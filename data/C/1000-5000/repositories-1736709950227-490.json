{
  "metadata": {
    "timestamp": 1736709950227,
    "page": 490,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rbsec/sslscan",
      "stars": 2372,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0078125,
          "content": "openssl\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.244140625,
          "content": "# object files\n*.o\n*.obj\n\n# compiled binary\nsslscan\nsslscan.exe\n\n# debian build of openssl\nopenssl-*/\nopenssl_*\nlibcrypto*\nlibssl*\n\n# custom openssl build\nopenssl/\n.openssl.is.fresh\n.openssl_mingw.is.fresh\n\n# custom zlib build for Windows\nzlib_mingw/"
        },
        {
          "name": "Changelog",
          "type": "blob",
          "size": 20.3798828125,
          "content": "Changelog\n=========\nVersion: 2.1.6\nDate   : 02/12/2024\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Flag CCM8 ciphers as weak and manually override their displayed\n\t\t bit strength to match newer versions of OpenSSL\n\t\t See https://github.com/openssl/openssl/pull/16652\n\nVersion: 2.1.5\nDate   : 21/09/2024\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Makefile improvements\n\nVersion: 2.1.4\nDate   : 16/06/2024\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Display the full cert chain --show-certificates (credit fhtino)\n\nVersion: 2.1.3\nDate   : 21/01/2024\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Enable quiet shutdown for scanning (credit jarnfast)\n\t\t > Fix Docker build on non-x64 architectures (credit jtesta)\n\nVersion: 2.1.2\nDate   : 14/11/2023\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix certificate and cipher enumeration when unsafe renegotiation is\n\t\t required(credit jtesta)\n\nVersion: 2.1.1\nDate   : 19/09/2023\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Work around several dodgy TLS implementations (credit jtesta)\n\nVersion: 2.1.0\nDate   : 05/09/2023\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Build against OpenSSL 3.0 instead of 1.1.0 (credit jtesta)\n\t\t > Improve CPU detection on OSX (tetlowgm)\n\nVersion: 2.0.16\nDate   : 08/04/2023\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix incorret detection of TLSv1.3 on Server 2019 (credit jtesta)\n\t\t > Fix incorrect XML certificate output\n\nVersion: 2.0.15\nDate   : 03/07/2022\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Obtain certificate info even if we can't connect properly\n\nVersion: 2.0.14\nDate   : 23/06/2022\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Strip out https:// from lines in a target file\n\nVersion: 2.0.13\nDate   : 03/04/2022\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix TLSv1.3 detection against Server 2022 (credit jtesta)\n\nVersion: 2.0.12\nDate   : 23/02/2022\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Add <not-yet-valid> XML element (credit lucacapacci)\n\nVersion: 2.0.11\nDate   : 16/12/2021\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Add --iana-names option to use IANA/RFC cipher names\n\t\t > Improve signature algorithm detection\n\nVersion: 2.0.10\nDate   : 27/04/2021\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Add the --connect-timeout option (credit alkalim)\n\t\t > Fix a typo in output\n\nVersion: 2.0.9\nDate   : 24/03/2021\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Warn on TLSv1.1, as it's now deprecated by RFC 8996\n\nVersion: 2.0.8\nDate   : 12/02/2021\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix a bug with LDAP STARTTLS\n\t\t > Fix certificate detection on some broken servers\n\t\t > Fix missing SCSV Fallback in XML output\n\nVersion: 2.0.7\nDate   : 10/02/2021\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Don't show server signature algorithms by default\n\t\t > Use --show-sigs to display them\n\nVersion: 2.0.6\nDate   : 31/10/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Flag certificates in red if CN is the same as issuer\n\nVersion: 2.0.5\nDate   : 24/10/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix --targets not working properly\n\nVersion: 2.0.4\nDate   : 13/10/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Remove the broken HTTP request scanning option (--http)\n\nVersion: 2.0.3\nDate   : 11/10/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix the extraneous padding of HTTP responses in XML\n\t\t > Update the HTTP request to HTTP/1.1\n\t\t > More robust checking the HTTP response is valid\n\t\t > Display \"No response\" when no HTTP response is returned\n\nVersion: 2.0.2\nDate   : 04/10/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Add <error> element to XML output\n\nVersion: 2.0.1\nDate   : 20/09/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix SNI name when using --targets\n\nVersion: 2.0.0\nDate   : 22/07/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Documentation updates\n\nVersion: 2.0.0-beta6\nDate   : 02/07/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Report servers that accept any signature algorithm in the XML\n\nVersion: 2.0.0-beta5\nDate   : 30/06/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Remove the \"Signature Algorithm:\" text and spacing from the XML.\n\nVersion: 2.0.0-beta4\nDate   : 10/06/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Add a new \"<certificates>\" element to the XML output.\n\nVersion: 2.0.0-beta3\nDate   : 10/06/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix a few compiler warnings.\n\t\t > Fix a regression where the \"strength\" attribute was missing.\n\nVersion: 2.0.0-beta2\nDate   : 10/05/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n\t\t > Fix a bug with servers that return incorrect cipher IDs.\n\t\t > Portability improvements.\n\t\t > Fix x86 windows build.\n\nVersion: 2.0.0-beta1\nDate   : 29/02/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Print curve name and key strength for ECC certs\n\t\t > Various documentation updates\n\nVersion: 2.0.0-alpha2\nDate   : 29/02/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Fix compilation on old versions of GCC.\n         > Minor changes to protocol support output.\n         > Strip a trailing slash from the specified target.\n         > Various other minor bugfixes.\n\nVersion: 2.0.0-alpha1\nDate   : 22/02/2020\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Major rewrite of backend scanning code.\n         > Support for additional cipher suites.\n         > Support for TLSv1.3\n         > Support for SSLv2 and SSLv3 protocol detection regardless of\n\t\t OpenSSL.\n         > Checks for server key exchange groups.\n         > Checks for server signature algorithms.\n\nVersion: 1.11.13\nDate   : 24/03/2019\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Added strength attribute to XML to reflect colouring in stdout\n\nVersion: 1.11.12\nDate   : 18/10/2018\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Enable colours in Windows console output if supported\n         > Include SCSV fallback in XML output\n         > Various bugfixes\n\nVersion: 1.11.11\nDate   : 31/12/2017\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Added -4 and -6 options to force IPv4 and IPv6.\n         > Fix build on Solaris and Windows.\n         > Fix cross-compiling.\n\nVersion: 1.11.10\nDate   : 04/05/2017\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Build against Peter Mosmans' branch of OpenSSL\n         > Support for ChaCha ciphers\n         > NOTE: you will need to run `make clean && make static`.\n\nVersion: 1.11.9\nDate   : 09/04/2017\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Add support for STARTTLS on mysql (--starttls-mysql)\n         > Display SNI information in XML output\n         > Fix some compiler warnings\n         > Mark SHA-1 certificates as weak\n         > Fix build on some platforms\n\nVersion: 1.11.8\nDate   : 06/11/2016\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Support alternate SNI hostnames (--sni=)\n         > Allow building with no support for TLS SCSV Fallback\n\nVersion: 1.11.7\nDate   : 13/06/2016\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Check for TLS Fallback SCSV\n         > Allow xml to be output on stdout (--xml=-)\n\nVersion: 1.11.6\nDate   : 09/04/2016\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Re-eanble support for weak (<1024) DH keys in OpenSSL\n\nVersion: 1.11.5\nDate   : 24/03/2016\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Fix bug in heartbleed check (credit nuxi)\n         > Makefile improvements and fixes for OSX and FreeBSD\n         > Optimize OpenSSL clone\n         > Implement --show-times to display handshake times in milliseconds\n\nVersion: 1.11.4\nDate   : 06/03/2016\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Fix compression detection (credit nuxi)\n         > Added support for PostgreSQL (credit nuxi)\n\nVersion: 1.11.3\nDate   : 03/03/2016\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Properly fix missing SSLv2 EXPORT ciphers by patching OpenSSL\n\nVersion: 1.11.2\nDate   : 02/03/2016\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Makefile improvements\n         > Update OpenSSL from Git when statically building\n         > Use enable-ssl2 and enable-weak-ciphers when building statically\n\nVersion: 1.11.1\nDate   : 11/12/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Show cipher IDs with --show-cipher-ids (credit maurice2k)\n         > Warn when building agsinst system OpenSSL rather than statically\n         > Allow building statically on OSX (experimental)\n\nVersion: 1.11.0\nDate   : 24/09/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Rewrote ciphersuite scanning engine to be much faster\n         > Ciphers are now output in order of server preference\n         > Most secure protocols are scanned first (TLSv1.2 -> SSLv2)\n         > All protocols are tried when trying to obtain the certificate\n         > Obselete --failed and --no-preferred-ciphers options removed\n         > Flag TLSv1.0 ciphers in output\n         > Flag 56 bit ciphers as red, not yellow\n         > Fix building on OpenBSD (credit Stuart Henderson)\n         > Fix incorrect output when server prefers NULL ciphers\n\nVersion: 1.10.6\nDate   : 06/08/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Fix --sleep only working for whole seconds (credit dmke)\n         > Fix compiling against OpenSSL 0.9.8 (credit aclemons)\n         > Flag expired certificates (credit jacktrice)\n\nVersion: 1.10.5\nDate   : 07/07/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Added IRC STARTTLS support (--starttls-irc, credit jkent)\n         > Highlight weak RSA keys in output\n         > Added option to show OCSP status (--ocsp, credit kelbyludwig)\n         > Fix a segfault with certificate parsing\n\nVersion: 1.10.4\nDate   : 21/06/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Display cipher details by default (hide with --no-cipher-details)\n         > Fix scanning multiple targets if one fails (credit shellster)\n         > Fix bug with --no-color and --failed (credit yasulib)\n         > Minor bugfixes to output\n\nVersion: 1.10.3\nDate   : 22/05/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Flag weak DHE keys in --cipher-details\n         > Report DHE key bits in XML\n         > Change ECDHE key bits to \"ecdhebits\" rather than \"dhebits\" in XML\n\nVersion: 1.10.2\nDate   : 12/05/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Wrap TLS extensions in CDATA blocks in XML output.\n         > Fix incorrect TLS versions in heartbleed checks\n\nVersion: 1.10.1\nDate   : 06/04/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Fix XML output to use \"TLSv1.0\" in preferred ciphers, not \"TLSv1\"\n         > Added --cipher-details option to display EC curves and EDH keys\n         Note that this feature requires OpenSSL >= 1.0.2\n         > Update static build options to compile against OpenSSL 1.0.2\n\nVersion: 1.10.0\nDate   : 28/02/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Experimental build support (credit jtesta).\n         > Support XMPP server-to-server connections (--xmpp-server).\n\nVersion: 1.9.11\nDate   : 03/02/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Makefile updates to assist packaging in Kali.\n         > Fix missing static build number when compiling from tarball.\n\nVersion: 1.9.10\nDate   : 24/01/2015\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Display certificate CN, Altnames and Issuer in default output.\n         > Flag certificates where CN == issuer, or CN = *\n         > Highlight GCM ciphersuites as good\n\nVersion: 1.9.9\nDate   : 22/01/2015\nAuthor : kyprizel <eldar@kyprizel.net>\nChanges: The following are a list of changes\n         > Added --show-client-cas option to determine trusted CAs\n         for client authentication\n         > Added --no-preferred option to disable any output except specified\n\nVersion: 1.9.8\nDate   : 08/12/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Added --sleep option to pause between request\n         > Only check for heartbleed against specified TLS version\n         > Added --sleep option to pause between request\n         > Fix issues compiling against OpenSSL 0.9.8\n         > Highlight CBC ciphersuites on SSLv3 (POODLE)\n         > Experimental build support on OSX (credit MikeSchroll)\n\nVersion: 1.9.7\nDate   : 26/10/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Added option for static compilation with OpenSSL (credit dmke)\n         > Added \"sslmethod\" attribute to Heartbleed XML output (credit dmke)\n         > Split headers into sslscan.h (credit dmke)\n\nVersion: 1.9.6\nDate   : 10/10/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Highlight NULL ciphers in output.\n         > Highlight SSLv3 ciphers.\n         > Added --rdp option to support RDP servers (credit skettler).\n         > Added --timeout option to set socket timeout (default 3s).\n\nVersion: 1.9.5\nDate   : 13/09/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Renamed --get-certificate option to --show-certficate.\n         > Display certificate signing algorithm highlighting weak algorithms.\n         > Display certificate key strength highlighting weak keys.\n         > Bumped XML version to 1.9.5 due to minor changes.\n\nVersion: 1.9.4\nDate   : 22/05/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Check for SSLv2 and SSLv3 ciphers over STARTTLS.\n\nVersion: 1.9.3\nDate   : 20/05/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Fixed broken STARTTLS SMTP check.\n\nVersion: 1.9.2\nDate   : 09/04/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Added check for OpenSSL Heartbleed (CVE-2014-0160).\n\nVersion: 1.9.1\nDate   : 06/03/2014\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Added --tlsall option to only scan TLS ciphersuites.\n         > Scan all TLS versions by default for STARTTLS services.\n         > Added support for IPv6 addresses using square bracket notation [:1].\n         > Highlight anonymous (ADH and AECDH) ciphers in output.\n         > Added option to disable colour in output (--no-colour).\n         > Removed undocumented -p output option.\n         > Removed old references to titania.co.uk domain.\n\nVersion: 1.9\nDate   : 30/12/2013\nAuthor : rbsec <robin@rbsec.net>\nChanges: The following are a list of changes\n         > Highlight SSLv2 ciphers\n         > Highlight weak (n <= 40 bit) and medium (40 < n <= 56 bit) ciphers\n         > Highlight RC4 ciphers\n         > Highlight anonymous (ADH) ciphers\n         > Hide certificate information by default\n         > Hide rejected ciphers by default (display with --failed).\n         > Added TLSv1.1 and TLSv1.2 support (merged from twwbond/sslscan).\n         > Compiles if OpenSSL does not support SSLv2 ciphers (merged from digineo/sslscan).\n         > Supports IPv6 hostnames (can be forced with --ipv6).\n         > Check for TLS compression (CRIME, disable with --no-compression)\n\nVersion: 1.8.4\nDate   : xx/xx/2010\nAuthor : Jacob Appelbaum <jacob@appelbaum.net>\nChanges: The following are a list of changes\n         > Add demo targets in Makefile\n         > Refactoring of code by Adam Langley\n         > Add SNI patch from Tim Brown\n         > Bug fixes from craSH and Cygwin build improvements\n\nVersion: 1.8.3\nDate   : 11/08/2010\nAuthor : Jacob Appelbaum <jacob@appelbaum.net>\nChanges: The following are a list of changes\n         > Improve new protocol setup support for STARTTLS:\n         POP3, IMAP, FTP, and XMPP\n         This modeled after the support found in OpenSSL's s_client\n         > Add verbose option to print more info\n         > Add default ports when a STARTTLS setup flag is called without\n         any port at all\n\nVersion: 1.8.2\nDate   : 19/06/2009\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Fixed output with HTML disabled\n            > Fixed XML critical\n\nVersion: 1.8.1\nDate   : 25/05/2009\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Fixed some compiler warnings.\n\nVersion: 1.8.0\nDate   : 19/05/2009\nAuthor : Ian Ventura-Whiting (Fizz)\nThanks : John Nichols\nChanges: The following are a list of changes\n         since the previous version:\n            > Added SSL implementation workaround\n              option.\n            > Added HTTP connection testing.\n            > Fixed Certification validation XML\n              output.\n\nVersion: 1.7.1\nDate   : 20/04/2008\nAuthor : Ian Ventura-Whiting (Fizz)\nThanks : Mark Lowe\nChanges: The following are a list of changes\n         since the previous version:\n            > Added HELO for SMTP checks\n            > Increased read buffer size\n\n\nVersion: 1.7\nDate   : 18/04/2008\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Added STARTTLS SMTP capability\n            > Fixed XML output format bug\n\nVersion: 1.6\nDate   : 30/12/2007\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Added man page.\n            > Improved certificate checking\n            > Added Makefile\n\nVersion: 1.5\nDate   : 25/09/2007\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Update to the license to make it\n              BINARY compatible with OpenSSL. Its\n              then easier for the packagers.\n\nVersion: 1.4\nDate   : 03/09/2007\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Added Server Certificate ouput.\n            > Added support for client certs.\n            > Added support for private keys\n              and password.\n            > Added support for PKCS#12.\n            > Fixed xml output.\n\nVersion: 1.3\nDate   : 06/08/2007\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Added XML file output option.\n            > Improved help text.\n            > Added program URL.\n\nVersion: 1.2\nDate   : 16/07/2007\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Removed unused variable\n            > Other minor changes.\n\nVersion: 1.1\nDate   : 13/07/2007\nAuthor : Ian Ventura-Whiting (Fizz)\nChanges: The following are a list of changes\n         since the previous version:\n            > Correction in banner text\n            > Host:Port now directly from the\n              command-line.\n\nVersion: 1.0\nDate   : 13/07/2007\nAuthor : Ian Ventura-Whiting (Fizz)\nNotes  : Initial version of sslscan\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.037109375,
          "content": "FROM alpine:latest as builder\n\n# Ensure no packages are cached before we try to do an update.\nRUN apk cache clean 2> /dev/null || exit 0\n\nRUN apk update && apk add gcc make ca-certificates git libc-dev linux-headers openssl perl zlib-dev\nRUN update-ca-certificates\n\nADD . builddir\n\n# Make a static build of sslscan, then strip it of debugging symbols.\nRUN cd builddir && make static\nRUN strip --strip-all /builddir/sslscan\n\n# Print the output of ldd so we can see what dynamic libraries that sslscan is still dependent upon.\nRUN echo \"ldd output:\" && ldd /builddir/sslscan\nRUN echo \"ls -al output:\" && ls -al /builddir/sslscan\n\n\n# Start with an empty container for our final build.\nFROM scratch\n\n# Copy over the sslscan executable from the intermediate build container, along with the dynamic libraries it is dependent upon (see output of ldd, above).\nCOPY --from=builder /builddir/sslscan /sslscan\nCOPY --from=builder /lib/libz.so.1 /lib/libz.so.1\nCOPY --from=builder /lib/ld-musl-*.so.1 /lib/\n\n# Drop root privileges.\nUSER 65535:65535\n\nENTRYPOINT [\"/sslscan\"]\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 2.4072265625,
          "content": "Requirements:\n   OpenSSL 0.9.8o or better\n\nMakefile build:\n      make\n      make install        (as root)\n\nManual Build:\n   sslscan can be built manually using the following\n   commands:\n\n      gcc -lssl -o sslscan sslscan.c\n      clang -lssl -o sslscan sslscan.c\n\n----\n\nThere are two ways to build a Windows executable:\n\n  1.) By cross-compiling on a Linux build machine using MinGW or Mingw-w64.\n\n  2.) By compiling on a Windows build machine using Visual Studio 2013\n      (other versions may also work, but are untested).\n\n  If you have a Debian-like Linux machine (such as Ubuntu or Kali), option\n#1 is BY FAR the easiest.  Note that installing Visual Studio and additional\ntools requires downloading gigabytes of data!\n\n  In any case, it is necessary to compile OpenSSL to ensure that all\nprotocols and algorithms are enabled (note that some systems that package\nOpenSSL have some deprecated features such as SSLv2 turned off for safety\nreasons; we actually need those to test with).\n\nPlease note that building on Windows (especially x86) is not supported, and\nyou may well encounter issues when trying to do so. Cross-compiling for x86\nfrom Debian Buster (10) is reported to work, but your mileage may vary.\n\n\nI. Cross-compiling from Linux\n\n  A. Building a 64-bit Windows executable\n\n    0.) Install Mingw-w64.  On Debian-like systems, this can be done with:\n        apt-get install mingw-w64\n\n    1.) Compile sslscan.  It will download the OpenSSL sources from GitHub\n        automatically:\n        make -f Makefile.mingw\n\n\n  B. Building a 32-bit Windows executable\n\n    0.) Install MinGW.  On Debian-like systems, this can be done with:\n        apt-get install mingw32\n\n    1.) Compile sslscan.  It will download the OpenSSL sources from GitHub\n        automatically:\n        make -f Makefile.mingw BUILD_32BIT=1\n\n\nII. Compiling on Windows using Visual Studio 2013 Express for Windows Desktop\n\n  A. Install Visual Studio 2013 Express for Windows Desktop:\n         http://go.microsoft.com/?linkid=9832280\n\n  B. Install the Windows Driver Kit 8.1:\n         http://go.microsoft.com/fwlink/p/?linkid=393659\n\n  C. Install ActivePerl Community Edition:\n         http://www.activestate.com/activeperl/downloads\n\n  D. In the VS2013 x64 Cross Tools Command Prompt, compile OpenSSL with:\n    perl Configure VC-WIN64A\n    ms\\do_win64a\n    nmake -f ms\\nt.mak\n\n  E. Inside the sslscan folder, compile sslscan with:\n    nmake -f Makefile.vs OPENSSL_PATH=path/to/openssl\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 31.7119140625,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.8349609375,
          "content": "# set gcc as default if CC is not set\n\nGIT_VERSION = $(shell git describe --tags --always --dirty=-wip)\n\n# Ugly hack to get version if git isn't installed\nifeq ($(GIT_VERSION),)\n  GIT_VERSION = $(shell grep -E -o -m 1 \"[0-9]+\\.[0-9]+\\.[0-9]+\" Changelog)\nendif\n\n# Detect OS\nOS := $(shell uname)\nARCH := $(shell uname -m)\n\n# Handle different version of Make\nifeq ($(OS), SunOS)\n\tifndef $(CC)\n\t\tCC=gcc\n\tendif\n\tifndef $(PREFIX)\n\t\tPREFIX = /usr\n\tendif\nelse\n\tCC ?= gcc\n\tPREFIX ?= /usr\nendif\n\nSRCS      = sslscan.c\nBINDIR    = $(PREFIX)/bin\nMANDIR    = $(PREFIX)/share/man\nMAN1DIR   = $(MANDIR)/man1\n\nWARNINGS  = -Wall -Wformat=2 -Wformat-security -Wno-deprecated-declarations\nDEFINES   = -DVERSION=\\\"$(GIT_VERSION)\\\"\n\n# for dynamic linking\nLIBS      = -lssl -lcrypto\nifneq ($(OS), FreeBSD)\nifneq ($(findstring MINGW64,$(OS)),MINGW64)\n\tLIBS += -ldl\nelse\n\tLIBS += -lwsock32 -lWs2_32\nendif\nendif\nifeq ($(OS), SunOS)\n\tCFLAGS += -m64\n\tLIBS   += -lsocket -lnsl\nendif\n\n# Enable checks for buffer overflows, add stack protectors, generate position\n# independent code, mark the relocation table read-only, and mark the global\n# offset table read-only.\nCFLAGS  += -D_FORTIFY_SOURCE=2 -fstack-protector-all -fPIE\n\n# Don't enable some hardening flags on OS X because it uses an old version of Clang\nifneq ($(OS), Darwin)\nifneq ($(OS), SunOS)\nifneq ($(findstring CYGWIN,$(OS)),CYGWIN)\nifneq ($(findstring MINGW64,$(OS)),MINGW64)\n\tLDFLAGS += -pie -z relro -z now\nelse\n\tLDFLAGS += -pie\nendif\nendif\nendif\nendif\n\n# Force C11 mode to fix the build on very old version of GCC\nCFLAGS += -std=gnu11\n\n# for static linking\nifeq ($(STATIC_BUILD), TRUE)\nPWD          = $(shell pwd)/openssl\nLDFLAGS      += -L${PWD}/\nCFLAGS       += -I${PWD}/include/ -I${PWD}/\nifeq ($(OS), Darwin)\nLIBS\t     = ./openssl/libssl.a ./openssl/libcrypto.a -lz -lpthread\nelse\nLIBS         = -lssl -lcrypto -lz -lpthread\nendif\nifneq ($(OS), FreeBSD)\nifneq ($(findstring CYGWIN,$(OS)),CYGWIN)\n\tLIBS += -ldl\nendif\nendif\nifeq ($(OS), SunOS)\n\tLIBS += -lsocket -lnsl\nendif\nGIT_VERSION  := $(GIT_VERSION)-static\nelse\n# for dynamic linking\nLDFLAGS   += -L/usr/local/lib -L/usr/local/ssl/lib -L/usr/local/opt/openssl/lib -L/opt/local/lib\nCFLAGS    += -I/usr/local/include -I/usr/local/ssl/include -I/usr/local/ssl/include/openssl -I/usr/local/opt/openssl/include -I/opt/local/include -I/opt/local/include/openssl\nendif\n\n# Find the number of processors on the system (used in -j option in building OpenSSL).\n# Uses /usr/bin/nproc if available, otherwise defaults to 1.\nNUM_PROCS = 1\nifneq (,$(wildcard /usr/bin/nproc))\n\tNUM_PROCS = `/usr/bin/nproc --all`\nendif\nifeq ($(OS), Darwin)\n\tNUM_PROCS = `sysctl -n hw.ncpu`\nendif\n\n.PHONY: all sslscan clean realclean install uninstall static opensslpull\n\nall: sslscan\n\t@echo\n\t@echo \"===========\"\n\t@echo \"| WARNING |\"\n\t@echo \"===========\"\n\t@echo\n\t@echo \"Building against system OpenSSL. Compression and other checks may not be possible.\"\n\t@echo \"It is recommended that you statically build sslscan with  \\`make static\\`.\"\n\t@echo\n\nsslscan: $(SRCS)\n\t$(CC) -o $@ ${WARNINGS} ${LDFLAGS} ${CFLAGS} ${CPPFLAGS} ${DEFINES} ${SRCS} ${LIBS}\n\ninstall:\n\t@if [ ! -f sslscan ] ; then \\\n\t\techo \"\\n=========\\n| ERROR |\\n=========\"; \\\n\t\techo \"Before installing you need to build sslscan with either \\`make\\` or \\`make static\\`\\n\"; \\\n\t\texit 1; \\\n\tfi\nifeq ($(OS), Darwin)\n\tinstall -d $(DESTDIR)$(BINDIR)/;\n\tinstall sslscan $(DESTDIR)$(BINDIR)/sslscan;\n\tinstall -d $(DESTDIR)$(MAN1DIR)/;\n\tinstall sslscan.1 $(DESTDIR)$(MAN1DIR)/sslscan.1;\nelse\n\tinstall -D sslscan $(DESTDIR)$(BINDIR)/sslscan;\n\tinstall -D sslscan.1 $(DESTDIR)$(MAN1DIR)/sslscan.1;\nendif\n\nuninstall:\n\trm -f $(DESTDIR)$(BINDIR)/sslscan\n\trm -f $(DESTDIR)$(MAN1DIR)/sslscan.1\n\n.openssl.is.fresh: opensslpull\n\ttrue\nopensslpull:\n\tif [ -d openssl -a -d openssl/.git ]; then \\\n\t\tcd ./openssl && git checkout `git ls-remote https://github.com/openssl/openssl | grep -Eo '(openssl-3\\.0\\.[0-9]+)' | sort --version-sort | tail -n 1` && git pull | grep -q \"Already up to date.\" && [ -e ../.openssl.is.fresh ] || touch ../.openssl.is.fresh ; \\\n\telse \\\n\tgit clone --depth 1 -b `git ls-remote https://github.com/openssl/openssl | grep -Eo '(openssl-3\\.0\\.[0-9]+)' | sort -V | tail -n 1` https://github.com/openssl/openssl ./openssl && cd ./openssl && touch ../.openssl.is.fresh ; \\\n\tfi\n\nopenssl/Makefile: .openssl.is.fresh\n\tcd ./openssl; ./Configure -v -fstack-protector-all -D_FORTIFY_SOURCE=2 -fPIC no-shared enable-weak-ssl-ciphers zlib\n\nopenssl/libcrypto.a: openssl/Makefile\n\t$(MAKE) -j $(NUM_PROCS) -C openssl depend\n\t$(MAKE) -j $(NUM_PROCS) -C openssl build_libs\n#\t$(MAKE) -j $(NUM_PROCS) -C openssl test # Disabled because this takes 45+ minutes for OpenSSL v1.1.1.\n\nstatic: openssl/libcrypto.a\n\t$(MAKE) -j $(NUM_PROCS) sslscan STATIC_BUILD=TRUE\n\ndocker:\n\tdocker build -t sslscan:sslscan .\n\ntest:\tstatic\n\t./docker_test.sh\n\nclean:\n\trm -f sslscan\n\nrealclean: clean\n\tif [ -d openssl ]; then ( rm -rf openssl ); fi;\n\trm -f .openssl.is.fresh\n"
        },
        {
          "name": "Makefile.mingw",
          "type": "blob",
          "size": 3.669921875,
          "content": "#\n# To build a 64-bit executable:  make -f Makefile.mingw\n# To build a 32-bit executable:  make -f Makefile.mingw BUILD_32BIT=1\n#\n\n\n# Enable to echo commands for debugging.\n#SHELL = sh -xv\n\n# If we're in Linux, lets see if we can find the path to Mingw automatically...\nARCHITECTURE=\nCC_PREFIX=\nOPENSSL_TARGET=\nifneq ($(BUILD_32BIT),)\n  DEFINES=-DBUILD_32BIT=1\nendif\n\nifeq ($(shell uname), Linux)\n  MINGW32=$(shell which i686-w64-mingw32-gcc)\n  ifneq ($(MINGW32),)\n    CC=$(MINGW32)\n    ARCHITECTURE=32-bit\n    CC_PREFIX=i686-w64-mingw32-\n    OPENSSL_TARGET=mingw\n  endif\n\n  MINGW64=$(shell which x86_64-w64-mingw32-gcc)\n  ifneq ($(MINGW64),)\n    ifeq ($(BUILD_32BIT),)\n      CC=$(MINGW64)\n      ARCHITECTURE=64-bit\n      CC_PREFIX=x86_64-w64-mingw32-\n      OPENSSL_TARGET=mingw64\n    endif\n  endif\nendif\n\nifndef CC\n  $(error \"Failed to determine the compiler!\")\nendif\n\n.PHONY: clean\n\n# Enable security options like stack protectors and variable formatting checks.\n# Sadly, we can't use -pie, because MinGW produces a broken executable when\n# enabled.\nSECURITY_OPTIONS=-fstack-protector-all -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security\n\n# Turn on linker optimizations, and DEP support (--nxcompat)\nLINK_OPTIONS=-Wl,-O1 -Wl,--discard-all -Wl,--no-undefined -Wl,--dynamicbase -Wl,--nxcompat -static\n\nCFLAGS += -Iopenssl_mingw/include -D__USE_GNU -DOPENSSL_NO_SSL2 -Wno-deprecated-declarations\nLDFLAGS += -lws2_32 -lgdi32 -lcrypt32\n\n# Set the version string for the program.\nVERSION = \"$(shell grep -E -o -m 1 '[0-9]+\\.[0-9]+\\.[0-9]+(\\-[a-z]+[0-9]+)?' Changelog) Windows $(ARCHITECTURE) (Mingw)\"\n\n\nall: sslscan\n\n.openssl_mingw.is.fresh: opensslpull\n\ttrue\n\nzlibpull:\n#\tIf the zlib dir already exists, issue a pull, otherwise clone it from GitHub.  Either way, check out the latest tag.\n\tif [ -d zlib_mingw -a -d zlib_mingw/.git ]; then \\\n\t\tcd ./zlib_mingw && git pull && git checkout tags/`git describe --abbrev=0 --tags` ; \\\n\telse \\\n\t\tgit clone -b master --depth 1 https://github.com/madler/zlib ./zlib_mingw && cd ./zlib_mingw && git checkout tags/`git describe --abbrev=0` ; \\\n\tfi\n\nopensslpull:\n\tif [ -d openssl_mingw -a -d openssl_mingw/.git ]; then \\\n\t\tcd ./openssl_mingw && git checkout `git ls-remote https://github.com/openssl/openssl | grep -Eo '(openssl-3\\.0\\.[0-9]+)' | sort --version-sort | tail -n 1` && git pull | grep -q \"Already up-to-date.\" && [ -e ../.openssl_mingw.is.fresh ] || touch ../.openssl_mingw.is.fresh ; \\\n\telse \\\n\tgit clone --depth 1 -b `git ls-remote https://github.com/openssl/openssl | grep -Eo '(openssl-3\\.0\\.[0-9]+)' | sort --version-sort | tail -n 1` https://github.com/openssl/openssl ./openssl_mingw && cd ./openssl_mingw && touch ../.openssl_mingw.is.fresh ; \\\n\tfi\n\nzlib_mingw/libz.a: zlibpull\n\tcd ./zlib_mingw; make -f win32/Makefile.gcc PREFIX=$(CC_PREFIX)\n\nopenssl_mingw/Makefile: .openssl_mingw.is.fresh zlib_mingw/libz.a\n\tcd ./openssl_mingw; ./Configure --cross-compile-prefix=$(CC_PREFIX) --with-zlib-include=`pwd`/../zlib_mingw --with-zlib-lib=`pwd`/../zlib_mingw -fstack-protector-all -D_FORTIFY_SOURCE=2 $(OPENSSL_TARGET) no-shared enable-weak-ssl-ciphers enable-ssl2 zlib\n\nopenssl_mingw/libcrypto.a: openssl_mingw/Makefile\n\t$(MAKE) -C openssl_mingw depend CC=$(CC)\n\t$(MAKE) -j 10 -C openssl_mingw all CC=$(CC)\n\nsslscan: openssl_mingw/libcrypto.a sslscan.c\n\t$(CC) $(CFLAGS) -DVERSION=\\\"$(VERSION)\\\" $(DEFINES) $(SECURITY_OPTIONS) $(LINK_OPTIONS) -o sslscan.exe sslscan.c openssl_mingw/libssl.a openssl_mingw/libcrypto.a zlib_mingw/libz.a $(LDFLAGS)\n\t$(CC_PREFIX)strip sslscan.exe\n\nclean:\n\trm -f *.o sslscan.exe .openssl_mingw.is.fresh\n\tif [ -f openssl_mingw/Makefile ]; then $(MAKE) -C openssl_mingw clean; fi\n\tif [ -f zlib_mingw/win32/Makefile.gcc ]; then $(MAKE) -C zlib_mingw -f win32/Makefile.gcc clean; fi\n"
        },
        {
          "name": "Makefile.vs",
          "type": "blob",
          "size": 0.50390625,
          "content": "LFLAGS=/nologo /dynamicbase /highentropyva /nxcompat /opt:ref /subsystem:console /ltcg\nCFLAGS=/nologo /GL /GS /Gs0 /Gw /MT /Ox -DVERSION=\"\\\"1.9.8 Windows 64-bit (VS)\\\"\"\n\nall: sslscan.exe\n\nsslscan.obj: sslscan.c\n\tcl.exe $(CFLAGS) /I $(OPENSSL_PATH)/include /c sslscan.c\n\nsslscan.exe: sslscan.obj\n\tlink.exe $(LFLAGS) /out:sslscan.exe sslscan.obj $(OPENSSL_PATH)/out32/libeay32.lib $(OPENSSL_PATH)/out32/ssleay32.lib advapi32.lib gdi32.lib user32.lib ws2_32.lib\n\nclean:\n\tdel sslscan.obj sslscan.exe\n\nrebuild: clean all\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.0078125,
          "content": "# sslscan2\n\nsslscan version 2 has now been released. This includes a major rewrite of the backend scanning code, which means that it is no longer reliant on the version of OpenSSL for many checks. This means that it is possible to support legacy protocols (SSLv2 and SSLv3), as well as supporting TLSv1.3 - regardless of the version of OpenSSL that it has been compiled against.\n\nThis has been made possible largely by the work of [jtesta](https://github.com/jtesta), who has been responsible for most of the backend rewrite.\n\nOther key changes include:\n\n* Enumeration of server key exchange groups.\n* Enumeration of server signature algorithms.\n* SSLv2 and SSLv3 protocol support is scanned, but individual ciphers are not.\n* A test suite is included using Docker, to verify that sslscan is functionality correctly.\n* Removed the `--http` option, as it was broken and had very little use in the first place.\n\n## XML Output Changes\nA potentially breaking change has been made to the XML output in version **2.0.0-beta4**. Previously, multiple `<certificate>` elements could be returned (one by default, and a second one if `--show-certificate` was used).\n\nThe key changes are:\n\n* A new parent `<certificates>` element that will contain the `<certificate>` elements.\n* `<certificate>` elements have a new `type` attribute, which can either be:\n  * `short` for the default output.\n  * `full` for when `--show-certificate` is used.\n* There will potentially be more than one certificate of each type returned on servers that have multiple certificates with different signature algorithms (see discussion in issue [#208](https://github.com/rbsec/sslscan/issues/208)).\n* The `<signature-algorithm>` element in a `<certificate>` no longer contains the \"Signature Algorithm:\" prefix, or the spacing and newline.\n\nIf you are using the XML output, then you may need to make changes to your parser.\n\n# README\n\n[![ci](https://github.com/rbsec/sslscan/actions/workflows/ci.yml/badge.svg)](https://github.com/rbsec/sslscan/actions/workflows/ci.yml)\n\nThis is a fork of ioerror's version of sslscan (the original readme of which is included below) by rbsec (robin@rbsec.net).\n\nKey changes are as follows:\n\n* Highlight SSLv2 and SSLv3 ciphers in output.\n* Highlight CBC ciphers on SSLv3 (POODLE).\n* Highlight 3DES and RC4 ciphers in output.\n* Highlight PFS+GCM ciphers as good in output.\n* Highlight NULL (0 bit), weak (<40 bit) and medium (40 < n <= 56) ciphers in output.\n* Highlight anonymous (ADH and AECDH) ciphers in output (purple).\n* Hide certificate information by default (display with `--show-certificate`).\n* Hide rejected ciphers by default (display with `--failed`).\n* Added TLSv1.1, TLSv1.2 and TLSv1.3 support.\n* Supports IPv6  (can be forced with `--ipv6`).\n* Check for TLS compression (CRIME, disable with `--no-compression`).\n* Disable cipher suite checking `--no-ciphersuites`.\n* Disable coloured output `--no-colour`.\n* Removed undocumented -p output option.\n* Added check for OpenSSL HeartBleed (CVE-2014-0160, disable with `--no-heartbleed`).\n* Flag certificates signed with MD5 or SHA-1, or with short (<2048 bit) RSA keys.\n* Support scanning RDP servers with `--rdp` (credit skettler).\n* Added option to specify socket timeout.\n* Added option for static compilation (credit dmke).\n* Added `--sleep` option to pause between requests.\n* Disable output for anything than specified checks `--no-preferred`.\n* Determine the list of CAs acceptable for client certificates `--show-client-cas`.\n* Experimental build support on OS X (credit MikeSchroll).\n* Flag some self-signed SSL certificates.\n* Experimental Windows support (credit jtesta).\n* Display EC curve names and DHE key lengths with OpenSSL >= 1.0.2 `--no-cipher-details`.\n* Flag weak DHE keys with OpenSSL >= 1.0.2 `--cipher-details`.\n* Flag expired certificates.\n* Flag TLSv1.0 and TLSv1.1 protocols in output as weak.\n* Experimental OS X support (static building only).\n* Support for scanning PostgreSQL servers (credit nuxi).\n* Check for TLS Fallback SCSV support.\n* Added StartTLS support for LDAP `--starttls-ldap`.\n* Added SNI support `--sni-name` (credit Ken).\n* Support STARTTLS for MySQL (credit bk2017).\n* Check for supported key exchange groups.\n* Check for supported server signature algorithms.\n* Display IANA/RFC cipher names `--iana-names`\n* Display the full certifiate chain `--show-certificates`\n\n### Building on Linux\n\nIt is possible to ignore the OpenSSL system installation and ship your own version. Although this results in a more resource-heavy `sslscan` binary (file size, memory consumption, etc.), this allows some additional checks such as TLS compression.\n\nTo compile your own OpenSSL version, you'll probably need to install the OpenSSL build dependencies. The commands below can be used to do this on Debian.\n\n    apt install git zlib1g-dev make gcc\n\nThen run\n\n    make static\n\nThis will clone the [OpenSSL repository](https://github.com/openssl/openssl), and configure/compile/test OpenSSL prior to compiling `sslscan`.\n\n**Please note:** By default, OpenSSL is compiled with `gcc` without further customization. To compile with `clang`, install build dependencies using the commands below.\n\n    apt install git zlib1g-dev make clang\n\nThen run\n\n    make static CC=clang\n\nYou can verify whether you have a statically linked OpenSSL version, by checking whether the version listed by `sslscan --version` has the `-static` suffix.\n\n### Building with Docker\n\nEnsure that you local Docker installation is functional, and the build the container with:\n\n    make docker\n\nOr manually with:\n\n    docker build -t sslscan:sslscan .\n\nYou can then run sslscan with:\n\n    docker run --rm -ti sslscan:sslscan --help\n\n### Building on Windows\n\nThanks to a patch by jtesta, sslscan can now be compiled on Windows. This can either be done natively or by cross-compiling from Linux. See INSTALL for instructions.\n\nNote that sslscan was originally written for Linux, and has not been extensively tested on Windows. As such, the Windows version should be considered experimental.\n\nPre-build cross-compiled Windows binaries are available on the [GitHub Releases Page](https://github.com/rbsec/sslscan/releases).\n\n### Building on OS X\nThere is experimental support for statically building on OS X, however this should be considered unsupported. You may need to install any dependencies required to compile OpenSSL from source on OS X. Once you have, just run:\n\n    make static\n\n# Original (ioerror) README\nThis is a fork of sslscan.c to better support STARTTLS.\n\nThe original home page of sslscan is:\n\n    http://www.titania.co.uk\n\nsslscan was originally written by:\n\n    Ian Ventura-Whiting\n\nThe current home page of this fork (until upstream merges a finished patch) is:\n\n    http://www.github.com/ioerror/sslscan\n\nMost of the pre-TLS protocol setup was inspired by the OpenSSL s_client.c\nprogram. The goal of this fork is to eventually merge with the original\nproject after the STARTTLS setup is polished.\n\nSome of the OpenSSL setup code was borrowed from The Tor Project's Tor program.\nThus it is likely proper to comply with the BSD license by saying:\n    Copyright (c) 2007-2010, The Tor Project, Inc.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.85546875,
          "content": "Fix session resumption test\n    We have a false positive for session resumption\n    IDs are assigned but not accepted for resumption\nFix the certificate formatting (prefix it with whitespace)\nAdd support for SOCKS5 proxy (or audit for 'usewithtor')\n    It seems to work fine with 'usewithtor'\n    It still seems prudent to add proper proxy support\nFix XMPP scans that do not support StartTLS:\n    \"<stream:error><invalid-namespace xmlns='urn:ietf:params:xml:ns:xmpp-streams'/></stream:error>\"\nAdd HTML report generation\nAdd diff between reported and actually supported ciphers\nMake a Debian package\nWe should explicitly check for things that may be NULL; the original author was not very careful.\nPerhaps write a GUI for people who are console adverse?\nCompare with http://www.thesprawl.org/memdump/?entry=7\nFinally, we should send a diff from 1.8.2 to the upstream developer\n"
        },
        {
          "name": "docker_test.sh",
          "type": "blob",
          "size": 21.4443359375,
          "content": "#!/bin/bash\n\n#\n# Copyright (C) 2019-2020  Joe Testa <jtesta@positronsecurity.com>\n#\n# This script (adapted from the ssh-audit project) will set up a docker image with\n# multiple SSL/TLS servers.  They are each executed one at a time, and sslscan is run\n# against them.  The output of sslscan is compared against the expected output.  If\n# they match, the test passes; otherwise the test fails.\n#\n#\n# For debugging purposes, here is a cheat sheet for manually running the docker image:\n#\n# docker run -p 4443:443 --security-opt seccomp:unconfined -it sslscan-test:3 /bin/bash\n#\n\n#\n# Running this script with no arguments causes it to build the docker image (if it\n# doesn't yet exist), then run all tests.\n#\n# Running the script with a test number argument (i.e.: './docker_test.sh 2') will\n# run the docker image for test #2 only (in the background) and do nothing else.  This\n# allows the test itself to be debugged.\n#\n\n\n# This is the docker tag for the image.  If this tag doesn't exist, then we assume the\n# image is out of date, and generate a new one with this tag.\nIMAGE_VERSION=3\n\n# This is the name of our docker image.\nIMAGE_NAME=sslscan-test\n\n\n# Terminal colors.\nCLR=\"\\033[0m\"\nRED=\"\\033[0;31m\"\nGREEN=\"\\033[0;32m\"\nREDB=\"\\033[1;31m\"    # Red + bold\nYELLOWB=\"\\033[1;33m\" # Yellow + bold\nGREENB=\"\\033[1;32m\"  # Green + bold\n\n# Set to 0 if any test fails.\nall_passed=1\n\n\n# Number of processors on this system (used to compile parallel builds).\nNUM_PROCS=`/usr/bin/nproc --all 2> /dev/null`\nif [[ $NUM_PROCS == '' ]]; then\n    NUM_PROCS=4\nfi\n\n\n# Returns 0 if current docker image exists.\nfunction check_if_docker_image_exists {\n    images=`docker image ls | grep -E \"$IMAGE_NAME[[:space:]]+$IMAGE_VERSION\"`\n}\n\n\n# Compile all version of GnuTLS.\nfunction compile_gnutls_all {\n    compile_gnutls '3.6.11.1'\n}\n\n\n# Compile all versions of OpenSSL.\nfunction compile_openssl_all {\n    compile_openssl '1.0.0'\n    compile_openssl '1.0.2'\n    compile_openssl '1.1.1'\n}\n\n\n# Compile a specific version of OpenSSL.\nfunction compile_openssl {\n    version=$1\n\n    git_tag=\n    compile_args=\n    precompile_command=\n    output_dir=\n    compile_num_procs=$NUM_PROCS\n    if [[ $version == '1.0.0' ]]; then\n\tgit_tag=\"OpenSSL_1_0_0-stable\"\n\tcompile_args=\"enable-weak-ssl-ciphers enable-ssl2 zlib no-shared\"\n\tprecompile_command=\"make depend\"\n\toutput_dir=\"openssl_v1.0.0_dir\"\n\tcompile_num_procs=1   # Compilation randomly fails when done in parallel.\n    elif [[ $version == '1.0.2' ]]; then\n\tgit_tag=\"OpenSSL_1_0_2-stable\"\n\tcompile_args=\"enable-weak-ssl-ciphers enable-ssl2 zlib\"\n\tprecompile_command=\"make depend\"\n\toutput_dir=\"openssl_v1.0.2_dir\"\n    elif [[ $version == '1.1.1' ]]; then\n\tgit_tag=\"OpenSSL_1_1_1-stable\"\n\tcompile_args=\"enable-weak-ssl-ciphers no-shared zlib\"\n\toutput_dir=\"openssl_v1.1.1_dir\"\n    else\n\techo -e \"${REDB}Error: OpenSSL v${version} is unknown!${CLR}\"\n\texit 1\n    fi\n\n    # Download OpenSSL from github.\n    echo -e \"\\n${YELLOWB}Downloading OpenSSL v${version}...${CLR}\\n\"\n    git clone --depth 1 -b $git_tag https://github.com/openssl/openssl/ $output_dir\n\n    # Configure and compile it.\n    echo -e \"\\n\\n${YELLOWB}Compiling OpenSSL v${version} with \\\"-j ${compile_num_procs}\\\"...${CLR}\"\n    pushd $output_dir\n    ./config $compile_args\n    if [[ $precompile_command != '' ]]; then $precompile_command; fi\n    make -j $compile_num_procs\n\n    # Ensure that the 'openssl' command-line tool was built.\n    if [[ ! -f \"apps/openssl\" ]]; then\n\techo -e \"${REDB}Error: compilation failed!  apps/openssl not found.${CLR}\\n\\nStrangely, sometimes OpenSSL v1.0.0 fails for no reason; simply running this script again and changing nothing fixes the problem.\\n\\n\"\n\texit 1\n    fi\n\n    # Copy the 'openssl' app to the top-level docker building dir as, e.g. 'openssl_prog_v1.0.0'.  Then we can delete the source code directory and move on.\n    cp \"apps/openssl\" \"../openssl_prog_v${version}\"\n    popd\n\n    # Delete the source code directory now that we built the 'openssl' tool and moved it out.\n    rm -rf $output_dir\n    echo -e \"\\n\\n${YELLOWB}Compilation of v${version} finished.${CLR}\\n\\n\"\n}\n\n\n# Compile a specific version of GnuTLS.\nfunction compile_gnutls {\n    gnutls_version=$1\n\n    gnutls_url=\n    nettle_url=\n    gnutls_expected_sha256=\n    nettle_expected_sha256=\n    gnutls_filename=\n    nettle_filename=\n    gnutls_source_dir=\n    nettle_source_dir=\n    nettle_version=\n    compile_num_procs=$NUM_PROCS\n    compile_nettle=0\n    if [[ $gnutls_version == '3.6.11.1' ]]; then\n\tgnutls_url=https://www.gnupg.org/ftp/gcrypt/gnutls/v3.6/gnutls-3.6.11.1.tar.xz\n\tgnutls_expected_sha256=fbba12f3db9a55dbf027e14111755817ec44b57eabec3e8089aac8ac6f533cf8\n\tgnutls_filename=gnutls-3.6.11.1.tar.xz\n\tgnutls_source_dir=gnutls-3.6.11.1\n\tnettle_version=3.5.1\n\tnettle_url=https://ftp.gnu.org/gnu/nettle/nettle-3.5.1.tar.gz\n\tnettle_expected_sha256=75cca1998761b02e16f2db56da52992aef622bf55a3b45ec538bc2eedadc9419\n\tnettle_filename=nettle-3.5.1.tar.gz\n\tnettle_source_dir=nettle-3.5.1\n\tcompile_nettle=1\n    else\n\techo -e \"${REDB}Error: GnuTLS v${gnutls_version} is unknown!${CLR}\"\n\texit 1\n    fi\n\n    # Download GnuTLS.\n    echo -e \"\\n${YELLOWB}Downloading GnuTLS v${gnutls_version}...${CLR}\\n\"\n    wget $gnutls_url\n\n    # Download nettle.\n    echo -e \"\\n${YELLOWB}Downloading nettle library v${nettle_version}...${CLR}\\n\"\n    wget $nettle_url\n\n    # Check the SHA256 hashes.\n    gnutls_actual_sha256=`sha256sum ${gnutls_filename} | cut -f1 -d\" \"`\n    nettle_actual_sha256=`sha256sum ${nettle_filename} | cut -f1 -d\" \"`\n\n    if [[ ($gnutls_actual_sha256 != $gnutls_expected_sha256) || ($nettle_actual_sha256 != $nettle_expected_sha256) ]]; then\n\techo -e \"${REDB}GnuTLS/nettle actual hashes differ from expected hashes! ${CLR}\\n\"\n\techo -e \"\\tGnuTLS expected hash: ${gnutls_expected_sha256}\\n\"\n\techo -e \"\\tGnuTLS actual hash:   ${gnutls_actual_sha256}\\n\"\n\techo -e \"\\tnettle expected hash: ${nettle_expected_sha256}\\n\"\n\techo -e \"\\tnettle actual hash:   ${nettle_actual_sha256}\\n\\n\"\n\texit 1\n    else\n\techo -e \"${GREEN}Hashes verified.${CLR}\\n\"\n    fi\n\n    tar xJf $gnutls_filename\n\n    if [[ $compile_nettle == 1 ]]; then\n\ttar xzf $nettle_filename\n\tmv $nettle_source_dir nettle\n\n\t# Configure and compile nettle.\n\techo -e \"\\n\\n${YELLOWB}Compiling nettle v${nettle_version} with \\\"-j ${compile_num_procs}\\\"...${CLR}\"\n\tpushd nettle\n\t./configure && make -j $compile_num_procs\n\n\tif [[ ! -f libnettle.so || ! -f libhogweed.so ]]; then\n\t    echo -e \"${REDB}Error: compilation failed!  libnettle.so and/or libhogweed.so not found.${CLR}\"\n\t    exit 1\n\tfi\n\tpopd\n    fi\n\n    # Configure and compile GnuTLS.\n    echo -e \"\\n\\n${YELLOWB}Compiling GnuTLS v${gnutls_version} with \\\"-j ${compile_num_procs}\\\"...${CLR}\"\n    pushd $gnutls_source_dir\n    nettle_source_dir_abs=`readlink -m ../nettle`\n    nettle_parent_dir=`readlink -m ..`\n    NETTLE_CFLAGS=-I${nettle_parent_dir} NETTLE_LIBS=\"-L${nettle_source_dir_abs} -lnettle\" HOGWEED_CFLAGS=-I${nettle_parent_dir} HOGWEED_LIBS=\"-L${nettle_source_dir_abs} -lhogweed\" ./configure --with-included-libtasn1 --with-included-unistring --without-p11-kit --disable-guile\n    make CFLAGS=-I${nettle_parent_dir} LDFLAGS=\"-L${nettle_source_dir_abs} -lhogweed -lnettle\" -j $compile_num_procs\n\n    # Ensure that the gnutls-serv and gnutls-cli tools were built\n    if [[ (! -f \"src/.libs/gnutls-cli\") || (! -f \"src/.libs/gnutls-serv\") ]]; then\n\techo -e \"${REDB}Error: compilation failed!  gnutls-cli and/or gnutls-serv not found.${CLR}\\n\"\n\texit 1\n    fi\n\n    # Copy the gnutls-cli and gnutls-serv apps to the top-level docker building dir as, e.g. 'gnutls-cli-v3.6.11.1'.  Then we can delete the source code directory and move on.\n    cp \"lib/.libs/libgnutls.so\" \"../libgnutls.so.30\"\n    cp \"src/.libs/gnutls-cli\" \"../gnutls-cli-v${gnutls_version}\"\n    cp \"src/.libs/gnutls-serv\" \"../gnutls-serv-v${gnutls_version}\"\n    cp \"${nettle_source_dir_abs}/libhogweed.so\" \"../libhogweed.so.5\"\n    cp \"${nettle_source_dir_abs}/libnettle.so\" \"../libnettle.so.7\"\n    popd\n\n\n    # Delete the source code directory now that we built the tools and moved them out.\n    rm -rf ${gnutls_source_dir}\n    echo -e \"\\n\\n${YELLOWB}Compilation of GnuTLS v${gnutls_version} finished.${CLR}\\n\\n\"\n}\n\n\n# Creates a new docker image.\nfunction create_docker_image {\n    # Create a new temporary directory.\n    TMP_DIR=`mktemp -d /tmp/sslscan-docker-XXXXXXXXXX`\n\n    # Copy the Dockerfile and all files in the test/docker/ dir to our new temp directory.\n    find docker_test -maxdepth 1 -type f | xargs cp -t $TMP_DIR\n\n    # Make the temp directory our working directory for the duration of the build\n    # process.\n    pushd $TMP_DIR > /dev/null\n\n    # Compile the versions of OpenSSL.\n    compile_openssl_all\n\n    # Compile the versions of GnuTLS.\n    compile_gnutls_all\n\n    # Now build the docker image!\n    echo -e \"${YELLOWB}Creating docker image...$IMAGE_NAME:$IMAGE_VERSION ${CLR}\"\n    docker build --tag $IMAGE_NAME:$IMAGE_VERSION .\n    echo -e \"${YELLOWB}Docker image creation complete.${CLR}\"\n\n    popd > /dev/null\n    rm -rf $TMP_DIR\n}\n\n\n# Runs all tests with the debug flag disabled.\nfunction run_tests {\n    run_test_1 \"0\"\n    run_test_2 \"0\"\n    run_test_3 \"0\"\n    run_test_4 \"0\"\n    run_test_5 \"0\"\n    run_test_6 \"0\"\n    run_test_7 \"0\"\n    run_test_8 \"0\"\n    run_test_9 \"0\"\n    run_test_10 \"0\"\n    run_test_11 \"0\"\n    run_test_12 \"0\"\n    run_test_13 \"0\"\n    run_test_14 \"0\"\n    run_test_15 \"0\"\n    run_test_16 \"0\"\n    run_test_17 \"0\"\n    run_test_18 \"0\"\n}\n\n\n# Mostly default v1.0.2 (SSLv3, TLSv1.0, TLSv1.1, TLSv1.2)\nfunction run_test_1 {\n    run_test $1 '1' \"/openssl_v1.0.2/openssl s_server -accept 443 -dhparam /etc/ssl/dhparams_2048.pem -key /etc/ssl/key_2048.pem -cert /etc/ssl/cert_2048.crt\" \"\"\n}\n\n\n# SSLv2 with 1024-bit certificate & DH parameters.\nfunction run_test_2 {\n    run_test $1 '2' \"/openssl_v1.0.2/openssl s_server -ssl2 -accept 443 -dhparam /etc/ssl/dhparams_1024.pem -key /etc/ssl/key_1024.pem -cert /etc/ssl/cert_1024.crt\" \"\"\n}\n\n\n# SSLv3 with 1024-bit certificate & DH parameters.\nfunction run_test_3 {\n    run_test $1 '3' \"/openssl_v1.0.2/openssl s_server -ssl3 -accept 443 -dhparam /etc/ssl/dhparams_1024.pem -key /etc/ssl/key_1024.pem -cert /etc/ssl/cert_1024.crt\" \"\"\n}\n\n\n# Mostly default v1.1.1.\nfunction run_test_4 {\n    run_test $1 '4' \"/openssl_v1.1.1/openssl s_server -accept 443 -dhparam /etc/ssl/dhparams_3072.pem -key /etc/ssl/key_3072.pem -cert /etc/ssl/cert_3072.crt\" \"\"\n}\n\n\n# All ciphers with SSLv2 through TLSv1.2 with 1024-bit certificate & DH parameters.\nfunction run_test_5 {\n    run_test $1 '5' \"/openssl_v1.0.2/openssl s_server -cipher ALL -accept 443 -dhparam /etc/ssl/dhparams_1024.pem -key /etc/ssl/key_1024.pem -cert /etc/ssl/cert_1024.crt\" \"\"\n}\n\n\n# TLSv1.3 with all ciphers.\nfunction run_test_6 {\n    run_test $1 '6' \"/openssl_v1.1.1/openssl s_server -tls1_3 -ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_CCM_SHA256:TLS_AES_128_CCM_8_SHA256 -accept 443 -dhparam /etc/ssl/dhparams_3072.pem -key /etc/ssl/key_3072.pem -cert /etc/ssl/cert_3072.crt\" \"\"\n}\n\n\n# Default v1.0.0.\nfunction run_test_7 {\n    run_test $1 '7' \"/openssl_v1.0.0/openssl s_server -accept 443 -key /etc/ssl/key_3072.pem -cert /etc/ssl/cert_3072.crt\" \"\"\n}\n\n\n# v1.0.0 with 'ALL:eNULL' ciphers.\nfunction run_test_8 {\n    run_test $1 '8' \"/openssl_v1.0.0/openssl s_server -accept 443 -cipher ALL:eNULL -key /etc/ssl/key_3072.pem -cert /etc/ssl/cert_3072.crt\" \"\"\n}\n\n\n# Runs nginx with client certificate checking (signed by the CA in docker_test/ca_cert.pem).  sslscan will connect and make an HTTP request (--http).  The HTTP response code should be 200 to signify that the certificate was accepted.  Otherwise, nginx returns HTTP code 400 if no client certificates were presented.\nfunction run_test_9 {\n    #run_test $1 '9' \"/usr/sbin/nginx -c /etc/nginx/nginx_test9.conf\" \"--no-fallback --no-renegotiation --no-compression --no-heartbleed --certs=docker_test/cert_3072.crt --pk=docker_test/key_3072.pem --http\"\n    echo \"Test #9 skipped.\"\n}\n\n\n# Runs nginx with client certificate checking, just as above.  Except this time, we connect with no certificate.  The HTTP response code should be \"400 Bad Request\".\nfunction run_test_10 {\n    #run_test $1 '10' \"/usr/sbin/nginx -c /etc/nginx/nginx_test9.conf\" \"--no-fallback --no-renegotiation --no-compression --no-heartbleed --http\"\n    echo \"Test #10 skipped.\"\n}\n\n\n# Makes an OCSP request to www.amazon.com.  The horrible Perl command that comes after it will filter out the timestamps and other variable data from the response, otherwise the diff would fail.\nfunction run_test_11 {\n    run_test_internet '11' \"./sslscan --ocsp --no-ciphersuites --no-fallback --no-renegotiation --no-compression --no-heartbleed --no-check-certificate --no-groups --no-sigs www.amazon.com | perl -pe 'BEGIN{undef $/;} s/Connected to .+?$/Connected to\\033[0m/smg; s/Responder Id: .+?$/Responder Id:/smg; s/Produced At: .+?$/Produced At:/smg; s/Hash Algorithm: .+?$/Hash Algorithm:/smg; s/Issuer Name Hash: .+?$/Issuer Name Hash:/smg; s/Issuer Key Hash: .+?$/Issuer Key Hash:/smg; s/Serial Number: .+?$/Serial Number:/smg; s/This Update: .+?$/This Update:/smg; s/Next Update: .+?$/Next Update:/smg; s/Response Single Extensions:.+?\\n\\n/\\n\\n/smg;'\"\n}\n\n\n# 512-bit DH, 512-bit RSA key with MD5 signature.\nfunction run_test_12 {\n    run_test $1 '12' \"/openssl_v1.0.0/openssl s_server -accept 443 -dhparam /etc/ssl/dhparams_512.pem -key /etc/ssl/key_512.pem -cert /etc/ssl/cert_512.crt\" \"\"\n}\n\n\n# Default GnuTLS.\nfunction run_test_13 {\n    run_test $1 '13' \"/gnutls-3.6.11.1/gnutls-serv -p 443 --x509certfile=/etc/ssl/cert_3072.crt --x509keyfile=/etc/ssl/key_3072.pem\" \"\"\n}\n\n\n# GnuTLS with only TLSv1.2 and TLSv1.3, and secp521r1 and ffdhe8192 groups.\nfunction run_test_14 {\n    run_test $1 '14' \"/gnutls-3.6.11.1/gnutls-serv -p 443 --priority=NORMAL:-VERS-TLS1.1:-VERS-TLS1.0:-GROUP-X25519:-GROUP-SECP256R1:-GROUP-SECP384R1:-GROUP-FFDHE2048:-GROUP-FFDHE3072:-GROUP-FFDHE4096:-GROUP-FFDHE6144 --x509certfile=/etc/ssl/cert_3072.crt --x509keyfile=/etc/ssl/key_3072.pem\" \"\"\n}\n\n\n# GnuTLS with an ECDSA certificate (secp256r1 / NIST P-256).\nfunction run_test_15 {\n    run_test $1 '15' \"/gnutls-3.6.11.1/gnutls-serv -p 443 --x509certfile=/etc/ssl/cert_ecdsa_prime256v1.crt --x509keyfile=/etc/ssl/key_ecdsa_prime256v1.pem\" \"\"\n}\n\n\n# OpenSSL v1.0.2, TLSv1.2 with sect163k1 curve only.\nfunction run_test_16 {\n    run_test $1 '16' \"/openssl_v1.0.2/openssl s_server -accept 443 -tls1_2 -named_curve sect163k1 -cert /etc/ssl/cert_1024.crt -key /etc/ssl/key_1024.pem\" \"\"\n}\n\n\n# OpenSSL v1.1.1, TLSv1.2 with brainpoolP512r1 curve only.\nfunction run_test_17 {\n    run_test $1 '17' \"/openssl_v1.1.1/openssl s_server -accept 443 -tls1_2 -named_curve brainpoolP512r1 -cert /etc/ssl/cert_1024.crt -key /etc/ssl/key_1024.pem\" \"\"\n}\n\n\n# TLSv1.2 with ECDSA-SHA1 signature only.\nfunction run_test_18 {\n    run_test $1 '18' \"/gnutls-3.6.11.1/gnutls-serv -p 443 --x509certfile=/etc/ssl/cert_ecdsa_prime256v1.crt --x509keyfile=/etc/ssl/key_ecdsa_prime256v1.pem --priority=NONE:-VERS-TLS1.0:-VERS-TLS1.1:+VERS-TLS1.2:-VERS-TLS1.3:+MAC-ALL:+GROUP-ALL:+SIGN-ECDSA-SHA1:+COMP-NULL:+CTYPE-SRV-ALL:+KX-ALL:+CHACHA20-POLY1305:+CAMELLIA-128-GCM:+AES-128-GCM\" \"\"\n}\n\n\n# Run a test.  Set the first argument to '1' to enable test debugging.\n# Second argument is the test number to run.  Third argument is the executable and\n# its args to be run inside the container..\nfunction run_test {\n    debug=$1\n    test_number=$2\n    server_exec=$3\n    sslscan_additional_args=$4\n\n    test_result_stdout=\"${TEST_RESULT_DIR}/test_${test_number}.txt\"\n    expected_result_stdout=\"docker_test/expected_output/test_${test_number}.txt\"\n\n    # Run the container in the background.  Route port 4443 on the outside to port 443 on the inside.\n    cid=`docker run -d -p 4443:443 -t ${IMAGE_NAME}:${IMAGE_VERSION} ${server_exec}`\n    if [[ $? != 0 ]]; then\n\techo -e \"${REDB}Failed to run docker image! (exit code: $?)${CLR}\"\n\texit 1\n    fi\n\n    # If debugging is enabled, just run the container.  Don't do any output comparison.\n    if [[ $debug == 1 ]]; then\n\techo -e \"\\nExecuted in container: ${server_exec}\\n\\nTerminate container with: docker container stop -t 0 ${cid}\\n\\nHint: run sslscan against localhost on port 4443, not 443.\\n\"\n\treturn\n    fi\n\n    # Wait 250ms to ensure that the services in the container are fully initialized.\n    sleep 0.25\n\n    # Run sslscan and cut out the first two lines.  Those contain the version number\n    # and local version of OpenSSL, which can change over time (and when they do, this\n    # would break the test if they were left in).\n    ./sslscan $sslscan_additional_args 127.0.0.1:4443 | tail -n +3 > $test_result_stdout\n    if [[ $? != 0 ]]; then\n\techo -e \"${REDB}Failed to run sslscan! (exit code: $?)${CLR}\"\n\tdocker container stop -t 0 $cid > /dev/null\n\texit 1\n    fi\n\n    # Stop the container now that we captured the sslscan output.\n    docker container stop -t 0 $cid > /dev/null\n    if [[ $? != 0 ]]; then\n       echo -e \"${REDB}Failed to stop docker container ${cid}! (exit code: $?)${CLR}\"\n       exit 1\n    fi\n\n    # If the expected output file doesn't exist, give the user all the info we have so they can fix this.\n    if [[ ! -f ${expected_result_stdout} ]]; then\n\ttest_result_stdout_actual=`cat ${test_result_stdout}`\n\techo -e \"\\n${REDB}Error:${CLR} expected output file for test #${test_number} not found (${expected_result_stdout}).  Actual test result is below.  Manually verify that this output is correct; if so, then copy it to the expected test file path with:\\n\\n  $ cp ${test_result_stdout} ${expected_result_stdout}\\n\\n------\\n${test_result_stdout_actual}\\n\"\n\tall_passed=0\n\treturn\n    fi\n\n    # Compare the actual output to the expected output.  Any discrepency results in test failure.\n    diff=`diff -u ${expected_result_stdout} ${test_result_stdout}`\n    if [[ $? != 0 ]]; then\n\techo -e \"Test #${test_number} ${REDB}FAILED${CLR}.\\n\\n${diff}\\n\"\n\tall_passed=0\n\treturn\n    fi\n\n    echo -e \"Test #${test_number} ${GREEN}passed${CLR}.\"\n}\n\n\n# Instead of spinning up a docker instance, this will run a test using a host on the\n# public Internet.\nfunction run_test_internet {\n    test_number=$1\n    command=$2\n\n    test_result_stdout=\"${TEST_RESULT_DIR}/test_${test_number}.txt\"\n    expected_result_stdout=\"docker_test/expected_output/test_${test_number}.txt\"\n\n    `/bin/bash -c \"${command} | tail -n +3 > ${test_result_stdout}\"`\n    if [[ $? != 0 ]]; then\n\techo -e \"${REDB}Failed to run sslscan! (exit code: $?)${CLR}\"\n\tdocker container stop -t 0 $cid > /dev/null\n\texit 1\n    fi\n\n    # If the expected output file doesn't exist, give the user all the info we have so they can fix this.\n    if [[ ! -f ${expected_result_stdout} ]]; then\n\ttest_result_stdout_actual=`cat ${test_result_stdout}`\n\techo -e \"\\n${REDB}Error:${CLR} expected output file for test #${test_number} not found (${expected_result_stdout}).  Actual test result is below.  Manually verify that this output is correct; if so, then copy it to the expected test file path with:\\n\\n  $ cp ${test_result_stdout} ${expected_result_stdout}\\n\\n------\\n${test_result_stdout_actual}\\n\"\n\texit 1\n    fi\n\n    # Compare the actual output to the expected output.  Any discrepency results in test failure.\n    diff=`diff -u ${expected_result_stdout} ${test_result_stdout}`\n    if [[ $? != 0 ]]; then\n\techo -e \"Test #${test_number} ${REDB}FAILED${CLR}.\\n\\n${diff}\\n\"\n\texit 1\n    fi\n\n    echo -e \"Test #${test_number} ${GREEN}passed${CLR}.\"\n}\n\n\n# First check if docker is functional.\ndocker version > /dev/null\nif [[ $? != 0 ]]; then\n    echo -e \"${REDB}Error: 'docker version' command failed (error code: $?).  Is docker installed and functioning?${CLR}\"\n    exit 1\nfi\n\nis_debian=0\nis_arch=0\n\n# If dpkg exists, assume this is a Debian-based system.\ndpkg --version > /dev/null 2>&1\nif [[ $? == 0 ]]; then\n    is_debian=1\nfi\n\n# If pacman exists, assume this is an Arch system.\npacman --version > /dev/null 2>&1\nif [[ ($is_debian == 0) && ($? == 0) ]]; then\n    is_arch=1\nfi\n\n# Ensure that the libgmp-dev, m4, and wget packages are installed.  Use dpkg on Debian, or pacman on Arch.\nif [[ $is_debian == 1 ]]; then\n    dpkg -l libgmp-dev m4 perl wget > /dev/null 2>&1\n    if [[ $? != 0 ]]; then\n        echo -e \"${REDB}Error: libgmp-dev, m4, perl and/or wget packages not installed.  Fix with: apt install libgmp-dev m4 perl wget${CLR}\"\n        exit 1\n    fi\nelif [[ $is_arch == 1 ]]; then\n    pacman -Qi gmp m4 perl wget > /dev/null 2>&1\n    if [[ $? != 0 ]]; then\n        echo -e \"${REDB}Error: gmp, m4, perl and/or wget packages not installed.  Fix with: pacman -S gmp m4 perl wget${CLR}\"\n        exit 1\n    fi\nfi\n\n# Make sure sslscan has been built.\nif [[ ! -f sslscan ]]; then\n    echo -e \"${REDB}Error: sslscan executable not found.  Build it first!${CLR}\"\n    exit 1\nfi\n\n# If the user specified a test number to debug...\ndebug_test_number=0\nif [[ $# == 1 ]]; then\n   debug_test_number=$1\n   debug_test_number=$((debug_test_number + 0)) # Effectively, convert this to a number.\nfi\n\n# Check if the docker image is the most up-to-date version.  If not, create it.\ncheck_if_docker_image_exists\nif [[ $? == 0 ]]; then\n    echo -e \"\\n${GREEN}Docker image $IMAGE_NAME:$IMAGE_VERSION already exists.${CLR}\"\nelse\n    echo -e \"\\nCreating docker image $IMAGE_NAME:$IMAGE_VERSION...\"\n    create_docker_image\n    echo -e \"\\n${GREEN}Done creating docker image!${CLR}\"\nfi\n\n# Create a temporary directory to write test results to.\nTEST_RESULT_DIR=`mktemp -d /tmp/sslscan_test-results_XXXXXXXXXX`\n\n# If the user wants to run a specific test with debugging enabled, do that then exit.\nif [[ $debug_test_number > 0 ]]; then\n    eval \"run_test_${debug_test_number} 1\"\n    exit 0\nfi\n\n# Now run all the tests.\necho -e \"\\nRunning all tests...\"\nrun_tests\n\nif [[ $all_passed == 1 ]]; then\n    echo -e \"\\n${GREENB}ALL TESTS PASS!${CLR}\\n\"\n    rm -rf $TEST_RESULT_DIR\n    exit 0\nelse\n    echo -e \"\\n\\n${YELLOWB}!! SOME TESTS FAILED !!${CLR}\\n\\n\"\n    exit 1\nfi\n"
        },
        {
          "name": "docker_test",
          "type": "tree",
          "content": null
        },
        {
          "name": "missing_ciphersuites.h",
          "type": "blob",
          "size": 34.783203125,
          "content": "#ifndef _MISSING_CIPHERSUITES_H\n#define _MISSING_CIPHERSUITES_H\n\n\n/* At run-time, the findMissingCiphers() function will enumerate all the ciphers that OpenSSL knows of, and compares them each to the missing_ciphersuites list.  Afterwards, the 'check_tls_versions' field will have the set of TLS versions that OpenSSL does not have an implementation for (i.e.: if the TLS_RSA_WITH_IDEA_CBC_SHA cipher is set to V1_2, then OpenSSL has an implementation for it for TLS v1.0 and v1.1, but not for v1.2). */\n\n\n#define V1_0 (1)\n#define V1_1 (1 << 1)\n#define V1_2 (1 << 2)\n#define VALL (V1_0 | V1_1 | V1_2)\n\n\nstruct missing_ciphersuite {\n  unsigned short id;      /* TLS protocol ID. */\n  char protocol_name[48]; /* IANA name, as defined in the RFCs. */\n  int bits;               /* Bit strength of the cipher.  -1 if unknown. */\n  unsigned int check_tls_versions; /* OR'ed list of V1_? defines.  Refers to TLS version that OpenSSL does not have a ciphersuite implementation for.  Hence, it should be tested under this version of TLS. */\n  unsigned int accepted_tls_versions;  /* OR'ed list of V1_? defines.  Set at run-time if this ciphersuite was accepted by the server by the specified TLS version. */\n};\n\n\n/* Auto-generated by iana_tls_ciphersuite_parser.py on November 10, 2024. */\nstruct missing_ciphersuite missing_ciphersuites[] = {\n  {0x0000, \"TLS_NULL_WITH_NULL_NULL\", -1, VALL, 0},\n  {0x0001, \"TLS_RSA_WITH_NULL_MD5\", -1, VALL, 0},\n  {0x0002, \"TLS_RSA_WITH_NULL_SHA\", -1, VALL, 0},\n  {0x0003, \"TLS_RSA_EXPORT_WITH_RC4_40_MD5\", 40, VALL, 0},\n  {0x0004, \"TLS_RSA_WITH_RC4_128_MD5\", 128, VALL, 0},\n  {0x0005, \"TLS_RSA_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0x0006, \"TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\", 40, VALL, 0},\n  {0x0007, \"TLS_RSA_WITH_IDEA_CBC_SHA\", 128, VALL, 0},\n  {0x0008, \"TLS_RSA_EXPORT_WITH_DES40_CBC_SHA\", 40, VALL, 0},\n  {0x0009, \"TLS_RSA_WITH_DES_CBC_SHA\", 56, VALL, 0},\n  {0x000A, \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x000B, \"TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA\", 40, VALL, 0},\n  {0x000C, \"TLS_DH_DSS_WITH_DES_CBC_SHA\", 56, VALL, 0},\n  {0x000D, \"TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x000E, \"TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\", 40, VALL, 0},\n  {0x000F, \"TLS_DH_RSA_WITH_DES_CBC_SHA\", 56, VALL, 0},\n  {0x0010, \"TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x0011, \"TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\", 40, VALL, 0},\n  {0x0012, \"TLS_DHE_DSS_WITH_DES_CBC_SHA\", 56, VALL, 0},\n  {0x0013, \"TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x0014, \"TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\", 40, VALL, 0},\n  {0x0015, \"TLS_DHE_RSA_WITH_DES_CBC_SHA\", 56, VALL, 0},\n  {0x0016, \"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x0017, \"TLS_DH_anon_EXPORT_WITH_RC4_40_MD5\", 40, VALL, 0},\n  {0x0018, \"TLS_DH_anon_WITH_RC4_128_MD5\", 128, VALL, 0},\n  {0x0019, \"TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA\", 40, VALL, 0},\n  {0x001A, \"TLS_DH_anon_WITH_DES_CBC_SHA\", 56, VALL, 0},\n  {0x001B, \"TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x001E, \"TLS_KRB5_WITH_DES_CBC_SHA\", 56, VALL, 0},\n  {0x001F, \"TLS_KRB5_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x0020, \"TLS_KRB5_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0x0021, \"TLS_KRB5_WITH_IDEA_CBC_SHA\", 128, VALL, 0},\n  {0x0022, \"TLS_KRB5_WITH_DES_CBC_MD5\", 56, VALL, 0},\n  {0x0023, \"TLS_KRB5_WITH_3DES_EDE_CBC_MD5\", 112, VALL, 0},\n  {0x0024, \"TLS_KRB5_WITH_RC4_128_MD5\", 128, VALL, 0},\n  {0x0025, \"TLS_KRB5_WITH_IDEA_CBC_MD5\", 128, VALL, 0},\n  {0x0026, \"TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA\", 56, VALL, 0},\n  {0x0027, \"TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA\", 40, VALL, 0},\n  {0x0028, \"TLS_KRB5_EXPORT_WITH_RC4_40_SHA\", 40, VALL, 0},\n  {0x0029, \"TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5\", 56, VALL, 0},\n  {0x002A, \"TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5\", 40, VALL, 0},\n  {0x002B, \"TLS_KRB5_EXPORT_WITH_RC4_40_MD5\", 40, VALL, 0},\n  {0x002C, \"TLS_PSK_WITH_NULL_SHA\", -1, VALL, 0},\n  {0x002D, \"TLS_DHE_PSK_WITH_NULL_SHA\", -1, VALL, 0},\n  {0x002E, \"TLS_RSA_PSK_WITH_NULL_SHA\", -1, VALL, 0},\n  {0x002F, \"TLS_RSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0030, \"TLS_DH_DSS_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0031, \"TLS_DH_RSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0032, \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0033, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0034, \"TLS_DH_anon_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0035, \"TLS_RSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x0036, \"TLS_DH_DSS_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x0037, \"TLS_DH_RSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x0038, \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x0039, \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x003A, \"TLS_DH_anon_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x003B, \"TLS_RSA_WITH_NULL_SHA256\", -1, VALL, 0},\n  {0x003C, \"TLS_RSA_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x003D, \"TLS_RSA_WITH_AES_256_CBC_SHA256\", 256, VALL, 0},\n  {0x003E, \"TLS_DH_DSS_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x003F, \"TLS_DH_RSA_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x0040, \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x0041, \"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA\", 128, VALL, 0},\n  {0x0042, \"TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA\", 128, VALL, 0},\n  {0x0043, \"TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA\", 128, VALL, 0},\n  {0x0044, \"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA\", 128, VALL, 0},\n  {0x0045, \"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\", 128, VALL, 0},\n  {0x0046, \"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA\", 128, VALL, 0},\n  {0x0067, \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x0068, \"TLS_DH_DSS_WITH_AES_256_CBC_SHA256\", 256, VALL, 0},\n  {0x0069, \"TLS_DH_RSA_WITH_AES_256_CBC_SHA256\", 256, VALL, 0},\n  {0x006A, \"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\", 256, VALL, 0},\n  {0x006B, \"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\", 256, VALL, 0},\n  {0x006C, \"TLS_DH_anon_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x006D, \"TLS_DH_anon_WITH_AES_256_CBC_SHA256\", 256, VALL, 0},\n  {0x0084, \"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA\", 256, VALL, 0},\n  {0x0085, \"TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA\", 256, VALL, 0},\n  {0x0086, \"TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA\", 256, VALL, 0},\n  {0x0087, \"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA\", 256, VALL, 0},\n  {0x0088, \"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA\", 256, VALL, 0},\n  {0x0089, \"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA\", 256, VALL, 0},\n  {0x008A, \"TLS_PSK_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0x008B, \"TLS_PSK_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x008C, \"TLS_PSK_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x008D, \"TLS_PSK_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x008E, \"TLS_DHE_PSK_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0x008F, \"TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x0090, \"TLS_DHE_PSK_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0091, \"TLS_DHE_PSK_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x0092, \"TLS_RSA_PSK_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0x0093, \"TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0x0094, \"TLS_RSA_PSK_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0x0095, \"TLS_RSA_PSK_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0x0096, \"TLS_RSA_WITH_SEED_CBC_SHA\", 128, VALL, 0},\n  {0x0097, \"TLS_DH_DSS_WITH_SEED_CBC_SHA\", 128, VALL, 0},\n  {0x0098, \"TLS_DH_RSA_WITH_SEED_CBC_SHA\", 128, VALL, 0},\n  {0x0099, \"TLS_DHE_DSS_WITH_SEED_CBC_SHA\", 128, VALL, 0},\n  {0x009A, \"TLS_DHE_RSA_WITH_SEED_CBC_SHA\", 128, VALL, 0},\n  {0x009B, \"TLS_DH_anon_WITH_SEED_CBC_SHA\", 128, VALL, 0},\n  {0x009C, \"TLS_RSA_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x009D, \"TLS_RSA_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x009E, \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x009F, \"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00A0, \"TLS_DH_RSA_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x00A1, \"TLS_DH_RSA_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00A2, \"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x00A3, \"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00A4, \"TLS_DH_DSS_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x00A5, \"TLS_DH_DSS_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00A6, \"TLS_DH_anon_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x00A7, \"TLS_DH_anon_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00A8, \"TLS_PSK_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x00A9, \"TLS_PSK_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00AA, \"TLS_DHE_PSK_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x00AB, \"TLS_DHE_PSK_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00AC, \"TLS_RSA_PSK_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x00AD, \"TLS_RSA_PSK_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x00AE, \"TLS_PSK_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00AF, \"TLS_PSK_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0x00B0, \"TLS_PSK_WITH_NULL_SHA256\", -1, VALL, 0},\n  {0x00B1, \"TLS_PSK_WITH_NULL_SHA384\", -1, VALL, 0},\n  {0x00B2, \"TLS_DHE_PSK_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00B3, \"TLS_DHE_PSK_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0x00B4, \"TLS_DHE_PSK_WITH_NULL_SHA256\", -1, VALL, 0},\n  {0x00B5, \"TLS_DHE_PSK_WITH_NULL_SHA384\", -1, VALL, 0},\n  {0x00B6, \"TLS_RSA_PSK_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00B7, \"TLS_RSA_PSK_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0x00B8, \"TLS_RSA_PSK_WITH_NULL_SHA256\", -1, VALL, 0},\n  {0x00B9, \"TLS_RSA_PSK_WITH_NULL_SHA384\", -1, VALL, 0},\n  {0x00BA, \"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00BB, \"TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00BC, \"TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00BD, \"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00BE, \"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00BF, \"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0x00C0, \"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256\", 256, VALL, 0},\n  {0x00C1, \"TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256\", 256, VALL, 0},\n  {0x00C2, \"TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256\", 256, VALL, 0},\n  {0x00C3, \"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256\", 256, VALL, 0},\n  {0x00C4, \"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256\", 256, VALL, 0},\n  {0x00C5, \"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256\", 256, VALL, 0},\n  {0x00C6, \"TLS_SM4_GCM_SM3\", 128, VALL, 0},\n  {0x00C7, \"TLS_SM4_CCM_SM3\", 128, VALL, 0},\n  {0x1301, \"TLS_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0x1302, \"TLS_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0x1303, \"TLS_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0x1304, \"TLS_AES_128_CCM_SHA256\", 128, VALL, 0},\n  {0x1305, \"TLS_AES_128_CCM_8_SHA256\", 128, VALL, 0},\n  {0x1306, \"TLS_AEGIS_256_SHA512\", 256, VALL, 0},\n  {0x1307, \"TLS_AEGIS_128L_SHA256\", 128, VALL, 0},\n  {0xC001, \"TLS_ECDH_ECDSA_WITH_NULL_SHA\", -1, VALL, 0},\n  {0xC002, \"TLS_ECDH_ECDSA_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0xC003, \"TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC004, \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC005, \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC006, \"TLS_ECDHE_ECDSA_WITH_NULL_SHA\", -1, VALL, 0},\n  {0xC007, \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0xC008, \"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC009, \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC00A, \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC00B, \"TLS_ECDH_RSA_WITH_NULL_SHA\", -1, VALL, 0},\n  {0xC00C, \"TLS_ECDH_RSA_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0xC00D, \"TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC00E, \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC00F, \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC010, \"TLS_ECDHE_RSA_WITH_NULL_SHA\", -1, VALL, 0},\n  {0xC011, \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0xC012, \"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC013, \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC014, \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC015, \"TLS_ECDH_anon_WITH_NULL_SHA\", -1, VALL, 0},\n  {0xC016, \"TLS_ECDH_anon_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0xC017, \"TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC018, \"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC019, \"TLS_ECDH_anon_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC01A, \"TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC01B, \"TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC01C, \"TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC01D, \"TLS_SRP_SHA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC01E, \"TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC01F, \"TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC020, \"TLS_SRP_SHA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC021, \"TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC022, \"TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC023, \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC024, \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC025, \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC026, \"TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC027, \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC028, \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC029, \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC02A, \"TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC02B, \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC02C, \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC02D, \"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC02E, \"TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC02F, \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC030, \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC031, \"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC032, \"TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC033, \"TLS_ECDHE_PSK_WITH_RC4_128_SHA\", 128, VALL, 0},\n  {0xC034, \"TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA\", 112, VALL, 0},\n  {0xC035, \"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\", 128, VALL, 0},\n  {0xC036, \"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA\", 256, VALL, 0},\n  {0xC037, \"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC038, \"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC039, \"TLS_ECDHE_PSK_WITH_NULL_SHA\", -1, VALL, 0},\n  {0xC03A, \"TLS_ECDHE_PSK_WITH_NULL_SHA256\", -1, VALL, 0},\n  {0xC03B, \"TLS_ECDHE_PSK_WITH_NULL_SHA384\", -1, VALL, 0},\n  {0xC03C, \"TLS_RSA_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC03D, \"TLS_RSA_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC03E, \"TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC03F, \"TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC040, \"TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC041, \"TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC042, \"TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC043, \"TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC044, \"TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC045, \"TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC046, \"TLS_DH_anon_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC047, \"TLS_DH_anon_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC048, \"TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC049, \"TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC04A, \"TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC04B, \"TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC04C, \"TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC04D, \"TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC04E, \"TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC04F, \"TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC050, \"TLS_RSA_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC051, \"TLS_RSA_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC052, \"TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC053, \"TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC054, \"TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC055, \"TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC056, \"TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC057, \"TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC058, \"TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC059, \"TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC05A, \"TLS_DH_anon_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC05B, \"TLS_DH_anon_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC05C, \"TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC05D, \"TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC05E, \"TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC05F, \"TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC060, \"TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC061, \"TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC062, \"TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC063, \"TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC064, \"TLS_PSK_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC065, \"TLS_PSK_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC066, \"TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC067, \"TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC068, \"TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC069, \"TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC06A, \"TLS_PSK_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC06B, \"TLS_PSK_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC06C, \"TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC06D, \"TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC06E, \"TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC06F, \"TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC070, \"TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC071, \"TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC072, \"TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC073, \"TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC074, \"TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC075, \"TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC076, \"TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC077, \"TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC078, \"TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC079, \"TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC07A, \"TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC07B, \"TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC07C, \"TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC07D, \"TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC07E, \"TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC07F, \"TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC080, \"TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC081, \"TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC082, \"TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC083, \"TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC084, \"TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC085, \"TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC086, \"TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC087, \"TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC088, \"TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC089, \"TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC08A, \"TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC08B, \"TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC08C, \"TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC08D, \"TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC08E, \"TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC08F, \"TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC090, \"TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC091, \"TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC092, \"TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC093, \"TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC094, \"TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC095, \"TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC096, \"TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC097, \"TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC098, \"TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC099, \"TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC09A, \"TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\", 128, VALL, 0},\n  {0xC09B, \"TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\", 256, VALL, 0},\n  {0xC09C, \"TLS_RSA_WITH_AES_128_CCM\", 128, VALL, 0},\n  {0xC09D, \"TLS_RSA_WITH_AES_256_CCM\", 256, VALL, 0},\n  {0xC09E, \"TLS_DHE_RSA_WITH_AES_128_CCM\", 128, VALL, 0},\n  {0xC09F, \"TLS_DHE_RSA_WITH_AES_256_CCM\", 256, VALL, 0},\n  {0xC0A0, \"TLS_RSA_WITH_AES_128_CCM_8\", 128, VALL, 0},\n  {0xC0A1, \"TLS_RSA_WITH_AES_256_CCM_8\", 256, VALL, 0},\n  {0xC0A2, \"TLS_DHE_RSA_WITH_AES_128_CCM_8\", 128, VALL, 0},\n  {0xC0A3, \"TLS_DHE_RSA_WITH_AES_256_CCM_8\", 256, VALL, 0},\n  {0xC0A4, \"TLS_PSK_WITH_AES_128_CCM\", 128, VALL, 0},\n  {0xC0A5, \"TLS_PSK_WITH_AES_256_CCM\", 256, VALL, 0},\n  {0xC0A6, \"TLS_DHE_PSK_WITH_AES_128_CCM\", 128, VALL, 0},\n  {0xC0A7, \"TLS_DHE_PSK_WITH_AES_256_CCM\", 256, VALL, 0},\n  {0xC0A8, \"TLS_PSK_WITH_AES_128_CCM_8\", 128, VALL, 0},\n  {0xC0A9, \"TLS_PSK_WITH_AES_256_CCM_8\", 256, VALL, 0},\n  {0xC0AA, \"TLS_PSK_DHE_WITH_AES_128_CCM_8\", 128, VALL, 0},\n  {0xC0AB, \"TLS_PSK_DHE_WITH_AES_256_CCM_8\", 256, VALL, 0},\n  {0xC0AC, \"TLS_ECDHE_ECDSA_WITH_AES_128_CCM\", 128, VALL, 0},\n  {0xC0AD, \"TLS_ECDHE_ECDSA_WITH_AES_256_CCM\", 256, VALL, 0},\n  {0xC0AE, \"TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\", 128, VALL, 0},\n  {0xC0AF, \"TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8\", 256, VALL, 0},\n  {0xC0B0, \"TLS_ECCPWD_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0xC0B1, \"TLS_ECCPWD_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0xC0B2, \"TLS_ECCPWD_WITH_AES_128_CCM_SHA256\", 128, VALL, 0},\n  {0xC0B3, \"TLS_ECCPWD_WITH_AES_256_CCM_SHA384\", 256, VALL, 0},\n  {0xC0B4, \"TLS_SHA256_SHA256\", -1, VALL, 0},\n  {0xC0B5, \"TLS_SHA384_SHA384\", -1, VALL, 0},\n  {0xC100, \"TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC\", 256, VALL, 0},\n  {0xC101, \"TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC\", 256, VALL, 0},\n  {0xC102, \"TLS_GOSTR341112_256_WITH_28147_CNT_IMIT\", 256, VALL, 0},\n  {0xC103, \"TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_L\", 256, VALL, 0},\n  {0xC104, \"TLS_GOSTR341112_256_WITH_MAGMA_MGM_L\", 256, VALL, 0},\n  {0xC105, \"TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_S\", 256, VALL, 0},\n  {0xC106, \"TLS_GOSTR341112_256_WITH_MAGMA_MGM_S\", 256, VALL, 0},\n  {0xCCA8, \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0xCCA9, \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0xCCAA, \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0xCCAB, \"TLS_PSK_WITH_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0xCCAC, \"TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0xCCAD, \"TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0xCCAE, \"TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256\", 256, VALL, 0},\n  {0xD001, \"TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256\", 128, VALL, 0},\n  {0xD002, \"TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384\", 256, VALL, 0},\n  {0xD003, \"TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256\", 128, VALL, 0},\n  {0xD005, \"TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256\", 128, VALL, 0},\n\n  /* The ciphers below are reserved for private use (see RFC8446). */\n  {0xFF00, \"PRIVATE_CIPHER_0\", -1, VALL, 0},\n  {0xFF01, \"PRIVATE_CIPHER_1\", -1, VALL, 0},\n  {0xFF02, \"PRIVATE_CIPHER_2\", -1, VALL, 0},\n  {0xFF03, \"PRIVATE_CIPHER_3\", -1, VALL, 0},\n  {0xFF04, \"PRIVATE_CIPHER_4\", -1, VALL, 0},\n  {0xFF05, \"PRIVATE_CIPHER_5\", -1, VALL, 0},\n  {0xFF06, \"PRIVATE_CIPHER_6\", -1, VALL, 0},\n  {0xFF07, \"PRIVATE_CIPHER_7\", -1, VALL, 0},\n  {0xFF08, \"PRIVATE_CIPHER_8\", -1, VALL, 0},\n  {0xFF09, \"PRIVATE_CIPHER_9\", -1, VALL, 0},\n  {0xFF0A, \"PRIVATE_CIPHER_10\", -1, VALL, 0},\n  {0xFF0B, \"PRIVATE_CIPHER_11\", -1, VALL, 0},\n  {0xFF0C, \"PRIVATE_CIPHER_12\", -1, VALL, 0},\n  {0xFF0D, \"PRIVATE_CIPHER_13\", -1, VALL, 0},\n  {0xFF0E, \"PRIVATE_CIPHER_14\", -1, VALL, 0},\n  {0xFF0F, \"PRIVATE_CIPHER_15\", -1, VALL, 0},\n  {0xFF10, \"PRIVATE_CIPHER_16\", -1, VALL, 0},\n  {0xFF11, \"PRIVATE_CIPHER_17\", -1, VALL, 0},\n  {0xFF12, \"PRIVATE_CIPHER_18\", -1, VALL, 0},\n  {0xFF13, \"PRIVATE_CIPHER_19\", -1, VALL, 0},\n  {0xFF14, \"PRIVATE_CIPHER_20\", -1, VALL, 0},\n  {0xFF15, \"PRIVATE_CIPHER_21\", -1, VALL, 0},\n  {0xFF16, \"PRIVATE_CIPHER_22\", -1, VALL, 0},\n  {0xFF17, \"PRIVATE_CIPHER_23\", -1, VALL, 0},\n  {0xFF18, \"PRIVATE_CIPHER_24\", -1, VALL, 0},\n  {0xFF19, \"PRIVATE_CIPHER_25\", -1, VALL, 0},\n  {0xFF1A, \"PRIVATE_CIPHER_26\", -1, VALL, 0},\n  {0xFF1B, \"PRIVATE_CIPHER_27\", -1, VALL, 0},\n  {0xFF1C, \"PRIVATE_CIPHER_28\", -1, VALL, 0},\n  {0xFF1D, \"PRIVATE_CIPHER_29\", -1, VALL, 0},\n  {0xFF1E, \"PRIVATE_CIPHER_30\", -1, VALL, 0},\n  {0xFF1F, \"PRIVATE_CIPHER_31\", -1, VALL, 0},\n  {0xFF20, \"PRIVATE_CIPHER_32\", -1, VALL, 0},\n  {0xFF21, \"PRIVATE_CIPHER_33\", -1, VALL, 0},\n  {0xFF22, \"PRIVATE_CIPHER_34\", -1, VALL, 0},\n  {0xFF23, \"PRIVATE_CIPHER_35\", -1, VALL, 0},\n  {0xFF24, \"PRIVATE_CIPHER_36\", -1, VALL, 0},\n  {0xFF25, \"PRIVATE_CIPHER_37\", -1, VALL, 0},\n  {0xFF26, \"PRIVATE_CIPHER_38\", -1, VALL, 0},\n  {0xFF27, \"PRIVATE_CIPHER_39\", -1, VALL, 0},\n  {0xFF28, \"PRIVATE_CIPHER_40\", -1, VALL, 0},\n  {0xFF29, \"PRIVATE_CIPHER_41\", -1, VALL, 0},\n  {0xFF2A, \"PRIVATE_CIPHER_42\", -1, VALL, 0},\n  {0xFF2B, \"PRIVATE_CIPHER_43\", -1, VALL, 0},\n  {0xFF2C, \"PRIVATE_CIPHER_44\", -1, VALL, 0},\n  {0xFF2D, \"PRIVATE_CIPHER_45\", -1, VALL, 0},\n  {0xFF2E, \"PRIVATE_CIPHER_46\", -1, VALL, 0},\n  {0xFF2F, \"PRIVATE_CIPHER_47\", -1, VALL, 0},\n  {0xFF30, \"PRIVATE_CIPHER_48\", -1, VALL, 0},\n  {0xFF31, \"PRIVATE_CIPHER_49\", -1, VALL, 0},\n  {0xFF32, \"PRIVATE_CIPHER_50\", -1, VALL, 0},\n  {0xFF33, \"PRIVATE_CIPHER_51\", -1, VALL, 0},\n  {0xFF34, \"PRIVATE_CIPHER_52\", -1, VALL, 0},\n  {0xFF35, \"PRIVATE_CIPHER_53\", -1, VALL, 0},\n  {0xFF36, \"PRIVATE_CIPHER_54\", -1, VALL, 0},\n  {0xFF37, \"PRIVATE_CIPHER_55\", -1, VALL, 0},\n  {0xFF38, \"PRIVATE_CIPHER_56\", -1, VALL, 0},\n  {0xFF39, \"PRIVATE_CIPHER_57\", -1, VALL, 0},\n  {0xFF3A, \"PRIVATE_CIPHER_58\", -1, VALL, 0},\n  {0xFF3B, \"PRIVATE_CIPHER_59\", -1, VALL, 0},\n  {0xFF3C, \"PRIVATE_CIPHER_60\", -1, VALL, 0},\n  {0xFF3D, \"PRIVATE_CIPHER_61\", -1, VALL, 0},\n  {0xFF3E, \"PRIVATE_CIPHER_62\", -1, VALL, 0},\n  {0xFF3F, \"PRIVATE_CIPHER_63\", -1, VALL, 0},\n  {0xFF40, \"PRIVATE_CIPHER_64\", -1, VALL, 0},\n  {0xFF41, \"PRIVATE_CIPHER_65\", -1, VALL, 0},\n  {0xFF42, \"PRIVATE_CIPHER_66\", -1, VALL, 0},\n  {0xFF43, \"PRIVATE_CIPHER_67\", -1, VALL, 0},\n  {0xFF44, \"PRIVATE_CIPHER_68\", -1, VALL, 0},\n  {0xFF45, \"PRIVATE_CIPHER_69\", -1, VALL, 0},\n  {0xFF46, \"PRIVATE_CIPHER_70\", -1, VALL, 0},\n  {0xFF47, \"PRIVATE_CIPHER_71\", -1, VALL, 0},\n  {0xFF48, \"PRIVATE_CIPHER_72\", -1, VALL, 0},\n  {0xFF49, \"PRIVATE_CIPHER_73\", -1, VALL, 0},\n  {0xFF4A, \"PRIVATE_CIPHER_74\", -1, VALL, 0},\n  {0xFF4B, \"PRIVATE_CIPHER_75\", -1, VALL, 0},\n  {0xFF4C, \"PRIVATE_CIPHER_76\", -1, VALL, 0},\n  {0xFF4D, \"PRIVATE_CIPHER_77\", -1, VALL, 0},\n  {0xFF4E, \"PRIVATE_CIPHER_78\", -1, VALL, 0},\n  {0xFF4F, \"PRIVATE_CIPHER_79\", -1, VALL, 0},\n  {0xFF50, \"PRIVATE_CIPHER_80\", -1, VALL, 0},\n  {0xFF51, \"PRIVATE_CIPHER_81\", -1, VALL, 0},\n  {0xFF52, \"PRIVATE_CIPHER_82\", -1, VALL, 0},\n  {0xFF53, \"PRIVATE_CIPHER_83\", -1, VALL, 0},\n  {0xFF54, \"PRIVATE_CIPHER_84\", -1, VALL, 0},\n  {0xFF55, \"PRIVATE_CIPHER_85\", -1, VALL, 0},\n  {0xFF56, \"PRIVATE_CIPHER_86\", -1, VALL, 0},\n  {0xFF57, \"PRIVATE_CIPHER_87\", -1, VALL, 0},\n  {0xFF58, \"PRIVATE_CIPHER_88\", -1, VALL, 0},\n  {0xFF59, \"PRIVATE_CIPHER_89\", -1, VALL, 0},\n  {0xFF5A, \"PRIVATE_CIPHER_90\", -1, VALL, 0},\n  {0xFF5B, \"PRIVATE_CIPHER_91\", -1, VALL, 0},\n  {0xFF5C, \"PRIVATE_CIPHER_92\", -1, VALL, 0},\n  {0xFF5D, \"PRIVATE_CIPHER_93\", -1, VALL, 0},\n  {0xFF5E, \"PRIVATE_CIPHER_94\", -1, VALL, 0},\n  {0xFF5F, \"PRIVATE_CIPHER_95\", -1, VALL, 0},\n  {0xFF60, \"PRIVATE_CIPHER_96\", -1, VALL, 0},\n  {0xFF61, \"PRIVATE_CIPHER_97\", -1, VALL, 0},\n  {0xFF62, \"PRIVATE_CIPHER_98\", -1, VALL, 0},\n  {0xFF63, \"PRIVATE_CIPHER_99\", -1, VALL, 0},\n  {0xFF64, \"PRIVATE_CIPHER_100\", -1, VALL, 0},\n  {0xFF65, \"PRIVATE_CIPHER_101\", -1, VALL, 0},\n  {0xFF66, \"PRIVATE_CIPHER_102\", -1, VALL, 0},\n  {0xFF67, \"PRIVATE_CIPHER_103\", -1, VALL, 0},\n  {0xFF68, \"PRIVATE_CIPHER_104\", -1, VALL, 0},\n  {0xFF69, \"PRIVATE_CIPHER_105\", -1, VALL, 0},\n  {0xFF6A, \"PRIVATE_CIPHER_106\", -1, VALL, 0},\n  {0xFF6B, \"PRIVATE_CIPHER_107\", -1, VALL, 0},\n  {0xFF6C, \"PRIVATE_CIPHER_108\", -1, VALL, 0},\n  {0xFF6D, \"PRIVATE_CIPHER_109\", -1, VALL, 0},\n  {0xFF6E, \"PRIVATE_CIPHER_110\", -1, VALL, 0},\n  {0xFF6F, \"PRIVATE_CIPHER_111\", -1, VALL, 0},\n  {0xFF70, \"PRIVATE_CIPHER_112\", -1, VALL, 0},\n  {0xFF71, \"PRIVATE_CIPHER_113\", -1, VALL, 0},\n  {0xFF72, \"PRIVATE_CIPHER_114\", -1, VALL, 0},\n  {0xFF73, \"PRIVATE_CIPHER_115\", -1, VALL, 0},\n  {0xFF74, \"PRIVATE_CIPHER_116\", -1, VALL, 0},\n  {0xFF75, \"PRIVATE_CIPHER_117\", -1, VALL, 0},\n  {0xFF76, \"PRIVATE_CIPHER_118\", -1, VALL, 0},\n  {0xFF77, \"PRIVATE_CIPHER_119\", -1, VALL, 0},\n  {0xFF78, \"PRIVATE_CIPHER_120\", -1, VALL, 0},\n  {0xFF79, \"PRIVATE_CIPHER_121\", -1, VALL, 0},\n  {0xFF7A, \"PRIVATE_CIPHER_122\", -1, VALL, 0},\n  {0xFF7B, \"PRIVATE_CIPHER_123\", -1, VALL, 0},\n  {0xFF7C, \"PRIVATE_CIPHER_124\", -1, VALL, 0},\n  {0xFF7D, \"PRIVATE_CIPHER_125\", -1, VALL, 0},\n  {0xFF7E, \"PRIVATE_CIPHER_126\", -1, VALL, 0},\n  {0xFF7F, \"PRIVATE_CIPHER_127\", -1, VALL, 0},\n  {0xFF80, \"PRIVATE_CIPHER_128\", -1, VALL, 0},\n  {0xFF81, \"PRIVATE_CIPHER_129\", -1, VALL, 0},\n  {0xFF82, \"PRIVATE_CIPHER_130\", -1, VALL, 0},\n  {0xFF83, \"PRIVATE_CIPHER_131\", -1, VALL, 0},\n  {0xFF84, \"PRIVATE_CIPHER_132\", -1, VALL, 0},\n  {0xFF85, \"PRIVATE_CIPHER_133\", -1, VALL, 0},\n  {0xFF86, \"PRIVATE_CIPHER_134\", -1, VALL, 0},\n  {0xFF87, \"PRIVATE_CIPHER_135\", -1, VALL, 0},\n  {0xFF88, \"PRIVATE_CIPHER_136\", -1, VALL, 0},\n  {0xFF89, \"PRIVATE_CIPHER_137\", -1, VALL, 0},\n  {0xFF8A, \"PRIVATE_CIPHER_138\", -1, VALL, 0},\n  {0xFF8B, \"PRIVATE_CIPHER_139\", -1, VALL, 0},\n  {0xFF8C, \"PRIVATE_CIPHER_140\", -1, VALL, 0},\n  {0xFF8D, \"PRIVATE_CIPHER_141\", -1, VALL, 0},\n  {0xFF8E, \"PRIVATE_CIPHER_142\", -1, VALL, 0},\n  {0xFF8F, \"PRIVATE_CIPHER_143\", -1, VALL, 0},\n  {0xFF90, \"PRIVATE_CIPHER_144\", -1, VALL, 0},\n  {0xFF91, \"PRIVATE_CIPHER_145\", -1, VALL, 0},\n  {0xFF92, \"PRIVATE_CIPHER_146\", -1, VALL, 0},\n  {0xFF93, \"PRIVATE_CIPHER_147\", -1, VALL, 0},\n  {0xFF94, \"PRIVATE_CIPHER_148\", -1, VALL, 0},\n  {0xFF95, \"PRIVATE_CIPHER_149\", -1, VALL, 0},\n  {0xFF96, \"PRIVATE_CIPHER_150\", -1, VALL, 0},\n  {0xFF97, \"PRIVATE_CIPHER_151\", -1, VALL, 0},\n  {0xFF98, \"PRIVATE_CIPHER_152\", -1, VALL, 0},\n  {0xFF99, \"PRIVATE_CIPHER_153\", -1, VALL, 0},\n  {0xFF9A, \"PRIVATE_CIPHER_154\", -1, VALL, 0},\n  {0xFF9B, \"PRIVATE_CIPHER_155\", -1, VALL, 0},\n  {0xFF9C, \"PRIVATE_CIPHER_156\", -1, VALL, 0},\n  {0xFF9D, \"PRIVATE_CIPHER_157\", -1, VALL, 0},\n  {0xFF9E, \"PRIVATE_CIPHER_158\", -1, VALL, 0},\n  {0xFF9F, \"PRIVATE_CIPHER_159\", -1, VALL, 0},\n  {0xFFA0, \"PRIVATE_CIPHER_160\", -1, VALL, 0},\n  {0xFFA1, \"PRIVATE_CIPHER_161\", -1, VALL, 0},\n  {0xFFA2, \"PRIVATE_CIPHER_162\", -1, VALL, 0},\n  {0xFFA3, \"PRIVATE_CIPHER_163\", -1, VALL, 0},\n  {0xFFA4, \"PRIVATE_CIPHER_164\", -1, VALL, 0},\n  {0xFFA5, \"PRIVATE_CIPHER_165\", -1, VALL, 0},\n  {0xFFA6, \"PRIVATE_CIPHER_166\", -1, VALL, 0},\n  {0xFFA7, \"PRIVATE_CIPHER_167\", -1, VALL, 0},\n  {0xFFA8, \"PRIVATE_CIPHER_168\", -1, VALL, 0},\n  {0xFFA9, \"PRIVATE_CIPHER_169\", -1, VALL, 0},\n  {0xFFAA, \"PRIVATE_CIPHER_170\", -1, VALL, 0},\n  {0xFFAB, \"PRIVATE_CIPHER_171\", -1, VALL, 0},\n  {0xFFAC, \"PRIVATE_CIPHER_172\", -1, VALL, 0},\n  {0xFFAD, \"PRIVATE_CIPHER_173\", -1, VALL, 0},\n  {0xFFAE, \"PRIVATE_CIPHER_174\", -1, VALL, 0},\n  {0xFFAF, \"PRIVATE_CIPHER_175\", -1, VALL, 0},\n  {0xFFB0, \"PRIVATE_CIPHER_176\", -1, VALL, 0},\n  {0xFFB1, \"PRIVATE_CIPHER_177\", -1, VALL, 0},\n  {0xFFB2, \"PRIVATE_CIPHER_178\", -1, VALL, 0},\n  {0xFFB3, \"PRIVATE_CIPHER_179\", -1, VALL, 0},\n  {0xFFB4, \"PRIVATE_CIPHER_180\", -1, VALL, 0},\n  {0xFFB5, \"PRIVATE_CIPHER_181\", -1, VALL, 0},\n  {0xFFB6, \"PRIVATE_CIPHER_182\", -1, VALL, 0},\n  {0xFFB7, \"PRIVATE_CIPHER_183\", -1, VALL, 0},\n  {0xFFB8, \"PRIVATE_CIPHER_184\", -1, VALL, 0},\n  {0xFFB9, \"PRIVATE_CIPHER_185\", -1, VALL, 0},\n  {0xFFBA, \"PRIVATE_CIPHER_186\", -1, VALL, 0},\n  {0xFFBB, \"PRIVATE_CIPHER_187\", -1, VALL, 0},\n  {0xFFBC, \"PRIVATE_CIPHER_188\", -1, VALL, 0},\n  {0xFFBD, \"PRIVATE_CIPHER_189\", -1, VALL, 0},\n  {0xFFBE, \"PRIVATE_CIPHER_190\", -1, VALL, 0},\n  {0xFFBF, \"PRIVATE_CIPHER_191\", -1, VALL, 0},\n  {0xFFC0, \"PRIVATE_CIPHER_192\", -1, VALL, 0},\n  {0xFFC1, \"PRIVATE_CIPHER_193\", -1, VALL, 0},\n  {0xFFC2, \"PRIVATE_CIPHER_194\", -1, VALL, 0},\n  {0xFFC3, \"PRIVATE_CIPHER_195\", -1, VALL, 0},\n  {0xFFC4, \"PRIVATE_CIPHER_196\", -1, VALL, 0},\n  {0xFFC5, \"PRIVATE_CIPHER_197\", -1, VALL, 0},\n  {0xFFC6, \"PRIVATE_CIPHER_198\", -1, VALL, 0},\n  {0xFFC7, \"PRIVATE_CIPHER_199\", -1, VALL, 0},\n  {0xFFC8, \"PRIVATE_CIPHER_200\", -1, VALL, 0},\n  {0xFFC9, \"PRIVATE_CIPHER_201\", -1, VALL, 0},\n  {0xFFCA, \"PRIVATE_CIPHER_202\", -1, VALL, 0},\n  {0xFFCB, \"PRIVATE_CIPHER_203\", -1, VALL, 0},\n  {0xFFCC, \"PRIVATE_CIPHER_204\", -1, VALL, 0},\n  {0xFFCD, \"PRIVATE_CIPHER_205\", -1, VALL, 0},\n  {0xFFCE, \"PRIVATE_CIPHER_206\", -1, VALL, 0},\n  {0xFFCF, \"PRIVATE_CIPHER_207\", -1, VALL, 0},\n  {0xFFD0, \"PRIVATE_CIPHER_208\", -1, VALL, 0},\n  {0xFFD1, \"PRIVATE_CIPHER_209\", -1, VALL, 0},\n  {0xFFD2, \"PRIVATE_CIPHER_210\", -1, VALL, 0},\n  {0xFFD3, \"PRIVATE_CIPHER_211\", -1, VALL, 0},\n  {0xFFD4, \"PRIVATE_CIPHER_212\", -1, VALL, 0},\n  {0xFFD5, \"PRIVATE_CIPHER_213\", -1, VALL, 0},\n  {0xFFD6, \"PRIVATE_CIPHER_214\", -1, VALL, 0},\n  {0xFFD7, \"PRIVATE_CIPHER_215\", -1, VALL, 0},\n  {0xFFD8, \"PRIVATE_CIPHER_216\", -1, VALL, 0},\n  {0xFFD9, \"PRIVATE_CIPHER_217\", -1, VALL, 0},\n  {0xFFDA, \"PRIVATE_CIPHER_218\", -1, VALL, 0},\n  {0xFFDB, \"PRIVATE_CIPHER_219\", -1, VALL, 0},\n  {0xFFDC, \"PRIVATE_CIPHER_220\", -1, VALL, 0},\n  {0xFFDD, \"PRIVATE_CIPHER_221\", -1, VALL, 0},\n  {0xFFDE, \"PRIVATE_CIPHER_222\", -1, VALL, 0},\n  {0xFFDF, \"PRIVATE_CIPHER_223\", -1, VALL, 0},\n  {0xFFE0, \"PRIVATE_CIPHER_224\", -1, VALL, 0},\n  {0xFFE1, \"PRIVATE_CIPHER_225\", -1, VALL, 0},\n  {0xFFE2, \"PRIVATE_CIPHER_226\", -1, VALL, 0},\n  {0xFFE3, \"PRIVATE_CIPHER_227\", -1, VALL, 0},\n  {0xFFE4, \"PRIVATE_CIPHER_228\", -1, VALL, 0},\n  {0xFFE5, \"PRIVATE_CIPHER_229\", -1, VALL, 0},\n  {0xFFE6, \"PRIVATE_CIPHER_230\", -1, VALL, 0},\n  {0xFFE7, \"PRIVATE_CIPHER_231\", -1, VALL, 0},\n  {0xFFE8, \"PRIVATE_CIPHER_232\", -1, VALL, 0},\n  {0xFFE9, \"PRIVATE_CIPHER_233\", -1, VALL, 0},\n  {0xFFEA, \"PRIVATE_CIPHER_234\", -1, VALL, 0},\n  {0xFFEB, \"PRIVATE_CIPHER_235\", -1, VALL, 0},\n  {0xFFEC, \"PRIVATE_CIPHER_236\", -1, VALL, 0},\n  {0xFFED, \"PRIVATE_CIPHER_237\", -1, VALL, 0},\n  {0xFFEE, \"PRIVATE_CIPHER_238\", -1, VALL, 0},\n  {0xFFEF, \"PRIVATE_CIPHER_239\", -1, VALL, 0},\n  {0xFFF0, \"PRIVATE_CIPHER_240\", -1, VALL, 0},\n  {0xFFF1, \"PRIVATE_CIPHER_241\", -1, VALL, 0},\n  {0xFFF2, \"PRIVATE_CIPHER_242\", -1, VALL, 0},\n  {0xFFF3, \"PRIVATE_CIPHER_243\", -1, VALL, 0},\n  {0xFFF4, \"PRIVATE_CIPHER_244\", -1, VALL, 0},\n  {0xFFF5, \"PRIVATE_CIPHER_245\", -1, VALL, 0},\n  {0xFFF6, \"PRIVATE_CIPHER_246\", -1, VALL, 0},\n  {0xFFF7, \"PRIVATE_CIPHER_247\", -1, VALL, 0},\n  {0xFFF8, \"PRIVATE_CIPHER_248\", -1, VALL, 0},\n  {0xFFF9, \"PRIVATE_CIPHER_249\", -1, VALL, 0},\n  {0xFFFA, \"PRIVATE_CIPHER_250\", -1, VALL, 0},\n  {0xFFFB, \"PRIVATE_CIPHER_251\", -1, VALL, 0},\n  {0xFFFC, \"PRIVATE_CIPHER_252\", -1, VALL, 0},\n  {0xFFFD, \"PRIVATE_CIPHER_253\", -1, VALL, 0},\n  {0xFFFE, \"PRIVATE_CIPHER_254\", -1, VALL, 0},\n  {0xFFFF, \"PRIVATE_CIPHER_255\", -1, VALL, 0},\n};\n\n#endif\n"
        },
        {
          "name": "sslscan.1",
          "type": "blob",
          "size": 5.3134765625,
          "content": ".TH SSLSCAN 1 \"March 19, 2020\"\n.SH NAME\nsslscan \\- Fast SSL/TLS scanner\n.SH SYNOPSIS\n.B sslscan\n.RI [ options ] \" [host:port | host]\"\n.SH DESCRIPTION\n.PP\n\\fBsslscan\\fP queries SSL/TLS services (such as HTTPS) and reports the protocol versions, cipher suites, key exchanges, signature algorithms, and certificates in use.  This helps the user understand which parameters are weak from a security standpoint.\n\nTerminal output is thus colour-coded as follows:\n\nRed Background  NULL cipher (no encryption)\n.br\nRed             Broken cipher (<= 40 bit), broken protocol (SSLv2 or SSLv3) or broken certificate signing algorithm (MD5)\n.br\nYellow          Weak cipher (<= 56 bit or RC4) or weak certificate signing algorithm (SHA-1)\n.br\nPurple          Anonymous cipher (ADH or AECDH)\n\n\\fBsslscan\\fP can also output results into an XML file for easy consumption by external programs.\n\n.SH OPTIONS\n.TP\n.B \\-\\-help\n.br\nShow summary of options\n.TP\n.B \\-\\-targets=<file>\nA file containing a list of hosts to\ncheck. Hosts can be supplied with\nports (i.e. host:port). One target per line\n.TP\n.B \\-\\-sni\\-name=<name>\nUse a different hostname for SNI\n.br\n.TP\n.B \\-\\-ipv4, \\-4\n.br\nForce IPv4 DNS resolution.\nDefault is to try IPv4, and if that fails then fall back to IPv6.\n.TP\n.B \\-\\-ipv6, \\-6\n.br\nForce IPv6 DNS resolution.\nDefault is to try IPv4, and if that fails then fall back to IPv6.\n.TP\n.B \\-\\-show\\-certificate\nDisplay certificate information.\n.TP\n.B \\-\\-show\\-certificates\nDisplay the full certificate chain.\n.TP\n.B \\-\\-no\\-check\\-certificate\n.B \\-\\-no\\-check\\-certificate\nDon't flag certificates signed with weak algorithms (MD5 and SHA-1) or short (<2048 bit) RSA keys\n.TP\n.B \\-\\-show\\-client\\-cas\nShow a list of CAs that the server allows for client authentication. Will be blank for IIS/Schannel servers.\n.TP\n.B \\-\\-show\\-ciphers\nShow a complete list of ciphers supported by sslscan\n.TP\n.B \\-\\-show\\-cipher-ids\nPrint the hexadecimal cipher IDs\n.TP\n.B \\-\\-iana\\-names\nUse IANA/RFC cipher names rather than OpenSSL ones\n.TP\n.B \\-\\-show\\-times\nShow the time taken for each handshake in milliseconds. Note that only a single request is made with each cipher, and that the size of the ClientHello is not constant, so this should not be used for proper benchmarking or performance testing.\n\nYou might want to also use \\-\\-no\\-cipher\\-details to make the output a bit clearer.\n.TP\n.B \\-\\-ssl2\n.br\nOnly check if SSLv2 is enabled\n.TP\n.B \\-\\-ssl3\n.br\nOnly check if SSLv3 is enabled\n.TP\n.B \\-\\-tls10\n.br\nOnly check TLS 1.0 ciphers\n.TP\n.B \\-\\-tls11\n.br\nOnly check TLS 1.1 ciphers\n.TP\n.B \\-\\-tls12\n.br\nOnly check TLS 1.2 ciphers\n.TP\n.B \\-\\-tls13\n.br\nOnly check TLS 1.3 ciphers\n.TP\n.B \\-\\-tlsall\n.br\nOnly check TLS ciphers (versions 1.0, 1.1, 1.2, and 1.3)\n.TP\n.B \\-\\-ocsp\n.br\nDisplay OCSP status\n.TP\n.B \\-\\-pk=<file>\nA file containing the private key or\na PKCS#12 file containing a private\nkey/certificate pair (as produced by\nMSIE and Netscape)\n.TP\n.B \\-\\-pkpass=<password>\nThe password for the private key or PKCS#12 file\n.TP\n.B \\-\\-certs=<file>\nA file containing PEM/ASN1 formatted client certificates\n.TP\n.B \\-\\-no\\-ciphersuites\nDo not scan for supported ciphersuites.\n.TP\n.B \\-\\-no\\-fallback\nDo not check for TLS Fallback Signaling Cipher Suite Value (fallback)\n.TP\n.B \\-\\-no\\-renegotiation\nDo not check for secure TLS renegotiation\n.TP\n.B \\-\\-no\\-compression\nDo not check for TLS compression (CRIME)\n.TP\n.B \\-\\-no\\-heartbleed\nDo not check for OpenSSL Heartbleed (CVE-2014-0160)\n.TP\n.B \\-\\-no\\-groups\nDo not enumerate key exchange groups\n.TP\n.B \\-\\-show\\-sigs\nEnumerate signature algorithms\n.TP\n.B \\-\\-starttls\\-ftp\nSTARTTLS setup for FTP\n.TP\n.B \\-\\-starttls\\-imap\nSTARTTLS setup for IMAP\n.TP\n.B \\-\\-starttls\\-irc\nSTARTTLS setup for IRC\n.TP\n.B \\-\\-starttls\\-ldap\nSTARTTLS setup for LDAP\n.TP\n.B \\-\\-starttls\\-pop3\nSTARTTLS setup for POP3\n.TP\n.B \\-\\-starttls\\-smtp\nSTARTTLS setup for SMTP\n.TP\n.B \\-\\-starttls\\-mysql\nSTARTTLS setup for MySQL\n.TP\n.B \\-\\-starttls\\-xmpp\nSTARTTLS setup for XMPP\n.TP\n.B \\-\\-starttls\\-psql\nSTARTTLS setup for PostgreSQL\n.TP\n.B \\-\\-xmpp-server\nPerform a server-to-server XMPP connection. Try this if --starttls-xmpp is failing.\n.TP\n.B \\-\\-rdp\n.br\nSend RDP preamble before starting scan.\n.TP\n.B \\-\\-bugs\n.br\nEnables workarounds for SSL bugs\n.TP\n.B \\-\\-timeout=<sec>\n.br\nSet socket timeout. Useful for hosts that fail to respond to ciphers they don't understand. Default is 3s.\n.TP\n.B \\-\\-connect\\-timeout=<sec>\n.br\nSet initial connection timeout. Useful for hosts that are slow to respond to the initial connect(). Default is 75s.\n.TP\n.B \\-\\-sleep=<msec>\n.br\nPause between connections. Useful on STARTTLS SMTP services, or anything else that's performing rate limiting. Default is disabled.\n.TP\n.B \\-\\-xml=<file>\n.br\nOutput results to an XML file. - can be used to mean stdout.\n.br\n.TP\n.B \\-\\-version\nShow version of program\n.TP\n.B \\-\\-verbose\nDisplay verbose output\n.TP\n.B \\-\\-no\\-cipher\\-details\n.br\nHide NIST EC curve name and EDH/RSA key length.\n.TP\n.B \\-\\-no-colour\n.br\nDisable coloured output.\n.SH EXAMPLES\n.LP\nScan a local HTTPS server\n.RS\n.nf\nsslscan localhost\nsslscan 127.0.0.1\nsslscan 127.0.0.1:443\nsslscan [::1]\nsslscan [::1]:443\n.SH AUTHOR\nsslscan was originally written by Ian Ventura-Whiting <fizz@titania.co.uk>.\n.br\nsslscan was extended by Jacob Appelbaum <jacob@appelbaum.net>.\n.br\nsslscan was extended by rbsec <robin@rbsec.net>.\n.br\nThis manual page was originally written by Marvin Stark <marv@der-marv.de>.\n"
        },
        {
          "name": "sslscan.c",
          "type": "blob",
          "size": 239.0771484375,
          "content": "/***************************************************************************\n *   sslscan - A SSL cipher scanning tool                                  *\n *   Copyright 2007-2009 by Ian Ventura-Whiting (Fizz)                     *\n *   fizz@titania.co.uk                                                    *\n *   Copyright 2010 by Michael Boman (michael@michaelboman.org)            *\n *   Copyleft 2010 by Jacob Appelbaum <jacob@appelbaum.net>                *\n *   Copyleft 2013 by rbsec <robin@rbsec.net>                              *\n *   Copyleft 2014 by Julian Kornberger <jk+github@digineo.de>             *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 3 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program. If not, see <http://www.gnu.org/licenses/>.  *\n *                                                                         *\n *   In addition, as a special exception, the copyright holders give       *\n *   permission to link the code of portions of this program with the      *\n *   OpenSSL library under certain conditions as described in each         *\n *   individual source file, and distribute linked combinations            *\n *   including the two.                                                    *\n *   You must obey the GNU General Public License in all respects          *\n *   for all of the code used other than OpenSSL.  If you modify           *\n *   file(s) with this exception, you may extend this exception to your    *\n *   version of the file(s), but you are not obligated to do so.  If you   *\n *   do not wish to do so, delete this exception statement from your       *\n *   version.  If you delete this exception statement from all source      *\n *   files in the program, then also delete it here.                       *\n ***************************************************************************/\n\n#define _GNU_SOURCE\n\n// Includes...\n#ifdef _WIN32\n  #define WIN32_LEAN_AND_MEAN\n  #define VC_EXTRALEAN\n  #define _WIN32_WINNT 0x0501\n  #include <windows.h>\n  #include <winsock2.h>\n  #include <ws2tcpip.h>\n  #include <stdint.h>\n  #include <winbase.h>\n  #ifdef _MSC_VER\n    // For access().\n    #include <io.h>\n\n    // Flag for access() call.\n    #define R_OK 4\n\n    // access() happens to be deprecated, so use the secure version instead.\n    #define access _access_s\n\n    // There is no snprintf(), but _snprintf() instead.\n    #define snprintf _snprintf\n\n    // Calling close() on a socket descriptor instead of closesocket() causes\n    // a crash!\n    #define close closesocket\n\n    // Visual Studio doesn't have ssize_t...\n    typedef int ssize_t;\n  #else\n    void *memmem(const void *haystack_start, size_t haystack_len, const void *needle, size_t needle_len);\n    /* Taken from https://sourceforge.net/p/mingw/bugs/_discuss/thread/ec0291f1/93ae/attachment/patchset-wrapped.diff:*/\n    #define timersub(a, b, result) \\\n    do { \\\n        (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; \\\n        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \\\n        if ((result)->tv_usec < 0) { \\\n            --(result)->tv_sec; \\\n            (result)->tv_usec += 1000000L; \\\n        } \\\n    } while (0)\n \n    #ifdef BUILD_32BIT\n      #include \"win32bit-compat.h\"\n    #endif\n  #endif\n\n  #ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING\n    #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004\n  #endif\n#else\n  #include <netdb.h>\n  #include <sys/socket.h>\n  #include <sys/select.h>\n  #include <fcntl.h>\n#endif\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <openssl/ec.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include <openssl/pkcs12.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include <openssl/ocsp.h>\n#ifdef __linux__\n    #include <arpa/inet.h>\n#endif\n#ifndef OPENSSL_NO_COMP\n  #include <openssl/comp.h>\n#endif\n\n// If we're not compiling with Visual Studio, include unistd.h.  VS\n// doesn't have this header.\n#ifndef _MSC_VER\n  #include <unistd.h>\n#endif\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n#include <netinet/in.h>\n#endif\n\n/* Format specifier for printing a size_t. */\n#ifdef _WIN32\n  #define SIZE_T_FMT PRIu64\n#else\n  #define SIZE_T_FMT \"zu\"\n#endif\n\n#include \"sslscan.h\"\n\n#if OPENSSL_VERSION_NUMBER < 0x1010100fL\n#error \"OpenSSL v1.1.1 or later is required!\"\n#endif\n\n/* Borrowed from tortls.c to dance with OpenSSL on many platforms, with\n * many versions and releases of OpenSSL. */\n/** Does the run-time openssl version look like we need\n * SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION? */\nstatic int use_unsafe_renegotiation_op = 0;\n\n/** Does the run-time openssl version look like we need\n * SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION? */\nstatic int use_unsafe_renegotiation_flag = 0;\n\n/** Does output xml to stdout? */\nstatic int xml_to_stdout = 0;\n\n#if OPENSSL_VERSION_NUMBER < 0x1000100L\nunsigned long SSL_CIPHER_get_id(const SSL_CIPHER* cipher) { return cipher->id; }\n#endif\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n\nconst SSL_METHOD *TLSv1_3_client_method(void)\n{\n    return TLS_client_method();\n}\n\nconst SSL_METHOD *TLSv1_3_method(void)\n{\n    return TLS_method();\n}\n\n/* Callback set through SSL_set_security_callback() and SSL_CTX_set_security_callback().  Allows all weak algorithms. */\nstatic int security_callback_allow_all(const SSL *s, const SSL_CTX *ctx, int op, int bits, int nid, void *other, void *ex) {\n  return 1;\n}\n\n/* Creates an SSL_CTX using SSL_CTX_new(), sets the security level to 0, and sets the permissive security callback on it.  Free with FREE_CTX(). */\nSSL_CTX *new_CTX(const SSL_METHOD *method) {\n  SSL_CTX *ret = SSL_CTX_new(method);\n  SSL_CTX_set_security_level(ret, 0);\n  SSL_CTX_set_security_callback(ret, security_callback_allow_all);\n  SSL_CTX_set_quiet_shutdown(ret, 1);\n  return ret;\n}\n\n/* Creates an SSL object using SSL_new(), sets the security level to 0, and sets the permissive security callback on it.  Free with FREE_SSL(). */\nSSL *new_SSL(SSL_CTX *ctx) {\n  SSL *ret = SSL_new(ctx);\n  SSL_set_security_level(ret, 0);\n  SSL_set_security_callback(ret, security_callback_allow_all);\n  return ret;\n}\n\n// Adds Ciphers to the Cipher List structure\nint populateCipherList(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    int returnCode = true;\n    struct sslCipher *sslCipherPointer;\n    int tempInt;\n    int loop;\n    // STACK_OF is a sign that you should be using C++ :)\n    STACK_OF(SSL_CIPHER) *cipherList;\n    SSL *ssl = NULL;\n    options->ctx = new_CTX(sslMethod);\n    if (options->ctx == NULL) {\n        printf_error(\"Could not create CTX object.\");\n        return false;\n    }\n    SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL);\n    ssl = new_SSL(options->ctx);\n    if (ssl == NULL) {\n        printf_error(\"Could not create SSL object.\");\n        FREE_CTX(options->ctx);\n        return false;\n    }\n    cipherList = SSL_get_ciphers(ssl);\n    // Create Cipher Struct Entries...\n    for (loop = 0; loop < sk_SSL_CIPHER_num(cipherList); loop++)\n    {\n        if (options->ciphers == 0)\n        {\n            options->ciphers = malloc(sizeof(struct sslCipher));\n            sslCipherPointer = options->ciphers;\n        }\n        else\n        {\n            sslCipherPointer = options->ciphers;\n            while (sslCipherPointer->next != 0)\n                sslCipherPointer = sslCipherPointer->next;\n            sslCipherPointer->next = malloc(sizeof(struct sslCipher));\n            sslCipherPointer = sslCipherPointer->next;\n        }\n        // Init\n        memset(sslCipherPointer, 0, sizeof(struct sslCipher));\n        // Add cipher information...\n        sslCipherPointer->sslMethod = sslMethod;\n        sslCipherPointer->name = SSL_CIPHER_get_name(sk_SSL_CIPHER_value(cipherList, loop));\n        sslCipherPointer->version = SSL_CIPHER_get_version(sk_SSL_CIPHER_value(cipherList, loop));\n        SSL_CIPHER_description(sk_SSL_CIPHER_value(cipherList, loop), sslCipherPointer->description, sizeof(sslCipherPointer->description) - 1);\n        sslCipherPointer->bits = SSL_CIPHER_get_bits(sk_SSL_CIPHER_value(cipherList, loop), &tempInt);\n    }\n    FREE_SSL(ssl);\n    FREE_CTX(options->ctx);\n    return returnCode;\n}\n\n// File Exists\nint fileExists(char *fileName)\n{\n    return access(fileName, R_OK) == 0;\n}\n\n// Read a line from the input...\nvoid readLine(FILE *input, char *lineFromFile, int maxSize)\n{\n    // Variables...\n    int stripPointer;\n\n    // Read line from file...\n    fgets(lineFromFile, maxSize, input);\n\n    // Clear the end-of-line stuff...\n    stripPointer = strlen(lineFromFile) -1;\n    while (stripPointer >= 0 && ((lineFromFile[stripPointer] == '\\r') || (lineFromFile[stripPointer] == '\\n') || (lineFromFile[stripPointer] == ' ')))\n    {\n        lineFromFile[stripPointer] = 0;\n        stripPointer--;\n    }\n}\n\n\nint readOrLogAndClose(int fd, void* buffer, size_t len, const struct sslCheckOptions *options)\n{\n    ssize_t n;\n\n    if (len < 2)\n        return 1;\n\n    n = recv(fd, buffer, len - 1, 0);\n\n    if (n < 0 && errno != 11) {\n        printf_error(\"Error reading from %s:%d: %s\", options->host, options->port, strerror(errno));\n        close(fd);\n        return 0;\n    } else if (n == 0) {\n        printf_error(\"Unexpected EOF reading from %s:%d\", options->host, options->port);\n        close(fd);\n        return 0;\n    } else {\n        ((unsigned char *)buffer)[n] = 0;\n    }\n\n    return 1;\n}\n\n// Write a null-terminated string to a socket\nssize_t sendString(int sockfd, const char str[])\n{\n    return send(sockfd, str, strlen(str), 0);\n}\n\nchar *sock_strerror(int err)\n{\n#ifdef _WIN32\n    static char msg[255];\n\n    msg[0] = '\\0';\n\n    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n            NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), msg, sizeof(msg), NULL) == 0 || msg[0] == '\\0')\n    {\n        sprintf(msg, \"Error code %d\", err);\n    }\n\n    return msg;\n#else\n    return strerror(err);\n#endif\n}\n\nint tcpConnectSocket(int socket, struct sslCheckOptions *options, char *error, int errlen)\n{\n    int status = -1, flags, errn = 0, len;\n    fd_set rset, wset, eset;\n    struct timeval tval;\n\n#ifdef _WIN32\n#define INPROGRESS  WSAEWOULDBLOCK\n#define sock_errno WSAGetLastError()\n    flags = 1;\n\n    if ((status = ioctlsocket(socket, FIONBIO, (u_long *)&flags)) != 0)\n    {\n        snprintf(error, errlen, \"ioctlsocket: %s\", sock_strerror(sock_errno));\n        return status;\n    }\n#else\n#define INPROGRESS  EINPROGRESS\n#define sock_errno errno\n    if ((flags = fcntl(socket, F_GETFL, 0)) < 0)\n    {\n        snprintf(error, errlen, \"fcntl getfl: %s\", sock_strerror(sock_errno));\n        return status;\n    }\n\n    if (fcntl(socket, F_SETFL, flags | O_NONBLOCK) < 0)\n    {\n        snprintf(error, errlen, \"fcntl setfl: %s\", sock_strerror(sock_errno));\n        return status;\n    }\n#endif\n\n    // Connect\n    if (options->h_addrtype == AF_INET)\n    {\n        status = connect(socket, (struct sockaddr *)&options->serverAddress, sizeof(options->serverAddress));\n    }\n    else    // IPv6\n    {\n        status = connect(socket, (struct sockaddr *)&options->serverAddress6, sizeof(options->serverAddress6));\n    }\n\n    if (status < 0 && sock_errno != INPROGRESS)\n    {\n        snprintf(error, errlen, \"connect: %s\", sock_strerror(sock_errno));\n        return status;\n    }\n\n    // connect() completed immediately\n    if (status == 0)\n        return status;\n\n    FD_ZERO(&rset);\n    FD_SET(socket, &rset);\n    wset = eset = rset;\n    tval.tv_sec = options->connect_timeout;\n    tval.tv_usec = 0;\n\n    if ((status = select(socket + 1, &rset, &wset, &eset, &tval)) == 0)\n    {\n        snprintf(error, errlen, \"connect: Timed out\");\n        return -1;\n    }\n    else if (status < 0)\n    {\n        snprintf(error, errlen, \"connect: select: %s\", sock_strerror(sock_errno));\n        return status;\n    }\n\n    if (FD_ISSET(socket, &rset) || FD_ISSET(socket, &wset) || FD_ISSET(socket, &eset))\n    {\n        len = sizeof(errn);\n        if (getsockopt(socket, SOL_SOCKET, SO_ERROR, (void *)&errn, (socklen_t *)&len) < 0)\n        {\n            snprintf(error, errlen, \"connect: getsockopt: %s\", sock_strerror(errn));\n            return -1;\n        }\n    }\n\n    if (errn)\n    {\n        snprintf(error, errlen, \"connect: %s\", sock_strerror(errn));\n        return -1;\n    }\n\n#ifdef _WIN32\n    flags = 0;\n\n    if ((status = ioctlsocket(socket, FIONBIO, (u_long *)&flags)) != NO_ERROR)\n    {\n        snprintf(error, errlen, \"ioctlsocket: %s\", sock_strerror(sock_errno));\n        return -1;\n    }\n#else\n    if (fcntl(socket, F_SETFL, flags) < 0)\n    {\n        snprintf(error, errlen, \"fcntl setfl: %s\", sock_strerror(sock_errno));\n        return -1;\n    }\n#endif\n\n    return status;\n}\n\n// Create a TCP socket\nint tcpConnect(struct sslCheckOptions *options)\n{\n    //Sleep if required\n    if (options->sleep > 0)\n    {\n        SLEEPMS(options->sleep);\n    }\n\n    // Variables...\n    int socketDescriptor;\n    int tlsStarted = 0;\n    char buffer[BUFFERSIZE], errmsg[BUFFERSIZE];\n    int status;\n\n    // Create Socket\n    if (options->h_addrtype == AF_INET)\n    {\n        socketDescriptor = socket(AF_INET, SOCK_STREAM, 0);\n    }\n    else    // IPv6\n    {\n        socketDescriptor = socket(AF_INET6, SOCK_STREAM, 0);\n    }\n\n    if(socketDescriptor < 0)\n    {\n        printf_error(\"Could not open a socket.\");\n        return 0;\n    }\n\n    // Set socket timeout\n#ifdef _WIN32\n    // Windows isn't looking for a timeval struct like in UNIX; it wants a timeout in a DWORD represented in milliseconds...\n    DWORD timeout = (options->timeout.tv_sec * 1000) + (options->timeout.tv_usec / 1000);\n    setsockopt(socketDescriptor, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));\n    setsockopt(socketDescriptor, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout, sizeof(timeout));\n#else\n    setsockopt(socketDescriptor, SOL_SOCKET, SO_RCVTIMEO, (char *)&options->timeout, sizeof(struct timeval));\n    setsockopt(socketDescriptor, SOL_SOCKET, SO_SNDTIMEO, (char *)&options->timeout, sizeof(struct timeval));\n#endif\n\n    status = tcpConnectSocket(socketDescriptor, options, errmsg, BUFFERSIZE);\n\n    if(status < 0)\n    {\n        printf_error(\"Could not open a connection to host %s (%s) on port %d (%s).\", options->host, options->addrstr,\n                options->port, errmsg);\n        close(socketDescriptor);\n        return 0;\n    }\n\n    // If STARTTLS is required...\n    if (options->starttls_smtp == true && tlsStarted == false)\n    {\n        tlsStarted = 1;\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n\n        if (strncmp(buffer, \"220\", 3) != 0)\n        {\n            close(socketDescriptor);\n            printf_error(\"The host %s on port %d did not appear to be an SMTP service.\", options->host, options->port);\n            return 0;\n        }\n        sendString(socketDescriptor, \"EHLO example.org\\r\\n\");\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        if (strncmp(buffer, \"250\", 3) != 0)\n        {\n            close(socketDescriptor);\n            printf_error(\"The SMTP service on %s port %d did not respond with status 250 to our HELO.\", options->host, options->port);\n            return 0;\n        }\n        sendString(socketDescriptor, \"STARTTLS\\r\\n\");\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        if (strncmp(buffer, \"220\", 3) != 0)\n        {\n            close(socketDescriptor);\n            printf_error(\"The SMTP service on %s port %d did not appear to support STARTTLS.\", options->host, options->port);\n            return 0;\n        }\n    }\n\n    if (options->starttls_mysql == true && tlsStarted == false)\n    {\n        tlsStarted = 1;\n        // Taken from https://github.com/tetlowgm/sslscan/blob/master/sslscan.c\n\n        const char mysqlssl[] = { 0x20, 0x00, 0x00, 0x01, 0x85, 0xae, 0x7f, 0x00,\n            0x00, 0x00, 0x00, 0x01, 0x21, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00};\n\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        send(socketDescriptor, mysqlssl, sizeof(mysqlssl), 0);\n    }\n\n    // We could use an XML parser but frankly it seems like a security disaster\n    if (options->starttls_xmpp == true && tlsStarted == false)\n    {\n        /* This is so ghetto, you cannot release it! */\n        char xmpp_setup[1024]; // options->host is 512 bytes long\n        /* XXX: TODO - options->host isn't always the host you want to test\n           eg:\n           talk.google.com actually expects gmail.com, not talk.google.com\n           jabber.ccc.de expects jabber.ccc.de\n\n           It may be useful to provide a commandline switch to provide the\n           expected hostname.\n        */\n        // Server to server handshake\n        if (options->xmpp_server)\n        {\n            if (snprintf(xmpp_setup, sizeof(xmpp_setup), \"<?xml version='1.0' ?>\\r\\n\"\n                        \"<stream:stream xmlns:stream='http://etherx.jabber.org/streams' xmlns='jabber:server' to='%s' version='1.0'>\\r\\n\", options->host) >= sizeof(xmpp_setup)) {\n                printf(\"(internal error: xmpp_setup buffer too small)\\n\");\n                abort();\n            }\n        }\n        // Client to server handshake (default)\n        else\n        {\n            if (snprintf(xmpp_setup, sizeof(xmpp_setup), \"<?xml version='1.0' ?>\\r\\n\"\n                        \"<stream:stream xmlns:stream='http://etherx.jabber.org/streams' xmlns='jabber:client' to='%s' version='1.0'>\\r\\n\", options->host) >= sizeof(xmpp_setup)) {\n                printf(\"(internal error: xmpp_setup buffer too small)\\n\");\n                abort();\n            }\n        }\n        tlsStarted = 1;\n        sendString(socketDescriptor, xmpp_setup);\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n\n        printf_verbose(\"Server reported: %s\\nAttempting to STARTTLS\\n\", buffer);\n\n        sendString(socketDescriptor, \"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\\r\\n\");\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n\n        /* We're looking for something like:\n        <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'\n        If we find the end of the stream features before we find tls, we may\n        not have STARTTLS support. */\n        if (strstr(buffer, \"urn:ietf:params:xml:ns:xmpp-tls\")) {\n            printf_verbose(\"It appears that xmpp-tls was detected.\\n\");\n        } else if (strstr(buffer, \"/stream:features\")) {\n            printf_verbose(\"It appears that xmpp-tls was not detected.\\n\");\n        }\n\n        if (options->verbose)\n            printf(\"Server reported: %s\\n\", buffer);\n\n        if (strstr(buffer, \"<proceed\"))\n        {\n            printf_verbose(\"It appears that xmpp-tls is ready for TLS.\\n\");\n        }\n        else\n        {\n            if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n                return 0;\n        }\n\n        printf_verbose(\"Server reported: %s\\n\", buffer);\n\n    }\n\n    // Setup a POP3 STARTTLS socket\n    if (options->starttls_pop3 == true && tlsStarted == false)\n    {\n        tlsStarted = 1;\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        printf_verbose(\"Server reported: %s\\n\", buffer);\n\n        sendString(socketDescriptor, \"STLS\\r\\n\");\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        // We probably want to confirm that we see something like:\n        // '+OK Begin SSL/TLS negotiation now.'\n        // Or\n        // '+OK Begin TLS negotiation, mate'\n        if (strstr(buffer, \"+OK Begin\")) {\n            printf_verbose(\"It appears that the POP3 server is ready for TLS.\\n\");\n        }\n        printf_verbose(\"Server reported: %s\\n\", buffer);\n    }\n\n    // Setup an IMAP STARTTLS socket\n    if (options->starttls_imap == true && tlsStarted == false)\n    {\n        tlsStarted = 1;\n        memset(buffer, 0, BUFFERSIZE);\n\n        // Fetch the IMAP banner\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        printf_verbose(\"Server banner: %s\\n\", buffer);\n\n        // Attempt to STARTTLS\n        sendString(socketDescriptor, \". STARTTLS\\r\\n\");\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n\n        if (strstr(buffer, \". OK\") || strstr(buffer, \" . OK\")){\n            printf_verbose(\"STARTLS IMAP setup complete.\\nServer reported: %s\\n\", buffer);\n        } else{\n            printf_verbose(\"STARTLS IMAP setup not complete.\\nServer reported: %s\\n\", buffer);\n        }\n    }\n\n    if (options->starttls_irc == true && tlsStarted == false)\n    {\n        tlsStarted = 1;\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        printf_verbose(\"Server reported: %s\\n\", buffer);\n\n        // Attempt to STARTTLS\n        sendString(socketDescriptor, \"STARTTLS\\r\\n\");\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n\n        if (strstr(buffer, \" 670 \") || strstr(buffer, \":STARTTLS successful\")) {\n            printf_verbose(\"STARTLS IRC setup complete.\\nServer reported %s\\n\", buffer);\n        } else {\n            printf_verbose(\"STARTLS IRC setup not complete.\\nServer reported %s\\n\", buffer);\n        }\n    }\n\n    // Setup a LDAP STARTTLS socket\n    if (options->starttls_ldap == true && tlsStarted == false)\n    {\n        tlsStarted = 1;\n        memset(buffer, 0, BUFFERSIZE);\n        char starttls[] = {'0', 0x1d, 0x02, 0x01, 0x01, 'w', 0x18, 0x80, 0x16,\n            '1', '.', '3', '.', '6', '.', '1', '.', '4', '.', '1', '.',\n            '1', '4', '6', '6', '.', '2', '0', '0', '3', '7'};\n        char ok[] = \"1.3.6.1.4.1.1466.20037\";\n        char unsupported[] = \"unsupported extended operation\";\n\n        // Send TLS\n        send(socketDescriptor, starttls, sizeof(starttls), 0);\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n\n        if (memmem(buffer, BUFFERSIZE, ok, strlen(ok))) {\n            printf_verbose(\"STARTLS LDAP setup complete.\\n\");\n        }\n        else if (strstr(buffer, unsupported)) {\n            printf_error(\"STARTLS LDAP connection to %s:%d failed with '%s'.\",\n                         options->host, options->port, unsupported);\n            return 0;\n        } else {\n            printf_error(\"STARTLS LDAP connection to %s:%d failed with unknown error.\",\n                         options->host, options->port);\n            return 0;\n        }\n    }\n\n    // Setup a FTP STARTTLS socket\n    if (options->starttls_ftp == true && tlsStarted == false)\n    {\n        tlsStarted = 1;\n\n        // Fetch the server banner\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        printf_verbose(\"Server banner: %s\\n\", buffer);\n\n        // Send TLS request\n        sendString(socketDescriptor, \"AUTH TLS\\r\\n\");\n        if (!readOrLogAndClose(socketDescriptor, buffer, BUFFERSIZE, options))\n            return 0;\n        if (strstr(buffer, \"234 AUTH TLS successful\")) {\n            printf_verbose(\"STARTLS FTP setup complete.\\n\");\n        } else {\n            printf_verbose(\"STARTLS FTP setup possibly not complete.\\n\");\n        }\n        printf_verbose(\"Server reported: %s\\n\", buffer);\n    }\n\n    if (options->starttls_psql == true && tlsStarted == false)\n    {\n        unsigned char buffer;\n\n        tlsStarted = 1;\n\n        // Send SSLRequest packet\n        send(socketDescriptor, \"\\x00\\x00\\x00\\x08\\x04\\xd2\\x16\\x2f\", 8, 0);\n\n        // Read reply byte\n        if (1 != recv(socketDescriptor, &buffer, 1, 0)) {\n            printf_error(\"Unexpected EOF reading from %s:%d\", options->host, options->port);\n            return 0;\n        }\n\n        if (buffer != 'S') {\n            printf_error(\"Server at %s:%d rejected TLS startup\", options->host, options->port);\n            return 0;\n        }\n    }\n\n    // Setup an RDP socket with preamble\n    // Borrowed from https://labs.portcullis.co.uk/tools/ssl-cipher-suite-enum/\n    if (options->rdp == true && tlsStarted == false)\n    {\n        unsigned char buffer[32768];\n        size_t readlen;\n\n        tlsStarted = 1;\n\n        // Send RDP preamble\n        send(socketDescriptor, \"\\x03\\x00\\x00\\x13\\x0e\\xe0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x08\\x00\\x03\\x00\\x00\\x00\", 19, 0);\n\n        // Read reply header\n        if (4 != recv(socketDescriptor, buffer, 4, 0)) {\n            printf_error(\"Unexpected EOF reading from %s:%d\", options->host, options->port);\n            return 0;\n        }\n\n        // Calculate remaining bytes (and check for overflows)\n        readlen = ((buffer[2] & 0x7f) << 8) + buffer[3] - 4;\n        if (readlen > sizeof(buffer)) {\n            printf_error(\"Unexpected data from %s:%d\", options->host, options->port);\n            return 0;\n\n        }\n\n        // Read reply data\n        if (readlen != recv(socketDescriptor, buffer, readlen, 0)) {\n            printf_error(\"Unexpected EOF reading from %s:%d\", options->host, options->port);\n            return 0;\n        }\n    }\n\n    // Return\n    return socketDescriptor;\n}\n\n// Private Key Password Callback...\nstatic int password_callback(char *buf, int size, int rwflag, void *userdata)\n{\n    strncpy(buf, (char *)userdata, size);\n    // I don't know the semantics of these arguments, but it looks like this\n    // could go badly wrong if userdata is too long.\n    buf[strlen(userdata)] = 0;\n    return strlen(userdata);\n}\n\n// Load client certificates/private keys...\nint loadCerts(struct sslCheckOptions *options)\n{\n    // Variables...\n    int status = 1;\n    PKCS12 *pk12 = NULL;\n    FILE *pk12File = NULL;\n    X509 *cert = NULL;\n    EVP_PKEY *pkey = NULL;\n    STACK_OF(X509) *ca = NULL;\n\n    // Configure PKey password...\n    if (options->privateKeyPassword != 0)\n    {\n        SSL_CTX_set_default_passwd_cb_userdata(options->ctx, (void *)options->privateKeyPassword);\n        SSL_CTX_set_default_passwd_cb(options->ctx, password_callback);\n    }\n\n    // Separate Certs and PKey Files...\n    if ((options->clientCertsFile != 0) && (options->privateKeyFile != 0))\n    {\n        // Load Cert...\n        if (!SSL_CTX_use_certificate_file(options->ctx, options->clientCertsFile, SSL_FILETYPE_PEM))\n        {\n            if (!SSL_CTX_use_certificate_file(options->ctx, options->clientCertsFile, SSL_FILETYPE_ASN1))\n            {\n                if (!SSL_CTX_use_certificate_chain_file(options->ctx, options->clientCertsFile))\n                {\n                    printf(\"%s    Could not configure certificate(s).%s\\n\", COL_RED, RESET);\n                    status = 0;\n                }\n            }\n        }\n\n        // Load PKey...\n        if (status != 0)\n        {\n            if (!SSL_CTX_use_PrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_PEM))\n            {\n                if (!SSL_CTX_use_PrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_ASN1))\n                {\n                    // Why would the more specific functions succeed if the generic functions failed?\n                    // -- I'm guessing that the original author was hopeful? - io\n                    if (!SSL_CTX_use_RSAPrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_PEM))\n                    {\n                        if (!SSL_CTX_use_RSAPrivateKey_file(options->ctx, options->privateKeyFile, SSL_FILETYPE_ASN1))\n                        {\n                            printf(\"%s    Could not configure private key.%s\\n\", COL_RED, RESET);\n                            status = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // PKCS Cert and PKey File...\n    else if (options->privateKeyFile != 0)\n    {\n        pk12File = fopen(options->privateKeyFile, \"rb\");\n        if (pk12File != NULL)\n        {\n            pk12 = d2i_PKCS12_fp(pk12File, NULL);\n            if (!pk12)\n            {\n                status = 0;\n                printf(\"%s    Could not read PKCS#12 file.%s\\n\", COL_RED, RESET);\n            }\n            else\n            {\n                if (!PKCS12_parse(pk12, options->privateKeyPassword, &pkey, &cert, &ca))\n                {\n                    status = 0;\n                    printf(\"%s    Error parsing PKCS#12. Are you sure that password was correct?%s\\n\", COL_RED, RESET);\n                }\n                else\n                {\n                    if (!SSL_CTX_use_certificate(options->ctx, cert))\n                    {\n                        status = 0;\n                        printf(\"%s    Could not configure certificate.%s\\n\", COL_RED, RESET);\n                    }\n                    if (!SSL_CTX_use_PrivateKey(options->ctx, pkey))\n                    {\n                        status = 0;\n                        printf(\"%s    Could not configure private key.%s\\n\", COL_RED, RESET);\n                    }\n                }\n                PKCS12_free(pk12);\n            }\n            fclose(pk12File);\n        }\n        else\n        {\n            printf(\"%s    Could not open PKCS#12 file.%s\\n\", COL_RED, RESET);\n            status = 0;\n        }\n    }\n\n    // Check Cert/Key...\n    if (status != 0)\n    {\n        if (!SSL_CTX_check_private_key(options->ctx))\n        {\n            printf(\"%s    Private key does not match certificate.%s\\n\", COL_RED, RESET);\n            return false;\n        }\n        else\n            return true;\n    }\n    else\n        return false;\n}\n\n\n// Test renegotiation\nint outputRenegotiation( struct sslCheckOptions *options, struct renegotiationOutput *outputData)\n{\n\n    printf_xml(\"  <renegotiation supported=\\\"%d\\\" secure=\\\"%d\\\" />\\n\",\n        outputData->supported, outputData->secure);\n\n    if (outputData->secure)\n    {\n        printf(\"%sSecure%s session renegotiation supported\\n\\n\", COL_GREEN, RESET);\n    }\n    else if (outputData->supported)\n    {\n        printf(\"%sInsecure%s session renegotiation supported\\n\\n\", COL_RED, RESET);\n    }\n    else\n    {\n       printf(\"Session renegotiation %snot supported%s\\n\\n\", COL_GREEN, RESET);\n    }\n\n    return true;\n}\n\nstruct renegotiationOutput * newRenegotiationOutput( void )\n{\n    struct renegotiationOutput *myRenOut;\n    myRenOut = calloc(1,sizeof(struct renegotiationOutput));\n    return( myRenOut );\n}\n\nint freeRenegotiationOutput( struct renegotiationOutput *myRenOut )\n{\n    if ( myRenOut != NULL) {\n        free(myRenOut);\n    }\n    return true;\n}\n\nvoid tls_reneg_init(struct sslCheckOptions *options)\n{\n    /* Borrowed from tortls.c to dance with OpenSSL on many platforms, with\n     * many versions and release of OpenSSL. */\n    SSL_library_init();\n    SSL_load_error_strings();\n\n    long version = SSLeay();\n    if (version >= 0x009080c0L && version < 0x009080d0L) {\n        printf_verbose(\"OpenSSL %s looks like version 0.9.8l; I will try SSL3_FLAGS to enable renegotiation.\\n\",\n            SSLeay_version(SSLEAY_VERSION));\n        use_unsafe_renegotiation_flag = 1;\n        use_unsafe_renegotiation_op = 1;\n    } else if (version >= 0x009080d0L) {\n        printf_verbose(\"OpenSSL %s looks like version 0.9.8m or later; \"\n            \"I will try SSL_OP to enable renegotiation\\n\",\n        SSLeay_version(SSLEAY_VERSION));\n        use_unsafe_renegotiation_op = 1;\n    } else if (version < 0x009080c0L) {\n        printf_verbose(\"OpenSSL %s [%lx] looks like it's older than \"\n            \"0.9.8l, but some vendors have backported 0.9.8l's \"\n            \"renegotiation code to earlier versions, and some have \"\n            \"backported the code from 0.9.8m or 0.9.8n.  I'll set both \"\n            \"SSL3_FLAGS and SSL_OP just to be safe.\\n\",\n            SSLeay_version(SSLEAY_VERSION), version);\n        use_unsafe_renegotiation_flag = 1;\n        use_unsafe_renegotiation_op = 1;\n    } else {\n        printf_verbose(\"OpenSSL %s has version %lx\\n\",\n            SSLeay_version(SSLEAY_VERSION), version);\n    }\n\n#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n  SSL_CTX_set_options(options->ctx,\n                      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);\n#endif\n}\n\n// Check if the server supports compression\nint testCompression(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    // Variables...\n    int status = true;\n    int socketDescriptor = 0;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio;\n    SSL_SESSION *session;\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n        // Setup Context Object...\n        options->ctx = new_CTX(sslMethod);\n        tls_reneg_init(options);\n        if (options->ctx != NULL)\n        {\n            if (SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL) != 0)\n            {\n\n                // Load Certs if required...\n                if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                    status = loadCerts(options);\n\n                if (status == true)\n                {\n                    // Create SSL object...\n                    ssl = new_SSL(options->ctx);\n\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n                    // Make sure we can connect to insecure servers\n                    // OpenSSL is going to change the default at a later date\n                    SSL_set_options(ssl, SSL_OP_LEGACY_SERVER_CONNECT);\n#endif\n\n#ifdef SSL_OP_NO_COMPRESSION\n                    // Make sure to clear the no compression flag\n                    SSL_clear_options(ssl, SSL_OP_NO_COMPRESSION);\n#endif\n\n                   if (ssl != NULL)\n                    {\n                        // Connect socket and BIO\n                        cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                        // Connect SSL and BIO\n                        SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n                        // This enables TLS SNI\n                        SSL_set_tlsext_host_name(ssl, options->sniname);\n#endif\n\n                        // Connect SSL over socket\n                        SSL_connect(ssl);\n\n                        session = SSL_get_session(ssl);\n\n#ifndef OPENSSL_NO_COMP\n                        // Make sure zlib is actually present\n                        if (sk_SSL_COMP_num(SSL_COMP_get_compression_methods()) != 0)\n                        {\n                            printf_xml(\"  <compression supported=\\\"%d\\\" />\\n\",\n                                SSL_SESSION_get_compress_id(session));\n\n                            if (SSL_SESSION_get_compress_id(session) == 0)\n                            {\n                                printf(\"Compression %sdisabled%s\\n\\n\", COL_GREEN, RESET);\n                            }\n                            else\n                            {\n                                printf(\"Compression %senabled%s (CRIME)\\n\\n\", COL_RED, RESET);\n                            }\n                        }\n                        else\n#endif\n                        {\n                            printf(\"%sOpenSSL version does not support compression%s\\n\", COL_RED, RESET);\n                            printf(\"%sRebuild with zlib1g-dev package for zlib support%s\\n\\n\", COL_RED, RESET);\n                        }\n\n                        // Disconnect SSL over socket\n                        SSL_shutdown(ssl);\n\n                        // Free SSL object\n                        FREE_SSL(ssl);\n                    }\n                    else\n                    {\n                        status = false;\n                        printf_error(\"Could not create SSL object.\");\n                    }\n                }\n            }\n            else\n            {\n                status = false;\n                printf_error(\"Could not set cipher.\");\n            }\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n        // Error Creating Context Object\n        else\n        {\n            status = false;\n            printf_error(\"Could not create CTX object.\");\n        }\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n    else\n    {\n        // Could not connect\n        printf_error(\"Could not connect.\");\n        exit(1);\n    }\n\n    return status;\n}\n\n#ifdef SSL_MODE_SEND_FALLBACK_SCSV\n// Check for TLS_FALLBACK_SCSV\nint testFallback(struct sslCheckOptions *options,  const SSL_METHOD *sslMethod)\n{\n    // Variables...\n    int status = true;\n    int downgraded = true;\n    int connStatus = false;\n    int socketDescriptor = 0;\n    int sslversion;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio;\n    const SSL_METHOD *secondMethod;\n\n    // Function gets called a second time with downgraded protocol\n    if (!sslMethod)\n    {\n        sslMethod = SSLv23_method();\n        downgraded = false;\n    }\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n        // Setup Context Object...\n        options->ctx = new_CTX(sslMethod);\n        tls_reneg_init(options);\n        if (options->ctx != NULL)\n        {\n            if (downgraded)\n            {\n                SSL_CTX_set_mode(options->ctx, SSL_MODE_SEND_FALLBACK_SCSV);\n            }\n            if (SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL) != 0)\n            {\n\n                // Load Certs if required...\n                if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                    status = loadCerts(options);\n\n                if (status == true)\n                {\n                    // Create SSL object...\n                    ssl = new_SSL(options->ctx);\n\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n                    // Make sure we can connect to insecure servers\n                    // OpenSSL is going to change the default at a later date\n                    SSL_set_options(ssl, SSL_OP_LEGACY_SERVER_CONNECT);\n#endif\n\n#ifdef SSL_OP_NO_COMPRESSION\n                    // Make sure to clear the no compression flag\n                    SSL_clear_options(ssl, SSL_OP_NO_COMPRESSION);\n#endif\n\n                   if (ssl != NULL)\n                    {\n                        // Connect socket and BIO\n                        cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                        // Connect SSL and BIO\n                        SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n                        // This enables TLS SNI\n                        SSL_set_tlsext_host_name(ssl, options->sniname);\n#endif\n\n                        // Connect SSL over socket\n                        connStatus = SSL_connect(ssl);\n                        if (connStatus > 0)\n                        {\n                            if (!downgraded)\n                            {\n                                sslversion = SSL_version(ssl);\n                                if (sslversion == TLS1_3_VERSION)\n                                {\n                                    secondMethod = TLSv1_2_client_method();\n                                }\n                                else if (sslversion == TLS1_2_VERSION)\n                                {\n\t\t\t\t  secondMethod = TLSv1_1_client_method();\n                                }\n\t\t\t\telse if (sslversion == TLS1_VERSION)\n\t\t\t\t{\n\t\t\t\t  secondMethod = TLSv1_client_method();\n\t\t\t\t}\n\t\t\t\telse if (sslversion == TLS1_VERSION)\n\t\t\t\t{\n\t\t\t\t  printf(\"Server only supports TLSv1.0\");\n\t\t\t\t  status = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t  printf(\"Server doesn't support TLS - skipping TLS Fallback SCSV check\\n\\n\");\n\t\t\t\t  status = false;\n\t\t\t\t}\n                            }\n                            else\n                            {\n                                printf(\"Server %sdoes not%s support TLS Fallback SCSV\\n\\n\", COL_RED, RESET);\n                                printf_xml(\"  <fallback supported=\\\"0\\\" />\\n\");\n                            }\n                        }\n                        else\n                        {\n                            if (downgraded)\n                            {\n                                if (SSL_get_error(ssl, connStatus == 1))\n                                {\n                                    ERR_get_error();\n                                    if (SSL_get_error(ssl, connStatus == 6))\n                                    {\n                                        printf(\"Server %ssupports%s TLS Fallback SCSV\\n\\n\", COL_GREEN, RESET);\n                                        printf_xml(\"  <fallback supported=\\\"1\\\" />\\n\");\n                                        status = false;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                printf(\"%sConnection failed%s - unable to determine TLS Fallback SCSV support\\n\\n\",\n                                        COL_YELLOW, RESET);\n                                status = false;\n                            }\n                        }\n\n                        // Disconnect SSL over socket\n                        SSL_shutdown(ssl);\n\n                        // Free SSL object\n                        FREE_SSL(ssl);\n                    }\n                    else\n                    {\n                        status = false;\n                        printf_error(\"Could not create SSL object.\");\n                    }\n                }\n            }\n            else\n            {\n                status = false;\n                printf_error(\"Could not set cipher.\");\n            }\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n        // Error Creating Context Object\n        else\n        {\n            status = false;\n            printf_error(\"Could not create CTX object.\");\n        }\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n    else\n    {\n        // Could not connect\n        printf_error(\"Could not connect.\");\n        exit(1);\n    }\n\n    // Call function again with downgraded protocol\n    if (status && !downgraded)\n    {\n        testFallback(options, secondMethod);\n    }\n    return status;\n}\n#endif\n\n\n// Check if the server supports renegotiation\nint testRenegotiation(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    // Variables...\n    int cipherStatus;\n    int status = true;\n    //int secure = false;\n    int socketDescriptor = 0;\n    int res;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio;\n    struct renegotiationOutput *renOut = newRenegotiationOutput();\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n\n        // Setup Context Object...\n        options->ctx = new_CTX(sslMethod);\n        tls_reneg_init(options);\n        if (options->ctx != NULL)\n        {\n            if (SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL) != 0)\n            {\n\n                // Load Certs if required...\n                if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                    status = loadCerts(options);\n\n                if (status == true)\n                {\n                    // Create SSL object...\n                    ssl = new_SSL(options->ctx);\n\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n                    // Make sure we can connect to insecure servers\n                    // OpenSSL is going to change the default at a later date\n                    SSL_set_options(ssl, SSL_OP_LEGACY_SERVER_CONNECT);\n#endif\n\n                   if (ssl != NULL)\n                    {\n                        // Connect socket and BIO\n                        cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                        // Connect SSL and BIO\n                        SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n                        // This enables TLS SNI\n                        // Based on http://does-not-exist.org/mail-archives/mutt-dev/msg13045.html\n                        // TLS Virtual-hosting requires that the server present the correct\n                        // certificate; to do this, the ServerNameIndication TLS extension is used.\n                        // If TLS is negotiated, and OpenSSL is recent enough that it might have\n                        // support, and support was enabled when OpenSSL was built, mutt supports\n                        // sending the hostname we think we're connecting to, so a server can send\n                        // back the correct certificate.\n                        // NB: finding a server which uses this for IMAP is problematic, so this is\n                        // untested.  Please report success or failure!  However, this code change\n                        // has worked fine in other projects to which the contributor has added it,\n                        // or HTTP usage.\n                        SSL_set_tlsext_host_name(ssl, options->sniname);\n#endif\n\n                        // Connect SSL over socket\n                        cipherStatus = SSL_connect(ssl);\n\n                      /* Yes, we know what we are doing here.  No, we do not treat a renegotiation\n                       * as authenticating any earlier-received data. */\n/*                      if (use_unsafe_renegotiation_flag) {\n                        printf_verbose(\"use_unsafe_renegotiation_flag\\n\");\n\t\t\tSSL_CTX_set_options(ssl,SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n\t\t\tSSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION??\n                      } */\n                      if (use_unsafe_renegotiation_op) {\n                        printf_verbose(\"use_unsafe_renegotiation_op\\n\");\n                        SSL_set_options(ssl,\n                                        SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                      }\n\n\n                        if (cipherStatus == 1)\n                        {\n\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n                            // SSL_get_secure_renegotiation_support() appeared first in OpenSSL 0.9.8m\n                            printf_verbose(\"Attempting secure_renegotiation_support()\\n\");\n                            renOut->secure = SSL_get_secure_renegotiation_support(ssl);\n                            if( renOut->secure )\n                            {\n                                // If it supports secure renegotiations,\n                                // it should have renegotiation support in general\n                                renOut->supported = true;\n                                status = true;\n                            }\n                            else\n                            {\n#endif\n                                // We can't assume that just because the secure renegotiation\n                                // support failed the server doesn't support insecure renegotiations\n\n                                // assume ssl is connected and error free up to here\n                                //setBlocking(ssl); // this is unnecessary if it is already blocking\n                                printf_verbose(\"Attempting SSL_renegotiate(ssl)\\n\");\n                                SSL_renegotiate(ssl); // Ask to renegotiate the connection\n                                // This hangs when an 'encrypted alert' is sent by the server\n                                printf_verbose(\"Attempting SSL_do_handshake(ssl)\\n\");\n                                SSL_do_handshake(ssl); // Send renegotiation request to server //TODO :: XXX hanging here\n\n                                if (SSL_get_state(ssl) == TLS_ST_OK)\n                                {\n                                    res = SSL_do_handshake(ssl); // Send renegotiation request to server\n                                    if( res != 1 )\n                                    {\n                                        printf_error(\"SSL_do_handshake() call failed\");\n                                    }\n                                    if (SSL_get_state(ssl) == TLS_ST_OK)\n                                    {\n                                        /* our renegotiation is complete */\n                                        renOut->supported = true;\n                                        status = true;\n                                    } else {\n                                        renOut->supported = false;\n                                        status = false;\n                                        printf_error(\"Failed to complete renegotiation\");\n                                    }\n                                } else {\n                                    status = false;\n                                    renOut->secure = false;\n                                }\n#if ( OPENSSL_VERSION_NUMBER > 0x009080cfL )\n                            }\n#endif\n                            // Disconnect SSL over socket\n                            SSL_shutdown(ssl);\n                        }\n\n                        // Free SSL object\n                        FREE_SSL(ssl);\n                    }\n                    else\n                    {\n                        status = false;\n                        renOut->supported = false;\n                        printf_error(\"Could not create SSL object.\");\n                    }\n                }\n            }\n            else\n            {\n                status = false;\n                renOut->supported = false;\n                printf_error(\"Could not set cipher.\");\n            }\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n        // Error Creating Context Object\n        else\n        {\n            status = false;\n            renOut->supported = false;\n            printf_error(\"Could not create CTX object.\");\n        }\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n    else\n    {\n        // Could not connect\n        printf_error(\"Could not connect.\");\n        renOut->supported = false;\n        freeRenegotiationOutput( renOut );\n        exit(1);\n    }\n    outputRenegotiation(options, renOut);\n    freeRenegotiationOutput( renOut );\n\n    return status;\n\n}\n\nconst char* printableSslMethod(const SSL_METHOD *sslMethod)\n{\n    if (sslMethod == TLSv1_client_method())\n        return \"TLSv1.0\";\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n    if (sslMethod == TLSv1_1_client_method())\n        return \"TLSv1.1\";\n    if (sslMethod == TLSv1_2_client_method())\n        return \"TLSv1.2\";\n#endif\n    if (sslMethod == TLSv1_3_client_method())\n        return \"TLSv1.3\";\n    return \"unknown SSL_METHOD\";\n}\n\n// Test for Heartbleed\nint testHeartbleed(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    // Variables...\n    int status = true;\n    int socketDescriptor = 0;\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n\n\n    if (socketDescriptor != 0)\n    {\n\n        // Credit to Jared Stafford (jspenguin@jspenguin.org)\n        char hello[] = {0x16,0x03,0x01,0x00,0xdc,0x01,0x00,0x00,0xd8,0x03,0x00,0x53,0x43,0x5b,0x90,0x9d,0x9b,0x72,0x0b,0xbc,0x0c,0xbc,0x2b,0x92,0xa8,0x48,0x97,0xcf,0xbd,0x39,0x04,0xcc,0x16,0x0a,0x85,0x03,0x90,0x9f,0x77,0x04,0x33,0xd4,0xde,0x00,0x00,0x66,0xc0,0x14,0xc0,0x0a,0xc0,0x22,0xc0,0x21,0x00,0x39,0x00,0x38,0x00,0x88,0x00,0x87,0xc0,0x0f,0xc0,0x05,0x00,0x35,0x00,0x84,0xc0,0x12,0xc0,0x08,0xc0,0x1c,0xc0,0x1b,0x00,0x16,0x00,0x13,0xc0,0x0d,0xc0,0x03,0x00,0x0a,0xc0,0x13,0xc0,0x09,0xc0,0x1f,0xc0,0x1e,0x00,0x33,0x00,0x32,0x00,0x9a,0x00,0x99,0x00,0x45,0x00,0x44,0xc0,0x0e,0xc0,0x04,0x00,0x2f,0x00,0x96,0x00,0x41,0xc0,0x11,0xc0,0x07,0xc0,0x0c,0xc0,0x02,0x00,0x05,0x00,0x04,0x00,0x15,0x00,0x12,0x00,0x09,0x00,0x14,0x00,0x11,0x00,0x08,0x00,0x06,0x00,0x03,0x00,0xff,0x01,0x00,0x00,0x49,0x00,0x0b,0x00,0x04,0x03,0x00,0x01,0x02,0x00,0x0a,0x00,0x34,0x00,0x32,0x00,0x0e,0x00,0x0d,0x00,0x19,0x00,0x0b,0x00,0x0c,0x00,0x18,0x00,0x09,0x00,0x0a,0x00,0x16,0x00,0x17,0x00,0x08,0x00,0x06,0x00,0x07,0x00,0x14,0x00,0x15,0x00,0x04,0x00,0x05,0x00,0x12,0x00,0x13,0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x0f,0x00,0x10,0x00,0x11,0x00,0x23,0x00,0x00,0x00,0x0f,0x00,0x01,0x01};\n\n        if (sslMethod == TLSv1_client_method())\n        {\n            hello[10] = 0x01;\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n        else if (sslMethod == TLSv1_1_client_method())\n        {\n            hello[10] = 0x02;\n        }\n        else if (sslMethod == TLSv1_2_client_method())\n        {\n            hello[10] = 0x03;\n        }\n#endif\n        else if (sslMethod == TLSv1_3_client_method())\n        {\n            hello[10] = 0x03;\n        }\n        if (send(socketDescriptor, hello, sizeof(hello), 0) <= 0) {\n            printf_error(\"send() failed: %s\", strerror(errno));\n            exit(1);\n        }\n\n        // Send the heartbeat\n        char hb[8] = {0x18,0x03,0x00,0x00,0x03,0x01,0x40,0x00};\n        if (sslMethod == TLSv1_client_method())\n        {\n            hb[2] = 0x01;\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n        else if (sslMethod == TLSv1_1_client_method())\n        {\n            hb[2] = 0x02;\n        }\n        else if (sslMethod == TLSv1_2_client_method())\n        {\n            hb[2] = 0x03;\n        }\n#endif\n        else if (sslMethod == TLSv1_3_client_method())\n        {\n            hb[2] = 0x03;\n        }\n        if (send(socketDescriptor, hb, sizeof(hb), 0) <= 0) {\n            printf_error(\"send() failed: %s\", strerror(errno));\n            exit(1);\n        }\n\n        char hbbuf[65536];\n\n        while(1)\n        {\n            memset(hbbuf, 0, sizeof(hbbuf));\n\n            // Read 5 byte header\n            int readResult = recv(socketDescriptor, hbbuf, 5, 0);\n            if (readResult <= 0)\n            {\n                break;\n            }\n\n            char typ = hbbuf[0];\n\n            // Combine 2 bytes to get payload length\n            uint16_t ln = hbbuf[4] | hbbuf[3] << 8;\n\n            // Debugging\n/*\n            uint16_t ver = hbbuf[2] | hbbuf[1] << 8;\n            printf(\"%hhX %hhX %hhX %hhX %hhX - %d %d %d\\n\", hbbuf[0], hbbuf[1], hbbuf[2], hbbuf[3], hbbuf[4], typ, ver, ln);\n*/\n            memset(hbbuf, 0, sizeof(hbbuf));\n\n            // Read rest of record\n            readResult = recv(socketDescriptor, hbbuf, ln, 0);\n            if (readResult <= 0)\n            {\n                break;\n            }\n\n            // Server returned error\n            if (typ == 21)\n            {\n                break;\n            }\n            // Successful response\n            else if (typ == 24 && ln > 3)\n            {\n                printf(\"%svulnerable%s to heartbleed\\n\", COL_RED, RESET);\n                printf_xml(\"  <heartbleed sslversion=\\\"%s\\\" vulnerable=\\\"1\\\" />\\n\", printableSslMethod(sslMethod));\n                close(socketDescriptor);\n                return status;\n            }\n        }\n        printf(\"%snot vulnerable%s to heartbleed\\n\", COL_GREEN, RESET);\n        printf_xml(\"  <heartbleed sslversion=\\\"%s\\\" vulnerable=\\\"0\\\" />\\n\", printableSslMethod(sslMethod));\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n    else\n    {\n        // Could not connect\n        printf_error(\"Could not connect.\");\n        printf(\"dying\");\n        exit(1);\n    }\n\n    return status;\n}\n\n\nint ssl_print_tmp_key(struct sslCheckOptions *options, SSL *s)\n{\n#if OPENSSL_VERSION_NUMBER >= 0x10002000L && !defined(LIBRESSL_VERSION_NUMBER)\n    EVP_PKEY *key;\n    if (!SSL_get_server_tmp_key(s, &key))\n        return 1;\n    switch (EVP_PKEY_id(key)) {\n    case EVP_PKEY_RSA:\n        if (EVP_PKEY_bits(key) <= 768)\n        {\n            printf(\" RSA %s%d%s bits\", COL_RED, EVP_PKEY_bits(key), RESET);\n        }\n        else if (EVP_PKEY_bits(key) <= 1024)\n        {\n            printf(\" RSA %s%d%s bits\", COL_YELLOW, EVP_PKEY_bits(key), RESET);\n        }\n        else\n        {\n            printf(\" RSA %d bits\", EVP_PKEY_bits(key));\n        }\n        break;\n\n    case EVP_PKEY_DH:\n        if (EVP_PKEY_bits(key) <= 768)\n        {\n            printf(\" DHE %s%d%s bits\", COL_RED, EVP_PKEY_bits(key), RESET);\n        }\n        else if (EVP_PKEY_bits(key) <= 1024)\n        {\n            printf(\" DHE %s%d%s bits\", COL_YELLOW, EVP_PKEY_bits(key), RESET);\n        }\n        else\n        {\n            printf(\" DHE %d bits\", EVP_PKEY_bits(key));\n        }\n        printf_xml(\" dhebits=\\\"%d\\\"\", EVP_PKEY_bits(key));\n        break;\n    case EVP_PKEY_EC:\n        {\n            EC_KEY *ec = EVP_PKEY_get1_EC_KEY(key);\n            int nid;\n            const char *cname;\n            nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));\n            EC_KEY_free(ec);\n            cname = EC_curve_nid2nist(nid);\n            if (!cname)\n                cname = OBJ_nid2sn(nid);\n            printf(\" Curve %s DHE %d\", cname, EVP_PKEY_bits(key));\n            printf_xml(\" curve=\\\"%s\\\" ecdhebits=\\\"%d\\\"\", cname, EVP_PKEY_bits(key));\n        }\n\tbreak;\n    case EVP_PKEY_X25519:\n      printf(\" Curve %s25519%s DHE %d\", COL_GREEN, RESET, EVP_PKEY_bits(key));\n      printf_xml(\" curve=\\\"25519\\\" ecdhebits=\\\"%d\\\"\", EVP_PKEY_bits(key));\n      break;\n    case EVP_PKEY_X448:\n      printf(\" Curve %s448%s DHE %d\", COL_GREEN, RESET, EVP_PKEY_bits(key));\n      printf_xml(\" curve=\\\"448\\\" ecdhebits=\\\"%d\\\"\", EVP_PKEY_bits(key));\n      break;\n    default:\n      printf(\" %sUnknown ID (%d)%s\", COL_YELLOW, EVP_PKEY_id(key), RESET);\n    }\n    EVP_PKEY_free(key);\n    return 1;\n#endif\n    return 0;\n}\n\nint setCipherSuite(struct sslCheckOptions *options, const SSL_METHOD *sslMethod, const char *str)\n{\n  if(strlen(str)>0)\n  {\n    if(sslMethod==TLSv1_3_client_method())\n    {\n      return(SSL_CTX_set_ciphersuites(options->ctx,str));\n    }\n    else\n    {\n      return(SSL_CTX_set_cipher_list(options->ctx,str));\n    }\n  }\n  return 0;\n}\n\nchar *cipherRemove(char *str, const char *sub) {\n    char *p, *q, *r;\n    if ((q = r = strstr(str, sub)) != NULL) {\n        size_t len = strlen(sub)+1;\n        if(q != str)\n        {\n          q--;\n          r--;\n        }\n        while ((r = strstr(p = r + len, sub)) != NULL) {\n            while (p < r)\n                *q++ = *p++;\n        }\n        while ((*q++ = *p++) != '\\0')\n            continue;\n    }\n    return str;\n}\n\n/* Outputs an accepted cipher to the console and XML file. */\nvoid outputCipher(struct sslCheckOptions *options, SSL *ssl, const char *cleanSslMethod, uint32_t cipherid, const char *ciphername, int cipherbits, int cipher_accepted, unsigned int milliseconds_elapsed) {\n  char hexCipherId[8] = {0};\n  char *strength;\n  unsigned int tempInt = 0;\n\n\n  printf_xml(\"  <cipher status=\\\"\");\n  if (cipher_accepted) {\n    if (strcmp(options->cipherstring, CIPHERSUITE_LIST_ALL) && strcmp(options->cipherstring, TLSV13_CIPHERSUITES)) {\n      printf_xml(\"accepted\\\"\");\n      printf(\"Accepted  \");\n    }\n    else {\n      printf_xml(\"preferred\\\"\");\n      printf(\"%sPreferred%s \", COL_GREEN, RESET);\n    }\n\n    printf_xml(\" sslversion=\\\"%s\\\"\", cleanSslMethod);\n    if (strcmp(cleanSslMethod, \"TLSv1.3\") == 0) {\n      printf(\"%sTLSv1.3%s  \", COL_GREEN, RESET);\n    }\n    else if (strcmp(cleanSslMethod, \"TLSv1.1\") == 0) {\n      printf(\"%sTLSv1.1%s  \", COL_YELLOW, RESET);\n    }\n    else if (strcmp(cleanSslMethod, \"TLSv1.0\") == 0) {\n      printf(\"%sTLSv1.0%s  \", COL_YELLOW, RESET);\n    } else\n      printf(\"%s  \", cleanSslMethod);\n\n    // Short authentication tag length\n    // These are flagged as 64 bit strength in newer versions of OpenSSL\n    // But in older versions they'll still show as 256 bits, so override that here\n    // See https://github.com/openssl/openssl/pull/16652\n    if (strstr(ciphername, \"CCM8\")) {\n        cipherbits = 64;\n    }\n\n    if (cipherbits < 10)\n      tempInt = 2;\n    else if (cipherbits < 100)\n      tempInt = 1;\n\n    if (cipherbits == -1) { /* When missing ciphers are tested, and we don't have a reasonable guess. */\n      printf(\"%s??%s bits  \", COL_YELLOW, RESET);\n    } else if (cipherbits == 0) {\n      printf(\"%s%d%s bits  \", COL_RED_BG, cipherbits, RESET);\n    } else if (cipherbits >= 112) {\n      printf(\"%s%d%s bits  \", COL_GREEN, cipherbits, RESET);\n    } else if (cipherbits > 56) {\n      printf(\"%s%d%s bits  \", COL_YELLOW, cipherbits, RESET);\n    } else\n      printf(\"%s%d%s bits  \", COL_RED, cipherbits, RESET);\n\n    while (tempInt != 0) {\n      tempInt--;\n      printf(\" \");\n    }\n\n    snprintf(hexCipherId, sizeof(hexCipherId) - 1, \"0x%04X\", cipherid);\n    if (options->showCipherIds == true)\n      printf(\"%8s \", hexCipherId);\n\n    printf_xml(\" bits=\\\"%d\\\" cipher=\\\"%s\\\" id=\\\"%s\\\"\", cipherbits, ciphername, hexCipherId);\n    if (strstr(ciphername, \"NULL\")) {\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_RED_BG, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_RED_BG, ciphername, RESET);\n        }\n        strength = \"null\";\n    } else if (strstr(ciphername, \"ADH\") || strstr(ciphername, \"AECDH\") || strstr(ciphername, \"_anon_\")) {\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_PURPLE, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_PURPLE, ciphername, RESET);\n        }\n        strength = \"anonymous\";\n    } else if (strstr(ciphername, \"EXP\")) {\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_RED, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_RED, ciphername, RESET);\n        }\n        strength = \"weak\";\n    } else if (strstr(ciphername, \"RC4\") || strstr(ciphername, \"DES\")) {\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        strength = \"medium\";\n    } else if (strstr(ciphername, \"CCM8\")) {\n        // Short authentication tag length\n        // These are flagged as 64 bit strength in newer versions of OpenSSL\n        // But in older versions they'll still show as 256 bits, so manually flag them here\n        // See https://github.com/openssl/openssl/pull/16652\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        strength = \"medium\";\n    } else if (strstr(ciphername, \"_SM4_\")) { /* Developed by Chinese government */\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        strength = \"medium\";\n    } else if (strstr(ciphername, \"_GOSTR341112_\")) { /* Developed by Russian government */\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_YELLOW, ciphername, RESET);\n        }\n        strength = \"medium\";\n    } else if ((strstr(ciphername, \"CHACHA20\") || (strstr(ciphername, \"GCM\"))) && (strstr(ciphername, \"DHE\") || (strcmp(cleanSslMethod, \"TLSv1.3\") == 0))) {\n        if (options->ianaNames) {\n            printf(\"%s%-45s%s\", COL_GREEN, ciphername, RESET);\n        }\n        else {\n            printf(\"%s%-29s%s\", COL_GREEN, ciphername, RESET);\n        }\n        strength = \"strong\";\n    } else {\n        if (options->ianaNames) {\n            printf(\"%-45s\", ciphername);\n        }\n        else {\n            printf(\"%-29s\", ciphername);\n        }\n        strength = \"acceptable\";\n    }\n    printf_xml(\" strength=\\\"%s\\\"\", strength);\n\n    if ((options->cipher_details == true) && (ssl != NULL))\n      ssl_print_tmp_key(options, ssl);\n\n    // Timing\n    if (options->showTimes) {\n      printf(\" %s%ums%s\", COL_GREY, milliseconds_elapsed, RESET);\n      printf_xml(\" time=\\\"%u\\\"\", milliseconds_elapsed);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf_xml(\" />\\n\");\n}\n\n// Test a cipher...\nint testCipher(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    // Variables...\n    int cipherStatus = 0;\n    int status = true;\n    int socketDescriptor = 0;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio = NULL;\n    int cipherbits = -1;\n    uint32_t cipherid = 0;\n    const SSL_CIPHER *sslCipherPointer = NULL;\n    const char *cleanSslMethod = printableSslMethod(sslMethod);\n    const char *ciphername = NULL;\n    struct timeval tval_start = {0};\n    unsigned int milliseconds_elapsed = 0;\n\n\n    if (options->showTimes)\n    {\n        gettimeofday(&tval_start, NULL);\n    }\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n        if (setCipherSuite(options, sslMethod, options->cipherstring))\n        {\n            // Create SSL object...\n            ssl = new_SSL(options->ctx);\n            if (ssl != NULL)\n            {\n                // Connect socket and BIO\n                cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                // Connect SSL and BIO\n                SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n                // This enables TLS SNI\n                SSL_set_tlsext_host_name (ssl, options->sniname);\n\n                // Against some servers, this is required for a successful SSL_connect(), below.\n                SSL_set_options(ssl, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n\n                // Connect SSL over socket\n                cipherStatus = SSL_connect(ssl);\n                printf_verbose(\"SSL_connect() returned: %d\\n\", cipherStatus);\n\n                sslCipherPointer = SSL_get_current_cipher(ssl);\n                if (sslCipherPointer == NULL) {\n                  printf_verbose(\"SSL_get_current_cipher() returned NULL; this indicates that the server did not choose a cipher from our list (%s)\\n\", options->cipherstring);\n                  SSL_shutdown(ssl);\n                  FREE_SSL(ssl);\n                  CLOSE(socketDescriptor);\n                  return false;\n                }\n\n                cipherbits = SSL_CIPHER_get_bits(sslCipherPointer, NULL);\n                cipherid = SSL_CIPHER_get_id(sslCipherPointer);\n                cipherid = cipherid & 0x00ffffff;  // remove first byte which is the version (0x03 for TLSv1/SSLv3)\n\n                if (options->ianaNames)\n                {\n                    ciphername = SSL_CIPHER_standard_name(sslCipherPointer);\n                }\n                else\n                {\n                    ciphername = SSL_CIPHER_get_name(sslCipherPointer);\n                }\n                \n\n\t\t// Timing\n\t\tif (options->showTimes) {\n\t\t  struct timeval tval_end = {0}, tval_elapsed = {0};\n\n\t\t  gettimeofday(&tval_end, NULL);\n\t\t  timersub(&tval_end, &tval_start, &tval_elapsed);\n\t\t  milliseconds_elapsed = tval_elapsed.tv_sec * 1000 + (int)tval_elapsed.tv_usec / 1000;\n\t\t}\n\n                outputCipher(options, ssl, cleanSslMethod, cipherid, ciphername, cipherbits, 1, milliseconds_elapsed);\n\n                // Disconnect SSL over socket\n                const char *usedcipher = SSL_get_cipher_name(ssl);\n                if(sslMethod == TLSv1_3_client_method())\n                  cipherRemove(options->cipherstring, usedcipher);  // Remove cipher from TLSv1.3 list\n                else {\n                  // Using strcat rather than strncat to avoid a warning from GCC\n                  strcat(options->cipherstring, \":!\");\n                  strncat(options->cipherstring, usedcipher, strlen(usedcipher));\n                }\n                SSL_shutdown(ssl);\n\n                // Free SSL object\n                FREE_SSL(ssl);\n            }\n            else\n            {\n                status = false;\n                printf_error(\"Could not create SSL object.\");\n            }\n        }\n        else\n        {\n            status = false;\n        }\n\n        // Disconnect from host\n        CLOSE(socketDescriptor);\n    }\n\n    // Could not connect\n    else\n        status = false;\n\n\n    return status;\n}\n\nint checkCertificateProtocol(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    int status = true;\n    // Setup Context Object...\n    options->ctx = new_CTX(sslMethod);\n    if (options->ctx != NULL)\n    {\n        // SSL implementation bugs/workaround\n        if (options->sslbugs)\n            SSL_CTX_set_options(options->ctx, SSL_OP_ALL | 0);\n        else\n            SSL_CTX_set_options(options->ctx, 0);\n\n        // Load Certs if required...\n        if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n            status = loadCerts(options);\n\n        // Check the certificate\n        status = checkCertificate(options, sslMethod);\n    }\n\n    // Error Creating Context Object\n    else\n    {\n        printf_error(\"Could not create CTX object.\");\n        status = false;\n    }\n    return status;\n}\n\n// Report certificate weaknesses (key length and signing algorithm)\nint checkCertificate(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    int status = true;\n    int socketDescriptor = 0;\n    int keyBits;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio = NULL;\n    BIO *stdoutBIO = NULL;\n    BIO *fileBIO = NULL;\n    X509 *x509Cert = NULL;\n    EVP_PKEY *publicKey = NULL;\n    char certAlgorithm[80];\n    X509_EXTENSION *extension = NULL;\n    const X509_ALGOR *palg = NULL;\n    const ASN1_OBJECT *paobj = NULL;\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n        // Setup Context Object...\n        options->ctx = new_CTX(sslMethod);\n        if (options->ctx != NULL)\n        {\n\n            if (SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL) != 0)\n            {\n                // Load Certs if required...\n                if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                    status = loadCerts(options);\n\n                if (status == true)\n                {\n                    // Create SSL object...\n                    ssl = new_SSL(options->ctx);\n                    if (ssl != NULL)\n                    {\n                        // Connect socket and BIO\n                        cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                        // Connect SSL and BIO\n                        SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n                        // Based on http://does-not-exist.org/mail-archives/mutt-dev/msg13045.html\n                        // TLS Virtual-hosting requires that the server present the correct\n                        // certificate; to do this, the ServerNameIndication TLS extension is used.\n                        // If TLS is negotiated, and OpenSSL is recent enough that it might have\n                        // support, and support was enabled when OpenSSL was built, mutt supports\n                        // sending the hostname we think we're connecting to, so a server can send\n                        // back the correct certificate.\n                        // NB: finding a server which uses this for IMAP is problematic, so this is\n                        // untested.  Please report success or failure!  However, this code change\n                        // has worked fine in other projects to which the contributor has added it,\n                        // or HTTP usage.\n                        SSL_set_tlsext_host_name (ssl, options->sniname);\n#endif\n\n                        // Against some servers, this is required for a successful SSL_connect(), below.\n                        SSL_set_options(ssl, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n\n                        // Connect SSL over socket\n                        SSL_connect(ssl);\n                        // Setup BIO's\n                        if (!xml_to_stdout) {\n                            stdoutBIO = BIO_new(BIO_s_file());\n                            BIO_set_fp(stdoutBIO, stdout, BIO_NOCLOSE);\n                        }\n                        if (options->xmlOutput)\n                        {\n                            fileBIO = BIO_new(BIO_s_file());\n                            BIO_set_fp(fileBIO, options->xmlOutput, BIO_NOCLOSE);\n                        }\n\n                        // Get Certificate...\n                        x509Cert = SSL_get_peer_certificate(ssl);\n                        if (x509Cert != NULL)\n                        {\n                            printf(\"\\n  %sSSL Certificate:%s\\n\", COL_BLUE, RESET);\n                            printf_xml(\"  <certificate type=\\\"short\\\">\\n\");\n                            // Cert Serial No. - Code adapted from OpenSSL's crypto/asn1/t_x509.c\n                            if (!(X509_FLAG_COMPAT & X509_FLAG_NO_SERIAL))\n                            {\n                                BIO *bp;\n                                bp = BIO_new_fp(stdout, BIO_NOCLOSE);\n                                if (options->xmlOutput)\n\n                                    if(NULL != bp)\n                                        BIO_free(bp);\n                                // We don't free the xml_bp because it will be used in the future\n                            }\n\n                            // Signature Algo...\n                            if (!(X509_FLAG_COMPAT & X509_FLAG_NO_SIGNAME))\n                            {\n                                printf(\"Signature Algorithm: \");\n                                X509_get0_signature(NULL, &palg, x509Cert);\n                                X509_ALGOR_get0(&paobj, NULL, NULL, palg);\n                                OBJ_obj2txt(certAlgorithm, sizeof(certAlgorithm), paobj, 0);\n                                strtok(certAlgorithm, \"\\n\");\n                                if (strstr(certAlgorithm, \"md5\") || strstr(certAlgorithm, \"sha1\"))\n                                {\n                                    printf(\"%s%s%s\\n\", COL_RED, certAlgorithm, RESET);\n                                }\n                                else if (strstr(certAlgorithm, \"sha512\") || strstr(certAlgorithm, \"sha256\"))\n                                {\n                                    printf(\"%s%s%s\\n\", COL_GREEN, certAlgorithm, RESET);\n                                }\n                                else\n                                {\n                                    printf(\"%s\\n\", certAlgorithm);\n                                }\n\n                                if (options->xmlOutput)\n                                {\n                                    printf_xml(\"   <signature-algorithm>%s</signature-algorithm>\\n\", certAlgorithm);\n                                }\n                            }\n\n                            // Public Key...\n                            if (!(X509_FLAG_COMPAT & X509_FLAG_NO_PUBKEY))\n                            {\n                                publicKey = X509_get_pubkey(x509Cert);\n                                if (publicKey == NULL)\n                                {\n                                    printf(\"Public Key: Could not load\\n\");\n                                    printf_xml(\"   <pk error=\\\"true\\\" />\\n\");\n                                }\n                                else\n                                {\n                                    keyBits=EVP_PKEY_bits(publicKey);\n                                    switch (EVP_PKEY_id(publicKey))\n                                    {\n                                        case EVP_PKEY_RSA:\n                                            if (EVP_PKEY_get1_RSA(publicKey)!=NULL)\n                                            {\n                                                if (keyBits < 2048 )\n                                                {\n                                                    printf(\"RSA Key Strength:    %s%d%s\\n\", COL_RED, keyBits, RESET);\n                                                }\n                                                else if (keyBits >= 3072 )\n                                                {\n                                                    printf(\"RSA Key Strength:    %s%d%s\\n\", COL_GREEN, keyBits, RESET);\n                                                }\n                                                else\n                                                {\n                                                    printf(\"RSA Key Strength:    %d\\n\", keyBits);\n                                                }\n\n                                                printf_xml(\"   <pk error=\\\"false\\\" type=\\\"RSA\\\" bits=\\\"%d\\\" />\\n\", keyBits);\n                                            }\n                                            else\n                                            {\n                                                printf(\"    RSA Public Key: NULL\\n\");\n                                            }\n                                            printf(\"\\n\");\n                                            break;\n                                        case EVP_PKEY_DSA:\n                                            if (EVP_PKEY_get1_DSA(publicKey)!=NULL)\n                                            {\n                                                // TODO - display key strength\n                                                printf_xml(\"   <pk error=\\\"false\\\" type=\\\"DSA\\\" />\\n\");\n                                                /* DSA_print(stdoutBIO, publicKey->pkey.dsa, 6); */\n                                            }\n                                            else\n                                            {\n                                                printf(\"    DSA Public Key: NULL\\n\");\n                                            }\n                                            break;\n                                        case EVP_PKEY_EC:\n                                            {\n                                                EC_KEY *ec_key = EVP_PKEY_get1_EC_KEY(publicKey);\n                                                if (ec_key != NULL)\n                                                {\n                                                    // We divide by two to get the symmetric key strength equivalent; this\n                                                    // ensures consistency with the Server Key Exchange Group section.\n                                                    int keyBits = EVP_PKEY_bits(publicKey) / 2;\n                                                    const char *ec_group_name = OBJ_nid2sn(EC_GROUP_get_curve_name(EC_KEY_get0_group(ec_key)));\n                                                    char *color = \"\";\n\n\n                                                    if (keyBits < 112)\n                                                        color = COL_RED;\n                                                    else if (keyBits < 128)\n                                                        color = COL_YELLOW;\n\n                                                    printf(\"ECC Curve Name:      %s\\n\", ec_group_name);\n                                                    printf(\"ECC Key Strength:    %s%d%s\\n\\n\", color, keyBits, RESET);\n                                                    printf_xml(\"   <pk error=\\\"false\\\" type=\\\"EC\\\" curve_name=\\\"%s\\\" bits=\\\"%d\\\" />\\n\", ec_group_name, keyBits);\n                                                    EC_KEY_free(ec_key); ec_key = NULL;\n                                                }\n                                                else\n                                                    printf(\"    EC Public Key: NULL\\n\");\n                                            }\n                                            break;\n                                        default:\n                                            printf(\"    Public Key: Unknown\\n\");\n                                            printf_xml(\"   <pk error=\\\"true\\\" type=\\\"unknown\\\" />\\n\");\n                                            break;\n                                    }\n\n                                    EVP_PKEY_free(publicKey);\n                                }\n                            }\n\n                            // SSL Certificate Issuer...\n                            if (!(X509_FLAG_COMPAT & X509_FLAG_NO_ISSUER))\n                            {\n                                int cnindex;\n                                X509_NAME *subj;\n                                X509_NAME_ENTRY *e;\n                                ASN1_STRING *d;\n                                const char *subject;\n                                const char *issuer;\n\n                                // Get SSL cert CN\n                                cnindex = -1;\n                                subj = X509_get_subject_name(x509Cert);\n                                cnindex = X509_NAME_get_index_by_NID(subj, NID_commonName, cnindex);\n\n                                // SSL cert doesn't have a CN, so just print whole thing\n                                if (cnindex == -1)\n                                {\n                                    subject = (char *) X509_NAME_oneline(X509_get_subject_name(x509Cert), NULL, 0);\n                                    printf(\"Subject:  %s\\n\", subject);\n                                    printf_xml(\"   <subject><![CDATA[%s]]></subject>\\n\", subject);\n\n                                }\n                                else\n                                {\n                                    e = X509_NAME_get_entry(subj, cnindex);\n                                    d = X509_NAME_ENTRY_get_data(e);\n                                    subject = (char *) ASN1_STRING_data(d);\n                                    printf(\"Subject:  %s\\n\", subject);\n                                    printf_xml(\"   <subject><![CDATA[%s]]></subject>\\n\", subject);\n                                }\n\n                                // Get certificate altnames if supported\n                                if (!(X509_FLAG_COMPAT & X509_FLAG_NO_EXTENSIONS))\n                                {\n                                    if (sk_X509_EXTENSION_num(X509_get0_extensions(x509Cert)) > 0)\n                                    {\n                                        cnindex = X509_get_ext_by_NID (x509Cert, NID_subject_alt_name, -1);\n                                        if (cnindex != -1)\n                                        {\n                                            extension = X509v3_get_ext(X509_get0_extensions(x509Cert),cnindex);\n\n                                            printf(\"Altnames: \");\n                                            if (!X509V3_EXT_print(stdoutBIO, extension, X509_FLAG_COMPAT, 0))\n                                            {\n                                                ASN1_STRING_print(stdoutBIO, X509_EXTENSION_get_data(extension));\n                                            }\n                                            if (options->xmlOutput)\n                                            {\n                                                printf_xml(\"   <altnames><![CDATA[\");\n                                                if (!X509V3_EXT_print(fileBIO, extension, X509_FLAG_COMPAT, 0))\n                                                    ASN1_STRING_print(fileBIO, X509_EXTENSION_get_data(extension));\n                                            }\n                                            printf_xml(\"]]></altnames>\\n\");\n                                            printf(\"\\n\");\n                                        }\n                                    }\n                                }\n\n                                // Get SSL cert issuer\n                                cnindex = -1;\n                                subj = X509_get_issuer_name(x509Cert);\n                                cnindex = X509_NAME_get_index_by_NID(subj, NID_commonName, cnindex);\n\n                                // Issuer cert doesn't have a CN, so just print whole thing\n                                if (cnindex == -1)\n                                {\n                                    char *issuer = X509_NAME_oneline(X509_get_issuer_name(x509Cert), NULL, 0);\n                                    char *color = \"\";\n                                    int self_signed = 0;\n\n                                    if ((subject != NULL) && (strcmp(subject, issuer) == 0)) {\n                                        color = COL_RED;\n                                        self_signed = 1;\n                                    }\n                                    printf(\"%sIssuer:   %s%s\", color, issuer, RESET);\n                                    printf_xml(\"   <issuer><![CDATA[%s]]></issuer>\\n\", issuer);\n\n                                    if (self_signed) {\n                                        printf_xml(\"   <self-signed>true</self-signed>\\n\");\n                                    }\n                                    else {\n                                        printf_xml(\"   <self-signed>false</self-signed>\\n\");\n                                    }\n                                }\n                                else\n                                {\n                                    e = X509_NAME_get_entry(subj, cnindex);\n                                    d = X509_NAME_ENTRY_get_data(e);\n                                    issuer = (char *) ASN1_STRING_data(d);\n\n                                    // If issuer is same as hostname we scanned or is *, flag as self-signed\n                                    if (\n                                            strcmp(issuer, options->host) == 0\n                                            || strcmp(issuer, subject) == 0\n                                            || strcmp(issuer, \"*\") == 0\n                                       )\n                                    {\n                                        printf(\"Issuer:   %s%s%s\\n\", COL_RED, issuer, RESET);\n                                        printf_xml(\"   <issuer><![CDATA[%s]]></issuer>\\n\", issuer);\n                                        printf_xml(\"   <self-signed>true</self-signed>\\n\");\n\n                                    }\n                                    else\n                                    {\n                                        printf(\"Issuer:   %s\\n\", issuer);\n                                        printf_xml(\"   <issuer><![CDATA[%s]]></issuer>\\n\", issuer);\n                                        printf_xml(\"   <self-signed>false</self-signed>\\n\");\n                                    }\n                                }\n                            }\n\n                            // Check for certificate expiration\n                            time_t *ptime;\n                            int timediff;\n                            ptime = NULL;\n\n                            printf(\"\\nNot valid before: \");\n                            timediff = X509_cmp_time(X509_get_notBefore(x509Cert), ptime);\n                            // Certificate isn't valid yet\n                            if (timediff > 0)\n                            {\n                                printf(\"%s\", COL_RED);\n                            }\n                            else\n                            {\n                                printf(\"%s\", COL_GREEN);\n                            }\n                            ASN1_TIME_print(stdoutBIO, X509_get_notBefore(x509Cert));\n                            printf(\"%s\", RESET);\n\n                            if (options->xmlOutput) {\n                                printf_xml(\"   <not-valid-before>\");\n                                ASN1_TIME_print(fileBIO, X509_get_notBefore(x509Cert));\n                                printf_xml(\"</not-valid-before>\\n\");\n                                if (timediff > 0)\n                                {\n                                    printf_xml(\"   <not-yet-valid>true</not-yet-valid>\\n\");\n                                }\n                                else\n                                {\n                                    printf_xml(\"   <not-yet-valid>false</not-yet-valid>\\n\");\n                                }\n                            }\n\n                            printf(\"\\nNot valid after:  \");\n                            timediff = X509_cmp_time(X509_get_notAfter(x509Cert), ptime);\n                            // Certificate has expired\n                            if (timediff < 0)\n                            {\n                                printf(\"%s\", COL_RED);\n                            }\n                            else\n                            {\n                                printf(\"%s\", COL_GREEN);\n                            }\n                            ASN1_TIME_print(stdoutBIO, X509_get_notAfter(x509Cert));\n                            printf(\"%s\", RESET);\n                            if (options->xmlOutput) {\n                                printf_xml(\"   <not-valid-after>\");\n                                ASN1_TIME_print(fileBIO, X509_get_notAfter(x509Cert));\n                                printf_xml(\"</not-valid-after>\\n\");\n                                if (timediff < 0)\n                                {\n                                    printf_xml(\"   <expired>true</expired>\\n\");\n                                }\n                                else\n                                {\n                                    printf_xml(\"   <expired>false</expired>\\n\");\n                                }\n                            }\n                            printf(\"\\n\");\n\n                            // Free X509 Certificate...\n                            X509_free(x509Cert);\n                            // This is abusing status a bit, but means that we'll only get the cert once\n                            status = false;\n\n                            printf_xml(\"  </certificate>\\n\");\n                        }\n\n                        else {\n                            printf(\"    Unable to parse certificate\\n\");\n                        }\n\n                        // Free BIO\n                        BIO_free(stdoutBIO);\n                        if (options->xmlOutput)\n                            BIO_free(fileBIO);\n\n                        // Disconnect SSL over socket\n                        SSL_shutdown(ssl);\n                        // Free SSL object\n                        FREE_SSL(ssl);\n                    }\n                    else\n                    {\n                        status = false;\n                        printf_error(\"Could not create SSL object.\");\n                    }\n                }\n            }\n            else\n            {\n                status = false;\n                printf_error(\"Could not set cipher.\");\n            }\n\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n        // Error Creating Context Object\n        else\n        {\n            status = false;\n            printf_error(\"Could not create CTX object.\");\n        }\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n\n    // Could not connect\n    else\n        status = false;\n\n    return status;\n}\n\n// Request a stapled OCSP request from the server.\nint ocspRequest(struct sslCheckOptions *options)\n{\n    int cipherStatus = 0;\n    int status = true;\n    int socketDescriptor = 0;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio = NULL;\n    BIO *stdoutBIO = NULL;\n    BIO *fileBIO = NULL;\n    const SSL_METHOD *sslMethod = NULL;\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n        // Setup Context Object...\n        if( options->sslVersion == ssl_v2 || options->sslVersion == ssl_v3) {\n            printf_verbose(\"sslMethod = SSLv23_method()\");\n            sslMethod = SSLv23_method();\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n        else if( options->sslVersion == tls_v11) {\n            printf_verbose(\"sslMethod = TLSv1_1_method()\");\n            sslMethod = TLSv1_1_method();\n        }\n        else if( options->sslVersion == tls_v12) {\n            printf_verbose(\"sslMethod = TLSv1_2_method()\");\n            sslMethod = TLSv1_2_method();\n        }\n#endif\n        else if( options->sslVersion == tls_v13) {\n            printf_verbose(\"sslMethod = TLSv1_3_method()\");\n            sslMethod = TLSv1_3_method();\n        }\n        else {\n            printf_verbose(\"sslMethod = TLS_method()\\n\");\n            sslMethod = TLS_method();\n        }\n        options->ctx = new_CTX(sslMethod);\n        if (options->ctx != NULL)\n        {\n\n            if (SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL) != 0)\n            {\n                // Load Certs if required...\n                if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                    status = loadCerts(options);\n\n                if (status == true)\n                {\n                    // Create SSL object...\n                    ssl = new_SSL(options->ctx);\n                    if (ssl != NULL)\n                    {\n                        // Connect socket and BIO\n                        cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                        // Connect SSL and BIO\n                        SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n                        // Based on http://does-not-exist.org/mail-archives/mutt-dev/msg13045.html\n                        // TLS Virtual-hosting requires that the server present the correct\n                        // certificate; to do this, the ServerNameIndication TLS extension is used.\n                        // If TLS is negotiated, and OpenSSL is recent enough that it might have\n                        // support, and support was enabled when OpenSSL was built, mutt supports\n                        // sending the hostname we think we're connecting to, so a server can send\n                        // back the correct certificate.\n                        // NB: finding a server which uses this for IMAP is problematic, so this is\n                        // untested.  Please report success or failure!  However, this code change\n                        // has worked fine in other projects to which the contributor has added it,\n                        // or HTTP usage.\n                        SSL_set_tlsext_host_name (ssl, options->sniname);\n#endif\n\t\t\t\t\t\tSSL_set_tlsext_status_type(ssl, TLSEXT_STATUSTYPE_ocsp);\n\t\t\t\t\t\tSSL_CTX_set_tlsext_status_cb(options->ctx, ocsp_resp_cb);\n                        \n\t\t\t\t\t\t// Connect SSL over socket\n                        cipherStatus = SSL_connect(ssl);\n                        if (cipherStatus == 1)\n                        {\n                            // Setup BIO's\n                            if (!xml_to_stdout) {\n                                stdoutBIO = BIO_new(BIO_s_file());\n                                BIO_set_fp(stdoutBIO, stdout, BIO_NOCLOSE);\n                            }\n                            if (options->xmlOutput)\n                            {\n                                fileBIO = BIO_new(BIO_s_file());\n                                BIO_set_fp(fileBIO, options->xmlOutput, BIO_NOCLOSE);\n                            }\n\n                            // Free BIO\n                            BIO_free(stdoutBIO);\n                            if (options->xmlOutput)\n                                BIO_free(fileBIO);\n\n                            // Disconnect SSL over socket\n                            SSL_shutdown(ssl);\n                        }\n                        else\n                        {\n                            printf(\"\\n%sFailed to connect to get OCSP status.%s\\n\", COL_RED, RESET);\n                            printf(\"Most likely cause is server not supporting %s, try manually specifying version\\n\", printableSslMethod(sslMethod));\n                        }\n                        // Free SSL object\n                        FREE_SSL(ssl);\n                    }\n                    else\n                    {\n                        status = false;\n                        printf_error(\"Could not create SSL object.\");\n                    }\n                }\n            }\n            else\n            {\n                status = false;\n                printf_error(\"Could not set cipher.\");\n            }\n\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n        // Error Creating Context Object\n        else\n        {\n            status = false;\n            printf_error(\"Could not create CTX object.\");\n        }\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n\n    // Could not connect\n    else\n        status = false;\n\n    return status;\n}\n\nstatic int ocsp_resp_cb(SSL *s, void *unused) {\n    const unsigned char *p = NULL;\n    int len = 0;\n    OCSP_RESPONSE *o = NULL;\n    BIO *bp = BIO_new_fp(stdout, BIO_NOCLOSE);\n    int i = 0;\n    long l = 0;\n    OCSP_CERTID *cid = NULL;\n    OCSP_BASICRESP *br = NULL;\n    OCSP_RESPID *rid = NULL;\n    OCSP_RESPDATA *rd = NULL;\n    OCSP_CERTSTATUS *cst = NULL;\n    OCSP_REVOKEDINFO *rev = NULL;\n    OCSP_SINGLERESP *single = NULL;\n    OCSP_RESPBYTES *rb = NULL;\n\n\n    len = SSL_get_tlsext_status_ocsp_resp(s, &p);\n    if (p == NULL) {\n        BIO_puts(bp, \"No OCSP response received.\\n\\n\");\n        goto err;\n    }\n\n    o = d2i_OCSP_RESPONSE(NULL, &p, len);\n    if (o == NULL) {\n        BIO_puts(bp, \"OCSP response parse error\\n\");\n        BIO_dump_indent(bp, (char *)p, len, 4);\n        goto err;\n    }\n\n    rb = o->responseBytes;\n    l = ASN1_ENUMERATED_get(o->responseStatus);\n    if (BIO_printf(bp, \"OCSP Response Status: %s (0x%lx)\\n\",\n                   OCSP_response_status_str(l), l) <= 0)\n        goto err;\n    if (rb == NULL)\n        return 1;\n    if (BIO_puts(bp, \"Response Type: \") <= 0)\n        goto err;\n    if (i2a_ASN1_OBJECT(bp, rb->responseType) <= 0)\n        goto err;\n    if (OBJ_obj2nid(rb->responseType) != NID_id_pkix_OCSP_basic) {\n        BIO_puts(bp, \" (unknown response type)\\n\");\n        return 1;\n    }\n\n    if ((br = OCSP_response_get1_basic(o)) == NULL)\n        goto err;\n    rd = &br->tbsResponseData;\n    l = ASN1_INTEGER_get(rd->version);\n    if (BIO_printf(bp, \"\\nVersion: %lu (0x%lx)\\n\", l + 1, l) <= 0)\n        goto err;\n    if (BIO_puts(bp, \"Responder Id: \") <= 0)\n        goto err;\n\n    rid = &rd->responderId;\n    switch (rid->type) {\n    case V_OCSP_RESPID_NAME:\n        X509_NAME_print_ex(bp, rid->value.byName, 0, XN_FLAG_ONELINE);\n        break;\n    case V_OCSP_RESPID_KEY:\n        i2a_ASN1_STRING(bp, rid->value.byKey, 0);\n        break;\n    }\n\n    if (BIO_printf(bp, \"\\nProduced At: \") <= 0)\n        goto err;\n    if (!ASN1_GENERALIZEDTIME_print(bp, rd->producedAt))\n        goto err;\n    if (BIO_printf(bp, \"\\nResponses:\\n\") <= 0)\n        goto err;\n    for (i = 0; i < sk_OCSP_SINGLERESP_num(rd->responses); i++) {\n        if (!sk_OCSP_SINGLERESP_value(rd->responses, i))\n            continue;\n        single = sk_OCSP_SINGLERESP_value(rd->responses, i);\n        cid = single->certId;\n        if (ocsp_certid_print(bp, cid, 4) <= 0)\n            goto err;\n        cst = single->certStatus;\n        if (BIO_puts(bp, \"    Cert Status: \") <= 0)\n            goto err;\n        if (cst->type == V_OCSP_CERTSTATUS_GOOD) {\n          if (BIO_printf(bp, \"%s%s%s\", COL_GREEN, OCSP_cert_status_str(cst->type), RESET) <= 0)\n                goto err;\n\t} else if (cst->type == V_OCSP_CERTSTATUS_REVOKED) {\n            if (BIO_printf(bp, \"%s%s%s\", COL_RED, OCSP_cert_status_str(cst->type), RESET) <= 0)\n                goto err;\n            rev = cst->value.revoked;\n            if (BIO_printf(bp, \"\\n    Revocation Time: \") <= 0)\n                goto err;\n            if (!ASN1_GENERALIZEDTIME_print(bp, rev->revocationTime))\n                goto err;\n            if (rev->revocationReason) {\n                l = ASN1_ENUMERATED_get(rev->revocationReason);\n                if (BIO_printf(bp,\n                               \"\\n    Revocation Reason: %s (0x%lx)\",\n                               OCSP_crl_reason_str(l), l) <= 0)\n                    goto err;\n            }\n        } else {\n\t  if (BIO_printf(bp, \"%s%s%s\", COL_YELLOW, OCSP_cert_status_str(cst->type), RESET) <= 0)\n\t    goto err;\n\t}\n        if (BIO_printf(bp, \"\\n    This Update: \") <= 0)\n            goto err;\n        if (!ASN1_GENERALIZEDTIME_print(bp, single->thisUpdate))\n            goto err;\n        if (single->nextUpdate) {\n            if (BIO_printf(bp, \"\\n    Next Update: \") <= 0)\n                goto err;\n            if (!ASN1_GENERALIZEDTIME_print(bp, single->nextUpdate))\n                goto err;\n        }\n        if (BIO_write(bp, \"\\n\", 1) <= 0)\n            goto err;\n\n        if (!X509V3_extensions_print(bp,\n                                     \"Response Single Extensions\",\n                                     single->singleExtensions, 0, 4))\n            goto err;\n        if (BIO_write(bp, \"\\n\", 1) <= 0)\n            goto err;\n    }\n    /*\n    if (!X509V3_extensions_print(bp, \"Response Extensions\",\n                                 rd->responseExtensions, 0, 4))\n        goto err;\n    if (X509_signature_print(bp, &br->signatureAlgorithm, br->signature) <= 0)\n        goto err;\n\n    for (i = 0; i < sk_X509_num(br->certs); i++) {\n        X509_print(bp, sk_X509_value(br->certs, i));\n        PEM_write_bio_X509(bp, sk_X509_value(br->certs, i));\n    }\n    */\n err:\n  if (o != NULL) { OCSP_RESPONSE_free(o); o = NULL; }\n  BIO_free(bp);\n  return 1;\n}\n\nint ocsp_certid_print(BIO *bp, OCSP_CERTID *a, int indent)\n{\n    BIO_printf(bp, \"%*sCertificate ID:\\n\", indent, \"\");\n    indent += 2;\n    BIO_printf(bp, \"%*sHash Algorithm: \", indent, \"\");\n    i2a_ASN1_OBJECT(bp, a->hashAlgorithm.algorithm);\n    BIO_printf(bp, \"\\n%*sIssuer Name Hash: \", indent, \"\");\n    i2a_ASN1_STRING(bp, &a->issuerNameHash, 0);\n    BIO_printf(bp, \"\\n%*sIssuer Key Hash: \", indent, \"\");\n    i2a_ASN1_STRING(bp, &a->issuerKeyHash, 0);\n    BIO_printf(bp, \"\\n%*sSerial Number: \", indent, \"\");\n    i2a_ASN1_INTEGER(bp, &a->serialNumber);\n    BIO_printf(bp, \"\\n\");\n    return 1;\n}\n\n// Print out the full certificate\nint showCertificate(struct sslCheckOptions *options)\n{\n    // Variables...\n    int cipherStatus = 0;\n    int status = true;\n    int socketDescriptor = 0;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio = NULL;\n    BIO *stdoutBIO = NULL;\n    BIO *fileBIO = NULL;\n    X509 *x509Cert = NULL;\n    EVP_PKEY *publicKey = NULL;\n    const SSL_METHOD *sslMethod = NULL;\n    ASN1_OBJECT *asn1Object = NULL;\n    X509_EXTENSION *extension = NULL;\n    char buffer[1024];\n    long tempLong = 0;\n    int tempInt = 0;\n    int tempInt2 = 0;\n    long verifyError = 0;\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n\n        // Setup Context Object...\n        if( options->sslVersion == ssl_v2 || options->sslVersion == ssl_v3) {\n            printf_verbose(\"sslMethod = SSLv23_method()\");\n            sslMethod = SSLv23_method();\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n        else if( options->sslVersion == tls_v11) {\n            printf_verbose(\"sslMethod = TLSv1_1_method()\");\n            sslMethod = TLSv1_1_method();\n        }\n        else if( options->sslVersion == tls_v12) {\n            printf_verbose(\"sslMethod = TLSv1_2_method()\");\n            sslMethod = TLSv1_2_method();\n        }\n        else if( options->sslVersion == tls_v13) {\n            printf_verbose(\"sslMethod = TLSv1_3_method()\");\n            sslMethod = TLSv1_3_method();\n        }\n#endif\n        else {\n            printf_verbose(\"sslMethod = TLS_method()\\n\");\n            sslMethod = TLS_method();\n        }\n        options->ctx = new_CTX(sslMethod);\n        if (options->ctx != NULL)\n        {\n            if (SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL) != 0)\n            {\n                // Load Certs if required...\n                if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                    status = loadCerts(options);\n\n                if (status == true)\n                {\n                    // Create SSL object...\n                    ssl = new_SSL(options->ctx);\n                    if (ssl != NULL)\n                    {\n                        // Connect socket and BIO\n                        cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                        // Connect SSL and BIO\n                        SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n                        // Based on http://does-not-exist.org/mail-archives/mutt-dev/msg13045.html\n                        // TLS Virtual-hosting requires that the server present the correct\n                        // certificate; to do this, the ServerNameIndication TLS extension is used.\n                        // If TLS is negotiated, and OpenSSL is recent enough that it might have\n                        // support, and support was enabled when OpenSSL was built, mutt supports\n                        // sending the hostname we think we're connecting to, so a server can send\n                        // back the correct certificate.\n                        // NB: finding a server which uses this for IMAP is problematic, so this is\n                        // untested.  Please report success or failure!  However, this code change\n                        // has worked fine in other projects to which the contributor has added it,\n                        // or HTTP usage.\n                        SSL_set_tlsext_host_name (ssl, options->sniname);\n#endif\n\n                        // Connect SSL over socket\n                        cipherStatus = SSL_connect(ssl);\n                        if (cipherStatus == 1)\n                        {\n                            // Setup BIO's\n                            if (!xml_to_stdout) {\n                                stdoutBIO = BIO_new(BIO_s_file());\n                                BIO_set_fp(stdoutBIO, stdout, BIO_NOCLOSE);\n                            }\n                            if (options->xmlOutput)\n                            {\n                                fileBIO = BIO_new(BIO_s_file());\n                                BIO_set_fp(fileBIO, options->xmlOutput, BIO_NOCLOSE);\n                            }\n\n                            // Get certificate(s) chain\n                            STACK_OF(X509) *certificatesChain;\n\n                            if (options->showCertificates == true)\n                            {\n                                certificatesChain = SSL_get_peer_cert_chain(ssl);   \n                            }\n                            else\n                            {                                \n                                X509 *peerCertificate = SSL_get_peer_certificate(ssl);\n                                certificatesChain = sk_X509_new_null();\n                                sk_X509_push(certificatesChain, peerCertificate);\n                            }\n\n                            for (int cert_index = 0; cert_index < sk_X509_num(certificatesChain); cert_index++)\n                            {\n                                // Get Certificate...\n                                printf(\"\\n  %sSSL Certificate: %s\\n\", COL_BLUE, RESET);\n                                printf_xml(\"  <certificate type=\\\"full\\\">\\n\");\n\n                                x509Cert = sk_X509_value(certificatesChain, cert_index);\n\n                                if (x509Cert != NULL)\n                                {\n\n                                    // Print a base64 blob version of the cert\n                                    printf(\"    Certificate blob:\\n\");\n                                    PEM_write_bio_X509(stdoutBIO,x509Cert);\n                                    if (options->xmlOutput)\n                                    {\n                                        printf_xml(\"   <certificate-blob>\\n\");\n                                        PEM_write_bio_X509(fileBIO,x509Cert);\n                                        printf_xml(\"   </certificate-blob>\\n\");\n                                    }\n\n                                    // SSL_set_verify(ssl, SSL_VERIFY_NONE|SSL_VERIFY_CLIENT_ONCE, NULL);\n\n                                    // X509_print_ex(bp, x509Cert, 0, 0);\n\n                                    // Cert Version\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_VERSION))\n                                    {\n                                        tempLong = X509_get_version(x509Cert);\n                                        printf(\"    Version: %lu\\n\", tempLong);\n                                        printf_xml(\"   <version>%lu</version>\\n\", tempLong);\n                                    }\n\n                                    // Cert Serial No. - Code adapted from OpenSSL's crypto/asn1/t_x509.c\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_SERIAL))\n                                    {\n                                        ASN1_INTEGER *bs;\n                                        BIO *bp;\n                                        BIO *xml_bp;\n                                        bp = BIO_new_fp(stdout, BIO_NOCLOSE);\n                                        if (options->xmlOutput)\n                                            xml_bp = BIO_new_fp(options->xmlOutput, BIO_NOCLOSE);\n                                        long l;\n                                        int i;\n                                        const char *neg;\n                                        bs=X509_get_serialNumber(x509Cert);\n\n                                        if (BIO_write(bp,\"    Serial Number:\",18) <= 0)\n                                            return(1);\n\n                                        if (bs->length <= 4)\n                                        {\n                                            l=ASN1_INTEGER_get(bs);\n                                            if (l < 0)\n                                            {\n                                                l= -l;\n                                                neg=\"-\";\n                                            }\n                                            else\n                                                neg=\"\";\n                                            if (BIO_printf(bp,\" %s%lu (%s0x%lx)\\n\",neg,l,neg,l) <= 0)\n                                                return(1);\n                                            if (options->xmlOutput)\n                                                if (BIO_printf(xml_bp,\"   <serial>%s%lu (%s0x%lx)</serial>\\n\",neg,l,neg,l) <= 0)\n                                                    return(1);\n                                        }\n                                        else\n                                        {\n                                            neg=(bs->type == V_ASN1_NEG_INTEGER)?\" (Negative)\":\"\";\n                                            if (BIO_printf(bp,\"%1s%s\",\"\",neg) <= 0)\n                                                return(1);\n\n                                            if (options->xmlOutput)\n                                                if (BIO_printf(xml_bp,\"   <serial>\") <= 0)\n                                                    return(1);\n\n                                            for (i=0; i<bs->length; i++)\n                                            {\n                                                if (BIO_printf(bp,\"%02x%c\",bs->data[i],\n                                                               ((i+1 == bs->length)?'\\n':':')) <= 0)\n                                                    return(1);\n                                                if (options->xmlOutput) {\n                                                    if (i+1 == bs->length)\n                                                    {\n                                                        if (BIO_printf(xml_bp,\"%02x\",bs->data[i]) <= 0)\n                                                            return(1);\n                                                    }\n                                                    else\n                                                    {\n                                                        if (BIO_printf(xml_bp,\"%02x%c\",bs->data[i], ':') <= 0)\n                                                            return(1);\n                                                    }\n                                                }\n                                            }\n\n                                            if (options->xmlOutput)\n                                                if (BIO_printf(xml_bp,\"</serial>\\n\") <= 0)\n                                                    return(1);\n\n                                        }\n                                        if(NULL != bp)\n                                            BIO_free(bp);\n                                        // We don't free the xml_bp because it will be used in the future\n                                    }\n\n                                    // Signature Algo...\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_SIGNAME))\n                                    {\n                                        X509_signature_print(stdoutBIO, X509_get0_tbs_sigalg(x509Cert), NULL);\n                                        /*                                    printf(\"    Signature Algorithm: \");\n                                                                            i2a_ASN1_OBJECT(stdoutBIO, X509_get0_tbs_sigalg(x509Cert));\n                                                                            printf(\"\\n\");\n                                        */\n                                        if (options->xmlOutput)\n                                        {\n                                            printf_xml(\"   <signature-algorithm>\");\n                                            X509_signature_print(fileBIO, X509_get0_tbs_sigalg(x509Cert), NULL);\n                                            printf_xml(\"</signature-algorithm>\\n\");\n                                        }\n                                    }\n\n                                    // SSL Certificate Issuer...\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_ISSUER))\n                                    {\n                                        X509_NAME_oneline(X509_get_issuer_name(x509Cert), buffer, sizeof(buffer) - 1);\n                                        printf(\"    Issuer: %s\\n\", buffer);\n                                        printf_xml(\"   <issuer><![CDATA[%s]]></issuer>\\n\", buffer);\n                                    }\n\n                                    // Validity...\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_VALIDITY))\n                                    {\n                                        printf(\"    Not valid before: \");\n                                        ASN1_TIME_print(stdoutBIO, X509_get_notBefore(x509Cert));\n                                        if (options->xmlOutput)\n                                        {\n                                            printf_xml(\"   <not-valid-before>\");\n                                            ASN1_TIME_print(fileBIO, X509_get_notBefore(x509Cert));\n                                            printf_xml(\"</not-valid-before>\\n\");\n                                        }\n                                        printf(\"\\n    Not valid after: \");\n                                        ASN1_TIME_print(stdoutBIO, X509_get_notAfter(x509Cert));\n                                        printf(\"\\n\");\n                                        if (options->xmlOutput)\n                                        {\n                                            printf_xml(\"   <not-valid-after>\");\n                                            ASN1_TIME_print(fileBIO, X509_get_notAfter(x509Cert));\n                                            printf_xml(\"</not-valid-after>\\n\");\n                                        }\n                                    }\n\n                                    // SSL Certificate Subject...\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_SUBJECT))\n                                    {\n                                        X509_NAME_oneline(X509_get_subject_name(x509Cert), buffer, sizeof(buffer) - 1);\n                                        printf(\"    Subject: %s\\n\", buffer);\n                                        printf_xml(\"   <subject><![CDATA[%s]]></subject>\\n\", buffer);\n                                    }\n\n                                    // Public Key Algo...\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_PUBKEY))\n                                    {\n                                        printf(\"    Public Key Algorithm: \");\n                                        ASN1_OBJECT *xpoid = NULL;\n                                        i2a_ASN1_OBJECT(stdoutBIO, xpoid);\n                                        printf(\"\\n\");\n                                        if (options->xmlOutput)\n                                        {\n                                            printf_xml(\"   <pk-algorithm>\");\n                                            i2a_ASN1_OBJECT(fileBIO, xpoid);\n                                            printf_xml(\"</pk-algorithm>\\n\");\n                                        }\n\n                                        // Public Key...\n                                        publicKey = X509_get_pubkey(x509Cert);\n                                        if (publicKey == NULL)\n                                        {\n                                            printf(\"    Public Key: Could not load\\n\");\n                                            printf_xml(\"   <pk error=\\\"true\\\" />\\n\");\n                                        }\n                                        else\n                                        {\n                                            switch (EVP_PKEY_id(publicKey))\n                                            {\n                                            case EVP_PKEY_RSA:\n                                                if (EVP_PKEY_get1_RSA(publicKey)!=NULL)\n                                                {\n                                                    printf(\"    RSA Public Key: (%d bit)\\n\", EVP_PKEY_bits(publicKey));\n                                                    printf_xml(\"   <pk error=\\\"false\\\" type=\\\"RSA\\\" bits=\\\"%d\\\">\\n\", EVP_PKEY_bits(publicKey));\n                                                    RSA_print(stdoutBIO, EVP_PKEY_get1_RSA(publicKey), 6);\n                                                    if (options->xmlOutput)\n                                                    {\n                                                        RSA_print(fileBIO, EVP_PKEY_get1_RSA(publicKey), 4);\n                                                        printf_xml(\"   </pk>\\n\");\n                                                    }\n                                                }\n                                                else\n                                                {\n                                                    printf(\"    RSA Public Key: NULL\\n\");\n                                                }\n                                                break;\n                                            case EVP_PKEY_DSA:\n                                                if (EVP_PKEY_get1_DSA(publicKey)!=NULL)\n                                                {\n                                                    printf(\"    DSA Public Key:\\n\");\n                                                    printf_xml(\"   <pk error=\\\"false\\\" type=\\\"DSA\\\">\\n\");\n                                                    DSA_print(stdoutBIO, EVP_PKEY_get1_DSA(publicKey), 6);\n                                                    if (options->xmlOutput)\n                                                    {\n                                                        DSA_print(fileBIO, EVP_PKEY_get1_DSA(publicKey), 4);\n                                                        printf_xml(\"   </pk>\\n\");\n                                                    }\n                                                }\n                                                else\n                                                {\n                                                    printf(\"    DSA Public Key: NULL\\n\");\n                                                }\n                                                break;\n                                            case EVP_PKEY_EC:\n                                                if (EVP_PKEY_get1_EC_KEY(publicKey)!=NULL)\n                                                {\n                                                    printf(\"    EC Public Key:\\n\");\n                                                    printf_xml(\"   <pk error=\\\"false\\\" type=\\\"EC\\\">\\n\");\n                                                    EC_KEY_print(stdoutBIO, EVP_PKEY_get1_EC_KEY(publicKey), 6);\n                                                    if (options->xmlOutput)\n                                                    {\n                                                        EC_KEY_print(fileBIO, EVP_PKEY_get1_EC_KEY(publicKey), 4);\n                                                        printf_xml(\"   </pk>\\n\");\n                                                    }\n                                                }\n                                                else\n                                                {\n                                                    printf(\"    EC Public Key: NULL\\n\");\n                                                }\n                                                break;\n                                            default:\n                                                printf(\"    Public Key: Unknown\\n\");\n                                                printf_xml(\"   <pk error=\\\"true\\\" type=\\\"unknown\\\" />\\n\");\n                                                break;\n                                            }\n\n                                            EVP_PKEY_free(publicKey);\n                                        }\n                                    }\n\n                                    // X509 v3...\n                                    if (!(X509_FLAG_COMPAT & X509_FLAG_NO_EXTENSIONS))\n                                    {\n                                        if (sk_X509_EXTENSION_num(X509_get0_extensions(x509Cert)) > 0)\n                                        {\n                                            printf(\"    X509v3 Extensions:\\n\");\n                                            printf_xml(\"   <X509v3-Extensions>\\n\");\n                                            for (tempInt = 0; tempInt < sk_X509_EXTENSION_num(X509_get0_extensions(x509Cert)); tempInt++)\n                                            {\n                                                // Get Extension...\n                                                extension = sk_X509_EXTENSION_value(X509_get0_extensions(x509Cert), tempInt);\n\n                                                // Print Extension name...\n                                                printf(\"      \");\n                                                asn1Object = X509_EXTENSION_get_object(extension);\n                                                i2a_ASN1_OBJECT(stdoutBIO, asn1Object);\n                                                tempInt2 = X509_EXTENSION_get_critical(extension);\n                                                BIO_printf(stdoutBIO, \": %s\\n\", tempInt2 ? \"critical\" : \"\");\n                                                if (options->xmlOutput)\n                                                {\n                                                    printf_xml(\"    <extension name=\\\"\");\n                                                    i2a_ASN1_OBJECT(fileBIO, asn1Object);\n                                                    BIO_printf(fileBIO, \"\\\"%s><![CDATA[\", tempInt2 ? \" level=\\\"critical\\\"\" : \"\");\n                                                }\n\n                                                // Print Extension value...\n                                                if (!X509V3_EXT_print(stdoutBIO, extension, X509_FLAG_COMPAT, 8))\n                                                {\n                                                    printf(\"        \");\n                                                    ASN1_STRING_print(stdoutBIO, X509_EXTENSION_get_data(extension));\n                                                }\n                                                if (options->xmlOutput)\n                                                {\n                                                    if (!X509V3_EXT_print(fileBIO, extension, X509_FLAG_COMPAT, 0))\n                                                        ASN1_STRING_print(stdoutBIO, X509_EXTENSION_get_data(extension));\n                                                    printf_xml(\"]]></extension>\\n\");\n                                                }\n                                                printf(\"\\n\");\n                                            }\n                                            printf_xml(\"   </X509v3-Extensions>\\n\");\n                                        }\n                                    }\n\n                                    // Verify Certificate...\n                                    printf(\"  Verify m:\\n\");\n                                    verifyError = SSL_get_verify_result(ssl);\n                                    if (verifyError == X509_V_OK)\n                                    {\n                                        printf(\"    Certificate passed verification\\n\");\n                                    }\n                                    else\n                                    {\n                                        printf(\"    %s\\n\", X509_verify_cert_error_string(verifyError));\n                                    }\n\n                                    // Free X509 Certificate...\n                                    X509_free(x509Cert);\n                                }\n\n                                else\n                                {\n                                    printf(\"    Unable to parse certificate\\n\");\n                                }\n\n                                printf_xml(\"  </certificate>\\n\");\n                            }\n\n                            // Free BIO\n                            BIO_free(stdoutBIO);\n                            if (options->xmlOutput)\n                                BIO_free(fileBIO);\n\n                            // Disconnect SSL over socket\n                            SSL_shutdown(ssl);\n                        }\n\n                        // Free SSL object\n                        FREE_SSL(ssl);\n                    }\n                    else\n                    {\n                        status = false;\n                        printf_error(\"Could not create SSL object.\");\n                    }\n                }\n            }\n            else\n            {\n                status = false;\n                printf_error(\"Could not set cipher.\");\n            }\n\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n\n        // Error Creating Context Object\n        else\n        {\n            status = false;\n            printf_error(\"Could not create CTX object.\");\n        }\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n\n    // Could not connect\n    else\n        status = false;\n\n    return status;\n}\n\n\n// Print out the list of trusted CAs\nint showTrustedCAs(struct sslCheckOptions *options)\n{\n    // Variables...\n    int cipherStatus = 0;\n    int status = true;\n    int socketDescriptor = 0;\n    SSL *ssl = NULL;\n    BIO *cipherConnectionBio = NULL;\n    BIO *stdoutBIO = NULL;\n    BIO *fileBIO = NULL;\n    const SSL_METHOD *sslMethod = NULL;\n    char buffer[1024];\n    int tempInt = 0;\n    STACK_OF(X509_NAME) *sk2;\n    X509_NAME *xn;\n\n    // Connect to host\n    socketDescriptor = tcpConnect(options);\n    if (socketDescriptor != 0)\n    {\n\n        // Setup Context Object...\n        if( options->sslVersion == ssl_v2 || options->sslVersion == ssl_v3) {\n            printf_verbose(\"sslMethod = SSLv23_method()\");\n            sslMethod = SSLv23_method();\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n        else if( options->sslVersion == tls_v11) {\n            printf_verbose(\"sslMethod = TLSv1_1_method()\");\n            sslMethod = TLSv1_1_method();\n        }\n        else if( options->sslVersion == tls_v12) {\n            printf_verbose(\"sslMethod = TLSv1_2_method()\");\n            sslMethod = TLSv1_2_method();\n        }\n        else if( options->sslVersion == tls_v13) {\n            printf_verbose(\"sslMethod = TLSv1_3_method()\");\n            sslMethod = TLSv1_3_method();\n        }\n#endif\n        else {\n            printf_verbose(\"sslMethod = TLS_method()\\n\");\n            sslMethod = TLS_method();\n        }\n        options->ctx = new_CTX(sslMethod);\n        if (options->ctx != NULL)\n        {\n            if (SSL_CTX_set_cipher_list(options->ctx, CIPHERSUITE_LIST_ALL) != 0)\n            {\n                // Load Certs if required...\n                if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                    status = loadCerts(options);\n\n                if (status == true)\n                {\n                    // Create SSL object...\n                    ssl = new_SSL(options->ctx);\n                    if (ssl != NULL)\n                    {\n                        // Connect socket and BIO\n                        cipherConnectionBio = BIO_new_socket(socketDescriptor, BIO_NOCLOSE);\n\n                        // Connect SSL and BIO\n                        SSL_set_bio(ssl, cipherConnectionBio, cipherConnectionBio);\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)\n                        // Based on http://does-not-exist.org/mail-archives/mutt-dev/msg13045.html\n                        // TLS Virtual-hosting requires that the server present the correct\n                        // certificate; to do this, the ServerNameIndication TLS extension is used.\n                        // If TLS is negotiated, and OpenSSL is recent enough that it might have\n                        // support, and support was enabled when OpenSSL was built, mutt supports\n                        // sending the hostname we think we're connecting to, so a server can send\n                        // back the correct certificate.\n                        // NB: finding a server which uses this for IMAP is problematic, so this is\n                        // untested.  Please report success or failure!  However, this code change\n                        // has worked fine in other projects to which the contributor has added it,\n                        // or HTTP usage.\n                        SSL_set_tlsext_host_name (ssl, options->sniname);\n#endif\n\n                        // Connect SSL over socket\n                        cipherStatus = SSL_connect(ssl);\n                        if (cipherStatus >= 0)\n                        {\n                            // Setup BIO's\n                            if (!xml_to_stdout) {\n                                stdoutBIO = BIO_new(BIO_s_file());\n                                BIO_set_fp(stdoutBIO, stdout, BIO_NOCLOSE);\n                            }\n                            if (options->xmlOutput)\n                            {\n                                fileBIO = BIO_new(BIO_s_file());\n                                BIO_set_fp(fileBIO, options->xmlOutput, BIO_NOCLOSE);\n                            }\n\n                            printf(\"\\n  %sAcceptable client certificate CA names:%s\\n\", COL_BLUE, RESET);\n                            sk2=SSL_get_client_CA_list(ssl);\n                            if ((sk2 != NULL) && (sk_X509_NAME_num(sk2) > 0))\n                            {\n                                for (tempInt=0; tempInt<sk_X509_NAME_num(sk2); tempInt++)\n                                {\n                                    xn=sk_X509_NAME_value(sk2,tempInt);\n                                    X509_NAME_oneline(xn,buffer,sizeof(buffer));\n                                    if (options->xmlOutput)\n                                    {\n                                        printf_xml(\"  <ca>\\n\");\n                                        BIO_printf(fileBIO, \"%s\", buffer);\n                                        BIO_printf(fileBIO, \"\\n\");\n                                        printf_xml(\"  </ca>\\n\");\n                                    }\n                                    printf(\"%s\", buffer);\n                                    printf(\"\\n\");\n                                }\n                            }\n                            else\n                            {\n                                printf(\"%sNone defined (any)%s\\n\", COL_YELLOW, RESET);\n                            }\n\n                            // Free BIO\n                            BIO_free(stdoutBIO);\n                            if (options->xmlOutput)\n                                BIO_free(fileBIO);\n\n                            // Disconnect SSL over socket\n                            SSL_shutdown(ssl);\n                        }\n\n                        // Free SSL object\n                        FREE_SSL(ssl);\n                    }\n                    else\n                    {\n                        status = false;\n                        printf_error(\"Could not create SSL object.\");\n                    }\n                }\n            }\n            else\n            {\n                status = false;\n                printf_error(\"Could not set cipher.\");\n            }\n\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n\n        // Error Creating Context Object\n        else\n        {\n            status = false;\n            printf_error(\"Could not create CTX object.\");\n        }\n\n        // Disconnect from host\n        close(socketDescriptor);\n    }\n\n    // Could not connect\n    else\n        status = false;\n\n    return status;\n}\n\nint testConnection(struct sslCheckOptions *options)\n{\n    // Variables...\n    int socketDescriptor = 0;\n    struct addrinfo *ai;\n    struct addrinfo *addrinfoResult = NULL;\n    struct addrinfo hints;\n\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_family = AF_UNSPEC;\n\n    // Resolve Host Name\n    if (options->ipv4 && options->ipv6)\n    {\n       // If both IPv4 and IPv6 are enabled, we restrict nothing in the\n       // results (i.e.: we'll accept either type of address).\n    }\n    else if (options->ipv4)  // Only IPv4 is acceptable...\n    {\n        hints.ai_family = AF_INET;\n    }\n    else if (options->ipv6)  // Only IPv6 is acceptable...\n    {\n        hints.ai_family = AF_INET6;\n        printf(\"Trying %sIPv6%s lookup\\n\\n\", COL_GREEN, RESET);\n    }\n\n    // Perform the actual lookup.\n    if (getaddrinfo(options->host, NULL, &hints, &addrinfoResult) != 0)\n    {\n        printf_error(\"Could not resolve hostname %s.\", options->host);\n        return false;\n    }\n\n    // Configure Server Address and Port\n    for (ai = addrinfoResult; ai != NULL; ai = ai->ai_next)\n    {\n        if (ai->ai_family == AF_INET6)\n        {\n            options->serverAddress6.sin6_family = ai->ai_family;\n            memcpy((char *) &options->serverAddress6, ai->ai_addr, ai->ai_addrlen);\n            options->serverAddress6.sin6_port = htons(options->port);\n            inet_ntop(ai->ai_family, &options->serverAddress6.sin6_addr, options->addrstr, sizeof(options->addrstr));\n        }\n        else\n        {\n            options->serverAddress.sin_family = ai->ai_family;\n            memcpy((char *) &options->serverAddress, ai->ai_addr, ai->ai_addrlen);\n            options->serverAddress.sin_port = htons(options->port);\n            inet_ntop(ai->ai_family, &options->serverAddress.sin_addr, options->addrstr, sizeof(options->addrstr));\n        }\n        options->h_addrtype = ai->ai_family;\n\n        socketDescriptor = tcpConnect(options);\n        if (socketDescriptor != 0)\n        {\n            close(socketDescriptor);\n            freeaddrinfo(addrinfoResult); addrinfoResult = NULL;\n            printf(\"%sConnected to %s%s\\n\\n\", COL_GREEN, options->addrstr, RESET);\n            return true;\n        }\n    }\n    freeaddrinfo(addrinfoResult); addrinfoResult = NULL;\n    return false;\n}\n\nint testProtocolCiphers(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)\n{\n    int status;\n    status = true;\n\n    if (sslMethod == TLSv1_3_client_method())\n      strncpy(options->cipherstring, TLSV13_CIPHERSUITES, sizeof(options->cipherstring));\n    else\n      strncpy(options->cipherstring, CIPHERSUITE_LIST_ALL, sizeof(options->cipherstring));\n\n    // Loop until the server won't accept any more ciphers\n    while (status == true)\n    {\n        // Setup Context Object...\n        options->ctx = new_CTX(sslMethod);\n        if (options->ctx != NULL)\n        {\n            // SSL implementation bugs/workaround\n            if (options->sslbugs)\n                SSL_CTX_set_options(options->ctx, SSL_OP_ALL | 0);\n            else\n                SSL_CTX_set_options(options->ctx, 0);\n\n            // minimal protocol version \n            if (sslMethod == TLSv1_3_client_method())\n                SSL_CTX_set_min_proto_version(options->ctx, TLS1_3_VERSION);\n\n            // Load Certs if required...\n            if ((options->clientCertsFile != 0) || (options->privateKeyFile != 0))\n                status = loadCerts(options);\n\n            // Test the cipher\n            if (status == true)\n                status = testCipher(options, sslMethod);\n\n            // Free CTX Object\n            FREE_CTX(options->ctx);\n        }\n\n        // Error Creating Context Object\n        else\n        {\n            printf_error(\"Could not create CTX object.\");\n            return false;\n        }\n    }\n\n    /* Test the missing ciphersuites. */\n    if (sslMethod != TLSv1_3_client_method()) {\n      int tls_version = TLSv1_0;\n      if (sslMethod == TLSv1_1_client_method())\n\ttls_version = TLSv1_1;\n      else if (sslMethod == TLSv1_2_client_method())\n\ttls_version = TLSv1_2;\n\n      testMissingCiphers(options, tls_version);\n    }\n    return true;\n}\n\n// Test a single host and port for ciphers...\nint testHost(struct sslCheckOptions *options)\n{\n    // Variables...\n    struct sslCipher *sslCipherPointer = NULL;\n    int status = true;\n    \n    // XML Output...\n    printf_xml(\" <ssltest host=\\\"%s\\\" sniname=\\\"%s\\\" port=\\\"%d\\\">\\n\", options->host, options->sniname, options->port);\n\n    // Verbose warning about STARTTLS and SSLv3\n    if (options->sslVersion == ssl_v3 || options->sslVersion == ssl_all)\n    {\n        printf_verbose(\"Some servers will fail to response to SSLv3 ciphers over STARTTLS\\nIf your scan hangs, try using the --tlsall option\\n\\n\");\n    }\n\n    printf(\"Testing SSL server %s%s%s on port %s%d%s using SNI name %s%s%s\\n\\n\", COL_GREEN, options->host, RESET,\n            COL_GREEN, options->port, RESET, COL_GREEN, options->sniname, RESET);\n\n    printf(\"  %sSSL/TLS Protocols:%s\\n\", COL_BLUE, RESET);\n\n    // Check if SSLv2 is enabled.\n    if ((options->sslVersion == ssl_all) || (options->sslVersion == ssl_v2)) {\n      if (runSSLv2Test(options)) {\n        printf(\"SSLv2     %senabled%s\\n\", COL_RED, RESET);\n        printf_xml(\"  <protocol type=\\\"ssl\\\" version=\\\"2\\\" enabled=\\\"1\\\" />\\n\");\n      } else {\n        printf(\"SSLv2     %sdisabled%s\\n\", COL_GREEN, RESET);\n        printf_xml(\"  <protocol type=\\\"ssl\\\" version=\\\"2\\\" enabled=\\\"0\\\" />\\n\");\n      }\n    }\n\n    // Check if SSLv3 is enabled.\n    if ((options->sslVersion == ssl_all) || (options->sslVersion == ssl_v3)) {\n      if (runSSLv3Test(options)) {\n\tprintf(\"SSLv3     %senabled%s\\n\", COL_RED, RESET);\n\tprintf_xml(\"  <protocol type=\\\"ssl\\\" version=\\\"3\\\" enabled=\\\"1\\\" />\\n\");\n      } else {\n\tprintf(\"SSLv3     %sdisabled%s\\n\", COL_GREEN, RESET);\n\tprintf_xml(\"  <protocol type=\\\"ssl\\\" version=\\\"3\\\" enabled=\\\"0\\\" />\\n\");\n      }\n    }\n\n    /* Test if TLSv1.0 through TLSv1.3 is supported.  This allows us to skip unnecessary tests later.  Print status of each protocol when verbose flag is set. */\n    if ((options->sslVersion == ssl_all) || (options->sslVersion == tls_all) || (options->sslVersion == tls_v10)) {\n      if ((options->tls10_supported = checkIfTLSVersionIsSupported(options, TLSv1_0))) {\n\tprintf(\"TLSv1.0   %senabled%s\\n\", COL_YELLOW, RESET);\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.0\\\" enabled=\\\"1\\\" />\\n\");\n      } else {\n\tprintf(\"TLSv1.0   %sdisabled%s\\n\", COL_GREEN, RESET);\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.0\\\" enabled=\\\"0\\\" />\\n\");\n      }\n    }\n\n    if ((options->sslVersion == ssl_all) || (options->sslVersion == tls_all) || (options->sslVersion == tls_v11)) {\n      if ((options->tls11_supported = checkIfTLSVersionIsSupported(options, TLSv1_1))) {\n\tprintf(\"TLSv1.1   %senabled%s\\n\", COL_YELLOW, RESET);\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.1\\\" enabled=\\\"1\\\" />\\n\");\n      } else {\n\tprintf(\"TLSv1.1   %sdisabled%s\\n\", COL_GREEN, RESET);\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.1\\\" enabled=\\\"0\\\" />\\n\");\n      }\n    }\n\n    if ((options->sslVersion == ssl_all) || (options->sslVersion == tls_all) || (options->sslVersion == tls_v12)) {\n      if ((options->tls12_supported = checkIfTLSVersionIsSupported(options, TLSv1_2))) {\n\tprintf(\"TLSv1.2   enabled\\n\");\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.2\\\" enabled=\\\"1\\\" />\\n\");\n      } else {\n\tprintf(\"TLSv1.2   disabled\\n\");\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.2\\\" enabled=\\\"0\\\" />\\n\");\n      }\n    }\n\n    if ((options->sslVersion == ssl_all) || (options->sslVersion == tls_all) || (options->sslVersion == tls_v13)) {\n      if ((options->tls13_supported = checkIfTLSVersionIsSupported(options, TLSv1_3))) {\n\tprintf(\"TLSv1.3   %senabled%s\\n\", COL_GREEN, RESET);\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.3\\\" enabled=\\\"1\\\" />\\n\");\n      } else {\n\tprintf(\"TLSv1.3   %sdisabled%s\\n\", COL_YELLOW, RESET);\n\tprintf_xml(\"  <protocol type=\\\"tls\\\" version=\\\"1.3\\\" enabled=\\\"0\\\" />\\n\");\n      }\n    }\n    printf(\"\\n\");\n\n    if (options->showClientCiphers == true)\n    {\n        // Build a list of ciphers...\n        switch (options->sslVersion)\n        {\n            case ssl_all:\n                populateCipherList(options, TLSv1_3_client_method());\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n                populateCipherList(options, TLSv1_2_client_method());\n                populateCipherList(options, TLSv1_1_client_method());\n#endif\n                populateCipherList(options, TLSv1_client_method());\n                break;\n            case tls_all:\n                populateCipherList(options, TLSv1_3_client_method());\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n                populateCipherList(options, TLSv1_2_client_method());\n                populateCipherList(options, TLSv1_1_client_method());\n#endif\n                populateCipherList(options, TLSv1_client_method());\n                break;\n            case tls_v13:\n                populateCipherList(options, TLSv1_3_client_method());\n                break;\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n            case tls_v12:\n                populateCipherList(options, TLSv1_2_client_method());\n                break;\n            case tls_v11:\n                populateCipherList(options, TLSv1_1_client_method());\n                break;\n#endif\n            case tls_v10:\n                populateCipherList(options, TLSv1_client_method());\n                break;\n        }\n        printf(\"\\n  %sOpenSSL-Supported Client Cipher(s):%s\\n\", COL_BLUE, RESET);\n        sslCipherPointer = options->ciphers;\n        while ((sslCipherPointer != 0) && (status == true))\n        {\n            printf(\"    %s\\n\",sslCipherPointer->name);\n            printf_xml(\"  <client-cipher cipher=\\\"%s\\\" provider=\\\"openssl\\\" />\\n\", sslCipherPointer->name);\n\n            sslCipherPointer = sslCipherPointer->next;\n        }\n        printf(\"\\n  %sDirectly-Supported Client Cipher(s):%s\\n\", COL_BLUE, RESET);\n        for (int i = 0; i < (sizeof(missing_ciphersuites) / sizeof(struct missing_ciphersuite)); i++) {\n            printf(\"    %s\\n\", missing_ciphersuites[i].protocol_name);\n            printf_xml(\"  <client-cipher cipher=\\\"%s\\\" provider=\\\"sslscan\\\" />\\n\", missing_ciphersuites[i].protocol_name);\n        }\n        printf(\"\\n\");\n    }\n    if (status == true && options->fallback )\n    {\n        printf(\"  %sTLS Fallback SCSV:%s\\n\", COL_BLUE, RESET);\n#ifdef SSL_MODE_SEND_FALLBACK_SCSV\n        testFallback(options, NULL);\n#else\n        printf(\"%sOpenSSL version does not support SCSV fallback%s\\n\\n\", COL_RED, RESET);\n\n#endif\n    }\n    if (status == true && options->reneg )\n    {\n        printf(\"  %sTLS renegotiation:%s\\n\", COL_BLUE, RESET);\n        testRenegotiation(options, TLSv1_client_method());\n    }\n\n    if (status == true && options->compression )\n    {\n        printf(\"  %sTLS Compression:%s\\n\", COL_BLUE, RESET);\n        testCompression(options, TLSv1_client_method());\n    }\n\n    if (status == true && options->heartbleed )\n    {\n        printf(\"  %sHeartbleed:%s\\n\", COL_BLUE, RESET);\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n        if ((options->sslVersion == ssl_all || options->sslVersion == tls_all || options->sslVersion == tls_v13) && options->tls13_supported)\n        {\n            printf(\"TLSv1.3 \");\n            status = testHeartbleed(options, TLSv1_3_client_method());\n        }\n        if ((options->sslVersion == ssl_all || options->sslVersion == tls_all || options->sslVersion == tls_v12) && options->tls12_supported)\n        {\n            printf(\"TLSv1.2 \");\n            status = testHeartbleed(options, TLSv1_2_client_method());\n        }\n        if ((options->sslVersion == ssl_all || options->sslVersion == tls_all || options->sslVersion == tls_v11) && options->tls11_supported)\n        {\n            printf(\"TLSv1.1 \");\n            status = testHeartbleed(options, TLSv1_1_client_method());\n        }\n#endif\n        if ((options->sslVersion == ssl_all || options->sslVersion == tls_all || options->sslVersion == tls_v10) && options->tls10_supported)\n        {\n            printf(\"TLSv1.0 \");\n            status = testHeartbleed(options, TLSv1_client_method());\n        }\n        if( options->sslVersion == ssl_v2 || options->sslVersion == ssl_v3)\n        {\n            printf(\"%sAll TLS protocols disabled, cannot check for heartbleed.\\n%s\", COL_RED, RESET);\n        }\n            printf(\"\\n\");\n    }\n\n\t// Print OCSP response\n\tif (status == true && options->ocspStatus == true)\n\t{\n\t\tprintf(\"  %sOCSP Stapling Request:%s\\n\", COL_BLUE, RESET);\n#if OPENSSL_VERSION_NUMBER > 0x00908000L && !defined(OPENSSL_NO_TLSEXT)\n\t\tstatus = ocspRequest(options);\n#endif\n\t}\n\n    if (options->ciphersuites)\n    {\n        // Test supported ciphers...\n        printf(\"  %sSupported Server Cipher(s):%s\\n\", COL_BLUE, RESET);\n        switch (options->sslVersion)\n        {\n            case ssl_all:\n            case tls_all:\n                if ((status != false) && options->tls13_supported)\n                    status = testProtocolCiphers(options, TLSv1_3_client_method());\n                if ((status != false) && options->tls12_supported)\n                    status = testProtocolCiphers(options, TLSv1_2_client_method());\n                if ((status != false) && options->tls11_supported)\n                    status = testProtocolCiphers(options, TLSv1_1_client_method());\n                if ((status != false) && options->tls10_supported)\n                    status = testProtocolCiphers(options, TLSv1_client_method());\n                break;\n            case tls_v10:\n                if ((status != false) && options->tls10_supported)\n                    status = testProtocolCiphers(options, TLSv1_client_method());\n                break;\n            case tls_v11:\n                if ((status != false) && options->tls11_supported)\n                    status = testProtocolCiphers(options, TLSv1_1_client_method());\n                break;\n            case tls_v12:\n                if ((status != false) && options->tls12_supported)\n                    status = testProtocolCiphers(options, TLSv1_2_client_method());\n                break;\n            case tls_v13:\n                if ((status != false) && options->tls13_supported)\n                    status = testProtocolCiphers(options, TLSv1_3_client_method());\n                break;\n        }\n    }\n\n    // Enumerate key exchange groups.\n    if (options->groups)\n        testSupportedGroups(options);\n\n    // Enumerate signature algorithms.\n    if (options->signature_algorithms)\n        testSignatureAlgorithms(options);\n\n    // Certificate checks\n    if (status == true && (options->showCertificate == true || options->checkCertificate == true))\n    {\n        printf_xml(\" <certificates>\\n\");\n\n        // Full certificate details\n        if (status == true && (options->showCertificate == true || options->showCertificates == true))\n        {\n            status = showCertificate(options);\n        }\n\n        // Default certificate details\n        if (status == true && options->checkCertificate == true)\n        {\n            if (status != false)\n                status = checkCertificateProtocol(options, TLSv1_3_client_method());\n            if (status != false)\n                status = checkCertificateProtocol(options, TLSv1_2_client_method());\n            if (status != false)\n                status = checkCertificateProtocol(options, TLSv1_1_client_method());\n            if (status != false)\n                status = checkCertificateProtocol(options, TLSv1_client_method());\n            if (status != false)\n                printf(\"Certificate information cannot be retrieved.\\n\\n\");\n        }\n        printf_xml(\" </certificates>\\n\");\n    }\n\n    // Print client auth trusted CAs\n    if (options->showTrustedCAs == true)\n    {\n        status = showTrustedCAs(options);\n    }\n\n    // XML Output...\n    printf_xml(\" </ssltest>\\n\");\n\n    // Return status...\n    return status;\n}\n\n\nint main(int argc, char *argv[])\n{\n    // Variables...\n    struct sslCheckOptions sslOptions;\n    struct sslCipher *sslCipherPointer;\n    int argLoop;\n    int tempInt;\n    int maxSize;\n    int xmlArg;\n    int mode = mode_help;\n    int msec;\n    FILE *targetsFile;\n    char line[1024];\n#ifdef _WIN32\n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n    HANDLE hConsole;\n    DWORD consoleMode;\n    unsigned int enable_colors;\n#endif\n\n    // Init...\n    memset(&sslOptions, 0, sizeof(struct sslCheckOptions));\n    sslOptions.port = 0;\n    xmlArg = 0;\n    strncpy(sslOptions.host, \"127.0.0.1\", 10);\n    sslOptions.showCertificate = false;\n    sslOptions.showTrustedCAs = false;\n    sslOptions.checkCertificate = true;\n    sslOptions.showClientCiphers = false;\n    sslOptions.showCipherIds = false;\n    sslOptions.showTimes = false;\n    sslOptions.ciphersuites = true;\n    sslOptions.reneg = true;\n    sslOptions.fallback = true;\n    sslOptions.compression = true;\n    sslOptions.heartbleed = true;\n    sslOptions.groups = true;\n    sslOptions.signature_algorithms = false;\n    sslOptions.starttls_ftp = false;\n    sslOptions.starttls_imap = false;\n    sslOptions.starttls_irc = false;\n    sslOptions.starttls_ldap = false;\n    sslOptions.starttls_pop3 = false;\n    sslOptions.starttls_smtp = false;\n    sslOptions.starttls_mysql = false;\n    sslOptions.starttls_xmpp = false;\n    sslOptions.starttls_psql = false;\n    sslOptions.xmpp_server = false;\n    sslOptions.verbose = false;\n    sslOptions.cipher_details = true;\n    sslOptions.ipv4 = true;\n    sslOptions.ipv6 = true;\n    sslOptions.ocspStatus = false;\n\n    // Default socket timeout 3s\n    sslOptions.timeout.tv_sec = 3;\n    sslOptions.timeout.tv_usec = 0;\n    // Default connect timeout 75s\n    sslOptions.connect_timeout = 75;\n    sslOptions.sleep = 0;\n\n    sslOptions.sslVersion = ssl_all;\n\n    struct sslCheckOptions *options = &sslOptions;\n\n#ifdef _WIN32\n    /* Attempt to enable console colors.  This succeeds in Windows 10.  For other\n     * OSes, color is disabled. */\n    enable_colors = 1;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    /* Cygwin's terminal is re-directed, so GetConsoleMode() fails on it.  So we'll try to get a direct handle in that case. */\n    if (!GetConsoleMode(hConsole, &consoleMode)) {\n      hConsole = CreateFile(\"CONIN$\", GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\n      /* Also, Cygwin appears to do full buffering of output, so the program seems to hang until its fully complete, then the output gets dumped all at once.  To be more responsive, we'll force line buffering at 80 bytes (the default terminal width). */\n      setvbuf(stdout, NULL, _IOLBF, 80);\n\n      /* If we still can't get console information, then disable colors. */\n      if (!GetConsoleMode(hConsole, &consoleMode))\n\tenable_colors = 0;\n    }\n\n    /* Some terminals already have colors enabled, and somehow don't like being set. */\n    if (enable_colors && ((consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == 0)) {\n      if (!SetConsoleMode(hConsole, consoleMode | ENABLE_VIRTUAL_TERMINAL_PROCESSING))\n\tenable_colors = 0;\n    }\n\n    if (!enable_colors) {\n        RESET = \"\";\n        COL_RED = \"\";\n        COL_YELLOW = \"\";\n        COL_BLUE = \"\";\n        COL_GREEN = \"\";\n        COL_PURPLE = \"\";\n        COL_GREY = \"\";\n        COL_RED_BG = \"\";\n    }\n\n    /* Initialize networking library. */\n    wVersionRequested = MAKEWORD(2, 2);\n    err = WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0)\n    {\n        printf_error(\"WSAStartup failed: %d\", err);\n        return -1;\n    }\n#endif\n    SSL_library_init();\n\n    // Get program parameters\n    for (argLoop = 1; argLoop < argc; argLoop++)\n    {\n        // Help\n        if ((strcmp(\"--help\", argv[argLoop]) == 0) || (strcmp(\"-h\", argv[argLoop]) == 0))\n            mode = mode_help;\n\n        // targets\n        else if ((strncmp(\"--targets=\", argv[argLoop], 10) == 0) && (strlen(argv[argLoop]) > 10))\n        {\n            mode = mode_multiple;\n            options->targets = argLoop;\n        }\n\n        // Show certificate (only one)\n        else if (strcmp(\"--show-certificate\", argv[argLoop]) == 0)\n            options->showCertificate = true;\n\n        // Show certificates (all)\n        else if (strcmp(\"--show-certificates\", argv[argLoop]) == 0)\n            options->showCertificates = true;\n\n        // Don't check certificate strength\n        else if (strcmp(\"--no-check-certificate\", argv[argLoop]) == 0)\n            options->checkCertificate = false;\n\n        // Show supported client ciphers\n        else if (strcmp(\"--show-ciphers\", argv[argLoop]) == 0)\n            options->showClientCiphers = true;\n\n        // Show ciphers ids\n        else if (strcmp(\"--show-cipher-ids\", argv[argLoop]) == 0)\n        {\n            options->showCipherIds = true;\n        }\n\n        // Show handshake times\n        else if (strcmp(\"--show-times\", argv[argLoop]) == 0)\n        {\n            options->showTimes = true;\n        }\n\n        // Show client auth trusted CAs\n        else if (strcmp(\"--show-client-cas\", argv[argLoop]) == 0)\n            options->showTrustedCAs = true;\n\n        // Version\n        else if (strcmp(\"--version\", argv[argLoop]) == 0)\n            mode = mode_version;\n\n        // XML Output\n        else if (strncmp(\"--xml=\", argv[argLoop], 6) == 0)\n            xmlArg = argLoop;\n\n        // Verbose\n        else if (strcmp(\"--verbose\", argv[argLoop]) == 0)\n            options->verbose = true;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10002000L\n        // Cipher details (curve names and EDH key lengths)\n        else if (strcmp(\"--no-cipher-details\", argv[argLoop]) == 0)\n            options->cipher_details = false;\n#endif\n\n        // Disable coloured output\n        else if ((strcmp(\"--no-colour\", argv[argLoop]) == 0) || (strcmp(\"--no-color\", argv[argLoop]) == 0))\n        {\n            RESET = \"\";\n            COL_RED = \"\";\n            COL_YELLOW = \"\";\n            COL_BLUE = \"\";\n            COL_GREEN = \"\";\n            COL_PURPLE = \"\";\n            COL_RED_BG = \"\";\n            COL_GREY = \"\";\n        }\n\n        // Client Certificates\n        else if (strncmp(\"--certs=\", argv[argLoop], 8) == 0)\n            options->clientCertsFile = argv[argLoop] +8;\n\n        // Private Key File\n        else if (strncmp(\"--pk=\", argv[argLoop], 5) == 0)\n            options->privateKeyFile = argv[argLoop] +5;\n\n        // Private Key Password\n        else if (strncmp(\"--pkpass=\", argv[argLoop], 9) == 0)\n            options->privateKeyPassword = argv[argLoop] +9;\n\n        // Should we check for supported cipher suites\n        else if (strcmp(\"--no-ciphersuites\", argv[argLoop]) == 0)\n            options->ciphersuites = false;\n\n        // Should we check for TLS Falback SCSV?\n        else if (strcmp(\"--no-fallback\", argv[argLoop]) == 0)\n            options->fallback = false;\n\n        // Should we check for TLS renegotiation?\n        else if (strcmp(\"--no-renegotiation\", argv[argLoop]) == 0)\n            options->reneg = false;\n\n        // Should we check for TLS Compression\n        else if (strcmp(\"--no-compression\", argv[argLoop]) == 0)\n            options->compression = false;\n\n        // Should we check for Heartbleed (CVE-2014-0160)\n        else if (strcmp(\"--no-heartbleed\", argv[argLoop]) == 0)\n            options->heartbleed = false;\n\n        // Should we check for key exchange groups?\n        else if (strcmp(\"--no-groups\", argv[argLoop]) == 0)\n            options->groups = false;\n\n        // Should we check for signature algorithms?\n        else if (strcmp(\"--show-sigs\", argv[argLoop]) == 0)\n            options->signature_algorithms = true;\n\n        // Show IANA/RFC cipher names in output\n        else if (strcmp(\"--iana-names\", argv[argLoop]) == 0)\n            options->ianaNames = true;\n\n        // StartTLS... FTP\n        else if (strcmp(\"--starttls-ftp\", argv[argLoop]) == 0)\n            options->starttls_ftp = true;\n\n        // StartTLS... IMAP\n        else if (strcmp(\"--starttls-imap\", argv[argLoop]) == 0)\n            options->starttls_imap = true;\n\n        else if (strcmp(\"--starttls-irc\", argv[argLoop]) == 0)\n            options->starttls_irc = true;\n\n        // StartTLS... LDAP\n        else if (strcmp(\"--starttls-ldap\", argv[argLoop]) == 0)\n            options->starttls_ldap = true;\n\n        // StartTLS... POP3\n        else if (strcmp(\"--starttls-pop3\", argv[argLoop]) == 0)\n            options->starttls_pop3 = true;\n\n        // StartTLS... SMTP\n        else if (strcmp(\"--starttls-smtp\", argv[argLoop]) == 0)\n            options->starttls_smtp = true;\n\n        // StartTLS... MYSQL\n        else if (strcmp(\"--starttls-mysql\", argv[argLoop]) == 0)\n            options->starttls_mysql = true;\n\n        // StartTLS... XMPP\n        else if (strcmp(\"--starttls-xmpp\", argv[argLoop]) == 0)\n            options->starttls_xmpp = true;\n\n        // StartTLS... PostgreSQL\n        else if (strcmp(\"--starttls-psql\", argv[argLoop]) == 0)\n            options->starttls_psql = true;\n\n        // SSL v2 only...\n        else if (strcmp(\"--ssl2\", argv[argLoop]) == 0)\n            options->sslVersion = ssl_v2;\n\n        // SSL v3 only...\n        else if (strcmp(\"--ssl3\", argv[argLoop]) == 0)\n            options->sslVersion = ssl_v3;\n\n        // TLS v1 only...\n        else if (strcmp(\"--tls10\", argv[argLoop]) == 0)\n            options->sslVersion = tls_v10;\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n        // TLS v11 only...\n        else if (strcmp(\"--tls11\", argv[argLoop]) == 0)\n            options->sslVersion = tls_v11;\n\n        // TLS v12 only...\n        else if (strcmp(\"--tls12\", argv[argLoop]) == 0)\n            options->sslVersion = tls_v12;\n        // TLS v13 only...\n        else if (strcmp(\"--tls13\", argv[argLoop]) == 0)\n            options->sslVersion = tls_v13;\n#endif\n        // TLS (all versions)...\n        else if (strcmp(\"--tlsall\", argv[argLoop]) == 0)\n            options->sslVersion = tls_all;\n\n        // Use a server-to-server XMPP handshake\n        else if (strcmp(\"--xmpp-server\", argv[argLoop]) == 0)\n            options->xmpp_server = true;\n\n        // SSL Bugs...\n        else if (strcmp(\"--bugs\", argv[argLoop]) == 0)\n            options->sslbugs = 1;\n\n        // Socket Timeout (both send and receive)\n        else if (strncmp(\"--timeout=\", argv[argLoop], 10) == 0)\n            options->timeout.tv_sec = atoi(argv[argLoop] + 10);\n\n        // Connect Timeout\n        else if (strncmp(\"--connect-timeout=\", argv[argLoop], 18) == 0)\n            options->connect_timeout = atoi(argv[argLoop] + 18);\n\n        // Sleep between requests (ms)\n        else if (strncmp(\"--sleep=\", argv[argLoop], 8) == 0)\n        {\n            msec = atoi(argv[argLoop] + 8);\n            if (msec >= 0) {\n                options->sleep = msec;\n            }\n        }\n\n        // RDP Preamble...\n        else if (strcmp(\"--rdp\", argv[argLoop]) == 0)\n            options->rdp = 1;\n\n        // IPv4 only\n        else if ((strcmp(\"--ipv4\", argv[argLoop]) == 0) || (strcmp(\"-4\", argv[argLoop]) == 0))\n            options->ipv6 = false;\n\n        // IPv6 only\n        else if ((strcmp(\"--ipv6\", argv[argLoop]) == 0) || (strcmp(\"-6\", argv[argLoop]) == 0))\n            options->ipv4 = false;\n\n        // Check OCSP response\n        else if (strcmp(\"--ocsp\", argv[argLoop]) == 0)\n            options->ocspStatus = true;\n\n        // SNI name\n        else if (strncmp(\"--sni-name=\", argv[argLoop], 11) == 0)\n        {\n            strncpy(options->sniname, argv[argLoop]+11, strlen(argv[argLoop])-11);\n            options->sni_set = 1;\n        }\n\n\n        // Host (maybe port too)...\n        else if (argLoop + 1 == argc)\n        {\n            mode = mode_single;\n\n            // Get host...\n            // IPv6 [] address parsing by DinoTools/phibos\n            tempInt = 0;\n            char *hostString = argv[argLoop];\n\n            maxSize = strlen(hostString);\n\n            if (strncmp((char*)hostString, \"https://\", 8) == 0)\n            {\n                // Strip https:// from the start of the hostname\n                memmove(hostString, hostString + 8, (maxSize - 8));\n                memset(hostString + (maxSize - 8), 0, 8);\n                maxSize = strlen(hostString);\n            }\n\n            int squareBrackets = false;\n            if (hostString[0] == '[')\n            {\n                squareBrackets = true;\n                // skip the square bracket\n                hostString++;\n            }\n\n            while ((hostString[tempInt] != 0) && ((squareBrackets == true && hostString[tempInt] != ']')\n                        || (squareBrackets == false && hostString[tempInt] != ':' && hostString[tempInt] != '/')))\n            {\n                tempInt++;\n            }\n\n            if (squareBrackets == true && hostString[tempInt] == ']')\n            {\n                hostString[tempInt] = 0;\n                if (tempInt < maxSize && (hostString[tempInt + 1] == ':' || hostString[tempInt + 1] == '/'))\n                {\n                    tempInt++;\n                    hostString[tempInt] = 0;\n                }\n            }\n            else\n            {\n                hostString[tempInt] = 0;\n            }\n            strncpy(options->host, hostString, sizeof(options->host) -1);\n\n            // No SNI name passed on command line\n            if (!options->sni_set)\n            {\n                strncpy(options->sniname, options->host, sizeof(options->host) -1);\n            }\n\n            // Get port (if it exists)...\n            tempInt++;\n            if (tempInt < maxSize)\n            {\n                errno = 0;\n                options->port = strtol((hostString + tempInt), NULL, 10);\n                if (options->port < 1 || options->port > 65535)\n                {\n                    printf_error(\"Invalid target specified.\");\n                    exit(1);\n                }\n            }\n            else if (options->port == 0) {\n                if (options->starttls_ftp)\n                    options->port = 21;\n                else if (options->starttls_imap)\n                    options->port = 143;\n                else if (options->starttls_irc)\n                    options->port = 6667;\n                else if (options->starttls_ldap)\n                    options->port = 389;\n                else if (options->starttls_pop3)\n                    options->port = 110;\n                else if (options->starttls_smtp)\n                    options->port = 25;\n                else if (options->starttls_mysql)\n                    options->port = 3306;\n                else if (options->starttls_xmpp)\n                    options->port = 5222;\n                else if (options->starttls_psql)\n                    options->port = 5432;\n                else if (options->rdp)\n                    options->port = 3389;\n                else\n                    options->port = 443;\n            }\n        }\n\n        // Not too sure what the user is doing...\n        else\n            mode = mode_help;\n    }\n\n    // Open XML file output...\n    if ((xmlArg > 0) && (mode != mode_help))\n    {\n        if (strcmp(argv[xmlArg] + 6, \"-\") == 0)\n        {\n            options->xmlOutput = stdout;\n            xml_to_stdout = 1;\n        }\n        else\n        {\n            options->xmlOutput = fopen(argv[xmlArg] + 6, \"w\");\n            if (options->xmlOutput == NULL)\n            {\n                printf_error(\"Could not open XML output file %s.\", argv[xmlArg] + 6);\n                exit(0);\n            }\n        }\n\n        // Output file header...\n        fprintf(options->xmlOutput, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<document title=\\\"SSLScan Results\\\" version=\\\"%s\\\" web=\\\"http://github.com/rbsec/sslscan\\\">\\n\", VERSION);\n    }\n\n    // Build the list of ciphers missing from OpenSSL.\n    findMissingCiphers();\n\n    switch (mode)\n    {\n        case mode_version:\n            printf(\"%s\\t\\t%s\\n\\t\\t%s\\n%s\", COL_BLUE, VERSION,\n                    SSLeay_version(SSLEAY_VERSION), RESET);\n#if OPENSSL_VERSION_NUMBER < 0x10001000L\n            printf(\"\\t\\t%sOpenSSL version does not support TLSv1.1%s\\n\", COL_RED, RESET);\n            printf(\"\\t\\t%sTLSv1.1 ciphers will not be detected%s\\n\", COL_RED, RESET);\n            printf(\"\\t\\t%sOpenSSL version does not support TLSv1.2%s\\n\", COL_RED, RESET);\n            printf(\"\\t\\t%sTLSv1.2 ciphers will not be detected%s\\n\", COL_RED, RESET);\n#endif\n            break;\n\n        case mode_help:\n            // Program version banner...\n            printf(\"%s%s%s\\n\", COL_BLUE, program_banner, RESET);\n            printf(\"%s\\t\\t%s\\n\\t\\t%s\\n%s\\n\\n\", COL_BLUE, VERSION,\n                    SSLeay_version(SSLEAY_VERSION), RESET);\n            printf(\"%sCommand:%s\\n\", COL_BLUE, RESET);\n            printf(\"  %s%s [options] [host:port | host]%s\\n\\n\", COL_GREEN, argv[0], RESET);\n            printf(\"%sOptions:%s\\n\", COL_BLUE, RESET);\n            printf(\"  %s--targets=<file>%s     A file containing a list of hosts to check.\\n\", COL_GREEN, RESET);\n            printf(\"                       Hosts can  be supplied  with ports (host:port)\\n\");\n            printf(\"  %s--sni-name=<name>%s    Hostname for SNI\\n\", COL_GREEN, RESET);\n            printf(\"  %s--ipv4, -4%s           Only use IPv4\\n\", COL_GREEN, RESET);\n            printf(\"  %s--ipv6, -6%s           Only use IPv6\\n\", COL_GREEN, RESET);\n            printf(\"\\n\");\n            printf(\"  %s--show-certificate%s   Show full certificate information\\n\", COL_GREEN, RESET);\n            printf(\"  %s--show-certificates%s  Show chain full certificates information\\n\", COL_GREEN, RESET);\n            printf(\"  %s--show-client-cas%s    Show trusted CAs for TLS client auth\\n\", COL_GREEN, RESET);\n            printf(\"  %s--no-check-certificate%s  Don't warn about weak certificate algorithm or keys\\n\", COL_GREEN, RESET);\n            printf(\"  %s--ocsp%s               Request OCSP response from server\\n\", COL_GREEN, RESET);\n            printf(\"  %s--pk=<file>%s          A file containing the private key or a PKCS#12 file\\n\", COL_GREEN, RESET);\n            printf(\"                       containing a private key/certificate pair\\n\");\n            printf(\"  %s--pkpass=<password>%s  The password for the private  key or PKCS#12 file\\n\", COL_GREEN, RESET);\n            printf(\"  %s--certs=<file>%s       A file containing PEM/ASN1 formatted client certificates\\n\", COL_GREEN, RESET);\n            printf(\"\\n\");\n            printf(\"  %s--ssl2%s               Only check if SSLv2 is enabled\\n\", COL_GREEN, RESET);\n            printf(\"  %s--ssl3%s               Only check if SSLv3 is enabled\\n\", COL_GREEN, RESET);\n            printf(\"  %s--tls10%s              Only check TLSv1.0 ciphers\\n\", COL_GREEN, RESET);\n#if OPENSSL_VERSION_NUMBER >= 0x10001000L\n            printf(\"  %s--tls11%s              Only check TLSv1.1 ciphers\\n\", COL_GREEN, RESET);\n            printf(\"  %s--tls12%s              Only check TLSv1.2 ciphers\\n\", COL_GREEN, RESET);\n            printf(\"  %s--tls13%s              Only check TLSv1.3 ciphers\\n\", COL_GREEN, RESET);\n#endif\n            printf(\"  %s--tlsall%s             Only check TLS ciphers (all versions)\\n\", COL_GREEN, RESET);\n            printf(\"  %s--show-ciphers%s       Show supported client ciphers\\n\", COL_GREEN, RESET);\n            printf(\"  %s--show-cipher-ids%s    Show cipher ids\\n\", COL_GREEN, RESET);\n            printf(\"  %s--iana-names%s         Use IANA/RFC cipher names rather than OpenSSL ones\\n\", COL_GREEN, RESET);\n            printf(\"  %s--show-times%s         Show handhake times in milliseconds\\n\", COL_GREEN, RESET);\n            printf(\"\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10002000L\n            printf(\"  %s--no-cipher-details%s  Disable EC curve names and EDH/RSA key lengths output\\n\", COL_GREEN, RESET);\n#endif\n            printf(\"  %s--no-ciphersuites%s    Do not check for supported ciphersuites\\n\", COL_GREEN, RESET);\n            printf(\"  %s--no-compression%s     Do not check for TLS compression (CRIME)\\n\", COL_GREEN, RESET);\n#ifdef SSL_MODE_SEND_FALLBACK_SCSV\n            printf(\"  %s--no-fallback%s        Do not check for TLS Fallback SCSV\\n\", COL_GREEN, RESET);\n#endif\n            printf(\"  %s--no-groups%s          Do not enumerate key exchange groups\\n\", COL_GREEN, RESET);\n            printf(\"  %s--no-heartbleed%s      Do not check for OpenSSL Heartbleed (CVE-2014-0160)\\n\", COL_GREEN, RESET);\n            printf(\"  %s--no-renegotiation%s   Do not check for TLS renegotiation\\n\", COL_GREEN, RESET);\n            printf(\"  %s--show-sigs%s          Enumerate signature algorithms\\n\", COL_GREEN, RESET);\n            printf(\"\\n\");\n            printf(\"  %s--starttls-ftp%s       STARTTLS setup for FTP\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-imap%s      STARTTLS setup for IMAP\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-irc%s       STARTTLS setup for IRC\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-ldap%s      STARTTLS setup for LDAP\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-mysql%s     STARTTLS setup for MYSQL\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-pop3%s      STARTTLS setup for POP3\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-psql%s      STARTTLS setup for PostgreSQL\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-smtp%s      STARTTLS setup for SMTP\\n\", COL_GREEN, RESET);\n            printf(\"  %s--starttls-xmpp%s      STARTTLS setup for XMPP\\n\", COL_GREEN, RESET);\n            printf(\"  %s--xmpp-server%s        Use a server-to-server XMPP handshake\\n\", COL_GREEN, RESET);\n            printf(\"  %s--rdp%s                Send RDP preamble before starting scan\\n\", COL_GREEN, RESET);\n            printf(\"\\n\");\n            printf(\"  %s--bugs%s               Enable SSL implementation bug work-arounds\\n\", COL_GREEN, RESET);\n            printf(\"  %s--no-colour%s          Disable coloured output\\n\", COL_GREEN, RESET);\n            printf(\"  %s--sleep=<msec>%s       Pause between connection request. Default is disabled\\n\", COL_GREEN, RESET);\n            printf(\"  %s--timeout=<sec>%s      Set socket timeout. Default is 3s\\n\", COL_GREEN, RESET);\n            printf(\"  %s--connect-timeout=<sec>%s  Set connect timeout. Default is 75s\\n\", COL_GREEN, RESET);\n            printf(\"  %s--verbose%s            Display verbose output\\n\", COL_GREEN, RESET);\n            printf(\"  %s--version%s            Display the program version\\n\", COL_GREEN, RESET);\n            printf(\"  %s--xml=<file>%s         Output results to an XML file. Use - for STDOUT.\\n\", COL_GREEN, RESET);\n            printf(\"  %s--help%s               Display the help text you are now reading\\n\\n\", COL_GREEN, RESET);\n            printf(\"%sExample:%s\\n\", COL_BLUE, RESET);\n            printf(\"  %s%s 127.0.0.1%s\\n\", COL_GREEN, argv[0], RESET);\n            printf(\"  %s%s [::1]%s\\n\\n\", COL_GREEN, argv[0], RESET);\n            break;\n\n        // Check a single host/port ciphers...\n        case mode_single:\n        case mode_multiple:\n            printf(\"Version: %s%s%s\\n%s\\n%s\\n\", COL_GREEN, VERSION, RESET,\n                    SSLeay_version(SSLEAY_VERSION), RESET);\n#if OPENSSL_VERSION_NUMBER < 0x10001000L\n            printf(\"\\t\\t%sOpenSSL version does not support TLSv1.1%s\\n\", COL_RED, RESET);\n            printf(\"\\t\\t%sTLSv1.1 ciphers will not be detected%s\\n\", COL_RED, RESET);\n            printf(\"\\t\\t%sOpenSSL version does not support TLSv1.2%s\\n\", COL_RED, RESET);\n            printf(\"\\t\\t%sTLSv1.2 ciphers will not be detected%s\\n\", COL_RED, RESET);\n#endif\n\n            //SSLeay_add_all_algorithms();\n            ERR_load_crypto_strings();\n\n            // Do the testing...\n            if (mode == mode_single)\n            {\n                if (testConnection(options))\n                {\n                    testHost(options);\n                }\n            }\n            else\n            {\n                if (fileExists(argv[options->targets] + 10) == true)\n                {\n                    // Open targets file...\n                    targetsFile = fopen(argv[options->targets] + 10, \"r\");\n                    if (targetsFile == NULL)\n                    {\n                        printf_error(\"Could not open targets file %s.\", argv[options->targets] + 10);\n                    }\n                    else\n                    {\n                        readLine(targetsFile, line, sizeof(line));\n                        while (feof(targetsFile) == 0)\n                        {\n                            if (strlen(line) != 0)\n                            {\n                                // Strip https:// from the start of the hostname\n                                if (strncmp(line, \"https://\", 8) == 0)\n                                {\n                                    memmove(line, line + 8, (strlen(line) - 8));\n                                    memset(line + (strlen(line) - 8), 0, 8);\n                                }\n                                // Get host...\n                                tempInt = 0;\n                                while ((line[tempInt] != 0) && (line[tempInt] != ':'))\n                                    tempInt++;\n                                line[tempInt] = 0;\n                                strncpy(options->host, line, sizeof(options->host) -1);\n\n                                if (!options->sni_set)\n                                {\n                                    strncpy(options->sniname, options->host, sizeof(options->host) -1);\n                                }\n\n                                // Get port (if it exists)...\n                                tempInt++;\n                                if (strlen(line + tempInt) > 0)\n                                {\n                                    int port;\n                                    port = atoi(line + tempInt);\n                                    // Invalid port\n                                    if (port == 0)\n                                    {\n                                        printf_error(\"Invalid port specified.\");\n                                        exit(1);\n                                    }\n                                    else\n                                    {\n                                        options->port = port;\n                                    }\n                                }\n                                // Otherwise assume 443\n                                else\n                                {\n                                    options->port = 443;\n                                }\n\n                                // Test the host...\n                                if (testConnection(options))\n                                {\n                                    testHost(options);\n                                }\n                                printf(\"\\n\\n\");\n                            }\n                            readLine(targetsFile, line, sizeof(line));\n                        }\n                    }\n                }\n                else\n                    printf_error(\"Targets file %s does not exist.\", argv[options->targets] + 10);\n            }\n\n            // Free Structures\n            while (options->ciphers != 0)\n            {\n                sslCipherPointer = options->ciphers->next;\n                free(options->ciphers);\n                options->ciphers = sslCipherPointer;\n            }\n            break;\n    }\n\n    // Close XML file, if required...\n    if ((xmlArg > 0) && (mode != mode_help))\n    {\n        fprintf(options->xmlOutput, \"</document>\\n\");\n        fclose(options->xmlOutput);\n    }\n\n    return 0;\n}\n\nint runSSLv2Test(struct sslCheckOptions *options) {\n  int ret = false, s = -1;\n  char sslv2_client_hello[] = {\n    0x80,\n    0x34, /* Length: 52 */\n    0x01, /* Handshake Message Type: Client Hello */\n    0x00, 0x02, /* Version: SSL 2.0 */\n    0x00, 0x1b, /* Cipher Spec Length: 27 */\n    0x00, 0x00, /* Session ID Length: 0 */\n    0x00, 0x10, /* Challenge Length: 16 */\n    0x05, 0x00, 0x80, /* SSL2_IDEA_128_CBC_WITH_MD5 */\n    0x03, 0x00, 0x80, /* SSL2_RC2_128_CBC_WITH_MD5 */\n    0x01, 0x00, 0x80, /* SSL2_RC4_128_WITH_MD5 */\n    0x07, 0x00, 0xc0, /* SSL2_DES_192_EDE3_CBC_WITH_MD5 */\n    0x08, 0x00, 0x80, /* SSL2_RC4_64_WITH_MD5 */\n    0x06, 0x00, 0x40, /* SSL2_DES_64_CBC_WITH_MD5 */\n    0x04, 0x00, 0x80, /* SSL2_RC2_128_CBC_EXPORT40_WITH_MD5 */\n    0x02, 0x00, 0x80, /* SSL2_RC4_128_EXPORT40_WITH_MD5 */\n    0x00, 0x00, 0x00, /* TLS_NULL_WITH_NULL_NULL */\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f /* Challenge */\n  };\n  char response[8] = {0};\n\n  /* Create a socket to the target. */\n  s = tcpConnect(options);\n\n  /* If a connection could not be made, return false. */\n  if (s == 0)\n    return false;\n\n  /* Send the SSLv2 Client Hello packet. */\n  if (send(s, sslv2_client_hello, sizeof(sslv2_client_hello), 0) <= 0) {\n    printf_error(\"send() failed: %s\", strerror(errno));\n    exit(1);\n  }\n\n  /* Read a small amount of the response. */\n  if (recv(s, response, sizeof(response), 0) != sizeof(response))\n    goto done; /* Returns false. */\n\n  /* If the Handshake Message Type is Server Hello (0x04) and the Version is SSL 2.0\n   * (0x00, 0x02), we confirm that this is SSL v2. */\n  if ((response[2] == 0x04) && (response[5] == 0x00) && (response[6] == 0x02))\n    ret = true;\n\n done:\n  close(s);\n  return ret;\n}\n\nint runSSLv3Test(struct sslCheckOptions *options) {\n  int ret = false, s = -1;\n  uint32_t timestamp = 0;\n  unsigned char timestamp_bytes[4] = {0};\n  char sslv3_client_hello_1[] = {\n    0x16, /* Content Type: Handshake (22) */\n    0x03, 0x00, /* Version SSL 3.0 */\n    0x00, 0xe8, /* Length: 232 */\n    0x01, /* Handshake Type: Client Hello */\n    0x00, 0x00, 0xe4, /* Length: 228 */\n    0x03, 0x00, /* Version: SSL 3.0 */\n  };\n\n  char sslv3_client_hello_2[] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, /* Random bytes */\n    0x00, /* Session ID Length */\n    0x00, 0xbc, /* Cipher Suites Length: 188 */\n    0xc0, 0x14, /* TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA */\n    0xc0, 0x0a, /* TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA */\n    0x00, 0x39, /* TLS_DHE_RSA_WITH_AES_256_CBC_SHA */\n    0x00, 0x38, /* TLS_DHE_DSS_WITH_AES_256_CBC_SHA */\n    0x00, 0x37, /* TLS_DH_RSA_WITH_AES_256_CBC_SHA */\n    0x00, 0x36, /* TLS_DH_DSS_WITH_AES_256_CBC_SHA */\n    0x00, 0x88, /* TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA */\n    0x00, 0x87, /* TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA */\n    0x00, 0x86, /* TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA */\n    0x00, 0x85, /* TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA */\n    0xc0, 0x19, /* TLS_ECDH_anon_WITH_AES_256_CBC_SHA */\n    0x00, 0x3a, /* TLS_DH_anon_WITH_AES_256_CBC_SHA */\n    0x00, 0x89, /* TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA */\n    0xc0, 0x0f, /* TLS_ECDH_RSA_WITH_AES_256_CBC_SHA */\n    0xc0, 0x05, /* TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA */\n    0x00, 0x35, /* TLS_RSA_WITH_AES_256_CBC_SHA */\n    0x00, 0x84, /* TLS_RSA_WITH_CAMELLIA_256_CBC_SHA */\n    0x00, 0x95, /* TLS_RSA_PSK_WITH_AES_256_CBC_SHA */\n    0xc0, 0x13, /* TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA */\n    0xc0, 0x09, /* TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA */\n    0x00, 0x33, /* TLS_DHE_RSA_WITH_AES_128_CBC_SHA */\n    0x00, 0x32, /* TLS_DHE_DSS_WITH_AES_128_CBC_SHA */\n    0x00, 0x31, /* TLS_DH_RSA_WITH_AES_128_CBC_SHA */\n    0x00, 0x30, /* TLS_DH_DSS_WITH_AES_128_CBC_SHA */\n    0x00, 0x9a, /* TLS_DHE_RSA_WITH_SEED_CBC_SHA */\n    0x00, 0x99, /* TLS_DHE_DSS_WITH_SEED_CBC_SHA */\n    0x00, 0x98, /* TLS_DH_RSA_WITH_SEED_CBC_SHA */\n    0x00, 0x97, /* TLS_DH_DSS_WITH_SEED_CBC_SHA */\n    0x00, 0x45, /* TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA */\n    0x00, 0x44, /* TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA */\n    0x00, 0x43, /* TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA */\n    0x00, 0x42, /* TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA */\n    0xc0, 0x18, /* TLS_ECDH_anon_WITH_AES_128_CBC_SHA */\n    0x00, 0x34, /* TLS_DH_anon_WITH_AES_128_CBC_SHA */\n    0x00, 0x9b, /* TLS_DH_anon_WITH_SEED_CBC_SHA */\n    0x00, 0x46, /* TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA */\n    0xc0, 0x0e, /* TLS_ECDH_RSA_WITH_AES_128_CBC_SHA */\n    0xc0, 0x04, /* TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA */\n    0x00, 0x2f, /* TLS_RSA_WITH_AES_128_CBC_SHA */\n    0x00, 0x96, /* TLS_RSA_WITH_SEED_CBC_SHA */\n    0x00, 0x41, /* TLS_RSA_WITH_CAMELLIA_128_CBC_SHA */\n    0x00, 0x07, /* TLS_RSA_WITH_IDEA_CBC_SHA */\n    0x00, 0x94, /* TLS_RSA_PSK_WITH_AES_128_CBC_SHA */\n    0xc0, 0x11, /* TLS_ECDHE_RSA_WITH_RC4_128_SHA */\n    0xc0, 0x07, /* TLS_ECDHE_ECDSA_WITH_RC4_128_SHA */\n    0x00, 0x66, /* TLS_DHE_DSS_WITH_RC4_128_SHA */\n    0xc0, 0x16, /* TLS_ECDH_anon_WITH_RC4_128_SHA */\n    0x00, 0x18, /* TLS_DH_anon_WITH_RC4_128_MD5 */\n    0xc0, 0x0c, /* TLS_ECDH_RSA_WITH_RC4_128_SHA */\n    0xc0, 0x02, /* TLS_ECDH_ECDSA_WITH_RC4_128_SHA */\n    0x00, 0x05, /* TLS_RSA_WITH_RC4_128_SHA */\n    0x00, 0x04, /* TLS_RSA_WITH_RC4_128_MD5 */\n    0x00, 0x92, /* TLS_RSA_PSK_WITH_RC4_128_SHA */\n    0xc0, 0x12, /* TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA */\n    0xc0, 0x08, /* TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x16, /* TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x13, /* TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x10, /* TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x0d, /* TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA */\n    0xc0, 0x17, /* TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x1b, /* TLS_DH_anon_WITH_3DES_EDE_CBC_SHA */\n    0xc0, 0x0d, /* TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA */\n    0xc0, 0x03, /* TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x0a, /* TLS_RSA_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x93, /* TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA */\n    0x00, 0x63, /* TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA */\n    0x00, 0x15, /* TLS_DHE_RSA_WITH_DES_CBC_SHA */\n    0x00, 0x12, /* TLS_DHE_DSS_WITH_DES_CBC_SHA */\n    0x00, 0x0f, /* TLS_DH_RSA_WITH_DES_CBC_SHA */\n    0x00, 0x0c, /* TLS_DH_DSS_WITH_DES_CBC_SHA */\n    0x00, 0x1a, /* TLS_DH_anon_WITH_DES_CBC_SHA */\n    0x00, 0x62, /* TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA */\n    0x00, 0x09, /* TLS_RSA_WITH_DES_CBC_SHA */\n    0x00, 0x61, /* TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5 */\n    0x00, 0x65, /* TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA */\n    0x00, 0x64, /* TLS_RSA_EXPORT1024_WITH_RC4_56_SHA */\n    0x00, 0x60, /* TLS_RSA_EXPORT1024_WITH_RC4_56_MD5 */\n    0x00, 0x14, /* TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA */\n    0x00, 0x11, /* TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA */\n    0x00, 0x0e, /* TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA */\n    0x00, 0x0b, /* TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA */\n    0x00, 0x19, /* TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA */\n    0x00, 0x08, /* TLS_RSA_EXPORT_WITH_DES40_CBC_SHA */\n    0x00, 0x06, /* TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 */\n    0x00, 0x17, /* TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 */\n    0x00, 0x03, /* TLS_RSA_EXPORT_WITH_RC4_40_MD5 */\n    0xc0, 0x10, /* TLS_ECDHE_RSA_WITH_NULL_SHA */\n    0xc0, 0x06, /* TLS_ECDHE_ECDSA_WITH_NULL_SHA */\n    0xc0, 0x15, /* TLS_ECDH_anon_WITH_NULL_SHA */\n    0xc0, 0x0b, /* TLS_ECDH_RSA_WITH_NULL_SHA */\n    0xc0, 0x01, /* TLS_ECDH_ECDSA_WITH_NULL_SHA */\n    0x00, 0x02, /* TLS_RSA_WITH_NULL_SHA */\n    0x00, 0x01, /* TLS_RSA_WITH_NULL_MD5 */\n    0x00, 0xff, /* TLS_EMPTY_RENEGOTIATION_INFO_SCSV */\n    0x02, /* Compression Methods Length: 2 */\n    0x01, 0x00, /* DEFLATE, none */\n  };\n  char response[16] = {0};\n\n  /* Create a socket to the target. */\n  s = tcpConnect(options);\n\n  /* If a connection could not be made, return false. */\n  if (s == 0)\n    return false;\n\n  /* Send the SSLv3 Client Hello packet. */\n  if (send(s, sslv3_client_hello_1, sizeof(sslv3_client_hello_1), 0) <= 0) {\n    printf_error(\"send() failed: %s\", strerror(errno));\n    exit(1);\n  }\n\n  timestamp = htonl(time(NULL)); /* Current time stamp. */\n  timestamp_bytes[0] = timestamp & 0xff;\n  timestamp_bytes[1] = (timestamp >> 8) & 0xff;\n  timestamp_bytes[2] = (timestamp >> 16) & 0xff;\n  timestamp_bytes[3] = (timestamp >> 24) & 0xff;\n\n  if (send(s, timestamp_bytes, sizeof(timestamp_bytes), 0) <= 0) {\n    printf_error(\"send() failed: %s\", strerror(errno));\n    exit(1);\n  }\n\n  if (send(s, sslv3_client_hello_2, sizeof(sslv3_client_hello_2), 0) <= 0) {\n    printf_error(\"send() failed: %s\", strerror(errno));\n    exit(1);\n  }\n\n  /* Read a small amount of the response. */\n  if (recv(s, response, sizeof(response), 0) != sizeof(response))\n    goto done; /* Returns false. */\n\n  /* Examine response. */\n  if ((response[0] == 0x16) && /* Content Type is Handshake (22) */\n      (response[1] == 0x03) && (response[2] == 0x00) && /* Version is SSL 3.0 */\n      (response[5] == 0x02) && /* Handshake Type is Server Hello (2) */\n      (response[9] == 0x03) && (response[10] == 0x00)) /* Version is SSL 3.0 (again) */\n    ret = true;\n\n done:\n  close(s);\n  return ret;\n}\n\n/* Compares the list of supported ciphersuites by OpenSSL with the complete list of ciphersuites from IANA.  Marks the matches so they are not re-tested again later. */\nvoid findMissingCiphers() {\n  STACK_OF(SSL_CIPHER) *cipherList = NULL;\n  const SSL_CIPHER *cipher = NULL;\n  unsigned int tls_version = 0;\n  uint32_t id = 0;\n  const SSL_METHOD *sslMethods[] = { TLSv1_client_method(), TLSv1_1_client_method(), TLSv1_2_client_method() };\n  unsigned int tls_versions[] = { V1_0, V1_1, V1_2 };\n\n  /* For each TLS version (not including v1.3)... */\n  for (int m = 0; m < (sizeof(sslMethods) / sizeof(const SSL_METHOD *)); m++) {\n    tls_version = tls_versions[m];\n    SSL_CTX *ctx = new_CTX(sslMethods[m]);\n    SSL_CTX_set_cipher_list(ctx, CIPHERSUITE_LIST_ALL);\n    cipherList = SSL_CTX_get_ciphers(ctx);\n\n    /* Loop through all OpenSSL ciphers... */\n    for (int i = 0; i < sk_SSL_CIPHER_num(cipherList); i++) {\n      cipher = sk_SSL_CIPHER_value(cipherList, i);\n      id = SSL_CIPHER_get_protocol_id(cipher);\n\n      /* Using the cipher ID, find the match in the IANA list. */\n      for (int j = 0; j < (sizeof(missing_ciphersuites) / sizeof(struct missing_ciphersuite)); j++) {\n\tif ((missing_ciphersuites[j].id == id) && (missing_ciphersuites[j].check_tls_versions & tls_version)) {\n\t  /* Turn off the flag for this version of TLS. */\n\t  missing_ciphersuites[j].check_tls_versions &= ~tls_version;\n\t}\n      }\n    }\n\n    FREE_CTX(ctx);\n  }\n}\n\n/* Creates a new byte string of size BS_DEFAULT_NEW_SIZE.  Caller must eventually free it with bs_free().  The caller MUST initialize the pointer to NULL, otherwise the heap will be corrupted. */\nvoid bs_new(bs **b) {\n  bs_new_size(b, BS_DEFAULT_NEW_SIZE);\n}\n\n/* Creates a new byte string with the specified initial size (or BS_DEFAULT_NEW_SIZE if 0).  Caller must eventually free it with bs_free(). The caller MUST initialize the pointer to NULL, otherwise the heap will be corrupted. */\nvoid bs_new_size(bs **b, size_t new_size) {\n  if (b == NULL) {\n    fprintf(stderr, \"Error: bs_new*() given NULL pointer!\\n\");\n    exit(-1);\n  }\n\n  /* If this byte string was already initialized, silently free it, then continue on. */\n  if (*b != NULL)\n    bs_free(b);\n\n  if (new_size == 0)\n    new_size = BS_DEFAULT_NEW_SIZE;\n\n  *b = calloc(1, sizeof(bs));\n  if (*b == NULL) {\n    fprintf(stderr, \"bs_new_size(): failed to allocate new buffer.\\n\");\n    exit(-1);\n  }\n\n  (*b)->buf = calloc(new_size, sizeof(unsigned char));\n  if ((*b)->buf == NULL) {\n    fprintf(stderr, \"bs_new_size(): failed to allocate new buffer.\\n\");\n    exit(-1);\n  }\n\n  (*b)->size = new_size;\n  (*b)->len = 0;\n}\n\n/* De-allocates a byte string.  May be safely called multiple times.  Furthermore, bs_free(NULL) does nothing. */\nvoid bs_free(bs **b) {\n  if ((b == NULL) || (*b == NULL))\n    return;\n\n  free((*b)->buf);\n  (*b)->buf = NULL;\n\n  (*b)->size = 0;\n  (*b)->len = 0;\n  free(*b);\n  *b = NULL;\n}\n\n/* Appends an array of bytes to this byte string.  The byte string is automatically re-sized if necessary. */\n#define OVERFLOW_MESSAGE \"Cannot lengthen buffer without overflowing length!\\n\"\nvoid bs_append_bytes(bs *b, unsigned char *bytes, size_t bytes_len) {\n  size_t new_len = 0, b_len = 0, b_size = 0;\n\n  if ((b == NULL) || (bytes == NULL) || (bytes_len == 0))\n    return;\n\n  b_len = b->len;\n  b_size = b->size;\n  new_len = b_len + bytes_len;\n\n  /* Ensure that the new length does not cause an integer overflow. */\n  if ((new_len < b_len) || (new_len < bytes_len)) {\n    fprintf(stderr, OVERFLOW_MESSAGE);\n    exit(-1);\n  }\n\n  /* If the buffer needs re-sizing... */\n  if (new_len > b_size) {\n    /* Double the size of the buffer until it is larger than what we need right now. */\n    while (new_len > b_size) {\n      /* Ensure we don't overflow the length. */\n      if ((b_len * 2) < b_len) {\n        fprintf(stderr, OVERFLOW_MESSAGE);\n        exit(-1);\n      }\n      b_size = b_size * 2;\n    }\n\n    /* Extend the buffer's size. */\n    b->buf = realloc(b->buf, b_size);\n    if (b->buf == NULL) {\n      fprintf(stderr, \"Failed to resize buffer.\\n\");\n      exit(-1);\n    }\n    b->size = b_size;\n\n    /* Zero out the extended buffer region; leave the existing bytes intact. */\n    memset(b->buf + b_len, 0, b_size - b_len);\n  }\n\n  /* Copy the new bytes into the buffer right after the existing bytes. */\n  memcpy(b->buf + b_len, bytes, bytes_len);\n\n  /* Update the number of used bytes in the buffer. */\n  b->len = new_len;\n}\n\n/* Appends a uint32_t to the byte string. */\nvoid bs_append_uint32_t(bs *b, uint32_t u) {\n  bs_append_bytes(b, (unsigned char *)&u, sizeof(uint32_t));\n}\n\n/* Converts an unsigned short to network-order, then appends it to the byte string. */\nvoid bs_append_ushort(bs *b, unsigned short us) {\n  uint16_t u16 = htons(us);\n  bs_append_bytes(b, (unsigned char *)&u16, sizeof(uint16_t));\n}\n\n/* Appends one byte string (src) to another (dst). */\nvoid bs_append_bs(bs *dst, bs *src) {\n  if (src == NULL)\n    return;\n\n  bs_append_bytes(dst, src->buf, src->len);\n}\n\n/* Returns the number of bytes in this byte string. */\nsize_t bs_get_len(bs *b) {\n  if (b == NULL)\n    return 0;\n\n  return b->len;\n}\n\n/* Returns the number of bytes allocated in the underlying byte string. */\nsize_t bs_get_size(bs *b) {\n  if (b == NULL)\n    return 0;\n\n  return b->size;\n}\n\n/* Gets the bytes of this byte string.  The caller must _never_ free it directly themselves. */\nunsigned char *bs_get_bytes(bs *b) {\n  if (b == NULL)\n    return NULL;\n\n  return b->buf;\n}\n\n/* Gets a single byte from the offset position.  Performs safety checks that the read will not overflow.  Returns 0 if out of bounds.  */\nunsigned char bs_get_byte(bs *b, size_t offset) {\n  if ((b == NULL) || (offset >= b->len))\n    return 0;\n\n  return b->buf[offset];\n}\n\n/* Gets a single byte from the offset position.  Performs safety checks that the read will not overflow. */\nvoid bs_set_byte(bs *b, size_t offset, unsigned char byte) {\n  if ((b == NULL) || (offset >= b->len))\n    return;\n\n  b->buf[offset] = byte;\n}\n\n/* Sets a length field in a TLS packet at the specified offset. */\nvoid bs_set_ushort(bs *b, size_t offset, unsigned short length) {\n  uint16_t u = htons(length);\n\n  bs_set_byte(b, offset, (unsigned char)u);\n  bs_set_byte(b, offset + 1, (unsigned char)(u >> 8));\n}\n\n/* Reads the specified number of bytes from socket s into byte string b.  Returns 0 on success, or errno on error. */\nint bs_read_socket(bs *b, int s, size_t num_bytes) {\n  int ret = -1, n = 0;\n  unsigned int i = 0;\n  size_t old_len = 0, bytes_read = 0;\n\n  if (b == NULL)\n    return -1;\n\n  /* Append num_bytes to the byte string to ensure that the underlying buffer is resized appropriately.  Then reset the length. */\n  old_len = b->len;\n  for (; i < (num_bytes / sizeof(uint32_t)) + 1; i++)\n    bs_append_uint32_t(b, 0);\n\n  b->len = old_len;\n\n  /* Read in num_bytes from the socket and store it in the underlying buffer. */\n  bytes_read = 0;\n  while (bytes_read < num_bytes) {\n    n = recv(s, b->buf + b->len + bytes_read, num_bytes - bytes_read, 0);\n    if (n <= 0) {\n      if ((errno != 0) && (errno != ECONNRESET))\n        ret = errno;\n\n      b->len += bytes_read;\n      goto err;\n    }\n    bytes_read += n;\n  }\n  b->len += bytes_read;\n  ret = 0;\n\nerr:\n  return ret;\n}\n\n\n/* Internal function.  Use  bs_append_x25519_pubkey() and bs_append_x448_pubkey() instead. */\nvoid __bs_append_xstar_pubkey(bs *b, unsigned int gen_x25519) {\n  unsigned char public_key[64] = {0};  /* X25519 requires 32 bytes minimum, and X448 requires 56 bytes minimum. */\n  size_t public_key_len = sizeof(public_key);\n  EVP_PKEY *pkey = NULL;\n  EVP_PKEY_CTX *pctx = NULL;\n\n\n  /* Create an X25519 or X448 key depending on which is requested. */\n  if (gen_x25519)\n    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_X25519, NULL);\n  else\n    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_X448, NULL);\n\n  /* Create the private and public keys, and append the raw public key to the byte string. */\n  EVP_PKEY_keygen_init(pctx);\n  EVP_PKEY_keygen(pctx, &pkey);\n  EVP_PKEY_get_raw_public_key(pkey, public_key, &public_key_len);\n  bs_append_bytes(b, public_key, public_key_len);\n\n  EVP_PKEY_free(pkey);  pkey = NULL;\n  EVP_PKEY_CTX_free(pctx);  pctx = NULL;\n}\n\n\n/* Generates a random x25519 public key and appends it to the byte string. */\nvoid bs_append_x25519_pubkey(bs *b) {\n  __bs_append_xstar_pubkey(b, 1);\n}\n\n\n/* Generates a random x448 public key and appends it to the byte string. */\nvoid bs_append_x448_pubkey(bs *b) {\n  __bs_append_xstar_pubkey(b, 0);\n}\n\n\n/* Returns true if the ServerHello response contains TLSv1.3 in its supported_versions extension. */\nunsigned int checkSupportedVersionsExtensionForTLS13(bs *server_hello) {\n\n  unsigned int handshake_record_len = bs_get_byte(server_hello, 3) << 8 | bs_get_byte(server_hello, 4);\n\n  /* The Server Hello *record* passed into this function can have multiple handshake protocols inside.  We need to find the Server Hello *handshake protocol*, specifically, since that contains the extensions we need to parse. */\n  unsigned int handshake_record_ptr = 5;\n  while (handshake_record_ptr < handshake_record_len) {\n    unsigned int handshake_protocol_type = bs_get_byte(server_hello, handshake_record_ptr);\n    unsigned int handshake_protocol_len = bs_get_byte(server_hello, handshake_record_ptr + 1) << 16 | bs_get_byte(server_hello, handshake_record_ptr + 2) << 8 | bs_get_byte(server_hello, handshake_record_ptr + 3);\n\n    /* We found the Server Hello handshake protocol entry... */\n    if (handshake_protocol_type == 2) {\n\n      /* The session ID field is variable, so we need to find its length first so we can skip over it and get to the extensions section. */\n      unsigned int session_id_len = (unsigned int)bs_get_byte(server_hello, handshake_record_ptr + 5 + 32 + 1);\n\n      /* Get the length of all the extensions. */\n      unsigned int extensions_len_offset = handshake_record_ptr + 5 + 32 + 1 + session_id_len + 4;\n      unsigned int extensions_len = bs_get_byte(server_hello, extensions_len_offset) << 8 | bs_get_byte(server_hello, extensions_len_offset + 1);\n\n      /* Loop through each extension. */\n      unsigned int extensions_base_offset = extensions_len_offset + 2;\n      unsigned int extensions_offset = 0;\n      while (extensions_offset < extensions_len) {\n\n\t/* Get the extension type and length. */\n\tunsigned int extension_type = bs_get_byte(server_hello, extensions_base_offset + extensions_offset) << 8 | bs_get_byte(server_hello, extensions_base_offset + extensions_offset + 1);\n\tunsigned int extension_len = bs_get_byte(server_hello, extensions_base_offset + extensions_offset + 2) << 8 | bs_get_byte(server_hello, extensions_base_offset + extensions_offset + 3);\n\n\t/* The supported_version extension is type 43. */\n\tif (extension_type == 43) {\n\n\t  /* The length of this extension should be divisible by 2, since the TLS versions are each 2 bytes. */\n\t  if ((extension_len % 2) != 0) {\n\t    fprintf(stderr, \"Error in %s: extension length for supported_versions is not even!: %u\\n\", __func__, extension_len);\n\t    return 0;\n\t  }\n\n\t  /* Loop through all the TLS versions in the supported_versions extension.  Each version uses two bytes. */\n\t  for (int i = 0; i < extension_len; i += 2) {\n\t    unsigned int tls_high_byte = (unsigned int)bs_get_byte(server_hello, extensions_base_offset + extensions_offset + 4 + i);\n\t    unsigned int tls_low_byte = (unsigned int)bs_get_byte(server_hello, extensions_base_offset + extensions_offset + 5 + i);\n\n\t    /* If we find TLS version 0x0304 in the supported_versions extension, then the server supports TLSv1.3! */\n\t    if ((tls_high_byte == 3) && (tls_low_byte == 4))\n\t      return 1;\n\t  }\n\t}\n\n\textensions_offset += (4 + extension_len);\n      }\n\n      /* We already found the Server Hello protocol handshake and looked through all the extensions.  If we reached here, then there's no point in continuing. */\n      return 0;\n    }\n\n    handshake_record_ptr += (4 + handshake_protocol_len);\n  }\n\n  return 0;\n}\n\n\n/* Returns true if a specific TLS version is supported by the server. */\nunsigned int checkIfTLSVersionIsSupported(struct sslCheckOptions *options, unsigned int tls_version) {\n  bs *tls_extensions = NULL, *ciphersuite_list = NULL, *client_hello = NULL, *server_hello = NULL;\n  int ret = false, s = -1;\n\n\n  tls_extensions = makeTLSExtensions(options, 1);\n  if (tls_version == TLSv1_3) {\n    /* Extension: supported_groups */\n    bs_append_bytes(tls_extensions, (unsigned char []) {\n      0x00, 0x0a, // Extension: supported_groups (10)\n      0x00, 0x16, // Extension Length (22)\n      0x00, 0x14, // Supported Groups List Length (20)\n      0x00, 0x17, // secp256r1\n      0x00, 0x19, // secp521r1\n      0x00, 0x18, // secp384r1\n      0x00, 0x1d, // X25519\n      0x00, 0x1e, // X448\n      0x01, 0x00, // FFDHE2048\n      0x01, 0x01, // FFDHE3072\n      0x01, 0x02, // FFDHE4096\n      0x01, 0x03, // FFDHE6144\n      0x01, 0x04, // FFDHE8192\n    }, 26);\n\n    /* Add key share for X25519. */\n    tlsExtensionAddDefaultKeyShare(tls_extensions);\n\n    /* Explicitly mark that this is a TLSv1.3 Client Hello. */\n    tlsExtensionAddTLSv1_3(tls_extensions);\n\n    /* Update the length of the extensions. */\n    tlsExtensionUpdateLength(tls_extensions);\n  } else {\n    /* Extension: supported_groups */\n    bs_append_bytes(tls_extensions, (unsigned char []) {\n      0x00, 0x0a, // Extension: supported_groups (10)\n      0x00, 0x1c, // Extension Length (28)\n      0x00, 0x1a, // Supported Groups List Length (26)\n      0x00, 0x17, // secp256r1\n      0x00, 0x19, // secp521r1\n      0x00, 0x1c, // brainpoolP512r1\n      0x00, 0x1b, // brainpoolP384r1\n      0x00, 0x18, // secp384r1\n      0x00, 0x1a, // brainpoolP256r1\n      0x00, 0x16, // secp256k1\n      0x00, 0x0e, // sect571r1\n      0x00, 0x0d, // sect571k1\n      0x00, 0x0b, // sect409k1\n      0x00, 0x0c, // sect409r1\n      0x00, 0x09, // sect283k1\n      0x00, 0x0a, // sect283r1\n    }, 32);\n\n    /* Update the length of the extensions. */\n    tlsExtensionUpdateLength(tls_extensions);\n  }\n\n  ciphersuite_list = makeCiphersuiteListAll(tls_version);\n  client_hello = makeClientHello(options, tls_version, ciphersuite_list, tls_extensions);\n  bs_free(&ciphersuite_list);\n  bs_free(&tls_extensions);\n\n  /* Now connect to the target server. */\n  s = tcpConnect(options);\n  if (s == 0)\n    goto done;\n\n  /* Send the Client Hello message. */\n  if (send(s, bs_get_bytes(client_hello), bs_get_len(client_hello), 0) <= 0) {\n    printf_error(\"send() failed while sending Client Hello: %d (%s)\", errno, strerror(errno));\n    goto done; /* Returns false. */\n  }\n  bs_free(&client_hello);\n\n  server_hello = getServerHello(s);\n\n  /* If we don't receive a proper Server Hello message, then this TLS version is not supported. */\n  if (server_hello == NULL)\n    goto done;\n\n  unsigned int expected_tls_version_low = tls_version + 1;\n  if (tls_version == TLSv1_3)\n    expected_tls_version_low = 3;\n\n  /* Get the server's TLS version and compare it with what we sent. */\n  unsigned int server_tls_version_high = bs_get_byte(server_hello, 9);\n  unsigned int server_tls_version_low = bs_get_byte(server_hello, 10);\n  if ((server_tls_version_high != 3) || (server_tls_version_low != expected_tls_version_low))\n    goto done;\n\n  /* TLSv1.3's ServerHello will be tagged as TLSv1.2 in the header, but will include v1.3 in the supported_versions extension.  Some servers (like Windows Server 2019), when only supporting v1.2, will still respond with a ServerHello to our v1.3 Client Hello.  So to eliminate false positives, we need to check the supported_versions extension and ensure v1.3 is listed there. */\n  if ((tls_version == TLSv1_3) && (!checkSupportedVersionsExtensionForTLS13(server_hello)))\n    goto done;\n\n  /* A valid Server Hello was returned, so this TLS version is supported. */\n  ret = true;\n\n done:\n  CLOSE(s);\n  bs_free(&ciphersuite_list);\n  bs_free(&tls_extensions);\n  bs_free(&client_hello);\n  bs_free(&server_hello);\n  return ret;\n}\n\n/* Given a TLSv1_? constant, return its printable string representation. */\nchar *getPrintableTLSName(unsigned int tls_version) {\n  switch (tls_version) {\n  case TLSv1_0:\n    return \"TLSv1.0\";\n  case TLSv1_1:\n    return \"TLSv1.1\";\n  case TLSv1_2:\n    return \"TLSv1.2\";\n  case TLSv1_3:\n    return \"TLSv1.3\";\n  default:\n    return \"Unknown\";\n  }\n}\n\n/* Returns a byte string of all TLSv1.3 cipher suites.  The caller must eventually call bs_free() on it. */\nbs *makeCiphersuiteListTLS13All() {\n  bs *ciphersuite_list = NULL;\n\n  bs_new_size(&ciphersuite_list, 16);\n  bs_append_bytes(ciphersuite_list, (unsigned char []) {\n    0x13, 0x01, // TLS_AES_128_GCM_SHA256\n    0x13, 0x02, // TLS_AES_256_GCM_SHA384\n    0x13, 0x03, // TLS_CHACHA20_POLY1305_SHA256\n    0x13, 0x04, // TLS_AES_128_CCM_SHA256\n    0x13, 0x05, // TLS_AES_128_CCM_8_SHA256\n  }, 10);\n\n  return ciphersuite_list;\n}\n\n\n/* Returns a byte string with a list of all ciphersuites registered by IANA. */\nbs *makeCiphersuiteListAll(unsigned int tls_version) {\n  bs *ciphersuite_list = NULL;\n\n  /* If its TLSv1.3, return the smaller v1.3-specific list. */\n  if (tls_version == TLSv1_3)\n    return makeCiphersuiteListTLS13All();\n\n  bs_new_size(&ciphersuite_list, 1024);\n\n  for (int i = 0; i < (sizeof(missing_ciphersuites) / sizeof(struct missing_ciphersuite)); i++) {\n    if (!strstr(missing_ciphersuites[i].protocol_name, \"PRIVATE_CIPHER_\"))\n      bs_append_ushort(ciphersuite_list, missing_ciphersuites[i].id);\n  }\n\n  /* Append TLS_EMPTY_RENEGOTIATION_INFO_SCSV (0x00ff), otherwise some servers will reject the connection outright. */\n  bs_append_ushort(ciphersuite_list, 255);\n\n  return ciphersuite_list;\n}\n\n\n/* Returns a byte string with a list of all missing ciphersuites for a given TLS version (TLSv1_? constant) .*/\nbs *makeCiphersuiteListMissing(unsigned int tls_version) {\n  bs *ciphersuite_list = NULL;\n\n  bs_new_size(&ciphersuite_list, 1024);\n\n  if (tls_version == TLSv1_0)\n    tls_version = V1_0;\n  else if (tls_version == TLSv1_1)\n    tls_version = V1_1;\n  else if (tls_version == TLSv1_2)\n    tls_version = V1_2;\n\n  for (int i = 0; i < (sizeof(missing_ciphersuites) / sizeof(struct missing_ciphersuite)); i++) {\n    /* Append only those that OpenSSL does not cover, and those that were not already accepted through a previous run. */\n    if ((missing_ciphersuites[i].check_tls_versions & tls_version) && ((missing_ciphersuites[i].accepted_tls_versions & tls_version) == 0)) {\n      bs_append_ushort(ciphersuite_list, missing_ciphersuites[i].id);\n    }\n  }\n\n  return ciphersuite_list;\n}\n\n/* Marks a ciphersuite as found so that it is not re-tested again. */\nvoid markFoundCiphersuite(unsigned short server_cipher_id, unsigned int tls_version) {\n  if (tls_version == TLSv1_0)\n    tls_version = V1_0;\n  else if (tls_version == TLSv1_1)\n    tls_version = V1_1;\n  else if (tls_version == TLSv1_2)\n    tls_version = V1_2;\n\n  for (int i = 0; i < (sizeof(missing_ciphersuites) / sizeof(struct missing_ciphersuite)); i++) {\n    if (missing_ciphersuites[i].id == server_cipher_id) {\n      missing_ciphersuites[i].accepted_tls_versions |= tls_version;\n      break;\n    }\n  }\n}\n\n/* Resolves an IANA cipher ID to its IANA name.  Sets the cipher_bits argument to the cipher strength (or to -1 if unknown).  Returns \"UNKNOWN_CIPHER if cipher ID is not found. */\nchar *resolveCipherID(unsigned short cipher_id, int *cipher_bits) {\n  for (int i = 0; i < (sizeof(missing_ciphersuites) / sizeof(struct missing_ciphersuite)); i++) {\n    if (missing_ciphersuites[i].id == cipher_id) {\n      *cipher_bits = missing_ciphersuites[i].bits;\n      return missing_ciphersuites[i].protocol_name;\n    }\n  }\n  *cipher_bits = -1;\n  return \"UNKNOWN_CIPHER\";\n}\n\n/* Creates a basic set of TLS extensions, including SNI, ec_point_formats, Session Ticket TLS, and signature_algorithms. */\nbs *makeTLSExtensions(struct sslCheckOptions *options, unsigned int include_signature_algorithms) {\n  bs *tls_extensions = NULL;\n\n  bs_new_size(&tls_extensions, 64);\n\n  /* Add the length of the extensions (to be filled in later). */\n  bs_append_ushort(tls_extensions, 0);\n\n  /* Extension: server name */\n  uint16_t sni_length = strlen(options->sniname);\n  uint16_t sni_list_length = sni_length + 3;\n  uint16_t extension_length = sni_list_length + 2;\n\n  bs_append_ushort(tls_extensions, 0x0000); /* Extension: server_name */\n  bs_append_ushort(tls_extensions, extension_length);\n  bs_append_ushort(tls_extensions, sni_list_length);\n  bs_append_bytes(tls_extensions, (unsigned char []) { 0x00 /* Server Name Type: host_name */ }, 1);\n  bs_append_ushort(tls_extensions, sni_length); /* The length of the hostname. */\n  bs_append_bytes(tls_extensions, (unsigned char *)options->sniname, sni_length); /* The hostname itself. */\n\n  /* Extension: ec_point_formats */\n  bs_append_bytes(tls_extensions, (unsigned char []) {\n    0x00, 0x0b, // Extension: ec_point_formats (11)\n    0x00, 0x04, // Extension Length (4)\n    0x03, // EC Point Formats Length (3)\n    0x00, // Uncompressed\n    0x01, // ansiX962_compressed_prime\n    0x02, // ansiX962_compressed_char2\n  }, 8);\n\n  /* Extension: SessionTicket TLS */\n  bs_append_bytes(tls_extensions, (unsigned char []) {\n    0x00, 0x23, // Extension: SessionTicket TLS (35)\n    0x00, 0x00, // Extension Length (0)\n  }, 4);\n\n  if (include_signature_algorithms) {\n    /* Extension: signature_algorithms */\n    bs_append_bytes(tls_extensions, (unsigned char []) {\n      0x00, 0x0d, // Extension: signature_algorithms (13)\n      0x00, 0x30, // Extension Length (48)\n      0x00, 0x2e, // Signature Hash Algorithms Length (46)\n      0x08, 0x04, // rsa_pss_rsae_sha256\n      0x08, 0x05, // rsa_pss_rsae_sha384\n      0x08, 0x06, // rsa_pss_rsae_sha512\n      0x08, 0x07, // ed25519\n      0x08, 0x08, // ed448\n      0x08, 0x09, // rsa_pss_pss_sha256\n      0x08, 0x0a, // rsa_pss_pss_sha384\n      0x08, 0x0b, // rsa_pss_pss_sha512\n      0x06, 0x01, // rsa_pkcs1_sha512\n      0x06, 0x02, // SHA512 DSA\n      0x06, 0x03, // ecdsa_secp521r1_sha512\n      0x05, 0x01, // rsa_pkcs1_sha384\n      0x05, 0x02, // SHA384 DSA\n      0x05, 0x03, // ecdsa_secp384r1_sha384\n      0x04, 0x01, // rsa_pkcs1_sha256\"\n      0x04, 0x02, // SHA256 DSA\n      0x04, 0x03, // ecdsa_secp256r1_sha256\n      0x03, 0x01, // SHA224 ECDSA\n      0x03, 0x02, // SHA224 DSA\n      0x03, 0x03, // SHA224 ECDSA\n      0x02, 0x01, // rsa_pkcs1_sha1\n      0x02, 0x02, // SHA1 DSA\n      0x02, 0x03, // ecdsa_sha1\n    }, 52);\n  }\n\n  /* Set the extension length. */\n  tlsExtensionUpdateLength(tls_extensions);\n  return tls_extensions;\n}\n\n/* Adds the TLS supported_versions extension, set to TLSv1.3 only. */\nvoid tlsExtensionAddTLSv1_3(bs *tls_extensions) {\n  bs_append_bytes(tls_extensions, (unsigned char []) {\n      0x00, 0x2b, // supported_versions (43)\n      0x00, 0x03, // Length\n      0x02,       // Supported Versions Length\n      0x03, 0x04, // Supported Version: TLS v1.3\n  }, 7);\n  tlsExtensionUpdateLength(tls_extensions);\n}\n\n/* Adds default key_share extension. */\nvoid tlsExtensionAddDefaultKeyShare(bs *tls_extensions) {\n\n  bs_append_bytes(tls_extensions, (unsigned char []) {\n    0x00, 0x33, // key_share (51)\n    0x00, 0x26, // Length (38)\n    0x00, 0x24, // Key Share List Length (36)\n    0x00, 0x1d, // Group ID (X25519)\n    0x00, 0x20, // Key Exchange Length (32)\n  }, 10);\n\n  /* Append a random X25519 public key. */\n  bs_append_x25519_pubkey(tls_extensions);\n\n  /* Update the length of the extensions. */\n  tlsExtensionUpdateLength(tls_extensions);\n}\n\n/* Retrieves a TLS Handshake record, or returns NULL on error. */\nbs *getTLSHandshakeRecord(int s) {\n  bs *tls_record = NULL;\n  bs_new_size(&tls_record, 512);\n\n  /* Read in the first 5 bytes to get the length of the rest of the record. */\n  int err = bs_read_socket(tls_record, s, 5);\n  if (err != 0)\n    goto err;\n\n  /* Ensure that the Content Type is Handshake (22). */\n  if (bs_get_byte(tls_record, 0) != 0x16)\n    goto err;\n\n  /* Get the length of the record. */\n  unsigned short packet_len = (bs_get_byte(tls_record, 3) << 8) | bs_get_byte(tls_record, 4);\n\n  /* Read in the rest of the record. */\n  err = bs_read_socket(tls_record, s, packet_len);\n  if (err != 0)\n    goto err;\n\n  return tls_record;\n\n err:\n  bs_free(&tls_record);\n  return NULL;\n}\n\n/* Update the length of the TLS extensions. */\nvoid tlsExtensionUpdateLength(bs *tls_extensions) {\n  bs_set_ushort(tls_extensions, 0, bs_get_len(tls_extensions) - 2);\n}\n\n/* From socket s, reads a ServerHello from the network.  Returns a byte string on success (which the caller must bs_free()), or NULL on failure. */\nbs *getServerHello(int s) {\n  bs *server_hello = getTLSHandshakeRecord(s);\n\n  if (server_hello == NULL)\n    goto err;\n\n  /* Ensure that the Handshake Type is Server Hello (2). */\n  if (bs_get_byte(server_hello, 5) != 0x02)\n    goto err;\n\n  return server_hello;\n\n err:\n  bs_free(&server_hello);\n  return NULL;\n}\n\n/* Returns a byte string (which the caller must later bs_free()) containing a TLS Client Hello message.  The 'tls_version' must be one of the TLSv1_? constants.  The specified ciphersuite list and TLS extensions will be included.  */\nbs *makeClientHello(struct sslCheckOptions *options, unsigned int tls_version, bs *ciphersuite_list, bs *tls_extensions) {\n  bs *client_hello = NULL;\n  unsigned int tls_record_version_low_byte = 1, tls_handshake_version_low_byte = 1;\n  time_t time_now = time(NULL);\n\n\n  /* For TLSv1.0, 1.1, and 1.2, the TLS Record version and Handshake version are the same (and what they should be).  For TLSv1.3, the TLS Record claims to be TLSv1.0 and the Handshake claims to be TLSv1.2; this is for compatibility of buggy middleware that most implementations follow. */\n  if (tls_version < TLSv1_3) {\n    tls_record_version_low_byte += tls_version;\n    tls_handshake_version_low_byte += tls_version;\n  } else {\n    tls_record_version_low_byte = 1;\n    tls_handshake_version_low_byte = 3;\n  }\n\n  /* Allocate byte string for the Client Hello and TLS extensions. */\n  bs_new_size(&client_hello, 1024);\n\n  /* Build the TLSv1 Record with the ClientHello message. */\n  bs_append_bytes(client_hello, (unsigned char []) {\n    0x16,       // Content Type: Handshake (22)\n    0x03, (unsigned char)tls_record_version_low_byte, // Version: TLS 1.x\n    0x00, 0x00, // Length (to be filled in later)\n    0x01,       // Handshake Type: Client Hello\n    0x00, 0x00, 0x00, // Length (to be filled in later)\n    0x03, (unsigned char)tls_handshake_version_low_byte, // Version: TLS 1.x\n  }, 11);\n\n  /* \"Random\" 32 bytes. */\n  uint32_t rand = htonl(time_now);\n  bs_append_uint32_t(client_hello, rand); /* The first 4 bytes is the timestamp. */\n\n  for (int i = 1; i < 8; i++) {\n    rand = rand + (time_now ^ (uint32_t)((~(i + 0) << 24) | (~(i + 1) << 16) | (~(i + 2) << 8) | (~(i + 3) << 0)));\n    bs_append_uint32_t(client_hello, rand);\n  }\n\n  /* Session ID Length: 32 */\n  bs_append_bytes(client_hello, (unsigned char []) { 32 }, 1);\n\n  /* A \"random\" 32-byte session ID. */\n  for (int i = 0; i < 8; i++) {\n    rand += (time_now ^ (uint32_t)((~(i + 0) << 24) | (~(i + 1) << 16) | (~(i + 2) << 8) | (~(i + 3) << 0)));\n    bs_append_uint32_t(client_hello, rand);\n  }\n\n  /* Add the length (in bytes) of the ciphersuites list to the Client Hello. */\n  bs_append_ushort(client_hello, bs_get_len(ciphersuite_list));\n\n  /* Add the ciphersuite list. */\n  bs_append_bs(client_hello, ciphersuite_list);\n\n  /* Add the compression options. */\n  bs_append_bytes(client_hello, (unsigned char []) {\n    0x01, // Compression Methods Length (1)\n    0x00  // Compression Method: null (0)\n  }, 2);\n\n  /* Add the extensions to the Client Hello. */\n  bs_append_bs(client_hello, tls_extensions);\n\n  /* Set the length of the Client Hello. */\n  bs_set_byte(client_hello, 6, 0);\n  bs_set_ushort(client_hello, 7, bs_get_len(client_hello) - 9);\n\n  /* Set the length of the Record Layer. */\n  bs_set_ushort(client_hello, 3, bs_get_len(client_hello) - 5);\n  return client_hello;\n}\n\n/* Checks all ciphersuites that OpenSSL does not support.  When version is 0, TLSv1.0 is tested.  When set to 1, TLSv1.1 is tested.  When set to 2, TLSv1.2 is tested. */\nint testMissingCiphers(struct sslCheckOptions *options, unsigned int tls_version) {\n  int ret = false, s = -1, valid_cipher_id = false;\n  unsigned int tls_version_low_byte = 1;\n  char *tls_printable_name = getPrintableTLSName(tls_version);\n  bs *client_hello = NULL, *server_hello = NULL, *ciphersuite_list = NULL, *tls_extensions = NULL;\n\n\n  tls_version_low_byte += tls_version;\n\n  /* Continue until a Server Hello isn't received. */\n  while (1) {\n    int cipher_bits = -1;\n    char *cipher_name = NULL;\n    struct timeval tval_start = {0}, tval_end = {0}, tval_elapsed = {0};\n\n\n    gettimeofday(&tval_start, NULL);\n\n    tls_extensions = makeTLSExtensions(options, 1);\n\n    /* Extension: supported_groups */\n    bs_append_bytes(tls_extensions, (unsigned char []) {\n      0x00, 0x0a, // Extension: supported_groups (10)\n      0x00, 0x1c, // Extension Length (28)\n      0x00, 0x1a, // Supported Groups List Length (26)\n      0x00, 0x17, // secp256r1\n      0x00, 0x19, // secp521r1\n      0x00, 0x1c, // brainpoolP512r1\n      0x00, 0x1b, // brainpoolP384r1\n      0x00, 0x18, // secp384r1\n      0x00, 0x1a, // brainpoolP256r1\n      0x00, 0x16, // secp256k1\n      0x00, 0x0e, // sect571r1\n      0x00, 0x0d, // sect571k1\n      0x00, 0x0b, // sect409k1\n      0x00, 0x0c, // sect409r1\n      0x00, 0x09, // sect283k1\n      0x00, 0x0a, // sect283r1\n    }, 32);\n\n    tlsExtensionUpdateLength(tls_extensions);\n\n    /* Construct the list of all ciphersuites not implemented by OpenSSL. */\n    ciphersuite_list = makeCiphersuiteListMissing(tls_version);\n\n    client_hello = makeClientHello(options, tls_version, ciphersuite_list, tls_extensions);\n    bs_free(&tls_extensions);\n\n    /* Now connect to the target server. */\n    s = tcpConnect(options);\n    if (s == 0)\n      goto done;\n\n    /* Send the Client Hello message. */\n    if (send(s, bs_get_bytes(client_hello), bs_get_len(client_hello), 0) <= 0) {\n      printf_error(\"send() failed while sending Client Hello: %d (%s)\", errno, strerror(errno));\n      goto done; /* Returns false. */\n    }\n    bs_free(&client_hello);\n\n    server_hello = getServerHello(s);\n\n    /* If we don't receive a proper Server Hello message, or its too short, abort.  We need to reach at least the session ID field (offset 44). */\n    if ((server_hello == NULL) || (bs_get_len(server_hello) < 44))\n      goto done;\n\n    /* Close the socket, since we're done reading. */\n    CLOSE(s);\n\n    /* Check that the TLS version returned is what we sent earlier. */\n    if ((bs_get_byte(server_hello, 1) != 0x03) || (bs_get_byte(server_hello, 2) != (unsigned char)tls_version_low_byte))\n      goto done;\n\n    /* At this point, the test is considered a success, even if the server rejects our Client Hello. */\n    ret = true;\n\n    /* Get the length of the session ID.  We must jump over this to reach the ciphersuite selected by the server. */\n    unsigned int session_id_len = bs_get_byte(server_hello, 43);\n\n    /* Its impossible for one byte to overflow an unsigned int (on any modern hardware), but still... */\n    if ((session_id_len + 43 + 2 + 1) < session_id_len) {\n      fprintf(stderr, \"Error: potential integer overflow averted (%d).\\n\", session_id_len);\n      exit(-1);\n    }\n\n    /* Check that the session ID length wouldn't put us past our buffer boundary. */\n    if ((session_id_len + 43 + 2 + 1) > bs_get_len(server_hello)) {\n      fprintf(stderr, \"Error: size of server_hello (%\"SIZE_T_FMT\") is not large enough to reach cipher suite (%u).\\n\", sizeof(server_hello), session_id_len + 43 + 2);\n      exit(-1);\n    }\n\n    /* Extract the cipher ID. */\n    unsigned char cipher_id_byte1 = bs_get_byte(server_hello, session_id_len + 43 + 1);\n    unsigned char cipher_id_byte2 = bs_get_byte(server_hello, session_id_len + 43 + 2);\n    unsigned short cipher_id = (cipher_id_byte1 << 8) | cipher_id_byte2;\n\n    bs_free(&server_hello);\n\n    /* Check that the server returned a cipher ID that we requested.  Some servers\n     * will return a cipher ID that we didn't request when our ciphersuite list\n     * doesn't match anything (this likely violates the spec, but real servers in the\n     * wild do this sometimes, so we have to handle it).  When this happens, we\n     * conclude that the server does not accept any of the ciphers, so we're done. */\n    valid_cipher_id = false;\n    for (int i = 0; i < (bs_get_len(ciphersuite_list) / 2) && (valid_cipher_id == false); i++) {\n      if ((bs_get_byte(ciphersuite_list, i * 2) == cipher_id_byte1) &&\n          (bs_get_byte(ciphersuite_list, (i * 2) + 1) == cipher_id_byte2))\n        valid_cipher_id = true;\n    }\n\n    if (valid_cipher_id == false)\n      goto done;\n\n    bs_free(&ciphersuite_list);\n\n    /* Mark this cipher ID as supported by the server, so when we loop again, the next ciphersuite list doesn't include it. */\n    markFoundCiphersuite(cipher_id, tls_version);\n\n    /* Get the IANA name and cipher bit strength (maybe -1 when unknown). */\n    cipher_name = resolveCipherID(cipher_id, &cipher_bits);\n\n    /* Get the number of milliseconds that have elapsed. */\n    gettimeofday(&tval_end, NULL);\n    timersub(&tval_end, &tval_start, &tval_elapsed);\n    unsigned int milliseconds_elapsed = tval_elapsed.tv_sec * 1000 + (int)tval_elapsed.tv_usec / 1000;\n\n    /* Output the cipher information. */\n    outputCipher(options, NULL, tls_printable_name, cipher_id, cipher_name, cipher_bits, 1, milliseconds_elapsed);\n  }\n\n done:\n  CLOSE(s);\n  bs_free(&ciphersuite_list);\n  bs_free(&tls_extensions);\n  bs_free(&client_hello);\n  bs_free(&server_hello);\n  return ret;\n}\n\n/* Enumerates all the group key exchanges supported by the server.  Tests the highest supported protocol between TLSv1.0 and v1.2, along with TLSv1.3 (if enabled). */\nint testSupportedGroups(struct sslCheckOptions *options) {\n  int ret = true, s = -1;\n  unsigned int printed_header = 0;\n  int test_versions[2] = {-1, -1};\n  bs *client_hello = NULL, *ciphersuite_list = NULL, *tls_extensions = NULL, *tls_record = NULL, *key_exchange = NULL;\n\n  struct group_key_exchange {\n    uint16_t group_id;\n    char *group_name;\n    unsigned int group_bit_strength; /* The bit strength equivalent of this group. */\n    char *color;\n    int nid;               /* NID for group, or -1 for X25519/X448. */\n    unsigned int nid_type; /* One of the NID_TYPE_* flags. */\n    uint16_t key_exchange_len;\n  };\n\n\n  /* Auto-generated by ./tools/iana_tls_supported_groups_parser.py on December 24, 2019. */\n#define COL_PLAIN \"\"\n#define NID_TYPE_UNUSED 0\n#define NID_TYPE_ECDHE 1 /* For ECDHE curves (sec*, P-256/384-521) */\n#define NID_TYPE_DHE 2   /* For ffdhe* */\n#define NID_TYPE_X25519 3\n#define NID_TYPE_X448 4\n  /* Bit strength of DHE 2048 and 3072-bit moduli is taken directly from NIST SP 800-57 pt.1, rev4., pg. 53; DHE 4096, 6144, and 8192 are estimated using that document. */\n  struct group_key_exchange group_key_exchanges[] = {\n    {0x0001, \"sect163k1\", 81, COL_RED, NID_sect163k1, NID_TYPE_ECDHE, 0},\n    {0x0002, \"sect163r1\", 81, COL_RED, NID_sect163r1, NID_TYPE_ECDHE, 0},\n    {0x0003, \"sect163r2\", 81, COL_RED, NID_sect163r2, NID_TYPE_ECDHE, 0},\n    {0x0004, \"sect193r1\", 96, COL_RED, NID_sect193r1, NID_TYPE_ECDHE, 0},\n    {0x0005, \"sect193r2\", 96, COL_RED, NID_sect193r2, NID_TYPE_ECDHE, 0},\n    {0x0006, \"sect233k1\", 116, COL_PLAIN, NID_sect233k1, NID_TYPE_ECDHE, 0},\n    {0x0007, \"sect233r1\", 116, COL_PLAIN, NID_sect233r1, NID_TYPE_ECDHE, 0},\n    {0x0008, \"sect239k1\", 119, COL_PLAIN, NID_sect239k1, NID_TYPE_ECDHE, 0},\n    {0x0009, \"sect283k1\", 141, COL_PLAIN, NID_sect283k1, NID_TYPE_ECDHE, 0},\n    {0x000a, \"sect283r1\", 141, COL_PLAIN, NID_sect283r1, NID_TYPE_ECDHE, 0},\n    {0x000b, \"sect409k1\", 204, COL_PLAIN, NID_sect409k1, NID_TYPE_ECDHE, 0},\n    {0x000c, \"sect409r1\", 204, COL_PLAIN, NID_sect409r1, NID_TYPE_ECDHE, 0},\n    {0x000d, \"sect571k1\", 285, COL_PLAIN, NID_sect571k1, NID_TYPE_ECDHE, 0},\n    {0x000e, \"sect571r1\", 285, COL_PLAIN, NID_sect571r1, NID_TYPE_ECDHE, 0},\n    {0x000f, \"secp160k1\", 80, COL_RED, NID_secp160k1, NID_TYPE_ECDHE, 0},\n    {0x0010, \"secp160r1\", 80, COL_RED, NID_secp160r1, NID_TYPE_ECDHE, 0},\n    {0x0011, \"secp160r2\", 80, COL_RED, NID_secp160r2, NID_TYPE_ECDHE, 0},\n    {0x0012, \"secp192k1\", 96, COL_RED, NID_secp192k1, NID_TYPE_ECDHE, 0},\n    {0x0013, \"secp192r1\", 96, COL_RED, NID_X9_62_prime192v1, NID_TYPE_ECDHE, 0},\n    {0x0014, \"secp224k1\", 112, COL_PLAIN, NID_secp224k1, NID_TYPE_ECDHE, 0},\n    {0x0015, \"secp224r1\", 112, COL_PLAIN, NID_secp224r1, NID_TYPE_ECDHE, 0},\n    {0x0016, \"secp256k1\", 128, COL_GREEN, NID_secp256k1, NID_TYPE_ECDHE, 0},\n    {0x0017, \"secp256r1 (NIST P-256)\", 128, COL_PLAIN, NID_X9_62_prime256v1, NID_TYPE_ECDHE, 0},\n    {0x0018, \"secp384r1 (NIST P-384)\", 192, COL_PLAIN, NID_secp384r1, NID_TYPE_ECDHE, 0},\n    {0x0019, \"secp521r1 (NIST P-521)\", 260, COL_PLAIN, NID_secp521r1, NID_TYPE_ECDHE, 0},\n    {0x001a, \"brainpoolP256r1\", 128, COL_PLAIN, NID_brainpoolP256r1, NID_TYPE_ECDHE, 0},\n    {0x001b, \"brainpoolP384r1\", 192, COL_PLAIN, NID_brainpoolP384r1, NID_TYPE_ECDHE, 0},\n    {0x001c, \"brainpoolP512r1\", 256, COL_PLAIN, NID_brainpoolP512r1, NID_TYPE_ECDHE, 0},\n    {0x001d, \"x25519\", 128, COL_GREEN, -1, NID_TYPE_X25519, 32},\n    {0x001e, \"x448\", 224, COL_GREEN, -1, NID_TYPE_X448, 56},\n    {0x0100, \"ffdhe2048\", 112, COL_PLAIN, NID_ffdhe2048, NID_TYPE_DHE, 256},\n    {0x0101, \"ffdhe3072\", 128, COL_PLAIN, NID_ffdhe3072, NID_TYPE_DHE, 384},\n    {0x0102, \"ffdhe4096\", 150, COL_PLAIN, NID_ffdhe4096, NID_TYPE_DHE, 512},\n    {0x0103, \"ffdhe6144\", 175, COL_PLAIN, NID_ffdhe6144, NID_TYPE_DHE, 768},\n    {0x0104, \"ffdhe8192\", 192, COL_PLAIN, NID_ffdhe8192, NID_TYPE_DHE, 1024},\n  };\n\n\n  /* If TLSv1.3 is supported, test it first. */\n  unsigned int index = 0;\n  if (options->tls13_supported) {\n    test_versions[index] = TLSv1_3;\n    index++;\n  }\n\n  /* For TLSv1.2 and below, test the highest protocol version supported. */\n  if (options->tls12_supported)\n    test_versions[index] = TLSv1_2;\n  else if (options->tls11_supported)\n    test_versions[index] = TLSv1_1;\n  else if (options->tls10_supported)\n    test_versions[index] = TLSv1_0;\n\n  /* Loop through the one or two TLS versions to test. */\n  for (index = 0; index < (sizeof(test_versions) / sizeof(int)); index++) {\n    int tls_version = test_versions[index];\n\n    /* If there's only one version to test... */\n    if (tls_version == -1)\n      break;\n\n    if (tls_version == TLSv1_3)\n      ciphersuite_list = makeCiphersuiteListAll(tls_version);\n    else {\n      /* For some reason, with TLSv1.2 (and maybe below), passing all ciphersuites causes false negatives.  So we use a string of bytes sniffed from an OpenSSL client connection. */\n      bs_new(&ciphersuite_list);\n      bs_append_bytes(ciphersuite_list, (unsigned char []) { 0xc0, 0x30, 0xc0, 0x2c, 0xc0, 0x28, 0xc0, 0x24, 0xc0, 0x14, 0xc0, 0x0a, 0x00, 0xa5, 0x00, 0xa3, 0x00, 0xa1, 0x00, 0x9f, 0x00, 0x6b, 0x00, 0x6a, 0x00, 0x69, 0x00, 0x68, 0x00, 0x39, 0x00, 0x38, 0x00, 0x37, 0x00, 0x36, 0x00, 0x88, 0x00, 0x87, 0x00, 0x86, 0x00, 0x85, 0xc0, 0x32, 0xc0, 0x2e, 0xc0, 0x2a, 0xc0, 0x26, 0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x9d, 0x00, 0x3d, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x2f, 0xc0, 0x2b, 0xc0, 0x27, 0xc0, 0x23, 0xc0, 0x13, 0xc0, 0x09, 0x00, 0xa4, 0x00, 0xa2, 0x00, 0xa0, 0x00, 0x9e, 0x00, 0x67, 0x00, 0x40, 0x00, 0x3f, 0x00, 0x3e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x31, 0x00, 0x30, 0x00, 0x9a, 0x00, 0x99, 0x00, 0x98, 0x00, 0x97, 0x00, 0x45, 0x00, 0x44, 0x00, 0x43, 0x00, 0x42, 0xc0, 0x31, 0xc0, 0x2d, 0xc0, 0x29, 0xc0, 0x25, 0xc0, 0x0e, 0xc0, 0x04, 0x00, 0x9c, 0x00, 0x3c, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41, 0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02, 0x00, 0x05, 0x00, 0x04, 0xc0, 0x12, 0xc0, 0x08, 0x00, 0x16, 0x00, 0x13, 0x00, 0x10, 0x00, 0x0d, 0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a, 0x00, 0xff }, 170);\n    }\n\n    /* For each key exchange group... */\n    for (int i = 0; i < (sizeof(group_key_exchanges) / sizeof(struct group_key_exchange)); i++) {\n      uint16_t group_id = group_key_exchanges[i].group_id;\n      char *group_name = group_key_exchanges[i].group_name;\n      char *color = group_key_exchanges[i].color;\n      unsigned int group_bit_strength = group_key_exchanges[i].group_bit_strength;\n      int nid = group_key_exchanges[i].nid;\n      unsigned nid_type = group_key_exchanges[i].nid_type;\n      uint16_t key_exchange_len = group_key_exchanges[i].key_exchange_len;\n\n      /* This will hold the key exchange data that we send to the server. */\n      bs_new_size(&key_exchange, key_exchange_len);\n\n      /* Generate the right type of key exchange data. */\n      if (nid_type == NID_TYPE_X25519)\n\tbs_append_x25519_pubkey(key_exchange);\n      else if (nid_type == NID_TYPE_X448)\n        bs_append_x448_pubkey(key_exchange);\n      else if (nid_type == NID_TYPE_ECDHE) {\n\n        /* Generate the ECDHE key. */\n        EC_KEY *key = EC_KEY_new_by_curve_name(nid);\n        if ((key == NULL) || (EC_KEY_generate_key(key) != 1)) {\n          EC_KEY_free(key); key = NULL;\n          fprintf(stderr, \"Failed to generate ECDHE key for nid %d\\n\", nid);\n          continue;\n        }\n\n        /* Allocate a *new* byte array and put the key into it. */\n        unsigned char *kex_buf = NULL;\n        key_exchange_len = EC_KEY_key2buf(key, POINT_CONVERSION_UNCOMPRESSED, &kex_buf, NULL);\n        if (kex_buf == NULL) {\n          EC_KEY_free(key); key = NULL;\n          fprintf(stderr, \"Failed to obtain ECDHE public key bytes.\\n\");\n          continue;\n        }\n\n        bs_append_bytes(key_exchange, kex_buf, key_exchange_len);\n        OPENSSL_free(kex_buf); kex_buf = NULL;\n        EC_KEY_free(key); key = NULL;\n\n      } else if (nid_type == NID_TYPE_DHE) {\n\n        /* The value (Y) for FFDHE group must be 1 < Y < p - 1 (see RFC7919).  Furthermore, GnuTLS checks that Y ^ q mod p == 1 (see GnuTLS v3.6.11.1, lib/nettle/pk.c:291).  The easiest way to do this seems to be to actually generate real DH public keys. */\n        DH *dh = DH_new_by_nid(nid);\n        if (!DH_generate_key(dh)) {\n          bs_free(&key_exchange);\n          fprintf(stderr, \"Failed to generate DH key for nid %d\\n\", nid);\n          continue;\n        }\n\n        /* Make array to read in DH public key. */\n        unsigned int bytes_len = key_exchange_len;\n        unsigned char *bytes = calloc(bytes_len, sizeof(unsigned char));\n        if (bytes == NULL) {\n          fprintf(stderr, \"Failed to allocate buffer for key.\\n\");\n          exit(-1);\n        }\n\n        /* Export the public key to our array. */\n        const BIGNUM *pub_key = NULL;\n        DH_get0_key(dh, &pub_key, NULL);\n        if (!BN_bn2binpad(pub_key, bytes, bytes_len)) {\n          bs_free(&key_exchange);\n          fprintf(stderr, \"Failed to get DH key for nid %d\\n\", nid);\n          continue;\n        }\n\n        /* Add the bytes to our byte string. */\n        bs_append_bytes(key_exchange, bytes, bytes_len);\n        FREE(bytes);  bytes_len = 0;\n\n      } else {\n        /* Use the provided value, since it must be a specific format. */\n        fprintf(stderr, \"Error: unknown NID_TYPE in struct: %d\\n\", nid_type);\n        exit(-1);\n      }\n\n      /* Make generic TLS extensions (with SNI, accepted EC point formats, etc). */\n      tls_extensions = makeTLSExtensions(options, 1);\n\n      /* Add the supported_versions extension to signify we are using TLS v1.3. */\n      if (tls_version == TLSv1_3)\n        tlsExtensionAddTLSv1_3(tls_extensions);\n\n      /* Add the supported_groups extension.  Only add the one group we are testing for. */\n      bs_append_bytes(tls_extensions, (unsigned char []) {\n        0x00, 0x0a, // Extension Type: supported_groups (10)\n        0x00, 0x04, // Extension Length (4)\n        0x00, 0x02, // Supported Groups List Length (2)\n      }, 6);\n      bs_append_ushort(tls_extensions, group_id);\n\n      /* Only add the key_share extension if we're using TLS v1.3. */\n      if (tls_version == TLSv1_3) {\n        /* Add the key_share extension for the current group type. */\n        bs_append_bytes(tls_extensions, (unsigned char []) { 0x00, 0x33 }, 2); // Extension Type: key_share (51)\n        bs_append_ushort(tls_extensions, bs_get_len(key_exchange) + 6); // Extension Length\n        bs_append_ushort(tls_extensions, bs_get_len(key_exchange) + 4); // Client Key Share Length\n        bs_append_ushort(tls_extensions, group_id); // Group ID.\n        bs_append_ushort(tls_extensions, bs_get_len(key_exchange)); // Key Exchange Length\n        bs_append_bs(tls_extensions, key_exchange); // Key Exchange\n      }\n      bs_free(&key_exchange);\n\n      /* Update the TLS extensions length since we manually added to it. */\n      tlsExtensionUpdateLength(tls_extensions);\n\n      /* Create the Client Hello buffer using the ciphersuite list and TLS extensions. */\n      client_hello = makeClientHello(options, tls_version, ciphersuite_list, tls_extensions);\n\n      /* Free the TLS extensions since we're done with them.  Note: we don't free the ciphersuite_list because we'll need them on the next loop. */\n      bs_free(&tls_extensions);\n\n      CLOSE(s); /* In case the last loop left the socket open. */\n\n      /* Now connect to the target server. */\n      s = tcpConnect(options);\n      if (s == 0) {\n        ret = false;\n        goto done;\n      }\n\n      /* Send the Client Hello message. */\n      if (send(s, bs_get_bytes(client_hello), bs_get_len(client_hello), 0) <= 0) {\n        printf_error(\"send() failed while sending Client Hello: %d (%s)\", errno, strerror(errno));\n        ret = false;\n        goto done;\n      }\n      bs_free(&client_hello);\n\n      tls_record = getServerHello(s);\n\n      /* This group is definitely not supported. */\n      if (tls_record == NULL) {\n        CLOSE(s);\n        continue;\n      }\n\n      /* For TLSv1.2 and below, we need to examine the Server Key Exchange record. */\n      if (tls_version < TLSv1_3) {\n\tunsigned int handshake_type = 0;\n\tunsigned int handshake_type_offset = 5;\n\tuint32_t handshake_len = 0;\n\n\t/* Loop through all the handshake protocols inside this TLS record.  Some implementations only include one (such as OpenSSL), and others include several (such as Windows Server 2022). */\n        while (tls_record != NULL) {\n\n\t  handshake_type = bs_get_byte(tls_record, handshake_type_offset);\n\n\t  /* Handshake type 12 is a Server Key Exchange.  This may have the group information we need, so we can stop searching. */\n\t  if (handshake_type == 12) {\n            break;\n\t  /* Handshake type 14 is a Server Hello Done.  If we reach this before finding a Server Key Exchange, we know the server does not support this group. */\n\t  } else if (handshake_type == 14) {\n            bs_free(&tls_record);\n            CLOSE(s);\n            continue;\n          }\n\n\t  /* The handshake length is strangely only three bytes... */\n\t  handshake_len = bs_get_byte(tls_record, handshake_type_offset + 1) << 16;\n\t  handshake_len |= bs_get_byte(tls_record, handshake_type_offset + 2) << 8;\n\t  handshake_len |= bs_get_byte(tls_record, handshake_type_offset + 3) << 0;\n\n\t  /* If we processed all handshake messages in this TLS record, read the next record. */\n\t  if (tls_record->len < handshake_len + handshake_type_offset) {\n\t    bs_free(&tls_record);\n\t    tls_record = getTLSHandshakeRecord(s);\n\t    handshake_type_offset = 5;\n\t  } else\n\t    handshake_type_offset += (handshake_len + 4);\n\n        }\n\n        /* Error, so skip this group. */\n        if (tls_record == NULL) {\n          bs_free(&tls_record);\n          CLOSE(s);\n          continue;\n        }\n\n        /* If this Server Key Exchange does not have a named_curve (3) field, skip this group. */\n        if (bs_get_byte(tls_record, handshake_type_offset + 4) != 3) {\n          bs_free(&tls_record);\n          CLOSE(s);\n          continue;\n        }\n\n        /* Check that the named_curve result is the group we requested. */\n        uint16_t server_group_id = bs_get_byte(tls_record, handshake_type_offset + 5) << 8 | bs_get_byte(tls_record, handshake_type_offset + 6);\n        if (server_group_id != group_id) {\n          bs_free(&tls_record);\n          CLOSE(s);\n          continue;\n        }\n      }\n\n      bs_free(&tls_record);\n      CLOSE(s);\n\n      if (!printed_header) {\n        printf(\"\\n  %sServer Key Exchange Group(s):%s\\n\", COL_BLUE, RESET);\n        printed_header = 1;\n      }\n\n      char *bits_color = RESET;\n      if (group_bit_strength < 112)\n        bits_color = COL_RED;\n      else\n        bits_color = COL_GREEN;\n\n      char *printable_TLS_name = getPrintableTLSName(tls_version);\n      printf(\"%s  %s%d%s bits  %s%s%s\\n\", printable_TLS_name, bits_color, group_bit_strength, RESET, color, group_name, RESET);\n      printf_xml(\"  <group sslversion=\\\"%s\\\" bits=\\\"%d\\\" name=\\\"%s\\\" id=\\\"0x%04x\\\" />\\n\", printable_TLS_name, group_bit_strength, group_name, group_id);\n    }\n  }\n\n done:\n  CLOSE(s);\n  bs_free(&ciphersuite_list);\n  bs_free(&tls_extensions);\n  bs_free(&client_hello);\n  bs_free(&tls_record);\n  return ret;\n}\n\n/* Enumerates all the signature algorithms supported by the server. */\nint testSignatureAlgorithms(struct sslCheckOptions *options) {\n\n  struct signature_algorithm {\n    uint16_t sig_id;\n    char *sig_name;\n    char *color;\n  };\n\n#define COL_PLAIN \"\"\n#define BOGUS_SIG_ALG_ID 0xfdff /* Last un-assigned ID. */\n  struct signature_algorithm signature_algorithms[] = {\n    {BOGUS_SIG_ALG_ID, \"bogus\", COL_RED}, /* Tests if the server is accepting all. */\n    {0x0001, \"rsa_pkcs1_nohash\", COL_RED},\n    {0x0002, \"dsa_nohash\", COL_RED},\n    {0x0003, \"ecdsa_nohash\", COL_RED},\n    {0x0101, \"rsa_pkcs1_md5\", COL_RED},\n    {0x0102, \"dsa_md5\", COL_RED},\n    {0x0103, \"ecdsa_md5\", COL_RED},\n    {0x0201, \"rsa_pkcs1_sha1\", COL_RED},\n    {0x0202, \"dsa_sha1\", COL_RED},\n    {0x0203, \"ecdsa_sha1\", COL_RED},\n    {0x0301, \"rsa_pkcs1_sha224\", COL_YELLOW},\n    {0x0302, \"dsa_sha224\", COL_RED},\n    {0x0303, \"ecdsa_sha224\", COL_YELLOW},\n    {0x0401, \"rsa_pkcs1_sha256\", COL_PLAIN},\n    {0x0402, \"dsa_sha256\", COL_RED},\n    {0x0403, \"ecdsa_secp256r1_sha256\", COL_PLAIN},\n    {0x0501, \"rsa_pkcs1_sha384\", COL_PLAIN},\n    {0x0502, \"dsa_sha384\", COL_RED},\n    {0x0503, \"ecdsa_secp384r1_sha384\", COL_PLAIN},\n    {0x0601, \"rsa_pkcs1_sha512\", COL_PLAIN},\n    {0x0602, \"dsa_sha512\", COL_RED},\n    {0x0603, \"ecdsa_secp521r1_sha512\", COL_PLAIN},\n    {0x0804, \"rsa_pss_rsae_sha256\", COL_PLAIN},\n    {0x0805, \"rsa_pss_rsae_sha384\", COL_PLAIN},\n    {0x0806, \"rsa_pss_rsae_sha512\", COL_PLAIN},\n    {0x0807, \"ed25519\", COL_GREEN},\n    {0x0808, \"ed448\", COL_GREEN},\n    {0x0809, \"rsa_pss_pss_sha256\", COL_PLAIN},\n    {0x080a, \"rsa_pss_pss_sha384\", COL_PLAIN},\n    {0x080b, \"rsa_pss_pss_sha512\", COL_PLAIN},\n  };\n\n  unsigned int printed_header = 0;\n  int ret = true, s = -1;\n  int test_versions[2] = {-1, -1};\n  bs *client_hello = NULL, *ciphersuite_list = NULL, *tls_extensions = NULL, *server_hello = NULL;\n\n  /* If TLSv1.3 is supported, test it first. */\n  unsigned int index = 0;\n  if (options->tls13_supported) {\n    test_versions[index] = TLSv1_3;\n    index++;\n  }\n\n  /* For TLSv1.2 and below, test the highest protocol version supported. */\n  if (options->tls12_supported)\n    test_versions[index] = TLSv1_2;\n  else if (options->tls11_supported)\n    test_versions[index] = TLSv1_1;\n  else if (options->tls10_supported)\n    test_versions[index] = TLSv1_0;\n\n  /* Loop through the one or two TLS versions to test. */\n  for (index = 0; index < (sizeof(test_versions) / sizeof(int)); index++) {\n    int tls_version = test_versions[index];\n\n    /* If there's only one version to test... */\n    if (tls_version == -1)\n      break;\n\n    if (tls_version == TLSv1_3) {\n      /* Get all TLSv1.3 ciphersuites. */\n      ciphersuite_list = makeCiphersuiteListTLS13All();\n    } else\n      ciphersuite_list = makeCiphersuiteListAll(tls_version);\n\n\n    /* For each signature algorithm... */\n    for (int i = 0; i < (sizeof(signature_algorithms) / sizeof(struct signature_algorithm)); i++) {\n      uint16_t sig_id = signature_algorithms[i].sig_id;\n      char *sig_name = signature_algorithms[i].sig_name;\n      char *color = signature_algorithms[i].color;\n\n\n      /* Make generic TLS extensions (with SNI, accepted EC point formats, etc). */\n      tls_extensions = makeTLSExtensions(options, 0);\n\n      if (tls_version == TLSv1_3) {\n        /* Extension: supported_groups */\n        bs_append_bytes(tls_extensions, (unsigned char []) {\n          0x00, 0x0a, // Extension: supported_groups (10)\n          0x00, 0x16, // Extension Length (22)\n          0x00, 0x14, // Supported Groups List Length (20)\n          0x00, 0x17, // secp256r1\n          0x00, 0x19, // secp521r1\n          0x00, 0x18, // secp384r1\n          0x00, 0x1d, // X25519\n          0x00, 0x1e, // X448\n          0x01, 0x00, // FFDHE2048\n          0x01, 0x01, // FFDHE3072\n          0x01, 0x02, // FFDHE4096\n          0x01, 0x03, // FFDHE6144\n          0x01, 0x04, // FFDHE8192\n        }, 26);\n\n        /* Add key shares for X25519. */\n        tlsExtensionAddDefaultKeyShare(tls_extensions);\n\n        /* Add the supported_versions extension to signify we are using TLS v1.3. */\n        tlsExtensionAddTLSv1_3(tls_extensions);\n      }\n\n      /* Add the signature_algorithms extension.  Only add the one group we are testing for. */\n      bs_append_bytes(tls_extensions, (unsigned char []) {\n        0x00, 0x0d, // Extension Type: signature_algorithms (13)\n        0x00, 0x04, // Extension Length (4)\n        0x00, 0x02, // Signature Hash Algorithms List Length (2)\n      }, 6);\n      bs_append_ushort(tls_extensions, sig_id);\n\n      /* Update the TLS extensions length since we manually added to it. */\n      tlsExtensionUpdateLength(tls_extensions);\n\n      /* Create the Client Hello buffer using the ciphersuite list and TLS extensions. */\n      client_hello = makeClientHello(options, tls_version, ciphersuite_list, tls_extensions);\n\n      /* Free the TLS extensions since we're done with them.  Note: we don't free the ciphersuite_list because we'll need them on the next loop. */\n      bs_free(&tls_extensions);\n\n      /* Now connect to the target server. */\n      s = tcpConnect(options);\n      if (s == 0) {\n        ret = false;\n        goto done;\n      }\n\n      /* Send the Client Hello message. */\n      if (send(s, bs_get_bytes(client_hello), bs_get_len(client_hello), 0) <= 0) {\n        printf_error(\"send() failed while sending Client Hello: %d (%s)\", errno, strerror(errno));\n        ret = false;\n        goto done;\n      }\n      bs_free(&client_hello);\n\n      server_hello = getServerHello(s);\n      CLOSE(s);\n\n      /* This signature algorithm is not supported. */\n      if (server_hello == NULL)\n        continue;\n\n      bs_free(&server_hello);\n\n      if (!printed_header) {\n        printf(\"\\n  %sServer Signature Algorithm(s):%s\\n\", COL_BLUE, RESET);\n        printed_header = 1;\n      }\n\n      /* If the server accepted our bogus signature ID, then we can conclude that it will accept all of them (and not test any further).  Some servers in the wild do this for some reason... */\n      if (sig_id == BOGUS_SIG_ALG_ID) {\n        printf(\"%s%s  Server accepts all signature algorithms.%s\\n\", getPrintableTLSName(tls_version), COL_RED, RESET);\n        printf_xml(\"  <connection-signature-algorithm sslversion=\\\"%s\\\" name=\\\"ANY\\\" id=\\\"0xfdff\\\" />\\n\", getPrintableTLSName(tls_version));\n        break;\n      } else {\n        printf(\"%s  %s%s%s\\n\", getPrintableTLSName(tls_version), color, sig_name, RESET);\n        printf_xml(\"  <connection-signature-algorithm sslversion=\\\"%s\\\" name=\\\"%s\\\" id=\\\"0x%04x\\\" />\\n\", getPrintableTLSName(tls_version), sig_name, sig_id);\n      }\n    }\n  }\n\n done:\n  CLOSE(s);\n  bs_free(&ciphersuite_list);\n  bs_free(&tls_extensions);\n  bs_free(&client_hello);\n  bs_free(&server_hello);\n  return ret;\n}\n\n/* MinGW doesn't have a memmem() implementation. */\n#ifdef _WIN32\n\n/* Implementation taken from: https://sourceforge.net/p/mingw/msys2-runtime/ci/f21dc72d306bd98e55a08461a9530c4b0ce1dffe/tree/newlib/libc/string/memmem.c#l80 */\n/* Copyright (C) 2008 Eric Blake\n * Permission to use, copy, modify, and distribute this software\n * is freely granted, provided that this notice is preserved.*/\nvoid *memmem(const void *haystack_start, size_t haystack_len, const void *needle, size_t needle_len) {\n  const unsigned char *haystack = (const unsigned char *) haystack_start;\n  //const unsigned char *needle = (const unsigned char *) needle_start;\n\n  if (needle_len == 0)\n    return (void *)haystack;\n\n  while (needle_len <= haystack_len)\n    {\n      if (!memcmp (haystack, needle, needle_len))\n        return (void *) haystack;\n      haystack++;\n      haystack_len--;\n    }\n  return NULL;\n}\n#endif\n\n/* vim :set ts=4 sw=4 sts=4 et : */\n"
        },
        {
          "name": "sslscan.h",
          "type": "blob",
          "size": 13.486328125,
          "content": "/***************************************************************************\n *   sslscan - A SSL cipher scanning tool                                  *\n *   Copyright 2007-2009 by Ian Ventura-Whiting (Fizz)                     *\n *   fizz@titania.co.uk                                                    *\n *   Copyright 2010 by Michael Boman (michael@michaelboman.org)            *\n *   Copyleft 2010 by Jacob Appelbaum <jacob@appelbaum.net>                *\n *   Copyleft 2013 by rbsec <robin@rbsec.net>                              *\n *   Copyleft 2014 by Julian Kornberger <jk+github@digineo.de>             *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 3 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program. If not, see <http://www.gnu.org/licenses/>.  *\n *                                                                         *\n *   In addition, as a special exception, the copyright holders give       *\n *   permission to link the code of portions of this program with the      *\n *   OpenSSL library under certain conditions as described in each         *\n *   individual source file, and distribute linked combinations            *\n *   including the two.                                                    *\n *   You must obey the GNU General Public License in all respects          *\n *   for all of the code used other than OpenSSL.  If you modify           *\n *   file(s) with this exception, you may extend this exception to your    *\n *   version of the file(s), but you are not obligated to do so.  If you   *\n *   do not wish to do so, delete this exception statement from your       *\n *   version.  If you delete this exception statement from all source      *\n *   files in the program, then also delete it here.                       *\n ***************************************************************************/\n\n#ifndef HAVE_SSLSCAN_H_\n#define HAVE_SSLSCAN_H_\n\n#include \"missing_ciphersuites.h\"\n\n// Defines...\n#define false 0\n#define true 1\n\n#define mode_help 0\n#define mode_version 1\n#define mode_single 2\n#define mode_multiple 3\n\n#define BUFFERSIZE 1024\n\n// For options.sslVersion field.\n#define ssl_all 0\n#define ssl_v2 1\n#define ssl_v3 2\n#define tls_all 3\n#define tls_v10 4\n#define tls_v11 5\n#define tls_v12 6\n#define tls_v13 7\n\n// For functions that take a tls_version argument.\n#define TLSv1_0 0\n#define TLSv1_1 1\n#define TLSv1_2 2\n#define TLSv1_3 3\n\n/* We must maintain our own list of TLSv1.3-specific ciphersuites here, because SSL_CTX_get_ciphers() will *always* return TLSv1.2 ciphersuites, even when SSL_CTX_set_min_proto_version() and SSL_CTX_set_max_proto_version() are used.  This is confirmed by an OpenSSL developer here: https://github.com/openssl/openssl/issues/7196#issuecomment-420575202 */\n#define TLSV13_CIPHERSUITES \"TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_CCM_SHA256:TLS_AES_128_CCM_8_SHA256\"\n\n/* Cipherlist for TLSv1.2 and below that corresponds to all available ciphersuites. */\n#define CIPHERSUITE_LIST_ALL \"ALL:COMPLEMENTOFALL\"\n\n// Macros for various outputs\n#define printf(format, ...)         if (!xml_to_stdout) fprintf(stdout, format, ##__VA_ARGS__)\n#define printf_xml(format, ...)     if (options->xmlOutput) fprintf(options->xmlOutput, format, ##__VA_ARGS__)\n#define printf_verbose(format, ...) if (options->verbose) printf(format, ##__VA_ARGS__)\n\n#define printf_error(format, ...) \\\n    if (!xml_to_stdout) fprintf(stderr, \"%sERROR: \" format \"%s\\n\", COL_RED, ##__VA_ARGS__, RESET); \\\n    printf_xml(\"  <error><![CDATA[\" format \"]]></error>\\n\", ##__VA_ARGS__)\n\n/* Calls close() on a file descriptor, then sets it to zero to prevent accidental re-use. */\n#define CLOSE(fd) { if ((fd) != -1) { close((fd)); (fd) = -1; } }\n\n/* Calls free() on a pointer, then explicitly sets it to NULL to avoid use-after-free. */\n#define FREE(ptr) { free((ptr)); (ptr) = NULL; }\n\n/* Frees an SSL pointer, and explicitly sets it to NULL to avoid use-after-free. */\n#define FREE_SSL(ssl) { if ((ssl) != NULL) { SSL_free((ssl)); (ssl) = NULL; } }\n\n/* Frees a SSL_CTX pointer, and explicitly sets it to NULL to avoid use-after-free. */\n#define FREE_CTX(ctx) { if ((ctx) != NULL) { SSL_CTX_free((ctx)); (ctx) = NULL; } }\n\n// Colour Console Output...\n// Always better to do \"const char RESET[] = \" because it saves relocation records.\n// Default colours were hard to read on Windows, so use lighter ones\n#ifdef _WIN32\nchar *RESET = \"\u001b[0m\";            // DEFAULT\nchar *COL_RED = \"\u001b[91m\";\nchar *COL_YELLOW = \"\u001b[93m\";\nchar *COL_BLUE = \"\u001b[1;36m\";\nchar *COL_GREEN = \"\u001b[92m\";\nchar *COL_PURPLE = \"\u001b[95m\";\nchar *COL_GREY = \"\u001b[1;30m\";\nchar *COL_RED_BG = \"\u001b[41m\";\n#else\nchar *RESET = \"\u001b[0m\";            // DEFAULT\nchar *COL_RED = \"\u001b[31m\";\nchar *COL_YELLOW = \"\u001b[33m\";\nchar *COL_BLUE = \"\u001b[1;34m\";\nchar *COL_GREEN = \"\u001b[32m\";\nchar *COL_PURPLE = \"\u001b[35m\";\nchar *COL_GREY = \"\u001b[1;30m\";\nchar *COL_RED_BG = \"\u001b[41m\";\n#endif\n\n#ifdef _WIN32\n    #define SLEEPMS(ms) Sleep(ms);\n#else\n    #define SLEEPMS(ms) do {                    \\\n        struct timeval wait = { 0, ms*1000 };   \\\n        select(0, NULL, NULL, NULL, &wait);     \\\n    } while(0)\n#endif\n\nconst char *program_banner = \"                   _\\n\"\n                             \"           ___ ___| |___  ___ __ _ _ __\\n\"\n                             \"          / __/ __| / __|/ __/ _` | '_ \\\\\\n\"\n                             \"          \\\\__ \\\\__ \\\\ \\\\__ \\\\ (_| (_| | | | |\\n\"\n                             \"          |___/___/_|___/\\\\___\\\\__,_|_| |_|\\n\\n\";\n\nstruct sslCipher\n{\n    // Cipher Properties...\n    const char *name;\n    const char *version;\n    int bits;\n    char description[512];\n    const SSL_METHOD *sslMethod;\n    struct sslCipher *next;\n};\n\nstruct sslCheckOptions\n{\n    // Program Options...\n    char host[512];\n    char sniname[512];\n    int sni_set;\n    char addrstr[INET6_ADDRSTRLEN];\n    int port;\n    int showCertificate;\n    int showCertificates;\n    int checkCertificate;\n    int showTrustedCAs;\n    int showClientCiphers;\n    int showCipherIds;\n    int showTimes;\n    int ciphersuites;\n    int reneg;\n    int fallback;\n    int compression;\n    int heartbleed;\n    int groups;\n    int signature_algorithms;\n    int starttls_ftp;\n    int starttls_imap;\n    int starttls_irc;\n    int starttls_ldap;\n    int starttls_pop3;\n    int starttls_smtp;\n    int starttls_mysql;\n    int starttls_xmpp;\n    int starttls_psql;\n    int xmpp_server;\n    int sslVersion;\n    int targets;\n    int sslbugs;\n    int rdp;\n    int verbose;\n    int cipher_details;\n    int ipv4;\n    int ipv6;\n    int ocspStatus;\n    int ianaNames;\n    char cipherstring[65536];\n\n    // File Handles...\n    FILE *xmlOutput;\n\n    // TCP Connection Variables...\n    short h_addrtype;\n    struct sockaddr_in serverAddress;\n    struct sockaddr_in6 serverAddress6;\n    struct timeval timeout;\n    int connect_timeout;\n    unsigned int sleep;\n\n    // SSL Variables...\n    SSL_CTX *ctx;\n    struct sslCipher *ciphers;\n    char *clientCertsFile;\n    char *privateKeyFile;\n    char *privateKeyPassword;\n\n    // TLS versions supported by the server.\n    unsigned int tls10_supported;\n    unsigned int tls11_supported;\n    unsigned int tls12_supported;\n    unsigned int tls13_supported;\n};\n\n// store renegotiation test data\nstruct renegotiationOutput\n{\n    int supported;\n    int secure;\n};\n\n/* For OCSP processing.  Taken from crypto/ocsp/ocsp_local.h in OpenSSL, which does not seem to be normally exposed externally. */\nstruct ocsp_response_st {\n    ASN1_ENUMERATED *responseStatus;\n    OCSP_RESPBYTES *responseBytes;\n};\n\nstruct ocsp_resp_bytes_st {\n    ASN1_OBJECT *responseType;\n    ASN1_OCTET_STRING *response;\n};\n\nstruct ocsp_responder_id_st {\n    int type;\n    union {\n        X509_NAME *byName;\n        ASN1_OCTET_STRING *byKey;\n    } value;\n};\ntypedef struct ocsp_responder_id_st OCSP_RESPID;\n\nstruct ocsp_response_data_st {\n    ASN1_INTEGER *version;\n    OCSP_RESPID responderId;\n    ASN1_GENERALIZEDTIME *producedAt;\n    STACK_OF(OCSP_SINGLERESP) *responses;\n    STACK_OF(X509_EXTENSION) *responseExtensions;\n};\ntypedef struct ocsp_response_data_st OCSP_RESPDATA;\n\nstruct ocsp_basic_response_st {\n    OCSP_RESPDATA tbsResponseData;\n    X509_ALGOR signatureAlgorithm;\n    ASN1_BIT_STRING *signature;\n    STACK_OF(X509) *certs;\n};\n\nstruct ocsp_single_response_st {\n    OCSP_CERTID *certId;\n    OCSP_CERTSTATUS *certStatus;\n    ASN1_GENERALIZEDTIME *thisUpdate;\n    ASN1_GENERALIZEDTIME *nextUpdate;\n    STACK_OF(X509_EXTENSION) *singleExtensions;\n};\n\nstruct ocsp_cert_status_st {\n    int type;\n    union {\n        ASN1_NULL *good;\n        OCSP_REVOKEDINFO *revoked;\n        ASN1_NULL *unknown;\n    } value;\n};\n\nstruct ocsp_revoked_info_st {\n    ASN1_GENERALIZEDTIME *revocationTime;\n    ASN1_ENUMERATED *revocationReason;\n};\n\nstruct ocsp_cert_id_st {\n    X509_ALGOR hashAlgorithm;\n    ASN1_OCTET_STRING issuerNameHash;\n    ASN1_OCTET_STRING issuerKeyHash;\n    ASN1_INTEGER serialNumber;\n};\n\n#define BS_DEFAULT_NEW_SIZE 256 /* The starting size of the buffer when bs_new() is used. */\nstruct _bs {\n  unsigned char *buf;\n  size_t size;  /* The size of the allocated buffer. */\n  size_t len;   /* The number of bytes currently in the buffer. */\n};\ntypedef struct _bs bs; /* Stands for 'byte string'. */\n\n/* We redefine these so that we can run correctly even if the vendor gives us\n * a version of OpenSSL that does not match its header files.  (Apple: I am\n * looking at you.)\n */\n#ifndef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\n#    define SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION 0x00040000L\n#endif\n#ifndef SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\n#    define SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION 0x0010\n#endif\n\n// Utilities\nvoid bs_new(bs **);\nvoid bs_new_size(bs **, size_t);\nvoid bs_free(bs **);\nvoid bs_append_bytes(bs *, unsigned char *, size_t);\nvoid bs_append_uint32_t(bs *, uint32_t);\nvoid bs_append_ushort(bs *, unsigned short);\nvoid bs_append_bs(bs *, bs *);\nsize_t bs_get_len(bs *);\nsize_t bs_get_size(bs *);\nunsigned char *bs_get_bytes(bs *);\nunsigned char bs_get_byte(bs *, size_t);\nvoid bs_set_byte(bs *, size_t, unsigned char);\nvoid bs_set_ushort(bs *b, size_t offset, unsigned short length);\nint bs_read_socket(bs *b, int s, size_t num_bytes);\nunsigned int checkIfTLSVersionIsSupported(struct sslCheckOptions *options, unsigned int tls_version);\nSSL_CTX *CTX_new(const SSL_METHOD *method);\nint fileExists(char *);\nvoid findMissingCiphers();\nchar *getPrintableTLSName(unsigned int tls_version);\nbs *getServerHello(int s);\nbs *makeCiphersuiteListAll(unsigned int tls_version);\nbs *makeCiphersuiteListTLS13All();\nbs *makeCiphersuiteListMissing(unsigned int tls_version);\nbs *makeClientHello(struct sslCheckOptions *options, unsigned int version, bs *ciphersuite_list, bs *tls_extensions);\nbs *makeTLSExtensions(struct sslCheckOptions *options, unsigned int include_signature_algorithms);\nvoid markFoundCiphersuite(unsigned short server_cipher_id, unsigned int tls_version);\nint ocsp_certid_print(BIO *bp, OCSP_CERTID *a, int indent);\nstatic int ocsp_resp_cb(SSL *s, void *arg);\nvoid readLine(FILE *, char *, int);\nint readOrLogAndClose(int, void *, size_t, const struct sslCheckOptions *);\nchar *resolveCipherID(unsigned short cipher_id, int *cipher_bits);\nstatic int password_callback(char *, int, int, void *);\nconst char *printableSslMethod(const SSL_METHOD *);\nssize_t sendString(int, const char[]);\nint ssl_print_tmp_key(struct sslCheckOptions *, SSL *s);\nvoid tlsExtensionAddDefaultKeyShare(bs *tls_extensions);\nvoid tlsExtensionAddTLSv1_3(bs *tls_extensions);\nvoid tlsExtensionUpdateLength(bs *tls_extensions);\nint tcpConnect(struct sslCheckOptions *);\n\n// Tests\nvoid tls_reneg_init(struct sslCheckOptions *);\nint outputRenegotiation(struct sslCheckOptions *, struct renegotiationOutput *);\nstruct renegotiationOutput *newRenegotiationOutput(void);\nint freeRenegotiationOutput(struct renegotiationOutput *);\n\nint testCompression(struct sslCheckOptions *, const SSL_METHOD *);\nint testRenegotiation(struct sslCheckOptions *, const SSL_METHOD *);\n#ifdef SSL_MODE_SEND_FALLBACK_SCSV\nint testfallback(struct sslCheckOptions *, const SSL_METHOD *);\n#endif\nint testHeartbleed(struct sslCheckOptions *, const SSL_METHOD *);\nint testSupportedGroups(struct sslCheckOptions *options);\nint testSignatureAlgorithms(struct sslCheckOptions *options);\nint testCipher(struct sslCheckOptions *, const SSL_METHOD *);\nint testMissingCiphers(struct sslCheckOptions *options, unsigned int version);\nint testProtocolCiphers(struct sslCheckOptions *, const SSL_METHOD *);\nint testConnection(struct sslCheckOptions *);\nint testHost(struct sslCheckOptions *);\nint loadCerts(struct sslCheckOptions *);\nint checkCertificateProtocols(struct sslCheckOptions *, const SSL_METHOD *);\nint checkCertificate(struct sslCheckOptions *, const SSL_METHOD *);\nint showCertificate(struct sslCheckOptions *);\n\nint runSSLv2Test(struct sslCheckOptions *options);\nint runSSLv3Test(struct sslCheckOptions *options);\n#endif\n\n/* vim :set ts=4 sw=4 sts=4 et : */\n"
        },
        {
          "name": "tags",
          "type": "blob",
          "size": 25.7421875,
          "content": "!_TAG_FILE_FORMAT\t2\t/extended format; --format=1 will not append ;\" to lines/\n!_TAG_FILE_SORTED\t1\t/0=unsorted, 1=sorted, 2=foldcase/\n!_TAG_OUTPUT_FILESEP\tslash\t/slash or backslash/\n!_TAG_OUTPUT_MODE\tu-ctags\t/u-ctags or e-ctags/\n!_TAG_PROGRAM_AUTHOR\tUniversal Ctags Team\t//\n!_TAG_PROGRAM_NAME\tUniversal Ctags\t/Derived from Exuberant Ctags/\n!_TAG_PROGRAM_URL\thttps://ctags.io/\t/official site/\n!_TAG_PROGRAM_VERSION\t0.0.0\t/a3c87ab5/\nBOGUS_SIG_ALG_ID\tsslscan.c\t/^#define BOGUS_SIG_ALG_ID /;\"\td\tfile:\nBS_DEFAULT_NEW_SIZE\tsslscan.h\t/^#define BS_DEFAULT_NEW_SIZE /;\"\td\nBUFFERSIZE\tsslscan.h\t/^#define BUFFERSIZE /;\"\td\nCIPHERSUITE_LIST_ALL\tsslscan.h\t/^#define CIPHERSUITE_LIST_ALL /;\"\td\nCLOSE\tsslscan.h\t/^#define CLOSE(/;\"\td\nCOL_BLUE\tsslscan.h\t/^char *COL_BLUE = \"\u001b[1;34m\";$/;\"\tv\ttyperef:typename:char *\nCOL_BLUE\tsslscan.h\t/^char *COL_BLUE = \"\u001b[1;36m\";$/;\"\tv\ttyperef:typename:char *\nCOL_GREEN\tsslscan.h\t/^char *COL_GREEN = \"\u001b[32m\";$/;\"\tv\ttyperef:typename:char *\nCOL_GREEN\tsslscan.h\t/^char *COL_GREEN = \"\u001b[92m\";$/;\"\tv\ttyperef:typename:char *\nCOL_GREY\tsslscan.h\t/^char *COL_GREY = \"\u001b[1;30m\";$/;\"\tv\ttyperef:typename:char *\nCOL_PLAIN\tsslscan.c\t/^#define COL_PLAIN /;\"\td\tfile:\nCOL_PURPLE\tsslscan.h\t/^char *COL_PURPLE = \"\u001b[35m\";$/;\"\tv\ttyperef:typename:char *\nCOL_PURPLE\tsslscan.h\t/^char *COL_PURPLE = \"\u001b[95m\";$/;\"\tv\ttyperef:typename:char *\nCOL_RED\tsslscan.h\t/^char *COL_RED = \"\u001b[31m\";$/;\"\tv\ttyperef:typename:char *\nCOL_RED\tsslscan.h\t/^char *COL_RED = \"\u001b[91m\";$/;\"\tv\ttyperef:typename:char *\nCOL_RED_BG\tsslscan.h\t/^char *COL_RED_BG = \"\u001b[41m\";$/;\"\tv\ttyperef:typename:char *\nCOL_YELLOW\tsslscan.h\t/^char *COL_YELLOW = \"\u001b[33m\";$/;\"\tv\ttyperef:typename:char *\nCOL_YELLOW\tsslscan.h\t/^char *COL_YELLOW = \"\u001b[93m\";$/;\"\tv\ttyperef:typename:char *\nENABLE_VIRTUAL_TERMINAL_PROCESSING\tsslscan.c\t/^    #define ENABLE_VIRTUAL_TERMINAL_PROCESSING /;\"\td\tfile:\nFREE\tsslscan.h\t/^#define FREE(/;\"\td\nFREE_CTX\tsslscan.h\t/^#define FREE_CTX(/;\"\td\nFREE_SSL\tsslscan.h\t/^#define FREE_SSL(/;\"\td\nHAVE_SSLSCAN_H_\tsslscan.h\t/^#define HAVE_SSLSCAN_H_$/;\"\td\nNID_TYPE_DHE\tsslscan.c\t/^#define NID_TYPE_DHE /;\"\td\tfile:\nNID_TYPE_ECDHE\tsslscan.c\t/^#define NID_TYPE_ECDHE /;\"\td\tfile:\nNID_TYPE_NA\tsslscan.c\t/^#define NID_TYPE_NA /;\"\td\tfile:\nOCSP_RESPDATA\tsslscan.h\t/^typedef struct ocsp_response_data_st OCSP_RESPDATA;$/;\"\tt\ttyperef:struct:ocsp_response_data_st\nOCSP_RESPID\tsslscan.h\t/^typedef struct ocsp_responder_id_st OCSP_RESPID;$/;\"\tt\ttyperef:struct:ocsp_responder_id_st\nOVERFLOW_MESSAGE\tsslscan.c\t/^#define OVERFLOW_MESSAGE /;\"\td\tfile:\nRESET\tsslscan.h\t/^char *RESET = \"\u001b[0m\";            \\/\\/ DEFAULT$/;\"\tv\ttyperef:typename:char *\nR_OK\tsslscan.c\t/^    #define R_OK /;\"\td\tfile:\nSIZE_T_FMT\tsslscan.c\t/^  #define SIZE_T_FMT /;\"\td\tfile:\nSLEEPMS\tsslscan.h\t/^    #define SLEEPMS(/;\"\td\nSSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\tsslscan.h\t/^#    define SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION /;\"\td\nSSL_CIPHER_get_id\tsslscan.c\t/^unsigned long SSL_CIPHER_get_id(const SSL_CIPHER* cipher) { return cipher->id; }$/;\"\tf\ttyperef:typename:unsigned long\nSSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\tsslscan.h\t/^#    define SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION /;\"\td\nTLSV13_CIPHERSUITES\tsslscan.h\t/^#define TLSV13_CIPHERSUITES /;\"\td\nTLSv1_0\tsslscan.h\t/^#define TLSv1_0 /;\"\td\nTLSv1_1\tsslscan.h\t/^#define TLSv1_1 /;\"\td\nTLSv1_2\tsslscan.h\t/^#define TLSv1_2 /;\"\td\nTLSv1_3\tsslscan.h\t/^#define TLSv1_3 /;\"\td\nTLSv1_3_client_method\tsslscan.c\t/^const SSL_METHOD *TLSv1_3_client_method(void)$/;\"\tf\ttyperef:typename:const SSL_METHOD *\nTLSv1_3_method\tsslscan.c\t/^const SSL_METHOD *TLSv1_3_method(void)$/;\"\tf\ttyperef:typename:const SSL_METHOD *\nVC_EXTRALEAN\tsslscan.c\t/^  #define VC_EXTRALEAN$/;\"\td\tfile:\nWIN32_LEAN_AND_MEAN\tsslscan.c\t/^  #define WIN32_LEAN_AND_MEAN$/;\"\td\tfile:\n_GNU_SOURCE\tsslscan.c\t/^#define _GNU_SOURCE$/;\"\td\tfile:\n_WIN32_WINNT\tsslscan.c\t/^  #define _WIN32_WINNT /;\"\td\tfile:\n__anonf49f55d2010a\tsslscan.h\t/^    union {$/;\"\tu\tstruct:ocsp_responder_id_st\n__anonf49f55d2020a\tsslscan.h\t/^    union {$/;\"\tu\tstruct:ocsp_cert_status_st\n_bs\tsslscan.h\t/^struct _bs {$/;\"\ts\naccess\tsslscan.c\t/^    #define access /;\"\td\tfile:\naddrstr\tsslscan.h\t/^    char addrstr[INET6_ADDRSTRLEN];$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:char[]\nbits\tsslscan.h\t/^    int bits;$/;\"\tm\tstruct:sslCipher\ttyperef:typename:int\nbs\tsslscan.h\t/^typedef struct _bs bs; \\/* Stands for 'byte string'. *\\/$/;\"\tt\ttyperef:struct:_bs\nbs_append_bs\tsslscan.c\t/^void bs_append_bs(bs *dst, bs *src) {$/;\"\tf\ttyperef:typename:void\nbs_append_bytes\tsslscan.c\t/^void bs_append_bytes(bs *b, unsigned char *bytes, size_t bytes_len) {$/;\"\tf\ttyperef:typename:void\nbs_append_uint32_t\tsslscan.c\t/^void bs_append_uint32_t(bs *b, uint32_t u) {$/;\"\tf\ttyperef:typename:void\nbs_append_ushort\tsslscan.c\t/^void bs_append_ushort(bs *b, unsigned short us) {$/;\"\tf\ttyperef:typename:void\nbs_free\tsslscan.c\t/^void bs_free(bs **b) {$/;\"\tf\ttyperef:typename:void\nbs_get_byte\tsslscan.c\t/^unsigned char bs_get_byte(bs *b, size_t offset) {$/;\"\tf\ttyperef:typename:unsigned char\nbs_get_bytes\tsslscan.c\t/^unsigned char *bs_get_bytes(bs *b) {$/;\"\tf\ttyperef:typename:unsigned char *\nbs_get_len\tsslscan.c\t/^size_t bs_get_len(bs *b) {$/;\"\tf\ttyperef:typename:size_t\nbs_get_size\tsslscan.c\t/^size_t bs_get_size(bs *b) {$/;\"\tf\ttyperef:typename:size_t\nbs_new\tsslscan.c\t/^void bs_new(bs **b) {$/;\"\tf\ttyperef:typename:void\nbs_new_size\tsslscan.c\t/^void bs_new_size(bs **b, size_t new_size) {$/;\"\tf\ttyperef:typename:void\nbs_read_socket\tsslscan.c\t/^int bs_read_socket(bs *b, int s, size_t num_bytes) {$/;\"\tf\ttyperef:typename:int\nbs_set_byte\tsslscan.c\t/^void bs_set_byte(bs *b, size_t offset, unsigned char byte) {$/;\"\tf\ttyperef:typename:void\nbs_set_ushort\tsslscan.c\t/^void bs_set_ushort(bs *b, size_t offset, unsigned short length) {$/;\"\tf\ttyperef:typename:void\nbuf\tsslscan.h\t/^  unsigned char *buf;$/;\"\tm\tstruct:_bs\ttyperef:typename:unsigned char *\nbyKey\tsslscan.h\t/^        ASN1_OCTET_STRING *byKey;$/;\"\tm\tunion:ocsp_responder_id_st::__anonf49f55d2010a\ttyperef:typename:ASN1_OCTET_STRING *\nbyName\tsslscan.h\t/^        X509_NAME *byName;$/;\"\tm\tunion:ocsp_responder_id_st::__anonf49f55d2010a\ttyperef:typename:X509_NAME *\ncertId\tsslscan.h\t/^    OCSP_CERTID *certId;$/;\"\tm\tstruct:ocsp_single_response_st\ttyperef:typename:OCSP_CERTID *\ncertStatus\tsslscan.h\t/^    OCSP_CERTSTATUS *certStatus;$/;\"\tm\tstruct:ocsp_single_response_st\ttyperef:typename:OCSP_CERTSTATUS *\ncheckCertificate\tsslscan.c\t/^int checkCertificate(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ncheckCertificate\tsslscan.h\t/^    int checkCertificate;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\ncheckCertificateProtocol\tsslscan.c\t/^int checkCertificateProtocol(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ncheckIfTLSVersionIsSupported\tsslscan.c\t/^unsigned int checkIfTLSVersionIsSupported(struct sslCheckOptions *options, unsigned int tls_vers/;\"\tf\ttyperef:typename:unsigned int\ncipherRemove\tsslscan.c\t/^char *cipherRemove(char *str, const char *sub) {$/;\"\tf\ttyperef:typename:char *\ncipher_details\tsslscan.h\t/^    int cipher_details;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nciphers\tsslscan.h\t/^    struct sslCipher *ciphers;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:struct:sslCipher *\ncipherstring\tsslscan.h\t/^    char cipherstring[65536];$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:char[65536]\nciphersuites\tsslscan.h\t/^    int ciphersuites;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nclientCertsFile\tsslscan.h\t/^    char *clientCertsFile;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:char *\nclose\tsslscan.c\t/^    #define close /;\"\td\tfile:\ncolor\tsslscan.c\t/^    char *color;$/;\"\tm\tstruct:testSignatureAlgorithms::signature_algorithm\ttyperef:typename:char *\tfile:\ncolor\tsslscan.c\t/^    char *color;$/;\"\tm\tstruct:testSupportedGroups::group_key_exchange\ttyperef:typename:char *\tfile:\ncompression\tsslscan.h\t/^    int compression;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nctx\tsslscan.h\t/^    SSL_CTX *ctx;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:SSL_CTX *\ndescription\tsslscan.h\t/^    char description[512];$/;\"\tm\tstruct:sslCipher\ttyperef:typename:char[512]\nfallback\tsslscan.h\t/^    int fallback;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nfalse\tsslscan.h\t/^#define false /;\"\td\nfileExists\tsslscan.c\t/^int fileExists(char *fileName)$/;\"\tf\ttyperef:typename:int\nfindMissingCiphers\tsslscan.c\t/^void findMissingCiphers() {$/;\"\tf\ttyperef:typename:void\nfreeRenegotiationOutput\tsslscan.c\t/^int freeRenegotiationOutput( struct renegotiationOutput *myRenOut )$/;\"\tf\ttyperef:typename:int\ngetPrintableTLSName\tsslscan.c\t/^char *getPrintableTLSName(unsigned int tls_version) {$/;\"\tf\ttyperef:typename:char *\ngetServerHello\tsslscan.c\t/^bs *getServerHello(int s) {$/;\"\tf\ttyperef:typename:bs *\ngetTLSHandshakeRecord\tsslscan.c\t/^bs *getTLSHandshakeRecord(int s) {$/;\"\tf\ttyperef:typename:bs *\ngood\tsslscan.h\t/^        ASN1_NULL *good;$/;\"\tm\tunion:ocsp_cert_status_st::__anonf49f55d2020a\ttyperef:typename:ASN1_NULL *\ngroup_bit_strength\tsslscan.c\t/^    unsigned int group_bit_strength; \\/* The bit strength equivalent of this group. *\\/$/;\"\tm\tstruct:testSupportedGroups::group_key_exchange\ttyperef:typename:unsigned int\tfile:\ngroup_id\tsslscan.c\t/^    uint16_t group_id;$/;\"\tm\tstruct:testSupportedGroups::group_key_exchange\ttyperef:typename:uint16_t\tfile:\ngroup_key_exchange\tsslscan.c\t/^  struct group_key_exchange {$/;\"\ts\tfunction:testSupportedGroups\tfile:\ngroup_name\tsslscan.c\t/^    char *group_name;$/;\"\tm\tstruct:testSupportedGroups::group_key_exchange\ttyperef:typename:char *\tfile:\ngroups\tsslscan.h\t/^    int groups;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nh_addrtype\tsslscan.h\t/^    short h_addrtype;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:short\nhashAlgorithm\tsslscan.h\t/^    X509_ALGOR hashAlgorithm;$/;\"\tm\tstruct:ocsp_cert_id_st\ttyperef:typename:X509_ALGOR\nheartbleed\tsslscan.h\t/^    int heartbleed;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nhost\tsslscan.h\t/^    char host[512];$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:char[512]\nhttp\tsslscan.h\t/^    int http;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nipv4\tsslscan.h\t/^    int ipv4;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nipv6\tsslscan.h\t/^    int ipv6;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nissuerKeyHash\tsslscan.h\t/^    ASN1_OCTET_STRING issuerKeyHash;$/;\"\tm\tstruct:ocsp_cert_id_st\ttyperef:typename:ASN1_OCTET_STRING\nissuerNameHash\tsslscan.h\t/^    ASN1_OCTET_STRING issuerNameHash;$/;\"\tm\tstruct:ocsp_cert_id_st\ttyperef:typename:ASN1_OCTET_STRING\nkey_exchange_len\tsslscan.c\t/^    uint16_t key_exchange_len;$/;\"\tm\tstruct:testSupportedGroups::group_key_exchange\ttyperef:typename:uint16_t\tfile:\nlen\tsslscan.h\t/^  size_t len;   \\/* The number of bytes currently in the buffer. *\\/$/;\"\tm\tstruct:_bs\ttyperef:typename:size_t\nloadCerts\tsslscan.c\t/^int loadCerts(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\nmain\tsslscan.c\t/^int main(int argc, char *argv[])$/;\"\tf\ttyperef:typename:int\nmakeCiphersuiteListAll\tsslscan.c\t/^bs *makeCiphersuiteListAll(unsigned int tls_version) {$/;\"\tf\ttyperef:typename:bs *\nmakeCiphersuiteListMissing\tsslscan.c\t/^bs *makeCiphersuiteListMissing(unsigned int tls_version) {$/;\"\tf\ttyperef:typename:bs *\nmakeCiphersuiteListTLS13All\tsslscan.c\t/^bs *makeCiphersuiteListTLS13All() {$/;\"\tf\ttyperef:typename:bs *\nmakeClientHello\tsslscan.c\t/^bs *makeClientHello(struct sslCheckOptions *options, unsigned int tls_version, bs *ciphersuite_l/;\"\tf\ttyperef:typename:bs *\nmakeTLSExtensions\tsslscan.c\t/^bs *makeTLSExtensions(struct sslCheckOptions *options, unsigned int include_signature_algorithms/;\"\tf\ttyperef:typename:bs *\nmarkFoundCiphersuite\tsslscan.c\t/^void markFoundCiphersuite(unsigned short server_cipher_id, unsigned int tls_version) {$/;\"\tf\ttyperef:typename:void\nmemmem\tsslscan.c\t/^void *memmem(const void *haystack_start, size_t haystack_len, const void *needle, size_t needle_/;\"\tf\ttyperef:typename:void *\nmode_help\tsslscan.h\t/^#define mode_help /;\"\td\nmode_multiple\tsslscan.h\t/^#define mode_multiple /;\"\td\nmode_single\tsslscan.h\t/^#define mode_single /;\"\td\nmode_version\tsslscan.h\t/^#define mode_version /;\"\td\nname\tsslscan.h\t/^    const char *name;$/;\"\tm\tstruct:sslCipher\ttyperef:typename:const char *\nnewRenegotiationOutput\tsslscan.c\t/^struct renegotiationOutput * newRenegotiationOutput( void )$/;\"\tf\ttyperef:struct:renegotiationOutput *\nnew_CTX\tsslscan.c\t/^SSL_CTX *new_CTX(const SSL_METHOD *method) {$/;\"\tf\ttyperef:typename:SSL_CTX *\nnew_SSL\tsslscan.c\t/^SSL *new_SSL(SSL_CTX *ctx) {$/;\"\tf\ttyperef:typename:SSL *\nnext\tsslscan.h\t/^    struct sslCipher *next;$/;\"\tm\tstruct:sslCipher\ttyperef:struct:sslCipher *\nnextUpdate\tsslscan.h\t/^    ASN1_GENERALIZEDTIME *nextUpdate;$/;\"\tm\tstruct:ocsp_single_response_st\ttyperef:typename:ASN1_GENERALIZEDTIME *\nnid\tsslscan.c\t/^    int nid;               \\/* NID for group, or -1 for X25519\\/X448. *\\/$/;\"\tm\tstruct:testSupportedGroups::group_key_exchange\ttyperef:typename:int\tfile:\nnid_type\tsslscan.c\t/^    unsigned int nid_type; \\/* One of the NID_TYPE_* flags. *\\/$/;\"\tm\tstruct:testSupportedGroups::group_key_exchange\ttyperef:typename:unsigned int\tfile:\nocspRequest\tsslscan.c\t/^int ocspRequest(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\nocspStatus\tsslscan.h\t/^    int ocspStatus;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nocsp_basic_response_st\tsslscan.h\t/^struct ocsp_basic_response_st {$/;\"\ts\nocsp_cert_id_st\tsslscan.h\t/^struct ocsp_cert_id_st {$/;\"\ts\nocsp_cert_status_st\tsslscan.h\t/^struct ocsp_cert_status_st {$/;\"\ts\nocsp_certid_print\tsslscan.c\t/^int ocsp_certid_print(BIO *bp, OCSP_CERTID *a, int indent)$/;\"\tf\ttyperef:typename:int\nocsp_resp_bytes_st\tsslscan.h\t/^struct ocsp_resp_bytes_st {$/;\"\ts\nocsp_resp_cb\tsslscan.c\t/^static int ocsp_resp_cb(SSL *s, void *unused) {$/;\"\tf\ttyperef:typename:int\tfile:\nocsp_responder_id_st\tsslscan.h\t/^struct ocsp_responder_id_st {$/;\"\ts\nocsp_response_data_st\tsslscan.h\t/^struct ocsp_response_data_st {$/;\"\ts\nocsp_response_st\tsslscan.h\t/^struct ocsp_response_st {$/;\"\ts\nocsp_revoked_info_st\tsslscan.h\t/^struct ocsp_revoked_info_st {$/;\"\ts\nocsp_single_response_st\tsslscan.h\t/^struct ocsp_single_response_st {$/;\"\ts\noutputCipher\tsslscan.c\t/^void outputCipher(struct sslCheckOptions *options, SSL *ssl, const char *cleanSslMethod, uint32_/;\"\tf\ttyperef:typename:void\noutputRenegotiation\tsslscan.c\t/^int outputRenegotiation( struct sslCheckOptions *options, struct renegotiationOutput *outputData/;\"\tf\ttyperef:typename:int\npassword_callback\tsslscan.c\t/^static int password_callback(char *buf, int size, int rwflag, void *userdata)$/;\"\tf\ttyperef:typename:int\tfile:\npopulateCipherList\tsslscan.c\t/^int populateCipherList(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\nport\tsslscan.h\t/^    int port;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nprintableSslMethod\tsslscan.c\t/^const char* printableSslMethod(const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:const char *\nprintf\tsslscan.h\t/^#define printf(/;\"\td\nprintf_error\tsslscan.h\t/^#define printf_error(/;\"\td\nprintf_verbose\tsslscan.h\t/^#define printf_verbose(/;\"\td\nprintf_xml\tsslscan.h\t/^#define printf_xml(/;\"\td\nprivateKeyFile\tsslscan.h\t/^    char *privateKeyFile;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:char *\nprivateKeyPassword\tsslscan.h\t/^    char *privateKeyPassword;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:char *\nproducedAt\tsslscan.h\t/^    ASN1_GENERALIZEDTIME *producedAt;$/;\"\tm\tstruct:ocsp_response_data_st\ttyperef:typename:ASN1_GENERALIZEDTIME *\nprogram_banner\tsslscan.h\t/^const char *program_banner = \"                   _\\\\n\"$/;\"\tv\ttyperef:typename:const char *\nrdp\tsslscan.h\t/^    int rdp;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nreadLine\tsslscan.c\t/^void readLine(FILE *input, char *lineFromFile, int maxSize)$/;\"\tf\ttyperef:typename:void\nreadOrLogAndClose\tsslscan.c\t/^int readOrLogAndClose(int fd, void* buffer, size_t len, const struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\nreneg\tsslscan.h\t/^    int reneg;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nrenegotiationOutput\tsslscan.h\t/^struct renegotiationOutput$/;\"\ts\nresolveCipherID\tsslscan.c\t/^char *resolveCipherID(unsigned short cipher_id, int *cipher_bits) {$/;\"\tf\ttyperef:typename:char *\nresponderId\tsslscan.h\t/^    OCSP_RESPID responderId;$/;\"\tm\tstruct:ocsp_response_data_st\ttyperef:typename:OCSP_RESPID\nresponse\tsslscan.h\t/^    ASN1_OCTET_STRING *response;$/;\"\tm\tstruct:ocsp_resp_bytes_st\ttyperef:typename:ASN1_OCTET_STRING *\nresponseBytes\tsslscan.h\t/^    OCSP_RESPBYTES *responseBytes;$/;\"\tm\tstruct:ocsp_response_st\ttyperef:typename:OCSP_RESPBYTES *\nresponseStatus\tsslscan.h\t/^    ASN1_ENUMERATED *responseStatus;$/;\"\tm\tstruct:ocsp_response_st\ttyperef:typename:ASN1_ENUMERATED *\nresponseType\tsslscan.h\t/^    ASN1_OBJECT *responseType;$/;\"\tm\tstruct:ocsp_resp_bytes_st\ttyperef:typename:ASN1_OBJECT *\nrevocationReason\tsslscan.h\t/^    ASN1_ENUMERATED *revocationReason;$/;\"\tm\tstruct:ocsp_revoked_info_st\ttyperef:typename:ASN1_ENUMERATED *\nrevocationTime\tsslscan.h\t/^    ASN1_GENERALIZEDTIME *revocationTime;$/;\"\tm\tstruct:ocsp_revoked_info_st\ttyperef:typename:ASN1_GENERALIZEDTIME *\nrevoked\tsslscan.h\t/^        OCSP_REVOKEDINFO *revoked;$/;\"\tm\tunion:ocsp_cert_status_st::__anonf49f55d2020a\ttyperef:typename:OCSP_REVOKEDINFO *\nrunSSLv2Test\tsslscan.c\t/^int runSSLv2Test(struct sslCheckOptions *options) {$/;\"\tf\ttyperef:typename:int\nrunSSLv3Test\tsslscan.c\t/^int runSSLv3Test(struct sslCheckOptions *options) {$/;\"\tf\ttyperef:typename:int\nsecure\tsslscan.h\t/^    int secure;$/;\"\tm\tstruct:renegotiationOutput\ttyperef:typename:int\nsecurity_callback_allow_all\tsslscan.c\t/^static int security_callback_allow_all(const SSL *s, const SSL_CTX *ctx, int op, int bits, int n/;\"\tf\ttyperef:typename:int\tfile:\nsendString\tsslscan.c\t/^ssize_t sendString(int sockfd, const char str[])$/;\"\tf\ttyperef:typename:ssize_t\nserialNumber\tsslscan.h\t/^    ASN1_INTEGER serialNumber;$/;\"\tm\tstruct:ocsp_cert_id_st\ttyperef:typename:ASN1_INTEGER\nserverAddress\tsslscan.h\t/^    struct sockaddr_in serverAddress;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:struct:sockaddr_in\nserverAddress6\tsslscan.h\t/^    struct sockaddr_in6 serverAddress6;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:struct:sockaddr_in6\nsetCipherSuite\tsslscan.c\t/^int setCipherSuite(struct sslCheckOptions *options, const SSL_METHOD *sslMethod, const char *str/;\"\tf\ttyperef:typename:int\nshowCertificate\tsslscan.c\t/^int showCertificate(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\nshowCertificate\tsslscan.h\t/^    int showCertificate;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nshowCipherIds\tsslscan.h\t/^    int showCipherIds;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nshowClientCiphers\tsslscan.h\t/^    int showClientCiphers;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nshowTimes\tsslscan.h\t/^    int showTimes;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nshowTrustedCAs\tsslscan.c\t/^int showTrustedCAs(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\nshowTrustedCAs\tsslscan.h\t/^    int showTrustedCAs;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nsig_id\tsslscan.c\t/^    uint16_t sig_id;$/;\"\tm\tstruct:testSignatureAlgorithms::signature_algorithm\ttyperef:typename:uint16_t\tfile:\nsig_name\tsslscan.c\t/^    char *sig_name;$/;\"\tm\tstruct:testSignatureAlgorithms::signature_algorithm\ttyperef:typename:char *\tfile:\nsignature\tsslscan.h\t/^    ASN1_BIT_STRING *signature;$/;\"\tm\tstruct:ocsp_basic_response_st\ttyperef:typename:ASN1_BIT_STRING *\nsignatureAlgorithm\tsslscan.h\t/^    X509_ALGOR signatureAlgorithm;$/;\"\tm\tstruct:ocsp_basic_response_st\ttyperef:typename:X509_ALGOR\nsignature_algorithm\tsslscan.c\t/^  struct signature_algorithm {$/;\"\ts\tfunction:testSignatureAlgorithms\tfile:\nsignature_algorithms\tsslscan.h\t/^    int signature_algorithms;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nsize\tsslscan.h\t/^  size_t size;  \\/* The size of the allocated buffer. *\\/$/;\"\tm\tstruct:_bs\ttyperef:typename:size_t\nsleep\tsslscan.h\t/^    unsigned int sleep;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:unsigned int\nsniname\tsslscan.h\t/^    char sniname[512];$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:char[512]\nsnprintf\tsslscan.c\t/^    #define snprintf /;\"\td\tfile:\nssize_t\tsslscan.c\t/^    typedef int ssize_t;$/;\"\tt\ttyperef:typename:int\tfile:\nsslCheckOptions\tsslscan.h\t/^struct sslCheckOptions$/;\"\ts\nsslCipher\tsslscan.h\t/^struct sslCipher$/;\"\ts\nsslMethod\tsslscan.h\t/^    const SSL_METHOD *sslMethod;$/;\"\tm\tstruct:sslCipher\ttyperef:typename:const SSL_METHOD *\nsslVersion\tsslscan.h\t/^    int sslVersion;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nssl_all\tsslscan.h\t/^#define ssl_all /;\"\td\nssl_print_tmp_key\tsslscan.c\t/^int ssl_print_tmp_key(struct sslCheckOptions *options, SSL *s)$/;\"\tf\ttyperef:typename:int\nssl_v2\tsslscan.h\t/^#define ssl_v2 /;\"\td\nssl_v3\tsslscan.h\t/^#define ssl_v3 /;\"\td\nsslbugs\tsslscan.h\t/^    int sslbugs;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_ftp\tsslscan.h\t/^    int starttls_ftp;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_imap\tsslscan.h\t/^    int starttls_imap;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_irc\tsslscan.h\t/^    int starttls_irc;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_ldap\tsslscan.h\t/^    int starttls_ldap;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_mysql\tsslscan.h\t/^    int starttls_mysql;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_pop3\tsslscan.h\t/^    int starttls_pop3;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_psql\tsslscan.h\t/^    int starttls_psql;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_smtp\tsslscan.h\t/^    int starttls_smtp;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nstarttls_xmpp\tsslscan.h\t/^    int starttls_xmpp;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nsupported\tsslscan.h\t/^    int supported;$/;\"\tm\tstruct:renegotiationOutput\ttyperef:typename:int\ntargets\tsslscan.h\t/^    int targets;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\ntbsResponseData\tsslscan.h\t/^    OCSP_RESPDATA tbsResponseData;$/;\"\tm\tstruct:ocsp_basic_response_st\ttyperef:typename:OCSP_RESPDATA\ntcpConnect\tsslscan.c\t/^int tcpConnect(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\ntestCipher\tsslscan.c\t/^int testCipher(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ntestCompression\tsslscan.c\t/^int testCompression(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ntestConnection\tsslscan.c\t/^int testConnection(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\ntestFallback\tsslscan.c\t/^int testFallback(struct sslCheckOptions *options,  const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ntestHeartbleed\tsslscan.c\t/^int testHeartbleed(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ntestHost\tsslscan.c\t/^int testHost(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:int\ntestMissingCiphers\tsslscan.c\t/^int testMissingCiphers(struct sslCheckOptions *options, unsigned int tls_version) {$/;\"\tf\ttyperef:typename:int\ntestProtocolCiphers\tsslscan.c\t/^int testProtocolCiphers(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ntestRenegotiation\tsslscan.c\t/^int testRenegotiation(struct sslCheckOptions *options, const SSL_METHOD *sslMethod)$/;\"\tf\ttyperef:typename:int\ntestSignatureAlgorithms\tsslscan.c\t/^int testSignatureAlgorithms(struct sslCheckOptions *options) {$/;\"\tf\ttyperef:typename:int\ntestSupportedGroups\tsslscan.c\t/^int testSupportedGroups(struct sslCheckOptions *options) {$/;\"\tf\ttyperef:typename:int\nthisUpdate\tsslscan.h\t/^    ASN1_GENERALIZEDTIME *thisUpdate;$/;\"\tm\tstruct:ocsp_single_response_st\ttyperef:typename:ASN1_GENERALIZEDTIME *\ntimeout\tsslscan.h\t/^    struct timeval timeout;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:struct:timeval\ntimersub\tsslscan.c\t/^    #define timersub(/;\"\td\tfile:\ntls10_supported\tsslscan.h\t/^    unsigned int tls10_supported;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:unsigned int\ntls11_supported\tsslscan.h\t/^    unsigned int tls11_supported;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:unsigned int\ntls12_supported\tsslscan.h\t/^    unsigned int tls12_supported;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:unsigned int\ntls13_supported\tsslscan.h\t/^    unsigned int tls13_supported;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:unsigned int\ntlsExtensionAddDefaultKeyShare\tsslscan.c\t/^void tlsExtensionAddDefaultKeyShare(bs *tls_extensions) {$/;\"\tf\ttyperef:typename:void\ntlsExtensionAddTLSv1_3\tsslscan.c\t/^void tlsExtensionAddTLSv1_3(bs *tls_extensions) {$/;\"\tf\ttyperef:typename:void\ntlsExtensionUpdateLength\tsslscan.c\t/^void tlsExtensionUpdateLength(bs *tls_extensions) {$/;\"\tf\ttyperef:typename:void\ntls_all\tsslscan.h\t/^#define tls_all /;\"\td\ntls_reneg_init\tsslscan.c\t/^void tls_reneg_init(struct sslCheckOptions *options)$/;\"\tf\ttyperef:typename:void\ntls_v10\tsslscan.h\t/^#define tls_v10 /;\"\td\ntls_v11\tsslscan.h\t/^#define tls_v11 /;\"\td\ntls_v12\tsslscan.h\t/^#define tls_v12 /;\"\td\ntls_v13\tsslscan.h\t/^#define tls_v13 /;\"\td\ntrue\tsslscan.h\t/^#define true /;\"\td\ntype\tsslscan.h\t/^    int type;$/;\"\tm\tstruct:ocsp_cert_status_st\ttyperef:typename:int\ntype\tsslscan.h\t/^    int type;$/;\"\tm\tstruct:ocsp_responder_id_st\ttyperef:typename:int\nunknown\tsslscan.h\t/^        ASN1_NULL *unknown;$/;\"\tm\tunion:ocsp_cert_status_st::__anonf49f55d2020a\ttyperef:typename:ASN1_NULL *\nuse_unsafe_renegotiation_flag\tsslscan.c\t/^static int use_unsafe_renegotiation_flag = 0;$/;\"\tv\ttyperef:typename:int\tfile:\nuse_unsafe_renegotiation_op\tsslscan.c\t/^static int use_unsafe_renegotiation_op = 0;$/;\"\tv\ttyperef:typename:int\tfile:\nvalue\tsslscan.h\t/^    } value;$/;\"\tm\tstruct:ocsp_cert_status_st\ttyperef:union:ocsp_cert_status_st::__anonf49f55d2020a\nvalue\tsslscan.h\t/^    } value;$/;\"\tm\tstruct:ocsp_responder_id_st\ttyperef:union:ocsp_responder_id_st::__anonf49f55d2010a\nverbose\tsslscan.h\t/^    int verbose;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\nversion\tsslscan.h\t/^    ASN1_INTEGER *version;$/;\"\tm\tstruct:ocsp_response_data_st\ttyperef:typename:ASN1_INTEGER *\nversion\tsslscan.h\t/^    const char *version;$/;\"\tm\tstruct:sslCipher\ttyperef:typename:const char *\nxmlOutput\tsslscan.h\t/^    FILE *xmlOutput;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:FILE *\nxml_to_stdout\tsslscan.c\t/^static int xml_to_stdout = 0;$/;\"\tv\ttyperef:typename:int\tfile:\nxmpp_server\tsslscan.h\t/^    int xmpp_server;$/;\"\tm\tstruct:sslCheckOptions\ttyperef:typename:int\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "win32bit-compat.h",
          "type": "blob",
          "size": 5.283203125,
          "content": "/* The file below was copied from glibc v2.26 (resolv/inet_ntop.c). */\n/* This is needed for legacy 32-bit Windows builds only. */\n\n#include <ws2tcpip.h>\ntypedef unsigned char u_char;\n#define __set_errno(X)\n#define libc_hidden_def(X)\n#define internal_function\n#define NS_IN6ADDRSZ    16\n#define NS_INT16SZ      2\n\n/*\n * Copyright (c) 1996-1999 by Internet Software Consortium.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS\n * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE\n * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n * SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/types.h>\n/*#include <sys/socket.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <arpa/nameser.h>*/\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifdef SPRINTF_CHAR\n# define SPRINTF(x) strlen(sprintf/**/x)\n#else\n# define SPRINTF(x) ((size_t)sprintf x)\n#endif\n\n/*\n * WARNING: Don't even consider trying to compile this on a system where\n * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.\n */\n\nstatic const char *inet_ntop4 (const u_char *src, char *dst, socklen_t size)\n     internal_function;\nstatic const char *inet_ntop6 (const u_char *src, char *dst, socklen_t size)\n     internal_function;\n\n/* char *\n * inet_ntop(af, src, dst, size)\n *\tconvert a network format address to presentation format.\n * return:\n *\tpointer to presentation format address (`dst'), or NULL (see errno).\n * author:\n *\tPaul Vixie, 1996.\n */\nconst char *\ninet_ntop (int af, const void *src, char *dst, socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, size));\n\tdefault:\n\t\t__set_errno (EAFNOSUPPORT);\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}\nlibc_hidden_def (inet_ntop)\n\n/* const char *\n * inet_ntop4(src, dst, size)\n *\tformat an IPv4 address\n * return:\n *\t`dst' (as a const)\n * notes:\n *\t(1) uses no statics\n *\t(2) takes a u_char* not an in_addr as input\n * author:\n *\tPaul Vixie, 1996.\n */\nstatic const char *\ninternal_function\ninet_ntop4 (const u_char *src, char *dst, socklen_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\n\tif (SPRINTF((tmp, fmt, src[0], src[1], src[2], src[3])) >= size) {\n\t\t__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\treturn strcpy(dst, tmp);\n}\n\n/* const char *\n * inet_ntop6(src, dst, size)\n *\tconvert IPv6 binary address into presentation (printable) format\n * author:\n *\tPaul Vixie, 1996.\n */\nstatic const char *\ninternal_function\ninet_ntop6 (const u_char *src, char *dst, socklen_t size)\n{\n\t/*\n\t * Note that int32_t and int16_t need only be \"at least\" large enough\n\t * to contain a value of the specified size.  On some systems, like\n\t * Crays, there is no such thing as an integer variable with 16 bits.\n\t * Keep this in mind if you think this function should have been coded\n\t * to use pointer overlays.  All the world's not a VAX.\n\t */\n\tchar tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"], *tp;\n\tstruct { int base, len; } best, cur;\n\tu_int words[NS_IN6ADDRSZ / NS_INT16SZ];\n\tint i;\n\n\t/*\n\t * Preprocess:\n\t *\tCopy the input (bytewise) array into a wordwise array.\n\t *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n\t */\n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < NS_IN6ADDRSZ; i += 2)\n\t\twords[i / 2] = (src[i] << 8) | src[i + 1];\n\tbest.base = -1;\n\tcur.base = -1;\n\tbest.len = 0;\n\tcur.len = 0;\n\tfor (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t/*\n\t * Format the result.\n\t */\n\ttp = tmp;\n\tfor (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n\t\t/* Are we inside the best run of 0x00's? */\n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base)\n\t\t\t\t*tp++ = ':';\n\t\t\tcontinue;\n\t\t}\n\t\t/* Are we following an initial run of 0x00s or any real hex? */\n\t\tif (i != 0)\n\t\t\t*tp++ = ':';\n\t\t/* Is this address an encapsulated IPv4? */\n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\ttp += SPRINTF((tp, \"%x\", words[i]));\n\t}\n\t/* Was it a trailing run of 0x00's? */\n\tif (best.base != -1 && (best.base + best.len) ==\n\t    (NS_IN6ADDRSZ / NS_INT16SZ))\n\t\t*tp++ = ':';\n\t*tp++ = '\\0';\n\n\t/*\n\t * Check for overflow, copy, and we're done.\n\t */\n\tif ((socklen_t)(tp - tmp) > size) {\n\t\t__set_errno (ENOSPC);\n\t\treturn (NULL);\n\t}\n\treturn strcpy(dst, tmp);\n}\n"
        }
      ]
    }
  ]
}