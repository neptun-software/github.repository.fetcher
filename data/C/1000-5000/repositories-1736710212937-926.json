{
  "metadata": {
    "timestamp": 1736710212937,
    "page": 926,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zlib-ng/zlib-ng",
      "stars": 1616,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".codecov.yaml",
          "type": "blob",
          "size": 0.4970703125,
          "content": "codecov:\n  max_report_age: off\n  notify:\n    wait_for_ci: false\n  require_ci_to_pass: false\ncomment:\n  require_base: false\n  require_head: false\ncoverage:\n  status:\n    project:\n      default:\n        threshold: 0.07\nfixes:\n- '/home/actions-runner/_work/zlib-ng/zlib-ng::'\n- '/home/actions-runner/_work/zlib-ng/zlib-ng/build/::'\nignore:\n- usr/include/.*\n- /usr/include/.*\n- /build/usr/include/.*\n- usr/lib/.*\n- /usr/lib/.*\n- /build/usr/lib/.*\n- usr/lib64/.*\n- /usr/lib64/.*\n- /build/usr/lib64/.*\n- _deps/**/*\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.28125,
          "content": "# By default, enforce LF line-endings on all files that are not considered binary files!\n* text=auto eol=lf\n\ncrc32_braid_tbl.h hooks-max-size=1000000\n\n# Don't export git/github-related files in tar/zip archives\n/.github export-ignore\n.gitattributes export-ignore\n.gitignore export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.064453125,
          "content": "*.diff\n*.patch\n*.orig\n*.rej\n\n*~\n*.a\n*.lo\n*.o\n*.dylib\n\n*.gcda\n*.gcno\n*.gcov\n\n/benchmark_zlib\n/example\n/example64\n/examplesh\n/gtest_zlib\n/libz.so*\n/libz-ng.so*\n/makefixed\n/minigzip\n/minigzip64\n/minigzipsh\n/switchlevels\n/zlib.pc\n/zlib-ng.pc\n/zconf-ng.h.included\n/zlib_name_mangling-ng.h\n/zlib-ng.h\n\n.DS_Store\n*_fuzzer\n*.obj\n*.exe\n*.pdb\n*.exp\n*.lib\n*.dll\n*.res\nfoo.gz\n*.manifest\n*.opensdf\n*.sln\n*.sdf\n*.vcxproj\n*.vcxproj.filters\n*.vcxproj.user\n.vs\n\nCMakeCache.txt\nCMakeFiles\nTesting\n/*.cmake\n*.stackdump\n*._h\nzconf.h\nzconf.h.cmakein\nzconf.h.included\nzconf-ng.h\nzconf-ng.h.cmakein\nztest*\n/test/CTestTestfile.cmake\n/test/cmake_install.cmake\n/.cache\n\nconfigure.log\na.out\n\n/Makefile\n/arch/arm/Makefile\n/arch/generic/Makefile\n/arch/power/Makefile\n/arch/x86/Makefile\n.kdev4\n*.kdev4\nMakefile.tmp\n/makecrct\n/maketrees\ngzread.c\n\n/Debug\n/example.dir\n/minigzip.dir\n/zlib.dir\n/zlibstatic.dir\n/test/*.dir/\n/build/\n/build[.-]*/\n/btmp[12]/\n/pkgtmp[12]/\n\n/.idea\n/cmake-build-debug\n/x64/Debug/\n/x64/Release/\n/win32/Debug/\n/win32/Release/\n/ARM*/Debug/\n/ARM*/Release/\nMinSizeRel\nRelWithDebInfo\n/_deps/googletest*\n"
        },
        {
          "name": ".shellcheckrc",
          "type": "blob",
          "size": 0.8828125,
          "content": "disable=SC2140,SC2086,SC2046,SC2015,SC1097,SC1035,SC1036,SC1007,SC2154,SC2155,SC2000,SC2034,SC2016,SC1091,SC1090,SC2212,SC2143,SC2129,SC2102,SC2069,SC1041,SC1042,SC1044,SC1046,SC1119,SC1110,SC1111,SC1112,SC1102,SC1105,SC1101,SC1004,SC1003,SC1012,SC2068,SC2065,SC2064,SC2063,SC2059,SC2053,SC2048,SC2044,SC2032,SC2031,SC2030,SC2029,SC2025,SC2024,SC2022,SC2018,SC2019,SC2017,SC2014,SC2013,SC2012,SC2009,SC2001,SC2098,SC2096,SC2094,SC2091,SC2092,SC2088,SC2087,SC2076,SC2072,SC2071,SC2223,SC2221,SC2222,SC2217,SC2207,SC2206,SC2205,SC2190,SC2188,SC2187,SC2185,SC2179,SC2178,SC2174,SC2168,SC2167,SC2163,SC2161,SC2160,SC2153,SC2150,SC2148,SC2147,SC2146,SC2142,SC2139,SC2126,SC2123,SC2120,SC2119,SC2117,SC2114,SC1117,SC2164,SC1083,SC2004,SC2125,SC2128,SC2011,SC1008,SC1019,SC2093,SC1132,SC1129,SC2236,SC2237,SC2231,SC2230,SC2229,SC2106,SC2102,SC2243,SC2244,SC2245,SC2247,SC2248,SC2249,SC2250,SC2251,SC2252,SC2181\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 54.921875,
          "content": "cmake_minimum_required(VERSION 3.5.1...3.29.0)\nif(CMAKE_VERSION VERSION_LESS 3.12)\n    cmake_policy(VERSION ${CMAKE_VERSION})\nendif()\nmessage(STATUS \"Using CMake version ${CMAKE_VERSION}\")\n\nif(POLICY CMP0169)\n    cmake_policy(SET CMP0169 OLD) # CMake 3.30: call FetchContent_Populate() with just the name of a dependency\nendif()\n\n# If not specified on the command line, enable C11 as the default\n# Configuration items that affect the global compiler environment standards\n# should be issued before the \"project\" command.\nif(NOT DEFINED CMAKE_C_STANDARD)\n    set(CMAKE_C_STANDARD 11)          # The C standard whose features are requested to build this target\nendif()\nif(NOT DEFINED CMAKE_C_STANDARD_REQUIRED)\n    set(CMAKE_C_STANDARD_REQUIRED ON) # Boolean describing whether the value of C_STANDARD is a requirement\nendif()\nif(NOT DEFINED CMAKE_C_EXTENSIONS)\n    set(CMAKE_C_EXTENSIONS OFF)       # Boolean specifying whether compiler specific extensions are requested\nendif()\nset(VALID_C_STANDARDS \"99\" \"11\")\nif(NOT CMAKE_C_STANDARD IN_LIST VALID_C_STANDARDS)\n    MESSAGE(FATAL_ERROR \"CMAKE_C_STANDARD:STRING=${CMAKE_C_STANDARD} not in known standards list\\n ${VALID_C_STANDARDS}\")\nendif()\n\n# Parse the full version number from zlib.h.in and include in ZLIB_FULL_VERSION\nfile(READ ${CMAKE_CURRENT_SOURCE_DIR}/zlib.h.in _zlib_h_contents)\nstring(REGEX REPLACE \".*#define[ \\t]+ZLIB_VERSION[ \\t]+\\\"([0-9]+.[0-9]+.[0-9]+).*\\\".*\"\n        \"\\\\1\" ZLIB_HEADER_VERSION ${_zlib_h_contents})\nstring(REGEX REPLACE \".*#define[ \\t]+ZLIBNG_VERSION[ \\t]+\\\"([-0-9A-Za-z.]+)\\\".*\"\n        \"\\\\1\" ZLIBNG_HEADER_VERSION ${_zlib_h_contents})\nmessage(STATUS \"ZLIB_HEADER_VERSION: ${ZLIB_HEADER_VERSION}\")\nmessage(STATUS \"ZLIBNG_HEADER_VERSION: ${ZLIBNG_HEADER_VERSION}\")\n\nproject(zlib VERSION ${ZLIB_HEADER_VERSION} LANGUAGES C)\n\ninclude(CheckTypeSize)\ninclude(CheckSymbolExists)\ninclude(CheckFunctionExists)\ninclude(CheckIncludeFile)\ninclude(CheckCSourceCompiles)\ninclude(CheckCSourceRuns)\ninclude(CheckCCompilerFlag)\ninclude(CMakeDependentOption)\ninclude(CMakePackageConfigHelpers)\ninclude(FeatureSummary)\n\ninclude(cmake/detect-arch.cmake)\ninclude(cmake/detect-install-dirs.cmake)\ninclude(cmake/detect-coverage.cmake)\ninclude(cmake/detect-intrinsics.cmake)\ninclude(cmake/detect-sanitizer.cmake)\ninclude(cmake/fallback-macros.cmake)\n\nif(CMAKE_TOOLCHAIN_FILE)\n    message(STATUS \"Using CMake toolchain: ${CMAKE_TOOLCHAIN_FILE}\")\nendif()\n\n# Make sure we use an appropriate BUILD_TYPE by default, \"Release\" to be exact\n# this should select the maximum generic optimisation on the current platform (i.e. -O3 for gcc/clang)\nget_property(GENERATOR_IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(NOT GENERATOR_IS_MULTI_CONFIG)\n    if(NOT CMAKE_BUILD_TYPE)\n        set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING\n            \"Choose the type of build, standard options are: Debug Release RelWithDebInfo MinSizeRel.\"\n            FORCE)\n        add_feature_info(CMAKE_BUILD_TYPE 1 \"Build type: ${CMAKE_BUILD_TYPE} (default)\")\n    else()\n        add_feature_info(CMAKE_BUILD_TYPE 1 \"Build type: ${CMAKE_BUILD_TYPE} (selected)\")\n    endif()\nendif()\n\n#\n# Options parsing\n#\noption(WITH_GZFILEOP \"Compile with support for gzFile related functions\" ON)\noption(ZLIB_COMPAT \"Compile with zlib compatible API\" OFF)\noption(ZLIB_ENABLE_TESTS \"Build test binaries\" ON)\noption(ZLIBNG_ENABLE_TESTS \"Test zlib-ng specific API\" ON)\noption(WITH_GTEST \"Build gtest_zlib\" ON)\noption(WITH_FUZZERS \"Build test/fuzz\" OFF)\noption(WITH_BENCHMARKS \"Build test/benchmarks\" OFF)\noption(WITH_BENCHMARK_APPS \"Build application benchmarks\" OFF)\noption(WITH_OPTIM \"Build with optimisation\" ON)\noption(WITH_REDUCED_MEM \"Reduced memory usage for special cases (reduces performance)\" OFF)\noption(WITH_NEW_STRATEGIES \"Use new strategies\" ON)\noption(WITH_NATIVE_INSTRUCTIONS\n    \"Instruct the compiler to use the full instruction set on this host (gcc/clang -march=native)\" OFF)\noption(WITH_RUNTIME_CPU_DETECTION \"Build with runtime detection of CPU architecture\" ON)\noption(WITH_MAINTAINER_WARNINGS \"Build with project maintainer warnings\" OFF)\noption(WITH_CODE_COVERAGE \"Enable code coverage reporting\" OFF)\noption(WITH_INFLATE_STRICT \"Build with strict inflate distance checking\" OFF)\noption(WITH_INFLATE_ALLOW_INVALID_DIST \"Build with zero fill for inflate invalid distances\" OFF)\n\nset(ZLIB_SYMBOL_PREFIX \"\" CACHE STRING \"Give this prefix to all publicly exported symbols.\nUseful when embedding into a larger library.\nDefault is no prefix (empty prefix).\")\n\n# Add multi-choice option\nset(WITH_SANITIZER AUTO CACHE STRING \"Enable sanitizer support\")\nset_property(CACHE WITH_SANITIZER PROPERTY STRINGS \"Memory\" \"Address\" \"Undefined\" \"Thread\")\n\nif(BASEARCH_ARM_FOUND)\n    option(WITH_ACLE \"Build with ACLE\" ON)\n    option(WITH_NEON \"Build with NEON intrinsics\" ON)\n    cmake_dependent_option(WITH_ARMV6 \"Build with ARMv6 SIMD\" ON \"NOT ARCH MATCHES \\\"aarch64\\\"\" OFF)\nelseif(BASEARCH_PPC_FOUND)\n    option(WITH_ALTIVEC \"Build with AltiVec (VMX) optimisations for PowerPC\" ON)\n    option(WITH_POWER8 \"Build with optimisations for POWER8\" ON)\n    option(WITH_POWER9 \"Build with optimisations for POWER9\" ON)\nelseif(BASEARCH_RISCV_FOUND)\n    option(WITH_RVV \"Build with RVV intrinsics\" ON)\nelseif(BASEARCH_S360_FOUND)\n    option(WITH_DFLTCC_DEFLATE \"Build with DFLTCC intrinsics for compression on IBM Z\" OFF)\n    option(WITH_DFLTCC_INFLATE \"Build with DFLTCC intrinsics for decompression on IBM Z\" OFF)\n    option(WITH_CRC32_VX \"Build with vectorized CRC32 on IBM Z\" ON)\nelseif(BASEARCH_X86_FOUND)\n    option(WITH_SSE2 \"Build with SSE2\" ON)\n    cmake_dependent_option(WITH_SSSE3 \"Build with SSSE3\" ON \"WITH_SSE2\" OFF)\n    cmake_dependent_option(WITH_SSE42 \"Build with SSE42\" ON \"WITH_SSSE3\" OFF)\n    cmake_dependent_option(WITH_PCLMULQDQ \"Build with PCLMULQDQ\" ON \"WITH_SSE42\" OFF)\n    cmake_dependent_option(WITH_AVX2 \"Build with AVX2\" ON \"WITH_SSE42\" OFF)\n    cmake_dependent_option(WITH_AVX512 \"Build with AVX512\" ON \"WITH_AVX2\" OFF)\n    cmake_dependent_option(WITH_AVX512VNNI \"Build with AVX512 VNNI extensions\" ON \"WITH_AVX512\" OFF)\n    cmake_dependent_option(WITH_VPCLMULQDQ \"Build with VPCLMULQDQ\" ON \"WITH_PCLMULQDQ;WITH_AVX512\" OFF)\nendif()\n\noption(INSTALL_UTILS \"Copy minigzip and minideflate during install\" OFF)\n\nmark_as_advanced(FORCE\n    ZLIB_SYMBOL_PREFIX\n    WITH_REDUCED_MEM\n    WITH_ACLE WITH_NEON\n    WITH_ARMV6\n    WITH_DFLTCC_DEFLATE\n    WITH_DFLTCC_INFLATE\n    WITH_CRC32_VX\n    WITH_AVX2 WITH_SSE2\n    WITH_SSSE3 WITH_SSE42\n    WITH_PCLMULQDQ\n    WITH_ALTIVEC\n    WITH_POWER8\n    WITH_POWER9\n    WITH_RVV\n    WITH_INFLATE_STRICT\n    WITH_INFLATE_ALLOW_INVALID_DIST\n    INSTALL_UTILS\n    )\n\nif(ZLIB_COMPAT)\n    add_definitions(-DZLIB_COMPAT)\n    set(WITH_GZFILEOP ON)\n    set(SUFFIX \"\")\n    set(ZLIB_FULL_VERSION ${ZLIB_HEADER_VERSION}.zlib-ng)\n    set(EXPORT_NAME ZLIB)\nelse()\n    set(SUFFIX \"-ng\")\n    set(ZLIB_FULL_VERSION ${ZLIBNG_HEADER_VERSION})\n    set(EXPORT_NAME zlib-ng)\nendif()\n\nif(WITH_GZFILEOP)\n    add_definitions(-DWITH_GZFILEOP)\nendif()\n\nif(CMAKE_C_COMPILER_ID MATCHES \"^Intel\")\n    if(CMAKE_HOST_UNIX)\n        set(WARNFLAGS -Wall)\n        set(WARNFLAGS_MAINTAINER -Wall -Wcheck -Wremarks)\n        set(WARNFLAGS_DISABLE)\n    else()\n        set(WARNFLAGS /Wall)\n        set(WARNFLAGS_MAINTAINER /W5)\n        set(WARNFLAGS_DISABLE)\n    endif()\n    check_c_compiler_flag(-diag-disable=10441 HAVE_DIAG_10441)\n    if(HAVE_DIAG_10441)\n        list(APPEND WARNFLAGS_DISABLE \"-diag-disable=10441\")\n        set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -diag-disable=10441\")\n        set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -diag-disable=10441\")\n    endif()\nelseif(MSVC)\n    # Minimum supported MSVC version is 1800 = Visual Studio 12.0/2013\n    # See also https://cmake.org/cmake/help/latest/variable/MSVC_VERSION.html\n    if(MSVC_VERSION VERSION_LESS 1800)\n        message(SEND_ERROR \"Unsupported Visual Studio compiler version (requires 2013 or later).\")\n    endif()\n    # TODO. ICC can be used through MSVC. I'm not sure if we'd ever see that combination\n    # (who'd use cmake from an IDE...) but checking for ICC before checking for MSVC should\n    # avoid mistakes.\n    # /Oi ?\n    set(WARNFLAGS /W3 /w34242 /WX)\n    set(WARNFLAGS_MAINTAINER /W4)\n    set(WARNFLAGS_DISABLE /wd4206 /wd4054 /wd4324)\n    if(BASEARCH_ARM_FOUND)\n        add_definitions(-D_ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE)\n        if(NOT \"${ARCH}\" MATCHES \"aarch64\")\n            set(NEONFLAG \"/arch:VFPv4\")\n        endif()\n    endif()\nelseif(CMAKE_C_COMPILER_ID MATCHES \"GNU\" OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n    # Enable warnings in GCC and Clang\n    set(WARNFLAGS -Wall)\n    set(WARNFLAGS_MAINTAINER -Wextra)\n    set(WARNFLAGS_DISABLE)\n    # Check whether -fno-lto is available\n    set(CMAKE_REQUIRED_FLAGS \"-fno-lto\")\n    check_c_source_compiles(\n        \"int main() { return 0; }\"\n        FNO_LTO_AVAILABLE FAIL_REGEX \"not supported\")\n    set(CMAKE_REQUIRED_FLAGS)\n    if(FNO_LTO_AVAILABLE)\n        set(ZNOLTOFLAG \"-fno-lto\")\n    endif()\n    if(NOT WITH_NATIVE_INSTRUCTIONS)\n        if(BASEARCH_ARM_FOUND)\n            if(\"${ARCH}\" MATCHES \"arm\" AND NOT CMAKE_C_FLAGS MATCHES \"-mfloat-abi\")\n                # Auto-detect support for ARM floating point ABI\n                check_include_file(features.h HAVE_FEATURES_H)\n                if(HAVE_FEATURES_H)\n                    set(CMAKE_REQUIRED_FLAGS -mfloat-abi=softfp)\n                    check_c_source_compiles(\n                        \"#include <features.h>\n                        int main() { return 0; }\"\n                        HAVE_FLOATABI_SOFTFP)\n                    if(HAVE_FLOATABI_SOFTFP)\n                        set(FLOATABI -mfloat-abi=softfp)\n                    else()\n                        set(CMAKE_REQUIRED_FLAGS -mfloat-abi=hard)\n                        check_c_source_compiles(\n                            \"#include <features.h>\n                            int main() { return 0; }\"\n                            HAVE_FLOATABI_HARD)\n                        if(HAVE_FLOATABI_HARD)\n                            set(FLOATABI -mfloat-abi=hard)\n                        endif()\n                    endif()\n                    set(CMAKE_REQUIRED_FLAGS)\n                endif()\n                if(FLOATABI)\n                    message(STATUS \"ARM floating point arch: ${FLOATABI}\")\n                    add_compile_options(${FLOATABI})\n                else()\n                    message(STATUS \"ARM floating point arch not auto-detected\")\n                endif()\n            endif()\n        endif()\n        # Disable LTO unless Native Instructions are enabled\n        if(FNO_LTO_AVAILABLE)\n            set(NOLTOFLAG ${ZNOLTOFLAG})\n        endif()\n    endif()\n    if(MINGW)\n        # Add `-Wno-pedantic-ms-format` only if the toolchain supports it\n        check_c_compiler_flag(-Wno-pedantic-ms-format HAVE_NO_PEDANTIC_MS_FORMAT)\n        if(HAVE_NO_PEDANTIC_MS_FORMAT)\n            list(APPEND WARNFLAGS_DISABLE -Wno-pedantic-ms-format)\n        endif()\n    endif()\nendif()\n\n# Set native march/mcpu\nif(WITH_NATIVE_INSTRUCTIONS)\n    if(NATIVE_ARCH_OVERRIDE)\n        message(STATUS \"WARNING: WITH_NATIVE_INSTRUCTIONS enabled, but running with NATIVE_ARCH_OVERRIDE: ${NATIVE_ARCH_OVERRIDE}\")\n        set(NATIVEFLAG \"${NATIVE_ARCH_OVERRIDE}\")\n    else()\n        if(CMAKE_C_COMPILER_ID MATCHES \"GNU\" OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n            check_c_compiler_flag(-march=native HAVE_MARCH_NATIVE)\n            if(HAVE_MARCH_NATIVE)\n                set(NATIVEFLAG \"-march=native\")\n            else()\n                check_c_compiler_flag(-mcpu=native HAVE_MCPU_NATIVE)\n                if(HAVE_MCPU_NATIVE)\n                    set(NATIVEFLAG \"-mcpu=native\")\n                endif()\n            endif()\n            # Fall through\n        endif()\n    endif()\n    if(NATIVEFLAG)\n        # Apply flags to all source files and compilation checks\n        if(WIN32)\n            separate_arguments(NATIVEOPTIONS WINDOWS_COMMAND \"${NATIVEFLAG}\")\n        else()\n            separate_arguments(NATIVEOPTIONS UNIX_COMMAND \"${NATIVEFLAG}\")\n        endif()\n        add_compile_options(${NATIVEOPTIONS})\n        set(WITH_RUNTIME_CPU_DETECTION OFF)\n    else()\n        message(STATUS \"Ignoring WITH_NATIVE_INSTRUCTIONS; not implemented yet on this configuration\")\n        set(WITH_NATIVE_INSTRUCTIONS OFF)\n    endif()\nendif()\n\n# Compile without functable or CPU detection\nif(NOT WITH_RUNTIME_CPU_DETECTION)\n    if(MSVC AND BASEARCH_X86_FOUND)\n        message(STATUS \"WARNING: Microsoft Visual Studio does not support compile time detection of CPU features for \\\"/arch\\\" before \\\"AVX\\\"\")\n        # Workaround for MSVC. By default MSVC does not define the __SSE*__ macros.\n        # Fix it if AVX is enabled.\n        set(CMAKE_REQUIRED_FLAGS \"${NATIVEFLAG}\")\n        check_c_source_compiles(\n            \"#ifndef __AVX__\n            #  error \\\"AVX is not enabled.\\\"\n            #endif\n            int main(void) { return 0; }\"\n            MSVC_IS_ENABLED_AVX\n        )\n        set(CMAKE_REQUIRED_FLAGS)\n        if(MSVC_IS_ENABLED_AVX)\n            add_definitions(\n                -D__SSE__=1\n                -D__SSE2__=1\n                -D__SSE3__=1\n                -D__SSSE3__=1\n                -D__SSE4_1__=1\n                -D__SSE4_2__=1\n                -D__PCLMUL__=1\n            )\n        endif()\n    endif()\n    add_definitions(-DDISABLE_RUNTIME_CPU_DETECTION)\nendif()\n\n# Force disable LTO if WITH_NATIVE_INSTRUCTIONS is not active\nif(NOT WITH_NATIVE_INSTRUCTIONS)\n    set(CMAKE_INTERPROCEDURAL_OPTIMIZATION OFF)\n    foreach(_cfg_name IN LISTS CMAKE_CONFIGURATION_TYPES)\n        string(TOUPPER \"${_cfg_name}\" _cfg_name_uc)\n        set(CMAKE_INTERPROCEDURAL_OPTIMIZATION_${_cfg_name_uc} OFF)\n    endforeach()\nendif()\n\n# Apply warning compiler flags\nif(WITH_MAINTAINER_WARNINGS)\n    add_compile_options(${WARNFLAGS} ${WARNFLAGS_MAINTAINER} ${WARNFLAGS_DISABLE})\nelse()\n    add_compile_options(${WARNFLAGS} ${WARNFLAGS_DISABLE})\nendif()\n\n# Set code coverage compiler flags\nif(WITH_CODE_COVERAGE)\n    add_code_coverage()\nendif()\n\n# Replace optimization level 3 added by default with level 2\nif(NOT WITH_CODE_COVERAGE AND NOT MSVC AND NOT CMAKE_C_FLAGS MATCHES \"([\\\\/\\\\-]O)3\")\n    string(REGEX REPLACE \"([\\\\/\\\\-]O)3\" \"\\\\12\"\n        CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE}\")\nendif()\n\n# Force Visual C++ to use UTF-8\nif(MSVC)\n    if (NOT CMAKE_C_FLAGS MATCHES \"[\\\\/\\\\-]utf-8\")\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /utf-8\")\n    endif()\n    if (NOT CMAKE_CXX_FLAGS MATCHES \"[\\\\/\\\\-]utf-8\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /utf-8\")\n    endif()\nendif()\n\n#\n# Check for standard/system includes\n#\ncheck_include_file(arm_acle.h  HAVE_ARM_ACLE_H)\nif(HAVE_ARM_ACLE_H)\n    add_definitions(-DHAVE_ARM_ACLE_H)\nendif()\ncheck_include_file(sys/auxv.h  HAVE_SYS_AUXV_H)\nif(HAVE_SYS_AUXV_H)\n    add_definitions(-DHAVE_SYS_AUXV_H)\nendif()\ncheck_include_file(sys/sdt.h   HAVE_SYS_SDT_H)\nif(HAVE_SYS_SDT_H)\n    add_definitions(-DHAVE_SYS_SDT_H)\nendif()\ncheck_include_file(unistd.h    HAVE_UNISTD_H)\n\n#\n# Check for Linux includes\n#\ncheck_include_file(linux/auxvec.h HAVE_LINUX_AUXVEC_H)\nif(HAVE_LINUX_AUXVEC_H)\n    add_definitions(-DHAVE_LINUX_AUXVEC_H)\nendif()\n\n#\n# Check to see if we have large file support\n#\nset(CMAKE_REQUIRED_DEFINITIONS -D_LARGEFILE64_SOURCE=1 -D__USE_LARGEFILE64)\ncheck_type_size(off64_t OFF64_T)\nif(HAVE_OFF64_T)\n    add_definitions(-D_LARGEFILE64_SOURCE=1 -D__USE_LARGEFILE64)\nelse()\n    check_type_size(_off64_t _OFF64_T)\n    if(HAVE__OFF64_T)\n        add_definitions(-D_LARGEFILE64_SOURCE=1 -D__USE_LARGEFILE64)\n    else()\n        check_type_size(__off64_t __OFF64_T)\n    endif()\nendif()\nset(CMAKE_REQUIRED_DEFINITIONS) # clear variable\n\n#\n# Check for fseeko and other optional functions\n#\ncheck_function_exists(fseeko HAVE_FSEEKO)\nif(NOT HAVE_FSEEKO)\n    add_definitions(-DNO_FSEEKO)\nendif()\n\ncheck_function_exists(strerror HAVE_STRERROR)\nif(NOT HAVE_STRERROR)\n    add_definitions(-DNO_STRERROR)\nendif()\n\nset(CMAKE_REQUIRED_DEFINITIONS -D_POSIX_C_SOURCE=200112L)\ncheck_symbol_exists(posix_memalign stdlib.h HAVE_POSIX_MEMALIGN)\nif(HAVE_POSIX_MEMALIGN)\n    add_definitions(-DHAVE_POSIX_MEMALIGN)\nendif()\nset(CMAKE_REQUIRED_DEFINITIONS)\n\nset(CMAKE_REQUIRED_DEFINITIONS -D_ISOC11_SOURCE=1)\ncheck_symbol_exists(aligned_alloc stdlib.h HAVE_ALIGNED_ALLOC)\nif(HAVE_ALIGNED_ALLOC)\n    add_definitions(-DHAVE_ALIGNED_ALLOC)\nendif()\nset(CMAKE_REQUIRED_DEFINITIONS)\n\nif(WITH_SANITIZER STREQUAL \"Address\")\n    add_address_sanitizer()\nelseif(WITH_SANITIZER STREQUAL \"Memory\")\n    add_memory_sanitizer()\nelseif(WITH_SANITIZER STREQUAL \"Thread\")\n    add_thread_sanitizer()\nelseif(WITH_SANITIZER STREQUAL \"Undefined\")\n    add_undefined_sanitizer()\nendif()\n\n#\n# Check whether compiler supports -fno-semantic-interposition parameter\n#\ncheck_c_compiler_flag(-fno-semantic-interposition HAVE_NO_INTERPOSITION)\n\n#\n# Check if we can hide zlib internal symbols that are linked between separate source files using hidden\n#\ncheck_c_source_compiles(\n    \"#define Z_INTERNAL __attribute__((visibility (\\\"hidden\\\")))\n    int Z_INTERNAL foo;\n    int main() {\n        return 0;\n    }\"\n    HAVE_ATTRIBUTE_VISIBILITY_HIDDEN FAIL_REGEX \"visibility\")\nif(HAVE_ATTRIBUTE_VISIBILITY_HIDDEN)\n    add_definitions(-DHAVE_VISIBILITY_HIDDEN)\nendif()\n\n#\n# Check if we can hide zlib internal symbols that are linked between separate source files using internal\n#\ncheck_c_source_compiles(\n    \"#define Z_INTERNAL __attribute__((visibility (\\\"internal\\\")))\n    int Z_INTERNAL foo;\n    int main() {\n        return 0;\n    }\"\n    HAVE_ATTRIBUTE_VISIBILITY_INTERNAL FAIL_REGEX \"visibility\")\nif(HAVE_ATTRIBUTE_VISIBILITY_INTERNAL)\n    add_definitions(-DHAVE_VISIBILITY_INTERNAL)\nendif()\n\n#\n# Check for __attribute__((aligned(x))) support in the compiler\n#\ncheck_c_source_compiles(\n    \"int main(void) {\n        __attribute__((aligned(8))) int test = 0;\n        (void)test;\n        return 0;\n    }\"\n    HAVE_ATTRIBUTE_ALIGNED FAIL_REGEX \"aligned\")\nif(HAVE_ATTRIBUTE_ALIGNED)\n    add_definitions(-DHAVE_ATTRIBUTE_ALIGNED)\nendif()\n\n#\n# Check for __builtin_assume_aligned(x,n) support in the compiler\n#\ncheck_c_source_compiles(\n    \"char *test(char *buffer) {\n        char *abuffer = __builtin_assume_aligned(buffer,64);\n        return abuffer;\n    }\n    int main() {\n        return 0;\n    }\"\n    HAVE_BUILTIN_ASSUME_ALIGNED)\nif(HAVE_BUILTIN_ASSUME_ALIGNED)\n    add_definitions(-DHAVE_BUILTIN_ASSUME_ALIGNED)\nendif()\n\n#\n# check for __builtin_ctz() support in the compiler\n#\ncheck_c_source_compiles(\n    \"int main(void) {\n        unsigned int zero = 0;\n        long test = __builtin_ctz(zero);\n        (void)test;\n        return 0;\n    }\"\n    HAVE_BUILTIN_CTZ\n)\nif(HAVE_BUILTIN_CTZ)\n    add_definitions(-DHAVE_BUILTIN_CTZ)\nendif()\n\n#\n# check for __builtin_ctzll() support in the compiler\n#\ncheck_c_source_compiles(\n    \"int main(void) {\n        unsigned int zero = 0;\n        long test = __builtin_ctzll(zero);\n        (void)test;\n        return 0;\n    }\"\n    HAVE_BUILTIN_CTZLL\n)\nif(HAVE_BUILTIN_CTZLL)\n    add_definitions(-DHAVE_BUILTIN_CTZLL)\nendif()\n\n#\n# check for ptrdiff_t support\n#\ncheck_c_source_compiles(\n    \"#include <stddef.h>\n     int main() {\n         ptrdiff_t *a;\n         (void)a;\n         return 0;\n    }\"\n    HAVE_PTRDIFF_T\n)\nif(NOT HAVE_PTRDIFF_T)\n    set(NEED_PTRDIFF_T 1)\n\n    check_type_size(\"void *\" SIZEOF_DATA_PTR)\n    message(STATUS \"sizeof(void *) is ${SIZEOF_DATA_PTR} bytes\")\n\n    if(${SIZEOF_DATA_PTR} MATCHES \"4\")\n        set(PTRDIFF_TYPE \"uint32_t\")\n    elseif(${SIZEOF_DATA_PTR} MATCHES \"8\")\n        set(PTRDIFF_TYPE \"uint64_t\")\n    else()\n        message(FATAL_ERROR \"sizeof(void *) is neither 32 nor 64 bit\")\n    endif()\nendif()\n\nadd_compile_options($<$<CONFIG:Debug>:-DZLIB_DEBUG>)\n\nif(MSVC)\n    set(CMAKE_DEBUG_POSTFIX \"d\")\n    add_definitions(-D_CRT_SECURE_NO_DEPRECATE)\n    add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)\nendif()\n\nif(BASEARCH_X86_FOUND)\n    # FORCE_SSE2 option will only be shown if HAVE_SSE2_INTRIN is true\n    if(\"${ARCH}\" MATCHES \"i[3-6]86\")\n        cmake_dependent_option(FORCE_SSE2 \"Always assume CPU is SSE2 capable\" OFF \"HAVE_SSE2_INTRIN\" OFF)\n    endif()\nendif()\n\n#\n# Enable deflate_quick at level 1\n#\nif(NOT WITH_NEW_STRATEGIES)\n    add_definitions(-DNO_QUICK_STRATEGY)\nendif()\n#\n# Enable deflate_medium at level 4-6\n#\nif(NOT WITH_NEW_STRATEGIES)\n    add_definitions(-DNO_MEDIUM_STRATEGY)\nendif()\n#\n# Enable inflate compilation options\n#\nif(WITH_INFLATE_STRICT)\n    add_definitions(-DINFLATE_STRICT)\n    message(STATUS \"Inflate strict distance checking enabled\")\nendif()\nif(WITH_INFLATE_ALLOW_INVALID_DIST)\n    add_definitions(-DINFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR)\n    message(STATUS \"Inflate zero data for invalid distances enabled\")\nendif()\n#\n# Enable reduced memory configuration\n#\nif(WITH_REDUCED_MEM)\n    add_definitions(-DHASH_SIZE=32768u -DGZBUFSIZE=8192 -DNO_LIT_MEM)\n    message(STATUS \"Configured for reduced memory environment\")\nendif()\n\nset(GENERIC_ARCHDIR \"arch/generic\")\n\nset(ZLIB_ARCH_SRCS)\nset(ZLIB_ARCH_HDRS ${GENERIC_ARCHDIR}/generic_functions.h)\n\nif(BASEARCH_ARM_FOUND)\n    set(ARCHDIR \"arch/arm\")\nelseif(BASEARCH_PPC_FOUND)\n    set(ARCHDIR \"arch/power\")\nelseif(BASEARCH_RISCV_FOUND)\n    set(ARCHDIR \"arch/riscv\")\nelseif(BASEARCH_S360_FOUND)\n    set(ARCHDIR \"arch/s390\")\nelseif(BASEARCH_X86_FOUND)\n    set(ARCHDIR \"arch/x86\")\n    if(NOT ${ARCH} MATCHES \"x86_64\")\n        add_feature_info(SSE2 1 \"Support the SSE2 instruction set, using \\\"${SSE2FLAG}\\\"\")\n    endif()\nelse()\n    set(ARCHDIR ${GENERIC_ARCHDIR})\n    message(STATUS \"No optimized architecture: using ${ARCHDIR}\")\nendif()\n\nif(WITH_OPTIM)\n    if(BASEARCH_ARM_FOUND)\n        add_definitions(-DARM_FEATURES)\n        if(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n            if(\"${ARCH}\" MATCHES \"aarch64\")\n                check_c_source_compiles(\n                    \"#include <sys/auxv.h>\n                    int main() {\n                        return (getauxval(AT_HWCAP) & HWCAP_CRC32);\n                    }\"\n                    ARM_AUXV_HAS_CRC32\n                )\n                if(ARM_AUXV_HAS_CRC32)\n                    add_definitions(-DARM_AUXV_HAS_CRC32)\n                else()\n                   message(STATUS \"HWCAP_CRC32 not present in sys/auxv.h; cannot detect support at runtime.\")\n                endif()\n            else()\n                check_c_source_compiles(\n                    \"#include <sys/auxv.h>\n                    int main() {\n                        return (getauxval(AT_HWCAP2) & HWCAP2_CRC32);\n                    }\"\n                    ARM_AUXV_HAS_CRC32\n                )\n                if(ARM_AUXV_HAS_CRC32)\n                    add_definitions(-DARM_AUXV_HAS_CRC32)\n                else()\n                    check_c_source_compiles(\n                        \"#include <sys/auxv.h>\n                        #include <asm/hwcap.h>\n                        int main() {\n                            return (getauxval(AT_HWCAP2) & HWCAP2_CRC32);\n                        }\"\n                        ARM_HWCAP_HAS_CRC32\n                    )\n                    if (ARM_HWCAP_HAS_CRC32)\n                        add_definitions(-DARM_AUXV_HAS_CRC32 -DARM_ASM_HWCAP)\n                    else()\n                        message(STATUS \"HWCAP2_CRC32 not present in sys/auxv.h; cannot detect support at runtime.\")\n                    endif()\n                endif()\n                check_c_source_compiles(\n                    \"#include <sys/auxv.h>\n                    int main() {\n                      return (getauxval(AT_HWCAP) & HWCAP_ARM_NEON);\n                    }\"\n                    ARM_AUXV_HAS_NEON\n                )\n                if(ARM_AUXV_HAS_NEON)\n                    add_definitions(-DARM_AUXV_HAS_NEON)\n                else()\n                    check_c_source_compiles(\n                        \"#include <sys/auxv.h>\n                        int main() {\n                          return (getauxval(AT_HWCAP) & HWCAP_NEON);\n                        }\"\n                        ARM_AUXV_HAS_NEON\n                    )\n                    if (ARM_AUXV_HAS_NEON)\n                        add_definitions(-DARM_AUXV_HAS_NEON)\n                    else()\n                        message(STATUS \"Neither HWCAP_ARM_NEON or HWCAP_NEON present in sys/auxv.h; cannot detect support at runtime.\")\n                    endif()\n                endif()\n            endif()\n        endif()\n        list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/arm_functions.h)\n        if(WITH_RUNTIME_CPU_DETECTION)\n            list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/arm_features.h)\n            list(APPEND ZLIB_ARCH_SRCS ${ARCHDIR}/arm_features.c)\n        endif()\n\n        if(WITH_ACLE)\n            check_acle_compiler_flag()\n            if(HAVE_ACLE_FLAG)\n                add_definitions(-DARM_ACLE)\n                set(ACLE_SRCS ${ARCHDIR}/crc32_acle.c)\n                set_property(SOURCE ${ACLE_SRCS} PROPERTY COMPILE_FLAGS \"${ACLEFLAG} ${NOLTOFLAG}\")\n                list(APPEND ZLIB_ARCH_SRCS ${ACLE_SRCS})\n                add_feature_info(ACLE_CRC 1 \"Support ACLE optimized CRC hash generation, using \\\"${ACLEFLAG}\\\"\")\n            else()\n                set(WITH_ACLE OFF)\n            endif()\n        else()\n            set(WITH_ACLE OFF)\n        endif()\n        if(WITH_NEON)\n            check_neon_compiler_flag()\n            if(NEON_AVAILABLE)\n                add_definitions(-DARM_NEON)\n                set(NEON_SRCS ${ARCHDIR}/adler32_neon.c ${ARCHDIR}/chunkset_neon.c\n                    ${ARCHDIR}/compare256_neon.c ${ARCHDIR}/slide_hash_neon.c)\n                list(APPEND ZLIB_ARCH_SRCS ${NEON_SRCS})\n                set_property(SOURCE ${NEON_SRCS} PROPERTY COMPILE_FLAGS \"${NEONFLAG} ${NOLTOFLAG}\")\n                if(MSVC)\n                    add_definitions(-D__ARM_NEON__)\n                endif()\n                add_feature_info(NEON_ADLER32 1 \"Support NEON instructions in adler32, using \\\"${NEONFLAG}\\\"\")\n                add_feature_info(NEON_SLIDEHASH 1 \"Support NEON instructions in slide_hash, using \\\"${NEONFLAG}\\\"\")\n                check_neon_ld4_intrinsics()\n                if(NEON_HAS_LD4)\n                    add_definitions(-DARM_NEON_HASLD4)\n                endif()\n            else()\n                set(WITH_NEON OFF)\n            endif()\n        endif()\n        if(WITH_ARMV6)\n            check_armv6_compiler_flag()\n            if(HAVE_ARMV6_INLINE_ASM OR HAVE_ARMV6_INTRIN)\n                add_definitions(-DARM_SIMD)\n                set(ARMV6_SRCS ${ARCHDIR}/slide_hash_armv6.c)\n                set_property(SOURCE ${ARMV6_SRCS} PROPERTY COMPILE_FLAGS \"${ARMV6FLAG} ${NOLTOFLAG}\")\n                list(APPEND ZLIB_ARCH_SRCS ${ARMV6_SRCS})\n                add_feature_info(ARMV6 1 \"Support ARMv6 SIMD instructions in slide_hash, using \\\"${ARMV6FLAG}\\\"\")\n                if(HAVE_ARMV6_INTRIN)\n                    add_definitions(-DARM_SIMD_INTRIN)\n                endif()\n            else()\n                set(WITH_ARMV6 OFF)\n            endif()\n        else()\n            set(WITH_ARMV6 OFF)\n        endif()\n    elseif(BASEARCH_PPC_FOUND)\n        # Common arch detection code\n        if(WITH_ALTIVEC)\n            check_ppc_intrinsics()\n        endif()\n        if(WITH_POWER8)\n            check_power8_intrinsics()\n        endif()\n        if(WITH_POWER9)\n            check_power9_intrinsics()\n        endif()\n        if(POWER8_NEED_AUXVEC_H OR POWER9_NEED_AUXVEC_H)\n            add_definitions(-DPOWER_NEED_AUXVEC_H)\n        endif()\n        if(HAVE_POWER8_INTRIN OR HAVE_POWER9_INTRIN)\n            add_definitions(-DPOWER_FEATURES)\n        endif()\n        if(HAVE_VMX OR HAVE_POWER8_INTRIN OR HAVE_POWER9_INTRIN)\n            list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/power_functions.h)\n            if(WITH_RUNTIME_CPU_DETECTION)\n                list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/power_features.h)\n                list(APPEND ZLIB_ARCH_SRCS ${ARCHDIR}/power_features.c)\n            endif()\n        endif()\n        # VMX specific options and files\n        if(WITH_ALTIVEC)\n            if(HAVE_VMX)\n                add_definitions(-DPPC_FEATURES)\n                if(HAVE_ALTIVEC)\n                    add_definitions(-DPPC_VMX)\n                    set(PPC_SRCS ${ARCHDIR}/adler32_vmx.c ${ARCHDIR}/slide_hash_vmx.c)\n                    list(APPEND ZLIB_ARCH_SRCS ${PPC_SRCS})\n                    add_feature_info(ALTIVEC 1 \"Support the AltiVec instruction set, using \\\"-maltivec\\\"\")\n                    set_property(SOURCE ${PPC_SRCS} PROPERTY COMPILE_FLAGS \"${PPCFLAGS}\")\n                else()\n                    set(WITH_ALTIVEC OFF)\n                endif()\n            endif()\n        endif()\n        # Power8 specific options and files\n        if(WITH_POWER8)\n            if(HAVE_POWER8_INTRIN)\n                add_definitions(-DPOWER8_VSX)\n                set(POWER8_SRCS ${ARCHDIR}/adler32_power8.c ${ARCHDIR}/chunkset_power8.c ${ARCHDIR}/slide_hash_power8.c)\n                if(\"${ARCH}\" MATCHES \"powerpc64(le)?\")\n                    add_definitions(-DPOWER8_VSX_CRC32)\n                    list(APPEND POWER8_SRCS ${ARCHDIR}/crc32_power8.c)\n                endif()\n                list(APPEND ZLIB_ARCH_SRCS ${POWER8_SRCS})\n                set_property(SOURCE ${POWER8_SRCS} PROPERTY COMPILE_FLAGS \"${POWER8FLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_POWER8 OFF)\n            endif()\n        endif()\n        # Power9 specific options and files\n        if(WITH_POWER9)\n            if(HAVE_POWER9_INTRIN)\n                add_definitions(-DPOWER9)\n                set(POWER9_SRCS ${ARCHDIR}/compare256_power9.c)\n                list(APPEND ZLIB_ARCH_SRCS ${POWER9_SRCS})\n                set_property(SOURCE ${POWER9_SRCS} PROPERTY COMPILE_FLAGS \"${POWER9FLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_POWER9 OFF)\n            endif()\n        endif()\n    elseif(BASEARCH_RISCV_FOUND)\n        if(WITH_RVV)\n            check_rvv_intrinsics()\n            if(HAVE_RVV_INTRIN)\n                add_definitions(-DRISCV_FEATURES)\n                add_definitions(-DRISCV_RVV)\n                list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/riscv_functions.h)\n                if(WITH_RUNTIME_CPU_DETECTION)\n                    list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/riscv_features.h)\n                    list(APPEND ZLIB_ARCH_SRCS ${ARCHDIR}/riscv_features.c)\n                endif()\n                # FIXME: we will not set compile flags for riscv_features.c when\n                # the kernels update hwcap or hwprobe for riscv\n                set(RVV_SRCS ${ARCHDIR}/adler32_rvv.c ${ARCHDIR}/chunkset_rvv.c ${ARCHDIR}/compare256_rvv.c ${ARCHDIR}/slide_hash_rvv.c)\n                if(WITH_RUNTIME_CPU_DETECTION)\n                    list(APPEND RVV_SRCS ${ARCHDIR}/riscv_features.c)\n                endif()\n                list(APPEND ZLIB_ARCH_SRCS ${RVV_SRCS})\n                set_property(SOURCE ${RVV_SRCS} PROPERTY COMPILE_FLAGS \"${RISCVFLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_RVV OFF)\n            endif()\n        endif()\n    elseif(BASEARCH_S360_FOUND)\n        check_s390_intrinsics()\n        if(HAVE_S390_INTRIN)\n            add_definitions(-DS390_FEATURES)\n            list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/s390_functions.h)\n            if(WITH_RUNTIME_CPU_DETECTION)\n                list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/s390_features.h)\n                list(APPEND ZLIB_ARCH_SRCS ${ARCHDIR}/s390_features.c)\n            endif()\n        endif()\n        if(WITH_DFLTCC_DEFLATE)\n            add_definitions(-DS390_DFLTCC_DEFLATE)\n            list(APPEND ZLIB_ARCH_SRCS ${ARCHDIR}/dfltcc_deflate.c)\n        endif()\n        if(WITH_DFLTCC_INFLATE)\n            add_definitions(-DS390_DFLTCC_INFLATE)\n            list(APPEND ZLIB_ARCH_SRCS ${ARCHDIR}/dfltcc_inflate.c)\n        endif()\n        if(WITH_CRC32_VX)\n            check_vgfma_intrinsics()\n            if(HAVE_VGFMA_INTRIN)\n                add_definitions(-DS390_CRC32_VX)\n                set(CRC32_VX_SRCS ${ARCHDIR}/crc32-vx.c)\n                list(APPEND ZLIB_ARCH_SRCS ${CRC32_VX_SRCS})\n                set_property(SOURCE ${CRC32_VX_SRCS} PROPERTY COMPILE_FLAGS \"${VGFMAFLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_CRC32_VX OFF)\n            endif()\n        endif()\n    elseif(BASEARCH_X86_FOUND)\n        add_definitions(-DX86_FEATURES)\n        list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/x86_functions.h)\n        if(WITH_RUNTIME_CPU_DETECTION)\n            list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/x86_features.h)\n            list(APPEND ZLIB_ARCH_SRCS ${ARCHDIR}/x86_features.c)\n        endif()\n        if(MSVC)\n            list(APPEND ZLIB_ARCH_HDRS fallback_builtins.h)\n        endif()\n        check_xsave_intrinsics()\n        if(HAVE_XSAVE_INTRIN)\n            add_feature_info(XSAVE 1 \"Support XSAVE intrinsics using \\\"${XSAVEFLAG}\\\"\")\n            if(WITH_RUNTIME_CPU_DETECTION)\n                set_property(SOURCE ${ARCHDIR}/x86_features.c PROPERTY COMPILE_FLAGS \"${XSAVEFLAG}\")\n            endif()\n            if(NOT (CMAKE_C_COMPILER_ID MATCHES \"GNU\" AND CMAKE_C_COMPILER_VERSION VERSION_LESS 8.2))\n                add_definitions(-DX86_HAVE_XSAVE_INTRIN)\n            endif()\n        endif()\n        if(WITH_SSE2)\n            check_sse2_intrinsics()\n            if(HAVE_SSE2_INTRIN)\n                add_definitions(-DX86_SSE2)\n                set(SSE2_SRCS ${ARCHDIR}/chunkset_sse2.c ${ARCHDIR}/compare256_sse2.c ${ARCHDIR}/slide_hash_sse2.c)\n                list(APPEND ZLIB_ARCH_SRCS ${SSE2_SRCS})\n                if(NOT ${ARCH} MATCHES \"x86_64\")\n                    set_property(SOURCE ${SSE2_SRCS} PROPERTY COMPILE_FLAGS \"${SSE2FLAG} ${NOLTOFLAG}\")\n                    add_feature_info(FORCE_SSE2 FORCE_SSE2 \"Assume CPU is SSE2 capable\")\n                    if(FORCE_SSE2)\n                        add_definitions(-DX86_NOCHECK_SSE2)\n                    endif()\n                endif()\n            else()\n                set(WITH_SSE2 OFF)\n            endif()\n        endif()\n        if(WITH_SSSE3)\n            check_ssse3_intrinsics()\n            if(HAVE_SSSE3_INTRIN AND WITH_SSE2)\n                add_definitions(-DX86_SSSE3)\n                set(SSSE3_SRCS ${ARCHDIR}/adler32_ssse3.c ${ARCHDIR}/chunkset_ssse3.c)\n                add_feature_info(SSSE3_ADLER32 1 \"Support SSSE3-accelerated adler32, using \\\"${SSSE3FLAG}\\\"\")\n                list(APPEND ZLIB_ARCH_SRCS ${SSSE3_SRCS})\n                set_property(SOURCE ${SSSE3_SRCS} PROPERTY COMPILE_FLAGS \"${SSSE3FLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_SSSE3 OFF)\n            endif()\n        endif()\n        if(WITH_SSE42)\n            check_sse42_intrinsics()\n            if(HAVE_SSE42_INTRIN AND WITH_SSSE3)\n                add_definitions(-DX86_SSE42)\n                set(SSE42_SRCS ${ARCHDIR}/adler32_sse42.c)\n                add_feature_info(SSE42_CRC 1 \"Support SSE4.2 optimized adler32 hash generation, using \\\"${SSE42FLAG}\\\"\")\n                list(APPEND ZLIB_ARCH_SRCS ${SSE42_SRCS})\n                set_property(SOURCE ${SSE42_SRCS} PROPERTY COMPILE_FLAGS \"${SSE42FLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_SSE42 OFF)\n            endif()\n        endif()\n        if(WITH_PCLMULQDQ)\n            check_pclmulqdq_intrinsics()\n            if(HAVE_PCLMULQDQ_INTRIN AND WITH_SSE42)\n                add_definitions(-DX86_PCLMULQDQ_CRC)\n                set(PCLMULQDQ_SRCS ${ARCHDIR}/crc32_pclmulqdq.c)\n                add_feature_info(PCLMUL_CRC 1 \"Support CRC hash generation using PCLMULQDQ, using \\\"${SSE42FLAG} ${PCLMULFLAG}\\\"\")\n                list(APPEND ZLIB_ARCH_SRCS ${PCLMULQDQ_SRCS})\n                set_property(SOURCE ${PCLMULQDQ_SRCS} PROPERTY COMPILE_FLAGS \"${SSE42FLAG} ${PCLMULFLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_PCLMULQDQ OFF)\n            endif()\n        endif()\n        if(WITH_AVX2)\n            check_avx2_intrinsics()\n            if(HAVE_AVX2_INTRIN AND WITH_SSE42)\n                add_definitions(-DX86_AVX2)\n                set(AVX2_SRCS ${ARCHDIR}/slide_hash_avx2.c)\n                add_feature_info(AVX2_SLIDEHASH 1 \"Support AVX2 optimized slide_hash, using \\\"${AVX2FLAG}\\\"\")\n                list(APPEND AVX2_SRCS ${ARCHDIR}/chunkset_avx2.c)\n                add_feature_info(AVX2_CHUNKSET 1 \"Support AVX2 optimized chunkset, using \\\"${AVX2FLAG}\\\"\")\n                list(APPEND AVX2_SRCS ${ARCHDIR}/compare256_avx2.c)\n                add_feature_info(AVX2_COMPARE256 1 \"Support AVX2 optimized compare256, using \\\"${AVX2FLAG}\\\"\")\n                list(APPEND AVX2_SRCS ${ARCHDIR}/adler32_avx2.c)\n                add_feature_info(AVX2_ADLER32 1 \"Support AVX2-accelerated adler32, using \\\"${AVX2FLAG}\\\"\")\n                list(APPEND ZLIB_ARCH_SRCS ${AVX2_SRCS})\n                set_property(SOURCE ${AVX2_SRCS} PROPERTY COMPILE_FLAGS \"${AVX2FLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_AVX2 OFF)\n            endif()\n        endif()\n        if(WITH_AVX512)\n            check_avx512_intrinsics()\n            if(HAVE_AVX512_INTRIN AND WITH_AVX2)\n                add_definitions(-DX86_AVX512)\n                list(APPEND AVX512_SRCS ${ARCHDIR}/adler32_avx512.c)\n                add_feature_info(AVX512_ADLER32 1 \"Support AVX512-accelerated adler32, using \\\"${AVX512FLAG}\\\"\")\n                list(APPEND AVX512_SRCS ${ARCHDIR}/chunkset_avx512.c)\n                add_feature_info(AVX512_CHUNKSET 1 \"Support AVX512 optimized chunkset, using \\\"${AVX512FLAG}\\\"\")\n                list(APPEND ZLIB_ARCH_HDRS ${ARCHDIR}/adler32_avx512_p.h)\n                list(APPEND ZLIB_ARCH_SRCS ${AVX512_SRCS})\n                set_property(SOURCE ${AVX512_SRCS} PROPERTY COMPILE_FLAGS \"${AVX512FLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_AVX512 OFF)\n            endif()\n        endif()\n        if(WITH_AVX512VNNI)\n            check_avx512vnni_intrinsics()\n            if(HAVE_AVX512VNNI_INTRIN AND WITH_AVX2)\n                add_definitions(-DX86_AVX512VNNI)\n                add_feature_info(AVX512VNNI_ADLER32 1 \"Support AVX512VNNI adler32, using \\\"${AVX512VNNIFLAG}\\\"\")\n                list(APPEND AVX512VNNI_SRCS ${ARCHDIR}/adler32_avx512_vnni.c)\n                list(APPEND ZLIB_ARCH_SRCS ${AVX512VNNI_SRCS})\n                set_property(SOURCE ${AVX512VNNI_SRCS} PROPERTY COMPILE_FLAGS \"${AVX512VNNIFLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_AVX512VNNI OFF)\n            endif()\n        endif()\n        if(WITH_VPCLMULQDQ)\n            check_vpclmulqdq_intrinsics()\n            if(HAVE_VPCLMULQDQ_INTRIN AND WITH_PCLMULQDQ AND WITH_AVX512)\n                add_definitions(-DX86_VPCLMULQDQ_CRC)\n                set(VPCLMULQDQ_SRCS ${ARCHDIR}/crc32_vpclmulqdq.c)\n                add_feature_info(VPCLMUL_CRC 1 \"Support CRC hash generation using VPCLMULQDQ, using \\\"${PCLMULFLAG} ${VPCLMULFLAG} ${AVX512FLAG}\\\"\")\n                list(APPEND ZLIB_ARCH_SRCS ${VPCLMULQDQ_SRCS})\n                set_property(SOURCE ${VPCLMULQDQ_SRCS} PROPERTY COMPILE_FLAGS \"${PCLMULFLAG} ${VPCLMULFLAG} ${AVX512FLAG} ${NOLTOFLAG}\")\n            else()\n                set(WITH_VPCLMULQDQ OFF)\n            endif()\n        endif()\n    endif()\nendif()\n\nmessage(STATUS \"Architecture-specific source files: ${ZLIB_ARCH_SRCS}\")\n\n#============================================================================\n# zconf.h\n#============================================================================\n\nmacro(generate_cmakein input output)\n    file(REMOVE ${output})\n    file(STRINGS ${input} _lines)\n    foreach(_line IN LISTS _lines)\n        string(REGEX REPLACE \"#ifdef HAVE_UNISTD_H.*\" \"@ZCONF_UNISTD_LINE@\" _line \"${_line}\")\n        string(REGEX REPLACE \"#ifdef NEED_PTRDIFF_T.*\" \"@ZCONF_PTRDIFF_LINE@\" _line \"${_line}\")\n        if(NEED_PTRDIFF_T)\n            string(REGEX REPLACE \"typedef PTRDIFF_TYPE\" \"typedef @PTRDIFF_TYPE@\" _line \"${_line}\")\n        endif()\n        file(APPEND ${output} \"${_line}\\n\")\n    endforeach()\nendmacro(generate_cmakein)\n\ngenerate_cmakein( ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h.in ${CMAKE_CURRENT_BINARY_DIR}/zconf${SUFFIX}.h.cmakein )\n\nif(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)\n    # If we're doing an out of source build and the user has a zconf.h\n    # in their source tree...\n    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h)\n        message(STATUS \"Renaming\")\n        message(STATUS \"    ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h\")\n        message(STATUS \"to 'zconf${SUFFIX}.h.included' because this file is included with zlib\")\n        message(STATUS \"but CMake generates it automatically in the build directory.\")\n        file(RENAME ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h.included)\n    endif()\n\n    # If we're doing an out of source build and the user has a zconf.h.cmakein\n    # in their source tree...\n    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h.cmakein)\n        message(STATUS \"Renaming\")\n        message(STATUS \"    ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h.cmakein\")\n        message(STATUS \"to 'zconf${SUFFIX}.h.cmakeincluded' because this file is included with zlib\")\n        message(STATUS \"but CMake generates it automatically in the build directory.\")\n        file(RENAME ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h.cmakein ${CMAKE_CURRENT_SOURCE_DIR}/zconf${SUFFIX}.h.cmakeincluded)\n    endif()\nendif()\n\n# The user is allowed (but discouraged) to set absolute CMAKE_INSTALL_*DIR paths.\n# If they do, we copy these non-relocatable paths into the pkg-config file.\nif(IS_ABSOLUTE \"${CMAKE_INSTALL_INCLUDEDIR}\")\n    set(PC_INC_INSTALL_DIR \"${CMAKE_INSTALL_INCLUDEDIR}\")\nelse()\n    set(PC_INC_INSTALL_DIR \"\\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}\")\nendif()\n\nif(IS_ABSOLUTE \"${CMAKE_INSTALL_LIBDIR}\")\n    set(PC_LIB_INSTALL_DIR \"${CMAKE_INSTALL_LIBDIR}\")\nelse()\n    set(PC_LIB_INSTALL_DIR \"\\${exec_prefix}/${CMAKE_INSTALL_LIBDIR}\")\nendif()\n\n#============================================================================\n# zlib\n#============================================================================\n\nset(ZLIB_PUBLIC_HDRS\n    ${CMAKE_CURRENT_BINARY_DIR}/zconf${SUFFIX}.h\n    ${CMAKE_CURRENT_BINARY_DIR}/zlib_name_mangling${SUFFIX}.h\n    ${CMAKE_CURRENT_BINARY_DIR}/zlib${SUFFIX}.h\n)\nset(ZLIB_PRIVATE_HDRS\n    arch/generic/chunk_permute_table.h\n    arch/generic/compare256_p.h\n    arch/generic/generic_functions.h\n    adler32_p.h\n    chunkset_tpl.h\n    compare256_rle.h\n    arch_functions.h\n    crc32_braid_p.h\n    crc32_braid_comb_p.h\n    crc32_braid_tbl.h\n    deflate.h\n    deflate_p.h\n    functable.h\n    inffast_tpl.h\n    inffixed_tbl.h\n    inflate.h\n    inflate_p.h\n    inftrees.h\n    insert_string_tpl.h\n    match_tpl.h\n    trees.h\n    trees_emit.h\n    trees_tbl.h\n    zbuild.h\n    zendian.h\n    zutil.h\n)\nset(ZLIB_SRCS\n    arch/generic/adler32_c.c\n    arch/generic/adler32_fold_c.c\n    arch/generic/chunkset_c.c\n    arch/generic/compare256_c.c\n    arch/generic/crc32_braid_c.c\n    arch/generic/crc32_fold_c.c\n    arch/generic/slide_hash_c.c\n    adler32.c\n    compress.c\n    crc32.c\n    crc32_braid_comb.c\n    deflate.c\n    deflate_fast.c\n    deflate_huff.c\n    deflate_medium.c\n    deflate_quick.c\n    deflate_rle.c\n    deflate_slow.c\n    deflate_stored.c\n    functable.c\n    infback.c\n    inflate.c\n    inftrees.c\n    insert_string.c\n    insert_string_roll.c\n    trees.c\n    uncompr.c\n    zutil.c\n)\n\nif(WITH_RUNTIME_CPU_DETECTION)\n    list(APPEND ZLIB_PRIVATE_HDRS cpu_features.h)\n    list(APPEND ZLIB_SRCS cpu_features.c)\nendif()\n\nset(ZLIB_GZFILE_PRIVATE_HDRS\n    gzguts.h\n)\nset(ZLIB_GZFILE_SRCS\n    gzlib.c\n    ${CMAKE_CURRENT_BINARY_DIR}/gzread.c\n    gzwrite.c\n)\n\nset(ZLIB_ALL_SRCS ${ZLIB_SRCS} ${ZLIB_ARCH_HDRS} ${ZLIB_ARCH_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})\nif(WITH_GZFILEOP)\n    list(APPEND ZLIB_ALL_SRCS ${ZLIB_GZFILE_PRIVATE_HDRS} ${ZLIB_GZFILE_SRCS})\nendif()\n\nif(NOT DEFINED BUILD_SHARED_LIBS OR BUILD_SHARED_LIBS)\n    set(ZLIB_DLL_SRCS win32/zlib${SUFFIX}1.rc)\nendif()\n\nif(NOT DEFINED BUILD_SHARED_LIBS)\n    add_library(zlib SHARED ${ZLIB_ALL_SRCS} ${ZLIB_DLL_SRCS})\n    add_library(zlibstatic STATIC ${ZLIB_ALL_SRCS})\n\n    set(ZLIB_INSTALL_LIBRARIES zlib zlibstatic)\nelse()\n    add_library(zlib ${ZLIB_ALL_SRCS})\n\n    if(BUILD_SHARED_LIBS)\n        target_sources(zlib PRIVATE ${ZLIB_DLL_SRCS})\n    else()\n        add_library(zlibstatic ALIAS zlib)\n    endif()\n\n    set(ZLIB_INSTALL_LIBRARIES zlib)\nendif()\n\n# INFO: Mimics official zlib CMake target\n# Generates ZLIB.cmake in case ZLIB_COMPAT=ON and always exports the CMake target ZLIB::ZLIB\n# In case ZLIB_COMPAT=OFF, the CMake target and file follows zlib-ng naming convention\nif (ZLIB_COMPAT)\n    if (TARGET zlib)\n        set_target_properties(zlib PROPERTIES EXPORT_NAME ZLIB)\n    else()\n        set_target_properties(zlibstatic PROPERTIES EXPORT_NAME ZLIB)\n    endif()\nendif()\n\nforeach(ZLIB_INSTALL_LIBRARY ${ZLIB_INSTALL_LIBRARIES})\n    if(NOT ZLIB_COMPAT)\n        target_compile_definitions(${ZLIB_INSTALL_LIBRARY} PUBLIC ZLIBNG_NATIVE_API)\n    endif()\n    target_include_directories(${ZLIB_INSTALL_LIBRARY} PUBLIC\n        \"$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}$<SEMICOLON>${CMAKE_CURRENT_SOURCE_DIR}>\"\n        \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n    target_include_directories(${ZLIB_INSTALL_LIBRARY} PRIVATE \"${ARCHDIR}\")\n    target_include_directories(${ZLIB_INSTALL_LIBRARY} PRIVATE \"${CMAKE_CURRENT_SOURCE_DIR}/arch/generic\")\nendforeach()\n\nif(WIN32)\n    # Shared library\n    if(NOT DEFINED BUILD_SHARED_LIBS OR BUILD_SHARED_LIBS)\n        set_target_properties(zlib PROPERTIES OUTPUT_NAME zlib${SUFFIX})\n    endif()\n    # Static library\n    if(NOT DEFINED BUILD_SHARED_LIBS)\n        if(MSVC)\n            set_target_properties(zlibstatic PROPERTIES OUTPUT_NAME zlibstatic${SUFFIX})\n        else()\n            set_target_properties(zlibstatic PROPERTIES OUTPUT_NAME z${SUFFIX})\n        endif()\n    elseif(NOT BUILD_SHARED_LIBS)\n        if(MSVC)\n            set_target_properties(zlib PROPERTIES OUTPUT_NAME zlibstatic${SUFFIX})\n        else()\n            set_target_properties(zlib PROPERTIES OUTPUT_NAME z${SUFFIX})\n        endif()\n    endif()\nelse()\n    # On unix-like platforms the library is almost always called libz\n    set_target_properties(${ZLIB_INSTALL_LIBRARIES} PROPERTIES OUTPUT_NAME z${SUFFIX})\nendif()\n\nif(NOT DEFINED BUILD_SHARED_LIBS OR BUILD_SHARED_LIBS)\n    set_target_properties(zlib PROPERTIES DEFINE_SYMBOL ZLIB_DLL)\n\n    if(ZLIB_COMPAT)\n        set_target_properties(zlib PROPERTIES SOVERSION 1)\n    else()\n        set_target_properties(zlib PROPERTIES SOVERSION 2)\n    endif()\n\n    if(NOT CYGWIN)\n        # This property causes shared libraries on Linux to have the full version\n        # encoded into their final filename.  We disable this on Cygwin because\n        # it causes cygz-${ZLIB_FULL_VERSION}.dll to be created when cygz.dll\n        # seems to be the default.\n        #\n        # This has no effect with MSVC, on that platform the version info for\n        # the DLL comes from the resource file win32/zlib1.rc\n        set_target_properties(zlib PROPERTIES VERSION ${ZLIB_FULL_VERSION})\n    endif()\n\n    if(UNIX)\n        if(HAVE_NO_INTERPOSITION)\n            set_target_properties(zlib PROPERTIES COMPILE_FLAGS \"-fno-semantic-interposition\")\n        endif()\n        if(NOT APPLE AND NOT CMAKE_SYSTEM_NAME STREQUAL AIX)\n            if(NOT ZLIB_COMPAT)\n                add_definitions(-DHAVE_SYMVER)\n            endif()\n            set_target_properties(zlib PROPERTIES LINK_FLAGS\n                \"-Wl,--version-script,\\\"${CMAKE_CURRENT_SOURCE_DIR}/zlib${SUFFIX}.map\\\"\")\n        endif()\n    endif()\n    if(MSYS)\n        # Suppress version number from shared library name\n        set(CMAKE_SHARED_LIBRARY_NAME_WITH_VERSION 0)\n    elseif(WIN32)\n        # Creates zlib1.dll when building shared library version\n        if(ZLIB_COMPAT)\n            set_target_properties(zlib PROPERTIES SUFFIX \"1.dll\")\n        else()\n            set_target_properties(zlib PROPERTIES SUFFIX \"2.dll\")\n        endif()\n    endif()\nendif()\n\nif(HAVE_UNISTD_H)\n  SET(ZCONF_UNISTD_LINE \"#if 1    /* was set to #if 1 by configure/cmake/etc */\")\nelse()\n  SET(ZCONF_UNISTD_LINE \"#if 0    /* was set to #if 0 by configure/cmake/etc */\")\nendif()\nif(NEED_PTRDIFF_T)\n    SET(ZCONF_PTRDIFF_LINE \"#if 1    /* was set to #if 1 by configure/cmake/etc */\")\nelse()\n    SET(ZCONF_PTRDIFF_LINE \"#ifdef NEED_PTRDIFF_T    /* may be set to #if 1 by configure/cmake/etc */\")\nendif()\n\nset(ZLIB_PC ${CMAKE_CURRENT_BINARY_DIR}/zlib${SUFFIX}.pc)\nif(WITH_GZFILEOP)\n    set(PKG_CONFIG_CFLAGS \"-DWITH_GZFILEOP\")\nendif()\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/zlib.pc.cmakein\n    ${ZLIB_PC} @ONLY)\nconfigure_file(${CMAKE_CURRENT_BINARY_DIR}/zconf${SUFFIX}.h.cmakein\n    ${CMAKE_CURRENT_BINARY_DIR}/zconf${SUFFIX}.h @ONLY)\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/zlib${SUFFIX}.h.in\n    ${CMAKE_CURRENT_BINARY_DIR}/zlib${SUFFIX}.h @ONLY)\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/gzread.c.in\n    ${CMAKE_CURRENT_BINARY_DIR}/gzread.c @ONLY)\n\nif (NOT ZLIB_SYMBOL_PREFIX STREQUAL \"\")\n    add_feature_info(ZLIB_SYMBOL_PREFIX ON \"Publicly exported symbols have a custom prefix\")\n    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/zlib_name_mangling${SUFFIX}.h.in\n        ${CMAKE_CURRENT_BINARY_DIR}/zlib_name_mangling${SUFFIX}.h @ONLY)\nelse()\n    add_feature_info(ZLIB_SYMBOL_PREFIX OFF \"Publicly exported symbols DO NOT have a custom prefix\")\n    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/zlib_name_mangling.h.empty\n        ${CMAKE_CURRENT_BINARY_DIR}/zlib_name_mangling${SUFFIX}.h COPYONLY)\nendif()\n# add_definitions(-DZLIB_SYMBOL_PREFIX=${ZLIB_SYMBOL_PREFIX}) # not needed\n\n\nif(NOT SKIP_INSTALL_LIBRARIES AND NOT SKIP_INSTALL_ALL)\n    install(TARGETS ${ZLIB_INSTALL_LIBRARIES}\n        EXPORT ${EXPORT_NAME}\n        RUNTIME DESTINATION \"${CMAKE_INSTALL_BINDIR}\"\n        ARCHIVE DESTINATION \"${CMAKE_INSTALL_LIBDIR}\"\n        LIBRARY DESTINATION \"${CMAKE_INSTALL_LIBDIR}\")\nendif()\nif(NOT SKIP_INSTALL_HEADERS AND NOT SKIP_INSTALL_ALL)\n    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/zlib${SUFFIX}.h\n        DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\" RENAME zlib${SUFFIX}.h)\n    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/zlib_name_mangling${SUFFIX}.h\n        DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\" RENAME zlib_name_mangling${SUFFIX}.h)\n    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/zconf${SUFFIX}.h\n        DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\" RENAME zconf${SUFFIX}.h)\nendif()\nif(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL)\n    install(FILES ${ZLIB_PC} DESTINATION \"${PKGCONFIG_INSTALL_DIR}\")\n    install(EXPORT ${EXPORT_NAME}\n        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${EXPORT_NAME}\"\n        NAMESPACE ${EXPORT_NAME}::)\n    # Use GNU-style variable names\n    set(INCLUDE_INSTALL_DIR ${CMAKE_INSTALL_INCLUDEDIR})\n    set(LIB_INSTALL_DIR ${CMAKE_INSTALL_LIBDIR})\n    if (ZLIB_COMPAT)\n       set(PACKAGE_CONFIGNAME zlib)\n       set(PACKAGE_VERSION ${ZLIB_HEADER_VERSION})\n    else()\n       set(PACKAGE_CONFIGNAME zlib-ng)\n       set(PACKAGE_VERSION ${ZLIBNG_HEADER_VERSION})\n    endif()\n    configure_package_config_file(${PACKAGE_CONFIGNAME}-config.cmake.in\n        ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_CONFIGNAME}-config.cmake\n        INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${EXPORT_NAME}\n        PATH_VARS INCLUDE_INSTALL_DIR LIB_INSTALL_DIR)\n    write_basic_package_version_file(\n        ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_CONFIGNAME}-config-version.cmake\n        VERSION ${PACKAGE_VERSION}\n        COMPATIBILITY AnyNewerVersion)\n    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_CONFIGNAME}-config.cmake\n                  ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_CONFIGNAME}-config-version.cmake\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${EXPORT_NAME})\nendif()\n\n#============================================================================\n# Example binaries\n#============================================================================\n\nif(ZLIB_ENABLE_TESTS)\n    enable_testing()\n\n    if(BUILD_SHARED_LIBS)\n        if(ZLIBNG_ENABLE_TESTS)\n            message(STATUS \"Disabling zlib-ng tests because shared libraries are enabled\")\n            set(ZLIBNG_ENABLE_TESTS OFF)\n        endif()\n\n        if(WITH_BENCHMARKS OR WITH_BENCHMARK_APPS)\n            message(STATUS \"Disabling benchmarks because shared libraries are enabled\")\n            set(WITH_BENCHMARKS OFF)\n            set(WITH_BENCHMARK_APPS OFF)\n        endif()\n    endif()\n\n    add_subdirectory(test)\nendif()\n\nadd_feature_info(WITH_GZFILEOP WITH_GZFILEOP \"Compile with support for gzFile related functions\")\nadd_feature_info(ZLIB_COMPAT ZLIB_COMPAT \"Compile with zlib compatible API\")\nadd_feature_info(ZLIB_ENABLE_TESTS ZLIB_ENABLE_TESTS \"Build test binaries\")\nadd_feature_info(ZLIBNG_ENABLE_TESTS ZLIBNG_ENABLE_TESTS \"Test zlib-ng specific API\")\nadd_feature_info(WITH_SANITIZER WITH_SANITIZER \"Enable sanitizer support\")\nadd_feature_info(WITH_GTEST WITH_GTEST \"Build gtest_zlib\")\nadd_feature_info(WITH_FUZZERS WITH_FUZZERS \"Build test/fuzz\")\nadd_feature_info(WITH_BENCHMARKS WITH_BENCHMARKS \"Build test/benchmarks\")\nadd_feature_info(WITH_BENCHMARK_APPS WITH_BENCHMARK_APPS \"Build application benchmarks\")\nadd_feature_info(WITH_OPTIM WITH_OPTIM \"Build with optimisation\")\nadd_feature_info(WITH_NEW_STRATEGIES WITH_NEW_STRATEGIES \"Use new strategies\")\nadd_feature_info(WITH_NATIVE_INSTRUCTIONS WITH_NATIVE_INSTRUCTIONS\n    \"Instruct the compiler to use the full instruction set on this host (gcc/clang -march=native)\")\nadd_feature_info(WITH_RUNTIME_CPU_DETECTION WITH_RUNTIME_CPU_DETECTION \"Build with runtime CPU detection\")\nadd_feature_info(WITH_MAINTAINER_WARNINGS WITH_MAINTAINER_WARNINGS \"Build with project maintainer warnings\")\nadd_feature_info(WITH_CODE_COVERAGE WITH_CODE_COVERAGE \"Enable code coverage reporting\")\nadd_feature_info(WITH_INFLATE_STRICT WITH_INFLATE_STRICT \"Build with strict inflate distance checking\")\nadd_feature_info(WITH_INFLATE_ALLOW_INVALID_DIST WITH_INFLATE_ALLOW_INVALID_DIST \"Build with zero fill for inflate invalid distances\")\n\nif(BASEARCH_ARM_FOUND)\n    add_feature_info(WITH_ACLE WITH_ACLE \"Build with ACLE\")\n    add_feature_info(WITH_NEON WITH_NEON \"Build with NEON intrinsics\")\n    add_feature_info(WITH_ARMV6 WITH_ARMV6 \"Build with ARMv6 SIMD\")\nelseif(BASEARCH_PPC_FOUND)\n    add_feature_info(WITH_ALTIVEC WITH_ALTIVEC \"Build with AltiVec optimisations\")\n    add_feature_info(WITH_POWER8 WITH_POWER8 \"Build with optimisations for POWER8\")\n    add_feature_info(WITH_POWER9 WITH_POWER9 \"Build with optimisations for POWER9\")\nelseif(BASEARCH_RISCV_FOUND)\n    add_feature_info(WITH_RVV WITH_RVV \"Build with RVV intrinsics\")\nelseif(BASEARCH_S360_FOUND)\n    add_feature_info(WITH_DFLTCC_DEFLATE WITH_DFLTCC_DEFLATE \"Build with DFLTCC intrinsics for compression on IBM Z\")\n    add_feature_info(WITH_DFLTCC_INFLATE WITH_DFLTCC_INFLATE \"Build with DFLTCC intrinsics for decompression on IBM Z\")\n    add_feature_info(WITH_CRC32_VX WITH_CRC32_VX \"Build with vectorized CRC32 on IBM Z\")\nelseif(BASEARCH_X86_FOUND)\n    add_feature_info(WITH_AVX2 WITH_AVX2 \"Build with AVX2\")\n    add_feature_info(WITH_AVX512 WITH_AVX512 \"Build with AVX512\")\n    add_feature_info(WITH_AVX512VNNI WITH_AVX512VNNI \"Build with AVX512 VNNI\")\n    add_feature_info(WITH_SSE2 WITH_SSE2 \"Build with SSE2\")\n    add_feature_info(WITH_SSSE3 WITH_SSSE3 \"Build with SSSE3\")\n    add_feature_info(WITH_SSE42 WITH_SSE42 \"Build with SSE42\")\n    add_feature_info(WITH_PCLMULQDQ WITH_PCLMULQDQ \"Build with PCLMULQDQ\")\n    add_feature_info(WITH_VPCLMULQDQ WITH_VPCLMULQDQ \"Build with VPCLMULQDQ\")\nendif()\n\nadd_feature_info(INSTALL_UTILS INSTALL_UTILS \"Copy minigzip and minideflate during install\")\n\nFEATURE_SUMMARY(WHAT ALL INCLUDE_QUIET_PACKAGES)\n\n#============================================================================\n# CPack\n#============================================================================\nset(CPACK_GENERATOR \"TGZ\")\nset(CPACK_SOURCE_GENERATOR \"TGZ\")\nset(CPACK_SOURCE_IGNORE_FILES .git/ _CPack_Packages/ \"${PROJECT_BINARY_DIR}/\")\n\nset(CPACK_PACKAGE_NAME \"zlib${SUFFIX}\")\nset(CPACK_PACKAGE_VERSION ${ZLIB_FULL_VERSION})\nset(CPACK_PACKAGE_DIRECTORY \"${PROJECT_BINARY_DIR}/package\")\n\nif(\"${PROJECT_BINARY_DIR}\" STREQUAL \"${PROJECT_SOURCE_DIR}\")\n    message(WARNING \"Building to source folder is not recommended. Cpack will be unable to generate source package.\")\nendif()\n\ninclude(CPack)\n"
        },
        {
          "name": "FAQ.zlib",
          "type": "blob",
          "size": 16.201171875,
          "content": "##\n# THIS IS AN UNMAINTAINED COPY OF THE ORIGINAL FILE DISTRIBUTED WITH ZLIB 1.2.11\n##\n\n\n\n\n                Frequently Asked Questions about zlib\n\n\nIf your question is not there, please check the zlib home page\nhttps://zlib.net/ which may have more recent information.\nThe latest zlib FAQ is at https://zlib.net/zlib_faq.html\n\n\n 1. Is zlib Y2K-compliant?\n\n    Yes. zlib doesn't handle dates.\n\n 2. Where can I get a Windows DLL version?\n\n    The zlib sources can be compiled without change to produce a DLL.  See the\n    file win32/DLL_FAQ.txt in the zlib distribution.\n\n 3. Where can I get a Visual Basic interface to zlib?\n\n    See\n        * https://marknelson.us/1997/01/01/zlib-engine/\n        * win32/DLL_FAQ.txt in the zlib distribution\n\n 4. compress() returns Z_BUF_ERROR.\n\n    Make sure that before the call of compress(), the length of the compressed\n    buffer is equal to the available size of the compressed buffer and not\n    zero.  For Visual Basic, check that this parameter is passed by reference\n    (\"as any\"), not by value (\"as long\").\n\n 5. deflate() or inflate() returns Z_BUF_ERROR.\n\n    Before making the call, make sure that avail_in and avail_out are not zero.\n    When setting the parameter flush equal to Z_FINISH, also make sure that\n    avail_out is big enough to allow processing all pending input.  Note that a\n    Z_BUF_ERROR is not fatal--another call to deflate() or inflate() can be\n    made with more input or output space.  A Z_BUF_ERROR may in fact be\n    unavoidable depending on how the functions are used, since it is not\n    possible to tell whether or not there is more output pending when\n    strm.avail_out returns with zero.  See https://zlib.net/zlib_how.html for a\n    heavily annotated example.\n\n 6. Where's the zlib documentation (man pages, etc.)?\n\n    It's in zlib.h .  Examples of zlib usage are in the files test/example.c\n    and test/minigzip.c, with more in examples/ .\n\n 7. Why don't you use GNU autoconf or libtool or ...?\n\n    Because we would like to keep zlib as a very small and simple package.\n    zlib is rather portable and doesn't need much configuration.\n\n 8. I found a bug in zlib.\n\n    Most of the time, such problems are due to an incorrect usage of zlib.\n    Please try to reproduce the problem with a small program and send the\n    corresponding source to us at zlib@gzip.org .  Do not send multi-megabyte\n    data files without prior agreement.\n\n 9. Why do I get \"undefined reference to gzputc\"?\n\n    If \"make test\" produces something like\n\n       example.o(.text+0x154): undefined reference to `gzputc'\n\n    check that you don't have old files libz.* in /usr/lib, /usr/local/lib or\n    /usr/X11R6/lib. Remove any old versions, then do \"make install\".\n\n10. I need a Delphi interface to zlib.\n\n    See the contrib/delphi directory in the zlib distribution.\n\n11. Can zlib handle .zip archives?\n\n    Not by itself, no.  See the directory contrib/minizip in the zlib\n    distribution.\n\n12. Can zlib handle .Z files?\n\n    No, sorry.  You have to spawn an uncompress or gunzip subprocess, or adapt\n    the code of uncompress on your own.\n\n13. How can I make a Unix shared library?\n\n    By default a shared (and a static) library is built for Unix.  So:\n\n    make distclean\n    ./configure\n    make\n\n14. How do I install a shared zlib library on Unix?\n\n    After the above, then:\n\n    make install\n\n    However, many flavors of Unix come with a shared zlib already installed.\n    Before going to the trouble of compiling a shared version of zlib and\n    trying to install it, you may want to check if it's already there!  If you\n    can #include <zlib.h>, it's there.  The -lz option will probably link to\n    it.  You can check the version at the top of zlib.h or with the\n    ZLIB_VERSION symbol defined in zlib.h .\n\n15. I have a question about OttoPDF.\n\n    We are not the authors of OttoPDF. The real author is on the OttoPDF web\n    site: Joel Hainley, jhainley@myndkryme.com.\n\n16. Can zlib decode Flate data in an Adobe PDF file?\n\n    Yes. See https://www.pdflib.com/ . To modify PDF forms, see\n    https://sourceforge.net/projects/acroformtool/ .\n\n17. Why am I getting this \"register_frame_info not found\" error on Solaris?\n\n    After installing zlib 1.1.4 on Solaris 2.6, running applications using zlib\n    generates an error such as:\n\n        ld.so.1: rpm: fatal: relocation error: file /usr/local/lib/libz.so:\n        symbol __register_frame_info: referenced symbol not found\n\n    The symbol __register_frame_info is not part of zlib, it is generated by\n    the C compiler (cc or gcc).  You must recompile applications using zlib\n    which have this problem.  This problem is specific to Solaris.  See\n    http://www.sunfreeware.com/ for Solaris versions of zlib and applications\n    using zlib.\n\n18. Why does gzip give an error on a file I make with compress/deflate?\n\n    The compress and deflate functions produce data in the zlib format, which\n    is different and incompatible with the gzip format.  The gz* functions in\n    zlib on the other hand use the gzip format.  Both the zlib and gzip formats\n    use the same compressed data format internally, but have different headers\n    and trailers around the compressed data.\n\n19. Ok, so why are there two different formats?\n\n    The gzip format was designed to retain the directory information about a\n    single file, such as the name and last modification date.  The zlib format\n    on the other hand was designed for in-memory and communication channel\n    applications, and has a much more compact header and trailer and uses a\n    faster integrity check than gzip.\n\n20. Well that's nice, but how do I make a gzip file in memory?\n\n    You can request that deflate write the gzip format instead of the zlib\n    format using deflateInit2().  You can also request that inflate decode the\n    gzip format using inflateInit2().  Read zlib.h for more details.\n\n21. Is zlib thread-safe?\n\n    Yes.  However any library routines that zlib uses and any application-\n    provided memory allocation routines must also be thread-safe.  zlib's gz*\n    functions use stdio library routines, and most of zlib's functions use the\n    library memory allocation routines by default.  zlib's *Init* functions\n    allow for the application to provide custom memory allocation routines.\n\n    Of course, you should only operate on any given zlib or gzip stream from a\n    single thread at a time.\n\n22. Can I use zlib in my commercial application?\n\n    Yes.  Please read the license in zlib.h.\n\n23. Is zlib under the GNU license?\n\n    No.  Please read the license in zlib.h.\n\n24. The license says that altered source versions must be \"plainly marked\". So\n    what exactly do I need to do to meet that requirement?\n\n    You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h.  In\n    particular, the final version number needs to be changed to \"f\", and an\n    identification string should be appended to ZLIB_VERSION.  Version numbers\n    x.x.x.f are reserved for modifications to zlib by others than the zlib\n    maintainers.  For example, if the version of the base zlib you are altering\n    is \"1.2.3.4\", then in zlib.h you should change ZLIB_VERNUM to 0x123f, and\n    ZLIB_VERSION to something like \"1.2.3.f-zachary-mods-v3\".  You can also\n    update the version strings in deflate.c and inftrees.c.\n\n    For altered source distributions, you should also note the origin and\n    nature of the changes in zlib.h, as well as in ChangeLog and README, along\n    with the dates of the alterations.  The origin should include at least your\n    name (or your company's name), and an email address to contact for help or\n    issues with the library.\n\n    Note that distributing a compiled zlib library along with zlib.h and\n    zconf.h is also a source distribution, and so you should change\n    ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes\n    in zlib.h as you would for a full source distribution.\n\n25. Will zlib work on a big-endian or little-endian architecture, and can I\n    exchange compressed data between them?\n\n    Yes and yes.\n\n26. Will zlib work on a 64-bit machine?\n\n    Yes.  It has been tested on 64-bit machines, and has no dependence on any\n    data types being limited to 32-bits in length.  If you have any\n    difficulties, please provide a complete problem report to zlib@gzip.org\n\n27. Will zlib decompress data from the PKWare Data Compression Library?\n\n    No.  The PKWare DCL uses a completely different compressed data format than\n    does PKZIP and zlib.  However, you can look in zlib's contrib/blast\n    directory for a possible solution to your problem.\n\n28. Can I access data randomly in a compressed stream?\n\n    No, not without some preparation.  If when compressing you periodically use\n    Z_FULL_FLUSH, carefully write all the pending data at those points, and\n    keep an index of those locations, then you can start decompression at those\n    points.  You have to be careful to not use Z_FULL_FLUSH too often, since it\n    can significantly degrade compression.  Alternatively, you can scan a\n    deflate stream once to generate an index, and then use that index for\n    random access.  See examples/zran.c .\n\n29. Does zlib work on MVS, OS/390, CICS, etc.?\n\n    It has in the past, but we have not heard of any recent evidence.  There\n    were working ports of zlib 1.1.4 to MVS, but those links no longer work.\n    If you know of recent, successful applications of zlib on these operating\n    systems, please let us know.  Thanks.\n\n30. Is there some simpler, easier to read version of inflate I can look at to\n    understand the deflate format?\n\n    First off, you should read RFC 1951.  Second, yes.  Look in zlib's\n    contrib/puff directory.\n\n31. Does zlib infringe on any patents?\n\n    As far as we know, no.  In fact, that was originally the whole point behind\n    zlib.  Look here for some more information:\n\n    https://www.gzip.org/#faq11\n\n32. Can zlib work with greater than 4 GB of data?\n\n    Yes.  inflate() and deflate() will process any amount of data correctly.\n    Each call of inflate() or deflate() is limited to input and output chunks\n    of the maximum value that can be stored in the compiler's \"unsigned int\"\n    type, but there is no limit to the number of chunks.  Note however that the\n    strm.total_in and strm_total_out counters may be limited to 4 GB.  These\n    counters are provided as a convenience and are not used internally by\n    inflate() or deflate().  The application can easily set up its own counters\n    updated after each call of inflate() or deflate() to count beyond 4 GB.\n    compress() and uncompress() may be limited to 4 GB, since they operate in a\n    single call.  gzseek() and gztell() may be limited to 4 GB depending on how\n    zlib is compiled.  See the zlibCompileFlags() function in zlib.h.\n\n    The word \"may\" appears several times above since there is a 4 GB limit only\n    if the compiler's \"long\" type is 32 bits.  If the compiler's \"long\" type is\n    64 bits, then the limit is 16 exabytes.\n\n33. Does zlib have any security vulnerabilities?\n\n    The only one that we are aware of is potentially in gzprintf().  If zlib is\n    compiled to use sprintf() or vsprintf(), then there is no protection\n    against a buffer overflow of an 8K string space (or other value as set by\n    gzbuffer()), other than the caller of gzprintf() assuring that the output\n    will not exceed 8K.  On the other hand, if zlib is compiled to use\n    snprintf() or vsnprintf(), which should normally be the case, then there is\n    no vulnerability.  The ./configure script will display warnings if an\n    insecure variation of sprintf() will be used by gzprintf().  Also the\n    zlibCompileFlags() function will return information on what variant of\n    sprintf() is used by gzprintf().\n\n    If you don't have snprintf() or vsnprintf() and would like one, you can\n    find a portable implementation here:\n\n        https://www.ijs.si/software/snprintf/\n\n    Note that you should be using the most recent version of zlib.  Versions\n    1.1.3 and before were subject to a double-free vulnerability, and versions\n    1.2.1 and 1.2.2 were subject to an access exception when decompressing\n    invalid compressed data.\n\n34. Is there a Java version of zlib?\n\n    Probably what you want is to use zlib in Java. zlib is already included\n    as part of the Java SDK in the java.util.zip package. If you really want\n    a version of zlib written in the Java language, look on the zlib home\n    page for links: https://zlib.net/ .\n\n35. I get this or that compiler or source-code scanner warning when I crank it\n    up to maximally-pedantic. Can't you guys write proper code?\n\n    Many years ago, we gave up attempting to avoid warnings on every compiler\n    in the universe.  It just got to be a waste of time, and some compilers\n    were downright silly as well as contradicted each other.  So now, we simply\n    make sure that the code always works.\n\n36. Valgrind (or some similar memory access checker) says that deflate is\n    performing a conditional jump that depends on an uninitialized value.\n    Isn't that a bug?\n\n    No.  That is intentional for performance reasons, and the output of deflate\n    is not affected.  This only started showing up recently since zlib 1.2.x\n    uses malloc() by default for allocations, whereas earlier versions used\n    calloc(), which zeros out the allocated memory.  Even though the code was\n    correct, versions 1.2.4 and later was changed to not stimulate these\n    checkers.\n\n37. Will zlib read the (insert any ancient or arcane format here) compressed\n    data format?\n\n    Probably not. Look in the comp.compression FAQ for pointers to various\n    formats and associated software.\n\n38. How can I encrypt/decrypt zip files with zlib?\n\n    zlib doesn't support encryption.  The original PKZIP encryption is very\n    weak and can be broken with freely available programs.  To get strong\n    encryption, use GnuPG, https://www.gnupg.org/ , which already includes zlib\n    compression.  For PKZIP compatible \"encryption\", look at\n    http://infozip.sourceforge.net/\n\n39. What's the difference between the \"gzip\" and \"deflate\" HTTP 1.1 encodings?\n\n    \"gzip\" is the gzip format, and \"deflate\" is the zlib format.  They should\n    probably have called the second one \"zlib\" instead to avoid confusion with\n    the raw deflate compressed data format.  While the HTTP 1.1 RFC 2616\n    correctly points to the zlib specification in RFC 1950 for the \"deflate\"\n    transfer encoding, there have been reports of servers and browsers that\n    incorrectly produce or expect raw deflate data per the deflate\n    specification in RFC 1951, most notably Microsoft.  So even though the\n    \"deflate\" transfer encoding using the zlib format would be the more\n    efficient approach (and in fact exactly what the zlib format was designed\n    for), using the \"gzip\" transfer encoding is probably more reliable due to\n    an unfortunate choice of name on the part of the HTTP 1.1 authors.\n\n    Bottom line: use the gzip format for HTTP 1.1 encoding.\n\n40. Does zlib support the new \"Deflate64\" format introduced by PKWare?\n\n    No.  PKWare has apparently decided to keep that format proprietary, since\n    they have not documented it as they have previous compression formats.  In\n    any case, the compression improvements are so modest compared to other more\n    modern approaches, that it's not worth the effort to implement.\n\n41. I'm having a problem with the zip functions in zlib, can you help?\n\n    There are no zip functions in zlib.  You are probably using minizip by\n    Giles Vollant, which is found in the contrib directory of zlib.  It is not\n    part of zlib.  In fact none of the stuff in contrib is part of zlib.  The\n    files in there are not supported by the zlib authors.  You need to contact\n    the authors of the respective contribution for help.\n\n42. The match.asm code in contrib is under the GNU General Public License.\n    Since it's part of zlib, doesn't that mean that all of zlib falls under the\n    GNU GPL?\n\n    No.  The files in contrib are not part of zlib.  They were contributed by\n    other authors and are provided as a convenience to the user within the zlib\n    distribution.  Each item in contrib has its own license.\n\n43. Is zlib subject to export controls?  What is its ECCN?\n\n    zlib is not subject to export controls, and so is classified as EAR99.\n\n44. Can you please sign these lengthy legal documents and fax them back to us\n    so that we can use your software in our product?\n\n    No. Go away. Shoo.\n"
        },
        {
          "name": "INDEX.md",
          "type": "blob",
          "size": 2.7900390625,
          "content": "Contents\n--------\n\n| Name             | Description                                                    |\n|:-----------------|:---------------------------------------------------------------|\n| arch/            | Architecture-specific code                                     |\n| doc/             | Documentation for formats and algorithms                       |\n| test/example.c   | Zlib usages examples for build testing                         |\n| test/minigzip.c  | Minimal gzip-like functionality for build testing              |\n| test/infcover.c  | Inflate code coverage for build testing                        |\n| win32/           | Shared library version resources for Windows                   |\n| CMakeLists.txt   | Cmake build script                                             |\n| configure        | Bash configure/build script                                    |\n| adler32.c        | Compute the Adler-32 checksum of a data stream                 |\n| chunkset.*       | Inline functions to copy small data chunks                     |\n| compress.c       | Compress a memory buffer                                       |\n| deflate.*        | Compress data using the deflate algorithm                      |\n| deflate_fast.c   | Compress data using the deflate algorithm with fast strategy   |\n| deflate_medium.c | Compress data using the deflate algorithm with medium strategy |\n| deflate_slow.c   | Compress data using the deflate algorithm with slow strategy   |\n| functable.*      | Struct containing function pointers to optimized functions     |\n| gzguts.h         | Internal definitions for gzip operations                       |\n| gzlib.c          | Functions common to reading and writing gzip files             |\n| gzread.c         | Read gzip files                                                |\n| gzwrite.c        | Write gzip files                                               |\n| infback.*        | Inflate using a callback interface                             |\n| inflate.*        | Decompress data                                                |\n| inffast.*        | Decompress data with speed optimizations                       |\n| inffixed_tbl.h   | Table for decoding fixed codes                                 |\n| inftrees.h       | Generate Huffman trees for efficient decoding                  |\n| trees.*          | Output deflated data using Huffman coding                      |\n| uncompr.c        | Decompress a memory buffer                                     |\n| zconf.h.cmakein  | zconf.h template for cmake                                     |\n| zendian.h        | BYTE_ORDER for endian tests                                    |\n| zlib.map         | Linux symbol information                                       |\n| zlib.pc.in       | Pkg-config template                                            |\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 0.8466796875,
          "content": "(C) 1995-2024 Jean-loup Gailly and Mark Adler\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would be\n   appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source distribution.\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 10.8486328125,
          "content": "# Makefile for zlib\n# Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n# For conditions of distribution and use, see copyright notice in zlib.h\n\n# To compile and test, type:\n#    ./configure; make test\n# Normally configure builds both a static and a shared library.\n# If you want to build just a static library, use: ./configure --static\n\n# To install /usr/local/lib/libz.* and /usr/local/include/zlib.h, type:\n#    make install\n# To install in $HOME instead of /usr/local, use:\n#    make install prefix=$HOME\n\nCC=cc\n\nCFLAGS=-O\n#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n#CFLAGS=-g -DZLIB_DEBUG\n#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n#           -Wstrict-prototypes -Wmissing-prototypes\n\nSFLAGS=-O\nLDFLAGS=-L.\nLIBNAME1=libz-ng\nLIBNAME2=zlib-ng\nSUFFIX=-ng\nTEST_LIBS=$(LIBNAME1).a\nLDSHARED=$(CC)\nLDSHAREDFLAGS=-shared\nLDVERSIONSCRIPT=\n\nVER=2.2.3\nVER1=2\n\nSTATICLIB=$(LIBNAME1).a\nSHAREDLIB=$(LIBNAME1).so\nSHAREDLIBV=$(LIBNAME1).so.$(VER)\nSHAREDLIBM=$(LIBNAME1).so.$(VER1)\nIMPORTLIB=\nSHAREDTARGET=$(LIBNAME1).so.$(VER)\nPKGFILE=$(LIBNAME2).pc\n\nLIBS=$(STATICLIB) $(SHAREDTARGET)\n\nAR=ar\nARFLAGS=rc\nDEFFILE=\nRC=\nRCFLAGS=\nRCOBJS=\nSTRIP=\nRANLIB=ranlib\nLDCONFIG=ldconfig\nLDSHAREDLIBC=\nEXE=\n\nSRCDIR=.\nINCLUDES=-I$(SRCDIR)\n\nBUILDDIR=.\n\nARCHDIR=arch/generic\nARCH_STATIC_OBJS=\nARCH_SHARED_OBJS=\n\nprefix = /usr/local\nexec_prefix = ${prefix}\nbindir = ${exec_prefix}/bin\nlibdir = ${exec_prefix}/lib\nsharedlibdir = ${libdir}\nincludedir = ${prefix}/include\nmandir = ${prefix}/share/man\nman3dir = ${mandir}/man3\npkgconfigdir = ${libdir}/pkgconfig\n\nOBJZ = \\\n\tarch/generic/adler32_c.o \\\n\tarch/generic/adler32_fold_c.o \\\n\tarch/generic/chunkset_c.o \\\n\tarch/generic/compare256_c.o \\\n\tarch/generic/crc32_braid_c.o \\\n\tarch/generic/crc32_fold_c.o \\\n\tarch/generic/slide_hash_c.o \\\n\tadler32.o \\\n\tcompress.o \\\n\tcrc32.o \\\n\tcrc32_braid_comb.o \\\n\tdeflate.o \\\n\tdeflate_fast.o \\\n\tdeflate_huff.o \\\n\tdeflate_medium.o \\\n\tdeflate_quick.o \\\n\tdeflate_rle.o \\\n\tdeflate_slow.o \\\n\tdeflate_stored.o \\\n\tfunctable.o \\\n\tinfback.o \\\n\tinflate.o \\\n\tinftrees.o \\\n\tinsert_string.o \\\n\tinsert_string_roll.o \\\n\ttrees.o \\\n\tuncompr.o \\\n\tzutil.o \\\n\tcpu_features.o \\\n\t$(ARCH_STATIC_OBJS)\n\nOBJG = \\\n\tgzlib.o \\\n\tgzread.o \\\n\tgzwrite.o\n\nTESTOBJG =\nOBJC = $(OBJZ) $(OBJG)\n\nPIC_OBJZ = \\\n\tarch/generic/adler32_c.lo \\\n\tarch/generic/adler32_fold_c.lo \\\n\tarch/generic/chunkset_c.lo \\\n\tarch/generic/compare256_c.lo \\\n\tarch/generic/crc32_braid_c.lo \\\n\tarch/generic/crc32_fold_c.lo \\\n\tarch/generic/slide_hash_c.lo \\\n\tadler32.lo \\\n\tcompress.lo \\\n\tcrc32.lo \\\n\tcrc32_braid_comb.lo \\\n\tdeflate.lo \\\n\tdeflate_fast.lo \\\n\tdeflate_huff.lo \\\n\tdeflate_medium.lo \\\n\tdeflate_quick.lo \\\n\tdeflate_rle.lo \\\n\tdeflate_slow.lo \\\n\tdeflate_stored.lo \\\n\tfunctable.lo \\\n\tinfback.lo \\\n\tinflate.lo \\\n\tinftrees.lo \\\n\tinsert_string.lo \\\n\tinsert_string_roll.lo \\\n\ttrees.lo \\\n\tuncompr.lo \\\n\tzutil.lo \\\n\tcpu_features.lo \\\n\t$(ARCH_SHARED_OBJS)\n\nPIC_OBJG = \\\n\tgzlib.lo \\\n\tgzread.lo \\\n\tgzwrite.lo\n\nPIC_TESTOBJG =\nPIC_OBJC = $(PIC_OBJZ) $(PIC_OBJG)\n\nOBJS = $(OBJC)\n\nPIC_OBJS = $(PIC_OBJC)\n\nall: static shared\n\nstatic: example$(EXE) minigzip$(EXE) makefixed$(EXE) maketrees$(EXE) makecrct$(EXE)\n\nshared: examplesh$(EXE) minigzipsh$(EXE)\n\ncheck: test\n\n.SECONDARY:\n\n$(ARCHDIR)/%.o: $(SRCDIR)/$(ARCHDIR)/%.c\n\t$(MAKE) -C $(ARCHDIR) $(notdir $@)\n\n$(ARCHDIR)/%.lo: $(SRCDIR)/$(ARCHDIR)/%.c\n\t$(MAKE) -C $(ARCHDIR) $(notdir $@)\n\narch/generic/%.o: $(SRCDIR)/arch/generic/%.c\n\t$(MAKE) -C arch/generic $(notdir $@)\n\narch/generic/%.lo: $(SRCDIR)/arch/generic/%.c\n\t$(MAKE) -C arch/generic $(notdir $@)\n\n%.o: $(ARCHDIR)/%.o\n\t-cp $< $@\n\n%.lo: $(ARCHDIR)/%.lo\n\t-cp $< $@\n\ntest: all\n\t$(MAKE) -C test\n\ninfcover.o: $(SRCDIR)/test/infcover.c zlib$(SUFFIX).h zconf$(SUFFIX).h zlib_name_mangling$(SUFFIX).h\n\t$(CC) $(CFLAGS) $(INCLUDES) -c -o $@ $(SRCDIR)/test/infcover.c\n\ninfcover$(EXE): infcover.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ infcover.o $(STATICLIB)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\ncover: infcover$(EXE)\n\trm -f *.gcda\n\t./infcover\n\tgcov inf*.c\n\n$(STATICLIB): $(OBJS)\n\t$(AR) $(ARFLAGS) $@ $(OBJS)\n\t-@ ($(RANLIB) $@ || true) >/dev/null 2>&1\n\nexample.o:\n\t$(CC) $(CFLAGS) -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $(SRCDIR)/test/example.c\n\nminigzip.o:\n\t$(CC) $(CFLAGS) -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $(SRCDIR)/test/minigzip.c\n\nmakefixed.o:\n\t$(CC) $(CFLAGS) $(INCLUDES) -c -o $@ $(SRCDIR)/tools/makefixed.c\n\nmaketrees.o:\n\t$(CC) $(CFLAGS) $(INCLUDES) -c -o $@ $(SRCDIR)/tools/maketrees.c\n\nmakecrct.o:\n\t$(CC) $(CFLAGS) $(INCLUDES) -c -o $@ $(SRCDIR)/tools/makecrct.c\n\nzlibrc.o: $(SRCDIR)/win32/zlib$(SUFFIX)1.rc\n\t$(RC) $(RCFLAGS) -o $@ $(SRCDIR)/win32/zlib$(SUFFIX)1.rc\n\n.SUFFIXES: .lo\n\n%.o: $(SRCDIR)/%.c\n\t$(CC) $(CFLAGS) $(INCLUDES) -c -o $@ $<\n\n%.lo: $(SRCDIR)/%.c\n\t$(CC) $(SFLAGS) -DPIC $(INCLUDES) -c -o $@ $<\n\ngzlib.o: $(SRCDIR)/gzlib.c\n\t$(CC) $(CFLAGS) -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $<\n\ngzlib.lo: $(SRCDIR)/gzlib.c\n\t$(CC) $(SFLAGS) -DPIC -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $<\n\ngzread.o: gzread.c\n\t$(CC) $(CFLAGS) -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $<\n\ngzread.lo: gzread.c\n\t$(CC) $(SFLAGS) -DPIC -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $<\n\ngzwrite.o: $(SRCDIR)/gzwrite.c\n\t$(CC) $(CFLAGS) -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $<\n\ngzwrite.lo: $(SRCDIR)/gzwrite.c\n\t$(CC) $(SFLAGS) -DPIC -DWITH_GZFILEOP $(INCLUDES) -c -o $@ $<\n\n$(SHAREDTARGET): $(PIC_OBJS) $(DEFFILE) $(RCOBJS)\nifneq ($(SHAREDTARGET),)\n\t$(LDSHARED) $(CFLAGS) $(LDSHAREDFLAGS) $(LDVERSIONSCRIPT) $(LDFLAGS) -o $@ $(DEFFILE) $(PIC_OBJS) $(RCOBJS) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\nifneq ($(SHAREDLIB),$(SHAREDTARGET))\n\trm -f $(SHAREDLIB) $(SHAREDLIBM)\n\tln -s $@ $(SHAREDLIB)\n\tln -s $@ $(SHAREDLIBM)\nendif\nendif\n\nexample$(EXE): example.o $(TESTOBJG) $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ example.o $(TESTOBJG) $(TEST_LIBS) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\nminigzip$(EXE): minigzip.o $(TESTOBJG) $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ minigzip.o $(TESTOBJG) $(TEST_LIBS) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\nminigzipsh$(EXE): minigzip.o $(PIC_TESTOBJG) $(SHAREDTARGET)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ minigzip.o $(PIC_TESTOBJG) $(SHAREDLIB) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\n\nexamplesh$(EXE): example.o $(PIC_TESTOBJG) $(SHAREDTARGET)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ example.o $(PIC_TESTOBJG) $(SHAREDLIB) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\nmakefixed$(EXE): makefixed.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ makefixed.o $(TEST_LIBS) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\nmaketrees$(EXE): maketrees.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ maketrees.o $(TEST_LIBS) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\nmakecrct$(EXE): makecrct.o $(STATICLIB)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ makecrct.o $(TEST_LIBS) $(LDSHAREDLIBC)\nifneq ($(STRIP),)\n\t$(STRIP) $@\nendif\n\ninstall-shared: $(SHAREDTARGET)\nifneq ($(SHAREDTARGET),)\n\t-@if [ ! -d $(DESTDIR)$(sharedlibdir) ]; then mkdir -p $(DESTDIR)$(sharedlibdir); fi\n\trm -f $(DESTDIR)$(sharedlibdir)/$(SHAREDTARGET)\n\tcp $(SHAREDTARGET) $(DESTDIR)$(sharedlibdir)\n\tchmod 755 $(DESTDIR)$(sharedlibdir)/$(SHAREDTARGET)\nifneq ($(SHAREDLIB),$(SHAREDTARGET))\n\trm -f $(DESTDIR)$(sharedlibdir)/$(SHAREDLIB) $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBM)\n\tln -s $(SHAREDLIBV) $(DESTDIR)$(sharedlibdir)/$(SHAREDLIB)\n\tln -s $(SHAREDLIBV) $(DESTDIR)$(sharedlibdir)/$(SHAREDLIBM)\n\t($(LDCONFIG) || true)  >/dev/null 2>&1\n# ldconfig is for Linux\nendif\nifneq ($(IMPORTLIB),)\n\tcp $(IMPORTLIB) $(DESTDIR)$(sharedlibdir)\n\tchmod 644 $(DESTDIR)$(sharedlibdir)/$(IMPORTLIB)\nendif\nendif\n\ninstall-static: $(STATICLIB)\n\t-@if [ ! -d $(DESTDIR)$(libdir)       ]; then mkdir -p $(DESTDIR)$(libdir); fi\n\trm -f $(DESTDIR)$(libdir)/$(STATICLIB)\n\tcp $(STATICLIB) $(DESTDIR)$(libdir)\n\tchmod 644 $(DESTDIR)$(libdir)/$(STATICLIB)\n\t-@($(RANLIB) $(DESTDIR)$(libdir)/$(STATICLIB) || true) >/dev/null 2>&1\n# The ranlib in install-static is needed on NeXTSTEP which checks file times\n\ninstall-libs: install-shared install-static\n\t-@if [ ! -d $(DESTDIR)$(man3dir)      ]; then mkdir -p $(DESTDIR)$(man3dir); fi\n\t-@if [ ! -d $(DESTDIR)$(pkgconfigdir) ]; then mkdir -p $(DESTDIR)$(pkgconfigdir); fi\n\trm -f $(DESTDIR)$(pkgconfigdir)/$(PKGFILE)\n\tcp $(PKGFILE) $(DESTDIR)$(pkgconfigdir)\n\tchmod 644 $(DESTDIR)$(pkgconfigdir)/$(PKGFILE)\n\ninstall: install-libs\n\t-@if [ ! -d $(DESTDIR)$(includedir)   ]; then mkdir -p $(DESTDIR)$(includedir); fi\n\trm -f $(DESTDIR)$(includedir)/zlib$(SUFFIX).h $(DESTDIR)$(includedir)/zconf$(SUFFIX).h $(DESTDIR)$(includedir)/zlib_name_mangling$(SUFFIX).h\n\tcp zlib$(SUFFIX).h $(DESTDIR)$(includedir)/zlib$(SUFFIX).h\n\tcp zconf$(SUFFIX).h $(DESTDIR)$(includedir)/zconf$(SUFFIX).h\n\tcp zlib_name_mangling$(SUFFIX).h $(DESTDIR)$(includedir)/zlib_name_mangling$(SUFFIX).h\n\tchmod 644 $(DESTDIR)$(includedir)/zlib$(SUFFIX).h $(DESTDIR)$(includedir)/zconf$(SUFFIX).h $(DESTDIR)$(includedir)/zlib_name_mangling$(SUFFIX).h\n\nuninstall-static:\n\tcd $(DESTDIR)$(libdir) && rm -f $(STATICLIB)\n\nuninstall-shared:\nifneq ($(SHAREDLIB),)\n\tcd $(DESTDIR)$(sharedlibdir) && rm -f $(SHAREDLIBV) $(SHAREDLIB) $(SHAREDLIBM)\nendif\nifneq ($(IMPORTLIB),)\n\tcd $(DESTDIR)$(sharedlibdir) && rm -f $(IMPORTLIB)\nendif\n\nuninstall: uninstall-static uninstall-shared\n\tcd $(DESTDIR)$(includedir) && rm -f zlib$(SUFFIX).h zconf$(SUFFIX).h zlib_name_mangling$(SUFFIX).h\n\tcd $(DESTDIR)$(pkgconfigdir) && rm -f $(PKGFILE)\n\nmostlyclean: clean\nclean:\n\t@if [ -f $(ARCHDIR)/Makefile ]; then $(MAKE) -C $(ARCHDIR) clean; fi\n\t@if [ -f arch/generic/Makefile ]; then $(MAKE) -C arch/generic clean; fi\n\t@if [ -f test/Makefile ]; then $(MAKE) -C test clean; fi\n\trm -f *.o *.lo *~ \\\n\t   example$(EXE) minigzip$(EXE) minigzipsh$(EXE) \\\n\t   infcover makefixed$(EXE) maketrees$(EXE) makecrct$(EXE) \\\n\t   $(STATICLIB) $(IMPORTLIB) $(SHAREDLIB) $(SHAREDLIBV) $(SHAREDLIBM) \\\n\t   foo.gz so_locations \\\n\t   _match.s maketree\n\trm -rf objs\n\trm -f *.gcda *.gcno *.gcov\n\trm -f a.out a.exe\n\trm -f *._h\n\trm -rf btmp1 btmp2 pkgtmp1 pkgtmp2\n\nmaintainer-clean: distclean\ndistclean: clean\n\t@if [ -f $(ARCHDIR)/Makefile ]; then $(MAKE) -C $(ARCHDIR) distclean; fi\n\t@if [ -f test/Makefile ]; then $(MAKE) -C test distclean; fi\n\trm -f $(PKGFILE) configure.log zconf.h zconf.h.cmakein zlib$(SUFFIX).h zlib_name_mangling$(SUFFIX).h *.pc gzread.c\n\t-@rm -f .DS_Store\n# Reset Makefile if building inside source tree\n\t@if [ -f Makefile.in ]; then \\\n\tprintf 'all:\\n\\t-@echo \"Please use ./configure first.  Thank you.\"\\n' > Makefile ; \\\n\tprintf '\\ndistclean:\\n\\t$(MAKE) -f Makefile.in distclean\\n' >> Makefile ; \\\n\ttouch -r $(SRCDIR)/Makefile.in Makefile ; fi\n# Reset zconf.h and zconf.h.cmakein if building inside source tree\n\t@if [ -f zconf.h.in ]; then \\\n\tcp -p $(SRCDIR)/zconf.h.in zconf.h ; \\\n\tgrep -v '^#cmakedefine' $(SRCDIR)/zconf.h.in > zconf.h.cmakein &&\\\n\ttouch -r $(SRCDIR)/zconf.h.in zconf.h.cmakein ; fi\n# Cleanup these files if building outside source tree\n\t@if [ ! -f README.md ]; then rm -f Makefile; fi\n# Remove arch and test directory if building outside source tree\n\t@if [ ! -f $(ARCHDIR)/Makefile.in ]; then rm -rf arch; fi\n\t@if [ ! -f test/Makefile.in ]; then rm -rf test; fi\n\ntags:\n\tetags $(SRCDIR)/*.[ch]\n"
        },
        {
          "name": "PORTING.md",
          "type": "blob",
          "size": 4.9267578125,
          "content": "Porting applications to use zlib-ng\n===================================\n\nZlib-ng can be used/compiled in two different modes, that require some\nconsideration by the application developer.\n\nChanges from zlib affecting native and compat modes\n---------------------------------------------------\nZlib-ng is not as conservative with memory allocation as Zlib is.\n\nWhere Zlib's inflate will allocate a lower amount of memory depending on\ncompression level and window size, zlib-ng will always allocate the maximum\namount of memory and possibly leave parts of it unused.\nZlib-ng's deflate will however allocate a lower amount of memory depending\non compression level and window size.\n\nZlib-ng also allocates one \"big\" buffer instead of doing multiple smaller\nallocations. This is faster, can lead to better cache locality and reduces\nspace lost to alignment padding.\n\nAt the time of writing, by default zlib-ng allocates the following amounts\nof memory on a 64-bit system (except on S390x that requires ~4KiB more):\n-  Deflate: 350.272 Bytes\n-  Inflate:  42.112 Bytes\n\n**Advantages:**\n- All memory is allocated during DeflateInit or InflateInit functions,\n  leaving the actual deflate/inflate functions free from allocations.\n- Zlib-ng can only fail from memory allocation errors during init.\n- Time spent doing memory allocation systemcalls is all done during init,\n  allowing applications to do prepare this before doing latency-sensitive\n  deflate/inflate later.\n- Can reduce wasted memory due to buffer alignment padding both by OS and zlib-ng.\n- Potentially improved memory locality.\n\n**Disadvantages:**\n- Zlib-ng allocates a little more memory than zlib does.\n\nzlib-compat mode\n----------------\nZlib-ng can be compiled in zlib-compat mode, suitable for zlib-replacement\nin a single application or system-wide.\n\nPlease note that zlib-ng in zlib-compat mode tries to maintain both API and\nABI compatibility with the original zlib. Any issues regarding compatibility\ncan be reported as bugs.\n\nIn certain instances you may not be able to simply replace the zlib library/dll\nfiles and expect the application to work. The application may need to be\nrecompiled against the zlib-ng headers and libs to ensure full compatibility.\n\nIt is also possible for the deflate output stream to differ from the original\nzlib due to algorithmic differences between the two libraries. Any tests or\napplications that depend on the exact length of the deflate stream being a\ncertain value will need to be updated.\n\n**Advantages:**\n- Easy to port to, since it only requires a recompile of the application and\n  no changes to the application code.\n\n**Disadvantages:**\n- Can conflict with a system-installed zlib, as that can often be linked in\n  by another library you are linking into your application. This can cause\n  crashes or incorrect output.\n- If your application is pre-allocating a memory buffer and you are providing\n  deflate/inflate init with your own allocator that allocates from that buffer\n  (looking at you nginx), you should be aware that zlib-ng needs to allocate\n  more memory than stock zlib needs. The same problem exists with Intels and\n  Cloudflares zlib forks. Doing this is not recommended since it makes it\n  very hard to maintain compatibility over time.\n\n**Build Considerations:**\n- Compile against the *zlib.h* provided by zlib-ng\n- Configuration header is named *zconf.h*\n- Static library is *libz.a* on Unix and macOS, or *zlib.lib* on Windows\n- Shared library is *libz.so* on Unix, *libz.dylib* on macOS, or *zlib1.dll*\n  on Windows\n- Type `z_size_t` is *unsigned __int64* on 64-bit Windows, and *unsigned long* on 32-bit Windows, Unix and macOS\n- Type `z_uintmax_t` is *unsigned long* in zlib-compat mode, and *size_t* with zlib-ng API\n\nzlib-ng native mode\n-------------------\nZlib-ng in native mode is suitable for co-existing with the standard zlib\nlibrary, allowing applications to implement support and testing separately.\n\nThe zlib-ng native has implemented some modernization and simplifications\nin its API, intended to make life easier for application developers.\n\n**Advantages:**\n- Does not conflict with other zlib implementations, and can co-exist as a\n  system library along with zlib.\n- In certain places zlib-ng native uses more appropriate data types, removing\n  the need for some workarounds in the API compared to zlib.\n\n**Disadvantages:**\n- Requires minor changes to applications to use the prefixed zlib-ng\n  function calls and structs. Usually this means a small prefix `zng_` has to be added.\n\n**Build Considerations:**\n- Compile against *zlib-ng.h*\n- Configuration header is named *zconf-ng.h*\n- Static library is *libz-ng.a* on Unix and macOS, or *zlib-ng.lib* on Windows\n- Shared library is *libz-ng.so* on Unix, *libz-ng.dylib* on macOS, or\n  *zlib-ng2.dll* on Windows\n- Type `z_size_t` is *size_t*\n\nzlib-ng compile-time detection\n------------------------------\n\nTo distinguish zlib-ng from other zlib implementations at compile-time check for the\nexistence of `ZLIBNG_VERSION` defined in the zlib header.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.4775390625,
          "content": "| CI | Stable | Develop |\n|:---|:-------|:--------|\n| GitHub Actions | [![Stable CMake](https://github.com/zlib-ng/zlib-ng/actions/workflows/cmake.yml/badge.svg?branch=stable)](https://github.com/zlib-ng/zlib-ng/actions/workflows/cmake.yml?query=branch%3Astable) <br> [![Stable Configure](https://github.com/zlib-ng/zlib-ng/actions/workflows/configure.yml/badge.svg?branch=stable)](https://github.com/zlib-ng/zlib-ng/actions/workflows/configure.yml?query=branch%3Astable) <br> [![Stable NMake](https://github.com/zlib-ng/zlib-ng/actions/workflows/nmake.yml/badge.svg?branch=stable)](https://github.com/zlib-ng/zlib-ng/actions/workflows/nmake.yml?query=branch%3Astable) | [![Develop CMake](https://github.com/zlib-ng/zlib-ng/actions/workflows/cmake.yml/badge.svg?branch=develop)](https://github.com/zlib-ng/zlib-ng/actions/workflows/cmake.yml?query=branch%3Adevelop) <br> [![Develop Configure](https://github.com/zlib-ng/zlib-ng/actions/workflows/configure.yml/badge.svg?branch=develop)](https://github.com/zlib-ng/zlib-ng/actions/workflows/configure.yml?query=branch%3Adevelop) <br> [![Develop NMake](https://github.com/zlib-ng/zlib-ng/actions/workflows/nmake.yml/badge.svg?branch=develop)](https://github.com/zlib-ng/zlib-ng/actions/workflows/nmake.yml?query=branch%3Adevelop) |\n| CodeFactor     | [![CodeFactor](https://www.codefactor.io/repository/github/zlib-ng/zlib-ng/badge/stable)](https://www.codefactor.io/repository/github/zlib-ng/zlib-ng/overview/stable) | [![CodeFactor](https://www.codefactor.io/repository/github/zlib-ng/zlib-ng/badge/develop)](https://www.codefactor.io/repository/github/zlib-ng/zlib-ng/overview/develop) |\n| OSS-Fuzz       | [![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/zlib-ng.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:zlib-ng) | [![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/zlib-ng.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:zlib-ng) |\n| Codecov        | [![codecov](https://codecov.io/github/zlib-ng/zlib-ng/branch/stable/graph/badge.svg?token=uKsgK9LIuC)](https://codecov.io/github/zlib-ng/zlib-ng/tree/stable) | [![codecov](https://codecov.io/github/zlib-ng/zlib-ng/branch/develop/graph/badge.svg?token=uKsgK9LIuC)](https://codecov.io/github/zlib-ng/zlib-ng/tree/develop) |\n\n## zlib-ng\n*zlib data compression library for the next generation systems*\n\nMaintained by Hans Kristian Rosbach\n          aka Dead2 (zlib-ng t circlestorm dt org)\n\nFeatures\n--------\n\n* Zlib compatible API with support for dual-linking\n* Modernized native API based on zlib API for ease of porting\n* Modern C11 syntax and a clean code layout\n* Deflate medium and quick algorithms based on Intels zlib fork\n* Support for CPU intrinsics when available\n  * Adler32 implementation using SSSE3, AVX2, AVX512, AVX512-VNNI, Neon, VMX & VSX\n  * CRC32-B implementation using PCLMULQDQ, VPCLMULQDQ, ACLE, & IBM Z\n  * Slide hash implementations using SSE2, AVX2, ARMv6, Neon, VMX & VSX\n  * Compare256 implementations using SSE2, AVX2, Neon, POWER9 & RVV\n  * Inflate chunk copying using SSE2, SSSE3, AVX, Neon & VSX\n  * Support for hardware-accelerated deflate using IBM Z DFLTCC\n* Safe unaligned memory read/writes and large bit buffer improvements\n* Includes improvements from Cloudflare and Intel forks\n* Configure, CMake, and NMake build system support\n* Comprehensive set of CMake unit tests\n* Code sanitizers, fuzzing, and coverage\n* GitHub Actions continuous integration on Windows, macOS, and Linux\n  * Emulated CI for ARM, AARCH64, PPC, PPC64, RISCV, SPARC64, S390x using qemu\n\n\nHistory\n-------\n\nThe motivation for this fork was seeing several 3rd party contributions with new optimizations not getting\nimplemented into the official zlib repository.\n\nMark Adler has been maintaining zlib for a very long time, and he has done a great job and hopefully he will continue\nfor a long time yet. The idea of zlib-ng is not to replace zlib, but to co-exist as a drop-in replacement with a\nlower threshold for code change.\n\nzlib has a long history and is incredibly portable, even supporting many systems that predate the Internet.<br>\nThat is great, but it can complicate further development and maintainability. The zlib code contains many workarounds\nfor really old compilers or to accommodate systems with limitations such as operating in a 16-bit environment.\n\nMany of these workarounds are only maintenance burdens, some of them are pretty huge code-wise. With many workarounds\ncluttered throughout the code, it makes it harder for new programmers with an idea/interest for zlib to contribute.\n\nI decided to make a fork, merge all the Intel optimizations, some of the Cloudflare optimizations, plus a couple other\nsmaller patches. Then started cleaning out workarounds, various dead code, all contrib and example code.<br>\nThe result is a better performing and easier to maintain zlib-ng.\n\nA lot of improvements have gone into zlib-ng since its start, and numerous people and companies have contributed both\nsmall and big improvements, or valuable testing.\n\n\nBuild\n-----\n<sup>Please read LICENSE.md, it is very simple and very liberal.</sup>\n\nThere are two ways to build zlib-ng:\n\n### Cmake\n\nTo build zlib-ng using the cross-platform makefile generator cmake.\n\n```\ncmake .\ncmake --build . --config Release\nctest --verbose -C Release\n```\n\nAlternatively, you can use the cmake configuration GUI tool ccmake:\n\n```\nccmake .\n```\n\n### Configure\n\nTo build zlib-ng using the bash configure script:\n\n```\n./configure\nmake\nmake test\n```\n\nBuild Options\n-------------\n\n| CMake                      | configure                | Description                                                                         | Default |\n|:---------------------------|:-------------------------|:------------------------------------------------------------------------------------|---------|\n| ZLIB_COMPAT                | --zlib-compat            | Compile with zlib compatible API                                                    | OFF     |\n| ZLIB_ENABLE_TESTS          |                          | Build test binaries                                                                 | ON      |\n| WITH_GZFILEOP              | --without-gzfileops      | Compile with support for gzFile related functions                                   | ON      |\n| WITH_OPTIM                 | --without-optimizations  | Build with optimisations                                                            | ON      |\n| WITH_NEW_STRATEGIES        | --without-new-strategies | Use new strategies                                                                  | ON      |\n| WITH_NATIVE_INSTRUCTIONS   |                          | Compiles with full instruction set supported on this host (gcc/clang -march=native) | OFF     |\n| WITH_RUNTIME_CPU_DETECTION |                          | Compiles with runtime CPU detection                                                 | ON      |\n| WITH_SANITIZER             |                          | Build with sanitizer (memory, address, undefined)                                   | OFF     |\n| WITH_GTEST                 |                          | Build gtest_zlib                                                                    | ON      |\n| WITH_FUZZERS               |                          | Build test/fuzz                                                                     | OFF     |\n| WITH_BENCHMARKS            |                          | Build test/benchmarks                                                               | OFF     |\n| WITH_MAINTAINER_WARNINGS   |                          | Build with project maintainer warnings                                              | OFF     |\n| WITH_CODE_COVERAGE         |                          | Enable code coverage reporting                                                      | OFF     |\n\n\nInstall\n-------\n\nWARNING: We do not recommend manually installing unless you really know what you are doing, because this can\npotentially override the system default zlib library, and any incompatibility or wrong configuration of zlib-ng\ncan make the whole system unusable, requiring recovery or reinstall.\nIf you still want a manual install, we recommend using the /opt/ path prefix.\n\nFor Linux distros, an alternative way to use zlib-ng (if compiled in zlib-compat mode) instead of zlib, is through\nthe use of the _LD_PRELOAD_ environment variable. If the program is dynamically linked with zlib, then the program\nwill temporarily attempt to use zlib-ng instead, without risking system-wide instability.\n\n```\nLD_PRELOAD=/opt/zlib-ng/libz.so.1.2.13.zlib-ng /usr/bin/program\n```\n\n### Cmake\n\nTo install zlib-ng system-wide using cmake:\n\n```sh or powershell\ncmake --build . --target install\n```\n\n### Configure\n\nTo install zlib-ng system-wide using the configure script:\n\n```sh\nmake install\n```\n\n### CPack\n\nAfter building with cmake, an installation package can be created using cpack. By default a tgz package is created,\nbut you can append `-G <format>` to each command to generate alternative packages types (TGZ, ZIP, RPM, DEB). To easily\ncreate a rpm or deb package, you would use `-G RPM` or `-G DEB` respectively.\n\n```sh or powershell\ncd build\ncpack --config CPackConfig.cmake\ncpack --config CPackSourceConfig.cmake\n```\n\n### Vcpkg\n\nAlternatively, you can build and install zlib-ng using the [vcpkg](https://github.com/Microsoft/vcpkg/) dependency manager:\n\n```sh or powershell\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh # \"./bootstrap-vcpkg.bat\" for powershell\n./vcpkg integrate install\n./vcpkg install zlib-ng\n```\n\nThe zlib-ng port in vcpkg is kept up to date by Microsoft team members and community contributors.\nIf the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\nContributing\n------------\n\nZlib-ng is aiming to be open to contributions, and we would be delighted to receive pull requests on github.\nHelp with testing and reviewing pull requests etc is also very much appreciated.\n\nPlease check the Wiki for more info: [Contributing](https://github.com/zlib-ng/zlib-ng/wiki/Contributing)\n\nAcknowledgments\n----------------\n\nThanks go out to all the people and companies who have taken the time to contribute\ncode reviews, testing and/or patches. Zlib-ng would not have been nearly as good without you.\n\nThe deflate format used by zlib was defined by Phil Katz.<br>\nThe deflate and zlib specifications were written by L. Peter Deutsch.\n\nzlib was originally created by Jean-loup Gailly (compression) and Mark Adler (decompression).\n\n\nAdvanced Build Options\n----------------------\n\n| CMake                           | configure             | Description                                                         | Default                |\n|:--------------------------------|:----------------------|:--------------------------------------------------------------------|------------------------|\n| FORCE_SSE2                      | --force-sse2          | Skip runtime check for SSE2 instructions (Always on for x86_64)     | OFF (x86)              |\n| WITH_AVX2                       |                       | Build with AVX2 intrinsics                                          | ON                     |\n| WITH_AVX512                     |                       | Build with AVX512 intrinsics                                        | ON                     |\n| WITH_AVX512VNNI                 |                       | Build with AVX512VNNI intrinsics                                    | ON                     |\n| WITH_SSE2                       |                       | Build with SSE2 intrinsics                                          | ON                     |\n| WITH_SSSE3                      |                       | Build with SSSE3 intrinsics                                         | ON                     |\n| WITH_SSE42                      |                       | Build with SSE42 intrinsics                                         | ON                     |\n| WITH_PCLMULQDQ                  |                       | Build with PCLMULQDQ intrinsics                                     | ON                     |\n| WITH_VPCLMULQDQ                 | --without-vpclmulqdq  | Build with VPCLMULQDQ intrinsics                                    | ON                     |\n| WITH_ACLE                       | --without-acle        | Build with ACLE intrinsics                                          | ON                     |\n| WITH_NEON                       | --without-neon        | Build with NEON intrinsics                                          | ON                     |\n| WITH_ARMV6                      | --without-armv6       | Build with ARMv6 intrinsics                                         | ON                     |\n| WITH_ALTIVEC                    | --without-altivec     | Build with AltiVec (VMX) intrinsics                                 | ON                     |\n| WITH_POWER8                     | --without-power8      | Build with POWER8 optimisations                                     | ON                     |\n| WITH_RVV                        |                       | Build with RVV intrinsics                                           | ON                     |\n| WITH_CRC32_VX                   | --without-crc32-vx    | Build with vectorized CRC32 on IBM Z                                | ON                     |\n| WITH_DFLTCC_DEFLATE             | --with-dfltcc-deflate | Build with DFLTCC intrinsics for compression on IBM Z               | OFF                    |\n| WITH_DFLTCC_INFLATE             | --with-dfltcc-inflate | Build with DFLTCC intrinsics for decompression on IBM Z             | OFF                    |\n| WITH_INFLATE_STRICT             |                       | Build with strict inflate distance checking                         | OFF                    |\n| WITH_INFLATE_ALLOW_INVALID_DIST |                       | Build with zero fill for inflate invalid distances                  | OFF                    |\n| INSTALL_UTILS                   |                       | Copy minigzip and minideflate during install                        | OFF                    |\n| ZLIBNG_ENABLE_TESTS             |                       | Test zlib-ng specific API                                           | ON                     |\n\n\nRelated Projects\n----------------\n\n* Fork of the popular minizip                   https://github.com/zlib-ng/minizip-ng\n* Python tool to benchmark minigzip/minideflate https://github.com/zlib-ng/deflatebench\n* Python tool to benchmark pigz                 https://github.com/zlib-ng/pigzbench\n* 3rd party patches for zlib-ng compatibility   https://github.com/zlib-ng/patches\n"
        },
        {
          "name": "adler32.c",
          "type": "blob",
          "size": 2.5732421875,
          "content": "/* adler32.c -- compute the Adler-32 checksum of a data stream\n * Copyright (C) 1995-2011, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"functable.h\"\n#include \"adler32_p.h\"\n\n#ifdef ZLIB_COMPAT\nunsigned long Z_EXPORT PREFIX(adler32_z)(unsigned long adler, const unsigned char *buf, size_t len) {\n    return (unsigned long)FUNCTABLE_CALL(adler32)((uint32_t)adler, buf, len);\n}\n#else\nuint32_t Z_EXPORT PREFIX(adler32_z)(uint32_t adler, const unsigned char *buf, size_t len) {\n    return FUNCTABLE_CALL(adler32)(adler, buf, len);\n}\n#endif\n\n/* ========================================================================= */\n#ifdef ZLIB_COMPAT\nunsigned long Z_EXPORT PREFIX(adler32)(unsigned long adler, const unsigned char *buf, unsigned int len) {\n    return (unsigned long)FUNCTABLE_CALL(adler32)((uint32_t)adler, buf, len);\n}\n#else\nuint32_t Z_EXPORT PREFIX(adler32)(uint32_t adler, const unsigned char *buf, uint32_t len) {\n    return FUNCTABLE_CALL(adler32)(adler, buf, len);\n}\n#endif\n\n/* ========================================================================= */\nstatic uint32_t adler32_combine_(uint32_t adler1, uint32_t adler2, z_off64_t len2) {\n    uint32_t sum1;\n    uint32_t sum2;\n    unsigned rem;\n\n    /* for negative len, return invalid adler32 as a clue for debugging */\n    if (len2 < 0)\n        return 0xffffffff;\n\n    /* the derivation of this formula is left as an exercise for the reader */\n    len2 %= BASE;                 /* assumes len2 >= 0 */\n    rem = (unsigned)len2;\n    sum1 = adler1 & 0xffff;\n    sum2 = rem * sum1;\n    sum2 %= BASE;\n    sum1 += (adler2 & 0xffff) + BASE - 1;\n    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);\n    if (sum2 >= BASE) sum2 -= BASE;\n    return sum1 | (sum2 << 16);\n}\n\n/* ========================================================================= */\n#ifdef ZLIB_COMPAT\nunsigned long Z_EXPORT PREFIX(adler32_combine)(unsigned long adler1, unsigned long adler2, z_off_t len2) {\n    return (unsigned long)adler32_combine_((uint32_t)adler1, (uint32_t)adler2, len2);\n}\n\nunsigned long Z_EXPORT PREFIX4(adler32_combine)(unsigned long adler1, unsigned long adler2, z_off64_t len2) {\n    return (unsigned long)adler32_combine_((uint32_t)adler1, (uint32_t)adler2, len2);\n}\n#else\nuint32_t Z_EXPORT PREFIX4(adler32_combine)(uint32_t adler1, uint32_t adler2, z_off64_t len2) {\n    return adler32_combine_(adler1, adler2, len2);\n}\n#endif\n"
        },
        {
          "name": "adler32_p.h",
          "type": "blob",
          "size": 2.2080078125,
          "content": "/* adler32_p.h -- Private inline functions and macros shared with\n *                different computation of the Adler-32 checksum\n *                of a data stream.\n * Copyright (C) 1995-2011, 2016 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef ADLER32_P_H\n#define ADLER32_P_H\n\n#define BASE 65521U     /* largest prime smaller than 65536 */\n#define NMAX 5552\n/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n\n#define DO1(sum1, sum2, buf, i)  {(sum1) += buf[(i)]; (sum2) += (sum1);}\n#define DO2(sum1, sum2, buf, i)  {DO1(sum1, sum2, buf, i); DO1(sum1, sum2, buf, i+1);}\n#define DO4(sum1, sum2, buf, i)  {DO2(sum1, sum2, buf, i); DO2(sum1, sum2, buf, i+2);}\n#define DO8(sum1, sum2, buf, i)  {DO4(sum1, sum2, buf, i); DO4(sum1, sum2, buf, i+4);}\n#define DO16(sum1, sum2, buf)    {DO8(sum1, sum2, buf, 0); DO8(sum1, sum2, buf, 8);}\n\nstatic inline uint32_t adler32_len_1(uint32_t adler, const uint8_t *buf, uint32_t sum2) {\n    adler += buf[0];\n    adler %= BASE;\n    sum2 += adler;\n    sum2 %= BASE;\n    return adler | (sum2 << 16);\n}\n\nstatic inline uint32_t adler32_len_16(uint32_t adler, const uint8_t *buf, size_t len, uint32_t sum2) {\n    while (len) {\n        --len;\n        adler += *buf++;\n        sum2 += adler;\n    }\n    adler %= BASE;\n    sum2 %= BASE;            /* only added so many BASE's */\n    /* return recombined sums */\n    return adler | (sum2 << 16);\n}\n\nstatic inline uint32_t adler32_copy_len_16(uint32_t adler, const uint8_t *buf, uint8_t *dst, size_t len, uint32_t sum2) {\n    while (len--) {\n        *dst = *buf++;\n        adler += *dst++;\n        sum2 += adler;\n    }\n    adler %= BASE;\n    sum2 %= BASE;            /* only added so many BASE's */\n    /* return recombined sums */\n    return adler | (sum2 << 16);\n}\n\nstatic inline uint32_t adler32_len_64(uint32_t adler, const uint8_t *buf, size_t len, uint32_t sum2) {\n#ifdef UNROLL_MORE\n    while (len >= 16) {\n        len -= 16;\n        DO16(adler, sum2, buf);\n        buf += 16;\n#else\n    while (len >= 8) {\n        len -= 8;\n        DO8(adler, sum2, buf, 0);\n        buf += 8;\n#endif\n    }\n    /* Process tail (len < 16).  */\n    return adler32_len_16(adler, buf, len, sum2);\n}\n\n#endif /* ADLER32_P_H */\n"
        },
        {
          "name": "arch",
          "type": "tree",
          "content": null
        },
        {
          "name": "arch_functions.h",
          "type": "blob",
          "size": 0.7529296875,
          "content": "/* arch_functions.h -- Arch-specific function prototypes.\n * Copyright (C) 2017 Hans Kristian Rosbach\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef CPU_FUNCTIONS_H_\n#define CPU_FUNCTIONS_H_\n\n#include \"zbuild.h\"\n#include \"zutil.h\"\n#include \"crc32.h\"\n#include \"deflate.h\"\n#include \"fallback_builtins.h\"\n\n#include \"arch/generic/generic_functions.h\"\n\n#if defined(X86_FEATURES)\n#  include \"arch/x86/x86_functions.h\"\n#elif defined(ARM_FEATURES)\n#  include \"arch/arm/arm_functions.h\"\n#elif defined(PPC_FEATURES) || defined(POWER_FEATURES)\n#  include \"arch/power/power_functions.h\"\n#elif defined(S390_FEATURES)\n#  include \"arch/s390/s390_functions.h\"\n#elif defined(RISCV_FEATURES)\n#  include \"arch/riscv/riscv_functions.h\"\n#endif\n\n#endif\n"
        },
        {
          "name": "chunkset_tpl.h",
          "type": "blob",
          "size": 9.033203125,
          "content": "/* chunkset_tpl.h -- inline functions to copy small data chunks.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include <stdlib.h>\n\n/* Returns the chunk size */\nZ_INTERNAL uint32_t CHUNKSIZE(void) {\n    return sizeof(chunk_t);\n}\n\n/* Behave like memcpy, but assume that it's OK to overwrite at least\n   chunk_t bytes of output even if the length is shorter than this,\n   that the length is non-zero, and that `from` lags `out` by at least\n   sizeof chunk_t bytes (or that they don't overlap at all or simply that\n   the distance is less than the length of the copy).\n\n   Aside from better memory bus utilisation, this means that short copies\n   (chunk_t bytes or fewer) will fall straight through the loop\n   without iteration, which will hopefully make the branch prediction more\n   reliable. */\n#ifndef HAVE_CHUNKCOPY\nstatic inline uint8_t* CHUNKCOPY(uint8_t *out, uint8_t const *from, unsigned len) {\n    Assert(len > 0, \"chunkcopy should never have a length 0\");\n    chunk_t chunk;\n    int32_t align = ((len - 1) % sizeof(chunk_t)) + 1;\n    loadchunk(from, &chunk);\n    storechunk(out, &chunk);\n    out += align;\n    from += align;\n    len -= align;\n    while (len > 0) {\n        loadchunk(from, &chunk);\n        storechunk(out, &chunk);\n        out += sizeof(chunk_t);\n        from += sizeof(chunk_t);\n        len -= sizeof(chunk_t);\n    }\n    return out;\n}\n#endif\n\n/* Perform short copies until distance can be rewritten as being at least\n   sizeof chunk_t.\n\n   This assumes that it's OK to overwrite at least the first\n   2*sizeof(chunk_t) bytes of output even if the copy is shorter than this.\n   This assumption holds because inflate_fast() starts every iteration with at\n   least 258 bytes of output space available (258 being the maximum length\n   output from a single token; see inflate_fast()'s assumptions below). */\n#ifndef HAVE_CHUNKUNROLL\nstatic inline uint8_t* CHUNKUNROLL(uint8_t *out, unsigned *dist, unsigned *len) {\n    unsigned char const *from = out - *dist;\n    chunk_t chunk;\n    while (*dist < *len && *dist < sizeof(chunk_t)) {\n        loadchunk(from, &chunk);\n        storechunk(out, &chunk);\n        out += *dist;\n        *len -= *dist;\n        *dist += *dist;\n    }\n    return out;\n}\n#endif\n\n#ifndef HAVE_CHUNK_MAG\n/* Loads a magazine to feed into memory of the pattern */\nstatic inline chunk_t GET_CHUNK_MAG(uint8_t *buf, uint32_t *chunk_rem, uint32_t dist) {\n        /* This code takes string of length dist from \"from\" and repeats\n         * it for as many times as can fit in a chunk_t (vector register) */\n        uint64_t cpy_dist;\n        uint64_t bytes_remaining = sizeof(chunk_t);\n        chunk_t chunk_load;\n        uint8_t *cur_chunk = (uint8_t *)&chunk_load;\n        while (bytes_remaining) {\n            cpy_dist = MIN(dist, bytes_remaining);\n            memcpy(cur_chunk, buf, (size_t)cpy_dist);\n            bytes_remaining -= cpy_dist;\n            cur_chunk += cpy_dist;\n            /* This allows us to bypass an expensive integer division since we're effectively\n             * counting in this loop, anyway */\n            *chunk_rem = (uint32_t)cpy_dist;\n        }\n\n        return chunk_load;\n}\n#endif\n\n#if defined(HAVE_HALF_CHUNK) && !defined(HAVE_HALFCHUNKCOPY)\nstatic inline uint8_t* HALFCHUNKCOPY(uint8_t *out, uint8_t const *from, unsigned len) {\n    halfchunk_t chunk;\n    int32_t align = ((len - 1) % sizeof(halfchunk_t)) + 1;\n    loadhalfchunk(from, &chunk);\n    storehalfchunk(out, &chunk);\n    out += align;\n    from += align;\n    len -= align;\n    while (len > 0) {\n        loadhalfchunk(from, &chunk);\n        storehalfchunk(out, &chunk);\n        out += sizeof(halfchunk_t);\n        from += sizeof(halfchunk_t);\n        len -= sizeof(halfchunk_t);\n    }\n    return out;\n}\n#endif\n\n/* Copy DIST bytes from OUT - DIST into OUT + DIST * k, for 0 <= k < LEN/DIST.\n   Return OUT + LEN. */\nstatic inline uint8_t* CHUNKMEMSET(uint8_t *out, uint8_t *from, unsigned len) {\n    /* Debug performance related issues when len < sizeof(uint64_t):\n       Assert(len >= sizeof(uint64_t), \"chunkmemset should be called on larger chunks\"); */\n    Assert(from != out, \"chunkmemset cannot have a distance 0\");\n\n    chunk_t chunk_load;\n    uint32_t chunk_mod = 0;\n    uint32_t adv_amount;\n    int64_t sdist = out - from;\n    uint64_t dist = llabs(sdist);\n\n    /* We are supporting the case for when we are reading bytes from ahead in the buffer.\n     * We now have to handle this, though it wasn't _quite_ clear if this rare circumstance\n     * always needed to be handled here or if we're just now seeing it because we are\n     * dispatching to this function, more */\n    if (sdist < 0 && dist < len) {\n#ifdef HAVE_MASKED_READWRITE\n        /* We can still handle this case if we can mitigate over writing _and_ we\n         * fit the entirety of the copy length with one load */\n        if (len <= sizeof(chunk_t)) {\n            /* Tempting to add a goto to the block below but hopefully most compilers\n             * collapse these identical code segments as one label to jump to */\n            return CHUNKCOPY(out, from, len);\n        }\n#endif\n        /* Here the memmove semantics match perfectly, as when this happens we are\n         * effectively sliding down the contents of memory by dist bytes */\n        memmove(out, from, len);\n        return out + len;\n    }\n\n    if (dist == 1) {\n        memset(out, *from, len);\n        return out + len;\n    } else if (dist >= sizeof(chunk_t)) {\n        return CHUNKCOPY(out, from, len);\n    }\n\n    /* Only AVX2+ as there's 128 bit vectors and 256 bit. We allow for shorter vector\n     * lengths because they serve to allow more cases to fall into chunkcopy, as the\n     * distance of the shorter length is still deemed a safe distance. We rewrite this\n     * here rather than calling the ssse3 variant directly now because doing so required\n     * dispatching to another function and broke inlining for this function entirely. We\n     * also can merge an assert and some remainder peeling behavior into the same code blocks,\n     * making the code a little smaller.  */\n#ifdef HAVE_HALF_CHUNK\n    if (len <= sizeof(halfchunk_t)) {\n        if (dist >= sizeof(halfchunk_t))\n            return HALFCHUNKCOPY(out, from, len);\n\n        if ((dist % 2) != 0 || dist == 6) {\n            halfchunk_t halfchunk_load = GET_HALFCHUNK_MAG(from, &chunk_mod, (unsigned)dist);\n\n            if (len == sizeof(halfchunk_t)) {\n                storehalfchunk(out, &halfchunk_load);\n                len -= sizeof(halfchunk_t);\n                out += sizeof(halfchunk_t);\n            }\n\n            chunk_load = halfchunk2whole(&halfchunk_load);\n            goto rem_bytes;\n        }\n    }\n#endif\n\n#ifdef HAVE_CHUNKMEMSET_2\n    if (dist == 2) {\n        chunkmemset_2(from, &chunk_load);\n    } else\n#endif\n#ifdef HAVE_CHUNKMEMSET_4\n    if (dist == 4) {\n        chunkmemset_4(from, &chunk_load);\n    } else\n#endif\n#ifdef HAVE_CHUNKMEMSET_8\n    if (dist == 8) {\n        chunkmemset_8(from, &chunk_load);\n    } else\n#endif\n#ifdef HAVE_CHUNKMEMSET_16\n    if (dist == 16) {\n        chunkmemset_16(from, &chunk_load);\n    } else\n#endif\n    chunk_load = GET_CHUNK_MAG(from, &chunk_mod, (unsigned)dist);\n\n    adv_amount = sizeof(chunk_t) - chunk_mod;\n\n    while (len >= (2 * sizeof(chunk_t))) {\n        storechunk(out, &chunk_load);\n        storechunk(out + adv_amount, &chunk_load);\n        out += 2 * adv_amount;\n        len -= 2 * adv_amount;\n    }\n\n    /* If we don't have a \"dist\" length that divides evenly into a vector\n     * register, we can write the whole vector register but we need only\n     * advance by the amount of the whole string that fits in our chunk_t.\n     * If we do divide evenly into the vector length, adv_amount = chunk_t size*/\n    while (len >= sizeof(chunk_t)) {\n        storechunk(out, &chunk_load);\n        len -= adv_amount;\n        out += adv_amount;\n    }\n\n#ifdef HAVE_HALF_CHUNK\nrem_bytes:\n#endif\n    if (len) {\n        memcpy(out, &chunk_load, len);\n        out += len;\n    }\n\n    return out;\n}\n\nZ_INTERNAL uint8_t* CHUNKMEMSET_SAFE(uint8_t *out, uint8_t *from, unsigned len, unsigned left) {\n#if OPTIMAL_CMP < 32\n    static const uint32_t align_mask = 7;\n#elif OPTIMAL_CMP == 32\n    static const uint32_t align_mask = 3;\n#endif\n\n    len = MIN(len, left);\n\n#if OPTIMAL_CMP < 64\n    while (((uintptr_t)out & align_mask) && (len > 0)) {\n        *out++ = *from++;\n        --len;\n        --left;\n    }\n#endif\n\n#ifndef HAVE_MASKED_READWRITE\n    if (UNLIKELY(left < sizeof(chunk_t))) {\n        while (len > 0) {\n            *out++ = *from++;\n            --len;\n        }\n\n        return out;\n    }\n#endif\n\n    if (len)\n        out = CHUNKMEMSET(out, from, len);\n\n    return out;\n}\n\nstatic inline uint8_t *CHUNKCOPY_SAFE(uint8_t *out, uint8_t *from, uint64_t len, uint8_t *safe)\n{\n    if (out == from)\n        return out + len;\n\n    uint64_t safelen = (safe - out);\n    len = MIN(len, safelen);\n\n#ifndef HAVE_MASKED_READWRITE\n    uint64_t from_dist = (uint64_t)llabs(safe - from);\n    if (UNLIKELY(from_dist < sizeof(chunk_t) || safelen < sizeof(chunk_t))) {\n        while (len--) {\n            *out++ = *from++;\n        }\n\n        return out;\n    }\n#endif\n\n    return CHUNKMEMSET(out, from, (unsigned)len);\n}\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "compare256_rle.h",
          "type": "blob",
          "size": 3.2900390625,
          "content": "/* compare256_rle.h -- 256 byte run-length encoding comparison\n * Copyright (C) 2022 Nathan Moinvaziri\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zmemory.h\"\n#include \"fallback_builtins.h\"\n\ntypedef uint32_t (*compare256_rle_func)(const uint8_t* src0, const uint8_t* src1);\n\n/* 8-bit integer comparison */\nstatic inline uint32_t compare256_rle_8(const uint8_t *src0, const uint8_t *src1) {\n    uint32_t len = 0;\n\n    do {\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n        if (*src0 != *src1)\n            return len;\n        src1 += 1, len += 1;\n    } while (len < 256);\n\n    return 256;\n}\n\n/* 16-bit integer comparison */\nstatic inline uint32_t compare256_rle_16(const uint8_t *src0, const uint8_t *src1) {\n    uint32_t len = 0;\n    uint16_t src0_cmp;\n\n    src0_cmp = zng_memread_2(src0);\n\n    do {\n        if (src0_cmp != zng_memread_2(src1))\n            return len + (*src0 == *src1);\n        src1 += 2, len += 2;\n        if (src0_cmp != zng_memread_2(src1))\n            return len + (*src0 == *src1);\n        src1 += 2, len += 2;\n        if (src0_cmp != zng_memread_2(src1))\n            return len + (*src0 == *src1);\n        src1 += 2, len += 2;\n        if (src0_cmp != zng_memread_2(src1))\n            return len + (*src0 == *src1);\n        src1 += 2, len += 2;\n    } while (len < 256);\n\n    return 256;\n}\n\n#ifdef HAVE_BUILTIN_CTZ\n/* 32-bit integer comparison */\nstatic inline uint32_t compare256_rle_32(const uint8_t *src0, const uint8_t *src1) {\n    uint32_t sv, len = 0;\n    uint16_t src0_cmp;\n\n    src0_cmp = zng_memread_2(src0);\n    sv = ((uint32_t)src0_cmp << 16) | src0_cmp;\n\n    do {\n        uint32_t mv, diff;\n\n        mv = zng_memread_4(src1);\n\n        diff = sv ^ mv;\n        if (diff) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n            uint32_t match_byte = __builtin_ctz(diff) / 8;\n#else\n            uint32_t match_byte = __builtin_clz(diff) / 8;\n#endif\n            return len + match_byte;\n        }\n\n        src1 += 4, len += 4;\n    } while (len < 256);\n\n    return 256;\n}\n#endif\n\n#ifdef HAVE_BUILTIN_CTZLL\n/* 64-bit integer comparison */\nstatic inline uint32_t compare256_rle_64(const uint8_t *src0, const uint8_t *src1) {\n    uint32_t src0_cmp32, len = 0;\n    uint16_t src0_cmp;\n    uint64_t sv;\n\n    src0_cmp = zng_memread_2(src0);\n    src0_cmp32 = ((uint32_t)src0_cmp << 16) | src0_cmp;\n    sv = ((uint64_t)src0_cmp32 << 32) | src0_cmp32;\n\n    do {\n        uint64_t mv, diff;\n\n        mv = zng_memread_8(src1);\n\n        diff = sv ^ mv;\n        if (diff) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n            uint64_t match_byte = __builtin_ctzll(diff) / 8;\n#else\n            uint64_t match_byte = __builtin_clzll(diff) / 8;\n#endif\n            return len + (uint32_t)match_byte;\n        }\n\n        src1 += 8, len += 8;\n    } while (len < 256);\n\n    return 256;\n}\n#endif\n"
        },
        {
          "name": "compress.c",
          "type": "blob",
          "size": 3.7998046875,
          "content": "/* compress.c -- compress a memory buffer\n * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil.h\"\n\n/* ===========================================================================\n *  Architecture-specific hooks.\n */\n#ifdef S390_DFLTCC_DEFLATE\n#  include \"arch/s390/dfltcc_common.h\"\n#else\n/* Returns the upper bound on compressed data length based on uncompressed data length, assuming default settings.\n * Zero means that arch-specific deflation code behaves identically to the regular zlib-ng algorithms. */\n#  define DEFLATE_BOUND_COMPLEN(source_len) 0\n#endif\n\n/* ===========================================================================\n     Compresses the source buffer into the destination buffer. The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer. Upon entry, destLen is the total size of the\n   destination buffer, which must be at least 0.1% larger than sourceLen plus\n   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\nint Z_EXPORT PREFIX(compress2)(unsigned char *dest, z_uintmax_t *destLen, const unsigned char *source,\n                        z_uintmax_t sourceLen, int level) {\n    PREFIX3(stream) stream;\n    int err;\n    const unsigned int max = (unsigned int)-1;\n    z_size_t left;\n\n    left = *destLen;\n    *destLen = 0;\n\n    stream.zalloc = NULL;\n    stream.zfree = NULL;\n    stream.opaque = NULL;\n\n    err = PREFIX(deflateInit)(&stream, level);\n    if (err != Z_OK)\n        return err;\n\n    stream.next_out = dest;\n    stream.avail_out = 0;\n    stream.next_in = (z_const unsigned char *)source;\n    stream.avail_in = 0;\n\n    do {\n        if (stream.avail_out == 0) {\n            stream.avail_out = left > (unsigned long)max ? max : (unsigned int)left;\n            left -= stream.avail_out;\n        }\n        if (stream.avail_in == 0) {\n            stream.avail_in = sourceLen > (unsigned long)max ? max : (unsigned int)sourceLen;\n            sourceLen -= stream.avail_in;\n        }\n        err = PREFIX(deflate)(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);\n    } while (err == Z_OK);\n\n    *destLen = stream.total_out;\n    PREFIX(deflateEnd)(&stream);\n    return err == Z_STREAM_END ? Z_OK : err;\n}\n\n/* ===========================================================================\n */\nint Z_EXPORT PREFIX(compress)(unsigned char *dest, z_uintmax_t *destLen, const unsigned char *source, z_uintmax_t sourceLen) {\n    return PREFIX(compress2)(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);\n}\n\n/* ===========================================================================\n   If the default memLevel or windowBits for deflateInit() is changed, then\n   this function needs to be updated.\n */\nz_uintmax_t Z_EXPORT PREFIX(compressBound)(z_uintmax_t sourceLen) {\n    z_uintmax_t complen = DEFLATE_BOUND_COMPLEN(sourceLen);\n\n    if (complen > 0)\n        /* Architecture-specific code provided an upper bound. */\n        return complen + ZLIB_WRAPLEN;\n\n#ifndef NO_QUICK_STRATEGY\n    return sourceLen                       /* The source size itself */\n      + (sourceLen == 0 ? 1 : 0)           /* Always at least one byte for any input */\n      + (sourceLen < 9 ? 1 : 0)            /* One extra byte for lengths less than 9 */\n      + DEFLATE_QUICK_OVERHEAD(sourceLen)  /* Source encoding overhead, padded to next full byte */\n      + DEFLATE_BLOCK_OVERHEAD             /* Deflate block overhead bytes */\n      + ZLIB_WRAPLEN;                      /* zlib wrapper */\n#else\n    return sourceLen + (sourceLen >> 4) + 7 + ZLIB_WRAPLEN;\n#endif\n}\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 73.0458984375,
          "content": "#!/bin/sh\n# configure script for zlib.\n#\n# Normally configure builds both a static and a shared library.\n# If you want to build just a static library, use: ./configure --static\n#\n# To impose specific compiler or flags or install directory, use for example:\n#    prefix=$HOME CC=cc CFLAGS=\"-O4\" ./configure\n# or for csh/tcsh users:\n#    (setenv prefix $HOME; setenv CC cc; setenv CFLAGS \"-O4\"; ./configure)\n\n# Incorrect settings of CC or CFLAGS may prevent creating a shared library.\n# If you have problems, try without defining CC and CFLAGS before reporting\n# an error.\n\n# start off configure.log\necho -------------------- >> configure.log\necho $0 $* >> configure.log\ndate >> configure.log\n\nSRCDIR=$(cd $(dirname $0); pwd)\nBUILDDIR=$(pwd)\n\n# set command prefix for cross-compilation\nif [ -n \"${CHOST}\" ]; then\n    # normalize the chost before parsing it\n    NORM_CHOST=$(sh \"$SRCDIR\"/tools/config.sub $CHOST)\n    uname=\"$(echo \"${NORM_CHOST}\" | sed -e 's/^[^-]*-\\([^-]*\\)$/\\1/' -e 's/^[^-]*-[^-]*-\\([^-]*\\)$/\\1/' -e 's/^[^-]*-[^-]*-\\([^-]*\\)-.*$/\\1/')\"\n    CROSS_PREFIX=\"${CHOST}-\"\n    ARCH=\"$(echo \"${NORM_CHOST}\" | sed -e 's/-.*//')\"\nelse\n    ARCH=\"$(uname -m)\"\nfi\n\ncase \"${ARCH}\" in\n    x86_64)\n        case \"${CFLAGS}\" in\n            *-m32*)\n                ARCH=i686\n            ;;\n        esac\n    ;;\n    i386 | i486 | i586 | i686)\n        case \"${CFLAGS}\" in\n            *-m64*)\n                ARCH=x86_64\n            ;;\n        esac\n    ;;\nesac\n\n# destination name for windows import library\nIMPORTLIB=\n\n# establish commands for library building\nif \"${CROSS_PREFIX}ar\" --version >/dev/null 2>/dev/null || test $? -lt 126; then\n    AR=${AR-\"${CROSS_PREFIX}ar\"}\n    test -n \"${CROSS_PREFIX}\" && echo Using ${AR} | tee -a configure.log\nelse\n    AR=${AR-\"ar\"}\n    test -n \"${CROSS_PREFIX}\" && echo Using ${AR} | tee -a configure.log\nfi\nARFLAGS=${ARFLAGS-\"rc\"}\nif \"${CROSS_PREFIX}ranlib\" --version >/dev/null 2>/dev/null || test $? -lt 126; then\n    RANLIB=${RANLIB-\"${CROSS_PREFIX}ranlib\"}\n    test -n \"${CROSS_PREFIX}\" && echo Using ${RANLIB} | tee -a configure.log\nelse\n    RANLIB=${RANLIB-\"ranlib\"}\nfi\n\n# set defaults before processing command line options\nLDCONFIG=${LDCONFIG-\"ldconfig\"}\nDEFFILE=\nRC=\nRCFLAGS=\nRCOBJS=\nSTRIP=\nARCHS=\nPC_CFLAGS=\nprefix=${prefix-/usr/local}\nexec_prefix=${exec_prefix-'${prefix}'}\nbindir=${bindir-'${exec_prefix}/bin'}\nlibdir=${libdir-'${exec_prefix}/lib'}\nsharedlibdir=${sharedlibdir-'${libdir}'}\nincludedir=${includedir-'${prefix}/include'}\nmandir=${mandir-'${prefix}/share/man'}\nshared_ext='.so'\nshared=1\ngzfileops=1\ncompat=0\ncover=0\nbuild32=0\nbuild64=0\nbuildvpclmulqdq=1\nbuildacle=1\nbuildarmv6=1\nbuildaltivec=1\nbuildpower8=1\nbuildpower9=1\nbuildneon=1\nbuilddfltccdeflate=0\nbuilddfltccinflate=0\nbuildcrc32vx=1\nfloatabi=\nforcesse2=0\n# For CPUs that can benefit from AVX512, it seems GCC generates suboptimal\n# instruction scheduling unless you specify a reasonable -mtune= target\navx512flag=\"-mavx512f -mavx512dq -mavx512bw -mavx512vl -mbmi2\"\navx512vnniflag=\"${avx512flag} -mavx512vnni\"\navx2flag=\"-mavx2 -mbmi2\"\nsse2flag=\"-msse2\"\nssse3flag=\"-mssse3\"\nsse42flag=\"-msse4.2\"\npclmulflag=\"-mpclmul\"\nvpclmulflag=\"-mvpclmulqdq -mavx512f\"\nxsaveflag=\"-mxsave\"\nacleflag=\nneonflag=\narmv6flag=\nnoltoflag=\"-fno-lto\"\nvgfmaflag=\"-march=z13\"\nvmxflag=\"-maltivec\"\nsymbol_prefix=\"\"\nwithout_optimizations=0\nwithout_new_strategies=0\nreducedmem=0\ngcc=0\nwarn=0\ndebug=0\nvisibility=1\nold_cc=\"$CC\"\nold_cflags=\"$CFLAGS\"\nOBJC='$(OBJZ)'\nPIC_OBJC='$(PIC_OBJZ)'\nINSTALLTARGETS=\"install-shared install-static\"\nUNINSTALLTARGETS=\"uninstall-shared uninstall-static\"\n\nTEST=\"teststatic\"\n\n# leave this script, optionally in a bad way\nleave()\n{\n  if test \"$*\" != \"0\"; then\n    echo \"** $0 aborting.\" | tee -a configure.log\n  fi\n  rm -f $test.[co] $test $test$shared_ext $test.gcno ./--version\n  echo -------------------- >> configure.log\n  echo >> configure.log\n  echo >> configure.log\n  exit $1\n}\n\n# process command line options\nwhile test $# -ge 1\ndo\ncase \"$1\" in\n    -h* | --help)\n      echo 'usage:' | tee -a configure.log\n      echo '  configure [--prefix=PREFIX]  [--eprefix=EXPREFIX]' | tee -a configure.log\n      echo '    [--static] [--32] [--64] [--libdir=LIBDIR] [--sharedlibdir=LIBDIR]' | tee -a configure.log\n      echo '    [--includedir=INCLUDEDIR] [--mandir=MANDIR] [--archs=\"-arch i386 -arch x86_64\"]' | tee -a configure.log\n      echo '    [--sprefix=SYMBOL_PREFIX]   Adds a prefix to all exported symbols' | tee -a configure.log\n      echo '    [--warn]                    Enables extra compiler warnings' | tee -a configure.log\n      echo '    [--debug]                   Enables extra debug prints during operation' | tee -a configure.log\n      echo '    [--zlib-compat]             Compiles for zlib-compatible API instead of zlib-ng API' | tee -a configure.log\n      echo '    [--without-gzfileops]       Compiles without the gzfile parts of the API enabled' | tee -a configure.log\n      echo '    [--without-optimizations]   Compiles without support for optional instruction sets' | tee -a configure.log\n      echo '    [--without-new-strategies]  Compiles without using new additional deflate strategies' | tee -a configure.log\n      echo '    [--without-acle]            Compiles without ARM C Language Extensions' | tee -a configure.log\n      echo '    [--without-neon]            Compiles without ARM Neon SIMD instruction set' | tee -a configure.log\n      echo '    [--without-armv6]           Compiles without ARMv6 SIMD instruction set' | tee -a configure.log\n      echo '    [--without-altivec]         Compiles without PPC AltiVec support' | tee -a configure.log\n      echo '    [--without-power8]          Compiles without Power8 instruction set' | tee -a configure.log\n      echo '    [--with-dfltcc-deflate]     Use DEFLATE CONVERSION CALL instruction for compression on IBM Z' | tee -a configure.log\n      echo '    [--with-dfltcc-inflate]     Use DEFLATE CONVERSION CALL instruction for decompression on IBM Z' | tee -a configure.log\n      echo '    [--without-crc32-vx]        Build without vectorized CRC32 on IBM Z' | tee -a configure.log\n      echo '    [--with-reduced-mem]        Reduced memory usage for special cases (reduces performance)' | tee -a configure.log\n      echo '    [--force-sse2]              Assume SSE2 instructions are always available (disabled by default on x86, enabled on x86_64)' | tee -a configure.log\n        exit 0 ;;\n    -p*=* | --prefix=*) prefix=$(echo $1 | sed 's/.*=//'); shift ;;\n    -e*=* | --eprefix=*) exec_prefix=$(echo $1 | sed 's/.*=//'); shift ;;\n    -m*=* | --sprefix=*) symbol_prefix=$(echo $1 | sed 's/.*=//'); shift ;;\n    -l*=* | --libdir=*) libdir=$(echo $1 | sed 's/.*=//'); shift ;;\n    --sharedlibdir=*) sharedlibdir=$(echo $1 | sed 's/.*=//'); shift ;;\n    -i*=* | --includedir=*) includedir=$(echo $1 | sed 's/.*=//');shift ;;\n    --mandir=*) mandir=$(echo $1 | sed 's/.*=//');shift ;;\n    -u*=* | --uname=*) uname=$(echo $1 | sed 's/.*=//');shift ;;\n    -p* | --prefix) prefix=\"$2\"; shift; shift ;;\n    -e* | --eprefix) exec_prefix=\"$2\"; shift; shift ;;\n    -m* | --sprefix) symbol_prefix=\"$2\"; shift; shift ;;\n    -l* | --libdir) libdir=\"$2\"; shift; shift ;;\n    -i* | --includedir) includedir=\"$2\"; shift; shift ;;\n    -s* | --shared | --enable-shared) shared=1; shift ;;\n    -t | --static) shared=0; shift ;;\n    --zlib-compat) compat=1; shift ;;\n    --without-gzfileops) gzfileops=0; shift ;;\n    --cover) cover=1; shift ;;\n    -3* | --32) build32=1; shift ;;\n    -6* | --64) build64=1; shift ;;\n    --without-vpclmulqdq) buildvpclmulqdq=0; shift ;;\n    --without-acle) buildacle=0; shift ;;\n    --without-neon) buildneon=0; shift ;;\n    --without-armv6) buildarmv6=0; shift ;;\n    --without-altivec) buildaltivec=0 ; shift ;;\n    --without-power8) buildpower8=0 ; shift ;;\n    --without-power9) buildpower9=0 ; shift ;;\n    --with-dfltcc-deflate) builddfltccdeflate=1; shift ;;\n    --with-dfltcc-inflate) builddfltccinflate=1; shift ;;\n    --without-crc32-vx) buildcrc32vx=0; shift ;;\n    --with-reduced-mem) reducedmem=1; shift ;;\n    --force-sse2) forcesse2=1; shift ;;\n    -a*=* | --archs=*) ARCHS=$(echo $1 | sed 's/.*=//'); shift ;;\n    --sysconfdir=*) echo \"ignored option: --sysconfdir\" | tee -a configure.log; shift ;;\n    --localstatedir=*) echo \"ignored option: --localstatedir\" | tee -a configure.log; shift ;;\n    -noopt | --without-optimizations) without_optimizations=1; shift;;\n    -oldstrat | --without-new-strategies) without_new_strategies=1; shift;;\n    -w* | --warn) warn=1; shift ;;\n    -d* | --debug) debug=1; shift ;;\n\n    *)\n      echo \"unknown option: $1\" | tee -a configure.log\n      echo \"$0 --help for help\" | tee -a configure.log\n      leave 1;;\n    esac\ndone\n\n# temporary file name\ntest=ztest$$\n\n# put arguments in log, also put test file in log if used in arguments\nshow()\n{\n  case \"$@\" in\n    *$test.c*)\n      echo \"=== $test.c ===\" >> configure.log\n      cat $test.c >> configure.log\n      echo \"===\" >> configure.log;;\n  esac\n  echo \"$@\" >> configure.log\n}\n\n# check for gcc vs. cc and set compile and link flags based on the system identified by uname\ncat > $test.c <<EOF\nextern int getchar();\nint main() {return getchar();}\nEOF\n\ncc=${CC-${CROSS_PREFIX}gcc}\nprintf \"Checking for compiler... \" | tee -a configure.log\ncase \"$cc\" in\n  *gcc*) gcc=1 ;;\n  *clang*) gcc=1 ;;\nesac\ncase $($cc -v 2>&1) in\n  *gcc*) gcc=1 ;;\n  *clang*) gcc=1 ;;\nesac\n\nif test $build32 -eq 1; then\n  CFLAGS=\"${CFLAGS} -m32\"\n  SFLAGS=\"${SFLAGS} -m32\"\n  LDFLAGS=\"${LDFLAGS} -m32\"\nfi\nif test $build64 -eq 1; then\n  CFLAGS=\"${CFLAGS} -m64\"\n  SFLAGS=\"${SFLAGS} -m64\"\n  LDFLAGS=\"${LDFLAGS} -m64\"\nfi\n\n# Set library name depending on zlib-compat option\nif test $compat -eq 0; then\n  LIBNAME=libz-ng\n  LIBNAME2=zlib-ng\n  SUFFIX=-ng\nelse\n  LIBNAME=libz\n  LIBNAME2=zlib\n  SUFFIX=\"\"\nfi\n\nSTATICLIB=${LIBNAME}.a\nMAPNAME=${LIBNAME2}.map\n\n# extract zlib version numbers from zlib.h\nif test $compat -eq 0; then\n  VER=$(sed -n -e '/ZLIBNG_VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < ${SRCDIR}/zlib-ng.h.in)\n  VER3=$(sed -n -e '/ZLIBNG_VERSION \"/s/.*\"\\([0-9]*\\.[0-9]*\\.[0-9]*\\).*/\\1/p' < ${SRCDIR}/zlib-ng.h.in)\n  VER2=$(sed -n -e '/ZLIBNG_VERSION \"/s/.*\"\\([0-9]*\\.[0-9]*\\)\\..*/\\1/p' < ${SRCDIR}/zlib-ng.h.in)\n  VER1=$(sed -n -e '/ZLIBNG_VERSION \"/s/.*\"\\([0-9]*\\)\\..*/\\1/p' < ${SRCDIR}/zlib-ng.h.in)\nelse\n  VER=$(sed -n -e '/ZLIB_VERSION \"/s/.*\"\\(.*\\)\".*/\\1/p' < ${SRCDIR}/zlib.h.in)\n  VER3=$(sed -n -e '/ZLIB_VERSION \"/s/.*\"\\([0-9]*\\.[0-9]*\\.[0-9]*\\).*/\\1/p' < ${SRCDIR}/zlib.h.in)\n  VER2=$(sed -n -e '/ZLIB_VERSION \"/s/.*\"\\([0-9]*\\.[0-9]*\\)\\..*/\\1/p' < ${SRCDIR}/zlib.h.in)\n  VER1=$(sed -n -e '/ZLIB_VERSION \"/s/.*\"\\([0-9]*\\)\\..*/\\1/p' < ${SRCDIR}/zlib.h.in)\nfi\n\nshow $cc -c $test.c\nif test \"$gcc\" -eq 1 && ($cc $CFLAGS -c $test.c) >> configure.log 2>&1; then\n  echo \"$cc\" | tee -a configure.log\n  CC=\"$cc\"\n  if test \"${CFLAGS#*\"-std=\"}\" = \"$CFLAGS\" ; then\n    CFLAGS=\"${CFLAGS} -std=c11\"\n  fi\n\n  # Re-check ARCH if the compiler is a cross-compiler.\n  if $CC -print-multiarch 1> /dev/null 2>&1 && test -n \"$($CC -print-multiarch)\" 1> /dev/null 2>&1; then\n      CC_ARCH=$($CC $CFLAGS -print-multiarch | sed 's/-.*//g')\n  else\n      CC_ARCH=$($CC $CFLAGS -dumpmachine | sed 's/-.*//g')\n  fi\n  case $CC_ARCH in\n    i386 | i486 | i586 | i686)\n      # Honor user choice if gcc is multilib and 64-bit is requested\n      if test $build64 -eq 1; then\n        ARCH=x86_64\n      else\n        ARCH=$CC_ARCH\n      fi ;;\n    x86_64)\n      # Honor user choice if gcc is multilib and 32-bit is requested\n      if test $build32 -ne 1; then\n        ARCH=$CC_ARCH\n      fi ;;\n    arm | armeb)\n      ARCH=arm\n      if test \"${uname}\" = \"eabi\"; then\n        uname=arm\n      fi ;;\n    armv8l)\n      ARCH=armv8-a ;;\n    aarch64 | aarch64_be | arm64)\n      if test \"${uname}\" = \"elf\"; then\n        uname=aarch64\n      fi\n      ARCH=aarch64 ;;\n    powerpc | ppc)\n      ARCH=powerpc ;;\n    powerpc64 | ppc64)\n      ARCH=powerpc64 ;;\n    powerpc64le | ppc64le)\n      ARCH=powerpc64le ;;\n  esac\n  CFLAGS=\"-O2 ${CFLAGS}\"\n  if test -n \"${ARCHS}\"; then\n    CFLAGS=\"${CFLAGS} ${ARCHS}\"\n    LDFLAGS=\"${LDFLAGS} ${ARCHS}\"\n  fi\n  CFLAGS=\"${CFLAGS} -Wall\"\n  SFLAGS=\"${CFLAGS} -fPIC\"\n  if test \"$warn\" -eq 1; then\n    CFLAGS=\"${CFLAGS} -Wextra\"\n  fi\n  if test $debug -eq 1; then\n    CFLAGS=\"${CFLAGS} -DZLIB_DEBUG\"\n    SFLAGS=\"${SFLAGS} -DZLIB_DEBUG\"\n  else\n    CFLAGS=\"${CFLAGS} -DNDEBUG\"\n    SFLAGS=\"${SFLAGS} -DNDEBUG\"\n  fi\n  if test -z \"$uname\"; then\n    uname=$( (uname -s || echo unknown) 2>/dev/null)\n  fi\n  case \"$uname\" in\n  Linux* | linux* | GNU | GNU/* | solaris* | Haiku)\n        LDSHARED=${LDSHARED-\"$cc\"}\n        LDSHAREDFLAGS=\"-shared -Wl,-soname,${LIBNAME}.so.${VER1}\" ;;\n  *BSD | *bsd* | DragonFly)\n        LDSHARED=${LDSHARED-\"$cc\"}\n        LDSHAREDFLAGS=\"-shared -Wl,-soname,${LIBNAME}.so.${VER1}\"\n        LDCONFIG=\"ldconfig -m\" ;;\n  CYGWIN* | Cygwin* | cygwin*)\n        visibility=0\n        ARFLAGS=\"rcs\"\n        SFLAGS=\"${CFLAGS}\"\n        shared_ext='.dll'\n        sharedlibdir='${bindir}'\n        if test $compat -eq 0; then\n          SHAREDLIB=cygz-ng$shared_ext\n        else\n          SHAREDLIB=cygz$shared_ext\n        fi\n        SHAREDLIBM=''\n        SHAREDLIBV=''\n        SHAREDTARGET=$SHAREDLIB\n        IMPORTLIB=\"${LIBNAME}.dll.a\"\n        LDSHARED=${LDSHARED-\"$cc\"}\n        LDSHAREDFLAGS=\"-shared -Wl,--out-implib,${IMPORTLIB}\"\n        LDSHAREDLIBC=\"\"\n        if test $gzfileops -eq 0; then\n          DEFFILE='win32/${LIBNAME2}.def'\n        fi\n        RC=\"${CROSS_PREFIX}windres\"\n        RCFLAGS=\"-I ${BUILDDIR}\"\n        RCOBJS='zlibrc.o'\n        STRIP=\"${CROSS_PREFIX}strip\"\n        EXE='.exe' ;;\n  MSYS* | msys*)\n        visibility=0\n        ARFLAGS=\"rcs\"\n        SFLAGS=\"${CFLAGS}\"\n        shared_ext='.dll'\n        sharedlibdir='${bindir}'\n        if test $compat -eq 0; then\n          SHAREDLIB=msys-z-ng$shared_ext\n        else\n          SHAREDLIB=msys-z$shared_ext\n        fi\n        SHAREDLIBM=''\n        SHAREDLIBV=''\n        SHAREDTARGET=$SHAREDLIB\n        IMPORTLIB=\"${LIBNAME}.dll.a\"\n        LDSHARED=${LDSHARED-\"$cc\"}\n        LDSHAREDFLAGS=\"-shared -Wl,--out-implib,${IMPORTLIB}\"\n        LDSHAREDLIBC=\"\"\n        if test $gzfileops -eq 0; then\n          DEFFILE='win32/${LIBNAME2}.def'\n        fi\n        RC=\"${CROSS_PREFIX}windres\"\n        RCFLAGS=\"-I ${BUILDDIR}\"\n        RCOBJS='zlibrc.o'\n        STRIP=\"${CROSS_PREFIX}strip\"\n        EXE='.exe' ;;\n  MINGW* | mingw*)\n        visibility=0\n        ARFLAGS=\"rcs\"\n        CFLAGS=\"${CFLAGS} -D_POSIX_C_SOURCE=200809L -D_GNU_SOURCE=1 -Wno-pedantic-ms-format\"\n        SFLAGS=\"${CFLAGS}\"\n        shared_ext='.dll'\n        sharedlibdir='${bindir}'\n        SHAREDLIB=${LIBNAME}-$VER1$shared_ext\n        SHAREDLIBM=''\n        SHAREDLIBV=''\n        SHAREDTARGET=$SHAREDLIB\n        IMPORTLIB=\"${LIBNAME}.dll.a\"\n        LDSHARED=${LDSHARED-\"$cc\"}\n        LDSHAREDFLAGS=\"-shared -Wl,--out-implib=${IMPORTLIB}\"\n        LDSHAREDLIBC=\"\"\n        if test $gzfileops -eq 0; then\n          DEFFILE='win32/${LIBNAME2}.def'\n        fi\n        RC=\"${CROSS_PREFIX}windres\"\n        RCFLAGS=\"-I ${BUILDDIR}\"\n        if [ \"$CC\" = \"mingw32-gcc\" ]; then\n          case $ARCH in\n          i386 | i486 | i586 | i686) RCFLAGS=\"${RCFLAGS} -F pe-i386\";;\n          esac;\n        fi\n        RCOBJS='zlibrc.o'\n        STRIP=\"${CROSS_PREFIX}strip\"\n        EXE='.exe' ;;\n  QNX*)  # This is for QNX6. I suppose that the QNX rule below is for QNX2,QNX4\n         # (alain.bonnefoy@icbt.com)\n                 LDSHARED=${LDSHARED-\"$cc\"}\n                 LDSHAREDFLAGS=\"-shared -Wl,-h${LIBNAME}.so.${VER1}\" ;;\n  HP-UX*)\n         LDSHARED=${LDSHARED-\"$cc\"}\n         LDSHAREDFLAGS=\"-shared\"\n         case $( (uname -m || echo unknown) 2>/dev/null) in\n         ia64)\n                 shared_ext='.so'\n                 SHAREDLIB='${LIBNAME}.so' ;;\n         *)\n                 shared_ext='.sl'\n                 SHAREDLIB='${LIBNAME}.sl' ;;\n         esac ;;\n  Darwin* | darwin*)\n             shared_ext='.dylib'\n             SHAREDLIB=${LIBNAME}$shared_ext\n             SHAREDLIBV=${LIBNAME}.$VER$shared_ext\n             SHAREDLIBM=${LIBNAME}.$VER1$shared_ext\n             SHAREDTARGET=$SHAREDLIBV\n             LDSHARED=${LDSHARED-\"$cc\"}\n             LDSHAREDFLAGS=\"-dynamiclib -install_name @rpath/${SHAREDLIBM} -compatibility_version ${VER1} -current_version ${VER3}\"\n             if \"${CROSS_PREFIX}libtool\" -V 2>&1 | grep Apple > /dev/null; then\n                 AR=\"${CROSS_PREFIX}libtool\"\n             elif libtool -V 2>&1 | grep Apple > /dev/null; then\n                 AR=\"libtool\"\n             else\n                 AR=\"/usr/bin/libtool\"\n             fi\n             ARFLAGS=\"-o\" ;;\n  aarch64)\n             LDSHARED=${LDSHARED-\"$cc\"}\n             LDSHAREDFLAGS=\"-shared -Wl,-soname,${LIBNAME}.so.${VER1}\"\n             LDSHAREDLIBC=\"-Wl,--start-group -lc -lrdimon -Wl,--end-group\" ;;\n  *)\n             LDSHARED=${LDSHARED-\"$cc\"}\n             LDSHAREDFLAGS=\"-shared\" ;;\n  esac\nelse\n  # find system name and corresponding cc options\n  CC=${CC-cc}\n  gcc=0\n  echo \"$CC\" | tee -a configure.log\n  if test -z \"$uname\"; then\n    uname=$( (uname -sr || echo unknown) 2>/dev/null)\n  fi\n  case \"$uname\" in\n  HP-UX*)    SFLAGS=${CFLAGS-\"-O +z\"}\n             CFLAGS=${CFLAGS-\"-O\"}\n             LDSHARED=${LDSHARED-\"ld\"}\n             LDSHAREDFLAGS=\"-b\"\n         case $( (uname -m || echo unknown) 2>/dev/null) in\n         ia64)\n             shared_ext='.so'\n             SHAREDLIB='${LIBNAME}.so' ;;\n         *)\n             shared_ext='.sl'\n             SHAREDLIB='${LIBNAME}.sl' ;;\n         esac ;;\n  AIX*)  # Courtesy of dbakker@arrayasolutions.com\n             SFLAGS=${CFLAGS-\"-O -qmaxmem=8192\"}\n             CFLAGS=${CFLAGS-\"-O -qmaxmem=8192\"}\n             LDSHARED=${LDSHARED-\"xlc\"}\n             LDSHAREDFLAGS=\"-G\" ;;\n  # send working options for other systems to zlib@gzip.org\n  *)         SFLAGS=${CFLAGS-\"-O\"}\n             CFLAGS=${CFLAGS-\"-O\"}\n             LDSHARED=${LDSHARED-\"cc\"}\n             LDSHAREDFLAGS=\"-shared\" ;;\n  esac\nfi\n\n# Symbol versioning\ncase \"$uname\" in\n  CYGWIN* | Cygwin* | cygwin* | MINGW* | mingw* | MSYS* | msys* | Darwin* | darwin*)\n    echo \"Checking for Symbol versioning... No.\"\n  ;;\n  *)\n    if test $shared -eq 1; then\n      echo \"Checking for Symbol versioning... Yes.\"\n      CFLAGS=\"${CFLAGS} -DHAVE_SYMVER\"\n      SFLAGS=\"${SFLAGS} -DHAVE_SYMVER\"\n    else\n      echo \"Checking for Symbol versioning... No.\"\n    fi\n  ;;\nesac\n\n# Simplify some later conditionals\ncase \"$uname\" in\nLinux* | linux*)\n  LINUX=1 ;;\n*)\n  LINUX=0 ;;\nesac\n\n# destination names for shared library if not defined above\nSHAREDLIB=${SHAREDLIB-\"${LIBNAME}$shared_ext\"}\nSHAREDLIBV=${SHAREDLIBV-\"${LIBNAME}$shared_ext.$VER\"}\nSHAREDLIBM=${SHAREDLIBM-\"${LIBNAME}$shared_ext.$VER1\"}\nSHAREDTARGET=${SHAREDTARGET-\"${LIBNAME}$shared_ext.$VER\"}\n\necho >> configure.log\n\n# define functions for testing compiler and library characteristics and logging the results\n\ncat > $test.c <<EOF\n#error error\nEOF\nif ($CC -c $CFLAGS $test.c) 2>/dev/null; then\n  try()\n  {\n    show \"$@\"\n    test \"$( (\"$@\") 2>&1 | tee -a configure.log)\" = \"\"\n  }\n  echo - using any output from compiler to indicate an error >> configure.log\nelse\n  try()\n  {\n    show \"$@\"\n    ( \"$@\" ) >> configure.log 2>&1\n    ret=$?\n    if test $ret -ne 0; then\n      echo \"(exit code $ret)\" >> configure.log\n    fi\n    return $ret\n  }\nfi\n\ncat > $test.c << EOF\nint foo() { return 0; }\nEOF\necho \"Checking for obsessive-compulsive compiler options...\" >> configure.log\nif try $CC -c $CFLAGS $test.c; then\n  :\nelse\n  echo \"Compiler error reporting is too harsh for $0 (perhaps remove -Werror).\" | tee -a configure.log\n  leave 1\nfi\n\necho >> configure.log\n\n# see if shared library build supported\ncat > $test.c <<EOF\nextern int getchar();\nint hello() {return getchar();}\nEOF\nif test $shared -eq 1; then\n  printf \"Checking for shared library support... \" | tee -a configure.log\n  # we must test in two steps (cc then ld), required at least on SunOS 4.x\n  if try $CC -c $SFLAGS $test.c &&\n     try $LDSHARED $LDSHAREDFLAGS $LDFLAGS -o $test$shared_ext $test.o $LDSHAREDLIBC; then\n    echo \"Building shared library $SHAREDTARGET with $CC.\" | tee -a configure.log\n  elif test -z \"$old_cc\" -a -z \"$old_cflags\"; then\n    echo \"No shared library support.\" | tee -a configure.log\n    shared=0;\n  else\n    echo 'No shared library support; try without defining CC and CFLAGS' | tee -a configure.log\n    shared=0;\n  fi\nfi\nif test $shared -eq 0; then\n  LDSHARED=\"$CC\"\n  LDSHAREDFLAGS=\"\"\n  ALL=\"static\"\n  SHAREDLIB=\"\"\n  SHAREDLIBV=\"\"\n  SHAREDLIBM=\"\"\n  SHAREDTARGET=\"\"\n  INSTALLTARGETS=install-static\n  UNINSTALLTARGETS=uninstall-static\n  echo Building static library $STATICLIB version $VER with $CC. | tee -a configure.log\nelse\n  ALL=\"static shared\"\n  TEST=\"${TEST} testshared\"\nfi\n\necho >> configure.log\n\n# check for version script support\ncat > $test.c <<EOF\nint foo(void) { return 0; }\nEOF\ncat > $test.map <<EOF\n{\n  global:\n    foo;\n  local:\n    *;\n};\nEOF\nif test $shared -eq 1; then\n  LDVERSIONSCRIPT=\"-Wl,--version-script,$SRCDIR/$MAPNAME\"\n  if try $CC -c $SFLAGS $test.c && try $LDSHARED $LDVERSIONSCRIPT $LDSHAREDFLAGS $LDFLAGS -o $test$shared_ext $test.o $LDSHAREDLIBC; then\n    echo \"Checking for version script support... $LDVERSIONSCRIPT.\" | tee -a configure.log\n  else\n    echo \"Checking for version script support... No.\" | tee -a configure.log\n    LDVERSIONSCRIPT=\"\"\n  fi\nfi\necho >> configure.log\n\n# check for large file support, and if none, check for fseeko()\ncat > $test.c <<EOF\n#include <sys/types.h>\noff64_t dummy = 0;\nEOF\nif try $CC -c $CFLAGS -D_LARGEFILE64_SOURCE=1 $test.c; then\n  CFLAGS=\"${CFLAGS} -D_LARGEFILE64_SOURCE=1\"\n  SFLAGS=\"${SFLAGS} -D_LARGEFILE64_SOURCE=1\"\n  echo \"Checking for off64_t... Yes.\" | tee -a configure.log\n  echo \"Checking for fseeko... Yes.\" | tee -a configure.log\nelse\n  echo \"Checking for off64_t... No.\" | tee -a configure.log\n  echo >> configure.log\n  cat > $test.c <<EOF\n#include <sys/types.h>\nint main() {\n  _off64_t dummy = 0;\n  return 0;\n}\nEOF\n  if try $CC $CFLAGS -o $test $test.c $LDSHAREDLIBC; then\n    echo \"Checking for _off64_t... Yes.\" | tee -a configure.log\n  else\n    echo \"Checking for _off64_t... No.\" | tee -a configure.log\n  fi\n  echo >> configure.log\n  cat > $test.c <<EOF\n#include <stdio.h>\nint main(void) {\n  fseeko(NULL, 0, 0);\n  return 0;\n}\nEOF\n  if try $CC $CFLAGS -o $test $test.c $LDSHAREDLIBC; then\n    echo \"Checking for fseeko... Yes.\" | tee -a configure.log\n  else\n    CFLAGS=\"${CFLAGS} -DNO_FSEEKO\"\n    SFLAGS=\"${SFLAGS} -DNO_FSEEKO\"\n    echo \"Checking for fseeko... No.\" | tee -a configure.log\n  fi\nfi\necho >> configure.log\n\ncat > $test.c <<EOF\n#define _POSIX_C_SOURCE 200112L\n#include <stdlib.h>\nint main(void) {\n  void *ptr = 0;\n  int ret = posix_memalign(&ptr, 64, 10);\n  if (ptr)\n    free(ptr);\n  return ret;\n}\nEOF\nif try $CC $CFLAGS -o $test $test.c $LDSHAREDLIBC; then\n  echo \"Checking for posix_memalign... Yes.\" | tee -a configure.log\n  CFLAGS=\"${CFLAGS} -DHAVE_POSIX_MEMALIGN\"\n  SFLAGS=\"${SFLAGS} -DHAVE_POSIX_MEMALIGN\"\nelse\n  echo \"Checking for posix_memalign... No.\" | tee -a configure.log\nfi\necho >> configure.log\n\ncat > $test.c <<EOF\n#define _ISOC11_SOURCE 1\n#include <stdlib.h>\nint main(void) {\n  void *ptr = aligned_alloc(64, 10);\n  if (ptr)\n    free(ptr);\n  return 0;\n}\nEOF\nif try $CC $CFLAGS -o $test $test.c $LDSHAREDLIBC; then\n  echo \"Checking for aligned_alloc... Yes.\" | tee -a configure.log\n  CFLAGS=\"${CFLAGS} -DHAVE_ALIGNED_ALLOC\"\n  SFLAGS=\"${SFLAGS} -DHAVE_ALIGNED_ALLOC\"\nelse\n  echo \"Checking for aligned_alloc... No.\" | tee -a configure.log\nfi\necho >> configure.log\n\n# check for strerror() for use by gz* functions\ncat > $test.c <<EOF\n#include <string.h>\n#include <errno.h>\nint main() { return strlen(strerror(errno)); }\nEOF\nif try $CC $CFLAGS -o $test $test.c $LDSHAREDLIBC; then\n  echo \"Checking for strerror... Yes.\" | tee -a configure.log\nelse\n  CFLAGS=\"${CFLAGS} -DNO_STRERROR\"\n  SFLAGS=\"${SFLAGS} -DNO_STRERROR\"\n  echo \"Checking for strerror... No.\" | tee -a configure.log\nfi\n\n# check for getauxval() or elf_aux_info() for architecture feature detection at run-time\ncat > $test.c <<EOF\n#include <sys/auxv.h>\nint main() {\n#ifdef __FreeBSD__\n  int test;\n  return elf_aux_info(AT_PAGESZ, &test, sizeof(test));\n#else\n  return getauxval(0);\n#endif\n}\nEOF\nif try $CC $CFLAGS -o $test $test.c $LDSHAREDLIBC; then\n  echo \"Checking for getauxval() or elf_aux_info() in sys/auxv.h... Yes.\" | tee -a configure.log\n  CFLAGS=\"${CFLAGS} -DHAVE_SYS_AUXV_H\"\n  SFLAGS=\"${SFLAGS} -DHAVE_SYS_AUXV_H\"\nelse\n  echo \"Checking for getauxval() in sys/auxv.h... No.\" | tee -a configure.log\nfi\n\n# We need to remove consigured files (zconf.h etc) from source directory if building outside of it\nif [ \"$SRCDIR\" != \"$BUILDDIR\" ]; then\n    rm -f $SRCDIR/zconf${SUFFIX}.h\n    rm -f $SRCDIR/zlib${SUFFIX}.h\n    rm -f $SRCDIR/zlib_name_mangling${SUFFIX}.h\nfi\n\n# Rename @ZLIB_SYMBOL_PREFIX@ to $symbol_prefix in gzread.c, zlib.h and zlib_name_mangling.h\nsed < $SRCDIR/gzread.c.in \"s/@ZLIB_SYMBOL_PREFIX@/$symbol_prefix/g\" > gzread.c\nsed < $SRCDIR/zlib${SUFFIX}.h.in \"s/@ZLIB_SYMBOL_PREFIX@/$symbol_prefix/g\" > zlib${SUFFIX}.h\nif [ ! -z \"$symbol_prefix\" ]; then\n  sed < $SRCDIR/zlib_name_mangling${SUFFIX}.h.in \"s/@ZLIB_SYMBOL_PREFIX@/$symbol_prefix/g\" > zlib_name_mangling${SUFFIX}.h\nelse\n  # symbol_prefix is not set, copy the empty mangling header\n  cp -p $SRCDIR/zlib_name_mangling.h.empty zlib_name_mangling${SUFFIX}.h\nfi\n\n# copy clean zconf.h for subsequent edits\ncp -p $SRCDIR/zconf${SUFFIX}.h.in zconf${SUFFIX}.h\n\necho >> configure.log\n\n# check for unistd.h and save result in zconf.h\ncat > $test.c <<EOF\n#include <unistd.h>\nint main() { return 0; }\nEOF\nif try $CC -c $CFLAGS $test.c; then\n  sed < zconf${SUFFIX}.h \"/^#ifdef HAVE_UNISTD_H.* may be/s/def HAVE_UNISTD_H\\(.*\\) may be/ 1\\1 was/\" > zconf${SUFFIX}.temp.h\n  mv zconf${SUFFIX}.temp.h zconf${SUFFIX}.h\n  echo \"Checking for unistd.h... Yes.\" | tee -a configure.log\nelse\n  sed < zconf${SUFFIX}.h \"/^#ifdef HAVE_UNISTD_H.* may be/s/def HAVE_UNISTD_H\\(.*\\) may be set to #if 1/ 0\\1 was set to #if 0/\" > zconf${SUFFIX}.temp.h\n  mv zconf${SUFFIX}.temp.h zconf${SUFFIX}.h\n  echo \"Checking for unistd.h... No.\" | tee -a configure.log\nfi\n\necho >> configure.log\n\n# check for ptrdiff_t and save result in zconf.h\nprintf \"Checking for ptrdiff_t... \" | tee -a configure.log\ncat > $test.c <<EOF\n#include <stddef.h>\nint fun(ptrdiff_t *a) { (void)a; return 0; }\nEOF\nif try $CC -c $CFLAGS $test.c; then\n  echo \"Yes.\" | tee -a configure.log\nelse\n    echo \"No.\" | tee -a configure.log\n    sed < zconf${SUFFIX}.h \"/^#ifdef NEED_PTRDIFF_T.* may be/s/def NEED_PTRDIFF_T\\(.*\\) may be/ 1\\1 was/\" > zconf${SUFFIX}.temp.h\n    mv zconf${SUFFIX}.temp.h zconf${SUFFIX}.h\n\n    printf \"Checking for sizeof(void *)... \" | tee -a configure.log\n    cat > $test.c <<EOF\n#include <stdint.h>\n#define COMPILE_TIME_ASSERT(pred) struct s { int x: (pred) ? 1 : -1; }\nCOMPILE_TIME_ASSERT(sizeof(int32_t) == sizeof(void *));\nEOF\n    if try $CC -c $CFLAGS $test.c; then\n        echo \"sizeof(int32_t).\" | tee -a configure.log\n        sed < zconf${SUFFIX}.h \"s/^typedef PTRDIFF_TYPE ptrdiff_t;/typedef int32_t ptrdiff_t;/g\" > zconf${SUFFIX}.temp.h\n        mv zconf${SUFFIX}.temp.h zconf${SUFFIX}.h\n    else\n        cat > $test.c <<EOF\n#include <stdint.h>\n#define COMPILE_TIME_ASSERT(pred) struct s { int x: (pred) ? 1 : -1; }\nCOMPILE_TIME_ASSERT(sizeof(int64_t) == sizeof(void *));\nEOF\n        if try $CC -c $CFLAGS $test.c; then\n            echo \"sizeof(int64_t).\" | tee -a configure.log\n            sed < zconf${SUFFIX}.h \"s/^typedef PTRDIFF_TYPE ptrdiff_t;/typedef int64_t ptrdiff_t;/g\" > zconf${SUFFIX}.temp.h\n            mv zconf${SUFFIX}.temp.h zconf${SUFFIX}.h\n        else\n            echo \"unknown.\" | tee -a configure.log\n            exit 1\n        fi\n    fi\nfi\n\n# if --zlib-compat was requested\nif test $compat -eq 1; then\n  gzfileops=1\n  CFLAGS=\"${CFLAGS} -DZLIB_COMPAT\"\n  SFLAGS=\"${SFLAGS} -DZLIB_COMPAT\"\n  case \"$uname\" in\n  CYGWIN* | Cygwin* | cygwin* | MSYS* | msys* | MINGW* | mingw*)\n    DEFFILE=\"win32/zlibcompat.def\" ;;\n  esac\nfi\n\nif [ ! -z \"$DEFFILE\" ]; then\n  mkdir -p win32\n  sed < $SRCDIR/$DEFFILE.in \"s/@ZLIB_SYMBOL_PREFIX@/$symbol_prefix/g\" > $DEFFILE\nfi\n\n# if --gzfileops was requested\nif test $gzfileops -eq 1; then\n  CFLAGS=\"${CFLAGS} -DWITH_GZFILEOP\"\n  SFLAGS=\"${SFLAGS} -DWITH_GZFILEOP\"\n  OBJC=\"${OBJC} \\$(OBJG)\"\n  PIC_OBJC=\"${PIC_OBJC} \\$(PIC_OBJG)\"\nelse\n  TESTOBJG=\"\\$(OBJG)\"\n  PIC_TESTOBJG=\"\\$(OBJG)\"\nfi\n\n# enable reduced memory configuration\nif test $reducedmem -eq 1; then\n  echo \"Configuring for reduced memory environment.\" | tee -a configure.log\n  CFLAGS=\"${CFLAGS} -DHASH_SIZE=32768u -DGZBUFSIZE=8192 -DNO_LIT_MEM\"\nfi\n\n# if code coverage testing was requested, use older gcc if defined, e.g. \"gcc-4.2\" on Mac OS X\nif test $cover -eq 1; then\n  CFLAGS=\"${CFLAGS} -fprofile-arcs -ftest-coverage\"\n  LDFLAGS=\"${LDFLAGS} -fprofile-arcs -ftest-coverage\"\n  if test -n \"$GCC_CLASSIC\"; then\n    CC=$GCC_CLASSIC\n  fi\nfi\n\necho >> configure.log\n\n# Check for ANSI C compliant compiler\ncat > $test.c <<EOF\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include \"zconf${SUFFIX}.h\"\nint main() {\n#ifdef STDC\n  return 0;\n#endif\n  return 1;\n}\nEOF\nif try $CC -c $CFLAGS $test.c; then\n  echo \"Checking for ANSI C compliant compiler...  Yes.\" | tee -a configure.log\n  :\nelse\n  echo \"Checking for ANSI C compliant compiler...  No.\" | tee -a configure.log\n  echo \"Error: ANSI C compatible compiler needed, cannot continue.\" | tee -a configure.log\n  leave 1\nfi\n\n# Check for -fno-semantic-interposition compiler support\necho \"\" > test.c\n  cat > $test.c <<EOF\nint main() { return 0; }\nEOF\nif test \"$gcc\" -eq 1 && ($cc $CFLAGS -fno-semantic-interposition -c $test.c) >> configure.log 2>&1; then\n  echo \"Checking for -fno-semantic-interposition... Yes.\" | tee -a configure.log\n  SFLAGS=\"$SFLAGS -fno-semantic-interposition\"\nelse\n  echo \"Checking for -fno-semantic-interposition... No.\" | tee -a configure.log\nfi\n\n# Check for -fno-lto compiler support\nif test $gcc -eq 1 -a $without_optimizations -eq 0; then\n  cat > $test.c <<EOF\nint main() { return 0; }\nEOF\n  if $cc $CFLAGS -fno-lto -c $test.c >> configure.log 2>&1; then\n    echo \"Checking for -fno-lto... Yes.\" | tee -a configure.log\n  else\n    echo \"Checking for -fno-lto... No.\" | tee -a configure.log\n    noltoflag=\"\"\n  fi\nfi\n\n# see if we can hide zlib internal symbols that are linked between separate source files using hidden\nif test \"$gcc\" -eq 1 && test \"$visibility\" -eq 1; then\n  echo >> configure.log\n  cat > $test.c <<EOF\n#define Z_INTERNAL __attribute__((visibility (\"hidden\")))\nint Z_INTERNAL foo;\nint main() { return 0; }\nEOF\n  if try $CC $CFLAGS $test.c; then\n    CFLAGS=\"$CFLAGS -DHAVE_VISIBILITY_HIDDEN\"\n    SFLAGS=\"$SFLAGS -DHAVE_VISIBILITY_HIDDEN\"\n    echo >> configure.log\n    echo \"Checking for attribute(visibility(hidden)) support... Yes.\" | tee -a configure.log\n  else\n    echo >> configure.log\n    echo \"Checking for attribute(visibility(hidden)) support... No.\" | tee -a configure.log\n  fi\nfi\n\n# see if we can hide zlib internal symbols that are linked between separate source files using internal\nif test \"$gcc\" -eq 1 && test \"$visibility\" -eq 1; then\n  echo >> configure.log\n  cat > $test.c <<EOF\n#define Z_INTERNAL __attribute__((visibility (\"internal\")))\nint Z_INTERNAL foo;\nint main() { return 0; }\nEOF\n  if try $CC $CFLAGS $test.c; then\n    CFLAGS=\"$CFLAGS -DHAVE_VISIBILITY_INTERNAL\"\n    SFLAGS=\"$SFLAGS -DHAVE_VISIBILITY_INTERNAL\"\n    echo >> configure.log\n    echo \"Checking for attribute(visibility(internal)) support... Yes.\" | tee -a configure.log\n  else\n    echo >> configure.log\n    echo \"Checking for attribute(visibility(internal)) support... No.\" | tee -a configure.log\n  fi\nfi\n\n# Check for attribute(aligned) support in compiler\ncat > $test.c << EOF\nint main(void) {\n  __attribute__((aligned(8))) int test = 0;\n  (void)test;\n  return 0;\n}\nEOF\nif try ${CC} ${CFLAGS} $test.c $LDSHAREDLIBC; then\n    echo \"Checking for attribute(aligned) ... Yes.\" | tee -a configure.log\n    CFLAGS=\"$CFLAGS -DHAVE_ATTRIBUTE_ALIGNED\"\n    SFLAGS=\"$SFLAGS -DHAVE_ATTRIBUTE_ALIGNED\"\nelse\n    echo \"Checking for attribute(aligned) ... No.\" | tee -a configure.log\nfi\n\n# Check for __builtin_assume_aligned(x,n) support in compiler\ncat > $test.c << EOF\nchar *test(char *buffer) {\n    char *abuffer = __builtin_assume_aligned(buffer,64);\n    return abuffer;\n}\nint main() {\n    return 0;\n}\nEOF\nif try ${CC} ${CFLAGS} $test.c $LDSHAREDLIBC; then\n    echo \"Checking for __builtin_assume_aligned() ... Yes.\" | tee -a configure.log\n    CFLAGS=\"$CFLAGS -DHAVE_BUILTIN_ASSUME_ALIGNED\"\n    SFLAGS=\"$SFLAGS -DHAVE_BUILTIN_ASSUME_ALIGNED\"\nelse\n    echo \"Checking for __builtin_assume_aligned() ... No.\" | tee -a configure.log\nfi\n\n# Check for __builtin_ctz() support in compiler\ncat > $test.c << EOF\nlong f(unsigned int x) { return __builtin_ctz(x); }\nint main(void) { return 0; }\nEOF\nif try ${CC} ${CFLAGS} $test.c $LDSHAREDLIBC; then\n    echo \"Checking for __builtin_ctz ... Yes.\" | tee -a configure.log\n    CFLAGS=\"$CFLAGS -DHAVE_BUILTIN_CTZ\"\n    SFLAGS=\"$SFLAGS -DHAVE_BUILTIN_CTZ\"\nelse\n    echo \"Checking for __builtin_ctz ... No.\" | tee -a configure.log\nfi\n\n# Check for __builtin_ctzll() support in compiler\ncat > $test.c << EOF\nlong f(unsigned long long x) { return __builtin_ctzll(x); }\nint main(void) { return 0; }\nEOF\nif try ${CC} ${CFLAGS} $test.c $LDSHAREDLIBC; then\n    echo \"Checking for __builtin_ctzll ... Yes.\" | tee -a configure.log\n    CFLAGS=\"$CFLAGS -DHAVE_BUILTIN_CTZLL\"\n    SFLAGS=\"$SFLAGS -DHAVE_BUILTIN_CTZLL\"\nelse\n    echo \"Checking for __builtin_ctzll ... No.\" | tee -a configure.log\nfi\n\ncheck_avx2_intrinsics() {\n    # Check whether compiler supports AVX2 intrinsics\n    cat > $test.c << EOF\n#include <immintrin.h>\n__m256i f(__m256i x) {\n    const __m256i y = _mm256_set1_epi16(1);\n    return _mm256_subs_epu16(x, y);\n}\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${avx2flag} $test.c; then\n        echo \"Checking for AVX2 intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_AVX2_INTRIN=1\n    else\n        echo \"Checking for AVX2 intrinsics ... No.\" | tee -a configure.log\n        HAVE_AVX2_INTRIN=0\n    fi\n}\n\ncheck_avx512_intrinsics() {\n    # Check whether compiler supports AVX512 intrinsics\n    cat > $test.c << EOF\n#include <immintrin.h>\n__m512i f(__m512i y) {\n  __m512i x = _mm512_set1_epi8(2);\n  return _mm512_sub_epi8(x, y);\n}\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${avx512flag} $test.c; then\n        echo \"Checking for AVX512 intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_AVX512_INTRIN=1\n    else\n        echo \"Checking for AVX512 intrinsics ... No.\" | tee -a configure.log\n        HAVE_AVX512_INTRIN=0\n    fi\n}\n\ncheck_mtune_skylake_avx512_compiler_flag() {\n    # Check whether -mtune=skylake-avx512 works correctly\n    cat > $test.c << EOF\nint main() { return 0; }\nEOF\n    if try $CC -c $CFLAGS -mtune=skylake-avx512 $test.c; then\n        MTUNE_SKYLAKE_AVX512_AVAILABLE=1\n        echo \"Check whether -mtune=skylake-avx512 works ... Yes.\" | tee -a configure.log\n    else\n        echo \"Check whether -mtune=skylake-avx512 works ... No.\" | tee -a configure.log\n        MTUNE_SKYLAKE_AVX512_AVAILABLE=0\n    fi\n}\n\ncheck_mtune_cascadelake_compiler_flag() {\n    # Check whether -mtune=cascadelake works correctly\n    cat > $test.c << EOF\nint main() { return 0; }\nEOF\n    if try $CC -c $CFLAGS -mtune=cascadelake $test.c; then\n        MTUNE_CASCADELAKE_AVAILABLE=1\n        echo \"Check whether -mtune=cascadelake works ... Yes.\" | tee -a configure.log\n    else\n        echo \"Check whether -mtune=cascadelake works ... No.\" | tee -a configure.log\n        MTUNE_CASCADELAKE_AVAILABLE=0\n        check_mtune_skylake_avx512_compiler_flag\n    fi\n}\n\ncheck_avx512vnni_intrinsics() {\n    # Check whether compiler supports AVX512-VNNI intrinsics\n    cat > $test.c << EOF\n#include <immintrin.h>\n__m512i f(__m512i x, __m512i y) {\n    __m512i z = _mm512_setzero_epi32();\n    return _mm512_dpbusd_epi32(z, x, y);\n}\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${avx512vnniflag} $test.c; then\n        echo \"Checking for AVX512VNNI intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_AVX512VNNI_INTRIN=1\n    else\n        echo \"Checking for AVX512VNNI intrinsics ... No.\" | tee -a configure.log\n        HAVE_AVX512VNNI_INTRIN=0\n    fi\n}\n\ncheck_acle_compiler_flag() {\n    # Check whether -march=armv8-a+crc works correctly\n    cat > $test.c << EOF\nint main() { return 0; }\nEOF\n    if try $CC -c $CFLAGS -march=armv8-a+crc $test.c; then\n        echo \"Check whether -march=armv8-a+crc works ... Yes.\" | tee -a configure.log\n        acleflag=\"-march=armv8-a+crc\"\n    else\n        echo \"Check whether -march=armv8-a+crc works ... No.\" | tee -a configure.log\n        if try $CC -c $CFLAGS -march=armv8-a+crc+simd $test.c; then\n            echo \"Check whether -march=armv8-a+crc+simd works ... Yes.\" | tee -a configure.log\n            acleflag=\"-march=armv8-a+crc+simd\"\n        else\n            echo \"Check whether -march=armv8-a+crc+simd works ... No.\" | tee -a configure.log\n        fi\n    fi\n\n    # Check whether compiler supports ARMv8 CRC intrinsics\n    cat > $test.c << EOF\n#include <arm_acle.h>\nunsigned int f(unsigned int a, unsigned int b) {\n    return __crc32w(a, b);\n}\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${acleflag} $test.c; then\n        echo \"Checking for ARMv8 CRC intrinsics ... Yes.\" | tee -a configure.log\n        ACLE_AVAILABLE=1\n    else\n        echo \"Checking for ARMv8 CRC intrinsics ... No.\" | tee -a configure.log\n        ACLE_AVAILABLE=0\n    fi\n}\n\ncheck_neon_compiler_flag() {\n    if test \"$ARCH\" = \"aarch64\"; then\n        neonflag=\"-march=armv8-a+simd\"\n    else\n        neonflag=\"-mfpu=neon\"\n    fi\n    # Check whether neon flag is available on ARM processors.\n    cat > $test.c << EOF\n#if defined(_M_ARM64) || defined(_M_ARM64EC)\n #  include <arm64_neon.h>\n #else\n #  include <arm_neon.h>\n#endif\nint main() { return 0; }\nEOF\n    if try $CC -c $CFLAGS $neonflag $test.c; then\n        NEON_AVAILABLE=1\n        echo \"Check whether $neonflag is available ... Yes.\" | tee -a configure.log\n    else\n        NEON_AVAILABLE=0\n        echo \"Check whether $neonflag is available ... No.\" | tee -a configure.log\n    fi\n}\n\ncheck_neon_ld4_intrinsics() {\n    cat > $test.c << EOF\n#if defined(_MSC_VER) && (defined(_M_ARM64) || defined(_M_ARM64EC))\n#  include <arm64_neon.h>\n#else\n#  include <arm_neon.h>\n#endif\nint32x4x4_t f(int var[16]) { return vld1q_s32_x4(var); }\nint main(void) { return 0; }\nEOF\n    if try $CC -c $CFLAGS $neonflag $test.c; then\n        NEON_HAS_LD4=1\n        echo \"check whether compiler supports 4 wide register loads ... Yes.\" | tee -a configure.log\n    else\n        NEON_HAS_LD4=0\n        echo \"check whether compiler supports 4 wide register loads ... No.\" | tee -a configure.log\n    fi\n}\n\ncheck_armv6_intrinsics() {\n    # Check whether -march=armv6 works correctly\n    cat > $test.c << EOF\nint main() { return 0; }\nEOF\n    if try $CC -c $CFLAGS -march=armv6 $test.c; then\n        armv6flag=-march=armv6\n        echo \"Check whether -march=armv6 works ... Yes.\" | tee -a configure.log\n    else\n        echo \"Check whether -march=armv6 works ... No.\" | tee -a configure.log\n    fi\n\n    # Check whether compiler supports ARMv6 inline asm\n    cat > $test.c << EOF\nunsigned int f(unsigned int a, unsigned int b) {\n    unsigned int c;\n    __asm__ __volatile__ ( \"uqsub16 %0, %1, %2\" : \"=r\" (c) : \"r\" (a), \"r\" (b) );\n    return c;\n}\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${armv6flag} $test.c; then\n        echo \"Checking for ARMv6 inline assembly ... Yes.\" | tee -a configure.log\n        HAVE_ARMV6_INLINE_ASM=1\n    else\n        echo \"Checking for ARMv6 inline assembly ... No.\" | tee -a configure.log\n        HAVE_ARMV6_INLINE_ASM=0\n    fi\n\n    # Check whether compiler supports ARMv6 intrinsics\n    cat > $test.c << EOF\n#include <arm_acle.h>\nunsigned int f(unsigned int a, unsigned int b) {\n    return __uqsub16(a, b);\n}\nint main(void) { return f(1, 2); }\nEOF\n    if try ${CC} ${CFLAGS} ${armv6flag} $test.c; then\n        echo \"Checking for ARMv6 intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_ARMV6_INTRIN=1\n    else\n        echo \"Checking for ARMv6 intrinsics ... No.\" | tee -a configure.log\n        HAVE_ARMV6_INTRIN=0\n    fi\n}\n\ncheck_pclmulqdq_intrinsics() {\n    # Check whether compiler supports PCLMULQDQ intrinsics\n    cat > $test.c << EOF\n#include <immintrin.h>\n#include <wmmintrin.h>\n__m128i f(__m128i a, __m128i b) { return _mm_clmulepi64_si128(a, b, 0x10); }\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${pclmulflag} $test.c; then\n        echo \"Checking for PCLMULQDQ intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_PCLMULQDQ_INTRIN=1\n    else\n        echo \"Checking for PCLMULQDQ intrinsics ... No.\" | tee -a configure.log\n        HAVE_PCLMULQDQ_INTRIN=0\n    fi\n}\n\ncheck_vpclmulqdq_intrinsics() {\n    # Check whether compiler supports VPCLMULQDQ intrinsics\n    cat > $test.c << EOF\n#include <immintrin.h>\n#include <wmmintrin.h>\n__m512i f(__m512i a) {\n    __m512i b = _mm512_setzero_si512();\n    return _mm512_clmulepi64_epi128(a, b, 0x10);\n}\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${vpclmulflag} $test.c; then\n        echo \"Checking for VPCLMULQDQ intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_VPCLMULQDQ_INTRIN=1\n    else\n        echo \"Checking for VPCLMULQDQ intrinsics ... No.\" | tee -a configure.log\n        HAVE_VPCLMULQDQ_INTRIN=0\n    fi\n}\n\ncheck_xsave_intrinsics() {\n   # Check whether compiler supports XSAVE intrinsics\n   cat > $test.c << EOF\n#ifdef _MSC_VER\n#  include <intrin.h>\n#elif __GNUC__ == 8 && __GNUC_MINOR__ > 1\n#  include <xsaveintrin.h>\n#else\n#  include <immintrin.h>\n#endif\nunsigned int f(unsigned int a) { return (int) _xgetbv(a); }\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${xsaveflag} $test.c; then\n        echo \"Checking for XSAVE intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_XSAVE_INTRIN=1\n    else\n        echo \"Checking for XSAVE intrinsics ... No.\" | tee -a configure.log\n        HAVE_XSAVE_INTRIN=0\n    fi\n}\n\ncheck_ppc_intrinsics() {\n        cat > $test.c << EOF\n#include <altivec.h>\nint main(void)\n{\n    vector int a = vec_splats(0);\n    vector int b = vec_splats(0);\n    a = vec_add(a, b);\n    return 0;\n}\nEOF\n        if test $buildaltivec -eq 1 && try ${CC} ${CFLAGS} -maltivec $test.c; then\n            echo \"Checking for AltiVec intrinsics ... Yes.\" | tee -a configure.log\n            HAVE_ALTIVEC_INTRIN=1\n        else\n            echo \"Checking for AltiVec intrinsics ... No.\" | tee -a configure.log\n            HAVE_ALTIVEC_INTRIN=0\n        fi\n        if test $buildaltivec -eq 1 && try ${CC} ${CFLAGS} -maltivec -mno-vsx $test.c; then\n            echo \"Checking if -mno-vsx is supported ... Yes.\" | tee -a configure.log\n            vmxflag=\"$vmxflag -mno-vsx\"\n        else\n            echo \"Checking if -mno-vsx is supported ... No.\" | tee -a configure.log\n        fi\n        cat > $test.c << EOF\n#ifdef __FreeBSD__\n#include <machine/cpu.h>\n#endif\n#include <sys/auxv.h>\nint main() {\n#ifdef __FreeBSD__\n  unsigned long hwcap;\n  elf_aux_info(AT_HWCAP, &hwcap, sizeof(hwcap));\n  return (hwcap & PPC_FEATURE_HAS_ALTIVEC);\n#else\n  return (getauxval(AT_HWCAP) & PPC_FEATURE_HAS_ALTIVEC);\n#endif\n}\nEOF\n        if try $CC -c $CFLAGS -maltivec $test.c; then\n            HAVE_VMX=1\n            echo \"Check whether VMX instructions are available ... Yes.\" | tee -a configure.log\n        else\n            HAVE_VMX=0\n            echo \"Check whether VMX instructions are available ... No.\" | tee -a configure.log\n        fi\n}\n\ncheck_power8_intrinsics() {\n    # Check whether features needed by POWER8 optimisations are available\n    cat > $test.c << EOF\n#ifdef __FreeBSD__\n#include <machine/cpu.h>\n#endif\n#include <sys/auxv.h>\nint main() {\n#ifdef __FreeBSD__\n  unsigned long hwcap;\n  elf_aux_info(AT_HWCAP2, &hwcap, sizeof(hwcap));\n  return (hwcap & PPC_FEATURE2_ARCH_2_07);\n#else\n  return (getauxval(AT_HWCAP2) & PPC_FEATURE2_ARCH_2_07);\n#endif\n}\nEOF\n    if test $buildpower8 -eq 1 && try $CC -c $CFLAGS -mcpu=power8 $test.c; then\n        HAVE_POWER8_INTRIN=1\n        echo \"Check whether POWER8 instructions are available ... Yes.\" | tee -a configure.log\n    else\n        HAVE_POWER8_INTRIN=0\n        echo \"Check whether POWER8 instructions are available ... No.\" | tee -a configure.log\n    fi\n}\n\ncheck_power9_intrinsics() {\n    # Check whether features needed by POWER9 optimisations are available\n    cat > $test.c << EOF\n#ifdef __FreeBSD__\n#include <machine/cpu.h>\n#endif\n#include <sys/auxv.h>\nint main() {\n#ifdef __FreeBSD__\n  unsigned long hwcap;\n  elf_aux_info(AT_HWCAP2, &hwcap, sizeof(hwcap));\n  return (hwcap & PPC_FEATURE2_ARCH_3_00);\n#else\n  return (getauxval(AT_HWCAP2) & PPC_FEATURE2_ARCH_3_00);\n#endif\n}\nEOF\n    if test $buildpower9 -eq 1 && try $CC -c $CFLAGS -mcpu=power9 $test.c; then\n        HAVE_POWER9_INTRIN=1\n        echo \"Check whether POWER9 instructions are available ... Yes.\" | tee -a configure.log\n    else\n        HAVE_POWER9_INTRIN=0\n        echo \"Check whether POWER9 instructions are available ... No.\" | tee -a configure.log\n    fi\n}\n\ncheck_sse2_intrinsics() {\n    # Check whether compiler supports SSE2 intrinsics\n    cat > $test.c << EOF\n#include <immintrin.h>\n__m128i f(__m128i x, __m128i y) { return _mm_sad_epu8(x, y); }\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${sse2flag} $test.c; then\n        echo \"Checking for SSE2 intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_SSE2_INTRIN=1\n    else\n        echo \"Checking for SSE2 intrinsics ... No.\" | tee -a configure.log\n        HAVE_SSE2_INTRIN=0\n    fi\n}\n\ncheck_sse42_intrinsics() {\n    # Check whether compiler supports SSE4.2 intrinsics\n    cat > $test.c << EOF\n#include <nmmintrin.h>\nunsigned int f(unsigned int a, unsigned int b) { return _mm_crc32_u32(a, b); }\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${sse42flag} $test.c; then\n        echo \"Checking for SSE4.2 intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_SSE42_INTRIN=1\n    else\n        echo \"Checking for SSE4.2 intrinsics ... No.\" | tee -a configure.log\n        HAVE_SSE42_INTRIN=0\n    fi\n}\n\ncheck_ssse3_intrinsics() {\n    # Check whether compiler supports SSSE3 intrinsics\n    cat > $test.c << EOF\n#include <immintrin.h>\n__m128i f(__m128i u) {\n  __m128i v = _mm_set1_epi32(1);\n  return _mm_hadd_epi32(u, v);\n}\nint main(void) { return 0; }\nEOF\n    if try ${CC} ${CFLAGS} ${ssse3flag} $test.c; then\n        echo \"Checking for SSSE3 intrinsics ... Yes.\" | tee -a configure.log\n        HAVE_SSSE3_INTRIN=1\n    else\n        echo \"Checking for SSSE3 intrinsics ... No.\" | tee -a configure.log\n        HAVE_SSSE3_INTRIN=0\n    fi\n}\n\ncheck_vgfma_intrinsics() {\n    # Check whether \"VECTOR GALOIS FIELD MULTIPLY SUM AND ACCUMULATE\" intrinsic is available\n    printf \"Checking for -mzarch... \" | tee -a configure.log\n    if try $CC -x c -c /dev/null -o /dev/null -mzarch; then\n        echo Yes. | tee -a configure.log\n        vgfmaflag=\"${vgfmaflag} -mzarch\"\n    else\n        echo No. | tee -a configure.log\n    fi\n    printf \"Checking for -fzvector... \" | tee -a configure.log\n    if try $CC -x c -c /dev/null -o /dev/null -fzvector; then\n        echo Yes. | tee -a configure.log\n        vgfmaflag=\"${vgfmaflag} -fzvector\"\n    else\n        echo No. | tee -a configure.log\n    fi\n    cat > $test.c << EOF\n#include <vecintrin.h>\nint main(void) {\n    unsigned long long a __attribute__((vector_size(16))) = { 0 };\n    unsigned long long b __attribute__((vector_size(16))) = { 0 };\n    unsigned char c __attribute__((vector_size(16))) = { 0 };\n    c = vec_gfmsum_accum_128(a, b, c);\n    return c[0];\n}\nEOF\n    printf \"Checking for VGFMA support... \" | tee -a configure.log\n    if try $CC -c $CFLAGS $vgfmaflag $test.c; then\n        HAVE_VGFMA_INTRIN=1\n        echo \"Yes.\" | tee -a configure.log\n    else\n        HAVE_VGFMA_INTRIN=0\n        echo \"No.\" | tee -a configure.log\n    fi\n}\n\n# Check whether to disable deflate_medium and deflate_quick\nif test $without_new_strategies -eq 1; then\n    CFLAGS=\"${CFLAGS} -DNO_QUICK_STRATEGY -DNO_MEDIUM_STRATEGY\"\n    SFLAGS=\"${SFLAGS} -DNO_QUICK_STRATEGY -DNO_MEDIUM_STRATEGY\"\nfi\n\nARCHDIR='arch/generic'\nARCH_STATIC_OBJS=''\nARCH_SHARED_OBJS=''\n\n# Set ARCH specific FLAGS\ncase \"${ARCH}\" in\n    # x86/amd64 specific optimizations\n    i386 | i486 | i586 | i686 |x86_64)\n        ARCHDIR=arch/x86\n\n        # Enable arch-specific optimizations\n        if test $without_optimizations -eq 0; then\n            CFLAGS=\"${CFLAGS} -DX86_FEATURES\"\n            SFLAGS=\"${SFLAGS} -DX86_FEATURES\"\n\n            ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} x86_features.o\"\n            ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} x86_features.lo\"\n\n            check_xsave_intrinsics\n\n            if test ${HAVE_XSAVE_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_HAVE_XSAVE_INTRIN\"\n                SFLAGS=\"${SFLAGS} -DX86_HAVE_XSAVE_INTRIN\"\n            else\n                xsaveflag=\"\"\n            fi\n\n            check_sse2_intrinsics\n\n            if test ${HAVE_SSE2_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_SSE2\"\n                SFLAGS=\"${SFLAGS} -DX86_SSE2\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} chunkset_sse2.o compare256_sse2.o slide_hash_sse2.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} chunkset_sse2.lo compare256_sse2.lo slide_hash_sse2.lo\"\n\n                if test $forcesse2 -eq 1; then\n                    CFLAGS=\"${CFLAGS} -DX86_NOCHECK_SSE2\"\n                    SFLAGS=\"${SFLAGS} -DX86_NOCHECK_SSE2\"\n                fi\n            fi\n\n            check_ssse3_intrinsics\n\n            if test ${HAVE_SSSE3_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_SSSE3\"\n                SFLAGS=\"${SFLAGS} -DX86_SSSE3\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} adler32_ssse3.o chunkset_ssse3.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} adler32_ssse3.lo chunkset_ssse3.lo\"\n            fi\n\n            check_sse42_intrinsics\n\n            if test ${HAVE_SSE42_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_SSE42\"\n                SFLAGS=\"${SFLAGS} -DX86_SSE42\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} adler32_sse42.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} adler32_sse42.lo\"\n            fi\n\n            check_pclmulqdq_intrinsics\n\n            if test ${HAVE_PCLMULQDQ_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_PCLMULQDQ_CRC\"\n                SFLAGS=\"${SFLAGS} -DX86_PCLMULQDQ_CRC\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} crc32_pclmulqdq.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} crc32_pclmulqdq.lo\"\n            fi\n\n            check_avx2_intrinsics\n\n            if test ${HAVE_AVX2_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_AVX2\"\n                SFLAGS=\"${SFLAGS} -DX86_AVX2\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} slide_hash_avx2.o chunkset_avx2.o compare256_avx2.o adler32_avx2.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} slide_hash_avx2.lo chunkset_avx2.lo compare256_avx2.lo adler32_avx2.lo\"\n            fi\n\n            check_avx512_intrinsics\n\n            if test ${HAVE_AVX512_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_AVX512\"\n                SFLAGS=\"${SFLAGS} -DX86_AVX512\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} adler32_avx512.o chunkset_avx512.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} adler32_avx512.lo chunkset_avx512.lo\"\n            fi\n\n            check_mtune_cascadelake_compiler_flag\n\n            if test ${MTUNE_CASCADELAKE_AVAILABLE} -eq 1; then\n                avx512flag=\"${avx512flag} -mtune=cascadelake\"\n                avx512vnniflag=\"${avx512vnniflag} -mtune=cascadelake\"\n            else\n                if test ${MTUNE_SKYLAKE_AVX512_AVAILABLE} -eq 1; then\n                    avx512flag=\"${avx512flag} -mtune=skylake-avx512\"\n                    avx512vnniflag=\"${avx512vnniflag} -mtune=skylake-avx512\"\n                fi\n            fi\n\n            check_avx512vnni_intrinsics\n\n            if test ${HAVE_AVX512VNNI_INTRIN} -eq 1; then\n                CFLAGS=\"${CFLAGS} -DX86_AVX512VNNI\"\n                SFLAGS=\"${SFLAGS} -DX86_AVX512VNNI\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} adler32_avx512_vnni.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} adler32_avx512_vnni.lo\"\n            fi\n\n            if test $buildvpclmulqdq -eq 1 && test ${HAVE_PCLMULQDQ_INTRIN} -eq 1 && test ${HAVE_AVX512_INTRIN} -eq 1; then\n                check_vpclmulqdq_intrinsics\n\n                if test ${HAVE_VPCLMULQDQ_INTRIN} -eq 1; then\n                    CFLAGS=\"${CFLAGS} -DX86_VPCLMULQDQ_CRC\"\n                    SFLAGS=\"${SFLAGS} -DX86_VPCLMULQDQ_CRC\"\n                    ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} crc32_vpclmulqdq.o\"\n                    ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} crc32_vpclmulqdq.lo\"\n                fi\n            fi\n        fi\n    ;;\n\n    # ARM specific optimizations\n    arm* | aarch64)\n        case \"${ARCH}\" in\n            arm*)\n                [ ! -z $CROSS_PREFIX ] && QEMU_ARCH=arm\n            ;;\n            aarch64)\n                [ ! -z $CROSS_PREFIX ] && QEMU_ARCH=aarch64\n                buildarmv6=0\n            ;;\n        esac\n\n        ARCHDIR=arch/arm\n\n        cat > $test.c << EOF\nint main() { return 0; }\nEOF\n        if try $CC -c $SFLAGS $test.c -mfloat-abi=softfp &&\n           try $LDSHARED $LDSHAREDFLAGS $LDFLAGS -o $test$shared_ext $test.o $LDSHAREDLIBC; then\n            floatabi=\"-mfloat-abi=softfp\"\n        else\n            if try $CC -c $SFLAGS $test.c -mfloat-abi=hard &&\n               try $LDSHARED $LDSHAREDFLAGS $LDFLAGS -o $test$shared_ext $test.o $LDSHAREDLIBC; then\n                floatabi=\"-mfloat-abi=hard\"\n            fi\n        fi\n\n        if [ -z $floatabi ]; then\n            echo \"ARM floating point arch not auto-detected\" | tee -a configure.log\n        else\n            echo \"ARM floating point arch: ${floatabi}\" | tee -a configure.log\n\n            CFLAGS=\"${CFLAGS} ${floatabi}\"\n            SFLAGS=\"${SFLAGS} ${floatabi}\"\n        fi\n\n        if test $without_optimizations -eq 0; then\n            CFLAGS=\"${CFLAGS} -DARM_FEATURES\"\n            SFLAGS=\"${SFLAGS} -DARM_FEATURES\"\n            ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} arm_features.o\"\n            ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} arm_features.lo\"\n\n            cat > $test.c <<EOF\n#include <arm_acle.h>\nEOF\n            if try $CC -c $CFLAGS $test.c; then\n                echo \"Checking for arm_acle.h... Yes.\" | tee -a configure.log\n                CFLAGS=\"${CFLAGS} -DHAVE_ARM_ACLE_H\"\n                SFLAGS=\"${SFLAGS} -DHAVE_ARM_ACLE_H\"\n            else\n                echo \"Checking for arm_acle.h... No.\" | tee -a configure.log\n            fi\n\n\n            if test $LINUX -eq 1; then\n                if test \"$ARCH\" = \"aarch64\"; then\n                    cat > $test.c <<EOF\n#include <sys/auxv.h>\nint main() {\n    return (getauxval(AT_HWCAP) & HWCAP_CRC32);\n}\nEOF\n                    if try $CC -c $CFLAGS $test.c; then\n                        CFLAGS=\"${CFLAGS} -DARM_AUXV_HAS_CRC32\"\n                        SFLAGS=\"${SFLAGS} -DARM_AUXV_HAS_CRC32\"\n                    else\n                        echo \"HWCAP_CRC32 not present in sys/auxv.h; cannot detect support at runtime.\" | tee -a configure.log\n                    fi\n                else\n                    cat > $test.c <<EOF\n#include <sys/auxv.h>\nint main() {\n    return (getauxval(AT_HWCAP2) & HWCAP2_CRC32);\n}\nEOF\n                    if try $CC -c $CFLAGS $test.c; then\n                        CFLAGS=\"${CFLAGS} -DARM_AUXV_HAS_CRC32\"\n                        SFLAGS=\"${SFLAGS} -DARM_AUXV_HAS_CRC32\"\n                    else\n                        cat > $test.c <<EOF\n#include <sys/auxv.h>\n#include <asm/hwcap.h>\nint main() {\n    return (getauxval(AT_HWCAP2) & HWCAP2_CRC32);\n}\nEOF\n                        if try $CC -c $CFLAGS $test.c; then\n                            CFLAGS=\"${CFLAGS} -DARM_AUXV_HAS_CRC32 -DARM_ASM_HWCAP\"\n                            SFLAGS=\"${SFLAGS} -DARM_AUXV_HAS_CRC32 -DARM_ASM_HWCAP\"\n                        else\n                            echo \"HWCAP2_CRC32 not present in sys/auxv.h; cannot detect support at runtime.\" | tee -a configure.log\n                        fi\n                    fi\n\n                    cat > $test.c <<EOF\n#include <sys/auxv.h>\nint main() {\n    return (getauxval(AT_HWCAP) & HWCAP_ARM_NEON);\n}\nEOF\n                    if try $CC -c $CFLAGS $test.c; then\n                        CFLAGS=\"${CFLAGS} -DARM_AUXV_HAS_NEON\"\n                        SFLAGS=\"${SFLAGS} -DARM_AUXV_HAS_NEON\"\n                    else\n                        cat > $test.c <<EOF\n#include <sys/auxv.h>\nint main() {\n    return (getauxval(AT_HWCAP) & HWCAP_NEON);\n}\nEOF\n                        if try $CC -c $CFLAGS $test.c; then\n                            CFLAGS=\"${CFLAGS} -DARM_AUXV_HAS_NEON\"\n                            SFLAGS=\"${SFLAGS} -DARM_AUXV_HAS_NEON\"\n                        else\n                            echo \"Neither HWCAP_ARM_NEON or HWCAP_NEON present in sys/auxv.h; cannot detect support at runtime.\" | tee -a configure.log\n                        fi\n                    fi\n                fi\n            fi\n\n            if test $buildacle -eq 1; then\n                check_acle_compiler_flag\n\n                if test $ACLE_AVAILABLE -eq 1; then\n                    CFLAGS=\"${CFLAGS} -DARM_ACLE\"\n                    SFLAGS=\"${SFLAGS} -DARM_ACLE\"\n\n                    ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} crc32_acle.o\"\n                    ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} crc32_acle.lo\"\n                fi\n            fi\n\n            if test $buildneon -eq 1; then\n                check_neon_compiler_flag\n\n                if test $NEON_AVAILABLE -eq 1; then\n                    CFLAGS=\"${CFLAGS} -DARM_NEON\"\n                    SFLAGS=\"${SFLAGS} -DARM_NEON\"\n\n                    check_neon_ld4_intrinsics\n\n                    if test $NEON_HAS_LD4 -eq 1; then\n                        CFLAGS=\"${CFLAGS} -DARM_NEON_HASLD4\"\n                        SFLAGS=\"${SFLAGS} -DARM_NEON_HASLD4\"\n                    fi\n\n                    ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} adler32_neon.o chunkset_neon.o compare256_neon.o slide_hash_neon.o\"\n                    ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} adler32_neon.lo chunkset_neon.lo compare256_neon.lo slide_hash_neon.lo\"\n                fi\n            fi\n\n            if test $buildarmv6 -eq 1; then\n                check_armv6_intrinsics\n\n                if test $HAVE_ARMV6_INTRIN -eq 1 || test $HAVE_ARMV6_INLINE_ASM -eq 1; then\n                    CFLAGS=\"${CFLAGS} -DARM_SIMD\"\n                    SFLAGS=\"${SFLAGS} -DARM_SIMD\"\n\n                    if test $HAVE_ARMV6_INTRIN -eq 1; then\n                        CFLAGS=\"${CFLAGS} -DARM_SIMD_INTRIN\"\n                        SFLAGS=\"${SFLAGS} -DARM_SIMD_INTRIN\"\n                    fi\n\n                    ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} slide_hash_armv6.o\"\n                    ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} slide_hash_armv6.lo\"\n                fi\n            fi\n\n        fi\n    ;;\n    powerpc*)\n        case \"${ARCH}\" in\n            powerpc)\n                [ ! -z $CROSS_PREFIX ] && QEMU_ARCH=ppc\n            ;;\n            powerpc64)\n                [ ! -z $CROSS_PREFIX ] && QEMU_ARCH=ppc64\n            ;;\n            powerpc64le)\n                [ ! -z $CROSS_PREFIX ] && QEMU_ARCH=ppc64le\n            ;;\n        esac\n\n        ARCHDIR=arch/power\n\n        if test $without_optimizations -eq 0; then\n\n            check_ppc_intrinsics\n            check_power8_intrinsics\n            check_power9_intrinsics\n\n            if test $HAVE_VMX -eq 1; then\n                CFLAGS=\"${CFLAGS} -DPPC_FEATURES\"\n                SFLAGS=\"${SFLAGS} -DPPC_FEATURES\"\n            fi\n            if test $HAVE_VMX -eq 1 -o $HAVE_POWER8_INTRIN -eq 1; then\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} power_features.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} power_features.lo\"\n            fi\n            if test $HAVE_VMX -eq 1 -a $HAVE_ALTIVEC_INTRIN -eq 1; then\n                CFLAGS=\"${CFLAGS} -DPPC_VMX\"\n                SFLAGS=\"${SFLAGS} -DPPC_VMX\"\n\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} adler32_vmx.o slide_hash_vmx.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} adler32_vmx.lo slide_hash_vmx.lo\"\n            fi\n            if test $HAVE_POWER8_INTRIN -eq 1; then\n                CFLAGS=\"${CFLAGS} -DPOWER8_VSX -DPOWER_FEATURES\"\n                SFLAGS=\"${SFLAGS} -DPOWER8_VSX -DPOWER_FEATURES\"\n\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} adler32_power8.o chunkset_power8.o slide_hash_power8.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} adler32_power8.lo chunkset_power8.lo slide_hash_power8.lo\"\n                case \"${ARCH}\" in\n                    powerpc64*)\n                        ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} crc32_power8.o\"\n                        ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} crc32_power8.lo\"\n                        CFLAGS=\"${CFLAGS} -DPOWER8_VSX_CRC32\"\n                        SFLAGS=\"${SFLAGS} -DPOWER8_VSX_CRC32\"\n                        ;;\n                esac\n            fi\n            if test $HAVE_POWER9_INTRIN -eq 1; then\n                CFLAGS=\"${CFLAGS} -DPOWER9 -DPOWER_FEATURES\"\n                SFLAGS=\"${SFLAGS} -DPOWER9 -DPOWER_FEATURES\"\n\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} compare256_power9.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} compare256_power9.lo\"\n            fi\n        fi\n    ;;\n    s390x)\n        [ ! -z $CROSS_PREFIX ] && QEMU_ARCH=s390x\n        ARCHDIR=arch/s390\n\n        if test $without_optimizations -eq 0; then\n            if test $buildcrc32vx -eq 1; then\n                CFLAGS=\"${CFLAGS} -DS390_FEATURES\"\n                SFLAGS=\"${SFLAGS} -DS390_FEATURES\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} s390_features.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} s390_features.lo\"\n            fi\n\n            if test $builddfltccdeflate -eq 1; then\n                CFLAGS=\"${CFLAGS} -DS390_DFLTCC_DEFLATE\"\n                SFLAGS=\"${SFLAGS} -DS390_DFLTCC_DEFLATE\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} dfltcc_deflate.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} dfltcc_deflate.lo\"\n                ARCH=\"${ARCH}+dfltcc-deflate\"\n            fi\n\n            if test $builddfltccinflate -eq 1; then\n                CFLAGS=\"${CFLAGS} -DS390_DFLTCC_INFLATE\"\n                SFLAGS=\"${SFLAGS} -DS390_DFLTCC_INFLATE\"\n                ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} dfltcc_inflate.o\"\n                ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} dfltcc_inflate.lo\"\n                ARCH=\"${ARCH}+dfltcc-inflate\"\n            fi\n\n            if test $buildcrc32vx -eq 1; then\n                check_vgfma_intrinsics\n                if test $HAVE_VGFMA_INTRIN -eq 1; then\n                    CFLAGS=\"${CFLAGS} -DS390_CRC32_VX\"\n                    SFLAGS=\"${SFLAGS} -DS390_CRC32_VX\"\n                    ARCH_STATIC_OBJS=\"${ARCH_STATIC_OBJS} crc32-vx.o\"\n                    ARCH_SHARED_OBJS=\"${ARCH_SHARED_OBJS} crc32-vx.lo\"\n                    ARCH=\"${ARCH}+crc32-vx\"\n                fi\n            fi\n        fi\n    ;;\n    *)\n        [ ! -z $CROSS_PREFIX ] && QEMU_ARCH=$ARCH\n    ;;\nesac\n\necho \"Uname: $uname\"\necho \"ARCH: ${ARCH}\"\necho \"Using arch directory: ${ARCHDIR}\"\necho \"Architecture-specific static object files:${ARCH_STATIC_OBJS}\"\necho \"Architecture-specific shared object files:${ARCH_SHARED_OBJS}\"\n\n# show the results in the log\necho >> configure.log\necho ALL = $ALL >> configure.log\necho AR = $AR >> configure.log\necho ARFLAGS = $ARFLAGS >> configure.log\necho CC = $CC >> configure.log\necho CFLAGS = $CFLAGS >> configure.log\necho EXE = $EXE >> configure.log\necho LDCONFIG = $LDCONFIG >> configure.log\necho LDFLAGS = $LDFLAGS >> configure.log\necho LDSHARED = $LDSHARED >> configure.log\necho LDSHAREDFLAGS = $LDSHAREDFLAGS >> configure.log\necho LDSHAREDLIBC = $LDSHAREDLIBC >> configure.log\necho DEFFILE = $DEFFILE >> configure.log\necho RC = $RC >> configure.log\necho RCFLAGS = $RCFLAGS >> configure.log\necho RCOBJS = $RCOBJS >> configure.log\necho STRIP = $STRIP >> configure.log\necho OBJC = $OBJC >> configure.log\necho TESTOBJG = $TESTOBJG >> configure.log\necho PIC_TESTOBJG = $PIC_TESTOBJG >> configure.log\necho PIC_OBJC = $PIC_OBJC >> configure.log\necho RANLIB = $RANLIB >> configure.log\necho SFLAGS = $SFLAGS >> configure.log\necho SHAREDLIB = $SHAREDLIB >> configure.log\necho SHAREDLIBM = $SHAREDLIBM >> configure.log\necho SHAREDLIBV = $SHAREDLIBV >> configure.log\necho SHAREDTARGET = $SHAREDTARGET >> configure.log\necho IMPORTLIB = $IMPORTLIB >> configure.log\necho INSTALLTARGETS = $INSTALLTARGETS >> configure.log\necho UNINSTALLTARGETS = $UNINSTALLTARGETS >> configure.log\necho SRCDIR = $SRCDIR >> configure.log\necho BUILDDIR = $BUILDDIR >> configure.log\necho STATICLIB = $STATICLIB >> configure.log\necho TEST = $TEST >> configure.log\necho VER = $VER >> configure.log\necho exec_prefix = $exec_prefix >> configure.log\necho includedir = $includedir >> configure.log\necho bindir = $bindir >> configure.log\necho libdir = $libdir >> configure.log\necho mandir = $mandir >> configure.log\necho prefix = $prefix >> configure.log\necho symbol_prefix = $symbol_prefix >> configure.log\necho sharedlibdir = $sharedlibdir >> configure.log\necho uname = $uname >> configure.log\necho sse2flag = $sse2flag >> configure.log\necho ssse3flag = $ssse3flag >> configure.log\necho sse42flag = $sse42flag >> configure.log\necho pclmulflag = $pclmulflag >> configure.log\necho vpclmulflag = $vpclmulflag >> configure.log\necho xsaveflag = $xsaveflag >> configure.log\necho acleflag = $acleflag >> configure.log\necho neonflag = $neonflag >> configure.log\necho armv6flag = $armv6flag >> configure.log\necho ARCHDIR = ${ARCHDIR} >> configure.log\necho ARCH_STATIC_OBJS = ${ARCH_STATIC_OBJS} >> configure.log\necho ARCH_SHARED_OBJS = ${ARCH_SHARED_OBJS} >> configure.log\n\n# Handle sed incompatibilities when using -i\nreplace_in_file() {\n  if [ \"$OS\" = 'Darwin' ]; then\n    sed -i '.tmp' -e \"$1\" \"$2\"\n  else\n    sed -i'.tmp' -e \"$1\" \"$2\"\n  fi\n}\n\n# update Makefile with the configure results\n\nINCLUDES=\"-I$SRCDIR -I$SRCDIR/$ARCHDIR -I$SRCDIR/arch/generic\"\nif [ \"$SRCDIR\" != \"$BUILDDIR\" ]; then INCLUDES=\"-I$BUILDDIR ${INCLUDES}\"; fi\n\nsed < $SRCDIR/Makefile.in \"\n/^CC *=/s#=.*#=$CC#\n/^CFLAGS *=/s#=.*#=$CFLAGS#\n/^SFLAGS *=/s#=.*#=$SFLAGS#\n/^LDFLAGS *=/s#=.*#=$LDFLAGS#\n/^LDSHARED *=/s#=.*#=$LDSHARED#\n/^LDSHAREDFLAGS *=/s#=.*#=$LDSHAREDFLAGS#\n/^LDVERSIONSCRIPT *=/s#=.*#=$LDVERSIONSCRIPT#\n/^LIBNAME1 *=/s#=.*#=$LIBNAME#\n/^LIBNAME2 *=/s#=.*#=$LIBNAME2#\n/^SUFFIX *=/s#=.*#=$SUFFIX#\n/^STATICLIB *=/s#=.*#=$STATICLIB#\n/^SHAREDLIB *=/s#=.*#=$SHAREDLIB#\n/^SHAREDLIBV *=/s#=.*#=$SHAREDLIBV#\n/^SHAREDLIBM *=/s#=.*#=$SHAREDLIBM#\n/^SHAREDTARGET *=/s#=.*#=$SHAREDTARGET#\n/^IMPORTLIB *=/s#=.*#=$IMPORTLIB#\n/^VER *=/s#=.*#=$VER#\n/^VER1 *=/s#=.*#=$VER1#\n/^AR *=/s#=.*#=$AR#\n/^ARFLAGS *=/s#=.*#=$ARFLAGS#\n/^RANLIB *=/s#=.*#=$RANLIB#\n/^LDCONFIG *=/s#=.*#=$LDCONFIG#\n/^LDSHAREDLIBC *=/s#=.*#=$LDSHAREDLIBC#\n/^DEFFILE *=/s#=.*#=$DEFFILE#\n/^RC *=/s#=.*#=$RC#\n/^RCFLAGS *=/s#=.*#=$RCFLAGS#\n/^RCOBJS *=/s#=.*#=$RCOBJS#\n/^STRIP *=/s#=.*#=$STRIP#\n/^EXE *=/s#=.*#=$EXE#\n/^prefix *=/s#=.*#= $prefix#\n/^exec_prefix *=/s#=.*#= $exec_prefix#\n/^bindir *=/s#=.*#= $bindir#\n/^symbol_prefix *=/s#=.*#= $symbol_prefix#\n/^libdir *=/s#=.*#= $libdir#\n/^sharedlibdir *=/s#=.*#= $sharedlibdir#\n/^includedir *=/s#=.*#= $includedir#\n/^mandir *=/s#=.*#= $mandir#\n/^SRCDIR *=/s#=.*#=$SRCDIR#\n/^INCLUDES *=/s#=.*#=$INCLUDES#\n/^OBJC *=/s#=.*#= $OBJC#\n/^TESTOBJG *=/s#=.*#= $TESTOBJG#\n/^PIC_TESTOBJG *=/s#=.*#= $PIC_TESTOBJG#\n/^PIC_OBJC *=/s#=.*#= $PIC_OBJC#\n/^all: */s#:.*#: $ALL#\n/^install-libs: */s#:.*#: $INSTALLTARGETS#\n/^uninstall-libs: */s#:.*#: $UNINSTALLTARGETS#\n/^ARCHDIR *=/s#=.*#=$ARCHDIR#\n/^ARCH_STATIC_OBJS *=/s#=.*#=$ARCH_STATIC_OBJS#\n/^ARCH_SHARED_OBJS *=/s#=.*#=$ARCH_SHARED_OBJS#\n\" > Makefile\n\n# Append header files dependencies.\nfor file in $SRCDIR/*.c $SRCDIR/test/*.c $SRCDIR/test/fuzz/*.c $SRCDIR/$ARCHDIR/*.c $SRCDIR/tools/*.c; do\n    if test ! -f $file; then\n        continue\n    fi\n\n    short_name=$(echo $file | sed -e \"s#$SRCDIR/##g\")\n    incs=$(grep -h include $file | sed -n 's/# *\\include *\"\\(.*\\.h\\)\".*/\\1/p' | sort | uniq)\n    includes=$(for i in $incs; do\n                   # Check that the include file exists in the current dir,\n                   # otherwise it may be one of the system include header.\n                   if test -e $SRCDIR/$i; then\n                       printf \" \\$(SRCDIR)/$i\"\n                   fi\n                   # We also need to check whether the include file is in the ARCHDIR.\n                   if test -e $SRCDIR/$ARCHDIR/$i; then\n                       printf \" \\$(SRCDIR)/$ARCHDIR/$i\"\n                   fi\n               done)\n    obj=$(basename $(echo $file | sed -e 's/\\.c/\\.o/g' -e 's#^\\./##g'))\n    lobj=$(basename $(echo $file | sed -e 's/\\.c/\\.lo/g' -e 's#^\\./##g'))\n\n    if grep -q \"^$obj:\" Makefile; then\n        # Replace the existing line with a line with all dependences.\n        $(replace_in_file \"s#$obj:.*#$obj: \\$(SRCDIR)/$short_name $includes#g\" Makefile)\n    else\n        # Append at the end of Makefile a new line with the header dependences.\n        echo \"$obj: \\$(SRCDIR)/$short_name $includes\" >> Makefile\n\n        # In case this is one of the ARCHDIR files, append a dependence line\n        # that will force the `$(MAKE) -C $(ARCHDIR)` generic rule. Without this\n        # we would only execute the copy rule from ARCHDIR to SRCDIR.\n        if test -e $SRCDIR/$ARCHDIR/$(basename $file); then\n            echo \"$ARCHDIR/$obj: \\$(SRCDIR)/$short_name $includes\" >> Makefile\n        fi\n    fi\n\n    if grep -q \"^$lobj:\" Makefile; then\n        # Replace the existing line with a line with all dependences.\n        $(replace_in_file \"s#$lobj:.*#$lobj: \\$(SRCDIR)/$short_name $includes#g\" Makefile)\n    else\n        # Append at the end of Makefile a new line with the header dependences.\n        echo \"$lobj: \\$(SRCDIR)/$short_name $includes\" >> Makefile\n    fi\ndone\n\n# Generate Makefile in arch dir\nmkdir -p $ARCHDIR\n\nsed < $SRCDIR/$ARCHDIR/Makefile.in \"\n/^CC *=/s#=.*#=$CC#\n/^CFLAGS *=/s#=.*#=$CFLAGS#\n/^SFLAGS *=/s#=.*#=$SFLAGS#\n/^LDFLAGS *=/s#=.*#=$LDFLAGS#\n/^INCLUDES *=/s#=.*#=$INCLUDES#\n/^SUFFIX *=/s#=.*#=$SUFFIX#\n/^SRCDIR *=/s#=.*#=$SRCDIR/$ARCHDIR#\n/^SRCTOP *=/s#=.*#=$SRCDIR#\n/^BUILDDIR *=/s#=.*#=$BUILDDIR#\n/^AVX2FLAG *=/s#=.*#=$avx2flag#\n/^AVX512FLAG *=/s#=.*#=$avx512flag#\n/^AVX512VNNIFLAG *=/s#=.*#=$avx512vnniflag#\n/^SSE2FLAG *=/s#=.*#=$sse2flag#\n/^SSSE3FLAG *=/s#=.*#=$ssse3flag#\n/^SSE42FLAG *=/s#=.*#=$sse42flag#\n/^PCLMULFLAG *=/s#=.*#=$pclmulflag#\n/^VPCLMULFLAG *=/s#=.*#=$vpclmulflag#\n/^XSAVEFLAG *=/s#=.*#=$xsaveflag#\n/^ACLEFLAG *=/s#=.*#=$acleflag#\n/^NEONFLAG *=/s#=.*#=$neonflag#\n/^ARMV6FLAG *=/s#=.*#=$armv6flag#\n/^NOLTOFLAG *=/s#=.*#=$noltoflag#\n/^VGFMAFLAG *=/s#=.*#=$vgfmaflag#\n/^PPCFLAGS *=/s#=.*#=$vmxflag#\n\" > $ARCHDIR/Makefile\n\n# Append header files dependencies.\nfor file in $SRCDIR/$ARCHDIR/*.c; do\n    if test ! -f $file; then\n        continue\n    fi\n\n    incs=$(grep -h include $file | sed -n 's/# *\\include *\"\\(.*\\.h\\)\".*/\\1/p' | sort | uniq)\n    includes=$(for i in $incs; do\n                   # Check that the include file exists in the current dir,\n                   # otherwise it may be one of the system include header.\n                   if test -e $SRCDIR/$i; then\n                       printf \" \\$(SRCTOP)/$i\"\n                   fi\n                   # We also need to check whether the include file is in the ARCHDIR.\n                   if test -e $SRCDIR/$ARCHDIR/$i; then\n                       printf \" \\$(SRCDIR)/$i\"\n                   fi\n               done)\n    obj=$(basename $(echo $file | sed -e 's/\\.c/\\.o/g' -e 's#^\\./##g'))\n    lobj=$(basename $(echo $file | sed -e 's/\\.c/\\.lo/g' -e 's#^\\./##g'))\n    short_name=$(basename $file)\n    if grep -q \"^$obj:\" $ARCHDIR/Makefile; then\n        # Replace the existing line with a line with all dependences.\n        $(replace_in_file \"s#$obj:.*#$obj: \\$(SRCDIR)/$short_name $includes#g\" $ARCHDIR/Makefile)\n    else\n        # Append at the end of Makefile a new line with the header dependences.\n        echo \"$obj: \\$(SRCDIR)/$short_name $includes\" >> $ARCHDIR/Makefile\n    fi\n\n    if grep -q \"^$lobj:\" $ARCHDIR/Makefile; then\n        # Replace the existing line with a line with all dependences.\n        $(replace_in_file \"s#$lobj:.*#$lobj: \\$(SRCDIR)/$short_name $includes#g\" $ARCHDIR/Makefile)\n    else\n        # Append at the end of Makefile a new line with the header dependences.\n        echo \"$lobj: \\$(SRCDIR)/$short_name $includes\" >> $ARCHDIR/Makefile\n    fi\ndone\n\n# Generate Makefile in generic arch dir\nmkdir -p arch/generic\n\nsed < $SRCDIR/arch/generic/Makefile.in \"\n/^CC *=/s#=.*#=$CC#\n/^CFLAGS *=/s#=.*#=$CFLAGS#\n/^SFLAGS *=/s#=.*#=$SFLAGS#\n/^INCLUDES *=/s#=.*#=$INCLUDES#\n/^SRCDIR *=/s#=.*#=$SRCDIR/arch/generic#\n/^SRCTOP *=/s#=.*#=$SRCDIR#\n/^BUILDDIR *=/s#=.*#=$BUILDDIR#\n\" > arch/generic/Makefile\n\n## TODO: Process header dependencies\n\n# Emscripten does not support large amounts of data via stdin/out\n# https://github.com/emscripten-core/emscripten/issues/16755#issuecomment-1102732849\nif test \"$CHOST\" != \"wasm32\"; then\n    TEST=\"${TEST} ghtests\"\nfi\n\n# Determine emulator to use when running tests\nif test -z \"$EMU_RUN\" && test $QEMU_ARCH; then\n    EMU_RUN=\"qemu-$QEMU_ARCH -L /usr/${CHOST}/\"\nfi\nif test -n \"$EMU_RUN\"; then\n    echo \"Using cross-compile emulator: $EMU_RUN\"\nfi\n\nif test $gzfileops -eq 1; then\n    PC_CFLAGS=\"-DWITH_GZFILEOP\"\nfi\n\n# Generate Makefile in test dir\nmkdir -p test\nsed < $SRCDIR/test/Makefile.in \"\n/^CC *=/s#=.*#=$CC#\n/^CFLAGS *=/s#=.*#=$CFLAGS#\n/^LDFLAGS *=/s#=.*#=$LDFLAGS#\n/^EXE *=/s#=.*#=$EXE#\n/^alltests: */s#:.*#: $TEST#\n/^SRCDIR *=/s#=.*#=$SRCDIR/test#\n/^SRCTOP *=/s#=.*#=$SRCDIR#\n/^EMU_RUN *=/s#=.*#=$EMU_RUN#\n/^LIBNAME *=/s#=.*#=$LIBNAME#\n\" > test/Makefile\n\n# create zlib.pc with the configure results\nsed < $SRCDIR/zlib.pc.in \"\n/^CC *=/s#=.*#=$CC#\n/^CFLAGS *=/s#=.*#=$CFLAGS#\n/^LDFLAGS *=/s#=.*#=$LDFLAGS#\n/^LDSHARED *=/s#=.*#=$LDSHARED#\n/^LDSHAREDFLAGS *=/s#=.*#=$LDSHAREDFLAGS#\n/^STATICLIB *=/s#=.*#=$STATICLIB#\n/^SHAREDLIB *=/s#=.*#=$SHAREDLIB#\n/^SHAREDLIBV *=/s#=.*#=$SHAREDLIBV#\n/^SHAREDLIBM *=/s#=.*#=$SHAREDLIBM#\n/^IMPORTLIB *=/s#=.*#=$IMPORTLIB#\n/^AR *=/s#=.*#=$AR#\n/^ARFLAGS *=/s#=.*#=$ARFLAGS#\n/^RANLIB *=/s#=.*#=$RANLIB#\n/^EXE *=/s#=.*#=$EXE#\n/^prefix *=/s#=.*#=$prefix#\n/^exec_prefix *=/s#=.*#=$exec_prefix#\n/^bindir *=/s#=.*#=$bindir#\n/^symbol_prefix *=/s#=.*#=$symbol_prefix#\n/^libdir *=/s#=.*#=$libdir#\n/^sharedlibdir *=/s#=.*#=$sharedlibdir#\n/^includedir *=/s#=.*#=$includedir#\n/^mandir *=/s#=.*#=$mandir#\n/^LDFLAGS *=/s#=.*#=$LDFLAGS#\n\" | sed -e \"\ns/\\@VERSION\\@/$VER/g;\ns/\\@SUFFIX\\@/$SUFFIX/g;\ns/\\@PKG_CONFIG_CFLAGS\\@/$PC_CFLAGS/g;\n\" > ${LIBNAME2}.pc\n\n# done\nleave 0\n"
        },
        {
          "name": "cpu_features.c",
          "type": "blob",
          "size": 0.7333984375,
          "content": "/* cpu_features.c -- CPU architecture feature check\n * Copyright (C) 2017 Hans Kristian Rosbach\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"cpu_features.h\"\n#include <string.h>\n\nZ_INTERNAL void cpu_check_features(struct cpu_features *features) {\n    memset(features, 0, sizeof(struct cpu_features));\n#if defined(X86_FEATURES)\n    x86_check_features(&features->x86);\n#elif defined(ARM_FEATURES)\n    arm_check_features(&features->arm);\n#elif defined(PPC_FEATURES) || defined(POWER_FEATURES)\n    power_check_features(&features->power);\n#elif defined(S390_FEATURES)\n    s390_check_features(&features->s390);\n#elif defined(RISCV_FEATURES)\n    riscv_check_features(&features->riscv);\n#endif\n}\n"
        },
        {
          "name": "cpu_features.h",
          "type": "blob",
          "size": 1.078125,
          "content": "/* cpu_features.h -- CPU architecture feature check\n * Copyright (C) 2017 Hans Kristian Rosbach\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef CPU_FEATURES_H_\n#define CPU_FEATURES_H_\n\n#ifndef DISABLE_RUNTIME_CPU_DETECTION\n\n#if defined(X86_FEATURES)\n#  include \"arch/x86/x86_features.h\"\n#elif defined(ARM_FEATURES)\n#  include \"arch/arm/arm_features.h\"\n#elif defined(PPC_FEATURES) || defined(POWER_FEATURES)\n#  include \"arch/power/power_features.h\"\n#elif defined(S390_FEATURES)\n#  include \"arch/s390/s390_features.h\"\n#elif defined(RISCV_FEATURES)\n#  include \"arch/riscv/riscv_features.h\"\n#endif\n\nstruct cpu_features {\n#if defined(X86_FEATURES)\n    struct x86_cpu_features x86;\n#elif defined(ARM_FEATURES)\n    struct arm_cpu_features arm;\n#elif defined(PPC_FEATURES) || defined(POWER_FEATURES)\n    struct power_cpu_features power;\n#elif defined(S390_FEATURES)\n    struct s390_cpu_features s390;\n#elif defined(RISCV_FEATURES)\n    struct riscv_cpu_features riscv;\n#else\n    char empty;\n#endif\n};\n\nvoid cpu_check_features(struct cpu_features *features);\n\n#endif\n\n#endif\n"
        },
        {
          "name": "crc32.c",
          "type": "blob",
          "size": 1.3662109375,
          "content": "/* crc32.c -- compute the CRC-32 of a data stream\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * This interleaved implementation of a CRC makes use of pipelined multiple\n * arithmetic-logic units, commonly found in modern CPU cores. It is due to\n * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.\n */\n\n#include \"zbuild.h\"\n#include \"functable.h\"\n#include \"crc32_braid_tbl.h\"\n\n/* ========================================================================= */\n\nconst uint32_t * Z_EXPORT PREFIX(get_crc_table)(void) {\n    return (const uint32_t *)crc_table;\n}\n\n#ifdef ZLIB_COMPAT\nunsigned long Z_EXPORT PREFIX(crc32_z)(unsigned long crc, const unsigned char *buf, size_t len) {\n    if (buf == NULL) return 0;\n\n    return (unsigned long)FUNCTABLE_CALL(crc32)((uint32_t)crc, buf, len);\n}\n#else\nuint32_t Z_EXPORT PREFIX(crc32_z)(uint32_t crc, const unsigned char *buf, size_t len) {\n    if (buf == NULL) return 0;\n\n    return FUNCTABLE_CALL(crc32)(crc, buf, len);\n}\n#endif\n\n#ifdef ZLIB_COMPAT\nunsigned long Z_EXPORT PREFIX(crc32)(unsigned long crc, const unsigned char *buf, unsigned int len) {\n    return (unsigned long)PREFIX(crc32_z)((uint32_t)crc, buf, len);\n}\n#else\nuint32_t Z_EXPORT PREFIX(crc32)(uint32_t crc, const unsigned char *buf, uint32_t len) {\n    return PREFIX(crc32_z)(crc, buf, len);\n}\n#endif\n"
        },
        {
          "name": "crc32.h",
          "type": "blob",
          "size": 0.37109375,
          "content": "/* crc32.h -- crc32 folding interface\n * Copyright (C) 2021 Nathan Moinvaziri\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n#ifndef CRC32_H_\n#define CRC32_H_\n\n#define CRC32_FOLD_BUFFER_SIZE (16 * 4)\n/* sizeof(__m128i) * (4 folds) */\n\ntypedef struct crc32_fold_s {\n    uint8_t fold[CRC32_FOLD_BUFFER_SIZE];\n    uint32_t value;\n} crc32_fold;\n\n#endif\n"
        },
        {
          "name": "crc32_braid_comb.c",
          "type": "blob",
          "size": 2.248046875,
          "content": "/* crc32_braid_comb.c -- compute the CRC-32 of a data stream\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * This interleaved implementation of a CRC makes use of pipelined multiple\n * arithmetic-logic units, commonly found in modern CPU cores. It is due to\n * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.\n */\n\n#include \"zutil.h\"\n#include \"crc32_braid_p.h\"\n#include \"crc32_braid_tbl.h\"\n#include \"crc32_braid_comb_p.h\"\n\n/* ========================================================================= */\nstatic uint32_t crc32_combine_(uint32_t crc1, uint32_t crc2, z_off64_t len2) {\n    return multmodp(x2nmodp(len2, 3), crc1) ^ crc2;\n}\nstatic uint32_t crc32_combine_gen_(z_off64_t len2) {\n     return x2nmodp(len2, 3);\n}\nstatic uint32_t crc32_combine_op_(uint32_t crc1, uint32_t crc2, const uint32_t op) {\n    return multmodp(op, crc1) ^ crc2;\n}\n\n/* ========================================================================= */\n\n#ifdef ZLIB_COMPAT\nunsigned long Z_EXPORT PREFIX(crc32_combine)(unsigned long crc1, unsigned long crc2, z_off_t len2) {\n    return (unsigned long)crc32_combine_((uint32_t)crc1, (uint32_t)crc2, len2);\n}\nunsigned long Z_EXPORT PREFIX4(crc32_combine)(unsigned long crc1, unsigned long crc2, z_off64_t len2) {\n    return (unsigned long)crc32_combine_((uint32_t)crc1, (uint32_t)crc2, len2);\n}\nunsigned long Z_EXPORT PREFIX(crc32_combine_gen)(z_off_t len2) {\n    return crc32_combine_gen_(len2);\n}\nunsigned long Z_EXPORT PREFIX4(crc32_combine_gen)(z_off64_t len2) {\n    return crc32_combine_gen_(len2);\n}\nunsigned long Z_EXPORT PREFIX(crc32_combine_op)(unsigned long crc1, unsigned long crc2, const unsigned long op) {\n    return (unsigned long)crc32_combine_op_((uint32_t)crc1, (uint32_t)crc2, (uint32_t)op);\n}\n#else\nuint32_t Z_EXPORT PREFIX4(crc32_combine)(uint32_t crc1, uint32_t crc2, z_off64_t len2) {\n    return crc32_combine_(crc1, crc2, len2);\n}\nuint32_t Z_EXPORT PREFIX(crc32_combine_gen)(z_off64_t len2) {\n    return crc32_combine_gen_(len2);\n}\nuint32_t Z_EXPORT PREFIX(crc32_combine_op)(uint32_t crc1, uint32_t crc2, const uint32_t op) {\n    return crc32_combine_op_(crc1, crc2, op);\n}\n#endif\n\n/* ========================================================================= */\n"
        },
        {
          "name": "crc32_braid_comb_p.h",
          "type": "blob",
          "size": 0.88671875,
          "content": "#ifndef CRC32_BRAID_COMB_P_H_\n#define CRC32_BRAID_COMB_P_H_\n\n/*\n  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,\n  reflected. For speed, this requires that a not be zero.\n */\nstatic uint32_t multmodp(uint32_t a, uint32_t b) {\n    uint32_t m, p;\n\n    m = (uint32_t)1 << 31;\n    p = 0;\n    for (;;) {\n        if (a & m) {\n            p ^= b;\n            if ((a & (m - 1)) == 0)\n                break;\n        }\n        m >>= 1;\n        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n    }\n    return p;\n}\n\n/*\n  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been\n  initialized.\n */\nstatic uint32_t x2nmodp(z_off64_t n, unsigned k) {\n    uint32_t p;\n\n    p = (uint32_t)1 << 31;           /* x^0 == 1 */\n    while (n) {\n        if (n & 1)\n            p = multmodp(x2n_table[k & 31], p);\n        n >>= 1;\n        k++;\n    }\n    return p;\n}\n\n#endif /* CRC32_BRAID_COMB_P_H_ */\n"
        },
        {
          "name": "crc32_braid_p.h",
          "type": "blob",
          "size": 1.3359375,
          "content": "#ifndef CRC32_BRAID_P_H_\n#define CRC32_BRAID_P_H_\n\n#include \"zendian.h\"\n\n/* Define N */\n#ifdef Z_TESTN\n#  define N Z_TESTN\n#else\n#  define N 5\n#endif\n#if N < 1 || N > 6\n#  error N must be in 1..6\n#endif\n\n/*\n  Define W and the associated z_word_t type. If W is not defined, then a\n  braided calculation is not used, and the associated tables and code are not\n  compiled.\n */\n#ifdef Z_TESTW\n#  if Z_TESTW-1 != -1\n#    define W Z_TESTW\n#  endif\n#else\n#  ifndef W\n#    if defined(__x86_64__) || defined(_M_AMD64) || defined(__aarch64__) || defined(_M_ARM64) || defined(__powerpc64__)\n#      define W 8\n#    else\n#      define W 4\n#    endif\n#  endif\n#endif\n#ifdef W\n#  if W == 8\n     typedef uint64_t z_word_t;\n#  else\n#    undef W\n#    define W 4\n     typedef uint32_t z_word_t;\n#  endif\n#endif\n\n#if BYTE_ORDER == LITTLE_ENDIAN\n#  define ZSWAPWORD(word) (word)\n#  define BRAID_TABLE crc_braid_table\n#elif BYTE_ORDER == BIG_ENDIAN\n#  if W == 8\n#    define ZSWAPWORD(word) ZSWAP64(word)\n#  elif W == 4\n#    define ZSWAPWORD(word) ZSWAP32(word)\n#  endif\n#  define BRAID_TABLE crc_braid_big_table\n#else\n#  error \"No endian defined\"\n#endif\n\n#define DO1 c = crc_table[(c ^ *buf++) & 0xff] ^ (c >> 8)\n#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1\n\n/* CRC polynomial. */\n#define POLY 0xedb88320         /* p(x) reflected, with x^32 implied */\n\n#endif /* CRC32_BRAID_P_H_ */\n"
        },
        {
          "name": "crc32_braid_tbl.h",
          "type": "blob",
          "size": 578.0380859375,
          "content": "#ifndef CRC32_BRAID_TBL_H_\n#define CRC32_BRAID_TBL_H_\n\n/* crc32_braid_tbl.h -- tables for braided CRC calculation\n * Generated automatically by makecrct.c\n */\n\nstatic const uint32_t crc_table[] = {\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d};\n\n#ifdef W\n\n#if W == 8\n\nstatic const z_word_t crc_big_table[] = {\n    0x0000000000000000, 0x9630077700000000, 0x2c610eee00000000,\n    0xba51099900000000, 0x19c46d0700000000, 0x8ff46a7000000000,\n    0x35a563e900000000, 0xa395649e00000000, 0x3288db0e00000000,\n    0xa4b8dc7900000000, 0x1ee9d5e000000000, 0x88d9d29700000000,\n    0x2b4cb60900000000, 0xbd7cb17e00000000, 0x072db8e700000000,\n    0x911dbf9000000000, 0x6410b71d00000000, 0xf220b06a00000000,\n    0x4871b9f300000000, 0xde41be8400000000, 0x7dd4da1a00000000,\n    0xebe4dd6d00000000, 0x51b5d4f400000000, 0xc785d38300000000,\n    0x56986c1300000000, 0xc0a86b6400000000, 0x7af962fd00000000,\n    0xecc9658a00000000, 0x4f5c011400000000, 0xd96c066300000000,\n    0x633d0ffa00000000, 0xf50d088d00000000, 0xc8206e3b00000000,\n    0x5e10694c00000000, 0xe44160d500000000, 0x727167a200000000,\n    0xd1e4033c00000000, 0x47d4044b00000000, 0xfd850dd200000000,\n    0x6bb50aa500000000, 0xfaa8b53500000000, 0x6c98b24200000000,\n    0xd6c9bbdb00000000, 0x40f9bcac00000000, 0xe36cd83200000000,\n    0x755cdf4500000000, 0xcf0dd6dc00000000, 0x593dd1ab00000000,\n    0xac30d92600000000, 0x3a00de5100000000, 0x8051d7c800000000,\n    0x1661d0bf00000000, 0xb5f4b42100000000, 0x23c4b35600000000,\n    0x9995bacf00000000, 0x0fa5bdb800000000, 0x9eb8022800000000,\n    0x0888055f00000000, 0xb2d90cc600000000, 0x24e90bb100000000,\n    0x877c6f2f00000000, 0x114c685800000000, 0xab1d61c100000000,\n    0x3d2d66b600000000, 0x9041dc7600000000, 0x0671db0100000000,\n    0xbc20d29800000000, 0x2a10d5ef00000000, 0x8985b17100000000,\n    0x1fb5b60600000000, 0xa5e4bf9f00000000, 0x33d4b8e800000000,\n    0xa2c9077800000000, 0x34f9000f00000000, 0x8ea8099600000000,\n    0x18980ee100000000, 0xbb0d6a7f00000000, 0x2d3d6d0800000000,\n    0x976c649100000000, 0x015c63e600000000, 0xf4516b6b00000000,\n    0x62616c1c00000000, 0xd830658500000000, 0x4e0062f200000000,\n    0xed95066c00000000, 0x7ba5011b00000000, 0xc1f4088200000000,\n    0x57c40ff500000000, 0xc6d9b06500000000, 0x50e9b71200000000,\n    0xeab8be8b00000000, 0x7c88b9fc00000000, 0xdf1ddd6200000000,\n    0x492dda1500000000, 0xf37cd38c00000000, 0x654cd4fb00000000,\n    0x5861b24d00000000, 0xce51b53a00000000, 0x7400bca300000000,\n    0xe230bbd400000000, 0x41a5df4a00000000, 0xd795d83d00000000,\n    0x6dc4d1a400000000, 0xfbf4d6d300000000, 0x6ae9694300000000,\n    0xfcd96e3400000000, 0x468867ad00000000, 0xd0b860da00000000,\n    0x732d044400000000, 0xe51d033300000000, 0x5f4c0aaa00000000,\n    0xc97c0ddd00000000, 0x3c71055000000000, 0xaa41022700000000,\n    0x10100bbe00000000, 0x86200cc900000000, 0x25b5685700000000,\n    0xb3856f2000000000, 0x09d466b900000000, 0x9fe461ce00000000,\n    0x0ef9de5e00000000, 0x98c9d92900000000, 0x2298d0b000000000,\n    0xb4a8d7c700000000, 0x173db35900000000, 0x810db42e00000000,\n    0x3b5cbdb700000000, 0xad6cbac000000000, 0x2083b8ed00000000,\n    0xb6b3bf9a00000000, 0x0ce2b60300000000, 0x9ad2b17400000000,\n    0x3947d5ea00000000, 0xaf77d29d00000000, 0x1526db0400000000,\n    0x8316dc7300000000, 0x120b63e300000000, 0x843b649400000000,\n    0x3e6a6d0d00000000, 0xa85a6a7a00000000, 0x0bcf0ee400000000,\n    0x9dff099300000000, 0x27ae000a00000000, 0xb19e077d00000000,\n    0x44930ff000000000, 0xd2a3088700000000, 0x68f2011e00000000,\n    0xfec2066900000000, 0x5d5762f700000000, 0xcb67658000000000,\n    0x71366c1900000000, 0xe7066b6e00000000, 0x761bd4fe00000000,\n    0xe02bd38900000000, 0x5a7ada1000000000, 0xcc4add6700000000,\n    0x6fdfb9f900000000, 0xf9efbe8e00000000, 0x43beb71700000000,\n    0xd58eb06000000000, 0xe8a3d6d600000000, 0x7e93d1a100000000,\n    0xc4c2d83800000000, 0x52f2df4f00000000, 0xf167bbd100000000,\n    0x6757bca600000000, 0xdd06b53f00000000, 0x4b36b24800000000,\n    0xda2b0dd800000000, 0x4c1b0aaf00000000, 0xf64a033600000000,\n    0x607a044100000000, 0xc3ef60df00000000, 0x55df67a800000000,\n    0xef8e6e3100000000, 0x79be694600000000, 0x8cb361cb00000000,\n    0x1a8366bc00000000, 0xa0d26f2500000000, 0x36e2685200000000,\n    0x95770ccc00000000, 0x03470bbb00000000, 0xb916022200000000,\n    0x2f26055500000000, 0xbe3bbac500000000, 0x280bbdb200000000,\n    0x925ab42b00000000, 0x046ab35c00000000, 0xa7ffd7c200000000,\n    0x31cfd0b500000000, 0x8b9ed92c00000000, 0x1daede5b00000000,\n    0xb0c2649b00000000, 0x26f263ec00000000, 0x9ca36a7500000000,\n    0x0a936d0200000000, 0xa906099c00000000, 0x3f360eeb00000000,\n    0x8567077200000000, 0x1357000500000000, 0x824abf9500000000,\n    0x147ab8e200000000, 0xae2bb17b00000000, 0x381bb60c00000000,\n    0x9b8ed29200000000, 0x0dbed5e500000000, 0xb7efdc7c00000000,\n    0x21dfdb0b00000000, 0xd4d2d38600000000, 0x42e2d4f100000000,\n    0xf8b3dd6800000000, 0x6e83da1f00000000, 0xcd16be8100000000,\n    0x5b26b9f600000000, 0xe177b06f00000000, 0x7747b71800000000,\n    0xe65a088800000000, 0x706a0fff00000000, 0xca3b066600000000,\n    0x5c0b011100000000, 0xff9e658f00000000, 0x69ae62f800000000,\n    0xd3ff6b6100000000, 0x45cf6c1600000000, 0x78e20aa000000000,\n    0xeed20dd700000000, 0x5483044e00000000, 0xc2b3033900000000,\n    0x612667a700000000, 0xf71660d000000000, 0x4d47694900000000,\n    0xdb776e3e00000000, 0x4a6ad1ae00000000, 0xdc5ad6d900000000,\n    0x660bdf4000000000, 0xf03bd83700000000, 0x53aebca900000000,\n    0xc59ebbde00000000, 0x7fcfb24700000000, 0xe9ffb53000000000,\n    0x1cf2bdbd00000000, 0x8ac2baca00000000, 0x3093b35300000000,\n    0xa6a3b42400000000, 0x0536d0ba00000000, 0x9306d7cd00000000,\n    0x2957de5400000000, 0xbf67d92300000000, 0x2e7a66b300000000,\n    0xb84a61c400000000, 0x021b685d00000000, 0x942b6f2a00000000,\n    0x37be0bb400000000, 0xa18e0cc300000000, 0x1bdf055a00000000,\n    0x8def022d00000000};\n\n#else /* W == 4 */\n\nstatic const z_word_t crc_big_table[] = {\n    0x00000000, 0x96300777, 0x2c610eee, 0xba510999, 0x19c46d07,\n    0x8ff46a70, 0x35a563e9, 0xa395649e, 0x3288db0e, 0xa4b8dc79,\n    0x1ee9d5e0, 0x88d9d297, 0x2b4cb609, 0xbd7cb17e, 0x072db8e7,\n    0x911dbf90, 0x6410b71d, 0xf220b06a, 0x4871b9f3, 0xde41be84,\n    0x7dd4da1a, 0xebe4dd6d, 0x51b5d4f4, 0xc785d383, 0x56986c13,\n    0xc0a86b64, 0x7af962fd, 0xecc9658a, 0x4f5c0114, 0xd96c0663,\n    0x633d0ffa, 0xf50d088d, 0xc8206e3b, 0x5e10694c, 0xe44160d5,\n    0x727167a2, 0xd1e4033c, 0x47d4044b, 0xfd850dd2, 0x6bb50aa5,\n    0xfaa8b535, 0x6c98b242, 0xd6c9bbdb, 0x40f9bcac, 0xe36cd832,\n    0x755cdf45, 0xcf0dd6dc, 0x593dd1ab, 0xac30d926, 0x3a00de51,\n    0x8051d7c8, 0x1661d0bf, 0xb5f4b421, 0x23c4b356, 0x9995bacf,\n    0x0fa5bdb8, 0x9eb80228, 0x0888055f, 0xb2d90cc6, 0x24e90bb1,\n    0x877c6f2f, 0x114c6858, 0xab1d61c1, 0x3d2d66b6, 0x9041dc76,\n    0x0671db01, 0xbc20d298, 0x2a10d5ef, 0x8985b171, 0x1fb5b606,\n    0xa5e4bf9f, 0x33d4b8e8, 0xa2c90778, 0x34f9000f, 0x8ea80996,\n    0x18980ee1, 0xbb0d6a7f, 0x2d3d6d08, 0x976c6491, 0x015c63e6,\n    0xf4516b6b, 0x62616c1c, 0xd8306585, 0x4e0062f2, 0xed95066c,\n    0x7ba5011b, 0xc1f40882, 0x57c40ff5, 0xc6d9b065, 0x50e9b712,\n    0xeab8be8b, 0x7c88b9fc, 0xdf1ddd62, 0x492dda15, 0xf37cd38c,\n    0x654cd4fb, 0x5861b24d, 0xce51b53a, 0x7400bca3, 0xe230bbd4,\n    0x41a5df4a, 0xd795d83d, 0x6dc4d1a4, 0xfbf4d6d3, 0x6ae96943,\n    0xfcd96e34, 0x468867ad, 0xd0b860da, 0x732d0444, 0xe51d0333,\n    0x5f4c0aaa, 0xc97c0ddd, 0x3c710550, 0xaa410227, 0x10100bbe,\n    0x86200cc9, 0x25b56857, 0xb3856f20, 0x09d466b9, 0x9fe461ce,\n    0x0ef9de5e, 0x98c9d929, 0x2298d0b0, 0xb4a8d7c7, 0x173db359,\n    0x810db42e, 0x3b5cbdb7, 0xad6cbac0, 0x2083b8ed, 0xb6b3bf9a,\n    0x0ce2b603, 0x9ad2b174, 0x3947d5ea, 0xaf77d29d, 0x1526db04,\n    0x8316dc73, 0x120b63e3, 0x843b6494, 0x3e6a6d0d, 0xa85a6a7a,\n    0x0bcf0ee4, 0x9dff0993, 0x27ae000a, 0xb19e077d, 0x44930ff0,\n    0xd2a30887, 0x68f2011e, 0xfec20669, 0x5d5762f7, 0xcb676580,\n    0x71366c19, 0xe7066b6e, 0x761bd4fe, 0xe02bd389, 0x5a7ada10,\n    0xcc4add67, 0x6fdfb9f9, 0xf9efbe8e, 0x43beb717, 0xd58eb060,\n    0xe8a3d6d6, 0x7e93d1a1, 0xc4c2d838, 0x52f2df4f, 0xf167bbd1,\n    0x6757bca6, 0xdd06b53f, 0x4b36b248, 0xda2b0dd8, 0x4c1b0aaf,\n    0xf64a0336, 0x607a0441, 0xc3ef60df, 0x55df67a8, 0xef8e6e31,\n    0x79be6946, 0x8cb361cb, 0x1a8366bc, 0xa0d26f25, 0x36e26852,\n    0x95770ccc, 0x03470bbb, 0xb9160222, 0x2f260555, 0xbe3bbac5,\n    0x280bbdb2, 0x925ab42b, 0x046ab35c, 0xa7ffd7c2, 0x31cfd0b5,\n    0x8b9ed92c, 0x1daede5b, 0xb0c2649b, 0x26f263ec, 0x9ca36a75,\n    0x0a936d02, 0xa906099c, 0x3f360eeb, 0x85670772, 0x13570005,\n    0x824abf95, 0x147ab8e2, 0xae2bb17b, 0x381bb60c, 0x9b8ed292,\n    0x0dbed5e5, 0xb7efdc7c, 0x21dfdb0b, 0xd4d2d386, 0x42e2d4f1,\n    0xf8b3dd68, 0x6e83da1f, 0xcd16be81, 0x5b26b9f6, 0xe177b06f,\n    0x7747b718, 0xe65a0888, 0x706a0fff, 0xca3b0666, 0x5c0b0111,\n    0xff9e658f, 0x69ae62f8, 0xd3ff6b61, 0x45cf6c16, 0x78e20aa0,\n    0xeed20dd7, 0x5483044e, 0xc2b30339, 0x612667a7, 0xf71660d0,\n    0x4d476949, 0xdb776e3e, 0x4a6ad1ae, 0xdc5ad6d9, 0x660bdf40,\n    0xf03bd837, 0x53aebca9, 0xc59ebbde, 0x7fcfb247, 0xe9ffb530,\n    0x1cf2bdbd, 0x8ac2baca, 0x3093b353, 0xa6a3b424, 0x0536d0ba,\n    0x9306d7cd, 0x2957de54, 0xbf67d923, 0x2e7a66b3, 0xb84a61c4,\n    0x021b685d, 0x942b6f2a, 0x37be0bb4, 0xa18e0cc3, 0x1bdf055a,\n    0x8def022d};\n\n#endif\n\n#endif /* W */\n\n#if N == 1\n\n#if W == 8\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0xccaa009e, 0x4225077d, 0x8e8f07e3, 0x844a0efa,\n    0x48e00e64, 0xc66f0987, 0x0ac50919, 0xd3e51bb5, 0x1f4f1b2b,\n    0x91c01cc8, 0x5d6a1c56, 0x57af154f, 0x9b0515d1, 0x158a1232,\n    0xd92012ac, 0x7cbb312b, 0xb01131b5, 0x3e9e3656, 0xf23436c8,\n    0xf8f13fd1, 0x345b3f4f, 0xbad438ac, 0x767e3832, 0xaf5e2a9e,\n    0x63f42a00, 0xed7b2de3, 0x21d12d7d, 0x2b142464, 0xe7be24fa,\n    0x69312319, 0xa59b2387, 0xf9766256, 0x35dc62c8, 0xbb53652b,\n    0x77f965b5, 0x7d3c6cac, 0xb1966c32, 0x3f196bd1, 0xf3b36b4f,\n    0x2a9379e3, 0xe639797d, 0x68b67e9e, 0xa41c7e00, 0xaed97719,\n    0x62737787, 0xecfc7064, 0x205670fa, 0x85cd537d, 0x496753e3,\n    0xc7e85400, 0x0b42549e, 0x01875d87, 0xcd2d5d19, 0x43a25afa,\n    0x8f085a64, 0x562848c8, 0x9a824856, 0x140d4fb5, 0xd8a74f2b,\n    0xd2624632, 0x1ec846ac, 0x9047414f, 0x5ced41d1, 0x299dc2ed,\n    0xe537c273, 0x6bb8c590, 0xa712c50e, 0xadd7cc17, 0x617dcc89,\n    0xeff2cb6a, 0x2358cbf4, 0xfa78d958, 0x36d2d9c6, 0xb85dde25,\n    0x74f7debb, 0x7e32d7a2, 0xb298d73c, 0x3c17d0df, 0xf0bdd041,\n    0x5526f3c6, 0x998cf358, 0x1703f4bb, 0xdba9f425, 0xd16cfd3c,\n    0x1dc6fda2, 0x9349fa41, 0x5fe3fadf, 0x86c3e873, 0x4a69e8ed,\n    0xc4e6ef0e, 0x084cef90, 0x0289e689, 0xce23e617, 0x40ace1f4,\n    0x8c06e16a, 0xd0eba0bb, 0x1c41a025, 0x92cea7c6, 0x5e64a758,\n    0x54a1ae41, 0x980baedf, 0x1684a93c, 0xda2ea9a2, 0x030ebb0e,\n    0xcfa4bb90, 0x412bbc73, 0x8d81bced, 0x8744b5f4, 0x4beeb56a,\n    0xc561b289, 0x09cbb217, 0xac509190, 0x60fa910e, 0xee7596ed,\n    0x22df9673, 0x281a9f6a, 0xe4b09ff4, 0x6a3f9817, 0xa6959889,\n    0x7fb58a25, 0xb31f8abb, 0x3d908d58, 0xf13a8dc6, 0xfbff84df,\n    0x37558441, 0xb9da83a2, 0x7570833c, 0x533b85da, 0x9f918544,\n    0x111e82a7, 0xddb48239, 0xd7718b20, 0x1bdb8bbe, 0x95548c5d,\n    0x59fe8cc3, 0x80de9e6f, 0x4c749ef1, 0xc2fb9912, 0x0e51998c,\n    0x04949095, 0xc83e900b, 0x46b197e8, 0x8a1b9776, 0x2f80b4f1,\n    0xe32ab46f, 0x6da5b38c, 0xa10fb312, 0xabcaba0b, 0x6760ba95,\n    0xe9efbd76, 0x2545bde8, 0xfc65af44, 0x30cfafda, 0xbe40a839,\n    0x72eaa8a7, 0x782fa1be, 0xb485a120, 0x3a0aa6c3, 0xf6a0a65d,\n    0xaa4de78c, 0x66e7e712, 0xe868e0f1, 0x24c2e06f, 0x2e07e976,\n    0xe2ade9e8, 0x6c22ee0b, 0xa088ee95, 0x79a8fc39, 0xb502fca7,\n    0x3b8dfb44, 0xf727fbda, 0xfde2f2c3, 0x3148f25d, 0xbfc7f5be,\n    0x736df520, 0xd6f6d6a7, 0x1a5cd639, 0x94d3d1da, 0x5879d144,\n    0x52bcd85d, 0x9e16d8c3, 0x1099df20, 0xdc33dfbe, 0x0513cd12,\n    0xc9b9cd8c, 0x4736ca6f, 0x8b9ccaf1, 0x8159c3e8, 0x4df3c376,\n    0xc37cc495, 0x0fd6c40b, 0x7aa64737, 0xb60c47a9, 0x3883404a,\n    0xf42940d4, 0xfeec49cd, 0x32464953, 0xbcc94eb0, 0x70634e2e,\n    0xa9435c82, 0x65e95c1c, 0xeb665bff, 0x27cc5b61, 0x2d095278,\n    0xe1a352e6, 0x6f2c5505, 0xa386559b, 0x061d761c, 0xcab77682,\n    0x44387161, 0x889271ff, 0x825778e6, 0x4efd7878, 0xc0727f9b,\n    0x0cd87f05, 0xd5f86da9, 0x19526d37, 0x97dd6ad4, 0x5b776a4a,\n    0x51b26353, 0x9d1863cd, 0x1397642e, 0xdf3d64b0, 0x83d02561,\n    0x4f7a25ff, 0xc1f5221c, 0x0d5f2282, 0x079a2b9b, 0xcb302b05,\n    0x45bf2ce6, 0x89152c78, 0x50353ed4, 0x9c9f3e4a, 0x121039a9,\n    0xdeba3937, 0xd47f302e, 0x18d530b0, 0x965a3753, 0x5af037cd,\n    0xff6b144a, 0x33c114d4, 0xbd4e1337, 0x71e413a9, 0x7b211ab0,\n    0xb78b1a2e, 0x39041dcd, 0xf5ae1d53, 0x2c8e0fff, 0xe0240f61,\n    0x6eab0882, 0xa201081c, 0xa8c40105, 0x646e019b, 0xeae10678,\n    0x264b06e6},\n   {0x00000000, 0xa6770bb4, 0x979f1129, 0x31e81a9d, 0xf44f2413,\n    0x52382fa7, 0x63d0353a, 0xc5a73e8e, 0x33ef4e67, 0x959845d3,\n    0xa4705f4e, 0x020754fa, 0xc7a06a74, 0x61d761c0, 0x503f7b5d,\n    0xf64870e9, 0x67de9cce, 0xc1a9977a, 0xf0418de7, 0x56368653,\n    0x9391b8dd, 0x35e6b369, 0x040ea9f4, 0xa279a240, 0x5431d2a9,\n    0xf246d91d, 0xc3aec380, 0x65d9c834, 0xa07ef6ba, 0x0609fd0e,\n    0x37e1e793, 0x9196ec27, 0xcfbd399c, 0x69ca3228, 0x582228b5,\n    0xfe552301, 0x3bf21d8f, 0x9d85163b, 0xac6d0ca6, 0x0a1a0712,\n    0xfc5277fb, 0x5a257c4f, 0x6bcd66d2, 0xcdba6d66, 0x081d53e8,\n    0xae6a585c, 0x9f8242c1, 0x39f54975, 0xa863a552, 0x0e14aee6,\n    0x3ffcb47b, 0x998bbfcf, 0x5c2c8141, 0xfa5b8af5, 0xcbb39068,\n    0x6dc49bdc, 0x9b8ceb35, 0x3dfbe081, 0x0c13fa1c, 0xaa64f1a8,\n    0x6fc3cf26, 0xc9b4c492, 0xf85cde0f, 0x5e2bd5bb, 0x440b7579,\n    0xe27c7ecd, 0xd3946450, 0x75e36fe4, 0xb044516a, 0x16335ade,\n    0x27db4043, 0x81ac4bf7, 0x77e43b1e, 0xd19330aa, 0xe07b2a37,\n    0x460c2183, 0x83ab1f0d, 0x25dc14b9, 0x14340e24, 0xb2430590,\n    0x23d5e9b7, 0x85a2e203, 0xb44af89e, 0x123df32a, 0xd79acda4,\n    0x71edc610, 0x4005dc8d, 0xe672d739, 0x103aa7d0, 0xb64dac64,\n    0x87a5b6f9, 0x21d2bd4d, 0xe47583c3, 0x42028877, 0x73ea92ea,\n    0xd59d995e, 0x8bb64ce5, 0x2dc14751, 0x1c295dcc, 0xba5e5678,\n    0x7ff968f6, 0xd98e6342, 0xe86679df, 0x4e11726b, 0xb8590282,\n    0x1e2e0936, 0x2fc613ab, 0x89b1181f, 0x4c162691, 0xea612d25,\n    0xdb8937b8, 0x7dfe3c0c, 0xec68d02b, 0x4a1fdb9f, 0x7bf7c102,\n    0xdd80cab6, 0x1827f438, 0xbe50ff8c, 0x8fb8e511, 0x29cfeea5,\n    0xdf879e4c, 0x79f095f8, 0x48188f65, 0xee6f84d1, 0x2bc8ba5f,\n    0x8dbfb1eb, 0xbc57ab76, 0x1a20a0c2, 0x8816eaf2, 0x2e61e146,\n    0x1f89fbdb, 0xb9fef06f, 0x7c59cee1, 0xda2ec555, 0xebc6dfc8,\n    0x4db1d47c, 0xbbf9a495, 0x1d8eaf21, 0x2c66b5bc, 0x8a11be08,\n    0x4fb68086, 0xe9c18b32, 0xd82991af, 0x7e5e9a1b, 0xefc8763c,\n    0x49bf7d88, 0x78576715, 0xde206ca1, 0x1b87522f, 0xbdf0599b,\n    0x8c184306, 0x2a6f48b2, 0xdc27385b, 0x7a5033ef, 0x4bb82972,\n    0xedcf22c6, 0x28681c48, 0x8e1f17fc, 0xbff70d61, 0x198006d5,\n    0x47abd36e, 0xe1dcd8da, 0xd034c247, 0x7643c9f3, 0xb3e4f77d,\n    0x1593fcc9, 0x247be654, 0x820cede0, 0x74449d09, 0xd23396bd,\n    0xe3db8c20, 0x45ac8794, 0x800bb91a, 0x267cb2ae, 0x1794a833,\n    0xb1e3a387, 0x20754fa0, 0x86024414, 0xb7ea5e89, 0x119d553d,\n    0xd43a6bb3, 0x724d6007, 0x43a57a9a, 0xe5d2712e, 0x139a01c7,\n    0xb5ed0a73, 0x840510ee, 0x22721b5a, 0xe7d525d4, 0x41a22e60,\n    0x704a34fd, 0xd63d3f49, 0xcc1d9f8b, 0x6a6a943f, 0x5b828ea2,\n    0xfdf58516, 0x3852bb98, 0x9e25b02c, 0xafcdaab1, 0x09baa105,\n    0xfff2d1ec, 0x5985da58, 0x686dc0c5, 0xce1acb71, 0x0bbdf5ff,\n    0xadcafe4b, 0x9c22e4d6, 0x3a55ef62, 0xabc30345, 0x0db408f1,\n    0x3c5c126c, 0x9a2b19d8, 0x5f8c2756, 0xf9fb2ce2, 0xc813367f,\n    0x6e643dcb, 0x982c4d22, 0x3e5b4696, 0x0fb35c0b, 0xa9c457bf,\n    0x6c636931, 0xca146285, 0xfbfc7818, 0x5d8b73ac, 0x03a0a617,\n    0xa5d7ada3, 0x943fb73e, 0x3248bc8a, 0xf7ef8204, 0x519889b0,\n    0x6070932d, 0xc6079899, 0x304fe870, 0x9638e3c4, 0xa7d0f959,\n    0x01a7f2ed, 0xc400cc63, 0x6277c7d7, 0x539fdd4a, 0xf5e8d6fe,\n    0x647e3ad9, 0xc209316d, 0xf3e12bf0, 0x55962044, 0x90311eca,\n    0x3646157e, 0x07ae0fe3, 0xa1d90457, 0x579174be, 0xf1e67f0a,\n    0xc00e6597, 0x66796e23, 0xa3de50ad, 0x05a95b19, 0x34414184,\n    0x92364a30},\n   {0x00000000, 0xcb5cd3a5, 0x4dc8a10b, 0x869472ae, 0x9b914216,\n    0x50cd91b3, 0xd659e31d, 0x1d0530b8, 0xec53826d, 0x270f51c8,\n    0xa19b2366, 0x6ac7f0c3, 0x77c2c07b, 0xbc9e13de, 0x3a0a6170,\n    0xf156b2d5, 0x03d6029b, 0xc88ad13e, 0x4e1ea390, 0x85427035,\n    0x9847408d, 0x531b9328, 0xd58fe186, 0x1ed33223, 0xef8580f6,\n    0x24d95353, 0xa24d21fd, 0x6911f258, 0x7414c2e0, 0xbf481145,\n    0x39dc63eb, 0xf280b04e, 0x07ac0536, 0xccf0d693, 0x4a64a43d,\n    0x81387798, 0x9c3d4720, 0x57619485, 0xd1f5e62b, 0x1aa9358e,\n    0xebff875b, 0x20a354fe, 0xa6372650, 0x6d6bf5f5, 0x706ec54d,\n    0xbb3216e8, 0x3da66446, 0xf6fab7e3, 0x047a07ad, 0xcf26d408,\n    0x49b2a6a6, 0x82ee7503, 0x9feb45bb, 0x54b7961e, 0xd223e4b0,\n    0x197f3715, 0xe82985c0, 0x23755665, 0xa5e124cb, 0x6ebdf76e,\n    0x73b8c7d6, 0xb8e41473, 0x3e7066dd, 0xf52cb578, 0x0f580a6c,\n    0xc404d9c9, 0x4290ab67, 0x89cc78c2, 0x94c9487a, 0x5f959bdf,\n    0xd901e971, 0x125d3ad4, 0xe30b8801, 0x28575ba4, 0xaec3290a,\n    0x659ffaaf, 0x789aca17, 0xb3c619b2, 0x35526b1c, 0xfe0eb8b9,\n    0x0c8e08f7, 0xc7d2db52, 0x4146a9fc, 0x8a1a7a59, 0x971f4ae1,\n    0x5c439944, 0xdad7ebea, 0x118b384f, 0xe0dd8a9a, 0x2b81593f,\n    0xad152b91, 0x6649f834, 0x7b4cc88c, 0xb0101b29, 0x36846987,\n    0xfdd8ba22, 0x08f40f5a, 0xc3a8dcff, 0x453cae51, 0x8e607df4,\n    0x93654d4c, 0x58399ee9, 0xdeadec47, 0x15f13fe2, 0xe4a78d37,\n    0x2ffb5e92, 0xa96f2c3c, 0x6233ff99, 0x7f36cf21, 0xb46a1c84,\n    0x32fe6e2a, 0xf9a2bd8f, 0x0b220dc1, 0xc07ede64, 0x46eaacca,\n    0x8db67f6f, 0x90b34fd7, 0x5bef9c72, 0xdd7beedc, 0x16273d79,\n    0xe7718fac, 0x2c2d5c09, 0xaab92ea7, 0x61e5fd02, 0x7ce0cdba,\n    0xb7bc1e1f, 0x31286cb1, 0xfa74bf14, 0x1eb014d8, 0xd5ecc77d,\n    0x5378b5d3, 0x98246676, 0x852156ce, 0x4e7d856b, 0xc8e9f7c5,\n    0x03b52460, 0xf2e396b5, 0x39bf4510, 0xbf2b37be, 0x7477e41b,\n    0x6972d4a3, 0xa22e0706, 0x24ba75a8, 0xefe6a60d, 0x1d661643,\n    0xd63ac5e6, 0x50aeb748, 0x9bf264ed, 0x86f75455, 0x4dab87f0,\n    0xcb3ff55e, 0x006326fb, 0xf135942e, 0x3a69478b, 0xbcfd3525,\n    0x77a1e680, 0x6aa4d638, 0xa1f8059d, 0x276c7733, 0xec30a496,\n    0x191c11ee, 0xd240c24b, 0x54d4b0e5, 0x9f886340, 0x828d53f8,\n    0x49d1805d, 0xcf45f2f3, 0x04192156, 0xf54f9383, 0x3e134026,\n    0xb8873288, 0x73dbe12d, 0x6eded195, 0xa5820230, 0x2316709e,\n    0xe84aa33b, 0x1aca1375, 0xd196c0d0, 0x5702b27e, 0x9c5e61db,\n    0x815b5163, 0x4a0782c6, 0xcc93f068, 0x07cf23cd, 0xf6999118,\n    0x3dc542bd, 0xbb513013, 0x700de3b6, 0x6d08d30e, 0xa65400ab,\n    0x20c07205, 0xeb9ca1a0, 0x11e81eb4, 0xdab4cd11, 0x5c20bfbf,\n    0x977c6c1a, 0x8a795ca2, 0x41258f07, 0xc7b1fda9, 0x0ced2e0c,\n    0xfdbb9cd9, 0x36e74f7c, 0xb0733dd2, 0x7b2fee77, 0x662adecf,\n    0xad760d6a, 0x2be27fc4, 0xe0beac61, 0x123e1c2f, 0xd962cf8a,\n    0x5ff6bd24, 0x94aa6e81, 0x89af5e39, 0x42f38d9c, 0xc467ff32,\n    0x0f3b2c97, 0xfe6d9e42, 0x35314de7, 0xb3a53f49, 0x78f9ecec,\n    0x65fcdc54, 0xaea00ff1, 0x28347d5f, 0xe368aefa, 0x16441b82,\n    0xdd18c827, 0x5b8cba89, 0x90d0692c, 0x8dd55994, 0x46898a31,\n    0xc01df89f, 0x0b412b3a, 0xfa1799ef, 0x314b4a4a, 0xb7df38e4,\n    0x7c83eb41, 0x6186dbf9, 0xaada085c, 0x2c4e7af2, 0xe712a957,\n    0x15921919, 0xdececabc, 0x585ab812, 0x93066bb7, 0x8e035b0f,\n    0x455f88aa, 0xc3cbfa04, 0x089729a1, 0xf9c19b74, 0x329d48d1,\n    0xb4093a7f, 0x7f55e9da, 0x6250d962, 0xa90c0ac7, 0x2f987869,\n    0xe4c4abcc},\n   {0x00000000, 0x3d6029b0, 0x7ac05360, 0x47a07ad0, 0xf580a6c0,\n    0xc8e08f70, 0x8f40f5a0, 0xb220dc10, 0x30704bc1, 0x0d106271,\n    0x4ab018a1, 0x77d03111, 0xc5f0ed01, 0xf890c4b1, 0xbf30be61,\n    0x825097d1, 0x60e09782, 0x5d80be32, 0x1a20c4e2, 0x2740ed52,\n    0x95603142, 0xa80018f2, 0xefa06222, 0xd2c04b92, 0x5090dc43,\n    0x6df0f5f3, 0x2a508f23, 0x1730a693, 0xa5107a83, 0x98705333,\n    0xdfd029e3, 0xe2b00053, 0xc1c12f04, 0xfca106b4, 0xbb017c64,\n    0x866155d4, 0x344189c4, 0x0921a074, 0x4e81daa4, 0x73e1f314,\n    0xf1b164c5, 0xccd14d75, 0x8b7137a5, 0xb6111e15, 0x0431c205,\n    0x3951ebb5, 0x7ef19165, 0x4391b8d5, 0xa121b886, 0x9c419136,\n    0xdbe1ebe6, 0xe681c256, 0x54a11e46, 0x69c137f6, 0x2e614d26,\n    0x13016496, 0x9151f347, 0xac31daf7, 0xeb91a027, 0xd6f18997,\n    0x64d15587, 0x59b17c37, 0x1e1106e7, 0x23712f57, 0x58f35849,\n    0x659371f9, 0x22330b29, 0x1f532299, 0xad73fe89, 0x9013d739,\n    0xd7b3ade9, 0xead38459, 0x68831388, 0x55e33a38, 0x124340e8,\n    0x2f236958, 0x9d03b548, 0xa0639cf8, 0xe7c3e628, 0xdaa3cf98,\n    0x3813cfcb, 0x0573e67b, 0x42d39cab, 0x7fb3b51b, 0xcd93690b,\n    0xf0f340bb, 0xb7533a6b, 0x8a3313db, 0x0863840a, 0x3503adba,\n    0x72a3d76a, 0x4fc3feda, 0xfde322ca, 0xc0830b7a, 0x872371aa,\n    0xba43581a, 0x9932774d, 0xa4525efd, 0xe3f2242d, 0xde920d9d,\n    0x6cb2d18d, 0x51d2f83d, 0x167282ed, 0x2b12ab5d, 0xa9423c8c,\n    0x9422153c, 0xd3826fec, 0xeee2465c, 0x5cc29a4c, 0x61a2b3fc,\n    0x2602c92c, 0x1b62e09c, 0xf9d2e0cf, 0xc4b2c97f, 0x8312b3af,\n    0xbe729a1f, 0x0c52460f, 0x31326fbf, 0x7692156f, 0x4bf23cdf,\n    0xc9a2ab0e, 0xf4c282be, 0xb362f86e, 0x8e02d1de, 0x3c220dce,\n    0x0142247e, 0x46e25eae, 0x7b82771e, 0xb1e6b092, 0x8c869922,\n    0xcb26e3f2, 0xf646ca42, 0x44661652, 0x79063fe2, 0x3ea64532,\n    0x03c66c82, 0x8196fb53, 0xbcf6d2e3, 0xfb56a833, 0xc6368183,\n    0x74165d93, 0x49767423, 0x0ed60ef3, 0x33b62743, 0xd1062710,\n    0xec660ea0, 0xabc67470, 0x96a65dc0, 0x248681d0, 0x19e6a860,\n    0x5e46d2b0, 0x6326fb00, 0xe1766cd1, 0xdc164561, 0x9bb63fb1,\n    0xa6d61601, 0x14f6ca11, 0x2996e3a1, 0x6e369971, 0x5356b0c1,\n    0x70279f96, 0x4d47b626, 0x0ae7ccf6, 0x3787e546, 0x85a73956,\n    0xb8c710e6, 0xff676a36, 0xc2074386, 0x4057d457, 0x7d37fde7,\n    0x3a978737, 0x07f7ae87, 0xb5d77297, 0x88b75b27, 0xcf1721f7,\n    0xf2770847, 0x10c70814, 0x2da721a4, 0x6a075b74, 0x576772c4,\n    0xe547aed4, 0xd8278764, 0x9f87fdb4, 0xa2e7d404, 0x20b743d5,\n    0x1dd76a65, 0x5a7710b5, 0x67173905, 0xd537e515, 0xe857cca5,\n    0xaff7b675, 0x92979fc5, 0xe915e8db, 0xd475c16b, 0x93d5bbbb,\n    0xaeb5920b, 0x1c954e1b, 0x21f567ab, 0x66551d7b, 0x5b3534cb,\n    0xd965a31a, 0xe4058aaa, 0xa3a5f07a, 0x9ec5d9ca, 0x2ce505da,\n    0x11852c6a, 0x562556ba, 0x6b457f0a, 0x89f57f59, 0xb49556e9,\n    0xf3352c39, 0xce550589, 0x7c75d999, 0x4115f029, 0x06b58af9,\n    0x3bd5a349, 0xb9853498, 0x84e51d28, 0xc34567f8, 0xfe254e48,\n    0x4c059258, 0x7165bbe8, 0x36c5c138, 0x0ba5e888, 0x28d4c7df,\n    0x15b4ee6f, 0x521494bf, 0x6f74bd0f, 0xdd54611f, 0xe03448af,\n    0xa794327f, 0x9af41bcf, 0x18a48c1e, 0x25c4a5ae, 0x6264df7e,\n    0x5f04f6ce, 0xed242ade, 0xd044036e, 0x97e479be, 0xaa84500e,\n    0x4834505d, 0x755479ed, 0x32f4033d, 0x0f942a8d, 0xbdb4f69d,\n    0x80d4df2d, 0xc774a5fd, 0xfa148c4d, 0x78441b9c, 0x4524322c,\n    0x028448fc, 0x3fe4614c, 0x8dc4bd5c, 0xb0a494ec, 0xf704ee3c,\n    0xca64c78c},\n   {0x00000000, 0xb8bc6765, 0xaa09c88b, 0x12b5afee, 0x8f629757,\n    0x37def032, 0x256b5fdc, 0x9dd738b9, 0xc5b428ef, 0x7d084f8a,\n    0x6fbde064, 0xd7018701, 0x4ad6bfb8, 0xf26ad8dd, 0xe0df7733,\n    0x58631056, 0x5019579f, 0xe8a530fa, 0xfa109f14, 0x42acf871,\n    0xdf7bc0c8, 0x67c7a7ad, 0x75720843, 0xcdce6f26, 0x95ad7f70,\n    0x2d111815, 0x3fa4b7fb, 0x8718d09e, 0x1acfe827, 0xa2738f42,\n    0xb0c620ac, 0x087a47c9, 0xa032af3e, 0x188ec85b, 0x0a3b67b5,\n    0xb28700d0, 0x2f503869, 0x97ec5f0c, 0x8559f0e2, 0x3de59787,\n    0x658687d1, 0xdd3ae0b4, 0xcf8f4f5a, 0x7733283f, 0xeae41086,\n    0x525877e3, 0x40edd80d, 0xf851bf68, 0xf02bf8a1, 0x48979fc4,\n    0x5a22302a, 0xe29e574f, 0x7f496ff6, 0xc7f50893, 0xd540a77d,\n    0x6dfcc018, 0x359fd04e, 0x8d23b72b, 0x9f9618c5, 0x272a7fa0,\n    0xbafd4719, 0x0241207c, 0x10f48f92, 0xa848e8f7, 0x9b14583d,\n    0x23a83f58, 0x311d90b6, 0x89a1f7d3, 0x1476cf6a, 0xaccaa80f,\n    0xbe7f07e1, 0x06c36084, 0x5ea070d2, 0xe61c17b7, 0xf4a9b859,\n    0x4c15df3c, 0xd1c2e785, 0x697e80e0, 0x7bcb2f0e, 0xc377486b,\n    0xcb0d0fa2, 0x73b168c7, 0x6104c729, 0xd9b8a04c, 0x446f98f5,\n    0xfcd3ff90, 0xee66507e, 0x56da371b, 0x0eb9274d, 0xb6054028,\n    0xa4b0efc6, 0x1c0c88a3, 0x81dbb01a, 0x3967d77f, 0x2bd27891,\n    0x936e1ff4, 0x3b26f703, 0x839a9066, 0x912f3f88, 0x299358ed,\n    0xb4446054, 0x0cf80731, 0x1e4da8df, 0xa6f1cfba, 0xfe92dfec,\n    0x462eb889, 0x549b1767, 0xec277002, 0x71f048bb, 0xc94c2fde,\n    0xdbf98030, 0x6345e755, 0x6b3fa09c, 0xd383c7f9, 0xc1366817,\n    0x798a0f72, 0xe45d37cb, 0x5ce150ae, 0x4e54ff40, 0xf6e89825,\n    0xae8b8873, 0x1637ef16, 0x048240f8, 0xbc3e279d, 0x21e91f24,\n    0x99557841, 0x8be0d7af, 0x335cb0ca, 0xed59b63b, 0x55e5d15e,\n    0x47507eb0, 0xffec19d5, 0x623b216c, 0xda874609, 0xc832e9e7,\n    0x708e8e82, 0x28ed9ed4, 0x9051f9b1, 0x82e4565f, 0x3a58313a,\n    0xa78f0983, 0x1f336ee6, 0x0d86c108, 0xb53aa66d, 0xbd40e1a4,\n    0x05fc86c1, 0x1749292f, 0xaff54e4a, 0x322276f3, 0x8a9e1196,\n    0x982bbe78, 0x2097d91d, 0x78f4c94b, 0xc048ae2e, 0xd2fd01c0,\n    0x6a4166a5, 0xf7965e1c, 0x4f2a3979, 0x5d9f9697, 0xe523f1f2,\n    0x4d6b1905, 0xf5d77e60, 0xe762d18e, 0x5fdeb6eb, 0xc2098e52,\n    0x7ab5e937, 0x680046d9, 0xd0bc21bc, 0x88df31ea, 0x3063568f,\n    0x22d6f961, 0x9a6a9e04, 0x07bda6bd, 0xbf01c1d8, 0xadb46e36,\n    0x15080953, 0x1d724e9a, 0xa5ce29ff, 0xb77b8611, 0x0fc7e174,\n    0x9210d9cd, 0x2aacbea8, 0x38191146, 0x80a57623, 0xd8c66675,\n    0x607a0110, 0x72cfaefe, 0xca73c99b, 0x57a4f122, 0xef189647,\n    0xfdad39a9, 0x45115ecc, 0x764dee06, 0xcef18963, 0xdc44268d,\n    0x64f841e8, 0xf92f7951, 0x41931e34, 0x5326b1da, 0xeb9ad6bf,\n    0xb3f9c6e9, 0x0b45a18c, 0x19f00e62, 0xa14c6907, 0x3c9b51be,\n    0x842736db, 0x96929935, 0x2e2efe50, 0x2654b999, 0x9ee8defc,\n    0x8c5d7112, 0x34e11677, 0xa9362ece, 0x118a49ab, 0x033fe645,\n    0xbb838120, 0xe3e09176, 0x5b5cf613, 0x49e959fd, 0xf1553e98,\n    0x6c820621, 0xd43e6144, 0xc68bceaa, 0x7e37a9cf, 0xd67f4138,\n    0x6ec3265d, 0x7c7689b3, 0xc4caeed6, 0x591dd66f, 0xe1a1b10a,\n    0xf3141ee4, 0x4ba87981, 0x13cb69d7, 0xab770eb2, 0xb9c2a15c,\n    0x017ec639, 0x9ca9fe80, 0x241599e5, 0x36a0360b, 0x8e1c516e,\n    0x866616a7, 0x3eda71c2, 0x2c6fde2c, 0x94d3b949, 0x090481f0,\n    0xb1b8e695, 0xa30d497b, 0x1bb12e1e, 0x43d23e48, 0xfb6e592d,\n    0xe9dbf6c3, 0x516791a6, 0xccb0a91f, 0x740cce7a, 0x66b96194,\n    0xde0506f1},\n   {0x00000000, 0x01c26a37, 0x0384d46e, 0x0246be59, 0x0709a8dc,\n    0x06cbc2eb, 0x048d7cb2, 0x054f1685, 0x0e1351b8, 0x0fd13b8f,\n    0x0d9785d6, 0x0c55efe1, 0x091af964, 0x08d89353, 0x0a9e2d0a,\n    0x0b5c473d, 0x1c26a370, 0x1de4c947, 0x1fa2771e, 0x1e601d29,\n    0x1b2f0bac, 0x1aed619b, 0x18abdfc2, 0x1969b5f5, 0x1235f2c8,\n    0x13f798ff, 0x11b126a6, 0x10734c91, 0x153c5a14, 0x14fe3023,\n    0x16b88e7a, 0x177ae44d, 0x384d46e0, 0x398f2cd7, 0x3bc9928e,\n    0x3a0bf8b9, 0x3f44ee3c, 0x3e86840b, 0x3cc03a52, 0x3d025065,\n    0x365e1758, 0x379c7d6f, 0x35dac336, 0x3418a901, 0x3157bf84,\n    0x3095d5b3, 0x32d36bea, 0x331101dd, 0x246be590, 0x25a98fa7,\n    0x27ef31fe, 0x262d5bc9, 0x23624d4c, 0x22a0277b, 0x20e69922,\n    0x2124f315, 0x2a78b428, 0x2bbade1f, 0x29fc6046, 0x283e0a71,\n    0x2d711cf4, 0x2cb376c3, 0x2ef5c89a, 0x2f37a2ad, 0x709a8dc0,\n    0x7158e7f7, 0x731e59ae, 0x72dc3399, 0x7793251c, 0x76514f2b,\n    0x7417f172, 0x75d59b45, 0x7e89dc78, 0x7f4bb64f, 0x7d0d0816,\n    0x7ccf6221, 0x798074a4, 0x78421e93, 0x7a04a0ca, 0x7bc6cafd,\n    0x6cbc2eb0, 0x6d7e4487, 0x6f38fade, 0x6efa90e9, 0x6bb5866c,\n    0x6a77ec5b, 0x68315202, 0x69f33835, 0x62af7f08, 0x636d153f,\n    0x612bab66, 0x60e9c151, 0x65a6d7d4, 0x6464bde3, 0x662203ba,\n    0x67e0698d, 0x48d7cb20, 0x4915a117, 0x4b531f4e, 0x4a917579,\n    0x4fde63fc, 0x4e1c09cb, 0x4c5ab792, 0x4d98dda5, 0x46c49a98,\n    0x4706f0af, 0x45404ef6, 0x448224c1, 0x41cd3244, 0x400f5873,\n    0x4249e62a, 0x438b8c1d, 0x54f16850, 0x55330267, 0x5775bc3e,\n    0x56b7d609, 0x53f8c08c, 0x523aaabb, 0x507c14e2, 0x51be7ed5,\n    0x5ae239e8, 0x5b2053df, 0x5966ed86, 0x58a487b1, 0x5deb9134,\n    0x5c29fb03, 0x5e6f455a, 0x5fad2f6d, 0xe1351b80, 0xe0f771b7,\n    0xe2b1cfee, 0xe373a5d9, 0xe63cb35c, 0xe7fed96b, 0xe5b86732,\n    0xe47a0d05, 0xef264a38, 0xeee4200f, 0xeca29e56, 0xed60f461,\n    0xe82fe2e4, 0xe9ed88d3, 0xebab368a, 0xea695cbd, 0xfd13b8f0,\n    0xfcd1d2c7, 0xfe976c9e, 0xff5506a9, 0xfa1a102c, 0xfbd87a1b,\n    0xf99ec442, 0xf85cae75, 0xf300e948, 0xf2c2837f, 0xf0843d26,\n    0xf1465711, 0xf4094194, 0xf5cb2ba3, 0xf78d95fa, 0xf64fffcd,\n    0xd9785d60, 0xd8ba3757, 0xdafc890e, 0xdb3ee339, 0xde71f5bc,\n    0xdfb39f8b, 0xddf521d2, 0xdc374be5, 0xd76b0cd8, 0xd6a966ef,\n    0xd4efd8b6, 0xd52db281, 0xd062a404, 0xd1a0ce33, 0xd3e6706a,\n    0xd2241a5d, 0xc55efe10, 0xc49c9427, 0xc6da2a7e, 0xc7184049,\n    0xc25756cc, 0xc3953cfb, 0xc1d382a2, 0xc011e895, 0xcb4dafa8,\n    0xca8fc59f, 0xc8c97bc6, 0xc90b11f1, 0xcc440774, 0xcd866d43,\n    0xcfc0d31a, 0xce02b92d, 0x91af9640, 0x906dfc77, 0x922b422e,\n    0x93e92819, 0x96a63e9c, 0x976454ab, 0x9522eaf2, 0x94e080c5,\n    0x9fbcc7f8, 0x9e7eadcf, 0x9c381396, 0x9dfa79a1, 0x98b56f24,\n    0x99770513, 0x9b31bb4a, 0x9af3d17d, 0x8d893530, 0x8c4b5f07,\n    0x8e0de15e, 0x8fcf8b69, 0x8a809dec, 0x8b42f7db, 0x89044982,\n    0x88c623b5, 0x839a6488, 0x82580ebf, 0x801eb0e6, 0x81dcdad1,\n    0x8493cc54, 0x8551a663, 0x8717183a, 0x86d5720d, 0xa9e2d0a0,\n    0xa820ba97, 0xaa6604ce, 0xaba46ef9, 0xaeeb787c, 0xaf29124b,\n    0xad6fac12, 0xacadc625, 0xa7f18118, 0xa633eb2f, 0xa4755576,\n    0xa5b73f41, 0xa0f829c4, 0xa13a43f3, 0xa37cfdaa, 0xa2be979d,\n    0xb5c473d0, 0xb40619e7, 0xb640a7be, 0xb782cd89, 0xb2cddb0c,\n    0xb30fb13b, 0xb1490f62, 0xb08b6555, 0xbbd72268, 0xba15485f,\n    0xb853f606, 0xb9919c31, 0xbcde8ab4, 0xbd1ce083, 0xbf5a5eda,\n    0xbe9834ed},\n   {0x00000000, 0x191b3141, 0x32366282, 0x2b2d53c3, 0x646cc504,\n    0x7d77f445, 0x565aa786, 0x4f4196c7, 0xc8d98a08, 0xd1c2bb49,\n    0xfaefe88a, 0xe3f4d9cb, 0xacb54f0c, 0xb5ae7e4d, 0x9e832d8e,\n    0x87981ccf, 0x4ac21251, 0x53d92310, 0x78f470d3, 0x61ef4192,\n    0x2eaed755, 0x37b5e614, 0x1c98b5d7, 0x05838496, 0x821b9859,\n    0x9b00a918, 0xb02dfadb, 0xa936cb9a, 0xe6775d5d, 0xff6c6c1c,\n    0xd4413fdf, 0xcd5a0e9e, 0x958424a2, 0x8c9f15e3, 0xa7b24620,\n    0xbea97761, 0xf1e8e1a6, 0xe8f3d0e7, 0xc3de8324, 0xdac5b265,\n    0x5d5daeaa, 0x44469feb, 0x6f6bcc28, 0x7670fd69, 0x39316bae,\n    0x202a5aef, 0x0b07092c, 0x121c386d, 0xdf4636f3, 0xc65d07b2,\n    0xed705471, 0xf46b6530, 0xbb2af3f7, 0xa231c2b6, 0x891c9175,\n    0x9007a034, 0x179fbcfb, 0x0e848dba, 0x25a9de79, 0x3cb2ef38,\n    0x73f379ff, 0x6ae848be, 0x41c51b7d, 0x58de2a3c, 0xf0794f05,\n    0xe9627e44, 0xc24f2d87, 0xdb541cc6, 0x94158a01, 0x8d0ebb40,\n    0xa623e883, 0xbf38d9c2, 0x38a0c50d, 0x21bbf44c, 0x0a96a78f,\n    0x138d96ce, 0x5ccc0009, 0x45d73148, 0x6efa628b, 0x77e153ca,\n    0xbabb5d54, 0xa3a06c15, 0x888d3fd6, 0x91960e97, 0xded79850,\n    0xc7cca911, 0xece1fad2, 0xf5facb93, 0x7262d75c, 0x6b79e61d,\n    0x4054b5de, 0x594f849f, 0x160e1258, 0x0f152319, 0x243870da,\n    0x3d23419b, 0x65fd6ba7, 0x7ce65ae6, 0x57cb0925, 0x4ed03864,\n    0x0191aea3, 0x188a9fe2, 0x33a7cc21, 0x2abcfd60, 0xad24e1af,\n    0xb43fd0ee, 0x9f12832d, 0x8609b26c, 0xc94824ab, 0xd05315ea,\n    0xfb7e4629, 0xe2657768, 0x2f3f79f6, 0x362448b7, 0x1d091b74,\n    0x04122a35, 0x4b53bcf2, 0x52488db3, 0x7965de70, 0x607eef31,\n    0xe7e6f3fe, 0xfefdc2bf, 0xd5d0917c, 0xcccba03d, 0x838a36fa,\n    0x9a9107bb, 0xb1bc5478, 0xa8a76539, 0x3b83984b, 0x2298a90a,\n    0x09b5fac9, 0x10aecb88, 0x5fef5d4f, 0x46f46c0e, 0x6dd93fcd,\n    0x74c20e8c, 0xf35a1243, 0xea412302, 0xc16c70c1, 0xd8774180,\n    0x9736d747, 0x8e2de606, 0xa500b5c5, 0xbc1b8484, 0x71418a1a,\n    0x685abb5b, 0x4377e898, 0x5a6cd9d9, 0x152d4f1e, 0x0c367e5f,\n    0x271b2d9c, 0x3e001cdd, 0xb9980012, 0xa0833153, 0x8bae6290,\n    0x92b553d1, 0xddf4c516, 0xc4eff457, 0xefc2a794, 0xf6d996d5,\n    0xae07bce9, 0xb71c8da8, 0x9c31de6b, 0x852aef2a, 0xca6b79ed,\n    0xd37048ac, 0xf85d1b6f, 0xe1462a2e, 0x66de36e1, 0x7fc507a0,\n    0x54e85463, 0x4df36522, 0x02b2f3e5, 0x1ba9c2a4, 0x30849167,\n    0x299fa026, 0xe4c5aeb8, 0xfdde9ff9, 0xd6f3cc3a, 0xcfe8fd7b,\n    0x80a96bbc, 0x99b25afd, 0xb29f093e, 0xab84387f, 0x2c1c24b0,\n    0x350715f1, 0x1e2a4632, 0x07317773, 0x4870e1b4, 0x516bd0f5,\n    0x7a468336, 0x635db277, 0xcbfad74e, 0xd2e1e60f, 0xf9ccb5cc,\n    0xe0d7848d, 0xaf96124a, 0xb68d230b, 0x9da070c8, 0x84bb4189,\n    0x03235d46, 0x1a386c07, 0x31153fc4, 0x280e0e85, 0x674f9842,\n    0x7e54a903, 0x5579fac0, 0x4c62cb81, 0x8138c51f, 0x9823f45e,\n    0xb30ea79d, 0xaa1596dc, 0xe554001b, 0xfc4f315a, 0xd7626299,\n    0xce7953d8, 0x49e14f17, 0x50fa7e56, 0x7bd72d95, 0x62cc1cd4,\n    0x2d8d8a13, 0x3496bb52, 0x1fbbe891, 0x06a0d9d0, 0x5e7ef3ec,\n    0x4765c2ad, 0x6c48916e, 0x7553a02f, 0x3a1236e8, 0x230907a9,\n    0x0824546a, 0x113f652b, 0x96a779e4, 0x8fbc48a5, 0xa4911b66,\n    0xbd8a2a27, 0xf2cbbce0, 0xebd08da1, 0xc0fdde62, 0xd9e6ef23,\n    0x14bce1bd, 0x0da7d0fc, 0x268a833f, 0x3f91b27e, 0x70d024b9,\n    0x69cb15f8, 0x42e6463b, 0x5bfd777a, 0xdc656bb5, 0xc57e5af4,\n    0xee530937, 0xf7483876, 0xb809aeb1, 0xa1129ff0, 0x8a3fcc33,\n    0x9324fd72},\n   {0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x9630077700000000, 0x2c610eee00000000,\n    0xba51099900000000, 0x19c46d0700000000, 0x8ff46a7000000000,\n    0x35a563e900000000, 0xa395649e00000000, 0x3288db0e00000000,\n    0xa4b8dc7900000000, 0x1ee9d5e000000000, 0x88d9d29700000000,\n    0x2b4cb60900000000, 0xbd7cb17e00000000, 0x072db8e700000000,\n    0x911dbf9000000000, 0x6410b71d00000000, 0xf220b06a00000000,\n    0x4871b9f300000000, 0xde41be8400000000, 0x7dd4da1a00000000,\n    0xebe4dd6d00000000, 0x51b5d4f400000000, 0xc785d38300000000,\n    0x56986c1300000000, 0xc0a86b6400000000, 0x7af962fd00000000,\n    0xecc9658a00000000, 0x4f5c011400000000, 0xd96c066300000000,\n    0x633d0ffa00000000, 0xf50d088d00000000, 0xc8206e3b00000000,\n    0x5e10694c00000000, 0xe44160d500000000, 0x727167a200000000,\n    0xd1e4033c00000000, 0x47d4044b00000000, 0xfd850dd200000000,\n    0x6bb50aa500000000, 0xfaa8b53500000000, 0x6c98b24200000000,\n    0xd6c9bbdb00000000, 0x40f9bcac00000000, 0xe36cd83200000000,\n    0x755cdf4500000000, 0xcf0dd6dc00000000, 0x593dd1ab00000000,\n    0xac30d92600000000, 0x3a00de5100000000, 0x8051d7c800000000,\n    0x1661d0bf00000000, 0xb5f4b42100000000, 0x23c4b35600000000,\n    0x9995bacf00000000, 0x0fa5bdb800000000, 0x9eb8022800000000,\n    0x0888055f00000000, 0xb2d90cc600000000, 0x24e90bb100000000,\n    0x877c6f2f00000000, 0x114c685800000000, 0xab1d61c100000000,\n    0x3d2d66b600000000, 0x9041dc7600000000, 0x0671db0100000000,\n    0xbc20d29800000000, 0x2a10d5ef00000000, 0x8985b17100000000,\n    0x1fb5b60600000000, 0xa5e4bf9f00000000, 0x33d4b8e800000000,\n    0xa2c9077800000000, 0x34f9000f00000000, 0x8ea8099600000000,\n    0x18980ee100000000, 0xbb0d6a7f00000000, 0x2d3d6d0800000000,\n    0x976c649100000000, 0x015c63e600000000, 0xf4516b6b00000000,\n    0x62616c1c00000000, 0xd830658500000000, 0x4e0062f200000000,\n    0xed95066c00000000, 0x7ba5011b00000000, 0xc1f4088200000000,\n    0x57c40ff500000000, 0xc6d9b06500000000, 0x50e9b71200000000,\n    0xeab8be8b00000000, 0x7c88b9fc00000000, 0xdf1ddd6200000000,\n    0x492dda1500000000, 0xf37cd38c00000000, 0x654cd4fb00000000,\n    0x5861b24d00000000, 0xce51b53a00000000, 0x7400bca300000000,\n    0xe230bbd400000000, 0x41a5df4a00000000, 0xd795d83d00000000,\n    0x6dc4d1a400000000, 0xfbf4d6d300000000, 0x6ae9694300000000,\n    0xfcd96e3400000000, 0x468867ad00000000, 0xd0b860da00000000,\n    0x732d044400000000, 0xe51d033300000000, 0x5f4c0aaa00000000,\n    0xc97c0ddd00000000, 0x3c71055000000000, 0xaa41022700000000,\n    0x10100bbe00000000, 0x86200cc900000000, 0x25b5685700000000,\n    0xb3856f2000000000, 0x09d466b900000000, 0x9fe461ce00000000,\n    0x0ef9de5e00000000, 0x98c9d92900000000, 0x2298d0b000000000,\n    0xb4a8d7c700000000, 0x173db35900000000, 0x810db42e00000000,\n    0x3b5cbdb700000000, 0xad6cbac000000000, 0x2083b8ed00000000,\n    0xb6b3bf9a00000000, 0x0ce2b60300000000, 0x9ad2b17400000000,\n    0x3947d5ea00000000, 0xaf77d29d00000000, 0x1526db0400000000,\n    0x8316dc7300000000, 0x120b63e300000000, 0x843b649400000000,\n    0x3e6a6d0d00000000, 0xa85a6a7a00000000, 0x0bcf0ee400000000,\n    0x9dff099300000000, 0x27ae000a00000000, 0xb19e077d00000000,\n    0x44930ff000000000, 0xd2a3088700000000, 0x68f2011e00000000,\n    0xfec2066900000000, 0x5d5762f700000000, 0xcb67658000000000,\n    0x71366c1900000000, 0xe7066b6e00000000, 0x761bd4fe00000000,\n    0xe02bd38900000000, 0x5a7ada1000000000, 0xcc4add6700000000,\n    0x6fdfb9f900000000, 0xf9efbe8e00000000, 0x43beb71700000000,\n    0xd58eb06000000000, 0xe8a3d6d600000000, 0x7e93d1a100000000,\n    0xc4c2d83800000000, 0x52f2df4f00000000, 0xf167bbd100000000,\n    0x6757bca600000000, 0xdd06b53f00000000, 0x4b36b24800000000,\n    0xda2b0dd800000000, 0x4c1b0aaf00000000, 0xf64a033600000000,\n    0x607a044100000000, 0xc3ef60df00000000, 0x55df67a800000000,\n    0xef8e6e3100000000, 0x79be694600000000, 0x8cb361cb00000000,\n    0x1a8366bc00000000, 0xa0d26f2500000000, 0x36e2685200000000,\n    0x95770ccc00000000, 0x03470bbb00000000, 0xb916022200000000,\n    0x2f26055500000000, 0xbe3bbac500000000, 0x280bbdb200000000,\n    0x925ab42b00000000, 0x046ab35c00000000, 0xa7ffd7c200000000,\n    0x31cfd0b500000000, 0x8b9ed92c00000000, 0x1daede5b00000000,\n    0xb0c2649b00000000, 0x26f263ec00000000, 0x9ca36a7500000000,\n    0x0a936d0200000000, 0xa906099c00000000, 0x3f360eeb00000000,\n    0x8567077200000000, 0x1357000500000000, 0x824abf9500000000,\n    0x147ab8e200000000, 0xae2bb17b00000000, 0x381bb60c00000000,\n    0x9b8ed29200000000, 0x0dbed5e500000000, 0xb7efdc7c00000000,\n    0x21dfdb0b00000000, 0xd4d2d38600000000, 0x42e2d4f100000000,\n    0xf8b3dd6800000000, 0x6e83da1f00000000, 0xcd16be8100000000,\n    0x5b26b9f600000000, 0xe177b06f00000000, 0x7747b71800000000,\n    0xe65a088800000000, 0x706a0fff00000000, 0xca3b066600000000,\n    0x5c0b011100000000, 0xff9e658f00000000, 0x69ae62f800000000,\n    0xd3ff6b6100000000, 0x45cf6c1600000000, 0x78e20aa000000000,\n    0xeed20dd700000000, 0x5483044e00000000, 0xc2b3033900000000,\n    0x612667a700000000, 0xf71660d000000000, 0x4d47694900000000,\n    0xdb776e3e00000000, 0x4a6ad1ae00000000, 0xdc5ad6d900000000,\n    0x660bdf4000000000, 0xf03bd83700000000, 0x53aebca900000000,\n    0xc59ebbde00000000, 0x7fcfb24700000000, 0xe9ffb53000000000,\n    0x1cf2bdbd00000000, 0x8ac2baca00000000, 0x3093b35300000000,\n    0xa6a3b42400000000, 0x0536d0ba00000000, 0x9306d7cd00000000,\n    0x2957de5400000000, 0xbf67d92300000000, 0x2e7a66b300000000,\n    0xb84a61c400000000, 0x021b685d00000000, 0x942b6f2a00000000,\n    0x37be0bb400000000, 0xa18e0cc300000000, 0x1bdf055a00000000,\n    0x8def022d00000000},\n   {0x0000000000000000, 0x41311b1900000000, 0x8262363200000000,\n    0xc3532d2b00000000, 0x04c56c6400000000, 0x45f4777d00000000,\n    0x86a75a5600000000, 0xc796414f00000000, 0x088ad9c800000000,\n    0x49bbc2d100000000, 0x8ae8effa00000000, 0xcbd9f4e300000000,\n    0x0c4fb5ac00000000, 0x4d7eaeb500000000, 0x8e2d839e00000000,\n    0xcf1c988700000000, 0x5112c24a00000000, 0x1023d95300000000,\n    0xd370f47800000000, 0x9241ef6100000000, 0x55d7ae2e00000000,\n    0x14e6b53700000000, 0xd7b5981c00000000, 0x9684830500000000,\n    0x59981b8200000000, 0x18a9009b00000000, 0xdbfa2db000000000,\n    0x9acb36a900000000, 0x5d5d77e600000000, 0x1c6c6cff00000000,\n    0xdf3f41d400000000, 0x9e0e5acd00000000, 0xa224849500000000,\n    0xe3159f8c00000000, 0x2046b2a700000000, 0x6177a9be00000000,\n    0xa6e1e8f100000000, 0xe7d0f3e800000000, 0x2483dec300000000,\n    0x65b2c5da00000000, 0xaaae5d5d00000000, 0xeb9f464400000000,\n    0x28cc6b6f00000000, 0x69fd707600000000, 0xae6b313900000000,\n    0xef5a2a2000000000, 0x2c09070b00000000, 0x6d381c1200000000,\n    0xf33646df00000000, 0xb2075dc600000000, 0x715470ed00000000,\n    0x30656bf400000000, 0xf7f32abb00000000, 0xb6c231a200000000,\n    0x75911c8900000000, 0x34a0079000000000, 0xfbbc9f1700000000,\n    0xba8d840e00000000, 0x79dea92500000000, 0x38efb23c00000000,\n    0xff79f37300000000, 0xbe48e86a00000000, 0x7d1bc54100000000,\n    0x3c2ade5800000000, 0x054f79f000000000, 0x447e62e900000000,\n    0x872d4fc200000000, 0xc61c54db00000000, 0x018a159400000000,\n    0x40bb0e8d00000000, 0x83e823a600000000, 0xc2d938bf00000000,\n    0x0dc5a03800000000, 0x4cf4bb2100000000, 0x8fa7960a00000000,\n    0xce968d1300000000, 0x0900cc5c00000000, 0x4831d74500000000,\n    0x8b62fa6e00000000, 0xca53e17700000000, 0x545dbbba00000000,\n    0x156ca0a300000000, 0xd63f8d8800000000, 0x970e969100000000,\n    0x5098d7de00000000, 0x11a9ccc700000000, 0xd2fae1ec00000000,\n    0x93cbfaf500000000, 0x5cd7627200000000, 0x1de6796b00000000,\n    0xdeb5544000000000, 0x9f844f5900000000, 0x58120e1600000000,\n    0x1923150f00000000, 0xda70382400000000, 0x9b41233d00000000,\n    0xa76bfd6500000000, 0xe65ae67c00000000, 0x2509cb5700000000,\n    0x6438d04e00000000, 0xa3ae910100000000, 0xe29f8a1800000000,\n    0x21cca73300000000, 0x60fdbc2a00000000, 0xafe124ad00000000,\n    0xeed03fb400000000, 0x2d83129f00000000, 0x6cb2098600000000,\n    0xab2448c900000000, 0xea1553d000000000, 0x29467efb00000000,\n    0x687765e200000000, 0xf6793f2f00000000, 0xb748243600000000,\n    0x741b091d00000000, 0x352a120400000000, 0xf2bc534b00000000,\n    0xb38d485200000000, 0x70de657900000000, 0x31ef7e6000000000,\n    0xfef3e6e700000000, 0xbfc2fdfe00000000, 0x7c91d0d500000000,\n    0x3da0cbcc00000000, 0xfa368a8300000000, 0xbb07919a00000000,\n    0x7854bcb100000000, 0x3965a7a800000000, 0x4b98833b00000000,\n    0x0aa9982200000000, 0xc9fab50900000000, 0x88cbae1000000000,\n    0x4f5def5f00000000, 0x0e6cf44600000000, 0xcd3fd96d00000000,\n    0x8c0ec27400000000, 0x43125af300000000, 0x022341ea00000000,\n    0xc1706cc100000000, 0x804177d800000000, 0x47d7369700000000,\n    0x06e62d8e00000000, 0xc5b500a500000000, 0x84841bbc00000000,\n    0x1a8a417100000000, 0x5bbb5a6800000000, 0x98e8774300000000,\n    0xd9d96c5a00000000, 0x1e4f2d1500000000, 0x5f7e360c00000000,\n    0x9c2d1b2700000000, 0xdd1c003e00000000, 0x120098b900000000,\n    0x533183a000000000, 0x9062ae8b00000000, 0xd153b59200000000,\n    0x16c5f4dd00000000, 0x57f4efc400000000, 0x94a7c2ef00000000,\n    0xd596d9f600000000, 0xe9bc07ae00000000, 0xa88d1cb700000000,\n    0x6bde319c00000000, 0x2aef2a8500000000, 0xed796bca00000000,\n    0xac4870d300000000, 0x6f1b5df800000000, 0x2e2a46e100000000,\n    0xe136de6600000000, 0xa007c57f00000000, 0x6354e85400000000,\n    0x2265f34d00000000, 0xe5f3b20200000000, 0xa4c2a91b00000000,\n    0x6791843000000000, 0x26a09f2900000000, 0xb8aec5e400000000,\n    0xf99fdefd00000000, 0x3accf3d600000000, 0x7bfde8cf00000000,\n    0xbc6ba98000000000, 0xfd5ab29900000000, 0x3e099fb200000000,\n    0x7f3884ab00000000, 0xb0241c2c00000000, 0xf115073500000000,\n    0x32462a1e00000000, 0x7377310700000000, 0xb4e1704800000000,\n    0xf5d06b5100000000, 0x3683467a00000000, 0x77b25d6300000000,\n    0x4ed7facb00000000, 0x0fe6e1d200000000, 0xccb5ccf900000000,\n    0x8d84d7e000000000, 0x4a1296af00000000, 0x0b238db600000000,\n    0xc870a09d00000000, 0x8941bb8400000000, 0x465d230300000000,\n    0x076c381a00000000, 0xc43f153100000000, 0x850e0e2800000000,\n    0x42984f6700000000, 0x03a9547e00000000, 0xc0fa795500000000,\n    0x81cb624c00000000, 0x1fc5388100000000, 0x5ef4239800000000,\n    0x9da70eb300000000, 0xdc9615aa00000000, 0x1b0054e500000000,\n    0x5a314ffc00000000, 0x996262d700000000, 0xd85379ce00000000,\n    0x174fe14900000000, 0x567efa5000000000, 0x952dd77b00000000,\n    0xd41ccc6200000000, 0x138a8d2d00000000, 0x52bb963400000000,\n    0x91e8bb1f00000000, 0xd0d9a00600000000, 0xecf37e5e00000000,\n    0xadc2654700000000, 0x6e91486c00000000, 0x2fa0537500000000,\n    0xe836123a00000000, 0xa907092300000000, 0x6a54240800000000,\n    0x2b653f1100000000, 0xe479a79600000000, 0xa548bc8f00000000,\n    0x661b91a400000000, 0x272a8abd00000000, 0xe0bccbf200000000,\n    0xa18dd0eb00000000, 0x62defdc000000000, 0x23efe6d900000000,\n    0xbde1bc1400000000, 0xfcd0a70d00000000, 0x3f838a2600000000,\n    0x7eb2913f00000000, 0xb924d07000000000, 0xf815cb6900000000,\n    0x3b46e64200000000, 0x7a77fd5b00000000, 0xb56b65dc00000000,\n    0xf45a7ec500000000, 0x370953ee00000000, 0x763848f700000000,\n    0xb1ae09b800000000, 0xf09f12a100000000, 0x33cc3f8a00000000,\n    0x72fd249300000000},\n   {0x0000000000000000, 0x376ac20100000000, 0x6ed4840300000000,\n    0x59be460200000000, 0xdca8090700000000, 0xebc2cb0600000000,\n    0xb27c8d0400000000, 0x85164f0500000000, 0xb851130e00000000,\n    0x8f3bd10f00000000, 0xd685970d00000000, 0xe1ef550c00000000,\n    0x64f91a0900000000, 0x5393d80800000000, 0x0a2d9e0a00000000,\n    0x3d475c0b00000000, 0x70a3261c00000000, 0x47c9e41d00000000,\n    0x1e77a21f00000000, 0x291d601e00000000, 0xac0b2f1b00000000,\n    0x9b61ed1a00000000, 0xc2dfab1800000000, 0xf5b5691900000000,\n    0xc8f2351200000000, 0xff98f71300000000, 0xa626b11100000000,\n    0x914c731000000000, 0x145a3c1500000000, 0x2330fe1400000000,\n    0x7a8eb81600000000, 0x4de47a1700000000, 0xe0464d3800000000,\n    0xd72c8f3900000000, 0x8e92c93b00000000, 0xb9f80b3a00000000,\n    0x3cee443f00000000, 0x0b84863e00000000, 0x523ac03c00000000,\n    0x6550023d00000000, 0x58175e3600000000, 0x6f7d9c3700000000,\n    0x36c3da3500000000, 0x01a9183400000000, 0x84bf573100000000,\n    0xb3d5953000000000, 0xea6bd33200000000, 0xdd01113300000000,\n    0x90e56b2400000000, 0xa78fa92500000000, 0xfe31ef2700000000,\n    0xc95b2d2600000000, 0x4c4d622300000000, 0x7b27a02200000000,\n    0x2299e62000000000, 0x15f3242100000000, 0x28b4782a00000000,\n    0x1fdeba2b00000000, 0x4660fc2900000000, 0x710a3e2800000000,\n    0xf41c712d00000000, 0xc376b32c00000000, 0x9ac8f52e00000000,\n    0xada2372f00000000, 0xc08d9a7000000000, 0xf7e7587100000000,\n    0xae591e7300000000, 0x9933dc7200000000, 0x1c25937700000000,\n    0x2b4f517600000000, 0x72f1177400000000, 0x459bd57500000000,\n    0x78dc897e00000000, 0x4fb64b7f00000000, 0x16080d7d00000000,\n    0x2162cf7c00000000, 0xa474807900000000, 0x931e427800000000,\n    0xcaa0047a00000000, 0xfdcac67b00000000, 0xb02ebc6c00000000,\n    0x87447e6d00000000, 0xdefa386f00000000, 0xe990fa6e00000000,\n    0x6c86b56b00000000, 0x5bec776a00000000, 0x0252316800000000,\n    0x3538f36900000000, 0x087faf6200000000, 0x3f156d6300000000,\n    0x66ab2b6100000000, 0x51c1e96000000000, 0xd4d7a66500000000,\n    0xe3bd646400000000, 0xba03226600000000, 0x8d69e06700000000,\n    0x20cbd74800000000, 0x17a1154900000000, 0x4e1f534b00000000,\n    0x7975914a00000000, 0xfc63de4f00000000, 0xcb091c4e00000000,\n    0x92b75a4c00000000, 0xa5dd984d00000000, 0x989ac44600000000,\n    0xaff0064700000000, 0xf64e404500000000, 0xc124824400000000,\n    0x4432cd4100000000, 0x73580f4000000000, 0x2ae6494200000000,\n    0x1d8c8b4300000000, 0x5068f15400000000, 0x6702335500000000,\n    0x3ebc755700000000, 0x09d6b75600000000, 0x8cc0f85300000000,\n    0xbbaa3a5200000000, 0xe2147c5000000000, 0xd57ebe5100000000,\n    0xe839e25a00000000, 0xdf53205b00000000, 0x86ed665900000000,\n    0xb187a45800000000, 0x3491eb5d00000000, 0x03fb295c00000000,\n    0x5a456f5e00000000, 0x6d2fad5f00000000, 0x801b35e100000000,\n    0xb771f7e000000000, 0xeecfb1e200000000, 0xd9a573e300000000,\n    0x5cb33ce600000000, 0x6bd9fee700000000, 0x3267b8e500000000,\n    0x050d7ae400000000, 0x384a26ef00000000, 0x0f20e4ee00000000,\n    0x569ea2ec00000000, 0x61f460ed00000000, 0xe4e22fe800000000,\n    0xd388ede900000000, 0x8a36abeb00000000, 0xbd5c69ea00000000,\n    0xf0b813fd00000000, 0xc7d2d1fc00000000, 0x9e6c97fe00000000,\n    0xa90655ff00000000, 0x2c101afa00000000, 0x1b7ad8fb00000000,\n    0x42c49ef900000000, 0x75ae5cf800000000, 0x48e900f300000000,\n    0x7f83c2f200000000, 0x263d84f000000000, 0x115746f100000000,\n    0x944109f400000000, 0xa32bcbf500000000, 0xfa958df700000000,\n    0xcdff4ff600000000, 0x605d78d900000000, 0x5737bad800000000,\n    0x0e89fcda00000000, 0x39e33edb00000000, 0xbcf571de00000000,\n    0x8b9fb3df00000000, 0xd221f5dd00000000, 0xe54b37dc00000000,\n    0xd80c6bd700000000, 0xef66a9d600000000, 0xb6d8efd400000000,\n    0x81b22dd500000000, 0x04a462d000000000, 0x33cea0d100000000,\n    0x6a70e6d300000000, 0x5d1a24d200000000, 0x10fe5ec500000000,\n    0x27949cc400000000, 0x7e2adac600000000, 0x494018c700000000,\n    0xcc5657c200000000, 0xfb3c95c300000000, 0xa282d3c100000000,\n    0x95e811c000000000, 0xa8af4dcb00000000, 0x9fc58fca00000000,\n    0xc67bc9c800000000, 0xf1110bc900000000, 0x740744cc00000000,\n    0x436d86cd00000000, 0x1ad3c0cf00000000, 0x2db902ce00000000,\n    0x4096af9100000000, 0x77fc6d9000000000, 0x2e422b9200000000,\n    0x1928e99300000000, 0x9c3ea69600000000, 0xab54649700000000,\n    0xf2ea229500000000, 0xc580e09400000000, 0xf8c7bc9f00000000,\n    0xcfad7e9e00000000, 0x9613389c00000000, 0xa179fa9d00000000,\n    0x246fb59800000000, 0x1305779900000000, 0x4abb319b00000000,\n    0x7dd1f39a00000000, 0x3035898d00000000, 0x075f4b8c00000000,\n    0x5ee10d8e00000000, 0x698bcf8f00000000, 0xec9d808a00000000,\n    0xdbf7428b00000000, 0x8249048900000000, 0xb523c68800000000,\n    0x88649a8300000000, 0xbf0e588200000000, 0xe6b01e8000000000,\n    0xd1dadc8100000000, 0x54cc938400000000, 0x63a6518500000000,\n    0x3a18178700000000, 0x0d72d58600000000, 0xa0d0e2a900000000,\n    0x97ba20a800000000, 0xce0466aa00000000, 0xf96ea4ab00000000,\n    0x7c78ebae00000000, 0x4b1229af00000000, 0x12ac6fad00000000,\n    0x25c6adac00000000, 0x1881f1a700000000, 0x2feb33a600000000,\n    0x765575a400000000, 0x413fb7a500000000, 0xc429f8a000000000,\n    0xf3433aa100000000, 0xaafd7ca300000000, 0x9d97bea200000000,\n    0xd073c4b500000000, 0xe71906b400000000, 0xbea740b600000000,\n    0x89cd82b700000000, 0x0cdbcdb200000000, 0x3bb10fb300000000,\n    0x620f49b100000000, 0x55658bb000000000, 0x6822d7bb00000000,\n    0x5f4815ba00000000, 0x06f653b800000000, 0x319c91b900000000,\n    0xb48adebc00000000, 0x83e01cbd00000000, 0xda5e5abf00000000,\n    0xed3498be00000000},\n   {0x0000000000000000, 0x6567bcb800000000, 0x8bc809aa00000000,\n    0xeeafb51200000000, 0x5797628f00000000, 0x32f0de3700000000,\n    0xdc5f6b2500000000, 0xb938d79d00000000, 0xef28b4c500000000,\n    0x8a4f087d00000000, 0x64e0bd6f00000000, 0x018701d700000000,\n    0xb8bfd64a00000000, 0xddd86af200000000, 0x3377dfe000000000,\n    0x5610635800000000, 0x9f57195000000000, 0xfa30a5e800000000,\n    0x149f10fa00000000, 0x71f8ac4200000000, 0xc8c07bdf00000000,\n    0xada7c76700000000, 0x4308727500000000, 0x266fcecd00000000,\n    0x707fad9500000000, 0x1518112d00000000, 0xfbb7a43f00000000,\n    0x9ed0188700000000, 0x27e8cf1a00000000, 0x428f73a200000000,\n    0xac20c6b000000000, 0xc9477a0800000000, 0x3eaf32a000000000,\n    0x5bc88e1800000000, 0xb5673b0a00000000, 0xd00087b200000000,\n    0x6938502f00000000, 0x0c5fec9700000000, 0xe2f0598500000000,\n    0x8797e53d00000000, 0xd187866500000000, 0xb4e03add00000000,\n    0x5a4f8fcf00000000, 0x3f28337700000000, 0x8610e4ea00000000,\n    0xe377585200000000, 0x0dd8ed4000000000, 0x68bf51f800000000,\n    0xa1f82bf000000000, 0xc49f974800000000, 0x2a30225a00000000,\n    0x4f579ee200000000, 0xf66f497f00000000, 0x9308f5c700000000,\n    0x7da740d500000000, 0x18c0fc6d00000000, 0x4ed09f3500000000,\n    0x2bb7238d00000000, 0xc518969f00000000, 0xa07f2a2700000000,\n    0x1947fdba00000000, 0x7c20410200000000, 0x928ff41000000000,\n    0xf7e848a800000000, 0x3d58149b00000000, 0x583fa82300000000,\n    0xb6901d3100000000, 0xd3f7a18900000000, 0x6acf761400000000,\n    0x0fa8caac00000000, 0xe1077fbe00000000, 0x8460c30600000000,\n    0xd270a05e00000000, 0xb7171ce600000000, 0x59b8a9f400000000,\n    0x3cdf154c00000000, 0x85e7c2d100000000, 0xe0807e6900000000,\n    0x0e2fcb7b00000000, 0x6b4877c300000000, 0xa20f0dcb00000000,\n    0xc768b17300000000, 0x29c7046100000000, 0x4ca0b8d900000000,\n    0xf5986f4400000000, 0x90ffd3fc00000000, 0x7e5066ee00000000,\n    0x1b37da5600000000, 0x4d27b90e00000000, 0x284005b600000000,\n    0xc6efb0a400000000, 0xa3880c1c00000000, 0x1ab0db8100000000,\n    0x7fd7673900000000, 0x9178d22b00000000, 0xf41f6e9300000000,\n    0x03f7263b00000000, 0x66909a8300000000, 0x883f2f9100000000,\n    0xed58932900000000, 0x546044b400000000, 0x3107f80c00000000,\n    0xdfa84d1e00000000, 0xbacff1a600000000, 0xecdf92fe00000000,\n    0x89b82e4600000000, 0x67179b5400000000, 0x027027ec00000000,\n    0xbb48f07100000000, 0xde2f4cc900000000, 0x3080f9db00000000,\n    0x55e7456300000000, 0x9ca03f6b00000000, 0xf9c783d300000000,\n    0x176836c100000000, 0x720f8a7900000000, 0xcb375de400000000,\n    0xae50e15c00000000, 0x40ff544e00000000, 0x2598e8f600000000,\n    0x73888bae00000000, 0x16ef371600000000, 0xf840820400000000,\n    0x9d273ebc00000000, 0x241fe92100000000, 0x4178559900000000,\n    0xafd7e08b00000000, 0xcab05c3300000000, 0x3bb659ed00000000,\n    0x5ed1e55500000000, 0xb07e504700000000, 0xd519ecff00000000,\n    0x6c213b6200000000, 0x094687da00000000, 0xe7e932c800000000,\n    0x828e8e7000000000, 0xd49eed2800000000, 0xb1f9519000000000,\n    0x5f56e48200000000, 0x3a31583a00000000, 0x83098fa700000000,\n    0xe66e331f00000000, 0x08c1860d00000000, 0x6da63ab500000000,\n    0xa4e140bd00000000, 0xc186fc0500000000, 0x2f29491700000000,\n    0x4a4ef5af00000000, 0xf376223200000000, 0x96119e8a00000000,\n    0x78be2b9800000000, 0x1dd9972000000000, 0x4bc9f47800000000,\n    0x2eae48c000000000, 0xc001fdd200000000, 0xa566416a00000000,\n    0x1c5e96f700000000, 0x79392a4f00000000, 0x97969f5d00000000,\n    0xf2f123e500000000, 0x05196b4d00000000, 0x607ed7f500000000,\n    0x8ed162e700000000, 0xebb6de5f00000000, 0x528e09c200000000,\n    0x37e9b57a00000000, 0xd946006800000000, 0xbc21bcd000000000,\n    0xea31df8800000000, 0x8f56633000000000, 0x61f9d62200000000,\n    0x049e6a9a00000000, 0xbda6bd0700000000, 0xd8c101bf00000000,\n    0x366eb4ad00000000, 0x5309081500000000, 0x9a4e721d00000000,\n    0xff29cea500000000, 0x11867bb700000000, 0x74e1c70f00000000,\n    0xcdd9109200000000, 0xa8beac2a00000000, 0x4611193800000000,\n    0x2376a58000000000, 0x7566c6d800000000, 0x10017a6000000000,\n    0xfeaecf7200000000, 0x9bc973ca00000000, 0x22f1a45700000000,\n    0x479618ef00000000, 0xa939adfd00000000, 0xcc5e114500000000,\n    0x06ee4d7600000000, 0x6389f1ce00000000, 0x8d2644dc00000000,\n    0xe841f86400000000, 0x51792ff900000000, 0x341e934100000000,\n    0xdab1265300000000, 0xbfd69aeb00000000, 0xe9c6f9b300000000,\n    0x8ca1450b00000000, 0x620ef01900000000, 0x07694ca100000000,\n    0xbe519b3c00000000, 0xdb36278400000000, 0x3599929600000000,\n    0x50fe2e2e00000000, 0x99b9542600000000, 0xfcdee89e00000000,\n    0x12715d8c00000000, 0x7716e13400000000, 0xce2e36a900000000,\n    0xab498a1100000000, 0x45e63f0300000000, 0x208183bb00000000,\n    0x7691e0e300000000, 0x13f65c5b00000000, 0xfd59e94900000000,\n    0x983e55f100000000, 0x2106826c00000000, 0x44613ed400000000,\n    0xaace8bc600000000, 0xcfa9377e00000000, 0x38417fd600000000,\n    0x5d26c36e00000000, 0xb389767c00000000, 0xd6eecac400000000,\n    0x6fd61d5900000000, 0x0ab1a1e100000000, 0xe41e14f300000000,\n    0x8179a84b00000000, 0xd769cb1300000000, 0xb20e77ab00000000,\n    0x5ca1c2b900000000, 0x39c67e0100000000, 0x80fea99c00000000,\n    0xe599152400000000, 0x0b36a03600000000, 0x6e511c8e00000000,\n    0xa716668600000000, 0xc271da3e00000000, 0x2cde6f2c00000000,\n    0x49b9d39400000000, 0xf081040900000000, 0x95e6b8b100000000,\n    0x7b490da300000000, 0x1e2eb11b00000000, 0x483ed24300000000,\n    0x2d596efb00000000, 0xc3f6dbe900000000, 0xa691675100000000,\n    0x1fa9b0cc00000000, 0x7ace0c7400000000, 0x9461b96600000000,\n    0xf10605de00000000},\n   {0x0000000000000000, 0xb029603d00000000, 0x6053c07a00000000,\n    0xd07aa04700000000, 0xc0a680f500000000, 0x708fe0c800000000,\n    0xa0f5408f00000000, 0x10dc20b200000000, 0xc14b703000000000,\n    0x7162100d00000000, 0xa118b04a00000000, 0x1131d07700000000,\n    0x01edf0c500000000, 0xb1c490f800000000, 0x61be30bf00000000,\n    0xd197508200000000, 0x8297e06000000000, 0x32be805d00000000,\n    0xe2c4201a00000000, 0x52ed402700000000, 0x4231609500000000,\n    0xf21800a800000000, 0x2262a0ef00000000, 0x924bc0d200000000,\n    0x43dc905000000000, 0xf3f5f06d00000000, 0x238f502a00000000,\n    0x93a6301700000000, 0x837a10a500000000, 0x3353709800000000,\n    0xe329d0df00000000, 0x5300b0e200000000, 0x042fc1c100000000,\n    0xb406a1fc00000000, 0x647c01bb00000000, 0xd455618600000000,\n    0xc489413400000000, 0x74a0210900000000, 0xa4da814e00000000,\n    0x14f3e17300000000, 0xc564b1f100000000, 0x754dd1cc00000000,\n    0xa537718b00000000, 0x151e11b600000000, 0x05c2310400000000,\n    0xb5eb513900000000, 0x6591f17e00000000, 0xd5b8914300000000,\n    0x86b821a100000000, 0x3691419c00000000, 0xe6ebe1db00000000,\n    0x56c281e600000000, 0x461ea15400000000, 0xf637c16900000000,\n    0x264d612e00000000, 0x9664011300000000, 0x47f3519100000000,\n    0xf7da31ac00000000, 0x27a091eb00000000, 0x9789f1d600000000,\n    0x8755d16400000000, 0x377cb15900000000, 0xe706111e00000000,\n    0x572f712300000000, 0x4958f35800000000, 0xf971936500000000,\n    0x290b332200000000, 0x9922531f00000000, 0x89fe73ad00000000,\n    0x39d7139000000000, 0xe9adb3d700000000, 0x5984d3ea00000000,\n    0x8813836800000000, 0x383ae35500000000, 0xe840431200000000,\n    0x5869232f00000000, 0x48b5039d00000000, 0xf89c63a000000000,\n    0x28e6c3e700000000, 0x98cfa3da00000000, 0xcbcf133800000000,\n    0x7be6730500000000, 0xab9cd34200000000, 0x1bb5b37f00000000,\n    0x0b6993cd00000000, 0xbb40f3f000000000, 0x6b3a53b700000000,\n    0xdb13338a00000000, 0x0a84630800000000, 0xbaad033500000000,\n    0x6ad7a37200000000, 0xdafec34f00000000, 0xca22e3fd00000000,\n    0x7a0b83c000000000, 0xaa71238700000000, 0x1a5843ba00000000,\n    0x4d77329900000000, 0xfd5e52a400000000, 0x2d24f2e300000000,\n    0x9d0d92de00000000, 0x8dd1b26c00000000, 0x3df8d25100000000,\n    0xed82721600000000, 0x5dab122b00000000, 0x8c3c42a900000000,\n    0x3c15229400000000, 0xec6f82d300000000, 0x5c46e2ee00000000,\n    0x4c9ac25c00000000, 0xfcb3a26100000000, 0x2cc9022600000000,\n    0x9ce0621b00000000, 0xcfe0d2f900000000, 0x7fc9b2c400000000,\n    0xafb3128300000000, 0x1f9a72be00000000, 0x0f46520c00000000,\n    0xbf6f323100000000, 0x6f15927600000000, 0xdf3cf24b00000000,\n    0x0eaba2c900000000, 0xbe82c2f400000000, 0x6ef862b300000000,\n    0xded1028e00000000, 0xce0d223c00000000, 0x7e24420100000000,\n    0xae5ee24600000000, 0x1e77827b00000000, 0x92b0e6b100000000,\n    0x2299868c00000000, 0xf2e326cb00000000, 0x42ca46f600000000,\n    0x5216664400000000, 0xe23f067900000000, 0x3245a63e00000000,\n    0x826cc60300000000, 0x53fb968100000000, 0xe3d2f6bc00000000,\n    0x33a856fb00000000, 0x838136c600000000, 0x935d167400000000,\n    0x2374764900000000, 0xf30ed60e00000000, 0x4327b63300000000,\n    0x102706d100000000, 0xa00e66ec00000000, 0x7074c6ab00000000,\n    0xc05da69600000000, 0xd081862400000000, 0x60a8e61900000000,\n    0xb0d2465e00000000, 0x00fb266300000000, 0xd16c76e100000000,\n    0x614516dc00000000, 0xb13fb69b00000000, 0x0116d6a600000000,\n    0x11caf61400000000, 0xa1e3962900000000, 0x7199366e00000000,\n    0xc1b0565300000000, 0x969f277000000000, 0x26b6474d00000000,\n    0xf6cce70a00000000, 0x46e5873700000000, 0x5639a78500000000,\n    0xe610c7b800000000, 0x366a67ff00000000, 0x864307c200000000,\n    0x57d4574000000000, 0xe7fd377d00000000, 0x3787973a00000000,\n    0x87aef70700000000, 0x9772d7b500000000, 0x275bb78800000000,\n    0xf72117cf00000000, 0x470877f200000000, 0x1408c71000000000,\n    0xa421a72d00000000, 0x745b076a00000000, 0xc472675700000000,\n    0xd4ae47e500000000, 0x648727d800000000, 0xb4fd879f00000000,\n    0x04d4e7a200000000, 0xd543b72000000000, 0x656ad71d00000000,\n    0xb510775a00000000, 0x0539176700000000, 0x15e537d500000000,\n    0xa5cc57e800000000, 0x75b6f7af00000000, 0xc59f979200000000,\n    0xdbe815e900000000, 0x6bc175d400000000, 0xbbbbd59300000000,\n    0x0b92b5ae00000000, 0x1b4e951c00000000, 0xab67f52100000000,\n    0x7b1d556600000000, 0xcb34355b00000000, 0x1aa365d900000000,\n    0xaa8a05e400000000, 0x7af0a5a300000000, 0xcad9c59e00000000,\n    0xda05e52c00000000, 0x6a2c851100000000, 0xba56255600000000,\n    0x0a7f456b00000000, 0x597ff58900000000, 0xe95695b400000000,\n    0x392c35f300000000, 0x890555ce00000000, 0x99d9757c00000000,\n    0x29f0154100000000, 0xf98ab50600000000, 0x49a3d53b00000000,\n    0x983485b900000000, 0x281de58400000000, 0xf86745c300000000,\n    0x484e25fe00000000, 0x5892054c00000000, 0xe8bb657100000000,\n    0x38c1c53600000000, 0x88e8a50b00000000, 0xdfc7d42800000000,\n    0x6feeb41500000000, 0xbf94145200000000, 0x0fbd746f00000000,\n    0x1f6154dd00000000, 0xaf4834e000000000, 0x7f3294a700000000,\n    0xcf1bf49a00000000, 0x1e8ca41800000000, 0xaea5c42500000000,\n    0x7edf646200000000, 0xcef6045f00000000, 0xde2a24ed00000000,\n    0x6e0344d000000000, 0xbe79e49700000000, 0x0e5084aa00000000,\n    0x5d50344800000000, 0xed79547500000000, 0x3d03f43200000000,\n    0x8d2a940f00000000, 0x9df6b4bd00000000, 0x2ddfd48000000000,\n    0xfda574c700000000, 0x4d8c14fa00000000, 0x9c1b447800000000,\n    0x2c32244500000000, 0xfc48840200000000, 0x4c61e43f00000000,\n    0x5cbdc48d00000000, 0xec94a4b000000000, 0x3cee04f700000000,\n    0x8cc764ca00000000},\n   {0x0000000000000000, 0xa5d35ccb00000000, 0x0ba1c84d00000000,\n    0xae72948600000000, 0x1642919b00000000, 0xb391cd5000000000,\n    0x1de359d600000000, 0xb830051d00000000, 0x6d8253ec00000000,\n    0xc8510f2700000000, 0x66239ba100000000, 0xc3f0c76a00000000,\n    0x7bc0c27700000000, 0xde139ebc00000000, 0x70610a3a00000000,\n    0xd5b256f100000000, 0x9b02d60300000000, 0x3ed18ac800000000,\n    0x90a31e4e00000000, 0x3570428500000000, 0x8d40479800000000,\n    0x28931b5300000000, 0x86e18fd500000000, 0x2332d31e00000000,\n    0xf68085ef00000000, 0x5353d92400000000, 0xfd214da200000000,\n    0x58f2116900000000, 0xe0c2147400000000, 0x451148bf00000000,\n    0xeb63dc3900000000, 0x4eb080f200000000, 0x3605ac0700000000,\n    0x93d6f0cc00000000, 0x3da4644a00000000, 0x9877388100000000,\n    0x20473d9c00000000, 0x8594615700000000, 0x2be6f5d100000000,\n    0x8e35a91a00000000, 0x5b87ffeb00000000, 0xfe54a32000000000,\n    0x502637a600000000, 0xf5f56b6d00000000, 0x4dc56e7000000000,\n    0xe81632bb00000000, 0x4664a63d00000000, 0xe3b7faf600000000,\n    0xad077a0400000000, 0x08d426cf00000000, 0xa6a6b24900000000,\n    0x0375ee8200000000, 0xbb45eb9f00000000, 0x1e96b75400000000,\n    0xb0e423d200000000, 0x15377f1900000000, 0xc08529e800000000,\n    0x6556752300000000, 0xcb24e1a500000000, 0x6ef7bd6e00000000,\n    0xd6c7b87300000000, 0x7314e4b800000000, 0xdd66703e00000000,\n    0x78b52cf500000000, 0x6c0a580f00000000, 0xc9d904c400000000,\n    0x67ab904200000000, 0xc278cc8900000000, 0x7a48c99400000000,\n    0xdf9b955f00000000, 0x71e901d900000000, 0xd43a5d1200000000,\n    0x01880be300000000, 0xa45b572800000000, 0x0a29c3ae00000000,\n    0xaffa9f6500000000, 0x17ca9a7800000000, 0xb219c6b300000000,\n    0x1c6b523500000000, 0xb9b80efe00000000, 0xf7088e0c00000000,\n    0x52dbd2c700000000, 0xfca9464100000000, 0x597a1a8a00000000,\n    0xe14a1f9700000000, 0x4499435c00000000, 0xeaebd7da00000000,\n    0x4f388b1100000000, 0x9a8adde000000000, 0x3f59812b00000000,\n    0x912b15ad00000000, 0x34f8496600000000, 0x8cc84c7b00000000,\n    0x291b10b000000000, 0x8769843600000000, 0x22bad8fd00000000,\n    0x5a0ff40800000000, 0xffdca8c300000000, 0x51ae3c4500000000,\n    0xf47d608e00000000, 0x4c4d659300000000, 0xe99e395800000000,\n    0x47ecadde00000000, 0xe23ff11500000000, 0x378da7e400000000,\n    0x925efb2f00000000, 0x3c2c6fa900000000, 0x99ff336200000000,\n    0x21cf367f00000000, 0x841c6ab400000000, 0x2a6efe3200000000,\n    0x8fbda2f900000000, 0xc10d220b00000000, 0x64de7ec000000000,\n    0xcaacea4600000000, 0x6f7fb68d00000000, 0xd74fb39000000000,\n    0x729cef5b00000000, 0xdcee7bdd00000000, 0x793d271600000000,\n    0xac8f71e700000000, 0x095c2d2c00000000, 0xa72eb9aa00000000,\n    0x02fde56100000000, 0xbacde07c00000000, 0x1f1ebcb700000000,\n    0xb16c283100000000, 0x14bf74fa00000000, 0xd814b01e00000000,\n    0x7dc7ecd500000000, 0xd3b5785300000000, 0x7666249800000000,\n    0xce56218500000000, 0x6b857d4e00000000, 0xc5f7e9c800000000,\n    0x6024b50300000000, 0xb596e3f200000000, 0x1045bf3900000000,\n    0xbe372bbf00000000, 0x1be4777400000000, 0xa3d4726900000000,\n    0x06072ea200000000, 0xa875ba2400000000, 0x0da6e6ef00000000,\n    0x4316661d00000000, 0xe6c53ad600000000, 0x48b7ae5000000000,\n    0xed64f29b00000000, 0x5554f78600000000, 0xf087ab4d00000000,\n    0x5ef53fcb00000000, 0xfb26630000000000, 0x2e9435f100000000,\n    0x8b47693a00000000, 0x2535fdbc00000000, 0x80e6a17700000000,\n    0x38d6a46a00000000, 0x9d05f8a100000000, 0x33776c2700000000,\n    0x96a430ec00000000, 0xee111c1900000000, 0x4bc240d200000000,\n    0xe5b0d45400000000, 0x4063889f00000000, 0xf8538d8200000000,\n    0x5d80d14900000000, 0xf3f245cf00000000, 0x5621190400000000,\n    0x83934ff500000000, 0x2640133e00000000, 0x883287b800000000,\n    0x2de1db7300000000, 0x95d1de6e00000000, 0x300282a500000000,\n    0x9e70162300000000, 0x3ba34ae800000000, 0x7513ca1a00000000,\n    0xd0c096d100000000, 0x7eb2025700000000, 0xdb615e9c00000000,\n    0x63515b8100000000, 0xc682074a00000000, 0x68f093cc00000000,\n    0xcd23cf0700000000, 0x189199f600000000, 0xbd42c53d00000000,\n    0x133051bb00000000, 0xb6e30d7000000000, 0x0ed3086d00000000,\n    0xab0054a600000000, 0x0572c02000000000, 0xa0a19ceb00000000,\n    0xb41ee81100000000, 0x11cdb4da00000000, 0xbfbf205c00000000,\n    0x1a6c7c9700000000, 0xa25c798a00000000, 0x078f254100000000,\n    0xa9fdb1c700000000, 0x0c2eed0c00000000, 0xd99cbbfd00000000,\n    0x7c4fe73600000000, 0xd23d73b000000000, 0x77ee2f7b00000000,\n    0xcfde2a6600000000, 0x6a0d76ad00000000, 0xc47fe22b00000000,\n    0x61acbee000000000, 0x2f1c3e1200000000, 0x8acf62d900000000,\n    0x24bdf65f00000000, 0x816eaa9400000000, 0x395eaf8900000000,\n    0x9c8df34200000000, 0x32ff67c400000000, 0x972c3b0f00000000,\n    0x429e6dfe00000000, 0xe74d313500000000, 0x493fa5b300000000,\n    0xececf97800000000, 0x54dcfc6500000000, 0xf10fa0ae00000000,\n    0x5f7d342800000000, 0xfaae68e300000000, 0x821b441600000000,\n    0x27c818dd00000000, 0x89ba8c5b00000000, 0x2c69d09000000000,\n    0x9459d58d00000000, 0x318a894600000000, 0x9ff81dc000000000,\n    0x3a2b410b00000000, 0xef9917fa00000000, 0x4a4a4b3100000000,\n    0xe438dfb700000000, 0x41eb837c00000000, 0xf9db866100000000,\n    0x5c08daaa00000000, 0xf27a4e2c00000000, 0x57a912e700000000,\n    0x1919921500000000, 0xbccacede00000000, 0x12b85a5800000000,\n    0xb76b069300000000, 0x0f5b038e00000000, 0xaa885f4500000000,\n    0x04facbc300000000, 0xa129970800000000, 0x749bc1f900000000,\n    0xd1489d3200000000, 0x7f3a09b400000000, 0xdae9557f00000000,\n    0x62d9506200000000, 0xc70a0ca900000000, 0x6978982f00000000,\n    0xccabc4e400000000},\n   {0x0000000000000000, 0xb40b77a600000000, 0x29119f9700000000,\n    0x9d1ae83100000000, 0x13244ff400000000, 0xa72f385200000000,\n    0x3a35d06300000000, 0x8e3ea7c500000000, 0x674eef3300000000,\n    0xd345989500000000, 0x4e5f70a400000000, 0xfa54070200000000,\n    0x746aa0c700000000, 0xc061d76100000000, 0x5d7b3f5000000000,\n    0xe97048f600000000, 0xce9cde6700000000, 0x7a97a9c100000000,\n    0xe78d41f000000000, 0x5386365600000000, 0xddb8919300000000,\n    0x69b3e63500000000, 0xf4a90e0400000000, 0x40a279a200000000,\n    0xa9d2315400000000, 0x1dd946f200000000, 0x80c3aec300000000,\n    0x34c8d96500000000, 0xbaf67ea000000000, 0x0efd090600000000,\n    0x93e7e13700000000, 0x27ec969100000000, 0x9c39bdcf00000000,\n    0x2832ca6900000000, 0xb528225800000000, 0x012355fe00000000,\n    0x8f1df23b00000000, 0x3b16859d00000000, 0xa60c6dac00000000,\n    0x12071a0a00000000, 0xfb7752fc00000000, 0x4f7c255a00000000,\n    0xd266cd6b00000000, 0x666dbacd00000000, 0xe8531d0800000000,\n    0x5c586aae00000000, 0xc142829f00000000, 0x7549f53900000000,\n    0x52a563a800000000, 0xe6ae140e00000000, 0x7bb4fc3f00000000,\n    0xcfbf8b9900000000, 0x41812c5c00000000, 0xf58a5bfa00000000,\n    0x6890b3cb00000000, 0xdc9bc46d00000000, 0x35eb8c9b00000000,\n    0x81e0fb3d00000000, 0x1cfa130c00000000, 0xa8f164aa00000000,\n    0x26cfc36f00000000, 0x92c4b4c900000000, 0x0fde5cf800000000,\n    0xbbd52b5e00000000, 0x79750b4400000000, 0xcd7e7ce200000000,\n    0x506494d300000000, 0xe46fe37500000000, 0x6a5144b000000000,\n    0xde5a331600000000, 0x4340db2700000000, 0xf74bac8100000000,\n    0x1e3be47700000000, 0xaa3093d100000000, 0x372a7be000000000,\n    0x83210c4600000000, 0x0d1fab8300000000, 0xb914dc2500000000,\n    0x240e341400000000, 0x900543b200000000, 0xb7e9d52300000000,\n    0x03e2a28500000000, 0x9ef84ab400000000, 0x2af33d1200000000,\n    0xa4cd9ad700000000, 0x10c6ed7100000000, 0x8ddc054000000000,\n    0x39d772e600000000, 0xd0a73a1000000000, 0x64ac4db600000000,\n    0xf9b6a58700000000, 0x4dbdd22100000000, 0xc38375e400000000,\n    0x7788024200000000, 0xea92ea7300000000, 0x5e999dd500000000,\n    0xe54cb68b00000000, 0x5147c12d00000000, 0xcc5d291c00000000,\n    0x78565eba00000000, 0xf668f97f00000000, 0x42638ed900000000,\n    0xdf7966e800000000, 0x6b72114e00000000, 0x820259b800000000,\n    0x36092e1e00000000, 0xab13c62f00000000, 0x1f18b18900000000,\n    0x9126164c00000000, 0x252d61ea00000000, 0xb83789db00000000,\n    0x0c3cfe7d00000000, 0x2bd068ec00000000, 0x9fdb1f4a00000000,\n    0x02c1f77b00000000, 0xb6ca80dd00000000, 0x38f4271800000000,\n    0x8cff50be00000000, 0x11e5b88f00000000, 0xa5eecf2900000000,\n    0x4c9e87df00000000, 0xf895f07900000000, 0x658f184800000000,\n    0xd1846fee00000000, 0x5fbac82b00000000, 0xebb1bf8d00000000,\n    0x76ab57bc00000000, 0xc2a0201a00000000, 0xf2ea168800000000,\n    0x46e1612e00000000, 0xdbfb891f00000000, 0x6ff0feb900000000,\n    0xe1ce597c00000000, 0x55c52eda00000000, 0xc8dfc6eb00000000,\n    0x7cd4b14d00000000, 0x95a4f9bb00000000, 0x21af8e1d00000000,\n    0xbcb5662c00000000, 0x08be118a00000000, 0x8680b64f00000000,\n    0x328bc1e900000000, 0xaf9129d800000000, 0x1b9a5e7e00000000,\n    0x3c76c8ef00000000, 0x887dbf4900000000, 0x1567577800000000,\n    0xa16c20de00000000, 0x2f52871b00000000, 0x9b59f0bd00000000,\n    0x0643188c00000000, 0xb2486f2a00000000, 0x5b3827dc00000000,\n    0xef33507a00000000, 0x7229b84b00000000, 0xc622cfed00000000,\n    0x481c682800000000, 0xfc171f8e00000000, 0x610df7bf00000000,\n    0xd506801900000000, 0x6ed3ab4700000000, 0xdad8dce100000000,\n    0x47c234d000000000, 0xf3c9437600000000, 0x7df7e4b300000000,\n    0xc9fc931500000000, 0x54e67b2400000000, 0xe0ed0c8200000000,\n    0x099d447400000000, 0xbd9633d200000000, 0x208cdbe300000000,\n    0x9487ac4500000000, 0x1ab90b8000000000, 0xaeb27c2600000000,\n    0x33a8941700000000, 0x87a3e3b100000000, 0xa04f752000000000,\n    0x1444028600000000, 0x895eeab700000000, 0x3d559d1100000000,\n    0xb36b3ad400000000, 0x07604d7200000000, 0x9a7aa54300000000,\n    0x2e71d2e500000000, 0xc7019a1300000000, 0x730aedb500000000,\n    0xee10058400000000, 0x5a1b722200000000, 0xd425d5e700000000,\n    0x602ea24100000000, 0xfd344a7000000000, 0x493f3dd600000000,\n    0x8b9f1dcc00000000, 0x3f946a6a00000000, 0xa28e825b00000000,\n    0x1685f5fd00000000, 0x98bb523800000000, 0x2cb0259e00000000,\n    0xb1aacdaf00000000, 0x05a1ba0900000000, 0xecd1f2ff00000000,\n    0x58da855900000000, 0xc5c06d6800000000, 0x71cb1ace00000000,\n    0xfff5bd0b00000000, 0x4bfecaad00000000, 0xd6e4229c00000000,\n    0x62ef553a00000000, 0x4503c3ab00000000, 0xf108b40d00000000,\n    0x6c125c3c00000000, 0xd8192b9a00000000, 0x56278c5f00000000,\n    0xe22cfbf900000000, 0x7f3613c800000000, 0xcb3d646e00000000,\n    0x224d2c9800000000, 0x96465b3e00000000, 0x0b5cb30f00000000,\n    0xbf57c4a900000000, 0x3169636c00000000, 0x856214ca00000000,\n    0x1878fcfb00000000, 0xac738b5d00000000, 0x17a6a00300000000,\n    0xa3add7a500000000, 0x3eb73f9400000000, 0x8abc483200000000,\n    0x0482eff700000000, 0xb089985100000000, 0x2d93706000000000,\n    0x999807c600000000, 0x70e84f3000000000, 0xc4e3389600000000,\n    0x59f9d0a700000000, 0xedf2a70100000000, 0x63cc00c400000000,\n    0xd7c7776200000000, 0x4add9f5300000000, 0xfed6e8f500000000,\n    0xd93a7e6400000000, 0x6d3109c200000000, 0xf02be1f300000000,\n    0x4420965500000000, 0xca1e319000000000, 0x7e15463600000000,\n    0xe30fae0700000000, 0x5704d9a100000000, 0xbe74915700000000,\n    0x0a7fe6f100000000, 0x97650ec000000000, 0x236e796600000000,\n    0xad50dea300000000, 0x195ba90500000000, 0x8441413400000000,\n    0x304a369200000000},\n   {0x0000000000000000, 0x9e00aacc00000000, 0x7d07254200000000,\n    0xe3078f8e00000000, 0xfa0e4a8400000000, 0x640ee04800000000,\n    0x87096fc600000000, 0x1909c50a00000000, 0xb51be5d300000000,\n    0x2b1b4f1f00000000, 0xc81cc09100000000, 0x561c6a5d00000000,\n    0x4f15af5700000000, 0xd115059b00000000, 0x32128a1500000000,\n    0xac1220d900000000, 0x2b31bb7c00000000, 0xb53111b000000000,\n    0x56369e3e00000000, 0xc83634f200000000, 0xd13ff1f800000000,\n    0x4f3f5b3400000000, 0xac38d4ba00000000, 0x32387e7600000000,\n    0x9e2a5eaf00000000, 0x002af46300000000, 0xe32d7bed00000000,\n    0x7d2dd12100000000, 0x6424142b00000000, 0xfa24bee700000000,\n    0x1923316900000000, 0x87239ba500000000, 0x566276f900000000,\n    0xc862dc3500000000, 0x2b6553bb00000000, 0xb565f97700000000,\n    0xac6c3c7d00000000, 0x326c96b100000000, 0xd16b193f00000000,\n    0x4f6bb3f300000000, 0xe379932a00000000, 0x7d7939e600000000,\n    0x9e7eb66800000000, 0x007e1ca400000000, 0x1977d9ae00000000,\n    0x8777736200000000, 0x6470fcec00000000, 0xfa70562000000000,\n    0x7d53cd8500000000, 0xe353674900000000, 0x0054e8c700000000,\n    0x9e54420b00000000, 0x875d870100000000, 0x195d2dcd00000000,\n    0xfa5aa24300000000, 0x645a088f00000000, 0xc848285600000000,\n    0x5648829a00000000, 0xb54f0d1400000000, 0x2b4fa7d800000000,\n    0x324662d200000000, 0xac46c81e00000000, 0x4f41479000000000,\n    0xd141ed5c00000000, 0xedc29d2900000000, 0x73c237e500000000,\n    0x90c5b86b00000000, 0x0ec512a700000000, 0x17ccd7ad00000000,\n    0x89cc7d6100000000, 0x6acbf2ef00000000, 0xf4cb582300000000,\n    0x58d978fa00000000, 0xc6d9d23600000000, 0x25de5db800000000,\n    0xbbdef77400000000, 0xa2d7327e00000000, 0x3cd798b200000000,\n    0xdfd0173c00000000, 0x41d0bdf000000000, 0xc6f3265500000000,\n    0x58f38c9900000000, 0xbbf4031700000000, 0x25f4a9db00000000,\n    0x3cfd6cd100000000, 0xa2fdc61d00000000, 0x41fa499300000000,\n    0xdffae35f00000000, 0x73e8c38600000000, 0xede8694a00000000,\n    0x0eefe6c400000000, 0x90ef4c0800000000, 0x89e6890200000000,\n    0x17e623ce00000000, 0xf4e1ac4000000000, 0x6ae1068c00000000,\n    0xbba0ebd000000000, 0x25a0411c00000000, 0xc6a7ce9200000000,\n    0x58a7645e00000000, 0x41aea15400000000, 0xdfae0b9800000000,\n    0x3ca9841600000000, 0xa2a92eda00000000, 0x0ebb0e0300000000,\n    0x90bba4cf00000000, 0x73bc2b4100000000, 0xedbc818d00000000,\n    0xf4b5448700000000, 0x6ab5ee4b00000000, 0x89b261c500000000,\n    0x17b2cb0900000000, 0x909150ac00000000, 0x0e91fa6000000000,\n    0xed9675ee00000000, 0x7396df2200000000, 0x6a9f1a2800000000,\n    0xf49fb0e400000000, 0x17983f6a00000000, 0x899895a600000000,\n    0x258ab57f00000000, 0xbb8a1fb300000000, 0x588d903d00000000,\n    0xc68d3af100000000, 0xdf84fffb00000000, 0x4184553700000000,\n    0xa283dab900000000, 0x3c83707500000000, 0xda853b5300000000,\n    0x4485919f00000000, 0xa7821e1100000000, 0x3982b4dd00000000,\n    0x208b71d700000000, 0xbe8bdb1b00000000, 0x5d8c549500000000,\n    0xc38cfe5900000000, 0x6f9ede8000000000, 0xf19e744c00000000,\n    0x1299fbc200000000, 0x8c99510e00000000, 0x9590940400000000,\n    0x0b903ec800000000, 0xe897b14600000000, 0x76971b8a00000000,\n    0xf1b4802f00000000, 0x6fb42ae300000000, 0x8cb3a56d00000000,\n    0x12b30fa100000000, 0x0bbacaab00000000, 0x95ba606700000000,\n    0x76bdefe900000000, 0xe8bd452500000000, 0x44af65fc00000000,\n    0xdaafcf3000000000, 0x39a840be00000000, 0xa7a8ea7200000000,\n    0xbea12f7800000000, 0x20a185b400000000, 0xc3a60a3a00000000,\n    0x5da6a0f600000000, 0x8ce74daa00000000, 0x12e7e76600000000,\n    0xf1e068e800000000, 0x6fe0c22400000000, 0x76e9072e00000000,\n    0xe8e9ade200000000, 0x0bee226c00000000, 0x95ee88a000000000,\n    0x39fca87900000000, 0xa7fc02b500000000, 0x44fb8d3b00000000,\n    0xdafb27f700000000, 0xc3f2e2fd00000000, 0x5df2483100000000,\n    0xbef5c7bf00000000, 0x20f56d7300000000, 0xa7d6f6d600000000,\n    0x39d65c1a00000000, 0xdad1d39400000000, 0x44d1795800000000,\n    0x5dd8bc5200000000, 0xc3d8169e00000000, 0x20df991000000000,\n    0xbedf33dc00000000, 0x12cd130500000000, 0x8ccdb9c900000000,\n    0x6fca364700000000, 0xf1ca9c8b00000000, 0xe8c3598100000000,\n    0x76c3f34d00000000, 0x95c47cc300000000, 0x0bc4d60f00000000,\n    0x3747a67a00000000, 0xa9470cb600000000, 0x4a40833800000000,\n    0xd44029f400000000, 0xcd49ecfe00000000, 0x5349463200000000,\n    0xb04ec9bc00000000, 0x2e4e637000000000, 0x825c43a900000000,\n    0x1c5ce96500000000, 0xff5b66eb00000000, 0x615bcc2700000000,\n    0x7852092d00000000, 0xe652a3e100000000, 0x05552c6f00000000,\n    0x9b5586a300000000, 0x1c761d0600000000, 0x8276b7ca00000000,\n    0x6171384400000000, 0xff71928800000000, 0xe678578200000000,\n    0x7878fd4e00000000, 0x9b7f72c000000000, 0x057fd80c00000000,\n    0xa96df8d500000000, 0x376d521900000000, 0xd46add9700000000,\n    0x4a6a775b00000000, 0x5363b25100000000, 0xcd63189d00000000,\n    0x2e64971300000000, 0xb0643ddf00000000, 0x6125d08300000000,\n    0xff257a4f00000000, 0x1c22f5c100000000, 0x82225f0d00000000,\n    0x9b2b9a0700000000, 0x052b30cb00000000, 0xe62cbf4500000000,\n    0x782c158900000000, 0xd43e355000000000, 0x4a3e9f9c00000000,\n    0xa939101200000000, 0x3739bade00000000, 0x2e307fd400000000,\n    0xb030d51800000000, 0x53375a9600000000, 0xcd37f05a00000000,\n    0x4a146bff00000000, 0xd414c13300000000, 0x37134ebd00000000,\n    0xa913e47100000000, 0xb01a217b00000000, 0x2e1a8bb700000000,\n    0xcd1d043900000000, 0x531daef500000000, 0xff0f8e2c00000000,\n    0x610f24e000000000, 0x8208ab6e00000000, 0x1c0801a200000000,\n    0x0501c4a800000000, 0x9b016e6400000000, 0x7806e1ea00000000,\n    0xe6064b2600000000}};\n\n#else /* W == 4 */\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0xb8bc6765, 0xaa09c88b, 0x12b5afee, 0x8f629757,\n    0x37def032, 0x256b5fdc, 0x9dd738b9, 0xc5b428ef, 0x7d084f8a,\n    0x6fbde064, 0xd7018701, 0x4ad6bfb8, 0xf26ad8dd, 0xe0df7733,\n    0x58631056, 0x5019579f, 0xe8a530fa, 0xfa109f14, 0x42acf871,\n    0xdf7bc0c8, 0x67c7a7ad, 0x75720843, 0xcdce6f26, 0x95ad7f70,\n    0x2d111815, 0x3fa4b7fb, 0x8718d09e, 0x1acfe827, 0xa2738f42,\n    0xb0c620ac, 0x087a47c9, 0xa032af3e, 0x188ec85b, 0x0a3b67b5,\n    0xb28700d0, 0x2f503869, 0x97ec5f0c, 0x8559f0e2, 0x3de59787,\n    0x658687d1, 0xdd3ae0b4, 0xcf8f4f5a, 0x7733283f, 0xeae41086,\n    0x525877e3, 0x40edd80d, 0xf851bf68, 0xf02bf8a1, 0x48979fc4,\n    0x5a22302a, 0xe29e574f, 0x7f496ff6, 0xc7f50893, 0xd540a77d,\n    0x6dfcc018, 0x359fd04e, 0x8d23b72b, 0x9f9618c5, 0x272a7fa0,\n    0xbafd4719, 0x0241207c, 0x10f48f92, 0xa848e8f7, 0x9b14583d,\n    0x23a83f58, 0x311d90b6, 0x89a1f7d3, 0x1476cf6a, 0xaccaa80f,\n    0xbe7f07e1, 0x06c36084, 0x5ea070d2, 0xe61c17b7, 0xf4a9b859,\n    0x4c15df3c, 0xd1c2e785, 0x697e80e0, 0x7bcb2f0e, 0xc377486b,\n    0xcb0d0fa2, 0x73b168c7, 0x6104c729, 0xd9b8a04c, 0x446f98f5,\n    0xfcd3ff90, 0xee66507e, 0x56da371b, 0x0eb9274d, 0xb6054028,\n    0xa4b0efc6, 0x1c0c88a3, 0x81dbb01a, 0x3967d77f, 0x2bd27891,\n    0x936e1ff4, 0x3b26f703, 0x839a9066, 0x912f3f88, 0x299358ed,\n    0xb4446054, 0x0cf80731, 0x1e4da8df, 0xa6f1cfba, 0xfe92dfec,\n    0x462eb889, 0x549b1767, 0xec277002, 0x71f048bb, 0xc94c2fde,\n    0xdbf98030, 0x6345e755, 0x6b3fa09c, 0xd383c7f9, 0xc1366817,\n    0x798a0f72, 0xe45d37cb, 0x5ce150ae, 0x4e54ff40, 0xf6e89825,\n    0xae8b8873, 0x1637ef16, 0x048240f8, 0xbc3e279d, 0x21e91f24,\n    0x99557841, 0x8be0d7af, 0x335cb0ca, 0xed59b63b, 0x55e5d15e,\n    0x47507eb0, 0xffec19d5, 0x623b216c, 0xda874609, 0xc832e9e7,\n    0x708e8e82, 0x28ed9ed4, 0x9051f9b1, 0x82e4565f, 0x3a58313a,\n    0xa78f0983, 0x1f336ee6, 0x0d86c108, 0xb53aa66d, 0xbd40e1a4,\n    0x05fc86c1, 0x1749292f, 0xaff54e4a, 0x322276f3, 0x8a9e1196,\n    0x982bbe78, 0x2097d91d, 0x78f4c94b, 0xc048ae2e, 0xd2fd01c0,\n    0x6a4166a5, 0xf7965e1c, 0x4f2a3979, 0x5d9f9697, 0xe523f1f2,\n    0x4d6b1905, 0xf5d77e60, 0xe762d18e, 0x5fdeb6eb, 0xc2098e52,\n    0x7ab5e937, 0x680046d9, 0xd0bc21bc, 0x88df31ea, 0x3063568f,\n    0x22d6f961, 0x9a6a9e04, 0x07bda6bd, 0xbf01c1d8, 0xadb46e36,\n    0x15080953, 0x1d724e9a, 0xa5ce29ff, 0xb77b8611, 0x0fc7e174,\n    0x9210d9cd, 0x2aacbea8, 0x38191146, 0x80a57623, 0xd8c66675,\n    0x607a0110, 0x72cfaefe, 0xca73c99b, 0x57a4f122, 0xef189647,\n    0xfdad39a9, 0x45115ecc, 0x764dee06, 0xcef18963, 0xdc44268d,\n    0x64f841e8, 0xf92f7951, 0x41931e34, 0x5326b1da, 0xeb9ad6bf,\n    0xb3f9c6e9, 0x0b45a18c, 0x19f00e62, 0xa14c6907, 0x3c9b51be,\n    0x842736db, 0x96929935, 0x2e2efe50, 0x2654b999, 0x9ee8defc,\n    0x8c5d7112, 0x34e11677, 0xa9362ece, 0x118a49ab, 0x033fe645,\n    0xbb838120, 0xe3e09176, 0x5b5cf613, 0x49e959fd, 0xf1553e98,\n    0x6c820621, 0xd43e6144, 0xc68bceaa, 0x7e37a9cf, 0xd67f4138,\n    0x6ec3265d, 0x7c7689b3, 0xc4caeed6, 0x591dd66f, 0xe1a1b10a,\n    0xf3141ee4, 0x4ba87981, 0x13cb69d7, 0xab770eb2, 0xb9c2a15c,\n    0x017ec639, 0x9ca9fe80, 0x241599e5, 0x36a0360b, 0x8e1c516e,\n    0x866616a7, 0x3eda71c2, 0x2c6fde2c, 0x94d3b949, 0x090481f0,\n    0xb1b8e695, 0xa30d497b, 0x1bb12e1e, 0x43d23e48, 0xfb6e592d,\n    0xe9dbf6c3, 0x516791a6, 0xccb0a91f, 0x740cce7a, 0x66b96194,\n    0xde0506f1},\n   {0x00000000, 0x01c26a37, 0x0384d46e, 0x0246be59, 0x0709a8dc,\n    0x06cbc2eb, 0x048d7cb2, 0x054f1685, 0x0e1351b8, 0x0fd13b8f,\n    0x0d9785d6, 0x0c55efe1, 0x091af964, 0x08d89353, 0x0a9e2d0a,\n    0x0b5c473d, 0x1c26a370, 0x1de4c947, 0x1fa2771e, 0x1e601d29,\n    0x1b2f0bac, 0x1aed619b, 0x18abdfc2, 0x1969b5f5, 0x1235f2c8,\n    0x13f798ff, 0x11b126a6, 0x10734c91, 0x153c5a14, 0x14fe3023,\n    0x16b88e7a, 0x177ae44d, 0x384d46e0, 0x398f2cd7, 0x3bc9928e,\n    0x3a0bf8b9, 0x3f44ee3c, 0x3e86840b, 0x3cc03a52, 0x3d025065,\n    0x365e1758, 0x379c7d6f, 0x35dac336, 0x3418a901, 0x3157bf84,\n    0x3095d5b3, 0x32d36bea, 0x331101dd, 0x246be590, 0x25a98fa7,\n    0x27ef31fe, 0x262d5bc9, 0x23624d4c, 0x22a0277b, 0x20e69922,\n    0x2124f315, 0x2a78b428, 0x2bbade1f, 0x29fc6046, 0x283e0a71,\n    0x2d711cf4, 0x2cb376c3, 0x2ef5c89a, 0x2f37a2ad, 0x709a8dc0,\n    0x7158e7f7, 0x731e59ae, 0x72dc3399, 0x7793251c, 0x76514f2b,\n    0x7417f172, 0x75d59b45, 0x7e89dc78, 0x7f4bb64f, 0x7d0d0816,\n    0x7ccf6221, 0x798074a4, 0x78421e93, 0x7a04a0ca, 0x7bc6cafd,\n    0x6cbc2eb0, 0x6d7e4487, 0x6f38fade, 0x6efa90e9, 0x6bb5866c,\n    0x6a77ec5b, 0x68315202, 0x69f33835, 0x62af7f08, 0x636d153f,\n    0x612bab66, 0x60e9c151, 0x65a6d7d4, 0x6464bde3, 0x662203ba,\n    0x67e0698d, 0x48d7cb20, 0x4915a117, 0x4b531f4e, 0x4a917579,\n    0x4fde63fc, 0x4e1c09cb, 0x4c5ab792, 0x4d98dda5, 0x46c49a98,\n    0x4706f0af, 0x45404ef6, 0x448224c1, 0x41cd3244, 0x400f5873,\n    0x4249e62a, 0x438b8c1d, 0x54f16850, 0x55330267, 0x5775bc3e,\n    0x56b7d609, 0x53f8c08c, 0x523aaabb, 0x507c14e2, 0x51be7ed5,\n    0x5ae239e8, 0x5b2053df, 0x5966ed86, 0x58a487b1, 0x5deb9134,\n    0x5c29fb03, 0x5e6f455a, 0x5fad2f6d, 0xe1351b80, 0xe0f771b7,\n    0xe2b1cfee, 0xe373a5d9, 0xe63cb35c, 0xe7fed96b, 0xe5b86732,\n    0xe47a0d05, 0xef264a38, 0xeee4200f, 0xeca29e56, 0xed60f461,\n    0xe82fe2e4, 0xe9ed88d3, 0xebab368a, 0xea695cbd, 0xfd13b8f0,\n    0xfcd1d2c7, 0xfe976c9e, 0xff5506a9, 0xfa1a102c, 0xfbd87a1b,\n    0xf99ec442, 0xf85cae75, 0xf300e948, 0xf2c2837f, 0xf0843d26,\n    0xf1465711, 0xf4094194, 0xf5cb2ba3, 0xf78d95fa, 0xf64fffcd,\n    0xd9785d60, 0xd8ba3757, 0xdafc890e, 0xdb3ee339, 0xde71f5bc,\n    0xdfb39f8b, 0xddf521d2, 0xdc374be5, 0xd76b0cd8, 0xd6a966ef,\n    0xd4efd8b6, 0xd52db281, 0xd062a404, 0xd1a0ce33, 0xd3e6706a,\n    0xd2241a5d, 0xc55efe10, 0xc49c9427, 0xc6da2a7e, 0xc7184049,\n    0xc25756cc, 0xc3953cfb, 0xc1d382a2, 0xc011e895, 0xcb4dafa8,\n    0xca8fc59f, 0xc8c97bc6, 0xc90b11f1, 0xcc440774, 0xcd866d43,\n    0xcfc0d31a, 0xce02b92d, 0x91af9640, 0x906dfc77, 0x922b422e,\n    0x93e92819, 0x96a63e9c, 0x976454ab, 0x9522eaf2, 0x94e080c5,\n    0x9fbcc7f8, 0x9e7eadcf, 0x9c381396, 0x9dfa79a1, 0x98b56f24,\n    0x99770513, 0x9b31bb4a, 0x9af3d17d, 0x8d893530, 0x8c4b5f07,\n    0x8e0de15e, 0x8fcf8b69, 0x8a809dec, 0x8b42f7db, 0x89044982,\n    0x88c623b5, 0x839a6488, 0x82580ebf, 0x801eb0e6, 0x81dcdad1,\n    0x8493cc54, 0x8551a663, 0x8717183a, 0x86d5720d, 0xa9e2d0a0,\n    0xa820ba97, 0xaa6604ce, 0xaba46ef9, 0xaeeb787c, 0xaf29124b,\n    0xad6fac12, 0xacadc625, 0xa7f18118, 0xa633eb2f, 0xa4755576,\n    0xa5b73f41, 0xa0f829c4, 0xa13a43f3, 0xa37cfdaa, 0xa2be979d,\n    0xb5c473d0, 0xb40619e7, 0xb640a7be, 0xb782cd89, 0xb2cddb0c,\n    0xb30fb13b, 0xb1490f62, 0xb08b6555, 0xbbd72268, 0xba15485f,\n    0xb853f606, 0xb9919c31, 0xbcde8ab4, 0xbd1ce083, 0xbf5a5eda,\n    0xbe9834ed},\n   {0x00000000, 0x191b3141, 0x32366282, 0x2b2d53c3, 0x646cc504,\n    0x7d77f445, 0x565aa786, 0x4f4196c7, 0xc8d98a08, 0xd1c2bb49,\n    0xfaefe88a, 0xe3f4d9cb, 0xacb54f0c, 0xb5ae7e4d, 0x9e832d8e,\n    0x87981ccf, 0x4ac21251, 0x53d92310, 0x78f470d3, 0x61ef4192,\n    0x2eaed755, 0x37b5e614, 0x1c98b5d7, 0x05838496, 0x821b9859,\n    0x9b00a918, 0xb02dfadb, 0xa936cb9a, 0xe6775d5d, 0xff6c6c1c,\n    0xd4413fdf, 0xcd5a0e9e, 0x958424a2, 0x8c9f15e3, 0xa7b24620,\n    0xbea97761, 0xf1e8e1a6, 0xe8f3d0e7, 0xc3de8324, 0xdac5b265,\n    0x5d5daeaa, 0x44469feb, 0x6f6bcc28, 0x7670fd69, 0x39316bae,\n    0x202a5aef, 0x0b07092c, 0x121c386d, 0xdf4636f3, 0xc65d07b2,\n    0xed705471, 0xf46b6530, 0xbb2af3f7, 0xa231c2b6, 0x891c9175,\n    0x9007a034, 0x179fbcfb, 0x0e848dba, 0x25a9de79, 0x3cb2ef38,\n    0x73f379ff, 0x6ae848be, 0x41c51b7d, 0x58de2a3c, 0xf0794f05,\n    0xe9627e44, 0xc24f2d87, 0xdb541cc6, 0x94158a01, 0x8d0ebb40,\n    0xa623e883, 0xbf38d9c2, 0x38a0c50d, 0x21bbf44c, 0x0a96a78f,\n    0x138d96ce, 0x5ccc0009, 0x45d73148, 0x6efa628b, 0x77e153ca,\n    0xbabb5d54, 0xa3a06c15, 0x888d3fd6, 0x91960e97, 0xded79850,\n    0xc7cca911, 0xece1fad2, 0xf5facb93, 0x7262d75c, 0x6b79e61d,\n    0x4054b5de, 0x594f849f, 0x160e1258, 0x0f152319, 0x243870da,\n    0x3d23419b, 0x65fd6ba7, 0x7ce65ae6, 0x57cb0925, 0x4ed03864,\n    0x0191aea3, 0x188a9fe2, 0x33a7cc21, 0x2abcfd60, 0xad24e1af,\n    0xb43fd0ee, 0x9f12832d, 0x8609b26c, 0xc94824ab, 0xd05315ea,\n    0xfb7e4629, 0xe2657768, 0x2f3f79f6, 0x362448b7, 0x1d091b74,\n    0x04122a35, 0x4b53bcf2, 0x52488db3, 0x7965de70, 0x607eef31,\n    0xe7e6f3fe, 0xfefdc2bf, 0xd5d0917c, 0xcccba03d, 0x838a36fa,\n    0x9a9107bb, 0xb1bc5478, 0xa8a76539, 0x3b83984b, 0x2298a90a,\n    0x09b5fac9, 0x10aecb88, 0x5fef5d4f, 0x46f46c0e, 0x6dd93fcd,\n    0x74c20e8c, 0xf35a1243, 0xea412302, 0xc16c70c1, 0xd8774180,\n    0x9736d747, 0x8e2de606, 0xa500b5c5, 0xbc1b8484, 0x71418a1a,\n    0x685abb5b, 0x4377e898, 0x5a6cd9d9, 0x152d4f1e, 0x0c367e5f,\n    0x271b2d9c, 0x3e001cdd, 0xb9980012, 0xa0833153, 0x8bae6290,\n    0x92b553d1, 0xddf4c516, 0xc4eff457, 0xefc2a794, 0xf6d996d5,\n    0xae07bce9, 0xb71c8da8, 0x9c31de6b, 0x852aef2a, 0xca6b79ed,\n    0xd37048ac, 0xf85d1b6f, 0xe1462a2e, 0x66de36e1, 0x7fc507a0,\n    0x54e85463, 0x4df36522, 0x02b2f3e5, 0x1ba9c2a4, 0x30849167,\n    0x299fa026, 0xe4c5aeb8, 0xfdde9ff9, 0xd6f3cc3a, 0xcfe8fd7b,\n    0x80a96bbc, 0x99b25afd, 0xb29f093e, 0xab84387f, 0x2c1c24b0,\n    0x350715f1, 0x1e2a4632, 0x07317773, 0x4870e1b4, 0x516bd0f5,\n    0x7a468336, 0x635db277, 0xcbfad74e, 0xd2e1e60f, 0xf9ccb5cc,\n    0xe0d7848d, 0xaf96124a, 0xb68d230b, 0x9da070c8, 0x84bb4189,\n    0x03235d46, 0x1a386c07, 0x31153fc4, 0x280e0e85, 0x674f9842,\n    0x7e54a903, 0x5579fac0, 0x4c62cb81, 0x8138c51f, 0x9823f45e,\n    0xb30ea79d, 0xaa1596dc, 0xe554001b, 0xfc4f315a, 0xd7626299,\n    0xce7953d8, 0x49e14f17, 0x50fa7e56, 0x7bd72d95, 0x62cc1cd4,\n    0x2d8d8a13, 0x3496bb52, 0x1fbbe891, 0x06a0d9d0, 0x5e7ef3ec,\n    0x4765c2ad, 0x6c48916e, 0x7553a02f, 0x3a1236e8, 0x230907a9,\n    0x0824546a, 0x113f652b, 0x96a779e4, 0x8fbc48a5, 0xa4911b66,\n    0xbd8a2a27, 0xf2cbbce0, 0xebd08da1, 0xc0fdde62, 0xd9e6ef23,\n    0x14bce1bd, 0x0da7d0fc, 0x268a833f, 0x3f91b27e, 0x70d024b9,\n    0x69cb15f8, 0x42e6463b, 0x5bfd777a, 0xdc656bb5, 0xc57e5af4,\n    0xee530937, 0xf7483876, 0xb809aeb1, 0xa1129ff0, 0x8a3fcc33,\n    0x9324fd72},\n   {0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n    0x2d02ef8d}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x00000000, 0x96300777, 0x2c610eee, 0xba510999, 0x19c46d07,\n    0x8ff46a70, 0x35a563e9, 0xa395649e, 0x3288db0e, 0xa4b8dc79,\n    0x1ee9d5e0, 0x88d9d297, 0x2b4cb609, 0xbd7cb17e, 0x072db8e7,\n    0x911dbf90, 0x6410b71d, 0xf220b06a, 0x4871b9f3, 0xde41be84,\n    0x7dd4da1a, 0xebe4dd6d, 0x51b5d4f4, 0xc785d383, 0x56986c13,\n    0xc0a86b64, 0x7af962fd, 0xecc9658a, 0x4f5c0114, 0xd96c0663,\n    0x633d0ffa, 0xf50d088d, 0xc8206e3b, 0x5e10694c, 0xe44160d5,\n    0x727167a2, 0xd1e4033c, 0x47d4044b, 0xfd850dd2, 0x6bb50aa5,\n    0xfaa8b535, 0x6c98b242, 0xd6c9bbdb, 0x40f9bcac, 0xe36cd832,\n    0x755cdf45, 0xcf0dd6dc, 0x593dd1ab, 0xac30d926, 0x3a00de51,\n    0x8051d7c8, 0x1661d0bf, 0xb5f4b421, 0x23c4b356, 0x9995bacf,\n    0x0fa5bdb8, 0x9eb80228, 0x0888055f, 0xb2d90cc6, 0x24e90bb1,\n    0x877c6f2f, 0x114c6858, 0xab1d61c1, 0x3d2d66b6, 0x9041dc76,\n    0x0671db01, 0xbc20d298, 0x2a10d5ef, 0x8985b171, 0x1fb5b606,\n    0xa5e4bf9f, 0x33d4b8e8, 0xa2c90778, 0x34f9000f, 0x8ea80996,\n    0x18980ee1, 0xbb0d6a7f, 0x2d3d6d08, 0x976c6491, 0x015c63e6,\n    0xf4516b6b, 0x62616c1c, 0xd8306585, 0x4e0062f2, 0xed95066c,\n    0x7ba5011b, 0xc1f40882, 0x57c40ff5, 0xc6d9b065, 0x50e9b712,\n    0xeab8be8b, 0x7c88b9fc, 0xdf1ddd62, 0x492dda15, 0xf37cd38c,\n    0x654cd4fb, 0x5861b24d, 0xce51b53a, 0x7400bca3, 0xe230bbd4,\n    0x41a5df4a, 0xd795d83d, 0x6dc4d1a4, 0xfbf4d6d3, 0x6ae96943,\n    0xfcd96e34, 0x468867ad, 0xd0b860da, 0x732d0444, 0xe51d0333,\n    0x5f4c0aaa, 0xc97c0ddd, 0x3c710550, 0xaa410227, 0x10100bbe,\n    0x86200cc9, 0x25b56857, 0xb3856f20, 0x09d466b9, 0x9fe461ce,\n    0x0ef9de5e, 0x98c9d929, 0x2298d0b0, 0xb4a8d7c7, 0x173db359,\n    0x810db42e, 0x3b5cbdb7, 0xad6cbac0, 0x2083b8ed, 0xb6b3bf9a,\n    0x0ce2b603, 0x9ad2b174, 0x3947d5ea, 0xaf77d29d, 0x1526db04,\n    0x8316dc73, 0x120b63e3, 0x843b6494, 0x3e6a6d0d, 0xa85a6a7a,\n    0x0bcf0ee4, 0x9dff0993, 0x27ae000a, 0xb19e077d, 0x44930ff0,\n    0xd2a30887, 0x68f2011e, 0xfec20669, 0x5d5762f7, 0xcb676580,\n    0x71366c19, 0xe7066b6e, 0x761bd4fe, 0xe02bd389, 0x5a7ada10,\n    0xcc4add67, 0x6fdfb9f9, 0xf9efbe8e, 0x43beb717, 0xd58eb060,\n    0xe8a3d6d6, 0x7e93d1a1, 0xc4c2d838, 0x52f2df4f, 0xf167bbd1,\n    0x6757bca6, 0xdd06b53f, 0x4b36b248, 0xda2b0dd8, 0x4c1b0aaf,\n    0xf64a0336, 0x607a0441, 0xc3ef60df, 0x55df67a8, 0xef8e6e31,\n    0x79be6946, 0x8cb361cb, 0x1a8366bc, 0xa0d26f25, 0x36e26852,\n    0x95770ccc, 0x03470bbb, 0xb9160222, 0x2f260555, 0xbe3bbac5,\n    0x280bbdb2, 0x925ab42b, 0x046ab35c, 0xa7ffd7c2, 0x31cfd0b5,\n    0x8b9ed92c, 0x1daede5b, 0xb0c2649b, 0x26f263ec, 0x9ca36a75,\n    0x0a936d02, 0xa906099c, 0x3f360eeb, 0x85670772, 0x13570005,\n    0x824abf95, 0x147ab8e2, 0xae2bb17b, 0x381bb60c, 0x9b8ed292,\n    0x0dbed5e5, 0xb7efdc7c, 0x21dfdb0b, 0xd4d2d386, 0x42e2d4f1,\n    0xf8b3dd68, 0x6e83da1f, 0xcd16be81, 0x5b26b9f6, 0xe177b06f,\n    0x7747b718, 0xe65a0888, 0x706a0fff, 0xca3b0666, 0x5c0b0111,\n    0xff9e658f, 0x69ae62f8, 0xd3ff6b61, 0x45cf6c16, 0x78e20aa0,\n    0xeed20dd7, 0x5483044e, 0xc2b30339, 0x612667a7, 0xf71660d0,\n    0x4d476949, 0xdb776e3e, 0x4a6ad1ae, 0xdc5ad6d9, 0x660bdf40,\n    0xf03bd837, 0x53aebca9, 0xc59ebbde, 0x7fcfb247, 0xe9ffb530,\n    0x1cf2bdbd, 0x8ac2baca, 0x3093b353, 0xa6a3b424, 0x0536d0ba,\n    0x9306d7cd, 0x2957de54, 0xbf67d923, 0x2e7a66b3, 0xb84a61c4,\n    0x021b685d, 0x942b6f2a, 0x37be0bb4, 0xa18e0cc3, 0x1bdf055a,\n    0x8def022d},\n   {0x00000000, 0x41311b19, 0x82623632, 0xc3532d2b, 0x04c56c64,\n    0x45f4777d, 0x86a75a56, 0xc796414f, 0x088ad9c8, 0x49bbc2d1,\n    0x8ae8effa, 0xcbd9f4e3, 0x0c4fb5ac, 0x4d7eaeb5, 0x8e2d839e,\n    0xcf1c9887, 0x5112c24a, 0x1023d953, 0xd370f478, 0x9241ef61,\n    0x55d7ae2e, 0x14e6b537, 0xd7b5981c, 0x96848305, 0x59981b82,\n    0x18a9009b, 0xdbfa2db0, 0x9acb36a9, 0x5d5d77e6, 0x1c6c6cff,\n    0xdf3f41d4, 0x9e0e5acd, 0xa2248495, 0xe3159f8c, 0x2046b2a7,\n    0x6177a9be, 0xa6e1e8f1, 0xe7d0f3e8, 0x2483dec3, 0x65b2c5da,\n    0xaaae5d5d, 0xeb9f4644, 0x28cc6b6f, 0x69fd7076, 0xae6b3139,\n    0xef5a2a20, 0x2c09070b, 0x6d381c12, 0xf33646df, 0xb2075dc6,\n    0x715470ed, 0x30656bf4, 0xf7f32abb, 0xb6c231a2, 0x75911c89,\n    0x34a00790, 0xfbbc9f17, 0xba8d840e, 0x79dea925, 0x38efb23c,\n    0xff79f373, 0xbe48e86a, 0x7d1bc541, 0x3c2ade58, 0x054f79f0,\n    0x447e62e9, 0x872d4fc2, 0xc61c54db, 0x018a1594, 0x40bb0e8d,\n    0x83e823a6, 0xc2d938bf, 0x0dc5a038, 0x4cf4bb21, 0x8fa7960a,\n    0xce968d13, 0x0900cc5c, 0x4831d745, 0x8b62fa6e, 0xca53e177,\n    0x545dbbba, 0x156ca0a3, 0xd63f8d88, 0x970e9691, 0x5098d7de,\n    0x11a9ccc7, 0xd2fae1ec, 0x93cbfaf5, 0x5cd76272, 0x1de6796b,\n    0xdeb55440, 0x9f844f59, 0x58120e16, 0x1923150f, 0xda703824,\n    0x9b41233d, 0xa76bfd65, 0xe65ae67c, 0x2509cb57, 0x6438d04e,\n    0xa3ae9101, 0xe29f8a18, 0x21cca733, 0x60fdbc2a, 0xafe124ad,\n    0xeed03fb4, 0x2d83129f, 0x6cb20986, 0xab2448c9, 0xea1553d0,\n    0x29467efb, 0x687765e2, 0xf6793f2f, 0xb7482436, 0x741b091d,\n    0x352a1204, 0xf2bc534b, 0xb38d4852, 0x70de6579, 0x31ef7e60,\n    0xfef3e6e7, 0xbfc2fdfe, 0x7c91d0d5, 0x3da0cbcc, 0xfa368a83,\n    0xbb07919a, 0x7854bcb1, 0x3965a7a8, 0x4b98833b, 0x0aa99822,\n    0xc9fab509, 0x88cbae10, 0x4f5def5f, 0x0e6cf446, 0xcd3fd96d,\n    0x8c0ec274, 0x43125af3, 0x022341ea, 0xc1706cc1, 0x804177d8,\n    0x47d73697, 0x06e62d8e, 0xc5b500a5, 0x84841bbc, 0x1a8a4171,\n    0x5bbb5a68, 0x98e87743, 0xd9d96c5a, 0x1e4f2d15, 0x5f7e360c,\n    0x9c2d1b27, 0xdd1c003e, 0x120098b9, 0x533183a0, 0x9062ae8b,\n    0xd153b592, 0x16c5f4dd, 0x57f4efc4, 0x94a7c2ef, 0xd596d9f6,\n    0xe9bc07ae, 0xa88d1cb7, 0x6bde319c, 0x2aef2a85, 0xed796bca,\n    0xac4870d3, 0x6f1b5df8, 0x2e2a46e1, 0xe136de66, 0xa007c57f,\n    0x6354e854, 0x2265f34d, 0xe5f3b202, 0xa4c2a91b, 0x67918430,\n    0x26a09f29, 0xb8aec5e4, 0xf99fdefd, 0x3accf3d6, 0x7bfde8cf,\n    0xbc6ba980, 0xfd5ab299, 0x3e099fb2, 0x7f3884ab, 0xb0241c2c,\n    0xf1150735, 0x32462a1e, 0x73773107, 0xb4e17048, 0xf5d06b51,\n    0x3683467a, 0x77b25d63, 0x4ed7facb, 0x0fe6e1d2, 0xccb5ccf9,\n    0x8d84d7e0, 0x4a1296af, 0x0b238db6, 0xc870a09d, 0x8941bb84,\n    0x465d2303, 0x076c381a, 0xc43f1531, 0x850e0e28, 0x42984f67,\n    0x03a9547e, 0xc0fa7955, 0x81cb624c, 0x1fc53881, 0x5ef42398,\n    0x9da70eb3, 0xdc9615aa, 0x1b0054e5, 0x5a314ffc, 0x996262d7,\n    0xd85379ce, 0x174fe149, 0x567efa50, 0x952dd77b, 0xd41ccc62,\n    0x138a8d2d, 0x52bb9634, 0x91e8bb1f, 0xd0d9a006, 0xecf37e5e,\n    0xadc26547, 0x6e91486c, 0x2fa05375, 0xe836123a, 0xa9070923,\n    0x6a542408, 0x2b653f11, 0xe479a796, 0xa548bc8f, 0x661b91a4,\n    0x272a8abd, 0xe0bccbf2, 0xa18dd0eb, 0x62defdc0, 0x23efe6d9,\n    0xbde1bc14, 0xfcd0a70d, 0x3f838a26, 0x7eb2913f, 0xb924d070,\n    0xf815cb69, 0x3b46e642, 0x7a77fd5b, 0xb56b65dc, 0xf45a7ec5,\n    0x370953ee, 0x763848f7, 0xb1ae09b8, 0xf09f12a1, 0x33cc3f8a,\n    0x72fd2493},\n   {0x00000000, 0x376ac201, 0x6ed48403, 0x59be4602, 0xdca80907,\n    0xebc2cb06, 0xb27c8d04, 0x85164f05, 0xb851130e, 0x8f3bd10f,\n    0xd685970d, 0xe1ef550c, 0x64f91a09, 0x5393d808, 0x0a2d9e0a,\n    0x3d475c0b, 0x70a3261c, 0x47c9e41d, 0x1e77a21f, 0x291d601e,\n    0xac0b2f1b, 0x9b61ed1a, 0xc2dfab18, 0xf5b56919, 0xc8f23512,\n    0xff98f713, 0xa626b111, 0x914c7310, 0x145a3c15, 0x2330fe14,\n    0x7a8eb816, 0x4de47a17, 0xe0464d38, 0xd72c8f39, 0x8e92c93b,\n    0xb9f80b3a, 0x3cee443f, 0x0b84863e, 0x523ac03c, 0x6550023d,\n    0x58175e36, 0x6f7d9c37, 0x36c3da35, 0x01a91834, 0x84bf5731,\n    0xb3d59530, 0xea6bd332, 0xdd011133, 0x90e56b24, 0xa78fa925,\n    0xfe31ef27, 0xc95b2d26, 0x4c4d6223, 0x7b27a022, 0x2299e620,\n    0x15f32421, 0x28b4782a, 0x1fdeba2b, 0x4660fc29, 0x710a3e28,\n    0xf41c712d, 0xc376b32c, 0x9ac8f52e, 0xada2372f, 0xc08d9a70,\n    0xf7e75871, 0xae591e73, 0x9933dc72, 0x1c259377, 0x2b4f5176,\n    0x72f11774, 0x459bd575, 0x78dc897e, 0x4fb64b7f, 0x16080d7d,\n    0x2162cf7c, 0xa4748079, 0x931e4278, 0xcaa0047a, 0xfdcac67b,\n    0xb02ebc6c, 0x87447e6d, 0xdefa386f, 0xe990fa6e, 0x6c86b56b,\n    0x5bec776a, 0x02523168, 0x3538f369, 0x087faf62, 0x3f156d63,\n    0x66ab2b61, 0x51c1e960, 0xd4d7a665, 0xe3bd6464, 0xba032266,\n    0x8d69e067, 0x20cbd748, 0x17a11549, 0x4e1f534b, 0x7975914a,\n    0xfc63de4f, 0xcb091c4e, 0x92b75a4c, 0xa5dd984d, 0x989ac446,\n    0xaff00647, 0xf64e4045, 0xc1248244, 0x4432cd41, 0x73580f40,\n    0x2ae64942, 0x1d8c8b43, 0x5068f154, 0x67023355, 0x3ebc7557,\n    0x09d6b756, 0x8cc0f853, 0xbbaa3a52, 0xe2147c50, 0xd57ebe51,\n    0xe839e25a, 0xdf53205b, 0x86ed6659, 0xb187a458, 0x3491eb5d,\n    0x03fb295c, 0x5a456f5e, 0x6d2fad5f, 0x801b35e1, 0xb771f7e0,\n    0xeecfb1e2, 0xd9a573e3, 0x5cb33ce6, 0x6bd9fee7, 0x3267b8e5,\n    0x050d7ae4, 0x384a26ef, 0x0f20e4ee, 0x569ea2ec, 0x61f460ed,\n    0xe4e22fe8, 0xd388ede9, 0x8a36abeb, 0xbd5c69ea, 0xf0b813fd,\n    0xc7d2d1fc, 0x9e6c97fe, 0xa90655ff, 0x2c101afa, 0x1b7ad8fb,\n    0x42c49ef9, 0x75ae5cf8, 0x48e900f3, 0x7f83c2f2, 0x263d84f0,\n    0x115746f1, 0x944109f4, 0xa32bcbf5, 0xfa958df7, 0xcdff4ff6,\n    0x605d78d9, 0x5737bad8, 0x0e89fcda, 0x39e33edb, 0xbcf571de,\n    0x8b9fb3df, 0xd221f5dd, 0xe54b37dc, 0xd80c6bd7, 0xef66a9d6,\n    0xb6d8efd4, 0x81b22dd5, 0x04a462d0, 0x33cea0d1, 0x6a70e6d3,\n    0x5d1a24d2, 0x10fe5ec5, 0x27949cc4, 0x7e2adac6, 0x494018c7,\n    0xcc5657c2, 0xfb3c95c3, 0xa282d3c1, 0x95e811c0, 0xa8af4dcb,\n    0x9fc58fca, 0xc67bc9c8, 0xf1110bc9, 0x740744cc, 0x436d86cd,\n    0x1ad3c0cf, 0x2db902ce, 0x4096af91, 0x77fc6d90, 0x2e422b92,\n    0x1928e993, 0x9c3ea696, 0xab546497, 0xf2ea2295, 0xc580e094,\n    0xf8c7bc9f, 0xcfad7e9e, 0x9613389c, 0xa179fa9d, 0x246fb598,\n    0x13057799, 0x4abb319b, 0x7dd1f39a, 0x3035898d, 0x075f4b8c,\n    0x5ee10d8e, 0x698bcf8f, 0xec9d808a, 0xdbf7428b, 0x82490489,\n    0xb523c688, 0x88649a83, 0xbf0e5882, 0xe6b01e80, 0xd1dadc81,\n    0x54cc9384, 0x63a65185, 0x3a181787, 0x0d72d586, 0xa0d0e2a9,\n    0x97ba20a8, 0xce0466aa, 0xf96ea4ab, 0x7c78ebae, 0x4b1229af,\n    0x12ac6fad, 0x25c6adac, 0x1881f1a7, 0x2feb33a6, 0x765575a4,\n    0x413fb7a5, 0xc429f8a0, 0xf3433aa1, 0xaafd7ca3, 0x9d97bea2,\n    0xd073c4b5, 0xe71906b4, 0xbea740b6, 0x89cd82b7, 0x0cdbcdb2,\n    0x3bb10fb3, 0x620f49b1, 0x55658bb0, 0x6822d7bb, 0x5f4815ba,\n    0x06f653b8, 0x319c91b9, 0xb48adebc, 0x83e01cbd, 0xda5e5abf,\n    0xed3498be},\n   {0x00000000, 0x6567bcb8, 0x8bc809aa, 0xeeafb512, 0x5797628f,\n    0x32f0de37, 0xdc5f6b25, 0xb938d79d, 0xef28b4c5, 0x8a4f087d,\n    0x64e0bd6f, 0x018701d7, 0xb8bfd64a, 0xddd86af2, 0x3377dfe0,\n    0x56106358, 0x9f571950, 0xfa30a5e8, 0x149f10fa, 0x71f8ac42,\n    0xc8c07bdf, 0xada7c767, 0x43087275, 0x266fcecd, 0x707fad95,\n    0x1518112d, 0xfbb7a43f, 0x9ed01887, 0x27e8cf1a, 0x428f73a2,\n    0xac20c6b0, 0xc9477a08, 0x3eaf32a0, 0x5bc88e18, 0xb5673b0a,\n    0xd00087b2, 0x6938502f, 0x0c5fec97, 0xe2f05985, 0x8797e53d,\n    0xd1878665, 0xb4e03add, 0x5a4f8fcf, 0x3f283377, 0x8610e4ea,\n    0xe3775852, 0x0dd8ed40, 0x68bf51f8, 0xa1f82bf0, 0xc49f9748,\n    0x2a30225a, 0x4f579ee2, 0xf66f497f, 0x9308f5c7, 0x7da740d5,\n    0x18c0fc6d, 0x4ed09f35, 0x2bb7238d, 0xc518969f, 0xa07f2a27,\n    0x1947fdba, 0x7c204102, 0x928ff410, 0xf7e848a8, 0x3d58149b,\n    0x583fa823, 0xb6901d31, 0xd3f7a189, 0x6acf7614, 0x0fa8caac,\n    0xe1077fbe, 0x8460c306, 0xd270a05e, 0xb7171ce6, 0x59b8a9f4,\n    0x3cdf154c, 0x85e7c2d1, 0xe0807e69, 0x0e2fcb7b, 0x6b4877c3,\n    0xa20f0dcb, 0xc768b173, 0x29c70461, 0x4ca0b8d9, 0xf5986f44,\n    0x90ffd3fc, 0x7e5066ee, 0x1b37da56, 0x4d27b90e, 0x284005b6,\n    0xc6efb0a4, 0xa3880c1c, 0x1ab0db81, 0x7fd76739, 0x9178d22b,\n    0xf41f6e93, 0x03f7263b, 0x66909a83, 0x883f2f91, 0xed589329,\n    0x546044b4, 0x3107f80c, 0xdfa84d1e, 0xbacff1a6, 0xecdf92fe,\n    0x89b82e46, 0x67179b54, 0x027027ec, 0xbb48f071, 0xde2f4cc9,\n    0x3080f9db, 0x55e74563, 0x9ca03f6b, 0xf9c783d3, 0x176836c1,\n    0x720f8a79, 0xcb375de4, 0xae50e15c, 0x40ff544e, 0x2598e8f6,\n    0x73888bae, 0x16ef3716, 0xf8408204, 0x9d273ebc, 0x241fe921,\n    0x41785599, 0xafd7e08b, 0xcab05c33, 0x3bb659ed, 0x5ed1e555,\n    0xb07e5047, 0xd519ecff, 0x6c213b62, 0x094687da, 0xe7e932c8,\n    0x828e8e70, 0xd49eed28, 0xb1f95190, 0x5f56e482, 0x3a31583a,\n    0x83098fa7, 0xe66e331f, 0x08c1860d, 0x6da63ab5, 0xa4e140bd,\n    0xc186fc05, 0x2f294917, 0x4a4ef5af, 0xf3762232, 0x96119e8a,\n    0x78be2b98, 0x1dd99720, 0x4bc9f478, 0x2eae48c0, 0xc001fdd2,\n    0xa566416a, 0x1c5e96f7, 0x79392a4f, 0x97969f5d, 0xf2f123e5,\n    0x05196b4d, 0x607ed7f5, 0x8ed162e7, 0xebb6de5f, 0x528e09c2,\n    0x37e9b57a, 0xd9460068, 0xbc21bcd0, 0xea31df88, 0x8f566330,\n    0x61f9d622, 0x049e6a9a, 0xbda6bd07, 0xd8c101bf, 0x366eb4ad,\n    0x53090815, 0x9a4e721d, 0xff29cea5, 0x11867bb7, 0x74e1c70f,\n    0xcdd91092, 0xa8beac2a, 0x46111938, 0x2376a580, 0x7566c6d8,\n    0x10017a60, 0xfeaecf72, 0x9bc973ca, 0x22f1a457, 0x479618ef,\n    0xa939adfd, 0xcc5e1145, 0x06ee4d76, 0x6389f1ce, 0x8d2644dc,\n    0xe841f864, 0x51792ff9, 0x341e9341, 0xdab12653, 0xbfd69aeb,\n    0xe9c6f9b3, 0x8ca1450b, 0x620ef019, 0x07694ca1, 0xbe519b3c,\n    0xdb362784, 0x35999296, 0x50fe2e2e, 0x99b95426, 0xfcdee89e,\n    0x12715d8c, 0x7716e134, 0xce2e36a9, 0xab498a11, 0x45e63f03,\n    0x208183bb, 0x7691e0e3, 0x13f65c5b, 0xfd59e949, 0x983e55f1,\n    0x2106826c, 0x44613ed4, 0xaace8bc6, 0xcfa9377e, 0x38417fd6,\n    0x5d26c36e, 0xb389767c, 0xd6eecac4, 0x6fd61d59, 0x0ab1a1e1,\n    0xe41e14f3, 0x8179a84b, 0xd769cb13, 0xb20e77ab, 0x5ca1c2b9,\n    0x39c67e01, 0x80fea99c, 0xe5991524, 0x0b36a036, 0x6e511c8e,\n    0xa7166686, 0xc271da3e, 0x2cde6f2c, 0x49b9d394, 0xf0810409,\n    0x95e6b8b1, 0x7b490da3, 0x1e2eb11b, 0x483ed243, 0x2d596efb,\n    0xc3f6dbe9, 0xa6916751, 0x1fa9b0cc, 0x7ace0c74, 0x9461b966,\n    0xf10605de}};\n\n#endif /* W */\n\n#endif /* N == 1 */\n#if N == 2\n\n#if W == 8\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0xae689191, 0x87a02563, 0x29c8b4f2, 0xd4314c87,\n    0x7a59dd16, 0x539169e4, 0xfdf9f875, 0x73139f4f, 0xdd7b0ede,\n    0xf4b3ba2c, 0x5adb2bbd, 0xa722d3c8, 0x094a4259, 0x2082f6ab,\n    0x8eea673a, 0xe6273e9e, 0x484faf0f, 0x61871bfd, 0xcfef8a6c,\n    0x32167219, 0x9c7ee388, 0xb5b6577a, 0x1bdec6eb, 0x9534a1d1,\n    0x3b5c3040, 0x129484b2, 0xbcfc1523, 0x4105ed56, 0xef6d7cc7,\n    0xc6a5c835, 0x68cd59a4, 0x173f7b7d, 0xb957eaec, 0x909f5e1e,\n    0x3ef7cf8f, 0xc30e37fa, 0x6d66a66b, 0x44ae1299, 0xeac68308,\n    0x642ce432, 0xca4475a3, 0xe38cc151, 0x4de450c0, 0xb01da8b5,\n    0x1e753924, 0x37bd8dd6, 0x99d51c47, 0xf11845e3, 0x5f70d472,\n    0x76b86080, 0xd8d0f111, 0x25290964, 0x8b4198f5, 0xa2892c07,\n    0x0ce1bd96, 0x820bdaac, 0x2c634b3d, 0x05abffcf, 0xabc36e5e,\n    0x563a962b, 0xf85207ba, 0xd19ab348, 0x7ff222d9, 0x2e7ef6fa,\n    0x8016676b, 0xa9ded399, 0x07b64208, 0xfa4fba7d, 0x54272bec,\n    0x7def9f1e, 0xd3870e8f, 0x5d6d69b5, 0xf305f824, 0xdacd4cd6,\n    0x74a5dd47, 0x895c2532, 0x2734b4a3, 0x0efc0051, 0xa09491c0,\n    0xc859c864, 0x663159f5, 0x4ff9ed07, 0xe1917c96, 0x1c6884e3,\n    0xb2001572, 0x9bc8a180, 0x35a03011, 0xbb4a572b, 0x1522c6ba,\n    0x3cea7248, 0x9282e3d9, 0x6f7b1bac, 0xc1138a3d, 0xe8db3ecf,\n    0x46b3af5e, 0x39418d87, 0x97291c16, 0xbee1a8e4, 0x10893975,\n    0xed70c100, 0x43185091, 0x6ad0e463, 0xc4b875f2, 0x4a5212c8,\n    0xe43a8359, 0xcdf237ab, 0x639aa63a, 0x9e635e4f, 0x300bcfde,\n    0x19c37b2c, 0xb7abeabd, 0xdf66b319, 0x710e2288, 0x58c6967a,\n    0xf6ae07eb, 0x0b57ff9e, 0xa53f6e0f, 0x8cf7dafd, 0x229f4b6c,\n    0xac752c56, 0x021dbdc7, 0x2bd50935, 0x85bd98a4, 0x784460d1,\n    0xd62cf140, 0xffe445b2, 0x518cd423, 0x5cfdedf4, 0xf2957c65,\n    0xdb5dc897, 0x75355906, 0x88cca173, 0x26a430e2, 0x0f6c8410,\n    0xa1041581, 0x2fee72bb, 0x8186e32a, 0xa84e57d8, 0x0626c649,\n    0xfbdf3e3c, 0x55b7afad, 0x7c7f1b5f, 0xd2178ace, 0xbadad36a,\n    0x14b242fb, 0x3d7af609, 0x93126798, 0x6eeb9fed, 0xc0830e7c,\n    0xe94bba8e, 0x47232b1f, 0xc9c94c25, 0x67a1ddb4, 0x4e696946,\n    0xe001f8d7, 0x1df800a2, 0xb3909133, 0x9a5825c1, 0x3430b450,\n    0x4bc29689, 0xe5aa0718, 0xcc62b3ea, 0x620a227b, 0x9ff3da0e,\n    0x319b4b9f, 0x1853ff6d, 0xb63b6efc, 0x38d109c6, 0x96b99857,\n    0xbf712ca5, 0x1119bd34, 0xece04541, 0x4288d4d0, 0x6b406022,\n    0xc528f1b3, 0xade5a817, 0x038d3986, 0x2a458d74, 0x842d1ce5,\n    0x79d4e490, 0xd7bc7501, 0xfe74c1f3, 0x501c5062, 0xdef63758,\n    0x709ea6c9, 0x5956123b, 0xf73e83aa, 0x0ac77bdf, 0xa4afea4e,\n    0x8d675ebc, 0x230fcf2d, 0x72831b0e, 0xdceb8a9f, 0xf5233e6d,\n    0x5b4baffc, 0xa6b25789, 0x08dac618, 0x211272ea, 0x8f7ae37b,\n    0x01908441, 0xaff815d0, 0x8630a122, 0x285830b3, 0xd5a1c8c6,\n    0x7bc95957, 0x5201eda5, 0xfc697c34, 0x94a42590, 0x3accb401,\n    0x130400f3, 0xbd6c9162, 0x40956917, 0xeefdf886, 0xc7354c74,\n    0x695ddde5, 0xe7b7badf, 0x49df2b4e, 0x60179fbc, 0xce7f0e2d,\n    0x3386f658, 0x9dee67c9, 0xb426d33b, 0x1a4e42aa, 0x65bc6073,\n    0xcbd4f1e2, 0xe21c4510, 0x4c74d481, 0xb18d2cf4, 0x1fe5bd65,\n    0x362d0997, 0x98459806, 0x16afff3c, 0xb8c76ead, 0x910fda5f,\n    0x3f674bce, 0xc29eb3bb, 0x6cf6222a, 0x453e96d8, 0xeb560749,\n    0x839b5eed, 0x2df3cf7c, 0x043b7b8e, 0xaa53ea1f, 0x57aa126a,\n    0xf9c283fb, 0xd00a3709, 0x7e62a698, 0xf088c1a2, 0x5ee05033,\n    0x7728e4c1, 0xd9407550, 0x24b98d25, 0x8ad11cb4, 0xa319a846,\n    0x0d7139d7},\n   {0x00000000, 0xb9fbdbe8, 0xa886b191, 0x117d6a79, 0x8a7c6563,\n    0x3387be8b, 0x22fad4f2, 0x9b010f1a, 0xcf89cc87, 0x7672176f,\n    0x670f7d16, 0xdef4a6fe, 0x45f5a9e4, 0xfc0e720c, 0xed731875,\n    0x5488c39d, 0x44629f4f, 0xfd9944a7, 0xece42ede, 0x551ff536,\n    0xce1efa2c, 0x77e521c4, 0x66984bbd, 0xdf639055, 0x8beb53c8,\n    0x32108820, 0x236de259, 0x9a9639b1, 0x019736ab, 0xb86ced43,\n    0xa911873a, 0x10ea5cd2, 0x88c53e9e, 0x313ee576, 0x20438f0f,\n    0x99b854e7, 0x02b95bfd, 0xbb428015, 0xaa3fea6c, 0x13c43184,\n    0x474cf219, 0xfeb729f1, 0xefca4388, 0x56319860, 0xcd30977a,\n    0x74cb4c92, 0x65b626eb, 0xdc4dfd03, 0xcca7a1d1, 0x755c7a39,\n    0x64211040, 0xdddacba8, 0x46dbc4b2, 0xff201f5a, 0xee5d7523,\n    0x57a6aecb, 0x032e6d56, 0xbad5b6be, 0xaba8dcc7, 0x1253072f,\n    0x89520835, 0x30a9d3dd, 0x21d4b9a4, 0x982f624c, 0xcafb7b7d,\n    0x7300a095, 0x627dcaec, 0xdb861104, 0x40871e1e, 0xf97cc5f6,\n    0xe801af8f, 0x51fa7467, 0x0572b7fa, 0xbc896c12, 0xadf4066b,\n    0x140fdd83, 0x8f0ed299, 0x36f50971, 0x27886308, 0x9e73b8e0,\n    0x8e99e432, 0x37623fda, 0x261f55a3, 0x9fe48e4b, 0x04e58151,\n    0xbd1e5ab9, 0xac6330c0, 0x1598eb28, 0x411028b5, 0xf8ebf35d,\n    0xe9969924, 0x506d42cc, 0xcb6c4dd6, 0x7297963e, 0x63eafc47,\n    0xda1127af, 0x423e45e3, 0xfbc59e0b, 0xeab8f472, 0x53432f9a,\n    0xc8422080, 0x71b9fb68, 0x60c49111, 0xd93f4af9, 0x8db78964,\n    0x344c528c, 0x253138f5, 0x9ccae31d, 0x07cbec07, 0xbe3037ef,\n    0xaf4d5d96, 0x16b6867e, 0x065cdaac, 0xbfa70144, 0xaeda6b3d,\n    0x1721b0d5, 0x8c20bfcf, 0x35db6427, 0x24a60e5e, 0x9d5dd5b6,\n    0xc9d5162b, 0x702ecdc3, 0x6153a7ba, 0xd8a87c52, 0x43a97348,\n    0xfa52a8a0, 0xeb2fc2d9, 0x52d41931, 0x4e87f0bb, 0xf77c2b53,\n    0xe601412a, 0x5ffa9ac2, 0xc4fb95d8, 0x7d004e30, 0x6c7d2449,\n    0xd586ffa1, 0x810e3c3c, 0x38f5e7d4, 0x29888dad, 0x90735645,\n    0x0b72595f, 0xb28982b7, 0xa3f4e8ce, 0x1a0f3326, 0x0ae56ff4,\n    0xb31eb41c, 0xa263de65, 0x1b98058d, 0x80990a97, 0x3962d17f,\n    0x281fbb06, 0x91e460ee, 0xc56ca373, 0x7c97789b, 0x6dea12e2,\n    0xd411c90a, 0x4f10c610, 0xf6eb1df8, 0xe7967781, 0x5e6dac69,\n    0xc642ce25, 0x7fb915cd, 0x6ec47fb4, 0xd73fa45c, 0x4c3eab46,\n    0xf5c570ae, 0xe4b81ad7, 0x5d43c13f, 0x09cb02a2, 0xb030d94a,\n    0xa14db333, 0x18b668db, 0x83b767c1, 0x3a4cbc29, 0x2b31d650,\n    0x92ca0db8, 0x8220516a, 0x3bdb8a82, 0x2aa6e0fb, 0x935d3b13,\n    0x085c3409, 0xb1a7efe1, 0xa0da8598, 0x19215e70, 0x4da99ded,\n    0xf4524605, 0xe52f2c7c, 0x5cd4f794, 0xc7d5f88e, 0x7e2e2366,\n    0x6f53491f, 0xd6a892f7, 0x847c8bc6, 0x3d87502e, 0x2cfa3a57,\n    0x9501e1bf, 0x0e00eea5, 0xb7fb354d, 0xa6865f34, 0x1f7d84dc,\n    0x4bf54741, 0xf20e9ca9, 0xe373f6d0, 0x5a882d38, 0xc1892222,\n    0x7872f9ca, 0x690f93b3, 0xd0f4485b, 0xc01e1489, 0x79e5cf61,\n    0x6898a518, 0xd1637ef0, 0x4a6271ea, 0xf399aa02, 0xe2e4c07b,\n    0x5b1f1b93, 0x0f97d80e, 0xb66c03e6, 0xa711699f, 0x1eeab277,\n    0x85ebbd6d, 0x3c106685, 0x2d6d0cfc, 0x9496d714, 0x0cb9b558,\n    0xb5426eb0, 0xa43f04c9, 0x1dc4df21, 0x86c5d03b, 0x3f3e0bd3,\n    0x2e4361aa, 0x97b8ba42, 0xc33079df, 0x7acba237, 0x6bb6c84e,\n    0xd24d13a6, 0x494c1cbc, 0xf0b7c754, 0xe1caad2d, 0x583176c5,\n    0x48db2a17, 0xf120f1ff, 0xe05d9b86, 0x59a6406e, 0xc2a74f74,\n    0x7b5c949c, 0x6a21fee5, 0xd3da250d, 0x8752e690, 0x3ea93d78,\n    0x2fd45701, 0x962f8ce9, 0x0d2e83f3, 0xb4d5581b, 0xa5a83262,\n    0x1c53e98a},\n   {0x00000000, 0x9d0fe176, 0xe16ec4ad, 0x7c6125db, 0x19ac8f1b,\n    0x84a36e6d, 0xf8c24bb6, 0x65cdaac0, 0x33591e36, 0xae56ff40,\n    0xd237da9b, 0x4f383bed, 0x2af5912d, 0xb7fa705b, 0xcb9b5580,\n    0x5694b4f6, 0x66b23c6c, 0xfbbddd1a, 0x87dcf8c1, 0x1ad319b7,\n    0x7f1eb377, 0xe2115201, 0x9e7077da, 0x037f96ac, 0x55eb225a,\n    0xc8e4c32c, 0xb485e6f7, 0x298a0781, 0x4c47ad41, 0xd1484c37,\n    0xad2969ec, 0x3026889a, 0xcd6478d8, 0x506b99ae, 0x2c0abc75,\n    0xb1055d03, 0xd4c8f7c3, 0x49c716b5, 0x35a6336e, 0xa8a9d218,\n    0xfe3d66ee, 0x63328798, 0x1f53a243, 0x825c4335, 0xe791e9f5,\n    0x7a9e0883, 0x06ff2d58, 0x9bf0cc2e, 0xabd644b4, 0x36d9a5c2,\n    0x4ab88019, 0xd7b7616f, 0xb27acbaf, 0x2f752ad9, 0x53140f02,\n    0xce1bee74, 0x988f5a82, 0x0580bbf4, 0x79e19e2f, 0xe4ee7f59,\n    0x8123d599, 0x1c2c34ef, 0x604d1134, 0xfd42f042, 0x41b9f7f1,\n    0xdcb61687, 0xa0d7335c, 0x3dd8d22a, 0x581578ea, 0xc51a999c,\n    0xb97bbc47, 0x24745d31, 0x72e0e9c7, 0xefef08b1, 0x938e2d6a,\n    0x0e81cc1c, 0x6b4c66dc, 0xf64387aa, 0x8a22a271, 0x172d4307,\n    0x270bcb9d, 0xba042aeb, 0xc6650f30, 0x5b6aee46, 0x3ea74486,\n    0xa3a8a5f0, 0xdfc9802b, 0x42c6615d, 0x1452d5ab, 0x895d34dd,\n    0xf53c1106, 0x6833f070, 0x0dfe5ab0, 0x90f1bbc6, 0xec909e1d,\n    0x719f7f6b, 0x8cdd8f29, 0x11d26e5f, 0x6db34b84, 0xf0bcaaf2,\n    0x95710032, 0x087ee144, 0x741fc49f, 0xe91025e9, 0xbf84911f,\n    0x228b7069, 0x5eea55b2, 0xc3e5b4c4, 0xa6281e04, 0x3b27ff72,\n    0x4746daa9, 0xda493bdf, 0xea6fb345, 0x77605233, 0x0b0177e8,\n    0x960e969e, 0xf3c33c5e, 0x6eccdd28, 0x12adf8f3, 0x8fa21985,\n    0xd936ad73, 0x44394c05, 0x385869de, 0xa55788a8, 0xc09a2268,\n    0x5d95c31e, 0x21f4e6c5, 0xbcfb07b3, 0x8373efe2, 0x1e7c0e94,\n    0x621d2b4f, 0xff12ca39, 0x9adf60f9, 0x07d0818f, 0x7bb1a454,\n    0xe6be4522, 0xb02af1d4, 0x2d2510a2, 0x51443579, 0xcc4bd40f,\n    0xa9867ecf, 0x34899fb9, 0x48e8ba62, 0xd5e75b14, 0xe5c1d38e,\n    0x78ce32f8, 0x04af1723, 0x99a0f655, 0xfc6d5c95, 0x6162bde3,\n    0x1d039838, 0x800c794e, 0xd698cdb8, 0x4b972cce, 0x37f60915,\n    0xaaf9e863, 0xcf3442a3, 0x523ba3d5, 0x2e5a860e, 0xb3556778,\n    0x4e17973a, 0xd318764c, 0xaf795397, 0x3276b2e1, 0x57bb1821,\n    0xcab4f957, 0xb6d5dc8c, 0x2bda3dfa, 0x7d4e890c, 0xe041687a,\n    0x9c204da1, 0x012facd7, 0x64e20617, 0xf9ede761, 0x858cc2ba,\n    0x188323cc, 0x28a5ab56, 0xb5aa4a20, 0xc9cb6ffb, 0x54c48e8d,\n    0x3109244d, 0xac06c53b, 0xd067e0e0, 0x4d680196, 0x1bfcb560,\n    0x86f35416, 0xfa9271cd, 0x679d90bb, 0x02503a7b, 0x9f5fdb0d,\n    0xe33efed6, 0x7e311fa0, 0xc2ca1813, 0x5fc5f965, 0x23a4dcbe,\n    0xbeab3dc8, 0xdb669708, 0x4669767e, 0x3a0853a5, 0xa707b2d3,\n    0xf1930625, 0x6c9ce753, 0x10fdc288, 0x8df223fe, 0xe83f893e,\n    0x75306848, 0x09514d93, 0x945eace5, 0xa478247f, 0x3977c509,\n    0x4516e0d2, 0xd81901a4, 0xbdd4ab64, 0x20db4a12, 0x5cba6fc9,\n    0xc1b58ebf, 0x97213a49, 0x0a2edb3f, 0x764ffee4, 0xeb401f92,\n    0x8e8db552, 0x13825424, 0x6fe371ff, 0xf2ec9089, 0x0fae60cb,\n    0x92a181bd, 0xeec0a466, 0x73cf4510, 0x1602efd0, 0x8b0d0ea6,\n    0xf76c2b7d, 0x6a63ca0b, 0x3cf77efd, 0xa1f89f8b, 0xdd99ba50,\n    0x40965b26, 0x255bf1e6, 0xb8541090, 0xc435354b, 0x593ad43d,\n    0x691c5ca7, 0xf413bdd1, 0x8872980a, 0x157d797c, 0x70b0d3bc,\n    0xedbf32ca, 0x91de1711, 0x0cd1f667, 0x5a454291, 0xc74aa3e7,\n    0xbb2b863c, 0x2624674a, 0x43e9cd8a, 0xdee62cfc, 0xa2870927,\n    0x3f88e851},\n   {0x00000000, 0xdd96d985, 0x605cb54b, 0xbdca6cce, 0xc0b96a96,\n    0x1d2fb313, 0xa0e5dfdd, 0x7d730658, 0x5a03d36d, 0x87950ae8,\n    0x3a5f6626, 0xe7c9bfa3, 0x9abab9fb, 0x472c607e, 0xfae60cb0,\n    0x2770d535, 0xb407a6da, 0x69917f5f, 0xd45b1391, 0x09cdca14,\n    0x74becc4c, 0xa92815c9, 0x14e27907, 0xc974a082, 0xee0475b7,\n    0x3392ac32, 0x8e58c0fc, 0x53ce1979, 0x2ebd1f21, 0xf32bc6a4,\n    0x4ee1aa6a, 0x937773ef, 0xb37e4bf5, 0x6ee89270, 0xd322febe,\n    0x0eb4273b, 0x73c72163, 0xae51f8e6, 0x139b9428, 0xce0d4dad,\n    0xe97d9898, 0x34eb411d, 0x89212dd3, 0x54b7f456, 0x29c4f20e,\n    0xf4522b8b, 0x49984745, 0x940e9ec0, 0x0779ed2f, 0xdaef34aa,\n    0x67255864, 0xbab381e1, 0xc7c087b9, 0x1a565e3c, 0xa79c32f2,\n    0x7a0aeb77, 0x5d7a3e42, 0x80ece7c7, 0x3d268b09, 0xe0b0528c,\n    0x9dc354d4, 0x40558d51, 0xfd9fe19f, 0x2009381a, 0xbd8d91ab,\n    0x601b482e, 0xddd124e0, 0x0047fd65, 0x7d34fb3d, 0xa0a222b8,\n    0x1d684e76, 0xc0fe97f3, 0xe78e42c6, 0x3a189b43, 0x87d2f78d,\n    0x5a442e08, 0x27372850, 0xfaa1f1d5, 0x476b9d1b, 0x9afd449e,\n    0x098a3771, 0xd41ceef4, 0x69d6823a, 0xb4405bbf, 0xc9335de7,\n    0x14a58462, 0xa96fe8ac, 0x74f93129, 0x5389e41c, 0x8e1f3d99,\n    0x33d55157, 0xee4388d2, 0x93308e8a, 0x4ea6570f, 0xf36c3bc1,\n    0x2efae244, 0x0ef3da5e, 0xd36503db, 0x6eaf6f15, 0xb339b690,\n    0xce4ab0c8, 0x13dc694d, 0xae160583, 0x7380dc06, 0x54f00933,\n    0x8966d0b6, 0x34acbc78, 0xe93a65fd, 0x944963a5, 0x49dfba20,\n    0xf415d6ee, 0x29830f6b, 0xbaf47c84, 0x6762a501, 0xdaa8c9cf,\n    0x073e104a, 0x7a4d1612, 0xa7dbcf97, 0x1a11a359, 0xc7877adc,\n    0xe0f7afe9, 0x3d61766c, 0x80ab1aa2, 0x5d3dc327, 0x204ec57f,\n    0xfdd81cfa, 0x40127034, 0x9d84a9b1, 0xa06a2517, 0x7dfcfc92,\n    0xc036905c, 0x1da049d9, 0x60d34f81, 0xbd459604, 0x008ffaca,\n    0xdd19234f, 0xfa69f67a, 0x27ff2fff, 0x9a354331, 0x47a39ab4,\n    0x3ad09cec, 0xe7464569, 0x5a8c29a7, 0x871af022, 0x146d83cd,\n    0xc9fb5a48, 0x74313686, 0xa9a7ef03, 0xd4d4e95b, 0x094230de,\n    0xb4885c10, 0x691e8595, 0x4e6e50a0, 0x93f88925, 0x2e32e5eb,\n    0xf3a43c6e, 0x8ed73a36, 0x5341e3b3, 0xee8b8f7d, 0x331d56f8,\n    0x13146ee2, 0xce82b767, 0x7348dba9, 0xaede022c, 0xd3ad0474,\n    0x0e3bddf1, 0xb3f1b13f, 0x6e6768ba, 0x4917bd8f, 0x9481640a,\n    0x294b08c4, 0xf4ddd141, 0x89aed719, 0x54380e9c, 0xe9f26252,\n    0x3464bbd7, 0xa713c838, 0x7a8511bd, 0xc74f7d73, 0x1ad9a4f6,\n    0x67aaa2ae, 0xba3c7b2b, 0x07f617e5, 0xda60ce60, 0xfd101b55,\n    0x2086c2d0, 0x9d4cae1e, 0x40da779b, 0x3da971c3, 0xe03fa846,\n    0x5df5c488, 0x80631d0d, 0x1de7b4bc, 0xc0716d39, 0x7dbb01f7,\n    0xa02dd872, 0xdd5ede2a, 0x00c807af, 0xbd026b61, 0x6094b2e4,\n    0x47e467d1, 0x9a72be54, 0x27b8d29a, 0xfa2e0b1f, 0x875d0d47,\n    0x5acbd4c2, 0xe701b80c, 0x3a976189, 0xa9e01266, 0x7476cbe3,\n    0xc9bca72d, 0x142a7ea8, 0x695978f0, 0xb4cfa175, 0x0905cdbb,\n    0xd493143e, 0xf3e3c10b, 0x2e75188e, 0x93bf7440, 0x4e29adc5,\n    0x335aab9d, 0xeecc7218, 0x53061ed6, 0x8e90c753, 0xae99ff49,\n    0x730f26cc, 0xcec54a02, 0x13539387, 0x6e2095df, 0xb3b64c5a,\n    0x0e7c2094, 0xd3eaf911, 0xf49a2c24, 0x290cf5a1, 0x94c6996f,\n    0x495040ea, 0x342346b2, 0xe9b59f37, 0x547ff3f9, 0x89e92a7c,\n    0x1a9e5993, 0xc7088016, 0x7ac2ecd8, 0xa754355d, 0xda273305,\n    0x07b1ea80, 0xba7b864e, 0x67ed5fcb, 0x409d8afe, 0x9d0b537b,\n    0x20c13fb5, 0xfd57e630, 0x8024e068, 0x5db239ed, 0xe0785523,\n    0x3dee8ca6},\n   {0x00000000, 0x9ba54c6f, 0xec3b9e9f, 0x779ed2f0, 0x03063b7f,\n    0x98a37710, 0xef3da5e0, 0x7498e98f, 0x060c76fe, 0x9da93a91,\n    0xea37e861, 0x7192a40e, 0x050a4d81, 0x9eaf01ee, 0xe931d31e,\n    0x72949f71, 0x0c18edfc, 0x97bda193, 0xe0237363, 0x7b863f0c,\n    0x0f1ed683, 0x94bb9aec, 0xe325481c, 0x78800473, 0x0a149b02,\n    0x91b1d76d, 0xe62f059d, 0x7d8a49f2, 0x0912a07d, 0x92b7ec12,\n    0xe5293ee2, 0x7e8c728d, 0x1831dbf8, 0x83949797, 0xf40a4567,\n    0x6faf0908, 0x1b37e087, 0x8092ace8, 0xf70c7e18, 0x6ca93277,\n    0x1e3dad06, 0x8598e169, 0xf2063399, 0x69a37ff6, 0x1d3b9679,\n    0x869eda16, 0xf10008e6, 0x6aa54489, 0x14293604, 0x8f8c7a6b,\n    0xf812a89b, 0x63b7e4f4, 0x172f0d7b, 0x8c8a4114, 0xfb1493e4,\n    0x60b1df8b, 0x122540fa, 0x89800c95, 0xfe1ede65, 0x65bb920a,\n    0x11237b85, 0x8a8637ea, 0xfd18e51a, 0x66bda975, 0x3063b7f0,\n    0xabc6fb9f, 0xdc58296f, 0x47fd6500, 0x33658c8f, 0xa8c0c0e0,\n    0xdf5e1210, 0x44fb5e7f, 0x366fc10e, 0xadca8d61, 0xda545f91,\n    0x41f113fe, 0x3569fa71, 0xaeccb61e, 0xd95264ee, 0x42f72881,\n    0x3c7b5a0c, 0xa7de1663, 0xd040c493, 0x4be588fc, 0x3f7d6173,\n    0xa4d82d1c, 0xd346ffec, 0x48e3b383, 0x3a772cf2, 0xa1d2609d,\n    0xd64cb26d, 0x4de9fe02, 0x3971178d, 0xa2d45be2, 0xd54a8912,\n    0x4eefc57d, 0x28526c08, 0xb3f72067, 0xc469f297, 0x5fccbef8,\n    0x2b545777, 0xb0f11b18, 0xc76fc9e8, 0x5cca8587, 0x2e5e1af6,\n    0xb5fb5699, 0xc2658469, 0x59c0c806, 0x2d582189, 0xb6fd6de6,\n    0xc163bf16, 0x5ac6f379, 0x244a81f4, 0xbfefcd9b, 0xc8711f6b,\n    0x53d45304, 0x274cba8b, 0xbce9f6e4, 0xcb772414, 0x50d2687b,\n    0x2246f70a, 0xb9e3bb65, 0xce7d6995, 0x55d825fa, 0x2140cc75,\n    0xbae5801a, 0xcd7b52ea, 0x56de1e85, 0x60c76fe0, 0xfb62238f,\n    0x8cfcf17f, 0x1759bd10, 0x63c1549f, 0xf86418f0, 0x8ffaca00,\n    0x145f866f, 0x66cb191e, 0xfd6e5571, 0x8af08781, 0x1155cbee,\n    0x65cd2261, 0xfe686e0e, 0x89f6bcfe, 0x1253f091, 0x6cdf821c,\n    0xf77ace73, 0x80e41c83, 0x1b4150ec, 0x6fd9b963, 0xf47cf50c,\n    0x83e227fc, 0x18476b93, 0x6ad3f4e2, 0xf176b88d, 0x86e86a7d,\n    0x1d4d2612, 0x69d5cf9d, 0xf27083f2, 0x85ee5102, 0x1e4b1d6d,\n    0x78f6b418, 0xe353f877, 0x94cd2a87, 0x0f6866e8, 0x7bf08f67,\n    0xe055c308, 0x97cb11f8, 0x0c6e5d97, 0x7efac2e6, 0xe55f8e89,\n    0x92c15c79, 0x09641016, 0x7dfcf999, 0xe659b5f6, 0x91c76706,\n    0x0a622b69, 0x74ee59e4, 0xef4b158b, 0x98d5c77b, 0x03708b14,\n    0x77e8629b, 0xec4d2ef4, 0x9bd3fc04, 0x0076b06b, 0x72e22f1a,\n    0xe9476375, 0x9ed9b185, 0x057cfdea, 0x71e41465, 0xea41580a,\n    0x9ddf8afa, 0x067ac695, 0x50a4d810, 0xcb01947f, 0xbc9f468f,\n    0x273a0ae0, 0x53a2e36f, 0xc807af00, 0xbf997df0, 0x243c319f,\n    0x56a8aeee, 0xcd0de281, 0xba933071, 0x21367c1e, 0x55ae9591,\n    0xce0bd9fe, 0xb9950b0e, 0x22304761, 0x5cbc35ec, 0xc7197983,\n    0xb087ab73, 0x2b22e71c, 0x5fba0e93, 0xc41f42fc, 0xb381900c,\n    0x2824dc63, 0x5ab04312, 0xc1150f7d, 0xb68bdd8d, 0x2d2e91e2,\n    0x59b6786d, 0xc2133402, 0xb58de6f2, 0x2e28aa9d, 0x489503e8,\n    0xd3304f87, 0xa4ae9d77, 0x3f0bd118, 0x4b933897, 0xd03674f8,\n    0xa7a8a608, 0x3c0dea67, 0x4e997516, 0xd53c3979, 0xa2a2eb89,\n    0x3907a7e6, 0x4d9f4e69, 0xd63a0206, 0xa1a4d0f6, 0x3a019c99,\n    0x448dee14, 0xdf28a27b, 0xa8b6708b, 0x33133ce4, 0x478bd56b,\n    0xdc2e9904, 0xabb04bf4, 0x3015079b, 0x428198ea, 0xd924d485,\n    0xaeba0675, 0x351f4a1a, 0x4187a395, 0xda22effa, 0xadbc3d0a,\n    0x36197165},\n   {0x00000000, 0xc18edfc0, 0x586cb9c1, 0x99e26601, 0xb0d97382,\n    0x7157ac42, 0xe8b5ca43, 0x293b1583, 0xbac3e145, 0x7b4d3e85,\n    0xe2af5884, 0x23218744, 0x0a1a92c7, 0xcb944d07, 0x52762b06,\n    0x93f8f4c6, 0xaef6c4cb, 0x6f781b0b, 0xf69a7d0a, 0x3714a2ca,\n    0x1e2fb749, 0xdfa16889, 0x46430e88, 0x87cdd148, 0x1435258e,\n    0xd5bbfa4e, 0x4c599c4f, 0x8dd7438f, 0xa4ec560c, 0x656289cc,\n    0xfc80efcd, 0x3d0e300d, 0x869c8fd7, 0x47125017, 0xdef03616,\n    0x1f7ee9d6, 0x3645fc55, 0xf7cb2395, 0x6e294594, 0xafa79a54,\n    0x3c5f6e92, 0xfdd1b152, 0x6433d753, 0xa5bd0893, 0x8c861d10,\n    0x4d08c2d0, 0xd4eaa4d1, 0x15647b11, 0x286a4b1c, 0xe9e494dc,\n    0x7006f2dd, 0xb1882d1d, 0x98b3389e, 0x593de75e, 0xc0df815f,\n    0x01515e9f, 0x92a9aa59, 0x53277599, 0xcac51398, 0x0b4bcc58,\n    0x2270d9db, 0xe3fe061b, 0x7a1c601a, 0xbb92bfda, 0xd64819ef,\n    0x17c6c62f, 0x8e24a02e, 0x4faa7fee, 0x66916a6d, 0xa71fb5ad,\n    0x3efdd3ac, 0xff730c6c, 0x6c8bf8aa, 0xad05276a, 0x34e7416b,\n    0xf5699eab, 0xdc528b28, 0x1ddc54e8, 0x843e32e9, 0x45b0ed29,\n    0x78bedd24, 0xb93002e4, 0x20d264e5, 0xe15cbb25, 0xc867aea6,\n    0x09e97166, 0x900b1767, 0x5185c8a7, 0xc27d3c61, 0x03f3e3a1,\n    0x9a1185a0, 0x5b9f5a60, 0x72a44fe3, 0xb32a9023, 0x2ac8f622,\n    0xeb4629e2, 0x50d49638, 0x915a49f8, 0x08b82ff9, 0xc936f039,\n    0xe00de5ba, 0x21833a7a, 0xb8615c7b, 0x79ef83bb, 0xea17777d,\n    0x2b99a8bd, 0xb27bcebc, 0x73f5117c, 0x5ace04ff, 0x9b40db3f,\n    0x02a2bd3e, 0xc32c62fe, 0xfe2252f3, 0x3fac8d33, 0xa64eeb32,\n    0x67c034f2, 0x4efb2171, 0x8f75feb1, 0x169798b0, 0xd7194770,\n    0x44e1b3b6, 0x856f6c76, 0x1c8d0a77, 0xdd03d5b7, 0xf438c034,\n    0x35b61ff4, 0xac5479f5, 0x6ddaa635, 0x77e1359f, 0xb66fea5f,\n    0x2f8d8c5e, 0xee03539e, 0xc738461d, 0x06b699dd, 0x9f54ffdc,\n    0x5eda201c, 0xcd22d4da, 0x0cac0b1a, 0x954e6d1b, 0x54c0b2db,\n    0x7dfba758, 0xbc757898, 0x25971e99, 0xe419c159, 0xd917f154,\n    0x18992e94, 0x817b4895, 0x40f59755, 0x69ce82d6, 0xa8405d16,\n    0x31a23b17, 0xf02ce4d7, 0x63d41011, 0xa25acfd1, 0x3bb8a9d0,\n    0xfa367610, 0xd30d6393, 0x1283bc53, 0x8b61da52, 0x4aef0592,\n    0xf17dba48, 0x30f36588, 0xa9110389, 0x689fdc49, 0x41a4c9ca,\n    0x802a160a, 0x19c8700b, 0xd846afcb, 0x4bbe5b0d, 0x8a3084cd,\n    0x13d2e2cc, 0xd25c3d0c, 0xfb67288f, 0x3ae9f74f, 0xa30b914e,\n    0x62854e8e, 0x5f8b7e83, 0x9e05a143, 0x07e7c742, 0xc6691882,\n    0xef520d01, 0x2edcd2c1, 0xb73eb4c0, 0x76b06b00, 0xe5489fc6,\n    0x24c64006, 0xbd242607, 0x7caaf9c7, 0x5591ec44, 0x941f3384,\n    0x0dfd5585, 0xcc738a45, 0xa1a92c70, 0x6027f3b0, 0xf9c595b1,\n    0x384b4a71, 0x11705ff2, 0xd0fe8032, 0x491ce633, 0x889239f3,\n    0x1b6acd35, 0xdae412f5, 0x430674f4, 0x8288ab34, 0xabb3beb7,\n    0x6a3d6177, 0xf3df0776, 0x3251d8b6, 0x0f5fe8bb, 0xced1377b,\n    0x5733517a, 0x96bd8eba, 0xbf869b39, 0x7e0844f9, 0xe7ea22f8,\n    0x2664fd38, 0xb59c09fe, 0x7412d63e, 0xedf0b03f, 0x2c7e6fff,\n    0x05457a7c, 0xc4cba5bc, 0x5d29c3bd, 0x9ca71c7d, 0x2735a3a7,\n    0xe6bb7c67, 0x7f591a66, 0xbed7c5a6, 0x97ecd025, 0x56620fe5,\n    0xcf8069e4, 0x0e0eb624, 0x9df642e2, 0x5c789d22, 0xc59afb23,\n    0x041424e3, 0x2d2f3160, 0xeca1eea0, 0x754388a1, 0xb4cd5761,\n    0x89c3676c, 0x484db8ac, 0xd1afdead, 0x1021016d, 0x391a14ee,\n    0xf894cb2e, 0x6176ad2f, 0xa0f872ef, 0x33008629, 0xf28e59e9,\n    0x6b6c3fe8, 0xaae2e028, 0x83d9f5ab, 0x42572a6b, 0xdbb54c6a,\n    0x1a3b93aa},\n   {0x00000000, 0xefc26b3e, 0x04f5d03d, 0xeb37bb03, 0x09eba07a,\n    0xe629cb44, 0x0d1e7047, 0xe2dc1b79, 0x13d740f4, 0xfc152bca,\n    0x172290c9, 0xf8e0fbf7, 0x1a3ce08e, 0xf5fe8bb0, 0x1ec930b3,\n    0xf10b5b8d, 0x27ae81e8, 0xc86cead6, 0x235b51d5, 0xcc993aeb,\n    0x2e452192, 0xc1874aac, 0x2ab0f1af, 0xc5729a91, 0x3479c11c,\n    0xdbbbaa22, 0x308c1121, 0xdf4e7a1f, 0x3d926166, 0xd2500a58,\n    0x3967b15b, 0xd6a5da65, 0x4f5d03d0, 0xa09f68ee, 0x4ba8d3ed,\n    0xa46ab8d3, 0x46b6a3aa, 0xa974c894, 0x42437397, 0xad8118a9,\n    0x5c8a4324, 0xb348281a, 0x587f9319, 0xb7bdf827, 0x5561e35e,\n    0xbaa38860, 0x51943363, 0xbe56585d, 0x68f38238, 0x8731e906,\n    0x6c065205, 0x83c4393b, 0x61182242, 0x8eda497c, 0x65edf27f,\n    0x8a2f9941, 0x7b24c2cc, 0x94e6a9f2, 0x7fd112f1, 0x901379cf,\n    0x72cf62b6, 0x9d0d0988, 0x763ab28b, 0x99f8d9b5, 0x9eba07a0,\n    0x71786c9e, 0x9a4fd79d, 0x758dbca3, 0x9751a7da, 0x7893cce4,\n    0x93a477e7, 0x7c661cd9, 0x8d6d4754, 0x62af2c6a, 0x89989769,\n    0x665afc57, 0x8486e72e, 0x6b448c10, 0x80733713, 0x6fb15c2d,\n    0xb9148648, 0x56d6ed76, 0xbde15675, 0x52233d4b, 0xb0ff2632,\n    0x5f3d4d0c, 0xb40af60f, 0x5bc89d31, 0xaac3c6bc, 0x4501ad82,\n    0xae361681, 0x41f47dbf, 0xa32866c6, 0x4cea0df8, 0xa7ddb6fb,\n    0x481fddc5, 0xd1e70470, 0x3e256f4e, 0xd512d44d, 0x3ad0bf73,\n    0xd80ca40a, 0x37cecf34, 0xdcf97437, 0x333b1f09, 0xc2304484,\n    0x2df22fba, 0xc6c594b9, 0x2907ff87, 0xcbdbe4fe, 0x24198fc0,\n    0xcf2e34c3, 0x20ec5ffd, 0xf6498598, 0x198beea6, 0xf2bc55a5,\n    0x1d7e3e9b, 0xffa225e2, 0x10604edc, 0xfb57f5df, 0x14959ee1,\n    0xe59ec56c, 0x0a5cae52, 0xe16b1551, 0x0ea97e6f, 0xec756516,\n    0x03b70e28, 0xe880b52b, 0x0742de15, 0xe6050901, 0x09c7623f,\n    0xe2f0d93c, 0x0d32b202, 0xefeea97b, 0x002cc245, 0xeb1b7946,\n    0x04d91278, 0xf5d249f5, 0x1a1022cb, 0xf12799c8, 0x1ee5f2f6,\n    0xfc39e98f, 0x13fb82b1, 0xf8cc39b2, 0x170e528c, 0xc1ab88e9,\n    0x2e69e3d7, 0xc55e58d4, 0x2a9c33ea, 0xc8402893, 0x278243ad,\n    0xccb5f8ae, 0x23779390, 0xd27cc81d, 0x3dbea323, 0xd6891820,\n    0x394b731e, 0xdb976867, 0x34550359, 0xdf62b85a, 0x30a0d364,\n    0xa9580ad1, 0x469a61ef, 0xadaddaec, 0x426fb1d2, 0xa0b3aaab,\n    0x4f71c195, 0xa4467a96, 0x4b8411a8, 0xba8f4a25, 0x554d211b,\n    0xbe7a9a18, 0x51b8f126, 0xb364ea5f, 0x5ca68161, 0xb7913a62,\n    0x5853515c, 0x8ef68b39, 0x6134e007, 0x8a035b04, 0x65c1303a,\n    0x871d2b43, 0x68df407d, 0x83e8fb7e, 0x6c2a9040, 0x9d21cbcd,\n    0x72e3a0f3, 0x99d41bf0, 0x761670ce, 0x94ca6bb7, 0x7b080089,\n    0x903fbb8a, 0x7ffdd0b4, 0x78bf0ea1, 0x977d659f, 0x7c4ade9c,\n    0x9388b5a2, 0x7154aedb, 0x9e96c5e5, 0x75a17ee6, 0x9a6315d8,\n    0x6b684e55, 0x84aa256b, 0x6f9d9e68, 0x805ff556, 0x6283ee2f,\n    0x8d418511, 0x66763e12, 0x89b4552c, 0x5f118f49, 0xb0d3e477,\n    0x5be45f74, 0xb426344a, 0x56fa2f33, 0xb938440d, 0x520fff0e,\n    0xbdcd9430, 0x4cc6cfbd, 0xa304a483, 0x48331f80, 0xa7f174be,\n    0x452d6fc7, 0xaaef04f9, 0x41d8bffa, 0xae1ad4c4, 0x37e20d71,\n    0xd820664f, 0x3317dd4c, 0xdcd5b672, 0x3e09ad0b, 0xd1cbc635,\n    0x3afc7d36, 0xd53e1608, 0x24354d85, 0xcbf726bb, 0x20c09db8,\n    0xcf02f686, 0x2ddeedff, 0xc21c86c1, 0x292b3dc2, 0xc6e956fc,\n    0x104c8c99, 0xff8ee7a7, 0x14b95ca4, 0xfb7b379a, 0x19a72ce3,\n    0xf66547dd, 0x1d52fcde, 0xf29097e0, 0x039bcc6d, 0xec59a753,\n    0x076e1c50, 0xe8ac776e, 0x0a706c17, 0xe5b20729, 0x0e85bc2a,\n    0xe147d714},\n   {0x00000000, 0x177b1443, 0x2ef62886, 0x398d3cc5, 0x5dec510c,\n    0x4a97454f, 0x731a798a, 0x64616dc9, 0xbbd8a218, 0xaca3b65b,\n    0x952e8a9e, 0x82559edd, 0xe634f314, 0xf14fe757, 0xc8c2db92,\n    0xdfb9cfd1, 0xacc04271, 0xbbbb5632, 0x82366af7, 0x954d7eb4,\n    0xf12c137d, 0xe657073e, 0xdfda3bfb, 0xc8a12fb8, 0x1718e069,\n    0x0063f42a, 0x39eec8ef, 0x2e95dcac, 0x4af4b165, 0x5d8fa526,\n    0x640299e3, 0x73798da0, 0x82f182a3, 0x958a96e0, 0xac07aa25,\n    0xbb7cbe66, 0xdf1dd3af, 0xc866c7ec, 0xf1ebfb29, 0xe690ef6a,\n    0x392920bb, 0x2e5234f8, 0x17df083d, 0x00a41c7e, 0x64c571b7,\n    0x73be65f4, 0x4a335931, 0x5d484d72, 0x2e31c0d2, 0x394ad491,\n    0x00c7e854, 0x17bcfc17, 0x73dd91de, 0x64a6859d, 0x5d2bb958,\n    0x4a50ad1b, 0x95e962ca, 0x82927689, 0xbb1f4a4c, 0xac645e0f,\n    0xc80533c6, 0xdf7e2785, 0xe6f31b40, 0xf1880f03, 0xde920307,\n    0xc9e91744, 0xf0642b81, 0xe71f3fc2, 0x837e520b, 0x94054648,\n    0xad887a8d, 0xbaf36ece, 0x654aa11f, 0x7231b55c, 0x4bbc8999,\n    0x5cc79dda, 0x38a6f013, 0x2fdde450, 0x1650d895, 0x012bccd6,\n    0x72524176, 0x65295535, 0x5ca469f0, 0x4bdf7db3, 0x2fbe107a,\n    0x38c50439, 0x014838fc, 0x16332cbf, 0xc98ae36e, 0xdef1f72d,\n    0xe77ccbe8, 0xf007dfab, 0x9466b262, 0x831da621, 0xba909ae4,\n    0xadeb8ea7, 0x5c6381a4, 0x4b1895e7, 0x7295a922, 0x65eebd61,\n    0x018fd0a8, 0x16f4c4eb, 0x2f79f82e, 0x3802ec6d, 0xe7bb23bc,\n    0xf0c037ff, 0xc94d0b3a, 0xde361f79, 0xba5772b0, 0xad2c66f3,\n    0x94a15a36, 0x83da4e75, 0xf0a3c3d5, 0xe7d8d796, 0xde55eb53,\n    0xc92eff10, 0xad4f92d9, 0xba34869a, 0x83b9ba5f, 0x94c2ae1c,\n    0x4b7b61cd, 0x5c00758e, 0x658d494b, 0x72f65d08, 0x169730c1,\n    0x01ec2482, 0x38611847, 0x2f1a0c04, 0x6655004f, 0x712e140c,\n    0x48a328c9, 0x5fd83c8a, 0x3bb95143, 0x2cc24500, 0x154f79c5,\n    0x02346d86, 0xdd8da257, 0xcaf6b614, 0xf37b8ad1, 0xe4009e92,\n    0x8061f35b, 0x971ae718, 0xae97dbdd, 0xb9eccf9e, 0xca95423e,\n    0xddee567d, 0xe4636ab8, 0xf3187efb, 0x97791332, 0x80020771,\n    0xb98f3bb4, 0xaef42ff7, 0x714de026, 0x6636f465, 0x5fbbc8a0,\n    0x48c0dce3, 0x2ca1b12a, 0x3bdaa569, 0x025799ac, 0x152c8def,\n    0xe4a482ec, 0xf3df96af, 0xca52aa6a, 0xdd29be29, 0xb948d3e0,\n    0xae33c7a3, 0x97befb66, 0x80c5ef25, 0x5f7c20f4, 0x480734b7,\n    0x718a0872, 0x66f11c31, 0x029071f8, 0x15eb65bb, 0x2c66597e,\n    0x3b1d4d3d, 0x4864c09d, 0x5f1fd4de, 0x6692e81b, 0x71e9fc58,\n    0x15889191, 0x02f385d2, 0x3b7eb917, 0x2c05ad54, 0xf3bc6285,\n    0xe4c776c6, 0xdd4a4a03, 0xca315e40, 0xae503389, 0xb92b27ca,\n    0x80a61b0f, 0x97dd0f4c, 0xb8c70348, 0xafbc170b, 0x96312bce,\n    0x814a3f8d, 0xe52b5244, 0xf2504607, 0xcbdd7ac2, 0xdca66e81,\n    0x031fa150, 0x1464b513, 0x2de989d6, 0x3a929d95, 0x5ef3f05c,\n    0x4988e41f, 0x7005d8da, 0x677ecc99, 0x14074139, 0x037c557a,\n    0x3af169bf, 0x2d8a7dfc, 0x49eb1035, 0x5e900476, 0x671d38b3,\n    0x70662cf0, 0xafdfe321, 0xb8a4f762, 0x8129cba7, 0x9652dfe4,\n    0xf233b22d, 0xe548a66e, 0xdcc59aab, 0xcbbe8ee8, 0x3a3681eb,\n    0x2d4d95a8, 0x14c0a96d, 0x03bbbd2e, 0x67dad0e7, 0x70a1c4a4,\n    0x492cf861, 0x5e57ec22, 0x81ee23f3, 0x969537b0, 0xaf180b75,\n    0xb8631f36, 0xdc0272ff, 0xcb7966bc, 0xf2f45a79, 0xe58f4e3a,\n    0x96f6c39a, 0x818dd7d9, 0xb800eb1c, 0xaf7bff5f, 0xcb1a9296,\n    0xdc6186d5, 0xe5ecba10, 0xf297ae53, 0x2d2e6182, 0x3a5575c1,\n    0x03d84904, 0x14a35d47, 0x70c2308e, 0x67b924cd, 0x5e341808,\n    0x494f0c4b}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x43147b1700000000, 0x8628f62e00000000,\n    0xc53c8d3900000000, 0x0c51ec5d00000000, 0x4f45974a00000000,\n    0x8a791a7300000000, 0xc96d616400000000, 0x18a2d8bb00000000,\n    0x5bb6a3ac00000000, 0x9e8a2e9500000000, 0xdd9e558200000000,\n    0x14f334e600000000, 0x57e74ff100000000, 0x92dbc2c800000000,\n    0xd1cfb9df00000000, 0x7142c0ac00000000, 0x3256bbbb00000000,\n    0xf76a368200000000, 0xb47e4d9500000000, 0x7d132cf100000000,\n    0x3e0757e600000000, 0xfb3bdadf00000000, 0xb82fa1c800000000,\n    0x69e0181700000000, 0x2af4630000000000, 0xefc8ee3900000000,\n    0xacdc952e00000000, 0x65b1f44a00000000, 0x26a58f5d00000000,\n    0xe399026400000000, 0xa08d797300000000, 0xa382f18200000000,\n    0xe0968a9500000000, 0x25aa07ac00000000, 0x66be7cbb00000000,\n    0xafd31ddf00000000, 0xecc766c800000000, 0x29fbebf100000000,\n    0x6aef90e600000000, 0xbb20293900000000, 0xf834522e00000000,\n    0x3d08df1700000000, 0x7e1ca40000000000, 0xb771c56400000000,\n    0xf465be7300000000, 0x3159334a00000000, 0x724d485d00000000,\n    0xd2c0312e00000000, 0x91d44a3900000000, 0x54e8c70000000000,\n    0x17fcbc1700000000, 0xde91dd7300000000, 0x9d85a66400000000,\n    0x58b92b5d00000000, 0x1bad504a00000000, 0xca62e99500000000,\n    0x8976928200000000, 0x4c4a1fbb00000000, 0x0f5e64ac00000000,\n    0xc63305c800000000, 0x85277edf00000000, 0x401bf3e600000000,\n    0x030f88f100000000, 0x070392de00000000, 0x4417e9c900000000,\n    0x812b64f000000000, 0xc23f1fe700000000, 0x0b527e8300000000,\n    0x4846059400000000, 0x8d7a88ad00000000, 0xce6ef3ba00000000,\n    0x1fa14a6500000000, 0x5cb5317200000000, 0x9989bc4b00000000,\n    0xda9dc75c00000000, 0x13f0a63800000000, 0x50e4dd2f00000000,\n    0x95d8501600000000, 0xd6cc2b0100000000, 0x7641527200000000,\n    0x3555296500000000, 0xf069a45c00000000, 0xb37ddf4b00000000,\n    0x7a10be2f00000000, 0x3904c53800000000, 0xfc38480100000000,\n    0xbf2c331600000000, 0x6ee38ac900000000, 0x2df7f1de00000000,\n    0xe8cb7ce700000000, 0xabdf07f000000000, 0x62b2669400000000,\n    0x21a61d8300000000, 0xe49a90ba00000000, 0xa78eebad00000000,\n    0xa481635c00000000, 0xe795184b00000000, 0x22a9957200000000,\n    0x61bdee6500000000, 0xa8d08f0100000000, 0xebc4f41600000000,\n    0x2ef8792f00000000, 0x6dec023800000000, 0xbc23bbe700000000,\n    0xff37c0f000000000, 0x3a0b4dc900000000, 0x791f36de00000000,\n    0xb07257ba00000000, 0xf3662cad00000000, 0x365aa19400000000,\n    0x754eda8300000000, 0xd5c3a3f000000000, 0x96d7d8e700000000,\n    0x53eb55de00000000, 0x10ff2ec900000000, 0xd9924fad00000000,\n    0x9a8634ba00000000, 0x5fbab98300000000, 0x1caec29400000000,\n    0xcd617b4b00000000, 0x8e75005c00000000, 0x4b498d6500000000,\n    0x085df67200000000, 0xc130971600000000, 0x8224ec0100000000,\n    0x4718613800000000, 0x040c1a2f00000000, 0x4f00556600000000,\n    0x0c142e7100000000, 0xc928a34800000000, 0x8a3cd85f00000000,\n    0x4351b93b00000000, 0x0045c22c00000000, 0xc5794f1500000000,\n    0x866d340200000000, 0x57a28ddd00000000, 0x14b6f6ca00000000,\n    0xd18a7bf300000000, 0x929e00e400000000, 0x5bf3618000000000,\n    0x18e71a9700000000, 0xdddb97ae00000000, 0x9ecfecb900000000,\n    0x3e4295ca00000000, 0x7d56eedd00000000, 0xb86a63e400000000,\n    0xfb7e18f300000000, 0x3213799700000000, 0x7107028000000000,\n    0xb43b8fb900000000, 0xf72ff4ae00000000, 0x26e04d7100000000,\n    0x65f4366600000000, 0xa0c8bb5f00000000, 0xe3dcc04800000000,\n    0x2ab1a12c00000000, 0x69a5da3b00000000, 0xac99570200000000,\n    0xef8d2c1500000000, 0xec82a4e400000000, 0xaf96dff300000000,\n    0x6aaa52ca00000000, 0x29be29dd00000000, 0xe0d348b900000000,\n    0xa3c733ae00000000, 0x66fbbe9700000000, 0x25efc58000000000,\n    0xf4207c5f00000000, 0xb734074800000000, 0x72088a7100000000,\n    0x311cf16600000000, 0xf871900200000000, 0xbb65eb1500000000,\n    0x7e59662c00000000, 0x3d4d1d3b00000000, 0x9dc0644800000000,\n    0xded41f5f00000000, 0x1be8926600000000, 0x58fce97100000000,\n    0x9191881500000000, 0xd285f30200000000, 0x17b97e3b00000000,\n    0x54ad052c00000000, 0x8562bcf300000000, 0xc676c7e400000000,\n    0x034a4add00000000, 0x405e31ca00000000, 0x893350ae00000000,\n    0xca272bb900000000, 0x0f1ba68000000000, 0x4c0fdd9700000000,\n    0x4803c7b800000000, 0x0b17bcaf00000000, 0xce2b319600000000,\n    0x8d3f4a8100000000, 0x44522be500000000, 0x074650f200000000,\n    0xc27addcb00000000, 0x816ea6dc00000000, 0x50a11f0300000000,\n    0x13b5641400000000, 0xd689e92d00000000, 0x959d923a00000000,\n    0x5cf0f35e00000000, 0x1fe4884900000000, 0xdad8057000000000,\n    0x99cc7e6700000000, 0x3941071400000000, 0x7a557c0300000000,\n    0xbf69f13a00000000, 0xfc7d8a2d00000000, 0x3510eb4900000000,\n    0x7604905e00000000, 0xb3381d6700000000, 0xf02c667000000000,\n    0x21e3dfaf00000000, 0x62f7a4b800000000, 0xa7cb298100000000,\n    0xe4df529600000000, 0x2db233f200000000, 0x6ea648e500000000,\n    0xab9ac5dc00000000, 0xe88ebecb00000000, 0xeb81363a00000000,\n    0xa8954d2d00000000, 0x6da9c01400000000, 0x2ebdbb0300000000,\n    0xe7d0da6700000000, 0xa4c4a17000000000, 0x61f82c4900000000,\n    0x22ec575e00000000, 0xf323ee8100000000, 0xb037959600000000,\n    0x750b18af00000000, 0x361f63b800000000, 0xff7202dc00000000,\n    0xbc6679cb00000000, 0x795af4f200000000, 0x3a4e8fe500000000,\n    0x9ac3f69600000000, 0xd9d78d8100000000, 0x1ceb00b800000000,\n    0x5fff7baf00000000, 0x96921acb00000000, 0xd58661dc00000000,\n    0x10baece500000000, 0x53ae97f200000000, 0x82612e2d00000000,\n    0xc175553a00000000, 0x0449d80300000000, 0x475da31400000000,\n    0x8e30c27000000000, 0xcd24b96700000000, 0x0818345e00000000,\n    0x4b0c4f4900000000},\n   {0x0000000000000000, 0x3e6bc2ef00000000, 0x3dd0f50400000000,\n    0x03bb37eb00000000, 0x7aa0eb0900000000, 0x44cb29e600000000,\n    0x47701e0d00000000, 0x791bdce200000000, 0xf440d71300000000,\n    0xca2b15fc00000000, 0xc990221700000000, 0xf7fbe0f800000000,\n    0x8ee03c1a00000000, 0xb08bfef500000000, 0xb330c91e00000000,\n    0x8d5b0bf100000000, 0xe881ae2700000000, 0xd6ea6cc800000000,\n    0xd5515b2300000000, 0xeb3a99cc00000000, 0x9221452e00000000,\n    0xac4a87c100000000, 0xaff1b02a00000000, 0x919a72c500000000,\n    0x1cc1793400000000, 0x22aabbdb00000000, 0x21118c3000000000,\n    0x1f7a4edf00000000, 0x6661923d00000000, 0x580a50d200000000,\n    0x5bb1673900000000, 0x65daa5d600000000, 0xd0035d4f00000000,\n    0xee689fa000000000, 0xedd3a84b00000000, 0xd3b86aa400000000,\n    0xaaa3b64600000000, 0x94c874a900000000, 0x9773434200000000,\n    0xa91881ad00000000, 0x24438a5c00000000, 0x1a2848b300000000,\n    0x19937f5800000000, 0x27f8bdb700000000, 0x5ee3615500000000,\n    0x6088a3ba00000000, 0x6333945100000000, 0x5d5856be00000000,\n    0x3882f36800000000, 0x06e9318700000000, 0x0552066c00000000,\n    0x3b39c48300000000, 0x4222186100000000, 0x7c49da8e00000000,\n    0x7ff2ed6500000000, 0x41992f8a00000000, 0xccc2247b00000000,\n    0xf2a9e69400000000, 0xf112d17f00000000, 0xcf79139000000000,\n    0xb662cf7200000000, 0x88090d9d00000000, 0x8bb23a7600000000,\n    0xb5d9f89900000000, 0xa007ba9e00000000, 0x9e6c787100000000,\n    0x9dd74f9a00000000, 0xa3bc8d7500000000, 0xdaa7519700000000,\n    0xe4cc937800000000, 0xe777a49300000000, 0xd91c667c00000000,\n    0x54476d8d00000000, 0x6a2caf6200000000, 0x6997988900000000,\n    0x57fc5a6600000000, 0x2ee7868400000000, 0x108c446b00000000,\n    0x1337738000000000, 0x2d5cb16f00000000, 0x488614b900000000,\n    0x76edd65600000000, 0x7556e1bd00000000, 0x4b3d235200000000,\n    0x3226ffb000000000, 0x0c4d3d5f00000000, 0x0ff60ab400000000,\n    0x319dc85b00000000, 0xbcc6c3aa00000000, 0x82ad014500000000,\n    0x811636ae00000000, 0xbf7df44100000000, 0xc66628a300000000,\n    0xf80dea4c00000000, 0xfbb6dda700000000, 0xc5dd1f4800000000,\n    0x7004e7d100000000, 0x4e6f253e00000000, 0x4dd412d500000000,\n    0x73bfd03a00000000, 0x0aa40cd800000000, 0x34cfce3700000000,\n    0x3774f9dc00000000, 0x091f3b3300000000, 0x844430c200000000,\n    0xba2ff22d00000000, 0xb994c5c600000000, 0x87ff072900000000,\n    0xfee4dbcb00000000, 0xc08f192400000000, 0xc3342ecf00000000,\n    0xfd5fec2000000000, 0x988549f600000000, 0xa6ee8b1900000000,\n    0xa555bcf200000000, 0x9b3e7e1d00000000, 0xe225a2ff00000000,\n    0xdc4e601000000000, 0xdff557fb00000000, 0xe19e951400000000,\n    0x6cc59ee500000000, 0x52ae5c0a00000000, 0x51156be100000000,\n    0x6f7ea90e00000000, 0x166575ec00000000, 0x280eb70300000000,\n    0x2bb580e800000000, 0x15de420700000000, 0x010905e600000000,\n    0x3f62c70900000000, 0x3cd9f0e200000000, 0x02b2320d00000000,\n    0x7ba9eeef00000000, 0x45c22c0000000000, 0x46791beb00000000,\n    0x7812d90400000000, 0xf549d2f500000000, 0xcb22101a00000000,\n    0xc89927f100000000, 0xf6f2e51e00000000, 0x8fe939fc00000000,\n    0xb182fb1300000000, 0xb239ccf800000000, 0x8c520e1700000000,\n    0xe988abc100000000, 0xd7e3692e00000000, 0xd4585ec500000000,\n    0xea339c2a00000000, 0x932840c800000000, 0xad43822700000000,\n    0xaef8b5cc00000000, 0x9093772300000000, 0x1dc87cd200000000,\n    0x23a3be3d00000000, 0x201889d600000000, 0x1e734b3900000000,\n    0x676897db00000000, 0x5903553400000000, 0x5ab862df00000000,\n    0x64d3a03000000000, 0xd10a58a900000000, 0xef619a4600000000,\n    0xecdaadad00000000, 0xd2b16f4200000000, 0xabaab3a000000000,\n    0x95c1714f00000000, 0x967a46a400000000, 0xa811844b00000000,\n    0x254a8fba00000000, 0x1b214d5500000000, 0x189a7abe00000000,\n    0x26f1b85100000000, 0x5fea64b300000000, 0x6181a65c00000000,\n    0x623a91b700000000, 0x5c51535800000000, 0x398bf68e00000000,\n    0x07e0346100000000, 0x045b038a00000000, 0x3a30c16500000000,\n    0x432b1d8700000000, 0x7d40df6800000000, 0x7efbe88300000000,\n    0x40902a6c00000000, 0xcdcb219d00000000, 0xf3a0e37200000000,\n    0xf01bd49900000000, 0xce70167600000000, 0xb76bca9400000000,\n    0x8900087b00000000, 0x8abb3f9000000000, 0xb4d0fd7f00000000,\n    0xa10ebf7800000000, 0x9f657d9700000000, 0x9cde4a7c00000000,\n    0xa2b5889300000000, 0xdbae547100000000, 0xe5c5969e00000000,\n    0xe67ea17500000000, 0xd815639a00000000, 0x554e686b00000000,\n    0x6b25aa8400000000, 0x689e9d6f00000000, 0x56f55f8000000000,\n    0x2fee836200000000, 0x1185418d00000000, 0x123e766600000000,\n    0x2c55b48900000000, 0x498f115f00000000, 0x77e4d3b000000000,\n    0x745fe45b00000000, 0x4a3426b400000000, 0x332ffa5600000000,\n    0x0d4438b900000000, 0x0eff0f5200000000, 0x3094cdbd00000000,\n    0xbdcfc64c00000000, 0x83a404a300000000, 0x801f334800000000,\n    0xbe74f1a700000000, 0xc76f2d4500000000, 0xf904efaa00000000,\n    0xfabfd84100000000, 0xc4d41aae00000000, 0x710de23700000000,\n    0x4f6620d800000000, 0x4cdd173300000000, 0x72b6d5dc00000000,\n    0x0bad093e00000000, 0x35c6cbd100000000, 0x367dfc3a00000000,\n    0x08163ed500000000, 0x854d352400000000, 0xbb26f7cb00000000,\n    0xb89dc02000000000, 0x86f602cf00000000, 0xffedde2d00000000,\n    0xc1861cc200000000, 0xc23d2b2900000000, 0xfc56e9c600000000,\n    0x998c4c1000000000, 0xa7e78eff00000000, 0xa45cb91400000000,\n    0x9a377bfb00000000, 0xe32ca71900000000, 0xdd4765f600000000,\n    0xdefc521d00000000, 0xe09790f200000000, 0x6dcc9b0300000000,\n    0x53a759ec00000000, 0x501c6e0700000000, 0x6e77ace800000000,\n    0x176c700a00000000, 0x2907b2e500000000, 0x2abc850e00000000,\n    0x14d747e100000000},\n   {0x0000000000000000, 0xc0df8ec100000000, 0xc1b96c5800000000,\n    0x0166e29900000000, 0x8273d9b000000000, 0x42ac577100000000,\n    0x43cab5e800000000, 0x83153b2900000000, 0x45e1c3ba00000000,\n    0x853e4d7b00000000, 0x8458afe200000000, 0x4487212300000000,\n    0xc7921a0a00000000, 0x074d94cb00000000, 0x062b765200000000,\n    0xc6f4f89300000000, 0xcbc4f6ae00000000, 0x0b1b786f00000000,\n    0x0a7d9af600000000, 0xcaa2143700000000, 0x49b72f1e00000000,\n    0x8968a1df00000000, 0x880e434600000000, 0x48d1cd8700000000,\n    0x8e25351400000000, 0x4efabbd500000000, 0x4f9c594c00000000,\n    0x8f43d78d00000000, 0x0c56eca400000000, 0xcc89626500000000,\n    0xcdef80fc00000000, 0x0d300e3d00000000, 0xd78f9c8600000000,\n    0x1750124700000000, 0x1636f0de00000000, 0xd6e97e1f00000000,\n    0x55fc453600000000, 0x9523cbf700000000, 0x9445296e00000000,\n    0x549aa7af00000000, 0x926e5f3c00000000, 0x52b1d1fd00000000,\n    0x53d7336400000000, 0x9308bda500000000, 0x101d868c00000000,\n    0xd0c2084d00000000, 0xd1a4ead400000000, 0x117b641500000000,\n    0x1c4b6a2800000000, 0xdc94e4e900000000, 0xddf2067000000000,\n    0x1d2d88b100000000, 0x9e38b39800000000, 0x5ee73d5900000000,\n    0x5f81dfc000000000, 0x9f5e510100000000, 0x59aaa99200000000,\n    0x9975275300000000, 0x9813c5ca00000000, 0x58cc4b0b00000000,\n    0xdbd9702200000000, 0x1b06fee300000000, 0x1a601c7a00000000,\n    0xdabf92bb00000000, 0xef1948d600000000, 0x2fc6c61700000000,\n    0x2ea0248e00000000, 0xee7faa4f00000000, 0x6d6a916600000000,\n    0xadb51fa700000000, 0xacd3fd3e00000000, 0x6c0c73ff00000000,\n    0xaaf88b6c00000000, 0x6a2705ad00000000, 0x6b41e73400000000,\n    0xab9e69f500000000, 0x288b52dc00000000, 0xe854dc1d00000000,\n    0xe9323e8400000000, 0x29edb04500000000, 0x24ddbe7800000000,\n    0xe40230b900000000, 0xe564d22000000000, 0x25bb5ce100000000,\n    0xa6ae67c800000000, 0x6671e90900000000, 0x67170b9000000000,\n    0xa7c8855100000000, 0x613c7dc200000000, 0xa1e3f30300000000,\n    0xa085119a00000000, 0x605a9f5b00000000, 0xe34fa47200000000,\n    0x23902ab300000000, 0x22f6c82a00000000, 0xe22946eb00000000,\n    0x3896d45000000000, 0xf8495a9100000000, 0xf92fb80800000000,\n    0x39f036c900000000, 0xbae50de000000000, 0x7a3a832100000000,\n    0x7b5c61b800000000, 0xbb83ef7900000000, 0x7d7717ea00000000,\n    0xbda8992b00000000, 0xbcce7bb200000000, 0x7c11f57300000000,\n    0xff04ce5a00000000, 0x3fdb409b00000000, 0x3ebda20200000000,\n    0xfe622cc300000000, 0xf35222fe00000000, 0x338dac3f00000000,\n    0x32eb4ea600000000, 0xf234c06700000000, 0x7121fb4e00000000,\n    0xb1fe758f00000000, 0xb098971600000000, 0x704719d700000000,\n    0xb6b3e14400000000, 0x766c6f8500000000, 0x770a8d1c00000000,\n    0xb7d503dd00000000, 0x34c038f400000000, 0xf41fb63500000000,\n    0xf57954ac00000000, 0x35a6da6d00000000, 0x9f35e17700000000,\n    0x5fea6fb600000000, 0x5e8c8d2f00000000, 0x9e5303ee00000000,\n    0x1d4638c700000000, 0xdd99b60600000000, 0xdcff549f00000000,\n    0x1c20da5e00000000, 0xdad422cd00000000, 0x1a0bac0c00000000,\n    0x1b6d4e9500000000, 0xdbb2c05400000000, 0x58a7fb7d00000000,\n    0x987875bc00000000, 0x991e972500000000, 0x59c119e400000000,\n    0x54f117d900000000, 0x942e991800000000, 0x95487b8100000000,\n    0x5597f54000000000, 0xd682ce6900000000, 0x165d40a800000000,\n    0x173ba23100000000, 0xd7e42cf000000000, 0x1110d46300000000,\n    0xd1cf5aa200000000, 0xd0a9b83b00000000, 0x107636fa00000000,\n    0x93630dd300000000, 0x53bc831200000000, 0x52da618b00000000,\n    0x9205ef4a00000000, 0x48ba7df100000000, 0x8865f33000000000,\n    0x890311a900000000, 0x49dc9f6800000000, 0xcac9a44100000000,\n    0x0a162a8000000000, 0x0b70c81900000000, 0xcbaf46d800000000,\n    0x0d5bbe4b00000000, 0xcd84308a00000000, 0xcce2d21300000000,\n    0x0c3d5cd200000000, 0x8f2867fb00000000, 0x4ff7e93a00000000,\n    0x4e910ba300000000, 0x8e4e856200000000, 0x837e8b5f00000000,\n    0x43a1059e00000000, 0x42c7e70700000000, 0x821869c600000000,\n    0x010d52ef00000000, 0xc1d2dc2e00000000, 0xc0b43eb700000000,\n    0x006bb07600000000, 0xc69f48e500000000, 0x0640c62400000000,\n    0x072624bd00000000, 0xc7f9aa7c00000000, 0x44ec915500000000,\n    0x84331f9400000000, 0x8555fd0d00000000, 0x458a73cc00000000,\n    0x702ca9a100000000, 0xb0f3276000000000, 0xb195c5f900000000,\n    0x714a4b3800000000, 0xf25f701100000000, 0x3280fed000000000,\n    0x33e61c4900000000, 0xf339928800000000, 0x35cd6a1b00000000,\n    0xf512e4da00000000, 0xf474064300000000, 0x34ab888200000000,\n    0xb7beb3ab00000000, 0x77613d6a00000000, 0x7607dff300000000,\n    0xb6d8513200000000, 0xbbe85f0f00000000, 0x7b37d1ce00000000,\n    0x7a51335700000000, 0xba8ebd9600000000, 0x399b86bf00000000,\n    0xf944087e00000000, 0xf822eae700000000, 0x38fd642600000000,\n    0xfe099cb500000000, 0x3ed6127400000000, 0x3fb0f0ed00000000,\n    0xff6f7e2c00000000, 0x7c7a450500000000, 0xbca5cbc400000000,\n    0xbdc3295d00000000, 0x7d1ca79c00000000, 0xa7a3352700000000,\n    0x677cbbe600000000, 0x661a597f00000000, 0xa6c5d7be00000000,\n    0x25d0ec9700000000, 0xe50f625600000000, 0xe46980cf00000000,\n    0x24b60e0e00000000, 0xe242f69d00000000, 0x229d785c00000000,\n    0x23fb9ac500000000, 0xe324140400000000, 0x60312f2d00000000,\n    0xa0eea1ec00000000, 0xa188437500000000, 0x6157cdb400000000,\n    0x6c67c38900000000, 0xacb84d4800000000, 0xaddeafd100000000,\n    0x6d01211000000000, 0xee141a3900000000, 0x2ecb94f800000000,\n    0x2fad766100000000, 0xef72f8a000000000, 0x2986003300000000,\n    0xe9598ef200000000, 0xe83f6c6b00000000, 0x28e0e2aa00000000,\n    0xabf5d98300000000, 0x6b2a574200000000, 0x6a4cb5db00000000,\n    0xaa933b1a00000000},\n   {0x0000000000000000, 0x6f4ca59b00000000, 0x9f9e3bec00000000,\n    0xf0d29e7700000000, 0x7f3b060300000000, 0x1077a39800000000,\n    0xe0a53def00000000, 0x8fe9987400000000, 0xfe760c0600000000,\n    0x913aa99d00000000, 0x61e837ea00000000, 0x0ea4927100000000,\n    0x814d0a0500000000, 0xee01af9e00000000, 0x1ed331e900000000,\n    0x719f947200000000, 0xfced180c00000000, 0x93a1bd9700000000,\n    0x637323e000000000, 0x0c3f867b00000000, 0x83d61e0f00000000,\n    0xec9abb9400000000, 0x1c4825e300000000, 0x7304807800000000,\n    0x029b140a00000000, 0x6dd7b19100000000, 0x9d052fe600000000,\n    0xf2498a7d00000000, 0x7da0120900000000, 0x12ecb79200000000,\n    0xe23e29e500000000, 0x8d728c7e00000000, 0xf8db311800000000,\n    0x9797948300000000, 0x67450af400000000, 0x0809af6f00000000,\n    0x87e0371b00000000, 0xe8ac928000000000, 0x187e0cf700000000,\n    0x7732a96c00000000, 0x06ad3d1e00000000, 0x69e1988500000000,\n    0x993306f200000000, 0xf67fa36900000000, 0x79963b1d00000000,\n    0x16da9e8600000000, 0xe60800f100000000, 0x8944a56a00000000,\n    0x0436291400000000, 0x6b7a8c8f00000000, 0x9ba812f800000000,\n    0xf4e4b76300000000, 0x7b0d2f1700000000, 0x14418a8c00000000,\n    0xe49314fb00000000, 0x8bdfb16000000000, 0xfa40251200000000,\n    0x950c808900000000, 0x65de1efe00000000, 0x0a92bb6500000000,\n    0x857b231100000000, 0xea37868a00000000, 0x1ae518fd00000000,\n    0x75a9bd6600000000, 0xf0b7633000000000, 0x9ffbc6ab00000000,\n    0x6f2958dc00000000, 0x0065fd4700000000, 0x8f8c653300000000,\n    0xe0c0c0a800000000, 0x10125edf00000000, 0x7f5efb4400000000,\n    0x0ec16f3600000000, 0x618dcaad00000000, 0x915f54da00000000,\n    0xfe13f14100000000, 0x71fa693500000000, 0x1eb6ccae00000000,\n    0xee6452d900000000, 0x8128f74200000000, 0x0c5a7b3c00000000,\n    0x6316dea700000000, 0x93c440d000000000, 0xfc88e54b00000000,\n    0x73617d3f00000000, 0x1c2dd8a400000000, 0xecff46d300000000,\n    0x83b3e34800000000, 0xf22c773a00000000, 0x9d60d2a100000000,\n    0x6db24cd600000000, 0x02fee94d00000000, 0x8d17713900000000,\n    0xe25bd4a200000000, 0x12894ad500000000, 0x7dc5ef4e00000000,\n    0x086c522800000000, 0x6720f7b300000000, 0x97f269c400000000,\n    0xf8becc5f00000000, 0x7757542b00000000, 0x181bf1b000000000,\n    0xe8c96fc700000000, 0x8785ca5c00000000, 0xf61a5e2e00000000,\n    0x9956fbb500000000, 0x698465c200000000, 0x06c8c05900000000,\n    0x8921582d00000000, 0xe66dfdb600000000, 0x16bf63c100000000,\n    0x79f3c65a00000000, 0xf4814a2400000000, 0x9bcdefbf00000000,\n    0x6b1f71c800000000, 0x0453d45300000000, 0x8bba4c2700000000,\n    0xe4f6e9bc00000000, 0x142477cb00000000, 0x7b68d25000000000,\n    0x0af7462200000000, 0x65bbe3b900000000, 0x95697dce00000000,\n    0xfa25d85500000000, 0x75cc402100000000, 0x1a80e5ba00000000,\n    0xea527bcd00000000, 0x851ede5600000000, 0xe06fc76000000000,\n    0x8f2362fb00000000, 0x7ff1fc8c00000000, 0x10bd591700000000,\n    0x9f54c16300000000, 0xf01864f800000000, 0x00cafa8f00000000,\n    0x6f865f1400000000, 0x1e19cb6600000000, 0x71556efd00000000,\n    0x8187f08a00000000, 0xeecb551100000000, 0x6122cd6500000000,\n    0x0e6e68fe00000000, 0xfebcf68900000000, 0x91f0531200000000,\n    0x1c82df6c00000000, 0x73ce7af700000000, 0x831ce48000000000,\n    0xec50411b00000000, 0x63b9d96f00000000, 0x0cf57cf400000000,\n    0xfc27e28300000000, 0x936b471800000000, 0xe2f4d36a00000000,\n    0x8db876f100000000, 0x7d6ae88600000000, 0x12264d1d00000000,\n    0x9dcfd56900000000, 0xf28370f200000000, 0x0251ee8500000000,\n    0x6d1d4b1e00000000, 0x18b4f67800000000, 0x77f853e300000000,\n    0x872acd9400000000, 0xe866680f00000000, 0x678ff07b00000000,\n    0x08c355e000000000, 0xf811cb9700000000, 0x975d6e0c00000000,\n    0xe6c2fa7e00000000, 0x898e5fe500000000, 0x795cc19200000000,\n    0x1610640900000000, 0x99f9fc7d00000000, 0xf6b559e600000000,\n    0x0667c79100000000, 0x692b620a00000000, 0xe459ee7400000000,\n    0x8b154bef00000000, 0x7bc7d59800000000, 0x148b700300000000,\n    0x9b62e87700000000, 0xf42e4dec00000000, 0x04fcd39b00000000,\n    0x6bb0760000000000, 0x1a2fe27200000000, 0x756347e900000000,\n    0x85b1d99e00000000, 0xeafd7c0500000000, 0x6514e47100000000,\n    0x0a5841ea00000000, 0xfa8adf9d00000000, 0x95c67a0600000000,\n    0x10d8a45000000000, 0x7f9401cb00000000, 0x8f469fbc00000000,\n    0xe00a3a2700000000, 0x6fe3a25300000000, 0x00af07c800000000,\n    0xf07d99bf00000000, 0x9f313c2400000000, 0xeeaea85600000000,\n    0x81e20dcd00000000, 0x713093ba00000000, 0x1e7c362100000000,\n    0x9195ae5500000000, 0xfed90bce00000000, 0x0e0b95b900000000,\n    0x6147302200000000, 0xec35bc5c00000000, 0x837919c700000000,\n    0x73ab87b000000000, 0x1ce7222b00000000, 0x930eba5f00000000,\n    0xfc421fc400000000, 0x0c9081b300000000, 0x63dc242800000000,\n    0x1243b05a00000000, 0x7d0f15c100000000, 0x8ddd8bb600000000,\n    0xe2912e2d00000000, 0x6d78b65900000000, 0x023413c200000000,\n    0xf2e68db500000000, 0x9daa282e00000000, 0xe803954800000000,\n    0x874f30d300000000, 0x779daea400000000, 0x18d10b3f00000000,\n    0x9738934b00000000, 0xf87436d000000000, 0x08a6a8a700000000,\n    0x67ea0d3c00000000, 0x1675994e00000000, 0x79393cd500000000,\n    0x89eba2a200000000, 0xe6a7073900000000, 0x694e9f4d00000000,\n    0x06023ad600000000, 0xf6d0a4a100000000, 0x999c013a00000000,\n    0x14ee8d4400000000, 0x7ba228df00000000, 0x8b70b6a800000000,\n    0xe43c133300000000, 0x6bd58b4700000000, 0x04992edc00000000,\n    0xf44bb0ab00000000, 0x9b07153000000000, 0xea98814200000000,\n    0x85d424d900000000, 0x7506baae00000000, 0x1a4a1f3500000000,\n    0x95a3874100000000, 0xfaef22da00000000, 0x0a3dbcad00000000,\n    0x6571193600000000},\n   {0x0000000000000000, 0x85d996dd00000000, 0x4bb55c6000000000,\n    0xce6ccabd00000000, 0x966ab9c000000000, 0x13b32f1d00000000,\n    0xdddfe5a000000000, 0x5806737d00000000, 0x6dd3035a00000000,\n    0xe80a958700000000, 0x26665f3a00000000, 0xa3bfc9e700000000,\n    0xfbb9ba9a00000000, 0x7e602c4700000000, 0xb00ce6fa00000000,\n    0x35d5702700000000, 0xdaa607b400000000, 0x5f7f916900000000,\n    0x91135bd400000000, 0x14cacd0900000000, 0x4cccbe7400000000,\n    0xc91528a900000000, 0x0779e21400000000, 0x82a074c900000000,\n    0xb77504ee00000000, 0x32ac923300000000, 0xfcc0588e00000000,\n    0x7919ce5300000000, 0x211fbd2e00000000, 0xa4c62bf300000000,\n    0x6aaae14e00000000, 0xef73779300000000, 0xf54b7eb300000000,\n    0x7092e86e00000000, 0xbefe22d300000000, 0x3b27b40e00000000,\n    0x6321c77300000000, 0xe6f851ae00000000, 0x28949b1300000000,\n    0xad4d0dce00000000, 0x98987de900000000, 0x1d41eb3400000000,\n    0xd32d218900000000, 0x56f4b75400000000, 0x0ef2c42900000000,\n    0x8b2b52f400000000, 0x4547984900000000, 0xc09e0e9400000000,\n    0x2fed790700000000, 0xaa34efda00000000, 0x6458256700000000,\n    0xe181b3ba00000000, 0xb987c0c700000000, 0x3c5e561a00000000,\n    0xf2329ca700000000, 0x77eb0a7a00000000, 0x423e7a5d00000000,\n    0xc7e7ec8000000000, 0x098b263d00000000, 0x8c52b0e000000000,\n    0xd454c39d00000000, 0x518d554000000000, 0x9fe19ffd00000000,\n    0x1a38092000000000, 0xab918dbd00000000, 0x2e481b6000000000,\n    0xe024d1dd00000000, 0x65fd470000000000, 0x3dfb347d00000000,\n    0xb822a2a000000000, 0x764e681d00000000, 0xf397fec000000000,\n    0xc6428ee700000000, 0x439b183a00000000, 0x8df7d28700000000,\n    0x082e445a00000000, 0x5028372700000000, 0xd5f1a1fa00000000,\n    0x1b9d6b4700000000, 0x9e44fd9a00000000, 0x71378a0900000000,\n    0xf4ee1cd400000000, 0x3a82d66900000000, 0xbf5b40b400000000,\n    0xe75d33c900000000, 0x6284a51400000000, 0xace86fa900000000,\n    0x2931f97400000000, 0x1ce4895300000000, 0x993d1f8e00000000,\n    0x5751d53300000000, 0xd28843ee00000000, 0x8a8e309300000000,\n    0x0f57a64e00000000, 0xc13b6cf300000000, 0x44e2fa2e00000000,\n    0x5edaf30e00000000, 0xdb0365d300000000, 0x156faf6e00000000,\n    0x90b639b300000000, 0xc8b04ace00000000, 0x4d69dc1300000000,\n    0x830516ae00000000, 0x06dc807300000000, 0x3309f05400000000,\n    0xb6d0668900000000, 0x78bcac3400000000, 0xfd653ae900000000,\n    0xa563499400000000, 0x20badf4900000000, 0xeed615f400000000,\n    0x6b0f832900000000, 0x847cf4ba00000000, 0x01a5626700000000,\n    0xcfc9a8da00000000, 0x4a103e0700000000, 0x12164d7a00000000,\n    0x97cfdba700000000, 0x59a3111a00000000, 0xdc7a87c700000000,\n    0xe9aff7e000000000, 0x6c76613d00000000, 0xa21aab8000000000,\n    0x27c33d5d00000000, 0x7fc54e2000000000, 0xfa1cd8fd00000000,\n    0x3470124000000000, 0xb1a9849d00000000, 0x17256aa000000000,\n    0x92fcfc7d00000000, 0x5c9036c000000000, 0xd949a01d00000000,\n    0x814fd36000000000, 0x049645bd00000000, 0xcafa8f0000000000,\n    0x4f2319dd00000000, 0x7af669fa00000000, 0xff2fff2700000000,\n    0x3143359a00000000, 0xb49aa34700000000, 0xec9cd03a00000000,\n    0x694546e700000000, 0xa7298c5a00000000, 0x22f01a8700000000,\n    0xcd836d1400000000, 0x485afbc900000000, 0x8636317400000000,\n    0x03efa7a900000000, 0x5be9d4d400000000, 0xde30420900000000,\n    0x105c88b400000000, 0x95851e6900000000, 0xa0506e4e00000000,\n    0x2589f89300000000, 0xebe5322e00000000, 0x6e3ca4f300000000,\n    0x363ad78e00000000, 0xb3e3415300000000, 0x7d8f8bee00000000,\n    0xf8561d3300000000, 0xe26e141300000000, 0x67b782ce00000000,\n    0xa9db487300000000, 0x2c02deae00000000, 0x7404add300000000,\n    0xf1dd3b0e00000000, 0x3fb1f1b300000000, 0xba68676e00000000,\n    0x8fbd174900000000, 0x0a64819400000000, 0xc4084b2900000000,\n    0x41d1ddf400000000, 0x19d7ae8900000000, 0x9c0e385400000000,\n    0x5262f2e900000000, 0xd7bb643400000000, 0x38c813a700000000,\n    0xbd11857a00000000, 0x737d4fc700000000, 0xf6a4d91a00000000,\n    0xaea2aa6700000000, 0x2b7b3cba00000000, 0xe517f60700000000,\n    0x60ce60da00000000, 0x551b10fd00000000, 0xd0c2862000000000,\n    0x1eae4c9d00000000, 0x9b77da4000000000, 0xc371a93d00000000,\n    0x46a83fe000000000, 0x88c4f55d00000000, 0x0d1d638000000000,\n    0xbcb4e71d00000000, 0x396d71c000000000, 0xf701bb7d00000000,\n    0x72d82da000000000, 0x2ade5edd00000000, 0xaf07c80000000000,\n    0x616b02bd00000000, 0xe4b2946000000000, 0xd167e44700000000,\n    0x54be729a00000000, 0x9ad2b82700000000, 0x1f0b2efa00000000,\n    0x470d5d8700000000, 0xc2d4cb5a00000000, 0x0cb801e700000000,\n    0x8961973a00000000, 0x6612e0a900000000, 0xe3cb767400000000,\n    0x2da7bcc900000000, 0xa87e2a1400000000, 0xf078596900000000,\n    0x75a1cfb400000000, 0xbbcd050900000000, 0x3e1493d400000000,\n    0x0bc1e3f300000000, 0x8e18752e00000000, 0x4074bf9300000000,\n    0xc5ad294e00000000, 0x9dab5a3300000000, 0x1872ccee00000000,\n    0xd61e065300000000, 0x53c7908e00000000, 0x49ff99ae00000000,\n    0xcc260f7300000000, 0x024ac5ce00000000, 0x8793531300000000,\n    0xdf95206e00000000, 0x5a4cb6b300000000, 0x94207c0e00000000,\n    0x11f9ead300000000, 0x242c9af400000000, 0xa1f50c2900000000,\n    0x6f99c69400000000, 0xea40504900000000, 0xb246233400000000,\n    0x379fb5e900000000, 0xf9f37f5400000000, 0x7c2ae98900000000,\n    0x93599e1a00000000, 0x168008c700000000, 0xd8ecc27a00000000,\n    0x5d3554a700000000, 0x053327da00000000, 0x80eab10700000000,\n    0x4e867bba00000000, 0xcb5fed6700000000, 0xfe8a9d4000000000,\n    0x7b530b9d00000000, 0xb53fc12000000000, 0x30e657fd00000000,\n    0x68e0248000000000, 0xed39b25d00000000, 0x235578e000000000,\n    0xa68cee3d00000000},\n   {0x0000000000000000, 0x76e10f9d00000000, 0xadc46ee100000000,\n    0xdb25617c00000000, 0x1b8fac1900000000, 0x6d6ea38400000000,\n    0xb64bc2f800000000, 0xc0aacd6500000000, 0x361e593300000000,\n    0x40ff56ae00000000, 0x9bda37d200000000, 0xed3b384f00000000,\n    0x2d91f52a00000000, 0x5b70fab700000000, 0x80559bcb00000000,\n    0xf6b4945600000000, 0x6c3cb26600000000, 0x1addbdfb00000000,\n    0xc1f8dc8700000000, 0xb719d31a00000000, 0x77b31e7f00000000,\n    0x015211e200000000, 0xda77709e00000000, 0xac967f0300000000,\n    0x5a22eb5500000000, 0x2cc3e4c800000000, 0xf7e685b400000000,\n    0x81078a2900000000, 0x41ad474c00000000, 0x374c48d100000000,\n    0xec6929ad00000000, 0x9a88263000000000, 0xd87864cd00000000,\n    0xae996b5000000000, 0x75bc0a2c00000000, 0x035d05b100000000,\n    0xc3f7c8d400000000, 0xb516c74900000000, 0x6e33a63500000000,\n    0x18d2a9a800000000, 0xee663dfe00000000, 0x9887326300000000,\n    0x43a2531f00000000, 0x35435c8200000000, 0xf5e991e700000000,\n    0x83089e7a00000000, 0x582dff0600000000, 0x2eccf09b00000000,\n    0xb444d6ab00000000, 0xc2a5d93600000000, 0x1980b84a00000000,\n    0x6f61b7d700000000, 0xafcb7ab200000000, 0xd92a752f00000000,\n    0x020f145300000000, 0x74ee1bce00000000, 0x825a8f9800000000,\n    0xf4bb800500000000, 0x2f9ee17900000000, 0x597feee400000000,\n    0x99d5238100000000, 0xef342c1c00000000, 0x34114d6000000000,\n    0x42f042fd00000000, 0xf1f7b94100000000, 0x8716b6dc00000000,\n    0x5c33d7a000000000, 0x2ad2d83d00000000, 0xea78155800000000,\n    0x9c991ac500000000, 0x47bc7bb900000000, 0x315d742400000000,\n    0xc7e9e07200000000, 0xb108efef00000000, 0x6a2d8e9300000000,\n    0x1ccc810e00000000, 0xdc664c6b00000000, 0xaa8743f600000000,\n    0x71a2228a00000000, 0x07432d1700000000, 0x9dcb0b2700000000,\n    0xeb2a04ba00000000, 0x300f65c600000000, 0x46ee6a5b00000000,\n    0x8644a73e00000000, 0xf0a5a8a300000000, 0x2b80c9df00000000,\n    0x5d61c64200000000, 0xabd5521400000000, 0xdd345d8900000000,\n    0x06113cf500000000, 0x70f0336800000000, 0xb05afe0d00000000,\n    0xc6bbf19000000000, 0x1d9e90ec00000000, 0x6b7f9f7100000000,\n    0x298fdd8c00000000, 0x5f6ed21100000000, 0x844bb36d00000000,\n    0xf2aabcf000000000, 0x3200719500000000, 0x44e17e0800000000,\n    0x9fc41f7400000000, 0xe92510e900000000, 0x1f9184bf00000000,\n    0x69708b2200000000, 0xb255ea5e00000000, 0xc4b4e5c300000000,\n    0x041e28a600000000, 0x72ff273b00000000, 0xa9da464700000000,\n    0xdf3b49da00000000, 0x45b36fea00000000, 0x3352607700000000,\n    0xe877010b00000000, 0x9e960e9600000000, 0x5e3cc3f300000000,\n    0x28ddcc6e00000000, 0xf3f8ad1200000000, 0x8519a28f00000000,\n    0x73ad36d900000000, 0x054c394400000000, 0xde69583800000000,\n    0xa88857a500000000, 0x68229ac000000000, 0x1ec3955d00000000,\n    0xc5e6f42100000000, 0xb307fbbc00000000, 0xe2ef738300000000,\n    0x940e7c1e00000000, 0x4f2b1d6200000000, 0x39ca12ff00000000,\n    0xf960df9a00000000, 0x8f81d00700000000, 0x54a4b17b00000000,\n    0x2245bee600000000, 0xd4f12ab000000000, 0xa210252d00000000,\n    0x7935445100000000, 0x0fd44bcc00000000, 0xcf7e86a900000000,\n    0xb99f893400000000, 0x62bae84800000000, 0x145be7d500000000,\n    0x8ed3c1e500000000, 0xf832ce7800000000, 0x2317af0400000000,\n    0x55f6a09900000000, 0x955c6dfc00000000, 0xe3bd626100000000,\n    0x3898031d00000000, 0x4e790c8000000000, 0xb8cd98d600000000,\n    0xce2c974b00000000, 0x1509f63700000000, 0x63e8f9aa00000000,\n    0xa34234cf00000000, 0xd5a33b5200000000, 0x0e865a2e00000000,\n    0x786755b300000000, 0x3a97174e00000000, 0x4c7618d300000000,\n    0x975379af00000000, 0xe1b2763200000000, 0x2118bb5700000000,\n    0x57f9b4ca00000000, 0x8cdcd5b600000000, 0xfa3dda2b00000000,\n    0x0c894e7d00000000, 0x7a6841e000000000, 0xa14d209c00000000,\n    0xd7ac2f0100000000, 0x1706e26400000000, 0x61e7edf900000000,\n    0xbac28c8500000000, 0xcc23831800000000, 0x56aba52800000000,\n    0x204aaab500000000, 0xfb6fcbc900000000, 0x8d8ec45400000000,\n    0x4d24093100000000, 0x3bc506ac00000000, 0xe0e067d000000000,\n    0x9601684d00000000, 0x60b5fc1b00000000, 0x1654f38600000000,\n    0xcd7192fa00000000, 0xbb909d6700000000, 0x7b3a500200000000,\n    0x0ddb5f9f00000000, 0xd6fe3ee300000000, 0xa01f317e00000000,\n    0x1318cac200000000, 0x65f9c55f00000000, 0xbedca42300000000,\n    0xc83dabbe00000000, 0x089766db00000000, 0x7e76694600000000,\n    0xa553083a00000000, 0xd3b207a700000000, 0x250693f100000000,\n    0x53e79c6c00000000, 0x88c2fd1000000000, 0xfe23f28d00000000,\n    0x3e893fe800000000, 0x4868307500000000, 0x934d510900000000,\n    0xe5ac5e9400000000, 0x7f2478a400000000, 0x09c5773900000000,\n    0xd2e0164500000000, 0xa40119d800000000, 0x64abd4bd00000000,\n    0x124adb2000000000, 0xc96fba5c00000000, 0xbf8eb5c100000000,\n    0x493a219700000000, 0x3fdb2e0a00000000, 0xe4fe4f7600000000,\n    0x921f40eb00000000, 0x52b58d8e00000000, 0x2454821300000000,\n    0xff71e36f00000000, 0x8990ecf200000000, 0xcb60ae0f00000000,\n    0xbd81a19200000000, 0x66a4c0ee00000000, 0x1045cf7300000000,\n    0xd0ef021600000000, 0xa60e0d8b00000000, 0x7d2b6cf700000000,\n    0x0bca636a00000000, 0xfd7ef73c00000000, 0x8b9ff8a100000000,\n    0x50ba99dd00000000, 0x265b964000000000, 0xe6f15b2500000000,\n    0x901054b800000000, 0x4b3535c400000000, 0x3dd43a5900000000,\n    0xa75c1c6900000000, 0xd1bd13f400000000, 0x0a98728800000000,\n    0x7c797d1500000000, 0xbcd3b07000000000, 0xca32bfed00000000,\n    0x1117de9100000000, 0x67f6d10c00000000, 0x9142455a00000000,\n    0xe7a34ac700000000, 0x3c862bbb00000000, 0x4a67242600000000,\n    0x8acde94300000000, 0xfc2ce6de00000000, 0x270987a200000000,\n    0x51e8883f00000000},\n   {0x0000000000000000, 0xe8dbfbb900000000, 0x91b186a800000000,\n    0x796a7d1100000000, 0x63657c8a00000000, 0x8bbe873300000000,\n    0xf2d4fa2200000000, 0x1a0f019b00000000, 0x87cc89cf00000000,\n    0x6f17727600000000, 0x167d0f6700000000, 0xfea6f4de00000000,\n    0xe4a9f54500000000, 0x0c720efc00000000, 0x751873ed00000000,\n    0x9dc3885400000000, 0x4f9f624400000000, 0xa74499fd00000000,\n    0xde2ee4ec00000000, 0x36f51f5500000000, 0x2cfa1ece00000000,\n    0xc421e57700000000, 0xbd4b986600000000, 0x559063df00000000,\n    0xc853eb8b00000000, 0x2088103200000000, 0x59e26d2300000000,\n    0xb139969a00000000, 0xab36970100000000, 0x43ed6cb800000000,\n    0x3a8711a900000000, 0xd25cea1000000000, 0x9e3ec58800000000,\n    0x76e53e3100000000, 0x0f8f432000000000, 0xe754b89900000000,\n    0xfd5bb90200000000, 0x158042bb00000000, 0x6cea3faa00000000,\n    0x8431c41300000000, 0x19f24c4700000000, 0xf129b7fe00000000,\n    0x8843caef00000000, 0x6098315600000000, 0x7a9730cd00000000,\n    0x924ccb7400000000, 0xeb26b66500000000, 0x03fd4ddc00000000,\n    0xd1a1a7cc00000000, 0x397a5c7500000000, 0x4010216400000000,\n    0xa8cbdadd00000000, 0xb2c4db4600000000, 0x5a1f20ff00000000,\n    0x23755dee00000000, 0xcbaea65700000000, 0x566d2e0300000000,\n    0xbeb6d5ba00000000, 0xc7dca8ab00000000, 0x2f07531200000000,\n    0x3508528900000000, 0xddd3a93000000000, 0xa4b9d42100000000,\n    0x4c622f9800000000, 0x7d7bfbca00000000, 0x95a0007300000000,\n    0xecca7d6200000000, 0x041186db00000000, 0x1e1e874000000000,\n    0xf6c57cf900000000, 0x8faf01e800000000, 0x6774fa5100000000,\n    0xfab7720500000000, 0x126c89bc00000000, 0x6b06f4ad00000000,\n    0x83dd0f1400000000, 0x99d20e8f00000000, 0x7109f53600000000,\n    0x0863882700000000, 0xe0b8739e00000000, 0x32e4998e00000000,\n    0xda3f623700000000, 0xa3551f2600000000, 0x4b8ee49f00000000,\n    0x5181e50400000000, 0xb95a1ebd00000000, 0xc03063ac00000000,\n    0x28eb981500000000, 0xb528104100000000, 0x5df3ebf800000000,\n    0x249996e900000000, 0xcc426d5000000000, 0xd64d6ccb00000000,\n    0x3e96977200000000, 0x47fcea6300000000, 0xaf2711da00000000,\n    0xe3453e4200000000, 0x0b9ec5fb00000000, 0x72f4b8ea00000000,\n    0x9a2f435300000000, 0x802042c800000000, 0x68fbb97100000000,\n    0x1191c46000000000, 0xf94a3fd900000000, 0x6489b78d00000000,\n    0x8c524c3400000000, 0xf538312500000000, 0x1de3ca9c00000000,\n    0x07eccb0700000000, 0xef3730be00000000, 0x965d4daf00000000,\n    0x7e86b61600000000, 0xacda5c0600000000, 0x4401a7bf00000000,\n    0x3d6bdaae00000000, 0xd5b0211700000000, 0xcfbf208c00000000,\n    0x2764db3500000000, 0x5e0ea62400000000, 0xb6d55d9d00000000,\n    0x2b16d5c900000000, 0xc3cd2e7000000000, 0xbaa7536100000000,\n    0x527ca8d800000000, 0x4873a94300000000, 0xa0a852fa00000000,\n    0xd9c22feb00000000, 0x3119d45200000000, 0xbbf0874e00000000,\n    0x532b7cf700000000, 0x2a4101e600000000, 0xc29afa5f00000000,\n    0xd895fbc400000000, 0x304e007d00000000, 0x49247d6c00000000,\n    0xa1ff86d500000000, 0x3c3c0e8100000000, 0xd4e7f53800000000,\n    0xad8d882900000000, 0x4556739000000000, 0x5f59720b00000000,\n    0xb78289b200000000, 0xcee8f4a300000000, 0x26330f1a00000000,\n    0xf46fe50a00000000, 0x1cb41eb300000000, 0x65de63a200000000,\n    0x8d05981b00000000, 0x970a998000000000, 0x7fd1623900000000,\n    0x06bb1f2800000000, 0xee60e49100000000, 0x73a36cc500000000,\n    0x9b78977c00000000, 0xe212ea6d00000000, 0x0ac911d400000000,\n    0x10c6104f00000000, 0xf81debf600000000, 0x817796e700000000,\n    0x69ac6d5e00000000, 0x25ce42c600000000, 0xcd15b97f00000000,\n    0xb47fc46e00000000, 0x5ca43fd700000000, 0x46ab3e4c00000000,\n    0xae70c5f500000000, 0xd71ab8e400000000, 0x3fc1435d00000000,\n    0xa202cb0900000000, 0x4ad930b000000000, 0x33b34da100000000,\n    0xdb68b61800000000, 0xc167b78300000000, 0x29bc4c3a00000000,\n    0x50d6312b00000000, 0xb80dca9200000000, 0x6a51208200000000,\n    0x828adb3b00000000, 0xfbe0a62a00000000, 0x133b5d9300000000,\n    0x09345c0800000000, 0xe1efa7b100000000, 0x9885daa000000000,\n    0x705e211900000000, 0xed9da94d00000000, 0x054652f400000000,\n    0x7c2c2fe500000000, 0x94f7d45c00000000, 0x8ef8d5c700000000,\n    0x66232e7e00000000, 0x1f49536f00000000, 0xf792a8d600000000,\n    0xc68b7c8400000000, 0x2e50873d00000000, 0x573afa2c00000000,\n    0xbfe1019500000000, 0xa5ee000e00000000, 0x4d35fbb700000000,\n    0x345f86a600000000, 0xdc847d1f00000000, 0x4147f54b00000000,\n    0xa99c0ef200000000, 0xd0f673e300000000, 0x382d885a00000000,\n    0x222289c100000000, 0xcaf9727800000000, 0xb3930f6900000000,\n    0x5b48f4d000000000, 0x89141ec000000000, 0x61cfe57900000000,\n    0x18a5986800000000, 0xf07e63d100000000, 0xea71624a00000000,\n    0x02aa99f300000000, 0x7bc0e4e200000000, 0x931b1f5b00000000,\n    0x0ed8970f00000000, 0xe6036cb600000000, 0x9f6911a700000000,\n    0x77b2ea1e00000000, 0x6dbdeb8500000000, 0x8566103c00000000,\n    0xfc0c6d2d00000000, 0x14d7969400000000, 0x58b5b90c00000000,\n    0xb06e42b500000000, 0xc9043fa400000000, 0x21dfc41d00000000,\n    0x3bd0c58600000000, 0xd30b3e3f00000000, 0xaa61432e00000000,\n    0x42bab89700000000, 0xdf7930c300000000, 0x37a2cb7a00000000,\n    0x4ec8b66b00000000, 0xa6134dd200000000, 0xbc1c4c4900000000,\n    0x54c7b7f000000000, 0x2dadcae100000000, 0xc576315800000000,\n    0x172adb4800000000, 0xfff120f100000000, 0x869b5de000000000,\n    0x6e40a65900000000, 0x744fa7c200000000, 0x9c945c7b00000000,\n    0xe5fe216a00000000, 0x0d25dad300000000, 0x90e6528700000000,\n    0x783da93e00000000, 0x0157d42f00000000, 0xe98c2f9600000000,\n    0xf3832e0d00000000, 0x1b58d5b400000000, 0x6232a8a500000000,\n    0x8ae9531c00000000},\n   {0x0000000000000000, 0x919168ae00000000, 0x6325a08700000000,\n    0xf2b4c82900000000, 0x874c31d400000000, 0x16dd597a00000000,\n    0xe469915300000000, 0x75f8f9fd00000000, 0x4f9f137300000000,\n    0xde0e7bdd00000000, 0x2cbab3f400000000, 0xbd2bdb5a00000000,\n    0xc8d322a700000000, 0x59424a0900000000, 0xabf6822000000000,\n    0x3a67ea8e00000000, 0x9e3e27e600000000, 0x0faf4f4800000000,\n    0xfd1b876100000000, 0x6c8aefcf00000000, 0x1972163200000000,\n    0x88e37e9c00000000, 0x7a57b6b500000000, 0xebc6de1b00000000,\n    0xd1a1349500000000, 0x40305c3b00000000, 0xb284941200000000,\n    0x2315fcbc00000000, 0x56ed054100000000, 0xc77c6def00000000,\n    0x35c8a5c600000000, 0xa459cd6800000000, 0x7d7b3f1700000000,\n    0xecea57b900000000, 0x1e5e9f9000000000, 0x8fcff73e00000000,\n    0xfa370ec300000000, 0x6ba6666d00000000, 0x9912ae4400000000,\n    0x0883c6ea00000000, 0x32e42c6400000000, 0xa37544ca00000000,\n    0x51c18ce300000000, 0xc050e44d00000000, 0xb5a81db000000000,\n    0x2439751e00000000, 0xd68dbd3700000000, 0x471cd59900000000,\n    0xe34518f100000000, 0x72d4705f00000000, 0x8060b87600000000,\n    0x11f1d0d800000000, 0x6409292500000000, 0xf598418b00000000,\n    0x072c89a200000000, 0x96bde10c00000000, 0xacda0b8200000000,\n    0x3d4b632c00000000, 0xcfffab0500000000, 0x5e6ec3ab00000000,\n    0x2b963a5600000000, 0xba0752f800000000, 0x48b39ad100000000,\n    0xd922f27f00000000, 0xfaf67e2e00000000, 0x6b67168000000000,\n    0x99d3dea900000000, 0x0842b60700000000, 0x7dba4ffa00000000,\n    0xec2b275400000000, 0x1e9fef7d00000000, 0x8f0e87d300000000,\n    0xb5696d5d00000000, 0x24f805f300000000, 0xd64ccdda00000000,\n    0x47dda57400000000, 0x32255c8900000000, 0xa3b4342700000000,\n    0x5100fc0e00000000, 0xc09194a000000000, 0x64c859c800000000,\n    0xf559316600000000, 0x07edf94f00000000, 0x967c91e100000000,\n    0xe384681c00000000, 0x721500b200000000, 0x80a1c89b00000000,\n    0x1130a03500000000, 0x2b574abb00000000, 0xbac6221500000000,\n    0x4872ea3c00000000, 0xd9e3829200000000, 0xac1b7b6f00000000,\n    0x3d8a13c100000000, 0xcf3edbe800000000, 0x5eafb34600000000,\n    0x878d413900000000, 0x161c299700000000, 0xe4a8e1be00000000,\n    0x7539891000000000, 0x00c170ed00000000, 0x9150184300000000,\n    0x63e4d06a00000000, 0xf275b8c400000000, 0xc812524a00000000,\n    0x59833ae400000000, 0xab37f2cd00000000, 0x3aa69a6300000000,\n    0x4f5e639e00000000, 0xdecf0b3000000000, 0x2c7bc31900000000,\n    0xbdeaabb700000000, 0x19b366df00000000, 0x88220e7100000000,\n    0x7a96c65800000000, 0xeb07aef600000000, 0x9eff570b00000000,\n    0x0f6e3fa500000000, 0xfddaf78c00000000, 0x6c4b9f2200000000,\n    0x562c75ac00000000, 0xc7bd1d0200000000, 0x3509d52b00000000,\n    0xa498bd8500000000, 0xd160447800000000, 0x40f12cd600000000,\n    0xb245e4ff00000000, 0x23d48c5100000000, 0xf4edfd5c00000000,\n    0x657c95f200000000, 0x97c85ddb00000000, 0x0659357500000000,\n    0x73a1cc8800000000, 0xe230a42600000000, 0x10846c0f00000000,\n    0x811504a100000000, 0xbb72ee2f00000000, 0x2ae3868100000000,\n    0xd8574ea800000000, 0x49c6260600000000, 0x3c3edffb00000000,\n    0xadafb75500000000, 0x5f1b7f7c00000000, 0xce8a17d200000000,\n    0x6ad3daba00000000, 0xfb42b21400000000, 0x09f67a3d00000000,\n    0x9867129300000000, 0xed9feb6e00000000, 0x7c0e83c000000000,\n    0x8eba4be900000000, 0x1f2b234700000000, 0x254cc9c900000000,\n    0xb4dda16700000000, 0x4669694e00000000, 0xd7f801e000000000,\n    0xa200f81d00000000, 0x339190b300000000, 0xc125589a00000000,\n    0x50b4303400000000, 0x8996c24b00000000, 0x1807aae500000000,\n    0xeab362cc00000000, 0x7b220a6200000000, 0x0edaf39f00000000,\n    0x9f4b9b3100000000, 0x6dff531800000000, 0xfc6e3bb600000000,\n    0xc609d13800000000, 0x5798b99600000000, 0xa52c71bf00000000,\n    0x34bd191100000000, 0x4145e0ec00000000, 0xd0d4884200000000,\n    0x2260406b00000000, 0xb3f128c500000000, 0x17a8e5ad00000000,\n    0x86398d0300000000, 0x748d452a00000000, 0xe51c2d8400000000,\n    0x90e4d47900000000, 0x0175bcd700000000, 0xf3c174fe00000000,\n    0x62501c5000000000, 0x5837f6de00000000, 0xc9a69e7000000000,\n    0x3b12565900000000, 0xaa833ef700000000, 0xdf7bc70a00000000,\n    0x4eeaafa400000000, 0xbc5e678d00000000, 0x2dcf0f2300000000,\n    0x0e1b837200000000, 0x9f8aebdc00000000, 0x6d3e23f500000000,\n    0xfcaf4b5b00000000, 0x8957b2a600000000, 0x18c6da0800000000,\n    0xea72122100000000, 0x7be37a8f00000000, 0x4184900100000000,\n    0xd015f8af00000000, 0x22a1308600000000, 0xb330582800000000,\n    0xc6c8a1d500000000, 0x5759c97b00000000, 0xa5ed015200000000,\n    0x347c69fc00000000, 0x9025a49400000000, 0x01b4cc3a00000000,\n    0xf300041300000000, 0x62916cbd00000000, 0x1769954000000000,\n    0x86f8fdee00000000, 0x744c35c700000000, 0xe5dd5d6900000000,\n    0xdfbab7e700000000, 0x4e2bdf4900000000, 0xbc9f176000000000,\n    0x2d0e7fce00000000, 0x58f6863300000000, 0xc967ee9d00000000,\n    0x3bd326b400000000, 0xaa424e1a00000000, 0x7360bc6500000000,\n    0xe2f1d4cb00000000, 0x10451ce200000000, 0x81d4744c00000000,\n    0xf42c8db100000000, 0x65bde51f00000000, 0x97092d3600000000,\n    0x0698459800000000, 0x3cffaf1600000000, 0xad6ec7b800000000,\n    0x5fda0f9100000000, 0xce4b673f00000000, 0xbbb39ec200000000,\n    0x2a22f66c00000000, 0xd8963e4500000000, 0x490756eb00000000,\n    0xed5e9b8300000000, 0x7ccff32d00000000, 0x8e7b3b0400000000,\n    0x1fea53aa00000000, 0x6a12aa5700000000, 0xfb83c2f900000000,\n    0x09370ad000000000, 0x98a6627e00000000, 0xa2c188f000000000,\n    0x3350e05e00000000, 0xc1e4287700000000, 0x507540d900000000,\n    0x258db92400000000, 0xb41cd18a00000000, 0x46a819a300000000,\n    0xd739710d00000000}};\n\n#else /* W == 4 */\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0xccaa009e, 0x4225077d, 0x8e8f07e3, 0x844a0efa,\n    0x48e00e64, 0xc66f0987, 0x0ac50919, 0xd3e51bb5, 0x1f4f1b2b,\n    0x91c01cc8, 0x5d6a1c56, 0x57af154f, 0x9b0515d1, 0x158a1232,\n    0xd92012ac, 0x7cbb312b, 0xb01131b5, 0x3e9e3656, 0xf23436c8,\n    0xf8f13fd1, 0x345b3f4f, 0xbad438ac, 0x767e3832, 0xaf5e2a9e,\n    0x63f42a00, 0xed7b2de3, 0x21d12d7d, 0x2b142464, 0xe7be24fa,\n    0x69312319, 0xa59b2387, 0xf9766256, 0x35dc62c8, 0xbb53652b,\n    0x77f965b5, 0x7d3c6cac, 0xb1966c32, 0x3f196bd1, 0xf3b36b4f,\n    0x2a9379e3, 0xe639797d, 0x68b67e9e, 0xa41c7e00, 0xaed97719,\n    0x62737787, 0xecfc7064, 0x205670fa, 0x85cd537d, 0x496753e3,\n    0xc7e85400, 0x0b42549e, 0x01875d87, 0xcd2d5d19, 0x43a25afa,\n    0x8f085a64, 0x562848c8, 0x9a824856, 0x140d4fb5, 0xd8a74f2b,\n    0xd2624632, 0x1ec846ac, 0x9047414f, 0x5ced41d1, 0x299dc2ed,\n    0xe537c273, 0x6bb8c590, 0xa712c50e, 0xadd7cc17, 0x617dcc89,\n    0xeff2cb6a, 0x2358cbf4, 0xfa78d958, 0x36d2d9c6, 0xb85dde25,\n    0x74f7debb, 0x7e32d7a2, 0xb298d73c, 0x3c17d0df, 0xf0bdd041,\n    0x5526f3c6, 0x998cf358, 0x1703f4bb, 0xdba9f425, 0xd16cfd3c,\n    0x1dc6fda2, 0x9349fa41, 0x5fe3fadf, 0x86c3e873, 0x4a69e8ed,\n    0xc4e6ef0e, 0x084cef90, 0x0289e689, 0xce23e617, 0x40ace1f4,\n    0x8c06e16a, 0xd0eba0bb, 0x1c41a025, 0x92cea7c6, 0x5e64a758,\n    0x54a1ae41, 0x980baedf, 0x1684a93c, 0xda2ea9a2, 0x030ebb0e,\n    0xcfa4bb90, 0x412bbc73, 0x8d81bced, 0x8744b5f4, 0x4beeb56a,\n    0xc561b289, 0x09cbb217, 0xac509190, 0x60fa910e, 0xee7596ed,\n    0x22df9673, 0x281a9f6a, 0xe4b09ff4, 0x6a3f9817, 0xa6959889,\n    0x7fb58a25, 0xb31f8abb, 0x3d908d58, 0xf13a8dc6, 0xfbff84df,\n    0x37558441, 0xb9da83a2, 0x7570833c, 0x533b85da, 0x9f918544,\n    0x111e82a7, 0xddb48239, 0xd7718b20, 0x1bdb8bbe, 0x95548c5d,\n    0x59fe8cc3, 0x80de9e6f, 0x4c749ef1, 0xc2fb9912, 0x0e51998c,\n    0x04949095, 0xc83e900b, 0x46b197e8, 0x8a1b9776, 0x2f80b4f1,\n    0xe32ab46f, 0x6da5b38c, 0xa10fb312, 0xabcaba0b, 0x6760ba95,\n    0xe9efbd76, 0x2545bde8, 0xfc65af44, 0x30cfafda, 0xbe40a839,\n    0x72eaa8a7, 0x782fa1be, 0xb485a120, 0x3a0aa6c3, 0xf6a0a65d,\n    0xaa4de78c, 0x66e7e712, 0xe868e0f1, 0x24c2e06f, 0x2e07e976,\n    0xe2ade9e8, 0x6c22ee0b, 0xa088ee95, 0x79a8fc39, 0xb502fca7,\n    0x3b8dfb44, 0xf727fbda, 0xfde2f2c3, 0x3148f25d, 0xbfc7f5be,\n    0x736df520, 0xd6f6d6a7, 0x1a5cd639, 0x94d3d1da, 0x5879d144,\n    0x52bcd85d, 0x9e16d8c3, 0x1099df20, 0xdc33dfbe, 0x0513cd12,\n    0xc9b9cd8c, 0x4736ca6f, 0x8b9ccaf1, 0x8159c3e8, 0x4df3c376,\n    0xc37cc495, 0x0fd6c40b, 0x7aa64737, 0xb60c47a9, 0x3883404a,\n    0xf42940d4, 0xfeec49cd, 0x32464953, 0xbcc94eb0, 0x70634e2e,\n    0xa9435c82, 0x65e95c1c, 0xeb665bff, 0x27cc5b61, 0x2d095278,\n    0xe1a352e6, 0x6f2c5505, 0xa386559b, 0x061d761c, 0xcab77682,\n    0x44387161, 0x889271ff, 0x825778e6, 0x4efd7878, 0xc0727f9b,\n    0x0cd87f05, 0xd5f86da9, 0x19526d37, 0x97dd6ad4, 0x5b776a4a,\n    0x51b26353, 0x9d1863cd, 0x1397642e, 0xdf3d64b0, 0x83d02561,\n    0x4f7a25ff, 0xc1f5221c, 0x0d5f2282, 0x079a2b9b, 0xcb302b05,\n    0x45bf2ce6, 0x89152c78, 0x50353ed4, 0x9c9f3e4a, 0x121039a9,\n    0xdeba3937, 0xd47f302e, 0x18d530b0, 0x965a3753, 0x5af037cd,\n    0xff6b144a, 0x33c114d4, 0xbd4e1337, 0x71e413a9, 0x7b211ab0,\n    0xb78b1a2e, 0x39041dcd, 0xf5ae1d53, 0x2c8e0fff, 0xe0240f61,\n    0x6eab0882, 0xa201081c, 0xa8c40105, 0x646e019b, 0xeae10678,\n    0x264b06e6},\n   {0x00000000, 0xa6770bb4, 0x979f1129, 0x31e81a9d, 0xf44f2413,\n    0x52382fa7, 0x63d0353a, 0xc5a73e8e, 0x33ef4e67, 0x959845d3,\n    0xa4705f4e, 0x020754fa, 0xc7a06a74, 0x61d761c0, 0x503f7b5d,\n    0xf64870e9, 0x67de9cce, 0xc1a9977a, 0xf0418de7, 0x56368653,\n    0x9391b8dd, 0x35e6b369, 0x040ea9f4, 0xa279a240, 0x5431d2a9,\n    0xf246d91d, 0xc3aec380, 0x65d9c834, 0xa07ef6ba, 0x0609fd0e,\n    0x37e1e793, 0x9196ec27, 0xcfbd399c, 0x69ca3228, 0x582228b5,\n    0xfe552301, 0x3bf21d8f, 0x9d85163b, 0xac6d0ca6, 0x0a1a0712,\n    0xfc5277fb, 0x5a257c4f, 0x6bcd66d2, 0xcdba6d66, 0x081d53e8,\n    0xae6a585c, 0x9f8242c1, 0x39f54975, 0xa863a552, 0x0e14aee6,\n    0x3ffcb47b, 0x998bbfcf, 0x5c2c8141, 0xfa5b8af5, 0xcbb39068,\n    0x6dc49bdc, 0x9b8ceb35, 0x3dfbe081, 0x0c13fa1c, 0xaa64f1a8,\n    0x6fc3cf26, 0xc9b4c492, 0xf85cde0f, 0x5e2bd5bb, 0x440b7579,\n    0xe27c7ecd, 0xd3946450, 0x75e36fe4, 0xb044516a, 0x16335ade,\n    0x27db4043, 0x81ac4bf7, 0x77e43b1e, 0xd19330aa, 0xe07b2a37,\n    0x460c2183, 0x83ab1f0d, 0x25dc14b9, 0x14340e24, 0xb2430590,\n    0x23d5e9b7, 0x85a2e203, 0xb44af89e, 0x123df32a, 0xd79acda4,\n    0x71edc610, 0x4005dc8d, 0xe672d739, 0x103aa7d0, 0xb64dac64,\n    0x87a5b6f9, 0x21d2bd4d, 0xe47583c3, 0x42028877, 0x73ea92ea,\n    0xd59d995e, 0x8bb64ce5, 0x2dc14751, 0x1c295dcc, 0xba5e5678,\n    0x7ff968f6, 0xd98e6342, 0xe86679df, 0x4e11726b, 0xb8590282,\n    0x1e2e0936, 0x2fc613ab, 0x89b1181f, 0x4c162691, 0xea612d25,\n    0xdb8937b8, 0x7dfe3c0c, 0xec68d02b, 0x4a1fdb9f, 0x7bf7c102,\n    0xdd80cab6, 0x1827f438, 0xbe50ff8c, 0x8fb8e511, 0x29cfeea5,\n    0xdf879e4c, 0x79f095f8, 0x48188f65, 0xee6f84d1, 0x2bc8ba5f,\n    0x8dbfb1eb, 0xbc57ab76, 0x1a20a0c2, 0x8816eaf2, 0x2e61e146,\n    0x1f89fbdb, 0xb9fef06f, 0x7c59cee1, 0xda2ec555, 0xebc6dfc8,\n    0x4db1d47c, 0xbbf9a495, 0x1d8eaf21, 0x2c66b5bc, 0x8a11be08,\n    0x4fb68086, 0xe9c18b32, 0xd82991af, 0x7e5e9a1b, 0xefc8763c,\n    0x49bf7d88, 0x78576715, 0xde206ca1, 0x1b87522f, 0xbdf0599b,\n    0x8c184306, 0x2a6f48b2, 0xdc27385b, 0x7a5033ef, 0x4bb82972,\n    0xedcf22c6, 0x28681c48, 0x8e1f17fc, 0xbff70d61, 0x198006d5,\n    0x47abd36e, 0xe1dcd8da, 0xd034c247, 0x7643c9f3, 0xb3e4f77d,\n    0x1593fcc9, 0x247be654, 0x820cede0, 0x74449d09, 0xd23396bd,\n    0xe3db8c20, 0x45ac8794, 0x800bb91a, 0x267cb2ae, 0x1794a833,\n    0xb1e3a387, 0x20754fa0, 0x86024414, 0xb7ea5e89, 0x119d553d,\n    0xd43a6bb3, 0x724d6007, 0x43a57a9a, 0xe5d2712e, 0x139a01c7,\n    0xb5ed0a73, 0x840510ee, 0x22721b5a, 0xe7d525d4, 0x41a22e60,\n    0x704a34fd, 0xd63d3f49, 0xcc1d9f8b, 0x6a6a943f, 0x5b828ea2,\n    0xfdf58516, 0x3852bb98, 0x9e25b02c, 0xafcdaab1, 0x09baa105,\n    0xfff2d1ec, 0x5985da58, 0x686dc0c5, 0xce1acb71, 0x0bbdf5ff,\n    0xadcafe4b, 0x9c22e4d6, 0x3a55ef62, 0xabc30345, 0x0db408f1,\n    0x3c5c126c, 0x9a2b19d8, 0x5f8c2756, 0xf9fb2ce2, 0xc813367f,\n    0x6e643dcb, 0x982c4d22, 0x3e5b4696, 0x0fb35c0b, 0xa9c457bf,\n    0x6c636931, 0xca146285, 0xfbfc7818, 0x5d8b73ac, 0x03a0a617,\n    0xa5d7ada3, 0x943fb73e, 0x3248bc8a, 0xf7ef8204, 0x519889b0,\n    0x6070932d, 0xc6079899, 0x304fe870, 0x9638e3c4, 0xa7d0f959,\n    0x01a7f2ed, 0xc400cc63, 0x6277c7d7, 0x539fdd4a, 0xf5e8d6fe,\n    0x647e3ad9, 0xc209316d, 0xf3e12bf0, 0x55962044, 0x90311eca,\n    0x3646157e, 0x07ae0fe3, 0xa1d90457, 0x579174be, 0xf1e67f0a,\n    0xc00e6597, 0x66796e23, 0xa3de50ad, 0x05a95b19, 0x34414184,\n    0x92364a30},\n   {0x00000000, 0xcb5cd3a5, 0x4dc8a10b, 0x869472ae, 0x9b914216,\n    0x50cd91b3, 0xd659e31d, 0x1d0530b8, 0xec53826d, 0x270f51c8,\n    0xa19b2366, 0x6ac7f0c3, 0x77c2c07b, 0xbc9e13de, 0x3a0a6170,\n    0xf156b2d5, 0x03d6029b, 0xc88ad13e, 0x4e1ea390, 0x85427035,\n    0x9847408d, 0x531b9328, 0xd58fe186, 0x1ed33223, 0xef8580f6,\n    0x24d95353, 0xa24d21fd, 0x6911f258, 0x7414c2e0, 0xbf481145,\n    0x39dc63eb, 0xf280b04e, 0x07ac0536, 0xccf0d693, 0x4a64a43d,\n    0x81387798, 0x9c3d4720, 0x57619485, 0xd1f5e62b, 0x1aa9358e,\n    0xebff875b, 0x20a354fe, 0xa6372650, 0x6d6bf5f5, 0x706ec54d,\n    0xbb3216e8, 0x3da66446, 0xf6fab7e3, 0x047a07ad, 0xcf26d408,\n    0x49b2a6a6, 0x82ee7503, 0x9feb45bb, 0x54b7961e, 0xd223e4b0,\n    0x197f3715, 0xe82985c0, 0x23755665, 0xa5e124cb, 0x6ebdf76e,\n    0x73b8c7d6, 0xb8e41473, 0x3e7066dd, 0xf52cb578, 0x0f580a6c,\n    0xc404d9c9, 0x4290ab67, 0x89cc78c2, 0x94c9487a, 0x5f959bdf,\n    0xd901e971, 0x125d3ad4, 0xe30b8801, 0x28575ba4, 0xaec3290a,\n    0x659ffaaf, 0x789aca17, 0xb3c619b2, 0x35526b1c, 0xfe0eb8b9,\n    0x0c8e08f7, 0xc7d2db52, 0x4146a9fc, 0x8a1a7a59, 0x971f4ae1,\n    0x5c439944, 0xdad7ebea, 0x118b384f, 0xe0dd8a9a, 0x2b81593f,\n    0xad152b91, 0x6649f834, 0x7b4cc88c, 0xb0101b29, 0x36846987,\n    0xfdd8ba22, 0x08f40f5a, 0xc3a8dcff, 0x453cae51, 0x8e607df4,\n    0x93654d4c, 0x58399ee9, 0xdeadec47, 0x15f13fe2, 0xe4a78d37,\n    0x2ffb5e92, 0xa96f2c3c, 0x6233ff99, 0x7f36cf21, 0xb46a1c84,\n    0x32fe6e2a, 0xf9a2bd8f, 0x0b220dc1, 0xc07ede64, 0x46eaacca,\n    0x8db67f6f, 0x90b34fd7, 0x5bef9c72, 0xdd7beedc, 0x16273d79,\n    0xe7718fac, 0x2c2d5c09, 0xaab92ea7, 0x61e5fd02, 0x7ce0cdba,\n    0xb7bc1e1f, 0x31286cb1, 0xfa74bf14, 0x1eb014d8, 0xd5ecc77d,\n    0x5378b5d3, 0x98246676, 0x852156ce, 0x4e7d856b, 0xc8e9f7c5,\n    0x03b52460, 0xf2e396b5, 0x39bf4510, 0xbf2b37be, 0x7477e41b,\n    0x6972d4a3, 0xa22e0706, 0x24ba75a8, 0xefe6a60d, 0x1d661643,\n    0xd63ac5e6, 0x50aeb748, 0x9bf264ed, 0x86f75455, 0x4dab87f0,\n    0xcb3ff55e, 0x006326fb, 0xf135942e, 0x3a69478b, 0xbcfd3525,\n    0x77a1e680, 0x6aa4d638, 0xa1f8059d, 0x276c7733, 0xec30a496,\n    0x191c11ee, 0xd240c24b, 0x54d4b0e5, 0x9f886340, 0x828d53f8,\n    0x49d1805d, 0xcf45f2f3, 0x04192156, 0xf54f9383, 0x3e134026,\n    0xb8873288, 0x73dbe12d, 0x6eded195, 0xa5820230, 0x2316709e,\n    0xe84aa33b, 0x1aca1375, 0xd196c0d0, 0x5702b27e, 0x9c5e61db,\n    0x815b5163, 0x4a0782c6, 0xcc93f068, 0x07cf23cd, 0xf6999118,\n    0x3dc542bd, 0xbb513013, 0x700de3b6, 0x6d08d30e, 0xa65400ab,\n    0x20c07205, 0xeb9ca1a0, 0x11e81eb4, 0xdab4cd11, 0x5c20bfbf,\n    0x977c6c1a, 0x8a795ca2, 0x41258f07, 0xc7b1fda9, 0x0ced2e0c,\n    0xfdbb9cd9, 0x36e74f7c, 0xb0733dd2, 0x7b2fee77, 0x662adecf,\n    0xad760d6a, 0x2be27fc4, 0xe0beac61, 0x123e1c2f, 0xd962cf8a,\n    0x5ff6bd24, 0x94aa6e81, 0x89af5e39, 0x42f38d9c, 0xc467ff32,\n    0x0f3b2c97, 0xfe6d9e42, 0x35314de7, 0xb3a53f49, 0x78f9ecec,\n    0x65fcdc54, 0xaea00ff1, 0x28347d5f, 0xe368aefa, 0x16441b82,\n    0xdd18c827, 0x5b8cba89, 0x90d0692c, 0x8dd55994, 0x46898a31,\n    0xc01df89f, 0x0b412b3a, 0xfa1799ef, 0x314b4a4a, 0xb7df38e4,\n    0x7c83eb41, 0x6186dbf9, 0xaada085c, 0x2c4e7af2, 0xe712a957,\n    0x15921919, 0xdececabc, 0x585ab812, 0x93066bb7, 0x8e035b0f,\n    0x455f88aa, 0xc3cbfa04, 0x089729a1, 0xf9c19b74, 0x329d48d1,\n    0xb4093a7f, 0x7f55e9da, 0x6250d962, 0xa90c0ac7, 0x2f987869,\n    0xe4c4abcc},\n   {0x00000000, 0x3d6029b0, 0x7ac05360, 0x47a07ad0, 0xf580a6c0,\n    0xc8e08f70, 0x8f40f5a0, 0xb220dc10, 0x30704bc1, 0x0d106271,\n    0x4ab018a1, 0x77d03111, 0xc5f0ed01, 0xf890c4b1, 0xbf30be61,\n    0x825097d1, 0x60e09782, 0x5d80be32, 0x1a20c4e2, 0x2740ed52,\n    0x95603142, 0xa80018f2, 0xefa06222, 0xd2c04b92, 0x5090dc43,\n    0x6df0f5f3, 0x2a508f23, 0x1730a693, 0xa5107a83, 0x98705333,\n    0xdfd029e3, 0xe2b00053, 0xc1c12f04, 0xfca106b4, 0xbb017c64,\n    0x866155d4, 0x344189c4, 0x0921a074, 0x4e81daa4, 0x73e1f314,\n    0xf1b164c5, 0xccd14d75, 0x8b7137a5, 0xb6111e15, 0x0431c205,\n    0x3951ebb5, 0x7ef19165, 0x4391b8d5, 0xa121b886, 0x9c419136,\n    0xdbe1ebe6, 0xe681c256, 0x54a11e46, 0x69c137f6, 0x2e614d26,\n    0x13016496, 0x9151f347, 0xac31daf7, 0xeb91a027, 0xd6f18997,\n    0x64d15587, 0x59b17c37, 0x1e1106e7, 0x23712f57, 0x58f35849,\n    0x659371f9, 0x22330b29, 0x1f532299, 0xad73fe89, 0x9013d739,\n    0xd7b3ade9, 0xead38459, 0x68831388, 0x55e33a38, 0x124340e8,\n    0x2f236958, 0x9d03b548, 0xa0639cf8, 0xe7c3e628, 0xdaa3cf98,\n    0x3813cfcb, 0x0573e67b, 0x42d39cab, 0x7fb3b51b, 0xcd93690b,\n    0xf0f340bb, 0xb7533a6b, 0x8a3313db, 0x0863840a, 0x3503adba,\n    0x72a3d76a, 0x4fc3feda, 0xfde322ca, 0xc0830b7a, 0x872371aa,\n    0xba43581a, 0x9932774d, 0xa4525efd, 0xe3f2242d, 0xde920d9d,\n    0x6cb2d18d, 0x51d2f83d, 0x167282ed, 0x2b12ab5d, 0xa9423c8c,\n    0x9422153c, 0xd3826fec, 0xeee2465c, 0x5cc29a4c, 0x61a2b3fc,\n    0x2602c92c, 0x1b62e09c, 0xf9d2e0cf, 0xc4b2c97f, 0x8312b3af,\n    0xbe729a1f, 0x0c52460f, 0x31326fbf, 0x7692156f, 0x4bf23cdf,\n    0xc9a2ab0e, 0xf4c282be, 0xb362f86e, 0x8e02d1de, 0x3c220dce,\n    0x0142247e, 0x46e25eae, 0x7b82771e, 0xb1e6b092, 0x8c869922,\n    0xcb26e3f2, 0xf646ca42, 0x44661652, 0x79063fe2, 0x3ea64532,\n    0x03c66c82, 0x8196fb53, 0xbcf6d2e3, 0xfb56a833, 0xc6368183,\n    0x74165d93, 0x49767423, 0x0ed60ef3, 0x33b62743, 0xd1062710,\n    0xec660ea0, 0xabc67470, 0x96a65dc0, 0x248681d0, 0x19e6a860,\n    0x5e46d2b0, 0x6326fb00, 0xe1766cd1, 0xdc164561, 0x9bb63fb1,\n    0xa6d61601, 0x14f6ca11, 0x2996e3a1, 0x6e369971, 0x5356b0c1,\n    0x70279f96, 0x4d47b626, 0x0ae7ccf6, 0x3787e546, 0x85a73956,\n    0xb8c710e6, 0xff676a36, 0xc2074386, 0x4057d457, 0x7d37fde7,\n    0x3a978737, 0x07f7ae87, 0xb5d77297, 0x88b75b27, 0xcf1721f7,\n    0xf2770847, 0x10c70814, 0x2da721a4, 0x6a075b74, 0x576772c4,\n    0xe547aed4, 0xd8278764, 0x9f87fdb4, 0xa2e7d404, 0x20b743d5,\n    0x1dd76a65, 0x5a7710b5, 0x67173905, 0xd537e515, 0xe857cca5,\n    0xaff7b675, 0x92979fc5, 0xe915e8db, 0xd475c16b, 0x93d5bbbb,\n    0xaeb5920b, 0x1c954e1b, 0x21f567ab, 0x66551d7b, 0x5b3534cb,\n    0xd965a31a, 0xe4058aaa, 0xa3a5f07a, 0x9ec5d9ca, 0x2ce505da,\n    0x11852c6a, 0x562556ba, 0x6b457f0a, 0x89f57f59, 0xb49556e9,\n    0xf3352c39, 0xce550589, 0x7c75d999, 0x4115f029, 0x06b58af9,\n    0x3bd5a349, 0xb9853498, 0x84e51d28, 0xc34567f8, 0xfe254e48,\n    0x4c059258, 0x7165bbe8, 0x36c5c138, 0x0ba5e888, 0x28d4c7df,\n    0x15b4ee6f, 0x521494bf, 0x6f74bd0f, 0xdd54611f, 0xe03448af,\n    0xa794327f, 0x9af41bcf, 0x18a48c1e, 0x25c4a5ae, 0x6264df7e,\n    0x5f04f6ce, 0xed242ade, 0xd044036e, 0x97e479be, 0xaa84500e,\n    0x4834505d, 0x755479ed, 0x32f4033d, 0x0f942a8d, 0xbdb4f69d,\n    0x80d4df2d, 0xc774a5fd, 0xfa148c4d, 0x78441b9c, 0x4524322c,\n    0x028448fc, 0x3fe4614c, 0x8dc4bd5c, 0xb0a494ec, 0xf704ee3c,\n    0xca64c78c}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x00000000, 0xb029603d, 0x6053c07a, 0xd07aa047, 0xc0a680f5,\n    0x708fe0c8, 0xa0f5408f, 0x10dc20b2, 0xc14b7030, 0x7162100d,\n    0xa118b04a, 0x1131d077, 0x01edf0c5, 0xb1c490f8, 0x61be30bf,\n    0xd1975082, 0x8297e060, 0x32be805d, 0xe2c4201a, 0x52ed4027,\n    0x42316095, 0xf21800a8, 0x2262a0ef, 0x924bc0d2, 0x43dc9050,\n    0xf3f5f06d, 0x238f502a, 0x93a63017, 0x837a10a5, 0x33537098,\n    0xe329d0df, 0x5300b0e2, 0x042fc1c1, 0xb406a1fc, 0x647c01bb,\n    0xd4556186, 0xc4894134, 0x74a02109, 0xa4da814e, 0x14f3e173,\n    0xc564b1f1, 0x754dd1cc, 0xa537718b, 0x151e11b6, 0x05c23104,\n    0xb5eb5139, 0x6591f17e, 0xd5b89143, 0x86b821a1, 0x3691419c,\n    0xe6ebe1db, 0x56c281e6, 0x461ea154, 0xf637c169, 0x264d612e,\n    0x96640113, 0x47f35191, 0xf7da31ac, 0x27a091eb, 0x9789f1d6,\n    0x8755d164, 0x377cb159, 0xe706111e, 0x572f7123, 0x4958f358,\n    0xf9719365, 0x290b3322, 0x9922531f, 0x89fe73ad, 0x39d71390,\n    0xe9adb3d7, 0x5984d3ea, 0x88138368, 0x383ae355, 0xe8404312,\n    0x5869232f, 0x48b5039d, 0xf89c63a0, 0x28e6c3e7, 0x98cfa3da,\n    0xcbcf1338, 0x7be67305, 0xab9cd342, 0x1bb5b37f, 0x0b6993cd,\n    0xbb40f3f0, 0x6b3a53b7, 0xdb13338a, 0x0a846308, 0xbaad0335,\n    0x6ad7a372, 0xdafec34f, 0xca22e3fd, 0x7a0b83c0, 0xaa712387,\n    0x1a5843ba, 0x4d773299, 0xfd5e52a4, 0x2d24f2e3, 0x9d0d92de,\n    0x8dd1b26c, 0x3df8d251, 0xed827216, 0x5dab122b, 0x8c3c42a9,\n    0x3c152294, 0xec6f82d3, 0x5c46e2ee, 0x4c9ac25c, 0xfcb3a261,\n    0x2cc90226, 0x9ce0621b, 0xcfe0d2f9, 0x7fc9b2c4, 0xafb31283,\n    0x1f9a72be, 0x0f46520c, 0xbf6f3231, 0x6f159276, 0xdf3cf24b,\n    0x0eaba2c9, 0xbe82c2f4, 0x6ef862b3, 0xded1028e, 0xce0d223c,\n    0x7e244201, 0xae5ee246, 0x1e77827b, 0x92b0e6b1, 0x2299868c,\n    0xf2e326cb, 0x42ca46f6, 0x52166644, 0xe23f0679, 0x3245a63e,\n    0x826cc603, 0x53fb9681, 0xe3d2f6bc, 0x33a856fb, 0x838136c6,\n    0x935d1674, 0x23747649, 0xf30ed60e, 0x4327b633, 0x102706d1,\n    0xa00e66ec, 0x7074c6ab, 0xc05da696, 0xd0818624, 0x60a8e619,\n    0xb0d2465e, 0x00fb2663, 0xd16c76e1, 0x614516dc, 0xb13fb69b,\n    0x0116d6a6, 0x11caf614, 0xa1e39629, 0x7199366e, 0xc1b05653,\n    0x969f2770, 0x26b6474d, 0xf6cce70a, 0x46e58737, 0x5639a785,\n    0xe610c7b8, 0x366a67ff, 0x864307c2, 0x57d45740, 0xe7fd377d,\n    0x3787973a, 0x87aef707, 0x9772d7b5, 0x275bb788, 0xf72117cf,\n    0x470877f2, 0x1408c710, 0xa421a72d, 0x745b076a, 0xc4726757,\n    0xd4ae47e5, 0x648727d8, 0xb4fd879f, 0x04d4e7a2, 0xd543b720,\n    0x656ad71d, 0xb510775a, 0x05391767, 0x15e537d5, 0xa5cc57e8,\n    0x75b6f7af, 0xc59f9792, 0xdbe815e9, 0x6bc175d4, 0xbbbbd593,\n    0x0b92b5ae, 0x1b4e951c, 0xab67f521, 0x7b1d5566, 0xcb34355b,\n    0x1aa365d9, 0xaa8a05e4, 0x7af0a5a3, 0xcad9c59e, 0xda05e52c,\n    0x6a2c8511, 0xba562556, 0x0a7f456b, 0x597ff589, 0xe95695b4,\n    0x392c35f3, 0x890555ce, 0x99d9757c, 0x29f01541, 0xf98ab506,\n    0x49a3d53b, 0x983485b9, 0x281de584, 0xf86745c3, 0x484e25fe,\n    0x5892054c, 0xe8bb6571, 0x38c1c536, 0x88e8a50b, 0xdfc7d428,\n    0x6feeb415, 0xbf941452, 0x0fbd746f, 0x1f6154dd, 0xaf4834e0,\n    0x7f3294a7, 0xcf1bf49a, 0x1e8ca418, 0xaea5c425, 0x7edf6462,\n    0xcef6045f, 0xde2a24ed, 0x6e0344d0, 0xbe79e497, 0x0e5084aa,\n    0x5d503448, 0xed795475, 0x3d03f432, 0x8d2a940f, 0x9df6b4bd,\n    0x2ddfd480, 0xfda574c7, 0x4d8c14fa, 0x9c1b4478, 0x2c322445,\n    0xfc488402, 0x4c61e43f, 0x5cbdc48d, 0xec94a4b0, 0x3cee04f7,\n    0x8cc764ca},\n   {0x00000000, 0xa5d35ccb, 0x0ba1c84d, 0xae729486, 0x1642919b,\n    0xb391cd50, 0x1de359d6, 0xb830051d, 0x6d8253ec, 0xc8510f27,\n    0x66239ba1, 0xc3f0c76a, 0x7bc0c277, 0xde139ebc, 0x70610a3a,\n    0xd5b256f1, 0x9b02d603, 0x3ed18ac8, 0x90a31e4e, 0x35704285,\n    0x8d404798, 0x28931b53, 0x86e18fd5, 0x2332d31e, 0xf68085ef,\n    0x5353d924, 0xfd214da2, 0x58f21169, 0xe0c21474, 0x451148bf,\n    0xeb63dc39, 0x4eb080f2, 0x3605ac07, 0x93d6f0cc, 0x3da4644a,\n    0x98773881, 0x20473d9c, 0x85946157, 0x2be6f5d1, 0x8e35a91a,\n    0x5b87ffeb, 0xfe54a320, 0x502637a6, 0xf5f56b6d, 0x4dc56e70,\n    0xe81632bb, 0x4664a63d, 0xe3b7faf6, 0xad077a04, 0x08d426cf,\n    0xa6a6b249, 0x0375ee82, 0xbb45eb9f, 0x1e96b754, 0xb0e423d2,\n    0x15377f19, 0xc08529e8, 0x65567523, 0xcb24e1a5, 0x6ef7bd6e,\n    0xd6c7b873, 0x7314e4b8, 0xdd66703e, 0x78b52cf5, 0x6c0a580f,\n    0xc9d904c4, 0x67ab9042, 0xc278cc89, 0x7a48c994, 0xdf9b955f,\n    0x71e901d9, 0xd43a5d12, 0x01880be3, 0xa45b5728, 0x0a29c3ae,\n    0xaffa9f65, 0x17ca9a78, 0xb219c6b3, 0x1c6b5235, 0xb9b80efe,\n    0xf7088e0c, 0x52dbd2c7, 0xfca94641, 0x597a1a8a, 0xe14a1f97,\n    0x4499435c, 0xeaebd7da, 0x4f388b11, 0x9a8adde0, 0x3f59812b,\n    0x912b15ad, 0x34f84966, 0x8cc84c7b, 0x291b10b0, 0x87698436,\n    0x22bad8fd, 0x5a0ff408, 0xffdca8c3, 0x51ae3c45, 0xf47d608e,\n    0x4c4d6593, 0xe99e3958, 0x47ecadde, 0xe23ff115, 0x378da7e4,\n    0x925efb2f, 0x3c2c6fa9, 0x99ff3362, 0x21cf367f, 0x841c6ab4,\n    0x2a6efe32, 0x8fbda2f9, 0xc10d220b, 0x64de7ec0, 0xcaacea46,\n    0x6f7fb68d, 0xd74fb390, 0x729cef5b, 0xdcee7bdd, 0x793d2716,\n    0xac8f71e7, 0x095c2d2c, 0xa72eb9aa, 0x02fde561, 0xbacde07c,\n    0x1f1ebcb7, 0xb16c2831, 0x14bf74fa, 0xd814b01e, 0x7dc7ecd5,\n    0xd3b57853, 0x76662498, 0xce562185, 0x6b857d4e, 0xc5f7e9c8,\n    0x6024b503, 0xb596e3f2, 0x1045bf39, 0xbe372bbf, 0x1be47774,\n    0xa3d47269, 0x06072ea2, 0xa875ba24, 0x0da6e6ef, 0x4316661d,\n    0xe6c53ad6, 0x48b7ae50, 0xed64f29b, 0x5554f786, 0xf087ab4d,\n    0x5ef53fcb, 0xfb266300, 0x2e9435f1, 0x8b47693a, 0x2535fdbc,\n    0x80e6a177, 0x38d6a46a, 0x9d05f8a1, 0x33776c27, 0x96a430ec,\n    0xee111c19, 0x4bc240d2, 0xe5b0d454, 0x4063889f, 0xf8538d82,\n    0x5d80d149, 0xf3f245cf, 0x56211904, 0x83934ff5, 0x2640133e,\n    0x883287b8, 0x2de1db73, 0x95d1de6e, 0x300282a5, 0x9e701623,\n    0x3ba34ae8, 0x7513ca1a, 0xd0c096d1, 0x7eb20257, 0xdb615e9c,\n    0x63515b81, 0xc682074a, 0x68f093cc, 0xcd23cf07, 0x189199f6,\n    0xbd42c53d, 0x133051bb, 0xb6e30d70, 0x0ed3086d, 0xab0054a6,\n    0x0572c020, 0xa0a19ceb, 0xb41ee811, 0x11cdb4da, 0xbfbf205c,\n    0x1a6c7c97, 0xa25c798a, 0x078f2541, 0xa9fdb1c7, 0x0c2eed0c,\n    0xd99cbbfd, 0x7c4fe736, 0xd23d73b0, 0x77ee2f7b, 0xcfde2a66,\n    0x6a0d76ad, 0xc47fe22b, 0x61acbee0, 0x2f1c3e12, 0x8acf62d9,\n    0x24bdf65f, 0x816eaa94, 0x395eaf89, 0x9c8df342, 0x32ff67c4,\n    0x972c3b0f, 0x429e6dfe, 0xe74d3135, 0x493fa5b3, 0xececf978,\n    0x54dcfc65, 0xf10fa0ae, 0x5f7d3428, 0xfaae68e3, 0x821b4416,\n    0x27c818dd, 0x89ba8c5b, 0x2c69d090, 0x9459d58d, 0x318a8946,\n    0x9ff81dc0, 0x3a2b410b, 0xef9917fa, 0x4a4a4b31, 0xe438dfb7,\n    0x41eb837c, 0xf9db8661, 0x5c08daaa, 0xf27a4e2c, 0x57a912e7,\n    0x19199215, 0xbccacede, 0x12b85a58, 0xb76b0693, 0x0f5b038e,\n    0xaa885f45, 0x04facbc3, 0xa1299708, 0x749bc1f9, 0xd1489d32,\n    0x7f3a09b4, 0xdae9557f, 0x62d95062, 0xc70a0ca9, 0x6978982f,\n    0xccabc4e4},\n   {0x00000000, 0xb40b77a6, 0x29119f97, 0x9d1ae831, 0x13244ff4,\n    0xa72f3852, 0x3a35d063, 0x8e3ea7c5, 0x674eef33, 0xd3459895,\n    0x4e5f70a4, 0xfa540702, 0x746aa0c7, 0xc061d761, 0x5d7b3f50,\n    0xe97048f6, 0xce9cde67, 0x7a97a9c1, 0xe78d41f0, 0x53863656,\n    0xddb89193, 0x69b3e635, 0xf4a90e04, 0x40a279a2, 0xa9d23154,\n    0x1dd946f2, 0x80c3aec3, 0x34c8d965, 0xbaf67ea0, 0x0efd0906,\n    0x93e7e137, 0x27ec9691, 0x9c39bdcf, 0x2832ca69, 0xb5282258,\n    0x012355fe, 0x8f1df23b, 0x3b16859d, 0xa60c6dac, 0x12071a0a,\n    0xfb7752fc, 0x4f7c255a, 0xd266cd6b, 0x666dbacd, 0xe8531d08,\n    0x5c586aae, 0xc142829f, 0x7549f539, 0x52a563a8, 0xe6ae140e,\n    0x7bb4fc3f, 0xcfbf8b99, 0x41812c5c, 0xf58a5bfa, 0x6890b3cb,\n    0xdc9bc46d, 0x35eb8c9b, 0x81e0fb3d, 0x1cfa130c, 0xa8f164aa,\n    0x26cfc36f, 0x92c4b4c9, 0x0fde5cf8, 0xbbd52b5e, 0x79750b44,\n    0xcd7e7ce2, 0x506494d3, 0xe46fe375, 0x6a5144b0, 0xde5a3316,\n    0x4340db27, 0xf74bac81, 0x1e3be477, 0xaa3093d1, 0x372a7be0,\n    0x83210c46, 0x0d1fab83, 0xb914dc25, 0x240e3414, 0x900543b2,\n    0xb7e9d523, 0x03e2a285, 0x9ef84ab4, 0x2af33d12, 0xa4cd9ad7,\n    0x10c6ed71, 0x8ddc0540, 0x39d772e6, 0xd0a73a10, 0x64ac4db6,\n    0xf9b6a587, 0x4dbdd221, 0xc38375e4, 0x77880242, 0xea92ea73,\n    0x5e999dd5, 0xe54cb68b, 0x5147c12d, 0xcc5d291c, 0x78565eba,\n    0xf668f97f, 0x42638ed9, 0xdf7966e8, 0x6b72114e, 0x820259b8,\n    0x36092e1e, 0xab13c62f, 0x1f18b189, 0x9126164c, 0x252d61ea,\n    0xb83789db, 0x0c3cfe7d, 0x2bd068ec, 0x9fdb1f4a, 0x02c1f77b,\n    0xb6ca80dd, 0x38f42718, 0x8cff50be, 0x11e5b88f, 0xa5eecf29,\n    0x4c9e87df, 0xf895f079, 0x658f1848, 0xd1846fee, 0x5fbac82b,\n    0xebb1bf8d, 0x76ab57bc, 0xc2a0201a, 0xf2ea1688, 0x46e1612e,\n    0xdbfb891f, 0x6ff0feb9, 0xe1ce597c, 0x55c52eda, 0xc8dfc6eb,\n    0x7cd4b14d, 0x95a4f9bb, 0x21af8e1d, 0xbcb5662c, 0x08be118a,\n    0x8680b64f, 0x328bc1e9, 0xaf9129d8, 0x1b9a5e7e, 0x3c76c8ef,\n    0x887dbf49, 0x15675778, 0xa16c20de, 0x2f52871b, 0x9b59f0bd,\n    0x0643188c, 0xb2486f2a, 0x5b3827dc, 0xef33507a, 0x7229b84b,\n    0xc622cfed, 0x481c6828, 0xfc171f8e, 0x610df7bf, 0xd5068019,\n    0x6ed3ab47, 0xdad8dce1, 0x47c234d0, 0xf3c94376, 0x7df7e4b3,\n    0xc9fc9315, 0x54e67b24, 0xe0ed0c82, 0x099d4474, 0xbd9633d2,\n    0x208cdbe3, 0x9487ac45, 0x1ab90b80, 0xaeb27c26, 0x33a89417,\n    0x87a3e3b1, 0xa04f7520, 0x14440286, 0x895eeab7, 0x3d559d11,\n    0xb36b3ad4, 0x07604d72, 0x9a7aa543, 0x2e71d2e5, 0xc7019a13,\n    0x730aedb5, 0xee100584, 0x5a1b7222, 0xd425d5e7, 0x602ea241,\n    0xfd344a70, 0x493f3dd6, 0x8b9f1dcc, 0x3f946a6a, 0xa28e825b,\n    0x1685f5fd, 0x98bb5238, 0x2cb0259e, 0xb1aacdaf, 0x05a1ba09,\n    0xecd1f2ff, 0x58da8559, 0xc5c06d68, 0x71cb1ace, 0xfff5bd0b,\n    0x4bfecaad, 0xd6e4229c, 0x62ef553a, 0x4503c3ab, 0xf108b40d,\n    0x6c125c3c, 0xd8192b9a, 0x56278c5f, 0xe22cfbf9, 0x7f3613c8,\n    0xcb3d646e, 0x224d2c98, 0x96465b3e, 0x0b5cb30f, 0xbf57c4a9,\n    0x3169636c, 0x856214ca, 0x1878fcfb, 0xac738b5d, 0x17a6a003,\n    0xa3add7a5, 0x3eb73f94, 0x8abc4832, 0x0482eff7, 0xb0899851,\n    0x2d937060, 0x999807c6, 0x70e84f30, 0xc4e33896, 0x59f9d0a7,\n    0xedf2a701, 0x63cc00c4, 0xd7c77762, 0x4add9f53, 0xfed6e8f5,\n    0xd93a7e64, 0x6d3109c2, 0xf02be1f3, 0x44209655, 0xca1e3190,\n    0x7e154636, 0xe30fae07, 0x5704d9a1, 0xbe749157, 0x0a7fe6f1,\n    0x97650ec0, 0x236e7966, 0xad50dea3, 0x195ba905, 0x84414134,\n    0x304a3692},\n   {0x00000000, 0x9e00aacc, 0x7d072542, 0xe3078f8e, 0xfa0e4a84,\n    0x640ee048, 0x87096fc6, 0x1909c50a, 0xb51be5d3, 0x2b1b4f1f,\n    0xc81cc091, 0x561c6a5d, 0x4f15af57, 0xd115059b, 0x32128a15,\n    0xac1220d9, 0x2b31bb7c, 0xb53111b0, 0x56369e3e, 0xc83634f2,\n    0xd13ff1f8, 0x4f3f5b34, 0xac38d4ba, 0x32387e76, 0x9e2a5eaf,\n    0x002af463, 0xe32d7bed, 0x7d2dd121, 0x6424142b, 0xfa24bee7,\n    0x19233169, 0x87239ba5, 0x566276f9, 0xc862dc35, 0x2b6553bb,\n    0xb565f977, 0xac6c3c7d, 0x326c96b1, 0xd16b193f, 0x4f6bb3f3,\n    0xe379932a, 0x7d7939e6, 0x9e7eb668, 0x007e1ca4, 0x1977d9ae,\n    0x87777362, 0x6470fcec, 0xfa705620, 0x7d53cd85, 0xe3536749,\n    0x0054e8c7, 0x9e54420b, 0x875d8701, 0x195d2dcd, 0xfa5aa243,\n    0x645a088f, 0xc8482856, 0x5648829a, 0xb54f0d14, 0x2b4fa7d8,\n    0x324662d2, 0xac46c81e, 0x4f414790, 0xd141ed5c, 0xedc29d29,\n    0x73c237e5, 0x90c5b86b, 0x0ec512a7, 0x17ccd7ad, 0x89cc7d61,\n    0x6acbf2ef, 0xf4cb5823, 0x58d978fa, 0xc6d9d236, 0x25de5db8,\n    0xbbdef774, 0xa2d7327e, 0x3cd798b2, 0xdfd0173c, 0x41d0bdf0,\n    0xc6f32655, 0x58f38c99, 0xbbf40317, 0x25f4a9db, 0x3cfd6cd1,\n    0xa2fdc61d, 0x41fa4993, 0xdffae35f, 0x73e8c386, 0xede8694a,\n    0x0eefe6c4, 0x90ef4c08, 0x89e68902, 0x17e623ce, 0xf4e1ac40,\n    0x6ae1068c, 0xbba0ebd0, 0x25a0411c, 0xc6a7ce92, 0x58a7645e,\n    0x41aea154, 0xdfae0b98, 0x3ca98416, 0xa2a92eda, 0x0ebb0e03,\n    0x90bba4cf, 0x73bc2b41, 0xedbc818d, 0xf4b54487, 0x6ab5ee4b,\n    0x89b261c5, 0x17b2cb09, 0x909150ac, 0x0e91fa60, 0xed9675ee,\n    0x7396df22, 0x6a9f1a28, 0xf49fb0e4, 0x17983f6a, 0x899895a6,\n    0x258ab57f, 0xbb8a1fb3, 0x588d903d, 0xc68d3af1, 0xdf84fffb,\n    0x41845537, 0xa283dab9, 0x3c837075, 0xda853b53, 0x4485919f,\n    0xa7821e11, 0x3982b4dd, 0x208b71d7, 0xbe8bdb1b, 0x5d8c5495,\n    0xc38cfe59, 0x6f9ede80, 0xf19e744c, 0x1299fbc2, 0x8c99510e,\n    0x95909404, 0x0b903ec8, 0xe897b146, 0x76971b8a, 0xf1b4802f,\n    0x6fb42ae3, 0x8cb3a56d, 0x12b30fa1, 0x0bbacaab, 0x95ba6067,\n    0x76bdefe9, 0xe8bd4525, 0x44af65fc, 0xdaafcf30, 0x39a840be,\n    0xa7a8ea72, 0xbea12f78, 0x20a185b4, 0xc3a60a3a, 0x5da6a0f6,\n    0x8ce74daa, 0x12e7e766, 0xf1e068e8, 0x6fe0c224, 0x76e9072e,\n    0xe8e9ade2, 0x0bee226c, 0x95ee88a0, 0x39fca879, 0xa7fc02b5,\n    0x44fb8d3b, 0xdafb27f7, 0xc3f2e2fd, 0x5df24831, 0xbef5c7bf,\n    0x20f56d73, 0xa7d6f6d6, 0x39d65c1a, 0xdad1d394, 0x44d17958,\n    0x5dd8bc52, 0xc3d8169e, 0x20df9910, 0xbedf33dc, 0x12cd1305,\n    0x8ccdb9c9, 0x6fca3647, 0xf1ca9c8b, 0xe8c35981, 0x76c3f34d,\n    0x95c47cc3, 0x0bc4d60f, 0x3747a67a, 0xa9470cb6, 0x4a408338,\n    0xd44029f4, 0xcd49ecfe, 0x53494632, 0xb04ec9bc, 0x2e4e6370,\n    0x825c43a9, 0x1c5ce965, 0xff5b66eb, 0x615bcc27, 0x7852092d,\n    0xe652a3e1, 0x05552c6f, 0x9b5586a3, 0x1c761d06, 0x8276b7ca,\n    0x61713844, 0xff719288, 0xe6785782, 0x7878fd4e, 0x9b7f72c0,\n    0x057fd80c, 0xa96df8d5, 0x376d5219, 0xd46add97, 0x4a6a775b,\n    0x5363b251, 0xcd63189d, 0x2e649713, 0xb0643ddf, 0x6125d083,\n    0xff257a4f, 0x1c22f5c1, 0x82225f0d, 0x9b2b9a07, 0x052b30cb,\n    0xe62cbf45, 0x782c1589, 0xd43e3550, 0x4a3e9f9c, 0xa9391012,\n    0x3739bade, 0x2e307fd4, 0xb030d518, 0x53375a96, 0xcd37f05a,\n    0x4a146bff, 0xd414c133, 0x37134ebd, 0xa913e471, 0xb01a217b,\n    0x2e1a8bb7, 0xcd1d0439, 0x531daef5, 0xff0f8e2c, 0x610f24e0,\n    0x8208ab6e, 0x1c0801a2, 0x0501c4a8, 0x9b016e64, 0x7806e1ea,\n    0xe6064b26}};\n\n#endif /* W */\n\n#endif /* N == 2 */\n#if N == 3\n\n#if W == 8\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0x81256527, 0xd93bcc0f, 0x581ea928, 0x69069e5f,\n    0xe823fb78, 0xb03d5250, 0x31183777, 0xd20d3cbe, 0x53285999,\n    0x0b36f0b1, 0x8a139596, 0xbb0ba2e1, 0x3a2ec7c6, 0x62306eee,\n    0xe3150bc9, 0x7f6b7f3d, 0xfe4e1a1a, 0xa650b332, 0x2775d615,\n    0x166de162, 0x97488445, 0xcf562d6d, 0x4e73484a, 0xad664383,\n    0x2c4326a4, 0x745d8f8c, 0xf578eaab, 0xc460dddc, 0x4545b8fb,\n    0x1d5b11d3, 0x9c7e74f4, 0xfed6fe7a, 0x7ff39b5d, 0x27ed3275,\n    0xa6c85752, 0x97d06025, 0x16f50502, 0x4eebac2a, 0xcfcec90d,\n    0x2cdbc2c4, 0xadfea7e3, 0xf5e00ecb, 0x74c56bec, 0x45dd5c9b,\n    0xc4f839bc, 0x9ce69094, 0x1dc3f5b3, 0x81bd8147, 0x0098e460,\n    0x58864d48, 0xd9a3286f, 0xe8bb1f18, 0x699e7a3f, 0x3180d317,\n    0xb0a5b630, 0x53b0bdf9, 0xd295d8de, 0x8a8b71f6, 0x0bae14d1,\n    0x3ab623a6, 0xbb934681, 0xe38defa9, 0x62a88a8e, 0x26dcfab5,\n    0xa7f99f92, 0xffe736ba, 0x7ec2539d, 0x4fda64ea, 0xceff01cd,\n    0x96e1a8e5, 0x17c4cdc2, 0xf4d1c60b, 0x75f4a32c, 0x2dea0a04,\n    0xaccf6f23, 0x9dd75854, 0x1cf23d73, 0x44ec945b, 0xc5c9f17c,\n    0x59b78588, 0xd892e0af, 0x808c4987, 0x01a92ca0, 0x30b11bd7,\n    0xb1947ef0, 0xe98ad7d8, 0x68afb2ff, 0x8bbab936, 0x0a9fdc11,\n    0x52817539, 0xd3a4101e, 0xe2bc2769, 0x6399424e, 0x3b87eb66,\n    0xbaa28e41, 0xd80a04cf, 0x592f61e8, 0x0131c8c0, 0x8014ade7,\n    0xb10c9a90, 0x3029ffb7, 0x6837569f, 0xe91233b8, 0x0a073871,\n    0x8b225d56, 0xd33cf47e, 0x52199159, 0x6301a62e, 0xe224c309,\n    0xba3a6a21, 0x3b1f0f06, 0xa7617bf2, 0x26441ed5, 0x7e5ab7fd,\n    0xff7fd2da, 0xce67e5ad, 0x4f42808a, 0x175c29a2, 0x96794c85,\n    0x756c474c, 0xf449226b, 0xac578b43, 0x2d72ee64, 0x1c6ad913,\n    0x9d4fbc34, 0xc551151c, 0x4474703b, 0x4db9f56a, 0xcc9c904d,\n    0x94823965, 0x15a75c42, 0x24bf6b35, 0xa59a0e12, 0xfd84a73a,\n    0x7ca1c21d, 0x9fb4c9d4, 0x1e91acf3, 0x468f05db, 0xc7aa60fc,\n    0xf6b2578b, 0x779732ac, 0x2f899b84, 0xaeacfea3, 0x32d28a57,\n    0xb3f7ef70, 0xebe94658, 0x6acc237f, 0x5bd41408, 0xdaf1712f,\n    0x82efd807, 0x03cabd20, 0xe0dfb6e9, 0x61fad3ce, 0x39e47ae6,\n    0xb8c11fc1, 0x89d928b6, 0x08fc4d91, 0x50e2e4b9, 0xd1c7819e,\n    0xb36f0b10, 0x324a6e37, 0x6a54c71f, 0xeb71a238, 0xda69954f,\n    0x5b4cf068, 0x03525940, 0x82773c67, 0x616237ae, 0xe0475289,\n    0xb859fba1, 0x397c9e86, 0x0864a9f1, 0x8941ccd6, 0xd15f65fe,\n    0x507a00d9, 0xcc04742d, 0x4d21110a, 0x153fb822, 0x941add05,\n    0xa502ea72, 0x24278f55, 0x7c39267d, 0xfd1c435a, 0x1e094893,\n    0x9f2c2db4, 0xc732849c, 0x4617e1bb, 0x770fd6cc, 0xf62ab3eb,\n    0xae341ac3, 0x2f117fe4, 0x6b650fdf, 0xea406af8, 0xb25ec3d0,\n    0x337ba6f7, 0x02639180, 0x8346f4a7, 0xdb585d8f, 0x5a7d38a8,\n    0xb9683361, 0x384d5646, 0x6053ff6e, 0xe1769a49, 0xd06ead3e,\n    0x514bc819, 0x09556131, 0x88700416, 0x140e70e2, 0x952b15c5,\n    0xcd35bced, 0x4c10d9ca, 0x7d08eebd, 0xfc2d8b9a, 0xa43322b2,\n    0x25164795, 0xc6034c5c, 0x4726297b, 0x1f388053, 0x9e1de574,\n    0xaf05d203, 0x2e20b724, 0x763e1e0c, 0xf71b7b2b, 0x95b3f1a5,\n    0x14969482, 0x4c883daa, 0xcdad588d, 0xfcb56ffa, 0x7d900add,\n    0x258ea3f5, 0xa4abc6d2, 0x47becd1b, 0xc69ba83c, 0x9e850114,\n    0x1fa06433, 0x2eb85344, 0xaf9d3663, 0xf7839f4b, 0x76a6fa6c,\n    0xead88e98, 0x6bfdebbf, 0x33e34297, 0xb2c627b0, 0x83de10c7,\n    0x02fb75e0, 0x5ae5dcc8, 0xdbc0b9ef, 0x38d5b226, 0xb9f0d701,\n    0xe1ee7e29, 0x60cb1b0e, 0x51d32c79, 0xd0f6495e, 0x88e8e076,\n    0x09cd8551},\n   {0x00000000, 0x9b73ead4, 0xed96d3e9, 0x76e5393d, 0x005ca193,\n    0x9b2f4b47, 0xedca727a, 0x76b998ae, 0x00b94326, 0x9bcaa9f2,\n    0xed2f90cf, 0x765c7a1b, 0x00e5e2b5, 0x9b960861, 0xed73315c,\n    0x7600db88, 0x0172864c, 0x9a016c98, 0xece455a5, 0x7797bf71,\n    0x012e27df, 0x9a5dcd0b, 0xecb8f436, 0x77cb1ee2, 0x01cbc56a,\n    0x9ab82fbe, 0xec5d1683, 0x772efc57, 0x019764f9, 0x9ae48e2d,\n    0xec01b710, 0x77725dc4, 0x02e50c98, 0x9996e64c, 0xef73df71,\n    0x740035a5, 0x02b9ad0b, 0x99ca47df, 0xef2f7ee2, 0x745c9436,\n    0x025c4fbe, 0x992fa56a, 0xefca9c57, 0x74b97683, 0x0200ee2d,\n    0x997304f9, 0xef963dc4, 0x74e5d710, 0x03978ad4, 0x98e46000,\n    0xee01593d, 0x7572b3e9, 0x03cb2b47, 0x98b8c193, 0xee5df8ae,\n    0x752e127a, 0x032ec9f2, 0x985d2326, 0xeeb81a1b, 0x75cbf0cf,\n    0x03726861, 0x980182b5, 0xeee4bb88, 0x7597515c, 0x05ca1930,\n    0x9eb9f3e4, 0xe85ccad9, 0x732f200d, 0x0596b8a3, 0x9ee55277,\n    0xe8006b4a, 0x7373819e, 0x05735a16, 0x9e00b0c2, 0xe8e589ff,\n    0x7396632b, 0x052ffb85, 0x9e5c1151, 0xe8b9286c, 0x73cac2b8,\n    0x04b89f7c, 0x9fcb75a8, 0xe92e4c95, 0x725da641, 0x04e43eef,\n    0x9f97d43b, 0xe972ed06, 0x720107d2, 0x0401dc5a, 0x9f72368e,\n    0xe9970fb3, 0x72e4e567, 0x045d7dc9, 0x9f2e971d, 0xe9cbae20,\n    0x72b844f4, 0x072f15a8, 0x9c5cff7c, 0xeab9c641, 0x71ca2c95,\n    0x0773b43b, 0x9c005eef, 0xeae567d2, 0x71968d06, 0x0796568e,\n    0x9ce5bc5a, 0xea008567, 0x71736fb3, 0x07caf71d, 0x9cb91dc9,\n    0xea5c24f4, 0x712fce20, 0x065d93e4, 0x9d2e7930, 0xebcb400d,\n    0x70b8aad9, 0x06013277, 0x9d72d8a3, 0xeb97e19e, 0x70e40b4a,\n    0x06e4d0c2, 0x9d973a16, 0xeb72032b, 0x7001e9ff, 0x06b87151,\n    0x9dcb9b85, 0xeb2ea2b8, 0x705d486c, 0x0b943260, 0x90e7d8b4,\n    0xe602e189, 0x7d710b5d, 0x0bc893f3, 0x90bb7927, 0xe65e401a,\n    0x7d2daace, 0x0b2d7146, 0x905e9b92, 0xe6bba2af, 0x7dc8487b,\n    0x0b71d0d5, 0x90023a01, 0xe6e7033c, 0x7d94e9e8, 0x0ae6b42c,\n    0x91955ef8, 0xe77067c5, 0x7c038d11, 0x0aba15bf, 0x91c9ff6b,\n    0xe72cc656, 0x7c5f2c82, 0x0a5ff70a, 0x912c1dde, 0xe7c924e3,\n    0x7cbace37, 0x0a035699, 0x9170bc4d, 0xe7958570, 0x7ce66fa4,\n    0x09713ef8, 0x9202d42c, 0xe4e7ed11, 0x7f9407c5, 0x092d9f6b,\n    0x925e75bf, 0xe4bb4c82, 0x7fc8a656, 0x09c87dde, 0x92bb970a,\n    0xe45eae37, 0x7f2d44e3, 0x0994dc4d, 0x92e73699, 0xe4020fa4,\n    0x7f71e570, 0x0803b8b4, 0x93705260, 0xe5956b5d, 0x7ee68189,\n    0x085f1927, 0x932cf3f3, 0xe5c9cace, 0x7eba201a, 0x08bafb92,\n    0x93c91146, 0xe52c287b, 0x7e5fc2af, 0x08e65a01, 0x9395b0d5,\n    0xe57089e8, 0x7e03633c, 0x0e5e2b50, 0x952dc184, 0xe3c8f8b9,\n    0x78bb126d, 0x0e028ac3, 0x95716017, 0xe394592a, 0x78e7b3fe,\n    0x0ee76876, 0x959482a2, 0xe371bb9f, 0x7802514b, 0x0ebbc9e5,\n    0x95c82331, 0xe32d1a0c, 0x785ef0d8, 0x0f2cad1c, 0x945f47c8,\n    0xe2ba7ef5, 0x79c99421, 0x0f700c8f, 0x9403e65b, 0xe2e6df66,\n    0x799535b2, 0x0f95ee3a, 0x94e604ee, 0xe2033dd3, 0x7970d707,\n    0x0fc94fa9, 0x94baa57d, 0xe25f9c40, 0x792c7694, 0x0cbb27c8,\n    0x97c8cd1c, 0xe12df421, 0x7a5e1ef5, 0x0ce7865b, 0x97946c8f,\n    0xe17155b2, 0x7a02bf66, 0x0c0264ee, 0x97718e3a, 0xe194b707,\n    0x7ae75dd3, 0x0c5ec57d, 0x972d2fa9, 0xe1c81694, 0x7abbfc40,\n    0x0dc9a184, 0x96ba4b50, 0xe05f726d, 0x7b2c98b9, 0x0d950017,\n    0x96e6eac3, 0xe003d3fe, 0x7b70392a, 0x0d70e2a2, 0x96030876,\n    0xe0e6314b, 0x7b95db9f, 0x0d2c4331, 0x965fa9e5, 0xe0ba90d8,\n    0x7bc97a0c},\n   {0x00000000, 0x172864c0, 0x2e50c980, 0x3978ad40, 0x5ca19300,\n    0x4b89f7c0, 0x72f15a80, 0x65d93e40, 0xb9432600, 0xae6b42c0,\n    0x9713ef80, 0x803b8b40, 0xe5e2b500, 0xf2cad1c0, 0xcbb27c80,\n    0xdc9a1840, 0xa9f74a41, 0xbedf2e81, 0x87a783c1, 0x908fe701,\n    0xf556d941, 0xe27ebd81, 0xdb0610c1, 0xcc2e7401, 0x10b46c41,\n    0x079c0881, 0x3ee4a5c1, 0x29ccc101, 0x4c15ff41, 0x5b3d9b81,\n    0x624536c1, 0x756d5201, 0x889f92c3, 0x9fb7f603, 0xa6cf5b43,\n    0xb1e73f83, 0xd43e01c3, 0xc3166503, 0xfa6ec843, 0xed46ac83,\n    0x31dcb4c3, 0x26f4d003, 0x1f8c7d43, 0x08a41983, 0x6d7d27c3,\n    0x7a554303, 0x432dee43, 0x54058a83, 0x2168d882, 0x3640bc42,\n    0x0f381102, 0x181075c2, 0x7dc94b82, 0x6ae12f42, 0x53998202,\n    0x44b1e6c2, 0x982bfe82, 0x8f039a42, 0xb67b3702, 0xa15353c2,\n    0xc48a6d82, 0xd3a20942, 0xeadaa402, 0xfdf2c0c2, 0xca4e23c7,\n    0xdd664707, 0xe41eea47, 0xf3368e87, 0x96efb0c7, 0x81c7d407,\n    0xb8bf7947, 0xaf971d87, 0x730d05c7, 0x64256107, 0x5d5dcc47,\n    0x4a75a887, 0x2fac96c7, 0x3884f207, 0x01fc5f47, 0x16d43b87,\n    0x63b96986, 0x74910d46, 0x4de9a006, 0x5ac1c4c6, 0x3f18fa86,\n    0x28309e46, 0x11483306, 0x066057c6, 0xdafa4f86, 0xcdd22b46,\n    0xf4aa8606, 0xe382e2c6, 0x865bdc86, 0x9173b846, 0xa80b1506,\n    0xbf2371c6, 0x42d1b104, 0x55f9d5c4, 0x6c817884, 0x7ba91c44,\n    0x1e702204, 0x095846c4, 0x3020eb84, 0x27088f44, 0xfb929704,\n    0xecbaf3c4, 0xd5c25e84, 0xc2ea3a44, 0xa7330404, 0xb01b60c4,\n    0x8963cd84, 0x9e4ba944, 0xeb26fb45, 0xfc0e9f85, 0xc57632c5,\n    0xd25e5605, 0xb7876845, 0xa0af0c85, 0x99d7a1c5, 0x8effc505,\n    0x5265dd45, 0x454db985, 0x7c3514c5, 0x6b1d7005, 0x0ec44e45,\n    0x19ec2a85, 0x209487c5, 0x37bce305, 0x4fed41cf, 0x58c5250f,\n    0x61bd884f, 0x7695ec8f, 0x134cd2cf, 0x0464b60f, 0x3d1c1b4f,\n    0x2a347f8f, 0xf6ae67cf, 0xe186030f, 0xd8feae4f, 0xcfd6ca8f,\n    0xaa0ff4cf, 0xbd27900f, 0x845f3d4f, 0x9377598f, 0xe61a0b8e,\n    0xf1326f4e, 0xc84ac20e, 0xdf62a6ce, 0xbabb988e, 0xad93fc4e,\n    0x94eb510e, 0x83c335ce, 0x5f592d8e, 0x4871494e, 0x7109e40e,\n    0x662180ce, 0x03f8be8e, 0x14d0da4e, 0x2da8770e, 0x3a8013ce,\n    0xc772d30c, 0xd05ab7cc, 0xe9221a8c, 0xfe0a7e4c, 0x9bd3400c,\n    0x8cfb24cc, 0xb583898c, 0xa2abed4c, 0x7e31f50c, 0x691991cc,\n    0x50613c8c, 0x4749584c, 0x2290660c, 0x35b802cc, 0x0cc0af8c,\n    0x1be8cb4c, 0x6e85994d, 0x79adfd8d, 0x40d550cd, 0x57fd340d,\n    0x32240a4d, 0x250c6e8d, 0x1c74c3cd, 0x0b5ca70d, 0xd7c6bf4d,\n    0xc0eedb8d, 0xf99676cd, 0xeebe120d, 0x8b672c4d, 0x9c4f488d,\n    0xa537e5cd, 0xb21f810d, 0x85a36208, 0x928b06c8, 0xabf3ab88,\n    0xbcdbcf48, 0xd902f108, 0xce2a95c8, 0xf7523888, 0xe07a5c48,\n    0x3ce04408, 0x2bc820c8, 0x12b08d88, 0x0598e948, 0x6041d708,\n    0x7769b3c8, 0x4e111e88, 0x59397a48, 0x2c542849, 0x3b7c4c89,\n    0x0204e1c9, 0x152c8509, 0x70f5bb49, 0x67dddf89, 0x5ea572c9,\n    0x498d1609, 0x95170e49, 0x823f6a89, 0xbb47c7c9, 0xac6fa309,\n    0xc9b69d49, 0xde9ef989, 0xe7e654c9, 0xf0ce3009, 0x0d3cf0cb,\n    0x1a14940b, 0x236c394b, 0x34445d8b, 0x519d63cb, 0x46b5070b,\n    0x7fcdaa4b, 0x68e5ce8b, 0xb47fd6cb, 0xa357b20b, 0x9a2f1f4b,\n    0x8d077b8b, 0xe8de45cb, 0xfff6210b, 0xc68e8c4b, 0xd1a6e88b,\n    0xa4cbba8a, 0xb3e3de4a, 0x8a9b730a, 0x9db317ca, 0xf86a298a,\n    0xef424d4a, 0xd63ae00a, 0xc11284ca, 0x1d889c8a, 0x0aa0f84a,\n    0x33d8550a, 0x24f031ca, 0x41290f8a, 0x56016b4a, 0x6f79c60a,\n    0x7851a2ca},\n   {0x00000000, 0x9fda839e, 0xe4c4017d, 0x7b1e82e3, 0x12f904bb,\n    0x8d238725, 0xf63d05c6, 0x69e78658, 0x25f20976, 0xba288ae8,\n    0xc136080b, 0x5eec8b95, 0x370b0dcd, 0xa8d18e53, 0xd3cf0cb0,\n    0x4c158f2e, 0x4be412ec, 0xd43e9172, 0xaf201391, 0x30fa900f,\n    0x591d1657, 0xc6c795c9, 0xbdd9172a, 0x220394b4, 0x6e161b9a,\n    0xf1cc9804, 0x8ad21ae7, 0x15089979, 0x7cef1f21, 0xe3359cbf,\n    0x982b1e5c, 0x07f19dc2, 0x97c825d8, 0x0812a646, 0x730c24a5,\n    0xecd6a73b, 0x85312163, 0x1aeba2fd, 0x61f5201e, 0xfe2fa380,\n    0xb23a2cae, 0x2de0af30, 0x56fe2dd3, 0xc924ae4d, 0xa0c32815,\n    0x3f19ab8b, 0x44072968, 0xdbddaaf6, 0xdc2c3734, 0x43f6b4aa,\n    0x38e83649, 0xa732b5d7, 0xced5338f, 0x510fb011, 0x2a1132f2,\n    0xb5cbb16c, 0xf9de3e42, 0x6604bddc, 0x1d1a3f3f, 0x82c0bca1,\n    0xeb273af9, 0x74fdb967, 0x0fe33b84, 0x9039b81a, 0xf4e14df1,\n    0x6b3bce6f, 0x10254c8c, 0x8fffcf12, 0xe618494a, 0x79c2cad4,\n    0x02dc4837, 0x9d06cba9, 0xd1134487, 0x4ec9c719, 0x35d745fa,\n    0xaa0dc664, 0xc3ea403c, 0x5c30c3a2, 0x272e4141, 0xb8f4c2df,\n    0xbf055f1d, 0x20dfdc83, 0x5bc15e60, 0xc41bddfe, 0xadfc5ba6,\n    0x3226d838, 0x49385adb, 0xd6e2d945, 0x9af7566b, 0x052dd5f5,\n    0x7e335716, 0xe1e9d488, 0x880e52d0, 0x17d4d14e, 0x6cca53ad,\n    0xf310d033, 0x63296829, 0xfcf3ebb7, 0x87ed6954, 0x1837eaca,\n    0x71d06c92, 0xee0aef0c, 0x95146def, 0x0aceee71, 0x46db615f,\n    0xd901e2c1, 0xa21f6022, 0x3dc5e3bc, 0x542265e4, 0xcbf8e67a,\n    0xb0e66499, 0x2f3ce707, 0x28cd7ac5, 0xb717f95b, 0xcc097bb8,\n    0x53d3f826, 0x3a347e7e, 0xa5eefde0, 0xdef07f03, 0x412afc9d,\n    0x0d3f73b3, 0x92e5f02d, 0xe9fb72ce, 0x7621f150, 0x1fc67708,\n    0x801cf496, 0xfb027675, 0x64d8f5eb, 0x32b39da3, 0xad691e3d,\n    0xd6779cde, 0x49ad1f40, 0x204a9918, 0xbf901a86, 0xc48e9865,\n    0x5b541bfb, 0x174194d5, 0x889b174b, 0xf38595a8, 0x6c5f1636,\n    0x05b8906e, 0x9a6213f0, 0xe17c9113, 0x7ea6128d, 0x79578f4f,\n    0xe68d0cd1, 0x9d938e32, 0x02490dac, 0x6bae8bf4, 0xf474086a,\n    0x8f6a8a89, 0x10b00917, 0x5ca58639, 0xc37f05a7, 0xb8618744,\n    0x27bb04da, 0x4e5c8282, 0xd186011c, 0xaa9883ff, 0x35420061,\n    0xa57bb87b, 0x3aa13be5, 0x41bfb906, 0xde653a98, 0xb782bcc0,\n    0x28583f5e, 0x5346bdbd, 0xcc9c3e23, 0x8089b10d, 0x1f533293,\n    0x644db070, 0xfb9733ee, 0x9270b5b6, 0x0daa3628, 0x76b4b4cb,\n    0xe96e3755, 0xee9faa97, 0x71452909, 0x0a5babea, 0x95812874,\n    0xfc66ae2c, 0x63bc2db2, 0x18a2af51, 0x87782ccf, 0xcb6da3e1,\n    0x54b7207f, 0x2fa9a29c, 0xb0732102, 0xd994a75a, 0x464e24c4,\n    0x3d50a627, 0xa28a25b9, 0xc652d052, 0x598853cc, 0x2296d12f,\n    0xbd4c52b1, 0xd4abd4e9, 0x4b715777, 0x306fd594, 0xafb5560a,\n    0xe3a0d924, 0x7c7a5aba, 0x0764d859, 0x98be5bc7, 0xf159dd9f,\n    0x6e835e01, 0x159ddce2, 0x8a475f7c, 0x8db6c2be, 0x126c4120,\n    0x6972c3c3, 0xf6a8405d, 0x9f4fc605, 0x0095459b, 0x7b8bc778,\n    0xe45144e6, 0xa844cbc8, 0x379e4856, 0x4c80cab5, 0xd35a492b,\n    0xbabdcf73, 0x25674ced, 0x5e79ce0e, 0xc1a34d90, 0x519af58a,\n    0xce407614, 0xb55ef4f7, 0x2a847769, 0x4363f131, 0xdcb972af,\n    0xa7a7f04c, 0x387d73d2, 0x7468fcfc, 0xebb27f62, 0x90acfd81,\n    0x0f767e1f, 0x6691f847, 0xf94b7bd9, 0x8255f93a, 0x1d8f7aa4,\n    0x1a7ee766, 0x85a464f8, 0xfebae61b, 0x61606585, 0x0887e3dd,\n    0x975d6043, 0xec43e2a0, 0x7399613e, 0x3f8cee10, 0xa0566d8e,\n    0xdb48ef6d, 0x44926cf3, 0x2d75eaab, 0xb2af6935, 0xc9b1ebd6,\n    0x566b6848},\n   {0x00000000, 0x65673b46, 0xcace768c, 0xafa94dca, 0x4eedeb59,\n    0x2b8ad01f, 0x84239dd5, 0xe144a693, 0x9ddbd6b2, 0xf8bcedf4,\n    0x5715a03e, 0x32729b78, 0xd3363deb, 0xb65106ad, 0x19f84b67,\n    0x7c9f7021, 0xe0c6ab25, 0x85a19063, 0x2a08dda9, 0x4f6fe6ef,\n    0xae2b407c, 0xcb4c7b3a, 0x64e536f0, 0x01820db6, 0x7d1d7d97,\n    0x187a46d1, 0xb7d30b1b, 0xd2b4305d, 0x33f096ce, 0x5697ad88,\n    0xf93ee042, 0x9c59db04, 0x1afc500b, 0x7f9b6b4d, 0xd0322687,\n    0xb5551dc1, 0x5411bb52, 0x31768014, 0x9edfcdde, 0xfbb8f698,\n    0x872786b9, 0xe240bdff, 0x4de9f035, 0x288ecb73, 0xc9ca6de0,\n    0xacad56a6, 0x03041b6c, 0x6663202a, 0xfa3afb2e, 0x9f5dc068,\n    0x30f48da2, 0x5593b6e4, 0xb4d71077, 0xd1b02b31, 0x7e1966fb,\n    0x1b7e5dbd, 0x67e12d9c, 0x028616da, 0xad2f5b10, 0xc8486056,\n    0x290cc6c5, 0x4c6bfd83, 0xe3c2b049, 0x86a58b0f, 0x35f8a016,\n    0x509f9b50, 0xff36d69a, 0x9a51eddc, 0x7b154b4f, 0x1e727009,\n    0xb1db3dc3, 0xd4bc0685, 0xa82376a4, 0xcd444de2, 0x62ed0028,\n    0x078a3b6e, 0xe6ce9dfd, 0x83a9a6bb, 0x2c00eb71, 0x4967d037,\n    0xd53e0b33, 0xb0593075, 0x1ff07dbf, 0x7a9746f9, 0x9bd3e06a,\n    0xfeb4db2c, 0x511d96e6, 0x347aada0, 0x48e5dd81, 0x2d82e6c7,\n    0x822bab0d, 0xe74c904b, 0x060836d8, 0x636f0d9e, 0xccc64054,\n    0xa9a17b12, 0x2f04f01d, 0x4a63cb5b, 0xe5ca8691, 0x80adbdd7,\n    0x61e91b44, 0x048e2002, 0xab276dc8, 0xce40568e, 0xb2df26af,\n    0xd7b81de9, 0x78115023, 0x1d766b65, 0xfc32cdf6, 0x9955f6b0,\n    0x36fcbb7a, 0x539b803c, 0xcfc25b38, 0xaaa5607e, 0x050c2db4,\n    0x606b16f2, 0x812fb061, 0xe4488b27, 0x4be1c6ed, 0x2e86fdab,\n    0x52198d8a, 0x377eb6cc, 0x98d7fb06, 0xfdb0c040, 0x1cf466d3,\n    0x79935d95, 0xd63a105f, 0xb35d2b19, 0x6bf1402c, 0x0e967b6a,\n    0xa13f36a0, 0xc4580de6, 0x251cab75, 0x407b9033, 0xefd2ddf9,\n    0x8ab5e6bf, 0xf62a969e, 0x934dadd8, 0x3ce4e012, 0x5983db54,\n    0xb8c77dc7, 0xdda04681, 0x72090b4b, 0x176e300d, 0x8b37eb09,\n    0xee50d04f, 0x41f99d85, 0x249ea6c3, 0xc5da0050, 0xa0bd3b16,\n    0x0f1476dc, 0x6a734d9a, 0x16ec3dbb, 0x738b06fd, 0xdc224b37,\n    0xb9457071, 0x5801d6e2, 0x3d66eda4, 0x92cfa06e, 0xf7a89b28,\n    0x710d1027, 0x146a2b61, 0xbbc366ab, 0xdea45ded, 0x3fe0fb7e,\n    0x5a87c038, 0xf52e8df2, 0x9049b6b4, 0xecd6c695, 0x89b1fdd3,\n    0x2618b019, 0x437f8b5f, 0xa23b2dcc, 0xc75c168a, 0x68f55b40,\n    0x0d926006, 0x91cbbb02, 0xf4ac8044, 0x5b05cd8e, 0x3e62f6c8,\n    0xdf26505b, 0xba416b1d, 0x15e826d7, 0x708f1d91, 0x0c106db0,\n    0x697756f6, 0xc6de1b3c, 0xa3b9207a, 0x42fd86e9, 0x279abdaf,\n    0x8833f065, 0xed54cb23, 0x5e09e03a, 0x3b6edb7c, 0x94c796b6,\n    0xf1a0adf0, 0x10e40b63, 0x75833025, 0xda2a7def, 0xbf4d46a9,\n    0xc3d23688, 0xa6b50dce, 0x091c4004, 0x6c7b7b42, 0x8d3fddd1,\n    0xe858e697, 0x47f1ab5d, 0x2296901b, 0xbecf4b1f, 0xdba87059,\n    0x74013d93, 0x116606d5, 0xf022a046, 0x95459b00, 0x3aecd6ca,\n    0x5f8bed8c, 0x23149dad, 0x4673a6eb, 0xe9daeb21, 0x8cbdd067,\n    0x6df976f4, 0x089e4db2, 0xa7370078, 0xc2503b3e, 0x44f5b031,\n    0x21928b77, 0x8e3bc6bd, 0xeb5cfdfb, 0x0a185b68, 0x6f7f602e,\n    0xc0d62de4, 0xa5b116a2, 0xd92e6683, 0xbc495dc5, 0x13e0100f,\n    0x76872b49, 0x97c38dda, 0xf2a4b69c, 0x5d0dfb56, 0x386ac010,\n    0xa4331b14, 0xc1542052, 0x6efd6d98, 0x0b9a56de, 0xeadef04d,\n    0x8fb9cb0b, 0x201086c1, 0x4577bd87, 0x39e8cda6, 0x5c8ff6e0,\n    0xf326bb2a, 0x9641806c, 0x770526ff, 0x12621db9, 0xbdcb5073,\n    0xd8ac6b35},\n   {0x00000000, 0xd7e28058, 0x74b406f1, 0xa35686a9, 0xe9680de2,\n    0x3e8a8dba, 0x9ddc0b13, 0x4a3e8b4b, 0x09a11d85, 0xde439ddd,\n    0x7d151b74, 0xaaf79b2c, 0xe0c91067, 0x372b903f, 0x947d1696,\n    0x439f96ce, 0x13423b0a, 0xc4a0bb52, 0x67f63dfb, 0xb014bda3,\n    0xfa2a36e8, 0x2dc8b6b0, 0x8e9e3019, 0x597cb041, 0x1ae3268f,\n    0xcd01a6d7, 0x6e57207e, 0xb9b5a026, 0xf38b2b6d, 0x2469ab35,\n    0x873f2d9c, 0x50ddadc4, 0x26847614, 0xf166f64c, 0x523070e5,\n    0x85d2f0bd, 0xcfec7bf6, 0x180efbae, 0xbb587d07, 0x6cbafd5f,\n    0x2f256b91, 0xf8c7ebc9, 0x5b916d60, 0x8c73ed38, 0xc64d6673,\n    0x11afe62b, 0xb2f96082, 0x651be0da, 0x35c64d1e, 0xe224cd46,\n    0x41724bef, 0x9690cbb7, 0xdcae40fc, 0x0b4cc0a4, 0xa81a460d,\n    0x7ff8c655, 0x3c67509b, 0xeb85d0c3, 0x48d3566a, 0x9f31d632,\n    0xd50f5d79, 0x02eddd21, 0xa1bb5b88, 0x7659dbd0, 0x4d08ec28,\n    0x9aea6c70, 0x39bcead9, 0xee5e6a81, 0xa460e1ca, 0x73826192,\n    0xd0d4e73b, 0x07366763, 0x44a9f1ad, 0x934b71f5, 0x301df75c,\n    0xe7ff7704, 0xadc1fc4f, 0x7a237c17, 0xd975fabe, 0x0e977ae6,\n    0x5e4ad722, 0x89a8577a, 0x2afed1d3, 0xfd1c518b, 0xb722dac0,\n    0x60c05a98, 0xc396dc31, 0x14745c69, 0x57ebcaa7, 0x80094aff,\n    0x235fcc56, 0xf4bd4c0e, 0xbe83c745, 0x6961471d, 0xca37c1b4,\n    0x1dd541ec, 0x6b8c9a3c, 0xbc6e1a64, 0x1f389ccd, 0xc8da1c95,\n    0x82e497de, 0x55061786, 0xf650912f, 0x21b21177, 0x622d87b9,\n    0xb5cf07e1, 0x16998148, 0xc17b0110, 0x8b458a5b, 0x5ca70a03,\n    0xfff18caa, 0x28130cf2, 0x78cea136, 0xaf2c216e, 0x0c7aa7c7,\n    0xdb98279f, 0x91a6acd4, 0x46442c8c, 0xe512aa25, 0x32f02a7d,\n    0x716fbcb3, 0xa68d3ceb, 0x05dbba42, 0xd2393a1a, 0x9807b151,\n    0x4fe53109, 0xecb3b7a0, 0x3b5137f8, 0x9a11d850, 0x4df35808,\n    0xeea5dea1, 0x39475ef9, 0x7379d5b2, 0xa49b55ea, 0x07cdd343,\n    0xd02f531b, 0x93b0c5d5, 0x4452458d, 0xe704c324, 0x30e6437c,\n    0x7ad8c837, 0xad3a486f, 0x0e6ccec6, 0xd98e4e9e, 0x8953e35a,\n    0x5eb16302, 0xfde7e5ab, 0x2a0565f3, 0x603beeb8, 0xb7d96ee0,\n    0x148fe849, 0xc36d6811, 0x80f2fedf, 0x57107e87, 0xf446f82e,\n    0x23a47876, 0x699af33d, 0xbe787365, 0x1d2ef5cc, 0xcacc7594,\n    0xbc95ae44, 0x6b772e1c, 0xc821a8b5, 0x1fc328ed, 0x55fda3a6,\n    0x821f23fe, 0x2149a557, 0xf6ab250f, 0xb534b3c1, 0x62d63399,\n    0xc180b530, 0x16623568, 0x5c5cbe23, 0x8bbe3e7b, 0x28e8b8d2,\n    0xff0a388a, 0xafd7954e, 0x78351516, 0xdb6393bf, 0x0c8113e7,\n    0x46bf98ac, 0x915d18f4, 0x320b9e5d, 0xe5e91e05, 0xa67688cb,\n    0x71940893, 0xd2c28e3a, 0x05200e62, 0x4f1e8529, 0x98fc0571,\n    0x3baa83d8, 0xec480380, 0xd7193478, 0x00fbb420, 0xa3ad3289,\n    0x744fb2d1, 0x3e71399a, 0xe993b9c2, 0x4ac53f6b, 0x9d27bf33,\n    0xdeb829fd, 0x095aa9a5, 0xaa0c2f0c, 0x7deeaf54, 0x37d0241f,\n    0xe032a447, 0x436422ee, 0x9486a2b6, 0xc45b0f72, 0x13b98f2a,\n    0xb0ef0983, 0x670d89db, 0x2d330290, 0xfad182c8, 0x59870461,\n    0x8e658439, 0xcdfa12f7, 0x1a1892af, 0xb94e1406, 0x6eac945e,\n    0x24921f15, 0xf3709f4d, 0x502619e4, 0x87c499bc, 0xf19d426c,\n    0x267fc234, 0x8529449d, 0x52cbc4c5, 0x18f54f8e, 0xcf17cfd6,\n    0x6c41497f, 0xbba3c927, 0xf83c5fe9, 0x2fdedfb1, 0x8c885918,\n    0x5b6ad940, 0x1154520b, 0xc6b6d253, 0x65e054fa, 0xb202d4a2,\n    0xe2df7966, 0x353df93e, 0x966b7f97, 0x4189ffcf, 0x0bb77484,\n    0xdc55f4dc, 0x7f037275, 0xa8e1f22d, 0xeb7e64e3, 0x3c9ce4bb,\n    0x9fca6212, 0x4828e24a, 0x02166901, 0xd5f4e959, 0x76a26ff0,\n    0xa140efa8},\n   {0x00000000, 0xef52b6e1, 0x05d46b83, 0xea86dd62, 0x0ba8d706,\n    0xe4fa61e7, 0x0e7cbc85, 0xe12e0a64, 0x1751ae0c, 0xf80318ed,\n    0x1285c58f, 0xfdd7736e, 0x1cf9790a, 0xf3abcfeb, 0x192d1289,\n    0xf67fa468, 0x2ea35c18, 0xc1f1eaf9, 0x2b77379b, 0xc425817a,\n    0x250b8b1e, 0xca593dff, 0x20dfe09d, 0xcf8d567c, 0x39f2f214,\n    0xd6a044f5, 0x3c269997, 0xd3742f76, 0x325a2512, 0xdd0893f3,\n    0x378e4e91, 0xd8dcf870, 0x5d46b830, 0xb2140ed1, 0x5892d3b3,\n    0xb7c06552, 0x56ee6f36, 0xb9bcd9d7, 0x533a04b5, 0xbc68b254,\n    0x4a17163c, 0xa545a0dd, 0x4fc37dbf, 0xa091cb5e, 0x41bfc13a,\n    0xaeed77db, 0x446baab9, 0xab391c58, 0x73e5e428, 0x9cb752c9,\n    0x76318fab, 0x9963394a, 0x784d332e, 0x971f85cf, 0x7d9958ad,\n    0x92cbee4c, 0x64b44a24, 0x8be6fcc5, 0x616021a7, 0x8e329746,\n    0x6f1c9d22, 0x804e2bc3, 0x6ac8f6a1, 0x859a4040, 0xba8d7060,\n    0x55dfc681, 0xbf591be3, 0x500bad02, 0xb125a766, 0x5e771187,\n    0xb4f1cce5, 0x5ba37a04, 0xaddcde6c, 0x428e688d, 0xa808b5ef,\n    0x475a030e, 0xa674096a, 0x4926bf8b, 0xa3a062e9, 0x4cf2d408,\n    0x942e2c78, 0x7b7c9a99, 0x91fa47fb, 0x7ea8f11a, 0x9f86fb7e,\n    0x70d44d9f, 0x9a5290fd, 0x7500261c, 0x837f8274, 0x6c2d3495,\n    0x86abe9f7, 0x69f95f16, 0x88d75572, 0x6785e393, 0x8d033ef1,\n    0x62518810, 0xe7cbc850, 0x08997eb1, 0xe21fa3d3, 0x0d4d1532,\n    0xec631f56, 0x0331a9b7, 0xe9b774d5, 0x06e5c234, 0xf09a665c,\n    0x1fc8d0bd, 0xf54e0ddf, 0x1a1cbb3e, 0xfb32b15a, 0x146007bb,\n    0xfee6dad9, 0x11b46c38, 0xc9689448, 0x263a22a9, 0xccbcffcb,\n    0x23ee492a, 0xc2c0434e, 0x2d92f5af, 0xc71428cd, 0x28469e2c,\n    0xde393a44, 0x316b8ca5, 0xdbed51c7, 0x34bfe726, 0xd591ed42,\n    0x3ac35ba3, 0xd04586c1, 0x3f173020, 0xae6be681, 0x41395060,\n    0xabbf8d02, 0x44ed3be3, 0xa5c33187, 0x4a918766, 0xa0175a04,\n    0x4f45ece5, 0xb93a488d, 0x5668fe6c, 0xbcee230e, 0x53bc95ef,\n    0xb2929f8b, 0x5dc0296a, 0xb746f408, 0x581442e9, 0x80c8ba99,\n    0x6f9a0c78, 0x851cd11a, 0x6a4e67fb, 0x8b606d9f, 0x6432db7e,\n    0x8eb4061c, 0x61e6b0fd, 0x97991495, 0x78cba274, 0x924d7f16,\n    0x7d1fc9f7, 0x9c31c393, 0x73637572, 0x99e5a810, 0x76b71ef1,\n    0xf32d5eb1, 0x1c7fe850, 0xf6f93532, 0x19ab83d3, 0xf88589b7,\n    0x17d73f56, 0xfd51e234, 0x120354d5, 0xe47cf0bd, 0x0b2e465c,\n    0xe1a89b3e, 0x0efa2ddf, 0xefd427bb, 0x0086915a, 0xea004c38,\n    0x0552fad9, 0xdd8e02a9, 0x32dcb448, 0xd85a692a, 0x3708dfcb,\n    0xd626d5af, 0x3974634e, 0xd3f2be2c, 0x3ca008cd, 0xcadfaca5,\n    0x258d1a44, 0xcf0bc726, 0x205971c7, 0xc1777ba3, 0x2e25cd42,\n    0xc4a31020, 0x2bf1a6c1, 0x14e696e1, 0xfbb42000, 0x1132fd62,\n    0xfe604b83, 0x1f4e41e7, 0xf01cf706, 0x1a9a2a64, 0xf5c89c85,\n    0x03b738ed, 0xece58e0c, 0x0663536e, 0xe931e58f, 0x081fefeb,\n    0xe74d590a, 0x0dcb8468, 0xe2993289, 0x3a45caf9, 0xd5177c18,\n    0x3f91a17a, 0xd0c3179b, 0x31ed1dff, 0xdebfab1e, 0x3439767c,\n    0xdb6bc09d, 0x2d1464f5, 0xc246d214, 0x28c00f76, 0xc792b997,\n    0x26bcb3f3, 0xc9ee0512, 0x2368d870, 0xcc3a6e91, 0x49a02ed1,\n    0xa6f29830, 0x4c744552, 0xa326f3b3, 0x4208f9d7, 0xad5a4f36,\n    0x47dc9254, 0xa88e24b5, 0x5ef180dd, 0xb1a3363c, 0x5b25eb5e,\n    0xb4775dbf, 0x555957db, 0xba0be13a, 0x508d3c58, 0xbfdf8ab9,\n    0x670372c9, 0x8851c428, 0x62d7194a, 0x8d85afab, 0x6caba5cf,\n    0x83f9132e, 0x697fce4c, 0x862d78ad, 0x7052dcc5, 0x9f006a24,\n    0x7586b746, 0x9ad401a7, 0x7bfa0bc3, 0x94a8bd22, 0x7e2e6040,\n    0x917cd6a1},\n   {0x00000000, 0x87a6cb43, 0xd43c90c7, 0x539a5b84, 0x730827cf,\n    0xf4aeec8c, 0xa734b708, 0x20927c4b, 0xe6104f9e, 0x61b684dd,\n    0x322cdf59, 0xb58a141a, 0x95186851, 0x12bea312, 0x4124f896,\n    0xc68233d5, 0x1751997d, 0x90f7523e, 0xc36d09ba, 0x44cbc2f9,\n    0x6459beb2, 0xe3ff75f1, 0xb0652e75, 0x37c3e536, 0xf141d6e3,\n    0x76e71da0, 0x257d4624, 0xa2db8d67, 0x8249f12c, 0x05ef3a6f,\n    0x567561eb, 0xd1d3aaa8, 0x2ea332fa, 0xa905f9b9, 0xfa9fa23d,\n    0x7d39697e, 0x5dab1535, 0xda0dde76, 0x899785f2, 0x0e314eb1,\n    0xc8b37d64, 0x4f15b627, 0x1c8feda3, 0x9b2926e0, 0xbbbb5aab,\n    0x3c1d91e8, 0x6f87ca6c, 0xe821012f, 0x39f2ab87, 0xbe5460c4,\n    0xedce3b40, 0x6a68f003, 0x4afa8c48, 0xcd5c470b, 0x9ec61c8f,\n    0x1960d7cc, 0xdfe2e419, 0x58442f5a, 0x0bde74de, 0x8c78bf9d,\n    0xaceac3d6, 0x2b4c0895, 0x78d65311, 0xff709852, 0x5d4665f4,\n    0xdae0aeb7, 0x897af533, 0x0edc3e70, 0x2e4e423b, 0xa9e88978,\n    0xfa72d2fc, 0x7dd419bf, 0xbb562a6a, 0x3cf0e129, 0x6f6abaad,\n    0xe8cc71ee, 0xc85e0da5, 0x4ff8c6e6, 0x1c629d62, 0x9bc45621,\n    0x4a17fc89, 0xcdb137ca, 0x9e2b6c4e, 0x198da70d, 0x391fdb46,\n    0xbeb91005, 0xed234b81, 0x6a8580c2, 0xac07b317, 0x2ba17854,\n    0x783b23d0, 0xff9de893, 0xdf0f94d8, 0x58a95f9b, 0x0b33041f,\n    0x8c95cf5c, 0x73e5570e, 0xf4439c4d, 0xa7d9c7c9, 0x207f0c8a,\n    0x00ed70c1, 0x874bbb82, 0xd4d1e006, 0x53772b45, 0x95f51890,\n    0x1253d3d3, 0x41c98857, 0xc66f4314, 0xe6fd3f5f, 0x615bf41c,\n    0x32c1af98, 0xb56764db, 0x64b4ce73, 0xe3120530, 0xb0885eb4,\n    0x372e95f7, 0x17bce9bc, 0x901a22ff, 0xc380797b, 0x4426b238,\n    0x82a481ed, 0x05024aae, 0x5698112a, 0xd13eda69, 0xf1aca622,\n    0x760a6d61, 0x259036e5, 0xa236fda6, 0xba8ccbe8, 0x3d2a00ab,\n    0x6eb05b2f, 0xe916906c, 0xc984ec27, 0x4e222764, 0x1db87ce0,\n    0x9a1eb7a3, 0x5c9c8476, 0xdb3a4f35, 0x88a014b1, 0x0f06dff2,\n    0x2f94a3b9, 0xa83268fa, 0xfba8337e, 0x7c0ef83d, 0xaddd5295,\n    0x2a7b99d6, 0x79e1c252, 0xfe470911, 0xded5755a, 0x5973be19,\n    0x0ae9e59d, 0x8d4f2ede, 0x4bcd1d0b, 0xcc6bd648, 0x9ff18dcc,\n    0x1857468f, 0x38c53ac4, 0xbf63f187, 0xecf9aa03, 0x6b5f6140,\n    0x942ff912, 0x13893251, 0x401369d5, 0xc7b5a296, 0xe727dedd,\n    0x6081159e, 0x331b4e1a, 0xb4bd8559, 0x723fb68c, 0xf5997dcf,\n    0xa603264b, 0x21a5ed08, 0x01379143, 0x86915a00, 0xd50b0184,\n    0x52adcac7, 0x837e606f, 0x04d8ab2c, 0x5742f0a8, 0xd0e43beb,\n    0xf07647a0, 0x77d08ce3, 0x244ad767, 0xa3ec1c24, 0x656e2ff1,\n    0xe2c8e4b2, 0xb152bf36, 0x36f47475, 0x1666083e, 0x91c0c37d,\n    0xc25a98f9, 0x45fc53ba, 0xe7caae1c, 0x606c655f, 0x33f63edb,\n    0xb450f598, 0x94c289d3, 0x13644290, 0x40fe1914, 0xc758d257,\n    0x01dae182, 0x867c2ac1, 0xd5e67145, 0x5240ba06, 0x72d2c64d,\n    0xf5740d0e, 0xa6ee568a, 0x21489dc9, 0xf09b3761, 0x773dfc22,\n    0x24a7a7a6, 0xa3016ce5, 0x839310ae, 0x0435dbed, 0x57af8069,\n    0xd0094b2a, 0x168b78ff, 0x912db3bc, 0xc2b7e838, 0x4511237b,\n    0x65835f30, 0xe2259473, 0xb1bfcff7, 0x361904b4, 0xc9699ce6,\n    0x4ecf57a5, 0x1d550c21, 0x9af3c762, 0xba61bb29, 0x3dc7706a,\n    0x6e5d2bee, 0xe9fbe0ad, 0x2f79d378, 0xa8df183b, 0xfb4543bf,\n    0x7ce388fc, 0x5c71f4b7, 0xdbd73ff4, 0x884d6470, 0x0febaf33,\n    0xde38059b, 0x599eced8, 0x0a04955c, 0x8da25e1f, 0xad302254,\n    0x2a96e917, 0x790cb293, 0xfeaa79d0, 0x38284a05, 0xbf8e8146,\n    0xec14dac2, 0x6bb21181, 0x4b206dca, 0xcc86a689, 0x9f1cfd0d,\n    0x18ba364e}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x43cba68700000000, 0xc7903cd400000000,\n    0x845b9a5300000000, 0xcf27087300000000, 0x8cecaef400000000,\n    0x08b734a700000000, 0x4b7c922000000000, 0x9e4f10e600000000,\n    0xdd84b66100000000, 0x59df2c3200000000, 0x1a148ab500000000,\n    0x5168189500000000, 0x12a3be1200000000, 0x96f8244100000000,\n    0xd53382c600000000, 0x7d99511700000000, 0x3e52f79000000000,\n    0xba096dc300000000, 0xf9c2cb4400000000, 0xb2be596400000000,\n    0xf175ffe300000000, 0x752e65b000000000, 0x36e5c33700000000,\n    0xe3d641f100000000, 0xa01de77600000000, 0x24467d2500000000,\n    0x678ddba200000000, 0x2cf1498200000000, 0x6f3aef0500000000,\n    0xeb61755600000000, 0xa8aad3d100000000, 0xfa32a32e00000000,\n    0xb9f905a900000000, 0x3da29ffa00000000, 0x7e69397d00000000,\n    0x3515ab5d00000000, 0x76de0dda00000000, 0xf285978900000000,\n    0xb14e310e00000000, 0x647db3c800000000, 0x27b6154f00000000,\n    0xa3ed8f1c00000000, 0xe026299b00000000, 0xab5abbbb00000000,\n    0xe8911d3c00000000, 0x6cca876f00000000, 0x2f0121e800000000,\n    0x87abf23900000000, 0xc46054be00000000, 0x403bceed00000000,\n    0x03f0686a00000000, 0x488cfa4a00000000, 0x0b475ccd00000000,\n    0x8f1cc69e00000000, 0xccd7601900000000, 0x19e4e2df00000000,\n    0x5a2f445800000000, 0xde74de0b00000000, 0x9dbf788c00000000,\n    0xd6c3eaac00000000, 0x95084c2b00000000, 0x1153d67800000000,\n    0x529870ff00000000, 0xf465465d00000000, 0xb7aee0da00000000,\n    0x33f57a8900000000, 0x703edc0e00000000, 0x3b424e2e00000000,\n    0x7889e8a900000000, 0xfcd272fa00000000, 0xbf19d47d00000000,\n    0x6a2a56bb00000000, 0x29e1f03c00000000, 0xadba6a6f00000000,\n    0xee71cce800000000, 0xa50d5ec800000000, 0xe6c6f84f00000000,\n    0x629d621c00000000, 0x2156c49b00000000, 0x89fc174a00000000,\n    0xca37b1cd00000000, 0x4e6c2b9e00000000, 0x0da78d1900000000,\n    0x46db1f3900000000, 0x0510b9be00000000, 0x814b23ed00000000,\n    0xc280856a00000000, 0x17b307ac00000000, 0x5478a12b00000000,\n    0xd0233b7800000000, 0x93e89dff00000000, 0xd8940fdf00000000,\n    0x9b5fa95800000000, 0x1f04330b00000000, 0x5ccf958c00000000,\n    0x0e57e57300000000, 0x4d9c43f400000000, 0xc9c7d9a700000000,\n    0x8a0c7f2000000000, 0xc170ed0000000000, 0x82bb4b8700000000,\n    0x06e0d1d400000000, 0x452b775300000000, 0x9018f59500000000,\n    0xd3d3531200000000, 0x5788c94100000000, 0x14436fc600000000,\n    0x5f3ffde600000000, 0x1cf45b6100000000, 0x98afc13200000000,\n    0xdb6467b500000000, 0x73ceb46400000000, 0x300512e300000000,\n    0xb45e88b000000000, 0xf7952e3700000000, 0xbce9bc1700000000,\n    0xff221a9000000000, 0x7b7980c300000000, 0x38b2264400000000,\n    0xed81a48200000000, 0xae4a020500000000, 0x2a11985600000000,\n    0x69da3ed100000000, 0x22a6acf100000000, 0x616d0a7600000000,\n    0xe536902500000000, 0xa6fd36a200000000, 0xe8cb8cba00000000,\n    0xab002a3d00000000, 0x2f5bb06e00000000, 0x6c9016e900000000,\n    0x27ec84c900000000, 0x6427224e00000000, 0xe07cb81d00000000,\n    0xa3b71e9a00000000, 0x76849c5c00000000, 0x354f3adb00000000,\n    0xb114a08800000000, 0xf2df060f00000000, 0xb9a3942f00000000,\n    0xfa6832a800000000, 0x7e33a8fb00000000, 0x3df80e7c00000000,\n    0x9552ddad00000000, 0xd6997b2a00000000, 0x52c2e17900000000,\n    0x110947fe00000000, 0x5a75d5de00000000, 0x19be735900000000,\n    0x9de5e90a00000000, 0xde2e4f8d00000000, 0x0b1dcd4b00000000,\n    0x48d66bcc00000000, 0xcc8df19f00000000, 0x8f46571800000000,\n    0xc43ac53800000000, 0x87f163bf00000000, 0x03aaf9ec00000000,\n    0x40615f6b00000000, 0x12f92f9400000000, 0x5132891300000000,\n    0xd569134000000000, 0x96a2b5c700000000, 0xddde27e700000000,\n    0x9e15816000000000, 0x1a4e1b3300000000, 0x5985bdb400000000,\n    0x8cb63f7200000000, 0xcf7d99f500000000, 0x4b2603a600000000,\n    0x08eda52100000000, 0x4391370100000000, 0x005a918600000000,\n    0x84010bd500000000, 0xc7caad5200000000, 0x6f607e8300000000,\n    0x2cabd80400000000, 0xa8f0425700000000, 0xeb3be4d000000000,\n    0xa04776f000000000, 0xe38cd07700000000, 0x67d74a2400000000,\n    0x241ceca300000000, 0xf12f6e6500000000, 0xb2e4c8e200000000,\n    0x36bf52b100000000, 0x7574f43600000000, 0x3e08661600000000,\n    0x7dc3c09100000000, 0xf9985ac200000000, 0xba53fc4500000000,\n    0x1caecae700000000, 0x5f656c6000000000, 0xdb3ef63300000000,\n    0x98f550b400000000, 0xd389c29400000000, 0x9042641300000000,\n    0x1419fe4000000000, 0x57d258c700000000, 0x82e1da0100000000,\n    0xc12a7c8600000000, 0x4571e6d500000000, 0x06ba405200000000,\n    0x4dc6d27200000000, 0x0e0d74f500000000, 0x8a56eea600000000,\n    0xc99d482100000000, 0x61379bf000000000, 0x22fc3d7700000000,\n    0xa6a7a72400000000, 0xe56c01a300000000, 0xae10938300000000,\n    0xeddb350400000000, 0x6980af5700000000, 0x2a4b09d000000000,\n    0xff788b1600000000, 0xbcb32d9100000000, 0x38e8b7c200000000,\n    0x7b23114500000000, 0x305f836500000000, 0x739425e200000000,\n    0xf7cfbfb100000000, 0xb404193600000000, 0xe69c69c900000000,\n    0xa557cf4e00000000, 0x210c551d00000000, 0x62c7f39a00000000,\n    0x29bb61ba00000000, 0x6a70c73d00000000, 0xee2b5d6e00000000,\n    0xade0fbe900000000, 0x78d3792f00000000, 0x3b18dfa800000000,\n    0xbf4345fb00000000, 0xfc88e37c00000000, 0xb7f4715c00000000,\n    0xf43fd7db00000000, 0x70644d8800000000, 0x33afeb0f00000000,\n    0x9b0538de00000000, 0xd8ce9e5900000000, 0x5c95040a00000000,\n    0x1f5ea28d00000000, 0x542230ad00000000, 0x17e9962a00000000,\n    0x93b20c7900000000, 0xd079aafe00000000, 0x054a283800000000,\n    0x46818ebf00000000, 0xc2da14ec00000000, 0x8111b26b00000000,\n    0xca6d204b00000000, 0x89a686cc00000000, 0x0dfd1c9f00000000,\n    0x4e36ba1800000000},\n   {0x0000000000000000, 0xe1b652ef00000000, 0x836bd40500000000,\n    0x62dd86ea00000000, 0x06d7a80b00000000, 0xe761fae400000000,\n    0x85bc7c0e00000000, 0x640a2ee100000000, 0x0cae511700000000,\n    0xed1803f800000000, 0x8fc5851200000000, 0x6e73d7fd00000000,\n    0x0a79f91c00000000, 0xebcfabf300000000, 0x89122d1900000000,\n    0x68a47ff600000000, 0x185ca32e00000000, 0xf9eaf1c100000000,\n    0x9b37772b00000000, 0x7a8125c400000000, 0x1e8b0b2500000000,\n    0xff3d59ca00000000, 0x9de0df2000000000, 0x7c568dcf00000000,\n    0x14f2f23900000000, 0xf544a0d600000000, 0x9799263c00000000,\n    0x762f74d300000000, 0x12255a3200000000, 0xf39308dd00000000,\n    0x914e8e3700000000, 0x70f8dcd800000000, 0x30b8465d00000000,\n    0xd10e14b200000000, 0xb3d3925800000000, 0x5265c0b700000000,\n    0x366fee5600000000, 0xd7d9bcb900000000, 0xb5043a5300000000,\n    0x54b268bc00000000, 0x3c16174a00000000, 0xdda045a500000000,\n    0xbf7dc34f00000000, 0x5ecb91a000000000, 0x3ac1bf4100000000,\n    0xdb77edae00000000, 0xb9aa6b4400000000, 0x581c39ab00000000,\n    0x28e4e57300000000, 0xc952b79c00000000, 0xab8f317600000000,\n    0x4a39639900000000, 0x2e334d7800000000, 0xcf851f9700000000,\n    0xad58997d00000000, 0x4ceecb9200000000, 0x244ab46400000000,\n    0xc5fce68b00000000, 0xa721606100000000, 0x4697328e00000000,\n    0x229d1c6f00000000, 0xc32b4e8000000000, 0xa1f6c86a00000000,\n    0x40409a8500000000, 0x60708dba00000000, 0x81c6df5500000000,\n    0xe31b59bf00000000, 0x02ad0b5000000000, 0x66a725b100000000,\n    0x8711775e00000000, 0xe5ccf1b400000000, 0x047aa35b00000000,\n    0x6cdedcad00000000, 0x8d688e4200000000, 0xefb508a800000000,\n    0x0e035a4700000000, 0x6a0974a600000000, 0x8bbf264900000000,\n    0xe962a0a300000000, 0x08d4f24c00000000, 0x782c2e9400000000,\n    0x999a7c7b00000000, 0xfb47fa9100000000, 0x1af1a87e00000000,\n    0x7efb869f00000000, 0x9f4dd47000000000, 0xfd90529a00000000,\n    0x1c26007500000000, 0x74827f8300000000, 0x95342d6c00000000,\n    0xf7e9ab8600000000, 0x165ff96900000000, 0x7255d78800000000,\n    0x93e3856700000000, 0xf13e038d00000000, 0x1088516200000000,\n    0x50c8cbe700000000, 0xb17e990800000000, 0xd3a31fe200000000,\n    0x32154d0d00000000, 0x561f63ec00000000, 0xb7a9310300000000,\n    0xd574b7e900000000, 0x34c2e50600000000, 0x5c669af000000000,\n    0xbdd0c81f00000000, 0xdf0d4ef500000000, 0x3ebb1c1a00000000,\n    0x5ab132fb00000000, 0xbb07601400000000, 0xd9dae6fe00000000,\n    0x386cb41100000000, 0x489468c900000000, 0xa9223a2600000000,\n    0xcbffbccc00000000, 0x2a49ee2300000000, 0x4e43c0c200000000,\n    0xaff5922d00000000, 0xcd2814c700000000, 0x2c9e462800000000,\n    0x443a39de00000000, 0xa58c6b3100000000, 0xc751eddb00000000,\n    0x26e7bf3400000000, 0x42ed91d500000000, 0xa35bc33a00000000,\n    0xc18645d000000000, 0x2030173f00000000, 0x81e66bae00000000,\n    0x6050394100000000, 0x028dbfab00000000, 0xe33bed4400000000,\n    0x8731c3a500000000, 0x6687914a00000000, 0x045a17a000000000,\n    0xe5ec454f00000000, 0x8d483ab900000000, 0x6cfe685600000000,\n    0x0e23eebc00000000, 0xef95bc5300000000, 0x8b9f92b200000000,\n    0x6a29c05d00000000, 0x08f446b700000000, 0xe942145800000000,\n    0x99bac88000000000, 0x780c9a6f00000000, 0x1ad11c8500000000,\n    0xfb674e6a00000000, 0x9f6d608b00000000, 0x7edb326400000000,\n    0x1c06b48e00000000, 0xfdb0e66100000000, 0x9514999700000000,\n    0x74a2cb7800000000, 0x167f4d9200000000, 0xf7c91f7d00000000,\n    0x93c3319c00000000, 0x7275637300000000, 0x10a8e59900000000,\n    0xf11eb77600000000, 0xb15e2df300000000, 0x50e87f1c00000000,\n    0x3235f9f600000000, 0xd383ab1900000000, 0xb78985f800000000,\n    0x563fd71700000000, 0x34e251fd00000000, 0xd554031200000000,\n    0xbdf07ce400000000, 0x5c462e0b00000000, 0x3e9ba8e100000000,\n    0xdf2dfa0e00000000, 0xbb27d4ef00000000, 0x5a91860000000000,\n    0x384c00ea00000000, 0xd9fa520500000000, 0xa9028edd00000000,\n    0x48b4dc3200000000, 0x2a695ad800000000, 0xcbdf083700000000,\n    0xafd526d600000000, 0x4e63743900000000, 0x2cbef2d300000000,\n    0xcd08a03c00000000, 0xa5acdfca00000000, 0x441a8d2500000000,\n    0x26c70bcf00000000, 0xc771592000000000, 0xa37b77c100000000,\n    0x42cd252e00000000, 0x2010a3c400000000, 0xc1a6f12b00000000,\n    0xe196e61400000000, 0x0020b4fb00000000, 0x62fd321100000000,\n    0x834b60fe00000000, 0xe7414e1f00000000, 0x06f71cf000000000,\n    0x642a9a1a00000000, 0x859cc8f500000000, 0xed38b70300000000,\n    0x0c8ee5ec00000000, 0x6e53630600000000, 0x8fe531e900000000,\n    0xebef1f0800000000, 0x0a594de700000000, 0x6884cb0d00000000,\n    0x893299e200000000, 0xf9ca453a00000000, 0x187c17d500000000,\n    0x7aa1913f00000000, 0x9b17c3d000000000, 0xff1ded3100000000,\n    0x1eabbfde00000000, 0x7c76393400000000, 0x9dc06bdb00000000,\n    0xf564142d00000000, 0x14d246c200000000, 0x760fc02800000000,\n    0x97b992c700000000, 0xf3b3bc2600000000, 0x1205eec900000000,\n    0x70d8682300000000, 0x916e3acc00000000, 0xd12ea04900000000,\n    0x3098f2a600000000, 0x5245744c00000000, 0xb3f326a300000000,\n    0xd7f9084200000000, 0x364f5aad00000000, 0x5492dc4700000000,\n    0xb5248ea800000000, 0xdd80f15e00000000, 0x3c36a3b100000000,\n    0x5eeb255b00000000, 0xbf5d77b400000000, 0xdb57595500000000,\n    0x3ae10bba00000000, 0x583c8d5000000000, 0xb98adfbf00000000,\n    0xc972036700000000, 0x28c4518800000000, 0x4a19d76200000000,\n    0xabaf858d00000000, 0xcfa5ab6c00000000, 0x2e13f98300000000,\n    0x4cce7f6900000000, 0xad782d8600000000, 0xc5dc527000000000,\n    0x246a009f00000000, 0x46b7867500000000, 0xa701d49a00000000,\n    0xc30bfa7b00000000, 0x22bda89400000000, 0x40602e7e00000000,\n    0xa1d67c9100000000},\n   {0x0000000000000000, 0x5880e2d700000000, 0xf106b47400000000,\n    0xa98656a300000000, 0xe20d68e900000000, 0xba8d8a3e00000000,\n    0x130bdc9d00000000, 0x4b8b3e4a00000000, 0x851da10900000000,\n    0xdd9d43de00000000, 0x741b157d00000000, 0x2c9bf7aa00000000,\n    0x6710c9e000000000, 0x3f902b3700000000, 0x96167d9400000000,\n    0xce969f4300000000, 0x0a3b421300000000, 0x52bba0c400000000,\n    0xfb3df66700000000, 0xa3bd14b000000000, 0xe8362afa00000000,\n    0xb0b6c82d00000000, 0x19309e8e00000000, 0x41b07c5900000000,\n    0x8f26e31a00000000, 0xd7a601cd00000000, 0x7e20576e00000000,\n    0x26a0b5b900000000, 0x6d2b8bf300000000, 0x35ab692400000000,\n    0x9c2d3f8700000000, 0xc4addd5000000000, 0x1476842600000000,\n    0x4cf666f100000000, 0xe570305200000000, 0xbdf0d28500000000,\n    0xf67beccf00000000, 0xaefb0e1800000000, 0x077d58bb00000000,\n    0x5ffdba6c00000000, 0x916b252f00000000, 0xc9ebc7f800000000,\n    0x606d915b00000000, 0x38ed738c00000000, 0x73664dc600000000,\n    0x2be6af1100000000, 0x8260f9b200000000, 0xdae01b6500000000,\n    0x1e4dc63500000000, 0x46cd24e200000000, 0xef4b724100000000,\n    0xb7cb909600000000, 0xfc40aedc00000000, 0xa4c04c0b00000000,\n    0x0d461aa800000000, 0x55c6f87f00000000, 0x9b50673c00000000,\n    0xc3d085eb00000000, 0x6a56d34800000000, 0x32d6319f00000000,\n    0x795d0fd500000000, 0x21dded0200000000, 0x885bbba100000000,\n    0xd0db597600000000, 0x28ec084d00000000, 0x706cea9a00000000,\n    0xd9eabc3900000000, 0x816a5eee00000000, 0xcae160a400000000,\n    0x9261827300000000, 0x3be7d4d000000000, 0x6367360700000000,\n    0xadf1a94400000000, 0xf5714b9300000000, 0x5cf71d3000000000,\n    0x0477ffe700000000, 0x4ffcc1ad00000000, 0x177c237a00000000,\n    0xbefa75d900000000, 0xe67a970e00000000, 0x22d74a5e00000000,\n    0x7a57a88900000000, 0xd3d1fe2a00000000, 0x8b511cfd00000000,\n    0xc0da22b700000000, 0x985ac06000000000, 0x31dc96c300000000,\n    0x695c741400000000, 0xa7caeb5700000000, 0xff4a098000000000,\n    0x56cc5f2300000000, 0x0e4cbdf400000000, 0x45c783be00000000,\n    0x1d47616900000000, 0xb4c137ca00000000, 0xec41d51d00000000,\n    0x3c9a8c6b00000000, 0x641a6ebc00000000, 0xcd9c381f00000000,\n    0x951cdac800000000, 0xde97e48200000000, 0x8617065500000000,\n    0x2f9150f600000000, 0x7711b22100000000, 0xb9872d6200000000,\n    0xe107cfb500000000, 0x4881991600000000, 0x10017bc100000000,\n    0x5b8a458b00000000, 0x030aa75c00000000, 0xaa8cf1ff00000000,\n    0xf20c132800000000, 0x36a1ce7800000000, 0x6e212caf00000000,\n    0xc7a77a0c00000000, 0x9f2798db00000000, 0xd4aca69100000000,\n    0x8c2c444600000000, 0x25aa12e500000000, 0x7d2af03200000000,\n    0xb3bc6f7100000000, 0xeb3c8da600000000, 0x42badb0500000000,\n    0x1a3a39d200000000, 0x51b1079800000000, 0x0931e54f00000000,\n    0xa0b7b3ec00000000, 0xf837513b00000000, 0x50d8119a00000000,\n    0x0858f34d00000000, 0xa1dea5ee00000000, 0xf95e473900000000,\n    0xb2d5797300000000, 0xea559ba400000000, 0x43d3cd0700000000,\n    0x1b532fd000000000, 0xd5c5b09300000000, 0x8d45524400000000,\n    0x24c304e700000000, 0x7c43e63000000000, 0x37c8d87a00000000,\n    0x6f483aad00000000, 0xc6ce6c0e00000000, 0x9e4e8ed900000000,\n    0x5ae3538900000000, 0x0263b15e00000000, 0xabe5e7fd00000000,\n    0xf365052a00000000, 0xb8ee3b6000000000, 0xe06ed9b700000000,\n    0x49e88f1400000000, 0x11686dc300000000, 0xdffef28000000000,\n    0x877e105700000000, 0x2ef846f400000000, 0x7678a42300000000,\n    0x3df39a6900000000, 0x657378be00000000, 0xccf52e1d00000000,\n    0x9475ccca00000000, 0x44ae95bc00000000, 0x1c2e776b00000000,\n    0xb5a821c800000000, 0xed28c31f00000000, 0xa6a3fd5500000000,\n    0xfe231f8200000000, 0x57a5492100000000, 0x0f25abf600000000,\n    0xc1b334b500000000, 0x9933d66200000000, 0x30b580c100000000,\n    0x6835621600000000, 0x23be5c5c00000000, 0x7b3ebe8b00000000,\n    0xd2b8e82800000000, 0x8a380aff00000000, 0x4e95d7af00000000,\n    0x1615357800000000, 0xbf9363db00000000, 0xe713810c00000000,\n    0xac98bf4600000000, 0xf4185d9100000000, 0x5d9e0b3200000000,\n    0x051ee9e500000000, 0xcb8876a600000000, 0x9308947100000000,\n    0x3a8ec2d200000000, 0x620e200500000000, 0x29851e4f00000000,\n    0x7105fc9800000000, 0xd883aa3b00000000, 0x800348ec00000000,\n    0x783419d700000000, 0x20b4fb0000000000, 0x8932ada300000000,\n    0xd1b24f7400000000, 0x9a39713e00000000, 0xc2b993e900000000,\n    0x6b3fc54a00000000, 0x33bf279d00000000, 0xfd29b8de00000000,\n    0xa5a95a0900000000, 0x0c2f0caa00000000, 0x54afee7d00000000,\n    0x1f24d03700000000, 0x47a432e000000000, 0xee22644300000000,\n    0xb6a2869400000000, 0x720f5bc400000000, 0x2a8fb91300000000,\n    0x8309efb000000000, 0xdb890d6700000000, 0x9002332d00000000,\n    0xc882d1fa00000000, 0x6104875900000000, 0x3984658e00000000,\n    0xf712facd00000000, 0xaf92181a00000000, 0x06144eb900000000,\n    0x5e94ac6e00000000, 0x151f922400000000, 0x4d9f70f300000000,\n    0xe419265000000000, 0xbc99c48700000000, 0x6c429df100000000,\n    0x34c27f2600000000, 0x9d44298500000000, 0xc5c4cb5200000000,\n    0x8e4ff51800000000, 0xd6cf17cf00000000, 0x7f49416c00000000,\n    0x27c9a3bb00000000, 0xe95f3cf800000000, 0xb1dfde2f00000000,\n    0x1859888c00000000, 0x40d96a5b00000000, 0x0b52541100000000,\n    0x53d2b6c600000000, 0xfa54e06500000000, 0xa2d402b200000000,\n    0x6679dfe200000000, 0x3ef93d3500000000, 0x977f6b9600000000,\n    0xcfff894100000000, 0x8474b70b00000000, 0xdcf455dc00000000,\n    0x7572037f00000000, 0x2df2e1a800000000, 0xe3647eeb00000000,\n    0xbbe49c3c00000000, 0x1262ca9f00000000, 0x4ae2284800000000,\n    0x0169160200000000, 0x59e9f4d500000000, 0xf06fa27600000000,\n    0xa8ef40a100000000},\n   {0x0000000000000000, 0x463b676500000000, 0x8c76ceca00000000,\n    0xca4da9af00000000, 0x59ebed4e00000000, 0x1fd08a2b00000000,\n    0xd59d238400000000, 0x93a644e100000000, 0xb2d6db9d00000000,\n    0xf4edbcf800000000, 0x3ea0155700000000, 0x789b723200000000,\n    0xeb3d36d300000000, 0xad0651b600000000, 0x674bf81900000000,\n    0x21709f7c00000000, 0x25abc6e000000000, 0x6390a18500000000,\n    0xa9dd082a00000000, 0xefe66f4f00000000, 0x7c402bae00000000,\n    0x3a7b4ccb00000000, 0xf036e56400000000, 0xb60d820100000000,\n    0x977d1d7d00000000, 0xd1467a1800000000, 0x1b0bd3b700000000,\n    0x5d30b4d200000000, 0xce96f03300000000, 0x88ad975600000000,\n    0x42e03ef900000000, 0x04db599c00000000, 0x0b50fc1a00000000,\n    0x4d6b9b7f00000000, 0x872632d000000000, 0xc11d55b500000000,\n    0x52bb115400000000, 0x1480763100000000, 0xdecddf9e00000000,\n    0x98f6b8fb00000000, 0xb986278700000000, 0xffbd40e200000000,\n    0x35f0e94d00000000, 0x73cb8e2800000000, 0xe06dcac900000000,\n    0xa656adac00000000, 0x6c1b040300000000, 0x2a20636600000000,\n    0x2efb3afa00000000, 0x68c05d9f00000000, 0xa28df43000000000,\n    0xe4b6935500000000, 0x7710d7b400000000, 0x312bb0d100000000,\n    0xfb66197e00000000, 0xbd5d7e1b00000000, 0x9c2de16700000000,\n    0xda16860200000000, 0x105b2fad00000000, 0x566048c800000000,\n    0xc5c60c2900000000, 0x83fd6b4c00000000, 0x49b0c2e300000000,\n    0x0f8ba58600000000, 0x16a0f83500000000, 0x509b9f5000000000,\n    0x9ad636ff00000000, 0xdced519a00000000, 0x4f4b157b00000000,\n    0x0970721e00000000, 0xc33ddbb100000000, 0x8506bcd400000000,\n    0xa47623a800000000, 0xe24d44cd00000000, 0x2800ed6200000000,\n    0x6e3b8a0700000000, 0xfd9dcee600000000, 0xbba6a98300000000,\n    0x71eb002c00000000, 0x37d0674900000000, 0x330b3ed500000000,\n    0x753059b000000000, 0xbf7df01f00000000, 0xf946977a00000000,\n    0x6ae0d39b00000000, 0x2cdbb4fe00000000, 0xe6961d5100000000,\n    0xa0ad7a3400000000, 0x81dde54800000000, 0xc7e6822d00000000,\n    0x0dab2b8200000000, 0x4b904ce700000000, 0xd836080600000000,\n    0x9e0d6f6300000000, 0x5440c6cc00000000, 0x127ba1a900000000,\n    0x1df0042f00000000, 0x5bcb634a00000000, 0x9186cae500000000,\n    0xd7bdad8000000000, 0x441be96100000000, 0x02208e0400000000,\n    0xc86d27ab00000000, 0x8e5640ce00000000, 0xaf26dfb200000000,\n    0xe91db8d700000000, 0x2350117800000000, 0x656b761d00000000,\n    0xf6cd32fc00000000, 0xb0f6559900000000, 0x7abbfc3600000000,\n    0x3c809b5300000000, 0x385bc2cf00000000, 0x7e60a5aa00000000,\n    0xb42d0c0500000000, 0xf2166b6000000000, 0x61b02f8100000000,\n    0x278b48e400000000, 0xedc6e14b00000000, 0xabfd862e00000000,\n    0x8a8d195200000000, 0xccb67e3700000000, 0x06fbd79800000000,\n    0x40c0b0fd00000000, 0xd366f41c00000000, 0x955d937900000000,\n    0x5f103ad600000000, 0x192b5db300000000, 0x2c40f16b00000000,\n    0x6a7b960e00000000, 0xa0363fa100000000, 0xe60d58c400000000,\n    0x75ab1c2500000000, 0x33907b4000000000, 0xf9ddd2ef00000000,\n    0xbfe6b58a00000000, 0x9e962af600000000, 0xd8ad4d9300000000,\n    0x12e0e43c00000000, 0x54db835900000000, 0xc77dc7b800000000,\n    0x8146a0dd00000000, 0x4b0b097200000000, 0x0d306e1700000000,\n    0x09eb378b00000000, 0x4fd050ee00000000, 0x859df94100000000,\n    0xc3a69e2400000000, 0x5000dac500000000, 0x163bbda000000000,\n    0xdc76140f00000000, 0x9a4d736a00000000, 0xbb3dec1600000000,\n    0xfd068b7300000000, 0x374b22dc00000000, 0x717045b900000000,\n    0xe2d6015800000000, 0xa4ed663d00000000, 0x6ea0cf9200000000,\n    0x289ba8f700000000, 0x27100d7100000000, 0x612b6a1400000000,\n    0xab66c3bb00000000, 0xed5da4de00000000, 0x7efbe03f00000000,\n    0x38c0875a00000000, 0xf28d2ef500000000, 0xb4b6499000000000,\n    0x95c6d6ec00000000, 0xd3fdb18900000000, 0x19b0182600000000,\n    0x5f8b7f4300000000, 0xcc2d3ba200000000, 0x8a165cc700000000,\n    0x405bf56800000000, 0x0660920d00000000, 0x02bbcb9100000000,\n    0x4480acf400000000, 0x8ecd055b00000000, 0xc8f6623e00000000,\n    0x5b5026df00000000, 0x1d6b41ba00000000, 0xd726e81500000000,\n    0x911d8f7000000000, 0xb06d100c00000000, 0xf656776900000000,\n    0x3c1bdec600000000, 0x7a20b9a300000000, 0xe986fd4200000000,\n    0xafbd9a2700000000, 0x65f0338800000000, 0x23cb54ed00000000,\n    0x3ae0095e00000000, 0x7cdb6e3b00000000, 0xb696c79400000000,\n    0xf0ada0f100000000, 0x630be41000000000, 0x2530837500000000,\n    0xef7d2ada00000000, 0xa9464dbf00000000, 0x8836d2c300000000,\n    0xce0db5a600000000, 0x04401c0900000000, 0x427b7b6c00000000,\n    0xd1dd3f8d00000000, 0x97e658e800000000, 0x5dabf14700000000,\n    0x1b90962200000000, 0x1f4bcfbe00000000, 0x5970a8db00000000,\n    0x933d017400000000, 0xd506661100000000, 0x46a022f000000000,\n    0x009b459500000000, 0xcad6ec3a00000000, 0x8ced8b5f00000000,\n    0xad9d142300000000, 0xeba6734600000000, 0x21ebdae900000000,\n    0x67d0bd8c00000000, 0xf476f96d00000000, 0xb24d9e0800000000,\n    0x780037a700000000, 0x3e3b50c200000000, 0x31b0f54400000000,\n    0x778b922100000000, 0xbdc63b8e00000000, 0xfbfd5ceb00000000,\n    0x685b180a00000000, 0x2e607f6f00000000, 0xe42dd6c000000000,\n    0xa216b1a500000000, 0x83662ed900000000, 0xc55d49bc00000000,\n    0x0f10e01300000000, 0x492b877600000000, 0xda8dc39700000000,\n    0x9cb6a4f200000000, 0x56fb0d5d00000000, 0x10c06a3800000000,\n    0x141b33a400000000, 0x522054c100000000, 0x986dfd6e00000000,\n    0xde569a0b00000000, 0x4df0deea00000000, 0x0bcbb98f00000000,\n    0xc186102000000000, 0x87bd774500000000, 0xa6cde83900000000,\n    0xe0f68f5c00000000, 0x2abb26f300000000, 0x6c80419600000000,\n    0xff26057700000000, 0xb91d621200000000, 0x7350cbbd00000000,\n    0x356bacd800000000},\n   {0x0000000000000000, 0x9e83da9f00000000, 0x7d01c4e400000000,\n    0xe3821e7b00000000, 0xbb04f91200000000, 0x2587238d00000000,\n    0xc6053df600000000, 0x5886e76900000000, 0x7609f22500000000,\n    0xe88a28ba00000000, 0x0b0836c100000000, 0x958bec5e00000000,\n    0xcd0d0b3700000000, 0x538ed1a800000000, 0xb00ccfd300000000,\n    0x2e8f154c00000000, 0xec12e44b00000000, 0x72913ed400000000,\n    0x911320af00000000, 0x0f90fa3000000000, 0x57161d5900000000,\n    0xc995c7c600000000, 0x2a17d9bd00000000, 0xb494032200000000,\n    0x9a1b166e00000000, 0x0498ccf100000000, 0xe71ad28a00000000,\n    0x7999081500000000, 0x211fef7c00000000, 0xbf9c35e300000000,\n    0x5c1e2b9800000000, 0xc29df10700000000, 0xd825c89700000000,\n    0x46a6120800000000, 0xa5240c7300000000, 0x3ba7d6ec00000000,\n    0x6321318500000000, 0xfda2eb1a00000000, 0x1e20f56100000000,\n    0x80a32ffe00000000, 0xae2c3ab200000000, 0x30afe02d00000000,\n    0xd32dfe5600000000, 0x4dae24c900000000, 0x1528c3a000000000,\n    0x8bab193f00000000, 0x6829074400000000, 0xf6aadddb00000000,\n    0x34372cdc00000000, 0xaab4f64300000000, 0x4936e83800000000,\n    0xd7b532a700000000, 0x8f33d5ce00000000, 0x11b00f5100000000,\n    0xf232112a00000000, 0x6cb1cbb500000000, 0x423edef900000000,\n    0xdcbd046600000000, 0x3f3f1a1d00000000, 0xa1bcc08200000000,\n    0xf93a27eb00000000, 0x67b9fd7400000000, 0x843be30f00000000,\n    0x1ab8399000000000, 0xf14de1f400000000, 0x6fce3b6b00000000,\n    0x8c4c251000000000, 0x12cfff8f00000000, 0x4a4918e600000000,\n    0xd4cac27900000000, 0x3748dc0200000000, 0xa9cb069d00000000,\n    0x874413d100000000, 0x19c7c94e00000000, 0xfa45d73500000000,\n    0x64c60daa00000000, 0x3c40eac300000000, 0xa2c3305c00000000,\n    0x41412e2700000000, 0xdfc2f4b800000000, 0x1d5f05bf00000000,\n    0x83dcdf2000000000, 0x605ec15b00000000, 0xfedd1bc400000000,\n    0xa65bfcad00000000, 0x38d8263200000000, 0xdb5a384900000000,\n    0x45d9e2d600000000, 0x6b56f79a00000000, 0xf5d52d0500000000,\n    0x1657337e00000000, 0x88d4e9e100000000, 0xd0520e8800000000,\n    0x4ed1d41700000000, 0xad53ca6c00000000, 0x33d010f300000000,\n    0x2968296300000000, 0xb7ebf3fc00000000, 0x5469ed8700000000,\n    0xcaea371800000000, 0x926cd07100000000, 0x0cef0aee00000000,\n    0xef6d149500000000, 0x71eece0a00000000, 0x5f61db4600000000,\n    0xc1e201d900000000, 0x22601fa200000000, 0xbce3c53d00000000,\n    0xe465225400000000, 0x7ae6f8cb00000000, 0x9964e6b000000000,\n    0x07e73c2f00000000, 0xc57acd2800000000, 0x5bf917b700000000,\n    0xb87b09cc00000000, 0x26f8d35300000000, 0x7e7e343a00000000,\n    0xe0fdeea500000000, 0x037ff0de00000000, 0x9dfc2a4100000000,\n    0xb3733f0d00000000, 0x2df0e59200000000, 0xce72fbe900000000,\n    0x50f1217600000000, 0x0877c61f00000000, 0x96f41c8000000000,\n    0x757602fb00000000, 0xebf5d86400000000, 0xa39db33200000000,\n    0x3d1e69ad00000000, 0xde9c77d600000000, 0x401fad4900000000,\n    0x18994a2000000000, 0x861a90bf00000000, 0x65988ec400000000,\n    0xfb1b545b00000000, 0xd594411700000000, 0x4b179b8800000000,\n    0xa89585f300000000, 0x36165f6c00000000, 0x6e90b80500000000,\n    0xf013629a00000000, 0x13917ce100000000, 0x8d12a67e00000000,\n    0x4f8f577900000000, 0xd10c8de600000000, 0x328e939d00000000,\n    0xac0d490200000000, 0xf48bae6b00000000, 0x6a0874f400000000,\n    0x898a6a8f00000000, 0x1709b01000000000, 0x3986a55c00000000,\n    0xa7057fc300000000, 0x448761b800000000, 0xda04bb2700000000,\n    0x82825c4e00000000, 0x1c0186d100000000, 0xff8398aa00000000,\n    0x6100423500000000, 0x7bb87ba500000000, 0xe53ba13a00000000,\n    0x06b9bf4100000000, 0x983a65de00000000, 0xc0bc82b700000000,\n    0x5e3f582800000000, 0xbdbd465300000000, 0x233e9ccc00000000,\n    0x0db1898000000000, 0x9332531f00000000, 0x70b04d6400000000,\n    0xee3397fb00000000, 0xb6b5709200000000, 0x2836aa0d00000000,\n    0xcbb4b47600000000, 0x55376ee900000000, 0x97aa9fee00000000,\n    0x0929457100000000, 0xeaab5b0a00000000, 0x7428819500000000,\n    0x2cae66fc00000000, 0xb22dbc6300000000, 0x51afa21800000000,\n    0xcf2c788700000000, 0xe1a36dcb00000000, 0x7f20b75400000000,\n    0x9ca2a92f00000000, 0x022173b000000000, 0x5aa794d900000000,\n    0xc4244e4600000000, 0x27a6503d00000000, 0xb9258aa200000000,\n    0x52d052c600000000, 0xcc53885900000000, 0x2fd1962200000000,\n    0xb1524cbd00000000, 0xe9d4abd400000000, 0x7757714b00000000,\n    0x94d56f3000000000, 0x0a56b5af00000000, 0x24d9a0e300000000,\n    0xba5a7a7c00000000, 0x59d8640700000000, 0xc75bbe9800000000,\n    0x9fdd59f100000000, 0x015e836e00000000, 0xe2dc9d1500000000,\n    0x7c5f478a00000000, 0xbec2b68d00000000, 0x20416c1200000000,\n    0xc3c3726900000000, 0x5d40a8f600000000, 0x05c64f9f00000000,\n    0x9b45950000000000, 0x78c78b7b00000000, 0xe64451e400000000,\n    0xc8cb44a800000000, 0x56489e3700000000, 0xb5ca804c00000000,\n    0x2b495ad300000000, 0x73cfbdba00000000, 0xed4c672500000000,\n    0x0ece795e00000000, 0x904da3c100000000, 0x8af59a5100000000,\n    0x147640ce00000000, 0xf7f45eb500000000, 0x6977842a00000000,\n    0x31f1634300000000, 0xaf72b9dc00000000, 0x4cf0a7a700000000,\n    0xd2737d3800000000, 0xfcfc687400000000, 0x627fb2eb00000000,\n    0x81fdac9000000000, 0x1f7e760f00000000, 0x47f8916600000000,\n    0xd97b4bf900000000, 0x3af9558200000000, 0xa47a8f1d00000000,\n    0x66e77e1a00000000, 0xf864a48500000000, 0x1be6bafe00000000,\n    0x8565606100000000, 0xdde3870800000000, 0x43605d9700000000,\n    0xa0e243ec00000000, 0x3e61997300000000, 0x10ee8c3f00000000,\n    0x8e6d56a000000000, 0x6def48db00000000, 0xf36c924400000000,\n    0xabea752d00000000, 0x3569afb200000000, 0xd6ebb1c900000000,\n    0x48686b5600000000},\n   {0x0000000000000000, 0xc064281700000000, 0x80c9502e00000000,\n    0x40ad783900000000, 0x0093a15c00000000, 0xc0f7894b00000000,\n    0x805af17200000000, 0x403ed96500000000, 0x002643b900000000,\n    0xc0426bae00000000, 0x80ef139700000000, 0x408b3b8000000000,\n    0x00b5e2e500000000, 0xc0d1caf200000000, 0x807cb2cb00000000,\n    0x40189adc00000000, 0x414af7a900000000, 0x812edfbe00000000,\n    0xc183a78700000000, 0x01e78f9000000000, 0x41d956f500000000,\n    0x81bd7ee200000000, 0xc11006db00000000, 0x01742ecc00000000,\n    0x416cb41000000000, 0x81089c0700000000, 0xc1a5e43e00000000,\n    0x01c1cc2900000000, 0x41ff154c00000000, 0x819b3d5b00000000,\n    0xc136456200000000, 0x01526d7500000000, 0xc3929f8800000000,\n    0x03f6b79f00000000, 0x435bcfa600000000, 0x833fe7b100000000,\n    0xc3013ed400000000, 0x036516c300000000, 0x43c86efa00000000,\n    0x83ac46ed00000000, 0xc3b4dc3100000000, 0x03d0f42600000000,\n    0x437d8c1f00000000, 0x8319a40800000000, 0xc3277d6d00000000,\n    0x0343557a00000000, 0x43ee2d4300000000, 0x838a055400000000,\n    0x82d8682100000000, 0x42bc403600000000, 0x0211380f00000000,\n    0xc275101800000000, 0x824bc97d00000000, 0x422fe16a00000000,\n    0x0282995300000000, 0xc2e6b14400000000, 0x82fe2b9800000000,\n    0x429a038f00000000, 0x02377bb600000000, 0xc25353a100000000,\n    0x826d8ac400000000, 0x4209a2d300000000, 0x02a4daea00000000,\n    0xc2c0f2fd00000000, 0xc7234eca00000000, 0x074766dd00000000,\n    0x47ea1ee400000000, 0x878e36f300000000, 0xc7b0ef9600000000,\n    0x07d4c78100000000, 0x4779bfb800000000, 0x871d97af00000000,\n    0xc7050d7300000000, 0x0761256400000000, 0x47cc5d5d00000000,\n    0x87a8754a00000000, 0xc796ac2f00000000, 0x07f2843800000000,\n    0x475ffc0100000000, 0x873bd41600000000, 0x8669b96300000000,\n    0x460d917400000000, 0x06a0e94d00000000, 0xc6c4c15a00000000,\n    0x86fa183f00000000, 0x469e302800000000, 0x0633481100000000,\n    0xc657600600000000, 0x864ffada00000000, 0x462bd2cd00000000,\n    0x0686aaf400000000, 0xc6e282e300000000, 0x86dc5b8600000000,\n    0x46b8739100000000, 0x06150ba800000000, 0xc67123bf00000000,\n    0x04b1d14200000000, 0xc4d5f95500000000, 0x8478816c00000000,\n    0x441ca97b00000000, 0x0422701e00000000, 0xc446580900000000,\n    0x84eb203000000000, 0x448f082700000000, 0x049792fb00000000,\n    0xc4f3baec00000000, 0x845ec2d500000000, 0x443aeac200000000,\n    0x040433a700000000, 0xc4601bb000000000, 0x84cd638900000000,\n    0x44a94b9e00000000, 0x45fb26eb00000000, 0x859f0efc00000000,\n    0xc53276c500000000, 0x05565ed200000000, 0x456887b700000000,\n    0x850cafa000000000, 0xc5a1d79900000000, 0x05c5ff8e00000000,\n    0x45dd655200000000, 0x85b94d4500000000, 0xc514357c00000000,\n    0x05701d6b00000000, 0x454ec40e00000000, 0x852aec1900000000,\n    0xc587942000000000, 0x05e3bc3700000000, 0xcf41ed4f00000000,\n    0x0f25c55800000000, 0x4f88bd6100000000, 0x8fec957600000000,\n    0xcfd24c1300000000, 0x0fb6640400000000, 0x4f1b1c3d00000000,\n    0x8f7f342a00000000, 0xcf67aef600000000, 0x0f0386e100000000,\n    0x4faefed800000000, 0x8fcad6cf00000000, 0xcff40faa00000000,\n    0x0f9027bd00000000, 0x4f3d5f8400000000, 0x8f59779300000000,\n    0x8e0b1ae600000000, 0x4e6f32f100000000, 0x0ec24ac800000000,\n    0xcea662df00000000, 0x8e98bbba00000000, 0x4efc93ad00000000,\n    0x0e51eb9400000000, 0xce35c38300000000, 0x8e2d595f00000000,\n    0x4e49714800000000, 0x0ee4097100000000, 0xce80216600000000,\n    0x8ebef80300000000, 0x4edad01400000000, 0x0e77a82d00000000,\n    0xce13803a00000000, 0x0cd372c700000000, 0xccb75ad000000000,\n    0x8c1a22e900000000, 0x4c7e0afe00000000, 0x0c40d39b00000000,\n    0xcc24fb8c00000000, 0x8c8983b500000000, 0x4cedaba200000000,\n    0x0cf5317e00000000, 0xcc91196900000000, 0x8c3c615000000000,\n    0x4c58494700000000, 0x0c66902200000000, 0xcc02b83500000000,\n    0x8cafc00c00000000, 0x4ccbe81b00000000, 0x4d99856e00000000,\n    0x8dfdad7900000000, 0xcd50d54000000000, 0x0d34fd5700000000,\n    0x4d0a243200000000, 0x8d6e0c2500000000, 0xcdc3741c00000000,\n    0x0da75c0b00000000, 0x4dbfc6d700000000, 0x8ddbeec000000000,\n    0xcd7696f900000000, 0x0d12beee00000000, 0x4d2c678b00000000,\n    0x8d484f9c00000000, 0xcde537a500000000, 0x0d811fb200000000,\n    0x0862a38500000000, 0xc8068b9200000000, 0x88abf3ab00000000,\n    0x48cfdbbc00000000, 0x08f102d900000000, 0xc8952ace00000000,\n    0x883852f700000000, 0x485c7ae000000000, 0x0844e03c00000000,\n    0xc820c82b00000000, 0x888db01200000000, 0x48e9980500000000,\n    0x08d7416000000000, 0xc8b3697700000000, 0x881e114e00000000,\n    0x487a395900000000, 0x4928542c00000000, 0x894c7c3b00000000,\n    0xc9e1040200000000, 0x09852c1500000000, 0x49bbf57000000000,\n    0x89dfdd6700000000, 0xc972a55e00000000, 0x09168d4900000000,\n    0x490e179500000000, 0x896a3f8200000000, 0xc9c747bb00000000,\n    0x09a36fac00000000, 0x499db6c900000000, 0x89f99ede00000000,\n    0xc954e6e700000000, 0x0930cef000000000, 0xcbf03c0d00000000,\n    0x0b94141a00000000, 0x4b396c2300000000, 0x8b5d443400000000,\n    0xcb639d5100000000, 0x0b07b54600000000, 0x4baacd7f00000000,\n    0x8bcee56800000000, 0xcbd67fb400000000, 0x0bb257a300000000,\n    0x4b1f2f9a00000000, 0x8b7b078d00000000, 0xcb45dee800000000,\n    0x0b21f6ff00000000, 0x4b8c8ec600000000, 0x8be8a6d100000000,\n    0x8abacba400000000, 0x4adee3b300000000, 0x0a739b8a00000000,\n    0xca17b39d00000000, 0x8a296af800000000, 0x4a4d42ef00000000,\n    0x0ae03ad600000000, 0xca8412c100000000, 0x8a9c881d00000000,\n    0x4af8a00a00000000, 0x0a55d83300000000, 0xca31f02400000000,\n    0x8a0f294100000000, 0x4a6b015600000000, 0x0ac6796f00000000,\n    0xcaa2517800000000},\n   {0x0000000000000000, 0xd4ea739b00000000, 0xe9d396ed00000000,\n    0x3d39e57600000000, 0x93a15c0000000000, 0x474b2f9b00000000,\n    0x7a72caed00000000, 0xae98b97600000000, 0x2643b90000000000,\n    0xf2a9ca9b00000000, 0xcf902fed00000000, 0x1b7a5c7600000000,\n    0xb5e2e50000000000, 0x6108969b00000000, 0x5c3173ed00000000,\n    0x88db007600000000, 0x4c86720100000000, 0x986c019a00000000,\n    0xa555e4ec00000000, 0x71bf977700000000, 0xdf272e0100000000,\n    0x0bcd5d9a00000000, 0x36f4b8ec00000000, 0xe21ecb7700000000,\n    0x6ac5cb0100000000, 0xbe2fb89a00000000, 0x83165dec00000000,\n    0x57fc2e7700000000, 0xf964970100000000, 0x2d8ee49a00000000,\n    0x10b701ec00000000, 0xc45d727700000000, 0x980ce50200000000,\n    0x4ce6969900000000, 0x71df73ef00000000, 0xa535007400000000,\n    0x0badb90200000000, 0xdf47ca9900000000, 0xe27e2fef00000000,\n    0x36945c7400000000, 0xbe4f5c0200000000, 0x6aa52f9900000000,\n    0x579ccaef00000000, 0x8376b97400000000, 0x2dee000200000000,\n    0xf904739900000000, 0xc43d96ef00000000, 0x10d7e57400000000,\n    0xd48a970300000000, 0x0060e49800000000, 0x3d5901ee00000000,\n    0xe9b3727500000000, 0x472bcb0300000000, 0x93c1b89800000000,\n    0xaef85dee00000000, 0x7a122e7500000000, 0xf2c92e0300000000,\n    0x26235d9800000000, 0x1b1ab8ee00000000, 0xcff0cb7500000000,\n    0x6168720300000000, 0xb582019800000000, 0x88bbe4ee00000000,\n    0x5c51977500000000, 0x3019ca0500000000, 0xe4f3b99e00000000,\n    0xd9ca5ce800000000, 0x0d202f7300000000, 0xa3b8960500000000,\n    0x7752e59e00000000, 0x4a6b00e800000000, 0x9e81737300000000,\n    0x165a730500000000, 0xc2b0009e00000000, 0xff89e5e800000000,\n    0x2b63967300000000, 0x85fb2f0500000000, 0x51115c9e00000000,\n    0x6c28b9e800000000, 0xb8c2ca7300000000, 0x7c9fb80400000000,\n    0xa875cb9f00000000, 0x954c2ee900000000, 0x41a65d7200000000,\n    0xef3ee40400000000, 0x3bd4979f00000000, 0x06ed72e900000000,\n    0xd207017200000000, 0x5adc010400000000, 0x8e36729f00000000,\n    0xb30f97e900000000, 0x67e5e47200000000, 0xc97d5d0400000000,\n    0x1d972e9f00000000, 0x20aecbe900000000, 0xf444b87200000000,\n    0xa8152f0700000000, 0x7cff5c9c00000000, 0x41c6b9ea00000000,\n    0x952cca7100000000, 0x3bb4730700000000, 0xef5e009c00000000,\n    0xd267e5ea00000000, 0x068d967100000000, 0x8e56960700000000,\n    0x5abce59c00000000, 0x678500ea00000000, 0xb36f737100000000,\n    0x1df7ca0700000000, 0xc91db99c00000000, 0xf4245cea00000000,\n    0x20ce2f7100000000, 0xe4935d0600000000, 0x30792e9d00000000,\n    0x0d40cbeb00000000, 0xd9aab87000000000, 0x7732010600000000,\n    0xa3d8729d00000000, 0x9ee197eb00000000, 0x4a0be47000000000,\n    0xc2d0e40600000000, 0x163a979d00000000, 0x2b0372eb00000000,\n    0xffe9017000000000, 0x5171b80600000000, 0x859bcb9d00000000,\n    0xb8a22eeb00000000, 0x6c485d7000000000, 0x6032940b00000000,\n    0xb4d8e79000000000, 0x89e102e600000000, 0x5d0b717d00000000,\n    0xf393c80b00000000, 0x2779bb9000000000, 0x1a405ee600000000,\n    0xceaa2d7d00000000, 0x46712d0b00000000, 0x929b5e9000000000,\n    0xafa2bbe600000000, 0x7b48c87d00000000, 0xd5d0710b00000000,\n    0x013a029000000000, 0x3c03e7e600000000, 0xe8e9947d00000000,\n    0x2cb4e60a00000000, 0xf85e959100000000, 0xc56770e700000000,\n    0x118d037c00000000, 0xbf15ba0a00000000, 0x6bffc99100000000,\n    0x56c62ce700000000, 0x822c5f7c00000000, 0x0af75f0a00000000,\n    0xde1d2c9100000000, 0xe324c9e700000000, 0x37ceba7c00000000,\n    0x9956030a00000000, 0x4dbc709100000000, 0x708595e700000000,\n    0xa46fe67c00000000, 0xf83e710900000000, 0x2cd4029200000000,\n    0x11ede7e400000000, 0xc507947f00000000, 0x6b9f2d0900000000,\n    0xbf755e9200000000, 0x824cbbe400000000, 0x56a6c87f00000000,\n    0xde7dc80900000000, 0x0a97bb9200000000, 0x37ae5ee400000000,\n    0xe3442d7f00000000, 0x4ddc940900000000, 0x9936e79200000000,\n    0xa40f02e400000000, 0x70e5717f00000000, 0xb4b8030800000000,\n    0x6052709300000000, 0x5d6b95e500000000, 0x8981e67e00000000,\n    0x27195f0800000000, 0xf3f32c9300000000, 0xcecac9e500000000,\n    0x1a20ba7e00000000, 0x92fbba0800000000, 0x4611c99300000000,\n    0x7b282ce500000000, 0xafc25f7e00000000, 0x015ae60800000000,\n    0xd5b0959300000000, 0xe88970e500000000, 0x3c63037e00000000,\n    0x502b5e0e00000000, 0x84c12d9500000000, 0xb9f8c8e300000000,\n    0x6d12bb7800000000, 0xc38a020e00000000, 0x1760719500000000,\n    0x2a5994e300000000, 0xfeb3e77800000000, 0x7668e70e00000000,\n    0xa282949500000000, 0x9fbb71e300000000, 0x4b51027800000000,\n    0xe5c9bb0e00000000, 0x3123c89500000000, 0x0c1a2de300000000,\n    0xd8f05e7800000000, 0x1cad2c0f00000000, 0xc8475f9400000000,\n    0xf57ebae200000000, 0x2194c97900000000, 0x8f0c700f00000000,\n    0x5be6039400000000, 0x66dfe6e200000000, 0xb235957900000000,\n    0x3aee950f00000000, 0xee04e69400000000, 0xd33d03e200000000,\n    0x07d7707900000000, 0xa94fc90f00000000, 0x7da5ba9400000000,\n    0x409c5fe200000000, 0x94762c7900000000, 0xc827bb0c00000000,\n    0x1ccdc89700000000, 0x21f42de100000000, 0xf51e5e7a00000000,\n    0x5b86e70c00000000, 0x8f6c949700000000, 0xb25571e100000000,\n    0x66bf027a00000000, 0xee64020c00000000, 0x3a8e719700000000,\n    0x07b794e100000000, 0xd35de77a00000000, 0x7dc55e0c00000000,\n    0xa92f2d9700000000, 0x9416c8e100000000, 0x40fcbb7a00000000,\n    0x84a1c90d00000000, 0x504bba9600000000, 0x6d725fe000000000,\n    0xb9982c7b00000000, 0x1700950d00000000, 0xc3eae69600000000,\n    0xfed303e000000000, 0x2a39707b00000000, 0xa2e2700d00000000,\n    0x7608039600000000, 0x4b31e6e000000000, 0x9fdb957b00000000,\n    0x31432c0d00000000, 0xe5a95f9600000000, 0xd890bae000000000,\n    0x0c7ac97b00000000},\n   {0x0000000000000000, 0x2765258100000000, 0x0fcc3bd900000000,\n    0x28a91e5800000000, 0x5f9e066900000000, 0x78fb23e800000000,\n    0x50523db000000000, 0x7737183100000000, 0xbe3c0dd200000000,\n    0x9959285300000000, 0xb1f0360b00000000, 0x9695138a00000000,\n    0xe1a20bbb00000000, 0xc6c72e3a00000000, 0xee6e306200000000,\n    0xc90b15e300000000, 0x3d7f6b7f00000000, 0x1a1a4efe00000000,\n    0x32b350a600000000, 0x15d6752700000000, 0x62e16d1600000000,\n    0x4584489700000000, 0x6d2d56cf00000000, 0x4a48734e00000000,\n    0x834366ad00000000, 0xa426432c00000000, 0x8c8f5d7400000000,\n    0xabea78f500000000, 0xdcdd60c400000000, 0xfbb8454500000000,\n    0xd3115b1d00000000, 0xf4747e9c00000000, 0x7afed6fe00000000,\n    0x5d9bf37f00000000, 0x7532ed2700000000, 0x5257c8a600000000,\n    0x2560d09700000000, 0x0205f51600000000, 0x2aaceb4e00000000,\n    0x0dc9cecf00000000, 0xc4c2db2c00000000, 0xe3a7fead00000000,\n    0xcb0ee0f500000000, 0xec6bc57400000000, 0x9b5cdd4500000000,\n    0xbc39f8c400000000, 0x9490e69c00000000, 0xb3f5c31d00000000,\n    0x4781bd8100000000, 0x60e4980000000000, 0x484d865800000000,\n    0x6f28a3d900000000, 0x181fbbe800000000, 0x3f7a9e6900000000,\n    0x17d3803100000000, 0x30b6a5b000000000, 0xf9bdb05300000000,\n    0xded895d200000000, 0xf6718b8a00000000, 0xd114ae0b00000000,\n    0xa623b63a00000000, 0x814693bb00000000, 0xa9ef8de300000000,\n    0x8e8aa86200000000, 0xb5fadc2600000000, 0x929ff9a700000000,\n    0xba36e7ff00000000, 0x9d53c27e00000000, 0xea64da4f00000000,\n    0xcd01ffce00000000, 0xe5a8e19600000000, 0xc2cdc41700000000,\n    0x0bc6d1f400000000, 0x2ca3f47500000000, 0x040aea2d00000000,\n    0x236fcfac00000000, 0x5458d79d00000000, 0x733df21c00000000,\n    0x5b94ec4400000000, 0x7cf1c9c500000000, 0x8885b75900000000,\n    0xafe092d800000000, 0x87498c8000000000, 0xa02ca90100000000,\n    0xd71bb13000000000, 0xf07e94b100000000, 0xd8d78ae900000000,\n    0xffb2af6800000000, 0x36b9ba8b00000000, 0x11dc9f0a00000000,\n    0x3975815200000000, 0x1e10a4d300000000, 0x6927bce200000000,\n    0x4e42996300000000, 0x66eb873b00000000, 0x418ea2ba00000000,\n    0xcf040ad800000000, 0xe8612f5900000000, 0xc0c8310100000000,\n    0xe7ad148000000000, 0x909a0cb100000000, 0xb7ff293000000000,\n    0x9f56376800000000, 0xb83312e900000000, 0x7138070a00000000,\n    0x565d228b00000000, 0x7ef43cd300000000, 0x5991195200000000,\n    0x2ea6016300000000, 0x09c324e200000000, 0x216a3aba00000000,\n    0x060f1f3b00000000, 0xf27b61a700000000, 0xd51e442600000000,\n    0xfdb75a7e00000000, 0xdad27fff00000000, 0xade567ce00000000,\n    0x8a80424f00000000, 0xa2295c1700000000, 0x854c799600000000,\n    0x4c476c7500000000, 0x6b2249f400000000, 0x438b57ac00000000,\n    0x64ee722d00000000, 0x13d96a1c00000000, 0x34bc4f9d00000000,\n    0x1c1551c500000000, 0x3b70744400000000, 0x6af5b94d00000000,\n    0x4d909ccc00000000, 0x6539829400000000, 0x425ca71500000000,\n    0x356bbf2400000000, 0x120e9aa500000000, 0x3aa784fd00000000,\n    0x1dc2a17c00000000, 0xd4c9b49f00000000, 0xf3ac911e00000000,\n    0xdb058f4600000000, 0xfc60aac700000000, 0x8b57b2f600000000,\n    0xac32977700000000, 0x849b892f00000000, 0xa3feacae00000000,\n    0x578ad23200000000, 0x70eff7b300000000, 0x5846e9eb00000000,\n    0x7f23cc6a00000000, 0x0814d45b00000000, 0x2f71f1da00000000,\n    0x07d8ef8200000000, 0x20bdca0300000000, 0xe9b6dfe000000000,\n    0xced3fa6100000000, 0xe67ae43900000000, 0xc11fc1b800000000,\n    0xb628d98900000000, 0x914dfc0800000000, 0xb9e4e25000000000,\n    0x9e81c7d100000000, 0x100b6fb300000000, 0x376e4a3200000000,\n    0x1fc7546a00000000, 0x38a271eb00000000, 0x4f9569da00000000,\n    0x68f04c5b00000000, 0x4059520300000000, 0x673c778200000000,\n    0xae37626100000000, 0x895247e000000000, 0xa1fb59b800000000,\n    0x869e7c3900000000, 0xf1a9640800000000, 0xd6cc418900000000,\n    0xfe655fd100000000, 0xd9007a5000000000, 0x2d7404cc00000000,\n    0x0a11214d00000000, 0x22b83f1500000000, 0x05dd1a9400000000,\n    0x72ea02a500000000, 0x558f272400000000, 0x7d26397c00000000,\n    0x5a431cfd00000000, 0x9348091e00000000, 0xb42d2c9f00000000,\n    0x9c8432c700000000, 0xbbe1174600000000, 0xccd60f7700000000,\n    0xebb32af600000000, 0xc31a34ae00000000, 0xe47f112f00000000,\n    0xdf0f656b00000000, 0xf86a40ea00000000, 0xd0c35eb200000000,\n    0xf7a67b3300000000, 0x8091630200000000, 0xa7f4468300000000,\n    0x8f5d58db00000000, 0xa8387d5a00000000, 0x613368b900000000,\n    0x46564d3800000000, 0x6eff536000000000, 0x499a76e100000000,\n    0x3ead6ed000000000, 0x19c84b5100000000, 0x3161550900000000,\n    0x1604708800000000, 0xe2700e1400000000, 0xc5152b9500000000,\n    0xedbc35cd00000000, 0xcad9104c00000000, 0xbdee087d00000000,\n    0x9a8b2dfc00000000, 0xb22233a400000000, 0x9547162500000000,\n    0x5c4c03c600000000, 0x7b29264700000000, 0x5380381f00000000,\n    0x74e51d9e00000000, 0x03d205af00000000, 0x24b7202e00000000,\n    0x0c1e3e7600000000, 0x2b7b1bf700000000, 0xa5f1b39500000000,\n    0x8294961400000000, 0xaa3d884c00000000, 0x8d58adcd00000000,\n    0xfa6fb5fc00000000, 0xdd0a907d00000000, 0xf5a38e2500000000,\n    0xd2c6aba400000000, 0x1bcdbe4700000000, 0x3ca89bc600000000,\n    0x1401859e00000000, 0x3364a01f00000000, 0x4453b82e00000000,\n    0x63369daf00000000, 0x4b9f83f700000000, 0x6cfaa67600000000,\n    0x988ed8ea00000000, 0xbfebfd6b00000000, 0x9742e33300000000,\n    0xb027c6b200000000, 0xc710de8300000000, 0xe075fb0200000000,\n    0xc8dce55a00000000, 0xefb9c0db00000000, 0x26b2d53800000000,\n    0x01d7f0b900000000, 0x297eeee100000000, 0x0e1bcb6000000000,\n    0x792cd35100000000, 0x5e49f6d000000000, 0x76e0e88800000000,\n    0x5185cd0900000000}};\n\n#else /* W == 4 */\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0x9ba54c6f, 0xec3b9e9f, 0x779ed2f0, 0x03063b7f,\n    0x98a37710, 0xef3da5e0, 0x7498e98f, 0x060c76fe, 0x9da93a91,\n    0xea37e861, 0x7192a40e, 0x050a4d81, 0x9eaf01ee, 0xe931d31e,\n    0x72949f71, 0x0c18edfc, 0x97bda193, 0xe0237363, 0x7b863f0c,\n    0x0f1ed683, 0x94bb9aec, 0xe325481c, 0x78800473, 0x0a149b02,\n    0x91b1d76d, 0xe62f059d, 0x7d8a49f2, 0x0912a07d, 0x92b7ec12,\n    0xe5293ee2, 0x7e8c728d, 0x1831dbf8, 0x83949797, 0xf40a4567,\n    0x6faf0908, 0x1b37e087, 0x8092ace8, 0xf70c7e18, 0x6ca93277,\n    0x1e3dad06, 0x8598e169, 0xf2063399, 0x69a37ff6, 0x1d3b9679,\n    0x869eda16, 0xf10008e6, 0x6aa54489, 0x14293604, 0x8f8c7a6b,\n    0xf812a89b, 0x63b7e4f4, 0x172f0d7b, 0x8c8a4114, 0xfb1493e4,\n    0x60b1df8b, 0x122540fa, 0x89800c95, 0xfe1ede65, 0x65bb920a,\n    0x11237b85, 0x8a8637ea, 0xfd18e51a, 0x66bda975, 0x3063b7f0,\n    0xabc6fb9f, 0xdc58296f, 0x47fd6500, 0x33658c8f, 0xa8c0c0e0,\n    0xdf5e1210, 0x44fb5e7f, 0x366fc10e, 0xadca8d61, 0xda545f91,\n    0x41f113fe, 0x3569fa71, 0xaeccb61e, 0xd95264ee, 0x42f72881,\n    0x3c7b5a0c, 0xa7de1663, 0xd040c493, 0x4be588fc, 0x3f7d6173,\n    0xa4d82d1c, 0xd346ffec, 0x48e3b383, 0x3a772cf2, 0xa1d2609d,\n    0xd64cb26d, 0x4de9fe02, 0x3971178d, 0xa2d45be2, 0xd54a8912,\n    0x4eefc57d, 0x28526c08, 0xb3f72067, 0xc469f297, 0x5fccbef8,\n    0x2b545777, 0xb0f11b18, 0xc76fc9e8, 0x5cca8587, 0x2e5e1af6,\n    0xb5fb5699, 0xc2658469, 0x59c0c806, 0x2d582189, 0xb6fd6de6,\n    0xc163bf16, 0x5ac6f379, 0x244a81f4, 0xbfefcd9b, 0xc8711f6b,\n    0x53d45304, 0x274cba8b, 0xbce9f6e4, 0xcb772414, 0x50d2687b,\n    0x2246f70a, 0xb9e3bb65, 0xce7d6995, 0x55d825fa, 0x2140cc75,\n    0xbae5801a, 0xcd7b52ea, 0x56de1e85, 0x60c76fe0, 0xfb62238f,\n    0x8cfcf17f, 0x1759bd10, 0x63c1549f, 0xf86418f0, 0x8ffaca00,\n    0x145f866f, 0x66cb191e, 0xfd6e5571, 0x8af08781, 0x1155cbee,\n    0x65cd2261, 0xfe686e0e, 0x89f6bcfe, 0x1253f091, 0x6cdf821c,\n    0xf77ace73, 0x80e41c83, 0x1b4150ec, 0x6fd9b963, 0xf47cf50c,\n    0x83e227fc, 0x18476b93, 0x6ad3f4e2, 0xf176b88d, 0x86e86a7d,\n    0x1d4d2612, 0x69d5cf9d, 0xf27083f2, 0x85ee5102, 0x1e4b1d6d,\n    0x78f6b418, 0xe353f877, 0x94cd2a87, 0x0f6866e8, 0x7bf08f67,\n    0xe055c308, 0x97cb11f8, 0x0c6e5d97, 0x7efac2e6, 0xe55f8e89,\n    0x92c15c79, 0x09641016, 0x7dfcf999, 0xe659b5f6, 0x91c76706,\n    0x0a622b69, 0x74ee59e4, 0xef4b158b, 0x98d5c77b, 0x03708b14,\n    0x77e8629b, 0xec4d2ef4, 0x9bd3fc04, 0x0076b06b, 0x72e22f1a,\n    0xe9476375, 0x9ed9b185, 0x057cfdea, 0x71e41465, 0xea41580a,\n    0x9ddf8afa, 0x067ac695, 0x50a4d810, 0xcb01947f, 0xbc9f468f,\n    0x273a0ae0, 0x53a2e36f, 0xc807af00, 0xbf997df0, 0x243c319f,\n    0x56a8aeee, 0xcd0de281, 0xba933071, 0x21367c1e, 0x55ae9591,\n    0xce0bd9fe, 0xb9950b0e, 0x22304761, 0x5cbc35ec, 0xc7197983,\n    0xb087ab73, 0x2b22e71c, 0x5fba0e93, 0xc41f42fc, 0xb381900c,\n    0x2824dc63, 0x5ab04312, 0xc1150f7d, 0xb68bdd8d, 0x2d2e91e2,\n    0x59b6786d, 0xc2133402, 0xb58de6f2, 0x2e28aa9d, 0x489503e8,\n    0xd3304f87, 0xa4ae9d77, 0x3f0bd118, 0x4b933897, 0xd03674f8,\n    0xa7a8a608, 0x3c0dea67, 0x4e997516, 0xd53c3979, 0xa2a2eb89,\n    0x3907a7e6, 0x4d9f4e69, 0xd63a0206, 0xa1a4d0f6, 0x3a019c99,\n    0x448dee14, 0xdf28a27b, 0xa8b6708b, 0x33133ce4, 0x478bd56b,\n    0xdc2e9904, 0xabb04bf4, 0x3015079b, 0x428198ea, 0xd924d485,\n    0xaeba0675, 0x351f4a1a, 0x4187a395, 0xda22effa, 0xadbc3d0a,\n    0x36197165},\n   {0x00000000, 0xc18edfc0, 0x586cb9c1, 0x99e26601, 0xb0d97382,\n    0x7157ac42, 0xe8b5ca43, 0x293b1583, 0xbac3e145, 0x7b4d3e85,\n    0xe2af5884, 0x23218744, 0x0a1a92c7, 0xcb944d07, 0x52762b06,\n    0x93f8f4c6, 0xaef6c4cb, 0x6f781b0b, 0xf69a7d0a, 0x3714a2ca,\n    0x1e2fb749, 0xdfa16889, 0x46430e88, 0x87cdd148, 0x1435258e,\n    0xd5bbfa4e, 0x4c599c4f, 0x8dd7438f, 0xa4ec560c, 0x656289cc,\n    0xfc80efcd, 0x3d0e300d, 0x869c8fd7, 0x47125017, 0xdef03616,\n    0x1f7ee9d6, 0x3645fc55, 0xf7cb2395, 0x6e294594, 0xafa79a54,\n    0x3c5f6e92, 0xfdd1b152, 0x6433d753, 0xa5bd0893, 0x8c861d10,\n    0x4d08c2d0, 0xd4eaa4d1, 0x15647b11, 0x286a4b1c, 0xe9e494dc,\n    0x7006f2dd, 0xb1882d1d, 0x98b3389e, 0x593de75e, 0xc0df815f,\n    0x01515e9f, 0x92a9aa59, 0x53277599, 0xcac51398, 0x0b4bcc58,\n    0x2270d9db, 0xe3fe061b, 0x7a1c601a, 0xbb92bfda, 0xd64819ef,\n    0x17c6c62f, 0x8e24a02e, 0x4faa7fee, 0x66916a6d, 0xa71fb5ad,\n    0x3efdd3ac, 0xff730c6c, 0x6c8bf8aa, 0xad05276a, 0x34e7416b,\n    0xf5699eab, 0xdc528b28, 0x1ddc54e8, 0x843e32e9, 0x45b0ed29,\n    0x78bedd24, 0xb93002e4, 0x20d264e5, 0xe15cbb25, 0xc867aea6,\n    0x09e97166, 0x900b1767, 0x5185c8a7, 0xc27d3c61, 0x03f3e3a1,\n    0x9a1185a0, 0x5b9f5a60, 0x72a44fe3, 0xb32a9023, 0x2ac8f622,\n    0xeb4629e2, 0x50d49638, 0x915a49f8, 0x08b82ff9, 0xc936f039,\n    0xe00de5ba, 0x21833a7a, 0xb8615c7b, 0x79ef83bb, 0xea17777d,\n    0x2b99a8bd, 0xb27bcebc, 0x73f5117c, 0x5ace04ff, 0x9b40db3f,\n    0x02a2bd3e, 0xc32c62fe, 0xfe2252f3, 0x3fac8d33, 0xa64eeb32,\n    0x67c034f2, 0x4efb2171, 0x8f75feb1, 0x169798b0, 0xd7194770,\n    0x44e1b3b6, 0x856f6c76, 0x1c8d0a77, 0xdd03d5b7, 0xf438c034,\n    0x35b61ff4, 0xac5479f5, 0x6ddaa635, 0x77e1359f, 0xb66fea5f,\n    0x2f8d8c5e, 0xee03539e, 0xc738461d, 0x06b699dd, 0x9f54ffdc,\n    0x5eda201c, 0xcd22d4da, 0x0cac0b1a, 0x954e6d1b, 0x54c0b2db,\n    0x7dfba758, 0xbc757898, 0x25971e99, 0xe419c159, 0xd917f154,\n    0x18992e94, 0x817b4895, 0x40f59755, 0x69ce82d6, 0xa8405d16,\n    0x31a23b17, 0xf02ce4d7, 0x63d41011, 0xa25acfd1, 0x3bb8a9d0,\n    0xfa367610, 0xd30d6393, 0x1283bc53, 0x8b61da52, 0x4aef0592,\n    0xf17dba48, 0x30f36588, 0xa9110389, 0x689fdc49, 0x41a4c9ca,\n    0x802a160a, 0x19c8700b, 0xd846afcb, 0x4bbe5b0d, 0x8a3084cd,\n    0x13d2e2cc, 0xd25c3d0c, 0xfb67288f, 0x3ae9f74f, 0xa30b914e,\n    0x62854e8e, 0x5f8b7e83, 0x9e05a143, 0x07e7c742, 0xc6691882,\n    0xef520d01, 0x2edcd2c1, 0xb73eb4c0, 0x76b06b00, 0xe5489fc6,\n    0x24c64006, 0xbd242607, 0x7caaf9c7, 0x5591ec44, 0x941f3384,\n    0x0dfd5585, 0xcc738a45, 0xa1a92c70, 0x6027f3b0, 0xf9c595b1,\n    0x384b4a71, 0x11705ff2, 0xd0fe8032, 0x491ce633, 0x889239f3,\n    0x1b6acd35, 0xdae412f5, 0x430674f4, 0x8288ab34, 0xabb3beb7,\n    0x6a3d6177, 0xf3df0776, 0x3251d8b6, 0x0f5fe8bb, 0xced1377b,\n    0x5733517a, 0x96bd8eba, 0xbf869b39, 0x7e0844f9, 0xe7ea22f8,\n    0x2664fd38, 0xb59c09fe, 0x7412d63e, 0xedf0b03f, 0x2c7e6fff,\n    0x05457a7c, 0xc4cba5bc, 0x5d29c3bd, 0x9ca71c7d, 0x2735a3a7,\n    0xe6bb7c67, 0x7f591a66, 0xbed7c5a6, 0x97ecd025, 0x56620fe5,\n    0xcf8069e4, 0x0e0eb624, 0x9df642e2, 0x5c789d22, 0xc59afb23,\n    0x041424e3, 0x2d2f3160, 0xeca1eea0, 0x754388a1, 0xb4cd5761,\n    0x89c3676c, 0x484db8ac, 0xd1afdead, 0x1021016d, 0x391a14ee,\n    0xf894cb2e, 0x6176ad2f, 0xa0f872ef, 0x33008629, 0xf28e59e9,\n    0x6b6c3fe8, 0xaae2e028, 0x83d9f5ab, 0x42572a6b, 0xdbb54c6a,\n    0x1a3b93aa},\n   {0x00000000, 0xefc26b3e, 0x04f5d03d, 0xeb37bb03, 0x09eba07a,\n    0xe629cb44, 0x0d1e7047, 0xe2dc1b79, 0x13d740f4, 0xfc152bca,\n    0x172290c9, 0xf8e0fbf7, 0x1a3ce08e, 0xf5fe8bb0, 0x1ec930b3,\n    0xf10b5b8d, 0x27ae81e8, 0xc86cead6, 0x235b51d5, 0xcc993aeb,\n    0x2e452192, 0xc1874aac, 0x2ab0f1af, 0xc5729a91, 0x3479c11c,\n    0xdbbbaa22, 0x308c1121, 0xdf4e7a1f, 0x3d926166, 0xd2500a58,\n    0x3967b15b, 0xd6a5da65, 0x4f5d03d0, 0xa09f68ee, 0x4ba8d3ed,\n    0xa46ab8d3, 0x46b6a3aa, 0xa974c894, 0x42437397, 0xad8118a9,\n    0x5c8a4324, 0xb348281a, 0x587f9319, 0xb7bdf827, 0x5561e35e,\n    0xbaa38860, 0x51943363, 0xbe56585d, 0x68f38238, 0x8731e906,\n    0x6c065205, 0x83c4393b, 0x61182242, 0x8eda497c, 0x65edf27f,\n    0x8a2f9941, 0x7b24c2cc, 0x94e6a9f2, 0x7fd112f1, 0x901379cf,\n    0x72cf62b6, 0x9d0d0988, 0x763ab28b, 0x99f8d9b5, 0x9eba07a0,\n    0x71786c9e, 0x9a4fd79d, 0x758dbca3, 0x9751a7da, 0x7893cce4,\n    0x93a477e7, 0x7c661cd9, 0x8d6d4754, 0x62af2c6a, 0x89989769,\n    0x665afc57, 0x8486e72e, 0x6b448c10, 0x80733713, 0x6fb15c2d,\n    0xb9148648, 0x56d6ed76, 0xbde15675, 0x52233d4b, 0xb0ff2632,\n    0x5f3d4d0c, 0xb40af60f, 0x5bc89d31, 0xaac3c6bc, 0x4501ad82,\n    0xae361681, 0x41f47dbf, 0xa32866c6, 0x4cea0df8, 0xa7ddb6fb,\n    0x481fddc5, 0xd1e70470, 0x3e256f4e, 0xd512d44d, 0x3ad0bf73,\n    0xd80ca40a, 0x37cecf34, 0xdcf97437, 0x333b1f09, 0xc2304484,\n    0x2df22fba, 0xc6c594b9, 0x2907ff87, 0xcbdbe4fe, 0x24198fc0,\n    0xcf2e34c3, 0x20ec5ffd, 0xf6498598, 0x198beea6, 0xf2bc55a5,\n    0x1d7e3e9b, 0xffa225e2, 0x10604edc, 0xfb57f5df, 0x14959ee1,\n    0xe59ec56c, 0x0a5cae52, 0xe16b1551, 0x0ea97e6f, 0xec756516,\n    0x03b70e28, 0xe880b52b, 0x0742de15, 0xe6050901, 0x09c7623f,\n    0xe2f0d93c, 0x0d32b202, 0xefeea97b, 0x002cc245, 0xeb1b7946,\n    0x04d91278, 0xf5d249f5, 0x1a1022cb, 0xf12799c8, 0x1ee5f2f6,\n    0xfc39e98f, 0x13fb82b1, 0xf8cc39b2, 0x170e528c, 0xc1ab88e9,\n    0x2e69e3d7, 0xc55e58d4, 0x2a9c33ea, 0xc8402893, 0x278243ad,\n    0xccb5f8ae, 0x23779390, 0xd27cc81d, 0x3dbea323, 0xd6891820,\n    0x394b731e, 0xdb976867, 0x34550359, 0xdf62b85a, 0x30a0d364,\n    0xa9580ad1, 0x469a61ef, 0xadaddaec, 0x426fb1d2, 0xa0b3aaab,\n    0x4f71c195, 0xa4467a96, 0x4b8411a8, 0xba8f4a25, 0x554d211b,\n    0xbe7a9a18, 0x51b8f126, 0xb364ea5f, 0x5ca68161, 0xb7913a62,\n    0x5853515c, 0x8ef68b39, 0x6134e007, 0x8a035b04, 0x65c1303a,\n    0x871d2b43, 0x68df407d, 0x83e8fb7e, 0x6c2a9040, 0x9d21cbcd,\n    0x72e3a0f3, 0x99d41bf0, 0x761670ce, 0x94ca6bb7, 0x7b080089,\n    0x903fbb8a, 0x7ffdd0b4, 0x78bf0ea1, 0x977d659f, 0x7c4ade9c,\n    0x9388b5a2, 0x7154aedb, 0x9e96c5e5, 0x75a17ee6, 0x9a6315d8,\n    0x6b684e55, 0x84aa256b, 0x6f9d9e68, 0x805ff556, 0x6283ee2f,\n    0x8d418511, 0x66763e12, 0x89b4552c, 0x5f118f49, 0xb0d3e477,\n    0x5be45f74, 0xb426344a, 0x56fa2f33, 0xb938440d, 0x520fff0e,\n    0xbdcd9430, 0x4cc6cfbd, 0xa304a483, 0x48331f80, 0xa7f174be,\n    0x452d6fc7, 0xaaef04f9, 0x41d8bffa, 0xae1ad4c4, 0x37e20d71,\n    0xd820664f, 0x3317dd4c, 0xdcd5b672, 0x3e09ad0b, 0xd1cbc635,\n    0x3afc7d36, 0xd53e1608, 0x24354d85, 0xcbf726bb, 0x20c09db8,\n    0xcf02f686, 0x2ddeedff, 0xc21c86c1, 0x292b3dc2, 0xc6e956fc,\n    0x104c8c99, 0xff8ee7a7, 0x14b95ca4, 0xfb7b379a, 0x19a72ce3,\n    0xf66547dd, 0x1d52fcde, 0xf29097e0, 0x039bcc6d, 0xec59a753,\n    0x076e1c50, 0xe8ac776e, 0x0a706c17, 0xe5b20729, 0x0e85bc2a,\n    0xe147d714},\n   {0x00000000, 0x177b1443, 0x2ef62886, 0x398d3cc5, 0x5dec510c,\n    0x4a97454f, 0x731a798a, 0x64616dc9, 0xbbd8a218, 0xaca3b65b,\n    0x952e8a9e, 0x82559edd, 0xe634f314, 0xf14fe757, 0xc8c2db92,\n    0xdfb9cfd1, 0xacc04271, 0xbbbb5632, 0x82366af7, 0x954d7eb4,\n    0xf12c137d, 0xe657073e, 0xdfda3bfb, 0xc8a12fb8, 0x1718e069,\n    0x0063f42a, 0x39eec8ef, 0x2e95dcac, 0x4af4b165, 0x5d8fa526,\n    0x640299e3, 0x73798da0, 0x82f182a3, 0x958a96e0, 0xac07aa25,\n    0xbb7cbe66, 0xdf1dd3af, 0xc866c7ec, 0xf1ebfb29, 0xe690ef6a,\n    0x392920bb, 0x2e5234f8, 0x17df083d, 0x00a41c7e, 0x64c571b7,\n    0x73be65f4, 0x4a335931, 0x5d484d72, 0x2e31c0d2, 0x394ad491,\n    0x00c7e854, 0x17bcfc17, 0x73dd91de, 0x64a6859d, 0x5d2bb958,\n    0x4a50ad1b, 0x95e962ca, 0x82927689, 0xbb1f4a4c, 0xac645e0f,\n    0xc80533c6, 0xdf7e2785, 0xe6f31b40, 0xf1880f03, 0xde920307,\n    0xc9e91744, 0xf0642b81, 0xe71f3fc2, 0x837e520b, 0x94054648,\n    0xad887a8d, 0xbaf36ece, 0x654aa11f, 0x7231b55c, 0x4bbc8999,\n    0x5cc79dda, 0x38a6f013, 0x2fdde450, 0x1650d895, 0x012bccd6,\n    0x72524176, 0x65295535, 0x5ca469f0, 0x4bdf7db3, 0x2fbe107a,\n    0x38c50439, 0x014838fc, 0x16332cbf, 0xc98ae36e, 0xdef1f72d,\n    0xe77ccbe8, 0xf007dfab, 0x9466b262, 0x831da621, 0xba909ae4,\n    0xadeb8ea7, 0x5c6381a4, 0x4b1895e7, 0x7295a922, 0x65eebd61,\n    0x018fd0a8, 0x16f4c4eb, 0x2f79f82e, 0x3802ec6d, 0xe7bb23bc,\n    0xf0c037ff, 0xc94d0b3a, 0xde361f79, 0xba5772b0, 0xad2c66f3,\n    0x94a15a36, 0x83da4e75, 0xf0a3c3d5, 0xe7d8d796, 0xde55eb53,\n    0xc92eff10, 0xad4f92d9, 0xba34869a, 0x83b9ba5f, 0x94c2ae1c,\n    0x4b7b61cd, 0x5c00758e, 0x658d494b, 0x72f65d08, 0x169730c1,\n    0x01ec2482, 0x38611847, 0x2f1a0c04, 0x6655004f, 0x712e140c,\n    0x48a328c9, 0x5fd83c8a, 0x3bb95143, 0x2cc24500, 0x154f79c5,\n    0x02346d86, 0xdd8da257, 0xcaf6b614, 0xf37b8ad1, 0xe4009e92,\n    0x8061f35b, 0x971ae718, 0xae97dbdd, 0xb9eccf9e, 0xca95423e,\n    0xddee567d, 0xe4636ab8, 0xf3187efb, 0x97791332, 0x80020771,\n    0xb98f3bb4, 0xaef42ff7, 0x714de026, 0x6636f465, 0x5fbbc8a0,\n    0x48c0dce3, 0x2ca1b12a, 0x3bdaa569, 0x025799ac, 0x152c8def,\n    0xe4a482ec, 0xf3df96af, 0xca52aa6a, 0xdd29be29, 0xb948d3e0,\n    0xae33c7a3, 0x97befb66, 0x80c5ef25, 0x5f7c20f4, 0x480734b7,\n    0x718a0872, 0x66f11c31, 0x029071f8, 0x15eb65bb, 0x2c66597e,\n    0x3b1d4d3d, 0x4864c09d, 0x5f1fd4de, 0x6692e81b, 0x71e9fc58,\n    0x15889191, 0x02f385d2, 0x3b7eb917, 0x2c05ad54, 0xf3bc6285,\n    0xe4c776c6, 0xdd4a4a03, 0xca315e40, 0xae503389, 0xb92b27ca,\n    0x80a61b0f, 0x97dd0f4c, 0xb8c70348, 0xafbc170b, 0x96312bce,\n    0x814a3f8d, 0xe52b5244, 0xf2504607, 0xcbdd7ac2, 0xdca66e81,\n    0x031fa150, 0x1464b513, 0x2de989d6, 0x3a929d95, 0x5ef3f05c,\n    0x4988e41f, 0x7005d8da, 0x677ecc99, 0x14074139, 0x037c557a,\n    0x3af169bf, 0x2d8a7dfc, 0x49eb1035, 0x5e900476, 0x671d38b3,\n    0x70662cf0, 0xafdfe321, 0xb8a4f762, 0x8129cba7, 0x9652dfe4,\n    0xf233b22d, 0xe548a66e, 0xdcc59aab, 0xcbbe8ee8, 0x3a3681eb,\n    0x2d4d95a8, 0x14c0a96d, 0x03bbbd2e, 0x67dad0e7, 0x70a1c4a4,\n    0x492cf861, 0x5e57ec22, 0x81ee23f3, 0x969537b0, 0xaf180b75,\n    0xb8631f36, 0xdc0272ff, 0xcb7966bc, 0xf2f45a79, 0xe58f4e3a,\n    0x96f6c39a, 0x818dd7d9, 0xb800eb1c, 0xaf7bff5f, 0xcb1a9296,\n    0xdc6186d5, 0xe5ecba10, 0xf297ae53, 0x2d2e6182, 0x3a5575c1,\n    0x03d84904, 0x14a35d47, 0x70c2308e, 0x67b924cd, 0x5e341808,\n    0x494f0c4b}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x00000000, 0x43147b17, 0x8628f62e, 0xc53c8d39, 0x0c51ec5d,\n    0x4f45974a, 0x8a791a73, 0xc96d6164, 0x18a2d8bb, 0x5bb6a3ac,\n    0x9e8a2e95, 0xdd9e5582, 0x14f334e6, 0x57e74ff1, 0x92dbc2c8,\n    0xd1cfb9df, 0x7142c0ac, 0x3256bbbb, 0xf76a3682, 0xb47e4d95,\n    0x7d132cf1, 0x3e0757e6, 0xfb3bdadf, 0xb82fa1c8, 0x69e01817,\n    0x2af46300, 0xefc8ee39, 0xacdc952e, 0x65b1f44a, 0x26a58f5d,\n    0xe3990264, 0xa08d7973, 0xa382f182, 0xe0968a95, 0x25aa07ac,\n    0x66be7cbb, 0xafd31ddf, 0xecc766c8, 0x29fbebf1, 0x6aef90e6,\n    0xbb202939, 0xf834522e, 0x3d08df17, 0x7e1ca400, 0xb771c564,\n    0xf465be73, 0x3159334a, 0x724d485d, 0xd2c0312e, 0x91d44a39,\n    0x54e8c700, 0x17fcbc17, 0xde91dd73, 0x9d85a664, 0x58b92b5d,\n    0x1bad504a, 0xca62e995, 0x89769282, 0x4c4a1fbb, 0x0f5e64ac,\n    0xc63305c8, 0x85277edf, 0x401bf3e6, 0x030f88f1, 0x070392de,\n    0x4417e9c9, 0x812b64f0, 0xc23f1fe7, 0x0b527e83, 0x48460594,\n    0x8d7a88ad, 0xce6ef3ba, 0x1fa14a65, 0x5cb53172, 0x9989bc4b,\n    0xda9dc75c, 0x13f0a638, 0x50e4dd2f, 0x95d85016, 0xd6cc2b01,\n    0x76415272, 0x35552965, 0xf069a45c, 0xb37ddf4b, 0x7a10be2f,\n    0x3904c538, 0xfc384801, 0xbf2c3316, 0x6ee38ac9, 0x2df7f1de,\n    0xe8cb7ce7, 0xabdf07f0, 0x62b26694, 0x21a61d83, 0xe49a90ba,\n    0xa78eebad, 0xa481635c, 0xe795184b, 0x22a99572, 0x61bdee65,\n    0xa8d08f01, 0xebc4f416, 0x2ef8792f, 0x6dec0238, 0xbc23bbe7,\n    0xff37c0f0, 0x3a0b4dc9, 0x791f36de, 0xb07257ba, 0xf3662cad,\n    0x365aa194, 0x754eda83, 0xd5c3a3f0, 0x96d7d8e7, 0x53eb55de,\n    0x10ff2ec9, 0xd9924fad, 0x9a8634ba, 0x5fbab983, 0x1caec294,\n    0xcd617b4b, 0x8e75005c, 0x4b498d65, 0x085df672, 0xc1309716,\n    0x8224ec01, 0x47186138, 0x040c1a2f, 0x4f005566, 0x0c142e71,\n    0xc928a348, 0x8a3cd85f, 0x4351b93b, 0x0045c22c, 0xc5794f15,\n    0x866d3402, 0x57a28ddd, 0x14b6f6ca, 0xd18a7bf3, 0x929e00e4,\n    0x5bf36180, 0x18e71a97, 0xdddb97ae, 0x9ecfecb9, 0x3e4295ca,\n    0x7d56eedd, 0xb86a63e4, 0xfb7e18f3, 0x32137997, 0x71070280,\n    0xb43b8fb9, 0xf72ff4ae, 0x26e04d71, 0x65f43666, 0xa0c8bb5f,\n    0xe3dcc048, 0x2ab1a12c, 0x69a5da3b, 0xac995702, 0xef8d2c15,\n    0xec82a4e4, 0xaf96dff3, 0x6aaa52ca, 0x29be29dd, 0xe0d348b9,\n    0xa3c733ae, 0x66fbbe97, 0x25efc580, 0xf4207c5f, 0xb7340748,\n    0x72088a71, 0x311cf166, 0xf8719002, 0xbb65eb15, 0x7e59662c,\n    0x3d4d1d3b, 0x9dc06448, 0xded41f5f, 0x1be89266, 0x58fce971,\n    0x91918815, 0xd285f302, 0x17b97e3b, 0x54ad052c, 0x8562bcf3,\n    0xc676c7e4, 0x034a4add, 0x405e31ca, 0x893350ae, 0xca272bb9,\n    0x0f1ba680, 0x4c0fdd97, 0x4803c7b8, 0x0b17bcaf, 0xce2b3196,\n    0x8d3f4a81, 0x44522be5, 0x074650f2, 0xc27addcb, 0x816ea6dc,\n    0x50a11f03, 0x13b56414, 0xd689e92d, 0x959d923a, 0x5cf0f35e,\n    0x1fe48849, 0xdad80570, 0x99cc7e67, 0x39410714, 0x7a557c03,\n    0xbf69f13a, 0xfc7d8a2d, 0x3510eb49, 0x7604905e, 0xb3381d67,\n    0xf02c6670, 0x21e3dfaf, 0x62f7a4b8, 0xa7cb2981, 0xe4df5296,\n    0x2db233f2, 0x6ea648e5, 0xab9ac5dc, 0xe88ebecb, 0xeb81363a,\n    0xa8954d2d, 0x6da9c014, 0x2ebdbb03, 0xe7d0da67, 0xa4c4a170,\n    0x61f82c49, 0x22ec575e, 0xf323ee81, 0xb0379596, 0x750b18af,\n    0x361f63b8, 0xff7202dc, 0xbc6679cb, 0x795af4f2, 0x3a4e8fe5,\n    0x9ac3f696, 0xd9d78d81, 0x1ceb00b8, 0x5fff7baf, 0x96921acb,\n    0xd58661dc, 0x10baece5, 0x53ae97f2, 0x82612e2d, 0xc175553a,\n    0x0449d803, 0x475da314, 0x8e30c270, 0xcd24b967, 0x0818345e,\n    0x4b0c4f49},\n   {0x00000000, 0x3e6bc2ef, 0x3dd0f504, 0x03bb37eb, 0x7aa0eb09,\n    0x44cb29e6, 0x47701e0d, 0x791bdce2, 0xf440d713, 0xca2b15fc,\n    0xc9902217, 0xf7fbe0f8, 0x8ee03c1a, 0xb08bfef5, 0xb330c91e,\n    0x8d5b0bf1, 0xe881ae27, 0xd6ea6cc8, 0xd5515b23, 0xeb3a99cc,\n    0x9221452e, 0xac4a87c1, 0xaff1b02a, 0x919a72c5, 0x1cc17934,\n    0x22aabbdb, 0x21118c30, 0x1f7a4edf, 0x6661923d, 0x580a50d2,\n    0x5bb16739, 0x65daa5d6, 0xd0035d4f, 0xee689fa0, 0xedd3a84b,\n    0xd3b86aa4, 0xaaa3b646, 0x94c874a9, 0x97734342, 0xa91881ad,\n    0x24438a5c, 0x1a2848b3, 0x19937f58, 0x27f8bdb7, 0x5ee36155,\n    0x6088a3ba, 0x63339451, 0x5d5856be, 0x3882f368, 0x06e93187,\n    0x0552066c, 0x3b39c483, 0x42221861, 0x7c49da8e, 0x7ff2ed65,\n    0x41992f8a, 0xccc2247b, 0xf2a9e694, 0xf112d17f, 0xcf791390,\n    0xb662cf72, 0x88090d9d, 0x8bb23a76, 0xb5d9f899, 0xa007ba9e,\n    0x9e6c7871, 0x9dd74f9a, 0xa3bc8d75, 0xdaa75197, 0xe4cc9378,\n    0xe777a493, 0xd91c667c, 0x54476d8d, 0x6a2caf62, 0x69979889,\n    0x57fc5a66, 0x2ee78684, 0x108c446b, 0x13377380, 0x2d5cb16f,\n    0x488614b9, 0x76edd656, 0x7556e1bd, 0x4b3d2352, 0x3226ffb0,\n    0x0c4d3d5f, 0x0ff60ab4, 0x319dc85b, 0xbcc6c3aa, 0x82ad0145,\n    0x811636ae, 0xbf7df441, 0xc66628a3, 0xf80dea4c, 0xfbb6dda7,\n    0xc5dd1f48, 0x7004e7d1, 0x4e6f253e, 0x4dd412d5, 0x73bfd03a,\n    0x0aa40cd8, 0x34cfce37, 0x3774f9dc, 0x091f3b33, 0x844430c2,\n    0xba2ff22d, 0xb994c5c6, 0x87ff0729, 0xfee4dbcb, 0xc08f1924,\n    0xc3342ecf, 0xfd5fec20, 0x988549f6, 0xa6ee8b19, 0xa555bcf2,\n    0x9b3e7e1d, 0xe225a2ff, 0xdc4e6010, 0xdff557fb, 0xe19e9514,\n    0x6cc59ee5, 0x52ae5c0a, 0x51156be1, 0x6f7ea90e, 0x166575ec,\n    0x280eb703, 0x2bb580e8, 0x15de4207, 0x010905e6, 0x3f62c709,\n    0x3cd9f0e2, 0x02b2320d, 0x7ba9eeef, 0x45c22c00, 0x46791beb,\n    0x7812d904, 0xf549d2f5, 0xcb22101a, 0xc89927f1, 0xf6f2e51e,\n    0x8fe939fc, 0xb182fb13, 0xb239ccf8, 0x8c520e17, 0xe988abc1,\n    0xd7e3692e, 0xd4585ec5, 0xea339c2a, 0x932840c8, 0xad438227,\n    0xaef8b5cc, 0x90937723, 0x1dc87cd2, 0x23a3be3d, 0x201889d6,\n    0x1e734b39, 0x676897db, 0x59035534, 0x5ab862df, 0x64d3a030,\n    0xd10a58a9, 0xef619a46, 0xecdaadad, 0xd2b16f42, 0xabaab3a0,\n    0x95c1714f, 0x967a46a4, 0xa811844b, 0x254a8fba, 0x1b214d55,\n    0x189a7abe, 0x26f1b851, 0x5fea64b3, 0x6181a65c, 0x623a91b7,\n    0x5c515358, 0x398bf68e, 0x07e03461, 0x045b038a, 0x3a30c165,\n    0x432b1d87, 0x7d40df68, 0x7efbe883, 0x40902a6c, 0xcdcb219d,\n    0xf3a0e372, 0xf01bd499, 0xce701676, 0xb76bca94, 0x8900087b,\n    0x8abb3f90, 0xb4d0fd7f, 0xa10ebf78, 0x9f657d97, 0x9cde4a7c,\n    0xa2b58893, 0xdbae5471, 0xe5c5969e, 0xe67ea175, 0xd815639a,\n    0x554e686b, 0x6b25aa84, 0x689e9d6f, 0x56f55f80, 0x2fee8362,\n    0x1185418d, 0x123e7666, 0x2c55b489, 0x498f115f, 0x77e4d3b0,\n    0x745fe45b, 0x4a3426b4, 0x332ffa56, 0x0d4438b9, 0x0eff0f52,\n    0x3094cdbd, 0xbdcfc64c, 0x83a404a3, 0x801f3348, 0xbe74f1a7,\n    0xc76f2d45, 0xf904efaa, 0xfabfd841, 0xc4d41aae, 0x710de237,\n    0x4f6620d8, 0x4cdd1733, 0x72b6d5dc, 0x0bad093e, 0x35c6cbd1,\n    0x367dfc3a, 0x08163ed5, 0x854d3524, 0xbb26f7cb, 0xb89dc020,\n    0x86f602cf, 0xffedde2d, 0xc1861cc2, 0xc23d2b29, 0xfc56e9c6,\n    0x998c4c10, 0xa7e78eff, 0xa45cb914, 0x9a377bfb, 0xe32ca719,\n    0xdd4765f6, 0xdefc521d, 0xe09790f2, 0x6dcc9b03, 0x53a759ec,\n    0x501c6e07, 0x6e77ace8, 0x176c700a, 0x2907b2e5, 0x2abc850e,\n    0x14d747e1},\n   {0x00000000, 0xc0df8ec1, 0xc1b96c58, 0x0166e299, 0x8273d9b0,\n    0x42ac5771, 0x43cab5e8, 0x83153b29, 0x45e1c3ba, 0x853e4d7b,\n    0x8458afe2, 0x44872123, 0xc7921a0a, 0x074d94cb, 0x062b7652,\n    0xc6f4f893, 0xcbc4f6ae, 0x0b1b786f, 0x0a7d9af6, 0xcaa21437,\n    0x49b72f1e, 0x8968a1df, 0x880e4346, 0x48d1cd87, 0x8e253514,\n    0x4efabbd5, 0x4f9c594c, 0x8f43d78d, 0x0c56eca4, 0xcc896265,\n    0xcdef80fc, 0x0d300e3d, 0xd78f9c86, 0x17501247, 0x1636f0de,\n    0xd6e97e1f, 0x55fc4536, 0x9523cbf7, 0x9445296e, 0x549aa7af,\n    0x926e5f3c, 0x52b1d1fd, 0x53d73364, 0x9308bda5, 0x101d868c,\n    0xd0c2084d, 0xd1a4ead4, 0x117b6415, 0x1c4b6a28, 0xdc94e4e9,\n    0xddf20670, 0x1d2d88b1, 0x9e38b398, 0x5ee73d59, 0x5f81dfc0,\n    0x9f5e5101, 0x59aaa992, 0x99752753, 0x9813c5ca, 0x58cc4b0b,\n    0xdbd97022, 0x1b06fee3, 0x1a601c7a, 0xdabf92bb, 0xef1948d6,\n    0x2fc6c617, 0x2ea0248e, 0xee7faa4f, 0x6d6a9166, 0xadb51fa7,\n    0xacd3fd3e, 0x6c0c73ff, 0xaaf88b6c, 0x6a2705ad, 0x6b41e734,\n    0xab9e69f5, 0x288b52dc, 0xe854dc1d, 0xe9323e84, 0x29edb045,\n    0x24ddbe78, 0xe40230b9, 0xe564d220, 0x25bb5ce1, 0xa6ae67c8,\n    0x6671e909, 0x67170b90, 0xa7c88551, 0x613c7dc2, 0xa1e3f303,\n    0xa085119a, 0x605a9f5b, 0xe34fa472, 0x23902ab3, 0x22f6c82a,\n    0xe22946eb, 0x3896d450, 0xf8495a91, 0xf92fb808, 0x39f036c9,\n    0xbae50de0, 0x7a3a8321, 0x7b5c61b8, 0xbb83ef79, 0x7d7717ea,\n    0xbda8992b, 0xbcce7bb2, 0x7c11f573, 0xff04ce5a, 0x3fdb409b,\n    0x3ebda202, 0xfe622cc3, 0xf35222fe, 0x338dac3f, 0x32eb4ea6,\n    0xf234c067, 0x7121fb4e, 0xb1fe758f, 0xb0989716, 0x704719d7,\n    0xb6b3e144, 0x766c6f85, 0x770a8d1c, 0xb7d503dd, 0x34c038f4,\n    0xf41fb635, 0xf57954ac, 0x35a6da6d, 0x9f35e177, 0x5fea6fb6,\n    0x5e8c8d2f, 0x9e5303ee, 0x1d4638c7, 0xdd99b606, 0xdcff549f,\n    0x1c20da5e, 0xdad422cd, 0x1a0bac0c, 0x1b6d4e95, 0xdbb2c054,\n    0x58a7fb7d, 0x987875bc, 0x991e9725, 0x59c119e4, 0x54f117d9,\n    0x942e9918, 0x95487b81, 0x5597f540, 0xd682ce69, 0x165d40a8,\n    0x173ba231, 0xd7e42cf0, 0x1110d463, 0xd1cf5aa2, 0xd0a9b83b,\n    0x107636fa, 0x93630dd3, 0x53bc8312, 0x52da618b, 0x9205ef4a,\n    0x48ba7df1, 0x8865f330, 0x890311a9, 0x49dc9f68, 0xcac9a441,\n    0x0a162a80, 0x0b70c819, 0xcbaf46d8, 0x0d5bbe4b, 0xcd84308a,\n    0xcce2d213, 0x0c3d5cd2, 0x8f2867fb, 0x4ff7e93a, 0x4e910ba3,\n    0x8e4e8562, 0x837e8b5f, 0x43a1059e, 0x42c7e707, 0x821869c6,\n    0x010d52ef, 0xc1d2dc2e, 0xc0b43eb7, 0x006bb076, 0xc69f48e5,\n    0x0640c624, 0x072624bd, 0xc7f9aa7c, 0x44ec9155, 0x84331f94,\n    0x8555fd0d, 0x458a73cc, 0x702ca9a1, 0xb0f32760, 0xb195c5f9,\n    0x714a4b38, 0xf25f7011, 0x3280fed0, 0x33e61c49, 0xf3399288,\n    0x35cd6a1b, 0xf512e4da, 0xf4740643, 0x34ab8882, 0xb7beb3ab,\n    0x77613d6a, 0x7607dff3, 0xb6d85132, 0xbbe85f0f, 0x7b37d1ce,\n    0x7a513357, 0xba8ebd96, 0x399b86bf, 0xf944087e, 0xf822eae7,\n    0x38fd6426, 0xfe099cb5, 0x3ed61274, 0x3fb0f0ed, 0xff6f7e2c,\n    0x7c7a4505, 0xbca5cbc4, 0xbdc3295d, 0x7d1ca79c, 0xa7a33527,\n    0x677cbbe6, 0x661a597f, 0xa6c5d7be, 0x25d0ec97, 0xe50f6256,\n    0xe46980cf, 0x24b60e0e, 0xe242f69d, 0x229d785c, 0x23fb9ac5,\n    0xe3241404, 0x60312f2d, 0xa0eea1ec, 0xa1884375, 0x6157cdb4,\n    0x6c67c389, 0xacb84d48, 0xaddeafd1, 0x6d012110, 0xee141a39,\n    0x2ecb94f8, 0x2fad7661, 0xef72f8a0, 0x29860033, 0xe9598ef2,\n    0xe83f6c6b, 0x28e0e2aa, 0xabf5d983, 0x6b2a5742, 0x6a4cb5db,\n    0xaa933b1a},\n   {0x00000000, 0x6f4ca59b, 0x9f9e3bec, 0xf0d29e77, 0x7f3b0603,\n    0x1077a398, 0xe0a53def, 0x8fe99874, 0xfe760c06, 0x913aa99d,\n    0x61e837ea, 0x0ea49271, 0x814d0a05, 0xee01af9e, 0x1ed331e9,\n    0x719f9472, 0xfced180c, 0x93a1bd97, 0x637323e0, 0x0c3f867b,\n    0x83d61e0f, 0xec9abb94, 0x1c4825e3, 0x73048078, 0x029b140a,\n    0x6dd7b191, 0x9d052fe6, 0xf2498a7d, 0x7da01209, 0x12ecb792,\n    0xe23e29e5, 0x8d728c7e, 0xf8db3118, 0x97979483, 0x67450af4,\n    0x0809af6f, 0x87e0371b, 0xe8ac9280, 0x187e0cf7, 0x7732a96c,\n    0x06ad3d1e, 0x69e19885, 0x993306f2, 0xf67fa369, 0x79963b1d,\n    0x16da9e86, 0xe60800f1, 0x8944a56a, 0x04362914, 0x6b7a8c8f,\n    0x9ba812f8, 0xf4e4b763, 0x7b0d2f17, 0x14418a8c, 0xe49314fb,\n    0x8bdfb160, 0xfa402512, 0x950c8089, 0x65de1efe, 0x0a92bb65,\n    0x857b2311, 0xea37868a, 0x1ae518fd, 0x75a9bd66, 0xf0b76330,\n    0x9ffbc6ab, 0x6f2958dc, 0x0065fd47, 0x8f8c6533, 0xe0c0c0a8,\n    0x10125edf, 0x7f5efb44, 0x0ec16f36, 0x618dcaad, 0x915f54da,\n    0xfe13f141, 0x71fa6935, 0x1eb6ccae, 0xee6452d9, 0x8128f742,\n    0x0c5a7b3c, 0x6316dea7, 0x93c440d0, 0xfc88e54b, 0x73617d3f,\n    0x1c2dd8a4, 0xecff46d3, 0x83b3e348, 0xf22c773a, 0x9d60d2a1,\n    0x6db24cd6, 0x02fee94d, 0x8d177139, 0xe25bd4a2, 0x12894ad5,\n    0x7dc5ef4e, 0x086c5228, 0x6720f7b3, 0x97f269c4, 0xf8becc5f,\n    0x7757542b, 0x181bf1b0, 0xe8c96fc7, 0x8785ca5c, 0xf61a5e2e,\n    0x9956fbb5, 0x698465c2, 0x06c8c059, 0x8921582d, 0xe66dfdb6,\n    0x16bf63c1, 0x79f3c65a, 0xf4814a24, 0x9bcdefbf, 0x6b1f71c8,\n    0x0453d453, 0x8bba4c27, 0xe4f6e9bc, 0x142477cb, 0x7b68d250,\n    0x0af74622, 0x65bbe3b9, 0x95697dce, 0xfa25d855, 0x75cc4021,\n    0x1a80e5ba, 0xea527bcd, 0x851ede56, 0xe06fc760, 0x8f2362fb,\n    0x7ff1fc8c, 0x10bd5917, 0x9f54c163, 0xf01864f8, 0x00cafa8f,\n    0x6f865f14, 0x1e19cb66, 0x71556efd, 0x8187f08a, 0xeecb5511,\n    0x6122cd65, 0x0e6e68fe, 0xfebcf689, 0x91f05312, 0x1c82df6c,\n    0x73ce7af7, 0x831ce480, 0xec50411b, 0x63b9d96f, 0x0cf57cf4,\n    0xfc27e283, 0x936b4718, 0xe2f4d36a, 0x8db876f1, 0x7d6ae886,\n    0x12264d1d, 0x9dcfd569, 0xf28370f2, 0x0251ee85, 0x6d1d4b1e,\n    0x18b4f678, 0x77f853e3, 0x872acd94, 0xe866680f, 0x678ff07b,\n    0x08c355e0, 0xf811cb97, 0x975d6e0c, 0xe6c2fa7e, 0x898e5fe5,\n    0x795cc192, 0x16106409, 0x99f9fc7d, 0xf6b559e6, 0x0667c791,\n    0x692b620a, 0xe459ee74, 0x8b154bef, 0x7bc7d598, 0x148b7003,\n    0x9b62e877, 0xf42e4dec, 0x04fcd39b, 0x6bb07600, 0x1a2fe272,\n    0x756347e9, 0x85b1d99e, 0xeafd7c05, 0x6514e471, 0x0a5841ea,\n    0xfa8adf9d, 0x95c67a06, 0x10d8a450, 0x7f9401cb, 0x8f469fbc,\n    0xe00a3a27, 0x6fe3a253, 0x00af07c8, 0xf07d99bf, 0x9f313c24,\n    0xeeaea856, 0x81e20dcd, 0x713093ba, 0x1e7c3621, 0x9195ae55,\n    0xfed90bce, 0x0e0b95b9, 0x61473022, 0xec35bc5c, 0x837919c7,\n    0x73ab87b0, 0x1ce7222b, 0x930eba5f, 0xfc421fc4, 0x0c9081b3,\n    0x63dc2428, 0x1243b05a, 0x7d0f15c1, 0x8ddd8bb6, 0xe2912e2d,\n    0x6d78b659, 0x023413c2, 0xf2e68db5, 0x9daa282e, 0xe8039548,\n    0x874f30d3, 0x779daea4, 0x18d10b3f, 0x9738934b, 0xf87436d0,\n    0x08a6a8a7, 0x67ea0d3c, 0x1675994e, 0x79393cd5, 0x89eba2a2,\n    0xe6a70739, 0x694e9f4d, 0x06023ad6, 0xf6d0a4a1, 0x999c013a,\n    0x14ee8d44, 0x7ba228df, 0x8b70b6a8, 0xe43c1333, 0x6bd58b47,\n    0x04992edc, 0xf44bb0ab, 0x9b071530, 0xea988142, 0x85d424d9,\n    0x7506baae, 0x1a4a1f35, 0x95a38741, 0xfaef22da, 0x0a3dbcad,\n    0x65711936}};\n\n#endif /* W */\n\n#endif /* N == 3 */\n#if N == 4\n\n#if W == 8\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0xf1da05aa, 0x38c50d15, 0xc91f08bf, 0x718a1a2a,\n    0x80501f80, 0x494f173f, 0xb8951295, 0xe3143454, 0x12ce31fe,\n    0xdbd13941, 0x2a0b3ceb, 0x929e2e7e, 0x63442bd4, 0xaa5b236b,\n    0x5b8126c1, 0x1d596ee9, 0xec836b43, 0x259c63fc, 0xd4466656,\n    0x6cd374c3, 0x9d097169, 0x541679d6, 0xa5cc7c7c, 0xfe4d5abd,\n    0x0f975f17, 0xc68857a8, 0x37525202, 0x8fc74097, 0x7e1d453d,\n    0xb7024d82, 0x46d84828, 0x3ab2ddd2, 0xcb68d878, 0x0277d0c7,\n    0xf3add56d, 0x4b38c7f8, 0xbae2c252, 0x73fdcaed, 0x8227cf47,\n    0xd9a6e986, 0x287cec2c, 0xe163e493, 0x10b9e139, 0xa82cf3ac,\n    0x59f6f606, 0x90e9feb9, 0x6133fb13, 0x27ebb33b, 0xd631b691,\n    0x1f2ebe2e, 0xeef4bb84, 0x5661a911, 0xa7bbacbb, 0x6ea4a404,\n    0x9f7ea1ae, 0xc4ff876f, 0x352582c5, 0xfc3a8a7a, 0x0de08fd0,\n    0xb5759d45, 0x44af98ef, 0x8db09050, 0x7c6a95fa, 0x7565bba4,\n    0x84bfbe0e, 0x4da0b6b1, 0xbc7ab31b, 0x04efa18e, 0xf535a424,\n    0x3c2aac9b, 0xcdf0a931, 0x96718ff0, 0x67ab8a5a, 0xaeb482e5,\n    0x5f6e874f, 0xe7fb95da, 0x16219070, 0xdf3e98cf, 0x2ee49d65,\n    0x683cd54d, 0x99e6d0e7, 0x50f9d858, 0xa123ddf2, 0x19b6cf67,\n    0xe86ccacd, 0x2173c272, 0xd0a9c7d8, 0x8b28e119, 0x7af2e4b3,\n    0xb3edec0c, 0x4237e9a6, 0xfaa2fb33, 0x0b78fe99, 0xc267f626,\n    0x33bdf38c, 0x4fd76676, 0xbe0d63dc, 0x77126b63, 0x86c86ec9,\n    0x3e5d7c5c, 0xcf8779f6, 0x06987149, 0xf74274e3, 0xacc35222,\n    0x5d195788, 0x94065f37, 0x65dc5a9d, 0xdd494808, 0x2c934da2,\n    0xe58c451d, 0x145640b7, 0x528e089f, 0xa3540d35, 0x6a4b058a,\n    0x9b910020, 0x230412b5, 0xd2de171f, 0x1bc11fa0, 0xea1b1a0a,\n    0xb19a3ccb, 0x40403961, 0x895f31de, 0x78853474, 0xc01026e1,\n    0x31ca234b, 0xf8d52bf4, 0x090f2e5e, 0xeacb7748, 0x1b1172e2,\n    0xd20e7a5d, 0x23d47ff7, 0x9b416d62, 0x6a9b68c8, 0xa3846077,\n    0x525e65dd, 0x09df431c, 0xf80546b6, 0x311a4e09, 0xc0c04ba3,\n    0x78555936, 0x898f5c9c, 0x40905423, 0xb14a5189, 0xf79219a1,\n    0x06481c0b, 0xcf5714b4, 0x3e8d111e, 0x8618038b, 0x77c20621,\n    0xbedd0e9e, 0x4f070b34, 0x14862df5, 0xe55c285f, 0x2c4320e0,\n    0xdd99254a, 0x650c37df, 0x94d63275, 0x5dc93aca, 0xac133f60,\n    0xd079aa9a, 0x21a3af30, 0xe8bca78f, 0x1966a225, 0xa1f3b0b0,\n    0x5029b51a, 0x9936bda5, 0x68ecb80f, 0x336d9ece, 0xc2b79b64,\n    0x0ba893db, 0xfa729671, 0x42e784e4, 0xb33d814e, 0x7a2289f1,\n    0x8bf88c5b, 0xcd20c473, 0x3cfac1d9, 0xf5e5c966, 0x043fcccc,\n    0xbcaade59, 0x4d70dbf3, 0x846fd34c, 0x75b5d6e6, 0x2e34f027,\n    0xdfeef58d, 0x16f1fd32, 0xe72bf898, 0x5fbeea0d, 0xae64efa7,\n    0x677be718, 0x96a1e2b2, 0x9faeccec, 0x6e74c946, 0xa76bc1f9,\n    0x56b1c453, 0xee24d6c6, 0x1ffed36c, 0xd6e1dbd3, 0x273bde79,\n    0x7cbaf8b8, 0x8d60fd12, 0x447ff5ad, 0xb5a5f007, 0x0d30e292,\n    0xfceae738, 0x35f5ef87, 0xc42fea2d, 0x82f7a205, 0x732da7af,\n    0xba32af10, 0x4be8aaba, 0xf37db82f, 0x02a7bd85, 0xcbb8b53a,\n    0x3a62b090, 0x61e39651, 0x903993fb, 0x59269b44, 0xa8fc9eee,\n    0x10698c7b, 0xe1b389d1, 0x28ac816e, 0xd97684c4, 0xa51c113e,\n    0x54c61494, 0x9dd91c2b, 0x6c031981, 0xd4960b14, 0x254c0ebe,\n    0xec530601, 0x1d8903ab, 0x4608256a, 0xb7d220c0, 0x7ecd287f,\n    0x8f172dd5, 0x37823f40, 0xc6583aea, 0x0f473255, 0xfe9d37ff,\n    0xb8457fd7, 0x499f7a7d, 0x808072c2, 0x715a7768, 0xc9cf65fd,\n    0x38156057, 0xf10a68e8, 0x00d06d42, 0x5b514b83, 0xaa8b4e29,\n    0x63944696, 0x924e433c, 0x2adb51a9, 0xdb015403, 0x121e5cbc,\n    0xe3c45916},\n   {0x00000000, 0x0ee7e8d1, 0x1dcfd1a2, 0x13283973, 0x3b9fa344,\n    0x35784b95, 0x265072e6, 0x28b79a37, 0x773f4688, 0x79d8ae59,\n    0x6af0972a, 0x64177ffb, 0x4ca0e5cc, 0x42470d1d, 0x516f346e,\n    0x5f88dcbf, 0xee7e8d10, 0xe09965c1, 0xf3b15cb2, 0xfd56b463,\n    0xd5e12e54, 0xdb06c685, 0xc82efff6, 0xc6c91727, 0x9941cb98,\n    0x97a62349, 0x848e1a3a, 0x8a69f2eb, 0xa2de68dc, 0xac39800d,\n    0xbf11b97e, 0xb1f651af, 0x078c1c61, 0x096bf4b0, 0x1a43cdc3,\n    0x14a42512, 0x3c13bf25, 0x32f457f4, 0x21dc6e87, 0x2f3b8656,\n    0x70b35ae9, 0x7e54b238, 0x6d7c8b4b, 0x639b639a, 0x4b2cf9ad,\n    0x45cb117c, 0x56e3280f, 0x5804c0de, 0xe9f29171, 0xe71579a0,\n    0xf43d40d3, 0xfadaa802, 0xd26d3235, 0xdc8adae4, 0xcfa2e397,\n    0xc1450b46, 0x9ecdd7f9, 0x902a3f28, 0x8302065b, 0x8de5ee8a,\n    0xa55274bd, 0xabb59c6c, 0xb89da51f, 0xb67a4dce, 0x0f1838c2,\n    0x01ffd013, 0x12d7e960, 0x1c3001b1, 0x34879b86, 0x3a607357,\n    0x29484a24, 0x27afa2f5, 0x78277e4a, 0x76c0969b, 0x65e8afe8,\n    0x6b0f4739, 0x43b8dd0e, 0x4d5f35df, 0x5e770cac, 0x5090e47d,\n    0xe166b5d2, 0xef815d03, 0xfca96470, 0xf24e8ca1, 0xdaf91696,\n    0xd41efe47, 0xc736c734, 0xc9d12fe5, 0x9659f35a, 0x98be1b8b,\n    0x8b9622f8, 0x8571ca29, 0xadc6501e, 0xa321b8cf, 0xb00981bc,\n    0xbeee696d, 0x089424a3, 0x0673cc72, 0x155bf501, 0x1bbc1dd0,\n    0x330b87e7, 0x3dec6f36, 0x2ec45645, 0x2023be94, 0x7fab622b,\n    0x714c8afa, 0x6264b389, 0x6c835b58, 0x4434c16f, 0x4ad329be,\n    0x59fb10cd, 0x571cf81c, 0xe6eaa9b3, 0xe80d4162, 0xfb257811,\n    0xf5c290c0, 0xdd750af7, 0xd392e226, 0xc0badb55, 0xce5d3384,\n    0x91d5ef3b, 0x9f3207ea, 0x8c1a3e99, 0x82fdd648, 0xaa4a4c7f,\n    0xa4ada4ae, 0xb7859ddd, 0xb962750c, 0x1e307184, 0x10d79955,\n    0x03ffa026, 0x0d1848f7, 0x25afd2c0, 0x2b483a11, 0x38600362,\n    0x3687ebb3, 0x690f370c, 0x67e8dfdd, 0x74c0e6ae, 0x7a270e7f,\n    0x52909448, 0x5c777c99, 0x4f5f45ea, 0x41b8ad3b, 0xf04efc94,\n    0xfea91445, 0xed812d36, 0xe366c5e7, 0xcbd15fd0, 0xc536b701,\n    0xd61e8e72, 0xd8f966a3, 0x8771ba1c, 0x899652cd, 0x9abe6bbe,\n    0x9459836f, 0xbcee1958, 0xb209f189, 0xa121c8fa, 0xafc6202b,\n    0x19bc6de5, 0x175b8534, 0x0473bc47, 0x0a945496, 0x2223cea1,\n    0x2cc42670, 0x3fec1f03, 0x310bf7d2, 0x6e832b6d, 0x6064c3bc,\n    0x734cfacf, 0x7dab121e, 0x551c8829, 0x5bfb60f8, 0x48d3598b,\n    0x4634b15a, 0xf7c2e0f5, 0xf9250824, 0xea0d3157, 0xe4ead986,\n    0xcc5d43b1, 0xc2baab60, 0xd1929213, 0xdf757ac2, 0x80fda67d,\n    0x8e1a4eac, 0x9d3277df, 0x93d59f0e, 0xbb620539, 0xb585ede8,\n    0xa6add49b, 0xa84a3c4a, 0x11284946, 0x1fcfa197, 0x0ce798e4,\n    0x02007035, 0x2ab7ea02, 0x245002d3, 0x37783ba0, 0x399fd371,\n    0x66170fce, 0x68f0e71f, 0x7bd8de6c, 0x753f36bd, 0x5d88ac8a,\n    0x536f445b, 0x40477d28, 0x4ea095f9, 0xff56c456, 0xf1b12c87,\n    0xe29915f4, 0xec7efd25, 0xc4c96712, 0xca2e8fc3, 0xd906b6b0,\n    0xd7e15e61, 0x886982de, 0x868e6a0f, 0x95a6537c, 0x9b41bbad,\n    0xb3f6219a, 0xbd11c94b, 0xae39f038, 0xa0de18e9, 0x16a45527,\n    0x1843bdf6, 0x0b6b8485, 0x058c6c54, 0x2d3bf663, 0x23dc1eb2,\n    0x30f427c1, 0x3e13cf10, 0x619b13af, 0x6f7cfb7e, 0x7c54c20d,\n    0x72b32adc, 0x5a04b0eb, 0x54e3583a, 0x47cb6149, 0x492c8998,\n    0xf8dad837, 0xf63d30e6, 0xe5150995, 0xebf2e144, 0xc3457b73,\n    0xcda293a2, 0xde8aaad1, 0xd06d4200, 0x8fe59ebf, 0x8102766e,\n    0x922a4f1d, 0x9ccda7cc, 0xb47a3dfb, 0xba9dd52a, 0xa9b5ec59,\n    0xa7520488},\n   {0x00000000, 0x3c60e308, 0x78c1c610, 0x44a12518, 0xf1838c20,\n    0xcde36f28, 0x89424a30, 0xb522a938, 0x38761e01, 0x0416fd09,\n    0x40b7d811, 0x7cd73b19, 0xc9f59221, 0xf5957129, 0xb1345431,\n    0x8d54b739, 0x70ec3c02, 0x4c8cdf0a, 0x082dfa12, 0x344d191a,\n    0x816fb022, 0xbd0f532a, 0xf9ae7632, 0xc5ce953a, 0x489a2203,\n    0x74fac10b, 0x305be413, 0x0c3b071b, 0xb919ae23, 0x85794d2b,\n    0xc1d86833, 0xfdb88b3b, 0xe1d87804, 0xddb89b0c, 0x9919be14,\n    0xa5795d1c, 0x105bf424, 0x2c3b172c, 0x689a3234, 0x54fad13c,\n    0xd9ae6605, 0xe5ce850d, 0xa16fa015, 0x9d0f431d, 0x282dea25,\n    0x144d092d, 0x50ec2c35, 0x6c8ccf3d, 0x91344406, 0xad54a70e,\n    0xe9f58216, 0xd595611e, 0x60b7c826, 0x5cd72b2e, 0x18760e36,\n    0x2416ed3e, 0xa9425a07, 0x9522b90f, 0xd1839c17, 0xede37f1f,\n    0x58c1d627, 0x64a1352f, 0x20001037, 0x1c60f33f, 0x18c1f649,\n    0x24a11541, 0x60003059, 0x5c60d351, 0xe9427a69, 0xd5229961,\n    0x9183bc79, 0xade35f71, 0x20b7e848, 0x1cd70b40, 0x58762e58,\n    0x6416cd50, 0xd1346468, 0xed548760, 0xa9f5a278, 0x95954170,\n    0x682dca4b, 0x544d2943, 0x10ec0c5b, 0x2c8cef53, 0x99ae466b,\n    0xa5cea563, 0xe16f807b, 0xdd0f6373, 0x505bd44a, 0x6c3b3742,\n    0x289a125a, 0x14faf152, 0xa1d8586a, 0x9db8bb62, 0xd9199e7a,\n    0xe5797d72, 0xf9198e4d, 0xc5796d45, 0x81d8485d, 0xbdb8ab55,\n    0x089a026d, 0x34fae165, 0x705bc47d, 0x4c3b2775, 0xc16f904c,\n    0xfd0f7344, 0xb9ae565c, 0x85ceb554, 0x30ec1c6c, 0x0c8cff64,\n    0x482dda7c, 0x744d3974, 0x89f5b24f, 0xb5955147, 0xf134745f,\n    0xcd549757, 0x78763e6f, 0x4416dd67, 0x00b7f87f, 0x3cd71b77,\n    0xb183ac4e, 0x8de34f46, 0xc9426a5e, 0xf5228956, 0x4000206e,\n    0x7c60c366, 0x38c1e67e, 0x04a10576, 0x3183ec92, 0x0de30f9a,\n    0x49422a82, 0x7522c98a, 0xc00060b2, 0xfc6083ba, 0xb8c1a6a2,\n    0x84a145aa, 0x09f5f293, 0x3595119b, 0x71343483, 0x4d54d78b,\n    0xf8767eb3, 0xc4169dbb, 0x80b7b8a3, 0xbcd75bab, 0x416fd090,\n    0x7d0f3398, 0x39ae1680, 0x05cef588, 0xb0ec5cb0, 0x8c8cbfb8,\n    0xc82d9aa0, 0xf44d79a8, 0x7919ce91, 0x45792d99, 0x01d80881,\n    0x3db8eb89, 0x889a42b1, 0xb4faa1b9, 0xf05b84a1, 0xcc3b67a9,\n    0xd05b9496, 0xec3b779e, 0xa89a5286, 0x94fab18e, 0x21d818b6,\n    0x1db8fbbe, 0x5919dea6, 0x65793dae, 0xe82d8a97, 0xd44d699f,\n    0x90ec4c87, 0xac8caf8f, 0x19ae06b7, 0x25cee5bf, 0x616fc0a7,\n    0x5d0f23af, 0xa0b7a894, 0x9cd74b9c, 0xd8766e84, 0xe4168d8c,\n    0x513424b4, 0x6d54c7bc, 0x29f5e2a4, 0x159501ac, 0x98c1b695,\n    0xa4a1559d, 0xe0007085, 0xdc60938d, 0x69423ab5, 0x5522d9bd,\n    0x1183fca5, 0x2de31fad, 0x29421adb, 0x1522f9d3, 0x5183dccb,\n    0x6de33fc3, 0xd8c196fb, 0xe4a175f3, 0xa00050eb, 0x9c60b3e3,\n    0x113404da, 0x2d54e7d2, 0x69f5c2ca, 0x559521c2, 0xe0b788fa,\n    0xdcd76bf2, 0x98764eea, 0xa416ade2, 0x59ae26d9, 0x65cec5d1,\n    0x216fe0c9, 0x1d0f03c1, 0xa82daaf9, 0x944d49f1, 0xd0ec6ce9,\n    0xec8c8fe1, 0x61d838d8, 0x5db8dbd0, 0x1919fec8, 0x25791dc0,\n    0x905bb4f8, 0xac3b57f0, 0xe89a72e8, 0xd4fa91e0, 0xc89a62df,\n    0xf4fa81d7, 0xb05ba4cf, 0x8c3b47c7, 0x3919eeff, 0x05790df7,\n    0x41d828ef, 0x7db8cbe7, 0xf0ec7cde, 0xcc8c9fd6, 0x882dbace,\n    0xb44d59c6, 0x016ff0fe, 0x3d0f13f6, 0x79ae36ee, 0x45ced5e6,\n    0xb8765edd, 0x8416bdd5, 0xc0b798cd, 0xfcd77bc5, 0x49f5d2fd,\n    0x759531f5, 0x313414ed, 0x0d54f7e5, 0x800040dc, 0xbc60a3d4,\n    0xf8c186cc, 0xc4a165c4, 0x7183ccfc, 0x4de32ff4, 0x09420aec,\n    0x3522e9e4},\n   {0x00000000, 0x6307d924, 0xc60fb248, 0xa5086b6c, 0x576e62d1,\n    0x3469bbf5, 0x9161d099, 0xf26609bd, 0xaedcc5a2, 0xcddb1c86,\n    0x68d377ea, 0x0bd4aece, 0xf9b2a773, 0x9ab57e57, 0x3fbd153b,\n    0x5cbacc1f, 0x86c88d05, 0xe5cf5421, 0x40c73f4d, 0x23c0e669,\n    0xd1a6efd4, 0xb2a136f0, 0x17a95d9c, 0x74ae84b8, 0x281448a7,\n    0x4b139183, 0xee1bfaef, 0x8d1c23cb, 0x7f7a2a76, 0x1c7df352,\n    0xb975983e, 0xda72411a, 0xd6e01c4b, 0xb5e7c56f, 0x10efae03,\n    0x73e87727, 0x818e7e9a, 0xe289a7be, 0x4781ccd2, 0x248615f6,\n    0x783cd9e9, 0x1b3b00cd, 0xbe336ba1, 0xdd34b285, 0x2f52bb38,\n    0x4c55621c, 0xe95d0970, 0x8a5ad054, 0x5028914e, 0x332f486a,\n    0x96272306, 0xf520fa22, 0x0746f39f, 0x64412abb, 0xc14941d7,\n    0xa24e98f3, 0xfef454ec, 0x9df38dc8, 0x38fbe6a4, 0x5bfc3f80,\n    0xa99a363d, 0xca9def19, 0x6f958475, 0x0c925d51, 0x76b13ed7,\n    0x15b6e7f3, 0xb0be8c9f, 0xd3b955bb, 0x21df5c06, 0x42d88522,\n    0xe7d0ee4e, 0x84d7376a, 0xd86dfb75, 0xbb6a2251, 0x1e62493d,\n    0x7d659019, 0x8f0399a4, 0xec044080, 0x490c2bec, 0x2a0bf2c8,\n    0xf079b3d2, 0x937e6af6, 0x3676019a, 0x5571d8be, 0xa717d103,\n    0xc4100827, 0x6118634b, 0x021fba6f, 0x5ea57670, 0x3da2af54,\n    0x98aac438, 0xfbad1d1c, 0x09cb14a1, 0x6acccd85, 0xcfc4a6e9,\n    0xacc37fcd, 0xa051229c, 0xc356fbb8, 0x665e90d4, 0x055949f0,\n    0xf73f404d, 0x94389969, 0x3130f205, 0x52372b21, 0x0e8de73e,\n    0x6d8a3e1a, 0xc8825576, 0xab858c52, 0x59e385ef, 0x3ae45ccb,\n    0x9fec37a7, 0xfcebee83, 0x2699af99, 0x459e76bd, 0xe0961dd1,\n    0x8391c4f5, 0x71f7cd48, 0x12f0146c, 0xb7f87f00, 0xd4ffa624,\n    0x88456a3b, 0xeb42b31f, 0x4e4ad873, 0x2d4d0157, 0xdf2b08ea,\n    0xbc2cd1ce, 0x1924baa2, 0x7a236386, 0xed627dae, 0x8e65a48a,\n    0x2b6dcfe6, 0x486a16c2, 0xba0c1f7f, 0xd90bc65b, 0x7c03ad37,\n    0x1f047413, 0x43beb80c, 0x20b96128, 0x85b10a44, 0xe6b6d360,\n    0x14d0dadd, 0x77d703f9, 0xd2df6895, 0xb1d8b1b1, 0x6baaf0ab,\n    0x08ad298f, 0xada542e3, 0xcea29bc7, 0x3cc4927a, 0x5fc34b5e,\n    0xfacb2032, 0x99ccf916, 0xc5763509, 0xa671ec2d, 0x03798741,\n    0x607e5e65, 0x921857d8, 0xf11f8efc, 0x5417e590, 0x37103cb4,\n    0x3b8261e5, 0x5885b8c1, 0xfd8dd3ad, 0x9e8a0a89, 0x6cec0334,\n    0x0febda10, 0xaae3b17c, 0xc9e46858, 0x955ea447, 0xf6597d63,\n    0x5351160f, 0x3056cf2b, 0xc230c696, 0xa1371fb2, 0x043f74de,\n    0x6738adfa, 0xbd4aece0, 0xde4d35c4, 0x7b455ea8, 0x1842878c,\n    0xea248e31, 0x89235715, 0x2c2b3c79, 0x4f2ce55d, 0x13962942,\n    0x7091f066, 0xd5999b0a, 0xb69e422e, 0x44f84b93, 0x27ff92b7,\n    0x82f7f9db, 0xe1f020ff, 0x9bd34379, 0xf8d49a5d, 0x5ddcf131,\n    0x3edb2815, 0xccbd21a8, 0xafbaf88c, 0x0ab293e0, 0x69b54ac4,\n    0x350f86db, 0x56085fff, 0xf3003493, 0x9007edb7, 0x6261e40a,\n    0x01663d2e, 0xa46e5642, 0xc7698f66, 0x1d1bce7c, 0x7e1c1758,\n    0xdb147c34, 0xb813a510, 0x4a75acad, 0x29727589, 0x8c7a1ee5,\n    0xef7dc7c1, 0xb3c70bde, 0xd0c0d2fa, 0x75c8b996, 0x16cf60b2,\n    0xe4a9690f, 0x87aeb02b, 0x22a6db47, 0x41a10263, 0x4d335f32,\n    0x2e348616, 0x8b3ced7a, 0xe83b345e, 0x1a5d3de3, 0x795ae4c7,\n    0xdc528fab, 0xbf55568f, 0xe3ef9a90, 0x80e843b4, 0x25e028d8,\n    0x46e7f1fc, 0xb481f841, 0xd7862165, 0x728e4a09, 0x1189932d,\n    0xcbfbd237, 0xa8fc0b13, 0x0df4607f, 0x6ef3b95b, 0x9c95b0e6,\n    0xff9269c2, 0x5a9a02ae, 0x399ddb8a, 0x65271795, 0x0620ceb1,\n    0xa328a5dd, 0xc02f7cf9, 0x32497544, 0x514eac60, 0xf446c70c,\n    0x97411e28},\n   {0x00000000, 0x01b5fd1d, 0x036bfa3a, 0x02de0727, 0x06d7f474,\n    0x07620969, 0x05bc0e4e, 0x0409f353, 0x0dafe8e8, 0x0c1a15f5,\n    0x0ec412d2, 0x0f71efcf, 0x0b781c9c, 0x0acde181, 0x0813e6a6,\n    0x09a61bbb, 0x1b5fd1d0, 0x1aea2ccd, 0x18342bea, 0x1981d6f7,\n    0x1d8825a4, 0x1c3dd8b9, 0x1ee3df9e, 0x1f562283, 0x16f03938,\n    0x1745c425, 0x159bc302, 0x142e3e1f, 0x1027cd4c, 0x11923051,\n    0x134c3776, 0x12f9ca6b, 0x36bfa3a0, 0x370a5ebd, 0x35d4599a,\n    0x3461a487, 0x306857d4, 0x31ddaac9, 0x3303adee, 0x32b650f3,\n    0x3b104b48, 0x3aa5b655, 0x387bb172, 0x39ce4c6f, 0x3dc7bf3c,\n    0x3c724221, 0x3eac4506, 0x3f19b81b, 0x2de07270, 0x2c558f6d,\n    0x2e8b884a, 0x2f3e7557, 0x2b378604, 0x2a827b19, 0x285c7c3e,\n    0x29e98123, 0x204f9a98, 0x21fa6785, 0x232460a2, 0x22919dbf,\n    0x26986eec, 0x272d93f1, 0x25f394d6, 0x244669cb, 0x6d7f4740,\n    0x6ccaba5d, 0x6e14bd7a, 0x6fa14067, 0x6ba8b334, 0x6a1d4e29,\n    0x68c3490e, 0x6976b413, 0x60d0afa8, 0x616552b5, 0x63bb5592,\n    0x620ea88f, 0x66075bdc, 0x67b2a6c1, 0x656ca1e6, 0x64d95cfb,\n    0x76209690, 0x77956b8d, 0x754b6caa, 0x74fe91b7, 0x70f762e4,\n    0x71429ff9, 0x739c98de, 0x722965c3, 0x7b8f7e78, 0x7a3a8365,\n    0x78e48442, 0x7951795f, 0x7d588a0c, 0x7ced7711, 0x7e337036,\n    0x7f868d2b, 0x5bc0e4e0, 0x5a7519fd, 0x58ab1eda, 0x591ee3c7,\n    0x5d171094, 0x5ca2ed89, 0x5e7ceaae, 0x5fc917b3, 0x566f0c08,\n    0x57daf115, 0x5504f632, 0x54b10b2f, 0x50b8f87c, 0x510d0561,\n    0x53d30246, 0x5266ff5b, 0x409f3530, 0x412ac82d, 0x43f4cf0a,\n    0x42413217, 0x4648c144, 0x47fd3c59, 0x45233b7e, 0x4496c663,\n    0x4d30ddd8, 0x4c8520c5, 0x4e5b27e2, 0x4feedaff, 0x4be729ac,\n    0x4a52d4b1, 0x488cd396, 0x49392e8b, 0xdafe8e80, 0xdb4b739d,\n    0xd99574ba, 0xd82089a7, 0xdc297af4, 0xdd9c87e9, 0xdf4280ce,\n    0xdef77dd3, 0xd7516668, 0xd6e49b75, 0xd43a9c52, 0xd58f614f,\n    0xd186921c, 0xd0336f01, 0xd2ed6826, 0xd358953b, 0xc1a15f50,\n    0xc014a24d, 0xc2caa56a, 0xc37f5877, 0xc776ab24, 0xc6c35639,\n    0xc41d511e, 0xc5a8ac03, 0xcc0eb7b8, 0xcdbb4aa5, 0xcf654d82,\n    0xced0b09f, 0xcad943cc, 0xcb6cbed1, 0xc9b2b9f6, 0xc80744eb,\n    0xec412d20, 0xedf4d03d, 0xef2ad71a, 0xee9f2a07, 0xea96d954,\n    0xeb232449, 0xe9fd236e, 0xe848de73, 0xe1eec5c8, 0xe05b38d5,\n    0xe2853ff2, 0xe330c2ef, 0xe73931bc, 0xe68ccca1, 0xe452cb86,\n    0xe5e7369b, 0xf71efcf0, 0xf6ab01ed, 0xf47506ca, 0xf5c0fbd7,\n    0xf1c90884, 0xf07cf599, 0xf2a2f2be, 0xf3170fa3, 0xfab11418,\n    0xfb04e905, 0xf9daee22, 0xf86f133f, 0xfc66e06c, 0xfdd31d71,\n    0xff0d1a56, 0xfeb8e74b, 0xb781c9c0, 0xb63434dd, 0xb4ea33fa,\n    0xb55fcee7, 0xb1563db4, 0xb0e3c0a9, 0xb23dc78e, 0xb3883a93,\n    0xba2e2128, 0xbb9bdc35, 0xb945db12, 0xb8f0260f, 0xbcf9d55c,\n    0xbd4c2841, 0xbf922f66, 0xbe27d27b, 0xacde1810, 0xad6be50d,\n    0xafb5e22a, 0xae001f37, 0xaa09ec64, 0xabbc1179, 0xa962165e,\n    0xa8d7eb43, 0xa171f0f8, 0xa0c40de5, 0xa21a0ac2, 0xa3aff7df,\n    0xa7a6048c, 0xa613f991, 0xa4cdfeb6, 0xa57803ab, 0x813e6a60,\n    0x808b977d, 0x8255905a, 0x83e06d47, 0x87e99e14, 0x865c6309,\n    0x8482642e, 0x85379933, 0x8c918288, 0x8d247f95, 0x8ffa78b2,\n    0x8e4f85af, 0x8a4676fc, 0x8bf38be1, 0x892d8cc6, 0x889871db,\n    0x9a61bbb0, 0x9bd446ad, 0x990a418a, 0x98bfbc97, 0x9cb64fc4,\n    0x9d03b2d9, 0x9fddb5fe, 0x9e6848e3, 0x97ce5358, 0x967bae45,\n    0x94a5a962, 0x9510547f, 0x9119a72c, 0x90ac5a31, 0x92725d16,\n    0x93c7a00b},\n   {0x00000000, 0x6e8c1b41, 0xdd183682, 0xb3942dc3, 0x61416b45,\n    0x0fcd7004, 0xbc595dc7, 0xd2d54686, 0xc282d68a, 0xac0ecdcb,\n    0x1f9ae008, 0x7116fb49, 0xa3c3bdcf, 0xcd4fa68e, 0x7edb8b4d,\n    0x1057900c, 0x5e74ab55, 0x30f8b014, 0x836c9dd7, 0xede08696,\n    0x3f35c010, 0x51b9db51, 0xe22df692, 0x8ca1edd3, 0x9cf67ddf,\n    0xf27a669e, 0x41ee4b5d, 0x2f62501c, 0xfdb7169a, 0x933b0ddb,\n    0x20af2018, 0x4e233b59, 0xbce956aa, 0xd2654deb, 0x61f16028,\n    0x0f7d7b69, 0xdda83def, 0xb32426ae, 0x00b00b6d, 0x6e3c102c,\n    0x7e6b8020, 0x10e79b61, 0xa373b6a2, 0xcdffade3, 0x1f2aeb65,\n    0x71a6f024, 0xc232dde7, 0xacbec6a6, 0xe29dfdff, 0x8c11e6be,\n    0x3f85cb7d, 0x5109d03c, 0x83dc96ba, 0xed508dfb, 0x5ec4a038,\n    0x3048bb79, 0x201f2b75, 0x4e933034, 0xfd071df7, 0x938b06b6,\n    0x415e4030, 0x2fd25b71, 0x9c4676b2, 0xf2ca6df3, 0xa2a3ab15,\n    0xcc2fb054, 0x7fbb9d97, 0x113786d6, 0xc3e2c050, 0xad6edb11,\n    0x1efaf6d2, 0x7076ed93, 0x60217d9f, 0x0ead66de, 0xbd394b1d,\n    0xd3b5505c, 0x016016da, 0x6fec0d9b, 0xdc782058, 0xb2f43b19,\n    0xfcd70040, 0x925b1b01, 0x21cf36c2, 0x4f432d83, 0x9d966b05,\n    0xf31a7044, 0x408e5d87, 0x2e0246c6, 0x3e55d6ca, 0x50d9cd8b,\n    0xe34de048, 0x8dc1fb09, 0x5f14bd8f, 0x3198a6ce, 0x820c8b0d,\n    0xec80904c, 0x1e4afdbf, 0x70c6e6fe, 0xc352cb3d, 0xadded07c,\n    0x7f0b96fa, 0x11878dbb, 0xa213a078, 0xcc9fbb39, 0xdcc82b35,\n    0xb2443074, 0x01d01db7, 0x6f5c06f6, 0xbd894070, 0xd3055b31,\n    0x609176f2, 0x0e1d6db3, 0x403e56ea, 0x2eb24dab, 0x9d266068,\n    0xf3aa7b29, 0x217f3daf, 0x4ff326ee, 0xfc670b2d, 0x92eb106c,\n    0x82bc8060, 0xec309b21, 0x5fa4b6e2, 0x3128ada3, 0xe3fdeb25,\n    0x8d71f064, 0x3ee5dda7, 0x5069c6e6, 0x9e36506b, 0xf0ba4b2a,\n    0x432e66e9, 0x2da27da8, 0xff773b2e, 0x91fb206f, 0x226f0dac,\n    0x4ce316ed, 0x5cb486e1, 0x32389da0, 0x81acb063, 0xef20ab22,\n    0x3df5eda4, 0x5379f6e5, 0xe0eddb26, 0x8e61c067, 0xc042fb3e,\n    0xaecee07f, 0x1d5acdbc, 0x73d6d6fd, 0xa103907b, 0xcf8f8b3a,\n    0x7c1ba6f9, 0x1297bdb8, 0x02c02db4, 0x6c4c36f5, 0xdfd81b36,\n    0xb1540077, 0x638146f1, 0x0d0d5db0, 0xbe997073, 0xd0156b32,\n    0x22df06c1, 0x4c531d80, 0xffc73043, 0x914b2b02, 0x439e6d84,\n    0x2d1276c5, 0x9e865b06, 0xf00a4047, 0xe05dd04b, 0x8ed1cb0a,\n    0x3d45e6c9, 0x53c9fd88, 0x811cbb0e, 0xef90a04f, 0x5c048d8c,\n    0x328896cd, 0x7cabad94, 0x1227b6d5, 0xa1b39b16, 0xcf3f8057,\n    0x1deac6d1, 0x7366dd90, 0xc0f2f053, 0xae7eeb12, 0xbe297b1e,\n    0xd0a5605f, 0x63314d9c, 0x0dbd56dd, 0xdf68105b, 0xb1e40b1a,\n    0x027026d9, 0x6cfc3d98, 0x3c95fb7e, 0x5219e03f, 0xe18dcdfc,\n    0x8f01d6bd, 0x5dd4903b, 0x33588b7a, 0x80cca6b9, 0xee40bdf8,\n    0xfe172df4, 0x909b36b5, 0x230f1b76, 0x4d830037, 0x9f5646b1,\n    0xf1da5df0, 0x424e7033, 0x2cc26b72, 0x62e1502b, 0x0c6d4b6a,\n    0xbff966a9, 0xd1757de8, 0x03a03b6e, 0x6d2c202f, 0xdeb80dec,\n    0xb03416ad, 0xa06386a1, 0xceef9de0, 0x7d7bb023, 0x13f7ab62,\n    0xc122ede4, 0xafaef6a5, 0x1c3adb66, 0x72b6c027, 0x807cadd4,\n    0xeef0b695, 0x5d649b56, 0x33e88017, 0xe13dc691, 0x8fb1ddd0,\n    0x3c25f013, 0x52a9eb52, 0x42fe7b5e, 0x2c72601f, 0x9fe64ddc,\n    0xf16a569d, 0x23bf101b, 0x4d330b5a, 0xfea72699, 0x902b3dd8,\n    0xde080681, 0xb0841dc0, 0x03103003, 0x6d9c2b42, 0xbf496dc4,\n    0xd1c57685, 0x62515b46, 0x0cdd4007, 0x1c8ad00b, 0x7206cb4a,\n    0xc192e689, 0xaf1efdc8, 0x7dcbbb4e, 0x1347a00f, 0xa0d38dcc,\n    0xce5f968d},\n   {0x00000000, 0xe71da697, 0x154a4b6f, 0xf257edf8, 0x2a9496de,\n    0xcd893049, 0x3fdeddb1, 0xd8c37b26, 0x55292dbc, 0xb2348b2b,\n    0x406366d3, 0xa77ec044, 0x7fbdbb62, 0x98a01df5, 0x6af7f00d,\n    0x8dea569a, 0xaa525b78, 0x4d4ffdef, 0xbf181017, 0x5805b680,\n    0x80c6cda6, 0x67db6b31, 0x958c86c9, 0x7291205e, 0xff7b76c4,\n    0x1866d053, 0xea313dab, 0x0d2c9b3c, 0xd5efe01a, 0x32f2468d,\n    0xc0a5ab75, 0x27b80de2, 0x8fd5b0b1, 0x68c81626, 0x9a9ffbde,\n    0x7d825d49, 0xa541266f, 0x425c80f8, 0xb00b6d00, 0x5716cb97,\n    0xdafc9d0d, 0x3de13b9a, 0xcfb6d662, 0x28ab70f5, 0xf0680bd3,\n    0x1775ad44, 0xe52240bc, 0x023fe62b, 0x2587ebc9, 0xc29a4d5e,\n    0x30cda0a6, 0xd7d00631, 0x0f137d17, 0xe80edb80, 0x1a593678,\n    0xfd4490ef, 0x70aec675, 0x97b360e2, 0x65e48d1a, 0x82f92b8d,\n    0x5a3a50ab, 0xbd27f63c, 0x4f701bc4, 0xa86dbd53, 0xc4da6723,\n    0x23c7c1b4, 0xd1902c4c, 0x368d8adb, 0xee4ef1fd, 0x0953576a,\n    0xfb04ba92, 0x1c191c05, 0x91f34a9f, 0x76eeec08, 0x84b901f0,\n    0x63a4a767, 0xbb67dc41, 0x5c7a7ad6, 0xae2d972e, 0x493031b9,\n    0x6e883c5b, 0x89959acc, 0x7bc27734, 0x9cdfd1a3, 0x441caa85,\n    0xa3010c12, 0x5156e1ea, 0xb64b477d, 0x3ba111e7, 0xdcbcb770,\n    0x2eeb5a88, 0xc9f6fc1f, 0x11358739, 0xf62821ae, 0x047fcc56,\n    0xe3626ac1, 0x4b0fd792, 0xac127105, 0x5e459cfd, 0xb9583a6a,\n    0x619b414c, 0x8686e7db, 0x74d10a23, 0x93ccacb4, 0x1e26fa2e,\n    0xf93b5cb9, 0x0b6cb141, 0xec7117d6, 0x34b26cf0, 0xd3afca67,\n    0x21f8279f, 0xc6e58108, 0xe15d8cea, 0x06402a7d, 0xf417c785,\n    0x130a6112, 0xcbc91a34, 0x2cd4bca3, 0xde83515b, 0x399ef7cc,\n    0xb474a156, 0x536907c1, 0xa13eea39, 0x46234cae, 0x9ee03788,\n    0x79fd911f, 0x8baa7ce7, 0x6cb7da70, 0x52c5c807, 0xb5d86e90,\n    0x478f8368, 0xa09225ff, 0x78515ed9, 0x9f4cf84e, 0x6d1b15b6,\n    0x8a06b321, 0x07ece5bb, 0xe0f1432c, 0x12a6aed4, 0xf5bb0843,\n    0x2d787365, 0xca65d5f2, 0x3832380a, 0xdf2f9e9d, 0xf897937f,\n    0x1f8a35e8, 0xedddd810, 0x0ac07e87, 0xd20305a1, 0x351ea336,\n    0xc7494ece, 0x2054e859, 0xadbebec3, 0x4aa31854, 0xb8f4f5ac,\n    0x5fe9533b, 0x872a281d, 0x60378e8a, 0x92606372, 0x757dc5e5,\n    0xdd1078b6, 0x3a0dde21, 0xc85a33d9, 0x2f47954e, 0xf784ee68,\n    0x109948ff, 0xe2cea507, 0x05d30390, 0x8839550a, 0x6f24f39d,\n    0x9d731e65, 0x7a6eb8f2, 0xa2adc3d4, 0x45b06543, 0xb7e788bb,\n    0x50fa2e2c, 0x774223ce, 0x905f8559, 0x620868a1, 0x8515ce36,\n    0x5dd6b510, 0xbacb1387, 0x489cfe7f, 0xaf8158e8, 0x226b0e72,\n    0xc576a8e5, 0x3721451d, 0xd03ce38a, 0x08ff98ac, 0xefe23e3b,\n    0x1db5d3c3, 0xfaa87554, 0x961faf24, 0x710209b3, 0x8355e44b,\n    0x644842dc, 0xbc8b39fa, 0x5b969f6d, 0xa9c17295, 0x4edcd402,\n    0xc3368298, 0x242b240f, 0xd67cc9f7, 0x31616f60, 0xe9a21446,\n    0x0ebfb2d1, 0xfce85f29, 0x1bf5f9be, 0x3c4df45c, 0xdb5052cb,\n    0x2907bf33, 0xce1a19a4, 0x16d96282, 0xf1c4c415, 0x039329ed,\n    0xe48e8f7a, 0x6964d9e0, 0x8e797f77, 0x7c2e928f, 0x9b333418,\n    0x43f04f3e, 0xa4ede9a9, 0x56ba0451, 0xb1a7a2c6, 0x19ca1f95,\n    0xfed7b902, 0x0c8054fa, 0xeb9df26d, 0x335e894b, 0xd4432fdc,\n    0x2614c224, 0xc10964b3, 0x4ce33229, 0xabfe94be, 0x59a97946,\n    0xbeb4dfd1, 0x6677a4f7, 0x816a0260, 0x733def98, 0x9420490f,\n    0xb39844ed, 0x5485e27a, 0xa6d20f82, 0x41cfa915, 0x990cd233,\n    0x7e1174a4, 0x8c46995c, 0x6b5b3fcb, 0xe6b16951, 0x01accfc6,\n    0xf3fb223e, 0x14e684a9, 0xcc25ff8f, 0x2b385918, 0xd96fb4e0,\n    0x3e721277},\n   {0x00000000, 0xa58b900e, 0x9066265d, 0x35edb653, 0xfbbd4afb,\n    0x5e36daf5, 0x6bdb6ca6, 0xce50fca8, 0x2c0b93b7, 0x898003b9,\n    0xbc6db5ea, 0x19e625e4, 0xd7b6d94c, 0x723d4942, 0x47d0ff11,\n    0xe25b6f1f, 0x5817276e, 0xfd9cb760, 0xc8710133, 0x6dfa913d,\n    0xa3aa6d95, 0x0621fd9b, 0x33cc4bc8, 0x9647dbc6, 0x741cb4d9,\n    0xd19724d7, 0xe47a9284, 0x41f1028a, 0x8fa1fe22, 0x2a2a6e2c,\n    0x1fc7d87f, 0xba4c4871, 0xb02e4edc, 0x15a5ded2, 0x20486881,\n    0x85c3f88f, 0x4b930427, 0xee189429, 0xdbf5227a, 0x7e7eb274,\n    0x9c25dd6b, 0x39ae4d65, 0x0c43fb36, 0xa9c86b38, 0x67989790,\n    0xc213079e, 0xf7feb1cd, 0x527521c3, 0xe83969b2, 0x4db2f9bc,\n    0x785f4fef, 0xddd4dfe1, 0x13842349, 0xb60fb347, 0x83e20514,\n    0x2669951a, 0xc432fa05, 0x61b96a0b, 0x5454dc58, 0xf1df4c56,\n    0x3f8fb0fe, 0x9a0420f0, 0xafe996a3, 0x0a6206ad, 0xbb2d9bf9,\n    0x1ea60bf7, 0x2b4bbda4, 0x8ec02daa, 0x4090d102, 0xe51b410c,\n    0xd0f6f75f, 0x757d6751, 0x9726084e, 0x32ad9840, 0x07402e13,\n    0xa2cbbe1d, 0x6c9b42b5, 0xc910d2bb, 0xfcfd64e8, 0x5976f4e6,\n    0xe33abc97, 0x46b12c99, 0x735c9aca, 0xd6d70ac4, 0x1887f66c,\n    0xbd0c6662, 0x88e1d031, 0x2d6a403f, 0xcf312f20, 0x6ababf2e,\n    0x5f57097d, 0xfadc9973, 0x348c65db, 0x9107f5d5, 0xa4ea4386,\n    0x0161d388, 0x0b03d525, 0xae88452b, 0x9b65f378, 0x3eee6376,\n    0xf0be9fde, 0x55350fd0, 0x60d8b983, 0xc553298d, 0x27084692,\n    0x8283d69c, 0xb76e60cf, 0x12e5f0c1, 0xdcb50c69, 0x793e9c67,\n    0x4cd32a34, 0xe958ba3a, 0x5314f24b, 0xf69f6245, 0xc372d416,\n    0x66f94418, 0xa8a9b8b0, 0x0d2228be, 0x38cf9eed, 0x9d440ee3,\n    0x7f1f61fc, 0xda94f1f2, 0xef7947a1, 0x4af2d7af, 0x84a22b07,\n    0x2129bb09, 0x14c40d5a, 0xb14f9d54, 0xad2a31b3, 0x08a1a1bd,\n    0x3d4c17ee, 0x98c787e0, 0x56977b48, 0xf31ceb46, 0xc6f15d15,\n    0x637acd1b, 0x8121a204, 0x24aa320a, 0x11478459, 0xb4cc1457,\n    0x7a9ce8ff, 0xdf1778f1, 0xeafacea2, 0x4f715eac, 0xf53d16dd,\n    0x50b686d3, 0x655b3080, 0xc0d0a08e, 0x0e805c26, 0xab0bcc28,\n    0x9ee67a7b, 0x3b6dea75, 0xd936856a, 0x7cbd1564, 0x4950a337,\n    0xecdb3339, 0x228bcf91, 0x87005f9f, 0xb2ede9cc, 0x176679c2,\n    0x1d047f6f, 0xb88fef61, 0x8d625932, 0x28e9c93c, 0xe6b93594,\n    0x4332a59a, 0x76df13c9, 0xd35483c7, 0x310fecd8, 0x94847cd6,\n    0xa169ca85, 0x04e25a8b, 0xcab2a623, 0x6f39362d, 0x5ad4807e,\n    0xff5f1070, 0x45135801, 0xe098c80f, 0xd5757e5c, 0x70feee52,\n    0xbeae12fa, 0x1b2582f4, 0x2ec834a7, 0x8b43a4a9, 0x6918cbb6,\n    0xcc935bb8, 0xf97eedeb, 0x5cf57de5, 0x92a5814d, 0x372e1143,\n    0x02c3a710, 0xa748371e, 0x1607aa4a, 0xb38c3a44, 0x86618c17,\n    0x23ea1c19, 0xedbae0b1, 0x483170bf, 0x7ddcc6ec, 0xd85756e2,\n    0x3a0c39fd, 0x9f87a9f3, 0xaa6a1fa0, 0x0fe18fae, 0xc1b17306,\n    0x643ae308, 0x51d7555b, 0xf45cc555, 0x4e108d24, 0xeb9b1d2a,\n    0xde76ab79, 0x7bfd3b77, 0xb5adc7df, 0x102657d1, 0x25cbe182,\n    0x8040718c, 0x621b1e93, 0xc7908e9d, 0xf27d38ce, 0x57f6a8c0,\n    0x99a65468, 0x3c2dc466, 0x09c07235, 0xac4be23b, 0xa629e496,\n    0x03a27498, 0x364fc2cb, 0x93c452c5, 0x5d94ae6d, 0xf81f3e63,\n    0xcdf28830, 0x6879183e, 0x8a227721, 0x2fa9e72f, 0x1a44517c,\n    0xbfcfc172, 0x719f3dda, 0xd414add4, 0xe1f91b87, 0x44728b89,\n    0xfe3ec3f8, 0x5bb553f6, 0x6e58e5a5, 0xcbd375ab, 0x05838903,\n    0xa008190d, 0x95e5af5e, 0x306e3f50, 0xd235504f, 0x77bec041,\n    0x42537612, 0xe7d8e61c, 0x29881ab4, 0x8c038aba, 0xb9ee3ce9,\n    0x1c65ace7}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0x0e908ba500000000, 0x5d26669000000000,\n    0x53b6ed3500000000, 0xfb4abdfb00000000, 0xf5da365e00000000,\n    0xa66cdb6b00000000, 0xa8fc50ce00000000, 0xb7930b2c00000000,\n    0xb903808900000000, 0xeab56dbc00000000, 0xe425e61900000000,\n    0x4cd9b6d700000000, 0x42493d7200000000, 0x11ffd04700000000,\n    0x1f6f5be200000000, 0x6e27175800000000, 0x60b79cfd00000000,\n    0x330171c800000000, 0x3d91fa6d00000000, 0x956daaa300000000,\n    0x9bfd210600000000, 0xc84bcc3300000000, 0xc6db479600000000,\n    0xd9b41c7400000000, 0xd72497d100000000, 0x84927ae400000000,\n    0x8a02f14100000000, 0x22fea18f00000000, 0x2c6e2a2a00000000,\n    0x7fd8c71f00000000, 0x71484cba00000000, 0xdc4e2eb000000000,\n    0xd2dea51500000000, 0x8168482000000000, 0x8ff8c38500000000,\n    0x2704934b00000000, 0x299418ee00000000, 0x7a22f5db00000000,\n    0x74b27e7e00000000, 0x6bdd259c00000000, 0x654dae3900000000,\n    0x36fb430c00000000, 0x386bc8a900000000, 0x9097986700000000,\n    0x9e0713c200000000, 0xcdb1fef700000000, 0xc321755200000000,\n    0xb26939e800000000, 0xbcf9b24d00000000, 0xef4f5f7800000000,\n    0xe1dfd4dd00000000, 0x4923841300000000, 0x47b30fb600000000,\n    0x1405e28300000000, 0x1a95692600000000, 0x05fa32c400000000,\n    0x0b6ab96100000000, 0x58dc545400000000, 0x564cdff100000000,\n    0xfeb08f3f00000000, 0xf020049a00000000, 0xa396e9af00000000,\n    0xad06620a00000000, 0xf99b2dbb00000000, 0xf70ba61e00000000,\n    0xa4bd4b2b00000000, 0xaa2dc08e00000000, 0x02d1904000000000,\n    0x0c411be500000000, 0x5ff7f6d000000000, 0x51677d7500000000,\n    0x4e08269700000000, 0x4098ad3200000000, 0x132e400700000000,\n    0x1dbecba200000000, 0xb5429b6c00000000, 0xbbd210c900000000,\n    0xe864fdfc00000000, 0xe6f4765900000000, 0x97bc3ae300000000,\n    0x992cb14600000000, 0xca9a5c7300000000, 0xc40ad7d600000000,\n    0x6cf6871800000000, 0x62660cbd00000000, 0x31d0e18800000000,\n    0x3f406a2d00000000, 0x202f31cf00000000, 0x2ebfba6a00000000,\n    0x7d09575f00000000, 0x7399dcfa00000000, 0xdb658c3400000000,\n    0xd5f5079100000000, 0x8643eaa400000000, 0x88d3610100000000,\n    0x25d5030b00000000, 0x2b4588ae00000000, 0x78f3659b00000000,\n    0x7663ee3e00000000, 0xde9fbef000000000, 0xd00f355500000000,\n    0x83b9d86000000000, 0x8d2953c500000000, 0x9246082700000000,\n    0x9cd6838200000000, 0xcf606eb700000000, 0xc1f0e51200000000,\n    0x690cb5dc00000000, 0x679c3e7900000000, 0x342ad34c00000000,\n    0x3aba58e900000000, 0x4bf2145300000000, 0x45629ff600000000,\n    0x16d472c300000000, 0x1844f96600000000, 0xb0b8a9a800000000,\n    0xbe28220d00000000, 0xed9ecf3800000000, 0xe30e449d00000000,\n    0xfc611f7f00000000, 0xf2f194da00000000, 0xa14779ef00000000,\n    0xafd7f24a00000000, 0x072ba28400000000, 0x09bb292100000000,\n    0x5a0dc41400000000, 0x549d4fb100000000, 0xb3312aad00000000,\n    0xbda1a10800000000, 0xee174c3d00000000, 0xe087c79800000000,\n    0x487b975600000000, 0x46eb1cf300000000, 0x155df1c600000000,\n    0x1bcd7a6300000000, 0x04a2218100000000, 0x0a32aa2400000000,\n    0x5984471100000000, 0x5714ccb400000000, 0xffe89c7a00000000,\n    0xf17817df00000000, 0xa2cefaea00000000, 0xac5e714f00000000,\n    0xdd163df500000000, 0xd386b65000000000, 0x80305b6500000000,\n    0x8ea0d0c000000000, 0x265c800e00000000, 0x28cc0bab00000000,\n    0x7b7ae69e00000000, 0x75ea6d3b00000000, 0x6a8536d900000000,\n    0x6415bd7c00000000, 0x37a3504900000000, 0x3933dbec00000000,\n    0x91cf8b2200000000, 0x9f5f008700000000, 0xcce9edb200000000,\n    0xc279661700000000, 0x6f7f041d00000000, 0x61ef8fb800000000,\n    0x3259628d00000000, 0x3cc9e92800000000, 0x9435b9e600000000,\n    0x9aa5324300000000, 0xc913df7600000000, 0xc78354d300000000,\n    0xd8ec0f3100000000, 0xd67c849400000000, 0x85ca69a100000000,\n    0x8b5ae20400000000, 0x23a6b2ca00000000, 0x2d36396f00000000,\n    0x7e80d45a00000000, 0x70105fff00000000, 0x0158134500000000,\n    0x0fc898e000000000, 0x5c7e75d500000000, 0x52eefe7000000000,\n    0xfa12aebe00000000, 0xf482251b00000000, 0xa734c82e00000000,\n    0xa9a4438b00000000, 0xb6cb186900000000, 0xb85b93cc00000000,\n    0xebed7ef900000000, 0xe57df55c00000000, 0x4d81a59200000000,\n    0x43112e3700000000, 0x10a7c30200000000, 0x1e3748a700000000,\n    0x4aaa071600000000, 0x443a8cb300000000, 0x178c618600000000,\n    0x191cea2300000000, 0xb1e0baed00000000, 0xbf70314800000000,\n    0xecc6dc7d00000000, 0xe25657d800000000, 0xfd390c3a00000000,\n    0xf3a9879f00000000, 0xa01f6aaa00000000, 0xae8fe10f00000000,\n    0x0673b1c100000000, 0x08e33a6400000000, 0x5b55d75100000000,\n    0x55c55cf400000000, 0x248d104e00000000, 0x2a1d9beb00000000,\n    0x79ab76de00000000, 0x773bfd7b00000000, 0xdfc7adb500000000,\n    0xd157261000000000, 0x82e1cb2500000000, 0x8c71408000000000,\n    0x931e1b6200000000, 0x9d8e90c700000000, 0xce387df200000000,\n    0xc0a8f65700000000, 0x6854a69900000000, 0x66c42d3c00000000,\n    0x3572c00900000000, 0x3be24bac00000000, 0x96e429a600000000,\n    0x9874a20300000000, 0xcbc24f3600000000, 0xc552c49300000000,\n    0x6dae945d00000000, 0x633e1ff800000000, 0x3088f2cd00000000,\n    0x3e18796800000000, 0x2177228a00000000, 0x2fe7a92f00000000,\n    0x7c51441a00000000, 0x72c1cfbf00000000, 0xda3d9f7100000000,\n    0xd4ad14d400000000, 0x871bf9e100000000, 0x898b724400000000,\n    0xf8c33efe00000000, 0xf653b55b00000000, 0xa5e5586e00000000,\n    0xab75d3cb00000000, 0x0389830500000000, 0x0d1908a000000000,\n    0x5eafe59500000000, 0x503f6e3000000000, 0x4f5035d200000000,\n    0x41c0be7700000000, 0x1276534200000000, 0x1ce6d8e700000000,\n    0xb41a882900000000, 0xba8a038c00000000, 0xe93ceeb900000000,\n    0xe7ac651c00000000},\n   {0x0000000000000000, 0x97a61de700000000, 0x6f4b4a1500000000,\n    0xf8ed57f200000000, 0xde96942a00000000, 0x493089cd00000000,\n    0xb1ddde3f00000000, 0x267bc3d800000000, 0xbc2d295500000000,\n    0x2b8b34b200000000, 0xd366634000000000, 0x44c07ea700000000,\n    0x62bbbd7f00000000, 0xf51da09800000000, 0x0df0f76a00000000,\n    0x9a56ea8d00000000, 0x785b52aa00000000, 0xeffd4f4d00000000,\n    0x171018bf00000000, 0x80b6055800000000, 0xa6cdc68000000000,\n    0x316bdb6700000000, 0xc9868c9500000000, 0x5e20917200000000,\n    0xc4767bff00000000, 0x53d0661800000000, 0xab3d31ea00000000,\n    0x3c9b2c0d00000000, 0x1ae0efd500000000, 0x8d46f23200000000,\n    0x75aba5c000000000, 0xe20db82700000000, 0xb1b0d58f00000000,\n    0x2616c86800000000, 0xdefb9f9a00000000, 0x495d827d00000000,\n    0x6f2641a500000000, 0xf8805c4200000000, 0x006d0bb000000000,\n    0x97cb165700000000, 0x0d9dfcda00000000, 0x9a3be13d00000000,\n    0x62d6b6cf00000000, 0xf570ab2800000000, 0xd30b68f000000000,\n    0x44ad751700000000, 0xbc4022e500000000, 0x2be63f0200000000,\n    0xc9eb872500000000, 0x5e4d9ac200000000, 0xa6a0cd3000000000,\n    0x3106d0d700000000, 0x177d130f00000000, 0x80db0ee800000000,\n    0x7836591a00000000, 0xef9044fd00000000, 0x75c6ae7000000000,\n    0xe260b39700000000, 0x1a8de46500000000, 0x8d2bf98200000000,\n    0xab503a5a00000000, 0x3cf627bd00000000, 0xc41b704f00000000,\n    0x53bd6da800000000, 0x2367dac400000000, 0xb4c1c72300000000,\n    0x4c2c90d100000000, 0xdb8a8d3600000000, 0xfdf14eee00000000,\n    0x6a57530900000000, 0x92ba04fb00000000, 0x051c191c00000000,\n    0x9f4af39100000000, 0x08ecee7600000000, 0xf001b98400000000,\n    0x67a7a46300000000, 0x41dc67bb00000000, 0xd67a7a5c00000000,\n    0x2e972dae00000000, 0xb931304900000000, 0x5b3c886e00000000,\n    0xcc9a958900000000, 0x3477c27b00000000, 0xa3d1df9c00000000,\n    0x85aa1c4400000000, 0x120c01a300000000, 0xeae1565100000000,\n    0x7d474bb600000000, 0xe711a13b00000000, 0x70b7bcdc00000000,\n    0x885aeb2e00000000, 0x1ffcf6c900000000, 0x3987351100000000,\n    0xae2128f600000000, 0x56cc7f0400000000, 0xc16a62e300000000,\n    0x92d70f4b00000000, 0x057112ac00000000, 0xfd9c455e00000000,\n    0x6a3a58b900000000, 0x4c419b6100000000, 0xdbe7868600000000,\n    0x230ad17400000000, 0xb4accc9300000000, 0x2efa261e00000000,\n    0xb95c3bf900000000, 0x41b16c0b00000000, 0xd61771ec00000000,\n    0xf06cb23400000000, 0x67caafd300000000, 0x9f27f82100000000,\n    0x0881e5c600000000, 0xea8c5de100000000, 0x7d2a400600000000,\n    0x85c717f400000000, 0x12610a1300000000, 0x341ac9cb00000000,\n    0xa3bcd42c00000000, 0x5b5183de00000000, 0xccf79e3900000000,\n    0x56a174b400000000, 0xc107695300000000, 0x39ea3ea100000000,\n    0xae4c234600000000, 0x8837e09e00000000, 0x1f91fd7900000000,\n    0xe77caa8b00000000, 0x70dab76c00000000, 0x07c8c55200000000,\n    0x906ed8b500000000, 0x68838f4700000000, 0xff2592a000000000,\n    0xd95e517800000000, 0x4ef84c9f00000000, 0xb6151b6d00000000,\n    0x21b3068a00000000, 0xbbe5ec0700000000, 0x2c43f1e000000000,\n    0xd4aea61200000000, 0x4308bbf500000000, 0x6573782d00000000,\n    0xf2d565ca00000000, 0x0a38323800000000, 0x9d9e2fdf00000000,\n    0x7f9397f800000000, 0xe8358a1f00000000, 0x10d8dded00000000,\n    0x877ec00a00000000, 0xa10503d200000000, 0x36a31e3500000000,\n    0xce4e49c700000000, 0x59e8542000000000, 0xc3bebead00000000,\n    0x5418a34a00000000, 0xacf5f4b800000000, 0x3b53e95f00000000,\n    0x1d282a8700000000, 0x8a8e376000000000, 0x7263609200000000,\n    0xe5c57d7500000000, 0xb67810dd00000000, 0x21de0d3a00000000,\n    0xd9335ac800000000, 0x4e95472f00000000, 0x68ee84f700000000,\n    0xff48991000000000, 0x07a5cee200000000, 0x9003d30500000000,\n    0x0a55398800000000, 0x9df3246f00000000, 0x651e739d00000000,\n    0xf2b86e7a00000000, 0xd4c3ada200000000, 0x4365b04500000000,\n    0xbb88e7b700000000, 0x2c2efa5000000000, 0xce23427700000000,\n    0x59855f9000000000, 0xa168086200000000, 0x36ce158500000000,\n    0x10b5d65d00000000, 0x8713cbba00000000, 0x7ffe9c4800000000,\n    0xe85881af00000000, 0x720e6b2200000000, 0xe5a876c500000000,\n    0x1d45213700000000, 0x8ae33cd000000000, 0xac98ff0800000000,\n    0x3b3ee2ef00000000, 0xc3d3b51d00000000, 0x5475a8fa00000000,\n    0x24af1f9600000000, 0xb309027100000000, 0x4be4558300000000,\n    0xdc42486400000000, 0xfa398bbc00000000, 0x6d9f965b00000000,\n    0x9572c1a900000000, 0x02d4dc4e00000000, 0x988236c300000000,\n    0x0f242b2400000000, 0xf7c97cd600000000, 0x606f613100000000,\n    0x4614a2e900000000, 0xd1b2bf0e00000000, 0x295fe8fc00000000,\n    0xbef9f51b00000000, 0x5cf44d3c00000000, 0xcb5250db00000000,\n    0x33bf072900000000, 0xa4191ace00000000, 0x8262d91600000000,\n    0x15c4c4f100000000, 0xed29930300000000, 0x7a8f8ee400000000,\n    0xe0d9646900000000, 0x777f798e00000000, 0x8f922e7c00000000,\n    0x1834339b00000000, 0x3e4ff04300000000, 0xa9e9eda400000000,\n    0x5104ba5600000000, 0xc6a2a7b100000000, 0x951fca1900000000,\n    0x02b9d7fe00000000, 0xfa54800c00000000, 0x6df29deb00000000,\n    0x4b895e3300000000, 0xdc2f43d400000000, 0x24c2142600000000,\n    0xb36409c100000000, 0x2932e34c00000000, 0xbe94feab00000000,\n    0x4679a95900000000, 0xd1dfb4be00000000, 0xf7a4776600000000,\n    0x60026a8100000000, 0x98ef3d7300000000, 0x0f49209400000000,\n    0xed4498b300000000, 0x7ae2855400000000, 0x820fd2a600000000,\n    0x15a9cf4100000000, 0x33d20c9900000000, 0xa474117e00000000,\n    0x5c99468c00000000, 0xcb3f5b6b00000000, 0x5169b1e600000000,\n    0xc6cfac0100000000, 0x3e22fbf300000000, 0xa984e61400000000,\n    0x8fff25cc00000000, 0x1859382b00000000, 0xe0b46fd900000000,\n    0x7712723e00000000},\n   {0x0000000000000000, 0x411b8c6e00000000, 0x823618dd00000000,\n    0xc32d94b300000000, 0x456b416100000000, 0x0470cd0f00000000,\n    0xc75d59bc00000000, 0x8646d5d200000000, 0x8ad682c200000000,\n    0xcbcd0eac00000000, 0x08e09a1f00000000, 0x49fb167100000000,\n    0xcfbdc3a300000000, 0x8ea64fcd00000000, 0x4d8bdb7e00000000,\n    0x0c90571000000000, 0x55ab745e00000000, 0x14b0f83000000000,\n    0xd79d6c8300000000, 0x9686e0ed00000000, 0x10c0353f00000000,\n    0x51dbb95100000000, 0x92f62de200000000, 0xd3eda18c00000000,\n    0xdf7df69c00000000, 0x9e667af200000000, 0x5d4bee4100000000,\n    0x1c50622f00000000, 0x9a16b7fd00000000, 0xdb0d3b9300000000,\n    0x1820af2000000000, 0x593b234e00000000, 0xaa56e9bc00000000,\n    0xeb4d65d200000000, 0x2860f16100000000, 0x697b7d0f00000000,\n    0xef3da8dd00000000, 0xae2624b300000000, 0x6d0bb00000000000,\n    0x2c103c6e00000000, 0x20806b7e00000000, 0x619be71000000000,\n    0xa2b673a300000000, 0xe3adffcd00000000, 0x65eb2a1f00000000,\n    0x24f0a67100000000, 0xe7dd32c200000000, 0xa6c6beac00000000,\n    0xfffd9de200000000, 0xbee6118c00000000, 0x7dcb853f00000000,\n    0x3cd0095100000000, 0xba96dc8300000000, 0xfb8d50ed00000000,\n    0x38a0c45e00000000, 0x79bb483000000000, 0x752b1f2000000000,\n    0x3430934e00000000, 0xf71d07fd00000000, 0xb6068b9300000000,\n    0x30405e4100000000, 0x715bd22f00000000, 0xb276469c00000000,\n    0xf36dcaf200000000, 0x15aba3a200000000, 0x54b02fcc00000000,\n    0x979dbb7f00000000, 0xd686371100000000, 0x50c0e2c300000000,\n    0x11db6ead00000000, 0xd2f6fa1e00000000, 0x93ed767000000000,\n    0x9f7d216000000000, 0xde66ad0e00000000, 0x1d4b39bd00000000,\n    0x5c50b5d300000000, 0xda16600100000000, 0x9b0dec6f00000000,\n    0x582078dc00000000, 0x193bf4b200000000, 0x4000d7fc00000000,\n    0x011b5b9200000000, 0xc236cf2100000000, 0x832d434f00000000,\n    0x056b969d00000000, 0x44701af300000000, 0x875d8e4000000000,\n    0xc646022e00000000, 0xcad6553e00000000, 0x8bcdd95000000000,\n    0x48e04de300000000, 0x09fbc18d00000000, 0x8fbd145f00000000,\n    0xcea6983100000000, 0x0d8b0c8200000000, 0x4c9080ec00000000,\n    0xbffd4a1e00000000, 0xfee6c67000000000, 0x3dcb52c300000000,\n    0x7cd0dead00000000, 0xfa960b7f00000000, 0xbb8d871100000000,\n    0x78a013a200000000, 0x39bb9fcc00000000, 0x352bc8dc00000000,\n    0x743044b200000000, 0xb71dd00100000000, 0xf6065c6f00000000,\n    0x704089bd00000000, 0x315b05d300000000, 0xf276916000000000,\n    0xb36d1d0e00000000, 0xea563e4000000000, 0xab4db22e00000000,\n    0x6860269d00000000, 0x297baaf300000000, 0xaf3d7f2100000000,\n    0xee26f34f00000000, 0x2d0b67fc00000000, 0x6c10eb9200000000,\n    0x6080bc8200000000, 0x219b30ec00000000, 0xe2b6a45f00000000,\n    0xa3ad283100000000, 0x25ebfde300000000, 0x64f0718d00000000,\n    0xa7dde53e00000000, 0xe6c6695000000000, 0x6b50369e00000000,\n    0x2a4bbaf000000000, 0xe9662e4300000000, 0xa87da22d00000000,\n    0x2e3b77ff00000000, 0x6f20fb9100000000, 0xac0d6f2200000000,\n    0xed16e34c00000000, 0xe186b45c00000000, 0xa09d383200000000,\n    0x63b0ac8100000000, 0x22ab20ef00000000, 0xa4edf53d00000000,\n    0xe5f6795300000000, 0x26dbede000000000, 0x67c0618e00000000,\n    0x3efb42c000000000, 0x7fe0ceae00000000, 0xbccd5a1d00000000,\n    0xfdd6d67300000000, 0x7b9003a100000000, 0x3a8b8fcf00000000,\n    0xf9a61b7c00000000, 0xb8bd971200000000, 0xb42dc00200000000,\n    0xf5364c6c00000000, 0x361bd8df00000000, 0x770054b100000000,\n    0xf146816300000000, 0xb05d0d0d00000000, 0x737099be00000000,\n    0x326b15d000000000, 0xc106df2200000000, 0x801d534c00000000,\n    0x4330c7ff00000000, 0x022b4b9100000000, 0x846d9e4300000000,\n    0xc576122d00000000, 0x065b869e00000000, 0x47400af000000000,\n    0x4bd05de000000000, 0x0acbd18e00000000, 0xc9e6453d00000000,\n    0x88fdc95300000000, 0x0ebb1c8100000000, 0x4fa090ef00000000,\n    0x8c8d045c00000000, 0xcd96883200000000, 0x94adab7c00000000,\n    0xd5b6271200000000, 0x169bb3a100000000, 0x57803fcf00000000,\n    0xd1c6ea1d00000000, 0x90dd667300000000, 0x53f0f2c000000000,\n    0x12eb7eae00000000, 0x1e7b29be00000000, 0x5f60a5d000000000,\n    0x9c4d316300000000, 0xdd56bd0d00000000, 0x5b1068df00000000,\n    0x1a0be4b100000000, 0xd926700200000000, 0x983dfc6c00000000,\n    0x7efb953c00000000, 0x3fe0195200000000, 0xfccd8de100000000,\n    0xbdd6018f00000000, 0x3b90d45d00000000, 0x7a8b583300000000,\n    0xb9a6cc8000000000, 0xf8bd40ee00000000, 0xf42d17fe00000000,\n    0xb5369b9000000000, 0x761b0f2300000000, 0x3700834d00000000,\n    0xb146569f00000000, 0xf05ddaf100000000, 0x33704e4200000000,\n    0x726bc22c00000000, 0x2b50e16200000000, 0x6a4b6d0c00000000,\n    0xa966f9bf00000000, 0xe87d75d100000000, 0x6e3ba00300000000,\n    0x2f202c6d00000000, 0xec0db8de00000000, 0xad1634b000000000,\n    0xa18663a000000000, 0xe09defce00000000, 0x23b07b7d00000000,\n    0x62abf71300000000, 0xe4ed22c100000000, 0xa5f6aeaf00000000,\n    0x66db3a1c00000000, 0x27c0b67200000000, 0xd4ad7c8000000000,\n    0x95b6f0ee00000000, 0x569b645d00000000, 0x1780e83300000000,\n    0x91c63de100000000, 0xd0ddb18f00000000, 0x13f0253c00000000,\n    0x52eba95200000000, 0x5e7bfe4200000000, 0x1f60722c00000000,\n    0xdc4de69f00000000, 0x9d566af100000000, 0x1b10bf2300000000,\n    0x5a0b334d00000000, 0x9926a7fe00000000, 0xd83d2b9000000000,\n    0x810608de00000000, 0xc01d84b000000000, 0x0330100300000000,\n    0x422b9c6d00000000, 0xc46d49bf00000000, 0x8576c5d100000000,\n    0x465b516200000000, 0x0740dd0c00000000, 0x0bd08a1c00000000,\n    0x4acb067200000000, 0x89e692c100000000, 0xc8fd1eaf00000000,\n    0x4ebbcb7d00000000, 0x0fa0471300000000, 0xcc8dd3a000000000,\n    0x8d965fce00000000},\n   {0x0000000000000000, 0x1dfdb50100000000, 0x3afa6b0300000000,\n    0x2707de0200000000, 0x74f4d70600000000, 0x6909620700000000,\n    0x4e0ebc0500000000, 0x53f3090400000000, 0xe8e8af0d00000000,\n    0xf5151a0c00000000, 0xd212c40e00000000, 0xcfef710f00000000,\n    0x9c1c780b00000000, 0x81e1cd0a00000000, 0xa6e6130800000000,\n    0xbb1ba60900000000, 0xd0d15f1b00000000, 0xcd2cea1a00000000,\n    0xea2b341800000000, 0xf7d6811900000000, 0xa425881d00000000,\n    0xb9d83d1c00000000, 0x9edfe31e00000000, 0x8322561f00000000,\n    0x3839f01600000000, 0x25c4451700000000, 0x02c39b1500000000,\n    0x1f3e2e1400000000, 0x4ccd271000000000, 0x5130921100000000,\n    0x76374c1300000000, 0x6bcaf91200000000, 0xa0a3bf3600000000,\n    0xbd5e0a3700000000, 0x9a59d43500000000, 0x87a4613400000000,\n    0xd457683000000000, 0xc9aadd3100000000, 0xeead033300000000,\n    0xf350b63200000000, 0x484b103b00000000, 0x55b6a53a00000000,\n    0x72b17b3800000000, 0x6f4cce3900000000, 0x3cbfc73d00000000,\n    0x2142723c00000000, 0x0645ac3e00000000, 0x1bb8193f00000000,\n    0x7072e02d00000000, 0x6d8f552c00000000, 0x4a888b2e00000000,\n    0x57753e2f00000000, 0x0486372b00000000, 0x197b822a00000000,\n    0x3e7c5c2800000000, 0x2381e92900000000, 0x989a4f2000000000,\n    0x8567fa2100000000, 0xa260242300000000, 0xbf9d912200000000,\n    0xec6e982600000000, 0xf1932d2700000000, 0xd694f32500000000,\n    0xcb69462400000000, 0x40477f6d00000000, 0x5dbaca6c00000000,\n    0x7abd146e00000000, 0x6740a16f00000000, 0x34b3a86b00000000,\n    0x294e1d6a00000000, 0x0e49c36800000000, 0x13b4766900000000,\n    0xa8afd06000000000, 0xb552656100000000, 0x9255bb6300000000,\n    0x8fa80e6200000000, 0xdc5b076600000000, 0xc1a6b26700000000,\n    0xe6a16c6500000000, 0xfb5cd96400000000, 0x9096207600000000,\n    0x8d6b957700000000, 0xaa6c4b7500000000, 0xb791fe7400000000,\n    0xe462f77000000000, 0xf99f427100000000, 0xde989c7300000000,\n    0xc365297200000000, 0x787e8f7b00000000, 0x65833a7a00000000,\n    0x4284e47800000000, 0x5f79517900000000, 0x0c8a587d00000000,\n    0x1177ed7c00000000, 0x3670337e00000000, 0x2b8d867f00000000,\n    0xe0e4c05b00000000, 0xfd19755a00000000, 0xda1eab5800000000,\n    0xc7e31e5900000000, 0x9410175d00000000, 0x89eda25c00000000,\n    0xaeea7c5e00000000, 0xb317c95f00000000, 0x080c6f5600000000,\n    0x15f1da5700000000, 0x32f6045500000000, 0x2f0bb15400000000,\n    0x7cf8b85000000000, 0x61050d5100000000, 0x4602d35300000000,\n    0x5bff665200000000, 0x30359f4000000000, 0x2dc82a4100000000,\n    0x0acff44300000000, 0x1732414200000000, 0x44c1484600000000,\n    0x593cfd4700000000, 0x7e3b234500000000, 0x63c6964400000000,\n    0xd8dd304d00000000, 0xc520854c00000000, 0xe2275b4e00000000,\n    0xffdaee4f00000000, 0xac29e74b00000000, 0xb1d4524a00000000,\n    0x96d38c4800000000, 0x8b2e394900000000, 0x808efeda00000000,\n    0x9d734bdb00000000, 0xba7495d900000000, 0xa78920d800000000,\n    0xf47a29dc00000000, 0xe9879cdd00000000, 0xce8042df00000000,\n    0xd37df7de00000000, 0x686651d700000000, 0x759be4d600000000,\n    0x529c3ad400000000, 0x4f618fd500000000, 0x1c9286d100000000,\n    0x016f33d000000000, 0x2668edd200000000, 0x3b9558d300000000,\n    0x505fa1c100000000, 0x4da214c000000000, 0x6aa5cac200000000,\n    0x77587fc300000000, 0x24ab76c700000000, 0x3956c3c600000000,\n    0x1e511dc400000000, 0x03aca8c500000000, 0xb8b70ecc00000000,\n    0xa54abbcd00000000, 0x824d65cf00000000, 0x9fb0d0ce00000000,\n    0xcc43d9ca00000000, 0xd1be6ccb00000000, 0xf6b9b2c900000000,\n    0xeb4407c800000000, 0x202d41ec00000000, 0x3dd0f4ed00000000,\n    0x1ad72aef00000000, 0x072a9fee00000000, 0x54d996ea00000000,\n    0x492423eb00000000, 0x6e23fde900000000, 0x73de48e800000000,\n    0xc8c5eee100000000, 0xd5385be000000000, 0xf23f85e200000000,\n    0xefc230e300000000, 0xbc3139e700000000, 0xa1cc8ce600000000,\n    0x86cb52e400000000, 0x9b36e7e500000000, 0xf0fc1ef700000000,\n    0xed01abf600000000, 0xca0675f400000000, 0xd7fbc0f500000000,\n    0x8408c9f100000000, 0x99f57cf000000000, 0xbef2a2f200000000,\n    0xa30f17f300000000, 0x1814b1fa00000000, 0x05e904fb00000000,\n    0x22eedaf900000000, 0x3f136ff800000000, 0x6ce066fc00000000,\n    0x711dd3fd00000000, 0x561a0dff00000000, 0x4be7b8fe00000000,\n    0xc0c981b700000000, 0xdd3434b600000000, 0xfa33eab400000000,\n    0xe7ce5fb500000000, 0xb43d56b100000000, 0xa9c0e3b000000000,\n    0x8ec73db200000000, 0x933a88b300000000, 0x28212eba00000000,\n    0x35dc9bbb00000000, 0x12db45b900000000, 0x0f26f0b800000000,\n    0x5cd5f9bc00000000, 0x41284cbd00000000, 0x662f92bf00000000,\n    0x7bd227be00000000, 0x1018deac00000000, 0x0de56bad00000000,\n    0x2ae2b5af00000000, 0x371f00ae00000000, 0x64ec09aa00000000,\n    0x7911bcab00000000, 0x5e1662a900000000, 0x43ebd7a800000000,\n    0xf8f071a100000000, 0xe50dc4a000000000, 0xc20a1aa200000000,\n    0xdff7afa300000000, 0x8c04a6a700000000, 0x91f913a600000000,\n    0xb6fecda400000000, 0xab0378a500000000, 0x606a3e8100000000,\n    0x7d978b8000000000, 0x5a90558200000000, 0x476de08300000000,\n    0x149ee98700000000, 0x09635c8600000000, 0x2e64828400000000,\n    0x3399378500000000, 0x8882918c00000000, 0x957f248d00000000,\n    0xb278fa8f00000000, 0xaf854f8e00000000, 0xfc76468a00000000,\n    0xe18bf38b00000000, 0xc68c2d8900000000, 0xdb71988800000000,\n    0xb0bb619a00000000, 0xad46d49b00000000, 0x8a410a9900000000,\n    0x97bcbf9800000000, 0xc44fb69c00000000, 0xd9b2039d00000000,\n    0xfeb5dd9f00000000, 0xe348689e00000000, 0x5853ce9700000000,\n    0x45ae7b9600000000, 0x62a9a59400000000, 0x7f54109500000000,\n    0x2ca7199100000000, 0x315aac9000000000, 0x165d729200000000,\n    0x0ba0c79300000000},\n   {0x0000000000000000, 0x24d9076300000000, 0x48b20fc600000000,\n    0x6c6b08a500000000, 0xd1626e5700000000, 0xf5bb693400000000,\n    0x99d0619100000000, 0xbd0966f200000000, 0xa2c5dcae00000000,\n    0x861cdbcd00000000, 0xea77d36800000000, 0xceaed40b00000000,\n    0x73a7b2f900000000, 0x577eb59a00000000, 0x3b15bd3f00000000,\n    0x1fccba5c00000000, 0x058dc88600000000, 0x2154cfe500000000,\n    0x4d3fc74000000000, 0x69e6c02300000000, 0xd4efa6d100000000,\n    0xf036a1b200000000, 0x9c5da91700000000, 0xb884ae7400000000,\n    0xa748142800000000, 0x8391134b00000000, 0xeffa1bee00000000,\n    0xcb231c8d00000000, 0x762a7a7f00000000, 0x52f37d1c00000000,\n    0x3e9875b900000000, 0x1a4172da00000000, 0x4b1ce0d600000000,\n    0x6fc5e7b500000000, 0x03aeef1000000000, 0x2777e87300000000,\n    0x9a7e8e8100000000, 0xbea789e200000000, 0xd2cc814700000000,\n    0xf615862400000000, 0xe9d93c7800000000, 0xcd003b1b00000000,\n    0xa16b33be00000000, 0x85b234dd00000000, 0x38bb522f00000000,\n    0x1c62554c00000000, 0x70095de900000000, 0x54d05a8a00000000,\n    0x4e91285000000000, 0x6a482f3300000000, 0x0623279600000000,\n    0x22fa20f500000000, 0x9ff3460700000000, 0xbb2a416400000000,\n    0xd74149c100000000, 0xf3984ea200000000, 0xec54f4fe00000000,\n    0xc88df39d00000000, 0xa4e6fb3800000000, 0x803ffc5b00000000,\n    0x3d369aa900000000, 0x19ef9dca00000000, 0x7584956f00000000,\n    0x515d920c00000000, 0xd73eb17600000000, 0xf3e7b61500000000,\n    0x9f8cbeb000000000, 0xbb55b9d300000000, 0x065cdf2100000000,\n    0x2285d84200000000, 0x4eeed0e700000000, 0x6a37d78400000000,\n    0x75fb6dd800000000, 0x51226abb00000000, 0x3d49621e00000000,\n    0x1990657d00000000, 0xa499038f00000000, 0x804004ec00000000,\n    0xec2b0c4900000000, 0xc8f20b2a00000000, 0xd2b379f000000000,\n    0xf66a7e9300000000, 0x9a01763600000000, 0xbed8715500000000,\n    0x03d117a700000000, 0x270810c400000000, 0x4b63186100000000,\n    0x6fba1f0200000000, 0x7076a55e00000000, 0x54afa23d00000000,\n    0x38c4aa9800000000, 0x1c1dadfb00000000, 0xa114cb0900000000,\n    0x85cdcc6a00000000, 0xe9a6c4cf00000000, 0xcd7fc3ac00000000,\n    0x9c2251a000000000, 0xb8fb56c300000000, 0xd4905e6600000000,\n    0xf049590500000000, 0x4d403ff700000000, 0x6999389400000000,\n    0x05f2303100000000, 0x212b375200000000, 0x3ee78d0e00000000,\n    0x1a3e8a6d00000000, 0x765582c800000000, 0x528c85ab00000000,\n    0xef85e35900000000, 0xcb5ce43a00000000, 0xa737ec9f00000000,\n    0x83eeebfc00000000, 0x99af992600000000, 0xbd769e4500000000,\n    0xd11d96e000000000, 0xf5c4918300000000, 0x48cdf77100000000,\n    0x6c14f01200000000, 0x007ff8b700000000, 0x24a6ffd400000000,\n    0x3b6a458800000000, 0x1fb342eb00000000, 0x73d84a4e00000000,\n    0x57014d2d00000000, 0xea082bdf00000000, 0xced12cbc00000000,\n    0xa2ba241900000000, 0x8663237a00000000, 0xae7d62ed00000000,\n    0x8aa4658e00000000, 0xe6cf6d2b00000000, 0xc2166a4800000000,\n    0x7f1f0cba00000000, 0x5bc60bd900000000, 0x37ad037c00000000,\n    0x1374041f00000000, 0x0cb8be4300000000, 0x2861b92000000000,\n    0x440ab18500000000, 0x60d3b6e600000000, 0xdddad01400000000,\n    0xf903d77700000000, 0x9568dfd200000000, 0xb1b1d8b100000000,\n    0xabf0aa6b00000000, 0x8f29ad0800000000, 0xe342a5ad00000000,\n    0xc79ba2ce00000000, 0x7a92c43c00000000, 0x5e4bc35f00000000,\n    0x3220cbfa00000000, 0x16f9cc9900000000, 0x093576c500000000,\n    0x2dec71a600000000, 0x4187790300000000, 0x655e7e6000000000,\n    0xd857189200000000, 0xfc8e1ff100000000, 0x90e5175400000000,\n    0xb43c103700000000, 0xe561823b00000000, 0xc1b8855800000000,\n    0xadd38dfd00000000, 0x890a8a9e00000000, 0x3403ec6c00000000,\n    0x10daeb0f00000000, 0x7cb1e3aa00000000, 0x5868e4c900000000,\n    0x47a45e9500000000, 0x637d59f600000000, 0x0f16515300000000,\n    0x2bcf563000000000, 0x96c630c200000000, 0xb21f37a100000000,\n    0xde743f0400000000, 0xfaad386700000000, 0xe0ec4abd00000000,\n    0xc4354dde00000000, 0xa85e457b00000000, 0x8c87421800000000,\n    0x318e24ea00000000, 0x1557238900000000, 0x793c2b2c00000000,\n    0x5de52c4f00000000, 0x4229961300000000, 0x66f0917000000000,\n    0x0a9b99d500000000, 0x2e429eb600000000, 0x934bf84400000000,\n    0xb792ff2700000000, 0xdbf9f78200000000, 0xff20f0e100000000,\n    0x7943d39b00000000, 0x5d9ad4f800000000, 0x31f1dc5d00000000,\n    0x1528db3e00000000, 0xa821bdcc00000000, 0x8cf8baaf00000000,\n    0xe093b20a00000000, 0xc44ab56900000000, 0xdb860f3500000000,\n    0xff5f085600000000, 0x933400f300000000, 0xb7ed079000000000,\n    0x0ae4616200000000, 0x2e3d660100000000, 0x42566ea400000000,\n    0x668f69c700000000, 0x7cce1b1d00000000, 0x58171c7e00000000,\n    0x347c14db00000000, 0x10a513b800000000, 0xadac754a00000000,\n    0x8975722900000000, 0xe51e7a8c00000000, 0xc1c77def00000000,\n    0xde0bc7b300000000, 0xfad2c0d000000000, 0x96b9c87500000000,\n    0xb260cf1600000000, 0x0f69a9e400000000, 0x2bb0ae8700000000,\n    0x47dba62200000000, 0x6302a14100000000, 0x325f334d00000000,\n    0x1686342e00000000, 0x7aed3c8b00000000, 0x5e343be800000000,\n    0xe33d5d1a00000000, 0xc7e45a7900000000, 0xab8f52dc00000000,\n    0x8f5655bf00000000, 0x909aefe300000000, 0xb443e88000000000,\n    0xd828e02500000000, 0xfcf1e74600000000, 0x41f881b400000000,\n    0x652186d700000000, 0x094a8e7200000000, 0x2d93891100000000,\n    0x37d2fbcb00000000, 0x130bfca800000000, 0x7f60f40d00000000,\n    0x5bb9f36e00000000, 0xe6b0959c00000000, 0xc26992ff00000000,\n    0xae029a5a00000000, 0x8adb9d3900000000, 0x9517276500000000,\n    0xb1ce200600000000, 0xdda528a300000000, 0xf97c2fc000000000,\n    0x4475493200000000, 0x60ac4e5100000000, 0x0cc746f400000000,\n    0x281e419700000000},\n   {0x0000000000000000, 0x08e3603c00000000, 0x10c6c17800000000,\n    0x1825a14400000000, 0x208c83f100000000, 0x286fe3cd00000000,\n    0x304a428900000000, 0x38a922b500000000, 0x011e763800000000,\n    0x09fd160400000000, 0x11d8b74000000000, 0x193bd77c00000000,\n    0x2192f5c900000000, 0x297195f500000000, 0x315434b100000000,\n    0x39b7548d00000000, 0x023cec7000000000, 0x0adf8c4c00000000,\n    0x12fa2d0800000000, 0x1a194d3400000000, 0x22b06f8100000000,\n    0x2a530fbd00000000, 0x3276aef900000000, 0x3a95cec500000000,\n    0x03229a4800000000, 0x0bc1fa7400000000, 0x13e45b3000000000,\n    0x1b073b0c00000000, 0x23ae19b900000000, 0x2b4d798500000000,\n    0x3368d8c100000000, 0x3b8bb8fd00000000, 0x0478d8e100000000,\n    0x0c9bb8dd00000000, 0x14be199900000000, 0x1c5d79a500000000,\n    0x24f45b1000000000, 0x2c173b2c00000000, 0x34329a6800000000,\n    0x3cd1fa5400000000, 0x0566aed900000000, 0x0d85cee500000000,\n    0x15a06fa100000000, 0x1d430f9d00000000, 0x25ea2d2800000000,\n    0x2d094d1400000000, 0x352cec5000000000, 0x3dcf8c6c00000000,\n    0x0644349100000000, 0x0ea754ad00000000, 0x1682f5e900000000,\n    0x1e6195d500000000, 0x26c8b76000000000, 0x2e2bd75c00000000,\n    0x360e761800000000, 0x3eed162400000000, 0x075a42a900000000,\n    0x0fb9229500000000, 0x179c83d100000000, 0x1f7fe3ed00000000,\n    0x27d6c15800000000, 0x2f35a16400000000, 0x3710002000000000,\n    0x3ff3601c00000000, 0x49f6c11800000000, 0x4115a12400000000,\n    0x5930006000000000, 0x51d3605c00000000, 0x697a42e900000000,\n    0x619922d500000000, 0x79bc839100000000, 0x715fe3ad00000000,\n    0x48e8b72000000000, 0x400bd71c00000000, 0x582e765800000000,\n    0x50cd166400000000, 0x686434d100000000, 0x608754ed00000000,\n    0x78a2f5a900000000, 0x7041959500000000, 0x4bca2d6800000000,\n    0x43294d5400000000, 0x5b0cec1000000000, 0x53ef8c2c00000000,\n    0x6b46ae9900000000, 0x63a5cea500000000, 0x7b806fe100000000,\n    0x73630fdd00000000, 0x4ad45b5000000000, 0x42373b6c00000000,\n    0x5a129a2800000000, 0x52f1fa1400000000, 0x6a58d8a100000000,\n    0x62bbb89d00000000, 0x7a9e19d900000000, 0x727d79e500000000,\n    0x4d8e19f900000000, 0x456d79c500000000, 0x5d48d88100000000,\n    0x55abb8bd00000000, 0x6d029a0800000000, 0x65e1fa3400000000,\n    0x7dc45b7000000000, 0x75273b4c00000000, 0x4c906fc100000000,\n    0x44730ffd00000000, 0x5c56aeb900000000, 0x54b5ce8500000000,\n    0x6c1cec3000000000, 0x64ff8c0c00000000, 0x7cda2d4800000000,\n    0x74394d7400000000, 0x4fb2f58900000000, 0x475195b500000000,\n    0x5f7434f100000000, 0x579754cd00000000, 0x6f3e767800000000,\n    0x67dd164400000000, 0x7ff8b70000000000, 0x771bd73c00000000,\n    0x4eac83b100000000, 0x464fe38d00000000, 0x5e6a42c900000000,\n    0x568922f500000000, 0x6e20004000000000, 0x66c3607c00000000,\n    0x7ee6c13800000000, 0x7605a10400000000, 0x92ec833100000000,\n    0x9a0fe30d00000000, 0x822a424900000000, 0x8ac9227500000000,\n    0xb26000c000000000, 0xba8360fc00000000, 0xa2a6c1b800000000,\n    0xaa45a18400000000, 0x93f2f50900000000, 0x9b11953500000000,\n    0x8334347100000000, 0x8bd7544d00000000, 0xb37e76f800000000,\n    0xbb9d16c400000000, 0xa3b8b78000000000, 0xab5bd7bc00000000,\n    0x90d06f4100000000, 0x98330f7d00000000, 0x8016ae3900000000,\n    0x88f5ce0500000000, 0xb05cecb000000000, 0xb8bf8c8c00000000,\n    0xa09a2dc800000000, 0xa8794df400000000, 0x91ce197900000000,\n    0x992d794500000000, 0x8108d80100000000, 0x89ebb83d00000000,\n    0xb1429a8800000000, 0xb9a1fab400000000, 0xa1845bf000000000,\n    0xa9673bcc00000000, 0x96945bd000000000, 0x9e773bec00000000,\n    0x86529aa800000000, 0x8eb1fa9400000000, 0xb618d82100000000,\n    0xbefbb81d00000000, 0xa6de195900000000, 0xae3d796500000000,\n    0x978a2de800000000, 0x9f694dd400000000, 0x874cec9000000000,\n    0x8faf8cac00000000, 0xb706ae1900000000, 0xbfe5ce2500000000,\n    0xa7c06f6100000000, 0xaf230f5d00000000, 0x94a8b7a000000000,\n    0x9c4bd79c00000000, 0x846e76d800000000, 0x8c8d16e400000000,\n    0xb424345100000000, 0xbcc7546d00000000, 0xa4e2f52900000000,\n    0xac01951500000000, 0x95b6c19800000000, 0x9d55a1a400000000,\n    0x857000e000000000, 0x8d9360dc00000000, 0xb53a426900000000,\n    0xbdd9225500000000, 0xa5fc831100000000, 0xad1fe32d00000000,\n    0xdb1a422900000000, 0xd3f9221500000000, 0xcbdc835100000000,\n    0xc33fe36d00000000, 0xfb96c1d800000000, 0xf375a1e400000000,\n    0xeb5000a000000000, 0xe3b3609c00000000, 0xda04341100000000,\n    0xd2e7542d00000000, 0xcac2f56900000000, 0xc221955500000000,\n    0xfa88b7e000000000, 0xf26bd7dc00000000, 0xea4e769800000000,\n    0xe2ad16a400000000, 0xd926ae5900000000, 0xd1c5ce6500000000,\n    0xc9e06f2100000000, 0xc1030f1d00000000, 0xf9aa2da800000000,\n    0xf1494d9400000000, 0xe96cecd000000000, 0xe18f8cec00000000,\n    0xd838d86100000000, 0xd0dbb85d00000000, 0xc8fe191900000000,\n    0xc01d792500000000, 0xf8b45b9000000000, 0xf0573bac00000000,\n    0xe8729ae800000000, 0xe091fad400000000, 0xdf629ac800000000,\n    0xd781faf400000000, 0xcfa45bb000000000, 0xc7473b8c00000000,\n    0xffee193900000000, 0xf70d790500000000, 0xef28d84100000000,\n    0xe7cbb87d00000000, 0xde7cecf000000000, 0xd69f8ccc00000000,\n    0xceba2d8800000000, 0xc6594db400000000, 0xfef06f0100000000,\n    0xf6130f3d00000000, 0xee36ae7900000000, 0xe6d5ce4500000000,\n    0xdd5e76b800000000, 0xd5bd168400000000, 0xcd98b7c000000000,\n    0xc57bd7fc00000000, 0xfdd2f54900000000, 0xf531957500000000,\n    0xed14343100000000, 0xe5f7540d00000000, 0xdc40008000000000,\n    0xd4a360bc00000000, 0xcc86c1f800000000, 0xc465a1c400000000,\n    0xfccc837100000000, 0xf42fe34d00000000, 0xec0a420900000000,\n    0xe4e9223500000000},\n   {0x0000000000000000, 0xd1e8e70e00000000, 0xa2d1cf1d00000000,\n    0x7339281300000000, 0x44a39f3b00000000, 0x954b783500000000,\n    0xe672502600000000, 0x379ab72800000000, 0x88463f7700000000,\n    0x59aed87900000000, 0x2a97f06a00000000, 0xfb7f176400000000,\n    0xcce5a04c00000000, 0x1d0d474200000000, 0x6e346f5100000000,\n    0xbfdc885f00000000, 0x108d7eee00000000, 0xc16599e000000000,\n    0xb25cb1f300000000, 0x63b456fd00000000, 0x542ee1d500000000,\n    0x85c606db00000000, 0xf6ff2ec800000000, 0x2717c9c600000000,\n    0x98cb419900000000, 0x4923a69700000000, 0x3a1a8e8400000000,\n    0xebf2698a00000000, 0xdc68dea200000000, 0x0d8039ac00000000,\n    0x7eb911bf00000000, 0xaf51f6b100000000, 0x611c8c0700000000,\n    0xb0f46b0900000000, 0xc3cd431a00000000, 0x1225a41400000000,\n    0x25bf133c00000000, 0xf457f43200000000, 0x876edc2100000000,\n    0x56863b2f00000000, 0xe95ab37000000000, 0x38b2547e00000000,\n    0x4b8b7c6d00000000, 0x9a639b6300000000, 0xadf92c4b00000000,\n    0x7c11cb4500000000, 0x0f28e35600000000, 0xdec0045800000000,\n    0x7191f2e900000000, 0xa07915e700000000, 0xd3403df400000000,\n    0x02a8dafa00000000, 0x35326dd200000000, 0xe4da8adc00000000,\n    0x97e3a2cf00000000, 0x460b45c100000000, 0xf9d7cd9e00000000,\n    0x283f2a9000000000, 0x5b06028300000000, 0x8aeee58d00000000,\n    0xbd7452a500000000, 0x6c9cb5ab00000000, 0x1fa59db800000000,\n    0xce4d7ab600000000, 0xc238180f00000000, 0x13d0ff0100000000,\n    0x60e9d71200000000, 0xb101301c00000000, 0x869b873400000000,\n    0x5773603a00000000, 0x244a482900000000, 0xf5a2af2700000000,\n    0x4a7e277800000000, 0x9b96c07600000000, 0xe8afe86500000000,\n    0x39470f6b00000000, 0x0eddb84300000000, 0xdf355f4d00000000,\n    0xac0c775e00000000, 0x7de4905000000000, 0xd2b566e100000000,\n    0x035d81ef00000000, 0x7064a9fc00000000, 0xa18c4ef200000000,\n    0x9616f9da00000000, 0x47fe1ed400000000, 0x34c736c700000000,\n    0xe52fd1c900000000, 0x5af3599600000000, 0x8b1bbe9800000000,\n    0xf822968b00000000, 0x29ca718500000000, 0x1e50c6ad00000000,\n    0xcfb821a300000000, 0xbc8109b000000000, 0x6d69eebe00000000,\n    0xa324940800000000, 0x72cc730600000000, 0x01f55b1500000000,\n    0xd01dbc1b00000000, 0xe7870b3300000000, 0x366fec3d00000000,\n    0x4556c42e00000000, 0x94be232000000000, 0x2b62ab7f00000000,\n    0xfa8a4c7100000000, 0x89b3646200000000, 0x585b836c00000000,\n    0x6fc1344400000000, 0xbe29d34a00000000, 0xcd10fb5900000000,\n    0x1cf81c5700000000, 0xb3a9eae600000000, 0x62410de800000000,\n    0x117825fb00000000, 0xc090c2f500000000, 0xf70a75dd00000000,\n    0x26e292d300000000, 0x55dbbac000000000, 0x84335dce00000000,\n    0x3befd59100000000, 0xea07329f00000000, 0x993e1a8c00000000,\n    0x48d6fd8200000000, 0x7f4c4aaa00000000, 0xaea4ada400000000,\n    0xdd9d85b700000000, 0x0c7562b900000000, 0x8471301e00000000,\n    0x5599d71000000000, 0x26a0ff0300000000, 0xf748180d00000000,\n    0xc0d2af2500000000, 0x113a482b00000000, 0x6203603800000000,\n    0xb3eb873600000000, 0x0c370f6900000000, 0xdddfe86700000000,\n    0xaee6c07400000000, 0x7f0e277a00000000, 0x4894905200000000,\n    0x997c775c00000000, 0xea455f4f00000000, 0x3badb84100000000,\n    0x94fc4ef000000000, 0x4514a9fe00000000, 0x362d81ed00000000,\n    0xe7c566e300000000, 0xd05fd1cb00000000, 0x01b736c500000000,\n    0x728e1ed600000000, 0xa366f9d800000000, 0x1cba718700000000,\n    0xcd52968900000000, 0xbe6bbe9a00000000, 0x6f83599400000000,\n    0x5819eebc00000000, 0x89f109b200000000, 0xfac821a100000000,\n    0x2b20c6af00000000, 0xe56dbc1900000000, 0x34855b1700000000,\n    0x47bc730400000000, 0x9654940a00000000, 0xa1ce232200000000,\n    0x7026c42c00000000, 0x031fec3f00000000, 0xd2f70b3100000000,\n    0x6d2b836e00000000, 0xbcc3646000000000, 0xcffa4c7300000000,\n    0x1e12ab7d00000000, 0x29881c5500000000, 0xf860fb5b00000000,\n    0x8b59d34800000000, 0x5ab1344600000000, 0xf5e0c2f700000000,\n    0x240825f900000000, 0x57310dea00000000, 0x86d9eae400000000,\n    0xb1435dcc00000000, 0x60abbac200000000, 0x139292d100000000,\n    0xc27a75df00000000, 0x7da6fd8000000000, 0xac4e1a8e00000000,\n    0xdf77329d00000000, 0x0e9fd59300000000, 0x390562bb00000000,\n    0xe8ed85b500000000, 0x9bd4ada600000000, 0x4a3c4aa800000000,\n    0x4649281100000000, 0x97a1cf1f00000000, 0xe498e70c00000000,\n    0x3570000200000000, 0x02eab72a00000000, 0xd302502400000000,\n    0xa03b783700000000, 0x71d39f3900000000, 0xce0f176600000000,\n    0x1fe7f06800000000, 0x6cded87b00000000, 0xbd363f7500000000,\n    0x8aac885d00000000, 0x5b446f5300000000, 0x287d474000000000,\n    0xf995a04e00000000, 0x56c456ff00000000, 0x872cb1f100000000,\n    0xf41599e200000000, 0x25fd7eec00000000, 0x1267c9c400000000,\n    0xc38f2eca00000000, 0xb0b606d900000000, 0x615ee1d700000000,\n    0xde82698800000000, 0x0f6a8e8600000000, 0x7c53a69500000000,\n    0xadbb419b00000000, 0x9a21f6b300000000, 0x4bc911bd00000000,\n    0x38f039ae00000000, 0xe918dea000000000, 0x2755a41600000000,\n    0xf6bd431800000000, 0x85846b0b00000000, 0x546c8c0500000000,\n    0x63f63b2d00000000, 0xb21edc2300000000, 0xc127f43000000000,\n    0x10cf133e00000000, 0xaf139b6100000000, 0x7efb7c6f00000000,\n    0x0dc2547c00000000, 0xdc2ab37200000000, 0xebb0045a00000000,\n    0x3a58e35400000000, 0x4961cb4700000000, 0x98892c4900000000,\n    0x37d8daf800000000, 0xe6303df600000000, 0x950915e500000000,\n    0x44e1f2eb00000000, 0x737b45c300000000, 0xa293a2cd00000000,\n    0xd1aa8ade00000000, 0x00426dd000000000, 0xbf9ee58f00000000,\n    0x6e76028100000000, 0x1d4f2a9200000000, 0xcca7cd9c00000000,\n    0xfb3d7ab400000000, 0x2ad59dba00000000, 0x59ecb5a900000000,\n    0x880452a700000000},\n   {0x0000000000000000, 0xaa05daf100000000, 0x150dc53800000000,\n    0xbf081fc900000000, 0x2a1a8a7100000000, 0x801f508000000000,\n    0x3f174f4900000000, 0x951295b800000000, 0x543414e300000000,\n    0xfe31ce1200000000, 0x4139d1db00000000, 0xeb3c0b2a00000000,\n    0x7e2e9e9200000000, 0xd42b446300000000, 0x6b235baa00000000,\n    0xc126815b00000000, 0xe96e591d00000000, 0x436b83ec00000000,\n    0xfc639c2500000000, 0x566646d400000000, 0xc374d36c00000000,\n    0x6971099d00000000, 0xd679165400000000, 0x7c7ccca500000000,\n    0xbd5a4dfe00000000, 0x175f970f00000000, 0xa85788c600000000,\n    0x0252523700000000, 0x9740c78f00000000, 0x3d451d7e00000000,\n    0x824d02b700000000, 0x2848d84600000000, 0xd2ddb23a00000000,\n    0x78d868cb00000000, 0xc7d0770200000000, 0x6dd5adf300000000,\n    0xf8c7384b00000000, 0x52c2e2ba00000000, 0xedcafd7300000000,\n    0x47cf278200000000, 0x86e9a6d900000000, 0x2cec7c2800000000,\n    0x93e463e100000000, 0x39e1b91000000000, 0xacf32ca800000000,\n    0x06f6f65900000000, 0xb9fee99000000000, 0x13fb336100000000,\n    0x3bb3eb2700000000, 0x91b631d600000000, 0x2ebe2e1f00000000,\n    0x84bbf4ee00000000, 0x11a9615600000000, 0xbbacbba700000000,\n    0x04a4a46e00000000, 0xaea17e9f00000000, 0x6f87ffc400000000,\n    0xc582253500000000, 0x7a8a3afc00000000, 0xd08fe00d00000000,\n    0x459d75b500000000, 0xef98af4400000000, 0x5090b08d00000000,\n    0xfa956a7c00000000, 0xa4bb657500000000, 0x0ebebf8400000000,\n    0xb1b6a04d00000000, 0x1bb37abc00000000, 0x8ea1ef0400000000,\n    0x24a435f500000000, 0x9bac2a3c00000000, 0x31a9f0cd00000000,\n    0xf08f719600000000, 0x5a8aab6700000000, 0xe582b4ae00000000,\n    0x4f876e5f00000000, 0xda95fbe700000000, 0x7090211600000000,\n    0xcf983edf00000000, 0x659de42e00000000, 0x4dd53c6800000000,\n    0xe7d0e69900000000, 0x58d8f95000000000, 0xf2dd23a100000000,\n    0x67cfb61900000000, 0xcdca6ce800000000, 0x72c2732100000000,\n    0xd8c7a9d000000000, 0x19e1288b00000000, 0xb3e4f27a00000000,\n    0x0cecedb300000000, 0xa6e9374200000000, 0x33fba2fa00000000,\n    0x99fe780b00000000, 0x26f667c200000000, 0x8cf3bd3300000000,\n    0x7666d74f00000000, 0xdc630dbe00000000, 0x636b127700000000,\n    0xc96ec88600000000, 0x5c7c5d3e00000000, 0xf67987cf00000000,\n    0x4971980600000000, 0xe37442f700000000, 0x2252c3ac00000000,\n    0x8857195d00000000, 0x375f069400000000, 0x9d5adc6500000000,\n    0x084849dd00000000, 0xa24d932c00000000, 0x1d458ce500000000,\n    0xb740561400000000, 0x9f088e5200000000, 0x350d54a300000000,\n    0x8a054b6a00000000, 0x2000919b00000000, 0xb512042300000000,\n    0x1f17ded200000000, 0xa01fc11b00000000, 0x0a1a1bea00000000,\n    0xcb3c9ab100000000, 0x6139404000000000, 0xde315f8900000000,\n    0x7434857800000000, 0xe12610c000000000, 0x4b23ca3100000000,\n    0xf42bd5f800000000, 0x5e2e0f0900000000, 0x4877cbea00000000,\n    0xe272111b00000000, 0x5d7a0ed200000000, 0xf77fd42300000000,\n    0x626d419b00000000, 0xc8689b6a00000000, 0x776084a300000000,\n    0xdd655e5200000000, 0x1c43df0900000000, 0xb64605f800000000,\n    0x094e1a3100000000, 0xa34bc0c000000000, 0x3659557800000000,\n    0x9c5c8f8900000000, 0x2354904000000000, 0x89514ab100000000,\n    0xa11992f700000000, 0x0b1c480600000000, 0xb41457cf00000000,\n    0x1e118d3e00000000, 0x8b03188600000000, 0x2106c27700000000,\n    0x9e0eddbe00000000, 0x340b074f00000000, 0xf52d861400000000,\n    0x5f285ce500000000, 0xe020432c00000000, 0x4a2599dd00000000,\n    0xdf370c6500000000, 0x7532d69400000000, 0xca3ac95d00000000,\n    0x603f13ac00000000, 0x9aaa79d000000000, 0x30afa32100000000,\n    0x8fa7bce800000000, 0x25a2661900000000, 0xb0b0f3a100000000,\n    0x1ab5295000000000, 0xa5bd369900000000, 0x0fb8ec6800000000,\n    0xce9e6d3300000000, 0x649bb7c200000000, 0xdb93a80b00000000,\n    0x719672fa00000000, 0xe484e74200000000, 0x4e813db300000000,\n    0xf189227a00000000, 0x5b8cf88b00000000, 0x73c420cd00000000,\n    0xd9c1fa3c00000000, 0x66c9e5f500000000, 0xcccc3f0400000000,\n    0x59deaabc00000000, 0xf3db704d00000000, 0x4cd36f8400000000,\n    0xe6d6b57500000000, 0x27f0342e00000000, 0x8df5eedf00000000,\n    0x32fdf11600000000, 0x98f82be700000000, 0x0deabe5f00000000,\n    0xa7ef64ae00000000, 0x18e77b6700000000, 0xb2e2a19600000000,\n    0xecccae9f00000000, 0x46c9746e00000000, 0xf9c16ba700000000,\n    0x53c4b15600000000, 0xc6d624ee00000000, 0x6cd3fe1f00000000,\n    0xd3dbe1d600000000, 0x79de3b2700000000, 0xb8f8ba7c00000000,\n    0x12fd608d00000000, 0xadf57f4400000000, 0x07f0a5b500000000,\n    0x92e2300d00000000, 0x38e7eafc00000000, 0x87eff53500000000,\n    0x2dea2fc400000000, 0x05a2f78200000000, 0xafa72d7300000000,\n    0x10af32ba00000000, 0xbaaae84b00000000, 0x2fb87df300000000,\n    0x85bda70200000000, 0x3ab5b8cb00000000, 0x90b0623a00000000,\n    0x5196e36100000000, 0xfb93399000000000, 0x449b265900000000,\n    0xee9efca800000000, 0x7b8c691000000000, 0xd189b3e100000000,\n    0x6e81ac2800000000, 0xc48476d900000000, 0x3e111ca500000000,\n    0x9414c65400000000, 0x2b1cd99d00000000, 0x8119036c00000000,\n    0x140b96d400000000, 0xbe0e4c2500000000, 0x010653ec00000000,\n    0xab03891d00000000, 0x6a25084600000000, 0xc020d2b700000000,\n    0x7f28cd7e00000000, 0xd52d178f00000000, 0x403f823700000000,\n    0xea3a58c600000000, 0x5532470f00000000, 0xff379dfe00000000,\n    0xd77f45b800000000, 0x7d7a9f4900000000, 0xc272808000000000,\n    0x68775a7100000000, 0xfd65cfc900000000, 0x5760153800000000,\n    0xe8680af100000000, 0x426dd00000000000, 0x834b515b00000000,\n    0x294e8baa00000000, 0x9646946300000000, 0x3c434e9200000000,\n    0xa951db2a00000000, 0x035401db00000000, 0xbc5c1e1200000000,\n    0x1659c4e300000000}};\n\n#else /* W == 4 */\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0xae689191, 0x87a02563, 0x29c8b4f2, 0xd4314c87,\n    0x7a59dd16, 0x539169e4, 0xfdf9f875, 0x73139f4f, 0xdd7b0ede,\n    0xf4b3ba2c, 0x5adb2bbd, 0xa722d3c8, 0x094a4259, 0x2082f6ab,\n    0x8eea673a, 0xe6273e9e, 0x484faf0f, 0x61871bfd, 0xcfef8a6c,\n    0x32167219, 0x9c7ee388, 0xb5b6577a, 0x1bdec6eb, 0x9534a1d1,\n    0x3b5c3040, 0x129484b2, 0xbcfc1523, 0x4105ed56, 0xef6d7cc7,\n    0xc6a5c835, 0x68cd59a4, 0x173f7b7d, 0xb957eaec, 0x909f5e1e,\n    0x3ef7cf8f, 0xc30e37fa, 0x6d66a66b, 0x44ae1299, 0xeac68308,\n    0x642ce432, 0xca4475a3, 0xe38cc151, 0x4de450c0, 0xb01da8b5,\n    0x1e753924, 0x37bd8dd6, 0x99d51c47, 0xf11845e3, 0x5f70d472,\n    0x76b86080, 0xd8d0f111, 0x25290964, 0x8b4198f5, 0xa2892c07,\n    0x0ce1bd96, 0x820bdaac, 0x2c634b3d, 0x05abffcf, 0xabc36e5e,\n    0x563a962b, 0xf85207ba, 0xd19ab348, 0x7ff222d9, 0x2e7ef6fa,\n    0x8016676b, 0xa9ded399, 0x07b64208, 0xfa4fba7d, 0x54272bec,\n    0x7def9f1e, 0xd3870e8f, 0x5d6d69b5, 0xf305f824, 0xdacd4cd6,\n    0x74a5dd47, 0x895c2532, 0x2734b4a3, 0x0efc0051, 0xa09491c0,\n    0xc859c864, 0x663159f5, 0x4ff9ed07, 0xe1917c96, 0x1c6884e3,\n    0xb2001572, 0x9bc8a180, 0x35a03011, 0xbb4a572b, 0x1522c6ba,\n    0x3cea7248, 0x9282e3d9, 0x6f7b1bac, 0xc1138a3d, 0xe8db3ecf,\n    0x46b3af5e, 0x39418d87, 0x97291c16, 0xbee1a8e4, 0x10893975,\n    0xed70c100, 0x43185091, 0x6ad0e463, 0xc4b875f2, 0x4a5212c8,\n    0xe43a8359, 0xcdf237ab, 0x639aa63a, 0x9e635e4f, 0x300bcfde,\n    0x19c37b2c, 0xb7abeabd, 0xdf66b319, 0x710e2288, 0x58c6967a,\n    0xf6ae07eb, 0x0b57ff9e, 0xa53f6e0f, 0x8cf7dafd, 0x229f4b6c,\n    0xac752c56, 0x021dbdc7, 0x2bd50935, 0x85bd98a4, 0x784460d1,\n    0xd62cf140, 0xffe445b2, 0x518cd423, 0x5cfdedf4, 0xf2957c65,\n    0xdb5dc897, 0x75355906, 0x88cca173, 0x26a430e2, 0x0f6c8410,\n    0xa1041581, 0x2fee72bb, 0x8186e32a, 0xa84e57d8, 0x0626c649,\n    0xfbdf3e3c, 0x55b7afad, 0x7c7f1b5f, 0xd2178ace, 0xbadad36a,\n    0x14b242fb, 0x3d7af609, 0x93126798, 0x6eeb9fed, 0xc0830e7c,\n    0xe94bba8e, 0x47232b1f, 0xc9c94c25, 0x67a1ddb4, 0x4e696946,\n    0xe001f8d7, 0x1df800a2, 0xb3909133, 0x9a5825c1, 0x3430b450,\n    0x4bc29689, 0xe5aa0718, 0xcc62b3ea, 0x620a227b, 0x9ff3da0e,\n    0x319b4b9f, 0x1853ff6d, 0xb63b6efc, 0x38d109c6, 0x96b99857,\n    0xbf712ca5, 0x1119bd34, 0xece04541, 0x4288d4d0, 0x6b406022,\n    0xc528f1b3, 0xade5a817, 0x038d3986, 0x2a458d74, 0x842d1ce5,\n    0x79d4e490, 0xd7bc7501, 0xfe74c1f3, 0x501c5062, 0xdef63758,\n    0x709ea6c9, 0x5956123b, 0xf73e83aa, 0x0ac77bdf, 0xa4afea4e,\n    0x8d675ebc, 0x230fcf2d, 0x72831b0e, 0xdceb8a9f, 0xf5233e6d,\n    0x5b4baffc, 0xa6b25789, 0x08dac618, 0x211272ea, 0x8f7ae37b,\n    0x01908441, 0xaff815d0, 0x8630a122, 0x285830b3, 0xd5a1c8c6,\n    0x7bc95957, 0x5201eda5, 0xfc697c34, 0x94a42590, 0x3accb401,\n    0x130400f3, 0xbd6c9162, 0x40956917, 0xeefdf886, 0xc7354c74,\n    0x695ddde5, 0xe7b7badf, 0x49df2b4e, 0x60179fbc, 0xce7f0e2d,\n    0x3386f658, 0x9dee67c9, 0xb426d33b, 0x1a4e42aa, 0x65bc6073,\n    0xcbd4f1e2, 0xe21c4510, 0x4c74d481, 0xb18d2cf4, 0x1fe5bd65,\n    0x362d0997, 0x98459806, 0x16afff3c, 0xb8c76ead, 0x910fda5f,\n    0x3f674bce, 0xc29eb3bb, 0x6cf6222a, 0x453e96d8, 0xeb560749,\n    0x839b5eed, 0x2df3cf7c, 0x043b7b8e, 0xaa53ea1f, 0x57aa126a,\n    0xf9c283fb, 0xd00a3709, 0x7e62a698, 0xf088c1a2, 0x5ee05033,\n    0x7728e4c1, 0xd9407550, 0x24b98d25, 0x8ad11cb4, 0xa319a846,\n    0x0d7139d7},\n   {0x00000000, 0xb9fbdbe8, 0xa886b191, 0x117d6a79, 0x8a7c6563,\n    0x3387be8b, 0x22fad4f2, 0x9b010f1a, 0xcf89cc87, 0x7672176f,\n    0x670f7d16, 0xdef4a6fe, 0x45f5a9e4, 0xfc0e720c, 0xed731875,\n    0x5488c39d, 0x44629f4f, 0xfd9944a7, 0xece42ede, 0x551ff536,\n    0xce1efa2c, 0x77e521c4, 0x66984bbd, 0xdf639055, 0x8beb53c8,\n    0x32108820, 0x236de259, 0x9a9639b1, 0x019736ab, 0xb86ced43,\n    0xa911873a, 0x10ea5cd2, 0x88c53e9e, 0x313ee576, 0x20438f0f,\n    0x99b854e7, 0x02b95bfd, 0xbb428015, 0xaa3fea6c, 0x13c43184,\n    0x474cf219, 0xfeb729f1, 0xefca4388, 0x56319860, 0xcd30977a,\n    0x74cb4c92, 0x65b626eb, 0xdc4dfd03, 0xcca7a1d1, 0x755c7a39,\n    0x64211040, 0xdddacba8, 0x46dbc4b2, 0xff201f5a, 0xee5d7523,\n    0x57a6aecb, 0x032e6d56, 0xbad5b6be, 0xaba8dcc7, 0x1253072f,\n    0x89520835, 0x30a9d3dd, 0x21d4b9a4, 0x982f624c, 0xcafb7b7d,\n    0x7300a095, 0x627dcaec, 0xdb861104, 0x40871e1e, 0xf97cc5f6,\n    0xe801af8f, 0x51fa7467, 0x0572b7fa, 0xbc896c12, 0xadf4066b,\n    0x140fdd83, 0x8f0ed299, 0x36f50971, 0x27886308, 0x9e73b8e0,\n    0x8e99e432, 0x37623fda, 0x261f55a3, 0x9fe48e4b, 0x04e58151,\n    0xbd1e5ab9, 0xac6330c0, 0x1598eb28, 0x411028b5, 0xf8ebf35d,\n    0xe9969924, 0x506d42cc, 0xcb6c4dd6, 0x7297963e, 0x63eafc47,\n    0xda1127af, 0x423e45e3, 0xfbc59e0b, 0xeab8f472, 0x53432f9a,\n    0xc8422080, 0x71b9fb68, 0x60c49111, 0xd93f4af9, 0x8db78964,\n    0x344c528c, 0x253138f5, 0x9ccae31d, 0x07cbec07, 0xbe3037ef,\n    0xaf4d5d96, 0x16b6867e, 0x065cdaac, 0xbfa70144, 0xaeda6b3d,\n    0x1721b0d5, 0x8c20bfcf, 0x35db6427, 0x24a60e5e, 0x9d5dd5b6,\n    0xc9d5162b, 0x702ecdc3, 0x6153a7ba, 0xd8a87c52, 0x43a97348,\n    0xfa52a8a0, 0xeb2fc2d9, 0x52d41931, 0x4e87f0bb, 0xf77c2b53,\n    0xe601412a, 0x5ffa9ac2, 0xc4fb95d8, 0x7d004e30, 0x6c7d2449,\n    0xd586ffa1, 0x810e3c3c, 0x38f5e7d4, 0x29888dad, 0x90735645,\n    0x0b72595f, 0xb28982b7, 0xa3f4e8ce, 0x1a0f3326, 0x0ae56ff4,\n    0xb31eb41c, 0xa263de65, 0x1b98058d, 0x80990a97, 0x3962d17f,\n    0x281fbb06, 0x91e460ee, 0xc56ca373, 0x7c97789b, 0x6dea12e2,\n    0xd411c90a, 0x4f10c610, 0xf6eb1df8, 0xe7967781, 0x5e6dac69,\n    0xc642ce25, 0x7fb915cd, 0x6ec47fb4, 0xd73fa45c, 0x4c3eab46,\n    0xf5c570ae, 0xe4b81ad7, 0x5d43c13f, 0x09cb02a2, 0xb030d94a,\n    0xa14db333, 0x18b668db, 0x83b767c1, 0x3a4cbc29, 0x2b31d650,\n    0x92ca0db8, 0x8220516a, 0x3bdb8a82, 0x2aa6e0fb, 0x935d3b13,\n    0x085c3409, 0xb1a7efe1, 0xa0da8598, 0x19215e70, 0x4da99ded,\n    0xf4524605, 0xe52f2c7c, 0x5cd4f794, 0xc7d5f88e, 0x7e2e2366,\n    0x6f53491f, 0xd6a892f7, 0x847c8bc6, 0x3d87502e, 0x2cfa3a57,\n    0x9501e1bf, 0x0e00eea5, 0xb7fb354d, 0xa6865f34, 0x1f7d84dc,\n    0x4bf54741, 0xf20e9ca9, 0xe373f6d0, 0x5a882d38, 0xc1892222,\n    0x7872f9ca, 0x690f93b3, 0xd0f4485b, 0xc01e1489, 0x79e5cf61,\n    0x6898a518, 0xd1637ef0, 0x4a6271ea, 0xf399aa02, 0xe2e4c07b,\n    0x5b1f1b93, 0x0f97d80e, 0xb66c03e6, 0xa711699f, 0x1eeab277,\n    0x85ebbd6d, 0x3c106685, 0x2d6d0cfc, 0x9496d714, 0x0cb9b558,\n    0xb5426eb0, 0xa43f04c9, 0x1dc4df21, 0x86c5d03b, 0x3f3e0bd3,\n    0x2e4361aa, 0x97b8ba42, 0xc33079df, 0x7acba237, 0x6bb6c84e,\n    0xd24d13a6, 0x494c1cbc, 0xf0b7c754, 0xe1caad2d, 0x583176c5,\n    0x48db2a17, 0xf120f1ff, 0xe05d9b86, 0x59a6406e, 0xc2a74f74,\n    0x7b5c949c, 0x6a21fee5, 0xd3da250d, 0x8752e690, 0x3ea93d78,\n    0x2fd45701, 0x962f8ce9, 0x0d2e83f3, 0xb4d5581b, 0xa5a83262,\n    0x1c53e98a},\n   {0x00000000, 0x9d0fe176, 0xe16ec4ad, 0x7c6125db, 0x19ac8f1b,\n    0x84a36e6d, 0xf8c24bb6, 0x65cdaac0, 0x33591e36, 0xae56ff40,\n    0xd237da9b, 0x4f383bed, 0x2af5912d, 0xb7fa705b, 0xcb9b5580,\n    0x5694b4f6, 0x66b23c6c, 0xfbbddd1a, 0x87dcf8c1, 0x1ad319b7,\n    0x7f1eb377, 0xe2115201, 0x9e7077da, 0x037f96ac, 0x55eb225a,\n    0xc8e4c32c, 0xb485e6f7, 0x298a0781, 0x4c47ad41, 0xd1484c37,\n    0xad2969ec, 0x3026889a, 0xcd6478d8, 0x506b99ae, 0x2c0abc75,\n    0xb1055d03, 0xd4c8f7c3, 0x49c716b5, 0x35a6336e, 0xa8a9d218,\n    0xfe3d66ee, 0x63328798, 0x1f53a243, 0x825c4335, 0xe791e9f5,\n    0x7a9e0883, 0x06ff2d58, 0x9bf0cc2e, 0xabd644b4, 0x36d9a5c2,\n    0x4ab88019, 0xd7b7616f, 0xb27acbaf, 0x2f752ad9, 0x53140f02,\n    0xce1bee74, 0x988f5a82, 0x0580bbf4, 0x79e19e2f, 0xe4ee7f59,\n    0x8123d599, 0x1c2c34ef, 0x604d1134, 0xfd42f042, 0x41b9f7f1,\n    0xdcb61687, 0xa0d7335c, 0x3dd8d22a, 0x581578ea, 0xc51a999c,\n    0xb97bbc47, 0x24745d31, 0x72e0e9c7, 0xefef08b1, 0x938e2d6a,\n    0x0e81cc1c, 0x6b4c66dc, 0xf64387aa, 0x8a22a271, 0x172d4307,\n    0x270bcb9d, 0xba042aeb, 0xc6650f30, 0x5b6aee46, 0x3ea74486,\n    0xa3a8a5f0, 0xdfc9802b, 0x42c6615d, 0x1452d5ab, 0x895d34dd,\n    0xf53c1106, 0x6833f070, 0x0dfe5ab0, 0x90f1bbc6, 0xec909e1d,\n    0x719f7f6b, 0x8cdd8f29, 0x11d26e5f, 0x6db34b84, 0xf0bcaaf2,\n    0x95710032, 0x087ee144, 0x741fc49f, 0xe91025e9, 0xbf84911f,\n    0x228b7069, 0x5eea55b2, 0xc3e5b4c4, 0xa6281e04, 0x3b27ff72,\n    0x4746daa9, 0xda493bdf, 0xea6fb345, 0x77605233, 0x0b0177e8,\n    0x960e969e, 0xf3c33c5e, 0x6eccdd28, 0x12adf8f3, 0x8fa21985,\n    0xd936ad73, 0x44394c05, 0x385869de, 0xa55788a8, 0xc09a2268,\n    0x5d95c31e, 0x21f4e6c5, 0xbcfb07b3, 0x8373efe2, 0x1e7c0e94,\n    0x621d2b4f, 0xff12ca39, 0x9adf60f9, 0x07d0818f, 0x7bb1a454,\n    0xe6be4522, 0xb02af1d4, 0x2d2510a2, 0x51443579, 0xcc4bd40f,\n    0xa9867ecf, 0x34899fb9, 0x48e8ba62, 0xd5e75b14, 0xe5c1d38e,\n    0x78ce32f8, 0x04af1723, 0x99a0f655, 0xfc6d5c95, 0x6162bde3,\n    0x1d039838, 0x800c794e, 0xd698cdb8, 0x4b972cce, 0x37f60915,\n    0xaaf9e863, 0xcf3442a3, 0x523ba3d5, 0x2e5a860e, 0xb3556778,\n    0x4e17973a, 0xd318764c, 0xaf795397, 0x3276b2e1, 0x57bb1821,\n    0xcab4f957, 0xb6d5dc8c, 0x2bda3dfa, 0x7d4e890c, 0xe041687a,\n    0x9c204da1, 0x012facd7, 0x64e20617, 0xf9ede761, 0x858cc2ba,\n    0x188323cc, 0x28a5ab56, 0xb5aa4a20, 0xc9cb6ffb, 0x54c48e8d,\n    0x3109244d, 0xac06c53b, 0xd067e0e0, 0x4d680196, 0x1bfcb560,\n    0x86f35416, 0xfa9271cd, 0x679d90bb, 0x02503a7b, 0x9f5fdb0d,\n    0xe33efed6, 0x7e311fa0, 0xc2ca1813, 0x5fc5f965, 0x23a4dcbe,\n    0xbeab3dc8, 0xdb669708, 0x4669767e, 0x3a0853a5, 0xa707b2d3,\n    0xf1930625, 0x6c9ce753, 0x10fdc288, 0x8df223fe, 0xe83f893e,\n    0x75306848, 0x09514d93, 0x945eace5, 0xa478247f, 0x3977c509,\n    0x4516e0d2, 0xd81901a4, 0xbdd4ab64, 0x20db4a12, 0x5cba6fc9,\n    0xc1b58ebf, 0x97213a49, 0x0a2edb3f, 0x764ffee4, 0xeb401f92,\n    0x8e8db552, 0x13825424, 0x6fe371ff, 0xf2ec9089, 0x0fae60cb,\n    0x92a181bd, 0xeec0a466, 0x73cf4510, 0x1602efd0, 0x8b0d0ea6,\n    0xf76c2b7d, 0x6a63ca0b, 0x3cf77efd, 0xa1f89f8b, 0xdd99ba50,\n    0x40965b26, 0x255bf1e6, 0xb8541090, 0xc435354b, 0x593ad43d,\n    0x691c5ca7, 0xf413bdd1, 0x8872980a, 0x157d797c, 0x70b0d3bc,\n    0xedbf32ca, 0x91de1711, 0x0cd1f667, 0x5a454291, 0xc74aa3e7,\n    0xbb2b863c, 0x2624674a, 0x43e9cd8a, 0xdee62cfc, 0xa2870927,\n    0x3f88e851},\n   {0x00000000, 0xdd96d985, 0x605cb54b, 0xbdca6cce, 0xc0b96a96,\n    0x1d2fb313, 0xa0e5dfdd, 0x7d730658, 0x5a03d36d, 0x87950ae8,\n    0x3a5f6626, 0xe7c9bfa3, 0x9abab9fb, 0x472c607e, 0xfae60cb0,\n    0x2770d535, 0xb407a6da, 0x69917f5f, 0xd45b1391, 0x09cdca14,\n    0x74becc4c, 0xa92815c9, 0x14e27907, 0xc974a082, 0xee0475b7,\n    0x3392ac32, 0x8e58c0fc, 0x53ce1979, 0x2ebd1f21, 0xf32bc6a4,\n    0x4ee1aa6a, 0x937773ef, 0xb37e4bf5, 0x6ee89270, 0xd322febe,\n    0x0eb4273b, 0x73c72163, 0xae51f8e6, 0x139b9428, 0xce0d4dad,\n    0xe97d9898, 0x34eb411d, 0x89212dd3, 0x54b7f456, 0x29c4f20e,\n    0xf4522b8b, 0x49984745, 0x940e9ec0, 0x0779ed2f, 0xdaef34aa,\n    0x67255864, 0xbab381e1, 0xc7c087b9, 0x1a565e3c, 0xa79c32f2,\n    0x7a0aeb77, 0x5d7a3e42, 0x80ece7c7, 0x3d268b09, 0xe0b0528c,\n    0x9dc354d4, 0x40558d51, 0xfd9fe19f, 0x2009381a, 0xbd8d91ab,\n    0x601b482e, 0xddd124e0, 0x0047fd65, 0x7d34fb3d, 0xa0a222b8,\n    0x1d684e76, 0xc0fe97f3, 0xe78e42c6, 0x3a189b43, 0x87d2f78d,\n    0x5a442e08, 0x27372850, 0xfaa1f1d5, 0x476b9d1b, 0x9afd449e,\n    0x098a3771, 0xd41ceef4, 0x69d6823a, 0xb4405bbf, 0xc9335de7,\n    0x14a58462, 0xa96fe8ac, 0x74f93129, 0x5389e41c, 0x8e1f3d99,\n    0x33d55157, 0xee4388d2, 0x93308e8a, 0x4ea6570f, 0xf36c3bc1,\n    0x2efae244, 0x0ef3da5e, 0xd36503db, 0x6eaf6f15, 0xb339b690,\n    0xce4ab0c8, 0x13dc694d, 0xae160583, 0x7380dc06, 0x54f00933,\n    0x8966d0b6, 0x34acbc78, 0xe93a65fd, 0x944963a5, 0x49dfba20,\n    0xf415d6ee, 0x29830f6b, 0xbaf47c84, 0x6762a501, 0xdaa8c9cf,\n    0x073e104a, 0x7a4d1612, 0xa7dbcf97, 0x1a11a359, 0xc7877adc,\n    0xe0f7afe9, 0x3d61766c, 0x80ab1aa2, 0x5d3dc327, 0x204ec57f,\n    0xfdd81cfa, 0x40127034, 0x9d84a9b1, 0xa06a2517, 0x7dfcfc92,\n    0xc036905c, 0x1da049d9, 0x60d34f81, 0xbd459604, 0x008ffaca,\n    0xdd19234f, 0xfa69f67a, 0x27ff2fff, 0x9a354331, 0x47a39ab4,\n    0x3ad09cec, 0xe7464569, 0x5a8c29a7, 0x871af022, 0x146d83cd,\n    0xc9fb5a48, 0x74313686, 0xa9a7ef03, 0xd4d4e95b, 0x094230de,\n    0xb4885c10, 0x691e8595, 0x4e6e50a0, 0x93f88925, 0x2e32e5eb,\n    0xf3a43c6e, 0x8ed73a36, 0x5341e3b3, 0xee8b8f7d, 0x331d56f8,\n    0x13146ee2, 0xce82b767, 0x7348dba9, 0xaede022c, 0xd3ad0474,\n    0x0e3bddf1, 0xb3f1b13f, 0x6e6768ba, 0x4917bd8f, 0x9481640a,\n    0x294b08c4, 0xf4ddd141, 0x89aed719, 0x54380e9c, 0xe9f26252,\n    0x3464bbd7, 0xa713c838, 0x7a8511bd, 0xc74f7d73, 0x1ad9a4f6,\n    0x67aaa2ae, 0xba3c7b2b, 0x07f617e5, 0xda60ce60, 0xfd101b55,\n    0x2086c2d0, 0x9d4cae1e, 0x40da779b, 0x3da971c3, 0xe03fa846,\n    0x5df5c488, 0x80631d0d, 0x1de7b4bc, 0xc0716d39, 0x7dbb01f7,\n    0xa02dd872, 0xdd5ede2a, 0x00c807af, 0xbd026b61, 0x6094b2e4,\n    0x47e467d1, 0x9a72be54, 0x27b8d29a, 0xfa2e0b1f, 0x875d0d47,\n    0x5acbd4c2, 0xe701b80c, 0x3a976189, 0xa9e01266, 0x7476cbe3,\n    0xc9bca72d, 0x142a7ea8, 0x695978f0, 0xb4cfa175, 0x0905cdbb,\n    0xd493143e, 0xf3e3c10b, 0x2e75188e, 0x93bf7440, 0x4e29adc5,\n    0x335aab9d, 0xeecc7218, 0x53061ed6, 0x8e90c753, 0xae99ff49,\n    0x730f26cc, 0xcec54a02, 0x13539387, 0x6e2095df, 0xb3b64c5a,\n    0x0e7c2094, 0xd3eaf911, 0xf49a2c24, 0x290cf5a1, 0x94c6996f,\n    0x495040ea, 0x342346b2, 0xe9b59f37, 0x547ff3f9, 0x89e92a7c,\n    0x1a9e5993, 0xc7088016, 0x7ac2ecd8, 0xa754355d, 0xda273305,\n    0x07b1ea80, 0xba7b864e, 0x67ed5fcb, 0x409d8afe, 0x9d0b537b,\n    0x20c13fb5, 0xfd57e630, 0x8024e068, 0x5db239ed, 0xe0785523,\n    0x3dee8ca6}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x00000000, 0x85d996dd, 0x4bb55c60, 0xce6ccabd, 0x966ab9c0,\n    0x13b32f1d, 0xdddfe5a0, 0x5806737d, 0x6dd3035a, 0xe80a9587,\n    0x26665f3a, 0xa3bfc9e7, 0xfbb9ba9a, 0x7e602c47, 0xb00ce6fa,\n    0x35d57027, 0xdaa607b4, 0x5f7f9169, 0x91135bd4, 0x14cacd09,\n    0x4cccbe74, 0xc91528a9, 0x0779e214, 0x82a074c9, 0xb77504ee,\n    0x32ac9233, 0xfcc0588e, 0x7919ce53, 0x211fbd2e, 0xa4c62bf3,\n    0x6aaae14e, 0xef737793, 0xf54b7eb3, 0x7092e86e, 0xbefe22d3,\n    0x3b27b40e, 0x6321c773, 0xe6f851ae, 0x28949b13, 0xad4d0dce,\n    0x98987de9, 0x1d41eb34, 0xd32d2189, 0x56f4b754, 0x0ef2c429,\n    0x8b2b52f4, 0x45479849, 0xc09e0e94, 0x2fed7907, 0xaa34efda,\n    0x64582567, 0xe181b3ba, 0xb987c0c7, 0x3c5e561a, 0xf2329ca7,\n    0x77eb0a7a, 0x423e7a5d, 0xc7e7ec80, 0x098b263d, 0x8c52b0e0,\n    0xd454c39d, 0x518d5540, 0x9fe19ffd, 0x1a380920, 0xab918dbd,\n    0x2e481b60, 0xe024d1dd, 0x65fd4700, 0x3dfb347d, 0xb822a2a0,\n    0x764e681d, 0xf397fec0, 0xc6428ee7, 0x439b183a, 0x8df7d287,\n    0x082e445a, 0x50283727, 0xd5f1a1fa, 0x1b9d6b47, 0x9e44fd9a,\n    0x71378a09, 0xf4ee1cd4, 0x3a82d669, 0xbf5b40b4, 0xe75d33c9,\n    0x6284a514, 0xace86fa9, 0x2931f974, 0x1ce48953, 0x993d1f8e,\n    0x5751d533, 0xd28843ee, 0x8a8e3093, 0x0f57a64e, 0xc13b6cf3,\n    0x44e2fa2e, 0x5edaf30e, 0xdb0365d3, 0x156faf6e, 0x90b639b3,\n    0xc8b04ace, 0x4d69dc13, 0x830516ae, 0x06dc8073, 0x3309f054,\n    0xb6d06689, 0x78bcac34, 0xfd653ae9, 0xa5634994, 0x20badf49,\n    0xeed615f4, 0x6b0f8329, 0x847cf4ba, 0x01a56267, 0xcfc9a8da,\n    0x4a103e07, 0x12164d7a, 0x97cfdba7, 0x59a3111a, 0xdc7a87c7,\n    0xe9aff7e0, 0x6c76613d, 0xa21aab80, 0x27c33d5d, 0x7fc54e20,\n    0xfa1cd8fd, 0x34701240, 0xb1a9849d, 0x17256aa0, 0x92fcfc7d,\n    0x5c9036c0, 0xd949a01d, 0x814fd360, 0x049645bd, 0xcafa8f00,\n    0x4f2319dd, 0x7af669fa, 0xff2fff27, 0x3143359a, 0xb49aa347,\n    0xec9cd03a, 0x694546e7, 0xa7298c5a, 0x22f01a87, 0xcd836d14,\n    0x485afbc9, 0x86363174, 0x03efa7a9, 0x5be9d4d4, 0xde304209,\n    0x105c88b4, 0x95851e69, 0xa0506e4e, 0x2589f893, 0xebe5322e,\n    0x6e3ca4f3, 0x363ad78e, 0xb3e34153, 0x7d8f8bee, 0xf8561d33,\n    0xe26e1413, 0x67b782ce, 0xa9db4873, 0x2c02deae, 0x7404add3,\n    0xf1dd3b0e, 0x3fb1f1b3, 0xba68676e, 0x8fbd1749, 0x0a648194,\n    0xc4084b29, 0x41d1ddf4, 0x19d7ae89, 0x9c0e3854, 0x5262f2e9,\n    0xd7bb6434, 0x38c813a7, 0xbd11857a, 0x737d4fc7, 0xf6a4d91a,\n    0xaea2aa67, 0x2b7b3cba, 0xe517f607, 0x60ce60da, 0x551b10fd,\n    0xd0c28620, 0x1eae4c9d, 0x9b77da40, 0xc371a93d, 0x46a83fe0,\n    0x88c4f55d, 0x0d1d6380, 0xbcb4e71d, 0x396d71c0, 0xf701bb7d,\n    0x72d82da0, 0x2ade5edd, 0xaf07c800, 0x616b02bd, 0xe4b29460,\n    0xd167e447, 0x54be729a, 0x9ad2b827, 0x1f0b2efa, 0x470d5d87,\n    0xc2d4cb5a, 0x0cb801e7, 0x8961973a, 0x6612e0a9, 0xe3cb7674,\n    0x2da7bcc9, 0xa87e2a14, 0xf0785969, 0x75a1cfb4, 0xbbcd0509,\n    0x3e1493d4, 0x0bc1e3f3, 0x8e18752e, 0x4074bf93, 0xc5ad294e,\n    0x9dab5a33, 0x1872ccee, 0xd61e0653, 0x53c7908e, 0x49ff99ae,\n    0xcc260f73, 0x024ac5ce, 0x87935313, 0xdf95206e, 0x5a4cb6b3,\n    0x94207c0e, 0x11f9ead3, 0x242c9af4, 0xa1f50c29, 0x6f99c694,\n    0xea405049, 0xb2462334, 0x379fb5e9, 0xf9f37f54, 0x7c2ae989,\n    0x93599e1a, 0x168008c7, 0xd8ecc27a, 0x5d3554a7, 0x053327da,\n    0x80eab107, 0x4e867bba, 0xcb5fed67, 0xfe8a9d40, 0x7b530b9d,\n    0xb53fc120, 0x30e657fd, 0x68e02480, 0xed39b25d, 0x235578e0,\n    0xa68cee3d},\n   {0x00000000, 0x76e10f9d, 0xadc46ee1, 0xdb25617c, 0x1b8fac19,\n    0x6d6ea384, 0xb64bc2f8, 0xc0aacd65, 0x361e5933, 0x40ff56ae,\n    0x9bda37d2, 0xed3b384f, 0x2d91f52a, 0x5b70fab7, 0x80559bcb,\n    0xf6b49456, 0x6c3cb266, 0x1addbdfb, 0xc1f8dc87, 0xb719d31a,\n    0x77b31e7f, 0x015211e2, 0xda77709e, 0xac967f03, 0x5a22eb55,\n    0x2cc3e4c8, 0xf7e685b4, 0x81078a29, 0x41ad474c, 0x374c48d1,\n    0xec6929ad, 0x9a882630, 0xd87864cd, 0xae996b50, 0x75bc0a2c,\n    0x035d05b1, 0xc3f7c8d4, 0xb516c749, 0x6e33a635, 0x18d2a9a8,\n    0xee663dfe, 0x98873263, 0x43a2531f, 0x35435c82, 0xf5e991e7,\n    0x83089e7a, 0x582dff06, 0x2eccf09b, 0xb444d6ab, 0xc2a5d936,\n    0x1980b84a, 0x6f61b7d7, 0xafcb7ab2, 0xd92a752f, 0x020f1453,\n    0x74ee1bce, 0x825a8f98, 0xf4bb8005, 0x2f9ee179, 0x597feee4,\n    0x99d52381, 0xef342c1c, 0x34114d60, 0x42f042fd, 0xf1f7b941,\n    0x8716b6dc, 0x5c33d7a0, 0x2ad2d83d, 0xea781558, 0x9c991ac5,\n    0x47bc7bb9, 0x315d7424, 0xc7e9e072, 0xb108efef, 0x6a2d8e93,\n    0x1ccc810e, 0xdc664c6b, 0xaa8743f6, 0x71a2228a, 0x07432d17,\n    0x9dcb0b27, 0xeb2a04ba, 0x300f65c6, 0x46ee6a5b, 0x8644a73e,\n    0xf0a5a8a3, 0x2b80c9df, 0x5d61c642, 0xabd55214, 0xdd345d89,\n    0x06113cf5, 0x70f03368, 0xb05afe0d, 0xc6bbf190, 0x1d9e90ec,\n    0x6b7f9f71, 0x298fdd8c, 0x5f6ed211, 0x844bb36d, 0xf2aabcf0,\n    0x32007195, 0x44e17e08, 0x9fc41f74, 0xe92510e9, 0x1f9184bf,\n    0x69708b22, 0xb255ea5e, 0xc4b4e5c3, 0x041e28a6, 0x72ff273b,\n    0xa9da4647, 0xdf3b49da, 0x45b36fea, 0x33526077, 0xe877010b,\n    0x9e960e96, 0x5e3cc3f3, 0x28ddcc6e, 0xf3f8ad12, 0x8519a28f,\n    0x73ad36d9, 0x054c3944, 0xde695838, 0xa88857a5, 0x68229ac0,\n    0x1ec3955d, 0xc5e6f421, 0xb307fbbc, 0xe2ef7383, 0x940e7c1e,\n    0x4f2b1d62, 0x39ca12ff, 0xf960df9a, 0x8f81d007, 0x54a4b17b,\n    0x2245bee6, 0xd4f12ab0, 0xa210252d, 0x79354451, 0x0fd44bcc,\n    0xcf7e86a9, 0xb99f8934, 0x62bae848, 0x145be7d5, 0x8ed3c1e5,\n    0xf832ce78, 0x2317af04, 0x55f6a099, 0x955c6dfc, 0xe3bd6261,\n    0x3898031d, 0x4e790c80, 0xb8cd98d6, 0xce2c974b, 0x1509f637,\n    0x63e8f9aa, 0xa34234cf, 0xd5a33b52, 0x0e865a2e, 0x786755b3,\n    0x3a97174e, 0x4c7618d3, 0x975379af, 0xe1b27632, 0x2118bb57,\n    0x57f9b4ca, 0x8cdcd5b6, 0xfa3dda2b, 0x0c894e7d, 0x7a6841e0,\n    0xa14d209c, 0xd7ac2f01, 0x1706e264, 0x61e7edf9, 0xbac28c85,\n    0xcc238318, 0x56aba528, 0x204aaab5, 0xfb6fcbc9, 0x8d8ec454,\n    0x4d240931, 0x3bc506ac, 0xe0e067d0, 0x9601684d, 0x60b5fc1b,\n    0x1654f386, 0xcd7192fa, 0xbb909d67, 0x7b3a5002, 0x0ddb5f9f,\n    0xd6fe3ee3, 0xa01f317e, 0x1318cac2, 0x65f9c55f, 0xbedca423,\n    0xc83dabbe, 0x089766db, 0x7e766946, 0xa553083a, 0xd3b207a7,\n    0x250693f1, 0x53e79c6c, 0x88c2fd10, 0xfe23f28d, 0x3e893fe8,\n    0x48683075, 0x934d5109, 0xe5ac5e94, 0x7f2478a4, 0x09c57739,\n    0xd2e01645, 0xa40119d8, 0x64abd4bd, 0x124adb20, 0xc96fba5c,\n    0xbf8eb5c1, 0x493a2197, 0x3fdb2e0a, 0xe4fe4f76, 0x921f40eb,\n    0x52b58d8e, 0x24548213, 0xff71e36f, 0x8990ecf2, 0xcb60ae0f,\n    0xbd81a192, 0x66a4c0ee, 0x1045cf73, 0xd0ef0216, 0xa60e0d8b,\n    0x7d2b6cf7, 0x0bca636a, 0xfd7ef73c, 0x8b9ff8a1, 0x50ba99dd,\n    0x265b9640, 0xe6f15b25, 0x901054b8, 0x4b3535c4, 0x3dd43a59,\n    0xa75c1c69, 0xd1bd13f4, 0x0a987288, 0x7c797d15, 0xbcd3b070,\n    0xca32bfed, 0x1117de91, 0x67f6d10c, 0x9142455a, 0xe7a34ac7,\n    0x3c862bbb, 0x4a672426, 0x8acde943, 0xfc2ce6de, 0x270987a2,\n    0x51e8883f},\n   {0x00000000, 0xe8dbfbb9, 0x91b186a8, 0x796a7d11, 0x63657c8a,\n    0x8bbe8733, 0xf2d4fa22, 0x1a0f019b, 0x87cc89cf, 0x6f177276,\n    0x167d0f67, 0xfea6f4de, 0xe4a9f545, 0x0c720efc, 0x751873ed,\n    0x9dc38854, 0x4f9f6244, 0xa74499fd, 0xde2ee4ec, 0x36f51f55,\n    0x2cfa1ece, 0xc421e577, 0xbd4b9866, 0x559063df, 0xc853eb8b,\n    0x20881032, 0x59e26d23, 0xb139969a, 0xab369701, 0x43ed6cb8,\n    0x3a8711a9, 0xd25cea10, 0x9e3ec588, 0x76e53e31, 0x0f8f4320,\n    0xe754b899, 0xfd5bb902, 0x158042bb, 0x6cea3faa, 0x8431c413,\n    0x19f24c47, 0xf129b7fe, 0x8843caef, 0x60983156, 0x7a9730cd,\n    0x924ccb74, 0xeb26b665, 0x03fd4ddc, 0xd1a1a7cc, 0x397a5c75,\n    0x40102164, 0xa8cbdadd, 0xb2c4db46, 0x5a1f20ff, 0x23755dee,\n    0xcbaea657, 0x566d2e03, 0xbeb6d5ba, 0xc7dca8ab, 0x2f075312,\n    0x35085289, 0xddd3a930, 0xa4b9d421, 0x4c622f98, 0x7d7bfbca,\n    0x95a00073, 0xecca7d62, 0x041186db, 0x1e1e8740, 0xf6c57cf9,\n    0x8faf01e8, 0x6774fa51, 0xfab77205, 0x126c89bc, 0x6b06f4ad,\n    0x83dd0f14, 0x99d20e8f, 0x7109f536, 0x08638827, 0xe0b8739e,\n    0x32e4998e, 0xda3f6237, 0xa3551f26, 0x4b8ee49f, 0x5181e504,\n    0xb95a1ebd, 0xc03063ac, 0x28eb9815, 0xb5281041, 0x5df3ebf8,\n    0x249996e9, 0xcc426d50, 0xd64d6ccb, 0x3e969772, 0x47fcea63,\n    0xaf2711da, 0xe3453e42, 0x0b9ec5fb, 0x72f4b8ea, 0x9a2f4353,\n    0x802042c8, 0x68fbb971, 0x1191c460, 0xf94a3fd9, 0x6489b78d,\n    0x8c524c34, 0xf5383125, 0x1de3ca9c, 0x07eccb07, 0xef3730be,\n    0x965d4daf, 0x7e86b616, 0xacda5c06, 0x4401a7bf, 0x3d6bdaae,\n    0xd5b02117, 0xcfbf208c, 0x2764db35, 0x5e0ea624, 0xb6d55d9d,\n    0x2b16d5c9, 0xc3cd2e70, 0xbaa75361, 0x527ca8d8, 0x4873a943,\n    0xa0a852fa, 0xd9c22feb, 0x3119d452, 0xbbf0874e, 0x532b7cf7,\n    0x2a4101e6, 0xc29afa5f, 0xd895fbc4, 0x304e007d, 0x49247d6c,\n    0xa1ff86d5, 0x3c3c0e81, 0xd4e7f538, 0xad8d8829, 0x45567390,\n    0x5f59720b, 0xb78289b2, 0xcee8f4a3, 0x26330f1a, 0xf46fe50a,\n    0x1cb41eb3, 0x65de63a2, 0x8d05981b, 0x970a9980, 0x7fd16239,\n    0x06bb1f28, 0xee60e491, 0x73a36cc5, 0x9b78977c, 0xe212ea6d,\n    0x0ac911d4, 0x10c6104f, 0xf81debf6, 0x817796e7, 0x69ac6d5e,\n    0x25ce42c6, 0xcd15b97f, 0xb47fc46e, 0x5ca43fd7, 0x46ab3e4c,\n    0xae70c5f5, 0xd71ab8e4, 0x3fc1435d, 0xa202cb09, 0x4ad930b0,\n    0x33b34da1, 0xdb68b618, 0xc167b783, 0x29bc4c3a, 0x50d6312b,\n    0xb80dca92, 0x6a512082, 0x828adb3b, 0xfbe0a62a, 0x133b5d93,\n    0x09345c08, 0xe1efa7b1, 0x9885daa0, 0x705e2119, 0xed9da94d,\n    0x054652f4, 0x7c2c2fe5, 0x94f7d45c, 0x8ef8d5c7, 0x66232e7e,\n    0x1f49536f, 0xf792a8d6, 0xc68b7c84, 0x2e50873d, 0x573afa2c,\n    0xbfe10195, 0xa5ee000e, 0x4d35fbb7, 0x345f86a6, 0xdc847d1f,\n    0x4147f54b, 0xa99c0ef2, 0xd0f673e3, 0x382d885a, 0x222289c1,\n    0xcaf97278, 0xb3930f69, 0x5b48f4d0, 0x89141ec0, 0x61cfe579,\n    0x18a59868, 0xf07e63d1, 0xea71624a, 0x02aa99f3, 0x7bc0e4e2,\n    0x931b1f5b, 0x0ed8970f, 0xe6036cb6, 0x9f6911a7, 0x77b2ea1e,\n    0x6dbdeb85, 0x8566103c, 0xfc0c6d2d, 0x14d79694, 0x58b5b90c,\n    0xb06e42b5, 0xc9043fa4, 0x21dfc41d, 0x3bd0c586, 0xd30b3e3f,\n    0xaa61432e, 0x42bab897, 0xdf7930c3, 0x37a2cb7a, 0x4ec8b66b,\n    0xa6134dd2, 0xbc1c4c49, 0x54c7b7f0, 0x2dadcae1, 0xc5763158,\n    0x172adb48, 0xfff120f1, 0x869b5de0, 0x6e40a659, 0x744fa7c2,\n    0x9c945c7b, 0xe5fe216a, 0x0d25dad3, 0x90e65287, 0x783da93e,\n    0x0157d42f, 0xe98c2f96, 0xf3832e0d, 0x1b58d5b4, 0x6232a8a5,\n    0x8ae9531c},\n   {0x00000000, 0x919168ae, 0x6325a087, 0xf2b4c829, 0x874c31d4,\n    0x16dd597a, 0xe4699153, 0x75f8f9fd, 0x4f9f1373, 0xde0e7bdd,\n    0x2cbab3f4, 0xbd2bdb5a, 0xc8d322a7, 0x59424a09, 0xabf68220,\n    0x3a67ea8e, 0x9e3e27e6, 0x0faf4f48, 0xfd1b8761, 0x6c8aefcf,\n    0x19721632, 0x88e37e9c, 0x7a57b6b5, 0xebc6de1b, 0xd1a13495,\n    0x40305c3b, 0xb2849412, 0x2315fcbc, 0x56ed0541, 0xc77c6def,\n    0x35c8a5c6, 0xa459cd68, 0x7d7b3f17, 0xecea57b9, 0x1e5e9f90,\n    0x8fcff73e, 0xfa370ec3, 0x6ba6666d, 0x9912ae44, 0x0883c6ea,\n    0x32e42c64, 0xa37544ca, 0x51c18ce3, 0xc050e44d, 0xb5a81db0,\n    0x2439751e, 0xd68dbd37, 0x471cd599, 0xe34518f1, 0x72d4705f,\n    0x8060b876, 0x11f1d0d8, 0x64092925, 0xf598418b, 0x072c89a2,\n    0x96bde10c, 0xacda0b82, 0x3d4b632c, 0xcfffab05, 0x5e6ec3ab,\n    0x2b963a56, 0xba0752f8, 0x48b39ad1, 0xd922f27f, 0xfaf67e2e,\n    0x6b671680, 0x99d3dea9, 0x0842b607, 0x7dba4ffa, 0xec2b2754,\n    0x1e9fef7d, 0x8f0e87d3, 0xb5696d5d, 0x24f805f3, 0xd64ccdda,\n    0x47dda574, 0x32255c89, 0xa3b43427, 0x5100fc0e, 0xc09194a0,\n    0x64c859c8, 0xf5593166, 0x07edf94f, 0x967c91e1, 0xe384681c,\n    0x721500b2, 0x80a1c89b, 0x1130a035, 0x2b574abb, 0xbac62215,\n    0x4872ea3c, 0xd9e38292, 0xac1b7b6f, 0x3d8a13c1, 0xcf3edbe8,\n    0x5eafb346, 0x878d4139, 0x161c2997, 0xe4a8e1be, 0x75398910,\n    0x00c170ed, 0x91501843, 0x63e4d06a, 0xf275b8c4, 0xc812524a,\n    0x59833ae4, 0xab37f2cd, 0x3aa69a63, 0x4f5e639e, 0xdecf0b30,\n    0x2c7bc319, 0xbdeaabb7, 0x19b366df, 0x88220e71, 0x7a96c658,\n    0xeb07aef6, 0x9eff570b, 0x0f6e3fa5, 0xfddaf78c, 0x6c4b9f22,\n    0x562c75ac, 0xc7bd1d02, 0x3509d52b, 0xa498bd85, 0xd1604478,\n    0x40f12cd6, 0xb245e4ff, 0x23d48c51, 0xf4edfd5c, 0x657c95f2,\n    0x97c85ddb, 0x06593575, 0x73a1cc88, 0xe230a426, 0x10846c0f,\n    0x811504a1, 0xbb72ee2f, 0x2ae38681, 0xd8574ea8, 0x49c62606,\n    0x3c3edffb, 0xadafb755, 0x5f1b7f7c, 0xce8a17d2, 0x6ad3daba,\n    0xfb42b214, 0x09f67a3d, 0x98671293, 0xed9feb6e, 0x7c0e83c0,\n    0x8eba4be9, 0x1f2b2347, 0x254cc9c9, 0xb4dda167, 0x4669694e,\n    0xd7f801e0, 0xa200f81d, 0x339190b3, 0xc125589a, 0x50b43034,\n    0x8996c24b, 0x1807aae5, 0xeab362cc, 0x7b220a62, 0x0edaf39f,\n    0x9f4b9b31, 0x6dff5318, 0xfc6e3bb6, 0xc609d138, 0x5798b996,\n    0xa52c71bf, 0x34bd1911, 0x4145e0ec, 0xd0d48842, 0x2260406b,\n    0xb3f128c5, 0x17a8e5ad, 0x86398d03, 0x748d452a, 0xe51c2d84,\n    0x90e4d479, 0x0175bcd7, 0xf3c174fe, 0x62501c50, 0x5837f6de,\n    0xc9a69e70, 0x3b125659, 0xaa833ef7, 0xdf7bc70a, 0x4eeaafa4,\n    0xbc5e678d, 0x2dcf0f23, 0x0e1b8372, 0x9f8aebdc, 0x6d3e23f5,\n    0xfcaf4b5b, 0x8957b2a6, 0x18c6da08, 0xea721221, 0x7be37a8f,\n    0x41849001, 0xd015f8af, 0x22a13086, 0xb3305828, 0xc6c8a1d5,\n    0x5759c97b, 0xa5ed0152, 0x347c69fc, 0x9025a494, 0x01b4cc3a,\n    0xf3000413, 0x62916cbd, 0x17699540, 0x86f8fdee, 0x744c35c7,\n    0xe5dd5d69, 0xdfbab7e7, 0x4e2bdf49, 0xbc9f1760, 0x2d0e7fce,\n    0x58f68633, 0xc967ee9d, 0x3bd326b4, 0xaa424e1a, 0x7360bc65,\n    0xe2f1d4cb, 0x10451ce2, 0x81d4744c, 0xf42c8db1, 0x65bde51f,\n    0x97092d36, 0x06984598, 0x3cffaf16, 0xad6ec7b8, 0x5fda0f91,\n    0xce4b673f, 0xbbb39ec2, 0x2a22f66c, 0xd8963e45, 0x490756eb,\n    0xed5e9b83, 0x7ccff32d, 0x8e7b3b04, 0x1fea53aa, 0x6a12aa57,\n    0xfb83c2f9, 0x09370ad0, 0x98a6627e, 0xa2c188f0, 0x3350e05e,\n    0xc1e42877, 0x507540d9, 0x258db924, 0xb41cd18a, 0x46a819a3,\n    0xd739710d}};\n\n#endif /* W */\n\n#endif /* N == 4 */\n#if N == 5\n\n#if W == 8\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0xaf449247, 0x85f822cf, 0x2abcb088, 0xd08143df,\n    0x7fc5d198, 0x55796110, 0xfa3df357, 0x7a7381ff, 0xd53713b8,\n    0xff8ba330, 0x50cf3177, 0xaaf2c220, 0x05b65067, 0x2f0ae0ef,\n    0x804e72a8, 0xf4e703fe, 0x5ba391b9, 0x711f2131, 0xde5bb376,\n    0x24664021, 0x8b22d266, 0xa19e62ee, 0x0edaf0a9, 0x8e948201,\n    0x21d01046, 0x0b6ca0ce, 0xa4283289, 0x5e15c1de, 0xf1515399,\n    0xdbede311, 0x74a97156, 0x32bf01bd, 0x9dfb93fa, 0xb7472372,\n    0x1803b135, 0xe23e4262, 0x4d7ad025, 0x67c660ad, 0xc882f2ea,\n    0x48cc8042, 0xe7881205, 0xcd34a28d, 0x627030ca, 0x984dc39d,\n    0x370951da, 0x1db5e152, 0xb2f17315, 0xc6580243, 0x691c9004,\n    0x43a0208c, 0xece4b2cb, 0x16d9419c, 0xb99dd3db, 0x93216353,\n    0x3c65f114, 0xbc2b83bc, 0x136f11fb, 0x39d3a173, 0x96973334,\n    0x6caac063, 0xc3ee5224, 0xe952e2ac, 0x461670eb, 0x657e037a,\n    0xca3a913d, 0xe08621b5, 0x4fc2b3f2, 0xb5ff40a5, 0x1abbd2e2,\n    0x3007626a, 0x9f43f02d, 0x1f0d8285, 0xb04910c2, 0x9af5a04a,\n    0x35b1320d, 0xcf8cc15a, 0x60c8531d, 0x4a74e395, 0xe53071d2,\n    0x91990084, 0x3edd92c3, 0x1461224b, 0xbb25b00c, 0x4118435b,\n    0xee5cd11c, 0xc4e06194, 0x6ba4f3d3, 0xebea817b, 0x44ae133c,\n    0x6e12a3b4, 0xc15631f3, 0x3b6bc2a4, 0x942f50e3, 0xbe93e06b,\n    0x11d7722c, 0x57c102c7, 0xf8859080, 0xd2392008, 0x7d7db24f,\n    0x87404118, 0x2804d35f, 0x02b863d7, 0xadfcf190, 0x2db28338,\n    0x82f6117f, 0xa84aa1f7, 0x070e33b0, 0xfd33c0e7, 0x527752a0,\n    0x78cbe228, 0xd78f706f, 0xa3260139, 0x0c62937e, 0x26de23f6,\n    0x899ab1b1, 0x73a742e6, 0xdce3d0a1, 0xf65f6029, 0x591bf26e,\n    0xd95580c6, 0x76111281, 0x5cada209, 0xf3e9304e, 0x09d4c319,\n    0xa690515e, 0x8c2ce1d6, 0x23687391, 0xcafc06f4, 0x65b894b3,\n    0x4f04243b, 0xe040b67c, 0x1a7d452b, 0xb539d76c, 0x9f8567e4,\n    0x30c1f5a3, 0xb08f870b, 0x1fcb154c, 0x3577a5c4, 0x9a333783,\n    0x600ec4d4, 0xcf4a5693, 0xe5f6e61b, 0x4ab2745c, 0x3e1b050a,\n    0x915f974d, 0xbbe327c5, 0x14a7b582, 0xee9a46d5, 0x41ded492,\n    0x6b62641a, 0xc426f65d, 0x446884f5, 0xeb2c16b2, 0xc190a63a,\n    0x6ed4347d, 0x94e9c72a, 0x3bad556d, 0x1111e5e5, 0xbe5577a2,\n    0xf8430749, 0x5707950e, 0x7dbb2586, 0xd2ffb7c1, 0x28c24496,\n    0x8786d6d1, 0xad3a6659, 0x027ef41e, 0x823086b6, 0x2d7414f1,\n    0x07c8a479, 0xa88c363e, 0x52b1c569, 0xfdf5572e, 0xd749e7a6,\n    0x780d75e1, 0x0ca404b7, 0xa3e096f0, 0x895c2678, 0x2618b43f,\n    0xdc254768, 0x7361d52f, 0x59dd65a7, 0xf699f7e0, 0x76d78548,\n    0xd993170f, 0xf32fa787, 0x5c6b35c0, 0xa656c697, 0x091254d0,\n    0x23aee458, 0x8cea761f, 0xaf82058e, 0x00c697c9, 0x2a7a2741,\n    0x853eb506, 0x7f034651, 0xd047d416, 0xfafb649e, 0x55bff6d9,\n    0xd5f18471, 0x7ab51636, 0x5009a6be, 0xff4d34f9, 0x0570c7ae,\n    0xaa3455e9, 0x8088e561, 0x2fcc7726, 0x5b650670, 0xf4219437,\n    0xde9d24bf, 0x71d9b6f8, 0x8be445af, 0x24a0d7e8, 0x0e1c6760,\n    0xa158f527, 0x2116878f, 0x8e5215c8, 0xa4eea540, 0x0baa3707,\n    0xf197c450, 0x5ed35617, 0x746fe69f, 0xdb2b74d8, 0x9d3d0433,\n    0x32799674, 0x18c526fc, 0xb781b4bb, 0x4dbc47ec, 0xe2f8d5ab,\n    0xc8446523, 0x6700f764, 0xe74e85cc, 0x480a178b, 0x62b6a703,\n    0xcdf23544, 0x37cfc613, 0x988b5454, 0xb237e4dc, 0x1d73769b,\n    0x69da07cd, 0xc69e958a, 0xec222502, 0x4366b745, 0xb95b4412,\n    0x161fd655, 0x3ca366dd, 0x93e7f49a, 0x13a98632, 0xbced1475,\n    0x9651a4fd, 0x391536ba, 0xc328c5ed, 0x6c6c57aa, 0x46d0e722,\n    0xe9947565},\n   {0x00000000, 0x4e890ba9, 0x9d121752, 0xd39b1cfb, 0xe15528e5,\n    0xafdc234c, 0x7c473fb7, 0x32ce341e, 0x19db578b, 0x57525c22,\n    0x84c940d9, 0xca404b70, 0xf88e7f6e, 0xb60774c7, 0x659c683c,\n    0x2b156395, 0x33b6af16, 0x7d3fa4bf, 0xaea4b844, 0xe02db3ed,\n    0xd2e387f3, 0x9c6a8c5a, 0x4ff190a1, 0x01789b08, 0x2a6df89d,\n    0x64e4f334, 0xb77fefcf, 0xf9f6e466, 0xcb38d078, 0x85b1dbd1,\n    0x562ac72a, 0x18a3cc83, 0x676d5e2c, 0x29e45585, 0xfa7f497e,\n    0xb4f642d7, 0x863876c9, 0xc8b17d60, 0x1b2a619b, 0x55a36a32,\n    0x7eb609a7, 0x303f020e, 0xe3a41ef5, 0xad2d155c, 0x9fe32142,\n    0xd16a2aeb, 0x02f13610, 0x4c783db9, 0x54dbf13a, 0x1a52fa93,\n    0xc9c9e668, 0x8740edc1, 0xb58ed9df, 0xfb07d276, 0x289cce8d,\n    0x6615c524, 0x4d00a6b1, 0x0389ad18, 0xd012b1e3, 0x9e9bba4a,\n    0xac558e54, 0xe2dc85fd, 0x31479906, 0x7fce92af, 0xcedabc58,\n    0x8053b7f1, 0x53c8ab0a, 0x1d41a0a3, 0x2f8f94bd, 0x61069f14,\n    0xb29d83ef, 0xfc148846, 0xd701ebd3, 0x9988e07a, 0x4a13fc81,\n    0x049af728, 0x3654c336, 0x78ddc89f, 0xab46d464, 0xe5cfdfcd,\n    0xfd6c134e, 0xb3e518e7, 0x607e041c, 0x2ef70fb5, 0x1c393bab,\n    0x52b03002, 0x812b2cf9, 0xcfa22750, 0xe4b744c5, 0xaa3e4f6c,\n    0x79a55397, 0x372c583e, 0x05e26c20, 0x4b6b6789, 0x98f07b72,\n    0xd67970db, 0xa9b7e274, 0xe73ee9dd, 0x34a5f526, 0x7a2cfe8f,\n    0x48e2ca91, 0x066bc138, 0xd5f0ddc3, 0x9b79d66a, 0xb06cb5ff,\n    0xfee5be56, 0x2d7ea2ad, 0x63f7a904, 0x51399d1a, 0x1fb096b3,\n    0xcc2b8a48, 0x82a281e1, 0x9a014d62, 0xd48846cb, 0x07135a30,\n    0x499a5199, 0x7b546587, 0x35dd6e2e, 0xe64672d5, 0xa8cf797c,\n    0x83da1ae9, 0xcd531140, 0x1ec80dbb, 0x50410612, 0x628f320c,\n    0x2c0639a5, 0xff9d255e, 0xb1142ef7, 0x46c47ef1, 0x084d7558,\n    0xdbd669a3, 0x955f620a, 0xa7915614, 0xe9185dbd, 0x3a834146,\n    0x740a4aef, 0x5f1f297a, 0x119622d3, 0xc20d3e28, 0x8c843581,\n    0xbe4a019f, 0xf0c30a36, 0x235816cd, 0x6dd11d64, 0x7572d1e7,\n    0x3bfbda4e, 0xe860c6b5, 0xa6e9cd1c, 0x9427f902, 0xdaaef2ab,\n    0x0935ee50, 0x47bce5f9, 0x6ca9866c, 0x22208dc5, 0xf1bb913e,\n    0xbf329a97, 0x8dfcae89, 0xc375a520, 0x10eeb9db, 0x5e67b272,\n    0x21a920dd, 0x6f202b74, 0xbcbb378f, 0xf2323c26, 0xc0fc0838,\n    0x8e750391, 0x5dee1f6a, 0x136714c3, 0x38727756, 0x76fb7cff,\n    0xa5606004, 0xebe96bad, 0xd9275fb3, 0x97ae541a, 0x443548e1,\n    0x0abc4348, 0x121f8fcb, 0x5c968462, 0x8f0d9899, 0xc1849330,\n    0xf34aa72e, 0xbdc3ac87, 0x6e58b07c, 0x20d1bbd5, 0x0bc4d840,\n    0x454dd3e9, 0x96d6cf12, 0xd85fc4bb, 0xea91f0a5, 0xa418fb0c,\n    0x7783e7f7, 0x390aec5e, 0x881ec2a9, 0xc697c900, 0x150cd5fb,\n    0x5b85de52, 0x694bea4c, 0x27c2e1e5, 0xf459fd1e, 0xbad0f6b7,\n    0x91c59522, 0xdf4c9e8b, 0x0cd78270, 0x425e89d9, 0x7090bdc7,\n    0x3e19b66e, 0xed82aa95, 0xa30ba13c, 0xbba86dbf, 0xf5216616,\n    0x26ba7aed, 0x68337144, 0x5afd455a, 0x14744ef3, 0xc7ef5208,\n    0x896659a1, 0xa2733a34, 0xecfa319d, 0x3f612d66, 0x71e826cf,\n    0x432612d1, 0x0daf1978, 0xde340583, 0x90bd0e2a, 0xef739c85,\n    0xa1fa972c, 0x72618bd7, 0x3ce8807e, 0x0e26b460, 0x40afbfc9,\n    0x9334a332, 0xddbda89b, 0xf6a8cb0e, 0xb821c0a7, 0x6bbadc5c,\n    0x2533d7f5, 0x17fde3eb, 0x5974e842, 0x8aeff4b9, 0xc466ff10,\n    0xdcc53393, 0x924c383a, 0x41d724c1, 0x0f5e2f68, 0x3d901b76,\n    0x731910df, 0xa0820c24, 0xee0b078d, 0xc51e6418, 0x8b976fb1,\n    0x580c734a, 0x168578e3, 0x244b4cfd, 0x6ac24754, 0xb9595baf,\n    0xf7d05006},\n   {0x00000000, 0x8d88fde2, 0xc060fd85, 0x4de80067, 0x5bb0fd4b,\n    0xd63800a9, 0x9bd000ce, 0x1658fd2c, 0xb761fa96, 0x3ae90774,\n    0x77010713, 0xfa89faf1, 0xecd107dd, 0x6159fa3f, 0x2cb1fa58,\n    0xa13907ba, 0xb5b2f36d, 0x383a0e8f, 0x75d20ee8, 0xf85af30a,\n    0xee020e26, 0x638af3c4, 0x2e62f3a3, 0xa3ea0e41, 0x02d309fb,\n    0x8f5bf419, 0xc2b3f47e, 0x4f3b099c, 0x5963f4b0, 0xd4eb0952,\n    0x99030935, 0x148bf4d7, 0xb014e09b, 0x3d9c1d79, 0x70741d1e,\n    0xfdfce0fc, 0xeba41dd0, 0x662ce032, 0x2bc4e055, 0xa64c1db7,\n    0x07751a0d, 0x8afde7ef, 0xc715e788, 0x4a9d1a6a, 0x5cc5e746,\n    0xd14d1aa4, 0x9ca51ac3, 0x112de721, 0x05a613f6, 0x882eee14,\n    0xc5c6ee73, 0x484e1391, 0x5e16eebd, 0xd39e135f, 0x9e761338,\n    0x13feeeda, 0xb2c7e960, 0x3f4f1482, 0x72a714e5, 0xff2fe907,\n    0xe977142b, 0x64ffe9c9, 0x2917e9ae, 0xa49f144c, 0xbb58c777,\n    0x36d03a95, 0x7b383af2, 0xf6b0c710, 0xe0e83a3c, 0x6d60c7de,\n    0x2088c7b9, 0xad003a5b, 0x0c393de1, 0x81b1c003, 0xcc59c064,\n    0x41d13d86, 0x5789c0aa, 0xda013d48, 0x97e93d2f, 0x1a61c0cd,\n    0x0eea341a, 0x8362c9f8, 0xce8ac99f, 0x4302347d, 0x555ac951,\n    0xd8d234b3, 0x953a34d4, 0x18b2c936, 0xb98bce8c, 0x3403336e,\n    0x79eb3309, 0xf463ceeb, 0xe23b33c7, 0x6fb3ce25, 0x225bce42,\n    0xafd333a0, 0x0b4c27ec, 0x86c4da0e, 0xcb2cda69, 0x46a4278b,\n    0x50fcdaa7, 0xdd742745, 0x909c2722, 0x1d14dac0, 0xbc2ddd7a,\n    0x31a52098, 0x7c4d20ff, 0xf1c5dd1d, 0xe79d2031, 0x6a15ddd3,\n    0x27fdddb4, 0xaa752056, 0xbefed481, 0x33762963, 0x7e9e2904,\n    0xf316d4e6, 0xe54e29ca, 0x68c6d428, 0x252ed44f, 0xa8a629ad,\n    0x099f2e17, 0x8417d3f5, 0xc9ffd392, 0x44772e70, 0x522fd35c,\n    0xdfa72ebe, 0x924f2ed9, 0x1fc7d33b, 0xadc088af, 0x2048754d,\n    0x6da0752a, 0xe02888c8, 0xf67075e4, 0x7bf88806, 0x36108861,\n    0xbb987583, 0x1aa17239, 0x97298fdb, 0xdac18fbc, 0x5749725e,\n    0x41118f72, 0xcc997290, 0x817172f7, 0x0cf98f15, 0x18727bc2,\n    0x95fa8620, 0xd8128647, 0x559a7ba5, 0x43c28689, 0xce4a7b6b,\n    0x83a27b0c, 0x0e2a86ee, 0xaf138154, 0x229b7cb6, 0x6f737cd1,\n    0xe2fb8133, 0xf4a37c1f, 0x792b81fd, 0x34c3819a, 0xb94b7c78,\n    0x1dd46834, 0x905c95d6, 0xddb495b1, 0x503c6853, 0x4664957f,\n    0xcbec689d, 0x860468fa, 0x0b8c9518, 0xaab592a2, 0x273d6f40,\n    0x6ad56f27, 0xe75d92c5, 0xf1056fe9, 0x7c8d920b, 0x3165926c,\n    0xbced6f8e, 0xa8669b59, 0x25ee66bb, 0x680666dc, 0xe58e9b3e,\n    0xf3d66612, 0x7e5e9bf0, 0x33b69b97, 0xbe3e6675, 0x1f0761cf,\n    0x928f9c2d, 0xdf679c4a, 0x52ef61a8, 0x44b79c84, 0xc93f6166,\n    0x84d76101, 0x095f9ce3, 0x16984fd8, 0x9b10b23a, 0xd6f8b25d,\n    0x5b704fbf, 0x4d28b293, 0xc0a04f71, 0x8d484f16, 0x00c0b2f4,\n    0xa1f9b54e, 0x2c7148ac, 0x619948cb, 0xec11b529, 0xfa494805,\n    0x77c1b5e7, 0x3a29b580, 0xb7a14862, 0xa32abcb5, 0x2ea24157,\n    0x634a4130, 0xeec2bcd2, 0xf89a41fe, 0x7512bc1c, 0x38fabc7b,\n    0xb5724199, 0x144b4623, 0x99c3bbc1, 0xd42bbba6, 0x59a34644,\n    0x4ffbbb68, 0xc273468a, 0x8f9b46ed, 0x0213bb0f, 0xa68caf43,\n    0x2b0452a1, 0x66ec52c6, 0xeb64af24, 0xfd3c5208, 0x70b4afea,\n    0x3d5caf8d, 0xb0d4526f, 0x11ed55d5, 0x9c65a837, 0xd18da850,\n    0x5c0555b2, 0x4a5da89e, 0xc7d5557c, 0x8a3d551b, 0x07b5a8f9,\n    0x133e5c2e, 0x9eb6a1cc, 0xd35ea1ab, 0x5ed65c49, 0x488ea165,\n    0xc5065c87, 0x88ee5ce0, 0x0566a102, 0xa45fa6b8, 0x29d75b5a,\n    0x643f5b3d, 0xe9b7a6df, 0xffef5bf3, 0x7267a611, 0x3f8fa676,\n    0xb2075b94},\n   {0x00000000, 0x80f0171f, 0xda91287f, 0x5a613f60, 0x6e5356bf,\n    0xeea341a0, 0xb4c27ec0, 0x343269df, 0xdca6ad7e, 0x5c56ba61,\n    0x06378501, 0x86c7921e, 0xb2f5fbc1, 0x3205ecde, 0x6864d3be,\n    0xe894c4a1, 0x623c5cbd, 0xe2cc4ba2, 0xb8ad74c2, 0x385d63dd,\n    0x0c6f0a02, 0x8c9f1d1d, 0xd6fe227d, 0x560e3562, 0xbe9af1c3,\n    0x3e6ae6dc, 0x640bd9bc, 0xe4fbcea3, 0xd0c9a77c, 0x5039b063,\n    0x0a588f03, 0x8aa8981c, 0xc478b97a, 0x4488ae65, 0x1ee99105,\n    0x9e19861a, 0xaa2befc5, 0x2adbf8da, 0x70bac7ba, 0xf04ad0a5,\n    0x18de1404, 0x982e031b, 0xc24f3c7b, 0x42bf2b64, 0x768d42bb,\n    0xf67d55a4, 0xac1c6ac4, 0x2cec7ddb, 0xa644e5c7, 0x26b4f2d8,\n    0x7cd5cdb8, 0xfc25daa7, 0xc817b378, 0x48e7a467, 0x12869b07,\n    0x92768c18, 0x7ae248b9, 0xfa125fa6, 0xa07360c6, 0x208377d9,\n    0x14b11e06, 0x94410919, 0xce203679, 0x4ed02166, 0x538074b5,\n    0xd37063aa, 0x89115cca, 0x09e14bd5, 0x3dd3220a, 0xbd233515,\n    0xe7420a75, 0x67b21d6a, 0x8f26d9cb, 0x0fd6ced4, 0x55b7f1b4,\n    0xd547e6ab, 0xe1758f74, 0x6185986b, 0x3be4a70b, 0xbb14b014,\n    0x31bc2808, 0xb14c3f17, 0xeb2d0077, 0x6bdd1768, 0x5fef7eb7,\n    0xdf1f69a8, 0x857e56c8, 0x058e41d7, 0xed1a8576, 0x6dea9269,\n    0x378bad09, 0xb77bba16, 0x8349d3c9, 0x03b9c4d6, 0x59d8fbb6,\n    0xd928eca9, 0x97f8cdcf, 0x1708dad0, 0x4d69e5b0, 0xcd99f2af,\n    0xf9ab9b70, 0x795b8c6f, 0x233ab30f, 0xa3caa410, 0x4b5e60b1,\n    0xcbae77ae, 0x91cf48ce, 0x113f5fd1, 0x250d360e, 0xa5fd2111,\n    0xff9c1e71, 0x7f6c096e, 0xf5c49172, 0x7534866d, 0x2f55b90d,\n    0xafa5ae12, 0x9b97c7cd, 0x1b67d0d2, 0x4106efb2, 0xc1f6f8ad,\n    0x29623c0c, 0xa9922b13, 0xf3f31473, 0x7303036c, 0x47316ab3,\n    0xc7c17dac, 0x9da042cc, 0x1d5055d3, 0xa700e96a, 0x27f0fe75,\n    0x7d91c115, 0xfd61d60a, 0xc953bfd5, 0x49a3a8ca, 0x13c297aa,\n    0x933280b5, 0x7ba64414, 0xfb56530b, 0xa1376c6b, 0x21c77b74,\n    0x15f512ab, 0x950505b4, 0xcf643ad4, 0x4f942dcb, 0xc53cb5d7,\n    0x45cca2c8, 0x1fad9da8, 0x9f5d8ab7, 0xab6fe368, 0x2b9ff477,\n    0x71fecb17, 0xf10edc08, 0x199a18a9, 0x996a0fb6, 0xc30b30d6,\n    0x43fb27c9, 0x77c94e16, 0xf7395909, 0xad586669, 0x2da87176,\n    0x63785010, 0xe388470f, 0xb9e9786f, 0x39196f70, 0x0d2b06af,\n    0x8ddb11b0, 0xd7ba2ed0, 0x574a39cf, 0xbfdefd6e, 0x3f2eea71,\n    0x654fd511, 0xe5bfc20e, 0xd18dabd1, 0x517dbcce, 0x0b1c83ae,\n    0x8bec94b1, 0x01440cad, 0x81b41bb2, 0xdbd524d2, 0x5b2533cd,\n    0x6f175a12, 0xefe74d0d, 0xb586726d, 0x35766572, 0xdde2a1d3,\n    0x5d12b6cc, 0x077389ac, 0x87839eb3, 0xb3b1f76c, 0x3341e073,\n    0x6920df13, 0xe9d0c80c, 0xf4809ddf, 0x74708ac0, 0x2e11b5a0,\n    0xaee1a2bf, 0x9ad3cb60, 0x1a23dc7f, 0x4042e31f, 0xc0b2f400,\n    0x282630a1, 0xa8d627be, 0xf2b718de, 0x72470fc1, 0x4675661e,\n    0xc6857101, 0x9ce44e61, 0x1c14597e, 0x96bcc162, 0x164cd67d,\n    0x4c2de91d, 0xccddfe02, 0xf8ef97dd, 0x781f80c2, 0x227ebfa2,\n    0xa28ea8bd, 0x4a1a6c1c, 0xcaea7b03, 0x908b4463, 0x107b537c,\n    0x24493aa3, 0xa4b92dbc, 0xfed812dc, 0x7e2805c3, 0x30f824a5,\n    0xb00833ba, 0xea690cda, 0x6a991bc5, 0x5eab721a, 0xde5b6505,\n    0x843a5a65, 0x04ca4d7a, 0xec5e89db, 0x6cae9ec4, 0x36cfa1a4,\n    0xb63fb6bb, 0x820ddf64, 0x02fdc87b, 0x589cf71b, 0xd86ce004,\n    0x52c47818, 0xd2346f07, 0x88555067, 0x08a54778, 0x3c972ea7,\n    0xbc6739b8, 0xe60606d8, 0x66f611c7, 0x8e62d566, 0x0e92c279,\n    0x54f3fd19, 0xd403ea06, 0xe03183d9, 0x60c194c6, 0x3aa0aba6,\n    0xba50bcb9},\n   {0x00000000, 0x9570d495, 0xf190af6b, 0x64e07bfe, 0x38505897,\n    0xad208c02, 0xc9c0f7fc, 0x5cb02369, 0x70a0b12e, 0xe5d065bb,\n    0x81301e45, 0x1440cad0, 0x48f0e9b9, 0xdd803d2c, 0xb96046d2,\n    0x2c109247, 0xe141625c, 0x7431b6c9, 0x10d1cd37, 0x85a119a2,\n    0xd9113acb, 0x4c61ee5e, 0x288195a0, 0xbdf14135, 0x91e1d372,\n    0x049107e7, 0x60717c19, 0xf501a88c, 0xa9b18be5, 0x3cc15f70,\n    0x5821248e, 0xcd51f01b, 0x19f3c2f9, 0x8c83166c, 0xe8636d92,\n    0x7d13b907, 0x21a39a6e, 0xb4d34efb, 0xd0333505, 0x4543e190,\n    0x695373d7, 0xfc23a742, 0x98c3dcbc, 0x0db30829, 0x51032b40,\n    0xc473ffd5, 0xa093842b, 0x35e350be, 0xf8b2a0a5, 0x6dc27430,\n    0x09220fce, 0x9c52db5b, 0xc0e2f832, 0x55922ca7, 0x31725759,\n    0xa40283cc, 0x8812118b, 0x1d62c51e, 0x7982bee0, 0xecf26a75,\n    0xb042491c, 0x25329d89, 0x41d2e677, 0xd4a232e2, 0x33e785f2,\n    0xa6975167, 0xc2772a99, 0x5707fe0c, 0x0bb7dd65, 0x9ec709f0,\n    0xfa27720e, 0x6f57a69b, 0x434734dc, 0xd637e049, 0xb2d79bb7,\n    0x27a74f22, 0x7b176c4b, 0xee67b8de, 0x8a87c320, 0x1ff717b5,\n    0xd2a6e7ae, 0x47d6333b, 0x233648c5, 0xb6469c50, 0xeaf6bf39,\n    0x7f866bac, 0x1b661052, 0x8e16c4c7, 0xa2065680, 0x37768215,\n    0x5396f9eb, 0xc6e62d7e, 0x9a560e17, 0x0f26da82, 0x6bc6a17c,\n    0xfeb675e9, 0x2a14470b, 0xbf64939e, 0xdb84e860, 0x4ef43cf5,\n    0x12441f9c, 0x8734cb09, 0xe3d4b0f7, 0x76a46462, 0x5ab4f625,\n    0xcfc422b0, 0xab24594e, 0x3e548ddb, 0x62e4aeb2, 0xf7947a27,\n    0x937401d9, 0x0604d54c, 0xcb552557, 0x5e25f1c2, 0x3ac58a3c,\n    0xafb55ea9, 0xf3057dc0, 0x6675a955, 0x0295d2ab, 0x97e5063e,\n    0xbbf59479, 0x2e8540ec, 0x4a653b12, 0xdf15ef87, 0x83a5ccee,\n    0x16d5187b, 0x72356385, 0xe745b710, 0x67cf0be4, 0xf2bfdf71,\n    0x965fa48f, 0x032f701a, 0x5f9f5373, 0xcaef87e6, 0xae0ffc18,\n    0x3b7f288d, 0x176fbaca, 0x821f6e5f, 0xe6ff15a1, 0x738fc134,\n    0x2f3fe25d, 0xba4f36c8, 0xdeaf4d36, 0x4bdf99a3, 0x868e69b8,\n    0x13febd2d, 0x771ec6d3, 0xe26e1246, 0xbede312f, 0x2baee5ba,\n    0x4f4e9e44, 0xda3e4ad1, 0xf62ed896, 0x635e0c03, 0x07be77fd,\n    0x92cea368, 0xce7e8001, 0x5b0e5494, 0x3fee2f6a, 0xaa9efbff,\n    0x7e3cc91d, 0xeb4c1d88, 0x8fac6676, 0x1adcb2e3, 0x466c918a,\n    0xd31c451f, 0xb7fc3ee1, 0x228cea74, 0x0e9c7833, 0x9becaca6,\n    0xff0cd758, 0x6a7c03cd, 0x36cc20a4, 0xa3bcf431, 0xc75c8fcf,\n    0x522c5b5a, 0x9f7dab41, 0x0a0d7fd4, 0x6eed042a, 0xfb9dd0bf,\n    0xa72df3d6, 0x325d2743, 0x56bd5cbd, 0xc3cd8828, 0xefdd1a6f,\n    0x7aadcefa, 0x1e4db504, 0x8b3d6191, 0xd78d42f8, 0x42fd966d,\n    0x261ded93, 0xb36d3906, 0x54288e16, 0xc1585a83, 0xa5b8217d,\n    0x30c8f5e8, 0x6c78d681, 0xf9080214, 0x9de879ea, 0x0898ad7f,\n    0x24883f38, 0xb1f8ebad, 0xd5189053, 0x406844c6, 0x1cd867af,\n    0x89a8b33a, 0xed48c8c4, 0x78381c51, 0xb569ec4a, 0x201938df,\n    0x44f94321, 0xd18997b4, 0x8d39b4dd, 0x18496048, 0x7ca91bb6,\n    0xe9d9cf23, 0xc5c95d64, 0x50b989f1, 0x3459f20f, 0xa129269a,\n    0xfd9905f3, 0x68e9d166, 0x0c09aa98, 0x99797e0d, 0x4ddb4cef,\n    0xd8ab987a, 0xbc4be384, 0x293b3711, 0x758b1478, 0xe0fbc0ed,\n    0x841bbb13, 0x116b6f86, 0x3d7bfdc1, 0xa80b2954, 0xcceb52aa,\n    0x599b863f, 0x052ba556, 0x905b71c3, 0xf4bb0a3d, 0x61cbdea8,\n    0xac9a2eb3, 0x39eafa26, 0x5d0a81d8, 0xc87a554d, 0x94ca7624,\n    0x01baa2b1, 0x655ad94f, 0xf02a0dda, 0xdc3a9f9d, 0x494a4b08,\n    0x2daa30f6, 0xb8dae463, 0xe46ac70a, 0x711a139f, 0x15fa6861,\n    0x808abcf4},\n   {0x00000000, 0xcf9e17c8, 0x444d29d1, 0x8bd33e19, 0x889a53a2,\n    0x4704446a, 0xccd77a73, 0x03496dbb, 0xca45a105, 0x05dbb6cd,\n    0x8e0888d4, 0x41969f1c, 0x42dff2a7, 0x8d41e56f, 0x0692db76,\n    0xc90cccbe, 0x4ffa444b, 0x80645383, 0x0bb76d9a, 0xc4297a52,\n    0xc76017e9, 0x08fe0021, 0x832d3e38, 0x4cb329f0, 0x85bfe54e,\n    0x4a21f286, 0xc1f2cc9f, 0x0e6cdb57, 0x0d25b6ec, 0xc2bba124,\n    0x49689f3d, 0x86f688f5, 0x9ff48896, 0x506a9f5e, 0xdbb9a147,\n    0x1427b68f, 0x176edb34, 0xd8f0ccfc, 0x5323f2e5, 0x9cbde52d,\n    0x55b12993, 0x9a2f3e5b, 0x11fc0042, 0xde62178a, 0xdd2b7a31,\n    0x12b56df9, 0x996653e0, 0x56f84428, 0xd00eccdd, 0x1f90db15,\n    0x9443e50c, 0x5bddf2c4, 0x58949f7f, 0x970a88b7, 0x1cd9b6ae,\n    0xd347a166, 0x1a4b6dd8, 0xd5d57a10, 0x5e064409, 0x919853c1,\n    0x92d13e7a, 0x5d4f29b2, 0xd69c17ab, 0x19020063, 0xe498176d,\n    0x2b0600a5, 0xa0d53ebc, 0x6f4b2974, 0x6c0244cf, 0xa39c5307,\n    0x284f6d1e, 0xe7d17ad6, 0x2eddb668, 0xe143a1a0, 0x6a909fb9,\n    0xa50e8871, 0xa647e5ca, 0x69d9f202, 0xe20acc1b, 0x2d94dbd3,\n    0xab625326, 0x64fc44ee, 0xef2f7af7, 0x20b16d3f, 0x23f80084,\n    0xec66174c, 0x67b52955, 0xa82b3e9d, 0x6127f223, 0xaeb9e5eb,\n    0x256adbf2, 0xeaf4cc3a, 0xe9bda181, 0x2623b649, 0xadf08850,\n    0x626e9f98, 0x7b6c9ffb, 0xb4f28833, 0x3f21b62a, 0xf0bfa1e2,\n    0xf3f6cc59, 0x3c68db91, 0xb7bbe588, 0x7825f240, 0xb1293efe,\n    0x7eb72936, 0xf564172f, 0x3afa00e7, 0x39b36d5c, 0xf62d7a94,\n    0x7dfe448d, 0xb2605345, 0x3496dbb0, 0xfb08cc78, 0x70dbf261,\n    0xbf45e5a9, 0xbc0c8812, 0x73929fda, 0xf841a1c3, 0x37dfb60b,\n    0xfed37ab5, 0x314d6d7d, 0xba9e5364, 0x750044ac, 0x76492917,\n    0xb9d73edf, 0x320400c6, 0xfd9a170e, 0x1241289b, 0xdddf3f53,\n    0x560c014a, 0x99921682, 0x9adb7b39, 0x55456cf1, 0xde9652e8,\n    0x11084520, 0xd804899e, 0x179a9e56, 0x9c49a04f, 0x53d7b787,\n    0x509eda3c, 0x9f00cdf4, 0x14d3f3ed, 0xdb4de425, 0x5dbb6cd0,\n    0x92257b18, 0x19f64501, 0xd66852c9, 0xd5213f72, 0x1abf28ba,\n    0x916c16a3, 0x5ef2016b, 0x97fecdd5, 0x5860da1d, 0xd3b3e404,\n    0x1c2df3cc, 0x1f649e77, 0xd0fa89bf, 0x5b29b7a6, 0x94b7a06e,\n    0x8db5a00d, 0x422bb7c5, 0xc9f889dc, 0x06669e14, 0x052ff3af,\n    0xcab1e467, 0x4162da7e, 0x8efccdb6, 0x47f00108, 0x886e16c0,\n    0x03bd28d9, 0xcc233f11, 0xcf6a52aa, 0x00f44562, 0x8b277b7b,\n    0x44b96cb3, 0xc24fe446, 0x0dd1f38e, 0x8602cd97, 0x499cda5f,\n    0x4ad5b7e4, 0x854ba02c, 0x0e989e35, 0xc10689fd, 0x080a4543,\n    0xc794528b, 0x4c476c92, 0x83d97b5a, 0x809016e1, 0x4f0e0129,\n    0xc4dd3f30, 0x0b4328f8, 0xf6d93ff6, 0x3947283e, 0xb2941627,\n    0x7d0a01ef, 0x7e436c54, 0xb1dd7b9c, 0x3a0e4585, 0xf590524d,\n    0x3c9c9ef3, 0xf302893b, 0x78d1b722, 0xb74fa0ea, 0xb406cd51,\n    0x7b98da99, 0xf04be480, 0x3fd5f348, 0xb9237bbd, 0x76bd6c75,\n    0xfd6e526c, 0x32f045a4, 0x31b9281f, 0xfe273fd7, 0x75f401ce,\n    0xba6a1606, 0x7366dab8, 0xbcf8cd70, 0x372bf369, 0xf8b5e4a1,\n    0xfbfc891a, 0x34629ed2, 0xbfb1a0cb, 0x702fb703, 0x692db760,\n    0xa6b3a0a8, 0x2d609eb1, 0xe2fe8979, 0xe1b7e4c2, 0x2e29f30a,\n    0xa5facd13, 0x6a64dadb, 0xa3681665, 0x6cf601ad, 0xe7253fb4,\n    0x28bb287c, 0x2bf245c7, 0xe46c520f, 0x6fbf6c16, 0xa0217bde,\n    0x26d7f32b, 0xe949e4e3, 0x629adafa, 0xad04cd32, 0xae4da089,\n    0x61d3b741, 0xea008958, 0x259e9e90, 0xec92522e, 0x230c45e6,\n    0xa8df7bff, 0x67416c37, 0x6408018c, 0xab961644, 0x2045285d,\n    0xefdb3f95},\n   {0x00000000, 0x24825136, 0x4904a26c, 0x6d86f35a, 0x920944d8,\n    0xb68b15ee, 0xdb0de6b4, 0xff8fb782, 0xff638ff1, 0xdbe1dec7,\n    0xb6672d9d, 0x92e57cab, 0x6d6acb29, 0x49e89a1f, 0x246e6945,\n    0x00ec3873, 0x25b619a3, 0x01344895, 0x6cb2bbcf, 0x4830eaf9,\n    0xb7bf5d7b, 0x933d0c4d, 0xfebbff17, 0xda39ae21, 0xdad59652,\n    0xfe57c764, 0x93d1343e, 0xb7536508, 0x48dcd28a, 0x6c5e83bc,\n    0x01d870e6, 0x255a21d0, 0x4b6c3346, 0x6fee6270, 0x0268912a,\n    0x26eac01c, 0xd965779e, 0xfde726a8, 0x9061d5f2, 0xb4e384c4,\n    0xb40fbcb7, 0x908ded81, 0xfd0b1edb, 0xd9894fed, 0x2606f86f,\n    0x0284a959, 0x6f025a03, 0x4b800b35, 0x6eda2ae5, 0x4a587bd3,\n    0x27de8889, 0x035cd9bf, 0xfcd36e3d, 0xd8513f0b, 0xb5d7cc51,\n    0x91559d67, 0x91b9a514, 0xb53bf422, 0xd8bd0778, 0xfc3f564e,\n    0x03b0e1cc, 0x2732b0fa, 0x4ab443a0, 0x6e361296, 0x96d8668c,\n    0xb25a37ba, 0xdfdcc4e0, 0xfb5e95d6, 0x04d12254, 0x20537362,\n    0x4dd58038, 0x6957d10e, 0x69bbe97d, 0x4d39b84b, 0x20bf4b11,\n    0x043d1a27, 0xfbb2ada5, 0xdf30fc93, 0xb2b60fc9, 0x96345eff,\n    0xb36e7f2f, 0x97ec2e19, 0xfa6add43, 0xdee88c75, 0x21673bf7,\n    0x05e56ac1, 0x6863999b, 0x4ce1c8ad, 0x4c0df0de, 0x688fa1e8,\n    0x050952b2, 0x218b0384, 0xde04b406, 0xfa86e530, 0x9700166a,\n    0xb382475c, 0xddb455ca, 0xf93604fc, 0x94b0f7a6, 0xb032a690,\n    0x4fbd1112, 0x6b3f4024, 0x06b9b37e, 0x223be248, 0x22d7da3b,\n    0x06558b0d, 0x6bd37857, 0x4f512961, 0xb0de9ee3, 0x945ccfd5,\n    0xf9da3c8f, 0xdd586db9, 0xf8024c69, 0xdc801d5f, 0xb106ee05,\n    0x9584bf33, 0x6a0b08b1, 0x4e895987, 0x230faadd, 0x078dfbeb,\n    0x0761c398, 0x23e392ae, 0x4e6561f4, 0x6ae730c2, 0x95688740,\n    0xb1ead676, 0xdc6c252c, 0xf8ee741a, 0xf6c1cb59, 0xd2439a6f,\n    0xbfc56935, 0x9b473803, 0x64c88f81, 0x404adeb7, 0x2dcc2ded,\n    0x094e7cdb, 0x09a244a8, 0x2d20159e, 0x40a6e6c4, 0x6424b7f2,\n    0x9bab0070, 0xbf295146, 0xd2afa21c, 0xf62df32a, 0xd377d2fa,\n    0xf7f583cc, 0x9a737096, 0xbef121a0, 0x417e9622, 0x65fcc714,\n    0x087a344e, 0x2cf86578, 0x2c145d0b, 0x08960c3d, 0x6510ff67,\n    0x4192ae51, 0xbe1d19d3, 0x9a9f48e5, 0xf719bbbf, 0xd39bea89,\n    0xbdadf81f, 0x992fa929, 0xf4a95a73, 0xd02b0b45, 0x2fa4bcc7,\n    0x0b26edf1, 0x66a01eab, 0x42224f9d, 0x42ce77ee, 0x664c26d8,\n    0x0bcad582, 0x2f4884b4, 0xd0c73336, 0xf4456200, 0x99c3915a,\n    0xbd41c06c, 0x981be1bc, 0xbc99b08a, 0xd11f43d0, 0xf59d12e6,\n    0x0a12a564, 0x2e90f452, 0x43160708, 0x6794563e, 0x67786e4d,\n    0x43fa3f7b, 0x2e7ccc21, 0x0afe9d17, 0xf5712a95, 0xd1f37ba3,\n    0xbc7588f9, 0x98f7d9cf, 0x6019add5, 0x449bfce3, 0x291d0fb9,\n    0x0d9f5e8f, 0xf210e90d, 0xd692b83b, 0xbb144b61, 0x9f961a57,\n    0x9f7a2224, 0xbbf87312, 0xd67e8048, 0xf2fcd17e, 0x0d7366fc,\n    0x29f137ca, 0x4477c490, 0x60f595a6, 0x45afb476, 0x612de540,\n    0x0cab161a, 0x2829472c, 0xd7a6f0ae, 0xf324a198, 0x9ea252c2,\n    0xba2003f4, 0xbacc3b87, 0x9e4e6ab1, 0xf3c899eb, 0xd74ac8dd,\n    0x28c57f5f, 0x0c472e69, 0x61c1dd33, 0x45438c05, 0x2b759e93,\n    0x0ff7cfa5, 0x62713cff, 0x46f36dc9, 0xb97cda4b, 0x9dfe8b7d,\n    0xf0787827, 0xd4fa2911, 0xd4161162, 0xf0944054, 0x9d12b30e,\n    0xb990e238, 0x461f55ba, 0x629d048c, 0x0f1bf7d6, 0x2b99a6e0,\n    0x0ec38730, 0x2a41d606, 0x47c7255c, 0x6345746a, 0x9ccac3e8,\n    0xb84892de, 0xd5ce6184, 0xf14c30b2, 0xf1a008c1, 0xd52259f7,\n    0xb8a4aaad, 0x9c26fb9b, 0x63a94c19, 0x472b1d2f, 0x2aadee75,\n    0x0e2fbf43},\n   {0x00000000, 0x36f290f3, 0x6de521e6, 0x5b17b115, 0xdbca43cc,\n    0xed38d33f, 0xb62f622a, 0x80ddf2d9, 0x6ce581d9, 0x5a17112a,\n    0x0100a03f, 0x37f230cc, 0xb72fc215, 0x81dd52e6, 0xdacae3f3,\n    0xec387300, 0xd9cb03b2, 0xef399341, 0xb42e2254, 0x82dcb2a7,\n    0x0201407e, 0x34f3d08d, 0x6fe46198, 0x5916f16b, 0xb52e826b,\n    0x83dc1298, 0xd8cba38d, 0xee39337e, 0x6ee4c1a7, 0x58165154,\n    0x0301e041, 0x35f370b2, 0x68e70125, 0x5e1591d6, 0x050220c3,\n    0x33f0b030, 0xb32d42e9, 0x85dfd21a, 0xdec8630f, 0xe83af3fc,\n    0x040280fc, 0x32f0100f, 0x69e7a11a, 0x5f1531e9, 0xdfc8c330,\n    0xe93a53c3, 0xb22de2d6, 0x84df7225, 0xb12c0297, 0x87de9264,\n    0xdcc92371, 0xea3bb382, 0x6ae6415b, 0x5c14d1a8, 0x070360bd,\n    0x31f1f04e, 0xddc9834e, 0xeb3b13bd, 0xb02ca2a8, 0x86de325b,\n    0x0603c082, 0x30f15071, 0x6be6e164, 0x5d147197, 0xd1ce024a,\n    0xe73c92b9, 0xbc2b23ac, 0x8ad9b35f, 0x0a044186, 0x3cf6d175,\n    0x67e16060, 0x5113f093, 0xbd2b8393, 0x8bd91360, 0xd0cea275,\n    0xe63c3286, 0x66e1c05f, 0x501350ac, 0x0b04e1b9, 0x3df6714a,\n    0x080501f8, 0x3ef7910b, 0x65e0201e, 0x5312b0ed, 0xd3cf4234,\n    0xe53dd2c7, 0xbe2a63d2, 0x88d8f321, 0x64e08021, 0x521210d2,\n    0x0905a1c7, 0x3ff73134, 0xbf2ac3ed, 0x89d8531e, 0xd2cfe20b,\n    0xe43d72f8, 0xb929036f, 0x8fdb939c, 0xd4cc2289, 0xe23eb27a,\n    0x62e340a3, 0x5411d050, 0x0f066145, 0x39f4f1b6, 0xd5cc82b6,\n    0xe33e1245, 0xb829a350, 0x8edb33a3, 0x0e06c17a, 0x38f45189,\n    0x63e3e09c, 0x5511706f, 0x60e200dd, 0x5610902e, 0x0d07213b,\n    0x3bf5b1c8, 0xbb284311, 0x8ddad3e2, 0xd6cd62f7, 0xe03ff204,\n    0x0c078104, 0x3af511f7, 0x61e2a0e2, 0x57103011, 0xd7cdc2c8,\n    0xe13f523b, 0xba28e32e, 0x8cda73dd, 0x78ed02d5, 0x4e1f9226,\n    0x15082333, 0x23fab3c0, 0xa3274119, 0x95d5d1ea, 0xcec260ff,\n    0xf830f00c, 0x1408830c, 0x22fa13ff, 0x79eda2ea, 0x4f1f3219,\n    0xcfc2c0c0, 0xf9305033, 0xa227e126, 0x94d571d5, 0xa1260167,\n    0x97d49194, 0xccc32081, 0xfa31b072, 0x7aec42ab, 0x4c1ed258,\n    0x1709634d, 0x21fbf3be, 0xcdc380be, 0xfb31104d, 0xa026a158,\n    0x96d431ab, 0x1609c372, 0x20fb5381, 0x7bece294, 0x4d1e7267,\n    0x100a03f0, 0x26f89303, 0x7def2216, 0x4b1db2e5, 0xcbc0403c,\n    0xfd32d0cf, 0xa62561da, 0x90d7f129, 0x7cef8229, 0x4a1d12da,\n    0x110aa3cf, 0x27f8333c, 0xa725c1e5, 0x91d75116, 0xcac0e003,\n    0xfc3270f0, 0xc9c10042, 0xff3390b1, 0xa42421a4, 0x92d6b157,\n    0x120b438e, 0x24f9d37d, 0x7fee6268, 0x491cf29b, 0xa524819b,\n    0x93d61168, 0xc8c1a07d, 0xfe33308e, 0x7eeec257, 0x481c52a4,\n    0x130be3b1, 0x25f97342, 0xa923009f, 0x9fd1906c, 0xc4c62179,\n    0xf234b18a, 0x72e94353, 0x441bd3a0, 0x1f0c62b5, 0x29fef246,\n    0xc5c68146, 0xf33411b5, 0xa823a0a0, 0x9ed13053, 0x1e0cc28a,\n    0x28fe5279, 0x73e9e36c, 0x451b739f, 0x70e8032d, 0x461a93de,\n    0x1d0d22cb, 0x2bffb238, 0xab2240e1, 0x9dd0d012, 0xc6c76107,\n    0xf035f1f4, 0x1c0d82f4, 0x2aff1207, 0x71e8a312, 0x471a33e1,\n    0xc7c7c138, 0xf13551cb, 0xaa22e0de, 0x9cd0702d, 0xc1c401ba,\n    0xf7369149, 0xac21205c, 0x9ad3b0af, 0x1a0e4276, 0x2cfcd285,\n    0x77eb6390, 0x4119f363, 0xad218063, 0x9bd31090, 0xc0c4a185,\n    0xf6363176, 0x76ebc3af, 0x4019535c, 0x1b0ee249, 0x2dfc72ba,\n    0x180f0208, 0x2efd92fb, 0x75ea23ee, 0x4318b31d, 0xc3c541c4,\n    0xf537d137, 0xae206022, 0x98d2f0d1, 0x74ea83d1, 0x42181322,\n    0x190fa237, 0x2ffd32c4, 0xaf20c01d, 0x99d250ee, 0xc2c5e1fb,\n    0xf4377108}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x0000000000000000, 0xf390f23600000000, 0xe621e56d00000000,\n    0x15b1175b00000000, 0xcc43cadb00000000, 0x3fd338ed00000000,\n    0x2a622fb600000000, 0xd9f2dd8000000000, 0xd981e56c00000000,\n    0x2a11175a00000000, 0x3fa0000100000000, 0xcc30f23700000000,\n    0x15c22fb700000000, 0xe652dd8100000000, 0xf3e3cada00000000,\n    0x007338ec00000000, 0xb203cbd900000000, 0x419339ef00000000,\n    0x54222eb400000000, 0xa7b2dc8200000000, 0x7e40010200000000,\n    0x8dd0f33400000000, 0x9861e46f00000000, 0x6bf1165900000000,\n    0x6b822eb500000000, 0x9812dc8300000000, 0x8da3cbd800000000,\n    0x7e3339ee00000000, 0xa7c1e46e00000000, 0x5451165800000000,\n    0x41e0010300000000, 0xb270f33500000000, 0x2501e76800000000,\n    0xd691155e00000000, 0xc320020500000000, 0x30b0f03300000000,\n    0xe9422db300000000, 0x1ad2df8500000000, 0x0f63c8de00000000,\n    0xfcf33ae800000000, 0xfc80020400000000, 0x0f10f03200000000,\n    0x1aa1e76900000000, 0xe931155f00000000, 0x30c3c8df00000000,\n    0xc3533ae900000000, 0xd6e22db200000000, 0x2572df8400000000,\n    0x97022cb100000000, 0x6492de8700000000, 0x7123c9dc00000000,\n    0x82b33bea00000000, 0x5b41e66a00000000, 0xa8d1145c00000000,\n    0xbd60030700000000, 0x4ef0f13100000000, 0x4e83c9dd00000000,\n    0xbd133beb00000000, 0xa8a22cb000000000, 0x5b32de8600000000,\n    0x82c0030600000000, 0x7150f13000000000, 0x64e1e66b00000000,\n    0x9771145d00000000, 0x4a02ced100000000, 0xb9923ce700000000,\n    0xac232bbc00000000, 0x5fb3d98a00000000, 0x8641040a00000000,\n    0x75d1f63c00000000, 0x6060e16700000000, 0x93f0135100000000,\n    0x93832bbd00000000, 0x6013d98b00000000, 0x75a2ced000000000,\n    0x86323ce600000000, 0x5fc0e16600000000, 0xac50135000000000,\n    0xb9e1040b00000000, 0x4a71f63d00000000, 0xf801050800000000,\n    0x0b91f73e00000000, 0x1e20e06500000000, 0xedb0125300000000,\n    0x3442cfd300000000, 0xc7d23de500000000, 0xd2632abe00000000,\n    0x21f3d88800000000, 0x2180e06400000000, 0xd210125200000000,\n    0xc7a1050900000000, 0x3431f73f00000000, 0xedc32abf00000000,\n    0x1e53d88900000000, 0x0be2cfd200000000, 0xf8723de400000000,\n    0x6f0329b900000000, 0x9c93db8f00000000, 0x8922ccd400000000,\n    0x7ab23ee200000000, 0xa340e36200000000, 0x50d0115400000000,\n    0x4561060f00000000, 0xb6f1f43900000000, 0xb682ccd500000000,\n    0x45123ee300000000, 0x50a329b800000000, 0xa333db8e00000000,\n    0x7ac1060e00000000, 0x8951f43800000000, 0x9ce0e36300000000,\n    0x6f70115500000000, 0xdd00e26000000000, 0x2e90105600000000,\n    0x3b21070d00000000, 0xc8b1f53b00000000, 0x114328bb00000000,\n    0xe2d3da8d00000000, 0xf762cdd600000000, 0x04f23fe000000000,\n    0x0481070c00000000, 0xf711f53a00000000, 0xe2a0e26100000000,\n    0x1130105700000000, 0xc8c2cdd700000000, 0x3b523fe100000000,\n    0x2ee328ba00000000, 0xdd73da8c00000000, 0xd502ed7800000000,\n    0x26921f4e00000000, 0x3323081500000000, 0xc0b3fa2300000000,\n    0x194127a300000000, 0xead1d59500000000, 0xff60c2ce00000000,\n    0x0cf030f800000000, 0x0c83081400000000, 0xff13fa2200000000,\n    0xeaa2ed7900000000, 0x19321f4f00000000, 0xc0c0c2cf00000000,\n    0x335030f900000000, 0x26e127a200000000, 0xd571d59400000000,\n    0x670126a100000000, 0x9491d49700000000, 0x8120c3cc00000000,\n    0x72b031fa00000000, 0xab42ec7a00000000, 0x58d21e4c00000000,\n    0x4d63091700000000, 0xbef3fb2100000000, 0xbe80c3cd00000000,\n    0x4d1031fb00000000, 0x58a126a000000000, 0xab31d49600000000,\n    0x72c3091600000000, 0x8153fb2000000000, 0x94e2ec7b00000000,\n    0x67721e4d00000000, 0xf0030a1000000000, 0x0393f82600000000,\n    0x1622ef7d00000000, 0xe5b21d4b00000000, 0x3c40c0cb00000000,\n    0xcfd032fd00000000, 0xda6125a600000000, 0x29f1d79000000000,\n    0x2982ef7c00000000, 0xda121d4a00000000, 0xcfa30a1100000000,\n    0x3c33f82700000000, 0xe5c125a700000000, 0x1651d79100000000,\n    0x03e0c0ca00000000, 0xf07032fc00000000, 0x4200c1c900000000,\n    0xb19033ff00000000, 0xa42124a400000000, 0x57b1d69200000000,\n    0x8e430b1200000000, 0x7dd3f92400000000, 0x6862ee7f00000000,\n    0x9bf21c4900000000, 0x9b8124a500000000, 0x6811d69300000000,\n    0x7da0c1c800000000, 0x8e3033fe00000000, 0x57c2ee7e00000000,\n    0xa4521c4800000000, 0xb1e30b1300000000, 0x4273f92500000000,\n    0x9f0023a900000000, 0x6c90d19f00000000, 0x7921c6c400000000,\n    0x8ab134f200000000, 0x5343e97200000000, 0xa0d31b4400000000,\n    0xb5620c1f00000000, 0x46f2fe2900000000, 0x4681c6c500000000,\n    0xb51134f300000000, 0xa0a023a800000000, 0x5330d19e00000000,\n    0x8ac20c1e00000000, 0x7952fe2800000000, 0x6ce3e97300000000,\n    0x9f731b4500000000, 0x2d03e87000000000, 0xde931a4600000000,\n    0xcb220d1d00000000, 0x38b2ff2b00000000, 0xe14022ab00000000,\n    0x12d0d09d00000000, 0x0761c7c600000000, 0xf4f135f000000000,\n    0xf4820d1c00000000, 0x0712ff2a00000000, 0x12a3e87100000000,\n    0xe1331a4700000000, 0x38c1c7c700000000, 0xcb5135f100000000,\n    0xdee022aa00000000, 0x2d70d09c00000000, 0xba01c4c100000000,\n    0x499136f700000000, 0x5c2021ac00000000, 0xafb0d39a00000000,\n    0x76420e1a00000000, 0x85d2fc2c00000000, 0x9063eb7700000000,\n    0x63f3194100000000, 0x638021ad00000000, 0x9010d39b00000000,\n    0x85a1c4c000000000, 0x763136f600000000, 0xafc3eb7600000000,\n    0x5c53194000000000, 0x49e20e1b00000000, 0xba72fc2d00000000,\n    0x08020f1800000000, 0xfb92fd2e00000000, 0xee23ea7500000000,\n    0x1db3184300000000, 0xc441c5c300000000, 0x37d137f500000000,\n    0x226020ae00000000, 0xd1f0d29800000000, 0xd183ea7400000000,\n    0x2213184200000000, 0x37a20f1900000000, 0xc432fd2f00000000,\n    0x1dc020af00000000, 0xee50d29900000000, 0xfbe1c5c200000000,\n    0x087137f400000000},\n   {0x0000000000000000, 0x3651822400000000, 0x6ca2044900000000,\n    0x5af3866d00000000, 0xd844099200000000, 0xee158bb600000000,\n    0xb4e60ddb00000000, 0x82b78fff00000000, 0xf18f63ff00000000,\n    0xc7dee1db00000000, 0x9d2d67b600000000, 0xab7ce59200000000,\n    0x29cb6a6d00000000, 0x1f9ae84900000000, 0x45696e2400000000,\n    0x7338ec0000000000, 0xa319b62500000000, 0x9548340100000000,\n    0xcfbbb26c00000000, 0xf9ea304800000000, 0x7b5dbfb700000000,\n    0x4d0c3d9300000000, 0x17ffbbfe00000000, 0x21ae39da00000000,\n    0x5296d5da00000000, 0x64c757fe00000000, 0x3e34d19300000000,\n    0x086553b700000000, 0x8ad2dc4800000000, 0xbc835e6c00000000,\n    0xe670d80100000000, 0xd0215a2500000000, 0x46336c4b00000000,\n    0x7062ee6f00000000, 0x2a91680200000000, 0x1cc0ea2600000000,\n    0x9e7765d900000000, 0xa826e7fd00000000, 0xf2d5619000000000,\n    0xc484e3b400000000, 0xb7bc0fb400000000, 0x81ed8d9000000000,\n    0xdb1e0bfd00000000, 0xed4f89d900000000, 0x6ff8062600000000,\n    0x59a9840200000000, 0x035a026f00000000, 0x350b804b00000000,\n    0xe52ada6e00000000, 0xd37b584a00000000, 0x8988de2700000000,\n    0xbfd95c0300000000, 0x3d6ed3fc00000000, 0x0b3f51d800000000,\n    0x51ccd7b500000000, 0x679d559100000000, 0x14a5b99100000000,\n    0x22f43bb500000000, 0x7807bdd800000000, 0x4e563ffc00000000,\n    0xcce1b00300000000, 0xfab0322700000000, 0xa043b44a00000000,\n    0x9612366e00000000, 0x8c66d89600000000, 0xba375ab200000000,\n    0xe0c4dcdf00000000, 0xd6955efb00000000, 0x5422d10400000000,\n    0x6273532000000000, 0x3880d54d00000000, 0x0ed1576900000000,\n    0x7de9bb6900000000, 0x4bb8394d00000000, 0x114bbf2000000000,\n    0x271a3d0400000000, 0xa5adb2fb00000000, 0x93fc30df00000000,\n    0xc90fb6b200000000, 0xff5e349600000000, 0x2f7f6eb300000000,\n    0x192eec9700000000, 0x43dd6afa00000000, 0x758ce8de00000000,\n    0xf73b672100000000, 0xc16ae50500000000, 0x9b99636800000000,\n    0xadc8e14c00000000, 0xdef00d4c00000000, 0xe8a18f6800000000,\n    0xb252090500000000, 0x84038b2100000000, 0x06b404de00000000,\n    0x30e586fa00000000, 0x6a16009700000000, 0x5c4782b300000000,\n    0xca55b4dd00000000, 0xfc0436f900000000, 0xa6f7b09400000000,\n    0x90a632b000000000, 0x1211bd4f00000000, 0x24403f6b00000000,\n    0x7eb3b90600000000, 0x48e23b2200000000, 0x3bdad72200000000,\n    0x0d8b550600000000, 0x5778d36b00000000, 0x6129514f00000000,\n    0xe39edeb000000000, 0xd5cf5c9400000000, 0x8f3cdaf900000000,\n    0xb96d58dd00000000, 0x694c02f800000000, 0x5f1d80dc00000000,\n    0x05ee06b100000000, 0x33bf849500000000, 0xb1080b6a00000000,\n    0x8759894e00000000, 0xddaa0f2300000000, 0xebfb8d0700000000,\n    0x98c3610700000000, 0xae92e32300000000, 0xf461654e00000000,\n    0xc230e76a00000000, 0x4087689500000000, 0x76d6eab100000000,\n    0x2c256cdc00000000, 0x1a74eef800000000, 0x59cbc1f600000000,\n    0x6f9a43d200000000, 0x3569c5bf00000000, 0x0338479b00000000,\n    0x818fc86400000000, 0xb7de4a4000000000, 0xed2dcc2d00000000,\n    0xdb7c4e0900000000, 0xa844a20900000000, 0x9e15202d00000000,\n    0xc4e6a64000000000, 0xf2b7246400000000, 0x7000ab9b00000000,\n    0x465129bf00000000, 0x1ca2afd200000000, 0x2af32df600000000,\n    0xfad277d300000000, 0xcc83f5f700000000, 0x9670739a00000000,\n    0xa021f1be00000000, 0x22967e4100000000, 0x14c7fc6500000000,\n    0x4e347a0800000000, 0x7865f82c00000000, 0x0b5d142c00000000,\n    0x3d0c960800000000, 0x67ff106500000000, 0x51ae924100000000,\n    0xd3191dbe00000000, 0xe5489f9a00000000, 0xbfbb19f700000000,\n    0x89ea9bd300000000, 0x1ff8adbd00000000, 0x29a92f9900000000,\n    0x735aa9f400000000, 0x450b2bd000000000, 0xc7bca42f00000000,\n    0xf1ed260b00000000, 0xab1ea06600000000, 0x9d4f224200000000,\n    0xee77ce4200000000, 0xd8264c6600000000, 0x82d5ca0b00000000,\n    0xb484482f00000000, 0x3633c7d000000000, 0x006245f400000000,\n    0x5a91c39900000000, 0x6cc041bd00000000, 0xbce11b9800000000,\n    0x8ab099bc00000000, 0xd0431fd100000000, 0xe6129df500000000,\n    0x64a5120a00000000, 0x52f4902e00000000, 0x0807164300000000,\n    0x3e56946700000000, 0x4d6e786700000000, 0x7b3ffa4300000000,\n    0x21cc7c2e00000000, 0x179dfe0a00000000, 0x952a71f500000000,\n    0xa37bf3d100000000, 0xf98875bc00000000, 0xcfd9f79800000000,\n    0xd5ad196000000000, 0xe3fc9b4400000000, 0xb90f1d2900000000,\n    0x8f5e9f0d00000000, 0x0de910f200000000, 0x3bb892d600000000,\n    0x614b14bb00000000, 0x571a969f00000000, 0x24227a9f00000000,\n    0x1273f8bb00000000, 0x48807ed600000000, 0x7ed1fcf200000000,\n    0xfc66730d00000000, 0xca37f12900000000, 0x90c4774400000000,\n    0xa695f56000000000, 0x76b4af4500000000, 0x40e52d6100000000,\n    0x1a16ab0c00000000, 0x2c47292800000000, 0xaef0a6d700000000,\n    0x98a124f300000000, 0xc252a29e00000000, 0xf40320ba00000000,\n    0x873bccba00000000, 0xb16a4e9e00000000, 0xeb99c8f300000000,\n    0xddc84ad700000000, 0x5f7fc52800000000, 0x692e470c00000000,\n    0x33ddc16100000000, 0x058c434500000000, 0x939e752b00000000,\n    0xa5cff70f00000000, 0xff3c716200000000, 0xc96df34600000000,\n    0x4bda7cb900000000, 0x7d8bfe9d00000000, 0x277878f000000000,\n    0x1129fad400000000, 0x621116d400000000, 0x544094f000000000,\n    0x0eb3129d00000000, 0x38e290b900000000, 0xba551f4600000000,\n    0x8c049d6200000000, 0xd6f71b0f00000000, 0xe0a6992b00000000,\n    0x3087c30e00000000, 0x06d6412a00000000, 0x5c25c74700000000,\n    0x6a74456300000000, 0xe8c3ca9c00000000, 0xde9248b800000000,\n    0x8461ced500000000, 0xb2304cf100000000, 0xc108a0f100000000,\n    0xf75922d500000000, 0xadaaa4b800000000, 0x9bfb269c00000000,\n    0x194ca96300000000, 0x2f1d2b4700000000, 0x75eead2a00000000,\n    0x43bf2f0e00000000},\n   {0x0000000000000000, 0xc8179ecf00000000, 0xd1294d4400000000,\n    0x193ed38b00000000, 0xa2539a8800000000, 0x6a44044700000000,\n    0x737ad7cc00000000, 0xbb6d490300000000, 0x05a145ca00000000,\n    0xcdb6db0500000000, 0xd488088e00000000, 0x1c9f964100000000,\n    0xa7f2df4200000000, 0x6fe5418d00000000, 0x76db920600000000,\n    0xbecc0cc900000000, 0x4b44fa4f00000000, 0x8353648000000000,\n    0x9a6db70b00000000, 0x527a29c400000000, 0xe91760c700000000,\n    0x2100fe0800000000, 0x383e2d8300000000, 0xf029b34c00000000,\n    0x4ee5bf8500000000, 0x86f2214a00000000, 0x9fccf2c100000000,\n    0x57db6c0e00000000, 0xecb6250d00000000, 0x24a1bbc200000000,\n    0x3d9f684900000000, 0xf588f68600000000, 0x9688f49f00000000,\n    0x5e9f6a5000000000, 0x47a1b9db00000000, 0x8fb6271400000000,\n    0x34db6e1700000000, 0xfcccf0d800000000, 0xe5f2235300000000,\n    0x2de5bd9c00000000, 0x9329b15500000000, 0x5b3e2f9a00000000,\n    0x4200fc1100000000, 0x8a1762de00000000, 0x317a2bdd00000000,\n    0xf96db51200000000, 0xe053669900000000, 0x2844f85600000000,\n    0xddcc0ed000000000, 0x15db901f00000000, 0x0ce5439400000000,\n    0xc4f2dd5b00000000, 0x7f9f945800000000, 0xb7880a9700000000,\n    0xaeb6d91c00000000, 0x66a147d300000000, 0xd86d4b1a00000000,\n    0x107ad5d500000000, 0x0944065e00000000, 0xc153989100000000,\n    0x7a3ed19200000000, 0xb2294f5d00000000, 0xab179cd600000000,\n    0x6300021900000000, 0x6d1798e400000000, 0xa500062b00000000,\n    0xbc3ed5a000000000, 0x74294b6f00000000, 0xcf44026c00000000,\n    0x07539ca300000000, 0x1e6d4f2800000000, 0xd67ad1e700000000,\n    0x68b6dd2e00000000, 0xa0a143e100000000, 0xb99f906a00000000,\n    0x71880ea500000000, 0xcae547a600000000, 0x02f2d96900000000,\n    0x1bcc0ae200000000, 0xd3db942d00000000, 0x265362ab00000000,\n    0xee44fc6400000000, 0xf77a2fef00000000, 0x3f6db12000000000,\n    0x8400f82300000000, 0x4c1766ec00000000, 0x5529b56700000000,\n    0x9d3e2ba800000000, 0x23f2276100000000, 0xebe5b9ae00000000,\n    0xf2db6a2500000000, 0x3accf4ea00000000, 0x81a1bde900000000,\n    0x49b6232600000000, 0x5088f0ad00000000, 0x989f6e6200000000,\n    0xfb9f6c7b00000000, 0x3388f2b400000000, 0x2ab6213f00000000,\n    0xe2a1bff000000000, 0x59ccf6f300000000, 0x91db683c00000000,\n    0x88e5bbb700000000, 0x40f2257800000000, 0xfe3e29b100000000,\n    0x3629b77e00000000, 0x2f1764f500000000, 0xe700fa3a00000000,\n    0x5c6db33900000000, 0x947a2df600000000, 0x8d44fe7d00000000,\n    0x455360b200000000, 0xb0db963400000000, 0x78cc08fb00000000,\n    0x61f2db7000000000, 0xa9e545bf00000000, 0x12880cbc00000000,\n    0xda9f927300000000, 0xc3a141f800000000, 0x0bb6df3700000000,\n    0xb57ad3fe00000000, 0x7d6d4d3100000000, 0x64539eba00000000,\n    0xac44007500000000, 0x1729497600000000, 0xdf3ed7b900000000,\n    0xc600043200000000, 0x0e179afd00000000, 0x9b28411200000000,\n    0x533fdfdd00000000, 0x4a010c5600000000, 0x8216929900000000,\n    0x397bdb9a00000000, 0xf16c455500000000, 0xe85296de00000000,\n    0x2045081100000000, 0x9e8904d800000000, 0x569e9a1700000000,\n    0x4fa0499c00000000, 0x87b7d75300000000, 0x3cda9e5000000000,\n    0xf4cd009f00000000, 0xedf3d31400000000, 0x25e44ddb00000000,\n    0xd06cbb5d00000000, 0x187b259200000000, 0x0145f61900000000,\n    0xc95268d600000000, 0x723f21d500000000, 0xba28bf1a00000000,\n    0xa3166c9100000000, 0x6b01f25e00000000, 0xd5cdfe9700000000,\n    0x1dda605800000000, 0x04e4b3d300000000, 0xccf32d1c00000000,\n    0x779e641f00000000, 0xbf89fad000000000, 0xa6b7295b00000000,\n    0x6ea0b79400000000, 0x0da0b58d00000000, 0xc5b72b4200000000,\n    0xdc89f8c900000000, 0x149e660600000000, 0xaff32f0500000000,\n    0x67e4b1ca00000000, 0x7eda624100000000, 0xb6cdfc8e00000000,\n    0x0801f04700000000, 0xc0166e8800000000, 0xd928bd0300000000,\n    0x113f23cc00000000, 0xaa526acf00000000, 0x6245f40000000000,\n    0x7b7b278b00000000, 0xb36cb94400000000, 0x46e44fc200000000,\n    0x8ef3d10d00000000, 0x97cd028600000000, 0x5fda9c4900000000,\n    0xe4b7d54a00000000, 0x2ca04b8500000000, 0x359e980e00000000,\n    0xfd8906c100000000, 0x43450a0800000000, 0x8b5294c700000000,\n    0x926c474c00000000, 0x5a7bd98300000000, 0xe116908000000000,\n    0x29010e4f00000000, 0x303fddc400000000, 0xf828430b00000000,\n    0xf63fd9f600000000, 0x3e28473900000000, 0x271694b200000000,\n    0xef010a7d00000000, 0x546c437e00000000, 0x9c7bddb100000000,\n    0x85450e3a00000000, 0x4d5290f500000000, 0xf39e9c3c00000000,\n    0x3b8902f300000000, 0x22b7d17800000000, 0xeaa04fb700000000,\n    0x51cd06b400000000, 0x99da987b00000000, 0x80e44bf000000000,\n    0x48f3d53f00000000, 0xbd7b23b900000000, 0x756cbd7600000000,\n    0x6c526efd00000000, 0xa445f03200000000, 0x1f28b93100000000,\n    0xd73f27fe00000000, 0xce01f47500000000, 0x06166aba00000000,\n    0xb8da667300000000, 0x70cdf8bc00000000, 0x69f32b3700000000,\n    0xa1e4b5f800000000, 0x1a89fcfb00000000, 0xd29e623400000000,\n    0xcba0b1bf00000000, 0x03b72f7000000000, 0x60b72d6900000000,\n    0xa8a0b3a600000000, 0xb19e602d00000000, 0x7989fee200000000,\n    0xc2e4b7e100000000, 0x0af3292e00000000, 0x13cdfaa500000000,\n    0xdbda646a00000000, 0x651668a300000000, 0xad01f66c00000000,\n    0xb43f25e700000000, 0x7c28bb2800000000, 0xc745f22b00000000,\n    0x0f526ce400000000, 0x166cbf6f00000000, 0xde7b21a000000000,\n    0x2bf3d72600000000, 0xe3e449e900000000, 0xfada9a6200000000,\n    0x32cd04ad00000000, 0x89a04dae00000000, 0x41b7d36100000000,\n    0x588900ea00000000, 0x909e9e2500000000, 0x2e5292ec00000000,\n    0xe6450c2300000000, 0xff7bdfa800000000, 0x376c416700000000,\n    0x8c01086400000000, 0x441696ab00000000, 0x5d28452000000000,\n    0x953fdbef00000000},\n   {0x0000000000000000, 0x95d4709500000000, 0x6baf90f100000000,\n    0xfe7be06400000000, 0x9758503800000000, 0x028c20ad00000000,\n    0xfcf7c0c900000000, 0x6923b05c00000000, 0x2eb1a07000000000,\n    0xbb65d0e500000000, 0x451e308100000000, 0xd0ca401400000000,\n    0xb9e9f04800000000, 0x2c3d80dd00000000, 0xd24660b900000000,\n    0x4792102c00000000, 0x5c6241e100000000, 0xc9b6317400000000,\n    0x37cdd11000000000, 0xa219a18500000000, 0xcb3a11d900000000,\n    0x5eee614c00000000, 0xa095812800000000, 0x3541f1bd00000000,\n    0x72d3e19100000000, 0xe707910400000000, 0x197c716000000000,\n    0x8ca801f500000000, 0xe58bb1a900000000, 0x705fc13c00000000,\n    0x8e24215800000000, 0x1bf051cd00000000, 0xf9c2f31900000000,\n    0x6c16838c00000000, 0x926d63e800000000, 0x07b9137d00000000,\n    0x6e9aa32100000000, 0xfb4ed3b400000000, 0x053533d000000000,\n    0x90e1434500000000, 0xd773536900000000, 0x42a723fc00000000,\n    0xbcdcc39800000000, 0x2908b30d00000000, 0x402b035100000000,\n    0xd5ff73c400000000, 0x2b8493a000000000, 0xbe50e33500000000,\n    0xa5a0b2f800000000, 0x3074c26d00000000, 0xce0f220900000000,\n    0x5bdb529c00000000, 0x32f8e2c000000000, 0xa72c925500000000,\n    0x5957723100000000, 0xcc8302a400000000, 0x8b11128800000000,\n    0x1ec5621d00000000, 0xe0be827900000000, 0x756af2ec00000000,\n    0x1c4942b000000000, 0x899d322500000000, 0x77e6d24100000000,\n    0xe232a2d400000000, 0xf285e73300000000, 0x675197a600000000,\n    0x992a77c200000000, 0x0cfe075700000000, 0x65ddb70b00000000,\n    0xf009c79e00000000, 0x0e7227fa00000000, 0x9ba6576f00000000,\n    0xdc34474300000000, 0x49e037d600000000, 0xb79bd7b200000000,\n    0x224fa72700000000, 0x4b6c177b00000000, 0xdeb867ee00000000,\n    0x20c3878a00000000, 0xb517f71f00000000, 0xaee7a6d200000000,\n    0x3b33d64700000000, 0xc548362300000000, 0x509c46b600000000,\n    0x39bff6ea00000000, 0xac6b867f00000000, 0x5210661b00000000,\n    0xc7c4168e00000000, 0x805606a200000000, 0x1582763700000000,\n    0xebf9965300000000, 0x7e2de6c600000000, 0x170e569a00000000,\n    0x82da260f00000000, 0x7ca1c66b00000000, 0xe975b6fe00000000,\n    0x0b47142a00000000, 0x9e9364bf00000000, 0x60e884db00000000,\n    0xf53cf44e00000000, 0x9c1f441200000000, 0x09cb348700000000,\n    0xf7b0d4e300000000, 0x6264a47600000000, 0x25f6b45a00000000,\n    0xb022c4cf00000000, 0x4e5924ab00000000, 0xdb8d543e00000000,\n    0xb2aee46200000000, 0x277a94f700000000, 0xd901749300000000,\n    0x4cd5040600000000, 0x572555cb00000000, 0xc2f1255e00000000,\n    0x3c8ac53a00000000, 0xa95eb5af00000000, 0xc07d05f300000000,\n    0x55a9756600000000, 0xabd2950200000000, 0x3e06e59700000000,\n    0x7994f5bb00000000, 0xec40852e00000000, 0x123b654a00000000,\n    0x87ef15df00000000, 0xeecca58300000000, 0x7b18d51600000000,\n    0x8563357200000000, 0x10b745e700000000, 0xe40bcf6700000000,\n    0x71dfbff200000000, 0x8fa45f9600000000, 0x1a702f0300000000,\n    0x73539f5f00000000, 0xe687efca00000000, 0x18fc0fae00000000,\n    0x8d287f3b00000000, 0xcaba6f1700000000, 0x5f6e1f8200000000,\n    0xa115ffe600000000, 0x34c18f7300000000, 0x5de23f2f00000000,\n    0xc8364fba00000000, 0x364dafde00000000, 0xa399df4b00000000,\n    0xb8698e8600000000, 0x2dbdfe1300000000, 0xd3c61e7700000000,\n    0x46126ee200000000, 0x2f31debe00000000, 0xbae5ae2b00000000,\n    0x449e4e4f00000000, 0xd14a3eda00000000, 0x96d82ef600000000,\n    0x030c5e6300000000, 0xfd77be0700000000, 0x68a3ce9200000000,\n    0x01807ece00000000, 0x94540e5b00000000, 0x6a2fee3f00000000,\n    0xfffb9eaa00000000, 0x1dc93c7e00000000, 0x881d4ceb00000000,\n    0x7666ac8f00000000, 0xe3b2dc1a00000000, 0x8a916c4600000000,\n    0x1f451cd300000000, 0xe13efcb700000000, 0x74ea8c2200000000,\n    0x33789c0e00000000, 0xa6acec9b00000000, 0x58d70cff00000000,\n    0xcd037c6a00000000, 0xa420cc3600000000, 0x31f4bca300000000,\n    0xcf8f5cc700000000, 0x5a5b2c5200000000, 0x41ab7d9f00000000,\n    0xd47f0d0a00000000, 0x2a04ed6e00000000, 0xbfd09dfb00000000,\n    0xd6f32da700000000, 0x43275d3200000000, 0xbd5cbd5600000000,\n    0x2888cdc300000000, 0x6f1addef00000000, 0xfacead7a00000000,\n    0x04b54d1e00000000, 0x91613d8b00000000, 0xf8428dd700000000,\n    0x6d96fd4200000000, 0x93ed1d2600000000, 0x06396db300000000,\n    0x168e285400000000, 0x835a58c100000000, 0x7d21b8a500000000,\n    0xe8f5c83000000000, 0x81d6786c00000000, 0x140208f900000000,\n    0xea79e89d00000000, 0x7fad980800000000, 0x383f882400000000,\n    0xadebf8b100000000, 0x539018d500000000, 0xc644684000000000,\n    0xaf67d81c00000000, 0x3ab3a88900000000, 0xc4c848ed00000000,\n    0x511c387800000000, 0x4aec69b500000000, 0xdf38192000000000,\n    0x2143f94400000000, 0xb49789d100000000, 0xddb4398d00000000,\n    0x4860491800000000, 0xb61ba97c00000000, 0x23cfd9e900000000,\n    0x645dc9c500000000, 0xf189b95000000000, 0x0ff2593400000000,\n    0x9a2629a100000000, 0xf30599fd00000000, 0x66d1e96800000000,\n    0x98aa090c00000000, 0x0d7e799900000000, 0xef4cdb4d00000000,\n    0x7a98abd800000000, 0x84e34bbc00000000, 0x11373b2900000000,\n    0x78148b7500000000, 0xedc0fbe000000000, 0x13bb1b8400000000,\n    0x866f6b1100000000, 0xc1fd7b3d00000000, 0x54290ba800000000,\n    0xaa52ebcc00000000, 0x3f869b5900000000, 0x56a52b0500000000,\n    0xc3715b9000000000, 0x3d0abbf400000000, 0xa8decb6100000000,\n    0xb32e9aac00000000, 0x26faea3900000000, 0xd8810a5d00000000,\n    0x4d557ac800000000, 0x2476ca9400000000, 0xb1a2ba0100000000,\n    0x4fd95a6500000000, 0xda0d2af000000000, 0x9d9f3adc00000000,\n    0x084b4a4900000000, 0xf630aa2d00000000, 0x63e4dab800000000,\n    0x0ac76ae400000000, 0x9f131a7100000000, 0x6168fa1500000000,\n    0xf4bc8a8000000000},\n   {0x0000000000000000, 0x1f17f08000000000, 0x7f2891da00000000,\n    0x603f615a00000000, 0xbf56536e00000000, 0xa041a3ee00000000,\n    0xc07ec2b400000000, 0xdf69323400000000, 0x7eada6dc00000000,\n    0x61ba565c00000000, 0x0185370600000000, 0x1e92c78600000000,\n    0xc1fbf5b200000000, 0xdeec053200000000, 0xbed3646800000000,\n    0xa1c494e800000000, 0xbd5c3c6200000000, 0xa24bcce200000000,\n    0xc274adb800000000, 0xdd635d3800000000, 0x020a6f0c00000000,\n    0x1d1d9f8c00000000, 0x7d22fed600000000, 0x62350e5600000000,\n    0xc3f19abe00000000, 0xdce66a3e00000000, 0xbcd90b6400000000,\n    0xa3cefbe400000000, 0x7ca7c9d000000000, 0x63b0395000000000,\n    0x038f580a00000000, 0x1c98a88a00000000, 0x7ab978c400000000,\n    0x65ae884400000000, 0x0591e91e00000000, 0x1a86199e00000000,\n    0xc5ef2baa00000000, 0xdaf8db2a00000000, 0xbac7ba7000000000,\n    0xa5d04af000000000, 0x0414de1800000000, 0x1b032e9800000000,\n    0x7b3c4fc200000000, 0x642bbf4200000000, 0xbb428d7600000000,\n    0xa4557df600000000, 0xc46a1cac00000000, 0xdb7dec2c00000000,\n    0xc7e544a600000000, 0xd8f2b42600000000, 0xb8cdd57c00000000,\n    0xa7da25fc00000000, 0x78b317c800000000, 0x67a4e74800000000,\n    0x079b861200000000, 0x188c769200000000, 0xb948e27a00000000,\n    0xa65f12fa00000000, 0xc66073a000000000, 0xd977832000000000,\n    0x061eb11400000000, 0x1909419400000000, 0x793620ce00000000,\n    0x6621d04e00000000, 0xb574805300000000, 0xaa6370d300000000,\n    0xca5c118900000000, 0xd54be10900000000, 0x0a22d33d00000000,\n    0x153523bd00000000, 0x750a42e700000000, 0x6a1db26700000000,\n    0xcbd9268f00000000, 0xd4ced60f00000000, 0xb4f1b75500000000,\n    0xabe647d500000000, 0x748f75e100000000, 0x6b98856100000000,\n    0x0ba7e43b00000000, 0x14b014bb00000000, 0x0828bc3100000000,\n    0x173f4cb100000000, 0x77002deb00000000, 0x6817dd6b00000000,\n    0xb77eef5f00000000, 0xa8691fdf00000000, 0xc8567e8500000000,\n    0xd7418e0500000000, 0x76851aed00000000, 0x6992ea6d00000000,\n    0x09ad8b3700000000, 0x16ba7bb700000000, 0xc9d3498300000000,\n    0xd6c4b90300000000, 0xb6fbd85900000000, 0xa9ec28d900000000,\n    0xcfcdf89700000000, 0xd0da081700000000, 0xb0e5694d00000000,\n    0xaff299cd00000000, 0x709babf900000000, 0x6f8c5b7900000000,\n    0x0fb33a2300000000, 0x10a4caa300000000, 0xb1605e4b00000000,\n    0xae77aecb00000000, 0xce48cf9100000000, 0xd15f3f1100000000,\n    0x0e360d2500000000, 0x1121fda500000000, 0x711e9cff00000000,\n    0x6e096c7f00000000, 0x7291c4f500000000, 0x6d86347500000000,\n    0x0db9552f00000000, 0x12aea5af00000000, 0xcdc7979b00000000,\n    0xd2d0671b00000000, 0xb2ef064100000000, 0xadf8f6c100000000,\n    0x0c3c622900000000, 0x132b92a900000000, 0x7314f3f300000000,\n    0x6c03037300000000, 0xb36a314700000000, 0xac7dc1c700000000,\n    0xcc42a09d00000000, 0xd355501d00000000, 0x6ae900a700000000,\n    0x75fef02700000000, 0x15c1917d00000000, 0x0ad661fd00000000,\n    0xd5bf53c900000000, 0xcaa8a34900000000, 0xaa97c21300000000,\n    0xb580329300000000, 0x1444a67b00000000, 0x0b5356fb00000000,\n    0x6b6c37a100000000, 0x747bc72100000000, 0xab12f51500000000,\n    0xb405059500000000, 0xd43a64cf00000000, 0xcb2d944f00000000,\n    0xd7b53cc500000000, 0xc8a2cc4500000000, 0xa89dad1f00000000,\n    0xb78a5d9f00000000, 0x68e36fab00000000, 0x77f49f2b00000000,\n    0x17cbfe7100000000, 0x08dc0ef100000000, 0xa9189a1900000000,\n    0xb60f6a9900000000, 0xd6300bc300000000, 0xc927fb4300000000,\n    0x164ec97700000000, 0x095939f700000000, 0x696658ad00000000,\n    0x7671a82d00000000, 0x1050786300000000, 0x0f4788e300000000,\n    0x6f78e9b900000000, 0x706f193900000000, 0xaf062b0d00000000,\n    0xb011db8d00000000, 0xd02ebad700000000, 0xcf394a5700000000,\n    0x6efddebf00000000, 0x71ea2e3f00000000, 0x11d54f6500000000,\n    0x0ec2bfe500000000, 0xd1ab8dd100000000, 0xcebc7d5100000000,\n    0xae831c0b00000000, 0xb194ec8b00000000, 0xad0c440100000000,\n    0xb21bb48100000000, 0xd224d5db00000000, 0xcd33255b00000000,\n    0x125a176f00000000, 0x0d4de7ef00000000, 0x6d7286b500000000,\n    0x7265763500000000, 0xd3a1e2dd00000000, 0xccb6125d00000000,\n    0xac89730700000000, 0xb39e838700000000, 0x6cf7b1b300000000,\n    0x73e0413300000000, 0x13df206900000000, 0x0cc8d0e900000000,\n    0xdf9d80f400000000, 0xc08a707400000000, 0xa0b5112e00000000,\n    0xbfa2e1ae00000000, 0x60cbd39a00000000, 0x7fdc231a00000000,\n    0x1fe3424000000000, 0x00f4b2c000000000, 0xa130262800000000,\n    0xbe27d6a800000000, 0xde18b7f200000000, 0xc10f477200000000,\n    0x1e66754600000000, 0x017185c600000000, 0x614ee49c00000000,\n    0x7e59141c00000000, 0x62c1bc9600000000, 0x7dd64c1600000000,\n    0x1de92d4c00000000, 0x02feddcc00000000, 0xdd97eff800000000,\n    0xc2801f7800000000, 0xa2bf7e2200000000, 0xbda88ea200000000,\n    0x1c6c1a4a00000000, 0x037beaca00000000, 0x63448b9000000000,\n    0x7c537b1000000000, 0xa33a492400000000, 0xbc2db9a400000000,\n    0xdc12d8fe00000000, 0xc305287e00000000, 0xa524f83000000000,\n    0xba3308b000000000, 0xda0c69ea00000000, 0xc51b996a00000000,\n    0x1a72ab5e00000000, 0x05655bde00000000, 0x655a3a8400000000,\n    0x7a4dca0400000000, 0xdb895eec00000000, 0xc49eae6c00000000,\n    0xa4a1cf3600000000, 0xbbb63fb600000000, 0x64df0d8200000000,\n    0x7bc8fd0200000000, 0x1bf79c5800000000, 0x04e06cd800000000,\n    0x1878c45200000000, 0x076f34d200000000, 0x6750558800000000,\n    0x7847a50800000000, 0xa72e973c00000000, 0xb83967bc00000000,\n    0xd80606e600000000, 0xc711f66600000000, 0x66d5628e00000000,\n    0x79c2920e00000000, 0x19fdf35400000000, 0x06ea03d400000000,\n    0xd98331e000000000, 0xc694c16000000000, 0xa6aba03a00000000,\n    0xb9bc50ba00000000},\n   {0x0000000000000000, 0xe2fd888d00000000, 0x85fd60c000000000,\n    0x6700e84d00000000, 0x4bfdb05b00000000, 0xa90038d600000000,\n    0xce00d09b00000000, 0x2cfd581600000000, 0x96fa61b700000000,\n    0x7407e93a00000000, 0x1307017700000000, 0xf1fa89fa00000000,\n    0xdd07d1ec00000000, 0x3ffa596100000000, 0x58fab12c00000000,\n    0xba0739a100000000, 0x6df3b2b500000000, 0x8f0e3a3800000000,\n    0xe80ed27500000000, 0x0af35af800000000, 0x260e02ee00000000,\n    0xc4f38a6300000000, 0xa3f3622e00000000, 0x410eeaa300000000,\n    0xfb09d30200000000, 0x19f45b8f00000000, 0x7ef4b3c200000000,\n    0x9c093b4f00000000, 0xb0f4635900000000, 0x5209ebd400000000,\n    0x3509039900000000, 0xd7f48b1400000000, 0x9be014b000000000,\n    0x791d9c3d00000000, 0x1e1d747000000000, 0xfce0fcfd00000000,\n    0xd01da4eb00000000, 0x32e02c6600000000, 0x55e0c42b00000000,\n    0xb71d4ca600000000, 0x0d1a750700000000, 0xefe7fd8a00000000,\n    0x88e715c700000000, 0x6a1a9d4a00000000, 0x46e7c55c00000000,\n    0xa41a4dd100000000, 0xc31aa59c00000000, 0x21e72d1100000000,\n    0xf613a60500000000, 0x14ee2e8800000000, 0x73eec6c500000000,\n    0x91134e4800000000, 0xbdee165e00000000, 0x5f139ed300000000,\n    0x3813769e00000000, 0xdaeefe1300000000, 0x60e9c7b200000000,\n    0x82144f3f00000000, 0xe514a77200000000, 0x07e92fff00000000,\n    0x2b1477e900000000, 0xc9e9ff6400000000, 0xaee9172900000000,\n    0x4c149fa400000000, 0x77c758bb00000000, 0x953ad03600000000,\n    0xf23a387b00000000, 0x10c7b0f600000000, 0x3c3ae8e000000000,\n    0xdec7606d00000000, 0xb9c7882000000000, 0x5b3a00ad00000000,\n    0xe13d390c00000000, 0x03c0b18100000000, 0x64c059cc00000000,\n    0x863dd14100000000, 0xaac0895700000000, 0x483d01da00000000,\n    0x2f3de99700000000, 0xcdc0611a00000000, 0x1a34ea0e00000000,\n    0xf8c9628300000000, 0x9fc98ace00000000, 0x7d34024300000000,\n    0x51c95a5500000000, 0xb334d2d800000000, 0xd4343a9500000000,\n    0x36c9b21800000000, 0x8cce8bb900000000, 0x6e33033400000000,\n    0x0933eb7900000000, 0xebce63f400000000, 0xc7333be200000000,\n    0x25ceb36f00000000, 0x42ce5b2200000000, 0xa033d3af00000000,\n    0xec274c0b00000000, 0x0edac48600000000, 0x69da2ccb00000000,\n    0x8b27a44600000000, 0xa7dafc5000000000, 0x452774dd00000000,\n    0x22279c9000000000, 0xc0da141d00000000, 0x7add2dbc00000000,\n    0x9820a53100000000, 0xff204d7c00000000, 0x1dddc5f100000000,\n    0x31209de700000000, 0xd3dd156a00000000, 0xb4ddfd2700000000,\n    0x562075aa00000000, 0x81d4febe00000000, 0x6329763300000000,\n    0x04299e7e00000000, 0xe6d416f300000000, 0xca294ee500000000,\n    0x28d4c66800000000, 0x4fd42e2500000000, 0xad29a6a800000000,\n    0x172e9f0900000000, 0xf5d3178400000000, 0x92d3ffc900000000,\n    0x702e774400000000, 0x5cd32f5200000000, 0xbe2ea7df00000000,\n    0xd92e4f9200000000, 0x3bd3c71f00000000, 0xaf88c0ad00000000,\n    0x4d75482000000000, 0x2a75a06d00000000, 0xc88828e000000000,\n    0xe47570f600000000, 0x0688f87b00000000, 0x6188103600000000,\n    0x837598bb00000000, 0x3972a11a00000000, 0xdb8f299700000000,\n    0xbc8fc1da00000000, 0x5e72495700000000, 0x728f114100000000,\n    0x907299cc00000000, 0xf772718100000000, 0x158ff90c00000000,\n    0xc27b721800000000, 0x2086fa9500000000, 0x478612d800000000,\n    0xa57b9a5500000000, 0x8986c24300000000, 0x6b7b4ace00000000,\n    0x0c7ba28300000000, 0xee862a0e00000000, 0x548113af00000000,\n    0xb67c9b2200000000, 0xd17c736f00000000, 0x3381fbe200000000,\n    0x1f7ca3f400000000, 0xfd812b7900000000, 0x9a81c33400000000,\n    0x787c4bb900000000, 0x3468d41d00000000, 0xd6955c9000000000,\n    0xb195b4dd00000000, 0x53683c5000000000, 0x7f95644600000000,\n    0x9d68eccb00000000, 0xfa68048600000000, 0x18958c0b00000000,\n    0xa292b5aa00000000, 0x406f3d2700000000, 0x276fd56a00000000,\n    0xc5925de700000000, 0xe96f05f100000000, 0x0b928d7c00000000,\n    0x6c92653100000000, 0x8e6fedbc00000000, 0x599b66a800000000,\n    0xbb66ee2500000000, 0xdc66066800000000, 0x3e9b8ee500000000,\n    0x1266d6f300000000, 0xf09b5e7e00000000, 0x979bb63300000000,\n    0x75663ebe00000000, 0xcf61071f00000000, 0x2d9c8f9200000000,\n    0x4a9c67df00000000, 0xa861ef5200000000, 0x849cb74400000000,\n    0x66613fc900000000, 0x0161d78400000000, 0xe39c5f0900000000,\n    0xd84f981600000000, 0x3ab2109b00000000, 0x5db2f8d600000000,\n    0xbf4f705b00000000, 0x93b2284d00000000, 0x714fa0c000000000,\n    0x164f488d00000000, 0xf4b2c00000000000, 0x4eb5f9a100000000,\n    0xac48712c00000000, 0xcb48996100000000, 0x29b511ec00000000,\n    0x054849fa00000000, 0xe7b5c17700000000, 0x80b5293a00000000,\n    0x6248a1b700000000, 0xb5bc2aa300000000, 0x5741a22e00000000,\n    0x30414a6300000000, 0xd2bcc2ee00000000, 0xfe419af800000000,\n    0x1cbc127500000000, 0x7bbcfa3800000000, 0x994172b500000000,\n    0x23464b1400000000, 0xc1bbc39900000000, 0xa6bb2bd400000000,\n    0x4446a35900000000, 0x68bbfb4f00000000, 0x8a4673c200000000,\n    0xed469b8f00000000, 0x0fbb130200000000, 0x43af8ca600000000,\n    0xa152042b00000000, 0xc652ec6600000000, 0x24af64eb00000000,\n    0x08523cfd00000000, 0xeaafb47000000000, 0x8daf5c3d00000000,\n    0x6f52d4b000000000, 0xd555ed1100000000, 0x37a8659c00000000,\n    0x50a88dd100000000, 0xb255055c00000000, 0x9ea85d4a00000000,\n    0x7c55d5c700000000, 0x1b553d8a00000000, 0xf9a8b50700000000,\n    0x2e5c3e1300000000, 0xcca1b69e00000000, 0xaba15ed300000000,\n    0x495cd65e00000000, 0x65a18e4800000000, 0x875c06c500000000,\n    0xe05cee8800000000, 0x02a1660500000000, 0xb8a65fa400000000,\n    0x5a5bd72900000000, 0x3d5b3f6400000000, 0xdfa6b7e900000000,\n    0xf35befff00000000, 0x11a6677200000000, 0x76a68f3f00000000,\n    0x945b07b200000000},\n   {0x0000000000000000, 0xa90b894e00000000, 0x5217129d00000000,\n    0xfb1c9bd300000000, 0xe52855e100000000, 0x4c23dcaf00000000,\n    0xb73f477c00000000, 0x1e34ce3200000000, 0x8b57db1900000000,\n    0x225c525700000000, 0xd940c98400000000, 0x704b40ca00000000,\n    0x6e7f8ef800000000, 0xc77407b600000000, 0x3c689c6500000000,\n    0x9563152b00000000, 0x16afb63300000000, 0xbfa43f7d00000000,\n    0x44b8a4ae00000000, 0xedb32de000000000, 0xf387e3d200000000,\n    0x5a8c6a9c00000000, 0xa190f14f00000000, 0x089b780100000000,\n    0x9df86d2a00000000, 0x34f3e46400000000, 0xcfef7fb700000000,\n    0x66e4f6f900000000, 0x78d038cb00000000, 0xd1dbb18500000000,\n    0x2ac72a5600000000, 0x83cca31800000000, 0x2c5e6d6700000000,\n    0x8555e42900000000, 0x7e497ffa00000000, 0xd742f6b400000000,\n    0xc976388600000000, 0x607db1c800000000, 0x9b612a1b00000000,\n    0x326aa35500000000, 0xa709b67e00000000, 0x0e023f3000000000,\n    0xf51ea4e300000000, 0x5c152dad00000000, 0x4221e39f00000000,\n    0xeb2a6ad100000000, 0x1036f10200000000, 0xb93d784c00000000,\n    0x3af1db5400000000, 0x93fa521a00000000, 0x68e6c9c900000000,\n    0xc1ed408700000000, 0xdfd98eb500000000, 0x76d207fb00000000,\n    0x8dce9c2800000000, 0x24c5156600000000, 0xb1a6004d00000000,\n    0x18ad890300000000, 0xe3b112d000000000, 0x4aba9b9e00000000,\n    0x548e55ac00000000, 0xfd85dce200000000, 0x0699473100000000,\n    0xaf92ce7f00000000, 0x58bcdace00000000, 0xf1b7538000000000,\n    0x0aabc85300000000, 0xa3a0411d00000000, 0xbd948f2f00000000,\n    0x149f066100000000, 0xef839db200000000, 0x468814fc00000000,\n    0xd3eb01d700000000, 0x7ae0889900000000, 0x81fc134a00000000,\n    0x28f79a0400000000, 0x36c3543600000000, 0x9fc8dd7800000000,\n    0x64d446ab00000000, 0xcddfcfe500000000, 0x4e136cfd00000000,\n    0xe718e5b300000000, 0x1c047e6000000000, 0xb50ff72e00000000,\n    0xab3b391c00000000, 0x0230b05200000000, 0xf92c2b8100000000,\n    0x5027a2cf00000000, 0xc544b7e400000000, 0x6c4f3eaa00000000,\n    0x9753a57900000000, 0x3e582c3700000000, 0x206ce20500000000,\n    0x89676b4b00000000, 0x727bf09800000000, 0xdb7079d600000000,\n    0x74e2b7a900000000, 0xdde93ee700000000, 0x26f5a53400000000,\n    0x8ffe2c7a00000000, 0x91cae24800000000, 0x38c16b0600000000,\n    0xc3ddf0d500000000, 0x6ad6799b00000000, 0xffb56cb000000000,\n    0x56bee5fe00000000, 0xada27e2d00000000, 0x04a9f76300000000,\n    0x1a9d395100000000, 0xb396b01f00000000, 0x488a2bcc00000000,\n    0xe181a28200000000, 0x624d019a00000000, 0xcb4688d400000000,\n    0x305a130700000000, 0x99519a4900000000, 0x8765547b00000000,\n    0x2e6edd3500000000, 0xd57246e600000000, 0x7c79cfa800000000,\n    0xe91ada8300000000, 0x401153cd00000000, 0xbb0dc81e00000000,\n    0x1206415000000000, 0x0c328f6200000000, 0xa539062c00000000,\n    0x5e259dff00000000, 0xf72e14b100000000, 0xf17ec44600000000,\n    0x58754d0800000000, 0xa369d6db00000000, 0x0a625f9500000000,\n    0x145691a700000000, 0xbd5d18e900000000, 0x4641833a00000000,\n    0xef4a0a7400000000, 0x7a291f5f00000000, 0xd322961100000000,\n    0x283e0dc200000000, 0x8135848c00000000, 0x9f014abe00000000,\n    0x360ac3f000000000, 0xcd16582300000000, 0x641dd16d00000000,\n    0xe7d1727500000000, 0x4edafb3b00000000, 0xb5c660e800000000,\n    0x1ccde9a600000000, 0x02f9279400000000, 0xabf2aeda00000000,\n    0x50ee350900000000, 0xf9e5bc4700000000, 0x6c86a96c00000000,\n    0xc58d202200000000, 0x3e91bbf100000000, 0x979a32bf00000000,\n    0x89aefc8d00000000, 0x20a575c300000000, 0xdbb9ee1000000000,\n    0x72b2675e00000000, 0xdd20a92100000000, 0x742b206f00000000,\n    0x8f37bbbc00000000, 0x263c32f200000000, 0x3808fcc000000000,\n    0x9103758e00000000, 0x6a1fee5d00000000, 0xc314671300000000,\n    0x5677723800000000, 0xff7cfb7600000000, 0x046060a500000000,\n    0xad6be9eb00000000, 0xb35f27d900000000, 0x1a54ae9700000000,\n    0xe148354400000000, 0x4843bc0a00000000, 0xcb8f1f1200000000,\n    0x6284965c00000000, 0x99980d8f00000000, 0x309384c100000000,\n    0x2ea74af300000000, 0x87acc3bd00000000, 0x7cb0586e00000000,\n    0xd5bbd12000000000, 0x40d8c40b00000000, 0xe9d34d4500000000,\n    0x12cfd69600000000, 0xbbc45fd800000000, 0xa5f091ea00000000,\n    0x0cfb18a400000000, 0xf7e7837700000000, 0x5eec0a3900000000,\n    0xa9c21e8800000000, 0x00c997c600000000, 0xfbd50c1500000000,\n    0x52de855b00000000, 0x4cea4b6900000000, 0xe5e1c22700000000,\n    0x1efd59f400000000, 0xb7f6d0ba00000000, 0x2295c59100000000,\n    0x8b9e4cdf00000000, 0x7082d70c00000000, 0xd9895e4200000000,\n    0xc7bd907000000000, 0x6eb6193e00000000, 0x95aa82ed00000000,\n    0x3ca10ba300000000, 0xbf6da8bb00000000, 0x166621f500000000,\n    0xed7aba2600000000, 0x4471336800000000, 0x5a45fd5a00000000,\n    0xf34e741400000000, 0x0852efc700000000, 0xa159668900000000,\n    0x343a73a200000000, 0x9d31faec00000000, 0x662d613f00000000,\n    0xcf26e87100000000, 0xd112264300000000, 0x7819af0d00000000,\n    0x830534de00000000, 0x2a0ebd9000000000, 0x859c73ef00000000,\n    0x2c97faa100000000, 0xd78b617200000000, 0x7e80e83c00000000,\n    0x60b4260e00000000, 0xc9bfaf4000000000, 0x32a3349300000000,\n    0x9ba8bddd00000000, 0x0ecba8f600000000, 0xa7c021b800000000,\n    0x5cdcba6b00000000, 0xf5d7332500000000, 0xebe3fd1700000000,\n    0x42e8745900000000, 0xb9f4ef8a00000000, 0x10ff66c400000000,\n    0x9333c5dc00000000, 0x3a384c9200000000, 0xc124d74100000000,\n    0x682f5e0f00000000, 0x761b903d00000000, 0xdf10197300000000,\n    0x240c82a000000000, 0x8d070bee00000000, 0x18641ec500000000,\n    0xb16f978b00000000, 0x4a730c5800000000, 0xe378851600000000,\n    0xfd4c4b2400000000, 0x5447c26a00000000, 0xaf5b59b900000000,\n    0x0650d0f700000000},\n   {0x0000000000000000, 0x479244af00000000, 0xcf22f88500000000,\n    0x88b0bc2a00000000, 0xdf4381d000000000, 0x98d1c57f00000000,\n    0x1061795500000000, 0x57f33dfa00000000, 0xff81737a00000000,\n    0xb81337d500000000, 0x30a38bff00000000, 0x7731cf5000000000,\n    0x20c2f2aa00000000, 0x6750b60500000000, 0xefe00a2f00000000,\n    0xa8724e8000000000, 0xfe03e7f400000000, 0xb991a35b00000000,\n    0x31211f7100000000, 0x76b35bde00000000, 0x2140662400000000,\n    0x66d2228b00000000, 0xee629ea100000000, 0xa9f0da0e00000000,\n    0x0182948e00000000, 0x4610d02100000000, 0xcea06c0b00000000,\n    0x893228a400000000, 0xdec1155e00000000, 0x995351f100000000,\n    0x11e3eddb00000000, 0x5671a97400000000, 0xbd01bf3200000000,\n    0xfa93fb9d00000000, 0x722347b700000000, 0x35b1031800000000,\n    0x62423ee200000000, 0x25d07a4d00000000, 0xad60c66700000000,\n    0xeaf282c800000000, 0x4280cc4800000000, 0x051288e700000000,\n    0x8da234cd00000000, 0xca30706200000000, 0x9dc34d9800000000,\n    0xda51093700000000, 0x52e1b51d00000000, 0x1573f1b200000000,\n    0x430258c600000000, 0x04901c6900000000, 0x8c20a04300000000,\n    0xcbb2e4ec00000000, 0x9c41d91600000000, 0xdbd39db900000000,\n    0x5363219300000000, 0x14f1653c00000000, 0xbc832bbc00000000,\n    0xfb116f1300000000, 0x73a1d33900000000, 0x3433979600000000,\n    0x63c0aa6c00000000, 0x2452eec300000000, 0xace252e900000000,\n    0xeb70164600000000, 0x7a037e6500000000, 0x3d913aca00000000,\n    0xb52186e000000000, 0xf2b3c24f00000000, 0xa540ffb500000000,\n    0xe2d2bb1a00000000, 0x6a62073000000000, 0x2df0439f00000000,\n    0x85820d1f00000000, 0xc21049b000000000, 0x4aa0f59a00000000,\n    0x0d32b13500000000, 0x5ac18ccf00000000, 0x1d53c86000000000,\n    0x95e3744a00000000, 0xd27130e500000000, 0x8400999100000000,\n    0xc392dd3e00000000, 0x4b22611400000000, 0x0cb025bb00000000,\n    0x5b43184100000000, 0x1cd15cee00000000, 0x9461e0c400000000,\n    0xd3f3a46b00000000, 0x7b81eaeb00000000, 0x3c13ae4400000000,\n    0xb4a3126e00000000, 0xf33156c100000000, 0xa4c26b3b00000000,\n    0xe3502f9400000000, 0x6be093be00000000, 0x2c72d71100000000,\n    0xc702c15700000000, 0x809085f800000000, 0x082039d200000000,\n    0x4fb27d7d00000000, 0x1841408700000000, 0x5fd3042800000000,\n    0xd763b80200000000, 0x90f1fcad00000000, 0x3883b22d00000000,\n    0x7f11f68200000000, 0xf7a14aa800000000, 0xb0330e0700000000,\n    0xe7c033fd00000000, 0xa052775200000000, 0x28e2cb7800000000,\n    0x6f708fd700000000, 0x390126a300000000, 0x7e93620c00000000,\n    0xf623de2600000000, 0xb1b19a8900000000, 0xe642a77300000000,\n    0xa1d0e3dc00000000, 0x29605ff600000000, 0x6ef21b5900000000,\n    0xc68055d900000000, 0x8112117600000000, 0x09a2ad5c00000000,\n    0x4e30e9f300000000, 0x19c3d40900000000, 0x5e5190a600000000,\n    0xd6e12c8c00000000, 0x9173682300000000, 0xf406fcca00000000,\n    0xb394b86500000000, 0x3b24044f00000000, 0x7cb640e000000000,\n    0x2b457d1a00000000, 0x6cd739b500000000, 0xe467859f00000000,\n    0xa3f5c13000000000, 0x0b878fb000000000, 0x4c15cb1f00000000,\n    0xc4a5773500000000, 0x8337339a00000000, 0xd4c40e6000000000,\n    0x93564acf00000000, 0x1be6f6e500000000, 0x5c74b24a00000000,\n    0x0a051b3e00000000, 0x4d975f9100000000, 0xc527e3bb00000000,\n    0x82b5a71400000000, 0xd5469aee00000000, 0x92d4de4100000000,\n    0x1a64626b00000000, 0x5df626c400000000, 0xf584684400000000,\n    0xb2162ceb00000000, 0x3aa690c100000000, 0x7d34d46e00000000,\n    0x2ac7e99400000000, 0x6d55ad3b00000000, 0xe5e5111100000000,\n    0xa27755be00000000, 0x490743f800000000, 0x0e95075700000000,\n    0x8625bb7d00000000, 0xc1b7ffd200000000, 0x9644c22800000000,\n    0xd1d6868700000000, 0x59663aad00000000, 0x1ef47e0200000000,\n    0xb686308200000000, 0xf114742d00000000, 0x79a4c80700000000,\n    0x3e368ca800000000, 0x69c5b15200000000, 0x2e57f5fd00000000,\n    0xa6e749d700000000, 0xe1750d7800000000, 0xb704a40c00000000,\n    0xf096e0a300000000, 0x78265c8900000000, 0x3fb4182600000000,\n    0x684725dc00000000, 0x2fd5617300000000, 0xa765dd5900000000,\n    0xe0f799f600000000, 0x4885d77600000000, 0x0f1793d900000000,\n    0x87a72ff300000000, 0xc0356b5c00000000, 0x97c656a600000000,\n    0xd054120900000000, 0x58e4ae2300000000, 0x1f76ea8c00000000,\n    0x8e0582af00000000, 0xc997c60000000000, 0x41277a2a00000000,\n    0x06b53e8500000000, 0x5146037f00000000, 0x16d447d000000000,\n    0x9e64fbfa00000000, 0xd9f6bf5500000000, 0x7184f1d500000000,\n    0x3616b57a00000000, 0xbea6095000000000, 0xf9344dff00000000,\n    0xaec7700500000000, 0xe95534aa00000000, 0x61e5888000000000,\n    0x2677cc2f00000000, 0x7006655b00000000, 0x379421f400000000,\n    0xbf249dde00000000, 0xf8b6d97100000000, 0xaf45e48b00000000,\n    0xe8d7a02400000000, 0x60671c0e00000000, 0x27f558a100000000,\n    0x8f87162100000000, 0xc815528e00000000, 0x40a5eea400000000,\n    0x0737aa0b00000000, 0x50c497f100000000, 0x1756d35e00000000,\n    0x9fe66f7400000000, 0xd8742bdb00000000, 0x33043d9d00000000,\n    0x7496793200000000, 0xfc26c51800000000, 0xbbb481b700000000,\n    0xec47bc4d00000000, 0xabd5f8e200000000, 0x236544c800000000,\n    0x64f7006700000000, 0xcc854ee700000000, 0x8b170a4800000000,\n    0x03a7b66200000000, 0x4435f2cd00000000, 0x13c6cf3700000000,\n    0x54548b9800000000, 0xdce437b200000000, 0x9b76731d00000000,\n    0xcd07da6900000000, 0x8a959ec600000000, 0x022522ec00000000,\n    0x45b7664300000000, 0x12445bb900000000, 0x55d61f1600000000,\n    0xdd66a33c00000000, 0x9af4e79300000000, 0x3286a91300000000,\n    0x7514edbc00000000, 0xfda4519600000000, 0xba36153900000000,\n    0xedc528c300000000, 0xaa576c6c00000000, 0x22e7d04600000000,\n    0x657594e900000000}};\n\n#else /* W == 4 */\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0x65673b46, 0xcace768c, 0xafa94dca, 0x4eedeb59,\n    0x2b8ad01f, 0x84239dd5, 0xe144a693, 0x9ddbd6b2, 0xf8bcedf4,\n    0x5715a03e, 0x32729b78, 0xd3363deb, 0xb65106ad, 0x19f84b67,\n    0x7c9f7021, 0xe0c6ab25, 0x85a19063, 0x2a08dda9, 0x4f6fe6ef,\n    0xae2b407c, 0xcb4c7b3a, 0x64e536f0, 0x01820db6, 0x7d1d7d97,\n    0x187a46d1, 0xb7d30b1b, 0xd2b4305d, 0x33f096ce, 0x5697ad88,\n    0xf93ee042, 0x9c59db04, 0x1afc500b, 0x7f9b6b4d, 0xd0322687,\n    0xb5551dc1, 0x5411bb52, 0x31768014, 0x9edfcdde, 0xfbb8f698,\n    0x872786b9, 0xe240bdff, 0x4de9f035, 0x288ecb73, 0xc9ca6de0,\n    0xacad56a6, 0x03041b6c, 0x6663202a, 0xfa3afb2e, 0x9f5dc068,\n    0x30f48da2, 0x5593b6e4, 0xb4d71077, 0xd1b02b31, 0x7e1966fb,\n    0x1b7e5dbd, 0x67e12d9c, 0x028616da, 0xad2f5b10, 0xc8486056,\n    0x290cc6c5, 0x4c6bfd83, 0xe3c2b049, 0x86a58b0f, 0x35f8a016,\n    0x509f9b50, 0xff36d69a, 0x9a51eddc, 0x7b154b4f, 0x1e727009,\n    0xb1db3dc3, 0xd4bc0685, 0xa82376a4, 0xcd444de2, 0x62ed0028,\n    0x078a3b6e, 0xe6ce9dfd, 0x83a9a6bb, 0x2c00eb71, 0x4967d037,\n    0xd53e0b33, 0xb0593075, 0x1ff07dbf, 0x7a9746f9, 0x9bd3e06a,\n    0xfeb4db2c, 0x511d96e6, 0x347aada0, 0x48e5dd81, 0x2d82e6c7,\n    0x822bab0d, 0xe74c904b, 0x060836d8, 0x636f0d9e, 0xccc64054,\n    0xa9a17b12, 0x2f04f01d, 0x4a63cb5b, 0xe5ca8691, 0x80adbdd7,\n    0x61e91b44, 0x048e2002, 0xab276dc8, 0xce40568e, 0xb2df26af,\n    0xd7b81de9, 0x78115023, 0x1d766b65, 0xfc32cdf6, 0x9955f6b0,\n    0x36fcbb7a, 0x539b803c, 0xcfc25b38, 0xaaa5607e, 0x050c2db4,\n    0x606b16f2, 0x812fb061, 0xe4488b27, 0x4be1c6ed, 0x2e86fdab,\n    0x52198d8a, 0x377eb6cc, 0x98d7fb06, 0xfdb0c040, 0x1cf466d3,\n    0x79935d95, 0xd63a105f, 0xb35d2b19, 0x6bf1402c, 0x0e967b6a,\n    0xa13f36a0, 0xc4580de6, 0x251cab75, 0x407b9033, 0xefd2ddf9,\n    0x8ab5e6bf, 0xf62a969e, 0x934dadd8, 0x3ce4e012, 0x5983db54,\n    0xb8c77dc7, 0xdda04681, 0x72090b4b, 0x176e300d, 0x8b37eb09,\n    0xee50d04f, 0x41f99d85, 0x249ea6c3, 0xc5da0050, 0xa0bd3b16,\n    0x0f1476dc, 0x6a734d9a, 0x16ec3dbb, 0x738b06fd, 0xdc224b37,\n    0xb9457071, 0x5801d6e2, 0x3d66eda4, 0x92cfa06e, 0xf7a89b28,\n    0x710d1027, 0x146a2b61, 0xbbc366ab, 0xdea45ded, 0x3fe0fb7e,\n    0x5a87c038, 0xf52e8df2, 0x9049b6b4, 0xecd6c695, 0x89b1fdd3,\n    0x2618b019, 0x437f8b5f, 0xa23b2dcc, 0xc75c168a, 0x68f55b40,\n    0x0d926006, 0x91cbbb02, 0xf4ac8044, 0x5b05cd8e, 0x3e62f6c8,\n    0xdf26505b, 0xba416b1d, 0x15e826d7, 0x708f1d91, 0x0c106db0,\n    0x697756f6, 0xc6de1b3c, 0xa3b9207a, 0x42fd86e9, 0x279abdaf,\n    0x8833f065, 0xed54cb23, 0x5e09e03a, 0x3b6edb7c, 0x94c796b6,\n    0xf1a0adf0, 0x10e40b63, 0x75833025, 0xda2a7def, 0xbf4d46a9,\n    0xc3d23688, 0xa6b50dce, 0x091c4004, 0x6c7b7b42, 0x8d3fddd1,\n    0xe858e697, 0x47f1ab5d, 0x2296901b, 0xbecf4b1f, 0xdba87059,\n    0x74013d93, 0x116606d5, 0xf022a046, 0x95459b00, 0x3aecd6ca,\n    0x5f8bed8c, 0x23149dad, 0x4673a6eb, 0xe9daeb21, 0x8cbdd067,\n    0x6df976f4, 0x089e4db2, 0xa7370078, 0xc2503b3e, 0x44f5b031,\n    0x21928b77, 0x8e3bc6bd, 0xeb5cfdfb, 0x0a185b68, 0x6f7f602e,\n    0xc0d62de4, 0xa5b116a2, 0xd92e6683, 0xbc495dc5, 0x13e0100f,\n    0x76872b49, 0x97c38dda, 0xf2a4b69c, 0x5d0dfb56, 0x386ac010,\n    0xa4331b14, 0xc1542052, 0x6efd6d98, 0x0b9a56de, 0xeadef04d,\n    0x8fb9cb0b, 0x201086c1, 0x4577bd87, 0x39e8cda6, 0x5c8ff6e0,\n    0xf326bb2a, 0x9641806c, 0x770526ff, 0x12621db9, 0xbdcb5073,\n    0xd8ac6b35},\n   {0x00000000, 0xd7e28058, 0x74b406f1, 0xa35686a9, 0xe9680de2,\n    0x3e8a8dba, 0x9ddc0b13, 0x4a3e8b4b, 0x09a11d85, 0xde439ddd,\n    0x7d151b74, 0xaaf79b2c, 0xe0c91067, 0x372b903f, 0x947d1696,\n    0x439f96ce, 0x13423b0a, 0xc4a0bb52, 0x67f63dfb, 0xb014bda3,\n    0xfa2a36e8, 0x2dc8b6b0, 0x8e9e3019, 0x597cb041, 0x1ae3268f,\n    0xcd01a6d7, 0x6e57207e, 0xb9b5a026, 0xf38b2b6d, 0x2469ab35,\n    0x873f2d9c, 0x50ddadc4, 0x26847614, 0xf166f64c, 0x523070e5,\n    0x85d2f0bd, 0xcfec7bf6, 0x180efbae, 0xbb587d07, 0x6cbafd5f,\n    0x2f256b91, 0xf8c7ebc9, 0x5b916d60, 0x8c73ed38, 0xc64d6673,\n    0x11afe62b, 0xb2f96082, 0x651be0da, 0x35c64d1e, 0xe224cd46,\n    0x41724bef, 0x9690cbb7, 0xdcae40fc, 0x0b4cc0a4, 0xa81a460d,\n    0x7ff8c655, 0x3c67509b, 0xeb85d0c3, 0x48d3566a, 0x9f31d632,\n    0xd50f5d79, 0x02eddd21, 0xa1bb5b88, 0x7659dbd0, 0x4d08ec28,\n    0x9aea6c70, 0x39bcead9, 0xee5e6a81, 0xa460e1ca, 0x73826192,\n    0xd0d4e73b, 0x07366763, 0x44a9f1ad, 0x934b71f5, 0x301df75c,\n    0xe7ff7704, 0xadc1fc4f, 0x7a237c17, 0xd975fabe, 0x0e977ae6,\n    0x5e4ad722, 0x89a8577a, 0x2afed1d3, 0xfd1c518b, 0xb722dac0,\n    0x60c05a98, 0xc396dc31, 0x14745c69, 0x57ebcaa7, 0x80094aff,\n    0x235fcc56, 0xf4bd4c0e, 0xbe83c745, 0x6961471d, 0xca37c1b4,\n    0x1dd541ec, 0x6b8c9a3c, 0xbc6e1a64, 0x1f389ccd, 0xc8da1c95,\n    0x82e497de, 0x55061786, 0xf650912f, 0x21b21177, 0x622d87b9,\n    0xb5cf07e1, 0x16998148, 0xc17b0110, 0x8b458a5b, 0x5ca70a03,\n    0xfff18caa, 0x28130cf2, 0x78cea136, 0xaf2c216e, 0x0c7aa7c7,\n    0xdb98279f, 0x91a6acd4, 0x46442c8c, 0xe512aa25, 0x32f02a7d,\n    0x716fbcb3, 0xa68d3ceb, 0x05dbba42, 0xd2393a1a, 0x9807b151,\n    0x4fe53109, 0xecb3b7a0, 0x3b5137f8, 0x9a11d850, 0x4df35808,\n    0xeea5dea1, 0x39475ef9, 0x7379d5b2, 0xa49b55ea, 0x07cdd343,\n    0xd02f531b, 0x93b0c5d5, 0x4452458d, 0xe704c324, 0x30e6437c,\n    0x7ad8c837, 0xad3a486f, 0x0e6ccec6, 0xd98e4e9e, 0x8953e35a,\n    0x5eb16302, 0xfde7e5ab, 0x2a0565f3, 0x603beeb8, 0xb7d96ee0,\n    0x148fe849, 0xc36d6811, 0x80f2fedf, 0x57107e87, 0xf446f82e,\n    0x23a47876, 0x699af33d, 0xbe787365, 0x1d2ef5cc, 0xcacc7594,\n    0xbc95ae44, 0x6b772e1c, 0xc821a8b5, 0x1fc328ed, 0x55fda3a6,\n    0x821f23fe, 0x2149a557, 0xf6ab250f, 0xb534b3c1, 0x62d63399,\n    0xc180b530, 0x16623568, 0x5c5cbe23, 0x8bbe3e7b, 0x28e8b8d2,\n    0xff0a388a, 0xafd7954e, 0x78351516, 0xdb6393bf, 0x0c8113e7,\n    0x46bf98ac, 0x915d18f4, 0x320b9e5d, 0xe5e91e05, 0xa67688cb,\n    0x71940893, 0xd2c28e3a, 0x05200e62, 0x4f1e8529, 0x98fc0571,\n    0x3baa83d8, 0xec480380, 0xd7193478, 0x00fbb420, 0xa3ad3289,\n    0x744fb2d1, 0x3e71399a, 0xe993b9c2, 0x4ac53f6b, 0x9d27bf33,\n    0xdeb829fd, 0x095aa9a5, 0xaa0c2f0c, 0x7deeaf54, 0x37d0241f,\n    0xe032a447, 0x436422ee, 0x9486a2b6, 0xc45b0f72, 0x13b98f2a,\n    0xb0ef0983, 0x670d89db, 0x2d330290, 0xfad182c8, 0x59870461,\n    0x8e658439, 0xcdfa12f7, 0x1a1892af, 0xb94e1406, 0x6eac945e,\n    0x24921f15, 0xf3709f4d, 0x502619e4, 0x87c499bc, 0xf19d426c,\n    0x267fc234, 0x8529449d, 0x52cbc4c5, 0x18f54f8e, 0xcf17cfd6,\n    0x6c41497f, 0xbba3c927, 0xf83c5fe9, 0x2fdedfb1, 0x8c885918,\n    0x5b6ad940, 0x1154520b, 0xc6b6d253, 0x65e054fa, 0xb202d4a2,\n    0xe2df7966, 0x353df93e, 0x966b7f97, 0x4189ffcf, 0x0bb77484,\n    0xdc55f4dc, 0x7f037275, 0xa8e1f22d, 0xeb7e64e3, 0x3c9ce4bb,\n    0x9fca6212, 0x4828e24a, 0x02166901, 0xd5f4e959, 0x76a26ff0,\n    0xa140efa8},\n   {0x00000000, 0xef52b6e1, 0x05d46b83, 0xea86dd62, 0x0ba8d706,\n    0xe4fa61e7, 0x0e7cbc85, 0xe12e0a64, 0x1751ae0c, 0xf80318ed,\n    0x1285c58f, 0xfdd7736e, 0x1cf9790a, 0xf3abcfeb, 0x192d1289,\n    0xf67fa468, 0x2ea35c18, 0xc1f1eaf9, 0x2b77379b, 0xc425817a,\n    0x250b8b1e, 0xca593dff, 0x20dfe09d, 0xcf8d567c, 0x39f2f214,\n    0xd6a044f5, 0x3c269997, 0xd3742f76, 0x325a2512, 0xdd0893f3,\n    0x378e4e91, 0xd8dcf870, 0x5d46b830, 0xb2140ed1, 0x5892d3b3,\n    0xb7c06552, 0x56ee6f36, 0xb9bcd9d7, 0x533a04b5, 0xbc68b254,\n    0x4a17163c, 0xa545a0dd, 0x4fc37dbf, 0xa091cb5e, 0x41bfc13a,\n    0xaeed77db, 0x446baab9, 0xab391c58, 0x73e5e428, 0x9cb752c9,\n    0x76318fab, 0x9963394a, 0x784d332e, 0x971f85cf, 0x7d9958ad,\n    0x92cbee4c, 0x64b44a24, 0x8be6fcc5, 0x616021a7, 0x8e329746,\n    0x6f1c9d22, 0x804e2bc3, 0x6ac8f6a1, 0x859a4040, 0xba8d7060,\n    0x55dfc681, 0xbf591be3, 0x500bad02, 0xb125a766, 0x5e771187,\n    0xb4f1cce5, 0x5ba37a04, 0xaddcde6c, 0x428e688d, 0xa808b5ef,\n    0x475a030e, 0xa674096a, 0x4926bf8b, 0xa3a062e9, 0x4cf2d408,\n    0x942e2c78, 0x7b7c9a99, 0x91fa47fb, 0x7ea8f11a, 0x9f86fb7e,\n    0x70d44d9f, 0x9a5290fd, 0x7500261c, 0x837f8274, 0x6c2d3495,\n    0x86abe9f7, 0x69f95f16, 0x88d75572, 0x6785e393, 0x8d033ef1,\n    0x62518810, 0xe7cbc850, 0x08997eb1, 0xe21fa3d3, 0x0d4d1532,\n    0xec631f56, 0x0331a9b7, 0xe9b774d5, 0x06e5c234, 0xf09a665c,\n    0x1fc8d0bd, 0xf54e0ddf, 0x1a1cbb3e, 0xfb32b15a, 0x146007bb,\n    0xfee6dad9, 0x11b46c38, 0xc9689448, 0x263a22a9, 0xccbcffcb,\n    0x23ee492a, 0xc2c0434e, 0x2d92f5af, 0xc71428cd, 0x28469e2c,\n    0xde393a44, 0x316b8ca5, 0xdbed51c7, 0x34bfe726, 0xd591ed42,\n    0x3ac35ba3, 0xd04586c1, 0x3f173020, 0xae6be681, 0x41395060,\n    0xabbf8d02, 0x44ed3be3, 0xa5c33187, 0x4a918766, 0xa0175a04,\n    0x4f45ece5, 0xb93a488d, 0x5668fe6c, 0xbcee230e, 0x53bc95ef,\n    0xb2929f8b, 0x5dc0296a, 0xb746f408, 0x581442e9, 0x80c8ba99,\n    0x6f9a0c78, 0x851cd11a, 0x6a4e67fb, 0x8b606d9f, 0x6432db7e,\n    0x8eb4061c, 0x61e6b0fd, 0x97991495, 0x78cba274, 0x924d7f16,\n    0x7d1fc9f7, 0x9c31c393, 0x73637572, 0x99e5a810, 0x76b71ef1,\n    0xf32d5eb1, 0x1c7fe850, 0xf6f93532, 0x19ab83d3, 0xf88589b7,\n    0x17d73f56, 0xfd51e234, 0x120354d5, 0xe47cf0bd, 0x0b2e465c,\n    0xe1a89b3e, 0x0efa2ddf, 0xefd427bb, 0x0086915a, 0xea004c38,\n    0x0552fad9, 0xdd8e02a9, 0x32dcb448, 0xd85a692a, 0x3708dfcb,\n    0xd626d5af, 0x3974634e, 0xd3f2be2c, 0x3ca008cd, 0xcadfaca5,\n    0x258d1a44, 0xcf0bc726, 0x205971c7, 0xc1777ba3, 0x2e25cd42,\n    0xc4a31020, 0x2bf1a6c1, 0x14e696e1, 0xfbb42000, 0x1132fd62,\n    0xfe604b83, 0x1f4e41e7, 0xf01cf706, 0x1a9a2a64, 0xf5c89c85,\n    0x03b738ed, 0xece58e0c, 0x0663536e, 0xe931e58f, 0x081fefeb,\n    0xe74d590a, 0x0dcb8468, 0xe2993289, 0x3a45caf9, 0xd5177c18,\n    0x3f91a17a, 0xd0c3179b, 0x31ed1dff, 0xdebfab1e, 0x3439767c,\n    0xdb6bc09d, 0x2d1464f5, 0xc246d214, 0x28c00f76, 0xc792b997,\n    0x26bcb3f3, 0xc9ee0512, 0x2368d870, 0xcc3a6e91, 0x49a02ed1,\n    0xa6f29830, 0x4c744552, 0xa326f3b3, 0x4208f9d7, 0xad5a4f36,\n    0x47dc9254, 0xa88e24b5, 0x5ef180dd, 0xb1a3363c, 0x5b25eb5e,\n    0xb4775dbf, 0x555957db, 0xba0be13a, 0x508d3c58, 0xbfdf8ab9,\n    0x670372c9, 0x8851c428, 0x62d7194a, 0x8d85afab, 0x6caba5cf,\n    0x83f9132e, 0x697fce4c, 0x862d78ad, 0x7052dcc5, 0x9f006a24,\n    0x7586b746, 0x9ad401a7, 0x7bfa0bc3, 0x94a8bd22, 0x7e2e6040,\n    0x917cd6a1},\n   {0x00000000, 0x87a6cb43, 0xd43c90c7, 0x539a5b84, 0x730827cf,\n    0xf4aeec8c, 0xa734b708, 0x20927c4b, 0xe6104f9e, 0x61b684dd,\n    0x322cdf59, 0xb58a141a, 0x95186851, 0x12bea312, 0x4124f896,\n    0xc68233d5, 0x1751997d, 0x90f7523e, 0xc36d09ba, 0x44cbc2f9,\n    0x6459beb2, 0xe3ff75f1, 0xb0652e75, 0x37c3e536, 0xf141d6e3,\n    0x76e71da0, 0x257d4624, 0xa2db8d67, 0x8249f12c, 0x05ef3a6f,\n    0x567561eb, 0xd1d3aaa8, 0x2ea332fa, 0xa905f9b9, 0xfa9fa23d,\n    0x7d39697e, 0x5dab1535, 0xda0dde76, 0x899785f2, 0x0e314eb1,\n    0xc8b37d64, 0x4f15b627, 0x1c8feda3, 0x9b2926e0, 0xbbbb5aab,\n    0x3c1d91e8, 0x6f87ca6c, 0xe821012f, 0x39f2ab87, 0xbe5460c4,\n    0xedce3b40, 0x6a68f003, 0x4afa8c48, 0xcd5c470b, 0x9ec61c8f,\n    0x1960d7cc, 0xdfe2e419, 0x58442f5a, 0x0bde74de, 0x8c78bf9d,\n    0xaceac3d6, 0x2b4c0895, 0x78d65311, 0xff709852, 0x5d4665f4,\n    0xdae0aeb7, 0x897af533, 0x0edc3e70, 0x2e4e423b, 0xa9e88978,\n    0xfa72d2fc, 0x7dd419bf, 0xbb562a6a, 0x3cf0e129, 0x6f6abaad,\n    0xe8cc71ee, 0xc85e0da5, 0x4ff8c6e6, 0x1c629d62, 0x9bc45621,\n    0x4a17fc89, 0xcdb137ca, 0x9e2b6c4e, 0x198da70d, 0x391fdb46,\n    0xbeb91005, 0xed234b81, 0x6a8580c2, 0xac07b317, 0x2ba17854,\n    0x783b23d0, 0xff9de893, 0xdf0f94d8, 0x58a95f9b, 0x0b33041f,\n    0x8c95cf5c, 0x73e5570e, 0xf4439c4d, 0xa7d9c7c9, 0x207f0c8a,\n    0x00ed70c1, 0x874bbb82, 0xd4d1e006, 0x53772b45, 0x95f51890,\n    0x1253d3d3, 0x41c98857, 0xc66f4314, 0xe6fd3f5f, 0x615bf41c,\n    0x32c1af98, 0xb56764db, 0x64b4ce73, 0xe3120530, 0xb0885eb4,\n    0x372e95f7, 0x17bce9bc, 0x901a22ff, 0xc380797b, 0x4426b238,\n    0x82a481ed, 0x05024aae, 0x5698112a, 0xd13eda69, 0xf1aca622,\n    0x760a6d61, 0x259036e5, 0xa236fda6, 0xba8ccbe8, 0x3d2a00ab,\n    0x6eb05b2f, 0xe916906c, 0xc984ec27, 0x4e222764, 0x1db87ce0,\n    0x9a1eb7a3, 0x5c9c8476, 0xdb3a4f35, 0x88a014b1, 0x0f06dff2,\n    0x2f94a3b9, 0xa83268fa, 0xfba8337e, 0x7c0ef83d, 0xaddd5295,\n    0x2a7b99d6, 0x79e1c252, 0xfe470911, 0xded5755a, 0x5973be19,\n    0x0ae9e59d, 0x8d4f2ede, 0x4bcd1d0b, 0xcc6bd648, 0x9ff18dcc,\n    0x1857468f, 0x38c53ac4, 0xbf63f187, 0xecf9aa03, 0x6b5f6140,\n    0x942ff912, 0x13893251, 0x401369d5, 0xc7b5a296, 0xe727dedd,\n    0x6081159e, 0x331b4e1a, 0xb4bd8559, 0x723fb68c, 0xf5997dcf,\n    0xa603264b, 0x21a5ed08, 0x01379143, 0x86915a00, 0xd50b0184,\n    0x52adcac7, 0x837e606f, 0x04d8ab2c, 0x5742f0a8, 0xd0e43beb,\n    0xf07647a0, 0x77d08ce3, 0x244ad767, 0xa3ec1c24, 0x656e2ff1,\n    0xe2c8e4b2, 0xb152bf36, 0x36f47475, 0x1666083e, 0x91c0c37d,\n    0xc25a98f9, 0x45fc53ba, 0xe7caae1c, 0x606c655f, 0x33f63edb,\n    0xb450f598, 0x94c289d3, 0x13644290, 0x40fe1914, 0xc758d257,\n    0x01dae182, 0x867c2ac1, 0xd5e67145, 0x5240ba06, 0x72d2c64d,\n    0xf5740d0e, 0xa6ee568a, 0x21489dc9, 0xf09b3761, 0x773dfc22,\n    0x24a7a7a6, 0xa3016ce5, 0x839310ae, 0x0435dbed, 0x57af8069,\n    0xd0094b2a, 0x168b78ff, 0x912db3bc, 0xc2b7e838, 0x4511237b,\n    0x65835f30, 0xe2259473, 0xb1bfcff7, 0x361904b4, 0xc9699ce6,\n    0x4ecf57a5, 0x1d550c21, 0x9af3c762, 0xba61bb29, 0x3dc7706a,\n    0x6e5d2bee, 0xe9fbe0ad, 0x2f79d378, 0xa8df183b, 0xfb4543bf,\n    0x7ce388fc, 0x5c71f4b7, 0xdbd73ff4, 0x884d6470, 0x0febaf33,\n    0xde38059b, 0x599eced8, 0x0a04955c, 0x8da25e1f, 0xad302254,\n    0x2a96e917, 0x790cb293, 0xfeaa79d0, 0x38284a05, 0xbf8e8146,\n    0xec14dac2, 0x6bb21181, 0x4b206dca, 0xcc86a689, 0x9f1cfd0d,\n    0x18ba364e}};\n\nstatic const z_word_t crc_braid_big_table[][256] = {\n   {0x00000000, 0x43cba687, 0xc7903cd4, 0x845b9a53, 0xcf270873,\n    0x8cecaef4, 0x08b734a7, 0x4b7c9220, 0x9e4f10e6, 0xdd84b661,\n    0x59df2c32, 0x1a148ab5, 0x51681895, 0x12a3be12, 0x96f82441,\n    0xd53382c6, 0x7d995117, 0x3e52f790, 0xba096dc3, 0xf9c2cb44,\n    0xb2be5964, 0xf175ffe3, 0x752e65b0, 0x36e5c337, 0xe3d641f1,\n    0xa01de776, 0x24467d25, 0x678ddba2, 0x2cf14982, 0x6f3aef05,\n    0xeb617556, 0xa8aad3d1, 0xfa32a32e, 0xb9f905a9, 0x3da29ffa,\n    0x7e69397d, 0x3515ab5d, 0x76de0dda, 0xf2859789, 0xb14e310e,\n    0x647db3c8, 0x27b6154f, 0xa3ed8f1c, 0xe026299b, 0xab5abbbb,\n    0xe8911d3c, 0x6cca876f, 0x2f0121e8, 0x87abf239, 0xc46054be,\n    0x403bceed, 0x03f0686a, 0x488cfa4a, 0x0b475ccd, 0x8f1cc69e,\n    0xccd76019, 0x19e4e2df, 0x5a2f4458, 0xde74de0b, 0x9dbf788c,\n    0xd6c3eaac, 0x95084c2b, 0x1153d678, 0x529870ff, 0xf465465d,\n    0xb7aee0da, 0x33f57a89, 0x703edc0e, 0x3b424e2e, 0x7889e8a9,\n    0xfcd272fa, 0xbf19d47d, 0x6a2a56bb, 0x29e1f03c, 0xadba6a6f,\n    0xee71cce8, 0xa50d5ec8, 0xe6c6f84f, 0x629d621c, 0x2156c49b,\n    0x89fc174a, 0xca37b1cd, 0x4e6c2b9e, 0x0da78d19, 0x46db1f39,\n    0x0510b9be, 0x814b23ed, 0xc280856a, 0x17b307ac, 0x5478a12b,\n    0xd0233b78, 0x93e89dff, 0xd8940fdf, 0x9b5fa958, 0x1f04330b,\n    0x5ccf958c, 0x0e57e573, 0x4d9c43f4, 0xc9c7d9a7, 0x8a0c7f20,\n    0xc170ed00, 0x82bb4b87, 0x06e0d1d4, 0x452b7753, 0x9018f595,\n    0xd3d35312, 0x5788c941, 0x14436fc6, 0x5f3ffde6, 0x1cf45b61,\n    0x98afc132, 0xdb6467b5, 0x73ceb464, 0x300512e3, 0xb45e88b0,\n    0xf7952e37, 0xbce9bc17, 0xff221a90, 0x7b7980c3, 0x38b22644,\n    0xed81a482, 0xae4a0205, 0x2a119856, 0x69da3ed1, 0x22a6acf1,\n    0x616d0a76, 0xe5369025, 0xa6fd36a2, 0xe8cb8cba, 0xab002a3d,\n    0x2f5bb06e, 0x6c9016e9, 0x27ec84c9, 0x6427224e, 0xe07cb81d,\n    0xa3b71e9a, 0x76849c5c, 0x354f3adb, 0xb114a088, 0xf2df060f,\n    0xb9a3942f, 0xfa6832a8, 0x7e33a8fb, 0x3df80e7c, 0x9552ddad,\n    0xd6997b2a, 0x52c2e179, 0x110947fe, 0x5a75d5de, 0x19be7359,\n    0x9de5e90a, 0xde2e4f8d, 0x0b1dcd4b, 0x48d66bcc, 0xcc8df19f,\n    0x8f465718, 0xc43ac538, 0x87f163bf, 0x03aaf9ec, 0x40615f6b,\n    0x12f92f94, 0x51328913, 0xd5691340, 0x96a2b5c7, 0xddde27e7,\n    0x9e158160, 0x1a4e1b33, 0x5985bdb4, 0x8cb63f72, 0xcf7d99f5,\n    0x4b2603a6, 0x08eda521, 0x43913701, 0x005a9186, 0x84010bd5,\n    0xc7caad52, 0x6f607e83, 0x2cabd804, 0xa8f04257, 0xeb3be4d0,\n    0xa04776f0, 0xe38cd077, 0x67d74a24, 0x241ceca3, 0xf12f6e65,\n    0xb2e4c8e2, 0x36bf52b1, 0x7574f436, 0x3e086616, 0x7dc3c091,\n    0xf9985ac2, 0xba53fc45, 0x1caecae7, 0x5f656c60, 0xdb3ef633,\n    0x98f550b4, 0xd389c294, 0x90426413, 0x1419fe40, 0x57d258c7,\n    0x82e1da01, 0xc12a7c86, 0x4571e6d5, 0x06ba4052, 0x4dc6d272,\n    0x0e0d74f5, 0x8a56eea6, 0xc99d4821, 0x61379bf0, 0x22fc3d77,\n    0xa6a7a724, 0xe56c01a3, 0xae109383, 0xeddb3504, 0x6980af57,\n    0x2a4b09d0, 0xff788b16, 0xbcb32d91, 0x38e8b7c2, 0x7b231145,\n    0x305f8365, 0x739425e2, 0xf7cfbfb1, 0xb4041936, 0xe69c69c9,\n    0xa557cf4e, 0x210c551d, 0x62c7f39a, 0x29bb61ba, 0x6a70c73d,\n    0xee2b5d6e, 0xade0fbe9, 0x78d3792f, 0x3b18dfa8, 0xbf4345fb,\n    0xfc88e37c, 0xb7f4715c, 0xf43fd7db, 0x70644d88, 0x33afeb0f,\n    0x9b0538de, 0xd8ce9e59, 0x5c95040a, 0x1f5ea28d, 0x542230ad,\n    0x17e9962a, 0x93b20c79, 0xd079aafe, 0x054a2838, 0x46818ebf,\n    0xc2da14ec, 0x8111b26b, 0xca6d204b, 0x89a686cc, 0x0dfd1c9f,\n    0x4e36ba18},\n   {0x00000000, 0xe1b652ef, 0x836bd405, 0x62dd86ea, 0x06d7a80b,\n    0xe761fae4, 0x85bc7c0e, 0x640a2ee1, 0x0cae5117, 0xed1803f8,\n    0x8fc58512, 0x6e73d7fd, 0x0a79f91c, 0xebcfabf3, 0x89122d19,\n    0x68a47ff6, 0x185ca32e, 0xf9eaf1c1, 0x9b37772b, 0x7a8125c4,\n    0x1e8b0b25, 0xff3d59ca, 0x9de0df20, 0x7c568dcf, 0x14f2f239,\n    0xf544a0d6, 0x9799263c, 0x762f74d3, 0x12255a32, 0xf39308dd,\n    0x914e8e37, 0x70f8dcd8, 0x30b8465d, 0xd10e14b2, 0xb3d39258,\n    0x5265c0b7, 0x366fee56, 0xd7d9bcb9, 0xb5043a53, 0x54b268bc,\n    0x3c16174a, 0xdda045a5, 0xbf7dc34f, 0x5ecb91a0, 0x3ac1bf41,\n    0xdb77edae, 0xb9aa6b44, 0x581c39ab, 0x28e4e573, 0xc952b79c,\n    0xab8f3176, 0x4a396399, 0x2e334d78, 0xcf851f97, 0xad58997d,\n    0x4ceecb92, 0x244ab464, 0xc5fce68b, 0xa7216061, 0x4697328e,\n    0x229d1c6f, 0xc32b4e80, 0xa1f6c86a, 0x40409a85, 0x60708dba,\n    0x81c6df55, 0xe31b59bf, 0x02ad0b50, 0x66a725b1, 0x8711775e,\n    0xe5ccf1b4, 0x047aa35b, 0x6cdedcad, 0x8d688e42, 0xefb508a8,\n    0x0e035a47, 0x6a0974a6, 0x8bbf2649, 0xe962a0a3, 0x08d4f24c,\n    0x782c2e94, 0x999a7c7b, 0xfb47fa91, 0x1af1a87e, 0x7efb869f,\n    0x9f4dd470, 0xfd90529a, 0x1c260075, 0x74827f83, 0x95342d6c,\n    0xf7e9ab86, 0x165ff969, 0x7255d788, 0x93e38567, 0xf13e038d,\n    0x10885162, 0x50c8cbe7, 0xb17e9908, 0xd3a31fe2, 0x32154d0d,\n    0x561f63ec, 0xb7a93103, 0xd574b7e9, 0x34c2e506, 0x5c669af0,\n    0xbdd0c81f, 0xdf0d4ef5, 0x3ebb1c1a, 0x5ab132fb, 0xbb076014,\n    0xd9dae6fe, 0x386cb411, 0x489468c9, 0xa9223a26, 0xcbffbccc,\n    0x2a49ee23, 0x4e43c0c2, 0xaff5922d, 0xcd2814c7, 0x2c9e4628,\n    0x443a39de, 0xa58c6b31, 0xc751eddb, 0x26e7bf34, 0x42ed91d5,\n    0xa35bc33a, 0xc18645d0, 0x2030173f, 0x81e66bae, 0x60503941,\n    0x028dbfab, 0xe33bed44, 0x8731c3a5, 0x6687914a, 0x045a17a0,\n    0xe5ec454f, 0x8d483ab9, 0x6cfe6856, 0x0e23eebc, 0xef95bc53,\n    0x8b9f92b2, 0x6a29c05d, 0x08f446b7, 0xe9421458, 0x99bac880,\n    0x780c9a6f, 0x1ad11c85, 0xfb674e6a, 0x9f6d608b, 0x7edb3264,\n    0x1c06b48e, 0xfdb0e661, 0x95149997, 0x74a2cb78, 0x167f4d92,\n    0xf7c91f7d, 0x93c3319c, 0x72756373, 0x10a8e599, 0xf11eb776,\n    0xb15e2df3, 0x50e87f1c, 0x3235f9f6, 0xd383ab19, 0xb78985f8,\n    0x563fd717, 0x34e251fd, 0xd5540312, 0xbdf07ce4, 0x5c462e0b,\n    0x3e9ba8e1, 0xdf2dfa0e, 0xbb27d4ef, 0x5a918600, 0x384c00ea,\n    0xd9fa5205, 0xa9028edd, 0x48b4dc32, 0x2a695ad8, 0xcbdf0837,\n    0xafd526d6, 0x4e637439, 0x2cbef2d3, 0xcd08a03c, 0xa5acdfca,\n    0x441a8d25, 0x26c70bcf, 0xc7715920, 0xa37b77c1, 0x42cd252e,\n    0x2010a3c4, 0xc1a6f12b, 0xe196e614, 0x0020b4fb, 0x62fd3211,\n    0x834b60fe, 0xe7414e1f, 0x06f71cf0, 0x642a9a1a, 0x859cc8f5,\n    0xed38b703, 0x0c8ee5ec, 0x6e536306, 0x8fe531e9, 0xebef1f08,\n    0x0a594de7, 0x6884cb0d, 0x893299e2, 0xf9ca453a, 0x187c17d5,\n    0x7aa1913f, 0x9b17c3d0, 0xff1ded31, 0x1eabbfde, 0x7c763934,\n    0x9dc06bdb, 0xf564142d, 0x14d246c2, 0x760fc028, 0x97b992c7,\n    0xf3b3bc26, 0x1205eec9, 0x70d86823, 0x916e3acc, 0xd12ea049,\n    0x3098f2a6, 0x5245744c, 0xb3f326a3, 0xd7f90842, 0x364f5aad,\n    0x5492dc47, 0xb5248ea8, 0xdd80f15e, 0x3c36a3b1, 0x5eeb255b,\n    0xbf5d77b4, 0xdb575955, 0x3ae10bba, 0x583c8d50, 0xb98adfbf,\n    0xc9720367, 0x28c45188, 0x4a19d762, 0xabaf858d, 0xcfa5ab6c,\n    0x2e13f983, 0x4cce7f69, 0xad782d86, 0xc5dc5270, 0x246a009f,\n    0x46b78675, 0xa701d49a, 0xc30bfa7b, 0x22bda894, 0x40602e7e,\n    0xa1d67c91},\n   {0x00000000, 0x5880e2d7, 0xf106b474, 0xa98656a3, 0xe20d68e9,\n    0xba8d8a3e, 0x130bdc9d, 0x4b8b3e4a, 0x851da109, 0xdd9d43de,\n    0x741b157d, 0x2c9bf7aa, 0x6710c9e0, 0x3f902b37, 0x96167d94,\n    0xce969f43, 0x0a3b4213, 0x52bba0c4, 0xfb3df667, 0xa3bd14b0,\n    0xe8362afa, 0xb0b6c82d, 0x19309e8e, 0x41b07c59, 0x8f26e31a,\n    0xd7a601cd, 0x7e20576e, 0x26a0b5b9, 0x6d2b8bf3, 0x35ab6924,\n    0x9c2d3f87, 0xc4addd50, 0x14768426, 0x4cf666f1, 0xe5703052,\n    0xbdf0d285, 0xf67beccf, 0xaefb0e18, 0x077d58bb, 0x5ffdba6c,\n    0x916b252f, 0xc9ebc7f8, 0x606d915b, 0x38ed738c, 0x73664dc6,\n    0x2be6af11, 0x8260f9b2, 0xdae01b65, 0x1e4dc635, 0x46cd24e2,\n    0xef4b7241, 0xb7cb9096, 0xfc40aedc, 0xa4c04c0b, 0x0d461aa8,\n    0x55c6f87f, 0x9b50673c, 0xc3d085eb, 0x6a56d348, 0x32d6319f,\n    0x795d0fd5, 0x21dded02, 0x885bbba1, 0xd0db5976, 0x28ec084d,\n    0x706cea9a, 0xd9eabc39, 0x816a5eee, 0xcae160a4, 0x92618273,\n    0x3be7d4d0, 0x63673607, 0xadf1a944, 0xf5714b93, 0x5cf71d30,\n    0x0477ffe7, 0x4ffcc1ad, 0x177c237a, 0xbefa75d9, 0xe67a970e,\n    0x22d74a5e, 0x7a57a889, 0xd3d1fe2a, 0x8b511cfd, 0xc0da22b7,\n    0x985ac060, 0x31dc96c3, 0x695c7414, 0xa7caeb57, 0xff4a0980,\n    0x56cc5f23, 0x0e4cbdf4, 0x45c783be, 0x1d476169, 0xb4c137ca,\n    0xec41d51d, 0x3c9a8c6b, 0x641a6ebc, 0xcd9c381f, 0x951cdac8,\n    0xde97e482, 0x86170655, 0x2f9150f6, 0x7711b221, 0xb9872d62,\n    0xe107cfb5, 0x48819916, 0x10017bc1, 0x5b8a458b, 0x030aa75c,\n    0xaa8cf1ff, 0xf20c1328, 0x36a1ce78, 0x6e212caf, 0xc7a77a0c,\n    0x9f2798db, 0xd4aca691, 0x8c2c4446, 0x25aa12e5, 0x7d2af032,\n    0xb3bc6f71, 0xeb3c8da6, 0x42badb05, 0x1a3a39d2, 0x51b10798,\n    0x0931e54f, 0xa0b7b3ec, 0xf837513b, 0x50d8119a, 0x0858f34d,\n    0xa1dea5ee, 0xf95e4739, 0xb2d57973, 0xea559ba4, 0x43d3cd07,\n    0x1b532fd0, 0xd5c5b093, 0x8d455244, 0x24c304e7, 0x7c43e630,\n    0x37c8d87a, 0x6f483aad, 0xc6ce6c0e, 0x9e4e8ed9, 0x5ae35389,\n    0x0263b15e, 0xabe5e7fd, 0xf365052a, 0xb8ee3b60, 0xe06ed9b7,\n    0x49e88f14, 0x11686dc3, 0xdffef280, 0x877e1057, 0x2ef846f4,\n    0x7678a423, 0x3df39a69, 0x657378be, 0xccf52e1d, 0x9475ccca,\n    0x44ae95bc, 0x1c2e776b, 0xb5a821c8, 0xed28c31f, 0xa6a3fd55,\n    0xfe231f82, 0x57a54921, 0x0f25abf6, 0xc1b334b5, 0x9933d662,\n    0x30b580c1, 0x68356216, 0x23be5c5c, 0x7b3ebe8b, 0xd2b8e828,\n    0x8a380aff, 0x4e95d7af, 0x16153578, 0xbf9363db, 0xe713810c,\n    0xac98bf46, 0xf4185d91, 0x5d9e0b32, 0x051ee9e5, 0xcb8876a6,\n    0x93089471, 0x3a8ec2d2, 0x620e2005, 0x29851e4f, 0x7105fc98,\n    0xd883aa3b, 0x800348ec, 0x783419d7, 0x20b4fb00, 0x8932ada3,\n    0xd1b24f74, 0x9a39713e, 0xc2b993e9, 0x6b3fc54a, 0x33bf279d,\n    0xfd29b8de, 0xa5a95a09, 0x0c2f0caa, 0x54afee7d, 0x1f24d037,\n    0x47a432e0, 0xee226443, 0xb6a28694, 0x720f5bc4, 0x2a8fb913,\n    0x8309efb0, 0xdb890d67, 0x9002332d, 0xc882d1fa, 0x61048759,\n    0x3984658e, 0xf712facd, 0xaf92181a, 0x06144eb9, 0x5e94ac6e,\n    0x151f9224, 0x4d9f70f3, 0xe4192650, 0xbc99c487, 0x6c429df1,\n    0x34c27f26, 0x9d442985, 0xc5c4cb52, 0x8e4ff518, 0xd6cf17cf,\n    0x7f49416c, 0x27c9a3bb, 0xe95f3cf8, 0xb1dfde2f, 0x1859888c,\n    0x40d96a5b, 0x0b525411, 0x53d2b6c6, 0xfa54e065, 0xa2d402b2,\n    0x6679dfe2, 0x3ef93d35, 0x977f6b96, 0xcfff8941, 0x8474b70b,\n    0xdcf455dc, 0x7572037f, 0x2df2e1a8, 0xe3647eeb, 0xbbe49c3c,\n    0x1262ca9f, 0x4ae22848, 0x01691602, 0x59e9f4d5, 0xf06fa276,\n    0xa8ef40a1},\n   {0x00000000, 0x463b6765, 0x8c76ceca, 0xca4da9af, 0x59ebed4e,\n    0x1fd08a2b, 0xd59d2384, 0x93a644e1, 0xb2d6db9d, 0xf4edbcf8,\n    0x3ea01557, 0x789b7232, 0xeb3d36d3, 0xad0651b6, 0x674bf819,\n    0x21709f7c, 0x25abc6e0, 0x6390a185, 0xa9dd082a, 0xefe66f4f,\n    0x7c402bae, 0x3a7b4ccb, 0xf036e564, 0xb60d8201, 0x977d1d7d,\n    0xd1467a18, 0x1b0bd3b7, 0x5d30b4d2, 0xce96f033, 0x88ad9756,\n    0x42e03ef9, 0x04db599c, 0x0b50fc1a, 0x4d6b9b7f, 0x872632d0,\n    0xc11d55b5, 0x52bb1154, 0x14807631, 0xdecddf9e, 0x98f6b8fb,\n    0xb9862787, 0xffbd40e2, 0x35f0e94d, 0x73cb8e28, 0xe06dcac9,\n    0xa656adac, 0x6c1b0403, 0x2a206366, 0x2efb3afa, 0x68c05d9f,\n    0xa28df430, 0xe4b69355, 0x7710d7b4, 0x312bb0d1, 0xfb66197e,\n    0xbd5d7e1b, 0x9c2de167, 0xda168602, 0x105b2fad, 0x566048c8,\n    0xc5c60c29, 0x83fd6b4c, 0x49b0c2e3, 0x0f8ba586, 0x16a0f835,\n    0x509b9f50, 0x9ad636ff, 0xdced519a, 0x4f4b157b, 0x0970721e,\n    0xc33ddbb1, 0x8506bcd4, 0xa47623a8, 0xe24d44cd, 0x2800ed62,\n    0x6e3b8a07, 0xfd9dcee6, 0xbba6a983, 0x71eb002c, 0x37d06749,\n    0x330b3ed5, 0x753059b0, 0xbf7df01f, 0xf946977a, 0x6ae0d39b,\n    0x2cdbb4fe, 0xe6961d51, 0xa0ad7a34, 0x81dde548, 0xc7e6822d,\n    0x0dab2b82, 0x4b904ce7, 0xd8360806, 0x9e0d6f63, 0x5440c6cc,\n    0x127ba1a9, 0x1df0042f, 0x5bcb634a, 0x9186cae5, 0xd7bdad80,\n    0x441be961, 0x02208e04, 0xc86d27ab, 0x8e5640ce, 0xaf26dfb2,\n    0xe91db8d7, 0x23501178, 0x656b761d, 0xf6cd32fc, 0xb0f65599,\n    0x7abbfc36, 0x3c809b53, 0x385bc2cf, 0x7e60a5aa, 0xb42d0c05,\n    0xf2166b60, 0x61b02f81, 0x278b48e4, 0xedc6e14b, 0xabfd862e,\n    0x8a8d1952, 0xccb67e37, 0x06fbd798, 0x40c0b0fd, 0xd366f41c,\n    0x955d9379, 0x5f103ad6, 0x192b5db3, 0x2c40f16b, 0x6a7b960e,\n    0xa0363fa1, 0xe60d58c4, 0x75ab1c25, 0x33907b40, 0xf9ddd2ef,\n    0xbfe6b58a, 0x9e962af6, 0xd8ad4d93, 0x12e0e43c, 0x54db8359,\n    0xc77dc7b8, 0x8146a0dd, 0x4b0b0972, 0x0d306e17, 0x09eb378b,\n    0x4fd050ee, 0x859df941, 0xc3a69e24, 0x5000dac5, 0x163bbda0,\n    0xdc76140f, 0x9a4d736a, 0xbb3dec16, 0xfd068b73, 0x374b22dc,\n    0x717045b9, 0xe2d60158, 0xa4ed663d, 0x6ea0cf92, 0x289ba8f7,\n    0x27100d71, 0x612b6a14, 0xab66c3bb, 0xed5da4de, 0x7efbe03f,\n    0x38c0875a, 0xf28d2ef5, 0xb4b64990, 0x95c6d6ec, 0xd3fdb189,\n    0x19b01826, 0x5f8b7f43, 0xcc2d3ba2, 0x8a165cc7, 0x405bf568,\n    0x0660920d, 0x02bbcb91, 0x4480acf4, 0x8ecd055b, 0xc8f6623e,\n    0x5b5026df, 0x1d6b41ba, 0xd726e815, 0x911d8f70, 0xb06d100c,\n    0xf6567769, 0x3c1bdec6, 0x7a20b9a3, 0xe986fd42, 0xafbd9a27,\n    0x65f03388, 0x23cb54ed, 0x3ae0095e, 0x7cdb6e3b, 0xb696c794,\n    0xf0ada0f1, 0x630be410, 0x25308375, 0xef7d2ada, 0xa9464dbf,\n    0x8836d2c3, 0xce0db5a6, 0x04401c09, 0x427b7b6c, 0xd1dd3f8d,\n    0x97e658e8, 0x5dabf147, 0x1b909622, 0x1f4bcfbe, 0x5970a8db,\n    0x933d0174, 0xd5066611, 0x46a022f0, 0x009b4595, 0xcad6ec3a,\n    0x8ced8b5f, 0xad9d1423, 0xeba67346, 0x21ebdae9, 0x67d0bd8c,\n    0xf476f96d, 0xb24d9e08, 0x780037a7, 0x3e3b50c2, 0x31b0f544,\n    0x778b9221, 0xbdc63b8e, 0xfbfd5ceb, 0x685b180a, 0x2e607f6f,\n    0xe42dd6c0, 0xa216b1a5, 0x83662ed9, 0xc55d49bc, 0x0f10e013,\n    0x492b8776, 0xda8dc397, 0x9cb6a4f2, 0x56fb0d5d, 0x10c06a38,\n    0x141b33a4, 0x522054c1, 0x986dfd6e, 0xde569a0b, 0x4df0deea,\n    0x0bcbb98f, 0xc1861020, 0x87bd7745, 0xa6cde839, 0xe0f68f5c,\n    0x2abb26f3, 0x6c804196, 0xff260577, 0xb91d6212, 0x7350cbbd,\n    0x356bacd8}};\n\n#endif /* W */\n\n#endif /* N == 5 */\n#if N == 6\n\n#if W == 8\n\nstatic const uint32_t crc_braid_table[][256] = {\n   {0x00000000, 0x3db1ecdc, 0x7b63d9b8, 0x46d23564, 0xf6c7b370,\n    0xcb765fac, 0x8da46ac8, 0xb0158614, 0x36fe60a1, 0x0b4f8c7d,\n    0x4d9db919, 0x702c55c5, 0xc039d3d1, 0xfd883f0d, 0xbb5a0a69,\n    0x86ebe6b5, 0x6dfcc142, 0x504d2d9e, 0x169f18fa, 0x2b2ef426,\n    0x9b3b7232, 0xa68a9eee, 0xe058ab8a, 0xdde94756, 0x5b02a1e3,\n    0x66b34d3f, 0x2061785b, 0x1dd09487, 0xadc51293, 0x9074fe4f,\n    0xd6a6cb2b, 0xeb1727f7, 0xdbf98284, 0xe6486e58, 0xa09a5b3c,\n    0x9d2bb7e0, 0x2d3e31f4, 0x108fdd28, 0x565de84c, 0x6bec0490,\n    0xed07e225, 0xd0b60ef9, 0x96643b9d, 0xabd5d741, 0x1bc05155,\n    0x2671bd89, 0x60a388ed, 0x5d126431, 0xb60543c6, 0x8bb4af1a,\n    0xcd669a7e, 0xf0d776a2, 0x40c2f0b6, 0x7d731c6a, 0x3ba1290e,\n    0x0610c5d2, 0x80fb2367, 0xbd4acfbb, 0xfb98fadf, 0xc6291603,\n    0x763c9017, 0x4b8d7ccb, 0x0d5f49af, 0x30eea573, 0x6c820349,\n    0x5133ef95, 0x17e1daf1, 0x2a50362d, 0x9a45b039, 0xa7f45ce5,\n    0xe1266981, 0xdc97855d, 0x5a7c63e8, 0x67cd8f34, 0x211fba50,\n    0x1cae568c, 0xacbbd098, 0x910a3c44, 0xd7d80920, 0xea69e5fc,\n    0x017ec20b, 0x3ccf2ed7, 0x7a1d1bb3, 0x47acf76f, 0xf7b9717b,\n    0xca089da7, 0x8cdaa8c3, 0xb16b441f, 0x3780a2aa, 0x0a314e76,\n    0x4ce37b12, 0x715297ce, 0xc14711da, 0xfcf6fd06, 0xba24c862,\n    0x879524be, 0xb77b81cd, 0x8aca6d11, 0xcc185875, 0xf1a9b4a9,\n    0x41bc32bd, 0x7c0dde61, 0x3adfeb05, 0x076e07d9, 0x8185e16c,\n    0xbc340db0, 0xfae638d4, 0xc757d408, 0x7742521c, 0x4af3bec0,\n    0x0c218ba4, 0x31906778, 0xda87408f, 0xe736ac53, 0xa1e49937,\n    0x9c5575eb, 0x2c40f3ff, 0x11f11f23, 0x57232a47, 0x6a92c69b,\n    0xec79202e, 0xd1c8ccf2, 0x971af996, 0xaaab154a, 0x1abe935e,\n    0x270f7f82, 0x61dd4ae6, 0x5c6ca63a, 0xd9040692, 0xe4b5ea4e,\n    0xa267df2a, 0x9fd633f6, 0x2fc3b5e2, 0x1272593e, 0x54a06c5a,\n    0x69118086, 0xeffa6633, 0xd24b8aef, 0x9499bf8b, 0xa9285357,\n    0x193dd543, 0x248c399f, 0x625e0cfb, 0x5fefe027, 0xb4f8c7d0,\n    0x89492b0c, 0xcf9b1e68, 0xf22af2b4, 0x423f74a0, 0x7f8e987c,\n    0x395cad18, 0x04ed41c4, 0x8206a771, 0xbfb74bad, 0xf9657ec9,\n    0xc4d49215, 0x74c11401, 0x4970f8dd, 0x0fa2cdb9, 0x32132165,\n    0x02fd8416, 0x3f4c68ca, 0x799e5dae, 0x442fb172, 0xf43a3766,\n    0xc98bdbba, 0x8f59eede, 0xb2e80202, 0x3403e4b7, 0x09b2086b,\n    0x4f603d0f, 0x72d1d1d3, 0xc2c457c7, 0xff75bb1b, 0xb9a78e7f,\n    0x841662a3, 0x6f014554, 0x52b0a988, 0x14629cec, 0x29d37030,\n    0x99c6f624, 0xa4771af8, 0xe2a52f9c, 0xdf14c340, 0x59ff25f5,\n    0x644ec929, 0x229cfc4d, 0x1f2d1091, 0xaf389685, 0x92897a59,\n    0xd45b4f3d, 0xe9eaa3e1, 0xb58605db, 0x8837e907, 0xcee5dc63,\n    0xf35430bf, 0x4341b6ab, 0x7ef05a77, 0x38226f13, 0x059383cf,\n    0x8378657a, 0xbec989a6, 0xf81bbcc2, 0xc5aa501e, 0x75bfd60a,\n    0x480e3ad6, 0x0edc0fb2, 0x336de36e, 0xd87ac499, 0xe5cb2845,\n    0xa3191d21, 0x9ea8f1fd, 0x2ebd77e9, 0x130c9b35, 0x55deae51,\n    0x686f428d, 0xee84a438, 0xd33548e4, 0x95e77d80, 0xa856915c,\n    0x18431748, 0x25f2fb94, 0x6320cef0, 0x5e91222c, 0x6e7f875f,\n    0x53ce6b83, 0x151c5ee7, 0x28adb23b, 0x98b8342f, 0xa509d8f3,\n    0xe3dbed97, 0xde6a014b, 0x5881e7fe, 0x65300b22, 0x23e23e46,\n    0x1e53d29a, 0xae46548e, 0x93f7b852, 0xd5258d36, 0xe89461ea,\n    0x0383461d, 0x3e32aac1, 0x78e09fa5, 0x45517379, 0xf544f56d,\n    0xc8f519b1, 0x8e272cd5, 0xb396c009, 0x357d26bc, 0x08ccca60,\n    0x4e1eff04, 0x73af13d8, 0xc3ba95cc, 0xfe0b7910, 0xb8d94c74,\n    0x8568a0a8},\n   {0x00000000, 0x69790b65, 0xd2f216ca, 0xbb8b1daf, 0x7e952bd5,\n    0x17ec20b0, 0xac673d1f, 0xc51e367a, 0xfd2a57aa, 0x94535ccf,\n    0x2fd84160, 0x46a14a05, 0x83bf7c7f, 0xeac6771a, 0x514d6ab5,\n    0x383461d0, 0x2125a915, 0x485ca270, 0xf3d7bfdf, 0x9aaeb4ba,\n    0x5fb082c0, 0x36c989a5, 0x8d42940a, 0xe43b9f6f, 0xdc0ffebf,\n    0xb576f5da, 0x0efde875, 0x6784e310, 0xa29ad56a, 0xcbe3de0f,\n    0x7068c3a0, 0x1911c8c5, 0x424b522a, 0x2b32594f, 0x90b944e0,\n    0xf9c04f85, 0x3cde79ff, 0x55a7729a, 0xee2c6f35, 0x87556450,\n    0xbf610580, 0xd6180ee5, 0x6d93134a, 0x04ea182f, 0xc1f42e55,\n    0xa88d2530, 0x1306389f, 0x7a7f33fa, 0x636efb3f, 0x0a17f05a,\n    0xb19cedf5, 0xd8e5e690, 0x1dfbd0ea, 0x7482db8f, 0xcf09c620,\n    0xa670cd45, 0x9e44ac95, 0xf73da7f0, 0x4cb6ba5f, 0x25cfb13a,\n    0xe0d18740, 0x89a88c25, 0x3223918a, 0x5b5a9aef, 0x8496a454,\n    0xedefaf31, 0x5664b29e, 0x3f1db9fb, 0xfa038f81, 0x937a84e4,\n    0x28f1994b, 0x4188922e, 0x79bcf3fe, 0x10c5f89b, 0xab4ee534,\n    0xc237ee51, 0x0729d82b, 0x6e50d34e, 0xd5dbcee1, 0xbca2c584,\n    0xa5b30d41, 0xccca0624, 0x77411b8b, 0x1e3810ee, 0xdb262694,\n    0xb25f2df1, 0x09d4305e, 0x60ad3b3b, 0x58995aeb, 0x31e0518e,\n    0x8a6b4c21, 0xe3124744, 0x260c713e, 0x4f757a5b, 0xf4fe67f4,\n    0x9d876c91, 0xc6ddf67e, 0xafa4fd1b, 0x142fe0b4, 0x7d56ebd1,\n    0xb848ddab, 0xd131d6ce, 0x6abacb61, 0x03c3c004, 0x3bf7a1d4,\n    0x528eaab1, 0xe905b71e, 0x807cbc7b, 0x45628a01, 0x2c1b8164,\n    0x97909ccb, 0xfee997ae, 0xe7f85f6b, 0x8e81540e, 0x350a49a1,\n    0x5c7342c4, 0x996d74be, 0xf0147fdb, 0x4b9f6274, 0x22e66911,\n    0x1ad208c1, 0x73ab03a4, 0xc8201e0b, 0xa159156e, 0x64472314,\n    0x0d3e2871, 0xb6b535de, 0xdfcc3ebb, 0xd25c4ee9, 0xbb25458c,\n    0x00ae5823, 0x69d75346, 0xacc9653c, 0xc5b06e59, 0x7e3b73f6,\n    0x17427893, 0x2f761943, 0x460f1226, 0xfd840f89, 0x94fd04ec,\n    0x51e33296, 0x389a39f3, 0x8311245c, 0xea682f39, 0xf379e7fc,\n    0x9a00ec99, 0x218bf136, 0x48f2fa53, 0x8deccc29, 0xe495c74c,\n    0x5f1edae3, 0x3667d186, 0x0e53b056, 0x672abb33, 0xdca1a69c,\n    0xb5d8adf9, 0x70c69b83, 0x19bf90e6, 0xa2348d49, 0xcb4d862c,\n    0x90171cc3, 0xf96e17a6, 0x42e50a09, 0x2b9c016c, 0xee823716,\n    0x87fb3c73, 0x3c7021dc, 0x55092ab9, 0x6d3d4b69, 0x0444400c,\n    0xbfcf5da3, 0xd6b656c6, 0x13a860bc, 0x7ad16bd9, 0xc15a7676,\n    0xa8237d13, 0xb132b5d6, 0xd84bbeb3, 0x63c0a31c, 0x0ab9a879,\n    0xcfa79e03, 0xa6de9566, 0x1d5588c9, 0x742c83ac, 0x4c18e27c,\n    0x2561e919, 0x9eeaf4b6, 0xf793ffd3, 0x328dc9a9, 0x5bf4c2cc,\n    0xe07fdf63, 0x8906d406, 0x56caeabd, 0x3fb3e1d8, 0x8438fc77,\n    0xed41f712, 0x285fc168, 0x4126ca0d, 0xfaadd7a2, 0x93d4dcc7,\n    0xabe0bd17, 0xc299b672, 0x7912abdd, 0x106ba0b8, 0xd57596c2,\n    0xbc0c9da7, 0x07878008, 0x6efe8b6d, 0x77ef43a8, 0x1e9648cd,\n    0xa51d5562, 0xcc645e07, 0x097a687d, 0x60036318, 0xdb887eb7,\n    0xb2f175d2, 0x8ac51402, 0xe3bc1f67, 0x583702c8, 0x314e09ad,\n    0xf4503fd7, 0x9d2934b2, 0x26a2291d, 0x4fdb2278, 0x1481b897,\n    0x7df8b3f2, 0xc673ae5d, 0xaf0aa538, 0x6a149342, 0x036d9827,\n    0xb8e68588, 0xd19f8eed, 0xe9abef3d, 0x80d2e458, 0x3b59f9f7,\n    0x5220f292, 0x973ec4e8, 0xfe47cf8d, 0x45ccd222, 0x2cb5d947,\n    0x35a41182, 0x5cdd1ae7, 0xe7560748, 0x8e2f0c2d, 0x4b313a57,\n    0x22483132, 0x99c32c9d, 0xf0ba27f8, 0xc88e4628, 0xa1f74d4d,\n    0x1a7c50e2, 0x73055b87, 0xb61b6dfd, 0xdf626698, 0x64e97b37,\n    0x0d907052},\n   {0x00000000, 0x7fc99b93, 0xff933726, 0x805aacb5, 0x2457680d,\n    0x5b9ef39e, 0xdbc45f2b, 0xa40dc4b8, 0x48aed01a, 0x37674b89,\n    0xb73de73c, 0xc8f47caf, 0x6cf9b817, 0x13302384, 0x936a8f31,\n    0xeca314a2, 0x915da034, 0xee943ba7, 0x6ece9712, 0x11070c81,\n    0xb50ac839, 0xcac353aa, 0x4a99ff1f, 0x3550648c, 0xd9f3702e,\n    0xa63aebbd, 0x26604708, 0x59a9dc9b, 0xfda41823, 0x826d83b0,\n    0x02372f05, 0x7dfeb496, 0xf9ca4629, 0x8603ddba, 0x0659710f,\n    0x7990ea9c, 0xdd9d2e24, 0xa254b5b7, 0x220e1902, 0x5dc78291,\n    0xb1649633, 0xcead0da0, 0x4ef7a115, 0x313e3a86, 0x9533fe3e,\n    0xeafa65ad, 0x6aa0c918, 0x1569528b, 0x6897e61d, 0x175e7d8e,\n    0x9704d13b, 0xe8cd4aa8, 0x4cc08e10, 0x33091583, 0xb353b936,\n    0xcc9a22a5, 0x20393607, 0x5ff0ad94, 0xdfaa0121, 0xa0639ab2,\n    0x046e5e0a, 0x7ba7c599, 0xfbfd692c, 0x8434f2bf, 0x28e58a13,\n    0x572c1180, 0xd776bd35, 0xa8bf26a6, 0x0cb2e21e, 0x737b798d,\n    0xf321d538, 0x8ce84eab, 0x604b5a09, 0x1f82c19a, 0x9fd86d2f,\n    0xe011f6bc, 0x441c3204, 0x3bd5a997, 0xbb8f0522, 0xc4469eb1,\n    0xb9b82a27, 0xc671b1b4, 0x462b1d01, 0x39e28692, 0x9def422a,\n    0xe226d9b9, 0x627c750c, 0x1db5ee9f, 0xf116fa3d, 0x8edf61ae,\n    0x0e85cd1b, 0x714c5688, 0xd5419230, 0xaa8809a3, 0x2ad2a516,\n    0x551b3e85, 0xd12fcc3a, 0xaee657a9, 0x2ebcfb1c, 0x5175608f,\n    0xf578a437, 0x8ab13fa4, 0x0aeb9311, 0x75220882, 0x99811c20,\n    0xe64887b3, 0x66122b06, 0x19dbb095, 0xbdd6742d, 0xc21fefbe,\n    0x4245430b, 0x3d8cd898, 0x40726c0e, 0x3fbbf79d, 0xbfe15b28,\n    0xc028c0bb, 0x64250403, 0x1bec9f90, 0x9bb63325, 0xe47fa8b6,\n    0x08dcbc14, 0x77152787, 0xf74f8b32, 0x888610a1, 0x2c8bd419,\n    0x53424f8a, 0xd318e33f, 0xacd178ac, 0x51cb1426, 0x2e028fb5,\n    0xae582300, 0xd191b893, 0x759c7c2b, 0x0a55e7b8, 0x8a0f4b0d,\n    0xf5c6d09e, 0x1965c43c, 0x66ac5faf, 0xe6f6f31a, 0x993f6889,\n    0x3d32ac31, 0x42fb37a2, 0xc2a19b17, 0xbd680084, 0xc096b412,\n    0xbf5f2f81, 0x3f058334, 0x40cc18a7, 0xe4c1dc1f, 0x9b08478c,\n    0x1b52eb39, 0x649b70aa, 0x88386408, 0xf7f1ff9b, 0x77ab532e,\n    0x0862c8bd, 0xac6f0c05, 0xd3a69796, 0x53fc3b23, 0x2c35a0b0,\n    0xa801520f, 0xd7c8c99c, 0x57926529, 0x285bfeba, 0x8c563a02,\n    0xf39fa191, 0x73c50d24, 0x0c0c96b7, 0xe0af8215, 0x9f661986,\n    0x1f3cb533, 0x60f52ea0, 0xc4f8ea18, 0xbb31718b, 0x3b6bdd3e,\n    0x44a246ad, 0x395cf23b, 0x469569a8, 0xc6cfc51d, 0xb9065e8e,\n    0x1d0b9a36, 0x62c201a5, 0xe298ad10, 0x9d513683, 0x71f22221,\n    0x0e3bb9b2, 0x8e611507, 0xf1a88e94, 0x55a54a2c, 0x2a6cd1bf,\n    0xaa367d0a, 0xd5ffe699, 0x792e9e35, 0x06e705a6, 0x86bda913,\n    0xf9743280, 0x5d79f638, 0x22b06dab, 0xa2eac11e, 0xdd235a8d,\n    0x31804e2f, 0x4e49d5bc, 0xce137909, 0xb1dae29a, 0x15d72622,\n    0x6a1ebdb1, 0xea441104, 0x958d8a97, 0xe8733e01, 0x97baa592,\n    0x17e00927, 0x682992b4, 0xcc24560c, 0xb3edcd9f, 0x33b7612a,\n    0x4c7efab9, 0xa0ddee1b, 0xdf147588, 0x5f4ed93d, 0x208742ae,\n    0x848a8616, 0xfb431d85, 0x7b19b130, 0x04d02aa3, 0x80e4d81c,\n    0xff2d438f, 0x7f77ef3a, 0x00be74a9, 0xa4b3b011, 0xdb7a2b82,\n    0x5b208737, 0x24e91ca4, 0xc84a0806, 0xb7839395, 0x37d93f20,\n    0x4810a4b3, 0xec1d600b, 0x93d4fb98, 0x138e572d, 0x6c47ccbe,\n    0x11b97828, 0x6e70e3bb, 0xee2a4f0e, 0x91e3d49d, 0x35ee1025,\n    0x4a278bb6, 0xca7d2703, 0xb5b4bc90, 0x5917a832, 0x26de33a1,\n    0xa6849f14, 0xd94d0487, 0x7d40c03f, 0x02895bac, 0x82d3f719,\n    0xfd1a6c8a},\n   {0x00000000, 0xa396284c, 0x9c5d56d9, 0x3fcb7e95, 0xe3cbabf3,\n    0x405d83bf, 0x7f96fd2a, 0xdc00d566, 0x1ce651a7, 0xbf7079eb,\n    0x80bb077e, 0x232d2f32, 0xff2dfa54, 0x5cbbd218, 0x6370ac8d,\n    0xc0e684c1, 0x39cca34e, 0x9a5a8b02, 0xa591f597, 0x0607dddb,\n    0xda0708bd, 0x799120f1, 0x465a5e64, 0xe5cc7628, 0x252af2e9,\n    0x86bcdaa5, 0xb977a430, 0x1ae18c7c, 0xc6e1591a, 0x65777156,\n    0x5abc0fc3, 0xf92a278f, 0x7399469c, 0xd00f6ed0, 0xefc41045,\n    0x4c523809, 0x9052ed6f, 0x33c4c523, 0x0c0fbbb6, 0xaf9993fa,\n    0x6f7f173b, 0xcce93f77, 0xf32241e2, 0x50b469ae, 0x8cb4bcc8,\n    0x2f229484, 0x10e9ea11, 0xb37fc25d, 0x4a55e5d2, 0xe9c3cd9e,\n    0xd608b30b, 0x759e9b47, 0xa99e4e21, 0x0a08666d, 0x35c318f8,\n    0x965530b4, 0x56b3b475, 0xf5259c39, 0xcaeee2ac, 0x6978cae0,\n    0xb5781f86, 0x16ee37ca, 0x2925495f, 0x8ab36113, 0xe7328d38,\n    0x44a4a574, 0x7b6fdbe1, 0xd8f9f3ad, 0x04f926cb, 0xa76f0e87,\n    0x98a47012, 0x3b32585e, 0xfbd4dc9f, 0x5842f4d3, 0x67898a46,\n    0xc41fa20a, 0x181f776c, 0xbb895f20, 0x844221b5, 0x27d409f9,\n    0xdefe2e76, 0x7d68063a, 0x42a378af, 0xe13550e3, 0x3d358585,\n    0x9ea3adc9, 0xa168d35c, 0x02fefb10, 0xc2187fd1, 0x618e579d,\n    0x5e452908, 0xfdd30144, 0x21d3d422, 0x8245fc6e, 0xbd8e82fb,\n    0x1e18aab7, 0x94abcba4, 0x373de3e8, 0x08f69d7d, 0xab60b531,\n    0x77606057, 0xd4f6481b, 0xeb3d368e, 0x48ab1ec2, 0x884d9a03,\n    0x2bdbb24f, 0x1410ccda, 0xb786e496, 0x6b8631f0, 0xc81019bc,\n    0xf7db6729, 0x544d4f65, 0xad6768ea, 0x0ef140a6, 0x313a3e33,\n    0x92ac167f, 0x4eacc319, 0xed3aeb55, 0xd2f195c0, 0x7167bd8c,\n    0xb181394d, 0x12171101, 0x2ddc6f94, 0x8e4a47d8, 0x524a92be,\n    0xf1dcbaf2, 0xce17c467, 0x6d81ec2b, 0x15141c31, 0xb682347d,\n    0x89494ae8, 0x2adf62a4, 0xf6dfb7c2, 0x55499f8e, 0x6a82e11b,\n    0xc914c957, 0x09f24d96, 0xaa6465da, 0x95af1b4f, 0x36393303,\n    0xea39e665, 0x49afce29, 0x7664b0bc, 0xd5f298f0, 0x2cd8bf7f,\n    0x8f4e9733, 0xb085e9a6, 0x1313c1ea, 0xcf13148c, 0x6c853cc0,\n    0x534e4255, 0xf0d86a19, 0x303eeed8, 0x93a8c694, 0xac63b801,\n    0x0ff5904d, 0xd3f5452b, 0x70636d67, 0x4fa813f2, 0xec3e3bbe,\n    0x668d5aad, 0xc51b72e1, 0xfad00c74, 0x59462438, 0x8546f15e,\n    0x26d0d912, 0x191ba787, 0xba8d8fcb, 0x7a6b0b0a, 0xd9fd2346,\n    0xe6365dd3, 0x45a0759f, 0x99a0a0f9, 0x3a3688b5, 0x05fdf620,\n    0xa66bde6c, 0x5f41f9e3, 0xfcd7d1af, 0xc31caf3a, 0x608a8776,\n    0xbc8a5210, 0x1f1c7a5c, 0x20d704c9, 0x83412c85, 0x43a7a844,\n    0xe0318008, 0xdffafe9d, 0x7c6cd6d1, 0xa06c03b7, 0x03fa2bfb,\n    0x3c31556e, 0x9fa77d22, 0xf2269109, 0x51b0b945, 0x6e7bc7d0,\n    0xcdedef9c, 0x11ed3afa, 0xb27b12b6, 0x8db06c23, 0x2e26446f,\n    0xeec0c0ae, 0x4d56e8e2, 0x729d9677, 0xd10bbe3b, 0x0d0b6b5d,\n    0xae9d4311, 0x91563d84, 0x32c015c8, 0xcbea3247, 0x687c1a0b,\n    0x57b7649e, 0xf4214cd2, 0x282199b4, 0x8bb7b1f8, 0xb47ccf6d,\n    0x17eae721, 0xd70c63e0, 0x749a4bac, 0x4b513539, 0xe8c71d75,\n    0x34c7c813, 0x9751e05f, 0xa89a9eca, 0x0b0cb686, 0x81bfd795,\n    0x2229ffd9, 0x1de2814c, 0xbe74a900, 0x62747c66, 0xc1e2542a,\n    0xfe292abf, 0x5dbf02f3, 0x9d598632, 0x3ecfae7e, 0x0104d0eb,\n    0xa292f8a7, 0x7e922dc1, 0xdd04058d, 0xe2cf7b18, 0x41595354,\n    0xb87374db, 0x1be55c97, 0x242e2202, 0x87b80a4e, 0x5bb8df28,\n    0xf82ef764, 0xc7e589f1, 0x6473a1bd, 0xa495257c, 0x07030d30,\n    0x38c873a5, 0x9b5e5be9, 0x475e8e8f, 0xe4c8a6c3, 0xdb03d856,\n    0x7895f01a},\n   {0x00000000, 0x2a283862, 0x545070c4, 0x7e7848a6, 0xa8a0e188,\n    0x8288d9ea, 0xfcf0914c, 0xd6d8a92e, 0x8a30c551, 0xa018fd33,\n    0xde60b595, 0xf4488df7, 0x229024d9, 0x08b81cbb, 0x76c0541d,\n    0x5ce86c7f, 0xcf108ce3, 0xe538b481, 0x9b40fc27, 0xb168c445,\n    0x67b06d6b, 0x4d985509, 0x33e01daf, 0x19c825cd, 0x452049b2,\n    0x6f0871d0, 0x11703976, 0x3b580114, 0xed80a83a, 0xc7a89058,\n    0xb9d0d8fe, 0x93f8e09c, 0x45501f87, 0x6f7827e5, 0x11006f43,\n    0x3b285721, 0xedf0fe0f, 0xc7d8c66d, 0xb9a08ecb, 0x9388b6a9,\n    0xcf60dad6, 0xe548e2b4, 0x9b30aa12, 0xb1189270, 0x67c03b5e,\n    0x4de8033c, 0x33904b9a, 0x19b873f8, 0x8a409364, 0xa068ab06,\n    0xde10e3a0, 0xf438dbc2, 0x22e072ec, 0x08c84a8e, 0x76b00228,\n    0x5c983a4a, 0x00705635, 0x2a586e57, 0x542026f1, 0x7e081e93,\n    0xa8d0b7bd, 0x82f88fdf, 0xfc80c779, 0xd6a8ff1b, 0x8aa03f0e,\n    0xa088076c, 0xdef04fca, 0xf4d877a8, 0x2200de86, 0x0828e6e4,\n    0x7650ae42, 0x5c789620, 0x0090fa5f, 0x2ab8c23d, 0x54c08a9b,\n    0x7ee8b2f9, 0xa8301bd7, 0x821823b5, 0xfc606b13, 0xd6485371,\n    0x45b0b3ed, 0x6f988b8f, 0x11e0c329, 0x3bc8fb4b, 0xed105265,\n    0xc7386a07, 0xb94022a1, 0x93681ac3, 0xcf8076bc, 0xe5a84ede,\n    0x9bd00678, 0xb1f83e1a, 0x67209734, 0x4d08af56, 0x3370e7f0,\n    0x1958df92, 0xcff02089, 0xe5d818eb, 0x9ba0504d, 0xb188682f,\n    0x6750c101, 0x4d78f963, 0x3300b1c5, 0x192889a7, 0x45c0e5d8,\n    0x6fe8ddba, 0x1190951c, 0x3bb8ad7e, 0xed600450, 0xc7483c32,\n    0xb9307494, 0x93184cf6, 0x00e0ac6a, 0x2ac89408, 0x54b0dcae,\n    0x7e98e4cc, 0xa8404de2, 0x82687580, 0xfc103d26, 0xd6380544,\n    0x8ad0693b, 0xa0f85159, 0xde8019ff, 0xf4a8219d, 0x227088b3,\n    0x0858b0d1, 0x7620f877, 0x5c08c015, 0xce31785d, 0xe419403f,\n    0x9a610899, 0xb04930fb, 0x669199d5, 0x4cb9a1b7, 0x32c1e911,\n    0x18e9d173, 0x4401bd0c, 0x6e29856e, 0x1051cdc8, 0x3a79f5aa,\n    0xeca15c84, 0xc68964e6, 0xb8f12c40, 0x92d91422, 0x0121f4be,\n    0x2b09ccdc, 0x5571847a, 0x7f59bc18, 0xa9811536, 0x83a92d54,\n    0xfdd165f2, 0xd7f95d90, 0x8b1131ef, 0xa139098d, 0xdf41412b,\n    0xf5697949, 0x23b1d067, 0x0999e805, 0x77e1a0a3, 0x5dc998c1,\n    0x8b6167da, 0xa1495fb8, 0xdf31171e, 0xf5192f7c, 0x23c18652,\n    0x09e9be30, 0x7791f696, 0x5db9cef4, 0x0151a28b, 0x2b799ae9,\n    0x5501d24f, 0x7f29ea2d, 0xa9f14303, 0x83d97b61, 0xfda133c7,\n    0xd7890ba5, 0x4471eb39, 0x6e59d35b, 0x10219bfd, 0x3a09a39f,\n    0xecd10ab1, 0xc6f932d3, 0xb8817a75, 0x92a94217, 0xce412e68,\n    0xe469160a, 0x9a115eac, 0xb03966ce, 0x66e1cfe0, 0x4cc9f782,\n    0x32b1bf24, 0x18998746, 0x44914753, 0x6eb97f31, 0x10c13797,\n    0x3ae90ff5, 0xec31a6db, 0xc6199eb9, 0xb861d61f, 0x9249ee7d,\n    0xcea18202, 0xe489ba60, 0x9af1f2c6, 0xb0d9caa4, 0x6601638a,\n    0x4c295be8, 0x3251134e, 0x18792b2c, 0x8b81cbb0, 0xa1a9f3d2,\n    0xdfd1bb74, 0xf5f98316, 0x23212a38, 0x0909125a, 0x77715afc,\n    0x5d59629e, 0x01b10ee1, 0x2b993683, 0x55e17e25, 0x7fc94647,\n    0xa911ef69, 0x8339d70b, 0xfd419fad, 0xd769a7cf, 0x01c158d4,\n    0x2be960b6, 0x55912810, 0x7fb91072, 0xa961b95c, 0x8349813e,\n    0xfd31c998, 0xd719f1fa, 0x8bf19d85, 0xa1d9a5e7, 0xdfa1ed41,\n    0xf589d523, 0x23517c0d, 0x0979446f, 0x77010cc9, 0x5d2934ab,\n    0xced1d437, 0xe4f9ec55, 0x9a81a4f3, 0xb0a99c91, 0x667135bf,\n    0x4c590ddd, 0x3221457b, 0x18097d19, 0x44e11166, 0x6ec92904,\n    0x10b161a2, 0x3a9959c0, 0xec41f0ee, 0xc669c88c, 0xb811802a,\n    0x9239b848},\n   {0x00000000, 0x4713f6fb, 0x8e27edf6, 0xc9341b0d, 0xc73eddad,\n    0x802d2b56, 0x4919305b, 0x0e0ac6a0, 0x550cbd1b, 0x121f4be0,\n    0xdb2b50ed, 0x9c38a616, 0x923260b6, 0xd521964d, 0x1c158d40,\n    0x5b067bbb, 0xaa197a36, 0xed0a8ccd, 0x243e97c0, 0x632d613b,\n    0x6d27a79b, 0x2a345160, 0xe3004a6d, 0xa413bc96, 0xff15c72d,\n    0xb80631d6, 0x71322adb, 0x3621dc20, 0x382b1a80, 0x7f38ec7b,\n    0xb60cf776, 0xf11f018d, 0x8f43f22d, 0xc85004d6, 0x01641fdb,\n    0x4677e920, 0x487d2f80, 0x0f6ed97b, 0xc65ac276, 0x8149348d,\n    0xda4f4f36, 0x9d5cb9cd, 0x5468a2c0, 0x137b543b, 0x1d71929b,\n    0x5a626460, 0x93567f6d, "
        },
        {
          "name": "deflate.c",
          "type": "blob",
          "size": 56.5361328125,
          "content": "/* deflate.c -- compress data using the deflation algorithm\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process depends on being able to identify portions\n *      of the input text which are identical to earlier input (within a\n *      sliding window trailing behind the input currently being processed).\n *\n *      The most straightforward technique turns out to be the fastest for\n *      most input files: try all possible matches and select the longest.\n *      The key feature of this algorithm is that insertions into the string\n *      dictionary are very simple and thus fast, and deletions are avoided\n *      completely. Insertions are performed at each input character, whereas\n *      string matches are performed only when the previous match ends. So it\n *      is preferable to spend more time in matches to allow very fast string\n *      insertions and avoid deletions. The matching algorithm for small\n *      strings is inspired from that of Rabin & Karp. A brute force approach\n *      is used to find longer strings when a small match has been found.\n *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze\n *      (by Leonid Broukhis).\n *         A previous version of this file used a more sophisticated algorithm\n *      (by Fiala and Greene) which is guaranteed to run in linear amortized\n *      time, but has a larger average cost, uses more memory and is patented.\n *      However the F&G algorithm may be faster for some highly redundant\n *      files if the parameter max_chain_length (described below) is too large.\n *\n *  ACKNOWLEDGEMENTS\n *\n *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and\n *      I found it in 'freeze' written by Leonid Broukhis.\n *      Thanks to many people for bug reports and testing.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n *      Available in https://tools.ietf.org/html/rfc1951\n *\n *      A description of the Rabin and Karp algorithm is given in the book\n *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n *\n *      Fiala,E.R., and Greene,D.H.\n *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595\n *\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n\n/* Avoid conflicts with zlib.h macros */\n#ifdef ZLIB_COMPAT\n# undef deflateInit\n# undef deflateInit2\n#endif\n\nconst char PREFIX(deflate_copyright)[] = \" deflate 1.3.1 Copyright 1995-2024 Jean-loup Gailly and Mark Adler \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\n\n/* ===========================================================================\n *  Architecture-specific hooks.\n */\n#ifdef S390_DFLTCC_DEFLATE\n#  include \"arch/s390/dfltcc_deflate.h\"\n/* DFLTCC instructions require window to be page-aligned */\n#  define PAD_WINDOW            PAD_4096\n#  define WINDOW_PAD_SIZE       4096\n#  define HINT_ALIGNED_WINDOW   HINT_ALIGNED_4096\n#else\n#  define PAD_WINDOW            PAD_64\n#  define WINDOW_PAD_SIZE       64\n#  define HINT_ALIGNED_WINDOW   HINT_ALIGNED_64\n/* Adjust the window size for the arch-specific deflate code. */\n#  define DEFLATE_ADJUST_WINDOW_SIZE(n) (n)\n/* Invoked at the beginning of deflateSetDictionary(). Useful for checking arch-specific window data. */\n#  define DEFLATE_SET_DICTIONARY_HOOK(strm, dict, dict_len) do {} while (0)\n/* Invoked at the beginning of deflateGetDictionary(). Useful for adjusting arch-specific window data. */\n#  define DEFLATE_GET_DICTIONARY_HOOK(strm, dict, dict_len) do {} while (0)\n/* Invoked at the end of deflateResetKeep(). Useful for initializing arch-specific extension blocks. */\n#  define DEFLATE_RESET_KEEP_HOOK(strm) do {} while (0)\n/* Invoked at the beginning of deflateParams(). Useful for updating arch-specific compression parameters. */\n#  define DEFLATE_PARAMS_HOOK(strm, level, strategy, hook_flush) do {} while (0)\n/* Returns whether the last deflate(flush) operation did everything it's supposed to do. */\n#  define DEFLATE_DONE(strm, flush) 1\n/* Adjusts the upper bound on compressed data length based on compression parameters and uncompressed data length.\n * Useful when arch-specific deflation code behaves differently than regular zlib-ng algorithms. */\n#  define DEFLATE_BOUND_ADJUST_COMPLEN(strm, complen, sourceLen) do {} while (0)\n/* Returns whether an optimistic upper bound on compressed data length should *not* be used.\n * Useful when arch-specific deflation code behaves differently than regular zlib-ng algorithms. */\n#  define DEFLATE_NEED_CONSERVATIVE_BOUND(strm) 0\n/* Invoked for each deflate() call. Useful for plugging arch-specific deflation code. */\n#  define DEFLATE_HOOK(strm, flush, bstate) 0\n/* Returns whether zlib-ng should compute a checksum. Set to 0 if arch-specific deflation code already does that. */\n#  define DEFLATE_NEED_CHECKSUM(strm) 1\n/* Returns whether reproducibility parameter can be set to a given value. */\n#  define DEFLATE_CAN_SET_REPRODUCIBLE(strm, reproducible) 1\n#endif\n\n/* ===========================================================================\n *  Function prototypes.\n */\nstatic int deflateStateCheck      (PREFIX3(stream) *strm);\nZ_INTERNAL block_state deflate_stored(deflate_state *s, int flush);\nZ_INTERNAL block_state deflate_fast  (deflate_state *s, int flush);\nZ_INTERNAL block_state deflate_quick (deflate_state *s, int flush);\n#ifndef NO_MEDIUM_STRATEGY\nZ_INTERNAL block_state deflate_medium(deflate_state *s, int flush);\n#endif\nZ_INTERNAL block_state deflate_slow  (deflate_state *s, int flush);\nZ_INTERNAL block_state deflate_rle   (deflate_state *s, int flush);\nZ_INTERNAL block_state deflate_huff  (deflate_state *s, int flush);\nstatic void lm_set_level         (deflate_state *s, int level);\nstatic void lm_init              (deflate_state *s);\nZ_INTERNAL unsigned read_buf  (PREFIX3(stream) *strm, unsigned char *buf, unsigned size);\n\n/* ===========================================================================\n * Local data\n */\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\ntypedef struct config_s {\n    uint16_t good_length; /* reduce lazy search above this match length */\n    uint16_t max_lazy;    /* do not perform lazy search above this match length */\n    uint16_t nice_length; /* quit search above this match length */\n    uint16_t max_chain;\n    compress_func func;\n} config;\n\nstatic const config configuration_table[10] = {\n/*      good lazy nice chain */\n/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */\n\n#ifdef NO_QUICK_STRATEGY\n/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */\n/* 2 */ {4,    5, 16,    8, deflate_fast},\n#else\n/* 1 */ {0,    0,  0,    0, deflate_quick},\n/* 2 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */\n#endif\n\n#ifdef NO_MEDIUM_STRATEGY\n/* 3 */ {4,    6, 32,   32, deflate_fast},\n/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */\n/* 5 */ {8,   16, 32,   32, deflate_slow},\n/* 6 */ {8,   16, 128, 128, deflate_slow},\n#else\n/* 3 */ {4,    6, 16,    6, deflate_medium},\n/* 4 */ {4,   12, 32,   24, deflate_medium},  /* lazy matches */\n/* 5 */ {8,   16, 32,   32, deflate_medium},\n/* 6 */ {8,   16, 128, 128, deflate_medium},\n#endif\n\n/* 7 */ {8,   32, 128,  256, deflate_slow},\n/* 8 */ {32, 128, 258, 1024, deflate_slow},\n/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */\n\n/* Note: the deflate() code requires max_lazy >= STD_MIN_MATCH and max_chain >= 4\n * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n * meaning.\n */\n\n/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */\n#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))\n\n\n/* ===========================================================================\n * Initialize the hash table. prev[] will be initialized on the fly.\n */\n#define CLEAR_HASH(s) do { \\\n    memset((unsigned char *)s->head, 0, HASH_SIZE * sizeof(*s->head)); \\\n  } while (0)\n\n\n#ifdef DEF_ALLOC_DEBUG\n#  include <stdio.h>\n#  define LOGSZ(name,size)           fprintf(stderr, \"%s is %d bytes\\n\", name, size)\n#  define LOGSZP(name,size,loc,pad)  fprintf(stderr, \"%s is %d bytes, offset %d, padded %d\\n\", name, size, loc, pad)\n#  define LOGSZPL(name,size,loc,pad) fprintf(stderr, \"%s is %d bytes, offset %ld, padded %d\\n\", name, size, loc, pad)\n#else\n#  define LOGSZ(name,size)\n#  define LOGSZP(name,size,loc,pad)\n#  define LOGSZPL(name,size,loc,pad)\n#endif\n\n/* ===========================================================================\n * Allocate a big buffer and divide it up into the various buffers deflate needs.\n * Handles alignment of allocated buffer and alignment of individual buffers.\n */\nZ_INTERNAL deflate_allocs* alloc_deflate(PREFIX3(stream) *strm, int windowBits, int lit_bufsize) {\n    int curr_size = 0;\n\n    /* Define sizes */\n    int window_size = DEFLATE_ADJUST_WINDOW_SIZE((1 << windowBits) * 2);\n    int prev_size = (1 << windowBits) * (int)sizeof(Pos);\n    int head_size = HASH_SIZE * sizeof(Pos);\n    int pending_size = lit_bufsize * LIT_BUFS;\n    int state_size = sizeof(deflate_state);\n    int alloc_size = sizeof(deflate_allocs);\n\n    /* Calculate relative buffer positions and paddings */\n    LOGSZP(\"window\", window_size, PAD_WINDOW(curr_size), PADSZ(curr_size,WINDOW_PAD_SIZE));\n    int window_pos = PAD_WINDOW(curr_size);\n    curr_size = window_pos + window_size;\n\n    LOGSZP(\"prev\", prev_size, PAD_64(curr_size), PADSZ(curr_size,64));\n    int prev_pos = PAD_64(curr_size);\n    curr_size = prev_pos + prev_size;\n\n    LOGSZP(\"head\", head_size, PAD_64(curr_size), PADSZ(curr_size,64));\n    int head_pos = PAD_64(curr_size);\n    curr_size = head_pos + head_size;\n\n    LOGSZP(\"pending\", pending_size, PAD_64(curr_size), PADSZ(curr_size,64));\n    int pending_pos = PAD_64(curr_size);\n    curr_size = pending_pos + pending_size;\n\n    LOGSZP(\"state\", state_size, PAD_64(curr_size), PADSZ(curr_size,64));\n    int state_pos = PAD_64(curr_size);\n    curr_size = state_pos + state_size;\n\n    LOGSZP(\"alloc\", alloc_size, PAD_16(curr_size), PADSZ(curr_size,16));\n    int alloc_pos = PAD_16(curr_size);\n    curr_size = alloc_pos + alloc_size;\n\n    /* Add 64-1 or 4096-1 to allow window alignment, and round size of buffer up to multiple of 64 */\n    int total_size = PAD_64(curr_size + (WINDOW_PAD_SIZE - 1));\n\n    /* Allocate buffer, align to 64-byte cacheline, and zerofill the resulting buffer */\n    char *original_buf = (char *)strm->zalloc(strm->opaque, 1, total_size);\n    if (original_buf == NULL)\n        return NULL;\n\n    char *buff = (char *)HINT_ALIGNED_WINDOW((char *)PAD_WINDOW(original_buf));\n    LOGSZPL(\"Buffer alloc\", total_size, PADSZ((uintptr_t)original_buf,WINDOW_PAD_SIZE), PADSZ(curr_size,WINDOW_PAD_SIZE));\n\n    /* Initialize alloc_bufs */\n    deflate_allocs *alloc_bufs  = (struct deflate_allocs_s *)(buff + alloc_pos);\n    alloc_bufs->buf_start = original_buf;\n    alloc_bufs->zfree = strm->zfree;\n\n    /* Assign buffers */\n    alloc_bufs->window = (unsigned char *)HINT_ALIGNED_WINDOW(buff + window_pos);\n    alloc_bufs->prev = (Pos *)HINT_ALIGNED_64(buff + prev_pos);\n    alloc_bufs->head = (Pos *)HINT_ALIGNED_64(buff + head_pos);\n    alloc_bufs->pending_buf = (unsigned char *)HINT_ALIGNED_64(buff + pending_pos);\n    alloc_bufs->state = (deflate_state *)HINT_ALIGNED_16(buff + state_pos);\n\n    memset((char *)alloc_bufs->prev, 0, prev_size);\n\n    return alloc_bufs;\n}\n\n/* ===========================================================================\n * Free all allocated deflate buffers\n */\nstatic inline void free_deflate(PREFIX3(stream) *strm) {\n    deflate_state *state = (deflate_state *)strm->state;\n\n    if (state->alloc_bufs != NULL) {\n        deflate_allocs *alloc_bufs = state->alloc_bufs;\n        alloc_bufs->zfree(strm->opaque, alloc_bufs->buf_start);\n        strm->state = NULL;\n    }\n}\n\n/* ===========================================================================\n * Initialize deflate state and buffers.\n * This function is hidden in ZLIB_COMPAT builds.\n */\nint32_t ZNG_CONDEXPORT PREFIX(deflateInit2)(PREFIX3(stream) *strm, int32_t level, int32_t method, int32_t windowBits,\n                                            int32_t memLevel, int32_t strategy) {\n    /* Todo: ignore strm->next_in if we use it as window */\n    deflate_state *s;\n    int wrap = 1;\n\n    /* Initialize functable */\n    FUNCTABLE_INIT;\n\n    if (strm == NULL)\n        return Z_STREAM_ERROR;\n\n    strm->msg = NULL;\n    if (strm->zalloc == NULL) {\n        strm->zalloc = PREFIX(zcalloc);\n        strm->opaque = NULL;\n    }\n    if (strm->zfree == NULL)\n        strm->zfree = PREFIX(zcfree);\n\n    if (level == Z_DEFAULT_COMPRESSION)\n        level = 6;\n\n    if (windowBits < 0) { /* suppress zlib wrapper */\n        wrap = 0;\n        if (windowBits < -MAX_WBITS)\n            return Z_STREAM_ERROR;\n        windowBits = -windowBits;\n#ifdef GZIP\n    } else if (windowBits > MAX_WBITS) {\n        wrap = 2;       /* write gzip wrapper instead */\n        windowBits -= 16;\n#endif\n    }\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < MIN_WBITS ||\n        windowBits > MAX_WBITS || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED ||\n        (windowBits == 8 && wrap != 1)) {\n        return Z_STREAM_ERROR;\n    }\n    if (windowBits == 8)\n        windowBits = 9;  /* until 256-byte window bug fixed */\n\n    /* Allocate buffers */\n    int lit_bufsize = 1 << (memLevel + 6);\n    deflate_allocs *alloc_bufs = alloc_deflate(strm, windowBits, lit_bufsize);\n    if (alloc_bufs == NULL)\n        return Z_MEM_ERROR;\n\n    s = alloc_bufs->state;\n    s->alloc_bufs = alloc_bufs;\n    s->window = alloc_bufs->window;\n    s->prev = alloc_bufs->prev;\n    s->head = alloc_bufs->head;\n    s->pending_buf = alloc_bufs->pending_buf;\n\n    strm->state = (struct internal_state *)s;\n    s->strm = strm;\n    s->status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n    s->wrap = wrap;\n    s->gzhead = NULL;\n    s->w_bits = (unsigned int)windowBits;\n    s->w_size = 1 << s->w_bits;\n    s->w_mask = s->w_size - 1;\n\n    s->high_water = 0;      /* nothing written to s->window yet */\n\n    s->lit_bufsize = lit_bufsize; /* 16K elements by default */\n\n    /* We overlay pending_buf and sym_buf. This works since the average size\n     * for length/distance pairs over any compressed block is assured to be 31\n     * bits or less.\n     *\n     * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n     * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n     * possible fixed-codes length/distance pair is then 31 bits total.\n     *\n     * sym_buf starts one-fourth of the way into pending_buf. So there are\n     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n     * in sym_buf is three bytes -- two for the distance and one for the\n     * literal/length. As each symbol is consumed, the pointer to the next\n     * sym_buf value to read moves forward three bytes. From that symbol, up to\n     * 31 bits are written to pending_buf. The closest the written pending_buf\n     * bits gets to the next sym_buf symbol to read is just before the last\n     * code is written. At that time, 31*(n-2) bits have been written, just\n     * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n     * symbols are written.) The closest the writing gets to what is unread is\n     * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n     * can range from 128 to 32768.\n     *\n     * Therefore, at a minimum, there are 142 bits of space between what is\n     * written and what is read in the overlain buffers, so the symbols cannot\n     * be overwritten by the compressed data. That space is actually 139 bits,\n     * due to the three-bit fixed-code block header.\n     *\n     * That covers the case where either Z_FIXED is specified, forcing fixed\n     * codes, or when the use of fixed codes is chosen, because that choice\n     * results in a smaller compressed block than dynamic codes. That latter\n     * condition then assures that the above analysis also covers all dynamic\n     * blocks. A dynamic-code block will only be chosen to be emitted if it has\n     * fewer bits than a fixed-code block would for the same set of symbols.\n     * Therefore its average symbol length is assured to be less than 31. So\n     * the compressed data for a dynamic block also cannot overwrite the\n     * symbols from which it is being constructed.\n     */\n\n    s->pending_buf_size = s->lit_bufsize * 4;\n\n    if (s->window == NULL || s->prev == NULL || s->head == NULL || s->pending_buf == NULL) {\n        s->status = FINISH_STATE;\n        strm->msg = ERR_MSG(Z_MEM_ERROR);\n        PREFIX(deflateEnd)(strm);\n        return Z_MEM_ERROR;\n    }\n\n#ifdef LIT_MEM\n    s->d_buf = (uint16_t *)(s->pending_buf + (s->lit_bufsize << 1));\n    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n    s->sym_end = s->lit_bufsize - 1;\n#else\n    s->sym_buf = s->pending_buf + s->lit_bufsize;\n    s->sym_end = (s->lit_bufsize - 1) * 3;\n#endif\n    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n\n    s->level = level;\n    s->strategy = strategy;\n    s->block_open = 0;\n    s->reproducible = 0;\n\n    return PREFIX(deflateReset)(strm);\n}\n\n#ifndef ZLIB_COMPAT\nint32_t Z_EXPORT PREFIX(deflateInit)(PREFIX3(stream) *strm, int32_t level) {\n    return PREFIX(deflateInit2)(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n#endif\n\n/* Function used by zlib.h and zlib-ng version 2.0 macros */\nint32_t Z_EXPORT PREFIX(deflateInit_)(PREFIX3(stream) *strm, int32_t level, const char *version, int32_t stream_size) {\n    if (CHECK_VER_STSIZE(version, stream_size))\n        return Z_VERSION_ERROR;\n    return PREFIX(deflateInit2)(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n/* Function used by zlib.h and zlib-ng version 2.0 macros */\nint32_t Z_EXPORT PREFIX(deflateInit2_)(PREFIX3(stream) *strm, int32_t level, int32_t method, int32_t windowBits,\n                           int32_t memLevel, int32_t strategy, const char *version, int32_t stream_size) {\n    if (CHECK_VER_STSIZE(version, stream_size))\n        return Z_VERSION_ERROR;\n    return PREFIX(deflateInit2)(strm, level, method, windowBits, memLevel, strategy);\n}\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nstatic int deflateStateCheck(PREFIX3(stream) *strm) {\n    deflate_state *s;\n    if (strm == NULL || strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)\n        return 1;\n    s = strm->state;\n    if (s == NULL || s->alloc_bufs == NULL || s->strm != strm || (s->status < INIT_STATE || s->status > MAX_STATE))\n        return 1;\n    return 0;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateSetDictionary)(PREFIX3(stream) *strm, const uint8_t *dictionary, uint32_t dictLength) {\n    deflate_state *s;\n    unsigned int str, n;\n    int wrap;\n    uint32_t avail;\n    const unsigned char *next;\n\n    if (deflateStateCheck(strm) || dictionary == NULL)\n        return Z_STREAM_ERROR;\n    s = strm->state;\n    wrap = s->wrap;\n    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)\n        return Z_STREAM_ERROR;\n\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n    if (wrap == 1)\n        strm->adler = FUNCTABLE_CALL(adler32)(strm->adler, dictionary, dictLength);\n    DEFLATE_SET_DICTIONARY_HOOK(strm, dictionary, dictLength);  /* hook for IBM Z DFLTCC */\n    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */\n\n    /* if dictionary would fill window, just replace the history */\n    if (dictLength >= s->w_size) {\n        if (wrap == 0) {            /* already empty otherwise */\n            CLEAR_HASH(s);\n            s->strstart = 0;\n            s->block_start = 0;\n            s->insert = 0;\n        }\n        dictionary += dictLength - s->w_size;  /* use the tail */\n        dictLength = s->w_size;\n    }\n\n    /* insert dictionary into window and hash */\n    avail = strm->avail_in;\n    next = strm->next_in;\n    strm->avail_in = dictLength;\n    strm->next_in = (z_const unsigned char *)dictionary;\n    PREFIX(fill_window)(s);\n    while (s->lookahead >= STD_MIN_MATCH) {\n        str = s->strstart;\n        n = s->lookahead - (STD_MIN_MATCH - 1);\n        s->insert_string(s, str, n);\n        s->strstart = str + n;\n        s->lookahead = STD_MIN_MATCH - 1;\n        PREFIX(fill_window)(s);\n    }\n    s->strstart += s->lookahead;\n    s->block_start = (int)s->strstart;\n    s->insert = s->lookahead;\n    s->lookahead = 0;\n    s->prev_length = 0;\n    s->match_available = 0;\n    strm->next_in = (z_const unsigned char *)next;\n    strm->avail_in = avail;\n    s->wrap = wrap;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateGetDictionary)(PREFIX3(stream) *strm, uint8_t *dictionary, uint32_t *dictLength) {\n    deflate_state *s;\n    unsigned int len;\n\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    DEFLATE_GET_DICTIONARY_HOOK(strm, dictionary, dictLength);  /* hook for IBM Z DFLTCC */\n    s = strm->state;\n    len = s->strstart + s->lookahead;\n    if (len > s->w_size)\n        len = s->w_size;\n    if (dictionary != NULL && len)\n        memcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);\n    if (dictLength != NULL)\n        *dictLength = len;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateResetKeep)(PREFIX3(stream) *strm) {\n    deflate_state *s;\n\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n\n    strm->total_in = strm->total_out = 0;\n    strm->msg = NULL; /* use zfree if we ever allocate msg dynamically */\n    strm->data_type = Z_UNKNOWN;\n\n    s = (deflate_state *)strm->state;\n    s->pending = 0;\n    s->pending_out = s->pending_buf;\n\n    if (s->wrap < 0)\n        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */\n\n    s->status =\n#ifdef GZIP\n        s->wrap == 2 ? GZIP_STATE :\n#endif\n        INIT_STATE;\n\n#ifdef GZIP\n    if (s->wrap == 2) {\n        strm->adler = FUNCTABLE_CALL(crc32_fold_reset)(&s->crc_fold);\n    } else\n#endif\n        strm->adler = ADLER32_INITIAL_VALUE;\n    s->last_flush = -2;\n\n    zng_tr_init(s);\n\n    DEFLATE_RESET_KEEP_HOOK(strm);  /* hook for IBM Z DFLTCC */\n\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateReset)(PREFIX3(stream) *strm) {\n    int ret = PREFIX(deflateResetKeep)(strm);\n    if (ret == Z_OK)\n        lm_init(strm->state);\n    return ret;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateSetHeader)(PREFIX3(stream) *strm, PREFIX(gz_headerp) head) {\n    if (deflateStateCheck(strm) || strm->state->wrap != 2)\n        return Z_STREAM_ERROR;\n    strm->state->gzhead = head;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflatePending)(PREFIX3(stream) *strm, uint32_t *pending, int32_t *bits) {\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    if (pending != NULL)\n        *pending = strm->state->pending;\n    if (bits != NULL)\n        *bits = strm->state->bi_valid;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflatePrime)(PREFIX3(stream) *strm, int32_t bits, int32_t value) {\n    deflate_state *s;\n    uint64_t value64 = (uint64_t)value;\n    int32_t put;\n\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    s = strm->state;\n\n#ifdef LIT_MEM\n    if (bits < 0 || bits > BIT_BUF_SIZE ||\n        (unsigned char *)s->d_buf < s->pending_out + ((BIT_BUF_SIZE + 7) >> 3))\n        return Z_BUF_ERROR;\n#else\n    if (bits < 0 || bits > BIT_BUF_SIZE || bits > (int32_t)(sizeof(value) << 3) ||\n        s->sym_buf < s->pending_out + ((BIT_BUF_SIZE + 7) >> 3))\n        return Z_BUF_ERROR;\n#endif\n\n    do {\n        put = BIT_BUF_SIZE - s->bi_valid;\n        put = MIN(put, bits);\n\n        if (s->bi_valid == 0)\n            s->bi_buf = value64;\n        else\n            s->bi_buf |= (value64 & ((UINT64_C(1) << put) - 1)) << s->bi_valid;\n        s->bi_valid += put;\n        zng_tr_flush_bits(s);\n        value64 >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateParams)(PREFIX3(stream) *strm, int32_t level, int32_t strategy) {\n    deflate_state *s;\n    compress_func func;\n    int hook_flush = Z_NO_FLUSH;\n\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    s = strm->state;\n\n    if (level == Z_DEFAULT_COMPRESSION)\n        level = 6;\n    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)\n        return Z_STREAM_ERROR;\n    DEFLATE_PARAMS_HOOK(strm, level, strategy, &hook_flush);  /* hook for IBM Z DFLTCC */\n    func = configuration_table[s->level].func;\n\n    if (((strategy != s->strategy || func != configuration_table[level].func) && s->last_flush != -2)\n        || hook_flush != Z_NO_FLUSH) {\n        /* Flush the last buffer. Use Z_BLOCK mode, unless the hook requests a \"stronger\" one. */\n        int flush = RANK(hook_flush) > RANK(Z_BLOCK) ? hook_flush : Z_BLOCK;\n        int err = PREFIX(deflate)(strm, flush);\n        if (err == Z_STREAM_ERROR)\n            return err;\n        if (strm->avail_in || ((int)s->strstart - s->block_start) + s->lookahead || !DEFLATE_DONE(strm, flush))\n            return Z_BUF_ERROR;\n    }\n    if (s->level != level) {\n        if (s->level == 0 && s->matches != 0) {\n            if (s->matches == 1) {\n                FUNCTABLE_CALL(slide_hash)(s);\n            } else {\n                CLEAR_HASH(s);\n            }\n            s->matches = 0;\n        }\n\n        lm_set_level(s, level);\n    }\n    s->strategy = strategy;\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateTune)(PREFIX3(stream) *strm, int32_t good_length, int32_t max_lazy, int32_t nice_length, int32_t max_chain) {\n    deflate_state *s;\n\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    s = strm->state;\n    s->good_match = (unsigned int)good_length;\n    s->max_lazy_match = (unsigned int)max_lazy;\n    s->nice_match = nice_length;\n    s->max_chain_length = (unsigned int)max_chain;\n    return Z_OK;\n}\n\n/* =========================================================================\n * For the default windowBits of 15 and memLevel of 8, this function returns\n * a close to exact, as well as small, upper bound on the compressed size.\n * They are coded as constants here for a reason--if the #define's are\n * changed, then this function needs to be changed as well.  The return\n * value for 15 and 8 only works for those exact settings.\n *\n * For any setting other than those defaults for windowBits and memLevel,\n * the value returned is a conservative worst case for the maximum expansion\n * resulting from using fixed blocks instead of stored blocks, which deflate\n * can emit on compressed data for some combinations of the parameters.\n *\n * This function could be more sophisticated to provide closer upper bounds for\n * every combination of windowBits and memLevel.  But even the conservative\n * upper bound of about 14% expansion does not seem onerous for output buffer\n * allocation.\n */\nunsigned long Z_EXPORT PREFIX(deflateBound)(PREFIX3(stream) *strm, unsigned long sourceLen) {\n    deflate_state *s;\n    unsigned long complen, wraplen;\n\n    /* conservative upper bound for compressed data */\n    complen = sourceLen + ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;\n    DEFLATE_BOUND_ADJUST_COMPLEN(strm, complen, sourceLen);  /* hook for IBM Z DFLTCC */\n\n    /* if can't get parameters, return conservative bound plus zlib wrapper */\n    if (deflateStateCheck(strm))\n        return complen + 6;\n\n    /* compute wrapper length */\n    s = strm->state;\n    switch (s->wrap) {\n    case 0:                                 /* raw deflate */\n        wraplen = 0;\n        break;\n    case 1:                                 /* zlib wrapper */\n        wraplen = ZLIB_WRAPLEN + (s->strstart ? 4 : 0);\n        break;\n#ifdef GZIP\n    case 2:                                 /* gzip wrapper */\n        wraplen = GZIP_WRAPLEN;\n        if (s->gzhead != NULL) {            /* user-supplied gzip header */\n            unsigned char *str;\n            if (s->gzhead->extra != NULL) {\n                wraplen += 2 + s->gzhead->extra_len;\n            }\n            str = s->gzhead->name;\n            if (str != NULL) {\n                do {\n                    wraplen++;\n                } while (*str++);\n            }\n            str = s->gzhead->comment;\n            if (str != NULL) {\n                do {\n                    wraplen++;\n                } while (*str++);\n            }\n            if (s->gzhead->hcrc)\n                wraplen += 2;\n        }\n        break;\n#endif\n    default:                                /* for compiler happiness */\n        wraplen = ZLIB_WRAPLEN;\n    }\n\n    /* if not default parameters, return conservative bound */\n    if (DEFLATE_NEED_CONSERVATIVE_BOUND(strm) ||  /* hook for IBM Z DFLTCC */\n            s->w_bits != MAX_WBITS || HASH_BITS < 15) {\n        if (s->level == 0) {\n            /* upper bound for stored blocks with length 127 (memLevel == 1) --\n               ~4% overhead plus a small constant */\n            complen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) + (sourceLen >> 11) + 7;\n        }\n\n        return complen + wraplen;\n    }\n\n#ifndef NO_QUICK_STRATEGY\n    return sourceLen                       /* The source size itself */\n      + (sourceLen == 0 ? 1 : 0)           /* Always at least one byte for any input */\n      + (sourceLen < 9 ? 1 : 0)            /* One extra byte for lengths less than 9 */\n      + DEFLATE_QUICK_OVERHEAD(sourceLen)  /* Source encoding overhead, padded to next full byte */\n      + DEFLATE_BLOCK_OVERHEAD             /* Deflate block overhead bytes */\n      + wraplen;                           /* none, zlib or gzip wrapper */\n#else\n    return sourceLen + (sourceLen >> 4) + 7 + wraplen;\n#endif\n}\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nZ_INTERNAL void PREFIX(flush_pending)(PREFIX3(stream) *strm) {\n    uint32_t len;\n    deflate_state *s = strm->state;\n\n    zng_tr_flush_bits(s);\n    len = MIN(s->pending, strm->avail_out);\n    if (len == 0)\n        return;\n\n    Tracev((stderr, \"[FLUSH]\"));\n    memcpy(strm->next_out, s->pending_out, len);\n    strm->next_out  += len;\n    s->pending_out  += len;\n    strm->total_out += len;\n    strm->avail_out -= len;\n    s->pending      -= len;\n    if (s->pending == 0)\n        s->pending_out = s->pending_buf;\n}\n\n/* ===========================================================================\n * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].\n */\n#define HCRC_UPDATE(beg) \\\n    do { \\\n        if (s->gzhead->hcrc && s->pending > (beg)) \\\n            strm->adler = PREFIX(crc32)(strm->adler, s->pending_buf + (beg), s->pending - (beg)); \\\n    } while (0)\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflate)(PREFIX3(stream) *strm, int32_t flush) {\n    int32_t old_flush; /* value of flush param for previous deflate call */\n    deflate_state *s;\n\n    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0)\n        return Z_STREAM_ERROR;\n    s = strm->state;\n\n    if (strm->next_out == NULL || (strm->avail_in != 0 && strm->next_in == NULL)\n        || (s->status == FINISH_STATE && flush != Z_FINISH)) {\n        ERR_RETURN(strm, Z_STREAM_ERROR);\n    }\n    if (strm->avail_out == 0) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    old_flush = s->last_flush;\n    s->last_flush = flush;\n\n    /* Flush as much pending output as possible */\n    if (s->pending != 0) {\n        PREFIX(flush_pending)(strm);\n        if (strm->avail_out == 0) {\n            /* Since avail_out is 0, deflate will be called again with\n             * more output space, but possibly with both pending and\n             * avail_in equal to zero. There won't be anything to do,\n             * but this is not an error situation so make sure we\n             * return OK instead of BUF_ERROR at next call of deflate:\n             */\n            s->last_flush = -1;\n            return Z_OK;\n        }\n\n        /* Make sure there is something to do and avoid duplicate consecutive\n         * flushes. For repeated and useless calls with Z_FINISH, we keep\n         * returning Z_STREAM_END instead of Z_BUF_ERROR.\n         */\n    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) && flush != Z_FINISH) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* User must not provide more input after the first FINISH: */\n    if (s->status == FINISH_STATE && strm->avail_in != 0)   {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* Write the header */\n    if (s->status == INIT_STATE && s->wrap == 0)\n        s->status = BUSY_STATE;\n    if (s->status == INIT_STATE) {\n        /* zlib header */\n        unsigned int header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n        unsigned int level_flags;\n\n        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)\n            level_flags = 0;\n        else if (s->level < 6)\n            level_flags = 1;\n        else if (s->level == 6)\n            level_flags = 2;\n        else\n            level_flags = 3;\n        header |= (level_flags << 6);\n        if (s->strstart != 0)\n            header |= PRESET_DICT;\n        header += 31 - (header % 31);\n\n        put_short_msb(s, (uint16_t)header);\n\n        /* Save the adler32 of the preset dictionary: */\n        if (s->strstart != 0)\n            put_uint32_msb(s, strm->adler);\n        strm->adler = ADLER32_INITIAL_VALUE;\n        s->status = BUSY_STATE;\n\n        /* Compression must start with an empty pending buffer */\n        PREFIX(flush_pending)(strm);\n        if (s->pending != 0) {\n            s->last_flush = -1;\n            return Z_OK;\n        }\n    }\n#ifdef GZIP\n    if (s->status == GZIP_STATE) {\n        /* gzip header */\n        FUNCTABLE_CALL(crc32_fold_reset)(&s->crc_fold);\n        put_byte(s, 31);\n        put_byte(s, 139);\n        put_byte(s, 8);\n        if (s->gzhead == NULL) {\n            put_uint32(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s->level == 9 ? 2 :\n                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ? 4 : 0));\n            put_byte(s, OS_CODE);\n            s->status = BUSY_STATE;\n\n            /* Compression must start with an empty pending buffer */\n            PREFIX(flush_pending)(strm);\n            if (s->pending != 0) {\n                s->last_flush = -1;\n                return Z_OK;\n            }\n        } else {\n            put_byte(s, (s->gzhead->text ? 1 : 0) +\n                     (s->gzhead->hcrc ? 2 : 0) +\n                     (s->gzhead->extra == NULL ? 0 : 4) +\n                     (s->gzhead->name == NULL ? 0 : 8) +\n                     (s->gzhead->comment == NULL ? 0 : 16)\n                     );\n            put_uint32(s, s->gzhead->time);\n            put_byte(s, s->level == 9 ? 2 : (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ? 4 : 0));\n            put_byte(s, s->gzhead->os & 0xff);\n            if (s->gzhead->extra != NULL)\n                put_short(s, (uint16_t)s->gzhead->extra_len);\n            if (s->gzhead->hcrc)\n                strm->adler = PREFIX(crc32)(strm->adler, s->pending_buf, s->pending);\n            s->gzindex = 0;\n            s->status = EXTRA_STATE;\n        }\n    }\n    if (s->status == EXTRA_STATE) {\n        if (s->gzhead->extra != NULL) {\n            uint32_t beg = s->pending;   /* start of bytes to update crc */\n            uint32_t left = (s->gzhead->extra_len & 0xffff) - s->gzindex;\n\n            while (s->pending + left > s->pending_buf_size) {\n                uint32_t copy = s->pending_buf_size - s->pending;\n                memcpy(s->pending_buf + s->pending, s->gzhead->extra + s->gzindex, copy);\n                s->pending = s->pending_buf_size;\n                HCRC_UPDATE(beg);\n                s->gzindex += copy;\n                PREFIX(flush_pending)(strm);\n                if (s->pending != 0) {\n                    s->last_flush = -1;\n                    return Z_OK;\n                }\n                beg = 0;\n                left -= copy;\n            }\n            memcpy(s->pending_buf + s->pending, s->gzhead->extra + s->gzindex, left);\n            s->pending += left;\n            HCRC_UPDATE(beg);\n            s->gzindex = 0;\n        }\n        s->status = NAME_STATE;\n    }\n    if (s->status == NAME_STATE) {\n        if (s->gzhead->name != NULL) {\n            uint32_t beg = s->pending;   /* start of bytes to update crc */\n            unsigned char val;\n\n            do {\n                if (s->pending == s->pending_buf_size) {\n                    HCRC_UPDATE(beg);\n                    PREFIX(flush_pending)(strm);\n                    if (s->pending != 0) {\n                        s->last_flush = -1;\n                        return Z_OK;\n                    }\n                    beg = 0;\n                }\n                val = s->gzhead->name[s->gzindex++];\n                put_byte(s, val);\n            } while (val != 0);\n            HCRC_UPDATE(beg);\n            s->gzindex = 0;\n        }\n        s->status = COMMENT_STATE;\n    }\n    if (s->status == COMMENT_STATE) {\n        if (s->gzhead->comment != NULL) {\n            uint32_t beg = s->pending;  /* start of bytes to update crc */\n            unsigned char val;\n\n            do {\n                if (s->pending == s->pending_buf_size) {\n                    HCRC_UPDATE(beg);\n                    PREFIX(flush_pending)(strm);\n                    if (s->pending != 0) {\n                        s->last_flush = -1;\n                        return Z_OK;\n                    }\n                    beg = 0;\n                }\n                val = s->gzhead->comment[s->gzindex++];\n                put_byte(s, val);\n            } while (val != 0);\n            HCRC_UPDATE(beg);\n        }\n        s->status = HCRC_STATE;\n    }\n    if (s->status == HCRC_STATE) {\n        if (s->gzhead->hcrc) {\n            if (s->pending + 2 > s->pending_buf_size) {\n                PREFIX(flush_pending)(strm);\n                if (s->pending != 0) {\n                    s->last_flush = -1;\n                    return Z_OK;\n                }\n            }\n            put_short(s, (uint16_t)strm->adler);\n            FUNCTABLE_CALL(crc32_fold_reset)(&s->crc_fold);\n        }\n        s->status = BUSY_STATE;\n\n        /* Compression must start with an empty pending buffer */\n        PREFIX(flush_pending)(strm);\n        if (s->pending != 0) {\n            s->last_flush = -1;\n            return Z_OK;\n        }\n    }\n#endif\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm->avail_in != 0 || s->lookahead != 0 || (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\n        block_state bstate;\n\n        bstate = DEFLATE_HOOK(strm, flush, &bstate) ? bstate :  /* hook for IBM Z DFLTCC */\n                 s->level == 0 ? deflate_stored(s, flush) :\n                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s->strategy == Z_RLE ? deflate_rle(s, flush) :\n                 (*(configuration_table[s->level].func))(s, flush);\n\n        if (bstate == finish_started || bstate == finish_done) {\n            s->status = FINISH_STATE;\n        }\n        if (bstate == need_more || bstate == finish_started) {\n            if (strm->avail_out == 0) {\n                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n            }\n            return Z_OK;\n            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n             * of deflate should use the same flush parameter to make sure\n             * that the flush is complete. So we don't have to output an\n             * empty block here, this will be done at next call. This also\n             * ensures that for a very small output buffer, we emit at most\n             * one empty block.\n             */\n        }\n        if (bstate == block_done) {\n            if (flush == Z_PARTIAL_FLUSH) {\n                zng_tr_align(s);\n            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n                zng_tr_stored_block(s, (char*)0, 0L, 0);\n                /* For a full flush, this empty block will be recognized\n                 * as a special marker by inflate_sync().\n                 */\n                if (flush == Z_FULL_FLUSH) {\n                    CLEAR_HASH(s);             /* forget history */\n                    if (s->lookahead == 0) {\n                        s->strstart = 0;\n                        s->block_start = 0;\n                        s->insert = 0;\n                    }\n                }\n            }\n            PREFIX(flush_pending)(strm);\n            if (strm->avail_out == 0) {\n                s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n                return Z_OK;\n            }\n        }\n    }\n\n    if (flush != Z_FINISH)\n        return Z_OK;\n\n    /* Write the trailer */\n#ifdef GZIP\n    if (s->wrap == 2) {\n        strm->adler = FUNCTABLE_CALL(crc32_fold_final)(&s->crc_fold);\n\n        put_uint32(s, strm->adler);\n        put_uint32(s, (uint32_t)strm->total_in);\n    } else\n#endif\n    {\n        if (s->wrap == 1)\n            put_uint32_msb(s, strm->adler);\n    }\n    PREFIX(flush_pending)(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    if (s->wrap > 0)\n        s->wrap = -s->wrap; /* write the trailer only once! */\n    if (s->pending == 0) {\n        Assert(s->bi_valid == 0, \"bi_buf not flushed\");\n        return Z_STREAM_END;\n    }\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT PREFIX(deflateEnd)(PREFIX3(stream) *strm) {\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n\n    int32_t status = strm->state->status;\n\n    /* Free allocated buffers */\n    free_deflate(strm);\n\n    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n}\n\n/* =========================================================================\n * Copy the source state to the destination state.\n */\nint32_t Z_EXPORT PREFIX(deflateCopy)(PREFIX3(stream) *dest, PREFIX3(stream) *source) {\n    deflate_state *ds;\n    deflate_state *ss;\n\n    if (deflateStateCheck(source) || dest == NULL)\n        return Z_STREAM_ERROR;\n\n    ss = source->state;\n\n    memcpy((void *)dest, (void *)source, sizeof(PREFIX3(stream)));\n\n    deflate_allocs *alloc_bufs = alloc_deflate(dest, ss->w_bits, ss->lit_bufsize);\n    if (alloc_bufs == NULL)\n        return Z_MEM_ERROR;\n\n    ds = alloc_bufs->state;\n\n    dest->state = (struct internal_state *) ds;\n    memcpy(ds, ss, sizeof(deflate_state));\n    ds->strm = dest;\n\n    ds->alloc_bufs = alloc_bufs;\n    ds->window = alloc_bufs->window;\n    ds->prev = alloc_bufs->prev;\n    ds->head = alloc_bufs->head;\n    ds->pending_buf = alloc_bufs->pending_buf;\n\n    if (ds->window == NULL || ds->prev == NULL || ds->head == NULL || ds->pending_buf == NULL) {\n        PREFIX(deflateEnd)(dest);\n        return Z_MEM_ERROR;\n    }\n\n    memcpy(ds->window, ss->window, DEFLATE_ADJUST_WINDOW_SIZE(ds->w_size * 2 * sizeof(unsigned char)));\n    memcpy((void *)ds->prev, (void *)ss->prev, ds->w_size * sizeof(Pos));\n    memcpy((void *)ds->head, (void *)ss->head, HASH_SIZE * sizeof(Pos));\n    memcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n#ifdef LIT_MEM\n    ds->d_buf = (uint16_t *)(ds->pending_buf + (ds->lit_bufsize << 1));\n    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);\n#else\n    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n#endif\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n}\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->next_in buffer and copying from it.\n * (See also flush_pending()).\n */\nZ_INTERNAL unsigned PREFIX(read_buf)(PREFIX3(stream) *strm, unsigned char *buf, unsigned size) {\n    uint32_t len = MIN(strm->avail_in, size);\n    if (len == 0)\n        return 0;\n\n    strm->avail_in  -= len;\n\n    if (!DEFLATE_NEED_CHECKSUM(strm)) {\n        memcpy(buf, strm->next_in, len);\n#ifdef GZIP\n    } else if (strm->state->wrap == 2) {\n        FUNCTABLE_CALL(crc32_fold_copy)(&strm->state->crc_fold, buf, strm->next_in, len);\n#endif\n    } else if (strm->state->wrap == 1) {\n        strm->adler = FUNCTABLE_CALL(adler32_fold_copy)(strm->adler, buf, strm->next_in, len);\n    } else {\n        memcpy(buf, strm->next_in, len);\n    }\n    strm->next_in  += len;\n    strm->total_in += len;\n\n    return len;\n}\n\n/* ===========================================================================\n * Set longest match variables based on level configuration\n */\nstatic void lm_set_level(deflate_state *s, int level) {\n    s->max_lazy_match   = configuration_table[level].max_lazy;\n    s->good_match       = configuration_table[level].good_length;\n    s->nice_match       = configuration_table[level].nice_length;\n    s->max_chain_length = configuration_table[level].max_chain;\n\n    /* Use rolling hash for deflate_slow algorithm with level 9. It allows us to\n     * properly lookup different hash chains to speed up longest_match search. Since hashing\n     * method changes depending on the level we cannot put this into functable. */\n    if (s->max_chain_length > 1024) {\n        s->update_hash = &update_hash_roll;\n        s->insert_string = &insert_string_roll;\n        s->quick_insert_string = &quick_insert_string_roll;\n    } else {\n        s->update_hash = update_hash;\n        s->insert_string = insert_string;\n        s->quick_insert_string = quick_insert_string;\n    }\n\n    s->level = level;\n}\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nstatic void lm_init(deflate_state *s) {\n    s->window_size = 2 * s->w_size;\n\n    CLEAR_HASH(s);\n\n    /* Set the default configuration parameters:\n     */\n    lm_set_level(s, s->level);\n\n    s->strstart = 0;\n    s->block_start = 0;\n    s->lookahead = 0;\n    s->insert = 0;\n    s->prev_length = 0;\n    s->match_available = 0;\n    s->match_start = 0;\n    s->ins_h = 0;\n}\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\n\nvoid Z_INTERNAL PREFIX(fill_window)(deflate_state *s) {\n    unsigned n;\n    unsigned int more;    /* Amount of free space at the end of the window. */\n    unsigned int wsize = s->w_size;\n\n    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n    do {\n        more = s->window_size - s->lookahead - s->strstart;\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        if (s->strstart >= wsize+MAX_DIST(s)) {\n            memcpy(s->window, s->window+wsize, (unsigned)wsize);\n            if (s->match_start >= wsize) {\n                s->match_start -= wsize;\n            } else {\n                s->match_start = 0;\n                s->prev_length = 0;\n            }\n            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */\n            s->block_start -= (int)wsize;\n            if (s->insert > s->strstart)\n                s->insert = s->strstart;\n            FUNCTABLE_CALL(slide_hash)(s);\n            more += wsize;\n        }\n        if (s->strm->avail_in == 0)\n            break;\n\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        Assert(more >= 2, \"more < 2\");\n\n        n = PREFIX(read_buf)(s->strm, s->window + s->strstart + s->lookahead, more);\n        s->lookahead += n;\n\n        /* Initialize the hash value now that we have some input: */\n        if (s->lookahead + s->insert >= STD_MIN_MATCH) {\n            unsigned int str = s->strstart - s->insert;\n            if (UNLIKELY(s->max_chain_length > 1024)) {\n                s->ins_h = s->update_hash(s->window[str], s->window[str+1]);\n            } else if (str >= 1) {\n                s->quick_insert_string(s, str + 2 - STD_MIN_MATCH);\n            }\n            unsigned int count = s->insert;\n            if (UNLIKELY(s->lookahead == 1)) {\n                count -= 1;\n            }\n            if (count > 0) {\n                s->insert_string(s, str, count);\n                s->insert -= count;\n            }\n        }\n        /* If the whole input has less than STD_MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n\n    /* If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to STD_MAX_MATCH since the longest match\n     * routines allow scanning to strstart + STD_MAX_MATCH, ignoring lookahead.\n     */\n    if (s->high_water < s->window_size) {\n        unsigned int curr = s->strstart + s->lookahead;\n        unsigned int init;\n\n        if (s->high_water < curr) {\n            /* Previous high water mark below current data -- zero WIN_INIT\n             * bytes or up to end of window, whichever is less.\n             */\n            init = s->window_size - curr;\n            if (init > WIN_INIT)\n                init = WIN_INIT;\n            memset(s->window + curr, 0, init);\n            s->high_water = curr + init;\n        } else if (s->high_water < curr + WIN_INIT) {\n            /* High water mark at or above current data, but below current data\n             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n             * to end of window, whichever is less.\n             */\n            init = curr + WIN_INIT - s->high_water;\n            if (init > s->window_size - s->high_water)\n                init = s->window_size - s->high_water;\n            memset(s->window + s->high_water, 0, init);\n            s->high_water += init;\n        }\n    }\n\n    Assert((unsigned long)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n           \"not enough room for search\");\n}\n\n#ifndef ZLIB_COMPAT\n/* =========================================================================\n * Checks whether buffer size is sufficient and whether this parameter is a duplicate.\n */\nstatic int32_t deflateSetParamPre(zng_deflate_param_value **out, size_t min_size, zng_deflate_param_value *param) {\n    int32_t buf_error = param->size < min_size;\n\n    if (*out != NULL) {\n        (*out)->status = Z_BUF_ERROR;\n        buf_error = 1;\n    }\n    *out = param;\n    return buf_error;\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT zng_deflateSetParams(zng_stream *strm, zng_deflate_param_value *params, size_t count) {\n    size_t i;\n    deflate_state *s;\n    zng_deflate_param_value *new_level = NULL;\n    zng_deflate_param_value *new_strategy = NULL;\n    zng_deflate_param_value *new_reproducible = NULL;\n    int param_buf_error;\n    int version_error = 0;\n    int buf_error = 0;\n    int stream_error = 0;\n\n    /* Initialize the statuses. */\n    for (i = 0; i < count; i++)\n        params[i].status = Z_OK;\n\n    /* Check whether the stream state is consistent. */\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    s = strm->state;\n\n    /* Check buffer sizes and detect duplicates. */\n    for (i = 0; i < count; i++) {\n        switch (params[i].param) {\n            case Z_DEFLATE_LEVEL:\n                param_buf_error = deflateSetParamPre(&new_level, sizeof(int), &params[i]);\n                break;\n            case Z_DEFLATE_STRATEGY:\n                param_buf_error = deflateSetParamPre(&new_strategy, sizeof(int), &params[i]);\n                break;\n            case Z_DEFLATE_REPRODUCIBLE:\n                param_buf_error = deflateSetParamPre(&new_reproducible, sizeof(int), &params[i]);\n                break;\n            default:\n                params[i].status = Z_VERSION_ERROR;\n                version_error = 1;\n                param_buf_error = 0;\n                break;\n        }\n        if (param_buf_error) {\n            params[i].status = Z_BUF_ERROR;\n            buf_error = 1;\n        }\n    }\n    /* Exit early if small buffers or duplicates are detected. */\n    if (buf_error)\n        return Z_BUF_ERROR;\n\n    /* Apply changes, remember if there were errors. */\n    if (new_level != NULL || new_strategy != NULL) {\n        int ret = PREFIX(deflateParams)(strm, new_level == NULL ? s->level : *(int *)new_level->buf,\n                                        new_strategy == NULL ? s->strategy : *(int *)new_strategy->buf);\n        if (ret != Z_OK) {\n            if (new_level != NULL)\n                new_level->status = Z_STREAM_ERROR;\n            if (new_strategy != NULL)\n                new_strategy->status = Z_STREAM_ERROR;\n            stream_error = 1;\n        }\n    }\n    if (new_reproducible != NULL) {\n        int val = *(int *)new_reproducible->buf;\n        if (DEFLATE_CAN_SET_REPRODUCIBLE(strm, val)) {\n            s->reproducible = val;\n        } else {\n            new_reproducible->status = Z_STREAM_ERROR;\n            stream_error = 1;\n        }\n    }\n\n    /* Report version errors only if there are no real errors. */\n    return stream_error ? Z_STREAM_ERROR : (version_error ? Z_VERSION_ERROR : Z_OK);\n}\n\n/* ========================================================================= */\nint32_t Z_EXPORT zng_deflateGetParams(zng_stream *strm, zng_deflate_param_value *params, size_t count) {\n    deflate_state *s;\n    size_t i;\n    int32_t buf_error = 0;\n    int32_t version_error = 0;\n\n    /* Initialize the statuses. */\n    for (i = 0; i < count; i++)\n        params[i].status = Z_OK;\n\n    /* Check whether the stream state is consistent. */\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    s = strm->state;\n\n    for (i = 0; i < count; i++) {\n        switch (params[i].param) {\n            case Z_DEFLATE_LEVEL:\n                if (params[i].size < sizeof(int))\n                    params[i].status = Z_BUF_ERROR;\n                else\n                    *(int *)params[i].buf = s->level;\n                break;\n            case Z_DEFLATE_STRATEGY:\n                if (params[i].size < sizeof(int))\n                    params[i].status = Z_BUF_ERROR;\n                else\n                    *(int *)params[i].buf = s->strategy;\n                break;\n            case Z_DEFLATE_REPRODUCIBLE:\n                if (params[i].size < sizeof(int))\n                    params[i].status = Z_BUF_ERROR;\n                else\n                    *(int *)params[i].buf = s->reproducible;\n                break;\n            default:\n                params[i].status = Z_VERSION_ERROR;\n                version_error = 1;\n                break;\n        }\n        if (params[i].status == Z_BUF_ERROR)\n            buf_error = 1;\n    }\n    return buf_error ? Z_BUF_ERROR : (version_error ? Z_VERSION_ERROR : Z_OK);\n}\n#endif\n"
        },
        {
          "name": "deflate.h",
          "type": "blob",
          "size": 17.2333984375,
          "content": "#ifndef DEFLATE_H_\n#define DEFLATE_H_\n/* deflate.h -- internal compression state\n * Copyright (C) 1995-2016 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n#include \"zutil.h\"\n#include \"zendian.h\"\n#include \"zmemory.h\"\n#include \"crc32.h\"\n\n#ifdef S390_DFLTCC_DEFLATE\n#  include \"arch/s390/dfltcc_common.h\"\n#  define HAVE_ARCH_DEFLATE_STATE\n#endif\n\n/* define NO_GZIP when compiling if you want to disable gzip header and\n   trailer creation by deflate().  NO_GZIP would be used to avoid linking in\n   the crc code when it is not needed.  For shared libraries, gzip encoding\n   should be left enabled. */\n#ifndef NO_GZIP\n#  define GZIP\n#endif\n\n/* define LIT_MEM to slightly increase the speed of deflate (order 1% to 2%) at\n   the cost of a larger memory footprint */\n#ifndef NO_LIT_MEM\n#  define LIT_MEM\n#endif\n\n/* ===========================================================================\n * Internal compression state.\n */\n\n#define LENGTH_CODES 29\n/* number of length codes, not counting the special END_BLOCK code */\n\n#define LITERALS  256\n/* number of literal bytes 0..255 */\n\n#define L_CODES (LITERALS+1+LENGTH_CODES)\n/* number of Literal or Length codes, including the END_BLOCK code */\n\n#define D_CODES   30\n/* number of distance codes */\n\n#define BL_CODES  19\n/* number of codes used to transfer the bit lengths */\n\n#define HEAP_SIZE (2*L_CODES+1)\n/* maximum heap size */\n\n#define BIT_BUF_SIZE 64\n/* size of bit buffer in bi_buf */\n\n#define END_BLOCK 256\n/* end of block literal code */\n\n#define INIT_STATE      1    /* zlib header -> BUSY_STATE */\n#ifdef GZIP\n#  define GZIP_STATE    4    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n#  define EXTRA_STATE   5    /* gzip extra block -> NAME_STATE */\n#  define NAME_STATE    6    /* gzip file name -> COMMENT_STATE */\n#  define COMMENT_STATE 7    /* gzip comment -> HCRC_STATE */\n#  define HCRC_STATE    8    /* gzip header CRC -> BUSY_STATE */\n#endif\n#define BUSY_STATE      2    /* deflate -> FINISH_STATE */\n#define FINISH_STATE    3    /* stream complete */\n#ifdef GZIP\n#  define MAX_STATE     HCRC_STATE\n#else\n#  define MAX_STATE     FINISH_STATE\n#endif\n/* Stream status */\n\n#define HASH_BITS    16u           /* log2(HASH_SIZE) */\n#ifndef HASH_SIZE\n#  define HASH_SIZE 65536u         /* number of elements in hash table */\n#endif\n#define HASH_MASK (HASH_SIZE - 1u) /* HASH_SIZE-1 */\n\n\n/* Data structure describing a single value and its code string. */\ntypedef struct ct_data_s {\n    union {\n        uint16_t  freq;       /* frequency count */\n        uint16_t  code;       /* bit string */\n    } fc;\n    union {\n        uint16_t  dad;        /* father node in Huffman tree */\n        uint16_t  len;        /* length of bit string */\n    } dl;\n} ct_data;\n\n#define Freq fc.freq\n#define Code fc.code\n#define Dad  dl.dad\n#define Len  dl.len\n\ntypedef struct static_tree_desc_s  static_tree_desc;\n\ntypedef struct tree_desc_s {\n    ct_data                *dyn_tree;  /* the dynamic tree */\n    int                    max_code;   /* largest code with non zero frequency */\n    const static_tree_desc *stat_desc; /* the corresponding static tree */\n} tree_desc;\n\ntypedef uint16_t Pos;\n\n/* A Pos is an index in the character window. We use short instead of int to\n * save space in the various tables.\n */\n/* Type definitions for hash callbacks */\ntypedef struct internal_state deflate_state;\n\ntypedef uint32_t (* update_hash_cb)        (uint32_t h, uint32_t val);\ntypedef void     (* insert_string_cb)      (deflate_state *const s, uint32_t str, uint32_t count);\ntypedef Pos      (* quick_insert_string_cb)(deflate_state *const s, uint32_t str);\n\nuint32_t update_hash             (uint32_t h, uint32_t val);\nvoid     insert_string           (deflate_state *const s, uint32_t str, uint32_t count);\nPos      quick_insert_string     (deflate_state *const s, uint32_t str);\n\nuint32_t update_hash_roll        (uint32_t h, uint32_t val);\nvoid     insert_string_roll      (deflate_state *const s, uint32_t str, uint32_t count);\nPos      quick_insert_string_roll(deflate_state *const s, uint32_t str);\n\n/* Struct for memory allocation handling */\ntypedef struct deflate_allocs_s {\n    char            *buf_start;\n    free_func        zfree;\n    deflate_state   *state;\n    unsigned char   *window;\n    unsigned char   *pending_buf;\n    Pos             *prev;\n    Pos             *head;\n} deflate_allocs;\n\nstruct ALIGNED_(64) internal_state {\n    PREFIX3(stream)      *strm;            /* pointer back to this zlib stream */\n    unsigned char        *pending_buf;     /* output still pending */\n    unsigned char        *pending_out;     /* next pending byte to output to the stream */\n    uint32_t             pending_buf_size; /* size of pending_buf */\n    uint32_t             pending;          /* nb of bytes in the pending buffer */\n    int                  wrap;             /* bit 0 true for zlib, bit 1 true for gzip */\n    uint32_t             gzindex;          /* where in extra, name, or comment */\n    PREFIX(gz_headerp)   gzhead;           /* gzip header information to write */\n    int                  status;           /* as the name implies */\n    int                  last_flush;       /* value of flush param for previous deflate call */\n    int                  reproducible;     /* Whether reproducible compression results are required. */\n\n    int block_open;\n    /* Whether or not a block is currently open for the QUICK deflation scheme.\n     * This is set to 1 if there is an active block, or 0 if the block was just closed.\n     */\n\n                /* used by deflate.c: */\n\n    unsigned int  w_size;            /* LZ77 window size (32K by default) */\n    unsigned int  w_bits;            /* log2(w_size)  (8..16) */\n    unsigned int  w_mask;            /* w_size - 1 */\n    unsigned int  lookahead;         /* number of valid bytes ahead in window */\n\n    unsigned int high_water;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n\n    unsigned int window_size;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    unsigned char *window;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-STD_MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size. Also, it limits\n     * the window size to 64K, which is quite useful on MSDOS.\n     * To do: use the user input buffer as sliding window.\n     */\n\n    Pos *prev;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    Pos *head; /* Heads of the hash chains or 0. */\n\n    uint32_t ins_h; /* hash index of string to be inserted */\n\n    int block_start;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    unsigned int match_length;       /* length of best match */\n    Pos          prev_match;         /* previous match */\n    int          match_available;    /* set if previous match exists */\n    unsigned int strstart;           /* start of string to insert */\n    unsigned int match_start;        /* start of matching string */\n\n    unsigned int prev_length;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    unsigned int max_chain_length;\n    /* To speed up deflation, hash chains are never searched beyond this length.\n     * A higher limit improves compression ratio but degrades the speed.\n     */\n\n    unsigned int max_lazy_match;\n    /* Attempt to find a better match only when the current match is strictly smaller\n     * than this value. This mechanism is used only for compression levels >= 4.\n     */\n#   define max_insert_length  max_lazy_match\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    update_hash_cb          update_hash;\n    insert_string_cb        insert_string;\n    quick_insert_string_cb  quick_insert_string;\n    /* Hash function callbacks that can be configured depending on the deflate\n     * algorithm being used */\n\n    int level;    /* compression level (1..9) */\n    int strategy; /* favor or force Huffman coding*/\n\n    unsigned int good_match;\n    /* Use a faster search when the previous match is longer than this */\n\n    int nice_match; /* Stop searching when current match exceeds this */\n\n#if defined(_M_IX86) || defined(_M_ARM)\n    int padding[2];\n#endif\n\n    struct crc32_fold_s ALIGNED_(16) crc_fold;\n\n                /* used by trees.c: */\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    struct tree_desc_s l_desc;               /* desc. for literal tree */\n    struct tree_desc_s d_desc;               /* desc. for distance tree */\n    struct tree_desc_s bl_desc;              /* desc. for bit length tree */\n\n    uint16_t bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    int heap_len;               /* number of elements in the heap */\n    int heap_max;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    unsigned char depth[2*L_CODES+1];\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n    unsigned int  lit_bufsize;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n#ifdef LIT_MEM\n#   define LIT_BUFS 5\n    uint16_t *d_buf;              /* buffer for distances */\n    unsigned char *l_buf;         /* buffer for literals/lengths */\n#else\n#   define LIT_BUFS 4\n    unsigned char *sym_buf;       /* buffer for distances and literals/lengths */\n#endif\n\n    unsigned int sym_next;        /* running index in symbol buffer */\n    unsigned int sym_end;         /* symbol table full when sym_next reaches this */\n\n    unsigned long opt_len;        /* bit length of current block with optimal trees */\n    unsigned long static_len;     /* bit length of current block with static trees */\n    unsigned int matches;         /* number of string matches in current block */\n    unsigned int insert;          /* bytes at end of window left to insert */\n\n    /* compressed_len and bits_sent are only used if ZLIB_DEBUG is defined */\n    unsigned long compressed_len; /* total bit length of compressed file mod 2^32 */\n    unsigned long bits_sent;      /* bit length of compressed data sent mod 2^32 */\n\n    deflate_allocs *alloc_bufs;\n\n#ifdef HAVE_ARCH_DEFLATE_STATE\n    arch_deflate_state arch;      /* architecture-specific extensions */\n#endif\n\n    uint64_t bi_buf;\n    /* Output buffer. bits are inserted starting at the bottom (least significant bits). */\n\n    int32_t bi_valid;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit are always zero. */\n\n    /* Reserved for future use and alignment purposes */\n    int32_t reserved[19];\n#if defined(_M_IX86) || defined(_M_ARM)\n    int32_t padding2[4];\n#endif\n};\n\ntypedef enum {\n    need_more,      /* block not completed, need more input or more output */\n    block_done,     /* block flush performed */\n    finish_started, /* finish started, need only more output at next deflate */\n    finish_done     /* finish done, accept no more input or output */\n} block_state;\n\n/* Output a byte on the stream.\n * IN assertion: there is enough room in pending_buf.\n */\n#define put_byte(s, c) { \\\n    s->pending_buf[s->pending++] = (unsigned char)(c); \\\n}\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pending_buf.\n */\nstatic inline void put_short(deflate_state *s, uint16_t w) {\n#if BYTE_ORDER == BIG_ENDIAN\n    w = ZSWAP16(w);\n#endif\n    zng_memwrite_2(&s->pending_buf[s->pending], w);\n    s->pending += 2;\n}\n\n/* ===========================================================================\n * Output a short MSB first on the stream.\n * IN assertion: there is enough room in pending_buf.\n */\nstatic inline void put_short_msb(deflate_state *s, uint16_t w) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n    w = ZSWAP16(w);\n#endif\n    zng_memwrite_2(&s->pending_buf[s->pending], w);\n    s->pending += 2;\n}\n\n/* ===========================================================================\n * Output a 32-bit unsigned int LSB first on the stream.\n * IN assertion: there is enough room in pending_buf.\n */\nstatic inline void put_uint32(deflate_state *s, uint32_t dw) {\n#if BYTE_ORDER == BIG_ENDIAN\n    dw = ZSWAP32(dw);\n#endif\n    zng_memwrite_4(&s->pending_buf[s->pending], dw);\n    s->pending += 4;\n}\n\n/* ===========================================================================\n * Output a 32-bit unsigned int MSB first on the stream.\n * IN assertion: there is enough room in pending_buf.\n */\nstatic inline void put_uint32_msb(deflate_state *s, uint32_t dw) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n    dw = ZSWAP32(dw);\n#endif\n    zng_memwrite_4(&s->pending_buf[s->pending], dw);\n    s->pending += 4;\n}\n\n/* ===========================================================================\n * Output a 64-bit unsigned int LSB first on the stream.\n * IN assertion: there is enough room in pending_buf.\n */\nstatic inline void put_uint64(deflate_state *s, uint64_t lld) {\n#if BYTE_ORDER == BIG_ENDIAN\n    lld = ZSWAP64(lld);\n#endif\n    zng_memwrite_8(&s->pending_buf[s->pending], lld);\n    s->pending += 8;\n}\n\n#define MIN_LOOKAHEAD (STD_MAX_MATCH + STD_MIN_MATCH + 1)\n/* Minimum amount of lookahead, except at the end of the input file.\n * See deflate.c for comments about the STD_MIN_MATCH+1.\n */\n\n#define MAX_DIST(s)  ((s)->w_size - MIN_LOOKAHEAD)\n/* In order to simplify the code, particularly on 16 bit machines, match\n * distances are limited to MAX_DIST instead of WSIZE.\n */\n\n#define WIN_INIT STD_MAX_MATCH\n/* Number of bytes after end of data in window to initialize in order to avoid\n   memory checker errors from longest match routines */\n\n\nvoid Z_INTERNAL PREFIX(fill_window)(deflate_state *s);\nvoid Z_INTERNAL slide_hash_c(deflate_state *s);\n\n        /* in trees.c */\nvoid Z_INTERNAL zng_tr_init(deflate_state *s);\nvoid Z_INTERNAL zng_tr_flush_block(deflate_state *s, char *buf, uint32_t stored_len, int last);\nvoid Z_INTERNAL zng_tr_flush_bits(deflate_state *s);\nvoid Z_INTERNAL zng_tr_align(deflate_state *s);\nvoid Z_INTERNAL zng_tr_stored_block(deflate_state *s, char *buf, uint32_t stored_len, int last);\nuint16_t Z_INTERNAL PREFIX(bi_reverse)(unsigned code, int len);\nvoid Z_INTERNAL PREFIX(flush_pending)(PREFIX3(streamp) strm);\n#define d_code(dist) ((dist) < 256 ? zng_dist_code[dist] : zng_dist_code[256+((dist)>>7)])\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. zng_dist_code[256] and zng_dist_code[257] are never\n * used.\n */\n\n/* Bit buffer and compress bits calculation debugging */\n#ifdef ZLIB_DEBUG\n#  define cmpr_bits_add(s, len)     s->compressed_len += (len)\n#  define cmpr_bits_align(s)        s->compressed_len = (s->compressed_len + 7) & ~7L\n#  define sent_bits_add(s, bits)    s->bits_sent += (bits)\n#  define sent_bits_align(s)        s->bits_sent = (s->bits_sent + 7) & ~7L\n#else\n#  define cmpr_bits_add(s, len)     Z_UNUSED(len)\n#  define cmpr_bits_align(s)\n#  define sent_bits_add(s, bits)    Z_UNUSED(bits)\n#  define sent_bits_align(s)\n#endif\n\n#endif /* DEFLATE_H_ */\n"
        },
        {
          "name": "deflate_fast.c",
          "type": "blob",
          "size": 4.1552734375,
          "content": "/* deflate_fast.c -- compress data using the fast strategy of deflation algorithm\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nZ_INTERNAL block_state deflate_fast(deflate_state *s, int flush) {\n    Pos hash_head;        /* head of the hash chain */\n    int bflush = 0;       /* set if current block must be flushed */\n    int64_t dist;\n    uint32_t match_len = 0;\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need STD_MAX_MATCH bytes\n         * for the next match, plus WANT_MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            PREFIX(fill_window)(s);\n            if (UNLIKELY(s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)) {\n                return need_more;\n            }\n            if (UNLIKELY(s->lookahead == 0))\n                break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        if (s->lookahead >= WANT_MIN_MATCH) {\n            hash_head = quick_insert_string(s, s->strstart);\n            dist = (int64_t)s->strstart - hash_head;\n\n            /* Find the longest match, discarding those <= prev_length.\n             * At this point we have always match length < WANT_MIN_MATCH\n             */\n            if (dist <= MAX_DIST(s) && dist > 0 && hash_head != 0) {\n                /* To simplify the code, we prevent matches with the string\n                 * of window index 0 (in particular we have to avoid a match\n                 * of the string with itself at the start of the input file).\n                 */\n                match_len = FUNCTABLE_CALL(longest_match)(s, hash_head);\n                /* longest_match() sets match_start */\n            }\n        }\n\n        if (match_len >= WANT_MIN_MATCH) {\n            Assert(s->strstart <= UINT16_MAX, \"strstart should fit in uint16_t\");\n            Assert(s->match_start <= UINT16_MAX, \"match_start should fit in uint16_t\");\n            check_match(s, (Pos)s->strstart, (Pos)s->match_start, match_len);\n\n            bflush = zng_tr_tally_dist(s, s->strstart - s->match_start, match_len - STD_MIN_MATCH);\n\n            s->lookahead -= match_len;\n\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n            if (match_len <= s->max_insert_length && s->lookahead >= WANT_MIN_MATCH) {\n                match_len--; /* string at strstart already in table */\n                s->strstart++;\n\n                insert_string(s, s->strstart, match_len);\n                s->strstart += match_len;\n            } else {\n                s->strstart += match_len;\n                quick_insert_string(s, s->strstart + 2 - STD_MIN_MATCH);\n\n                /* If lookahead < STD_MIN_MATCH, ins_h is garbage, but it does not\n                 * matter since it will be recomputed at next deflate call.\n                 */\n            }\n            match_len = 0;\n        } else {\n            /* No match, output a literal byte */\n            bflush = zng_tr_tally_lit(s, s->window[s->strstart]);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (UNLIKELY(bflush))\n            FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < (STD_MIN_MATCH - 1) ? s->strstart : (STD_MIN_MATCH - 1);\n    if (UNLIKELY(flush == Z_FINISH)) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (UNLIKELY(s->sym_next))\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n"
        },
        {
          "name": "deflate_huff.c",
          "type": "blob",
          "size": 1.3720703125,
          "content": "/* deflate_huff.c -- compress data using huffman encoding only strategy\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nZ_INTERNAL block_state deflate_huff(deflate_state *s, int flush) {\n    int bflush = 0;         /* set if current block must be flushed */\n\n    for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s->lookahead == 0) {\n            PREFIX(fill_window)(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      /* flush the current block */\n            }\n        }\n\n        /* Output a literal byte */\n        bflush = zng_tr_tally_lit(s, s->window[s->strstart]);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush)\n            FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n"
        },
        {
          "name": "deflate_medium.c",
          "type": "blob",
          "size": 9.708984375,
          "content": "/* deflate_medium.c -- The deflate_medium deflate strategy\n *\n * Copyright (C) 2013 Intel Corporation. All rights reserved.\n * Authors:\n *  Arjan van de Ven    <arjan@linux.intel.com>\n *\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n#ifndef NO_MEDIUM_STRATEGY\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n\nstruct match {\n    uint16_t match_start;\n    uint16_t match_length;\n    uint16_t strstart;\n    uint16_t orgstart;\n};\n\nstatic int emit_match(deflate_state *s, struct match match) {\n    int bflush = 0;\n\n    /* matches that are not long enough we need to emit as literals */\n    if (match.match_length < WANT_MIN_MATCH) {\n        while (match.match_length) {\n            bflush += zng_tr_tally_lit(s, s->window[match.strstart]);\n            s->lookahead--;\n            match.strstart++;\n            match.match_length--;\n        }\n        return bflush;\n    }\n\n    check_match(s, match.strstart, match.match_start, match.match_length);\n\n    bflush += zng_tr_tally_dist(s, match.strstart - match.match_start, match.match_length - STD_MIN_MATCH);\n\n    s->lookahead -= match.match_length;\n    return bflush;\n}\n\nstatic void insert_match(deflate_state *s, struct match match) {\n    if (UNLIKELY(s->lookahead <= (unsigned int)(match.match_length + WANT_MIN_MATCH)))\n        return;\n\n    /* string at strstart already in table */\n    match.strstart++;\n    match.match_length--;\n\n    /* matches that are not long enough we need to emit as literals */\n    if (LIKELY(match.match_length < WANT_MIN_MATCH - 1)) {\n        if (UNLIKELY(match.match_length > 0)) {\n            if (match.strstart >= match.orgstart) {\n                if (match.strstart + match.match_length - 1 >= match.orgstart) {\n                    insert_string(s, match.strstart, match.match_length);\n                } else {\n                    insert_string(s, match.strstart, match.orgstart - match.strstart + 1);\n                }\n                match.strstart += match.match_length;\n                match.match_length = 0;\n            }\n        }\n        return;\n    }\n\n    /* Insert into hash table. */\n    if (LIKELY(match.strstart >= match.orgstart)) {\n        if (LIKELY(match.strstart + match.match_length - 1 >= match.orgstart)) {\n            insert_string(s, match.strstart, match.match_length);\n        } else {\n            insert_string(s, match.strstart, match.orgstart - match.strstart + 1);\n        }\n    } else if (match.orgstart < match.strstart + match.match_length) {\n        insert_string(s, match.orgstart, match.strstart + match.match_length - match.orgstart);\n    }\n    match.strstart += match.match_length;\n    match.match_length = 0;\n}\n\nstatic void fizzle_matches(deflate_state *s, struct match *current, struct match *next) {\n    Pos limit;\n    unsigned char *match, *orig;\n    int changed = 0;\n    struct match c, n;\n    /* step zero: sanity checks */\n\n    if (current->match_length <= 1)\n        return;\n\n    if (UNLIKELY(current->match_length > 1 + next->match_start))\n        return;\n\n    if (UNLIKELY(current->match_length > 1 + next->strstart))\n        return;\n\n    match = s->window - current->match_length + 1 + next->match_start;\n    orig  = s->window - current->match_length + 1 + next->strstart;\n\n    /* quick exit check.. if this fails then don't bother with anything else */\n    if (LIKELY(*match != *orig))\n        return;\n\n    c = *current;\n    n = *next;\n\n    /* step one: try to move the \"next\" match to the left as much as possible */\n    limit = next->strstart > MAX_DIST(s) ? next->strstart - (Pos)MAX_DIST(s) : 0;\n\n    match = s->window + n.match_start - 1;\n    orig = s->window + n.strstart - 1;\n\n    while (*match == *orig) {\n        if (UNLIKELY(c.match_length < 1))\n            break;\n        if (UNLIKELY(n.strstart <= limit))\n            break;\n        if (UNLIKELY(n.match_length >= 256))\n            break;\n        if (UNLIKELY(n.match_start <= 1))\n            break;\n\n        n.strstart--;\n        n.match_start--;\n        n.match_length++;\n        c.match_length--;\n        match--;\n        orig--;\n        changed++;\n    }\n\n    if (!changed)\n        return;\n\n    if (c.match_length <= 1 && n.match_length != 2) {\n        n.orgstart++;\n        *current = c;\n        *next = n;\n    } else {\n        return;\n    }\n}\n\nZ_INTERNAL block_state deflate_medium(deflate_state *s, int flush) {\n    /* Align the first struct to start on a new cacheline, this allows us to fit both structs in one cacheline */\n    ALIGNED_(16) struct match current_match;\n                 struct match next_match;\n\n    /* For levels below 5, don't check the next position for a better match */\n    int early_exit = s->level < 5;\n\n    memset(&current_match, 0, sizeof(struct match));\n    memset(&next_match, 0, sizeof(struct match));\n\n    for (;;) {\n        Pos hash_head = 0;    /* head of the hash chain */\n        int bflush = 0;       /* set if current block must be flushed */\n        int64_t dist;\n\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need STD_MAX_MATCH bytes\n         * for the next match, plus WANT_MIN_MATCH bytes to insert the\n         * string following the next current_match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            PREFIX(fill_window)(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (UNLIKELY(s->lookahead == 0))\n                break; /* flush the current block */\n            next_match.match_length = 0;\n        }\n\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n        /* If we already have a future match from a previous round, just use that */\n        if (!early_exit && next_match.match_length > 0) {\n            current_match = next_match;\n            next_match.match_length = 0;\n        } else {\n            hash_head = 0;\n            if (s->lookahead >= WANT_MIN_MATCH) {\n                hash_head = quick_insert_string(s, s->strstart);\n            }\n\n            current_match.strstart = (uint16_t)s->strstart;\n            current_match.orgstart = current_match.strstart;\n\n            /* Find the longest match, discarding those <= prev_length.\n             * At this point we have always match_length < WANT_MIN_MATCH\n             */\n\n            dist = (int64_t)s->strstart - hash_head;\n            if (dist <= MAX_DIST(s) && dist > 0 && hash_head != 0) {\n                /* To simplify the code, we prevent matches with the string\n                 * of window index 0 (in particular we have to avoid a match\n                 * of the string with itself at the start of the input file).\n                 */\n                current_match.match_length = (uint16_t)FUNCTABLE_CALL(longest_match)(s, hash_head);\n                current_match.match_start = (uint16_t)s->match_start;\n                if (UNLIKELY(current_match.match_length < WANT_MIN_MATCH))\n                    current_match.match_length = 1;\n                if (UNLIKELY(current_match.match_start >= current_match.strstart)) {\n                    /* this can happen due to some restarts */\n                    current_match.match_length = 1;\n                }\n            } else {\n                /* Set up the match to be a 1 byte literal */\n                current_match.match_start = 0;\n                current_match.match_length = 1;\n            }\n        }\n\n        insert_match(s, current_match);\n\n        /* now, look ahead one */\n        if (LIKELY(!early_exit && s->lookahead > MIN_LOOKAHEAD && (uint32_t)(current_match.strstart + current_match.match_length) < (s->window_size - MIN_LOOKAHEAD))) {\n            s->strstart = current_match.strstart + current_match.match_length;\n            hash_head = quick_insert_string(s, s->strstart);\n\n            next_match.strstart = (uint16_t)s->strstart;\n            next_match.orgstart = next_match.strstart;\n\n            /* Find the longest match, discarding those <= prev_length.\n             * At this point we have always match_length < WANT_MIN_MATCH\n             */\n\n            dist = (int64_t)s->strstart - hash_head;\n            if (dist <= MAX_DIST(s) && dist > 0 && hash_head != 0) {\n                /* To simplify the code, we prevent matches with the string\n                 * of window index 0 (in particular we have to avoid a match\n                 * of the string with itself at the start of the input file).\n                 */\n                next_match.match_length = (uint16_t)FUNCTABLE_CALL(longest_match)(s, hash_head);\n                next_match.match_start = (uint16_t)s->match_start;\n                if (UNLIKELY(next_match.match_start >= next_match.strstart)) {\n                    /* this can happen due to some restarts */\n                    next_match.match_length = 1;\n                }\n                if (next_match.match_length < WANT_MIN_MATCH)\n                    next_match.match_length = 1;\n                else\n                    fizzle_matches(s, &current_match, &next_match);\n            } else {\n                /* Set up the match to be a 1 byte literal */\n                next_match.match_start = 0;\n                next_match.match_length = 1;\n            }\n\n            s->strstart = current_match.strstart;\n        } else {\n            next_match.match_length = 0;\n        }\n\n        /* now emit the current match */\n        bflush = emit_match(s, current_match);\n\n        /* move the \"cursor\" forward */\n        s->strstart += current_match.match_length;\n\n        if (UNLIKELY(bflush))\n            FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < (STD_MIN_MATCH - 1) ? s->strstart : (STD_MIN_MATCH - 1);\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (UNLIKELY(s->sym_next))\n        FLUSH_BLOCK(s, 0);\n\n    return block_done;\n}\n#endif\n"
        },
        {
          "name": "deflate_p.h",
          "type": "blob",
          "size": 4.59375,
          "content": "/* deflate_p.h -- Private inline functions and macros shared with more than\n *                one deflate method\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n */\n\n#ifndef DEFLATE_P_H\n#define DEFLATE_P_H\n\n/* Forward declare common non-inlined functions declared in deflate.c */\n\n#ifdef ZLIB_DEBUG\n/* ===========================================================================\n * Check that the match at match_start is indeed a match.\n */\nstatic inline void check_match(deflate_state *s, Pos start, Pos match, int length) {\n    /* check that the match length is valid*/\n    if (length < STD_MIN_MATCH || length > STD_MAX_MATCH) {\n        fprintf(stderr, \" start %u, match %u, length %d\\n\", start, match, length);\n        z_error(\"invalid match length\");\n    }\n    /* check that the match isn't at the same position as the start string */\n    if (match == start) {\n        fprintf(stderr, \" start %u, match %u, length %d\\n\", start, match, length);\n        z_error(\"invalid match position\");\n    }\n    /* check that the match is indeed a match */\n    if (memcmp(s->window + match, s->window + start, length) != 0) {\n        int32_t i = 0;\n        fprintf(stderr, \" start %u, match %u, length %d\\n\", start, match, length);\n        do {\n            fprintf(stderr, \"  %03d: match [%02x] start [%02x]\\n\", i++,\n                s->window[match++], s->window[start++]);\n        } while (--length != 0);\n        z_error(\"invalid match\");\n    }\n    if (z_verbose > 1) {\n        fprintf(stderr, \"\\\\[%u,%d]\", start-match, length);\n        do {\n            putc(s->window[start++], stderr);\n        } while (--length != 0);\n    }\n}\n#else\n#define check_match(s, start, match, length)\n#endif\n\nZ_INTERNAL void PREFIX(flush_pending)(PREFIX3(stream) *strm);\nZ_INTERNAL unsigned PREFIX(read_buf)(PREFIX3(stream) *strm, unsigned char *buf, unsigned size);\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\n\nextern const unsigned char Z_INTERNAL zng_length_code[];\nextern const unsigned char Z_INTERNAL zng_dist_code[];\n\nstatic inline int zng_tr_tally_lit(deflate_state *s, unsigned char c) {\n    /* c is the unmatched char */\n#ifdef LIT_MEM\n    s->d_buf[s->sym_next] = 0;\n    s->l_buf[s->sym_next++] = c;\n#else\n    s->sym_buf[s->sym_next++] = 0;\n    s->sym_buf[s->sym_next++] = 0;\n    s->sym_buf[s->sym_next++] = c;\n#endif\n    s->dyn_ltree[c].Freq++;\n    Tracevv((stderr, \"%c\", c));\n    Assert(c <= (STD_MAX_MATCH-STD_MIN_MATCH), \"zng_tr_tally: bad literal\");\n    return (s->sym_next == s->sym_end);\n}\n\nstatic inline int zng_tr_tally_dist(deflate_state* s, uint32_t dist, uint32_t len) {\n    /* dist: distance of matched string */\n    /* len: match length-STD_MIN_MATCH */\n#ifdef LIT_MEM\n    Assert(dist <= UINT16_MAX, \"dist should fit in uint16_t\");\n    Assert(len <= UINT8_MAX, \"len should fit in uint8_t\");\n    s->d_buf[s->sym_next] = (uint16_t)dist;\n    s->l_buf[s->sym_next++] = (uint8_t)len;\n#else\n    s->sym_buf[s->sym_next++] = (uint8_t)(dist);\n    s->sym_buf[s->sym_next++] = (uint8_t)(dist >> 8);\n    s->sym_buf[s->sym_next++] = (uint8_t)len;\n#endif\n    s->matches++;\n    dist--;\n    Assert(dist < MAX_DIST(s) && (uint16_t)d_code(dist) < (uint16_t)D_CODES,\n        \"zng_tr_tally: bad match\");\n\n    s->dyn_ltree[zng_length_code[len] + LITERALS + 1].Freq++;\n    s->dyn_dtree[d_code(dist)].Freq++;\n    return (s->sym_next == s->sym_end);\n}\n\n/* ===========================================================================\n * Flush the current block, with given end-of-file flag.\n * IN assertion: strstart is set to the end of the current match.\n */\n#define FLUSH_BLOCK_ONLY(s, last) { \\\n    zng_tr_flush_block(s, (s->block_start >= 0 ? \\\n                   (char *)&s->window[(unsigned)s->block_start] : \\\n                   NULL), \\\n                   (uint32_t)((int)s->strstart - s->block_start), \\\n                   (last)); \\\n    s->block_start = (int)s->strstart; \\\n    PREFIX(flush_pending)(s->strm); \\\n}\n\n/* Same but force premature exit if necessary. */\n#define FLUSH_BLOCK(s, last) { \\\n    FLUSH_BLOCK_ONLY(s, last); \\\n    if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \\\n}\n\n/* Maximum stored block length in deflate format (not including header). */\n#define MAX_STORED 65535\n\n/* Compression function. Returns the block state after the call. */\ntypedef block_state (*compress_func) (deflate_state *s, int flush);\n/* Match function. Returns the longest match. */\ntypedef uint32_t    (*match_func)    (deflate_state *const s, Pos cur_match);\n\n#endif\n"
        },
        {
          "name": "deflate_quick.c",
          "type": "blob",
          "size": 4.4248046875,
          "content": "/*\n * The deflate_quick deflate strategy, designed to be used when cycles are\n * at a premium.\n *\n * Copyright (C) 2013 Intel Corporation. All rights reserved.\n * Authors:\n *  Wajdi Feghali   <wajdi.k.feghali@intel.com>\n *  Jim Guilford    <james.guilford@intel.com>\n *  Vinodh Gopal    <vinodh.gopal@intel.com>\n *     Erdinc Ozturk   <erdinc.ozturk@intel.com>\n *  Jim Kukunas     <james.t.kukunas@linux.intel.com>\n *\n * Portions are Copyright (C) 2016 12Sided Technology, LLC.\n * Author:\n *  Phil Vachon     <pvachon@12sidedtech.com>\n *\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zmemory.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n#include \"trees_emit.h\"\n\nextern const ct_data static_ltree[L_CODES+2];\nextern const ct_data static_dtree[D_CODES];\n\n#define QUICK_START_BLOCK(s, last) { \\\n    zng_tr_emit_tree(s, STATIC_TREES, last); \\\n    s->block_open = 1 + (int)last; \\\n    s->block_start = (int)s->strstart; \\\n}\n\n#define QUICK_END_BLOCK(s, last) { \\\n    if (s->block_open) { \\\n        zng_tr_emit_end_block(s, static_ltree, last); \\\n        s->block_open = 0; \\\n        s->block_start = (int)s->strstart; \\\n        PREFIX(flush_pending)(s->strm); \\\n        if (s->strm->avail_out == 0) \\\n            return (last) ? finish_started : need_more; \\\n    } \\\n}\n\nZ_INTERNAL block_state deflate_quick(deflate_state *s, int flush) {\n    Pos hash_head;\n    int64_t dist;\n    unsigned match_len, last;\n\n\n    last = (flush == Z_FINISH) ? 1 : 0;\n    if (UNLIKELY(last && s->block_open != 2)) {\n        /* Emit end of previous block */\n        QUICK_END_BLOCK(s, 0);\n        /* Emit start of last block */\n        QUICK_START_BLOCK(s, last);\n    } else if (UNLIKELY(s->block_open == 0 && s->lookahead > 0)) {\n        /* Start new block only when we have lookahead data, so that if no\n           input data is given an empty block will not be written */\n        QUICK_START_BLOCK(s, last);\n    }\n\n    for (;;) {\n        if (UNLIKELY(s->pending + ((BIT_BUF_SIZE + 7) >> 3) >= s->pending_buf_size)) {\n            PREFIX(flush_pending)(s->strm);\n            if (s->strm->avail_out == 0) {\n                return (last && s->strm->avail_in == 0 && s->bi_valid == 0 && s->block_open == 0) ? finish_started : need_more;\n            }\n        }\n\n        if (UNLIKELY(s->lookahead < MIN_LOOKAHEAD)) {\n            PREFIX(fill_window)(s);\n            if (UNLIKELY(s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)) {\n                return need_more;\n            }\n            if (UNLIKELY(s->lookahead == 0))\n                break;\n\n            if (UNLIKELY(s->block_open == 0)) {\n                /* Start new block when we have lookahead data, so that if no\n                   input data is given an empty block will not be written */\n                QUICK_START_BLOCK(s, last);\n            }\n        }\n\n        if (LIKELY(s->lookahead >= WANT_MIN_MATCH)) {\n            hash_head = quick_insert_string(s, s->strstart);\n            dist = (int64_t)s->strstart - hash_head;\n\n            if (dist <= MAX_DIST(s) && dist > 0) {\n                const uint8_t *str_start = s->window + s->strstart;\n                const uint8_t *match_start = s->window + hash_head;\n\n                if (zng_memcmp_2(str_start, match_start) == 0) {\n                    match_len = FUNCTABLE_CALL(compare256)(str_start+2, match_start+2) + 2;\n\n                    if (match_len >= WANT_MIN_MATCH) {\n                        if (UNLIKELY(match_len > s->lookahead))\n                            match_len = s->lookahead;\n                        if (UNLIKELY(match_len > STD_MAX_MATCH))\n                            match_len = STD_MAX_MATCH;\n\n                        Assert(s->strstart <= UINT16_MAX, \"strstart should fit in uint16_t\");\n                        check_match(s, (Pos)s->strstart, hash_head, match_len);\n\n                        zng_tr_emit_dist(s, static_ltree, static_dtree, match_len - STD_MIN_MATCH, (uint32_t)dist);\n                        s->lookahead -= match_len;\n                        s->strstart += match_len;\n                        continue;\n                    }\n                }\n            }\n        }\n\n        zng_tr_emit_lit(s, static_ltree, s->window[s->strstart]);\n        s->strstart++;\n        s->lookahead--;\n    }\n\n    s->insert = s->strstart < (STD_MIN_MATCH - 1) ? s->strstart : (STD_MIN_MATCH - 1);\n    if (UNLIKELY(last)) {\n        QUICK_END_BLOCK(s, 1);\n        return finish_done;\n    }\n\n    QUICK_END_BLOCK(s, 0);\n    return block_done;\n}\n"
        },
        {
          "name": "deflate_rle.c",
          "type": "blob",
          "size": 2.9990234375,
          "content": "/* deflate_rle.c -- compress data using RLE strategy of deflation algorithm\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n#include \"compare256_rle.h\"\n\n#if OPTIMAL_CMP == 8\n#  define compare256_rle compare256_rle_8\n#elif defined(HAVE_BUILTIN_CTZLL)\n#  define compare256_rle compare256_rle_64\n#elif defined(HAVE_BUILTIN_CTZ)\n#  define compare256_rle compare256_rle_32\n#else\n#  define compare256_rle compare256_rle_16\n#endif\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nZ_INTERNAL block_state deflate_rle(deflate_state *s, int flush) {\n    int bflush = 0;                 /* set if current block must be flushed */\n    unsigned char *scan;            /* scan goes up to strend for length of run */\n    uint32_t match_len = 0;\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need STD_MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s->lookahead <= STD_MAX_MATCH) {\n            PREFIX(fill_window)(s);\n            if (s->lookahead <= STD_MAX_MATCH && flush == Z_NO_FLUSH)\n                return need_more;\n            if (s->lookahead == 0)\n                break; /* flush the current block */\n        }\n\n        /* See how many times the previous byte repeats */\n        if (s->lookahead >= STD_MIN_MATCH && s->strstart > 0) {\n            scan = s->window + s->strstart - 1;\n            if (scan[0] == scan[1] && scan[1] == scan[2]) {\n                match_len = compare256_rle(scan, scan+3)+2;\n                match_len = MIN(match_len, s->lookahead);\n                match_len = MIN(match_len, STD_MAX_MATCH);\n            }\n            Assert(scan+match_len <= s->window + s->window_size - 1, \"wild scan\");\n        }\n\n        /* Emit match if have run of STD_MIN_MATCH or longer, else emit literal */\n        if (match_len >= STD_MIN_MATCH) {\n            Assert(s->strstart <= UINT16_MAX, \"strstart should fit in uint16_t\");\n            check_match(s, (Pos)s->strstart, (Pos)(s->strstart - 1), match_len);\n\n            bflush = zng_tr_tally_dist(s, 1, match_len - STD_MIN_MATCH);\n\n            s->lookahead -= match_len;\n            s->strstart += match_len;\n            match_len = 0;\n        } else {\n            /* No match, output a literal byte */\n            bflush = zng_tr_tally_lit(s, s->window[s->strstart]);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush)\n            FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n"
        },
        {
          "name": "deflate_slow.c",
          "type": "blob",
          "size": 5.6533203125,
          "content": "/* deflate_slow.c -- compress data using the slow strategy of deflation algorithm\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n\n/* ===========================================================================\n * Same as deflate_medium, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nZ_INTERNAL block_state deflate_slow(deflate_state *s, int flush) {\n    Pos hash_head;           /* head of hash chain */\n    int bflush;              /* set if current block must be flushed */\n    int64_t dist;\n    uint32_t match_len;\n    match_func longest_match;\n\n    if (s->max_chain_length <= 1024)\n        longest_match = FUNCTABLE_FPTR(longest_match);\n    else\n        longest_match = FUNCTABLE_FPTR(longest_match_slow);\n\n    /* Process the input block. */\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need STD_MAX_MATCH bytes\n         * for the next match, plus WANT_MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            PREFIX(fill_window)(s);\n            if (UNLIKELY(s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)) {\n                return need_more;\n            }\n            if (UNLIKELY(s->lookahead == 0))\n                break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = 0;\n        if (LIKELY(s->lookahead >= WANT_MIN_MATCH)) {\n            hash_head = s->quick_insert_string(s, s->strstart);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        s->prev_match = (Pos)s->match_start;\n        match_len = STD_MIN_MATCH - 1;\n        dist = (int64_t)s->strstart - hash_head;\n\n        if (dist <= MAX_DIST(s) && dist > 0 && s->prev_length < s->max_lazy_match && hash_head != 0) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            match_len = longest_match(s, hash_head);\n            /* longest_match() sets match_start */\n\n            if (match_len <= 5 && (s->strategy == Z_FILTERED)) {\n                /* If prev_match is also WANT_MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                match_len = STD_MIN_MATCH - 1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s->prev_length >= STD_MIN_MATCH && match_len <= s->prev_length) {\n            unsigned int max_insert = s->strstart + s->lookahead - STD_MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n\n            Assert((s->strstart-1) <= UINT16_MAX, \"strstart-1 should fit in uint16_t\");\n            check_match(s, (Pos)(s->strstart - 1), s->prev_match, s->prev_length);\n\n            bflush = zng_tr_tally_dist(s, s->strstart -1 - s->prev_match, s->prev_length - STD_MIN_MATCH);\n\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             */\n            s->prev_length -= 1;\n            s->lookahead -= s->prev_length;\n\n            unsigned int mov_fwd = s->prev_length - 1;\n            if (max_insert > s->strstart) {\n                unsigned int insert_cnt = mov_fwd;\n                if (UNLIKELY(insert_cnt > max_insert - s->strstart))\n                    insert_cnt = max_insert - s->strstart;\n                s->insert_string(s, s->strstart + 1, insert_cnt);\n            }\n            s->prev_length = 0;\n            s->match_available = 0;\n            s->strstart += mov_fwd + 1;\n\n            if (UNLIKELY(bflush))\n                FLUSH_BLOCK(s, 0);\n\n        } else if (s->match_available) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            bflush = zng_tr_tally_lit(s, s->window[s->strstart-1]);\n            if (UNLIKELY(bflush))\n                FLUSH_BLOCK_ONLY(s, 0);\n            s->prev_length = match_len;\n            s->strstart++;\n            s->lookahead--;\n            if (UNLIKELY(s->strm->avail_out == 0))\n                return need_more;\n        } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            s->prev_length = match_len;\n            s->match_available = 1;\n            s->strstart++;\n            s->lookahead--;\n        }\n    }\n    Assert(flush != Z_NO_FLUSH, \"no flush?\");\n    if (UNLIKELY(s->match_available)) {\n        Z_UNUSED(zng_tr_tally_lit(s, s->window[s->strstart-1]));\n        s->match_available = 0;\n    }\n    s->insert = s->strstart < (STD_MIN_MATCH - 1) ? s->strstart : (STD_MIN_MATCH - 1);\n    if (UNLIKELY(flush == Z_FINISH)) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (UNLIKELY(s->sym_next))\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}\n"
        },
        {
          "name": "deflate_stored.c",
          "type": "blob",
          "size": 8.2265625,
          "content": "/* deflate_stored.c -- store data without compression using deflation algorithm\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"deflate_p.h\"\n#include \"functable.h\"\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunities to have a single copy from next_in to next_out.\n */\nZ_INTERNAL block_state deflate_stored(deflate_state *s, int flush) {\n    /* Smallest worthy block size when not flushing or finishing. By default\n     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n     * large input and output buffers, the stored block size will be larger.\n     */\n    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);\n\n    /* Copy as many min_block or larger stored blocks directly to next_out as\n     * possible. If flushing, copy the remaining available input to next_out as\n     * stored blocks, if there is enough space.\n     */\n    unsigned len, left, have, last = 0;\n    unsigned used = s->strm->avail_in;\n    do {\n        /* Set len to the maximum size block that we can copy directly with the\n         * available input data and output space. Set left to how much of that\n         * would be copied from what's left in the window.\n         */\n        len = MAX_STORED;       /* maximum deflate stored block length */\n        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */\n        if (s->strm->avail_out < have)          /* need room for header */\n            break;\n            /* maximum stored block length that will fit in avail_out: */\n        have = s->strm->avail_out - have;\n        left = (int)s->strstart - s->block_start;    /* bytes left in window */\n        if (len > (unsigned long)left + s->strm->avail_in)\n            len = left + s->strm->avail_in;     /* limit len to the input */\n        len = MIN(len, have);                   /* limit len to the output */\n\n        /* If the stored block would be less than min_block in length, or if\n         * unable to copy all of the available input when flushing, then try\n         * copying to the window and the pending buffer instead. Also don't\n         * write an empty block when flushing -- deflate() does that.\n         */\n        if (len < min_block && ((len == 0 && flush != Z_FINISH) || flush == Z_NO_FLUSH || len != left + s->strm->avail_in))\n            break;\n\n        /* Make a dummy stored block in pending to get the header bytes,\n         * including any pending bits. This also updates the debugging counts.\n         */\n        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;\n        zng_tr_stored_block(s, (char *)0, 0L, last);\n\n        /* Replace the lengths in the dummy stored block with len. */\n        s->pending -= 4;\n        put_short(s, (uint16_t)len);\n        put_short(s, (uint16_t)~len);\n\n        /* Write the stored block header bytes. */\n        PREFIX(flush_pending)(s->strm);\n\n        /* Update debugging counts for the data about to be copied. */\n        cmpr_bits_add(s, len << 3);\n        sent_bits_add(s, len << 3);\n\n        /* Copy uncompressed bytes from the window to next_out. */\n        if (left) {\n            left = MIN(left, len);\n            memcpy(s->strm->next_out, s->window + s->block_start, left);\n            s->strm->next_out += left;\n            s->strm->avail_out -= left;\n            s->strm->total_out += left;\n            s->block_start += (int)left;\n            len -= left;\n        }\n\n        /* Copy uncompressed bytes directly from next_in to next_out, updating\n         * the check value.\n         */\n        if (len) {\n            PREFIX(read_buf)(s->strm, s->strm->next_out, len);\n            s->strm->next_out += len;\n            s->strm->avail_out -= len;\n            s->strm->total_out += len;\n        }\n    } while (last == 0);\n\n    /* Update the sliding window with the last s->w_size bytes of the copied\n     * data, or append all of the copied data to the existing window if less\n     * than s->w_size bytes were copied. Also update the number of bytes to\n     * insert in the hash tables, in the event that deflateParams() switches to\n     * a non-zero compression level.\n     */\n    used -= s->strm->avail_in;      /* number of input bytes directly copied */\n    if (used) {\n        /* If any input was used, then no unused input remains in the window,\n         * therefore s->block_start == s->strstart.\n         */\n        if (used >= s->w_size) {    /* supplant the previous history */\n            s->matches = 2;         /* clear hash */\n            memcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n            s->strstart = s->w_size;\n            s->insert = s->strstart;\n        } else {\n            if (s->window_size - s->strstart <= used) {\n                /* Slide the window down. */\n                s->strstart -= s->w_size;\n                memcpy(s->window, s->window + s->w_size, s->strstart);\n                if (s->matches < 2)\n                    s->matches++;   /* add a pending slide_hash() */\n                s->insert = MIN(s->insert, s->strstart);\n            }\n            memcpy(s->window + s->strstart, s->strm->next_in - used, used);\n            s->strstart += used;\n            s->insert += MIN(used, s->w_size - s->insert);\n        }\n        s->block_start = (int)s->strstart;\n    }\n    s->high_water = MAX(s->high_water, s->strstart);\n\n    /* If the last block was written to next_out, then done. */\n    if (last)\n        return finish_done;\n\n    /* If flushing and all input has been consumed, then done. */\n    if (flush != Z_NO_FLUSH && flush != Z_FINISH && s->strm->avail_in == 0 && (int)s->strstart == s->block_start)\n        return block_done;\n\n    /* Fill the window with any remaining input. */\n    have = s->window_size - s->strstart;\n    if (s->strm->avail_in > have && s->block_start >= (int)s->w_size) {\n        /* Slide the window down. */\n        s->block_start -= (int)s->w_size;\n        s->strstart -= s->w_size;\n        memcpy(s->window, s->window + s->w_size, s->strstart);\n        if (s->matches < 2)\n            s->matches++;           /* add a pending slide_hash() */\n        have += s->w_size;          /* more space now */\n        s->insert = MIN(s->insert, s->strstart);\n    }\n\n    have = MIN(have, s->strm->avail_in);\n    if (have) {\n        PREFIX(read_buf)(s->strm, s->window + s->strstart, have);\n        s->strstart += have;\n        s->insert += MIN(have, s->w_size - s->insert);\n    }\n    s->high_water = MAX(s->high_water, s->strstart);\n\n    /* There was not enough avail_out to write a complete worthy or flushed\n     * stored block to next_out. Write a stored block to pending instead, if we\n     * have enough input for a worthy block, or if flushing and there is enough\n     * room for the remaining input as a stored block in the pending buffer.\n     */\n    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */\n        /* maximum stored block length that will fit in pending: */\n    have = MIN(s->pending_buf_size - have, MAX_STORED);\n    min_block = MIN(have, s->w_size);\n    left = (int)s->strstart - s->block_start;\n    if (left >= min_block || ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH && s->strm->avail_in == 0 && left <= have)) {\n        len = MIN(left, have);\n        last = flush == Z_FINISH && s->strm->avail_in == 0 && len == left ? 1 : 0;\n        zng_tr_stored_block(s, (char *)s->window + s->block_start, len, last);\n        s->block_start += (int)len;\n        PREFIX(flush_pending)(s->strm);\n    }\n\n    /* We've done all we can with the available input and output. */\n    return last ? finish_started : need_more;\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "fallback_builtins.h",
          "type": "blob",
          "size": 1.7734375,
          "content": "#ifndef FALLBACK_BUILTINS_H\n#define FALLBACK_BUILTINS_H\n\n#if defined(_MSC_VER) && !defined(__clang__)\n#if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64) ||  defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC)\n\n#include <intrin.h>\n\n/* This is not a general purpose replacement for __builtin_ctz. The function expects that value is != 0.\n * Because of that assumption trailing_zero is not initialized and the return value is not checked.\n * Tzcnt and bsf give identical results except when input value is 0, therefore this can not be allowed.\n * If tzcnt instruction is not supported, the cpu will itself execute bsf instead.\n * Performance tzcnt/bsf is identical on Intel cpu, tzcnt is faster than bsf on AMD cpu.\n */\nstatic __forceinline int __builtin_ctz(unsigned int value) {\n    Assert(value != 0, \"Invalid input value: 0\");\n# if defined(X86_FEATURES) && !(_MSC_VER < 1700)\n    return (int)_tzcnt_u32(value);\n# else\n    unsigned long trailing_zero;\n    _BitScanForward(&trailing_zero, value);\n    return (int)trailing_zero;\n# endif\n}\n#define HAVE_BUILTIN_CTZ\n\n#ifdef _M_AMD64\n/* This is not a general purpose replacement for __builtin_ctzll. The function expects that value is != 0.\n * Because of that assumption trailing_zero is not initialized and the return value is not checked.\n */\nstatic __forceinline int __builtin_ctzll(unsigned long long value) {\n    Assert(value != 0, \"Invalid input value: 0\");\n# if defined(X86_FEATURES) && !(_MSC_VER < 1700)\n    return (int)_tzcnt_u64(value);\n# else\n    unsigned long trailing_zero;\n    _BitScanForward64(&trailing_zero, value);\n    return (int)trailing_zero;\n# endif\n}\n#define HAVE_BUILTIN_CTZLL\n#endif // Microsoft AMD64\n\n#endif // Microsoft AMD64/IA64/x86/ARM/ARM64 test\n#endif // _MSC_VER & !clang\n\n#endif // include guard FALLBACK_BUILTINS_H\n"
        },
        {
          "name": "functable.c",
          "type": "blob",
          "size": 10.58984375,
          "content": "/* functable.c -- Choose relevant optimized functions at runtime\n * Copyright (C) 2017 Hans Kristian Rosbach\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n#ifndef DISABLE_RUNTIME_CPU_DETECTION\n\n#include \"zbuild.h\"\n\n#if defined(_MSC_VER)\n#  include <intrin.h>\n#endif\n\n#include \"functable.h\"\n#include \"cpu_features.h\"\n#include \"arch_functions.h\"\n\n/* Platform has pointer size atomic store */\n#if defined(__GNUC__) || defined(__clang__)\n#  define FUNCTABLE_ASSIGN(VAR, FUNC_NAME) \\\n    __atomic_store(&(functable.FUNC_NAME), &(VAR.FUNC_NAME), __ATOMIC_SEQ_CST)\n#  define FUNCTABLE_BARRIER() __atomic_thread_fence(__ATOMIC_SEQ_CST)\n#elif defined(_MSC_VER)\n#  define FUNCTABLE_ASSIGN(VAR, FUNC_NAME) \\\n    _InterlockedExchangePointer((void * volatile *)&(functable.FUNC_NAME), (void *)(VAR.FUNC_NAME))\n#  if defined(_M_ARM) || defined(_M_ARM64)\n#    define FUNCTABLE_BARRIER() do { \\\n    _ReadWriteBarrier();  \\\n    __dmb(0xB); /* _ARM_BARRIER_ISH */ \\\n    _ReadWriteBarrier(); \\\n} while (0)\n#  else\n#    define FUNCTABLE_BARRIER() _ReadWriteBarrier()\n#  endif\n#else\n#  warning Unable to detect atomic intrinsic support.\n#  define FUNCTABLE_ASSIGN(VAR, FUNC_NAME) \\\n    *((void * volatile *)&(functable.FUNC_NAME)) = (void *)(VAR.FUNC_NAME)\n#  define FUNCTABLE_BARRIER() do { /* Empty */ } while (0)\n#endif\n\nstatic void force_init_empty(void) {\n    // empty\n}\n\nstatic void init_functable(void) {\n    struct functable_s ft;\n    struct cpu_features cf;\n\n    cpu_check_features(&cf);\n\n    // Generic code\n    ft.force_init = &force_init_empty;\n    ft.adler32 = &adler32_c;\n    ft.adler32_fold_copy = &adler32_fold_copy_c;\n    ft.chunkmemset_safe = &chunkmemset_safe_c;\n    ft.chunksize = &chunksize_c;\n    ft.crc32 = &PREFIX(crc32_braid);\n    ft.crc32_fold = &crc32_fold_c;\n    ft.crc32_fold_copy = &crc32_fold_copy_c;\n    ft.crc32_fold_final = &crc32_fold_final_c;\n    ft.crc32_fold_reset = &crc32_fold_reset_c;\n    ft.inflate_fast = &inflate_fast_c;\n    ft.slide_hash = &slide_hash_c;\n    ft.longest_match = &longest_match_c;\n    ft.longest_match_slow = &longest_match_slow_c;\n    ft.compare256 = &compare256_c;\n\n    // Select arch-optimized functions\n\n    // X86 - SSE2\n#ifdef X86_SSE2\n#  if !defined(__x86_64__) && !defined(_M_X64) && !defined(X86_NOCHECK_SSE2)\n    if (cf.x86.has_sse2)\n#  endif\n    {\n        ft.chunkmemset_safe = &chunkmemset_safe_sse2;\n        ft.chunksize = &chunksize_sse2;\n        ft.inflate_fast = &inflate_fast_sse2;\n        ft.slide_hash = &slide_hash_sse2;\n#  ifdef HAVE_BUILTIN_CTZ\n        ft.compare256 = &compare256_sse2;\n        ft.longest_match = &longest_match_sse2;\n        ft.longest_match_slow = &longest_match_slow_sse2;\n#  endif\n    }\n#endif\n    // X86 - SSSE3\n#ifdef X86_SSSE3\n    if (cf.x86.has_ssse3) {\n        ft.adler32 = &adler32_ssse3;\n        ft.chunkmemset_safe = &chunkmemset_safe_ssse3;\n        ft.inflate_fast = &inflate_fast_ssse3;\n    }\n#endif\n    // X86 - SSE4.2\n#ifdef X86_SSE42\n    if (cf.x86.has_sse42) {\n        ft.adler32_fold_copy = &adler32_fold_copy_sse42;\n    }\n#endif\n    // X86 - PCLMUL\n#ifdef X86_PCLMULQDQ_CRC\n    if (cf.x86.has_pclmulqdq) {\n        ft.crc32 = &crc32_pclmulqdq;\n        ft.crc32_fold = &crc32_fold_pclmulqdq;\n        ft.crc32_fold_copy = &crc32_fold_pclmulqdq_copy;\n        ft.crc32_fold_final = &crc32_fold_pclmulqdq_final;\n        ft.crc32_fold_reset = &crc32_fold_pclmulqdq_reset;\n    }\n#endif\n    // X86 - AVX\n#ifdef X86_AVX2\n    /* BMI2 support is all but implicit with AVX2 but let's sanity check this just in case. Enabling BMI2 allows for\n     * flagless shifts, resulting in fewer flag stalls for the pipeline, and allows us to set destination registers\n     * for the shift results as an operand, eliminating several register-register moves when the original value needs\n     * to remain intact. They also allow for a count operand that isn't the CL register, avoiding contention there */\n    if (cf.x86.has_avx2 && cf.x86.has_bmi2) {\n        ft.adler32 = &adler32_avx2;\n        ft.adler32_fold_copy = &adler32_fold_copy_avx2;\n        ft.chunkmemset_safe = &chunkmemset_safe_avx2;\n        ft.chunksize = &chunksize_avx2;\n        ft.inflate_fast = &inflate_fast_avx2;\n        ft.slide_hash = &slide_hash_avx2;\n#  ifdef HAVE_BUILTIN_CTZ\n        ft.compare256 = &compare256_avx2;\n        ft.longest_match = &longest_match_avx2;\n        ft.longest_match_slow = &longest_match_slow_avx2;\n#  endif\n    }\n#endif\n    // X86 - AVX512 (F,DQ,BW,Vl)\n#ifdef X86_AVX512\n    if (cf.x86.has_avx512_common) {\n        ft.adler32 = &adler32_avx512;\n        ft.adler32_fold_copy = &adler32_fold_copy_avx512;\n        ft.chunkmemset_safe = &chunkmemset_safe_avx512;\n        ft.chunksize = &chunksize_avx512;\n        ft.inflate_fast = &inflate_fast_avx512;\n    }\n#endif\n#ifdef X86_AVX512VNNI\n    if (cf.x86.has_avx512vnni) {\n        ft.adler32 = &adler32_avx512_vnni;\n        ft.adler32_fold_copy = &adler32_fold_copy_avx512_vnni;\n    }\n#endif\n    // X86 - VPCLMULQDQ\n#ifdef X86_VPCLMULQDQ_CRC\n    if (cf.x86.has_pclmulqdq && cf.x86.has_avx512_common && cf.x86.has_vpclmulqdq) {\n        ft.crc32 = &crc32_vpclmulqdq;\n        ft.crc32_fold = &crc32_fold_vpclmulqdq;\n        ft.crc32_fold_copy = &crc32_fold_vpclmulqdq_copy;\n        ft.crc32_fold_final = &crc32_fold_vpclmulqdq_final;\n        ft.crc32_fold_reset = &crc32_fold_vpclmulqdq_reset;\n    }\n#endif\n\n\n    // ARM - SIMD\n#ifdef ARM_SIMD\n#  ifndef ARM_NOCHECK_SIMD\n    if (cf.arm.has_simd)\n#  endif\n    {\n        ft.slide_hash = &slide_hash_armv6;\n    }\n#endif\n    // ARM - NEON\n#ifdef ARM_NEON\n#  ifndef ARM_NOCHECK_NEON\n    if (cf.arm.has_neon)\n#  endif\n    {\n        ft.adler32 = &adler32_neon;\n        ft.chunkmemset_safe = &chunkmemset_safe_neon;\n        ft.chunksize = &chunksize_neon;\n        ft.inflate_fast = &inflate_fast_neon;\n        ft.slide_hash = &slide_hash_neon;\n#  ifdef HAVE_BUILTIN_CTZLL\n        ft.compare256 = &compare256_neon;\n        ft.longest_match = &longest_match_neon;\n        ft.longest_match_slow = &longest_match_slow_neon;\n#  endif\n    }\n#endif\n    // ARM - ACLE\n#ifdef ARM_ACLE\n    if (cf.arm.has_crc32) {\n        ft.crc32 = &crc32_acle;\n    }\n#endif\n\n\n    // Power - VMX\n#ifdef PPC_VMX\n    if (cf.power.has_altivec) {\n        ft.adler32 = &adler32_vmx;\n        ft.slide_hash = &slide_hash_vmx;\n    }\n#endif\n    // Power8 - VSX\n#ifdef POWER8_VSX\n    if (cf.power.has_arch_2_07) {\n        ft.adler32 = &adler32_power8;\n        ft.chunkmemset_safe = &chunkmemset_safe_power8;\n        ft.chunksize = &chunksize_power8;\n        ft.inflate_fast = &inflate_fast_power8;\n        ft.slide_hash = &slide_hash_power8;\n    }\n#endif\n#ifdef POWER8_VSX_CRC32\n    if (cf.power.has_arch_2_07)\n        ft.crc32 = &crc32_power8;\n#endif\n    // Power9\n#ifdef POWER9\n    if (cf.power.has_arch_3_00) {\n        ft.compare256 = &compare256_power9;\n        ft.longest_match = &longest_match_power9;\n        ft.longest_match_slow = &longest_match_slow_power9;\n    }\n#endif\n\n\n    // RISCV - RVV\n#ifdef RISCV_RVV\n    if (cf.riscv.has_rvv) {\n        ft.adler32 = &adler32_rvv;\n        ft.adler32_fold_copy = &adler32_fold_copy_rvv;\n        ft.chunkmemset_safe = &chunkmemset_safe_rvv;\n        ft.chunksize = &chunksize_rvv;\n        ft.compare256 = &compare256_rvv;\n        ft.inflate_fast = &inflate_fast_rvv;\n        ft.longest_match = &longest_match_rvv;\n        ft.longest_match_slow = &longest_match_slow_rvv;\n        ft.slide_hash = &slide_hash_rvv;\n    }\n#endif\n\n\n    // S390\n#ifdef S390_CRC32_VX\n    if (cf.s390.has_vx)\n        ft.crc32 = crc32_s390_vx;\n#endif\n\n    // Assign function pointers individually for atomic operation\n    FUNCTABLE_ASSIGN(ft, force_init);\n    FUNCTABLE_ASSIGN(ft, adler32);\n    FUNCTABLE_ASSIGN(ft, adler32_fold_copy);\n    FUNCTABLE_ASSIGN(ft, chunkmemset_safe);\n    FUNCTABLE_ASSIGN(ft, chunksize);\n    FUNCTABLE_ASSIGN(ft, compare256);\n    FUNCTABLE_ASSIGN(ft, crc32);\n    FUNCTABLE_ASSIGN(ft, crc32_fold);\n    FUNCTABLE_ASSIGN(ft, crc32_fold_copy);\n    FUNCTABLE_ASSIGN(ft, crc32_fold_final);\n    FUNCTABLE_ASSIGN(ft, crc32_fold_reset);\n    FUNCTABLE_ASSIGN(ft, inflate_fast);\n    FUNCTABLE_ASSIGN(ft, longest_match);\n    FUNCTABLE_ASSIGN(ft, longest_match_slow);\n    FUNCTABLE_ASSIGN(ft, slide_hash);\n\n    // Memory barrier for weak memory order CPUs\n    FUNCTABLE_BARRIER();\n}\n\n/* stub functions */\nstatic void force_init_stub(void) {\n    init_functable();\n}\n\nstatic uint32_t adler32_stub(uint32_t adler, const uint8_t* buf, size_t len) {\n    init_functable();\n    return functable.adler32(adler, buf, len);\n}\n\nstatic uint32_t adler32_fold_copy_stub(uint32_t adler, uint8_t* dst, const uint8_t* src, size_t len) {\n    init_functable();\n    return functable.adler32_fold_copy(adler, dst, src, len);\n}\n\nstatic uint8_t* chunkmemset_safe_stub(uint8_t* out, uint8_t *from, unsigned len, unsigned left) {\n    init_functable();\n    return functable.chunkmemset_safe(out, from, len, left);\n}\n\nstatic uint32_t chunksize_stub(void) {\n    init_functable();\n    return functable.chunksize();\n}\n\nstatic uint32_t compare256_stub(const uint8_t* src0, const uint8_t* src1) {\n    init_functable();\n    return functable.compare256(src0, src1);\n}\n\nstatic uint32_t crc32_stub(uint32_t crc, const uint8_t* buf, size_t len) {\n    init_functable();\n    return functable.crc32(crc, buf, len);\n}\n\nstatic void crc32_fold_stub(crc32_fold* crc, const uint8_t* src, size_t len, uint32_t init_crc) {\n    init_functable();\n    functable.crc32_fold(crc, src, len, init_crc);\n}\n\nstatic void crc32_fold_copy_stub(crc32_fold* crc, uint8_t* dst, const uint8_t* src, size_t len) {\n    init_functable();\n    functable.crc32_fold_copy(crc, dst, src, len);\n}\n\nstatic uint32_t crc32_fold_final_stub(crc32_fold* crc) {\n    init_functable();\n    return functable.crc32_fold_final(crc);\n}\n\nstatic uint32_t crc32_fold_reset_stub(crc32_fold* crc) {\n    init_functable();\n    return functable.crc32_fold_reset(crc);\n}\n\nstatic void inflate_fast_stub(PREFIX3(stream) *strm, uint32_t start) {\n    init_functable();\n    functable.inflate_fast(strm, start);\n}\n\nstatic uint32_t longest_match_stub(deflate_state* const s, Pos cur_match) {\n    init_functable();\n    return functable.longest_match(s, cur_match);\n}\n\nstatic uint32_t longest_match_slow_stub(deflate_state* const s, Pos cur_match) {\n    init_functable();\n    return functable.longest_match_slow(s, cur_match);\n}\n\nstatic void slide_hash_stub(deflate_state* s) {\n    init_functable();\n    functable.slide_hash(s);\n}\n\n/* functable init */\nZ_INTERNAL struct functable_s functable = {\n    force_init_stub,\n    adler32_stub,\n    adler32_fold_copy_stub,\n    chunkmemset_safe_stub,\n    chunksize_stub,\n    compare256_stub,\n    crc32_stub,\n    crc32_fold_stub,\n    crc32_fold_copy_stub,\n    crc32_fold_final_stub,\n    crc32_fold_reset_stub,\n    inflate_fast_stub,\n    longest_match_stub,\n    longest_match_slow_stub,\n    slide_hash_stub,\n};\n\n#endif\n"
        },
        {
          "name": "functable.h",
          "type": "blob",
          "size": 2.123046875,
          "content": "/* functable.h -- Struct containing function pointers to optimized functions\n * Copyright (C) 2017 Hans Kristian Rosbach\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef FUNCTABLE_H_\n#define FUNCTABLE_H_\n\n#include \"deflate.h\"\n#include \"crc32.h\"\n\n#ifdef DISABLE_RUNTIME_CPU_DETECTION\n\n#  include \"arch_functions.h\"\n\n/* When compiling with native instructions it is not necessary to use functable.\n * Instead we use native_ macro indicating the best available variant of arch-specific\n * functions for the current platform.\n */\n#  define FUNCTABLE_INIT ((void)0)\n#  define FUNCTABLE_CALL(name) native_ ## name\n#  define FUNCTABLE_FPTR(name) &native_ ## name\n\n#else\n\nstruct functable_s {\n    void     (* force_init)         (void);\n    uint32_t (* adler32)            (uint32_t adler, const uint8_t *buf, size_t len);\n    uint32_t (* adler32_fold_copy)  (uint32_t adler, uint8_t *dst, const uint8_t *src, size_t len);\n    uint8_t* (* chunkmemset_safe)   (uint8_t *out, uint8_t *from, unsigned len, unsigned left);\n    uint32_t (* chunksize)          (void);\n    uint32_t (* compare256)         (const uint8_t *src0, const uint8_t *src1);\n    uint32_t (* crc32)              (uint32_t crc, const uint8_t *buf, size_t len);\n    void     (* crc32_fold)         (struct crc32_fold_s *crc, const uint8_t *src, size_t len, uint32_t init_crc);\n    void     (* crc32_fold_copy)    (struct crc32_fold_s *crc, uint8_t *dst, const uint8_t *src, size_t len);\n    uint32_t (* crc32_fold_final)   (struct crc32_fold_s *crc);\n    uint32_t (* crc32_fold_reset)   (struct crc32_fold_s *crc);\n    void     (* inflate_fast)       (PREFIX3(stream) *strm, uint32_t start);\n    uint32_t (* longest_match)      (deflate_state *const s, Pos cur_match);\n    uint32_t (* longest_match_slow) (deflate_state *const s, Pos cur_match);\n    void     (* slide_hash)         (deflate_state *s);\n};\n\nZ_INTERNAL extern struct functable_s functable;\n\n\n/* Explicitly indicate functions are conditionally dispatched.\n */\n#  define FUNCTABLE_INIT functable.force_init()\n#  define FUNCTABLE_CALL(name) functable.name\n#  define FUNCTABLE_FPTR(name) functable.name\n\n#endif\n\n#endif\n"
        },
        {
          "name": "gzguts.h",
          "type": "blob",
          "size": 4.833984375,
          "content": "#ifndef GZGUTS_H_\n#define GZGUTS_H_\n/* gzguts.h -- zlib internal header definitions for gz* operations\n * Copyright (C) 2004-2024 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifdef _LARGEFILE64_SOURCE\n#  ifndef _LARGEFILE_SOURCE\n#    define _LARGEFILE_SOURCE 1\n#  endif\n#  undef _FILE_OFFSET_BITS\n#  undef _TIME_BITS\n#endif\n\n#if defined(HAVE_VISIBILITY_INTERNAL)\n#  define Z_INTERNAL __attribute__((visibility (\"internal\")))\n#elif defined(HAVE_VISIBILITY_HIDDEN)\n#  define Z_INTERNAL __attribute__((visibility (\"hidden\")))\n#else\n#  define Z_INTERNAL\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <fcntl.h>\n\n#if defined(ZLIB_COMPAT)\n#  include \"zlib.h\"\n#else\n#  include \"zlib-ng.h\"\n#endif\n\n#ifdef _WIN32\n#  include <stddef.h>\n#endif\n\n#if defined(_WIN32)\n#  include <io.h>\n#  define WIDECHAR\n#endif\n\n#ifdef WINAPI_FAMILY\n#  define open _open\n#  define read _read\n#  define write _write\n#  define close _close\n#endif\n\n/* In Win32, vsnprintf is available as the \"non-ANSI\" _vsnprintf. */\n#if !defined(STDC99) && !defined(__CYGWIN__) && !defined(__MINGW__) && defined(_WIN32)\n#  if !defined(vsnprintf)\n#    if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )\n#       define vsnprintf _vsnprintf\n#    endif\n#  endif\n#endif\n\n/* unlike snprintf (which is required in C99), _snprintf does not guarantee\n   null termination of the result -- however this is only used in gzlib.c\n   where the result is assured to fit in the space provided */\n#if defined(_MSC_VER) && _MSC_VER < 1900\n#  define snprintf _snprintf\n#endif\n\n/* get errno and strerror definition */\n#ifndef NO_STRERROR\n#  include <errno.h>\n#  define zstrerror() strerror(errno)\n#else\n#  define zstrerror() \"stdio error (consult errno)\"\n#endif\n\n/* default memLevel */\n#if MAX_MEM_LEVEL >= 8\n#  define DEF_MEM_LEVEL 8\n#else\n#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL\n#endif\n\n/* default i/o buffer size -- double this for output when reading (this and\n   twice this must be able to fit in an unsigned type) */\n#ifndef GZBUFSIZE\n#  define GZBUFSIZE 131072\n#endif\n\n/* gzip modes, also provide a little integrity check on the passed structure */\n#define GZ_NONE 0\n#define GZ_READ 7247\n#define GZ_WRITE 31153\n#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */\n\n/* values for gz_state how */\n#define LOOK 0      /* look for a gzip header */\n#define COPY 1      /* copy input directly */\n#define GZIP 2      /* decompress a gzip stream */\n\n/* internal gzip file state data structure */\ntypedef struct {\n        /* exposed contents for gzgetc() macro */\n    struct gzFile_s x;      /* \"x\" for exposed */\n                            /* x.have: number of bytes available at x.next */\n                            /* x.next: next output data to deliver or write */\n                            /* x.pos: current position in uncompressed data */\n        /* used for both reading and writing */\n    int mode;               /* see gzip modes above */\n    int fd;                 /* file descriptor */\n    char *path;             /* path or fd for error messages */\n    unsigned size;          /* buffer size, zero if not allocated yet */\n    unsigned want;          /* requested buffer size, default is GZBUFSIZE */\n    unsigned char *in;      /* input buffer (double-sized when writing) */\n    unsigned char *out;     /* output buffer (double-sized when reading) */\n    int direct;             /* 0 if processing gzip, 1 if transparent */\n        /* just for reading */\n    int how;                /* 0: get header, 1: copy, 2: decompress */\n    z_off64_t start;        /* where the gzip data started, for rewinding */\n    int eof;                /* true if end of input file reached */\n    int past;               /* true if read requested past end */\n        /* just for writing */\n    int level;              /* compression level */\n    int strategy;           /* compression strategy */\n    int reset;              /* true if a reset is pending after a Z_FINISH */\n        /* seek request */\n    z_off64_t skip;         /* amount to skip (already rewound if backwards) */\n    int seek;               /* true if seek request pending */\n        /* error information */\n    int err;                /* error code */\n    char *msg;              /* error message */\n        /* zlib inflate or deflate stream */\n    PREFIX3(stream) strm;  /* stream structure in-place (not a pointer) */\n} gz_state;\ntypedef gz_state *gz_statep;\n\n/* shared functions */\nvoid Z_INTERNAL gz_error(gz_state *, int, const char *);\n#ifdef ZLIB_COMPAT\nunsigned Z_INTERNAL gz_intmax(void);\n#endif\n/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t\n   value -- needed when comparing unsigned to z_off64_t, which is signed\n   (possible z_off64_t types off_t, off64_t, and long are all signed) */\n#define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)\n\n#endif /* GZGUTS_H_ */\n"
        },
        {
          "name": "gzlib.c",
          "type": "blob",
          "size": 14.5546875,
          "content": "/* gzlib.c -- zlib functions common to reading and writing gzip files\n * Copyright (C) 2004-2024 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil_p.h\"\n#include \"gzguts.h\"\n\n#if defined(_WIN32)\n#  define LSEEK _lseeki64\n#else\n#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0\n#  define LSEEK lseek64\n#else\n#  define LSEEK lseek\n#endif\n#endif\n\n/* Local functions */\nstatic void gz_reset(gz_state *);\nstatic gzFile gz_open(const void *, int, const char *);\n\n/* Reset gzip file state */\nstatic void gz_reset(gz_state *state) {\n    state->x.have = 0;              /* no output data available */\n    if (state->mode == GZ_READ) {   /* for reading ... */\n        state->eof = 0;             /* not at end of file */\n        state->past = 0;            /* have not read past end yet */\n        state->how = LOOK;          /* look for gzip header */\n    }\n    else                            /* for writing ... */\n        state->reset = 0;           /* no deflateReset pending */\n    state->seek = 0;                /* no seek request pending */\n    gz_error(state, Z_OK, NULL);    /* clear error */\n    state->x.pos = 0;               /* no uncompressed data yet */\n    state->strm.avail_in = 0;       /* no input data yet */\n}\n\n/* Open a gzip file either by name or file descriptor. */\nstatic gzFile gz_open(const void *path, int fd, const char *mode) {\n    gz_state *state;\n    size_t len;\n    int oflag;\n#ifdef O_CLOEXEC\n    int cloexec = 0;\n#endif\n#ifdef O_EXCL\n    int exclusive = 0;\n#endif\n\n    /* check input */\n    if (path == NULL)\n        return NULL;\n\n    /* allocate gzFile structure to return */\n    state = (gz_state *)zng_alloc(sizeof(gz_state));\n    if (state == NULL)\n        return NULL;\n    state->size = 0;            /* no buffers allocated yet */\n    state->want = GZBUFSIZE;    /* requested buffer size */\n    state->msg = NULL;          /* no error message yet */\n\n    /* interpret mode */\n    state->mode = GZ_NONE;\n    state->level = Z_DEFAULT_COMPRESSION;\n    state->strategy = Z_DEFAULT_STRATEGY;\n    state->direct = 0;\n    while (*mode) {\n        if (*mode >= '0' && *mode <= '9') {\n            state->level = *mode - '0';\n        } else {\n            switch (*mode) {\n            case 'r':\n                state->mode = GZ_READ;\n                break;\n#ifndef NO_GZCOMPRESS\n            case 'w':\n                state->mode = GZ_WRITE;\n                break;\n            case 'a':\n                state->mode = GZ_APPEND;\n                break;\n#endif\n            case '+':       /* can't read and write at the same time */\n                zng_free(state);\n                return NULL;\n            case 'b':       /* ignore -- will request binary anyway */\n                break;\n#ifdef O_CLOEXEC\n            case 'e':\n                cloexec = 1;\n                break;\n#endif\n#ifdef O_EXCL\n            case 'x':\n                exclusive = 1;\n                break;\n#endif\n            case 'f':\n                state->strategy = Z_FILTERED;\n                break;\n            case 'h':\n                state->strategy = Z_HUFFMAN_ONLY;\n                break;\n            case 'R':\n                state->strategy = Z_RLE;\n                break;\n            case 'F':\n                state->strategy = Z_FIXED;\n                break;\n            case 'T':\n                state->direct = 1;\n                break;\n            default:        /* could consider as an error, but just ignore */\n                {}\n            }\n        }\n        mode++;\n    }\n\n    /* must provide an \"r\", \"w\", or \"a\" */\n    if (state->mode == GZ_NONE) {\n        zng_free(state);\n        return NULL;\n    }\n\n    /* can't force transparent read */\n    if (state->mode == GZ_READ) {\n        if (state->direct) {\n            zng_free(state);\n            return NULL;\n        }\n        state->direct = 1;      /* for empty file */\n    }\n\n    /* save the path name for error messages */\n#ifdef WIDECHAR\n    if (fd == -2) {\n        len = wcstombs(NULL, (const wchar_t *)path, 0);\n        if (len == (size_t)-1)\n            len = 0;\n    } else\n#endif\n        len = strlen((const char *)path);\n    state->path = (char *)malloc(len + 1);\n    if (state->path == NULL) {\n        zng_free(state);\n        return NULL;\n    }\n#ifdef WIDECHAR\n    if (fd == -2)\n        if (len) {\n            wcstombs(state->path, (const wchar_t *)path, len + 1);\n        } else {\n            *(state->path) = 0;\n        }\n    else\n#endif\n        (void)snprintf(state->path, len + 1, \"%s\", (const char *)path);\n\n    /* compute the flags for open() */\n    oflag =\n#ifdef O_LARGEFILE\n        O_LARGEFILE |\n#endif\n#ifdef O_BINARY\n        O_BINARY |\n#endif\n#ifdef O_CLOEXEC\n        (cloexec ? O_CLOEXEC : 0) |\n#endif\n        (state->mode == GZ_READ ?\n         O_RDONLY :\n         (O_WRONLY | O_CREAT |\n#ifdef O_EXCL\n          (exclusive ? O_EXCL : 0) |\n#endif\n          (state->mode == GZ_WRITE ?\n           O_TRUNC :\n           O_APPEND)));\n\n    /* open the file with the appropriate flags (or just use fd) */\n    state->fd = fd > -1 ? fd : (\n#if defined(_WIN32)\n        fd == -2 ? _wopen((const wchar_t *)path, oflag, 0666) :\n#elif __CYGWIN__\n        fd == -2 ? open(state->path, oflag, 0666) :\n#endif\n        open((const char *)path, oflag, 0666));\n    if (state->fd == -1) {\n        free(state->path);\n        zng_free(state);\n        return NULL;\n    }\n    if (state->mode == GZ_APPEND) {\n        LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */\n        state->mode = GZ_WRITE;         /* simplify later checks */\n    }\n\n    /* save the current position for rewinding (only if reading) */\n    if (state->mode == GZ_READ) {\n        state->start = LSEEK(state->fd, 0, SEEK_CUR);\n        if (state->start == -1) state->start = 0;\n    }\n\n    /* initialize stream */\n    gz_reset(state);\n\n    /* return stream */\n    return (gzFile)state;\n}\n\n/* -- see zlib.h -- */\ngzFile Z_EXPORT PREFIX(gzopen)(const char *path, const char *mode) {\n    return gz_open(path, -1, mode);\n}\n\n#ifdef ZLIB_COMPAT\ngzFile Z_EXPORT PREFIX4(gzopen)(const char *path, const char *mode) {\n    return gz_open(path, -1, mode);\n}\n#endif\n\n/* -- see zlib.h -- */\ngzFile Z_EXPORT PREFIX(gzdopen)(int fd, const char *mode) {\n    char *path;         /* identifier for error messages */\n    gzFile gz;\n\n    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)\n        return NULL;\n    (void)snprintf(path, 7 + 3 * sizeof(int), \"<fd:%d>\", fd); /* for debugging */\n    gz = gz_open(path, fd, mode);\n    free(path);\n    return gz;\n}\n\n/* -- see zlib.h -- */\n#ifdef WIDECHAR\ngzFile Z_EXPORT PREFIX(gzopen_w)(const wchar_t *path, const char *mode) {\n    return gz_open(path, -2, mode);\n}\n#endif\n\nint Z_EXPORT PREFIX(gzclose)(gzFile file) {\n#ifndef NO_GZCOMPRESS\n    gz_state *state;\n\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_state *)file;\n\n    return state->mode == GZ_READ ? PREFIX(gzclose_r)(file) : PREFIX(gzclose_w)(file);\n#else\n    return PREFIX(gzclose_r)(file);\n#endif\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzbuffer)(gzFile file, unsigned size) {\n    gz_state *state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* make sure we haven't already allocated memory */\n    if (state->size != 0)\n        return -1;\n\n    /* check and set requested size */\n    if ((size << 1) < size)\n        return -1;              /* need to be able to double it */\n    if (size < 8)\n        size = 8;               /* needed to behave well with flushing */\n    state->want = size;\n    return 0;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzrewind)(gzFile file) {\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n\n    /* check that we're reading and that there's no error */\n    if (state->mode != GZ_READ || (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* back up and start over */\n    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)\n        return -1;\n    gz_reset(state);\n    return 0;\n}\n\n/* -- see zlib.h -- */\nz_off64_t Z_EXPORT PREFIX4(gzseek)(gzFile file, z_off64_t offset, int whence) {\n    unsigned n;\n    z_off64_t ret;\n    gz_state *state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* check that there's no error */\n    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n\n    /* can only seek from start or relative to current position */\n    if (whence != SEEK_SET && whence != SEEK_CUR)\n        return -1;\n\n    /* normalize offset to a SEEK_CUR specification */\n    if (whence == SEEK_SET)\n        offset -= state->x.pos;\n    else if (state->seek)\n        offset += state->skip;\n    state->seek = 0;\n\n    /* if within raw area while reading, just go there */\n    if (state->mode == GZ_READ && state->how == COPY && state->x.pos + offset >= 0) {\n        ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);\n        if (ret == -1)\n            return -1;\n        state->x.have = 0;\n        state->eof = 0;\n        state->past = 0;\n        state->seek = 0;\n        gz_error(state, Z_OK, NULL);\n        state->strm.avail_in = 0;\n        state->x.pos += offset;\n        return state->x.pos;\n    }\n\n    /* calculate skip amount, rewinding if needed for back seek when reading */\n    if (offset < 0) {\n        if (state->mode != GZ_READ)         /* writing -- can't go backwards */\n            return -1;\n        offset += state->x.pos;\n        if (offset < 0)                     /* before start of file! */\n            return -1;\n        if (PREFIX(gzrewind)(file) == -1)   /* rewind, then skip to offset */\n            return -1;\n    }\n\n    /* if reading, skip what's in output buffer (one less gzgetc() check) */\n    if (state->mode == GZ_READ) {\n        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ? (unsigned)offset : state->x.have;\n        state->x.have -= n;\n        state->x.next += n;\n        state->x.pos += n;\n        offset -= n;\n    }\n\n    /* request skip (if not zero) */\n    if (offset) {\n        state->seek = 1;\n        state->skip = offset;\n    }\n    return state->x.pos + offset;\n}\n\n/* -- see zlib.h -- */\n#ifdef ZLIB_COMPAT\nz_off_t Z_EXPORT PREFIX(gzseek)(gzFile file, z_off_t offset, int whence) {\n    z_off64_t ret;\n\n    ret = PREFIX4(gzseek)(file, (z_off64_t)offset, whence);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}\n#endif\n\n/* -- see zlib.h -- */\nz_off64_t Z_EXPORT PREFIX4(gztell)(gzFile file) {\n    gz_state *state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* return position */\n    return state->x.pos + (state->seek ? state->skip : 0);\n}\n\n/* -- see zlib.h -- */\n#ifdef ZLIB_COMPAT\nz_off_t Z_EXPORT PREFIX(gztell)(gzFile file) {\n\n    z_off64_t ret;\n\n    ret = PREFIX4(gztell)(file);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}\n#endif\n\n/* -- see zlib.h -- */\nz_off64_t Z_EXPORT PREFIX4(gzoffset)(gzFile file) {\n    z_off64_t offset;\n    gz_state *state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* compute and return effective offset in file */\n    offset = LSEEK(state->fd, 0, SEEK_CUR);\n    if (offset == -1)\n        return -1;\n    if (state->mode == GZ_READ)             /* reading */\n        offset -= state->strm.avail_in;     /* don't count buffered input */\n    return offset;\n}\n\n/* -- see zlib.h -- */\n#ifdef ZLIB_COMPAT\nz_off_t Z_EXPORT PREFIX(gzoffset)(gzFile file) {\n    z_off64_t ret;\n\n    ret = PREFIX4(gzoffset)(file);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}\n#endif\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzeof)(gzFile file) {\n    gz_state *state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return 0;\n    state = (gz_state *)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return 0;\n\n    /* return end-of-file state */\n    return state->mode == GZ_READ ? state->past : 0;\n}\n\n/* -- see zlib.h -- */\nconst char * Z_EXPORT PREFIX(gzerror)(gzFile file, int *errnum) {\n    gz_state *state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return NULL;\n    state = (gz_state *)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return NULL;\n\n    /* return error information */\n    if (errnum != NULL)\n        *errnum = state->err;\n    return state->err == Z_MEM_ERROR ? \"out of memory\" : (state->msg == NULL ? \"\" : state->msg);\n}\n\n/* -- see zlib.h -- */\nvoid Z_EXPORT PREFIX(gzclearerr)(gzFile file) {\n    gz_state *state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return;\n    state = (gz_state *)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return;\n\n    /* clear error and end-of-file */\n    if (state->mode == GZ_READ) {\n        state->eof = 0;\n        state->past = 0;\n    }\n    gz_error(state, Z_OK, NULL);\n}\n\n/* Create an error message in allocated memory and set state->err and\n   state->msg accordingly.  Free any previous error message already there.  Do\n   not try to free or allocate space if the error is Z_MEM_ERROR (out of\n   memory).  Simply save the error message as a static string.  If there is an\n   allocation failure constructing the error message, then convert the error to\n   out of memory. */\nvoid Z_INTERNAL gz_error(gz_state *state, int err, const char *msg) {\n    /* free previously allocated message and clear */\n    if (state->msg != NULL) {\n        if (state->err != Z_MEM_ERROR)\n            free(state->msg);\n        state->msg = NULL;\n    }\n\n    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */\n    if (err != Z_OK && err != Z_BUF_ERROR)\n        state->x.have = 0;\n\n    /* set error code, and if no message, then done */\n    state->err = err;\n    if (msg == NULL)\n        return;\n\n    /* for an out of memory error, return literal string when requested */\n    if (err == Z_MEM_ERROR)\n        return;\n\n    /* construct error message with path */\n    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {\n        state->err = Z_MEM_ERROR;\n        return;\n    }\n    (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3, \"%s%s%s\", state->path, \": \", msg);\n}\n\n#ifdef ZLIB_COMPAT\nunsigned Z_INTERNAL gz_intmax(void) {\n    return INT_MAX;\n}\n#endif\n"
        },
        {
          "name": "gzread.c.in",
          "type": "blob",
          "size": 20.0107421875,
          "content": "/* gzread.c -- zlib functions for reading gzip files\n * Copyright (C) 2004-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil_p.h\"\n#include \"gzguts.h\"\n\n/* Local functions */\nstatic int gz_load(gz_state *, unsigned char *, unsigned, unsigned *);\nstatic int gz_avail(gz_state *);\nstatic int gz_look(gz_state *);\nstatic int gz_decomp(gz_state *);\nstatic int gz_fetch(gz_state *);\nstatic int gz_skip(gz_state *, z_off64_t);\nstatic size_t gz_read(gz_state *, void *, size_t);\n\n/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from\n   state->fd, and update state->eof, state->err, and state->msg as appropriate.\n   This function needs to loop on read(), since read() is not guaranteed to\n   read the number of bytes requested, depending on the type of descriptor. */\nstatic int gz_load(gz_state *state, unsigned char *buf, unsigned len, unsigned *have) {\n    ssize_t ret;\n\n    *have = 0;\n    do {\n        ret = read(state->fd, buf + *have, len - *have);\n        if (ret <= 0)\n            break;\n        *have += (unsigned)ret;\n    } while (*have < len);\n    if (ret < 0) {\n        gz_error(state, Z_ERRNO, zstrerror());\n        return -1;\n    }\n    if (ret == 0)\n        state->eof = 1;\n    return 0;\n}\n\n/* Load up input buffer and set eof flag if last data loaded -- return -1 on\n   error, 0 otherwise.  Note that the eof flag is set when the end of the input\n   file is reached, even though there may be unused data in the buffer.  Once\n   that data has been used, no more attempts will be made to read the file.\n   If strm->avail_in != 0, then the current data is moved to the beginning of\n   the input buffer, and then the remainder of the buffer is loaded with the\n   available data from the input file. */\nstatic int gz_avail(gz_state *state) {\n    unsigned got;\n    PREFIX3(stream) *strm = &(state->strm);\n\n    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n    if (state->eof == 0) {\n        if (strm->avail_in) {       /* copy what's there to the start */\n            unsigned char *p = state->in;\n            unsigned const char *q = strm->next_in;\n            unsigned n = strm->avail_in;\n            do {\n                *p++ = *q++;\n            } while (--n);\n        }\n        if (gz_load(state, state->in + strm->avail_in, state->size - strm->avail_in, &got) == -1)\n            return -1;\n        strm->avail_in += got;\n        strm->next_in = state->in;\n    }\n    return 0;\n}\n\n/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.\n   If this is the first time in, allocate required memory.  state->how will be\n   left unchanged if there is no more input data available, will be set to COPY\n   if there is no gzip header and direct copying will be performed, or it will\n   be set to GZIP for decompression.  If direct copying, then leftover input\n   data from the input buffer will be copied to the output buffer.  In that\n   case, all further file reads will be directly to either the output buffer or\n   a user buffer.  If decompressing, the inflate state will be initialized.\n   gz_look() will return 0 on success or -1 on failure. */\nstatic int gz_look(gz_state *state) {\n    PREFIX3(stream) *strm = &(state->strm);\n\n    /* allocate read buffers and inflate memory */\n    if (state->size == 0) {\n        /* allocate buffers */\n        state->in = (unsigned char *)zng_alloc(state->want);\n        state->out = (unsigned char *)zng_alloc(state->want << 1);\n        if (state->in == NULL || state->out == NULL) {\n            zng_free(state->out);\n            zng_free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        state->size = state->want;\n\n        /* allocate inflate memory */\n        state->strm.zalloc = NULL;\n        state->strm.zfree = NULL;\n        state->strm.opaque = NULL;\n        state->strm.avail_in = 0;\n        state->strm.next_in = NULL;\n        if (PREFIX(inflateInit2)(&(state->strm), MAX_WBITS + 16) != Z_OK) {    /* gunzip */\n            zng_free(state->out);\n            zng_free(state->in);\n            state->size = 0;\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n    }\n\n    /* get at least the magic bytes in the input buffer */\n    if (strm->avail_in < 2) {\n        if (gz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0)\n            return 0;\n    }\n\n    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is\n       a logical dilemma here when considering the case of a partially written\n       gzip file, to wit, if a single 31 byte is written, then we cannot tell\n       whether this is a single-byte file, or just a partially written gzip\n       file -- for here we assume that if a gzip file is being written, then\n       the header will be written in a single operation, so that reading a\n       single byte is sufficient indication that it is not a gzip file) */\n    if (strm->avail_in > 1 &&\n            strm->next_in[0] == 31 && strm->next_in[1] == 139) {\n        PREFIX(inflateReset)(strm);\n        state->how = GZIP;\n        state->direct = 0;\n        return 0;\n    }\n\n    /* no gzip header -- if we were decoding gzip before, then this is trailing\n       garbage.  Ignore the trailing garbage and finish. */\n    if (state->direct == 0) {\n        strm->avail_in = 0;\n        state->eof = 1;\n        state->x.have = 0;\n        return 0;\n    }\n\n    /* doing raw i/o, copy any leftover input to output -- this assumes that\n       the output buffer is larger than the input buffer, which also assures\n       space for gzungetc() */\n    state->x.next = state->out;\n    memcpy(state->x.next, strm->next_in, strm->avail_in);\n    state->x.have = strm->avail_in;\n    strm->avail_in = 0;\n    state->how = COPY;\n    state->direct = 1;\n    return 0;\n}\n\n/* Decompress from input to the provided next_out and avail_out in the state.\n   On return, state->x.have and state->x.next point to the just decompressed\n   data.  If the gzip stream completes, state->how is reset to LOOK to look for\n   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0\n   on success, -1 on failure. */\nstatic int gz_decomp(gz_state *state) {\n    int ret = Z_OK;\n    unsigned had;\n    PREFIX3(stream) *strm = &(state->strm);\n\n    /* fill output buffer up to end of deflate stream */\n    had = strm->avail_out;\n    do {\n        /* get more input for inflate() */\n        if (strm->avail_in == 0 && gz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0) {\n            gz_error(state, Z_BUF_ERROR, \"unexpected end of file\");\n            break;\n        }\n\n        /* decompress and handle errors */\n        ret = PREFIX(inflate)(strm, Z_NO_FLUSH);\n        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n            gz_error(state, Z_STREAM_ERROR, \"internal error: inflate stream corrupt\");\n            return -1;\n        }\n        if (ret == Z_MEM_ERROR) {\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */\n            gz_error(state, Z_DATA_ERROR, strm->msg == NULL ? \"compressed data error\" : strm->msg);\n            return -1;\n        }\n    } while (strm->avail_out && ret != Z_STREAM_END);\n\n    /* update available output */\n    state->x.have = had - strm->avail_out;\n    state->x.next = strm->next_out - state->x.have;\n\n    /* if the gzip stream completed successfully, look for another */\n    if (ret == Z_STREAM_END)\n        state->how = LOOK;\n\n    /* good decompression */\n    return 0;\n}\n\n/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.\n   Data is either copied from the input file or decompressed from the input\n   file depending on state->how.  If state->how is LOOK, then a gzip header is\n   looked for to determine whether to copy or decompress.  Returns -1 on error,\n   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the\n   end of the input file has been reached and all data has been processed.  */\nstatic int gz_fetch(gz_state *state) {\n    PREFIX3(stream) *strm = &(state->strm);\n\n    do {\n        switch (state->how) {\n        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */\n            if (gz_look(state) == -1)\n                return -1;\n            if (state->how == LOOK)\n                return 0;\n            break;\n        case COPY:      /* -> COPY */\n            if (gz_load(state, state->out, state->size << 1, &(state->x.have))\n                    == -1)\n                return -1;\n            state->x.next = state->out;\n            return 0;\n        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */\n            strm->avail_out = state->size << 1;\n            strm->next_out = state->out;\n            if (gz_decomp(state) == -1)\n                return -1;\n        }\n    } while (state->x.have == 0 && (!state->eof || strm->avail_in));\n    return 0;\n}\n\n/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */\nstatic int gz_skip(gz_state *state, z_off64_t len) {\n    unsigned n;\n\n    /* skip over len bytes or reach end-of-file, whichever comes first */\n    while (len)\n        /* skip over whatever is in output buffer */\n        if (state->x.have) {\n            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?\n                (unsigned)len : state->x.have;\n            state->x.have -= n;\n            state->x.next += n;\n            state->x.pos += n;\n            len -= n;\n        } else if (state->eof && state->strm.avail_in == 0) {\n            /* output buffer empty -- return if we're at the end of the input */\n            break;\n        } else {\n            /* need more data to skip -- load up output buffer */\n            /* get more output, looking for header if required */\n            if (gz_fetch(state) == -1)\n                return -1;\n        }\n    return 0;\n}\n\n/* Read len bytes into buf from file, or less than len up to the end of the\n   input.  Return the number of bytes read.  If zero is returned, either the\n   end of file was reached, or there was an error.  state->err must be\n   consulted in that case to determine which. */\nstatic size_t gz_read(gz_state *state, void *buf, size_t len) {\n    size_t got;\n    unsigned n;\n\n    /* if len is zero, avoid unnecessary operations */\n    if (len == 0)\n        return 0;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* get len bytes to buf, or less than len if at the end */\n    got = 0;\n    do {\n        /* set n to the maximum amount of len that fits in an unsigned int */\n        n = (unsigned)-1;\n        if (n > len)\n            n = (unsigned)len;\n\n        /* first just try copying data from the output buffer */\n        if (state->x.have) {\n            if (state->x.have < n)\n                n = state->x.have;\n            memcpy(buf, state->x.next, n);\n            state->x.next += n;\n            state->x.have -= n;\n        }\n\n        /* output buffer empty -- return if we're at the end of the input */\n        else if (state->eof && state->strm.avail_in == 0) {\n            state->past = 1;        /* tried to read past end */\n            break;\n        }\n\n        /* need output data -- for small len or new stream load up our output\n           buffer */\n        else if (state->how == LOOK || n < (state->size << 1)) {\n            /* get more output, looking for header if required */\n            if (gz_fetch(state) == -1)\n                return 0;\n            continue;       /* no progress yet -- go back to copy above */\n            /* the copy above assures that we will leave with space in the\n               output buffer, allowing at least one gzungetc() to succeed */\n        }\n\n        /* large len -- read directly into user buffer */\n        else if (state->how == COPY) {      /* read directly */\n            if (gz_load(state, (unsigned char *)buf, n, &n) == -1)\n                return 0;\n        }\n\n        /* large len -- decompress directly into user buffer */\n        else {  /* state->how == GZIP */\n            state->strm.avail_out = n;\n            state->strm.next_out = (unsigned char *)buf;\n            if (gz_decomp(state) == -1)\n                return 0;\n            n = state->x.have;\n            state->x.have = 0;\n        }\n\n        /* update progress */\n        len -= n;\n        buf = (char *)buf + n;\n        got += n;\n        state->x.pos += n;\n    } while (len);\n\n    /* return number of bytes read into user buffer */\n    return got;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzread)(gzFile file, void *buf, unsigned len) {\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) */\n    if ((int)len < 0) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in an int\");\n        return -1;\n    }\n\n    /* read len or fewer bytes to buf */\n    len = (unsigned)gz_read(state, buf, len);\n\n    /* check for an error */\n    if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n\n    /* return the number of bytes read (this is assured to fit in an int) */\n    return (int)len;\n}\n\n/* -- see zlib.h -- */\nsize_t Z_EXPORT PREFIX(gzfread)(void *buf, size_t size, size_t nitems, gzFile file) {\n    size_t len;\n    gz_state *state;\n\n    /* Exit early if size is zero, also prevents potential division by zero */\n    if (size == 0)\n        return 0;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_state *)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return 0;\n\n    /* compute bytes to read -- error on overflow */\n    if (size && SIZE_MAX / size < nitems) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in a size_t\");\n        return 0;\n    }\n    len = nitems * size;\n\n    /* read len or fewer bytes to buf, return the number of full items read */\n    return len ? gz_read(state, buf, len) / size : 0;\n}\n\n/* -- see zlib.h -- */\n#undef @ZLIB_SYMBOL_PREFIX@gzgetc\n#undef @ZLIB_SYMBOL_PREFIX@zng_gzgetc\nint Z_EXPORT PREFIX(gzgetc)(gzFile file) {\n    unsigned char buf[1];\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ || (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* try output buffer (no need to check for skip request) */\n    if (state->x.have) {\n        state->x.have--;\n        state->x.pos++;\n        return *(state->x.next)++;\n    }\n\n    /* nothing there -- try gz_read() */\n    return gz_read(state, buf, 1) < 1 ? -1 : buf[0];\n}\n\n#ifdef ZLIB_COMPAT\nint Z_EXPORT PREFIX(gzgetc_)(gzFile file) {\n    return PREFIX(gzgetc)(file);\n}\n#endif\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzungetc)(int c, gzFile file) {\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n\n    /* in case this was just opened, set up the input buffer */\n    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n        (void)gz_look(state);\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ || (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return -1;\n    }\n\n    /* can't push EOF */\n    if (c < 0)\n        return -1;\n\n    /* if output buffer empty, put byte at end (allows more pushing) */\n    if (state->x.have == 0) {\n        state->x.have = 1;\n        state->x.next = state->out + (state->size << 1) - 1;\n        state->x.next[0] = (unsigned char)c;\n        state->x.pos--;\n        state->past = 0;\n        return c;\n    }\n\n    /* if no room, give up (must have already done a gzungetc()) */\n    if (state->x.have == (state->size << 1)) {\n        gz_error(state, Z_DATA_ERROR, \"out of room to push characters\");\n        return -1;\n    }\n\n    /* slide output data if needed and insert byte before existing data */\n    if (state->x.next == state->out) {\n        unsigned char *src = state->out + state->x.have;\n        unsigned char *dest = state->out + (state->size << 1);\n        while (src > state->out)\n            *--dest = *--src;\n        state->x.next = dest;\n    }\n    state->x.have++;\n    state->x.next--;\n    state->x.next[0] = (unsigned char)c;\n    state->x.pos--;\n    state->past = 0;\n    return c;\n}\n\n/* -- see zlib.h -- */\nchar * Z_EXPORT PREFIX(gzgets)(gzFile file, char *buf, int len) {\n    unsigned left, n;\n    char *str;\n    unsigned char *eol;\n    gz_state *state;\n\n    /* check parameters and get internal structure */\n    if (file == NULL || buf == NULL || len < 1)\n        return NULL;\n    state = (gz_state *)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ || (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return NULL;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return NULL;\n    }\n\n    /* copy output bytes up to new line or len - 1, whichever comes first --\n       append a terminating zero to the string (we don't check for a zero in\n       the contents, let the user worry about that) */\n    str = buf;\n    left = (unsigned)len - 1;\n    if (left) {\n        do {\n            /* assure that something is in the output buffer */\n            if (state->x.have == 0 && gz_fetch(state) == -1)\n                return NULL;                /* error */\n            if (state->x.have == 0) {       /* end of file */\n                state->past = 1;            /* read past end */\n                break;                      /* return what we have */\n            }\n\n            /* look for end-of-line in current output buffer */\n            n = state->x.have > left ? left : state->x.have;\n            eol = (unsigned char *)memchr(state->x.next, '\\n', n);\n            if (eol != NULL)\n                n = (unsigned)(eol - state->x.next) + 1;\n\n            /* copy through end-of-line, or remainder if not found */\n            memcpy(buf, state->x.next, n);\n            state->x.have -= n;\n            state->x.next += n;\n            state->x.pos += n;\n            left -= n;\n            buf += n;\n        } while (left && eol == NULL);\n    }\n\n    /* return terminated string, or if nothing, end of file */\n    if (buf == str)\n        return NULL;\n    buf[0] = 0;\n    return str;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzdirect)(gzFile file) {\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n\n    state = (gz_state *)file;\n\n    /* if the state is not known, but we can find out, then do so (this is\n       mainly for right after a gzopen() or gzdopen()) */\n    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n        (void)gz_look(state);\n\n    /* return 1 if transparent, 0 if processing a gzip stream */\n    return state->direct;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzclose_r)(gzFile file) {\n    int ret, err;\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n\n    state = (gz_state *)file;\n\n    /* check that we're reading */\n    if (state->mode != GZ_READ)\n        return Z_STREAM_ERROR;\n\n    /* free memory and close file */\n    if (state->size) {\n        PREFIX(inflateEnd)(&(state->strm));\n        zng_free(state->out);\n        zng_free(state->in);\n    }\n    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;\n    gz_error(state, Z_OK, NULL);\n    free(state->path);\n    ret = close(state->fd);\n    zng_free(state);\n    return ret ? Z_ERRNO : err;\n}\n"
        },
        {
          "name": "gzwrite.c",
          "type": "blob",
          "size": 15.720703125,
          "content": "/* gzwrite.c -- zlib functions for writing gzip files\n * Copyright (C) 2004-2019 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil_p.h\"\n#include <stdarg.h>\n#include \"gzguts.h\"\n\n/* Local functions */\nstatic int gz_init(gz_state *);\nstatic int gz_comp(gz_state *, int);\nstatic int gz_zero(gz_state *, z_off64_t);\nstatic size_t gz_write(gz_state *, void const *, size_t);\n\n/* Initialize state for writing a gzip file.  Mark initialization by setting\n   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on\n   success. */\nstatic int gz_init(gz_state *state) {\n    int ret;\n    PREFIX3(stream) *strm = &(state->strm);\n\n    /* allocate input buffer (double size for gzprintf) */\n    state->in = (unsigned char *)zng_alloc(state->want << 1);\n    if (state->in == NULL) {\n        gz_error(state, Z_MEM_ERROR, \"out of memory\");\n        return -1;\n    }\n    memset(state->in, 0, state->want << 1);\n\n    /* only need output buffer and deflate state if compressing */\n    if (!state->direct) {\n        /* allocate output buffer */\n        state->out = (unsigned char *)zng_alloc(state->want);\n        if (state->out == NULL) {\n            zng_free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n\n        /* allocate deflate memory, set up for gzip compression */\n        strm->zalloc = NULL;\n        strm->zfree = NULL;\n        strm->opaque = NULL;\n        ret = PREFIX(deflateInit2)(strm, state->level, Z_DEFLATED, MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);\n        if (ret != Z_OK) {\n            zng_free(state->out);\n            zng_free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        strm->next_in = NULL;\n    }\n\n    /* mark state as initialized */\n    state->size = state->want;\n\n    /* initialize write buffer if compressing */\n    if (!state->direct) {\n        strm->avail_out = state->size;\n        strm->next_out = state->out;\n        state->x.next = strm->next_out;\n    }\n    return 0;\n}\n\n/* Compress whatever is at avail_in and next_in and write to the output file.\n   Return -1 if there is an error writing to the output file or if gz_init()\n   fails to allocate memory, otherwise 0.  flush is assumed to be a valid\n   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is\n   reset to start a new gzip stream.  If gz->direct is true, then simply write\n   to the output file without compressing, and ignore flush. */\nstatic int gz_comp(gz_state *state, int flush) {\n    int ret;\n    ssize_t got;\n    unsigned have;\n    PREFIX3(stream) *strm = &(state->strm);\n\n    /* allocate memory if this is the first time through */\n    if (state->size == 0 && gz_init(state) == -1)\n        return -1;\n\n    /* write directly if requested */\n    if (state->direct) {\n        got = write(state->fd, strm->next_in, strm->avail_in);\n        if (got < 0 || (unsigned)got != strm->avail_in) {\n            gz_error(state, Z_ERRNO, zstrerror());\n            return -1;\n        }\n        strm->avail_in = 0;\n        return 0;\n    }\n\n    /* check for a pending reset */\n    if (state->reset) {\n        /* don't start a new gzip member unless there is data to write */\n        if (strm->avail_in == 0)\n            return 0;\n        PREFIX(deflateReset)(strm);\n        state->reset = 0;\n    }\n\n    /* run deflate() on provided input until it produces no more output */\n    ret = Z_OK;\n    do {\n        /* write out current buffer contents if full, or if flushing, but if\n           doing Z_FINISH then don't write until we get to Z_STREAM_END */\n        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH && (flush != Z_FINISH || ret == Z_STREAM_END))) {\n            have = (unsigned)(strm->next_out - state->x.next);\n            if (have && ((got = write(state->fd, state->x.next, (unsigned long)have)) < 0 || (unsigned)got != have)) {\n                gz_error(state, Z_ERRNO, zstrerror());\n                return -1;\n            }\n            if (strm->avail_out == 0) {\n                strm->avail_out = state->size;\n                strm->next_out = state->out;\n                state->x.next = state->out;\n            }\n            state->x.next = strm->next_out;\n        }\n\n        /* compress */\n        have = strm->avail_out;\n        ret = PREFIX(deflate)(strm, flush);\n        if (ret == Z_STREAM_ERROR) {\n            gz_error(state, Z_STREAM_ERROR, \"internal error: deflate stream corrupt\");\n            return -1;\n        }\n        have -= strm->avail_out;\n    } while (have);\n\n    /* if that completed a deflate stream, allow another to start */\n    if (flush == Z_FINISH)\n        state->reset = 1;\n    /* all done, no errors */\n    return 0;\n}\n\n/* Compress len zeros to output.  Return -1 on a write error or memory\n   allocation failure by gz_comp(), or 0 on success. */\nstatic int gz_zero(gz_state *state, z_off64_t len) {\n    int first;\n    unsigned n;\n    PREFIX3(stream) *strm = &(state->strm);\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return -1;\n\n    /* compress len zeros (len guaranteed > 0) */\n    first = 1;\n    while (len) {\n        n = GT_OFF(state->size) || (z_off64_t)state->size > len ? (unsigned)len : state->size;\n        if (first) {\n            memset(state->in, 0, n);\n            first = 0;\n        }\n        strm->avail_in = n;\n        strm->next_in = state->in;\n        state->x.pos += n;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return -1;\n        len -= n;\n    }\n    return 0;\n}\n\n/* Write len bytes from buf to file.  Return the number of bytes written.  If\n   the returned value is less than len, then there was an error. */\nstatic size_t gz_write(gz_state *state, void const *buf, size_t len) {\n    size_t put = len;\n\n    /* if len is zero, avoid unnecessary operations */\n    if (len == 0)\n        return 0;\n\n    /* allocate memory if this is the first time through */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* for small len, copy to input buffer, otherwise compress directly */\n    if (len < state->size) {\n        /* copy to input buffer, compress when full */\n        do {\n            unsigned have, copy;\n\n            if (state->strm.avail_in == 0)\n                state->strm.next_in = state->in;\n            have = (unsigned)((state->strm.next_in + state->strm.avail_in) -\n                              state->in);\n            copy = state->size - have;\n            if (copy > len)\n                copy = (unsigned)len;\n            memcpy(state->in + have, buf, copy);\n            state->strm.avail_in += copy;\n            state->x.pos += copy;\n            buf = (const char *)buf + copy;\n            len -= copy;\n            if (len && gz_comp(state, Z_NO_FLUSH) == -1)\n                return 0;\n        } while (len);\n    } else {\n        /* consume whatever's left in the input buffer */\n        if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n            return 0;\n\n        /* directly compress user buffer to file */\n        state->strm.next_in = (z_const unsigned char *) buf;\n        do {\n            unsigned n = (unsigned)-1;\n            if (n > len)\n                n = (unsigned)len;\n            state->strm.avail_in = n;\n            state->x.pos += n;\n            if (gz_comp(state, Z_NO_FLUSH) == -1)\n                return 0;\n            len -= n;\n        } while (len);\n    }\n\n    /* input was all buffered or compressed */\n    return put;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzwrite)(gzFile file, void const *buf, unsigned len) {\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_state *)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) */\n    if ((int)len < 0) {\n        gz_error(state, Z_DATA_ERROR, \"requested length does not fit in int\");\n        return 0;\n    }\n\n    /* write len bytes from buf (the return value will fit in an int) */\n    return (int)gz_write(state, buf, len);\n}\n\n/* -- see zlib.h -- */\nsize_t Z_EXPORT PREFIX(gzfwrite)(void const *buf, size_t size, size_t nitems, gzFile file) {\n    size_t len;\n    gz_state *state;\n\n    /* Exit early if size is zero, also prevents potential division by zero */\n    if (size == 0)\n        return 0;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_state *)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* compute bytes to read -- error on overflow */\n    len = nitems * size;\n    if (len / size != nitems) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in a size_t\");\n        return 0;\n    }\n\n    /* write len bytes to buf, return the number of full items written */\n    return len ? gz_write(state, buf, len) / size : 0;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzputc)(gzFile file, int c) {\n    unsigned have;\n    unsigned char buf[1];\n    gz_state *state;\n    PREFIX3(stream) *strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return -1;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return -1;\n    }\n\n    /* try writing to input buffer for speed (state->size == 0 if buffer not\n       initialized) */\n    if (state->size) {\n        if (strm->avail_in == 0)\n            strm->next_in = state->in;\n        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);\n        if (have < state->size) {\n            state->in[have] = (unsigned char)c;\n            strm->avail_in++;\n            state->x.pos++;\n            return c & 0xff;\n        }\n    }\n\n    /* no room in buffer or not initialized, use gz_write() */\n    buf[0] = (unsigned char)c;\n    if (gz_write(state, buf, 1) != 1)\n        return -1;\n    return c & 0xff;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzputs)(gzFile file, const char *s) {\n    size_t len, put;\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_state *)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return -1;\n\n    /* write string */\n    len = strlen(s);\n    if ((int)len < 0 || (unsigned)len != len) {\n        gz_error(state, Z_STREAM_ERROR, \"string length does not fit in int\");\n        return -1;\n    }\n    put = gz_write(state, s, len);\n    return put < len ? -1 : (int)len;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORTVA PREFIX(gzvprintf)(gzFile file, const char *format, va_list va) {\n    int len;\n    unsigned left;\n    char *next;\n    gz_state *state;\n    PREFIX3(stream) *strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_state *)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n    len = vsnprintf(next, state->size, format, va);\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memmove(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}\n\nint Z_EXPORTVA PREFIX(gzprintf)(gzFile file, const char *format, ...) {\n    va_list va;\n    int ret;\n\n    va_start(va, format);\n    ret = PREFIX(gzvprintf)(file, format, va);\n    va_end(va);\n    return ret;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzflush)(gzFile file, int flush) {\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_state *)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* check flush parameter */\n    if (flush < 0 || flush > Z_FINISH)\n        return Z_STREAM_ERROR;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* compress remaining data with requested flush */\n    (void)gz_comp(state, flush);\n    return state->err;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzsetparams)(gzFile file, int level, int strategy) {\n    gz_state *state;\n    PREFIX3(stream) *strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_state *)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK || state->direct)\n        return Z_STREAM_ERROR;\n\n    /* if no change is requested, then do nothing */\n    if (level == state->level && strategy == state->strategy)\n        return Z_OK;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* change compression parameters for subsequent input */\n    if (state->size) {\n        /* flush previous input with previous parameters before changing */\n        if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)\n            return state->err;\n        PREFIX(deflateParams)(strm, level, strategy);\n    }\n    state->level = level;\n    state->strategy = strategy;\n    return Z_OK;\n}\n\n/* -- see zlib.h -- */\nint Z_EXPORT PREFIX(gzclose_w)(gzFile file) {\n    int ret = Z_OK;\n    gz_state *state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_state *)file;\n\n    /* check that we're writing */\n    if (state->mode != GZ_WRITE)\n        return Z_STREAM_ERROR;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            ret = state->err;\n    }\n\n    /* flush, free memory, and close file */\n    if (gz_comp(state, Z_FINISH) == -1)\n        ret = state->err;\n    if (state->size) {\n        if (!state->direct) {\n            (void)PREFIX(deflateEnd)(&(state->strm));\n            zng_free(state->out);\n        }\n        zng_free(state->in);\n    }\n    gz_error(state, Z_OK, NULL);\n    free(state->path);\n    if (close(state->fd) == -1)\n        ret = Z_ERRNO;\n    zng_free(state);\n    return ret;\n}\n"
        },
        {
          "name": "infback.c",
          "type": "blob",
          "size": 18.75390625,
          "content": "/* infback.c -- inflate using a call-back interface\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n   This code is largely copied from inflate.c.  Normally either infback.o or\n   inflate.o would be linked into an application--not both.  The interface\n   with inffast.c is retained so that optimized assembler-coded versions of\n   inflate_fast() can be used with either inflate.c or infback.c.\n */\n\n#include \"zbuild.h\"\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inflate_p.h\"\n#include \"functable.h\"\n\n/* Avoid conflicts with zlib.h macros */\n#ifdef ZLIB_COMPAT\n# undef inflateBackInit\n#endif\n\n/*\n   strm provides memory allocation functions in zalloc and zfree, or\n   NULL to use the library memory allocation functions.\n\n   windowBits is in the range 8..15, and window is a user-supplied\n   window and output buffer that is 2**windowBits bytes.\n\n   This function is hidden in ZLIB_COMPAT builds.\n */\nint32_t ZNG_CONDEXPORT PREFIX(inflateBackInit)(PREFIX3(stream) *strm, int32_t windowBits, uint8_t *window) {\n    struct inflate_state *state;\n\n    if (strm == NULL || window == NULL || windowBits < MIN_WBITS || windowBits > MAX_WBITS)\n        return Z_STREAM_ERROR;\n    strm->msg = NULL;                   /* in case we return an error */\n    if (strm->zalloc == NULL) {\n        strm->zalloc = PREFIX(zcalloc);\n        strm->opaque = NULL;\n    }\n    if (strm->zfree == NULL)\n        strm->zfree = PREFIX(zcfree);\n\n    inflate_allocs *alloc_bufs = alloc_inflate(strm);\n    if (alloc_bufs == NULL)\n        return Z_MEM_ERROR;\n\n    state = alloc_bufs->state;\n    state->alloc_bufs = alloc_bufs;\n    Tracev((stderr, \"inflate: allocated\\n\"));\n\n    strm->state = (struct internal_state *)state;\n    state->wbits = (unsigned int)windowBits;\n    state->wsize = 1U << windowBits;\n    state->wbufsize = 1U << windowBits;\n    state->window = window;\n    state->wnext = 0;\n    state->whave = 0;\n    state->chunksize = FUNCTABLE_CALL(chunksize)();\n#ifdef INFLATE_STRICT\n    state->dmax = 32768U;\n#endif\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    state->sane = 1;\n#endif\n    return Z_OK;\n}\n\n/* Function used by zlib.h and zlib-ng version 2.0 macros */\nint32_t Z_EXPORT PREFIX(inflateBackInit_)(PREFIX3(stream) *strm, int32_t windowBits, uint8_t *window,\n                              const char *version, int32_t stream_size) {\n    if (CHECK_VER_STSIZE(version, stream_size))\n        return Z_VERSION_ERROR;\n    return PREFIX(inflateBackInit)(strm, windowBits, window);\n}\n\n/*\n   Private macros for inflateBack()\n   Look in inflate_p.h for macros shared with inflate()\n*/\n\n/* Assure that some input is available.  If input is requested, but denied,\n   then return a Z_BUF_ERROR from inflateBack(). */\n#define PULL() \\\n    do { \\\n        if (have == 0) { \\\n            have = in(in_desc, &next); \\\n            if (have == 0) { \\\n                next = NULL; \\\n                ret = Z_BUF_ERROR; \\\n                goto inf_leave; \\\n            } \\\n        } \\\n    } while (0)\n\n/* Get a byte of input into the bit accumulator, or return from inflateBack()\n   with an error if there is no input available. */\n#define PULLBYTE() \\\n    do { \\\n        PULL(); \\\n        have--; \\\n        hold += ((unsigned)(*next++) << bits); \\\n        bits += 8; \\\n    } while (0)\n\n/* Assure that some output space is available, by writing out the window\n   if it's full.  If the write fails, return from inflateBack() with a\n   Z_BUF_ERROR. */\n#define ROOM() \\\n    do { \\\n        if (left == 0) { \\\n            put = state->window; \\\n            left = state->wsize; \\\n            state->whave = left; \\\n            if (out(out_desc, put, left)) { \\\n                ret = Z_BUF_ERROR; \\\n                goto inf_leave; \\\n            } \\\n        } \\\n    } while (0)\n\n/*\n   strm provides the memory allocation functions and window buffer on input,\n   and provides information on the unused input on return.  For Z_DATA_ERROR\n   returns, strm will also provide an error message.\n\n   in() and out() are the call-back input and output functions.  When\n   inflateBack() needs more input, it calls in().  When inflateBack() has\n   filled the window with output, or when it completes with data in the\n   window, it calls out() to write out the data.  The application must not\n   change the provided input until in() is called again or inflateBack()\n   returns.  The application must not change the window/output buffer until\n   inflateBack() returns.\n\n   in() and out() are called with a descriptor parameter provided in the\n   inflateBack() call.  This parameter can be a structure that provides the\n   information required to do the read or write, as well as accumulated\n   information on the input and output such as totals and check values.\n\n   in() should return zero on failure.  out() should return non-zero on\n   failure.  If either in() or out() fails, than inflateBack() returns a\n   Z_BUF_ERROR.  strm->next_in can be checked for NULL to see whether it\n   was in() or out() that caused in the error.  Otherwise, inflateBack()\n   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format\n   error, or Z_MEM_ERROR if it could not allocate memory for the state.\n   inflateBack() can also return Z_STREAM_ERROR if the input parameters\n   are not correct, i.e. strm is NULL or the state was not initialized.\n */\nint32_t Z_EXPORT PREFIX(inflateBack)(PREFIX3(stream) *strm, in_func in, void *in_desc, out_func out, void *out_desc) {\n    struct inflate_state *state;\n    z_const unsigned char *next; /* next input */\n    unsigned char *put;          /* next output */\n    unsigned have, left;         /* available input and output */\n    uint32_t hold;               /* bit buffer */\n    unsigned bits;               /* bits in bit buffer */\n    unsigned copy;               /* number of stored or match bytes to copy */\n    unsigned char *from;         /* where to copy match bytes from */\n    code here;                   /* current decoding table entry */\n    code last;                   /* parent table entry */\n    unsigned len;                /* length to copy for repeats, bits to drop */\n    int32_t ret;                 /* return code */\n    static const uint16_t order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* Check that the strm exists and that the state was initialized */\n    if (strm == NULL || strm->state == NULL)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n\n    /* Reset the state */\n    strm->msg = NULL;\n    state->mode = TYPE;\n    state->last = 0;\n    state->whave = 0;\n    next = strm->next_in;\n    have = next != NULL ? strm->avail_in : 0;\n    hold = 0;\n    bits = 0;\n    put = state->window;\n    left = state->wsize;\n\n    /* Inflate until end of block marked as last */\n    for (;;)\n        switch (state->mode) {\n        case TYPE:\n            /* determine and dispatch block type */\n            if (state->last) {\n                BYTEBITS();\n                state->mode = DONE;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\", state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                PREFIX(fixedtables)(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\", state->last ? \" (last)\" : \"\"));\n                state->mode = LEN;              /* decode codes */\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\", state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                SET_BAD(\"invalid block type\");\n            }\n            DROPBITS(2);\n            break;\n\n        case STORED:\n            /* get and verify stored block length */\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                SET_BAD(\"invalid stored block lengths\");\n                break;\n            }\n            state->length = (uint16_t)hold;\n            Tracev((stderr, \"inflate:       stored length %u\\n\", state->length));\n            INITBITS();\n\n            /* copy stored block from input to output */\n            while (state->length != 0) {\n                copy = state->length;\n                PULL();\n                ROOM();\n                copy = MIN(copy, have);\n                copy = MIN(copy, left);\n                memcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n\n        case TABLE:\n            /* get dynamic table entries descriptor */\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                SET_BAD(\"too many length or distance symbols\");\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n\n            /* get code length code lengths (not a typo) */\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (uint16_t)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (const code *)(state->next);\n            state->lenbits = 7;\n            ret = zng_inflate_table(CODES, state->lens, 19, &(state->next), &(state->lenbits), state->work);\n            if (ret) {\n                SET_BAD(\"invalid code lengths set\");\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n\n            /* get length and distance code code lengths */\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if (here.bits <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                } else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            SET_BAD(\"invalid bit length repeat\");\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    } else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    } else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        SET_BAD(\"invalid bit length repeat\");\n                        break;\n                    }\n                    while (copy) {\n                        --copy;\n                        state->lens[state->have++] = (uint16_t)len;\n                    }\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD)\n                break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                SET_BAD(\"invalid code -- missing end-of-block\");\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (10 and 9) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code *)(state->next);\n            state->lenbits = 10;\n            ret = zng_inflate_table(LENS, state->lens, state->nlen, &(state->next), &(state->lenbits), state->work);\n            if (ret) {\n                SET_BAD(\"invalid literal/lengths set\");\n                break;\n            }\n            state->distcode = (const code *)(state->next);\n            state->distbits = 9;\n            ret = zng_inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                                &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                SET_BAD(\"invalid distances set\");\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN;\n            Z_FALLTHROUGH;\n\n        case LEN:\n            /* use inflate_fast() if we have enough input and output */\n            if (have >= INFLATE_FAST_MIN_HAVE &&\n                left >= INFLATE_FAST_MIN_LEFT) {\n                RESTORE();\n                if (state->whave < state->wsize)\n                    state->whave = state->wsize - left;\n                FUNCTABLE_CALL(inflate_fast)(strm, state->wsize);\n                LOAD();\n                break;\n            }\n\n            /* get a literal, length, or end-of-block code */\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if (here.bits <= bits)\n                    break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val + (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)last.bits + (unsigned)here.bits <= bits)\n                        break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            state->length = here.val;\n\n            /* process literal */\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                ROOM();\n                *put++ = (unsigned char)(state->length);\n                left--;\n                state->mode = LEN;\n                break;\n            }\n\n            /* process end of block */\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->mode = TYPE;\n                break;\n            }\n\n            /* invalid code */\n            if (here.op & 64) {\n                SET_BAD(\"invalid literal/length code\");\n                break;\n            }\n\n            /* length code -- get extra bits, if any */\n            state->extra = (here.op & MAX_BITS);\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n\n            /* get distance code */\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if (here.bits <= bits)\n                    break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val + (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)last.bits + (unsigned)here.bits <= bits)\n                        break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            if (here.op & 64) {\n                SET_BAD(\"invalid distance code\");\n                break;\n            }\n            state->offset = here.val;\n            state->extra = (here.op & MAX_BITS);\n\n            /* get distance extra bits, if any */\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->wsize - (state->whave < state->wsize ? left : 0)) {\n                SET_BAD(\"invalid distance too far back\");\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n\n            /* copy match from window to output */\n            do {\n                ROOM();\n                copy = state->wsize - state->offset;\n                if (copy < left) {\n                    from = put + copy;\n                    copy = left - copy;\n                } else {\n                    from = put - state->offset;\n                    copy = left;\n                }\n                copy = MIN(copy, state->length);\n                state->length -= copy;\n                left -= copy;\n                do {\n                    *put++ = *from++;\n                } while (--copy);\n            } while (state->length != 0);\n            break;\n\n        case DONE:\n            /* inflate stream terminated properly */\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\n        default:                /* can't happen, but makes compilers happy */\n            ret = Z_STREAM_ERROR;\n            goto inf_leave;\n        }\n\n    /* Write leftover output and return unused input */\n  inf_leave:\n    if (left < state->wsize) {\n        if (out(out_desc, state->window, state->wsize - left) && (ret == Z_STREAM_END)) {\n            ret = Z_BUF_ERROR;\n        }\n    }\n    strm->next_in = next;\n    strm->avail_in = have;\n    return ret;\n}\n\nint32_t Z_EXPORT PREFIX(inflateBackEnd)(PREFIX3(stream) *strm) {\n    if (strm == NULL || strm->state == NULL || strm->zfree == NULL)\n        return Z_STREAM_ERROR;\n\n    /* Free allocated buffers */\n    free_inflate(strm);\n\n    Tracev((stderr, \"inflate: end\\n\"));\n    return Z_OK;\n}\n"
        },
        {
          "name": "inffast_tpl.h",
          "type": "blob",
          "size": 14.5693359375,
          "content": "/* inffast.c -- fast decoding\n * Copyright (C) 1995-2017 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zendian.h\"\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inflate_p.h\"\n#include \"functable.h\"\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state->mode == LEN\n        strm->avail_in >= INFLATE_FAST_MIN_HAVE\n        strm->avail_out >= INFLATE_FAST_MIN_LEFT\n        start >= strm->avail_out\n        state->bits < 8\n\n   On return, state->mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm->avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - On some architectures, it can be significantly faster (e.g. up to 1.2x\n      faster on x86_64) to load from strm->next_in 64 bits, or 8 bytes, at a\n      time, so INFLATE_FAST_MIN_HAVE == 8.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm->avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvoid Z_INTERNAL INFLATE_FAST(PREFIX3(stream) *strm, uint32_t start) {\n    /* start: inflate()'s starting value for strm->avail_out */\n    struct inflate_state *state;\n    z_const unsigned char *in;  /* local strm->next_in */\n    const unsigned char *last;  /* have enough input while in < last */\n    unsigned char *out;         /* local strm->next_out */\n    unsigned char *beg;         /* inflate()'s initial strm->next_out */\n    unsigned char *end;         /* while out < end, enough space available */\n    unsigned char *safe;        /* can use chunkcopy provided out < safe */\n    unsigned char *window;      /* allocated sliding window, if wsize != 0 */\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n\n    /* hold is a local copy of strm->hold. By default, hold satisfies the same\n       invariants that strm->hold does, namely that (hold >> bits) == 0. This\n       invariant is kept by loading bits into hold one byte at a time, like:\n\n       hold |= next_byte_of_input << bits; in++; bits += 8;\n\n       If we need to ensure that bits >= 15 then this code snippet is simply\n       repeated. Over one iteration of the outermost do/while loop, this\n       happens up to six times (48 bits of input), as described in the NOTES\n       above.\n\n       However, on some little endian architectures, it can be significantly\n       faster to load 64 bits once instead of 8 bits six times:\n\n       if (bits <= 16) {\n         hold |= next_8_bytes_of_input << bits; in += 6; bits += 48;\n       }\n\n       Unlike the simpler one byte load, shifting the next_8_bytes_of_input\n       by bits will overflow and lose those high bits, up to 2 bytes' worth.\n       The conservative estimate is therefore that we have read only 6 bytes\n       (48 bits). Again, as per the NOTES above, 48 bits is sufficient for the\n       rest of the iteration, and we will not need to load another 8 bytes.\n\n       Inside this function, we no longer satisfy (hold >> bits) == 0, but\n       this is not problematic, even if that overflow does not land on an 8 bit\n       byte boundary. Those excess bits will eventually shift down lower as the\n       Huffman decoder consumes input, and when new input bits need to be loaded\n       into the bits variable, the same input bits will be or'ed over those\n       existing bits. A bitwise or is idempotent: (a | b | b) equals (a | b).\n       Note that we therefore write that load operation as \"hold |= etc\" and not\n       \"hold += etc\".\n\n       Outside that loop, at the end of the function, hold is bitwise and'ed\n       with (1<<bits)-1 to drop those excess bits so that, on function exit, we\n       keep the invariant that (state->hold >> state->bits) == 0.\n    */\n    unsigned bits;              /* local strm->bits */\n    uint64_t hold;              /* local strm->hold */\n    unsigned lmask;             /* mask for first level of length codes */\n    unsigned dmask;             /* mask for first level of distance codes */\n    code const *lcode;          /* local strm->lencode */\n    code const *dcode;          /* local strm->distcode */\n    const code *here;           /* retrieved table entry */\n    unsigned op;                /* code bits, operation, extra bits, or */\n                                /*  window position, window bytes to copy */\n    unsigned len;               /* match length, unused bytes */\n    unsigned char *from;        /* where to copy match from */\n    unsigned dist;              /* match distance */\n    unsigned extra_safe;        /* copy chunks safely in all cases */\n\n    /* copy state to local variables */\n    state = (struct inflate_state *)strm->state;\n    in = strm->next_in;\n    last = in + (strm->avail_in - (INFLATE_FAST_MIN_HAVE - 1));\n    out = strm->next_out;\n    beg = out - (start - strm->avail_out);\n    end = out + (strm->avail_out - (INFLATE_FAST_MIN_LEFT - 1));\n    safe = out + strm->avail_out;\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    /* Detect if out and window point to the same memory allocation. In this instance it is\n       necessary to use safe chunk copy functions to prevent overwriting the window. If the\n       window is overwritten then future matches with far distances will fail to copy correctly. */\n    extra_safe = (wsize != 0 && out >= window && out + INFLATE_FAST_MIN_LEFT <= window + state->wbufsize);\n\n#define REFILL() do { \\\n        hold |= load_64_bits(in, bits); \\\n        in += 7; \\\n        in -= ((bits >> 3) & 7); \\\n        bits |= 56; \\\n    } while (0)\n\n    /* decode literals and length/distances until end-of-block or not enough\n       input data or output space */\n    do {\n        REFILL();\n        here = lcode + (hold & lmask);\n        if (here->op == 0) {\n            *out++ = (unsigned char)(here->val);\n            DROPBITS(here->bits);\n            here = lcode + (hold & lmask);\n            if (here->op == 0) {\n                *out++ = (unsigned char)(here->val);\n                DROPBITS(here->bits);\n                here = lcode + (hold & lmask);\n            }\n        }\n      dolen:\n        DROPBITS(here->bits);\n        op = here->op;\n        if (op == 0) {                          /* literal */\n            Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?\n                    \"inflate:         literal '%c'\\n\" :\n                    \"inflate:         literal 0x%02x\\n\", here->val));\n            *out++ = (unsigned char)(here->val);\n        } else if (op & 16) {                     /* length base */\n            len = here->val;\n            op &= MAX_BITS;                       /* number of extra bits */\n            len += BITS(op);\n            DROPBITS(op);\n            Tracevv((stderr, \"inflate:         length %u\\n\", len));\n            here = dcode + (hold & dmask);\n            if (bits < MAX_BITS + MAX_DIST_EXTRA_BITS) {\n                REFILL();\n            }\n          dodist:\n            DROPBITS(here->bits);\n            op = here->op;\n            if (op & 16) {                      /* distance base */\n                dist = here->val;\n                op &= MAX_BITS;                 /* number of extra bits */\n                dist += BITS(op);\n#ifdef INFLATE_STRICT\n                if (dist > state->dmax) {\n                    SET_BAD(\"invalid distance too far back\");\n                    break;\n                }\n#endif\n                DROPBITS(op);\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                    op = dist - op;             /* distance back in window */\n                    if (op > whave) {\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                        if (state->sane) {\n                            SET_BAD(\"invalid distance too far back\");\n                            break;\n                        }\n                        if (len <= op - whave) {\n                            do {\n                                *out++ = 0;\n                            } while (--len);\n                            continue;\n                        }\n                        len -= op - whave;\n                        do {\n                            *out++ = 0;\n                        } while (--op > whave);\n                        if (op == 0) {\n                            from = out - dist;\n                            do {\n                                *out++ = *from++;\n                            } while (--len);\n                            continue;\n                        }\n#else\n                        SET_BAD(\"invalid distance too far back\");\n                        break;\n#endif\n                    }\n                    from = window;\n                    if (wnext == 0) {           /* very common case */\n                        from += wsize - op;\n                    } else if (wnext >= op) {   /* contiguous in window */\n                        from += wnext - op;\n                    } else {                    /* wrap around window */\n                        op -= wnext;\n                        from += wsize - op;\n                        if (op < len) {         /* some from end of window */\n                            len -= op;\n                            out = CHUNKCOPY_SAFE(out, from, op, safe);\n                            from = window;      /* more from start of window */\n                            op = wnext;\n                            /* This (rare) case can create a situation where\n                               the first chunkcopy below must be checked.\n                             */\n                        }\n                    }\n                    if (op < len) {             /* still need some from output */\n                        len -= op;\n                        if (!extra_safe) {\n                            out = CHUNKCOPY_SAFE(out, from, op, safe);\n                            out = CHUNKUNROLL(out, &dist, &len);\n                            out = CHUNKCOPY_SAFE(out, out - dist, len, safe);\n                        } else {\n                            out = chunkcopy_safe(out, from, op, safe);\n                            out = chunkcopy_safe(out, out - dist, len, safe);\n                        }\n                    } else {\n#ifndef HAVE_MASKED_READWRITE\n                        if (extra_safe)\n                            out = chunkcopy_safe(out, from, len, safe);\n                        else\n#endif\n                            out = CHUNKCOPY_SAFE(out, from, len, safe);\n                    }\n#ifndef HAVE_MASKED_READWRITE\n                } else if (extra_safe) {\n                    /* Whole reference is in range of current output. */\n                        out = chunkcopy_safe(out, out - dist, len, safe);\n#endif\n                } else {\n                    /* Whole reference is in range of current output.  No range checks are\n                       necessary because we start with room for at least 258 bytes of output,\n                       so unroll and roundoff operations can write beyond `out+len` so long\n                       as they stay within 258 bytes of `out`.\n                    */\n                    if (dist >= len || dist >= state->chunksize)\n                        out = CHUNKCOPY(out, out - dist, len);\n                    else\n                        out = CHUNKMEMSET(out, out - dist, len);\n                }\n            } else if ((op & 64) == 0) {          /* 2nd level distance code */\n                here = dcode + here->val + BITS(op);\n                goto dodist;\n            } else {\n                SET_BAD(\"invalid distance code\");\n                break;\n            }\n        } else if ((op & 64) == 0) {              /* 2nd level length code */\n            here = lcode + here->val + BITS(op);\n            goto dolen;\n        } else if (op & 32) {                     /* end-of-block */\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        } else {\n            SET_BAD(\"invalid literal/length code\");\n            break;\n        }\n    } while (in < last && out < end);\n\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n    hold &= (UINT64_C(1) << bits) - 1;\n\n    /* update state and return */\n    strm->next_in = in;\n    strm->next_out = out;\n    strm->avail_in = (unsigned)(in < last ? (INFLATE_FAST_MIN_HAVE - 1) + (last - in)\n                                          : (INFLATE_FAST_MIN_HAVE - 1) - (in - last));\n    strm->avail_out = (unsigned)(out < end ? (INFLATE_FAST_MIN_LEFT - 1) + (end - out)\n                                           : (INFLATE_FAST_MIN_LEFT - 1) - (out - end));\n\n    Assert(bits <= 32, \"Remaining bits greater than 32\");\n    state->hold = (uint32_t)hold;\n    state->bits = bits;\n    return;\n}\n\n/*\n   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):\n   - Using bit fields for code structure\n   - Different op definition to avoid & for extra bits (do & for table bits)\n   - Three separate decoding do-loops for direct, window, and wnext == 0\n   - Special case for distance > 1 copies to do overlapped load and store copy\n   - Explicit branch predictions (based on measured branch probabilities)\n   - Deferring match copy and interspersed it with decoding subsequent codes\n   - Swapping literal/length else\n   - Swapping window/direct else\n   - Larger unrolled copy loops (three is about right)\n   - Moving len -= 3 statement into middle of loop\n */\n"
        },
        {
          "name": "inffixed_tbl.h",
          "type": "blob",
          "size": 5.83203125,
          "content": "/* inffixed_tbl.h -- table for decoding fixed codes\n * Generated automatically by makefixed().\n */\n\n/* WARNING: this file should *not* be used by applications.\n * It is part of the implementation of this library and is\n * subject to change. Applications should only use zlib.h.\n */\n\nstatic const code lenfix[512] = {\n    {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},\n    {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},\n    {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},\n    {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},\n    {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},\n    {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},\n    {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},\n    {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},\n    {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},\n    {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},\n    {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},\n    {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},\n    {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},\n    {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},\n    {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},\n    {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},\n    {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},\n    {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},\n    {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},\n    {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},\n    {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},\n    {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},\n    {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},\n    {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},\n    {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},\n    {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},\n    {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},\n    {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},\n    {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},\n    {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},\n    {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},\n    {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},\n    {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},\n    {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},\n    {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},\n    {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},\n    {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},\n    {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},\n    {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},\n    {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},\n    {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},\n    {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},\n    {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},\n    {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},\n    {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},\n    {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},\n    {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},\n    {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},\n    {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},\n    {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},\n    {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},\n    {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},\n    {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},\n    {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},\n    {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},\n    {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},\n    {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},\n    {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},\n    {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},\n    {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},\n    {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},\n    {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},\n    {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},\n    {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},\n    {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},\n    {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},\n    {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},\n    {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},\n    {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},\n    {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},\n    {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},\n    {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},\n    {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},\n    {0,9,255}\n};\n\nstatic const code distfix[32] = {\n    {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},\n    {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},\n    {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},\n    {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},\n    {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},\n    {22,5,193},{64,5,0}\n};\n"
        },
        {
          "name": "inflate.c",
          "type": "blob",
          "size": 51.5546875,
          "content": "/* inflate.c -- zlib decompression\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inflate_p.h\"\n#include \"inffixed_tbl.h\"\n#include \"functable.h\"\n\n/* Avoid conflicts with zlib.h macros */\n#ifdef ZLIB_COMPAT\n# undef inflateInit\n# undef inflateInit2\n#endif\n\n/* function prototypes */\nstatic int inflateStateCheck(PREFIX3(stream) *strm);\nstatic void updatewindow(PREFIX3(stream) *strm, const uint8_t *end, uint32_t len, int32_t cksum);\nstatic uint32_t syncsearch(uint32_t *have, const unsigned char *buf, uint32_t len);\n\nstatic inline void inf_chksum_cpy(PREFIX3(stream) *strm, uint8_t *dst,\n                           const uint8_t *src, uint32_t copy) {\n    if (!copy) return;\n    struct inflate_state *state = (struct inflate_state*)strm->state;\n#ifdef GUNZIP\n    if (state->flags) {\n        FUNCTABLE_CALL(crc32_fold_copy)(&state->crc_fold, dst, src, copy);\n    } else\n#endif\n    {\n        strm->adler = state->check = FUNCTABLE_CALL(adler32_fold_copy)(state->check, dst, src, copy);\n    }\n}\n\nstatic inline void inf_chksum(PREFIX3(stream) *strm, const uint8_t *src, uint32_t len) {\n    struct inflate_state *state = (struct inflate_state*)strm->state;\n#ifdef GUNZIP\n    if (state->flags) {\n        FUNCTABLE_CALL(crc32_fold)(&state->crc_fold, src, len, 0);\n    } else\n#endif\n    {\n        strm->adler = state->check = FUNCTABLE_CALL(adler32)(state->check, src, len);\n    }\n}\n\nstatic int inflateStateCheck(PREFIX3(stream) *strm) {\n    struct inflate_state *state;\n    if (strm == NULL || strm->zalloc == NULL || strm->zfree == NULL)\n        return 1;\n    state = (struct inflate_state *)strm->state;\n    if (state == NULL || state->alloc_bufs == NULL || state->strm != strm || state->mode < HEAD || state->mode > SYNC)\n        return 1;\n    return 0;\n}\n\nint32_t Z_EXPORT PREFIX(inflateResetKeep)(PREFIX3(stream) *strm) {\n    struct inflate_state *state;\n\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    strm->total_in = strm->total_out = state->total = 0;\n    strm->msg = NULL;\n    if (state->wrap)        /* to support ill-conceived Java test suite */\n        strm->adler = state->wrap & 1;\n    state->mode = HEAD;\n    state->check = ADLER32_INITIAL_VALUE;\n    state->last = 0;\n    state->havedict = 0;\n    state->flags = -1;\n    state->head = NULL;\n    state->hold = 0;\n    state->bits = 0;\n    state->lencode = state->distcode = state->next = state->codes;\n    state->back = -1;\n#ifdef INFLATE_STRICT\n    state->dmax = 32768U;\n#endif\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    state->sane = 1;\n#endif\n    INFLATE_RESET_KEEP_HOOK(strm);  /* hook for IBM Z DFLTCC */\n    Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}\n\nint32_t Z_EXPORT PREFIX(inflateReset)(PREFIX3(stream) *strm) {\n    struct inflate_state *state;\n\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    state->wsize = 0;\n    state->whave = 0;\n    state->wnext = 0;\n    return PREFIX(inflateResetKeep)(strm);\n}\n\nint32_t Z_EXPORT PREFIX(inflateReset2)(PREFIX3(stream) *strm, int32_t windowBits) {\n    int wrap;\n    struct inflate_state *state;\n\n    /* get the state */\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n\n    /* extract wrap request from windowBits parameter */\n    if (windowBits < 0) {\n        wrap = 0;\n        if (windowBits < -MAX_WBITS)\n            return Z_STREAM_ERROR;\n        windowBits = -windowBits;\n    } else {\n        wrap = (windowBits >> 4) + 5;\n#ifdef GUNZIP\n        if (windowBits < 48)\n            windowBits &= MAX_WBITS;\n#endif\n    }\n\n    /* set number of window bits */\n    if (windowBits && (windowBits < MIN_WBITS || windowBits > MAX_WBITS))\n        return Z_STREAM_ERROR;\n\n    /* update state and reset the rest of it */\n    state->wrap = wrap;\n    state->wbits = (unsigned)windowBits;\n    return PREFIX(inflateReset)(strm);\n}\n\n#ifdef INF_ALLOC_DEBUG\n#  include <stdio.h>\n#  define LOGSZ(name,size)           fprintf(stderr, \"%s is %d bytes\\n\", name, size)\n#  define LOGSZP(name,size,loc,pad)  fprintf(stderr, \"%s is %d bytes, offset %d, padded %d\\n\", name, size, loc, pad)\n#  define LOGSZPL(name,size,loc,pad) fprintf(stderr, \"%s is %d bytes, offset %ld, padded %d\\n\", name, size, loc, pad)\n#else\n#  define LOGSZ(name,size)\n#  define LOGSZP(name,size,loc,pad)\n#  define LOGSZPL(name,size,loc,pad)\n#endif\n\n/* ===========================================================================\n * Allocate a big buffer and divide it up into the various buffers inflate needs.\n * Handles alignment of allocated buffer and alignment of individual buffers.\n */\nZ_INTERNAL inflate_allocs* alloc_inflate(PREFIX3(stream) *strm) {\n    int curr_size = 0;\n\n    /* Define sizes */\n    int window_size = INFLATE_ADJUST_WINDOW_SIZE((1 << MAX_WBITS) + 64); /* 64B padding for chunksize */\n    int state_size = sizeof(inflate_state);\n    int alloc_size = sizeof(inflate_allocs);\n\n    /* Calculate relative buffer positions and paddings */\n    LOGSZP(\"window\", window_size, PAD_WINDOW(curr_size), PADSZ(curr_size,WINDOW_PAD_SIZE));\n    int window_pos = PAD_WINDOW(curr_size);\n    curr_size = window_pos + window_size;\n\n    LOGSZP(\"state\", state_size, PAD_64(curr_size), PADSZ(curr_size,64));\n    int state_pos = PAD_64(curr_size);\n    curr_size = state_pos + state_size;\n\n    LOGSZP(\"alloc\", alloc_size, PAD_16(curr_size), PADSZ(curr_size,16));\n    int alloc_pos = PAD_16(curr_size);\n    curr_size = alloc_pos + alloc_size;\n\n    /* Add 64-1 or 4096-1 to allow window alignment, and round size of buffer up to multiple of 64 */\n    int total_size = PAD_64(curr_size + (WINDOW_PAD_SIZE - 1));\n\n    /* Allocate buffer, align to 64-byte cacheline, and zerofill the resulting buffer */\n    char *original_buf = (char *)strm->zalloc(strm->opaque, 1, total_size);\n    if (original_buf == NULL)\n        return NULL;\n\n    char *buff = (char *)HINT_ALIGNED_WINDOW((char *)PAD_WINDOW(original_buf));\n    LOGSZPL(\"Buffer alloc\", total_size, PADSZ((uintptr_t)original_buf,WINDOW_PAD_SIZE), PADSZ(curr_size,WINDOW_PAD_SIZE));\n\n    /* Initialize alloc_bufs */\n    inflate_allocs *alloc_bufs  = (struct inflate_allocs_s *)(buff + alloc_pos);\n    alloc_bufs->buf_start = original_buf;\n    alloc_bufs->zfree = strm->zfree;\n\n    alloc_bufs->window =  (unsigned char *)HINT_ALIGNED_WINDOW((buff + window_pos));\n    alloc_bufs->state = (inflate_state *)HINT_ALIGNED_64((buff + state_pos));\n\n#ifdef Z_MEMORY_SANITIZER\n    /* This is _not_ to subvert the memory sanitizer but to instead unposion some\n       data we willingly and purposefully load uninitialized into vector registers\n       in order to safely read the last < chunksize bytes of the window. */\n    __msan_unpoison(alloc_bufs->window + window_size, 64);\n#endif\n\n    return alloc_bufs;\n}\n\n/* ===========================================================================\n * Free all allocated inflate buffers\n */\nZ_INTERNAL void free_inflate(PREFIX3(stream) *strm) {\n    struct inflate_state *state = (struct inflate_state *)strm->state;\n\n    if (state->alloc_bufs != NULL) {\n        inflate_allocs *alloc_bufs = state->alloc_bufs;\n        alloc_bufs->zfree(strm->opaque, alloc_bufs->buf_start);\n        strm->state = NULL;\n    }\n}\n\n/* ===========================================================================\n * Initialize inflate state and buffers.\n * This function is hidden in ZLIB_COMPAT builds.\n */\nint32_t ZNG_CONDEXPORT PREFIX(inflateInit2)(PREFIX3(stream) *strm, int32_t windowBits) {\n    struct inflate_state *state;\n    int32_t ret;\n\n    /* Initialize functable */\n    FUNCTABLE_INIT;\n\n    if (strm == NULL)\n        return Z_STREAM_ERROR;\n    strm->msg = NULL;                   /* in case we return an error */\n    if (strm->zalloc == NULL) {\n        strm->zalloc = PREFIX(zcalloc);\n        strm->opaque = NULL;\n    }\n    if (strm->zfree == NULL)\n        strm->zfree = PREFIX(zcfree);\n\n    inflate_allocs *alloc_bufs = alloc_inflate(strm);\n    if (alloc_bufs == NULL)\n        return Z_MEM_ERROR;\n\n    state = alloc_bufs->state;\n    state->window = alloc_bufs->window;\n    state->alloc_bufs = alloc_bufs;\n    state->wbufsize = INFLATE_ADJUST_WINDOW_SIZE((1 << MAX_WBITS) + 64);\n    Tracev((stderr, \"inflate: allocated\\n\"));\n\n    strm->state = (struct internal_state *)state;\n    state->strm = strm;\n    state->mode = HEAD;     /* to pass state test in inflateReset2() */\n    state->chunksize = FUNCTABLE_CALL(chunksize)();\n    ret = PREFIX(inflateReset2)(strm, windowBits);\n    if (ret != Z_OK) {\n        free_inflate(strm);\n    }\n    return ret;\n}\n\n#ifndef ZLIB_COMPAT\nint32_t Z_EXPORT PREFIX(inflateInit)(PREFIX3(stream) *strm) {\n    return PREFIX(inflateInit2)(strm, DEF_WBITS);\n}\n#endif\n\n/* Function used by zlib.h and zlib-ng version 2.0 macros */\nint32_t Z_EXPORT PREFIX(inflateInit_)(PREFIX3(stream) *strm, const char *version, int32_t stream_size) {\n    if (CHECK_VER_STSIZE(version, stream_size))\n        return Z_VERSION_ERROR;\n    return PREFIX(inflateInit2)(strm, DEF_WBITS);\n}\n\n/* Function used by zlib.h and zlib-ng version 2.0 macros */\nint32_t Z_EXPORT PREFIX(inflateInit2_)(PREFIX3(stream) *strm, int32_t windowBits, const char *version, int32_t stream_size) {\n    if (CHECK_VER_STSIZE(version, stream_size))\n        return Z_VERSION_ERROR;\n    return PREFIX(inflateInit2)(strm, windowBits);\n}\n\nint32_t Z_EXPORT PREFIX(inflatePrime)(PREFIX3(stream) *strm, int32_t bits, int32_t value) {\n    struct inflate_state *state;\n\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    if (bits == 0)\n        return Z_OK;\n    INFLATE_PRIME_HOOK(strm, bits, value);  /* hook for IBM Z DFLTCC */\n    state = (struct inflate_state *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + (unsigned int)bits > 32)\n        return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += (unsigned int)bits;\n    return Z_OK;\n}\n\n/*\n   Return state with length and distance decoding tables and index sizes set to\n   fixed code decoding.  This returns fixed tables from inffixed_tbl.h.\n */\n\nvoid Z_INTERNAL PREFIX(fixedtables)(struct inflate_state *state) {\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}\n\n/*\n   Update the window with the last wsize (normally 32K) bytes written before\n   returning.  If window does not exist yet, create it.  This is only called\n   when a window is already in use, or when output has been written during this\n   inflate call, but the end of the deflate stream has not been reached yet.\n   It is also called to create a window for dictionary data when a dictionary\n   is loaded.\n\n   Providing output buffers larger than 32K to inflate() should provide a speed\n   advantage, since only the last 32K of output is copied to the sliding window\n   upon return from inflate(), and since all distances after the first 32K of\n   output will fall in the output data, making match copies simpler and faster.\n   The advantage may be dependent on the size of the processor's data caches.\n */\nstatic void updatewindow(PREFIX3(stream) *strm, const uint8_t *end, uint32_t len, int32_t cksum) {\n    struct inflate_state *state;\n    uint32_t dist;\n\n    state = (struct inflate_state *)strm->state;\n\n    /* if window not in use yet, initialize */\n    if (state->wsize == 0)\n        state->wsize = 1U << state->wbits;\n\n    /* len state->wsize or less output bytes into the circular window */\n    if (len >= state->wsize) {\n        /* Only do this if the caller specifies to checksum bytes AND the platform requires\n         * it (s/390 being the primary exception to this) */\n        if (INFLATE_NEED_CHECKSUM(strm) && cksum) {\n            /* We have to split the checksum over non-copied and copied bytes */\n            if (len > state->wsize)\n                inf_chksum(strm, end - len, len - state->wsize);\n            inf_chksum_cpy(strm, state->window, end - state->wsize, state->wsize);\n        } else {\n            memcpy(state->window, end - state->wsize, state->wsize);\n        }\n\n        state->wnext = 0;\n        state->whave = state->wsize;\n    } else {\n        dist = state->wsize - state->wnext;\n        /* Only do this if the caller specifies to checksum bytes AND the platform requires\n         * We need to maintain the correct order here for the checksum */\n        dist = MIN(dist, len);\n        if (INFLATE_NEED_CHECKSUM(strm) && cksum) {\n            inf_chksum_cpy(strm, state->window + state->wnext, end - len, dist);\n        } else {\n            memcpy(state->window + state->wnext, end - len, dist);\n        }\n        len -= dist;\n        if (len) {\n            if (INFLATE_NEED_CHECKSUM(strm) && cksum) {\n                inf_chksum_cpy(strm, state->window, end - len, len);\n            } else {\n                memcpy(state->window, end - len, len);\n            }\n\n            state->wnext = len;\n            state->whave = state->wsize;\n        } else {\n            state->wnext += dist;\n            if (state->wnext == state->wsize)\n                state->wnext = 0;\n            if (state->whave < state->wsize)\n                state->whave += dist;\n        }\n    }\n}\n\n/*\n   Private macros for inflate()\n   Look in inflate_p.h for macros shared with inflateBack()\n*/\n\n/* Get a byte of input into the bit accumulator, or return from inflate() if there is no input available. */\n#define PULLBYTE() \\\n    do { \\\n        if (have == 0) goto inf_leave; \\\n        have--; \\\n        hold += ((unsigned)(*next++) << bits); \\\n        bits += 8; \\\n    } while (0)\n\n/*\n   inflate() uses a state machine to process as much input data and generate as\n   much output data as possible before returning.  The state machine is\n   structured roughly as follows:\n\n    for (;;) switch (state) {\n    ...\n    case STATEn:\n        if (not enough input data or output space to make progress)\n            return;\n        ... make progress ...\n        state = STATEm;\n        break;\n    ...\n    }\n\n   so when inflate() is called again, the same case is attempted again, and\n   if the appropriate resources are provided, the machine proceeds to the\n   next state.  The NEEDBITS() macro is usually the way the state evaluates\n   whether it can proceed or should return.  NEEDBITS() does the return if\n   the requested bits are not available.  The typical use of the BITS macros\n   is:\n\n        NEEDBITS(n);\n        ... do something with BITS(n) ...\n        DROPBITS(n);\n\n   where NEEDBITS(n) either returns from inflate() if there isn't enough\n   input left to load n bits into the accumulator, or it continues.  BITS(n)\n   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops\n   the low n bits off the accumulator.  INITBITS() clears the accumulator\n   and sets the number of available bits to zero.  BYTEBITS() discards just\n   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()\n   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.\n\n   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return\n   if there is no input available.  The decoding of variable length codes uses\n   PULLBYTE() directly in order to pull just enough bytes to decode the next\n   code, and no more.\n\n   Some states loop until they get enough input, making sure that enough\n   state information is maintained to continue the loop where it left off\n   if NEEDBITS() returns in the loop.  For example, want, need, and keep\n   would all have to actually be part of the saved state in case NEEDBITS()\n   returns:\n\n    case STATEw:\n        while (want < need) {\n            NEEDBITS(n);\n            keep[want++] = BITS(n);\n            DROPBITS(n);\n        }\n        state = STATEx;\n    case STATEx:\n\n   As shown above, if the next state is also the next case, then the break\n   is omitted.\n\n   A state may also return if there is not enough output space available to\n   complete that state.  Those states are copying stored data, writing a\n   literal byte, and copying a matching string.\n\n   When returning, a \"goto inf_leave\" is used to update the total counters,\n   update the check value, and determine whether any progress has been made\n   during that inflate() call in order to return the proper return code.\n   Progress is defined as a change in either strm->avail_in or strm->avail_out.\n   When there is a window, goto inf_leave will update the window with the last\n   output written.  If a goto inf_leave occurs in the middle of decompression\n   and there is no window currently, goto inf_leave will create one and copy\n   output to the window for the next call of inflate().\n\n   In this implementation, the flush parameter of inflate() only affects the\n   return code (per zlib.h).  inflate() always writes as much as possible to\n   strm->next_out, given the space available and the provided input--the effect\n   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers\n   the allocation of and copying into a sliding window until necessary, which\n   provides the effect documented in zlib.h for Z_FINISH when the entire input\n   stream available.  So the only thing the flush parameter actually does is:\n   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it\n   will return Z_BUF_ERROR if it has not reached the end of the stream.\n */\n\nint32_t Z_EXPORT PREFIX(inflate)(PREFIX3(stream) *strm, int32_t flush) {\n    struct inflate_state *state;\n    const unsigned char *next;  /* next input */\n    unsigned char *put;         /* next output */\n    unsigned char *from;        /* where to copy match bytes from */\n    unsigned have, left;        /* available input and output */\n    uint32_t hold;              /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    uint32_t in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int32_t ret;                /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const uint16_t order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (inflateStateCheck(strm) || strm->next_out == NULL ||\n        (strm->next_in == NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state *)strm->state;\n    if (state->mode == TYPE)      /* skip check */\n        state->mode = TYPEDO;\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                if (state->wbits == 0)\n                    state->wbits = MAX_WBITS;\n                state->check = CRC32_INITIAL_VALUE;\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            if (state->head != NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                SET_BAD(\"incorrect header check\");\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                SET_BAD(\"unknown compression method\");\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            if (len > MAX_WBITS || len > state->wbits) {\n                SET_BAD(\"invalid window size\");\n                break;\n            }\n#ifdef INFLATE_STRICT\n            state->dmax = 1U << len;\n#endif\n            state->flags = 0;               /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = ADLER32_INITIAL_VALUE;\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                SET_BAD(\"unknown compression method\");\n                break;\n            }\n            if (state->flags & 0xe000) {\n                SET_BAD(\"unknown header flags set\");\n                break;\n            }\n            if (state->head != NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n            Z_FALLTHROUGH;\n\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != NULL)\n                state->head->time = hold;\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n            Z_FALLTHROUGH;\n\n        case OS:\n            NEEDBITS(16);\n            if (state->head != NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n            Z_FALLTHROUGH;\n\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (uint16_t)hold;\n                if (state->head != NULL)\n                    state->head->extra_len = (uint16_t)hold;\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check, hold);\n                INITBITS();\n            } else if (state->head != NULL) {\n                state->head->extra = NULL;\n            }\n            state->mode = EXTRA;\n            Z_FALLTHROUGH;\n\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have)\n                    copy = have;\n                if (copy) {\n                    if (state->head != NULL && state->head->extra != NULL) {\n                        len = state->head->extra_len - state->length;\n                        if (len < state->head->extra_max) {\n                            memcpy(state->head->extra + len, next,\n                                    len + copy > state->head->extra_max ?\n                                    state->head->extra_max - len : copy);\n                        }\n                    }\n                    if ((state->flags & 0x0200) && (state->wrap & 4)) {\n                        state->check = PREFIX(crc32)(state->check, next, copy);\n                    }\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length)\n                    goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n            Z_FALLTHROUGH;\n\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != NULL && state->head->name != NULL && state->length < state->head->name_max)\n                        state->head->name[state->length++] = (unsigned char)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = PREFIX(crc32)(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len)\n                    goto inf_leave;\n            } else if (state->head != NULL) {\n                state->head->name = NULL;\n            }\n            state->length = 0;\n            state->mode = COMMENT;\n            Z_FALLTHROUGH;\n\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != NULL && state->head->comment != NULL\n                        && state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = (unsigned char)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = PREFIX(crc32)(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len)\n                    goto inf_leave;\n            } else if (state->head != NULL) {\n                state->head->comment = NULL;\n            }\n            state->mode = HCRC;\n            Z_FALLTHROUGH;\n\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                    SET_BAD(\"header crc mismatch\");\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            /* compute crc32 checksum if not in raw mode */\n            if ((state->wrap & 4) && state->flags)\n                strm->adler = state->check = FUNCTABLE_CALL(crc32_fold_reset)(&state->crc_fold);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n            state->mode = DICT;\n            Z_FALLTHROUGH;\n\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = ADLER32_INITIAL_VALUE;\n            state->mode = TYPE;\n            Z_FALLTHROUGH;\n\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES)\n                goto inf_leave;\n            Z_FALLTHROUGH;\n\n        case TYPEDO:\n            /* determine and dispatch block type */\n            INFLATE_TYPEDO_HOOK(strm, flush);  /* hook for IBM Z DFLTCC */\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\", state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                PREFIX(fixedtables)(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\", state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\", state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                SET_BAD(\"invalid block type\");\n            }\n            DROPBITS(2);\n            break;\n\n        case STORED:\n            /* get and verify stored block length */\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                SET_BAD(\"invalid stored block lengths\");\n                break;\n            }\n            state->length = (uint16_t)hold;\n            Tracev((stderr, \"inflate:       stored length %u\\n\", state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES)\n                goto inf_leave;\n            Z_FALLTHROUGH;\n\n        case COPY_:\n            state->mode = COPY;\n            Z_FALLTHROUGH;\n\n        case COPY:\n            /* copy stored block from input to output */\n            copy = state->length;\n            if (copy) {\n                copy = MIN(copy, have);\n                copy = MIN(copy, left);\n                if (copy == 0)\n                    goto inf_leave;\n                memcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n\n        case TABLE:\n            /* get dynamic table entries descriptor */\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                SET_BAD(\"too many length or distance symbols\");\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n            Z_FALLTHROUGH;\n\n        case LENLENS:\n            /* get code length code lengths (not a typo) */\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (uint16_t)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (const code *)(state->next);\n            state->lenbits = 7;\n            ret = zng_inflate_table(CODES, state->lens, 19, &(state->next), &(state->lenbits), state->work);\n            if (ret) {\n                SET_BAD(\"invalid code lengths set\");\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n            Z_FALLTHROUGH;\n\n        case CODELENS:\n            /* get length and distance code code lengths */\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if (here.bits <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                } else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            SET_BAD(\"invalid bit length repeat\");\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    } else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    } else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        SET_BAD(\"invalid bit length repeat\");\n                        break;\n                    }\n                    while (copy) {\n                        --copy;\n                        state->lens[state->have++] = (uint16_t)len;\n                    }\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD)\n                break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                SET_BAD(\"invalid code -- missing end-of-block\");\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (10 and 9) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code *)(state->next);\n            state->lenbits = 10;\n            ret = zng_inflate_table(LENS, state->lens, state->nlen, &(state->next), &(state->lenbits), state->work);\n            if (ret) {\n                SET_BAD(\"invalid literal/lengths set\");\n                break;\n            }\n            state->distcode = (const code *)(state->next);\n            state->distbits = 9;\n            ret = zng_inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                SET_BAD(\"invalid distances set\");\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES)\n                goto inf_leave;\n            Z_FALLTHROUGH;\n\n        case LEN_:\n            state->mode = LEN;\n            Z_FALLTHROUGH;\n\n        case LEN:\n            /* use inflate_fast() if we have enough input and output */\n            if (have >= INFLATE_FAST_MIN_HAVE && left >= INFLATE_FAST_MIN_LEFT) {\n                RESTORE();\n                FUNCTABLE_CALL(inflate_fast)(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n\n            /* get a literal, length, or end-of-block code */\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if (here.bits <= bits)\n                    break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val + (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)last.bits + (unsigned)here.bits <= bits)\n                        break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = here.val;\n\n            /* process literal */\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n\n            /* process end of block */\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n\n            /* invalid code */\n            if (here.op & 64) {\n                SET_BAD(\"invalid literal/length code\");\n                break;\n            }\n\n            /* length code */\n            state->extra = (here.op & MAX_BITS);\n            state->mode = LENEXT;\n            Z_FALLTHROUGH;\n\n        case LENEXT:\n            /* get extra bits, if any */\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n            Z_FALLTHROUGH;\n\n        case DIST:\n            /* get distance code */\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if (here.bits <= bits)\n                    break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val + (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)last.bits + (unsigned)here.bits <= bits)\n                        break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                SET_BAD(\"invalid distance code\");\n                break;\n            }\n            state->offset = here.val;\n            state->extra = (here.op & MAX_BITS);\n            state->mode = DISTEXT;\n            Z_FALLTHROUGH;\n\n        case DISTEXT:\n            /* get distance extra bits, if any */\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                SET_BAD(\"invalid distance too far back\");\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n            Z_FALLTHROUGH;\n\n        case MATCH:\n            /* copy match from window to output */\n            if (left == 0)\n                goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    if (state->sane) {\n                        SET_BAD(\"invalid distance too far back\");\n                        break;\n                    }\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    copy = MIN(copy, state->length);\n                    copy = MIN(copy, left);\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0)\n                        state->mode = LEN;\n#else\n                    SET_BAD(\"invalid distance too far back\");\n#endif\n                    break;\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                } else {\n                    from = state->window + (state->wnext - copy);\n                }\n                copy = MIN(copy, state->length);\n                copy = MIN(copy, left);\n\n                put = chunkcopy_safe(put, from, copy, put + left);\n            } else {\n                copy = MIN(state->length, left);\n\n                put = FUNCTABLE_CALL(chunkmemset_safe)(put, put - state->offset, copy, left);\n            }\n            left -= copy;\n            state->length -= copy;\n            if (state->length == 0)\n                state->mode = LEN;\n            break;\n\n        case LIT:\n            if (left == 0)\n                goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n\n                /* compute crc32 checksum if not in raw mode */\n                if (INFLATE_NEED_CHECKSUM(strm) && state->wrap & 4) {\n                    if (out) {\n                        inf_chksum(strm, put - out, out);\n                    }\n#ifdef GUNZIP\n                    if (state->flags)\n                        strm->adler = state->check = FUNCTABLE_CALL(crc32_fold_final)(&state->crc_fold);\n#endif\n                }\n                out = left;\n                if ((state->wrap & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     ZSWAP32(hold)) != state->check) {\n                    SET_BAD(\"incorrect data check\");\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n            Z_FALLTHROUGH;\n\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                    SET_BAD(\"incorrect length check\");\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n            Z_FALLTHROUGH;\n\n        case DONE:\n            /* inflate stream terminated properly */\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\n        case SYNC:\n\n        default:                 /* can't happen, but makes compilers happy */\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n     */\n  inf_leave:\n    RESTORE();\n    uint32_t check_bytes = out - strm->avail_out;\n    if (INFLATE_NEED_UPDATEWINDOW(strm) &&\n            (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n                 (state->mode < CHECK || flush != Z_FINISH)))) {\n        /* update sliding window with respective checksum if not in \"raw\" mode */\n        updatewindow(strm, strm->next_out, check_bytes, state->wrap & 4);\n    }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n\n    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) + (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK) {\n        /* when no sliding window is used, hash the output bytes if no CHECK state */\n        if (INFLATE_NEED_CHECKSUM(strm) && !state->wsize && flush == Z_FINISH) {\n            inf_chksum(strm, put - check_bytes, check_bytes);\n        }\n        ret = Z_BUF_ERROR;\n    }\n    return ret;\n}\n\nint32_t Z_EXPORT PREFIX(inflateEnd)(PREFIX3(stream) *strm) {\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n\n    /* Free allocated buffers */\n    free_inflate(strm);\n\n    Tracev((stderr, \"inflate: end\\n\"));\n    return Z_OK;\n}\n\nint32_t Z_EXPORT PREFIX(inflateGetDictionary)(PREFIX3(stream) *strm, uint8_t *dictionary, uint32_t *dictLength) {\n    struct inflate_state *state;\n\n    /* check state */\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n\n    INFLATE_GET_DICTIONARY_HOOK(strm, dictionary, dictLength);  /* hook for IBM Z DFLTCC */\n\n    /* copy dictionary */\n    if (state->whave && dictionary != NULL) {\n        memcpy(dictionary, state->window + state->wnext, state->whave - state->wnext);\n        memcpy(dictionary + state->whave - state->wnext, state->window, state->wnext);\n    }\n    if (dictLength != NULL)\n        *dictLength = state->whave;\n    return Z_OK;\n}\n\nint32_t Z_EXPORT PREFIX(inflateSetDictionary)(PREFIX3(stream) *strm, const uint8_t *dictionary, uint32_t dictLength) {\n    struct inflate_state *state;\n    unsigned long dictid;\n\n    /* check state */\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    if (state->wrap != 0 && state->mode != DICT)\n        return Z_STREAM_ERROR;\n\n    /* check for correct dictionary identifier */\n    if (state->mode == DICT) {\n        dictid = FUNCTABLE_CALL(adler32)(ADLER32_INITIAL_VALUE, dictionary, dictLength);\n        if (dictid != state->check)\n            return Z_DATA_ERROR;\n    }\n\n    INFLATE_SET_DICTIONARY_HOOK(strm, dictionary, dictLength);  /* hook for IBM Z DFLTCC */\n\n    /* copy dictionary to window using updatewindow(), which will amend the\n       existing dictionary if appropriate */\n    updatewindow(strm, dictionary + dictLength, dictLength, 0);\n\n    state->havedict = 1;\n    Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\n\nint32_t Z_EXPORT PREFIX(inflateGetHeader)(PREFIX3(stream) *strm, PREFIX(gz_headerp) head) {\n    struct inflate_state *state;\n\n    /* check state */\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    if ((state->wrap & 2) == 0)\n        return Z_STREAM_ERROR;\n\n    /* save header structure */\n    state->head = head;\n    head->done = 0;\n    return Z_OK;\n}\n\n/*\n   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found\n   or when out of input.  When called, *have is the number of pattern bytes\n   found in order so far, in 0..3.  On return *have is updated to the new\n   state.  If on return *have equals four, then the pattern was found and the\n   return value is how many bytes were read including the last byte of the\n   pattern.  If *have is less than four, then the pattern has not been found\n   yet and the return value is len.  In the latter case, syncsearch() can be\n   called again with more data and the *have state.  *have is initialized to\n   zero for the first call.\n */\nstatic uint32_t syncsearch(uint32_t *have, const uint8_t *buf, uint32_t len) {\n    uint32_t got, next;\n\n    got = *have;\n    next = 0;\n    while (next < len && got < 4) {\n        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))\n            got++;\n        else if (buf[next])\n            got = 0;\n        else\n            got = 4 - got;\n        next++;\n    }\n    *have = got;\n    return next;\n}\n\nint32_t Z_EXPORT PREFIX(inflateSync)(PREFIX3(stream) *strm) {\n    struct inflate_state *state;\n    size_t in, out;             /* temporary to save total_in and total_out */\n    unsigned len;               /* number of bytes to look at or looked at */\n    int flags;                  /* temporary to save header status */\n    unsigned char buf[4];       /* to restore bit buffer to byte string */\n\n    /* check parameters */\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    if (strm->avail_in == 0 && state->bits < 8)\n        return Z_BUF_ERROR;\n\n    /* if first time, start search in bit buffer */\n    if (state->mode != SYNC) {\n        state->mode = SYNC;\n        state->hold >>= state->bits & 7;\n        state->bits -= state->bits & 7;\n        len = 0;\n        while (state->bits >= 8) {\n            buf[len++] = (unsigned char)(state->hold);\n            state->hold >>= 8;\n            state->bits -= 8;\n        }\n        state->have = 0;\n        syncsearch(&(state->have), buf, len);\n    }\n\n    /* search available input */\n    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);\n    strm->avail_in -= len;\n    strm->next_in += len;\n    strm->total_in += len;\n\n    /* return no joy or set up to restart inflate() on a new block */\n    if (state->have != 4)\n        return Z_DATA_ERROR;\n    if (state->flags == -1)\n        state->wrap = 0;    /* if no header yet, treat as raw */\n    else\n        state->wrap &= ~4;  /* no point in computing a check value now */\n    flags = state->flags;\n    in = strm->total_in;\n    out = strm->total_out;\n    PREFIX(inflateReset)(strm);\n    strm->total_in = (z_uintmax_t)in; /* Can't use z_size_t here as it will overflow on 64-bit Windows */\n    strm->total_out = (z_uintmax_t)out;\n    state->flags = flags;\n    state->mode = TYPE;\n    return Z_OK;\n}\n\n/*\n   Returns true if inflate is currently at the end of a block generated by\n   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n   implementation to provide an additional safety check. PPP uses\n   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored\n   block. When decompressing, PPP checks that at the end of input packet,\n   inflate is waiting for these length bytes.\n */\nint32_t Z_EXPORT PREFIX(inflateSyncPoint)(PREFIX3(stream) *strm) {\n    struct inflate_state *state;\n\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    INFLATE_SYNC_POINT_HOOK(strm);\n    state = (struct inflate_state *)strm->state;\n    return state->mode == STORED && state->bits == 0;\n}\n\nint32_t Z_EXPORT PREFIX(inflateCopy)(PREFIX3(stream) *dest, PREFIX3(stream) *source) {\n    struct inflate_state *state;\n    struct inflate_state *copy;\n\n    /* check input */\n    if (inflateStateCheck(source) || dest == NULL)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)source->state;\n\n    /* copy stream */\n    memcpy((void *)dest, (void *)source, sizeof(PREFIX3(stream)));\n\n    /* allocate space */\n    inflate_allocs *alloc_bufs = alloc_inflate(dest);\n    if (alloc_bufs == NULL)\n        return Z_MEM_ERROR;\n    copy = alloc_bufs->state;\n\n    /* copy state */\n    memcpy(copy, state, sizeof(struct inflate_state));\n    copy->strm = dest;\n    if (state->lencode >= state->codes && state->lencode <= state->codes + ENOUGH - 1) {\n        copy->lencode = copy->codes + (state->lencode - state->codes);\n        copy->distcode = copy->codes + (state->distcode - state->codes);\n    }\n    copy->next = copy->codes + (state->next - state->codes);\n    copy->window = alloc_bufs->window;\n    copy->alloc_bufs = alloc_bufs;\n\n    /* window */\n    memcpy(copy->window, state->window, INFLATE_ADJUST_WINDOW_SIZE((size_t)state->wsize));\n\n    dest->state = (struct internal_state *)copy;\n    return Z_OK;\n}\n\nint32_t Z_EXPORT PREFIX(inflateUndermine)(PREFIX3(stream) *strm, int32_t subvert) {\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    struct inflate_state *state;\n\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    state->sane = !subvert;\n    return Z_OK;\n#else\n    Z_UNUSED(strm);\n    Z_UNUSED(subvert);\n    return Z_DATA_ERROR;\n#endif\n}\n\nint32_t Z_EXPORT PREFIX(inflateValidate)(PREFIX3(stream) *strm, int32_t check) {\n    struct inflate_state *state;\n\n    if (inflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    if (check && state->wrap)\n        state->wrap |= 4;\n    else\n        state->wrap &= ~4;\n    return Z_OK;\n}\n\nlong Z_EXPORT PREFIX(inflateMark)(PREFIX3(stream) *strm) {\n    struct inflate_state *state;\n\n    if (inflateStateCheck(strm))\n        return -65536;\n    INFLATE_MARK_HOOK(strm);  /* hook for IBM Z DFLTCC */\n    state = (struct inflate_state *)strm->state;\n    return (long)(((unsigned long)((long)state->back)) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}\n\nunsigned long Z_EXPORT PREFIX(inflateCodesUsed)(PREFIX3(stream) *strm) {\n    struct inflate_state *state;\n    if (strm == NULL || strm->state == NULL)\n        return (unsigned long)-1;\n    state = (struct inflate_state *)strm->state;\n    return (unsigned long)(state->next - state->codes);\n}\n"
        },
        {
          "name": "inflate.h",
          "type": "blob",
          "size": 7.7021484375,
          "content": "/* inflate.h -- internal inflate state definition\n * Copyright (C) 1995-2019 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n#ifndef INFLATE_H_\n#define INFLATE_H_\n\n#include \"crc32.h\"\n\n#ifdef S390_DFLTCC_INFLATE\n#  include \"arch/s390/dfltcc_common.h\"\n#  define HAVE_ARCH_INFLATE_STATE\n#endif\n\n/* define NO_GZIP when compiling if you want to disable gzip header and trailer decoding by inflate().\n   NO_GZIP would be used to avoid linking in the crc code when it is not needed.\n   For shared libraries, gzip decoding should be left enabled. */\n#ifndef NO_GZIP\n#  define GUNZIP\n#endif\n\n/* Possible inflate modes between inflate() calls */\ntypedef enum {\n    HEAD = 16180,   /* i: waiting for magic header */\n    FLAGS,      /* i: waiting for method and flags (gzip) */\n    TIME,       /* i: waiting for modification time (gzip) */\n    OS,         /* i: waiting for extra flags and operating system (gzip) */\n    EXLEN,      /* i: waiting for extra length (gzip) */\n    EXTRA,      /* i: waiting for extra bytes (gzip) */\n    NAME,       /* i: waiting for end of file name (gzip) */\n    COMMENT,    /* i: waiting for end of comment (gzip) */\n    HCRC,       /* i: waiting for header crc (gzip) */\n    DICTID,     /* i: waiting for dictionary check value */\n    DICT,       /* waiting for inflateSetDictionary() call */\n        TYPE,       /* i: waiting for type bits, including last-flag bit */\n        TYPEDO,     /* i: same, but skip check to exit inflate on new block */\n        STORED,     /* i: waiting for stored size (length and complement) */\n        COPY_,      /* i/o: same as COPY below, but only first time in */\n        COPY,       /* i/o: waiting for input or output to copy stored block */\n        TABLE,      /* i: waiting for dynamic block table lengths */\n        LENLENS,    /* i: waiting for code length code lengths */\n        CODELENS,   /* i: waiting for length/lit and distance code lengths */\n            LEN_,       /* i: same as LEN below, but only first time in */\n            LEN,        /* i: waiting for length/lit/eob code */\n            LENEXT,     /* i: waiting for length extra bits */\n            DIST,       /* i: waiting for distance code */\n            DISTEXT,    /* i: waiting for distance extra bits */\n            MATCH,      /* o: waiting for output space to copy string */\n            LIT,        /* o: waiting for output space to write literal */\n    CHECK,      /* i: waiting for 32-bit check value */\n    LENGTH,     /* i: waiting for 32-bit length (gzip) */\n    DONE,       /* finished check, done -- remain here until reset */\n    BAD,        /* got a data error -- remain here until reset */\n    SYNC        /* looking for synchronization bytes to restart inflate() */\n} inflate_mode;\n\n/*\n    State transitions between above modes -\n\n    (most modes can go to BAD on error -- not shown for clarity)\n\n    Process header:\n        HEAD -> (gzip) or (zlib) or (raw)\n        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->\n                  HCRC -> TYPE\n        (zlib) -> DICTID or TYPE\n        DICTID -> DICT -> TYPE\n        (raw) -> TYPEDO\n    Read deflate blocks:\n            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK\n            STORED -> COPY_ -> COPY -> TYPE\n            TABLE -> LENLENS -> CODELENS -> LEN_\n            LEN_ -> LEN\n    Read deflate codes in fixed or dynamic block:\n                LEN -> LENEXT or LIT or TYPE\n                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN\n                LIT -> LEN\n    Process trailer:\n        CHECK -> LENGTH -> DONE\n */\ntypedef struct inflate_state inflate_state;\n\n/* Struct for memory allocation handling */\ntypedef struct inflate_allocs_s {\n    char            *buf_start;\n    free_func        zfree;\n    inflate_state   *state;\n    unsigned char   *window;\n} inflate_allocs;\n\n/* State maintained between inflate() calls -- approximately 7K bytes, not\n   including the allocated sliding window, which is up to 32K bytes. */\nstruct ALIGNED_(64) inflate_state {\n    PREFIX3(stream) *strm;      /* pointer back to this zlib stream */\n    inflate_mode mode;          /* current inflate mode */\n    int last;                   /* true if processing last block */\n    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,\n                                   bit 2 true to validate check value */\n    int havedict;               /* true if dictionary provided */\n    int flags;                  /* gzip header method and flags, 0 if zlib, or\n                                   -1 if raw or no header yet */\n    unsigned was;               /* initial length of match, for inflateMark */\n    unsigned long check;        /* protected copy of check value */\n    unsigned long total;        /* protected copy of output count */\n    PREFIX(gz_headerp) head;    /* where to save gzip header information */\n    int back;                   /* bits back of last unprocessed length/lit */\n\n        /* sliding window */\n    unsigned wbits;             /* log base 2 of requested window size */\n    uint32_t wsize;             /* window size or zero if not using window */\n    uint32_t wbufsize;          /* real size of the allocated window buffer, including padding */\n    uint32_t whave;             /* valid bytes in the window */\n    uint32_t wnext;             /* window write index */\n    unsigned char *window;      /* allocated sliding window, if needed */\n    uint32_t chunksize;         /* size of memory copying chunk */\n\n        /* bit accumulator */\n    uint32_t hold;              /* input bit accumulator */\n    unsigned bits;              /* number of bits in \"in\" */\n        /* fixed and dynamic code tables */\n    unsigned lenbits;           /* index bits for lencode */\n    code const *lencode;        /* starting table for length/literal codes */\n    code const *distcode;       /* starting table for distance codes */\n    unsigned distbits;          /* index bits for distcode */\n        /* for string and stored block copying */\n    uint32_t length;            /* literal or length of data to copy */\n    unsigned offset;            /* distance back to copy string from */\n        /* for table and code decoding */\n    unsigned extra;             /* extra bits needed */\n        /* dynamic table building */\n    unsigned ncode;             /* number of code length code lengths */\n    unsigned nlen;              /* number of length code lengths */\n    unsigned ndist;             /* number of distance code lengths */\n    uint32_t have;              /* number of code lengths in lens[] */\n    code *next;                 /* next available space in codes[] */\n\n#if defined(_M_IX86) || defined(_M_ARM)\n    uint32_t padding[2];\n#endif\n    struct crc32_fold_s ALIGNED_(16) crc_fold;\n\n    uint16_t lens[320];         /* temporary storage for code lengths */\n    uint16_t work[288];         /* work area for code table building */\n    code codes[ENOUGH];         /* space for code tables */\n\n    inflate_allocs *alloc_bufs; /* struct for handling memory allocations */\n\n#ifdef INFLATE_STRICT\n    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */\n#endif\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    int sane;                   /* if false, allow invalid distance too far */\n#endif\n#ifdef HAVE_ARCH_INFLATE_STATE\n    arch_inflate_state arch;    /* architecture-specific extensions */\n#endif\n#if defined(_M_IX86) || defined(_M_ARM)\n    int padding2[8];\n#endif\n};\n\nvoid Z_INTERNAL PREFIX(fixedtables)(struct inflate_state *state);\nZ_INTERNAL inflate_allocs* alloc_inflate(PREFIX3(stream) *strm);\nZ_INTERNAL void free_inflate(PREFIX3(stream) *strm);\n\n#endif /* INFLATE_H_ */\n"
        },
        {
          "name": "inflate_p.h",
          "type": "blob",
          "size": 7.05859375,
          "content": "/* inflate_p.h -- Private inline functions and macros shared with more than one deflate method\n *\n */\n\n#ifndef INFLATE_P_H\n#define INFLATE_P_H\n\n#include <stdlib.h>\n#include \"zmemory.h\"\n\n/* Architecture-specific hooks. */\n#ifdef S390_DFLTCC_INFLATE\n#  include \"arch/s390/dfltcc_inflate.h\"\n/* DFLTCC instructions require window to be page-aligned */\n#  define PAD_WINDOW            PAD_4096\n#  define WINDOW_PAD_SIZE       4096\n#  define HINT_ALIGNED_WINDOW   HINT_ALIGNED_4096\n#else\n#  define PAD_WINDOW            PAD_64\n#  define WINDOW_PAD_SIZE       64\n#  define HINT_ALIGNED_WINDOW   HINT_ALIGNED_64\n/* Adjust the window size for the arch-specific inflate code. */\n#  define INFLATE_ADJUST_WINDOW_SIZE(n) (n)\n/* Invoked at the end of inflateResetKeep(). Useful for initializing arch-specific extension blocks. */\n#  define INFLATE_RESET_KEEP_HOOK(strm) do {} while (0)\n/* Invoked at the beginning of inflatePrime(). Useful for updating arch-specific buffers. */\n#  define INFLATE_PRIME_HOOK(strm, bits, value) do {} while (0)\n/* Invoked at the beginning of each block. Useful for plugging arch-specific inflation code. */\n#  define INFLATE_TYPEDO_HOOK(strm, flush) do {} while (0)\n/* Returns whether zlib-ng should compute a checksum. Set to 0 if arch-specific inflation code already does that. */\n#  define INFLATE_NEED_CHECKSUM(strm) 1\n/* Returns whether zlib-ng should update a window. Set to 0 if arch-specific inflation code already does that. */\n#  define INFLATE_NEED_UPDATEWINDOW(strm) 1\n/* Invoked at the beginning of inflateMark(). Useful for updating arch-specific pointers and offsets. */\n#  define INFLATE_MARK_HOOK(strm) do {} while (0)\n/* Invoked at the beginning of inflateSyncPoint(). Useful for performing arch-specific state checks. */\n#  define INFLATE_SYNC_POINT_HOOK(strm) do {} while (0)\n/* Invoked at the beginning of inflateSetDictionary(). Useful for checking arch-specific window data. */\n#  define INFLATE_SET_DICTIONARY_HOOK(strm, dict, dict_len) do {} while (0)\n/* Invoked at the beginning of inflateGetDictionary(). Useful for adjusting arch-specific window data. */\n#  define INFLATE_GET_DICTIONARY_HOOK(strm, dict, dict_len) do {} while (0)\n#endif\n\n/*\n *   Macros shared by inflate() and inflateBack()\n */\n\n/* check function to use adler32() for zlib or crc32() for gzip */\n#ifdef GUNZIP\n#  define UPDATE(check, buf, len) \\\n    (state->flags ? PREFIX(crc32)(check, buf, len) : FUNCTABLE_CALL(adler32)(check, buf, len))\n#else\n#  define UPDATE(check, buf, len) FUNCTABLE_CALL(adler32)(check, buf, len)\n#endif\n\n/* check macros for header crc */\n#ifdef GUNZIP\n#  define CRC2(check, word) \\\n    do { \\\n        hbuf[0] = (unsigned char)(word); \\\n        hbuf[1] = (unsigned char)((word) >> 8); \\\n        check = PREFIX(crc32)(check, hbuf, 2); \\\n    } while (0)\n\n#  define CRC4(check, word) \\\n    do { \\\n        hbuf[0] = (unsigned char)(word); \\\n        hbuf[1] = (unsigned char)((word) >> 8); \\\n        hbuf[2] = (unsigned char)((word) >> 16); \\\n        hbuf[3] = (unsigned char)((word) >> 24); \\\n        check = PREFIX(crc32)(check, hbuf, 4); \\\n    } while (0)\n#endif\n\n/* Load registers with state in inflate() for speed */\n#define LOAD() \\\n    do { \\\n        put = strm->next_out; \\\n        left = strm->avail_out; \\\n        next = strm->next_in; \\\n        have = strm->avail_in; \\\n        hold = state->hold; \\\n        bits = state->bits; \\\n    } while (0)\n\n/* Restore state from registers in inflate() */\n#define RESTORE() \\\n    do { \\\n        strm->next_out = put; \\\n        strm->avail_out = left; \\\n        strm->next_in = (z_const unsigned char *)next; \\\n        strm->avail_in = have; \\\n        state->hold = hold; \\\n        state->bits = bits; \\\n    } while (0)\n\n/* Clear the input bit accumulator */\n#define INITBITS() \\\n    do { \\\n        hold = 0; \\\n        bits = 0; \\\n    } while (0)\n\n/* Ensure that there is at least n bits in the bit accumulator.  If there is\n   not enough available input to do that, then return from inflate()/inflateBack(). */\n#define NEEDBITS(n) \\\n    do { \\\n        while (bits < (unsigned)(n)) \\\n            PULLBYTE(); \\\n    } while (0)\n\n/* Return the low n bits of the bit accumulator (n < 16) */\n#define BITS(n) \\\n    (hold & ((1U << (unsigned)(n)) - 1))\n\n/* Remove n bits from the bit accumulator */\n#define DROPBITS(n) \\\n    do { \\\n        hold >>= (n); \\\n        bits -= (unsigned)(n); \\\n    } while (0)\n\n/* Remove zero to seven bits as needed to go to a byte boundary */\n#define BYTEBITS() \\\n    do { \\\n        hold >>= bits & 7; \\\n        bits -= bits & 7; \\\n    } while (0)\n\n/* Set mode=BAD and prepare error message */\n#define SET_BAD(errmsg) \\\n    do { \\\n        state->mode = BAD; \\\n        strm->msg = (char *)errmsg; \\\n    } while (0)\n\n#define INFLATE_FAST_MIN_HAVE 15\n#define INFLATE_FAST_MIN_LEFT 260\n\n/* Load 64 bits from IN and place the bytes at offset BITS in the result. */\nstatic inline uint64_t load_64_bits(const unsigned char *in, unsigned bits) {\n    uint64_t chunk = zng_memread_8(in);\n\n#if BYTE_ORDER == LITTLE_ENDIAN\n    return chunk << bits;\n#else\n    return ZSWAP64(chunk) << bits;\n#endif\n}\n\n/* Behave like chunkcopy, but avoid writing beyond of legal output. */\nstatic inline uint8_t* chunkcopy_safe(uint8_t *out, uint8_t *from, uint64_t len, uint8_t *safe) {\n    uint64_t safelen = safe - out;\n    len = MIN(len, safelen);\n    int32_t olap_src = from >= out && from < out + len;\n    int32_t olap_dst = out >= from && out < from + len;\n    uint64_t tocopy;\n\n    /* For all cases without overlap, memcpy is ideal */\n    if (!(olap_src || olap_dst)) {\n        memcpy(out, from, (size_t)len);\n        return out + len;\n    }\n\n    /* Complete overlap: Source == destination */\n    if (out == from) {\n        return out + len;\n    }\n\n    /* We are emulating a self-modifying copy loop here. To do this in a way that doesn't produce undefined behavior,\n     * we have to get a bit clever. First if the overlap is such that src falls between dst and dst+len, we can do the\n     * initial bulk memcpy of the nonoverlapping region. Then, we can leverage the size of this to determine the safest\n     * atomic memcpy size we can pick such that we have non-overlapping regions. This effectively becomes a safe look\n     * behind or lookahead distance. */\n    uint64_t non_olap_size = llabs(from - out); // llabs vs labs for compatibility with windows\n\n    /* So this doesn't give use a worst case scenario of function calls in a loop,\n     * we want to instead break this down into copy blocks of fixed lengths\n     *\n     * TODO: The memcpy calls aren't inlined on architectures with strict memory alignment\n     */\n    while (len) {\n        tocopy = MIN(non_olap_size, len);\n        len -= tocopy;\n\n        while (tocopy >= 16) {\n            memcpy(out, from, 16);\n            out += 16;\n            from += 16;\n            tocopy -= 16;\n        }\n\n        if (tocopy >= 8) {\n            memcpy(out, from, 8);\n            out += 8;\n            from += 8;\n            tocopy -= 8;\n        }\n\n        if (tocopy >= 4) {\n            memcpy(out, from, 4);\n            out += 4;\n            from += 4;\n            tocopy -= 4;\n        }\n\n        while (tocopy--) {\n            *out++ = *from++;\n        }\n    }\n\n    return out;\n}\n\n#endif\n"
        },
        {
          "name": "inftrees.c",
          "type": "blob",
          "size": 12.60546875,
          "content": "/* inftrees.c -- generate Huffman trees for efficient decoding\n * Copyright (C) 1995-2024 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil.h\"\n#include \"inftrees.h\"\n\nconst char PREFIX(inflate_copyright)[] = \" inflate 1.3.1 Copyright 1995-2024 Mark Adler \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\n\n/*\n   Build a set of tables to decode the provided canonical Huffman code.\n   The code lengths are lens[0..codes-1].  The result starts at *table,\n   whose indices are 0..2^bits-1.  work is a writable array of at least\n   lens shorts, which is used as a work area.  type is the type of code\n   to be generated, CODES, LENS, or DISTS.  On return, zero is success,\n   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table\n   on return points to the next available entry's address.  bits is the\n   requested root table index bits, and on return it is the actual root\n   table index bits.  It will differ if the request is greater than the\n   longest code or if it is less than the shortest code.\n */\nint Z_INTERNAL zng_inflate_table(codetype type, uint16_t *lens, unsigned codes,\n                                code * *table, unsigned *bits, uint16_t *work) {\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n    code *next;                 /* next available space in table */\n    const uint16_t *base;       /* base value table to use */\n    const uint16_t *extra;      /* extra bits table to use */\n    unsigned match;             /* use base and extra for symbol >= match */\n    uint16_t count[MAX_BITS+1];  /* number of codes of each length */\n    uint16_t offs[MAX_BITS+1];   /* offsets in table for each length */\n    static const uint16_t lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const uint16_t lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 77};\n    static const uint16_t dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const uint16_t dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAX_BITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAX_BITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    root = MIN(root, max);\n    if (UNLIKELY(max == 0)) {           /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (uint16_t)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    root = MAX(root, min);\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAX_BITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAX_BITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (uint16_t)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n    switch (type) {\n    case CODES:\n        base = extra = work;    /* dummy value--not used */\n        match = 20;\n        break;\n    case LENS:\n        base = lbase;\n        extra = lext;\n        match = 257;\n        break;\n    default:    /* DISTS */\n        base = dbase;\n        extra = dext;\n        match = 0;\n    }\n\n    /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used > ENOUGH_LENS) ||\n        (type == DISTS && used > ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n    for (;;) {\n        /* create table entry */\n        here.bits = (unsigned char)(len - drop);\n        if (LIKELY(work[sym] >= match)) {\n            here.op = (unsigned char)(extra[work[sym] - match]);\n            here.val = base[work[sym] - match];\n        } else if (work[sym] + 1U < match) {\n            here.op = (unsigned char)0;\n            here.val = work[sym];\n        } else {\n            here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        } else {\n            huff = 0;\n        }\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max)\n                break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0)\n                    break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used > ENOUGH_LENS) || (type == DISTS && used > ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (uint16_t)(next - *table);\n        }\n    }\n\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) */\n    if (UNLIKELY(huff != 0)) {\n        here.op = (unsigned char)64;            /* invalid code marker */\n        here.bits = (unsigned char)(len - drop);\n        here.val = (uint16_t)0;\n        next[huff] = here;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}\n"
        },
        {
          "name": "inftrees.h",
          "type": "blob",
          "size": 2.8525390625,
          "content": "#ifndef INFTREES_H_\n#define INFTREES_H_\n\n/* inftrees.h -- header to use inftrees.c\n * Copyright (C) 1995-2022 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n/* Structure for decoding tables.  Each entry provides either the\n   information needed to do the operation requested by the code that\n   indexed that table entry, or it provides a pointer to another\n   table that indexes more bits of the code.  op indicates whether\n   the entry is a pointer to another table, a literal, a length or\n   distance, an end-of-block, or an invalid code.  For a table\n   pointer, the low four bits of op is the number of index bits of\n   that table.  For a length or distance, the low four bits of op\n   is the number of extra bits to get after the code.  bits is\n   the number of bits in this code or part of the code to drop off\n   of the bit buffer.  val is the actual byte to output in the case\n   of a literal, the base length or distance, or the offset from\n   the current table to the next table.  Each entry is four bytes. */\ntypedef struct {\n    unsigned char op;         /* operation, extra bits, table bits */\n    unsigned char bits;       /* bits in this part of the code */\n    uint16_t val;             /* offset in table or code value */\n} code;\n\n/* op values as set by inflate_table():\n    00000000 - literal\n    0000tttt - table link, tttt != 0 is the number of table index bits\n    0001eeee - length or distance, eeee is the number of extra bits\n    01100000 - end of block\n    01000000 - invalid code\n */\n\n/* Maximum size of the dynamic table.  The maximum number of code structures is\n   1924, which is the sum of 1332 for literal/length codes and 592 for distance\n   codes.  These values were found by exhaustive searches using the program\n   examples/enough.c found in the zlib distributions.  The arguments to that\n   program are the number of symbols, the initial root table size, and the\n   maximum bit length of a code.  \"enough 286 10 15\" for literal/length codes\n   returns 1332, and \"enough 30 9 15\" for distance codes returns 592.\n   The initial root table size (10 or 9) is found in the fifth argument of the\n   inflate_table() calls in inflate.c and infback.c.  If the root table size is\n   changed, then these maximum sizes would be need to be recalculated and\n   updated. */\n#define ENOUGH_LENS 1332\n#define ENOUGH_DISTS 592\n#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)\n\n/* Type of code to build for inflate_table() */\ntypedef enum {\n    CODES,\n    LENS,\n    DISTS\n} codetype;\n\nint Z_INTERNAL zng_inflate_table (codetype type, uint16_t *lens, unsigned codes,\n                                  code * *table, unsigned *bits, uint16_t *work);\n\n#endif /* INFTREES_H_ */\n"
        },
        {
          "name": "insert_string.c",
          "type": "blob",
          "size": 0.5732421875,
          "content": "/* insert_string.c -- insert_string integer hash variant\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n\n#define HASH_SLIDE           16\n\n#define HASH_CALC(h, val)    h = ((val * 2654435761U) >> HASH_SLIDE);\n#define HASH_CALC_VAR        h\n#define HASH_CALC_VAR_INIT   uint32_t h = 0\n\n#define UPDATE_HASH          update_hash\n#define INSERT_STRING        insert_string\n#define QUICK_INSERT_STRING  quick_insert_string\n\n#include \"insert_string_tpl.h\"\n"
        },
        {
          "name": "insert_string_roll.c",
          "type": "blob",
          "size": 0.7158203125,
          "content": "/* insert_string_roll.c -- insert_string rolling hash variant\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n\n#define HASH_SLIDE           5\n\n#define HASH_CALC(h, val)    h = ((h << HASH_SLIDE) ^ ((uint8_t)val))\n#define HASH_CALC_VAR        s->ins_h\n#define HASH_CALC_VAR_INIT\n#define HASH_CALC_READ       val = strstart[0]\n#define HASH_CALC_MASK       (32768u - 1u)\n#define HASH_CALC_OFFSET     (STD_MIN_MATCH-1)\n\n#define UPDATE_HASH          update_hash_roll\n#define INSERT_STRING        insert_string_roll\n#define QUICK_INSERT_STRING  quick_insert_string_roll\n\n#include \"insert_string_tpl.h\"\n"
        },
        {
          "name": "insert_string_tpl.h",
          "type": "blob",
          "size": 3.37890625,
          "content": "#ifndef INSERT_STRING_H_\n#define INSERT_STRING_H_\n\n/* insert_string_tpl.h -- Private insert_string functions shared with more than\n *                        one insert string implementation\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n *\n * Copyright (C) 2013 Intel Corporation. All rights reserved.\n * Authors:\n *  Wajdi Feghali   <wajdi.k.feghali@intel.com>\n *  Jim Guilford    <james.guilford@intel.com>\n *  Vinodh Gopal    <vinodh.gopal@intel.com>\n *  Erdinc Ozturk   <erdinc.ozturk@intel.com>\n *  Jim Kukunas     <james.t.kukunas@linux.intel.com>\n *\n * Portions are Copyright (C) 2016 12Sided Technology, LLC.\n * Author:\n *  Phil Vachon     <pvachon@12sidedtech.com>\n *\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n */\n\n#include \"zmemory.h\"\n\n#ifndef HASH_CALC_OFFSET\n#  define HASH_CALC_OFFSET 0\n#endif\n#ifndef HASH_CALC_MASK\n#  define HASH_CALC_MASK HASH_MASK\n#endif\n#ifndef HASH_CALC_READ\n#  if BYTE_ORDER == LITTLE_ENDIAN\n#    define HASH_CALC_READ \\\n        val = zng_memread_4(strstart);\n#  else\n#    define HASH_CALC_READ \\\n        val = ZSWAP32(zng_memread_4(strstart));\n#  endif\n#endif\n\n/* ===========================================================================\n * Update a hash value with the given input byte\n * IN  assertion: all calls to UPDATE_HASH are made with consecutive\n *    input characters, so that a running hash key can be computed from the\n *    previous key instead of complete recalculation each time.\n */\nZ_INTERNAL uint32_t UPDATE_HASH(uint32_t h, uint32_t val) {\n    HASH_CALC(h, val);\n    return h & HASH_CALC_MASK;\n}\n\n/* ===========================================================================\n * Quick insert string str in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n */\nZ_INTERNAL Pos QUICK_INSERT_STRING(deflate_state *const s, uint32_t str) {\n    Pos head;\n    uint8_t *strstart = s->window + str + HASH_CALC_OFFSET;\n    uint32_t val, hm;\n\n    HASH_CALC_VAR_INIT;\n    HASH_CALC_READ;\n    HASH_CALC(HASH_CALC_VAR, val);\n    HASH_CALC_VAR &= HASH_CALC_MASK;\n    hm = HASH_CALC_VAR;\n\n    head = s->head[hm];\n    if (LIKELY(head != str)) {\n        s->prev[str & s->w_mask] = head;\n        s->head[hm] = (Pos)str;\n    }\n    return head;\n}\n\n/* ===========================================================================\n * Insert string str in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * IN  assertion: all calls to INSERT_STRING are made with consecutive\n *    input characters and the first STD_MIN_MATCH bytes of str are valid\n *    (except for the last STD_MIN_MATCH-1 bytes of the input file).\n */\nZ_INTERNAL void INSERT_STRING(deflate_state *const s, uint32_t str, uint32_t count) {\n    uint8_t *strstart = s->window + str + HASH_CALC_OFFSET;\n    uint8_t *strend = strstart + count;\n\n    for (Pos idx = (Pos)str; strstart < strend; idx++, strstart++) {\n        uint32_t val, hm;\n\n        HASH_CALC_VAR_INIT;\n        HASH_CALC_READ;\n        HASH_CALC(HASH_CALC_VAR, val);\n        HASH_CALC_VAR &= HASH_CALC_MASK;\n        hm = HASH_CALC_VAR;\n\n        Pos head = s->head[hm];\n        if (LIKELY(head != idx)) {\n            s->prev[idx & s->w_mask] = head;\n            s->head[hm] = idx;\n        }\n    }\n}\n#endif\n"
        },
        {
          "name": "match_tpl.h",
          "type": "blob",
          "size": 8.8095703125,
          "content": "/* match_tpl.h -- find longest match template for compare256 variants\n *\n * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * Portions copyright (C) 2014-2021 Konstantin Nosov\n *  Fast-zlib optimized longest_match\n *  https://github.com/gildor2/fast_zlib\n */\n\n#ifndef MATCH_TPL_H\n#define MATCH_TPL_H\n\n#define EARLY_EXIT_TRIGGER_LEVEL 5\n\n#endif\n\n/* Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is garbage.\n *\n * IN assertions: cur_match is the head of the hash chain for the current\n * string (strstart) and its distance is <= MAX_DIST, and prev_length >=1\n * OUT assertion: the match length is not greater than s->lookahead\n *\n * The LONGEST_MATCH_SLOW variant spends more time to attempt to find longer\n * matches once a match has already been found.\n */\nZ_INTERNAL uint32_t LONGEST_MATCH(deflate_state *const s, Pos cur_match) {\n    unsigned int strstart = s->strstart;\n    const unsigned wmask = s->w_mask;\n    unsigned char *window = s->window;\n    unsigned char *scan = window + strstart;\n    Z_REGISTER unsigned char *mbase_start = window;\n    Z_REGISTER unsigned char *mbase_end;\n    const Pos *prev = s->prev;\n    Pos limit;\n#ifdef LONGEST_MATCH_SLOW\n    Pos limit_base;\n#else\n    int32_t early_exit;\n#endif\n    uint32_t chain_length, nice_match, best_len, offset;\n    uint32_t lookahead = s->lookahead;\n    Pos match_offset = 0;\n    uint64_t scan_start;\n    uint64_t scan_end;\n\n#define GOTO_NEXT_CHAIN \\\n    if (--chain_length && (cur_match = prev[cur_match & wmask]) > limit) \\\n        continue; \\\n    return best_len;\n\n    /* The code is optimized for STD_MAX_MATCH-2 multiple of 16. */\n    Assert(STD_MAX_MATCH == 258, \"Code too clever\");\n\n    best_len = s->prev_length ? s->prev_length : STD_MIN_MATCH-1;\n\n    /* Calculate read offset which should only extend an extra byte\n     * to find the next best match length.\n     */\n    offset = best_len-1;\n    if (best_len >= sizeof(uint32_t)) {\n        offset -= 2;\n        if (best_len >= sizeof(uint64_t))\n            offset -= 4;\n    }\n\n    scan_start = zng_memread_8(scan);\n    scan_end = zng_memread_8(scan+offset);\n    mbase_end  = (mbase_start+offset);\n\n    /* Do not waste too much time if we already have a good match */\n    chain_length = s->max_chain_length;\n    if (best_len >= s->good_match)\n        chain_length >>= 2;\n    nice_match = (uint32_t)s->nice_match;\n\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0\n     */\n    limit = strstart > MAX_DIST(s) ? (Pos)(strstart - MAX_DIST(s)) : 0;\n#ifdef LONGEST_MATCH_SLOW\n    limit_base = limit;\n    if (best_len >= STD_MIN_MATCH) {\n        /* We're continuing search (lazy evaluation). */\n        uint32_t i, hash;\n        Pos pos;\n\n        /* Find a most distant chain starting from scan with index=1 (index=0 corresponds\n         * to cur_match). We cannot use s->prev[strstart+1,...] immediately, because\n         * these strings are not yet inserted into the hash table.\n         */\n        hash = s->update_hash(0, scan[1]);\n        hash = s->update_hash(hash, scan[2]);\n\n        for (i = 3; i <= best_len; i++) {\n            hash = s->update_hash(hash, scan[i]);\n\n            /* If we're starting with best_len >= 3, we can use offset search. */\n            pos = s->head[hash];\n            if (pos < cur_match) {\n                match_offset = (Pos)(i - 2);\n                cur_match = pos;\n            }\n        }\n\n        /* Update offset-dependent variables */\n        limit = limit_base+match_offset;\n        if (cur_match <= limit)\n            goto break_matching;\n        mbase_start -= match_offset;\n        mbase_end -= match_offset;\n    }\n#else\n    early_exit = s->level < EARLY_EXIT_TRIGGER_LEVEL;\n#endif\n    Assert((unsigned long)strstart <= s->window_size - MIN_LOOKAHEAD, \"need lookahead\");\n    for (;;) {\n        if (cur_match >= strstart)\n            break;\n\n        /* Skip to next match if the match length cannot increase or if the match length is\n         * less than 2. Note that the checks below for insufficient lookahead only occur\n         * occasionally for performance reasons.\n         * Therefore uninitialized memory will be accessed and conditional jumps will be made\n         * that depend on those values. However the length of the match is limited to the\n         * lookahead, so the output of deflate is not affected by the uninitialized values.\n         */\n        if (best_len < sizeof(uint32_t)) {\n            for (;;) {\n                if (zng_memcmp_2(mbase_end+cur_match, &scan_end) == 0 &&\n                    zng_memcmp_2(mbase_start+cur_match, &scan_start) == 0)\n                    break;\n                GOTO_NEXT_CHAIN;\n            }\n        } else if (best_len >= sizeof(uint64_t)) {\n            for (;;) {\n                if (zng_memcmp_8(mbase_end+cur_match, &scan_end) == 0 &&\n                    zng_memcmp_8(mbase_start+cur_match, &scan_start) == 0)\n                    break;\n                GOTO_NEXT_CHAIN;\n            }\n        } else {\n            for (;;) {\n                if (zng_memcmp_4(mbase_end+cur_match, &scan_end) == 0 &&\n                    zng_memcmp_4(mbase_start+cur_match, &scan_start) == 0)\n                    break;\n                GOTO_NEXT_CHAIN;\n            }\n        }\n        uint32_t len = COMPARE256(scan+2, mbase_start+cur_match+2) + 2;\n        Assert(scan+len <= window+(unsigned)(s->window_size-1), \"wild scan\");\n\n        if (len > best_len) {\n            uint32_t match_start = cur_match - match_offset;\n            s->match_start = match_start;\n\n            /* Do not look for matches beyond the end of the input. */\n            if (len > lookahead)\n                return lookahead;\n            best_len = len;\n            if (best_len >= nice_match)\n                return best_len;\n\n            offset = best_len-1;\n            if (best_len >= sizeof(uint32_t)) {\n                offset -= 2;\n                if (best_len >= sizeof(uint64_t))\n                    offset -= 4;\n            }\n\n            scan_end = zng_memread_8(scan+offset);\n\n#ifdef LONGEST_MATCH_SLOW\n            /* Look for a better string offset */\n            if (UNLIKELY(len > STD_MIN_MATCH && match_start + len < strstart)) {\n                Pos pos, next_pos;\n                uint32_t i, hash;\n                unsigned char *scan_endstr;\n\n                /* Go back to offset 0 */\n                cur_match -= match_offset;\n                match_offset = 0;\n                next_pos = cur_match;\n                for (i = 0; i <= len - STD_MIN_MATCH; i++) {\n                    pos = prev[(cur_match + i) & wmask];\n                    if (pos < next_pos) {\n                        /* Hash chain is more distant, use it */\n                        if (pos <= limit_base + i)\n                            goto break_matching;\n                        next_pos = pos;\n                        match_offset = (Pos)i;\n                    }\n                }\n                /* Switch cur_match to next_pos chain */\n                cur_match = next_pos;\n\n                /* Try hash head at len-(STD_MIN_MATCH-1) position to see if we could get\n                 * a better cur_match at the end of string. Using (STD_MIN_MATCH-1) lets\n                 * us include one more byte into hash - the byte which will be checked\n                 * in main loop now, and which allows to grow match by 1.\n                 */\n                scan_endstr = scan + len - (STD_MIN_MATCH+1);\n\n                hash = s->update_hash(0, scan_endstr[0]);\n                hash = s->update_hash(hash, scan_endstr[1]);\n                hash = s->update_hash(hash, scan_endstr[2]);\n\n                pos = s->head[hash];\n                if (pos < cur_match) {\n                    match_offset = (Pos)(len - (STD_MIN_MATCH+1));\n                    if (pos <= limit_base + match_offset)\n                        goto break_matching;\n                    cur_match = pos;\n                }\n\n                /* Update offset-dependent variables */\n                limit = limit_base+match_offset;\n                mbase_start = window-match_offset;\n                mbase_end = (mbase_start+offset);\n                continue;\n            }\n#endif\n            mbase_end = (mbase_start+offset);\n        }\n#ifndef LONGEST_MATCH_SLOW\n        else if (UNLIKELY(early_exit)) {\n            /* The probability of finding a match later if we here is pretty low, so for\n             * performance it's best to outright stop here for the lower compression levels\n             */\n            break;\n        }\n#endif\n        GOTO_NEXT_CHAIN;\n    }\n    return best_len;\n\n#ifdef LONGEST_MATCH_SLOW\nbreak_matching:\n\n    if (best_len < s->lookahead)\n        return best_len;\n\n    return s->lookahead;\n#endif\n}\n\n#undef LONGEST_MATCH_SLOW\n#undef LONGEST_MATCH\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "trees.c",
          "type": "blob",
          "size": 30.724609375,
          "content": "/* trees.c -- output deflated data using Huffman coding\n * Copyright (C) 1995-2024 Jean-loup Gailly\n * detect_data_type() function provided freely by Cosmin Truta, 2006\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process uses several Huffman trees. The more\n *      common source values are represented by shorter bit sequences.\n *\n *      Each code tree is stored in a compressed form which is itself\n * a Huffman encoding of the lengths of all the code strings (in\n * ascending order by source values).  The actual code strings are\n * reconstructed from the lengths in the inflate process, as described\n * in the deflate specification.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"'Deflate' Compressed Data Format Specification\".\n *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc\n *\n *      Storer, James A.\n *          Data Compression:  Methods and Theory, pp. 49-50.\n *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.\n *\n *      Sedgewick, R.\n *          Algorithms, p290.\n *          Addison-Wesley, 1983. ISBN 0-201-06672-6.\n */\n\n#include \"zbuild.h\"\n#include \"deflate.h\"\n#include \"trees.h\"\n#include \"trees_emit.h\"\n#include \"trees_tbl.h\"\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\nstruct static_tree_desc_s {\n    const ct_data *static_tree; /* static tree or NULL */\n    const int     *extra_bits;  /* extra bits for each code or NULL */\n    int            extra_base;  /* base index for extra_bits */\n    int            elems;       /* max number of elements in the tree */\n    unsigned int   max_length;  /* max bit length for the codes */\n};\n\nstatic const static_tree_desc  static_l_desc =\n{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};\n\nstatic const static_tree_desc  static_d_desc =\n{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};\n\nstatic const static_tree_desc  static_bl_desc =\n{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};\n\n/* ===========================================================================\n * Local (static) routines in this file.\n */\n\nstatic void init_block       (deflate_state *s);\nstatic void pqdownheap       (deflate_state *s, ct_data *tree, int k);\nstatic void gen_bitlen       (deflate_state *s, tree_desc *desc);\nstatic void build_tree       (deflate_state *s, tree_desc *desc);\nstatic void scan_tree        (deflate_state *s, ct_data *tree, int max_code);\nstatic void send_tree        (deflate_state *s, ct_data *tree, int max_code);\nstatic int  build_bl_tree    (deflate_state *s);\nstatic void send_all_trees   (deflate_state *s, int lcodes, int dcodes, int blcodes);\nstatic void compress_block   (deflate_state *s, const ct_data *ltree, const ct_data *dtree);\nstatic int  detect_data_type (deflate_state *s);\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nvoid Z_INTERNAL zng_tr_init(deflate_state *s) {\n    s->l_desc.dyn_tree = s->dyn_ltree;\n    s->l_desc.stat_desc = &static_l_desc;\n\n    s->d_desc.dyn_tree = s->dyn_dtree;\n    s->d_desc.stat_desc = &static_d_desc;\n\n    s->bl_desc.dyn_tree = s->bl_tree;\n    s->bl_desc.stat_desc = &static_bl_desc;\n\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n#ifdef ZLIB_DEBUG\n    s->compressed_len = 0L;\n    s->bits_sent = 0L;\n#endif\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n}\n\n/* ===========================================================================\n * Initialize a new block.\n */\nstatic void init_block(deflate_state *s) {\n    int n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES;  n++)\n        s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++)\n        s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++)\n        s->bl_tree[n].Freq = 0;\n\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->sym_next = s->matches = 0;\n}\n\n#define SMALLEST 1\n/* Index within the heap array of least frequent node in the Huffman tree */\n\n\n/* ===========================================================================\n * Remove the smallest element from the heap and recreate the heap with\n * one less element. Updates heap and heap_len.\n */\n#define pqremove(s, tree, top) \\\n{\\\n    top = s->heap[SMALLEST]; \\\n    s->heap[SMALLEST] = s->heap[s->heap_len--]; \\\n    pqdownheap(s, tree, SMALLEST); \\\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n#define smaller(tree, n, m, depth) \\\n    (tree[n].Freq < tree[m].Freq || \\\n    (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nstatic void pqdownheap(deflate_state *s, ct_data *tree, int k) {\n    /* tree: the tree to restore */\n    /* k: node to move down */\n    int v = s->heap[k];\n    int j = k << 1;  /* left son of k */\n    while (j <= s->heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s->heap_len && smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s->heap[j], s->depth))\n            break;\n\n        /* Exchange v with the smallest son */\n        s->heap[k] = s->heap[j];\n        k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n    }\n    s->heap[k] = v;\n}\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nstatic void gen_bitlen(deflate_state *s, tree_desc *desc) {\n    /* desc: the tree descriptor */\n    ct_data *tree           = desc->dyn_tree;\n    int max_code            = desc->max_code;\n    const ct_data *stree    = desc->stat_desc->static_tree;\n    const int *extra        = desc->stat_desc->extra_bits;\n    int base                = desc->stat_desc->extra_base;\n    unsigned int max_length = desc->stat_desc->max_length;\n    int h;              /* heap index */\n    int n, m;           /* iterate over the tree elements */\n    unsigned int bits;  /* bit length */\n    int xbits;          /* extra bits */\n    uint16_t f;         /* frequency */\n    int overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS; bits++)\n        s->bl_count[bits] = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */\n\n    for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s->heap[h];\n        bits = tree[tree[n].Dad].Len + 1u;\n        if (bits > max_length){\n            bits = max_length;\n            overflow++;\n        }\n        tree[n].Len = (uint16_t)bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) /* not a leaf node */\n            continue;\n\n        s->bl_count[bits]++;\n        xbits = 0;\n        if (n >= base)\n            xbits = extra[n-base];\n        f = tree[n].Freq;\n        s->opt_len += (unsigned long)f * (unsigned int)(bits + xbits);\n        if (stree)\n            s->static_len += (unsigned long)f * (unsigned int)(stree[n].Len + xbits);\n    }\n    if (overflow == 0)\n        return;\n\n    Tracev((stderr, \"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n        bits = max_length - 1;\n        while (s->bl_count[bits] == 0)\n            bits--;\n        s->bl_count[bits]--;       /* move one leaf down the tree */\n        s->bl_count[bits+1] += 2u; /* move one overflow item as its brother */\n        s->bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n        overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits != 0; bits--) {\n        n = s->bl_count[bits];\n        while (n != 0) {\n            m = s->heap[--h];\n            if (m > max_code)\n                continue;\n            if (tree[m].Len != bits) {\n                Tracev((stderr, \"code %d bits %d->%u\\n\", m, tree[m].Len, bits));\n                s->opt_len += (unsigned long)(bits * tree[m].Freq);\n                s->opt_len -= (unsigned long)(tree[m].Len * tree[m].Freq);\n                tree[m].Len = (uint16_t)bits;\n            }\n            n--;\n        }\n    }\n}\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nZ_INTERNAL void gen_codes(ct_data *tree, int max_code, uint16_t *bl_count) {\n    /* tree: the tree to decorate */\n    /* max_code: largest code with non zero frequency */\n    /* bl_count: number of codes at each bit length */\n    uint16_t next_code[MAX_BITS+1];  /* next code value for each bit length */\n    unsigned int code = 0;           /* running code value */\n    int bits;                        /* bit index */\n    int n;                           /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS; bits++) {\n        code = (code + bl_count[bits-1]) << 1;\n        next_code[bits] = (uint16_t)code;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    Assert(code + bl_count[MAX_BITS]-1 == (1 << MAX_BITS)-1, \"inconsistent bit counts\");\n    Tracev((stderr, \"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n        int len = tree[n].Len;\n        if (len == 0)\n            continue;\n        /* Now reverse the bits */\n        tree[n].Code = PREFIX(bi_reverse)(next_code[len]++, len);\n\n        Tracecv(tree != static_ltree, (stderr, \"\\nn %3d %c l %2d c %4x (%x) \",\n             n, (isgraph(n & 0xff) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n}\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nstatic void build_tree(deflate_state *s, tree_desc *desc) {\n    /* desc: the tree descriptor */\n    ct_data *tree         = desc->dyn_tree;\n    const ct_data *stree  = desc->stat_desc->static_tree;\n    int elems             = desc->stat_desc->elems;\n    int n, m;          /* iterate over heap elements */\n    int max_code = -1; /* largest code with non zero frequency */\n    int node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n    s->heap_len = 0;\n    s->heap_max = HEAP_SIZE;\n\n    for (n = 0; n < elems; n++) {\n        if (tree[n].Freq != 0) {\n            s->heap[++(s->heap_len)] = max_code = n;\n            s->depth[n] = 0;\n        } else {\n            tree[n].Len = 0;\n        }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s->heap_len < 2) {\n        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);\n        tree[node].Freq = 1;\n        s->depth[node] = 0;\n        s->opt_len--;\n        if (stree)\n            s->static_len -= stree[node].Len;\n        /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc->max_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = s->heap_len/2; n >= 1; n--)\n        pqdownheap(s, tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n        pqremove(s, tree, n);  /* n = node of least frequency */\n        m = s->heap[SMALLEST]; /* m = node of next least frequency */\n\n        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */\n        s->heap[--(s->heap_max)] = m;\n\n        /* Create a new node father of n and m */\n        tree[node].Freq = tree[n].Freq + tree[m].Freq;\n        s->depth[node] = (unsigned char)((s->depth[n] >= s->depth[m] ?\n                                          s->depth[n] : s->depth[m]) + 1);\n        tree[n].Dad = tree[m].Dad = (uint16_t)node;\n#ifdef DUMP_BL_TREE\n        if (tree == s->bl_tree) {\n            fprintf(stderr, \"\\nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);\n        }\n#endif\n        /* and insert the new node in the heap */\n        s->heap[SMALLEST] = node++;\n        pqdownheap(s, tree, SMALLEST);\n    } while (s->heap_len >= 2);\n\n    s->heap[--(s->heap_max)] = s->heap[SMALLEST];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, (tree_desc *)desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes((ct_data *)tree, max_code, s->bl_count);\n}\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nstatic void scan_tree(deflate_state *s, ct_data *tree, int max_code) {\n    /* tree: the tree to be scanned */\n    /* max_code: and its largest code of non zero frequency */\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    uint16_t count = 0;        /* repeat count of the current code */\n    uint16_t max_count = 7;    /* max repeat count */\n    uint16_t min_count = 4;    /* min repeat count */\n\n    if (nextlen == 0)\n        max_count = 138, min_count = 3;\n\n    tree[max_code+1].Len = (uint16_t)0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[n+1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s->bl_tree[curlen].Freq += count;\n        } else if (curlen != 0) {\n            if (curlen != prevlen)\n                s->bl_tree[curlen].Freq++;\n            s->bl_tree[REP_3_6].Freq++;\n        } else if (count <= 10) {\n            s->bl_tree[REPZ_3_10].Freq++;\n        } else {\n            s->bl_tree[REPZ_11_138].Freq++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nstatic void send_tree(deflate_state *s, ct_data *tree, int max_code) {\n    /* tree: the tree to be scanned */\n    /* max_code and its largest code of non zero frequency */\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    /* tree[max_code+1].Len = -1; */  /* guard already set */\n    if (nextlen == 0)\n        max_count = 138, min_count = 3;\n\n    // Temp local variables\n    uint32_t bi_valid = s->bi_valid;\n    uint64_t bi_buf = s->bi_buf;\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[n+1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do {\n                send_code(s, curlen, s->bl_tree, bi_buf, bi_valid);\n            } while (--count != 0);\n\n        } else if (curlen != 0) {\n            if (curlen != prevlen) {\n                send_code(s, curlen, s->bl_tree, bi_buf, bi_valid);\n                count--;\n            }\n            Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s->bl_tree, bi_buf, bi_valid);\n            send_bits(s, count-3, 2, bi_buf, bi_valid);\n\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s->bl_tree, bi_buf, bi_valid);\n            send_bits(s, count-3, 3, bi_buf, bi_valid);\n\n        } else {\n            send_code(s, REPZ_11_138, s->bl_tree, bi_buf, bi_valid);\n            send_bits(s, count-11, 7, bi_buf, bi_valid);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n\n    // Store back temp variables\n    s->bi_buf = bi_buf;\n    s->bi_valid = bi_valid;\n}\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nstatic int build_bl_tree(deflate_state *s) {\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);\n    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, (tree_desc *)(&(s->bl_desc)));\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n        if (s->bl_tree[bl_order[max_blindex]].Len != 0)\n            break;\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s->opt_len += 3*((unsigned long)max_blindex+1) + 5+5+4;\n    Tracev((stderr, \"\\ndyn trees: dyn %lu, stat %lu\", s->opt_len, s->static_len));\n\n    return max_blindex;\n}\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nstatic void send_all_trees(deflate_state *s, int lcodes, int dcodes, int blcodes) {\n    int rank;                    /* index in bl_order */\n\n    Assert(lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    Assert(lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES, \"too many codes\");\n\n    // Temp local variables\n    uint32_t bi_valid = s->bi_valid;\n    uint64_t bi_buf = s->bi_buf;\n\n    Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes-257, 5, bi_buf, bi_valid); /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes-1,   5, bi_buf, bi_valid);\n    send_bits(s, blcodes-4,  4, bi_buf, bi_valid); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n        Tracev((stderr, \"\\nbl code %2u \", bl_order[rank]));\n        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3, bi_buf, bi_valid);\n    }\n    Tracev((stderr, \"\\nbl tree: sent %lu\", s->bits_sent));\n\n    // Store back temp variables\n    s->bi_buf = bi_buf;\n    s->bi_valid = bi_valid;\n\n    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */\n    Tracev((stderr, \"\\nlit tree: sent %lu\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */\n    Tracev((stderr, \"\\ndist tree: sent %lu\", s->bits_sent));\n}\n\n/* ===========================================================================\n * Send a stored block\n */\nvoid Z_INTERNAL zng_tr_stored_block(deflate_state *s, char *buf, uint32_t stored_len, int last) {\n    /* buf: input block */\n    /* stored_len: length of input block */\n    /* last: one if this is the last block for a file */\n    zng_tr_emit_tree(s, STORED_BLOCK, last); /* send block type */\n    zng_tr_emit_align(s);                    /* align on byte boundary */\n    cmpr_bits_align(s);\n    put_short(s, (uint16_t)stored_len);\n    put_short(s, (uint16_t)~stored_len);\n    cmpr_bits_add(s, 32);\n    sent_bits_add(s, 32);\n    if (stored_len) {\n        memcpy(s->pending_buf + s->pending, (unsigned char *)buf, stored_len);\n        s->pending += stored_len;\n        cmpr_bits_add(s, stored_len << 3);\n        sent_bits_add(s, stored_len << 3);\n    }\n}\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nvoid Z_INTERNAL zng_tr_align(deflate_state *s) {\n    zng_tr_emit_tree(s, STATIC_TREES, 0);\n    zng_tr_emit_end_block(s, static_ltree, 0);\n    zng_tr_flush_bits(s);\n}\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nvoid Z_INTERNAL zng_tr_flush_block(deflate_state *s, char *buf, uint32_t stored_len, int last) {\n    /* buf: input block, or NULL if too old */\n    /* stored_len: length of input block */\n    /* last: one if this is the last block for a file */\n    unsigned long opt_lenb, static_lenb; /* opt_len and static_len in bytes */\n    int max_blindex = 0;  /* index of last bit length code of non zero freq */\n\n    /* Build the Huffman trees unless a stored block is forced */\n    if (UNLIKELY(s->sym_next == 0)) {\n        /* Emit an empty static tree block with no codes */\n        opt_lenb = static_lenb = 0;\n        s->static_len = 7;\n    } else if (s->level > 0) {\n        /* Check if the file is binary or text */\n        if (s->strm->data_type == Z_UNKNOWN)\n            s->strm->data_type = detect_data_type(s);\n\n        /* Construct the literal and distance trees */\n        build_tree(s, (tree_desc *)(&(s->l_desc)));\n        Tracev((stderr, \"\\nlit data: dyn %lu, stat %lu\", s->opt_len, s->static_len));\n\n        build_tree(s, (tree_desc *)(&(s->d_desc)));\n        Tracev((stderr, \"\\ndist data: dyn %lu, stat %lu\", s->opt_len, s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n        max_blindex = build_bl_tree(s);\n\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n        opt_lenb = (s->opt_len+3+7) >> 3;\n        static_lenb = (s->static_len+3+7) >> 3;\n\n        Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %u lit %u \",\n                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n                s->sym_next / 3));\n\n        if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)\n            opt_lenb = static_lenb;\n\n    } else {\n        Assert(buf != NULL, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n    }\n\n    if (stored_len+4 <= opt_lenb && buf != NULL) {\n        /* 4: two words for the lengths\n         * The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        zng_tr_stored_block(s, buf, stored_len, last);\n\n    } else if (static_lenb == opt_lenb) {\n        zng_tr_emit_tree(s, STATIC_TREES, last);\n        compress_block(s, (const ct_data *)static_ltree, (const ct_data *)static_dtree);\n        cmpr_bits_add(s, s->static_len);\n    } else {\n        zng_tr_emit_tree(s, DYN_TREES, last);\n        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1, max_blindex+1);\n        compress_block(s, (const ct_data *)s->dyn_ltree, (const ct_data *)s->dyn_dtree);\n        cmpr_bits_add(s, s->opt_len);\n    }\n    Assert(s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n     * and unsigned long implemented on 32 bits.\n     */\n    init_block(s);\n\n    if (last) {\n        zng_tr_emit_align(s);\n    }\n    Tracev((stderr, \"\\ncomprlen %lu(%lu) \", s->compressed_len>>3, s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nstatic void compress_block(deflate_state *s, const ct_data *ltree, const ct_data *dtree) {\n    /* ltree: literal tree */\n    /* dtree: distance tree */\n    unsigned dist;      /* distance of matched string */\n    int lc;             /* match length or unmatched char (if dist == 0) */\n    unsigned sx = 0;    /* running index in symbol buffers */\n\n    if (s->sym_next != 0) {\n        do {\n#ifdef LIT_MEM\n            dist = s->d_buf[sx];\n            lc = s->l_buf[sx++];\n#else\n            dist = s->sym_buf[sx++] & 0xff;\n            dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n            lc = s->sym_buf[sx++];\n#endif\n            if (dist == 0) {\n                zng_emit_lit(s, ltree, lc);\n            } else {\n                zng_emit_dist(s, ltree, dtree, lc, dist);\n            } /* literal or match pair ? */\n\n            /* Check for no overlay of pending_buf on needed symbols */\n#ifdef LIT_MEM\n            Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pending_buf overflow\");\n#else\n            Assert(s->pending < s->lit_bufsize + sx, \"pending_buf overflow\");\n#endif\n        } while (sx < s->sym_next);\n    }\n\n    zng_emit_end_block(s, ltree, 0);\n}\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nstatic int detect_data_type(deflate_state *s) {\n    /* black_mask is the bit mask of black-listed bytes\n     * set bits 0..6, 14..25, and 28..31\n     * 0xf3ffc07f = binary 11110011111111111100000001111111\n     */\n    unsigned long black_mask = 0xf3ffc07fUL;\n    int n;\n\n    /* Check for non-textual (\"black-listed\") bytes. */\n    for (n = 0; n <= 31; n++, black_mask >>= 1)\n        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))\n            return Z_BINARY;\n\n    /* Check for textual (\"white-listed\") bytes. */\n    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0 || s->dyn_ltree[13].Freq != 0)\n        return Z_TEXT;\n    for (n = 32; n < LITERALS; n++)\n        if (s->dyn_ltree[n].Freq != 0)\n            return Z_TEXT;\n\n    /* There are no \"black-listed\" or \"white-listed\" bytes:\n     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n     */\n    return Z_BINARY;\n}\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nvoid Z_INTERNAL zng_tr_flush_bits(deflate_state *s) {\n    if (s->bi_valid >= 48) {\n        put_uint32(s, (uint32_t)s->bi_buf);\n        put_short(s, (uint16_t)(s->bi_buf >> 32));\n        s->bi_buf >>= 48;\n        s->bi_valid -= 48;\n    } else if (s->bi_valid >= 32) {\n        put_uint32(s, (uint32_t)s->bi_buf);\n        s->bi_buf >>= 32;\n        s->bi_valid -= 32;\n    }\n    if (s->bi_valid >= 16) {\n        put_short(s, (uint16_t)s->bi_buf);\n        s->bi_buf >>= 16;\n        s->bi_valid -= 16;\n    }\n    if (s->bi_valid >= 8) {\n        put_byte(s, s->bi_buf);\n        s->bi_buf >>= 8;\n        s->bi_valid -= 8;\n    }\n}\n\n/* ===========================================================================\n * Reverse the first len bits of a code using bit manipulation\n */\nZ_INTERNAL uint16_t PREFIX(bi_reverse)(unsigned code, int len) {\n    /* code: the value to invert */\n    /* len: its bit length */\n    Assert(len >= 1 && len <= 15, \"code length must be 1-15\");\n#define bitrev8(b) \\\n    (uint8_t)((((uint8_t)(b) * 0x80200802ULL) & 0x0884422110ULL) * 0x0101010101ULL >> 32)\n    return (bitrev8(code >> 8) | (uint16_t)bitrev8(code) << 8) >> (16 - len);\n}\n"
        },
        {
          "name": "trees.h",
          "type": "blob",
          "size": 1.2568359375,
          "content": "#ifndef TREES_H_\n#define TREES_H_\n\n/* Constants */\n\n#define DIST_CODE_LEN  512\n/* see definition of array dist_code in trees.c */\n\n#define MAX_BL_BITS 7\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\n#define REP_3_6      16\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n#define REPZ_3_10    17\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n#define REPZ_11_138  18\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nstatic const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */\n    = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};\n\nstatic const int extra_dbits[D_CODES] /* extra bits for each distance code */\n    = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nstatic const int extra_blbits[BL_CODES] /* extra bits for each bit length code */\n    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};\n\nstatic const unsigned char bl_order[BL_CODES]\n    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};\n /* The lengths of the bit length codes are sent in order of decreasing\n  * probability, to avoid transmitting the lengths for unused bit length codes.\n  */\n\n\n/* Function definitions */\nvoid gen_codes        (ct_data *tree, int max_code, uint16_t *bl_count);\n\n#endif\n"
        },
        {
          "name": "trees_emit.h",
          "type": "blob",
          "size": 6.90234375,
          "content": "#ifndef TREES_EMIT_H_\n#define TREES_EMIT_H_\n\n#include \"zbuild.h\"\n#include \"trees.h\"\n\n#ifdef ZLIB_DEBUG\n#  include <ctype.h>\n#  include <inttypes.h>\n#endif\n\n\n/* trees.h */\nextern Z_INTERNAL const ct_data static_ltree[L_CODES+2];\nextern Z_INTERNAL const ct_data static_dtree[D_CODES];\n\nextern const unsigned char Z_INTERNAL zng_dist_code[DIST_CODE_LEN];\nextern const unsigned char Z_INTERNAL zng_length_code[STD_MAX_MATCH-STD_MIN_MATCH+1];\n\nextern Z_INTERNAL const int base_length[LENGTH_CODES];\nextern Z_INTERNAL const int base_dist[D_CODES];\n\n/* Bit buffer and deflate code stderr tracing */\n#ifdef ZLIB_DEBUG\n#  define send_bits_trace(s, value, length) { \\\n        Tracevv((stderr, \" l %2d v %4llx \", (int)(length), (long long)(value))); \\\n        Assert(length > 0 && length <= BIT_BUF_SIZE, \"invalid length\"); \\\n    }\n#  define send_code_trace(s, c) \\\n    if (z_verbose > 2) { \\\n        fprintf(stderr, \"\\ncd %3d \", (c)); \\\n    }\n#else\n#  define send_bits_trace(s, value, length)\n#  define send_code_trace(s, c)\n#endif\n\n/* If not enough room in bi_buf, use (valid) bits from bi_buf and\n * (64 - bi_valid) bits from value, leaving (width - (64-bi_valid))\n * unused bits in value.\n */\n#define send_bits(s, t_val, t_len, bi_buf, bi_valid) {\\\n    uint64_t val = (uint64_t)t_val;\\\n    uint32_t len = (uint32_t)t_len;\\\n    uint32_t total_bits = bi_valid + len;\\\n    send_bits_trace(s, val, len);\\\n    sent_bits_add(s, len);\\\n    if (total_bits < BIT_BUF_SIZE) {\\\n        bi_buf |= val << bi_valid;\\\n        bi_valid = total_bits;\\\n    } else if (bi_valid == BIT_BUF_SIZE) {\\\n        put_uint64(s, bi_buf);\\\n        bi_buf = val;\\\n        bi_valid = len;\\\n    } else {\\\n        bi_buf |= val << bi_valid;\\\n        put_uint64(s, bi_buf);\\\n        bi_buf = val >> (BIT_BUF_SIZE - bi_valid);\\\n        bi_valid = total_bits - BIT_BUF_SIZE;\\\n    }\\\n}\n\n/* Send a code of the given tree. c and tree must not have side effects */\n#ifdef ZLIB_DEBUG\n#  define send_code(s, c, tree, bi_buf, bi_valid) { \\\n    send_code_trace(s, c); \\\n    send_bits(s, tree[c].Code, tree[c].Len, bi_buf, bi_valid); \\\n}\n#else\n#  define send_code(s, c, tree, bi_buf, bi_valid) \\\n    send_bits(s, tree[c].Code, tree[c].Len, bi_buf, bi_valid)\n#endif\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nstatic void bi_windup(deflate_state *s) {\n    if (s->bi_valid > 56) {\n        put_uint64(s, s->bi_buf);\n    } else {\n        if (s->bi_valid > 24) {\n            put_uint32(s, (uint32_t)s->bi_buf);\n            s->bi_buf >>= 32;\n            s->bi_valid -= 32;\n        }\n        if (s->bi_valid > 8) {\n            put_short(s, (uint16_t)s->bi_buf);\n            s->bi_buf >>= 16;\n            s->bi_valid -= 16;\n        }\n        if (s->bi_valid > 0) {\n            put_byte(s, s->bi_buf);\n        }\n    }\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n}\n\n/* ===========================================================================\n * Emit literal code\n */\nstatic inline uint32_t zng_emit_lit(deflate_state *s, const ct_data *ltree, unsigned c) {\n    uint32_t bi_valid = s->bi_valid;\n    uint64_t bi_buf = s->bi_buf;\n\n    send_code(s, c, ltree, bi_buf, bi_valid);\n\n    s->bi_valid = bi_valid;\n    s->bi_buf = bi_buf;\n\n    Tracecv(isgraph(c & 0xff), (stderr, \" '%c' \", c));\n\n    return ltree[c].Len;\n}\n\n/* ===========================================================================\n * Emit match distance/length code\n */\nstatic inline uint32_t zng_emit_dist(deflate_state *s, const ct_data *ltree, const ct_data *dtree,\n    uint32_t lc, uint32_t dist) {\n    uint32_t c, extra;\n    uint8_t code;\n    uint64_t match_bits;\n    uint32_t match_bits_len;\n    uint32_t bi_valid = s->bi_valid;\n    uint64_t bi_buf = s->bi_buf;\n\n    /* Send the length code, len is the match length - STD_MIN_MATCH */\n    code = zng_length_code[lc];\n    c = code+LITERALS+1;\n    Assert(c < L_CODES, \"bad l_code\");\n    send_code_trace(s, c);\n\n    match_bits = ltree[c].Code;\n    match_bits_len = ltree[c].Len;\n    extra = extra_lbits[code];\n    if (extra != 0) {\n        lc -= base_length[code];\n        match_bits |= ((uint64_t)lc << match_bits_len);\n        match_bits_len += extra;\n    }\n\n    dist--; /* dist is now the match distance - 1 */\n    code = d_code(dist);\n    Assert(code < D_CODES, \"bad d_code\");\n    send_code_trace(s, code);\n\n    /* Send the distance code */\n    match_bits |= ((uint64_t)dtree[code].Code << match_bits_len);\n    match_bits_len += dtree[code].Len;\n    extra = extra_dbits[code];\n    if (extra != 0) {\n        dist -= base_dist[code];\n        match_bits |= ((uint64_t)dist << match_bits_len);\n        match_bits_len += extra;\n    }\n\n    send_bits(s, match_bits, match_bits_len, bi_buf, bi_valid);\n\n    s->bi_valid = bi_valid;\n    s->bi_buf = bi_buf;\n\n    return match_bits_len;\n}\n\n/* ===========================================================================\n * Emit end block\n */\nstatic inline void zng_emit_end_block(deflate_state *s, const ct_data *ltree, const int last) {\n    uint32_t bi_valid = s->bi_valid;\n    uint64_t bi_buf = s->bi_buf;\n    send_code(s, END_BLOCK, ltree, bi_buf, bi_valid);\n    s->bi_valid = bi_valid;\n    s->bi_buf = bi_buf;\n    Tracev((stderr, \"\\n+++ Emit End Block: Last: %u Pending: %u Total Out: %\" PRIu64 \"\\n\",\n        last, s->pending, (uint64_t)s->strm->total_out));\n    Z_UNUSED(last);\n}\n\n/* ===========================================================================\n * Emit literal and count bits\n */\nstatic inline void zng_tr_emit_lit(deflate_state *s, const ct_data *ltree, unsigned c) {\n    cmpr_bits_add(s, zng_emit_lit(s, ltree, c));\n}\n\n/* ===========================================================================\n * Emit match and count bits\n */\nstatic inline void zng_tr_emit_dist(deflate_state *s, const ct_data *ltree, const ct_data *dtree,\n    uint32_t lc, uint32_t dist) {\n    cmpr_bits_add(s, zng_emit_dist(s, ltree, dtree, lc, dist));\n}\n\n/* ===========================================================================\n * Emit start of block\n */\nstatic inline void zng_tr_emit_tree(deflate_state *s, int type, const int last) {\n    uint32_t bi_valid = s->bi_valid;\n    uint64_t bi_buf = s->bi_buf;\n    uint32_t header_bits = (type << 1) + last;\n    send_bits(s, header_bits, 3, bi_buf, bi_valid);\n    cmpr_bits_add(s, 3);\n    s->bi_valid = bi_valid;\n    s->bi_buf = bi_buf;\n    Tracev((stderr, \"\\n--- Emit Tree: Last: %u\\n\", last));\n}\n\n/* ===========================================================================\n * Align bit buffer on a byte boundary and count bits\n */\nstatic inline void zng_tr_emit_align(deflate_state *s) {\n    bi_windup(s); /* align on byte boundary */\n    sent_bits_align(s);\n}\n\n/* ===========================================================================\n * Emit an end block and align bit buffer if last block\n */\nstatic inline void zng_tr_emit_end_block(deflate_state *s, const ct_data *ltree, const int last) {\n    zng_emit_end_block(s, ltree, last);\n    cmpr_bits_add(s, 7);\n    if (last)\n        zng_tr_emit_align(s);\n}\n\n#endif\n"
        },
        {
          "name": "trees_tbl.h",
          "type": "blob",
          "size": 7.794921875,
          "content": "#ifndef TREES_TBL_H_\n#define TREES_TBL_H_\n\n/* header created automatically with maketrees.c */\n\nZ_INTERNAL const ct_data static_ltree[L_CODES+2] = {\n{{ 12},{8}}, {{140},{8}}, {{ 76},{8}}, {{204},{8}}, {{ 44},{8}},\n{{172},{8}}, {{108},{8}}, {{236},{8}}, {{ 28},{8}}, {{156},{8}},\n{{ 92},{8}}, {{220},{8}}, {{ 60},{8}}, {{188},{8}}, {{124},{8}},\n{{252},{8}}, {{  2},{8}}, {{130},{8}}, {{ 66},{8}}, {{194},{8}},\n{{ 34},{8}}, {{162},{8}}, {{ 98},{8}}, {{226},{8}}, {{ 18},{8}},\n{{146},{8}}, {{ 82},{8}}, {{210},{8}}, {{ 50},{8}}, {{178},{8}},\n{{114},{8}}, {{242},{8}}, {{ 10},{8}}, {{138},{8}}, {{ 74},{8}},\n{{202},{8}}, {{ 42},{8}}, {{170},{8}}, {{106},{8}}, {{234},{8}},\n{{ 26},{8}}, {{154},{8}}, {{ 90},{8}}, {{218},{8}}, {{ 58},{8}},\n{{186},{8}}, {{122},{8}}, {{250},{8}}, {{  6},{8}}, {{134},{8}},\n{{ 70},{8}}, {{198},{8}}, {{ 38},{8}}, {{166},{8}}, {{102},{8}},\n{{230},{8}}, {{ 22},{8}}, {{150},{8}}, {{ 86},{8}}, {{214},{8}},\n{{ 54},{8}}, {{182},{8}}, {{118},{8}}, {{246},{8}}, {{ 14},{8}},\n{{142},{8}}, {{ 78},{8}}, {{206},{8}}, {{ 46},{8}}, {{174},{8}},\n{{110},{8}}, {{238},{8}}, {{ 30},{8}}, {{158},{8}}, {{ 94},{8}},\n{{222},{8}}, {{ 62},{8}}, {{190},{8}}, {{126},{8}}, {{254},{8}},\n{{  1},{8}}, {{129},{8}}, {{ 65},{8}}, {{193},{8}}, {{ 33},{8}},\n{{161},{8}}, {{ 97},{8}}, {{225},{8}}, {{ 17},{8}}, {{145},{8}},\n{{ 81},{8}}, {{209},{8}}, {{ 49},{8}}, {{177},{8}}, {{113},{8}},\n{{241},{8}}, {{  9},{8}}, {{137},{8}}, {{ 73},{8}}, {{201},{8}},\n{{ 41},{8}}, {{169},{8}}, {{105},{8}}, {{233},{8}}, {{ 25},{8}},\n{{153},{8}}, {{ 89},{8}}, {{217},{8}}, {{ 57},{8}}, {{185},{8}},\n{{121},{8}}, {{249},{8}}, {{  5},{8}}, {{133},{8}}, {{ 69},{8}},\n{{197},{8}}, {{ 37},{8}}, {{165},{8}}, {{101},{8}}, {{229},{8}},\n{{ 21},{8}}, {{149},{8}}, {{ 85},{8}}, {{213},{8}}, {{ 53},{8}},\n{{181},{8}}, {{117},{8}}, {{245},{8}}, {{ 13},{8}}, {{141},{8}},\n{{ 77},{8}}, {{205},{8}}, {{ 45},{8}}, {{173},{8}}, {{109},{8}},\n{{237},{8}}, {{ 29},{8}}, {{157},{8}}, {{ 93},{8}}, {{221},{8}},\n{{ 61},{8}}, {{189},{8}}, {{125},{8}}, {{253},{8}}, {{ 19},{9}},\n{{275},{9}}, {{147},{9}}, {{403},{9}}, {{ 83},{9}}, {{339},{9}},\n{{211},{9}}, {{467},{9}}, {{ 51},{9}}, {{307},{9}}, {{179},{9}},\n{{435},{9}}, {{115},{9}}, {{371},{9}}, {{243},{9}}, {{499},{9}},\n{{ 11},{9}}, {{267},{9}}, {{139},{9}}, {{395},{9}}, {{ 75},{9}},\n{{331},{9}}, {{203},{9}}, {{459},{9}}, {{ 43},{9}}, {{299},{9}},\n{{171},{9}}, {{427},{9}}, {{107},{9}}, {{363},{9}}, {{235},{9}},\n{{491},{9}}, {{ 27},{9}}, {{283},{9}}, {{155},{9}}, {{411},{9}},\n{{ 91},{9}}, {{347},{9}}, {{219},{9}}, {{475},{9}}, {{ 59},{9}},\n{{315},{9}}, {{187},{9}}, {{443},{9}}, {{123},{9}}, {{379},{9}},\n{{251},{9}}, {{507},{9}}, {{  7},{9}}, {{263},{9}}, {{135},{9}},\n{{391},{9}}, {{ 71},{9}}, {{327},{9}}, {{199},{9}}, {{455},{9}},\n{{ 39},{9}}, {{295},{9}}, {{167},{9}}, {{423},{9}}, {{103},{9}},\n{{359},{9}}, {{231},{9}}, {{487},{9}}, {{ 23},{9}}, {{279},{9}},\n{{151},{9}}, {{407},{9}}, {{ 87},{9}}, {{343},{9}}, {{215},{9}},\n{{471},{9}}, {{ 55},{9}}, {{311},{9}}, {{183},{9}}, {{439},{9}},\n{{119},{9}}, {{375},{9}}, {{247},{9}}, {{503},{9}}, {{ 15},{9}},\n{{271},{9}}, {{143},{9}}, {{399},{9}}, {{ 79},{9}}, {{335},{9}},\n{{207},{9}}, {{463},{9}}, {{ 47},{9}}, {{303},{9}}, {{175},{9}},\n{{431},{9}}, {{111},{9}}, {{367},{9}}, {{239},{9}}, {{495},{9}},\n{{ 31},{9}}, {{287},{9}}, {{159},{9}}, {{415},{9}}, {{ 95},{9}},\n{{351},{9}}, {{223},{9}}, {{479},{9}}, {{ 63},{9}}, {{319},{9}},\n{{191},{9}}, {{447},{9}}, {{127},{9}}, {{383},{9}}, {{255},{9}},\n{{511},{9}}, {{  0},{7}}, {{ 64},{7}}, {{ 32},{7}}, {{ 96},{7}},\n{{ 16},{7}}, {{ 80},{7}}, {{ 48},{7}}, {{112},{7}}, {{  8},{7}},\n{{ 72},{7}}, {{ 40},{7}}, {{104},{7}}, {{ 24},{7}}, {{ 88},{7}},\n{{ 56},{7}}, {{120},{7}}, {{  4},{7}}, {{ 68},{7}}, {{ 36},{7}},\n{{100},{7}}, {{ 20},{7}}, {{ 84},{7}}, {{ 52},{7}}, {{116},{7}},\n{{  3},{8}}, {{131},{8}}, {{ 67},{8}}, {{195},{8}}, {{ 35},{8}},\n{{163},{8}}, {{ 99},{8}}, {{227},{8}}\n};\n\nZ_INTERNAL const ct_data static_dtree[D_CODES] = {\n{{ 0},{5}}, {{16},{5}}, {{ 8},{5}}, {{24},{5}}, {{ 4},{5}},\n{{20},{5}}, {{12},{5}}, {{28},{5}}, {{ 2},{5}}, {{18},{5}},\n{{10},{5}}, {{26},{5}}, {{ 6},{5}}, {{22},{5}}, {{14},{5}},\n{{30},{5}}, {{ 1},{5}}, {{17},{5}}, {{ 9},{5}}, {{25},{5}},\n{{ 5},{5}}, {{21},{5}}, {{13},{5}}, {{29},{5}}, {{ 3},{5}},\n{{19},{5}}, {{11},{5}}, {{27},{5}}, {{ 7},{5}}, {{23},{5}}\n};\n\nconst unsigned char Z_INTERNAL zng_dist_code[DIST_CODE_LEN] = {\n 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,\n 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,\n10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,\n13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,\n15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,\n18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,\n23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29\n};\n\nconst unsigned char Z_INTERNAL zng_length_code[STD_MAX_MATCH-STD_MIN_MATCH+1] = {\n 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,\n13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,\n17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,\n19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,\n22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,\n23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,\n26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28\n};\n\nZ_INTERNAL const int base_length[LENGTH_CODES] = {\n0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,\n64, 80, 96, 112, 128, 160, 192, 224, 0\n};\n\nZ_INTERNAL const int base_dist[D_CODES] = {\n    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,\n   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,\n 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576\n};\n\n#endif /* TREES_TBL_H_ */\n"
        },
        {
          "name": "uncompr.c",
          "type": "blob",
          "size": 2.9423828125,
          "content": "/* uncompr.c -- decompress a memory buffer\n * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil.h\"\n\n/* ===========================================================================\n     Decompresses the source buffer into the destination buffer.  *sourceLen is\n   the byte length of the source buffer. Upon entry, *destLen is the total size\n   of the destination buffer, which must be large enough to hold the entire\n   uncompressed data. (The size of the uncompressed data must have been saved\n   previously by the compressor and transmitted to the decompressor by some\n   mechanism outside the scope of this compression library.) Upon exit,\n   *destLen is the size of the decompressed data and *sourceLen is the number\n   of source bytes consumed. Upon return, source + *sourceLen points to the\n   first unused input byte.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or\n   Z_DATA_ERROR if the input data was corrupted, including if the input data is\n   an incomplete zlib stream.\n*/\nint Z_EXPORT PREFIX(uncompress2)(unsigned char *dest, z_uintmax_t *destLen, const unsigned char *source, z_uintmax_t *sourceLen) {\n    PREFIX3(stream) stream;\n    int err;\n    const unsigned int max = (unsigned int)-1;\n    z_uintmax_t len, left;\n    unsigned char buf[1];    /* for detection of incomplete stream when *destLen == 0 */\n\n    len = *sourceLen;\n    if (*destLen) {\n        left = *destLen;\n        *destLen = 0;\n    } else {\n        left = 1;\n        dest = buf;\n    }\n\n    stream.next_in = (z_const unsigned char *)source;\n    stream.avail_in = 0;\n    stream.zalloc = NULL;\n    stream.zfree = NULL;\n    stream.opaque = NULL;\n\n    err = PREFIX(inflateInit)(&stream);\n    if (err != Z_OK) return err;\n\n    stream.next_out = dest;\n    stream.avail_out = 0;\n\n    do {\n        if (stream.avail_out == 0) {\n            stream.avail_out = left > (unsigned long)max ? max : (unsigned int)left;\n            left -= stream.avail_out;\n        }\n        if (stream.avail_in == 0) {\n            stream.avail_in = len > (unsigned long)max ? max : (unsigned int)len;\n            len -= stream.avail_in;\n        }\n        err = PREFIX(inflate)(&stream, Z_NO_FLUSH);\n    } while (err == Z_OK);\n\n    *sourceLen -= len + stream.avail_in;\n    if (dest != buf)\n        *destLen = (z_size_t)stream.total_out;\n    else if (stream.total_out && err == Z_BUF_ERROR)\n        left = 1;\n\n    PREFIX(inflateEnd)(&stream);\n    return err == Z_STREAM_END ? Z_OK :\n           err == Z_NEED_DICT ? Z_DATA_ERROR  :\n           err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :\n           err;\n}\n\nint Z_EXPORT PREFIX(uncompress)(unsigned char *dest, z_uintmax_t *destLen, const unsigned char *source, z_uintmax_t sourceLen) {\n    return PREFIX(uncompress2)(dest, destLen, source, &sourceLen);\n}\n"
        },
        {
          "name": "win32",
          "type": "tree",
          "content": null
        },
        {
          "name": "zbuild.h",
          "type": "blob",
          "size": 10.8876953125,
          "content": "#ifndef _ZBUILD_H\n#define _ZBUILD_H\n\n#define _POSIX_SOURCE 1  /* fileno */\n#ifndef _POSIX_C_SOURCE\n#  define _POSIX_C_SOURCE 200809L /* snprintf, posix_memalign, strdup */\n#endif\n#ifndef _ISOC11_SOURCE\n#  define _ISOC11_SOURCE 1 /* aligned_alloc */\n#endif\n#ifdef __OpenBSD__\n#  define _BSD_SOURCE 1\n#endif\n\n#include <stddef.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n/* Determine compiler version of C Standard */\n#ifdef __STDC_VERSION__\n#  if __STDC_VERSION__ >= 199901L\n#    ifndef STDC99\n#      define STDC99\n#    endif\n#  endif\n#  if __STDC_VERSION__ >= 201112L\n#    ifndef STDC11\n#      define STDC11\n#    endif\n#  endif\n#endif\n\n#ifndef Z_HAS_ATTRIBUTE\n#  if defined(__has_attribute)\n#    define Z_HAS_ATTRIBUTE(a) __has_attribute(a)\n#  else\n#    define Z_HAS_ATTRIBUTE(a) 0\n#  endif\n#endif\n\n#ifndef Z_FALLTHROUGH\n#  if Z_HAS_ATTRIBUTE(__fallthrough__) || (defined(__GNUC__) && (__GNUC__ >= 7))\n#    define Z_FALLTHROUGH __attribute__((__fallthrough__))\n#  else\n#    define Z_FALLTHROUGH do {} while(0) /* fallthrough */\n#  endif\n#endif\n\n#ifndef Z_TARGET\n#  if Z_HAS_ATTRIBUTE(__target__)\n#    define Z_TARGET(x) __attribute__((__target__(x)))\n#  else\n#    define Z_TARGET(x)\n#  endif\n#endif\n\n/* This has to be first include that defines any types */\n#if defined(_MSC_VER)\n#  if defined(_WIN64)\n    typedef __int64 ssize_t;\n#  else\n    typedef long ssize_t;\n#  endif\n\n#  if defined(_WIN64)\n    #define SSIZE_MAX _I64_MAX\n#  else\n    #define SSIZE_MAX LONG_MAX\n#  endif\n#endif\n\n/* MS Visual Studio does not allow inline in C, only C++.\n   But it provides __inline instead, so use that. */\n#if defined(_MSC_VER) && !defined(inline) && !defined(__cplusplus)\n#  define inline __inline\n#endif\n\n#if defined(ZLIB_COMPAT)\n#  define PREFIX(x) x\n#  define PREFIX2(x) ZLIB_ ## x\n#  define PREFIX3(x) z_ ## x\n#  define PREFIX4(x) x ## 64\n#  define zVersion zlibVersion\n#else\n#  define PREFIX(x) zng_ ## x\n#  define PREFIX2(x) ZLIBNG_ ## x\n#  define PREFIX3(x) zng_ ## x\n#  define PREFIX4(x) zng_ ## x\n#  define zVersion zlibng_version\n#  define z_size_t size_t\n#endif\n\n/* In zlib-compat some functions and types use unsigned long, but zlib-ng use size_t */\n#if defined(ZLIB_COMPAT)\n#  define z_uintmax_t unsigned long\n#else\n#  define z_uintmax_t size_t\n#endif\n\n/* Minimum of a and b. */\n#define MIN(a, b) ((a) > (b) ? (b) : (a))\n/* Maximum of a and b. */\n#define MAX(a, b) ((a) < (b) ? (b) : (a))\n/* Ignore unused variable warning */\n#define Z_UNUSED(var) (void)(var)\n\n#if defined(HAVE_VISIBILITY_INTERNAL)\n#  define Z_INTERNAL __attribute__((visibility (\"internal\")))\n#elif defined(HAVE_VISIBILITY_HIDDEN)\n#  define Z_INTERNAL __attribute__((visibility (\"hidden\")))\n#else\n#  define Z_INTERNAL\n#endif\n\n/* Symbol versioning helpers, allowing multiple versions of a function to exist.\n * Functions using this must also be added to zlib-ng.map for each version.\n * Double @@ means this is the default for newly compiled applications to link against.\n * Single @ means this is kept for backwards compatibility.\n * This is only used for Zlib-ng native API, and only on platforms supporting this.\n */\n#if defined(HAVE_SYMVER)\n#  define ZSYMVER(func,alias,ver) __asm__(\".symver \" func \", \" alias \"@ZLIB_NG_\" ver);\n#  define ZSYMVER_DEF(func,alias,ver) __asm__(\".symver \" func \", \" alias \"@@ZLIB_NG_\" ver);\n#else\n#  define ZSYMVER(func,alias,ver)\n#  define ZSYMVER_DEF(func,alias,ver)\n#endif\n\n#ifndef __cplusplus\n#  define Z_REGISTER register\n#else\n#  define Z_REGISTER\n#endif\n\n/* Reverse the bytes in a value. Use compiler intrinsics when\n   possible to take advantage of hardware implementations. */\n#if defined(_MSC_VER) && (_MSC_VER >= 1300)\n#  include <stdlib.h>\n#  pragma intrinsic(_byteswap_ulong)\n#  define ZSWAP16(q) _byteswap_ushort(q)\n#  define ZSWAP32(q) _byteswap_ulong(q)\n#  define ZSWAP64(q) _byteswap_uint64(q)\n\n#elif defined(__clang__) || (defined(__GNUC__) && \\\n        (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)))\n#  define ZSWAP16(q) __builtin_bswap16(q)\n#  define ZSWAP32(q) __builtin_bswap32(q)\n#  define ZSWAP64(q) __builtin_bswap64(q)\n\n#elif defined(__GNUC__) && (__GNUC__ >= 2) && defined(__linux__)\n#  include <byteswap.h>\n#  define ZSWAP16(q) bswap_16(q)\n#  define ZSWAP32(q) bswap_32(q)\n#  define ZSWAP64(q) bswap_64(q)\n\n#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__)\n#  include <sys/endian.h>\n#  define ZSWAP16(q) bswap16(q)\n#  define ZSWAP32(q) bswap32(q)\n#  define ZSWAP64(q) bswap64(q)\n#elif defined(__OpenBSD__)\n#  include <sys/endian.h>\n#  define ZSWAP16(q) swap16(q)\n#  define ZSWAP32(q) swap32(q)\n#  define ZSWAP64(q) swap64(q)\n#elif defined(__INTEL_COMPILER)\n/* ICC does not provide a two byte swap. */\n#  define ZSWAP16(q) ((((q) & 0xff) << 8) | (((q) & 0xff00) >> 8))\n#  define ZSWAP32(q) _bswap(q)\n#  define ZSWAP64(q) _bswap64(q)\n\n#else\n#  define ZSWAP16(q) ((((q) & 0xff) << 8) | (((q) & 0xff00) >> 8))\n#  define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \\\n                     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))\n#  define ZSWAP64(q)                           \\\n         (((q & 0xFF00000000000000u) >> 56u) | \\\n          ((q & 0x00FF000000000000u) >> 40u) | \\\n          ((q & 0x0000FF0000000000u) >> 24u) | \\\n          ((q & 0x000000FF00000000u) >> 8u)  | \\\n          ((q & 0x00000000FF000000u) << 8u)  | \\\n          ((q & 0x0000000000FF0000u) << 24u) | \\\n          ((q & 0x000000000000FF00u) << 40u) | \\\n          ((q & 0x00000000000000FFu) << 56u))\n#endif\n\n/* Only enable likely/unlikely if the compiler is known to support it */\n#if (defined(__GNUC__) && (__GNUC__ >= 3)) || defined(__INTEL_COMPILER) || defined(__clang__)\n#  define LIKELY_NULL(x)        __builtin_expect((x) != 0, 0)\n#  define LIKELY(x)             __builtin_expect(!!(x), 1)\n#  define UNLIKELY(x)           __builtin_expect(!!(x), 0)\n#else\n#  define LIKELY_NULL(x)        x\n#  define LIKELY(x)             x\n#  define UNLIKELY(x)           x\n#endif /* (un)likely */\n\n#if defined(HAVE_ATTRIBUTE_ALIGNED)\n#  define ALIGNED_(x) __attribute__ ((aligned(x)))\n#elif defined(_MSC_VER)\n#  define ALIGNED_(x) __declspec(align(x))\n#else\n/* TODO: Define ALIGNED_ for your compiler */\n#  define ALIGNED_(x)\n#endif\n\n#ifdef HAVE_BUILTIN_ASSUME_ALIGNED\n#  define HINT_ALIGNED(p,n) __builtin_assume_aligned((void *)(p),(n))\n#else\n#  define HINT_ALIGNED(p,n) (p)\n#endif\n#define HINT_ALIGNED_16(p) HINT_ALIGNED((p),16)\n#define HINT_ALIGNED_64(p) HINT_ALIGNED((p),64)\n#define HINT_ALIGNED_4096(p) HINT_ALIGNED((p),4096)\n\n/* PADSZ returns needed bytes to pad bpos to pad size\n * PAD_NN calculates pad size and adds it to bpos, returning the result.\n * All take an integer or a pointer as bpos input.\n */\n#define PADSZ(bpos, pad) (((pad) - ((uintptr_t)(bpos) % (pad))) % (pad))\n#define PAD_16(bpos) ((bpos) + PADSZ((bpos),16))\n#define PAD_64(bpos) ((bpos) + PADSZ((bpos),64))\n#define PAD_4096(bpos) ((bpos) + PADSZ((bpos),4096))\n\n/* Diagnostic functions */\n#ifdef ZLIB_DEBUG\n#  include <stdio.h>\n   extern int Z_INTERNAL z_verbose;\n   extern void Z_INTERNAL z_error(const char *m);\n#  define Assert(cond, msg) {int _cond = (cond); if (!_cond) z_error(msg);}\n#  define Trace(x) {if (z_verbose >= 0) fprintf x;}\n#  define Tracev(x) {if (z_verbose > 0) fprintf x;}\n#  define Tracevv(x) {if (z_verbose > 1) fprintf x;}\n#  define Tracec(c, x) {if (z_verbose > 0 && (c)) fprintf x;}\n#  define Tracecv(c, x) {if (z_verbose > 1 && (c)) fprintf x;}\n#else\n#  define Assert(cond, msg)\n#  define Trace(x)\n#  define Tracev(x)\n#  define Tracevv(x)\n#  define Tracec(c, x)\n#  define Tracecv(c, x)\n#endif\n\n/* OPTIMAL_CMP values determine the comparison width:\n * 64: Best for 64-bit architectures with unaligned access\n * 32: Best for 32-bit architectures with unaligned access\n * 16: Safe default for unknown architectures\n * 8:  Safe fallback for architectures without unaligned access\n * Note: The unaligned access mentioned is cpu-support, this allows compiler or\n *       separate unaligned intrinsics to utilize safe unaligned access, without\n *       utilizing unaligned C pointers that are known to have undefined behavior.\n */\n#if !defined(OPTIMAL_CMP)\n#  if defined(__x86_64__) || defined(_M_X64) || defined(__amd64__) || defined(_M_AMD64)\n#    define OPTIMAL_CMP 64\n#  elif defined(__i386__) || defined(__i486__) || defined(__i586__) || \\\n        defined(__i686__) || defined(_X86_) || defined(_M_IX86)\n#    define OPTIMAL_CMP 32\n#  elif defined(__aarch64__) || defined(_M_ARM64) || defined(_M_ARM64EC)\n#    if defined(__ARM_FEATURE_UNALIGNED) || defined(_WIN32)\n#      define OPTIMAL_CMP 64\n#    else\n#      define OPTIMAL_CMP 8\n#    endif\n#  elif defined(__arm__) || defined(_M_ARM)\n#    if defined(__ARM_FEATURE_UNALIGNED) || defined(_WIN32)\n#      define OPTIMAL_CMP 32\n#    else\n#      define OPTIMAL_CMP 8\n#    endif\n#  elif defined(__powerpc64__) || defined(__ppc64__)\n#    define OPTIMAL_CMP 64\n#  elif defined(__powerpc__) || defined(__ppc__) || defined(__PPC__)\n#    define OPTIMAL_CMP 32\n#  endif\n#endif\n#if !defined(OPTIMAL_CMP)\n#  define OPTIMAL_CMP 16\n#endif\n\n#if defined(__has_feature)\n#  if __has_feature(address_sanitizer)\n#    define Z_ADDRESS_SANITIZER 1\n#  endif\n#elif defined(__SANITIZE_ADDRESS__)\n#  define Z_ADDRESS_SANITIZER 1\n#endif\n\n/*\n * __asan_loadN() and __asan_storeN() calls are inserted by compilers in order to check memory accesses.\n * They can be called manually too, with the following caveats:\n * gcc says: \"warning: implicit declaration of function '...'\"\n * g++ says: \"error: new declaration '...' ambiguates built-in declaration '...'\"\n * Accommodate both.\n */\n#ifdef Z_ADDRESS_SANITIZER\n#ifndef __cplusplus\nvoid __asan_loadN(void *, long);\nvoid __asan_storeN(void *, long);\n#endif\n#else\n#  define __asan_loadN(a, size) do { Z_UNUSED(a); Z_UNUSED(size); } while (0)\n#  define __asan_storeN(a, size) do { Z_UNUSED(a); Z_UNUSED(size); } while (0)\n#endif\n\n#if defined(__has_feature)\n#  if __has_feature(memory_sanitizer)\n#    define Z_MEMORY_SANITIZER 1\n#    include <sanitizer/msan_interface.h>\n#  endif\n#endif\n\n#ifndef Z_MEMORY_SANITIZER\n#  define __msan_check_mem_is_initialized(a, size) do { Z_UNUSED(a); Z_UNUSED(size); } while (0)\n#  define __msan_unpoison(a, size) do { Z_UNUSED(a); Z_UNUSED(size); } while (0)\n#endif\n\n/* Notify sanitizer runtime about an upcoming read access. */\n#define instrument_read(a, size) do {             \\\n    void *__a = (void *)(a);                      \\\n    long __size = size;                           \\\n    __asan_loadN(__a, __size);                    \\\n    __msan_check_mem_is_initialized(__a, __size); \\\n} while (0)\n\n/* Notify sanitizer runtime about an upcoming write access. */\n#define instrument_write(a, size) do { \\\n   void *__a = (void *)(a);            \\\n   long __size = size;                 \\\n   __asan_storeN(__a, __size);         \\\n} while (0)\n\n/* Notify sanitizer runtime about an upcoming read/write access. */\n#define instrument_read_write(a, size) do {       \\\n    void *__a = (void *)(a);                      \\\n    long __size = size;                           \\\n    __asan_storeN(__a, __size);                   \\\n    __msan_check_mem_is_initialized(__a, __size); \\\n} while (0)\n\n#endif\n"
        },
        {
          "name": "zconf-ng.h.in",
          "type": "blob",
          "size": 4.92578125,
          "content": "/* zconf-ng.h -- configuration of the zlib-ng compression library\n * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef ZCONFNG_H\n#define ZCONFNG_H\n\n#include \"zlib_name_mangling-ng.h\"\n\n#if !defined(_WIN32) && defined(__WIN32__)\n#  define _WIN32\n#endif\n\n/* Clang macro for detecting declspec support\n * https://clang.llvm.org/docs/LanguageExtensions.html#has-declspec-attribute\n */\n#ifndef __has_declspec_attribute\n#  define __has_declspec_attribute(x) 0\n#endif\n\n/* Always define z_const as const */\n#define z_const const\n\n/* Maximum value for memLevel in deflateInit2 */\n#ifndef MAX_MEM_LEVEL\n#  define MAX_MEM_LEVEL 9\n#endif\n\n/* Maximum value for windowBits in deflateInit2 and inflateInit2.\n * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files\n * created by gzip. (Files created by minigzip can still be extracted by\n * gzip.)\n */\n#ifndef MIN_WBITS\n#  define MIN_WBITS   8  /* 256 LZ77 window */\n#endif\n#ifndef MAX_WBITS\n#  define MAX_WBITS   15 /* 32K LZ77 window */\n#endif\n\n/* The memory requirements for deflate are (in bytes):\n            (1 << (windowBits+2)) +  (1 << (memLevel+9))\n that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n plus a few kilobytes for small objects. For example, if you want to reduce\n the default memory requirements from 256K to 128K, compile with\n     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n Of course this will generally degrade compression (there's no free lunch).\n\n   The memory requirements for inflate are (in bytes) 1 << windowBits\n that is, 32K for windowBits=15 (default value) plus about 7 kilobytes\n for small objects.\n*/\n\n/* Type declarations */\n\n#ifdef ZLIB_INTERNAL\n#  define Z_INTERNAL ZLIB_INTERNAL\n#endif\n\n/* If building or using zlib as a DLL, define ZLIB_DLL.\n * This is not mandatory, but it offers a little performance increase.\n */\n#if defined(ZLIB_DLL) && (defined(_WIN32) || (__has_declspec_attribute(dllexport) && __has_declspec_attribute(dllimport)))\n#  ifdef Z_INTERNAL\n#    define Z_EXTERN extern __declspec(dllexport)\n#  else\n#    define Z_EXTERN extern __declspec(dllimport)\n#  endif\n#endif\n\n/* If building or using zlib with the WINAPI/WINAPIV calling convention,\n * define ZLIB_WINAPI.\n * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.\n */\n#if defined(ZLIB_WINAPI) && defined(_WIN32)\n#  include <windows.h>\n   /* No need for _export, use ZLIB.DEF instead. */\n   /* For complete Windows compatibility, use WINAPI, not __stdcall. */\n#  define Z_EXPORT WINAPI\n#  define Z_EXPORTVA WINAPIV\n#endif\n\n#ifndef Z_EXTERN\n#  define Z_EXTERN extern\n#endif\n#ifndef Z_EXPORT\n#  define Z_EXPORT\n#endif\n#ifndef Z_EXPORTVA\n#  define Z_EXPORTVA\n#endif\n\n/* Conditional exports */\n#define ZNG_CONDEXPORT Z_EXPORT\n\n/* Fallback for something that includes us. */\ntypedef unsigned char Byte;\ntypedef Byte Bytef;\n\ntypedef unsigned int   uInt;  /* 16 bits or more */\ntypedef unsigned long  uLong; /* 32 bits or more */\n\ntypedef char  charf;\ntypedef int   intf;\ntypedef uInt  uIntf;\ntypedef uLong uLongf;\n\ntypedef void const *voidpc;\ntypedef void       *voidpf;\ntypedef void       *voidp;\n\n#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by configure/cmake/etc */\n#  define Z_HAVE_UNISTD_H\n#endif\n\n#ifdef NEED_PTRDIFF_T    /* may be set to #if 1 by configure/cmake/etc */\ntypedef PTRDIFF_TYPE ptrdiff_t;\n#endif\n\n#include <sys/types.h>      /* for off_t */\n\n#include <stddef.h>         /* for wchar_t and NULL */\n\n/* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n * \"#define _LARGEFILE64_SOURCE 1\" as requesting 64-bit operations, (even\n * though the former does not conform to the LFS document), but considering\n * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n * equivalently requesting no 64-bit operations\n */\n#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n#  undef _LARGEFILE64_SOURCE\n#endif\n\n#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)\n#  include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n#  ifndef z_off_t\n#    define z_off_t off_t\n#  endif\n#endif\n\n#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n#  define Z_LFS64\n#endif\n\n#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n#  define Z_LARGE64\n#endif\n\n#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n#  define Z_WANT64\n#endif\n\n#if !defined(SEEK_SET) && defined(WITH_GZFILEOP)\n#  define SEEK_SET        0       /* Seek from beginning of file.  */\n#  define SEEK_CUR        1       /* Seek from current position.  */\n#  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n#endif\n\n#ifndef z_off_t\n#  define z_off_t long\n#endif\n\n#if !defined(_WIN32) && defined(Z_LARGE64)\n#  define z_off64_t off64_t\n#else\n#  if defined(__MSYS__)\n#    define z_off64_t _off64_t\n#  elif defined(_WIN32) && !defined(__GNUC__)\n#    define z_off64_t __int64\n#  else\n#    define z_off64_t z_off_t\n#  endif\n#endif\n\n#endif /* ZCONFNG_H */\n"
        },
        {
          "name": "zconf.h.in",
          "type": "blob",
          "size": 5.3837890625,
          "content": "/* zconf.h -- configuration of the zlib compression library\n * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef ZCONF_H\n#define ZCONF_H\n\n#include \"zlib_name_mangling.h\"\n\n#if !defined(_WIN32) && defined(__WIN32__)\n#  define _WIN32\n#endif\n\n/* Clang macro for detecting declspec support\n * https://clang.llvm.org/docs/LanguageExtensions.html#has-declspec-attribute\n */\n#ifndef __has_declspec_attribute\n#  define __has_declspec_attribute(x) 0\n#endif\n\n#if defined(ZLIB_CONST) && !defined(z_const)\n#  define z_const const\n#else\n#  define z_const\n#endif\n\n/* Maximum value for memLevel in deflateInit2 */\n#ifndef MAX_MEM_LEVEL\n#  define MAX_MEM_LEVEL 9\n#endif\n\n/* Maximum value for windowBits in deflateInit2 and inflateInit2.\n * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files\n * created by gzip. (Files created by minigzip can still be extracted by\n * gzip.)\n */\n#ifndef MIN_WBITS\n#  define MIN_WBITS   8  /* 256 LZ77 window */\n#endif\n#ifndef MAX_WBITS\n#  define MAX_WBITS   15 /* 32K LZ77 window */\n#endif\n\n/* The memory requirements for deflate are (in bytes):\n            (1 << (windowBits+2)) +  (1 << (memLevel+9))\n that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n plus a few kilobytes for small objects. For example, if you want to reduce\n the default memory requirements from 256K to 128K, compile with\n     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n Of course this will generally degrade compression (there's no free lunch).\n\n   The memory requirements for inflate are (in bytes) 1 << windowBits\n that is, 32K for windowBits=15 (default value) plus about 7 kilobytes\n for small objects.\n*/\n\n/* Type declarations */\n\n\n#ifndef OF /* function prototypes */\n#  define OF(args)  args\n#endif\n\n#ifdef ZLIB_INTERNAL\n#  define Z_INTERNAL ZLIB_INTERNAL\n#endif\n\n/* If building or using zlib as a DLL, define ZLIB_DLL.\n * This is not mandatory, but it offers a little performance increase.\n */\n#if defined(ZLIB_DLL) && (defined(_WIN32) || (__has_declspec_attribute(dllexport) && __has_declspec_attribute(dllimport)))\n#  ifdef Z_INTERNAL\n#    define Z_EXTERN extern __declspec(dllexport)\n#  else\n#    define Z_EXTERN extern __declspec(dllimport)\n#  endif\n#endif\n\n/* If building or using zlib with the WINAPI/WINAPIV calling convention,\n * define ZLIB_WINAPI.\n * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.\n */\n#if defined(ZLIB_WINAPI) && defined(_WIN32)\n#  ifndef WIN32_LEAN_AND_MEAN\n#    define WIN32_LEAN_AND_MEAN\n#  endif\n#  include <windows.h>\n   /* No need for _export, use ZLIB.DEF instead. */\n   /* For complete Windows compatibility, use WINAPI, not __stdcall. */\n#  define Z_EXPORT WINAPI\n#  define Z_EXPORTVA WINAPIV\n#endif\n\n#ifndef Z_EXTERN\n#  define Z_EXTERN extern\n#endif\n#ifndef Z_EXPORT\n#  define Z_EXPORT\n#endif\n#ifndef Z_EXPORTVA\n#  define Z_EXPORTVA\n#endif\n\n/* Conditional exports */\n#define ZNG_CONDEXPORT Z_INTERNAL\n\n/* For backwards compatibility */\n\n#ifndef ZEXTERN\n#  define ZEXTERN Z_EXTERN\n#endif\n#ifndef ZEXPORT\n#  define ZEXPORT Z_EXPORT\n#endif\n#ifndef ZEXPORTVA\n#  define ZEXPORTVA Z_EXPORTVA\n#endif\n#ifndef FAR\n#  define FAR\n#endif\n\n/* Legacy zlib typedefs for backwards compatibility. Don't assume stdint.h is defined. */\ntypedef unsigned char Byte;\ntypedef Byte Bytef;\n\ntypedef unsigned int   uInt;  /* 16 bits or more */\ntypedef unsigned long  uLong; /* 32 bits or more */\n\ntypedef char  charf;\ntypedef int   intf;\ntypedef uInt  uIntf;\ntypedef uLong uLongf;\n\ntypedef void const *voidpc;\ntypedef void       *voidpf;\ntypedef void       *voidp;\n\ntypedef unsigned int z_crc_t;\n\n#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by configure/cmake/etc */\n#  define Z_HAVE_UNISTD_H\n#endif\n\n#ifdef NEED_PTRDIFF_T    /* may be set to #if 1 by configure/cmake/etc */\ntypedef PTRDIFF_TYPE ptrdiff_t;\n#endif\n\n#include <sys/types.h>      /* for off_t */\n\n#include <stddef.h>         /* for wchar_t and NULL */\n\n/* a little trick to accommodate both \"#define _LARGEFILE64_SOURCE\" and\n * \"#define _LARGEFILE64_SOURCE 1\" as requesting 64-bit operations, (even\n * though the former does not conform to the LFS document), but considering\n * both \"#undef _LARGEFILE64_SOURCE\" and \"#define _LARGEFILE64_SOURCE 0\" as\n * equivalently requesting no 64-bit operations\n */\n#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1\n#  undef _LARGEFILE64_SOURCE\n#endif\n\n#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)\n#  include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n#  ifndef z_off_t\n#    define z_off_t off_t\n#  endif\n#endif\n\n#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0\n#  define Z_LFS64\n#endif\n\n#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)\n#  define Z_LARGE64\n#endif\n\n#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)\n#  define Z_WANT64\n#endif\n\n#if !defined(SEEK_SET)\n#  define SEEK_SET        0       /* Seek from beginning of file.  */\n#  define SEEK_CUR        1       /* Seek from current position.  */\n#  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n#endif\n\n#ifndef z_off_t\n#  define z_off_t long\n#endif\n\n#if !defined(_WIN32) && defined(Z_LARGE64)\n#  define z_off64_t off64_t\n#else\n#  if defined(__MSYS__)\n#    define z_off64_t _off64_t\n#  elif defined(_WIN32) && !defined(__GNUC__)\n#    define z_off64_t __int64\n#  else\n#    define z_off64_t z_off_t\n#  endif\n#endif\n\ntypedef size_t z_size_t;\n\n#endif /* ZCONF_H */\n"
        },
        {
          "name": "zendian.h",
          "type": "blob",
          "size": 1.6650390625,
          "content": "/* zendian.h -- define BYTE_ORDER for endian tests\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef ENDIAN_H_\n#define ENDIAN_H_\n\n/* First check whether the compiler knows the target __BYTE_ORDER__. */\n#if defined(__BYTE_ORDER__)\n#  if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#    if !defined(LITTLE_ENDIAN)\n#      define LITTLE_ENDIAN __ORDER_LITTLE_ENDIAN__\n#    endif\n#    if !defined(BYTE_ORDER)\n#      define BYTE_ORDER LITTLE_ENDIAN\n#    endif\n#  elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#    if !defined(BIG_ENDIAN)\n#      define BIG_ENDIAN __ORDER_BIG_ENDIAN__\n#    endif\n#    if !defined(BYTE_ORDER)\n#      define BYTE_ORDER BIG_ENDIAN\n#    endif\n#  endif\n#elif defined(__MINGW32__)\n#  include <sys/param.h>\n#elif defined(_WIN32)\n#  define LITTLE_ENDIAN 1234\n#  define BIG_ENDIAN 4321\n#  if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64) || defined (_M_ARM) || defined (_M_ARM64) || defined (_M_ARM64EC)\n#    define BYTE_ORDER LITTLE_ENDIAN\n#  else\n#    error Unknown endianness!\n#  endif\n#elif defined(__linux__)\n#  include <endian.h>\n#elif defined(__APPLE__)\n#  include <machine/endian.h>\n#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__) || defined(__DragonFly__)\n#  include <sys/endian.h>\n#elif defined(__sun) || defined(sun)\n#  include <sys/byteorder.h>\n#  if !defined(LITTLE_ENDIAN)\n#    define LITTLE_ENDIAN 4321\n#   endif\n#  if !defined(BIG_ENDIAN)\n#    define BIG_ENDIAN 1234\n#  endif\n#  if !defined(BYTE_ORDER)\n#    if defined(_BIG_ENDIAN)\n#      define BYTE_ORDER BIG_ENDIAN\n#    else\n#      define BYTE_ORDER LITTLE_ENDIAN\n#    endif\n#  endif\n#else\n#  include <endian.h>\n#endif\n\n#endif\n"
        },
        {
          "name": "zlib-config.cmake.in",
          "type": "blob",
          "size": 0.3271484375,
          "content": "set(ZLIB_VERSION @ZLIB_HEADER_VERSION@)\n\n@PACKAGE_INIT@\n\nset_and_check(ZLIB_INCLUDE_DIR \"@PACKAGE_INCLUDE_INSTALL_DIR@\")\nset(ZLIB_INCLUDE_DIRS \"${ZLIB_INCLUDE_DIR}\")\nset_and_check(ZLIB_LIB_DIR \"@PACKAGE_LIB_INSTALL_DIR@\")\nset(ZLIB_LIBRARIES ZLIB::ZLIB)\n\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/ZLIB.cmake\")\n\ncheck_required_components(ZLIB)\n"
        },
        {
          "name": "zlib-ng-config.cmake.in",
          "type": "blob",
          "size": 0.26953125,
          "content": "set(zlib-ng_VERSION @ZLIBNG_HEADER_VERSION@)\n\n@PACKAGE_INIT@\n\nset_and_check(zlib-ng_INCLUDE_DIR \"@PACKAGE_INCLUDE_INSTALL_DIR@\")\nset_and_check(zlib-ng_LIB_DIR \"@PACKAGE_LIB_INSTALL_DIR@\")\n\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/zlib-ng.cmake\")\n\ncheck_required_components(zlib-ng)\n"
        },
        {
          "name": "zlib-ng.h.in",
          "type": "blob",
          "size": 90.6484375,
          "content": "#ifndef ZNGLIB_H_\n#define ZNGLIB_H_\n/* zlib-ng.h -- interface of the 'zlib-ng' compression library, forked from zlib.\n\n  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\n\n  The data format used by the zlib library is described by RFCs (Request for\n  Comments) 1950 to 1952 in the files https://tools.ietf.org/html/rfc1950\n  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).\n*/\n\n#ifdef ZLIB_H_\n#  error Include zlib-ng.h for zlib-ng API or zlib.h for zlib-compat API but not both\n#endif\n\n#ifndef RC_INVOKED\n#include <stdint.h>\n#include <stdarg.h>\n\n#include \"zconf-ng.h\"\n\n#ifndef ZCONFNG_H\n#  error Missing zconf-ng.h add binary output directory to include directories\n#endif\n#endif  /* RC_INVOKED */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ZLIBNG_VERSION \"2.2.3\"\n#define ZLIBNG_VERNUM 0x020203F0L   /* MMNNRRSM: major minor revision status modified */\n#define ZLIBNG_VER_MAJOR 2\n#define ZLIBNG_VER_MINOR 2\n#define ZLIBNG_VER_REVISION 3\n#define ZLIBNG_VER_STATUS F         /* 0=devel, 1-E=beta, F=Release (DEPRECATED) */\n#define ZLIBNG_VER_STATUSH 0xF      /* Hex values: 0=devel, 1-E=beta, F=Release */\n#define ZLIBNG_VER_MODIFIED 0       /* non-zero if modified externally from zlib-ng */\n\n/*\n    The 'zlib' compression library provides in-memory compression and\n  decompression functions, including integrity checks of the uncompressed data.\n  This version of the library supports only one compression method (deflation)\n  but other algorithms will be added later and will have the same stream\n  interface.\n\n    Compression can be done in a single step if the buffers are large enough,\n  or can be done by repeated calls of the compression function.  In the latter\n  case, the application must provide more input and/or consume the output\n  (providing more output space) before each call.\n\n    The compressed data format used by default by the in-memory functions is\n  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped\n  around a deflate stream, which is itself documented in RFC 1951.\n\n    The library also supports reading and writing files in gzip (.gz) format\n  with an interface similar to that of stdio using the functions that start\n  with \"gz\".  The gzip format is different from the zlib format.  gzip is a\n  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.\n\n    This library can optionally read and write gzip and raw deflate streams in\n  memory as well.\n\n    The zlib format was designed to be compact and fast for use in memory\n  and on communications channels.  The gzip format was designed for single-\n  file compression on file systems, has a larger header than zlib to maintain\n  directory information, and uses a different, slower check method than zlib.\n\n    The library does not install any signal handler.  The decoder checks\n  the consistency of the compressed data, so the library should never crash\n  even in the case of corrupted input.\n*/\n\ntypedef void *(*alloc_func) (void *opaque, unsigned int items, unsigned int size);\ntypedef void  (*free_func)  (void *opaque, void *address);\n\nstruct internal_state;\n\ntypedef struct zng_stream_s {\n    const uint8_t         *next_in;   /* next input byte */\n    uint32_t              avail_in;   /* number of bytes available at next_in */\n    size_t                total_in;   /* total number of input bytes read so far */\n\n    uint8_t               *next_out;  /* next output byte will go here */\n    uint32_t              avail_out;  /* remaining free space at next_out */\n    size_t                total_out;  /* total number of bytes output so far */\n\n    const char            *msg;       /* last error message, NULL if no error */\n    struct internal_state *state;     /* not visible by applications */\n\n    alloc_func            zalloc;     /* used to allocate the internal state */\n    free_func             zfree;      /* used to free the internal state */\n    void                  *opaque;    /* private data object passed to zalloc and zfree */\n\n    int                   data_type;  /* best guess about the data type: binary or text\n                                         for deflate, or the decoding state for inflate */\n    uint32_t              adler;      /* Adler-32 or CRC-32 value of the uncompressed data */\n    unsigned long         reserved;   /* reserved for future use */\n} zng_stream;\n\ntypedef zng_stream *zng_streamp;  /* Obsolete type, retained for compatibility only */\n\n/*\n    gzip header information passed to and from zlib routines.  See RFC 1952\n  for more details on the meanings of these fields.\n*/\ntypedef struct zng_gz_header_s {\n    int32_t         text;       /* true if compressed data believed to be text */\n    unsigned long   time;       /* modification time */\n    int32_t         xflags;     /* extra flags (not used when writing a gzip file) */\n    int32_t         os;         /* operating system */\n    uint8_t         *extra;     /* pointer to extra field or NULL if none */\n    uint32_t        extra_len;  /* extra field length (valid if extra != NULL) */\n    uint32_t        extra_max;  /* space at extra (only when reading header) */\n    uint8_t         *name;      /* pointer to zero-terminated file name or NULL */\n    uint32_t        name_max;   /* space at name (only when reading header) */\n    uint8_t         *comment;   /* pointer to zero-terminated comment or NULL */\n    uint32_t        comm_max;   /* space at comment (only when reading header) */\n    int32_t         hcrc;       /* true if there was or will be a header crc */\n    int32_t         done;       /* true when done reading gzip header (not used when writing a gzip file) */\n} zng_gz_header;\n\ntypedef zng_gz_header *zng_gz_headerp;\n\n/*\n     The application must update next_in and avail_in when avail_in has dropped\n   to zero.  It must update next_out and avail_out when avail_out has dropped\n   to zero.  The application must initialize zalloc, zfree and opaque before\n   calling the init function.  All other fields are set by the compression\n   library and must not be updated by the application.\n\n     The opaque value provided by the application will be passed as the first\n   parameter for calls of zalloc and zfree.  This can be useful for custom\n   memory management.  The compression library attaches no meaning to the\n   opaque value.\n\n     zalloc must return NULL if there is not enough memory for the object.\n   If zlib is used in a multi-threaded application, zalloc and zfree must be\n   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are\n   Z_NULL on entry to the initialization function, they are set to internal\n   routines that use the standard library functions malloc() and free().\n\n     The fields total_in and total_out can be used for statistics or progress\n   reports.  After compression, total_in holds the total size of the\n   uncompressed data and may be saved for use by the decompressor (particularly\n   if the decompressor wants to decompress everything in a single step).\n*/\n\n                        /* constants */\n\n#define Z_NO_FLUSH      0\n#define Z_PARTIAL_FLUSH 1\n#define Z_SYNC_FLUSH    2\n#define Z_FULL_FLUSH    3\n#define Z_FINISH        4\n#define Z_BLOCK         5\n#define Z_TREES         6\n/* Allowed flush values; see deflate() and inflate() below for details */\n\n#define Z_OK            0\n#define Z_STREAM_END    1\n#define Z_NEED_DICT     2\n#define Z_ERRNO        (-1)\n#define Z_STREAM_ERROR (-2)\n#define Z_DATA_ERROR   (-3)\n#define Z_MEM_ERROR    (-4)\n#define Z_BUF_ERROR    (-5)\n#define Z_VERSION_ERROR (-6)\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\n\n#define Z_NO_COMPRESSION         0\n#define Z_BEST_SPEED             1\n#define Z_BEST_COMPRESSION       9\n#define Z_DEFAULT_COMPRESSION  (-1)\n/* compression levels */\n\n#define Z_FILTERED            1\n#define Z_HUFFMAN_ONLY        2\n#define Z_RLE                 3\n#define Z_FIXED               4\n#define Z_DEFAULT_STRATEGY    0\n/* compression strategy; see deflateInit2() below for details */\n\n#define Z_BINARY   0\n#define Z_TEXT     1\n#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */\n#define Z_UNKNOWN  2\n/* Possible values of the data_type field for deflate() */\n\n#define Z_DEFLATED   8\n/* The deflate compression method (the only one supported in this version) */\n\n#define Z_NULL  NULL  /* for compatibility with zlib, was for initializing zalloc, zfree, opaque */\n\n\n                        /* basic functions */\n\nZ_EXTERN Z_EXPORT\nconst char *zlibng_version(void);\n/* The application can compare zlibng_version and ZLIBNG_VERSION for consistency.\n   If the first character differs, the library code actually used is not\n   compatible with the zlib-ng.h header file used by the application.\n */\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateInit(zng_stream *strm, int32_t level);\n/*\n     Initializes the internal stream state for compression.  The fields\n   zalloc, zfree and opaque must be initialized before by the caller.  If\n   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default\n   allocation functions.  total_in, total_out, adler, and msg are initialized.\n\n     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:\n   1 gives best speed, 9 gives best compression, 0 gives no compression at all\n   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION\n   requests a default compromise between speed and compression (currently\n   equivalent to level 6).\n\n     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if level is not a valid compression level.\n   msg is set to null if there is no error message.  deflateInit does not perform\n   any compression: this will be done by deflate().\n*/\n\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflate(zng_stream *strm, int32_t flush);\n/*\n    deflate compresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n    The detailed semantics are as follows.  deflate performs one or both of the\n  following actions:\n\n  - Compress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), next_in and avail_in are updated and\n    processing will resume at this point for the next call of deflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  This action is forced if the parameter flush is non zero.\n    Forcing flush frequently degrades the compression ratio, so this parameter\n    should be set only when necessary.  Some output may be provided even if\n    flush is zero.\n\n    Before the call of deflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating avail_in or avail_out accordingly; avail_out should\n  never be zero before the call.  The application can consume the compressed\n  output when it wants, for example when the output buffer is full (avail_out\n  == 0), or after each call of deflate().  If deflate returns Z_OK and with\n  zero avail_out, it must be called again after making room in the output\n  buffer because there might be more output pending. See deflatePending(),\n  which can be used if desired to determine whether or not there is more output\n  in that case.\n\n    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to\n  decide how much data to accumulate before producing output, in order to\n  maximize compression.\n\n    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is\n  flushed to the output buffer and the output is aligned on a byte boundary, so\n  that the decompressor can get all input data available so far.  (In\n  particular avail_in is zero after the call if enough output space has been\n  provided before the call.) Flushing may degrade compression for some\n  compression algorithms and so it should be used only when necessary.  This\n  completes the current deflate block and follows it with an empty stored block\n  that is three bits plus filler bits to the next byte, followed by four bytes\n  (00 00 ff ff).\n\n    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the\n  output buffer, but the output is not aligned to a byte boundary.  All of the\n  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.\n  This completes the current deflate block and follows it with an empty fixed\n  codes block that is 10 bits long.  This assures that enough bytes are output\n  in order for the decompressor to finish the block before the empty fixed\n  codes block.\n\n    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as\n  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to\n  seven bits of the current block are held to be written as the next byte after\n  the next deflate block is completed.  In this case, the decompressor may not\n  be provided enough bits at this point in order to complete decompression of\n  the data provided so far to the compressor.  It may need to wait for the next\n  block to be emitted.  This is for advanced applications that need to control\n  the emission of deflate blocks.\n\n    If flush is set to Z_FULL_FLUSH, all output is flushed as with\n  Z_SYNC_FLUSH, and the compression state is reset so that decompression can\n  restart from this point if previous compressed data has been damaged or if\n  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade\n  compression.\n\n    If deflate returns with avail_out == 0, this function must be called again\n  with the same value of the flush parameter and more output space (updated\n  avail_out), until the flush is complete (deflate returns with non-zero\n  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that\n  avail_out is greater than six when the flush marker begins, in order to avoid\n  repeated flush markers upon calling deflate() again when avail_out == 0.\n\n    If the parameter flush is set to Z_FINISH, pending input is processed,\n  pending output is flushed and deflate returns with Z_STREAM_END if there was\n  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this\n  function must be called again with Z_FINISH and more output space (updated\n  avail_out) but no more input data, until it returns with Z_STREAM_END or an\n  error.  After deflate has returned Z_STREAM_END, the only possible operations\n  on the stream are deflateReset or deflateEnd.\n\n    Z_FINISH can be used in the first deflate call after deflateInit if all the\n  compression is to be done in a single step.  In order to complete in one\n  call, avail_out must be at least the value returned by deflateBound (see\n  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough\n  output space is provided, deflate will not return Z_STREAM_END, and it must\n  be called again as described above.\n\n    deflate() sets strm->adler to the Adler-32 checksum of all input read\n  so far (that is, total_in bytes).  If a gzip stream is being generated, then\n  strm->adler will be the CRC-32 checksum of the input read so far.  (See\n  deflateInit2 below.)\n\n    deflate() may update strm->data_type if it can make a good guess about\n  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is\n  considered binary.  This field is only for information purposes and does not\n  affect the compression algorithm in any manner.\n\n    deflate() returns Z_OK if some progress has been made (more input\n  processed or more output produced), Z_STREAM_END if all input has been\n  consumed and all output has been produced (only when flush is set to\n  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example\n  if next_in or next_out was NULL) or the state was inadvertently written over\n  by the application), or Z_BUF_ERROR if no progress is possible (for example\n  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and\n  deflate() can be called again with more input and more output space to\n  continue compressing.\n*/\n\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateEnd(zng_stream *strm);\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the\n   stream state was inconsistent, Z_DATA_ERROR if the stream was freed\n   prematurely (some input or output was discarded).  In the error case, msg\n   may be set but then points to a static string (which must not be\n   deallocated).\n*/\n\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateInit(zng_stream *strm);\n/*\n     Initializes the internal stream state for decompression.  The fields\n   next_in, avail_in, zalloc, zfree and opaque must be initialized before by\n   the caller.  In the current version of inflate, the provided input is not\n   read or consumed.  The allocation of a sliding window will be deferred to\n   the first call of inflate (if the decompression does not complete on the\n   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates\n   them to use default allocation functions.  total_in, total_out, adler, and\n   msg are initialized.\n\n     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, or Z_STREAM_ERROR if the parameters are invalid, such as a null\n   pointer to the structure.  msg is set to null if there is no error message.\n   inflateInit does not perform any decompression. Actual decompression will\n   be done by inflate().  So next_in, and avail_in, next_out, and avail_out\n   are unused and unchanged.  The current implementation of inflateInit()\n   does not process any header information -- that is deferred until inflate()\n   is called.\n*/\n\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflate(zng_stream *strm, int32_t flush);\n/*\n    inflate decompresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n  The detailed semantics are as follows.  inflate performs one or both of the\n  following actions:\n\n  - Decompress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), then next_in and avail_in are updated\n    accordingly, and processing will resume at this point for the next call of\n    inflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  inflate() provides as much output as possible, until there is\n    no more input data or no more space in the output buffer (see below about\n    the flush parameter).\n\n    Before the call of inflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating the next_* and avail_* values accordingly.  If the\n  caller of inflate() does not provide both available input and available\n  output space, it is possible that there will be no progress made.  The\n  application can consume the uncompressed output when it wants, for example\n  when the output buffer is full (avail_out == 0), or after each call of\n  inflate().  If inflate returns Z_OK and with zero avail_out, it must be\n  called again after making room in the output buffer because there might be\n  more output pending.\n\n    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,\n  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much\n  output as possible to the output buffer.  Z_BLOCK requests that inflate()\n  stop if and when it gets to the next deflate block boundary.  When decoding\n  the zlib or gzip format, this will cause inflate() to return immediately\n  after the header and before the first block.  When doing a raw inflate,\n  inflate() will go ahead and process the first block, and will return when it\n  gets to the end of that block, or when it runs out of data.\n\n    The Z_BLOCK option assists in appending to or combining deflate streams.\n  To assist in this, on return inflate() always sets strm->data_type to the\n  number of unused bits in the last byte taken from strm->next_in, plus 64 if\n  inflate() is currently decoding the last block in the deflate stream, plus\n  128 if inflate() returned immediately after decoding an end-of-block code or\n  decoding the complete header up to just before the first byte of the deflate\n  stream.  The end-of-block will not be indicated until all of the uncompressed\n  data from that block has been written to strm->next_out.  The number of\n  unused bits may in general be greater than seven, except when bit 7 of\n  data_type is set, in which case the number of unused bits will be less than\n  eight.  data_type is set as noted here every time inflate() returns for all\n  flush options, and so can be used to determine the amount of currently\n  consumed input in bits.\n\n    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the\n  end of each deflate block header is reached, before any actual data in that\n  block is decoded.  This allows the caller to determine the length of the\n  deflate block header for later use in random access within a deflate block.\n  256 is added to the value of strm->data_type when inflate() returns\n  immediately after reaching the end of the deflate block header.\n\n    inflate() should normally be called until it returns Z_STREAM_END or an\n  error.  However if all decompression is to be performed in a single step (a\n  single call of inflate), the parameter flush should be set to Z_FINISH.  In\n  this case all pending input is processed and all pending output is flushed;\n  avail_out must be large enough to hold all of the uncompressed data for the\n  operation to complete.  (The size of the uncompressed data may have been\n  saved by the compressor for this purpose.)  The use of Z_FINISH is not\n  required to perform an inflation in one step.  However it may be used to\n  inform inflate that a faster approach can be used for the single inflate()\n  call.  Z_FINISH also informs inflate to not maintain a sliding window if the\n  stream completes, which reduces inflate's memory footprint.  If the stream\n  does not complete, either because not all of the stream is provided or not\n  enough output space is provided, then a sliding window will be allocated and\n  inflate() can be called again to continue the operation as if Z_NO_FLUSH had\n  been used.\n\n     In this implementation, inflate() always flushes as much output as\n  possible to the output buffer, and always uses the faster approach on the\n  first call.  So the effects of the flush parameter in this implementation are\n  on the return value of inflate() as noted below, when inflate() returns early\n  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of\n  memory for a sliding window when Z_FINISH is used.\n\n     If a preset dictionary is needed after this call (see inflateSetDictionary\n  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary\n  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets\n  strm->adler to the Adler-32 checksum of all output produced so far (that is,\n  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described\n  below.  At the end of the stream, inflate() checks that its computed Adler-32\n  checksum is equal to that saved by the compressor and returns Z_STREAM_END\n  only if the checksum is correct.\n\n    inflate() can decompress and check either zlib-wrapped or gzip-wrapped\n  deflate data.  The header type is detected automatically, if requested when\n  initializing with inflateInit2().  Any information contained in the gzip\n  header is not retained unless inflateGetHeader() is used.  When processing\n  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output\n  produced so far.  The CRC-32 is checked against the gzip trailer, as is the\n  uncompressed length, modulo 2^32.\n\n    inflate() returns Z_OK if some progress has been made (more input processed\n  or more output produced), Z_STREAM_END if the end of the compressed data has\n  been reached and all uncompressed output has been produced, Z_NEED_DICT if a\n  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was\n  corrupted (input stream not conforming to the zlib format or incorrect check\n  value, in which case strm->msg points to a string with a more specific\n  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example\n  next_in or next_out was NULL, or the state was inadvertently written over\n  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR\n  if no progress is possible or if there was not enough room in the output\n  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and\n  inflate() can be called again with more input and more output space to\n  continue decompressing.  If Z_DATA_ERROR is returned, the application may\n  then call inflateSync() to look for a good compression block if a partial\n  recovery of the data is to be attempted.\n*/\n\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateEnd(zng_stream *strm);\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state\n   was inconsistent.\n*/\n\n\n                        /* Advanced functions */\n\n/*\n    The following functions are needed only in some special applications.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateInit2(zng_stream *strm, int32_t level, int32_t method, int32_t windowBits, int32_t memLevel, int32_t strategy);\n/*\n     This is another version of deflateInit with more compression options.  The\n   fields zalloc, zfree and opaque must be initialized before by the caller.\n\n     The method parameter is the compression method.  It must be Z_DEFLATED in\n   this version of the library.\n\n     The windowBits parameter is the base two logarithm of the window size\n   (the size of the history buffer).  It should be in the range 8..15 for this\n   version of the library.  Larger values of this parameter result in better\n   compression at the expense of memory usage.  The default value is 15 if\n   deflateInit is used instead.\n\n     For the current implementation of deflate(), a windowBits value of 8 (a\n   window size of 256 bytes) is not supported.  As a result, a request for 8\n   will result in 9 (a 512-byte window).  In that case, providing 8 to\n   inflateInit2() will result in an error when the zlib header with 9 is\n   checked against the initialization of inflate().  The remedy is to not use 8\n   with deflateInit2() with this initialization, or at least in that case use 9\n   with inflateInit2().\n\n     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits\n   determines the window size.  deflate() will then generate raw deflate data\n   with no zlib header or trailer, and will not compute a check value.\n\n     windowBits can also be greater than 15 for optional gzip encoding.  Add\n   16 to windowBits to write a simple gzip header and trailer around the\n   compressed data instead of a zlib wrapper.  The gzip header will have no\n   file name, no extra data, no comment, no modification time (set to zero), no\n   header crc, and the operating system will be set to the appropriate value,\n   if the operating system was determined at compile time.  If a gzip stream is\n   being written, strm->adler is a CRC-32 instead of an Adler-32.\n\n     For raw deflate or gzip encoding, a request for a 256-byte window is\n   rejected as invalid, since only the zlib header provides a means of\n   transmitting the window size to the decompressor.\n\n     The memLevel parameter specifies how much memory should be allocated\n   for the internal compression state.  memLevel=1 uses minimum memory but is\n   slow and reduces compression ratio; memLevel=9 uses maximum memory for\n   optimal speed.  The default value is 8.  See zconf.h for total memory usage\n   as a function of windowBits and memLevel.\n\n     The strategy parameter is used to tune the compression algorithm.  Use the\n   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a\n   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no\n   string match), or Z_RLE to limit match distances to one (run-length\n   encoding).  Filtered data consists mostly of small values with a somewhat\n   random distribution.  In this case, the compression algorithm is tuned to\n   compress them better.  The effect of Z_FILTERED is to force more Huffman\n   coding and less string matching; it is somewhat intermediate between\n   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as\n   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The\n   strategy parameter only affects the compression ratio but not the\n   correctness of the compressed output even if it is not set appropriately.\n   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler\n   decoder for special applications.\n\n     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid method).\n   msg is set to null if there is no error message.  deflateInit2 does not perform\n   any compression: this will be done by deflate().\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateSetDictionary(zng_stream *strm, const uint8_t *dictionary, uint32_t dictLength);\n/*\n     Initializes the compression dictionary from the given byte sequence\n   without producing any compressed output.  When using the zlib format, this\n   function must be called immediately after deflateInit, deflateInit2 or\n   deflateReset, and before any call of deflate.  When doing raw deflate, this\n   function must be called either before any call of deflate, or immediately\n   after the completion of a deflate block, i.e. after all input has been\n   consumed and all output has been delivered when using any of the flush\n   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The\n   compressor and decompressor must use exactly the same dictionary (see\n   inflateSetDictionary).\n\n     The dictionary should consist of strings (byte sequences) that are likely\n   to be encountered later in the data to be compressed, with the most commonly\n   used strings preferably put towards the end of the dictionary.  Using a\n   dictionary is most useful when the data to be compressed is short and can be\n   predicted with good accuracy; the data can then be compressed better than\n   with the default empty dictionary.\n\n     Depending on the size of the compression data structures selected by\n   deflateInit or deflateInit2, a part of the dictionary may in effect be\n   discarded, for example if the dictionary is larger than the window size\n   provided in deflateInit or deflateInit2.  Thus the strings most likely to be\n   useful should be put at the end of the dictionary, not at the front.  In\n   addition, the current implementation of deflate will use at most the window\n   size minus 262 bytes of the provided dictionary.\n\n     Upon return of this function, strm->adler is set to the Adler-32 value\n   of the dictionary; the decompressor may later use this value to determine\n   which dictionary has been used by the compressor.  (The Adler-32 value\n   applies to the whole dictionary even if only a subset of the dictionary is\n   actually used by the compressor.) If a raw deflate was requested, then the\n   Adler-32 value is not computed and strm->adler is not set.\n\n     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being NULL) or the stream state is\n   inconsistent (for example if deflate has already been called for this stream\n   or if not at a block boundary for raw deflate).  deflateSetDictionary does\n   not perform any compression: this will be done by deflate().\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateGetDictionary(zng_stream *strm, uint8_t *dictionary, uint32_t *dictLength);\n/*\n     Returns the sliding dictionary being maintained by deflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If deflateGetDictionary() is called with dictionary equal to\n   Z_NULL, then only the dictionary length is returned, and nothing is copied.\n   Similarly, if dictLength is Z_NULL, then it is not set.\n\n     deflateGetDictionary() may return a length less than the window size, even\n   when more than the window size in input has been provided. It may return up\n   to 258 bytes less in that case, due to how zlib's implementation of deflate\n   manages the sliding window and lookahead for matches, where matches can be\n   up to 258 bytes long. If the application needs the last window-size bytes of\n   input, then that would need to be saved by the application outside of zlib.\n\n     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateCopy(zng_stream *dest, zng_stream *source);\n/*\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when several compression strategies will be\n   tried, for example when there are several ways of pre-processing the input\n   data with a filter.  The streams that will be discarded should then be freed\n   by calling deflateEnd.  Note that deflateCopy duplicates the internal\n   compression state which can be quite large, so this strategy is slow and can\n   consume lots of memory.\n\n     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being NULL).  msg is left unchanged in both source and\n   destination.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateReset(zng_stream *strm);\n/*\n     This function is equivalent to deflateEnd followed by deflateInit, but\n   does not free and reallocate the internal compression state.  The stream\n   will leave the compression level and any other attributes that may have been\n   set unchanged.  total_in, total_out, adler, and msg are initialized.\n\n     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL).\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateParams(zng_stream *strm, int32_t level, int32_t strategy);\n/*\n     Dynamically update the compression level and compression strategy.  The\n   interpretation of level and strategy is as in deflateInit2().  This can be\n   used to switch between compression and straight copy of the input data, or\n   to switch to a different kind of input data requiring a different strategy.\n   If the compression approach (which is a function of the level) or the\n   strategy is changed, and if there have been any deflate() calls since the\n   state was initialized or reset, then the input available so far is\n   compressed with the old level and strategy using deflate(strm, Z_BLOCK).\n   There are three approaches for the compression levels 0, 1..3, and 4..9\n   respectively.  The new level and strategy will take effect at the next call\n   of deflate().\n\n     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does\n   not have enough output space to complete, then the parameter change will not\n   take effect.  In this case, deflateParams() can be called again with the\n   same parameters and more output space to try again.\n\n     In order to assure a change in the parameters on the first try, the\n   deflate stream should be flushed using deflate() with Z_BLOCK or other flush\n   request until strm.avail_out is not zero, before calling deflateParams().\n   Then no more input data should be provided before the deflateParams() call.\n   If this is done, the old level and strategy will be applied to the data\n   compressed before deflateParams(), and the new level and strategy will be\n   applied to the data compressed after deflateParams().\n\n     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream\n   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if\n   there was not enough output space to complete the compression of the\n   available input data before a change in the strategy or approach.  Note that\n   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return\n   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be\n   retried with more output space.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateTune(zng_stream *strm, int32_t good_length, int32_t max_lazy, int32_t nice_length, int32_t max_chain);\n/*\n     Fine tune deflate's internal compression parameters.  This should only be\n   used by someone who understands the algorithm used by zlib's deflate for\n   searching for the best matching string, and even then only by the most\n   fanatic optimizer trying to squeeze out the last compressed bit for their\n   specific input data.  Read the deflate.c source code for the meaning of the\n   max_lazy, good_length, nice_length, and max_chain parameters.\n\n     deflateTune() can be called after deflateInit() or deflateInit2(), and\n   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.\n */\n\nZ_EXTERN Z_EXPORT\nunsigned long zng_deflateBound(zng_stream *strm, unsigned long sourceLen);\n/*\n     deflateBound() returns an upper bound on the compressed size after\n   deflation of sourceLen bytes.  It must be called after deflateInit() or\n   deflateInit2(), and after deflateSetHeader(), if used.  This would be used\n   to allocate an output buffer for deflation in a single pass, and so would be\n   called before deflate().  If that first deflate() call is provided the\n   sourceLen input bytes, an output buffer allocated to the size returned by\n   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed\n   to return Z_STREAM_END.  Note that it is possible for the compressed size to\n   be larger than the value returned by deflateBound() if flush options other\n   than Z_FINISH or Z_NO_FLUSH are used.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflatePending(zng_stream *strm, uint32_t *pending, int32_t *bits);\n/*\n     deflatePending() returns the number of bytes and bits of output that have\n   been generated, but not yet provided in the available output.  The bytes not\n   provided would be due to the available output space having being consumed.\n   The number of bits of output not provided are between 0 and 7, where they\n   await more bits to join them in order to fill out a full byte.  If pending\n   or bits are NULL, then those values are not set.\n\n     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n */\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflatePrime(zng_stream *strm, int32_t bits, int32_t value);\n/*\n     deflatePrime() inserts bits in the deflate output stream.  The intent\n   is that this function is used to start off the deflate output with the bits\n   leftover from a previous deflate stream when appending to it.  As such, this\n   function can only be used for raw deflate, and must be used before the first\n   deflate() call after a deflateInit2() or deflateReset().  bits must be less\n   than or equal to 16, and that many of the least significant bits of value\n   will be inserted in the output.\n\n     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough\n   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the\n   source stream state was inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateSetHeader(zng_stream *strm, zng_gz_headerp head);\n/*\n     deflateSetHeader() provides gzip header information for when a gzip\n   stream is requested by deflateInit2().  deflateSetHeader() may be called\n   after deflateInit2() or deflateReset() and before the first call of\n   deflate().  The text, time, os, extra field, name, and comment information\n   in the provided zng_gz_header structure are written to the gzip header (xflag is\n   ignored -- the extra flags are set according to the compression level).  The\n   caller must assure that, if not NULL, name and comment are terminated with\n   a zero byte, and that if extra is not NULL, that extra_len bytes are\n   available there.  If hcrc is true, a gzip header crc is included.  Note that\n   the current versions of the command-line version of gzip (up through version\n   1.3.x) do not support header crc's, and will report that it is a \"multi-part\n   gzip file\" and give up.\n\n     If deflateSetHeader is not used, the default gzip header has text false,\n   the time set to zero, and os set to the current operating system, with no\n   extra, name, or comment fields.  The gzip header is returned to the default\n   state by deflateReset().\n\n     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateInit2(zng_stream *strm, int32_t windowBits);\n/*\n     This is another version of inflateInit with an extra parameter.  The\n   fields next_in, avail_in, zalloc, zfree and opaque must be initialized\n   before by the caller.\n\n     The windowBits parameter is the base two logarithm of the maximum window\n   size (the size of the history buffer).  It should be in the range 8..15 for\n   this version of the library.  The default value is 15 if inflateInit is used\n   instead.  windowBits must be greater than or equal to the windowBits value\n   provided to deflateInit2() while compressing, or it must be equal to 15 if\n   deflateInit2() was not used.  If a compressed stream with a larger window\n   size is given as input, inflate() will return with the error code\n   Z_DATA_ERROR instead of trying to allocate a larger window.\n\n     windowBits can also be zero to request that inflate use the window size in\n   the zlib header of the compressed stream.\n\n     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits\n   determines the window size.  inflate() will then process raw deflate data,\n   not looking for a zlib or gzip header, not generating a check value, and not\n   looking for any check values for comparison at the end of the stream.  This\n   is for use with other formats that use the deflate compressed data format\n   such as zip.  Those formats provide their own check values.  If a custom\n   format is developed using the raw deflate format for compressed data, it is\n   recommended that a check value such as an Adler-32 or a CRC-32 be applied to\n   the uncompressed data as is done in the zlib, gzip, and zip formats.  For\n   most applications, the zlib format should be used as is.  Note that comments\n   above on the use in deflateInit2() applies to the magnitude of windowBits.\n\n     windowBits can also be greater than 15 for optional gzip decoding.  Add\n   32 to windowBits to enable zlib and gzip decoding with automatic header\n   detection, or add 16 to decode only the gzip format (the zlib format will\n   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a\n   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see\n   below), inflate() will *not* automatically decode concatenated gzip members.\n   inflate() will return Z_STREAM_END at the end of the gzip member.  The state\n   would need to be reset to continue decoding a subsequent gzip member.  This\n   *must* be done if there is more data after a gzip member, in order for the\n   decompression to be compliant with the gzip standard (RFC 1952).\n\n     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, or Z_STREAM_ERROR if the parameters are invalid, such as a null\n   pointer to the structure.  msg is set to null if there is no error message.\n   inflateInit2 does not perform any decompression apart from possibly reading\n   the zlib header if present: actual decompression will be done by inflate().\n   (So next_in and avail_in may be modified, but next_out and avail_out are\n   unused and unchanged.) The current implementation of inflateInit2() does not\n   process any header information -- that is deferred until inflate() is called.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateSetDictionary(zng_stream *strm, const uint8_t *dictionary, uint32_t dictLength);\n/*\n     Initializes the decompression dictionary from the given uncompressed byte\n   sequence.  This function must be called immediately after a call of inflate,\n   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor\n   can be determined from the Adler-32 value returned by that call of inflate.\n   The compressor and decompressor must use exactly the same dictionary (see\n   deflateSetDictionary).  For raw inflate, this function can be called at any\n   time to set the dictionary.  If the provided dictionary is smaller than the\n   window and there is already data in the window, then the provided dictionary\n   will amend what's there.  The application must ensure that the dictionary\n   that was used for compression is provided.\n\n     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being NULL) or the stream state is\n   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the\n   expected one (incorrect Adler-32 value).  inflateSetDictionary does not\n   perform any decompression: this will be done by subsequent calls of\n   inflate().\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateGetDictionary(zng_stream *strm, uint8_t *dictionary, uint32_t *dictLength);\n/*\n     Returns the sliding dictionary being maintained by inflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If inflateGetDictionary() is called with dictionary equal to\n   NULL, then only the dictionary length is returned, and nothing is copied.\n   Similarly, if dictLength is NULL, then it is not set.\n\n     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateSync(zng_stream *strm);\n/*\n     Skips invalid compressed data until a possible full flush point (see above\n   for the description of deflate with Z_FULL_FLUSH) can be found, or until all\n   available input is skipped.  No output is provided.\n\n     inflateSync searches for a 00 00 FF FF pattern in the compressed data.\n   All full flush points have this pattern, but not all occurrences of this\n   pattern are full flush points.\n\n     inflateSync returns Z_OK if a possible full flush point has been found,\n   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point\n   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.\n   In the success case, the application may save the current current value of\n   total_in which indicates where valid compressed data was found.  In the\n   error case, the application may repeatedly call inflateSync, providing more\n   input each time, until success or end of the input data.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateCopy(zng_stream *dest, zng_stream *source);\n/*\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when randomly accessing a large stream.  The\n   first pass through the stream can periodically record the inflate state,\n   allowing restarting inflate at those points when randomly accessing the\n   stream.\n\n     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being NULL).  msg is left unchanged in both source and\n   destination.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateReset(zng_stream *strm);\n/*\n     This function is equivalent to inflateEnd followed by inflateInit,\n   but does not free and reallocate the internal decompression state.  The\n   stream will keep attributes that may have been set by inflateInit2.\n   total_in, total_out, adler, and msg are initialized.\n\n     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL).\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateReset2(zng_stream *strm, int32_t windowBits);\n/*\n     This function is the same as inflateReset, but it also permits changing\n   the wrap and window size requests.  The windowBits parameter is interpreted\n   the same as it is for inflateInit2.  If the window size is changed, then the\n   memory allocated for the window is freed, and the window will be reallocated\n   by inflate() if needed.\n\n     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL), or if\n   the windowBits parameter is invalid.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflatePrime(zng_stream *strm, int32_t bits, int32_t value);\n/*\n     This function inserts bits in the inflate input stream.  The intent is\n   that this function is used to start inflating at a bit position in the\n   middle of a byte.  The provided bits will be used before any bytes are used\n   from next_in.  This function should only be used with raw inflate, and\n   should be used before the first inflate() call after inflateInit2() or\n   inflateReset().  bits must be less than or equal to 16, and that many of the\n   least significant bits of value will be inserted in the input.\n\n     If bits is negative, then the input stream bit buffer is emptied.  Then\n   inflatePrime() can be called again to put bits in the buffer.  This is used\n   to clear out bits leftover after feeding inflate a block description prior\n   to feeding inflate codes.\n\n     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nlong zng_inflateMark(zng_stream *strm);\n/*\n     This function returns two values, one in the lower 16 bits of the return\n   value, and the other in the remaining upper bits, obtained by shifting the\n   return value down 16 bits.  If the upper value is -1 and the lower value is\n   zero, then inflate() is currently decoding information outside of a block.\n   If the upper value is -1 and the lower value is non-zero, then inflate is in\n   the middle of a stored block, with the lower value equaling the number of\n   bytes from the input remaining to copy.  If the upper value is not -1, then\n   it is the number of bits back from the current bit position in the input of\n   the code (literal or length/distance pair) currently being processed.  In\n   that case the lower value is the number of bytes already emitted for that\n   code.\n\n     A code is being processed if inflate is waiting for more input to complete\n   decoding of the code, or if it has completed decoding but is waiting for\n   more output space to write the literal or match data.\n\n     inflateMark() is used to mark locations in the input data for random\n   access, which may be at bit positions, and to note those cases where the\n   output of a code may span boundaries of random access blocks.  The current\n   location in the input stream can be determined from avail_in and data_type\n   as noted in the description for the Z_BLOCK flush parameter for inflate.\n\n     inflateMark returns the value noted above, or -65536 if the provided\n   source stream state was inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateGetHeader(zng_stream *strm, zng_gz_headerp head);\n/*\n     inflateGetHeader() requests that gzip header information be stored in the\n   provided zng_gz_header structure.  inflateGetHeader() may be called after\n   inflateInit2() or inflateReset(), and before the first call of inflate().\n   As inflate() processes the gzip stream, head->done is zero until the header\n   is completed, at which time head->done is set to one.  If a zlib stream is\n   being decoded, then head->done is set to -1 to indicate that there will be\n   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be\n   used to force inflate() to return immediately after header processing is\n   complete and before any actual data is decompressed.\n\n     The text, time, xflags, and os fields are filled in with the gzip header\n   contents.  hcrc is set to true if there is a header CRC.  (The header CRC\n   was valid if done is set to one.) If extra is not NULL, then extra_max\n   contains the maximum number of bytes to write to extra.  Once done is true,\n   extra_len contains the actual extra field length, and extra contains the\n   extra field, or that field truncated if extra_max is less than extra_len.\n   If name is not NULL, then up to name_max characters are written there,\n   terminated with a zero unless the length is greater than name_max.  If\n   comment is not NULL, then up to comm_max characters are written there,\n   terminated with a zero unless the length is greater than comm_max.  When any\n   of extra, name, or comment are not NULL and the respective field is not\n   present in the header, then that field is set to NULL to signal its\n   absence.  This allows the use of deflateSetHeader() with the returned\n   structure to duplicate the header.  However if those fields are set to\n   allocated memory, then the application will need to save those pointers\n   elsewhere so that they can be eventually freed.\n\n     If inflateGetHeader is not used, then the header information is simply\n   discarded.  The header is always checked for validity, including the header\n   CRC if present.  inflateReset() will reset the process to discard the header\n   information.  The application would need to call inflateGetHeader() again to\n   retrieve the header from the next gzip stream.\n\n     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateBackInit(zng_stream *strm, int32_t windowBits, uint8_t *window);\n/*\n     Initialize the internal stream state for decompression using inflateBack()\n   calls.  The fields zalloc, zfree and opaque in strm must be initialized\n   before the call.  If zalloc and zfree are NULL, then the default library-\n   derived memory allocation routines are used.  windowBits is the base two\n   logarithm of the window size, in the range 8..15.  window is a caller\n   supplied buffer of that size.  Except for special applications where it is\n   assured that deflate was used with small window sizes, windowBits must be 15\n   and a 32K byte window must be supplied to be able to decompress general\n   deflate streams.\n\n     See inflateBack() for the usage of these routines.\n\n     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of\n   the parameters are invalid, Z_MEM_ERROR if the internal state could not be\n   allocated.\n*/\n\ntypedef uint32_t (*in_func) (void *, const uint8_t * *);\ntypedef int32_t  (*out_func) (void *, uint8_t *, uint32_t);\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateBack(zng_stream *strm, in_func in, void *in_desc, out_func out, void *out_desc);\n/*\n     inflateBack() does a raw inflate with a single call using a call-back\n   interface for input and output.  This is potentially more efficient than\n   inflate() for file i/o applications, in that it avoids copying between the\n   output and the sliding window by simply making the window itself the output\n   buffer.  inflate() can be faster on modern CPUs when used with large\n   buffers.  inflateBack() trusts the application to not change the output\n   buffer passed by the output function, at least until inflateBack() returns.\n\n     inflateBackInit() must be called first to allocate the internal state\n   and to initialize the state with the user-provided window buffer.\n   inflateBack() may then be used multiple times to inflate a complete, raw\n   deflate stream with each call.  inflateBackEnd() is then called to free the\n   allocated state.\n\n     A raw deflate stream is one with no zlib or gzip header or trailer.\n   This routine would normally be used in a utility that reads zip or gzip\n   files and writes out uncompressed files.  The utility would decode the\n   header and process the trailer on its own, hence this routine expects only\n   the raw deflate stream to decompress.  This is different from the default\n   behavior of inflate(), which expects a zlib header and trailer around the\n   deflate stream.\n\n     inflateBack() uses two subroutines supplied by the caller that are then\n   called by inflateBack() for input and output.  inflateBack() calls those\n   routines until it reads a complete deflate stream and writes out all of the\n   uncompressed data, or until it encounters an error.  The function's\n   parameters and return types are defined above in the in_func and out_func\n   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the\n   number of bytes of provided input, and a pointer to that input in buf.  If\n   there is no input available, in() must return zero -- buf is ignored in that\n   case -- and inflateBack() will return a buffer error.  inflateBack() will\n   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].\n   out() should return zero on success, or non-zero on failure.  If out()\n   returns non-zero, inflateBack() will return with an error.  Neither in() nor\n   out() are permitted to change the contents of the window provided to\n   inflateBackInit(), which is also the buffer that out() uses to write from.\n   The length written by out() will be at most the window size.  Any non-zero\n   amount of input may be provided by in().\n\n     For convenience, inflateBack() can be provided input on the first call by\n   setting strm->next_in and strm->avail_in.  If that input is exhausted, then\n   in() will be called.  Therefore strm->next_in must be initialized before\n   calling inflateBack().  If strm->next_in is NULL, then in() will be called\n   immediately for input.  If strm->next_in is not NULL, then strm->avail_in\n   must also be initialized, and then if strm->avail_in is not zero, input will\n   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].\n\n     The in_desc and out_desc parameters of inflateBack() is passed as the\n   first parameter of in() and out() respectively when they are called.  These\n   descriptors can be optionally used to pass any information that the caller-\n   supplied in() and out() functions need to do their job.\n\n     On return, inflateBack() will set strm->next_in and strm->avail_in to\n   pass back any unused input that was provided by the last in() call.  The\n   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR\n   if in() or out() returned an error, Z_DATA_ERROR if there was a format error\n   in the deflate stream (in which case strm->msg is set to indicate the nature\n   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.\n   In the case of Z_BUF_ERROR, an input or output error can be distinguished\n   using strm->next_in which will be NULL only if in() returned an error.  If\n   strm->next_in is not NULL, then the Z_BUF_ERROR was due to out() returning\n   non-zero.  (in() will always be called before out(), so strm->next_in is\n   assured to be defined if out() returns non-zero.)  Note that inflateBack()\n   cannot return Z_OK.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_inflateBackEnd(zng_stream *strm);\n/*\n     All memory allocated by inflateBackInit() is freed.\n\n     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream\n   state was inconsistent.\n*/\n\nZ_EXTERN Z_EXPORT\nunsigned long zng_zlibCompileFlags(void);\n/* Return flags indicating compile-time options.\n\n    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:\n     1.0: size of unsigned int\n     3.2: size of unsigned long\n     5.4: size of void * (pointer)\n     7.6: size of z_off_t\n\n    Compiler, assembler, and debug options:\n     8: ZLIB_DEBUG\n     9: ASMV or ASMINF -- use ASM code\n     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention\n     11: 0 (reserved)\n\n    One-time table building (smaller code, but not thread-safe if true):\n     12: BUILDFIXED -- build static block decoding tables when needed (not supported by zlib-ng)\n     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed\n     14,15: 0 (reserved)\n\n    Library content (indicates missing functionality):\n     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking\n                          deflate code when not needed)\n     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect\n                    and decode gzip streams (to avoid linking crc code)\n     18-19: 0 (reserved)\n\n    Operation variations (changes in library functionality):\n     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate\n     21: FASTEST -- deflate algorithm with only one, lowest compression level\n     22,23: 0 (reserved)\n\n    The sprintf variant used by gzprintf (zero is best):\n     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format\n     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!\n     26: 0 = returns value, 1 = void -- 1 means inferred string length returned\n\n    Remainder:\n     27-31: 0 (reserved)\n */\n\n\n                        /* utility functions */\n\n/*\n     The following utility functions are implemented on top of the basic\n   stream-oriented functions.  To simplify the interface, some default options\n   are assumed (compression level and memory usage, standard memory allocation\n   functions).  The source code of these utility functions can be modified if\n   you need special options.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_compress(uint8_t *dest, size_t *destLen, const uint8_t *source, size_t sourceLen);\n/*\n     Compresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.  compress() is equivalent to compress2() with a level\n   parameter of Z_DEFAULT_COMPRESSION.\n\n     compress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_compress2(uint8_t *dest, size_t *destLen, const uint8_t *source, size_t sourceLen, int32_t level);\n/*\n     Compresses the source buffer into the destination buffer.  The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer.  Upon entry, destLen is the total size of the\n   destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\n\nZ_EXTERN Z_EXPORT\nsize_t zng_compressBound(size_t sourceLen);\n/*\n     compressBound() returns an upper bound on the compressed size after\n   compress() or compress2() on sourceLen bytes.  It would be used before a\n   compress() or compress2() call to allocate the destination buffer.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_uncompress(uint8_t *dest, size_t *destLen, const uint8_t *source, size_t sourceLen);\n/*\n     Decompresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be large enough to hold the entire\n   uncompressed data.  (The size of the uncompressed data must have been saved\n   previously by the compressor and transmitted to the decompressor by some\n   mechanism outside the scope of this compression library.) Upon exit, destLen\n   is the actual size of the uncompressed data.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In\n   the case where there is not enough room, uncompress() will fill the output\n   buffer with the uncompressed data up to that point.\n*/\n\n\nZ_EXTERN Z_EXPORT\nint32_t zng_uncompress2(uint8_t *dest, size_t *destLen, const uint8_t *source, size_t *sourceLen);\n/*\n     Same as uncompress, except that sourceLen is a pointer, where the\n   length of the source is *sourceLen.  On return, *sourceLen is the number of\n   source bytes consumed.\n*/\n\n\n#ifdef WITH_GZFILEOP\n                        /* gzip file access functions */\n\n/*\n     This library supports reading and writing files in gzip (.gz) format with\n   an interface similar to that of stdio, using the functions that start with\n   \"gz\".  The gzip format is different from the zlib format.  gzip is a gzip\n   wrapper, documented in RFC 1952, wrapped around a deflate stream.\n*/\n\ntypedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */\n\nZ_EXTERN Z_EXPORT\ngzFile zng_gzopen(const char *path, const char *mode);\n/*\n     Open the gzip (.gz) file at path for reading and decompressing, or\n   compressing and writing.  The mode parameter is as in fopen (\"rb\" or \"wb\")\n   but can also include a compression level (\"wb9\") or a strategy: 'f' for\n   filtered data as in \"wb6f\", 'h' for Huffman-only compression as in \"wb1h\",\n   'R' for run-length encoding as in \"wb1R\", or 'F' for fixed code compression\n   as in \"wb9F\".  (See the description of deflateInit2 for more information\n   about the strategy parameter.)  'T' will request transparent writing or\n   appending with no compression and not using the gzip format.\n\n     \"a\" can be used instead of \"w\" to request that the gzip stream that will\n   be written be appended to the file.  \"+\" will result in an error, since\n   reading and writing to the same gzip file is not supported.  The addition of\n   \"x\" when writing will create the file exclusively, which fails if the file\n   already exists.  On systems that support it, the addition of \"e\" when\n   reading or writing will set the flag to close the file on an execve() call.\n\n     These functions, as well as gzip, will read and decode a sequence of gzip\n   streams in a file.  The append function of gzopen() can be used to create\n   such a file.  (Also see gzflush() for another way to do this.)  When\n   appending, gzopen does not test whether the file begins with a gzip stream,\n   nor does it look for the end of the gzip streams to begin appending.  gzopen\n   will simply append a gzip stream to the existing file.\n\n     gzopen can be used to read a file which is not in gzip format; in this\n   case gzread will directly read from the file without decompression.  When\n   reading, this will be detected automatically by looking for the magic two-\n   byte gzip header.\n\n     gzopen returns NULL if the file could not be opened, if there was\n   insufficient memory to allocate the gzFile state, or if an invalid mode was\n   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).\n   errno can be checked to determine if the reason gzopen failed was that the\n   file could not be opened.\n*/\n\nZ_EXTERN Z_EXPORT\ngzFile zng_gzdopen(int fd, const char *mode);\n/*\n     Associate a gzFile with the file descriptor fd.  File descriptors are\n   obtained from calls like open, dup, creat, pipe or fileno (if the file has\n   been previously opened with fopen).  The mode parameter is as in gzopen.\n\n     The next call of gzclose on the returned gzFile will also close the file\n   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor\n   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,\n   mode);.  The duplicated descriptor should be saved to avoid a leak, since\n   gzdopen does not close fd if it fails.  If you are using fileno() to get the\n   file descriptor from a FILE *, then you will have to use dup() to avoid\n   double-close()ing the file descriptor.  Both gzclose() and fclose() will\n   close the associated file descriptor, so they need to have different file\n   descriptors.\n\n     gzdopen returns NULL if there was insufficient memory to allocate the\n   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not\n   provided, or '+' was provided), or if fd is -1.  The file descriptor is not\n   used until the next gz* read, write, seek, or close operation, so gzdopen\n   will not detect if fd is invalid (unless fd is -1).\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzbuffer(gzFile file, uint32_t size);\n/*\n     Set the internal buffer size used by this library's functions for file to\n   size.  The default buffer size is 8192 bytes.  This function must be called\n   after gzopen() or gzdopen(), and before any other calls that read or write\n   the file.  The buffer memory allocation is always deferred to the first read\n   or write.  Three times that size in buffer space is allocated.  A larger\n   buffer size of, for example, 64K or 128K bytes will noticeably increase the\n   speed of decompression (reading).\n\n     The new buffer size also affects the maximum length for gzprintf().\n\n     gzbuffer() returns 0 on success, or -1 on failure, such as being called\n   too late.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzsetparams(gzFile file, int32_t level, int32_t strategy);\n/*\n     Dynamically update the compression level and strategy for file.  See the\n   description of deflateInit2 for the meaning of these parameters. Previously\n   provided data is flushed before applying the parameter changes.\n\n     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not\n   opened for writing, Z_ERRNO if there is an error writing the flushed data,\n   or Z_MEM_ERROR if there is a memory allocation error.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzread(gzFile file, void *buf, uint32_t len);\n/*\n     Read and decompress up to len uncompressed bytes from file into buf.  If\n   the input file is not in gzip format, gzread copies the given number of\n   bytes into the buffer directly from the file.\n\n     After reaching the end of a gzip stream in the input, gzread will continue\n   to read, looking for another gzip stream.  Any number of gzip streams may be\n   concatenated in the input file, and will all be decompressed by gzread().\n   If something other than a gzip stream is encountered after a gzip stream,\n   that remaining trailing garbage is ignored (and no error is returned).\n\n     gzread can be used to read a gzip file that is being concurrently written.\n   Upon reaching the end of the input, gzread will return with the available\n   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then\n   gzclearerr can be used to clear the end of file indicator in order to permit\n   gzread to be tried again.  Z_OK indicates that a gzip stream was completed\n   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the\n   middle of a gzip stream.  Note that gzread does not return -1 in the event\n   of an incomplete gzip stream.  This error is deferred until gzclose(), which\n   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip\n   stream.  Alternatively, gzerror can be used before gzclose to detect this\n   case.\n\n     gzread returns the number of uncompressed bytes actually read, less than\n   len for end of file, or -1 for error.  If len is too large to fit in an int,\n   then nothing is read, -1 is returned, and the error state is set to\n   Z_STREAM_ERROR.\n*/\n\nZ_EXTERN Z_EXPORT\nsize_t zng_gzfread(void *buf, size_t size, size_t nitems, gzFile file);\n/*\n     Read and decompress up to nitems items of size size from file into buf,\n   otherwise operating as gzread() does.  This duplicates the interface of\n   stdio's fread(), with size_t request and return types.\n\n     gzfread() returns the number of full items read of size size, or zero if\n   the end of the file was reached and a full item could not be read, or if\n   there was an error.  gzerror() must be consulted if zero is returned in\n   order to determine if there was an error.  If the multiplication of size and\n   nitems overflows, i.e. the product does not fit in a size_t, then nothing\n   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.\n\n     In the event that the end of file is reached and only a partial item is\n   available at the end, i.e. the remaining uncompressed data length is not a\n   multiple of size, then the final partial item is nevertheless read into buf\n   and the end-of-file flag is set.  The length of the partial item read is not\n   provided, but could be inferred from the result of gztell().  This behavior\n   is the same as the behavior of fread() implementations in common libraries,\n   but it prevents the direct use of gzfread() to read a concurrently written\n   file, resetting and retrying on end-of-file, when size is not 1.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzwrite(gzFile file, void const *buf, uint32_t len);\n/*\n     Compress and write the len uncompressed bytes at buf to file. gzwrite\n   returns the number of uncompressed bytes written or 0 in case of error.\n*/\n\nZ_EXTERN Z_EXPORT\nsize_t zng_gzfwrite(void const *buf, size_t size, size_t nitems, gzFile file);\n/*\n     Compress and write nitems items of size size from buf to file, duplicating\n   the interface of stdio's fwrite(), with size_t request and return types.\n\n     gzfwrite() returns the number of full items written of size size, or zero\n   if there was an error.  If the multiplication of size and nitems overflows,\n   i.e. the product does not fit in a size_t, then nothing is written, zero\n   is returned, and the error state is set to Z_STREAM_ERROR.\n*/\n\nZ_EXTERN Z_EXPORTVA\nint32_t zng_gzprintf(gzFile file, const char *format, ...);\n/*\n     Convert, format, compress, and write the arguments (...) to file under\n   control of the string format, as in fprintf.  gzprintf returns the number of\n   uncompressed bytes actually written, or a negative zlib error code in case\n   of error.  The number of uncompressed bytes written is limited to 8191, or\n   one less than the buffer size given to gzbuffer().  The caller should assure\n   that this limit is not exceeded.  If it is exceeded, then gzprintf() will\n   return an error (0) with nothing written.  In this case, there may also be a\n   buffer overflow with unpredictable consequences, which is possible only if\n   zlib was compiled with the insecure functions sprintf() or vsprintf(),\n   because the secure snprintf() or vsnprintf() functions were not available.\n   This can be determined using zlibCompileFlags().\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzputs(gzFile file, const char *s);\n/*\n     Compress and write the given null-terminated string s to file, excluding\n   the terminating null character.\n\n     gzputs returns the number of characters written, or -1 in case of error.\n*/\n\nZ_EXTERN Z_EXPORT\nchar * zng_gzgets(gzFile file, char *buf, int32_t len);\n/*\n     Read and decompress bytes from file into buf, until len-1 characters are\n   read, or until a newline character is read and transferred to buf, or an\n   end-of-file condition is encountered.  If any characters are read or if len\n   is one, the string is terminated with a null character.  If no characters\n   are read due to an end-of-file or len is less than one, then the buffer is\n   left untouched.\n\n     gzgets returns buf which is a null-terminated string, or it returns NULL\n   for end-of-file or in case of error.  If there was an error, the contents at\n   buf are indeterminate.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzputc(gzFile file, int32_t c);\n/*\n     Compress and write c, converted to an unsigned char, into file.  gzputc\n   returns the value that was written, or -1 in case of error.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzgetc(gzFile file);\n/*\n     Read and decompress one byte from file.  gzgetc returns this byte or -1\n   in case of end of file or error.  This is implemented as a macro for speed.\n   As such, it does not do all of the checking the other functions do.  I.e.\n   it does not check to see if file is NULL, nor whether the structure file\n   points to has been clobbered or not.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzungetc(int32_t c, gzFile file);\n/*\n     Push c back onto the stream for file to be read as the first character on\n   the next read.  At least one character of push-back is always allowed.\n   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will\n   fail if c is -1, and may fail if a character has been pushed but not read\n   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the\n   output buffer size of pushed characters is allowed.  (See gzbuffer above.)\n   The pushed character will be discarded if the stream is repositioned with\n   gzseek() or gzrewind().\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzflush(gzFile file, int32_t flush);\n/*\n     Flush all pending output to file.  The parameter flush is as in the\n   deflate() function.  The return value is the zlib error number (see function\n   gzerror below).  gzflush is only permitted when writing.\n\n     If the flush parameter is Z_FINISH, the remaining data is written and the\n   gzip stream is completed in the output.  If gzwrite() is called again, a new\n   gzip stream will be started in the output.  gzread() is able to read such\n   concatenated gzip streams.\n\n     gzflush should be called only when strictly necessary because it will\n   degrade compression if called too often.\n*/\n\nZ_EXTERN Z_EXPORT\nz_off64_t zng_gzseek(gzFile file, z_off64_t offset, int whence);\n/*\n     Set the starting position to offset relative to whence for the next gzread\n   or gzwrite on file.  The offset represents a number of bytes in the\n   uncompressed data stream.  The whence parameter is defined as in lseek(2);\n   the value SEEK_END is not supported.\n\n     If the file is opened for reading, this function is emulated but can be\n   extremely slow.  If the file is opened for writing, only forward seeks are\n   supported; gzseek then compresses a sequence of zeroes up to the new\n   starting position.\n\n     gzseek returns the resulting offset location as measured in bytes from\n   the beginning of the uncompressed stream, or -1 in case of error, in\n   particular if the file is opened for writing and the new starting position\n   would be before the current position.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzrewind(gzFile file);\n/*\n     Rewind file. This function is supported only for reading.\n\n     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).\n*/\n\nZ_EXTERN Z_EXPORT\nz_off64_t zng_gztell(gzFile file);\n/*\n     Return the starting position for the next gzread or gzwrite on file.\n   This position represents a number of bytes in the uncompressed data stream,\n   and is zero when starting, even if appending or reading a gzip stream from\n   the middle of a file using gzdopen().\n\n     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)\n*/\n\nZ_EXTERN Z_EXPORT\nz_off64_t zng_gzoffset(gzFile file);\n/*\n     Return the current compressed (actual) read or write offset of file.  This\n   offset includes the count of bytes that precede the gzip stream, for example\n   when appending or when using gzdopen() for reading.  When reading, the\n   offset does not include as yet unused buffered input.  This information can\n   be used for a progress indicator.  On error, gzoffset() returns -1.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzeof(gzFile file);\n/*\n     Return true (1) if the end-of-file indicator for file has been set while\n   reading, false (0) otherwise.  Note that the end-of-file indicator is set\n   only if the read tried to go past the end of the input, but came up short.\n   Therefore, just like feof(), gzeof() may return false even if there is no\n   more data to read, in the event that the last read request was for the exact\n   number of bytes remaining in the input file.  This will happen if the input\n   file size is an exact multiple of the buffer size.\n\n     If gzeof() returns true, then the read functions will return no more data,\n   unless the end-of-file indicator is reset by gzclearerr() and the input file\n   has grown since the previous end of file was detected.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzdirect(gzFile file);\n/*\n     Return true (1) if file is being copied directly while reading, or false\n   (0) if file is a gzip stream being decompressed.\n\n     If the input file is empty, gzdirect() will return true, since the input\n   does not contain a gzip stream.\n\n     If gzdirect() is used immediately after gzopen() or gzdopen() it will\n   cause buffers to be allocated to allow reading the file to determine if it\n   is a gzip file.  Therefore if gzbuffer() is used, it should be called before\n   gzdirect().\n\n     When writing, gzdirect() returns true (1) if transparent writing was\n   requested (\"wT\" for the gzopen() mode), or false (0) otherwise.  (Note:\n   gzdirect() is not needed when writing.  Transparent writing must be\n   explicitly requested, so the application already knows the answer.  When\n   linking statically, using gzdirect() will include all of the zlib code for\n   gzip file reading and decompression, which may not be desired.)\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzclose(gzFile file);\n/*\n     Flush all pending output for file, if necessary, close file and\n   deallocate the (de)compression state.  Note that once file is closed, you\n   cannot call gzerror with file, since its structures have been deallocated.\n   gzclose must not be called more than once on the same file, just as free\n   must not be called more than once on the same allocation.\n\n     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a\n   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the\n   last read ended in the middle of a gzip stream, or Z_OK on success.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_gzclose_r(gzFile file);\nZ_EXTERN Z_EXPORT\nint32_t zng_gzclose_w(gzFile file);\n/*\n     Same as gzclose(), but gzclose_r() is only for use when reading, and\n   gzclose_w() is only for use when writing or appending.  The advantage to\n   using these instead of gzclose() is that they avoid linking in zlib\n   compression or decompression code that is not used when only reading or only\n   writing respectively.  If gzclose() is used, then both compression and\n   decompression code will be included the application when linking to a static\n   zlib library.\n*/\n\nZ_EXTERN Z_EXPORT\nconst char * zng_gzerror(gzFile file, int32_t *errnum);\n/*\n     Return the error message for the last error which occurred on file.\n   errnum is set to zlib error number.  If an error occurred in the file system\n   and not in the compression library, errnum is set to Z_ERRNO and the\n   application may consult errno to get the exact error code.\n\n     The application must not modify the returned string.  Future calls to\n   this function may invalidate the previously returned string.  If file is\n   closed, then the string previously returned by gzerror will no longer be\n   available.\n\n     gzerror() should be used to distinguish errors from end-of-file for those\n   functions above that do not distinguish those cases in their return values.\n*/\n\nZ_EXTERN Z_EXPORT\nvoid zng_gzclearerr(gzFile file);\n/*\n     Clear the error and end-of-file flags for file.  This is analogous to the\n   clearerr() function in stdio.  This is useful for continuing to read a gzip\n   file that is being written concurrently.\n*/\n\n#endif /* WITH_GZFILEOP */\n\n                        /* checksum functions */\n\n/*\n     These functions are not related to compression but are exported\n   anyway because they might be useful in applications using the compression\n   library.\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_adler32(uint32_t adler, const uint8_t *buf, uint32_t len);\n/*\n     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n   return the updated checksum. An Adler-32 value is in the range of a 32-bit\n   unsigned integer. If buf is Z_NULL, this function returns the required\n   initial value for the checksum.\n\n     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed\n   much faster.\n\n   Usage example:\n\n     uint32_t adler = adler32(0L, NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       adler = adler32(adler, buffer, length);\n     }\n     if (adler != original_adler) error();\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_adler32_z(uint32_t adler, const uint8_t *buf, size_t len);\n/*\n     Same as adler32(), but with a size_t length.\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_adler32_combine(uint32_t adler1, uint32_t adler2, z_off64_t len2);\n/*\n     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1\n   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for\n   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of\n   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note\n   that the z_off_t type (like off_t) is a signed integer.  If len2 is\n   negative, the result has no meaning or utility.\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_crc32(uint32_t crc, const uint8_t *buf, uint32_t len);\n/*\n     Update a running CRC-32 with the bytes buf[0..len-1] and return the\n   updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.\n   If buf is Z_NULL, this function returns the required initial value for the\n   crc. Pre- and post-conditioning (one's complement) is performed within this\n   function so it shouldn't be done by the application.\n\n   Usage example:\n\n     uint32_t crc = crc32(0L, NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       crc = crc32(crc, buffer, length);\n     }\n     if (crc != original_crc) error();\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_crc32_z(uint32_t crc, const uint8_t *buf, size_t len);\n/*\n     Same as crc32(), but with a size_t length.\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_crc32_combine(uint32_t crc1, uint32_t crc2, z_off64_t len2);\n\n/*\n     Combine two CRC-32 check values into one.  For two sequences of bytes,\n   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were\n   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32\n   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and\n   len2. len2 must be non-negative.\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_crc32_combine_gen(z_off64_t len2);\n\n/*\n     Return the operator corresponding to length len2, to be used with\n   crc32_combine_op(). len2 must be non-negative.\n*/\n\nZ_EXTERN Z_EXPORT\nuint32_t zng_crc32_combine_op(uint32_t crc1, uint32_t crc2, const uint32_t op);\n/*\n     Give the same result as crc32_combine(), using op in place of len2. op is\n   is generated from len2 by crc32_combine_gen(). This will be faster than\n   crc32_combine() if the generated op is used more than once.\n*/\n\n                        /* various hacks, don't look :) */\n\n#ifdef WITH_GZFILEOP\n\n/* gzgetc() macro and its supporting function and exposed data structure.  Note\n * that the real internal state is much larger than the exposed structure.\n * This abbreviated structure exposes just enough for the gzgetc() macro.  The\n * user should not mess with these exposed elements, since their names or\n * behavior could change in the future, perhaps even capriciously.  They can\n * only be used by the gzgetc() macro.  You have been warned.\n */\nstruct gzFile_s {\n    unsigned have;\n    unsigned char *next;\n    z_off64_t pos;\n};\n#  define @ZLIB_SYMBOL_PREFIX@zng_gzgetc(g) ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (@ZLIB_SYMBOL_PREFIX@zng_gzgetc)(g))\n\n#endif /* WITH_GZFILEOP */\n\n\ntypedef enum {\n    Z_DEFLATE_LEVEL = 0,         /* compression level, represented as an int */\n    Z_DEFLATE_STRATEGY = 1,      /* compression strategy, represented as an int */\n    Z_DEFLATE_REPRODUCIBLE = 2,\n    /*\n         Whether reproducible compression results are required. Represented as an int, where 0 means that it is allowed\n       to trade reproducibility for e.g. improved performance or compression ratio, and non-0 means that\n       reproducibility is strictly required. Reproducibility is guaranteed only when using an identical zlib-ng build.\n       Default is 0.\n    */\n} zng_deflate_param;\n\ntypedef struct {\n    zng_deflate_param param;  /* parameter ID */\n    void   *buf;              /* parameter value */\n    size_t  size;             /* parameter value size */\n    int32_t status;           /* result of the last set/get call */\n} zng_deflate_param_value;\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateSetParams(zng_stream *strm, zng_deflate_param_value *params, size_t count);\n/*\n     Sets the values of the given zlib-ng deflate stream parameters. All the buffers are copied internally, so the\n   caller still owns them after this function returns. Returns Z_OK if success.\n\n     If the size of at least one of the buffers is too small to hold the entire value of the corresponding parameter,\n   or if the same parameter is specified multiple times, Z_BUF_ERROR is returned. The caller may inspect status fields\n   in order to determine which of the parameters caused this error. No other changes are performed.\n\n     If the stream state is inconsistent or if at least one of the values cannot be updated, Z_STREAM_ERROR is\n   returned. The caller may inspect status fields in order to determine which of the parameters caused this error.\n   Parameters, whose status field is equal to Z_OK, have been applied successfully. If all status fields are not equal\n   to Z_STREAM_ERROR, then the error was caused by a stream state inconsistency.\n\n     If there are no other errors, but at least one parameter is not supported by the current zlib-ng version,\n   Z_VERSION_ERROR is returned. The caller may inspect status fields in order to determine which of the parameters\n   caused this error.\n*/\n\nZ_EXTERN Z_EXPORT\nint32_t zng_deflateGetParams(zng_stream *strm, zng_deflate_param_value *params, size_t count);\n/*\n     Copies the values of the given zlib-ng deflate stream parameters into the user-provided buffers. Returns Z_OK if\n   success, Z_VERSION_ERROR if at least one parameter is not supported by the current zlib-ng version, Z_STREAM_ERROR\n   if the stream state is inconsistent, and Z_BUF_ERROR if the size of at least one buffer is too small to hold the\n   entire value of the corresponding parameter.\n*/\n\n/* undocumented functions */\nZ_EXTERN Z_EXPORT const char *     zng_zError           (int32_t);\nZ_EXTERN Z_EXPORT int32_t          zng_inflateSyncPoint (zng_stream *);\nZ_EXTERN Z_EXPORT const uint32_t * zng_get_crc_table    (void);\nZ_EXTERN Z_EXPORT int32_t          zng_inflateUndermine (zng_stream *, int32_t);\nZ_EXTERN Z_EXPORT int32_t          zng_inflateValidate  (zng_stream *, int32_t);\nZ_EXTERN Z_EXPORT unsigned long    zng_inflateCodesUsed (zng_stream *);\nZ_EXTERN Z_EXPORT int32_t          zng_inflateResetKeep (zng_stream *);\nZ_EXTERN Z_EXPORT int32_t          zng_deflateResetKeep (zng_stream *);\n\n#ifdef WITH_GZFILEOP\n#  if defined(_WIN32)\n     Z_EXTERN Z_EXPORT gzFile zng_gzopen_w(const wchar_t *path, const char *mode);\n#  endif\nZ_EXTERN Z_EXPORTVA int32_t zng_gzvprintf(gzFile file, const char *format, va_list va);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZNGLIB_H_ */\n"
        },
        {
          "name": "zlib-ng.map",
          "type": "blob",
          "size": 2.052734375,
          "content": "ZLIB_NG_2.1.0 {\n  global:\n    zng_deflateInit;\n    zng_deflateInit2;\n    zng_inflateBackInit;\n    zng_inflateInit;\n    zng_inflateInit2;\n    zlibng_version;\n};\n\nZLIB_NG_2.0.0 {\n  global:\n    zng_adler32;\n    zng_adler32_combine;\n    zng_adler32_z;\n    zng_compress;\n    zng_compress2;\n    zng_compressBound;\n    zng_crc32;\n    zng_crc32_combine;\n    zng_crc32_combine_gen;\n    zng_crc32_combine_op;\n    zng_crc32_z;\n    zng_deflate;\n    zng_deflateBound;\n    zng_deflateCopy;\n    zng_deflateEnd;\n    zng_deflateGetDictionary;\n    zng_deflateGetParams;\n    zng_deflateInit_;\n    zng_deflateInit2_;\n    zng_deflateParams;\n    zng_deflatePending;\n    zng_deflatePrime;\n    zng_deflateReset;\n    zng_deflateResetKeep;\n    zng_deflateSetDictionary;\n    zng_deflateSetHeader;\n    zng_deflateSetParams;\n    zng_deflateTune;\n    zng_get_crc_table;\n    zng_inflate;\n    zng_inflateBack;\n    zng_inflateBackEnd;\n    zng_inflateBackInit_;\n    zng_inflateCodesUsed;\n    zng_inflateCopy;\n    zng_inflateEnd;\n    zng_inflateGetDictionary;\n    zng_inflateGetHeader;\n    zng_inflateInit_;\n    zng_inflateInit2_;\n    zng_inflateMark;\n    zng_inflatePrime;\n    zng_inflateReset;\n    zng_inflateReset2;\n    zng_inflateResetKeep;\n    zng_inflateSetDictionary;\n    zng_inflateSync;\n    zng_inflateSyncPoint;\n    zng_inflateUndermine;\n    zng_inflateValidate;\n    zng_uncompress;\n    zng_uncompress2;\n    zng_zError;\n    zng_zlibCompileFlags;\n    zng_vstring;\n  local:\n    zng_deflate_copyright;\n    zng_inflate_copyright;\n    zng_zcalloc;\n    zng_zcfree;\n    zng_z_errmsg;\n    gz_error;\n    _*;\n};\n\nZLIB_NG_GZ_2.0.0 {\n  global:\n    zng_gzbuffer;\n    zng_gzclearerr;\n    zng_gzclose;\n    zng_gzclose_r;\n    zng_gzclose_w;\n    zng_gzdirect;\n    zng_gzdopen;\n    zng_gzeof;\n    zng_gzerror;\n    zng_gzflush;\n    zng_gzfread;\n    zng_gzfwrite;\n    zng_gzgetc;\n    zng_gzgets;\n    zng_gzoffset;\n    zng_gzopen;\n    zng_gzprintf;\n    zng_gzputc;\n    zng_gzputs;\n    zng_gzread;\n    zng_gzrewind;\n    zng_gzseek;\n    zng_gzsetparams;\n    zng_gztell;\n    zng_gzungetc;\n    zng_gzvprintf;\n    zng_gzwrite;\n};\n\nFAIL {\n  local: *;\n};\n"
        },
        {
          "name": "zlib.h.in",
          "type": "blob",
          "size": 93.2265625,
          "content": "#ifndef ZLIB_H_\n#define ZLIB_H_\n/* zlib.h -- interface of the 'zlib-ng' compression library\n   Forked from and compatible with zlib 1.3.1\n\n  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\n\n  The data format used by the zlib library is described by RFCs (Request for\n  Comments) 1950 to 1952 in the files https://tools.ietf.org/html/rfc1950\n  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).\n*/\n\n#ifdef ZNGLIB_H_\n#  error Include zlib-ng.h for zlib-ng API or zlib.h for zlib-compat API but not both\n#endif\n\n#ifndef RC_INVOKED\n#include <stdint.h>\n#include <stdarg.h>\n\n#include \"zconf.h\"\n\n#ifndef ZCONF_H\n#  error Missing zconf.h add binary output directory to include directories\n#endif\n#endif  /* RC_INVOKED */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ZLIBNG_VERSION \"2.2.3\"\n#define ZLIBNG_VERNUM 0x020203F0L   /* MMNNRRSM: major minor revision status modified */\n#define ZLIBNG_VER_MAJOR 2\n#define ZLIBNG_VER_MINOR 2\n#define ZLIBNG_VER_REVISION 3\n#define ZLIBNG_VER_STATUS F         /* 0=devel, 1-E=beta, F=Release (DEPRECATED) */\n#define ZLIBNG_VER_STATUSH 0xF      /* Hex values: 0=devel, 1-E=beta, F=Release */\n#define ZLIBNG_VER_MODIFIED 0       /* non-zero if modified externally from zlib-ng */\n\n#define ZLIB_VERSION \"1.3.1.zlib-ng\"\n#define ZLIB_VERNUM 0x131f\n#define ZLIB_VER_MAJOR 1\n#define ZLIB_VER_MINOR 3\n#define ZLIB_VER_REVISION 1\n#define ZLIB_VER_SUBREVISION 15    /* 15=fork (0xf) */\n\n/*\n    The 'zlib' compression library provides in-memory compression and\n  decompression functions, including integrity checks of the uncompressed data.\n  This version of the library supports only one compression method (deflation)\n  but other algorithms will be added later and will have the same stream\n  interface.\n\n    Compression can be done in a single step if the buffers are large enough,\n  or can be done by repeated calls of the compression function.  In the latter\n  case, the application must provide more input and/or consume the output\n  (providing more output space) before each call.\n\n    The compressed data format used by default by the in-memory functions is\n  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped\n  around a deflate stream, which is itself documented in RFC 1951.\n\n    The library also supports reading and writing files in gzip (.gz) format\n  with an interface similar to that of stdio using the functions that start\n  with \"gz\".  The gzip format is different from the zlib format.  gzip is a\n  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.\n\n    This library can optionally read and write gzip and raw deflate streams in\n  memory as well.\n\n    The zlib format was designed to be compact and fast for use in memory\n  and on communications channels.  The gzip format was designed for single-\n  file compression on file systems, has a larger header than zlib to maintain\n  directory information, and uses a different, slower check method than zlib.\n\n    The library does not install any signal handler.  The decoder checks\n  the consistency of the compressed data, so the library should never crash\n  even in the case of corrupted input.\n*/\n\ntypedef void *(*alloc_func) (void *opaque, unsigned int items, unsigned int size);\ntypedef void  (*free_func)  (void *opaque, void *address);\n\nstruct internal_state;\n\ntypedef struct z_stream_s {\n    z_const unsigned char *next_in;   /* next input byte */\n    uint32_t              avail_in;   /* number of bytes available at next_in */\n    unsigned long         total_in;   /* total number of input bytes read so far */\n\n    unsigned char         *next_out;  /* next output byte will go here */\n    uint32_t              avail_out;  /* remaining free space at next_out */\n    unsigned long         total_out;  /* total number of bytes output so far */\n\n    z_const char          *msg;       /* last error message, NULL if no error */\n    struct internal_state *state;     /* not visible by applications */\n\n    alloc_func            zalloc;     /* used to allocate the internal state */\n    free_func             zfree;      /* used to free the internal state */\n    void                  *opaque;    /* private data object passed to zalloc and zfree */\n\n    int                   data_type;  /* best guess about the data type: binary or text\n                                         for deflate, or the decoding state for inflate */\n    unsigned long         adler;      /* Adler-32 or CRC-32 value of the uncompressed data */\n    unsigned long         reserved;   /* reserved for future use */\n} z_stream;\n\ntypedef z_stream *z_streamp;  /* Obsolete type, retained for compatibility only */\n\n/*\n    gzip header information passed to and from zlib routines.  See RFC 1952\n  for more details on the meanings of these fields.\n*/\ntypedef struct gz_header_s {\n    int             text;       /* true if compressed data believed to be text */\n    unsigned long   time;       /* modification time */\n    int             xflags;     /* extra flags (not used when writing a gzip file) */\n    int             os;         /* operating system */\n    unsigned char   *extra;     /* pointer to extra field or NULL if none */\n    unsigned int    extra_len;  /* extra field length (valid if extra != NULL) */\n    unsigned int    extra_max;  /* space at extra (only when reading header) */\n    unsigned char   *name;      /* pointer to zero-terminated file name or NULL */\n    unsigned int    name_max;   /* space at name (only when reading header) */\n    unsigned char   *comment;   /* pointer to zero-terminated comment or NULL */\n    unsigned int    comm_max;   /* space at comment (only when reading header) */\n    int             hcrc;       /* true if there was or will be a header crc */\n    int             done;       /* true when done reading gzip header (not used when writing a gzip file) */\n} gz_header;\n\ntypedef gz_header *gz_headerp;\n\n/*\n     The application must update next_in and avail_in when avail_in has dropped\n   to zero.  It must update next_out and avail_out when avail_out has dropped\n   to zero.  The application must initialize zalloc, zfree and opaque before\n   calling the init function.  All other fields are set by the compression\n   library and must not be updated by the application.\n\n     The opaque value provided by the application will be passed as the first\n   parameter for calls of zalloc and zfree.  This can be useful for custom\n   memory management.  The compression library attaches no meaning to the\n   opaque value.\n\n     zalloc must return NULL if there is not enough memory for the object.\n   If zlib is used in a multi-threaded application, zalloc and zfree must be\n   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are\n   Z_NULL on entry to the initialization function, they are set to internal\n   routines that use the standard library functions malloc() and free().\n\n     The fields total_in and total_out can be used for statistics or progress\n   reports.  After compression, total_in holds the total size of the\n   uncompressed data and may be saved for use by the decompressor (particularly\n   if the decompressor wants to decompress everything in a single step).\n*/\n\n                        /* constants */\n\n#define Z_NO_FLUSH      0\n#define Z_PARTIAL_FLUSH 1\n#define Z_SYNC_FLUSH    2\n#define Z_FULL_FLUSH    3\n#define Z_FINISH        4\n#define Z_BLOCK         5\n#define Z_TREES         6\n/* Allowed flush values; see deflate() and inflate() below for details */\n\n#define Z_OK            0\n#define Z_STREAM_END    1\n#define Z_NEED_DICT     2\n#define Z_ERRNO        (-1)\n#define Z_STREAM_ERROR (-2)\n#define Z_DATA_ERROR   (-3)\n#define Z_MEM_ERROR    (-4)\n#define Z_BUF_ERROR    (-5)\n#define Z_VERSION_ERROR (-6)\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\n\n#define Z_NO_COMPRESSION         0\n#define Z_BEST_SPEED             1\n#define Z_BEST_COMPRESSION       9\n#define Z_DEFAULT_COMPRESSION  (-1)\n/* compression levels */\n\n#define Z_FILTERED            1\n#define Z_HUFFMAN_ONLY        2\n#define Z_RLE                 3\n#define Z_FIXED               4\n#define Z_DEFAULT_STRATEGY    0\n/* compression strategy; see deflateInit2() below for details */\n\n#define Z_BINARY   0\n#define Z_TEXT     1\n#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */\n#define Z_UNKNOWN  2\n/* Possible values of the data_type field for deflate() */\n\n#define Z_DEFLATED   8\n/* The deflate compression method (the only one supported in this version) */\n\n#define Z_NULL  0  /* for compatibility with zlib, was for initializing zalloc, zfree, opaque */\n\n#define zlib_version zlibVersion()\n/* for compatibility with versions < 1.0.2 */\n\n\n                        /* basic functions */\n\nZ_EXTERN const char * Z_EXPORT zlibVersion(void);\n/* The application can compare zlibVersion and ZLIB_VERSION for consistency.\n   If the first character differs, the library code actually used is not\n   compatible with the zlib.h header file used by the application.  This check\n   is automatically made by deflateInit and inflateInit.\n */\n\n/*\nZ_EXTERN int Z_EXPORT deflateInit (z_stream *strm, int level);\n\n     Initializes the internal stream state for compression.  The fields\n   zalloc, zfree and opaque must be initialized before by the caller.  If\n   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default\n   allocation functions.  total_in, total_out, adler, and msg are initialized.\n\n     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:\n   1 gives best speed, 9 gives best compression, 0 gives no compression at all\n   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION\n   requests a default compromise between speed and compression (currently\n   equivalent to level 6).\n\n     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if level is not a valid compression level, or\n   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible\n   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null\n   if there is no error message.  deflateInit does not perform any compression:\n   this will be done by deflate().\n*/\n\n\nZ_EXTERN int Z_EXPORT deflate(z_stream *strm, int flush);\n/*\n    deflate compresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n    The detailed semantics are as follows.  deflate performs one or both of the\n  following actions:\n\n  - Compress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), next_in and avail_in are updated and\n    processing will resume at this point for the next call of deflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  This action is forced if the parameter flush is non zero.\n    Forcing flush frequently degrades the compression ratio, so this parameter\n    should be set only when necessary.  Some output may be provided even if\n    flush is zero.\n\n    Before the call of deflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating avail_in or avail_out accordingly; avail_out should\n  never be zero before the call.  The application can consume the compressed\n  output when it wants, for example when the output buffer is full (avail_out\n  == 0), or after each call of deflate().  If deflate returns Z_OK and with\n  zero avail_out, it must be called again after making room in the output\n  buffer because there might be more output pending. See deflatePending(),\n  which can be used if desired to determine whether or not there is more output\n  in that case.\n\n    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to\n  decide how much data to accumulate before producing output, in order to\n  maximize compression.\n\n    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is\n  flushed to the output buffer and the output is aligned on a byte boundary, so\n  that the decompressor can get all input data available so far.  (In\n  particular avail_in is zero after the call if enough output space has been\n  provided before the call.) Flushing may degrade compression for some\n  compression algorithms and so it should be used only when necessary.  This\n  completes the current deflate block and follows it with an empty stored block\n  that is three bits plus filler bits to the next byte, followed by four bytes\n  (00 00 ff ff).\n\n    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the\n  output buffer, but the output is not aligned to a byte boundary.  All of the\n  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.\n  This completes the current deflate block and follows it with an empty fixed\n  codes block that is 10 bits long.  This assures that enough bytes are output\n  in order for the decompressor to finish the block before the empty fixed\n  codes block.\n\n    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as\n  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to\n  seven bits of the current block are held to be written as the next byte after\n  the next deflate block is completed.  In this case, the decompressor may not\n  be provided enough bits at this point in order to complete decompression of\n  the data provided so far to the compressor.  It may need to wait for the next\n  block to be emitted.  This is for advanced applications that need to control\n  the emission of deflate blocks.\n\n    If flush is set to Z_FULL_FLUSH, all output is flushed as with\n  Z_SYNC_FLUSH, and the compression state is reset so that decompression can\n  restart from this point if previous compressed data has been damaged or if\n  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade\n  compression.\n\n    If deflate returns with avail_out == 0, this function must be called again\n  with the same value of the flush parameter and more output space (updated\n  avail_out), until the flush is complete (deflate returns with non-zero\n  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that\n  avail_out is greater than six when the flush marker begins, in order to avoid\n  repeated flush markers upon calling deflate() again when avail_out == 0.\n\n    If the parameter flush is set to Z_FINISH, pending input is processed,\n  pending output is flushed and deflate returns with Z_STREAM_END if there was\n  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this\n  function must be called again with Z_FINISH and more output space (updated\n  avail_out) but no more input data, until it returns with Z_STREAM_END or an\n  error.  After deflate has returned Z_STREAM_END, the only possible operations\n  on the stream are deflateReset or deflateEnd.\n\n    Z_FINISH can be used in the first deflate call after deflateInit if all the\n  compression is to be done in a single step.  In order to complete in one\n  call, avail_out must be at least the value returned by deflateBound (see\n  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough\n  output space is provided, deflate will not return Z_STREAM_END, and it must\n  be called again as described above.\n\n    deflate() sets strm->adler to the Adler-32 checksum of all input read\n  so far (that is, total_in bytes).  If a gzip stream is being generated, then\n  strm->adler will be the CRC-32 checksum of the input read so far.  (See\n  deflateInit2 below.)\n\n    deflate() may update strm->data_type if it can make a good guess about\n  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is\n  considered binary.  This field is only for information purposes and does not\n  affect the compression algorithm in any manner.\n\n    deflate() returns Z_OK if some progress has been made (more input\n  processed or more output produced), Z_STREAM_END if all input has been\n  consumed and all output has been produced (only when flush is set to\n  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example\n  if next_in or next_out was NULL) or the state was inadvertently written over\n  by the application), or Z_BUF_ERROR if no progress is possible (for example\n  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and\n  deflate() can be called again with more input and more output space to\n  continue compressing.\n*/\n\n\nZ_EXTERN int Z_EXPORT deflateEnd(z_stream *strm);\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the\n   stream state was inconsistent, Z_DATA_ERROR if the stream was freed\n   prematurely (some input or output was discarded).  In the error case, msg\n   may be set but then points to a static string (which must not be\n   deallocated).\n*/\n\n\n/*\nZ_EXTERN int Z_EXPORT inflateInit (z_stream *strm);\n\n     Initializes the internal stream state for decompression.  The fields\n   next_in, avail_in, zalloc, zfree and opaque must be initialized before by\n   the caller.  In the current version of inflate, the provided input is not\n   read or consumed.  The allocation of a sliding window will be deferred to\n   the first call of inflate (if the decompression does not complete on the\n   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates\n   them to use default allocation functions.  total_in, total_out, adler, and\n   msg are initialized.\n\n     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n   version assumed by the caller, or Z_STREAM_ERROR if the parameters are\n   invalid, such as a null pointer to the structure.  msg is set to null if\n   there is no error message.  inflateInit does not perform any decompression.\n   Actual decompression will be done by inflate().  So next_in, and avail_in,\n   next_out, and avail_out are unused and unchanged.  The current\n   implementation of inflateInit() does not process any header information --\n   that is deferred until inflate() is called.\n*/\n\n\nZ_EXTERN int Z_EXPORT inflate(z_stream *strm, int flush);\n/*\n    inflate decompresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full.  It may introduce\n  some output latency (reading input without producing any output) except when\n  forced to flush.\n\n  The detailed semantics are as follows.  inflate performs one or both of the\n  following actions:\n\n  - Decompress more input starting at next_in and update next_in and avail_in\n    accordingly.  If not all input can be processed (because there is not\n    enough room in the output buffer), then next_in and avail_in are updated\n    accordingly, and processing will resume at this point for the next call of\n    inflate().\n\n  - Generate more output starting at next_out and update next_out and avail_out\n    accordingly.  inflate() provides as much output as possible, until there is\n    no more input data or no more space in the output buffer (see below about\n    the flush parameter).\n\n    Before the call of inflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming more\n  output, and updating the next_* and avail_* values accordingly.  If the\n  caller of inflate() does not provide both available input and available\n  output space, it is possible that there will be no progress made.  The\n  application can consume the uncompressed output when it wants, for example\n  when the output buffer is full (avail_out == 0), or after each call of\n  inflate().  If inflate returns Z_OK and with zero avail_out, it must be\n  called again after making room in the output buffer because there might be\n  more output pending.\n\n    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,\n  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much\n  output as possible to the output buffer.  Z_BLOCK requests that inflate()\n  stop if and when it gets to the next deflate block boundary.  When decoding\n  the zlib or gzip format, this will cause inflate() to return immediately\n  after the header and before the first block.  When doing a raw inflate,\n  inflate() will go ahead and process the first block, and will return when it\n  gets to the end of that block, or when it runs out of data.\n\n    The Z_BLOCK option assists in appending to or combining deflate streams.\n  To assist in this, on return inflate() always sets strm->data_type to the\n  number of unused bits in the last byte taken from strm->next_in, plus 64 if\n  inflate() is currently decoding the last block in the deflate stream, plus\n  128 if inflate() returned immediately after decoding an end-of-block code or\n  decoding the complete header up to just before the first byte of the deflate\n  stream.  The end-of-block will not be indicated until all of the uncompressed\n  data from that block has been written to strm->next_out.  The number of\n  unused bits may in general be greater than seven, except when bit 7 of\n  data_type is set, in which case the number of unused bits will be less than\n  eight.  data_type is set as noted here every time inflate() returns for all\n  flush options, and so can be used to determine the amount of currently\n  consumed input in bits.\n\n    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the\n  end of each deflate block header is reached, before any actual data in that\n  block is decoded.  This allows the caller to determine the length of the\n  deflate block header for later use in random access within a deflate block.\n  256 is added to the value of strm->data_type when inflate() returns\n  immediately after reaching the end of the deflate block header.\n\n    inflate() should normally be called until it returns Z_STREAM_END or an\n  error.  However if all decompression is to be performed in a single step (a\n  single call of inflate), the parameter flush should be set to Z_FINISH.  In\n  this case all pending input is processed and all pending output is flushed;\n  avail_out must be large enough to hold all of the uncompressed data for the\n  operation to complete.  (The size of the uncompressed data may have been\n  saved by the compressor for this purpose.)  The use of Z_FINISH is not\n  required to perform an inflation in one step.  However it may be used to\n  inform inflate that a faster approach can be used for the single inflate()\n  call.  Z_FINISH also informs inflate to not maintain a sliding window if the\n  stream completes, which reduces inflate's memory footprint.  If the stream\n  does not complete, either because not all of the stream is provided or not\n  enough output space is provided, then a sliding window will be allocated and\n  inflate() can be called again to continue the operation as if Z_NO_FLUSH had\n  been used.\n\n     In this implementation, inflate() always flushes as much output as\n  possible to the output buffer, and always uses the faster approach on the\n  first call.  So the effects of the flush parameter in this implementation are\n  on the return value of inflate() as noted below, when inflate() returns early\n  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of\n  memory for a sliding window when Z_FINISH is used.\n\n     If a preset dictionary is needed after this call (see inflateSetDictionary\n  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary\n  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets\n  strm->adler to the Adler-32 checksum of all output produced so far (that is,\n  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described\n  below.  At the end of the stream, inflate() checks that its computed Adler-32\n  checksum is equal to that saved by the compressor and returns Z_STREAM_END\n  only if the checksum is correct.\n\n    inflate() can decompress and check either zlib-wrapped or gzip-wrapped\n  deflate data.  The header type is detected automatically, if requested when\n  initializing with inflateInit2().  Any information contained in the gzip\n  header is not retained unless inflateGetHeader() is used.  When processing\n  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output\n  produced so far.  The CRC-32 is checked against the gzip trailer, as is the\n  uncompressed length, modulo 2^32.\n\n    inflate() returns Z_OK if some progress has been made (more input processed\n  or more output produced), Z_STREAM_END if the end of the compressed data has\n  been reached and all uncompressed output has been produced, Z_NEED_DICT if a\n  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was\n  corrupted (input stream not conforming to the zlib format or incorrect check\n  value, in which case strm->msg points to a string with a more specific\n  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example\n  next_in or next_out was NULL, or the state was inadvertently written over\n  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR\n  if no progress is possible or if there was not enough room in the output\n  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and\n  inflate() can be called again with more input and more output space to\n  continue decompressing.  If Z_DATA_ERROR is returned, the application may\n  then call inflateSync() to look for a good compression block if a partial\n  recovery of the data is to be attempted.\n*/\n\n\nZ_EXTERN int Z_EXPORT inflateEnd(z_stream *strm);\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any pending\n   output.\n\n     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state\n   was inconsistent.\n*/\n\n\n                        /* Advanced functions */\n\n/*\n    The following functions are needed only in some special applications.\n*/\n\n/*\nZ_EXTERN int Z_EXPORT deflateInit2 (z_stream *strm,\n                                     int  level,\n                                     int  method,\n                                     int  windowBits,\n                                     int  memLevel,\n                                     int  strategy);\n\n     This is another version of deflateInit with more compression options.  The\n   fields zalloc, zfree and opaque must be initialized before by the caller.\n\n     The method parameter is the compression method.  It must be Z_DEFLATED in\n   this version of the library.\n\n     The windowBits parameter is the base two logarithm of the window size\n   (the size of the history buffer).  It should be in the range 8..15 for this\n   version of the library.  Larger values of this parameter result in better\n   compression at the expense of memory usage.  The default value is 15 if\n   deflateInit is used instead.\n\n     For the current implementation of deflate(), a windowBits value of 8 (a\n   window size of 256 bytes) is not supported.  As a result, a request for 8\n   will result in 9 (a 512-byte window).  In that case, providing 8 to\n   inflateInit2() will result in an error when the zlib header with 9 is\n   checked against the initialization of inflate().  The remedy is to not use 8\n   with deflateInit2() with this initialization, or at least in that case use 9\n   with inflateInit2().\n\n     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits\n   determines the window size.  deflate() will then generate raw deflate data\n   with no zlib header or trailer, and will not compute a check value.\n\n     windowBits can also be greater than 15 for optional gzip encoding.  Add\n   16 to windowBits to write a simple gzip header and trailer around the\n   compressed data instead of a zlib wrapper.  The gzip header will have no\n   file name, no extra data, no comment, no modification time (set to zero), no\n   header crc, and the operating system will be set to the appropriate value,\n   if the operating system was determined at compile time.  If a gzip stream is\n   being written, strm->adler is a CRC-32 instead of an Adler-32.\n\n     For raw deflate or gzip encoding, a request for a 256-byte window is\n   rejected as invalid, since only the zlib header provides a means of\n   transmitting the window size to the decompressor.\n\n     The memLevel parameter specifies how much memory should be allocated\n   for the internal compression state.  memLevel=1 uses minimum memory but is\n   slow and reduces compression ratio; memLevel=9 uses maximum memory for\n   optimal speed.  The default value is 8.  See zconf.h for total memory usage\n   as a function of windowBits and memLevel.\n\n     The strategy parameter is used to tune the compression algorithm.  Use the\n   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a\n   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no\n   string match), or Z_RLE to limit match distances to one (run-length\n   encoding).  Filtered data consists mostly of small values with a somewhat\n   random distribution.  In this case, the compression algorithm is tuned to\n   compress them better.  The effect of Z_FILTERED is to force more Huffman\n   coding and less string matching; it is somewhat intermediate between\n   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as\n   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The\n   strategy parameter only affects the compression ratio but not the\n   correctness of the compressed output even if it is not set appropriately.\n   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler\n   decoder for special applications.\n\n     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid\n   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is\n   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is\n   set to null if there is no error message.  deflateInit2 does not perform any\n   compression: this will be done by deflate().\n*/\n\nZ_EXTERN int Z_EXPORT deflateSetDictionary(z_stream *strm,\n                                             const unsigned char *dictionary,\n                                             unsigned int dictLength);\n/*\n     Initializes the compression dictionary from the given byte sequence\n   without producing any compressed output.  When using the zlib format, this\n   function must be called immediately after deflateInit, deflateInit2 or\n   deflateReset, and before any call of deflate.  When doing raw deflate, this\n   function must be called either before any call of deflate, or immediately\n   after the completion of a deflate block, i.e. after all input has been\n   consumed and all output has been delivered when using any of the flush\n   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The\n   compressor and decompressor must use exactly the same dictionary (see\n   inflateSetDictionary).\n\n     The dictionary should consist of strings (byte sequences) that are likely\n   to be encountered later in the data to be compressed, with the most commonly\n   used strings preferably put towards the end of the dictionary.  Using a\n   dictionary is most useful when the data to be compressed is short and can be\n   predicted with good accuracy; the data can then be compressed better than\n   with the default empty dictionary.\n\n     Depending on the size of the compression data structures selected by\n   deflateInit or deflateInit2, a part of the dictionary may in effect be\n   discarded, for example if the dictionary is larger than the window size\n   provided in deflateInit or deflateInit2.  Thus the strings most likely to be\n   useful should be put at the end of the dictionary, not at the front.  In\n   addition, the current implementation of deflate will use at most the window\n   size minus 262 bytes of the provided dictionary.\n\n     Upon return of this function, strm->adler is set to the Adler-32 value\n   of the dictionary; the decompressor may later use this value to determine\n   which dictionary has been used by the compressor.  (The Adler-32 value\n   applies to the whole dictionary even if only a subset of the dictionary is\n   actually used by the compressor.) If a raw deflate was requested, then the\n   Adler-32 value is not computed and strm->adler is not set.\n\n     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being NULL) or the stream state is\n   inconsistent (for example if deflate has already been called for this stream\n   or if not at a block boundary for raw deflate).  deflateSetDictionary does\n   not perform any compression: this will be done by deflate().\n*/\n\nZ_EXTERN int Z_EXPORT deflateGetDictionary (z_stream *strm, unsigned char *dictionary, unsigned int *dictLength);\n/*\n     Returns the sliding dictionary being maintained by deflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If deflateGetDictionary() is called with dictionary equal to\n   Z_NULL, then only the dictionary length is returned, and nothing is copied.\n   Similarly, if dictLength is Z_NULL, then it is not set.\n\n     deflateGetDictionary() may return a length less than the window size, even\n   when more than the window size in input has been provided. It may return up\n   to 258 bytes less in that case, due to how zlib's implementation of deflate\n   manages the sliding window and lookahead for matches, where matches can be\n   up to 258 bytes long. If the application needs the last window-size bytes of\n   input, then that would need to be saved by the application outside of zlib.\n\n     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n*/\n\nZ_EXTERN int Z_EXPORT deflateCopy(z_stream *dest, z_stream *source);\n/*\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when several compression strategies will be\n   tried, for example when there are several ways of pre-processing the input\n   data with a filter.  The streams that will be discarded should then be freed\n   by calling deflateEnd.  Note that deflateCopy duplicates the internal\n   compression state which can be quite large, so this strategy is slow and can\n   consume lots of memory.\n\n     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being NULL).  msg is left unchanged in both source and\n   destination.\n*/\n\nZ_EXTERN int Z_EXPORT deflateReset(z_stream *strm);\n/*\n     This function is equivalent to deflateEnd followed by deflateInit, but\n   does not free and reallocate the internal compression state.  The stream\n   will leave the compression level and any other attributes that may have been\n   set unchanged.  total_in, total_out, adler, and msg are initialized.\n\n     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL).\n*/\n\nZ_EXTERN int Z_EXPORT deflateParams(z_stream *strm, int level, int strategy);\n/*\n     Dynamically update the compression level and compression strategy.  The\n   interpretation of level and strategy is as in deflateInit2().  This can be\n   used to switch between compression and straight copy of the input data, or\n   to switch to a different kind of input data requiring a different strategy.\n   If the compression approach (which is a function of the level) or the\n   strategy is changed, and if there have been any deflate() calls since the\n   state was initialized or reset, then the input available so far is\n   compressed with the old level and strategy using deflate(strm, Z_BLOCK).\n   There are three approaches for the compression levels 0, 1..3, and 4..9\n   respectively.  The new level and strategy will take effect at the next call\n   of deflate().\n\n     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does\n   not have enough output space to complete, then the parameter change will not\n   take effect.  In this case, deflateParams() can be called again with the\n   same parameters and more output space to try again.\n\n     In order to assure a change in the parameters on the first try, the\n   deflate stream should be flushed using deflate() with Z_BLOCK or other flush\n   request until strm.avail_out is not zero, before calling deflateParams().\n   Then no more input data should be provided before the deflateParams() call.\n   If this is done, the old level and strategy will be applied to the data\n   compressed before deflateParams(), and the new level and strategy will be\n   applied to the data compressed after deflateParams().\n\n     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream\n   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if\n   there was not enough output space to complete the compression of the\n   available input data before a change in the strategy or approach.  Note that\n   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return\n   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be\n   retried with more output space.\n*/\n\nZ_EXTERN int Z_EXPORT deflateTune(z_stream *strm, int good_length, int max_lazy, int nice_length, int max_chain);\n/*\n     Fine tune deflate's internal compression parameters.  This should only be\n   used by someone who understands the algorithm used by zlib's deflate for\n   searching for the best matching string, and even then only by the most\n   fanatic optimizer trying to squeeze out the last compressed bit for their\n   specific input data.  Read the deflate.c source code for the meaning of the\n   max_lazy, good_length, nice_length, and max_chain parameters.\n\n     deflateTune() can be called after deflateInit() or deflateInit2(), and\n   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.\n */\n\nZ_EXTERN unsigned long Z_EXPORT deflateBound(z_stream *strm, unsigned long sourceLen);\n/*\n     deflateBound() returns an upper bound on the compressed size after\n   deflation of sourceLen bytes.  It must be called after deflateInit() or\n   deflateInit2(), and after deflateSetHeader(), if used.  This would be used\n   to allocate an output buffer for deflation in a single pass, and so would be\n   called before deflate().  If that first deflate() call is provided the\n   sourceLen input bytes, an output buffer allocated to the size returned by\n   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed\n   to return Z_STREAM_END.  Note that it is possible for the compressed size to\n   be larger than the value returned by deflateBound() if flush options other\n   than Z_FINISH or Z_NO_FLUSH are used.\n*/\n\nZ_EXTERN int Z_EXPORT deflatePending(z_stream *strm, uint32_t *pending, int *bits);\n/*\n     deflatePending() returns the number of bytes and bits of output that have\n   been generated, but not yet provided in the available output.  The bytes not\n   provided would be due to the available output space having being consumed.\n   The number of bits of output not provided are between 0 and 7, where they\n   await more bits to join them in order to fill out a full byte.  If pending\n   or bits are NULL, then those values are not set.\n\n     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n */\n\nZ_EXTERN int Z_EXPORT deflatePrime(z_stream *strm, int bits, int value);\n/*\n     deflatePrime() inserts bits in the deflate output stream.  The intent\n   is that this function is used to start off the deflate output with the bits\n   leftover from a previous deflate stream when appending to it.  As such, this\n   function can only be used for raw deflate, and must be used before the first\n   deflate() call after a deflateInit2() or deflateReset().  bits must be less\n   than or equal to 16, and that many of the least significant bits of value\n   will be inserted in the output.\n\n     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough\n   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the\n   source stream state was inconsistent.\n*/\n\nZ_EXTERN int Z_EXPORT deflateSetHeader(z_stream *strm, gz_headerp head);\n/*\n     deflateSetHeader() provides gzip header information for when a gzip\n   stream is requested by deflateInit2().  deflateSetHeader() may be called\n   after deflateInit2() or deflateReset() and before the first call of\n   deflate().  The text, time, os, extra field, name, and comment information\n   in the provided gz_header structure are written to the gzip header (xflag is\n   ignored -- the extra flags are set according to the compression level).  The\n   caller must assure that, if not NULL, name and comment are terminated with\n   a zero byte, and that if extra is not NULL, that extra_len bytes are\n   available there.  If hcrc is true, a gzip header crc is included.  Note that\n   the current versions of the command-line version of gzip (up through version\n   1.3.x) do not support header crc's, and will report that it is a \"multi-part\n   gzip file\" and give up.\n\n     If deflateSetHeader is not used, the default gzip header has text false,\n   the time set to zero, and os set to the current operating system, with no\n   extra, name, or comment fields.  The gzip header is returned to the default\n   state by deflateReset().\n\n     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\n/*\nZ_EXTERN int Z_EXPORT inflateInit2(z_stream *strm, int  windowBits);\n\n     This is another version of inflateInit with an extra parameter.  The\n   fields next_in, avail_in, zalloc, zfree and opaque must be initialized\n   before by the caller.\n\n     The windowBits parameter is the base two logarithm of the maximum window\n   size (the size of the history buffer).  It should be in the range 8..15 for\n   this version of the library.  The default value is 15 if inflateInit is used\n   instead.  windowBits must be greater than or equal to the windowBits value\n   provided to deflateInit2() while compressing, or it must be equal to 15 if\n   deflateInit2() was not used.  If a compressed stream with a larger window\n   size is given as input, inflate() will return with the error code\n   Z_DATA_ERROR instead of trying to allocate a larger window.\n\n     windowBits can also be zero to request that inflate use the window size in\n   the zlib header of the compressed stream.\n\n     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits\n   determines the window size.  inflate() will then process raw deflate data,\n   not looking for a zlib or gzip header, not generating a check value, and not\n   looking for any check values for comparison at the end of the stream.  This\n   is for use with other formats that use the deflate compressed data format\n   such as zip.  Those formats provide their own check values.  If a custom\n   format is developed using the raw deflate format for compressed data, it is\n   recommended that a check value such as an Adler-32 or a CRC-32 be applied to\n   the uncompressed data as is done in the zlib, gzip, and zip formats.  For\n   most applications, the zlib format should be used as is.  Note that comments\n   above on the use in deflateInit2() applies to the magnitude of windowBits.\n\n     windowBits can also be greater than 15 for optional gzip decoding.  Add\n   32 to windowBits to enable zlib and gzip decoding with automatic header\n   detection, or add 16 to decode only the gzip format (the zlib format will\n   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a\n   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see\n   below), inflate() will *not* automatically decode concatenated gzip members.\n   inflate() will return Z_STREAM_END at the end of the gzip member.  The state\n   would need to be reset to continue decoding a subsequent gzip member.  This\n   *must* be done if there is more data after a gzip member, in order for the\n   decompression to be compliant with the gzip standard (RFC 1952).\n\n     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n   version assumed by the caller, or Z_STREAM_ERROR if the parameters are\n   invalid, such as a null pointer to the structure.  msg is set to null if\n   there is no error message.  inflateInit2 does not perform any decompression\n   apart from possibly reading the zlib header if present: actual decompression\n   will be done by inflate().  (So next_in and avail_in may be modified, but\n   next_out and avail_out are unused and unchanged.) The current implementation\n   of inflateInit2() does not process any header information -- that is\n   deferred until inflate() is called.\n*/\n\nZ_EXTERN int Z_EXPORT inflateSetDictionary(z_stream *strm, const unsigned char *dictionary, unsigned int dictLength);\n/*\n     Initializes the decompression dictionary from the given uncompressed byte\n   sequence.  This function must be called immediately after a call of inflate,\n   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor\n   can be determined from the Adler-32 value returned by that call of inflate.\n   The compressor and decompressor must use exactly the same dictionary (see\n   deflateSetDictionary).  For raw inflate, this function can be called at any\n   time to set the dictionary.  If the provided dictionary is smaller than the\n   window and there is already data in the window, then the provided dictionary\n   will amend what's there.  The application must ensure that the dictionary\n   that was used for compression is provided.\n\n     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n   parameter is invalid (e.g.  dictionary being NULL) or the stream state is\n   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the\n   expected one (incorrect Adler-32 value).  inflateSetDictionary does not\n   perform any decompression: this will be done by subsequent calls of\n   inflate().\n*/\n\nZ_EXTERN int Z_EXPORT inflateGetDictionary(z_stream *strm, unsigned char *dictionary, unsigned int *dictLength);\n/*\n     Returns the sliding dictionary being maintained by inflate.  dictLength is\n   set to the number of bytes in the dictionary, and that many bytes are copied\n   to dictionary.  dictionary must have enough space, where 32768 bytes is\n   always enough.  If inflateGetDictionary() is called with dictionary equal to\n   NULL, then only the dictionary length is returned, and nothing is copied.\n   Similarly, if dictLength is NULL, then it is not set.\n\n     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the\n   stream state is inconsistent.\n*/\n\nZ_EXTERN int Z_EXPORT inflateSync(z_stream *strm);\n/*\n     Skips invalid compressed data until a possible full flush point (see above\n   for the description of deflate with Z_FULL_FLUSH) can be found, or until all\n   available input is skipped.  No output is provided.\n\n     inflateSync searches for a 00 00 FF FF pattern in the compressed data.\n   All full flush points have this pattern, but not all occurrences of this\n   pattern are full flush points.\n\n     inflateSync returns Z_OK if a possible full flush point has been found,\n   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point\n   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.\n   In the success case, the application may save the current value of\n   total_in which indicates where valid compressed data was found.  In the\n   error case, the application may repeatedly call inflateSync, providing more\n   input each time, until success or end of the input data.\n*/\n\nZ_EXTERN int Z_EXPORT inflateCopy(z_stream *dest, z_stream *source);\n/*\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when randomly accessing a large stream.  The\n   first pass through the stream can periodically record the inflate state,\n   allowing restarting inflate at those points when randomly accessing the\n   stream.\n\n     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being NULL).  msg is left unchanged in both source and\n   destination.\n*/\n\nZ_EXTERN int Z_EXPORT inflateReset(z_stream *strm);\n/*\n     This function is equivalent to inflateEnd followed by inflateInit,\n   but does not free and reallocate the internal decompression state.  The\n   stream will keep attributes that may have been set by inflateInit2.\n   total_in, total_out, adler, and msg are initialized.\n\n     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL).\n*/\n\nZ_EXTERN int Z_EXPORT inflateReset2(z_stream *strm, int windowBits);\n/*\n     This function is the same as inflateReset, but it also permits changing\n   the wrap and window size requests.  The windowBits parameter is interpreted\n   the same as it is for inflateInit2.  If the window size is changed, then the\n   memory allocated for the window is freed, and the window will be reallocated\n   by inflate() if needed.\n\n     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL), or if\n   the windowBits parameter is invalid.\n*/\n\nZ_EXTERN int Z_EXPORT inflatePrime(z_stream *strm, int bits, int value);\n/*\n     This function inserts bits in the inflate input stream.  The intent is\n   that this function is used to start inflating at a bit position in the\n   middle of a byte.  The provided bits will be used before any bytes are used\n   from next_in.  This function should only be used with raw inflate, and\n   should be used before the first inflate() call after inflateInit2() or\n   inflateReset().  bits must be less than or equal to 16, and that many of the\n   least significant bits of value will be inserted in the input.\n\n     If bits is negative, then the input stream bit buffer is emptied.  Then\n   inflatePrime() can be called again to put bits in the buffer.  This is used\n   to clear out bits leftover after feeding inflate a block description prior\n   to feeding inflate codes.\n\n     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\nZ_EXTERN long Z_EXPORT inflateMark(z_stream *strm);\n/*\n     This function returns two values, one in the lower 16 bits of the return\n   value, and the other in the remaining upper bits, obtained by shifting the\n   return value down 16 bits.  If the upper value is -1 and the lower value is\n   zero, then inflate() is currently decoding information outside of a block.\n   If the upper value is -1 and the lower value is non-zero, then inflate is in\n   the middle of a stored block, with the lower value equaling the number of\n   bytes from the input remaining to copy.  If the upper value is not -1, then\n   it is the number of bits back from the current bit position in the input of\n   the code (literal or length/distance pair) currently being processed.  In\n   that case the lower value is the number of bytes already emitted for that\n   code.\n\n     A code is being processed if inflate is waiting for more input to complete\n   decoding of the code, or if it has completed decoding but is waiting for\n   more output space to write the literal or match data.\n\n     inflateMark() is used to mark locations in the input data for random\n   access, which may be at bit positions, and to note those cases where the\n   output of a code may span boundaries of random access blocks.  The current\n   location in the input stream can be determined from avail_in and data_type\n   as noted in the description for the Z_BLOCK flush parameter for inflate.\n\n     inflateMark returns the value noted above, or -65536 if the provided\n   source stream state was inconsistent.\n*/\n\nZ_EXTERN int Z_EXPORT inflateGetHeader(z_stream *strm, gz_headerp head);\n/*\n     inflateGetHeader() requests that gzip header information be stored in the\n   provided gz_header structure.  inflateGetHeader() may be called after\n   inflateInit2() or inflateReset(), and before the first call of inflate().\n   As inflate() processes the gzip stream, head->done is zero until the header\n   is completed, at which time head->done is set to one.  If a zlib stream is\n   being decoded, then head->done is set to -1 to indicate that there will be\n   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be\n   used to force inflate() to return immediately after header processing is\n   complete and before any actual data is decompressed.\n\n     The text, time, xflags, and os fields are filled in with the gzip header\n   contents.  hcrc is set to true if there is a header CRC.  (The header CRC\n   was valid if done is set to one.) If extra is not NULL, then extra_max\n   contains the maximum number of bytes to write to extra.  Once done is true,\n   extra_len contains the actual extra field length, and extra contains the\n   extra field, or that field truncated if extra_max is less than extra_len.\n   If name is not NULL, then up to name_max characters are written there,\n   terminated with a zero unless the length is greater than name_max.  If\n   comment is not NULL, then up to comm_max characters are written there,\n   terminated with a zero unless the length is greater than comm_max.  When any\n   of extra, name, or comment are not NULL and the respective field is not\n   present in the header, then that field is set to NULL to signal its\n   absence.  This allows the use of deflateSetHeader() with the returned\n   structure to duplicate the header.  However if those fields are set to\n   allocated memory, then the application will need to save those pointers\n   elsewhere so that they can be eventually freed.\n\n     If inflateGetHeader is not used, then the header information is simply\n   discarded.  The header is always checked for validity, including the header\n   CRC if present.  inflateReset() will reset the process to discard the header\n   information.  The application would need to call inflateGetHeader() again to\n   retrieve the header from the next gzip stream.\n\n     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent.\n*/\n\n/*\nZ_EXTERN int Z_EXPORT inflateBackInit (z_stream *strm, int windowBits, unsigned char *window);\n\n     Initialize the internal stream state for decompression using inflateBack()\n   calls.  The fields zalloc, zfree and opaque in strm must be initialized\n   before the call.  If zalloc and zfree are NULL, then the default library-\n   derived memory allocation routines are used.  windowBits is the base two\n   logarithm of the window size, in the range 8..15.  window is a caller\n   supplied buffer of that size.  Except for special applications where it is\n   assured that deflate was used with small window sizes, windowBits must be 15\n   and a 32K byte window must be supplied to be able to decompress general\n   deflate streams.\n\n     See inflateBack() for the usage of these routines.\n\n     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of\n   the parameters are invalid, Z_MEM_ERROR if the internal state could not be\n   allocated, or Z_VERSION_ERROR if the version of the library does not match\n   the version of the header file.\n*/\n\ntypedef uint32_t (*in_func) (void *, z_const unsigned char * *);\ntypedef int (*out_func) (void *, unsigned char *, uint32_t);\n\nZ_EXTERN int Z_EXPORT inflateBack(z_stream *strm, in_func in, void *in_desc, out_func out, void *out_desc);\n/*\n     inflateBack() does a raw inflate with a single call using a call-back\n   interface for input and output.  This is potentially more efficient than\n   inflate() for file i/o applications, in that it avoids copying between the\n   output and the sliding window by simply making the window itself the output\n   buffer.  inflate() can be faster on modern CPUs when used with large\n   buffers.  inflateBack() trusts the application to not change the output\n   buffer passed by the output function, at least until inflateBack() returns.\n\n     inflateBackInit() must be called first to allocate the internal state\n   and to initialize the state with the user-provided window buffer.\n   inflateBack() may then be used multiple times to inflate a complete, raw\n   deflate stream with each call.  inflateBackEnd() is then called to free the\n   allocated state.\n\n     A raw deflate stream is one with no zlib or gzip header or trailer.\n   This routine would normally be used in a utility that reads zip or gzip\n   files and writes out uncompressed files.  The utility would decode the\n   header and process the trailer on its own, hence this routine expects only\n   the raw deflate stream to decompress.  This is different from the default\n   behavior of inflate(), which expects a zlib header and trailer around the\n   deflate stream.\n\n     inflateBack() uses two subroutines supplied by the caller that are then\n   called by inflateBack() for input and output.  inflateBack() calls those\n   routines until it reads a complete deflate stream and writes out all of the\n   uncompressed data, or until it encounters an error.  The function's\n   parameters and return types are defined above in the in_func and out_func\n   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the\n   number of bytes of provided input, and a pointer to that input in buf.  If\n   there is no input available, in() must return zero -- buf is ignored in that\n   case -- and inflateBack() will return a buffer error.  inflateBack() will\n   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].\n   out() should return zero on success, or non-zero on failure.  If out()\n   returns non-zero, inflateBack() will return with an error.  Neither in() nor\n   out() are permitted to change the contents of the window provided to\n   inflateBackInit(), which is also the buffer that out() uses to write from.\n   The length written by out() will be at most the window size.  Any non-zero\n   amount of input may be provided by in().\n\n     For convenience, inflateBack() can be provided input on the first call by\n   setting strm->next_in and strm->avail_in.  If that input is exhausted, then\n   in() will be called.  Therefore strm->next_in must be initialized before\n   calling inflateBack().  If strm->next_in is NULL, then in() will be called\n   immediately for input.  If strm->next_in is not NULL, then strm->avail_in\n   must also be initialized, and then if strm->avail_in is not zero, input will\n   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].\n\n     The in_desc and out_desc parameters of inflateBack() is passed as the\n   first parameter of in() and out() respectively when they are called.  These\n   descriptors can be optionally used to pass any information that the caller-\n   supplied in() and out() functions need to do their job.\n\n     On return, inflateBack() will set strm->next_in and strm->avail_in to\n   pass back any unused input that was provided by the last in() call.  The\n   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR\n   if in() or out() returned an error, Z_DATA_ERROR if there was a format error\n   in the deflate stream (in which case strm->msg is set to indicate the nature\n   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.\n   In the case of Z_BUF_ERROR, an input or output error can be distinguished\n   using strm->next_in which will be NULL only if in() returned an error.  If\n   strm->next_in is not NULL, then the Z_BUF_ERROR was due to out() returning\n   non-zero.  (in() will always be called before out(), so strm->next_in is\n   assured to be defined if out() returns non-zero.)  Note that inflateBack()\n   cannot return Z_OK.\n*/\n\nZ_EXTERN int Z_EXPORT inflateBackEnd(z_stream *strm);\n/*\n     All memory allocated by inflateBackInit() is freed.\n\n     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream\n   state was inconsistent.\n*/\n\nZ_EXTERN unsigned long Z_EXPORT zlibCompileFlags(void);\n/* Return flags indicating compile-time options.\n\n    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:\n     1.0: size of unsigned int\n     3.2: size of unsigned long\n     5.4: size of void * (pointer)\n     7.6: size of z_off_t\n\n    Compiler, assembler, and debug options:\n     8: ZLIB_DEBUG\n     9: ASMV or ASMINF -- use ASM code\n     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention\n     11: 0 (reserved)\n\n    One-time table building (smaller code, but not thread-safe if true):\n     12: BUILDFIXED -- build static block decoding tables when needed (not supported by zlib-ng)\n     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed\n     14,15: 0 (reserved)\n\n    Library content (indicates missing functionality):\n     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking\n                          deflate code when not needed)\n     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect\n                    and decode gzip streams (to avoid linking crc code)\n     18-19: 0 (reserved)\n\n    Operation variations (changes in library functionality):\n     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate\n     21: FASTEST -- deflate algorithm with only one, lowest compression level\n     22,23: 0 (reserved)\n\n    The sprintf variant used by gzprintf (zero is best):\n     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format\n     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!\n     26: 0 = returns value, 1 = void -- 1 means inferred string length returned\n\n    Remainder:\n     27-31: 0 (reserved)\n */\n\n\n#ifndef Z_SOLO\n\n                        /* utility functions */\n\n/*\n     The following utility functions are implemented on top of the basic\n   stream-oriented functions.  To simplify the interface, some default options\n   are assumed (compression level and memory usage, standard memory allocation\n   functions).  The source code of these utility functions can be modified if\n   you need special options.\n*/\n\nZ_EXTERN int Z_EXPORT compress(unsigned char *dest, unsigned long *destLen, const unsigned char *source, unsigned long sourceLen);\n/*\n     Compresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.  compress() is equivalent to compress2() with a level\n   parameter of Z_DEFAULT_COMPRESSION.\n\n     compress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer.\n*/\n\nZ_EXTERN int Z_EXPORT compress2(unsigned char *dest, unsigned long *destLen, const unsigned char *source,\n                              unsigned long sourceLen, int level);\n/*\n     Compresses the source buffer into the destination buffer.  The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer.  Upon entry, destLen is the total size of the\n   destination buffer, which must be at least the value returned by\n   compressBound(sourceLen).  Upon exit, destLen is the actual size of the\n   compressed data.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\n\nZ_EXTERN unsigned long Z_EXPORT compressBound(unsigned long sourceLen);\n/*\n     compressBound() returns an upper bound on the compressed size after\n   compress() or compress2() on sourceLen bytes.  It would be used before a\n   compress() or compress2() call to allocate the destination buffer.\n*/\n\nZ_EXTERN int Z_EXPORT uncompress(unsigned char *dest, unsigned long *destLen, const unsigned char *source, unsigned long sourceLen);\n/*\n     Decompresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer.  Upon entry, destLen is the total size\n   of the destination buffer, which must be large enough to hold the entire\n   uncompressed data.  (The size of the uncompressed data must have been saved\n   previously by the compressor and transmitted to the decompressor by some\n   mechanism outside the scope of this compression library.) Upon exit, destLen\n   is the actual size of the uncompressed data.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In\n   the case where there is not enough room, uncompress() will fill the output\n   buffer with the uncompressed data up to that point.\n*/\n\n\nZ_EXTERN int Z_EXPORT uncompress2 (unsigned char *dest,         unsigned long *destLen,\n                                 const unsigned char *source, unsigned long *sourceLen);\n/*\n     Same as uncompress, except that sourceLen is a pointer, where the\n   length of the source is *sourceLen.  On return, *sourceLen is the number of\n   source bytes consumed.\n*/\n\n\n                        /* gzip file access functions */\n\n/*\n     This library supports reading and writing files in gzip (.gz) format with\n   an interface similar to that of stdio, using the functions that start with\n   \"gz\".  The gzip format is different from the zlib format.  gzip is a gzip\n   wrapper, documented in RFC 1952, wrapped around a deflate stream.\n*/\n\ntypedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */\n\n/*\nZ_EXTERN gzFile Z_EXPORT gzopen(const char *path, const char *mode);\n\n     Open the gzip (.gz) file at path for reading and decompressing, or\n   compressing and writing.  The mode parameter is as in fopen (\"rb\" or \"wb\")\n   but can also include a compression level (\"wb9\") or a strategy: 'f' for\n   filtered data as in \"wb6f\", 'h' for Huffman-only compression as in \"wb1h\",\n   'R' for run-length encoding as in \"wb1R\", or 'F' for fixed code compression\n   as in \"wb9F\".  (See the description of deflateInit2 for more information\n   about the strategy parameter.)  'T' will request transparent writing or\n   appending with no compression and not using the gzip format.\n\n     \"a\" can be used instead of \"w\" to request that the gzip stream that will\n   be written be appended to the file.  \"+\" will result in an error, since\n   reading and writing to the same gzip file is not supported.  The addition of\n   \"x\" when writing will create the file exclusively, which fails if the file\n   already exists.  On systems that support it, the addition of \"e\" when\n   reading or writing will set the flag to close the file on an execve() call.\n\n     These functions, as well as gzip, will read and decode a sequence of gzip\n   streams in a file.  The append function of gzopen() can be used to create\n   such a file.  (Also see gzflush() for another way to do this.)  When\n   appending, gzopen does not test whether the file begins with a gzip stream,\n   nor does it look for the end of the gzip streams to begin appending.  gzopen\n   will simply append a gzip stream to the existing file.\n\n     gzopen can be used to read a file which is not in gzip format; in this\n   case gzread will directly read from the file without decompression.  When\n   reading, this will be detected automatically by looking for the magic two-\n   byte gzip header.\n\n     gzopen returns NULL if the file could not be opened, if there was\n   insufficient memory to allocate the gzFile state, or if an invalid mode was\n   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).\n   errno can be checked to determine if the reason gzopen failed was that the\n   file could not be opened.\n*/\n\nZ_EXTERN gzFile Z_EXPORT gzdopen(int fd, const char *mode);\n/*\n     Associate a gzFile with the file descriptor fd.  File descriptors are\n   obtained from calls like open, dup, creat, pipe or fileno (if the file has\n   been previously opened with fopen).  The mode parameter is as in gzopen.\n\n     The next call of gzclose on the returned gzFile will also close the file\n   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor\n   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,\n   mode);.  The duplicated descriptor should be saved to avoid a leak, since\n   gzdopen does not close fd if it fails.  If you are using fileno() to get the\n   file descriptor from a FILE *, then you will have to use dup() to avoid\n   double-close()ing the file descriptor.  Both gzclose() and fclose() will\n   close the associated file descriptor, so they need to have different file\n   descriptors.\n\n     gzdopen returns NULL if there was insufficient memory to allocate the\n   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not\n   provided, or '+' was provided), or if fd is -1.  The file descriptor is not\n   used until the next gz* read, write, seek, or close operation, so gzdopen\n   will not detect if fd is invalid (unless fd is -1).\n*/\n\nZ_EXTERN int Z_EXPORT gzbuffer(gzFile file, unsigned size);\n/*\n     Set the internal buffer size used by this library's functions for file to\n   size.  The default buffer size is 8192 bytes.  This function must be called\n   after gzopen() or gzdopen(), and before any other calls that read or write\n   the file.  The buffer memory allocation is always deferred to the first read\n   or write.  Three times that size in buffer space is allocated.  A larger\n   buffer size of, for example, 64K or 128K bytes will noticeably increase the\n   speed of decompression (reading).\n\n     The new buffer size also affects the maximum length for gzprintf().\n\n     gzbuffer() returns 0 on success, or -1 on failure, such as being called\n   too late.\n*/\n\nZ_EXTERN int Z_EXPORT gzsetparams(gzFile file, int level, int strategy);\n/*\n     Dynamically update the compression level and strategy for file.  See the\n   description of deflateInit2 for the meaning of these parameters. Previously\n   provided data is flushed before applying the parameter changes.\n\n     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not\n   opened for writing, Z_ERRNO if there is an error writing the flushed data,\n   or Z_MEM_ERROR if there is a memory allocation error.\n*/\n\nZ_EXTERN int Z_EXPORT gzread(gzFile file, void *buf, unsigned len);\n/*\n     Read and decompress up to len uncompressed bytes from file into buf.  If\n   the input file is not in gzip format, gzread copies the given number of\n   bytes into the buffer directly from the file.\n\n     After reaching the end of a gzip stream in the input, gzread will continue\n   to read, looking for another gzip stream.  Any number of gzip streams may be\n   concatenated in the input file, and will all be decompressed by gzread().\n   If something other than a gzip stream is encountered after a gzip stream,\n   that remaining trailing garbage is ignored (and no error is returned).\n\n     gzread can be used to read a gzip file that is being concurrently written.\n   Upon reaching the end of the input, gzread will return with the available\n   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then\n   gzclearerr can be used to clear the end of file indicator in order to permit\n   gzread to be tried again.  Z_OK indicates that a gzip stream was completed\n   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the\n   middle of a gzip stream.  Note that gzread does not return -1 in the event\n   of an incomplete gzip stream.  This error is deferred until gzclose(), which\n   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip\n   stream.  Alternatively, gzerror can be used before gzclose to detect this\n   case.\n\n     gzread returns the number of uncompressed bytes actually read, less than\n   len for end of file, or -1 for error.  If len is too large to fit in an int,\n   then nothing is read, -1 is returned, and the error state is set to\n   Z_STREAM_ERROR.\n*/\n\nZ_EXTERN size_t Z_EXPORT gzfread (void *buf, size_t size, size_t nitems, gzFile file);\n/*\n     Read and decompress up to nitems items of size size from file into buf,\n   otherwise operating as gzread() does.  This duplicates the interface of\n   stdio's fread(), with size_t request and return types.  If the library\n   defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t\n   is an unsigned integer type that can contain a pointer.\n\n     gzfread() returns the number of full items read of size size, or zero if\n   the end of the file was reached and a full item could not be read, or if\n   there was an error.  gzerror() must be consulted if zero is returned in\n   order to determine if there was an error.  If the multiplication of size and\n   nitems overflows, i.e. the product does not fit in a size_t, then nothing\n   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.\n\n     In the event that the end of file is reached and only a partial item is\n   available at the end, i.e. the remaining uncompressed data length is not a\n   multiple of size, then the final partial item is nevertheless read into buf\n   and the end-of-file flag is set.  The length of the partial item read is not\n   provided, but could be inferred from the result of gztell().  This behavior\n   is the same as the behavior of fread() implementations in common libraries,\n   but it prevents the direct use of gzfread() to read a concurrently written\n   file, resetting and retrying on end-of-file, when size is not 1.\n*/\n\nZ_EXTERN int Z_EXPORT gzwrite(gzFile file, void const *buf, unsigned len);\n/*\n     Compress and write the len uncompressed bytes at buf to file. gzwrite\n   returns the number of uncompressed bytes written or 0 in case of error.\n*/\n\nZ_EXTERN size_t Z_EXPORT gzfwrite(void const *buf, size_t size, size_t nitems, gzFile file);\n/*\n     Compress and write nitems items of size size from buf to file, duplicating\n   the interface of stdio's fwrite(), with size_t request and return types.\n\n     gzfwrite() returns the number of full items written of size size, or zero\n   if there was an error.  If the multiplication of size and nitems overflows,\n   i.e. the product does not fit in a size_t, then nothing is written, zero\n   is returned, and the error state is set to Z_STREAM_ERROR.\n*/\n\nZ_EXTERN int Z_EXPORTVA gzprintf(gzFile file, const char *format, ...);\n/*\n     Convert, format, compress, and write the arguments (...) to file under\n   control of the string format, as in fprintf.  gzprintf returns the number of\n   uncompressed bytes actually written, or a negative zlib error code in case\n   of error.  The number of uncompressed bytes written is limited to 8191, or\n   one less than the buffer size given to gzbuffer().  The caller should assure\n   that this limit is not exceeded.  If it is exceeded, then gzprintf() will\n   return an error (0) with nothing written.  In this case, there may also be a\n   buffer overflow with unpredictable consequences, which is possible only if\n   zlib was compiled with the insecure functions sprintf() or vsprintf(),\n   because the secure snprintf() or vsnprintf() functions were not available.\n   This can be determined using zlibCompileFlags().\n*/\n\nZ_EXTERN int Z_EXPORT gzputs(gzFile file, const char *s);\n/*\n     Compress and write the given null-terminated string s to file, excluding\n   the terminating null character.\n\n     gzputs returns the number of characters written, or -1 in case of error.\n*/\n\nZ_EXTERN char * Z_EXPORT gzgets(gzFile file, char *buf, int len);\n/*\n     Read and decompress bytes from file into buf, until len-1 characters are\n   read, or until a newline character is read and transferred to buf, or an\n   end-of-file condition is encountered.  If any characters are read or if len\n   is one, the string is terminated with a null character.  If no characters\n   are read due to an end-of-file or len is less than one, then the buffer is\n   left untouched.\n\n     gzgets returns buf which is a null-terminated string, or it returns NULL\n   for end-of-file or in case of error.  If there was an error, the contents at\n   buf are indeterminate.\n*/\n\nZ_EXTERN int Z_EXPORT gzputc(gzFile file, int c);\n/*\n     Compress and write c, converted to an unsigned char, into file.  gzputc\n   returns the value that was written, or -1 in case of error.\n*/\n\nZ_EXTERN int Z_EXPORT gzgetc(gzFile file);\n/*\n     Read and decompress one byte from file.  gzgetc returns this byte or -1\n   in case of end of file or error.  This is implemented as a macro for speed.\n   As such, it does not do all of the checking the other functions do.  I.e.\n   it does not check to see if file is NULL, nor whether the structure file\n   points to has been clobbered or not.\n*/\n\nZ_EXTERN int Z_EXPORT gzungetc(int c, gzFile file);\n/*\n     Push c back onto the stream for file to be read as the first character on\n   the next read.  At least one character of push-back is always allowed.\n   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will\n   fail if c is -1, and may fail if a character has been pushed but not read\n   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the\n   output buffer size of pushed characters is allowed.  (See gzbuffer above.)\n   The pushed character will be discarded if the stream is repositioned with\n   gzseek() or gzrewind().\n*/\n\nZ_EXTERN int Z_EXPORT gzflush(gzFile file, int flush);\n/*\n     Flush all pending output to file.  The parameter flush is as in the\n   deflate() function.  The return value is the zlib error number (see function\n   gzerror below).  gzflush is only permitted when writing.\n\n     If the flush parameter is Z_FINISH, the remaining data is written and the\n   gzip stream is completed in the output.  If gzwrite() is called again, a new\n   gzip stream will be started in the output.  gzread() is able to read such\n   concatenated gzip streams.\n\n     gzflush should be called only when strictly necessary because it will\n   degrade compression if called too often.\n*/\n\n/*\nZ_EXTERN z_off_t Z_EXPORT gzseek (gzFile file, z_off_t offset, int whence);\n\n     Set the starting position to offset relative to whence for the next gzread\n   or gzwrite on file.  The offset represents a number of bytes in the\n   uncompressed data stream.  The whence parameter is defined as in lseek(2);\n   the value SEEK_END is not supported.\n\n     If the file is opened for reading, this function is emulated but can be\n   extremely slow.  If the file is opened for writing, only forward seeks are\n   supported; gzseek then compresses a sequence of zeroes up to the new\n   starting position.\n\n     gzseek returns the resulting offset location as measured in bytes from\n   the beginning of the uncompressed stream, or -1 in case of error, in\n   particular if the file is opened for writing and the new starting position\n   would be before the current position.\n*/\n\nZ_EXTERN int Z_EXPORT gzrewind(gzFile file);\n/*\n     Rewind file. This function is supported only for reading.\n\n     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).\n*/\n\n/*\nZ_EXTERN z_off_t Z_EXPORT gztell(gzFile file);\n\n     Return the starting position for the next gzread or gzwrite on file.\n   This position represents a number of bytes in the uncompressed data stream,\n   and is zero when starting, even if appending or reading a gzip stream from\n   the middle of a file using gzdopen().\n\n     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)\n*/\n\n/*\nZ_EXTERN z_off_t Z_EXPORT gzoffset(gzFile file);\n\n     Return the current compressed (actual) read or write offset of file.  This\n   offset includes the count of bytes that precede the gzip stream, for example\n   when appending or when using gzdopen() for reading.  When reading, the\n   offset does not include as yet unused buffered input.  This information can\n   be used for a progress indicator.  On error, gzoffset() returns -1.\n*/\n\nZ_EXTERN int Z_EXPORT gzeof(gzFile file);\n/*\n     Return true (1) if the end-of-file indicator for file has been set while\n   reading, false (0) otherwise.  Note that the end-of-file indicator is set\n   only if the read tried to go past the end of the input, but came up short.\n   Therefore, just like feof(), gzeof() may return false even if there is no\n   more data to read, in the event that the last read request was for the exact\n   number of bytes remaining in the input file.  This will happen if the input\n   file size is an exact multiple of the buffer size.\n\n     If gzeof() returns true, then the read functions will return no more data,\n   unless the end-of-file indicator is reset by gzclearerr() and the input file\n   has grown since the previous end of file was detected.\n*/\n\nZ_EXTERN int Z_EXPORT gzdirect(gzFile file);\n/*\n     Return true (1) if file is being copied directly while reading, or false\n   (0) if file is a gzip stream being decompressed.\n\n     If the input file is empty, gzdirect() will return true, since the input\n   does not contain a gzip stream.\n\n     If gzdirect() is used immediately after gzopen() or gzdopen() it will\n   cause buffers to be allocated to allow reading the file to determine if it\n   is a gzip file.  Therefore if gzbuffer() is used, it should be called before\n   gzdirect().\n\n     When writing, gzdirect() returns true (1) if transparent writing was\n   requested (\"wT\" for the gzopen() mode), or false (0) otherwise.  (Note:\n   gzdirect() is not needed when writing.  Transparent writing must be\n   explicitly requested, so the application already knows the answer.  When\n   linking statically, using gzdirect() will include all of the zlib code for\n   gzip file reading and decompression, which may not be desired.)\n*/\n\nZ_EXTERN int Z_EXPORT gzclose(gzFile file);\n/*\n     Flush all pending output for file, if necessary, close file and\n   deallocate the (de)compression state.  Note that once file is closed, you\n   cannot call gzerror with file, since its structures have been deallocated.\n   gzclose must not be called more than once on the same file, just as free\n   must not be called more than once on the same allocation.\n\n     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a\n   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the\n   last read ended in the middle of a gzip stream, or Z_OK on success.\n*/\n\nZ_EXTERN int Z_EXPORT gzclose_r(gzFile file);\nZ_EXTERN int Z_EXPORT gzclose_w(gzFile file);\n/*\n     Same as gzclose(), but gzclose_r() is only for use when reading, and\n   gzclose_w() is only for use when writing or appending.  The advantage to\n   using these instead of gzclose() is that they avoid linking in zlib\n   compression or decompression code that is not used when only reading or only\n   writing respectively.  If gzclose() is used, then both compression and\n   decompression code will be included the application when linking to a static\n   zlib library.\n*/\n\nZ_EXTERN const char * Z_EXPORT gzerror(gzFile file, int *errnum);\n/*\n     Return the error message for the last error which occurred on file.\n   errnum is set to zlib error number.  If an error occurred in the file system\n   and not in the compression library, errnum is set to Z_ERRNO and the\n   application may consult errno to get the exact error code.\n\n     The application must not modify the returned string.  Future calls to\n   this function may invalidate the previously returned string.  If file is\n   closed, then the string previously returned by gzerror will no longer be\n   available.\n\n     gzerror() should be used to distinguish errors from end-of-file for those\n   functions above that do not distinguish those cases in their return values.\n*/\n\nZ_EXTERN void Z_EXPORT gzclearerr(gzFile file);\n/*\n     Clear the error and end-of-file flags for file.  This is analogous to the\n   clearerr() function in stdio.  This is useful for continuing to read a gzip\n   file that is being written concurrently.\n*/\n\n#endif\n\n                        /* checksum functions */\n\n/*\n     These functions are not related to compression but are exported\n   anyway because they might be useful in applications using the compression\n   library.\n*/\n\nZ_EXTERN unsigned long Z_EXPORT adler32(unsigned long adler, const unsigned char *buf, unsigned int len);\n/*\n     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n   return the updated checksum. An Adler-32 value is in the range of a 32-bit\n   unsigned integer. If buf is Z_NULL, this function returns the required\n   initial value for the checksum.\n\n     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed\n   much faster.\n\n   Usage example:\n\n     uint32_t adler = adler32(0L, NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       adler = adler32(adler, buffer, length);\n     }\n     if (adler != original_adler) error();\n*/\n\nZ_EXTERN unsigned long Z_EXPORT adler32_z(unsigned long adler, const unsigned char *buf, size_t len);\n/*\n     Same as adler32(), but with a size_t length.\n*/\n\n/*\nZ_EXTERN unsigned long Z_EXPORT adler32_combine(unsigned long adler1, unsigned long adler2, z_off_t len2);\n\n     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1\n   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for\n   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of\n   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note\n   that the z_off_t type (like off_t) is a signed integer.  If len2 is\n   negative, the result has no meaning or utility.\n*/\n\nZ_EXTERN unsigned long Z_EXPORT crc32(unsigned long crc, const unsigned char *buf, unsigned int len);\n/*\n     Update a running CRC-32 with the bytes buf[0..len-1] and return the\n   updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.\n   If buf is Z_NULL, this function returns the required initial value for the\n   crc. Pre- and post-conditioning (one's complement) is performed within this\n   function so it shouldn't be done by the application.\n\n   Usage example:\n\n     uint32_t crc = crc32(0L, NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       crc = crc32(crc, buffer, length);\n     }\n     if (crc != original_crc) error();\n*/\n\nZ_EXTERN unsigned long Z_EXPORT crc32_z(unsigned long crc, const unsigned char *buf, size_t len);\n/*\n     Same as crc32(), but with a size_t length.\n*/\n\n/*\nZ_EXTERN unsigned long Z_EXPORT crc32_combine(unsigned long crc1, unsigned long crc2, z_off64_t len2);\n\n     Combine two CRC-32 check values into one.  For two sequences of bytes,\n   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were\n   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32\n   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and\n   len2. len2 must be non-negative.\n*/\n\n/*\nZ_EXTERN unsigned long Z_EXPORT crc32_combine_gen(z_off_t len2);\n\n     Return the operator corresponding to length len2, to be used with\n   crc32_combine_op(). len2 must be non-negative.\n*/\n\nZ_EXTERN unsigned long Z_EXPORT crc32_combine_op(unsigned long crc1, unsigned long crc2,\n                                                 const unsigned long op);\n/*\n     Give the same result as crc32_combine(), using op in place of len2. op is\n   is generated from len2 by crc32_combine_gen(). This will be faster than\n   crc32_combine() if the generated op is used more than once.\n*/\n\n\n                        /* various hacks, don't look :) */\n\n/* deflateInit and inflateInit are macros to allow checking the zlib version\n * and the compiler's view of z_stream:\n */\nZ_EXTERN int Z_EXPORT deflateInit_(z_stream *strm, int level, const char *version, int stream_size);\nZ_EXTERN int Z_EXPORT inflateInit_(z_stream *strm, const char *version, int stream_size);\nZ_EXTERN int Z_EXPORT deflateInit2_(z_stream *strm, int  level, int  method, int windowBits, int memLevel,\n                                   int strategy, const char *version, int stream_size);\nZ_EXTERN int Z_EXPORT inflateInit2_(z_stream *strm, int  windowBits, const char *version, int stream_size);\nZ_EXTERN int Z_EXPORT inflateBackInit_(z_stream *strm, int windowBits, unsigned char *window,\n                                      const char *version, int stream_size);\n#define @ZLIB_SYMBOL_PREFIX@deflateInit(strm, level) deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))\n#define @ZLIB_SYMBOL_PREFIX@inflateInit(strm) inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))\n#define @ZLIB_SYMBOL_PREFIX@deflateInit2(strm, level, method, windowBits, memLevel, strategy) \\\n        deflateInit2_((strm), (level), (method), (windowBits), (memLevel), \\\n                     (strategy), ZLIB_VERSION, (int)sizeof(z_stream))\n#define @ZLIB_SYMBOL_PREFIX@inflateInit2(strm, windowBits) inflateInit2_((strm), (windowBits), ZLIB_VERSION, (int)sizeof(z_stream))\n#define @ZLIB_SYMBOL_PREFIX@inflateBackInit(strm, windowBits, window) \\\n                        inflateBackInit_((strm), (windowBits), (window), ZLIB_VERSION, (int)sizeof(z_stream))\n\n\n#ifndef Z_SOLO\n/* gzgetc() macro and its supporting function and exposed data structure.  Note\n * that the real internal state is much larger than the exposed structure.\n * This abbreviated structure exposes just enough for the gzgetc() macro.  The\n * user should not mess with these exposed elements, since their names or\n * behavior could change in the future, perhaps even capriciously.  They can\n * only be used by the gzgetc() macro.  You have been warned.\n */\nstruct gzFile_s {\n    unsigned have;\n    unsigned char *next;\n    z_off64_t pos;\n};\nZ_EXTERN int Z_EXPORT gzgetc_(gzFile file);  /* backward compatibility */\n#  define @ZLIB_SYMBOL_PREFIX@gzgetc(g) ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (@ZLIB_SYMBOL_PREFIX@gzgetc)(g))\n\n/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or\n * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if\n * both are true, the application gets the *64 functions, and the regular\n * functions are changed to 64 bits) -- in case these are set on systems\n * without large file support, _LFS64_LARGEFILE must also be true\n */\n#ifdef Z_LARGE64\n   Z_EXTERN gzFile Z_EXPORT gzopen64(const char *, const char *);\n   Z_EXTERN z_off64_t Z_EXPORT gzseek64(gzFile, z_off64_t, int);\n   Z_EXTERN z_off64_t Z_EXPORT gztell64(gzFile);\n   Z_EXTERN z_off64_t Z_EXPORT gzoffset64(gzFile);\n   Z_EXTERN unsigned long Z_EXPORT adler32_combine64(unsigned long, unsigned long, z_off64_t);\n   Z_EXTERN unsigned long Z_EXPORT crc32_combine64(unsigned long, unsigned long, z_off64_t);\n   Z_EXTERN unsigned long Z_EXPORT crc32_combine_gen64(z_off64_t);\n#endif\n#endif\n\n#if !defined(Z_SOLO) && !defined(Z_INTERNAL) && defined(Z_WANT64)\n#    define @ZLIB_SYMBOL_PREFIX@gzopen @ZLIB_SYMBOL_PREFIX@gzopen64\n#    define @ZLIB_SYMBOL_PREFIX@gzseek @ZLIB_SYMBOL_PREFIX@gzseek64\n#    define @ZLIB_SYMBOL_PREFIX@gztell @ZLIB_SYMBOL_PREFIX@gztell64\n#    define @ZLIB_SYMBOL_PREFIX@gzoffset @ZLIB_SYMBOL_PREFIX@gzoffset64\n#    define @ZLIB_SYMBOL_PREFIX@adler32_combine @ZLIB_SYMBOL_PREFIX@adler32_combine64\n#    define @ZLIB_SYMBOL_PREFIX@crc32_combine @ZLIB_SYMBOL_PREFIX@crc32_combine64\n#    define @ZLIB_SYMBOL_PREFIX@crc32_combine_gen @ZLIB_SYMBOL_PREFIX@crc32_combine_gen64\n#  ifndef Z_LARGE64\n     Z_EXTERN gzFile Z_EXPORT @ZLIB_SYMBOL_PREFIX@gzopen64(const char *, const char *);\n     Z_EXTERN z_off_t Z_EXPORT @ZLIB_SYMBOL_PREFIX@gzseek64(gzFile, z_off_t, int);\n     Z_EXTERN z_off_t Z_EXPORT @ZLIB_SYMBOL_PREFIX@gztell64(gzFile);\n     Z_EXTERN z_off_t Z_EXPORT @ZLIB_SYMBOL_PREFIX@gzoffset64(gzFile);\n     Z_EXTERN unsigned long Z_EXPORT @ZLIB_SYMBOL_PREFIX@adler32_combine64(unsigned long, unsigned long, z_off_t);\n     Z_EXTERN unsigned long Z_EXPORT @ZLIB_SYMBOL_PREFIX@crc32_combine64(unsigned long, unsigned long, z_off_t);\n     Z_EXTERN unsigned long Z_EXPORT @ZLIB_SYMBOL_PREFIX@crc32_combine_gen64(z_off64_t);\n#  endif\n#else\n#  ifndef Z_SOLO\n   Z_EXTERN gzFile Z_EXPORT @ZLIB_SYMBOL_PREFIX@gzopen(const char *, const char *);\n   Z_EXTERN z_off_t Z_EXPORT @ZLIB_SYMBOL_PREFIX@gzseek(gzFile, z_off_t, int);\n   Z_EXTERN z_off_t Z_EXPORT @ZLIB_SYMBOL_PREFIX@gztell(gzFile);\n   Z_EXTERN z_off_t Z_EXPORT @ZLIB_SYMBOL_PREFIX@gzoffset(gzFile);\n#  endif\n   Z_EXTERN unsigned long Z_EXPORT @ZLIB_SYMBOL_PREFIX@adler32_combine(unsigned long, unsigned long, z_off_t);\n   Z_EXTERN unsigned long Z_EXPORT @ZLIB_SYMBOL_PREFIX@crc32_combine(unsigned long, unsigned long, z_off_t);\n   Z_EXTERN unsigned long Z_EXPORT @ZLIB_SYMBOL_PREFIX@crc32_combine_gen(z_off_t);\n#endif\n\n/* undocumented functions */\nZ_EXTERN const char     * Z_EXPORT zError           (int);\nZ_EXTERN int              Z_EXPORT inflateSyncPoint (z_stream *);\nZ_EXTERN const uint32_t * Z_EXPORT get_crc_table    (void);\nZ_EXTERN int              Z_EXPORT inflateUndermine (z_stream *, int);\nZ_EXTERN int              Z_EXPORT inflateValidate  (z_stream *, int);\nZ_EXTERN unsigned long    Z_EXPORT inflateCodesUsed (z_stream *);\nZ_EXTERN int              Z_EXPORT inflateResetKeep (z_stream *);\nZ_EXTERN int              Z_EXPORT deflateResetKeep (z_stream *);\n\n#ifndef Z_SOLO\n#if defined(_WIN32)\n    Z_EXTERN gzFile Z_EXPORT gzopen_w(const wchar_t *path, const char *mode);\n#endif\nZ_EXTERN int Z_EXPORTVA gzvprintf(gzFile file, const char *format, va_list va);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZLIB_H_ */\n"
        },
        {
          "name": "zlib.map",
          "type": "blob",
          "size": 1.3916015625,
          "content": "ZLIB_1.2.0 {\n  global:\n    compressBound;\n    deflateBound;\n    inflateBack;\n    inflateBackEnd;\n    inflateBackInit_;\n    inflateCopy;\n  local:\n    deflate_copyright;\n    inflate_copyright;\n    zcalloc;\n    zcfree;\n    z_errmsg;\n    gz_error;\n    gz_intmax;\n    _*;\n};\n\nZLIB_1.2.0.2 {\n    gzclearerr;\n    gzungetc;\n    zlibCompileFlags;\n} ZLIB_1.2.0;\n\nZLIB_1.2.0.8 {\n    deflatePrime;\n} ZLIB_1.2.0.2;\n\nZLIB_1.2.2 {\n    adler32_combine;\n    crc32_combine;\n    deflateSetHeader;\n    inflateGetHeader;\n} ZLIB_1.2.0.8;\n\nZLIB_1.2.2.3 {\n    deflateTune;\n    gzdirect;\n} ZLIB_1.2.2;\n\nZLIB_1.2.2.4 {\n    inflatePrime;\n} ZLIB_1.2.2.3;\n\nZLIB_1.2.3.3 {\n    adler32_combine64;\n    crc32_combine64;\n    gzopen64;\n    gzseek64;\n    gztell64;\n    inflateUndermine;\n} ZLIB_1.2.2.4;\n\nZLIB_1.2.3.4 {\n    inflateReset2;\n    inflateMark;\n} ZLIB_1.2.3.3;\n\nZLIB_1.2.3.5 {\n    gzbuffer;\n    gzoffset;\n    gzoffset64;\n    gzclose_r;\n    gzclose_w;\n} ZLIB_1.2.3.4;\n\nZLIB_1.2.5.1 {\n    deflatePending;\n} ZLIB_1.2.3.5;\n\nZLIB_1.2.5.2 {\n    deflateResetKeep;\n    gzgetc_;\n    inflateResetKeep;\n} ZLIB_1.2.5.1;\n\nZLIB_1.2.7.1 {\n    inflateGetDictionary;\n    gzvprintf;\n} ZLIB_1.2.5.2;\n\nZLIB_1.2.9 {\n    inflateCodesUsed;\n    inflateValidate;\n    uncompress2;\n    gzfread;\n    gzfwrite;\n    deflateGetDictionary;\n    adler32_z;\n    crc32_z;\n} ZLIB_1.2.7.1;\n\nZLIB_1.2.12 {\n    crc32_combine_gen;\n    crc32_combine_gen64;\n    crc32_combine_op;\n} ZLIB_1.2.9;\n"
        },
        {
          "name": "zlib.pc.cmakein",
          "type": "blob",
          "size": 0.3544921875,
          "content": "prefix=@CMAKE_INSTALL_PREFIX@\nexec_prefix=${prefix}\nsymbol_prefix=@ZLIB_SYMBOL_PREFIX@\nlibdir=@PC_LIB_INSTALL_DIR@\nsharedlibdir=${libdir}\nincludedir=@PC_INC_INSTALL_DIR@\n\nName: zlib@SUFFIX@\nDescription: zlib-ng compression library\nVersion: @ZLIB_FULL_VERSION@\n\nRequires:\nLibs: -L${libdir} -L${sharedlibdir} -lz@SUFFIX@\nCflags: -I${includedir} @PKG_CONFIG_CFLAGS@\n"
        },
        {
          "name": "zlib.pc.in",
          "type": "blob",
          "size": 0.3154296875,
          "content": "prefix=@prefix@\nexec_prefix=@exec_prefix@\nsymbol_prefix=@symbol_prefix@\nlibdir=@libdir@\nsharedlibdir=@sharedlibdir@\nincludedir=@includedir@\n\nName: zlib@SUFFIX@\nDescription: zlib-ng compression library\nVersion: @VERSION@\n\nRequires:\nLibs: -L${libdir} -L${sharedlibdir} -lz@SUFFIX@\nCflags: -I${includedir} @PKG_CONFIG_CFLAGS@\n"
        },
        {
          "name": "zlib_name_mangling-ng.h.in",
          "type": "blob",
          "size": 10.7861328125,
          "content": "/* zlib_name_mangling.h has been automatically generated from\n * zlib_name_mangling.h.in because ZLIB_SYMBOL_PREFIX was set.\n */\n\n#ifndef ZLIB_NAME_MANGLING_H\n#define ZLIB_NAME_MANGLING_H\n\n/* all linked symbols and init macros */\n#define zng__dist_code            @ZLIB_SYMBOL_PREFIX@zng__dist_code\n#define zng__length_code          @ZLIB_SYMBOL_PREFIX@zng__length_code\n#define zng__tr_align             @ZLIB_SYMBOL_PREFIX@zng__tr_align\n#define zng__tr_flush_bits        @ZLIB_SYMBOL_PREFIX@zng__tr_flush_bits\n#define zng__tr_flush_block       @ZLIB_SYMBOL_PREFIX@zng__tr_flush_block\n#define zng__tr_init              @ZLIB_SYMBOL_PREFIX@zng__tr_init\n#define zng__tr_stored_block      @ZLIB_SYMBOL_PREFIX@zng__tr_stored_block\n#define zng__tr_tally             @ZLIB_SYMBOL_PREFIX@zng__tr_tally\n#define zng_adler32               @ZLIB_SYMBOL_PREFIX@zng_adler32\n#define zng_adler32_combine       @ZLIB_SYMBOL_PREFIX@zng_adler32_combine\n#define zng_adler32_combine64     @ZLIB_SYMBOL_PREFIX@zng_adler32_combine64\n#define zng_adler32_z             @ZLIB_SYMBOL_PREFIX@zng_adler32_z\n#define zng_compress              @ZLIB_SYMBOL_PREFIX@zng_compress\n#define zng_compress2             @ZLIB_SYMBOL_PREFIX@zng_compress2\n#define zng_compressBound         @ZLIB_SYMBOL_PREFIX@zng_compressBound\n#define zng_crc32                 @ZLIB_SYMBOL_PREFIX@zng_crc32\n#define zng_crc32_combine         @ZLIB_SYMBOL_PREFIX@zng_crc32_combine\n#define zng_crc32_combine64       @ZLIB_SYMBOL_PREFIX@zng_crc32_combine64\n#define zng_crc32_combine_gen     @ZLIB_SYMBOL_PREFIX@zng_crc32_combine_gen\n#define zng_crc32_combine_gen64   @ZLIB_SYMBOL_PREFIX@zng_crc32_combine_gen64\n#define zng_crc32_combine_op      @ZLIB_SYMBOL_PREFIX@zng_crc32_combine_op\n#define zng_crc32_z               @ZLIB_SYMBOL_PREFIX@zng_crc32_z\n#define zng_deflate               @ZLIB_SYMBOL_PREFIX@zng_deflate\n#define zng_deflateBound          @ZLIB_SYMBOL_PREFIX@zng_deflateBound\n#define zng_deflateCopy           @ZLIB_SYMBOL_PREFIX@zng_deflateCopy\n#define zng_deflateEnd            @ZLIB_SYMBOL_PREFIX@zng_deflateEnd\n#define zng_deflateGetDictionary  @ZLIB_SYMBOL_PREFIX@zng_deflateGetDictionary\n#define zng_deflateInit           @ZLIB_SYMBOL_PREFIX@zng_deflateInit\n#define zng_deflateInit2          @ZLIB_SYMBOL_PREFIX@zng_deflateInit2\n#define zng_deflateInit2_         @ZLIB_SYMBOL_PREFIX@zng_deflateInit2_\n#define zng_deflateInit_          @ZLIB_SYMBOL_PREFIX@zng_deflateInit_\n#define zng_deflateParams         @ZLIB_SYMBOL_PREFIX@zng_deflateParams\n#define zng_deflatePending        @ZLIB_SYMBOL_PREFIX@zng_deflatePending\n#define zng_deflatePrime          @ZLIB_SYMBOL_PREFIX@zng_deflatePrime\n#define zng_deflateReset          @ZLIB_SYMBOL_PREFIX@zng_deflateReset\n#define zng_deflateResetKeep      @ZLIB_SYMBOL_PREFIX@zng_deflateResetKeep\n#define zng_deflateSetDictionary  @ZLIB_SYMBOL_PREFIX@zng_deflateSetDictionary\n#define zng_deflateSetHeader      @ZLIB_SYMBOL_PREFIX@zng_deflateSetHeader\n#define zng_deflateTune           @ZLIB_SYMBOL_PREFIX@zng_deflateTune\n#define zng_deflate_copyright     @ZLIB_SYMBOL_PREFIX@zng_deflate_copyright\n#define zng_fill_window           @ZLIB_SYMBOL_PREFIX@zng_fill_window\n#define zng_fixedtables           @ZLIB_SYMBOL_PREFIX@zng_fixedtables\n#define zng_flush_pending         @ZLIB_SYMBOL_PREFIX@zng_flush_pending\n#define zng_get_crc_table         @ZLIB_SYMBOL_PREFIX@zng_get_crc_table\n#ifdef WITH_GZFILEOP\n#  define zng_gz_error              @ZLIB_SYMBOL_PREFIX@zng_gz_error\n#  define zng_gz_strwinerror        @ZLIB_SYMBOL_PREFIX@zng_gz_strwinerror\n#  define zng_gzbuffer              @ZLIB_SYMBOL_PREFIX@zng_gzbuffer\n#  define zng_gzclearerr            @ZLIB_SYMBOL_PREFIX@zng_gzclearerr\n#  define zng_gzclose               @ZLIB_SYMBOL_PREFIX@zng_gzclose\n#  define zng_gzclose_r             @ZLIB_SYMBOL_PREFIX@zng_gzclose_r\n#  define zng_gzclose_w             @ZLIB_SYMBOL_PREFIX@zng_gzclose_w\n#  define zng_gzdirect              @ZLIB_SYMBOL_PREFIX@zng_gzdirect\n#  define zng_gzdopen               @ZLIB_SYMBOL_PREFIX@zng_gzdopen\n#  define zng_gzeof                 @ZLIB_SYMBOL_PREFIX@zng_gzeof\n#  define zng_gzerror               @ZLIB_SYMBOL_PREFIX@zng_gzerror\n#  define zng_gzflush               @ZLIB_SYMBOL_PREFIX@zng_gzflush\n#  define zng_gzfread               @ZLIB_SYMBOL_PREFIX@zng_gzfread\n#  define zng_gzfwrite              @ZLIB_SYMBOL_PREFIX@zng_gzfwrite\n#  define zng_gzgetc                @ZLIB_SYMBOL_PREFIX@zng_gzgetc\n#  define zng_gzgetc_               @ZLIB_SYMBOL_PREFIX@zng_gzgetc_\n#  define zng_gzgets                @ZLIB_SYMBOL_PREFIX@zng_gzgets\n#  define zng_gzoffset              @ZLIB_SYMBOL_PREFIX@zng_gzoffset\n#  define zng_gzoffset64            @ZLIB_SYMBOL_PREFIX@zng_gzoffset64\n#  define zng_gzopen                @ZLIB_SYMBOL_PREFIX@zng_gzopen\n#  define zng_gzopen64              @ZLIB_SYMBOL_PREFIX@zng_gzopen64\n#  ifdef _WIN32\n#    define zng_gzopen_w              @ZLIB_SYMBOL_PREFIX@zng_gzopen_w\n#  endif\n#  define zng_gzprintf              @ZLIB_SYMBOL_PREFIX@zng_gzprintf\n#  define zng_gzputc                @ZLIB_SYMBOL_PREFIX@zng_gzputc\n#  define zng_gzputs                @ZLIB_SYMBOL_PREFIX@zng_gzputs\n#  define zng_gzread                @ZLIB_SYMBOL_PREFIX@zng_gzread\n#  define zng_gzrewind              @ZLIB_SYMBOL_PREFIX@zng_gzrewind\n#  define zng_gzseek                @ZLIB_SYMBOL_PREFIX@zng_gzseek\n#  define zng_gzseek64              @ZLIB_SYMBOL_PREFIX@zng_gzseek64\n#  define zng_gzsetparams           @ZLIB_SYMBOL_PREFIX@zng_gzsetparams\n#  define zng_gztell                @ZLIB_SYMBOL_PREFIX@zng_gztell\n#  define zng_gztell64              @ZLIB_SYMBOL_PREFIX@zng_gztell64\n#  define zng_gzungetc              @ZLIB_SYMBOL_PREFIX@zng_gzungetc\n#  define zng_gzvprintf             @ZLIB_SYMBOL_PREFIX@zng_gzvprintf\n#  define zng_gzwrite               @ZLIB_SYMBOL_PREFIX@zng_gzwrite\n#endif\n#define zng_inflate               @ZLIB_SYMBOL_PREFIX@zng_inflate\n#define zng_inflateBack           @ZLIB_SYMBOL_PREFIX@zng_inflateBack\n#define zng_inflateBackEnd        @ZLIB_SYMBOL_PREFIX@zng_inflateBackEnd\n#define zng_inflateBackInit       @ZLIB_SYMBOL_PREFIX@zng_inflateBackInit\n#define zng_inflateBackInit_      @ZLIB_SYMBOL_PREFIX@zng_inflateBackInit_\n#define zng_inflateCodesUsed      @ZLIB_SYMBOL_PREFIX@zng_inflateCodesUsed\n#define zng_inflateCopy           @ZLIB_SYMBOL_PREFIX@zng_inflateCopy\n#define zng_inflateEnd            @ZLIB_SYMBOL_PREFIX@zng_inflateEnd\n#define zng_inflateGetDictionary  @ZLIB_SYMBOL_PREFIX@zng_inflateGetDictionary\n#define zng_inflateGetHeader      @ZLIB_SYMBOL_PREFIX@zng_inflateGetHeader\n#define zng_inflateInit           @ZLIB_SYMBOL_PREFIX@zng_inflateInit\n#define zng_inflateInit2          @ZLIB_SYMBOL_PREFIX@zng_inflateInit2\n#define zng_inflateInit2_         @ZLIB_SYMBOL_PREFIX@zng_inflateInit2_\n#define zng_inflateInit_          @ZLIB_SYMBOL_PREFIX@zng_inflateInit_\n#define zng_inflateMark           @ZLIB_SYMBOL_PREFIX@zng_inflateMark\n#define zng_inflatePrime          @ZLIB_SYMBOL_PREFIX@zng_inflatePrime\n#define zng_inflateReset          @ZLIB_SYMBOL_PREFIX@zng_inflateReset\n#define zng_inflateReset2         @ZLIB_SYMBOL_PREFIX@zng_inflateReset2\n#define zng_inflateResetKeep      @ZLIB_SYMBOL_PREFIX@zng_inflateResetKeep\n#define zng_inflateSetDictionary  @ZLIB_SYMBOL_PREFIX@zng_inflateSetDictionary\n#define zng_inflateSync           @ZLIB_SYMBOL_PREFIX@zng_inflateSync\n#define zng_inflateSyncPoint      @ZLIB_SYMBOL_PREFIX@zng_inflateSyncPoint\n#define zng_inflateUndermine      @ZLIB_SYMBOL_PREFIX@zng_inflateUndermine\n#define zng_inflateValidate       @ZLIB_SYMBOL_PREFIX@zng_inflateValidate\n#define zng_inflate_copyright     @ZLIB_SYMBOL_PREFIX@zng_inflate_copyright\n#define zng_inflate_ensure_window @ZLIB_SYMBOL_PREFIX@zng_inflate_ensure_window\n#define zng_inflate_fast          @ZLIB_SYMBOL_PREFIX@zng_inflate_fast\n#define zng_inflate_table         @ZLIB_SYMBOL_PREFIX@zng_inflate_table\n#define zng_read_buf              @ZLIB_SYMBOL_PREFIX@zng_read_buf\n#define zng_uncompress            @ZLIB_SYMBOL_PREFIX@zng_uncompress\n#define zng_uncompress2           @ZLIB_SYMBOL_PREFIX@zng_uncompress2\n#define zng_zError                @ZLIB_SYMBOL_PREFIX@zng_zError\n#define zng_zcalloc               @ZLIB_SYMBOL_PREFIX@zng_zcalloc\n#define zng_zcfree                @ZLIB_SYMBOL_PREFIX@zng_zcfree\n#define zng_zlibCompileFlags      @ZLIB_SYMBOL_PREFIX@zng_zlibCompileFlags\n#define zng_zlibVersion           @ZLIB_SYMBOL_PREFIX@zng_zlibVersion\n\n/* all zlib typedefs in zlib.h and zconf.h */\n#define Byte                  @ZLIB_SYMBOL_PREFIX@Byte\n#define Bytef                 @ZLIB_SYMBOL_PREFIX@Bytef\n#define alloc_func            @ZLIB_SYMBOL_PREFIX@alloc_func\n#define charf                 @ZLIB_SYMBOL_PREFIX@charf\n#define free_func             @ZLIB_SYMBOL_PREFIX@free_func\n#ifdef WITH_GZFILEOP\n#  define gzFile                @ZLIB_SYMBOL_PREFIX@gzFile\n#endif\n#define gz_header             @ZLIB_SYMBOL_PREFIX@gz_header\n#define gz_headerp            @ZLIB_SYMBOL_PREFIX@gz_headerp\n#define in_func               @ZLIB_SYMBOL_PREFIX@in_func\n#define intf                  @ZLIB_SYMBOL_PREFIX@intf\n#define out_func              @ZLIB_SYMBOL_PREFIX@out_func\n#define uInt                  @ZLIB_SYMBOL_PREFIX@uInt\n#define uIntf                 @ZLIB_SYMBOL_PREFIX@uIntf\n#define uLong                 @ZLIB_SYMBOL_PREFIX@uLong\n#define uLongf                @ZLIB_SYMBOL_PREFIX@uLongf\n#define voidp                 @ZLIB_SYMBOL_PREFIX@voidp\n#define voidpc                @ZLIB_SYMBOL_PREFIX@voidpc\n#define voidpf                @ZLIB_SYMBOL_PREFIX@voidpf\n\n/* all zlib structs in zlib.h and zconf.h */\n#define zng_gz_header_s           @ZLIB_SYMBOL_PREFIX@zng_gz_header_s\n#define internal_state            @ZLIB_SYMBOL_PREFIX@internal_state\n\n/* zlib-ng specific symbols */\n#define zng_deflate_param         @ZLIB_SYMBOL_PREFIX@zng_deflate_param\n#define zng_deflate_param_value   @ZLIB_SYMBOL_PREFIX@zng_deflate_param_value\n#define zng_deflateSetParams      @ZLIB_SYMBOL_PREFIX@zng_deflateSetParams\n#define zng_deflateGetParams      @ZLIB_SYMBOL_PREFIX@zng_deflateGetParams\n\n#define zlibng_version         @ZLIB_SYMBOL_PREFIX@zlibng_version\n#define zng_vstring            @ZLIB_SYMBOL_PREFIX@zng_vstring\n#define zng_zError             @ZLIB_SYMBOL_PREFIX@zng_zError\n\n#define zng_alloc_aligned      @ZLIB_SYMBOL_PREFIX@zng_alloc_aligned\n#define zng_free_aligned       @ZLIB_SYMBOL_PREFIX@zng_free_aligned\n#define zng_get_crc_table      @ZLIB_SYMBOL_PREFIX@zng_get_crc_table\n#define zng_inflateSyncPoint   @ZLIB_SYMBOL_PREFIX@zng_inflateSyncPoint\n#define zng_inflateUndermine   @ZLIB_SYMBOL_PREFIX@zng_inflateUndermine\n#define zng_inflateValidate    @ZLIB_SYMBOL_PREFIX@zng_inflateValidate\n#define zng_inflateCodesUsed   @ZLIB_SYMBOL_PREFIX@zng_inflateCodesUsed\n#define zng_inflateResetKeep   @ZLIB_SYMBOL_PREFIX@zng_inflateResetKeep\n#define zng_deflateResetKeep   @ZLIB_SYMBOL_PREFIX@zng_deflateResetKeep\n\n#define zng_gzopen_w           @ZLIB_SYMBOL_PREFIX@zng_gzopen_w\n#define zng_gzvprintf          @ZLIB_SYMBOL_PREFIX@zng_gzvprintf\n\n#endif /* ZLIB_NAME_MANGLING_H */\n"
        },
        {
          "name": "zlib_name_mangling.h.empty",
          "type": "blob",
          "size": 0.224609375,
          "content": "/* zlib_name_mangling.h has been automatically generated from\n * zlib_name_mangling.h.empty because ZLIB_SYMBOL_PREFIX was NOT set.\n */\n\n#ifndef ZLIB_NAME_MANGLING_H\n#define ZLIB_NAME_MANGLING_H\n\n#endif /* ZLIB_NAME_MANGLING_H */\n"
        },
        {
          "name": "zlib_name_mangling.h.in",
          "type": "blob",
          "size": 9.0576171875,
          "content": "/* zlib_name_mangling.h has been automatically generated from\n * zlib_name_mangling.h.in because ZLIB_SYMBOL_PREFIX was set.\n */\n\n#ifndef ZLIB_NAME_MANGLING_H\n#define ZLIB_NAME_MANGLING_H\n\n/* all linked symbols and init macros */\n#define _dist_code            @ZLIB_SYMBOL_PREFIX@_dist_code\n#define _length_code          @ZLIB_SYMBOL_PREFIX@_length_code\n#define _tr_align             @ZLIB_SYMBOL_PREFIX@_tr_align\n#define _tr_flush_bits        @ZLIB_SYMBOL_PREFIX@_tr_flush_bits\n#define _tr_flush_block       @ZLIB_SYMBOL_PREFIX@_tr_flush_block\n#define _tr_init              @ZLIB_SYMBOL_PREFIX@_tr_init\n#define _tr_stored_block      @ZLIB_SYMBOL_PREFIX@_tr_stored_block\n#define _tr_tally             @ZLIB_SYMBOL_PREFIX@_tr_tally\n#define adler32               @ZLIB_SYMBOL_PREFIX@adler32\n#define adler32_combine       @ZLIB_SYMBOL_PREFIX@adler32_combine\n#define adler32_combine64     @ZLIB_SYMBOL_PREFIX@adler32_combine64\n#define adler32_z             @ZLIB_SYMBOL_PREFIX@adler32_z\n#ifndef Z_SOLO\n#  define compress              @ZLIB_SYMBOL_PREFIX@compress\n#  define compress2             @ZLIB_SYMBOL_PREFIX@compress2\n#  define compressBound         @ZLIB_SYMBOL_PREFIX@compressBound\n#endif\n#define crc32                 @ZLIB_SYMBOL_PREFIX@crc32\n#define crc32_combine         @ZLIB_SYMBOL_PREFIX@crc32_combine\n#define crc32_combine64       @ZLIB_SYMBOL_PREFIX@crc32_combine64\n#define crc32_combine_gen     @ZLIB_SYMBOL_PREFIX@crc32_combine_gen\n#define crc32_combine_gen64   @ZLIB_SYMBOL_PREFIX@crc32_combine_gen64\n#define crc32_combine_op      @ZLIB_SYMBOL_PREFIX@crc32_combine_op\n#define crc32_z               @ZLIB_SYMBOL_PREFIX@crc32_z\n#define deflate               @ZLIB_SYMBOL_PREFIX@deflate\n#define deflateBound          @ZLIB_SYMBOL_PREFIX@deflateBound\n#define deflateCopy           @ZLIB_SYMBOL_PREFIX@deflateCopy\n#define deflateEnd            @ZLIB_SYMBOL_PREFIX@deflateEnd\n#define deflateGetDictionary  @ZLIB_SYMBOL_PREFIX@deflateGetDictionary\n#define deflateInit           @ZLIB_SYMBOL_PREFIX@deflateInit\n#define deflateInit2          @ZLIB_SYMBOL_PREFIX@deflateInit2\n#define deflateInit2_         @ZLIB_SYMBOL_PREFIX@deflateInit2_\n#define deflateInit_          @ZLIB_SYMBOL_PREFIX@deflateInit_\n#define deflateParams         @ZLIB_SYMBOL_PREFIX@deflateParams\n#define deflatePending        @ZLIB_SYMBOL_PREFIX@deflatePending\n#define deflatePrime          @ZLIB_SYMBOL_PREFIX@deflatePrime\n#define deflateReset          @ZLIB_SYMBOL_PREFIX@deflateReset\n#define deflateResetKeep      @ZLIB_SYMBOL_PREFIX@deflateResetKeep\n#define deflateSetDictionary  @ZLIB_SYMBOL_PREFIX@deflateSetDictionary\n#define deflateSetHeader      @ZLIB_SYMBOL_PREFIX@deflateSetHeader\n#define deflateTune           @ZLIB_SYMBOL_PREFIX@deflateTune\n#define deflate_copyright     @ZLIB_SYMBOL_PREFIX@deflate_copyright\n#define fill_window           @ZLIB_SYMBOL_PREFIX@fill_window\n#define fixedtables           @ZLIB_SYMBOL_PREFIX@fixedtables\n#define flush_pending         @ZLIB_SYMBOL_PREFIX@flush_pending\n#define get_crc_table         @ZLIB_SYMBOL_PREFIX@get_crc_table\n#ifndef Z_SOLO\n#  define gz_error              @ZLIB_SYMBOL_PREFIX@gz_error\n#  define gz_strwinerror        @ZLIB_SYMBOL_PREFIX@gz_strwinerror\n#  define gzbuffer              @ZLIB_SYMBOL_PREFIX@gzbuffer\n#  define gzclearerr            @ZLIB_SYMBOL_PREFIX@gzclearerr\n#  define gzclose               @ZLIB_SYMBOL_PREFIX@gzclose\n#  define gzclose_r             @ZLIB_SYMBOL_PREFIX@gzclose_r\n#  define gzclose_w             @ZLIB_SYMBOL_PREFIX@gzclose_w\n#  define gzdirect              @ZLIB_SYMBOL_PREFIX@gzdirect\n#  define gzdopen               @ZLIB_SYMBOL_PREFIX@gzdopen\n#  define gzeof                 @ZLIB_SYMBOL_PREFIX@gzeof\n#  define gzerror               @ZLIB_SYMBOL_PREFIX@gzerror\n#  define gzflush               @ZLIB_SYMBOL_PREFIX@gzflush\n#  define gzfread               @ZLIB_SYMBOL_PREFIX@gzfread\n#  define gzfwrite              @ZLIB_SYMBOL_PREFIX@gzfwrite\n#  define gzgetc                @ZLIB_SYMBOL_PREFIX@gzgetc\n#  define gzgetc_               @ZLIB_SYMBOL_PREFIX@gzgetc_\n#  define gzgets                @ZLIB_SYMBOL_PREFIX@gzgets\n#  define gzoffset              @ZLIB_SYMBOL_PREFIX@gzoffset\n#  define gzoffset64            @ZLIB_SYMBOL_PREFIX@gzoffset64\n#  define gzopen                @ZLIB_SYMBOL_PREFIX@gzopen\n#  define gzopen64              @ZLIB_SYMBOL_PREFIX@gzopen64\n#  ifdef _WIN32\n#    define gzopen_w              @ZLIB_SYMBOL_PREFIX@gzopen_w\n#  endif\n#  define gzprintf              @ZLIB_SYMBOL_PREFIX@gzprintf\n#  define gzputc                @ZLIB_SYMBOL_PREFIX@gzputc\n#  define gzputs                @ZLIB_SYMBOL_PREFIX@gzputs\n#  define gzread                @ZLIB_SYMBOL_PREFIX@gzread\n#  define gzrewind              @ZLIB_SYMBOL_PREFIX@gzrewind\n#  define gzseek                @ZLIB_SYMBOL_PREFIX@gzseek\n#  define gzseek64              @ZLIB_SYMBOL_PREFIX@gzseek64\n#  define gzsetparams           @ZLIB_SYMBOL_PREFIX@gzsetparams\n#  define gztell                @ZLIB_SYMBOL_PREFIX@gztell\n#  define gztell64              @ZLIB_SYMBOL_PREFIX@gztell64\n#  define gzungetc              @ZLIB_SYMBOL_PREFIX@gzungetc\n#  define gzvprintf             @ZLIB_SYMBOL_PREFIX@gzvprintf\n#  define gzwrite               @ZLIB_SYMBOL_PREFIX@gzwrite\n#endif\n#define inflate               @ZLIB_SYMBOL_PREFIX@inflate\n#define inflateBack           @ZLIB_SYMBOL_PREFIX@inflateBack\n#define inflateBackEnd        @ZLIB_SYMBOL_PREFIX@inflateBackEnd\n#define inflateBackInit       @ZLIB_SYMBOL_PREFIX@inflateBackInit\n#define inflateBackInit_      @ZLIB_SYMBOL_PREFIX@inflateBackInit_\n#define inflateCodesUsed      @ZLIB_SYMBOL_PREFIX@inflateCodesUsed\n#define inflateCopy           @ZLIB_SYMBOL_PREFIX@inflateCopy\n#define inflateEnd            @ZLIB_SYMBOL_PREFIX@inflateEnd\n#define inflateGetDictionary  @ZLIB_SYMBOL_PREFIX@inflateGetDictionary\n#define inflateGetHeader      @ZLIB_SYMBOL_PREFIX@inflateGetHeader\n#define inflateInit           @ZLIB_SYMBOL_PREFIX@inflateInit\n#define inflateInit2          @ZLIB_SYMBOL_PREFIX@inflateInit2\n#define inflateInit2_         @ZLIB_SYMBOL_PREFIX@inflateInit2_\n#define inflateInit_          @ZLIB_SYMBOL_PREFIX@inflateInit_\n#define inflateMark           @ZLIB_SYMBOL_PREFIX@inflateMark\n#define inflatePrime          @ZLIB_SYMBOL_PREFIX@inflatePrime\n#define inflateReset          @ZLIB_SYMBOL_PREFIX@inflateReset\n#define inflateReset2         @ZLIB_SYMBOL_PREFIX@inflateReset2\n#define inflateResetKeep      @ZLIB_SYMBOL_PREFIX@inflateResetKeep\n#define inflateSetDictionary  @ZLIB_SYMBOL_PREFIX@inflateSetDictionary\n#define inflateSync           @ZLIB_SYMBOL_PREFIX@inflateSync\n#define inflateSyncPoint      @ZLIB_SYMBOL_PREFIX@inflateSyncPoint\n#define inflateUndermine      @ZLIB_SYMBOL_PREFIX@inflateUndermine\n#define inflateValidate       @ZLIB_SYMBOL_PREFIX@inflateValidate\n#define inflate_copyright     @ZLIB_SYMBOL_PREFIX@inflate_copyright\n#define inflate_ensure_window @ZLIB_SYMBOL_PREFIX@inflate_ensure_window\n#define inflate_fast          @ZLIB_SYMBOL_PREFIX@inflate_fast\n#define inflate_table         @ZLIB_SYMBOL_PREFIX@inflate_table\n#define read_buf              @ZLIB_SYMBOL_PREFIX@read_buf\n#ifndef Z_SOLO\n#  define uncompress            @ZLIB_SYMBOL_PREFIX@uncompress\n#  define uncompress2           @ZLIB_SYMBOL_PREFIX@uncompress2\n#endif\n#define zError                @ZLIB_SYMBOL_PREFIX@zError\n#ifndef Z_SOLO\n#  define zcalloc               @ZLIB_SYMBOL_PREFIX@zcalloc\n#  define zcfree                @ZLIB_SYMBOL_PREFIX@zcfree\n#endif\n#define zlibCompileFlags      @ZLIB_SYMBOL_PREFIX@zlibCompileFlags\n#define zlibVersion           @ZLIB_SYMBOL_PREFIX@zlibVersion\n\n/* all zlib typedefs in zlib.h and zconf.h */\n#define Byte                  @ZLIB_SYMBOL_PREFIX@Byte\n#define Bytef                 @ZLIB_SYMBOL_PREFIX@Bytef\n#define alloc_func            @ZLIB_SYMBOL_PREFIX@alloc_func\n#define charf                 @ZLIB_SYMBOL_PREFIX@charf\n#define free_func             @ZLIB_SYMBOL_PREFIX@free_func\n#ifndef Z_SOLO\n#  define gzFile                @ZLIB_SYMBOL_PREFIX@gzFile\n#endif\n#define gz_header             @ZLIB_SYMBOL_PREFIX@gz_header\n#define gz_headerp            @ZLIB_SYMBOL_PREFIX@gz_headerp\n#define in_func               @ZLIB_SYMBOL_PREFIX@in_func\n#define intf                  @ZLIB_SYMBOL_PREFIX@intf\n#define out_func              @ZLIB_SYMBOL_PREFIX@out_func\n#define uInt                  @ZLIB_SYMBOL_PREFIX@uInt\n#define uIntf                 @ZLIB_SYMBOL_PREFIX@uIntf\n#define uLong                 @ZLIB_SYMBOL_PREFIX@uLong\n#define uLongf                @ZLIB_SYMBOL_PREFIX@uLongf\n#define voidp                 @ZLIB_SYMBOL_PREFIX@voidp\n#define voidpc                @ZLIB_SYMBOL_PREFIX@voidpc\n#define voidpf                @ZLIB_SYMBOL_PREFIX@voidpf\n\n/* all zlib structs in zlib.h and zconf.h */\n#define gz_header_s           @ZLIB_SYMBOL_PREFIX@gz_header_s\n#define internal_state        @ZLIB_SYMBOL_PREFIX@internal_state\n\n/* all zlib structs in zutil.h */\n#define z_errmsg              @ZLIB_SYMBOL_PREFIX@z_errmsg\n#define z_vstring             @ZLIB_SYMBOL_PREFIX@z_vstring\n#define zlibng_version        @ZLIB_SYMBOL_PREFIX@zlibng_version\n\n/* zlib-ng specific symbols */\n#define zng_alloc_aligned     @ZLIB_SYMBOL_PREFIX@zng_alloc_aligned\n#define zng_free_aligned      @ZLIB_SYMBOL_PREFIX@zng_free_aligned\n\n#endif /* ZLIB_NAME_MANGLING_H */\n"
        },
        {
          "name": "zmemory.h",
          "type": "blob",
          "size": 2.8916015625,
          "content": "/* zmemory.h -- Private inline functions used internally in zlib-ng\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef _ZMEMORY_H\n#define _ZMEMORY_H\n\n#if defined(__GNUC__) && (__GNUC__ >= 4)\n#  define HAVE_MAY_ALIAS\n#endif\n\nstatic inline uint16_t zng_memread_2(const void *ptr) {\n#if defined(HAVE_MAY_ALIAS)\n    typedef struct { uint16_t val; } __attribute__ ((__packed__, __may_alias__)) unaligned_uint16_t;\n    return ((const unaligned_uint16_t *)ptr)->val;\n#else\n    uint16_t val;\n    memcpy(&val, ptr, sizeof(val));\n    return val;\n#endif\n}\n\nstatic inline uint32_t zng_memread_4(const void *ptr) {\n#if defined(HAVE_MAY_ALIAS)\n    typedef struct { uint32_t val; } __attribute__ ((__packed__, __may_alias__)) unaligned_uint32_t;\n    return ((const unaligned_uint32_t *)ptr)->val;\n#else\n    uint32_t val;\n    memcpy(&val, ptr, sizeof(val));\n    return val;\n#endif\n}\n\nstatic inline uint64_t zng_memread_8(const void *ptr) {\n#if defined(HAVE_MAY_ALIAS)\n    typedef struct { uint64_t val; } __attribute__ ((__packed__, __may_alias__)) unaligned_uint64_t;\n    return ((const unaligned_uint64_t *)ptr)->val;\n#else\n    uint64_t val;\n    memcpy(&val, ptr, sizeof(val));\n    return val;\n#endif\n}\n\nstatic inline void zng_memwrite_2(void *ptr, uint16_t val) {\n#if defined(HAVE_MAY_ALIAS)\n    typedef struct { uint16_t val; } __attribute__ ((__packed__, __may_alias__)) unaligned_uint16_t;\n    ((unaligned_uint16_t *)ptr)->val = val;\n#else\n    memcpy(ptr, &val, sizeof(val));\n#endif\n}\n\nstatic inline void zng_memwrite_4(void *ptr, uint32_t val) {\n#if defined(HAVE_MAY_ALIAS)\n    typedef struct { uint32_t val; } __attribute__ ((__packed__, __may_alias__)) unaligned_uint32_t;\n    ((unaligned_uint32_t *)ptr)->val = val;\n#else\n    memcpy(ptr, &val, sizeof(val));\n#endif\n}\n\nstatic inline void zng_memwrite_8(void *ptr, uint64_t val) {\n#if defined(HAVE_MAY_ALIAS)\n    typedef struct { uint64_t val; } __attribute__ ((__packed__, __may_alias__)) unaligned_uint64_t;\n    ((unaligned_uint64_t *)ptr)->val = val;\n#else\n    memcpy(ptr, &val, sizeof(val));\n#endif\n}\n\n/* Use zng_memread_* instead of memcmp to avoid older compilers not converting memcmp\n   calls to unaligned comparisons when unaligned access is supported. Use memcmp only when\n   unaligned support is not available to avoid an extra call to memcpy. */\nstatic inline int32_t zng_memcmp_2(const void *src0, const void *src1) {\n#if defined(HAVE_MAY_ALIAS)\n    return zng_memread_2(src0) != zng_memread_2(src1);\n#else\n    return memcmp(src0, src1, 2);\n#endif\n}\n\nstatic inline int32_t zng_memcmp_4(const void *src0, const void *src1) {\n#if defined(HAVE_MAY_ALIAS)\n    return zng_memread_4(src0) != zng_memread_4(src1);\n#else\n    return memcmp(src0, src1, 4);\n#endif\n}\n\nstatic inline int32_t zng_memcmp_8(const void *src0, const void *src1) {\n#if defined(HAVE_MAY_ALIAS)\n    return zng_memread_8(src0) != zng_memread_8(src1);\n#else\n    return memcmp(src0, src1, 8);\n#endif\n}\n\n#endif\n"
        },
        {
          "name": "zutil.c",
          "type": "blob",
          "size": 2.9541015625,
          "content": "/* zutil.c -- target dependent utility functions for the compression library\n * Copyright (C) 1995-2017 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zbuild.h\"\n#include \"zutil_p.h\"\n#include \"zutil.h\"\n\nz_const char * const PREFIX(z_errmsg)[10] = {\n    (z_const char *)\"need dictionary\",     /* Z_NEED_DICT       2  */\n    (z_const char *)\"stream end\",          /* Z_STREAM_END      1  */\n    (z_const char *)\"\",                    /* Z_OK              0  */\n    (z_const char *)\"file error\",          /* Z_ERRNO         (-1) */\n    (z_const char *)\"stream error\",        /* Z_STREAM_ERROR  (-2) */\n    (z_const char *)\"data error\",          /* Z_DATA_ERROR    (-3) */\n    (z_const char *)\"insufficient memory\", /* Z_MEM_ERROR     (-4) */\n    (z_const char *)\"buffer error\",        /* Z_BUF_ERROR     (-5) */\n    (z_const char *)\"incompatible version\",/* Z_VERSION_ERROR (-6) */\n    (z_const char *)\"\"\n};\n\nconst char PREFIX3(vstring)[] =\n    \" zlib-ng 2.2.3\";\n\n#ifdef ZLIB_COMPAT\nconst char * Z_EXPORT zlibVersion(void) {\n    return ZLIB_VERSION;\n}\n#else\nconst char * Z_EXPORT zlibng_version(void) {\n    return ZLIBNG_VERSION;\n}\n#endif\n\nunsigned long Z_EXPORT PREFIX(zlibCompileFlags)(void) {\n    unsigned long flags;\n\n    flags = 0;\n    switch ((int)(sizeof(unsigned int))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(unsigned long))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(void *))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef ZLIB_DEBUG\n    flags += 1 << 8;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n    /* Bit 13 reserved for DYNAMIC_CRC_TABLE */\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n    return flags;\n}\n\n#ifdef ZLIB_DEBUG\n#  include <stdlib.h>\n#  ifndef verbose\n#    define verbose 0\n#  endif\nint Z_INTERNAL z_verbose = verbose;\n\nvoid Z_INTERNAL z_error(const char *m) {\n    fprintf(stderr, \"%s\\n\", m);\n    exit(1);\n}\n#endif\n\n/* exported to allow conversion of error code to string for compress() and\n * uncompress()\n */\nconst char * Z_EXPORT PREFIX(zError)(int err) {\n    return ERR_MSG(err);\n}\n\nvoid Z_INTERNAL *PREFIX(zcalloc)(void *opaque, unsigned items, unsigned size) {\n    Z_UNUSED(opaque);\n    return zng_alloc((size_t)items * (size_t)size);\n}\n\nvoid Z_INTERNAL PREFIX(zcfree)(void *opaque, void *ptr) {\n    Z_UNUSED(opaque);\n    zng_free(ptr);\n}\n"
        },
        {
          "name": "zutil.h",
          "type": "blob",
          "size": 3.7841796875,
          "content": "#ifndef ZUTIL_H_\n#define ZUTIL_H_\n/* zutil.h -- internal interface and configuration of the compression library\n * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n#include \"zbuild.h\"\n#ifdef ZLIB_COMPAT\n#  include \"zlib.h\"\n#else\n#  include \"zlib-ng.h\"\n#endif\n\ntypedef unsigned char uch; /* Included for compatibility with external code only */\ntypedef uint16_t ush;      /* Included for compatibility with external code only */\ntypedef unsigned long ulg;\n\nextern z_const char * const PREFIX(z_errmsg)[10]; /* indexed by 2-zlib_error */\n/* (size given to avoid silly warnings with Visual C++) */\n\n#define ERR_MSG(err) PREFIX(z_errmsg)[(err) < -6 || (err) > 2 ? 9 : 2 - (err)]\n\n#define ERR_RETURN(strm, err) return (strm->msg = ERR_MSG(err), (err))\n/* To be used only when the state is known to be valid */\n\n        /* common constants */\n\n#ifndef DEF_WBITS\n#  define DEF_WBITS MAX_WBITS\n#endif\n/* default windowBits for decompression. MAX_WBITS is for compression only */\n\n#define MAX_BITS 15\n/* all codes must not exceed MAX_BITS bits */\n#define MAX_DIST_EXTRA_BITS 13\n/* maximum number of extra distance bits */\n\n#if MAX_MEM_LEVEL >= 8\n#  define DEF_MEM_LEVEL 8\n#else\n#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL\n#endif\n/* default memLevel */\n\n#define STORED_BLOCK 0\n#define STATIC_TREES 1\n#define DYN_TREES    2\n/* The three kinds of block type */\n\n#define STD_MIN_MATCH  3\n#define STD_MAX_MATCH  258\n/* The minimum and maximum match lengths mandated by the deflate standard */\n\n#define WANT_MIN_MATCH  4\n/* The minimum wanted match length, affects deflate_quick, deflate_fast, deflate_medium and deflate_slow  */\n\n#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */\n\n#define ADLER32_INITIAL_VALUE 1 /* initial adler-32 hash value */\n#define CRC32_INITIAL_VALUE   0 /* initial crc-32 hash value */\n\n#define ZLIB_WRAPLEN 6      /* zlib format overhead */\n#define GZIP_WRAPLEN 18     /* gzip format overhead */\n\n#define DEFLATE_HEADER_BITS 3\n#define DEFLATE_EOBS_BITS   15\n#define DEFLATE_PAD_BITS    6\n#define DEFLATE_BLOCK_OVERHEAD ((DEFLATE_HEADER_BITS + DEFLATE_EOBS_BITS + DEFLATE_PAD_BITS) >> 3)\n/* deflate block overhead: 3 bits for block start + 15 bits for block end + padding to nearest byte */\n\n#define DEFLATE_QUICK_LIT_MAX_BITS 9\n#define DEFLATE_QUICK_OVERHEAD(x) ((x * (DEFLATE_QUICK_LIT_MAX_BITS - 8) + 7) >> 3)\n/* deflate_quick worst-case overhead: 9 bits per literal, round up to next byte (+7) */\n\n\n        /* target dependencies */\n\n#ifdef AMIGA\n#  define OS_CODE  1\n#endif\n\n#ifdef __370__\n#  if __TARGET_LIB__ < 0x20000000\n#    define OS_CODE 4\n#  elif __TARGET_LIB__ < 0x40000000\n#    define OS_CODE 11\n#  else\n#    define OS_CODE 8\n#  endif\n#endif\n\n#if defined(ATARI) || defined(atarist)\n#  define OS_CODE  5\n#endif\n\n#ifdef OS2\n#  define OS_CODE  6\n#endif\n\n#if defined(MACOS)\n#  define OS_CODE  7\n#endif\n\n#ifdef __acorn\n#  define OS_CODE 13\n#endif\n\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#  define OS_CODE  10\n#endif\n\n#ifdef __APPLE__\n#  define OS_CODE 19\n#endif\n\n        /* common defaults */\n\n#ifndef OS_CODE\n#  define OS_CODE  3  /* assume Unix */\n#endif\n\n         /* macros */\n\n#define CHECK_VER_STSIZE(_ver,_stsize) ((_ver) == NULL || (_ver)[0] != PREFIX2(VERSION)[0] || (_stsize) != (int32_t)sizeof(PREFIX3(stream)))\n\n         /* memory allocation functions */\n\nvoid Z_INTERNAL *PREFIX(zcalloc)(void *opaque, unsigned items, unsigned size);\nvoid Z_INTERNAL  PREFIX(zcfree)(void *opaque, void *ptr);\n\ntypedef void *zng_calloc_func(void *opaque, unsigned items, unsigned size);\ntypedef void  zng_cfree_func(void *opaque, void *ptr);\n\n#endif /* ZUTIL_H_ */\n"
        },
        {
          "name": "zutil_p.h",
          "type": "blob",
          "size": 1.2353515625,
          "content": "/* zutil_p.h -- Private inline functions used internally in zlib-ng\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#ifndef ZUTIL_P_H\n#define ZUTIL_P_H\n\n#if defined(__APPLE__) || defined(HAVE_POSIX_MEMALIGN) || defined(HAVE_ALIGNED_ALLOC)\n#  include <stdlib.h>\n#elif defined(__FreeBSD__)\n#  include <stdlib.h>\n#  include <malloc_np.h>\n#else\n#  include <malloc.h>\n#endif\n\n/* Function to allocate 16 or 64-byte aligned memory */\nstatic inline void *zng_alloc(size_t size) {\n#ifdef HAVE_ALIGNED_ALLOC\n    /* Size must be a multiple of alignment */\n    size = (size + (64 - 1)) & ~(64 - 1);\n    return (void *)aligned_alloc(64, size);  /* Defined in C11 */\n#elif defined(HAVE_POSIX_MEMALIGN)\n    void *ptr;\n    return posix_memalign(&ptr, 64, size) ? NULL : ptr;\n#elif defined(_WIN32)\n    return (void *)_aligned_malloc(size, 64);\n#elif defined(__APPLE__)\n    /* Fallback for when posix_memalign and aligned_alloc are not available.\n     * On macOS, it always aligns to 16 bytes. */\n    return (void *)malloc(size);\n#else\n    return (void *)memalign(64, size);\n#endif\n}\n\n/* Function that can free aligned memory */\nstatic inline void zng_free(void *ptr) {\n#if defined(_WIN32)\n    _aligned_free(ptr);\n#else\n    free(ptr);\n#endif\n}\n\n#endif\n"
        }
      ]
    }
  ]
}