{
  "metadata": {
    "timestamp": 1736710204983,
    "page": 913,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rofl0r/microsocks",
      "stars": 1626,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": "*.o\n*.out\n\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.228515625,
          "content": "microSocks is licensed under the following standard MIT license:\n\n----------------------------------------------------------------------\nCopyright Â© 2017 rofl0r.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n----------------------------------------------------------------------\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.626953125,
          "content": "# if you want to change/override some variables, do so in a file called\n# config.mak, which is gets included automatically if it exists.\n\nprefix = /usr/local\nbindir = $(prefix)/bin\n\nPROG = microsocks\nSRCS =  sockssrv.c server.c sblist.c sblist_delete.c\nOBJS = $(SRCS:.c=.o)\n\nLIBS = -lpthread\n\nCFLAGS += -Wall -std=c99\n\nINSTALL = ./install.sh\n\n-include config.mak\n\nall: $(PROG)\n\ninstall: $(PROG)\n\t$(INSTALL) -D -m 755 $(PROG) $(DESTDIR)$(bindir)/$(PROG)\n\nclean:\n\trm -f $(PROG)\n\trm -f $(OBJS)\n\n%.o: %.c\n\t$(CC) $(CPPFLAGS) $(CFLAGS) $(INC) $(PIC) -c -o $@ $<\n\n$(PROG): $(OBJS)\n\t$(CC) $(LDFLAGS) $(OBJS) $(LIBS) -o $@\n\n.PHONY: all clean install\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.966796875,
          "content": "MicroSocks - multithreaded, small, efficient SOCKS5 server.\n===========================================================\n\na SOCKS5 service that you can run on your remote boxes to tunnel connections\nthrough them, if for some reason SSH doesn't cut it for you.\n\nIt's very lightweight, and very light on resources too:\n\nfor every client, a thread with a low stack size is spawned.\nthe main process basically doesn't consume any resources at all.\n\nthe only limits are the amount of file descriptors and the RAM.\n\nIt's also designed to be robust: it handles resource exhaustion\ngracefully by simply denying new connections, instead of calling abort()\nas most other programs do these days.\n\nanother plus is ease-of-use: no config file necessary, everything can be\ndone from the command line and doesn't even need any parameters for quick\nsetup.\n\nHistory\n-------\n\nThis is the successor of \"rocksocks5\", and it was written with\ndifferent goals in mind:\n\n- prefer usage of standard libc functions over homegrown ones\n- no artificial limits\n- do not aim for minimal binary size, but for minimal source code size,\n  and maximal readability, reusability, and extensibility.\n\nas a result of that, ipv4, dns, and ipv6 is supported out of the box\nand can use the same code, while rocksocks5 has several compile time\ndefines to bring down the size of the resulting binary to extreme values\nlike 10 KB static linked when only ipv4 support is enabled.\n\nstill, if optimized for size, *this* program when static linked against musl\nlibc is not even 50 KB. that's easily usable even on the cheapest routers.\n\ncommand line options\n--------------------\n\n    microsocks -1 -q -i listenip -p port -u user -P passw -b bindaddr -w wl\n\nall arguments are optional.\nby default listenip is 0.0.0.0 and port 1080.\n\n- option -q disables logging.\n- option -b specifies which ip outgoing connections are bound to\n- option -w allows to specify a comma-separated whitelist of ip addresses,\nthat may use the proxy without user/pass authentication.\ne.g. -w 127.0.0.1,192.168.1.1.1,::1 or just -w 10.0.0.1\nto allow access ONLY to those ips, choose an impossible to guess user/pw combo.\n- option -1 activates auth_once mode: once a specific ip address\nauthed successfully with user/pass, it is added to a whitelist\nand may use the proxy without auth.\nthis is handy for programs like firefox that don't support\nuser/pass auth. for it to work you'd basically make one connection\nwith another program that supports it, and then you can use firefox too.\nfor example, authenticate once using curl:\n\n    curl --socks5 user:password@listenip:port anyurl\n\n\nSupported SOCKS5 Features\n-------------------------\n- authentication: none, password, one-time\n- IPv4, IPv6, DNS\n- TCP (no UDP at this time)\n\nTroubleshooting\n---------------\n\nif you experience segfaults, try raising the `THREAD_STACK_SIZE` in sockssrv.c\nfor your platform in steps of 4KB.\n\nif this fixes your issue please file a pull request.\n\nmicrosocks uses the smallest safe thread stack size to minimize overall memory\nusage.\n"
        },
        {
          "name": "create-dist.sh",
          "type": "blob",
          "size": 0.4560546875,
          "content": "#!/bin/sh\nif [ -z \"$VER\" ] ; then\n\techo set VER!\n\texit\nfi\nme=`pwd`\n\nproj=microsocks\nprojver=${proj}-${VER}\n\ntempdir=/tmp/${proj}-0000\nrm -rf \"$tempdir\"\nmkdir -p \"$tempdir\"\n\ncd $tempdir\nGITDIR=https://github.com/rofl0r/$proj\nGITDIR=$me\ngit clone \"$GITDIR\" $projver\n\nrm -rf $projver/.git\nrm -rf $projver/docs\nrm -f $projver/.gitignore\nrm -f $projver/create-dist.sh\n\ntar cf $proj.tar $projver/\nxz -z -9 -e $proj.tar\nmv $proj.tar.xz $me/$projver.tar.xz\nrm -rf \"$tempdir\"\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 1.00390625,
          "content": "#!/bin/sh\n#\n# Written by Rich Felker, originally as part of musl libc.\n# Multi-licensed under MIT, 0BSD, and CC0.\n#\n# This is an actually-safe install command which installs the new\n# file atomically in the new location, rather than overwriting\n# existing files.\n#\n\nusage() {\nprintf \"usage: %s [-D] [-l] [-m mode] src dest\\n\" \"$0\" 1>&2\nexit 1\n}\n\nmkdirp=\nsymlink=\nmode=755\n\nwhile getopts Dlm: name ; do\ncase \"$name\" in\nD) mkdirp=yes ;;\nl) symlink=yes ;;\nm) mode=$OPTARG ;;\n?) usage ;;\nesac\ndone\nshift $(($OPTIND - 1))\n\ntest \"$#\" -eq 2 || usage\nsrc=$1\ndst=$2\ntmp=\"$dst.tmp.$$\"\n\ncase \"$dst\" in\n*/) printf \"%s: %s ends in /\\n\", \"$0\" \"$dst\" 1>&2 ; exit 1 ;;\nesac\n\nset -C\nset -e\n\nif test \"$mkdirp\" ; then\numask 022\ncase \"$2\" in\n*/*) mkdir -p \"${dst%/*}\" ;;\nesac\nfi\n\ntrap 'rm -f \"$tmp\"' EXIT INT QUIT TERM HUP\n\numask 077\n\nif test \"$symlink\" ; then\nln -s \"$1\" \"$tmp\"\nelse\ncat < \"$1\" > \"$tmp\"\nchmod \"$mode\" \"$tmp\"\nfi\n\nmv -f \"$tmp\" \"$2\"\ntest -d \"$2\" && {\nrm -f \"$2/$tmp\"\nprintf \"%s: %s is a directory\\n\" \"$0\" \"$dst\" 1>&2\nexit 1\n}\n\nexit 0\n"
        },
        {
          "name": "sblist.c",
          "type": "blob",
          "size": 1.5087890625,
          "content": "#undef _POSIX_C_SOURCE\n#define _POSIX_C_SOURCE 200809L\n#include \"sblist.h\"\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#define MY_PAGE_SIZE 4096\n\nsblist* sblist_new(size_t itemsize, size_t blockitems) {\n\tsblist* ret = (sblist*) malloc(sizeof(sblist));\n\tsblist_init(ret, itemsize, blockitems);\n\treturn ret;\n}\n\nstatic void sblist_clear(sblist* l) {\n\tl->items = NULL;\n\tl->capa = 0;\n\tl->count = 0;\n}\n\nvoid sblist_init(sblist* l, size_t itemsize, size_t blockitems) {\n\tif(l) {\n\t\tl->blockitems = blockitems ? blockitems : MY_PAGE_SIZE / itemsize;\n\t\tl->itemsize = itemsize;\n\t\tsblist_clear(l);\n\t}\n}\n\nvoid sblist_free_items(sblist* l) {\n\tif(l) {\n\t\tif(l->items) free(l->items);\n\t\tsblist_clear(l);\n\t}\n}\n\nvoid sblist_free(sblist* l) {\n\tif(l) {\n\t\tsblist_free_items(l);\n\t\tfree(l);\n\t}\n}\n\nchar* sblist_item_from_index(sblist* l, size_t idx) {\n\treturn l->items + (idx * l->itemsize);\n}\n\nvoid* sblist_get(sblist* l, size_t item) {\n\tif(item < l->count) return (void*) sblist_item_from_index(l, item);\n\treturn NULL;\n}\n\nint sblist_set(sblist* l, void* item, size_t pos) {\n\tif(pos >= l->count) return 0;\n\tmemcpy(sblist_item_from_index(l, pos), item, l->itemsize);\n\treturn 1;\n}\n\nint sblist_grow_if_needed(sblist* l) {\n\tchar* temp;\n\tif(l->count == l->capa) {\n\t\ttemp = realloc(l->items, (l->capa + l->blockitems) * l->itemsize);\n\t\tif(!temp) return 0;\n\t\tl->capa += l->blockitems;\n\t\tl->items = temp;\n\t}\n\treturn 1;\n}\n\nint sblist_add(sblist* l, void* item) {\n\tif(!sblist_grow_if_needed(l)) return 0;\n\tl->count++;\n\treturn sblist_set(l, item, l->count - 1);\n}\n"
        },
        {
          "name": "sblist.h",
          "type": "blob",
          "size": 2.8828125,
          "content": "#ifndef SBLIST_H\n#define SBLIST_H\n\n/* this file is part of libulz, as of commit 8ab361a27743aaf025323ee43b8b8876dc054fdd\n   modified for direct inclusion in microsocks. */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stddef.h>\n/*\n * simple buffer list.\n * \n * this thing here is basically a generic dynamic array\n * will realloc after every blockitems inserts\n * can store items of any size.\n * \n * so think of it as a by-value list, as opposed to a typical by-ref list.\n * you typically use it by having some struct on the stack, and pass a pointer\n * to sblist_add, which will copy the contents into its internal memory.\n * \n */\n\ntypedef struct {\n\tsize_t itemsize;\n\tsize_t blockitems;\n\tsize_t count;\n\tsize_t capa;\n\tchar* items;\n} sblist;\n\n#define sblist_getsize(X) ((X)->count)\n#define sblist_get_count(X) ((X)->count)\n#define sblist_empty(X) ((X)->count == 0)\n\n// for dynamic style\nsblist* sblist_new(size_t itemsize, size_t blockitems);\nvoid sblist_free(sblist* l);\n\n//for static style\nvoid sblist_init(sblist* l, size_t itemsize, size_t blockitems);\nvoid sblist_free_items(sblist* l);\n\n// accessors\nvoid* sblist_get(sblist* l, size_t item);\n// returns 1 on success, 0 on OOM\nint sblist_add(sblist* l, void* item);\nint sblist_set(sblist* l, void* item, size_t pos);\nvoid sblist_delete(sblist* l, size_t item);\nchar* sblist_item_from_index(sblist* l, size_t idx);\nint sblist_grow_if_needed(sblist* l);\nint sblist_insert(sblist* l, void* item, size_t pos);\n/* same as sblist_add, but returns list index of new item, or -1 */\nsize_t sblist_addi(sblist* l, void* item);\nvoid sblist_sort(sblist *l, int (*compar)(const void *, const void *));\n/* insert element into presorted list, returns listindex of new entry or -1*/\nsize_t sblist_insert_sorted(sblist* l, void* o, int (*compar)(const void *, const void *));\n\n#ifndef __COUNTER__\n#define __COUNTER__ __LINE__\n#endif\n\n#define __sblist_concat_impl( x, y ) x##y\n#define __sblist_macro_concat( x, y ) __sblist_concat_impl( x, y )\n#define __sblist_iterator_name __sblist_macro_concat(sblist_iterator, __COUNTER__)\n\n// use with custom iterator variable\n#define sblist_iter_counter(LIST, ITER, PTR) \\\n\tfor(size_t ITER = 0; (PTR = sblist_get(LIST, ITER)), ITER < sblist_getsize(LIST); ITER++)\n\n// use with custom iterator variable, which is predeclared\n#define sblist_iter_counter2(LIST, ITER, PTR) \\\n\tfor(ITER = 0; (PTR = sblist_get(LIST, ITER)), ITER < sblist_getsize(LIST); ITER++)\n\n// use with custom iterator variable, which is predeclared and signed\n// useful for a loop which can delete items from the list, and then decrease the iterator var.\n#define sblist_iter_counter2s(LIST, ITER, PTR) \\\n\tfor(ITER = 0; (PTR = sblist_get(LIST, ITER)), ITER < (ssize_t) sblist_getsize(LIST); ITER++)\n\n\n// uses \"magic\" iterator variable\n#define sblist_iter(LIST, PTR) sblist_iter_counter(LIST, __sblist_iterator_name, PTR)\n\n#ifdef __cplusplus\n}\n#endif\n\n#pragma RcB2 DEP \"sblist.c\" \"sblist_delete.c\"\n\n#endif\n"
        },
        {
          "name": "sblist_delete.c",
          "type": "blob",
          "size": 0.263671875,
          "content": "#include \"sblist.h\"\n#include <string.h>\n\nvoid sblist_delete(sblist* l, size_t item) {\n\tif (l->count && item < l->count) {\n\t\tmemmove(sblist_item_from_index(l, item), sblist_item_from_index(l, item + 1), (sblist_getsize(l) - (item + 1)) * l->itemsize);\n\t\tl->count--;\n\t}\n}\n"
        },
        {
          "name": "server.c",
          "type": "blob",
          "size": 1.7177734375,
          "content": "#include \"server.h\"\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nint resolve(const char *host, unsigned short port, struct addrinfo** addr) {\n\tstruct addrinfo hints = {\n\t\t.ai_family = AF_UNSPEC,\n\t\t.ai_socktype = SOCK_STREAM,\n\t\t.ai_flags = AI_PASSIVE,\n\t};\n\tchar port_buf[8];\n\tsnprintf(port_buf, sizeof port_buf, \"%u\", port);\n\treturn getaddrinfo(host, port_buf, &hints, addr);\n}\n\nint resolve_sa(const char *host, unsigned short port, union sockaddr_union *res) {\n\tstruct addrinfo *ainfo = 0;\n\tint ret;\n\tSOCKADDR_UNION_AF(res) = AF_UNSPEC;\n\tif((ret = resolve(host, port, &ainfo))) return ret;\n\tmemcpy(res, ainfo->ai_addr, ainfo->ai_addrlen);\n\tfreeaddrinfo(ainfo);\n\treturn 0;\n}\n\nint bindtoip(int fd, union sockaddr_union *bindaddr) {\n\tsocklen_t sz = SOCKADDR_UNION_LENGTH(bindaddr);\n\tif(sz)\n\t\treturn bind(fd, (struct sockaddr*) bindaddr, sz);\n\treturn 0;\n}\n\nint server_waitclient(struct server *server, struct client* client) {\n\tsocklen_t clen = sizeof client->addr;\n\treturn ((client->fd = accept(server->fd, (void*)&client->addr, &clen)) == -1)*-1;\n}\n\nint server_setup(struct server *server, const char* listenip, unsigned short port) {\n\tstruct addrinfo *ainfo = 0;\n\tif(resolve(listenip, port, &ainfo)) return -1;\n\tstruct addrinfo* p;\n\tint listenfd = -1;\n\tfor(p = ainfo; p; p = p->ai_next) {\n\t\tif((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)\n\t\t\tcontinue;\n\t\tint yes = 1;\n\t\tsetsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));\n\t\tif(bind(listenfd, p->ai_addr, p->ai_addrlen) < 0) {\n\t\t\tclose(listenfd);\n\t\t\tlistenfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfreeaddrinfo(ainfo);\n\tif(listenfd < 0) return -2;\n\tif(listen(listenfd, SOMAXCONN) < 0) {\n\t\tclose(listenfd);\n\t\treturn -3;\n\t}\n\tserver->fd = listenfd;\n\treturn 0;\n}\n"
        },
        {
          "name": "server.h",
          "type": "blob",
          "size": 1.302734375,
          "content": "#ifndef SERVER_H\n#define SERVER_H\n\n#undef _POSIX_C_SOURCE\n#define _POSIX_C_SOURCE 200809L\n\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n\n#pragma RcB2 DEP \"server.c\"\n\nunion sockaddr_union {\n\tstruct sockaddr_in  v4;\n\tstruct sockaddr_in6 v6;\n};\n\n#define SOCKADDR_UNION_AF(PTR) (PTR)->v4.sin_family\n\n#define SOCKADDR_UNION_LENGTH(PTR) ( \\\n\t( SOCKADDR_UNION_AF(PTR) == AF_INET  ) ? sizeof((PTR)->v4) : ( \\\n\t( SOCKADDR_UNION_AF(PTR) == AF_INET6 ) ? sizeof((PTR)->v6) : 0 ) )\n\n#define SOCKADDR_UNION_ADDRESS(PTR) ( \\\n\t( SOCKADDR_UNION_AF(PTR) == AF_INET  ) ? (void*) &(PTR)->v4.sin_addr  : ( \\\n\t( SOCKADDR_UNION_AF(PTR) == AF_INET6 ) ? (void*) &(PTR)->v6.sin6_addr : (void*) 0 ) )\n\n#define SOCKADDR_UNION_PORT(PTR) ( \\\n\t( SOCKADDR_UNION_AF(PTR) == AF_INET  ) ? (PTR)->v4.sin_port  : ( \\\n\t( SOCKADDR_UNION_AF(PTR) == AF_INET6 ) ? (PTR)->v6.sin6_port : 0 ) )\n\nstruct client {\n\tunion sockaddr_union addr;\n\tint fd;\n};\n\nstruct server {\n\tint fd;\n};\n\nint resolve(const char *host, unsigned short port, struct addrinfo** addr);\nint resolve_sa(const char *host, unsigned short port, union sockaddr_union *res);\nint bindtoip(int fd, union sockaddr_union *bindaddr);\n\nint server_waitclient(struct server *server, struct client* client);\nint server_setup(struct server *server, const char* listenip, unsigned short port);\n\n#endif\n\n"
        },
        {
          "name": "sockssrv.c",
          "type": "blob",
          "size": 13.8388671875,
          "content": "/*\n   MicroSocks - multithreaded, small, efficient SOCKS5 server.\n\n   Copyright (C) 2017 rofl0r.\n\n   This is the successor of \"rocksocks5\", and it was written with\n   different goals in mind:\n\n   - prefer usage of standard libc functions over homegrown ones\n   - no artificial limits\n   - do not aim for minimal binary size, but for minimal source code size,\n     and maximal readability, reusability, and extensibility.\n\n   as a result of that, ipv4, dns, and ipv6 is supported out of the box\n   and can use the same code, while rocksocks5 has several compile time\n   defines to bring down the size of the resulting binary to extreme values\n   like 10 KB static linked when only ipv4 support is enabled.\n\n   still, if optimized for size, *this* program when static linked against musl\n   libc is not even 50 KB. that's easily usable even on the cheapest routers.\n\n*/\n\n#define _GNU_SOURCE\n#include <unistd.h>\n#define _POSIX_C_SOURCE 200809L\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <pthread.h>\n#include <signal.h>\n#include <poll.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <limits.h>\n#include \"server.h\"\n#include \"sblist.h\"\n\n/* timeout in microseconds on resource exhaustion to prevent excessive\n   cpu usage. */\n#ifndef FAILURE_TIMEOUT\n#define FAILURE_TIMEOUT 64\n#endif\n\n#ifndef MAX\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#endif\n\n#ifdef PTHREAD_STACK_MIN\n#define THREAD_STACK_SIZE MAX(16*1024, PTHREAD_STACK_MIN)\n#else\n#define THREAD_STACK_SIZE 64*1024\n#endif\n\n#if defined(__APPLE__)\n#undef THREAD_STACK_SIZE\n#define THREAD_STACK_SIZE 64*1024\n#elif defined(__GLIBC__) || defined(__FreeBSD__) || defined(__sun__)\n#undef THREAD_STACK_SIZE\n#define THREAD_STACK_SIZE 32*1024\n#endif\n\nstatic int quiet;\nstatic const char* auth_user;\nstatic const char* auth_pass;\nstatic sblist* auth_ips;\nstatic pthread_rwlock_t auth_ips_lock = PTHREAD_RWLOCK_INITIALIZER;\nstatic const struct server* server;\nstatic union sockaddr_union bind_addr = {.v4.sin_family = AF_UNSPEC};\n\nenum socksstate {\n\tSS_1_CONNECTED,\n\tSS_2_NEED_AUTH, /* skipped if NO_AUTH method supported */\n\tSS_3_AUTHED,\n};\n\nenum authmethod {\n\tAM_NO_AUTH = 0,\n\tAM_GSSAPI = 1,\n\tAM_USERNAME = 2,\n\tAM_INVALID = 0xFF\n};\n\nenum errorcode {\n\tEC_SUCCESS = 0,\n\tEC_GENERAL_FAILURE = 1,\n\tEC_NOT_ALLOWED = 2,\n\tEC_NET_UNREACHABLE = 3,\n\tEC_HOST_UNREACHABLE = 4,\n\tEC_CONN_REFUSED = 5,\n\tEC_TTL_EXPIRED = 6,\n\tEC_COMMAND_NOT_SUPPORTED = 7,\n\tEC_ADDRESSTYPE_NOT_SUPPORTED = 8,\n};\n\nstruct thread {\n\tpthread_t pt;\n\tstruct client client;\n\tenum socksstate state;\n\tvolatile int  done;\n};\n\n#ifndef CONFIG_LOG\n#define CONFIG_LOG 1\n#endif\n#if CONFIG_LOG\n/* we log to stderr because it's not using line buffering, i.e. malloc which would need\n   locking when called from different threads. for the same reason we use dprintf,\n   which writes directly to an fd. */\n#define dolog(...) do { if(!quiet) dprintf(2, __VA_ARGS__); } while(0)\n#else\nstatic void dolog(const char* fmt, ...) { }\n#endif\n\nstatic struct addrinfo* addr_choose(struct addrinfo* list, union sockaddr_union* bindaddr) {\n\tint af = SOCKADDR_UNION_AF(bindaddr);\n\tif(af == AF_UNSPEC) return list;\n\tstruct addrinfo* p;\n\tfor(p=list; p; p=p->ai_next)\n\t\tif(p->ai_family == af) return p;\n\treturn list;\n}\n\nstatic int connect_socks_target(unsigned char *buf, size_t n, struct client *client) {\n\tif(n < 5) return -EC_GENERAL_FAILURE;\n\tif(buf[0] != 5) return -EC_GENERAL_FAILURE;\n\tif(buf[1] != 1) return -EC_COMMAND_NOT_SUPPORTED; /* we support only CONNECT method */\n\tif(buf[2] != 0) return -EC_GENERAL_FAILURE; /* malformed packet */\n\n\tint af = AF_INET;\n\tsize_t minlen = 4 + 4 + 2, l;\n\tchar namebuf[256];\n\tstruct addrinfo* remote;\n\n\tswitch(buf[3]) {\n\t\tcase 4: /* ipv6 */\n\t\t\taf = AF_INET6;\n\t\t\tminlen = 4 + 2 + 16;\n\t\t\t/* fall through */\n\t\tcase 1: /* ipv4 */\n\t\t\tif(n < minlen) return -EC_GENERAL_FAILURE;\n\t\t\tif(namebuf != inet_ntop(af, buf+4, namebuf, sizeof namebuf))\n\t\t\t\treturn -EC_GENERAL_FAILURE; /* malformed or too long addr */\n\t\t\tbreak;\n\t\tcase 3: /* dns name */\n\t\t\tl = buf[4];\n\t\t\tminlen = 4 + 2 + l + 1;\n\t\t\tif(n < 4 + 2 + l + 1) return -EC_GENERAL_FAILURE;\n\t\t\tmemcpy(namebuf, buf+4+1, l);\n\t\t\tnamebuf[l] = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EC_ADDRESSTYPE_NOT_SUPPORTED;\n\t}\n\tunsigned short port;\n\tport = (buf[minlen-2] << 8) | buf[minlen-1];\n\t/* there's no suitable errorcode in rfc1928 for dns lookup failure */\n\tif(resolve(namebuf, port, &remote)) return -EC_GENERAL_FAILURE;\n\tstruct addrinfo* raddr = addr_choose(remote, &bind_addr);\n\tint fd = socket(raddr->ai_family, SOCK_STREAM, 0);\n\tif(fd == -1) {\n\t\teval_errno:\n\t\tif(fd != -1) close(fd);\n\t\tfreeaddrinfo(remote);\n\t\tswitch(errno) {\n\t\t\tcase ETIMEDOUT:\n\t\t\t\treturn -EC_TTL_EXPIRED;\n\t\t\tcase EPROTOTYPE:\n\t\t\tcase EPROTONOSUPPORT:\n\t\t\tcase EAFNOSUPPORT:\n\t\t\t\treturn -EC_ADDRESSTYPE_NOT_SUPPORTED;\n\t\t\tcase ECONNREFUSED:\n\t\t\t\treturn -EC_CONN_REFUSED;\n\t\t\tcase ENETDOWN:\n\t\t\tcase ENETUNREACH:\n\t\t\t\treturn -EC_NET_UNREACHABLE;\n\t\t\tcase EHOSTUNREACH:\n\t\t\t\treturn -EC_HOST_UNREACHABLE;\n\t\t\tcase EBADF:\n\t\t\tdefault:\n\t\t\tperror(\"socket/connect\");\n\t\t\treturn -EC_GENERAL_FAILURE;\n\t\t}\n\t}\n\tif(SOCKADDR_UNION_AF(&bind_addr) == raddr->ai_family &&\n\t   bindtoip(fd, &bind_addr) == -1)\n\t\tgoto eval_errno;\n\tif(connect(fd, raddr->ai_addr, raddr->ai_addrlen) == -1)\n\t\tgoto eval_errno;\n\n\tfreeaddrinfo(remote);\n\tif(CONFIG_LOG) {\n\t\tchar clientname[256];\n\t\taf = SOCKADDR_UNION_AF(&client->addr);\n\t\tvoid *ipdata = SOCKADDR_UNION_ADDRESS(&client->addr);\n\t\tinet_ntop(af, ipdata, clientname, sizeof clientname);\n\t\tdolog(\"client[%d] %s: connected to %s:%d\\n\", client->fd, clientname, namebuf, port);\n\t}\n\treturn fd;\n}\n\nstatic int is_authed(union sockaddr_union *client, union sockaddr_union *authedip) {\n\tint af = SOCKADDR_UNION_AF(authedip);\n\tif(af == SOCKADDR_UNION_AF(client)) {\n\t\tsize_t cmpbytes = af == AF_INET ? 4 : 16;\n\t\tvoid *cmp1 = SOCKADDR_UNION_ADDRESS(client);\n\t\tvoid *cmp2 = SOCKADDR_UNION_ADDRESS(authedip);\n\t\tif(!memcmp(cmp1, cmp2, cmpbytes)) return 1;\n\t}\n\treturn 0;\n}\n\nstatic int is_in_authed_list(union sockaddr_union *caddr) {\n\tsize_t i;\n\tfor(i=0;i<sblist_getsize(auth_ips);i++)\n\t\tif(is_authed(caddr, sblist_get(auth_ips, i)))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic void add_auth_ip(union sockaddr_union *caddr) {\n\tsblist_add(auth_ips, caddr);\n}\n\nstatic enum authmethod check_auth_method(unsigned char *buf, size_t n, struct client*client) {\n\tif(buf[0] != 5) return AM_INVALID;\n\tsize_t idx = 1;\n\tif(idx >= n ) return AM_INVALID;\n\tint n_methods = buf[idx];\n\tidx++;\n\twhile(idx < n && n_methods > 0) {\n\t\tif(buf[idx] == AM_NO_AUTH) {\n\t\t\tif(!auth_user) return AM_NO_AUTH;\n\t\t\telse if(auth_ips) {\n\t\t\t\tint authed = 0;\n\t\t\t\tif(pthread_rwlock_rdlock(&auth_ips_lock) == 0) {\n\t\t\t\t\tauthed = is_in_authed_list(&client->addr);\n\t\t\t\t\tpthread_rwlock_unlock(&auth_ips_lock);\n\t\t\t\t}\n\t\t\t\tif(authed) return AM_NO_AUTH;\n\t\t\t}\n\t\t} else if(buf[idx] == AM_USERNAME) {\n\t\t\tif(auth_user) return AM_USERNAME;\n\t\t}\n\t\tidx++;\n\t\tn_methods--;\n\t}\n\treturn AM_INVALID;\n}\n\nstatic void send_auth_response(int fd, int version, enum authmethod meth) {\n\tunsigned char buf[2];\n\tbuf[0] = version;\n\tbuf[1] = meth;\n\twrite(fd, buf, 2);\n}\n\nstatic void send_error(int fd, enum errorcode ec) {\n\t/* position 4 contains ATYP, the address type, which is the same as used in the connect\n\t   request. we're lazy and return always IPV4 address type in errors. */\n\tchar buf[10] = { 5, ec, 0, 1 /*AT_IPV4*/, 0,0,0,0, 0,0 };\n\twrite(fd, buf, 10);\n}\n\nstatic void copyloop(int fd1, int fd2) {\n\tstruct pollfd fds[2] = {\n\t\t[0] = {.fd = fd1, .events = POLLIN},\n\t\t[1] = {.fd = fd2, .events = POLLIN},\n\t};\n\n\twhile(1) {\n\t\t/* inactive connections are reaped after 15 min to free resources.\n\t\t   usually programs send keep-alive packets so this should only happen\n\t\t   when a connection is really unused. */\n\t\tswitch(poll(fds, 2, 60*15*1000)) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase -1:\n\t\t\t\tif(errno == EINTR || errno == EAGAIN) continue;\n\t\t\t\telse perror(\"poll\");\n\t\t\t\treturn;\n\t\t}\n\t\tint infd = (fds[0].revents & POLLIN) ? fd1 : fd2;\n\t\tint outfd = infd == fd2 ? fd1 : fd2;\n\t\t/* since the biggest stack consumer in the entire code is\n\t\t   libc's getaddrinfo(), we can safely use at least half the\n\t\t   available stacksize to improve throughput. */\n\t\tchar buf[MIN(16*1024, THREAD_STACK_SIZE/2)];\n\t\tssize_t sent = 0, n = read(infd, buf, sizeof buf);\n\t\tif(n <= 0) return;\n\t\twhile(sent < n) {\n\t\t\tssize_t m = write(outfd, buf+sent, n-sent);\n\t\t\tif(m < 0) return;\n\t\t\tsent += m;\n\t\t}\n\t}\n}\n\nstatic enum errorcode check_credentials(unsigned char* buf, size_t n) {\n\tif(n < 5) return EC_GENERAL_FAILURE;\n\tif(buf[0] != 1) return EC_GENERAL_FAILURE;\n\tunsigned ulen, plen;\n\tulen=buf[1];\n\tif(n < 2 + ulen + 2) return EC_GENERAL_FAILURE;\n\tplen=buf[2+ulen];\n\tif(n < 2 + ulen + 1 + plen) return EC_GENERAL_FAILURE;\n\tchar user[256], pass[256];\n\tmemcpy(user, buf+2, ulen);\n\tmemcpy(pass, buf+2+ulen+1, plen);\n\tuser[ulen] = 0;\n\tpass[plen] = 0;\n\tif(!strcmp(user, auth_user) && !strcmp(pass, auth_pass)) return EC_SUCCESS;\n\treturn EC_NOT_ALLOWED;\n}\n\nstatic int handshake(struct thread *t) {\n\tunsigned char buf[1024];\n\tssize_t n;\n\tint ret;\n\tenum authmethod am;\n\tt->state = SS_1_CONNECTED;\n\twhile((n = recv(t->client.fd, buf, sizeof buf, 0)) > 0) {\n\t\tswitch(t->state) {\n\t\t\tcase SS_1_CONNECTED:\n\t\t\t\tam = check_auth_method(buf, n, &t->client);\n\t\t\t\tif(am == AM_NO_AUTH) t->state = SS_3_AUTHED;\n\t\t\t\telse if (am == AM_USERNAME) t->state = SS_2_NEED_AUTH;\n\t\t\t\tsend_auth_response(t->client.fd, 5, am);\n\t\t\t\tif(am == AM_INVALID) return -1;\n\t\t\t\tbreak;\n\t\t\tcase SS_2_NEED_AUTH:\n\t\t\t\tret = check_credentials(buf, n);\n\t\t\t\tsend_auth_response(t->client.fd, 1, ret);\n\t\t\t\tif(ret != EC_SUCCESS)\n\t\t\t\t\treturn -1;\n\t\t\t\tt->state = SS_3_AUTHED;\n\t\t\t\tif(auth_ips && !pthread_rwlock_wrlock(&auth_ips_lock)) {\n\t\t\t\t\tif(!is_in_authed_list(&t->client.addr))\n\t\t\t\t\t\tadd_auth_ip(&t->client.addr);\n\t\t\t\t\tpthread_rwlock_unlock(&auth_ips_lock);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SS_3_AUTHED:\n\t\t\t\tret = connect_socks_target(buf, n, &t->client);\n\t\t\t\tif(ret < 0) {\n\t\t\t\t\tsend_error(t->client.fd, ret*-1);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tsend_error(t->client.fd, EC_SUCCESS);\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void* clientthread(void *data) {\n\tstruct thread *t = data;\n\tint remotefd = handshake(t);\n\tif(remotefd != -1) {\n\t\tcopyloop(t->client.fd, remotefd);\n\t\tclose(remotefd);\n\t}\n\tclose(t->client.fd);\n\tt->done = 1;\n\treturn 0;\n}\n\nstatic void collect(sblist *threads) {\n\tsize_t i;\n\tfor(i=0;i<sblist_getsize(threads);) {\n\t\tstruct thread* thread = *((struct thread**)sblist_get(threads, i));\n\t\tif(thread->done) {\n\t\t\tpthread_join(thread->pt, 0);\n\t\t\tsblist_delete(threads, i);\n\t\t\tfree(thread);\n\t\t} else\n\t\t\ti++;\n\t}\n}\n\nstatic int usage(void) {\n\tdprintf(2,\n\t\t\"MicroSocks SOCKS5 Server\\n\"\n\t\t\"------------------------\\n\"\n\t\t\"usage: microsocks -1 -q -i listenip -p port -u user -P pass -b bindaddr -w ips\\n\"\n\t\t\"all arguments are optional.\\n\"\n\t\t\"by default listenip is 0.0.0.0 and port 1080.\\n\\n\"\n\t\t\"option -q disables logging.\\n\"\n\t\t\"option -b specifies which ip outgoing connections are bound to\\n\"\n\t\t\"option -w allows to specify a comma-separated whitelist of ip addresses,\\n\"\n\t\t\" that may use the proxy without user/pass authentication.\\n\"\n\t\t\" e.g. -w 127.0.0.1,192.168.1.1.1,::1 or just -w 10.0.0.1\\n\"\n\t\t\" to allow access ONLY to those ips, choose an impossible to guess user/pw combo.\\n\"\n\t\t\"option -1 activates auth_once mode: once a specific ip address\\n\"\n\t\t\" authed successfully with user/pass, it is added to a whitelist\\n\"\n\t\t\" and may use the proxy without auth.\\n\"\n\t\t\" this is handy for programs like firefox that don't support\\n\"\n\t\t\" user/pass auth. for it to work you'd basically make one connection\\n\"\n\t\t\" with another program that supports it, and then you can use firefox too.\\n\"\n\t);\n\treturn 1;\n}\n\n/* prevent username and password from showing up in top. */\nstatic void zero_arg(char *s) {\n\tsize_t i, l = strlen(s);\n\tfor(i=0;i<l;i++) s[i] = 0;\n}\n\nint main(int argc, char** argv) {\n\tint ch;\n\tconst char *listenip = \"0.0.0.0\";\n\tchar *p, *q;\n\tunsigned port = 1080;\n\twhile((ch = getopt(argc, argv, \":1qb:i:p:u:P:w:\")) != -1) {\n\t\tswitch(ch) {\n\t\t\tcase 'w': /* fall-through */\n\t\t\tcase '1':\n\t\t\t\tif(!auth_ips)\n\t\t\t\t\tauth_ips = sblist_new(sizeof(union sockaddr_union), 8);\n\t\t\t\tif(ch == '1') break;\n\t\t\t\tp = optarg;\n\t\t\t\twhile(1) {\n\t\t\t\t\tunion sockaddr_union ca;\n\t\t\t\t\tif((q = strchr(p, ','))) *q = 0;\n\t\t\t\t\tif(resolve_sa(p, 0, &ca)) {\n\t\t\t\t\t\tdprintf(2, \"error: failed to resolve %s\\n\", p);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tadd_auth_ip(&ca);\n\t\t\t\t\tif(q) *(q++) = ',', p = q;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tquiet = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tresolve_sa(optarg, 0, &bind_addr);\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tauth_user = strdup(optarg);\n\t\t\t\tzero_arg(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tauth_pass = strdup(optarg);\n\t\t\t\tzero_arg(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tlistenip = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tport = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase ':':\n\t\t\t\tdprintf(2, \"error: option -%c requires an operand\\n\", optopt);\n\t\t\t\t/* fall through */\n\t\t\tcase '?':\n\t\t\t\treturn usage();\n\t\t}\n\t}\n\tif((auth_user && !auth_pass) || (!auth_user && auth_pass)) {\n\t\tdprintf(2, \"error: user and pass must be used together\\n\");\n\t\treturn 1;\n\t}\n\tif(auth_ips && !auth_pass) {\n\t\tdprintf(2, \"error: -1/-w options must be used together with user/pass\\n\");\n\t\treturn 1;\n\t}\n\tsignal(SIGPIPE, SIG_IGN);\n\tstruct server s;\n\tsblist *threads = sblist_new(sizeof (struct thread*), 8);\n\tif(server_setup(&s, listenip, port)) {\n\t\tperror(\"server_setup\");\n\t\treturn 1;\n\t}\n\tserver = &s;\n\n\twhile(1) {\n\t\tcollect(threads);\n\t\tstruct client c;\n\t\tstruct thread *curr = malloc(sizeof (struct thread));\n\t\tif(!curr) goto oom;\n\t\tcurr->done = 0;\n\t\tif(server_waitclient(&s, &c)) {\n\t\t\tdolog(\"failed to accept connection\\n\");\n\t\t\tfree(curr);\n\t\t\tusleep(FAILURE_TIMEOUT);\n\t\t\tcontinue;\n\t\t}\n\t\tcurr->client = c;\n\t\tif(!sblist_add(threads, &curr)) {\n\t\t\tclose(curr->client.fd);\n\t\t\tfree(curr);\n\t\t\toom:\n\t\t\tdolog(\"rejecting connection due to OOM\\n\");\n\t\t\tusleep(FAILURE_TIMEOUT); /* prevent 100% CPU usage in OOM situation */\n\t\t\tcontinue;\n\t\t}\n\t\tpthread_attr_t *a = 0, attr;\n\t\tif(pthread_attr_init(&attr) == 0) {\n\t\t\ta = &attr;\n\t\t\tpthread_attr_setstacksize(a, THREAD_STACK_SIZE);\n\t\t}\n\t\tif(pthread_create(&curr->pt, a, clientthread, curr) != 0)\n\t\t\tdolog(\"pthread_create failed. OOM?\\n\");\n\t\tif(a) pthread_attr_destroy(&attr);\n\t}\n}\n"
        }
      ]
    }
  ]
}