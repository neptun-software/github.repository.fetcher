{
  "metadata": {
    "timestamp": 1736710195796,
    "page": 895,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vstakhov/libucl",
      "stars": 1640,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3330078125,
          "content": ".cproject\n.project\n.settings\n\n# Auto*/libtool\nMakefile\nMakefile.in\n/aclocal.m4\n/autom4te.cache/\n/config.*\n/configure\n/depcomp\n/install-sh\n/libtool\n/ltmain.sh\n/missing\n/stamp-h*\n/ar-lib\n/test-driver\n/compile\n.deps/\n.dirstamp\n.libs/\n*.l[ao]\n*~\n*.o\n\n# pkgconf\nlibucl.pc\n\n# python extension\npython/build\n\n# Default CMake build directory\n/build/\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 10.3037109375,
          "content": "CMAKE_MINIMUM_REQUIRED(VERSION 3.1.0 FATAL_ERROR)\nPROJECT(libucl C)\n\nSET(LIBUCL_VERSION_MAJOR 0)\nSET(LIBUCL_VERSION_MINOR 9)\nSET(LIBUCL_VERSION_PATCH 2)\n\nSET(LIBUCL_VERSION\n        \"${LIBUCL_VERSION_MAJOR}.${LIBUCL_VERSION_MINOR}.${LIBUCL_VERSION_PATCH}\")\n\nINCLUDE(CheckCCompilerFlag)\nINCLUDE(CheckCSourceCompiles)\nINCLUDE(FindOpenSSL)\nINCLUDE(GNUInstallDirs)\n\nOPTION(ENABLE_URL_INCLUDE  \"Enable urls in ucl includes (requires libcurl or libfetch) [default: OFF]\" OFF)\nOPTION(ENABLE_URL_SIGN  \"Enable signatures check in ucl includes (requires openssl) [default: OFF]\" OFF)\nOPTION(BUILD_SHARED_LIBS \"Build Shared Libraries [default: OFF]\" OFF)\nOPTION(ENABLE_LUA \"Enable lua support [default: OFF]\" OFF)\nOPTION(ENABLE_LUAJIT \"Enable luajit support [default: OFF]\" OFF)\nOPTION(ENABLE_UTILS \"Enable building utility binaries [default: OFF]\" OFF)\n\n# Find lua installation\nMACRO(FindLua)\n\t# Find lua libraries\n\tUNSET(LUA_INCLUDE_DIR CACHE)\n\tUNSET(LUA_LIBRARY CACHE)\n\tCMAKE_PARSE_ARGUMENTS(LUA \"\" \"VERSION_MAJOR;VERSION_MINOR;ROOT\" \"\" ${ARGN})\n\n\tIF(NOT LUA_VERSION_MAJOR OR NOT LUA_VERSION_MINOR)\n\t\tMESSAGE(FATAL_ERROR \"Invalid FindLua invocation: ${ARGN}\")\n\tENDIF()\n\n\tIF(ENABLE_LUAJIT MATCHES \"ON\")\n\t\tMESSAGE(STATUS \"Check for luajit ${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\")\n\t\tFIND_PATH(LUA_INCLUDE_DIR luajit.h\n\t\t\t\tHINTS\n\t\t\t\t\"${RSPAMD_SEARCH_PATH}\" \"${LUA_ROOT}\"\n\t\t\t\t$ENV{LUA_DIR}\n\t\t\t\tPATH_SUFFIXES \"include/luajit-2.0\"\n\t\t\t\t\"include/luajit${LUA_VERSION_MAJOR}${LUA_VERSION_MINOR}\"\n\t\t\t\t\"include/luajit${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\"include/luajit-${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\"include/luajit\"\n\t\t\t\t\"include/lua${LUA_VERSION_MAJOR}${LUA_VERSION_MINOR}\"\n\t\t\t\t\"include/lua${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\"include/lua-${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\tinclude/lua include\n\t\t\t\tPATHS ${RSPAMD_DEFAULT_INCLUDE_PATHS}\n\t\t)\n\t\tFIND_LIBRARY(LUA_LIBRARY\n\t\t\t\tNAMES luajit\n\t\t\t\t\"luajit-2.0\"\n\t\t\t\t\"luajit2.0\"\n\t\t\t\t\"luajit${LUA_VERSION_MAJOR}${LUA_VERSION_MINOR}\"\n\t\t\t\t\"luajit${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\"luajit-${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\tHINTS\n\t\t\t\t\"${RSPAMD_SEARCH_PATH}\" \"${LUA_ROOT}\"\n\t\t\t\t$ENV{LUA_DIR}\n\t\t\t\tPATH_SUFFIXES lib64 lib\n\t\t\t\tPATHS ${RSPAMD_DEFAULT_LIBRARY_PATHS}\n\t\t\t\tDOC \"Lua library\"\n\t\t)\n\n\t\tIF(NOT LUA_LIBRARY OR NOT LUA_INCLUDE_DIR)\n\t\t\tMESSAGE(STATUS \"Fallback from luajit to plain lua\")\n\t\t\tSET(ENABLE_LUAJIT \"OFF\")\n\t\t\tMESSAGE(STATUS \"Check for lua ${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\")\n\t\t\tFIND_PATH(LUA_INCLUDE_DIR lua.h\n\t\t\t\t\tHINTS\n\t\t\t\t\t\"${RSPAMD_SEARCH_PATH}\" \"${LUA_ROOT}\"\n\t\t\t\t\t$ENV{LUA_DIR}\n\t\t\t\t\tPATH_SUFFIXES \"include/lua${LUA_VERSION_MAJOR}${LUA_VERSION_MINOR}\"\n\t\t\t\t\t\"include/lua${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\t\"include/lua-${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\tinclude/lua include\n\t\t\t\t\tPATHS ${RSPAMD_DEFAULT_INCLUDE_PATHS}\n\t\t\t)\n\t\t\tFIND_LIBRARY(LUA_LIBRARY\n\t\t\t\t\tNAMES lua\n\t\t\t\t\t\"lua${LUA_VERSION_MAJOR}${LUA_VERSION_MINOR}\"\n\t\t\t\t\t\"lua${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\t\"lua-${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\tHINTS\n\t\t\t\t\t\"${RSPAMD_SEARCH_PATH}\" \"${LUA_ROOT}\"\n\t\t\t\t\t$ENV{LUA_DIR}\n\t\t\t\t\tPATH_SUFFIXES lib64 lib\n\t\t\t\t\tPATHS ${RSPAMD_DEFAULT_LIBRARY_PATHS}\n\t\t\t\t\tDOC \"Lua library\"\n\t\t\t)\n\t\tENDIF()\n\tELSE(ENABLE_LUAJIT MATCHES \"ON\")\n\t\tMESSAGE(STATUS \"Check for lua ${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\")\n\t\tFIND_PATH(LUA_INCLUDE_DIR lua.h\n\t\t\t\tHINTS\n\t\t\t\t\"${RSPAMD_SEARCH_PATH}\" \"${LUA_ROOT}\"\n\t\t\t\t$ENV{LUA_DIR}\n\t\t\t\tPATH_SUFFIXES \"include/lua${LUA_VERSION_MAJOR}${LUA_VERSION_MINOR}\"\n\t\t\t\t\"include/lua${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\"include/lua-${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\tinclude/lua include\n\t\t\t\tPATHS ${RSPAMD_DEFAULT_INCLUDE_PATHS}\n\t\t)\n\t\tFIND_LIBRARY(LUA_LIBRARY\n\t\t\t\tNAMES lua\n\t\t\t\t\"lua${LUA_VERSION_MAJOR}${LUA_VERSION_MINOR}\"\n\t\t\t\t\"lua${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\t\"lua-${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\"\n\t\t\t\tHINTS\n\t\t\t\t\"${RSPAMD_SEARCH_PATH}\" \"${LUA_ROOT}\"\n\t\t\t\t$ENV{LUA_DIR}\n\t\t\t\tPATH_SUFFIXES lib64 lib\n\t\t\t\tPATHS ${RSPAMD_DEFAULT_LIBRARY_PATHS}\n\t\t\t\tDOC \"Lua library\"\n\t\t)\n\tENDIF(ENABLE_LUAJIT MATCHES \"ON\")\n\n\tIF(LUA_LIBRARY AND LUA_INCLUDE_DIR)\n\t\tSET(LUA_FOUND 1)\n\t\tIF(NOT LUA_VERSION_MAJOR OR NOT LUA_VERSION_MINOR)\n\t\t\tSET(LUA_VERSION_MAJOR ${LUA_VERSION_MAJOR})\n\t\t\tSET(LUA_VERSION_MINOR ${LUA_VERSION_MINOR})\n\t\tENDIF(NOT LUA_VERSION_MAJOR OR NOT LUA_VERSION_MINOR)\n\t\tIF(ENABLE_LUAJIT MATCHES \"ON\")\n\t\t\tMESSAGE(STATUS \"Found luajit ${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\")\n\t\tELSE(ENABLE_LUAJIT MATCHES \"ON\")\n\t\t\tMESSAGE(STATUS \"Found lua ${LUA_VERSION_MAJOR}.${LUA_VERSION_MINOR}\")\n\t\tENDIF(ENABLE_LUAJIT MATCHES \"ON\")\n\tENDIF(LUA_LIBRARY AND LUA_INCLUDE_DIR)\nENDMACRO()\n\nIF(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tLIST(APPEND CMAKE_REQUIRED_LIBRARIES rt)\nENDIF(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\nIF(ENABLE_URL_INCLUDE MATCHES \"ON\")\n    FIND_LIBRARY(LIBFETCH_LIBRARY NAMES fetch PATHS\tPATH_SUFFIXES lib64 lib\n                      PATHS\n                          ~/Library/Frameworks\n                          /Library/Frameworks\n                          /usr/local\n                          /usr\n                          /sw\n                          /opt/local\n                          /opt/csw\n                          /opt\n                     DOC \"Path where the libfetch library can be found\")\n    IF(LIBFETCH_LIBRARY)\n    \tFIND_FILE(HAVE_FETCH_H NAMES fetch.h PATHS /usr/include\n    \t\t\t\t\t\t\t\t\t\t\t   /opt/include\n    \t\t\t\t\t\t\t\t\t\t\t   /usr/local/include\n    \t\t\t\tDOC \"Path to libfetch header\")\n    ELSE(LIBFETCH_LIBRARY)\n    \t# Try to find libcurl\n        FIND_PACKAGE(CURL)\n    \tIF(NOT CURL_FOUND)\n    \t\tMESSAGE(WARNING \"Neither libcurl nor libfetch were found, no support of URL includes in configuration\")\n    \tENDIF(NOT CURL_FOUND)\n    ENDIF(LIBFETCH_LIBRARY)\nENDIF(ENABLE_URL_INCLUDE MATCHES \"ON\")\n\nset(SYNC_BUILTINS_TEST_SOURCE [====[\nint main()\n{\n    unsigned long val;\n\n    __sync_bool_compare_and_swap(&val, 0, 1);\n    __sync_add_and_fetch(&val, 1);\n    __sync_fetch_and_add(&val, 0);\n    __sync_sub_and_fetch(&val, 1);\n\n    return 0;\n}\n]====])\n\nCHECK_C_SOURCE_COMPILES(\"${SYNC_BUILTINS_TEST_SOURCE}\" HAVE_ATOMIC_BUILTINS)\nIF(NOT HAVE_ATOMIC_BUILTINS)\n    MESSAGE(WARNING \"Libucl references could be thread-unsafe because atomic builtins are missing\")\nENDIF(NOT HAVE_ATOMIC_BUILTINS)\n\nSET(CMAKE_C_WARN_FLAGS \"\")\nCHECK_C_COMPILER_FLAG(-W SUPPORT_W)\nCHECK_C_COMPILER_FLAG(-Wno-pointer-sign SUPPORT_WPOINTER_SIGN)\nCHECK_C_COMPILER_FLAG(-Wno-unused-parameter SUPPORT_WUNUSED_PARAMETER)\nIF(SUPPORT_W)\n    SET(CMAKE_C_WARN_FLAGS \"${CMAKE_C_WARN_FLAGS} -W\")\nENDIF(SUPPORT_W)\nIF(SUPPORT_WPOINTER_SIGN)\n\tSET(CMAKE_C_WARN_FLAGS \"${CMAKE_C_WARN_FLAGS} -Wno-pointer-sign\")\nENDIF(SUPPORT_WPOINTER_SIGN)\nIF(SUPPORT_WUNUSED_PARAMETER)\n\tSET(CMAKE_C_WARN_FLAGS \"${CMAKE_C_WARN_FLAGS} -Wno-unused-parameter\")\nENDIF(SUPPORT_WUNUSED_PARAMETER)\n\nSET( CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${CMAKE_C_WARN_FLAGS}\" )\n\nIF(ENABLE_URL_SIGN MATCHES \"ON\")\n\tIF(OPENSSL_FOUND)\n\t\tSET(HAVE_OPENSSL 1)\n\t\tINCLUDE_DIRECTORIES(\"${OPENSSL_INCLUDE_DIR}\")\n\tENDIF(OPENSSL_FOUND)\nENDIF(ENABLE_URL_SIGN MATCHES \"ON\")\n\nSET(UCL_COMPILE_DEFS)\nIF(HAVE_FETCH_H)\n    LIST(APPEND UCL_COMPILE_DEFS -DHAVE_FETCH_H=1)\nENDIF(HAVE_FETCH_H)\nIF(CURL_FOUND)\n    LIST(APPEND UCL_COMPILE_DEFS -DCURL_FOUND=1)\nENDIF(CURL_FOUND)\nIF(HAVE_OPENSSL)\n    LIST(APPEND UCL_COMPILE_DEFS -DHAVE_OPENSSL=1)\nENDIF(HAVE_OPENSSL)\nIF(HAVE_ATOMIC_BUILTINS)\n    LIST(APPEND UCL_COMPILE_DEFS -DHAVE_ATOMIC_BUILTINS=1)\nENDIF(HAVE_ATOMIC_BUILTINS)\n\nSET(UCLSRC src/ucl_util.c\n\t\tsrc/ucl_parser.c\n\t\tsrc/ucl_emitter.c\n\t\tsrc/ucl_emitter_streamline.c\n\t\tsrc/ucl_emitter_utils.c\n\t\tsrc/ucl_hash.c\n\t\tsrc/ucl_schema.c\n\t\tsrc/ucl_msgpack.c\n\t\tsrc/ucl_sexp.c)\n\nSET(UCLHDR include/ucl.h\n\t\tinclude/ucl++.h)\n\nSET (LIB_TYPE STATIC)\nIF (BUILD_SHARED_LIBS)\n  SET (LIB_TYPE SHARED)\nENDIF (BUILD_SHARED_LIBS)\nADD_LIBRARY(ucl ${LIB_TYPE} ${UCLSRC})\nADD_LIBRARY(ucl::ucl ALIAS ucl)\nSET_TARGET_PROPERTIES(ucl PROPERTIES VERSION ${LIBUCL_VERSION} SOVERSION ${LIBUCL_VERSION_MAJOR})\nTARGET_INCLUDE_DIRECTORIES(ucl\n        PUBLIC\n          $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n          $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n        PRIVATE\n          ${CMAKE_CURRENT_SOURCE_DIR}/src\n          ${CMAKE_CURRENT_SOURCE_DIR}/uthash\n          ${CMAKE_CURRENT_SOURCE_DIR}/klib)\nTARGET_COMPILE_DEFINITIONS(ucl\n    PRIVATE\n    ${UCL_COMPILE_DEFS}\n)\n\nIF(ENABLE_LUA MATCHES \"ON\")\n\tIF(ENABLE_LUAJIT MATCHES \"ON\")\n\t\tFindLua(VERSION_MAJOR \"5\" VERSION_MINOR \"1\" ROOT \"${LUA_ROOT}\")\n\t\tIF(NOT LUA_FOUND)\n\t\t\tMESSAGE(FATAL_ERROR \"Lua not found, lua support is required\")\n\t\tELSE(NOT LUA_FOUND)\n\t\t\tINCLUDE_DIRECTORIES(\"${LUA_INCLUDE_DIR}\")\n\t\tENDIF(NOT LUA_FOUND)\n\tELSE(ENABLE_LUAJIT MATCHES \"ON\")\n\t\tFindLua(VERSION_MAJOR \"5\" VERSION_MINOR \"2\" ROOT \"${LUA_ROOT}\")\n\t\tIF(NOT LUA_FOUND)\n\t\t\tFindLua(VERSION_MAJOR \"5\" VERSION_MINOR \"1\" ROOT \"${LUA_ROOT}\")\n\t\tENDIF(NOT LUA_FOUND)\n\t\tIF(NOT LUA_FOUND)\n\t\t\tMESSAGE(FATAL_ERROR \"Lua not found, lua support is required\")\n\t\tELSE(NOT LUA_FOUND)\n\t\t\tINCLUDE_DIRECTORIES(\"${LUA_INCLUDE_DIR}\")\n\t\tENDIF(NOT LUA_FOUND)\n\tENDIF(ENABLE_LUAJIT MATCHES \"ON\")\n\tSET(UCL_LUA_SRC lua/lua_ucl.c)\n\tADD_LIBRARY(lua-ucl ${LIB_TYPE} ${UCL_LUA_SRC})\n\tADD_LIBRARY(ucl::lua ALIAS lua-ucl)\n\tIF(ENABLE_LUAJIT MATCHES \"ON\")\n\t\tTARGET_LINK_LIBRARIES(lua-ucl \"${LUAJIT_LIBRARY}\")\n\tELSE(ENABLE_LUAJIT MATCHES \"ON\")\n\t\tTARGET_LINK_LIBRARIES(lua-ucl \"${LUA_LIBRARY}\")\n\tENDIF(ENABLE_LUAJIT MATCHES \"ON\")\n\tTARGET_LINK_LIBRARIES(lua-ucl ucl)\n\tTARGET_INCLUDE_DIRECTORIES(lua-ucl PUBLIC include PRIVATE src uthash)\n\tSET_TARGET_PROPERTIES(lua-ucl PROPERTIES\n\t\tVERSION ${LIBUCL_VERSION}\n\t\tSOVERSION ${LIBUCL_VERSION_MAJOR}\n\t\tPUBLIC_HEADER include/lua_ucl.h)\n\tINSTALL(TARGETS lua-ucl DESTINATION ${CMAKE_INSTALL_LIBDIR}\n\t\t\tPUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\nENDIF()\n\nIF(HAVE_FETCH_H)\n    TARGET_LINK_LIBRARIES(ucl fetch)\nELSE(HAVE_FETCH_H)\n    IF(CURL_FOUND)\n        TARGET_LINK_LIBRARIES(ucl ${CURL_LIBRARIES})\n    ENDIF(CURL_FOUND)\nENDIF(HAVE_FETCH_H)\nIF(ENABLE_URL_SIGN MATCHES \"ON\")\n\tIF(OPENSSL_FOUND)\n\t\tTARGET_LINK_LIBRARIES(ucl ${OPENSSL_LIBRARIES})\n\tENDIF(OPENSSL_FOUND)\nENDIF(ENABLE_URL_SIGN MATCHES \"ON\")\n\nIF(UNIX)\n    TARGET_LINK_LIBRARIES(ucl -lm)\nENDIF(UNIX)\n\nSET_TARGET_PROPERTIES(ucl PROPERTIES\n\tPUBLIC_HEADER \"${UCLHDR}\")\n\nINSTALL(TARGETS ucl EXPORT uclConfig DESTINATION ${CMAKE_INSTALL_LIBDIR}\n\t\tPUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\nIF(ENABLE_UTILS MATCHES \"ON\")\n    ADD_SUBDIRECTORY(utils)\nENDIF()\n\ninstall(EXPORT uclConfig\n\tFILE ucl-config.cmake\n\tNAMESPACE ucl::\n\tDESTINATION \"share/ucl\"\n)\n\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.2978515625,
          "content": "Copyright (c) 2013-2014, Vsevolod Stakhov <vsevolod@highsecure.ru>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "ChangeLog.md",
          "type": "blob",
          "size": 10.1044921875,
          "content": "# Version history\n\n## Libucl 0.9.0\n\n* 803b588 Breaking: Try to fix streamline embedding\n* 9eddef0 Fix: set p to endptr before checking\n* 25d3f51 Fix broken tests\n* ac644e2 Update makefile.yml\n* 0a5739e Create makefile.yml\n* 987389a Merge branch 'master' into vstakhov-gh-actions\n* 7433904 Import lua code from Rspamd\n* 3912614 Create cmake-multi-platform.yml\n* 3a04c92 lua: Push string with len\n* 2fefed6 Use `_WIN32` instead of `_MSC_VER`\n* aecf17e Avoid build failure trying to create setup.py link if it already exists.\n* 4ef9e6d Add inttypes.h for PRId64\n* dcb43f0 Fix excessive escaping when using ucl_object_fromstring()\n\n## Libucl 0.5\n\n- Streamline emitter has been added, so it is now possible to output partial `ucl` objects\n- Emitter now is more flexible due to emitter_context structure\n\n### 0.5.1\n- Fixed number of bugs and memory leaks\n\n### 0.5.2\n\n- Allow userdata objects to be emitted and destructed\n- Use userdata objects to store lua function references\n\n### Libucl 0.6\n\n- Reworked macro interface\n\n### Libucl 0.6.1\n\n- Various utilities fixes\n\n### Libucl 0.7.0\n\n- Move to klib library from uthash to reduce memory overhead and increase performance\n\n### Libucl 0.7.1\n\n- Added safe iterators API\n\n### Libucl 0.7.2\n\n- Fixed serious bugs in schema and arrays iteration\n\n### Libucl 0.7.3\n\n- Fixed a bug with macros that come after an empty object\n- Fixed a bug in include processing when an incorrect variable has been destroyed (use-after-free)\n\n### Libucl 0.8.0\n\n- Allow to save comments and macros when parsing UCL documents\n- C++ API\n- Python bindings (by Eitan Adler)\n- Add msgpack support for parser and emitter\n- Add Canonical S-expressions parser for libucl\n- CLI interface for parsing and validation (by Maxim Ignatenko)\n- Implement include with priority\n- Add 'nested' functionality to .include macro (by Allan Jude)\n- Allow searching an array of paths for includes (by Allan Jude)\n- Add new .load macro (by Allan Jude)\n- Implement .inherit macro (#100)\n- Add merge strategies\n- Add schema validation to lua API\n- Add support for external references to schema validation\n- Add coveralls integration to libucl\n- Implement tests for 80% of libucl code lines\n- Fix tonns of minor and major bugs\n- Improve documentation\n- Rework function names to the common conventions (old names are preserved for backwards compatibility)\n- Add Coverity scan integration\n- Add fuzz tests\n\n**Incompatible changes**:\n\n- `ucl_object_emit_full` now accepts additional argument `comments` that could be used to emit comments with UCL output\n\n### Libucl 0.8.1\n\n- Create ucl_parser_add_file_full() to be able to specify merge mode and parser type (by Allan Jude)\n- C++ wrapper improvements (by @ftilde)\n- C++ wrapper: add convenience method at() and lookup() (by Yonghee Kim)\n- C++ wrapper: add assignment operator to Ucl class (by Yonghee Kim)\n- C++ wrapper: support variables in parser (by Yonghee Kim)\n- C++ wrapper: refactoring C++ interface (by Yonghee Kim):\n    - use auto variables (if possible)\n    - remove dangling expressions\n    - use std::set::emplace instead of std::set::insert\n    - not use std::move in return statement; considering copy elision\n- C++ wrapper: fix compilation error and warnings (by Zhe Wang)\n- C++ wrapper: fix iteration over objects in which the first value is `false` (by Zhe Wang)\n- C++ wrapper: Macro helper functions (by Chris Meacham)\n- C++ wrapper: Changing the duplicate strategy in the C++ API (by Chris Meacham)\n- C++ wrapper: Added access functions for the size of a UCL_ARRAY (by Chris Meacham)\n- Fix caseless comparison\n- Fix include when EPERM is issued\n- Fix Windows build\n- Allow to reserve space in arrays and hashes\n- Fix bug with including of empty files\n- Move to mum_hash from xxhash\n- Fix msgpack on non-x86\n- python: Add support to Python 3 (by Denis Volpato Martins)\n- python: Add support for Python 2.6 tests (by Denis Volpato Martins)\n- python: Implement validation function and tests (by Denis Volpato Martins)\n- python: Added UCL_NULL handling and tests (by Denis Volpato Martins)\n- Fix schema validation for patternProperties with object data (by Denis Volpato Martins)\n- Remove the dependency on NBBY, add missing <strings.h> include (by Ed Schouten)\n- Allow to emit msgpack from Lua\n- Performance improvements in Lua API\n- Allow to pass opaque objects in Lua API for transparent C passthrough\n- Various bugs fixed\n- Couple of memory leaks plugged\n\n### Libucl 0.8.2\n\n* .include: also validate priority to be within range\n* Add -W into list of warnings\n* Add ability to add file preprocessors\n* Add ability to pass both the parser and userdata into a macro handler\n* Add missing tests for .gitignore\n* Add more safe guards when trying to insert objects\n* Add some documentation/example about the .priority macro\n* Add tests for single quotes\n* Added CMake compile definitions\n* Added CMake support to build utils\n* Added a fuzzer for OSS-fuzz integration\n* Added a return statement if the string is 0\n* Added default CMake \"build\" directory to gitignore\n* Added fuzzer for msgpack\n* Adding another fix\n* Adjust example.\n* Allow to test msgpack inputs\n* Another sync\n* Assume gcov absense as a non-fatal error\n* Avoid read when a chunk is ended\n* CMake: Install headers and library.\n* Check for NULL inputs in ucl_object_compare()\n* Cleanup CURL handle after use\n* Cleanup CURL handle after use\n* Convert ucl_hash_insert() from returning int to returning bool.\n* Convert ucl_hash_reserve() from returning int to bool.\n* Do not try to emit single quoted strings in json mode\n* Document single quotes\n* Document ucl_object_iter_chk_excpn().\n* Document usage of ucl_object_iter_chk_excpn().\n* Don't double-escape Lua strings\n* Excercise ucl_object_iter_chk_excpn().\n* Fix '\\v' encoding\n* Fix 68d87c362b0d7fbb45f395bfae616a28439e0bbc by setting error to 0 always. Which makes it even uglier.\n* Fix cmake public include install\n* Fix emitting of the bad unicode escapes\n* Fix format strings, add printf attribute to schema functions\n* Fix levels and objects closing\n* Fix load macro with try=true\n* Fix mismerge.\n* Fix mismerge.\n* Fix old issue with parsing numbers\n* Fix processing of the incomplete msgpack objects\n* Fix remain calculations\n* Fix remain lenght calculation that led to assertion failure\n* Fix single quotes emitting\n* Fix spelling and markup errors.\n* Fix typos: replace missmatch with mismatch\n* Fix ucl++ bug where iterators stop on a null field.\n* Fix ucl_util.c not having the prototype for ucl_hash_sort()\n* Fix variables expansion\n* Fix vertical tab handling\n* Fixed Visual Studio compilation error\n* Fixed expanding variables at runtime\n* Fixed linker error\n* Fixed ucl_tool's command line argument parsing\n* Fixing error with installing using pip from git with following command: 'pip install -e git+https://github.com/vstakhov/libucl.git/#egg=ucl\n* Forgot hash sort function\n* Improve ENOMEM handling: handle most of errors while consuructing parser, also extend iterator routines to allow capturing such exception and checking it in the higher level code using new ucl_object_iter_chk_excpn() API.\n* Mark + as unsafe which fixes export a key with + in config mode\n* Modernise the CMake build system slightly.\n* Modernize CMake file with target-based includes.\n* Pass correct pointer to var_handler\n* Port util objdump to Windows (Visual Studio)\n* Port util ucl-tool to Windows\n* Provide inline free(3) wrapper, so it's easier to plug the code into out memory usage tracking framework.\n* Provide inline free(3) wrapper, so it's easier to plug the code into out memory usage tracking framework.\n* Provide priority validation for the .priority macro\n* Put space between \"exit\" and ().\n* Put space between name of teh function and ().\n* Python build fixes\n* Read data in chunks\n* Remove leak in the test\n* Remove one more bit of unused logic\n* Remove one more stupid assertion\n* Remove unnecessary (and ignored) `const` from return types.\n* Remove unnecessary std::move from return statement.\n* Remove unused CMake logic and ad -Wno-pointer-sign.\n* Removed dependency from rspamd CMake file\n* Removed null-terminator for input data\n* Rename ENOMEM-safe version of kv_xxx macros from kv_xxx into kv_xxx_safe and put back old version as well (with a big warning in the header file) for a compat purposes.\n* Renamed util binaries to match autotools\n* Replace *neat* and *tidy* implementation of kv_xxx() macros using error handling labels with a much *uglier* implementation using \"error code pointer\". One man's \"ugly\" is other man's \"pretty\", I suppose.\n* Replaced spaces by tabs to match coding style\n* Rework hash table structure to provide pointers and order safety\n* Save chunk in the parser stack\n* Save filename in chunk\n* Split level and flags, add obrace flag, fix msgpack flags\n* Squelch incompatible pointer type warning\n* Support single quoted strings\n* Suppress the [-Wunused-parameter] warning.\n* Sync changes from Rspamd\n* Sync changes from rspamd\n* Sync with Rspamd\n* Understand nan and inf\n* Use safe iterator - avoid leaking memory.\n* docs: fix simple typo, tectual -> textual\n* fix: Changed OpenSSL check inside configure.am\n* fix: Incorrect pointer arithmetics in ucl_expand_single_variable\n* fix: ucl_expand_single_variable doesn't call free\n* lua: Return early when init fails\n* make use of the undocumented flag UCL_PARSER_NO_IMPLICIT_ARRAYS, so that multiple keys are treated as arrays, and special code doesn't have to be added to the Python module to handle it.\n* mypy/stubgen: add typeinterfaces for ucl python module\n* o `ucl_object_iterate2()` -> `ucl_object_iterate_with_error()`;\n* python: update package to 0.8.1\n* `ucl_check_variable`: fix out_len on unterminated variable\n* `ucl_chunk_skipc`: avoid out-of-bounds read\n* `ucl_expand_single_variable`: better bounds check\n* `ucl_expand_variable`: fix out-of-bounds read\n* `ucl_inherit_handler`: fix format string for non-null-terminated strings\n* `ucl_lc_cmp` is not used outside ucl_hash.c\n* `ucl_lex_json_string`: fix out-of-bounds read\n* `ucl_maybe_parse_number`: if there is trailing content, it is not a number\n* `ucl_object_copy_internal`: null terminate keys\n* `ucl_object_copy_internal`: use memcpy instead of strdup\n* `ucl_object_free` is deprecated\n* `ucl_parse_value`: fix out-of-bounds read\n* `ucl_strnstr`: fix out-of-bounds read\n* update JSON example to match w/ UCL example\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 2.8212890625,
          "content": "ACLOCAL_AMFLAGS = -I m4\nEXTRA_DIST = uthash klib README.md\n\npkgconfigdir = $(libdir)/pkgconfig\npkgconfig_DATA = libucl.pc\n\nif LUA_SUB\n  LUA_SUBDIR = lua\nendif\n\nCOVERAGE_INFO_FILE = $(top_builddir)/coverage.info\nCOVERAGE_REPORT_DIR = $(top_builddir)/coverage\n\n.PHONY = coverage-requirement-check clean-coverage-report\n\ncoverage-requirement-check:\n\t@if test ! -e $(GCOV); then \\\n\t\techo \"Cannot find $(GCOV). Please install gcov.\"; \\\n\t\texit 1; \\\n\tfi\n\ncoverage: coverage-requirement-check clean-coverage coverage-build coverage-check coverage-report\n\t@echo \"Please execute 'make clean' before 'make' or 'make check' to remove instrumented object files(compiled with -O0 etc.). Note that 'make clean' also remove coverage data.\"\n\ncoverage-build: coverage-requirement-check\n\t@if test `find $(top_builddir) -name \"*.gcno\" | wc -l` -eq 0; then \\\n\t\techo \"Start to remove old non-instrumented object files...\"; \\\n\t\t$(MAKE) $(AM_MAKEFLAGS) clean; \\\n\t\techo \"Successfully removed old non-instrumented object files.\"; \\\n\tfi\n\t@echo \"Start to build libraries with coverage options...\"\n\t$(MAKE) $(AM_MAKEFLAGS) \\\n\t\tCFLAGS=\"$(CFLAGS) $(COVERAGE_CFLAGS) $(COVERAGE_OPTFLAGS)\" \\\n\t\tCXXFLAGS=\"$(CXXFLAGS) $(COVERAGE_CXXFLAGS) $(COVERAGE_OPTFLAGS)\" \\\n\t\tLDFLAGS=\"$(LDFLAGS) $(COVERAGE_LDFLAGS)\" \\\n\t\tLIBS=\"$(LIBS) $(COVERAGE_LIBS)\"\n\t@echo \"Successfully built libraries with coverage options.\"\n\ncoverage-check: coverage-requirement-check\n\t@echo \"Start to run tests with instrumented libraries...\"\n\t$(MAKE) $(AM_MAKEFLAGS) check \\\n\t\tCFLAGS=\"$(CFLAGS) $(COVERAGE_CFLAGS) $(COVERAGE_OPTFLAGS)\" \\\n\t\tCXXFLAGS=\"$(CXXFLAGS) $(COVERAGE_CXXFLAGS) $(COVERAGE_OPTFLAGS)\" \\\n\t\tLDFLAGS=\"$(LDFLAGS) $(COVERAGE_LDFLAGS)\" \\\n\t\tLIBS=\"$(LIBS) $(COVERAGE_LIBS)\"\n\t@echo \"Successfully run tests with instrumented libraries.\"\n\ncoverage-lcov: coverage-check coverage-requirement-check\n\t$(LCOV) --capture \\\n\t\t--directory \"$(top_builddir)/\" \\\n\t\t--output-file $(COVERAGE_INFO_FILE) \\\n\t\t--gcov-tool $(GCOV) \\\n\t\t--compat-libtool --checksum\n\t$(LCOV) --extract $(COVERAGE_INFO_FILE) `pwd`/src/ucl_\\* \\\n\t\t--output-file $(COVERAGE_INFO_FILE)\n\ncoverage-report: coverage-lcov\n\t@echo \"Start to create coverage reports...\"\n\t$(GENHTML) --prefix \"$(top_srcdir)\" \\\n\t\t--output-directory $(COVERAGE_REPORT_DIR) \\\n\t\t--title $(PACKAGE_NAME) \\\n\t\t--legend --show-details \\\n\t\t$(GENHTML_OPTIONS) \\\n\t\t$(COVERAGE_INFO_FILE)\n\t@echo \"Successfully created coverage reports into $(COVERAGE_REPORT_DIR) directory.\"\n\nclean-coverage-report:\n\t-rm -rf $(COVERAGE_INFO_FILE)\n\t-rm -rf $(COVERAGE_REPORT_DIR)\n\nclean-coverage: clean-coverage-report\n\t-$(LCOV) --gcov-tool $(GCOV) --zerocounters --directory $(top_builddir) || true\n\t@if xargs --version 2>/dev/null; then \\\n\t\tfind $(top_builddir) -name \"*.gcno\" | xargs --no-run-if-empty rm; \\\n\telse \\\n\t\tfind $(top_builddir) -name \"*.gcno\" | xargs rm; \\\n\tfi\n\nclean-local: clean-coverage\n\nSUBDIRS = src tests utils doc $(LUA_SUBDIR)\n"
        },
        {
          "name": "Makefile.unix",
          "type": "blob",
          "size": 4.1103515625,
          "content": "CC ?= gcc\nDESTDIR ?= /usr/local\nLD ?= gcc\nC_COMMON_FLAGS ?= -fPIC -Wall -W -Wno-unused-parameter -Wno-pointer-sign -I./include -I./uthash -I./src -I./klib\nMAJOR_VERSION = 0\nMINOR_VERSION = 9\nPATCH_VERSION = 2\nVERSION = \"$(MAJOR_VERSION).$(MINOR_VERSION).$(PATCH_VERSION)\"\nSONAME = libucl.so\nSONAME_FULL = $(SONAME).$(MAJOR_VERSION)\nOBJDIR ?= .obj\nTESTDIR ?= tests\nSRCDIR ?= src\nINCLUDEDIR ?= include\nMKDIR ?= mkdir\nINSTALL ?= install\nRM ?= rm\nRMDIR ?= rmdir\nLN ?= ln\nLD_SHARED_FLAGS ?= -Wl,-soname,$(SONAME) -shared -lm\nLD_UCL_FLAGS ?= -L$(OBJDIR) -Wl,-rpath,$(OBJDIR) -lucl\nLD_ADD ?= -lrt\nCOPT_FLAGS ?= -O2\nHDEPS = $(SRCDIR)/ucl_hash.h \\\n\t\t$(SRCDIR)/ucl_chartable.h \\\n\t\t$(SRCDIR)/ucl_internal.h \\\n\t\t$(INCLUDEDIR)/ucl.h \\\n\t\t$(SRCDIR)/mum.h\nOBJECTS = $(OBJDIR)/ucl_hash.o \\\n\t\t$(OBJDIR)/ucl_util.o \\\n\t\t$(OBJDIR)/ucl_parser.o \\\n\t\t$(OBJDIR)/ucl_emitter.o \\\n\t\t$(OBJDIR)/ucl_schema.o\n\nall: $(OBJDIR) $(OBJDIR)/$(SONAME)\n\n$(OBJDIR)/$(SONAME): $(OBJDIR)/$(SONAME_FULL)\n\t$(LN) -sf $(SONAME_FULL) $(OBJDIR)/$(SONAME)\n\n$(OBJDIR)/$(SONAME_FULL): $(OBJECTS)\n\t$(CC) -o $(OBJDIR)/$(SONAME_FULL) $(OBJECTS) $(LD_SHARED_FLAGS) $(LDFLAGS) $(SSL_LIBS) $(FETCH_LIBS)\n\n$(OBJDIR):\n\t@$(MKDIR) -p $(OBJDIR)\n\n# Compile rules\n$(OBJDIR)/ucl_util.o: $(SRCDIR)/ucl_util.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_util.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_util.c\n$(OBJDIR)/ucl_parser.o: $(SRCDIR)/ucl_parser.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_parser.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_parser.c\n$(OBJDIR)/ucl_emitter.o: $(SRCDIR)/ucl_emitter.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_emitter.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_emitter.c\n$(OBJDIR)/ucl_hash.o: $(SRCDIR)/ucl_hash.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_hash.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_hash.c\n$(OBJDIR)/ucl_schema.o: $(SRCDIR)/ucl_schema.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_schema.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_schema.c\n\nclean:\n\t$(RM) $(OBJDIR)/*.o $(OBJDIR)/$(SONAME_FULL) $(OBJDIR)/$(SONAME) $(OBJDIR)/chargen $(OBJDIR)/test_basic $(OBJDIR)/test_speed $(OBJDIR)/objdump $(OBJDIR)/test_generate $(OBJDIR)/test_schema || true\n\t$(RMDIR) $(OBJDIR)\n\t\n# Utils\n\nchargen: utils/chargen.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/chargen $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) utils/chargen.c\nobjdump: utils/objdump.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/objdump $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) utils/objdump.c $(LD_UCL_FLAGS)\n\n# Tests\n\ntest: $(OBJDIR) $(OBJDIR)/$(SONAME) $(OBJDIR)/test_basic $(OBJDIR)/test_speed $(OBJDIR)/test_generate $(OBJDIR)/test_schema\n\nrun-test: test\n\tTEST_DIR=$(TESTDIR) $(TESTDIR)/run_tests.sh $(OBJDIR)/test_basic $(OBJDIR)/test_speed $(OBJDIR)/test_generate $(OBJDIR)/test_schema\n\t\n$(OBJDIR)/test_basic: $(TESTDIR)/test_basic.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/test_basic $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) $(TESTDIR)/test_basic.c $(LD_UCL_FLAGS)\n$(OBJDIR)/test_schema: $(TESTDIR)/test_schema.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/test_schema $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) $(TESTDIR)/test_schema.c $(LD_UCL_FLAGS)\n$(OBJDIR)/test_speed: $(TESTDIR)/test_speed.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/test_speed $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) $(TESTDIR)/test_speed.c $(LD_UCL_FLAGS) $(LD_ADD)\n$(OBJDIR)/test_generate: $(TESTDIR)/test_generate.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/test_generate $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) $(TESTDIR)/test_generate.c $(LD_UCL_FLAGS) $(LD_ADD)\n\ninstall: $(OBJDIR)/$(SONAME)\n\t$(INSTALL) -m0755 $(SONAME) $(DESTDIR)/lib/$(SONAME)\n\t$(INSTALL) -m0644 include/ucl.h $(DESTDIR)/include/ucl.h\n\n.PHONY: clean $(OBJDIR)\n"
        },
        {
          "name": "Makefile.w32",
          "type": "blob",
          "size": 4.1328125,
          "content": "CC ?= gcc\nDESTDIR ?= /usr/local\nLD ?= gcc\nC_COMMON_FLAGS ?= -fPIC -Wall -W -Wno-unused-parameter -Wno-pointer-sign -I./include -I./uthash -I./src\nMAJOR_VERSION = 0\nMINOR_VERSION = 2\nPATCH_VERSION = 9\nVERSION = \"$(MAJOR_VERSION).$(MINOR_VERSION).$(PATCH_VERSION)\"\nSONAME = libucl.dll\nOBJDIR ?= .obj\nTESTDIR ?= tests\nSRCDIR ?= src\nINCLUDEDIR ?= include\nMKDIR ?= mkdir\nINSTALL ?= install\nRM ?= rm\nRMDIR ?= rmdir\nifeq (Windows_NT, $(OS))\nLN ?= ln\nelse\nLN ?= rem ln\nendif\nLD_SHARED_FLAGS ?= -Wl,-soname,$(SONAME) -shared -lm\nLD_UCL_FLAGS ?= -L$(OBJDIR) -Wl,-rpath,$(OBJDIR) -lucl\nLD_ADD ?= -lrt\nCOPT_FLAGS ?= -O2\nHDEPS = $(SRCDIR)/ucl_hash.h \\\n\t\t$(SRCDIR)/ucl_chartable.h \\\n\t\t$(SRCDIR)/ucl_internal.h \\\n\t\t$(INCLUDEDIR)/ucl.h \\\n\t\t$(SRCDIR)/mum.h\nOBJECTS = $(OBJDIR)/ucl_hash.o \\\n\t\t$(OBJDIR)/ucl_util.o \\\n\t\t$(OBJDIR)/ucl_parser.o \\\n\t\t$(OBJDIR)/ucl_emitter.o \\\n\t\t$(OBJDIR)/ucl_emitter_utils.o \\\n\t\t$(OBJDIR)/ucl_schema.o\n\nall: $(OBJDIR) $(OBJDIR)/$(SONAME)\n\n$(OBJDIR)/$(SONAME): $(OBJECTS)\n\t$(CC) -o $(OBJDIR)/$(SONAME) $(OBJECTS) $(LD_SHARED_FLAGS) $(LDFLAGS) $(SSL_LIBS) $(FETCH_LIBS)\n\n$(OBJDIR):\n\t@$(MKDIR) -p $(OBJDIR)\n\n# Compile rules\n$(OBJDIR)/ucl_util.o: $(SRCDIR)/ucl_util.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_util.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_util.c\n$(OBJDIR)/ucl_parser.o: $(SRCDIR)/ucl_parser.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_parser.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_parser.c\n$(OBJDIR)/ucl_emitter.o: $(SRCDIR)/ucl_emitter.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_emitter.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_emitter.c\n$(OBJDIR)/ucl_emitter_utils.o: $(SRCDIR)/ucl_emitter_utils.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_emitter_utils.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_emitter_utils.c\n$(OBJDIR)/ucl_hash.o: $(SRCDIR)/ucl_hash.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_hash.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_hash.c\n$(OBJDIR)/ucl_schema.o: $(SRCDIR)/ucl_schema.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/ucl_schema.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/ucl_schema.c\n$(OBJDIR)/xxhash.o: $(SRCDIR)/xxhash.c $(HDEPS)\n\t$(CC) -o $(OBJDIR)/xxhash.o $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) -c $(SRCDIR)/xxhash.c\n\nclean:\n\t$(RM) $(OBJDIR)/*.o $(OBJDIR)/$(SONAME) $(OBJDIR)/$(SONAME) $(OBJDIR)/chargen $(OBJDIR)/test_basic $(OBJDIR)/test_speed $(OBJDIR)/objdump $(OBJDIR)/test_generate\n\t$(RMDIR) $(OBJDIR)\n\n# Utils\n\nchargen: utils/chargen.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/chargen $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) utils/chargen.c\nobjdump: utils/objdump.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/objdump $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) utils/objdump.c $(LD_UCL_FLAGS)\n\n# Tests\n\ntest: $(OBJDIR) $(OBJDIR)/$(SONAME) $(OBJDIR)/test_basic $(OBJDIR)/test_speed $(OBJDIR)/test_generate\n\nrun-test: test\n\tTEST_DIR=$(TESTDIR) $(TESTDIR)/run_tests.sh $(OBJDIR)/test_basic $(OBJDIR)/test_speed $(OBJDIR)/test_generate\n\n$(OBJDIR)/test_basic: $(TESTDIR)/test_basic.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/test_basic $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) $(TESTDIR)/test_basic.c $(LD_UCL_FLAGS)\n$(OBJDIR)/test_speed: $(TESTDIR)/test_speed.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/test_speed $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) $(TESTDIR)/test_speed.c $(LD_UCL_FLAGS) $(LD_ADD)\n$(OBJDIR)/test_generate: $(TESTDIR)/test_generate.c $(OBJDIR)/$(SONAME)\n\t$(CC) -o $(OBJDIR)/test_generate $(CPPFLAGS) $(COPT_FLAGS) $(CFLAGS) $(C_COMMON_FLAGS) $(SSL_CFLAGS) $(FETCH_FLAGS) $(LDFLAGS) $(TESTDIR)/test_generate.c $(LD_UCL_FLAGS) $(LD_ADD)\n\ninstall: $(OBJDIR)/$(SONAME)\n\t$(INSTALL) -m0755 $(SONAME) $(DESTDIR)/lib/$(SONAME)\n\t$(INSTALL) -m0644 include/ucl.h $(DESTDIR)/include/ucl.h\n\n.PHONY: clean $(OBJDIR)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.505859375,
          "content": "# UCL - Universal Configuration Language\n\n**Table of Contents**  *generated with [DocToc](http://doctoc.herokuapp.com/)*\n\n- [Introduction](#introduction)\n- [Basic structure](#basic-structure)\n- [Improvements to the json notation](#improvements-to-the-json-notation)\n\t- [General syntax sugar](#general-syntax-sugar)\n\t- [Automatic arrays creation](#automatic-arrays-creation)\n\t- [Named keys hierarchy](#named-keys-hierarchy)\n\t- [Convenient numbers and booleans](#convenient-numbers-and-booleans)\n- [General improvements](#general-improvements)\n\t- [Comments](#comments)\n\t- [Macros support](#macros-support)\n\t- [Variables support](#variables-support)\n\t- [Multiline strings](#multiline-strings)\n\t- [Single quoted strings](#single-quoted-strings)\n- [Emitter](#emitter)\n- [Validation](#validation)\n- [Performance](#performance)\n- [Conclusion](#conclusion)\n\n## Introduction\n\nThis repository provides the `C` library for parsing configurations written in `UCL` - universal configuration language. It also provides functions to operate with other formats:\n\n* `JSON`: read, write and pretty format\n* `Messagepack`: read and write\n* `S-Expressions`: read only (canonical form)\n* `Yaml`: limited write support (mainly for compatibility)\n\nIf you are looking for the libucl API documentation you can find it at [this page](doc/api.md).\n\n## Basic structure\n\n`UCL` is heavily infused by `nginx` configuration as the example of a convenient configuration\nsystem. However, `UCL` is fully compatible with `JSON` format and is able to parse json files.\nFor example, you can write the same configuration in the following ways:\n\n* in nginx like:\n\n```nginx\nparam = value;\nsection {\n    param = value;\n    param1 = value1;\n    flag = true;\n    number = 10k;\n    time = 0.2s;\n    string = \"something\";\n    subsection {\n        host = {\n            host = \"hostname\";\n            port = 900;\n        }\n        host = {\n            host = \"hostname\";\n            port = 901;\n        }\n    }\n}\n```\n\n* or in JSON:\n\n```json\n{\n    \"param\": \"value\",\n    \"section\": {\n        \"param\": \"value\",\n        \"param1\": \"value1\",\n        \"flag\": true,\n        \"number\": 10000,\n        \"time\": \"0.2s\",\n        \"string\": \"something\",\n        \"subsection\": {\n            \"host\": [\n                {\n                    \"host\": \"hostname\",\n                    \"port\": 900\n                },\n                {\n                    \"host\": \"hostname\",\n                    \"port\": 901\n                }\n            ]\n        }\n    }\n}\n```\n\n## Improvements to the json notation.\n\nThere are various things that make ucl configuration more convenient for editing than strict json:\n\n### General syntax sugar\n\n* Braces are not necessary to enclose a top object: it is automatically treated as an object:\n\n```json\n\"key\": \"value\"\n```\nis equal to:\n```json\n{\"key\": \"value\"}\n```\n\n* There is no requirement of quotes for strings and keys, moreover, `:` may be replaced `=` or even be skipped for objects:\n\n```nginx\nkey = value;\nsection {\n    key = value;\n}\n```\nis equal to:\n```json\n{\n    \"key\": \"value\",\n    \"section\": {\n        \"key\": \"value\"\n    }\n}\n```\n\n* No commas mess: you can safely place a comma or semicolon for the last element in an array or an object:\n\n```json\n{\n    \"key1\": \"value\",\n    \"key2\": \"value\",\n}\n```\n### Automatic arrays creation\n\n* Non-unique keys in an object are allowed and are automatically converted to the arrays internally:\n\n```json\n{\n    \"key\": \"value1\",\n    \"key\": \"value2\"\n}\n```\nis converted to:\n```json\n{\n    \"key\": [\"value1\", \"value2\"]\n}\n```\n\n### Named keys hierarchy\n\nUCL accepts named keys and organize them into objects hierarchy internally. Here is an example of this process:\n```nginx\nsection \"blah\" {\n\tkey = value;\n}\nsection foo {\n\tkey = value;\n}\n```\n\nis converted to the following object:\n\n```nginx\nsection {\n\tblah {\n\t\tkey = value;\n\t}\n\tfoo {\n\t\tkey = value;\n\t}\n}\n```\n\nPlain definitions may be more complex and contain more than a single level of nested objects:\n\n```nginx\nsection \"blah\" \"foo\" {\n\tkey = value;\n}\n```\n\nis presented as:\n\n```nginx\nsection {\n\tblah {\n\t\tfoo {\n\t\t\tkey = value;\n\t\t}\n\t}\n}\n```\n\n### Convenient numbers and booleans\n\n* Numbers can have suffixes to specify standard multipliers:\n    + `[kKmMgG]` - standard 10 base multipliers (so `1k` is translated to 1000)\n    + `[kKmMgG]b` - 2 power multipliers (so `1kb` is translated to 1024)\n    + `[s|min|d|w|y]` - time multipliers, all time values are translated to float number of seconds, for example `10min` is translated to 600.0 and `10ms` is translated to 0.01\n* Hexadecimal integers can be used by `0x` prefix, for example `key = 0xff`. However, floating point values can use decimal base only.\n* Booleans can be specified as `true` or `yes` or `on` and `false` or `no` or `off`.\n* It is still possible to treat numbers and booleans as strings by enclosing them in double quotes.\n\n## General improvements\n\n### Comments\n\nUCL supports different style of comments:\n\n* single line: `#`\n* multiline: `/* ... */`\n\nMultiline comments may be nested:\n```c\n# Sample single line comment\n/*\n some comment\n /* nested comment */\n end of comment\n*/\n```\n\n### Macros support\n\nUCL supports external macros both multiline and single line ones:\n```nginx\n.macro_name \"sometext\";\n.macro_name {\n    Some long text\n    ....\n};\n```\n\nMoreover, each macro can accept an optional list of arguments in braces. These\narguments themselves are the `UCL` object that is parsed and passed to a macro as\noptions:\n\n```nginx\n.macro_name(param=value) \"something\";\n.macro_name(param={key=value}) \"something\";\n.macro_name(.include \"params.conf\") \"something\";\n.macro_name(#this is multiline macro\nparam = [value1, value2]) \"something\";\n.macro_name(key=\"()\") \"something\";\n```\n\nUCL also provide a convenient `include` macro to load content from another files\nto the current UCL object. This macro accepts either path to file:\n\n```nginx\n.include \"/full/path.conf\"\n.include \"./relative/path.conf\"\n.include \"${CURDIR}/path.conf\"\n```\n\nor URL (if ucl is built with url support provided by either `libcurl` or `libfetch`):\n\n\t.include \"http://example.com/file.conf\"\n\n`.include` macro supports a set of options:\n\n* `try` (default: **false**) - if this option is `true` than UCL treats errors on loading of\nthis file as non-fatal. For example, such a file can be absent but it won't stop the parsing\nof the top-level document.\n* `sign` (default: **false**) - if this option is `true` UCL loads and checks the signature for\na file from path named `<FILEPATH>.sig`. Trusted public keys should be provided for UCL API after\nparser is created but before any configurations are parsed.\n* `glob` (default: **false**) - if this option is `true` UCL treats the filename as GLOB pattern and load\nall files that matches the specified pattern (normally the format of patterns is defined in `glob` manual page\nfor your operating system). This option is meaningless for URL includes.\n* `url` (default: **true**) - allow URL includes.\n* `path` (default: empty) - A UCL_ARRAY of directories to search for the include file.\nSearch ends after the first match, unless `glob` is true, then all matches are included.\n* `prefix` (default false) - Put included contents inside an object, instead\nof loading them into the root. If no `key` is provided, one is automatically generated based on each files basename()\n* `key` (default: <empty string>) - Key to load contents of include into. If\nthe key already exists, it must be the correct type\n* `target` (default: object) - Specify if the `prefix` `key` should be an\nobject or an array.\n* `priority` (default: 0) - specify priority for the include (see below).\n* `duplicate` (default: 'append') - specify policy of duplicates resolving:\n\t- `append` - default strategy, if we have new object of higher priority then it replaces old one, if we have new object with less priority it is ignored completely, and if we have two duplicate objects with the same priority then we have a multi-value key (implicit array)\n\t- `merge` - if we have object or array, then new keys are merged inside, if we have a plain object then an implicit array is formed (regardless of priorities)\n\t- `error` - create error on duplicate keys and stop parsing\n\t- `rewrite` - always rewrite an old value with new one (ignoring priorities)\n\nPriorities are used by UCL parser to manage the policy of objects rewriting during including other files\nas following:\n\n* If we have two objects with the same priority then we form an implicit array\n* If a new object has bigger priority then we overwrite an old one\n* If a new object has lower priority then we ignore it\n\nBy default, the priority of top-level object is set to zero (lowest priority). Currently,\nyou can define up to 16 priorities (from 0 to 15). Includes with bigger priorities will\nrewrite keys from the objects with lower priorities as specified by the policy. The priority\nof the top-level or any other object can be changed with the `.priority` macro, which has no\noptions and takes the new priority:\n\n```\n# Default priority: 0.\nfoo = 6\n.priority 5\n# The following will have priority 5.\nbar = 6\nbaz = 7\n# The following will be included with a priority of 3, 5, and 6 respectively.\n.include(priority=3) \"path.conf\"\n.include(priority=5) \"equivalent-path.conf\"\n.include(priority=6) \"highpriority-path.conf\"\n```\n\n### Variables support\n\nUCL supports variables in input. Variables are registered by a user of the UCL parser and can be presented in the following forms:\n\n* `${VARIABLE}`\n* `$VARIABLE`\n\nUCL currently does not support nested variables. To escape variables one could use double dollar signs:\n\n* `$${VARIABLE}` is converted to `${VARIABLE}`\n* `$$VARIABLE` is converted to `$VARIABLE`\n\nHowever, if no valid variables are found in a string, no expansion will be performed (and `$$` thus remains unchanged). This may be a subject\nto change in future libucl releases.\n\n### Multiline strings\n\nUCL can handle multiline strings as well as single line ones. It uses shell/perl like notation for such objects:\n```\nkey = <<EOD\nsome text\nsplitted to\nlines\nEOD\n```\n\nIn this example `key` will be interpreted as the following string: `some text\\nsplitted to\\nlines`.\nHere are some rules for this syntax:\n\n* Multiline terminator must start just after `<<` symbols and it must consist of capital letters only (e.g. `<<eof` or `<< EOF` won't work);\n* Terminator must end with a single newline character (and no spaces are allowed between terminator and newline character);\n* To finish multiline string you need to include a terminator string just after newline and followed by a newline (no spaces or other characters are allowed as well);\n* The initial and the final newlines are not inserted to the resulting string, but you can still specify newlines at the beginning and at the end of a value, for example:\n\n```\nkey <<EOD\n\nsome\ntext\n\nEOD\n```\n\n### Single quoted strings\n\nIt is possible to use single quoted strings to simplify escaping rules. All values passed in single quoted strings are *NOT* escaped, with two exceptions: a single `'` character just before `\\` character, and a newline character just after `\\` character that is ignored.\n\n```\nkey = 'value'; # Read as value\nkey = 'value\\n\\'; # Read as  value\\n\\\nkey = 'value\\''; # Read as value'\nkey = 'value\\\nbla'; # Read as valuebla\n```\n\n## Emitter\n\nEach UCL object can be serialized to one of the four supported formats:\n\n* `JSON` - canonic json notation (with spaces indented structure);\n* `Compacted JSON` - compact json notation (without spaces or newlines);\n* `Configuration` - nginx like notation;\n* `YAML` - yaml inlined notation;\n* `messagepack` - MessagePack binary format.\n\n## Validation\n\nUCL allows validation of objects. It uses the same schema that is used for json: [json schema v4](http://json-schema.org). UCL supports the full set of json schema with the exception of remote references. This feature is unlikely useful for configuration objects. Of course, a schema definition can be in UCL format instead of JSON that simplifies schemas writing. Moreover, since UCL supports multiple values for keys in an object it is possible to specify generic integer constraints `maxValues` and `minValues` to define the limits of values count in a single key. UCL currently is not absolutely strict about validation schemas themselves, therefore UCL users should supply valid schemas (as it is defined in json-schema draft v4) to ensure that the input objects are validated properly.\n\n## Performance\n\nAre UCL parser and emitter fast enough? Well, there are some numbers.\nI got a 19Mb file that consist of ~700 thousand lines of json (obtained via\nhttp://www.json-generator.com/). Then I checked jansson library that performs json\nparsing and emitting and compared it with UCL. Here are results:\n\n```\njansson: parsed json in 1.3899 seconds\njansson: emitted object in 0.2609 seconds\n\nucl: parsed input in 0.6649 seconds\nucl: emitted config in 0.2423 seconds\nucl: emitted json in 0.2329 seconds\nucl: emitted compact json in 0.1811 seconds\nucl: emitted yaml in 0.2489 seconds\n```\n\nSo far, UCL seems to be significantly faster than jansson on parsing and slightly faster on emitting. Moreover,\nUCL compiled with optimizations (-O3) performs significantly faster:\n```\nucl: parsed input in 0.3002 seconds\nucl: emitted config in 0.1174 seconds\nucl: emitted json in 0.1174 seconds\nucl: emitted compact json in 0.0991 seconds\nucl: emitted yaml in 0.1354 seconds\n```\n\nYou can do your own benchmarks by running `make check` in libucl top directory.\n\n## Conclusion\n\nUCL has clear design that should be very convenient for reading and writing. At the same time it is compatible with\nJSON language and therefore can be used as a simple JSON parser. Macro logic provides an ability to extend configuration\nlanguage (for example by including some lua code) and comments allow to disable or enable the parts of a configuration\nquickly.\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.0234375,
          "content": "#!/bin/sh\nautoreconf -i\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 5.5908203125,
          "content": "m4_define([maj_ver], [0])\nm4_define([med_ver], [9])\nm4_define([min_ver], [2])\nm4_define([so_version], [9:0:2])\nm4_define([ucl_version], [maj_ver.med_ver.min_ver])\n\nAC_INIT([libucl],[ucl_version],[https://github.com/vstakhov/libucl],[libucl])\nAC_CONFIG_SRCDIR([configure.ac])\nAM_INIT_AUTOMAKE([1.11 foreign -Wall -Wportability no-dist-gzip dist-xz])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nUCL_VERSION=ucl_version\nSO_VERSION=so_version\n\nAC_SUBST(UCL_VERSION)\nAC_SUBST(SO_VERSION)\n\nAC_PROG_CC_C99\nAM_PROG_CC_C_O\nAM_PROG_AR\nLT_INIT\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_HEADERS([config.h])\n\nAC_C_CONST\nAC_TYPE_SIZE_T\n\nAC_CHECK_HEADERS_ONCE([fcntl.h unistd.h])\nAC_TYPE_OFF_T\nAC_FUNC_MMAP\nAC_CHECK_HEADERS_ONCE([fcntl.h])\nAC_CHECK_HEADERS_ONCE([sys/types.h])\nAC_CHECK_HEADERS_ONCE([sys/stat.h])\nAC_CHECK_HEADERS_ONCE([sys/param.h])\nAC_CHECK_HEADERS_ONCE([sys/mman.h])\nAC_CHECK_HEADERS_ONCE([stdlib.h])\nAC_CHECK_HEADERS_ONCE([stddef.h])\nAC_CHECK_HEADERS_ONCE([stdarg.h])\nAC_CHECK_HEADERS_ONCE([stdbool.h])\nAC_CHECK_HEADERS_ONCE([stdint.h])\nAC_CHECK_HEADERS_ONCE([string.h])\nAC_CHECK_HEADERS_ONCE([strings.h])\nAC_CHECK_HEADERS_ONCE([unistd.h])\nAC_CHECK_HEADERS_ONCE([ctype.h])\nAC_CHECK_HEADERS_ONCE([errno.h])\nAC_CHECK_HEADERS_ONCE([limits.h])\nAC_CHECK_HEADERS_ONCE([libgen.h])\nAC_CHECK_HEADERS_ONCE([stdio.h])\nAC_CHECK_HEADERS_ONCE([float.h])\nAC_CHECK_HEADERS_ONCE([math.h])\nAC_CHECK_HEADERS_ONCE([endian.h sys/endian.h machine/endian.h])\n\ndnl Example of default-disabled feature\nAC_ARG_ENABLE([urls], AS_HELP_STRING([--enable-urls], \n\t[Enable URLs fetch (requires libfetch or libcurl) @<:@default=no@:>@]), [],\n\t[enable_urls=no])\nAC_ARG_ENABLE([regex], AS_HELP_STRING([--enable-regex], \n\t[Enable regex checking for schema @<:@default=yes@:>@]), [],\n\t[enable_regex=yes])\nAC_ARG_ENABLE([signatures], AS_HELP_STRING([--enable-signatures],\n\t[Enable signatures check (requires openssl) @<:@default=no@:>@]), [],\n\t[enable_signatures=no])\nAC_ARG_ENABLE([lua], AS_HELP_STRING([--enable-lua],\n\t[Enable lua API build (requires lua libraries and headers) @<:@default=no@:>@]), [],\n\t[enable_lua=no])\nAC_ARG_ENABLE([utils],\n\tAS_HELP_STRING([--enable-utils], [Build and install utils @<:@default=no@:>@]),\n\t[case \"${enableval}\" in\n  \t\tyes) utils=true ;;\n  \t\tno)  utils=false ;;\n  \t\t*) AC_MSG_ERROR([bad value ${enableval} for --enable-utils]) ;;\n\tesac],[utils=false])\nAM_CONDITIONAL([UTILS], [test x$utils = xtrue])\n\nAS_IF([test \"x$enable_signatures\" = \"xyes\"], [\n\tAC_SEARCH_LIBS([CRYPTO_new_ex_data], [crypto], [\n\t\tAC_DEFINE(HAVE_OPENSSL, 1, [Define to 1 if you have the 'crypto' library (-lcrypto).])\n\t\tLIBCRYPTO_LIB=\"-lcrypto\"\n\t\tLIBS_EXTRA=\"${LIBS_EXTRA} -lcrypto\"\n\t\t], [AC_MSG_ERROR([unable to find the CRYPTO_new_ex_data() function])])\n])\nAC_SUBST(LIBCRYPTO_LIB)\nAC_PATH_PROG(PANDOC, pandoc, [/non/existent])\n\nAC_SEARCH_LIBS([clock_gettime], [rt], [], [\n\tAC_CHECK_HEADER([mach/mach_time.h], [\n\t\tAC_DEFINE(HAVE_MACH_MACH_TIME_H, 1, [Define to 1 on Darwin])\n\t], [AC_MSG_ERROR([unable to find clock_gettime or mach_absolute_time])])\n])\nAC_SEARCH_LIBS([remainder], [m], [], [AC_MSG_ERROR([unable to find remainder() function])])\n\nAS_IF([test \"x$enable_regex\" = \"xyes\"], [\n\tAC_CHECK_HEADER([regex.h], [\n\t\tAC_DEFINE(HAVE_REGEX_H, 1, [Define to 1 if you have the <regex.h> header file.])\n\t\tAC_SEARCH_LIBS([regexec], [regex], [\n\t\t\tAS_IF([test \"x$ac_cv_search_regexec\" = \"x-lregex\"], [\n\t\t\t\tLIBREGEX_LIB=\"-lregex\"\n\t\t\t\tLIBS_EXTRA=\"${LIBS_EXTRA} -lregex\"\n\t\t\t\t]\n\t\t\t)], \n\t\t\t[AC_MSG_ERROR([unable to find the regexec() function])])],\n\t\t\t[AC_MSG_ERROR([unable to find the regex.h header])\n\t\t],\n\t\t[#include <sys/types.h>])\n])\nAC_SUBST(LIBREGEX_LIB)\n\nAS_IF([test \"x$enable_lua\" = \"xyes\"], [\n\tAX_PROG_LUA([5.1], [], [\n\t\tAX_LUA_HEADERS([\n\t\t\tAX_LUA_LIBS([\n\t\t\t\tAC_DEFINE(HAVE_LUA, 1, [Define to 1 for lua support.])\n\t\t\t\twith_lua=\"yes\"\n\t\t\t], [AC_MSG_ERROR([unable to find the lua libraries])\n\t\t\t])\n\t\t], [AC_MSG_ERROR([unable to find the lua header files])\n\t\t])\n\t], [AC_MSG_ERROR([unable to find the lua interpreter])])\n], [with_lua=\"no\"])\n\nAM_CONDITIONAL([LUA_SUB], [test \"$with_lua\" = \"yes\"])\n\nAS_IF([test \"x$enable_urls\" = \"xyes\"], [\n\tAC_CHECK_HEADER([fetch.h], [\n\t\tAC_DEFINE(HAVE_FETCH_H, 1, [Define to 1 if you have the <fetch.h> header file.])\n\t\tAC_CHECK_LIB(fetch, fetchXGet, [\n\t\t\tAC_DEFINE(HAVE_LIBFETCH, 1, [Define to 1 if you have the 'fetch' library (-lfetch).])\n\t\t\tLIBFETCH_LIBS=\"-lfetch\"\n\t\t\thave_libfetch=\"yes\"\n\t\t\tLIBS_EXTRA=\"${LIBS_EXTRA} -lfetch\"\n\t\t])\n\t], [],[\n\t#include <stdio.h>\n\t#ifdef HAVE_SYS_PARAM_H\n\t#include <sys/param.h>\n\t#endif\n\t])\n\tAC_SUBST(LIBFETCH_LIBS)\n\n\tAS_IF([ test \"x$have_libfetch\" != \"xyes\"], [\n\t\tdnl Fallback to libcurl\n\t\tPKG_CHECK_MODULES([CURL], [libcurl], [\n\t\t\tAC_DEFINE(CURL_FOUND, 1, [Use libcurl])\n\t\t\tLIBS_EXTRA=\"${LIBS_EXTRA} -lcurl\"],\n\t\t[AC_MSG_ERROR([unable to find neither libfetch nor libcurl])])\n\t])\n\tAC_SUBST(CURL_FOUND)\n\tAC_SUBST(CURL_LIBS)\n\tAC_SUBST(CURL_CFLAGS)\n])\n\nAC_SUBST(LIBS_EXTRA)\n\nAC_MSG_CHECKING(for GCC atomic builtins)\nAC_LINK_IFELSE([\n\tAC_LANG_SOURCE([[\n\t\tint main() {\n\t\t\tvolatile unsigned long val = 1;\n\t\t\t__sync_synchronize();\n\t\t\t__sync_val_compare_and_swap(&val, 1, 0);\n\t\t\t__sync_add_and_fetch(&val, 1);\n\t\t\t__sync_sub_and_fetch(&val, 1);\n\t\t\treturn 0;\n\t\t}\n\t]])\n],\n[\n\tAC_MSG_RESULT([yes])\n\tAC_DEFINE([HAVE_ATOMIC_BUILTINS], [1], [Has gcc/MSVC atomic intrinsics])\n],\n[\n\tAC_MSG_RESULT([no])\n\tAC_DEFINE([HAVE_ATOMIC_BUILTINS], [0], [Has gcc/MSVC atomic intrinsics])\n\tAC_MSG_WARN([Libucl references could be thread-unsafe because atomic builtins are missing])\n])\n\nAX_CODE_COVERAGE\n\nAC_CONFIG_FILES(Makefile \\\n\tsrc/Makefile \\\n\tlua/Makefile\n\ttests/Makefile \\\n\tutils/Makefile \\\n\tdoc/Makefile \\\n\tlua/libucl.rockspec \\\n\tlibucl.pc)\nAC_CONFIG_FILES([stamp-h], [echo timestamp > stamp-h])\nAC_OUTPUT\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "haskell",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "klib",
          "type": "tree",
          "content": null
        },
        {
          "name": "libucl.pc.in",
          "type": "blob",
          "size": 0.244140625,
          "content": "prefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nincludedir=@includedir@\n\nName: LibUCL\nDescription: Universal configuration library\nVersion: @UCL_VERSION@\nLibs: -L${libdir} -lucl\nLibs.private: @LIBS_EXTRA@ @LUA_LIB@\nCflags: -I${includedir}/\n"
        },
        {
          "name": "lua",
          "type": "tree",
          "content": null
        },
        {
          "name": "m4",
          "type": "tree",
          "content": null
        },
        {
          "name": "python",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "stamp-h.in",
          "type": "blob",
          "size": 0.009765625,
          "content": "timestamp\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "uthash",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}