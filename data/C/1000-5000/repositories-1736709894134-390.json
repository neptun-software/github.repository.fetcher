{
  "metadata": {
    "timestamp": 1736709894134,
    "page": 390,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "haampie/libtree",
      "stars": 2676,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0380859375,
          "content": "---\nBasedOnStyle:  LLVM\nIndentWidth: 4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "*.o\n*.so\nexe*\nlibtree\n*.swp\nMake.user\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.029296875,
          "content": "# v3.1.1\n- Build system portability fixes\n- Fix make check exit code\n\n# v3.1.0\n- Add a `--max-depth` flag to limit recursion depth. For example,\n  `libtree --max-depth 1 <file>` will show the resolved direct dependencies only.\n\n# v3.0.4\n- Build system portability fixes\n- Fix `make check` exit code\n\n# v3.0.3\n- `libtree -vvvv...` is now treated as `libtree -vvv`.\n\n# v3.0.2\n- Improve `make check`, `make clean` and CI\n- Preserve original timestamps when installing files\n- Add rpath order test\n\n# v3.0.1\n- Fix man pages directory in `make install`\n- Skip dynamic linker on aarch64 and powerpc\n\n# v3.0.0\n- Rewritten in C99 with 0 external dependencies.\n- Significantly faster & smaller (~50KB statically compiled with musl libc, or\n  even smaller than the source file with diet libc).\n- Cross-compiled binaries now available thanks to\n  [binarybuilder.org](https://binarybuilder.org/)\n- Improved search path printing when libraries cannot be located.\n- Improved rpath search: shows `[rpath of ...]` when lib is located by parent\n  of parent ... of parent's rpath.\n- `fd` inspired highlight of filename when printing paths.\n- Caches files by inode instead of soname, which is useful in the sense that\n  this allows you to find broken libraries that only work because of a\n  particular search order of the tree. (Consider an executable A and libraries\n  B, C and D, where A depends on B and C, and B and C depend on D:\n  \n  ```\n    B\n   / \\\n  A   D\n   \\ /\n    C\n  ```\n\n  It may happen that D *can* be located through B's rpath, but not through C's.\n  Then, depending on whether A - B - D is traversed first, or A - C - D, ld.so\n  will complain about missing libraries or not. `libtree` on the other hand\n  will always tell you that D can't be located through C.\n- More verbosity levels `-v`, `-vv`, `-vvv` instead of `-a` and `-v` flags.\n- Skip fewer libraries by default (only libc / libstdc++ type of libs).\n- `PLATFORM` rpath interpolation now uses `uname`, this is not always the same\n  as `AT_PLATFORM`, but unlikely to be different, and in fact the feature is\n  rarely used.\n- Support for `NODEFLIB` flag, which is a dynamic array entry flag that signals\n  to the dynamic linker that it should not search default system paths\n  including those specified in `ld.so.conf`.\n- Better FreeBSD support (`OSREL`, `OSNAME` interpolation in rpaths and\n  `/etc/ld-elf.so.conf` config file support)\n- Support for relative includes in `ld.so.conf` config files.\n\nBreaking changes:\n- The bundling feature was dropped in `3.0.0`, but is still supported in `2.x`.\n  It may return in a future `3.x` release, but my impression is that there are\n  excellent tools like Exodus which do a better job at bundling (in particular:\n  they ship a copy of the dynamic linker.)\n- The `--skip` and `--platform` flags were removed.\n\n# v2.0.0\n\n- No changes to the libtree API\n- Provide static executables for ease of use on distros with an old glibc or\n  musl.\n- Dropped the dependency on `cppglob`, use posix `glob` instead.\n- No more vendored dependencies, rely on `find_package` to find `cxxopts`,\n  `elfio`, and `termcolor`.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2020 Harmen Stoppels\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.8583984375,
          "content": "CFLAGS ?= -O2\nLIBTREE_CFLAGS = -std=c99 -Wall -Wextra -Wshadow -pedantic\nLIBTREE_DEFINES = -D_FILE_OFFSET_BITS=64\n\n# uppercase variables for backwards compatibility only:\nPREFIX = /usr/local\n\nprefix = $(PREFIX)\nexec_prefix = $(prefix)\nbindir = $(exec_prefix)/bin\ndatarootdir = $(prefix)/share\nmandir = $(datarootdir)/man\n\n.PHONY: all check install clean\n\nall: libtree\n\n.c.o:\n\t$(CC) $(CFLAGS) $(LIBTREE_CFLAGS) $(LIBTREE_DEFINES) -c $<\n\nlibtree-objs = libtree.o\nlibtree: $(libtree-objs)\n\t$(CC) $(LDFLAGS) -o $@ $(libtree-objs)\n\ninstall: all\n\tmkdir -p $(DESTDIR)$(bindir)\n\tcp -p libtree $(DESTDIR)$(bindir)\n\tmkdir -p $(DESTDIR)$(mandir)/man1\n\tcp -p doc/libtree.1 $(DESTDIR)$(mandir)/man1\n\ncheck:: libtree\n\nclean::\n\trm -f *.o libtree\n\nclean check::\n\tfind tests -mindepth 1 -maxdepth 1 -type d | while read -r dir; do \\\n\t\t$(MAKE) -C \"$$dir\" $@ || exit 1 ;\\\n\tdone\n\n-include Make.user\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.4013671875,
          "content": "# libtree\n\nA tool that:\n- :deciduous_tree: turns `ldd` into a tree\n- :point_up: explains how shared libraries are found or why they cannot be located\n\n![Screenshot of libtree](doc/screenshot.png)\n\n\n## Output\n\nBy default, certain standard dependencies are not shown. For more verbose output use\n\n-  `libtree -v`             Show libraries skipped by default\n-  `libtree -vv`            Show dependencies of libraries skipped by default\n-  `libtree -vvv`           Show dependencies of already encountered libraries\n\nUse the `--path` or `-p` flags to show paths rather than sonames:\n\n- `libtree -p $(which tar)`\n\nUse `--max-depth` to limit the recursion depth.\n\n\n## Install\n\n- [Prebuilt binaries for **v3.1.1**](https://github.com/haampie/libtree/releases/tag/v3.1.1)\n  | arch    | sha256sum |\n  |---------|-----------|\n  | [aarch64 (linux)](https://github.com/haampie/libtree/releases/download/v3.1.1/libtree_aarch64) | `c5d4fbcd4e3fb46f02c028532f60fcf1c92f7c6aad5b07a991c67550c2554862` |\n  | [armv6l (linux)](https://github.com/haampie/libtree/releases/download/v3.1.1/libtree_armv6l) | `16f5a7503a095bd88ebc5e21ec4ba8337c5d9712cac355bf89399c9e6beef661` |\n  | [armv7l (linux)](https://github.com/haampie/libtree/releases/download/v3.1.1/libtree_armv7l) | `17f493621e7cc651e2bddef207c1554a64a114e1c907dbe5b79ff0e97180b29e` |\n  | [i686 (linux)](https://github.com/haampie/libtree/releases/download/v3.1.1/libtree_i686) | `230a163c20f4a88a983d8647a9aa793317be6556e2c6a79e8a6295389e651ef5` |\n  | [x86_64 (linux)](https://github.com/haampie/libtree/releases/download/v3.1.1/libtree_x86_64) | `49218482f89648972ea4ef38cf986e85268efd1ce8f27fe14b23124bca009e6f` |\n- Fedora / RHEL / CentOS\n  ```console\n  $ dnf install epel-release # For RHEL and derivatives enable EPEL first \n  $ dnf install libtree-ldd\n  ```\n- Ubuntu 22.04+\n  ```console\n  apt-get install libtree\n  ```\n\n- [GNU Guix](https://guix.gnu.org/)\n  ```console\n  guix install libtree\n  ```\n\n- [Older release **v2.0.0**](https://github.com/haampie/libtree/releases/tag/v2.0.0)\n\n\n## Building from sources\n\n`libtree` requires a C compiler that understands c99\n\n```\ngit clone https://github.com/haampie/libtree.git\ncd libtree\nmake # recommended: LDFLAGS=-static\n```\n\n<details>\n<summary>Or use the following unsafe quick install instructions</summary>\n\n```\ncurl -Lfs https://raw.githubusercontent.com/haampie/libtree/master/libtree.c | ${CC:-cc} -o libtree -x c - -std=c99 -D_FILE_OFFSET_BITS=64\n```\n</details>\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "libtree.c",
          "type": "blob",
          "size": 55.431640625,
          "content": "#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <ctype.h>\n#include <glob.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n\n#define VERSION \"3.2.0-dev\"\n\n#define ET_EXEC 2\n#define ET_DYN 3\n\n#define PT_NULL 0\n#define PT_LOAD 1\n#define PT_DYNAMIC 2\n\n#define DT_NULL 0\n#define DT_NEEDED 1\n#define DT_STRTAB 5\n#define DT_SONAME 14\n#define DT_RPATH 15\n#define DT_RUNPATH 29\n\n#define BITS32 1\n#define BITS64 2\n\n#define ERR_INVALID_MAGIC 11\n#define ERR_INVALID_CLASS 12\n#define ERR_INVALID_DATA 13\n#define ERR_INVALID_HEADER 14\n#define ERR_INVALID_BITS 15\n#define ERR_INVALID_ENDIANNESS 16\n#define ERR_NO_EXEC_OR_DYN 17\n#define ERR_INVALID_PHOFF 18\n#define ERR_INVALID_PROG_HEADER 19\n#define ERR_CANT_STAT 20\n#define ERR_INVALID_DYNAMIC_SECTION 21\n#define ERR_INVALID_DYNAMIC_ARRAY_ENTRY 22\n#define ERR_NO_STRTAB 23\n#define ERR_INVALID_SONAME 24\n#define ERR_INVALID_RPATH 25\n#define ERR_INVALID_RUNPATH 26\n#define ERR_INVALID_NEEDED 27\n#define ERR_DEPENDENCY_NOT_FOUND 28\n#define ERR_NO_PT_LOAD 29\n#define ERR_VADDRS_NOT_ORDERED 30\n#define ERR_COULD_NOT_OPEN_FILE 31\n#define ERR_INCOMPATIBLE_ISA 32\n\n#define DT_FLAGS_1 0x6ffffffb\n#define DT_1_NODEFLIB 0x800\n\n#define MAX_OFFSET_T 0xFFFFFFFFFFFFFFFF\n\n#define REGULAR_RED \"\\033[0;31m\"\n#define BOLD_RED \"\\033[1;31m\"\n#define CLEAR \"\\033[0m\"\n#define BOLD_YELLOW \"\\033[33m\"\n#define BOLD_CYAN \"\\033[1;36m\"\n#define REGULAR_CYAN \"\\033[0;36m\"\n#define REGULAR_MAGENTA \"\\033[0;35m\"\n#define REGULAR_BLUE \"\\033[0;34m\"\n#define BRIGHT_BLACK \"\\033[0;90m\"\n#define REGULAR \"\\033[0m\"\n\n// don't judge me.\n#define LIGHT_HORIZONTAL \"\\xe2\\x94\\x80\"\n#define LIGHT_QUADRUPLE_DASH_VERTICAL \"\\xe2\\x94\\x8a\"\n#define LIGHT_UP_AND_RIGHT \"\\xe2\\x94\\x94\"\n#define LIGHT_VERTICAL \"\\xe2\\x94\\x82\"\n#define LIGHT_VERTICAL_AND_RIGHT \"\\xe2\\x94\\x9c\"\n\n#define JUST_INDENT \"    \"\n#define LIGHT_VERTICAL_WITH_INDENT LIGHT_VERTICAL \"   \"\n\n#define SMALL_VEC_SIZE 16\n#define MAX_RECURSION_DEPTH 32\n#define MAX_PATH_LENGTH 4096\n\n// Libraries we do not show by default -- this reduces the verbosity quite a\n// bit.\nchar const *exclude_list[] = {\"ld-linux-aarch64.so\",\n                              \"ld-linux-armhf.so\",\n                              \"ld-linux-x86-64.so\",\n                              \"ld-linux.so\",\n                              \"ld64.so\",\n                              \"libc.musl-aarch64.so\",\n                              \"libc.musl-armhf.so\",\n                              \"libc.musl-i386.so\",\n                              \"libc.musl-x86_64.so\",\n                              \"libc.so\",\n                              \"libdl.so\",\n                              \"libgcc_s.so\",\n                              \"libm.so\",\n                              \"libstdc++.so\"};\n\nstruct header_64_t {\n    uint16_t e_type;\n    uint16_t e_machine;\n    uint32_t e_version;\n    uint64_t e_entry;\n    uint64_t e_phoff;\n    uint64_t e_shoff;\n    uint32_t e_flags;\n    uint16_t e_ehsize;\n    uint16_t e_phentsize;\n    uint16_t e_phnum;\n    uint16_t e_shentsize;\n    uint16_t e_shnum;\n    uint16_t e_shstrndx;\n};\n\nstruct header_32_t {\n    uint16_t e_type;\n    uint16_t e_machine;\n    uint32_t e_version;\n    uint32_t e_entry;\n    uint32_t e_phoff;\n    uint32_t e_shoff;\n    uint32_t e_flags;\n    uint16_t e_ehsize;\n    uint16_t e_phentsize;\n    uint16_t e_phnum;\n    uint16_t e_shentsize;\n    uint16_t e_shnum;\n    uint16_t e_shstrndx;\n};\n\nstruct prog_64_t {\n    uint32_t p_type;\n    uint32_t p_flags;\n    uint64_t p_offset;\n    uint64_t p_vaddr;\n    uint64_t p_paddr;\n    uint64_t p_filesz;\n    uint64_t p_memsz;\n    uint64_t p_align;\n};\n\nstruct prog_32_t {\n    uint32_t p_type;\n    uint32_t p_offset;\n    uint32_t p_vaddr;\n    uint32_t p_paddr;\n    uint32_t p_filesz;\n    uint32_t p_memsz;\n    uint32_t p_flags;\n    uint32_t p_align;\n};\n\nstruct dyn_64_t {\n    int64_t d_tag;\n    uint64_t d_val;\n};\n\nstruct dyn_32_t {\n    int32_t d_tag;\n    uint32_t d_val;\n};\n\nstruct compat_t {\n    char any; // 1 iff we don't look for libs matching a certain architecture\n    uint8_t class;    // 32 or 64 bits?\n    uint16_t machine; // instruction set\n};\n\ntypedef enum {\n    INPUT,\n    DIRECT,\n    RPATH,\n    LD_LIBRARY_PATH,\n    RUNPATH,\n    LD_SO_CONF,\n    DEFAULT\n} how_t;\n\nstruct found_t {\n    how_t how;\n    // only set when found by in the rpath NOT of the direct parent.  so, when\n    // it is found in a \"special\" way only rpaths allow, which is worth\n    // informing the user about.\n    size_t depth;\n};\n\n// large buffer in which to copy rpaths, needed libraries and sonames.\nstruct string_table_t {\n    char *arr;\n    size_t n;\n    size_t capacity;\n};\n\nstruct visited_file_t {\n    dev_t st_dev;\n    ino_t st_ino;\n};\n\nstruct visited_file_array_t {\n    struct visited_file_t *arr;\n    size_t n;\n    size_t capacity;\n};\n\nstruct libtree_state_t {\n    int verbosity;\n    int path;\n    int color;\n    char *ld_conf_file;\n    unsigned long max_depth;\n\n    struct string_table_t string_table;\n    struct visited_file_array_t visited;\n\n    // rpath substitutions values (note: OSNAME/OSREL are FreeBSD specific, LIB\n    // is glibc/Linux specific -- we substitute all so we can support\n    // cross-compiled binaries).\n    char *PLATFORM;\n    char *LIB;\n    char *OSNAME;\n    char *OSREL;\n\n    // rpath stack: if lib_a needs lib_b needs lib_c and all have rpaths\n    // then first lib_c's rpaths are considered, then lib_b's, then lib_a's.\n    // so this data structure keeps a list of offsets into the string buffer\n    // where rpaths start, like [lib_a_rpath_offset, lib_b_rpath_offset,\n    // lib_c_rpath_offset]...\n    size_t rpath_offsets[MAX_RECURSION_DEPTH];\n    size_t ld_library_path_offset;\n    size_t default_paths_offset;\n    size_t ld_so_conf_offset;\n\n    // This is so we know we have to print a | or white space\n    // in the tree\n    char found_all_needed[MAX_RECURSION_DEPTH];\n};\n\n// Keep track of the files we've see\n\n/**\n * small_vec_u64 is an array that lives on the stack until it grows to the heap\n */\nstruct small_vec_u64_t {\n    uint64_t buf[SMALL_VEC_SIZE];\n    uint64_t *p;\n    size_t n;\n    size_t capacity;\n};\n\nstatic inline void utoa(char *str, size_t v) {\n    char *p = str;\n    do {\n        *p++ = '0' + (v % 10);\n        v /= 10;\n    } while (v > 0);\n    size_t len = p - str;\n    for (size_t i = 0; i < len / 2; i++) {\n        char tmp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = tmp;\n    }\n    str[len] = '\\0';\n}\n\nstatic inline void small_vec_u64_init(struct small_vec_u64_t *v) {\n    memset(v, 0, sizeof(*v));\n    v->p = v->buf;\n}\n\nstatic void small_vec_u64_append(struct small_vec_u64_t *v, uint64_t val) {\n    // The hopefully likely path\n    if (v->n < SMALL_VEC_SIZE) {\n        v->p[v->n++] = val;\n        return;\n    }\n\n    // The slow fallback on the heap\n    if (v->n == SMALL_VEC_SIZE) {\n        v->capacity = 2 * SMALL_VEC_SIZE;\n        v->p = malloc(v->capacity * sizeof(uint64_t));\n        if (v->p == NULL)\n            exit(1);\n        memcpy(v->p, v->buf, SMALL_VEC_SIZE * sizeof(uint64_t));\n    } else if (v->n == v->capacity) {\n        v->capacity *= 2;\n        uint64_t *p = realloc(v->p, v->capacity * sizeof(uint64_t));\n        if (p == NULL)\n            exit(1);\n        v->p = p;\n    }\n\n    v->p[v->n++] = val;\n}\n\nstatic void small_vec_u64_free(struct small_vec_u64_t *v) {\n    if (v->n <= SMALL_VEC_SIZE)\n        return;\n    free(v->p);\n    v->p = NULL;\n}\n\n/**\n * end of small_vec_u64_t\n */\n\nstatic inline int host_is_little_endian() {\n    int test = 1;\n    char *bytes = (char *)&test;\n    return bytes[0] == 1;\n}\n\nstatic int is_ascending_order(uint64_t *v, size_t n) {\n    for (size_t j = 1; j < n; ++j)\n        if (v[j - 1] >= v[j])\n            return 0;\n\n    return 1;\n}\n\nstatic void string_table_maybe_grow(struct string_table_t *t, size_t n) {\n    // The likely case of not having to resize\n    if (t->n + n <= t->capacity)\n        return;\n\n    // Otherwise give twice the amount of required space.\n    t->capacity = 2 * (t->n + n);\n    char *arr = realloc(t->arr, t->capacity * sizeof(char));\n    if (arr == NULL) {\n        exit(1);\n    }\n    t->arr = arr;\n}\n\nstatic void string_table_store(struct string_table_t *t, char const *str) {\n    size_t n = strlen(str) + 1;\n    string_table_maybe_grow(t, n);\n    memcpy(t->arr + t->n, str, n);\n    t->n += n;\n}\n\nstatic void string_table_copy_from_file(struct string_table_t *t, FILE *fptr) {\n    int c;\n    // TODO: this could be a bit more efficient...\n    while ((c = getc(fptr)) != '\\0' && c != EOF) {\n        string_table_maybe_grow(t, 1);\n        t->arr[t->n++] = c;\n    }\n    string_table_maybe_grow(t, 1);\n    t->arr[t->n++] = '\\0';\n}\n\nstatic int is_in_exclude_list(char *soname) {\n    // Get to the end.\n    char *start = soname;\n    char *end = strrchr(start, '\\0');\n\n    // Empty needed string, is that even possible?\n    if (start == end)\n        return 0;\n\n    --end;\n\n    // Strip \"1234567890.\" from the right.\n    while (end != start && ((*end >= '0' && *end <= '9') || *end == '.')) {\n        --end;\n    }\n\n    // Check if we should skip this one.\n    for (size_t j = 0; j < sizeof(exclude_list) / sizeof(char *); ++j) {\n        size_t len = strlen(exclude_list[j]);\n        if (strncmp(start, exclude_list[j], len) != 0)\n            continue;\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic void tree_preamble(struct libtree_state_t *s, size_t depth) {\n    if (depth == 0)\n        return;\n\n    for (size_t i = 0; i < depth - 1; ++i)\n        fputs(s->found_all_needed[i] ? JUST_INDENT : LIGHT_VERTICAL_WITH_INDENT,\n              stdout);\n\n    fputs(s->found_all_needed[depth - 1]\n              ? LIGHT_UP_AND_RIGHT LIGHT_HORIZONTAL LIGHT_HORIZONTAL \" \"\n              : LIGHT_VERTICAL_AND_RIGHT LIGHT_HORIZONTAL LIGHT_HORIZONTAL \" \",\n          stdout);\n}\n\nstatic int recurse(char *current_file, size_t depth,\n                   struct libtree_state_t *state, struct compat_t compat,\n                   struct found_t reason);\n\nstatic void apply_exclude_list(size_t *needed_not_found,\n                               struct small_vec_u64_t *needed_buf_offsets,\n                               struct libtree_state_t *s) {\n    for (size_t i = 0; i < *needed_not_found;) {\n        // If in exclude list, swap to the back.\n        if (is_in_exclude_list(s->string_table.arr +\n                               needed_buf_offsets->p[i])) {\n            size_t tmp = needed_buf_offsets->p[i];\n            needed_buf_offsets->p[i] =\n                needed_buf_offsets->p[*needed_not_found - 1];\n            needed_buf_offsets->p[--*needed_not_found] = tmp;\n            continue;\n        } else {\n            ++i;\n        }\n    }\n}\n\nstatic int check_absolute_paths(size_t *needed_not_found,\n                                struct small_vec_u64_t *needed_buf_offsets,\n                                size_t depth, struct libtree_state_t *s,\n                                struct compat_t compat) {\n    int exit_code = 0;\n    // First go over absolute paths in needed libs.\n    for (size_t i = 0; i < *needed_not_found;) {\n        struct string_table_t const *st = &s->string_table;\n\n        // Skip dt_needed that have do not contain /\n        if (strchr(st->arr + needed_buf_offsets->p[i], '/') == NULL) {\n            ++i;\n            continue;\n        }\n\n        // Copy the path over.\n        char path[MAX_PATH_LENGTH];\n        size_t len = strlen(st->arr + needed_buf_offsets->p[i]);\n\n        // Unlikely to happen but good to guard against\n        if (len >= MAX_PATH_LENGTH)\n            continue;\n\n        // Include \\0\n        memcpy(path, st->arr + needed_buf_offsets->p[i], len + 1);\n\n        s->found_all_needed[depth] = *needed_not_found <= 1;\n        char *err = NULL;\n\n        // If it is not an absolute path, we bail, cause it then starts to\n        // depend on the current working directory, which is rather\n        // nonsensical. This is allowed by glibc though.\n        if (path[0] != '/') {\n            err = \" is not absolute\";\n            exit_code = ERR_DEPENDENCY_NOT_FOUND;\n        } else {\n            int code = recurse(path, depth + 1, s, compat,\n                               (struct found_t){.how = DIRECT});\n            if (code == ERR_DEPENDENCY_NOT_FOUND)\n                exit_code = ERR_DEPENDENCY_NOT_FOUND;\n\n            // Check if there was an issue with the direct dep and ignore errors\n            // of transient deps.\n            if (code != 0 && code != ERR_DEPENDENCY_NOT_FOUND) {\n                err = \" not found\";\n            }\n        }\n\n        if (err) {\n            tree_preamble(s, depth + 1);\n            if (s->color)\n                fputs(BOLD_RED, stdout);\n            fputs(path, stdout);\n            fputs(\" is not absolute\", stdout);\n            fputs(s->color ? CLEAR \"\\n\" : \"\\n\", stdout);\n        }\n\n        // Handled this library, so swap to the back.\n        size_t tmp = needed_buf_offsets->p[i];\n        needed_buf_offsets->p[i] = needed_buf_offsets->p[*needed_not_found - 1];\n        needed_buf_offsets->p[--*needed_not_found] = tmp;\n    }\n\n    return exit_code;\n}\n\nstatic int check_search_paths(struct found_t reason, size_t offset,\n                              size_t *needed_not_found,\n                              struct small_vec_u64_t *needed_buf_offsets,\n                              size_t depth, struct libtree_state_t *s,\n                              struct compat_t compat) {\n    int exit_code = 0;\n    char path[MAX_PATH_LENGTH];\n    char *path_end = path + MAX_PATH_LENGTH;\n\n    struct string_table_t const *st = &s->string_table;\n\n    while (st->arr[offset] != '\\0') {\n        // First remove trailing colons\n        while (st->arr[offset] == ':' && st->arr[offset] != '\\0')\n            ++offset;\n\n        // Check if it was only colons\n        if (st->arr[offset] == '\\0')\n            return exit_code;\n\n        // Copy the search path until the first \\0 or :\n        char *dest = path;\n        while (st->arr[offset] != '\\0' && st->arr[offset] != ':' &&\n               dest != path_end)\n            *dest++ = st->arr[offset++];\n\n        // Path too long... Can't handle.\n        if (dest + 1 >= path_end)\n            continue;\n\n        // Add a separator if necessary\n        if (*(dest - 1) != '/')\n            *dest++ = '/';\n\n        // Keep track of the end of the current search path.\n        char *search_path_end = dest;\n\n        // Try to open it -- if we've found anything, swap it with the back.\n        for (size_t i = 0; i < *needed_not_found;) {\n            size_t soname_len = strlen(st->arr + needed_buf_offsets->p[i]);\n\n            // Path too long, can't handle.\n            if (search_path_end + soname_len + 1 >= path_end)\n                continue;\n\n            // Otherwise append.\n            memcpy(search_path_end, st->arr + needed_buf_offsets->p[i],\n                   soname_len + 1);\n            s->found_all_needed[depth] = *needed_not_found <= 1;\n\n            // And try to locate the lib.\n            int code = recurse(path, depth + 1, s, compat, reason);\n            if (code == ERR_DEPENDENCY_NOT_FOUND)\n                exit_code = ERR_DEPENDENCY_NOT_FOUND;\n            if (code == 0 || code == ERR_DEPENDENCY_NOT_FOUND) {\n                // Found at least the direct dependency, so swap out the current\n                // soname to the back and reduce the number of to be found by\n                // one.\n                size_t tmp = needed_buf_offsets->p[i];\n                needed_buf_offsets->p[i] =\n                    needed_buf_offsets->p[*needed_not_found - 1];\n                needed_buf_offsets->p[--(*needed_not_found)] = tmp;\n            } else {\n                ++i;\n            }\n        }\n    }\n\n    return exit_code;\n}\n\nstatic int interpolate_variables(struct libtree_state_t *s, size_t src,\n                                 char const *ORIGIN) {\n    // We do not write to dst if there is no variables to interpolate.\n    size_t prev_src = src;\n    size_t curr_src = src;\n\n    struct string_table_t *st = &s->string_table;\n\n    while (1) {\n        // Find the next potential variable.\n        char *dollar = strchr(st->arr + curr_src, '$');\n        if (dollar == NULL)\n            break;\n        curr_src = dollar - st->arr;\n\n        size_t bytes_to_dollar = curr_src - prev_src;\n\n        // Go past the dollar.\n        ++curr_src;\n\n        // Remember if we have to look for matching curly braces.\n        int curly = 0;\n        if (st->arr[curr_src] == '{') {\n            curly = 1;\n            ++curr_src;\n        }\n\n        // String to interpolate.\n        char const *var_val = NULL;\n        if (strncmp(&st->arr[curr_src], \"ORIGIN\", 6) == 0) {\n            var_val = ORIGIN;\n            curr_src += 6;\n        } else if (strncmp(&st->arr[curr_src], \"LIB\", 3) == 0) {\n            var_val = s->LIB;\n            curr_src += 3;\n        } else if (strncmp(&st->arr[curr_src], \"PLATFORM\", 8) == 0) {\n            var_val = s->PLATFORM;\n            curr_src += 8;\n        } else if (strncmp(&st->arr[curr_src], \"OSNAME\", 6) == 0) {\n            var_val = s->OSNAME;\n            curr_src += 6;\n        } else if (strncmp(&st->arr[curr_src], \"OSREL\", 5) == 0) {\n            var_val = s->OSREL;\n            curr_src += 5;\n        } else {\n            continue;\n        }\n\n        // Require matching {...}.\n        if (curly) {\n            if (st->arr[curr_src] != '}') {\n                continue;\n            }\n            ++curr_src;\n        }\n\n        size_t var_len = strlen(var_val);\n\n        // Make sure we have enough space to write to.\n        string_table_maybe_grow(st, bytes_to_dollar + var_len);\n\n        // First copy over the string until the variable.\n        memcpy(&st->arr[s->string_table.n], &st->arr[prev_src],\n               bytes_to_dollar);\n        s->string_table.n += bytes_to_dollar;\n\n        // Then move prev_src until after the variable.\n        prev_src = curr_src;\n\n        // Then copy the variable value (without null).\n        memcpy(&st->arr[s->string_table.n], var_val, var_len);\n        s->string_table.n += var_len;\n    }\n\n    // Did we copy anything? That implies a variable was interpolated.\n    // Copy the remainder, including the \\0.\n    if (prev_src != src) {\n        size_t n = strlen(st->arr + prev_src) + 1;\n        string_table_maybe_grow(st, n);\n        // note: we're copying from within the string table, so we\n        // should not store st->arr + prev_src.\n        memcpy(st->arr + st->n, st->arr + prev_src, n);\n        st->n += n;\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic void print_colon_delimited_paths(char const *start, char const *indent) {\n    while (1) {\n        // Don't print empty string\n        if (*start == '\\0')\n            break;\n\n        // Find the next delimiter after start\n        char *next = strchr(start, ':');\n\n        // Don't print empty strings\n        if (start == next) {\n            ++start;\n            continue;\n        }\n\n        fputs(indent, stdout);\n        fputs(JUST_INDENT, stdout);\n\n        // Print up to but not including : or \\0, followed by a newline.\n        if (next == NULL) {\n            puts(start);\n        } else {\n            fwrite(start, 1, next - start, stdout);\n            putchar('\\n');\n        }\n\n        // We done yet?\n        if (next == NULL)\n            break;\n\n        // Otherwise put the : back in place and continue.\n        start = next + 1;\n    }\n}\n\nstatic void print_line(size_t depth, char *name, char *color_bold,\n                       char *color_regular, int highlight,\n                       struct found_t reason, struct libtree_state_t *s) {\n    tree_preamble(s, depth);\n    // Color the filename different than the path name, if we have a path.\n    char *slash = NULL;\n    if (s->color && highlight && (slash = strrchr(name, '/')) != NULL) {\n        fputs(color_regular, stdout);\n        fwrite(name, 1, slash + 1 - name, stdout);\n        fputs(color_bold, stdout);\n        fputs(slash + 1, stdout);\n    } else {\n        if (s->color)\n            fputs(color_bold, stdout);\n\n        fputs(name, stdout);\n    }\n    if (s->color && highlight)\n        fputs(CLEAR \" \" BOLD_YELLOW, stdout);\n    else\n        putchar(' ');\n    switch (reason.how) {\n    case RPATH:\n        if (reason.depth + 1 >= depth) {\n            fputs(\"[rpath]\", stdout);\n        } else {\n            char num[8];\n            utoa(num, reason.depth + 1);\n            fputs(\"[rpath of \", stdout);\n            fputs(num, stdout);\n            putchar(']');\n        }\n        break;\n    case LD_LIBRARY_PATH:\n        fputs(\"[LD_LIBRARY_PATH]\", stdout);\n        break;\n    case RUNPATH:\n        fputs(\"[runpath]\", stdout);\n        break;\n    case LD_SO_CONF:\n        putchar('[');\n        char *conf_name = strrchr(s->ld_conf_file, '/');\n        conf_name = conf_name == NULL ? s->ld_conf_file : conf_name + 1;\n        fputs(conf_name, stdout);\n        putchar(']');\n        break;\n    case DIRECT:\n        fputs(\"[direct]\", stdout);\n        break;\n    case DEFAULT:\n        fputs(\"[default path]\", stdout);\n        break;\n    default:\n        break;\n    }\n    if (s->color)\n        fputs(CLEAR \"\\n\", stdout);\n    else\n        putchar('\\n');\n}\n\nstatic void print_error(size_t depth, size_t needed_not_found,\n                        struct small_vec_u64_t *needed_buf_offsets,\n                        char *runpath, struct libtree_state_t *s,\n                        int no_def_lib) {\n    for (size_t i = 0; i < needed_not_found; ++i) {\n        s->found_all_needed[depth] = i + 1 >= needed_not_found;\n        tree_preamble(s, depth + 1);\n        if (s->color)\n            fputs(BOLD_RED, stdout);\n        fputs(s->string_table.arr + needed_buf_offsets->p[i], stdout);\n        fputs(\" not found\\n\", stdout);\n        if (s->color)\n            fputs(CLEAR, stdout);\n    }\n\n    // If anything was not found, we print the search paths in order they\n    // are considered.\n    char *box_vertical =\n        s->color ? JUST_INDENT REGULAR_RED LIGHT_QUADRUPLE_DASH_VERTICAL CLEAR\n                 : JUST_INDENT LIGHT_QUADRUPLE_DASH_VERTICAL;\n    char *indent = malloc(sizeof(LIGHT_VERTICAL_WITH_INDENT) * depth +\n                          strlen(box_vertical) + 1);\n    char *p = indent;\n    for (size_t i = 0; i < depth; ++i) {\n        if (s->found_all_needed[i]) {\n            int len = sizeof(JUST_INDENT) - 1;\n            memcpy(p, JUST_INDENT, len);\n            p += len;\n        } else {\n            int len = sizeof(LIGHT_VERTICAL_WITH_INDENT) - 1;\n            memcpy(p, LIGHT_VERTICAL_WITH_INDENT, len);\n            p += len;\n        }\n    }\n    // dotted | in red\n    strcpy(p, box_vertical);\n\n    fputs(indent, stdout);\n    if (s->color)\n        fputs(BRIGHT_BLACK, stdout);\n    fputs(\" Paths considered in this order:\\n\", stdout);\n    if (s->color)\n        fputs(CLEAR, stdout);\n\n    // Consider rpaths only when runpath is empty\n    fputs(indent, stdout);\n    if (runpath != NULL) {\n        if (s->color)\n            fputs(BRIGHT_BLACK, stdout);\n        fputs(\" 1. rpath is skipped because runpath was set\\n\", stdout);\n        if (s->color)\n            fputs(CLEAR, stdout);\n    } else {\n        if (s->color)\n            fputs(BRIGHT_BLACK, stdout);\n        fputs(\" 1. rpath:\\n\", stdout);\n        if (s->color)\n            fputs(CLEAR, stdout);\n        for (int j = depth; j >= 0; --j) {\n            if (s->rpath_offsets[j] != SIZE_MAX) {\n                char num[8];\n                utoa(num, j + 1);\n                fputs(indent, stdout);\n                if (s->color)\n                    fputs(BRIGHT_BLACK, stdout);\n                fputs(\"    depth \", stdout);\n                fputs(num, stdout);\n                if (s->color)\n                    fputs(CLEAR, stdout);\n                putchar('\\n');\n                print_colon_delimited_paths(\n                    s->string_table.arr + s->rpath_offsets[j], indent);\n            }\n        }\n    }\n\n    // Environment variables\n    fputs(indent, stdout);\n    if (s->color)\n        fputs(BRIGHT_BLACK, stdout);\n    fputs(s->ld_library_path_offset == SIZE_MAX\n              ? \" 2. LD_LIBRARY_PATH was not set\\n\"\n              : \" 2. LD_LIBRARY_PATH:\\n\",\n          stdout);\n    if (s->color)\n        fputs(CLEAR, stdout);\n    if (s->ld_library_path_offset != SIZE_MAX)\n        print_colon_delimited_paths(\n            s->string_table.arr + s->ld_library_path_offset, indent);\n\n    // runpath\n    fputs(indent, stdout);\n    if (s->color)\n        fputs(BRIGHT_BLACK, stdout);\n    fputs(runpath == NULL ? \" 3. runpath was not set\\n\" : \" 3. runpath:\\n\",\n          stdout);\n    if (s->color)\n        fputs(CLEAR, stdout);\n    if (runpath != NULL)\n        print_colon_delimited_paths(runpath, indent);\n\n    fputs(indent, stdout);\n    if (s->color)\n        fputs(BRIGHT_BLACK, stdout);\n    fputs(no_def_lib\n              ? \" 4. ld config files not considered due to NODEFLIB flag\\n\"\n              : \" 4. ld config files:\\n\",\n          stdout);\n    if (s->color)\n        fputs(CLEAR, stdout);\n    print_colon_delimited_paths(s->string_table.arr + s->ld_so_conf_offset,\n                                indent);\n\n    fputs(indent, stdout);\n    if (s->color)\n        fputs(BRIGHT_BLACK, stdout);\n    fputs(no_def_lib\n              ? \" 5. Standard paths not considered due to NODEFLIB flag\\n\"\n              : \" 5. Standard paths:\\n\",\n          stdout);\n    if (s->color)\n        fputs(CLEAR, stdout);\n    print_colon_delimited_paths(s->string_table.arr + s->default_paths_offset,\n                                indent);\n\n    free(indent);\n}\n\nstatic int visited_files_contains(struct visited_file_array_t *files,\n                                  struct stat *needle) {\n    for (size_t i = 0; i < files->n; ++i) {\n        struct visited_file_t *f = &files->arr[i];\n        if (f->st_dev == needle->st_dev && f->st_ino == needle->st_ino)\n            return 1;\n    }\n    return 0;\n}\n\nstatic void visited_files_append(struct visited_file_array_t *files,\n                                 struct stat *new) {\n    if (files->n == files->capacity) {\n        files->capacity *= 2;\n        files->arr = realloc(files->arr,\n                             files->capacity * sizeof(struct visited_file_t));\n        if (files->arr == NULL)\n            exit(1);\n    }\n    files->arr[files->n].st_dev = new->st_dev;\n    files->arr[files->n].st_ino = new->st_ino;\n    ++files->n;\n}\n\nstatic int recurse(char *current_file, size_t depth, struct libtree_state_t *s,\n                   struct compat_t compat, struct found_t reason) {\n    FILE *fptr = fopen(current_file, \"rb\");\n\n    if (fptr == NULL)\n        return ERR_COULD_NOT_OPEN_FILE;\n\n    // When we're done recursing, we should give back the memory we've claimed.\n    size_t old_buf_size = s->string_table.n;\n\n    // Parse the header\n    char e_ident[16];\n    if (fread(&e_ident, 16, 1, fptr) != 1) {\n        fclose(fptr);\n        return ERR_INVALID_MAGIC;\n    }\n\n    // Find magic elfs\n    if (e_ident[0] != 0x7f || e_ident[1] != 'E' || e_ident[2] != 'L' ||\n        e_ident[3] != 'F') {\n        fclose(fptr);\n        return ERR_INVALID_MAGIC;\n    }\n\n    // Do at least *some* header validation\n    if (e_ident[4] != BITS32 && e_ident[4] != BITS64) {\n        fclose(fptr);\n        return ERR_INVALID_CLASS;\n    }\n\n    if (e_ident[5] != '\\x01' && e_ident[5] != '\\x02') {\n        fclose(fptr);\n        return ERR_INVALID_DATA;\n    }\n\n    struct compat_t curr_type = {.any = 0, .class = e_ident[4]};\n    int is_little_endian = e_ident[5] == '\\x01';\n\n    // Make sure that we have matching bits with parent\n    if (!compat.any && compat.class != curr_type.class) {\n        fclose(fptr);\n        return ERR_INVALID_BITS;\n    }\n\n    // Make sure that the elf file has a the host's endianness\n    // Byte swapping is on the TODO list\n    if (is_little_endian ^ host_is_little_endian()) {\n        fclose(fptr);\n        return ERR_INVALID_ENDIANNESS;\n    }\n\n    // And get the type\n    union {\n        struct header_64_t h64;\n        struct header_32_t h32;\n    } header;\n\n    // Read the (rest of the) elf header\n    if (curr_type.class == BITS64) {\n        if (fread(&header.h64, sizeof(struct header_64_t), 1, fptr) != 1) {\n            fclose(fptr);\n            return ERR_INVALID_HEADER;\n        }\n        if (header.h64.e_type != ET_EXEC && header.h64.e_type != ET_DYN) {\n            fclose(fptr);\n            return ERR_NO_EXEC_OR_DYN;\n        }\n        curr_type.machine = header.h64.e_machine;\n        if (!compat.any && compat.machine != curr_type.machine) {\n            fclose(fptr);\n            return ERR_INCOMPATIBLE_ISA;\n        }\n        if (fseek(fptr, header.h64.e_phoff, SEEK_SET) != 0) {\n            fclose(fptr);\n            return ERR_INVALID_PHOFF;\n        }\n    } else {\n        if (fread(&header.h32, sizeof(struct header_32_t), 1, fptr) != 1) {\n            fclose(fptr);\n            return ERR_INVALID_HEADER;\n        }\n        if (header.h32.e_type != ET_EXEC && header.h32.e_type != ET_DYN) {\n            fclose(fptr);\n            return ERR_NO_EXEC_OR_DYN;\n        }\n        curr_type.machine = header.h32.e_machine;\n        if (!compat.any && compat.machine != curr_type.machine) {\n            fclose(fptr);\n            return ERR_INCOMPATIBLE_ISA;\n        }\n        if (fseek(fptr, header.h32.e_phoff, SEEK_SET) != 0) {\n            fclose(fptr);\n            return ERR_INVALID_PHOFF;\n        }\n    }\n\n    // Make sure it's an executable or library\n    union {\n        struct prog_64_t p64;\n        struct prog_32_t p32;\n    } prog;\n\n    // map vaddr to file offset (we don't mmap the file, but directly seek in\n    // the file which means that we have to translate vaddr to file offset)\n    struct small_vec_u64_t pt_load_offset;\n    struct small_vec_u64_t pt_load_vaddr;\n\n    small_vec_u64_init(&pt_load_offset);\n    small_vec_u64_init(&pt_load_vaddr);\n\n    // Read the program header.\n    uint64_t p_offset = MAX_OFFSET_T;\n    if (curr_type.class == BITS64) {\n        for (uint64_t i = 0; i < header.h64.e_phnum; ++i) {\n            if (fread(&prog.p64, sizeof(struct prog_64_t), 1, fptr) != 1) {\n                fclose(fptr);\n                small_vec_u64_free(&pt_load_offset);\n                small_vec_u64_free(&pt_load_vaddr);\n                return ERR_INVALID_PROG_HEADER;\n            }\n\n            if (prog.p64.p_type == PT_LOAD) {\n                small_vec_u64_append(&pt_load_offset, prog.p64.p_offset);\n                small_vec_u64_append(&pt_load_vaddr, prog.p64.p_vaddr);\n            } else if (prog.p64.p_type == PT_DYNAMIC) {\n                p_offset = prog.p64.p_offset;\n            }\n        }\n    } else {\n        for (uint32_t i = 0; i < header.h32.e_phnum; ++i) {\n            if (fread(&prog.p32, sizeof(struct prog_32_t), 1, fptr) != 1) {\n                fclose(fptr);\n                small_vec_u64_free(&pt_load_offset);\n                small_vec_u64_free(&pt_load_vaddr);\n                return ERR_INVALID_PROG_HEADER;\n            }\n\n            if (prog.p32.p_type == PT_LOAD) {\n                small_vec_u64_append(&pt_load_offset, prog.p32.p_offset);\n                small_vec_u64_append(&pt_load_vaddr, prog.p32.p_vaddr);\n            } else if (prog.p32.p_type == PT_DYNAMIC) {\n                p_offset = prog.p32.p_offset;\n            }\n        }\n    }\n\n    // At this point we're going to store the file as \"success\"\n    struct stat finfo;\n    if (stat(current_file, &finfo) != 0) {\n        fclose(fptr);\n        small_vec_u64_free(&pt_load_offset);\n        small_vec_u64_free(&pt_load_vaddr);\n        return ERR_CANT_STAT;\n    }\n\n    int seen_before = visited_files_contains(&s->visited, &finfo);\n\n    if (!seen_before)\n        visited_files_append(&s->visited, &finfo);\n\n    // No dynamic section?\n    if (p_offset == MAX_OFFSET_T) {\n        print_line(depth, current_file, BOLD_CYAN, REGULAR_CYAN, 1, reason, s);\n        fclose(fptr);\n        small_vec_u64_free(&pt_load_offset);\n        small_vec_u64_free(&pt_load_vaddr);\n        return 0;\n    }\n\n    // I guess you always have to load at least a string\n    // table, so if there are not PT_LOAD sections, then\n    // it is an error.\n    if (pt_load_offset.n == 0) {\n        fclose(fptr);\n        small_vec_u64_free(&pt_load_offset);\n        small_vec_u64_free(&pt_load_vaddr);\n        return ERR_NO_PT_LOAD;\n    }\n\n    // Go to the dynamic section\n    if (fseek(fptr, p_offset, SEEK_SET) != 0) {\n        fclose(fptr);\n        small_vec_u64_free(&pt_load_offset);\n        small_vec_u64_free(&pt_load_vaddr);\n        return ERR_INVALID_DYNAMIC_SECTION;\n    }\n\n    // Shared libraries can disable searching in\n    // \"default\" search paths, aka ld.so.conf and\n    // /usr/lib etc. At least glibc respects this.\n    int no_def_lib = 0;\n\n    uint64_t strtab = MAX_OFFSET_T;\n    uint64_t rpath = MAX_OFFSET_T;\n    uint64_t runpath = MAX_OFFSET_T;\n    uint64_t soname = MAX_OFFSET_T;\n\n    // Offsets in strtab\n    struct small_vec_u64_t needed;\n    small_vec_u64_init(&needed);\n\n    for (int cont = 1; cont;) {\n        uint64_t d_tag;\n        uint64_t d_val;\n\n        if (curr_type.class == BITS64) {\n            struct dyn_64_t dyn;\n            if (fread(&dyn, sizeof(struct dyn_64_t), 1, fptr) != 1) {\n                fclose(fptr);\n                small_vec_u64_free(&pt_load_offset);\n                small_vec_u64_free(&pt_load_vaddr);\n                small_vec_u64_free(&needed);\n                return ERR_INVALID_DYNAMIC_ARRAY_ENTRY;\n            }\n            d_tag = dyn.d_tag;\n            d_val = dyn.d_val;\n\n        } else {\n            struct dyn_32_t dyn;\n            if (fread(&dyn, sizeof(struct dyn_32_t), 1, fptr) != 1) {\n                fclose(fptr);\n                small_vec_u64_free(&pt_load_offset);\n                small_vec_u64_free(&pt_load_vaddr);\n                small_vec_u64_free(&needed);\n                return ERR_INVALID_DYNAMIC_ARRAY_ENTRY;\n            }\n            d_tag = dyn.d_tag;\n            d_val = dyn.d_val;\n        }\n\n        // Store strtab / rpath / runpath / needed / soname info.\n        switch (d_tag) {\n        case DT_NULL:\n            cont = 0;\n            break;\n        case DT_STRTAB:\n            strtab = d_val;\n            break;\n        case DT_RPATH:\n            rpath = d_val;\n            break;\n        case DT_RUNPATH:\n            runpath = d_val;\n            break;\n        case DT_NEEDED:\n            small_vec_u64_append(&needed, d_val);\n            break;\n        case DT_SONAME:\n            soname = d_val;\n            break;\n        case DT_FLAGS_1:\n            no_def_lib |= (DT_1_NODEFLIB & d_val) == DT_1_NODEFLIB;\n            break;\n        }\n    }\n\n    if (strtab == MAX_OFFSET_T) {\n        fclose(fptr);\n        small_vec_u64_free(&pt_load_offset);\n        small_vec_u64_free(&pt_load_vaddr);\n        small_vec_u64_free(&needed);\n        return ERR_NO_STRTAB;\n    }\n\n    // Let's verify just to be sure that the offsets are\n    // ordered.\n    if (!is_ascending_order(pt_load_vaddr.p, pt_load_vaddr.n)) {\n        fclose(fptr);\n        small_vec_u64_free(&pt_load_vaddr);\n        small_vec_u64_free(&pt_load_offset);\n        small_vec_u64_free(&needed);\n        return ERR_VADDRS_NOT_ORDERED;\n    }\n\n    // Find the file offset corresponding to the strtab virtual address\n    size_t vaddr_idx = 0;\n    while (vaddr_idx + 1 != pt_load_vaddr.n &&\n           strtab >= pt_load_vaddr.p[vaddr_idx + 1]) {\n        ++vaddr_idx;\n    }\n\n    uint64_t strtab_offset =\n        pt_load_offset.p[vaddr_idx] + strtab - pt_load_vaddr.p[vaddr_idx];\n\n    small_vec_u64_free(&pt_load_vaddr);\n    small_vec_u64_free(&pt_load_offset);\n\n    // From this point on we actually copy strings from the ELF file into our\n    // own string buffer.\n\n    // Copy the current soname\n    size_t soname_buf_offset = s->string_table.n;\n    if (soname != MAX_OFFSET_T) {\n        if (fseek(fptr, strtab_offset + soname, SEEK_SET) != 0) {\n            s->string_table.n = old_buf_size;\n            fclose(fptr);\n            small_vec_u64_free(&needed);\n            return ERR_INVALID_SONAME;\n        }\n        string_table_copy_from_file(&s->string_table, fptr);\n    }\n\n    int in_exclude_list =\n        soname != MAX_OFFSET_T &&\n        is_in_exclude_list(s->string_table.arr + soname_buf_offset);\n\n    // No need to recurse deeper when we aren't in very verbose mode.\n    int should_recurse =\n        depth < s->max_depth &&\n        ((!seen_before && !in_exclude_list) ||\n         (!seen_before && in_exclude_list && s->verbosity >= 2) ||\n         s->verbosity >= 3);\n\n    // Just print the library and return\n    if (!should_recurse) {\n        char *print_name = soname == MAX_OFFSET_T || s->path\n                               ? current_file\n                               : (s->string_table.arr + soname_buf_offset);\n\n        char *bold_color = in_exclude_list\n                               ? REGULAR_MAGENTA\n                               : seen_before ? REGULAR_BLUE : BOLD_CYAN;\n        char *regular_color = in_exclude_list\n                                  ? REGULAR_MAGENTA\n                                  : seen_before ? REGULAR_BLUE : REGULAR_CYAN;\n\n        int highlight = !seen_before && !in_exclude_list;\n        print_line(depth, print_name, bold_color, regular_color, highlight,\n                   reason, s);\n\n        s->string_table.n = old_buf_size;\n        fclose(fptr);\n        small_vec_u64_free(&needed);\n        return 0;\n    }\n\n    // Store the ORIGIN string.\n    char origin[MAX_PATH_LENGTH];\n    char *last_slash = strrchr(current_file, '/');\n    if (last_slash != NULL) {\n        // Exclude the last slash\n        size_t bytes = last_slash - current_file;\n        memcpy(origin, current_file, bytes);\n        origin[bytes] = '\\0';\n    } else {\n        // this only happens when the input is relative (e.g. in current dir)\n        memcpy(origin, \"./\", 3);\n    }\n\n    // Copy DT_PRATH\n    if (rpath == MAX_OFFSET_T) {\n        s->rpath_offsets[depth] = SIZE_MAX;\n    } else {\n        s->rpath_offsets[depth] = s->string_table.n;\n        if (fseek(fptr, strtab_offset + rpath, SEEK_SET) != 0) {\n            s->string_table.n = old_buf_size;\n            fclose(fptr);\n            small_vec_u64_free(&needed);\n            return ERR_INVALID_RPATH;\n        }\n\n        string_table_copy_from_file(&s->string_table, fptr);\n\n        // We store the interpolated string right after the literal copy.\n        size_t curr_buf_size = s->string_table.n;\n        if (interpolate_variables(s, s->rpath_offsets[depth], origin))\n            s->rpath_offsets[depth] = curr_buf_size;\n    }\n\n    // Copy DT_RUNPATH\n    size_t runpath_buf_offset = s->string_table.n;\n    if (runpath != MAX_OFFSET_T) {\n        if (fseek(fptr, strtab_offset + runpath, SEEK_SET) != 0) {\n            s->string_table.n = old_buf_size;\n            fclose(fptr);\n            small_vec_u64_free(&needed);\n            return ERR_INVALID_RUNPATH;\n        }\n\n        string_table_copy_from_file(&s->string_table, fptr);\n\n        // We store the interpolated string right after the literal copy.\n        size_t curr_buf_size = s->string_table.n;\n        if (interpolate_variables(s, runpath_buf_offset, origin))\n            runpath_buf_offset = curr_buf_size;\n    }\n\n    // Copy needed libraries.\n    struct small_vec_u64_t needed_buf_offsets;\n    small_vec_u64_init(&needed_buf_offsets);\n\n    for (size_t i = 0; i < needed.n; ++i) {\n        small_vec_u64_append(&needed_buf_offsets, s->string_table.n);\n        if (fseek(fptr, strtab_offset + needed.p[i], SEEK_SET) != 0) {\n            s->string_table.n = old_buf_size;\n            fclose(fptr);\n            small_vec_u64_free(&needed_buf_offsets);\n            small_vec_u64_free(&needed);\n            return ERR_INVALID_NEEDED;\n        }\n        string_table_copy_from_file(&s->string_table, fptr);\n    }\n\n    fclose(fptr);\n\n    char *print_name = soname == MAX_OFFSET_T || s->path\n                           ? current_file\n                           : (s->string_table.arr + soname_buf_offset);\n\n    char *bold_color = in_exclude_list ? REGULAR_MAGENTA\n                                       : seen_before ? REGULAR_BLUE : BOLD_CYAN;\n    char *regular_color = in_exclude_list\n                              ? REGULAR_MAGENTA\n                              : seen_before ? REGULAR_BLUE : REGULAR_CYAN;\n\n    int highlight = !seen_before && !in_exclude_list;\n    print_line(depth, print_name, bold_color, regular_color, highlight, reason,\n               s);\n\n    // Finally start searching.\n\n    int exit_code = 0;\n\n    size_t needed_not_found = needed_buf_offsets.n;\n\n    // Skip common libraries if not verbose\n    if (needed_not_found && s->verbosity == 0)\n        apply_exclude_list(&needed_not_found, &needed_buf_offsets, s);\n\n    if (needed_not_found)\n        exit_code |= check_absolute_paths(\n            &needed_not_found, &needed_buf_offsets, depth, s, curr_type);\n\n    // Consider rpaths only when runpath is empty\n    if (runpath == MAX_OFFSET_T) {\n        // We have a stack of rpaths, try them all, starting with one set at\n        // this lib, then the parents.\n        for (int j = depth; j >= 0 && needed_not_found; --j) {\n            if (s->rpath_offsets[j] == SIZE_MAX)\n                continue;\n\n            exit_code |= check_search_paths(\n                (struct found_t){.how = RPATH, .depth = j}, s->rpath_offsets[j],\n                &needed_not_found, &needed_buf_offsets, depth, s, curr_type);\n        }\n    }\n\n    // Then try LD_LIBRARY_PATH, if we have it.\n    if (needed_not_found && s->ld_library_path_offset != SIZE_MAX) {\n        exit_code |= check_search_paths(\n            (struct found_t){.how = LD_LIBRARY_PATH}, s->ld_library_path_offset,\n            &needed_not_found, &needed_buf_offsets, depth, s, curr_type);\n    }\n\n    // Then consider runpaths\n    if (needed_not_found && runpath != MAX_OFFSET_T) {\n        exit_code |= check_search_paths(\n            (struct found_t){.how = RUNPATH}, runpath_buf_offset,\n            &needed_not_found, &needed_buf_offsets, depth, s, curr_type);\n    }\n\n    // Check ld.so.conf paths\n    if (needed_not_found && !no_def_lib) {\n        exit_code |= check_search_paths(\n            (struct found_t){.how = LD_SO_CONF}, s->ld_so_conf_offset,\n            &needed_not_found, &needed_buf_offsets, depth, s, curr_type);\n    }\n\n    // Then consider standard paths\n    if (needed_not_found && !no_def_lib) {\n        exit_code |= check_search_paths(\n            (struct found_t){.how = DEFAULT}, s->default_paths_offset,\n            &needed_not_found, &needed_buf_offsets, depth, s, curr_type);\n    }\n\n    // Finally summarize those that could not be found.\n    if (needed_not_found) {\n        print_error(depth, needed_not_found, &needed_buf_offsets,\n                    runpath == MAX_OFFSET_T\n                        ? NULL\n                        : s->string_table.arr + runpath_buf_offset,\n                    s, no_def_lib);\n        s->string_table.n = old_buf_size;\n        small_vec_u64_free(&needed_buf_offsets);\n        small_vec_u64_free(&needed);\n        return ERR_DEPENDENCY_NOT_FOUND;\n    }\n\n    // Free memory in our string table\n    s->string_table.n = old_buf_size;\n    small_vec_u64_free(&needed_buf_offsets);\n    small_vec_u64_free(&needed);\n    return exit_code;\n}\n\nstatic int parse_ld_config_file(struct string_table_t *st, char *path);\n\nstatic int ld_conf_globbing(struct string_table_t *st, char *pattern) {\n    glob_t result;\n    memset(&result, 0, sizeof(result));\n    int status = glob(pattern, 0, NULL, &result);\n\n    // Handle errors (no result is not an error...)\n    switch (status) {\n    case GLOB_NOSPACE:\n    case GLOB_ABORTED:\n        globfree(&result);\n        return 1;\n    case GLOB_NOMATCH:\n        globfree(&result);\n        return 0;\n    }\n\n    // Otherwise parse the files we've found!\n    int code = 0;\n    for (size_t i = 0; i < result.gl_pathc; ++i)\n        code |= parse_ld_config_file(st, result.gl_pathv[i]);\n\n    globfree(&result);\n    return code;\n}\n\nstatic int parse_ld_config_file(struct string_table_t *st, char *path) {\n    FILE *fptr = fopen(path, \"r\");\n\n    if (fptr == NULL)\n        return 1;\n\n    int c = 0;\n    char line[MAX_PATH_LENGTH];\n    char tmp[MAX_PATH_LENGTH];\n\n    while (c != EOF) {\n        size_t line_len = 0;\n        while ((c = getc(fptr)) != '\\n' && c != EOF) {\n            if (line_len < MAX_PATH_LENGTH - 1) {\n                line[line_len++] = c;\n            }\n        }\n\n        line[line_len] = '\\0';\n\n        char *begin = line;\n        char *end = line + line_len;\n        // Remove leading whitespace\n        for (; isspace(*begin); ++begin) {\n        }\n\n        // Remove trailing comments\n        char *comment = strchr(begin, '#');\n        if (comment != NULL)\n            *comment = '\\0';\n\n        // Remove trailing whitespace\n        while (end != begin)\n            if (!isspace(*--end))\n                break;\n\n        // Skip empty lines\n        if (begin == end)\n            continue;\n\n        // Put back the end of the string\n        end[1] = '\\0';\n\n        // 'include ': glob whatever follows.\n        if (strncmp(begin, \"include\", 7) == 0 && isspace(begin[7])) {\n            begin += 8;\n            // Remove more whitespace.\n            while (isspace(*begin))\n                ++begin;\n\n            // Prepend current dir when include dir is relative.\n            if (*begin != '/') {\n                char *wd = strrchr(path, '/');\n                wd = wd == NULL ? strrchr(path, '\\0') : wd;\n\n                // bytes until /\n                size_t wd_len = wd - path;\n                size_t include_len = end - begin + 1;\n\n                // just skip then.\n                if (wd_len + 1 + include_len >= MAX_PATH_LENGTH)\n                    continue;\n\n                memcpy(tmp, path, wd_len);\n                tmp[wd_len] = '/';\n                memcpy(tmp + wd_len + 1, begin, include_len);\n                tmp[wd_len + 1 + include_len] = '\\0';\n                begin = tmp;\n            }\n\n            ld_conf_globbing(st, begin);\n        } else {\n            // Copy over and replace trailing \\0 with :.\n            string_table_store(st, begin);\n            st->arr[st->n - 1] = ':';\n        }\n    }\n\n    fclose(fptr);\n\n    return 0;\n}\n\nstatic void parse_ld_so_conf(struct libtree_state_t *s) {\n    struct string_table_t *st = &s->string_table;\n    s->ld_so_conf_offset = st->n;\n\n    // Linux / glibc\n    parse_ld_config_file(st, s->ld_conf_file);\n\n    // Replace the last semicolon with a '\\0'\n    // if we have a nonzero number of paths.\n    if (st->n > s->ld_so_conf_offset) {\n        st->arr[st->n - 1] = '\\0';\n    } else {\n        string_table_store(st, \"\");\n    }\n}\n\nstatic void parse_ld_library_path(struct libtree_state_t *s) {\n    s->ld_library_path_offset = SIZE_MAX;\n    char *val = getenv(\"LD_LIBRARY_PATH\");\n\n    // not set, so nothing to do.\n    if (val == NULL)\n        return;\n\n    s->ld_library_path_offset = s->string_table.n;\n\n    // otherwise, we just copy it over and replace ; with :\n    string_table_store(&s->string_table, val);\n\n    // replace ; with :\n    char *search = s->string_table.arr + s->ld_library_path_offset;\n    while ((search = strchr(search, ';')) != NULL)\n        *search++ = ':';\n}\n\nstatic void set_default_paths(struct libtree_state_t *s) {\n    s->default_paths_offset = s->string_table.n;\n    // TODO: how to retrieve this list properly at runtime?\n    string_table_store(&s->string_table, \"/lib:/lib64:/usr/lib:/usr/lib64\");\n}\n\nstatic void libtree_state_init(struct libtree_state_t *s) {\n    s->string_table.n = 0;\n    s->string_table.capacity = 1024;\n    s->string_table.arr = malloc(s->string_table.capacity * sizeof(char));\n    s->visited.n = 0;\n    s->visited.capacity = 256;\n    s->visited.arr =\n        malloc(s->visited.capacity * sizeof(struct visited_file_t));\n}\n\nstatic void libtree_state_free(struct libtree_state_t *s) {\n    free(s->string_table.arr);\n    free(s->visited.arr);\n}\n\nstatic int print_tree(int pathc, char **pathv, struct libtree_state_t *s) {\n    // First collect standard paths\n    libtree_state_init(s);\n\n    parse_ld_so_conf(s);\n    parse_ld_library_path(s);\n    set_default_paths(s);\n\n    int exit_code = 0;\n\n    for (int i = 0; i < pathc; ++i) {\n        int code = recurse(pathv[i], 0, s, (struct compat_t){.any = 1},\n                           (struct found_t){.how = INPUT});\n        fflush(stdout);\n        if (code != 0) {\n            exit_code = code;\n            fputs(\"Error [\", stderr);\n            fputs(pathv[i], stderr);\n            fputs(\"]: \", stderr);\n        }\n        char *msg = NULL;\n        switch (code) {\n        case ERR_INVALID_MAGIC:\n            msg = \"Invalid ELF magic bytes\\n\";\n            break;\n        case ERR_INVALID_CLASS:\n            msg = \"Invalid ELF class\\n\";\n            break;\n        case ERR_INVALID_DATA:\n            msg = \"Invalid ELF data\\n\";\n            break;\n        case ERR_INVALID_HEADER:\n            msg = \"Invalid ELF header\\n\";\n            break;\n        case ERR_INVALID_BITS:\n            msg = \"Invalid bits\\n\";\n            break;\n        case ERR_INVALID_ENDIANNESS:\n            msg = \"Invalid endianness\\n\";\n            break;\n        case ERR_NO_EXEC_OR_DYN:\n            msg = \"Not an ET_EXEC or ET_DYN ELF file\\n\";\n            break;\n        case ERR_INVALID_PHOFF:\n            msg = \"Invalid ELF program header offset\\n\";\n            break;\n        case ERR_INVALID_PROG_HEADER:\n            msg = \"Invalid ELF program header\\n\";\n            break;\n        case ERR_CANT_STAT:\n            msg = \"Can't stat file\\n\";\n            break;\n        case ERR_INVALID_DYNAMIC_SECTION:\n            msg = \"Invalid ELF dynamic section\\n\";\n            break;\n        case ERR_INVALID_DYNAMIC_ARRAY_ENTRY:\n            msg = \"Invalid ELF dynamic array entry\\n\";\n            break;\n        case ERR_NO_STRTAB:\n            msg = \"No ELF string table found\\n\";\n            break;\n        case ERR_INVALID_SONAME:\n            msg = \"Can't read DT_SONAME\\n\";\n            break;\n        case ERR_INVALID_RPATH:\n            msg = \"Can't read DT_RPATH\\n\";\n            break;\n        case ERR_INVALID_RUNPATH:\n            msg = \"Can't read DT_RUNPATH\\n\";\n            break;\n        case ERR_INVALID_NEEDED:\n            msg = \"Can't read DT_NEEDED\\n\";\n            break;\n        case ERR_DEPENDENCY_NOT_FOUND:\n            msg = \"Not all dependencies were found\\n\";\n            break;\n        case ERR_NO_PT_LOAD:\n            msg = \"No PT_LOAD found in ELF file\\n\";\n            break;\n        case ERR_VADDRS_NOT_ORDERED:\n            msg = \"Virtual addresses are not ordered\\n\";\n            break;\n        case ERR_COULD_NOT_OPEN_FILE:\n            msg = \"Could not open file\\n\";\n            break;\n        case ERR_INCOMPATIBLE_ISA:\n            msg = \"Incompatible ISA\\n\";\n            break;\n        }\n\n        if (msg != NULL)\n            fputs(msg, stderr);\n\n        fflush(stderr);\n    }\n\n    libtree_state_free(s);\n    return exit_code;\n}\n\nint main(int argc, char **argv) {\n    // Enable or disable colors (no-color.com)\n    struct libtree_state_t s;\n    s.color = getenv(\"NO_COLOR\") == NULL && isatty(STDOUT_FILENO);\n    s.verbosity = 0;\n    s.path = 0;\n    s.max_depth = MAX_RECURSION_DEPTH;\n\n    // We want to end up with an array of file names\n    // in argv[1] up to argv[positional-1].\n    int positional = 1;\n\n    struct utsname uname_val;\n    if (uname(&uname_val) != 0)\n        return 1;\n\n    // Technically this should be AT_PLATFORM, but\n    // (a) the feature is rarely used\n    // (b) it's almost always the same\n    s.PLATFORM = uname_val.machine;\n    s.OSNAME = uname_val.sysname;\n    s.OSREL = uname_val.release;\n    s.ld_conf_file = \"/etc/ld.so.conf\";\n\n    if (strcmp(uname_val.sysname, \"FreeBSD\") == 0)\n        s.ld_conf_file = \"/etc/ld-elf.so.conf\";\n\n    // TODO: how to find this value at runtime?\n    s.LIB = \"lib\";\n\n    int opt_help = 0;\n    int opt_version = 0;\n\n    // After `--` we treat everything as filenames, not flags.\n    int opt_raw = 0;\n\n    for (int i = 1; i < argc; ++i) {\n        char *arg = argv[i];\n\n        // Positional args don't start with - or are `-` literal.\n        if (opt_raw || *arg != '-' || arg[1] == '\\0') {\n            argv[positional++] = arg;\n            continue;\n        }\n\n        // Now we're in flag land!\n        ++arg;\n\n        // Long flags\n        if (*arg == '-') {\n            ++arg;\n\n            // Literal '--'\n            if (*arg == '\\0') {\n                opt_raw = 1;\n                continue;\n            }\n\n            if (strcmp(arg, \"version\") == 0) {\n                opt_version = 1;\n            } else if (strcmp(arg, \"path\") == 0) {\n                s.path = 1;\n            } else if (strcmp(arg, \"verbose\") == 0) {\n                ++s.verbosity;\n            } else if (strcmp(arg, \"help\") == 0) {\n                opt_help = 1;\n            } else if (strcmp(arg, \"ldconf\") == 0) {\n                // Require a value\n                if (i + 1 == argc) {\n                    fputs(\"Expected value after `--ldconf`\\n\", stderr);\n                    return 1;\n                }\n                s.ld_conf_file = argv[++i];\n            } else if (strcmp(arg, \"max-depth\") == 0) {\n                // Require a value\n                if (i + 1 == argc) {\n                    fputs(\"Expected value after `--max-depth`\\n\", stderr);\n                    return 1;\n                }\n                // Limit it by MAX_RECURSION_DEPTH.\n                char *ptr;\n                s.max_depth = strtoul(argv[++i], &ptr, 10);\n                if (s.max_depth > MAX_RECURSION_DEPTH)\n                    s.max_depth = MAX_RECURSION_DEPTH;\n            } else {\n                fputs(\"Unrecognized flag `--\", stderr);\n                fputs(arg, stderr);\n                fputs(\"`\\n\", stderr);\n                return 1;\n            }\n\n            continue;\n        }\n\n        // Short flags\n        for (; *arg != '\\0'; ++arg) {\n            switch (*arg) {\n            case 'h':\n                opt_help = 1;\n                break;\n            case 'p':\n                s.path = 1;\n                break;\n            case 'v':\n                ++s.verbosity;\n                break;\n            default:\n                fputs(\"Unrecognized flag `-\", stderr);\n                fputs(arg, stderr);\n                fputs(\"`\\n\", stderr);\n                return 1;\n            }\n        }\n    }\n\n    ++argv;\n    --positional;\n\n    // Print a help message on -h, --help or no positional args.\n    if (opt_help || (!opt_version && positional == 0)) {\n        // clang-format off\n        fputs(\"Show the dynamic dependency tree of ELF files\\n\"\n              \"Usage: libtree [OPTION]... [--] FILE [FILES]...\\n\"\n              \"\\n\"\n              \"  -h, --help     Print help info\\n\"\n              \"      --version  Print version info\\n\"\n              \"\\n\"\n              \"File names starting with '-', for example '-.so', can be specified as follows:\\n\"\n              \"  libtree -- -.so\\n\"\n              \"\\n\"\n              \"Locating libs options:\\n\"\n              \"  -p, --path       Show the path of libraries instead of the soname\\n\"\n              \"  -v               Show libraries skipped by default*\\n\"\n              \"  -vv              Show dependencies of libraries skipped by default*\\n\"\n              \"  -vvv             Show dependencies of already encountered libraries\\n\"\n              \"  --ldconf <path>  Config file for extra search paths [\", stdout);\n        fputs(s.ld_conf_file, stdout);\n        fputs(\"]\\n\"\n              \"  --max-depth <n>  Limit library traversal to at most n levels of depth\\n\"\n              \"\\n\"\n              \"* For brevity, the following libraries are not shown by default:\\n\"\n              \"  \",\n              stdout);\n        // clang-format on\n\n        // Print a comma separated list of skipped libraries,\n        // with some new lines every now and then to make it readable.\n        size_t num_excluded = sizeof(exclude_list) / sizeof(char *);\n\n        size_t cursor_x = 3;\n        for (size_t j = 0; j < num_excluded; ++j) {\n            cursor_x += strlen(exclude_list[j]);\n            if (cursor_x > 60) {\n                cursor_x = 3;\n                fputs(\"\\n  \", stdout);\n            }\n            fputs(exclude_list[j], stdout);\n            if (j + 1 != num_excluded)\n                fputs(\", \", stdout);\n        }\n\n        // rpath substitution values:\n        fputs(\".\\n\\nThe following rpath/runpath substitutions are used:\\n\",\n              stdout);\n        fputs(\"  PLATFORM       \", stdout);\n        fputs(s.PLATFORM, stdout);\n        fputs(\"\\n  LIB            \", stdout);\n        fputs(s.LIB, stdout);\n        fputs(\"\\n  OSNAME         \", stdout);\n        fputs(s.OSNAME, stdout);\n        fputs(\"\\n  OSREL          \", stdout);\n        fputs(s.OSREL, stdout);\n        putchar('\\n');\n\n        // Return an error status code if no positional args were passed.\n        return !opt_help;\n    }\n\n    if (opt_version) {\n        puts(VERSION);\n        return 0;\n    }\n\n    return print_tree(positional, argv, &s);\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}