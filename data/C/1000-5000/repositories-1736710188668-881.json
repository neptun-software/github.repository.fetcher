{
  "metadata": {
    "timestamp": 1736710188668,
    "page": 881,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "samtools/samtools",
      "stars": 1658,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 2.46484375,
          "content": "# version format.\r\n# you can use {branch} name in version format too\r\n# version: 1.0.{build}-{branch}\r\nversion: 'vers.{build}'\r\n\r\n# branches to build\r\nbranches:\r\n    # Blacklist\r\n    except:\r\n      - gh-pages\r\n      - /.*/ # Appveyor builds are currently disabled.\r\n\r\n# Do not build on tags (GitHub and BitBucket)\r\nskip_tags: true\r\n\r\n# Skipping commits affecting specific files (GitHub only). More details here: /docs/appveyor-yml\r\n#skip_commits:\r\n#  files:\r\n#    - docs/*\r\n#    - '**/*.html'\r\n\r\n# Appveyor Windows images are based on Visual studio version\r\nimage: Visual Studio 2019\r\n\r\n# We use Mingw/Msys, so use pacman for installs\r\ninstall:\r\n  - set HOME=.\r\n  - set MSYSTEM=MINGW64\r\n  - set PATH=C:/msys64/usr/bin;C:/msys64/mingw64/bin;%PATH%\r\n  - set MINGWPREFIX=x86_64-w64-mingw32\r\n  - \"sh -lc \\\"pacman -S --noconfirm --needed base-devel mingw-w64-x86_64-toolchain mingw-w64-x86_64-autotools mingw-w64-x86_64-zlib mingw-w64-x86_64-bzip2 mingw-w64-x86_64-xz mingw-w64-x86_64-curl\\\"\"\r\n\r\n# The user may have e.g. jkbonfield/samtools branch FOO and an associated\r\n# jkbonfield/htslib branch FOO.  If so use that related htslib, obtained by\r\n# munging $APPVEYOR_REPO_NAME.  Otherwise we assume this is a PR only to\r\n# samtools and should be linked against samtools(org)/htslib develop branch.\r\nclone_script:\r\n  - \"sh -lc \\\"if test x$APPVEYOR_PULL_REQUEST_HEAD_REPO_NAME != x ; then git clone --branch=$APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH https://github.com/$APPVEYOR_PULL_REQUEST_HEAD_REPO_NAME $APPVEYOR_BUILD_FOLDER ; else false ; fi || git clone --branch=$APPVEYOR_REPO_BRANCH https://github.com/$APPVEYOR_REPO_NAME $APPVEYOR_BUILD_FOLDER\\\"\"\r\n  - \"sh -lc \\\"git show-branch --sha1-name HEAD\"\r\n  - \"sh -lc \\\"git clone --branch=$APPVEYOR_REPO_BRANCH --recurse-submodules --shallow-submodules https://github.com/`echo $APPVEYOR_REPO_NAME|sed 's#/samtools#/htslib#'`.git $APPVEYOR_BUILD_FOLDER/htslib || git clone --recurse-submodules --shallow-submodules https://github.com/samtools/htslib.git $APPVEYOR_BUILD_FOLDER/htslib \\\"\"\r\n  - \"sh -lc \\\"cd $APPVEYOR_BUILD_FOLDER/htslib && git show-branch --sha1-name HEAD\\\"\"\r\n\r\nbuild_script:\r\n  - set HOME=.\r\n  - set MSYSTEM=MINGW64\r\n  - set PATH=C:/msys64/usr/bin;C:/msys64/mingw64/bin;%PATH%\r\n  - \"sh -lc \\\"(cd htslib; autoreconf -i)\\\"\"\r\n  - \"sh -lc \\\"aclocal && autoheader && autoconf && ./configure --enable-werror && make -j2\\\"\"\r\n\r\ntest_script:\r\n  - set HOME=.\r\n  - set MSYSTEM=MINGW64\r\n  - set PATH=C:/msys64/usr/bin;C:/msys64/mingw64/bin;%PATH%\r\n  - \"sh -lc \\\"make test\\\"\"\r\n"
        },
        {
          "name": ".ci_helpers",
          "type": "tree",
          "content": null
        },
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 5.626953125,
          "content": "# Note we have a maximum of 16 CPUs available, so adjust our\n# builds so we can start all concurrently without needing to schedule.\n\n# Sadly though there is still a finite limit to macOS of one instance.\n# Can we cull our Mac test to just one instance?\n\ntimeout_in: 10m\n\n#--------------------------------------------------\n# Template: htslib clone & build\n#\n# We try to clone htslib using the same branch name and owner as this\n# samtools branch.  If it exists, it's likely the user is making a\n# joint samtools+htslib PR and wants both checked in unison.\n# Failing that we use samtools/htslib:develop.\n# Note this only works on the users own forks.  Once in the samtools\n# organisation the branch name becomes pull/<num>.\n\n# Logic for choosing which to use is in the .ci_helpers/clone script.\n# Note we could also use \"clone_script\" if we want to replace the samtools\n# clone with our own commands too.\nclone_template: &HTSLIB_CLONE\n  htslib_clone_script: |\n    # Tricky, but when run as a PR Cirrus-CI obscures the branch name and\n    # replaces it by pull/<num>.  This means we can't automatically get PRs\n    # to test whether the user has a similarly named branch to compiler and\n    # test against.\n    #\n    # Instead if we add htslib#NUM into the first line of the commit then\n    # we will use that PR from htslib instead.  This is only needed when\n    # making a PR, so for development prior to the PR being made the\n    # CIRRUS_BRANCH will be used in preference.\n    .ci_helpers/clone ${CIRRUS_REPO_OWNER} htslib \"${HTSDIR}\" \"${CIRRUS_BRANCH}\" `printenv CIRRUS_CHANGE_TITLE | sed -n 's/.*htslib#\\([0-9]*\\).*/\\1/p'`\n\nhtslib_compile_template: &HTSLIB_COMPILE\n  << : *HTSLIB_CLONE\n  htslib_compile_script: |\n    cd $HTSDIR\n    autoreconf -i\n    if test \"x$WERROR\" != \"xno\"; then CONFIG_OPTS=\"--enable-werror\"; fi\n    eval ./configure $CONFIG_OPTS --prefix=`pwd`/../inst \\\n        CFLAGS=\\\"$CFLAGS\\\" CPPFLAGS=\\\"$CPPFLAGS\\\" LDFLAGS=\\\"$LDFLAGS\\\" \\\n        || (cat config.log; /bin/false)\n    make -j3 install\n\n#--------------------------------------------------\n# Template: samtools compile and test\n\ncompile_template: &COMPILE\n  << : *HTSLIB_COMPILE\n\n  compile_script: |\n    autoreconf -i\n    if test \"x$WERROR\" != \"xno\"; then CONFIG_OPTS=\"--enable-werror\"; fi\n    eval ./configure $CONFIG_OPTS --with-htslib=`pwd`/inst  \\\n        LDFLAGS=\\\"$LDFLAGS -Wl,-rpath,`pwd`/inst/lib\\\" \\\n        CFLAGS=\\\"$CFLAGS\\\" CPPFLAGS=\\\"$CPPFLAGS\\\" || \\\n        (cat config.log; /bin/false)\n    make -j3\n\ntest_template: &TEST\n  test_script: |\n    if test \"x$DO_MAINTAINER_CHECKS\" = \"xyes\" ; then\n        make maintainer-check\n    fi\n    make\n    make test BGZIP=inst/bin/bgzip\n\n\n#--------------------------------------------------\n# Task: linux builds.\n\n# Debian + latest GCC\ngcc_task:\n  name: debian-gcc\n  container:\n    image: gcc:latest\n    cpu: 2\n    memory: 1G\n\n  environment:\n    LC_ALL: C\n    CIRRUS_CLONE_DEPTH: 1\n    HTSDIR: ./hidden-htslib\n    DO_MAINTAINER_CHECKS: yes\n    # gcc ubsan is incompatible with some -Wformat options, but they're checked\n    # in other tests.  See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87884\n    CFLAGS: -g -Og -std=c99 -D_XOPEN_SOURCE=600 -pedantic -fsanitize=address,undefined -Wno-format-truncation -Wno-format-overflow\n    CPPFLAGS: -DHTS_ALLOW_UNALIGNED=0\n    LDFLAGS: -fsanitize=address,undefined\n    UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1\n\n  << : *COMPILE\n  << : *TEST\n\n\n# Ubuntu + Clang\nubuntu_task:\n  name: ubuntu-clang\n  container:\n    image: ubuntu:latest\n    #image: ubuntu:devel\n    cpu: 2\n    memory: 1G\n\n  environment:\n    CC: clang\n    LC_ALL: C\n    CIRRUS_CLONE_DEPTH: 1\n    HTSDIR: ./hidden-htslib\n\n  matrix:\n    - environment:\n       CFLAGS: -std=gnu99 -O0\n    - environment:\n       CFLAGS: -g -Wall -Wformat -Wformat=2 -O3\n       LDFLAGS: -Wl,-rpath,`pwd`/inst/lib\n\n  # NB: we could consider building a docker image with these\n  # preinstalled and specifying that instead, to speed up testing.\n  install_script: |\n    apt-get update\n    apt-get install -y --no-install-suggests --no-install-recommends \\\n        ca-certificates clang git autoconf automake make zlib1g-dev  \\\n        libbz2-dev liblzma-dev libcurl4-gnutls-dev libssl-dev        \\\n        libdeflate-dev libncurses5-dev\n\n  << : *COMPILE\n  << : *TEST\n\n\n# Rocky Linux\nrocky_task:\n  name: rockylinux-gcc\n  container:\n    image: rockylinux:9\n    cpu: 2\n    memory: 1G\n\n  environment:\n    LC_ALL: C\n    CIRRUS_CLONE_DEPTH: 1\n    HTSDIR: ./hidden-htslib\n    CFLAGS: -O2 -Wextra -Wformat -Wformat=2 -Wno-sign-compare -Wno-missing-field-initializers -Wno-unused-parameter\n\n  # NB: we could consider building a docker image with these\n  # preinstalled and specifying that instead, to speed up testing.\n  install_script: |\n    yum install -y autoconf automake make gcc perl-Data-Dumper perl-FindBin \\\n        zlib-devel bzip2 bzip2-devel xz-devel curl-devel openssl-devel \\\n        ncurses-devel git diffutils\n\n  << : *COMPILE\n  << : *TEST\n\n\n#--------------------------------------------------\n# Task: macOS builds\n\nmacosx_task:\n  name: macosx + clang\n  macos_instance:\n    image: ghcr.io/cirruslabs/macos-ventura-base:latest\n\n  environment:\n    CC: clang\n    LC_ALL: C\n    CIRRUS_CLONE_DEPTH: 1\n    HTSDIR: ./hidden-htslib\n    CFLAGS: -g -Wall -O2\n\n  package_install_script:\n    - HOMEBREW_NO_AUTO_UPDATE=1 brew install autoconf automake libtool xz\n\n  << : *COMPILE\n  << : *TEST\n\n\n# #--------------------------------------------------\n# # Task: FreeBSD builds\n# \n# # Slow to launch?  Commented out for now.\n# freebsd_task:\n#   name: freebsd + gcc\n# \n#   freebsd_instance:\n#     image_family: freebsd-12-1\n#     cpu: 1\n#     memory: 1G\n# #\n# #  install_script: |\n# #    pkg install -y ... to be determined\n# \n#   << : *COMPILE\n#   << : *TEST\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.6044921875,
          "content": "# Ensure BAM files are left as binary.  To display changes in them by\n# converting to SAM, add to your configuration (perhaps with --global):\n#\n#\tgit config diff.bam.textconv \"samtools view\"\n*.bam\t-text diff=bam\n\n# Omit these files from release tarballs.\n/.appveyor.yml  export-ignore\n/.cirrus.yml    export-ignore\n.git*           export-ignore\n.ci_helpers*    export-ignore\nREADME.md       export-ignore\n\n# Correct language misidentifications.\ntest/**/*.[1-9] linguist-language=none\n\n# Prevent Windows cr-lf endings\ntest/**    -text\ntest/**.c   text\ntest/**.h   text\ntest/**.pl  text\ntest/**.sh  text\ntest/**.reg text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.296875,
          "content": "*.o\n*.dSYM\n*.exe\n/version.h\n\naclocal.m4\nautom4te.cache\nconfig.cache\nconfig.h\nconfig.h.in\nconfig.log\nconfig.mk\nconfig.status\nconfigure\n\nlib*.a\n\n/misc/ace2sam\n/misc/maq2sam-long\n/misc/maq2sam-short\n/misc/md5fa\n/misc/md5sum-lite\n/misc/wgsim\n/samtools\n/test/vcf-miniview\n\n/TAGS\n.autotools\n.cproject\n.project\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.80859375,
          "content": "Heng Li from the Sanger Institute wrote most of the initial source codes\nof SAMtools and various converters.\n\nBob Handsaker from the Broad Institute is a major contributor to the\nSAM/BAM specification. He designed and implemented the BGZF format, the\nunderlying indexable compression format for the BAM format. BGZF does\nnot support arithmetic between file offsets.\n\nJue Ruan for the Beijing Genome Institute designed and implemented the\nRAZF format, an alternative indexable compression format. RAZF is no longer\nused by or provided with SAMtools. Source code remains available in older\nSAMtools 0.1.x releases and from the standalone branch in the repository.\n\nColin Hercus updated novo2sam.pl to support gapped alignment by\nnovoalign.\n\nPetr Danecek contributed the header parsing library sam_header.c and \nsam2vcf.pl script.\n"
        },
        {
          "name": "ChangeLog.old",
          "type": "blob",
          "size": 113.640625,
          "content": "commit db2ad3e19068cbafde72ecde75d0638bbb3598ba\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 16 14:45:17 2012 -0500\n\n    removed downsample.c\n\ncommit 6c55c576903992c6fef148fe3b606fbc8bd10655\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 16 14:45:06 2012 -0500\n\n    print to output\n\ncommit db1044a34e6049c87eaa63c39ed6e56f03e7d4c1\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 16 14:39:34 2012 -0500\n\n    removed sample\n    \n    Downsampling already exists in \"view\". View also keeps pairing while \"sample\" does not.\n\ncommit ffdeed3e5d4a530bfdf6f9ba97fff0ba7add6cba\nMerge: 2daad7b accf026\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 16 14:22:15 2012 -0500\n\n    Merge branch 'master' of github.com:lh3/samtools\n\ncommit accf0260fd1117e10047344345d40b31a9ec31bb\nMerge: 9134e0d c554160\nAuthor: Heng Li <lh3@me.com>\nDate:   Thu Feb 16 11:21:14 2012 -0800\n\n    Merge pull request #8 from nh13/master\n    \n    Patches\n\ncommit c554160df16ec7748cfdda4c7b54c641be7b809f\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 14:06:52 2012 -0500\n\n    * more README.md work\n\ncommit 2a81ffe349208d917666808fbc9f3041e0cb57de\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 14:06:10 2012 -0500\n\n    * more README work\n\ncommit fb3125f732715f62cded8685a23a002a96ce009b\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 14:05:19 2012 -0500\n\n    * more README work\n\ncommit 444d41002c37e1c3d0f9208b4a88126c47276386\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 14:02:13 2012 -0500\n\n    * updating README\n\ncommit dec53cb1043fe7efadfde75fa2fd39b76de22e54\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 13:55:01 2012 -0500\n\n    updating the README for markdown syntax\n\ncommit 798da18c346dca8ec6005582a0ddb1d5420b04ca\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 13:48:35 2012 -0500\n\n    adding a README with the current differences between this repository and\n    the official one\n\ncommit 4d22d86c0f28636662f2144a88cd168e104c4275\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 13:35:03 2012 -0500\n\n    adding \"samtools sample\" to the main\n\ncommit 893c25a37c21005dc42f45d45e9ad78ddc5f29bb\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 13:33:51 2012 -0500\n\n    * removing some compile flags to work with OS X\n\ncommit 7ac22f72fdc32edd5c24af6baebfa7db5faf8e7b\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:47:14 2012 -0500\n\n    Check write filehandle after opening for write. tamw/tamr is a union type, so change is only semantic.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit fef53330416631690f60fdff42b6e43d764170dc\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:44:59 2012 -0500\n\n    Catch and report invalid BAM header, instead of segfaulting later on.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit 5cc013fe4930bf9b6e7963aab1cd4a3c94f695bc\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:44:16 2012 -0500\n\n    Add downsample to examples.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit b3fa9e7071532905a81dc7aa48eadc24b8c8846b\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:43:48 2012 -0500\n\n    Adjust for leading hard clip on colorspace reads.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit 1a9296c1389469d1c1db5b8069f0e11ffcc8abb2\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:42:52 2012 -0500\n\n    Add samtools sample command, contributed by Davide Cittaro <davide.cittaro@ifom-ieo-campus.it>.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit 2a804f3379748aeba944f1dec306dd726ff3235e\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:42:07 2012 -0500\n\n    Add samtools qa command, contributed by Roman Valls Guimera <roman.valls.guimera@scilifelab.se>.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit 0f3207fe8fd93e44d40fcf57204079c8c06d24a6\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:39:08 2012 -0500\n\n    Makefile cleanup - allow CC, CFLAGS, LDFLAGS to be passed on make command line. Use LDFLAGS in samtools compile.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit 6e7df604025f6a86881bf7f4a16f30e15d31538a\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:31:15 2012 -0500\n\n    Allow max_mem for sort to be specified with units.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit f12ebcaf6e60d34180a27d70e09b743cef140b98\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:29:11 2012 -0500\n\n    Allow user defined [lowercase] tags in header elements.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit 50b931fa3312dc109537a4260698ddecd0f06a05\nAuthor: Jonathan Manning <jonathan.manning@lifetech.com>\nDate:   Thu Feb 16 10:27:11 2012 -0500\n\n    Check lowerbound in text entry box to avoid segfault in tview. Remove redundant call to bam_aux_get.\n    \n    Signed-off-by: Nils Homer <nils.homer@lifetech.com>\n\ncommit 5e729da5190949a813d20d329eab7ddb661816bd\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 10:31:48 2012 -0500\n\n    * fixing overflow/underflow in integer parsing\n\ncommit fa50a4330b9abedaf07c26e13d31f05e57f1d319\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 10:30:40 2012 -0500\n\n    * updating help message for samtools depth\n\ncommit 79e52c9624b6dd3bdfdf439f4b4bc6f774c230a4\nAuthor: Nils Homer <nils.homer@lifetech.com>\nDate:   Thu Feb 16 10:29:32 2012 -0500\n\n    * adding support for outputting a circos histogram file in \"samtools depth\".  Use\n    the \"-c/-B\" options.\n\ncommit 2daad7b52daa86561c0fb65fe366691fad9f5ed3\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 16 09:31:57 2012 -0500\n\n    bugfix: wrong SP; missing DV in the VCF hdr\n\ncommit 9134e0d5047c281ef3bd53da91771d4814a5131c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 8 11:19:12 2012 -0500\n\n    missing support of DV\n\ncommit 34ebf12078c1d1015a0b8b9a9221243a60b22893\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 8 11:08:56 2012 -0500\n\n    new BCF DV format: number of variant reads\n\ncommit 9589d3312fa2d076f48bdd68e2a5edd419c8070c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Jan 10 10:30:27 2012 -0500\n\n    scale depth to quality (hidden option)\n\ncommit 704473e14668333ecaca5fb7b238af405c43e3b1\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Jan 10 10:18:17 2012 -0500\n\n    really nothing\n\ncommit 01b307fd287962372bbf07461c88b54f41636817\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Dec 7 13:07:42 2011 -0500\n\n    added an example containing 'B'\n\ncommit c678791f0451ceb9205c1ab5c52c84641863c99a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Dec 3 12:10:30 2011 -0500\n\n    'B' now moves backward w.r.t. the query\n\ncommit 152119bc06a073933ca830e8e1407538e44626cc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Dec 2 10:50:12 2011 -0500\n\n    better consensus; a little more robust\n\ncommit 454da4754ac503edda5b1329b67757d797e46e07\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Dec 2 00:20:22 2011 -0500\n\n    in pileup call remove_B()\n\ncommit ff2bcac1cc078ba1879f18c89cfae314439d7086\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Dec 2 00:17:32 2011 -0500\n\n    working on a few toy examples\n\ncommit 745ca7260158d6df7897b52598033ffb055a9e4f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Dec 1 22:55:39 2011 -0500\n\n    bam_remove_B(); not tested\n\ncommit 07e4cdc7300abfcc82e03105b4689f95cab551cd\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Nov 10 12:58:55 2011 -0500\n\n    baseQ threshold on plain pipleup; removed -E\n\ncommit 322ebf2082dfa91df44b3a996d26c85357e5d5a2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Oct 19 09:28:04 2011 -0400\n\n    fixed two gcc warnings\n\ncommit a632457b4c4adc50d833b56b5a5231feafaf8193\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Oct 4 10:13:23 2011 -0400\n\n    change size_t to uint32_t in bam_header_t\n    \n    This may cause issues on 64-bit big-endian machines. Reported and fixed by Paolo Emilio Mazzon.\n\ncommit af31bf5a78aea03baf6eb90fe50076549d499f6e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Sep 26 20:17:57 2011 -0400\n\n    rename pad2unpad to depad\n\ncommit 77b198b73dfad1048e5d1c5a64aa75ee7b90f596\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Sep 23 01:22:40 2011 -0400\n\n    convert padded BAM to unpadded BAM\n\ncommit adb9e2342b7b7501d9527d3c23afab10469ae2c6\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Sep 7 11:40:50 2011 -0400\n\n    generate template cigar with \"fixmate\"\n\ncommit 46e5ab445a0fe880216cbc0daf1225725b569d7a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Sep 2 12:50:18 2011 -0400\n\n    update kseq.h to the latest version\n\ncommit 68e9e4a73eb91405bb3e56bf0cdaf12d1b487abb\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Sep 2 12:44:45 2011 -0400\n\n    Release samtools-0.1.18\n\ncommit aa06bdadb2d109a79f927f478102f96a1f5fd258\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Sep 2 12:14:17 2011 -0400\n\n    updated the revision number\n\ncommit 267e1e1b6e54c0ab24f94cd9aee9cbd2d1923f9f\nMerge: 19ff1d3 aebab30\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Sep 2 12:13:08 2011 -0400\n\n    Merge https://github.com/lh3/samtools into reduce\n    \n    Conflicts:\n    \tbam_md.c\n    \n    Fixed a few typos in the merge\n\ncommit aebab302399c24eaa6c5ab79d13d6bd5e2e9ea9a\nMerge: c2c63d0 da62663\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Sep 2 09:03:49 2011 -0700\n\n    Merge pull request #4 from peterjc/x_equals2\n    \n    Implement basic support for =/X CIGAR operations\n\ncommit 19ff1d3d7f47d7e61b121292aefe5a74bb8a18d2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Aug 25 16:38:12 2011 -0400\n\n    reduce BAM size (experimental)\n\ncommit da626630fd98fd4e07ceb4d58c5c9a42d312a85d\nAuthor: peterjc <p.j.a.cock@googlemail.com>\nDate:   Mon Aug 22 06:58:08 2011 +0100\n\n    Support =/X CIGAR operations (treated like M)\n\ncommit 461d8003529db77a4d5ecbd108312e868b051a3d\nAuthor: peterjc <p.j.a.cock@googlemail.com>\nDate:   Mon Aug 22 05:52:56 2011 +0100\n\n    Define CIGAR equals and X operationss (7 and 8)\n\ncommit c2c63d067113baab41f3bc35fb28f4f00578accb\nMerge: 7ab3ef3 9a0ed9a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Aug 18 17:21:54 2011 -0700\n\n    Merge pull request #3 from peterjc/x_equals\n    \n    Accept SAM files using = in CIGAR (treats X and = as M)\n\ncommit 9a0ed9a6b85c7981465f459300208dbd93e3c6f5\nAuthor: peterjc <p.j.a.cock@googlemail.com>\nDate:   Thu Aug 18 19:28:52 2011 +0100\n\n    Accept SAM files using = in CIGAR (treats X and = as M)\n\ncommit 7ab3ef388c1eb34d7912fd70cc5656c955240263\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Aug 8 10:22:22 2011 -0400\n\n    bugfix: indexing takes huge memory\n    \n    This happens when an unmapped mate has coordinate 1. Thank Joel Martin for the fix.\n\ncommit a3f6738593e944354a8f75306687d8b3acf08bf1\nMerge: a8bdca9 bc67ea2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Aug 8 09:52:26 2011 -0400\n\n    Merge branch 'master' of github.com:lh3/samtools\n\ncommit bc67ea225da653f36a70b38382d6111dd494f659\nAuthor: Petr Danecek <pd3@sanger.ac.uk>\nDate:   Thu Jul 28 20:03:16 2011 +0100\n\n    Variant Distance Bias\n\ncommit deb578f0c49d0b7d8c3bc6be220b4d67e2e7dfdf\nAuthor: Petr Danecek <pd3@sanger.ac.uk>\nDate:   Tue Jul 26 09:57:37 2011 +0100\n\n    If there is only one RG tag present in the header and reads are not annotated, don't refuse to work but use the tag instead.\n\ncommit a8bdca9cf482a637b89ee4f98469a93e0ab5e69b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Jul 25 10:10:55 2011 -0400\n\n    bugfix: LRT2=nan\n\ncommit 0afe33137d046a3e849eeb4a54590f27cbad4228\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jul 22 21:55:38 2011 -0400\n\n    fixed a bug/typo\n\ncommit 62d5849658c10222d40308c6b53ab4f99a448494\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jul 15 16:04:19 2011 -0400\n\n    allow to set see in subsampling\n\ncommit 5f46243824cc9435b167973e1d51e13128794ea1\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jul 15 15:54:47 2011 -0400\n\n    support subsampling\n\ncommit 5e55b6f34fc86cba7cf98d52ccaed405c3ffabbc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jul 15 15:53:38 2011 -0400\n\n    support indels\n\ncommit f31c162926d6f43e8b60171789a258d02e1f9be5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jul 7 17:02:33 2011 -0400\n\n    do not count indel with \"view -Y\"\n\ncommit e412dae587883b4c17e5fbf4b7c33f38bfa8458a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jul 7 00:35:25 2011 -0400\n\n    for WIN32 compatibility\n\ncommit 70a52501bcfa63824749893a5ab8ed3c38e34958\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jul 7 00:32:46 2011 -0400\n\n    for WIN32 compatibility\n\ncommit 00438f14ed5984f08e8f7645a9b95644a812f969\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jul 6 23:41:45 2011 -0400\n\n    fixed an uninitialized variable\n\ncommit 7609c4a01059c326544b3d0142dfe9c4229d68c6\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jul 6 23:39:31 2011 -0400\n\n    fixed an uninitialized variable\n\ncommit cec7189a412f80ccb068a73bd28528915c16b0bf\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jul 6 22:53:19 2011 -0400\n\n    Release samtools-0.1.17\n\ncommit 93c06a249de3bb666029bf07b66de5e8e5e314fa\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jul 6 09:46:09 2011 -0400\n\n    bugfix: incorrect idxstats for the last seq\n    \n    Again, this bug is caused by 3rd-party code for the sorting order checking.\n\ncommit 84f6ca62db6e27b8c4c711e7b5f3ca704bf27b4f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Jul 5 23:30:23 2011 -0400\n\n    output mapping quality in the old pileup format\n\ncommit 362e05fd670886acaede69b864903d730b9db3ca\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Jul 5 21:59:22 2011 -0400\n\n    added a brief description of the VCF format\n\ncommit e690a696468205e0cc4560016361c997660dd496\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Jul 5 16:23:10 2011 -0400\n\n    improved samtools manual page\n\ncommit 362b4a1408ef3c32311d638aa8d85ce39c1c7b2d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Jul 5 15:58:29 2011 -0400\n\n    merge bcftools.1 to samtools.1\n\ncommit 643e0e61ba7266efbc9e5bfcb8e41f369ba2ce0a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Jul 5 13:39:02 2011 -0400\n\n    mpileup: when region set, set reference properly\n\ncommit 613e4d67624a94f62563935fbd5cc294df69605a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Jul 4 23:29:02 2011 -0400\n\n    compute the min PL diff\n\ncommit 5b7d5d3f52b97ca42c8500eede808dab88a46a53\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Jul 4 22:57:48 2011 -0400\n\n    rename trio.c to mut.c\n\ncommit 84fe96ad64b0365ead93a4115d1684b9bebb98fc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Jul 3 15:38:51 2011 -0400\n\n    added pair caller interface; not tested\n\ncommit 2f2867b87b84c35319cc416d6173819d5c8a4e8c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Jul 3 15:24:23 2011 -0400\n\n    inital implementation of a pair caller\n\ncommit e97653cf2ad653c95886933c42a2b5492ccab5ff\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Jul 3 00:06:28 2011 -0400\n\n    convert bam to single-end fastq\n\ncommit e8013e11f7a8db0a8d18c60d130169cca39bf2bd\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Jul 2 14:39:18 2011 -0400\n\n    improve BED parsing\n\ncommit 1025714325fdc636aeee47a76db8dafbbbfde64b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jul 1 14:19:54 2011 -0400\n\n    update the manual page\n\ncommit 8022d0039dff47b1c11b2421357d510c1f28ae15\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jul 1 14:17:03 2011 -0400\n\n    output the best constrained genotypes in trio\n\ncommit 18c87295e12f5bebafdcae00d52000fb94c8a566\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jul 1 11:18:14 2011 -0400\n\n    added documentations for view -T\n\ncommit daf7a8d96bd495296bf7c7d99cddb808a3ced7d5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jun 30 22:45:20 2011 -0400\n\n    fixed a bug in writing SP\n\ncommit e5c32bf9b28c6e3e861db88de56b5dbe11058b61\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jun 30 22:35:25 2011 -0400\n\n    optionally output read positions in mpileup\n\ncommit 1008051155ec994c1901e18f3eb03ea32a62e5d7\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jun 30 22:17:25 2011 -0400\n\n    make faidx works with <2GB lines\n\ncommit 2daebb63762425dd3074ddf71582ad189001e394\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jun 30 17:28:58 2011 -0400\n\n    fixed an issue in the trio caller and the indel caller\n\ncommit 9fdd52cf0716fb342a94946433d564b28b230835\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jun 30 13:34:01 2011 -0400\n\n    Added trio caller; NOT tested yet\n\ncommit ea22a8ed83625e9c82382b56acc42a2d9cfd17e5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jun 30 11:42:29 2011 -0400\n\n    convert PL to 10-likelihood GL\n\ncommit 10d7065267b0d12c2bfcb6c70204fb6944cd395d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jun 30 10:49:05 2011 -0400\n\n    fix a compatibility issue with the new bcftools\n\ncommit d340f01f609c61b719d38a6a55629a3fc899e1cd\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Jun 26 23:41:20 2011 -0400\n\n    allow to ignore RG\n\ncommit d6321faf98ebfe899b9409fb23c90a4aa8c6b542\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Jun 5 23:05:21 2011 -0400\n\n    fixed a bug in SO checking due to a recent change\n\ncommit bc995abf666d0c9ab4258f6c1b3518a45a89209f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jun 3 14:45:36 2011 -0400\n\n    update the version number\n\ncommit 9e7cd83a08383858d008e0ccb2238a2b93831d6c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Jun 3 14:43:12 2011 -0400\n\n    smarter way to parse a region string\n\ncommit e58a90a0fde54053dac65352b34c13c3fea815fc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jun 1 14:36:22 2011 -0400\n\n    output LRT2 instead of LRT1\n\ncommit 08f78c9af3e5661f04f80bef424232de721dba03\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jun 1 14:02:28 2011 -0400\n\n    genotype test, but assuming 1-degree\n\ncommit 587b852340d7e60f6f7cf474a92ef77aeab46018\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jun 1 12:55:19 2011 -0400\n\n    perform 2-degree test by default\n\ncommit 3d38e403c5c830478b7eb157a484776997440501\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jun 1 12:44:34 2011 -0400\n\n    fixed a typo; but the result is still not good\n\ncommit 06291624f7dcc57445676f3be25d0bc355dd7110\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jun 1 12:24:18 2011 -0400\n\n    fixed a typo\n\ncommit 63b98aa33636b0d82a435bf49153c8c1502e7d42\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jun 1 12:23:37 2011 -0400\n\n    added HWE+F<0 filter\n\ncommit 37d926e8999999b593d0637ab7dc379dbd3d6006\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed May 4 10:11:59 2011 -0400\n\n    improved sorting order checking in index\n    \n    Patches from Jonathan Manning\n\ncommit 1c2dc6762c5f7cd946046b53346513f2f9761dbf\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue May 3 23:09:05 2011 -0400\n\n    added r^2 estimate; added Brent's method\n\ncommit c2d3bcd8f98e31668b5f1321222fbc6fd6336e75\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun May 1 23:45:23 2011 -0400\n\n    combine several utilites into vcfutils.lua\n\ncommit be2e7362d7593ea4d03fb33cdb6af2aa096ca6c4\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 27 21:09:22 2011 -0400\n\n    minor warning\n\ncommit 683ef0443860813d743cf84fa86dda9bfaf5445a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 27 10:10:38 2011 -0400\n\n    added versioning\n\ncommit ed72f25ec85671f7646dbc92fa7b5b1dda427f7d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 27 10:04:02 2011 -0400\n\n    Output ML allele count\n\ncommit 2a9e36d2d6c405b2411ca47458f028ada8fe1000\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Apr 26 16:14:20 2011 -0400\n\n    use ar -s\n\ncommit 7a4f54e6dbcd7c94acbb3f1050a93f94b8a07949\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Apr 23 01:22:31 2011 -0400\n\n    added another type of LRT\n\ncommit b9c5e84762a4aacce3a3771b51ea80967c79a2e5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 22 16:00:31 2011 -0400\n\n    added version\n\ncommit 8fad6677c5952efd67391581d64e67e02e7f6e68\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 22 00:30:19 2011 -0400\n\n    remove the pileup command\n\ncommit 3a962fb6ebf779de70f9e6effb2d8701a9aa3dd9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 21 23:10:45 2011 -0400\n\n    Release 0.1.16 (r963:234)\n\ncommit b4d683cffbd98c43f05aff8610b37d63dd7e54aa\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 21 12:44:44 2011 -0400\n\n    fixed a bug when coordinate-less reads are on the reverse strand\n\ncommit c5ec45a128f409debc6a56a798024f53004037dc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 20 11:36:52 2011 -0400\n\n    added option '-f' to merge to avoid overwritting\n\ncommit 68d431531370d24907c01a27f166f2341d7c4d35\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 20 10:26:58 2011 -0400\n\n    do not print a warning\n\ncommit 32922607e51ad2260c337eb022b9e4aedacb049f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 20 10:21:06 2011 -0400\n\n    Added ldpair to compute LD between requested pairs\n\ncommit b8d6fa71b91678fa02338257e0707d1e5ca098dd\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Apr 17 21:51:43 2011 -0400\n\n    On a toy sample, type \"B\" seems to be accepted\n\ncommit 0e7ee9a6bb4029184202aa6e6738105ba0c0510b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Apr 17 21:21:20 2011 -0400\n\n    added type \"B\"; not tested yet\n\ncommit a513dfad0ac0062b03871eb6ecf26cb8d18dc895\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Apr 17 19:25:54 2011 -0400\n\n    fixed a bug in bedidx.c: input BED not sorted\n\ncommit de1e192bb0a8a762a54a6eee81d882fab01c3d32\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Apr 17 18:51:08 2011 -0400\n\n    by default, always perform posterior chi^2\n\ncommit df6e0d1099895fc6cd7a19dc89fba95ed6654d35\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Apr 16 12:33:28 2011 -0400\n\n    added debugging\n\ncommit 8ce52e024dc2ef361dbd5399c232163055057e70\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Apr 16 00:59:05 2011 -0400\n\n    avoid a segfault given wrong input\n\ncommit e66b6684fc9a397f91ec29fdeecae9f8eb986a55\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 15 19:55:39 2011 -0400\n\n    do not segfault when there is no PL\n\ncommit 9ce3c584ec0cebfa45576f2ef538df4dad2b7e55\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 15 11:59:55 2011 -0400\n\n    remove another unused part\n\ncommit f53a051d68bf312ac8d5865210fae7a9808c0fb9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 15 10:41:25 2011 -0400\n\n    print G3 if HWE is small\n\ncommit 4b2c08bb86ca4ed4959e4cb77a28f7d6fc19f5c9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 15 10:04:34 2011 -0400\n\n    fixed a bug\n    \n    actually not fix, but hide it\n\ncommit 088e13c32453fb533b7bb1c65a573f9b90a23625\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 15 09:48:47 2011 -0400\n\n    added LRT based permutation; not used though\n\ncommit 1e3c2001afcb80b5eaa4c3f88df9da7b01b62524\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 15 09:28:55 2011 -0400\n\n    Perform posterior contrast for small LRT\n    \n    Posterior contrast is much slower than LRT. Nonetheless, posterior P-value is\n    more robust to sequencing artifacts. Thus we may combine the two to achieve a\n    balance between speed and low FPR.\n\ncommit 6f1b066270902198a7175ff6c1b05ebc8d1919be\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 15 01:36:06 2011 -0400\n\n    Added Brent's method\n\ncommit 3d061e5db25b67b25f6ff87afe4162e121354232\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 23:30:10 2011 -0400\n\n    fixed a typo in printing\n\ncommit 7fd14ceb5990bb350b8e97346ef3537d80058def\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 23:14:23 2011 -0400\n\n    fixed a stupid bug\n\ncommit f5b2c3459ec098b3cafd9619b9077132516baf58\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 22:42:35 2011 -0400\n\n    separate EM and posterior\n    \n    Now, constrast is not performed unless -C is in use. EM can be invoked\n    independently with -e without computing the posterior.\n\ncommit 9eefcac963697fae554789b11ae3cb2c23f224d0\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 22:00:19 2011 -0400\n\n    further code cleanup; prepare to add EM interface\n\ncommit c2cce52355262743711e4742b0c8542bfcab1cdd\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 21:44:03 2011 -0400\n\n    drop EM from prob1\n\ncommit 24016f04bd3bdffb7eeb50cb25854f5007feb70f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 21:08:33 2011 -0400\n\n    drop posterior LRT; prepare for clean up\n\ncommit 3670d8bd88c3eb22873f0a80e2a5913f64ca8c9a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 20:57:43 2011 -0400\n\n    better initial values for LD\n\ncommit d48a8873c060b18b57799cfe3a0e5496ba069457\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Apr 14 20:36:25 2011 -0400\n\n    finished EM\n\ncommit b101f2db476188a950c23f5c1b6185fdb7f8f40b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 13 01:19:04 2011 -0400\n\n    genotype frequency estimate\n\ncommit d79bdcbf6242ecfb8accba9ac9a22fbcbd543cf2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 13 00:37:22 2011 -0400\n\n    prepare for code clean up\n\ncommit e0ce416abfc094f0c090957080b1404fd0edf752\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 13 00:34:15 2011 -0400\n\n    rename ld.c to em.c\n\ncommit 45ede3ad181f35c1be24bed5d75841e472357ab7\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Apr 13 00:22:10 2011 -0400\n\n    implemeted EM likelihood ratio test\n    \n    The idea is learned from a brief chat with Rasmus Nielsen.\n\ncommit 0454a346b60e42b75a2f742272089810279c7131\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Apr 12 15:45:52 2011 -0400\n\n    added likelihood-ratio test (idea from Nick)\n\ncommit f6287c8646c690440a1554c8958e7268f4134dc2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Apr 10 18:24:37 2011 -0400\n\n    Release samtools-0.1.15 (r949:203)\n\ncommit de6023f38f4d652438557cf7a0ac6eec324e7416\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Apr 10 15:54:58 2011 -0400\n\n    improved help information\n\ncommit d3b337f2b7eda1e6f8f5575a19d1b5ed55cae279\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Apr 9 16:28:01 2011 -0400\n\n    fixed a minor issue\n\ncommit 82f6e4f49247e75fbd8ec08c285b8d3047b3d235\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Apr 9 15:49:04 2011 -0400\n\n    separate QC-pass and QC-fail reads\n\ncommit 8362b4a255081ee7ca0a4ca2eabc8c76758b6863\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 8 17:45:19 2011 -0400\n\n    added verbose level\n\ncommit f7bf419c290462be7d289249a4a6d28f825b4c93\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 8 16:08:14 2011 -0400\n\n    fixed a bug\n\ncommit 890cbb1ac93b3004fb6cf42ff47195077dcfc8ad\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 8 16:00:37 2011 -0400\n\n    drop unrelated @RG when \"-R\" is in use\n\ncommit a62dc929c950fb51311b705f5b5bfba8e3f704d7\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 8 16:00:14 2011 -0400\n\n    skip header validation\n\ncommit 39da810e2c56c8f0eff1ab726600b41f26d3d8e9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Apr 5 23:52:22 2011 -0400\n\n    change error message\n\ncommit c0c50a34df250ef8a7a29b172058cd229be582b5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Apr 5 23:50:46 2011 -0400\n\n    fixed a bug caused by recent modifications\n\ncommit 25226e8c468404cb5e1b5272efcea57e4193c762\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Apr 5 13:31:19 2011 -0400\n\n    reduce the indel filtering window\n\ncommit 5e18d7014437734f9dac9ab45a95e43ec2526101\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Apr 4 13:56:20 2011 -0400\n\n    only output hwe if it is small enough\n\ncommit 614941fb7dd276de662e7820eb8c7bae871a18cc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Apr 4 13:34:02 2011 -0400\n\n    added HWE back\n\ncommit 7abe8825aa0bacccdeb38125934ae94d18f0ad4d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Apr 4 12:46:24 2011 -0400\n\n    EM estimate of genotype frequency\n\ncommit 2bfeff9c645d177416664f1cb811e85cac3ff9e3\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Apr 4 11:29:12 2011 -0400\n\n    minor\n\ncommit 401e40647e7e3abbac6e4ec3d8bb68eb6f2d401b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Apr 4 11:24:04 2011 -0400\n\n    Added genotype freq estimate and association test\n\ncommit 6cc226df6e3b480f1bd6e763ce8ef47f785bbb74\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Apr 3 20:57:23 2011 -0400\n\n    minor changes\n\ncommit 7e47a39630e812f09b80369f14606245976f687e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 1 15:21:59 2011 -0400\n\n    print the grayscale\n\ncommit 2f675d9c0dde3c166c99e335fa17c7873a5ae8d5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 1 08:55:16 2011 -0400\n\n    change to comment\n\ncommit 0592bb514994544ed84f51e509b233cf8821e0cf\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Apr 1 08:54:35 2011 -0400\n\n    added base quality filtering\n\ncommit fc1b47e04a7b94f6362c45856cbeb89d9d0b5ca5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 31 23:31:14 2011 -0400\n\n    fixed a few typos in comments\n\ncommit 60be79bc8f0d24656e5e8a329af7e9b5b91d4c8b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 31 23:13:23 2011 -0400\n\n    comments\n\ncommit 2432864acc25ebe5cee4217dbb0120439077a7f8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 31 22:42:46 2011 -0400\n\n    added bam2depth.c, a demo program\n\ncommit 39625f7c6bea9ccbfd9af0feb22348d52079f012\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 31 16:37:22 2011 -0400\n\n    added bgzf_check_bgzf() (used by tabix)\n\ncommit 6de6bd3fb67fd22753a5f07d4cc25bf94e1b5a8c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 31 16:37:08 2011 -0400\n\n    fixed a bug in bedidx.c\n\ncommit 3b9e257d25b2e81eed1625bc5d2882ed486ef20e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 30 13:27:15 2011 -0400\n\n    added bed support to bcftools\n\ncommit 47bcce3d14ec4d205283b61e5e653803996c42e0\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 30 12:56:40 2011 -0400\n\n    Added BED support to \"samtools view\"\n\ncommit a812386017faedfc86c0e6562adbb2138329cfeb\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 30 12:47:04 2011 -0400\n\n    support BED file\n\ncommit 3052dddc929f1825e6e7f7f6f6724d9465d6cf9a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Mar 28 15:51:55 2011 -0400\n\n    relax RG matching; proper mismatching message\n\ncommit f86d60c8fe25785523f01fae1486d2a6df4ee6ef\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Mar 26 10:38:23 2011 -0400\n\n    Avoid reporting association when something unexpected, which I do not understand, happens.\n\ncommit dd41e6b26fd9fe30218748b9a0a1f49bdb1862b9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Mar 26 10:38:01 2011 -0400\n\n    Added -1 to merge\n\ncommit 4a0364b0d7f87f1c88d71ec5857a1f1d40710681\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 23 16:56:55 2011 -0400\n\n    plot pairwise r^2\n\ncommit 452629a711582e612bec22b3b082e234bd37039b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 23 14:31:01 2011 -0400\n\n    pairwise LD; case-control AF2\n\ncommit 52862951adcaecde26ba8f0d9c1897944640a674\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Mar 21 23:03:14 2011 -0400\n\n    Release samtools-0.1.14 (r933:170)\n\ncommit 59a5a8ba8e2940f0e38238f9339f02c91a8a0ce4\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Mar 21 13:52:55 2011 -0400\n\n    optionally skip loci with too low sample coverage\n\ncommit 6434264b5c69514d4fafe62cbd30b3bbaddc1d41\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Mar 19 14:38:25 2011 -0400\n\n    mpileup support Illumina1.3+ quality; skip non-variant sites when \"view -v\" is in use\n\ncommit 5f59e01987e1d5eca7d6359cae64a9734b18beea\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 18 17:19:18 2011 -0400\n\n    update version to r933:167\n\ncommit 4d2c3c950910aa3d2c87760c3532e458fe01c0fa\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 18 16:25:01 2011 -0400\n\n    added \"-1\" to the command-line help\n\ncommit 55313a015a7bd6369cf5a66fed7fab2333201dc9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 18 16:22:12 2011 -0400\n\n    added the \"cat\" command (by Chris Saunders)\n\ncommit b670272cadf3efa4dc456ac4c76104f73477d60d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 18 15:59:46 2011 -0400\n\n    support varying the compression level\n\ncommit c5dd3c9ca5f75f880e52c8cd2beae983bcb8d3b1\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 16 14:33:45 2011 -0400\n\n    update the manual pages\n\ncommit 12fb4b596dc51bccd154fc4bd0593442f7937a46\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 16 12:49:26 2011 -0400\n\n    update changelog\n\ncommit e7fe4fd66e02d60a1ca7952ad1938809e77729a9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 16 12:10:05 2011 -0400\n\n    do not call indels when the depth is very high\n\ncommit 7455eeaa32b949bb3856f75810890aabf7cacb18\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 16 11:56:56 2011 -0400\n\n    code clean up\n\ncommit 5f16679e54ced8e67a75d949f9175c50480b914e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Mar 15 14:45:24 2011 -0400\n\n    when -s is specified, change the sample order\n\ncommit 7ba95adee09d3b06a7eaf797d25efef837e592f5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Mar 15 14:11:42 2011 -0400\n\n    compute the rank in permutation\n\ncommit d219783cea7643fc7e10e1bd3a98e9b3165b4506\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Mar 13 21:35:13 2011 -0400\n\n    I have found a SERIOUS BUG!!!\n\ncommit 8e20d04ecdac1a7788eef71c4bb91b8479cf7150\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Mar 13 17:04:04 2011 -0400\n\n    optionally shuffle samples in a BCF (debugging)\n\ncommit fc7b261f181f2a411427bc9ee5d586c883ca9cdc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 11 09:34:20 2011 -0500\n\n    fixed a bug\n\ncommit b3bbcc3d40994ae85705ab6fef9866ec8c142201\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 10 20:25:59 2011 -0500\n\n    use mode instead of mean\n\ncommit f1161262d137098a19143b5cb0de810e5db3243e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 10 20:09:16 2011 -0500\n\n    start from the mean instead of the mode\n\ncommit 2ba56f5e99e90674855c4ffc8bf583340b932e1e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 10 17:13:34 2011 -0500\n\n    fixed an error in Chi^2 test\n\ncommit b4ce7ae400290bc43dd287240479667f99b3b11e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Mar 10 00:23:39 2011 -0500\n\n    minor\n\ncommit 8487fa5d3a73a43443964e731ea2a4c873c9d4e5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 21:33:19 2011 -0500\n\n    added -F to accept BCFs generated by old samtools\n\ncommit fd51d2093f7fd775a7eaaeea57fa34716ab59ac2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 17:39:09 2011 -0500\n\n    update version\n\ncommit b6da54335df943015a998a934075331b467abb5b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 17:37:14 2011 -0500\n\n    compute pseudo-chi2 probability\n\ncommit 9f73cefdb8935421d872b989dd98fbc8e1295029\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 15:54:04 2011 -0500\n\n    remove a comment which is wrong\n\ncommit b10b1e47ece522e97ab8ef23417bcb6454f8b9db\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 15:51:12 2011 -0500\n\n    clean up\n\ncommit 353bfae2c6ff59205bd9223db04084cf7f507f01\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 15:45:29 2011 -0500\n\n    for backup\n\ncommit 53915d1c6410c2537d18bfa8eb8c657a2233c35e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 15:27:56 2011 -0500\n\n    having debugging code\n\ncommit 0d0dbf66995b1511390d593981eae7b5d36fe17b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Mar 9 14:58:23 2011 -0500\n\n    temporary backup\n\ncommit 5b74a174a8b637dee43b7f30250df6fb96580e12\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Mar 8 15:46:11 2011 -0500\n\n    the output makes sense, but there may be a typo...\n\ncommit d81ec654b6c0c1eef6b0625d96f14b3155cee7c6\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Mar 8 15:19:09 2011 -0500\n\n    added contrast2(); fixed a bug in haploid mode\n\ncommit 0cfd896fad5f7737cca49efa94a11892dafcd812\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Mar 7 21:40:17 2011 -0500\n\n    fixed a bug in haploid genotyping\n\ncommit ccd52155ef61273f2b42ad9c7b31ff1915f81b24\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Mar 5 18:10:35 2011 -0500\n\n    fixed a few bugs; still not fully working\n\ncommit edc3af753f96f831968ae32f2e0f915b74f31e6e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 4 17:31:33 2011 -0500\n\n    drop HWE calculation\n\ncommit 92dac194debb66ca0718c21c871822dda2dd5bc1\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 4 17:28:35 2011 -0500\n\n    implemented hap/dipoind mode; probably BUGGY!\n\ncommit 7f26804bc27937e36fdc967e5c76514653ea40f5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 4 16:01:27 2011 -0500\n\n    read ploidy\n\ncommit e7b7213475b5e61a69aab77ffb02b4983c8e7678\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 4 14:12:14 2011 -0500\n\n    added math notes\n\ncommit 46023e2f21321da83fc8e83e9229757a4e821acb\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Mar 4 13:34:10 2011 -0500\n\n    update BCF spec\n\ncommit 13190c49eeb006ad7013b7f1e9fc1b3beca3ae78\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Mar 1 14:45:19 2011 -0500\n\n    Release samtools-0.1.13 (r926:134)\n\ncommit be8fabbb6001d9fd5263a70a3e21ed6dfe5a9837\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Mar 1 14:07:15 2011 -0500\n\n    prepare to finalize 0.1.13\n\ncommit 1e8c753660978bed7e9289fe50becd596d9314bb\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Mar 1 09:40:17 2011 -0500\n\n    allow to change whether to drop ambiguous reads\n\ncommit 412210bfdb46606023f2e4b9086f2787f0cf1c62\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 22:01:29 2011 -0500\n\n    revert to the old behavior of phase\n\ncommit 46035589518cf84738de8666b866e2619457c1fb\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 16:46:23 2011 -0500\n\n    change version number\n\ncommit 7f40c33e37fc16fcb0a375ce46ae1d09cafb6d50\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 16:37:42 2011 -0500\n\n    bugfix in indel calling: interger overflow\n\ncommit 75849470efbe30042e5ddd516f9bcbe3b9bf6062\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 15:35:47 2011 -0500\n\n    fixed a typo\n\ncommit 9e6fb569885f906fabaab7fc2f02eae82f4bd602\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 15:34:09 2011 -0500\n\n    minor changes to heuristic rules\n\ncommit 30a799a91f5e2c10b761aa5437f902c6649fceb3\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 15:20:26 2011 -0500\n\n    fixed a bug in the latest change\n\ncommit e21ba9df950ea37f5c1b35c2af9ba9a4e0bba02a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 12:47:06 2011 -0500\n\n    put version in bam.h\n\ncommit 918b14780c1dceb39c7010638ecd61c626e17166\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 12:00:38 2011 -0500\n\n    frag_t::phased==0 reads are dumped to chimera.bam\n\ncommit 657293c7bdba3ac69f53cd1ffa2874ed8756475e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 11:05:29 2011 -0500\n\n    change default -q to 37 (previously 40)\n\ncommit 33d8d3bea76e466798ea322d68d34deb8d2dff06\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 28 10:39:57 2011 -0500\n\n    fixed a minor bug in BAM reading\n\ncommit daa25d426d42465d76c7317c95772bbb36bb3f47\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Feb 26 21:07:24 2011 -0500\n\n    suppress gzopen64() warning\n\ncommit 9cec4256eb9e7848d4711adb67b540659c141e32\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 22:14:52 2011 -0500\n\n    fixed a long existing bug in vcf2fq\n\ncommit 304487c83067a733add71cbc3886fa8c49f7ef2a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 16:37:40 2011 -0500\n\n    change version number\n\ncommit 10ba6bf4f16692760f696f7b17f3719065786f77\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 16:34:08 2011 -0500\n\n    Change the order of PL; change SP to int32_t\n\ncommit c5cc2a8036a9c3579fbfde651efec4f6763b0228\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 14:52:03 2011 -0500\n\n    claim X defined in the header\n\ncommit 4ee8cb29f6092fd14a89f0cc5d3575112a204f39\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 14:40:24 2011 -0500\n\n    minor changes\n\ncommit 00065e9336a2831dc53bee7da2f4719845be1a2a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 11:39:06 2011 -0500\n\n    fixed an error in the BCF spec\n\ncommit 1e2a73afcb72a02aa448718cb017c0438de89f90\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 11:36:40 2011 -0500\n\n    update BCF spec\n\ncommit dbf8eedaa38a405cb2fba5b3952b85776f51d035\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 11:28:43 2011 -0500\n\n    update BCF spec\n\ncommit eed1d91af9fad3c9d965333a55e623757f9c4e9d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 09:51:39 2011 -0500\n\n    fixed a flaw in targetcut\n\ncommit 59bc980bb832b92a8b0cc244cf106e6150e4db6f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 00:54:35 2011 -0500\n\n    update manual page\n\ncommit fcc4738c4abdca79e3de159e21208df1b98ac76c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 00:45:39 2011 -0500\n\n    update version format\n\ncommit 5748639ae542b7f6b853562edc2bb3faf43030e4\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 00:45:12 2011 -0500\n\n    update version number\n\ncommit 06b44cc366cf27ce8976ee6a05810a0b3c48b56d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 00:44:21 2011 -0500\n\n    update version number\n\ncommit ab7f4529d12739ff66fd4c09af9d992ab59c53ef\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 25 00:42:55 2011 -0500\n\n    various help message\n\ncommit a092e1f6f963272f8bb23616986ddaf604fd0f82\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 24 23:43:13 2011 -0500\n\n    disable unfinished functionality\n\ncommit f00a78db72b14ee4c6689fc13f20ed31aeaecd40\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 24 10:04:56 2011 -0500\n\n    added \"const\" to bcf_p1_cal()\n\ncommit 91049c4a8db3bf50dcc9d07506f22fa4ca5b5a96\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 23 11:53:47 2011 -0500\n\n    randomly allocate unphased reads\n\ncommit f4405354a8d4cb3441141fa734573031059d7f57\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 22 15:36:07 2011 -0500\n\n    fixed a typo\n\ncommit 3075e4dc5c7c9d954426aabda6a73fa788357100\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 22 15:33:40 2011 -0500\n\n    make output more informative\n\ncommit 628cf3235e2815a40acf089fb1d3357be6437787\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 22 14:50:06 2011 -0500\n\n    change the scoring rule; change default k to 13\n\ncommit f22fd99831e4b5c74f898719216f359dbe987bbf\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 22 14:45:15 2011 -0500\n\n    update scoring in masking\n\ncommit 2f23547b81984555032aa0eefd064b8e07986fdc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 22 14:37:17 2011 -0500\n\n    remove dropreg()\n\ncommit 4d8b6b1f1f331ca9041983c66e34a857c3b8f1bb\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 22 13:10:16 2011 -0500\n\n    accept files from stdin\n\ncommit 9b50c5038e6fc0185e29ca5b50fe0806a9a939b9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 22 11:16:57 2011 -0500\n\n    fixed a bug in consensus generation\n\ncommit 1332ab32fb788fdc81b2ba8653b905d106238fad\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 22:53:23 2011 -0500\n\n    print dropped fragments\n\ncommit a288761b4ca1584e51076a71cbc4d72fe923dda1\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 22:37:04 2011 -0500\n\n    bugfix: singletons are not phased\n\ncommit 683365f534c0223dea7d72532015ac16a45ba22b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 17:27:10 2011 -0500\n\n    output singleton blocks\n\ncommit 841a4609084d81f1bc81e0b00dd806002461e7d9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 15:58:55 2011 -0500\n\n    fixed a bug; not working with -l right now\n\ncommit fdd57ea31732b5516dc212d72174b60206952636\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 15:17:00 2011 -0500\n\n    skip mapQ==0 reads\n\ncommit 4eb6ba75c23c1c9be5f76814fa1b93a2e304b2af\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 14:03:03 2011 -0500\n\n    print the \"targetcut\" command\n\ncommit 0123d9559ba58b026c0dfd15bc26019a193cd21a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 11:22:13 2011 -0500\n\n    allow to set the maximum depth\n\ncommit 0f92eb248a4d06645b2c3d736a0faea8a7a9f731\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 09:56:41 2011 -0500\n\n    use a proper error model to call hets\n\ncommit 587a01504af5aea6288740d121dccf48fb8a75f4\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 21 09:16:38 2011 -0500\n\n    phase is UNFINISHED; strip RG when merging\n\ncommit 723bf3cd79e4f4a558373d4c707fa6b3db0fb357\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Feb 19 23:38:11 2011 -0500\n\n    use a proper model to compute consensus\n\ncommit 891a6b02d4a9af2ed98fbaac4915bf1f0da4f6c8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Feb 19 22:14:19 2011 -0500\n\n    added comment\n\ncommit 8b55e0a581ecc9e4ba754d1f3c8784f3038b6e48\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 18 17:23:39 2011 -0500\n\n    change the output format\n\ncommit 75c36e8c563eddd0a362ba3b38cf0aea21aafb1f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 15 20:31:00 2011 -0500\n\n    fixed a bug in writing BAM\n\ncommit bb0ce52f066cfebaa35a125d57b353bb717a5165\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 23:39:09 2011 -0500\n\n    skip uncovered; unknown alleles taken as X\n\ncommit ba67f4d119c7d06907db3015d337d9a01a3fc9fe\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 23:21:19 2011 -0500\n\n    fixed a bug\n\ncommit e4448d49e6129a5e1ee9c7f04f43612f12d6aad6\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 22:43:09 2011 -0500\n\n    prepare to read hets from a list; unfinished\n\ncommit 129ea29c1f12177c0a7c3e21676f6210370fc59b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 16:32:22 2011 -0500\n\n    updated khash.h to 0.2.5\n\ncommit 15b44ed93bd949dffcf79ac8dbea6d9b7dfcb58c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 16:15:04 2011 -0500\n\n    use the latest version of khash\n\ncommit 486c05f06f44d981dfb2069bcb43e4b35fd8389c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 15:04:40 2011 -0500\n\n    change the default -k to 11\n\ncommit 07cf9d1e443d73cf053de38dd01671e3781f6e29\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 14:50:51 2011 -0500\n\n    sort fragments by vpos instead of by beg\n\ncommit d0d3e7faabf5cbb7e5ff7b294f7e220da807c4c0\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 14:45:41 2011 -0500\n\n    shuffling the two haplotypes for better randomness\n\ncommit 3be28eaf5f6033229aedf12ddb11a0084ba01cd8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 14:09:17 2011 -0500\n\n    write chimeras to a separate BAM\n\ncommit 80ccbc26f43918fe42be123cc1da9d3d7ce30816\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 13:54:13 2011 -0500\n\n    no mem leak/violation on small files; correctness is not checked\n\ncommit 5c923867432fa14c26a19e3782e7f48d4080f6ac\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 14 13:50:25 2011 -0500\n\n    bam separation; at least not immediate segfault\n\ncommit cea2643ec30a59735bf89b2f562b563bf7263e79\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Feb 13 23:24:11 2011 -0500\n\n    on the way to implement BAM separation; unfinished\n\ncommit 964269cd15036a470ca89e43d0952201a0825671\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Feb 13 18:07:56 2011 -0500\n\n    keep singletons in the hash table\n\ncommit 2d4aa649bd670d5e038a1acaefd33c5fe24ae0e8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Feb 13 17:42:24 2011 -0500\n\n    Revert \"prepare to add bam separation\"\n    \n    This reverts commit ed6957e5211c2c4cf684dcb8bbb661052c74df6f.\n\ncommit ed6957e5211c2c4cf684dcb8bbb661052c74df6f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Feb 13 00:24:28 2011 -0500\n\n    prepare to add bam separation\n\ncommit d211e652d93791d2e112d334added243ffe5fc3e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Feb 12 18:50:20 2011 -0500\n\n    accelerate kstrtok\n\ncommit 2d6af49d331ff5afe7b9e9b102e79d7d4512fdbe\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 11 21:08:21 2011 -0500\n\n    split unlinked blocks\n\ncommit 68e4cd1b560b0a6fd4c77e5e51eadde9fda26ea4\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 11 10:47:58 2011 -0500\n\n    remove heading and tailing ambiguous positions\n\ncommit d2b685141426a902ae76660c1fbe8020da150cf8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 11 10:02:21 2011 -0500\n\n    code clean up for further features\n\ncommit c6980e062d55928b59f287c03e599dd5a37ed509\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 11 08:00:08 2011 -0500\n\n    change /64 to >>6; the latter is faster\n\ncommit 91635b9c2687f24d72ee6a8aad2050a79bb8400f\nMerge: 41d4df2 9a7e155\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 11 01:22:55 2011 -0500\n\n    Merge branch 'master' into devel\n\ncommit 9a7e155cc591c1b6c9f7f9cb939364a6becb65b2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 11 01:21:07 2011 -0500\n\n    output an unrecognized field as '.'; autofix GL/PL\n\ncommit 41d4df2e9545e9abe97151cfe5d6c763f3d00db1\nMerge: c00c41c aacce0c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 23:00:14 2011 -0500\n\n    Merge branch 'master' into devel\n\ncommit aacce0ce7276f451e4fddf81832f9e5f7f65198b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 22:57:53 2011 -0500\n\n    finished VCF->BCF conversion\n\ncommit 0e875df643e41d848b709e2fa877de8ae53cdd4c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 21:57:28 2011 -0500\n\n    fixed a bug in reading VCF files\n\ncommit c00c41c2a5da69cccea64adb542a0b365e56b4fc\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 16:28:37 2011 -0500\n\n    suppres one-allele blocks\n\ncommit 2e2354b673722e2f00d72970a043f80a66270da1\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 16:06:56 2011 -0500\n\n    fixed the bug in filtering\n\ncommit d971e1fe24de4ecaf94055efffc5f641e2bdb563\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 12:24:23 2011 -0500\n\n    prepare to add filtering; buggy right now\n\ncommit a0a5a3fbf504c3b02f7b9212e72315c1047cc249\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 11:55:02 2011 -0500\n\n    make masking optional\n\ncommit 28db71ccd95054a5f8a47c2332794f8968f6a822\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 10 11:40:47 2011 -0500\n\n    routine to mask poorly called regions\n\ncommit a3f6c439262bc10a4067860440f4d4dde9e0c515\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 17:18:33 2011 -0500\n\n    code clean up: remove globals\n\ncommit 0b711978492f6ad39d459d78723c299468906818\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 16:52:54 2011 -0500\n\n    output more information\n\ncommit f69d217ae5b691bf42ad07a97f29a7cc6456046f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 16:11:54 2011 -0500\n\n    fixed another bug in flipping\n\ncommit d47882d549337fbcc251597508a2c7faf1bb92e2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 16:01:35 2011 -0500\n\n    fixed a stupid bug in flipping\n\ncommit e33f89de499496537f5fbde396a66557f0353f1b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 15:54:42 2011 -0500\n\n    fix chimeras; a little weird...\n\ncommit 03d3c1d0b945245108ce0942d4772536a32212c7\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 13:27:35 2011 -0500\n\n    no effective change; prepare to fix chimera\n\ncommit 6bc0a4676dd2252085a6e67bb06daa5ae05a554f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 11:52:58 2011 -0500\n\n    better count output\n\ncommit dcac515439d25f71125d6de8111da417776ab9ce\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 9 10:31:07 2011 -0500\n\n    prepare for another way of filtering\n\ncommit ca7e4f1899b86d2e077994c789e8f69d699b3cd9\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 8 16:10:08 2011 -0500\n\n    fixed the bug; I can do better.\n\ncommit 0733f77b98af121bdcb198cea6151d159831bb9c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 8 15:55:38 2011 -0500\n\n    fixed two bugs; still not working...\n\ncommit 80f18cba9ba73c9592380fc1ecd53c351d294782\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 8 15:42:58 2011 -0500\n\n    filter false SNPs; NOT working right now\n\ncommit 69a66e2f96d5b102cd712ff1527a3802fa84c590\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 8 14:39:09 2011 -0500\n\n    write sequence in the SAM format for debugging\n\ncommit b6f1c9d160822af2b713be206f37bd6dde00546a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 7 11:51:21 2011 -0500\n\n    fixed two bugs\n\ncommit 400aa5c06100af9c47cd5e4ce8b95b7deb84f54b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 7 11:22:38 2011 -0500\n\n    Optionally apply BAQ\n\ncommit 4c82e0e19682e424f5cdb8381364114c307b329e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Feb 7 01:23:31 2011 -0500\n\n    improved output; the result makes sense at a glance\n\ncommit dc7853a581ab24bcc496e96b123ccf637e32ed1d\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Feb 6 14:12:43 2011 -0500\n\n    process per linked block instead of per chr\n\ncommit e867d9c6c2e61d9e748e78163e5481dca5697a36\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sun Feb 6 00:45:46 2011 -0500\n\n    DP seems to work on toy examples\n\ncommit 445ad72fc43d4354d56f5f759790e8ae0be73d02\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Feb 5 01:24:42 2011 -0500\n\n    implemented backtrack; not tested\n\ncommit ba38e180b9cd545956583b22e97e09b4bb12073e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 4 23:55:23 2011 -0500\n\n    More \"correct\" DP; backtrack not implemented\n\ncommit d69761fd9351273ccd37ea431b10509add91e7cf\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 4 17:22:31 2011 -0500\n\n    scratch of dynamic programming; unfinished...\n\ncommit 769ffcb44e26e59300791658801d321559b33858\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Fri Feb 4 16:29:55 2011 -0500\n\n    UNFINISHED commit.\n\ncommit 9adab9591317c3467f3d8cdf2d19ec1f65d1b5b7\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 3 16:20:59 2011 -0500\n\n    another way of counting; can be even faster\n\ncommit bbafbdc01ed1ceaab44927def1ad47c4c78aeb9c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Feb 3 14:48:20 2011 -0500\n\n    for backup\n\ncommit eba7446389cad62a19133bced1386a4334dcab79\nMerge: a44a98e f01a593\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 2 14:06:07 2011 -0500\n\n    Merge branch 'master' into devel\n\ncommit f01a5930445b5fda7e6b5b813ed63c652160ada2\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 2 11:31:54 2011 -0500\n\n    Better truncation warning when EOF is absent\n\ncommit dd3ee5ed26c8bbef4a62fa5b2bfb0a75833f2c31\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 2 10:38:28 2011 -0500\n\n    fixed a typo in BCF/VCF headers\n\ncommit b9d1137c55f401387113d1ad8a387489afe741db\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Feb 2 09:13:44 2011 -0500\n\n    fixed an out-of-boundary bug (fixed by Roel Kluin)\n\ncommit a44a98e16559b9672e8a3492c8f8c640074b7ee2\nMerge: ef68a14 d0443d5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 1 21:54:48 2011 -0500\n\n    Merge branch 'master' into devel\n\ncommit d0443d5c2f648e0f69bd4c56eaac7868e501c18b\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 1 17:31:52 2011 -0500\n\n    improved sorting order checking\n\ncommit ef68a14fab91399b2ecd38345936c3d6e7391cf3\nMerge: 1e597b3 1a39a2e\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 1 15:12:37 2011 -0500\n\n    Merge branch 'master' into devel\n\ncommit 1a39a2eb08a270e20a34a0983e8bed6ffb3e2008\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 1 15:12:14 2011 -0500\n\n    more precise error message\n\ncommit e028e7a47c02232e06a9dd3009262c00dede1060\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 1 14:48:01 2011 -0500\n\n    improved sorting order validation in index\n\ncommit 1e597b3356744e2b791b12c9187f91c8054511d5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Tue Feb 1 14:44:27 2011 -0500\n\n    testing only; not working\n\ncommit 5753ace1e54228822d8ee95f69943f586e42f6e8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Jan 31 17:37:08 2011 -0500\n\n    reduce the effect of seq errors at the cost of SN\n\ncommit 6f239ce5e0abd47babee33174476d48b723260d8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Jan 31 17:29:34 2011 -0500\n\n    added testing code\n\ncommit 3db42fe22d27d61ab5735cd2308f73d93def8ebe\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Jan 31 14:33:21 2011 -0500\n\n    routine for phasing fosmid resequencing (incomplete)\n\ncommit ed88f2797323229ae8f38fbcd107b231007956a8\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Mon Jan 31 10:12:53 2011 -0500\n\n    SAM output\n\ncommit abc6acae28dc4794f6422255f077cf370d34e414\nMerge: f1985a9 b133dbf\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Jan 29 22:56:10 2011 -0500\n\n    Merge branch 'master' into devel\n\ncommit b133dbf82de4e8cea5eb56e5bbf0c4b3e9368fd5\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Jan 29 22:37:11 2011 -0500\n\n    fixed a bug in tview on big-endian by Nathan Weeks\n\ncommit 9d3fdaef29f91e21dbfcb9ff0165b9573e7c1042\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Jan 29 22:24:00 2011 -0500\n\n    update INSTALL\n\ncommit 9d074a38bde53961f96157b6fb3683b6dded38d7\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Jan 29 21:56:25 2011 -0500\n\n    avoid a segfault when network connect fails\n\ncommit f1985a93f7455b3ea1b0ef9b959d50b896ccd620\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Sat Jan 29 21:53:18 2011 -0500\n\n    fixed a bug about bit ordering\n\ncommit d09797db6fef648a6823cbe718d67664660c6ebe\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jan 27 16:53:19 2011 -0500\n\n    point out there are 4 or fewer free parameters\n\ncommit 5fd1717650ed68ab6c55d094d1648c16a054891a\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jan 27 16:09:18 2011 -0500\n\n    updated .gitignore\n\ncommit fccb19fbe8f9de91f59d85bb49a248683dc6266c\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jan 27 16:08:14 2011 -0500\n\n    fixed a bug; better scoring\n\ncommit b4dcb844bde3d09eedcd9f6832186ece60ae5afd\nMerge: ffc3e89 6f502de\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jan 27 14:50:30 2011 -0500\n\n    Merge branch 'master' into devel\n\ncommit 6f502dec46b18dae4bb5b2319715d028b5e193d0\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jan 27 14:47:31 2011 -0500\n\n    skip unmapped and ref-skip reads in indel calling\n\ncommit 3639f37dd8257b24560c35effcc3b6c16c3c1bcb\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jan 27 14:19:15 2011 -0500\n\n    fixed an out-of-boundary bug in rare cases\n\ncommit ffc3e89678ab9052b84f403da1e43044b045e73f\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Thu Jan 27 14:00:17 2011 -0500\n\n    targetcut can be compiled, though probably buggy\n\ncommit f452b3ac51306865ddde31a8d715b155d4d3e6e6\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jan 26 18:58:43 2011 -0500\n\n    this is for a very special application...\n\ncommit ca1451c6406c7ee757cb31349ea0b8de70db0656\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jan 26 18:48:09 2011 -0500\n\n    fixed compiling errors\n\ncommit 085b87a7642865f17239fb6a436e626e25417838\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jan 26 18:45:09 2011 -0500\n\n    This script was put in a wrong place...\n\ncommit 090d360828622520de60385af4928ce1aebe0e48\nAuthor: Heng Li <lh3@live.co.uk>\nDate:   Wed Jan 26 18:33:58 2011 -0500\n\n    Imported from samtools-r902\n------------------------------------------------------------------------\nr108 | lh3lh3 | 2009-01-20 11:56:45 +0000 (Tue, 20 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/examples/Makefile\n\nmade it a little more convenient\n\n------------------------------------------------------------------------\nr107 | lh3lh3 | 2009-01-20 11:53:30 +0000 (Tue, 20 Jan 2009) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/examples/Makefile\n\nadded a Makefile\n\n------------------------------------------------------------------------\nr106 | lh3lh3 | 2009-01-20 11:25:05 +0000 (Tue, 20 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/maq2sam.c\n\nsupport RG tag\n\n------------------------------------------------------------------------\nr105 | lh3lh3 | 2009-01-18 17:37:20 +0000 (Sun, 18 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/ChangeLog\n\nupdate changelog\n\n------------------------------------------------------------------------\nr104 | lh3lh3 | 2009-01-18 17:31:21 +0000 (Sun, 18 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_lpileup.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-18\n * fixed a bug in bam_lpileup.c: segment start and end are not correctly recognized\n\n------------------------------------------------------------------------\nr103 | lh3lh3 | 2009-01-18 16:34:03 +0000 (Sun, 18 Jan 2009) | 5 lines\nChanged paths:\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-17\n * fixed a bug when there are reads without coordinates\n * also recognize type 'c' as 'A'\t\n * found a bug in bam_lpileup.c; NOT fixed yet\n\n------------------------------------------------------------------------\nr102 | lh3lh3 | 2009-01-17 19:46:49 +0000 (Sat, 17 Jan 2009) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/INSTALL\n\nInstruction for compilation\n\n------------------------------------------------------------------------\nr101 | lh3lh3 | 2009-01-17 19:31:36 +0000 (Sat, 17 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   A /branches/dev/samtools/Makefile.lite\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/faidx.c\n   M /branches/dev/samtools/misc/Makefile\n   M /branches/dev/samtools/razf.c\n\n * replaced HAVE_RAZF with _NO_RAZF\n * added Makefile.lite for people who have trouble with razf.c\n\n------------------------------------------------------------------------\nr100 | lh3lh3 | 2009-01-16 10:03:37 +0000 (Fri, 16 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_mate.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/misc/wgsim.c\n\n * samtools-0.1.1-15\n * fixed another bug in fixmate: unmapped pair has non-zero isize\n\n------------------------------------------------------------------------\nr99 | lh3lh3 | 2009-01-16 09:13:36 +0000 (Fri, 16 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/ChangeLog\n   M /branches/dev/samtools/bam_mate.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-14\n * fixed a bug in fixmate: isize not equal to zero if two ends mapped to\n   different chr\n\n------------------------------------------------------------------------\nr98 | lh3lh3 | 2009-01-15 16:47:41 +0000 (Thu, 15 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-13\n * fixed the prior for hom indels (Richard pointed this out)\n\n------------------------------------------------------------------------\nr97 | lh3lh3 | 2009-01-15 16:38:47 +0000 (Thu, 15 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/COPYING\n   M /branches/dev/samtools/bam_sort.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/source.dot\n\n * samtools-0.1.1-12\n * fixed a bug in sort\n * update source file graph and copyright information\n\n------------------------------------------------------------------------\nr96 | lh3lh3 | 2009-01-14 21:46:14 +0000 (Wed, 14 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/glf.c\n\nfixed a typo\n\n------------------------------------------------------------------------\nr95 | lh3lh3 | 2009-01-14 21:44:53 +0000 (Wed, 14 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/glf.c\n\nadded a main function for glf.c\n\n------------------------------------------------------------------------\nr94 | lh3lh3 | 2009-01-14 17:14:59 +0000 (Wed, 14 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/bgzf.h\n   A /branches/dev/samtools/glf.c\n   M /branches/dev/samtools/glf.h\n\n * samtools-0.1.1-11\n * generate binary GLFv2\n * added glfview command to dump GLFv2 binary file\n\n------------------------------------------------------------------------\nr93 | lh3lh3 | 2009-01-14 15:07:44 +0000 (Wed, 14 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam_rmdup.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/glf.h\n\n * samtools-0.1.1-10\n * fixed several bugs in rmdup\n * prepare to generate GLF2\n\n------------------------------------------------------------------------\nr92 | lh3lh3 | 2009-01-14 13:27:44 +0000 (Wed, 14 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_import.c\n   A /branches/dev/samtools/bam_rmdup.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-9\n * implemented rmdup; NOT tested yet\n\n------------------------------------------------------------------------\nr91 | lh3lh3 | 2009-01-13 20:15:43 +0000 (Tue, 13 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/examples/00README.txt\n\nupdate README for typos\n\n------------------------------------------------------------------------\nr90 | lh3lh3 | 2009-01-13 19:57:50 +0000 (Tue, 13 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/examples/ex1.sam.gz\n\nupdate example\n\n------------------------------------------------------------------------\nr89 | lh3lh3 | 2009-01-13 17:21:38 +0000 (Tue, 13 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam.c\n   A /branches/dev/samtools/bam_mate.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-8\n * added fixmate command\n\n------------------------------------------------------------------------\nr88 | lh3lh3 | 2009-01-13 10:48:23 +0000 (Tue, 13 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-7\n * change the reported indel position to the previous way\n\n------------------------------------------------------------------------\nr87 | lh3lh3 | 2009-01-12 22:12:12 +0000 (Mon, 12 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-6\n * addd glt output\n * allow to change indel calling parameters at the command line\n\n------------------------------------------------------------------------\nr86 | lh3lh3 | 2009-01-12 21:16:48 +0000 (Mon, 12 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_pileup.c\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-5\n * added two more flags\n * allowed to select reads shown in pileup with a mask\n\n------------------------------------------------------------------------\nr85 | lh3lh3 | 2009-01-12 20:47:51 +0000 (Mon, 12 Jan 2009) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-4\n * fixed a bug in indexing (linear index)\n * prepare to add glt output from pileup\n\n------------------------------------------------------------------------\nr84 | lh3lh3 | 2009-01-12 09:22:35 +0000 (Mon, 12 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-3\n * fixed a bug in outputing the coordinate of an indel\n\n------------------------------------------------------------------------\nr83 | lh3lh3 | 2009-01-11 15:18:01 +0000 (Sun, 11 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-2\n * pileup: allows to output indel sites only\n\n------------------------------------------------------------------------\nr82 | lh3lh3 | 2009-01-10 23:34:31 +0000 (Sat, 10 Jan 2009) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bam_maqcns.h\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.1-1\n * implemented a Bayesian indel caller\n\n------------------------------------------------------------------------\nr81 | lh3lh3 | 2009-01-09 09:54:28 +0000 (Fri, 09 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/examples/00README.txt\n   D /branches/dev/samtools/examples/ex1.fa.fai\n\nLet users generate ex1.fa.fai.\n\n------------------------------------------------------------------------\nr80 | lh3lh3 | 2009-01-08 16:10:08 +0000 (Thu, 08 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/bowtie2sam.pl\n\nmake the bowtie converter works for \"-k 2\"\n\n------------------------------------------------------------------------\nr78 | lh3lh3 | 2009-01-03 17:25:24 +0000 (Sat, 03 Jan 2009) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/export2sam.pl\n\nfixed a bug for \"QC\" reads\n\n------------------------------------------------------------------------\nr77 | lh3lh3 | 2009-01-01 18:32:06 +0000 (Thu, 01 Jan 2009) | 3 lines\nChanged paths:\n   A /branches/dev/samtools/misc/bowtie2sam.pl\n   M /branches/dev/samtools/misc/soap2sam.pl\n\n * soap2sam.pl: added NM tag\n * bowtie2sam.pl: converter for bowtie\n\n------------------------------------------------------------------------\nr76 | lh3lh3 | 2008-12-31 23:24:24 +0000 (Wed, 31 Dec 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/misc/soap2sam.pl\n\nsoap2sam.pl: convert soap output to SAM\n\n------------------------------------------------------------------------\nr75 | lh3lh3 | 2008-12-31 17:54:32 +0000 (Wed, 31 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/misc/wgsim_eval.pl\n\n * wgsim_eval.pl-0.1.1\n * fixed a bug for a contig name like \"NT_012345\"\n\n------------------------------------------------------------------------\nr74 | lh3lh3 | 2008-12-31 16:38:21 +0000 (Wed, 31 Dec 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/misc/wgsim_eval.pl\n\n * evaluate alignment for reads generated by wgsim\n\n------------------------------------------------------------------------\nr73 | lh3lh3 | 2008-12-31 15:11:22 +0000 (Wed, 31 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/Makefile\n   M /branches/dev/samtools/misc/wgsim.c\n\nfixed compiling warnings for wgsim\n\n------------------------------------------------------------------------\nr72 | lh3lh3 | 2008-12-31 13:40:51 +0000 (Wed, 31 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/bam_tview.c\n\nremove an unused variable (a compiler warning only)\n\n------------------------------------------------------------------------\nr71 | lh3lh3 | 2008-12-31 13:37:16 +0000 (Wed, 31 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/Makefile\n   A /branches/dev/samtools/misc/wgsim.c\n\nwgsim: Paired-end reads simulator\n\n------------------------------------------------------------------------\nr70 | bhandsaker | 2008-12-29 20:27:16 +0000 (Mon, 29 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bam_tview.c\n\nMove definition of bam_nt16_nt4_table so we can build without curses.\n\n------------------------------------------------------------------------\nr62 | lh3lh3 | 2008-12-22 15:55:13 +0000 (Mon, 22 Dec 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/NEWS\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/samtools.1\n\nRelease samtools-0.1.1\n\n------------------------------------------------------------------------\nr61 | lh3lh3 | 2008-12-22 15:46:08 +0000 (Mon, 22 Dec 2008) | 10 lines\nChanged paths:\n   M /branches/dev/samtools/bam_aux.c\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bam_tview.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/razf.c\n   M /branches/dev/samtools/samtools.1\n\n * samtools-0.1.0-66\n * fixed a bug in razf.c: reset z_eof when razf_seek() is called\n * fixed a memory leak in parsing a region\n * changed pileup a little bit when -s is in use: output ^ and $\n * when a bam is not indexed, output more meaningful error message\n * fixed a bug in indexing for small alignment\n * fixed a bug in the viewer when we come to the end of a reference file\n * updated documentation\n * prepare to release 0.1.1\n\n------------------------------------------------------------------------\nr60 | lh3lh3 | 2008-12-22 15:10:16 +0000 (Mon, 22 Dec 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/examples\n   A /branches/dev/samtools/examples/00README.txt\n   A /branches/dev/samtools/examples/ex1.fa\n   A /branches/dev/samtools/examples/ex1.fa.fai\n   A /branches/dev/samtools/examples/ex1.sam.gz\n\nexample\n\n------------------------------------------------------------------------\nr59 | lh3lh3 | 2008-12-22 09:38:15 +0000 (Mon, 22 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/ChangeLog\n\nupdate ChangeLog\n\n------------------------------------------------------------------------\nr58 | lh3lh3 | 2008-12-20 23:06:00 +0000 (Sat, 20 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/misc/export2sam.pl\n\n * added comments\n * fixed several bugs \n\n------------------------------------------------------------------------\nr57 | lh3lh3 | 2008-12-20 15:44:20 +0000 (Sat, 20 Dec 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/misc/export2sam.pl\n\nconvert Export format to SAM; not thoroughly tested\n\n------------------------------------------------------------------------\nr56 | lh3lh3 | 2008-12-19 22:13:28 +0000 (Fri, 19 Dec 2008) | 6 lines\nChanged paths:\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bam_tview.c\n   M /branches/dev/samtools/bamtk.c\n   A /branches/dev/samtools/source.dot\n\n * samtools-0.1.0-65\n * pileup: generate maq-like simple output\n * pileup: allow to output pileup at required sites\n * source.dot: source file relationship graph\n * tview: fixed a minor bug\n\n------------------------------------------------------------------------\nr55 | lh3lh3 | 2008-12-19 20:10:26 +0000 (Fri, 19 Dec 2008) | 2 lines\nChanged paths:\n   D /branches/dev/samtools/misc/all2sam.pl\n\nremove all2sam.pl\n\n------------------------------------------------------------------------\nr54 | lh3lh3 | 2008-12-16 22:34:25 +0000 (Tue, 16 Dec 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/COPYING\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/faidx.h\n   M /branches/dev/samtools/khash.h\n   M /branches/dev/samtools/kseq.h\n   M /branches/dev/samtools/ksort.h\n   M /branches/dev/samtools/samtools.1\n\nAdded copyright information and a bit more documentation. No code change.\n\n------------------------------------------------------------------------\nr53 | lh3lh3 | 2008-12-16 13:40:18 +0000 (Tue, 16 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam.c\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-64\n * improved efficiency of the indel caller for spliced alignments\n\n------------------------------------------------------------------------\nr52 | lh3lh3 | 2008-12-16 10:28:20 +0000 (Tue, 16 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam.c\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_aux.c\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-63\n * a bit code cleanup: reduce the dependency between source files\n\n------------------------------------------------------------------------\nr51 | lh3lh3 | 2008-12-15 14:29:32 +0000 (Mon, 15 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-62\n * fixed a memory leak\n\n------------------------------------------------------------------------\nr50 | lh3lh3 | 2008-12-15 14:00:13 +0000 (Mon, 15 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/ChangeLog\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/samtools.1\n\nupdate documentation, ChangeLog and a comment\n\n------------------------------------------------------------------------\nr49 | lh3lh3 | 2008-12-15 13:36:43 +0000 (Mon, 15 Dec 2008) | 6 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bam_maqcns.h\n   M /branches/dev/samtools/bam_pileup.c\n   A /branches/dev/samtools/bam_plcmd.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/samtools.1\n\n * samtools-0.1.0-61\n * moved pileup command to a separate source file\n * added indel caller\n * added bam_cal_segend(). (NOT WORKING for spliced alignment!!!)\n * updated documentation\n\n------------------------------------------------------------------------\nr48 | lh3lh3 | 2008-12-12 13:55:36 +0000 (Fri, 12 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-60\n * fixed another bug in maqcns when there is a nearby deletion\n\n------------------------------------------------------------------------\nr47 | lh3lh3 | 2008-12-12 13:42:16 +0000 (Fri, 12 Dec 2008) | 5 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bam_pileup.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-59\n * pileup: outputing consensus is now optional\n * fixed a bug in glfgen. This bug also exists in maq's glfgen. However,\n   I am not quite sure why the previous version may have problem.\n\n------------------------------------------------------------------------\nr46 | lh3lh3 | 2008-12-12 11:44:56 +0000 (Fri, 12 Dec 2008) | 6 lines\nChanged paths:\n   M /branches/dev/samtools/bam_pileup.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-58\n * add maq consensus to pileup. However, I will move this part to a new\n   command as strictly speaking, consensus callin is not part of pileup,\n   and imposing it would make it harder to generate for other language\n   bindings.\n\n------------------------------------------------------------------------\nr45 | bhandsaker | 2008-12-11 20:43:56 +0000 (Thu, 11 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/bgzf.c\n\nFix bug in tell() after reads that consume to the exact end of a block.\n\n------------------------------------------------------------------------\nr44 | lh3lh3 | 2008-12-11 09:36:53 +0000 (Thu, 11 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/samtools.1\n\nupdate manual\n\n------------------------------------------------------------------------\nr43 | lh3lh3 | 2008-12-11 09:25:36 +0000 (Thu, 11 Dec 2008) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-57\n * fixed a bug in parser when there is auxiliary fields\n * made the parser a bit more robust\n\n------------------------------------------------------------------------\nr42 | lh3lh3 | 2008-12-10 14:57:29 +0000 (Wed, 10 Dec 2008) | 5 lines\nChanged paths:\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/bgzf.c\n\n * samtools-0.1.0-56\n * fixed a bug in bgzf (only reading is affected)\n * fixed a typo in bam_index.c\n * in bam_index.c, check potential bugs in the underlying I/O library\n\n------------------------------------------------------------------------\nr41 | lh3lh3 | 2008-12-10 12:53:08 +0000 (Wed, 10 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/samtools.1\n\nupdate manual\n\n------------------------------------------------------------------------\nr40 | lh3lh3 | 2008-12-10 11:52:10 +0000 (Wed, 10 Dec 2008) | 5 lines\nChanged paths:\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_pileup.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-55\n * tried to make pileup work with clipping (previously not), though NOT tested\n * removed -v from pileup\n * made pileup take the reference sequence\n\n------------------------------------------------------------------------\nr39 | lh3lh3 | 2008-12-09 11:59:28 +0000 (Tue, 09 Dec 2008) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/samtools.1\n\n * samtools-0.1.0-54\n * in parser, recognize \"=\", rather than \",\", as a match\n * in parser, correctl parse \"=\" at the MRNM field.\n\n------------------------------------------------------------------------\nr38 | lh3lh3 | 2008-12-09 11:39:07 +0000 (Tue, 09 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/maq2sam.c\n\nfixed a bug in handling maq flag 64 and 192\n\n------------------------------------------------------------------------\nr37 | lh3lh3 | 2008-12-09 09:53:46 +0000 (Tue, 09 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/md5fa.c\n\nalso calculate unordered md5sum check\n\n------------------------------------------------------------------------\nr36 | lh3lh3 | 2008-12-09 09:46:21 +0000 (Tue, 09 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/md5fa.c\n\nfixed a minor bug when there are space in the sequence\n\n------------------------------------------------------------------------\nr35 | lh3lh3 | 2008-12-09 09:40:45 +0000 (Tue, 09 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/md5fa.c\n\nfixed a potential memory leak\n\n------------------------------------------------------------------------\nr34 | lh3lh3 | 2008-12-08 14:52:17 +0000 (Mon, 08 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bamtk.c\n\n * fixed a bug in import: bin is wrongly calculated\n\n------------------------------------------------------------------------\nr33 | lh3lh3 | 2008-12-08 14:08:01 +0000 (Mon, 08 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/misc/all2sam.pl\n\nnothing, really\n\n------------------------------------------------------------------------\nr32 | lh3lh3 | 2008-12-08 12:56:02 +0000 (Mon, 08 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/kseq.h\n   M /branches/dev/samtools/misc/Makefile\n   A /branches/dev/samtools/misc/md5.c\n   A /branches/dev/samtools/misc/md5.h\n   A /branches/dev/samtools/misc/md5fa.c\n\n * fixed two warnings in kseq.h\n * added md5sum utilities\n\n------------------------------------------------------------------------\nr31 | lh3lh3 | 2008-12-08 11:35:29 +0000 (Mon, 08 Dec 2008) | 5 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bamtk.c\n   A /branches/dev/samtools/kseq.h\n   D /branches/dev/samtools/kstream.h\n\n * samtools-0.1.0-52\n * replace kstream with kseq. kseq is a superset of kstream. I need the\n   extra functions in kseq.h.\n * also compile stand-alone faidx\n\n------------------------------------------------------------------------\nr30 | lh3lh3 | 2008-12-08 11:17:04 +0000 (Mon, 08 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_sort.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-51\n * sorting by read names is available\n\n------------------------------------------------------------------------\nr29 | lh3lh3 | 2008-12-08 10:29:02 +0000 (Mon, 08 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam.c\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bam_pileup.c\n   M /branches/dev/samtools/bam_sort.c\n   M /branches/dev/samtools/bam_tview.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/misc/maq2sam.c\n\n * samtools-0.1.0-50\n * format change to meet the latest specification\n\n------------------------------------------------------------------------\nr28 | lh3lh3 | 2008-12-04 16:09:21 +0000 (Thu, 04 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/misc/maq2sam.c\n\n * minor change in maqcns: special care when n==0\n * change maq2sam to meet the latest specification\n\n------------------------------------------------------------------------\nr27 | lh3lh3 | 2008-12-04 15:55:44 +0000 (Thu, 04 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/razf.c\n   M /branches/dev/samtools/razf.h\n\nconsiderable code clean up in razf\n\n------------------------------------------------------------------------\nr26 | lh3lh3 | 2008-12-04 15:08:18 +0000 (Thu, 04 Dec 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/ChangeLog\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/faidx.c\n\nmake RAZF optional in faidx.c\n\n------------------------------------------------------------------------\nr25 | lh3lh3 | 2008-12-01 15:27:22 +0000 (Mon, 01 Dec 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/bam_aux.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/samtools.1\n\n * samtools-0.1.0-49\n * added routines for retrieving aux data, NOT TESTED YET!\n\n------------------------------------------------------------------------\nr24 | lh3lh3 | 2008-12-01 14:29:43 +0000 (Mon, 01 Dec 2008) | 5 lines\nChanged paths:\n   M /branches/dev/samtools/bam.c\n   M /branches/dev/samtools/bam_import.c\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/bgzf.c\n   M /branches/dev/samtools/samtools.1\n\n * samtools-0.1.0-48\n * bgzf: fixed a potential integer overflow on 32-it machines\n * maqcns: set the minimum combined quality as 0\n * supporting hex strings\n\n------------------------------------------------------------------------\nr23 | lh3lh3 | 2008-11-27 17:14:37 +0000 (Thu, 27 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/bam_maqcns.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-47\n * fixed the bug in maqcns\n\n------------------------------------------------------------------------\nr22 | lh3lh3 | 2008-11-27 17:08:11 +0000 (Thu, 27 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam.h\n   A /branches/dev/samtools/bam_maqcns.c\n   A /branches/dev/samtools/bam_maqcns.h\n   M /branches/dev/samtools/bam_tview.c\n   M /branches/dev/samtools/bamtk.c\n   A /branches/dev/samtools/glf.h\n\n * samtools-0.1.0-46\n * add MAQ consensus caller, currently BUGGY!\n\n------------------------------------------------------------------------\nr21 | lh3lh3 | 2008-11-27 13:51:28 +0000 (Thu, 27 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam_pileup.c\n   M /branches/dev/samtools/bam_tview.c\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-45\n * tview: display padded alignment (but not P operation)\n * better coordinates and reference sequence\n\n------------------------------------------------------------------------\nr19 | lh3lh3 | 2008-11-27 09:26:05 +0000 (Thu, 27 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/ChangeLog\n\nnew ChangeLog\n\n------------------------------------------------------------------------\nr18 | lh3lh3 | 2008-11-27 09:24:45 +0000 (Thu, 27 Nov 2008) | 3 lines\nChanged paths:\n   D /branches/dev/samtools/ChangeLog\n   A /branches/dev/samtools/ChangeLog.old (from /branches/dev/samtools/ChangeLog:6)\n\nRename ChangeLog to ChangeLog.old. This old ChangeLog is generated from\nthe log of my personal SVN repository.\n\n------------------------------------------------------------------------\nr17 | lh3lh3 | 2008-11-27 09:22:55 +0000 (Thu, 27 Nov 2008) | 6 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/bgzf.c\n\n * samtools-0.1.0-44\n * declare fseeko and ftello as some Linux may not do this by default and\n   missing these declarations will make bgzf buggy\n * get rid of some harmless warings\n * use BGZF by default, now\n\n------------------------------------------------------------------------\nr16 | lh3lh3 | 2008-11-26 21:19:11 +0000 (Wed, 26 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bam_index.c\n   M /branches/dev/samtools/bamtk.c\n   M /branches/dev/samtools/razf.c\n\n * samtools-0.1.0-43\n * fixed a bug in razf_read()\n * give more warnings when the file is truncated (or due to bugs in I/O library)\n\n------------------------------------------------------------------------\nr15 | lh3lh3 | 2008-11-26 20:41:39 +0000 (Wed, 26 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/bgzf.c\n\nfixed a bug in bgzf.c at the end of the file\n\n------------------------------------------------------------------------\nr14 | lh3lh3 | 2008-11-26 17:05:18 +0000 (Wed, 26 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/dev/samtools/bamtk.c\n\n * samtools-0.1.0-42\n * a lot happened to RAZF, although samtools itself is untouched. Better\n   also update the version number anyway to avoid confusion\n\n------------------------------------------------------------------------\nr13 | lh3lh3 | 2008-11-26 17:03:48 +0000 (Wed, 26 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/razf.c\n\na change from Jue, but I think it should not matter\n\n------------------------------------------------------------------------\nr12 | lh3lh3 | 2008-11-26 16:48:14 +0000 (Wed, 26 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/dev/samtools/razf.c\n\nfixed a potential bug in razf. However, it seems still buggy, just\nrarely happens, very rarely.\n\n------------------------------------------------------------------------\nr11 | lh3lh3 | 2008-11-26 14:02:56 +0000 (Wed, 26 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/razf.c\n\nfixed a bug in razf, with the help of Jue\n\n------------------------------------------------------------------------\nr10 | lh3lh3 | 2008-11-26 11:55:32 +0000 (Wed, 26 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/bam_index.c\n\nremove a comment\n\n------------------------------------------------------------------------\nr9 | lh3lh3 | 2008-11-26 11:37:05 +0000 (Wed, 26 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/dev/samtools/Makefile\n   M /branches/dev/samtools/bam.h\n   M /branches/dev/samtools/razf.c\n   M /branches/dev/samtools/razf.h\n\n * Jue has updated razf to realize Bob's scheme\n\n------------------------------------------------------------------------\nr7 | lh3lh3 | 2008-11-25 20:37:37 +0000 (Tue, 25 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools/samtools.1\n\nthe manual page\n\n------------------------------------------------------------------------\nr6 | lh3lh3 | 2008-11-25 20:37:16 +0000 (Tue, 25 Nov 2008) | 3 lines\nChanged paths:\n   A /branches/dev/samtools/ChangeLog\n   A /branches/dev/samtools/Makefile\n   A /branches/dev/samtools/bam.c\n   A /branches/dev/samtools/bam.h\n   A /branches/dev/samtools/bam_aux.c\n   A /branches/dev/samtools/bam_endian.h\n   A /branches/dev/samtools/bam_import.c\n   A /branches/dev/samtools/bam_index.c\n   A /branches/dev/samtools/bam_lpileup.c\n   A /branches/dev/samtools/bam_pileup.c\n   A /branches/dev/samtools/bam_sort.c\n   A /branches/dev/samtools/bam_tview.c\n   A /branches/dev/samtools/bamtk.c\n   A /branches/dev/samtools/bgzf.c\n   A /branches/dev/samtools/bgzf.h\n   A /branches/dev/samtools/bgzip.c\n   A /branches/dev/samtools/faidx.c\n   A /branches/dev/samtools/faidx.h\n   A /branches/dev/samtools/khash.h\n   A /branches/dev/samtools/ksort.h\n   A /branches/dev/samtools/kstream.h\n   A /branches/dev/samtools/misc\n   A /branches/dev/samtools/misc/Makefile\n   A /branches/dev/samtools/misc/all2sam.pl\n   A /branches/dev/samtools/misc/maq2sam.c\n   A /branches/dev/samtools/razf.c\n   A /branches/dev/samtools/razf.h\n   A /branches/dev/samtools/razip.c\n   A /branches/dev/samtools/zutil.h\n\nThe initial version of samtools, replicated from my local SVN repository.\nThe current version is: 0.1.0-42. All future development will happen here.\n\n------------------------------------------------------------------------\nr5 | lh3lh3 | 2008-11-25 20:30:49 +0000 (Tue, 25 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/dev/samtools\n\nsamtools (C version)\n\n------------------------------------------------------------------------\n------------------------------------------------------------------------\nr703 | lh3 | 2008-11-25 20:20:02 +0000 (Tue, 25 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/samtools.1\n\nrename bamtk to samtools\n\n------------------------------------------------------------------------\nr702 | lh3 | 2008-11-25 20:15:09 +0000 (Tue, 25 Nov 2008) | 2 lines\nChanged paths:\n   D /branches/prog/bam/bamtk.1\n   A /branches/prog/bam/samtools.1 (from /branches/prog/bam/bamtk.1:679)\n\nrename bamtk.1 to samtools.1\n\n------------------------------------------------------------------------\nr701 | lh3 | 2008-11-25 13:29:10 +0000 (Tue, 25 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/misc/Makefile\n\n * samtools-0.1.0-41\n * small (but a bit dangerous) changes to meet the latest specification\n\n------------------------------------------------------------------------\nr700 | lh3 | 2008-11-25 13:15:11 +0000 (Tue, 25 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam/misc/all2sam.pl (from /branches/prog/bam/misc/all2tam.pl:649)\n   D /branches/prog/bam/misc/all2tam.pl\n   A /branches/prog/bam/misc/maq2sam.c (from /branches/prog/bam/misc/maq2tam.c:699)\n   D /branches/prog/bam/misc/maq2tam.c\n\nrename tam to sam\n\n------------------------------------------------------------------------\nr699 | lh3 | 2008-11-25 13:14:49 +0000 (Tue, 25 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/misc/maq2tam.c\n\nchange for the new specification\n\n------------------------------------------------------------------------\nr698 | lh3 | 2008-11-24 13:15:20 +0000 (Mon, 24 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/razf.c\n   M /branches/prog/bam/razf.h\n\n * add a fake BGZF mode to razf. It is fake in that it loads razf index into\n   memory but gives BGZF like virtual offset\n\n------------------------------------------------------------------------\nr697 | lh3 | 2008-11-24 09:53:44 +0000 (Mon, 24 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam/ChangeLog\n\nchange log\n\n------------------------------------------------------------------------\nr696 | lh3 | 2008-11-24 09:53:23 +0000 (Mon, 24 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bgzf.c\n\nupdated bgzf, on behalf of Bob\n\n------------------------------------------------------------------------\nr695 | lh3 | 2008-11-23 11:40:31 +0000 (Sun, 23 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/razf.c\n\nfixed a bug in razf\n\n------------------------------------------------------------------------\nr694 | lh3 | 2008-11-22 16:23:52 +0000 (Sat, 22 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_lpileup.c\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bam-0.1.0-40\n * fixed two small memory leaks\n * fixed a memory problem when seek outside the length of the sequence\n\n------------------------------------------------------------------------\nr693 | lh3 | 2008-11-22 16:10:04 +0000 (Sat, 22 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n\n * bam-0.1.0-39\n * fixed an uninitialized warning. This does not matter in fact\n\n------------------------------------------------------------------------\nr692 | lh3 | 2008-11-22 15:44:05 +0000 (Sat, 22 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/razf.c\n   M /branches/prog/bam/razf.h\n\nJue's new razf\n\n------------------------------------------------------------------------\nr691 | lh3 | 2008-11-21 21:30:39 +0000 (Fri, 21 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/bgzip.c\n\n * bam-0.1.0-38\n * get rid of some warings in bgzip.c\n * potentially improve performance in indexing for BGZF\n\n------------------------------------------------------------------------\nr690 | lh3 | 2008-11-21 21:15:51 +0000 (Fri, 21 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bgzf.c\n\nI think I have fixed the bug in bgzf\n\n------------------------------------------------------------------------\nr689 | lh3 | 2008-11-21 20:48:56 +0000 (Fri, 21 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bgzf.c\n\nbug fix by Bob\n\n------------------------------------------------------------------------\nr688 | lh3 | 2008-11-21 20:37:27 +0000 (Fri, 21 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n\nfixed a bug due to the name change in _IOLIB\n\n------------------------------------------------------------------------\nr687 | lh3 | 2008-11-21 14:42:56 +0000 (Fri, 21 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bgzf.c\n\nfix small things\n\n------------------------------------------------------------------------\nr686 | lh3 | 2008-11-21 14:37:59 +0000 (Fri, 21 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam/bgzf.c\n   A /branches/prog/bam/bgzf.h\n   A /branches/prog/bam/bgzip.c\n\nBob's BGZF format, although currently buggy\n\n------------------------------------------------------------------------\nr685 | lh3 | 2008-11-21 09:48:20 +0000 (Fri, 21 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bam-0.1.0-37\n * improve interface a little bit\n\n------------------------------------------------------------------------\nr684 | lh3 | 2008-11-21 09:30:18 +0000 (Fri, 21 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bam-0.1.0-36\n * improve the interface of tview, a little bit\n\n------------------------------------------------------------------------\nr683 | lh3 | 2008-11-20 22:33:54 +0000 (Thu, 20 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam_tview.c\n\na little better viewer\n\n------------------------------------------------------------------------\nr682 | lh3 | 2008-11-20 22:27:01 +0000 (Thu, 20 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-35\n * better viewer\n\n------------------------------------------------------------------------\nr681 | lh3 | 2008-11-20 20:51:16 +0000 (Thu, 20 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-34\n * tview is now a component of bamtk\n\n------------------------------------------------------------------------\nr680 | lh3 | 2008-11-20 19:17:30 +0000 (Thu, 20 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam/bam_tview.c\n\ntext alignment viewer\n\n------------------------------------------------------------------------\nr679 | lh3 | 2008-11-20 19:17:15 +0000 (Thu, 20 Nov 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_lpileup.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.1\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/faidx.c\n\n * bamtk-0.1.0-33\n * added routines to reset pileup bufferes\n * fixed a bug in faidx\n * add text alignment viewer\n\n------------------------------------------------------------------------\nr678 | lh3 | 2008-11-20 11:05:02 +0000 (Thu, 20 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   A /branches/prog/bam/bam_lpileup.c (from /branches/prog/bam/bam_tview.c:668)\n   D /branches/prog/bam/bam_tview.c\n\nrename tview as lpileup\n\n------------------------------------------------------------------------\nr677 | lh3 | 2008-11-20 10:08:52 +0000 (Thu, 20 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/razf.c\n\nfixed a bug in razf\n\n------------------------------------------------------------------------\nr676 | lh3 | 2008-11-19 22:52:20 +0000 (Wed, 19 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/faidx.h\n\nadd documentations\n\n------------------------------------------------------------------------\nr674 | lh3 | 2008-11-19 21:39:17 +0000 (Wed, 19 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bamtk.1\n   M /branches/prog/bam/faidx.h\n\nupdate documentation\n\n------------------------------------------------------------------------\nr673 | lh3 | 2008-11-19 21:19:03 +0000 (Wed, 19 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam/bamtk.1\n\nadd manual page\n\n------------------------------------------------------------------------\nr672 | lh3 | 2008-11-19 16:40:49 +0000 (Wed, 19 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/faidx.c\n\n * bamtk-0.1.0-32\n * make faidx more error resistant\n\n------------------------------------------------------------------------\nr671 | lh3 | 2008-11-19 16:09:55 +0000 (Wed, 19 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/faidx.h\n\nadd index\n\n------------------------------------------------------------------------\nr670 | lh3 | 2008-11-19 16:02:39 +0000 (Wed, 19 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/faidx.c\n\n * bamtk-0.1.0-31\n * show reference sequence in pileup -v (not in the default pileup)\n\n------------------------------------------------------------------------\nr669 | lh3 | 2008-11-19 14:51:17 +0000 (Wed, 19 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/faidx.c\n\n * bamtk-0.1.0-30\n * put faidx in bamtk and remove faidx_main.c\n\n------------------------------------------------------------------------\nr668 | lh3 | 2008-11-19 14:15:05 +0000 (Wed, 19 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n   A /branches/prog/bam/faidx.c\n   A /branches/prog/bam/faidx.h\n   M /branches/prog/bam/razf.c\n\n * bamtk-0.1.0-29\n * fixed a bug in tview.c\n * prepare to add faidx\n\n------------------------------------------------------------------------\nr667 | lh3 | 2008-11-19 10:20:45 +0000 (Wed, 19 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/razf.c\n   M /branches/prog/bam/razf.h\n\ngzip-compatible razf\n\n------------------------------------------------------------------------\nr664 | lh3 | 2008-11-18 12:50:23 +0000 (Tue, 18 Nov 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-28\n * fetch: fixed a bug at an array boundary\n * fetch: fixed a bug when the whole chromosome is retrieved\n * add linear index\n\n------------------------------------------------------------------------\nr663 | lh3 | 2008-11-17 21:29:22 +0000 (Mon, 17 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-27\n * put l_qseq into core and move l_aux to bam1_t\n\n------------------------------------------------------------------------\nr662 | lh3 | 2008-11-17 20:55:16 +0000 (Mon, 17 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-26\n * save seq and qual separately\n\n------------------------------------------------------------------------\nr661 | lh3 | 2008-11-17 13:09:37 +0000 (Mon, 17 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n\nlittle\n\n------------------------------------------------------------------------\nr660 | lh3 | 2008-11-17 13:06:14 +0000 (Mon, 17 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n\nmore documentations\n\n------------------------------------------------------------------------\nr659 | lh3 | 2008-11-17 12:55:08 +0000 (Mon, 17 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-25\n * make tview work for TAM\n\n------------------------------------------------------------------------\nr658 | lh3 | 2008-11-17 12:50:21 +0000 (Mon, 17 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-24\n * make tview as an independent module\n\n------------------------------------------------------------------------\nr657 | lh3 | 2008-11-17 11:26:06 +0000 (Mon, 17 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_pileup.c\n\nchange little\n\n------------------------------------------------------------------------\nr656 | lh3 | 2008-11-16 21:33:19 +0000 (Sun, 16 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-23\n * also add tview for TAM\n\n------------------------------------------------------------------------\nr655 | lh3 | 2008-11-16 21:29:46 +0000 (Sun, 16 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-22\n * make tview more efficient for deep depth\n\n------------------------------------------------------------------------\nr654 | lh3 | 2008-11-16 20:52:19 +0000 (Sun, 16 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_pileup.c\n   A /branches/prog/bam/bam_tview.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-21\n * fixed bug in the TAM parser: lowercase not recognized\n * unfinished function to leveled pileup (tview)\n\n------------------------------------------------------------------------\nr653 | lh3 | 2008-11-15 12:58:36 +0000 (Sat, 15 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-20\n * pileup now display deleted bases as '*'\n\n------------------------------------------------------------------------\nr652 | lh3 | 2008-11-15 09:58:39 +0000 (Sat, 15 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-19\n * fixed a bug in fetch()\n * reduce memory in indexing\n\n------------------------------------------------------------------------\nr651 | lh3 | 2008-11-14 21:56:05 +0000 (Fri, 14 Nov 2008) | 5 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-18\n * important changes are made to index: the index size is increased, but\n   now we have no limit on file sizes and the new method potentially\n   works with BGZF, Bob's new compression format.\n\n------------------------------------------------------------------------\nr650 | lh3 | 2008-11-14 16:03:22 +0000 (Fri, 14 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-17\n * more comments in bam.h\n * fixed a bug in bam_index.c\n\n------------------------------------------------------------------------\nr649 | lh3 | 2008-11-13 16:04:18 +0000 (Thu, 13 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bam_sort.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-16\n * use macros to retrieve pointers from bam1_t and thus reduce the size\n   of bam1_t struct.\n\n------------------------------------------------------------------------\nr648 | lh3 | 2008-11-13 13:21:39 +0000 (Thu, 13 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_sort.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-15\n * make more things work over pipe\n\n------------------------------------------------------------------------\nr647 | lh3 | 2008-11-13 12:49:28 +0000 (Thu, 13 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/misc/maq2tam.c\n\nfixed a bug in maq2tam\n\n------------------------------------------------------------------------\nr646 | lh3 | 2008-11-13 11:46:59 +0000 (Thu, 13 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/Makefile\n   M /branches/prog/bam/misc/Makefile\n   M /branches/prog/bam/misc/maq2tam.c\n\n * bug fix in maq2tam.c\n * improve Makefile\n\n------------------------------------------------------------------------\nr645 | lh3 | 2008-11-13 11:39:46 +0000 (Thu, 13 Nov 2008) | 3 lines\nChanged paths:\n   A /branches/prog/bam/misc/Makefile\n   M /branches/prog/bam/misc/maq2tam.c\n\n * corrected maq2tam\n * add Makefile\n\n------------------------------------------------------------------------\nr644 | lh3 | 2008-11-13 11:25:45 +0000 (Thu, 13 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/razf.c\n\nfixed the bug in buffered write (on behalf of Jue)\n\n------------------------------------------------------------------------\nr643 | lh3 | 2008-11-13 10:53:42 +0000 (Thu, 13 Nov 2008) | 2 lines\nChanged paths:\n   D /branches/prog/bam/all2tam.pl\n   A /branches/prog/bam/misc/all2tam.pl (from /branches/prog/bam/all2tam.pl:642)\n\nmove to misc\n\n------------------------------------------------------------------------\nr642 | lh3 | 2008-11-13 10:53:23 +0000 (Thu, 13 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/all2tam.pl\n\nchange tag\n\n------------------------------------------------------------------------\nr641 | lh3 | 2008-11-13 10:53:12 +0000 (Thu, 13 Nov 2008) | 2 lines\nChanged paths:\n   D /branches/prog/bam/utils\n\nhas been renamed\n\n------------------------------------------------------------------------\nr640 | lh3 | 2008-11-13 10:52:50 +0000 (Thu, 13 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam/misc (from /branches/prog/bam/utils:639)\n\nrename\n\n------------------------------------------------------------------------\nr639 | lh3 | 2008-11-13 10:52:35 +0000 (Thu, 13 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam/utils\n   A /branches/prog/bam/utils/maq2tam.c\n\nutilities (converters and so on)\n\n------------------------------------------------------------------------\nr638 | lh3 | 2008-11-12 22:24:22 +0000 (Wed, 12 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-14\n * copy the text header to BAM\n * add BAM1 header flag\n\n------------------------------------------------------------------------\nr637 | lh3 | 2008-11-12 14:56:08 +0000 (Wed, 12 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/razf.c\n\n * bamtk-0.1.0-13\n * fixed a bug in razf\n * improved and fixed potential bugs in index\n\n------------------------------------------------------------------------\nr636 | lh3 | 2008-11-12 11:57:13 +0000 (Wed, 12 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\nupdate documentation in the HeaderDOC format\n\n------------------------------------------------------------------------\nr635 | lh3 | 2008-11-12 10:08:38 +0000 (Wed, 12 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-12\n * more documentations\n * rename baf1_core_t as bam1_core_t\n\n------------------------------------------------------------------------\nr634 | lh3 | 2008-11-11 23:00:35 +0000 (Tue, 11 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_pileup.c\n\ndocumentation\n\n------------------------------------------------------------------------\nr633 | lh3 | 2008-11-11 21:23:49 +0000 (Tue, 11 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-11\n * give up regional pileup. We can now use pipe to mimic that.\n * for index file, change suffix .idx to .bmi\n\n------------------------------------------------------------------------\nr632 | lh3 | 2008-11-11 21:00:11 +0000 (Tue, 11 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/razf.c\n\n * bamtk-0.1.0-10\n * make pileup work on TAM\n\n------------------------------------------------------------------------\nr631 | lh3 | 2008-11-11 09:20:29 +0000 (Tue, 11 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/razf.c\n   M /branches/prog/bam/razf.h\n   M /branches/prog/bam/razip.c\n\n * bamtk-0.1.0-9\n * razf now supports streaming\n * prepare to improve pileup (have not yet)\n\n------------------------------------------------------------------------\nr630 | lh3 | 2008-11-10 18:34:40 +0000 (Mon, 10 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-8\n * improve the interface of TAM parser\n\n------------------------------------------------------------------------\nr629 | lh3 | 2008-11-10 13:06:13 +0000 (Mon, 10 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-7\n * almost nothing\n\n------------------------------------------------------------------------\nr628 | lh3 | 2008-11-10 12:56:36 +0000 (Mon, 10 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-6\n * fixed a bug in bam_pileup.c\n\n------------------------------------------------------------------------\nr627 | lh3 | 2008-11-10 11:32:46 +0000 (Mon, 10 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bamtk.c\n   M /branches/prog/bam/razf.c\n\n * bamtk-0.1.0-5\n * fixed a bug in razf.c, caused by my modifications\n * improve the interface of pileup. Now it will be slower but more flexible\n\n------------------------------------------------------------------------\nr626 | lh3 | 2008-11-09 20:51:04 +0000 (Sun, 09 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-4\n * view: dumping binary output\n\n------------------------------------------------------------------------\nr625 | lh3 | 2008-11-09 20:31:54 +0000 (Sun, 09 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bam_pileup.c\n   M /branches/prog/bam/bam_sort.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-3\n * rename functions\n\n------------------------------------------------------------------------\nr624 | lh3 | 2008-11-09 15:07:32 +0000 (Sun, 09 Nov 2008) | 2 lines\nChanged paths:\n   M /branches/prog/bam/bam.h\n\nadd comments\n\n------------------------------------------------------------------------\nr623 | lh3 | 2008-11-08 22:32:49 +0000 (Sat, 08 Nov 2008) | 4 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-2\n * improve indexing for a mixture of long and short reads, although currently\n   I do not know whether it really works...\n\n------------------------------------------------------------------------\nr622 | lh3 | 2008-11-08 22:13:58 +0000 (Sat, 08 Nov 2008) | 3 lines\nChanged paths:\n   M /branches/prog/bam/bam_index.c\n   M /branches/prog/bam/bamtk.c\n\n * bamtk-0.1.0-1\n * prepare for improving indexing algorithm\n\n------------------------------------------------------------------------\nr621 | lh3 | 2008-11-08 20:28:09 +0000 (Sat, 08 Nov 2008) | 4 lines\nChanged paths:\n   A /branches/prog/bam/all2tam.pl\n   M /branches/prog/bam/bam.c\n   M /branches/prog/bam/bam.h\n   M /branches/prog/bam/bam_import.c\n   M /branches/prog/bam/bamtk.c\n   D /branches/prog/bam/tam_utils.pl\n\n * bamtk-0.1.0\n * smarter integers\n * rename tam_utils.pl to all2tam.pl\n\n------------------------------------------------------------------------\nr620 | lh3 | 2008-11-08 17:17:22 +0000 (Sat, 08 Nov 2008) | 2 lines\nChanged paths:\n   A /branches/prog/bam\n   A /branches/prog/bam/Makefile\n   A /branches/prog/bam/bam.c\n   A /branches/prog/bam/bam.h\n   A /branches/prog/bam/bam_endian.h\n   A /branches/prog/bam/bam_import.c\n   A /branches/prog/bam/bam_index.c\n   A /branches/prog/bam/bam_pileup.c\n   A /branches/prog/bam/bam_sort.c\n   A /branches/prog/bam/bamtk.c\n   A /branches/prog/bam/khash.h\n   A /branches/prog/bam/ksort.h\n   A /branches/prog/bam/kstream.h\n   A /branches/prog/bam/razf.c\n   A /branches/prog/bam/razf.h\n   A /branches/prog/bam/razip.c\n   A /branches/prog/bam/tam_utils.pl\n   A /branches/prog/bam/zutil.h\n\nThe Binary Alignment/Mapping format.\n\n------------------------------------------------------------------------\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 10.32421875,
          "content": "System Requirements\n===================\n\nSamtools and HTSlib depend on the following libraries:\n\n  Samtools:\n    zlib       <http://zlib.net>\n    curses or GNU ncurses (optional, for the 'tview' command)\n               <http://www.gnu.org/software/ncurses/>\n\n  HTSlib:\n    zlib       <http://zlib.net>\n    libbz2     <http://bzip.org/>\n    liblzma    <http://tukaani.org/xz/>\n    libcurl    <https://curl.haxx.se/>\n               (optional but strongly recommended, for network access)\n    libcrypto  <https://www.openssl.org/>\n               (optional, for Amazon S3 support; not needed on MacOS)\n    libdeflate <https://github.com/ebiggers/libdeflate>\n               (optional, but strongly recommended for faster gzip)\n\nSee the \"System Specific Details\" below for guidance on how to install\nthese.\n\nThe bzip2 and liblzma dependencies can be removed if full CRAM support\nis not needed - see HTSlib's INSTALL file for details.\n\nThe following programs are required:\n\n    GNU make\n    C compiler (e.g. gcc or clang)\n\nIn addition, building the configure script requires:\n\n    autoheader\n    autoconf\n\nRunning the configure script uses awk, along with a number of\nstandard UNIX tools (cat, cp, grep, mv, rm, sed, among others).  Almost\nall installations will have these already.  \n\nRunning the test harness (make test) uses:\n\n    bash\n    perl\n\nIf you are unsure about this, be sure to use './configure' to determine\nwhether you have these libraries and to help diagnose which packages may\nneed to be installed on your build machine to provide them.\n\nBuilding Configure\n==================\n\nThis step is only needed if configure.ac has been changed, or if configure\ndoes not exist (for example, when building from a git clone).  The\nconfigure script and config.h.in can be built by running:\n\n    autoheader\n    autoconf -Wno-syntax\n\nIf you have a full GNU autotools install, you can alternatively run:\n\n    autoreconf\n\nWhen running these tools, you may see warnings about AC_CONFIG_SUBDIRS.\nThese are expected, and should be ignored.\n\nBasic Installation\n==================\n\nTo build and install Samtools, 'cd' to the samtools-1.x directory containing\nthe package's source and type the following commands:\n\n    ./configure\n    make\n    make install\n\nThe './configure' command checks your build environment and allows various\noptional functionality to be enabled (see Configuration below).  If you\ndon't want to select any optional functionality, you may wish to omit\nconfigure and just type 'make; make install' as for previous versions\nof samtools.  However if the build fails you should run './configure'\nas it can diagnose the common reasons for build failures.\n\nThe 'make' command builds samtools and various miscellaneous utilities.\nIf compilation fails you should run './configure' as it can diagnose\nproblems with your build environment that cause build failures.\n\n(The bgzip, htsfile, and tabix utilities are provided by HTSlib.  If you are\nnot also compiling HTSlib separately, you may wish to compile these utilities\nin the associated copy of HTSlib.  Type 'make all all-htslib' to do this.)\n\nThe 'make install' command installs the samtools executable and various\nscripts and executables from misc/ and a manual page to /usr/local.\nThe installation location can be changed by configuring with --prefix=DIR\nor via 'make prefix=DIR install' (see Installation Locations below).\n\n(If you have not also installed HTSlib separately, you may wish to install\nthe bgzip, htsfile, and tabix utilities from the associated copy of HTSlib.\nType 'make install install-htslib' to do this.)\n\nTypically you will want to enable HTSlib's HTTPS/etc plugin etc.\nSee README for recipes for typical installation.\n\n\nConfiguration\n=============\n\nBy default, './configure' examines your build environment, searching for a\nusable HTSlib and checking for requirements such as the curses development\nfiles, and arranges for a plain samtools build.\n\nThis samtools release contains a copy of the HTSlib source code which will\nbe used to build samtools.  If you already have a system-installed HTSlib\nor another HTSlib that you would prefer to build against, you can arrange\nthis via the --with-htslib option.\n\nThe following configure options can be used to enable various features and\nspecify further optional external requirements:\n\n--with-htslib=DIR\n    Specifies the HTSlib source tree or installation directory that samtools\n    should use to parse bioinformatics file formats etc.  Configure will check\n    that DIR appears to contain HTSlib source files or to be the root of an\n    installation directory (i.e., it has 'include' and 'lib' subdirectories\n    containing HTSlib headers and libraries).\n\n    (If the desired HTSlib source tree has been configured to build in a\n    separate build directory, DIR should refer to the build directory.)\n\n    By default, configure looks for an HTSlib source tree within or alongside\n    the samtools source directory; if there are several likely candidates,\n    you will have to choose one via this option.\n\n--with-htslib=system\n    Ignores any nearby HTSlib source trees, and builds samtools using an\n    existing HTSlib installation in a system directory (i.e., a directory\n    already being searched by $CPPFLAGS/$LDFLAGS).\n\n--without-curses\n    Omit the curses-based 'tview' subcommand from the build.  If you do not\n    have curses on your build machine or otherwise don't want the interactive\n    tview subcommand, this option disables it and skips testing for working\n    curses development files.\n\n--enable-configure-htslib\n    When building with an HTSlib source tree, run HTSlib's configure script\n    as well.  HTSlib configure options can also be used and will be\n    passed down to the HTSlib configure.  See HTSlib's INSTALL documentation\n    for details of these options.\n\nIf you are building with HTSlib source in a subdirectory of the samtools\ntree,  --enable-configure-htslib is turned on by default and the HTSlib\nconfigure script will be run automatically.  This is the case for the\nsamtools release tar archives which include an embedded copy of HTSlib.\n\nThe configure script also accepts the usual options and environment variables\nfor tuning installation locations and compilers: type './configure --help'\nfor details.  For example,\n\n    ./configure CC=icc --prefix=/opt/icc-compiled\n\nwould specify that samtools is to be built with icc and installed into bin,\nlib, etc subdirectories under /opt/icc-compiled.\n\nIf dependencies have been installed in non-standard locations (i.e. not on\nthe normal include and library search paths) then the CPPFLAGS and LDFLAGS\nenvironment variables can be used to set the options needed to find them.\nFor example, NetBSD users may use:\n\n    ./configure CPPFLAGS=-I/usr/pkg/include \\\n                LDFLAGS='-L/usr/pkg/lib -Wl,-R/usr/pkg/lib'\n\nto allow compiling and linking against dependencies installed via the ports\ncollection.\n\nInstallation Locations\n======================\n\nBy default, 'make install' installs samtools and the utilities under\n/usr/local/bin and manual pages under /usr/local/share/man.\n\nYou can specify a different location to install Samtools by configuring\nwith --prefix=DIR or specify locations for particular parts of HTSlib by\nconfiguring with --bindir=DIR and so on.  Type './configure --help' for\nthe full list of such install directory options.\n\nAlternatively you can specify different locations at install time by\ntyping 'make prefix=DIR install' or 'make bindir=DIR install' and so on.\nConsult the list of prefix/exec_prefix/etc variables near the top of the\nMakefile for the full list of such variables that can be overridden.\n\nYou can also specify a staging area by typing 'make DESTDIR=DIR install',\npossibly in conjunction with other --prefix or prefix=DIR settings.\nFor example,\n\n    make DESTDIR=/tmp/staging prefix=/opt\n\nwould install into bin and share/man subdirectories under /tmp/staging/opt.\n\n\nSystem Specific Details\n=======================\n\nInstalling the prerequisites is system dependent and there is more\nthan one correct way of satisfying these, including downloading them\nfrom source, compiling and installing them yourself.\n\nFor people with super-user access, we provide an example set of commands\nbelow for installing the dependencies on a variety of operating system\ndistributions.  Note these are not specific recommendations on distribution,\ncompiler or SSL implementation.  It is assumed you already have the core set\nof packages for the given distribution - the lists may be incomplete if\nthis is not the case.\n\nDebian / Ubuntu\n---------------\n\nsudo apt-get update  # Ensure the package list is up to date\nsudo apt-get install autoconf automake make gcc perl zlib1g-dev libbz2-dev liblzma-dev libcurl4-gnutls-dev libssl-dev libncurses5-dev libdeflate-dev\n\nNote: libcurl4-openssl-dev can be used as an alternative to libcurl4-gnutls-dev.\n\nRedHat / CentOS\n---------------\n\nsudo yum install autoconf automake make gcc perl-Data-Dumper zlib-devel bzip2 bzip2-devel xz-devel curl-devel openssl-devel ncurses-devel libdeflate-devel\n\nNote: On some versions, Perl FindBin will need to be installed to make the tests work.\n\nsudo yum install perl-FindBin\n\nAlpine Linux\n------------\n\ndoas apk update  # Ensure the package list is up to date\ndoas apk add autoconf automake make gcc musl-dev perl bash zlib-dev bzip2-dev xz-dev curl-dev openssl-dev ncurses-dev\n\nIdeally also install a copy of libdeflate-dev for faster (de)compression.\nThis can be found in the Alpine community repository.\n\nNote: some older Alpine versions use libressl-dev rather than openssl-dev.\n\nOpenSUSE\n--------\n\nsudo zypper install autoconf automake make gcc perl zlib-devel libbz2-devel xz-devel libcurl-devel libopenssl-devel ncurses-devel\n\nAlso install libdeflate-devel, available on OpenSUSE Leap 15.4 onwards\nor directly via git releases above.\n\nWindows MSYS2/MINGW64\n---------------------\n\nThe configure script must be used as without it the compilation will\nlikely fail.\n\nFollow MSYS2 installation instructions at\nhttps://www.msys2.org/wiki/MSYS2-installation/\n\nThen relaunch to MSYS2 shell using the \"MSYS2 MinGW x64\" executable.\nOnce in that environment (check $MSYSTEM equals \"MINGW64\") install the\ncompilers using pacman -S and the following package list:\n\nbase-devel mingw-w64-x86_64-toolchain mingw-w64-x86_64-libdeflate\nmingw-w64-x86_64-zlib mingw-w64-x86_64-bzip2 mingw-w64-x86_64-xz\nmingw-w64-x86_64-curl mingw-w64-x86_64-autotools\nmingw-w64-x86_64-ncurses mingw-w64-x86_64-tools-git\n\n(The last is only needed for building libraries compatible with MSVC.)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.666015625,
          "content": "The MIT/Expat License\n\nCopyright (C) 2008-2024 Genome Research Ltd.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n\n\n[The use of a range of years within a copyright notice in this distribution\nshould be interpreted as being equivalent to a list of years including the\nfirst and last year specified and all consecutive years between them.\n\nFor example, a copyright notice that reads \"Copyright (C) 2005, 2007-2009,\n2011-2012\" should be interpreted as being identical to a notice that reads\n\"Copyright (C) 2005, 2007, 2008, 2009, 2011, 2012\" and a copyright notice\nthat reads \"Copyright (C) 2005-2012\" should be interpreted as being identical\nto a notice that reads \"Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012\".]\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 18.4638671875,
          "content": "# Makefile for samtools, utilities for the Sequence Alignment/Map format.\n#\n#    Copyright (C) 2008-2022, 2024 Genome Research Ltd.\n#    Portions copyright (C) 2010-2012 Broad Institute.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n\nCC       = gcc\nAR       = ar\nAWK      = awk\nCPPFLAGS =\n#CFLAGS   = -g -Wall -O2 -pedantic -std=c99 -D_XOPEN_SOURCE=600\nCFLAGS   = -g -Wall -O2\nLDFLAGS  =\nLIBS     =\n\nLZ4DIR   = ./lz4\nLZ4_CPPFLAGS = -I$(LZ4DIR)\nLZ4_LDFLAGS  = -L$(LZ4DIR)\n\n\nAOBJS=      bam_aux.o bam_index.o bam_plcmd.o sam_view.o bam_fastq.o \\\n            bam_cat.o bam_md.o bam_plbuf.o bam_reheader.o bam_sort.o \\\n            bam_rmdup.o bam_rmdupse.o bam_mate.o bam_stat.o bam_color.o \\\n            bamtk.o bam2bcf.o sample.o \\\n            cut_target.o phase.o bam2depth.o coverage.o padding.o bedcov.o bamshuf.o \\\n            faidx.o dict.o stats.o stats_isize.o bam_flags.o bam_split.o \\\n            bam_tview.o bam_tview_curses.o bam_tview_html.o bam_lpileup.o \\\n            bam_quickcheck.o bam_addrprg.o bam_markdup.o tmp_file.o \\\n            bam_ampliconclip.o amplicon_stats.o bam_import.o bam_samples.o \\\n            bam_consensus.o consensus_pileup.o reference.o reset.o cram_size.o \\\n            bam_checksum.o\nLZ4OBJS  =  $(LZ4DIR)/lz4.o\n\nprefix      = /usr/local\nexec_prefix = $(prefix)\nbindir      = $(exec_prefix)/bin\ndatarootdir = $(prefix)/share\nmandir      = $(datarootdir)/man\nman1dir     = $(mandir)/man1\n\n# Installation location for $(MISC_PROGRAMS) and $(MISC_SCRIPTS)\nmisc_bindir = $(bindir)\n\nMKDIR_P = mkdir -p\nINSTALL = install -p\nINSTALL_DATA    = $(INSTALL) -m 644\nINSTALL_DIR     = $(MKDIR_P) -m 755\nINSTALL_MAN     = $(INSTALL_DATA)\nINSTALL_PROGRAM = $(INSTALL)\nINSTALL_SCRIPT  = $(INSTALL_PROGRAM)\n\n\nPROGRAMS = samtools\n\nMISC_PROGRAMS = \\\n\tmisc/ace2sam misc/maq2sam-long misc/maq2sam-short \\\n\tmisc/md5fa misc/md5sum-lite misc/wgsim\n\nMISC_SCRIPTS = \\\n\tmisc/blast2sam.pl misc/bowtie2sam.pl misc/export2sam.pl \\\n\tmisc/fasta-sanitize.pl misc/interpolate_sam.pl misc/novo2sam.pl \\\n\tmisc/plot-ampliconstats misc/plot-bamstats misc/psl2sam.pl \\\n\tmisc/sam2vcf.pl misc/samtools.pl misc/seq_cache_populate.pl \\\n\tmisc/soap2sam.pl misc/wgsim_eval.pl misc/zoom2sam.pl\n\nTEST_PROGRAMS = \\\n\ttest/merge/test_bam_translate \\\n\ttest/merge/test_rtrans_build \\\n\ttest/merge/test_trans_tbl_init \\\n\ttest/split/test_count_rg \\\n\ttest/split/test_expand_format_string \\\n\ttest/split/test_filter_header_rg \\\n\ttest/split/test_parse_args \\\n\ttest/vcf-miniview\n\nall: $(PROGRAMS) $(MISC_PROGRAMS) $(TEST_PROGRAMS)\n\nALL_CPPFLAGS = -I. $(HTSLIB_CPPFLAGS) $(LZ4_CPPFLAGS) $(CPPFLAGS)\nALL_LDFLAGS  = $(HTSLIB_LDFLAGS) $(LZ4_LDFLAGS) $(LDFLAGS)\nALL_LIBS     = -lz $(LIBS)\n\n# Usually config.mk and config.h are generated by running configure\n# or config.status, but if those aren't used create defaults here.\n\nconfig.mk:\n\t@sed -e '/^prefix/,/^LIBS/d;s/@Hsource@//;s/@Hinstall@/#/;s#@HTSDIR@#../htslib#g;s/@HTSLIB_CPPFLAGS@/-I$$(HTSDIR)/g;s/@CURSES_LIB@/-lcurses/g' config.mk.in > $@\n\nconfig.h:\n\techo '/* Basic config.h generated by Makefile */' > $@\n\techo '#define HAVE_CURSES' >> $@\n\techo '#define HAVE_CURSES_H' >> $@\n\ninclude config.mk\n\n# If not using GNU make, you need to copy the version number from version.sh\n# into here.\nPACKAGE_VERSION = $(shell ./version.sh)\n\n# Force version.h to be remade if $(PACKAGE_VERSION) has changed.\nversion.h: $(if $(wildcard version.h),$(if $(findstring \"$(PACKAGE_VERSION)\",$(shell cat version.h)),,force))\n\n# If you don't have GNU Make but are building from a Git repository, you may\n# wish to replace this with a rule that always rebuilds version.h:\n# version.h: force\n#\techo '#define SAMTOOLS_VERSION \"`git describe --always --dirty`\"' > $@\nversion.h:\n\techo '#define SAMTOOLS_VERSION \"$(PACKAGE_VERSION)\"' > $@\n\techo '#define SAMTOOLS_CC \"$(CC)\"' >> $@\n\techo '#define SAMTOOLS_CPPFLAGS \"$(CPPFLAGS)\"' >> $@\n\techo '#define SAMTOOLS_CFLAGS \"$(CFLAGS)\"' >> $@\n\techo '#define SAMTOOLS_LDFLAGS \"$(LDFLAGS)\"' >> $@\n\techo '#define SAMTOOLS_HTSDIR \"$(HTSDIR)\"' >> $@\n\techo '#define SAMTOOLS_LIBS \"$(LIBS)\"' >> $@\n\techo '#define SAMTOOLS_CURSES_LIB \"$(CURSES_LIB)\"' >> $@\n\nprint-version:\n\t@echo $(PACKAGE_VERSION)\n\n\n.SUFFIXES: .c .o\n\n.c.o:\n\t$(CC) $(CFLAGS) $(ALL_CPPFLAGS) -c -o $@ $<\n\nLIBST_OBJS = sam_opts.o sam_utils.o bedidx.o bam.o\n\n\nsamtools: $(AOBJS) $(LZ4OBJS) libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ $(AOBJS) $(LZ4OBJS) libst.a $(HTSLIB_LIB) $(CURSES_LIB) -lm $(ALL_LIBS) -lpthread\n\n# For building samtools and its test suite only: NOT to be installed.\nlibst.a: $(LIBST_OBJS)\n\t@-rm -f $@\n\t$(AR) -rcs $@ $(LIBST_OBJS)\n\n\nbam_h = bam.h $(htslib_sam_h)\nbam2bcf_h = bam2bcf.h $(htslib_hts_h) $(htslib_vcf_h)\nbam_ampliconclip_h = bam_ampliconclip.h $(htslib_khash_h)\nbam_lpileup_h = bam_lpileup.h $(htslib_sam_h)\nbam_plbuf_h = bam_plbuf.h $(htslib_sam_h)\nbam_tview_h = bam_tview.h $(htslib_hts_h) $(htslib_sam_h) $(htslib_faidx_h) $(bam2bcf_h) $(htslib_khash_h) $(bam_lpileup_h)\nbedidx_h = bedidx.h $(htslib_hts_h)\nconsensus_pileup_h = consensus_pileup.h $(htslib_sam_h)\nsam_opts_h = sam_opts.h $(htslib_hts_h)\nsam_utils_h = sam_utils.h $(htslib_khash_h) $(htslib_sam_h)\nsample_h = sample.h $(htslib_kstring_h)\nsamtools_h = samtools.h $(htslib_hts_defs_h) $(htslib_sam_h) $(sam_utils_h)\nstats_isize_h = stats_isize.h $(htslib_khash_h)\ntmp_file_h = tmp_file.h $(htslib_sam_h) $(LZ4DIR)/lz4.h\n\nbam.o: bam.c config.h $(bam_h) $(htslib_kstring_h)\nbam2bcf.o: bam2bcf.c config.h $(htslib_hts_h) $(htslib_sam_h) $(bam2bcf_h)\nbam2depth.o: bam2depth.c config.h $(htslib_sam_h) $(samtools_h) $(bedidx_h) $(sam_opts_h) $(htslib_khash_h)\ncoverage.o: coverage.c config.h $(htslib_sam_h) $(htslib_hts_h) $(samtools_h) $(sam_opts_h)\nbam_addrprg.o: bam_addrprg.c config.h $(htslib_sam_h) $(htslib_kstring_h) $(samtools_h) $(htslib_thread_pool_h) $(sam_opts_h)\nbam_aux.o: bam_aux.c config.h $(htslib_sam_h)\nbam_cat.o: bam_cat.c config.h $(htslib_bgzf_h) $(htslib_sam_h) $(htslib_cram_h) $(htslib_kstring_h) $(htslib_hfile_h) $(samtools_h) $(sam_opts_h)\nbam_color.o: bam_color.c config.h $(htslib_sam_h)\nbam_fastq.o: bam_fastq.c config.h $(htslib_sam_h) $(htslib_klist_h) $(htslib_kstring_h) $(htslib_bgzf_h) $(htslib_thread_pool_h) $(htslib_khash_h) $(samtools_h) $(sam_opts_h)\nbam_import.o: bam_import.c config.h $(htslib_sam_h) $(htslib_thread_pool_h) $(samtools_h) $(sam_opts_h)\nbam_index.o: bam_index.c config.h $(htslib_hts_h) $(htslib_sam_h) $(htslib_hfile_h) $(htslib_khash_h) $(samtools_h) $(sam_opts_h)\nbam_lpileup.o: bam_lpileup.c config.h $(bam_plbuf_h) $(bam_lpileup_h) splaysort.h\nbam_mate.o: bam_mate.c config.h $(htslib_thread_pool_h) $(sam_opts_h) $(htslib_kstring_h) $(htslib_sam_h) $(samtools_h)\nbam_md.o: bam_md.c config.h $(htslib_faidx_h) $(htslib_sam_h) $(htslib_kstring_h) $(htslib_thread_pool_h) $(sam_opts_h) $(samtools_h)\nbam_plbuf.o: bam_plbuf.c config.h $(htslib_hts_h) $(htslib_sam_h) $(bam_plbuf_h)\nbam_checksum.o: bam_checksum.c config.h $(htslib_sam_h) $(htslib_khash_h) $(htslib_kstring_h) $(htslib_hts_endian_h) $(sam_opts_h) $(sam_utils_h)\nbam_consensus.o: bam_consensus.c config.h $(htslib_sam_h) $(htslib_hfile_h) $(samtools_h) $(sam_opts_h) $(bam_plbuf_h) $(consensus_pileup_h)\nbam_plcmd.o: bam_plcmd.c config.h $(htslib_sam_h) $(htslib_faidx_h) $(htslib_kstring_h) $(htslib_klist_h) $(htslib_khash_str2int_h) $(samtools_h) $(bedidx_h) $(sam_opts_h) $(sample_h) $(htslib_cram_h) $(bam_plbuf_h)\nbam_quickcheck.o: bam_quickcheck.c config.h $(htslib_hts_h) $(htslib_sam_h)\nbam_reheader.o: bam_reheader.c config.h $(htslib_bgzf_h) $(htslib_sam_h) $(htslib_hfile_h) $(htslib_cram_h) $(samtools_h)\nbam_rmdup.o: bam_rmdup.c config.h $(htslib_sam_h) $(sam_opts_h) $(samtools_h) $(bam_h) $(htslib_khash_h)\nbam_rmdupse.o: bam_rmdupse.c config.h $(bam_h) $(htslib_sam_h) $(htslib_khash_h) $(htslib_klist_h) $(samtools_h)\nbam_sort.o: bam_sort.c config.h $(htslib_ksort_h) $(htslib_hts_os_h) $(htslib_khash_h) $(htslib_klist_h) $(htslib_kstring_h) $(htslib_sam_h) $(htslib_hts_endian_h) $(htslib_cram_h) $(htslib_thread_pool_h) $(sam_opts_h) $(samtools_h) $(bedidx_h) $(bam_h)\nbam_split.o: bam_split.c config.h $(htslib_sam_h) $(htslib_khash_h) $(htslib_kstring_h) $(htslib_cram_h) $(htslib_thread_pool_h) $(sam_opts_h) $(samtools_h)\nbam_stat.o: bam_stat.c config.h $(htslib_sam_h) $(samtools_h) $(sam_opts_h)\nbam_tview.o: bam_tview.c config.h $(bam_tview_h) $(htslib_faidx_h) $(htslib_sam_h) $(htslib_bgzf_h) $(samtools_h) $(sam_opts_h)\nbam_tview_curses.o: bam_tview_curses.c config.h $(bam_tview_h)\nbam_tview_html.o: bam_tview_html.c config.h $(bam_tview_h)\nbam_flags.o: bam_flags.c config.h $(htslib_sam_h) $(samtools_h)\nbamshuf.o: bamshuf.c config.h $(htslib_sam_h) $(htslib_hts_h) $(htslib_ksort_h) $(samtools_h) $(htslib_thread_pool_h) $(sam_opts_h) $(htslib_khash_h)\nbamtk.o: bamtk.c config.h $(htslib_hts_h) $(htslib_hfile_h) $(samtools_h) version.h\nbedcov.o: bedcov.c config.h $(htslib_kstring_h) $(htslib_sam_h) $(htslib_thread_pool_h) $(samtools_h) $(sam_opts_h) $(htslib_kseq_h)\nbedidx.o: bedidx.c config.h $(bedidx_h) $(htslib_ksort_h) $(htslib_kseq_h) $(htslib_khash_h)\nconsensus_pileup.o: consensus_pileup.c config.h $(htslib_sam_h) $(consensus_pileup_h)\ncram_size.o: cram_size.c config.h $(htslib_bgzf_h) $(htslib_sam_h) $(htslib_cram_h) $(htslib_kstring_h) $(htslib_khash_h) $(samtools_h) $(sam_opts_h) $(htslib_hfile_h)\ncut_target.o: cut_target.c config.h $(htslib_hts_h) $(htslib_sam_h) $(htslib_faidx_h) $(samtools_h) $(sam_opts_h)\ndict.o: dict.c config.h $(htslib_khash_h) $(htslib_kseq_h) $(htslib_hts_h) $(samtools_h)\nfaidx.o: faidx.c config.h $(htslib_faidx_h) $(htslib_hts_h) $(htslib_hfile_h) $(htslib_kstring_h) $(htslib_bgzf_h) $(htslib_thread_pool_h) $(sam_opts_h) $(samtools_h)\npadding.o: padding.c config.h $(htslib_kstring_h) $(htslib_sam_h) $(htslib_faidx_h) $(sam_opts_h) $(samtools_h)\nphase.o: phase.c config.h $(htslib_hts_h) $(htslib_sam_h) $(htslib_kstring_h) $(sam_opts_h) $(samtools_h) $(htslib_hts_os_h) $(htslib_kseq_h) $(htslib_khash_h) $(htslib_ksort_h)\nreference.o: reference.c config.h $(htslib_sam_h) $(htslib_cram_h) $(samtools_h) $(sam_opts_h)\nsam_opts.o: sam_opts.c config.h $(sam_opts_h)\nsam_utils.o: sam_utils.c config.h $(sam_utils_h)\nsam_view.o: sam_view.c config.h $(htslib_sam_h) $(htslib_faidx_h) $(htslib_khash_h) $(htslib_kstring_h) $(htslib_hfile_h) $(htslib_thread_pool_h) $(htslib_hts_expr_h) $(samtools_h) $(sam_opts_h) $(bam_h) $(bedidx_h) $(sam_utils_h)\nsample.o: sample.c config.h $(sample_h) $(htslib_khash_h)\nstats_isize.o: stats_isize.c config.h $(stats_isize_h) $(htslib_khash_h)\nstats.o: stats.c config.h $(htslib_faidx_h) $(htslib_sam_h) $(htslib_hts_h) $(htslib_hts_defs_h) $(samtools_h) $(htslib_khash_h) $(htslib_kstring_h) $(stats_isize_h) $(sam_opts_h) $(bedidx_h)\namplicon_stats.o: amplicon_stats.c config.h $(htslib_sam_h) $(htslib_khash_h) $(samtools_h) $(sam_opts_h) $(bam_ampliconclip_h)\nbam_markdup.o: bam_markdup.c config.h $(htslib_thread_pool_h) $(htslib_sam_h) $(sam_opts_h) $(samtools_h) $(htslib_khash_h) $(htslib_klist_h) $(htslib_kstring_h) $(tmp_file_h) $(bam_h)\ntmp_file.o: tmp_file.c config.h $(tmp_file_h) $(htslib_sam_h)\nbam_ampliconclip.o: bam_ampliconclip.c config.h $(htslib_thread_pool_h) $(sam_opts_h) $(htslib_hts_h) $(htslib_hfile_h) $(htslib_kstring_h) $(htslib_sam_h) $(samtools_h) $(bam_ampliconclip_h)\nbam_samples.o: bam_samples.c config.h $(htslib_hts_h) $(htslib_sam_h) $(htslib_faidx_h) $(htslib_khash_h) $(htslib_kseq_h) $(samtools_h)\nreset.o: reset.c config.h $(samtools_h) $(htslib_sam_h) $(sam_opts_h) $(htslib_thread_pool_h) $(htslib_khash_h) $(sam_utils_h)\n\n# Maintainer source code checks\n# - copyright boilerplate presence\n# - tab and trailing space detection\nmaintainer-check:\n\ttest/maintainer/check_copyright.pl .\n\ttest/maintainer/check_spaces.pl .\n\n# test programs\n\n# For tests that might use it, set $REF_PATH explicitly to use only reference\n# areas within the test suite (or set it to ':' to use no reference areas).\n# (regression.sh sets $REF_PATH to a subdirectory itself.)\n#\n# If using MSYS, avoid poor shell expansion via:\n#    MSYS2_ARG_CONV_EXCL=\"*\" make check\ncheck test: samtools $(BGZIP) $(TEST_PROGRAMS)\n\ttest/split/test_count_rg\n\ttest/split/test_expand_format_string\n\ttest/split/test_filter_header_rg\n\ttest/split/test_parse_args\n\tREF_PATH=: test/test.pl --exec bgzip=$(BGZIP) $${TEST_OPTS:-}\n\ttest/merge/test_bam_translate test/merge/test_bam_translate.tmp\n\ttest/merge/test_rtrans_build\n\ttest/merge/test_trans_tbl_init\n\tcd test/mpileup && AWK=\"$(AWK)\" ../regression.sh mpileup.reg\n\tcd test/mpileup && AWK=\"$(AWK)\" ../regression.sh depth.reg\n\tcd test/mpileup && AWK=\"$(AWK)\" ../regression.sh cram-size.reg\n\tcd test/consensus && AWK=\"$(AWK)\" ../regression.sh consensus.reg\n\tcd test/cram_size && AWK=\"$(AWK)\" ../regression.sh cram_size.reg\n\n\ntest/merge/test_bam_translate: test/merge/test_bam_translate.o test/test.o libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/merge/test_bam_translate.o test/test.o libst.a $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest/merge/test_rtrans_build: test/merge/test_rtrans_build.o test/test.o libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/merge/test_rtrans_build.o test/test.o libst.a $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest/merge/test_trans_tbl_init: test/merge/test_trans_tbl_init.o test/test.o libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/merge/test_trans_tbl_init.o test/test.o libst.a $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest/split/test_count_rg: test/split/test_count_rg.o test/test.o libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/split/test_count_rg.o test/test.o libst.a $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest/split/test_expand_format_string: test/split/test_expand_format_string.o test/test.o libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/split/test_expand_format_string.o test/test.o libst.a $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest/split/test_filter_header_rg: test/split/test_filter_header_rg.o test/test.o libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/split/test_filter_header_rg.o test/test.o libst.a $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest/split/test_parse_args: test/split/test_parse_args.o test/test.o libst.a $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/split/test_parse_args.o test/test.o libst.a $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest/vcf-miniview: test/vcf-miniview.o $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ test/vcf-miniview.o $(HTSLIB_LIB) $(ALL_LIBS) -lpthread\n\ntest_test_h = test/test.h $(htslib_sam_h)\n\ntest/merge/test_bam_translate.o: test/merge/test_bam_translate.c config.h bam_sort.o $(test_test_h)\ntest/merge/test_rtrans_build.o: test/merge/test_rtrans_build.c config.h bam_sort.o\ntest/merge/test_trans_tbl_init.o: test/merge/test_trans_tbl_init.c config.h bam_sort.o\ntest/split/test_count_rg.o: test/split/test_count_rg.c config.h bam_split.o $(test_test_h)\ntest/split/test_expand_format_string.o: test/split/test_expand_format_string.c config.h bam_split.o $(test_test_h)\ntest/split/test_filter_header_rg.o: test/split/test_filter_header_rg.c config.h $(test_test_h) $(samtools_h) $(htslib_kstring_h)\ntest/split/test_parse_args.o: test/split/test_parse_args.c config.h bam_split.o $(test_test_h)\ntest/test.o: test/test.c config.h $(htslib_sam_h) $(test_test_h)\ntest/vcf-miniview.o: test/vcf-miniview.c config.h $(htslib_vcf_h)\n\n# test HTSlib as well, where it is built alongside SAMtools\n\ncheck-all test-all: test-htslib test\n\n# misc programs\n\nmisc/ace2sam: misc/ace2sam.o $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ misc/ace2sam.o $(HTSLIB_LIB) $(ALL_LIBS)\n\nmisc/maq2sam-short: misc/maq2sam-short.o\n\t$(CC) $(LDFLAGS) -o $@ misc/maq2sam-short.o $(ALL_LIBS)\n\nmisc/maq2sam-long: misc/maq2sam-long.o\n\t$(CC) $(LDFLAGS) -o $@ misc/maq2sam-long.o $(ALL_LIBS)\n\nmisc/md5fa: misc/md5fa.o $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ misc/md5fa.o $(HTSLIB_LIB) $(ALL_LIBS)\n\nmisc/md5sum-lite: misc/md5sum-lite.o $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ misc/md5sum-lite.o $(HTSLIB_LIB) $(ALL_LIBS)\n\nmisc/wgsim: misc/wgsim.o $(HTSLIB)\n\t$(CC) $(ALL_LDFLAGS) -o $@ misc/wgsim.o -lm $(HTSLIB_LIB) $(ALL_LIBS)\n\nmisc/ace2sam.o: misc/ace2sam.c config.h $(htslib_kstring_h) $(htslib_kseq_h)\nmisc/md5fa.o: misc/md5fa.c config.h $(htslib_kseq_h) $(htslib_hts_h)\nmisc/md5sum-lite.o: misc/md5sum-lite.c config.h $(htslib_hts_h)\nmisc/wgsim.o: misc/wgsim.c config.h version.h $(htslib_kseq_h) $(htslib_hts_os_h)\n\nmisc/maq2sam-short.o: misc/maq2sam.c config.h version.h\n\t$(CC) $(CFLAGS) $(ALL_CPPFLAGS) -c -o $@ misc/maq2sam.c\n\nmisc/maq2sam-long.o: misc/maq2sam.c config.h version.h\n\t$(CC) $(CFLAGS) -DMAQ_LONGREADS $(ALL_CPPFLAGS) -c -o $@ misc/maq2sam.c\n\n\ninstall: $(PROGRAMS) $(MISC_PROGRAMS)\n\t$(INSTALL_DIR) $(DESTDIR)$(bindir) $(DESTDIR)$(misc_bindir) $(DESTDIR)$(man1dir)\n\t$(INSTALL_PROGRAM) $(PROGRAMS) $(DESTDIR)$(bindir)\n\t$(INSTALL_PROGRAM) $(MISC_PROGRAMS) $(DESTDIR)$(misc_bindir)\n\t$(INSTALL_SCRIPT) $(MISC_SCRIPTS) $(DESTDIR)$(misc_bindir)\n\t$(INSTALL_MAN) doc/samtools*.1 misc/wgsim.1 $(DESTDIR)$(man1dir)\n\n\ntestclean:\n\t-rm -f test/*.new test/*.tmp test/*/*.new test/*/*.tmp test/*/*.tmp.*\n\t-cd test/dat && rm -f test_input_*.bam.bai view.*.bam.bai\n\t-cd test/mpileup && rm -f FAIL-*.out* PASS-*.out* *.fa.fai anomalous.[bc]*am indels.[bc]*am mpileup.*.[cs]*am mpileup.*.crai overlap50.[bc]*am expected/1.out xx#depth*.bam*\n\t-cd test/reference && rm -f mpileup.*.fai\n\nmostlyclean: testclean\n\t-rm -f *.o misc/*.o test/*.o test/*/*.o version.h $(LZ4OBJS)\n\nclean: mostlyclean\n\t-rm -f $(PROGRAMS) libst.a $(MISC_PROGRAMS) $(TEST_PROGRAMS)\n\ndistclean: clean\n\t-rm -f config.cache config.h config.log config.mk config.status\n\t-rm -f TAGS\n\t-rm -rf autom4te.cache\n\nclean-all: clean clean-htslib\n\ndistclean-all: distclean distclean-htslib\n\nmostlyclean-all: mostlyclean mostlyclean-htslib\n\ntestclean-all: testclean testclean-htslib\n\ntags:\n\tctags -f TAGS *.[ch] misc/*.[ch]\n\n\nforce:\n\n\n.PHONY: all check check-all clean clean-all distclean distclean-all force\n.PHONY: install mostlyclean mostlyclean-all print-version tags\n.PHONY: test test-all testclean testclean-all\n"
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 105.369140625,
          "content": "Release a.b\n-----------\n\nRelease 1.21 (12th September 2024)\n----------------------------------\n\nNotice:\n\n* This is the last SAMtools / HTSlib release where CRAM 3.0 will be\n  the default CRAM version.  From the next we will change to CRAM 3.1\n  unless the version is explicitly specified, for example using\n  \"samtools view -O cram,version=3.0\".\n\nNew work and changes:\n\n* `samtools reset` now removes a set of predefined auxtags, as these tags are no\n  longer valid after the reset operation.  This behaviour can be overridden if\n  desired.\n  (PR #2034, fixes #2011.  Reported by Felix Lenner)\n\n* `samtools reset` now also removes duplicate flags.\n  (PR #2047.  Reported by Kevin Lewis)\n\n* Region and section/part filtering added to CRAM `samtools cat`.  Region\n  filtering permits `samtools cat` to produce new CRAMs that only cover a\n  specified region.\n  (PR #2035)\n\n* Added a report of the number of alignments for each primer to\n  `samtools ampliconclip`.\n  (PR #2039, PR #2101, feature request #2033.  Thanks to Brad Langhorst)\n\n* Make `ampliconclip` primer counts output deterministic.\n  (PR #2081)\n\n* `samtools fixmate` no longer removes the PAIRED flag from reads that have no\n  mate.  This is done on the understanding that the PAIRED flag is a sequencing\n  technology indicator not a feature of alignment.  This is a change to\n  previous `fixmate` behaviour.\n  (PR #2056, fixes #2052.  Reported by John Wiedenhoeft)\n\n* Added bgzf compressed FASTA output to `samtools faidx`.\n  (PR #2067, fixes #2055. Requested by Filipe G Vieira)\n\n* Optimise `samtools depth` histogram incrementing code.\n  (PR #2078)\n\n* In `samtools merge` zero pad unique suffix IDs.\n  (PR #2087, fixes #2086.  Thanks to Chris Wright)\n\n* `samtools idxstats` now accepts the `-X` option, making it easier\n  to specify the location of the index file.\n  (PR #2093, feature request #2071.  Requested by Samuel Chen)\n\n* Improved documentation for the mpileup `--adjust-MQ` option.\n  (PR #2098.  Requested by Georg Langebrake)\n\n\nBug fixes:\n\n* Avoid `tview` buffer overflow for positions with >= 14 digits.\n  (PR #2032.  Thanks to John Marshall. Reported on\n  bioconda/bioconda-recipes#47137 by jmunoz94)\n\n* Added file name and error message to 'error closing output file'\n  error in `samtools sort`.\n  (PR #2050, fixes #2049.  Thanks to Joshua C Randall).\n\n* Fixed hard clip trimming issue in `ampliconclip` where right-hand side\n  qualities were being removed from left-hand side trims.\n  (PR #2053, fixes #2048.  Reported by Duda5)\n\n* Fixed a bug in `samtools merge --template-coordinate` where the wrong heap\n  was being tested.\n  (PR #2062.  Thanks to Nils Homer.  Reported on ng-core/fastquorum#52 by\n  David Mas-Ponte)\n\n* Do not look at chr \"*\" for unmapped-placed reads with\n  `samtools view --fetch-pairs`.  This was causing a significant slowdown when\n  `--fetch-pairs` was being used.\n  (PR #2070, fixes #2059.  Reported by acorvelo)\n\n* Fixed bug which could cause `samtools view -L` to give incomplete output\n  when the BED file contained nested target locations.\n  (PR #2107, fixes #2104.  Reported by geertvandeweyer)\n\n* Enable `samtools coverage` to handle alignments that do not have quality score\n  data.  This was causing memory access problems.\n  (PR #2083, fixes #2076.  Reported by Matthew Colpus)\n\n* Fix undefined behaviour in `samtools fastq` with empty QUAL.\n  (PR #2084)\n\n* In `plot-bamstats` fixed read-length plot for data with limited variations in\n  length. Lack of data was causing gnuplot problems.\n  (PR #2085, fixes #2068.  Reported by mariyeta)\n\n* Fixed an accidental fall-through that caused `samtools split -p` to\n  also enable `--no-PG`.\n  (PR #2101)\n\n* Fixed an overflow that caused `samtools consensus -m simple` to give\n  incorrect output when the input coverage exceeded several million\n  reads deep.\n  (PR #2099, fixes #2095.  Reported by Dylan Lawrence)\n\nNon user-visible changes and build improvements:\n\n* Work around address sanitizer going missing from the Cirrus CI\n  ubuntu clang compiler by moving the address sanitizer build to gcc.\n  Fix warnings from the new clang compiler.\n  (PR #2043)\n\n* Windows based CI has been migrated from AppVeyor to GitHub Actions.\n  (PR #2072, PR #2108)\n\n* Turn on more warning options in Cirrus-CI builds, ensure everything builds\n  with `-Werror`, and add undefined behaviour checks to the address sanitizer\n  test.\n  (PR #2101, PR #2103, PR #2109)\n\n* Tidy up Makefile dependencies and untracked test files.\n  (PR #2106.  Thanks to John Marshall)\n\nRelease 1.20 (15th April 2024)\n------------------------------\n\n* Added a `--max-depth` option to `bedcov`, for more control over the depth\n  limit used when calculating the pileup.  Previously this limit was set\n  at 64000; now it is set to over 2 billion, so effectively all bases will\n  be counted.\n  (PR #1970, fixes #1950.  Reported by ellisjj)\n\n* Added `mpileup --output-extra RLEN` to display the unclipped read length.\n  (PR #1971, feature request #1959.  Requested by Feng Tian)\n\n* Improved checking of symbolic flag names (e.g. UNMAP) passed to samtools.\n  (PR #1981, fixes #1977.  Reported by Ilya Shlyakhter)\n\n* The `samtools consensus --min-depth` option now works for the Bayesian\n  mode as well as the simple one.\n  (PR #1989, feature request #1982.  Requested by Gautier Richard)\n\n* It's now possible to use the `samtools fastq` `-d tag:val` option multiple\n  times, allowing matches on more than one tag/value.  It also gets\n  a `-D` option which allows the values to be listed in a file.\n  (PR #1993, feature request #1958.  Requested by Tristan Lefebure)\n\n* Added `samtools fixmate` `-M` option to sanity check base modification\n  (`ML`, `MM`, `MN`) tags, and where necessary adjust modification data\n  on hard-clipped records.\n  (PR #1990)\n\n* Made `mpileup` run faster.\n  (PR #1995)\n\n* `samtools import` now adds a `@PG` header to the files it makes.\n  As with other sub-commands, this can be disabled by using `--no-PG`.\n  (PR #2008.  Requested by Steven Leonard)\n\n* The `samtools split` `-d` option to split by tag value now works on\n  tags with integer values.\n  (PR #2005, feature request #1956.  Requested by Alex Leonard)\n\n* Adjusted `samtools sort -n` (by name) so that primary reads are always sorted\n  before secondary / supplementary.\n  (PR #2012, feature request #2010.  Requested by Stijn van Dongen)\n\n* Added `samtools bedcov` `-H` option to print column headers in the\n  output.\n  (PR #2025.  Thanks to Dr. K. D. Murray)\n\nDocumentation:\n\n* Added a note that BAQ is applied before filtering and overlap removal\n  during mpileup processing.\n  (PR #1988, fixes #1985.  Reported by Joseph Galasso)\n\n* Added 3.1 to the list of supported CRAM versions in the samtools manual page.\n  (PR #2009.  Thanks to Andrew Thrasher)\n\n* Made assorted improvements to ampliconclip, flagstat and markdup manual\n  pages.\n  (PR #2014)\n\nBug Fixes:\n\n* Security fix: Fixed double free that could occur if bed file indexing failed\n  due to running out of memory.  This bug first appeared in version 1.19.1.\n  (PR #2026)\n\n* Corrected error message printed when faidx fails to load the fai index.\n  (PR #1987.  Thanks to Nick Moore)\n\n* Fixed bug introduced in release 1.4 that caused incorrect reference\n  bases to be printed by `samtools mpileup -a -f ref.fa` in the zero-depth\n  regions at the end of each reference.\n  (PR #2019, fixes #2018.  Reported by Joe Georgeson)\n\n* Fixed a samtools view usage crash on MinGW when given invalid options.\n  (PR #2030, fixes #2029.  Reported by Divon Lan)\n\nNon user-visible changes and build improvements:\n\n* Added tests to ensure that CRAM compression is working properly.\n  (PR #1969, part of fix for #1968.  Reported by Clockris)\n\nRelease 1.19.2 (24th January 2024)\n----------------------------------\n\nBug Fixes:\n\n* Fixed a regression in 1.19.1 that broke BED filtering for inputs where\n  the region start positions for the same reference were not sorted in\n  ascending order.\n  (PR #1975, fixes #1974.  Reported by Anže Starič)\n\nRelease 1.19.1 (22nd January 2024)\n----------------------------------\n\nBug Fixes:\n\n* Fixed a possible array bounds violation when looking up regions in\n  a BED file (e.g. using `samtools view -L`).  This could lead to crashes\n  or the return of incomplete results if the BED file contained a\n  large number of entries all referencing low positions on a chromosome.\n  (PR #1962, fixes #1961.  Reported by geertvandeweyer)\n\n* Fixed a crash in samtools stats that occurred when trying to clean up\n  after it was unable to open a CRAM reference file.\n  (PR #1957, fixes crash reported in samtools/htslib#1723.  Reported by\n  Alex Leonard)\n\nDocumentation:\n\n* Fixed inverted logic in the `samtools consensus --show-del` manual page\n  description.\n  (PR #1955, fixes #1951.  Reported by Mikhail Schelkunov)\n\n* Added a description of the MPC section to the `samtools stats` manual page.\n  (PR #1963, fixes #1954.  Reported by litun-fkby)\n\nRelease 1.19 (12th December 2023)\n---------------------------------\n\nNew work and changes:\n\n* Samtools coverage: add a new --plot-depth option to draw depth (of\n  coverage) rather than the percentage of bases covered.\n  (PR #1910.  Thanks to Pierre Lindenbaum)\n\n* Samtools merge / sort: add a lexicographical name-sort option via the -N\n  option.  The \"natural\" alpha-numeric sort is still available via -n.\n  (PR #1900, fixes #1500.  Reported by Steve Huang)\n\n* Samtools view: add -N ^NAME_FILE and -R ^RG_FILE options.  The standard -N\n  and -R options only output reads matching a specified list of names or\n  read-groups.  With a caret (^) prefix these may be negated to only output\n  read not matching the specified files.\n  (PR #1896, fixes #1895.  Suggested by Feng Tian)\n\n* Cope with Htslib's change to no longer close stdout on hts_close.\n  Htslib companion PR is samtools/htslib#1665.\n  (PR #1909.  Thanks to John Marshall)\n\n* Plot-bamstats: add a new plot of the read lengths (\"RL\") from samtools\n  stats output.\n  (PR #1922, fixes #1824.  Thanks to @erboone, suggested by Martin Pollard)\n\n* Samtools split: support splitting files based on the contents of\n  auxiliary tags.  Also adds a -M option to limit the number of files split\n  can make, to avoid accidental resource over-allocation, and fixes some\n  issues with --write-index.\n  (PR #1222, PR #1933, fixes #1758.  Thanks to Valeriu Ohan, suggested by\n  Scott Norton)\n\nBug Fixes:\n\n* Samtools stats: empty barcode tags are now treated as having no barcode.\n  (PR #1929, fixes #1926.  Reported by Jukka Matilainen)\n\n* Samtools cat: add support for non-seekable streams.  The file format\n  detection blocked pipes from working before, but now files may be\n  non-seekable such as stdin or a pipe.\n  (PR #1930, fixes #1731.  Reported by Julian Hess)\n\n* Samtools mpileup -aa (absolutely all positions) now produces an output\n  even when given an empty input file.\n  (PR #1939.  Reported by Chang Y)\n\n* Samtools markdup: speed up optical duplicate tagging on regions with very\n  deep data.\n  (PR #1952)\n\nDocumentation:\n\n* Samtools mpileup: add more usage examples to the man page.\n  (PR #1913, fixes #1801)\n\n* Samtools fastq: explicitly document the order that filters apply.\n  (PR #1907)\n\n* Samtools merge: fix example output to use an uppercase RG PL field.\n  (PR #1917.  Thanks to John Marshall.  Reported by Michael Macias)\n\n* Add hclen SAM filter documentation.\n  (PR #1902.  See also samtools/htslib#1660)\n\n* Samtools consensus: remove the -5 option from documentation.  This option\n  was renamed before the consensus subcommand was merged, but accidentally\n  left in the man page.\n  (PR #1924)\n\n\nRelease 1.18 (25th July 2023)\n-----------------------------\n\nNew work and changes:\n\n* Add minimiser sort option to collate by an indexed fasta.  Expand the\n  minimiser sort to arrange the minimiser values in the same order as they\n  occur in the reference genome. This is acts as an extremely crude and\n  simplistic read aligner that can be used to boost read compression.\n  (PR #1818)\n\n* Add a --duplicate-count option to markdup.  Adds the number of duplicates\n  (including itself) to the original read in a 'dc' tag.\n  (PR #1816. Thanks to wulj2)\n\n* Make calmd handle unaligned data or empty files without throwing an error.\n  This is to make pipelines work more smoothly.  A warning will still be issued.\n  (PR #1841, fixes #1839.  Reported by Filipe G. Vieira)\n\n* Consistent, more comprehensive flag filtering for fasta/fastq.  Added\n  --rf/--incl[ude]-flags and long options for -F (--excl[ude]-flags and\n  -f (--require-flags).\n  (PR #1842.  Thanks to Devang Thakkar)\n\n* Apply fastq --input-fmt-option settings.  Previously any options specified\n  were not being applied to the input file.\n  (PR #1855.  Thanks to John Marshall)\n\n* Add fastq -d TAG[:VAL] check.  This mirrors view -d and will only output\n  alignments that match TAG (and VAL if specified).\n  (PR #1863, fixes #1854.  Requested by Rasmus Kirkegaard)\n\n* Extend import --order TAG to --order TAG:length.  If length is specified, the\n  tag format goes from integer to a 0-padded string format.  This is a\n  workaround for BAM and CRAM that cannot encode an order tag of over 4 billion\n  records.\n  (PR #1850, fixes #1847.  Reported by Feng Tian)\n\n* New -aa mode for consensus.  This works like the -aa option in depth and\n  mpileup. The single 'a' reports all bases in contigs covered by alignments.\n  Double 'aa' (or '-a -a') reports Ns even for the references with no alignments\n  against them.\n  (PR #1851, fixes #1849.  Requested by Tim Fennell)\n\n* Add long option support to samtools index.\n  (PR #1872, fixes #1869.  Reported by Jason Bacon)\n\n* Be consistent with rounding of \"average length\" in samtools stats.\n  (PR #1876, fixes #1867.  Reported by Jelinek-J)\n\n* Add option to ampliconclip that marks reads as unmapped when they do not have\n  enough aligned bases left after clipping.  Default is to unmap reads with zero\n  aligned bases.\n  (PR #1865, fixes #1856.  Requested by ces)\n\nBug Fixes:\n\n* [From HTSLib] Fix a major bug when searching against a CRAM index where\n  one container has start and end coordinates entirely contained within the\n  previous container. This would occasionally miss data, and sometimes\n  return much more than required.  The bug affected versions 1.11 to 1.17,\n  although the change in 1.11 was bug-fixing multi-threaded index queries.\n  This bug did not affect index building.  There is no need to reindex your\n  CRAM files.\n  (PR #samtools/htslib#1574, PR #samtools/htslib#1640. Fixes\n  #samtools/htslib#1569, #samtools/htslib#1639, #1808, #1819.  Reported by\n  xuxif, Jens Reeder and Jared Simpson)\n\n* Fix a sort -M bug (regression) when merging sub-blocks.  Data was valid but\n  in a poor order for compression.\n  (PR #1812)\n\n* Fix bug in split output format.  Now SAM and CRAM format can chosen as well\n  as BAM.  Also a documentation change, see below.\n  (PR #1821)\n\n* Add error checking to view -e filter expression code.  Invalid expressions\n  were not returning an error code.\n  (PR #1833, fixes #1829.  Reported by Steve Huang)\n\n* Fix reheader CRAM output version.  Sets the correct CRAM output version for\n  non-3.0 CRAMs.\n  (PR #1868, fixes #1866.  Reported by John Marshall)\n\nDocumentation:\n\n* Expand the default filtering information on the mpileup man page.\n  (PR #1802, fixes #1801.  Reported by gevro)\n\n* Add an explanation of the default behaviour of split files on generating\n  a file for reads with missing or unrecognised RG tags.  Also a small bug fix,\n  see above.\n  (PR #1821, fixes #1817.  Reported by Steve Huang)\n\n* In the INSTALL instructions, switched back to openssl for Alpine.  This\n  matches the current Alpine Linux practice.\n  (PR #1837, see htslib#1591.  Reported by John Marshall)\n\n* Fix various typos caught by lintian parsers.\n  (PR #1877.  Thanks to Étienne Mollier)\n\n* Document consensus --qual-calibration option.\n  (PR #1880, fixes #1879.  Reported by John Marshall)\n\n* Updated the page about samtools duplicate marking with more detail at\n  www.htslib.org/algorithms/duplicate.html\n\nNon user-visible changes and build improvements:\n\n* Removed a redundant line that caused a warning in gcc-13.\n  (PR #1838)\n\n\nRelease 1.17 (21st February 2023)\n---------------------------------\n\nNew work and changes:\n\n* New samtools reset subcommand.  Removes alignment information.  Alignment\n  location, CIGAR, mate mapping and flags are updated. If the alignment was in\n  reverse direction, sequence and its quality values are reversed and\n  complemented and the reverse flag is reset.  Supplementary and secondary\n  alignment data are discarded.\n  (PR #1767, implements #1682. Requested by dkj)\n\n* New samtools cram-size subcommand.  It writes out metrics about a CRAM file\n  reporting aggregate sizes per block \"Content ID\" fields, the data-series\n  contained within them, and the compression methods used.\n  (PR #1777)\n\n* Added a --sanitize option to fixmate and view.  This performs some sanity\n  checks on the state of SAM record fields, fixing up common mistakes made by\n  aligners.\n  (PR #1698)\n\n* Made better use of threading during the merge stage of samtools sort.\n  It also now limits the number of temporary files present by making\n  intermediate merges if the count gets too high.\n  (PR #1706)\n\n* Permit 1 thread with samtools view.  All other subcommands already allow this\n  and it does provide a modest speed increase.\n  (PR #1755, fixes #1743. Reported by Goran Vinterhalter)\n\n* Add CRAM_OPT_REQUIRED_FIELDS option for view -c.  This is a big speed up for\n  CRAM (maybe 5-fold), but it depends on which filtering options are being used.\n  (PR #1776, fixes #1775. Reported by Chang Y)\n\n* New filtering options in samtools depth.  The new --excl-flags option is a\n  synonym for -G, with --incl-flags and --require-flags added to match view\n  logic.\n  (PR #1718, fixes #1702. Reported by Dario Beraldi)\n\n* Speed up calmd's slow handling of non-position-sorted data by adding caching.\n  This uses more memory but is only activated when needed.\n  (PR #1723, fixes #1595. Reported by lxwgcool)\n\n* Improve samtools consensus for platforms with instrument specific profiles,\n  considerably helping for data with very different indel error models and\n  providing base quality recalibration tables. On PacBio HiFi, ONT and\n  Ultima Genomics consensus qualities are also redistributed within homopolymers\n  and the likelihood of nearby indel errors is raised.\n  (PR #1721, PR #1733)\n\n* Consensus --mark-ins option.  This permits he consensus output to include a\n  markup indicating the next base is an insertion. This is necessary as we need\n  a way of outputting both consensus and also how that consensus marries up with\n  the reference coordinates.\n  (PR #1746)\n\n* Consensus min depth now works on the overall depth of the data, in line with\n  the documentation.  Added a --min-BQ (minimum base quality) filtering option.\n  (PR #1704, fixes #1700 reported by Thiseas C. Lamnidis)\n\n* Make faidx/fqidx output line length default to the input line length.\n  (PR #1738, fixes #1734. Reported by John Marshall)\n\n* Speed up optical duplicate checking where data has a lot of duplicates\n  compared to non-duplicates.\n  (PR #1779, fixes #1771. Reported by Poshi)\n\n* Added option to add read group matching to the duplicate criteria.  Change\n  stats to include read groups and add an optional JSON format.\n  (PR #1699, implements #1143 requested by Jonathan Keats)\n\n* For collate use TMPDIR environment variable, when looking for a temporary\n  folder.\n  (PR #1782, based on PR #1178 and fixes #1172.  Reported by Martin Pollard)\n\nBug Fixes:\n\n* Fix stats breakage on long deletions when given a reference.\n  (PR #1712, fixes #1707. Reported by John Didion)\n\n* In ampliconclip, stop hard clipping from wrongly removing entire reads.\n  (PR #1722, fixes #1717. Reported by Kevin Xu)\n\n* Fix bug in ampliconstats where references mentioned in the input file headers\n  but not in the bed file would cause it to complain that the SAM headers were\n  inconsistent.\n  (PR #1727, fixes #1650. Reported by jPontix)\n\n* Fixed SEGV in samtools collate when no filename given.\n  (PR #1724)\n\n* Changed the default UMI barcode regex in markdup.  The old regex was too\n  restrictive.  This version will at least allow the default read name UMI as\n  given in the Illumina example documentation.\n  (PR #1737, fixes #1730. Reported by yloemie)\n\n* Fix samtools consensus buffer overrun with MD:Z handling.\n  (PR #1745, fixes #1744. Reported by trilisser)\n\n* Fix a buffer read-overflow in mpileup and tview on sequences with seq \"*\".\n  (PR #1747)\n\n* Fix view -X command line parsing that was broken in 1.15.\n  (PR #1772, fixes #1720.  Reported by Francisco Rodríguez-Algarra\n  and Miguel Machado)\n\n* Stop samtools view -d from reporting meaningless system errors when\n  tag validation fails.\n  (PR #1796)\n\nDocumentation:\n\n* Add a description of the samtools tview display layout to the man page.\n  Documents . vs , and upper vs lowercase. Adds a -s sample example, and\n  documents the -w option.\n  (PR #1765, fixes #1759. Reported by Lucas Ferreira da Silva)\n\n* Clarify intention of samtools fasta/q in man page and soft vs hard\n  clipping.\n  (PR #1794, fixes #1792. Reported by Ryan Lorig-Roach)\n\n* Minor fix to wording of mpileup --rf usage and man page.\n  (PR #1795, fixes #1791. Reported by Luka Pavageau)\n\nNon user-visible changes and build improvements:\n\n* Use POSIX grep in testing as egrep and fgrep are considered obsolete.\n  (PR #1726, thanks to David Seifert)\n\n* Switch MacOS CI tests to an ARM-based image.\n  (PR #1770)\n\n\nRelease 1.16.1 (2nd September 2022)\n-----------------------------------\n\nBug fixes:\n\n * Fixed a bug with the template-coordinate sort which caused incorrect\n   ordering when using threads, or processing large files that don't\n   fit completely in memory.\n   (PR #1703, thanks to Nils Homer)\n\n * Fixed a crash that occurred when trying to use `samtools merge` in\n   template-coordinate mode.\n   (PR #1705, thanks to Nils Homer)\n\nRelease 1.16 (18th August 2022)\n-------------------------------\n\nNew work and changes:\n\n * samtools reference command added.  This subcommand extracts the embedded\n   reference out of a CRAM file.\n   (PR #1649, addresses #723.  Requested by Torsten Seemann)\n\n * samtools import now adds grouped by query-name to the header.\n   (PR #1633, thanks to Nils Homer)\n\n * Made samtools view read error messages more generic.  Former error message\n   would claim that there was a \"truncated file or corrupt BAM index file\" with\n   no real justification.  Also reset errno in stream_view which could lead to\n   confusing error messages.\n   (PR #1645, addresses some of the issues in #1640.  Reported by Jian-Guo Zhou)\n\n * Make samtools view -p also clear mqual, tlen and cigar.\n   (PR #1647, fixes #1606.  Reported by eboyden)\n\n * Add bedcov option -c to report read count.\n   (PR #1644, fixes #1629.  Reported by Natchaphon Rajudom)\n\n * Add UMI/barcode handling to samtools markdup.\n   (PR #1630, fixes #1358 and #1514.  Reported by Gert Hulselmans and Poshi)\n\n * Add a new template coordinate sort order to samtools sort and\n   samtools merge.  This is useful when working with unique molecular\n   identifiers (UMIs).\n   (PR #1605, fixes #1591.  Thanks to Nils Homer)\n\n * Rename mpileup --ignore-overlaps to --ignore-overlaps-removal\n   or --disable-overlap-removal.  The previous name was ambiguous and was often\n   read as an option to enable removal of overlapping bases, while in reality\n   this is on by default and the option turns off the ability to remove\n   overlapping bases.\n   (PR #1666, fixes #1663.  Reported by yangdingyangding)\n\n * The dict command can now read BWA's .alt file and add AH:* tags\n   indicating reference sequences that represent alternate loci.\n   (PR #1676.  Thanks to John Marshall)\n\n * The \"samtools index\" command can now accept multiple alignment filenames\n   with the new -M option, and will index each of them separately. (Specifying\n   the output index filename via out.index or the new -o option is currently\n   only applicable when there is only one alignment file to be indexed.)\n   (PR #1674.  Reported by Abigail Ramsøe and Nicola Romanò.\n    Thanks to John Marshall)\n\n * Allow samtools fastq -T \"*\".\n   This allows all tags from SAM records to be written to fastq headers. This is\n   a counterpart to samtools import -T \"*\".\n   (PR #1679.  Thanks to cjw85)\n\nBug Fixes:\n\n * Re-enable --reference option for samtools depth.  The reference is not used\n   but this makes the command line usage compatible with older releases.\n   (PR #1646, fixes #1643.  Reported by Randy Harr)\n\n * Fix regex coordinate bug in samtools markdup.\n   (PR #1657, fixes #1642.  Reported by Randy Harr)\n\n * Fix divide by zero in plot-bamstats -m, on unmapped data.\n   (PR #1678, fixes #1675.  Thanks to Shane McCarthy)\n\n * Fix missing RG headers when using samtools merge -r.\n   (PR #1683, addresses htslib#1479.  Reported by Alex Leonard)\n\n * Fix a possible unaligned access in samtools reference.\n   (PR #1696)\n\nDocumentation:\n\n * Add documentation on CRAM compression profiles and some of the newer options\n   that appear in CRAM 3.1 and above.\n   (PR #1659, fixes #1656.  Reported by Matthias De Smet)\n\n * Add \"sclen\" filter expression keyword documentation.\n   (PR #1661, see also htslib#1441)\n\n * Extend FILTER EXPRESSION man page section to match the changes made in\n   HTSlib.\n   (PR #1687, samtools/htslib#1478)\n\nNon user-visible changes and build improvements:\n\n * Ensure generated test files are ignored (by git) and cleaned (by make\n   testclean)\n   (PR #1692, Thanks to John Marshall)\n\nRelease 1.15.1 (7th April 2022)\n-------------------------------\n\nBug fixes:\n\n * A bug which prevented the samtools view --region-file (and the\n   equivalent -M -L <file>) options from working in version 1.15 has\n   been fixed. (#1617)\n\n * Fixed a crash triggered by using the samtools view -c/--count and --unmap\n   options together.  The --unmap option is now ignored in counting mode.\n   (#1619)\n\nDocumentation:\n\n * The consensus command was missing from the main samtools.1 manual page.\n   It has now been added. (#1603)\n\n * Corrected instructions for reproducing the samtools stats \"raw total\n   sequences\" count using samtools view -c. (#1620; reported by @krukanna)\n\n * Improved manual page formatting.  (#1625; thanks to John Marshall)\n\nNon user-visible changes and build improvements:\n\n * Unnecessary #include lines have been removed from bam_plcmd.c. (#1607;\n   thanks to John Marshall)\n\nRelease 1.15 (21st February 2022)\n---------------------------------\n\nNotice:\n\n * Samtools mpileup VCF and BCF output (deprecated in release 1.9) has been\n   removed.  Please use bcftools mpileup instead.\n\nNew work and changes:\n\n * Added \"--min-BQ\" and \"--min-MQ\" options to \"depth\". These match the\n   equivalent long options found in \"samtools mpileup\" and gives a consistent\n   way of specifying the base and mapping quality filters.\n   (#1584; fixes #1580. Reported by Chang Y)\n\n * Improved automatic file type detection with \"view -u\" or \"view -1\".  Setting\n   either of these options would default to BAM format regardless of the usual\n   automatic file type selection based on the file name.  The defaults are now\n   only used when the file name does not indicate otherwise.\n   (#1582)\n\n * For \"markdup\" optical duplicate marking add regex options for custom\n   coordinates.  For the case of non standard read names (QNAME), add options\n   to read the coordinates and, optionally, another part of the string to test\n   for optical duplication.\n   (#1558)\n\n * New \"samtools consensus\" subcommand for generating consensus from SAM, BAM or\n   CRAM files based on the contents of the alignment records.  The consensus is\n   written as FASTA, FASTQ or as a pileup oriented format.  The default\n   FASTA/FASTQ output includes one base per non-gap consensus, with insertions\n   with respect to the aligned reference being included and deletions removed.\n   This could be used to compute a new reference from sequence assemblies to\n   realign against.\n   (#1557)\n\n * New \"samtools view --fetch-pairs\" option.  This options retrieves pairs even\n   when the mate is outside of the requested region.  Using this option enables\n   the multi-region iterator and a region to search must be specified.  The\n   input file must be an indexed regular file.\n   (#1542)\n\n * Building on #1530 below, add a tview reflist for Goto.\n   (#1539, thanks to Adam Blanchet)\n\n * Completion of references added to tview Goto.\n   (#1530; thanks to Adam Blanchet)\n\n * New \"samtools head\" subcommand for conveniently displaying the headers\n   of a SAM, BAM, or CRAM file. Without options, this is equivalent to\n   `samtools view --header-only --no-PG` but more succinct and memorable.\n   (#1517; thanks to John Marshall)\n\nBug Fixes:\n * Free memory when stats fails to read the header of a file.\n   (#1592; thanks to Mathias Schmitt)\n\n * Fixed empty field on unsupported aux tags in \"mpileup --output-extra\".\n   Replaces the empty fields on unsupported aux tags with a '*'.\n   (#1553; fixes #1544. Thanks to Adam Blanchet)\n\n * In mpileup, the --output-BP-5 and --output-BP are no longer mutually\n   exclusive.  This fixes the problem of output columns being switched.\n   (#1540; fixes 1534.  Reported by Konstantin Riege)\n\n * Fix for hardclip bug in ampliconclip.  Odd length sequences resulted in\n   random characters appearing in sequence.\n   (#1538; fixes #1527. Reported by Ivana Mihalek)\n\nDocumentation:\n\n * Improved mpileup documentation.\n   (#1566; fixes #1564.  Reported by Chang Y)\n\n * Fixed \"samtools depth -J\" documentation, which was reversed.\n   (#1552; fixes #1549.  Reported by Stephan Hutter)\n\n * Numerous minor man page fixes.\n   (#1528, #1536, #1579, #1590.  Thanks to John Marshall for some of these)\n\nNon user-visible changes and build improvements:\n\n * Replace CentOS test build with Rocky Linux.  The CentOS Docker images that\n   our test build depended on has stopped working.  Switched to Rocky Linux as\n   the nearest available equivalent.\n   (#1589)\n\n * Fix missing autotools on Appveyor.  Newer versions of msys2 removed autotools\n   from their base-devel package.  This is putting them back.\n   (#1575)\n\n * Fixed bug detected by clang-13 with -Wformat-security.\n   (#1553)\n\n * Switch to using splaysort in bam_lpileup.  Improves speed and efficiency in\n   \"tview\".\n   (#1548; thanks to Adam Blanchet)\n\n\nRelease 1.14 (22nd October 2021)\n--------------------------------\n\nNotice:\n\n * Samtools mpileup VCF and BCF output (deprecated in release 1.9)\n   will be removed in the next release.  Please use bcftools mpileup\n   instead.\n\nNew work and changes:\n\n * The legacy samtools API (libbam.a, bam_endian.h, sam.h and most of\n   bam.h) has been removed.  We recommend coding against the HTSlib\n   API directly. The legacy API had not been actively maintained since\n   2015. (#1483)\n\n * New \"samtools samples\" command to list the samples used in a\n   SAM/BAM/CRAM file. (#1432; thanks to Pierre Lindenbaum)\n\n * \"mpileup\" now supports base modifications via the SAM Mm/MM\n   auxiliary tag.  Please see the \"--output-mods\" option. (#1311)\n\n * Added \"mpileup --output-BP-5\" option to output the BP field in 5'\n   to 3' order instead of left to right. (#1484; fixes #1481)\n\n * Added \"samtools view --rf\" option as an additional FLAG filtering\n   method.  This keeps records only if (FLAG & N) != 0. (#1508; fixes\n   #1470)\n\n * New \"samtools import -N\" option to use the second word on a FASTQ\n   header line, matching the SRA/ENA FASTQ variant. (#1485)\n\n * Improve \"view -x\" option to simplify specifying multiple tags, and\n   added the reverse \"--keep-tag\" option to include rather than\n   exclude. (#516)\n\n * Switched the processing order of \"view\" -x (tag filtering) and -e\n   (expression) handling.  Expressions now happen first so we can\n   filter on tags which are about to be deleted.  This is now\n   consistent with the \"view -d\" behaviour too. (#1480; fixes\n   #1476. Reported by William Rowell)\n\n * Added filter expression \"endpos\" keyword. (#1464.  Thanks to\n   John Marshall)\n\n * \"samtools view\" errors now appear after any SAM output, improving\n   their visibility. (#1490.  Thanks to John Marshall)\n\n * Improved \"samtools sort\" use of temporary files, both tidying up\n   if it fails and recovery when facing pre-existing temporary files.\n   (#1510; fixes #1035, #1503.  Reported by Vivek Rai and\n   Maarten Kooyman)\n\n * Filtering in \"samtools markdup\" now sets the UNMAP BAM flag when\n   given the \"-p\" option. (#1512; fixes #1469)\n\n * Make CRAM references shared during \"samtools merge\" so merging many\n   files has a lower memory usage. (#471)\n\nBug fixes:\n\n * Prevent \"samtools depth\" from closing stdout when outputting to\n   terminal, avoiding a bad interaction with PySam. (#1465.  Thanks\n   to John Marshall)\n\n * In-place \"samtools reheader\" now works on CRAMs produced using a\n   higher than default compression level. (#1479)\n\n * Fix setting of the dt tag in \"markdup\".  Optical duplicates were\n   being marked too early, negating the tagging and counting elsewhere.\n   (#1487; fixes #1486.  Reported by Kevin Lewis)\n\n * Reinstate the \"samtools stats -I\" option to filter by sample.\n   (#1496; fixes #1489.  Reported by Matthias Bernt)\n\n * Fix \"samtools fastq\" handling of dual index tags on single-ended\n   input. (#1474)\n\n * Improve \"samtools coverage\" documentation. (#1521; fixes #1504.\n   Reported by Peter Menzel)\n\nNon user-visible changes and build improvements:\n\n * Replace Curses mvprintw() with va_list-based\n   equivalent. (#1509. Thanks to John Marshall and Andreas Tille)\n\n * Fixed some clang-13 warning messages. (#1506)\n\n * Improve quoting of options in \"samtools import\" tests. (#1466.\n   Thanks to John Marshall)\n\n * Fixed a faulty test which caused test harness failures on NetBSD. (#1520)\n\nRelease 1.13 (7th July 2021)\n----------------------------\n\n * Fixed samtools view FILE REGION, mpileup -r REGION, coverage -r REGION and\n   other region queries: fixed bug introduced in 1.12, which led to region\n   queries producing very few reads for some queries (especially for larger\n   target regions) when unmapped reads were present.\n   Thanks to @vinimfava (#1451), @JingGuo1997 (#1457) and Ramprasad Neethiraj\n   (#1460) for reporting the respective issues.\n\n * Added options to set and clear flags to samtools view.  Along with the\n   existing remove aux tags this gives the ability to remove mark duplicate\n   changes (part of #1358)\n   (#1441)\n\n * samtools view now has long option equivalents for most of its single-letter\n   options. Thanks to John Marshall.\n   (#1442)\n\n * A new tool, samtools import, has been added.  It reads one or more FASTQ\n   files and converts them into unmapped SAM, BAM or CRAM.\n   (#1323)\n\n * Fixed samtools coverage error message when the target region name is not\n   present in the file header. Thanks to @Lyn16 for reporting it.\n   (#1462; fixes #1461)\n\n * Made samtools coverage ASCII mode produce true ASCII output.  Previously it\n   would produce UTF-8 characters.\n   (#1423; fixes #1419)\n\n * samtools coverage now allows setting the maximum depth, using the -d/--depth\n   option. Also, the default maximum depth has been set to 1000000.\n   (#1415; fixes #1395)\n\n * Complete rewrite of samtools depth.  This means it is now considerably faster\n   and does not need a depth limit to avoid high memory usage.  Results should\n   mostly be the same as the old command with the potential exception of overlap\n   removal.\n   (#1428; fixes #889, helps ameliorate #1411)\n\n * samtools flags now accepts any number of command line arguments,\n   allowing multiple SAM flag combinations to be converted at once.  Thanks to\n   John Marshall.\n   (#1401, fixes #749)\n\n * samtools ampliconclip, ampliconstats and plot-ampliconstats now support\n   inputs that list more than one reference.\n   (#1410 and #1417; fixes #1396 and #1418)\n\n * samtools ampliconclip now accepts the --tolerance option, which allows the\n   user to set the number of bases within which a region is matched.  The\n   default is 5.\n   (#1456)\n\n * Updated the documentation on samtools ampliconclip to be clearer about what\n   it does.  From a suggestion by Nathan S Watson-Haigh.\n   (#1448)\n\n * Fixed negative depth values in ampliconstats output.\n   (#1400)\n\n * samtools addreplacerg now allows for updating (replacing) an existing\n   `@RG` line in the output header, if a new `@RG` line is provided in the\n   command line, via the -r argument. The update still requires the user's\n   approval, which can be given with the new -w option.  Thanks to Chuang Yu.\n   (#1404)\n\n * Stopped samtools cat from outputting multiple CRAM EOF markers.\n   (#1422)\n\n * Three new counts have been added to samtools flagstat: primary, mapped\n   primary and duplicate primary.\n   (#1431; fixes #1382)\n\n * samtools merge now accepts a `-o FILE` option specifying the output file,\n   similarly to most other subcommands. The existing way of specifying it\n   (as the first non-option argument, alongside the input file arguments)\n   remains supported. Thanks to David McGaughey and John Marshall.\n   (#1434)\n\n * The way samtools merge checks for existing files has been changed\n   so that it does not hang when used on a named pipe.\n   (#1438; fixes #1437)\n\n * Updated documentation on mpileup to highlight the fact that the filtering\n   options on FLAGs work with ANY rules.\n   (#1447; fixes #1435)\n\n * samtools can now be configured to use a copy of HTSlib that has been set\n   up with separate build and source trees.  When this is the case, the\n   `--with-htslib` configure option should be given the location of the HTSlib\n   build tree.  (Note that samtools itself does not yet support out-of-tree\n   builds).  Thanks to John Marshall.\n   (#1427; companion change to samtools/htslib#1277)\n\n\nRelease 1.12 (17th March 2021)\n------------------------------\n\n * The legacy samtools API (libbam.a, bam.h, sam.h, etc) has not been actively\n   maintained since 2015. It is deprecated and will be removed entirely in a\n   future SAMtools release. We recommend coding against the HTSlib API directly.\n\n * I/O errors and record parsing errors during the reading of SAM/BAM/CRAM\n   files are now always detected. Thanks to John Marshall (#1379; fixed #101)\n\n * New make targets have been added: check-all, test-all, distclean-all,\n   mostlyclean-all, testclean-all, which allow SAMtools installations to\n   call corresponding Makefile targets from embedded HTSlib installations.\n\n * samtools --version now displays a summary of the compilation details and\n   available features, including flags, used libraries and enabled plugins\n   from HTSlib. As an alias, `samtools version` can also be used. (#1371)\n\n * samtools stats now displays the number of supplementary reads in the\n   SN section. Also, supplementary reads are no longer considered when\n   splitting read pairs by orientation (inward, outward, other). (#1363)\n\n * samtools stats now counts only the filtered alignments that overlap\n   target regions, if any are specified. (#1363)\n\n * samtools view now accepts option -N, which takes a file containing\n   read names of interest. This allows the output of only the reads with\n   names contained in the given file. Thanks to Daniel Cameron. (#1324)\n\n * samtools view -d option now works without a tag associated value, which\n   allows it to output all the reads with the given tag. (#1339; fixed #1317)\n\n * samtools view -d and -D options now accept integer and single character\n   values associated with tags, not just strings. Thanks to `@dariome` and\n   Keiran Raine for the suggestions. (#1357, #1392)\n\n * samtools view now works with the filtering expressions introduced by HTSlib.\n   The filtering expression is passed to the program using the specific option\n   -e or the global long option --input-fmt-option. E.g.\n   `samtools view -e 'qname =~ \"#49$\" && mrefid != refid && refid != -1 &&\n    mrefid != -1' align.bam` looks for records with query-name ending in `#49`\n   that have their mate aligned in a different chromosome. More details can be\n   found in the FILTER EXPRESSIONS section of the main man page. (#1346)\n\n * samtools markdup now benefits from an increase in performance in the\n   situation when a single read has tens or hundreds of thousands of duplicates.\n   Thanks to @denriquez for reporting the issue. (#1345; fixed #1325)\n\n * The documentation for samtools ampliconstats has been added to the samtools\n   man page. (#1351)\n\n * A new FASTA/FASTQ sanitizer script (`fasta-sanitize.pl`) was added, which\n   corrects the invalid characters in the reference names. (#1314) Thanks to\n   John Marshall for the installation fix. (#1353)\n\n * The CI scripts have been updated to recurse the HTSlib submodules when\n   cloning HTSlib, to accommodate for the CRAM codecs, which now reside in the\n   htscodecs submodule. (#1359)\n\n * The CI integrations now include Cirrus-CI rather than Travis. (#1335; #1365)\n\n * Updated the Windows image used by Appveyor to 'Visual Studio 2019'.\n  (#1333; fixed #1332)\n\n * Fixed a bug in samtools cat, which prevented the command from running in\n   multi-threaded mode. Thanks to Alex Leonard for reporting the issue.\n   (#1337; fixed #1336)\n\n * A couple of invalid CIGAR strings have been corrected in the test data.\n   (#1343)\n\n * The documentation for `samtools depth -s` has been improved.\n   Thanks to @wulj2. (#1355)\n\n * Fixed a `samtools merge` segmentation fault when it failed to merge\n   header `@PG` records. Thanks to John Marshall.  (#1394; reported by\n   Kemin Zhou in #1393)\n\n * Ampliconclip and ampliconstats now guard against the BED file\n   containing more than one reference (chromosome) and fail when\n   found.  Adding proper support for multiple references will appear\n   later.  (#1398)\n\n\nRelease 1.11 (22nd September 2020)\n----------------------------------\n\n * New samtools ampliconclip sub-command for removing primers from\n   amplicon-based sequencing experiments, including the current\n   COVID-19 projects.  The primers are listed in a BED file and can be\n   either soft-clipped or hard-clipped. (#1219)\n\n * New samtools ampliconstats sub-command to produce a textual summary\n   of primer and amplicon usage, in a similar style to \"samtools\n   stats\". The misc/plot-ampliconstats script can generate PNG\n   images based on this text report. (#1227)\n\n * Samtools fixmate, addreplacerg, markdup, ampliconclip and sort now\n   accept a -u option to enable uncompressed output, which is useful when\n   sending data over a pipe to another process.  Other subcommands which\n   already support this option for the same purpose are calmd, collate,\n   merge, view and depad. (#1265)\n\n * samtools stats has a new GCT section, where it reports ACGT content\n   percentages, similar to GCC but taking into account the read orientation.\n   (#1274)\n\n * Samtools split now supports splitting by tag content with the -d\n   option (#1211)\n\n * samtools merge now accepts a BED file as a command line argument (-L) and\n   does the merging only with reads overlapping the specified regions (#1156)\n\n * Samtools sort now has a minhash collation (-M) to group unmapped\n   reads with similar sequence together.  This can sometimes\n   significantly reduce the file size. (#1093)\n\n * Samtools bedcov now has -g and -G options to filter-in and\n   filter-out based on the FLAG field.  Also the new -d option adds\n   an extra column per file counting the number of bases with a depth\n   greater than or equal to a given threshold. (#1214)\n\n * Fixed samtools bedcov -j option (discard deletions and ref-skips)\n   with multiple input files (#1212)\n\n * samtools bedcov will now accept BED files with columns separated by\n   spaces as well as tabs (#1246; #1188 reported by Mary Carmack)\n\n * samtools depth can now include deletions (D) when computing the base\n   coverage depth, if the user adds the -J option to the command\n   line (#1163).\n\n * samtools depth will count only the bases of one read, for the overlapping\n   section of a read pair, if the -s option is used in the command line\n   (#1241, thanks to Teng Li).\n\n * samtools depth will now write zeros for the entire reference length,\n   when \"samtools depth -aa\" is run on a file with no alignments. (#1252;\n   #1249 reported by Paul Donovan)\n\n * Stopped depth from closing stdout, which triggered test fails\n   in pysam (#1208, thanks to John Marshall).\n\n * samtools view now accepts remote URIs for FASTA and FAI files.\n   Furthermore, the reference and index file can be provided in a single\n   argument, such as\n   samtools view -T ftp://x.com/ref.fa##idx##ftp://y.com/index.fa.fai a.cram\n   (#1176; samtools/htslib#933 reported by @uitde007)\n\n * samtools faidx gets new options --fai-idx and --gzi-idx to allow\n   specification of the locations of the .fai and (if needed) .gzi index\n   files. (#1283)\n\n * The samtools fasta/fastq '-T' option can now add SAM array (type 'B') tags\n   to the output header lines. (#1301)\n\n * samtools mpileup can now display MAPQ either as ASCII characters (with\n   -s/--output-MQ; column now restored to its documented order as in 1.9 and\n   previous versions) or comma-separated numbers (with --output-extra MAPQ;\n   in SAM column order alongside other selected --output-extra columns).\n\n   When both -s/--output-MQ and -O/--output-BP are used, samtools 1.10 printed\n   the extra columns in the opposite order.  This changes the format produced\n   by 1.10's --output-extra MAPQ. (#1281, thanks to John Marshall; reported\n   by Christoffer Flensburg)\n\n * samtools tview now accepts a -w option to set the output width in\n   text mode (-d T). (#1280)\n\n * The dict command can now add AN tags containing alternative names with\n   \"chr\" prefixes added to or removed from each sequence name as appropriate\n   and listing both \"M\" and \"MT\" alternatives for mitochondria. (#1164,\n   thanks to John Marshall)\n\n * The samtools import command, labelled as obsolete in May 2009 and\n   removed from all help and documentation later that year, has\n   finally been removed.  Use samtools view instead. (#1185)\n\n * Replaced the remaining usage of the Samtools 0.1 legacy API with\n   htslib calls. (#1187, thanks to John Marshall)\n\n * Documentation / help improvements (#1154; #1168; #1191; #1199;\n   #1204; #1313):\n   - Fixed a few man-page table layout issues\n   - Added <file>##idx##<index> filename documentation\n   - Fixed usage statement for samtools addreplacerg\n   - Miscellaneous spelling and grammar fixes\n   - Note fixmate/markdup name collated rather than name sorted input\n   - Note that fastq and fasta inputs should also be name collated\n   - Reshuffled order of main man-page and added -@ to more sub-pages\n   - The misc/seq_cache_populate.pl script now gives REF_CACHE guidance\n\n * Additional documentation improvements, thanks to John Marshall (#1181;\n   #1224; #1248; #1262; #1300)\n   - Emphasise that samtools index requires a position-sorted file\n   - Document 2^29 chromosome length limit in BAI indexes\n   - Numerous typing, spelling and formatting fixes\n\n * Improved the message printed when samtools view fails to read its\n   input (#1296)\n\n * Added build support for the OpenIndiana OS (#1165, thanks to John Marshall)\n\n * Fixed failing tests on OpenBSD (#1151, thanks to John Marshall)\n\n * The samtools sort tests now use less memory so the test suite works better\n   on small virtual machines. (#1159)\n\n * Improved markdup's calculation of insert sizes (#1161)\n   Also improved tests (#1150) and made it run faster when not checking\n   for optical duplicates or adding 'do' tags (#1308)\n\n * Fixed samtools coverage minor inconsistency vs idxstats (#1205; #1203\n   reported by @calliza)\n\n * Fixed samtools coverage quality thresholding options which were the\n   wrong way round compared to mpileup (-q is the mapping quality threshold\n   and -Q is base quality). (#1279; #1278 reported by @kaspernie)\n\n * Fixed bug where `samtools fastq -i` would add two copies of the barcode\n   in the fastq header if both reads in a pair had a \"BC:Z\" tag (#1309;\n   #1307 reported by @mattsoup)\n\n * Samtools calmd no longer errors with a SEQ of \"*\" (#1230; #1229\n   reported by Bob Harris)\n\n * Samtools tview now honours $COLUMNS, fixing some CI tests (#1171; #1162\n   reported by @cljacobs)\n\n * Fixed a samtools depad overflow condition (#1200)\n\n * Improved curses detection in configure script (#1170, #577, #940)\n\n * Fixed samtools stats integer overflows and added support for long\n   references (#1174; #1173)\n\n * Fixed a 1-byte undersized memory allocation in samtools merge. (#1302)\n\n\nRelease 1.10 (6th December 2019)\n--------------------------------\n\nChanges affecting the whole of samtools, or multiple sub-commands:\n\n * Samtools now uses the new HTSlib header API.  As this adds more checks\n   for invalid headers, it is possible that some illegal files will now\n   be rejected when they would have been allowed by earlier versions. (#998)\n\n   Examples of problems that will now be rejected include `@SQ` lines with\n   no SN: tag, and `@RG` or `@PG` lines with no ID: tag.\n\n * samtools sub-commands will now add `@PG` header lines to output sam/bam/cram\n   files.  To disable this, use the '--no-PG' option. (#1087; #1097)\n\n * samtools now supports alignment records with reference positions greater\n   than 2 gigabases.  This allows samtools to process alignments for\n   species which have large chromosomes, like axolotl and lungfish.  Note that\n   due to file format limitations, data with large reference positions\n   must use the SAM format. (#1107; #1117)\n\n * Improved the efficiency of reading and writing SAM format data by 2 fold\n   (single thread). This is further improved by the ability to use multiple\n   threads, as previously done with BAM and CRAM.\n\n * samtools can now write BGZF-compressed SAM format.  To enable this,\n   either save files with a '.sam.gz' suffix, or use '--output-fmt sam.gz'.\n\n * samtools can now index BGZF-compressed SAM files.\n\n * The region parsing code has been improved to handle colons in reference\n   names.  Strings can be disambiguated by the use of braces, so for\n   example when reference sequences called \"chr1\" and \"chr1:100-200\"\n   are both present, the regions \"{chr1}:100-200\" and \"{chr1:100-200}\"\n   unambiguously indicate which reference is being used. (#864)\n\n * samtools flags, flagstats, idxstats and stats now have aliases\n   flag, flagstat, idxstat and stat. (#934)\n\n * A new global '--write-index' option has been added.  This allows output\n   sam.gz/bam/cram files to be indexed while they are being written out.\n   This should work with addreplacerg, depad, markdup, merge, sort, split,\n   and view. (#1062)\n\n * A global '--verbosity' option has been added to enable/disable\n   debugging output. (#1124, thanks to John Marshall)\n\n * It is now possible to have data and index files stored in different\n   locations.  There are two ways to tell samtools where to find the\n   index:\n\n   1. Samtools bedcov, depth, merge, mpileup, stats, tview, and view\n      accept a new option (-X).  When this is used, each input sam/bam/cram\n      listed on the command line should have a corresponding index file.\n      Note that all the data files should be listed first, followed by all\n      the index files. (#978, thanks to Mingfei Shao)\n\n   2. A delimiter '##idx##' can be appended to the data file name followed\n      by the index file name.  This can be used both for input files and\n      outputs when indexing on-the-fly.\n\n * HTSlib (and therefore SAMtools) now uses version 4 signatures by default\n   for its s3:// plug-in.  It can also write to S3 buckets, as long as\n   version 4 signatures are in use.  See HTSlib's NEWS file and\n   htslib-s3-plugin manual page for more information.\n\n * HTSlib (and therefore SAMtools) no longer considers a zero-length empty\n   file to be a valid SAM file.  This has been changed so that pipelines such\n   as `somecmd | samtools ...` with `somecmd` aborting before outputting\n   anything will now propagate the error to the second command.\n\n * The samtools manual page has been split up into one for each\n   sub-command.  The main samtools.1 manual page now lists the sub-commands\n   and describes the common global options. (#894)\n\n * The meaning of decode_md, store_md and store_nm in the fmt-option section\n   of the samtools.1 man page has been clarified. (#898, thanks to Evan Benn)\n\n * Fixed numerous memory leaks. (#892)\n\n * Fixed incorrect macro definition on Windows. (#950)\n\n * bedcov, phase, misc/ace2sam and misc/wgsim now check for failure to open\n   files.  (#1013, thanks to Julie Blommaert and John Marshall)\n\nChanges affecting specific sub-commands:\n\n * A new \"coverage\" sub-command has been added.  This prints a tabular format\n   of the average coverage and percent coverage for each reference sequence,\n   as well as number of aligned reads, average mapping quality and base\n   quality.  It can also (with the '-m' option) plot a histogram of\n   coverage across the genome. (#992, thanks to Florian Breitwieser)\n\n * samtools calmd:\n\n   - Reference bases in MD: tags are now converted to upper case. (#981, #988)\n\n * samtools depth:\n\n   - Add new options to write a header to the output (-H) and to direct\n     the output to a file (-o).  (#937, thanks to Pierre Lindenbaum)\n\n   - New options '-g' and '-G' can be used to filter reads. (#953)\n\n   - Fix memory leak when failing to set CRAM options. (#985, thanks\n     to Florian Breitwieser)\n\n   - Fix bug when using region filters where the '-a' option did not\n     work for regions with no coverage. (#1113; #1112 reported by\n     Paweł Sztromwasser)\n\n * samtools fasta and fastq:\n\n   - '-1 FILE -2 FILE' with the same filename now works properly. (#1042)\n\n   - '-o FILE' is added as a synonym for '-1 FILE -2 FILE'. (#1042)\n\n   - The '-F' option now defaults to 0x900 (SECONDARY,SUPPLEMENTARY).\n     Previously secondary and supplementary records were filtered internally\n     in a way that could not be turned off. (#1042; #939 reported\n     by @finswimmer)\n\n   - Allow reading from a pipe without an explicit '-' on the command line.\n     (#1042; #874 reported by John Marshall)\n\n   - Turn on multi-threading for bgzf compressed output files. (#908)\n\n   - Fixed bug where the samtools fastq -i would output incorrect information\n     in the Casava tags for dual-index reads.  It also now prints the tags\n     for dual indices in the same way as bcl2fastq, using a '+' sign between\n     the two parts of the index. (#1059; #1047 reported by Denis Loginov)\n\n * samtools flagstat:\n\n   - Samtools flagstat can now optionally write its output in JSON format or\n     as a tab-separated values file. (#1106, thanks to Vivek Rai).\n\n * samtools markdup:\n\n   - It can optionally tag optical duplicates (reads following Illumina\n     naming conventions only).  The is enabled with the '-d' option,\n     which sets the distance for duplicates to be considered as optical.\n     (#1091; #1103; #1121; #1128; #1134)\n\n   - The report stats (-s) option now outputs counts for optical and\n     non-primary (supplementary / secondary) duplicates.  It also reports\n     the Picard \"estimate library size\" statistic.  A new '-f' option\n     can be used to save the statistics in a given file. (#1091)\n\n   - The rules for calling duplicates can be changed using the new --mode\n     option.  This mainly changes the position associated with each read in\n     a pair.  '--mode t' (the default) is the existing behaviour where the\n     position used is that of the outermost template base associated with the\n     read. Alternatively '--mode s' always uses the first unclipped sequence\n     base.  In practice, this only makes a difference for read pairs where the\n     two reads are aligned in the same direction. (#1091)\n\n   - A new '-c' option can be used to clear any existing duplicate tags.\n     (#1091)\n\n   - A new '--include-fails' option makes markdup include QC-failed reads.\n     (#1091)\n\n   - Fixed buffer overflow in temporary file writer when writing a mixture\n     of long and short alignment records. (#911; #909)\n\n * samtools mpileup:\n\n   - mpileup can now process alignments including CIGAR P (pad) operators\n     correctly.  They will now also produce the correct output for alignments\n     where insertions are immediately followed by deletions, or deletions by\n     insertions.  Note that due to limitations in HTSlib, they are still\n     unable to output sequences that have been inserted before the first\n     aligned base of a read. (#847; #842 reported by Tiffany Delhomme.\n     See also htslib issue #59 and pull request #699).\n\n   - In samtools mpileup, a deletion or pad on the reverse strand is now\n     marked with a different character ('#') than the one used on a forward\n     strand ('*'), if the '--reverse-del' option is used. (#1070)\n\n   - New option '--output-extra' can be used to add columns for user\n     selected alignment fields or aux tags. (#1073)\n\n   - Fixed double-counting of overlapping bases in alignment records with\n     deletions or reference skips longer than twice the insert size.\n     (#989; #987 reported by @dariomel)\n\n   - Improved manual page with documentation about what each output column\n     means. (#1055, thanks to John Marshall)\n\n * samtools quickcheck:\n\n   - Add unmapped (-u) option, which disables the check for `@SQ` lines in\n     the header. (#920, thanks to Shane McCarthy)\n\n * samtools reheader:\n\n   - A new option '-c' allows the input header to be passed to a given\n     command.  Samtools then takes the output of this command and uses it\n     as the replacement header. (#1007)\n\n   - Make it clear in help message that reheader --in-place only works on\n     CRAM files. (#921, thanks to Julian Gehring)\n\n   - Refuse to in-place reheader BAM files, instead of unexpectedly writing\n     a BAM file to stdout. (#935)\n\n * samtools split:\n\n   - In samtools split, the '-u' option no longer accepts an extra file name\n     from which a replacement header was read.  The two file names were\n     separated using a colon, which caused problems on Windows and prevented\n     the use of URLs.  A new '-h' option has been added to allow the replacement\n     header file to be specified in its own option. (#961)\n\n   - Fixed bug where samtools split would crash if it read a SAM header that\n     contained an `@RG` line with no ID tag. (#954, reported by @blue-bird1)\n\n * samtools stats:\n\n   - stats will now compute base compositions for BC, CR, OX and RX tags,\n     and quality histograms for QT, CY, BZ and QX tags. (#904)\n\n   - New stats FTC and LTC showing total number of nucleotides for first and\n     last fragments. (#946)\n\n   - The rules for classifying reads as \"first\" or \"last\" fragment have been\n     tightened up. (#949)\n\n   - Fixed bug where stats could over-estimate coverage when using the\n     target-regions option or when a region was specified on the command-line.\n     (#1027; #1025, reported by Miguel Machado; #1029, reported by Jody Phelan).\n\n   - Fixed error in stats GCD percentile depth calculation when the depth to be\n     reported fell between two bins.  It would report the depth entirely from\n     the lower bin instead of taking a weighted average of the two. (#1048)\n\n   - Better catching and reporting of out of memory conditions. (#984;\n     #982, reported by Jukka Matilainen)\n\n   - Improved manual page. (#927)\n\n * samtools tview:\n\n   - tview can now display alignments including CIGAR P operators, D followed\n     by I and I followed by D correctly.  See mpileup above for more\n     information. (#847; #734, reported by Ryan Lorig-Roach)\n\n   - The \"go to position\" text entry box has been made wider. (#968, thanks\n     to John Marshall)\n\n   - Fixed samtools tview -s option which was not filtering reads correctly.\n     It now only shows reads from the requested sample or read group. (#1089)\n\n * samtools view:\n\n   - New options '-d' and '-D' to only output alignments which have a tag\n     with a given type and value. (#1001, thanks to Gert Hulselmans)\n\n * misc/plot-bamstats script:\n\n   - Fixed merge (-m) option. (#923, #924 both thanks to Marcus D Sherman)\n\n   - Made the quality heatmap work with gnuplot version 5.2.7 and later.\n     (#1068; #1065 reported by Martin Mokrejš)\n\n   - Fixed --do-ref-stats bug where fasta header lines would be counted\n     as part of the sequence when the --targets option was used. (#1120,\n     thanks to Neil Goodgame)\n\n * Removed the misc/varfilter.py Python script, as it takes consensus-pileup\n   as input, which was removed from samtools in release 0.1.17 in 2011. (#1125)\n\nRelease 1.9 (18th July 2018)\n----------------------------\n\n * Samtools mpileup VCF and BCF output is now deprecated.  It is still\n   functional, but will warn.  Please use bcftools mpileup instead. (#884)\n\n * Samtools mpileup now handles the '-d' max_depth option differently.  There\n   is no longer an enforced minimum, and '-d 0' is interpreted as limitless\n   (no maximum - warning this may be slow).  The default per-file depth is\n   now 8000, which matches the value mpileup used to use when processing\n   a single sample.  To get the previous default behaviour use the higher\n   of 8000 divided by the number of samples across all input files, or 250.\n   (#859)\n\n * Samtools stats new features:\n\n   - The '--remove-overlaps' option discounts overlapping portions of\n     templates when computing coverage and mapped base counting. (#855)\n\n   - When a target file is in use, the number of bases inside the\n     target is printed and the percentage of target bases with coverage\n     above a given threshold specified by the '--cov-threshold' option. (#855)\n\n   - Split base composition and length statistics by first and last reads.\n     (#814, #816)\n\n * Samtools faidx new features:\n\n   - Now takes long options. (#509, thanks to Pierre Lindenbaum)\n\n   - Now warns about zero-length and truncated sequences due to the\n     requested range being beyond the end of the sequence. (#834)\n\n   - Gets a new option (--continue) that allows it to carry on\n     when a requested sequence was not in the index. (#834)\n\n   - It is now possible to supply the list of regions to output in a text\n     file using the new '--region-file' option. (#840)\n\n   - New '-i' option to make faidx return the reverse complement of\n     the regions requested. (#878)\n\n   - faidx now works on FASTQ (returning FASTA) and added a new\n     fqidx command to index and return FASTQ. (#852)\n\n * Samtools collate now has a fast option '-f' that only operates on\n   primary pairs, dropping secondary and supplementary.  It tries to write\n   pairs to the final output file as soon as both reads have been found. (#818)\n\n * Samtools bedcov gets a new '-j' option to make it ignore deletions (D) and\n   reference skips (N) when computing coverage. (#843)\n\n * Small speed up to samtools coordinate sort, by converting it to use\n   radix sort. (#835, thanks to Zhuravleva Aleksandra)\n\n * Samtools idxstats now works on SAM and CRAM files, however this\n   isn't fast due to some information lacking from indices. (#832)\n\n * Compression levels may now be specified with the level=N\n   output-fmt-option.  E.g. with -O bam,level=3.\n\n * Various documentation improvements.\n\n * Bug-fixes:\n\n   - Improved error reporting in several places. (#827, #834, #877, cd7197)\n\n   - Various test improvements.\n\n   - Fixed failures in the multi-region iterator (view -M) when regions\n     provided via BED files include overlaps (#819, reported by Dave Larson).\n\n   - Samtools stats now counts '=' and 'X' CIGAR operators when\n     counting mapped bases. (#855)\n\n   - Samtools stats has fixes for insert size filtering (-m, -i). (#845; #697\n     reported by Soumitra Pal)\n\n   - Samtools stats -F now longer negates an earlier -d option. (#830)\n\n   - Fix samtools stats crash when using a target region. (#875, reported by\n     John Marshall)\n\n   - Samtools sort now keeps to a single thread when the -@ option is absent.\n     Previously it would spawn a writer thread, which could cause the CPU\n     usage to go slightly over 100%. (#833, reported by Matthias Bernt)\n\n   - Fixed samtools phase '-A' option which was incorrectly defined to take\n     a parameter. (#850; #846 reported by Dianne Velasco)\n\n   - Fixed compilation problems when using C_INCLUDE_PATH. (#870; #817 reported\n     by Robert Boissy)\n\n   - Fixed --version when built from a Git repository. (#844, thanks to\n     John Marshall)\n\n   - Use noenhanced mode for title in plot-bamstats.  Prevents unwanted\n     interpretation of characters like underscore in gnuplot version 5. (#829,\n     thanks to M. Zapukhlyak)\n\n   - blast2sam.pl now reports perfect match hits (no indels or mismatches).\n     (#873, thanks to Nils Homer)\n\n   - Fixed bug in fasta and fastq subcommands where stdout would not be flushed\n     correctly if the -0 option was used.\n\n   - Fixed invalid memory access in mpileup and depth on alignment records\n     where the sequence is absent.\n\nRelease 1.8 (3rd April 2018)\n----------------------------\n\n * samtools calmd now has a quiet mode.  This can be enabled by passing `-Q` to\n   calmd. (Thanks to Colin Davenport)\n\n * In samtools depth `-d 0` will effectively remove the depth limit. (#764)\n\n * Improvements made to samtools collate's interface and documentation.  It is\n   now possible to specify an output file name using `-o`, instead of deriving\n   it from the prefix used for temporary files.  The prefix itself is now\n   optional if `-o` or `-O` (to stdout) is used. (#780)\n\n * Bug-fixes:\n\n   - Make samtools addreplacerg choose output format by file extension. (#767;\n     reported by Argy Megalios)\n\n   - Merge tests now work on ungzipped data, allowing tests to be run against\n     different deflate libraries.\n\n   - samtools markdup error messages about missing tags have been updated with\n     the suggestion that samtools fixmate is run beforehand. (#765; reported by\n     Yudong Cai)\n\n   - Enables the `--reference` option for samtools fastq.  Now works like other\n     programs when a reference sequence is needed for CRAM files. (#791,\n     reported by Milana Kaljevic)\n\n\nRelease 1.7 (26th January 2018)\n--------------------\n\n* HTSlib, and so samtools, now support BAMs which include CIGARs with more\n  than 65535 operations as per HTS-Specs 18th November (dab57f4 and 2f915a8).\n\n* samtools quickcheck will now write a warning to stderr if it finds\n  any problems.  These messages can be suppressed with a new `-q` option.\n\n* samtools markdup can now mark supplementary alignments of reads where\n  the primary alignment is found to be a duplicate.  Supplementary marking\n  can be turned on by passing the `-S` option to markdup.  When this\n  option is enabled, all the alignment data will be written to a temporary\n  file so that supplementary alignments that occur before a duplicated\n  primary can be correctly marked in the final output.  The location\n  of this temporary file can be influenced using the new `-T` option.\n\n* samtools view now supports HTSlib's new multi-region iterator.\n  This can be enabled by passing the `-M` option to view.  When using\n  this option:\n\n  - The BED filter (`-L` option) will use the index to skip through the file\n  - Reads from overlapping regions will only be output once\n\n* samtools bedcov will now ignore BED comment and header lines (#571; thanks\n  to Daniel Baker).\n\n* samtools collate now updates the `@HD` SO: and GO: tags, and sort will\n  remove a GO: tag if present.  (#757; reported by Imran Haque).\n\n* Bug-fixes:\n\n - maq2sam now checks for input files that end early.  (#751; patch supplied\n   by Alexandre Rebert of the Mayhem team, via Andreas Tille from Debian.)\n\n - Fixed incorrect check when looking up header tags that could lead\n   to a crash in samtools stats. (#208; thanks to Dave Larson.)\n\n - Fixed bug in samtools fastq `-O` option where it would fail if\n   the OQ tag in the input file had an unexpected type. (#758;\n   reported by Taejeong Bae)\n\n - The MD5 calculations in samtools dict and md5fa did not handle\n   non-alphabetic characters in the same way as the CRAM MD5 function.\n   They have now been updated to match. (#704; reported by Chris Norman).\n\n - Fix possible infinite loop in samtools targetcut.\n\n - Building bam_tview_curses should no longer fail if a curses header file\n   cannot be found.\n\nRelease 1.6 (28th September 2017)\n--------------------\n\n* Added new markdup sub-command and '-m' option for fixmate.  Used together,\n  they allow duplicates to be marked and optionally removed.  This\n  fixes a number of problems with the old 'rmdup' sub-command, for\n  example samtools issue #497.  'rmdup' is kept for backwards compatibility\n  but 'markdup' should be used in preference.\n\n* Sort is now much better at keeping within the requested memory limit.  It\n  should also be slightly faster and need fewer temporary files when the file\n  to be sorted does not fit in memory.  (#593; thanks to Nathan Weeks.)\n\n* Sort no longer rewrites the header when merging from files.  It can also\n  now merge from memory, so fewer temporary files need to be written and\n  it is better at sorting in parallel when everything fits in memory.\n\n* Both sort and merge now resolve ties when merging based on the position\n  in the input file(s).  This makes them fully stable for all ordering\n  options.  (Previously position sort was stable, but name and by tag\n  sorts were not).\n\n* New --output-qname option for mpileup.\n\n* Support for building on Windows using msys2/mingw64 or cygwin has\n  been improved.\n\nRelease 1.5 [Solstice Release] (21st June 2017)\n--------------------\n\n* Samtools fastq now has a -i option to create a fastq file from an index\n  tag, and a -T option (similar to -t) to add user specified aux tags to\n  the fastq header line.\n\n* Samtools fastq can now create compressed fastq files, by giving the\n  output filenames an extension of .gq, .bgz, or .bgzf\n\n* Samtools sort has a -t TAG option, that allows records to be sorted by\n  the value of the specified aux tag, then by position or name.  Merge\n  gets a similar option, allowing files sorted this way to be merged.\n  (#675; thanks to Patrick Marks of 10xgenomics).\n\nRelease 1.4.1  (8th May 2017)\n-----------------------------\n\n* Added options to fastq to create fastq files from BC (or other)\n  tags.\n\n* Samtools view has gained a -G <flags> option to exclude on all bits\n  set.  For example to discard reads where neither end has been\n  mapped use \"-G 12\".\n\n* Samtools cat has a -b <fofn> option to ease concatenation of many\n  files.\n\n* Added misc/samtools_tab_completion for bash auto-completion of\n  samtools sub-commands. (#560)\n\n* Samtools tview now has J and K keys for verticale movement by 20\n  lines. (#257)\n\n* Various compilation / portability improvements.\n\n* Fixed issue with more than 65536 CIGAR operations and SAM/CRAM files.\n  (#667)\n\n\nRelease 1.4  (13 March 2017)\n----------------------------\n\nNoteworthy changes in samtools:\n\n* Fixed Issue #345 - out-by-one error in insert-size in samtools stats\n\n* bam_split now add a `@PG` header to the bam file\n\n* Added mate cigar tag support to fixmate\n\n* Multi-threading is now supported for decoding BAM and CRAM (as well\n  as the previously supported encoding).  Most commands that read BAM\n  or CRAM have gained an -@ or --threads arguments, providing a\n  significant speed bonus.  For commands that both read and write\n  files the threads are shared between decoding and encoding tasks.\n\n* Added -a option to samtools mpileup to show all locations, including\n  sites with zero depth; repeating the option as -aa or -a -a additionally\n  shows reference sequences without any reads mapped to them (#496).\n\n* The mpileup text output no longer contains empty columns at zero coverage\n  positions.  Previously it would output \"...0\\t\\t...\" in some circumstances\n  (zero coverage due to being below a minimum base quality); this has been\n  fixed to output as \"...0\\t*\\t*...\" with placeholder '*' characters as in\n  other zero coverage circumstances (see PR #537).\n\n* To stop it from creating too many temporary files, samtools sort\n  will now not run unless its per-thread memory limit (-m) is set to\n  at least 1 megabyte (#547).\n\n* The misc/plot-bamstats script now has a -l / --log-y option to change\n  various graphs to display their Y axis log-scaled.  Currently this\n  affects the Insert Size graph (PR #589; thanks to Anton Kratz).\n\n* Fixmate will now also add and update MC (mate CIGAR) tags.\n\n\nBeta Release 1.3.1  (22 April 2016)\n-----------------------------------\n\nNoteworthy changes in samtools:\n\n* The sort command creates any needed temporary files alongside the final\n  output file (similarly to the pre-1.3 behaviour), and now aborts when\n  it detects a collision with another sort invocation's temporary files.\n\n  When the -T PREFIX option specified is a directory (or when sorting to\n  standard output), a random component is now added to temporary filenames\n  to try to avoid collisions (#432, #523, #529, #535, PR #530).\n\n* All samtools commands now check for I/O errors more carefully, especially\n  when writing output files (#111, #253, #470, PR #467).\n\n* Build fixes for 32-bit systems; be sure to run configure on such systems\n  to enable large file support and access to 2GiB+ files.\n\n* The fasta/fastq/bam2fq command no longer ignores reads when the -s option\n  is used (#532).\n\n* The fastq -O option no longer crashes on reads that do not have an OQ tag\n  field (#517).\n\n* The merge and sort commands now handle (unusual) BAM files that have no\n  textual `@SQ` headers (#548, #550).\n\n* Sorting files containing @CO headers no longer duplicates the comment\n  headers, which previously happened on large sorts for which temporary\n  files were needed (#563).\n\n* The rmdup and view -l commands no longer crash on `@RG` headers that do not\n  have a LB field (#538).\n\n* Fixed miscellaneous issues #128, #130, #131, #489, and #514.\n\n\nBeta Release 1.3  (15 December 2015)\n------------------------------------\n\nNoteworthy changes in samtools:\n\n* The obsolete \"samtools sort in.bam out.prefix\" usage has been removed.\n  If you are still using -f, -o, or out.prefix, convert to use -T PREFIX\n  and/or -o FILE instead.  (#295, #349, #356, #418, PR #441; see also\n  discussions in #171, #213.)\n\n* When writing CRAM output, samtools now defaults to writing CRAM v3.0\n  rather than v2.1.\n\n* The \"bamshuf\" command has been renamed to \"collate\" (hence the term\n  bamshuf no longer appears in the documentation, though it still works\n  on the command line for compatibility with existing scripts).\n\n* The mpileup command now outputs the unseen allele in VCF/BCF as <*>\n  rather than X or <X> as previously, and now has AD, ADF, ADR, INFO/AD,\n  INFO/ADF, INFO/ADR --output-tags annotations that largely supersede\n  the existing DV, DP4, DPR annotations.\n\n* The mpileup command now applies BAQ calculations at all base positions,\n  regardless of which -l or -r options are used (previously with -l it was\n  not applied to the first few tens of bases of each chromosome, leading\n  to different mpileup results with -l vs. -r; #79, #125, #286, #407).\n\n* Samtools now has a configure script which checks your build environment\n  and facilitates choosing which HTSlib to build against.  See INSTALL\n  for details.\n\n* Samtools's Makefile now fully supports the standard convention of\n  allowing CC/CPPFLAGS/CFLAGS/LDFLAGS/LIBS to be overridden as needed.\n  Previously it listened to $(LDLIBS) instead; if you were overriding\n  that, you should now override LIBS rather than LDLIBS.\n\n* A new addreplacerg command that adds or alters `@RG` headers and RG:Z\n  record tags has been added.\n\n* The rmdup command no longer immediately aborts (previously it always\n  aborted with \"bam_get_library() not yet implemented\"), but remains\n  not recommended for most use (#159, #252, #291, #393).\n\n* Merging files with millions of headers now completes in a reasonable\n  amount of time (#337, #373, #419, #453; thanks to Nathan Weeks,\n  Chris Smowton, Martin Pollard, Rob Davies).\n\n* Samtools index's optional index output path argument works again (#199).\n\n* Fixed calmd, targetcut, and potential mpileup segfaults when given broken\n  alignments with POS far beyond the end of their reference sequences.\n\n* If you have source code using bam_md.c's bam_fillmd1_core(), bam_cap_mapQ(),\n  or bam_prob_realn_core() functions, note that these now take an additional\n  ref_len parameter.  (The versions named without \"_core\" are unchanged.)\n\n* The tview command's colour scheme has been altered to be more suitable\n  for users with colour blindness (#457).\n\n* Samtools depad command now handles CIGAR N operators and accepts\n  CRAM files (#201, #404).\n\n* Samtools stats now outputs separate \"N\" and \"other\" columns in the\n  ACGT content per cycle section (#376).\n\n* Added -a option to samtools depth to show all locations, including\n  zero depth sites (#374).\n\n* New samtools dict command, which creates a sequence dictionary\n  (as used by Picard) from a FASTA reference file.\n\n* Samtools stats --target-regions option works again.\n\n* Added legacy API sam.h functions sam_index_load() and samfetch() providing\n  bam_fetch()-style iteration over either BAM or CRAM files.  (In general\n  we recommend recoding against the htslib API directly, but this addition\n  may help existing libbam-using programs to be CRAM-enabled easily.)\n\n* Fixed legacy API's samopen() to write headers only with \"wh\" when writing\n  SAM files.  Plain \"w\" suppresses headers for SAM file output, but this\n  was broken in 1.2.\n\n* \"samtools fixmate - -\" works in pipelines again; with 1.0 to 1.2,\n  this failed with \"[bam_mating] cannot determine output format\".\n\n* Restored previous \"samtools calmd -u\" behaviour of writing compression\n  level 0 BAM files.  Samtools 1.0 to 1.2 incorrectly wrote raw non-BGZF\n  BAM files, which cannot be read by most other tools.  (Samtools commands\n  other than calmd were unaffected by this bug.)\n\n* Restored bam_nt16_nt4_table[] to legacy API header bam.h.\n\n* Fixed bugs #269, #305, #320, #328, #346, #353, #365, #392, #410, #445,\n  #462, #475, and #495.\n\n\nBeta Release 1.2  (2 February 2015)\n-----------------------------------\n\nNoteworthy changes in samtools:\n\n* Flagstat now works on SAM, BAM, or CRAM files (rather than BAM only)\n* Stats calculates mismatches per cycle for unclipped length\n* Merge can now merge SAM input files\n* CRAM reference files are now cached by default (see HTSlib release\n  notes and samtools(1) man page)\n* Tested against Intel-optimised zlib (https://github.com/jtkukunas/zlib;\n  see README for details)\n* Fixed bugs #302, #309, #318, and #327 and many other improvements\n  and bugs fixed in HTSlib -- see the HTSlib release notes\n\n\nBeta Release 1.1 (19 September, 2014)\n-------------------------------------\n\nNotable changes in samtools:\n\n * Sorting files with thousands of reference contigs now completes in\n   a reasonable amount of time (#260)\n * Fixmate and flagstat now consider supplementary reads\n * Fixmate now only adds a template cigar tag (\"ct:Z\") when requested\n   via a new -c option, and never adds it repeatedly (#276)\n * Mpileup DPR annotation fixed (#274)\n * Checksum added to stats command output\n * Removed view -Q option\n\n\nBeta Release 1.0 (15 August, 2014)\n----------------------------------\n\nFirst release of HTSlib-based samtools.\n\nNumerous changes, notably support for the CRAM sequencing file format.\n\nThe faidx command now reads either uncompressed or BGZF-compressed FASTA files\ncompressed with bgzip.  In previous samtools-0.1.x versions, faidx could read\neither uncompressed or RAZF-compressed FASTA files, but RAZF and razip are\nsuperseded by BGZF/bgzip and have been removed from samtools.\n\n\nBeta Release 0.1.20 (15 August, 2014)\n-------------------------------------\n\nFinal release of standalone samtools.\n\n\nBeta Release 0.1.19 (15 March, 2013)\n------------------------------------\n\nNotable changes in samtools and bcftools:\n\n * The latest source code and development moved to github,\n    http://github.com/samtools/samtools\n\n * Many important bugfixes and contributions by many people. Thanks to all!\n\n * Performance improvements (multi-threading)\n\n * Important changes in calling, see\n    - samtools mpileup -p\n    - bcftools view -m\n\n * New annotations useful for filtering (RPB, HWE, QBD, MDV)\n\n * New tools, bamcheck and plot-bamcheck\n\n * New features in samtools tview\n\n * And much more..\n\nFor a detailed list of commits, please see\nhttp://github.com/samtools/samtools/commits/master\n\n(0.1.19: 15 March 2013, commit 96b5f2294ac0054230e88913c4983d548069ea4e)\n\n\nBeta Release 0.1.18 (2 September, 2011)\n---------------------------------------\n\nNotable changes in samtools:\n\n * Support the new =/X CIGAR operators (by Peter Cock).\n\n * Allow to subsample BAM while keeping the pairing intact (view -s).\n\n * Implemented variant distance bias as a new filter (by Petr Danecek).\n\n * Bugfix: huge memory usage during indexing\n\n * Bugfix: use of uninitialized variable in mpileup (rare)\n\n * Bugfix: wrong BAQ probability (rare)\n\nNotable changes in bcftools:\n\n * Support indel in the contrast caller.\n\n * Bugfix: LRT2=nan in rare cases\n\n(0.1.18: 2 September 2011, r982:295)\n\n\n\nBeta Release 0.1.17 (6 July, 2011)\n----------------------------------\n\nWith the maturity of `mpileup` and the lack of update in the `pileup` command,\nthe `pileup` command is now formally dropped. Most of the pileup functionality,\nsuch as outputting mapping quality and read positions, have been added\n`mpileup`.\n\nSince this release, `bcftools view` is able to perform contrast SNP calling\n(option -T) for discovering de novo and/or somatic mutations between a pair of\nsamples or in a family trio. Potential mutations are scored by a log likelihood\nratio, which is very simple in math, but should be comparable to more\nsophisticated methods. Note that getting the score is only the very first step.\nA lot more need to be done to reduce systematical errors due to mapping and\nreference errors and structural variations.\n\nOther notable changes in samtools:\n\n * Improved sorting order checking during indexing.\n\n * Improved region parsing. Colons in reference sequence names are parsed\n   properly.\n\n * Fixed an issue where mpileup does not apply BAQ for the first few reads when\n   a region is specified.\n\n * Fixed an issue where `faidx` does not work with FASTA files with long lines.\n\n * Bugfix: wrong SP genotype information in the BCF output.\n\nOther notable changes in bcftools:\n\n * Output the ML estimate of the allele count.\n\n * Added the HWE plus F<0 filter to varFilter. For multiple samples, it\n   effectively filters false heterozygous calls around centromeres.\n\n * For association mapping, perform both 1-degree and 2-degree test. The\n   2-degree test is conservative but more robust to HWE violation.\n\n(0.1.17: 6 July 2011, r973:277)\n\n\n\nBeta Release 0.1.16 (21 April, 2011)\n------------------------------------\n\nNotable changes in samtools:\n\n * Support the new SAM/BAM type `B` in the latest SAM spec v1.4.\n\n * When the output file of `samtools merge` exists, do not overwrite it unless\n   a new command-line option `-f` is applied.\n\n * Bugfix: BED support is not working when the input BED is not sorted.\n\n * Bugfix: some reads without coordinates but given on the reverse strand are\n   lost in merging.\n\nNotable changes in bcftools:\n\n * Code cleanup: separated max-likelihood inference and Bayesian inference.\n\n * Test Hardy-Weinberg equilibrium with a likelihood-ratio test.\n\n * Provided another association test P-value by likelihood-ratio test.\n\n * Use Brent's method to estimate the site allele frequency when EM converges\n   slowly. The resulting ML estimate of allele frequnecy is more accurate.\n\n * Added the `ldpair` command, which computes r^2 between SNP pairs given in\n   an input file.\n\nAlso, the `pileup` command, which has been deprecated by `mpileup` since\nversion 0.1.10, will be dropped in the next release. The old `pileup` command\nis substandard and causing a lot of confusion.\n\n(0.1.16: 21 April 2011, r963:234)\n\n\n\nBeta Release 0.1.15 (10 April, 2011)\n------------------------------------\n\nNotable changes:\n\n * Allow to perform variant calling or to extract information in multiple\n   regions specified by a BED file (`samtools mpileup -l`, `samtools view -L`\n   and `bcftools view -l`).\n\n * Added the `depth` command to samtools to compute the per-base depth with a\n   simpler interface. File `bam2depth.c`, which implements this command, is the\n   recommended example on how to use the mpileup APIs.\n\n * Estimate genotype frequencies with ML; perform chi^2 based Hardy-Weinberg\n   test using this estimate.\n\n * For `samtools view`, when `-R` is specified, drop read groups in the header\n   that are not contained in the specified file.\n\n * For `samtools flagstat`, separate QC-pass and QC-fail reads.\n\n * Improved the command line help of `samtools mpileup` and `bcftools view`.\n\n * Use a global variable to control the verbose level of samtools stderr\n   output. Nonetheless, it has not been full utilized.\n\n * Fixed an issue in association test which may report false associations,\n   possibly due to floating point underflow.\n\n(0.1.15: 10 April 2011, r949:203)\n\n\n\nBeta release 0.1.14 (21 March, 2011)\n------------------------------------\n\nThis release implements a method for testing associations for case-control\ndata. The method does not call genotypes but instead sums over all genotype\nconfigurations to compute a chi^2 based test statistics. It can be potentially\napplied to comparing a pair of samples (e.g. a tumor-normal pair), but this\nhas not been evaluated on real data.\n\nAnother new feature is to make X chromosome variant calls when female and male\nsamples are both present. The user needs to provide a file indicating the\nploidy of each sample (see also manual bcftools/bcftools.1).\n\nOther notable changes:\n\n * Added `bcftools view -F` to parse BCF files generated by samtools r921 or\n   older which encodes PL in a different way.\n\n * Changed the behavior of `bcftools view -s`. Now when a list of samples is\n   provided, the samples in the output will be reordered to match the ordering\n   in the sample list. This change is mainly designed for association test.\n\n * Sped up `bcftools view -v` for target sequencing given thousands of samples.\n   Also added a new option `view -d` to skip loci where only a few samples are\n   covered by reads.\n\n * Dropped HWE test. This feature has never been implemented properly. An EM\n   should be much better. To be implemented in future.\n\n * Added the `cat` command to samtools. This command concatenate BAMs with\n   identical sequence dictionaries in an efficient way. Modified from bam_cat.c\n   written by Chris Saunders.\n\n * Added `samtools view -1` to write BAMs at a low compression level but twice\n   faster to create. The `sort` command generates temporary files at a low\n   compression level as well.\n\n * Added `samtools mpileup -6` to accept \"BAM\" with Illumina 1.3+ quality\n   strings (strictly speaking, such a file is not BAM).\n\n * Added `samtools mpileup -L` to skip INDEL calling in regions with\n   excessively high coverage. Such regions dramatically slow down mpileup.\n\n * Updated `misc/export2sam.pl`, provided by Chris Saunders from Illumina Inc.\n\n(0.1.14: 21 March 2011, r933:170)\n\n\n\nBeta release 0.1.13 (1 March, 2011)\n-----------------------------------\n\nThe most important though largely invisible modification is the change of the\norder of genotypes in the PL VCF/BCF tag. This is to conform the upcoming VCF\nspec v4.1. The change means that 0.1.13 is not backward compatible with VCF/BCF\ngenerated by samtools older than r921 inclusive.  VCF/BCF generated by the new\nsamtools will contain a line `##fileformat=VCFv4.1` as well as the samtools\nversion number.\n\nSingle Individual Haplotyping (SIH) is added as an experimental feature. It\noriginally aims to produce haploid consensus from fosmid pool sequencing, but\nalso works with short-read data. For short reads, phased blocks are usually too\nshort to be useful in many applications, but they can help to rule out part of\nSNPs close to INDELs or between copies of CNVs.\n\n\nOther notable changes in samtools:\n\n * Construct per-sample consensus to reduce the effect of nearby SNPs in INDEL\n   calling. This reduces the power but improves specificity.\n\n * Improved sorting order checking in indexing. Now indexing is the preferred way\n   to check if a BAM is sorted.\n\n * Added a switch `-E` to mpileup and calmd. This option uses an alternative way\n   to apply BAQ, which increases sensistivity, especially to MNPs, at the cost of\n   a little loss in specificity.\n\n * Added `mpileup -A` to allow to use reads in anomalous pairs in SNP calling.\n\n * Added `mpileup -m` to allow fine control of the collection of INDEL candidates.\n\n * Added `mpileup -S` to compute per-sample strand bias P-value.\n\n * Added `mpileup -G` to exclude read groups in variant calling.\n\n * Fixed segfault in indel calling related to unmapped and refskip reads.\n\n * Fixed an integer overflow in INDEL calling. This bug produces wrong INDEL\n   genotypes for longer short INDELs, typically over 10bp.\n\n * Fixed a bug in tview on big-endian machines.\n\n * Fixed a very rare memory issue in bam_md.c\n\n * Fixed an out-of-boundary bug in mpileup when the read base is `N`.\n\n * Fixed a compiling error when the knetfile library is not used. Fixed a\n   library compiling error due to the lack of bam_nt16_nt4_table[] table.\n   Suppress a compiling warning related to the latest zlib.\n\n\nOther notable changes in bcftools:\n\n * Updated the BCF spec.\n\n * Added the `FQ` VCF INFO field, which gives the phred-scaled probability\n   of all samples being the same (identical to the reference or all homozygous\n   variants). Option `view -f` has been dropped.\n\n * Implemented \"vcfutils.pl vcf2fq\" to generate a consensus sequence\n   similar to \"samtools.pl pileup2fq\".\n\n * Make sure the GT FORMAT field is always the first FORMAT to conform the VCF\n   spec. Drop bcf-fix.pl.\n\n * Output bcftools specific INFO and FORMAT in the VCF header.\n\n * Added `view -s` to call variants from a subset of samples.\n\n * Properly convert VCF to BCF with a user provided sequence dictionary. Nonetheless,\n   custom fields are still unparsed and will be stored as a missing value.\n\n * Fixed a minor bug in Fisher's exact test; the results are rarely changed.\n\n\n(0.1.13: 1 March 2011, r926:134)\n\n\n\nBeta release 0.1.12a (2 December, 2010)\n---------------------------------------\n\nThis is another bug fix release:\n\n * Fixed a memory violation in mpileup, which causes segfault. Release\n   0.1.9 and above are affected.\n\n * Fixed a memory violation in the indel caller, which does not causes\n   segfault, but may potentially affect deletion calls in an unexpected\n   way. Release 0.1.10 and above are affected.\n\n * Fixed a bug in computing r-square in bcftools. Few are using this\n   functionality and it only has minor effect.\n\n * Fixed a memory leak in bam_fetch().\n\n * Fixed a bug in writing meta information to the BAM index for the last\n   sequence. This bug is invisible to most users, but it is a bug anyway.\n\n * Fixed a bug in bcftools which causes false \"DP4=0,0,0,0\" annotations.\n\n(0.1.12: 2 December 2010, r862)\n\n\n\nBeta release 0.1.11 (21 November, 2010)\n---------------------------------------\n\nThis is mainly a bug fix release:\n\n * Fixed a bug in random retrieval (since 0.1.8). It occurs when reads\n   are retrieved from a small region containing no reads.\n\n * Fixed a bug in pileup (since 0.1.9). The bug causes an assertion\n   failure when the first CIGAR operation is a deletion.\n\n * Improved fault tolerance in remote access.\n\nOne minor feature has been implemented in bcftools:\n\n * Added a reference-free variant calling mode. In this mode, a site is\n   regarded as a variat iff the sample(s) contains two or more alleles;\n   the meaning of the QUAL field in the VCF output is changed\n   accordingly. Effectively, the reference allele is irrelevant to the\n   result in the new mode, although the reference sequence has to be\n   used in realignment when SAMtools computes genotype likelihoods.\n\nIn addition, since 0.1.10, the `pileup` command has been deprecated by\n`mpileup` which is more powerful and more accurate. The `pileup` command\nwill not be removed in the next few releases, but new features will not\nbe added.\n\n(0.1.11: 21 November 2010, r851)\n\n\n\nBeta Release 0.1.10 (16 November, 2010)\n---------------------------------------\n\nThis release is featured as the first major improvement to the indel\ncaller. The method is similar to the old one implemented in the pileup\ncommand, but the details are handled more carefully both in theory and\nin practice. As a result, the new indel caller usually gives more\naccurate indel calls, though at the cost of sensitivity. The caller is\nimplemented in the mpileup command and is invoked by default. It works\nwith multiple samples.\n\nOther notable changes:\n\n * With the -r option, the calmd command writes the difference between\n   the original base quality and the BAQ capped base quality at the BQ\n   tag but does not modify the base quality. Please use -Ar to overwrite\n   the original base quality (the 0.1.9 behavior).\n\n * Allow to set a maximum per-sample read depth to reduce memory. In\n   0.1.9, most of memory is wasted for the ultra high read depth in some\n   regions (e.g. the chr1 centromere).\n\n * Optionally write per-sample read depth and per-sample strand bias\n   P-value.\n\n * Compute equal-tail (Bayesian) credible interval of site allele\n   frequency at the CI95 VCF annotation.\n\n * Merged the vcfutils.pl varFilter and filter4vcf for better SNP/indel\n   filtering.\n\n(0.1.10: 16 November 2010, r829)\n\n\n\nBeta Release 0.1.9 (27 October, 2010)\n-------------------------------------\n\nThis release is featured as the first major improvement to the samtools'\nSNP caller.  It comes with a revised MAQ error model, the support of\nmulti-sample SNP calling and the computation of base alignment quality\n(BAQ).\n\nThe revised MAQ error model is based on the original model. It solves an\nissue of miscalling SNPs in repetitive regions. Although such SNPs can\nusually be filtered at a later step, they mess up unfiltered calls. This\nis a theoretical flaw in the original model. The revised MAQ model\ndeprecates the original MAQ model and the simplified SOAPsnp model.\n\nMulti-sample SNP calling is separated in two steps. The first is done by\nsamtools mpileup and the second by a new program, bcftools, which is\nincluded in the samtools source code tree. Multi-sample SNP calling also\nworks for single sample and has the advantage of enabling more powerful\nfiltration. It is likely to deprecate pileup in future once a proper\nindel calling method is implemented.\n\nBAQ is the Phred-scaled probability of a read base being wrongly\naligned. Capping base quality by BAQ has been shown to be very effective\nin suppressing false SNPs caused by misalignments around indels or in\nlow-complexity regions with acceptable compromise on computation\ntime. This strategy is highly recommended and can be used with other SNP\ncallers as well.\n\nIn addition to the three major improvements, other notable changes are:\n\n * Changes to the pileup format. A reference skip (the N CIGAR operator)\n   is shown as '<' or '>' depending on the strand. Tview is also changed\n   accordingly.\n\n * Accelerated pileup. The plain pileup is about 50% faster.\n\n * Regional merge. The merge command now accepts a new option to merge\n   files in a specified region.\n\n * Fixed a bug in bgzip and razip which causes source files to be\n   deleted even if option -c is applied.\n\n * In APIs, propagate errors to downstream callers and make samtools\n   return non-zero values once errors occur.\n\n(0.1.9: 27 October 2010, r783)\n\n\n\nBeta Release 0.1.8 (11 July, 2010)\n----------------------------------\n\nNotable functional changes:\n\n * Added the `reheader` command which replaces a BAM header with a new\n   header. This command is much faster than replacing header by\n   BAM->SAM->BAM conversions.\n\n * Added the `mpileup` command which computes the pileup of multiple\n   alignments.\n\n * The `index` command now stores the number of mapped and unmapped\n   reads in the index file. This information can be retrieved quickly by\n   the new `idxstats` command.\n\n * By default, pileup used the SOAPsnp model for SNP calling. This\n   avoids the floating overflow in the MAQ model which leads to spurious\n   calls in repetitive regions, although these calls will be immediately\n   filtered by varFilter.\n\n * The `tview` command now correctly handles CIGARs like 7I10M and\n   10M1P1I10M which cause assertion failure in earlier versions.\n\n * Tview accepts a region like `=10,000` where `=` stands for the\n   current sequence name. This saves typing for long sequence names.\n\n * Added the `-d` option to `pileup` which avoids slow indel calling\n   in ultradeep regions by subsampling reads locally.\n\n * Added the `-R` option to `view` which retrieves alignments in read\n   groups listed in the specified file.\n\nPerformance improvements:\n\n * The BAM->SAM conversion is up to twice faster, depending on the\n   characteristic of the input.\n\n * Parsing SAM headers with a lot of reference sequences is now much\n   faster.\n\n * The number of lseek() calls per query is reduced when the query\n   region contains no read alignments.\n\nBug fixes:\n\n * Fixed an issue in the indel caller that leads to miscall of indels.\n   Note that this solution may not work well when the sequencing indel\n   error rate is higher than the rate of SNPs.\n\n * Fixed another issue in the indel caller which may lead to incorrect\n   genotype.\n\n * Fixed a bug in `sort` when option `-o` is applied.\n\n * Fixed a bug in `view -r`.\n\nAPIs and other changes:\n\n * Added iterator interfaces to random access and pileup. The callback\n   interfaces directly call the iterator interfaces.\n\n * The BGZF blocks holding the BAM header are independent of alignment\n   BGZF blocks. Alignment records shorter than 64kB is guaranteed to be\n   fully contained in one BGZF block. This change is fully compatible\n   with the old version of samtools/picard.\n\nChanges in other utilities:\n\n * Updated export2sam.pl by Chris Saunders.\n\n * Improved the sam2vcf.pl script.\n\n * Added a Python version of varfilter.py by Aylwyn Scally.\n\n(0.1.8: 11 July 2010, r613)\n\n\n\nBeta Release 0.1.7 (10 November, 2009)\n--------------------------------------\n\nNotable changes:\n\n * Improved the indel caller in complex scenariors, in particular for\n   long reads. The indel caller is now able to make reasonable indel\n   calls from Craig Venter capillary reads.\n\n * Rewrote single-end duplicate removal with improved\n   performance. Paired-end reads are not touched.\n\n * Duplicate removal is now library aware. Samtools remove potential\n   PCR/optical duplicates inside a library rather than across libraries.\n\n * SAM header is now fully parsed, although this functionality is not\n   used in merging and so on.\n\n * In samtools merge, optionally take the input file name as RG-ID and\n   attach the RG tag to each alignment.\n\n * Added FTP support in the RAZF library. RAZF-compressed reference\n   sequence can be retrieved remotely.\n\n * Improved network support for Win32.\n\n * Samtools sort and merge are now stable.\n\nChanges in other utilities:\n\n * Implemented sam2vcf.pl that converts the pileup format to the VCF\n   format.\n\n * This release of samtools is known to work with the latest\n   Bio-Samtools Perl module.\n\n(0.1.7: 10 November 2009, r510)\n\n\n\nBeta Release 0.1.6 (2 September, 2009)\n--------------------------------------\n\nNotable changes:\n\n * In tview, do not show a blank screen when no reads mapped to the\n   corresponding region.\n\n * Implemented native HTTP support in the BGZF library. Samtools is now\n   able to directly open a BAM file on HTTP. HTTP proxy is also\n   supported via the \"http_proxy\" environmental variable.\n\n * Samtools is now compatible with the MinGW (win32) compiler and the\n   PDCurses library.\n\n * The calmd (or fillmd) command now calculates the NM tag and replaces\n   MD tags if they are wrong.\n\n * The view command now recognizes and optionally prints FLAG in HEXs or\n   strings to make a SAM file more friendly to human eyes. This is a\n   samtools-C extension, not implemented in Picard for the time\n   being. Please type `samtools view -?` for more information.\n\n * BAM files now have an end-of-file (EOF) marker to facilitate\n   truncation detection. A warning will be given if an on-disk BAM file\n   does not have this marker. The warning will be seen on BAM files\n   generated by an older version of samtools. It does NO harm.\n\n * New key bindings in tview: 'r' to show read names and 's' to show\n   reference skip (N operation) as deletions.\n\n * Fixed a bug in `samtools merge -n`.\n\n * Samtools merge now optionally copies the header of a user specified\n   SAM file to the resultant BAM output.\n\n * Samtools pileup/tview works with a CIGAR with the first or the last\n   operation is an indel.\n\n * Fixed a bug in bam_aux_get().\n\n\nChanges in other utilities:\n\n * Fixed wrong FLAG in maq2sam.\n\n\n(0.1.6: 2 September 2009, r453)\n\n\n\nBeta Release 0.1.5 (7 July, 2009)\n---------------------------------\n\nNotable changes:\n\n * Support opening a BAM alignment on FTP. Users can now use \"tview\" to\n   view alignments at the NCBI ftp site. Please read manual for more\n   information.\n\n * In library, propagate errors rather than exit or complain assertion\n   failure.\n\n * Simplified the building system and fixed compiling errors caused by\n   zlib<1.2.2.1.\n\n * Fixed an issue about lost header information when a SAM is imported\n   with \"view -t\".\n\n * Implemented \"samtool.pl varFilter\" which filters both SNPs and short\n   indels. This command replaces \"indelFilter\".\n\n * Implemented \"samtools.pl pileup2fq\" to generate FASTQ consensus from\n   pileup output.\n\n * In pileup, cap mapping quality at 60. This helps filtering when\n   different aligners are in use.\n\n * In pileup, allow to output variant sites only.\n\n * Made pileup generate correct calls in repetitive region. At the same\n   time, I am considering to implement a simplified model in SOAPsnp,\n   although this has not happened yet.\n\n * In view, added '-u' option to output BAM without compression. This\n   option is preferred when the output is piped to other commands.\n\n * In view, added '-l' and '-r' to get the alignments for one library or\n   read group. The `@RG` header lines are now partially parsed.\n\n * Do not include command line utilities to libbam.a.\n\n * Fixed memory leaks in pileup and bam_view1().\n\n * Made faidx more tolerant to empty lines right before or after FASTA >\n   lines.\n\n\nChanges in other utilities:\n\n * Updated novo2sam.pl by Colin Hercus, the key developer of novoalign.\n\n\nThis release involves several modifications to the key code base which\nmay potentially introduce new bugs even though we have tried to minimize\nthis by testing on several examples. Please let us know if you catch\nbugs.\n\n(0.1.5: 7 July 2009, r373)\n\n\n\nBeta Release 0.1.4 (21 May, 2009)\n---------------------------------\n\nNotable changes:\n\n * Added the 'rmdupse' command: removing duplicates for SE reads.\n\n * Fixed a critical bug in the indel caller: clipped alignments are not\n   processed correctly.\n\n * Fixed a bug in the tview: gapped alignment may be incorrectly\n   displayed.\n\n * Unified the interface to BAM and SAM I/O. This is done by\n   implementing a wrapper on top of the old APIs and therefore old APIs\n   are still valid. The new I/O APIs also recognize the `@SQ` header\n   lines.\n\n * Generate the MD tag.\n\n * Generate \"=\" bases. However, the indel caller will not work when \"=\"\n   bases are present.\n\n * Enhanced support of color-read display (by Nils Homer).\n\n * Implemented the GNU building system. However, currently the building\n   system does not generate libbam.a. We will improve this later. For\n   the time being, `make -f Makefile.generic` is preferred.\n\n * Fixed a minor bug in pileup: the first read in a chromosome may be\n   skipped.\n\n * Fixed bugs in bam_aux.c. These bugs do not affect other components as\n   they were not used previously.\n\n * Output the 'SM' tag from maq2sam.\n\n(0.1.4: 21 May 2009, r297)\n\n\n\nBeta Release 0.1.3 (15 April, 2009)\n-----------------------------------\n\nNotable changes in SAMtools:\n\n * SAMtools is more consistent with the specification: a) '*' in the\n   QUAL field is allowed; b) the field separator is TAB only and SPACE\n   is treated as a character in a field; c) empty header is allowed.\n\n * Implemented GLFv3 support in pileup.\n\n * Fixed a severe bug in fixmate: strand information is wrongly\n   overwritten.\n\n * Fixed a bug in alignment retrieval: alignments bridging n*16384bp are\n   not correctly retrieved sometimes.\n\n * Fixed a bug in rmdup: segfault if unmapped reads are present.\n\n * Move indel_filter.pl to samtools.pl and improved the filtering by\n   checking the actual number of alignments containing indels. The indel\n   pileup line is also changed a little to make this filtration easier.\n\n * Fixed a minor bug in indexing: the bin number of an unmapped read is\n   wrongly calculated.\n\n * Added `flagstat` command to show statistics on the FLAG field.\n\n * Improved indel caller by setting the maximum window size in local\n   realignment.\n\nChanges in other utilities:\n\n * Fixed a bug in maq2sam: a tag name is obsolete.\n\n * Improvement to wgsim: a) added support for SOLiD read simulation; b)\n   show the number of substitutions/indels/errors in read name; c)\n   considerable code clean up.\n\n * Various converters: improved functionality in general.\n\n * Updated the example SAM due to the previous bug in fixmate.\n\n(0.1.3: 15 April 2009, r227)\n\n\n\nBeta Release 0.1.2 (28 January, 2008)\n-------------------------------------\n\nNotable changes in SAMtools:\n\n * Implemented a Bayesian indel caller. The new caller generate scores\n   and genotype and is potentially more accurate than Maq's indel\n   caller. The pileup format is also changed accordingly.\n\n * Implemented rmdup command: remove potential PCR duplicates. Note that\n   this command ONLY works for FR orientation and requires ISIZE is\n   correctly set.\n\n * Added fixmate command: fill in mate coordinates, ISIZE and mate\n   related flags from a name-sorted alignment.\n\n * Fixed a bug in indexing: reads bridging 16x kbp were not retrieved.\n\n * Allow to select reads shown in the pileup output with a mask.\n\n * Generate GLFv2 from pileup.\n\n * Added two more flags for flagging PCR/optical duplicates and for QC\n   failure.\n\n * Fixed a bug in sort command: name sorting for large alignment did not\n   work.\n\n * Allow to completely disable RAZF (using Makefile.lite) as some people\n   have problem to compile it.\n\n * Fixed a bug in import command when there are reads without\n   coordinates.\n\n * Fixed a bug in tview: clipping broke the alignment viewer.\n\n * Fixed a compiling error when _NO_CURSES is applied.\n\n * Fixed a bug in merge command.\n\nChanges in other utilities:\n\n * Added wgsim, a paired-end reads simulator. Wgsim was adapted from\n   maq's reads simulator. Colin Hercus further improved it to allow\n   longer indels.\n\n * Added wgsim_eval.pl, a script that evaluates the accuracy of\n   alignment on reads generated by wgsim.\n\n * Added soap2sam.pl, a SOAP2->SAM converter. This converter does not\n   work properly when multiple hits are output.\n\n * Added bowtie2sam.pl, a Bowtie->SAM converter. Only the top hit will\n   be retained when multiple hits are present.\n\n * Fixed a bug in export2sam.pl for QC reads.\n\n * Support RG tag at MAQ->SAM converter.\n\n * Added novo2sam.pl, a NovoAlign->SAM converter. Multiple hits and\n   indel are not properly handled, though.\n\n * Added zoom2sam.pl, a ZOOM->SAM converter. It only works with the\n   default Illumina output.\n\n(0.1.2: 28 January 2008; r116)\n\n\n\nBeta Release 0.1.1 (22 December, 2008)\n--------------------------------------\n\nThe is the first public release of samtools. For more information,\nplease check the manual page `samtools.1` and the samtools website\nhttp://samtools.sourceforge.net\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 5.8505859375,
          "content": "Samtools implements various utilities for post-processing alignments in the\nSAM, BAM, and CRAM formats, including indexing, variant calling (in conjunction\nwith bcftools), and a simple alignment viewer.\n\n\nBuilding samtools\n=================\n\nThe typical simple case of building Samtools using the HTSlib bundled within\nthis Samtools release tarball is done as follows:\n\n    cd .../samtools-1.21 # Within the unpacked release directory\n    ./configure\n    make\n\nYou may wish to copy the resulting samtools executable into somewhere on your\n$PATH, or run it where it is.\n\nRather than running-in-place like that, the next simplest typical case is to\ninstall samtools etc properly into a directory of your choosing.  Building for\ninstallation using the HTSlib bundled within this Samtools release tarball,\nand building the various HTSlib utilities such as bgzip is done as follows:\n\n    cd .../samtools-1.21 # Within the unpacked release directory\n    ./configure --prefix=/path/to/location\n    make all all-htslib\n    make install install-htslib\n\nYou will likely wish to add /path/to/location/bin to your $PATH.\n\nSee INSTALL for full building and installation instructions and details.\n\nBuilding with HTSlib plug-in support\n====================================\n\nEnabling plug-ins causes some parts of HTSlib to be built as separate modules.\nThere are two advantages to this:\n\n * The static library libhts.a has fewer dependencies, which makes linking\n   third-party code against it easier.\n\n * It is possible to build extra plug-ins in addition to the ones that are\n   bundled with HTSlib.  For example, the hts-plugins repository\n   <https://github.com/samtools/htslib-plugins> includes a module that\n   allows direct access to files stored in an iRODS data management\n   repository (see <https://irods.org/>).\n\nTo build with plug-ins, you need to use the --enable-plugins configure option\nas follows:\n\n    cd .../samtools-1.21 # Within the unpacked release directory\n    ./configure --enable-plugins --prefix=/path/to/location\n    make all all-htslib\n    make install install-htslib\n\nThere are two other configure options that affect plug-ins.  These are:\n   --with-plugin-dir=DIR     plug-in installation location\n   --with-plugin-path=PATH   default plug-in search path\n\nThe default for --with-plugin-dir is <prefix>/libexec/htslib.\n--with-plugin-path sets the built-in search path used to find the plug-ins.  By\ndefault this is the directory set by the --with-plugin-dir option.  Multiple\ndirectories should be separated by colons.\n\nSetting --with-plugin-path is useful if you want to run directly from\nthe source distribution instead of installing the package.  In that case\nyou can use:\n\n    cd .../samtools-1.21 # Within the unpacked release directory\n    ./configure --enable-plugins --with-plugin-path=$PWD/htslib-1.21\n    make all all-htslib\n\nIt is possible to override the built-in search path using the HTS_PATH\nenvironment variable.  Directories should be separated by colons.  To\ninclude the built-in path, add an empty entry to HTS_PATH:\n\n   export HTS_PATH=:/my/path            # Search built-in path first\n   export HTS_PATH=/my/path:            # Search built-in path last\n   export HTS_PATH=/my/path1::/my/path2 # Search built-in path between others\n\nUsing an optimised zlib library\n===============================\n\nSamtools has been minimally tested against both the Intel-optimised and\nCloudFlare-optimised zlibs and shown to work.\n\nThey can be downloaded from:\n\n    https://github.com/jtkukunas/zlib     # Intel\n    https://github.com/cloudflare/zlib    # CloudFlare\n\nNeither Samtools nor HTSlib needs recompiling to use these optimised libraries,\nbut the LD_LIBRARY_PATH environment variable should be set to a directory\ncontaining the libz.so.1 file.\n\nBenchmarks comparing the various zlibs are available at:\n\n    http://www.htslib.org/benchmarks/zlib.html\n\nIt is recommended that you perform your own rigorous tests for an entire\npipeline if you wish to switch to one of the optimised zlib implementations.\n\nCiting\n======\n\nPlease cite this paper when using SAMtools for your publications:\n\nTwelve years of SAMtools and BCFtools\nPetr Danecek, James K Bonfield, Jennifer Liddle, John Marshall, Valeriu Ohan, Martin O Pollard, Andrew Whitwham, Thomas Keane, Shane A McCarthy, Robert M Davies, Heng Li\nGigaScience, Volume 10, Issue 2, February 2021, giab008, https://doi.org/10.1093/gigascience/giab008\n\n@article{10.1093/gigascience/giab008,\n    author = {Danecek, Petr and Bonfield, James K and Liddle, Jennifer and Marshall, John and Ohan, Valeriu and Pollard, Martin O and Whitwham, Andrew and Keane, Thomas and McCarthy, Shane A and Davies, Robert M and Li, Heng},\n    title = \"{Twelve years of SAMtools and BCFtools}\",\n    journal = {GigaScience},\n    volume = {10},\n    number = {2},\n    year = {2021},\n    month = {02},\n    abstract = \"{SAMtools and BCFtools are widely used programs for processing and analysing high-throughput sequencing data. They include tools for file format conversion and manipulation, sorting, querying, statistics, variant calling, and effect analysis amongst other methods.The first version appeared online 12 years ago and has been maintained and further developed ever since, with many new features and improvements added over the years. The SAMtools and BCFtools packages represent a unique collection of tools that have been used in numerous other software projects and countless genomic pipelines.Both SAMtools and BCFtools are freely available on GitHub under the permissive MIT licence, free for both non-commercial and commercial use. Both packages have been installed \\\\&gt;1 million times via Bioconda. The source code and documentation are available from https://www.htslib.org.}\",\n    issn = {2047-217X},\n    doi = {10.1093/gigascience/giab008},\n    url = {https://doi.org/10.1093/gigascience/giab008},\n    note = {giab008},\n    eprint = {https://academic.oup.com/gigascience/article-pdf/10/2/giab008/36332246/giab008.pdf},\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.6328125,
          "content": "samtools\n========\n\n[![Build Status](https://api.cirrus-ci.com/github/samtools/samtools.svg?branch=develop)](https://cirrus-ci.com/github/samtools/samtools)\n[![Build status](https://github.com/samtools/samtools/actions/workflows/windows-build.yml/badge.svg)](https://github.com/samtools/samtools/actions/workflows/windows-build.yml?query=branch%3Adevelop)\n[![Github All Releases](https://img.shields.io/github/downloads/samtools/samtools/total.svg)](https://github.com/samtools/samtools/releases/latest)\n\nThis is the official development repository for samtools.\n\nThe original samtools package has been split into three separate\nbut tightly coordinated projects:\n- [htslib](https://github.com/samtools/htslib): C-library for handling high-throughput sequencing data\n- samtools: mpileup and other tools for handling SAM, BAM, CRAM\n- [bcftools](https://github.com/samtools/bcftools): calling and other tools for handling VCF, BCF\n\nSee also http://github.com/samtools/\n\n### Building Samtools\n\nSee [INSTALL](INSTALL) for complete details.\n[Release tarballs][download] contain generated files that have not been\ncommitted to this repository, so building the code from a Git repository\nrequires extra steps:\n\n```sh\nautoheader            # Build config.h.in (this may generate a warning about\n                      # AC_CONFIG_SUBDIRS - please ignore it).\nautoconf -Wno-syntax  # Generate the configure script\n./configure           # Needed for choosing optional functionality\nmake\nmake install\n```\n\nBy default, this will build against an HTSlib source tree in `../htslib`.\nYou can alter this to a source tree elsewhere or to a previously-installed\nHTSlib by configuring with `--with-htslib=DIR`.\n\n[download]: http://www.htslib.org/download/\n\n### Citing\n\nPlease cite this paper when using SAMtools for your publications.\n\n> Twelve years of SAMtools and BCFtools </br>\n> Petr Danecek, James K Bonfield, Jennifer Liddle, John Marshall, Valeriu Ohan, Martin O Pollard, Andrew Whitwham, Thomas Keane, Shane A McCarthy, Robert M Davies, Heng Li </br>\n> _GigaScience_, Volume 10, Issue 2, February 2021, giab008, https://doi.org/10.1093/gigascience/giab008\n\n```\n@article{10.1093/gigascience/giab008,\n    author = {Danecek, Petr and Bonfield, James K and Liddle, Jennifer and Marshall, John and Ohan, Valeriu and Pollard, Martin O and Whitwham, Andrew and Keane, Thomas and McCarthy, Shane A and Davies, Robert M and Li, Heng},\n    title = \"{Twelve years of SAMtools and BCFtools}\",\n    journal = {GigaScience},\n    volume = {10},\n    number = {2},\n    year = {2021},\n    month = {02},\n    abstract = \"{SAMtools and BCFtools are widely used programs for processing and analysing high-throughput sequencing data. They include tools for file format conversion and manipulation, sorting, querying, statistics, variant calling, and effect analysis amongst other methods.The first version appeared online 12 years ago and has been maintained and further developed ever since, with many new features and improvements added over the years. The SAMtools and BCFtools packages represent a unique collection of tools that have been used in numerous other software projects and countless genomic pipelines.Both SAMtools and BCFtools are freely available on GitHub under the permissive MIT licence, free for both non-commercial and commercial use. Both packages have been installed \\\\&gt;1 million times via Bioconda. The source code and documentation are available from https://www.htslib.org.}\",\n    issn = {2047-217X},\n    doi = {10.1093/gigascience/giab008},\n    url = {https://doi.org/10.1093/gigascience/giab008},\n    note = {giab008},\n    eprint = {https://academic.oup.com/gigascience/article-pdf/10/2/giab008/36332246/giab008.pdf},\n}\n```\n"
        },
        {
          "name": "amplicon_stats.c",
          "type": "blob",
          "size": 62.98046875,
          "content": "/*  stats.c -- This is the former bamcheck integrated into samtools/htslib.\n\n    Copyright (C) 2020-2021, 2024 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n/*\n * This tool is designed to give \"samtools stats\" style output, but dedicated\n * to small amplicon sequencing projects.  It gathers stats on the\n * distribution of reads across amplicons.\n */\n\n/*\n * TODO:\n * - Cope with multiple references.  What do we do here?  Just request one?\n * - Permit regions rather than consuming whole file (maybe solves above).\n */\n\n#include <config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <getopt.h>\n#include <unistd.h>\n#include <math.h>\n\n#include <htslib/sam.h>\n#include <htslib/khash.h>\n\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n#include \"bam_ampliconclip.h\"\n\nKHASH_MAP_INIT_INT64(tcoord, int64_t)\nKHASH_MAP_INIT_STR(qname, int64_t)\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#ifndef ABS\n#define ABS(a) ((a)>=0?(a):-(a))\n#endif\n\n#define TCOORD_MIN_COUNT   10\n#define MAX_AMP 1000       // Default maximum number of amplicons\n#define MAX_AMP_LEN 1000   // Default maximum length of any single amplicon\n#define MAX_PRIMER_PER_AMPLICON 4  // Max primers per LEFT/RIGHT\n#define MAX_DEPTH 5        // Number of different depths permitted\n\ntypedef struct {\n    sam_global_args ga;\n    uint32_t flag_require;\n    uint32_t flag_filter;\n    int max_delta;   // Used for matching read to amplicon primer loc\n    int min_depth[MAX_DEPTH]; // Used for coverage; must be >= min_depth deep\n    int use_sample_name;\n    int max_amp;     // Total number of amplicons\n    int max_amp_len; // Maximum length of an individual amplicon\n    double depth_bin;// aggregate depth within this fraction\n    int tlen_adj;    // Adjust tlen by this amount, due to clip but no fixmate\n    FILE *out_fp;\n    char *argv;\n    int tcoord_min_count;\n    int tcoord_bin;\n    int multi_ref;\n} astats_args_t;\n\ntypedef struct {\n    int nseq;       // total sequence count\n    int nfiltered;  // sequence filtered\n    int nfailprimer;// count of sequences not matching the primer locations\n\n    // Sizes of memory allocated below, to permit reset\n    int max_amp, max_amp_len, max_len;\n\n    // Summary across all samples, sum(x) plus sum(x^2) for s.d. calc\n    int64_t *nreads, *nreads2;          // [max_amp]\n    double  *nfull_reads;               // [max_amp]; 0.5/read if paired.\n    double  *nrperc, *nrperc2;          // [max_amp]\n    int64_t *nbases, *nbases2;          // [max_amp]\n    int64_t *coverage;                  // [max_amp][max_amp_len]\n    double  (*covered_perc)[MAX_DEPTH]; // [max_amp][MAX_DEPTH]\n    double  (*covered_perc2)[MAX_DEPTH];// [max_amp][MAX_DEPTH];\n    khash_t(tcoord) **tcoord;           // [max_amp+1]\n\n    // 0 is correct pair, 1 is incorrect pair, 2 is unidentified\n    int     (*amp_dist)[3];             // [MAX_AMP][3];\n\n    int *depth_valid; // [max_len]\n    int *depth_all;   // [max_len]\n    khash_t(qname) *qend;  // queryname end, for overlap removal\n} astats_t;\n\n// We can have multiple primers for LEFT / RIGHT, so this\n// permits detection by any compatible combination.\n// One reference:\ntypedef struct {\n    int64_t left[MAX_PRIMER_PER_AMPLICON];\n    int nleft;\n    int64_t right[MAX_PRIMER_PER_AMPLICON];\n    int nright;\n    int64_t max_left, min_right; // inner dimensions\n    int64_t min_left, max_right; // outer dimensions\n} amplicon_t;\n\n// Multiple references, we have an array of amplicons_t - one per used ref.\n// We have per reference local and global stats here, as some of the stats\n// are coordinate based.  However we report them combined together as a single\n// list across all references.\n// \"namp\" is the number of amplicons in this reference, but they're\n// numbered first_amp to first_amp+namp-1 inclusively.\ntypedef struct {\n    int tid, namp;\n    int64_t len;\n    bed_entry_list_t *sites;\n    amplicon_t *amp;\n    astats_t *lstats, *gstats; // local (1 file) and global (all file) stats\n    const char *ref;           // ref name (pointer to the bed hash table key)\n    int first_amp;             // first amplicon number for this ref\n} amplicons_t;\n\n// Reinitialised for each new reference/chromosome.\n// Counts from 1 to namp, -1 for no match and 0 for ?.\nstatic int *pos2start = NULL;\nstatic int *pos2end = NULL;\nstatic int pos2size = 0; // allocated size of pos2start/end\n\n// Lookup table to go from position to amplicon based on\n// read start / end.\nstatic int initialise_amp_pos_lookup(astats_args_t *args,\n                                     amplicons_t *amps,\n                                     int ref) {\n    int64_t i, j;\n    amplicon_t *amp = amps[ref].amp;\n    int64_t max_len = amps[ref].len;\n    int namp = amps[ref].namp;\n\n    if (max_len+1 > pos2size) {\n        if (!(pos2start = realloc(pos2start, (max_len+1)*sizeof(*pos2start))))\n            return -1;\n        if (!(pos2end   = realloc(pos2end,   (max_len+1)*sizeof(*pos2end))))\n            return -1;\n        pos2size = max_len;\n    }\n    for (i = 0; i < max_len; i++)\n        pos2start[i] = pos2end[i] = -1;\n\n    for (i = 0; i < namp; i++) {\n        for (j = 0; j < amp[i].nleft; j++) {\n            int64_t p;\n            for (p = amp[i].left[j] - args->max_delta;\n                 p <= amp[i].left[j] + args->max_delta; p++) {\n                if (p < 1 || p > max_len)\n                    continue;\n                pos2start[p-1] = i;\n            }\n        }\n        for (j = 0; j < amp[i].nright; j++) {\n            int64_t p;\n            for (p = amp[i].right[j] - args->max_delta;\n                 p <= amp[i].right[j] + args->max_delta; p++) {\n                if (p < 1 || p > max_len)\n                    continue;\n                pos2end[p-1] = i;\n            }\n        }\n    }\n\n    return 0;\n}\n\n// Counts amplicons.\n// Assumption: input BED file alternates between LEFT and RIGHT primers\n// per amplicon, thus we can count the number based on the switching\n// orientation.\nstatic int count_amplicon(bed_entry_list_t *sites) {\n    int i, namp, last_rev = 0;\n    for (i = namp = 0; i < sites->length; i++) {\n        if (sites->bp[i].rev == 0 && last_rev)\n            namp++;\n        last_rev = sites->bp[i].rev;\n    }\n\n    return ++namp;\n}\n\n// We're only interest in the internal part of the amplicon.\n// Our bed file has LEFT start/end followed by RIGHT start/end,\n// so collapse these to LEFT end / RIGHT start.\n//\n// Returns right most amplicon position on success,\n//         < 0 on error\nstatic int64_t bed2amplicon(astats_args_t *args, bed_entry_list_t *sites,\n                            amplicon_t *amp, int *namp, int do_title,\n                            const char *ref, int first_amp) {\n    int i, j;\n    int64_t max_right = 0;\n    FILE *ofp = args->out_fp;\n\n    *namp = 0;\n\n    // Assume all primers for the same amplicon are adjacent in BED\n    // with all + followed by all -.  Thus - to + signifies next primer set.\n    int last_rev = 0;\n    amp[0].max_left = 0;\n    amp[0].min_right = INT64_MAX;\n    amp[0].min_left = INT64_MAX;\n    amp[0].max_right = 0;\n    if (do_title) {\n        fprintf(ofp, \"# Amplicon locations from BED file.\\n\");\n        fprintf(ofp, \"# LEFT/RIGHT are <start>-<end> format and \"\n                \"comma-separated for alt-primers.\\n\");\n        if (args->multi_ref)\n            fprintf(ofp, \"#\\n# AMPLICON\\tREF\\tNUMBER\\tLEFT\\tRIGHT\\n\");\n        else\n            fprintf(ofp, \"#\\n# AMPLICON\\tNUMBER\\tLEFT\\tRIGHT\\n\");\n    }\n    for (i = j = 0; i < sites->length; i++) {\n        if (i == 0 && sites->bp[i].rev != 0) {\n            fprintf(stderr, \"[ampliconstats] error: BED file should start\"\n                    \" with the + strand primer\\n\");\n            return -1;\n        }\n        if (sites->bp[i].rev == 0 && last_rev) {\n            j++;\n            if (j >= args->max_amp) {\n                fprintf(stderr, \"[ampliconstats] error: too many amplicons\"\n                        \" (%d). Use -a option to raise this.\\n\", j);\n                return -1;\n            }\n            amp[j].max_left = 0;\n            amp[j].min_right = INT64_MAX;\n            amp[j].min_left = INT64_MAX;\n            amp[j].max_right = 0;\n        }\n        if (sites->bp[i].rev == 0) {\n            if (i == 0 || last_rev) {\n                if (j>0) fprintf(ofp, \"\\n\");\n                if (args->multi_ref)\n                    fprintf(ofp, \"AMPLICON\\t%s\\t%d\", ref, j+1 + first_amp);\n                else\n                    fprintf(ofp, \"AMPLICON\\t%d\", j+1);\n            }\n            if (amp[j].nleft >= MAX_PRIMER_PER_AMPLICON) {\n                print_error_errno(\"ampliconstats\",\n                                  \"too many primers per amplicon (%d).\\n\",\n                                  MAX_PRIMER_PER_AMPLICON);\n                return -1;\n            }\n            amp[j].left[amp[j].nleft++] = sites->bp[i].right;\n            if (amp[j].max_left < sites->bp[i].right+1)\n                amp[j].max_left = sites->bp[i].right+1;\n            if (amp[j].min_left > sites->bp[i].right+1)\n                amp[j].min_left = sites->bp[i].right+1;\n            // BED file, so left+1 as zero based. right(+1-1) as\n            // BED goes one beyond end (and we want inclusive range).\n            fprintf(ofp, \"%c%\"PRId64\"-%\"PRId64, \"\\t,\"[amp[j].nleft > 1],\n                    sites->bp[i].left+1, sites->bp[i].right);\n        } else {\n            if (amp[j].nright >= MAX_PRIMER_PER_AMPLICON) {\n                print_error_errno(\"ampliconstats\",\n                                  \"too many primers per amplicon (%d)\",\n                                  MAX_PRIMER_PER_AMPLICON);\n                return -1;\n            }\n            amp[j].right[amp[j].nright++] = sites->bp[i].left;\n            if (amp[j].min_right > sites->bp[i].left-1)\n                amp[j].min_right = sites->bp[i].left-1;\n            if (amp[j].max_right < sites->bp[i].left-1) {\n                amp[j].max_right = sites->bp[i].left-1;\n                if (amp[j].max_right - amp[j].min_left + 1 >=\n                    args->max_amp_len) {\n                    fprintf(stderr, \"[ampliconstats] error: amplicon \"\n                            \"longer (%d) than max_amp_len option (%d)\\n\",\n                            (int)(amp[j].max_right - amp[j].min_left + 2),\n                            args->max_amp_len);\n                    return -1;\n                }\n                if (max_right < amp[j].max_right)\n                    max_right = amp[j].max_right;\n            }\n            fprintf(ofp, \"%c%\"PRId64\"-%\"PRId64, \"\\t,\"[amp[j].nright > 1],\n                    sites->bp[i].left+1, sites->bp[i].right);\n        }\n        last_rev = sites->bp[i].rev;\n    }\n    if (last_rev != 1) {\n        fprintf(ofp, \"\\n\"); // useful if going to stdout\n        fprintf(stderr, \"[ampliconstats] error: bed file does not end on\"\n                \" a reverse strand primer.\\n\");\n        return -1;\n    }\n    *namp = ++j;\n    if (j) fprintf(ofp, \"\\n\");\n\n    if (j >= args->max_amp) {\n        fprintf(stderr, \"[ampliconstats] error: \"\n                \"too many amplicons (%d). Use -a option to raise this.\", j);\n        return -1;\n    }\n\n//    for (i = 0; i < *namp; i++) {\n//      printf(\"%d\\t%ld\", i, amp[i].length);\n//      for (j = 0; j < amp[i].nleft; j++)\n//          printf(\"%c%ld\", \"\\t,\"[j>0], amp[i].left[j]);\n//      for (j = 0; j < amp[i].nright; j++)\n//          printf(\"%c%ld\", \"\\t,\"[j>0], amp[i].right[j]);\n//      printf(\"\\n\");\n//    }\n\n    return max_right;\n}\n\nvoid stats_free(astats_t *st) {\n    if (!st)\n        return;\n\n    free(st->nreads);\n    free(st->nreads2);\n    free(st->nfull_reads);\n    free(st->nrperc);\n    free(st->nrperc2);\n    free(st->nbases);\n    free(st->nbases2);\n    free(st->coverage);\n    free(st->covered_perc);\n    free(st->covered_perc2);\n    free(st->amp_dist);\n\n    free(st->depth_valid);\n    free(st->depth_all);\n\n    if (st->tcoord) {\n        int i;\n        for (i = 0; i <= st->max_amp; i++) {\n            if (st->tcoord[i])\n                kh_destroy(tcoord, st->tcoord[i]);\n        }\n        free(st->tcoord);\n    }\n\n    khiter_t k;\n    for (k = kh_begin(st->qend); k != kh_end(st->qend); k++)\n        if (kh_exist(st->qend, k))\n            free((void *)kh_key(st->qend, k));\n    kh_destroy(qname, st->qend);\n\n    free(st);\n}\n\nastats_t *stats_alloc(int64_t max_len, int max_amp, int max_amp_len) {\n    astats_t *st = calloc(1, sizeof(*st));\n    if (!st)\n        return NULL;\n\n    st->max_amp = max_amp;\n    st->max_amp_len = max_amp_len;\n    st->max_len = max_len;\n\n    if (!(st->nreads  = calloc(max_amp, sizeof(*st->nreads))))  goto err;\n    if (!(st->nreads2 = calloc(max_amp, sizeof(*st->nreads2)))) goto err;\n    if (!(st->nrperc  = calloc(max_amp, sizeof(*st->nrperc))))  goto err;\n    if (!(st->nrperc2 = calloc(max_amp, sizeof(*st->nrperc2)))) goto err;\n    if (!(st->nbases  = calloc(max_amp, sizeof(*st->nbases))))  goto err;\n    if (!(st->nbases2 = calloc(max_amp, sizeof(*st->nbases2)))) goto err;\n\n    if (!(st->nfull_reads = calloc(max_amp, sizeof(*st->nfull_reads))))\n        goto err;\n\n    if (!(st->coverage = calloc(max_amp*max_amp_len, sizeof(*st->coverage))))\n        goto err;\n\n    if (!(st->covered_perc  = calloc(max_amp, sizeof(*st->covered_perc))))\n        goto err;\n    if (!(st->covered_perc2 = calloc(max_amp, sizeof(*st->covered_perc2))))\n        goto err;\n\n    if (!(st->tcoord = calloc(max_amp+1, sizeof(*st->tcoord)))) goto err;\n    int i;\n    for (i = 0; i <= st->max_amp; i++)\n        if (!(st->tcoord[i] = kh_init(tcoord)))\n            goto err;\n\n    if (!(st->qend = kh_init(qname)))\n        goto err;\n\n    if (!(st->depth_valid = calloc(max_len, sizeof(*st->depth_valid))))\n        goto err;\n    if (!(st->depth_all   = calloc(max_len, sizeof(*st->depth_all))))\n        goto err;\n\n    if (!(st->amp_dist  = calloc(max_amp, sizeof(*st->amp_dist))))  goto err;\n\n    return st;\n\n err:\n    stats_free(st);\n    return NULL;\n}\n\nstatic void stats_reset(astats_t *st) {\n    st->nseq = 0;\n    st->nfiltered = 0;\n    st->nfailprimer = 0;\n\n    memset(st->nreads,  0, st->max_amp * sizeof(*st->nreads));\n    memset(st->nreads2, 0, st->max_amp * sizeof(*st->nreads2));\n    memset(st->nfull_reads, 0, st->max_amp * sizeof(*st->nfull_reads));\n\n    memset(st->nrperc,  0, st->max_amp * sizeof(*st->nrperc));\n    memset(st->nrperc2, 0, st->max_amp * sizeof(*st->nrperc2));\n\n    memset(st->nbases,  0, st->max_amp * sizeof(*st->nbases));\n    memset(st->nbases2, 0, st->max_amp * sizeof(*st->nbases2));\n\n    memset(st->coverage, 0, st->max_amp * st->max_amp_len\n           * sizeof(*st->coverage));\n    memset(st->covered_perc,  0, st->max_amp * sizeof(*st->covered_perc));\n    memset(st->covered_perc2, 0, st->max_amp * sizeof(*st->covered_perc2));\n\n    // Keep the allocated entries as it's likely all files will share\n    // the same keys.  Instead we reset counters to zero for common ones\n    // and delete rare ones.\n    int i;\n    for (i = 0; i <= st->max_amp; i++) {\n        khiter_t k;\n        for (k = kh_begin(st->tcoord[i]);\n             k != kh_end(st->tcoord[i]); k++)\n            if (kh_exist(st->tcoord[i], k)) {\n                if (kh_value(st->tcoord[i], k) < 5)\n                    kh_del(tcoord, st->tcoord[i], k);\n                else\n                    kh_value(st->tcoord[i], k) = 0;\n            }\n    }\n\n    khiter_t k;\n    for (k = kh_begin(st->qend); k != kh_end(st->qend); k++)\n        if (kh_exist(st->qend, k))\n            free((void *)kh_key(st->qend, k));\n    kh_clear(qname, st->qend);\n\n    memset(st->depth_valid, 0, st->max_len * sizeof(*st->depth_valid));\n    memset(st->depth_all,   0, st->max_len * sizeof(*st->depth_all));\n    memset(st->amp_dist,  0, st->max_amp * sizeof(*st->amp_dist));\n}\n\nstatic void amp_stats_reset(amplicons_t *amps, int nref) {\n    int i;\n    for (i = 0; i < nref; i++) {\n        if (!amps[i].sites)\n            continue;\n        stats_reset(amps[i].lstats);\n    }\n}\n\nstatic int accumulate_stats(astats_args_t *args, amplicons_t *amps,\n                            bam1_t *b) {\n    int ref = b->core.tid;\n    amplicon_t *amp = amps[ref].amp;\n    astats_t *stats = amps[ref].lstats;\n    int len = amps[ref].len;\n\n    if (!stats)\n        return 0;\n\n    stats->nseq++;\n    if ((b->core.flag & args->flag_require) != args->flag_require ||\n        (b->core.flag & args->flag_filter)  != 0) {\n        stats->nfiltered++;\n        return 0;\n    }\n\n    int64_t start = b->core.pos, mstart = start; // modified start\n    int64_t end = bam_endpos(b), i;\n\n    // Compute all-template-depth and valid-template-depth.\n    // We track current end location per read name so we can remove overlaps.\n    // Potentially we could use this data for a better amplicon-depth\n    // count too, but for now it's purely for the per-base plots.\n    int ret;\n    khiter_t k;\n    int prev_start = 0, prev_end = 0;\n    if ((b->core.flag & BAM_FPAIRED)\n        && !(b->core.flag & (BAM_FSUPPLEMENTARY | BAM_FSECONDARY))) {\n        k = kh_put(qname, stats->qend, bam_get_qname(b), &ret);\n        if (ret == 0) {\n            prev_start = kh_value(stats->qend, k) & 0xffffffff;\n            prev_end = kh_value(stats->qend, k)>>32;\n            mstart = MAX(mstart, prev_end);\n            // Ideally we'd reuse strings so we don't thrash free/malloc.\n            // However let's see if the official way of doing that (malloc\n            // itself) is fast enough first.\n            free((void *)kh_key(stats->qend, k));\n            kh_del(qname, stats->qend, k);\n            //fprintf(stderr, \"remove overlap %d to %d\\n\", (int)start, (int)mstart);\n        } else {\n            if (!(kh_key(stats->qend, k) = strdup(bam_get_qname(b))))\n                return -1;\n\n            kh_value(stats->qend, k) = start | (end << 32);\n        }\n    }\n    for (i = mstart; i < end && i < len; i++)\n        stats->depth_all[i]++;\n    if (i < end) {\n        print_error(\"ampliconstats\", \"record %s overhangs end of reference\",\n                    bam_get_qname(b));\n        // But keep going, as it's harmless.\n    }\n\n    // On single ended runs, eg ONT or PacBio, we just use the start/end\n    // of the template to assign.\n    int anum = (b->core.flag & BAM_FREVERSE) || !(b->core.flag & BAM_FPAIRED)\n        ? (end-1 >= 0 && end-1 < len ? pos2end[end-1] : -1)\n        : (start >= 0 && start < len ? pos2start[start] : -1);\n\n    // ivar sometimes soft-clips 100% of the bases.\n    // This is essentially unmapped\n    if (end == start && (args->flag_filter & BAM_FUNMAP)) {\n        stats->nfiltered++;\n        return 0;\n    }\n\n    if (anum == -1)\n        stats->nfailprimer++;\n\n    if (anum >= 0) {\n        int64_t c = MIN(end,amp[anum].min_right+1) - MAX(start,amp[anum].max_left);\n        if (c > 0) {\n            stats->nreads[anum]++;\n            // NB: ref bases rather than read bases\n            stats->nbases[anum] += c;\n\n            int64_t i;\n            if (start < 0) start = 0;\n            if (end > len) end = len;\n\n            int64_t ostart = MAX(start, amp[anum].min_left-1);\n            int64_t oend = MIN(end, amp[anum].max_right);\n            int64_t offset = amp[anum].min_left-1;\n            for (i = ostart; i < oend; i++)\n                stats->coverage[anum*stats->max_amp_len + i-offset]++;\n        } else {\n            stats->nfailprimer++;\n        }\n    }\n\n    // Template length in terms of amplicon number to amplicon number.\n    // We expect left to right of same amplicon (len 0), but it may go\n    // to next amplicon (len 1) or prev (len -1), etc.\n    int64_t t_end;\n    int oth_anum = -1;\n\n    if (b->core.flag & BAM_FPAIRED) {\n        t_end = (b->core.flag & BAM_FREVERSE ? end : start)\n            + b->core.isize;\n\n        // If we've clipped the primers but not followed up with a fixmates\n        // then our start+TLEN will take us to a location which is\n        // length(LEFT_PRIMER) + length(RIGHT_PRIMER) too far away.\n        //\n        // The correct solution is to run samtools fixmate so TLEN is correct.\n        // The hacky solution is to fudge the expected tlen by double the\n        // average primer length (e.g. 50).\n        t_end += b->core.isize > 0 ? -args->tlen_adj : +args->tlen_adj;\n\n        if (t_end > 0 && t_end < len && b->core.isize != 0)\n            oth_anum = (b->core.flag & BAM_FREVERSE)\n                ? pos2start[t_end]\n                : pos2end[t_end];\n    } else {\n        // Not paired (see int anum = (REV || !PAIR) ?en :st expr above)\n        oth_anum = pos2start[start];\n        t_end = end;\n    }\n\n    // We don't want to count our pairs twice.\n    // If both left/right are known, count it on left only.\n    // If only one is known, we'll only get to this code once\n    // so we can also count it.\n    int astatus = 2;\n    if (anum != -1 && oth_anum != -1) {\n        astatus = oth_anum == anum ? 0 : 1;\n        if (start <= t_end)\n            stats->amp_dist[anum][astatus]++;\n    } else if (anum >= 0) {\n        stats->amp_dist[anum][astatus = 2]++;\n    }\n\n    if (astatus == 0 && !(b->core.flag & (BAM_FUNMAP | BAM_FMUNMAP))) {\n        if (prev_end && mstart > prev_end) {\n            // 2nd read with gap to 1st; undo previous increment.\n            for (i = prev_start; i < prev_end; i++)\n                stats->depth_valid[i]--;\n            stats->nfull_reads[anum] -= (b->core.flag & BAM_FPAIRED) ? 0.5 : 1;\n        } else {\n            // 1st read, or 2nd read that overlaps 1st\n            for (i = mstart; i < end; i++)\n                stats->depth_valid[i]++;\n            stats->nfull_reads[anum] += (b->core.flag & BAM_FPAIRED) ? 0.5 : 1;\n        }\n    }\n\n    // Track template start,end frequencies, so we can give stats on\n    // amplicon primer usage.\n    if ((b->core.flag & BAM_FPAIRED) && b->core.isize <= 0)\n        // left to right only, so we don't double count template positions.\n        return 0;\n\n    start = b->core.pos;\n    t_end = b->core.flag & BAM_FPAIRED\n        ? start + b->core.isize-1\n        : end;\n    uint64_t tcoord = MIN(start+1, UINT32_MAX) | (MIN(t_end+1, UINT32_MAX)<<32);\n    k = kh_put(tcoord, stats->tcoord[anum+1], tcoord, &ret);\n    if (ret < 0)\n        return -1;\n    if (ret == 0)\n        kh_value(stats->tcoord[anum+1], k)++;\n    else\n        kh_value(stats->tcoord[anum+1], k)=1;\n    kh_value(stats->tcoord[anum+1], k) |= ((int64_t)astatus<<32);\n\n    return 0;\n}\n\n// Append file local stats to global stats\nint append_lstats(astats_t *lstats, astats_t *gstats, int namp, int all_nseq) {\n    gstats->nseq += lstats->nseq;\n    gstats->nfiltered += lstats->nfiltered;\n    gstats->nfailprimer += lstats->nfailprimer;\n\n    int a;\n    for (a = -1; a < namp; a++) {\n        // Add khash local (kl) to khash global (kg)\n        khiter_t kl, kg;\n        for (kl = kh_begin(lstats->tcoord[a+1]);\n             kl != kh_end(lstats->tcoord[a+1]); kl++) {\n            if (!kh_exist(lstats->tcoord[a+1], kl) ||\n                kh_value(lstats->tcoord[a+1], kl) == 0)\n                continue;\n\n            int ret;\n            kg = kh_put(tcoord, gstats->tcoord[a+1],\n                        kh_key(lstats->tcoord[a+1], kl),\n                        &ret);\n            if (ret < 0)\n                return -1;\n\n            kh_value(gstats->tcoord[a+1], kg) =\n                (ret == 0\n                 ? (kh_value(gstats->tcoord[a+1], kg) & 0xFFFFFFFF)\n                 : 0)\n                + kh_value(lstats->tcoord[a+1], kl);\n        }\n        if (a == -1) continue;\n\n        gstats->nreads[a]  += lstats->nreads[a];\n        gstats->nreads2[a] += lstats->nreads[a] * lstats->nreads[a];\n        gstats->nfull_reads[a] += lstats->nfull_reads[a];\n\n        // To get mean & sd for amplicon read percentage, we need\n        // to do the divisions here as nseq differs for each sample.\n        double nrperc = all_nseq ? 100.0 * lstats->nreads[a] / all_nseq : 0;\n        gstats->nrperc[a]  += nrperc;\n        gstats->nrperc2[a] += nrperc*nrperc;\n\n        gstats->nbases[a]  += lstats->nbases[a];\n        gstats->nbases2[a] += lstats->nbases[a] * lstats->nbases[a];\n\n        int d;\n        for (d = 0; d < MAX_DEPTH; d++) {\n            gstats->covered_perc[a][d]  += lstats->covered_perc[a][d];\n            gstats->covered_perc2[a][d] += lstats->covered_perc[a][d]\n                                         * lstats->covered_perc[a][d];\n        }\n\n        for (d = 0; d < 3; d++)\n            gstats->amp_dist[a][d] += lstats->amp_dist[a][d];\n    }\n\n    for (a = 0; a < lstats->max_len; a++) {\n        gstats->depth_valid[a] += lstats->depth_valid[a];\n        gstats->depth_all[a]   += lstats->depth_all[a];\n    }\n\n    return 0;\n}\n\nint append_stats(amplicons_t *amps, int nref) {\n    int i, r, all_nseq = 0;\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = amps[r].lstats;\n        all_nseq  += stats->nseq - stats->nfiltered - stats->nfailprimer;\n    }\n\n    for (i = 0; i < nref; i++) {\n        if (!amps[i].sites)\n            continue;\n        if (append_lstats(amps[i].lstats, amps[i].gstats, amps[i].namp,\n                          all_nseq) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\ntypedef struct {\n    int32_t start, end;\n    uint32_t freq;\n    uint32_t status;\n} tcoord_t;\n\n// Sort tcoord by descending frequency and then ascending start and  end.\nstatic int tcoord_freq_sort(const void *vp1, const void *vp2) {\n    const tcoord_t *t1 = (const tcoord_t *)vp1;\n    const tcoord_t *t2 = (const tcoord_t *)vp2;\n\n    if (t1->freq != t2->freq)\n        return t2->freq - t1->freq;\n\n    if (t1->start != t2->start)\n        return t1->start - t2->start;\n\n    return t1->end - t2->end;\n}\n\n\n/*\n * Merges tcoord start,end,freq,status tuples if their coordinates are\n * close together.  We aim to keep the start,end for the most frequent\n * value and assume that is the correct coordinate and all others are\n * minor fluctuations due to errors or variants.\n *\n * We sort by frequency first and then merge later items in the list into\n * the earlier more frequent ones.  It's O(N^2), but sufficient for now\n * given current scale of projects.\n *\n * If we ever need to resolve that then consider sorting by start\n * coordinate and scanning the list to find all items within X, find\n * the most frequent of those, and then cluster that way.  (I'd have\n * done that had I thought of it at the time!)\n */\nstatic void aggregate_tcoord(astats_args_t *args, tcoord_t *tpos, size_t *np){\n    size_t n = *np, j, j2, j3, k;\n\n    // Sort by frequency and cluster infrequent coords into frequent\n    // ones provided they're close by.\n    // This is O(N^2), but we've already binned by tcoord_bin/2 so\n    // the list isn't intended to be vast at this point.\n    qsort(tpos, n, sizeof(*tpos), tcoord_freq_sort);\n\n    // For frequency ties, find mid start coord, and then find mid end\n    // coord of those matching start.\n    // We make that the first item so we merge into that mid point.\n    for (j = 0; j < n; j++) {\n        for (j2 = j+1; j2 < n; j2++) {\n            if (tpos[j].freq != tpos[j2].freq)\n                break;\n            if (tpos[j2].start - tpos[j].start >= args->tcoord_bin)\n                break;\n        }\n\n        // j to j2 all within bin of a common start,\n        // m is the mid start.\n        if (j2-1 > j) {\n            size_t m = (j2-1 + j)/2;\n\n            // Find mid end for this same start\n            while (m > 1 && tpos[m].start == tpos[m-1].start)\n                m--;\n            for (j3 = m+1; j3 < j2; j3++) {\n                if (tpos[m].start != tpos[j3].start)\n                    break;\n                if (tpos[m].end - tpos[j3].end >= args->tcoord_bin)\n                    break;\n            }\n            if (j3-1 > m)\n                m = (j3-1 + m)/2;\n\n            // Swap with first item.\n            tcoord_t tmp = tpos[j];\n            tpos[j] = tpos[m];\n            tpos[m] = tmp;\n            j = j2-1;\n        }\n    }\n\n    // Now merge in coordinates.\n    // This bit is O(N^2), so consider binning first to reduce the\n    // size of the list if we have excessive positional variation.\n    for (k = j = 0; j < n; j++) {\n        if (!tpos[j].freq)\n            continue;\n\n        if (k < j)\n            tpos[k] = tpos[j];\n\n        for (j2 = j+1; j2 < n; j2++) {\n            if (ABS(tpos[j].start-tpos[j2].start) < args->tcoord_bin/2 &&\n                ABS(tpos[j].end  -tpos[j2].end)  < args->tcoord_bin/2 &&\n                tpos[j].status == tpos[j2].status) {\n                tpos[k].freq += tpos[j2].freq;\n                tpos[j2].freq = 0;\n            }\n        }\n        k++;\n    }\n\n    *np = k;\n}\n\nint dump_stats(astats_args_t *args, char type, char *name, int nfile,\n               amplicons_t *amps, int nref, int local) {\n    int i, r;\n    FILE *ofp = args->out_fp;\n    tcoord_t *tpos = NULL;\n    size_t ntcoord = 0;\n\n    // summary stats for this sample (or for all samples)\n    fprintf(ofp, \"# Summary stats.\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cSS | cut -f 2-' to extract this part.\\n\", type);\n\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        int nmatch = stats->nseq - stats->nfiltered - stats->nfailprimer;\n        char *name_ref = malloc(strlen(name) + strlen(amps[r].ref) + 2);\n        if (!name_ref)\n            return -1;\n        if (args->multi_ref)\n            sprintf(name_ref, \"%s\\t%s\", name, amps[r].ref);\n        else\n            sprintf(name_ref, \"%s\", name);\n        fprintf(ofp, \"%cSS\\t%s\\traw total sequences:\\t%d\\n\",\n                type, name_ref, stats->nseq);\n        fprintf(ofp, \"%cSS\\t%s\\tfiltered sequences:\\t%d\\n\",\n                type, name_ref, stats->nfiltered);\n        fprintf(ofp, \"%cSS\\t%s\\tfailed primer match:\\t%d\\n\",\n                type, name_ref, stats->nfailprimer);\n        fprintf(ofp, \"%cSS\\t%s\\tmatching sequences:\\t%d\\n\",\n                type, name_ref, nmatch);\n\n        int d = 0;\n        do {\n            // From first to last amplicon only, so not entire consensus.\n            // If contig length is known, maybe we want to add the missing\n            // count to < DEPTH figures?\n            int64_t start = 0, covered = 0, total = 0;\n            amplicon_t *amp = amps[r].amp;\n            for (i = 0; i < amps[r].namp; i++) {\n                int64_t j, offset = amp[i].min_left-1;\n                if (amp[i].min_right - amp[i].min_left > stats->max_amp_len) {\n                    fprintf(stderr, \"[ampliconstats] error: \"\n                            \"Maximum amplicon length (%d) exceeded for '%s'\\n\",\n                            stats->max_amp, name);\n                    return -1;\n                }\n                for (j = MAX(start, amp[i].max_left-1);\n                     j < MAX(start, amp[i].min_right); j++) {\n                    if (stats->coverage[i*stats->max_amp_len + j-offset]\n                        >= args->min_depth[d])\n                        covered++;\n                    total++;\n                }\n                start = MAX(start, amp[i].min_right);\n            }\n            fprintf(ofp, \"%cSS\\t%s\\tconsensus depth count < %d and >= %d:\\t%\"\n                    PRId64\"\\t%\"PRId64\"\\n\", type, name_ref,\n                    args->min_depth[d], args->min_depth[d],\n                    total-covered, covered);\n        } while (++d < MAX_DEPTH && args->min_depth[d]);\n\n        free(name_ref);\n    }\n\n    // Read count\n    fprintf(ofp, \"# Absolute matching read counts per amplicon.\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cREADS | cut -f 2-' to extract this part.\\n\", type);\n    fprintf(ofp, \"%cREADS\\t%s\", type, name);\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        for (i = 0; i < amps[r].namp; i++) {\n            fprintf(ofp, \"\\t%\"PRId64, stats->nreads[i]);\n        }\n    }\n    fprintf(ofp, \"\\n\");\n\n    // Valid depth is the number of full length reads (already divided\n    // by the number we expect to cover), so +0.5 per read in pair.\n    // A.k.a \"usable depth\" in the plots.\n    fprintf(ofp, \"%cVDEPTH\\t%s\", type, name);\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        for (i = 0; i < amps[r].namp; i++)\n            fprintf(ofp, \"\\t%d\", (int)stats->nfull_reads[i]);\n    }\n    fprintf(ofp, \"\\n\");\n\n    if (type == 'C') {\n        // For combined we can compute mean & standard deviation too\n        fprintf(ofp, \"CREADS\\tMEAN\");\n        for (r = 0; r < nref; r++) {\n            if (!amps[r].sites)\n                continue;\n            astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n            for (i = 0; i < amps[r].namp; i++) {\n                fprintf(ofp, \"\\t%.1f\", stats->nreads[i] / (double)nfile);\n            }\n        }\n        fprintf(ofp, \"\\n\");\n\n        fprintf(ofp, \"CREADS\\tSTDDEV\");\n        for (r = 0; r < nref; r++) {\n            if (!amps[r].sites)\n                continue;\n            astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n            for (i = 0; i < amps[r].namp; i++) {\n                double n1 = stats->nreads[i];\n                fprintf(ofp, \"\\t%.1f\", nfile > 1 && stats->nreads2[i] > 0\n                        ? sqrt(stats->nreads2[i]/(double)nfile\n                               - (n1/nfile)*(n1/nfile))\n                        : 0);\n            }\n        }\n        fprintf(ofp, \"\\n\");\n    }\n\n    fprintf(ofp, \"# Read percentage of distribution between amplicons.\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cRPERC | cut -f 2-' to extract this part.\\n\", type);\n    fprintf(ofp, \"%cRPERC\\t%s\", type, name);\n    int all_nseq = 0;\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        all_nseq  += stats->nseq - stats->nfiltered - stats->nfailprimer;\n    }\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        for (i = 0; i < amps[r].namp; i++) {\n            if (type == 'C') {\n                fprintf(ofp, \"\\t%.3f\", (double)stats->nrperc[i] / nfile);\n            } else {\n                fprintf(ofp, \"\\t%.3f\",\n                        all_nseq ? 100.0 * stats->nreads[i] / all_nseq : 0);\n            }\n        }\n    }\n    fprintf(ofp, \"\\n\");\n\n    if (type == 'C') {\n        // For combined we compute mean and standard deviation too\n        fprintf(ofp, \"CRPERC\\tMEAN\");\n        for (r = 0; r < nref; r++) {\n            if (!amps[r].sites)\n                continue;\n            astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n            for (i = 0; i < amps[r].namp; i++) {\n                fprintf(ofp, \"\\t%.3f\", stats->nrperc[i] / nfile);\n            }\n        }\n        fprintf(ofp, \"\\n\");\n\n        fprintf(ofp, \"CRPERC\\tSTDDEV\");\n        for (r = 0; r < nref; r++) {\n            if (!amps[r].sites)\n                continue;\n            astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n            for (i = 0; i < amps[r].namp; i++) {\n                // variance = SUM(X^2) - ((SUM(X)^2) / N)\n                double n1 = stats->nrperc[i];\n                double v = stats->nrperc2[i]/nfile - (n1/nfile)*(n1/nfile);\n                fprintf(ofp, \"\\t%.3f\", v>0?sqrt(v):0);\n            }\n        }\n        fprintf(ofp, \"\\n\");\n    }\n\n    // Base depth\n    fprintf(ofp, \"# Read depth per amplicon.\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cDEPTH | cut -f 2-' to extract this part.\\n\", type);\n    fprintf(ofp, \"%cDEPTH\\t%s\", type, name);\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        amplicon_t *amp = amps[r].amp;\n        for (i = 0; i < amps[r].namp; i++) {\n            int nseq = stats->nseq - stats->nfiltered - stats->nfailprimer;\n            int64_t alen = amp[i].min_right - amp[i].max_left+1;\n            fprintf(ofp, \"\\t%.1f\", nseq ? stats->nbases[i] / (double)alen : 0);\n        }\n    }\n    fprintf(ofp, \"\\n\");\n\n    if (type == 'C') {\n        // For combined we can compute mean & standard deviation too\n        fprintf(ofp, \"CDEPTH\\tMEAN\");\n        for (r = 0; r < nref; r++) {\n            if (!amps[r].sites)\n                continue;\n            astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n            amplicon_t *amp = amps[r].amp;\n            int nseq = stats->nseq - stats->nfiltered - stats->nfailprimer;\n            for (i = 0; i < amps[r].namp; i++) {\n                int64_t alen = amp[i].min_right - amp[i].max_left+1;\n                fprintf(ofp, \"\\t%.1f\", nseq ? stats->nbases[i] / (double)alen / nfile : 0);\n            }\n        }\n        fprintf(ofp, \"\\n\");\n\n        fprintf(ofp, \"CDEPTH\\tSTDDEV\");\n        for (r = 0; r < nref; r++) {\n            if (!amps[r].sites)\n                continue;\n            astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n            amplicon_t *amp = amps[r].amp;\n            for (i = 0; i < amps[r].namp; i++) {\n                double alen = amp[i].min_right - amp[i].max_left+1;\n                double n1 = stats->nbases[i] / alen;\n                double v = stats->nbases2[i] / (alen*alen) /nfile\n                    - (n1/nfile)*(n1/nfile);\n                fprintf(ofp, \"\\t%.1f\", v>0?sqrt(v):0);\n            }\n        }\n        fprintf(ofp, \"\\n\");\n    }\n\n    // Percent Coverage\n    if (type == 'F') {\n        fprintf(ofp, \"# Percentage coverage per amplicon\\n\");\n        fprintf(ofp, \"# Use 'grep ^%cPCOV | cut -f 2-' to extract this part.\\n\", type);\n        int d = 0;\n        do {\n            fprintf(ofp, \"%cPCOV-%d\\t%s\", type, args->min_depth[d], name);\n\n            for (r = 0; r < nref; r++) {\n                if (!amps[r].sites)\n                    continue;\n                astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n                amplicon_t *amp = amps[r].amp;\n                for (i = 0; i < amps[r].namp; i++) {\n                    int covered = 0;\n                    if (amp[i].min_right - amp[i].min_left > stats->max_amp_len) {\n                        fprintf(stderr, \"[ampliconstats] error: \"\n                                \"Maximum amplicon length (%d) exceeded for '%s'\\n\",\n                                stats->max_amp, name);\n                        return -1;\n                    }\n                    int64_t j, offset = amp[i].min_left-1;\n                    for (j = amp[i].max_left-1; j < amp[i].min_right; j++) {\n                        int apos = i*stats->max_amp_len + j-offset;\n                        if (stats->coverage[apos] >= args->min_depth[d])\n                            covered++;\n                    }\n                    int64_t alen = amp[i].min_right - amp[i].max_left+1;\n                    stats->covered_perc[i][d] = 100.0 * covered / alen;\n                    fprintf(ofp, \"\\t%.2f\", 100.0 * covered / alen);\n                }\n            }\n            fprintf(ofp, \"\\n\");\n        } while (++d < MAX_DEPTH && args->min_depth[d]);\n\n    } else if (type == 'C') {\n        // For combined we can compute mean & standard deviation too\n        int d = 0;\n        do {\n            fprintf(ofp, \"CPCOV-%d\\tMEAN\", args->min_depth[d]);\n            for (r = 0; r < nref; r++) {\n                if (!amps[r].sites)\n                    continue;\n                astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n                for (i = 0; i < amps[r].namp; i++) {\n                    fprintf(ofp, \"\\t%.1f\", stats->covered_perc[i][d] / nfile);\n                }\n            }\n            fprintf(ofp, \"\\n\");\n\n            fprintf(ofp, \"CPCOV-%d\\tSTDDEV\", args->min_depth[d]);\n            for (r = 0; r < nref; r++) {\n                if (!amps[r].sites)\n                    continue;\n                astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n                for (i = 0; i < amps[r].namp; i++) {\n                    double n1 = stats->covered_perc[i][d] / nfile;\n                    double v = stats->covered_perc2[i][d] / nfile - n1*n1;\n                    fprintf(ofp, \"\\t%.1f\", v>0?sqrt(v):0);\n                }\n            }\n            fprintf(ofp, \"\\n\");\n        } while (++d < MAX_DEPTH && args->min_depth[d]);\n    }\n\n    // Plus base depth for all reads, irrespective of amplicon.\n    // This is post overlap removal, if reads in the read-pair overlap.\n    fprintf(ofp, \"# Depth per reference base for ALL data.\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cDP_ALL | cut -f 2-' to extract this part.\\n\",\n            type);\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        if (args->multi_ref)\n            fprintf(ofp, \"%cDP_ALL\\t%s\\t%s\", type, name, amps[r].ref);\n        else\n            fprintf(ofp, \"%cDP_ALL\\t%s\", type, name);\n\n        for (i = 0; i < amps[r].len; i++) {\n            // Basic run-length encoding provided all values are within\n            // +- depth_bin fraction of the mid-point.\n            int dmin = stats->depth_all[i], dmax = stats->depth_all[i], j;\n            double dmid = (dmin + dmax)/2.0;\n            double low  = dmid*(1-args->depth_bin);\n            double high = dmid*(1+args->depth_bin);\n            for (j = i+1; j < amps[r].len; j++) {\n                int d = stats->depth_all[j];\n                if (d < low || d > high)\n                    break;\n                if (dmin > d) {\n                    dmin = d;\n                    dmid = (dmin + dmax)/2.0;\n                    low  = dmid*(1-args->depth_bin);\n                    high = dmid*(1+args->depth_bin);\n                } else if (dmax < d) {\n                    dmax = d;\n                    dmid = (dmin + dmax)/2.0;\n                    low  = dmid*(1-args->depth_bin);\n                    high = dmid*(1+args->depth_bin);\n                }\n            }\n            fprintf(ofp, \"\\t%d,%d\", (int)dmid, j-i);\n            i = j-1;\n        }\n        fprintf(ofp, \"\\n\");\n    }\n\n    // And depth for only reads matching to a single amplicon for full\n    // length.  This is post read overlap removal.\n    fprintf(ofp, \"# Depth per reference base for full-length valid amplicon data.\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cDP_VALID | cut -f 2-' to extract this \"\n            \"part.\\n\", type);\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        if (args->multi_ref)\n            fprintf(ofp, \"%cDP_VALID\\t%s\\t%s\", type, name, amps[r].ref);\n        else\n            fprintf(ofp, \"%cDP_VALID\\t%s\", type, name);\n\n        for (i = 0; i < amps[r].len; i++) {\n            int dmin = stats->depth_valid[i], dmax = stats->depth_valid[i], j;\n            double dmid = (dmin + dmax)/2.0;\n            double low  = dmid*(1-args->depth_bin);\n            double high = dmid*(1+args->depth_bin);\n            for (j = i+1; j < amps[r].len; j++) {\n                int d = stats->depth_valid[j];\n                if (d < low || d > high)\n                    break;\n                if (dmin > d) {\n                    dmin = d;\n                    dmid = (dmin + dmax)/2.0;\n                    low  = dmid*(1-args->depth_bin);\n                    high = dmid*(1+args->depth_bin);\n                } else if (dmax < d) {\n                    dmax = d;\n                    dmid = (dmin + dmax)/2.0;\n                    low  = dmid*(1-args->depth_bin);\n                    high = dmid*(1+args->depth_bin);\n                }\n            }\n            fprintf(ofp, \"\\t%d,%d\", (int)dmid, j-i);\n            i = j-1;\n        }\n        fprintf(ofp, \"\\n\");\n    }\n\n    // TCOORD (start to end) distribution\n    fprintf(ofp, \"# Distribution of aligned template coordinates.\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cTCOORD | cut -f 2-' to extract this part.\\n\", type);\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        for (i = 0 - (nref==1); i < amps[r].namp; i++) {\n            if (ntcoord < kh_size(stats->tcoord[i+1])) {\n                ntcoord = kh_size(stats->tcoord[i+1]);\n                tcoord_t *tmp = realloc(tpos, ntcoord * sizeof(*tmp));\n                if (!tmp) {\n                    free(tpos);\n                    return -1;\n                }\n                tpos = tmp;\n            }\n\n            khiter_t k;\n            size_t n = 0, j;\n            for (k = kh_begin(stats->tcoord[i+1]);\n                 k != kh_end(stats->tcoord[i+1]); k++) {\n                if (!kh_exist(stats->tcoord[i+1], k) ||\n                    (kh_value(stats->tcoord[i+1], k) & 0xFFFFFFFF) == 0)\n                    continue;\n                // Key is start,end in 32-bit quantities.\n                // Yes this limits us to 4Gb references, but just how\n                // many primers are we planning on making?  Not that many\n                // I hope.\n                tpos[n].start = kh_key(stats->tcoord[i+1], k)&0xffffffff;\n                tpos[n].end   = kh_key(stats->tcoord[i+1], k)>>32;\n\n                // Value is frequency (top 32-bits) and status (bottom 32).\n                tpos[n].freq   = kh_value(stats->tcoord[i+1], k)&0xffffffff;\n                tpos[n].status = kh_value(stats->tcoord[i+1], k)>>32;\n                n++;\n            }\n\n            if (args->tcoord_bin > 1)\n                aggregate_tcoord(args, tpos, &n);\n\n            fprintf(ofp, \"%cTCOORD\\t%s\\t%d\", type, name,\n                    i+1+amps[r].first_amp); // per amplicon\n            for (j = 0; j < n; j++) {\n                if (tpos[j].freq < args->tcoord_min_count)\n                    continue;\n                fprintf(ofp, \"\\t%d,%d,%u,%u\",\n                        tpos[j].start,\n                        tpos[j].end,\n                        tpos[j].freq,\n                        tpos[j].status);\n            }\n            fprintf(ofp, \"\\n\");\n        }\n    }\n\n\n    // AMP length distribution.\n    // 0 = both ends in this amplicon\n    // 1 = ends in different amplicons\n    // 2 = other end matching an unknown amplicon site\n    //     (see tcoord for further analysis of where)\n    fprintf(ofp, \"# Classification of amplicon status.  Columns are\\n\");\n    fprintf(ofp, \"# number with both primers from this amplicon, number with\\n\");\n    fprintf(ofp, \"# primers from different amplicon, and number with a position\\n\");\n    fprintf(ofp, \"# not matching any valid amplicon primer site\\n\");\n    fprintf(ofp, \"# Use 'grep ^%cAMP | cut -f 2-' to extract this part.\\n\", type);\n\n    fprintf(ofp, \"%cAMP\\t%s\\t0\", type, name); // all merged\n    int amp_dist[3] = {0};\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        for (i = 0; i < amps[r].namp; i++) { // accumulate for all amps\n            amp_dist[0] += stats->amp_dist[i][0];\n            amp_dist[1] += stats->amp_dist[i][1];\n            amp_dist[2] += stats->amp_dist[i][2];\n        }\n    }\n    fprintf(ofp, \"\\t%d\\t%d\\t%d\\n\", amp_dist[0], amp_dist[1], amp_dist[2]);\n\n    for (r = 0; r < nref; r++) {\n        if (!amps[r].sites)\n            continue;\n        astats_t *stats = local ? amps[r].lstats : amps[r].gstats;\n        for (i = 0; i < amps[r].namp; i++) {\n            // per amplicon\n            fprintf(ofp, \"%cAMP\\t%s\\t%d\", type, name, i+1+amps[r].first_amp);\n            fprintf(ofp, \"\\t%d\\t%d\\t%d\\n\", stats->amp_dist[i][0],\n                    stats->amp_dist[i][1], stats->amp_dist[i][2]);\n        }\n    }\n\n    free(tpos);\n    return 0;\n}\n\nint dump_lstats(astats_args_t *args, char type, char *name, int nfile,\n               amplicons_t *amps, int nref) {\n    return dump_stats(args, type, name, nfile, amps, nref, 1);\n}\n\nint dump_gstats(astats_args_t *args, char type, char *name, int nfile,\n               amplicons_t *amps, int nref) {\n    return dump_stats(args, type, name, nfile, amps, nref, 0);\n}\n\nchar const *get_sample_name(sam_hdr_t *header, char *RG) {\n    kstring_t ks = {0};\n    sam_hdr_find_tag_id(header, \"RG\", RG?\"ID\":NULL, RG, \"SM\", &ks);\n    return ks.s;\n}\n\n// Return maximum reference length (SQ is NULL) or the length\n// of the specified reference in SQ.\nint64_t get_ref_len(sam_hdr_t *header, const char *SQ) {\n    if (SQ) {\n        int tid = SQ ? sam_hdr_name2tid(header, SQ) : 0;\n        return tid >= 0 ? sam_hdr_tid2len(header, tid) : -1;\n    } else {\n        int nref = sam_hdr_nref(header), tid;;\n        int64_t len = 0;\n        for (tid = 0; tid < nref; tid++) {\n            int64_t rl = sam_hdr_tid2len(header, tid);\n            if (len < rl)\n                len = rl;\n        }\n        return len;\n    }\n}\n\nstatic int amplicon_stats(astats_args_t *args,\n                          khash_t(bed_list_hash) *bed_hash,\n                          char **filev, int filec) {\n    int i, ref = -1, ref_tid = -1, ret = -1, nref = 0;\n    samFile *fp = NULL;\n    sam_hdr_t *header = NULL;\n    bam1_t *b = bam_init1();\n    FILE *ofp = args->out_fp;\n    char sname_[8192], *sname = NULL;\n    amplicons_t *amps = NULL;\n\n    // Report initial SS header.  We gather data from the bed_hash entries\n    // as well as from the first SAM header (with the requirement that all\n    // headers should be compatible).\n    if (filec) {\n        if (!(fp = sam_open_format(filev[0], \"r\", &args->ga.in))) {\n            print_error_errno(\"ampliconstats\",\n                              \"Cannot open input file \\\"%s\\\"\",\n                              filev[0]);\n            goto err;\n        }\n        if (!(header = sam_hdr_read(fp)))\n            goto err;\n\n        if (!amps) {\n            amps = calloc(nref=sam_hdr_nref(header), sizeof(*amps));\n            if (!amps)\n                goto err;\n            fprintf(ofp, \"# Summary statistics, used for scaling the plots.\\n\");\n            fprintf(ofp, \"SS\\tSamtools version: %s\\n\", samtools_version());\n            fprintf(ofp, \"SS\\tCommand line: %s\\n\", args->argv);\n            fprintf(ofp, \"SS\\tNumber of files:\\t%d\\n\", filec);\n\n            // Note: order of hash entries will be different to order of\n            // BED file which may also differ to order of SQ headers.\n            // SQ header is canonical ordering (pos sorted file).\n            khiter_t k;\n            int bam_nref = sam_hdr_nref(header);\n            for (i = 0; i < bam_nref; i++) {\n                k = kh_get(bed_list_hash, bed_hash,\n                           sam_hdr_tid2name(header, i));\n                if (!kh_exist(bed_hash, k))\n                    continue;\n\n                bed_entry_list_t *sites = &kh_value(bed_hash, k);\n\n                ref = i;\n                amps[ref].ref = kh_key(bed_hash, k);\n                amps[ref].sites = sites;\n                amps[ref].namp = count_amplicon(sites);\n                amps[ref].amp  = calloc(sites->length,\n                                        sizeof(*amps[ref].amp));\n                if (!amps[ref].amp)\n                    goto err;\n                if (args->multi_ref)\n                    fprintf(ofp, \"SS\\tNumber of amplicons:\\t%s\\t%d\\n\",\n                            kh_key(bed_hash, k), amps[ref].namp);\n                else\n                    fprintf(ofp, \"SS\\tNumber of amplicons:\\t%d\\n\",\n                            amps[ref].namp);\n\n                amps[ref].tid = ref;\n                if (ref_tid == -1)\n                    ref_tid = ref;\n\n                int64_t len = get_ref_len(header, kh_key(bed_hash, k));\n                amps[ref].len = len;\n                if (args->multi_ref)\n                    fprintf(ofp, \"SS\\tReference length:\\t%s\\t%\"PRId64\"\\n\",\n                            kh_key(bed_hash, k), len);\n                else\n                    fprintf(ofp, \"SS\\tReference length:\\t%\"PRId64\"\\n\",\n                            len);\n\n                amps[ref].lstats = stats_alloc(len, args->max_amp,\n                                               args->max_amp_len);\n                amps[ref].gstats = stats_alloc(len, args->max_amp,\n                                               args->max_amp_len);\n                if (!amps[ref].lstats || !amps[ref].gstats)\n                    goto err;\n            }\n        }\n\n        sam_hdr_destroy(header);\n        header = NULL;\n        if (sam_close(fp) < 0) {\n            fp = NULL;\n            goto err;\n        }\n        fp = NULL;\n    }\n    fprintf(ofp, \"SS\\tEnd of summary\\n\");\n\n    // Extract the bits of amplicon data we need from bed hash and turn\n    // it into a position-to-amplicon lookup table.\n    int offset = 0;\n    for (i = 0; i < nref; i++) {\n        if (!amps[i].sites)\n            continue;\n\n        amps[i].first_amp = offset;\n        if (bed2amplicon(args, amps[i].sites, amps[i].amp,\n                         &amps[i].namp, i==0, amps[i].ref, offset) < 0)\n            goto err;\n\n        offset += amps[i].namp; // cumulative amplicon number across refs\n    }\n\n    // Now iterate over file contents, one at a time.\n    for (i = 0; i < filec; i++) {\n        char *nstart = filev[i];\n\n        fp = sam_open_format(filev[i], \"r\", &args->ga.in);\n        if (!fp) {\n            print_error_errno(\"ampliconstats\",\n                              \"Cannot open input file \\\"%s\\\"\",\n                              filev[i]);\n            goto err;\n        }\n\n        if (args->ga.nthreads > 0)\n            hts_set_threads(fp, args->ga.nthreads);\n\n        if (!(header = sam_hdr_read(fp)))\n            goto err;\n\n        if (nref != sam_hdr_nref(header)) {\n            print_error_errno(\"ampliconstats\",\n                              \"SAM headers are not consistent across input files\");\n            goto err;\n        }\n        int r;\n        for (r = 0; r < nref; r++) {\n            if (!amps[r].sites)\n                continue;\n            if (!amps[r].ref ||\n                strcmp(amps[r].ref, sam_hdr_tid2name(header, r)) != 0 ||\n                amps[r].len != sam_hdr_tid2len(header, r)) {\n                print_error_errno(\"ampliconstats\",\n                                  \"SAM headers are not consistent across \"\n                                  \"input files\");\n                goto err;\n            }\n        }\n\n        if (args->use_sample_name)\n            sname = (char *)get_sample_name(header, NULL);\n\n        if (!sname) {\n            sname = sname_;\n            char *nend = filev[i] + strlen(filev[i]), *cp;\n            if ((cp = strrchr(filev[i], '/')))\n                nstart = cp+1;\n            if ((cp = strrchr(nstart, '.')) &&\n                (strcmp(cp, \".bam\") == 0 ||\n                 strcmp(cp, \".sam\") == 0 ||\n                 strcmp(cp, \".cram\") == 0))\n                nend = cp;\n            if (nend - nstart >= 8192) nend = nstart+8191;\n            memcpy(sname, nstart, nend-nstart);\n            sname[nend-nstart] = 0;\n        }\n\n        // Stats local to this sample only\n        amp_stats_reset(amps, nref);\n\n        int last_ref = -9;\n        while ((r = sam_read1(fp, header, b)) >= 0) {\n            // Other filter options useful here?\n            if (b->core.tid < 0)\n                continue;\n\n            if (last_ref != b->core.tid) {\n                last_ref  = b->core.tid;\n                if (initialise_amp_pos_lookup(args, amps, last_ref) < 0)\n                    goto err;\n            }\n\n            if (accumulate_stats(args, amps, b) < 0)\n                goto err;\n        }\n\n        if (r < -1) {\n            print_error_errno(\"ampliconstats\", \"Fail reading record\");\n            goto err;\n        }\n\n        sam_hdr_destroy(header);\n        if (sam_close(fp) < 0) {\n            fp = NULL;\n            goto err;\n        }\n\n        fp = NULL;\n        header = NULL;\n\n        if (dump_lstats(args, 'F', sname, filec, amps, nref) < 0)\n            goto err;\n\n        if (append_stats(amps, nref) < 0)\n            goto err;\n\n        if (sname && sname != sname_)\n            free(sname);\n        sname = NULL;\n    }\n\n    if (dump_gstats(args, 'C', \"COMBINED\", filec, amps, nref) < 0)\n        goto err;\n\n    ret = 0;\n err:\n    bam_destroy1(b);\n    if (ret) {\n        if (header)\n            sam_hdr_destroy(header);\n        if (fp)\n            sam_close(fp);\n    }\n    for (i = 0; i < nref; i++) {\n        stats_free(amps[i].lstats);\n        stats_free(amps[i].gstats);\n        free(amps[i].amp);\n    }\n    free(amps);\n    free(pos2start);\n    free(pos2end);\n    if (ret) {\n        if (sname && sname != sname_)\n            free(sname);\n    }\n\n    return ret;\n}\n\nstatic int usage(astats_args_t *args, FILE *fp, int exit_status) {\n    fprintf(fp,\n\"\\n\"\n\"Usage: samtools ampliconstats [options] primers.bed *.bam > astats.txt\\n\"\n\"\\n\"\n\"Options:\\n\");\n    fprintf(fp, \"  -f, --required-flag STR|INT\\n\"\n            \"               Only include reads with all of the FLAGs present [0x%X]\\n\",args->flag_require);\n    fprintf(fp, \"  -F, --filter-flag STR|INT\\n\"\n            \"               Only include reads with none of the FLAGs present [0x%X]\\n\",args->flag_filter & 0xffff);\n    fprintf(fp, \"  -a, --max-amplicons INT\\n\"\n            \"               Change the maximum number of amplicons permitted [%d]\\n\", MAX_AMP);\n    fprintf(fp, \"  -l, --max-amplicon-length INT\\n\"\n            \"               Change the maximum length of an individual amplicon [%d]\\n\", MAX_AMP_LEN);\n    fprintf(fp, \"  -d, --min-depth INT[,INT]...\\n\"\n            \"               Minimum base depth(s) to consider position covered [%d]\\n\", args->min_depth[0]);\n    fprintf(fp, \"  -m, --pos-margin INT\\n\"\n            \"               Margin of error for matching primer positions [%d]\\n\", args->max_delta);\n    fprintf(fp, \"  -o, --output FILE\\n\"\n            \"               Specify output file [stdout if unset]\\n\");\n    fprintf(fp, \"  -s, --use-sample-name\\n\"\n            \"               Use the sample name from the first @RG header line\\n\");\n    fprintf(fp, \"  -t, --tlen-adjust INT\\n\"\n            \"               Add/subtract from TLEN; use when clipping but no fixmate step\\n\");\n    fprintf(fp, \"  -b, --tcoord-bin INT\\n\"\n            \"               Bin template start,end positions into multiples of INT[1]\\n\");\n    fprintf(fp, \"  -c, --tcoord-min-count INT\\n\"\n            \"               Minimum template start,end frequency for recording [%d]\\n\", TCOORD_MIN_COUNT);\n    fprintf(fp, \"  -D, --depth-bin FRACTION\\n\"\n            \"               Merge FDP values within +/- FRACTION together\\n\");\n    fprintf(fp, \"  -S, --single-ref\\n\"\n            \"               Force single-ref (<=1.12) output format\\n\");\n    sam_global_opt_help(fp, \"I.--.@\");\n\n    return exit_status;\n}\n\nint main_ampliconstats(int argc, char **argv) {\n    astats_args_t args = {\n        .ga = SAM_GLOBAL_ARGS_INIT,\n        .flag_require = 0,\n        .flag_filter = 0x10B04,\n        //.sites = BED_LIST_INIT,\n        .max_delta = 30, // large enough to cope with alt primers\n        .min_depth = {1},\n        .use_sample_name = 0,\n        .max_amp = MAX_AMP,\n        .max_amp_len = MAX_AMP_LEN,\n        .tlen_adj = 0,\n        .out_fp = stdout,\n        .tcoord_min_count = TCOORD_MIN_COUNT,\n        .tcoord_bin = 1,\n        .depth_bin = 0.01,\n        .multi_ref = 1\n    }, oargs = args;\n\n    static const struct option loptions[] =\n    {\n        SAM_OPT_GLOBAL_OPTIONS('I', 0, '-', '-', 0, '@'),\n        {\"help\", no_argument, NULL, 'h'},\n        {\"flag-require\", required_argument, NULL, 'f'},\n        {\"flag-filter\", required_argument, NULL, 'F'},\n        {\"min-depth\", required_argument, NULL, 'd'},\n        {\"output\", required_argument, NULL, 'o'},\n        {\"pos-margin\", required_argument, NULL, 'm'},\n        {\"use-sample-name\", no_argument, NULL, 's'},\n        {\"max-amplicons\", required_argument, NULL, 'a'},\n        {\"max-amplicon-length\", required_argument, NULL, 'l'},\n        {\"tlen-adjust\", required_argument, NULL, 't'},\n        {\"tcoord-min-count\", required_argument, NULL, 'c'},\n        {\"tcoord-bin\", required_argument, NULL, 'b'},\n        {\"depth-bin\", required_argument, NULL, 'D'},\n        {\"single-ref\", no_argument, NULL, 'S'},\n        {NULL, 0, NULL, 0}\n    };\n    int opt, tmp_flag;\n\n    while ( (opt=getopt_long(argc,argv,\"?hf:F:@:p:m:d:sa:l:t:o:c:b:D:S\",loptions,NULL))>0 ) {\n        switch (opt) {\n        case 'f':\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"ampliconstats\", \"Unknown flag '%s'\\n\", optarg);\n                return 1;\n            }\n\n            args.flag_require = tmp_flag;\n            break;\n\n        case 'F':\n            tmp_flag = bam_str2flag(optarg);\n\n            if (args.flag_filter & 0x10000)\n                args.flag_filter = 0; // strip default on first -F usage\n\n            if (tmp_flag < 0) {\n                print_error(\"ampliconstats\", \"Unknown flag '%s'\\n\", optarg);\n                return 1;\n            }\n\n            args.flag_filter |= tmp_flag;\n            break;\n\n        case 'm': args.max_delta = atoi(optarg); break; // margin\n        case 'D': args.depth_bin = atof(optarg); break; // depth bin fraction\n        case 'd': {\n            int d = 0;\n            char *cp = optarg, *ep;\n            do {\n                long n = strtol(cp, &ep, 10);\n                args.min_depth[d++] = n;\n                if (*ep != ',')\n                    break;\n                cp = ep+1;\n            } while (d < MAX_DEPTH);\n            break;\n        }\n\n        case 'a': args.max_amp = atoi(optarg)+1;break;\n        case 'l': args.max_amp_len = atoi(optarg)+1;break;\n\n        case 'c': args.tcoord_min_count = atoi(optarg);break;\n        case 'b':\n            args.tcoord_bin = atoi(optarg);\n            if (args.tcoord_bin < 1)\n                args.tcoord_bin = 1;\n            break;\n\n        case 't': args.tlen_adj = atoi(optarg);break;\n\n        case 's': args.use_sample_name = 1;break;\n\n        case 'o':\n            if (!(args.out_fp = fopen(optarg, \"w\"))) {\n                perror(optarg);\n                return 1;\n            }\n            break;\n\n        case 'S':\n            args.multi_ref = 0;\n            break;\n\n        case '?': return usage(&oargs, stderr, EXIT_FAILURE);\n        case 'h': return usage(&oargs, stdout, EXIT_SUCCESS);\n\n        default:\n            if (parse_sam_global_opt(opt, optarg, loptions, &args.ga) != 0)\n                usage(&oargs,stderr, EXIT_FAILURE);\n            break;\n        }\n    }\n\n    if (argc <= optind)\n        return usage(&oargs, stdout, EXIT_SUCCESS);\n    if (argc <= optind+1 && isatty(STDIN_FILENO))\n        return usage(&oargs, stderr, EXIT_FAILURE);\n\n    khash_t(bed_list_hash) *bed_hash = kh_init(bed_list_hash);\n    if (load_bed_file_multi_ref(argv[optind], 1, 0, bed_hash, NULL, NULL)) {\n        print_error_errno(\"ampliconstats\",\n                          \"Could not read file \\\"%s\\\"\", argv[optind]);\n        return 1;\n\n    }\n\n    khiter_t k, ref_count = 0;\n    for (k = kh_begin(bed_hash); k != kh_end(bed_hash); k++) {\n        if (!kh_exist(bed_hash, k))\n            continue;\n        ref_count++;\n    }\n    if (ref_count == 0)\n        return 1;\n    if (ref_count > 1 && args.multi_ref == 0) {\n        print_error(\"ampliconstats\",\n                    \"Single-ref mode is not permitted for BED files\\n\"\n                    \"containing more than one reference.\");\n        return 1;\n    }\n\n    args.argv = stringify_argv(argc, argv);\n    int ret;\n    if (argc == ++optind) {\n        char *av = \"-\";\n        ret = amplicon_stats(&args, bed_hash, &av, 1);\n    } else {\n        ret = amplicon_stats(&args, bed_hash, &argv[optind], argc-optind);\n    }\n\n    free(args.argv);\n    destroy_bed_hash(bed_hash);\n\n    return ret;\n}\n"
        },
        {
          "name": "bam.c",
          "type": "blob",
          "size": 8.783203125,
          "content": "/*  bam.c -- miscellaneous BAM functions.\n\n    Copyright (C) 2008-2013, 2015, 2019-2020, 2022 Genome Research Ltd.\n    Portions copyright (C) 2009-2012 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <ctype.h>\n#include <errno.h>\n#include \"bam.h\"\n#include \"htslib/kstring.h\"\n\n// FIXME: we should also check the LB tag associated with each alignment\nconst char *bam_get_library(sam_hdr_t *h, const bam1_t *b)\n{\n    const char *rg;\n    kstring_t lib = { 0, 0, NULL };\n    rg = (char *)bam_aux_get(b, \"RG\");\n\n    if (!rg)\n        return NULL;\n    else\n        rg++;\n\n    if (sam_hdr_find_tag_id(h, \"RG\", \"ID\", rg, \"LB\", &lib)  < 0)\n        return NULL;\n\n    static char LB_text[1024];\n    int len = lib.l < sizeof(LB_text) - 1 ? lib.l : sizeof(LB_text) - 1;\n\n    memcpy(LB_text, lib.s, len);\n    LB_text[len] = 0;\n\n    free(lib.s);\n\n    return LB_text;\n}\n\n/************\n * Remove B *\n ************/\n\n#define bam1_seq_seti(s, i, c) ( (s)[(i)>>1] = ((s)[(i)>>1] & 0xf<<(((i)&1)<<2)) | (c)<<((~(i)&1)<<2) )\n\nint bam_remove_B(bam1_t *b)\n{\n    int i, j, end_j, k, l, no_qual;\n    uint32_t *cigar, *new_cigar;\n    uint8_t *seq, *qual, *p;\n    // test if removal is necessary\n    if (b->core.flag & BAM_FUNMAP) return 0; // unmapped; do nothing\n    cigar = bam_get_cigar(b);\n    for (k = 0; k < b->core.n_cigar; ++k)\n        if (bam_cigar_op(cigar[k]) == BAM_CBACK) break;\n    if (k == b->core.n_cigar) return 0; // no 'B'\n    if (bam_cigar_op(cigar[0]) == BAM_CBACK) goto rmB_err; // cannot be removed\n    // allocate memory for the new CIGAR\n    if (b->l_data + (b->core.n_cigar + 1) * 4 > b->m_data) { // not enough memory\n        b->m_data = b->l_data + b->core.n_cigar * 4;\n        kroundup32(b->m_data);\n        b->data = (uint8_t*)realloc(b->data, b->m_data);\n        cigar = bam_get_cigar(b); // after realloc, cigar may be changed\n    }\n    new_cigar = (uint32_t*)(b->data + (b->m_data - b->core.n_cigar * 4)); // from the end of b->data\n    // the core loop\n    seq = bam_get_seq(b); qual = bam_get_qual(b);\n    no_qual = (qual[0] == 0xff); // test whether base quality is available\n    i = j = 0; end_j = -1;\n    for (k = l = 0; k < b->core.n_cigar; ++k) {\n        int op  = bam_cigar_op(cigar[k]);\n        int len = bam_cigar_oplen(cigar[k]);\n        if (op == BAM_CBACK) { // the backward operation\n            int t, u;\n            if (k == b->core.n_cigar - 1) break; // ignore 'B' at the end of CIGAR\n            if (len > j) goto rmB_err; // an excessively long backward\n            for (t = l - 1, u = 0; t >= 0; --t) { // look back\n                int op1  = bam_cigar_op(new_cigar[t]);\n                int len1 = bam_cigar_oplen(new_cigar[t]);\n                if (bam_cigar_type(op1)&1) { // consume the query\n                    if (u + len1 >= len) { // stop\n                        new_cigar[t] -= (len - u) << BAM_CIGAR_SHIFT;\n                        break;\n                    } else u += len1;\n                }\n            }\n            if (bam_cigar_oplen(new_cigar[t]) == 0) --t; // squeeze out the zero-length operation\n            l = t + 1;\n            end_j = j; j -= len;\n        } else { // other CIGAR operations\n            new_cigar[l++] = cigar[k];\n            if (bam_cigar_type(op)&1) { // consume the query\n                if (i != j) { // no need to copy if i == j\n                    int u, c, c0;\n                    for (u = 0; u < len; ++u) { // construct the consensus\n                        c = bam_seqi(seq, i+u);\n                        if (j + u < end_j) { // in an overlap\n                            c0 = bam_seqi(seq, j+u);\n                            if (c != c0) { // a mismatch; choose the better base\n                                if (qual[j+u] < qual[i+u]) { // the base in the 2nd segment is better\n                                    bam1_seq_seti(seq, j+u, c);\n                                    qual[j+u] = qual[i+u] - qual[j+u];\n                                } else qual[j+u] -= qual[i+u]; // the 1st is better; reduce base quality\n                            } else qual[j+u] = qual[j+u] > qual[i+u]? qual[j+u] : qual[i+u];\n                        } else { // not in an overlap; copy over\n                            bam1_seq_seti(seq, j+u, c);\n                            qual[j+u] = qual[i+u];\n                        }\n                    }\n                }\n                i += len, j += len;\n            }\n        }\n    }\n    if (no_qual) qual[0] = 0xff; // in very rare cases, this may be modified\n    // merge adjacent operations if possible\n    for (k = 1; k < l; ++k)\n        if (bam_cigar_op(new_cigar[k]) == bam_cigar_op(new_cigar[k-1]))\n            new_cigar[k] += new_cigar[k-1] >> BAM_CIGAR_SHIFT << BAM_CIGAR_SHIFT, new_cigar[k-1] &= 0xf;\n    // kill zero length operations\n    for (k = i = 0; k < l; ++k)\n        if (new_cigar[k] >> BAM_CIGAR_SHIFT)\n            new_cigar[i++] = new_cigar[k];\n    l = i;\n    // update b\n    memcpy(cigar, new_cigar, l * 4); // set CIGAR\n    p = b->data + b->core.l_qname + l * 4;\n    memmove(p, seq, (j+1)>>1); p += (j+1)>>1; // set SEQ\n    memmove(p, qual, j); p += j; // set QUAL\n    memmove(p, bam_get_aux(b), bam_get_l_aux(b)); p += bam_get_l_aux(b); // set optional fields\n    b->core.n_cigar = l, b->core.l_qseq = j; // update CIGAR length and query length\n    b->l_data = p - b->data; // update record length\n    return 0;\n\nrmB_err:\n    b->core.flag |= BAM_FUNMAP;\n    return -1;\n}\n\n/* Calculate the current read's start based on the stored cigar string. */\nhts_pos_t unclipped_start(bam1_t *b) {\n    uint32_t *cigar = bam_get_cigar(b);\n    int64_t clipped = 0;\n    uint32_t i;\n\n    for (i = 0; i < b->core.n_cigar; i++) {\n        char c = bam_cigar_opchr(cigar[i]);\n\n        if (c == 'S' || c == 'H') { // clips\n            clipped += bam_cigar_oplen(cigar[i]);\n        } else {\n            break;\n        }\n    }\n\n    return b->core.pos - clipped + 1;\n}\n\n/* Calculate the mate's unclipped start based on position and cigar string from MC tag. */\nhts_pos_t unclipped_other_start(hts_pos_t op, char *cigar) {\n    char *c = cigar;\n    int64_t clipped = 0;\n\n    while (*c && *c != '*') {\n        long num = 0;\n\n        if (isdigit((int)*c)) {\n            num = strtol(c, &c, 10);\n        } else {\n            num = 1;\n        }\n\n        if (*c == 'S' || *c == 'H') { // clips\n            clipped += num;\n        } else {\n            break;\n        }\n\n        c++;\n    }\n\n    return op - clipped + 1;\n}\n\n/* Calculate the current read's end based on the stored cigar string. */\nhts_pos_t unclipped_end(bam1_t *b) {\n    uint32_t *cigar = bam_get_cigar(b);\n    hts_pos_t end_pos, clipped = 0;\n    int32_t i;\n\n    end_pos = bam_endpos(b);\n\n    // now get the clipped end bases (if any)\n    // if we get to the beginning of the cigar string\n    // without hitting a non-clip then the results are meaningless\n    for (i = b->core.n_cigar - 1; i >= 0; i--) {\n        char c = bam_cigar_opchr(cigar[i]);\n\n        if (c == 'S' || c == 'H') { // clips\n            clipped += bam_cigar_oplen(cigar[i]);\n        } else {\n            break;\n        }\n    }\n\n    return end_pos + clipped;\n}\n\n\n/* Calculate the mate's unclipped end based on start position and cigar string from MC tag.*/\nhts_pos_t unclipped_other_end(int64_t op, char *cigar) {\n    char *c = cigar;\n    int64_t refpos = 0;\n    int skip = 1;\n\n    while (*c && *c != '*') {\n        long num = 0;\n\n        if (isdigit((int)*c)) {\n            num = strtol(c, &c, 10);\n        } else {\n            num = 1;\n        }\n\n        switch (*c) {\n            case 'M':\n            case 'D':\n            case 'N':\n            case '=':\n            case 'X':\n                refpos += num;\n                skip = 0; // ignore initial clips\n            break;\n\n            case 'S':\n            case 'H':\n                if (!skip) {\n                refpos += num;\n            }\n            break;\n        }\n\n        c++;\n   }\n\n    return  op + refpos;\n}\n"
        },
        {
          "name": "bam.h",
          "type": "blob",
          "size": 1.4873046875,
          "content": "/*  bam.h -- miscellaneous BAM functions.\n\n    Copyright (C) 2008-2014, 2019 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BAM_BAM_H\n#define BAM_BAM_H\n\n#include \"htslib/sam.h\"\n\nint bam_remove_B(bam1_t *b);\n\nconst char *bam_get_library(sam_hdr_t *header, const bam1_t *b);\n\nhts_pos_t unclipped_start(bam1_t *b);\nhts_pos_t unclipped_other_start(hts_pos_t op, char *cigar);\nhts_pos_t unclipped_end(bam1_t *b);\nhts_pos_t unclipped_other_end(int64_t op, char *cigar);\n\n#endif\n"
        },
        {
          "name": "bam2bcf.c",
          "type": "blob",
          "size": 4.26171875,
          "content": "/*  bam2bcf.c -- variant calling.  Used for tview consensus\n\n    Copyright (C) 2010-2012 Broad Institute.\n    Copyright (C) 2012-2015, 2021-2022 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdint.h>\n#include <assert.h>\n#include <htslib/hts.h>\n#include <htslib/sam.h>\n#include \"bam2bcf.h\"\n\n#define CALL_DEFTHETA 0.83\n#define DEF_MAPQ 20\n\n#define CAP_DIST 25\n\nbcf_callaux_t *bcf_call_init(double theta, int min_baseQ)\n{\n    bcf_callaux_t *bca;\n    if (theta <= 0.) theta = CALL_DEFTHETA;\n    bca = calloc(1, sizeof(bcf_callaux_t));\n    bca->capQ = 60;\n    bca->min_baseQ = min_baseQ;\n    bca->e = errmod_init(1. - theta);\n    return bca;\n}\n\nvoid bcf_call_destroy(bcf_callaux_t *bca)\n{\n    if (bca == 0) return;\n    errmod_destroy(bca->e);\n    free(bca->bases); free(bca);\n}\n\n/*\n * This function is called once for each sample.\n * _n is number of pilesups pl contributing reads to this sample\n * pl is pointer to array of _n pileups (one pileup per read)\n * ref_base is the 4-bit representation of the reference base. It is negative if we are looking at an indel.\n * bca is the settings to perform calls across all samples\n * r is the returned value of the call\n */\nint bcf_call_glfgen(int _n, const bam_pileup1_t *pl, int ref_base, bcf_callaux_t *bca, bcf_callret1_t *r)\n{\n    int i, n, is_indel;\n\n    // clean from previous run\n    memset(r->qsum,0,sizeof(float)*4);\n    memset(r->p,0,sizeof(float)*25);\n\n    if (ref_base >= 0) {\n        is_indel = 0;\n    } else is_indel = 1;\n    if (_n <= 0) return -1;\n    // enlarge the bases array if necessary\n    if (bca->max_bases < _n) {\n        bca->max_bases = _n;\n        kroundup32(bca->max_bases);\n        bca->bases = (uint16_t*)realloc(bca->bases, 2 * (size_t) bca->max_bases);\n    }\n    // fill the bases array\n    for (i = n = 0; i < _n; ++i) {\n        const bam_pileup1_t *p = pl + i;\n        int q, b, mapQ, min_dist, seqQ;\n        // set base\n        if (p->is_del || p->is_refskip || (p->b->core.flag&BAM_FUNMAP)) continue;\n        mapQ  = p->b->core.qual < 255? p->b->core.qual : DEF_MAPQ; // special case for mapQ==255\n        q = is_indel? p->aux&0xff : // base/indel quality\n            (p->qpos < p->b->core.l_qseq\n             ? (int)bam_get_qual(p->b)[p->qpos]\n             : 0);\n        seqQ = is_indel? (p->aux>>8&0xff) : 99;\n        if (q < bca->min_baseQ) continue;\n        if (q > seqQ) q = seqQ;\n        mapQ = mapQ < bca->capQ? mapQ : bca->capQ;\n        if (q > mapQ) q = mapQ;\n        if (q > 63) q = 63;\n        if (q < 4) q = 4;       // MQ=0 reads count as BQ=4\n        if (!is_indel) {\n            if (p->qpos < p->b->core.l_qseq) {\n                b = bam_seqi(bam_get_seq(p->b), p->qpos); // base\n                b = seq_nt16_int[b? b : ref_base]; // b is the 2-bit base\n            } else {\n                b = 4; // N\n            }\n        } else {\n            b = p->aux>>16&0x3f;\n        }\n        bca->bases[n++] = q<<5 | (int)bam_is_rev(p->b)<<4 | b;\n        // collect annotations\n        if (b < 4)\n            r->qsum[b] += q;\n\n        min_dist = p->b->core.l_qseq - 1 - p->qpos;\n        if (min_dist > p->qpos) min_dist = p->qpos;\n        if (min_dist > CAP_DIST) min_dist = CAP_DIST;\n    }\n    // glfgen\n    errmod_cal(bca->e, n, 5, bca->bases, r->p); // calculate PL of each genotype\n    return n;\n}\n"
        },
        {
          "name": "bam2bcf.h",
          "type": "blob",
          "size": 2.0029296875,
          "content": "/*  bam2bcf.h -- variant calling.\n\n    Copyright (C) 2010-2012 Broad Institute.\n    Copyright (C) 2012-2014, 2019, 2021 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BAM2BCF_H\n#define BAM2BCF_H\n\n#include <stdint.h>\n#include <htslib/hts.h>\n#include <htslib/vcf.h>\n\ntypedef struct __bcf_callaux_t {\n    int capQ, min_baseQ;\n    // for internal uses\n    int max_bases;\n    uint16_t *bases;        // 5bit: unused, 6:quality, 1:is_rev, 4:2-bit base or indel allele (index to bcf_callaux_t.indel_types)\n    errmod_t *e;\n} bcf_callaux_t;\n\n// NB: Only bits used by tview are retained.\ntypedef struct {\n    float qsum[4];\n    float p[25];        // phred-scaled likelihood of each genotype\n} bcf_callret1_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n    bcf_callaux_t *bcf_call_init(double theta, int min_baseQ);\n    void bcf_call_destroy(bcf_callaux_t *bca);\n    int bcf_call_glfgen(int _n, const bam_pileup1_t *pl, int ref_base, bcf_callaux_t *bca, bcf_callret1_t *r);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bam2depth.c",
          "type": "blob",
          "size": 32.5693359375,
          "content": "/*  bam2depth.c -- depth subcommand.\n\n    Copyright (C) 2011, 2012 Broad Institute.\n    Copyright (C) 2012-2016, 2018, 2019-2022, 2024 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk> (to 2020)\n    Author: James Bonfield <jkb@sanger.ac.uk> (2021 rewrite)\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n/* This program demonstrates how to generate pileup from multiple BAMs\n * simultaneously, to achieve random access and to use the BED interface.\n * To compile this program separately, you may:\n *\n *   gcc -g -O2 -Wall -o bam2depth -D_MAIN_BAM2DEPTH bam2depth.c -lhts -lz\n */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <unistd.h>\n#include \"htslib/sam.h\"\n#include \"samtools.h\"\n#include \"bedidx.h\"\n#include \"sam_opts.h\"\n#include \"htslib/khash.h\"\n\n// From bam_plcmd.c\nint read_file_list(const char *file_list, int *n, char **argv[]);\n\n// We accumulate to hist[pos & (size-1)].  This is a ring-buffer.\n// We track where we last got to in output and what the biggest value\n// we've written to so far (in absolute unmasked coordinates) in\n// \"last_output\" and \"end_pos\" respectively.\n// For each new record we just flush anything we haven't written yet\n// already, between \"last_output\" and this read's start position, and\n// initialise any newly seen positions between \"end_pos\" and this read's\n// end position.\ntypedef struct {\n    size_t size;\n    int **hist;         // hist[nfiles][size]\n    hts_pos_t *end_pos; // end_pos[nfiles]\n    hts_pos_t last_output;\n    int last_ref;\n    int nfiles;\n    const char *ref;\n    kstring_t ks;\n    hts_pos_t beg, end; // limit to region\n    int tid;\n} depth_hist;\n\ntypedef struct {\n    int header;\n    int flag;\n    int incl_flag;\n    int require_flag;\n    int min_qual;\n    int min_mqual;\n    int min_len;\n    int skip_del;\n    int all_pos;\n    int remove_overlaps;\n    FILE *out;\n    char *reg;\n    void *bed;\n} depth_opt;\n\nstatic void zero_region(depth_opt *opt, depth_hist *dh,\n                        const char *name, hts_pos_t start, hts_pos_t end) {\n    hts_pos_t i;\n    kstring_t *ks = &dh->ks;\n\n    kputs(name, ks_clear(ks));\n    kputc('\\t', ks);\n    size_t cur_l = ks->l;\n    if (dh->beg >= 0 && start < dh->beg)\n        start = dh->beg;\n    if (dh->end >= 0 && end > dh->end)\n        end = dh->end;\n\n    for (i = start; i < end; i++) {\n        // Could be optimised, but needs better API to skip to next\n        // bed region.\n        if (opt->bed && bed_overlap(opt->bed, name, i, i+1) == 0)\n            continue;\n\n        ks->l = cur_l;\n        kputll(i+1,  ks);\n        int n;\n        for (n = 0; n < dh->nfiles; n++) {\n            kputc_('\\t', ks);\n            kputc_('0',  ks);\n        }\n        kputc('\\n',  ks);\n        fputs(ks->s, opt->out);\n    }\n    ks->l = cur_l;\n}\n\n// A variation of bam_cigar2qlen which doesn't count soft-clips in to the\n// equation.  Basically it's the number of bases in query that are aligned\n// in some way to the reference (including insertions, which are considered\n// to be aligned by dint of being anchored either side).\nhts_pos_t qlen_used(bam1_t *b) {\n    int n_cigar = b->core.n_cigar;\n    const uint32_t *cigar = bam_get_cigar(b);\n\n    hts_pos_t l;\n\n    if (b->core.l_qseq) {\n        // Known SEQ permits of short cut of l_qseq minus CSOFT_CLIPs.\n        // Full scan not needed, which helps on excessively long CIGARs.\n        l = b->core.l_qseq;\n        int kl, kr;\n        for (kl = 0; kl < n_cigar; kl++)\n            if (bam_cigar_op(cigar[kl]) == BAM_CSOFT_CLIP)\n                l -= bam_cigar_oplen(cigar[kl]);\n            else\n                break;\n\n        for (kr = n_cigar-1; kr > kl; kr--)\n            if (bam_cigar_op(cigar[kr]) == BAM_CSOFT_CLIP)\n                l -= bam_cigar_oplen(cigar[kr]);\n            else\n                break;\n    } else {\n        // Unknown SEQ (\"*\") needs a full scan through the CIGAR string.\n        static int query[16] = {\n          //M I D N  S H P =  X B ? ?  ? ? ? ?\n            1,1,0,0, 0,0,0,1, 1,0,0,0, 0,0,0,0\n        };\n        int k;\n        for (k = l = 0; k < n_cigar; k++)\n            if (query[bam_cigar_op(cigar[k])])\n                l += bam_cigar_oplen(cigar[k]);\n    }\n    return l;\n\n}\n\n// Without HTS_OPT3 gcc11 and earlier don't vectorize this, nor even\n// unroll it.  By adding HTS_OPT3 we can force a better level of optimization.\n// On an Illumina BAM with gcc11 -O2, with HTS_OPT3 is 9% quicker for the\n// entire process (ie decompress, iterator, aggregate & report)\nstatic inline void HTS_OPT3 incr_hist(int *hist, int oplen) {\n    const int N = 16;\n    int k;\n    for (k = 0; k < (oplen & ~(N-1)); k+=N) {\n        for (int i = 0; i < N; i++)\n            hist[k+i]++;\n    }\n    for (; k < oplen; k++)\n        hist[k]++;\n}\n\nstatic inline void HTS_OPT3\nincr_hist_qual(int *hist, uint8_t *qual, int min_qual, int oplen) {\n    if (!min_qual) {\n        incr_hist(hist, oplen);\n        return;\n    }\n\n    int k;\n    for (k = 0; k < (oplen & ~31); k+=32) {\n        int pass[32];\n        // Two separate loops helps clang to vectorize\n        for (int i = 0; i < 32; i++)\n            pass[i]=qual[k+i]>=min_qual;\n\n        for (int i = 0; i < 32; i++)\n            hist[k+i]+=pass[i];\n    }\n    for (; k < oplen; k++)\n        hist[k]+=qual[k]>=min_qual;\n}\n\n// Adds the depth for a single read to a depth_hist struct.\n// For just one file, this is easy.  We just have a circular buffer\n// where we increment values for bits that overlap existing data\n// and initialise values for coordinates which we're seeing for the first\n// time.  This is tracked by \"end_pos\" to know where we've got to.\n//\n// As the input is sorted, we can flush output from \"last_output\" to\n// b->core.pos.\n//\n// With multiple files, we must feed data in sorted order as if all files\n// are merged, but track depth per file.  This also means \"end_pos\" is per\n// file too, but \"last_output\" is global as it corresponds to rows printed.\nstatic int add_depth(depth_opt *opt, depth_hist *dh, sam_hdr_t *h, bam1_t *b,\n                     int overlap_clip, int file) {\n    hts_pos_t i;\n    size_t hmask = dh->size-1;\n    int n;\n\n    if (!b || b->core.tid != dh->last_ref) {\n        // New ref\n        if (dh->last_ref >= 0) {\n            // do end\n            size_t cur_l = dh->ks.l;\n            int nf = dh->nfiles;\n            i = dh->last_output;\n            for (i = dh->last_output; nf; i++) {\n                nf = 0;\n                for (n = 0; n < dh->nfiles; n++) {\n                    if (i < dh->end_pos[n])\n                        nf++;\n                }\n                if (!nf)\n                    break;\n\n                if (opt->bed && bed_overlap(opt->bed, dh->ref, i, i+1) == 0)\n                    continue;\n\n                dh->ks.l = cur_l;\n                kputll(i+1, &dh->ks);\n                for (n = 0; n < dh->nfiles; n++) {\n                    kputc_('\\t', &dh->ks);\n                    int d = i < dh->end_pos[n]\n                        ? dh->hist[n][i & hmask]\n                        : 0;\n                    kputuw(d, &dh->ks);\n                }\n                kputc('\\n', &dh->ks);\n                fputs(dh->ks.s, opt->out);\n            }\n            if (opt->all_pos) {\n                // End of last ref\n                zero_region(opt, dh,\n                            sam_hdr_tid2name(h, dh->last_ref),\n                            i, sam_hdr_tid2len(h, dh->last_ref));\n            }\n            dh->ks.l = cur_l;\n        }\n\n        if (opt->all_pos > 1 && !opt->reg) {\n            // Any previous unused refs\n            int lr = dh->last_ref < 0 ? 0 : dh->last_ref+1;\n            int rr = b ? b->core.tid : sam_hdr_nref(h), r;\n            for (r = lr; r < rr; r++)\n                zero_region(opt, dh,\n                            sam_hdr_tid2name(h, r),\n                            0, sam_hdr_tid2len(h, r));\n        }\n\n        if (!b) {\n            // we're just flushing to end of file\n            if (opt->all_pos && opt->reg && dh->last_ref < 0)\n                // -a or -aa without a single read being output yet\n                zero_region(opt, dh, sam_hdr_tid2name(h, dh->tid), dh->beg,\n                            MIN(dh->end, sam_hdr_tid2len(h, dh->tid)));\n\n            return 0;\n        }\n\n        for (n = 0; dh->end_pos && n < dh->nfiles; n++)\n            dh->end_pos[n] = 0;\n        dh->last_output = dh->beg >= 0\n            ? MAX(b->core.pos, dh->beg)\n            : b->core.pos;\n        dh->last_ref = b->core.tid;\n        dh->ref = sam_hdr_tid2name(h, b->core.tid);\n        kputs(dh->ref, ks_clear(&dh->ks));\n        kputc('\\t', &dh->ks);\n\n        if (opt->all_pos)\n            // Start of ref\n            zero_region(opt, dh, dh->ref, 0, b->core.pos);\n    } else {\n        if (dh->last_output < b->core.pos) {\n            // Flush any depth outputs up to start of new read\n            size_t cur_l = dh->ks.l;\n            int nf = dh->nfiles;\n            for (i = dh->last_output; i < b->core.pos; i++) {\n                nf = 0;\n                for (n = 0; n < dh->nfiles; n++) {\n                    if (i < dh->end_pos[n])\n                        nf++;\n                }\n                if (!nf)\n                    break;\n\n                if (opt->bed && bed_overlap(opt->bed, dh->ref, i, i+1) == 0)\n                    continue;\n\n                dh->ks.l = cur_l;\n                kputll(i+1, &dh->ks);\n                for (n = 0; n < dh->nfiles; n++) {\n                    kputc_('\\t', &dh->ks);\n                    int d = i < dh->end_pos[n]\n                        ? dh->hist[n][i & hmask]\n                        : 0;\n                    kputuw(d, &dh->ks);\n                }\n                kputc('\\n', &dh->ks);\n                fputs(dh->ks.s, opt->out);\n            }\n            if (opt->all_pos && i < b->core.pos)\n                // Hole in middle of ref\n                zero_region(opt, dh, dh->ref, i, b->core.pos);\n\n            dh->ks.l = cur_l;\n            dh->last_output = b->core.pos;\n        }\n    }\n\n    hts_pos_t end_pos = bam_endpos(b); // 0 based, 1 past end.\n    //printf(\"%d %d\\n\", (int)b->core.pos+1, (int)end_pos);\n\n    if (b->core.tid < dh->last_ref ||\n        (dh->last_ref == b->core.tid && end_pos < dh->last_output)) {\n        print_error_errno(\"depth\", \"Data is not position sorted\");\n        return -1;\n    }\n\n    // If needed, grow the circular buffer.\n    if (end_pos+1 - b->core.pos >= dh->size) {\n        size_t old_size = dh->size;\n        size_t old_hmask = hmask;\n        while (end_pos+1 - b->core.pos >= dh->size)\n            dh->size = dh->size ? 2*dh->size : 2048;\n        hmask = dh->size-1;\n        if (!dh->hist) {\n            dh->hist = calloc(dh->nfiles, sizeof(*dh->hist));\n            dh->end_pos = calloc(dh->nfiles, sizeof(*dh->end_pos));\n            if (!dh->hist || !dh->end_pos)\n                return -1;\n        }\n        for (n = 0; n < dh->nfiles; n++) {\n            int *hist = calloc(dh->size, sizeof(*dh->hist[n]));\n            if (!hist)\n                return -1;\n\n            // Simple approach for now; copy over old histogram verbatim.\n            for (i = dh->last_output; i < dh->last_output + old_size; i++)\n                hist[i & hmask] = dh->hist[n][i & old_hmask];\n            free(dh->hist[n]);\n            dh->hist[n] = hist;\n        }\n    }\n\n    // Accumulate depth, based on CIGAR\n    uint32_t *cig = bam_get_cigar(b);\n    int ncig = b->core.n_cigar, j, k, spos = 0;\n\n    // Zero new (previously unseen) coordinates so increment works later.\n    hts_pos_t end = MAX(dh->end_pos[file], b->core.pos);\n    if (end_pos > end && (end & hmask) < (end_pos & hmask)) {\n        memset(&dh->hist[file][end & hmask], 0,\n               sizeof(**dh->hist) * (end_pos - end));\n    } else {\n        for (i = end; i < end_pos; i++)\n            dh->hist[file][i & hmask] = 0;\n    }\n\n    i = b->core.pos;\n    uint8_t *qual = bam_get_qual(b);\n    int min_qual = opt->min_qual;\n    for (j = 0; j < ncig; j++) {\n        int op    = bam_cigar_op(cig[j]);\n        int oplen = bam_cigar_oplen(cig[j]);\n\n        switch (op) {\n        case BAM_CDEL:\n        case BAM_CREF_SKIP:\n            if (op != BAM_CDEL || opt->skip_del) {\n                // don't increment reference location\n                if (i + oplen >= dh->end_pos[file]) {\n                    for (k = 0; k < oplen; k++, i++) {\n                        if (i >= dh->end_pos[file])\n                            // redundant due to zero new elements above?\n                            dh->hist[file][i & hmask] = 0;\n                    }\n                } else {\n                    i += oplen;\n                }\n            } else { // op == BAM_CDEL and we count them (-J option),\n                // We don't incr spos here, but we still use qual.\n                // This doesn't make much sense, but it's for compatibility\n                // with the old code.  Arguably DEL shouldn't have a min\n                // qual and should always pass (as we've explicitly asked to\n                // include them).\n                int *hist = dh->hist[file];\n                k = 0;\n                if (overlap_clip) {\n                    if (i+oplen < overlap_clip) {\n                        i += oplen;\n                        break;\n                    } else if (i < overlap_clip) {\n                        k = overlap_clip - i;\n                        i = overlap_clip;\n                    }\n                }\n\n                // Question: should we even check quality values for DEL?\n                // We've explicitly asked to include them, and the quality\n                // is wrong anyway (it's the neighbouring base).  We do this\n                // for now for compatibility with the old depth command.\n                if (spos < b->core.l_qseq)\n                    for (; k < oplen; k++, i++)\n                        hist[i & hmask]+=qual[spos]>=min_qual;\n                else\n                    for (; k < oplen; k++, i++)\n                        hist[i & hmask]++;\n            }\n            break;\n\n        case BAM_CMATCH:\n        case BAM_CEQUAL:\n        case BAM_CDIFF: {\n            int *hist = dh->hist[file];\n            k = 0;\n            if (overlap_clip) {\n                if (i+oplen < overlap_clip) {\n                    i += oplen;\n                    break;\n                } else if (i < overlap_clip) {\n                    oplen -= overlap_clip - i;\n                    spos += overlap_clip - i;\n                    i = overlap_clip;\n                }\n            }\n\n            int len = (i & hmask) < ((i+oplen) & hmask)\n                ? oplen                  // doesn't wrap around\n                : dh->size - (i&hmask);  // does wrap around\n            incr_hist_qual(&hist[i & hmask], &qual[spos], min_qual, len);\n            if (oplen > len)\n                incr_hist_qual(hist, &qual[spos+len], min_qual, oplen-len);\n            spos += oplen;\n            i += oplen;\n            break;\n        }\n\n        case BAM_CINS:\n        case BAM_CSOFT_CLIP:\n            spos += oplen;\n            break;\n\n        case BAM_CPAD:\n        case BAM_CHARD_CLIP:\n            // ignore\n            break;\n\n        default:\n            print_error(\"depth\", \"Unsupported cigar op '%d'\", op);\n            return -1;\n        }\n    }\n\n    if (dh->end >= 0 && end_pos > dh->end)\n        end_pos = dh->end;\n    if (dh->end_pos[file] < end_pos)\n        dh->end_pos[file] = end_pos;\n\n    return 0;\n}\n\n// Hash on name -> alignment end pos. This permits a naive overlap removal.\n// Note it cannot analyse the overlapping sequence and qualities, so the\n// interaction of basecalls/qualities and the -Q parameter cannot be\n// applied here (unlike the full mpileup algorithm).\nKHASH_MAP_INIT_STR(olap_hash, hts_pos_t)\ntypedef khash_t(olap_hash) olap_hash_t;\n\nstatic int fastdepth_core(depth_opt *opt, uint32_t nfiles, char **fn,\n                          samFile **fp, hts_itr_t **itr, sam_hdr_t **h) {\n    int ret = -1, err = 1, i;\n    olap_hash_t **overlaps = NULL;\n    depth_hist dh = {0};\n\n    // An array of bam structs, one per input file, to hold the next entry\n    bam1_t **b = calloc(nfiles, sizeof(*b));\n    int *finished = calloc(nfiles, sizeof(*finished)), to_go = nfiles;\n    if (!b || !finished)\n        goto err;\n\n    for (i = 0; i < nfiles; i++)\n        if (!(b[i] = bam_init1()))\n            goto err;\n\n    // Do we need one overlap hash per file? Or shared?\n    if (opt->remove_overlaps) {\n        if (!(overlaps = calloc(nfiles, sizeof(*overlaps))))\n            return -1;\n        for (i = 0; i < nfiles; i++) {\n            if (!(overlaps[i] = kh_init(olap_hash)))\n                return -1;\n        }\n    }\n\n    // Create the initial histogram\n    dh.nfiles = nfiles;\n    dh.size = 0;\n    dh.hist = NULL;\n    dh.last_ref = -99;\n    dh.end_pos = NULL;\n    dh.last_output = itr && itr[0] ? itr[0]->beg : 0;\n    ks_initialize(&dh.ks);\n\n    // Clip results to region if specified\n    dh.beg = -1;\n    dh.end = -1;\n    dh.tid = 0;\n    if (itr && itr[0]) {\n        dh.tid = itr[0]->tid;\n        dh.beg = itr[0]->beg;\n        dh.end = itr[0]->end;\n    }\n\n    if (opt->header) {\n        fprintf(opt->out, \"#CHROM\\tPOS\");\n        for (i = 0; i < nfiles; i++)\n            fprintf(opt->out, \"\\t%s\", fn[i]);\n        fputc('\\n', opt->out);\n    }\n\n    // Populate first record per file\n    for (i = 0; i < nfiles; i++) {\n        for(;;) {\n            ret = itr && itr[i]\n                ? sam_itr_next(fp[i], itr[i], b[i])\n                : sam_read1(fp[i], h[i], b[i]);\n            if (ret < -1)\n                goto err;\n            if (ret == -1) {\n                to_go--;\n                finished[i] = 1;\n                break;\n            }\n\n            if (b[i]->core.tid < 0)\n                continue;\n            if (b[i]->core.flag & opt->flag)\n                continue; // must have none of the flags set\n            if (opt->incl_flag && (b[i]->core.flag & opt->incl_flag) == 0)\n                continue; // must have at least one flag set\n            if ((b[i]->core.flag & opt->require_flag) != opt->require_flag)\n                continue; // must have all lags set\n            if (b[i]->core.qual < opt->min_mqual)\n                continue;\n\n            // Original samtools depth used the total sequence (l_qseq)\n            // including soft-clips.  This doesn't feel like a useful metric\n            // to be filtering on.  We now only count sequence bases that\n            // form the used part of the alignment.\n            if (opt->min_len) {\n                if (qlen_used(b[i]) < opt->min_len)\n                    continue;\n            }\n\n            break;\n        }\n    }\n\n    // Loop through input files, merging in order so we're\n    // always adding the next record in sequence\n    while (to_go) {\n        // Find next record in file list\n        int best_tid = INT_MAX, best_file = 0;\n        hts_pos_t best_pos = HTS_POS_MAX;\n\n        for (i = 0; i < nfiles; i++) {\n            if (finished[i])\n                continue;\n            if (best_tid > b[i]->core.tid) {\n                best_tid = b[i]->core.tid;\n                best_pos = b[i]->core.pos;\n                best_file = i;\n            } else if (best_tid == b[i]->core.tid &&\n                       best_pos > b[i]->core.pos) {\n                best_pos = b[i]->core.pos;\n                best_file = i;\n            }\n        }\n        i = best_file;\n\n        hts_pos_t clip = 0;\n        if (overlaps && (b[i]->core.flag & BAM_FPAIRED) &&\n            !(b[i]->core.flag & BAM_FMUNMAP)) {\n            khiter_t k = kh_get(olap_hash, overlaps[i], bam_get_qname(b[i]));\n            if (k == kh_end(overlaps[i])) {\n                // not seen before\n                hts_pos_t endpos = bam_endpos(b[i]);\n\n                // Don't add if mate location is known and can't overlap.\n                if (b[i]->core.mpos == -1 ||\n                    (b[i]->core.tid == b[i]->core.mtid &&\n                     b[i]->core.mpos <= endpos)) {\n                    k = kh_put(olap_hash, overlaps[i], bam_get_qname(b[i]),\n                               &ret);\n                    if (ret < 0)\n                        return -1;\n                    kh_key(overlaps[i], k) = strdup(bam_get_qname(b[i]));\n                    kh_value(overlaps[i], k) = endpos;\n                }\n            } else {\n                // seen before\n                clip = kh_value(overlaps[i], k);\n                free((char *)kh_key(overlaps[i], k));\n                kh_del(olap_hash, overlaps[i], k);\n            }\n        }\n\n        // Add the next merged BAM record to the depth plot\n        if ((ret = add_depth(opt, &dh, h[i], b[i], clip, i)) < 0) {\n            ret = -1;\n            goto err;\n        }\n\n        // Populate next record from this file\n        for(;!finished[i];) {\n            ret = itr && itr[i]\n                ? sam_itr_next(fp[i], itr[i], b[i])\n                : sam_read1(fp[i], h[i], b[i]);\n            if (ret < -1) {\n                ret = -1;\n                goto err;\n            }\n            if (ret == -1) {\n                to_go--;\n                finished[i] = 1;\n                break;\n            }\n\n            if (b[i]->core.tid < 0)\n                continue;\n            if (b[i]->core.flag & opt->flag)\n                continue; // must have none of the flags set\n            if (opt->incl_flag && (b[i]->core.flag & opt->incl_flag) == 0)\n                continue; // must have at least one flag set\n            if ((b[i]->core.flag & opt->require_flag) != opt->require_flag)\n                continue; // must have all lags set\n            if (b[i]->core.qual < opt->min_mqual)\n                continue;\n\n            if (opt->min_len) {\n                if (qlen_used(b[i]) < opt->min_len)\n                    continue;\n            }\n\n            break;\n        }\n    }\n\n    // Tidy up end.\n    ret = add_depth(opt, &dh, h[0], NULL, 0, 0);\n    err = 0;\n\n err:\n    if (ret == 0 && err)\n        ret = -1;\n\n    for (i = 0; i < nfiles; i++) {\n        if (b[i])\n            bam_destroy1(b[i]);\n        if (dh.hist && dh.hist[i])\n            free(dh.hist[i]);\n    }\n    free(b);\n    free(finished);\n    ks_free(&dh.ks);\n    free(dh.hist);\n    free(dh.end_pos);\n    if (overlaps) {\n        khiter_t k;\n        for (i = 0; i < nfiles; i++) {\n            if (!overlaps[i])\n                continue;\n            for (k = kh_begin(overlaps[i]); k < kh_end(overlaps[i]); k++)\n                if (kh_exist(overlaps[i], k))\n                    free((char *)kh_key(overlaps[i], k));\n            kh_destroy(olap_hash, overlaps[i]);\n        }\n        free(overlaps);\n    }\n\n    return ret;\n}\n\nstatic void usage_exit(FILE *fp, int exit_status)\n{\n    fprintf(fp, \"Usage: samtools depth [options] in.bam [in.bam ...]\\n\");\n    fprintf(fp, \"\\nOptions:\\n\");\n    fprintf(fp, \"  -a           Output all positions (including zero depth)\\n\");\n    fprintf(fp, \"  -a -a, -aa   Output absolutely all positions, including unused ref seqs\\n\");\n    fprintf(fp, \"  -r REG       Specify a region in chr or chr:from-to syntax\\n\");\n    fprintf(fp, \"  -b FILE      Use bed FILE for list of regions\\n\");\n    fprintf(fp, \"  -f FILE      Specify list of input BAM/SAM/CRAM filenames\\n\");\n    fprintf(fp, \"  -X           Use custom index files (in -X *.bam *.bam.bai order)\\n\");\n    fprintf(fp, \"  -g INT       Remove specified flags from default filter-out flag list\\n\");\n    fprintf(fp, \"  -G, --excl-flags FLAGS\\n\");\n    fprintf(fp, \"               Add specified flags to the  default filter-out flag list\\n\");\n    fprintf(fp, \"               [UNMAP,SECONDARY,QCFAIL,DUP]\\n\");\n    fprintf(fp, \"      --incl-flags FLAGS\\n\");\n    fprintf(fp, \"               Only include records with at least one the FLAGs present [0]\\n\");\n    fprintf(fp, \"      --require-flags FLAGS\\n\");\n    fprintf(fp, \"               Only include records with all of the FLAGs present [0]\\n\");\n    fprintf(fp, \"  -H           Print a file header line\\n\");\n    fprintf(fp, \"  -l INT       Minimum read length [0]\\n\");\n    fprintf(fp, \"  -o FILE      Write output to FILE [stdout]\\n\");\n    fprintf(fp, \"  -q, --min-BQ INT\\n\"\n                \"               Filter bases with base quality smaller than INT [0]\\n\");\n    fprintf(fp, \"  -Q, --min-MQ INT\\n\"\n                \"               Filter alignments with mapping quality smaller than INT [0]\\n\");\n    fprintf(fp, \"  -J           Include reads with deletions in depth computation\\n\");\n    fprintf(fp, \"  -s           Do not count overlapping reads within a template\\n\");\n    sam_global_opt_help(fp, \"-.--.@-.\");\n    exit(exit_status);\n}\n\nint main_depth(int argc, char *argv[])\n{\n    int nfiles, i, tmp_flag;\n    samFile **fp;\n    sam_hdr_t **header;\n    int c, has_index_file = 0;\n    char *file_list = NULL, **fn = NULL;\n    char *out_file = NULL;\n    depth_opt opt = {\n        .flag = BAM_FUNMAP | BAM_FSECONDARY | BAM_FDUP | BAM_FQCFAIL,\n        .incl_flag = 0,\n        .require_flag = 0,\n        .min_qual = 0,\n        .min_mqual = 0,\n        .skip_del = 1,\n        .header = 0,\n        .min_len = 0,\n        .out = stdout,\n        .all_pos = 0,\n        .remove_overlaps = 0,\n        .reg = NULL,\n        .bed = NULL,\n    };\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        {\"min-MQ\",        required_argument, NULL, 'Q'},\n        {\"min-mq\",        required_argument, NULL, 'Q'},\n        {\"min-BQ\",        required_argument, NULL, 'q'},\n        {\"min-bq\",        required_argument, NULL, 'q'},\n        {\"excl-flags\",    required_argument, NULL, 'G'},\n        {\"incl-flags\",    required_argument, NULL, 1},\n        {\"require-flags\", required_argument, NULL, 2},\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 0, '@'),\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"@:q:Q:JHd:m:l:g:G:o:ar:Xf:b:s\",\n                            lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'a':\n            opt.all_pos++;\n            break;\n\n        case 'b':\n            opt.bed = bed_read(optarg);\n            if (!opt.bed) {\n                print_error_errno(\"depth\", \"Could not read file \\\"%s\\\"\",\n                                  optarg);\n                return 1;\n            }\n            break;\n\n        case 'f':\n            file_list = optarg;\n            break;\n\n        case 'd':\n        case 'm':\n            // depth limit - now ignored\n            break;\n\n        case 'g':\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"depth\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            opt.flag &= ~tmp_flag;\n            break;\n        case 'G': // reject if any set\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"depth\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            opt.flag |= tmp_flag;\n            break;\n        case 1: // reject unless at least one set (0 means ignore option)\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"depth\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            opt.incl_flag |= tmp_flag;\n            break;\n        case 2: // reject unless all set\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"depth\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            opt.require_flag |= tmp_flag;\n            break;\n\n        case 'l':\n            opt.min_len = atoi(optarg);\n            break;\n\n        case 'H':\n            opt.header = 1;\n            break;\n\n        case 'q':\n            opt.min_qual = atoi(optarg);\n            break;\n        case 'Q':\n            opt.min_mqual = atoi(optarg);\n            break;\n\n        case 'J':\n            opt.skip_del = 0;\n            break;\n\n        case 'o':\n            if (opt.out != stdout)\n                break;\n            opt.out = fopen(out_file = optarg, \"w\");\n            if (!opt.out) {\n                print_error_errno(\"depth\", \"Cannot open \\\"%s\\\" for writing.\",\n                                  optarg);\n                return EXIT_FAILURE;\n            }\n            break;\n\n        case 'r':\n            opt.reg = optarg;\n            break;\n\n        case 's':\n            opt.remove_overlaps = 1;\n            break;\n\n        case 'X':\n            has_index_file = 1;\n            break;\n\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?':\n            usage_exit(stderr, EXIT_FAILURE);\n        }\n    }\n\n    if (argc < optind+1 && !file_list) {\n        if (argc == optind)\n            usage_exit(stdout, EXIT_SUCCESS);\n        else\n            usage_exit(stderr, EXIT_FAILURE);\n    }\n\n    if (file_list) {\n        if (has_index_file) {\n            print_error(\"depth\", \"The -f option cannot be combined with -X\");\n            return 1;\n        }\n        if (read_file_list(file_list, &nfiles, &fn))\n            return 1;\n        argv = fn;\n        argc = nfiles;\n        optind = 0;\n    } else {\n        nfiles = argc - optind;\n    }\n\n    if (has_index_file) {\n        if (nfiles%1) {\n            print_error(\"depth\", \"-X needs one index specified per bam file\");\n            return 1;\n        }\n        nfiles /= 2;\n    }\n    fp = malloc(nfiles * sizeof(*fp));\n    header = malloc(nfiles * sizeof(*header));\n    if (!fp || !header) {\n        print_error_errno(\"depth\", \"Out of memory\");\n        return 1;\n    }\n\n    hts_itr_t **itr = NULL;\n    if (opt.reg) {\n        itr = calloc(nfiles, sizeof(*itr));\n        if (!itr)\n            return 1;\n    }\n\n    for (i = 0; i < nfiles; i++, optind++) {\n        fp[i] = sam_open_format(argv[optind], \"r\", &ga.in);\n        if (fp[i] == NULL) {\n            print_error_errno(\"depth\",\n                              \"Cannot open input file \\\"%s\\\"\", argv[optind]);\n            return 1;\n        }\n\n        if (ga.nthreads > 0)\n            hts_set_threads(fp[i], ga.nthreads);\n\n        if (hts_set_opt(fp[i], CRAM_OPT_REQUIRED_FIELDS,\n                        SAM_FLAG | SAM_RNAME | SAM_POS | SAM_CIGAR\n                        | (opt.remove_overlaps ? SAM_QNAME|SAM_RNEXT|SAM_PNEXT\n                                               : 0)\n                        | (opt.min_mqual       ? SAM_MAPQ  : 0)\n                        | (opt.min_len         ? SAM_SEQ   : 0)\n                        | (opt.min_qual        ? SAM_QUAL  : 0))) {\n            fprintf(stderr, \"Failed to set CRAM_OPT_REQUIRED_FIELDS value\\n\");\n            return 1;\n        }\n\n        if (hts_set_opt(fp[i], CRAM_OPT_DECODE_MD, 0)) {\n            fprintf(stderr, \"Failed to set CRAM_OPT_DECODE_MD value\\n\");\n            return 1;\n        }\n\n        // FIXME: what if headers differ?\n        header[i] = sam_hdr_read(fp[i]);\n        if (header == NULL) {\n            fprintf(stderr, \"Failed to read header for \\\"%s\\\"\\n\",\n                    argv[optind]);\n            return 1;\n        }\n\n        if (opt.reg) {\n            hts_idx_t *idx = has_index_file\n                ? sam_index_load2(fp[i], argv[optind], argv[optind+nfiles])\n                : sam_index_load(fp[i], argv[optind]);\n            if (!idx) {\n                print_error(\"depth\", \"cannot load index for \\\"%s\\\"\",\n                            argv[optind]);\n                return 1;\n            }\n            if (!(itr[i] = sam_itr_querys(idx, header[i], opt.reg))) {\n                print_error(\"depth\", \"cannot parse region \\\"%s\\\"\", opt.reg);\n                return 1;\n            }\n            hts_idx_destroy(idx);\n        }\n    }\n\n    int ret = fastdepth_core(&opt, nfiles, &argv[argc-nfiles], fp, itr, header)\n        ? 1 : 0;\n\n    for (i = 0; i < nfiles; i++) {\n        sam_hdr_destroy(header[i]);\n        sam_close(fp[i]);\n        if (itr && itr[i])\n            hts_itr_destroy(itr[i]);\n    }\n    free(header);\n    free(fp);\n    free(itr);\n    if (file_list) {\n        for (i=0; i<nfiles; i++)\n            free(fn[i]);\n        free(fn);\n    }\n    if (opt.bed)\n        bed_destroy(opt.bed);\n    sam_global_args_free(&ga);\n    if (opt.out != stdout) {\n        if (fclose(opt.out) != 0 && ret == 0) {\n            print_error_errno(\"depth\", \"error on closing \\\"%s\\\"\", out_file);\n            ret = 1;\n        }\n    }\n\n    return ret;\n}\n\n#ifdef _MAIN_BAM2DEPTH\nint main(int argc, char *argv[])\n{\n    return main_depth(argc, argv);\n}\n#endif\n"
        },
        {
          "name": "bam_addrprg.c",
          "type": "blob",
          "size": 15.5458984375,
          "content": "/* bam_addrprg.c -- samtools command to add or replace readgroups.\n\n   Copyright (c) 2013, 2015-2017, 2019-2021 Genome Research Limited.\n\n   Author: Martin O. Pollard <mp15@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <htslib/sam.h>\n#include <htslib/kstring.h>\n#include \"samtools.h\"\n#include \"htslib/thread_pool.h\"\n#include \"sam_opts.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <assert.h>\n#include <unistd.h>\n\ntypedef enum {\n    overwrite_all,\n    orphan_only,\n} rg_mode;\n\nstruct parsed_opts {\n    char* input_name;\n    char* output_name;\n    char* rg_id;\n    char* rg_line;\n    int no_pg;\n    rg_mode mode;\n    sam_global_args ga;\n    htsThreadPool p;\n    int uncompressed;\n    int overwrite_hdr_rg;\n};\n\nstruct state;\ntypedef struct parsed_opts parsed_opts_t;\ntypedef struct state state_t;\n\nstruct state {\n    samFile* input_file;\n    sam_hdr_t* input_header;\n    samFile* output_file;\n    sam_hdr_t* output_header;\n    char* rg_id;\n    void (*mode_func)(const state_t*, bam1_t*);\n};\n\nstatic void cleanup_opts(parsed_opts_t* opts)\n{\n    if (!opts) return;\n    free(opts->rg_id);\n    free(opts->output_name);\n    free(opts->input_name);\n    free(opts->rg_line);\n    if (opts->p.pool) hts_tpool_destroy(opts->p.pool);\n    sam_global_args_free(&opts->ga);\n    free(opts);\n}\n\nstatic void cleanup_state(state_t* state)\n{\n    if (!state) return;\n    free(state->rg_id);\n    if (state->output_file) sam_close(state->output_file);\n    sam_hdr_destroy(state->output_header);\n    if (state->input_file) sam_close(state->input_file);\n    sam_hdr_destroy(state->input_header);\n    free(state);\n}\n\n// Converts \\t and \\n into real tabs and newlines\nstatic char* basic_unescape(const char* in)\n{\n    assert(in);\n    char *ptr, *out;\n    out = ptr = malloc(strlen(in)+1);\n    size_t size = 0;\n    while (*in) {\n        if (*in == '\\\\') {\n            ++in;\n            if (*in == '\\0') {\n                fprintf(stderr, \"[%s] Unterminated escape sequence.\\n\", __func__);\n                free(out);\n                return NULL;\n            }\n            switch (*in) {\n            case '\\\\':\n                *ptr = '\\\\';\n                break;\n            case 't':\n                *ptr = '\\t';\n                break;\n            case 'n':\n                fprintf(stderr, \"[%s] \\\\n in escape sequence is not supported.\\n\", __func__);\n                free(out);\n                return NULL;\n            default:\n                fprintf(stderr, \"[%s] Unsupported escape sequence.\\n\", __func__);\n                free(out);\n                return NULL;\n            }\n        } else {\n            *ptr = *in;\n        }\n        ++in;\n        ++ptr;\n        ++size;\n    }\n    *ptr = '\\0';\n    ++size;\n    char* tmp = (char*)realloc(out, size);\n    if (!tmp) {\n        free(out);\n    }\n    return tmp;\n}\n\n// Malloc a string containing [s,slim) or to the end of s if slim is NULL.\n// If lenp is non-NULL, stores the length of the resulting string there.\nstatic char *dup_substring(const char *s, const char *slim, size_t *lenp)\n{\n    size_t len = slim? (slim - s) : strlen(s);\n    char *ns = malloc(len+1);\n    if (ns == NULL) return NULL;\n    memcpy(ns, s, len);\n    ns[len] = '\\0';\n    if (lenp) *lenp = len;\n    return ns;\n}\n\n\n// Given a @RG line return the id\nstatic char* get_rg_id(const char *line)\n{\n    const char *id = strstr(line, \"\\tID:\");\n    if (! id) return NULL;\n\n    id += 4;\n    return dup_substring(id, strchr(id, '\\t'), NULL);\n}\n\n\nstatic void usage(FILE *fp)\n{\n    fprintf(fp,\n            \"Usage: samtools addreplacerg [options] [-r <@RG line> | -R <existing id>] [-m orphan_only|overwrite_all] [-o <output.bam>] <input.bam>\\n\"\n            \"\\n\"\n            \"Options:\\n\"\n            \"  -m MODE   Set the mode of operation from one of overwrite_all, orphan_only [overwrite_all]\\n\"\n            \"  -o FILE   Where to write output to [stdout]\\n\"\n            \"  -r STRING @RG line text\\n\"\n            \"  -R STRING ID of @RG line in existing header to use\\n\"\n            \"  -u        Output uncompressed data\\n\"\n            \"  -w        Overwrite an existing @RG line\\n\"\n            \"  --no-PG   Do not add a PG line\\n\"\n            );\n    sam_global_opt_help(fp, \"..O..@..\");\n}\n\nstatic bool parse_args(int argc, char** argv, parsed_opts_t** opts)\n{\n    *opts = NULL;\n    int n;\n\n    if (argc == 1) { usage(stdout); return true; }\n\n    parsed_opts_t* retval = calloc(1, sizeof(parsed_opts_t));\n    if (! retval ) {\n        fprintf(stderr, \"[%s] Out of memory allocating parsed_opts_t\\n\", __func__);\n        return false;\n    }\n    // Set defaults\n    retval->mode = overwrite_all;\n    sam_global_args_init(&retval->ga);\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS(0, 0, 'O', 0, 0, '@'),\n        {\"no-PG\", no_argument, NULL, 1},\n        { NULL, 0, NULL, 0 }\n    };\n    kstring_t rg_line = {0,0,NULL};\n\n    while ((n = getopt_long(argc, argv, \"r:R:m:o:O:h@:uw\", lopts, NULL)) >= 0) {\n        switch (n) {\n            case 'r':\n                // Are we adding to existing rg line?\n                if (ks_len(&rg_line) == 0) {\n                    if (strlen(optarg)<3 || (optarg[0] != '@' && optarg[1] != 'R' && optarg[2] != 'G')) {\n                        kputs(\"@RG\\t\", &rg_line);\n                    }\n                } else {\n                    kputs(\"\\t\", &rg_line);\n                }\n                kputs(optarg, &rg_line);\n                break;\n            case 'R':\n                retval->rg_id = strdup(optarg);\n                break;\n            case 'm': {\n                if (strcmp(optarg, \"overwrite_all\") == 0) {\n                    retval->mode = overwrite_all;\n                } else if (strcmp(optarg, \"orphan_only\") == 0) {\n                    retval->mode = orphan_only;\n                } else {\n                    usage(stderr);\n                    return false;\n                }\n                break;\n            }\n            case 'o':\n                retval->output_name = strdup(optarg);\n                break;\n            case 'h':\n                usage(stdout);\n                free(retval);\n                return true;\n            case 1:\n                retval->no_pg = 1;\n                break;\n            case 'u':\n                retval->uncompressed = 1;\n                break;\n            case 'w':\n                retval->overwrite_hdr_rg = 1;\n                break;\n            case '?':\n                usage(stderr);\n                free(retval);\n                return false;\n            case 'O':\n            default:\n                if (parse_sam_global_opt(n, optarg, lopts, &retval->ga) == 0) break;\n                usage(stderr);\n                free(retval);\n                return false;\n        }\n    }\n    retval->rg_line = ks_release(&rg_line);\n\n    if (argc-optind < 1) {\n        fprintf(stderr, \"You must specify an input file.\\n\");\n        usage(stderr);\n        cleanup_opts(retval);\n        return false;\n    }\n    if (retval->rg_id && retval->rg_line) {\n        fprintf(stderr, \"The options -r and -R are mutually exclusive.\\n\");\n        cleanup_opts(retval);\n        return false;\n    }\n\n    if (retval->rg_line)\n    {\n        char* tmp = basic_unescape(retval->rg_line);\n\n        if ((retval->rg_id = get_rg_id(tmp)) == NULL) {\n            fprintf(stderr, \"[%s] The supplied RG line lacks an ID tag.\\n\", __func__);\n            free(tmp);\n            cleanup_opts(retval);\n            return false;\n        }\n        free(retval->rg_line);\n        retval->rg_line = tmp;\n    }\n    retval->input_name = strdup(argv[optind+0]);\n\n    if (retval->ga.nthreads > 0) {\n        if (!(retval->p.pool = hts_tpool_init(retval->ga.nthreads))) {\n            fprintf(stderr, \"Error creating thread pool\\n\");\n            return false;\n        }\n    }\n\n    *opts = retval;\n    return true;\n}\n\nstatic void overwrite_all_func(const state_t* state, bam1_t* file_read)\n{\n    uint8_t* data = (uint8_t*)strdup(state->rg_id);\n    int len = strlen(state->rg_id)+1;\n    // If the old exists delete it\n    uint8_t* old = bam_aux_get(file_read, \"RG\");\n    if (old != NULL) {\n        bam_aux_del(file_read, old);\n    }\n\n    bam_aux_append(file_read, \"RG\", 'Z', len, data);\n    free(data);\n}\n\nstatic void orphan_only_func(const state_t* state, bam1_t* file_read)\n{\n    uint8_t* data = (uint8_t*)strdup(state->rg_id);\n    int len = strlen(state->rg_id)+1;\n    // If the old exists don't do anything\n    uint8_t* old = bam_aux_get(file_read, \"RG\");\n    if (old == NULL) {\n        bam_aux_append(file_read, \"RG\",'Z',len,data);\n    }\n    free(data);\n}\n\nstatic bool init(const parsed_opts_t* opts, state_t** state_out) {\n    char output_mode[9] = \"w\";\n    state_t* retval = (state_t*) calloc(1, sizeof(state_t));\n\n    if (retval == NULL) {\n        fprintf(stderr, \"[init] Out of memory allocating state struct.\\n\");\n        return false;\n    }\n    *state_out = retval;\n\n    // Open files\n    retval->input_file = sam_open_format(opts->input_name, \"r\", &opts->ga.in);\n    if (retval->input_file == NULL) {\n        print_error_errno(\"addreplacerg\", \"could not open \\\"%s\\\"\", opts->input_name);\n        return false;\n    }\n    retval->input_header = sam_hdr_read(retval->input_file);\n\n    retval->output_header = sam_hdr_dup(retval->input_header);\n\n    if (opts->uncompressed)\n        strcat(output_mode, \"0\");\n    if (opts->output_name) // File format auto-detection\n        sam_open_mode(output_mode + strlen(output_mode),\n                      opts->output_name, NULL);\n    retval->output_file = sam_open_format(opts->output_name == NULL?\"-\":opts->output_name, output_mode, &opts->ga.out);\n\n    if (retval->output_file == NULL) {\n        print_error_errno(\"addreplacerg\", \"could not create \\\"%s\\\"\", opts->output_name);\n        return false;\n    }\n\n    if (opts->p.pool) {\n        hts_set_opt(retval->input_file,  HTS_OPT_THREAD_POOL, &opts->p);\n        hts_set_opt(retval->output_file, HTS_OPT_THREAD_POOL, &opts->p);\n    }\n\n    if (opts->rg_line) {\n        // Append new RG line to header.\n        // Check does not already exist\n        kstring_t hdr_line = { 0, 0, NULL };\n        if (sam_hdr_find_line_id(retval->output_header, \"RG\", \"ID\", opts->rg_id, &hdr_line) == 0) {\n            if (opts->overwrite_hdr_rg) {\n                if(-1 == sam_hdr_remove_line_id(retval->output_header, \"RG\", \"ID\", opts->rg_id)) {\n                    fprintf(stderr, \"[init] Error removing the RG line with ID:%s from the output header.\\n\", opts->rg_id);\n                    ks_free(&hdr_line);\n                    return false;\n                }\n            } else {\n                fprintf(stderr, \"[init] RG line with ID:%s already present in the header. Use -w to overwrite.\\n\", opts->rg_id);\n                ks_free(&hdr_line);\n                return false;\n            }\n        }\n        ks_free(&hdr_line);\n\n        if (-1 == sam_hdr_add_lines(retval->output_header, opts->rg_line, strlen(opts->rg_line))) {\n            fprintf(stderr, \"[init] Error adding RG line with ID:%s to the output header.\\n\", opts->rg_id);\n            return false;\n        }\n        if (opts->mode == overwrite_all &&\n            -1 == sam_hdr_remove_except(retval->output_header, \"RG\", \"ID\", opts->rg_id)) {\n            fprintf(stderr, \"[init] Error removing the old RG lines from the output header.\\n\");\n            return false;\n        }\n        retval->rg_id = strdup(opts->rg_id);\n    } else {\n        if (opts->rg_id) {\n            // Confirm what has been supplied exists\n            kstring_t hdr_line = { 0, 0, NULL };\n            if (sam_hdr_find_line_id(retval->output_header, \"RG\", \"ID\", opts->rg_id, &hdr_line) < 0) {\n                fprintf(stderr, \"RG ID supplied does not exist in header. Supply full @RG line with -r instead?\\n\");\n                return false;\n            }\n            retval->rg_id = strdup(opts->rg_id);\n            ks_free(&hdr_line);\n        } else {\n            kstring_t rg_id = { 0, 0, NULL };\n            if (sam_hdr_find_tag_id(retval->output_header, \"RG\", NULL, NULL, \"ID\", &rg_id) < 0) {\n                fprintf(stderr, \"No RG specified on command line or in existing header.\\n\");\n                return false;\n            }\n            retval->rg_id = ks_release(&rg_id);\n        }\n    }\n\n    switch (opts->mode) {\n        case overwrite_all:\n            retval->mode_func = &overwrite_all_func;\n            break;\n        case orphan_only:\n            retval->mode_func = &orphan_only_func;\n            break;\n    }\n\n    return true;\n}\n\nstatic bool readgroupise(parsed_opts_t *opts, state_t* state, char *arg_list)\n{\n    if (!opts->no_pg && sam_hdr_add_pg(state->output_header, \"samtools\",\n                                       \"VN\", samtools_version(),\n                                       arg_list ? \"CL\": NULL,\n                                       arg_list ? arg_list : NULL,\n                                       NULL))\n        return false;\n\n    if (sam_hdr_write(state->output_file, state->output_header) != 0) {\n        print_error_errno(\"addreplacerg\", \"[%s] Could not write header to output file\", __func__);\n        return false;\n    }\n    char *idx_fn = NULL;\n    if (opts->ga.write_index) {\n        if (!(idx_fn = auto_index(state->output_file, opts->output_name, state->output_header)))\n            return false;\n    }\n\n    bam1_t* file_read = bam_init1();\n    int ret;\n    while ((ret = sam_read1(state->input_file, state->input_header, file_read)) >= 0) {\n        state->mode_func(state, file_read);\n\n        if (sam_write1(state->output_file, state->output_header, file_read) < 0) {\n            print_error_errno(\"addreplacerg\", \"[%s] Could not write read to output file\", __func__);\n            bam_destroy1(file_read);\n            free(idx_fn);\n            return false;\n        }\n    }\n    bam_destroy1(file_read);\n    if (ret != -1) {\n        print_error_errno(\"addreplacerg\", \"[%s] Error reading from input file\", __func__);\n        free(idx_fn);\n        return false;\n    } else {\n\n        if (opts->ga.write_index) {\n            if (sam_idx_save(state->output_file) < 0) {\n                print_error_errno(\"addreplacerg\", \"[%s] Writing index failed\", __func__);\n                free(idx_fn);\n                return false;\n            }\n        }\n        free(idx_fn);\n        return true;\n    }\n}\n\nint main_addreplacerg(int argc, char** argv)\n{\n    parsed_opts_t* opts = NULL;\n    state_t* state = NULL;\n    char *arg_list = stringify_argv(argc+1, argv-1);\n    if (!arg_list)\n        return EXIT_FAILURE;\n\n    if (!parse_args(argc, argv, &opts)) goto error;\n    if (opts) { // Not an error but user doesn't want us to proceed\n        if (!init(opts, &state) || !readgroupise(opts, state, arg_list))\n            goto error;\n    }\n\n    cleanup_state(state);\n    cleanup_opts(opts);\n    free(arg_list);\n\n    return EXIT_SUCCESS;\nerror:\n    cleanup_state(state);\n    cleanup_opts(opts);\n    free(arg_list);\n\n    return EXIT_FAILURE;\n}\n"
        },
        {
          "name": "bam_ampliconclip.c",
          "type": "blob",
          "size": 39.130859375,
          "content": "/*  bam_ampliconclip.c -- loads amplicon primers from a BED file and cuts reads\n                          from the 5' end.\n\n    Copyright (C) 2020-2024 Genome Research Ltd.\n\n    Authors: Andrew Whitwham <aw7@sanger.ac.uk>\n             Rob Davies <rmd+git@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE\n*/\n\n#include <config.h>\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"htslib/thread_pool.h\"\n#include \"sam_opts.h\"\n#include <htslib/hts.h>\n#include \"htslib/hfile.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/sam.h\"\n#include \"samtools.h\"\n#include \"bam_ampliconclip.h\"\n\ntypedef enum {\n    soft_clip,\n    hard_clip\n} clipping_type;\n\ntypedef struct {\n    int add_pg;\n    int use_strand;\n    int write_clipped;\n    int mark_fail;\n    int both;\n    int fail_len;\n    int filter_len;\n    int unmapped;\n    int oa_tag;\n    int del_tag;\n    int tol;\n    int unmap_len;\n    char *arg_list;\n    char *stats_file;\n    char *primer_counts_file;\n    char *rejects_file;\n} cl_param_t;\n\n\nstatic int bed_entry_sort(const void *av, const void *bv) {\n    bed_entry_t *a = (bed_entry_t *) av;\n    bed_entry_t *b = (bed_entry_t *) bv;\n    return a->right < b->right ? -1 : (a->right == b->right ? 0 : 1);\n}\n\nint load_bed_file_multi_ref(char *infile, int get_strand, int sort_by_pos, khash_t(bed_list_hash) *bed_lists, char ***ref_list, size_t *num_refs_out) {\n    hFILE *fp;\n    int line_count = 0, ret;\n\n    //variables to store the bed file data for each record\n    char ref[1024] = \"\";\n    int64_t left, right;\n    char name[1024] = \"\", score[1024] = \"\";\n    char strand;\n\n    //hash table to store clipping results and bed file data\n    kstring_t line = KS_INITIALIZE;\n    bed_entry_list_t *list;\n    khiter_t bed_itr;\n\n    //ordered ref names list\n    size_t ref_list_sz = 0;\n    size_t num_refs = 0;\n\n    if (ref_list)\n        *ref_list = NULL;\n\n    if (num_refs_out)\n        *num_refs_out = 0;\n\n    if ((fp = hopen(infile, \"r\")) == NULL) {\n        print_error_errno(\"amplicon\", \"unable to open file %s.\", infile);\n        return 1;\n    }\n\n\n    while (line.l = 0, kgetline(&line, (kgets_func *)hgets, fp) >= 0) {\n        line_count++;\n        int hret;\n\n        if (line.l == 0 || *line.s == '#') continue;\n        if (strncmp(line.s, \"track \", 6) == 0) continue;\n        if (strncmp(line.s, \"browser \", 8) == 0) continue;\n\n        // A list of the maximal number of columns we may want to parse.\n        // There may be more, but we don't use the ones beyond these.\n        const char *const scanf_str =\n            \"%1023s %\"SCNd64\" %\"SCNd64\" %1023s %1023s %c\";\n\n        // Extract the data from the line into the variables.\n        // Variables corresponding to any missing columns will remain\n        // uninitialised.  We asked for all columns, but cols_parsed will\n        // return how many we found which can be validated against num_columns.\n        int cols_parsed = sscanf(line.s, scanf_str, ref,\n                                 &left, &right, name, score, &strand);\n        if (cols_parsed < (get_strand ? 6 : 3)) {\n            fprintf(stderr, \"[amplicon] error: invalid bed file format in line %d of %s.\\n\"\n                    \"Parsed %d columns, but need at least %d\\n\"\n                    \"(N.B. ref/chrom name limited to 1023 characters.)\\n\",\n                    line_count, infile, cols_parsed, get_strand ? 6 : 3);\n            ret = 1;\n            goto error;\n        }\n\n        bed_itr = kh_get(bed_list_hash, bed_lists, ref);\n\n        if (bed_itr == kh_end(bed_lists)) { // new ref entry\n            char *ref_name = strdup(ref); // need a copy for the hash key\n\n            if (!ref_name) {\n                fprintf(stderr, \"[amplicon] error: unable to allocate memory for ref name.\\n\");\n                ret = 1;\n                goto error;\n            }\n\n            if (ref_list) {\n                if (hts_resize(char **, num_refs + 1, &ref_list_sz, ref_list, 0) < 0) {\n                    fprintf(stderr, \"[amplicon] error: unable to allocate memory for ref name list.\\n\");\n                    ret = 1;\n                    goto error;\n                }\n                (*ref_list)[num_refs++] = ref_name;\n            }\n            bed_itr = kh_put(bed_list_hash, bed_lists, ref_name, &hret);\n\n            if (hret > 0) {\n                list = &kh_val(bed_lists, bed_itr);\n\n                // initialise the new hash entry\n                list->longest = 0;\n                list->size = 0;\n                list->length = 0;\n                list->bp = NULL;\n            } else {\n                fprintf(stderr, \"[amplicon] error: ref hashing failure.\\n\");\n                ret = 1;\n                goto error;\n            }\n        } else { // existing ref\n            list = &kh_val(bed_lists, bed_itr);\n        }\n\n        // add the bed entry to the list, growing the list if necessary\n        if (list->length == list->size) {\n           bed_entry_t *tmp;\n\n           list->size += list->size / 2 + 256;\n\n           if ((tmp = realloc(list->bp, list->size * sizeof(bed_entry_t))) == NULL) {\n               fprintf(stderr, \"[amplicon] error: unable to allocate more memory for bed data.\\n\");\n               ret = 1;\n               goto error;\n           }\n\n           list->bp = tmp;\n        }\n\n        list->bp[list->length].left  = left;\n        list->bp[list->length].right = right;\n        list->bp[list->length].name  = NULL;\n        list->bp[list->length].score = NULL;\n        if (cols_parsed >= 4) {\n            list->bp[list->length].name = strdup(name);\n            if (list->bp[list->length].name == NULL) {\n                fprintf(stderr, \"[amplicon] error: unable to allocate memory for name in line %d of %s: %s.\\n\", line_count, infile, line.s);\n                ret = 1;\n                goto error;\n            }\n        }\n        if (cols_parsed >= 5) {\n            list->bp[list->length].score = strdup(score);\n            if (list->bp[list->length].score == NULL) {\n                fprintf(stderr, \"[amplicon] error: unable to allocate memory for score in line %d of %s: %s\\n\", line_count, infile, line.s);\n                ret = 1;\n                goto error;\n            }\n        }\n\n        list->bp[list->length].num_reads = 0;\n\n        if (get_strand) {\n            if (strand == '+') {\n                list->bp[list->length].rev = 0;\n            } else if (strand == '-') {\n                list->bp[list->length].rev = 1;\n            } else {\n                fprintf(stderr, \"[amplicon] error: bad strand value in line %d, expecting '+' or '-', found '%c'.\\n\",\n                            line_count, strand);\n                ret = 1;\n                goto error;\n            }\n        }\n\n        if (right - left > list->longest)\n            list->longest = right - left;\n\n        list->length++;\n    }\n\n    if (sort_by_pos) {\n        for (bed_itr = kh_begin(bed_lists); bed_itr != kh_end(bed_lists); ++bed_itr) {\n            if (kh_exist(bed_lists, bed_itr)) {\n                list = &kh_val(bed_lists, bed_itr);\n                qsort(list->bp, list->length, sizeof(list->bp[0]), bed_entry_sort);\n            }\n        }\n    }\n\n    if (kh_size(bed_lists) > 0) {// any entries\n        ret = 0;\n    } else {\n        ret = 1;\n    }\n\n    if (num_refs_out)\n        *num_refs_out = num_refs;\n\nerror:\n    ks_free(&line);\n\n    if (hclose(fp) != 0) {\n        fprintf(stderr, \"[amplicon] warning: failed to close %s\", infile);\n    }\n\n    return ret;\n}\n\n\nvoid destroy_bed_hash(khash_t(bed_list_hash) *hash) {\n    khiter_t itr;\n\n    for (itr = kh_begin(hash); itr != kh_end(hash); ++itr) {\n       if (kh_exist(hash, itr)) {\n           bed_entry_list_t list = kh_val(hash, itr);\n           for (int i = 0; i < list.length; i++) {\n               free(list.bp[i].name);\n               free(list.bp[i].score);\n           }\n           free(list.bp);\n           free((char *)kh_key(hash, itr));\n           kh_key(hash, itr) = NULL;\n        }\n    }\n\n    kh_destroy(bed_list_hash, hash);\n}\n\n\nstatic int matching_clip_site(bed_entry_list_t *sites, hts_pos_t pos,\n                              int is_rev, int use_strand, int64_t longest,\n                              cl_param_t *param) {\n    int i, size, used_i;\n    int tol = param->tol;\n    int l = 0, mid = sites->length / 2, r = sites->length;\n    int pos_tol = is_rev ? (pos > tol ? pos - tol : 0) : pos;\n\n    while (r - l > 1) {\n        if (sites->bp[mid].right <= pos_tol) {\n            l = mid;\n        } else {\n            r = mid;\n        }\n        mid = (l + r) / 2;\n    }\n\n    size = 0;\n    used_i = -1;\n\n    for (i = l; i < sites->length; i++) {\n        hts_pos_t mod_left, mod_right;\n\n        if (use_strand && is_rev != sites->bp[i].rev)\n            continue;\n\n        if (is_rev) {\n            mod_left = sites->bp[i].left;\n            mod_right = sites->bp[i].right + tol;\n        } else {\n            if (sites->bp[i].left > tol) {\n                mod_left = sites->bp[i].left - tol;\n            } else {\n                mod_left = 0;\n            }\n            mod_right = sites->bp[i].right;\n        }\n\n        if (pos + longest + tol < mod_right)\n            break;\n\n        if (pos >= mod_left && pos <= mod_right) {\n            if (is_rev) {\n                if (size < pos - sites->bp[i].left) {\n                    size = pos - sites->bp[i].left;\n                    used_i = i;\n                }\n            } else {\n                if (size < sites->bp[i].right - pos) {\n                    size = sites->bp[i].right - pos;\n                    used_i = i;\n                }\n            }\n        }\n    }\n    if (used_i >= 0) {\n        sites->bp[used_i].num_reads++;\n    }\n    return size;\n}\n\n\nstatic int bam_trim_left(bam1_t *rec, bam1_t *rec_out, uint32_t bases,\n                         clipping_type clipping) {\n    uint32_t *orig_cigar = bam_get_cigar(rec);\n    uint8_t *orig_seq = bam_get_seq(rec);\n    uint8_t *orig_qual = bam_get_qual(rec);\n    uint8_t *orig_aux = bam_get_aux(rec);\n    uint32_t *new_cigar;\n    uint8_t *new_qual;\n    size_t orig_l_aux = bam_get_l_aux(rec);\n    uint32_t i, j;\n    uint32_t ref_remove = bases, qry_removed = 0, hardclip = 0;\n    hts_pos_t new_pos = rec->core.pos;\n    uint32_t cig_type, cig_op;\n\n    if (rec->l_data + 8 > rec_out->m_data) {\n        uint8_t *new_data = realloc(rec_out->data, rec->l_data + 8);\n        if (!new_data) {\n            fprintf(stderr, \"[ampliconclip] error: could not allocate memoy for new bam record\\n\");\n            return 1;\n        }\n        rec_out->data = new_data;\n        rec_out->m_data = rec->l_data + 8;\n    }\n\n    // Copy core data & name\n    memcpy(&rec_out->core, &rec->core, sizeof(rec->core));\n    memcpy(rec_out->data, rec->data, rec->core.l_qname);\n\n    // Modify CIGAR\n    new_cigar = bam_get_cigar(rec_out);\n\n    for (i = 0;  i < rec->core.n_cigar; i++) {\n        cig_op = bam_cigar_op(orig_cigar[i]);\n        cig_type = bam_cigar_type(cig_op);\n\n        if (cig_op == BAM_CHARD_CLIP) {\n            hardclip += bam_cigar_oplen(orig_cigar[i]);\n        } else {\n            if (cig_type & 2) {\n                if (bam_cigar_oplen(orig_cigar[i]) <= ref_remove) {\n                    ref_remove -= bam_cigar_oplen(orig_cigar[i]);\n                } else {\n                    break;\n                }\n                new_pos += bam_cigar_oplen(orig_cigar[i]);\n            }\n            if (cig_type & 1) {\n                qry_removed += bam_cigar_oplen(orig_cigar[i]);\n            }\n        }\n    }\n\n    if (i < rec->core.n_cigar) {\n        cig_type = bam_cigar_type(bam_cigar_op(orig_cigar[i]));\n\n        // account for the last operation\n        if (cig_type & 2) {\n            new_pos += ref_remove;\n        }\n        if (cig_type & 1) {\n            qry_removed += ref_remove;\n        }\n    } else {\n        if (clipping == hard_clip) {\n\n            rec_out->core.l_qseq = 0;\n            rec_out->core.n_cigar = 0;\n\n            if (orig_l_aux)\n                memcpy(bam_get_aux(rec_out), orig_aux, orig_l_aux);\n\n            rec_out->l_data = bam_get_aux(rec_out) - rec_out->data + orig_l_aux;\n\n            return 0;\n        }\n\n        qry_removed = rec->core.l_qseq;\n    }\n\n    j = 0;\n    if (clipping == hard_clip && hardclip + qry_removed > 0) {\n        new_cigar[j++] = bam_cigar_gen(hardclip + qry_removed, BAM_CHARD_CLIP);\n    }\n    if (clipping == soft_clip) {\n        if (hardclip > 0) {\n            new_cigar[j++] = bam_cigar_gen(hardclip, BAM_CHARD_CLIP);\n        }\n        if (qry_removed > 0) {\n            new_cigar[j++] = bam_cigar_gen(qry_removed, BAM_CSOFT_CLIP);\n        }\n    }\n\n    if (i < rec->core.n_cigar\n        && bam_cigar_oplen(orig_cigar[i]) > ref_remove) {\n        new_cigar[j++] = bam_cigar_gen(bam_cigar_oplen(orig_cigar[i]) - ref_remove, bam_cigar_op(orig_cigar[i]));\n\n        // fill in the rest of the cigar\n        i++;\n\n        for (; i < rec->core.n_cigar; i++) {\n            new_cigar[j++] = orig_cigar[i];\n        }\n    }\n\n    rec_out->core.n_cigar = j;\n\n    if (clipping == soft_clip) {\n        qry_removed = 0; // Copy all the sequence and confidence values\n    }\n\n    new_qual = bam_get_seq(rec_out) + (rec->core.l_qseq - qry_removed + 1) / 2;\n    // Copy remaining SEQ\n    if ((qry_removed & 1) == 0) {\n        memcpy(bam_get_seq(rec_out), orig_seq + (qry_removed / 2),\n                (rec->core.l_qseq - qry_removed + 1) / 2); // +1 to account for odd numbers\n    } else {\n        uint8_t *in = orig_seq + qry_removed / 2;\n        uint8_t *out = bam_get_seq(rec_out);\n        uint32_t i;\n        for (i = qry_removed; i < rec->core.l_qseq - 1; i += 2) {\n            *out++ = ((in[0] & 0x0f) << 4) | ((in[1] & 0xf0) >> 4);\n            in++;\n        }\n        if (i < rec->core.l_qseq) {\n            *out++ = (in[0] & 0x0f) << 4;\n        }\n        assert(out == new_qual);\n    }\n\n    // Copy remaining QUAL\n    memmove(new_qual, orig_qual + qry_removed, rec->core.l_qseq - qry_removed);\n\n    // Set new l_qseq\n    rec_out->core.l_qseq -= qry_removed;\n\n    // Move AUX\n    if (orig_l_aux)\n        memcpy(bam_get_aux(rec_out), orig_aux, orig_l_aux);\n\n    // Set new l_data\n    rec_out->l_data = bam_get_aux(rec_out) - rec_out->data + orig_l_aux;\n\n    // put in new pos\n    rec_out->core.pos = new_pos;\n\n    return 0;\n}\n\n\nstatic int bam_trim_right(bam1_t *rec, bam1_t *rec_out, uint32_t bases,\n                          clipping_type clipping) {\n    uint32_t *orig_cigar = bam_get_cigar(rec);\n    uint8_t *orig_seq = bam_get_seq(rec);\n    uint8_t *orig_qual = bam_get_qual(rec);\n    uint8_t *orig_aux = bam_get_aux(rec);\n    uint32_t *new_cigar;\n    uint32_t new_n_cigar = 0;\n    uint8_t *new_qual;\n    size_t orig_l_aux = bam_get_l_aux(rec);\n    int32_t i;\n    int32_t j;\n    uint32_t ref_remove = bases, qry_removed = 0, hardclip = 0;\n    uint32_t cig_type, cig_op;\n\n    if (rec->l_data + 8 > rec_out->m_data) {\n        uint8_t *new_data = realloc(rec_out->data, rec->l_data + 8);\n        if (!new_data) {\n            fprintf(stderr, \"[ampliconclip] error: could not allocate memoy for new bam record\\n\");\n            return 1;\n        }\n        rec_out->data = new_data;\n        rec_out->m_data = rec->l_data + 8;\n    }\n\n    // Copy core data & name\n    memcpy(&rec_out->core, &rec->core, sizeof(rec->core));\n    memcpy(rec_out->data, rec->data, rec->core.l_qname);\n\n    // Modify CIGAR here\n    new_cigar = bam_get_cigar(rec_out);\n\n    for (i = rec->core.n_cigar - 1;  i >= 0; --i) {\n        cig_op = bam_cigar_op(orig_cigar[i]);\n        cig_type = bam_cigar_type(cig_op);\n\n        if (cig_op == BAM_CHARD_CLIP) {\n            hardclip += bam_cigar_oplen(orig_cigar[i]);\n        } else {\n            if (cig_type & 2) {\n                if (bam_cigar_oplen(orig_cigar[i]) <= ref_remove) {\n                    ref_remove -= bam_cigar_oplen(orig_cigar[i]);\n                } else {\n                    break;\n                }\n            }\n            if (cig_type & 1) {\n                qry_removed += bam_cigar_oplen(orig_cigar[i]);\n            }\n        }\n    }\n\n    if (i >= 0) {\n        cig_type = bam_cigar_type(bam_cigar_op(orig_cigar[i]));\n        if (cig_type & 1) {\n            qry_removed += ref_remove;\n        }\n        j = i;\n        if (qry_removed > 0) j++;\n        if (hardclip > 0 && (clipping == soft_clip || qry_removed == 0)) j++;\n    } else {\n        if (clipping == hard_clip) {\n\n            rec_out->core.l_qseq = 0;\n            rec_out->core.n_cigar = 0;\n\n            if (orig_l_aux)\n                memcpy(bam_get_aux(rec_out), orig_aux, orig_l_aux);\n\n            rec_out->l_data = bam_get_aux(rec_out) - rec_out->data + orig_l_aux;\n\n            return 0;\n        }\n\n        qry_removed = rec->core.l_qseq;\n        j = 0;\n        if (hardclip > 0 && clipping == soft_clip) j++;\n    }\n\n    if (clipping == hard_clip && hardclip + qry_removed > 0) {\n        new_cigar[j] = bam_cigar_gen(hardclip + qry_removed, BAM_CHARD_CLIP);\n        new_n_cigar++;\n    }\n    if (clipping == soft_clip) {\n        if (hardclip > 0) {\n            new_cigar[j] = bam_cigar_gen(hardclip, BAM_CHARD_CLIP);\n            new_n_cigar++;\n            if (qry_removed > 0) --j;\n        }\n        if (qry_removed > 0) {\n            new_cigar[j] = bam_cigar_gen(qry_removed, BAM_CSOFT_CLIP);\n            new_n_cigar++;\n        }\n    }\n\n    if (j > 0) {\n        new_cigar[--j] = bam_cigar_gen(bam_cigar_oplen(orig_cigar[i]) - ref_remove, bam_cigar_op(orig_cigar[i]));\n        new_n_cigar++;\n    }\n\n    // fill in the rest of the cigar\n    while (j > 0) {\n        new_cigar[--j] = orig_cigar[--i];\n        new_n_cigar++;\n    }\n\n    rec_out->core.n_cigar = new_n_cigar;\n\n    if (clipping == soft_clip)\n        qry_removed = 0; // Copy all the sequence and confidence values\n\n    new_qual = bam_get_seq(rec_out) + (rec->core.l_qseq - qry_removed + 1) / 2;\n    // Copy remaining SEQ\n    memcpy(bam_get_seq(rec_out), orig_seq, (rec->core.l_qseq - qry_removed + 1) / 2);\n\n    // Copy remaining QUAL\n    memcpy(new_qual, orig_qual, rec->core.l_qseq - qry_removed);\n\n    // Set new l_qseq\n    rec_out->core.l_qseq -= qry_removed;\n\n    // Copy AUX\n    if (orig_l_aux)\n        memcpy(bam_get_aux(rec_out), orig_aux, orig_l_aux);\n\n    // Set new l_data\n    rec_out->l_data = bam_get_aux(rec_out) - rec_out->data + orig_l_aux;\n\n    return 0;\n}\n\n\nstatic hts_pos_t active_query_len(bam1_t *b) {\n    uint32_t *cigar = bam_get_cigar(b);\n    uint32_t cig_type, cig_op;\n    hts_pos_t len = 0;\n    int i;\n\n    for (i = 0; i < b->core.n_cigar; i++) {\n        cig_op =  bam_cigar_op(cigar[i]);\n        cig_type = bam_cigar_type(cig_op);\n\n        if ((cig_type & 1) && (cig_op != BAM_CSOFT_CLIP)) {\n            len += bam_cigar_oplen(cigar[i]);\n        }\n    }\n\n    return len;\n}\n\n\nstatic inline void swap_bams(bam1_t **a, bam1_t **b) {\n    bam1_t *tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n\n// Format OA:Z:(RNAME,POS,strand,CIGAR,MAPQ,NM;\nstatic inline int tag_original_data(bam1_t *orig, kstring_t *oa_tag) {\n    char strand;\n    uint8_t *nm_tag, *old_oa_tag;\n    uint32_t *cigar;\n    int64_t nm = 0;\n    int i, res = 0;\n\n    ks_clear(oa_tag);\n\n    // if there is an existing OA tag the new one gets appended to it\n    if ((old_oa_tag = bam_aux_get(orig, \"OA\"))) {\n        res |= ksprintf(oa_tag, \"%s\", bam_aux2Z(old_oa_tag)) < 0;\n    }\n\n    if (orig->core.flag & BAM_FREVERSE)\n        strand = '-';\n    else\n        strand = '+';\n\n    if ((nm_tag = bam_aux_get(orig, \"NM\"))) {\n        nm = bam_aux2i(nm_tag);\n    }\n\n    res |= ksprintf(oa_tag, \"%s,%\"PRIhts_pos\",%c,\", bam_get_qname(orig), orig->core.pos + 1, strand) < 0;\n\n    for (i = 0, cigar = bam_get_cigar(orig); i < orig->core.n_cigar && res == 0; ++i) {\n        res |= kputw(bam_cigar_oplen(cigar[i]), oa_tag) < 0;\n        res |= kputc(bam_cigar_opchr(cigar[i]), oa_tag) < 0;\n    }\n\n    if (nm_tag) {\n        res |= ksprintf(oa_tag, \",%d,%\"PRId64\";\", orig->core.qual, nm) < 0;\n    } else {\n        res |= ksprintf(oa_tag, \"%d,;\", orig->core.qual) < 0;\n    }\n\n    return res;\n}\n\n\nstatic int bam_clip(samFile *in, samFile *out, samFile *reject, char *bedfile,\n                    clipping_type clipping, cl_param_t *param) {\n    int ret = 1, r, file_open = 0;\n\n    bam_hdr_t *header = NULL;\n    bam1_t *b = NULL, *b_tmp = NULL;\n    long f_count = 0, r_count = 0, n_count = 0, l_count = 0, l_exclude = 0, b_count = 0;\n    long filtered = 0, written = 0, failed = 0;\n    kstring_t str = KS_INITIALIZE;\n    kstring_t oat = KS_INITIALIZE;\n    kstring_t seq = KS_INITIALIZE;\n    bed_entry_list_t *sites;\n    FILE *stats_fp = stderr;\n    FILE *bed_count_summary_fp = stderr;\n    khash_t(bed_list_hash) *bed_hash = kh_init(bed_list_hash);\n    char **bed_ref_list = NULL;\n    size_t num_bed_refs = 0;\n\n    if (load_bed_file_multi_ref(bedfile, param->use_strand, 1, bed_hash,\n                                &bed_ref_list, &num_bed_refs)) {\n        fprintf(stderr, \"[ampliconclip] error: unable to load bed file.\\n\");\n        goto fail;\n    }\n\n    if ((header = sam_hdr_read(in)) == NULL) {\n        fprintf(stderr, \"[ampliconclip] error: could not read header\\n\");\n        goto fail;\n    }\n\n    // changing pos can ruin coordinate sort order\n    if (sam_hdr_find_tag_hd(header, \"SO\", &str) == 0 && str.s && strcmp(str.s, \"coordinate\") == 0) {\n        const char *new_order = \"unknown\";\n\n        if (sam_hdr_update_hd(header, \"SO\", new_order) == -1) {\n            fprintf(stderr, \"[ampliconclip] error: unable to change sort order to 'SO:%s'\\n\", new_order);\n            goto fail;\n        }\n    }\n\n    ks_free(&str);\n\n    if (param->add_pg && sam_hdr_add_pg(header, \"samtools\", \"VN\", samtools_version(),\n                        param->arg_list ? \"CL\" : NULL,\n                        param->arg_list ? param->arg_list : NULL,\n                        NULL) != 0) {\n        fprintf(stderr, \"[ampliconclip] warning: unable to add @PG line to header.\\n\");\n    }\n    if (sam_hdr_write(out, header) < 0) {\n        fprintf(stderr, \"[ampliconclip] error: could not write header.\\n\");\n        goto fail;\n    }\n\n    if (reject) {\n       if (sam_hdr_write(reject, header) < 0) {\n           fprintf(stderr, \"[ampliconclip] error: could not write header to rejects file.\\n\");\n           goto fail;\n       }\n    }\n\n    b = bam_init1();\n    b_tmp = bam_init1();\n    if (!b || !b_tmp) {\n        fprintf(stderr, \"[ampliconclip] error: out of memory when trying to create record.\\n\");\n        goto fail;\n    }\n\n    int32_t last_tid = -1;\n    int ref_found = 0;\n\n    while ((r = sam_read1(in, header, b)) >= 0) {\n        hts_pos_t pos;\n        int is_rev;\n        int p_size;\n        int been_clipped  = 0, filter = 0;\n        int exclude = (BAM_FUNMAP | BAM_FQCFAIL);\n        khiter_t itr;\n\n        l_count++;\n\n        if (b->core.tid != last_tid) {\n            const char *ref_name;\n\n            ref_found = 0;\n            last_tid = b->core.tid;\n\n            if ((ref_name = sam_hdr_tid2name(header, b->core.tid)) != NULL) {\n                itr = kh_get(bed_list_hash, bed_hash, ref_name);\n\n                if (itr != kh_end(bed_hash)) {\n                    sites = &kh_val(bed_hash, itr);\n                    ref_found = 1;\n                }\n            }\n        }\n\n        if (!(b->core.flag & exclude) && ref_found) {\n            if (param->oa_tag)\n                if (tag_original_data(b, &oat))\n                    goto fail;\n\n            if (!param->both) {\n                if (bam_is_rev(b)) {\n                    pos = bam_endpos(b);\n                    is_rev = 1;\n                } else {\n                    pos = b->core.pos;\n                    is_rev = 0;\n                }\n\n                if ((p_size = matching_clip_site(sites, pos, is_rev, param->use_strand, sites->longest, param))) {\n                    if (is_rev) {\n                        if (bam_trim_right(b, b_tmp, p_size, clipping) != 0)\n                            goto fail;\n\n                        swap_bams(&b, &b_tmp);\n                        r_count++;\n                    } else {\n                        if (bam_trim_left(b, b_tmp, p_size, clipping) != 0)\n                            goto fail;\n\n                        swap_bams(&b, &b_tmp);\n                        f_count++;\n                    }\n\n                    if (param->oa_tag) {\n                        if (bam_aux_update_str(b, \"OA\", oat.l + 1, (const char *)oat.s))\n                            goto fail;\n                    }\n\n                    if (param->del_tag) {\n                        uint8_t *tag;\n\n                        if ((tag = bam_aux_get(b, \"NM\")))\n                            bam_aux_del(b, tag);\n\n                        if ((tag = bam_aux_get(b, \"MD\")))\n                            bam_aux_del(b, tag);\n                    }\n\n                    been_clipped = 1;\n                } else {\n                    if (param->mark_fail) {\n                        b->core.flag |= BAM_FQCFAIL;\n                    }\n\n                    n_count++;\n                }\n            } else {\n                int left = 0, right = 0;\n\n                // left first\n                pos = b->core.pos;\n                is_rev = 0;\n\n                if ((p_size = matching_clip_site(sites, pos, is_rev, param->use_strand, sites->longest, param))) {\n                    if (bam_trim_left(b, b_tmp, p_size, clipping) != 0)\n                        goto fail;\n\n                    swap_bams(&b, &b_tmp);\n                    f_count++;\n                    left = 1;\n                    been_clipped = 1;\n                }\n\n                // the right\n                pos = bam_endpos(b);\n                is_rev = 1;\n\n                if ((p_size = matching_clip_site(sites, pos, is_rev, param->use_strand, sites->longest, param))) {\n                    if (bam_trim_right(b, b_tmp, p_size, clipping) != 0)\n                        goto fail;\n\n                    swap_bams(&b, &b_tmp);\n                    r_count++;\n                    right = 1;\n                    been_clipped = 1;\n                }\n\n                if (left || right) {\n                    uint8_t *tag;\n\n                    if (param->oa_tag) {\n                        if (bam_aux_update_str(b, \"OA\", oat.l + 1, (const char *)oat.s))\n                            goto fail;\n                    }\n\n                    if (param->del_tag) {\n                        if ((tag = bam_aux_get(b, \"NM\")))\n                            bam_aux_del(b, tag);\n\n                        if ((tag = bam_aux_get(b, \"MD\")))\n                            bam_aux_del(b, tag);\n                    }\n                }\n\n                if (left && right) {\n                    b_count++;\n                } else if (!left && !right) {\n                    if (param->mark_fail) {\n                        b->core.flag |= BAM_FQCFAIL;\n                    }\n\n                    n_count++;\n                }\n            }\n\n            if (param->fail_len >= 0 || param->filter_len >= 0 || param->unmap_len >= 0) {\n                hts_pos_t aql = active_query_len(b);\n\n                if (param->fail_len >= 0 && aql <= param->fail_len) {\n                    b->core.flag |= BAM_FQCFAIL;\n                }\n\n                if (param->filter_len >= 0 && aql <= param->filter_len) {\n                    filter = 1;\n                }\n\n                if (param->unmap_len >= 0 && aql <= param->unmap_len) {\n\n                    if (ks_resize(&seq, b->core.l_qseq) < 0) {\n                        fprintf(stderr, \"[ampliconclip] error: allocate memory for sequence %s\\n\", bam_get_seq(b));\n                        goto fail;\n                    }\n\n                    ks_clear(&seq);\n                    char *sb = ks_str(&seq);\n                    uint8_t *sequence = bam_get_seq(b);\n                    int i;\n\n                    for (i = 0; i < b->core.l_qseq ; ++i) {\n                        *sb++ = seq_nt16_str[bam_seqi(sequence, i)];\n                    }\n\n                    if (bam_set1(b_tmp, b->core.l_qname - b->core.l_extranul - 1, bam_get_qname(b),\n                                 (b->core.flag | BAM_FUNMAP), b->core.tid, b->core.pos, 0,\n                                 0, NULL, b->core.mtid, b->core.mpos, b->core.isize,\n                                 b->core.l_qseq, seq.s, (const char *)bam_get_qual(b),\n                                 bam_get_l_aux(b)) < 0) {\n                        fprintf(stderr, \"[ampliconclip] error: could not unmap read %s\\n\", bam_get_seq(b));\n                        goto fail;\n                    }\n\n                    memcpy(bam_get_aux(b_tmp), bam_get_aux(b), bam_get_l_aux(b));\n                    b_tmp->l_data += bam_get_l_aux(b);\n                    swap_bams(&b, &b_tmp);\n                }\n           }\n\n           if (b->core.flag & BAM_FQCFAIL) {\n               failed++;\n           }\n\n           if (param->write_clipped && !been_clipped) {\n               filter = 1;\n           }\n\n        } else {\n            l_exclude++;\n\n            if (param->unmapped) {\n                filter = 1;\n            }\n        }\n\n        if (!filter) {\n            if (sam_write1(out, header, b) < 0) {\n                fprintf(stderr, \"[ampliconclip] error: could not write line %ld.\\n\", l_count);\n                goto fail;\n            }\n\n            written++;\n        } else {\n            if (reject) {\n                if (sam_write1(reject, header, b) < 0) {\n                    fprintf(stderr, \"[ampliconclip] error: could not write to reject file %s\\n\",\n                            param->rejects_file);\n                    goto fail;\n                }\n            }\n\n            filtered++;\n        }\n    }\n\n    if (r < -1) {\n        fprintf(stderr, \"[ampliconclip] error: failed to read input.\\n\");\n        goto fail;\n    }\n\n    if (param->stats_file) {\n        if ((stats_fp = fopen(param->stats_file, \"w\")) == NULL) {\n            fprintf(stderr, \"[ampliconclip] warning: cannot write stats to %s.\\n\", param->stats_file);\n        } else {\n            file_open = 1;\n        }\n    }\n\n    fprintf(stats_fp, \"COMMAND: %s\\n\"\n                    \"TOTAL READS: %ld\\n\"\n                    \"TOTAL CLIPPED: %ld\\n\"\n                    \"FORWARD CLIPPED: %ld\\n\"\n                    \"REVERSE CLIPPED: %ld\\n\"\n                    \"BOTH CLIPPED: %ld\\n\"\n                    \"NOT CLIPPED: %ld\\n\"\n                    \"EXCLUDED: %ld\\n\"\n                    \"FILTERED: %ld\\n\"\n                    \"FAILED: %ld\\n\"\n                    \"WRITTEN: %ld\\n\", param->arg_list, l_count, f_count + r_count,\n                                    f_count, r_count, b_count, n_count, l_exclude,\n                                    filtered, failed, written);\n\n    if (file_open) {\n        fclose(stats_fp);\n        file_open = 0;\n    }\n\n    if (param->primer_counts_file) {\n        if ((bed_count_summary_fp = fopen(param->primer_counts_file, \"w\")) == NULL) {\n            fprintf(stderr, \"[ampliconclip] warning: cannot write count summary to %s.\\n\", param->primer_counts_file);\n        } else {\n            file_open = 1;\n        }\n\n        //print out the number of reads for each bed entry, bedgraph format\n        fprintf(bed_count_summary_fp, \"#CHR\\tLEFT\\tRIGHT\\tNAME\\tSCORE\\tSTRAND\\tNUM_CLIPPED\\n\");\n        size_t refidx;\n        for (refidx = 0; refidx < num_bed_refs; refidx++) {\n            khiter_t itr = kh_get(bed_list_hash, bed_hash, bed_ref_list[refidx]);\n            if (itr >= kh_end(bed_hash)) {\n                fprintf(stderr, \"[ampliconclip] error: %s has gone missing from the hash table\\n\", bed_ref_list[refidx]);\n                goto fail;\n            }\n            sites = &kh_val(bed_hash, itr);\n            int i;\n            for (i = 0; i < sites->length; i++) {\n                char* strand_out = param->use_strand ? (sites->bp[i].rev ? \"-\" : \"+\") : \".\";\n                fprintf(bed_count_summary_fp, \"%s\\t%\"PRId64\"\\t%\"PRId64\"\\t%s\\t%s\\t%s\\t%\"PRId64\"\\n\",\n                        kh_key(bed_hash, itr), sites->bp[i].left, sites->bp[i].right, sites->bp[i].name,\n                        sites->bp[i].score, strand_out, sites->bp[i].num_reads);\n            }\n        }\n        if (file_open) {\n            fclose(bed_count_summary_fp);\n        }\n    }\n\n    ret = 0;\n\nfail:\n    free(bed_ref_list);\n    destroy_bed_hash(bed_hash);\n    ks_free(&oat);\n    ks_free(&seq);\n    sam_hdr_destroy(header);\n    bam_destroy1(b);\n    bam_destroy1(b_tmp);\n    return ret;\n}\n\n\nstatic void usage(void) {\n    fprintf(stderr, \"Usage: samtools ampliconclip -b BED file <input.bam> -o <output.bam>\\n\\n\");\n    fprintf(stderr, \"Option: \\n\");\n    fprintf(stderr, \" -b  FILE             BED file of regions (eg amplicon primers) to be removed.\\n\");\n    fprintf(stderr, \" -o  FILE             output file name (default: stdout).\\n\");\n    fprintf(stderr, \" -f  FILE             write stats to file name (default: stderr)\\n\");\n    fprintf(stderr, \" -u                   Output uncompressed data\\n\");\n    fprintf(stderr, \" --soft-clip          soft clip amplicon primers from reads (default)\\n\");\n    fprintf(stderr, \" --hard-clip          hard clip amplicon primers from reads.\\n\");\n    fprintf(stderr, \" --both-ends          clip on both 5' and 3' ends.\\n\");\n    fprintf(stderr, \" --strand             use strand data from BED file to match read direction.\\n\");\n    fprintf(stderr, \" --clipped            only output clipped reads.\\n\");\n    fprintf(stderr, \" --fail               mark unclipped, mapped reads as QCFAIL.\\n\");\n    fprintf(stderr, \" --filter-len INT     do not output reads INT size or shorter.\\n\");\n    fprintf(stderr, \" --fail-len   INT     mark as QCFAIL reads INT size or shorter.\\n\");\n    fprintf(stderr, \" --unmap-len  INT     unmap reads INT size or shorter, default 0.\\n\");\n    fprintf(stderr, \" --no-excluded        do not write excluded reads (unmapped or QCFAIL).\\n\");\n    fprintf(stderr, \" --rejects-file FILE  file to write filtered reads.\\n\");\n    fprintf(stderr, \" --primer-counts FILE file to write read counts per bed entry (bedgraph format).\\n\");\n    fprintf(stderr, \" --original           for clipped entries add an OA tag with original data.\\n\");\n    fprintf(stderr, \" --keep-tag           for clipped entries keep the old NM and MD tags.\\n\");\n    fprintf(stderr, \" --tolerance          match region within this number of bases, default 5.\\n\");\n    fprintf(stderr, \" --no-PG              do not add an @PG line.\\n\");\n    sam_global_opt_help(stderr, \"-.O..@-.\");\n    fprintf(stderr, \"\\nAbout: Soft clips read alignments where they match BED file defined regions.\\n\"\n                    \"Default clipping is only on the 5' end.\\n\\n\");\n}\n\n\nint amplicon_clip_main(int argc, char **argv) {\n    int c, ret;\n    char wmode[4] = {'w', 'b', 0, 0};\n    char *bedfile = NULL, *fnout = \"-\";\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    htsThreadPool p = {NULL, 0};\n    samFile *in = NULL, *out = NULL, *reject = NULL;\n    clipping_type clipping = soft_clip;\n    cl_param_t param = {1, 0, 0, 0, 0, -1, -1, 0, 0, 1, 5, 0, NULL, NULL, NULL};\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', 0, 0, '@'),\n        {\"no-PG\", no_argument, NULL, 1002},\n        {\"soft-clip\", no_argument, NULL, 1003},\n        {\"hard-clip\", no_argument, NULL, 1004},\n        {\"strand\", no_argument, NULL, 1005},\n        {\"clipped\", no_argument, NULL, 1006},\n        {\"fail\", no_argument, NULL, 1007},\n        {\"both-ends\", no_argument, NULL, 1008},\n        {\"filter-len\", required_argument, NULL, 1009},\n        {\"fail-len\", required_argument, NULL, 1010},\n        {\"no-excluded\", no_argument, NULL, 1011},\n        {\"rejects-file\", required_argument, NULL, 1012},\n        {\"primer-counts\", required_argument, NULL, 1013},\n        {\"original\", no_argument, NULL, 1014},\n        {\"keep-tag\", no_argument, NULL, 1015},\n        {\"tolerance\", required_argument, NULL, 1016},\n        {\"unmap-len\", required_argument, NULL, 1017},\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"b:@:o:O:f:u\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'b': bedfile = optarg; break;\n            case 'o': fnout = optarg; break;\n            case 'f': param.stats_file = optarg; break;\n            case 'u': wmode[2] = '0'; break;\n            case 1002: param.add_pg = 0; break;\n            case 1003: clipping = soft_clip; break;\n            case 1004: clipping = hard_clip; break;\n            case 1005: param.use_strand = 1; break;\n            case 1006: param.write_clipped = 1; break;\n            case 1007: param.mark_fail = 1; break;\n            case 1008: param.both = 1; break;\n            case 1009: param.filter_len = atoi(optarg); break;\n            case 1010: param.fail_len = atoi(optarg); break;\n            case 1011: param.unmapped = 1; break;\n            case 1012: param.rejects_file = optarg; break;\n            case 1013: param.primer_counts_file = optarg; break;\n            case 1014: param.oa_tag = 1; break;\n            case 1015: param.del_tag = 0; break;\n            case 1016: param.tol = atoi(optarg); break;\n            case 1017: param.unmap_len = atoi(optarg); break;\n            default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                      /* else fall-through */\n            case '?': usage(); exit(1);\n        }\n    }\n\n    if (!bedfile) {\n        usage();\n        return 1;\n    }\n\n    if (optind + 1 > argc) {\n        usage();\n        return 1;\n    }\n\n    if (param.tol < 0) {\n        fprintf(stderr, \"[ampliconclip] warning: invalid tolerance of %d,\"\n                        \" resetting tolerance to default of 5.\\n\", param.tol);\n        param.tol = 5;\n    }\n\n    if ((in = sam_open_format(argv[optind], \"rb\", &ga.in)) == NULL) {\n        print_error_errno(\"ampliconclip\", \"cannot open input file\");\n        return 1;\n    }\n\n    sam_open_mode(wmode+1, fnout, NULL);\n\n    if ((out = sam_open_format(fnout, wmode, &ga.out)) == NULL) {\n        print_error_errno(\"ampliconclip\", \"cannot open output file\");\n        return 1;\n    }\n\n    if (param.rejects_file) {\n        sam_open_mode(wmode+1, param.rejects_file, NULL);\n\n        if ((reject = sam_open_format(param.rejects_file, wmode, &ga.out)) == NULL) {\n            print_error_errno(\"ampliconclip\", \"cannot open rejects file\");\n            return 1;\n        }\n    }\n\n    if (ga.nthreads > 0) {\n        if (!(p.pool = hts_tpool_init(ga.nthreads))) {\n            fprintf(stderr, \"[ampliconclip] error: cannot create thread pool.\\n\");\n            return 1;\n        }\n        hts_set_opt(in,  HTS_OPT_THREAD_POOL, &p);\n        hts_set_opt(out, HTS_OPT_THREAD_POOL, &p);\n\n        if (reject) {\n           hts_set_opt(reject,  HTS_OPT_THREAD_POOL, &p);\n        }\n    }\n\n    param.arg_list = stringify_argv(argc + 1, argv - 1);\n\n    ret = bam_clip(in, out, reject, bedfile, clipping, &param);\n\n    // cleanup\n    sam_close(in);\n\n    if (sam_close(out) < 0) {\n        fprintf(stderr, \"[ampliconclip] error: error while closing output file %s.\\n\", argv[optind+1]);\n        ret = 1;\n    }\n\n    if (reject) {\n        if (sam_close(reject) < 0) {\n            fprintf(stderr, \"[ampliconclip] error: error while closing reject file %s.\\n\", param.rejects_file);\n            ret = 1;\n        }\n    }\n\n    if (p.pool) hts_tpool_destroy(p.pool);\n\n    sam_global_args_free(&ga);\n    free(param.arg_list);\n\n    return ret;\n}\n\n"
        },
        {
          "name": "bam_ampliconclip.h",
          "type": "blob",
          "size": 1.8720703125,
          "content": "/*  bam_ampliconclip.h -- shared functions between amplicon clip/stats\n\n    Copyright (C) 2020-2021 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BAM_AMPLICONCLIP_H\n#define BAM_AMPLICONCLIP_H\n\n#include \"htslib/khash.h\"\n\ntypedef struct {\n    int64_t left;\n    int64_t right;\n    char *name;\n    char *score;\n    int rev;\n    int64_t num_reads;\n} bed_entry_t;\n\ntypedef struct {\n    bed_entry_t *bp;\n    int64_t longest;\n    int length;\n    int size;\n} bed_entry_list_t;\n\nKHASH_MAP_INIT_STR(bed_list_hash, bed_entry_list_t)\n\n#define BED_LIST_INIT {NULL, 0, 0, 0, {0}}\n\n\nint load_bed_file_multi_ref(char *infile, int get_strand,\n                            int sort_by_pos, khash_t(bed_list_hash) *bed_lists,\n                            char ***ref_list, size_t *num_refs);\n\nvoid destroy_bed_hash(khash_t(bed_list_hash) *hash);\n\n\n#endif /* BAM_AMPLICONCLIP_H */\n"
        },
        {
          "name": "bam_aux.c",
          "type": "blob",
          "size": 2.1044921875,
          "content": "/*  bam_aux.c -- remaining aux field handling.\n\n    Copyright (C) 2008-2010, 2013, 2015, 2019 Genome Research Ltd.\n    Portions copyright (C) 2011 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <ctype.h>\n#include \"htslib/sam.h\"\n\nstatic inline int bam_aux_type2size(int x)\n{\n    if (x == 'C' || x == 'c' || x == 'A') return 1;\n    else if (x == 'S' || x == 's') return 2;\n    else if (x == 'I' || x == 'i' || x == 'f' || x == 'F') return 4;\n    else return 0;\n}\n\n#define __skip_tag(s) do { \\\n        int type = toupper(*(s)); \\\n        ++(s); \\\n        if (type == 'Z' || type == 'H') { while (*(s)) ++(s); ++(s); } \\\n        else if (type == 'B') (s) += 5 + bam_aux_type2size(*(s)) * (*(int32_t*)((s)+1)); \\\n        else (s) += bam_aux_type2size(type); \\\n    } while(0)\n\n\nint bam_aux_drop_other(bam1_t *b, uint8_t *s)\n{\n    if (s) {\n        uint8_t *p, *aux;\n        aux = bam_get_aux(b);\n        p = s - 2;\n        __skip_tag(s);\n        memmove(aux, p, s - p);\n        b->l_data -= bam_get_l_aux(b) - (s - p);\n    } else {\n        b->l_data -= bam_get_l_aux(b);\n    }\n    return 0;\n}\n"
        },
        {
          "name": "bam_cat.c",
          "type": "blob",
          "size": 33.29296875,
          "content": "/*  bam_cat.c -- efficiently concatenates bam files.\n\n    Copyright (C) 2008-2009, 2011-2013, 2015-2017, 2019, 2021,\n                  2023-2024 Genome Research Ltd.\n    Modified SAMtools work copyright (C) 2010 Illumina, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n/*\nbam_cat can be used to concatenate BAM files. Under special\ncircumstances, it can be used as an alternative to 'samtools merge' to\nconcatenate multiple sorted files into a single sorted file. For this\nto work each file must be sorted, and the sorted files must be given\nas command line arguments in order such that the final read in file i\nis less than or equal to the first read in file i+1.\n\nThis code is derived from the bam_reheader function in samtools 0.1.8\nand modified to perform concatenation by Chris Saunders on behalf of\nIllumina.\n*/\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <strings.h>\n\n#include \"htslib/bgzf.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/cram.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/hfile.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\n/// cat_check_merge_hdr - check compatibility and merge RG hearders merges RGon both CRAM and BAM.\n/** @param firstfile - pointer to the 1sr file opened in caller\n *  @param nfn - number of files to be processed, including the firstfile\n *  @param fn - array of file paths to be processed\n *  @param h - sam header pointer which contains explicitly given header\n *  @param vers_maj_p - cram major version set and send out for output creation\n *  @param vers_min_p - cram min version set and send out for output creation\n *  @param out_h - pointer to sam header pointer, outputs the merged header\n * returns array of opened samFile pointers on success and NULL on failure\n * This method has the merged header processing for cram and bam.\n * RG lines are merged for both cram and bam. For cram, version match for each\n * file and order match of RG lines are compared as well.\n * Note: it is a simple merge of RG lines alone.\n*/\nstatic samFile** cat_check_merge_hdr(samFile * const firstfile, int nfn, char * const *fn, const sam_hdr_t *h,\n                                     int *vers_maj_p, int *vers_min_p, sam_hdr_t **out_h) {\n    int i, vers_maj = -1, vers_min = -1;\n    sam_hdr_t *new_h = NULL, *old_h = NULL;\n    samFile *in = NULL;\n    kstring_t ks = KS_INITIALIZE;\n    samFile **files = calloc(nfn, sizeof(samFile *));\n    if(!files) {\n        fprintf(stderr, \"[%s] ERROR: failed to allocate space for file handles.\\n\", __func__);\n        return NULL;\n    }\n    if (!out_h || !firstfile) {\n        fprintf(stderr, \"[%s] ERROR: header check failed.\\n\", __func__);\n        goto fail;\n    }\n    if (*out_h) {           //use header if one is already present\n        new_h = *out_h;\n    }\n    else {\n        if (h) {            //use the explicit header given\n            new_h = sam_hdr_dup(h);\n            if (!new_h) {\n                fprintf(stderr, \"[%s] ERROR: header duplication failed.\\n\",\n                        __func__);\n                goto fail;\n            }\n        }\n    }\n\n    for (i = 0; i < nfn; ++i) {\n        int ki;\n        //1st file is already open and passed, rest open locally\n        files[i] = in = i ? sam_open(fn[i], \"r\") : firstfile;\n        if (in == 0) {\n            print_error_errno(\"cat\", \"fail to open file '%s'\", fn[i]);\n            goto fail;\n        }\n        if (firstfile->format.format != in->format.format) {\n            print_error(\"cat\", \"File %s is of different format!\", fn[i]);\n            goto fail;\n        }\n        if (firstfile->format.format == cram) {     //version check for cram\n            cram_fd *in_c;\n            in_c = in->fp.cram;\n\n            int vmaj = cram_major_vers(in_c);\n            int vmin = cram_minor_vers(in_c);\n            if ((vers_maj != -1 && vers_maj != vmaj) ||\n                (vers_min != -1 && vers_min != vmin)) {\n                fprintf(stderr, \"[%s] ERROR: input files have differing version numbers.\\n\",\n                        __func__);\n                goto fail;\n            }\n            vers_maj = vmaj;\n            vers_min = vmin;\n        }\n\n        old_h = sam_hdr_read(in);\n        if (!old_h) {\n            fprintf(stderr, \"[%s] ERROR: header reading for file '%s' filed.\\n\",\n                    __func__, fn[i]);\n            goto fail;\n        }\n\n        if (!new_h) {\n            new_h = sam_hdr_dup(old_h);\n            if (!new_h) {\n                fprintf(stderr, \"[%s] ERROR: header duplication for file '%s' failed.\\n\",\n                        __func__, fn[i]);\n                goto fail;\n            }\n            sam_hdr_destroy(old_h);\n            old_h = NULL;\n            continue;\n        }\n        //merge RG lines\n        int old_count = sam_hdr_count_lines(old_h, \"RG\");\n        for (ki = 0; ki < old_count; ki++) {\n            const char *old_name = sam_hdr_line_name(old_h, \"RG\", ki);\n            if (old_name) {\n                int new_i = sam_hdr_line_index(new_h, \"RG\", old_name);\n                if (-1 == new_i) { // line does not exist in the new header\n                    if (sam_hdr_find_line_pos(old_h, \"RG\", ki, &ks) ||\n                        !ks.s || sam_hdr_add_lines(new_h, ks.s, ks.l)) {\n                        fprintf(stderr, \"[%s] ERROR: failed to add @RG line 'ID:%s' from file '%s'\\n\",\n                                __func__, old_name, fn[i]);\n                        goto fail;\n                    }\n                    ks_free(&ks);\n                }\n            } else {\n                fprintf(stderr, \"[%s] ERROR: failed to read %d @RG line from file '%s'\\n\",\n                        __func__, ki, fn[i]);\n                goto fail;\n            }\n        }\n\n        if (firstfile->format.format == cram && old_count > 1 && sam_hdr_count_lines(new_h, \"RG\") == old_count) {\n            //RG order check for cram\n            for (ki = 0; ki < old_count; ki++) {\n                const char *old_name = sam_hdr_line_name(old_h, \"RG\", ki);\n                const char *new_name = sam_hdr_line_name(new_h, \"RG\", ki);\n                if (!old_name || !new_name || strcmp(old_name, new_name)) {\n                    fprintf(stderr, \"[%s] ERROR: Same size @RG lists but differing order / contents\\n\",\n                            __func__);\n                    goto fail;\n                }\n            }\n        }\n\n        sam_hdr_destroy(old_h); old_h = NULL;\n    }\n\n    ks_free(&ks);\n\n    if (vers_maj_p) {\n        *vers_maj_p = vers_maj;\n    }\n    if (vers_min_p) {\n        *vers_min_p = vers_min;\n    }\n    *out_h = new_h;\n    return files;\n\nfail:\n    ks_free(&ks);\n    if (old_h) sam_hdr_destroy(old_h);\n    if (new_h) sam_hdr_destroy(new_h);\n    *out_h = NULL;\n    for (i = 1; i < nfn; ++i) {         //close files other than the firstfile\n        if (files[i]) {\n            sam_close(files[i]);\n        }\n    }\n    free(files);\n\n    return NULL;\n}\n\n\n/* ----------------------------------------------------------------------\n * CRAM cat\n */\n\n// Reports the number of CRAM containers spanning a specified region if\n// specified, or the entire file if not.\n// This is the implements the \"samtools cat -q [-r reg]\" functionality.\n//\n// Returns 0 on success, <0 on error.\nstatic int cram_query_ncont(int nfn, char * const *fn, char *reg) {\n    int i;\n    hts_idx_t *idx = NULL;\n    sam_hdr_t *hdr = NULL;\n    hts_itr_t *iter = NULL;\n    samFile *in = NULL;\n\n    for (i = 0; i < nfn; i++) {\n        in = sam_open(fn[i], \"r\");\n        if (!in) {\n            print_error_errno(\"cat\", \"Couldn't open file %s\", fn[i]);\n            return -1;\n        }\n        idx = sam_index_load(in, fn[i]);\n        if (!idx) {\n            print_error(\"cat\", \"No index found\");\n            goto err;\n        }\n\n        off_t cstart = 0, cend = 0;\n        if (reg) {\n            sam_hdr_t *hdr = sam_hdr_read(in);\n            hts_itr_t *iter = sam_itr_querys(idx, hdr, reg);\n            if (!hdr) {\n                print_error(\"cat\", \"Unable to read header\");\n                goto err;\n            }\n            if (!iter) {\n                print_error(\"cat\", \"Unable to parse region\");\n                goto err;\n            }\n\n            if (cram_index_extents(in->fp.cram, iter->tid, iter->beg,\n                                   iter->end, &cstart, &cend) < 0) {\n                print_error(\"cat\", \"Failed to query index\");\n                goto err;\n            }\n\n            hts_itr_destroy(iter);\n            sam_hdr_destroy(hdr);\n        }\n\n        int64_t first, last;\n        int64_t nc = cram_num_containers_between(in->fp.cram, cstart, cend,\n                                                 &first, &last);\n        printf(\"%s\\t%\"PRId64\"\\t%\"PRId64\"\\t%\"PRId64\"\\n\",\n               fn[i], nc, first, last);\n        sam_close(in);\n        hts_idx_destroy(idx);\n    }\n\n    return 0;\n\n err:\n    if (idx)\n        hts_idx_destroy(idx);\n    if (hdr)\n        sam_hdr_destroy(hdr);\n    if (iter)\n        hts_itr_destroy(iter);\n\n    sam_close(in);\n\n    return -1;\n}\n\n// Container range #:A-B or #:A.\n// Returns 0 on success, -1 on failure.\nstatic int cram_handle_cnum_region(cram_fd *fd, hts_idx_t *idx,\n                                   char *reg, off_t *cstart, off_t *cend) {\n    int cnum_start, cnum_end; // container versions\n    int n = sscanf(reg, \"#:%d-%d\", &cnum_start, &cnum_end);\n\n    if (n == 0) {\n        print_error(\"cat\", \"ERROR: Malformed region: %s\", reg);\n        return -1;\n    } else if (n == 1) {\n        cnum_end = cnum_start;\n    }\n\n    int64_t nc = cram_num_containers(fd);\n    if (cnum_end >= nc) {\n        print_error(\"cat\", \"Too many containers.  \"\n                    \"The end range should be < %\"PRId64, nc);\n        return -1;\n    }\n\n    // Container number to offset\n    *cstart = cram_container_num2offset(fd, cnum_start);\n    *cend   = cram_container_num2offset(fd, cnum_end);\n    if (*cstart < 0 || *cend < 0)\n        return -1;\n\n    // Seek manually\n    return cram_seek(fd, *cstart, SEEK_SET);\n}\n\n// Normal range chr:start-end.\n// Returns an hts iterator on success, NULL on failure.\nstatic hts_itr_t *cram_handle_region(cram_fd *fd, hts_idx_t *idx, sam_hdr_t *h,\n                                     char *reg, off_t *cstart, off_t *cend) {\n    hts_itr_t *iter;\n\n    if (!idx) {\n        fprintf(stderr, \"[%s] ERROR: No index found.\\n\", __func__);\n        return NULL;\n    }\n\n    // This does an implicit seek and modifies the cram_fd.\n    if (!(iter = sam_itr_querys(idx, h, reg))) {\n        print_error(\"cat\", \"Unable to parse region %s\", reg);\n        return NULL;\n    }\n    if (cram_index_extents(fd, iter->tid, iter->beg,\n                           iter->end, cstart, cend) < 0) {\n        print_error(\"cat\", \"Failed to query index\");\n        return NULL;\n    }\n\n    return iter;\n}\n\n// Handle the -p A/B option to subdivide our region or file into portions.\n// Updates cstart/cend.\n// returns 0 on success (do something),\n//         1 on success (but nothing to do),\n//        -1 on failure.\nstatic int cram_subdivide_part(cram_fd *fd, hts_idx_t *idx, char *part,\n                               off_t *cstart, off_t *cend) {\n    int a, b;\n    // Part N of M\n    if (sscanf(part, \"%d/%d\", &a, &b) != 2) {\n        print_error(\"cat\", \"malformed region %s. Should be e.g. '1/10'\", part);\n        return -1;\n    }\n\n    // Inclusive container numbers for range, 0 to NC-1\n    // Our part N/M is in container percentages as we can't have\n    // partial containers, so convert to that first.\n    int64_t cnum1, cnum2;\n    if (cstart) {\n        cnum1 = cram_container_offset2num(fd, *cstart);\n        cnum2 = cram_container_offset2num(fd, *cend);\n    } else {\n        cnum1 = 0;\n        cnum2 = cram_num_containers(fd)-1;\n    }\n\n    // Subdivide cnum1/cnum2 container numbers to new range cnum_start/end\n    int64_t nc = cnum2 - cnum1 + 1;\n    if (b > nc)\n        b = nc;\n\n    int cnum_start = (a-1)*(double)nc/b;\n    int cnum_end   = a*(double)nc/b - 1;\n    if (cnum_start < 0 || cnum_end >= nc)\n        return 1;\n\n    // Then convert back to file offsets so we can seek and do htell\n    // to detect EOR/EOF.\n    *cstart = cram_container_num2offset(fd, cnum_start + cnum1);\n    *cend   = cram_container_num2offset(fd, cnum_end   + cnum1);\n\n    return 0;\n}\n\n// The main cram_cat interface.\n// Returns 0 on success, < 0 on error.\nint cram_cat(samFile * const firstfile, int nfn, char * const *fn,\n             const sam_hdr_t *h, const char* outcram, sam_global_args *ga,\n             char *arg_list, int no_pg, char *reg, char *part, int fast_reg)\n{\n    samFile *out = NULL;\n    cram_fd *out_c;\n    int i, vers_maj, vers_min, ret = -1;\n    sam_hdr_t *new_h = NULL;\n    samFile **files = NULL;\n    hts_idx_t *idx = NULL;\n    hts_itr_t *iter = NULL;\n    sam_hdr_t *old_h = NULL;\n\n    // Check consistent versioning and compatible headers;\n    // merges RG lines, opens all files and returns them that multiple\n    // non-seekable stream inputs can be handled\n    if (!(files = cat_check_merge_hdr(firstfile, nfn, fn, h, &vers_maj,\n                                      &vers_min, &new_h)))\n        return -1;\n\n    if (!new_h) {\n        print_error_errno(\"cat\", \"failed to make output header\");\n        goto closefiles;\n    }\n\n    /* Open the file with cram_vers */\n    char vers[100];\n    snprintf(vers, sizeof(vers), \"%d.%d\", vers_maj, vers_min);\n\n    // Can override level=1 with e.g. \"--output-fmt-option level=9\"\n    out = sam_open_format(outcram, \"wc1\", &ga->out);\n    if (out == 0) {\n        print_error_errno(\"cat\", \"fail to open output file '%s'\", outcram);\n        goto closefiles;\n    }\n    out_c = out->fp.cram;\n    cram_set_option(out_c, CRAM_OPT_VERSION, vers);\n\n    if (!no_pg && sam_hdr_add_pg(new_h, \"samtools\",\n                                 \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL))\n        goto closefiles;\n\n    if (sam_hdr_write(out, new_h) < 0) {\n        print_error_errno(\"cat\", \"Couldn't write header\");\n        goto closefiles;\n    }\n    out_c = out->fp.cram;\n\n    for (i = 0; i < nfn; ++i) {\n        samFile *in;\n        cram_fd *in_c;\n        cram_container *c;\n        int new_rg = -1;\n\n        in = files[i];\n        if (in == 0) {\n            print_error_errno(\"cat\", \"fail to open file '%s'\", fn[i]);\n            goto closefiles;\n        }\n        in_c = in->fp.cram;\n\n        old_h = sam_hdr_read(in);\n        if (!old_h) {\n            print_error(\"cat\", \"fail to read the header of file '%s'\", fn[i]);\n            goto closefiles;\n        }\n\n        // Compute RG mapping if suitable for changing.\n        if (sam_hdr_count_lines(old_h, \"RG\") == 1) {\n            const char *old_name = sam_hdr_line_name(old_h, \"RG\", 0);\n            if (old_name) {\n                new_rg = sam_hdr_line_index(new_h, \"RG\", old_name);\n                if (new_rg < 0) {\n                    print_error(\"cat\", \"fail to find @RG line '%s' in the new header\", old_name);\n                    goto closefiles;\n                }\n            } else {\n                print_error(\"cat\", \"fail to find @RG line in file '%s'\", fn[i]);\n                goto closefiles;\n            }\n        } else {\n            new_rg = 0;\n        }\n\n        // We have multiple region syntax.  Either the standard chr:start-end\n        // or a cat-specific #:num-num for explicit container numbers.\n        // Both of these seek to a specific file offset and also have the\n        // end offset known so we can use htell to detect when we're done.\n        // Those offsets are in cstart and cend.\n        //\n        // However for the e.g. -p 1/10 syntax we need to know the container\n        // numbers corresponding to the cstart/cend offsets as we can't\n        // start half way through a container when doing fractions.\n        // These are cnum1 and cnum2.  (We could short cut this for the\n        // #:num-num, but it's simpler to just treat all regions identically.)\n        off_t cstart = 0, cend = 0;\n        int filter_by_cnum = 0;\n\n        if (reg || part) {\n            idx = sam_index_load(in, fn[i]);\n            if (!idx) {\n                print_error(\"cat\", \"failed to load index\");\n                goto closefiles;\n            }\n        }\n\n        if (reg) {\n            if (strncmp(reg, \"#:\", 2) == 0) {\n                // Region as container numbers\n                if (cram_handle_cnum_region(in_c, idx, reg, &cstart,&cend) < 0)\n                    goto closefiles;\n\n                filter_by_cnum = 1;\n            } else {\n                // Normal range chr:start-end\n                if (!(iter = cram_handle_region(in_c, idx, old_h, reg,\n                                                &cstart, &cend)))\n                    goto closefiles;\n            }\n        }\n\n        // We can also take a range above and subdivide it into parts.\n        // Eg -r chr1 -p 1/10 (... to -p 10/10).  Part only implies\n        // portions of the entire file.\n        if (part) {\n            int r = cram_subdivide_part(in_c, idx, part, &cstart, &cend);\n            if (r != 0) {\n                if (r > 0) // Not an error, just nothing to do\n                    ret = 0;\n                goto closefiles;\n            }\n        }\n\n        if (cstart) // reg or part\n            if (0 != cram_seek(in_c, cstart, SEEK_SET))\n                goto closefiles;\n\n\n        // Make refid -2 (\"*\") come after other chromosomes, for easy sort\n        int itid = iter\n            ? (iter->tid == HTS_IDX_NOCOOR ? INT_MAX : iter->tid)\n            : 0;\n        int last_ref_id = -99;\n\n        off_t before_hdr = htell(cram_fd_get_fp(in_c));\n\n        // Copy contains and blocks within them\n        while ((c = cram_read_container(in_c))) {\n            if (cram_container_is_empty(in_c)) {\n                cram_block *blk;\n                // Container compression header\n                if (!(blk = cram_read_block(in_c)))\n                    goto closefiles;\n                cram_free_block(blk);\n                cram_free_container(c);\n                continue;\n            }\n\n            int filter = 0;\n\n            // If we have just one RG key and new_rg != 0 then\n            // we need to edit the compression header. IF WE CAN.\n            if (new_rg) {\n                if (reg) {\n                    print_error(\"cat\", \"Cannot specify a region while \"\n                                \"transcoding RG lines\");\n                    goto closefiles;\n                }\n                int zero = 0;\n                //fprintf(stderr, \"Transcode RG %d to %d\\n\", 0, new_rg);\n                cram_transcode_rg(in_c, out_c, c, 1, &zero, &new_rg);\n            } else {\n                int32_t num_slices;\n\n                if (reg) {\n                    if (before_hdr > cend) {\n                        cram_free_container(c);\n                        break;\n                    }\n                }\n\n                // For chr:start-end regions, do we need to filter or skip?\n                if (iter && reg) {\n                    int refid;\n                    hts_pos_t start, span, end;\n\n                    cram_container_get_coords(c, &refid, &start, &span);\n                    end = start+span;\n\n                    // Make refid -1 (\"*\") come after other chromosomes\n                    if (refid == -1)\n                        refid = INT_MAX;\n\n                    if (refid > itid || start > iter->end) {\n                        // Beyond the requested range\n                        break;\n                    } else if (refid == -2) {\n                        // Multi-ref containers.  We only support this if\n                        // the RI data series is in a container by itself.\n                        filter = 3;\n                    } else if (refid < itid || end < iter->beg) {\n                        // Skip, in case of mixed size containers.\n                        // Eg: Use \"=\", skip \"-\".\n                        // ==========|======|=\n                        //   ----  ==|==  ==|== ----\n                        //     ----- | ====   ----\n                        filter = 2;\n                    } else if (start < iter->beg || end > iter->end) {\n                        // Container overlaps region.\n                        // Fast mode just copies overlapping containers.\n                        // Slow mode does a precise filtering by reading and\n                        // filtering each record in turn so it's the same as\n                        // a samtools view command.\n                        filter = fast_reg ? 0 : 1;\n                    }\n                    // else we're in an \"internal\" container, so just copy\n                }\n\n                if (filter && last_ref_id == -1 && itid == INT_MAX)\n                    // Multi-ref containers consisting solely of ref \"*\" are\n                    // common, but if it's sorted then we know it's \"*\" from\n                    // here on so we don't need to filter despite multi-ref.\n                    filter = 0;\n\n                if (filter) {\n                    // Filter or skip\n                    cram_filter_container(in_c, out_c, c, &last_ref_id);\n                } else {\n                    // Copy. Consider adding a cram_copy_container API instead.\n\n                    // Container compression header\n                    cram_block *blk;\n                    if (!(blk = cram_read_block(in_c)))\n                        goto closefiles;\n\n                    // Not switching rg so do the usual read/write loop\n                    if (cram_write_container(out_c, c) != 0)\n                        goto closefiles;\n\n                    // Contatiner compression header\n                    if (cram_write_block(out_c, blk) != 0) {\n                        cram_free_block(blk);\n                        goto closefiles;\n                    }\n\n                    // Container num_blocks can be invalid, due to a bug.\n                    // Instead we iterate in slice context instead.\n                    (void)cram_container_get_landmarks(c, &num_slices);\n                    if (cram_copy_slice(in_c, out_c, num_slices) < 0) {\n                        cram_free_block(blk);\n                        goto closefiles;\n                    }\n                    cram_free_block(blk);\n                }\n            }\n            cram_free_container(c);\n\n            // Location of next container start\n            before_hdr = htell(cram_fd_get_fp(in_c));\n            if (filter_by_cnum && before_hdr > cend)\n                break;\n        }\n        sam_hdr_destroy(old_h);\n        old_h = NULL;\n\n        if (idx) {\n            hts_idx_destroy(idx);\n            idx = NULL;\n        }\n\n        if (iter) {\n            hts_itr_destroy(iter);\n            iter = NULL;\n        }\n    }\n    ret = 0;\n\nclosefiles:\n    if (old_h)\n        sam_hdr_destroy(old_h);\n\n    if (idx)\n        hts_idx_destroy(idx);\n\n    if (iter)\n        hts_itr_destroy(iter);\n\n    if (out)\n        sam_close(out);\n\n    if (new_h)\n        sam_hdr_destroy(new_h);\n\n    for (i = 1; i < nfn; ++i) {     //skip firstfile and close rest\n        if (files[i]) {\n            sam_close(files[i]);\n        }\n    }\n    free(files);\n    return ret;\n}\n\n/* ----------------------------------------------------------------------\n * BAM cat\n */\n#define BUF_SIZE 0x10000\n\n#define GZIPID1 31\n#define GZIPID2 139\n\n#define BGZF_EMPTY_BLOCK_SIZE 28\n\nint bam_cat(samFile * const firstfile, int nfn, char * const *fn, sam_hdr_t *h, const char* outbam, char *arg_list, int no_pg)\n{\n    BGZF *fp = NULL, *in = NULL;\n    uint8_t *buf = NULL;\n    uint8_t ebuf[BGZF_EMPTY_BLOCK_SIZE];\n    const int es=BGZF_EMPTY_BLOCK_SIZE;\n    int i;\n    samFile **files = NULL;\n    sam_hdr_t *new_h = NULL;\n\n    /* merges RG lines, opens all files and returns them that multiple non-seekable\n    stream inputs can be handled */\n    if (!(files = cat_check_merge_hdr(firstfile, nfn, fn, h, NULL, NULL, &new_h)))\n        return -1;\n    if (!new_h) {\n        print_error_errno(\"cat\", \"failed to make output header\");\n        goto fail;\n    }\n    fp = strcmp(outbam, \"-\")? bgzf_open(outbam, \"w\") : bgzf_fdopen(fileno(stdout), \"w\");\n    if (fp == 0) {\n        print_error_errno(\"cat\", \"fail to open output file '%s'\", outbam);\n        goto fail;\n    }\n\n    if (!no_pg && sam_hdr_add_pg(new_h, \"samtools\",\n                                    \"VN\", samtools_version(),\n                                    arg_list ? \"CL\": NULL,\n                                    arg_list ? arg_list : NULL,\n                                    NULL))\n        goto fail;\n\n    if (bam_hdr_write(fp, new_h) < 0) {\n        print_error_errno(\"cat\", \"Couldn't write header\");\n        goto fail;\n    }\n\n    buf = (uint8_t*) malloc(BUF_SIZE);\n    if (!buf) {\n        fprintf(stderr, \"[%s] Couldn't allocate buffer\\n\", __func__);\n        goto fail;\n    }\n    for(i = 0; i < nfn; ++i){\n        int len,j;\n        in = files[i]->fp.bgzf;\n        if (in == 0) {\n            print_error_errno(\"cat\", \"fail to open file '%s'\", fn[i]);\n            goto fail;\n        }\n        if (in->is_write) goto fail;\n\n        if (in->block_offset < in->block_length) {\n            if (bgzf_write(fp, (char *)in->uncompressed_block + in->block_offset, in->block_length - in->block_offset) < 0) goto write_fail;\n            if (bgzf_flush(fp) != 0) goto write_fail;\n        }\n\n        j=0;\n        while ((len = bgzf_raw_read(in, buf, BUF_SIZE)) > 0) {\n            if(len<es){\n                int diff=es-len;\n                if(j==0) {\n                    fprintf(stderr, \"[%s] ERROR: truncated file?: '%s'.\\n\", __func__, fn[i]);\n                    goto fail;\n                }\n                if (bgzf_raw_write(fp, ebuf, len) < 0) goto write_fail;\n\n                memcpy(ebuf,ebuf+len,diff);\n                memcpy(ebuf+diff,buf,len);\n            } else {\n                if(j!=0) {\n                    if (bgzf_raw_write(fp, ebuf, es) < 0) goto write_fail;\n                }\n                len-= es;\n                memcpy(ebuf,buf+len,es);\n                if (bgzf_raw_write(fp, buf, len) < 0) goto write_fail;\n            }\n            j=1;\n        }\n\n        /* check final gzip block */\n        {\n            const uint8_t gzip1=ebuf[0];\n            const uint8_t gzip2=ebuf[1];\n            const uint32_t isize=*((uint32_t*)(ebuf+es-4));\n            if(((gzip1!=GZIPID1) || (gzip2!=GZIPID2)) || (isize!=0)) {\n                fprintf(stderr, \"[%s] WARNING: Unexpected block structure in file '%s'.\", __func__, fn[i]);\n                fprintf(stderr, \" Possible output corruption.\\n\");\n                if (bgzf_raw_write(fp, ebuf, es) < 0) goto write_fail;\n            }\n        }\n        in = NULL;\n    }\n    free(buf);\n    if (bgzf_close(fp) < 0) {\n        fprintf(stderr, \"[%s] Error on closing '%s'.\\n\", __func__, outbam);\n        goto fail;\n    }\n    for (i = 1; i < nfn; ++i) {     //skip firstfile and close rest\n        if (files[i]) {\n            sam_close(files[i]);\n        }\n    }\n    free(files);\n    sam_hdr_destroy(new_h);\n    return 0;\n\n write_fail:\n    fprintf(stderr, \"[%s] Error writing to '%s'.\\n\", __func__, outbam);\n fail:\n    if (new_h) {\n        sam_hdr_destroy(new_h);\n    }\n    if (fp) bgzf_close(fp);\n    free(buf);\n\n    if (files) {\n        for(i = 1; i < nfn; ++i) {  //except the firstfile\n            if(files[i]) {\n                sam_close(files[i]);\n            }\n        }\n        free(files);\n    }\n    return -1;\n}\n\nint main_cat(int argc, char *argv[])\n{\n    sam_hdr_t *h = 0;\n    char *outfn = 0;\n    char **infns = NULL; // files to concatenate\n    int infns_size = 0;\n    int c, ret = 0, no_pg = 0, usage = 0, query_ncont = 0, fast_mode = 0;\n    samFile *in;\n    sam_global_args ga;\n    char *reg = NULL, *part = NULL;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', '-', '-', 0, '-', '-'),\n        {\"no-PG\", no_argument, NULL, 1},\n        { NULL, 0, NULL, 0 }\n    };\n\n    char *arg_list = NULL;\n\n    sam_global_args_init(&ga);\n    while ((c = getopt_long(argc, argv, \"h:o:b:r:p:qf\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'h': {\n                samFile *fph = sam_open(optarg, \"r\");\n                if (fph == 0) {\n                    fprintf(stderr, \"[%s] ERROR: fail to read the header from '%s'.\\n\", __func__, optarg);\n                    ret = 1;\n                    goto end;\n                }\n                h = sam_hdr_read(fph);\n                if (h == NULL) {\n                    fprintf(stderr,\n                            \"[%s] ERROR: failed to read the header from '%s'.\\n\",\n                            __func__, optarg);\n                    ret = 1;\n                    goto end;\n                }\n                sam_close(fph);\n                break;\n            }\n            case 'o': outfn = strdup(optarg); break;\n            case 'b': {\n                // add file names in \"optarg\" to the list\n                // of files to concatenate\n                int nfns;\n                char **fns_read = hts_readlines(optarg, &nfns);\n                if (fns_read) {\n                    infns = realloc(infns, (infns_size + nfns) * sizeof(char*));\n                    if (infns == NULL) { ret = 1; goto end; }\n                    memcpy(infns+infns_size, fns_read, nfns * sizeof(char*));\n                    infns_size += nfns;\n                    free(fns_read);\n                } else {\n                    print_error(\"cat\", \"Invalid file list \\\"%s\\\"\", optarg);\n                    ret = 1;\n                }\n                break;\n            }\n            case 1:\n                no_pg = 1;\n                break;\n            case 'r':\n                reg = optarg;\n                break;\n            case 'p':\n                part = optarg;\n                break;\n            case 'f':\n                fast_mode = 1;\n                break;\n            case 'q':\n                query_ncont=1;\n                break;\n\n            default:\n                if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                /* else fall-through */\n            case '?': usage=1; break;\n        }\n    }\n\n    if (!no_pg && !(arg_list = stringify_argv(argc+1, argv-1))) {\n        print_error(\"cat\", \"failed to create arg_list\");\n        ret = 1;\n        goto end;\n    }\n\n    // Append files specified in argv to the list.\n    int nargv_fns = argc - optind;\n    if (nargv_fns > 0) {\n        infns = realloc(infns, (infns_size + nargv_fns) * sizeof(char*));\n        if (infns == NULL) { ret = 1; goto end; }\n        memcpy(infns + infns_size, argv + optind, nargv_fns * sizeof(char*));\n    }\n\n    // Require at least one input file\n    if (infns_size + nargv_fns == 0 || usage) {\n        fprintf(stderr, \"Usage: samtools cat [options] <in1.bam>  [... <inN.bam>]\\n\");\n        fprintf(stderr, \"       samtools cat [options] <in1.cram> [... <inN.cram>]\\n\\n\");\n        fprintf(stderr, \"Concatenate BAM or CRAM files, first those in <bamlist.fofn>, then those\\non the command line.\\n\\n\");\n        fprintf(stderr, \"Options: -b FILE  list of input BAM/CRAM file names, one per line\\n\");\n        fprintf(stderr, \"         -h FILE  copy the header from FILE [default is 1st input file]\\n\");\n        fprintf(stderr, \"         -o FILE  output BAM/CRAM\\n\");\n        fprintf(stderr, \"         --no-PG  do not add a PG line\\n\");\n        fprintf(stderr, \"\\nCRAM only options for filtering:\\n\");\n        fprintf(stderr, \"         -r REG   filter to region REG.\\n\");\n        fprintf(stderr, \"                  REG can also be #:cstart-cend for specific container numbers\\n\");\n        fprintf(stderr, \"         -p N/M   Specify part N of M (where N is 1 to M inclusive)\\n\");\n        fprintf(stderr, \"         -f       Fast mode: don't filter containers to exactly match region\\n\");\n        fprintf(stderr, \"         -q       Query the total number of indexed containers\\n\");\n        fprintf(stderr, \"\\nStandard options:\\n\");\n        sam_global_opt_help(stderr, \"---.---.\");\n        ret = 1;\n        goto end;\n    }\n\n    in = sam_open(infns[0], \"r\");\n    if (!in) {\n        print_error_errno(\"cat\", \"failed to open file '%s'\", infns[0]);\n        ret = 1;\n        goto end;\n    }\n\n    switch (hts_get_format(in)->format) {\n    case bam:\n        if (bam_cat(in, infns_size+nargv_fns, infns, h, outfn? outfn : \"-\", arg_list, no_pg) < 0)\n            ret = 1;\n        break;\n\n    case cram:\n        if (query_ncont) {\n            if (cram_query_ncont(infns_size+nargv_fns, infns, reg) < 0)\n                ret = 1;\n        } else {\n            if (cram_cat(in, infns_size+nargv_fns, infns, h,\n                         outfn? outfn : \"-\", &ga, arg_list, no_pg, reg,\n                         part, fast_mode) < 0)\n            ret = 1;\n        }\n        break;\n\n    default:\n        fprintf(stderr, \"[%s] ERROR: input is not BAM or CRAM\\n\", __func__);\n        ret = 1;\n    }\n    sam_close(in);\n\n end:\n    if (infns_size > 0) {\n        int i;\n        for (i=0; i<infns_size; i++)\n            free(infns[i]);\n    }\n\n    free(outfn);\n    free(infns);\n    free(arg_list);\n    if (h)\n        sam_hdr_destroy(h);\n    sam_global_args_free(&ga);\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_checksum.c",
          "type": "blob",
          "size": 42.2431640625,
          "content": "/*  bam_checksum.c -- produces checksums on SAM/BAM/CRAM/FASTA/FASTQ data\n\n    Copyright (C) 2024 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n/*\n * This is inspired by Biobambam's bamseqchksum tool written by\n * David Jackson and amended by German Tischler.\n *\n * It computes order agnostic checksums for a variety of SAM fields, allowing\n * validation that all the data is still present at different stages of an\n * analysis pipeline.  This may be useful to detect sequences which have been\n * lost by an aligner, memory corruptions flipping individual sequence bases,\n * or file format decoding errors.\n *\n * We start with something basic such as a FASTQ file, and name, seq and qual\n * checksums should still all match after aligning and sorting.\n */\n\n#include <config.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <htslib/sam.h>\n#include <htslib/khash.h>\n#include <htslib/kstring.h>\n#include <htslib/hts_endian.h>\n\n#include \"sam_opts.h\"\n#include \"sam_utils.h\"\n#include \"samtools.h\"\n\ntypedef struct {\n    int req_flags, excl_flags;  // BAM flags filtering\n    int flag_mask, rev_comp, in_order, sanitize;\n    int check_pos, check_cigar, check_mate;\n    char *tag_str; // X,Y,Z or \"*,X,Y,Z\" for negation\n    char *tag_free;// copy of tag_str if non-literal\n    char **tags;   // parsed and split tag_str\n    int ntags;\n    int64_t nrec;\n    int verbose;   // whether to show zero count lines\n    int show_pass; // show pass stats\n    int show_fail; // show fail stats\n    int show_combine; // show the combine column\n    FILE *fp;\n    int tabs;\n    int merge;     // merge checksum output, rather than read BAM et al.\n    int compat;    // compatibility with bamseqchksum format\n} opts;\n\n/* ----------------------------------------------------------------------\n * Utility functions.  Possible candidates for moving to htslib?\n */\n\n// Note: qual+33 is a pain, but only for the benefit of compatability with\n// biobambam's bamseqchksum.  It's also wrong for QUAL \"*\" as it triggers a\n// wraparound and turning from BAM's 0xff-run to ASCII makes no sense in a\n// checksum.\n\n#if 1\n// Nibble at a time.  This could be sped up further.  Eg see htslib's simd.c.\n// That code ought to be expanded upon and exposed from htslib.\n//\n// However this is still 2.4x quicker than the naive implementation below\n// It's now around 8% of CPU for a NovaSeq BAM, so some optimisation is\n// possible but we're at deminishing returns.\nvoid fill_seq_qual(opts *o, bam1_t *b, uint8_t *restrict seq_buf,\n                   uint8_t *restrict qual_buf) {\n    // Tables mapping a pair of nibbles to a pair of ASCII bytes\n    static const char code2fwdbase[512] =\n        \"===A=C=M=G=R=S=V=T=W=Y=H=K=D=B=N\"\n        \"A=AAACAMAGARASAVATAWAYAHAKADABAN\"\n        \"C=CACCCMCGCRCSCVCTCWCYCHCKCDCBCN\"\n        \"M=MAMCMMMGMRMSMVMTMWMYMHMKMDMBMN\"\n        \"G=GAGCGMGGGRGSGVGTGWGYGHGKGDGBGN\"\n        \"R=RARCRMRGRRRSRVRTRWRYRHRKRDRBRN\"\n        \"S=SASCSMSGSRSSSVSTSWSYSHSKSDSBSN\"\n        \"V=VAVCVMVGVRVSVVVTVWVYVHVKVDVBVN\"\n        \"T=TATCTMTGTRTSTVTTTWTYTHTKTDTBTN\"\n        \"W=WAWCWMWGWRWSWVWTWWWYWHWKWDWBWN\"\n        \"Y=YAYCYMYGYRYSYVYTYWYYYHYKYDYBYN\"\n        \"H=HAHCHMHGHRHSHVHTHWHYHHHKHDHBHN\"\n        \"K=KAKCKMKGKRKSKVKTKWKYKHKKKDKBKN\"\n        \"D=DADCDMDGDRDSDVDTDWDYDHDKDDDBDN\"\n        \"B=BABCBMBGBRBSBVBTBWBYBHBKBDBBBN\"\n        \"N=NANCNMNGNRNSNVNTNWNYNHNKNDNBNN\";\n\n    static const char code2revbase[512] =\n        \"==T=G=K=C=Y=S=B=A=W=R=D=M=H=V=N=\"\n        \"=TTTGTKTCTYTSTBTATWTRTDTMTHTVTNT\"\n        \"=GTGGGKGCGYGSGBGAGWGRGDGMGHGVGNG\"\n        \"=KTKGKKKCKYKSKBKAKWKRKDKMKHKVKNK\"\n        \"=CTCGCKCCCYCSCBCACWCRCDCMCHCVCNC\"\n        \"=YTYGYKYCYYYSYBYAYWYRYDYMYHYVYNY\"\n        \"=STSGSKSCSYSSSBSASWSRSDSMSHSVSNS\"\n        \"=BTBGBKBCBYBSBBBABWBRBDBMBHBVBNB\"\n        \"=ATAGAKACAYASABAAAWARADAMAHAVANA\"\n        \"=WTWGWKWCWYWSWBWAWWWRWDWMWHWVWNW\"\n        \"=RTRGRKRCRYRSRBRARWRRRDRMRHRVRNR\"\n        \"=DTDGDKDCDYDSDBDADWDRDDDMDHDVDND\"\n        \"=MTMGMKMCMYMSMBMAMWMRMDMMMHMVMNM\"\n        \"=HTHGHKHCHYHSHBHAHWHRHDHMHHHVHNH\"\n        \"=VTVGVKVCVYVSVBVAVWVRVDVMVHVVVNV\"\n        \"=NTNGNKNCNYNSNBNANWNRNDNMNHNVNNN\";\n\n    uint8_t *seq = bam_get_seq(b);\n    uint8_t *qual = bam_get_qual(b);\n\n    if ((b->core.flag & BAM_FREVERSE) && o->rev_comp) {\n        int i, j, len2 = b->core.l_qseq & ~1;\n        for (i=0, j=b->core.l_qseq-1; i < len2; i+=2, j-=2) {\n            memcpy(&seq_buf[j-1], &code2revbase[(size_t)seq[i>>1]*2], 2);\n            qual_buf[j-0] = qual[i+0]+33;\n            qual_buf[j-1] = qual[i+1]+33;\n        }\n        if (i < b->core.l_qseq) {\n            seq_buf[j] = \"=TGKCYSBAWRDMHVN\"[bam_seqi(seq, i)];\n            qual_buf[j] = qual[i]+33;\n        }\n    } else {\n        int i, j, len2 = b->core.l_qseq & ~1;\n        for (i = j = 0; i < len2; i+=2, j++) {\n            // Note size_t cast helps gcc optimiser.\n            memcpy(&seq_buf[i], &code2fwdbase[(size_t)seq[j]*2], 2);\n            // Simple, but a union approach is a little faster with clang.\n            qual_buf[i+0] = qual[i+0]+33;\n            qual_buf[i+1] = qual[i+1]+33;\n        }\n        if (i < b->core.l_qseq) {\n            seq_buf[i] = seq_nt16_str[bam_seqi(seq, i)];\n            qual_buf[i] = qual[i]+33;\n        }\n    }\n}\n\n#else\n// Simple version\nvoid fill_seq_qual(opts *o, bam1_t *b, uint8_t *restrict seq_buf,\n                   uint8_t *restrict qual_buf) {\n    uint8_t *seq = bam_get_seq(b);\n    uint8_t *qual = bam_get_qual(b);\n\n    if ((b->core.flag & BAM_FREVERSE) && o->rev_comp) {\n        for (int i=0, j=b->core.l_qseq-1; i < b->core.l_qseq; i++,j--) {\n            seq_buf[j] = \"=TGKCYSBAWRDMHVN\"[bam_seqi(seq, i)];\n            qual_buf[j] = qual[i]+33;\n        }\n    } else {\n        for (int i = 0; i < b->core.l_qseq; i++) {\n            seq_buf[i] = seq_nt16_str[bam_seqi(seq, i)];\n            qual_buf[i] = qual[i]+33;\n        }\n    }\n}\n#endif\n\n\n/* ----------------------------------------------------------------------\n * Checksum aggregation\n */\n\n/*\n * The hash is multiplicative within a finite field, modulo PRIME.\n * We need to avoid zeros, and the data type has to be large enough to ensure\n * no wraparound happens (other than the intended modulo).\n *\n * A simpler version would be (hash + crc) % PRIME, but we use the\n * multiplicative version to keep compatibility with biobambam2.\n */\n#define PRIME ((1u<<31)-1)\nuint64_t update_hash(uint64_t hash, uint32_t crc) {\n    crc &= PRIME;\n    if (crc == 0 || crc == PRIME)\n        crc = 1;\n\n    return (hash * crc) % PRIME;\n}\n\ntypedef struct {\n    uint64_t seq[3];   // flag + seq\n    uint64_t name[3];  // name + flag + seq\n    uint64_t qual[3];  // flag + seq + qual\n    uint64_t aux[3];   // flag + seq + aux\n    uint64_t pos[3];   // flag + seq + chr/pos\n    uint64_t cigar[3]; // flag + seq + cigar\n    uint64_t mate[3];  // flag + seq + rnext/pnext/tlen\n    uint64_t count[3];\n} sums_t;\n\ntypedef struct {\n    uint32_t seq;\n    uint32_t name;\n    uint32_t qual;\n    uint32_t aux;\n    uint32_t pos;\n    uint32_t cigar;\n    uint32_t mate;\n} crcs_t;\n\nKHASH_MAP_INIT_STR(chk, sums_t)\n\n// Initialise the sums.  To 1 as we're multiplying and 0 is banned.\n// (Except count which is literally just a counter)\nvoid sums_init(sums_t *h32) {\n    for (int i = 0; i < 3; i++) {\n        h32->seq[i]   = 1;\n        h32->name[i]  = 1;\n        h32->qual[i]  = 1;\n        h32->aux[i]   = 1;\n        h32->pos[i]   = 1;\n        h32->cigar[i] = 1;\n        h32->mate[i]  = 1;\n        h32->count[i] = 0;\n    }\n}\n\n// Updates a single row in the checksum output\nvoid sums_update_row(int row, sums_t *h32, const crcs_t *c,\n                     uint32_t count_crc, uint64_t n) {\n    h32->seq[row]  = update_hash(h32->seq[row],  count_crc ^ c->seq);\n    h32->name[row] = update_hash(h32->name[row], count_crc ^ c->name);\n    h32->qual[row] = update_hash(h32->qual[row], count_crc ^ c->qual);\n    h32->aux[row]  = update_hash(h32->aux[row],  count_crc ^ c->aux);\n    h32->pos[row]  = update_hash(h32->pos[row],  count_crc ^ c->pos);\n    h32->cigar[row]= update_hash(h32->cigar[row],count_crc ^ c->cigar);\n    h32->mate[row] = update_hash(h32->mate[row], count_crc ^ c->mate);\n    h32->count[row] += n;\n}\n\n// Updates a single group, with all/pass or all/fail rows.  Also handles the\n// in_order modes.\nvoid sums_update(int qcfail, sums_t *h32, const crcs_t *crcs, opts *o,\n                 uint64_t count) {\n    uint32_t count_crc = 0;\n    if (o->in_order) {\n        uint8_t c[8];\n        u64_to_le(o->in_order == 1 ? count : h32->count[0], c);\n        count_crc = hts_crc32(0, c, 8);\n    }\n\n    sums_update_row(0, h32, crcs, count_crc, 1);\n    if (o->show_pass && !qcfail)\n        sums_update_row(1, h32, crcs, count_crc, 1);\n    if (o->show_fail && qcfail)\n        sums_update_row(2, h32, crcs, count_crc, 1);\n}\n\n// Report single group (all, pass, fail)\nvoid sums_report(opts *o, sums_t *h32, const char *set) {\n    for (int r = 0; r <= 2; r++) {\n        uint64_t hc = 1;\n        char *pass[] = {\"all\", \"pass\", \"fail\"};\n\n        if (r == 1 && !o->show_pass)\n            continue;\n        if (r == 2 && !o->show_fail)\n            continue;\n\n        if (!o->verbose && !h32->count[r])\n            continue;\n\n        if (o->tabs) {\n            fprintf(o->fp, \"%s\\t%s\\t%\"PRIu64\"\\t%s%\"PRIx64\"\\t%\"PRIx64\n                    \"\\t%\"PRIx64\"\\t%\"PRIx64, set, pass[r], h32->count[r],\n                    o->compat ? \"\\t\" : \"\",\n                    h32->seq[r], h32->name[r], h32->qual[r], h32->aux[r]);\n            if (o->check_pos)\n                fprintf(o->fp, \"\\t%\"PRIx64, h32->pos[r]);\n            if (o->check_cigar)\n                fprintf(o->fp, \"\\t%\"PRIx64, h32->cigar[r]);\n            if (o->check_mate)\n                fprintf(o->fp, \"\\t%\"PRIx64, h32->mate[r]);\n        } else {\n            fprintf(o->fp, \"%-10s %-4s %12\"PRIu64\"  %08\"PRIx64\"  %08\"PRIx64\n                    \"  %08\"PRIx64\"  %08\"PRIx64, set, pass[r], h32->count[r],\n                    h32->seq[r], h32->name[r], h32->qual[r], h32->aux[r]);\n            if (o->check_pos)\n                fprintf(o->fp, \"  %08\"PRIx64, h32->pos[r]);\n            if (o->check_cigar)\n                fprintf(o->fp, \"  %08\"PRIx64, h32->cigar[r]);\n            if (o->check_mate)\n                fprintf(o->fp, \"  %08\"PRIx64, h32->mate[r]);\n        }\n\n        // Merge all\n        hc = update_hash(hc, h32->count[r]>>32);\n        hc = update_hash(hc, h32->count[r] & 0xffffffff);\n        hc = update_hash(hc, h32->seq[r]);\n        hc = update_hash(hc, h32->name[r]);\n        hc = update_hash(hc, h32->seq[r]);\n        hc = update_hash(hc, h32->aux[r]);\n        if (o->check_pos)\n            hc = update_hash(hc, h32->pos[r]);\n        if (o->check_cigar)\n            hc = update_hash(hc, h32->cigar[r]);\n        if (o->check_mate)\n            hc = update_hash(hc, h32->mate[r]);\n\n        if (o->show_combine) {\n            if (o->tabs)\n                fprintf(o->fp, \"\\t%\"PRIx64\"\\n\", hc);\n            else\n                fprintf(o->fp, \"  %08\"PRIx64\"\\n\", hc);\n        } else {\n            fprintf(o->fp, \"\\n\");\n        }\n    }\n}\n\n/* ----------------------------------------------------------------------\n * Main checksumming algorithm\n */\n\n/*\n * Canonicalised integer tags.\n * We can store CcSsIi for unsigned and signed char, short and integer.\n * (This can also happen for B arrays, but we don't yet canonicalise these.)\n *\n * Unfortunately some BAMs have degenerate encs, eg XAs\\000\\001 for XA:s:1.\n * Also CRAM's computed NM can change, so NM:i:0 could be NMc0 or NMC0.\n *\n * Rules: unsigned if >= 0\n *        smallest encoding necessary\n *\n * Returns a tag pointer (possibly local static, or original ptr),\n *         plus rewrites *tag_len if needed.\n */\nuint8_t *canonical_tag(uint8_t *tag, size_t *tag_len) {\n    switch (tag[2]) {\n        static uint8_t ct[7], code;\n        int64_t val;\n\n    case 'C': case 'c':\n    case 'S': case 's':\n    case 'I': case 'i':\n        val = bam_aux2i(tag+2);\n        if (val >= 0) {\n            if      (val <= 255)   code = 'C';\n            else if (val <= 65535) code = 'S';\n            else                   code = 'I';\n        } else {\n            if      (val >= -128   && val <= 127)   code = 'c';\n            else if (val >= -32768 && val <= 32767) code = 's';\n            else                                    code = 'i';\n        }\n        if (code == tag[2])\n            // Already optimal.  The usual code path\n            return tag;\n\n        // Otherwise rewrite it;\n        ct[0] = tag[0];\n        ct[1] = tag[1];\n        ct[2] = code;\n        switch (code) {\n        case 'C': case 'c':\n            ct[3] = val;\n            *tag_len = 4;\n            break;\n\n        case 'S': case 's':\n            // Don't care about sign as it's defined anyway\n            u16_to_le(val, ct+3);\n            *tag_len = 5;\n            break;\n\n        case 'I': case 'i':\n            // Don't care about sign as it's defined anyway\n            u32_to_le(val, ct+3);\n            *tag_len = 7;\n            break;\n        }\n        return ct;\n\n    default:\n        return tag;\n    }\n}\n\n// Qsort callback, by integer\nstatic int tag_qsort(const void *t1, const void *t2) {\n    return *(const int *)t1 - *(const int *)t2;\n}\n\n/*\n * Produces a concatenated string of aux tags in <ID><TYPE><VAL> binary\n * representation,  with the tag names and orders defined in tag_ids[],\n * checksums it, and combines it with the flag-seq CRC.\n * If *tag_str is \"*\" then we negate tag_ids and encode everything but those.\n * This is a bit trickier as we can no longer use the order specified and\n * instead encode in ASCII sorted order instead.\n *\n * If the read-group is found in the RG:Z: aux, this is returned in\n * the *RGZ ptr (which points to the <VAL> field.\n *\n * Returns 0 on success, updating *crc_aux,\n *        -1 on error\n */\nint hash_aux(bam1_t *b, kstring_t *ks, int ntags,\n             char **tag_ids,\n             uint8_t **tag_ptr, size_t *tag_len,\n             const char *tag_str, short (*tag_keep)[75],\n             uint32_t crc_seq, uint32_t *crc_aux,\n             uint8_t **RGZ) {\n    size_t aux_len = bam_get_l_aux(b);\n    // 1 byte minimum forces a non-NULL pointer so CRC works\n    if (ks_resize(ks, aux_len+1) < 0)\n        return -1;\n    uint8_t *aux_ptr = (uint8_t *)ks->s;\n\n    // Pass 1: find all tags to copy and their lengths\n    uint8_t *aux = bam_aux_first(b), *aux_next;\n    memset(tag_len, 0, ntags * sizeof(*tag_len));\n    int tag_id[4000]; // a-zA-Z0-9 is 62. 62^2 is 3844\n\n    if (*tag_str == '*') {\n        // All tags bar specific ones, in alphanumeric order.\n        // Select the tags by name on pass 1, then sort by name to get\n        // a canonical order, and finally concatenate tags in order.\n        ntags = 0;\n        while (aux) {\n            if (aux[-2] == 'R' && aux[-1] == 'G' && aux[0] == 'Z' && RGZ)\n                *RGZ = aux+1;\n            aux_next = bam_aux_next(b, aux);\n            if (!(aux[-2] >= '0' && aux[-2] <= 'z' &&\n                  aux[-1] >= '0' && aux[-1] <= 'z')) {\n                aux = aux_next;\n                continue; // skip illegal tag names\n            }\n            if (tag_keep[aux[-2]-'0'][aux[-1]-'0'] == 0) {\n                size_t tag_sz = aux_next\n                    ? aux_next - aux\n                    : b->data + b->l_data - aux + 2;\n                tag_id[ntags] = (aux[-2]<<24) | (aux[-1]<<16) | ntags;\n                tag_ptr[ntags] = aux-2;\n                tag_len[ntags] = tag_sz;\n                if (++ntags >= 4000)\n                    return -1;\n            }\n\n            aux = aux_next;\n        }\n\n        // Sort\n        qsort(tag_id, ntags, sizeof(*tag_id), tag_qsort);\n\n        // Now we have tag_ptr2 in order of occurrence and tag_id in\n        // lexicalgraphical order.  Stitch together\n        for (int i = 0; i < ntags; i++) {\n            int orig_pos = tag_id[i]&0xffff;\n            size_t len = tag_len[orig_pos];\n            uint8_t *tag = canonical_tag(tag_ptr[orig_pos], &len);\n            memcpy(aux_ptr, tag, len);\n            aux_ptr += len;\n        }\n\n    } else {\n        // Selected tags only, in the order requested\n        while (aux) {\n            if (aux[-2] == 'R' && aux[-1] == 'G' && aux[0] == 'Z' && RGZ)\n                *RGZ = aux+1;\n            aux_next = bam_aux_next(b, aux);\n            if (!(aux[-2] >= '0' && aux[-2] <= 'z' &&\n                  aux[-1] >= '0' && aux[-1] <= 'z'))\n                continue; // skip illegal tag names\n            int i = tag_keep[aux[-2]-'0'][aux[-1]-'0']-1;\n            if (i>=0) {\n                // found one\n                size_t tag_sz = aux_next\n                    ? aux_next - aux\n                    : b->data + b->l_data - aux + 2;\n\n                tag_ptr[i] = aux-2;\n                tag_len[i] = tag_sz;\n            }\n\n            aux = aux_next;\n        }\n\n        // Pass 2: copy tags in the order we requested\n        for (int i = 0; i < ntags; i++) {\n            if (tag_len[i]) {\n                size_t len = tag_len[i];\n                uint8_t *tag = canonical_tag(tag_ptr[i], &len);\n                memcpy(aux_ptr, tag, len);\n                aux_ptr += len;\n            }\n        }\n    }\n\n    //write(3, (uint8_t *)ks->s, aux_ptr - (uint8_t *)ks->s);\n    *crc_aux = hts_crc32(crc_seq, ks->s, aux_ptr - (uint8_t *)ks->s);\n\n    return 0;\n}\n\n// Qsort callback, by kh_key(h,idx).\n// Needs a global due to the rubbish interface of qsort, but that's fine\n// as we're not multi-threaded.\nstatic khash_t(chk) *key_qsort_h = NULL;\nstatic int key_qsort(const void *t1, const void *t2) {\n    return strcmp(kh_key(key_qsort_h, *(const khiter_t *)t1),\n                  kh_key(key_qsort_h, *(const khiter_t *)t2));\n}\n\n// Compatibility with biobambam2's bamseqchksum output format\nint checksum_bamseqchksum(opts *o, sums_t *all, sums_t *noRG, khash_t(chk) *h){\n    // Why two tabs after count?\n    fprintf(o->fp, \"###\\tset\\tcount\\t\\tb_seq\\tname_b_seq\\tb_seq_qual\\tb_seq_tags(BC,FI,QT,RT,TC)\\n\");\n\n    o->tabs = 1;\n    o->show_pass = 1;\n    o->verbose = 1;\n    o->show_combine = 0;\n    sums_report(o, all,  \"all\");\n    sums_report(o, noRG,  \"\");\n\n    // Per read-group line\n    int nrgs = 0;\n    khiter_t *rgs = malloc(kh_size(h) * sizeof(*rgs));\n    if (!rgs)\n        return -1;\n\n    for (khiter_t k = kh_begin(h); k != kh_end(h); k++)\n        if (kh_exist(h, k))\n            rgs[nrgs++] = k;\n\n    key_qsort_h = h; // Use a global to avoid extra hash lookups here\n    qsort(rgs, nrgs, sizeof(*rgs), key_qsort);\n    for (int k = 0; k < nrgs; k++)\n        sums_report(o, &kh_value(h, rgs[k]), kh_key(h, rgs[k]));\n\n    free(rgs);\n\n    return 0;\n}\n\nint checksum_report(char *fn, opts *o,\n                    sums_t *all, sums_t *noRG, khash_t(chk) *h) {\n    if (o->compat)\n        return checksum_bamseqchksum(o, all, noRG, h);\n\n    // headers\n    fprintf(o->fp, \"# Checksum 1.0 for file:%s%s\\n\",\n            o->tabs ? \"\\t\" : \" \", fn);\n    fprintf(o->fp, \"# Aux tags:%s%s\\n\",\n            o->tabs ? \"\\t\" : \"          \", o->tag_str);\n    char *s=bam_flag2str(o->flag_mask);\n    if (!s)\n        return -1;\n    fprintf(o->fp, \"# BAM flags:%s%s\\n\",\n            o->tabs ? \"\\t\" : \"         \", s);\n    free(s);\n    if (o->tabs)\n        fprintf(o->fp, \"\\n# Group\\tQC\\tcount\\tflag+seq\\t+name\\t+qual\\t+aux\");\n    else\n        fprintf(o->fp, \"\\n# Group    QC          count  flag+seq  +name\"\n                \"     +qual     +aux    \");\n    if (o->check_pos)\n        fprintf(o->fp, o->tabs ? \"\\t+chr/pos\" : \"  +chr/pos\");\n    if (o->check_cigar)\n        fprintf(o->fp, o->tabs ? \"\\t+cigar\" : \"  +cigar  \");\n    if (o->check_mate)\n        fprintf(o->fp, o->tabs ? \"\\t+mate\" : \"  +mate   \");\n    fprintf(o->fp, o->tabs ? \"\\tcombined\\n\" : \"  combined\\n\");\n\n    // All and \"-\" (no RG) lines\n    sums_report(o, all,  \"all\");\n    if (o->verbose || (noRG->count[0] + noRG->count[1]))\n        sums_report(o, noRG,  \"-\");\n\n    // Per read-group line\n    int nrgs = 0;\n    khiter_t *rgs = malloc(kh_size(h) * sizeof(*rgs));\n    if (!rgs)\n        return -1;\n\n    for (khiter_t k = kh_begin(h); k != kh_end(h); k++)\n        if (kh_exist(h, k))\n            rgs[nrgs++] = k;\n\n    key_qsort_h = h; // Use a global to avoid extra hash lookups here\n    qsort(rgs, nrgs, sizeof(*rgs), key_qsort);\n    for (int k = 0; k < nrgs; k++)\n        sums_report(o, &kh_value(h, rgs[k]), kh_key(h, rgs[k]));\n\n    free(rgs);\n\n    return 0;\n}\n\nint checksum(sam_global_args *ga, opts *o, char *fn) {\n    samFile *fp = NULL;\n    sam_hdr_t *hdr = NULL;\n    bam1_t *b = bam_init1();\n    char **tags = o->tags;\n    int ntags = o->ntags;\n    uint8_t **tag_ptr = calloc(65536, sizeof(*tag_ptr));\n    size_t   *tag_len = calloc(65536, sizeof(*tag_len));\n    kstring_t aux_ks  = KS_INITIALIZE;\n    kstring_t seq_ks  = KS_INITIALIZE;\n    kstring_t qual_ks = KS_INITIALIZE;\n    khash_t(chk) *h = kh_init(chk);\n    int ret = -1;\n    int64_t nrec = o->nrec;\n\n    if (!b || !tag_ptr || !tag_len || !h)\n        goto err;\n\n//#undef HTS_LITTLE_ENDIAN // uncomment this to validate / debug\n\n#ifndef HTS_LITTLE_ENDIAN\n    kstring_t cigar_ks = KS_INITIALIZE;\n#endif\n\n    // A precomputed lookup table to speed up selection of tags\n    short tag_keep[75][75] = {0}; // 'z' is 122, '0' is 48. 122-48+1 == 75\n    for (int i = 0; i < ntags; i++) {\n        char *t = tags[i];\n        if (t[0] != '*' &&\n            !(t[0] >= '0' && t[0] <= 'z' &&\n              t[1] >= '0' && t[1] <= 'z')) {\n            fprintf(stderr, \"[checksum] Illegal tag ID '%.2s'\\n\", t);\n            goto err;\n        }\n        if (t[0] != '*')\n            tag_keep[t[0]-'0'][t[1]-'0'] = i+1;\n    }\n\n    sums_t h32, noRG;\n    sums_init(&h32);\n    sums_init(&noRG);\n    uint32_t crc32_start = hts_crc32(0, NULL, 0);\n\n    fp = sam_open_format(fn, \"r\", &ga->in);\n    if (!fp) {\n        print_error_errno(\"checksum\", \"Cannot open input file \\\"%s\\\"\", fn);\n        goto err;\n    }\n\n    if (ga->nthreads > 0)\n        hts_set_threads(fp, ga->nthreads);\n\n    if (!(hdr = sam_hdr_read(fp)))\n        goto err;\n\n    int r;\n    while ((r = sam_read1(fp, hdr, b)) >= 0) {\n        crcs_t c;\n\n        if (b->core.flag & o->excl_flags)\n            continue;\n\n        if ((b->core.flag & o->req_flags) != o->req_flags)\n            continue;\n\n        if (o->sanitize)\n            bam_sanitize(hdr, b, o->sanitize);\n\n        // 8 bits of flag corresponding to original instrument data\n        uint8_t flags = b->core.flag & o->flag_mask;\n\n        // Copy sequence out from nibble to base, and reverse complement\n        // seq / qual if required.  Qual is +33 (ASCII format) only for\n        // compatibility with biobambam's bamseqchksum tool.\n        // The +1 here and elsewhere is to force zero byte allocations to\n        // always return a pointer rather than NULL.  This in turn prevents\n        // crc32() from considering it as a reinitialisation.\n        if (ks_resize(&seq_ks, b->core.l_qseq+1) < 0 ||\n            ks_resize(&qual_ks, b->core.l_qseq+1) < 0)\n            goto err;\n\n        fill_seq_qual(o, b, (uint8_t *)seq_ks.s, (uint8_t *)qual_ks.s);\n\n        // flag + seq\n        uint32_t crc = hts_crc32(crc32_start, &flags, 1);\n        c.seq = hts_crc32(crc, seq_ks.s, b->core.l_qseq);\n\n        // name + flag + seq.\n        // flag + seq + name would be faster, but bamseqchksum does this.\n        // Also include single nul for compatibility too.\n        crc = hts_crc32(crc32_start, bam_get_qname(b),\n                        b->core.l_qname - b->core.l_extranul);\n        crc = hts_crc32(crc, &flags, 1);\n        c.name = hts_crc32(crc, seq_ks.s, b->core.l_qseq);\n\n        // flag + seq + qual\n        c.qual = hts_crc32(c.seq, qual_ks.s, b->core.l_qseq);\n\n        // flag + seq + aux tags\n        uint8_t *RGZ = NULL;\n        if (hash_aux(b, &aux_ks, ntags, tags, tag_ptr, tag_len,\n                     o->tag_str, tag_keep, c.seq, &c.aux, &RGZ) < 0)\n            goto err;\n\n        // flag + seq + chr + pos\n        if (o->check_pos) {\n            uint8_t chr_pos[4+8];\n            u32_to_le(b->core.tid, chr_pos);\n            u64_to_le(b->core.pos, chr_pos+4);\n            c.pos = hts_crc32(c.seq, chr_pos, 12);\n        }\n\n        // flag + seq + rnext + pnext + tlen\n        if (o->check_mate) {\n            uint8_t mate[4+8+8];\n            u32_to_le(b->core.mtid,  mate);\n            u64_to_le(b->core.mpos,  mate+4);\n            u64_to_le(b->core.isize, mate+12);\n            c.mate = hts_crc32(c.seq, mate, 12);\n        }\n\n        // flag + seq + mapq + cigar\n        if (o->check_cigar) {\n            uint8_t *cigar = (uint8_t *)bam_get_cigar(b);\n#ifndef HTS_LITTLE_ENDIAN\n            if (ks_resize(&cigar_ks, 4 * b->core.n_cigar+1) < 0)\n                goto err;\n            uint32_t *cig32 = bam_get_cigar(b);\n            cigar = (uint8_t *)cigar_ks.s;\n\n            for (int i = 0; i < b->core.n_cigar; i++)\n                u32_to_le(cig32[i], cigar + 4*i);\n#endif\n            uint8_t mapq[4];\n            u32_to_le(b->core.qual, mapq);\n            c.cigar = hts_crc32(c.seq, mapq, 4);\n            c.cigar = hts_crc32(c.cigar, cigar, 4 * b->core.n_cigar);\n        }\n\n        // Aggregate checksum hashes\n        uint64_t count = h32.count[0];\n        if (RGZ) {\n            sums_t *h32p;\n\n            // create func\n            int kret;\n            khiter_t k = kh_get(chk, h, (char *)RGZ);\n            if (k == kh_end(h)) {\n                char *rgz_ = strdup((char *)RGZ);\n                if (!rgz_)\n                    goto err;\n                k = kh_put(chk, h, rgz_, &kret);\n                if (kret < 0) {\n                    free(rgz_);\n                    goto err;\n                }\n                sums_init(&kh_value(h, k));\n            }\n            h32p = &kh_value(h, k);\n\n            count = h32p->count[0];\n            sums_update(b->core.flag & BAM_FQCFAIL, h32p, &c, o, count);\n        } else {\n            count = noRG.count[0];\n            sums_update(b->core.flag & BAM_FQCFAIL, &noRG, &c, o, count);\n        }\n\n        sums_update(b->core.flag & BAM_FQCFAIL, &h32, &c, o, count);\n\n        if (nrec && --nrec == 0)\n            break;\n    }\n\n    if (r < -1)\n        goto err;\n\n    if (sam_close(fp) < 0) {\n        fp = NULL;\n        print_error_errno(\"checksum\", \"Closing input file \\\"%s\\\"\", fn);\n        goto err;\n    }\n    fp = NULL;\n\n    // Report hashes\n    if (checksum_report(fn, o, &h32, &noRG, h) < 0)\n        goto err;\n\n    ret = 0;\n err:\n    if (b)   bam_destroy1(b);\n    if (hdr) sam_hdr_destroy(hdr);\n    if (fp)  sam_close(fp);\n\n    free(tag_ptr);\n    free(tag_len);\n    ks_free(&aux_ks);\n    ks_free(&seq_ks);\n    ks_free(&qual_ks);\n#ifndef HTS_LITTLE_ENDIAN\n    ks_free(&cigar_ks);\n#endif\n\n    if (h) {\n        for (khiter_t k = kh_begin(h); k != kh_end(h); k++) {\n            if (!kh_exist(h, k))\n                continue;\n\n            free((char *)kh_key(h, k));\n        }\n        kh_destroy(chk, h);\n    }\n\n    return ret;\n}\n\n/* ----------------------------------------------------------------------\n * Checksum combining.  This is used to merge multiple checksum output files\n * from e.g. \"samtools split\" readgroup files, into a single combined\n * checksum to give the same result as doing a samtools merge | checksum.\n */\n\n// Process an individual file, aggregating to s, noRG and h\nstatic int sums_parse(opts *o, char *fn, sums_t *sums, sums_t *noRG,\n                      khash_t(chk) *h) {\n    int ret = -1;\n    FILE *fp;\n    if ((fp = fopen(fn, \"r\")) == NULL) {\n        perror(fn);\n        return -1;\n    }\n\n    kstring_t line = KS_INITIALIZE;\n    int nheader = 0;\n    enum {\n        H_GROUP, H_QC, H_COUNT, H_SEQ, H_NAME, H_QUAL, H_AUX,\n        H_POS, H_CIGAR, H_MATE, H_COMBINED\n    } header[11] = {-1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1};\n    crcs_t crcs = {1,1,1,1,1,1,1};\n\n    while (line.l = 0, kgetline(&line, (kgets_func *)fgets, fp) >= 0) {\n        if (strncmp(line.s, \"# Checksum\", 10) == 0) {\n            int major, minor;\n            if (sscanf(line.s, \"# Checksum %d.%d\", &major, &minor) == 2) {\n                if (major != 1 || minor != 0) {\n                    fprintf(stderr, \"Unsupported checksum output version\\n\");\n                    goto err;\n                }\n            }\n            continue;\n        }\n\n        if (strncmp(line.s, \"# Group\", 7) == 0) {\n            // Parse column header so we know which fields are present\n            int n, i = 0, idx;\n            char *ptr = line.s+2;\n            char token[20];\n            while ((n = sscanf(ptr, \"%19s%n\", token, &idx)) == 1) {\n                if (strcmp(token, \"Group\") == 0)\n                    header[i] = H_GROUP;\n                else if (strcmp(token, \"QC\") == 0)\n                    header[i] = H_QC;\n                else if (strcmp(token, \"count\") == 0)\n                    header[i] = H_COUNT;\n                else if (strcmp(token, \"flag+seq\") == 0)\n                    header[i] = H_SEQ;\n                else if (strcmp(token, \"+name\") == 0)\n                    header[i] = H_NAME;\n                else if (strcmp(token, \"+qual\") == 0)\n                    header[i] = H_QUAL;\n                else if (strcmp(token, \"+aux\") == 0)\n                    header[i] = H_AUX;\n                else if (strcmp(token, \"+chr/pos\") == 0)\n                    header[i] = H_POS, o->check_pos = 1;\n                else if (strcmp(token, \"+cigar\") == 0)\n                    header[i] = H_CIGAR, o->check_cigar = 1;\n                else if (strcmp(token, \"+mate\") == 0)\n                    header[i] = H_MATE, o->check_mate = 1;\n                else if (strcmp(token, \"combined\") == 0)\n                    header[i] = H_COMBINED;\n                else  {\n                    fprintf(stderr, \"Unrecognised header token '%s'\\n\", token);\n                    goto err;\n                }\n\n                i++;\n                ptr += idx;\n            }\n            nheader = i;\n\n            continue;\n        }\n\n        if (strncmp(line.s, \"# Aux\", 5) == 0) {\n            int idx;\n            char c;\n            if (sscanf(line.s, \"# Aux tags: %c%n\", &c, &idx) == 1)\n                if (!o->tag_str)\n                    o->tag_free = o->tag_str = strdup(line.s + idx-1);\n\n            continue;\n        }\n\n        if (strncmp(line.s, \"# BAM\", 5) == 0) {\n            int idx;\n            char c;\n            if (sscanf(line.s, \"# BAM flags: %c%n\", &c, &idx) == 1)\n                o->flag_mask = bam_str2flag(line.s + idx-1);\n\n            continue;\n        }\n\n        if (!line.l || *line.s == '#')\n            continue;\n\n\n        // Header done.  Now parse the data lines\n        if (strncmp(line.s, \"all \", 4) == 0 ||\n            strncmp(line.s, \"all\\t\", 4) == 0)\n            continue;\n\n        char col[11][128], *ptr = line.s;\n        int nf;\n        for (nf = 0; nf < 11; nf++) {\n            int idx;\n            int n = sscanf(ptr, \"%127s%n\", col[nf], &idx);\n            if (n <= 0)\n                break;\n            if (strlen(col[nf]) == 127) {\n                fprintf(stderr, \"Field too long\\n\");\n                goto err;\n            }\n            ptr += idx;\n        }\n\n        // Sanity check that header and rows match\n        if (nf < 8 || nf != nheader) {\n            fprintf(stderr, \"Incorrect number of columns in line: %s\\n\",\n                    line.s);\n            goto err;\n        }\n\n        // Marry up column header with row entries and set struct.\n        // (We could update the struct to be numbered instead of\n        // named in variables to make this easier.)\n        int qc = 0;\n        uint64_t count = 0;\n        for (int i = 0; i < nf; i++) {\n            switch (header[i]) {\n            case H_QC:\n                if (strcmp(col[i], \"all\") == 0)\n                    qc = 0;\n                else if (strcmp(col[i], \"pass\") == 0)\n                    qc = 1;\n                else if (strcmp(col[i], \"fail\") == 0)\n                    qc = 2;\n                else\n                    goto err;\n                break;\n\n            case H_COUNT:\n                count = strtoull(col[i], NULL, 10);\n                break;\n\n            case H_SEQ:\n                crcs.seq = strtoul(col[i], NULL, 16);\n                break;\n\n            case H_NAME:\n                crcs.name = strtoul(col[i], NULL, 16);\n                break;\n\n            case H_QUAL:\n                crcs.qual = strtoul(col[i], NULL, 16);\n                break;\n\n            case H_AUX:\n                crcs.aux = strtoul(col[i], NULL, 16);\n                break;\n\n            case H_POS:\n                crcs.pos = strtoul(col[i], NULL, 16);\n                break;\n\n            case H_CIGAR:\n                crcs.cigar = strtoul(col[i], NULL, 16);\n                break;\n\n            case H_MATE:\n                crcs.mate = strtoul(col[i], NULL, 16);\n                break;\n\n            default:\n                break;\n            }\n        }\n\n        // Add group entry\n        if (strcmp(col[0], \"-\") == 0) {\n            sums_update_row(qc, noRG, &crcs, 0, count);\n        } else {\n            int kret;\n            khiter_t k = kh_get(chk, h, col[0]);\n            if (k == kh_end(h)) {\n                char *rgz_ = strdup(col[0]);\n                if (!rgz_)\n                    goto err;\n                k = kh_put(chk, h, rgz_, &kret);\n                if (kret < 0) {\n                    free(rgz_);\n                    goto err;\n                }\n                sums_init(&kh_value(h, k));\n            }\n            sums_update_row(qc, &kh_value(h, k), &crcs, 0, count);\n        }\n\n        // Add to global \"all\" stats\n        sums_update_row(qc, sums, &crcs, 0, count);\n    }\n\n    ret = 0;\n\n err:\n    ks_free(&line);\n    fclose(fp);\n    return ret;\n}\n\n// Combine multiple checksum files together and report the merged stats\nint combine(opts *o, int argc, char **argv) {\n    int ret = -1;\n    sums_t s, noRG;\n    sums_init(&s);\n    sums_init(&noRG);\n\n    free(o->tag_free); // Probably NULL, but just incase\n    o->tag_free = o->tag_str = NULL;\n    khash_t(chk) *h = kh_init(chk);\n    if (!h)\n        goto err;\n    for (int i = 0; i < argc; i++) {\n        if (sums_parse(o, argv[i], &s, &noRG, h) < 0) {\n            fprintf(stderr, \"Failed to parse checksum file '%s'\\n\", argv[i]);\n            goto err;\n        }\n    }\n    checksum_report(\"merge\", o, &s, &noRG, h);\n\n    ret = 0;\n err:\n    free(o->tag_free);\n    o->tag_free = NULL;\n\n    if (h) {\n        for (khiter_t k = kh_begin(h); k != kh_end(h); k++) {\n            if (!kh_exist(h, k))\n                continue;\n\n            free((char *)kh_key(h, k));\n        }\n        kh_destroy(chk, h);\n    }\n\n    return ret;\n}\n\n/* ----------------------------------------------------------------------\n * CLI\n */\nvoid usage_exit(FILE *fp, int ret) {\n    fprintf(stderr, \"Usage: samtools checksum [options] [file.bam ...]\\n\");\n    fprintf(stderr, \"or     samtools checksum [options] -m [file.chk ...]\\n\\n\");\n    fprintf(stderr, \"Options:\\n\\\n  -F, --exclude-flags FLAG    Filter if any FLAGs are present [0x900]\\n\\\n  -f, --require-flags FLAG    Filter unless all FLAGs are present [0]\\n\\\n  -b, --flag-mask FLAG        BAM FLAGs to use in checksums [0x0c1]\\n\\\n  -c, --no-rev-comp           Do not reverse-complement sequences [off]\\n\\\n  -t, --tags STR[,STR]        Select tags to checksum [BC,FI,QT,RT,TC]\\n\\\n  -O, --in-order              Use order-specific checksumming [off]\\n\\\n  -P, --check-pos             Also checksum CHR / POS [off]\\n\\\n  -C, --check-cigar           Also checksum MAPQ / CIGAR [off]\\n\\\n  -M, --check_mate            Also checksum PNEXT / RNEXT / TLEN [off]\\n\\\n  -z, --sanitize FLAGS        Perform sanity checks and fix records [off]\\n\\\n  -N, --count INT             Stop after INT number of records [0]\\n\\\n  -o, --output FILE           Write report to FILE [stdout]\\n\\\n  -q, --show-qc               Also show QC pass/fail lines\\n\\\n  -v, --verbose               Increase verbosity: show lines with 0 counts\\n\\\n  -a, --all                   Check all: -PCMOc -b 0xfff -f0 -F0 -z all,cigarx\\n\\\n  -T, --tabs                  Format output as tab delimited text\\n\\\n  -m, --merge FILE            Merge checksum output (-o opt) files\\n\\\n  -B, --bamseqchksum          Report in bamseqchksum format\\n\");\n    fprintf(fp, \"\\nGlobal options:\\n\");\n    sam_global_opt_help(fp, \"-.---@--\");\n    exit(ret);\n}\n\nint parse_tags(opts *o) {\n    // Count\n    int nt = 0;\n    for (char *t = o->tag_str; *t; t++) {\n        nt++;\n        char *l = t;\n        while (*t && *t != ',')\n            t++;\n        if (t-l != 2 && !(t-l == 1 && *l == '*')) {\n            fprintf(stderr, \"Bad tag string.  Should be XX,YY,... syntax\\n\");\n            return 1;\n        }\n        if (!*t)\n            break;\n    }\n\n    // Split by tag\n    o->ntags = nt;\n    o->tags = calloc(nt, sizeof(*o->tags));\n    if (!o->tags)\n        return 1;\n\n    nt = 0;\n    for (char *t = o->tag_str; *t; t++, nt++) {\n        o->tags[nt] =  t;\n        while (*t && *t != ',')\n            t++;\n        if (!*t)\n            break;\n    }\n\n    return 0;\n}\n\n// Main command entry\nint main_checksum(int argc, char **argv) {\n    opts opts = {\n        .req_flags    = 0,\n        .excl_flags   = BAM_FSECONDARY | BAM_FSUPPLEMENTARY,\n        .flag_mask    = BAM_FPAIRED | BAM_FREAD1 | BAM_FREAD2,\n        .rev_comp     = 1,\n        .tag_str      = \"BC,FI,QT,RT,TC\",\n        .tag_free     = NULL,\n        .check_pos    = 0,\n        .check_cigar  = 0,\n        .check_mate   = 0,\n        .in_order     = 0,\n        .sanitize     = 0,\n        .nrec         = 0,\n        .verbose      = 0,\n        .show_pass    = 0,\n        .show_fail    = 0,\n        .show_combine = 1,\n        .fp           = stdout,\n        .tabs         = 0,\n        .merge        = 0,\n    };\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 'I', '-', '-', '.', '@'),\n        {\"--exclude-flags\", required_argument, NULL, 'F'},\n        {\"--require-flags\", required_argument, NULL, 'f'},\n        {\"--flag-mask\",     required_argument, NULL, 'b'},\n        {\"--tags\",          required_argument, NULL, 't'},\n        {\"--no-rev-comp\",   no_argument,       NULL, 'c'},\n        {\"--in-order\",      no_argument,       NULL, 'O'},\n        {\"--check-pos\",     no_argument,       NULL, 'P'},\n        {\"--check-cigar\",   no_argument,       NULL, 'C'},\n        {\"--check-mate\",    no_argument,       NULL, 'M'},\n        {\"--count\",         required_argument, NULL, 'N'},\n        {\"--sanitize\",      required_argument, NULL, 'z'},\n        {\"--output\",        required_argument, NULL, 'o'},\n        {\"--show-qc\",       no_argument,       NULL, 'q'},\n        {\"--verbose\",       no_argument,       NULL, 'v'},\n        {\"--all\",           no_argument,       NULL, 'a'},\n        {\"--tabs\",          no_argument,       NULL, 'T'},\n        {\"--merge\",         no_argument,       NULL, 'm'},\n        {\"--bamseqchksum\",  no_argument,       NULL, 'B'},\n        {NULL, 0, NULL, 0}\n    };\n\n    if (argc == 1 && isatty(STDIN_FILENO))\n        usage_exit(stdout, EXIT_SUCCESS);\n\n    int c;\n    while ((c = getopt_long(argc, argv, \"@:f:F:t:cPCMOb:z:aN:vqo:TmB\",\n                            lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'O':\n            opts.in_order++;\n            break;\n        case 'F':\n            if ((opts.excl_flags = bam_str2flag(optarg)) < 0) {\n                print_error(\"checksum\", \"could not parse flag %s\", optarg);\n                return 1;\n            }\n            break;\n        case 'f':\n            if ((opts.req_flags  = bam_str2flag(optarg)) < 0) {\n                print_error(\"checksum\", \"could not parse flag %s\", optarg);\n                return 1;\n            }\n            break;\n        case 'b':\n            if ((opts.flag_mask  = bam_str2flag(optarg)) < 0) {\n                print_error(\"checksum\", \"could not parse flag %s\", optarg);\n                return 1;\n            }\n            break;\n        case 'P':\n            opts.check_pos = 1;\n            break;\n        case 'C':\n            opts.check_cigar = 1;\n            break;\n        case 'M':\n            opts.check_mate = 1;\n            break;\n        case 't':\n            opts.tag_str = optarg;\n            break;\n        case 'c':\n            opts.rev_comp = 0;\n            break;\n        case 'N':\n            opts.nrec = strtoll(optarg, NULL, 0);\n            break;\n\n        case 'B':\n            opts.compat = 1;\n            opts.show_pass = 1;\n            break;\n        case 'v':\n            opts.verbose++;\n            break;\n        case 'q':\n            opts.show_pass = opts.show_fail = 1;\n            break;\n        case 'T':\n            opts.tabs = 1;\n            break;\n        case 'm':\n            opts.merge = 1;\n            break;\n\n        case 'z':\n            if ((opts.sanitize = bam_sanitize_options(optarg)) < 0)\n                return 1;\n            break;\n\n        case 'a':\n            // ALL: a shorthand for a bunch of options to checksum the entire\n            // file contents.  TODO: we still need tag wildcards.\n            opts.req_flags = 0;\n            opts.excl_flags = 0;\n            opts.flag_mask = -1;\n            opts.rev_comp = 0;\n            opts.in_order = 1;\n            opts.check_pos = 1;\n            opts.check_cigar = 1;\n            opts.check_mate = 1;\n            opts.sanitize = FIX_ALL | FIX_CIGARX;\n            opts.tag_str = \"*,cF,MD,NM\";\n            break;\n\n        case 'o':\n            opts.fp = fopen(optarg, \"w\");\n            if (!opts.fp) {\n                perror(optarg);\n                return 1;\n            }\n            break;\n\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0)\n                break;\n            /* else fall-through */\n        case '?':\n            usage_exit(stderr, EXIT_FAILURE);\n        }\n    }\n\n    if (!opts.tags) {\n        if (parse_tags(&opts) < 0)\n            return 1;\n    }\n\n    int ret = 0;\n    if (opts.merge) {\n        ret = combine(&opts, argc - optind, argv+optind);\n    } else {\n        if (argc-optind) {\n            while (optind < argc)\n                ret |= checksum(&ga, &opts, argv[optind++]) < 0;\n        } else {\n            ret = checksum(&ga, &opts, \"-\") < 0;\n        }\n    }\n\n    if (opts.fp != stdout)\n        ret |= fclose(opts.fp) < 0;\n\n    free(opts.tags);\n    free(opts.tag_free);\n\n    if (ret)\n        fprintf(stderr, \"[checksum] Failed to process data\\n\");\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_color.c",
          "type": "blob",
          "size": 4.8525390625,
          "content": "/*  bam_color.c -- color-space support.\n\n    Copyright (C) 2009, 2012 University of California - Los Angeles.\n\n    Author: Nils Homer <nilshomer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <ctype.h>\n#include <string.h>\n\n#include \"htslib/sam.h\"\n\n/*!\n @abstract     Get the color encoding the previous and current base\n @param b      pointer to an alignment\n @param i      The i-th position, 0-based\n @return       color\n\n @discussion   Returns 0 no color information is found.\n */\nchar bam_aux_getCSi(bam1_t *b, int i)\n{\n    uint8_t *c = bam_aux_get(b, \"CS\");\n    char *cs = NULL;\n\n    // return the base if the tag was not found\n    if(0 == c) return 0;\n\n    cs = bam_aux2Z(c);\n    // adjust for strandedness and leading adaptor\n    if(bam_is_rev(b)) {\n        i = strlen(cs) - 1 - i;\n        // adjust for leading hard clip\n        uint32_t cigar = bam_get_cigar(b)[0];\n        if((cigar & BAM_CIGAR_MASK) == BAM_CHARD_CLIP) {\n        i -= cigar >> BAM_CIGAR_SHIFT;\n        }\n    } else { i++; }\n    return cs[i];\n}\n\n/*!\n @abstract     Get the color quality of the color encoding the previous and current base\n @param b      pointer to an alignment\n @param i      The i-th position, 0-based\n @return       color quality\n\n @discussion   Returns 0 no color information is found.\n */\nchar bam_aux_getCQi(bam1_t *b, int i)\n{\n    uint8_t *c = bam_aux_get(b, \"CQ\");\n    char *cq = NULL;\n\n    // return the base if the tag was not found\n    if(0 == c) return 0;\n\n    cq = bam_aux2Z(c);\n    // adjust for strandedness\n    if(bam_is_rev(b)) {\n        i = strlen(cq) - 1 - i;\n        // adjust for leading hard clip\n        uint32_t cigar = bam_get_cigar(b)[0];\n        if((cigar & BAM_CIGAR_MASK) == BAM_CHARD_CLIP) {\n        i -= (cigar >> BAM_CIGAR_SHIFT);\n        }\n    }\n    return cq[i];\n}\n\nchar bam_aux_nt2int(char a)\n{\n    switch(toupper(a)) {\n        case 'A':\n            return 0;\n            break;\n        case 'C':\n            return 1;\n            break;\n        case 'G':\n            return 2;\n            break;\n        case 'T':\n            return 3;\n            break;\n        default:\n            return 4;\n            break;\n    }\n}\n\nchar bam_aux_ntnt2cs(char a, char b)\n{\n    a = bam_aux_nt2int(a);\n    b = bam_aux_nt2int(b);\n    if(4 == a || 4 == b) return '4';\n    return \"0123\"[(int)(a ^ b)];\n}\n\n/*!\n @abstract     Get the color error profile at the give position\n @param b      pointer to an alignment\n @return       the original color if the color was an error, '-' (dash) otherwise\n\n @discussion   Returns 0 no color information is found.\n */\nchar bam_aux_getCEi(bam1_t *b, int i)\n{\n    int cs_i;\n    uint8_t *c = bam_aux_get(b, \"CS\");\n    char *cs = NULL;\n    char prev_b, cur_b;\n    char cur_color, cor_color;\n\n    // return the base if the tag was not found\n    if(0 == c) return 0;\n\n    cs = bam_aux2Z(c);\n\n    // adjust for strandedness and leading adaptor\n    if(bam_is_rev(b)) { //reverse strand\n        cs_i = strlen(cs) - 1 - i;\n        // adjust for leading hard clip\n        uint32_t cigar = bam_get_cigar(b)[0];\n        if((cigar & BAM_CIGAR_MASK) == BAM_CHARD_CLIP) {\n            cs_i -= cigar >> BAM_CIGAR_SHIFT;\n        }\n        // get current color\n        cur_color = cs[cs_i];\n        // get previous base.  Note: must rc adaptor\n        prev_b = (cs_i == 1) ? \"TGCAN\"[(int)bam_aux_nt2int(cs[0])] : seq_nt16_str[bam_seqi(bam_get_seq(b), i+1)];\n        // get current base\n        cur_b = seq_nt16_str[bam_seqi(bam_get_seq(b), i)];\n    }\n    else {\n        cs_i=i+1;\n        // get current color\n        cur_color = cs[cs_i];\n        // get previous base\n        prev_b = (0 == i) ? cs[0] : seq_nt16_str[bam_seqi(bam_get_seq(b), i-1)];\n        // get current base\n        cur_b = seq_nt16_str[bam_seqi(bam_get_seq(b), i)];\n    }\n\n    // corrected color\n    cor_color = bam_aux_ntnt2cs(prev_b, cur_b);\n\n    if(cur_color == cor_color) {\n        return '-';\n    }\n    else {\n        return cur_color;\n    }\n}\n"
        },
        {
          "name": "bam_consensus.c",
          "type": "blob",
          "size": 97.916015625,
          "content": "/*  bam_consensus.c -- consensus subcommand.\n\n    Copyright (C) 1998-2001,2003 Medical Research Council (Gap4/5 source)\n    Copyright (C) 2003-2005,2007-2024 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nThe primary work here is GRL since 2021, under an MIT license.\nSections derived from Gap5, which include calculate_consensus_gap5()\nassociated functions, are mostly copyright Genome Research Limited from\n2003 onwards.  These were originally under a BSD license, but as GRL is\ncopyright holder these portions can be considered to also be under the\nsame MIT license below:\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n/*\n * The Gap5 consensus algorithm was in turn derived from the earlier Gap4\n * tool, developed by the Medical Research Council as part of the\n * Staden Package.  It is unsure how much of this source code is still\n * extant, without deep review, but the license used was a compatible\n * modified BSD license, included below.\n */\n\n/*\nModified BSD license for any legacy components from the Staden Package:\n\nCopyright (c) 2003 MEDICAL RESEARCH COUNCIL\nAll rights reserved\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n   . Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n   . Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n   . Neither the name of the MEDICAL RESEARCH COUNCIL, THE LABORATORY OF\nMOLECULAR BIOLOGY nor the names of its contributors may be used to endorse or\npromote products derived from this software without specific prior written\npermission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n// FIXME: also use strand to spot possible basecalling errors.\n//        Specifically het calls where mods are predominantly on one\n//        strand.  So maybe require + and - calls and check concordance\n//        before calling a het as confident.  (Still call, but low qual?)\n\n// TODO: call by kmers rather than individual bases?  Or use kmers to skew\n// quality at least.  It can identify variants that are low quality due to\n// neighbouring edits that aren't consistently correlated.\n\n// TODO: pileup callback ought to know when it's the last in the region /\n// chromosome.  This means the caller code doesn't have to handle the\n// termination phase and deduplicates the code.  (Changing from\n// one chr to the next is the same as ending the last.)\n//\n// TODO: track which reads contribute to multiple confirmed (HQ) differences\n// vs which contribute to only one (LQ) difference.  Correlated changes\n// are more likely to be real.  Ie consensus more of a path than solely\n// isolated columns.\n//\n// Either that or a dummy \"end of data\" call is made to signify end to\n// permit tidying up.  Maybe add a \"start of data\" call too?\n\n// Eg 50T 20A seems T/A het,\n// but 30T+ 20T- 18A+ 2A- seems like a consistent A miscall on one strand\n// only, while T is spread evenly across both strands.\n\n// TODO:  Phasing of long reads.\n// Long reads offer very strong phasing opportunities for SNPs.\n// From these, we get strong evidence for accuracy of indels.\n// Specifically whether the distribution of poly-len within a phases\n// is significantly different to the distribution of poly len between\n// phases.\n\n// TODO end STR trimming. Eg:\n// REF AAGCTGAAAAGTTAATGTCTTATTTTTTTTTTTTTTTTGAGATGGAGTC\n//     aagctgaaaagttaatgtctta****ttttttttttttgagatggagtc\n//     aagctgaaaagttaatgtcttattttttttt\n//     aagctgaaaagttaatgtctta****ttttttttttttgagatggagtc\n// Middle seq doesn't validate those initial T alignments.\n// Qual_train solves this by use of the STR trimmer.\n\n// TODO add a weight for proximity to homopolymer.\n// Maybe length/distance?  So 3 away from a 12-mer is similar to 1 away\n// from a 4-mer?\n\n// TODO: Count number of base types between this point and the nearest\n// indel or end of read.  Eg GATCG<here>AGAGAG*TAGC => 2 (A and G).\n// adj is nbase/4 * score, or (nbase+1)/5?\n// Perhaps multiplied by length too, to get local complexity score?\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n\n#include <htslib/sam.h>\n#include <htslib/hfile.h>\n\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n#include \"bam_plbuf.h\"\n#include \"consensus_pileup.h\"\n\n#ifdef __SSE__\n#   include <xmmintrin.h>\n#else\n#   define _mm_prefetch(a,b)\n#endif\n\n#ifndef MIN\n#  define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#ifndef MAX\n#  define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n// Defines for experiment code which is currently disabled\n\n// Hardy-Weinberg statistics to check heterozygous sites match allelic\n// frequencies.\n//#define DO_HDW\n\n// Filter bayesian calls by min-depth and min-fract parameters\n//#define DO_FRACT\n\n// Checks uniqueness of surrounding bases to adjust scores\n//#define K2 2\n\n// Look for strand bias in distribution of homopolymer lengths\n//#define DO_POLY_DIST\n\n// Minimum cutoff for storing mod data; => at least 10% chance\n#define MOD_CUTOFF 0.46\n\nenum format {\n    FASTQ,\n    FASTA,\n    PILEUP\n};\n\ntypedef unsigned char uc;\n\n// Simple recalibration table for substitutions, undercalls and overcalls.\n// In future, we'll update this to be kmer based too.\ntypedef struct {\n    int smap[101]; // substituion or SNP\n    int umap[101]; // undercall   or DEL\n    int omap[101]; // overcall    or INS\n} qcal_t;\n\ntypedef struct {\n    // User options\n    char *reg;\n    int use_qual;\n    int min_qual;\n    int adj_qual;\n    int use_mqual;\n    double scale_mqual;\n    int nm_adjust;\n    int nm_halo;\n    int sc_cost;\n    int low_mqual;\n    int high_mqual;\n    int min_depth;\n    double call_fract;\n    double het_fract;\n    int mode;   // One of MODE_* macros below\n    enum format fmt;\n    int cons_cutoff;\n    int ambig;\n    int line_len;\n    int default_qual;\n    int het_only;\n    int all_bases;\n    int show_del;\n    int show_ins;\n    int mark_ins;\n    int excl_flags;\n    int incl_flags;\n    int min_mqual;\n    double P_het;\n    double P_indel;\n    double het_scale;\n    double homopoly_fix;\n    double homopoly_redux;\n    qcal_t qcal;\n\n    // Internal state\n    samFile *fp;\n    FILE *fp_out;\n    sam_hdr_t *h;\n    hts_idx_t *idx;\n    hts_itr_t *iter;\n    kstring_t ks_line;\n    kstring_t ks_ins_seq;\n    kstring_t ks_ins_qual;\n    int last_tid;\n    hts_pos_t last_pos;\n} consensus_opts;\n\n/* --------------------------------------------------------------------------\n * A bayesian consensus algorithm that analyses the data to work out\n * which hypothesis of pure A/C/G/T/absent and all combinations of two\n * such bases meets the observations.\n *\n * This has its origins in Gap4 (homozygous) -> Gap5 (heterozygous)\n * -> Crumble (tidied up to use htslib's pileup) -> here.\n *\n */\n\n#define CONS_DISCREP    4\n#define CONS_ALL        15\n\n#define CONS_MQUAL      16\n\ntypedef struct {\n    /* the most likely base call - we never call N here */\n    /* A=0, C=1, G=2, T=3, *=4 */\n    int call;\n\n    /* The most likely heterozygous base call */\n    /* Use \"ACGT*\"[het / 5] vs \"ACGT*\"[het % 5] for the combination */\n    int het_call;\n\n    /* Log-odds for het_call */\n    int het_logodd;\n\n    /* Single phred style call */\n    int phred;\n\n    /* Sequence depth */\n    int depth;\n\n    /* Discrepancy search score */\n    float discrep;\n} consensus_t;\n\n#define P_HET 1e-3\n#define P_INDEL 2e-4\n#define P_HOMOPOLY 0.5\n#define P_HET_SCALE 1.0\n\n#define LOG10            2.30258509299404568401\n#define TENOVERLOG10     4.34294481903251827652\n#define TENLOG2OVERLOG10 3.0103\n\n#ifdef __GNUC__\n#define ALIGNED(x) __attribute((aligned(x)))\n#else\n#define ALIGNED(x)\n#endif\n\n// Initialised once as a global array.  This won't work if threaded,\n// but we'll rewrite if and when that gets added later.\nstatic double e_tab_a[1002]  ALIGNED(16);\nstatic double *e_tab = &e_tab_a[500];\nstatic double e_tab2_a[1002] ALIGNED(16);\nstatic double *e_tab2 = &e_tab2_a[500];\nstatic double e_log[501]     ALIGNED(16);\n\n/* Precomputed matrices for the consensus algorithm */\ntypedef struct {\n    double prior[25]    ALIGNED(16);  /* Sum to 1.0 */\n    double lprior15[15] ALIGNED(16);  /* 15 combinations of {ACGT*} */\n\n    double pMM[101] ALIGNED(16);\n    double p__[101] ALIGNED(16);\n    double p_M[101] ALIGNED(16);\n    double po_[101] ALIGNED(16);\n    double poM[101] ALIGNED(16);\n    double poo[101] ALIGNED(16);\n    double puu[101] ALIGNED(16);\n    double pum[101] ALIGNED(16);\n    double pmm[101] ALIGNED(16);\n\n    // Multiplier on homopolymer length before reducing phred qual\n    double poly_mul;\n} cons_probs;\n\n// Two sets of params; recall oriented (gap5) and precision (stf).\n// We use the former unless MODE_MIXED is set (which is the default\n// for bayesian consensus mode if P_indel is significant).\nstatic cons_probs cons_prob_recall, cons_prob_precise;\n\n/*\n * Lots of confusing matrix terms here, so some definitions will help.\n *\n * M = match base\n * m = match pad\n * _ = mismatch\n * o = overcall\n * u = undercall\n *\n * We need to distinguish between homozygous columns and heterozygous columns,\n * done using a flat prior.  This is implemented by treating every observation\n * as coming from one of two alleles, giving us a 2D matrix of possibilities\n * (the hypotheses) for each and every call (the observation).\n *\n * So pMM[] is the chance that given a call 'x' that it came from the\n * x/x allele combination.  Similarly p_o[] is the chance that call\n * 'x' came from a mismatch (non-x) / overcall (consensus=*) combination.\n *\n * Examples with observation (call) C and * follows\n *\n *  C | A  C  G  T  *          * | A  C  G  T  *\n *  -----------------          -----------------\n *  A | __ _M __ __ o_         A | uu uu uu uu um\n *  C | _M MM _M _M oM         C | uu uu uu uu um\n *  G | __ _M __ __ o_         G | uu uu uu uu um\n *  T | __ _M __ __ o_         T | uu uu uu uu um\n *  * | o_ oM o_ o_ oo         * | um um um um mm\n *\n * In calculation terms, the _M is half __ and half MM, similarly o_ and um.\n *\n * Relative weights of substitution vs overcall vs undercall are governed on a\n * per base basis using the P_OVER and P_UNDER scores (subst is\n * 1-P_OVER-P_UNDER).\n *\n * The heterozygosity weight though is a per column calculation as we're\n * trying to model whether the column is pure or mixed. Hence this is done\n * once via a prior and has no affect on the individual matrix cells.\n *\n * We have a generic indel probability, but it's a catch all for overcall,\n * undercall, alignment artifacts, homopolymer issues, etc.  So we can set\n * it considerably higher and just let the QUAL skew do the filtering for\n * us, albeit no longer well calibrated.\n */\n\n// NB: Should _M be MM?\n// Ie sample really is A/C het, and we observe C.  That should be a match,\n// not half a match.\n\n#define MODE_SIMPLE    0 // freq counting\n\n#define MODE_BAYES_116 1 // Samtools 1.16 (no indel param)\n#define MODE_RECALL    2 // so called as it's the params from Gap5\n#define MODE_PRECISE   3 // a more precise set; +FN, --FP\n#define MODE_MIXED     4 // Combination of GAP5/BAYES\n\n#define QCAL_FLAT           0\n#define QCAL_HIFI           1\n#define QCAL_HISEQ          2\n#define QCAL_ONT_R10_4_SUP  3\n#define QCAL_ONT_R10_4_DUP  4\n#define QCAL_ULTIMA         5\n\n// Calibration tables here don't necessarily reflect the true accuracy.\n// They have been manually tuned to work in conjunction with other command\n// line parameters used in the machine profiles.  For example reducing one\n// qual here and increasing sensitivity elsewhere via another parameter.\nstatic qcal_t static_qcal[6] = {\n    { // FLAT\n        {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n         10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n         20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n         30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n         40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n         50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n         60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n         70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n         80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n         90, 91, 92, 93, 94, 95, 96, 97, 98, 99},\n        {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n         10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n         20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n         30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n         40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n         50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n         60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n         70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n         80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n         90, 91, 92, 93, 94, 95, 96, 97, 98, 99},\n        {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n         10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n         20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n         30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n         40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n         50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n         60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n         70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n         80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n         90, 91, 92, 93, 94, 95, 96, 97, 98, 99}\n    },\n\n    { // HiFi\n        {10, 11, 11, 12, 13, 14, 15, 16, 18, 19,\n         20, 21, 22, 23, 24, 25, 27, 28, 29, 30,\n         31, 32, 33, 33, 34, 35, 36, 36, 37, 38,\n         38, 39, 39, 40, 40, 41, 41, 41, 41, 42,\n         42, 42, 42, 43, 43, 43, 43, 43, 43, 43,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         },\n        {  4,  4,  4,  4,  5,  6,  6,  7,  8,  9,\n          10, 11, 11, 12, 13, 14, 15, 15, 16, 17,\n          18, 19, 19, 20, 20, 21, 22, 23, 23, 24,\n          25, 25, 25, 26, 26, 26, 27, 27, 28, 28,\n          28, 28, 27, 27, 27, 28, 28, 28, 28, 27,\n          27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n          27, 27, 26, 26, 25, 26, 26, 27, 27, 27,\n          26, 26, 26, 26, 26, 26, 26, 26, 27, 27,\n          28, 29, 28, 28, 28, 27, 27, 27, 27, 27,\n          27, 28, 28, 30, 30, 30, 30, 30, 30, 30,\n          },\n        {  8,  8,  8,  8,  9, 10, 11, 12, 13, 14,\n          15, 15, 16, 17, 18, 19, 19, 20, 20, 21,\n          21, 22, 22, 23, 23, 23, 24, 24, 24, 25,\n          25, 25, 25, 25, 25, 26, 26, 26, 26, 27,\n          27, 27, 27, 27, 27, 28, 28, 28, 28, 28,\n          29, 29, 29, 29, 29, 29, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n        }\n    },\n\n    { // HiSeq\n        { 2,  2,  2,  3,  3,  4,  5,  5,  6,  7,\n          8,  9, 10, 11, 11, 12, 13, 14, 15, 16,\n          17, 17, 18, 19, 20, 21, 22, 22, 23, 24,\n          25, 26, 27, 28, 28, 29, 30, 31, 32, 33,\n          34, 34, 35, 36, 37, 38, 39, 39, 40, 41,\n          42, 43, 44, 45, 45, 46, 47, 48, 49, 50,\n          51, 51, 52, 53, 54, 55, 56, 56, 57, 58,\n          59, 60, 61, 62, 62, 63, 64, 65, 66, 67,\n          68, 68, 69, 70, 71, 72, 73, 73, 74, 75,\n          76, 77, 78, 79, 79, 80, 81, 82, 83, 84,\n        },\n        { 1,  2,  3,  4,  5,  7,  8,  9, 10, 11,\n          13, 14, 15, 16, 17, 19, 20, 21, 22, 23,\n          25, 26, 27, 28, 29, 31, 32, 33, 34, 35,\n          37, 38, 39, 40, 41, 43, 44, 45, 46, 47,\n          49, 50, 51, 52, 53, 55, 56, 57, 58, 59,\n          61, 62, 63, 64, 65, 67, 68, 69, 70, 71,\n          73, 74, 75, 76, 77, 79, 80, 81, 82, 83,\n          85, 86, 87, 88, 89, 91, 92, 93, 94, 95,\n          97, 98, 99, 100, 101, 103, 104, 105, 106, 107,\n          109, 110, 111, 112, 113, 115, 116, 117, 118, 119,\n        },\n        { 1,  2,  3,  4,  5,  7,  8,  9, 10, 11,\n          13, 14, 15, 16, 17, 19, 20, 21, 22, 23,\n          25, 26, 27, 28, 29, 31, 32, 33, 34, 35,\n          37, 38, 39, 40, 41, 43, 44, 45, 46, 47,\n          49, 50, 51, 52, 53, 55, 56, 57, 58, 59,\n          61, 62, 63, 64, 65, 67, 68, 69, 70, 71,\n          73, 74, 75, 76, 77, 79, 80, 81, 82, 83,\n          85, 86, 87, 88, 89, 91, 92, 93, 94, 95,\n          97, 98, 99, 100, 101, 103, 104, 105, 106, 107,\n          109, 110, 111, 112, 113, 115, 116, 117, 118, 119,\n        }\n    },\n    { // ONT R10.4 super\n        {  0,  2,  2,  2,  3,  4,  4,  5,  6,  7,\n           7,  8,  9, 12, 13, 14, 15, 15, 16, 17,\n          18, 19, 20, 22, 24, 25, 26, 27, 28, 29,\n          30, 31, 33, 34, 36, 37, 38, 38, 39, 39,\n          40, 40, 40, 40, 40, 40, 40, 41, 40, 40,\n          41, 41, 40, 40, 40, 40, 41, 40, 40, 40,\n          40, 41, 41, 40, 40, 41, 40, 40, 39, 41,\n          40, 41, 40, 40, 41, 41, 41, 40, 40, 40,\n          40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n          40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n        },\n        {  0,  2,  2,  2,  3,  4,  5,  6,  7,  8,\n           8,  9,  9, 10, 10, 10, 11, 12, 12, 13,\n          13, 13, 14, 14, 15, 16, 16, 17, 18, 18,\n          19, 19, 20, 21, 22, 23, 24, 25, 25, 25,\n          25, 25, 25, 25, 25, 25, 26, 26, 26, 26,\n          26, 26, 26, 26, 27, 27, 27, 27, 27, 27,\n          27, 27, 27, 27, 27, 27, 27, 28, 28, 28,\n          28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n          28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n          28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n        },\n        {  0,  4,  6,  6,  6,  7,  7,  8,  9,  9,\n           9, 10, 10, 11, 11, 12, 12, 13, 13, 14,\n          15, 15, 15, 16, 16, 17, 17, 18, 18, 19,\n          19, 20, 20, 21, 22, 22, 23, 23, 24, 24,\n          24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n          24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n          24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n          24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n          24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n          24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n        }\n    },\n    { // ONT R10.4 duplex; just a copy of hifi for now\n        {10, 11, 11, 12, 13, 14, 15, 16, 18, 19,\n         20, 21, 22, 23, 24, 25, 27, 28, 29, 30,\n         31, 32, 33, 33, 34, 35, 36, 36, 37, 38,\n         38, 39, 39, 40, 40, 41, 41, 41, 41, 42,\n         42, 42, 42, 43, 43, 43, 43, 43, 43, 43,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n         },\n        {  4,  4,  4,  4,  5,  6,  6,  7,  8,  9,\n          10, 11, 11, 12, 13, 14, 15, 15, 16, 17,\n          18, 19, 19, 20, 20, 21, 22, 23, 23, 24,\n          25, 25, 25, 26, 26, 26, 27, 27, 28, 28,\n          28, 28, 27, 27, 27, 28, 28, 28, 28, 27,\n          27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n          27, 27, 26, 26, 25, 26, 26, 27, 27, 27,\n          26, 26, 26, 26, 26, 26, 26, 26, 27, 27,\n          28, 29, 28, 28, 28, 27, 27, 27, 27, 27,\n          27, 28, 28, 30, 30, 30, 30, 30, 30, 30,\n          },\n        {  8,  8,  8,  8,  9, 10, 11, 12, 13, 14,\n          15, 15, 16, 17, 18, 19, 19, 20, 20, 21,\n          21, 22, 22, 23, 23, 23, 24, 24, 24, 25,\n          25, 25, 25, 25, 25, 26, 26, 26, 26, 27,\n          27, 27, 27, 27, 27, 28, 28, 28, 28, 28,\n          29, 29, 29, 29, 29, 29, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n          30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n        }\n    },\n    { // Ultima Genomics\n        { 2,  2,  3,  4,  5,  6,  6,  7,  8,  9,\n          10, 10, 11, 12, 13, 14, 14, 15, 16, 17,\n          18, 18, 19, 21, 22, 23, 23, 24, 25, 26,\n          27, 27, 28, 29, 30, 31, 31, 32, 33, 34,\n          35, 35, 36, 37, 38, 39, 39, 40, 42, 43,\n          44, 44, 45, 46, 47, 48, 48, 49, 50, 51,\n          52, 52, 53, 54, 55, 56, 56, 57, 58, 59,\n          60, 60, 61, 63, 64, 65, 65, 66, 67, 68,\n          69, 69, 70, 71, 72, 73, 73, 74, 75, 76,\n          77, 77, 78, 79, 80, 81, 81, 82, 84, 85,\n        },\n        { 1,  1,  2,  2,  3,  3,  4,  4,  4,  4,\n          5,  5,  6,  6,  7,  7,  8,  8,  9, 10,\n          10, 10, 11, 12, 13, 13, 13, 14, 15, 16,\n          16, 16, 17, 18, 18, 19, 19, 20, 20, 21,\n          21, 22, 22, 22, 22, 23, 23, 24, 24, 25,\n          25, 25, 25, 25, 25, 25, 26, 26, 26, 26,\n          26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n          27, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n          28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n          28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n        },\n        { 1,  1,  2,  2,  3,  3,  4,  4,  4,  4,\n          5,  5,  6,  6,  7,  7,  8,  8,  9, 10,\n          10, 10, 11, 12, 13, 13, 13, 14, 15, 16,\n          16, 16, 17, 18, 18, 19, 19, 20, 20, 21,\n          21, 22, 22, 22, 22, 23, 23, 24, 24, 25,\n          25, 25, 25, 25, 25, 25, 26, 26, 26, 26,\n          26, 26, 27, 27, 27, 27, 27, 27, 27, 27,\n          27, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n          28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n          28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n        }\n    }\n};\n\nint set_qcal(qcal_t *q, int id) {\n    if (id < 0 || id >= sizeof(static_qcal)/sizeof(*static_qcal))\n        return -1;\n\n    memcpy(q, &static_qcal[id], sizeof(*q));\n    return 0;\n}\n\nint load_qcal(qcal_t *q, const char *fn) {\n    int i;\n\n    if (strcmp(fn, \":hifi\") == 0)\n        return set_qcal(q, QCAL_HIFI);\n    if (strcmp(fn, \":hiseq\") == 0)\n        return set_qcal(q, QCAL_HISEQ);\n    if (strcmp(fn, \":r10.4_sup\") == 0)\n        return set_qcal(q, QCAL_ONT_R10_4_SUP);\n    if (strcmp(fn, \":r10.4_dup\") == 0)\n        return set_qcal(q, QCAL_ONT_R10_4_DUP);\n    if (strcmp(fn, \":ultima\") == 0)\n        return set_qcal(q, QCAL_ULTIMA);\n\n    // default\n    for (i = 0; i < 101; i++)\n        q->smap[i] = q->umap[i] = q->omap[i] = i;\n\n    if (strcmp(fn, \":flat\") == 0)\n        return 0;\n\n    hFILE *fp = hopen(fn, \"r\");\n    if (!fp)\n        return -1;\n\n    kstring_t line = KS_INITIALIZE;\n    int max = 0;\n    int last_qual = 0;\n    while (line.l = 0, kgetline(&line, (kgets_func *)hgets, fp) >= 0) {\n        int v, s, u, o;\n        if (*line.s == '#')\n            continue;\n        if (sscanf(line.s, \"QUAL %d %d %d %d\", &v, &s, &u, &o) != 4)\n            goto err;\n        while (v > last_qual) {\n            q->smap[last_qual+1] = q->smap[last_qual];\n            q->umap[last_qual+1] = q->umap[last_qual];\n            q->omap[last_qual+1] = q->omap[last_qual];\n            last_qual++;\n        }\n        if (v >= 0 && v < 100) {\n            q->smap[v] = s;\n            q->umap[v] = u;\n            q->omap[v] = o;\n        }\n        if (v < max) {\n            fprintf(stderr, \"Qual calibration file is not in ascending order\\n\");\n            return hclose(fp) ? -2 : -1;\n        }\n        max = v;\n    }\n\n    for (i = max+1; i < 101; i++) {\n        q->smap[i] = q->smap[max];\n        q->umap[i] = q->umap[max];\n        q->omap[i] = q->omap[max];\n    }\n\n    ks_free(&line);\n    return hclose(fp) < 0 ? -2 : 0;\n\n err:\n    ks_free(&line);\n    return hclose(fp) < 0 ? -2 : -1;\n}\n\nstatic void consensus_init(double p_het, double p_indel, double het_scale,\n                           double poly_mul,\n                           qcal_t *qcal, int mode, cons_probs *cp) {\n    int i;\n\n    // NB: only need to initialise once, but we do here for now\n    for (i = -500; i <= 500; i++)\n        e_tab[i] = exp(i);\n    for (i = -500; i <= 500; i++)\n        e_tab2[i] = exp(i/10.);\n    for (i = 0; i <= 500; i++)\n        e_log[i] = log(i);\n\n    // EXPERIMENTAL\n    cp->poly_mul = poly_mul;\n\n    // The priors make very little difference, unless shallow data.\n    // ACGT* by ACGT*\n    // So AA=0, CC=6, GG=12, TT=18, **=24\n    for (i = 0; i < 25; i++)\n        cp->prior[i] = p_het / 6; // AC AG AT CG CT GT\n\n    // Flat assumption that it is what we observe, and measure everything else\n    // as relative to this.\n    cp->prior[0]=cp->prior[6]=cp->prior[12]=cp->prior[18]=cp->prior[24] = 1;\n\n    // heterozygous deletion\n    for (i = 4; i < 24; i+=5)\n        cp->prior[i] = p_indel / 6; // /6 to be scaled vs p_het equivalently\n\n    // heterozygous insertion\n    for (i = 20; i < 24; i++)\n        cp->prior[i] = p_indel / 6;\n\n    cp->lprior15[0]  = log(cp->prior[0]);\n    cp->lprior15[1]  = log(cp->prior[1]);\n    cp->lprior15[2]  = log(cp->prior[2]);\n    cp->lprior15[3]  = log(cp->prior[3]);\n    cp->lprior15[4]  = log(cp->prior[4]);\n    cp->lprior15[5]  = log(cp->prior[6]);\n    cp->lprior15[6]  = log(cp->prior[7]);\n    cp->lprior15[7]  = log(cp->prior[8]);\n    cp->lprior15[8]  = log(cp->prior[9]);\n    cp->lprior15[9]  = log(cp->prior[12]);\n    cp->lprior15[10] = log(cp->prior[13]);\n    cp->lprior15[11] = log(cp->prior[14]);\n    cp->lprior15[12] = log(cp->prior[18]);\n    cp->lprior15[13] = log(cp->prior[19]);\n    cp->lprior15[14] = log(cp->prior[24]);\n\n    for (i = 1; i < 101; i++) {\n        double prob = 1 - pow(10, -qcal->smap[i] / 10.0);\n\n        // Or is it that prob is 1-p(subst)-p(overcall)?\n        cp->pMM[i] = log(prob);\n\n        //cp->p__[i] = log(1-prob); // Big help to PB-CCS SNPs; unless fudged\n        cp->p__[i] = log((1-prob)/3); // correct? poor on PB-CCS w/o fudge\n\n        // Mixed alleles; just average two likelihoods\n        cp->p_M[i] = log((exp(cp->pMM[i]) + exp(cp->p__[i]))/2);\n\n        // What does this really mean?  Can we simulate this by priors?\n        // It reduces the likelihood of calling het sites, which is\n        // maybe compensation for alignment artifacts?  I'm unsure,\n        // but it works (to differing degrees) on both PacBio HiFi and\n        // Illumina HiSeq.  It (obviously) loses true hets, but\n        // potentially this can be compensated for by tweaking P-het\n        // (which is entirely in the priors).\n        //\n        // Low het_scale reduces false positives by making hets less\n        // likely to be called.  In  high depth data we normally  have\n        // enough evidence to call correctly even with low het_scale,\n        // so it's a good +FN vs --FP tradeoff.  However on low depth\n        // data, het_scale can filter out too many true variants.\n        //\n        // TODO: So consider adjusting at the end maybe?\n        // Also consider never changing calls, but changing their\n        // confidence, so the data is what produces the call with the\n        // parameters skewing the quality score distribution.\n        cp->p_M[i] += log(het_scale);\n\n        if (mode == MODE_BAYES_116) {\n            // Compatibility with samtools 1.16\n\n            // This had no differention for indel vs substitution error rates,\n            // so o(vercall) and u(undercall) are subst(_).\n            cp->pmm[i] = cp->pMM[i];\n            cp->poM[i] = cp->p_M[i];\n            cp->pum[i] = cp->p_M[i];\n            cp->po_[i] = cp->p__[i];\n            cp->poo[i] = cp->p__[i];\n            cp->puu[i] = cp->p__[i];\n\n        } else {\n            // When observing A C G T; leads to insertion calls\n            prob = 1 - pow(10, -qcal->omap[i] / 10.0);\n            // /3 for consistency with ACGT rem as relative likelihoods.\n            // Otherwise with flat priors we end up calling all shallow data\n            // as \"*\", which is illogical.\n            cp->poo[i] = log((1-prob)/3);\n\n            // Ensure pMM is always more likely. (NB: This shouldn't happen\n            // now with the addition of the /3 step above.)\n            if (cp->poo[i] > cp->pMM[i]-.5)\n                cp->poo[i] = cp->pMM[i]-.5;\n\n            cp->po_[i] = log((exp(cp->poo[i]) + exp(cp->p__[i]))/2);\n            cp->poM[i] = log((exp(cp->poo[i]) + exp(cp->pMM[i]))/2);\n\n            // Overcalls should never be twice as likely than mismatches.\n            // Het bases are mix of _M (other) and MM ops (this).\n            // It's fine for _M to be less likely than oM (more likely\n            // to be overcalled than miscalled),  but it should never\n            // be stronger when combined with other mixed data.\n            if (cp->poM[i] > cp->p_M[i]+.5)\n                cp->poM[i] = cp->p_M[i]+.5;\n\n            // Note --low-MQ and --scale-MQ have a big impact on\n            // undercall errs.  May need to separate these options per\n            // type, but how?\n            // Multiple-calls, as with mixed mode?  This feels like a cheat\n\n            prob = 1 - pow(10, -qcal->umap[i] / 10.0);\n            cp->pmm[i] = log(prob);\n            cp->puu[i] = log((1-prob)/3);\n            if (cp->puu[i] > cp->pMM[i]-.5) // MM is -ve\n                cp->puu[i] = cp->pMM[i]-.5;\n\n            cp->pum[i] = log((exp(cp->puu[i]) + exp(cp->pmm[i]))/2);\n        }\n    }\n\n    cp->pMM[0] = cp->pMM[1];\n    cp->p__[0] = cp->p__[1];\n    cp->p_M[0] = cp->p_M[1];\n\n    cp->pmm[0] = cp->pmm[1];\n    cp->poo[0] = cp->poo[1];\n    cp->po_[0] = cp->po_[1];\n    cp->poM[0] = cp->poM[1];\n    cp->puu[0] = cp->puu[1];\n    cp->pum[0] = cp->pum[1];\n}\n\nstatic inline double fast_exp(double y) {\n    if (y >= -50 && y <= 50)\n        return e_tab2[(int)(y*10)];\n\n    if (y < -500)\n        y = -500;\n    if (y > 500)\n        y = 500;\n\n    return e_tab[(int)y];\n}\n\n/* Taylor (deg 3) implementation of the log */\nstatic inline double fast_log2(double val)\n{\n    // FP representation is exponent & mantissa, where\n    // value = 2^E * M.\n    // Hence log2(value) = log2(2^E * M)\n    //                   = log2(2^E)+ log2(M)\n    //                   =        E + log2(M)\n    union { double d; uint64_t x; } u = {val};\n    const int E = ((u.x >> 52) & 2047) - 1024; // exponent E\n    // Initial log2(M) based on mantissa\n    u.x &= ~(2047LL << 52);\n    u.x +=   1023LL << 52;\n\n    val = ((-1/3.) * u.d + 2) * u.d - 2/3.;\n\n    return E + val;\n}\n\n#define ph_log(x) (-TENLOG2OVERLOG10*fast_log2((x)))\n\n\nint nins(const bam1_t *b){\n    int i, indel = 0;\n    uint32_t *cig = bam_get_cigar(b);\n    for (i = 0; i < b->core.n_cigar; i++) {\n        int op = bam_cigar_op(cig[i]);\n        if (op == BAM_CINS || op == BAM_CDEL)\n            indel += bam_cigar_oplen(cig[i]);\n    }\n    return indel;\n}\n\n/*\n * Some machines, including 454 and PacBio, store the quality values in\n * homopolymers with the first or last base always being the low quality\n * state.  This can cause problems when reverse-complementing and aligning,\n * especially when we left-justify indels.\n *\n * Other platforms take the approach of having the middle bases high and\n * the low confidence spread evenly to both start and end.  This means\n * reverse-complementing doesn't introduce any strand bias.\n *\n * We redistribute qualities within homopolymers in this style to fix\n * naive consensus or variant calling algorithms.\n */\nvoid homopoly_qual_fix(bam1_t *b) {\n    static double ph2err[256] = {0};\n    int i;\n    if (!ph2err[0]) {\n        for (i = 0; i < 256; i++)\n            ph2err[i] = pow(10, i/-10.0);\n    }\n    uint8_t *seq = bam_get_seq(b);\n    uint8_t *qual = bam_get_qual(b);\n    for (i = 0; i < b->core.l_qseq; i++) {\n        int s = i; // start of homopoly\n        int base = bam_seqi(seq, i);\n        while (i+1 < b->core.l_qseq && bam_seqi(seq, i+1) == base)\n            i++;\n        // s..i inclusive is now homopolymer\n\n        if (s == i)\n            continue;\n\n        // Simplest:  reverse if end_qual < start_qual\n        // Next:      average outer-most two, then next two, etc\n        // Best:      fully redistribute so start/end lower qual than centre\n\n        // Middle route of averaging outer pairs is sufficient?\n        int j, k;\n        for (j = s, k = i; j < k; j++,k--) {\n            double e = ph2err[qual[j]] + ph2err[qual[k]];\n            qual[j] = qual[k] = -fast_log2(e/2)*3.0104+.49;\n        }\n    }\n}\n\n// Return the local NM figure within halo (+/- HALO) of pos.\n// This local NM is used as a way to modify MAPQ to get a localised MAPQ\n// score via an adhoc fashion.\ndouble nm_local(const pileup_t *p, const bam1_t *b, hts_pos_t pos) {\n    int *nm = (int *)p->cd;\n    if (!nm)\n        return 0;\n    pos -= b->core.pos;\n    if (pos < 0)\n        return nm[0] & ((1<<24)-1);\n    if (pos >= b->core.l_qseq)\n        return nm[b->core.l_qseq-1] & ((1<<24)-1);\n\n    return (nm[pos] & ((1<<24)-1)) / 10.0;\n}\n\nint poly_len(const pileup_t *p, const bam1_t *b, hts_pos_t pos) {\n    int *nm = (int *)p->cd;\n    if (!nm)\n        return 0;\n    pos -= b->core.pos;\n    if (pos >= 0 && pos < b->core.l_qseq)\n        return nm[pos] >> 24;\n    else\n        return 0;\n}\n\n/*\n * Initialise a new sequence appearing in the pileup.  We use this to\n * precompute some metrics that we'll repeatedly use in the consensus\n * caller; the localised NM score.\n *\n * We also directly amend the BAM record (which will be discarded later\n * anyway) to modify qualities to account for local quality minima.\n *\n * Returns 0 (discard) or 1 (keep) on success, -1 on failure.\n */\nint nm_init(void *client_data, samFile *fp, sam_hdr_t *h, pileup_t *p) {\n    consensus_opts *opts = (consensus_opts *)client_data;\n    if (!opts->use_mqual)\n        return 1;\n\n    const bam1_t *b = &p->b;\n    int qlen = b->core.l_qseq, i;\n    if (qlen <= 0)\n        return 0;\n    int *local_nm = calloc(qlen, sizeof(*local_nm));\n    if (!local_nm)\n        return -1;\n    p->cd = local_nm;\n\n    double poly_adj = opts->homopoly_fix ? opts->homopoly_fix : 1;\n\n    if (opts->adj_qual) {\n        // Set local_nm based on a function of current qual and the local\n        // minimum qual within the surrounding window.\n        //\n        // Basically if we're in a region of low confidence then we downgrade\n        // higher qual outliers as they may not be as trustworthy as they\n        // claim.  This may be because the qualities have been assigned to\n        // the wrong or arbitrary base (very common in homopolymers), or the\n        // surrounding quality (hence also error likelihood) have lead to\n        // misalignments and the base may be contributing to the wrong\n        // pileup column.\n        //\n        // The nm_local() function returns these scores and uses it to bias\n        // the mapping quality, which in turn adjusts base quality.\n        uint8_t *qual = bam_get_qual(b);\n        uint8_t *seq = bam_get_seq(b);\n        const int qhalo = 8; // window size for base qual\n        int qmin = qual[0];  // min qual within qhalo\n        const int qhalop = 2;// window size for homopolymer qual\n        int qminp = qual[0]; // min qual within homopolymer halo\n        int base = bam_seqi(seq, 0), polyl = 0, polyr = 0; // pos, not len\n\n        // Minimum quality of the initial homopolymer\n        for (i = 1; i < qlen; i++) {\n            if (bam_seqi(seq, i) != base)\n                break;\n            if (i < qhalop && qminp > qual[i])\n                qminp = qual[i];\n        }\n\n        // Minimum quality for general bases\n        for (i = 0; i < qlen && i < qhalo; i++) {\n            if (qmin > qual[i])\n                qmin = qual[i];\n        }\n\n        for (;i < qlen-qhalo; i++) {\n            if (opts->homopoly_fix && bam_seqi(seq, i) != base) {\n                polyl = i;\n                base = bam_seqi(seq, i);\n                qminp = qual[i];\n                int j;\n                for (j = i+1; j < qlen; j++) {\n                    if (bam_seqi(seq, j) != base)\n                        break;\n                    if (i < qhalop && qminp > qual[j])\n                        qminp = qual[j];\n                }\n                polyr = j-1;\n            } else {\n                // CHECK: do we want to have opts->homopoly_fix above,\n                // so when not in use we don't define pl to non-zero?\n                // Test on SynDip\n                polyr = polyl;\n            }\n            int pl = polyr-polyl;\n\n            // Useful for SNPS, as we're judging the variation in\n            // length as an indicator for base-misalignment.\n            // Not so useful for indel calling where the longer the indel\n            // the less confident we are on the len variation being real.\n            int t = (opts->mode == MODE_BAYES_116)\n                ? (qual[i]   + 5*qmin)/4\n                : qual[i]/3 + (qminp-pl*2)*poly_adj;\n\n\n            local_nm[i] += t < qual[i] ? qual[i]-t : 0;\n\n            // Brute force qminp in polyl to polyr range.\n            // TODO: optimise this with sliding window\n            qminp = qual[i];\n            int k;\n            for (k = MAX(polyl,i-qhalop); k <= MIN(polyr,i+qhalop); k++)\n                if (qminp > qual[k])\n                    qminp = qual[k];\n\n            if (qmin > qual[i+qhalo])\n                qmin = qual[i+qhalo];\n            else if (qmin <= qual[i-qhalo]) {\n                int j;\n                qmin = 99;\n                for (j = i-qhalo+1; j <= i+qhalo; j++)\n                    if (qmin > qual[j])\n                        qmin = qual[j];\n            }\n        }\n        for (; i < qlen; i++) {\n            int t = (opts->mode == MODE_BAYES_116)\n                ? (qual[i]   + 5*qmin)/4\n                : qual[i]/3 + qminp*poly_adj;\n            local_nm[i] += t < qual[i] ? qual[i]-t : 0;\n        }\n    }\n\n    // Fix e.g. PacBio homopolymer qualities\n    if (opts->homopoly_fix)\n        homopoly_qual_fix((bam1_t *)b);\n\n    // local_nm[i] & ((1<<24)-1) is for SNP score adjustment.\n    // We also put some more basic poly-X len in local_nm[i] >> 24.\n    uint8_t *seq = bam_get_seq(b);\n    for (i = 0; i < qlen; i++) {\n        int base = bam_seqi(seq, i);\n        int poly = 0, j, k;\n        for (j = i+1; j < qlen; j++)\n            if (bam_seqi(seq, j) != base)\n                break;\n        //printf(\"%d x %d\\n\", base, j-i);\n\n        poly = j-i-1; if (poly > 100) poly = 100;\n        const int HALO=0;\n        for (k = i-HALO; k < j+HALO; k++)\n            if (k >= 0 && k < qlen)\n                local_nm[k] = ((MAX(poly, local_nm[k]>>24))<<24)\n                            | (local_nm[k] & ((1<<24)-1));\n\n        i = j-1;\n    }\n\n    // Adjust local_nm array by the number of edits within\n    // a defined region (pos +/- halo).\n    const int halo = opts->nm_halo;\n    const uint8_t *md = bam_aux_get(b, \"MD\");\n    if (!md)\n        return 1;\n    md = (const uint8_t *)bam_aux2Z(md);\n\n    // Handle cost of being near a soft-clip\n    uint32_t *cig = bam_get_cigar(b);\n    int ncig = b->core.n_cigar;\n\n    if ( (cig[0] & BAM_CIGAR_MASK) == BAM_CSOFT_CLIP ||\n        ((cig[0] & BAM_CIGAR_MASK) == BAM_CHARD_CLIP && ncig > 1 &&\n         (cig[1] & BAM_CIGAR_MASK) == BAM_CSOFT_CLIP)) {\n        for (i = 0; i < halo && i < qlen; i++)\n            local_nm[i]+=opts->sc_cost;\n        for (; i < halo*2 && i < qlen; i++)\n            local_nm[i]+=opts->sc_cost>>1;\n    }\n    if ( (cig[ncig-1] & BAM_CIGAR_MASK) == BAM_CSOFT_CLIP ||\n        ((cig[ncig-1] & BAM_CIGAR_MASK) == BAM_CHARD_CLIP && ncig > 1 &&\n         (cig[ncig-2] & BAM_CIGAR_MASK) == BAM_CSOFT_CLIP)) {\n        for (i = qlen-1; i >= qlen-halo && i >= 0; i--)\n            local_nm[i]+=opts->sc_cost;\n        for (; i >= qlen-halo*2 && i >= 0; i--)\n            local_nm[i]+=opts->sc_cost>>1;\n    }\n\n    // Now iterate over MD tag\n    int pos = 0;\n    while (*md) {\n        if (isdigit(*md)) {\n            uint8_t *endptr;\n            long i = strtol((char *)md, (char **)&endptr, 10);\n            md = endptr;\n            pos += i;\n            continue;\n        }\n\n        // deletion.\n        // Should we bump local_nm here too?  Maybe\n        if (*md == '^') {\n            while (*++md && !isdigit(*md))\n                continue;\n            continue;\n        }\n\n        // substitution\n        for (i = pos-halo*2 >= 0 ?pos-halo*2 :0; i < pos-halo && i < qlen; i++)\n            local_nm[i]+=5;\n        for (; i < pos+halo && i < qlen; i++)\n            local_nm[i]+=10;\n        for (; i < pos+halo*2 && i < qlen; i++)\n            local_nm[i]+=5;\n        md++;\n    }\n\n    return 1;\n}\n\nvoid nm_free(void *client_data, samFile *fp, sam_hdr_t *h, pileup_t *p) {\n    free(p->cd);\n    p->cd = NULL;\n}\n\n#ifdef DO_HDW\n/*\n * Stirling's formula with a 1/12n correction applied to improve accuracy.\n * This seems to hold remarkably true for both low and high numbers too.\n */\ndouble lnfact(double n) {\n    /* Or Gosper's formula...\n     * return (n*ln(n) - n + ln(2*M_PI*n + M_PI/3) / 2);\n     */\n    return ((n+0.5)*log(n) - n + log(2*M_PI)/2) + log(1 + 1/(12.0*n));\n        /* + log(1 + 1/(288.0*n*n)); */\n}\n\n/*\n * The binomical coefficient (n,k) for n trials with k successes where\n * prob(success) = p.\n *                               k      n-k\n * P (k|n) = n! / (k! (n-k)!)   p  (1-p)\n *  p\n *\n * The coefficient we are returning here is the n! / (k! (n-k)!) bit.\n * We compute it using ln(n!) and then exp() the result back to avoid\n * excessively large numbers.\n */\ndouble bincoef(int n, double k) {\n    return exp(lnfact(n) - lnfact(k) - lnfact(n-k));\n}\n\n/*\n * Given p == 0.5 the binomial expansion simplifies a bit, so we have\n * a dedicated function for this.\n */\ndouble binprobhalf(int n, double k) {\n    return bincoef(n, k) * pow(0.5, n);\n}\n\ndouble lnbinprobhalf(int n, double k) {\n    // ln(binprobhalf) expanded up and simplified\n    return lnfact(n) - lnfact(k) - lnfact(n-k) - 0.69315*n;\n}\n#endif\n\nstatic\nint calculate_consensus_gap5(hts_pos_t pos, int flags, int depth,\n                             pileup_t *plp, consensus_opts *opts,\n                             consensus_t *cons, int default_qual,\n                             cons_probs *cp) {\n    int i, j;\n    static int init_done =0;\n    static double q2p[101], mqual_pow[256];\n    double min_e_exp = DBL_MIN_EXP * log(2) + 1;\n\n    double S[15] ALIGNED(16) = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n    double sumsC[6] = {0,0,0,0,0,0}; // A C G T * N\n\n    // Small hash on seq to check for uniqueness of surrounding bases.\n    // If it's frequent, then it's more likely to be correctly called than\n    // if it's rare.\n    // Helps a bit on deep data, especially with K2=3, but detrimental on\n    // shallow and (currently) quite a slow down.\n#ifdef K2\n    int hashN[1<<(K2*4+2)] = {0};\n    int hash1[1<<2] = {0};\n#endif\n\n    /* Map the 15 possible combinations to 1-base or 2-base encodings */\n    static int map_sing[15] ALIGNED(16) =\n        {0, 5, 5, 5, 5,\n            1, 5, 5, 5,\n               2, 5, 5,\n                  3, 5,\n                     4};\n    static int map_het[15] ALIGNED(16) =\n        {0,  1,  2,  3,  4,\n             6,  7,  8,  9,\n                12, 13, 14,\n                    18, 19,\n                        24};\n\n    if (!init_done) {\n        init_done = 1;\n\n        for (i = 0; i <= 100; i++) {\n            q2p[i] = pow(10, -i/10.0);\n        }\n\n        for (i = 0; i < 255; i++) {\n            //mqual_pow[i] = 1-pow(10, -(i+.01)/10.0);\n            mqual_pow[i] = 1-pow(10, -(i*.9)/10.0);\n            //mqual_pow[i] = 1-pow(10, -(i/3+.1)/10.0);\n            //mqual_pow[i] = 1-pow(10, -(i/2+.05)/10.0);\n        }\n        // unknown mqual\n        mqual_pow[255] = mqual_pow[10];\n    }\n\n    /* Initialise */\n    int counts[6] = {0};\n#ifdef DO_FRACT\n    int counts2[2][6] = {{0}};\n#endif\n\n    /* Accumulate */\n\n#ifdef K2\n    const pileup_t *ptmp = plp;\n    for (; ptmp; ptmp = ptmp->next) {\n        const pileup_t *p = ptmp;\n        if (p->qual < opts->min_qual)\n            continue;\n\n        int hb = 0;\n#define _ 0\n        static int X[16] = {_,0,1,_,2,_,_,_,3,_,_,_,_,_,_,_};\n#undef _\n        uint8_t *seq = bam_get_seq(&p->b);\n        int i, base1 = X[p->base4];\n        hash1[base1]++;\n        for (i = p->seq_offset-K2; i <= p->seq_offset+K2; i++) {\n            int base = i >= 0 && i < p->b.core.l_qseq ? X[bam_seqi(seq,i)] : _;\n            hb = (hb<<2)|base;\n        }\n        hashN[hb]++;\n    }\n#endif\n\n    int td = depth; // original depth\n    depth = 0;\n#ifdef DO_POLY_DIST\n    int poly_dist[2][100] = {0};\n#endif\n    for (; plp; plp = plp->next) {\n        pileup_t *p = plp;\n\n        if (p->next)\n            _mm_prefetch(p->next, _MM_HINT_T0);\n\n        if (p->qual < opts->min_qual)\n            continue;\n\n        if (p->ref_skip)\n            continue;\n\n#ifdef K2\n        int hb = 0;\n#define _ 0\n        static int X[16] = {_,0,1,_,2,_,_,_,3,_,_,_,_,_,_,_};\n        int i, base1 = X[p->base4];\n        for (i = p->seq_offset-K2; i <= p->seq_offset+K2; i++) {\n            int base = i >= 0 && i < p->b.core.l_qseq ? X[bam_seqi(seq,i)] : _;\n            hb = (hb<<2)|base;\n        }\n#undef _\n#endif\n\n        const bam1_t *b = &p->b;\n        uint8_t base = p->base4;\n        uint8_t *qual_arr = bam_get_qual(b);\n        uint8_t qual = p->qual;\n        //qual = qual*qual/40+1;\n        if (qual == 255 || (qual == 0 && *qual_arr == 255))\n            qual = default_qual;\n\n#ifdef K2\n        //qual = qual * hashN[hb] / hash1[base1];\n        qual -= -TENOVERLOG10*log(hashN[hb] / (hash1[base1]+.1));\n        if (qual < 1)\n            qual = 1;\n#endif\n\n        // =ACM GRSV TWYH KDBN *\n        static int L[32] = {\n            5,0,1,5, 2,5,5,5, 3,5,5,5, 5,5,5,5,\n            4,4,4,4, 4,4,4,4, 4,4,4,4, 4,4,4,4,\n        };\n\n        // convert from sam base to acgt*n order.\n        base = L[base];\n\n        double MM, __, _M, oo, oM, o_, uu, um, mm, qe;\n\n        // Correction for mapping quality.  Maybe speed up via lookups?\n        // Cannot nullify mapping quality completely.  Lots of (true)\n        // SNPs means low mapping quality.  (Ideally need to know\n        // hamming distance to next best location.)\n\n        if (flags & CONS_MQUAL) {\n            int mqual = b->core.qual;\n            if (opts->nm_adjust) {\n                //mqual /= (nm_local(p, b, pos)+1);\n                mqual /= (nm_local(p, b, b->core.pos + p->seq_offset+1)+1);\n                mqual *= 1 + 2*(0.5-(td>30?30:td)/60.0); // depth fudge\n            }\n\n            // higher => call more; +FP, -FN\n            // lower  => call less; -FP, +FN\n            mqual *= opts->scale_mqual;\n\n            // Drop these?  They don't seem to ever help.\n            if (mqual < opts->low_mqual)\n                mqual = opts->low_mqual;\n            if (mqual > opts->high_mqual)\n                mqual = opts->high_mqual;\n\n            double _p = 1-q2p[qual];\n            double _m = mqual_pow[mqual];\n            qual = ph_log(1-(_m * _p + (1 - _m)/4)); // CURRENT\n            //qual = ph_log(1-_p*_m); // testing\n            //qual *= 6/sqrt(td);\n        }\n\n        /* Quality 0 should never be permitted as it breaks the maths */\n        if (qual < 1)\n            qual = 1;\n\n        double poly = poly_len(p, b, b->core.pos + p->seq_offset+1);\n#ifdef DO_POLY_DIST\n        poly_dist[bam_is_rev(b)][MIN(99,(int)poly)]++;\n#endif\n\n        // EXPERIMENTAL\n        // Adjust qual based on homopolymer length.\n        // Affects different platforms by differing amounts.\n        // May wish to further separate to qual2 and qual3 for ins and del?\n        int qual2 = MAX(1, qual-(poly-2)*cp->poly_mul);\n\n        /* MM=match  _M=half-match  __=mismatch */\n        __ = cp->p__[qual];       // neither match\n        MM = cp->pMM[qual] - __;  // both match\n        _M = cp->p_M[qual] - __;  // one allele only (half match)\n\n        /* observation ACGT, but against hypothesis ** or *base */\n        oo = cp->poo[qual2] - __;\n        oM = cp->poM[qual2] - __;\n        o_ = cp->po_[qual2] - __;\n\n        /* observation * */\n        uu = cp->puu[qual2] - __;\n        um = cp->pum[qual2] - __;\n        mm = cp->pmm[qual2] - __;\n\n        if (flags & CONS_DISCREP) {\n            qe = q2p[qual];\n            sumsC[base] += 1 - qe;\n        }\n\n\n        counts[base]++;\n#ifdef DO_FRACT\n        counts2[bam_is_rev(b)][base]++;\n#endif\n\n        // oM should never be higher than _M for actual bases!  or...\n        //printf(\"base %d@%d MM %f _M %f oM %f\\n\", base, qual, MM, _M, oM);\n\n        switch (base) {\n        case 0: // A\n            S[0]  += MM;\n            S[1]  += _M;\n            S[2]  += _M;\n            S[3]  += _M;\n            S[4]  += oM;\n            S[8]  += o_;\n            S[11] += o_;\n            S[13] += o_;\n            S[14] += oo;\n            break;\n\n        case 1: // C\n            S[1]  += _M;\n            S[5]  += MM;\n            S[6]  += _M;\n            S[7]  += _M;\n            S[8]  += oM;\n            S[4]  += o_;\n            S[11] += o_;\n            S[13] += o_;\n            S[14] += oo;\n\n            //fprintf(stderr, \"%d %f %f %f\\n\", qual, MM+__, oo+__, MM-oo);\n            break;\n\n        case 2: // G\n            S[ 2] += _M;\n            S[ 6] += _M;\n            S[ 9] += MM;\n            S[10] += _M;\n            S[11] += oM;\n            S[4]  += o_;\n            S[8]  += o_;\n            S[13] += o_;\n            S[14] += oo;\n            break;\n\n        case 3: // T\n            S[ 3] += _M; // _m\n            S[ 7] += _M;\n            S[10] += _M;\n            S[12] += MM; // mm\n            S[13] += oM;\n            S[4]  += o_;\n            S[8]  += o_;\n            S[11] += o_;\n            S[14] += oo;\n            // S[14] oo\n\n            break;\n\n        case 4: // *\n            //   under       under       under       under   agree-no-base\n            S[0] += uu; S[1 ]+= uu; S[2 ]+= uu; S[3 ]+= uu; S[4 ]+= um;\n                        S[5 ]+= uu; S[6 ]+= uu; S[7 ]+= uu; S[8 ]+= um;\n                                    S[9 ]+= uu; S[10]+= uu; S[11]+= um;\n                                                S[12]+= uu; S[13]+= um;\n                                                            S[14]+= mm;\n            break;\n\n        case 5: /* N => equal weight to all A,C,G,T but not a pad */\n            S[0] += MM; S[1 ]+= MM; S[2 ]+= MM; S[3 ]+= MM; S[4 ]+= oM;\n                        S[5 ]+= MM; S[6 ]+= MM; S[7 ]+= MM; S[8 ]+= oM;\n                                    S[9 ]+= MM; S[10]+= MM; S[11]+= oM;\n                                                S[12]+= MM; S[13]+= oM;\n                                                            S[14]+= oo;\n            break;\n        }\n\n        depth++;\n    }\n\n#ifdef DO_POLY_DIST\n    // Or compute mean and s.d per strand.\n    // Then compare likelihood of strands coming from the same distribution?\n    // eg s.d=0.59 vs mean=3.41 sd=0.54... hmm\n    //\n    // Or compare ratio of most frequent to next most frequent, for each\n    // strand.\n\n    int d1 = 0, d2 = 0;\n    double nd1 = 0, nd2 = 0;\n    int k;\n    for (k = 0; k < 100; k++) {\n        if (!poly_dist[0][k] && !poly_dist[1][k])\n            continue;\n\n//        fprintf(stdout, \"%ld %d %2d %2d\\n\", pos, k, poly_dist[0][k], poly_dist[1][k]);\n        d1 += (k+1)*poly_dist[0][k];\n        d2 += (k+1)*poly_dist[1][k];\n        nd1 += poly_dist[0][k];\n        nd2 += poly_dist[1][k];\n    }\n//    printf(\"Avg = %f / %f %f / %f / %f\\n\",\n//           (d1+d2+1)/(nd1+nd2+1.),\n//           (d1+1)/(nd1+1.), (d2+1)/(nd2+1.),\n//           (d2+1)/(nd2+1.) - (d1+1)/(nd1+1.),\n//           ((d2+1)/(nd2+1.) - (d1+1)/(nd1+1.)) / ((d1+d2+1)/(nd1+nd2+1.)));\n\n    // Find the top two frequent lengths\n    int n1 = 0, n2 = 0, l1 = 0, l2 = 0;\n    for (k = 0; k < 100; k++) {\n        int poly12 = poly_dist[0][k]+poly_dist[1][k];\n        if (n1 < poly12) {\n            n2 = n1; l2 = l1;\n            n1 = poly12;\n            l1 = k;\n        } else if (n2 < poly12) {\n            n2 = poly12;\n            l2 = k;\n        }\n    }\n\n    const double N = 5;\n    nd1 += 1;\n    nd2 += 1;\n\n    // l1 is most common length\n    int pn1p = poly_dist[0][l1];\n    int pn1m = poly_dist[1][l1];\n    // l2 2nd most common\n    int pn2p = poly_dist[0][l2];\n    int pn2m = poly_dist[1][l2];\n\n    // ratio if two most common lengths on +\n    double s1 = (pn1p+N) / (pn2p+N); s1 = s1>1?1/s1:s1;\n    // ratio if two most common lengths on -\n    double s2 = (pn1m+N) / (pn2m+N); s2 = s2>1?1/s2:s2;\n\n    // ratio of s1 and s2 to identify strand bias\n    double sbias = s1 / s2; sbias = sbias>1?1/sbias:sbias;\n\n    if (pn2p+pn2m > 0 && l1 != l2) {\n//        printf(\"len %d,%d  + %d,%d  - %d,%d\\tbias = %f %f, %f %f\\t%ld\\n\",\n//               l1, l2,  pn1p, pn2p,   pn1m, pn2m,\n//               s1, s2, sbias, sqrt(sbias)-1, pos);\n\n        // adjust score for het indels\n        // sbias is close to 0 for strong strand bias, and 1 for none\n        sbias = 10*log(sbias);//+.5);\n        S[ 4] += sbias; // A*\n        S[ 8] += sbias; // C*\n        S[11] += sbias; // G*\n        S[13] += sbias; // T*\n    } else {\n        sbias = 0;\n    }\n#endif\n\n    /* We've accumulated stats, so now we speculate on the consensus call */\n    double shift, max, max_het, norm[15];\n    int call = 0, het_call = 0;\n    double tot1 = 0, tot2 = 0;\n\n    /*\n     * Scale numbers so the maximum score is 0. This shift is essentially\n     * a multiplication in non-log scale to both numerator and denominator,\n     * so it cancels out. We do this to avoid calling exp(-large_num) and\n     * ending up with norm == 0 and hence a 0/0 error.\n     *\n     * Can also generate the base-call here too.\n     */\n    shift = -DBL_MAX;\n    max = -DBL_MAX;\n    max_het = -DBL_MAX;\n\n#ifdef DO_FRACT\n    // Filter by --min-depth and --het-fract.\n    // Also add a slight adjustment for strand bias.\n    for (j = 0; j < 15; j++) {\n        if (j == 0 || j == 5 || j == 9 || j == 12 || j == 14)\n            continue;\n\n        double c1p = counts2[0][map_het[j]%5];\n        double c1m = counts2[1][map_het[j]%5];\n        double c2p = counts2[0][map_het[j]/5];\n        double c2m = counts2[1][map_het[j]/5];\n\n        double c1 = c1p + c1m;\n        double c2 = c2p + c2m;\n\n        if (c1 && c2) {\n            // Slight decrease in confidence if strong strand bias.\n            const int N = 10; // avoid low sample size problems\n            double b1 = 1 - (N+MIN(c1p,c1m))/(N+MAX(c1p,c1m));\n            double b2 = 1 - (N+MIN(c2p,c2m))/(N+MAX(c2p,c2m));\n            if (b1 > 0.5) S[j] -= b1;\n            if (b2 > 0.5) S[j] -= b2;\n\n            // Fraction based filtering, via --min-depth and --het-fract opts.\n            c1 += 1e-5;\n            c2 += 1e-5;\n            if (c2 > c1) {\n                double tmp = c2;\n                c2 = c1;\n                c1 = tmp;\n            }\n\n            if (c2 < opts->min_depth)\n                S[j] -= 100;\n            if (c2 / (c1+1e-5) <= opts->het_fract)\n                S[j] -= 100;\n        }\n    }\n#endif\n\n#ifdef DO_HDW\n    /*\n     * Apply Hardy-Weinberg statistics for heterozygous sites.\n     * This helps, but it also loses sensitivity a little.\n     */\n    for (j = 0; j < 15; j++) {\n        if (j == 0 || j == 5 || j == 9 || j == 12 || j == 14)\n            continue;\n\n        double c1 = counts[map_het[j]%5];\n        double c2 = counts[map_het[j]/5];\n\n        if (c1 && c2) {\n            c1 += 1e-5;\n            c2 += 1e-5;\n            if (c2 > c1) {\n                double tmp = c2;\n                c2 = c1;\n                c1 = tmp;\n            }\n\n            // Limit depth for HW as we'll have an allele freq difference,\n            // even if it's just caused by alignment reference bias.\n            double c12 = c1+c2;\n            if (c12 > 20) {\n                c2 *= 20/(c12);\n                c12 = 20;\n                c1  = 20-c2;\n            }\n\n            // Helps a little, especially reducing FN deletions.\n            c1+=1;\n            c2+=1;\n            c12+=2;\n            S[j] += lnbinprobhalf(c12, c2) + fast_log2(c12)*0.69+.2;\n        }\n    }\n#endif\n\n    for (j = 0; j < 15; j++) {\n        S[j] += cp->lprior15[j];\n        if (shift < S[j])\n            shift = S[j];\n\n        /* Only call pure AA, CC, GG, TT, ** for now */\n        if (j != 0 && j != 5 && j != 9 && j != 12 && j != 14) {\n            if (max_het < S[j]) {\n                max_het = S[j];\n                het_call = j;\n            }\n            continue;\n        }\n\n        if (max < S[j]) {\n            max = S[j];\n            call = j;\n        }\n    }\n\n    /*\n     * Shift and normalise.\n     * If call is, say, b we want p = b/(a+b+c+...+n), but then we do\n     * p/(1-p) later on and this has exceptions when p is very close\n     * to 1.\n     *\n     * Hence we compute b/(a+b+c+...+n - b) and\n     * rearrange (p/norm) / (1 - (p/norm)) to be p/norm2.\n     */\n    for (j = 0; j < 15; j++) {\n        S[j] -= shift;\n        double e = fast_exp(S[j]);\n        S[j] = (S[j] > min_e_exp) ? e : DBL_MIN;\n        norm[j] = 0;\n    }\n\n    for (j = 0; j < 15; j++) {\n        norm[j]    += tot1;\n        norm[14-j] += tot2;\n        tot1 += S[j];\n        tot2 += S[14-j];\n    }\n\n    /* And store result */\n    if (!depth || depth == counts[5] /* all N */) {\n        cons->call = 4; /* N */\n        cons->het_call = 0;\n        cons->het_logodd = 0;\n        cons->phred = 0;\n        cons->depth = 0;\n        cons->discrep = 0;\n        return 0;\n    }\n\n    cons->depth = depth;\n\n    /* Call */\n    if (norm[call] == 0) norm[call] = DBL_MIN;\n    // Approximation of phred for when S[call] ~= 1 and norm[call]\n    // is small.  Otherwise we need the full calculation.\n    int ph;\n    if (S[call] == 1 && norm[call] < .01)\n        ph = ph_log(norm[call]) + .5;\n    else\n        ph = ph_log(1-S[call]/(norm[call]+S[call])) + .5;\n\n    cons->call     = map_sing[call];\n    cons->phred = ph < 0 ? 0 : ph;\n\n    if (norm[het_call] == 0) norm[het_call] = DBL_MIN;\n    ph = TENLOG2OVERLOG10 * (fast_log2(S[het_call])\n                             - fast_log2(norm[het_call])) + .5;\n\n    cons->het_call = map_het[het_call];\n    cons->het_logodd = ph;\n\n    /* Compute discrepancy score */\n    if (flags & CONS_DISCREP) {\n        double m = sumsC[0]+sumsC[1]+sumsC[2]+sumsC[3]+sumsC[4];\n        double c;\n        if (cons->het_logodd > 0)\n            c = sumsC[cons->het_call%5] + sumsC[cons->het_call/5];\n        else\n            c = sumsC[cons->call];\n        cons->discrep = (m-c)/sqrt(m);\n    }\n\n    return 0;\n}\n\n// If opts->gap5 is MODE_MIXED then we use two different parameter\n// sets, favouring cp_p for precision and cp_r for recall.  Otherwise it's\n// always cp_r only.\n//\n// When both calls equal, we return the same result.  When they differ,\n// we adjust qual based on accurate vs recall profiles.\nint calculate_consensus_gap5m(hts_pos_t pos, int flags, int depth,\n                              pileup_t *plp, consensus_opts *opts,\n                              consensus_t *cons, int default_qual,\n                              cons_probs *cp_r, cons_probs *cp_p) {\n    if (opts->mode != MODE_MIXED)\n        return calculate_consensus_gap5(pos, flags, depth, plp, opts,\n                                        cons, default_qual,\n                                        opts->mode == MODE_PRECISE\n                                            ? cp_p : cp_r);\n\n    // EXPERIMENTAL: mixed mode\n    consensus_t consP, consR;\n    // Favours precision\n    calculate_consensus_gap5(pos, flags, depth, plp, opts,\n                             &consP, default_qual, cp_p);\n    // Favours recall\n    calculate_consensus_gap5(pos, flags, depth, plp, opts,\n                             &consR, default_qual, cp_r);\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAX(a,b) ((a)>(b)?(a):(b))\n\n    // Initial starting point is precise mode\n    memcpy(cons, &consP, sizeof(consP));\n\n    if (consP.phred > 0 && consR.phred > 0 && consP.call == consR.call) {\n        // Both strategies match as HOM\n        // Boost qual as both in agreement\n        cons->phred += MIN(20, consR.phred);\n\n    } else if (consP.het_logodd >= 0 && consR.het_logodd >= 0 &&\n               consP.het_call == consR.het_call) {\n        // Both strategies match as HET\n        // Boost qual as both in agreement\n        cons->het_logodd += MIN(20, consR.het_logodd);\n\n    } else if (consP.het_logodd >= 0) {\n        // Accurate method claims heterozygous, so go with it.\n        // However sensitive method disagrees, so reduce qual a little.\n        int q2 = MAX(consR.phred, consR.het_logodd);\n        cons->het_logodd = MAX(1, (cons->het_logodd - q2/2));\n\n    } else if (consR.het_logodd >= 70) {\n        // Accurate is homozygous and consR is het, so we go with it instead\n        // but at a lower quality value.\n        // TODO: may wish to check HET is consistent with HOM? Very unlikely\n        // not to be though.\n        int q1 = consP.phred;\n        int q2 = consR.het_logodd;\n        memcpy(cons, &consR, sizeof(consR));\n        cons->het_logodd = MIN(15, MAX((q2-q1*2)/2, 1+q2/(q1+1.0)));\n\n    } else if (consR.het_logodd >= 0) {\n        // As above, but low quality\n        int q1 = consP.phred;\n        int q2 = consR.het_logodd;\n        memcpy(cons, &consR, sizeof(consR));\n        cons->het_logodd = MAX(1,q2 - 0.3*q1)\n            + 5*(consP.het_call == consR.het_call);\n        cons->phred = 0;\n\n    } else if (consR.het_logodd < 0) {\n        // Neither are heterozygous, but differing in phred call (V rare).\n        // Pick highest qual, after some scaling?\n        consR.phred = consR.phred / 2;\n        if (consR.phred > consP.phred)\n            memcpy(cons, &consR, sizeof(consR));\n        cons->phred = MAX(10, cons->phred);\n    }\n\n    return 0;\n}\n\n/* --------------------------------------------------------------------------\n * Main processing logic\n */\n\nstatic void dump_fastq(consensus_opts *opts,\n                       const char *name,\n                       const char *seq, size_t seq_l,\n                       const char *qual, size_t qual_l) {\n    enum format fmt = opts->fmt;\n    int line_len = opts->line_len;\n    FILE *fp = opts->fp_out;\n\n    fprintf(fp, \"%c%s\\n\", \">@\"[fmt==FASTQ], name);\n    size_t i;\n    for (i = 0; i < seq_l; i += line_len)\n        fprintf(fp, \"%.*s\\n\", (int)MIN(line_len, seq_l - i), seq+i);\n\n    if (fmt == FASTQ) {\n        fprintf(fp, \"+\\n\");\n        for (i = 0; i < seq_l; i += line_len)\n            fprintf(fp, \"%.*s\\n\", (int)MIN(line_len, seq_l - i), qual+i);\n    }\n}\n\n//---------------------------------------------------------------------------\n\n/*\n * Reads a single alignment record, using either the iterator\n * or a direct sam_read1 call.\n */\nstatic int readaln2(void *dat, samFile *fp, sam_hdr_t *h, bam1_t *b) {\n    consensus_opts *opts = (consensus_opts *)dat;\n\n    for (;;) {\n        int ret = opts->iter\n            ? sam_itr_next(fp, opts->iter, b)\n            : sam_read1(fp, h, b);\n        if (ret < 0)\n            return ret;\n\n        // Apply hard filters\n        if (opts->incl_flags && !(b->core.flag & opts->incl_flags))\n            continue;\n        if (opts->excl_flags &&  (b->core.flag & opts->excl_flags))\n            continue;\n        if (b->core.qual < opts->min_mqual)\n            continue;\n\n        return ret;\n    }\n}\n\n/* --------------------------------------------------------------------------\n * A simple summing algorithm, either pure base frequency, or by\n * weighting them according to their quality values.\n *\n * This is crude, but easy to understand and fits with several\n * standard pileup criteria (eg COG-UK / CLIMB Covid-19 seq project).\n *\n *\n * call1 / score1 is the highest scoring allele.\n * call2 / score2 is the second highest scoring allele.\n *\n * Het_fract:  score2/score1\n * Call_fract: score1 or score1+score2 over total score\n * Min_depth:  minimum total depth of unfiltered bases (above qual/mqual)\n * Min_score:  minimum total score of utilised bases (score1+score2)\n *\n * Eg het_fract 0.66, call_fract 0.75 and min_depth 10.\n * 11A, 2C, 2G (14 total depth) is A.\n * 9A, 2C, 2G  (12 total depth) is N as depth(A) < 10.\n * 11A, 5C, 5G (21 total depth) is N as 11/21 < 0.75 (call_fract)\n *\n *\n * 6A, 5G, 1C  (12 total depth) is AG het as depth(A)+depth(G) >= 10\n *                              and 5/6 >= 0.66 and 11/12 >= 0.75.\n *\n * 6A, 5G, 4C  (15 total depth) is N as (6+5)/15 < 0.75 (call_fract).\n *\n *\n * Note for the purpose of deletions, a base/del has an ambiguity\n * code of lower-case base (otherwise it is uppercase).\n */\nstatic int calculate_consensus_simple(const pileup_t *plp,\n                                      consensus_opts *opts, int *qual) {\n    int i, min_qual = opts->min_qual;\n    int tot_depth = 0;\n\n    // Map \"seqi\" nt16 to A,C,G,T compatibility with weights on pure bases.\n    // where seqi is A | (C<<1) | (G<<2) | (T<<3)\n    //                        * A C M  G R S V  T W Y H  K D B N\n    static int seqi2A[16] = { 0,8,0,4, 0,4,0,2, 0,4,0,2, 0,2,0,1 };\n    static int seqi2C[16] = { 0,0,8,4, 0,0,4,2, 0,0,4,2, 0,0,2,1 };\n    static int seqi2G[16] = { 0,0,0,0, 8,4,4,1, 0,0,0,0, 4,2,2,1 };\n    static int seqi2T[16] = { 0,0,0,0, 0,0,0,0, 8,4,4,2, 8,2,2,1 };\n\n    // Ignore ambiguous bases in seq for now, so we don't treat R, Y, etc\n    // as part of one base and part another.  Based on BAM seqi values.\n    // We also use freq[16] as \"*\" for gap.\n    int      freq[17]  = {0}; // base frequency, aka depth\n    uint64_t score[17] = {0}; // summation of base qualities\n\n    // Accumulate\n    for (; plp; plp = plp->next) {\n        const pileup_t *p = plp;\n        if (p->next)\n            _mm_prefetch(p->next, _MM_HINT_T0);\n\n        int q = p->qual;\n        if (q < min_qual)\n            // Should we still record these in freq[] somewhere so\n            // we can use them in the fracts?\n            // Difference between >= X% of high-qual bases calling Y\n            // and >= X% of all bases are high-quality Y calls.\n            continue;\n\n        //int b = p->is_del ? 16 : bam_seqi(bam_get_seq(&p->b), p->seq_offset);\n        int b = p->base4;\n\n        // Map ambiguity codes to one or more component bases.\n        if (b < 16) {\n            int Q = seqi2A[b] * (opts->use_qual ? q : 1);\n            freq[1]  += Q?1:0;\n            score[1] += Q?Q:0;\n            Q = seqi2C[b] * (opts->use_qual ? q : 1);\n            freq[2]  += Q?1:0;\n            score[2] += Q?Q:0;\n            Q = seqi2G[b] * (opts->use_qual ? q : 1);\n            freq[4]  += Q?1:0;\n            score[4] += Q?Q:0;\n            Q = seqi2T[b] * (opts->use_qual ? q : 1);\n            freq[8]  += Q?1:0;\n            score[8] += Q?Q:0;\n        } else { /* * */\n            freq[16] ++;\n            score[16]+=8 * (opts->use_qual ? q : 1);\n        }\n        tot_depth++;\n    }\n\n    // Total usable depth\n    uint64_t tscore = 0;\n    for (i = 0; i < 5; i++)\n        tscore += score[1<<i];\n\n    // Best and second best potential calls\n    int      call1  = 15, call2  = 15;\n    uint64_t score1 = 0,  score2 = 0;\n    for (i = 0; i < 5; i++) {\n        int c = 1<<i; // A C G T *\n        if (score1 < score[c]) {\n            score2 = score1;\n            call2  = call1;\n            score1 = score[c];\n            call1  = c;\n        } else if (score2 < score[c]) {\n            score2 = score[c];\n            call2  = c;\n        }\n    }\n\n    // Work out which best and second best are usable as a call\n    uint64_t used_score = score1;\n    int      used_base  = call1;\n    if (score2 >= opts->het_fract * score1 && opts->ambig) {\n        used_base  |= call2;\n        used_score += score2;\n    }\n\n    // N is too shallow, or insufficient proportion of total\n    if (tot_depth  < opts->min_depth ||\n        used_score < opts->call_fract * tscore) {\n        // But note shallow gaps are still called gaps, not N, as\n        // we're still more confident there is no base than it is\n        // A, C, G or T.\n        used_base = call1 == 16 ? 16 : 0; // * or N\n    }\n\n    // Our final call.  \"?\" shouldn't be possible to generate\n    const char *het =\n        \"NACMGRSVTWYHKDBN\"\n        \"*ac?g???t???????\";\n\n    //printf(\"%c %d\\n\", het[used_base], tot_depth);\n    if (qual)\n        *qual = used_base ? 100.0 * used_score / tscore : 0;\n\n    return het[used_base];\n}\n\nstatic int empty_pileup2(consensus_opts *opts, sam_hdr_t *h, int tid,\n                         hts_pos_t start, hts_pos_t end) {\n    const char *name = sam_hdr_tid2name(h, tid);\n    hts_pos_t i;\n\n    int err = 0;\n    for (i = start; i < end; i++)\n        err |= fprintf(opts->fp_out, \"%s\\t%\"PRIhts_pos\"\\t0\\t0\\tN\\t0\\t*\\t*\\n\", name, i+1) < 0;\n\n    return err ? -1 : 0;\n}\n\n/*\n * Returns 0 on success\n *        -1 on failure\n */\nstatic int basic_pileup(void *cd, samFile *fp, sam_hdr_t *h, pileup_t *p,\n                        int depth, hts_pos_t pos, int nth, int is_insert) {\n    unsigned char *qp, *cp;\n    char *rp;\n    int ref, cb, cq;\n    consensus_opts *opts = (consensus_opts *)cd;\n    int tid = p->b.core.tid;\n\n//    opts->show_ins=0;\n//    opts->show_del=1;\n    if (!opts->show_ins && nth)\n        return 0;\n\n    if (opts->iter) {\n        if (opts->iter->beg >= pos || opts->iter->end < pos)\n            return 0;\n    }\n\n    if (opts->all_bases) {\n        if (tid != opts->last_tid && opts->last_tid >= -1) {\n            if (opts->last_tid >= 0) {\n                // remainder of previous ref\n                hts_pos_t len = sam_hdr_tid2len(opts->h, opts->last_tid);\n                if (opts->iter)\n                    len =  MIN(opts->iter->end, len);\n                if (empty_pileup2(opts, opts->h, opts->last_tid,\n                                  opts->last_pos, len) < 0)\n                    return -1;\n            }\n\n            opts->last_pos = opts->iter ? opts->iter->beg : 0;\n        }\n\n        // Any refs between last_tid and tid\n        if (!opts->iter && tid > opts->last_tid && opts->all_bases > 1) {\n            while (++opts->last_tid < tid) {\n                hts_pos_t len = sam_hdr_tid2len(opts->h, opts->last_tid);\n                if (empty_pileup2(opts, opts->h, opts->last_tid, 0, len) < 0)\n                    return -1;\n            }\n        }\n\n        // Any gaps in this ref (same tid) or at start of this new tid\n        if (opts->last_pos >= 0 && pos > opts->last_pos+1) {\n            if (empty_pileup2(opts, opts->h, p->b.core.tid, opts->last_pos,\n                              pos-1) < 0)\n                return -1;\n        } else if (opts->last_pos < 0) {\n            if (empty_pileup2(opts, opts->h, p->b.core.tid,\n                              opts->iter ? opts->iter->beg : 0, pos-1) < 0)\n                return -1;\n        }\n    }\n\n    if (opts->mode != MODE_SIMPLE) {\n        consensus_t cons;\n        calculate_consensus_gap5m(pos, opts->use_mqual ? CONS_MQUAL : 0,\n                                  depth, p, opts, &cons, opts->default_qual,\n                                  &cons_prob_recall, &cons_prob_precise);\n        if (cons.depth < opts->min_depth) {\n            cb = 'N';\n            cq = 0;\n        } else if (cons.het_logodd > 0 && opts->ambig) {\n            cb = \"AMRWa\" // 5x5 matrix with ACGT* per row / col\n                 \"MCSYc\"\n                 \"RSGKg\"\n                 \"WYKTt\"\n                 \"acgt*\"[cons.het_call];\n            cq = cons.het_logodd;\n        } else{\n            cb = \"ACGT*\"[cons.call];\n            cq = cons.phred;\n        }\n        if (cq < opts->cons_cutoff && cb != '*') {\n            cb = 'N';\n            cq = 0;\n        }\n    } else {\n        cb = calculate_consensus_simple(p, opts, &cq);\n    }\n    if (cb < 0)\n        return -1;\n\n    if (!p)\n        return 0;\n\n    if (!opts->show_del && cb == '*')\n        return 0;\n\n    /* Ref, pos, nth, score, seq, qual */\n    kstring_t *ks = &opts->ks_line;\n    ks->l = 0;\n    ref = p->b.core.tid;\n    rp = (char *)sam_hdr_tid2name(h, ref);\n\n    int err = 0;\n    err |= kputs(rp, ks)    < 0;\n    err |= kputc_('\\t', ks) < 0;\n    err |= kputw(pos, ks)   < 0;\n    err |= kputc_('\\t', ks) < 0;\n    err |= kputw(nth, ks)   < 0;\n    err |= kputc_('\\t', ks) < 0;\n    err |= kputw(depth, ks) < 0;\n    err |= kputc_('\\t', ks) < 0;\n    err |= kputc_(cb, ks)   < 0;\n    err |= kputc_('\\t', ks) < 0;\n    err |= kputw(cq, ks)    < 0;\n    err |= kputc_('\\t', ks) < 0;\n    if (err)\n        return -1;\n\n    /* Seq + qual at predetermined offsets */\n    if (ks_resize(ks, ks->l + depth*2 + 2) < 0)\n        return -1;\n\n    cp = (unsigned char *)ks->s + ks->l;\n    ks->l += depth*2 + 2;\n    qp = cp+depth+1;\n    for (; p; p = p->next) {\n        // Too tight a loop to help much, but some benefit still\n        if (p->next && p->next->next)\n            _mm_prefetch(p->next->next, _MM_HINT_T0);\n        if (p->b_is_rev) {\n            *cp++ = p->base == '*' ? '#' : tolower(p->base);\n        } else {\n            *cp++ = p->base;\n        }\n        *qp++ = MIN(p->qual,93) + '!';\n    }\n    *cp++ = '\\t';\n    *qp++ = '\\n';\n    if (fwrite(ks->s, 1, ks->l, opts->fp_out) != ks->l)\n        return -1;\n\n    opts->last_pos = pos;\n    opts->last_tid = tid;\n\n    return 0;\n}\n\nstatic int basic_fasta(void *cd, samFile *fp, sam_hdr_t *h, pileup_t *p,\n                       int depth, hts_pos_t pos, int nth, int is_insert) {\n    int cb, cq;\n    consensus_opts *opts = (consensus_opts *)cd;\n    int tid = p->b.core.tid;\n    kstring_t *seq  = &opts->ks_ins_seq;\n    kstring_t *qual = &opts->ks_ins_qual;\n\n    if (!opts->show_ins && nth)\n        return 0;\n\n    if (opts->iter) {\n        if (opts->iter->beg >= pos || opts->iter->end < pos)\n            return 0;\n    }\n\n next_ref:\n    if (tid != opts->last_tid) {\n        if (opts->last_tid != -1) {\n            if (opts->all_bases) {\n                // Fill in remainder of previous reference\n                int i, N;\n                if (opts->iter) {\n                    opts->last_pos = MAX(opts->last_pos, opts->iter->beg-1);\n                    N = opts->iter->end;\n                } else {\n                    N = INT_MAX;\n                }\n                N = MIN(N, sam_hdr_tid2len(opts->h, opts->last_tid))\n                    - opts->last_pos;\n                if (N > 0) {\n                    if (ks_expand(seq, N+1) < 0)\n                        return -1;\n                    if (ks_expand(qual, N+1) < 0)\n                        return -1;\n                    for (i = 0; i < N; i++) {\n                        seq->s[seq->l++] = 'N';\n                        qual->s[qual->l++] = '!';\n                    }\n                    seq->s[seq->l] = 0;\n                    qual->s[qual->l] = 0;\n                }\n            }\n            dump_fastq(opts, sam_hdr_tid2name(opts->h, opts->last_tid),\n                       seq->s, seq->l, qual->s, qual->l);\n        }\n\n        seq->l = 0; qual->l = 0;\n\n        if (!opts->iter && opts->all_bases > 1 && ++opts->last_tid < tid) {\n            opts->last_pos = 0;\n            goto next_ref;\n        }\n\n        opts->last_tid = tid;\n        if (opts->iter)\n            opts->last_pos = opts->iter->beg;\n        else\n            opts->last_pos = opts->all_bases ? 0 : pos-1;\n    }\n\n    // share this with basic_pileup\n    if (opts->mode != MODE_SIMPLE) {\n        consensus_t cons;\n        calculate_consensus_gap5m(pos, opts->use_mqual ? CONS_MQUAL : 0,\n                                  depth, p, opts, &cons, opts->default_qual,\n                                  &cons_prob_recall, &cons_prob_precise);\n        if (cons.depth < opts->min_depth) {\n            cb = 'N';\n            cq = 0;\n        } else if (cons.het_logodd > 0 && opts->ambig) {\n            cb = \"AMRWa\" // 5x5 matrix with ACGT* per row / col\n                 \"MCSYc\"\n                 \"RSGKg\"\n                 \"WYKTt\"\n                 \"acgt*\"[cons.het_call];\n            cq = cons.het_logodd;\n        } else {\n            cb = \"ACGT*\"[cons.call];\n            cq = cons.phred;\n        }\n        if (cq < opts->cons_cutoff && cb != '*' &&\n            cons.het_call % 5 != 4 && cons.het_call / 5 != 4) {\n            // het base/* keeps base or * as most likely pure call, else N.\n            // This is because we don't have a traditional way of representing\n            // base or not-base ambiguity.\n            cb = 'N';\n            cq = 0;\n        }\n    } else {\n        cb = calculate_consensus_simple(p, opts, &cq);\n    }\n    if (cb < 0)\n        return -1;\n\n    if (!p)\n        return 0;\n\n    if (!opts->show_del && cb == '*') {\n        opts->last_pos = pos;\n        opts->last_tid = tid;\n        return 0;\n    }\n    if (opts->mark_ins && nth && cb != '*') {\n        kputc('_', seq);\n        kputc('_', qual);\n    }\n\n    // end of share\n\n    // Append consensus base/qual to seqs\n    if (pos > opts->last_pos) {\n        if (opts->last_pos >= 0 || opts->all_bases) {\n            // FIXME: don't expand qual if fasta\n            if (ks_expand(seq,  pos - opts->last_pos) < 0 ||\n                ks_expand(qual, pos - opts->last_pos) < 0)\n                return -1;\n            memset(seq->s  + seq->l,  'N', pos - (opts->last_pos+1));\n            memset(qual->s + qual->l, '!', pos - (opts->last_pos+1));\n            seq->l  += pos - (opts->last_pos+1);\n            qual->l += pos - (opts->last_pos+1);\n        }\n    }\n    if ((nth && opts->show_ins && cb != '*')\n        || cb != '*' || (pos > opts->last_pos && opts->show_del)) {\n        int err = 0;\n        err |= kputc(cb, seq) < 0;\n        err |= kputc(MIN(cq, '~'-'!')+'!', qual) < 0;\n        if (err)\n            return -1;\n    }\n\n    opts->last_pos = pos;\n    opts->last_tid = tid;\n\n    return 0;\n}\n\n// END OF NEW PILEUP\n//---------------------------------------------------------------------------\n\nstatic void usage_exit(FILE *fp, int exit_status) {\n    fprintf(fp, \"Usage: samtools consensus [options] <in.bam>\\n\");\n    fprintf(fp, \"\\nOptions:\\n\");\n    fprintf(fp, \"  -r, --region REG      Limit query to REG. Requires an index\\n\");\n    fprintf(fp, \"  -f, --format FMT      Output in format FASTA, FASTQ or PILEUP [FASTA]\\n\");\n    fprintf(fp, \"  -l, --line-len INT    Wrap FASTA/Q at line length INT [70]\\n\");\n    fprintf(fp, \"  -o, --output FILE     Output consensus to FILE\\n\");\n    fprintf(fp, \"  -m, --mode STR        Switch consensus mode to \\\"simple\\\"/\\\"bayesian\\\" [bayesian]\\n\");\n    fprintf(fp, \"  -a                    Output all bases (start/end of reference)\\n\");\n    fprintf(fp, \"  --rf, --incl-flags STR|INT\\n\");\n    fprintf(fp, \"                        Only include reads with any flag bit set [0]\\n\");\n    fprintf(fp, \"  --ff, --excl-flags STR|INT\\n\");\n    fprintf(fp, \"                        Exclude reads with any flag bit set\\n\");\n    fprintf(fp, \"                        [UNMAP,SECONDARY,QCFAIL,DUP]\\n\");\n    fprintf(fp, \"  --min-MQ INT          Exclude reads with mapping quality below INT [0]\\n\");\n    fprintf(fp, \"  --min-BQ INT          Exclude reads with base quality below INT [0]\\n\");\n    fprintf(fp, \"  --show-del yes/no     Whether to show deletion as \\\"*\\\" [no]\\n\");\n    fprintf(fp, \"  --show-ins yes/no     Whether to show insertions [yes]\\n\");\n    fprintf(fp, \"  --mark-ins            Add '+' before every inserted base/qual [off]\\n\");\n    fprintf(fp, \"  -A, --ambig           Enable IUPAC ambiguity codes [off]\\n\");\n    fprintf(fp, \"  -d, --min-depth INT   Minimum depth of INT [1]\\n\");\n    fprintf(fp, \"\\nFor simple consensus mode:\\n\");\n    fprintf(fp, \"  -q, --(no-)use-qual   Use quality values in calculation [off]\\n\");\n    fprintf(fp, \"  -c, --call-fract INT  At least INT portion of bases must agree [0.75]\\n\");\n    fprintf(fp, \"  -H, --het-fract INT   Minimum fraction of 2nd-most to most common base [0.15]\\n\");\n    fprintf(fp, \"\\nFor default \\\"Bayesian\\\" consensus mode:\\n\");\n    fprintf(fp, \"  -C, --cutoff C        Consensus cutoff quality C [10]\\n\");\n    fprintf(fp, \"      --(no-)adj-qual   Modify quality with local minima [on]\\n\");\n    fprintf(fp, \"      --(no-)use-MQ     Use mapping quality in calculation [on]\\n\");\n    fprintf(fp, \"      --(no-)adj-MQ     Modify mapping quality by local NM [on]\\n\");\n    fprintf(fp, \"      --NM-halo INT     Size of window for NM count in --adj-MQ [50]\\n\");\n    fprintf(fp, \"      --scale-MQ FLOAT  Scale mapping quality by FLOAT [1.00]\\n\");\n    fprintf(fp, \"      --low-MQ  INT     Cap minimum mapping quality [1]\\n\");\n    fprintf(fp, \"      --high-MQ INT     Cap maximum mapping quality [60]\\n\");\n    fprintf(fp, \"      --P-het FLOAT     Probability of heterozygous site[%.1e]\\n\",\n            P_HET);\n    fprintf(fp, \"      --P-indel FLOAT   Probability of indel sites[%.1e]\\n\",\n            P_INDEL);\n    fprintf(fp, \"      --het-scale FLOAT Heterozygous SNP probability multiplier[%.1e]\\n\",\n            P_HET_SCALE);\n    fprintf(fp, \"  -p, --homopoly-fix    Spread low-qual bases to both ends of homopolymers\\n\");\n    fprintf(fp, \"      --homopoly-score FLOAT\\n\"\n                \"                        Qual fraction adjustment for -p option [%g]\\n\", P_HOMOPOLY);\n    fprintf(fp, \"  -t, --qual-calibration FILE / :config (see man page)\\n\");\n    fprintf(fp, \"                        Load quality calibration file\\n\");\n    fprintf(fp, \"\\n\");\n    fprintf(fp, \"  -X, --config STR      Use pre-defined configuration set. STR from:\\n\");\n    fprintf(fp, \"                        hiseq, hifi, r10.4_sup, r10.4_dup and ultima\\n\");\n\n    fprintf(fp, \"\\nGlobal options:\\n\");\n    // Edited sam_global_opt_help(fp, \"-.---@-.\") help to expand -@ description.\n    fprintf(fp, \"      --input-fmt-option OPT[=VAL]\\n\");\n    fprintf(fp, \"               Specify a single input file format option in the form\\n\");\n    fprintf(fp, \"               of OPTION or OPTION=VALUE\\n\");\n    fprintf(fp, \"  -@, --threads INT\\n\");\n    fprintf(fp, \"               Number of additional decompression threads to use [0]\\n\");\n    fprintf(fp, \"      --verbosity INT\\n\");\n    fprintf(fp, \"               Set level of verbosity\\n\");\n    exit(exit_status);\n}\n\nint main_consensus(int argc, char **argv) {\n    int c, ret = 1;\n\n    consensus_opts opts = {\n        // User options\n        .mode         = MODE_RECALL,\n        .use_qual     = 0,\n        .min_qual     = 0,\n        .adj_qual     = 1,\n        .use_mqual    = 1,\n        .scale_mqual  = 1.00,\n        .nm_adjust    = 1,\n        .nm_halo      = 50,\n        .sc_cost      = 60,\n        .low_mqual    = 1,\n        .high_mqual   = 60,\n        .min_depth    = 1,\n        .call_fract   = 0.75,\n        .het_fract    = 0.5,\n        .het_only     = 0,\n        .fmt          = FASTA,\n        .cons_cutoff  = 10,\n        .ambig        = 0,\n        .line_len     = 70,\n        .default_qual = 10,\n        .all_bases    = 0,\n        .show_del     = 0,\n        .show_ins     = 1,\n        .mark_ins     = 0,\n        .incl_flags   = 0,\n        .excl_flags   = BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP,\n        .min_mqual    = 0,\n        .P_het        = P_HET,\n        .P_indel      = P_INDEL,\n        .het_scale    = P_HET_SCALE,\n        .homopoly_fix = 0,\n        .homopoly_redux = 0.01,\n\n        // Internal state\n        .ks_line      = {0,0},\n        .ks_ins_seq   = {0,0},\n        .ks_ins_qual  = {0,0},\n        .fp           = NULL,\n        .fp_out       = stdout,\n        .iter         = NULL,\n        .idx          = NULL,\n        .last_tid     = -1,\n        .last_pos     = -1,\n    };\n\n    set_qcal(&opts.qcal, QCAL_FLAT);\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', '-', '-', '@'),\n        {\"use-qual\",           no_argument,       NULL, 'q'},\n        {\"no-use-qual\",        no_argument,       NULL, 'q'+1000},\n        {\"adj-qual\",           no_argument,       NULL, 'q'+100},\n        {\"no-adj-qual\",        no_argument,       NULL, 'q'+101},\n        {\"use-MQ\",             no_argument,       NULL, 'm'+1000},\n        {\"no-use-MQ\",          no_argument,       NULL, 'm'+1001},\n        {\"adj-MQ\",             no_argument,       NULL, 'm'+100},\n        {\"no-adj-MQ\",          no_argument,       NULL, 'm'+101},\n        {\"NM-halo\",            required_argument, NULL, 'h'+100},\n        {\"SC-cost\",            required_argument, NULL, 'h'+101},\n        {\"scale-MQ\",           required_argument, NULL, 14},\n        {\"low-MQ\"   ,          required_argument, NULL,  9},\n        {\"high-MQ\",            required_argument, NULL, 10},\n        {\"min-depth\",          required_argument, NULL, 'd'},\n        {\"call-fract\",         required_argument, NULL, 'c'},\n        {\"het-fract\",          required_argument, NULL, 'H'},\n        {\"region\",             required_argument, NULL, 'r'},\n        {\"format\",             required_argument, NULL, 'f'},\n        {\"cutoff\",             required_argument, NULL, 'C'},\n        {\"ambig\",              no_argument,       NULL, 'A'},\n        {\"line-len\",           required_argument, NULL, 'l'},\n        {\"default-qual\",       required_argument, NULL, 1},\n        {\"het-only\",           no_argument,       NULL, 6},\n        {\"show-del\",           required_argument, NULL, 7},\n        {\"show-ins\",           required_argument, NULL, 8},\n        {\"mark-ins\",           no_argument,       NULL, 18},\n        {\"output\",             required_argument, NULL, 'o'},\n        {\"incl-flags\",         required_argument, NULL, 11},\n        {\"rf\",                 required_argument, NULL, 11},\n        {\"excl-flags\",         required_argument, NULL, 12},\n        {\"ff\",                 required_argument, NULL, 12},\n        {\"min-MQ\",             required_argument, NULL, 13},\n        {\"min-BQ\",             required_argument, NULL, 16},\n        {\"P-het\",              required_argument, NULL, 15},\n        {\"P-indel\",            required_argument, NULL, 17},\n        {\"het-scale\",          required_argument, NULL, 19},\n        {\"mode\",               required_argument, NULL, 'm'},\n        {\"homopoly-fix\",       no_argument,       NULL, 'p'},\n        {\"homopoly-score\",     required_argument, NULL, 'p'+100},\n        {\"homopoly-redux\",     required_argument, NULL, 'p'+200},\n        {\"qual-calibration\",   required_argument, NULL, 't'},\n        {\"config\",             required_argument, NULL, 'X'},\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"@:qd:c:H:r:5f:C:aAl:o:m:pt:X:\",\n                            lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'a': opts.all_bases++; break;\n        case 'q': opts.use_qual=1; break;\n        case 'q'+1000: opts.use_qual=0; break;\n        case 'm'+1000: opts.use_mqual=1; break;\n        case 'm'+1001: opts.use_mqual=0; break;\n        case 14:  opts.scale_mqual = atof(optarg); break;\n        case  9:  opts.low_mqual = atoi(optarg); break;\n        case 10:  opts.high_mqual = atoi(optarg); break;\n        case 'd': opts.min_depth = atoi(optarg); break;\n        case 'c': opts.call_fract = atof(optarg); break;\n        case 'H': opts.het_fract = atof(optarg); break;\n        case 'r': opts.reg = optarg; break;\n        case 'C': opts.cons_cutoff = atoi(optarg); break;\n        case 'A': opts.ambig = 1; break;\n        case 'p': opts.homopoly_fix = P_HOMOPOLY; break;\n        case 'p'+100: opts.homopoly_fix = atof(optarg); break;\n        case 'p'+200:\n          // EXPERIMENTAL\n          opts.homopoly_redux = atof(optarg); break;\n        case 1:   opts.default_qual = atoi(optarg); break;\n        case 6:   opts.het_only = 1; break;\n        case 7:   opts.show_del = (*optarg == 'y' || *optarg == 'Y'); break;\n        case 8:   opts.show_ins = (*optarg == 'y' || *optarg == 'Y'); break;\n        case 18:  opts.mark_ins = 1; break;\n        case 13:  opts.min_mqual = atoi(optarg); break;\n        case 16:  opts.min_qual  = atoi(optarg); break;\n        case 15:  opts.P_het = atof(optarg); break;\n        case 17:  opts.P_indel = atof(optarg); break;\n        case 19:  opts.het_scale = atof(optarg); break;\n        case 'q'+100: opts.adj_qual = 1; break;\n        case 'q'+101: opts.adj_qual = 0; break;\n        case 'm'+100: opts.nm_adjust = 1; break;\n        case 'm'+101: opts.nm_adjust = 0; break;\n        case 'h'+100: opts.nm_halo = atoi(optarg); break;\n        case 'h'+101: opts.sc_cost = atoi(optarg); break;\n\n        case 'm': // mode\n            if (strcasecmp(optarg, \"simple\") == 0) {\n                opts.mode = MODE_SIMPLE;\n            } else if (strcasecmp(optarg, \"bayesian_m\") == 0) {\n                // EXPERIMENTAL:\n                // A mixture of modified precise/recall params and a\n                // blending of the two.  Sometimes helps a bit.\n                opts.mode = MODE_MIXED;\n            } else if (strcasecmp(optarg, \"bayesian_p\") == 0) {\n                // EXPERIMENTAL:\n                // favours precision\n                opts.mode = MODE_PRECISE;\n            } else if (strcasecmp(optarg, \"bayesian_r\") == 0 ||\n                       strcasecmp(optarg, \"bayesian\") == 0) {\n                // favours recall; the default\n                opts.mode = MODE_RECALL;\n            } else if (strcasecmp(optarg, \"bayesian_116\") == 0) {\n                opts.mode = MODE_BAYES_116;\n            } else {\n                fprintf(stderr, \"Unknown mode %s\\n\", optarg);\n                return 1;\n            }\n            break;\n\n        case 'l':\n            if ((opts.line_len = atoi(optarg)) <= 0)\n                opts.line_len = INT_MAX;\n            break;\n\n        case 'f':\n            if (strcasecmp(optarg, \"fasta\") == 0) {\n                opts.fmt = FASTA;\n            } else if (strcasecmp(optarg, \"fastq\") == 0) {\n                opts.fmt = FASTQ;\n            } else if (strcasecmp(optarg, \"pileup\") == 0) {\n                opts.fmt = PILEUP;\n            } else {\n                fprintf(stderr, \"Unknown format %s\\n\", optarg);\n                return 1;\n            }\n            break;\n\n        case 'o':\n            if (!(opts.fp_out = fopen(optarg, \"w\"))) {\n                perror(optarg);\n                return 1;\n            }\n            break;\n\n        case 'X':\n            if (strcasecmp(optarg, \"hifi\") == 0) {\n                set_qcal(&opts.qcal, QCAL_HIFI);\n                opts.mode = MODE_RECALL;\n                opts.homopoly_fix = 0.3;\n                opts.homopoly_redux = 0.01;\n                opts.low_mqual = 5;\n                opts.scale_mqual = 1.5;\n                opts.het_scale = 0.37;\n            } else if (strcasecmp(optarg, \"hiseq\") == 0) {\n                opts.mode = MODE_RECALL;\n                set_qcal(&opts.qcal, QCAL_HISEQ);\n                opts.homopoly_redux = 0.01;\n            } else if (strcasecmp(optarg, \"r10.4_sup\") == 0) {\n                // Same as HiFi params, but ONT calibration table.\n                // At higher depth, hifi params work well for ONT\n                // when combined with ONT calibration chart.\n                //\n                // At lower depth we gain a bit from increasing homopoly_redux\n                set_qcal(&opts.qcal, QCAL_ONT_R10_4_SUP);\n                opts.mode = MODE_RECALL;\n                opts.homopoly_fix = 0.3;\n                opts.homopoly_redux = 0.01;\n                opts.low_mqual = 5;\n                opts.scale_mqual = 1.5;\n                opts.het_scale = 0.37;\n\n                // Also consider, for lower depth:\n                // opts.homopoly_redux = 1;\n                // opts.scale_mqual = 1;\n                // opts.het_scale = 0.45;\n            } else if (strcasecmp(optarg, \"r10.4_dup\") == 0) {\n                // Just a copy of of HiFi for duplex currently until\n                // we get a good truth set for calibration.\n                set_qcal(&opts.qcal, QCAL_ONT_R10_4_DUP);\n                opts.mode = MODE_RECALL;\n                opts.homopoly_fix = 0.3;\n                opts.homopoly_redux = 0.01;\n                opts.low_mqual = 5;\n                opts.scale_mqual = 1.5;\n                opts.het_scale = 0.37;\n            } else if (strcasecmp(optarg, \"ultima\") == 0) {\n                // Very similar to HiFi, but with own calibration table\n                opts.mode = MODE_RECALL;\n                set_qcal(&opts.qcal, QCAL_ULTIMA);\n                opts.homopoly_fix = 0.3;\n                opts.homopoly_redux = 0.01;\n                opts.het_scale = 0.37;\n                opts.scale_mqual = 2;\n                opts.low_mqual = 10;\n            } else {\n                // NB consider defaults that are a mixture of all above.\n                // Options are all similar for all bar Illumina.\n                // Unsure what :flat calibration table does to each of\n                // these though.\n                fprintf(stderr, \"Unrecognised configuration name: \\\"%s\\\"\\n\",\n                        optarg);\n                return 1;\n            }\n            break;\n\n        case 11:\n            if ((opts.incl_flags = bam_str2flag(optarg)) < 0) {\n                print_error(\"consensus\", \"could not parse --rf %s\", optarg);\n                return 1;\n            }\n            break;\n        case 12:\n            if ((opts.excl_flags = bam_str2flag(optarg)) < 0) {\n                print_error(\"consensus\", \"could not parse --ff %s\", optarg);\n                return 1;\n            }\n            break;\n\n        case 't': // --qual-calibration\n            if (load_qcal(&opts.qcal, optarg) < 0) {\n                print_error(\"consensus\",\n                            \"failed to load quality calibration '%s'\",\n                            optarg);\n                return -1;\n            }\n            break;\n\n         default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?':\n            usage_exit(stderr, EXIT_FAILURE);\n        }\n    }\n\n#if 0\n    // Dump out the qcal table.  Useful for copying into the code above.\n    int i;\n    qcal_t *q = &opts.qcal;\n    fprintf(stderr, \"{\");\n    for (i = 0; i < 100; i++)\n        fprintf(stderr, \"%2d,%s\", q->smap[i],(i+1)%10?\" \":\"\\n\");\n    fprintf(stderr, \"},\\n{\");\n    for (i = 0; i < 100; i++)\n        fprintf(stderr, \"%2d,%s\", q->umap[i],(i+1)%10?\" \":\"\\n\");\n    fprintf(stderr, \"},\\n{\");\n    for (i = 0; i < 100; i++)\n        fprintf(stderr, \"%2d,%s\", q->omap[i],(i+1)%10?\" \":\"\\n\");\n    fprintf(stderr, \"}\\n\");\n#endif\n\n    if (opts.mode != MODE_SIMPLE) {\n        if (opts.mode == MODE_PRECISE)\n            // More accuracy / precision, but a significant drop\n            // in recall.\n            consensus_init(opts.P_het, opts.P_indel,\n                           0.3 * opts.het_scale, opts.homopoly_redux,\n                           &opts.qcal, MODE_PRECISE, &cons_prob_precise);\n\n        if (opts.mode == MODE_MIXED)\n            // Blend these in when running in mixed mode, so we can\n            // keep sensitivity but have a better joint quality to\n            // reduce the FP rate.\n            consensus_init(pow(opts.P_het, 0.7), pow(opts.P_indel, 0.7),\n                           0.3 * opts.het_scale, opts.homopoly_redux,\n                           &opts.qcal, MODE_PRECISE, &cons_prob_precise);\n\n        // Better recall, at a cost of some accuracy (false positives)\n        consensus_init(opts.P_het, opts.P_indel, opts.het_scale,\n                       opts.mode == MODE_RECALL ? opts.homopoly_redux : 0.01,\n                       &opts.qcal, MODE_RECALL, &cons_prob_recall);\n    }\n\n    if (argc != optind+1) {\n        if (argc == optind) usage_exit(stdout, EXIT_SUCCESS);\n        else usage_exit(stderr, EXIT_FAILURE);\n    }\n    opts.fp = sam_open_format(argv[optind], \"r\", &ga.in);\n    if (opts.fp == NULL) {\n        print_error_errno(\"consensus\", \"Cannot open input file \\\"%s\\\"\",\n                          argv[optind]);\n        goto err;\n    }\n    if (ga.nthreads > 0)\n        hts_set_threads(opts.fp, ga.nthreads);\n\n    if (!(opts.h = sam_hdr_read(opts.fp))) {\n        fprintf(stderr, \"Failed to read header for \\\"%s\\\"\\n\", argv[optind]);\n        goto err;\n    }\n\n    if (opts.reg) {\n        opts.idx = sam_index_load(opts.fp, argv[optind]);\n        if (!opts.idx) {\n            print_error(\"consensus\", \"Cannot load index for input file \\\"%s\\\"\",\n                        argv[optind]);\n            goto err;\n        }\n        opts.iter = sam_itr_querys(opts.idx, opts.h, opts.reg);\n        if (!opts.iter) {\n            print_error(\"consensus\", \"Failed to parse region \\\"%s\\\"\",\n                        opts.reg);\n            goto err;\n        }\n    }\n\n    if (opts.fmt == PILEUP) {\n        if (pileup_loop(opts.fp, opts.h, readaln2,\n                        opts.mode != MODE_SIMPLE ? nm_init : NULL,\n                        basic_pileup,\n                        opts.mode != MODE_SIMPLE ? nm_free : NULL,\n                        &opts) < 0)\n            goto err;\n\n        if (opts.all_bases) {\n            int tid = opts.iter ? opts.iter->tid : opts.last_tid;\n            int len = sam_hdr_tid2len(opts.h, tid);\n            int pos = opts.last_pos;\n            if (opts.iter) {\n                len = MIN(opts.iter->end, len);\n                pos = MAX(opts.iter->beg, pos);\n            }\n            if (empty_pileup2(&opts, opts.h, tid, pos, len) < 0)\n                goto err;\n        }\n        while (!opts.iter && opts.all_bases > 1 &&\n               ++opts.last_tid < opts.h->n_targets) {\n            int len = sam_hdr_tid2len(opts.h, opts.last_tid);\n            if (empty_pileup2(&opts, opts.h, opts.last_tid, 0, len) < 0)\n                goto err;\n        }\n\n    } else {\n        if (pileup_loop(opts.fp, opts.h, readaln2,\n                        opts.mode != MODE_SIMPLE ? nm_init : NULL,\n                        basic_fasta,\n                        opts.mode != MODE_SIMPLE ? nm_free : NULL,\n                        &opts) < 0)\n            goto err;\n\n    next_ref_q:\n        if (opts.all_bases) {\n            // fill out terminator\n            int tid = opts.iter ? opts.iter->tid : opts.last_tid;\n            int len = sam_hdr_tid2len(opts.h, tid);\n            int pos = opts.last_pos;\n            if (opts.iter) {\n                len = MIN(opts.iter->end, len);\n                pos = MAX(opts.iter->beg, pos);\n                opts.last_tid = opts.iter->tid;\n            }\n            if (pos < len) {\n                if (ks_expand(&opts.ks_ins_seq,  len-pos+1) < 0)\n                    goto err;\n                if (ks_expand(&opts.ks_ins_qual, len-pos+1) < 0)\n                    goto err;\n                while (pos++ < len) {\n                    opts.ks_ins_seq.s [opts.ks_ins_seq.l++] = 'N';\n                    opts.ks_ins_qual.s[opts.ks_ins_qual.l++] = '!';\n                }\n                opts.ks_ins_seq.s [opts.ks_ins_seq.l] = 0;\n                opts.ks_ins_qual.s[opts.ks_ins_qual.l] = 0;\n            }\n        }\n        if (opts.last_tid >= 0)\n            dump_fastq(&opts, sam_hdr_tid2name(opts.h, opts.last_tid),\n                       opts.ks_ins_seq.s,  opts.ks_ins_seq.l,\n                       opts.ks_ins_qual.s, opts.ks_ins_qual.l);\n\n        if (!opts.iter && opts.all_bases > 1 &&\n            ++opts.last_tid < opts.h->n_targets) {\n            opts.last_pos = 0;\n            opts.ks_ins_seq.l = opts.ks_ins_qual.l = 0;\n            goto next_ref_q;\n        }\n//        if (consensus_loop(&opts) < 0) {\n//            print_error_errno(\"consensus\", \"Failed\");\n//            goto err;\n//        }\n    }\n\n    ret = 0;\n\n err:\n    if (opts.iter)\n        hts_itr_destroy(opts.iter);\n    if (opts.idx)\n        hts_idx_destroy(opts.idx);\n\n    if (opts.fp && sam_close(opts.fp) < 0) {\n        print_error_errno(\"consensus\", \"Closing input file \\\"%s\\\"\",\n                          argv[optind]);\n        ret = 1;\n    }\n\n    if (opts.h)\n        sam_hdr_destroy(opts.h);\n    sam_global_args_free(&ga);\n\n    if (opts.fp_out && opts.fp_out != stdout)\n        ret |= fclose(opts.fp_out) != 0;\n    else\n        ret |= fflush(stdout) != 0;\n\n    ks_free(&opts.ks_line);\n    ks_free(&opts.ks_ins_seq);\n    ks_free(&opts.ks_ins_qual);\n\n    if (ret)\n        print_error(\"consensus\", \"failed\");\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_fastq.c",
          "type": "blob",
          "size": 35.69921875,
          "content": "/*  bam_fastq.c -- FASTA and FASTQ file generation\n\n    Copyright (C) 2009-2017, 2019-2020, 2023-2024 Genome Research Ltd.\n    Portions copyright (C) 2009, 2011, 2012 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <stdbool.h>\n#include <ctype.h>\n#include <assert.h>\n#include <inttypes.h>\n#include <unistd.h>\n#include <float.h>\n\n#include \"htslib/sam.h\"\n#include \"htslib/klist.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/bgzf.h\"\n#include \"htslib/thread_pool.h\"\n#include \"htslib/khash.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\nKHASH_SET_INIT_STR(str)\ntypedef khash_t(str) strhash_t;\n\n#define DEFAULT_BARCODE_TAG \"BC\"\n#define DEFAULT_QUALITY_TAG \"QT\"\n#define INDEX_SEPARATOR \"+\"\n\nint8_t seq_comp_table[16] = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };\nstatic void bam2fq_usage(FILE *to, const char *command)\n{\n    int fq = strcasecmp(\"fastq\", command) == 0 || strcasecmp(\"bam2fq\", command) == 0;\n    fprintf(to,\n\"Usage: samtools %s [options...] <in.bam>\\n\", command);\n    fprintf(to,\n\"\\n\"\n\"Description:\\n\"\n\"Converts a SAM, BAM or CRAM to %s format.\\n\"\n\"\\n\"\n\"Options:\\n\"\n\"  -0 FILE      write reads designated READ_OTHER to FILE\\n\"\n\"  -1 FILE      write reads designated READ1 to FILE\\n\"\n\"  -2 FILE      write reads designated READ2 to FILE\\n\"\n\"  -o FILE      write reads designated READ1 or READ2 to FILE\\n\"\n\"               note: if a singleton file is specified with -s, only\\n\"\n\"               paired reads will be written to the -1 and -2 files.\\n\"\n\"  -d, --tag TAG[:VAL]\\n\"\n\"               only include reads containing TAG, optionally with value VAL\\n\"\n\"  -D, --tag-file STR:FILE\\n\"\n\"               only include reads containing TAG, with a value listed in FILE\\n\"\n\"  -f, --require-flags INT\\n\"\n\"               only include reads with all  of the FLAGs in INT present [0]\\n\"       //   F&x == x\n\"  -F, --excl[ude]-flags INT\\n\"\n\"               only include reads with none of the FLAGs in INT present [0x900]\\n\"   //   F&x == 0\n\"      --rf, --incl[ude]-flags INT\\n\"\n\"               only include reads with any  of the FLAGs in INT present [0]\\n\"       // !(F&x == 0)\n\"  -G INT       only EXCLUDE reads with all  of the FLAGs in INT present [0]\\n\"       // !(F&x == x)\n\"  -n           don't append /1 and /2 to the read name\\n\"\n\"  -N           always append /1 and /2 to the read name\\n\",\n    fq ? \"FASTQ\" : \"FASTA\");\n    if (fq) fprintf(to,\n\"  -O           output quality in the OQ tag if present\\n\");\n    fprintf(to,\n\"  -s FILE      write singleton reads designated READ1 or READ2 to FILE\\n\"\n\"  -t           copy RG, BC and QT tags to the %s header line\\n\",\n    fq ? \"FASTQ\" : \"FASTA\");\n    fprintf(to,\n\"  -T TAGLIST   copy arbitrary tags to the %s header line, '*' for all\\n\",\n    fq ? \"FASTQ\" : \"FASTA\");\n    if (fq) fprintf(to,\n\"  -v INT       default quality score if not given in file [1]\\n\"\n\"  -i           add Illumina Casava 1.8 format entry to header (eg 1:N:0:ATCACG)\\n\"\n\"  -c INT       compression level [0..9] to use when writing bgzf files [1]\\n\"\n\"  --i1 FILE    write first index reads to FILE\\n\"\n\"  --i2 FILE    write second index reads to FILE\\n\"\n\"  --barcode-tag TAG\\n\"\n\"               Barcode tag [\" DEFAULT_BARCODE_TAG \"]\\n\"\n\"  --quality-tag TAG\\n\"\n\"               Quality tag [\" DEFAULT_QUALITY_TAG \"]\\n\"\n\"  --index-format STR\\n\"\n\"               How to parse barcode and quality tags\\n\\n\");\n    sam_global_opt_help(to, \"-.--.@-.\");\n    fprintf(to,\n\"\\n\"\n\"The files will be automatically compressed if the file names have a .gz\\n\"\n\"or .bgzf extension.  The input to this program must be collated by name.\\n\"\n\"Run 'samtools collate' or 'samtools sort -n' to achieve this.\\n\"\n\"\\n\"\n\"Reads are designated READ1 if FLAG READ1 is set and READ2 is not set.\\n\"\n\"Reads are designated READ2 if FLAG READ1 is not set and READ2 is set.\\n\"\n\"Otherwise reads are designated READ_OTHER (both flags set or both flags unset).\\n\"\n\"Run 'samtools flags' for more information on flag codes and meanings.\\n\");\n    fprintf(to,\n\"\\n\"\n\"The index-format string describes how to parse the barcode and quality tags.\\n\"\n\"It is made up of 'i' or 'n' followed by a length or '*'.  For example:\\n\"\n\"   i14i8       The first 14 characters are index 1, the next 8 are index 2\\n\"\n\"   n8i14       Ignore the first 8 characters, and use the next 14 for index 1\\n\\n\"\n\"If the tag contains a separator, then the numeric part can be replaced with\\n\"\n\"'*' to mean 'read until the separator or end of tag', for example:\\n\"\n\"   i*i*        Break the tag at the separator into index 1 and index 2\\n\"\n\"   n*i*        Ignore the left part of the tag until the separator,\\n\"\n\"               then use the second part of the tag as index 1\\n\");\n    fprintf(to,\n\"\\n\"\n\"Examples:\\n\"\n\"To get just the paired reads in separate files, use:\\n\"\n\"   samtools %s -1 pair1.%s -2 pair2.%s -0 /dev/null -s /dev/null -n in.bam\\n\"\n\"\\nTo get all non-supplementary/secondary reads in a single file, redirect\\n\"\n\"the output:\\n\"\n\"   samtools %s in.bam > all_reads.%s\\n\",\n            command, fq ? \"fq\" : \"fa\", fq ? \"fq\" : \"fa\",\n            command, fq ? \"fq\" : \"fa\");\n}\n\ntypedef enum { READ_UNKNOWN = 0, READ_1 = 1, READ_2 = 2 } readpart;\ntypedef enum { FASTA, FASTQ } fastfile;\ntypedef struct bam2fq_opts {\n    char *fnse;\n    char *fnr[3];\n    char *fn_input; // pointer to input filename in argv do not free\n    bool has12, has12always, use_oq, copy_tags, illumina_tag;\n    int flag_on, flag_off, flag_alloff, flag_anyon;\n    sam_global_args ga;\n    fastfile filetype;\n    int def_qual;\n    char *barcode_tag;\n    char *quality_tag;\n    char *index_file[2];\n    char *index_format;\n    char *extra_tags;\n    char compression_level;\n    const char *filter_tag;       // -d opt\n    strhash_t *filter_tag_vals;\n} bam2fq_opts_t;\n\ntypedef struct bam2fq_state {\n    samFile *fp;\n    samFile *fpse;\n    samFile *fpr[3];\n    samFile *fpi[3];\n    samFile *hstdout;\n    sam_hdr_t *h;\n    bool has12, use_oq, copy_tags, illumina_tag;\n    int flag_on, flag_off, flag_alloff, flag_anyon;\n    fastfile filetype;\n    int def_qual;\n    char *index_sequence;\n    char compression_level;\n    htsThreadPool p;\n} bam2fq_state_t;\n\n// Adds a single tag value to the filter tag value hash\nstatic int add_tag_value(bam2fq_opts_t *opts, char *val) {\n    if (!opts->filter_tag_vals) {\n        if (!(opts->filter_tag_vals = kh_init(str)))\n            return -1;\n    }\n\n    if (!(val = strdup(val)))\n        return -1;\n\n    int ret = 0;\n    kh_put(str, opts->filter_tag_vals, val, &ret);\n    if (ret <= 0)\n        free(val);\n\n    return ret < 0 ? -1 : 0;\n}\n\n// Adds multiple values, listed in a file\nstatic int add_tag_file(bam2fq_opts_t *opts, char *fn) {\n    FILE *fp;\n    kstring_t ks = {0,0};\n\n    if (!(fp = fopen(fn, \"r\"))) {\n        print_error_errno(\"fastq\", \"failed to open \\\"%s\\\" for reading\", fn);\n        return -1;\n    }\n\n    while (ks.l = 0, kgetline(&ks, (kgets_func *)fgets, fp) >= 0) {\n        if (add_tag_value(opts, ks.s) < 0) {\n            ks_free(&ks);\n            return -1;\n        }\n    }\n\n    ks_free(&ks);\n    return 0;\n}\n\nstatic readpart which_readpart(const bam1_t *b)\n{\n    if ((b->core.flag & BAM_FREAD1) && !(b->core.flag & BAM_FREAD2)) {\n        return READ_1;\n    } else if ((b->core.flag & BAM_FREAD2) && !(b->core.flag & BAM_FREAD1)) {\n        return READ_2;\n    } else {\n        return READ_UNKNOWN;\n    }\n}\n\nstatic void free_opts(bam2fq_opts_t *opts)\n{\n    if (opts->filter_tag_vals) {\n        khint_t k;\n        for (k = 0; k < kh_end(opts->filter_tag_vals); k++)\n            if (kh_exist(opts->filter_tag_vals, k))\n                free((char *)kh_key(opts->filter_tag_vals, k));\n\n        kh_destroy(str, opts->filter_tag_vals);\n    }\n    free(opts);\n}\n\n// Make mnemonic distinct values for longoption-only options\n#define LONGOPT(c)  ((c) + 128)\n\n// return true if valid\nstatic bool parse_opts(int argc, char *argv[], bam2fq_opts_t** opts_out)\n{\n    // Parse args\n    bam2fq_opts_t* opts = calloc(1, sizeof(bam2fq_opts_t));\n    opts->has12 = true;\n    opts->has12always = false;\n    opts->filetype = FASTQ;\n    opts->def_qual = 1;\n    opts->barcode_tag = NULL;\n    opts->quality_tag = NULL;\n    opts->index_format = NULL;\n    opts->index_file[0] = NULL;\n    opts->index_file[1] = NULL;\n    opts->extra_tags = NULL;\n    opts->compression_level = 1;\n    opts->flag_off = BAM_FSECONDARY|BAM_FSUPPLEMENTARY;\n\n    int c;\n    sam_global_args_init(&opts->ga);\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 0, '@'),\n        {\"require-flags\", required_argument, NULL, 'f'},\n        {\"excl-flags\", required_argument, NULL, 'F'},\n        {\"exclude-flags\", required_argument, NULL, 'F'},\n        // following the same convention as view: g exists as a longoption_only\n        // argument, accessible from the command line as --rf/--incl[ude]-flags\n        {\"rf\", required_argument, NULL, LONGOPT('g')},\n        {\"incl-flags\", required_argument, NULL, LONGOPT('g')},\n        {\"include-flags\", required_argument, NULL, LONGOPT('g')},\n        {\"i1\", required_argument, NULL, 1},\n        {\"I1\", required_argument, NULL, 1},\n        {\"i2\", required_argument, NULL, 2},\n        {\"I2\", required_argument, NULL, 2},\n        {\"if\", required_argument, NULL, 3},\n        {\"IF\", required_argument, NULL, 3},\n        {\"index-format\", required_argument, NULL, 3},\n        {\"barcode-tag\", required_argument, NULL, 'b'},\n        {\"quality-tag\", required_argument, NULL, 'q'},\n        {\"tag\", required_argument, NULL, 'd'},\n        {\"tag-file\", required_argument, NULL, 'D'},\n        { NULL, 0, NULL, 0 }\n    };\n    while ((c = getopt_long(argc, argv, \"0:1:2:o:f:F:G:niNOs:c:tT:v:@:d:D:\",\n                            lopts, NULL)) > 0) {\n        switch (c) {\n            case 'b': opts->barcode_tag = optarg; break;\n            case 'q': opts->quality_tag = optarg; break;\n            case  1 : opts->index_file[0] = optarg; break;\n            case  2 : opts->index_file[1] = optarg; break;\n            case  3 : opts->index_format = optarg; break;\n            case '0': opts->fnr[0] = optarg; break;\n            case '1': opts->fnr[1] = optarg; break;\n            case '2': opts->fnr[2] = optarg; break;\n            case 'o': opts->fnr[1] = optarg; opts->fnr[2] = optarg; break;\n            case 'f': opts->flag_on |= strtol(optarg, 0, 0); break;\n            // note that flag_off does not have |= because it has a default\n            // value of 0x900 which needs to be replaced by the optarg\n            case 'F': opts->flag_off = strtol(optarg, 0, 0); break;\n            case 'G': opts->flag_alloff |= strtol(optarg, 0, 0); break;\n            case LONGOPT('g'): opts->flag_anyon |= strtol(optarg, 0, 0); break;\n            case 'n': opts->has12 = false; break;\n            case 'N': opts->has12always = true; break;\n            case 'O': opts->use_oq = true; break;\n            case 's': opts->fnse = optarg; break;\n            case 't': opts->copy_tags = true; break;\n            case 'i': opts->illumina_tag = true; break;\n            case 'c':\n                opts->compression_level = atoi(optarg);\n                if (opts->compression_level < 0)\n                    opts->compression_level = 0;\n                if (opts->compression_level > 9)\n                    opts->compression_level = 9;\n                break;\n            case 'T': opts->extra_tags = optarg; break;\n            case 'v': opts->def_qual = atoi(optarg); break;\n\n            case 'd':\n                if (strlen(optarg) < 2 ||\n                    (strlen(optarg) > 2 && optarg[2] != ':')) {\n                    print_error(\"fastq\",\n                                \"Invalid \\\"tag:value\\\" option: \\\"%s\\\"\",\n                                optarg);\n                    free_opts(opts);\n                    return false;\n                }\n\n                if (opts->filter_tag && memcmp(opts->filter_tag, optarg, 2)) {\n                    print_error(\"fastq\", \"Different tag type specified \"\n                                \"to before\");\n                    free_opts(opts);\n                    return false;\n                }\n\n                if (strlen(optarg) >= 3)\n                    add_tag_value(opts, optarg+3);\n                opts->filter_tag = optarg;\n                break;\n\n            case 'D':\n                // Allow \";\" as delimiter besides \":\" to support MinGW CLI POSIX\n                // path translation as described at:\n                // http://www.mingw.org/wiki/Posix_path_conversion\n                if (strlen(optarg) < 4\n                    || (optarg[2] != ':' && optarg[2] != ';')) {\n                    print_error(\"view\", \"Invalid \\\"tag:file\\\" option: \\\"%s\\\"\",\n                                optarg);\n                    free_opts(opts);\n                    return false;\n                }\n\n                if (opts->filter_tag && memcmp(opts->filter_tag, optarg, 2)) {\n                    print_error(\"fastq\", \"Different tag type specified \"\n                                \"to before\");\n                    free_opts(opts);\n                    return false;\n                }\n\n                if (strlen(optarg) >= 3) {\n                    if (add_tag_file(opts, optarg+3) < 0) {\n                        free_opts(opts);\n                        return false;\n                    }\n                }\n                opts->filter_tag = optarg;\n                break;\n\n            case '?':\n                bam2fq_usage(stderr, argv[0]);\n                free_opts(opts);\n                return false;\n            default:\n                if (parse_sam_global_opt(c, optarg, lopts, &opts->ga) != 0) {\n                    bam2fq_usage(stderr, argv[0]);\n                    free_opts(opts);\n                    return false;\n                }\n                break;\n        }\n    }\n\n    if (opts->fnr[1] || opts->fnr[2]) opts->has12 = false;\n    if (opts->has12always) opts->has12 = true;\n\n    if (!opts->barcode_tag) opts->barcode_tag = DEFAULT_BARCODE_TAG;\n    if (!opts->quality_tag) opts->quality_tag = DEFAULT_QUALITY_TAG;\n\n    int nIndex = 0;\n    if (opts->index_format) {\n        char *s;\n        for (s = opts->index_format; *s; s++) {\n            if (*s == 'i') nIndex++;\n        }\n    }\n    if (nIndex>2) {\n        fprintf(stderr,\"Invalid index format: more than 2 indexes\\n\");\n        bam2fq_usage(stderr, argv[0]);\n        free_opts(opts);\n        return false;\n    }\n\n    if (opts->index_file[1] && !opts->index_file[0]) {\n        fprintf(stderr, \"Index one specified, but index two not given\\n\");\n        bam2fq_usage(stderr, argv[0]);\n        free_opts(opts);\n        return false;\n    }\n\n    if (opts->illumina_tag && !nIndex) {\n        fprintf(stderr, \"You must specify an index format (--index-format) with the Illumina Casava (-i) option\\n\");\n        bam2fq_usage(stderr, argv[0]);\n        free_opts(opts);\n        return false;\n    }\n\n    if (nIndex==0 && opts->index_file[0]) {\n        fprintf(stderr, \"index_format not specified, but index file given\\n\");\n        bam2fq_usage(stderr, argv[0]);\n        free_opts(opts);\n        return false;\n    }\n\n    if (opts->def_qual < 0 || 93 < opts->def_qual) {\n        fprintf(stderr, \"Invalid -v default quality %i, allowed range 0 to 93\\n\", opts->def_qual);\n        bam2fq_usage(stderr, argv[0]);\n        free_opts(opts);\n        return false;\n    }\n\n    const char* type_str = argv[0];\n    if (strcasecmp(\"fastq\", type_str) == 0 ||\n        strcasecmp(\"bam2fq\", type_str) == 0) {\n        opts->filetype = FASTQ;\n    } else if (strcasecmp(\"fasta\", type_str) == 0) {\n        opts->filetype = FASTA;\n    } else {\n        print_error(\"bam2fq\", \"Unrecognised type call \\\"%s\\\", this should be impossible... but you managed it!\", type_str);\n        bam2fq_usage(stderr, argv[0]);\n        free_opts(opts);\n        return false;\n    }\n\n    if (argc == optind && isatty(STDIN_FILENO)) {\n        bam2fq_usage(stdout, argv[0]);\n        free_opts(opts);\n        return true;\n    }\n\n    if (argc - optind > 1) {\n        fprintf(stderr, \"Too many arguments.\\n\");\n        bam2fq_usage(stderr, argv[0]);\n        free_opts(opts);\n        return false;\n    }\n    opts->fn_input = argc > optind ? argv[optind] : \"-\";\n    *opts_out = opts;\n    return true;\n}\n\nvoid set_sam_opts(samFile *fp, bam2fq_state_t *state,\n                  const bam2fq_opts_t *opts) {\n    if (state->has12)\n        hts_set_opt(fp, FASTQ_OPT_RNUM, 1);\n\n    if (state->illumina_tag)\n        hts_set_opt(fp, FASTQ_OPT_CASAVA, 1);\n\n    hts_set_opt(fp, FASTQ_OPT_BARCODE, opts->barcode_tag);\n\n    if (opts->extra_tags && (*opts->extra_tags == '*' || *opts->extra_tags == '\\0'))\n        hts_set_opt(fp, FASTQ_OPT_AUX, NULL);\n    else {\n        kstring_t tag_list = {0,0};\n        if (state->copy_tags)\n            kputs(\"RG,BC,QT\", &tag_list);\n        if (opts->extra_tags) {\n            if (tag_list.l)\n                kputc(',', &tag_list);\n            kputs(opts->extra_tags, &tag_list);\n        }\n        if (tag_list.l)\n            hts_set_opt(fp, FASTQ_OPT_AUX, tag_list.s);\n        ks_free(&tag_list);\n    }\n}\n\n// Open a file as normal or gzipped based on filename.\n// Note we always use bgzf and don't bother to attempt non-blocked\n// gzip streams.  This is a departure from the old fastq code.\nstatic samFile *sam_open_z(char *fn, char *mode, bam2fq_state_t *state) {\n    char modez[6];\n    strcpy(modez, mode);\n\n    size_t l = strlen(fn);\n    if ((l > 3 && strcmp(fn+l-3, \".gz\") == 0) ||\n        (l > 4 && strcmp(fn+l-4, \".bgz\") == 0) ||\n        (l > 5 && strcmp(fn+l-5, \".bgzf\") == 0)) {\n        char m[3] = {'z', state->compression_level+'0', '\\0'};\n        strcat(modez, m);\n    }\n\n    samFile *fp = sam_open(fn, modez);\n    if (!fp)\n        return NULL;\n\n    if (state->p.pool)\n        hts_set_thread_pool(fp, &state->p);\n\n    return fp;\n}\n\nstatic bool init_state(const bam2fq_opts_t* opts, bam2fq_state_t** state_out)\n{\n    char *mode = opts->filetype == FASTA ? \"wF\" : \"wf\";\n\n    bam2fq_state_t* state = calloc(1, sizeof(bam2fq_state_t));\n    if (!state)\n        return false;\n    state->flag_on = opts->flag_on;\n    state->flag_off = opts->flag_off;\n    state->flag_alloff = opts->flag_alloff;\n    state->flag_anyon = opts->flag_anyon;\n    state->has12 = opts->has12;\n    state->use_oq = opts->use_oq;\n    state->illumina_tag = opts->illumina_tag;\n    state->copy_tags = opts->copy_tags;\n    state->filetype = opts->filetype;\n    state->def_qual = opts->def_qual;\n    state->index_sequence = NULL;\n    state->hstdout = NULL;\n    state->compression_level = opts->compression_level;\n\n    state->fp = sam_open_format(opts->fn_input, \"r\", &opts->ga.in);\n    if (state->fp == NULL) {\n        print_error_errno(\"bam2fq\",\"Cannot read file \\\"%s\\\"\", opts->fn_input);\n        free(state);\n        return false;\n    }\n\n    state->p.pool = NULL;\n    if (opts->ga.nthreads > 0) {\n        if (!(state->p.pool = hts_tpool_init(opts->ga.nthreads))) {\n            fprintf(stderr, \"Failed to create thread pool\\n\");\n            free(state);\n            return false;\n        }\n        state->p.qsize = opts->ga.nthreads*2;\n        hts_set_thread_pool(state->fp, &state->p);\n    }\n\n    uint32_t rf = SAM_QNAME | SAM_FLAG | SAM_SEQ | SAM_QUAL;\n    if (opts->use_oq || opts->extra_tags || opts->index_file[0])\n        rf |= SAM_AUX;\n    if (opts->filter_tag) {\n        if (memcmp(opts->filter_tag, \"NM\", 2) == 0 ||\n            memcmp(opts->filter_tag, \"MD\", 2) == 0)\n            rf |= SAM_AUX | SAM_SEQ;\n        else if (memcmp(opts->filter_tag, \"RG\", 2) == 0)\n            rf |= SAM_RGAUX;\n        else\n            rf |= SAM_AUX;\n    }\n    if (opts->illumina_tag || opts->copy_tags)\n        rf |= SAM_AUX;\n    if (hts_set_opt(state->fp, CRAM_OPT_REQUIRED_FIELDS, rf)) {\n        fprintf(stderr, \"Failed to set CRAM_OPT_REQUIRED_FIELDS value\\n\");\n        free(state);\n        return false;\n    }\n    if (hts_set_opt(state->fp, CRAM_OPT_DECODE_MD, 0)) {\n        fprintf(stderr, \"Failed to set CRAM_OPT_DECODE_MD value\\n\");\n        free(state);\n        return false;\n    }\n    if (opts->fnse) {\n        if (!(state->fpse = sam_open_z(opts->fnse, mode, state))) {\n            print_error_errno(\"bam2fq\", \"Cannot open singleton file \\\"%s\\\"\", opts->fnse);\n            free(state);\n            return false;\n        }\n        set_sam_opts(state->fpse, state, opts);\n    }\n\n    if (opts->ga.reference) {\n        if (hts_set_fai_filename(state->fp, opts->ga.reference) != 0) {\n            print_error_errno(\"bam2fq\", \"cannot load reference \\\"%s\\\"\", opts->ga.reference);\n            free(state);\n            return false;\n        }\n    }\n\n    // single, read1, read2\n    int i, j;\n    for (i = 0; i < 3; ++i) {\n        if (opts->fnr[i]) {\n            for (j = 0; j < i; j++)\n                if (opts->fnr[j] && strcmp(opts->fnr[j], opts->fnr[i]) == 0)\n                    break;\n            if (j == i) {\n                if (!(state->fpr[i] = sam_open_z(opts->fnr[i], mode, state))) {\n                    print_error_errno(\"bam2fq\", \"Cannot open r%d file \\\"%s\\\"\",\n                                      i, opts->fnr[i]);\n                    free(state);\n                    return false;\n                }\n                set_sam_opts(state->fpr[i], state, opts);\n            } else {\n                state->fpr[i] = state->fpr[j];\n            }\n        } else {\n            if (!state->hstdout) {\n                if (!(state->hstdout = sam_open_z(\"-\", mode, state))) {\n                    print_error_errno(\"bam2fq\", \"Cannot open STDOUT\");\n                    free(state);\n                    return false;\n                }\n                set_sam_opts(state->hstdout, state, opts);\n                autoflush_if_stdout(state->hstdout, \"-\");\n            }\n            state->fpr[i] = state->hstdout;\n        }\n    }\n\n    // index 1, index 2\n    for (i = 0; i < 2; i++) {\n        state->fpi[i] = NULL;\n        if (opts->index_file[i]) {\n            for (j = 0; j < 3; j++)\n                if (opts->fnr[j] && strcmp(opts->fnr[j], opts->index_file[i]) == 0)\n                    break;\n            for (j -= 3; j >= 0 && j < i; j++)\n                if (opts->index_file[j] && strcmp(opts->index_file[j], opts->index_file[i]) == 0)\n                    break;\n            if (i == j) {\n                if (!(state->fpi[i] = sam_open_z(opts->index_file[i], mode,\n                                                 state))) {\n                    print_error_errno(\"bam2fq\", \"Cannot open i%d file \\\"%s\\\"\",\n                                      i+1, opts->index_file[i]);\n                    free(state);\n                    return false;\n                }\n                set_sam_opts(state->fpi[i], state, opts);\n            } else if (j < 0) {\n                state->fpi[i] = state->fpr[j+3];\n            } else {\n                state->fpi[i] = state->fpi[j];\n            }\n        }\n    }\n\n    state->h = sam_hdr_read(state->fp);\n    if (state->h == NULL) {\n        fprintf(stderr, \"Failed to read header for \\\"%s\\\"\\n\", opts->fn_input);\n        free(state);\n        return false;\n    }\n\n    *state_out = state;\n    return true;\n}\n\nstatic bool destroy_state(const bam2fq_opts_t *opts, bam2fq_state_t *state, int* status)\n{\n    bool valid = true;\n    sam_hdr_destroy(state->h);\n    check_sam_close(\"bam2fq\", state->fp, opts->fn_input, \"file\", status);\n    if (state->fpse && sam_close(state->fpse) < 0) {\n        print_error_errno(\"bam2fq\", \"Error closing singleton file \\\"%s\\\"\", opts->fnse);\n        valid = false;\n    }\n\n    int i, j;\n    for (i = 0; i < 3; ++i) {\n        if (state->fpr[i] != state->hstdout) {\n            for (j = 0; j < i; j++)\n                if (state->fpr[i] == state->fpr[j])\n                    break;\n            if (j == i && sam_close(state->fpr[i])) {\n                print_error_errno(\"bam2fq\", \"Error closing r%d file \\\"%s\\\"\", i, opts->fnr[i]);\n                valid = false;\n            }\n        }\n    }\n    if (state->hstdout) {\n        release_autoflush(state->hstdout);\n        if (sam_close(state->hstdout) < 0) {\n            print_error_errno(\"bam2fq\", \"Error closing STDOUT\");\n            valid = false;\n        }\n    }\n    for (i = 0; i < 2; i++) {\n        for (j = 0; j < 3; j++)\n            if (state->fpi[i] == state->fpr[j])\n                break;\n        for (j -= 3; j >= 0 && j < i; j++)\n            if (state->fpi[i] == state->fpi[j])\n                break;\n        if (j == i && state->fpi[i] && sam_close(state->fpi[i]) < 0) {\n            print_error_errno(\"bam2fq\", \"Error closing i%d file \\\"%s\\\"\", i+1, opts->index_file[i]);\n            valid = false;\n        }\n    }\n    free(state->index_sequence);\n    if (state->p.pool)\n        hts_tpool_destroy(state->p.pool);\n    free(state);\n    return valid;\n}\n\nstatic inline bool filter_it_out(const bam1_t *b, const bam2fq_state_t *state,\n                                 bam2fq_opts_t *opts)\n{\n    if (opts->filter_tag) {\n        uint8_t *s = bam_aux_get(b, opts->filter_tag);\n        if (!s)\n            return true;\n\n        if (opts->filter_tag_vals) {\n            char t[32], *val = t;\n            switch (*s) {\n            case 'i': case 'I':\n            case 's': case 'S':\n            case 'c': case 'C':\n                if (snprintf(t, 32, \"%\"PRId64, bam_aux2i(s)) <= 0)\n                    return true;\n                break;\n\n            case 'f':\n                // Comparing floats is hard.\n                // Eg (double)0.1 - (double)0.1f is -1.5e-9.\n                // Given BAM binary encoding is float however, just keep it.\n                // This means rounding errors will (hopefully) always be the\n                // same and basic equality still works.\n                if (snprintf(t, 32, \"%f\", (float)bam_aux2f(s)) <= 0)\n                    return true;\n                break;\n\n            case 'A':\n                t[0] = s[1];\n                t[1] = 0;\n                break;\n\n            case 'Z': case 'H':\n                val = (char *)s+1;\n                break;\n\n            default:\n                // Anything unsupported fails the filter match too.\n                return true;\n            }\n\n            khint_t k = kh_get(str, opts->filter_tag_vals, val);\n            if (k == kh_end(opts->filter_tag_vals))\n                return 1; // tag value not found\n        }\n    }\n\n    return ((b->core.flag&(state->flag_on)) != state->flag_on // or reads indicated by filter flags\n        ||  (b->core.flag&(state->flag_off)) != 0\n        ||  (((b->core.flag&(state->flag_anyon)) == 0) && (state->flag_anyon != 0))\n        ||  (b->core.flag&(state->flag_alloff) && (b->core.flag&(state->flag_alloff)) == state->flag_alloff));\n\n}\n\nint write_index_rec(samFile *fp, bam1_t *b, bam2fq_state_t *state,\n                    bam2fq_opts_t* opts, char *seq, int seq_len,\n                    char *qual, int qual_len) {\n    if (!fp || !b || !seq_len)\n        return 0;\n\n    int ret = -1;\n    bam1_t *b2 = bam_init1(); // FIXME: reuse\n    if (!b2)\n        return -1;\n\n    size_t aux_len = b->data + b->l_data - bam_get_aux(b);\n    if (bam_set1(b2, b->core.l_qname, bam_get_qname(b),\n                 (b->core.flag | BAM_FUNMAP) & ~BAM_FREVERSE,\n                 -1, -1, 0,    // refid, pos, mapq\n                 0, NULL,      // cigar\n                 -1, -1, 0,    // rnext, pnext, tlen\n                 seq_len, seq, qual,\n                 aux_len) < 0)\n        goto err;\n\n    uint8_t *q = bam_get_qual(b2);\n    if (qual) {\n        int i;\n        for (i = 0; i < seq_len; i++)\n            q[i] -= '!';\n    } else {\n        memset(q, opts->def_qual, seq_len);\n    }\n\n    memcpy(bam_get_aux(b2), bam_get_aux(b), aux_len);\n    b2->l_data += aux_len;\n    if (sam_write1(fp, state->h, b2) < 0)\n        goto err;\n\n    ret = 0;\n err:\n    if (b2)\n        bam_destroy1(b2);\n    return ret;\n}\n\nint output_index(bam1_t *b1, bam1_t *b2, bam2fq_state_t *state,\n                 bam2fq_opts_t* opts) {\n    bam1_t *b = b1 ? b1 : b2;\n\n    char *ifmt = opts->index_format;\n    if (!ifmt)\n        ifmt = \"i*i*\";\n\n    // Get seq / qual elements\n    char *bc = NULL, *qt = NULL;\n    if (b1)\n        bc = (char *)bam_aux_get(b1, opts->barcode_tag);\n    if (b2 && !bc)\n        bc = (char *)bam_aux_get(b2, opts->barcode_tag);\n    if (!bc)\n        return 0;\n    else\n        bc++; // skip Z\n\n    if (b1)\n        qt = (char *)bam_aux_get(b1, opts->quality_tag);\n    if (b2 && !qt)\n        qt = (char *)bam_aux_get(b2, opts->quality_tag);\n    if (qt && strlen(bc) != strlen(qt)-1)\n        qt = NULL;\n    else if (qt)\n        qt++;\n\n    int inum = 0;\n    while (inum < 2) {\n        char fc = *ifmt++;\n        if (!fc)\n            break; // ran out of index-format\n\n        long len, rem = 0;\n        if (isdigit(*ifmt)) {\n            rem = len = strtol(ifmt, &ifmt, 10);\n        } else {\n            ifmt++;\n            len = 0;\n        }\n\n        char *bc_end = bc, *qt_end = qt;\n        if (qt) {\n            while (len ? *bc_end && rem-- : isalpha(*bc_end))\n                bc_end++, qt_end++;\n        } else {\n            while (len ? *bc_end && rem-- : isalpha(*bc_end))\n                bc_end++;\n        }\n\n        switch (fc) {\n        case 'n':\n            // skip\n            bc = bc_end + (len==0);\n            if (qt)\n                qt = qt_end + (len==0);\n            break;\n\n        case 'i':\n            if (write_index_rec(state->fpi[inum], b, state, opts,\n                                bc, bc_end-bc, qt, qt_end-qt) < 0)\n                return -1;\n            bc = bc_end + (len==0);\n            if (qt)\n                qt = qt_end + (len==0);\n            inum++;\n            break;\n\n        default:\n            fprintf(stderr, \"Unknown index-format code\\n\");\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nstatic int flush_rec(bam2fq_state_t *state, bam2fq_opts_t* opts,\n                     bam1_t *b[4], int score[3], int best[3],\n                     int64_t *n_singletons) {\n    // Paired data, with 1 or 2 ends present.\n    if (score[1] > 0 && score[2] > 0) {\n        // If CASAVA tag is required and barcode is only on R1,\n        // copy it to R2\n        if (state->illumina_tag) {\n            char *tag;\n            if ((tag = (char *)bam_aux_get(b[best[1]],\n                                           opts->barcode_tag)))\n                if (bam_aux_update_str(b[best[2]],\n                                       opts->barcode_tag,\n                                       strlen(tag), tag+1) < 0)\n                    goto err;\n            if ((tag = (char *)bam_aux_get(b[best[1]],\n                                           opts->quality_tag)))\n                if (bam_aux_update_str(b[best[2]],\n                                       opts->quality_tag,\n                                       strlen(tag), tag+1) < 0)\n                    goto err;\n\n        }\n        if (sam_write1(state->fpr[1], state->h, b[best[1]]) < 0)\n            goto err;\n        if (sam_write1(state->fpr[2], state->h, b[best[2]]) < 0)\n            goto err;\n\n        if (output_index(b[best[1]], b[best[2]], state, opts) < 0)\n            goto err;\n    } else if (score[1] > 0 || score[2] > 0) {\n        if (state->fpse) {\n            // print whichever one exists to fpse\n            if (score[1] > 0) {\n                if (sam_write1(state->fpse, state->h, b[best[1]]) < 0)\n                    goto err;\n            } else {\n                if (sam_write1(state->fpse, state->h, b[best[2]]) < 0)\n                    goto err;\n            }\n            ++(*n_singletons);\n        } else {\n            if (score[1] > 0) {\n                if (sam_write1(state->fpr[1], state->h, b[best[1]]) < 0)\n                    goto err;\n            } else {\n                if (sam_write1(state->fpr[2], state->h, b[best[2]]) < 0)\n                    goto err;\n            }\n        }\n\n        if (output_index(score[1] > 0 ? b[best[1]] : NULL,\n                         score[2] > 0 ? b[best[2]] : NULL,\n                         state, opts) < 0)\n            goto err;\n    }\n\n    if (score[0]) { // single ended data (neither READ1 nor READ2)\n        if (sam_write1(state->fpr[0], state->h, b[best[0]]) < 0)\n            goto err;\n\n        if (output_index(b[best[0]], NULL, state, opts) < 0)\n            goto err;\n    }\n\n    return 0;\n\n err:\n    return -1;\n}\n\nstatic bool bam2fq_mainloop(bam2fq_state_t *state, bam2fq_opts_t* opts)\n{\n    int n;\n    char *current_qname = NULL;\n    int64_t n_reads = 0, n_singletons = 0; // Statistics\n    int score[3];\n    int at_eof;\n    bool valid = false;\n    int best[3] = {-1, -1, -1}; // map R0, R1, single to b[] indices;\n                                // indexed by [readpart]\n    bam1_t *b[4];               // 3 readparts, plus current record\n\n    for (n = 0; n < 4; n++) {\n        if (!(b[n] = bam_init1())) {\n            perror(\"[bam2fq_mainloop] Malloc error for bam record buffer.\");\n            return false;\n        }\n    }\n\n    n = 0;\n    while (true) {\n        int res = sam_read1(state->fp, state->h, b[n]);\n        if (res < -1) {\n            print_error(\"bam2fq\", \"Failed to read bam record\");\n            goto err;\n        }\n        at_eof = res < 0;\n\n        if (!at_eof && filter_it_out(b[n], state, opts))\n            continue;\n        if (!at_eof) {\n            ++n_reads;\n\n            // Handle -O option: use OQ for qual\n            uint8_t *oq;\n            if (state->use_oq && (oq = bam_aux_get(b[n],\"OQ\")) && *oq == 'Z') {\n                int i, l = strlen((char *)++oq);\n                uint8_t *qual = bam_get_qual(b[n]);\n                for (i = 0; i < l && i < b[n]->core.l_qseq; i++)\n                    qual[i] = oq[i] - '!';\n            }\n        }\n\n        if (at_eof\n            || !current_qname\n            || (strcmp(current_qname, bam_get_qname(b[n])) != 0)) {\n            // New name, so flush best examples of previous name.\n            if (current_qname)\n                if (flush_rec(state, opts, b, score, best, &n_singletons) < 0)\n                    goto err;\n\n            current_qname = bam_get_qname(b[n]);\n            score[0] = score[1] = score[2] = 0;\n\n            if (at_eof) { break; }\n        }\n\n        // Prefer a copy of the read that has base qualities\n        int b_score = bam_get_qual(b[n])[0] != 0xff? 2 : 1;\n        readpart rp = which_readpart(b[n]);\n        if (score[rp] < b_score) {\n            score[rp] = b_score;\n            // Record b[n] slot for best copy of readpair and find a new\n            // slot for next bam read\n            best[rp] = n;\n            int used_slot[4] = {0}, i;\n            for (i = 0; i < 3; i++)\n                if (best[i] >= 0)\n                    used_slot[best[i]] = 1;\n            for (i = 0; i < 4 && used_slot[i]; i++)\n                ;\n            n = i;\n        }\n    }\n\n    valid = true;\n err:\n    if (!valid)\n        print_error_errno(\"bam2fq\", \"Error writing to FASTx files.\");\n\n    for (n = 0; n < 4; n++)\n        bam_destroy1(b[n]);\n\n    fprintf(stderr, \"[M::%s] discarded %\" PRId64 \" singletons\\n\",\n            __func__, n_singletons);\n    fprintf(stderr, \"[M::%s] processed %\" PRId64 \" reads\\n\",\n            __func__, n_reads);\n\n    return valid;\n}\n\nint main_bam2fq(int argc, char *argv[])\n{\n    int status = EXIT_FAILURE;\n    bam2fq_opts_t* opts = NULL;\n    bam2fq_state_t* state = NULL;\n\n    bool valid = parse_opts(argc, argv, &opts);\n    if (!valid || opts == NULL) return valid ? EXIT_SUCCESS : EXIT_FAILURE;\n\n    if (!init_state(opts, &state)) goto err;\n\n    if (!bam2fq_mainloop(state,opts)) goto err;\n\n    if (!destroy_state(opts, state, &status)) goto err;\n\n    status = EXIT_SUCCESS;\n err:\n    sam_global_args_free(&opts->ga);\n    free_opts(opts);\n\n    return status;\n}\n"
        },
        {
          "name": "bam_flags.c",
          "type": "blob",
          "size": 3.1806640625,
          "content": "/*  bam_flags.c -- flags subcommand.\n\n    Copyright (C) 2013-2014, 2021 Genome Research Ltd.\n\n    Author: Petr Danecek <pd3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <htslib/sam.h>\n#include \"samtools.h\"\n\nstatic void usage(FILE *fp)\n{\n    static const struct { int bit; const char *desc; } *fl, flags[] = {\n        { BAM_FPAIRED, \"paired-end / multiple-segment sequencing technology\" },\n        { BAM_FPROPER_PAIR, \"each segment properly aligned according to aligner\" },\n        { BAM_FUNMAP, \"segment unmapped\" },\n        { BAM_FMUNMAP, \"next segment in the template unmapped\" },\n        { BAM_FREVERSE, \"SEQ is reverse complemented\" },\n        { BAM_FMREVERSE, \"SEQ of next segment in template is rev.complemented\" },\n        { BAM_FREAD1, \"the first segment in the template\" },\n        { BAM_FREAD2, \"the last segment in the template\" },\n        { BAM_FSECONDARY, \"secondary alignment\" },\n        { BAM_FQCFAIL, \"not passing quality controls or other filters\" },\n        { BAM_FDUP, \"PCR or optical duplicate\" },\n        { BAM_FSUPPLEMENTARY, \"supplementary alignment\" },\n        { 0, NULL }\n    };\n\n    fprintf(fp,\n\"About: Convert between textual and numeric flag representation\\n\"\n\"Usage: samtools flags FLAGS...\\n\"\n\"\\n\"\n\"Each FLAGS argument is either an INT (in decimal/hexadecimal/octal) representing\\n\"\n\"a combination of the following numeric flag values, or a comma-separated string\\n\"\n\"NAME,...,NAME representing a combination of the following flag names:\\n\"\n\"\\n\");\n    for (fl = flags; fl->desc; fl++) {\n        char *name = bam_flag2str(fl->bit);\n        fprintf(fp, \"%#6x %5d  %-15s%s\\n\", fl->bit, fl->bit, name, fl->desc);\n        free(name);\n    }\n}\n\n\nint main_flags(int argc, char *argv[])\n{\n    if ( argc < 2 ) { usage(stdout); return 0; }\n\n    int i;\n    for (i = 1; i < argc; i++)\n    {\n        int mask = bam_str2flag(argv[i]);\n        if ( mask<0 ) { print_error(\"flags\", \"Could not parse \\\"%s\\\"\", argv[i]); usage(stderr); return 1; }\n        char *str = bam_flag2str(mask);\n        printf(\"0x%x\\t%d\\t%s\\n\", mask, mask, str);\n        free(str);\n    }\n    return 0;\n}\n\n"
        },
        {
          "name": "bam_import.c",
          "type": "blob",
          "size": 17.0341796875,
          "content": "/* bam_import -- Import of FASTQ files.\n *\n *   samtools import -1 a_1.fq -2 a_2.fq --i1 a_i1.fq --i2 a_i2.fq\n *   samtools import a_1.fq a_2.fq\n *   samtools import a_interleaved.fq\n *\n * Copyright (C) 2020-2021, 2023-2024 Genome Research Ltd.\n *\n * Author: James Bonfield <jkb@sanger.ac.uk>\n */\n\n/*\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n*/\n\n// TODO: Store other non-aux comments; in new sam tag?\n\n#include <config.h>\n#include <ctype.h>\n\n#include \"htslib/sam.h\"\n#include \"htslib/thread_pool.h\"\n\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\nstatic int usage(FILE *fp, int exit_status) {\n    fprintf(fp, \"Usage: samtools import [options] [file.fastq ...]\\n\");\n    fprintf(fp, \"\\n\");\n    fprintf(fp, \"Options:\\n\");\n    fprintf(fp, \"  -s FILE      Read paired-ended data from single FILE\\n\");\n    fprintf(fp, \"  -0 FILE      Read single-ended data from FILE\\n\");\n    fprintf(fp, \"  -1 FILE      Read-1 from FILE\\n\");\n    fprintf(fp, \"  -2 FILE      Read-2 from FILE\\n\");\n    fprintf(fp, \"  --i1 FILE    Index-1 from FILE\\n\");\n    fprintf(fp, \"  --i2 FILE    Index-2 from FILE\\n\");\n    fprintf(fp, \"  -i           Parse CASAVA identifier\\n\");\n    fprintf(fp, \"  --barcode-tag TAG\\n\");\n    fprintf(fp, \"               Tag to use with barcode sequences [BC]\\n\");\n    fprintf(fp, \"  --quality-tag TAG\\n\");\n    fprintf(fp, \"               Tag to use with barcode qualities [QT]\\n\");\n    fprintf(fp, \"  -N, --name2  Use 2nd field as read name (SRA format)\\n\");\n    fprintf(fp, \"  -r STRING    Build up a complete @RG line\\n\");\n    fprintf(fp, \"  -R STRING    Add a simple RG line of \\\"@RG\\\\tID:STRING\\\"\\n\");\n    fprintf(fp, \"  -T TAGLIST   Parse tags in SAM format; list of '*' for all\\n\");\n    fprintf(fp, \"  -o FILE      Output to FILE instead of stdout\\n\");\n    fprintf(fp, \"  -u           Uncompressed output\\n\");\n    fprintf(fp, \"  --order TAG  Store Nth record count in TAG\\n\");\n    fprintf(fp, \"\\n\");\n    fprintf(fp, \"      --no-PG  Do not add a PG line\\n\");\n    sam_global_opt_help(fp, \"-.O.-@--\");\n\n    fprintf(fp, \"\\nA single fastq file will be interpreted as -s, -0 or -1 depending on\\n\");\n    fprintf(fp, \"file contents, and a pair of fastq files as \\\"-1 FILE1 -2 FILE2\\\".\\n\");\n\n    return exit_status;\n}\n\n// Order matters here as we want to read index elements before main\n// sequences so on reading the seqs we can emit a fully annotated record.\nenum fileno {\n    FQ_I1, FQ_I2, // index seqs for R1 and R2\n    FQ_R0,        // single file and unpaired data (singled-ended tech).\n    FQ_R1, FQ_R2, // separate read1 and read2 files\n    FQ_SINGLE,    // single file, but with read1 and/or read2 present.\n    FQ_END\n};\n\ntypedef struct {\n    sam_global_args ga;\n    int no_pg;\n    char *fn[FQ_END], *fn_out;\n    int idx_both;      // add index to READ2 too, not just READ1\n    int casava;\n    char *barcode_seq;\n    char *barcode_qual;\n    char *aux;\n    char *rg;\n    char *rg_line;\n    char *order;\n    int order_str;\n    int compress_level;\n    htsThreadPool p;\n    int name2;\n} opts_t;\n\n// Append a sequence and quality string from a BAM record to a BC:Z and\n// QT:Z style aux tag string.\nstatic int append_index(kstring_t *s, kstring_t *q, bam1_t *b) {\n    char *sp, *qp;\n    if (ks_resize(s, s->l + b->core.l_qseq+1 +1) < 0)\n        return -1;\n    if (ks_resize(q, q->l + b->core.l_qseq+1 +1) < 0)\n        return -1;\n\n    sp = s->s + s->l - (s->l > 0);\n    qp = q->s + q->l - (q->l > 0);\n\n    if (s->l)\n        *sp++ = '-';\n\n    if (q->l)\n        *qp++ = ' ';\n\n    int i;\n    uint8_t *seq = bam_get_seq(b);\n    uint8_t *qual = bam_get_qual(b);\n    for (i = 0; i < b->core.l_qseq; i++) {\n        *sp++ = seq_nt16_str[bam_seqi(seq, i)];\n        *qp++ = qual[i] + '!';\n    }\n    *sp++ = 0;\n    *qp++ = 0;\n\n    s->l = sp - s->s;\n    q->l = qp - q->s;\n\n    return 0;\n}\n\nstatic int import_fastq(int argc, char **argv, opts_t *opts) {\n    int i, n, ret = 0;\n    samFile *fp_in[FQ_END] = {NULL};\n    bam1_t *b = bam_init1();\n    int ids[FQ_END];\n    samFile *fp_out = NULL;\n    sam_hdr_t *hdr_out = NULL;\n    kstring_t index_str = {0,0};\n    kstring_t read_str = {0,0};\n    char *rg = opts->rg;\n    kstring_t rg_line = {0,0};\n    uint64_t read_num = 0;\n    kstring_t idx_seq  = {0};\n    kstring_t idx_qual = {0};\n\n    // Any additional arguments are assumed to be r1 r2, as a\n    // short cut. We support reading index tags out of those too (eg\n    // Illumina CASAVA format), but if we do that we lack the barcode\n    // quality string.\n    //\n    // We also consider a read name ending in /1 or /2 to be a single\n    // file containing interleaved fastq records for both ends.\n    // These will be labeled as fn[FQ_R1] but adjusted during reading.\n    if (argc == 1)\n        opts->fn[FQ_SINGLE] = argv[0];\n    else\n        for (i = 0; i < 2; i++)\n            if (argc > i)\n                opts->fn[FQ_R1+i] = argv[i];\n\n    // Open all files\n    for (i = n = 0; i < FQ_END; i++) {\n        if (!opts->fn[i])\n            continue;\n        fp_in[i] = sam_open_format(opts->fn[i], \"r\", &opts->ga.in);\n        if (!fp_in[i]) {\n            perror(opts->fn[i]);\n            ret = -1;\n            goto err;\n        }\n        if (opts->p.pool)\n            hts_set_thread_pool(fp_in[i], &opts->p);\n        ids[n++] = i;\n\n        if (opts->name2)\n            hts_set_opt(fp_in[i], FASTQ_OPT_NAME2, 1);\n        if (opts->casava)\n            hts_set_opt(fp_in[i], FASTQ_OPT_CASAVA, 1);\n        if (opts->barcode_seq) // for auto-CASAVA parsing\n            hts_set_opt(fp_in[i], FASTQ_OPT_BARCODE, opts->barcode_seq);\n        if (opts->aux)\n            hts_set_opt(fp_in[i], FASTQ_OPT_AUX,\n                        *opts->aux == '*' || *opts->aux == '\\0'\n                        ? NULL : opts->aux);\n\n        switch (i) {\n        case FQ_I1:\n            kputs(\"--i1 I1.fastq \", &read_str);\n            kputs(\"i*\", &index_str);\n            break;\n        case FQ_I2:\n            kputs(\"--i2 I2.fastq \", &read_str);\n            kputs(\"i*\", &index_str);\n            break;\n\n        case FQ_R0:\n            kputs(\"-0 unpaired.fastq \", &read_str);\n            break;\n\n        case FQ_R1:\n            kputs(\"-1 R1.fastq \", &read_str);\n            break;\n\n        case FQ_R2:\n            kputs(\"-2 R2.fastq \", &read_str);\n            break;\n\n        case FQ_SINGLE:\n            kputs(\"-N -o paired.fastq \", &read_str);\n            break;\n\n        default:\n            ks_clear(&read_str); // not reversible\n            kputs(\"\", &read_str);\n        }\n    }\n    if (n == 0) {\n        bam_destroy1(b);\n        return usage(stdout, EXIT_SUCCESS);\n    }\n\n    char out_mode[10] = {'w', 0, 0};\n    if (opts->compress_level != -1)\n        out_mode[1] = '0' + opts->compress_level;\n    sam_open_mode(out_mode+strlen(out_mode), opts->fn_out, NULL);\n    fp_out = sam_open_format(opts->fn_out, out_mode, &opts->ga.out);\n    if (!fp_out) {\n        perror(opts->fn_out);\n        goto err;\n    }\n    autoflush_if_stdout(fp_out, opts->fn_out);\n    if (opts->p.pool)\n        hts_set_thread_pool(fp_out, &opts->p);\n\n    // Create header\n    if (ks_len(&read_str)) {\n        char CO[2100];\n        if (ks_len(&index_str))\n            snprintf(CO, sizeof(CO), \"@CO\\tReverse with: samtools fastq %s \"\n                    \"--index-format=\\\"%s\\\"\\n\",\n                    ks_str(&read_str), ks_str(&index_str));\n        else\n            snprintf(CO, sizeof(CO), \"@CO\\tReverse with: samtools fastq %s\\n\",\n                    ks_str(&read_str));\n\n        hdr_out = sam_hdr_parse(strlen(CO), CO);\n    } else {\n        hdr_out = sam_hdr_init();\n    }\n\n    // Add a version line with the sort order to the output header\n    if (sam_hdr_add_line(hdr_out, \"HD\", \"VN\", SAM_FORMAT_VERSION, \"SO\", \"unsorted\", \"GO\", \"query\", NULL) < 0) {\n        fprintf(stderr, \"Could not set SO and GO in the header.\\n\");\n        goto err;\n    }\n\n    if (!opts->no_pg) {\n        char *arg_list;\n        if (!(arg_list = stringify_argv(argc+1+optind, argv-1-optind))) {\n            print_error(\"view\", \"failed to create arg_list\");\n            goto err;\n        }\n        if (sam_hdr_add_pg(hdr_out, \"samtools\",\n                           \"VN\", samtools_version(),\n                           arg_list ? \"CL\" : NULL,\n                           arg_list ? arg_list : NULL,\n                           NULL)) {\n            fprintf(stderr, \"Failed to add PG line to the header\");\n            free(arg_list);\n            goto err;\n        }\n\n        free(arg_list);\n    }\n\n    // Read group\n    if (opts->rg_line) {\n        if (*opts->rg_line != '@')\n            ksprintf(&rg_line, \"@RG\\t%s\", opts->rg_line);\n        else\n            kputs(opts->rg_line, &rg_line);\n    } else if (opts->rg) {\n        ksprintf(&rg_line, \"@RG\\tID:%s\", opts->rg);\n    }\n\n    if (ks_len(&rg_line)) {\n        if (sam_hdr_add_lines(hdr_out, ks_str(&rg_line), 0) < 0)\n            goto err;\n        rg = strstr(ks_str(&rg_line), \"\\tID:\");\n        if (!rg) {\n            fprintf(stderr, \"\\\"-r RG-LINE\\\" option contained no ID field\\n\");\n            goto err;\n        }\n        rg += 4;\n\n        i = 0;\n        while (rg[i] != '\\t' && rg[i] != '\\0')\n            i++;\n        rg[i] = 0;\n    }\n\n    if ((ret = sam_hdr_write(fp_out, hdr_out)) < 0)\n        goto err;\n\n\n    // Interleave / combine from n files (ids[0..n-1]).\n    int res = 0;\n    int eof = 0;\n    do {\n        idx_seq.l = idx_qual.l = 0;\n        for (i = 0; i < n; i++) {\n            if ((res = sam_read1(fp_in[ids[i]], NULL, b)) < 0) {\n                if (res == -1) {\n                    eof++;\n                    continue;\n                } else\n                    break;\n            }\n\n            // index\n            if (ids[i] == FQ_I1 || ids[i] == FQ_I2) {\n                if (append_index(&idx_seq, &idx_qual, b) < 0) {\n                    res = -1;\n                    break;\n                }\n                continue;\n            }\n\n            // full read\n            if (idx_seq.l) {\n                if (opts->idx_both || ids[i] == FQ_SINGLE ||\n                    ids[i] == FQ_R0 || ids[i] == FQ_R1) {\n                    if (bam_aux_append(b, opts->barcode_seq, 'Z', idx_seq.l,\n                                       (uint8_t *)idx_seq.s) ||\n                        bam_aux_append(b, opts->barcode_qual, 'Z', idx_qual.l,\n                                       (uint8_t *)idx_qual.s)) {\n                        res = -1;\n                        break;\n                    }\n                }\n            }\n\n            switch(ids[i]) {\n            case FQ_R0:\n                // unpaired; no flags to declare\n                break;\n            case FQ_SINGLE:\n                // paired (but don't know if R1 or R2) or unpaired.\n                // We rely on the /1 and /2 read suffix parsing in htslib\n                // to distinguish the two cases, or CASAVA tags if\n                // explicitly enabled.\n                break;\n            case FQ_R1:\n                if ((b->core.flag & (BAM_FREAD1 | BAM_FREAD2)) == 0)\n                    b->core.flag |= BAM_FREAD1;\n                b->core.flag |= BAM_FPAIRED;\n                if (i+1 < n && ids[i+1] == FQ_R2)\n                    b->core.flag |= BAM_FMUNMAP;\n                break;\n            case FQ_R2:\n                b->core.flag |= BAM_FPAIRED | BAM_FREAD2;\n                if (i > 0 && ids[i-1] == FQ_R1)\n                    b->core.flag |= BAM_FMUNMAP;\n                break;\n            }\n\n            if (rg) {\n                if (bam_aux_append(b, \"RG\", 'Z', strlen(rg)+1,\n                                   (uint8_t *)rg) < 0) {\n                    ret = -1;\n                    goto err;\n                }\n            }\n\n            if (opts->order) {\n                if (opts->order_str) {\n                    char buf[25];\n                    snprintf(buf, sizeof(buf), \"%0*\"PRIu64,\n                             opts->order_str, read_num++);\n                    if (bam_aux_update_str(b, opts->order,\n                                           strlen(buf), buf) < 0) {\n                        ret = -1;\n                        goto err;\n                    }\n                } else {\n                    if (bam_aux_update_int(b, opts->order, read_num++) < 0) {\n                        ret = -1;\n                        goto err;\n                    }\n                    if (read_num == UINT_MAX)\n                        fprintf(stderr, \"Warning: --order tag has overflowed.\"\n                                \"  Consider using TAG:LENGTH instead\\n\");\n                }\n            }\n\n            res = sam_write1(fp_out, hdr_out, b);\n        }\n    } while (res >= 0);\n\n    if (res != -1) {\n        print_error(\"import\", \"truncated file. Aborting\");\n        ret = res;\n        goto err;\n    }\n\n    if (eof != n) {\n        print_error(\"import\", \"input files with differing number of records\");\n        ret = -1;\n        goto err;\n    }\n\n    // Close and return\n    ret = 0;\nerr:\n    bam_destroy1(b);\n    sam_hdr_destroy(hdr_out);\n    ks_free(&rg_line);\n    ks_free(&index_str);\n    ks_free(&read_str);\n    if (fp_out) {\n        release_autoflush(fp_out);\n        if (sam_close(fp_out) < 0) {\n            perror(opts->fn_out);\n            ret |= -1;\n        }\n    }\n    for (i = 0; i < FQ_END; i++) {\n        if (fp_in[i] && sam_close(fp_in[i]) < 0) {\n            perror(opts->fn[i]);\n            ret |= -1;\n        }\n    }\n    ks_free(&idx_seq);\n    ks_free(&idx_qual);\n\n    return ret;\n}\n\nint main_import(int argc, char *argv[]) {\n    int c;\n    opts_t opts = {\n        .no_pg = 0,\n        .ga = SAM_GLOBAL_ARGS_INIT,\n        .fn = {NULL},\n        .fn_out = \"-\",\n        .casava = 0,\n        .barcode_seq = \"BC\",\n        .barcode_qual = \"QT\",\n        .aux = NULL,\n        .rg = NULL,\n        .rg_line = NULL,\n        .order = NULL,\n        .order_str = 0,\n        .compress_level = -1,\n        .name2 = 0,\n    };\n    kstring_t rg = {0};\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', 0, '-', '@'),\n        {\"no-PG\", no_argument, NULL, 9},\n        {\"i1\", required_argument, NULL, 1},\n        {\"i2\", required_argument, NULL, 2},\n        {\"r1\", required_argument, NULL, '1'},\n        {\"r2\", required_argument, NULL, '2'},\n        {\"rg\", required_argument, NULL, 'R'},\n        {\"rg-line\", required_argument, NULL, 'r'},\n        {\"order\", required_argument, NULL, 3},\n        {\"barcode-tag\", required_argument, NULL, 4},\n        {\"quality-tag\", required_argument, NULL, 5},\n        {\"name2\", no_argument, NULL, 'N'},\n        { NULL, 0, NULL, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \"1:2:s:0:bhiT:r:R:o:O:u@:N\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'b': opts.idx_both = 1; break;\n        case '0': opts.fn[FQ_R0] = optarg; break;\n        case '1': opts.fn[FQ_R1] = optarg; break;\n        case '2': opts.fn[FQ_R2] = optarg; break;\n        case  1:  opts.fn[FQ_I1] = optarg; break;\n        case  2:  opts.fn[FQ_I2] = optarg; break;\n        case 's': opts.fn[FQ_SINGLE] = optarg; break;\n        case 'o': opts.fn_out = optarg; break;\n        case 'i': opts.casava = 1; break;\n        case  4:  opts.barcode_seq = optarg; break;\n        case  5:  opts.barcode_qual = optarg; break;\n        case 'T': opts.aux = optarg; break;\n        case 'u': opts.compress_level = 0; break;\n        case 'R': opts.rg = optarg; break;\n        case 'r':\n            if (*optarg != '@' && ks_len(&rg) == 0)\n                kputs(\"@RG\", &rg);\n            if (ks_len(&rg))\n                kputc_('\\t', &rg);\n            kputs(optarg, &rg);\n            opts.rg_line = rg.s;\n            break;\n\n        case 'N': opts.name2 = 1; break;\n\n        case 9: opts.no_pg = 1; break;\n        case 3:\n            opts.order = optarg;\n            if (strlen(optarg) > 3 && optarg[2] == ':')\n                opts.order_str = atoi(optarg+3);\n            break;\n\n        case 'h': return usage(stdout, EXIT_SUCCESS);\n        case '?': return usage(stderr, EXIT_FAILURE);\n\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &opts.ga) != 0)\n                return usage(stderr, EXIT_FAILURE);\n            break;\n        }\n    }\n\n    if (opts.ga.nthreads > 0) {\n        if (!(opts.p.pool = hts_tpool_init(opts.ga.nthreads))) {\n            fprintf(stderr, \"Failed to create thread pool\\n\");\n            if (rg.s)\n                free(rg.s);\n            return -1;;\n        }\n    }\n\n    int ret = import_fastq(argc-optind, argv+optind, &opts) ? 1 : 0;\n\n    if (rg.s)\n        free(rg.s);\n\n    if (opts.p.pool)\n        hts_tpool_destroy(opts.p.pool);\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_index.c",
          "type": "blob",
          "size": 9.48046875,
          "content": "/*  bam_index.c -- index and idxstats subcommands.\n\n    Copyright (C) 2008-2011, 2013-2016, 2018, 2019, 2023-2024  Genome Research Ltd.\n    Portions copyright (C) 2010 Broad Institute.\n    Portions copyright (C) 2013 Peter Cock, The James Hutton Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <htslib/hts.h>\n#include <htslib/sam.h>\n#include <htslib/hfile.h>\n#include <htslib/khash.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <unistd.h>\n#include <getopt.h>\n\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\n#define BAM_LIDX_SHIFT    14\n\nstatic void index_usage(FILE *fp)\n{\n    fprintf(fp,\n\"Usage: samtools index -M [-bc] [-m INT] <in1.bam> <in2.bam>...\\n\"\n\"   or: samtools index [-bc] [-m INT] <in.bam> [out.index]\\n\"\n\"Options:\\n\"\n\"  -b, --bai            Generate BAI-format index for BAM files [default]\\n\"\n\"  -c, --csi            Generate CSI-format index for BAM files\\n\"\n\"  -m, --min-shift INT  Set minimum interval size for CSI indices to 2^INT [%d]\\n\"\n\"  -M                   Interpret all filename arguments as files to be indexed\\n\"\n\"  -o, --output FILE    Write index to FILE [alternative to <out.index> in args]\\n\"\n\"  -@, --threads INT    Sets the number of threads [none]\\n\", BAM_LIDX_SHIFT);\n}\n\n// Returns 1 if the file does not exist or can be positively\n// identified as an index file.\nstatic int nonexistent_or_index(const char *fn)\n{\n    int ret1, ret2;\n    htsFormat fmt;\n    hFILE *fp = hopen(fn, \"r\");\n    if (fp == NULL) return 1;\n\n    ret1 = hts_detect_format2(fp, fn, &fmt);\n    ret2 = hclose(fp);\n    if (ret1 < 0 || ret2 < 0) return 0;\n\n    return fmt.category == index_file;\n}\n\nint bam_index(int argc, char *argv[])\n{\n    int csi = 0;\n    int min_shift = BAM_LIDX_SHIFT;\n    int multiple = 0;\n    int n_threads = 0;\n    int n_files, c, i, ret;\n    const char *fn_idx = NULL;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', '-', '-', '-', '-', '@'),\n        {\"output\",    required_argument, NULL, 'o'},\n        {\"bai\",       no_argument,       NULL, 'b'},\n        {\"csi\",       no_argument,       NULL, 'c'},\n        {\"min-shift\", required_argument, NULL, 'm'},\n        { NULL, 0, NULL, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \"bcm:Mo:@:\", lopts, NULL)) >= 0)\n        switch (c) {\n        case 'b': csi = 0; break;\n        case 'c': csi = 1; break;\n        case 'm': csi = 1; min_shift = atoi(optarg); break;\n        case 'M': multiple = 1; break;\n        case 'o': fn_idx = optarg; break;\n        case '@': n_threads = atoi(optarg); break;\n        default:\n            index_usage(stderr);\n            return 1;\n        }\n\n    n_files = argc - optind;\n\n    if (n_files == 0) {\n        index_usage(stdout);\n        return 0;\n    }\n\n    // Handle legacy synopsis\n    if (n_files == 2 && !fn_idx && nonexistent_or_index(argv[optind+1])) {\n        n_files = 1;\n        fn_idx = argv[optind+1];\n    }\n\n    if (n_files > 1 && !multiple) {\n        print_error(\"index\", \"use -M to enable indexing more than one alignment file\");\n        return EXIT_FAILURE;\n    }\n\n    if (fn_idx && n_files > 1) {\n        // TODO In future we may allow %* placeholders or similar\n        print_error(\"index\", \"can't use -o with multiple input alignment files\");\n        return EXIT_FAILURE;\n    }\n\n    for (i = optind; i < optind + n_files; i++) {\n        ret = sam_index_build3(argv[i], fn_idx, csi? min_shift : 0, n_threads);\n        if (ret < 0) {\n            if (ret == -2)\n                print_error_errno(\"index\", \"failed to open \\\"%s\\\"\", argv[i]);\n            else if (ret == -3)\n                print_error(\"index\", \"\\\"%s\\\" is in a format that cannot be usefully indexed\", argv[i]);\n            else if (ret == -4 && fn_idx)\n                print_error(\"index\", \"failed to create or write index \\\"%s\\\"\", fn_idx);\n            else if (ret == -4)\n                print_error(\"index\", \"failed to create or write index\");\n            else\n                print_error_errno(\"index\", \"failed to create index for \\\"%s\\\"\", argv[i]);\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/*\n * Cram indices do not contain mapped/unmapped record counts, so we have to\n * decode each record and count.  However we can speed this up as much as\n * possible by using the required fields parameter.\n *\n * This prints the stats to stdout in the same manner than the BAM function\n * does.\n *\n * Returns 0 on success,\n *        -1 on failure.\n */\nint slow_idxstats(samFile *fp, sam_hdr_t *header) {\n    int ret, last_tid = -2;\n    bam1_t *b = bam_init1();\n\n    if (hts_set_opt(fp, CRAM_OPT_REQUIRED_FIELDS, SAM_RNAME | SAM_FLAG))\n        return -1;\n\n    uint64_t (*count0)[2] = calloc(sam_hdr_nref(header)+1, sizeof(*count0));\n    uint64_t (*counts)[2] = count0+1;\n    if (!count0)\n        return -1;\n\n    while ((ret = sam_read1(fp, header, b)) >= 0) {\n        if (b->core.tid >= sam_hdr_nref(header) || b->core.tid < -1) {\n            free(count0);\n            return -1;\n        }\n\n        if (b->core.tid != last_tid) {\n            if (last_tid >= -1) {\n                if (counts[b->core.tid][0] + counts[b->core.tid][1]) {\n                    print_error(\"idxstats\", \"file is not position sorted\");\n                    free(count0);\n                    return -1;\n                }\n            }\n            last_tid = b->core.tid;\n        }\n\n        counts[b->core.tid][(b->core.flag & BAM_FUNMAP) ? 1 : 0]++;\n    }\n\n    if (ret == -1) {\n        int i;\n        for (i = 0; i < sam_hdr_nref(header); i++) {\n            printf(\"%s\\t%\"PRId64\"\\t%\"PRIu64\"\\t%\"PRIu64\"\\n\",\n                   sam_hdr_tid2name(header, i),\n                   (int64_t) sam_hdr_tid2len(header, i),\n                   counts[i][0], counts[i][1]);\n        }\n        printf(\"*\\t0\\t%\"PRIu64\"\\t%\"PRIu64\"\\n\", counts[-1][0], counts[-1][1]);\n    }\n\n    free(count0);\n\n    bam_destroy1(b);\n\n    return (ret == -1) ? 0 : -1;\n}\n\nstatic void usage_exit(FILE *fp, int exit_status)\n{\n    fprintf(fp, \"Usage: samtools idxstats [options] <in.bam>\\n\"\n                \"  -X           Include customized index file\\n\");\n    sam_global_opt_help(fp, \"-.---@-.\");\n    exit(exit_status);\n}\n\nint bam_idxstats(int argc, char *argv[])\n{\n    hts_idx_t* idx;\n    sam_hdr_t* header;\n    samFile* fp;\n    int c, has_index_file = 0, file_names = 1;\n    char *index_name = NULL;\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', '-', '@'),\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"@:X\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'X': has_index_file=1; break;\n            default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                /* else fall-through */\n            case '?':\n                usage_exit(stderr, EXIT_FAILURE);\n        }\n    }\n\n    if (has_index_file) {\n        file_names = 2;\n        index_name = argv[optind + 1];\n    }\n\n    if (argc != optind + file_names) {\n        if (argc == optind) usage_exit(stdout, EXIT_SUCCESS);\n        else usage_exit(stderr, EXIT_FAILURE);\n    }\n\n    fp = sam_open_format(argv[optind], \"r\", &ga.in);\n    if (fp == NULL) {\n        print_error_errno(\"idxstats\", \"failed to open \\\"%s\\\"\", argv[optind]);\n        return 1;\n    }\n    header = sam_hdr_read(fp);\n    if (header == NULL) {\n        print_error(\"idxstats\", \"failed to read header for \\\"%s\\\"\", argv[optind]);\n        return 1;\n    }\n\n    if (hts_get_format(fp)->format != bam) {\n    slow_method:\n        if (ga.nthreads)\n            hts_set_threads(fp, ga.nthreads);\n\n        if (slow_idxstats(fp, header) < 0) {\n            print_error(\"idxstats\", \"failed to process \\\"%s\\\"\", argv[optind]);\n            return 1;\n        }\n    } else {\n        idx = sam_index_load2(fp, argv[optind], index_name);\n        if (idx == NULL) {\n            print_error(\"idxstats\", \"fail to load index for \\\"%s\\\", \"\n                        \"reverting to slow method\", argv[optind]);\n            goto slow_method;\n        }\n\n        int i;\n        for (i = 0; i < sam_hdr_nref(header); ++i) {\n            // Print out contig name and length\n            printf(\"%s\\t%\"PRId64, sam_hdr_tid2name(header, i), (int64_t) sam_hdr_tid2len(header, i));\n            // Now fetch info about it from the meta bin\n            uint64_t u, v;\n            hts_idx_get_stat(idx, i, &u, &v);\n            printf(\"\\t%\" PRIu64 \"\\t%\" PRIu64 \"\\n\", u, v);\n        }\n        // Dump information about unmapped reads\n        printf(\"*\\t0\\t0\\t%\" PRIu64 \"\\n\", hts_idx_get_n_no_coor(idx));\n        hts_idx_destroy(idx);\n    }\n\n    sam_hdr_destroy(header);\n    sam_close(fp);\n    return 0;\n}\n"
        },
        {
          "name": "bam_lpileup.c",
          "type": "blob",
          "size": 6.7861328125,
          "content": "/*  bam_lpileup.c -- lplbuf routines.\n\n    Copyright (C) 2008, 2009, 2013 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"bam_plbuf.h\"\n#include \"bam_lpileup.h\"\n#include \"splaysort.h\"\n\n#define TV_GAP 2\n\ntypedef struct __freenode_t {\n    uint32_t level:28, cnt:4;\n    struct __freenode_t *next;\n} freenode_t, *freenode_p;\n\n#define freenode_lt(a,b) ((a)->cnt < (b)->cnt || ((a)->cnt == (b)->cnt && (a)->level < (b)->level))\nSPLAYSORT_INIT(node, freenode_p, freenode_lt)\n\n/* Memory pool, similar to the one in bam_pileup.c */\ntypedef struct {\n    int cnt, n, max;\n    freenode_t **buf;\n} mempool_t;\n\nstatic mempool_t *mp_init(void)\n{\n    return (mempool_t*)calloc(1, sizeof(mempool_t));\n}\nstatic void mp_destroy(mempool_t *mp)\n{\n    int k;\n    for (k = 0; k < mp->n; ++k) free(mp->buf[k]);\n    free(mp->buf); free(mp);\n}\nstatic inline freenode_t *mp_alloc(mempool_t *mp)\n{\n    ++mp->cnt;\n    if (mp->n == 0) return (freenode_t*)calloc(1, sizeof(freenode_t));\n    else return mp->buf[--mp->n];\n}\nstatic inline void mp_free(mempool_t *mp, freenode_t *p)\n{\n    --mp->cnt; p->next = 0; p->cnt = TV_GAP;\n    if (mp->n == mp->max) {\n        mp->max = mp->max? mp->max<<1 : 256;\n        mp->buf = (freenode_t**)realloc(mp->buf, sizeof(freenode_t*) * mp->max);\n    }\n    mp->buf[mp->n++] = p;\n}\n\n/* core part */\nstruct __bam_lplbuf_t {\n    int max, n_cur, n_pre;\n    int max_level, *cur_level, *pre_level;\n    mempool_t *mp;\n    freenode_t **aux, *head, *tail;\n    int n_nodes, m_aux;\n    bam_pileup_f func;\n    void *user_data;\n    bam_plbuf_t *plbuf;\n};\n\nvoid bam_lplbuf_reset(bam_lplbuf_t *buf)\n{\n    freenode_t *p, *q;\n    bam_plbuf_reset(buf->plbuf);\n    for (p = buf->head; p->next;) {\n        q = p->next;\n        mp_free(buf->mp, p);\n        p = q;\n    }\n    buf->head = buf->tail;\n    buf->max_level = 0;\n    buf->n_cur = buf->n_pre = 0;\n    buf->n_nodes = 0;\n}\n\nstatic int tview_func(uint32_t tid, hts_pos_t pos, int n, const bam_pileup1_t *pl, void *data)\n{\n    bam_lplbuf_t *tv = (bam_lplbuf_t*)data;\n    freenode_t *p;\n    int i, l, max_level;\n    // allocate memory if necessary\n    if (tv->max < n) { // enlarge\n        tv->max = n;\n        kroundup32(tv->max);\n        tv->cur_level = (int*)realloc(tv->cur_level, sizeof(int) * tv->max);\n        tv->pre_level = (int*)realloc(tv->pre_level, sizeof(int) * tv->max);\n    }\n    tv->n_cur = n;\n    // update cnt\n    for (p = tv->head; p->next; p = p->next)\n        if (p->cnt > 0) --p->cnt;\n    // calculate cur_level[]\n    max_level = 0;\n    for (i = l = 0; i < n; ++i) {\n        const bam_pileup1_t *p = pl + i;\n        if (p->is_head) {\n            if (tv->head->next && tv->head->cnt == 0) { // then take a free slot\n                freenode_t *p = tv->head->next;\n                tv->cur_level[i] = tv->head->level;\n                mp_free(tv->mp, tv->head);\n                tv->head = p;\n                --tv->n_nodes;\n            } else tv->cur_level[i] = ++tv->max_level;\n        } else {\n            tv->cur_level[i] = tv->pre_level[l++];\n            if (p->is_tail) { // then return a free slot\n                tv->tail->level = tv->cur_level[i];\n                tv->tail->next = mp_alloc(tv->mp);\n                tv->tail = tv->tail->next;\n                ++tv->n_nodes;\n            }\n        }\n        if (tv->cur_level[i] > max_level) max_level = tv->cur_level[i];\n        ((bam_pileup1_t*)p)->level = tv->cur_level[i];\n    }\n    assert(l == tv->n_pre);\n    tv->func(tid, pos, n, pl, tv->user_data);\n    // sort the linked list\n    if (tv->n_nodes) {\n        freenode_t *q;\n        if (tv->n_nodes + 1 > tv->m_aux) { // enlarge\n            tv->m_aux = tv->n_nodes + 1;\n            kroundup32(tv->m_aux);\n            tv->aux = (freenode_t**)realloc(tv->aux, sizeof(freenode_t*) * tv->m_aux);\n        }\n        for (p = tv->head, i = l = 0; p->next;) {\n            if (p->level > max_level) { // then discard this entry\n                q = p->next;\n                mp_free(tv->mp, p);\n                p = q;\n            } else {\n                tv->aux[i++] = p;\n                p = p->next;\n            }\n        }\n        tv->aux[i] = tv->tail; // add a proper tail for the loop below\n        tv->n_nodes = i;\n        if (tv->n_nodes) {\n            splaysort(node, tv->n_nodes, tv->aux);\n            for (i = 0; i < tv->n_nodes; ++i) tv->aux[i]->next = tv->aux[i+1];\n            tv->head = tv->aux[0];\n        } else tv->head = tv->tail;\n    }\n    // clean up\n    tv->max_level = max_level;\n    memcpy(tv->pre_level, tv->cur_level, tv->n_cur * 4);\n    // squeeze out terminated levels\n    for (i = l = 0; i < n; ++i) {\n        const bam_pileup1_t *p = pl + i;\n        if (!p->is_tail)\n            tv->pre_level[l++] = tv->pre_level[i];\n    }\n    tv->n_pre = l;\n/*\n    fprintf(stderr, \"%d\\t\", pos+1);\n    for (i = 0; i < n; ++i) {\n        const bam_pileup1_t *p = pl + i;\n        if (p->is_head) fprintf(stderr, \"^\");\n        if (p->is_tail) fprintf(stderr, \"$\");\n        fprintf(stderr, \"%d,\", p->level);\n    }\n    fprintf(stderr, \"\\n\");\n*/\n    return 0;\n}\n\nbam_lplbuf_t *bam_lplbuf_init(bam_pileup_f func, void *data)\n{\n    bam_lplbuf_t *tv;\n    tv = (bam_lplbuf_t*)calloc(1, sizeof(bam_lplbuf_t));\n    tv->mp = mp_init();\n    tv->head = tv->tail = mp_alloc(tv->mp);\n    tv->func = func;\n    tv->user_data = data;\n    tv->plbuf = bam_plbuf_init(tview_func, tv);\n    return (bam_lplbuf_t*)tv;\n}\n\nvoid bam_lplbuf_destroy(bam_lplbuf_t *tv)\n{\n    freenode_t *p, *q;\n    free(tv->cur_level); free(tv->pre_level);\n    bam_plbuf_destroy(tv->plbuf);\n    free(tv->aux);\n    for (p = tv->head; p->next;) {\n        q = p->next;\n        mp_free(tv->mp, p); p = q;\n    }\n    mp_free(tv->mp, p);\n    assert(tv->mp->cnt == 0);\n    mp_destroy(tv->mp);\n    free(tv);\n}\n\nint bam_lplbuf_push(const bam1_t *b, bam_lplbuf_t *tv)\n{\n    return bam_plbuf_push(b, tv->plbuf);\n}\n"
        },
        {
          "name": "bam_lpileup.h",
          "type": "blob",
          "size": 2.0107421875,
          "content": "/*  bam_lpileup.h -- lplbuf routines (declarations copied from bam.h).\n\n    Copyright (C) 2008, 2013 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BAM_LPILEUP_H\n#define BAM_LPILEUP_H\n\n\n#include <htslib/sam.h>\n\nstruct __bam_lplbuf_t;\ntypedef struct __bam_lplbuf_t bam_lplbuf_t;\n\n#ifndef BAM_PILEUP_F_DEFINED\n#define BAM_PILEUP_F_DEFINED\ntypedef int (*bam_pileup_f)(uint32_t tid, hts_pos_t pos, int n, const bam_pileup1_t *pl, void *data);\n#endif //BAM_PILEUP_F_DEFINED\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    void bam_lplbuf_reset(bam_lplbuf_t *buf);\n\n    /*! @abstract  bam_plbuf_init() equivalent with level calculated. */\n    bam_lplbuf_t *bam_lplbuf_init(bam_pileup_f func, void *data);\n\n    /*! @abstract  bam_plbuf_destroy() equivalent with level calculated. */\n    void bam_lplbuf_destroy(bam_lplbuf_t *tv);\n\n    /*! @abstract  bam_plbuf_push() equivalent with level calculated. */\n    int bam_lplbuf_push(const bam1_t *b, bam_lplbuf_t *buf);\n#ifdef __cplusplus\n}\n#endif\n\n#endif // BAM_LPILEUP_H\n"
        },
        {
          "name": "bam_markdup.c",
          "type": "blob",
          "size": 82.9990234375,
          "content": "/*  bam_markdup.c -- Mark duplicates from a coord sorted file that has gone\n                     through fixmates with the mate scoring option on.\n\n    Copyright (C) 2017-2023 Genome Research Ltd.\n\n    Author: Andrew Whitwham <aw7@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE\n\nEstimate library size derived from Picard DuplicationMetrics.java\nCopyright (c) 2009,2018 The Broad Institute.  MIT license.\n*/\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <math.h>\n#include <regex.h>\n#include \"htslib/thread_pool.h\"\n#include \"htslib/sam.h\"\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n#include \"htslib/khash.h\"\n#include \"htslib/klist.h\"\n#include \"htslib/kstring.h\"\n#include \"tmp_file.h\"\n#include \"bam.h\"\n\n\ntypedef struct {\n    samFile *in;\n    samFile *out;\n    char *prefix;\n    int remove_dups;\n    int32_t max_length;\n    int do_stats;\n    int supp;\n    int tag;\n    int opt_dist;\n    int no_pg;\n    int clear;\n    int mode;\n    int write_index;\n    int include_fails;\n    int check_chain;\n    char *stats_file;\n    char *arg_list;\n    char *out_fn;\n    regex_t *rgx;\n    int rgx_x;\n    int rgx_y;\n    int rgx_t;\n    char *barcode;\n    regex_t *bc_rgx;\n    int read_groups;\n    int json;\n    int dc;\n} md_param_t;\n\ntypedef struct {\n    hts_pos_t this_coord;\n    hts_pos_t other_coord;\n    int32_t this_ref;\n    int32_t other_ref;\n    int32_t barcode;\n    int32_t read_group;\n    int8_t single;\n    int8_t leftmost;\n    int8_t orientation;\n} key_data_t;\n\ntypedef struct read_queue_s {\n    key_data_t pair_key;\n    key_data_t single_key;\n    bam1_t *b;\n    struct read_queue_s *duplicate;\n    struct read_queue_s *original;\n    int dc;\n    hts_pos_t pos;\n    int dup_checked;\n    int read_group;\n} read_queue_t;\n\ntypedef struct {\n    read_queue_t *p;\n} in_hash_t;\n\ntypedef struct {\n    char *name;\n    char type;\n    int read_group;\n} dup_map_t;\n\ntypedef struct {\n    bam1_t *b;\n    int64_t score;\n    int64_t mate_score;\n    long x;\n    long y;\n    int opt;\n    int beg;\n    int end;\n    int len;\n} check_t;\n\ntypedef struct {\n    check_t *c;\n    size_t size;\n    size_t length;\n} check_list_t;\n\ntypedef struct {\n    long reading;\n    long writing;\n    long excluded;\n    long duplicate;\n    long single;\n    long pair;\n    long single_dup;\n    long examined;\n    long optical;\n    long single_optical;\n    long np_duplicate;\n    long np_opt_duplicate;\n} stats_block_t;\n\nstatic khint32_t do_hash(unsigned char *key, khint32_t len);\n\nstatic khint_t hash_key(key_data_t key) {\n    int i = 0;\n    khint_t hash;\n\n    if (key.single) {\n        unsigned char sig[21];\n\n        memcpy(sig + i, &key.this_ref, 4);      i += 4;\n        memcpy(sig + i, &key.this_coord, 8);    i += 8;\n        memcpy(sig + i, &key.orientation, 1);   i += 1;\n        memcpy(sig + i, &key.barcode, 4);       i += 4;\n        memcpy(sig + i, &key.read_group, 4);    i += 4;\n\n        hash = do_hash(sig, i);\n    } else {\n        unsigned char sig[34];\n\n        memcpy(sig + i, &key.this_ref, 4);      i += 4;\n        memcpy(sig + i, &key.this_coord, 8);    i += 8;\n        memcpy(sig + i, &key.other_ref, 4);     i += 4;\n        memcpy(sig + i, &key.other_coord, 8);   i += 8;\n        memcpy(sig + i, &key.leftmost, 1);      i += 1;\n        memcpy(sig + i, &key.orientation, 1);   i += 1;\n        memcpy(sig + i, &key.barcode, 4);       i += 4;\n        memcpy(sig + i, &key.read_group, 4);    i += 4;\n\n        hash = do_hash(sig, i);\n    }\n\n    return hash;\n}\n\n\nstatic int key_equal(key_data_t a, key_data_t b) {\n    int match = 1;\n\n    if (a.this_coord != b.this_coord)\n        match = 0;\n    else if (a.orientation != b.orientation)\n        match = 0;\n    else if (a.this_ref != b.this_ref)\n        match = 0;\n    else if (a.single != b.single)\n        match = 0;\n    else if (a.barcode != b.barcode)\n        match = 0;\n    else if (a.read_group != b.read_group)\n        match = 0;\n\n    if (!a.single) {\n        if (a.other_coord != b.other_coord)\n            match = 0;\n        else if (a.leftmost != b.leftmost)\n            match = 0;\n        else if (a.other_ref != b.other_ref)\n            match = 0;\n    }\n\n    return match;\n}\n\n\n#define __free_queue_element(p)\n\n// Orientations (prime numbers to feed to hashing algorithm)\n#define O_FF 2\n#define O_RR 3\n#define O_FR 5\n#define O_RF 7\n\n// Left or rightmost\n#define R_LE 11\n#define R_RI 13\n\n#define BMD_WARNING_MAX 10\n\n#define MD_MIN_QUALITY 15\n\n// Duplicate finding mode\n#define MD_MODE_TEMPLATE 0\n#define MD_MODE_SEQUENCE 1\n\nKHASH_INIT(reads, key_data_t, in_hash_t, 1, hash_key, key_equal) // read map hash\nKLIST_INIT(read_queue, read_queue_t, __free_queue_element) // the reads buffer\nKHASH_MAP_INIT_STR(duplicates, dup_map_t) // map of duplicates for supplementary dup id\nKHASH_MAP_INIT_STR(read_groups, int) // read group lookup\n\n/* The Bob Jenkins one_at_a_time hash to reduce the key to a 32 bit value. */\n\nstatic khint32_t do_hash(unsigned char *key, khint32_t len) {\n    khint32_t   hash, i;\n\n    for (hash = 0, i = 0; i < len; ++i) {\n        hash += key[i];\n        hash += (hash << 10);\n        hash ^= (hash >> 6);\n    }\n\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n\n    return hash;\n}\n\n\n/* Get mate score from tag. */\n\nstatic int64_t get_mate_score(bam1_t *b) {\n    uint8_t *data;\n    int64_t score;\n\n    if ((data = bam_aux_get(b, \"ms\"))) {\n        score = bam_aux2i(data);\n    } else {\n        print_error(\"markdup\", \"error, no ms score tag. Please run samtools fixmate on file first.\\n\");\n        return -1;\n    }\n\n    return score;\n}\n\n\n/* Calc current score from quality. */\n\nstatic int64_t calc_score(bam1_t *b)\n{\n    int64_t score = 0;\n    uint8_t  *qual = bam_get_qual(b);\n    int i;\n\n    for (i = 0; i < b->core.l_qseq; i++) {\n        if (qual[i] >= MD_MIN_QUALITY) score += qual[i];\n    }\n\n    return score;\n}\n\n\n/* Create a signature hash of the current read and its pair.\n   Uses the unclipped start (or end depending on orientation),\n   the reference id, orientation and whether the current\n   read is leftmost of the pair. */\n\n\nstatic int make_pair_key(md_param_t *param, key_data_t *key, bam1_t *bam, int rg_num, long *warnings) {\n     hts_pos_t this_coord, this_end, other_coord, other_end, leftmost;\n    int32_t this_ref, other_ref, barcode = 0;\n    int8_t orientation, left_read;\n    uint8_t *data;\n    char *cig, *bar;\n    long incoming_warnings = *warnings;\n\n    this_ref    = bam->core.tid + 1; // avoid a 0 being put into the hash\n    other_ref   = bam->core.mtid + 1;\n\n    this_coord = unclipped_start(bam);\n    this_end   = unclipped_end(bam);\n\n    if ((data = bam_aux_get(bam, \"MC\"))) {\n        if (!(cig = bam_aux2Z(data))) {\n            print_error(\"markdup\", \"error, MC tag wrong type. Please use the MC tag provided by samtools fixmate.\\n\");\n            return 1;\n        }\n\n        other_end   = unclipped_other_end(bam->core.mpos, cig);\n        other_coord = unclipped_other_start(bam->core.mpos, cig);\n    } else {\n        print_error(\"markdup\", \"error, no MC tag. Please run samtools fixmate on file first.\\n\");\n        return 1;\n    }\n\n    // work out orientations\n    if (param->mode == MD_MODE_TEMPLATE) {\n\n        if (this_ref != other_ref) {\n            leftmost = this_ref < other_ref;\n        } else {\n            if (bam_is_rev(bam) == bam_is_mrev(bam)) {\n                if (!bam_is_rev(bam)) {\n                    leftmost = this_coord <= other_coord;\n                } else {\n                    leftmost = this_end <= other_end;\n                }\n            } else {\n                if (bam_is_rev(bam)) {\n                    leftmost = this_end <= other_coord;\n                } else {\n                    leftmost = this_coord <= other_end;\n                }\n            }\n        }\n\n        // pair orientation\n        if (leftmost) {\n            if (bam_is_rev(bam) == bam_is_mrev(bam)) {\n                other_coord = other_end;\n\n                if (!bam_is_rev(bam)) {\n                    if (bam->core.flag & BAM_FREAD1) {\n                        orientation = O_FF;\n                    } else {\n                        orientation = O_RR;\n                    }\n                } else {\n                    if (bam->core.flag & BAM_FREAD1) {\n                        orientation = O_RR;\n                    } else {\n                        orientation = O_FF;\n                    }\n                }\n            } else {\n                if (!bam_is_rev(bam)) {\n                    orientation = O_FR;\n                    other_coord = other_end;\n                } else {\n                    orientation = O_RF;\n                    this_coord = this_end;\n                }\n            }\n        } else {\n            if (bam_is_rev(bam) == bam_is_mrev(bam)) {\n                this_coord = this_end;\n\n                if (!bam_is_rev(bam)) {\n                    if (bam->core.flag & BAM_FREAD1) {\n                        orientation = O_RR;\n                    } else {\n                        orientation = O_FF;\n                    }\n                } else {\n                    if (bam->core.flag & BAM_FREAD1) {\n                        orientation = O_FF;\n                    } else {\n                        orientation = O_RR;\n                    }\n                }\n            } else {\n                if (!bam_is_rev(bam)) {\n                    orientation = O_RF;\n                    other_coord = other_end;\n                } else {\n                    orientation = O_FR;\n                    this_coord = this_end;\n                }\n            }\n        }\n    } else { // MD_MODE_SEQUENCE\n\n        if (this_ref != other_ref) {\n            leftmost = this_ref - other_ref;\n        } else {\n            if (bam_is_rev(bam) == bam_is_mrev(bam)) {\n                if (!bam_is_rev(bam)) {\n                    leftmost = this_coord - other_coord;\n                } else {\n                    leftmost = this_end - other_end;\n                }\n            } else {\n                if (bam_is_rev(bam)) {\n                    leftmost = this_end - other_coord;\n                } else {\n                    leftmost = this_coord - other_end;\n                }\n            }\n        }\n\n        if (leftmost < 0) {\n            leftmost = 1;\n        } else if (leftmost > 0) {\n            leftmost = 0;\n        } else {\n            // tie breaks\n\n            if (bam->core.pos == bam->core.mpos) {\n                if (bam->core.flag & BAM_FREAD1) {\n                    leftmost = 1;\n                } else {\n                    leftmost = 0;\n                }\n            } else if (bam->core.pos < bam->core.mpos) {\n                leftmost = 1;\n            } else {\n                leftmost = 0;\n            }\n        }\n\n        // pair orientation\n        if (leftmost) {\n            if (bam_is_rev(bam) == bam_is_mrev(bam)) {\n\n                if (!bam_is_rev(bam)) {\n                        orientation = O_FF;\n                } else {\n                        orientation = O_RR;\n                }\n            } else {\n                if (!bam_is_rev(bam)) {\n                    orientation = O_FR;\n                } else {\n                    orientation = O_RF;\n                }\n            }\n        } else {\n            if (bam_is_rev(bam) == bam_is_mrev(bam)) {\n\n                if (!bam_is_rev(bam)) {\n                        orientation = O_RR;\n                } else {\n                        orientation = O_FF;\n                }\n            } else {\n                if (!bam_is_rev(bam)) {\n                    orientation = O_RF;\n                } else {\n                    orientation = O_FR;\n                }\n            }\n        }\n\n        if (!bam_is_rev(bam)) {\n            this_coord = unclipped_start(bam);\n        } else {\n            this_coord = unclipped_end(bam);\n        }\n\n        if (!bam_is_mrev(bam)) {\n            other_coord = unclipped_other_start(bam->core.mpos, cig);\n        } else {\n            other_coord = unclipped_other_end(bam->core.mpos, cig);\n        }\n    }\n\n    if (!leftmost)\n        left_read = R_RI;\n    else\n        left_read = R_LE;\n\n    if (param->barcode) {\n        if ((data = bam_aux_get(bam, param->barcode))) {\n            if (!(bar = bam_aux2Z(data))) {\n                (*warnings)++;\n\n                if (*warnings <= BMD_WARNING_MAX) {\n                    print_error(\"markdup\", \"warning, %s tag wrong type. Aux tag needs to be a string type.\\n\", param->barcode);\n                }\n            } else {\n                barcode = do_hash((unsigned char *)bar, strlen(bar));\n            }\n        }\n    } else if (param->bc_rgx) {\n        int result;\n        regmatch_t matches[3];\n        size_t max_matches = 2;\n        char *qname = bam_get_qname(bam);\n\n        if ((result = regexec(param->bc_rgx, qname, max_matches, matches, 0)) == 0) {\n            int bc_start, bc_end;\n\n            bc_start = matches[1].rm_so;\n            bc_end   = matches[1].rm_eo;\n\n            if (bc_start != -1) {\n                barcode = do_hash((unsigned char *)qname + bc_start, bc_end - bc_start);\n            } else {\n                (*warnings)++;\n\n                if (*warnings <= BMD_WARNING_MAX) {\n                    print_error(\"markdup\", \"warning, barcode regex unable to match substring on %s.\\n\", qname);\n                }\n            }\n        } else {\n            (*warnings)++;\n\n            if (*warnings <= BMD_WARNING_MAX) {\n                char warn_msg[256];\n\n                regerror(result, param->bc_rgx, warn_msg, 256);\n                print_error(\"markdup\", \"warning, barcode regex match error \\\"%s\\\" on %s.\\n\", warn_msg, qname);\n            }\n        }\n    }\n\n    if ((*warnings == BMD_WARNING_MAX) && (incoming_warnings != *warnings)) {\n        print_error(\"markdup\", \"warning, %ld barcode read warnings.  New warnings will not be reported.\\n\",\n                        *warnings);\n    }\n\n    key->single        = 0;\n    key->this_ref      = this_ref;\n    key->this_coord    = this_coord;\n    key->other_ref     = other_ref;\n    key->other_coord   = other_coord;\n    key->leftmost      = left_read;\n    key->orientation   = orientation;\n    key->barcode       = barcode;\n    key->read_group    = rg_num;\n\n    return 0;\n}\n\n\n/* Create a signature hash of single read (or read with an unmatched pair).\n   Uses unclipped start (or end depending on orientation), reference id,\n   and orientation. */\n\nstatic void make_single_key(md_param_t *param, key_data_t *key, bam1_t *bam, int rg_num, long *warnings) {\n    hts_pos_t this_coord;\n    int32_t this_ref, barcode = 0;\n    int8_t orientation;\n    uint8_t *data;\n    char *bar;\n    long incoming_warnings = *warnings;\n\n    this_ref = bam->core.tid + 1; // avoid a 0 being put into the hash\n\n    if (bam_is_rev(bam)) {\n        this_coord = unclipped_end(bam);\n        orientation = O_RR;\n    } else {\n        this_coord = unclipped_start(bam);\n        orientation = O_FF;\n    }\n\n    if (param->barcode) {\n        if ((data = bam_aux_get(bam, param->barcode))) {\n            if (!(bar = bam_aux2Z(data))) {\n                (*warnings)++;\n\n                if (*warnings <= BMD_WARNING_MAX) {\n                    print_error(\"markdup\", \"warning, %s tag wrong type. Aux tag needs to be a string type.\\n\", param->barcode);\n                }\n            } else {\n                barcode = do_hash((unsigned char *)bar, strlen(bar));\n            }\n        }\n    } else if (param->bc_rgx) {\n        int result;\n        regmatch_t matches[3];\n        size_t max_matches = 2;\n        char *qname = bam_get_qname(bam);\n\n        if ((result = regexec(param->bc_rgx, qname, max_matches, matches, 0)) == 0) {\n            int bc_start, bc_end;\n\n            bc_start = matches[1].rm_so;\n            bc_end   = matches[1].rm_eo;\n\n            if (bc_start != -1) {\n                barcode = do_hash((unsigned char *)qname + bc_start, bc_end - bc_start);\n            } else {\n                (*warnings)++;\n\n                if (*warnings <= BMD_WARNING_MAX) {\n                    print_error(\"markdup\", \"warning, barcode regex unable to match substring on %s.\\n\", qname);\n                }\n            }\n        } else {\n            (*warnings)++;\n\n            if (*warnings <= BMD_WARNING_MAX) {\n                char warn_msg[256];\n\n                regerror(result, param->bc_rgx, warn_msg, 256);\n                print_error(\"markdup\", \"warning, barcode regex match error \\\"%s\\\" on %s.\\n\", warn_msg, qname);\n            }\n        }\n    }\n\n    if ((*warnings == BMD_WARNING_MAX) && (incoming_warnings != *warnings)) {\n        print_error(\"markdup\", \"warning, %ld barcode read warnings.  New warnings will not be reported.\\n\",\n                        *warnings);\n    }\n\n\n    key->single        = 1;\n    key->this_ref      = this_ref;\n    key->this_coord    = this_coord;\n    key->orientation   = orientation;\n    key->barcode       = barcode;\n    key->read_group    = rg_num;\n}\n\n\n/* Add the duplicate name to a hash if it does not exist. */\n\nstatic int add_duplicate(khash_t(duplicates) *d_hash, bam1_t *dupe, char *orig_name, char type, int group) {\n    khiter_t d;\n    int ret;\n\n    d = kh_get(duplicates, d_hash, bam_get_qname(dupe));\n\n    if (d == kh_end(d_hash)) {\n        char *name = strdup(bam_get_qname(dupe));\n        if (name) {\n            d = kh_put(duplicates, d_hash, name, &ret);\n        } else {\n            ret = -1;\n        }\n\n        if (ret >= 0) {\n            if (orig_name) {\n                if (ret == 0) {\n                    // replace old name\n                    free(kh_value(d_hash, d).name);\n                    free(name);\n                }\n\n                kh_value(d_hash, d).name = strdup(orig_name);\n\n                if (kh_value(d_hash, d).name == NULL) {\n                    print_error(\"markdup\", \"error, unable to allocate memory for duplicate original name.\\n\");\n                    return 1;\n                }\n            } else {\n                kh_value(d_hash, d).name = NULL;\n            }\n\n            kh_value(d_hash, d).type = type;\n            kh_value(d_hash, d).read_group = group;\n        } else {\n            print_error(\"markdup\", \"error, unable to store supplementary duplicates.\\n\");\n            free(name);\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n\n/* Get coordinates from the standard Illumina style read names.\n   Returned values are of the x and y coordinates and a section of\n   the read name to test (t) for string equality e.g. lane and tile part. */\n\nstatic int get_coordinates_colons(md_param_t *param, const char *qname, int *t_beg, int *t_end, long *x_coord, long *y_coord, long *warnings) {\n    int sep = 0;\n    int pos = 0;\n    int xpos = 0, ypos = 0;\n    char *end;\n\n    while (qname[pos]) {\n        if (qname[pos] == ':') {\n            sep++;\n\n            if (sep == 2) {\n                xpos = pos + 1;\n            } else if (sep == 3) {\n                ypos = pos + 1;\n            } else if (sep == 4) { // HiSeq style names\n                xpos = ypos;\n                ypos = pos + 1;\n            } else if (sep == 5) { // Newer Illumina format\n                xpos = pos + 1;\n            } else if (sep == 6) {\n                ypos = pos + 1;\n            }\n        }\n\n        pos++;\n    }\n\n    /* The most current Illumina read format at time of writing is:\n       @machine:run:flowcell:lane:tile:x:y:UMI or\n       @machine:run:flowcell:lane:tile:x:y\n\n       Counting the separating colons gives us a quick format check.\n       Older name formats have fewer elements.\n    */\n\n    if (!(sep == 3 || sep == 4 || sep == 6 || sep == 7)) {\n        (*warnings)++;\n\n        if (*warnings <= BMD_WARNING_MAX) {\n            print_error(\"markdup\", \"warning, cannot decipher read name %s for optical duplicate marking.\\n\", qname);\n        }\n\n        return 1;\n    } else {\n        *x_coord = strtol(qname + xpos, &end, 10);\n\n        if ((qname + xpos) == end) {\n            (*warnings)++;\n\n            if (*warnings <= BMD_WARNING_MAX) {\n                print_error(\"markdup\", \"warning, cannot decipher x coordinate in %s .\\n\", qname);\n            }\n\n            return 1;\n        }\n\n        *y_coord = strtol(qname + ypos, &end, 10);\n\n        if ((qname + ypos) == end) {\n            (*warnings)++;\n\n            if (*warnings <= BMD_WARNING_MAX) {\n                print_error(\"markdup\", \"warning, cannot decipher y coordinate in %s .\\n\", qname);\n            }\n\n            return 1;\n        }\n\n        *t_beg = 0;\n        *t_end = xpos;\n    }\n\n    return 0;\n}\n\n/* Get the coordinates from the read name.\n   Returned values are of the x and y coordinates and an optional section of\n   the read name to test (t) for string equality e.g. lane and tile part. */\n\nstatic inline int get_coordinates_regex(md_param_t *param, const char *qname, int *t_beg, int *t_end, long *x_coord, long *y_coord, long *warnings) {\n    regmatch_t matches[5];\n    size_t max_matches = 5;\n    int xpos, ypos, xend, yend, xlen, ylen;\n    char coord[255];\n    char *end;\n\n    if (!param->rgx_t)\n        max_matches = 4;\n\n    if (regexec(param->rgx, qname, max_matches, matches, 0))\n        return -1;\n\n    xpos = matches[param->rgx_x].rm_so;\n    ypos = matches[param->rgx_y].rm_so;\n\n    if (param->rgx_t) {\n        *t_beg = matches[param->rgx_t].rm_so;\n        *t_end = matches[param->rgx_t].rm_eo;\n    } else {\n        *t_beg = *t_end = 0;\n    }\n\n    if (xpos == -1 || ypos == -1 || *t_beg == -1)\n        return -1;\n\n    xend = matches[param->rgx_x].rm_eo;\n    yend = matches[param->rgx_y].rm_eo;\n\n    if ((xlen = xend - xpos) > 254) {\n        (*warnings)++;\n\n        if (*warnings <= BMD_WARNING_MAX) {\n            print_error(\"markdup\", \"warning, x coordinate string longer than allowed qname length in %s (%d long).\\n\", qname, xlen);\n        }\n\n        return 1;\n    }\n\n    strncpy(coord, qname + xpos, xlen);\n    coord[xlen] = '\\0';\n    *x_coord = strtol(coord, &end, 10);\n\n    if (coord == end) {\n        (*warnings)++;\n\n        if (*warnings <= BMD_WARNING_MAX) {\n            print_error(\"markdup\", \"warning, cannot decipher x coordinate in %s (%s).\\n\", qname, coord);\n        }\n\n        return 1;\n    }\n\n    if ((ylen = yend - ypos) > 254) {\n        (*warnings)++;\n\n        if (*warnings <= BMD_WARNING_MAX) {\n            print_error(\"markdup\", \"warning, y coordinate string longer than allowed qname length in %s (%d long).\\n\", qname, ylen);\n        }\n\n        return 1;\n    }\n\n    strncpy(coord, qname + ypos, ylen);\n    coord[ylen] = '\\0';\n    *y_coord = strtol(coord, &end, 10);\n\n    if (coord == end) {\n        (*warnings)++;\n\n        if (*warnings <= BMD_WARNING_MAX) {\n            print_error(\"markdup\", \"warning, cannot decipher y coordinate in %s (%s).\\n\", qname, coord);\n        }\n\n        return 1;\n    }\n\n    return 0;\n}\n\n\nstatic int get_coordinates(md_param_t *param, const char *name, int *t_beg, int *t_end, long *x_coord, long *y_coord, long *warnings) {\n    int ret = 1;\n\n    if (param->rgx == NULL) {\n        ret = get_coordinates_colons(param, name, t_beg, t_end, x_coord, y_coord, warnings);\n    } else {\n        ret = get_coordinates_regex(param, name, t_beg, t_end, x_coord, y_coord, warnings);\n    }\n\n    return ret;\n}\n\n\n/* Using the coordinates from the read name, see whether the duplicated read is\n   close enough (set by max_dist) to the original to be counted as optical.*/\n\nstatic int is_optical_duplicate(md_param_t *param, bam1_t *ori, bam1_t *dup, long max_dist, long *warnings) {\n    int ret = 0;\n    char *original, *duplicate;\n    long ox, oy, dx, dy;\n    int o_beg = 0, o_end = 0, d_beg = 0, d_end = 0;\n\n    original  = bam_get_qname(ori);\n    duplicate = bam_get_qname(dup);\n\n    if (get_coordinates(param, original, &o_beg, &o_end, &ox, &oy, warnings)) {\n        return ret;\n    }\n\n    if (get_coordinates(param, duplicate, &d_beg, &d_end, &dx, &dy, warnings)) {\n        return ret;\n    }\n\n    int o_len = o_end - o_beg;\n    int d_len = d_end - d_beg;\n\n    if ((o_len == d_len) && memcmp(original + o_beg, duplicate + d_beg, o_len) == 0) {\n        long xdiff, ydiff;\n\n        if (ox > dx) {\n            xdiff = ox - dx;\n        } else {\n            xdiff = dx - ox;\n        }\n\n        if (xdiff <= max_dist) {\n            // still might be optical\n\n            if (oy > dy) {\n                ydiff = oy - dy;\n            } else {\n                ydiff = dy - oy;\n            }\n\n            if (ydiff <= max_dist) ret = 1;\n        }\n    }\n\n    return ret;\n}\n\n\n/* Using the coordinates from the Illumina read name, see whether the duplicated read is\n   close enough (set by max_dist) to the original to be counted as optical.\n\n   This function needs the values from the first read to be already calculated. */\n\nstatic int optical_duplicate_partial(md_param_t *param, const char *name, const int o_beg, const int o_end, const long ox, const long oy, bam1_t *dup, check_t *c, long max_dist, long *warnings) {\n    int ret = 0;\n    char *duplicate;\n    int d_beg = 0, d_end = 0;\n    long dx, dy;\n\n    duplicate = bam_get_qname(dup);\n\n    if (get_coordinates(param, duplicate, &d_beg, &d_end, &dx, &dy, warnings)) {\n        return ret;\n    }\n\n    int o_len = o_end - o_beg;\n    int d_len = d_end - d_beg;\n\n    if ((o_len == d_len) && memcmp(name + o_beg, duplicate + d_beg, o_len) == 0) {\n        // the initial parts match, look at the numbers\n        long xdiff, ydiff;\n\n        if (ox > dx) {\n            xdiff = ox - dx;\n        } else {\n            xdiff = dx - ox;\n        }\n\n        if (xdiff <= max_dist) {\n            // still might be optical\n\n            if (oy > dy) {\n                ydiff = oy - dy;\n            } else {\n                ydiff = dy - oy;\n            }\n\n            if (ydiff <= max_dist) ret = 1;\n        }\n    }\n\n    c->x = dx;\n    c->y = dy;\n    c->beg = d_beg;\n    c->end = d_end;\n    c->len = d_end - d_beg;\n\n    return ret;\n}\n\n\n/* Mark the read as a duplicate and update the duplicate hash (if needed) */\nstatic int mark_duplicates(md_param_t *param, khash_t(duplicates) *dup_hash, bam1_t *ori, bam1_t *dup,\n                           int read_group, long *optical, long *warn) {\n    char dup_type = 0;\n    long incoming_warnings = *warn;\n\n    dup->core.flag |= BAM_FDUP;\n\n    if (param->tag) {\n        if (bam_aux_update_str(dup, \"do\", strlen(bam_get_qname(ori)) + 1, bam_get_qname(ori))) {\n            print_error(\"markdup\", \"error, unable to append 'do' tag.\\n\");\n            return -1;\n        }\n    }\n\n    if (param->opt_dist) { // mark optical duplicates\n        if (is_optical_duplicate(param, ori, dup, param->opt_dist, warn)) {\n            bam_aux_update_str(dup, \"dt\", 3, \"SQ\");\n            dup_type = 'O';\n            (*optical)++;\n        } else {\n            // not an optical duplicate\n            bam_aux_update_str(dup, \"dt\", 3, \"LB\");\n        }\n    }\n\n    if ((*warn == BMD_WARNING_MAX) && (incoming_warnings != *warn)) {\n        print_error(\"markdup\", \"warning, %ld decipher read name warnings.  New warnings will not be reported.\\n\",\n                        *warn);\n    }\n\n    if (param->supp) {\n        if (bam_aux_get(dup, \"SA\") || (dup->core.flag & BAM_FMUNMAP) || bam_aux_get(dup, \"XA\")) {\n            char *original = NULL;\n\n            if (param->tag) {\n                original = bam_get_qname(ori);\n            }\n\n            if (add_duplicate(dup_hash, dup, original, dup_type, read_group))\n                return -1;\n        }\n    }\n\n    return 0;\n}\n\n\n/* If the duplicate type has changed to optical then retag and duplicate hash. */\nstatic inline int optical_retag(md_param_t *param, khash_t(duplicates) *dup_hash, bam1_t *b, int paired, stats_block_t *stats) {\n    int ret = 0;\n\n    if (bam_aux_update_str(b, \"dt\", 3, \"SQ\")) {\n        print_error(\"markdup\", \"error, unable to update 'dt' tag.\\n\");\n        ret = -1;\n    }\n\n    if (paired) {\n        stats->optical++;\n    } else {\n        stats->single_optical++;\n    }\n\n    if (param->supp) {\n        // Change the duplicate type\n\n        if (bam_aux_get(b, \"SA\") || (b->core.flag & BAM_FMUNMAP)\n            || bam_aux_get(b, \"XA\")) {\n            khiter_t d;\n\n            d = kh_get(duplicates, dup_hash, bam_get_qname(b));\n\n            if (d == kh_end(dup_hash)) {\n                // error, name should already be in dup hash\n                print_error(\"markdup\", \"error, duplicate name %s not found in hash.\\n\",\n                    bam_get_qname(b));\n                ret = -1;\n            } else {\n                kh_value(dup_hash, d).type = 'O';\n            }\n        }\n    }\n\n    return ret;\n}\n\n\n/* This is based on the fixmate actions for when only one of a pair is present */\nstatic inline int has_mate(bam1_t *b) {\n    int ret = 0;\n\n    if ((b->core.flag & BAM_FPAIRED) && !(b->core.flag & BAM_FMUNMAP) &&\n       !((b->core.mtid == -1) && (b->core.mpos == -1))) {\n        ret = 1;\n    }\n\n    return ret;\n}\n\n\n/* Check all duplicates of the highest quality read (the \"original\") for consistancy.  Also\n   pre-calculate any values for use in check_duplicate_chain later.\n   Returns 0 on success, >0 on coordinate reading error (program can continue) or\n   <0 on an error (program should not continue. */\nstatic int check_chain_against_original(md_param_t *param, khash_t(duplicates) *dup_hash, read_queue_t *ori,\n             check_list_t *list, long *warn, stats_block_t *stats) {\n\n    int ret = 0, coord_fail = 0;\n    char *ori_name = bam_get_qname(ori->b);\n    read_queue_t *current = ori->duplicate;\n    int t_beg = 0, t_end = 0;\n    long x, y;\n\n    if (param->opt_dist) {\n        coord_fail = get_coordinates(param, ori_name, &t_beg, &t_end, &x, &y, warn);\n    }\n\n    list->length = 0;\n\n    while (current) {\n        check_t *c;\n\n        if (list->length >= list->size) {\n            check_t *tmp;\n\n            list->size *= 2;\n\n            if (!(tmp = realloc(list->c, list->size * sizeof(check_t)))) {\n                print_error(\"markdup\", \"error, Unable to expand optical check list.\\n\");\n                return -1;\n            }\n\n            list->c = tmp;\n        }\n\n        c = &list->c[list->length];\n\n        c->b = current->b;\n        c->x = -1;\n        c->y = -1;\n        c->opt = 0;\n        c->score = 0;\n        c->mate_score = 0;\n        current->dup_checked = 1;\n\n        if (param->tag) {\n            uint8_t *data;\n\n            // at this stage all duplicates should have a do tag\n            if ((data = bam_aux_get(current->b, \"do\")) != NULL) {\n                // see if we need to change the tag\n                char *old_name = bam_aux2Z(data);\n\n                if (old_name) {\n                    if (strcmp(old_name, ori_name) != 0) {\n                        if (bam_aux_update_str(current->b, \"do\", strlen(ori_name) + 1, (const char *)ori_name)) {\n                            print_error(\"markdup\", \"error, unable to update 'do' tag.\\n\");\n                            ret =  -1;\n                            break;\n                        }\n                    }\n                } else {\n                    print_error(\"markdup\", \"error, 'do' tag has wrong type for read %s.\\n\", bam_get_qname(current->b));\n                    ret = -1;\n                    break;\n                }\n            }\n        }\n\n        if (param->opt_dist && !coord_fail) {\n            uint8_t *data;\n            char *dup_type;\n            int is_opt = 0;\n            int current_paired = has_mate(current->b);\n\n            if ((data = bam_aux_get(current->b, \"dt\"))) {\n                if ((dup_type = bam_aux2Z(data))) {\n                    if (strcmp(dup_type, \"SQ\") == 0) {\n                        c->opt = 1;\n                    }\n                }\n            }\n\n            // need to run this to get the duplicates x and y scores\n            is_opt = optical_duplicate_partial(param, ori_name, t_beg, t_end, x, y, current->b, c, param->opt_dist, warn);\n\n            if (!c->opt && is_opt) {\n                if (optical_retag(param, dup_hash, current->b, current_paired, stats)) {\n                    ret = -1;\n                    break;\n                }\n\n                c->opt = 1;\n            }\n\n            c->score = calc_score(current->b);\n\n            if (current_paired) {\n                if ((c->mate_score = get_mate_score(current->b)) == -1) {\n                     print_error(\"markdup\", \"error, no ms score tag. Please run samtools fixmate on file first.\\n\");\n                     ret = -1;\n                     break;\n                }\n            }\n        }\n\n        current = current->duplicate;\n        list->length++;\n    }\n\n    if (!ret && coord_fail)\n        ret = coord_fail;\n\n    ori->dup_checked = 1;\n\n    return ret;\n}\n\n\nstatic int chain_sort(const void *a, const void *b) {\n    check_t *ac = (check_t *) a;\n    check_t *bc = (check_t *) b;\n    int ret;\n\n    if ((ret = ac->len - bc->len))\n        return ret;\n    else if ((ret = memcmp(bam_get_qname(ac->b) + ac->beg, bam_get_qname(bc->b) + bc->beg, ac->len)))\n        return ret;\n\n    return (ac->x - bc->x);\n}\n\n\n/* Check all the duplicates against each other to see if they are optical duplicates. */\nstatic int check_duplicate_chain(md_param_t *param, khash_t(duplicates) *dup_hash, check_list_t *list,\n             long *warn, stats_block_t *stats) {\n    int ret = 0;\n    size_t curr = 0;\n\n    qsort(list->c, list->length, sizeof(list->c[0]), chain_sort);\n\n    while (curr < list->length - 1) {\n        check_t *base = &list->c[curr];\n        char *base_name = bam_get_qname(base->b);\n        int end_name_match = curr;\n\n        // find the end of the matching name parts\n        while (++end_name_match < list->length) {\n            check_t *chk = &list->c[end_name_match];\n\n            if ((base->len == chk->len) && memcmp(base_name + base->beg, bam_get_qname(chk->b) + chk->beg, base->len) != 0)\n                break;\n        }\n\n        while (curr < end_name_match) {\n            size_t count = curr;\n            check_t *current = &list->c[curr];\n            int current_paired = has_mate(current->b);\n\n            while (++count < end_name_match && (list->c[count].x - current->x <= param->opt_dist)) {\n                // while close enough along the x coordinate\n                check_t *chk = &list->c[count];\n\n                if (current->opt && chk->opt)\n                    continue;\n\n                long ydiff;\n\n                if (current->y > chk->y) {\n                    ydiff = current->y - chk->y;\n                } else {\n                    ydiff = chk->y - current->y;\n                }\n\n                if (ydiff > param->opt_dist)\n                    continue;\n\n                // optical duplicates\n                int chk_dup = 0;\n                int chk_paired = has_mate(chk->b);\n\n                if (current_paired != chk_paired) {\n                    if (!chk_paired) {\n                        // chk is single vs pair, this is a dup.\n                        chk_dup = 1;\n                    }\n                } else {\n                    // do it by scores\n                    int64_t cur_score, chk_score;\n\n                    if ((current->b->core.flag & BAM_FQCFAIL) != (chk->b->core.flag & BAM_FQCFAIL)) {\n                        if (current->b->core.flag & BAM_FQCFAIL) {\n                            cur_score = 0;\n                            chk_score = 1;\n                        } else {\n                            cur_score = 1;\n                            chk_score = 0;\n                        }\n                    } else {\n                        cur_score = current->score;\n                        chk_score = chk->score;\n\n                        if (current_paired) {\n                            // they are pairs so add mate scores.\n                            chk_score += chk->mate_score;\n                            cur_score += current->mate_score;\n                        }\n                    }\n\n                    if (cur_score == chk_score) {\n                        if (strcmp(bam_get_qname(chk->b), bam_get_qname(current->b)) < 0) {\n                            chk_score++;\n                        } else {\n                            chk_score--;\n                        }\n                    }\n\n                    if (cur_score > chk_score) {\n                        chk_dup = 1;\n                    }\n                }\n\n                if (chk_dup) {\n                    // the duplicate is the optical duplicate\n                    if (!chk->opt) { // only change if not already an optical duplicate\n                        if (optical_retag(param, dup_hash, chk->b, chk_paired, stats)) {\n                            ret = -1;\n                            goto fail;\n                        }\n\n                        chk->opt = 1;\n                    }\n                } else {\n                    if (!current->opt) {\n                        if (optical_retag(param, dup_hash, current->b, current_paired, stats)) {\n                            ret = -1;\n                            goto fail;\n                        }\n\n                        current->opt = 1;\n                    }\n                }\n            }\n\n            curr++;\n        }\n    }\n\n fail:\n    return ret;\n}\n\n\n/* Where there is more than one duplicate go down the list and check for optical duplicates and change\n   do tags (where used) to point to original (non-duplicate) read. */\nstatic int find_duplicate_chains(md_param_t *param, read_queue_t *in_read , khash_t(duplicates) *dup_hash, check_list_t *dup_list,\n                                long *warn, stats_block_t *stats) {\n    int ret = 0;\n\n    while (in_read->original) in_read = in_read->original;\n\n    // check against the original for tagging and optical duplication\n    if ((ret = check_chain_against_original(param, dup_hash, in_read, dup_list, warn, stats + in_read->read_group))) {\n        if (ret < 0) { // real error\n            ret = -1;\n        } else { // coordinate decoding error\n            ret = 0;\n        }\n    } else {\n        // check the rest of the duplicates against each other for optical duplication\n        if (param->opt_dist && check_duplicate_chain(param, dup_hash, dup_list, warn, stats + in_read->read_group)) {\n            ret = -1;\n        }\n    }\n\n    return ret;\n}\n\n\n/*\n  Function to use when estimating library size.\n\n  This is based on an approximate formula for the coverage of a set\n  obtained after sampling it a given number of times with replacement.\n\n  x = number of items in the set (the number of unique fragments in the library)\n\n  c = number of unique items (unique read pairs observed)\n\n  n = number of items samples (total number of read pairs)\n\n  c and n are known; x is unknown.\n\n  As n -> infinity, the coverage (c/x) can be given as:\n\n  c / x = 1 - exp(-n / x)  (see https://math.stackexchange.com/questions/32800)\n\n  This needs to be solved for x, so it is rearranged to put both terms on the\n  left side and estimate_library_size() finds a value of x which gives a\n  result of zero (or as close as it can get).\n */\nstatic inline double coverage_equation(double x, double c, double n) {\n    return c / x - 1 + exp(-n / x);\n}\n\n\n/* estimate the library size, based on the Picard code in DuplicationMetrics.java*/\nstatic unsigned long estimate_library_size(unsigned long paired_reads, unsigned long paired_duplicate_reads, unsigned long optical) {\n    unsigned long estimated_size = 0;\n    unsigned long non_optical_pairs = (paired_reads - optical) / 2;\n    unsigned long unique_pairs = (paired_reads - paired_duplicate_reads) / 2;\n    unsigned long duplicate_pairs = (paired_duplicate_reads - optical) / 2;\n\n    if ((non_optical_pairs && duplicate_pairs && unique_pairs) && (non_optical_pairs > duplicate_pairs)) {\n        double m = 1;\n        double M = 100;\n        int i;\n\n        if (coverage_equation(m * (double)unique_pairs, (double)unique_pairs, (double)non_optical_pairs) < 0) {\n            print_error(\"markdup\", \"warning, unable to calculate estimated library size.\\n\");\n            return  estimated_size;\n        }\n\n        while (coverage_equation(M * (double)unique_pairs, (double)unique_pairs, (double)non_optical_pairs) > 0) {\n            M *= 10;\n        }\n\n        for (i = 0; i < 40; i++) {\n            double r = (m + M) / 2;\n            double u = coverage_equation(r * (double)unique_pairs, (double)unique_pairs, (double)non_optical_pairs);\n\n            if (u > 0) {\n                m = r;\n            } else if (u < 0) {\n                M = r;\n            } else {\n                break;\n            }\n        }\n\n        estimated_size = (unsigned long)(unique_pairs * (m + M) / 2);\n    } else {\n        print_error(\"markdup\", \"warning, unable to calculate estimated library size.\"\n                        \" Read pairs %ld should be greater than duplicate pairs %ld,\"\n                        \" which should both be non zero.\\n\",\n                        non_optical_pairs, duplicate_pairs);\n    }\n\n    return estimated_size;\n}\n\n\nstatic void write_stats(FILE *fp, const char *title,  const char *title_con, stats_block_t *stats) {\n    unsigned long els;\n\n    els = estimate_library_size(stats->pair, stats->duplicate, stats->optical);\n\n    if (title) {\n        fprintf(fp, \"%s%s\\n\", title, title_con);\n    }\n\n    fprintf(fp,\n            \"READ: %ld\\n\"\n            \"WRITTEN: %ld\\n\"\n            \"EXCLUDED: %ld\\n\"\n            \"EXAMINED: %ld\\n\"\n            \"PAIRED: %ld\\n\"\n            \"SINGLE: %ld\\n\"\n            \"DUPLICATE PAIR: %ld\\n\"\n            \"DUPLICATE SINGLE: %ld\\n\"\n            \"DUPLICATE PAIR OPTICAL: %ld\\n\"\n            \"DUPLICATE SINGLE OPTICAL: %ld\\n\"\n            \"DUPLICATE NON PRIMARY: %ld\\n\"\n            \"DUPLICATE NON PRIMARY OPTICAL: %ld\\n\"\n            \"DUPLICATE PRIMARY TOTAL: %ld\\n\"\n            \"DUPLICATE TOTAL: %ld\\n\"\n            \"ESTIMATED_LIBRARY_SIZE: %ld\\n\", stats->reading, stats->writing, stats->excluded, stats->examined, stats->pair, stats->single,\n                            stats->duplicate, stats->single_dup, stats->optical, stats->single_optical, stats->np_duplicate, stats->np_opt_duplicate,\n                            stats->single_dup + stats->duplicate, stats->single_dup + stats->duplicate + stats->np_duplicate, els);\n}\n\n\nstatic void write_json_stats(FILE *fp, const char *offset, const char *group_name, stats_block_t *stats, const char *end) {\n    unsigned long  els;\n\n    els = estimate_library_size(stats->pair, stats->duplicate, stats->optical);\n\n    if (group_name) {\n        fprintf(fp, \"%s\\\"READ GROUP\\\": \\\"%s\\\",\\n\", offset, group_name);\n    }\n\n    fprintf(fp, \"%s\\\"READ\\\": %ld,\\n\", offset, stats->reading);\n    fprintf(fp, \"%s\\\"WRITTEN\\\": %ld,\\n\", offset, stats->writing);\n    fprintf(fp, \"%s\\\"EXCLUDED\\\": %ld,\\n\", offset, stats->excluded);\n    fprintf(fp, \"%s\\\"EXAMINED\\\": %ld,\\n\", offset, stats->examined);\n    fprintf(fp, \"%s\\\"PAIRED\\\": %ld,\\n\", offset, stats->pair);\n    fprintf(fp, \"%s\\\"SINGLE\\\": %ld,\\n\", offset, stats->single);\n    fprintf(fp, \"%s\\\"DUPLICATE PAIR\\\": %ld,\\n\", offset, stats->duplicate);\n    fprintf(fp, \"%s\\\"DUPLICATE SINGLE\\\": %ld,\\n\", offset, stats->single_dup);\n    fprintf(fp, \"%s\\\"DUPLICATE PAIR OPTICAL\\\": %ld,\\n\", offset, stats->optical);\n    fprintf(fp, \"%s\\\"DUPLICATE SINGLE OPTICAL\\\": %ld,\\n\", offset, stats->single_optical);\n    fprintf(fp, \"%s\\\"DUPLICATE NON PRIMARY\\\": %ld,\\n\", offset, stats->np_duplicate);\n    fprintf(fp, \"%s\\\"DUPLICATE NON PRIMARY OPTICAL\\\": %ld,\\n\", offset, stats->np_opt_duplicate);\n    fprintf(fp, \"%s\\\"DUPLICATE PRIMARY TOTAL\\\": %ld,\\n\", offset, stats->single_dup + stats->duplicate);\n    fprintf(fp, \"%s\\\"DUPLICATE TOTAL\\\": %ld,\\n\", offset, stats->single_dup + stats->duplicate + stats->np_duplicate);\n    fprintf(fp, \"%s\\\"ESTIMATED_LIBRARY_SIZE\\\": %ld\", offset, els);\n\n    if (end) {\n        fprintf(fp, \"%s\", end);\n    }\n}\n\n\n/* Compare the reads near each other (coordinate sorted) and try to spot the duplicates.\n   Generally the highest quality scoring is chosen as the original and all others the duplicates.\n   The score is based on the sum of the quality values (<= 15) of the read and its mate (if any).\n   While single reads are compared to only one read of a pair, the pair will chosen as the original.\n   The comparison is done on position and orientation, see above for details.\n\n   Marking the supplementary reads of a duplicate as also duplicates takes an extra file read/write\n   step.  This is because the duplicate can occur before the primary read.*/\n\nstatic int bam_mark_duplicates(md_param_t *param) {\n    bam_hdr_t *header = NULL;\n    khiter_t k;\n    khash_t(reads) *pair_hash        = kh_init(reads);\n    khash_t(reads) *single_hash      = kh_init(reads);\n    klist_t(read_queue) *read_buffer = kl_init(read_queue);\n    kliter_t(read_queue) *rq;\n    khash_t(duplicates) *dup_hash    = kh_init(duplicates);\n    khash_t(read_groups) *rg_hash    = kh_init(read_groups);\n    int32_t prev_tid;\n    hts_pos_t prev_coord;\n    read_queue_t *in_read;\n    int ret;\n    stats_block_t *stats, *stat_array = NULL;\n    int num_groups = 0;\n    long opt_warnings = 0, bc_warnings = 0;\n    tmp_file_t temp;\n    char *idx_fn = NULL;\n    int exclude = 0;\n    check_list_t dup_list = {NULL, 0, 0};\n\n    if (!pair_hash || !single_hash || !read_buffer || !dup_hash || !rg_hash) {\n        print_error(\"markdup\", \"error, unable to allocate memory to initialise structures.\\n\");\n        goto fail;\n    }\n\n    if ((header = sam_hdr_read(param->in)) == NULL) {\n        print_error(\"markdup\", \"error reading header\\n\");\n        goto fail;\n    }\n\n    // accept unknown, unsorted or coordinate sort order, but error on queryname sorted.\n    // only really works on coordinate sorted files.\n    kstring_t str = KS_INITIALIZE;\n    if (!sam_hdr_find_tag_hd(header, \"SO\", &str) && str.s && !strcmp(str.s, \"queryname\")) {\n        print_error(\"markdup\", \"error, queryname sorted, must be sorted by coordinate.\\n\");\n        ks_free(&str);\n        goto fail;\n    }\n    ks_free(&str);\n\n    if (!param->no_pg && sam_hdr_add_pg(header, \"samtools\", \"VN\", samtools_version(),\n                        param->arg_list ? \"CL\" : NULL,\n                        param->arg_list ? param->arg_list : NULL,\n                        NULL) != 0) {\n        print_error(\"markdup\", \"warning, unable to add @PG line to header.\\n\");\n    }\n\n    if (sam_hdr_write(param->out, header) < 0) {\n        print_error(\"markdup\", \"error writing header.\\n\");\n        goto fail;\n    }\n    if (param->write_index) {\n        if (!(idx_fn = auto_index(param->out, param->out_fn, header)))\n            goto fail;\n    }\n\n    if (param->read_groups) {\n        num_groups = sam_hdr_count_lines(header, \"RG\");\n        int g_ret = 0;\n\n        if (num_groups > 0) {\n            int i;\n\n            for (i = 0; i < num_groups; i++) {\n                const char *rg_key;\n                khiter_t rg;\n\n                rg_key = sam_hdr_line_name(header, \"RG\", i);\n\n                if (rg_key) {\n                    rg = kh_get(read_groups, rg_hash, rg_key);\n\n                    if (rg == kh_end(rg_hash)) { // new entry\n                        rg = kh_put(read_groups, rg_hash, rg_key, &g_ret);\n\n                        if (g_ret > 0) {\n                            kh_value(rg_hash, rg) = i + 1;\n                        } else {\n                            print_error(\"markdup\", \"error, unable to populate read group ids.  \"\n                                     \"Read groups will not be used\\n\");\n                            g_ret = -1;\n                            break;\n                        }\n                    } else {\n                        print_error(\"markdup\", \"error, duplicate read group ids %s.\"\n                                  \"Read groups will not be used\\n\", rg_key);\n                        g_ret = -1;\n                        break;\n                    }\n                } else {\n                    print_error(\"markdup\", \"error, Unable to retrieve read group at position %d.\"\n                              \"Read groups will not be used\\n\", i);\n                    g_ret = -1;\n                    break;\n                }\n            }\n        } else {\n            print_error(\"markdup\", \"error, no read groups found.\\n\");\n            g_ret = -1;\n        }\n\n        if (g_ret < 0) {\n            print_error(\"markdup\", \"error, read groups will not be used.\\n\");\n            param->read_groups = 0;\n            num_groups = 0;\n        }\n    }\n\n    // stat_array[0] will be for ungrouped reads\n    stat_array = calloc(num_groups + 1, sizeof(stats_block_t));\n\n    if (stat_array == NULL) {\n        print_error(\"markdup\", \"error, unable to allocate memory for stats.\\n\");\n        goto fail;\n    }\n\n    // used for coordinate order checks\n    prev_tid = prev_coord = 0;\n\n    // get the buffer going\n    in_read = kl_pushp(read_queue, read_buffer);\n    if (!in_read) {\n        print_error(\"markdup\", \"error, unable to allocate memory to hold reads.\\n\");\n        goto fail;\n    }\n\n    // handling supplementary reads needs a temporary file\n    if (param->supp) {\n        if (tmp_file_open_write(&temp, param->prefix, 1)) {\n            print_error(\"markdup\", \"error, unable to open tmp file %s.\\n\", param->prefix);\n            goto fail;\n        }\n    }\n\n    if ((in_read->b = bam_init1()) == NULL) {\n        print_error(\"markdup\", \"error, unable to allocate memory for alignment.\\n\");\n        goto fail;\n    }\n\n    if (param->check_chain && !(param->tag || param->opt_dist))\n        param->check_chain = 0;\n\n    if (param->check_chain) {\n        dup_list.size = 128;\n        dup_list.c = NULL;\n\n        if ((dup_list.c = malloc(dup_list.size * sizeof(check_t))) == NULL) {\n            print_error(\"markdup\", \"error, unable to allocate memory for dup_list.\\n\");\n            goto fail;\n        }\n    }\n\n    while ((ret = sam_read1(param->in, header, in_read->b)) >= 0) {\n\n        // do some basic coordinate order checks\n        if (in_read->b->core.tid >= 0) { // -1 for unmapped reads\n            if (in_read->b->core.tid < prev_tid ||\n               ((in_read->b->core.tid == prev_tid) && (in_read->b->core.pos < prev_coord))) {\n                print_error(\"markdup\", \"error, not in coordinate sorted order.\\n\");\n                goto fail;\n            }\n        }\n\n        prev_coord = in_read->pos = in_read->b->core.pos;\n        prev_tid   =  in_read->b->core.tid;\n        in_read->pair_key.single   = 1;\n        in_read->single_key.single = 0;\n        in_read->duplicate = NULL;\n        in_read->original = NULL;\n        in_read->dup_checked = 0;\n        in_read->read_group = 0;\n        in_read->dc = 1;\n\n        if (param->read_groups) {\n            uint8_t *data;\n            char *rg;\n\n            if ((data = bam_aux_get(in_read->b, \"RG\"))) {\n                if ((rg = bam_aux2Z(data))) {\n                    khiter_t r;\n\n                    r = kh_get(read_groups, rg_hash, rg);\n\n                    if (r != kh_end(rg_hash)) {\n                        in_read->read_group = kh_value(rg_hash, r);\n                    }\n                }\n            }\n        }\n\n        stats = stat_array + in_read->read_group;\n\n        stats->reading++;\n\n        if (param->clear && (in_read->b->core.flag & BAM_FDUP)) {\n            uint8_t *data;\n\n            in_read->b->core.flag ^= BAM_FDUP;\n\n            if ((data = bam_aux_get(in_read->b, \"dt\")) != NULL) {\n                bam_aux_del(in_read->b, data);\n            }\n\n            if ((data = bam_aux_get(in_read->b, \"do\")) != NULL) {\n                bam_aux_del(in_read->b, data);\n            }\n        }\n\n        if (param->include_fails) {\n            exclude |= (BAM_FSECONDARY | BAM_FSUPPLEMENTARY | BAM_FUNMAP);\n        } else {\n            exclude |= (BAM_FSECONDARY | BAM_FSUPPLEMENTARY | BAM_FUNMAP | BAM_FQCFAIL);\n        }\n\n        // read must not be secondary, supplementary, unmapped or (possibly) failed QC\n        if (!(in_read->b->core.flag & exclude)) {\n            stats->examined++;\n\n\n            // look at the pairs first\n            if (has_mate(in_read->b)) {\n                int ret, mate_tmp;\n                key_data_t pair_key;\n                key_data_t single_key;\n                in_hash_t *bp;\n\n                if (make_pair_key(param, &pair_key, in_read->b, in_read->read_group, &bc_warnings)) {\n                    print_error(\"markdup\", \"error, unable to assign pair hash key.\\n\");\n                    goto fail;\n                }\n\n                make_single_key(param, &single_key, in_read->b, in_read->read_group, &bc_warnings);\n\n                stats->pair++;\n                in_read->pos = single_key.this_coord; // cigar/orientation modified pos\n\n                // put in singles hash for checking against non paired reads\n                k = kh_put(reads, single_hash, single_key, &ret);\n\n                if (ret > 0) { // new\n                    // add to single duplicate hash\n                    bp = &kh_val(single_hash, k);\n                    bp->p = in_read;\n                    in_read->single_key = single_key;\n                } else if (ret == 0) { // exists\n                    // look at singles only for duplication marking\n                    bp = &kh_val(single_hash, k);\n\n                    if (!has_mate(bp->p->b)) {\n                       // singleton will always be marked duplicate even if\n                       // scores more than one read of the pair\n                        bam1_t *dup = bp->p->b;\n\n                        if (param->check_chain) {\n                            in_read->duplicate = bp->p;\n                            bp->p->original = in_read;\n                        }\n\n                        bp->p = in_read;\n                        bp->p->dc += 1;\n\n                        if (mark_duplicates(param, dup_hash, bp->p->b, dup, in_read->read_group, &stats->single_optical, &opt_warnings))\n                            goto fail;\n\n                        stats->single_dup++;\n                    }\n                } else {\n                    print_error(\"markdup\", \"error, single hashing failure for paired read.\\n\");\n                    goto fail;\n                }\n\n                // now do the pair\n                k = kh_put(reads, pair_hash, pair_key, &ret);\n\n                if (ret > 0) { // new\n                    // add to the pair hash\n                    bp = &kh_val(pair_hash, k);\n                    bp->p = in_read;\n                    in_read->pair_key = pair_key;\n                } else if (ret == 0) {\n                    int64_t old_score, new_score, tie_add = 0;\n                    bam1_t *dup = NULL;\n\n                    bp = &kh_val(pair_hash, k);\n\n                    if ((bp->p->b->core.flag & BAM_FQCFAIL) != (in_read->b->core.flag & BAM_FQCFAIL)) {\n                        if (bp->p->b->core.flag & BAM_FQCFAIL) {\n                            old_score = 0;\n                            new_score = 1;\n                        } else {\n                            old_score = 1;\n                            new_score = 0;\n                        }\n                    } else {\n                        if ((mate_tmp = get_mate_score(bp->p->b)) == -1) {\n                            print_error(\"markdup\", \"error, no ms score tag. Please run samtools fixmate on file first.\\n\");\n                            goto fail;\n                        } else {\n                            old_score = calc_score(bp->p->b) + mate_tmp;\n                        }\n\n                        if ((mate_tmp = get_mate_score(in_read->b)) == -1) {\n                            print_error(\"markdup\", \"error, no ms score tag. Please run samtools fixmate on file first.\\n\");\n                            goto fail;\n                        } else {\n                            new_score = calc_score(in_read->b) + mate_tmp;\n                        }\n                    }\n\n                    // choose the highest score as the original\n                    // and add it to the pair hash, mark the other as duplicate\n\n                    if (new_score == old_score) {\n                        if (strcmp(bam_get_qname(in_read->b), bam_get_qname(bp->p->b)) < 0) {\n                            tie_add = 1;\n                        } else {\n                            tie_add = -1;\n                        }\n                    }\n\n                    if (new_score + tie_add > old_score) { // swap reads\n                        dup = bp->p->b;\n                        in_read->dc += bp->p->dc;\n\n                        if (param->check_chain) {\n\n                            if (in_read->duplicate) {\n                                read_queue_t *current = in_read->duplicate;\n\n                                while (current->duplicate) {\n                                    current = current->duplicate;\n                                }\n\n                                current->duplicate = bp->p;\n                            } else {\n                                in_read->duplicate = bp->p;\n                            }\n\n                            bp->p->original = in_read;\n                        }\n\n                        bp->p = in_read;\n                    } else {\n                        if (param->check_chain) {\n                            if (bp->p->duplicate) {\n                                if (in_read->duplicate) {\n                                    read_queue_t *current = bp->p->duplicate;\n\n                                    while (current->duplicate) {\n                                        current = current->duplicate;\n                                    }\n\n                                    current->duplicate = in_read->duplicate;\n                                }\n\n                                in_read->duplicate = bp->p->duplicate;\n                            }\n\n                            bp->p->duplicate = in_read;\n                            in_read->original = bp->p;\n                        }\n\n                        dup = in_read->b;\n                        bp->p->dc += 1;\n                    }\n\n                    if (mark_duplicates(param, dup_hash, bp->p->b, dup, in_read->read_group, &stats->optical, &opt_warnings))\n                        goto fail;\n\n                    stats->duplicate++;\n                } else {\n                    print_error(\"markdup\", \"error, pair hashing failure.\\n\");\n                    goto fail;\n                }\n            } else { // do the single (or effectively single) reads\n                int ret;\n                key_data_t single_key;\n                in_hash_t *bp;\n\n                make_single_key(param, &single_key, in_read->b, in_read->read_group, &bc_warnings);\n\n                stats->single++;\n                in_read->pos = single_key.this_coord; // cigar/orientation modified pos\n\n                k = kh_put(reads, single_hash, single_key, &ret);\n\n                if (ret > 0) { // new\n                    bp = &kh_val(single_hash, k);\n                    bp->p = in_read;\n                    in_read->single_key = single_key;\n                } else if (ret == 0) { // exists\n                    bp = &kh_val(single_hash, k);\n\n                    if (has_mate(bp->p->b)) {\n                        // if matched against one of a pair just mark as duplicate\n\n                        if (param->check_chain) {\n                            if (bp->p->duplicate) {\n                                in_read->duplicate = bp->p->duplicate;\n                            }\n\n                            bp->p->duplicate = in_read;\n                            in_read->original = bp->p;\n                        }\n\n                        bp->p->dc += 1;\n\n                        if (mark_duplicates(param, dup_hash, bp->p->b, in_read->b, in_read->read_group, &stats->single_optical, &opt_warnings))\n                            goto fail;\n\n                    } else {\n                        int64_t old_score, new_score;\n                        bam1_t *dup = NULL;\n\n                        old_score = calc_score(bp->p->b);\n                        new_score = calc_score(in_read->b);\n\n                        // choose the highest score as the original, add it\n                        // to the single hash and mark the other as duplicate\n                        if (new_score > old_score) { // swap reads\n                            dup = bp->p->b;\n                            in_read->dc += bp->p->dc;\n\n                            if (param->check_chain) {\n                                in_read->duplicate = bp->p;\n                                bp->p->original = in_read;\n                            }\n\n                            bp->p = in_read;\n                        } else {\n                            if (param->check_chain) {\n                                if (bp->p->duplicate) {\n                                    in_read->duplicate = bp->p->duplicate;\n                                }\n\n                                bp->p->duplicate = in_read;\n                                in_read->original = bp->p;\n                            }\n\n                            bp->p->dc += 1;\n                            dup = in_read->b;\n                        }\n\n                        if (mark_duplicates(param, dup_hash, bp->p->b, dup, in_read->read_group, &stats->single_optical, &opt_warnings))\n                            goto fail;\n                    }\n\n                    stats->single_dup++;\n                } else {\n                    print_error(\"markdup\", \"error, single hashing failure for single read.\\n\");\n                    goto fail;\n                }\n            }\n        } else {\n            stats->excluded++;\n        }\n\n        // loop through the stored reads and write out those we\n        // no longer need\n        rq = kl_begin(read_buffer);\n        while (rq != kl_end(read_buffer)) {\n            in_read = &kl_val(rq);\n\n            /* keep a moving window of reads based on coordinates and max read length.  Any unaligned reads\n               should just be written as they cannot be matched as duplicates. */\n            if (in_read->pos + param->max_length > prev_coord && in_read->b->core.tid == prev_tid && (prev_tid != -1 || prev_coord != -1)) {\n                break;\n            }\n\n            if (param->check_chain && !in_read->dup_checked && (in_read->original || in_read->duplicate)) {\n                if (find_duplicate_chains(param, in_read, dup_hash, &dup_list, &opt_warnings, stat_array)) {\n                    print_error(\"markdup\", \"error, duplicate checking failed.\\n\");\n                    goto fail;\n                }\n            }\n\n            if (!param->remove_dups || !(in_read->b->core.flag & BAM_FDUP)) {\n                if (param->dc && !(in_read->b->core.flag & BAM_FDUP)) {\n                    bam_aux_update_int(in_read->b, \"dc\", in_read->dc);\n                }\n                if (param->supp) {\n                    if (tmp_file_write(&temp, in_read->b)) {\n                        print_error(\"markdup\", \"error, writing temp output failed.\\n\");\n                        goto fail;\n                    }\n                } else {\n                    if (sam_write1(param->out, header, in_read->b) < 0) {\n                        print_error(\"markdup\", \"error, writing output failed.\\n\");\n                        goto fail;\n                    }\n                }\n\n                stat_array[in_read->read_group].writing++;\n            }\n\n            // remove from hash\n            if (in_read->pair_key.single == 0) {\n                k = kh_get(reads, pair_hash, in_read->pair_key);\n                kh_del(reads, pair_hash, k);\n            }\n\n            if (in_read->single_key.single == 1) {\n                k = kh_get(reads, single_hash, in_read->single_key);\n                kh_del(reads, single_hash, k);\n            }\n\n            kl_shift(read_queue, read_buffer, NULL);\n            bam_destroy1(in_read->b);\n            rq = kl_begin(read_buffer);\n        }\n\n        // set the next one up for reading\n        in_read = kl_pushp(read_queue, read_buffer);\n        if (!in_read) {\n            print_error(\"markdup\", \"error, unable to allocate memory for read in queue.\\n\");\n            goto fail;\n        }\n\n        if ((in_read->b = bam_init1()) == NULL) {\n            print_error(\"markdup\", \"error, unable to allocate memory for alignment.\\n\");\n            goto fail;\n        }\n    }\n\n    if (ret < -1) {\n        print_error(\"markdup\", \"error, truncated input file.\\n\");\n        goto fail;\n    }\n\n    // write out the end of the list\n    rq = kl_begin(read_buffer);\n    while (rq != kl_end(read_buffer)) {\n        in_read = &kl_val(rq);\n\n        if (bam_get_qname(in_read->b)) { // last entry will be blank\n            if (param->check_chain && !in_read->dup_checked && (in_read->original || in_read->duplicate)) {\n                if (find_duplicate_chains(param, in_read, dup_hash, &dup_list, &opt_warnings, stat_array)) {\n                    print_error(\"markdup\", \"error, duplicate checking failed.\\n\");\n                    goto fail;\n                }\n            }\n\n            if (!param->remove_dups || !(in_read->b->core.flag & BAM_FDUP)) {\n                if (param->dc && !(in_read->b->core.flag & BAM_FDUP)) {\n                    bam_aux_update_int(in_read->b, \"dc\",  in_read->dc);\n                }\n\n                if (param->supp) {\n                    if (tmp_file_write(&temp, in_read->b)) {\n                        print_error(\"markdup\", \"error, writing temp output failed on final write.\\n\");\n                        goto fail;\n                    }\n                } else {\n                    if (param->dc && !(in_read->b->core.flag & BAM_FDUP)) {\n                        bam_aux_update_int(in_read->b, \"dc\", in_read->dc);\n                    }\n\n                    if (sam_write1(param->out, header, in_read->b) < 0) {\n                        print_error(\"markdup\", \"error, writing output failed on final write.\\n\");\n                        goto fail;\n                    }\n                }\n\n                stat_array[in_read->read_group].writing++;\n            }\n        }\n\n        kl_shift(read_queue, read_buffer, NULL);\n        bam_destroy1(in_read->b);\n        rq = kl_begin(read_buffer);\n    }\n\n    if (param->supp) {\n        bam1_t *b;\n\n        if (tmp_file_end_write(&temp)) {\n            print_error(\"markdup\", \"error, unable to end tmp writing.\\n\");\n            goto fail;\n        }\n\n        // read data from temp file and mark duplicate supplementary alignments\n\n        if (tmp_file_begin_read(&temp)) {\n            goto fail;\n        }\n\n        b = bam_init1();\n\n        while ((ret = tmp_file_read(&temp, b)) > 0) {\n\n            if ((b->core.flag & BAM_FSUPPLEMENTARY) || (b->core.flag & BAM_FUNMAP) || (b->core.flag & BAM_FSECONDARY)) {\n\n                k = kh_get(duplicates, dup_hash, bam_get_qname(b));\n\n                if (k != kh_end(dup_hash)) {\n\n                    b->core.flag  |= BAM_FDUP;\n                    stat_array[kh_val(dup_hash, k).read_group].np_duplicate++;\n\n                    if (param->tag && kh_val(dup_hash, k).name) {\n                        if (bam_aux_update_str(b, \"do\", strlen(kh_val(dup_hash, k).name) + 1, (char*)kh_val(dup_hash, k).name)) {\n                            print_error(\"markdup\", \"error, unable to append supplementary 'do' tag.\\n\");\n                            goto fail;\n                        }\n                    }\n\n                    if (param->opt_dist) {\n                        if (kh_val(dup_hash, k).type) {\n                            bam_aux_update_str(b, \"dt\", 3, \"SQ\");\n                            stat_array[kh_val(dup_hash, k).read_group].np_opt_duplicate++;\n                        } else {\n                            bam_aux_update_str(b, \"dt\", 3, \"LB\");\n                        }\n                    }\n                }\n            }\n\n            if (!param->remove_dups || !(b->core.flag & BAM_FDUP)) {\n                if (param->dc && (b->core.flag & BAM_FDUP)) {\n                    uint8_t* data = bam_aux_get(b, \"dc\");\n                    if(data) bam_aux_del(b, data);\n                }\n                if (sam_write1(param->out, header, b) < 0) {\n                    print_error(\"markdup\", \"error, writing final output failed.\\n\");\n                    goto fail;\n                }\n            }\n        }\n\n        if (ret == -1) {\n            print_error(\"markdup\", \"error, failed to read tmp file.\\n\");\n            goto fail;\n        }\n\n        for (k = kh_begin(dup_hash); k != kh_end(dup_hash); ++k) {\n            if (kh_exist(dup_hash, k)) {\n                free(kh_val(dup_hash, k).name);\n                free((char *)kh_key(dup_hash, k));\n                kh_key(dup_hash, k) = NULL;\n            }\n        }\n\n        tmp_file_destroy(&temp);\n        bam_destroy1(b);\n    }\n\n    if (opt_warnings) {\n        print_error(\"markdup\", \"warning, number of failed attempts to get coordinates from read names = %ld\\n\",\n                        opt_warnings);\n    }\n\n    if (bc_warnings) {\n        print_error(\"markdup\", \"warning, number of failed attempts to get barcodes = %ld\\n\", bc_warnings);\n    }\n\n    if (param->do_stats) {\n        FILE *fp;\n        int file_open = 0;\n        stats_block_t total;\n        int i;\n\n        if (param->stats_file) {\n            if (NULL == (fp = fopen(param->stats_file, \"w\"))) {\n                print_error(\"markdup\", \"warning, cannot write stats to %s.\\n\", param->stats_file);\n                fp = stderr;\n            } else {\n                file_open = 1;\n            }\n        } else {\n            fp = stderr;\n        }\n\n        total = stat_array[0];\n\n        if (param->read_groups) {\n            for (i = 1; i <= num_groups; i++) {\n                total.reading += stat_array[i].reading;\n                total.writing += stat_array[i].writing;\n                total.excluded += stat_array[i].excluded;\n                total.duplicate += stat_array[i].duplicate;\n                total.single += stat_array[i].single;\n                total.pair += stat_array[i].pair;\n                total.single_dup += stat_array[i].single_dup;\n                total.examined += stat_array[i].examined;\n                total.optical += stat_array[i].optical;\n                total.single_optical += stat_array[i].single_optical;\n                total.np_duplicate += stat_array[i].np_duplicate;\n                total.np_opt_duplicate += stat_array[i].np_opt_duplicate;\n            }\n        }\n\n        if (!param->json) {\n            write_stats(fp, \"COMMAND: \", param->arg_list, &total);\n            fprintf(fp, \"\\n\");\n\n            if (param->read_groups) {\n                if (stat_array[0].reading) {\n                    write_stats(fp, \"READ GROUP: \", \"ungrouped\", stat_array);\n                    fprintf(fp, \"\\n\");\n                }\n\n                for (i = 0; i < num_groups; i++) {\n                    write_stats(fp, \"READ GROUP: \", sam_hdr_line_name(header, \"RG\", i), stat_array + i + 1);\n                    fprintf(fp, \"\\n\");\n                }\n            }\n        } else {\n            char space4[]  = \"    \";\n            char space8[]  = \"        \";\n            char space12[] = \"            \";\n\n            fprintf(fp, \"{\\n\");\n            fprintf(fp, \"%s\\\"COMMAND\\\": \\\"%s\\\",\\n\", space4, param->arg_list);\n            write_json_stats(fp, space4, NULL, &total, param->read_groups ? \",\\n\" : \"\\n\");\n\n            if (param->read_groups) {\n                fprintf(fp, \"%s\\\"READ GROUPS\\\": [\\n\", space4);\n\n                if (stat_array[0].reading) {\n                    fprintf(fp, \"%s{\\n\", space8);\n                    write_json_stats(fp, space12, \"ungrouped\", stat_array, \"\\n\");\n                    fprintf(fp, \"%s},\\n\", space8);\n                }\n\n                for (i = 0; i < num_groups; i++) {\n                    fprintf(fp, \"%s{\\n\", space8);\n\n                    write_json_stats(fp, space12,  sam_hdr_line_name(header, \"RG\", i), stat_array + i + 1, \"\\n\");\n\n                    if (i < num_groups -1 ) {\n                        fprintf(fp, \"%s},\\n\", space8);\n                    } else {\n                        fprintf(fp, \"%s}\\n\", space8);\n                    }\n                }\n\n                fprintf(fp, \"%s]\\n\", space4);\n            }\n\n            fprintf(fp, \"}\\n\");\n        }\n\n        if (file_open) {\n            fclose(fp);\n        }\n    }\n\n    if (param->write_index) {\n        if (sam_idx_save(param->out) < 0) {\n            print_error_errno(\"markdup\", \"error, writing index failed\");\n            goto fail;\n        }\n    }\n\n    if (param->check_chain && (param->tag || param->opt_dist))\n        free(dup_list.c);\n\n    free(idx_fn);\n    free(stat_array);\n    kh_destroy(reads, pair_hash);\n    kh_destroy(reads, single_hash);\n    kl_destroy(read_queue, read_buffer);\n    kh_destroy(duplicates, dup_hash);\n    kh_destroy(read_groups, rg_hash);\n    sam_hdr_destroy(header);\n\n    return 0;\n\n fail:\n    for (rq = kl_begin(read_buffer); rq != kl_end(read_buffer); rq = kl_next(rq))\n        bam_destroy1(kl_val(rq).b);\n    kl_destroy(read_queue, read_buffer);\n\n    for (k = kh_begin(dup_hash); k != kh_end(dup_hash); ++k) {\n        if (kh_exist(dup_hash, k)) {\n            free((char *)kh_key(dup_hash, k));\n        }\n    }\n    kh_destroy(duplicates, dup_hash);\n    kh_destroy(read_groups, rg_hash);\n\n    if (param->check_chain && (param->tag || param->opt_dist))\n        free(dup_list.c);\n\n    free(idx_fn);\n    free(stat_array);\n    kh_destroy(reads, pair_hash);\n    kh_destroy(reads, single_hash);\n    sam_hdr_destroy(header);\n    return 1;\n}\n\n\nstatic int markdup_usage(void) {\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"Usage:  samtools markdup <input.bam> <output.bam>\\n\\n\");\n    fprintf(stderr, \"Option: \\n\");\n    fprintf(stderr, \"  -r                 Remove duplicate reads\\n\");\n    fprintf(stderr, \"  -l INT             Max read length (default 300 bases)\\n\");\n    fprintf(stderr, \"  -S                 Mark supplementary alignments of duplicates as duplicates (slower).\\n\");\n    fprintf(stderr, \"  -s                 Report stats.\\n\");\n    fprintf(stderr, \"  -f NAME            Write stats to named file.  Implies -s.\\n\");\n    fprintf(stderr, \"  --json             Output stats in JSON.  Also implies -s\\n\");\n    fprintf(stderr, \"  -T PREFIX          Write temporary files to PREFIX.samtools.nnnn.nnnn.tmp.\\n\");\n    fprintf(stderr, \"  -d INT             Optical distance (if set, marks with dt tag)\\n\");\n    fprintf(stderr, \"  -c                 Clear previous duplicate settings and tags.\\n\");\n    fprintf(stderr, \"  -m --mode TYPE     Duplicate decision method for paired reads.\\n\"\n                    \"                     TYPE = t measure positions based on template start/end (default).\\n\"\n                    \"                            s measure positions based on sequence start.\\n\");\n    fprintf(stderr, \"  -u                 Output uncompressed data\\n\");\n    fprintf(stderr, \"  --include-fails    Include quality check failed reads.\\n\");\n    fprintf(stderr, \"  --no-PG            Do not add a PG line\\n\");\n    fprintf(stderr, \"  --no-multi-dup     Reduced duplicates of duplicates checking.\\n\");\n    fprintf(stderr, \"  --read-coords STR  Regex for coords from read name.\\n\");\n    fprintf(stderr, \"  --coords-order STR Order of regex elements. txy (default).  With t being a part of\\n\"\n                    \"                     the read names that must be equal and x/y being coordinates.\\n\");\n    fprintf(stderr, \"  --barcode-tag STR  Use barcode a tag that duplicates much match.\\n\");\n    fprintf(stderr, \"  --barcode-name     Use the UMI/barcode in the read name (eigth colon delimited part).\\n\");\n    fprintf(stderr, \"  --barcode-rgx STR  Regex for barcode in the readname (alternative to --barcode-name).\\n\");\n    fprintf(stderr, \"  --use-read-groups  Use the read group tags in duplicate matching.\\n\");\n    fprintf(stderr, \"  -t                 Mark primary duplicates with the name of the original in a \\'do\\' tag.\"\n                                        \" Mainly for information and debugging.\\n\");\n    fprintf(stderr, \"  --duplicate-count  Record the original primary read duplication count(include itself) in a \\'dc\\' tag.\\n\");\n\n    sam_global_opt_help(stderr, \"-.O..@..\");\n\n    fprintf(stderr, \"\\nThe input file must be coordinate sorted and must have gone\"\n                     \" through fixmates with the mate scoring option on.\\n\");\n\n    return 1;\n}\n\n\nint bam_markdup(int argc, char **argv) {\n    int c, ret, bc_name = 0;\n    char wmode[4] = {'w', 0, 0, 0};\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    htsThreadPool p = {NULL, 0};\n    kstring_t tmpprefix = {0, 0, NULL};\n    struct stat st;\n    unsigned int t;\n    char *regex = NULL, *bc_regex = NULL;\n    char *regex_order = \"txy\";\n    md_param_t param = {NULL, NULL, NULL, 0, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                        1, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, NULL, 0, 0, 0};\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', 0, 0, '@'),\n        {\"include-fails\", no_argument, NULL, 1001},\n        {\"no-PG\", no_argument, NULL, 1002},\n        {\"mode\", required_argument, NULL, 'm'},\n        {\"no-multi-dup\", no_argument, NULL, 1003},\n        {\"read-coords\", required_argument, NULL, 1004},\n        {\"coords-order\", required_argument, NULL, 1005},\n        {\"barcode-tag\", required_argument, NULL, 1006},\n        {\"barcode-name\", no_argument, NULL, 1007},\n        {\"barcode-rgx\", required_argument, NULL, 1008},\n        {\"use-read-groups\", no_argument, NULL, 1009},\n        {\"json\", no_argument, NULL, 1010},\n        {\"duplicate-count\", no_argument, NULL, 1011},\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"rsl:StT:O:@:f:d:cm:u\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'r': param.remove_dups = 1; break;\n            case 'l': param.max_length = atoi(optarg); break;\n            case 's': param.do_stats = 1; break;\n            case 'T': kputs(optarg, &tmpprefix); break;\n            case 'S': param.supp = 1; break;\n            case 't': param.tag = 1; break;\n            case 'f': param.stats_file = optarg; param.do_stats = 1; break;\n            case 'd': param.opt_dist = atoi(optarg); break;\n            case 'c': param.clear = 1; break;\n            case 'm':\n                if (strcmp(optarg, \"t\") == 0) {\n                    param.mode = MD_MODE_TEMPLATE;\n                } else if (strcmp(optarg, \"s\") == 0) {\n                    param.mode = MD_MODE_SEQUENCE;\n                } else {\n                    print_error(\"markdup\", \"error, unknown mode '%s'.\\n\", optarg);\n                    return markdup_usage();\n                }\n\n                break;\n            case 'u': wmode[1] = '0'; break;\n            case 1001: param.include_fails = 1; break;\n            case 1002: param.no_pg = 1; break;\n            case 1003: param.check_chain = 0; break;\n            case 1004: regex = optarg; break;\n            case 1005: regex_order = optarg; break;\n            case 1006: param.barcode = optarg; break;\n            case 1007: bc_name = 1; break;\n            case 1008: bc_name = 1, bc_regex = optarg; break;\n            case 1009: param.read_groups = 1; break;\n            case 1010: param.json = 1; param.do_stats = 1; break;\n            case 1011: param.dc = 1; break;\n            default: if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n            case '?': return markdup_usage();\n        }\n    }\n\n    if (optind + 2 > argc)\n        return markdup_usage();\n\n    if (param.barcode && bc_name) {\n        print_error(\"markdup\", \"error, cannot specify --barcode-tag and \"\n                        \"--barcode-name (or --barcode-rgx) at same time.\\n\");\n        return 1;\n    }\n\n    if (param.opt_dist < 0) param.opt_dist = 0;\n    if (param.max_length < 0) param.max_length = 300;\n\n    if (regex) {\n        int result;\n\n        // set the order the elements of the regex are assigned to.\n        // x and y being coordinates, t being any other important part of the read\n        // e.g. tile and lane\n        // x and y order does not matter as long as it is consistent\n\n        if ((strncmp(regex_order, \"txy\", 3) == 0) || (strncmp(regex_order, \"tyx\", 3) == 0)) {\n            param.rgx_t = 1;\n            param.rgx_x = 2;\n            param.rgx_y = 3;\n        } else if ((strncmp(regex_order, \"xyt\", 3) == 0) || (strncmp(regex_order, \"yxt\", 3) == 0)) {\n            param.rgx_x = 1;\n            param.rgx_y = 2;\n            param.rgx_t = 3;\n        } else if ((strncmp(regex_order, \"xty\", 3) == 0) || (strncmp(regex_order, \"ytx\", 3) == 0)) {\n            param.rgx_x = 1;\n            param.rgx_t = 2;\n            param.rgx_y = 3;\n        } else if ((strncmp(regex_order, \"xy\", 2) == 0) || (strncmp(regex_order, \"yx\", 2) == 0)) {\n            param.rgx_x = 1;\n            param.rgx_y = 2;\n            param.rgx_t = 0;\n        } else {\n            print_error(\"markdup\", \"error,  could not recognise regex coordinate order \\\"%s\\\".\\n\", regex_order);\n            return 1;\n        }\n\n        if ((param.rgx = malloc(sizeof(regex_t))) == NULL) {\n            print_error(\"markdup\", \"error,  could not allocate memory for regex.\\n\");\n            return 1;\n        }\n\n        if ((result = regcomp(param.rgx, regex, REG_EXTENDED))) {\n            char err_msg[256];\n\n            regerror(result, param.rgx, err_msg, 256);\n            print_error(\"markdup\", \"error, regex fail \\\"%s\\\"\\n\", err_msg);\n            free(param.rgx);\n            return 1;\n        }\n    }\n\n    if (bc_name) {\n        int result;\n\n        /* From Illumina UMI documentation: \"The UMI sequence is located in the\n           eighth colon-delimited field of the read name (QNAME)\". */\n        char *rgx = \"[0-9A-Za-z]+:[0-9A-Za-z]+:[0-9A-Za-z]+:[0-9A-Za-z]+:[0-9A-Za-z]+:[0-9A-Za-z]+:[0-9A-Za-z]+:([!-?A-~]+)\";\n\n        if ((param.bc_rgx = malloc(sizeof(regex_t))) == NULL) {\n            print_error(\"markdup\", \"error,  could not allocate memory for barcode regex.\\n\");\n            return 1;\n        }\n\n        if (bc_regex) {\n            rgx = bc_regex;\n        }\n\n        if ((result = regcomp(param.bc_rgx, rgx, REG_EXTENDED))) {\n            char err_msg[256];\n\n            regerror(result, param.bc_rgx, err_msg, 256);\n            print_error(\"markdup\", \"error, barcode regex fail \\\"%s\\\"\\n\", err_msg);\n            free(param.bc_rgx);\n            return 1;\n        }\n    }\n\n    param.in = sam_open_format(argv[optind], \"r\", &ga.in);\n\n    if (!param.in) {\n        print_error_errno(\"markdup\", \"error, failed to open \\\"%s\\\" for input\", argv[optind]);\n        return 1;\n    }\n\n    strcat(wmode, \"b\"); // default if unknown suffix\n    sam_open_mode(wmode + strlen(wmode)-1, argv[optind + 1], NULL);\n    param.out = sam_open_format(argv[optind + 1], wmode, &ga.out);\n\n    if (!param.out) {\n        print_error_errno(\"markdup\", \"error, failed to open \\\"%s\\\" for output\", argv[optind + 1]);\n        return 1;\n    }\n\n    if (ga.nthreads > 0)  {\n        if (!(p.pool = hts_tpool_init(ga.nthreads))) {\n            print_error(\"markdup\", \"error creating thread pool.\\n\");\n            return 1;\n        }\n\n        hts_set_opt(param.in,  HTS_OPT_THREAD_POOL, &p);\n        hts_set_opt(param.out, HTS_OPT_THREAD_POOL, &p);\n    }\n\n    // actual stuff happens here\n\n    // we need temp files so fix up the name here\n    if (tmpprefix.l == 0) {\n\n        if (strcmp(argv[optind + 1], \"-\") != 0)\n            ksprintf(&tmpprefix, \"%s.\", argv[optind + 1]);\n        else\n            kputc('.', &tmpprefix);\n    }\n\n    if (stat(tmpprefix.s, &st) == 0 && S_ISDIR(st.st_mode)) {\n        if (tmpprefix.s[tmpprefix.l-1] != '/') kputc('/', &tmpprefix);\n    }\n\n    t = ((unsigned) time(NULL)) ^ ((unsigned) clock());\n    ksprintf(&tmpprefix, \"samtools.%d.%u.tmp\", (int) getpid(), t % 10000);\n    param.prefix = tmpprefix.s;\n\n    param.arg_list = stringify_argv(argc + 1, argv - 1);\n    param.write_index = ga.write_index;\n    param.out_fn = argv[optind + 1];\n\n    ret = bam_mark_duplicates(&param);\n\n    sam_close(param.in);\n\n    if (sam_close(param.out) < 0) {\n        print_error(\"markdup\", \"error closing output file.\\n\");\n        ret = 1;\n    }\n\n    if (p.pool) hts_tpool_destroy(p.pool);\n\n    if (param.rgx) {\n        regfree(param.rgx);\n        free(param.rgx);\n    }\n\n    if (param.bc_rgx) {\n        regfree(param.bc_rgx);\n        free(param.bc_rgx);\n    }\n\n    free(param.arg_list);\n    free(tmpprefix.s);\n    sam_global_args_free(&ga);\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_mate.c",
          "type": "blob",
          "size": 42.1884765625,
          "content": "/*  bam_mate.c -- fix mate pairing information and clean up flags.\n\n    Copyright (C) 2009, 2011-2017, 2019, 2022, 2024 Genome Research Ltd.\n    Portions copyright (C) 2011 Broad Institute.\n    Portions copyright (C) 2012 Peter Cock, The James Hutton Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"htslib/thread_pool.h\"\n#include \"sam_opts.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/sam.h\"\n#include \"samtools.h\"\n\n\n#define MD_MIN_QUALITY 15\n\n/*\n * This function calculates ct tag for two bams, it assumes they are from the same template and\n * writes the tag to the first read in position terms.\n */\nstatic void bam_template_cigar(bam1_t *b1, bam1_t *b2, kstring_t *str)\n{\n    bam1_t *swap;\n    int i;\n    hts_pos_t end;\n    uint32_t *cigar;\n    str->l = 0;\n    if (b1->core.tid != b2->core.tid || b1->core.tid < 0 || b1->core.pos < 0 || b2->core.pos < 0 || b1->core.flag&BAM_FUNMAP || b2->core.flag&BAM_FUNMAP) return; // coordinateless or not on the same chr; skip\n    if (b1->core.pos > b2->core.pos) swap = b1, b1 = b2, b2 = swap; // make sure b1 has a smaller coordinate\n    kputc((b1->core.flag & BAM_FREAD1)? '1' : '2', str); // segment index\n    kputc((b1->core.flag & BAM_FREVERSE)? 'R' : 'F', str); // strand\n    for (i = 0, cigar = bam_get_cigar(b1); i < b1->core.n_cigar; ++i) {\n        kputw(bam_cigar_oplen(cigar[i]), str);\n        kputc(bam_cigar_opchr(cigar[i]), str);\n    }\n    end = bam_endpos(b1);\n    kputw(b2->core.pos - end, str);\n    kputc('T', str);\n    kputc((b2->core.flag & BAM_FREAD1)? '1' : '2', str); // segment index\n    kputc((b2->core.flag & BAM_FREVERSE)? 'R' : 'F', str); // strand\n    for (i = 0, cigar = bam_get_cigar(b2); i < b2->core.n_cigar; ++i) {\n        kputw(bam_cigar_oplen(cigar[i]), str);\n        kputc(bam_cigar_opchr(cigar[i]), str);\n    }\n\n    uint8_t* data;\n    if ((data = bam_aux_get(b1,\"ct\")) != NULL) bam_aux_del(b1, data);\n    if ((data = bam_aux_get(b2,\"ct\")) != NULL) bam_aux_del(b2, data);\n\n    bam_aux_append(b1, \"ct\", 'Z', str->l+1, (uint8_t*)str->s);\n}\n\n/*\n * What This Program is Supposed To Do:\n * Fill in mate coordinates, ISIZE and mate related flags from a name-sorted\n * alignment.\n *\n * How We Handle Input\n *\n * Secondary and supplementary Reads:\n * -write to output unchanged\n * All Reads:\n * -if pos == 0 (1 based), tid == -1 set UNMAPPED flag\n * single Reads:\n * -if pos == 0 (1 based), tid == -1, or UNMAPPED then set UNMAPPED, pos = 0,\n *  tid = -1\n * -clear bad flags (MREVERSE, PROPER_PAIR)\n * -set mpos = 0 (1 based), mtid = -1 and isize = 0\n * -write to output\n * Paired Reads:\n * -if read is unmapped and mate is not, set pos and tid to equal that of mate\n * -sync mate flags (MREVERSE, MUNMAPPED), mpos, mtid\n * -recalculate ISIZE if possible, otherwise set it to 0\n * -optionally clear PROPER_PAIR flag from reads where mapping or orientation\n *  indicate this is not possible (Illumina orientation only)\n * -calculate ct and apply to lowest positioned read\n * -write to output\n * Limitations\n * -Does not handle tandem reads\n * -Should mark supplementary reads the same as primary.\n * Notes\n * -CT definition appears to be something else in spec, this was in here before\n *  I started tampering with it, anyone know what is going on here? To work\n *  around this I have demoted the CT this tool generates to ct.\n */\n\nstatic void sync_unmapped_pos_inner(bam1_t* src, bam1_t* dest) {\n    if ((dest->core.flag & BAM_FUNMAP) && !(src->core.flag & BAM_FUNMAP)) {\n        // Set unmapped read's RNAME and POS to those of its mapped mate\n        // (recommended best practice, ensures if coord sort will be together)\n        dest->core.tid = src->core.tid;\n        dest->core.pos = src->core.pos;\n    }\n}\n\nstatic void sync_mate_inner(bam1_t* src, bam1_t* dest)\n{\n    // sync mate pos information\n    dest->core.mtid = src->core.tid; dest->core.mpos = src->core.pos;\n    // sync flag info\n    if (src->core.flag&BAM_FREVERSE)\n        dest->core.flag |= BAM_FMREVERSE;\n    else\n        dest->core.flag &= ~BAM_FMREVERSE;\n    if (src->core.flag & BAM_FUNMAP) {\n        dest->core.flag |= BAM_FMUNMAP;\n    }\n}\n\n// Is it plausible that these reads are properly paired?\n// Can't really give definitive answer without checking isize\nstatic bool plausibly_properly_paired(bam1_t* a, bam1_t* b)\n{\n    if ((a->core.flag & BAM_FUNMAP) || (b->core.flag & BAM_FUNMAP)) return false;\n    assert(a->core.tid >= 0); // This should never happen if FUNMAP is set correctly\n\n    if (a->core.tid != b->core.tid) return false;\n\n    bam1_t* first = a;\n    bam1_t* second = b;\n    hts_pos_t a_pos = a->core.flag&BAM_FREVERSE ? bam_endpos(a) : a->core.pos;\n    hts_pos_t  b_pos = b->core.flag&BAM_FREVERSE ? bam_endpos(b) : b->core.pos;\n    if (a_pos > b_pos) {\n        first = b;\n        second = a;\n    } else {\n        first = a;\n        second = b;\n    }\n\n    if (!(first->core.flag&BAM_FREVERSE) && (second->core.flag&BAM_FREVERSE))\n        return true;\n    else\n        return false;\n}\n\n// Returns 0 on success, -1 on failure.\nstatic int bam_format_cigar(const bam1_t* b, kstring_t* str)\n{\n    // An empty cigar is a special case return \"*\" rather than \"\"\n    if (b->core.n_cigar == 0) {\n        return (kputc('*', str) == EOF) ? -1 : 0;\n    }\n\n    const uint32_t *cigar = bam_get_cigar(b);\n    uint32_t i;\n\n    for (i = 0; i < b->core.n_cigar; ++i) {\n        if (kputw(bam_cigar_oplen(cigar[i]), str) == EOF) return -1;\n        if (kputc(bam_cigar_opchr(cigar[i]), str) == EOF) return -1;\n    }\n\n    return 0;\n}\n\n// Returns 0 on success, -1 on failure.\nstatic int sync_mq_mc(bam1_t* src, bam1_t* dest)\n{\n    if ( (src->core.flag & BAM_FUNMAP) == 0 ) { // If mapped\n        // Copy Mate Mapping Quality\n        uint32_t mq = src->core.qual;\n        uint8_t* data;\n        if ((data = bam_aux_get(dest,\"MQ\")) != NULL) {\n            bam_aux_del(dest, data);\n        }\n\n        bam_aux_append(dest, \"MQ\", 'i', sizeof(uint32_t), (uint8_t*)&mq);\n    }\n    // Copy mate cigar if either read is mapped\n    if ( (src->core.flag & BAM_FUNMAP) == 0 || (dest->core.flag & BAM_FUNMAP) == 0 ) {\n        uint8_t* data_mc;\n        if ((data_mc = bam_aux_get(dest,\"MC\")) != NULL) {\n            bam_aux_del(dest, data_mc);\n        }\n\n        // Convert cigar to string\n        kstring_t mc = { 0, 0, NULL };\n        if (bam_format_cigar(src, &mc) < 0) return -1;\n\n        bam_aux_append(dest, \"MC\", 'Z', ks_len(&mc)+1, (uint8_t*)ks_str(&mc));\n        free(mc.s);\n    }\n    return 0;\n}\n\n// Copy flags.\n// Returns 0 on success, -1 on failure.\nstatic int sync_mate(bam1_t* a, bam1_t* b)\n{\n    sync_unmapped_pos_inner(a,b);\n    sync_unmapped_pos_inner(b,a);\n    sync_mate_inner(a,b);\n    sync_mate_inner(b,a);\n    if (sync_mq_mc(a,b) < 0) return -1;\n    if (sync_mq_mc(b,a) < 0) return -1;\n    return 0;\n}\n\n\nstatic uint32_t calc_mate_score(bam1_t *b)\n{\n    uint32_t score = 0;\n    uint8_t  *qual = bam_get_qual(b);\n    int i;\n\n    for (i = 0; i < b->core.l_qseq; i++) {\n        if (qual[i] >= MD_MIN_QUALITY) score += qual[i];\n    }\n\n    return score;\n}\n\n\nstatic int add_mate_score(bam1_t *src, bam1_t *dest)\n{\n    uint8_t *data_ms;\n    uint32_t mate_score = calc_mate_score(src);\n\n    if ((data_ms = bam_aux_get(dest, \"ms\")) != NULL) {\n        bam_aux_del(dest, data_ms);\n    }\n\n    if (bam_aux_append(dest, \"ms\", 'i', sizeof(uint32_t), (uint8_t*)&mate_score) == -1) {\n        return -1;\n    }\n\n    return 0;\n}\n\n// Completely delete the CIGAR field\nstatic void clear_cigar(bam1_t *b) {\n    memmove(bam_get_cigar(b), bam_get_seq(b),\n            b->data + b->l_data - bam_get_seq(b));\n    b->l_data -= 4*b->core.n_cigar;\n    b->core.n_cigar = 0;\n}\n\n// Trim a CIGAR field to end on reference position \"end\".  Remaining bases\n// are turned to soft clips.\nstatic int bam_trim(bam1_t *b, hts_pos_t end) {\n    hts_pos_t pos = b->core.pos;\n    int n_cigar = b->core.n_cigar, i;\n    uint32_t new_cigar_a[1024];\n    uint32_t *new_cigar = new_cigar_a;\n    uint32_t *cigar = bam_get_cigar(b);\n\n    // Find end of alignment or end of ref\n    int op = 0, oplen = 0;\n    for (i = 0; i < n_cigar; i++) {\n        op = bam_cigar_op(cigar[i]);\n        oplen = bam_cigar_oplen(cigar[i]);\n        if (!(bam_cigar_type(op) & 2))\n            continue;\n        pos += oplen;\n        if (pos > end)\n            break;\n    }\n\n    if (i == n_cigar)\n        // looks fine already\n        return 0;\n\n    int old_i = i, j = 0;\n    // At worst we grow by 1 element (eg 100M -> 70M30S)\n    if (n_cigar-i >= 1024-1) {\n        new_cigar = malloc(4*(n_cigar-i+1));\n        if (!new_cigar)\n            return -1;\n    }\n\n    // We fill out to new_cigar from here on.\n    if (pos-oplen < end) {\n        // Partial CIGAR op?  Split existing tag.\n        cigar[old_i++] = bam_cigar_gen(end - (pos-oplen), op);\n        new_cigar[j++] = bam_cigar_gen(pos-end, BAM_CSOFT_CLIP);\n    } else if (pos > end) {\n        // entirely off the chromosome; this will trigger CIGAR *, MQUAL 0\n        b->core.flag |= BAM_FUNMAP;\n        b->core.flag &= ~BAM_FPROPER_PAIR;\n    } else {\n        // CIGAR op started on the trim junction\n        new_cigar[j++] = bam_cigar_gen(oplen, BAM_CSOFT_CLIP);\n    }\n\n    // Replace trailing elements.\n    for (i++; i < n_cigar; i++) {\n        op = bam_cigar_op(cigar[i]);\n        oplen = bam_cigar_oplen(cigar[i]);\n        if (op == BAM_CHARD_CLIP) {\n            new_cigar[j++] = cigar[i];\n        } else {\n            new_cigar[j-1] =\n                bam_cigar_gen(bam_cigar_oplen(new_cigar[j-1]) + oplen,\n                              BAM_CSOFT_CLIP);\n        }\n    }\n\n    // We now have cigar[0..old_i-1] for existing CIGAR\n    // and new_cigar[0..j-1] for new CIGAR trailing component.\n\n    if (old_i+j == n_cigar) {\n        // Fits and no data move needed\n        memcpy(&cigar[old_i], new_cigar, j*4);\n    } else {\n        uint8_t *seq_old = bam_get_seq(b);\n        uint8_t *aux_end = b->data + b->l_data;\n        int nshift;\n        if (old_i+j < n_cigar) {\n            // Smaller, and can move data down\n            nshift = -4*(n_cigar - (old_i+j));\n        } else {\n            // Bigger, so grow BAM and move data up\n            nshift = 4*(old_i+j - n_cigar);\n            // FIXME: make htslib's sam_realloc_bam_data public\n            if (b->l_data + nshift > b->m_data) {\n                uint8_t *new_data = realloc(b->data, b->l_data + nshift);\n                if (!new_data) {\n                    if (new_cigar != new_cigar_a)\n                        free(new_cigar);\n                    return -1;\n                }\n                b->m_data = b->l_data + nshift;\n                if (b->data != new_data) {\n                    b->data = new_data;\n                    seq_old = bam_get_seq(b);\n                    aux_end = b->data + b->l_data;\n                    cigar = bam_get_cigar(b);\n                }\n            }\n        }\n        memmove(seq_old+nshift, seq_old, aux_end - seq_old);\n        b->l_data += nshift;\n        memcpy(&cigar[old_i], new_cigar, j*4);\n        b->core.n_cigar = old_i+j;\n    }\n\n    if (new_cigar != new_cigar_a)\n        free(new_cigar);\n\n    return 0;\n}\n\n// Parses a comma-separated list of \"pos\", \"mqual\", \"unmap\", \"cigar\", and \"aux\"\n// keywords for the bam sanitizer.\nint bam_sanitize_options(const char *str) {\n    int opt = 0;\n\n    while (str && *str) {\n        const char *str_start;\n        while(*str && *str == ',')\n            str++;\n\n        for (str_start = str; *str && *str != ','; str++);\n        int len = str - str_start;\n        if (strncmp(str_start, \"all\", 3) == 0 || *str_start == '*')\n            opt = FIX_ALL;\n        else if (strncmp(str_start, \"none\", 4) == 0 ||\n                 strncmp(str_start, \"off\", 3) == 0)\n            opt = 0;\n        else if (strncmp(str_start, \"on\", 2) == 0)\n            // default for position sorted data\n            opt = FIX_MQUAL | FIX_UNMAP | FIX_CIGAR | FIX_AUX;\n        else if (strncmp(str_start, \"pos\", 3) == 0)\n            opt |= FIX_POS;\n        else if (strncmp(str_start, \"mqual\", 5) == 0)\n            opt |= FIX_MQUAL;\n        else if (strncmp(str_start, \"unmap\", 5) == 0)\n            opt |= FIX_UNMAP;\n        else if (strncmp(str_start, \"cigdup\", 6) == 0)\n            opt |= FIX_CIGDUP;\n        else if (strncmp(str_start, \"cigarx\", 6) == 0)\n            opt |= FIX_CIGARX | FIX_CIGDUP;\n        else if (strncmp(str_start, \"cigar\", 5) == 0)\n            opt |= FIX_CIGAR;\n        else if (strncmp(str_start, \"aux\", 3) == 0)\n            opt |= FIX_AUX;\n        else {\n            print_error(\"sanitize\", \"Unrecognised keyword %.*s\\n\",\n                        len, str_start);\n            return -1;\n        }\n    }\n\n    return opt;\n}\n\nint bam_sanitize(sam_hdr_t *h, bam1_t *b, int flags) {\n    if ((flags & FIX_POS) && b->core.tid < 0) {\n        // RNAME * => pos 0. NB can break alignment chr/pos sort order\n        b->core.pos = -1;\n        if (flags & FIX_UNMAP)\n            b->core.flag |= BAM_FUNMAP;\n    }\n\n    if ((flags & FIX_CIGAR) && !(b->core.flag & BAM_FUNMAP)) {\n        // Mapped => unmapped correction\n        if (b->core.pos < 0 && (flags & FIX_UNMAP)) {\n            b->core.flag |= BAM_FUNMAP;\n        } else {\n            hts_pos_t cur_end, rlen = sam_hdr_tid2len(h, b->core.tid);\n            if (b->core.pos >= rlen && (flags & FIX_UNMAP)) {\n                b->core.flag |= BAM_FUNMAP;\n                if (flags & FIX_POS)\n                    b->core.tid = b->core.pos = -1;\n            } else if ((cur_end = bam_endpos(b)) > rlen) {\n                if (bam_trim(b, rlen) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    if (b->core.flag & BAM_FUNMAP) {\n        // Unmapped -> cigar/qual correctoins\n        if ((flags & FIX_CIGAR) && b->core.n_cigar > 0)\n            clear_cigar(b);\n\n        if (flags & FIX_MQUAL)\n            b->core.qual = 0;\n\n        // Remove NM, MD, CG, SM tags.\n        if (flags & FIX_AUX) {\n            uint8_t *from = bam_aux_first(b);\n            uint8_t *end = b->data + b->l_data;\n            uint8_t *to = from ? from-2 : end;\n\n#define XTAG(a) (((a)[0]<<8) + (a)[1])\n            while (from) {\n                uint8_t *next = bam_aux_next(b, from);\n                if (!next && errno != ENOENT)\n                    return -1;\n\n                // Keep tag unless one of a specific set.\n                // NB \"to\" always points to an aux tag start, while\n                // \"from\" is after key.\n                from -= 2;\n                int key = (int)from[0]<<8 | from[1];\n                if (key != XTAG(\"NM\") && key != XTAG(\"MD\") &&\n                    key != XTAG(\"CG\") && key != XTAG(\"SM\")) {\n                    ptrdiff_t len = (next ? next-2 : end) - from;\n                    if (from != to)\n                        memmove(to, from, len);\n                    to += len;\n                }\n                from = next;\n            }\n            b->l_data = to - b->data;\n        }\n    }\n\n    if ((flags & FIX_CIGARX) && !(b->core.flag & BAM_FUNMAP)) {\n        // Turn CIGAR = and X into M.  These will then be merged together\n        // by CIGDUP below.  Ie 10=1X9= becomes 20M.\n        int i;\n        uint32_t *cig = bam_get_cigar(b);\n        for (i = 0; i < b->core.n_cigar; i++) {\n            int op = bam_cigar_op(cig[i]);\n            if (op == BAM_CEQUAL || op == BAM_CDIFF)\n                cig[i] = bam_cigar_gen(bam_cigar_oplen(cig[i]), BAM_CMATCH);\n        }\n    }\n\n    if ((flags & FIX_CIGDUP) && !(b->core.flag & BAM_FUNMAP)) {\n        // Canonicalise cigar strings, so xMyM becomes (x+y)M.\n        int nc = b->core.n_cigar, i, j;\n        uint32_t *cigf = bam_get_cigar(b), *cigt = cigf;\n        uint32_t last_op = -1, last_len = 0;\n\n        for (i = j = 0; i < nc; i++) {\n            int op = bam_cigar_op(cigf[i]);\n            int len = bam_cigar_oplen(cigf[i]);\n            if (op == last_op) {\n                if (last_len + len >= (1<<28)) {\n                    cigt[j-1] = bam_cigar_gen((1<<28)-1, op);\n                    len -= (1<<28)-1;\n                    cigt[j++] = bam_cigar_gen(len, op);\n                } else {\n                    cigt[j-1] = bam_cigar_gen(len = last_len + len, op);\n                }\n            } else if (len > 0) {\n                cigt[j++] = cigf[i];\n            }\n            if (len > 0) {\n                last_op  = op;\n                last_len = len;\n            }\n        }\n\n        if (j != nc) {\n            // Collapsed CIGAR so move data down\n            b->core.n_cigar = j;\n            uint8_t *endp = b->data + b->l_data;\n            memmove(cigf + j, cigf + nc, endp - (uint8_t *)(cigf + nc));\n            b->l_data -= 4*(nc-j);\n        }\n    }\n\n    return 0;\n}\n\n// Look for 3 tags in one pass, for efficiencies sake.\n// We also convert the draft tags Mm and Ml to MM and ML here.\nstatic inline void find_tags(bam1_t *b,\n                             char *t1, uint8_t **t1p,\n                             char *t2, uint8_t **t2p,\n                             char *t3, uint8_t **t3p) {\n    *t1p = *t2p = *t3p = NULL;\n    uint8_t *aux = bam_aux_first(b);\n\n    while (aux) {\n        if (aux[-2] == t1[0] && toupper(aux[-1]) == t1[1]) {\n            *t1p = aux;\n            if (islower(aux[-1]))\n                aux[-1] = t1[1];\n        } else if (aux[-2] == t2[0] && toupper(aux[-1]) == t2[1]) {\n            *t2p = aux;\n            if (islower(aux[-1]))\n                aux[-1] = t2[1];\n        } else if (aux[-2] == t3[0] && toupper(aux[-1]) == t3[1]) {\n            *t3p = aux;\n            if (islower(aux[-1]))\n                aux[-1] = t3[1];\n        }\n        aux = bam_aux_next(b, aux);\n    }\n}\n\n// Return 5' and 3' CIGAR hard-clip counts\nstatic inline void hard_clips(bam1_t *b, int *end5, int *end3) {\n    uint32_t *cigar = bam_get_cigar(b);\n    int ncigar = b->core.n_cigar;\n    int endL = 0, endR = 0, nh = 0;\n\n    if (ncigar && bam_cigar_op(cigar[0]) == BAM_CHARD_CLIP)\n        endL = bam_cigar_oplen(cigar[0]), nh=1;\n    if (ncigar > nh && bam_cigar_op(cigar[ncigar-1]) == BAM_CHARD_CLIP)\n        endR = bam_cigar_oplen(cigar[ncigar-1]);\n\n    if (b->core.flag & BAM_FREVERSE) {\n        *end5 = endR;\n        *end3 = endL;\n    } else {\n        *end5 = endL;\n        *end3 = endR;\n    }\n}\n\n// Get MM, ML and MN tags, and 5' and 3' hard-clip lengths.\n// MNi is integer copy of MN, or -1 if absent/invalid\nvoid get_mod_info(bam1_t *b, uint8_t **MM, uint8_t **ML, uint8_t **MN,\n                  int *MNi, int *end5, int *end3) {\n    find_tags(b, \"MM\", MM, \"ML\", ML, \"MN\", MN);\n    if (*MN) {\n        int save_errno = errno;\n        errno = 0;\n        *MNi = bam_aux2i(*MN);\n        if (errno == EINVAL)\n            *MNi = -1;\n        errno = save_errno;\n    } else {\n        *MNi = -1;\n    }\n\n    if (*MM)\n        hard_clips(b, end5, end3);\n    else\n        *end5 = *end3 = 0; // don't need if MM not found\n}\n\ntypedef struct MM_state {\n    // tags found on \"pre\" BAM\n    uint8_t *MM, *ML, *MN;\n} MM_state;\n\nuint8_t *MN_enc(uint8_t *tag, uint32_t n) {\n    if (n > UINT16_MAX) {\n        tag[0] = 'I';\n        i32_to_le(n, tag+1);\n        tag += 5;\n    } else if (n > UINT8_MAX) {\n        tag[0] = 'S';\n        i16_to_le(n, tag+1);\n        tag += 3;\n    } else {\n        *tag++ = 'C';\n        *tag++ = n;\n    }\n\n    return tag;\n}\n\n// Trim 5'/3' bases off MM and ML tags, using a previous sequence as a guide.\nint trim_MM(bam1_t *pre, bam1_t *cur, int end5, int end3,\n            uint8_t *MM, uint8_t *ML, uint8_t *MN) {\n    // Count number of bases\n    int counts5[16] = {0}, counts3[16] = {0};\n\n    uint8_t *seq = bam_get_seq(pre);\n    int i;\n    for (i = 0; i < end5; i++)\n        counts5[bam_seqi(seq, i)]++;\n    memcpy(counts3, counts5, 16 * sizeof(*counts3));\n    for (; i < pre->core.l_qseq - end3; i++)\n        counts3[bam_seqi(seq, i)]++;\n\n    // \"p\" is position in pre.\n    // \"q\" is position in cur.\n    // Hence move up \"p\" to start and copy from there to \"q\".\n    uint8_t *MMp, *MLp, *MMq = NULL, *MLq = NULL;\n    if (ML && ML[0] == 'B' && ML[1] == 'C') {\n        MLp = ML+6;\n    } else {\n        ML = MLp = NULL;\n    }\n    MMq = MM+1;\n    MLq = MLp;\n    for (MMp = MM+1; *MMp; ) {\n        int fundamental = seq_nt16_table[*MMp];\n        while (*MMp && *MMp != ',')\n            *MMq++ = *MMp++;\n        if (*MMp)\n            *MMq++ = *MMp++;\n\n        // Now on comma separated list for MM and BC array for ML. Skip\n        int n = 0;\n        while (*MMp != ';' && n < counts5[fundamental]) {\n            char *endptr;\n            long delta = strtol((char *)MMp, &endptr, 10);\n            if (counts5[fundamental] - n > delta) {\n                // Skip entire delta in MM and ML.\n                // Eg counts[]=10, MM=3,10 ML=<10><20> => MM=10 ML=<20>\n                n += delta+1;\n                if(ML) MLp++;\n            } else if (counts3[fundamental] > counts5[fundamental]) {\n                // Shrink delta, writing MM and ML is unchanged.\n                // Eg counts[]=3, MM=10,4 ML=<10><20> => MM=7,4 ML=<10><20>\n                char num[50];\n                int l = sprintf(num, \"%ld\",\n                                delta - (counts5[fundamental]-n));\n                memcpy((char *)MMq, num, l);\n                MMq += l;\n                *MMq++ = *endptr;\n                n += delta+1;\n                if (ML)\n                    *MLq++ = *MLp++;\n            } else {\n                // next base mod is on boundary of 3' clip point\n                break;\n            }\n\n            MMp = (uint8_t *)endptr;\n            if (*MMp != ',')\n                // error?  if not ; also?\n                break;\n            MMp++;\n        }\n\n        // Copy\n        while (*MMp != ';' && n < counts3[fundamental]) {\n            char *endptr;\n            long delta = strtol((char *)MMp, &endptr, 10);\n            if (counts3[fundamental] - n > delta) {\n                // Copy entire delta in MM and ML including [,;]\n                memmove(MMq, MMp, (uint8_t *)endptr - MMp + 1);\n                MMq += (uint8_t *)endptr - MMp + 1;\n                n += delta+1;\n                if (ML)\n                    *MLq++ = *MLp++;\n            } else {\n                // Next mod is into 3' cutoff, so can terminate MM/ML now\n                n = counts3[fundamental];\n                if (ML)\n                    MLp++;\n            }\n\n            MMp = (uint8_t *)endptr;\n            if (*MMp != ',')\n                break;\n            MMp++;\n        }\n\n        // Skip\n        while (*MMp && *MMp != ';') {\n            while (*MMp && *MMp != ',' && *MMp != ';')\n                MMp++;\n            if (*MMp == ',')\n                MMp++;\n\n            if (ML)\n                MLp++;\n        }\n        MMq[-1] = ';'; // replaces , with ; if clipping right\n        if (*MMp)\n            MMp++;\n    }\n\n    MMp++; // skip nul\n    *MMq++ = 0;\n\n    // Adjust ML B array length\n    if (ML)\n        u32_to_le(MLq-(ML+6), ML+2);\n\n    // Move MM and ML down to include their MM:Z and ML:B bits\n    if (MM) MM-=2;\n    if (ML) ML-=2;\n\n    // Now MM/ML are start of tags, MMq/MLq are ends of edited tags,\n    // and MMp/MLp are ends of original tags.  Walk through tags taking up\n    // any gaps\n    //\n    // Eg XXXXXXmmmmm--YYYlllll-ZZ (m and l are edited MM and ML tags)\n    // => XXXXXXmmmmmYYYlllllZZ\n\n    uint8_t *tag = bam_get_aux(cur), *tag_end = cur->data + cur->l_data;\n    uint8_t *to = tag;\n    while (tag && tag < tag_end) {\n        if (tag[0] == 'M' && (tag[1] == 'M' || tag[1] == 'm')) {\n            // Slow but easy\n            memmove(to, MM, MMq-MM); // length of new tag\n            to += MMq-MM;\n            tag = MMp; // size of old tag\n        } else if (tag[0] == 'M' && (tag[1] == 'L' || tag[1] == 'l')) {\n            memmove(to, ML, MLq-ML);\n            to += MLq-ML;\n            tag = MLp;\n        } else if (tag[0] == 'M' && tag[1] == 'N') {\n            tag = bam_aux_next(cur, tag+2);\n            // Skip it as we'll overwrite this later, although this\n            // does change the tag order.  Instead we could do:\n            //\n            // *to++ = 'M';\n            // *to++ = 'N';\n            // to = MN_enc(to, cur->core.l_qseq);\n        } else {\n            // Want aux_skip, but it's private.\n            // So we use bam_aux_next with work-arounds. :(\n            uint8_t *from = tag;\n            tag = bam_aux_next(cur, tag+2);\n            tag = tag ? tag-2 : tag_end;\n            memmove(to, from, tag-from);\n            to += tag-from;\n        }\n    }\n    cur->l_data = to - cur->data;\n\n    return 0;\n}\n\n// Removes base modification tags: MM, ML and MN.\n// This is more efficient than a series of bam_aux_remove and\n// bam_aux_find calls, as the previous removes shuffle the tags we've\n// previously found.  However it's still not optimal.\nvoid delete_mod_tags(bam1_t *b) {\n    uint8_t *tag = bam_aux_first(b), *next;\n    uint8_t *to = tag;\n    while (tag) {\n        next = bam_aux_next(b, tag);\n        if (tag[-2] == 'M' &&\n            (tag[-1] == 'M' || tag[-1] == 'm' ||\n             tag[-1] == 'L' || tag[-1] == 'l' ||\n             tag[-1] == 'N')) {\n            // Skip. Equivalent to bam_aux_remove without multiple passes\n        } else {\n            // Copy.  All these +/-2s are an annoyance caused by the\n            // tag iterator pointing to the byte after the 2-letter code\n            uint8_t *end = next ? next : b->data + b->l_data + 2;\n            if (tag != to)\n                memmove(to-2, tag-2, end-tag);\n            to += end-tag;\n        }\n        tag = next;\n    }\n\n    b->l_data = (to-2) - b->data;\n}\n\nint validate_MM(bam1_t *b, hts_base_mod_state *state) {\n    hts_base_mod mods[10];\n    int n, pos;\n    while ((n = bam_next_basemod(b, state, mods, 10, &pos)) > 0) {\n        // bam_next_basemod will trigger MM out-of-bound checks\n    }\n    return n;\n}\n\n// Fix base modification tags MM, ML and MN.\n// For supplementary-style alignments we may have hard-clipped the sequence\n// and just duplicated the MM/ML tags.  Use the primary alignment to get the\n// clipped sequence so we can trim MM/ML accordingly.\n//\n// We call this first on primary reads with pre == NULL.  This caches\n// MM and ML data into MM_state.\n//\n// We then call it again on secondary and/or supplementary data with\n// pre == the primary record and pass in the associated state.  This then\n// validates MM/ML/MN match, and if not adjusts them if they have hard-clips\n// which yields consistent data.\n//\n// TODO: add sanity check on counts of base types and MM tag to ensure it's\n// possible. We can do this post-trimming, so we sanitize everything.\n//\n// Returns 0 on success,\n//        -1 on failure\nint fix_MM(bam1_t *pre, bam1_t *cur, MM_state *state) {\n    int end5, end3;\n    int MNi = 0; // MN of -1 is used as indicator for no valid mods\n\n    if (!pre && state) {\n        // First time we've see this name.\n        // Look for base modification tags and sanity check.\n        get_mod_info(cur, &state->MM, &state->ML, &state->MN, &MNi,\n                     &end5, &end3);\n        if (!state->MM) {\n            delete_mod_tags(cur);\n            return 0;\n        }\n\n        if (!end5 && !end3 && MNi <= 0) {\n            // No MN tag, but also no clipping.  Assume MM is valid\n            if (cur->core.l_qseq)\n                if (bam_aux_update_int(cur, \"MN\", cur->core.l_qseq) < 0)\n                    return -1;\n        } else if ((end3 || end5) && cur->core.l_qseq != MNi) {\n            // We have hard clips and MN tag, but the MN tag doesn't match\n            // observed sequence length so it appears the hard-clipping\n            // happened after base-mods called without updating.\n            // Fail as this is a primary read.\n            delete_mod_tags(cur);\n        }\n        // Otherwise we assume the base modifications are correct\n\n    } else if (state) {\n        // A supplementary or secondary alignment with known primary\n        uint8_t *cur_MM = NULL, *cur_ML = NULL, *cur_MN = NULL;\n        MNi = -1;\n        get_mod_info(cur, &cur_MM, &cur_ML, &cur_MN, &MNi, &end5, &end3);\n\n        if (!cur_MM) {\n            delete_mod_tags(cur);\n            return 0;\n        }\n\n        // Does MN match seq length?  If so, we believe it's already valid\n        if (MNi == cur->core.l_qseq)\n            goto validate;\n\n        // Length mismatch and/or no known length, so check vs full seq.\n        if (pre->core.l_qseq != cur->core.l_qseq + end3 + end5) {\n            delete_mod_tags(cur);\n            return 0;\n        } else if (end5 || end3) {\n             if (MNi < 0 || MNi == pre->core.l_qseq)\n                 trim_MM(pre, cur, end5, end3, cur_MM, cur_ML, cur_MN);\n        } // else no hard clips so MM is already valid\n\n        // Set MN so we've validated it, provided seq isn't \"*\".\n        // inefficient, but minimal compared to everything else\n        if (cur->core.l_qseq)\n            if (bam_aux_update_int(cur, \"MN\", cur->core.l_qseq) < 0)\n                return -1;\n    }\n\n validate:\n    ;\n\n    // Also validate MM length matches sequence length.  This mirrors the\n    // logic in htslib/sam_mods.c.\n    // For now we take the inefficient approach of using bam_parse_basemod2.\n    // Inefficient, but robust.\n    hts_base_mod_state *mst = hts_base_mod_state_alloc();\n    if (!mst)\n        return -1;\n\n    enum htsLogLevel lvl = hts_get_log_level();\n    hts_set_log_level(HTS_LOG_OFF);\n    if (bam_parse_basemod(cur, mst) < 0)\n        // Maybe we want hts_log_warning still though?\n        delete_mod_tags(cur);\n    if (validate_MM(cur, mst) < 0)\n        delete_mod_tags(cur);\n    hts_set_log_level(lvl);\n    hts_base_mod_state_free(mst);\n\n    return 0;\n}\n\n// Ensure the b[] array is at least n.\n// Returns 0 on success,\n//        -1 on failure\nstatic int grow_b_array(bam1_t **b, int *ba, int n) {\n    if (n < *ba)\n        return 0;\n\n    bam1_t *bnew = realloc(*b, (n+=10) * sizeof(**b));\n    if (!bnew)\n        return -1;\n    *b = bnew;\n\n    // bam_init1 equivalent\n    int i;\n    for (i = *ba; i < n; i++)\n        memset(&(*b)[i], 0, sizeof(bam1_t));\n\n    *b = bnew;\n    *ba = n;\n\n    return 0;\n}\n\n// We have b[0]..b[bn-1] entries all from the same template (qname)\ntypedef struct {\n    bam1_t *b;\n    int n, ba;  // number used and number allocated\n    int b_next; // b[b_next] for start of next set, -1 if unset\n    int eof;    // marker for having seen eof\n} bam_set;\n\n// Fetches a new batch of BAM records all containing the same name.\n// NB: we cache the last (non-matching) name in b[n], so we can use it to\n// start the next batch.\n// Returns the number of records on success,\n//         <0 on failure or EOF (sam_read1 return vals)\nstatic int next_template(samFile *in, sam_hdr_t *header, bam_set *bs,\n                         int sanitize_flags) {\n    int result;\n\n    if (bs->eof)\n        return -1;\n\n    // First time through, prime the template name\n    if (bs->b_next < 0) {\n        if (grow_b_array(&bs->b, &bs->ba, 1) < 0)\n            return -2;\n        result = sam_read1(in, header, &bs->b[0]);\n        if (result < 0)\n            return result;\n        if (bam_sanitize(header, &bs->b[0], sanitize_flags) < 0)\n            return -2;\n    } else {\n        // Otherwise use the previous template name read\n        bam1_t btmp = bs->b[0];\n        bs->b[0] = bs->b[bs->b_next];\n        bs->b[bs->b_next] = btmp; // For ->{,l_,m_}data\n    }\n    bs->n = 1;\n\n    // Now keep reading until we find a read that mismatches or we hit eof.\n    char *name = bam_get_qname(&bs->b[0]);\n    for (;;) {\n        if (grow_b_array(&bs->b, &bs->ba, bs->n+1) < 0)\n            return -2;\n\n        result = sam_read1(in, header, &bs->b[bs->n]);\n        if (result < -1)\n            return result;\n\n        if (result < 0) {\n            bs->eof = 1;\n            bs->b_next = -1;\n            break;\n        } else {\n            if (bam_sanitize(header, &bs->b[bs->n], sanitize_flags) < 0)\n                return -2;\n\n            bs->b_next = bs->n;\n            if (strcmp(name, bam_get_qname(&bs->b[bs->n])) != 0)\n                break;\n        }\n\n        bs->n++;\n    }\n\n    return bs->n;\n}\n\n// currently, this function ONLY works if each read has one hit\n//\n// Returns 0 on success,\n//        >0 on failure\nstatic int bam_mating_core(samFile *in, samFile *out, int remove_reads,\n                           int proper_pair_check, int add_ct,\n                           int do_mate_scoring, char *arg_list, int no_pg,\n                           int sanitize_flags, int base_mods)\n{\n    sam_hdr_t *header;\n    int result, n;\n    kstring_t str = KS_INITIALIZE;\n    bam_set bs = {NULL, 0, 0, -1, 0};\n\n    header = sam_hdr_read(in);\n    if (header == NULL) {\n        fprintf(stderr, \"[bam_mating_core] ERROR: Couldn't read header\\n\");\n        return 1;\n    }\n\n    // Accept unknown, unsorted, or queryname sort order, but error on coordinate sorted.\n    if (!sam_hdr_find_tag_hd(header, \"SO\", &str) && str.s && !strcmp(str.s, \"coordinate\")) {\n        fprintf(stderr, \"[bam_mating_core] ERROR: Coordinate sorted, require grouped/sorted by queryname.\\n\");\n        goto fail;\n    }\n    ks_free(&str);\n\n    if (!no_pg && sam_hdr_add_pg(header, \"samtools\",\n                                 \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL))\n        goto fail;\n\n    if (sam_hdr_write(out, header) < 0) goto write_fail;\n\n    // Iterate template by template fetching bs->n records at a time\n    while ((result = next_template(in, header, &bs, sanitize_flags)) >= 0) {\n        bam1_t *cur = NULL, *pre = NULL, *rnum[2] = {NULL, NULL};\n        int prev = -1, curr = -1;\n        hts_pos_t pre_end = 0, cur_end = 0;\n\n        // Find and fix up primary alignments\n        MM_state state[2];\n        for (n = 0; n < bs.n; n++) {\n            int is_r2 = (bs.b[n].core.flag & BAM_FREAD2) != 0;\n            if (bs.b[n].core.flag & (BAM_FSECONDARY | BAM_FSUPPLEMENTARY))\n                continue;\n\n            if (base_mods)\n                if (fix_MM(NULL, &bs.b[n], &state[is_r2]) < 0)\n                    goto fail;\n\n            if (!pre) {\n                pre = &bs.b[prev = n];\n                rnum[(pre->core.flag & BAM_FREAD2) != 0] = pre;\n\n                pre_end = (pre->core.flag & BAM_FUNMAP) == 0\n                    ? bam_endpos(pre) : 0;\n                continue;\n            }\n\n            // Note, more than 2 primary alignments will use 'curr' as last\n            cur = &bs.b[curr = n];\n            rnum[(cur->core.flag & BAM_FREAD2) != 0] = cur;\n            cur_end = (cur->core.flag & BAM_FUNMAP) == 0\n                ? bam_endpos(cur) : 0;\n\n            pre->core.flag |= BAM_FPAIRED;\n            cur->core.flag |= BAM_FPAIRED;\n            if (sync_mate(pre, cur))\n                goto fail;\n\n            // If safe set TLEN/ISIZE\n            if (pre->core.tid == cur->core.tid\n                && !(cur->core.flag & (BAM_FUNMAP | BAM_FMUNMAP))\n                && !(pre->core.flag & (BAM_FUNMAP | BAM_FMUNMAP))) {\n                hts_pos_t cur5, pre5;\n                cur5 = (cur->core.flag & BAM_FREVERSE)\n                    ? cur_end\n                    : cur->core.pos;\n                pre5 = (pre->core.flag & BAM_FREVERSE)\n                    ? pre_end\n                    : pre->core.pos;\n                cur->core.isize = pre5 - cur5;\n                pre->core.isize = cur5 - pre5;\n            } else {\n                cur->core.isize = pre->core.isize = 0;\n            }\n\n            if (add_ct)\n                bam_template_cigar(pre, cur, &str);\n\n            // TODO: Add code to properly check if read is in a proper\n            // pair based on ISIZE distribution\n            if (proper_pair_check && !plausibly_properly_paired(pre,cur)) {\n                pre->core.flag &= ~BAM_FPROPER_PAIR;\n                cur->core.flag &= ~BAM_FPROPER_PAIR;\n            }\n\n            if (do_mate_scoring) {\n                if ((add_mate_score(pre, cur) == -1) ||\n                    (add_mate_score(cur, pre) == -1)) {\n                    fprintf(stderr, \"[bam_mating_core] ERROR: \"\n                            \"unable to add mate score.\\n\");\n                    goto fail;\n                }\n            }\n\n            // If we have to remove reads make sure we do it in a way that\n            // doesn't create orphans with bad flags\n            if (remove_reads) {\n                if (pre->core.flag&BAM_FUNMAP)\n                    cur->core.flag &=\n                        ~(BAM_FMREVERSE|BAM_FPROPER_PAIR);\n                if (cur->core.flag&BAM_FUNMAP)\n                    pre->core.flag &=\n                        ~(BAM_FMREVERSE|BAM_FPROPER_PAIR);\n            }\n        }\n\n        // Handle unpaired primary data\n        if (!cur && pre) {\n            pre->core.mtid = -1;\n            pre->core.mpos = -1;\n            pre->core.isize = 0;\n            pre->core.flag &= ~(BAM_FMREVERSE|BAM_FPROPER_PAIR);\n        }\n\n        // Now process secondary and supplementary alignments\n        for (n = 0; n < bs.n; n++) {\n            if (!(bs.b[n].core.flag & (BAM_FSECONDARY|BAM_FSUPPLEMENTARY))) {\n                // primary\n                continue;\n            }\n\n            // Secondary or supplementary\n            int is_r2 = (bs.b[n].core.flag & BAM_FREAD2) != 0;\n            bam1_t *primary = rnum[is_r2];\n            if (primary) {\n                if (base_mods)\n                    fix_MM(primary, &bs.b[n], &state[is_r2]);\n            } else {\n                // Record with base modifications but no known primary\n                //fprintf(stderr, \"Unpaired secondary or supplementary\\n\");\n                if (base_mods)\n                    fix_MM(NULL, &bs.b[n], NULL);\n            }\n        }\n\n        // Finally having curated everything, write out all records in their\n        // original ordering\n        for (n = 0; n < bs.n; n++) {\n            bam1_t *cur = &bs.b[n];\n            // We may remove unmapped and secondary alignments\n            if (remove_reads && (cur->core.flag & (BAM_FSECONDARY|BAM_FUNMAP)))\n                continue;\n\n            if (sam_write1(out, header, cur) < 0)\n                goto write_fail;\n        }\n    }\n    if (result < -1)\n        goto read_fail;\n\n    sam_hdr_destroy(header);\n\n    for (n = 0; n < bs.ba; n++)\n        free(bs.b[n].data);\n    free(bs.b);\n    ks_free(&str);\n    return 0;\n\n read_fail:\n    print_error(\"fixmate\", \"Couldn't read from input file\");\n    goto fail;\n\n write_fail:\n    print_error_errno(\"fixmate\", \"Couldn't write to output file\");\n fail:\n    sam_hdr_destroy(header);\n    for (n = 0; n < bs.ba; n++)\n        free(bs.b[n].data);\n    free(bs.b);\n    ks_free(&str);\n    return 1;\n}\n\nvoid usage(FILE* where)\n{\n    fprintf(where,\n\"Usage: samtools fixmate <in.nameSrt.bam> <out.nameSrt.bam>\\n\"\n\"Options:\\n\"\n\"  -r           Remove unmapped reads and secondary alignments\\n\"\n\"  -p           Disable FR proper pair check\\n\"\n\"  -c           Add template cigar ct tag\\n\"\n\"  -m           Add mate score tag\\n\"\n\"  -u           Uncompressed output\\n\"\n\"  -z, --sanitize FLAG[,FLAG]\\n\"\n\"               Sanitize alignment fields [defaults to all types]\\n\"\n\"  -M           Fix base modification tags (MM/ML/MN)\\n\"\n\"  --no-PG      do not add a PG line\\n\");\n\n    sam_global_opt_help(where, \"-.O..@-.\");\n\n    fprintf(where,\n\"\\n\"\n\"As elsewhere in samtools, use '-' as the filename for stdin/stdout. The input\\n\"\n\"file must be grouped by read name (e.g. sorted by name). Coordinated sorted\\n\"\n\"input is not accepted.\\n\");\n}\n\nint bam_mating(int argc, char *argv[])\n{\n    htsThreadPool p = {NULL, 0};\n    samFile *in = NULL, *out = NULL;\n    int c, remove_reads = 0, proper_pair_check = 1, add_ct = 0, res = 1,\n        mate_score = 0, no_pg = 0, sanitize_flags = FIX_ALL, base_mods = 0;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    char wmode[4] = {'w', 'b', 0, 0};\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', 0, 0, '@'),\n        {\"no-PG\", no_argument, NULL, 1},\n        { NULL, 0, NULL, 0 }\n    };\n    char *arg_list = NULL;\n\n    // parse args\n    if (argc == 1) { usage(stdout); return 0; }\n    while ((c = getopt_long(argc, argv, \"rpcmMO:@:uz:\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'r': remove_reads = 1; break;\n        case 'p': proper_pair_check = 0; break;\n        case 'c': add_ct = 1; break;\n        case 'm': mate_score = 1; break;\n        case 'M': base_mods = 1; break;\n        case 'u': wmode[2] = '0'; break;\n        case 1: no_pg = 1; break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?': usage(stderr); goto fail;\n        case 'z':\n            if ((sanitize_flags = bam_sanitize_options(optarg)) < 0)\n                exit(1);\n            break;\n        }\n    }\n    if (optind+1 >= argc) { usage(stderr); goto fail; }\n\n    if (!no_pg && !(arg_list =  stringify_argv(argc+1, argv-1)))\n        goto fail;\n\n    // init\n    if ((in = sam_open_format(argv[optind], \"rb\", &ga.in)) == NULL) {\n        print_error_errno(\"fixmate\", \"cannot open input file\");\n        goto fail;\n    }\n    sam_open_mode(wmode+1, argv[optind+1], NULL);\n    if ((out = sam_open_format(argv[optind+1], wmode, &ga.out)) == NULL) {\n        print_error_errno(\"fixmate\", \"cannot open output file\");\n        goto fail;\n    }\n\n    if (ga.nthreads > 0) {\n        if (!(p.pool = hts_tpool_init(ga.nthreads))) {\n            fprintf(stderr, \"Error creating thread pool\\n\");\n            goto fail;\n        }\n        hts_set_opt(in,  HTS_OPT_THREAD_POOL, &p);\n        hts_set_opt(out, HTS_OPT_THREAD_POOL, &p);\n    }\n\n    // run\n    res = bam_mating_core(in, out, remove_reads, proper_pair_check, add_ct,\n                          mate_score, arg_list, no_pg, sanitize_flags,\n                          base_mods);\n\n    // cleanup\n    sam_close(in);\n    if (sam_close(out) < 0) {\n        fprintf(stderr, \"[bam_mating] error while closing output file\\n\");\n        res = 1;\n    }\n\n    if (p.pool) hts_tpool_destroy(p.pool);\n    free(arg_list);\n    sam_global_args_free(&ga);\n    return res;\n\n fail:\n    if (in) sam_close(in);\n    if (out) sam_close(out);\n    if (p.pool) hts_tpool_destroy(p.pool);\n    free(arg_list);\n    sam_global_args_free(&ga);\n    return 1;\n}\n\n\n"
        },
        {
          "name": "bam_md.c",
          "type": "blob",
          "size": 18.2353515625,
          "content": "/*  bam_md.c -- calmd subcommand.\n\n    Copyright (C) 2009-2011, 2014-2015, 2019-2020, 2022 Genome Research Ltd.\n    Portions copyright (C) 2009-2011 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"htslib/faidx.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/thread_pool.h\"\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n\n#define USE_EQUAL 1\n#define DROP_TAG  2\n#define BIN_QUAL  4\n#define UPDATE_NM 8\n#define UPDATE_MD 16\n#define HASH_QNM  32\n\ntypedef struct cached_ref_entry {\n    char *ref;\n    hts_pos_t len;\n} cached_ref_entry;\n\ntypedef struct ref_cache {\n    cached_ref_entry *refs;\n    char *last_ref;\n    hts_pos_t last_len;\n    int nref;\n    int last_tid;\n} ref_cache;\n\nint bam_aux_drop_other(bam1_t *b, uint8_t *s);\n\nstatic int bam_fillmd1_core(const char *ref_name, bam1_t *b, char *ref,\n                            hts_pos_t ref_len, int flag, int max_nm,\n                            int quiet_mode, uint32_t *skipped)\n{\n    uint8_t *seq = bam_get_seq(b);\n    uint32_t *cigar = bam_get_cigar(b);\n    bam1_core_t *c = &b->core;\n    int i, qpos, matched = 0;\n    hts_pos_t rpos;\n    kstring_t str = KS_INITIALIZE;\n    int32_t old_nm_i = -1, nm = 0;\n    uint32_t err = 0;\n\n    if (c->l_qseq == 0) {\n        if (!quiet_mode) {\n            if (ref_name) {\n                fprintf(stderr, \"[bam_fillmd1] no sequence in alignment \"\n                        \"record for '%s' at %s:%\"PRIhts_pos\", skipped\\n\",\n                        bam_get_qname(b), ref_name, c->pos + 1);\n            } else {\n                fprintf(stderr, \"[bam_fillmd1] no sequence in alignment \"\n                        \"record for '%s', skipped\", bam_get_qname(b));\n            }\n        }\n        if (skipped) (*skipped)++;\n        return 0;\n    }\n\n    for (i = qpos = 0, rpos = c->pos; i < c->n_cigar; ++i) {\n        int j, oplen = cigar[i]>>4, op = cigar[i]&0xf;\n        if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {\n            for (j = 0; j < oplen; ++j) {\n                int c1, c2, z = qpos + j;\n                if (rpos+j >= ref_len || z >= c->l_qseq || ref[rpos+j] == '\\0')\n                    break; // out of bounds\n                c1 = bam_seqi(seq, z);\n                c2 = seq_nt16_table[(uint8_t)ref[rpos+j]];\n                if ((c1 == c2 && c1 != 15 && c2 != 15) || c1 == 0) { // a match\n                    if (flag&USE_EQUAL) seq[z/2] &= (z&1)? 0xf0 : 0x0f;\n                    ++matched;\n                } else {\n                    err |= kputw(matched, &str) < 0;\n                    err |= kputc(toupper(ref[rpos+j]), &str) < 0;\n                    matched = 0; ++nm;\n                }\n            }\n            if (j < oplen) break;\n            rpos += oplen; qpos += oplen;\n        } else if (op == BAM_CDEL) {\n            err |= kputw(matched, &str) < 0;\n            err |= kputc('^', &str) < 0;\n            for (j = 0; j < oplen; ++j) {\n                if (rpos+j >= ref_len || ref[rpos+j] == '\\0') break;\n                err |= kputc(toupper(ref[rpos+j]), &str) < 0;\n            }\n            matched = 0;\n            rpos += j; nm += j;\n            if (j < oplen) break;\n        } else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) {\n            qpos += oplen;\n            if (op == BAM_CINS) nm += oplen;\n        } else if (op == BAM_CREF_SKIP) {\n            rpos += oplen;\n        }\n    }\n    err |= kputw(matched, &str) < 0;\n    if (err) {\n        print_error_errno(\"calmd\", \"Couldn't build new MD string\");\n        goto fail;\n    }\n    // apply max_nm\n    if (max_nm > 0 && nm >= max_nm) {\n        for (i = qpos = 0, rpos = c->pos; i < c->n_cigar; ++i) {\n            int j, oplen = cigar[i]>>4, op = cigar[i]&0xf;\n            if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {\n                for (j = 0; j < oplen; ++j) {\n                    int c1, c2, z = qpos + j;\n                    if (rpos+j >= ref_len || z >= c->l_qseq || ref[rpos+j] == '\\0')\n                        break; // out of bounds\n                    c1 = bam_seqi(seq, z);\n                    c2 = seq_nt16_table[(uint8_t)ref[rpos+j]];\n                    if ((c1 == c2 && c1 != 15 && c2 != 15) || c1 == 0) { // a match\n                        seq[z/2] |= (z&1)? 0x0f : 0xf0;\n                        bam_get_qual(b)[z] = 0;\n                    }\n                }\n                if (j < oplen) break;\n                rpos += oplen; qpos += oplen;\n            } else if (op == BAM_CDEL || op == BAM_CREF_SKIP) rpos += oplen;\n            else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) qpos += oplen;\n        }\n    }\n    // update NM\n    if ((flag & UPDATE_NM) && !(c->flag & BAM_FUNMAP)) {\n        uint8_t *old_nm = bam_aux_get(b, \"NM\");\n        if (old_nm) old_nm_i = bam_aux2i(old_nm);\n        if (!old_nm) {\n            if (bam_aux_append(b, \"NM\", 'i', 4, (uint8_t*)&nm) < 0)\n                goto aux_fail;\n        }\n        else if (nm != old_nm_i) {\n            if (!quiet_mode) {\n                fprintf(stderr, \"[bam_fillmd1] different NM for read '%s': %d -> %d\\n\", bam_get_qname(b), old_nm_i, nm);\n            }\n            if (bam_aux_del(b, old_nm) < 0) goto aux_fail;\n            if (bam_aux_append(b, \"NM\", 'i', 4, (uint8_t*)&nm) < 0)\n                goto aux_fail;\n        }\n    }\n    // update MD\n    if ((flag & UPDATE_MD) && !(c->flag & BAM_FUNMAP)) {\n        uint8_t *old_md = bam_aux_get(b, \"MD\");\n        if (!old_md) {\n            if (bam_aux_append(b, \"MD\", 'Z', str.l + 1, (uint8_t*)str.s) < 0)\n                goto aux_fail;\n        } else {\n            int is_diff = 0;\n            if (strlen((char*)old_md+1) == str.l) {\n                for (i = 0; i < str.l; ++i)\n                    if (toupper(old_md[i+1]) != toupper(str.s[i]))\n                        break;\n                if (i < str.l) is_diff = 1;\n            } else is_diff = 1;\n            if (is_diff) {\n                if (!quiet_mode) {\n                    fprintf(stderr, \"[bam_fillmd1] different MD for read '%s': '%s' -> '%s'\\n\", bam_get_qname(b), old_md+1, str.s);\n                }\n                if (bam_aux_del(b, old_md) < 0) goto aux_fail;\n                if (bam_aux_append(b, \"MD\", 'Z', str.l + 1, (uint8_t*)str.s) < 0)\n                    goto aux_fail;\n            }\n        }\n    }\n\n    // drop all tags but RG\n    if (flag&DROP_TAG) {\n        uint8_t *q = bam_aux_get(b, \"RG\");\n        bam_aux_drop_other(b, q);\n    }\n    // reduce the resolution of base quality\n    if (flag&BIN_QUAL) {\n        uint8_t *qual = bam_get_qual(b);\n        for (i = 0; i < b->core.l_qseq; ++i)\n            if (qual[i] >= 3) qual[i] = qual[i]/10*10 + 7;\n    }\n\n    free(str.s);\n    return 0;\n\n aux_fail:\n    if (errno == ENOMEM) {\n        print_error(\"calmd\", \"Couldn't add aux tag (too long)\");\n    } else if (errno == EINVAL) {\n        print_error(\"calmd\", \"Corrupt aux data\");\n    } else {\n        print_error_errno(\"calmd\", \"Couldn't add aux tag\");\n    }\n fail:\n    free(str.s);\n    return -1;\n}\n\nint bam_fillmd1(bam1_t *b, char *ref, int flag, int quiet_mode)\n{\n    return bam_fillmd1_core(NULL, b, ref, INT_MAX, flag, 0, quiet_mode, NULL);\n}\n\n// Get a new reference sequence.\n// For position-sorted inputs, the previous reference should never be\n// needed again and can be discarded to save memory.  For other orderings,\n// references are stored in a cache in case they're required in the future.\n// The caching mode is turned on if the requested  tid is less than the last\n// one used, indicating the file ordering doesn't match the sequence dictionary.\nstatic int get_ref(faidx_t *fai, sam_hdr_t *header, ref_cache *cache,\n                   int tid, char **ref_out, const char **ref_name_out,\n                   hts_pos_t *len_out)\n{\n    char *ref = NULL;\n    const char *ref_name;\n    hts_pos_t len = 0;\n\n    // This should only be called when tid changes\n    assert(tid != cache->last_tid);\n\n    // Array lookup, should be fast\n    ref_name = sam_hdr_tid2name(header, tid);\n    *ref_name_out = ref_name;\n\n    // Return a cached entry, if available\n    if (cache->refs && tid >= 0 && tid < cache->nref\n        && cache->refs[tid].ref) {\n        assert(cache->last_ref == NULL);\n        *ref_out = cache->refs[tid].ref;\n        *len_out = cache->refs[tid].len;\n        cache->last_tid = tid;\n        return 0;\n    }\n\n    // Try to get the reference\n    if (ref_name)\n        ref = fai_fetch64(fai, ref_name, &len);\n\n    if (!ref) {\n        // Historically, calmd doesn't worry too much about missing refs\n        *ref_out = NULL;\n        *len_out = 0;\n        return 0;\n    }\n\n    if (!cache->refs && cache->last_tid > tid) {\n        // Going backwards throught the list of tids implies\n        // a non-position-ordered file, so turn on caching mode\n        cache->nref = sam_hdr_nref(header);\n        if (cache->nref < 0) {\n            print_error(\"calmd\", \"couldn't get number of refs from header\");\n            return -1;\n        }\n        if (cache->nref > 0) {\n            cache->refs = calloc(cache->nref, sizeof(cache->refs[0]));\n            if (!cache->refs) {\n                print_error_errno(\"calmd\",\n                                  \"couldn't allocate reference cache\");\n                return -1;\n            }\n            // Add the reference we already have as the first entry\n            if (cache->last_tid >= 0 && cache->last_tid < cache->nref) {\n                cache->refs[cache->last_tid].ref = cache->last_ref;\n                cache->refs[cache->last_tid].len = cache->last_len;\n            } else {\n                free(cache->last_ref);\n            }\n            cache->last_ref = NULL;\n        }\n    }\n\n    if (cache->refs) {\n        assert(cache->last_ref == NULL);  // Shouldn't be set when caching\n        // Add the new reference to the cache\n        if (tid >= 0 && tid < cache->nref) {\n            cache->refs[tid].ref = ref;\n            cache->refs[tid].len = len;\n        }\n    } else {\n        // Streaming mode - free the last ref and replace it with this one\n        free(cache->last_ref);\n        cache->last_ref = ref;\n        cache->last_len = len;\n    }\n\n    *ref_out = ref;\n    *len_out = len;\n    cache->last_tid = tid;\n    return 0;\n}\n\nstatic void refs_destroy(ref_cache *cache) {\n    if (cache->refs) {\n        int i;\n        assert(cache->last_ref == NULL);\n        for (i = 0; i < cache->nref; i++)\n            free(cache->refs[i].ref);\n        free(cache->refs);\n    } else {\n        free(cache->last_ref);\n    }\n}\n\nint calmd_usage(void) {\n    fprintf(stderr,\n\"Usage: samtools calmd [-eubrAESQ] <aln.bam> <ref.fasta>\\n\"\n\"Options:\\n\"\n\"  -e       change identical bases to '='\\n\"\n\"  -u       uncompressed BAM output (for piping)\\n\"\n\"  -b       compressed BAM output\\n\"\n\"  -S       ignored (input format is auto-detected)\\n\"\n\"  -A       modify the quality string\\n\"\n\"  -Q       use quiet mode to output less debug info to stdout\\n\"\n\"  -r       compute the BQ tag (without -A) or cap baseQ by BAQ (with -A)\\n\"\n\"  -E       extended BAQ for better sensitivity but lower specificity\\n\"\n\"  --no-PG  do not add a PG line\\n\");\n\n    sam_global_opt_help(stderr, \"-....@-.\");\n    return 1;\n}\n\nint bam_fillmd(int argc, char *argv[])\n{\n    int c, flt_flag, ret, is_bam_out, is_uncompressed, max_nm, is_realn, capQ, baq_flag, quiet_mode, no_pg = 0;\n    hts_pos_t len = 0;\n    htsThreadPool p = {NULL, 0};\n    samFile *fp = NULL, *fpout = NULL;\n    sam_hdr_t *header = NULL;\n    faidx_t *fai = NULL;\n    char *ref = NULL, mode_w[8], *ref_file, *arg_list = NULL;\n    ref_cache refs = { NULL, NULL, 0, 0, -2 };\n    const char *ref_name = NULL;\n    bam1_t *b = NULL;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    uint32_t skipped = 0;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 0, 0, 0,'@'),\n        {\"no-PG\", no_argument, NULL, 1},\n        { NULL, 0, NULL, 0 }\n    };\n\n    flt_flag = UPDATE_NM | UPDATE_MD;\n    is_bam_out = is_uncompressed = is_realn = max_nm = capQ = baq_flag = quiet_mode = 0;\n    strcpy(mode_w, \"w\");\n    while ((c = getopt_long(argc, argv, \"EqQreuNhbSC:n:Ad@:\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'r': is_realn = 1; break;\n        case 'e': flt_flag |= USE_EQUAL; break;\n        case 'd': flt_flag |= DROP_TAG; break;\n        case 'q': flt_flag |= BIN_QUAL; break;\n        case 'h': flt_flag |= HASH_QNM; break;\n        case 'N': flt_flag &= ~(UPDATE_MD|UPDATE_NM); break;\n        case 'b': is_bam_out = 1; break;\n        case 'u': is_uncompressed = is_bam_out = 1; break;\n        case 'S': break;\n        case 'n': max_nm = atoi(optarg); break;\n        case 'C': capQ = atoi(optarg); break;\n        case 'A': baq_flag |= 1; break;\n        case 'E': baq_flag |= 2; break;\n        case 'Q': quiet_mode = 1; break;\n        case 1: no_pg = 1; break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            fprintf(stderr, \"[bam_fillmd] unrecognized option '-%c'\\n\\n\", c);\n            /* else fall-through */\n        case '?': return calmd_usage();\n        }\n    }\n    if (is_bam_out) strcat(mode_w, \"b\");\n    else strcat(mode_w, \"h\");\n    if (is_uncompressed) strcat(mode_w, \"0\");\n    if (optind + (ga.reference == NULL) >= argc)\n        return calmd_usage();\n    fp = sam_open_format(argv[optind], \"r\", &ga.in);\n    if (fp == NULL) {\n        print_error_errno(\"calmd\", \"Failed to open input file '%s'\", argv[optind]);\n        return 1;\n    }\n\n    if (!no_pg && !(arg_list = stringify_argv(argc+1, argv-1))) {\n        print_error(\"calmd\", \"failed to create arg_list\");\n        return 1;\n    }\n\n    header = sam_hdr_read(fp);\n    if (header == NULL || sam_hdr_nref(header) == 0) {\n        // NB: if we have no SQ headers but have aligned data, then this will\n        // be caught during processing with e.g.\n        // \"[E::sam_parse1] no SQ lines present in the header\"\n        fprintf(stderr, \"[bam_fillmd] warning: input SAM does not have \"\n                \"header, performing a no-op.\\n\");\n    }\n\n    fpout = sam_open_format(\"-\", mode_w, &ga.out);\n    if (fpout == NULL) {\n        print_error_errno(\"calmd\", \"Failed to open output\");\n        goto fail;\n    }\n    if (!no_pg && sam_hdr_add_pg(header, \"samtools\",\n                                 \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL)) {\n        print_error(\"calmd\", \"failed to add PG line to header\");\n        goto fail;\n    }\n    if (sam_hdr_write(fpout, header) < 0) {\n        print_error_errno(\"calmd\", \"Failed to write sam header\");\n        goto fail;\n    }\n\n    if (ga.nthreads > 0) {\n        if (!(p.pool = hts_tpool_init(ga.nthreads))) {\n            fprintf(stderr, \"Error creating thread pool\\n\");\n            goto fail;\n        }\n        hts_set_opt(fp,    HTS_OPT_THREAD_POOL, &p);\n        hts_set_opt(fpout, HTS_OPT_THREAD_POOL, &p);\n    }\n\n    ref_file = argc > optind + 1 ? argv[optind+1] : ga.reference;\n    fai = fai_load(ref_file);\n\n    if (!fai) {\n        print_error_errno(\"calmd\", \"Failed to open reference file '%s'\", ref_file);\n        goto fail;\n    }\n\n    b = bam_init1();\n    if (!b) {\n        fprintf(stderr, \"[bam_fillmd] Failed to allocate bam struct\\n\");\n        goto fail;\n    }\n    while ((ret = sam_read1(fp, header, b)) >= 0) {\n        if (b->core.tid >= 0) {\n            if (refs.last_tid != b->core.tid) {\n                if (get_ref(fai, header, &refs, b->core.tid,\n                            &ref, &ref_name, &len) < 0) {\n                    goto fail;\n                }\n                if (ref == 0) { // FIXME: Should this always be fatal?\n                    fprintf(stderr, \"[bam_fillmd] fail to find sequence '%s' in the reference.\\n\",\n                            ref_name ? ref_name : \"(unknown)\");\n                    if (is_realn || capQ > 10) goto fail; // Would otherwise crash\n                }\n            }\n            if (is_realn) {\n                if (sam_prob_realn(b, ref, len, baq_flag) < -3) {\n                    print_error_errno(\"calmd\", \"BAQ alignment failed\");\n                    goto fail;\n                }\n            }\n            if (capQ > 10) {\n                int q = sam_cap_mapq(b, ref, len, capQ);\n                if (b->core.qual > q) b->core.qual = q;\n            }\n            if (ref) {\n                if (bam_fillmd1_core(ref_name, b, ref, len, flt_flag, max_nm,\n                                     quiet_mode, &skipped) < 0)\n                    goto fail;\n            }\n        }\n        if (sam_write1(fpout, header, b) < 0) {\n            print_error_errno(\"calmd\", \"failed to write to output file\");\n            goto fail;\n        }\n    }\n    if (ret < -1) {\n        fprintf(stderr, \"[bam_fillmd] Error reading input.\\n\");\n        goto fail;\n    }\n\n    if (skipped) {\n        fprintf(stderr, \"[calmd] Warning: %\"PRIu32\" records skipped due \"\n                \"to no query sequence\\n\",\n                skipped);\n    }\n\n    bam_destroy1(b);\n    sam_hdr_destroy(header);\n\n    free(arg_list);\n    refs_destroy(&refs);\n    fai_destroy(fai);\n    sam_close(fp);\n    if (sam_close(fpout) < 0) {\n        fprintf(stderr, \"[bam_fillmd] error when closing output file\\n\");\n        return 1;\n    }\n    if (p.pool) hts_tpool_destroy(p.pool);\n\n    return 0;\n\n fail:\n    free(arg_list);\n    refs_destroy(&refs);\n    if (b) bam_destroy1(b);\n    if (header) sam_hdr_destroy(header);\n    if (fai) fai_destroy(fai);\n    if (fp) sam_close(fp);\n    if (fpout) sam_close(fpout);\n    if (p.pool) hts_tpool_destroy(p.pool);\n\n    return 1;\n}\n"
        },
        {
          "name": "bam_plbuf.c",
          "type": "blob",
          "size": 2.076171875,
          "content": "/*  bam_plbuf.c -- plbuf routines (previously in bam_pileup.c).\n\n    Copyright (C) 2008-2010, 2013 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <htslib/hts.h>\n#include <htslib/sam.h>\n#include \"bam_plbuf.h\"\n\n/*****************\n * callback APIs *\n *****************/\n\nvoid bam_plbuf_reset(bam_plbuf_t *buf)\n{\n    bam_plp_reset(buf->iter);\n}\n\nbam_plbuf_t *bam_plbuf_init(bam_pileup_f func, void *data)\n{\n    bam_plbuf_t *buf;\n    buf = calloc(1, sizeof(bam_plbuf_t));\n    buf->iter = bam_plp_init(0, 0);\n    buf->func = func;\n    buf->data = data;\n    return buf;\n}\n\nvoid bam_plbuf_destroy(bam_plbuf_t *buf)\n{\n    bam_plp_destroy(buf->iter);\n    free(buf);\n}\n\nint bam_plbuf_push(const bam1_t *b, bam_plbuf_t *buf)\n{\n    int ret, n_plp, tid;\n    hts_pos_t pos;\n    const bam_pileup1_t *plp;\n    ret = bam_plp_push(buf->iter, b);\n    if (ret < 0) return ret;\n    while ((plp = bam_plp64_next(buf->iter, &tid, &pos, &n_plp)) != 0)\n        buf->func(tid, pos, n_plp, plp, buf->data);\n    return 0;\n}\n"
        },
        {
          "name": "bam_plbuf.h",
          "type": "blob",
          "size": 1.822265625,
          "content": "/*  bam_plbuf.h -- plbuf routines (declarations copied from bam.h).\n\n    Copyright (C) 2008, 2013, 2021 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BAM_PLBUF_H\n#define BAM_PLBUF_H\n\n#include <htslib/sam.h>\n\n#ifndef BAM_PILEUP_F_DEFINED\n#define BAM_PILEUP_F_DEFINED\ntypedef int (*bam_pileup_f)(uint32_t tid, hts_pos_t pos, int n, const bam_pileup1_t *pl, void *data);\n#endif //BAM_PILEUP_F_DEFINED\n\ntypedef struct {\n    bam_plp_t iter;\n    bam_pileup_f func;\n    void *data;\n} bam_plbuf_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/* Exported from bam_plbuf.c */\nvoid bam_plbuf_reset(bam_plbuf_t *buf);\n\nbam_plbuf_t *bam_plbuf_init(bam_pileup_f func, void *data);\n\nvoid bam_plbuf_destroy(bam_plbuf_t *buf);\n\nint bam_plbuf_push(const bam1_t *b, bam_plbuf_t *buf);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // BAM_PLBUF_H\n"
        },
        {
          "name": "bam_plcmd.c",
          "type": "blob",
          "size": 45.6787109375,
          "content": "/*  bam_plcmd.c -- mpileup subcommand.\n\n    Copyright (C) 2008-2015, 2019-2021, 2023-2024 Genome Research Ltd.\n    Portions copyright (C) 2009-2012 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <string.h>\n#include <strings.h>\n#include <limits.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <htslib/sam.h>\n#include <htslib/faidx.h>\n#include <htslib/kstring.h>\n#include <htslib/klist.h>\n#include <htslib/khash_str2int.h>\n#include <htslib/cram.h>\n#include \"samtools.h\"\n#include \"bedidx.h\"\n#include \"sam_opts.h\"\n#include \"bam_plbuf.h\"\n\n#define dummy_free(p)\nKLIST_INIT(auxlist, char *, dummy_free)\n\nint pileup_seq(kstring_t *ks_seq, const bam_pileup1_t *p, hts_pos_t pos,\n               hts_pos_t ref_len, const char *ref, kstring_t *ks_mod,\n               int rev_del, int no_ins, int no_ins_mods,\n               int no_del, int no_ends)\n{\n    no_ins_mods |= no_ins;\n    int j, err = 0;\n    hts_base_mod_state *m = p->cd.p;\n    if (!no_ends && p->is_head) {\n        err |= kputc_('^', ks_seq) < 0;\n        err |= kputc_(p->b->core.qual > 93 ? 126 : p->b->core.qual + 33,\n                      ks_seq) < 0;\n    }\n    if (!p->is_del) {\n        // See seq_nt16_str in htslib/hts.c\n        const char seq_nt_str_lc[] = \",acmgrsvtwyhkdbn\"; // reverse strand\n        const char seq_nt_str_uc[] = \".ACMGRSVTWYHKDBN\";\n        int c = p->qpos < p->b->core.l_qseq\n            ? bam_seqi(bam_get_seq(p->b), p->qpos)\n            : 15 /*N*/;\n        if (ref) {\n            int rb = pos < ref_len\n                ? seq_nt16_table[(uint8_t)(ref[pos])]\n                : 15/*N*/;\n            if (c == rb)\n                c = 0; // \"=\", which becomes . or ,\n        }\n        c = bam_is_rev(p->b)\n            ? seq_nt_str_lc[c]\n            : seq_nt_str_uc[c];\n        err |= kputc_(c, ks_seq) < 0;\n\n        if (m) {\n            int nm;\n            hts_base_mod mod[256];\n            if ((nm = bam_mods_at_qpos(p->b, p->qpos, m, mod, 256)) > 0) {\n                err |= kputc_('[', ks_seq) < 0;\n                int j;\n                for (j = 0; j < nm && j < 256; j++) {\n                    char qual[20];\n                    if (mod[j].qual >= 0)\n                        sprintf(qual, \"%d\", mod[j].qual);\n                    else\n                        *qual = 0;\n                    if (mod[j].modified_base < 0)\n                        // ChEBI\n                        err |= ksprintf(ks_seq, \"%c(%d)%s\",\n                                        \"+-\"[mod[j].strand],\n                                        -mod[j].modified_base, qual) < 0;\n                    else\n                        err |= ksprintf(ks_seq, \"%c%c%s\", \"+-\"[mod[j].strand],\n                                        mod[j].modified_base, qual) < 0;\n                }\n                err |= kputc_(']', ks_seq) < 0;\n            }\n        }\n    } else {\n        err |= kputc_(p->is_refskip\n                      ? (bam_is_rev(p->b)? '<' : '>')\n                      : ((bam_is_rev(p->b) && rev_del) ? '#' : '*'),\n                      ks_seq) < 0;\n    }\n\n    int del_len = -p->indel;\n    if (p->indel > 0) {\n        int len = bam_plp_insertion_mod(p, m && !no_ins_mods ? m : NULL,\n                                        ks_mod, &del_len);\n        if (len < 0) {\n            print_error(\"mpileup\", \"bam_plp_insertion() failed\");\n            return -1;\n        }\n        if (no_ins < 2) {\n            err |= kputc_('+', ks_seq) < 0;\n            err |= kputuw(len, ks_seq) < 0;\n        }\n        if (!no_ins) {\n            kstring_t *ks = ks_mod;\n            if (bam_is_rev(p->b)) {\n                char pad = rev_del ? '#' : '*';\n                int in_mod = 0;\n                for (j = 0; j < ks->l; j++) {\n                    if (ks->s[j] == '[') in_mod = 1;\n                    else if (ks->s[j] == ']') in_mod = 0;\n                    err |= kputc_(ks->s[j] != '*'\n                                  ? (in_mod ? ks->s[j] : tolower(ks->s[j]))\n                                  : pad, ks_seq) < 0;\n                }\n            } else {\n                int in_mod = 0;\n                for (j = 0; j < ks->l; j++) {\n                    if (ks->s[j] == '[') in_mod = 1;\n                    if (ks->s[j] == ']') in_mod = 0;\n                    err |= kputc_(in_mod ? ks->s[j] : toupper(ks->s[j]),\n                                  ks_seq) < 0;\n                }\n            }\n        }\n    }\n\n    if (del_len > 0) {\n        if (no_del < 2)\n            err |= kputw(-del_len, ks_seq) < 0;\n        if (!no_del) {\n            for (j = 1; j <= del_len; ++j) {\n                int c = (ref && (int)pos+j < ref_len)? ref[pos+j] : 'N';\n                err |= kputc_(bam_is_rev(p->b)? tolower(c) : toupper(c),\n                              ks_seq) < 0;\n            }\n        }\n    }\n\n    if (!no_ends && p->is_tail)\n        err |= kputc_('$', ks_seq) < 0;\n\n    return -err;\n}\n\n#include \"sample.h\"\n\n#define MPLP_NO_COMP    (1<<2)\n#define MPLP_NO_ORPHAN  (1<<3)\n#define MPLP_REALN      (1<<4)\n#define MPLP_NO_INDEL   (1<<5)\n#define MPLP_REDO_BAQ   (1<<6)\n#define MPLP_ILLUMINA13 (1<<7)\n#define MPLP_IGNORE_RG  (1<<8)\n#define MPLP_SMART_OVERLAPS (1<<10)\n\n#define MPLP_PRINT_MAPQ_CHAR (1<<11)\n#define MPLP_PRINT_QPOS  (1<<12)\n// Start of struct active_cols elements\n#define MPLP_PRINT_QNAME (1<<13)\n#define MPLP_PRINT_FLAG  (1<<14)\n#define MPLP_PRINT_RNAME (1<<15)\n#define MPLP_PRINT_POS   (1<<16)\n#define MPLP_PRINT_MAPQ  (1<<17)\n#define MPLP_PRINT_CIGAR (1<<18)\n#define MPLP_PRINT_RNEXT (1<<19)\n#define MPLP_PRINT_PNEXT (1<<20)\n#define MPLP_PRINT_TLEN  (1<<21)\n#define MPLP_PRINT_SEQ   (1<<22)\n#define MPLP_PRINT_QUAL  (1<<23)\n#define MPLP_PRINT_RLEN  (1<<24)\n// Must occur after struct active_cols element list\n#define MPLP_PRINT_MODS  (1<<25)\n#define MPLP_PRINT_QPOS5 (1<<26)\n\n#define MPLP_PRINT_LAST  (1<<27) // terminator for loop\n\n#define MPLP_MAX_DEPTH 8000\n#define MPLP_MAX_INDEL_DEPTH 250\n\ntypedef struct {\n    int min_mq, flag, min_baseQ, capQ_thres, max_depth, max_indel_depth, all, rev_del;\n    int rflag_require, rflag_filter;\n    char *reg, *pl_list, *fai_fname, *output_fname;\n    faidx_t *fai;\n    void *bed, *rghash, *auxlist;\n    int argc;\n    char **argv;\n    char sep, empty, no_ins, no_ins_mods, no_del, no_ends;\n    sam_global_args ga;\n} mplp_conf_t;\n\ntypedef struct {\n    char *ref[2];\n    int ref_id[2];\n    hts_pos_t ref_len[2];\n} mplp_ref_t;\n\n#define MPLP_REF_INIT {{NULL,NULL},{-1,-1},{0,0}}\n\ntypedef struct {\n    samFile *fp;\n    hts_itr_t *iter;\n    sam_hdr_t *h;\n    mplp_ref_t *ref;\n    const mplp_conf_t *conf;\n} mplp_aux_t;\n\ntypedef struct {\n    int n;\n    int *n_plp, *m_plp;\n    bam_pileup1_t **plp;\n} mplp_pileup_t;\n\nstatic int build_auxlist(mplp_conf_t *conf, char *optstring) {\n    if (!optstring)\n        return 0;\n\n    void *colhash = khash_str2int_init();\n    if (!colhash)\n        return 1;\n\n    struct active_cols {\n        char *name;\n        int supported;\n    };\n\n    const struct active_cols colnames[12] = {\n            {\"QNAME\", 1}, {\"FLAG\", 1}, {\"RNAME\", 1}, {\"POS\", 1}, {\"MAPQ\", 1},\n            {\"CIGAR\", 0}, {\"RNEXT\", 1}, {\"PNEXT\", 1}, {\"TLEN\", 0}, {\"SEQ\", 0},\n            {\"QUAL\", 0},  {\"RLEN\", 1},\n    };\n\n    int i, f = MPLP_PRINT_QNAME, colno = sizeof(colnames)/sizeof(*colnames);\n    for (i = 0; i < colno; i++, f <<= 1)\n        if (colnames[i].supported)\n            khash_str2int_set(colhash, colnames[i].name, f);\n\n    conf->auxlist = kl_init(auxlist);\n    if (!conf->auxlist)\n        return 1;\n\n    char *save_p;\n    char *tag = strtok_r(optstring, \",\", &save_p);\n    while (tag) {\n        if (khash_str2int_get(colhash, tag, &f) == 0) {\n            conf->flag |= f;\n        } else {\n            if (strlen(tag) != 2) {\n                fprintf(stderr, \"[%s] tag '%s' has more than two characters or not supported\\n\", __func__, tag);\n            } else {\n                char **tag_p = kl_pushp(auxlist, conf->auxlist);\n                *tag_p = tag;\n            }\n        }\n        tag = strtok_r(NULL, \",\", &save_p);\n    }\n\n    khash_str2int_destroy(colhash);\n\n    return 0;\n}\n\nstatic int mplp_get_ref(mplp_aux_t *ma, int tid, char **ref, hts_pos_t *ref_len) {\n    mplp_ref_t *r = ma->ref;\n\n    //printf(\"get ref %d {%d/%p, %d/%p}\\n\", tid, r->ref_id[0], r->ref[0], r->ref_id[1], r->ref[1]);\n\n    if (!r || !ma->conf->fai) {\n        *ref = NULL;\n        return 0;\n    }\n\n    // Do we need to reference count this so multiple mplp_aux_t can\n    // track which references are in use?\n    // For now we just cache the last two. Sufficient?\n    if (tid == r->ref_id[0]) {\n        *ref = r->ref[0];\n        *ref_len = r->ref_len[0];\n        return 1;\n    }\n    if (tid == r->ref_id[1]) {\n        // Last, swap over\n        int tmp_id;\n        hts_pos_t tmp_len;\n        tmp_id  = r->ref_id[0];  r->ref_id[0]  = r->ref_id[1];  r->ref_id[1]  = tmp_id;\n        tmp_len = r->ref_len[0]; r->ref_len[0] = r->ref_len[1]; r->ref_len[1] = tmp_len;\n\n        char *tc;\n        tc = r->ref[0]; r->ref[0] = r->ref[1]; r->ref[1] = tc;\n        *ref = r->ref[0];\n        *ref_len = r->ref_len[0];\n        return 1;\n    }\n\n    // New, so migrate to old and load new\n    free(r->ref[1]);\n    r->ref[1]     = r->ref[0];\n    r->ref_id[1]  = r->ref_id[0];\n    r->ref_len[1] = r->ref_len[0];\n\n    r->ref_id[0] = tid;\n    r->ref[0] = faidx_fetch_seq64(ma->conf->fai,\n                                sam_hdr_tid2name(ma->h, r->ref_id[0]),\n                                0,\n                                HTS_POS_MAX,\n                                &r->ref_len[0]);\n\n    if (!r->ref[0]) {\n        r->ref[0] = NULL;\n        r->ref_id[0] = -1;\n        r->ref_len[0] = 0;\n        *ref = NULL;\n        return 0;\n    }\n\n    *ref = r->ref[0];\n    *ref_len = r->ref_len[0];\n    return 1;\n}\n\n// Initialise and destroy the base modifier state data. This is called\n// as each new read is added or removed from the pileups.\nstatic\nint pileup_cd_create(void *data, const bam1_t *b, bam_pileup_cd *cd) {\n    int ret;\n    hts_base_mod_state *m = hts_base_mod_state_alloc();\n    ret = bam_parse_basemod(b, m);\n    cd->p = m;\n    return ret;\n}\n\nstatic\nint pileup_cd_destroy(void *data, const bam1_t *b, bam_pileup_cd *cd) {\n    hts_base_mod_state_free(cd->p);\n    return 0;\n}\n\nstatic void\nprint_empty_pileup(FILE *fp, const mplp_conf_t *conf, const char *tname,\n                   hts_pos_t pos, int n, const char *ref, hts_pos_t ref_len)\n{\n    int i;\n    fprintf(fp, \"%s\\t%\"PRIhts_pos\"\\t%c\", tname, pos+1, (ref && pos < ref_len)? ref[pos] : 'N');\n    for (i = 0; i < n; ++i) {\n        fputs(\"\\t0\\t*\\t*\", fp);\n        int flag_value = MPLP_PRINT_MAPQ_CHAR;\n        while(flag_value < MPLP_PRINT_LAST) {\n            if (flag_value != MPLP_PRINT_MODS && (conf->flag & flag_value))\n                fputs(\"\\t*\", fp);\n            flag_value <<= 1;\n        }\n        if (conf->auxlist) {\n            int t = 0;\n            while(t++ < ((klist_t(auxlist) *)conf->auxlist)->size)\n                fputs(\"\\t*\", fp);\n        }\n    }\n    putc('\\n', fp);\n}\n\nstatic int mplp_func(void *data, bam1_t *b)\n{\n    char *ref;\n    mplp_aux_t *ma = (mplp_aux_t*)data;\n    int ret, skip = 0;\n    hts_pos_t ref_len;\n\n    do {\n        int has_ref;\n        ret = ma->iter? sam_itr_next(ma->fp, ma->iter, b) : sam_read1(ma->fp, ma->h, b);\n        if (ret < 0) break;\n        // The 'B' cigar operation is not part of the specification, considering as obsolete.\n        //  bam_remove_B(b);\n        if (b->core.tid < 0 || (b->core.flag&BAM_FUNMAP)) { // exclude unmapped reads\n            skip = 1;\n            continue;\n        }\n        if (ma->conf->rflag_require && !(ma->conf->rflag_require&b->core.flag)) { skip = 1; continue; }\n        if (ma->conf->rflag_filter && ma->conf->rflag_filter&b->core.flag) { skip = 1; continue; }\n        if (ma->conf->bed && ma->conf->all == 0) { // test overlap\n            skip = !bed_overlap(ma->conf->bed, sam_hdr_tid2name(ma->h, b->core.tid), b->core.pos, bam_endpos(b));\n            if (skip) continue;\n        }\n        if (ma->conf->rghash) { // exclude read groups\n            uint8_t *rg = bam_aux_get(b, \"RG\");\n            skip = (rg && khash_str2int_get(ma->conf->rghash, (const char*)(rg+1), NULL)==0);\n            if (skip) continue;\n        }\n        if (ma->conf->flag & MPLP_ILLUMINA13) {\n            int i;\n            uint8_t *qual = bam_get_qual(b);\n            for (i = 0; i < b->core.l_qseq; ++i)\n                qual[i] = qual[i] > 31? qual[i] - 31 : 0;\n        }\n\n        if (ma->conf->fai && b->core.tid >= 0) {\n            has_ref = mplp_get_ref(ma, b->core.tid, &ref, &ref_len);\n            if (has_ref && ref_len <= b->core.pos) { // exclude reads outside of the reference sequence\n                fprintf(stderr,\"[%s] Skipping because %\"PRIhts_pos\" is outside of %\"PRIhts_pos\" [ref:%d]\\n\",\n                        __func__, (int64_t) b->core.pos, ref_len, b->core.tid);\n                skip = 1;\n                continue;\n            }\n        } else {\n            has_ref = 0;\n        }\n\n        skip = 0;\n        if (has_ref && (ma->conf->flag&MPLP_REALN)) sam_prob_realn(b, ref, ref_len, (ma->conf->flag & MPLP_REDO_BAQ)? 7 : 3);\n        if (has_ref && ma->conf->capQ_thres > 10) {\n            int q = sam_cap_mapq(b, ref, ref_len, ma->conf->capQ_thres);\n            if (q < 0) skip = 1;\n            else if (b->core.qual > q) b->core.qual = q;\n        }\n        if (b->core.qual < ma->conf->min_mq) skip = 1;\n        else if ((ma->conf->flag&MPLP_NO_ORPHAN) && (b->core.flag&BAM_FPAIRED) && !(b->core.flag&BAM_FPROPER_PAIR)) skip = 1;\n    } while (skip);\n    return ret;\n}\n\n/*\n * Performs pileup\n * @param conf configuration for this pileup\n * @param n number of files specified in fn\n * @param fn filenames\n * @param fn_idx index filenames\n */\nstatic int mpileup(mplp_conf_t *conf, int nfn, char **fn, char **fn_idx)\n{\n    mplp_aux_t **data;\n    int i, tid, *n_plp, tid0 = 0, max_depth;\n    hts_pos_t pos, beg0 = 0, end0 = HTS_POS_MAX, ref_len;\n    const bam_pileup1_t **plp;\n    mplp_ref_t mp_ref = MPLP_REF_INIT;\n    bam_mplp_t iter;\n    sam_hdr_t *h = NULL; /* header of first file in input list */\n    char *ref;\n    FILE *pileup_fp = NULL;\n\n    bam_sample_t *sm = NULL;\n    kstring_t buf;\n    mplp_pileup_t gplp;\n\n    memset(&gplp, 0, sizeof(mplp_pileup_t));\n    memset(&buf, 0, sizeof(kstring_t));\n    data = calloc(nfn, sizeof(mplp_aux_t*));\n    plp = calloc(nfn, sizeof(bam_pileup1_t*));\n    n_plp = calloc(nfn, sizeof(int));\n    sm = bam_smpl_init();\n\n    if (nfn == 0) {\n        fprintf(stderr,\"[%s] no input file/data given\\n\", __func__);\n        exit(EXIT_FAILURE);\n    }\n\n    // read the header of each file in the list and initialize data\n    refs_t *refs = NULL;\n    for (i = 0; i < nfn; ++i) {\n        sam_hdr_t *h_tmp;\n        data[i] = calloc(1, sizeof(mplp_aux_t));\n        data[i]->fp = sam_open_format(fn[i], \"rb\", &conf->ga.in);\n        if ( !data[i]->fp )\n        {\n            fprintf(stderr, \"[%s] failed to open %s: %s\\n\", __func__, fn[i], strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        if (hts_set_opt(data[i]->fp, CRAM_OPT_DECODE_MD, 0)) {\n            fprintf(stderr, \"Failed to set CRAM_OPT_DECODE_MD value\\n\");\n            exit(EXIT_FAILURE);\n        }\n\n        if (!refs && conf->fai_fname) {\n            if (hts_set_fai_filename(data[i]->fp, conf->fai_fname) != 0) {\n                fprintf(stderr, \"[%s] failed to process %s: %s\\n\",\n                        __func__, conf->fai_fname, strerror(errno));\n                exit(EXIT_FAILURE);\n            }\n            refs = cram_get_refs(data[i]->fp);\n        } else if (conf->fai_fname) {\n            if (hts_set_opt(data[i]->fp, CRAM_OPT_SHARED_REF, refs) != 0) {\n                fprintf(stderr, \"[%s] failed to process %s: %s\\n\",\n                        __func__, conf->fai_fname, strerror(errno));\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        data[i]->conf = conf;\n        data[i]->ref = &mp_ref;\n        h_tmp = sam_hdr_read(data[i]->fp);\n        if ( !h_tmp ) {\n            fprintf(stderr,\"[%s] fail to read the header of %s\\n\", __func__, fn[i]);\n            exit(EXIT_FAILURE);\n        }\n        bam_smpl_add(sm, fn[i], (conf->flag&MPLP_IGNORE_RG)? 0 : sam_hdr_str(h_tmp));\n        if (conf->reg) {\n            hts_idx_t *idx = NULL;\n            // If index filename has not been specfied, look in BAM folder\n            if (fn_idx != NULL)  {\n                idx = sam_index_load2(data[i]->fp, fn[i], fn_idx[i]);\n            } else {\n                idx = sam_index_load(data[i]->fp, fn[i]);\n            }\n\n            if (idx == NULL) {\n                fprintf(stderr, \"[%s] fail to load index for %s\\n\", __func__, fn[i]);\n                exit(EXIT_FAILURE);\n            }\n            if ( (data[i]->iter=sam_itr_querys(idx, h_tmp, conf->reg)) == 0) {\n                fprintf(stderr, \"[E::%s] fail to parse region '%s' with %s\\n\", __func__, conf->reg, fn[i]);\n                exit(EXIT_FAILURE);\n            }\n            if (i == 0) beg0 = data[i]->iter->beg, end0 = data[i]->iter->end, tid0 = data[i]->iter->tid;\n            hts_idx_destroy(idx);\n        }\n        else\n            data[i]->iter = NULL;\n\n        if (i == 0) h = data[i]->h = h_tmp; // save the header of the first file\n        else {\n            // FIXME: check consistency between h and h_tmp\n            sam_hdr_destroy(h_tmp);\n\n            // we store only the first file's header; it's (alleged to be)\n            // compatible with the i-th file's target_name lookup needs\n            data[i]->h = h;\n        }\n    }\n    fprintf(stderr, \"[%s] %d samples in %d input files\\n\",\n            __func__, sm->n, nfn);\n\n    pileup_fp = conf->output_fname? fopen(conf->output_fname, \"w\") : stdout;\n\n    if (pileup_fp == NULL) {\n        fprintf(stderr, \"[%s] failed to write to %s: %s\\n\", __func__, conf->output_fname, strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    // init pileup\n    iter = bam_mplp_init(nfn, mplp_func, (void**)data);\n    if (conf->flag & MPLP_PRINT_MODS) {\n        bam_mplp_constructor(iter, pileup_cd_create);\n        bam_mplp_destructor(iter, pileup_cd_destroy);\n    }\n    if ( conf->flag & MPLP_SMART_OVERLAPS ) bam_mplp_init_overlaps(iter);\n    if ( !conf->max_depth ) {\n        max_depth = INT_MAX;\n        fprintf(stderr, \"[%s] Max depth set to maximum value (%d)\\n\", __func__, INT_MAX);\n    } else {\n        max_depth = conf->max_depth;\n        if ( max_depth * nfn > 1<<20 )\n            fprintf(stderr, \"[%s] Combined max depth is above 1M. Potential memory hog!\\n\", __func__);\n    }\n\n\n    bam_mplp_set_maxcnt(iter, max_depth);\n    int ret;\n    int last_tid = -1;\n    hts_pos_t last_pos = -1;\n    int one_seq = 0;\n\n    // begin pileup\n    kstring_t ks_seq = KS_INITIALIZE;\n    kstring_t ks_mod = KS_INITIALIZE;\n    kstring_t ks_qual = KS_INITIALIZE;\n    while ( (ret=bam_mplp64_auto(iter, &tid, &pos, n_plp, plp)) > 0) {\n        one_seq = 1; // at least 1 output\n        if (conf->reg && (pos < beg0 || pos >= end0)) continue; // out of the region requested\n        if (conf->all) {\n            // Deal with missing portions of previous tids\n            while (tid > last_tid) {\n                if (last_tid >= 0 && !conf->reg) {\n                    while (++last_pos < sam_hdr_tid2len(h, last_tid)) {\n                        if (conf->bed && bed_overlap(conf->bed, sam_hdr_tid2name(h, last_tid), last_pos, last_pos + 1) == 0)\n                            continue;\n                        print_empty_pileup(pileup_fp, conf, sam_hdr_tid2name(h, last_tid), last_pos, nfn, ref, ref_len);\n                    }\n                }\n                last_tid++;\n                last_pos = -1;\n                if (conf->all < 2)\n                    break;\n                if (tid > last_tid)\n                    // multiple missing references and -aa used\n                    mplp_get_ref(data[0], last_tid, &ref, &ref_len);\n            }\n        }\n        mplp_get_ref(data[0], tid, &ref, &ref_len);\n\n        if (conf->all) {\n            // Deal with missing portion of current tid\n            while (++last_pos < pos) {\n                if (conf->reg && last_pos < beg0) continue; // out of range; skip\n                if (conf->bed && bed_overlap(conf->bed, sam_hdr_tid2name(h, tid), last_pos, last_pos + 1) == 0)\n                    continue;\n                print_empty_pileup(pileup_fp, conf, sam_hdr_tid2name(h, tid), last_pos, nfn, ref, ref_len);\n            }\n            last_tid = tid;\n            last_pos = pos;\n        }\n        if (conf->bed && tid >= 0 && !bed_overlap(conf->bed, sam_hdr_tid2name(h, tid), pos, pos+1)) continue;\n\n        fprintf(pileup_fp, \"%s\\t%\"PRIhts_pos\"\\t%c\", sam_hdr_tid2name(h, tid), pos + 1, (ref && pos < ref_len)? ref[pos] : 'N');\n        for (i = 0; i < nfn; ++i) {\n            int j, cnt, err = 0;\n            ks_clear(&ks_seq);\n            ks_clear(&ks_qual);\n            ks_clear(&ks_mod);\n            for (j = cnt = 0; j < n_plp[i]; ++j) {\n                const bam_pileup1_t *p = plp[i] + j;\n                int c = p->qpos < p->b->core.l_qseq\n                    ? bam_get_qual(p->b)[p->qpos]\n                    : 0;\n                if (c >= conf->min_baseQ) {\n                    // Build up seq\n                    err |= pileup_seq(&ks_seq, plp[i] + j, pos, ref_len,\n                                      ref, &ks_mod, conf->rev_del,\n                                      conf->no_ins, conf->no_ins_mods,\n                                      conf->no_del, conf->no_ends) < 0;\n\n                    // Build up qual\n                    err |= kputc_(c+33 < 126 ? c+33 : 126, &ks_qual) < 0;\n                    cnt++;\n                }\n            }\n            if (err) {\n                ret = 1;\n                goto fail;\n            }\n            fprintf(pileup_fp, \"\\t%d\\t\", cnt);\n\n            if (n_plp[i] == 0) {\n                fputs(\"*\\t*\", pileup_fp);\n                int flag_value = MPLP_PRINT_MAPQ_CHAR;\n                while(flag_value < MPLP_PRINT_LAST) {\n                    if (flag_value != MPLP_PRINT_MODS\n                        && (conf->flag & flag_value))\n                        fputs(\"\\t*\", pileup_fp);\n                    flag_value <<= 1;\n                }\n                if (conf->auxlist) {\n                    int t = 0;\n                    while(t++ < ((klist_t(auxlist) *)conf->auxlist)->size)\n                        fputs(\"\\t*\", pileup_fp);\n                }\n            } else {\n                if (ks_seq.l) {\n                    fwrite(ks_seq.s, 1, ks_seq.l, pileup_fp);\n                } else {\n                    putc('*', pileup_fp);\n                }\n                putc('\\t', pileup_fp);\n\n                if (ks_qual.l) {\n                    fwrite(ks_qual.s, 1, ks_qual.l, pileup_fp);\n                } else {\n                    putc('*', pileup_fp);\n                }\n\n                /* Print selected columns */\n                int flag_value = MPLP_PRINT_MAPQ_CHAR;\n                while(flag_value < MPLP_PRINT_LAST) {\n                    if (flag_value != MPLP_PRINT_MODS\n                        && (conf->flag & flag_value)) {\n                        int n = 0;\n                        putc('\\t', pileup_fp);\n                        for (j = 0; j < n_plp[i]; ++j) {\n                            const bam_pileup1_t *p = &plp[i][j];\n                            int c = p->qpos < p->b->core.l_qseq\n                                ? bam_get_qual(p->b)[p->qpos]\n                                : 0;\n                            if ( c < conf->min_baseQ ) continue;\n                            if (n > 0 && flag_value != MPLP_PRINT_MAPQ_CHAR) putc(',', pileup_fp);\n                            n++;\n\n                            switch (flag_value) {\n                            case MPLP_PRINT_MAPQ_CHAR:\n                                c = p->b->core.qual + 33;\n                                if (c > 126) c = 126;\n                                putc(c, pileup_fp);\n                                break;\n                            case MPLP_PRINT_QPOS:\n                                // query position in current orientation\n                                fprintf(pileup_fp, \"%d\", p->qpos + 1);\n                                break;\n                            case MPLP_PRINT_QPOS5: {\n                                // query position in 5' to 3' orientation\n                                int pos5 = bam_is_rev(p->b)\n                                    ? p->b->core.l_qseq-p->qpos + p->is_del\n                                    : p->qpos + 1;\n                                fprintf(pileup_fp, \"%d\", pos5);\n                                break;\n                            }\n                            case MPLP_PRINT_QNAME:\n                                fputs(bam_get_qname(p->b), pileup_fp);\n                                break;\n                            case MPLP_PRINT_FLAG:\n                                fprintf(pileup_fp, \"%d\", p->b->core.flag);\n                                break;\n                            case MPLP_PRINT_RNAME:\n                                if (p->b->core.tid >= 0)\n                                    fputs(sam_hdr_tid2name(h, p->b->core.tid), pileup_fp);\n                                else\n                                    putc('*', pileup_fp);\n                                break;\n                            case MPLP_PRINT_POS:\n                                fprintf(pileup_fp, \"%\"PRId64, (int64_t) p->b->core.pos + 1);\n                                break;\n                            case MPLP_PRINT_MAPQ:\n                                fprintf(pileup_fp, \"%d\", p->b->core.qual);\n                                break;\n                            case MPLP_PRINT_RNEXT:\n                                if (p->b->core.mtid >= 0)\n                                    fputs(sam_hdr_tid2name(h, p->b->core.mtid), pileup_fp);\n                                else\n                                    putc('*', pileup_fp);\n                                break;\n                            case MPLP_PRINT_PNEXT:\n                                fprintf(pileup_fp, \"%\"PRId64, (int64_t) p->b->core.mpos + 1);\n                                break;\n                            case MPLP_PRINT_RLEN:\n                                fprintf(pileup_fp, \"%d\", p->b->core.l_qseq);\n                                break;\n                            }\n                        }\n                        if (!n) putc('*', pileup_fp);\n                    }\n                    flag_value <<= 1;\n                }\n\n                /* Print selected tags */\n                klist_t(auxlist) *auxlist_p = ((klist_t(auxlist) *)conf->auxlist);\n                if (auxlist_p && auxlist_p->size) {\n                    kliter_t(auxlist) *aux;\n                    for (aux = kl_begin(auxlist_p); aux != kl_end(auxlist_p); aux = kl_next(aux)) {\n                        int n = 0; // NB shadows outer loop\n                        putc('\\t', pileup_fp);\n                        for (j = 0; j < n_plp[i]; ++j) {\n                            const bam_pileup1_t *p = &plp[i][j];\n                            int c = p->qpos < p->b->core.l_qseq\n                                ? bam_get_qual(p->b)[p->qpos]\n                                : 0;\n                            if ( c < conf->min_baseQ ) continue;\n\n                            if (n > 0) putc(conf->sep, pileup_fp);\n                            n++;\n                            uint8_t* tag_u = bam_aux_get(p->b, kl_val(aux));\n                            if (!tag_u) {\n                                putc(conf->empty , pileup_fp);\n                                continue;\n                            }\n\n                            int tag_supported = 0;\n\n                            /* Tag value is string */\n                            if (*tag_u == 'Z' || *tag_u == 'H') {\n                                char *tag_s = bam_aux2Z(tag_u);\n                                if (!tag_s) continue;\n                                fputs(tag_s, pileup_fp);\n                                tag_supported = 1;\n                            }\n\n                            /* Tag value is integer */\n                            if (*tag_u == 'I' || *tag_u == 'i' || *tag_u == 'C' || *tag_u == 'c' || *tag_u == 'S' || *tag_u == 's') {\n                                int64_t tag_i = bam_aux2i(tag_u);\n                                fprintf(pileup_fp, \"%\" PRId64 \"\", tag_i);\n                                tag_supported = 1;\n                            }\n\n                            /* Tag value is float */\n                            if (*tag_u == 'd' || *tag_u == 'f') {\n                                double tag_f = bam_aux2f(tag_u);\n                                fprintf(pileup_fp, \"%lf\", tag_f);\n                                tag_supported = 1;\n                            }\n\n                            /* Tag value is character */\n                            if (*tag_u == 'A') {\n                                char tag_c = bam_aux2A(tag_u);\n                                putc(tag_c, pileup_fp);\n                                tag_supported = 1;\n                            }\n\n                            if (!tag_supported) putc('*', pileup_fp);\n                        }\n                        if (!n) putc('*', pileup_fp);\n                    }\n                }\n            }\n        }\n        putc('\\n', pileup_fp);\n    }\n\n    ks_free(&ks_seq);\n    ks_free(&ks_mod);\n    ks_free(&ks_qual);\n\n    if (ret < 0) {\n        print_error(\"mpileup\", \"error reading from input file\");\n        ret = EXIT_FAILURE;\n        goto fail;\n    }\n\n    if (conf->all) {\n        // Handle terminating region\n        if (last_tid < 0 && conf->reg && conf->all > 1) {\n            last_tid = tid0;\n            last_pos = beg0-1;\n            mplp_get_ref(data[0], tid0, &ref, &ref_len);\n        } else if (last_tid < 0 && !one_seq && conf->all > 1) {\n            last_tid = 0; // --aa on a blank file\n        }\n        while (last_tid >= 0 && last_tid < sam_hdr_nref(h)) {\n            mplp_get_ref(data[0], last_tid, &ref, &ref_len);\n            while (++last_pos < sam_hdr_tid2len(h, last_tid)) {\n                if (last_pos >= end0) break;\n                if (conf->bed && bed_overlap(conf->bed, sam_hdr_tid2name(h, last_tid), last_pos, last_pos + 1) == 0)\n                    continue;\n                print_empty_pileup(pileup_fp, conf, sam_hdr_tid2name(h, last_tid), last_pos, nfn, ref, ref_len);\n            }\n            last_tid++;\n            last_pos = -1;\n            if (conf->all < 2 || conf->reg)\n                break;\n        }\n    }\n\nfail:\n    // clean up\n    if (pileup_fp && conf->output_fname) fclose(pileup_fp);\n    bam_smpl_destroy(sm); free(buf.s);\n    for (i = 0; i < gplp.n; ++i) free(gplp.plp[i]);\n    free(gplp.plp); free(gplp.n_plp); free(gplp.m_plp);\n    bam_mplp_destroy(iter);\n    sam_hdr_destroy(h);\n    for (i = 0; i < nfn; ++i) {\n        sam_close(data[i]->fp);\n        if (data[i]->iter) hts_itr_destroy(data[i]->iter);\n        free(data[i]);\n    }\n    free(data); free(plp); free(n_plp);\n    free(mp_ref.ref[0]);\n    free(mp_ref.ref[1]);\n    return ret;\n}\n\nstatic int is_url(const char *s)\n{\n    static const char uri_scheme_chars[] =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+.-\";\n    return s[strspn(s, uri_scheme_chars)] == ':';\n}\n\n#define MAX_PATH_LEN 1024\nint read_file_list(const char *file_list,int *n,char **argv[])\n{\n    char buf[MAX_PATH_LEN];\n    int len, nfiles = 0;\n    char **files = NULL;\n    struct stat sb;\n\n    *n = 0;\n    *argv = NULL;\n\n    FILE *fh = fopen(file_list,\"r\");\n    if ( !fh )\n    {\n        fprintf(stderr,\"%s: %s\\n\", file_list,strerror(errno));\n        return 1;\n    }\n\n    files = calloc(nfiles,sizeof(char*));\n    nfiles = 0;\n    while ( fgets(buf,MAX_PATH_LEN,fh) )\n    {\n        // allow empty lines and trailing spaces\n        len = strlen(buf);\n        while ( len>0 && isspace(buf[len-1]) ) len--;\n        if ( !len ) continue;\n\n        // check sanity of the file list\n        buf[len] = 0;\n        if (! (is_url(buf) || stat(buf, &sb) == 0))\n        {\n            // no such file, check if it is safe to print its name\n            int i, safe_to_print = 1;\n            for (i=0; i<len; i++)\n                if (!isprint(buf[i])) { safe_to_print = 0; break; }\n            if ( safe_to_print )\n                fprintf(stderr,\"The file list \\\"%s\\\" appears broken, could not locate: %s\\n\", file_list,buf);\n            else\n                fprintf(stderr,\"Does the file \\\"%s\\\" really contain a list of files and do all exist?\\n\", file_list);\n            return 1;\n        }\n\n        nfiles++;\n        files = realloc(files,nfiles*sizeof(char*));\n        files[nfiles-1] = strdup(buf);\n    }\n    fclose(fh);\n    if ( !nfiles )\n    {\n        fprintf(stderr,\"No files read from %s\\n\", file_list);\n        return 1;\n    }\n    *argv = files;\n    *n    = nfiles;\n    return 0;\n}\n#undef MAX_PATH_LEN\n\nstatic void print_usage(FILE *fp, const mplp_conf_t *mplp)\n{\n    char *tmp_require = bam_flag2str(mplp->rflag_require);\n    char *tmp_filter  = bam_flag2str(mplp->rflag_filter);\n\n    // Display usage information, formatted for the standard 80 columns.\n    // (The unusual string formatting here aids the readability of this\n    // source code in 80 columns, to the extent that's possible.)\n\n    fprintf(fp,\n\"\\n\"\n\"Usage: samtools mpileup [options] in1.bam [in2.bam [...]]\\n\"\n\"\\n\"\n\"Input options:\\n\"\n\"  -6, --illumina1.3+      quality is in the Illumina-1.3+ encoding\\n\"\n\"  -A, --count-orphans     do not discard anomalous read pairs\\n\"\n\"  -b, --bam-list FILE     list of input BAM filenames, one per line\\n\"\n\"  -B, --no-BAQ            disable BAQ (per-Base Alignment Quality)\\n\"\n\"  -C, --adjust-MQ INT     adjust mapping quality; recommended:50, disable:0 [0]\\n\"\n\"  -d, --max-depth INT     max per-file depth; avoids excessive memory usage [%d]\\n\", mplp->max_depth);\n    fprintf(fp,\n\"  -E, --redo-BAQ          recalculate BAQ on the fly, ignore existing BQs\\n\"\n\"  -f, --fasta-ref FILE    faidx indexed reference sequence file\\n\"\n\"  -G, --exclude-RG FILE   exclude read groups listed in FILE\\n\"\n\"  -l, --positions FILE    skip unlisted positions (chr pos) or regions (BED)\\n\"\n\"  -q, --min-MQ INT        skip alignments with mapQ smaller than INT [%d]\\n\", mplp->min_mq);\n    fprintf(fp,\n\"  -Q, --min-BQ INT        skip bases with baseQ/BAQ smaller than INT [%d]\\n\", mplp->min_baseQ);\n    fprintf(fp,\n\"  -r, --region REG        region in which pileup is generated\\n\"\n\"  -R, --ignore-RG         ignore RG tags (one BAM = one sample)\\n\"\n\"  --rf, --incl-flags STR|INT\\n\"\n\"                          required flags: only include reads with any of\\n\"\n\"                          the mask bits set [%s]\\n\", tmp_require);\n    fprintf(fp,\n\"  --ff, --excl-flags STR|INT\\n\"\n\"                          filter flags: skip reads with any of the mask bits set\\n\"\n\"                                            [%s]\\n\", tmp_filter);\n    fprintf(fp,\n\"  -x, --ignore-overlaps-removal, --disable-overlap-removal\\n\"\n\"                          disable read-pair overlap detection and removal\\n\"\n\"  -X, --customized-index  use customized index files\\n\" // -X flag for index filename\n\"\\n\"\n\"Output options:\\n\"\n\"  -o, --output FILE        write output to FILE [standard output]\\n\"\n\"  -O, --output-BP          output base positions on reads, current orientation\\n\"\n\"      --output-BP-5        output base positions on reads, 5' to 3' orientation\\n\"\n\"  -M, --output-mods        output base modifications\\n\"\n\"  -s, --output-MQ          output mapping quality\\n\"\n\"      --output-QNAME       output read names\\n\"\n\"      --output-extra STR   output extra read fields and read tag values\\n\"\n\"      --output-sep CHAR    set the separator character for tag lists [,]\\n\"\n\"      --output-empty CHAR  set the no value character for tag lists [*]\\n\"\n\"      --no-output-ins      skip insertion sequence after +NUM\\n\"\n\"                           Use twice for complete insertion removal\\n\"\n\"      --no-output-ins-mods don't display base modifications within insertions\\n\"\n\"      --no-output-del      skip deletion sequence after -NUM\\n\"\n\"                           Use twice for complete deletion removal\\n\"\n\"      --no-output-ends     remove ^MQUAL and $ markup in sequence column\\n\"\n\"      --reverse-del        use '#' character for deletions on the reverse strand\\n\"\n\"  -a                       output all positions (including zero depth)\\n\"\n\"  -a -a (or -aa)           output absolutely all positions, including unused ref. sequences\\n\"\n\"\\n\"\n\"Generic options:\\n\");\n    sam_global_opt_help(fp, \"-.--.--.\");\n\n    fprintf(fp, \"\\n\"\n\"Note that using \\\"samtools mpileup\\\" to generate BCF or VCF files has been\\n\"\n\"removed.  To output these formats, please use \\\"bcftools mpileup\\\" instead.\\n\");\n\n    free(tmp_require);\n    free(tmp_filter);\n}\n\nint bam_mpileup(int argc, char *argv[])\n{\n    int c;\n    const char *file_list = NULL;\n    char **fn = NULL;\n    int nfiles = 0, use_orphan = 0, has_index_file = 0;\n    mplp_conf_t mplp;\n    memset(&mplp, 0, sizeof(mplp_conf_t));\n    mplp.min_baseQ = 13;\n    mplp.capQ_thres = 0;\n    mplp.max_depth = MPLP_MAX_DEPTH;\n    mplp.flag = MPLP_NO_ORPHAN | MPLP_REALN | MPLP_SMART_OVERLAPS;\n    mplp.argc = argc; mplp.argv = argv;\n    mplp.rflag_filter = BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP;\n    mplp.output_fname = NULL;\n    mplp.all = 0;\n    mplp.rev_del = 0;\n    mplp.sep = ',';\n    mplp.empty = '*';\n    sam_global_args_init(&mplp.ga);\n\n    static const struct option lopts[] =\n    {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 0, '-'),\n        {\"rf\", required_argument, NULL, 1},   // require flag\n        {\"ff\", required_argument, NULL, 2},   // filter flag\n        {\"incl-flags\", required_argument, NULL, 1},\n        {\"excl-flags\", required_argument, NULL, 2},\n        {\"output\", required_argument, NULL, 3},\n        {\"output-QNAME\", no_argument, NULL, 5},\n        {\"output-qname\", no_argument, NULL, 5},\n        {\"illumina1.3+\", no_argument, NULL, '6'},\n        {\"count-orphans\", no_argument, NULL, 'A'},\n        {\"bam-list\", required_argument, NULL, 'b'},\n        {\"no-BAQ\", no_argument, NULL, 'B'},\n        {\"no-baq\", no_argument, NULL, 'B'},\n        {\"adjust-MQ\", required_argument, NULL, 'C'},\n        {\"adjust-mq\", required_argument, NULL, 'C'},\n        {\"max-depth\", required_argument, NULL, 'd'},\n        {\"redo-BAQ\", no_argument, NULL, 'E'},\n        {\"redo-baq\", no_argument, NULL, 'E'},\n        {\"fasta-ref\", required_argument, NULL, 'f'},\n        {\"exclude-RG\", required_argument, NULL, 'G'},\n        {\"exclude-rg\", required_argument, NULL, 'G'},\n        {\"positions\", required_argument, NULL, 'l'},\n        {\"region\", required_argument, NULL, 'r'},\n        {\"ignore-RG\", no_argument, NULL, 'R'},\n        {\"ignore-rg\", no_argument, NULL, 'R'},\n        {\"min-MQ\", required_argument, NULL, 'q'},\n        {\"min-mq\", required_argument, NULL, 'q'},\n        {\"min-BQ\", required_argument, NULL, 'Q'},\n        {\"min-bq\", required_argument, NULL, 'Q'},\n        // NB: old \"--ignore-overlaps\" auto-completes to this\n        {\"ignore-overlaps-removal\",  no_argument, NULL, 'x'},\n        {\"disable-overlap-removal\",  no_argument, NULL, 'x'},\n        {\"output-mods\", no_argument, NULL, 'M'},\n        {\"output-BP\", no_argument, NULL, 'O'},\n        {\"output-bp\", no_argument, NULL, 'O'},\n        {\"output-BP-5\", no_argument, NULL, 14},\n        {\"output-bp-5\", no_argument, NULL, 14},\n        {\"output-MQ\", no_argument, NULL, 's'},\n        {\"output-mq\", no_argument, NULL, 's'},\n        {\"ext-prob\", required_argument, NULL, 'e'},\n        {\"gap-frac\", required_argument, NULL, 'F'},\n        {\"tandem-qual\", required_argument, NULL, 'h'},\n        {\"skip-indels\", no_argument, NULL, 'I'},\n        {\"max-idepth\", required_argument, NULL, 'L'},\n        {\"min-ireads \", required_argument, NULL, 'm'},\n        {\"per-sample-mF\", no_argument, NULL, 'p'},\n        {\"per-sample-mf\", no_argument, NULL, 'p'},\n        {\"platforms\", required_argument, NULL, 'P'},\n        {\"customized-index\", no_argument, NULL, 'X'},\n        {\"reverse-del\", no_argument, NULL, 6},\n        {\"output-extra\", required_argument, NULL, 7},\n        {\"output-sep\", required_argument, NULL, 8},\n        {\"output-empty\", required_argument, NULL, 9},\n        {\"no-output-ins\", no_argument, NULL, 10},\n        {\"no-output-ins-mods\", no_argument, NULL, 11},\n        {\"no-output-del\", no_argument, NULL, 12},\n        {\"no-output-ends\", no_argument, NULL, 13},\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"Af:r:l:q:Q:RC:Bd:b:o:EG:6OsxXaM\",lopts,NULL)) >= 0) {\n        switch (c) {\n        case 'x': mplp.flag &= ~MPLP_SMART_OVERLAPS; break;\n        case  1 :\n            mplp.rflag_require = bam_str2flag(optarg);\n            if ( mplp.rflag_require<0 ) { fprintf(stderr,\"Could not parse --rf %s\\n\", optarg); return 1; }\n            break;\n        case  2 :\n            mplp.rflag_filter = bam_str2flag(optarg);\n            if ( mplp.rflag_filter<0 ) { fprintf(stderr,\"Could not parse --ff %s\\n\", optarg); return 1; }\n            break;\n        case  3 : mplp.output_fname = optarg; break;\n        case  5 : mplp.flag |= MPLP_PRINT_QNAME; break;\n        case  6 : mplp.rev_del = 1; break;\n        case  7 :\n            if (build_auxlist(&mplp, optarg) != 0) {\n                fprintf(stderr,\"Could not build aux list using '%s'\\n\", optarg);\n                return 1;\n            }\n            break;\n        case 8: mplp.sep = optarg[0]; break;\n        case 9: mplp.empty = optarg[0]; break;\n        case 10: mplp.no_ins++; break;\n        case 11: mplp.no_ins_mods = 1; break;\n        case 12: mplp.no_del++; break;\n        case 13: mplp.no_ends = 1; break;\n        case 'f':\n            mplp.fai = fai_load(optarg);\n            if (mplp.fai == NULL) return 1;\n            mplp.fai_fname = optarg;\n            break;\n        case 'd': mplp.max_depth = atoi(optarg); break;\n        case 'r': mplp.reg = strdup(optarg); break;\n        case 'l':\n                  // In the original version the whole BAM was streamed which is inefficient\n                  //  with few BED intervals and big BAMs. Todo: devise a heuristic to determine\n                  //  best strategy, that is streaming or jumping.\n                  mplp.bed = bed_read(optarg);\n                  if (!mplp.bed) { print_error_errno(\"mpileup\", \"Could not read file \\\"%s\\\"\", optarg); return 1; }\n                  break;\n        case 'B': mplp.flag &= ~MPLP_REALN; break;\n        case 'X': has_index_file = 1; break;\n        case 'E': mplp.flag |= MPLP_REDO_BAQ; break;\n        case '6': mplp.flag |= MPLP_ILLUMINA13; break;\n        case 'R': mplp.flag |= MPLP_IGNORE_RG; break;\n        case 's': mplp.flag |= MPLP_PRINT_MAPQ_CHAR; break;\n        case 'O': mplp.flag |= MPLP_PRINT_QPOS; break;\n        case  14: mplp.flag |= MPLP_PRINT_QPOS5; break;\n        case 'M': mplp.flag |= MPLP_PRINT_MODS; break;\n        case 'C': mplp.capQ_thres = atoi(optarg); break;\n        case 'q': mplp.min_mq = atoi(optarg); break;\n        case 'Q': mplp.min_baseQ = atoi(optarg); break;\n        case 'b': file_list = optarg; break;\n        case 'o': mplp.output_fname = optarg; break;\n        case 'A': use_orphan = 1; break;\n        case 'G': {\n                FILE *fp_rg;\n                char buf[1024];\n                mplp.rghash = khash_str2int_init();\n                if ((fp_rg = fopen(optarg, \"r\")) == NULL)\n                    fprintf(stderr, \"[%s] Fail to open file %s. Continue anyway.\\n\", __func__, optarg);\n                while (!feof(fp_rg) && fscanf(fp_rg, \"%s\", buf) > 0) // this is not a good style, but forgive me...\n                    khash_str2int_inc(mplp.rghash, strdup(buf));\n                fclose(fp_rg);\n            }\n            break;\n        case 'a': mplp.all++; break;\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &mplp.ga) == 0) break;\n            /* else fall-through */\n        case '?':\n            print_usage(stderr, &mplp);\n            return 1;\n        }\n    }\n    if (!mplp.fai && mplp.ga.reference) {\n        mplp.fai_fname = mplp.ga.reference;\n        mplp.fai = fai_load(mplp.fai_fname);\n        if (mplp.fai == NULL) return 1;\n    }\n\n    if ( !(mplp.flag&MPLP_REALN) && mplp.flag&MPLP_REDO_BAQ )\n    {\n        fprintf(stderr,\"Error: The -B option cannot be combined with -E\\n\");\n        return 1;\n    }\n    if (use_orphan) mplp.flag &= ~MPLP_NO_ORPHAN;\n    if (argc == 1)\n    {\n        print_usage(stderr, &mplp);\n        return 1;\n    }\n    int ret;\n    if (file_list) {\n        if (has_index_file) {\n            fprintf(stderr,\"Error: The -b option cannot be combined with -X\\n\"); // No customize index loc in file list mode\n            return 1;\n        }\n        if ( read_file_list(file_list,&nfiles,&fn) ) return 1;\n        ret = mpileup(&mplp,nfiles,fn,NULL);\n        for (c=0; c<nfiles; c++) free(fn[c]);\n        free(fn);\n    }\n    else {\n        if (has_index_file) {\n            if ((argc - optind)%2 !=0) { // Calculate # of input BAM files\n                fprintf(stderr, \"Odd number of filenames detected! Each BAM file should have an index file\\n\");\n                return 1;\n            }\n            nfiles = (argc - optind)/2;\n            ret = mpileup(&mplp, nfiles, argv + optind, argv + nfiles + optind);\n        } else {\n            nfiles = argc - optind;\n            ret = mpileup(&mplp, nfiles, argv + optind, NULL);\n        }\n    }\n    if (mplp.rghash) khash_str2int_destroy_free(mplp.rghash);\n    free(mplp.reg); free(mplp.pl_list);\n    if (mplp.fai) fai_destroy(mplp.fai);\n    if (mplp.bed) bed_destroy(mplp.bed);\n    if (mplp.auxlist) kl_destroy(auxlist, (klist_t(auxlist) *)mplp.auxlist);\n    return ret;\n}\n"
        },
        {
          "name": "bam_quickcheck.c",
          "type": "blob",
          "size": 6.583984375,
          "content": "/*  bam_quickcheck.c -- quickcheck subcommand.\n\n    Copyright (C) 2015-2017 Genome Research Ltd.\n\n    Author: Joshua C. Randall <jcrandall@alum.mit.edu>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <htslib/hts.h>\n#include <htslib/sam.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n/* File status flags (zero means OK). It's possible for more than one to be\n * set on a single file.   The final exit status is the bitwise-or of the\n * status of all the files. */\n#define QC_FAIL_OPEN     2\n#define QC_NOT_SEQUENCE  4\n#define QC_BAD_HEADER    8\n#define QC_NO_EOF_BLOCK 16\n#define QC_FAIL_CLOSE   32\n\nstatic void usage_quickcheck(FILE *write_to)\n{\n    fprintf(write_to,\n\"Usage: samtools quickcheck [options] <input> [...]\\n\"\n\"Options:\\n\"\n\"  -v              verbose output (repeat for more verbosity)\\n\"\n\"  -q              suppress warning messages\\n\"\n\"  -u              unmapped input (do not require targets in header)\\n\"\n\"\\n\"\n\"Notes:\\n\"\n\"\\n\"\n\"1. By default quickcheck will emit a warning message if and only if a file\\n\"\n\"   fails the checks, in which case the exit status is non-zero.  Under normal\\n\"\n\"   behaviour with valid data it will be silent and has a zero exit status.\\n\"\n\"   The warning messages are purely for manual inspection and should not be \\n\"\n\"   parsed by scripts.\\n\"\n\"\\n\"\n\"2. In order to use this command programmatically, you should check its exit\\n\"\n\"   status.  One way to use quickcheck might be as a check that all BAM files in\\n\"\n\"   a directory are okay:\\n\"\n\"\\n\"\n\"\\tsamtools quickcheck *.bam && echo 'all ok' \\\\\\n\"\n\"\\t   || echo 'fail!'\\n\"\n\"\\n\"\n\"   The first level of verbosity lists only files that fail to stdout.\\n\"\n\"   To obtain a parsable list of files that have failed, use this option:\\n\"\n\"\\n\"\n\"\\tsamtools quickcheck -qv *.bam > bad_bams.fofn \\\\\\n\"\n\"\\t   && echo 'all ok' \\\\\\n\"\n\"\\t   || echo 'some files failed check, see bad_bams.fofn'\\n\"\n    );\n}\n\n#define QC_ERR(state, v, msg, arg1)                                     \\\n    file_state |= (state);                                              \\\n    if (!quiet || verbose >= (v)) fprintf(stderr, (msg), (arg1))\n\nint main_quickcheck(int argc, char** argv)\n{\n    int verbose = 0, quiet = 0, unmapped = 0;\n    hts_verbose = 0;\n\n    const char* optstring = \"vqu\";\n    int opt;\n    while ((opt = getopt(argc, argv, optstring)) != -1) {\n        switch (opt) {\n        case 'u':\n            unmapped = 1;\n            break;\n        case 'v':\n            verbose++;\n            break;\n        case 'q':\n            quiet = 1;\n            break;\n        default:\n            usage_quickcheck(stderr);\n            return 1;\n        }\n    }\n\n    argc -= optind;\n    argv += optind;\n\n    if (argc < 1) {\n        usage_quickcheck(stdout);\n        return 1;\n    }\n\n    if (verbose >= 2) {\n        fprintf(stderr, \"verbosity set to %d\\n\", verbose);\n    }\n\n    if (verbose >= 4) {\n        hts_verbose = 3;\n    }\n\n    int ret = 0;\n    int i;\n\n    for (i = 0; i < argc; i++) {\n        char* fn = argv[i];\n        int file_state = 0;\n\n        if (verbose >= 3) fprintf(stderr, \"checking %s\\n\", fn);\n\n        // attempt to open\n        htsFile *hts_fp = hts_open(fn, \"r\");\n        if (hts_fp == NULL) {\n            QC_ERR(QC_FAIL_OPEN, 2, \"%s could not be opened for reading.\\n\", fn);\n        }\n        else {\n            if (verbose >= 3) fprintf(stderr, \"opened %s\\n\", fn);\n            // make sure we have sequence data\n            const htsFormat *fmt = hts_get_format(hts_fp);\n            if (fmt->category != sequence_data ) {\n                QC_ERR(QC_NOT_SEQUENCE, 2, \"%s was not identified as sequence data.\\n\", fn);\n            }\n            else {\n                if (verbose >= 3) fprintf(stderr, \"%s is sequence data\\n\", fn);\n                // check header\n                sam_hdr_t *header = sam_hdr_read(hts_fp);\n                if (header == NULL) {\n                    QC_ERR(QC_BAD_HEADER, 2, \"%s caused an error whilst reading its header.\\n\", fn);\n                } else {\n                    if (!unmapped && sam_hdr_nref(header) <= 0) {\n                        QC_ERR(QC_BAD_HEADER, 2, \"%s had no targets in header.\\n\", fn);\n                    }\n                    else {\n                        if (verbose >= 3) fprintf(stderr, \"%s has %d targets in header.\\n\", fn, sam_hdr_nref(header));\n                    }\n                    sam_hdr_destroy(header);\n                }\n            }\n            // check EOF on formats that support this\n            int ret;\n            if ((ret = hts_check_EOF(hts_fp)) < 0) {\n                QC_ERR(QC_NO_EOF_BLOCK, 2, \"%s caused an error whilst checking for EOF block.\\n\", fn);\n           }\n            else {\n                switch (ret) {\n                    case 0:\n                        QC_ERR(QC_NO_EOF_BLOCK, 2, \"%s was missing EOF block when one should be present.\\n\", fn);\n                        break;\n                    case 1:\n                        if (verbose >= 3) fprintf(stderr, \"%s has good EOF block.\\n\", fn);\n                        break;\n                    case 2:\n                        if (verbose >= 3) fprintf(stderr, \"%s cannot be checked for EOF block as it is not seekable.\\n\", fn);\n                        break;\n                    case 3:\n                        if (verbose >= 3) fprintf(stderr, \"%s cannot be checked for EOF block because its filetype does not contain one.\\n\", fn);\n                        break;\n                }\n            }\n\n            if (hts_close(hts_fp) < 0) {\n                QC_ERR(QC_FAIL_CLOSE, 2, \"%s did not close cleanly.\\n\", fn);\n            }\n        }\n\n        if (file_state > 0 && verbose >= 1) {\n            fprintf(stdout, \"%s\\n\", fn);\n        }\n        ret |= file_state;\n    }\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_reheader.c",
          "type": "blob",
          "size": 19.6357421875,
          "content": "/*  bam_reheader.c -- reheader subcommand.\n\n    Copyright (C) 2010 Broad Institute.\n    Copyright (C) 2012-2019 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <getopt.h>\n#include <unistd.h>\n\n#include \"htslib/bgzf.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/hfile.h\"\n#include \"htslib/cram.h\"\n#include \"samtools.h\"\n\n#define BUF_SIZE 0x10000\n\n/*\n * Reads a file and outputs a new BAM file to fd with 'h' replaced as\n * the header.    No checks are made to the validity.\n */\nint bam_reheader(BGZF *in, sam_hdr_t *h, int fd,\n                 const char *arg_list, int no_pg, int skip_header)\n{\n    BGZF *fp = NULL;\n    ssize_t len;\n    uint8_t *buf = NULL;\n    sam_hdr_t *tmp;\n    if (!h)\n        return -1;\n\n    if (in->is_write) return -1;\n    buf = malloc(BUF_SIZE);\n    if (!buf) {\n        fprintf(stderr, \"Out of memory\\n\");\n        return -1;\n    }\n\n    if (!skip_header) {\n        if ((tmp = bam_hdr_read(in)) == NULL) {\n            fprintf(stderr, \"Couldn't read header\\n\");\n            goto fail;\n        }\n        sam_hdr_destroy(tmp);\n    }\n\n    fp = bgzf_fdopen(fd, \"w\");\n    if (!fp) {\n        print_error_errno(\"reheader\", \"Couldn't open output file\");\n        goto fail;\n    }\n\n    if (!no_pg && sam_hdr_add_pg(h, \"samtools\",\n                           \"VN\", samtools_version(),\n                           arg_list ? \"CL\": NULL,\n                           arg_list ? arg_list : NULL,\n                           NULL) != 0)\n            goto fail;\n\n    if (bam_hdr_write(fp, h) < 0) {\n        print_error_errno(\"reheader\", \"Couldn't write header\");\n        goto fail;\n    }\n    if (in->block_offset < in->block_length) {\n        if (bgzf_write(fp, (char *)in->uncompressed_block + in->block_offset, in->block_length - in->block_offset) < 0) goto write_fail;\n        if (bgzf_flush(fp) < 0) goto write_fail;\n    }\n    while ((len = bgzf_raw_read(in, buf, BUF_SIZE)) > 0) {\n        if (bgzf_raw_write(fp, buf, len) < 0) goto write_fail;\n    }\n    if (len < 0) {\n        fprintf(stderr, \"[%s] Error reading input file\\n\", __func__);\n        goto fail;\n    }\n    free(buf);\n    fp->block_offset = in->block_offset = 0;\n    if (bgzf_close(fp) < 0) {\n        fprintf(stderr, \"[%s] Error closing output file\\n\", __func__);\n        return -1;\n    }\n    return 0;\n\n write_fail:\n    print_error_errno(\"reheader\", \"Error writing to output file\");\n fail:\n    bgzf_close(fp);\n    free(buf);\n    return -1;\n}\n\n/*\n * Reads a file and outputs a new CRAM file to stdout with 'h'\n * replaced as the header.  No checks are made to the validity.\n *\n * FIXME: error checking\n */\nint cram_reheader(cram_fd *in, sam_hdr_t *h, const char *arg_list, int no_pg)\n{\n    htsFile *h_out = hts_open(\"-\", \"wc\");\n    cram_fd *out = h_out->fp.cram;\n    cram_container *c = NULL;\n    int ret = -1;\n    if (!h)\n        return ret;\n\n    // Match output version number with input file.\n    char vers[99];\n    sprintf(vers, \"%d.%d\", cram_major_vers(in), cram_minor_vers(in));\n    cram_set_option(out, CRAM_OPT_VERSION, vers);\n\n    // Attempt to fill out a cram->refs[] array from @SQ headers\n    sam_hdr_t *cram_h = sam_hdr_dup(h);\n    if (!cram_h)\n        return -1;\n    cram_fd_set_header(out, cram_h);\n    if (!no_pg && sam_hdr_add_pg(cram_fd_get_header(out), \"samtools\",\n                           \"VN\", samtools_version(),\n                           arg_list ? \"CL\": NULL,\n                           arg_list ? arg_list : NULL,\n                           NULL))\n            goto err;\n\n    if (sam_hdr_write(h_out, cram_h) != 0)\n        goto err;\n    cram_set_option(out, CRAM_OPT_REFERENCE, NULL);\n\n    while ((c = cram_read_container(in))) {\n        int32_t i, num_blocks = cram_container_get_num_blocks(c);\n        if (cram_write_container(out, c) != 0)\n            goto err;\n\n        for (i = 0; i < num_blocks; i++) {\n            cram_block *blk = cram_read_block(in);\n            if (!blk || cram_write_block(out, blk) != 0) {\n                if (blk) cram_free_block(blk);\n                goto err;\n            }\n            cram_free_block(blk);\n        }\n        cram_free_container(c);\n    }\n\n    ret = 0;\n\n err:\n    if (hts_close(h_out) != 0)\n        ret = -1;\n\n    return ret;\n}\n\n\n\n/*\n * Reads a version 2 CRAM file and replaces the header in-place,\n * provided the header is small enough to fit without growing the\n * entire file.\n *\n * Version 2 format has an uncompressed SAM header with multiple nul\n * termination bytes to permit inline header editing.\n *\n * Returns 0 on success;\n *        -1 on general failure;\n *        -2 on failure due to insufficient size\n */\nint cram_reheader_inplace2(cram_fd *fd, sam_hdr_t *h, const char *arg_list,\n                          int no_pg)\n{\n    cram_container *c = NULL;\n    cram_block *b = NULL;\n    sam_hdr_t *cram_h = NULL;\n    off_t start;\n    int ret = -1;\n    if (!h)\n        goto err;\n\n    if (cram_major_vers(fd) < 2 ||\n        cram_major_vers(fd) > 3) {\n        fprintf(stderr, \"[%s] unsupported CRAM version %d\\n\", __func__,\n                cram_major_vers(fd));\n        goto err;\n    }\n\n    cram_h = sam_hdr_dup(h);\n    if (!cram_h)\n        goto err;\n\n    if (!no_pg && sam_hdr_add_pg(cram_h, \"samtools\", \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL))\n        goto err;\n\n    int header_len = sam_hdr_length(cram_h);\n    /* Fix M5 strings? Maybe out of scope for this tool */\n\n    // Load the existing header\n    if ((start = hseek(cram_fd_get_fp(fd), 26, SEEK_SET)) != 26)\n        goto err;\n\n    if (!(c = cram_read_container(fd)))\n        goto err;\n\n    // Version 2.1 has a single uncompressed block which is nul\n    // terminated with many nuls to permit growth.\n    //\n    // So load old block and keep all contents identical bar the\n    // header text itself\n    if (!(b = cram_read_block(fd)))\n        goto err;\n\n    if (cram_block_get_uncomp_size(b) < header_len+4) {\n        fprintf(stderr, \"New header will not fit. Use non-inplace version (%d > %d)\\n\",\n                header_len+4, cram_block_get_uncomp_size(b));\n        ret = -2;\n        goto err;\n    }\n\n    cram_block_set_offset(b, 0);   // rewind block\n    int32_put_blk(b, header_len);\n    cram_block_append(b, (void *)sam_hdr_str(cram_h), header_len);\n    // Zero the remaining block\n    memset((char *)cram_block_get_data(b)+cram_block_get_offset(b), 0,\n           cram_block_get_uncomp_size(b) - cram_block_get_offset(b));\n    // Make sure all sizes and byte-offsets are consistent after memset\n    cram_block_set_offset(b, cram_block_get_uncomp_size(b));\n    cram_block_set_comp_size(b, cram_block_get_uncomp_size(b));\n\n    if (hseek(cram_fd_get_fp(fd), start, SEEK_SET) != start)\n        goto err;\n\n    if (cram_write_container(fd, c) == -1)\n        goto err;\n\n    if (cram_write_block(fd, b) == -1)\n        goto err;\n\n    ret = 0;\n err:\n    if (c) cram_free_container(c);\n    if (b) cram_free_block(b);\n    if (cram_h) sam_hdr_destroy(cram_h);\n\n    return ret;\n}\n\n\n/*\n * Reads a version 3 CRAM file and replaces the header in-place,\n * provided the header is small enough to fit without growing the\n * entire file.\n *\n * Version 3 format has a SAM header held as an (optionally)\n * compressed block within the header container.  Additional\n * uncompressed blocks or simply unallocated space (the difference\n * between total block sizes and the container size) are used to\n * provide room for growth or contraction of the compressed header.\n *\n * Returns 0 on success;\n *        -1 on general failure;\n *        -2 on failure due to insufficient size\n */\nint cram_reheader_inplace3(cram_fd *fd, sam_hdr_t *h, const char *arg_list,\n                          int no_pg)\n{\n    cram_container *c = NULL;\n    cram_block *b = NULL;\n    sam_hdr_t *cram_h = NULL;\n    off_t start, sz, end;\n    int container_sz, max_container_sz;\n    char *buf = NULL;\n    int ret = -1;\n    if (!h)\n        goto err;\n\n    if (cram_major_vers(fd) < 2 ||\n        cram_major_vers(fd) > 3) {\n        fprintf(stderr, \"[%s] unsupported CRAM version %d\\n\", __func__,\n                cram_major_vers(fd));\n        goto err;\n    }\n\n    cram_h = sam_hdr_dup(h);\n    if (!cram_h)\n        goto err;\n\n    if (!no_pg && sam_hdr_add_pg(cram_h, \"samtools\", \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL))\n        goto err;\n\n    int header_len = sam_hdr_length(cram_h);\n    /* Fix M5 strings? Maybe out of scope for this tool */\n\n    // Find current size of SAM header block\n    if ((start = hseek(cram_fd_get_fp(fd), 26, SEEK_SET)) != 26)\n        goto err;\n\n    if (!(c = cram_read_container(fd)))\n        goto err;\n\n    // +5 allows num_landmarks to increase from 0 to 1 (Cramtools)\n    max_container_sz = cram_container_size(c)+5;\n\n    sz = htell(cram_fd_get_fp(fd)) + cram_container_get_length(c) - start;\n    end = htell(cram_fd_get_fp(fd)) + cram_container_get_length(c);\n\n    // We force 1 block instead of (optionally) 2.  C CRAM\n    // implementations for v3 were writing 1 compressed block followed\n    // by 1 uncompressed block.  However this is tricky to deal with\n    // as changing block sizes can mean the block header also changes\n    // size due to itf8 and variable size integers.\n    //\n    // If we had 1 block, this doesn't change anything.\n    // If we had 2 blocks, the new container header will be smaller by\n    // 1+ bytes, requiring the cram_container_get_length(c) to be larger in value.\n    // However this is an int32 instead of itf8 so the container\n    // header structure stays the same size.  This means we can always\n    // reduce the number of blocks without running into size problems.\n    cram_container_set_num_blocks(c, 1);\n    int32_t *landmark;\n    int32_t num_landmarks;\n    landmark = cram_container_get_landmarks(c, &num_landmarks);\n    if (num_landmarks && landmark) {\n        num_landmarks = 1;\n        landmark[0] = 0;\n    } else {\n        num_landmarks = 0;\n    }\n    cram_container_set_landmarks(c, num_landmarks, landmark);\n\n    buf = malloc(max_container_sz);\n    container_sz = max_container_sz;\n    if (cram_store_container(fd, c, buf, &container_sz) != 0)\n        goto err;\n\n    if (!buf)\n        goto err;\n\n    // Proposed new length, but changing cram_container_get_length(c) may change the\n    // container_sz and thus the remainder (cram_container_get_length(c) itself).\n    cram_container_set_length(c, sz - container_sz);\n\n    int old_container_sz = container_sz;\n    container_sz = max_container_sz;\n    if (cram_store_container(fd, c, buf, &container_sz) != 0)\n        goto err;\n\n    if (old_container_sz != container_sz) {\n        fprintf(stderr, \"Quirk of fate makes this troublesome! \"\n                \"Please use non-inplace version.\\n\");\n        goto err;\n    }\n\n\n\n    // Version 3.0 supports compressed header\n    b = cram_new_block(FILE_HEADER, 0);\n    int32_put_blk(b, header_len);\n    cram_block_append(b, (void *)sam_hdr_str(cram_h), header_len);\n    cram_block_update_size(b);\n\n    cram_compress_block(fd, b, NULL, -1, 9);\n\n    if (hseek(cram_fd_get_fp(fd), 26, SEEK_SET) != 26)\n        goto err;\n\n    if (cram_block_size(b) > cram_container_get_length(c)) {\n        fprintf(stderr, \"New header will not fit. Use non-inplace version\"\n                \" (%d > %d)\\n\",\n                (int)cram_block_size(b), cram_container_get_length(c));\n        ret = -2;\n        goto err;\n    }\n\n    if (cram_write_container(fd, c) == -1)\n        goto err;\n\n    if (cram_write_block(fd, b) == -1)\n        goto err;\n\n    // Blank out the remainder\n    int rsz = end - htell(cram_fd_get_fp(fd));\n    assert(rsz >= 0);\n    if (rsz) {\n        char *rem = calloc(1, rsz);\n        ret = hwrite(cram_fd_get_fp(fd), rem, rsz) == rsz ? 0 : -1;\n        free(rem);\n    }\n\n err:\n    if (c) cram_free_container(c);\n    if (buf) free(buf);\n    if (b) cram_free_block(b);\n    if (cram_h) sam_hdr_destroy(cram_h);\n\n    return ret;\n}\n\nint cram_reheader_inplace(cram_fd *fd, sam_hdr_t *h, const char *arg_list,\n                         int no_pg)\n{\n    switch (cram_major_vers(fd)) {\n    case 2: return cram_reheader_inplace2(fd, h, arg_list, no_pg);\n    case 3: return cram_reheader_inplace3(fd, h, arg_list, no_pg);\n    default:\n        fprintf(stderr, \"[%s] unsupported CRAM version %d\\n\", __func__,\n                cram_major_vers(fd));\n        return -1;\n    }\n}\n\nstatic void usage(FILE *fp, int ret) {\n    fprintf(fp,\n           \"Usage: samtools reheader [-P] in.header.sam in.bam > out.bam\\n\"\n           \"   or  samtools reheader [-P] -i in.header.sam file.cram\\n\"\n           \"   or  samtools reheader -c CMD in.bam\\n\"\n           \"   or  samtools reheader -c CMD in.cram\\n\"\n           \"\\n\"\n           \"Options:\\n\"\n           \"    -P, --no-PG         Do not generate a @PG header line.\\n\"\n           \"    -i, --in-place      Modify the CRAM file directly, if possible.\\n\"\n           \"                        (Defaults to outputting to stdout.)\\n\"\n           \"    -c, --command CMD   Pass the header in SAM format to external program CMD.\\n\");\n    exit(ret);\n}\n\nstatic sam_hdr_t* external_reheader(samFile* in, const char* external) {\n    char *command = NULL;\n    sam_hdr_t* h = NULL;\n    sam_hdr_t* ih = sam_hdr_read(in);\n    if (ih == NULL) {\n        fprintf(stderr, \"[%s] failed to read the header for '%s'.\\n\", __func__, in->fn);\n        return NULL;\n    }\n    char tmp_fn[] = \"reheaderXXXXXX\";\n    int tmp_fd = mkstemp(tmp_fn);\n    if (tmp_fd < 0) {\n        print_error_errno(\"reheader\", \"fail to open temp file '%s'\", tmp_fn);\n        return NULL;\n    }\n    hFILE* tmp_hf = hdopen(tmp_fd, \"w\");\n    if (!tmp_hf) {\n        fprintf(stderr, \"[%s] failed to convert to hFILE.\\n\", __func__);\n        goto cleanup;\n    }\n    samFile* tmp_sf = hts_hopen(tmp_hf, tmp_fn, \"w\");\n    if (!tmp_sf) {\n        fprintf(stderr, \"[%s] failed to convert to samFile.\\n\", __func__);\n        goto cleanup;\n    }\n    if (-1 == sam_hdr_write(tmp_sf, ih)) {\n        fprintf(stderr, \"[%s] failed to write the header to the temp file.\\n\", __func__);\n        goto cleanup;\n    }\n    sam_close(tmp_sf);\n    sam_hdr_destroy(ih);\n    int comm_len = strlen(external) + strlen(tmp_fn) + 8;\n    command = calloc(comm_len, 1);\n    if (!command || snprintf(command, comm_len, \"( %s ) < %s\", external, tmp_fn) != comm_len - 1) {\n        fprintf(stderr, \"[%s] failed to create command string.\\n\", __func__);\n        goto cleanup;\n    }\n    FILE* nh = popen(command, \"r\");\n    if (!nh) {\n        print_error_errno(\"reheader\", \"[%s] failed to run external command '%s'.\\n\", __func__, command);\n        goto cleanup;\n    }\n\n    int nh_fd = dup(fileno(nh));\n    if (nh_fd < 0) {\n        fprintf(stderr, \"[%s] failed to get the file descriptor.\\n\", __func__);\n        goto cleanup;\n    }\n    hFILE* nh_hf = hdopen(nh_fd, \"r\");\n    if (!nh_hf) {\n        fprintf(stderr, \"[%s] failed to convert to hFILE.\\n\", __func__);\n        goto cleanup;\n    }\n    samFile* nh_sf = hts_hopen(nh_hf, tmp_fn, \"r\");\n    if (!nh_sf) {\n        fprintf(stderr, \"[%s] failed to convert to samFile.\\n\", __func__);\n        goto cleanup;\n    }\n\n    h = sam_hdr_read(nh_sf);\n    sam_close(nh_sf);\n    if (h == NULL) {\n        fprintf(stderr, \"[%s] failed to read the header from the temp file.\\n\", __func__);\n    }\n    int res = pclose(nh);\n    if (res != 0) {\n        if (res < 0) {\n            print_error_errno(\"reheader\",\n                              \"Error on closing pipe from command '%s'.\\n\",\n                              command);\n        } else {\n            print_error(\"reheader\",\n                        \"Non-zero exit code returned by command '%s'\\n\",\n                        command);\n        }\n        if (h) sam_hdr_destroy(h);\n        h = NULL;\n    }\ncleanup:\n    free(command);\n    if (unlink(tmp_fn) != 0) {\n        print_error_errno(\"reheader\", \"failed to remove the temp file '%s'\", tmp_fn);\n    }\n\n    return h;\n}\n\nint main_reheader(int argc, char *argv[])\n{\n    int inplace = 0, r, no_pg = 0, c, skip_header = 0;\n    sam_hdr_t *h;\n    samFile *in;\n    char *arg_list = NULL, *external = NULL;\n\n    static const struct option lopts[] = {\n        {\"help\",     no_argument, NULL, 'h'},\n        {\"in-place\", no_argument, NULL, 'i'},\n        {\"no-PG\",    no_argument, NULL, 'P'},\n        {\"command\", required_argument, NULL, 'c'},\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"hiPc:\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'P': no_pg = 1; break;\n        case 'i': inplace = 1; break;\n        case 'c': external = optarg; break;\n        case 'h': usage(stdout, 0); break;\n        default:\n            fprintf(stderr, \"Invalid option '%c'\\n\", c);\n            usage(stderr, 1);\n        }\n    }\n\n    if ((argc - optind != 2 || external) && (argc - optind != 1 || !external))\n        usage(stderr, 1);\n\n    if (!no_pg && !(arg_list = stringify_argv(argc+1, argv-1))) {\n         print_error(\"reheader\", \"failed to create arg_list\");\n         return 1;\n     }\n\n    if (external) {\n        skip_header = 1;\n        in = sam_open(argv[optind], inplace?\"r+\":\"r\");\n        if (in == 0) {\n            print_error_errno(\"reheader\", \"fail to open file '%s'\", argv[optind]);\n            return 1;\n        }\n\n        h = external_reheader(in, external);\n        if (h == NULL) {\n            fprintf(stderr, \"[%s] failed to read the header from '%s'.\\n\", __func__, external);\n            sam_close(in);\n            return 1;\n        }\n    } else { // read the header from a separate file\n        samFile *fph = sam_open(argv[optind], \"r\");\n        if (fph == 0) {\n            print_error_errno(\"reheader\", \"fail to read the header from '%s'\", argv[optind]);\n            return 1;\n        }\n        h = sam_hdr_read(fph);\n        sam_close(fph);\n        if (h == NULL) {\n            fprintf(stderr, \"[%s] failed to read the header for '%s'.\\n\",\n                    __func__, argv[1]);\n            return 1;\n        }\n        in = sam_open(argv[optind+1], inplace?\"r+\":\"r\");\n        if (in == 0) {\n            print_error_errno(\"reheader\", \"fail to open file '%s'\", argv[optind+1]);\n            return 1;\n        }\n    }\n\n    if (hts_get_format(in)->format == bam) {\n        if (inplace) {\n            print_error(\"reheader\", \"cannot reheader BAM '%s' in-place\", argv[optind+1]);\n            r = -1;\n        } else {\n            r = bam_reheader(in->fp.bgzf, h, fileno(stdout), arg_list, no_pg, skip_header);\n        }\n    } else if (hts_get_format(in)->format == cram) {\n        if (inplace)\n            r = cram_reheader_inplace(in->fp.cram, h, arg_list, no_pg);\n        else\n            r = cram_reheader(in->fp.cram, h, arg_list, no_pg);\n    } else {\n        print_error(\"reheader\", \"input file '%s' must be BAM or CRAM\", argv[optind+1]);\n        r = -1;\n    }\n\n    if (sam_close(in) != 0)\n        r = -1;\n\n    sam_hdr_destroy(h);\n\n    if (arg_list)\n        free(arg_list);\n\n    return -r;\n}\n"
        },
        {
          "name": "bam_rmdup.c",
          "type": "blob",
          "size": 10.41796875,
          "content": "/*  bam_rmdup.c -- duplicate read detection.\n\n    Copyright (C) 2009, 2015, 2016, 2019 Genome Research Ltd.\n    Portions copyright (C) 2009 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <zlib.h>\n#include <unistd.h>\n#include \"htslib/sam.h\"\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n#include \"bam.h\" // for bam_get_library\n\ntypedef bam1_t *bam1_p;\n\n#include \"htslib/khash.h\"\nKHASH_SET_INIT_STR(name)\nKHASH_MAP_INIT_INT64(pos, bam1_p)\n\n#define BUFFER_SIZE 0x40000\n\ntypedef struct {\n    uint64_t n_checked, n_removed;\n    khash_t(pos) *best_hash;\n} lib_aux_t;\nKHASH_MAP_INIT_STR(lib, lib_aux_t)\n\ntypedef struct {\n    int n, max;\n    bam1_t **a;\n} tmp_stack_t;\n\nstatic inline void stack_insert(tmp_stack_t *stack, bam1_t *b)\n{\n    if (stack->n == stack->max) {\n        stack->max = stack->max? stack->max<<1 : 0x10000;\n        stack->a = (bam1_t**)realloc(stack->a, sizeof(bam1_t*) * stack->max);\n    }\n    stack->a[stack->n++] = b;\n}\n\nstatic inline int dump_best(tmp_stack_t *stack, samFile *out, sam_hdr_t *hdr)\n{\n    int i;\n    for (i = 0; i != stack->n; ++i) {\n        if (sam_write1(out, hdr, stack->a[i]) < 0) return -1;\n        bam_destroy1(stack->a[i]);\n        stack->a[i] = NULL;\n    }\n    stack->n = 0;\n    return 0;\n}\n\nstatic inline void clear_stack(tmp_stack_t *stack) {\n    int i;\n    if (!stack->a) return;\n    for (i = 0; i != stack->n; ++i) {\n        bam_destroy1(stack->a[i]);\n    }\n}\n\nstatic void clear_del_set(khash_t(name) *del_set)\n{\n    khint_t k;\n    for (k = kh_begin(del_set); k < kh_end(del_set); ++k)\n        if (kh_exist(del_set, k))\n            free((char*)kh_key(del_set, k));\n    kh_clear(name, del_set);\n}\n\nstatic lib_aux_t *get_aux(khash_t(lib) *aux, const char *lib)\n{\n    khint_t k = kh_get(lib, aux, lib);\n    if (k == kh_end(aux)) {\n        int ret;\n        char *p = strdup(lib);\n        lib_aux_t *q;\n        k = kh_put(lib, aux, p, &ret);\n        q = &kh_val(aux, k);\n        q->n_checked = q->n_removed = 0;\n        q->best_hash = kh_init(pos);\n        return q;\n    } else return &kh_val(aux, k);\n}\n\nstatic void clear_best(khash_t(lib) *aux, int max)\n{\n    khint_t k;\n    for (k = kh_begin(aux); k != kh_end(aux); ++k) {\n        if (kh_exist(aux, k)) {\n            lib_aux_t *q = &kh_val(aux, k);\n            if (kh_size(q->best_hash) >= max)\n                kh_clear(pos, q->best_hash);\n        }\n    }\n}\n\nstatic inline int sum_qual(const bam1_t *b)\n{\n    int i, q;\n    uint8_t *qual = bam_get_qual(b);\n    for (i = q = 0; i < b->core.l_qseq; ++i) q += qual[i];\n    return q;\n}\n\nint bam_rmdup_core(samFile *in, sam_hdr_t *hdr, samFile *out)\n{\n    bam1_t *b = NULL;\n    int last_tid = -1, last_pos = -1, r;\n    tmp_stack_t stack;\n    khint_t k;\n    khash_t(lib) *aux = NULL;\n    khash_t(name) *del_set = NULL;\n\n    memset(&stack, 0, sizeof(tmp_stack_t));\n    aux = kh_init(lib);\n    del_set = kh_init(name);\n    b = bam_init1();\n    if (!aux || !del_set || !b) {\n        perror(__func__);\n        goto fail;\n    }\n\n    kh_resize(name, del_set, 4 * BUFFER_SIZE);\n    while ((r = sam_read1(in, hdr, b)) >= 0) {\n        bam1_core_t *c = &b->core;\n        if (c->tid != last_tid || last_pos != c->pos) {\n            if (dump_best(&stack, out, hdr) < 0) goto write_fail; // write the result\n            clear_best(aux, BUFFER_SIZE);\n            if (c->tid != last_tid) {\n                clear_best(aux, 0);\n                if (kh_size(del_set)) { // check\n                    fprintf(stderr, \"[bam_rmdup_core] %llu unmatched pairs\\n\", (long long)kh_size(del_set));\n                    clear_del_set(del_set);\n                }\n                if ((int)c->tid == -1) { // append unmapped reads\n                    if (sam_write1(out, hdr, b) < 0) goto write_fail;\n                    while ((r = sam_read1(in, hdr, b)) >= 0) {\n                        if (sam_write1(out, hdr, b) < 0) goto write_fail;\n                    }\n                    break;\n                }\n                last_tid = c->tid;\n                fprintf(stderr, \"[bam_rmdup_core] processing reference %s...\\n\", sam_hdr_tid2name(hdr, c->tid));\n            }\n        }\n        if (!(c->flag&BAM_FPAIRED) || (c->flag&(BAM_FUNMAP|BAM_FMUNMAP)) || (c->mtid >= 0 && c->tid != c->mtid)) {\n            if (sam_write1(out, hdr, b) < 0) goto write_fail;\n        } else if (c->isize > 0) { // paired, head\n            uint64_t key = (uint64_t)c->pos<<32 | c->isize;\n            const char *lib;\n            lib_aux_t *q;\n            int ret;\n            lib = bam_get_library(hdr, b);\n            q = lib? get_aux(aux, lib) : get_aux(aux, \"\\t\");\n            ++q->n_checked;\n            k = kh_put(pos, q->best_hash, key, &ret);\n            if (ret < 0) goto fail;\n            if (ret == 0) { // found in best_hash\n                bam1_t *p = kh_val(q->best_hash, k);\n                ++q->n_removed;\n                if (sum_qual(p) < sum_qual(b)) { // the current alignment is better; this can be accelerated in principle\n                    kh_put(name, del_set, strdup(bam_get_qname(p)), &ret); // p will be removed\n                    if (ret < 0) goto fail;\n                    if (bam_copy1(p, b) == NULL) goto fail; // replaced as b\n                } else kh_put(name, del_set, strdup(bam_get_qname(b)), &ret); // b will be removed\n                if (ret < 0) goto fail;\n                if (ret == 0)\n                    fprintf(stderr, \"[bam_rmdup_core] inconsistent BAM file for pair '%s'. Continue anyway.\\n\", bam_get_qname(b));\n            } else { // not found in best_hash\n                kh_val(q->best_hash, k) = bam_dup1(b);\n                stack_insert(&stack, kh_val(q->best_hash, k));\n            }\n        } else { // paired, tail\n            k = kh_get(name, del_set, bam_get_qname(b));\n            if (k != kh_end(del_set)) {\n                free((char*)kh_key(del_set, k));\n                kh_del(name, del_set, k);\n            } else {\n                if (sam_write1(out, hdr, b) < 0) goto write_fail;\n            }\n        }\n        last_pos = c->pos;\n    }\n    if (r < -1) {\n        fprintf(stderr, \"[%s] failed to read input file\\n\", __func__);\n        goto fail;\n    }\n\n    for (k = kh_begin(aux); k != kh_end(aux); ++k) {\n        if (kh_exist(aux, k)) {\n            lib_aux_t *q = &kh_val(aux, k);\n            if (dump_best(&stack, out, hdr) < 0) goto write_fail;\n            fprintf(stderr, \"[bam_rmdup_core] %lld / %lld = %.4lf in library '%s'\\n\", (long long)q->n_removed,\n                    (long long)q->n_checked, (double)q->n_removed/q->n_checked, kh_key(aux, k));\n            kh_destroy(pos, q->best_hash);\n            free((char*)kh_key(aux, k));\n            kh_del(lib, aux, k);\n        }\n    }\n    kh_destroy(lib, aux);\n\n    clear_del_set(del_set);\n    kh_destroy(name, del_set);\n    free(stack.a);\n    bam_destroy1(b);\n    return 0;\n\n write_fail:\n    print_error_errno(\"rmdup\", \"failed to write record\");\n fail:\n    clear_stack(&stack);\n    free(stack.a);\n    if (aux) {\n        for (k = kh_begin(aux); k != kh_end(aux); ++k) {\n            if (kh_exist(aux, k)) {\n                lib_aux_t *q = &kh_val(aux, k);\n                kh_destroy(pos, q->best_hash);\n                free((char*)kh_key(aux, k));\n            }\n        }\n        kh_destroy(lib, aux);\n    }\n    if (del_set) {\n        clear_del_set(del_set);\n        kh_destroy(name, del_set);\n    }\n    bam_destroy1(b);\n    return 1;\n}\n\nint bam_rmdupse_core(samFile *in, sam_hdr_t *hdr, samFile *out, int force_se);\n\nstatic int rmdup_usage(void) {\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"Usage:  samtools rmdup [-sS] <input.srt.bam> <output.bam>\\n\\n\");\n    fprintf(stderr, \"Option: -s    rmdup for SE reads\\n\");\n    fprintf(stderr, \"        -S    treat PE reads as SE in rmdup (force -s)\\n\");\n\n    sam_global_opt_help(stderr, \"-....--.\");\n    return 1;\n}\n\nint bam_rmdup(int argc, char *argv[])\n{\n    int c, ret, is_se = 0, force_se = 0;\n    samFile *in, *out;\n    sam_hdr_t *header;\n    char wmode[3] = {'w', 'b', 0};\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 0, 0, 0, '-'),\n        { NULL, 0, NULL, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \"sS\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 's': is_se = 1; break;\n        case 'S': force_se = is_se = 1; break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?': return rmdup_usage();\n        }\n    }\n    if (optind + 2 > argc)\n        return rmdup_usage();\n\n    in = sam_open_format(argv[optind], \"r\", &ga.in);\n    if (!in) {\n        print_error_errno(\"rmdup\", \"failed to open \\\"%s\\\" for input\", argv[optind]);\n        return 1;\n    }\n    header = sam_hdr_read(in);\n    if (header == NULL || sam_hdr_nref(header) == 0) {\n        fprintf(stderr, \"[bam_rmdup] input SAM does not have header. Abort!\\n\");\n        return 1;\n    }\n\n    sam_open_mode(wmode+1, argv[optind+1], NULL);\n    out = sam_open_format(argv[optind+1], wmode, &ga.out);\n    if (!out) {\n        print_error_errno(\"rmdup\", \"failed to open \\\"%s\\\" for output\", argv[optind+1]);\n        return 1;\n    }\n    if (sam_hdr_write(out, header) < 0) {\n        print_error_errno(\"rmdup\", \"failed to write header\");\n        return 1;\n    }\n\n    if (is_se) ret = bam_rmdupse_core(in, header, out, force_se);\n    else ret = bam_rmdup_core(in, header, out);\n\n    sam_hdr_destroy(header);\n    sam_close(in);\n    if (sam_close(out) < 0) {\n        fprintf(stderr, \"[bam_rmdup] error closing output file\\n\");\n        ret = 1;\n    }\n    return ret;\n}\n"
        },
        {
          "name": "bam_rmdupse.c",
          "type": "blob",
          "size": 7.333984375,
          "content": "/*  bam_rmdupse.c -- duplicate read detection for unpaired reads.\n\n    Copyright (C) 2009, 2015, 2016, 2019 Genome Research Ltd.\n    Portions copyright (C) 2009 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <math.h>\n#include <stdio.h>\n#include \"bam.h\" // for bam_get_library\n#include \"htslib/sam.h\"\n#include \"htslib/khash.h\"\n#include \"htslib/klist.h\"\n#include \"samtools.h\"\n\n#define QUEUE_CLEAR_SIZE 0x100000\n#define MAX_POS 0x7fffffff\n\ntypedef struct {\n    int endpos;\n    uint32_t score:31, discarded:1;\n    bam1_t *b;\n} elem_t, *elem_p;\n#define __free_elem(p) bam_destroy1((p)->data.b)\nKLIST_INIT(q, elem_t, __free_elem)\ntypedef klist_t(q) queue_t;\n\nKHASH_MAP_INIT_INT(best, elem_p)\ntypedef khash_t(best) besthash_t;\n\ntypedef struct {\n    uint64_t n_checked, n_removed;\n    besthash_t *left, *rght;\n} lib_aux_t;\nKHASH_MAP_INIT_STR(lib, lib_aux_t)\n\nstatic lib_aux_t *get_aux(khash_t(lib) *aux, const char *lib)\n{\n    khint_t k = kh_get(lib, aux, lib);\n    if (k == kh_end(aux)) {\n        int ret;\n        char *p = strdup(lib);\n        lib_aux_t *q;\n        k = kh_put(lib, aux, p, &ret);\n        q = &kh_val(aux, k);\n        q->left = kh_init(best);\n        q->rght = kh_init(best);\n        q->n_checked = q->n_removed = 0;\n        return q;\n    } else return &kh_val(aux, k);\n}\n\nstatic inline int sum_qual(const bam1_t *b)\n{\n    int i, q;\n    uint8_t *qual = bam_get_qual(b);\n    for (i = q = 0; i < b->core.l_qseq; ++i) q += qual[i];\n    return q;\n}\n\nstatic inline elem_t *push_queue(queue_t *queue, const bam1_t *b, int endpos, int score)\n{\n    elem_t *p = kl_pushp(q, queue);\n    p->discarded = 0;\n    p->endpos = endpos; p->score = score;\n    if (p->b == 0) p->b = bam_init1();\n    if (!p->b) { perror(NULL); exit(EXIT_FAILURE); }\n    if (bam_copy1(p->b, b) == NULL) { perror(NULL); exit(EXIT_FAILURE); }\n    return p;\n}\n\nstatic void clear_besthash(besthash_t *h, int32_t pos)\n{\n    khint_t k;\n    for (k = kh_begin(h); k != kh_end(h); ++k)\n        if (kh_exist(h, k) && kh_val(h, k)->endpos <= pos)\n            kh_del(best, h, k);\n}\n\nstatic int dump_alignment(samFile *out, sam_hdr_t *hdr,\n                          queue_t *queue, int32_t pos, khash_t(lib) *h)\n{\n    if (queue->size > QUEUE_CLEAR_SIZE || pos == MAX_POS) {\n        khint_t k;\n        while (1) {\n            elem_t *q;\n            if (queue->head == queue->tail) break;\n            q = &kl_val(queue->head);\n            if (q->discarded) {\n                q->b->l_data = 0;\n                kl_shift(q, queue, 0);\n                continue;\n            }\n            if ((q->b->core.flag&BAM_FREVERSE) && q->endpos > pos) break;\n            if (sam_write1(out, hdr, q->b) < 0) return -1;\n            q->b->l_data = 0;\n            kl_shift(q, queue, 0);\n        }\n        for (k = kh_begin(h); k != kh_end(h); ++k) {\n            if (kh_exist(h, k)) {\n                clear_besthash(kh_val(h, k).left, pos);\n                clear_besthash(kh_val(h, k).rght, pos);\n            }\n        }\n    }\n    return 0;\n}\n\nint bam_rmdupse_core(samFile *in, sam_hdr_t *hdr, samFile *out, int force_se)\n{\n    bam1_t *b = NULL;\n    queue_t *queue = NULL;\n    khint_t k;\n    int last_tid = -2, r;\n    khash_t(lib) *aux = NULL;\n\n    aux = kh_init(lib);\n    b = bam_init1();\n    queue = kl_init(q);\n    if (!aux || !b || !queue) {\n        perror(__func__);\n        goto fail;\n    }\n\n    while ((r = sam_read1(in, hdr, b)) >= 0) {\n        bam1_core_t *c = &b->core;\n        int endpos = bam_endpos(b);\n        int score = sum_qual(b);\n\n        if (last_tid != c->tid) {\n            if (last_tid >= 0) {\n                if (dump_alignment(out, hdr, queue, MAX_POS, aux) < 0)\n                    goto write_fail;\n            }\n            last_tid = c->tid;\n        } else {\n            if (dump_alignment(out, hdr, queue, c->pos, aux) < 0)\n                goto write_fail;\n        }\n        if ((c->flag&BAM_FUNMAP) || ((c->flag&BAM_FPAIRED) && !force_se)) {\n            push_queue(queue, b, endpos, score);\n        } else {\n            const char *lib;\n            lib_aux_t *q;\n            besthash_t *h;\n            uint32_t key;\n            int ret;\n            lib = bam_get_library(hdr, b);\n            q = lib? get_aux(aux, lib) : get_aux(aux, \"\\t\");\n            ++q->n_checked;\n            h = (c->flag&BAM_FREVERSE)? q->rght : q->left;\n            key = (c->flag&BAM_FREVERSE)? endpos : c->pos;\n            k = kh_put(best, h, key, &ret);\n            if (ret == 0) { // in the hash table\n                elem_t *p = kh_val(h, k);\n                ++q->n_removed;\n                if (p->score < score) {\n                    if (c->flag&BAM_FREVERSE) { // mark \"discarded\" and push the queue\n                        p->discarded = 1;\n                        kh_val(h, k) = push_queue(queue, b, endpos, score);\n                    } else { // replace\n                        p->score = score; p->endpos = endpos;\n                        if (bam_copy1(p->b, b) == NULL) {\n                            perror(NULL); exit(EXIT_FAILURE);\n                        }\n                    }\n                } // otherwise, discard the alignment\n            } else kh_val(h, k) = push_queue(queue, b, endpos, score);\n        }\n    }\n    if (r < -1) {\n        fprintf(stderr, \"[%s] error reading input file\\n\", __func__);\n        goto fail;\n    }\n\n    if (dump_alignment(out, hdr, queue, MAX_POS, aux) < 0) goto write_fail;\n\n    for (k = kh_begin(aux); k != kh_end(aux); ++k) {\n        if (kh_exist(aux, k)) {\n            lib_aux_t *q = &kh_val(aux, k);\n            fprintf(stderr, \"[bam_rmdupse_core] %lld / %lld = %.4lf in library '%s'\\n\", (long long)q->n_removed,\n                    (long long)q->n_checked, (double)q->n_removed/q->n_checked, kh_key(aux, k));\n            kh_destroy(best, q->left); kh_destroy(best, q->rght);\n            free((char*)kh_key(aux, k));\n            kh_del(lib, aux, k);\n        }\n    }\n    kh_destroy(lib, aux);\n    bam_destroy1(b);\n    kl_destroy(q, queue);\n    return 0;\n\n write_fail:\n    print_error_errno(\"rmdup\", \"failed to write record\");\n fail:\n    if (aux) {\n        for (k = kh_begin(aux); k != kh_end(aux); ++k) {\n            if (kh_exist(aux, k)) {\n                lib_aux_t *q = &kh_val(aux, k);\n                kh_destroy(best, q->left);\n                kh_destroy(best, q->rght);\n                free((char*)kh_key(aux, k));\n            }\n        }\n        kh_destroy(lib, aux);\n    }\n    bam_destroy1(b);\n    kl_destroy(q, queue);\n    return 1;\n}\n"
        },
        {
          "name": "bam_samples.c",
          "type": "blob",
          "size": 14.2705078125,
          "content": "/*  bam_samples -- print samples in a set of BAM files\n\n    Copyright (C) 2021 Pierre Lindenbaum\n    Institut du Thorax. u1087 Nantes. France.\n    @yokofakun\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n#include <htslib/hts.h>\n#include <htslib/sam.h>\n#include <htslib/faidx.h>\n#include <htslib/khash.h>\n#include <htslib/kseq.h>\n#include <samtools.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <getopt.h>\n\nKHASH_MAP_INIT_STR(sm, int)\n\n/** and chained struct containing the faidx and the fasta filename\n    will be compared with the @SQ lines in the SAM header\n */\ntypedef struct FaidxPath {\n    /** path to reference */\n    char* filename;\n    /** fasta index  */\n    faidx_t* faidx;\n    struct FaidxPath* next;\n} FaidxPath;\n\n/** program parameters */\ntypedef struct Params {\n    /** output stream */\n    FILE* out;\n    /** tag in @RG line. default is \"SM\" */\n    char tag[3];\n    /** first faidx/path in chained list */\n    FaidxPath* faidx;\n    /** show whether the bam is indexed */\n    int test_index;\n} Params;\n\n/** print usage */\nstatic void usage_samples(FILE *write_to) {\n    fprintf(write_to,\n            \"Usage: samtools samples [options] <input> [...]\\n\"\n            \"       samtools samples [options] -X f1.bam f2.bam f1.bam.bai f2.bai \\n\"\n            \"       find dir1 dir2 -type f \\\\(-name \\\"*.bam\\\" -o -name \\\"*.cram\\\" \\\\) | samtools samples [options]\\n\"\n            \"       find dir1 dir2 -type f \\\\(-name \\\"*.bam\\\" -o -name \\\"*.bai\\\" \\\\) | sort | paste - - | samtools samples -X [options]\\n\"\n            \"\\n\"\n            \"Options:\\n\"\n            \"  -?              print help and exit\\n\"\n            \"  -h              add the columns header before printing the results\\n\"\n            \"  -i              test if the file is indexed.\\n\"\n            \"  -T <tag>        provide the sample tag name from the @RG line [SM].\\n\"\n            \"  -o <file>       output file [stdout].\\n\"\n            \"  -f <file.fa>    load an indexed fasta file in the collection of references. Can be used multiple times.\\n\"\n            \"  -F <file.txt>   read a file containing the paths to indexed fasta files. One path per line.\\n\"\n            \"  -X              use a custom index file.\\n\"\n            \"\\n\"\n            \" Using -f or -F will add a column containing the path to the reference or \\\".\\\" if the reference was not found.\\n\"\n            \"\\n\"\n    );\n}\n\n\n/** loads fasta fai file into FaidxPath, add it to params->faidx */\nstatic int load_dictionary(struct Params* params, const char* filename) {\n    FaidxPath* head = params->faidx;\n    FaidxPath* ptr = (FaidxPath*)malloc(sizeof(FaidxPath));\n    if (ptr == NULL) {\n        print_error_errno(\"samples\", \"Out of memory\");\n        return EXIT_FAILURE;\n    }\n    ptr->filename = strdup(filename);\n    if (ptr->filename == NULL) {\n        free(ptr);\n        print_error_errno(\"samples\", \"Out of memory\");\n        return EXIT_FAILURE;\n    }\n    ptr->faidx = fai_load(filename);\n    if (ptr->faidx == NULL) {\n        free(ptr->filename);\n        free(ptr);\n        print_error_errno(\"samples\", \"Cannot load index from \\\"%s\\\"\", filename);\n        return EXIT_FAILURE;\n    }\n    /* insert at the beginning of the linked list */\n    params->faidx = ptr;\n    ptr->next = head;\n    return EXIT_SUCCESS;\n}\n\n/** load a faidx file and append it to params */\nstatic int load_dictionaries(Params* params, const char* filename) {\n    int ret;\n    htsFile* in;\n    int status = EXIT_SUCCESS;\n\n    in = hts_open(filename, \"r\");\n    if (in == NULL) {\n        print_error_errno(\"samples\", \"Cannot open \\\"%s\\\"\", filename);\n        status = EXIT_FAILURE;\n    } else {\n        kstring_t ks = KS_INITIALIZE;\n        while ((ret = hts_getline(in, KS_SEP_LINE, &ks)) >= 0) {\n            if (load_dictionary(params, ks_str(&ks)) != EXIT_SUCCESS) {\n                status = EXIT_FAILURE;\n                break;\n            }\n        }\n        ks_free(&ks);\n        hts_close(in);\n    }\n    return status;\n}\n\n/** print the sample information, search for a reference */\nstatic int print_sample(\n        Params* params,\n        sam_hdr_t *header,\n        int has_index,\n        const char* sample,\n        const char* fname) {\n    fputs(sample, params->out);\n    fputc('\\t', params->out);\n    fputs(fname, params->out);\n    if (params->test_index) {\n        fprintf(params->out, \"\\t%c\", has_index ? 'Y' : 'N');\n    }\n    if (params->faidx != NULL) {\n        FaidxPath* ref = NULL;\n        FaidxPath* curr = params->faidx;\n        while (curr != NULL) {\n            /** check names and length are the same in the same order */\n            if (faidx_nseq(curr->faidx) == header->n_targets) {\n                int i;\n                for (i = 0; i < faidx_nseq(curr->faidx); i++) {\n                    /** check name is the same */\n                    if (strcmp(faidx_iseq(curr->faidx, i), header->target_name[i]) != 0) break;\n                    /** check length is the same */\n                    if (faidx_seq_len(curr->faidx, faidx_iseq(curr->faidx, i)) != header->target_len[i]) break;\n                }\n                /* the ref was found */\n                if (i == faidx_nseq(curr->faidx)) {\n                    ref = curr;\n                    break;\n                }\n            }\n            curr = curr->next;\n        }\n        fputc('\\t', params->out);\n        if (ref == NULL) {\n            fputc('.', params->out);\n        } else {\n            fputs(curr->filename, params->out);\n        }\n    }\n    fputc('\\n', params->out);\n    return 0;\n}\n\n/** open a sam file. Search for all samples in the @RG lines */\nstatic int print_samples(Params* params, const char* fname, const char* baifname) {\n    samFile *in = 0;\n    sam_hdr_t *header = NULL;\n    int n_rg;\n    int status = EXIT_SUCCESS;\n    khash_t(sm) *sample_set = NULL;\n    khint_t k;\n    int count_samples = 0;\n    int has_index = 0;\n\n    if ((sample_set = kh_init(sm)) == NULL) {\n        print_error(\"samples\", \"Failed to initialise sample hash\");\n        status = EXIT_FAILURE;\n        goto end_print;\n    }\n\n    if ((in = sam_open_format(fname, \"r\", NULL)) == 0) {\n        print_error_errno(\"samples\", \"Failed to open \\\"%s\\\" for reading\", fname);\n        status = EXIT_FAILURE;\n        goto end_print;\n    }\n    if ((header = sam_hdr_read(in)) == 0) {\n        print_error(\"samples\", \"Failed to read the header from \\\"%s\\\"\", fname);\n        status = EXIT_FAILURE;\n        goto end_print;\n    }\n\n    /* try to load index if required */\n    if (params->test_index) {\n        hts_idx_t *bam_idx;\n        /* path to bam index was specified */\n        if (baifname != NULL) {\n            bam_idx = sam_index_load3(in, fname, baifname, HTS_IDX_SILENT_FAIL);\n        }\n        /* get default index */\n        else {\n            bam_idx = sam_index_load3(in, fname, NULL, HTS_IDX_SILENT_FAIL);\n        }\n        has_index = bam_idx != NULL;\n        if (bam_idx != NULL) hts_idx_destroy(bam_idx);\n        /* and we continue... we have tested the index file but we always test for the samples and the references */\n    }\n\n    /* get the RG lines */\n    n_rg = sam_hdr_count_lines(header, \"RG\");\n    if (n_rg > 0) {\n        int i, r, ret;\n        char* sample;\n        kstring_t sm_val = KS_INITIALIZE;\n        for (i = 0; i < n_rg; i++) {\n            r = sam_hdr_find_tag_pos(header, \"RG\", i, params->tag, &sm_val);\n            if (r < 0) continue;\n            k = kh_get(sm, sample_set, ks_str(&sm_val));\n            if (k != kh_end(sample_set)) continue;\n            sample = strdup(ks_str(&sm_val));\n            if (sample == NULL) {\n                print_error_errno(\"samples\", \"Out of memory\");\n                status = EXIT_FAILURE;\n                goto end_print;\n            }\n            kh_put(sm, sample_set, sample, &ret);\n            if (ret < 0) {\n                print_error(\"samples\", \"Failed to insert key '%s' into sample_set\", sample);\n                free(sample);\n                status = EXIT_FAILURE;\n                goto end_print;\n            }\n            ++count_samples;\n        }\n        ks_free(&sm_val);\n    }\n    if (count_samples == 0) {\n        print_sample(params, header, has_index, \".\", fname);\n    } else {\n        for (k = kh_begin(sample_set); k != kh_end(sample_set); ++k) {\n            if (kh_exist(sample_set, k)) {\n                char* sample = (char*)kh_key(sample_set, k);\n                print_sample(params, header, has_index, sample, fname);\n            }\n        }\n    }\n\nend_print:\n    if (sample_set != NULL) {\n        for (k = kh_begin(sample_set); k != kh_end(sample_set); ++k) {\n            if (kh_exist(sample_set, k)) {\n                char* sample = (char*)kh_key(sample_set, k);\n                free(sample);\n            }\n        }\n        kh_destroy(sm, sample_set);\n    }\n    if (header != NULL) sam_hdr_destroy(header);\n    if (in != NULL) sam_close(in);\n\n    return status;\n}\n\n\nint main_samples(int argc, char** argv) {\n    int status = EXIT_SUCCESS;\n    int print_header = 0;\n    int has_index_file = 0;\n    Params params;\n    char* out_filename = NULL;\n    FaidxPath* fai;\n\n    strcpy(params.tag, \"SM\");\n    params.faidx = NULL;\n    params.test_index =0;\n\n    int opt;\n    while ((opt = getopt_long(argc, argv,  \"?hiXo:f:F:T:\", NULL, NULL)) != -1) {\n        switch (opt) {\n        case 'h':\n            print_header = 1;\n            break;\n        case 'o':\n            out_filename = optarg;\n            break;\n        case 'i':\n            params.test_index = 1;\n            break;\n        case 'f':\n            if (load_dictionary(&params, optarg) != EXIT_SUCCESS) {\n                return EXIT_FAILURE;\n            }\n            break;\n        case 'F':\n            if (load_dictionaries(&params, optarg) != EXIT_SUCCESS) {\n                return EXIT_FAILURE;\n            }\n            break;\n        case 'T':\n            if (strlen(optarg) != 2) {\n                print_error(\"samples\", \"Length of tag \\\"%s\\\" is not 2.\", optarg);\n                return EXIT_FAILURE;\n            }\n            strcpy(params.tag, optarg);\n            break;\n        case '?':\n            usage_samples(stdout);\n            return EXIT_SUCCESS;\n        case 'X':\n            has_index_file = 1;\n            break;\n        default:\n            usage_samples(stderr);\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* if no file was provided and input is the terminal, print the usage and exit */\n    if (argc == optind && isatty(STDIN_FILENO)) {\n       usage_samples(stderr);\n       return EXIT_FAILURE;\n    }\n\n    if (out_filename != NULL) {\n        params.out = fopen(out_filename, \"w\");\n        if (params.out == NULL) {\n            print_error_errno(\"samples\", \"Cannot open \\\"%s\\\" for writing\", out_filename);\n            return EXIT_FAILURE;\n        }\n    } else {\n        params.out = stdout;\n    }\n\n    if (print_header) {\n        fprintf(params.out, \"#%s\\tPATH\", params.tag);\n        if (params.test_index) fprintf(params.out, \"\\tINDEX\");\n        if (params.faidx != NULL) fprintf(params.out, \"\\tREFERENCE\");\n        fprintf(params.out, \"\\n\");\n    }\n\n    /* no file was provided, input is stdin, each line contains the path to a bam file */\n    if (argc == optind) {\n        htsFile* fp = hts_open(\"-\", \"r\");\n        if (fp == NULL) {\n            print_error_errno(\"samples\", \"Cannot read from stdin\");\n            status = EXIT_FAILURE;\n        } else {\n            kstring_t ks = KS_INITIALIZE;\n            int ret;\n            while ((ret = hts_getline(fp, KS_SEP_LINE, &ks)) >= 0) {\n                char* bai_path = NULL;\n                if (has_index_file) {\n                    /* bam path and bam index file are separated by a tab */\n                    char* tab = strchr(ks_str(&ks), '\\t');\n                    if (tab == NULL || *(tab+1) == '\\0') {\n                        print_error_errno(\"samples\", \"Expected path-to-bam(tab)path-to-index but got \\\"%s\\\"\", ks_str(&ks));\n                        status = EXIT_FAILURE;\n                        break;\n                    }\n                    *tab=0;\n                    bai_path = (tab + 1);\n                }\n                if (print_samples(&params, ks_str(&ks), bai_path) != EXIT_SUCCESS) {\n                    status = EXIT_FAILURE;\n                    break;\n                }\n            }\n            ks_free(&ks);\n            hts_close(fp);\n        }\n    }\n    /* loop over each file in argc/argv bam index provided */\n    else if (has_index_file) {\n        /* calculate number of input BAM files */\n        if ((argc - optind) % 2 != 0) {\n            print_error(\"samples\",\"Odd number of filenames detected! Each BAM file should have an index file\");\n            status = EXIT_FAILURE;\n        } else {\n            int i;\n            int n = (argc - optind ) / 2;\n            for (i = 0; i < n; i++) {\n                if (print_samples(&params, argv[optind+i], argv[optind+i+n]) != EXIT_SUCCESS) {\n                    status = EXIT_FAILURE;\n                    break;\n                }\n            }\n        }\n    } else {\n        int i;\n        for (i = optind; i < argc; i++) {\n            if (print_samples(&params, argv[i], NULL) != EXIT_SUCCESS) {\n                status = EXIT_FAILURE;\n                break;\n            }\n        }\n    }\n\n    fai = params.faidx;\n    while (fai != NULL) {\n        FaidxPath* next = fai -> next;\n        free(fai->filename);\n        fai_destroy(fai->faidx);\n        free(fai);\n        fai = next;\n    }\n\n    if (fflush(params.out) != 0) {\n        print_error_errno(\"samples\", \"Cannot flush output\");\n        status = EXIT_FAILURE;\n    }\n    if (out_filename != NULL) {\n        fclose(params.out);\n    }\n\n    return status;\n}\n"
        },
        {
          "name": "bam_sort.c",
          "type": "blob",
          "size": 131.8359375,
          "content": "/*  bam_sort.c -- sorting and merging.\n\n    Copyright (C) 2008-2024 Genome Research Ltd.\n    Portions copyright (C) 2009-2012 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n    Author: Martin Pollard <mp15@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <assert.h>\n#include <pthread.h>\n#include <inttypes.h>\n#include \"htslib/ksort.h\"\n#include \"htslib/hts_os.h\"\n#include \"htslib/khash.h\"\n#include \"htslib/klist.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/hts_endian.h\"\n#include \"htslib/cram.h\"\n#include \"htslib/thread_pool.h\"\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n#include \"bedidx.h\"\n#include \"bam.h\"\n\n//#define DEBUG_MINHASH\n\n#define BAM_BLOCK_SIZE 2*1024*1024\n#define MAX_TMP_FILES 64\n\n// Struct which contains the sorting key for TemplateCoordinate sort.\ntypedef struct {\n    int tid1;\n    int tid2;\n    hts_pos_t pos1;\n    hts_pos_t pos2;\n    bool neg1;\n    bool neg2;\n    const char *library;\n    char *mid;\n    char *name;\n    bool is_upper_of_pair;\n} template_coordinate_key_t;\n\n// Struct to store fixed buffers of template coordinate keys\ntypedef struct {\n  size_t n; // the # of keys stored\n  size_t m; // the # of buffers allocated\n  size_t buffer_size; // # the fixed size of each buffer\n  template_coordinate_key_t **buffers; // the list of buffers\n} template_coordinate_keys_t;\n\n// Gets the idx'th key; does not OOB check\nstatic template_coordinate_key_t* template_coordinate_keys_get(template_coordinate_keys_t *keys, size_t idx) {\n    size_t buffer_idx = idx / keys->buffer_size; // the index of the buffer to retrieve in buffer\n    size_t buffer_offset = idx % keys->buffer_size; // the offset into the given buffer to retrieve\n    //assert(buffer_idx < keys->m);\n    //assert(buffer_offset < keys->buffer_size);\n    return &keys->buffers[buffer_idx][buffer_offset];\n}\n\n// Rellocates the buffers to hold at least max_k entries\nstatic int template_coordinate_keys_realloc(template_coordinate_keys_t *keys, int max_k) {\n    size_t cur_m = keys->m;\n    keys->m += 0x100;\n    //assert(keys->m > cur_m);\n    //assert(keys->m * keys->buffer_size >= max_k);\n    if ((keys->buffers = realloc(keys->buffers, keys->m * sizeof(template_coordinate_key_t*))) == NULL) {\n        print_error(\"sort\", \"couldn't reallocate memory for template coordinate key buffers\");\n        return -1;\n    }\n    // allocate space for new buffers\n    int j;\n    for (j = cur_m; j < keys->m; ++j) {\n        if ((keys->buffers[j]= malloc(sizeof(template_coordinate_key_t) * keys->buffer_size)) == NULL) {\n            print_error(\"sort\", \"couldn't allocate memory for template coordinate key buffer\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n\n// Struct which contains the a record, and the pointer to the sort tag (if any) or\n// a combined ref / position / strand.\n// Used to speed up sorts (coordinate, by-tag, and template-coordinate).\ntypedef struct bam1_tag {\n    bam1_t *bam_record;\n    union {\n        const uint8_t *tag;\n        uint8_t pos_tid[12];\n        template_coordinate_key_t *key;\n    } u;\n} bam1_tag;\n\n/* Minimum memory required in megabytes before sort will attempt to run. This\n   is to prevent accidents where failing to use the -m option correctly results\n   in the creation of a temporary file for each read in the input file.\n   Don't forget to update the man page if you change this. */\nconst size_t SORT_MIN_MEGS_PER_THREAD = 1;\n\n/* Default per-thread memory for sort. Must be >= SORT_MIN_MEGS_PER_THREAD.\n   Don't forget to update the man page if you change this. */\nconst size_t SORT_DEFAULT_MEGS_PER_THREAD = 768;\n\n#if !defined(__DARWIN_C_LEVEL) || __DARWIN_C_LEVEL < 900000L\n#define NEED_MEMSET_PATTERN4\n#endif\n\n#ifdef NEED_MEMSET_PATTERN4\nvoid memset_pattern4(void *target, const void *pattern, size_t size) {\n    uint32_t* target_iter = target;\n    size_t loops = size/4;\n    size_t i;\n    for (i = 0; i < loops; ++i) {\n        memcpy(target_iter, pattern, 4);\n        ++target_iter;\n    }\n    if (size%4 != 0)\n        memcpy(target_iter, pattern, size%4);\n}\n#endif\n\nKHASH_INIT(c2c, char*, char*, 1, kh_str_hash_func, kh_str_hash_equal)\nKHASH_INIT(cset, char*, char, 0, kh_str_hash_func, kh_str_hash_equal)\nKHASH_MAP_INIT_STR(c2i, int)\nKHASH_MAP_INIT_STR(const_c2c, char *)\n\n#define hdrln_free_char(p)\nKLIST_INIT(hdrln, char*, hdrln_free_char)\n\nstatic template_coordinate_key_t* template_coordinate_key(bam1_t *b, template_coordinate_key_t *key, sam_hdr_t *hdr, khash_t(const_c2c) *lib_lookup);\n\ntypedef enum {Coordinate, QueryName, TagCoordinate, TagQueryName, MinHash, TemplateCoordinate} SamOrder;\nstatic SamOrder g_sam_order = Coordinate;\nstatic int natural_sort = 1; // not ASCII, but alphanumeric: a12b > a7b\nstatic char g_sort_tag[2] = {0,0};\n\n#define is_digit(c) ((c)<='9' && (c)>='0')\nstatic int strnum_cmp(const char *_a, const char *_b)\n{\n    if (!natural_sort)\n        return strcmp(_a,_b);\n\n    const unsigned char *a = (const unsigned char*)_a, *b = (const unsigned char*)_b;\n    const unsigned char *pa = a, *pb = b;\n    while (*pa && *pb) {\n        if (!is_digit(*pa) || !is_digit(*pb)) {\n            if (*pa != *pb)\n                return (int)*pa - (int)*pb;\n            ++pa; ++pb;\n        } else {\n            // skip leading zeros\n            while (*pa == '0') ++pa;\n            while (*pb == '0') ++pb;\n\n            // skip matching digits\n            while (is_digit(*pa) && *pa == *pb)\n                pa++, pb++;\n\n            // Now mismatching, so see which ends the number sooner\n            int diff = (int)*pa - (int)*pb;\n            while (is_digit(*pa) && is_digit(*pb))\n                pa++, pb++;\n\n            if (is_digit(*pa))\n                return  1; // pa still going, so larger\n            else if (is_digit(*pb))\n                return -1; // pb still going, so larger\n            else if (diff)\n                return diff; // same length, so earlier diff\n        }\n    }\n    return *pa? 1 : *pb? -1 : 0;\n}\n\n#define HEAP_EMPTY (UINT64_MAX >> 1)\n\ntypedef struct {\n    int i;\n    uint32_t tid;\n    uint64_t pos:63, rev:1, idx;\n    bam1_tag entry;\n} heap1_t;\n\nstatic inline int bam1_cmp_by_tag(const bam1_tag a, const bam1_tag b);\nstatic inline int bam1_cmp_by_minhash(const bam1_tag a, const bam1_tag b);\nstatic inline int bam1_cmp_template_coordinate(const bam1_tag a, const bam1_tag b);\nstatic khash_t(const_c2c) * lookup_libraries(sam_hdr_t *header);\nstatic void lib_lookup_destroy(khash_t(const_c2c) *lib_lookup);\n\n// Function to compare reads in the heap and determine which one is < the other\n// Note, unlike the bam1_cmp_by_X functions which return <0, 0, >0 this\n// is strictly 0 or 1 only.\nstatic inline int heap_lt(const heap1_t a, const heap1_t b)\n{\n    if (!a.entry.bam_record)\n        return 1;\n    if (!b.entry.bam_record)\n        return 0;\n\n    int t, fa, fb;\n    switch (g_sam_order) {\n        case Coordinate:\n            if (a.tid != b.tid) return a.tid > b.tid;\n            if (a.pos != b.pos) return a.pos > b.pos;\n            if (a.rev != b.rev) return a.rev > b.rev;\n            break;\n        case QueryName:\n            t = strnum_cmp(bam_get_qname(a.entry.bam_record), bam_get_qname(b.entry.bam_record));\n            if (t != 0) return t > 0;\n            fa = a.entry.bam_record->core.flag;\n            fb = b.entry.bam_record->core.flag;\n            // Sort order is READ1, READ2, (PRIMARY), SUPPLEMENTARY, SECONDARY\n            // Get the bits in this order so sort is a natural a-b\n            fa = ((fa&0xc0)<<8)|((fa&0x100)<<3)|((fa&0x800)>>3);\n            fb = ((fb&0xc0)<<8)|((fb&0x100)<<3)|((fb&0x800)>>3);\n            if (fa != fb) return fa > fb;\n            break;\n        case TagQueryName:\n        case TagCoordinate:\n            t = bam1_cmp_by_tag(a.entry, b.entry);\n            if (t != 0) return t > 0;\n            break;\n        case MinHash:\n            t = bam1_cmp_by_minhash(a.entry, b.entry);\n            if (t != 0) return t > 0;\n            break;\n        case TemplateCoordinate:\n            t = bam1_cmp_template_coordinate(a.entry, b.entry);\n            if (t != 0) return t > 0;\n            break;\n        default:\n            print_error(\"heap_lt\", \"unknown sort order: %d\", g_sam_order);\n            break;\n    }\n\n    // This compares by position (i/idx'th read) in the input file(s)\n    if (a.i != b.i) return a.i > b.i;\n    return a.idx > b.idx;\n}\n\nKSORT_INIT(heap, heap1_t, heap_lt)\n\ntypedef struct merged_header {\n    sam_hdr_t    *hdr;\n    kstring_t     out_rg;\n    kstring_t     out_pg;\n    kstring_t     out_co;\n    char        **target_name;\n    uint32_t     *target_len;\n    size_t        n_targets;\n    size_t        targets_sz;\n    khash_t(c2i) *sq_tids;\n    khash_t(cset) *rg_ids;\n    khash_t(cset) *pg_ids;\n    bool          have_hd;\n} merged_header_t;\n\ntypedef struct trans_tbl {\n    int32_t n_targets;\n    int* tid_trans;\n    kh_c2c_t* rg_trans;\n    kh_c2c_t* pg_trans;\n    bool lost_coord_sort;\n} trans_tbl_t;\n\nstatic void trans_tbl_destroy(trans_tbl_t *tbl) {\n    khiter_t iter;\n\n    free(tbl->tid_trans);\n\n    /*\n     * The values for the tbl->rg_trans and tbl->pg_trans hashes are pointers\n     * to keys in the rg_ids and pg_ids sets of the merged_header_t, so\n     * they should not be freed here.\n     *\n     * The keys are unique to each hash entry, so they do have to go.\n     */\n\n    for (iter = kh_begin(tbl->rg_trans); iter != kh_end(tbl->rg_trans); ++iter) {\n        if (kh_exist(tbl->rg_trans, iter)) {\n            free(kh_key(tbl->rg_trans, iter));\n        }\n    }\n    for (iter = kh_begin(tbl->pg_trans); iter != kh_end(tbl->pg_trans); ++iter) {\n        if (kh_exist(tbl->pg_trans, iter)) {\n            free(kh_key(tbl->pg_trans, iter));\n        }\n    }\n\n    kh_destroy(c2c,tbl->rg_trans);\n    kh_destroy(c2c,tbl->pg_trans);\n}\n\n/*\n *  Create a merged_header_t struct.\n */\n\nstatic merged_header_t * init_merged_header(void) {\n    merged_header_t *merged_hdr;\n\n    merged_hdr = calloc(1, sizeof(*merged_hdr));\n    if (merged_hdr == NULL) return NULL;\n\n    merged_hdr->hdr = sam_hdr_init();\n    if (!merged_hdr->hdr) goto fail;\n\n    merged_hdr->targets_sz   = 16;\n    merged_hdr->target_name = malloc(merged_hdr->targets_sz\n                                     * sizeof(*merged_hdr->target_name));\n    if (NULL == merged_hdr->target_name) goto fail;\n\n    merged_hdr->target_len = malloc(merged_hdr->targets_sz\n                                    * sizeof(*merged_hdr->target_len));\n    if (NULL == merged_hdr->target_len) goto fail;\n\n    merged_hdr->sq_tids = kh_init(c2i);\n    if (merged_hdr->sq_tids == NULL) goto fail;\n\n    merged_hdr->rg_ids = kh_init(cset);\n    if (merged_hdr->rg_ids == NULL) goto fail;\n\n    merged_hdr->pg_ids = kh_init(cset);\n    if (merged_hdr->pg_ids == NULL) goto fail;\n\n    return merged_hdr;\n\n fail:\n    perror(\"[init_merged_header]\");\n    kh_destroy(cset, merged_hdr->pg_ids);\n    kh_destroy(cset, merged_hdr->rg_ids);\n    kh_destroy(c2i, merged_hdr->sq_tids);\n    free(merged_hdr->target_name);\n    free(merged_hdr->target_len);\n    sam_hdr_destroy(merged_hdr->hdr);\n    free(merged_hdr);\n    return NULL;\n}\n\n/* Some handy kstring manipulating functions */\n\n// Append char range to kstring\nstatic inline int range_to_ks(const char *src, int from, int to,\n                              kstring_t *dest) {\n    return kputsn(src + from, to - from, dest) != to - from;\n}\n\n// Append a kstring to a kstring\nstatic inline int ks_to_ks(kstring_t *src, kstring_t *dest) {\n    return kputsn(ks_str(src), ks_len(src), dest) != ks_len(src);\n}\n\n/*\n * Generate a unique ID by appending a random suffix to a given prefix.\n * existing_ids is the set of IDs that are already in use.\n * If always_add_suffix is true, the suffix will always be included.\n * If false, prefix will be returned unchanged if it isn't in existing_ids.\n */\n\nstatic int gen_unique_id(char *prefix, khash_t(cset) *existing_ids,\n                         bool always_add_suffix, kstring_t *dest) {\n    khiter_t iter;\n\n    if (!always_add_suffix) {\n        // Try prefix on its own first\n        iter = kh_get(cset, existing_ids, prefix);\n        if (iter == kh_end(existing_ids)) { // prefix isn't used yet\n            dest->l = 0;\n            if (kputs(prefix, dest) == EOF) return -1;\n            return 0;\n        }\n    }\n\n    do {\n        dest->l = 0;\n        ksprintf(dest, \"%s-%08lX\", prefix, lrand48());\n        iter = kh_get(cset, existing_ids, ks_str(dest));\n    } while (iter != kh_end(existing_ids));\n\n    return 0;\n}\n\n/*\n * Add the @HD line to the new header\n * In practice the @HD line will come from the first input header.\n */\n\nstatic int trans_tbl_add_hd(merged_header_t* merged_hdr,\n                            sam_hdr_t *translate) {\n    kstring_t hd_line = { 0, 0, NULL };\n    int res;\n\n    // TODO: handle case when @HD needs merging.\n    if (merged_hdr->have_hd) return 0;\n\n    res = sam_hdr_find_hd(translate, &hd_line);\n    if (res < -1) {\n        print_error(\"merge\", \"failed to get @HD line from header\");\n        return -1;\n    }\n\n    if (res < 0) // Not found\n        return 0;\n\n    if (sam_hdr_add_lines(merged_hdr->hdr, hd_line.s, hd_line.l) < 0) {\n        print_error(\"merge\", \"failed to add @HD line to new header\");\n        free(hd_line.s);\n        return -1;\n    }\n\n    free(hd_line.s);\n    merged_hdr->have_hd = true;\n\n    return 0;\n}\n\n/*\n * Add @SQ records to the translation table.\n *\n * Go through the target list for the input header.  Any new targets found\n * are added to the output header target list.  At the same time, a mapping\n * from the input to output target ids is stored in tbl.\n *\n * If any new targets are found, the header text is scanned to find the\n * corresponding @SQ records.  They are then copied into the\n * merged_hdr->out_text kstring (which will eventually become the\n * output header text).\n *\n * Returns 0 on success, -1 on failure.\n */\n\nstatic int trans_tbl_add_sq(merged_header_t* merged_hdr, sam_hdr_t *translate,\n                            trans_tbl_t* tbl) {\n    int32_t i;\n    int min_tid = -1, res;\n    kstring_t sq_line = { 0, 0, NULL }, sq_sn = { 0, 0, NULL };\n\n    // Fill in the tid part of the translation table, adding new targets\n    // to the merged header as we go.\n\n    tbl->n_targets = sam_hdr_nref(translate);\n    tbl->tid_trans = calloc(tbl->n_targets ? tbl->n_targets : 1, sizeof(int));\n    if (tbl->tid_trans == NULL) {\n        print_error_errno(\"merge\", \"failed to allocate @SQ translation table\");\n        return -1;\n    }\n\n    for (i = 0; i < tbl->n_targets; ++i) {\n        int trans_tid;\n        sq_sn.l = 0;\n        res = sam_hdr_find_tag_pos(translate, \"SQ\", i, \"SN\", &sq_sn);\n        if (res < 0) {\n            print_error(\"merge\", \"failed to get @SQ SN #%d from header\", i + 1);\n            goto fail;\n        }\n\n        trans_tid = sam_hdr_name2tid(merged_hdr->hdr, sq_sn.s);\n        if (trans_tid < -1) {\n            print_error(\"merge\", \"failed to lookup ref\");\n            goto fail;\n        }\n\n        if (trans_tid < 0) {\n            // Append missing entries to out_hdr\n            sq_line.l = 0;\n            res = sam_hdr_find_line_id(translate, \"SQ\", \"SN\", sq_sn.s, &sq_line);\n            if (res < 0) {\n                print_error(\"merge\", \"failed to get @SQ SN:%s from header\", sq_sn.s);\n                goto fail;\n            }\n\n            trans_tid = sam_hdr_nref(merged_hdr->hdr);\n\n            res = sam_hdr_add_lines(merged_hdr->hdr, sq_line.s, sq_line.l);\n            if (res < 0) {\n                print_error(\"merge\", \"failed to add @SQ SN:%s to new header\", sq_sn.s);\n                goto fail;\n            }\n        }\n        tbl->tid_trans[i] = trans_tid;\n\n        if (tbl->tid_trans[i] > min_tid) {\n            min_tid = tbl->tid_trans[i];\n        } else {\n            tbl->lost_coord_sort = true;\n        }\n    }\n\n    free(sq_line.s);\n    free(sq_sn.s);\n\n    return 0;\n\n fail:\n    free(sq_line.s);\n    free(sq_sn.s);\n    return -1;\n}\n\n/*\n * Common code for setting up RG and PG record ID tag translation.\n *\n * is_rg is true for RG translation, false for PG.\n * translate is the input bam header\n * merge is true if tags with the same ID are to be merged.\n * known_ids is the set of IDs already in the output header.\n * id_map is the translation map from input header IDs to output header IDs\n * If override is set, it will be used to replace the existing ID (RG only)\n *\n * known_ids and id_map have entries for the new IDs added to them.\n *\n * Return value is a linked list of header lines with the translated IDs,\n * or NULL if something went wrong (probably out of memory).\n *\n */\n\nstatic klist_t(hdrln) * trans_rg_pg(bool is_rg, sam_hdr_t *translate,\n                                    bool merge, khash_t(cset)* known_ids,\n                                    khash_t(c2c)* id_map, char *override) {\n    khiter_t iter;\n    int num_ids, i;\n    const char *rec_type = is_rg ? \"RG\" : \"PG\";\n    klist_t(hdrln) *hdr_lines;\n\n    hdr_lines = kl_init(hdrln);\n\n    // Search through translate's header\n    num_ids = sam_hdr_count_lines(translate, rec_type);\n    if (num_ids < 0)\n        goto fail;\n\n    for (i = 0; i < num_ids; i++) {\n        kstring_t orig_id = { 0, 0, NULL };        // ID in original header\n        kstring_t transformed_id = { 0, 0, NULL }; // ID in output header\n        char *map_value;    // Value to store in id_map\n        bool id_changed;    // Have we changed the ID?\n        bool not_found_in_output; // ID isn't in the output header (yet)\n\n        if (sam_hdr_find_tag_pos(translate, rec_type, i, \"ID\", &orig_id) < 0)\n            goto fail;\n\n        // is our matched ID in our output ID set already?\n        iter = kh_get(cset, known_ids, ks_str(&orig_id));\n        not_found_in_output = (iter == kh_end(known_ids));\n\n        if (override) {\n            // Override original ID (RG only)\n#ifdef OVERRIDE_DOES_NOT_MERGE\n            if (gen_unique_id(override, known_ids, false, &transformed_id))\n                goto memfail;\n            not_found_in_output = true;  // As ID now unique\n#else\n            if (kputs(override, &transformed_id) == EOF) goto memfail;\n            // Know about override already?\n            iter = kh_get(cset, known_ids, ks_str(&transformed_id));\n            not_found_in_output = (iter == kh_end(known_ids));\n#endif\n            id_changed = true;\n        } else {\n            if ( not_found_in_output || merge) {\n                // Not in there or merging so can add it as 1-1 mapping\n                if (ks_to_ks(&orig_id, &transformed_id)) goto memfail;\n                id_changed = false;\n            } else {\n                // It's in there so we need to transform it by appending\n                // a random number to the id\n                if (gen_unique_id(ks_str(&orig_id), known_ids,\n                                  true, &transformed_id))\n                    goto memfail;\n                id_changed = true;\n                not_found_in_output = true;  // As ID now unique\n            }\n        }\n\n        // Does this line need to go into our output header?\n        if (not_found_in_output) {\n            // Take matched line and replace ID with transformed_id\n            kstring_t new_hdr_line = { 0, 0, NULL };\n            if (sam_hdr_find_line_id(translate, rec_type,\n                                     \"ID\", ks_str(&orig_id), &new_hdr_line) < 0){\n                goto fail;\n            }\n\n            if (id_changed) {\n                char *idp = strstr(ks_str(&new_hdr_line), \"\\tID:\"), *id_end;\n                ptrdiff_t id_offset, id_len;\n                if (!idp) {\n                    print_error(\"merge\", \"failed to find ID in \\\"%s\\\"\\n\",\n                                ks_str(&new_hdr_line));\n                    goto fail;\n                }\n                idp += 4;\n                for (id_end = idp; *id_end >= '\\n'; id_end++) {}\n\n                id_offset = idp - new_hdr_line.s;\n                id_len = id_end - idp;\n\n                if (id_len < transformed_id.l) {\n                    if (ks_resize(&new_hdr_line, new_hdr_line.l\n                                  + transformed_id.l - id_len + 1/*nul*/))\n                        goto fail;\n                }\n                if (id_len != transformed_id.l) {\n                    memmove(new_hdr_line.s + id_offset + transformed_id.l,\n                            new_hdr_line.s + id_offset + id_len,\n                            new_hdr_line.l - id_offset - id_len + 1);\n                }\n                memcpy(new_hdr_line.s + id_offset, transformed_id.s,\n                       transformed_id.l);\n            }\n\n            // append line to output linked list\n            char** ln = kl_pushp(hdrln, hdr_lines);\n            *ln = ks_release(&new_hdr_line);  // Give away to linked list\n\n            // Need to add it to known_ids set\n            int in_there = 0;\n            iter = kh_put(cset, known_ids, ks_str(&transformed_id), &in_there);\n            if (in_there < 0) goto memfail;\n            assert(in_there > 0);  // Should not already be in the map\n            map_value = ks_release(&transformed_id);\n        } else {\n            // Use existing string in id_map\n            assert(kh_exist(known_ids, iter));\n            map_value = kh_key(known_ids, iter);\n            free(ks_release(&transformed_id));\n        }\n\n        // Insert it into our translation map\n        int in_there = 0;\n        iter = kh_put(c2c, id_map, ks_release(&orig_id), &in_there);\n        kh_value(id_map, iter) = map_value;\n    }\n\n    // If there are no RG lines in the file and we are overriding add one\n    if (is_rg && override && hdr_lines->size == 0) {\n        kstring_t new_id = {0, 0, NULL};\n        kstring_t line = {0, 0, NULL};\n        kstring_t empty = {0, 0, NULL};\n        int in_there = 0;\n        char** ln;\n\n        // Get the new ID\n        if (gen_unique_id(override, known_ids, false, &new_id))\n            goto memfail;\n\n        // Make into a header line and add to linked list\n        ksprintf(&line, \"@RG\\tID:%s\", ks_str(&new_id));\n        ln = kl_pushp(hdrln, hdr_lines);\n        *ln = ks_release(&line);\n\n        // Put into known_ids set\n        iter = kh_put(cset, known_ids, ks_str(&new_id), &in_there);\n        if (in_there < 0) goto memfail;\n        assert(in_there > 0);  // Should be a new entry\n\n        // Put into translation map (key is empty string)\n        if (kputs(\"\", &empty) == EOF) goto memfail;\n        iter = kh_put(c2c, id_map, ks_release(&empty), &in_there);\n        if (in_there < 0) goto memfail;\n        assert(in_there > 0);  // Should be a new entry\n        kh_value(id_map, iter) = ks_release(&new_id);\n    }\n\n    return hdr_lines;\n\n memfail:\n    perror(__func__);\n fail:\n    if (hdr_lines) kl_destroy(hdrln, hdr_lines);\n    return NULL;\n}\n\n/*\n * Common code for completing RG and PG record translation.\n *\n * Input is a list of header lines, and the mapping from input to\n * output @PG record IDs.\n *\n * RG and PG records can contain tags that cross-reference to other @PG\n * records.  This fixes the tags to contain the new IDs before adding\n * them to the output header text.\n */\n\nstatic int finish_rg_pg(bool is_rg, klist_t(hdrln) *hdr_lines,\n                        khash_t(c2c)* pg_map, kstring_t *out_text) {\n    const char *search = is_rg ? \"\\tPG:\" : \"\\tPP:\";\n    khiter_t idx;\n    char *line = NULL;\n\n    while ((kl_shift(hdrln, hdr_lines, &line)) == 0) {\n        char *id = strstr(line, search); // Look for tag to fix\n        int pos1 = 0, pos2 = 0;\n        char *new_id = NULL;\n\n        if (id) {\n            // Found a tag.  Look up the value in the translation map\n            // to see what it should be changed to in the output file.\n            char *end, tmp;\n\n            id += 4; // Point to value\n            end = strchr(id, '\\t');  // Find end of tag\n            if (!end) end = id + strlen(id);\n\n            tmp = *end;\n            *end = '\\0'; // Temporarily get the value on its own.\n\n            // Look-up in translation table\n            idx = kh_get(c2c, pg_map, id);\n            if (idx == kh_end(pg_map)) {\n                // Not found, warn.\n                fprintf(stderr, \"[W::%s] Tag %s%s not found in @PG records\\n\",\n                        __func__, search + 1, id);\n            } else {\n                // Remember new id and splice points on original string\n                new_id = kh_value(pg_map, idx);\n                pos1 = id - line;\n                pos2 = end - line;\n            }\n\n            *end = tmp; // Restore string\n        }\n\n        // Copy line to output:\n        // line[0..pos1), new_id (if not NULL), line[pos2..end), '\\n'\n\n        if (pos1 && range_to_ks(line, 0, pos1, out_text)) goto memfail;\n        if (new_id && kputs(new_id, out_text) == EOF) goto memfail;\n        if (kputs(line + pos2, out_text) == EOF) goto memfail;\n        if (kputc('\\n', out_text) == EOF) goto memfail;\n        free(line);   // No longer needed\n        line = NULL;\n    }\n\n    return 0;\n\n memfail:\n    perror(__func__);\n    free(line);  // Prevent leakage as no longer on list\n    return -1;\n}\n\n/*\n * Build the translation table for an input *am file.  This stores mappings\n * which allow IDs to be converted from those used in the input file\n * to the ones which will be used in the output.  The mappings are for:\n *   Reference sequence IDs (for @SQ records)\n *   @RG record ID tags\n *   @PG record ID tags\n *\n * At the same time, new header text is built up by copying records\n * from the input bam file.  This will eventually become the header for\n * the output file.  When copied, the ID tags for @RG and @PG records\n * are replaced with their values.  The @PG PP: and @RG PG: tags\n * are also modified if necessary.\n *\n * merged_hdr holds state on the output header (which IDs are present, etc.)\n * translate is the input header\n * tbl is the translation table that gets filled in.\n * merge_rg controls merging of @RG records\n * merge_pg controls merging of @PG records\n * If rg_override is not NULL, it will be used to replace the existing @RG ID\n *\n * Returns 0 on success, -1 on failure.\n */\n\nstatic int trans_tbl_init(merged_header_t* merged_hdr, sam_hdr_t* translate,\n                          trans_tbl_t* tbl, bool merge_rg, bool merge_pg,\n                          bool copy_co, char* rg_override)\n{\n    kstring_t lines = { 0, 0, NULL };\n    klist_t(hdrln) *rg_list = NULL;\n    klist_t(hdrln) *pg_list = NULL;\n\n    tbl->n_targets = 0;\n    tbl->tid_trans = NULL;\n    tbl->rg_trans = tbl->pg_trans = NULL;\n    tbl->rg_trans = kh_init(c2c);\n    if (tbl->rg_trans == NULL) goto memfail;\n    tbl->pg_trans = kh_init(c2c);\n    if (tbl->pg_trans == NULL) goto memfail;\n\n    tbl->lost_coord_sort = false;\n\n    // Get the @HD record (if not there already).\n    if (trans_tbl_add_hd(merged_hdr, translate)) goto fail;\n\n    // Fill in map and add header lines for @SQ records\n    if (trans_tbl_add_sq(merged_hdr, translate, tbl)) goto fail;\n\n    // Get translated header lines and fill in map for @RG records\n    rg_list = trans_rg_pg(true, translate, merge_rg, merged_hdr->rg_ids,\n                          tbl->rg_trans, rg_override);\n    if (!rg_list) goto fail;\n\n    // Get translated header lines and fill in map for @PG records\n    pg_list = trans_rg_pg(false, translate, merge_pg, merged_hdr->pg_ids,\n                          tbl->pg_trans, NULL);\n    if (!pg_list) goto fail;\n\n    // Fix-up PG: tags in the new @RG records and add to output\n    if (finish_rg_pg(true, rg_list, tbl->pg_trans, &merged_hdr->out_rg))\n        goto fail;\n\n    // Fix-up PP: tags in the new @PG records and add to output\n    lines.l = 0;\n    if (finish_rg_pg(false, pg_list, tbl->pg_trans, &merged_hdr->out_pg))\n        goto fail;\n\n    kl_destroy(hdrln, rg_list); rg_list = NULL;\n    kl_destroy(hdrln, pg_list); pg_list = NULL;\n\n    if (copy_co) {\n        // Just append @CO headers without translation\n        int num_co = sam_hdr_count_lines(translate, \"CO\"), i;\n        if (num_co < 0)\n            goto fail;\n\n        for (i = 0; i < num_co; i++) {\n            if (sam_hdr_find_line_pos(translate, \"CO\", i, &lines) < 0)\n                goto fail;\n            if (ks_to_ks(&lines, &merged_hdr->out_co))\n                goto fail;\n            if (kputc('\\n', &merged_hdr->out_co) < 0)\n                goto fail;\n        }\n    }\n\n    free(lines.s);\n\n    return 0;\n\n memfail:\n    perror(__func__);\n fail:\n    trans_tbl_destroy(tbl);\n    if (rg_list) kl_destroy(hdrln, rg_list);\n    if (pg_list) kl_destroy(hdrln, pg_list);\n    free(lines.s);\n    return -1;\n}\n\nstatic int finish_merged_header(merged_header_t *merged_hdr) {\n    if (sam_hdr_add_lines(merged_hdr->hdr, ks_c_str(&merged_hdr->out_rg),\n                          ks_len(&merged_hdr->out_rg)) < 0)\n        return -1;\n    if (sam_hdr_add_lines(merged_hdr->hdr, ks_c_str(&merged_hdr->out_pg),\n                          ks_len(&merged_hdr->out_pg)) < 0)\n        return -1;\n    if (sam_hdr_add_lines(merged_hdr->hdr, ks_c_str(&merged_hdr->out_co),\n                          ks_len(&merged_hdr->out_co)) < 0)\n        return -1;\n\n    return 0;\n}\n\n/*\n * Free a merged_header_t struct and all associated data.\n *\n * Note that the keys to the rg_ids and pg_ids sets are also used as\n * values in the translation tables.  This function should therefore not\n * be called until the translation tables are no longer needed.\n */\n\nstatic void free_merged_header(merged_header_t *merged_hdr) {\n    size_t i;\n    khiter_t iter;\n    if (!merged_hdr) return;\n    free(ks_release(&merged_hdr->out_rg));\n    free(ks_release(&merged_hdr->out_pg));\n    free(ks_release(&merged_hdr->out_co));\n    if (merged_hdr->target_name) {\n        for (i = 0; i < merged_hdr->n_targets; i++) {\n            free(merged_hdr->target_name[i]);\n        }\n        free(merged_hdr->target_name);\n    }\n    free(merged_hdr->target_len);\n    kh_destroy(c2i, merged_hdr->sq_tids);\n\n    if (merged_hdr->rg_ids) {\n        for (iter = kh_begin(merged_hdr->rg_ids);\n             iter != kh_end(merged_hdr->rg_ids); ++iter) {\n            if (kh_exist(merged_hdr->rg_ids, iter))\n                free(kh_key(merged_hdr->rg_ids, iter));\n        }\n        kh_destroy(cset, merged_hdr->rg_ids);\n    }\n\n    if (merged_hdr->pg_ids) {\n        for (iter = kh_begin(merged_hdr->pg_ids);\n             iter != kh_end(merged_hdr->pg_ids); ++iter) {\n            if (kh_exist(merged_hdr->pg_ids, iter))\n                free(kh_key(merged_hdr->pg_ids, iter));\n        }\n        kh_destroy(cset, merged_hdr->pg_ids);\n    }\n\n    free(merged_hdr);\n}\n\nstatic void bam_translate(bam1_t* b, trans_tbl_t* tbl)\n{\n    // Update target id if not unmapped tid\n    if ( b->core.tid >= 0 ) { b->core.tid = tbl->tid_trans[b->core.tid]; }\n    if ( b->core.mtid >= 0 ) { b->core.mtid = tbl->tid_trans[b->core.mtid]; }\n\n    // If we have a RG update it\n    uint8_t *rg = bam_aux_get(b, \"RG\");\n    if (rg) {\n        char* decoded_rg = bam_aux2Z(rg);\n        khiter_t k = kh_get(c2c, tbl->rg_trans, decoded_rg);\n        if (k != kh_end(tbl->rg_trans)) {\n            char* translate_rg = kh_value(tbl->rg_trans,k);\n            bam_aux_del(b, rg);\n            if (translate_rg) {\n                bam_aux_append(b, \"RG\", 'Z', strlen(translate_rg) + 1,\n                               (uint8_t*)translate_rg);\n            }\n        } else {\n            char *tmp = strdup(decoded_rg);\n            fprintf(stderr,\n                    \"[bam_translate] RG tag \\\"%s\\\" on read \\\"%s\\\" encountered \"\n                    \"with no corresponding entry in header, tag lost. \"\n                    \"Unknown tags are only reported once per input file for \"\n                    \"each tag ID.\\n\",\n                    decoded_rg, bam_get_qname(b));\n            bam_aux_del(b, rg);\n            // Prevent future whinges\n            if (tmp) {\n                int in_there = 0;\n                k = kh_put(c2c, tbl->rg_trans, tmp, &in_there);\n                if (in_there > 0) kh_value(tbl->rg_trans, k) = NULL;\n            }\n        }\n    }\n\n    // If we have a PG update it\n    uint8_t *pg = bam_aux_get(b, \"PG\");\n    if (pg) {\n        char* decoded_pg = bam_aux2Z(pg);\n        khiter_t k = kh_get(c2c, tbl->pg_trans, decoded_pg);\n        if (k != kh_end(tbl->pg_trans)) {\n            char* translate_pg = kh_value(tbl->pg_trans,k);\n            bam_aux_del(b, pg);\n            if (translate_pg) {\n                bam_aux_append(b, \"PG\", 'Z', strlen(translate_pg) + 1,\n                               (uint8_t*)translate_pg);\n            }\n        } else {\n            char *tmp = strdup(decoded_pg);\n            fprintf(stderr,\n                    \"[bam_translate] PG tag \\\"%s\\\" on read \\\"%s\\\" encountered \"\n                    \"with no corresponding entry in header, tag lost. \"\n                    \"Unknown tags are only reported once per input file for \"\n                    \"each tag ID.\\n\",\n                    decoded_pg, bam_get_qname(b));\n            bam_aux_del(b, pg);\n            // Prevent future whinges\n            if (tmp) {\n                int in_there = 0;\n                k = kh_put(c2c, tbl->pg_trans, tmp, &in_there);\n                if (in_there > 0) kh_value(tbl->pg_trans, k) = NULL;\n            }\n        }\n    }\n}\n\nint* rtrans_build(int n, int n_targets, trans_tbl_t* translation_tbl)\n{\n    // Create reverse translation table for tids\n    int* rtrans = (int*)malloc(sizeof(int32_t)*n*n_targets);\n    const int32_t NOTID = INT32_MIN;\n    if (!rtrans) return NULL;\n    memset_pattern4((void*)rtrans, &NOTID, sizeof(int32_t)*n*n_targets);\n    int i;\n    for (i = 0; i < n; ++i) {\n        int j;\n        for (j = 0; j < (translation_tbl+i)->n_targets; ++j) {\n            if ((translation_tbl+i)->tid_trans[j] != -1) {\n                rtrans[i*n_targets + (translation_tbl+i)->tid_trans[j]] = j;\n            }\n        }\n    }\n\n    return rtrans;\n}\n\n#define MERGE_RG          1 // Attach RG tag based on filename\n#define MERGE_UNCOMP      2 // Generate uncompressed BAM\n#define MERGE_LEVEL1      4 // Compress the BAM at level 1 (fast) mode\n#define MERGE_FORCE       8 // Overwrite output BAM if it exists\n#define MERGE_COMBINE_RG 16 // Combine RG tags frather than redefining them\n#define MERGE_COMBINE_PG 32 // Combine PG tags frather than redefining them\n#define MERGE_FIRST_CO   64 // Use only first file's @CO headers (sort cmd only)\n\n\nstatic hts_reglist_t *duplicate_reglist(const hts_reglist_t *rl, int rn) {\n    if (!rl)\n        return NULL;\n\n    hts_reglist_t *new_rl = calloc(rn, sizeof(hts_reglist_t));\n    if (!new_rl)\n        return NULL;\n\n    int i;\n    for (i=0; i < rn; i++) {\n        new_rl[i].tid     = rl[i].tid;\n        new_rl[i].count   = rl[i].count;\n        new_rl[i].min_beg = rl[i].min_beg;\n        new_rl[i].max_end = rl[i].max_end;\n\n        new_rl[i].reg = rl[i].reg;\n        new_rl[i].intervals = malloc(new_rl[i].count * sizeof(hts_pair_pos_t));\n        if (!new_rl[i].intervals) {\n            hts_reglist_free(new_rl, i);\n            return NULL;\n        }\n        memcpy(new_rl[i].intervals, rl[i].intervals, new_rl[i].count * sizeof(hts_pair_pos_t));\n    }\n\n    return new_rl;\n}\n\n/*\n * How merging is handled\n *\n * If a header is defined use we will use that as our output header\n * otherwise we use the first header from the first input file.\n *\n * Now go through each file and create a translation table for that file for:\n * -RG\n * -tid\n * -PG tags\n *\n * Then whenever we read a record from a bam we translate that read before\n * stashing it in the hash.\n *\n * In the actual merge, a read is read from each input file, translated and\n * stashed in the hash. This assumes that all input files are sorted in the\n * same way.  Next we just extract the next position ordered read from the\n * hash, and replace it if there are still reads left in it's source input\n * file. Finally we write our chosen read it to the output file.\n */\n\n/*!\n  @abstract    Merge multiple sorted BAM.\n  @param  sam_order   the order in which the data was sorted\n  @param  sort_tag    if non-null, the tag that data was sorted by\n  @param  out         output BAM file name\n  @param  mode        sam_open() mode to be used to create the final output file\n                      (overrides level settings from UNCOMP and LEVEL1 flags)\n  @param  headers     name of SAM file from which to copy '@' header lines,\n                      or NULL to copy them from the first file to be merged\n  @param  n           number of files to be merged\n  @param  fn          names of files to be merged\n  @param  flag        flags that control how the merge is undertaken\n  @param  reg         region to merge\n  @param  n_threads   number of threads to use (passed to htslib)\n  @param  cmd         command name (used in print_error() etc)\n  @param  in_fmt      format options for input files\n  @param  out_fmt     output file format and options\n  @param  write_index create the index, together with the output file\n  @param  arg_list    command string for PG line\n  @param  no_pg       if 1, do not add a new PG line\n  @discussion Padding information may NOT correctly maintained. This\n  function is NOT thread safe.\n */\nint bam_merge_core2(SamOrder sam_order, char* sort_tag, const char *out, const char *mode,\n                    const char *headers, int n, char * const *fn, char * const *fn_idx,\n                    const char *fn_bed, int flag, const char *reg, int n_threads,\n                    const char *cmd, const htsFormat *in_fmt, const htsFormat *out_fmt,\n                    int write_index, char *arg_list, int no_pg)\n{\n    samFile *fpout, **fp = NULL;\n    heap1_t *heap = NULL;\n    sam_hdr_t *hout = NULL;\n    sam_hdr_t *hin  = NULL;\n    int i, j, *RG_len = NULL;\n    uint64_t idx = 0;\n    char **RG = NULL;\n    hts_itr_t **iter = NULL;\n    sam_hdr_t **hdr = NULL;\n    trans_tbl_t *translation_tbl = NULL;\n    int *rtrans = NULL;\n    char *out_idx_fn = NULL;\n    void *hreg = NULL;\n    hts_reglist_t *lreg = NULL;\n    merged_header_t *merged_hdr = init_merged_header();\n    if (!merged_hdr) return -1;\n    refs_t *refs = NULL;\n    template_coordinate_keys_t *keys = NULL;\n    khash_t(const_c2c) *lib_lookup = NULL;\n\n    // Is there a specified pre-prepared header to use for output?\n    if (headers) {\n        samFile* fpheaders = sam_open(headers, \"r\");\n        if (fpheaders == NULL) {\n            print_error_errno(cmd, \"cannot open \\\"%s\\\"\", headers);\n            return -1;\n        }\n        hin = sam_hdr_read(fpheaders);\n        sam_close(fpheaders);\n        if (hin == NULL) {\n            print_error(cmd, \"couldn't read headers from \\\"%s\\\"\", headers);\n            goto mem_fail;\n        }\n    }\n\n    g_sam_order = sam_order;\n    if (sam_order == TagQueryName || sam_order == TagCoordinate) {\n        g_sort_tag[0] = sort_tag[0];\n        g_sort_tag[1] = sort_tag[0] ? sort_tag[1] : '\\0';\n    }\n\n    fp = (samFile**)calloc(n, sizeof(samFile*));\n    if (!fp) goto mem_fail;\n    heap = (heap1_t*)calloc(n, sizeof(heap1_t));\n    if (!heap) goto mem_fail;\n    iter = (hts_itr_t**)calloc(n, sizeof(hts_itr_t*));\n    if (!iter) goto mem_fail;\n    hdr = (sam_hdr_t**)calloc(n, sizeof(sam_hdr_t*));\n    if (!hdr) goto mem_fail;\n    translation_tbl = (trans_tbl_t*)calloc(n, sizeof(trans_tbl_t));\n    if (!translation_tbl) goto mem_fail;\n    RG = (char**)calloc(n, sizeof(char*));\n    if (!RG) goto mem_fail;\n\n    // prepare RG tag from file names\n    if (flag & MERGE_RG) {\n        RG_len = (int*)calloc(n, sizeof(int));\n        if (!RG_len) goto mem_fail;\n        for (i = 0; i != n; ++i) {\n            int l = strlen(fn[i]);\n            const char *s = fn[i];\n            if (l > 4 && (strcmp(s + l - 4, \".bam\") == 0 || strcmp(s + l - 4, \".sam\") == 0)) l -= 4;\n            if (l > 5 && strcmp(s + l - 5, \".cram\") == 0) l -= 5;\n            for (j = l - 1; j >= 0; --j) if (s[j] == '/') break;\n            ++j; l -= j;\n            RG[i] = (char*)calloc(l + 1, 1);\n            if (!RG[i]) goto mem_fail;\n            RG_len[i] = l;\n            strncpy(RG[i], s + j, l);\n        }\n    }\n\n    if (hin) {\n        // Populate merged_hdr from the pre-prepared header\n        trans_tbl_t dummy;\n        int res;\n        res = trans_tbl_init(merged_hdr, hin, &dummy, flag & MERGE_COMBINE_RG,\n                             flag & MERGE_COMBINE_PG, true, NULL);\n        trans_tbl_destroy(&dummy);\n        if (res) return -1; // FIXME: memory leak\n    }\n\n    // open and read the header from each file\n    for (i = 0; i < n; ++i) {\n        sam_hdr_t *hin;\n        fp[i] = sam_open_format(fn[i], \"r\", in_fmt);\n        if (fp[i] == NULL) {\n            print_error_errno(cmd, \"fail to open \\\"%s\\\"\", fn[i]);\n            goto fail;\n        }\n        hts_set_opt(fp[i], HTS_OPT_BLOCK_SIZE, BAM_BLOCK_SIZE);\n        hin = sam_hdr_read(fp[i]);\n        if (hin == NULL) {\n            print_error(cmd, \"failed to read header from \\\"%s\\\"\", fn[i]);\n            goto fail;\n        }\n\n        if (trans_tbl_init(merged_hdr, hin, translation_tbl+i,\n                           flag & MERGE_COMBINE_RG, flag & MERGE_COMBINE_PG,\n                           (flag & MERGE_FIRST_CO)? (i == 0) : true,\n                           RG[i]))\n            goto fail;\n\n        hdr[i] = hin;\n\n        int order_ok = 1;\n        if ((translation_tbl+i)->lost_coord_sort && (sam_order == Coordinate || sam_order == MinHash)) {\n            fprintf(stderr, \"[bam_merge_core] Order of targets in file %s caused coordinate sort to be lost\\n\", fn[i]);\n            order_ok = 0;\n        }\n\n        if (!refs)\n            refs = cram_get_refs(fp[i]);\n\n        if (order_ok && refs && hts_set_opt(fp[i], CRAM_OPT_SHARED_REF, refs))\n            goto fail;\n    }\n\n    // Did we get an @HD line?\n    if (!merged_hdr->have_hd) {\n        fprintf(stderr, \"[W::%s] No @HD tag found.\\n\", __func__);\n        /* FIXME:  Should we add an @HD line here, and if so what should\n           we put in it? Ideally we want a way of getting htslib to tell\n           us the SAM version number to assume given no @HD line.  Is\n           it also safe to assume that the output is coordinate sorted?\n           SO: is optional so we don't have to have it.*/\n        /* ksprintf(&merged_hdr->out_hd, \"@HD\\tVN:1.5\\tSO:coordinate\\n\"); */\n    }\n\n    // Transform the header into standard form\n    if (finish_merged_header(merged_hdr) < 0)\n        goto fail;\n\n    hout = merged_hdr->hdr;\n    if (!hout)\n        goto fail;\n\n    // If we're only merging a specified region move our iters to start at that point\n    int tid, nreg;\n    hts_pos_t beg, end;\n\n    if (fn_bed) {\n        hreg = bed_read(fn_bed);\n        if (!hreg) {\n            fprintf(stderr, \"[%s] Could not read BED file: \\\"%s\\\"\\n\", __func__, fn_bed);\n            goto fail;\n        }\n        bed_unify(hreg);\n        lreg = bed_reglist(hreg, ALL, &nreg);\n        if (!lreg || !nreg) {\n            fprintf(stderr, \"[%s] Null or empty region list\\n\", __func__);\n            goto fail;\n        }\n    } else if (reg) {\n        rtrans = rtrans_build(n, sam_hdr_nref(hout), translation_tbl);\n        if (!rtrans) goto mem_fail;\n\n        if (!sam_parse_region(hout, reg, &tid, &beg, &end, 0)) {\n            fprintf(stderr, \"[%s] Badly formatted region or unknown reference name: \\\"%s\\\"\\n\", __func__, reg);\n            goto fail;\n        }\n\n    }\n\n    if (reg || fn_bed) {\n        hts_idx_t *reg_idx = NULL;\n        for (i = 0; i < n; ++i) {\n\n            // If index filename has not been specified, look in the BAM folder\n            if (fn_idx != NULL) {\n                reg_idx = sam_index_load2(fp[i], fn[i], fn_idx[i]);\n            } else {\n                reg_idx = sam_index_load(fp[i], fn[i]);\n            }\n            if (reg_idx == NULL) {\n                fprintf(stderr, \"[%s] failed to load index for %s. Random alignment retrieval only works for indexed BAM or CRAM files.\\n\",\n                        __func__, fn[i]);\n                free(rtrans);\n                rtrans = NULL;\n                goto fail;\n            }\n\n            int mapped_tid = INT32_MIN;\n            if (fn_bed) {\n                hts_reglist_t *rl = duplicate_reglist(lreg, nreg);\n                iter[i] = sam_itr_regions(reg_idx, hdr[i], rl, nreg);\n            } else {\n                // (rtrans[i*n+tid]) Look up what hout tid translates to in input tid space\n                mapped_tid = rtrans[i*sam_hdr_nref(hout)+tid];\n                if (mapped_tid != INT32_MIN) {\n                    iter[i] = sam_itr_queryi(reg_idx, mapped_tid, beg, end);\n                } else {\n                    iter[i] = sam_itr_queryi(reg_idx, HTS_IDX_NONE, 0, 0);\n                }\n            }\n\n            if (iter[i] == NULL) {\n                if (fn_bed) {\n                    fprintf(stderr, \"[%s] failed to get multi-region iterator \"\n                            \"{%s, %s}\\n\", __func__, fn[i], fn_bed);\n                } else {\n                    if (mapped_tid != INT32_MIN) {\n                        fprintf(stderr,\n                                \"[%s] failed to get iterator over \"\n                                \"{%s, %d, %\"PRIhts_pos\", %\"PRIhts_pos\"}\\n\",\n                                __func__, fn[i], mapped_tid, beg, end);\n                    } else {\n                        fprintf(stderr,\n                                \"[%s] failed to get iterator over \"\n                                \"{%s, HTS_IDX_NONE, 0, 0}\\n\",\n                                __func__, fn[i]);\n                    }\n                }\n                hts_idx_destroy(reg_idx);\n                free(rtrans);\n                rtrans = NULL;\n                goto fail;\n            }\n\n            hts_idx_destroy(reg_idx);\n        }\n\n        free(rtrans);\n        rtrans = NULL;\n    }\n\n    // Make sure that there's enough memory for template coordinate keys, one per file to read\n    if (sam_order == TemplateCoordinate) {\n        if ((keys = malloc(sizeof(template_coordinate_keys_t))) == NULL) {\n            print_error(cmd, \"could not allocate memory for the top-level keys\");\n            goto mem_fail;\n        }\n        keys->n = 0;\n        keys->m = 0;\n        keys->buffer_size = 0x10000;\n        keys->buffers = NULL;\n        // Make sure that there's enough memory for template coordinate keys, one per file to read\n        if (keys->n + n >= keys->m * keys->buffer_size) {\n            if (template_coordinate_keys_realloc(keys, keys->n + n) < 0) goto mem_fail;\n        }\n        lib_lookup = lookup_libraries(hout);\n        if (!lib_lookup) {\n            goto mem_fail;\n        }\n    }\n\n    // Load the first read from each file into the heap\n    for (i = 0; i < n; ++i) {\n        heap1_t *h = heap + i;\n        int res;\n        h->i = i;\n        h->entry.bam_record = bam_init1();\n        h->entry.u.tag = NULL;\n        if (!h->entry.bam_record) goto mem_fail;\n        res = iter[i] ? sam_itr_next(fp[i], iter[i], h->entry.bam_record) : sam_read1(fp[i], hdr[i], h->entry.bam_record);\n        if (res >= 0) {\n            bam_translate(h->entry.bam_record, translation_tbl + i);\n            h->tid = h->entry.bam_record->core.tid;\n            h->pos = (uint64_t)(h->entry.bam_record->core.pos + 1);\n            h->rev = bam_is_rev(h->entry.bam_record);\n            h->idx = idx++;\n            if (g_sam_order == TagQueryName || g_sam_order == TagCoordinate) {\n                h->entry.u.tag = bam_aux_get(h->entry.bam_record, g_sort_tag);\n            } else if (g_sam_order == TemplateCoordinate) {\n                template_coordinate_key_t *key = template_coordinate_keys_get(keys, i); // get the next key to use\n                h->entry.u.key = template_coordinate_key(h->entry.bam_record, key, hout, lib_lookup); // update the key\n                if (h->entry.u.key == NULL) goto fail; // key could not be created, error out\n            } else {\n                h->entry.u.tag = NULL;\n            }\n        }\n        else if (res == -1 && (!iter[i] || iter[i]->finished)) {\n            h->pos = HEAP_EMPTY;\n            bam_destroy1(h->entry.bam_record);\n            h->entry.bam_record = NULL;\n            h->entry.u.tag = NULL;\n            h->entry.u.key = NULL;\n        } else {\n            print_error(cmd, \"failed to read first record from \\\"%s\\\"\", fn[i]);\n            goto fail;\n        }\n    }\n\n    // Open output file and write header\n    if ((fpout = sam_open_format(out, mode, out_fmt)) == 0) {\n        print_error_errno(cmd, \"failed to create \\\"%s\\\"\", out);\n        return -1;\n    }\n    hts_set_opt(fpout, HTS_OPT_BLOCK_SIZE, BAM_BLOCK_SIZE);\n    if (!no_pg && sam_hdr_add_pg(hout, \"samtools\",\n                                 \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL)) {\n        print_error(cmd, \"failed to add PG line to the header of \\\"%s\\\"\", out);\n        sam_close(fpout);\n        return -1;\n    }\n    if (sam_hdr_write(fpout, hout) != 0) {\n        print_error_errno(cmd, \"failed to write header to \\\"%s\\\"\", out);\n        sam_close(fpout);\n        return -1;\n    }\n    if (write_index) {\n        if (!(out_idx_fn = auto_index(fpout, out, hout))){\n            sam_close(fpout);\n            return -1;\n        }\n    }\n    if (!(flag & MERGE_UNCOMP)) hts_set_threads(fpout, n_threads);\n\n    if (refs && hts_set_opt(fpout, CRAM_OPT_SHARED_REF, refs))\n        goto fail;\n\n    // Begin the actual merge\n    ks_heapmake(heap, n, heap);\n    while (heap->pos != HEAP_EMPTY) {\n        bam1_t *b = heap->entry.bam_record;\n        if (flag & MERGE_RG) {\n            uint8_t *rg = bam_aux_get(b, \"RG\");\n            if (rg) bam_aux_del(b, rg);\n            bam_aux_append(b, \"RG\", 'Z', RG_len[heap->i] + 1, (uint8_t*)RG[heap->i]);\n        }\n        if (sam_write1(fpout, hout, b) < 0) {\n            print_error_errno(cmd, \"failed writing to \\\"%s\\\"\", out);\n            sam_close(fpout);\n            free(out_idx_fn);\n            return -1;\n        }\n        if ((j = (iter[heap->i]? sam_itr_next(fp[heap->i], iter[heap->i], b) : sam_read1(fp[heap->i], hdr[heap->i], b))) >= 0) {\n            bam_translate(b, translation_tbl + heap->i);\n            heap->tid = b->core.tid;\n            heap->pos = (uint64_t)(b->core.pos + 1);\n            heap->rev = bam_is_rev(b);\n            heap->idx = idx++;\n            if (g_sam_order == TagQueryName || g_sam_order == TagCoordinate) {\n                heap->entry.u.tag = bam_aux_get(heap->entry.bam_record, g_sort_tag);\n            } else if (g_sam_order == TemplateCoordinate) {\n                template_coordinate_key_t *key = template_coordinate_keys_get(keys, heap->i); // get the next key to use\n                heap->entry.u.key = template_coordinate_key(heap->entry.bam_record, key, hout, lib_lookup); // update the key\n                if (heap->entry.u.key == NULL) goto fail; // key could not be created, error out\n            } else {\n                heap->entry.u.tag = NULL;\n            }\n        } else if (j == -1 && (!iter[heap->i] || iter[heap->i]->finished)) {\n            heap->pos = HEAP_EMPTY;\n            bam_destroy1(heap->entry.bam_record);\n            heap->entry.bam_record = NULL;\n            heap->entry.u.tag = NULL;\n        } else {\n            print_error(cmd, \"\\\"%s\\\" is truncated\", fn[heap->i]);\n            goto fail;\n        }\n        ks_heapadjust(heap, 0, n, heap);\n    }\n\n    if (write_index) {\n        if (sam_idx_save(fpout) < 0) {\n            print_error_errno(\"merge\", \"writing index failed\");\n            goto fail;\n        }\n    }\n    free(out_idx_fn);\n\n    // Clean up and close\n    if (flag & MERGE_RG) {\n        for (i = 0; i != n; ++i) free(RG[i]);\n        free(RG_len);\n    }\n    for (i = 0; i < n; ++i) {\n        trans_tbl_destroy(translation_tbl + i);\n        hts_itr_destroy(iter[i]);\n        sam_hdr_destroy(hdr[i]);\n        sam_close(fp[i]);\n    }\n    sam_hdr_destroy(hin);\n    sam_hdr_destroy(hout);\n    free_merged_header(merged_hdr);\n    hts_reglist_free(lreg, nreg);\n    bed_destroy(hreg);\n    free(RG); free(translation_tbl); free(fp); free(heap); free(iter); free(hdr);\n    if (sam_close(fpout) < 0) {\n        print_error_errno(cmd, \"error closing output file \\\"%s\\\"\", out);\n        return -1;\n    }\n    if (keys != NULL) {\n        for (i = 0; i < keys->m; ++i) {\n            free(keys->buffers[i]);\n        }\n        free(keys->buffers);\n        free(keys);\n    }\n    lib_lookup_destroy(lib_lookup);\n    return 0;\n\n mem_fail:\n    print_error(cmd, \"Out of memory\");\n\n fail:\n    if (flag & MERGE_RG) {\n        if (RG) {\n            for (i = 0; i != n; ++i) free(RG[i]);\n        }\n        free(RG_len);\n    }\n    for (i = 0; i < n; ++i) {\n        if (translation_tbl && translation_tbl[i].tid_trans) trans_tbl_destroy(translation_tbl + i);\n        if (iter && iter[i]) hts_itr_destroy(iter[i]);\n        if (hdr && hdr[i]) sam_hdr_destroy(hdr[i]);\n        if (fp && fp[i]) sam_close(fp[i]);\n        if (heap && heap[i].entry.bam_record) bam_destroy1(heap[i].entry.bam_record);\n    }\n    if (hout) sam_hdr_destroy(hout);\n    free(RG);\n    free(translation_tbl);\n    free(hdr);\n    hts_reglist_free(lreg, nreg);\n    bed_destroy(hreg);\n    free(iter);\n    free(heap);\n    free(fp);\n    free(rtrans);\n    free(out_idx_fn);\n    if (keys != NULL) {\n        for (i = 0; i < keys->m; ++i) {\n            free(keys->buffers[i]);\n        }\n        free(keys->buffers);\n        free(keys);\n    }\n    lib_lookup_destroy(lib_lookup);\n    return -1;\n}\n\n// Unused here but may be used by legacy samtools-using third-party code\nint bam_merge_core(int by_qname, const char *out, const char *headers, int n, char * const *fn, int flag, const char *reg)\n{\n    char mode[12];\n    strcpy(mode, \"wb\");\n    if (flag & MERGE_UNCOMP) strcat(mode, \"0\");\n    else if (flag & MERGE_LEVEL1) strcat(mode, \"1\");\n    SamOrder sam_order = by_qname ? QueryName : Coordinate;\n    return bam_merge_core2(sam_order, NULL, out, mode, headers, n, fn, NULL, NULL, flag, reg, 0, \"merge\", NULL, NULL, 0, NULL, 1);\n}\n\nstatic void merge_usage(FILE *to)\n{\n    fprintf(to,\n\"Usage: samtools merge [options] -o <out.bam> [options] <in1.bam> ... <inN.bam>\\n\"\n\"   or: samtools merge [options] <out.bam> <in1.bam> ... <inN.bam>\\n\"\n\"\\n\"\n\"Options:\\n\"\n\"  -n         Input files are sorted by read name (natural)\\n\"\n\"  -N         Input files are sorted by read name (ASCII)\\n\"\n\"  -t TAG     Input files are sorted by TAG value\\n\"\n\"  -r         Attach RG tag (inferred from file names)\\n\"\n\"  -u         Uncompressed BAM output\\n\"\n\"  -f         Overwrite the output BAM if exist\\n\"\n\"  -o FILE    Specify output file via option instead of <out.bam> argument\\n\"\n\"  -1         Compress level 1\\n\"\n\"  -l INT     Compression level, from 0 to 9 [-1]\\n\"\n\"  -R STR     Merge file in the specified region STR [all]\\n\"\n\"  -h FILE    Copy the header in FILE to <out.bam> [in1.bam]\\n\"\n\"  -c         Combine @RG headers with colliding IDs [alter IDs to be distinct]\\n\"\n\"  -p         Combine @PG headers with colliding IDs [alter IDs to be distinct]\\n\"\n\"  -s VALUE   Override random seed\\n\"\n\"  -b FILE    List of input BAM filenames, one per line [null]\\n\"\n\"  -X         Use customized index files\\n\"\n\"  -L FILE    Specify a BED file for multiple region filtering [null]\\n\"\n\"  --no-PG    do not add a PG line\\n\"\n\"  --template-coordinate Input files are sorted by template-coordinate\\n\");\n    sam_global_opt_help(to, \"-.O..@..\");\n}\n\nint bam_merge(int argc, char *argv[])\n{\n    int c, flag = 0, ret = 0, level = -1, has_index_file = 0;\n    char *fn_headers = NULL, *reg = NULL, mode[12];\n    char *sort_tag = NULL, *fnout = NULL, *arg_list = NULL;\n    long random_seed = (long)time(NULL);\n    char** fn = NULL;\n    char** fn_idx = NULL, *fn_bed = NULL;\n    int fn_size = 0, no_pg = 0;\n    SamOrder sam_order = Coordinate;\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', 0, 0, '@'),\n        { \"threads\", required_argument, NULL, '@' },\n        {\"no-PG\", no_argument, NULL, 1},\n        { \"template-coordinate\", no_argument, NULL, 2},\n        { NULL, 0, NULL, 0 }\n    };\n\n    if (argc == 1) {\n        merge_usage(stdout);\n        return 0;\n    }\n\n    while ((c = getopt_long(argc, argv, \"h:nNru1R:o:f@:l:cps:b:O:t:XL:\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'r': flag |= MERGE_RG; break;\n        case 'f': flag |= MERGE_FORCE; break;\n        case 'h': fn_headers = optarg; break;\n        case 'N': natural_sort = 0; // fall through\n        case 'n': sam_order = QueryName; break;\n        case 'o': fnout = optarg; break;\n        case 't': sort_tag = optarg; break;\n        case '1': flag |= MERGE_LEVEL1; level = 1; break;\n        case 'u': flag |= MERGE_UNCOMP; level = 0; break;\n        case 'R': reg = strdup(optarg); break;\n        case 'l': level = atoi(optarg); break;\n        case 'c': flag |= MERGE_COMBINE_RG; break;\n        case 'p': flag |= MERGE_COMBINE_PG; break;\n        case 's': random_seed = atol(optarg); break;\n        case 'X': has_index_file = 1; break; // -X flag for index filename\n        case 'L': fn_bed = optarg; break;\n        case 'b': {\n            // load the list of files to read\n            if (has_index_file) {\n                fprintf(stderr,\"Error: The -b option cannot be combined with -X\\n\");\n                ret = 1; goto end;\n            }\n            int nfiles;\n            char **fn_read = hts_readlines(optarg, &nfiles);\n            if (fn_read) {\n                // Append to end of array\n                fn = realloc(fn, (fn_size+nfiles) * sizeof(char*));\n                if (fn == NULL) { ret = 1; goto end; }\n                memcpy(fn+fn_size, fn_read, nfiles * sizeof(char*));\n                fn_size += nfiles;\n                free(fn_read);\n            }\n            else {\n                print_error(\"merge\", \"Invalid file list \\\"%s\\\"\", optarg);\n                ret = 1;\n            }\n            break;\n        }\n        case 1: no_pg = 1; break;\n        case 2: sam_order = TemplateCoordinate; break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                  /* else fall-through */\n        case '?': merge_usage(stderr); return 1;\n        }\n    }\n\n    if (sort_tag != NULL) {\n        sam_order = sam_order == QueryName ? TagQueryName : TagCoordinate;\n    }\n\n    if (fnout == NULL && argc - optind >= 1) {\n        fnout = argv[optind];\n        optind++;\n    }\n    if (fnout == NULL) {\n        print_error(\"merge\", \"You must at least specify the output file\");\n        merge_usage(stderr);\n        return 1;\n    }\n\n    if (!no_pg && !(arg_list = stringify_argv(argc+1, argv-1))) {\n        print_error(\"merge\", \"failed to create arg_list\");\n        return 1;\n    }\n\n    hts_srand48(random_seed);\n    if (!(flag & MERGE_FORCE) && strcmp(fnout, \"-\") != 0) {\n        struct stat sbuf;\n        if (stat(fnout, &sbuf) == 0 && S_ISREG(sbuf.st_mode)) {\n            fprintf(stderr, \"[%s] File '%s' exists. Please apply '-f' to overwrite. Abort.\\n\", __func__, fnout);\n            ret = 1;\n            goto end;\n        }\n    }\n\n    int nargcfiles = 0;\n    if (has_index_file) { // Calculate # of input BAM files\n        if ((argc - optind) % 2 != 0) {\n            fprintf(stderr, \"Odd number of filenames detected! Each BAM file should have an index file\\n\");\n            ret = 1;\n            goto end;\n        }\n        nargcfiles = (argc - optind) / 2;\n    } else {\n        nargcfiles = argc - optind;\n    }\n\n    if (nargcfiles > 0) {\n        // Add argc files to end of array\n        fn = realloc(fn, (fn_size+nargcfiles) * sizeof(char*));\n        if (fn == NULL) { ret = 1; goto end; }\n        memcpy(fn+fn_size, argv + optind, nargcfiles * sizeof(char*));\n\n        if(has_index_file) {\n            fn_idx = realloc(fn_idx, nargcfiles * sizeof(char*));\n            if (fn_idx == NULL) { ret = 1; goto end; }\n            memcpy(fn_idx+fn_size, argv + nargcfiles + optind, nargcfiles * sizeof(char*));\n        }\n    }\n    if (fn_size+nargcfiles < 1) {\n        print_error(\"merge\", \"You must specify at least one (and usually two or more) input files\");\n        merge_usage(stderr);\n        ret = 1;\n        goto end;\n    }\n\n    if (reg && fn_bed) {\n        print_error(\"merge\", \"You must specify either a BED file or a region\");\n        ret = 1;\n        goto end;\n    }\n    strcpy(mode, \"wb\");\n    sam_open_mode(mode+1, fnout, NULL);\n    if (level >= 0) sprintf(strchr(mode, '\\0'), \"%d\", level < 9? level : 9);\n    if (bam_merge_core2(sam_order, sort_tag, fnout, mode, fn_headers,\n                        fn_size+nargcfiles, fn, fn_idx, fn_bed, flag, reg, ga.nthreads,\n                        \"merge\", &ga.in, &ga.out, ga.write_index, arg_list, no_pg) < 0)\n        ret = 1;\n\nend:\n    if (fn_size > 0) {\n        int i;\n        for (i=0; i<fn_size; i++) free(fn[i]);\n    }\n    free(fn);\n    free(fn_idx);\n    free(reg);\n    free(arg_list);\n    sam_global_args_free(&ga);\n    return ret;\n}\n\n/***************\n * BAM sorting *\n ***************/\n\n\ntypedef struct {\n    size_t from;\n    size_t to;\n} buf_region;\n\n/* Simplified version of bam_merge_core2() for merging part-sorted\n   temporary files.  No need for header merging or translation,\n   it just needs to read data into the heap and push it out again. */\n\nstatic inline int heap_add_read(heap1_t *heap, int nfiles, samFile **fp,\n                                int num_in_mem, buf_region *in_mem,\n                                bam1_tag *buf, template_coordinate_keys_t *keys,\n                                uint64_t *idx, sam_hdr_t *hout,\n                                khash_t(const_c2c) *lib_lookup) {\n    int i = heap->i, res;\n    if (i < nfiles) { // read from file\n        res = sam_read1(fp[i], hout, heap->entry.bam_record);\n        if (res >= 0 && g_sam_order == TemplateCoordinate) { // file read OK and TemplateCoordinate order\n            // It is assumed that there are nfiles more keys allocated than keys->n; see allocation in bam_merge_simple\n            template_coordinate_key_t *key = template_coordinate_keys_get(keys, keys->n + i); // get the next key to use\n            heap->entry.u.key = template_coordinate_key(heap->entry.bam_record, key, hout, lib_lookup); // update the key\n            if (heap->entry.u.key == NULL) res = -1; // key could not be created, error out\n        }\n    } else { // read from memory\n        if (in_mem[i - nfiles].from < in_mem[i - nfiles].to) {\n            size_t from = in_mem[i - nfiles].from;\n            heap->entry.bam_record = buf[from].bam_record;\n            if (g_sam_order == TemplateCoordinate) heap->entry.u.key = buf[from].u.key;\n            in_mem[i - nfiles].from++;\n            res = 0;\n        } else {\n            res = -1;\n        }\n    }\n    if (res >= 0) {\n        heap->tid = heap->entry.bam_record->core.tid;\n        heap->pos = (uint64_t)(heap->entry.bam_record->core.pos + 1);\n        heap->rev = bam_is_rev(heap->entry.bam_record);\n        heap->idx = (*idx)++;\n        if (g_sam_order == TagQueryName || g_sam_order == TagCoordinate) {\n            heap->entry.u.tag = bam_aux_get(heap->entry.bam_record, g_sort_tag);\n        } else if (g_sam_order != TemplateCoordinate) {\n            heap->entry.u.tag = NULL;\n            heap->entry.u.key = NULL;\n        }\n    } else if (res == -1) {\n        heap->pos = HEAP_EMPTY;\n        if (i < nfiles) bam_destroy1(heap->entry.bam_record);\n        heap->entry.bam_record = NULL;\n        heap->entry.u.tag = NULL;\n        heap->entry.u.key = NULL;\n    } else {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int bam_merge_simple(SamOrder sam_order, char *sort_tag, const char *out,\n                            const char *mode, sam_hdr_t *hout,\n                            int n, char * const *fn, int num_in_mem,\n                            buf_region *in_mem, bam1_tag *buf,\n                            template_coordinate_keys_t *keys,\n                            khash_t(const_c2c) *lib_lookup,\n                            htsThreadPool *htspool,\n                            const char *cmd, const htsFormat *in_fmt,\n                            const htsFormat *out_fmt, char *arg_list, int no_pg,\n                            int write_index, int final_out) {\n    samFile *fpout = NULL, **fp = NULL;\n    heap1_t *heap = NULL;\n    uint64_t idx = 0;\n    int i, heap_size = n + num_in_mem;\n    char *out_idx_fn = NULL;\n\n    if (sam_order == TagQueryName || sam_order == TagCoordinate) {\n        g_sort_tag[0] = sort_tag[0];\n        g_sort_tag[1] = sort_tag[0] ? sort_tag[1] : '\\0';\n    }\n    if (n > 0) {\n        fp = (samFile**)calloc(n, sizeof(samFile*));\n        if (!fp) goto mem_fail;\n    }\n    heap = (heap1_t*)calloc(heap_size, sizeof(heap1_t));\n    if (!heap) goto mem_fail;\n\n    // Make sure that there's enough memory for template coordinate keys, one per file to read\n    if (keys && keys->n + n >= keys->m * keys->buffer_size) {\n        if (template_coordinate_keys_realloc(keys, keys->n + n) < 0) goto mem_fail;\n    }\n\n    // Open each file, read the header and put the first read into the heap\n    for (i = 0; i < heap_size; i++) {\n        sam_hdr_t *hin;\n        heap1_t *h = &heap[i];\n\n        if (i < n) {\n            fp[i] = sam_open_format(fn[i], \"r\", in_fmt);\n            if (fp[i] == NULL) {\n                print_error_errno(cmd, \"fail to open \\\"%s\\\"\", fn[i]);\n                goto fail;\n            }\n            hts_set_opt(fp[i], HTS_OPT_BLOCK_SIZE, BAM_BLOCK_SIZE);\n            if (htspool->pool)\n                hts_set_opt(fp[i], HTS_OPT_THREAD_POOL, htspool);\n\n            // Read header ...\n            hin = sam_hdr_read(fp[i]);\n            if (hin == NULL) {\n                print_error(cmd, \"failed to read header from \\\"%s\\\"\", fn[i]);\n                goto fail;\n            }\n            // ... and throw it away as we don't really need it\n            sam_hdr_destroy(hin);\n        }\n\n        // Get a read into the heap\n        h->i = i;\n        h->entry.u.tag = NULL;\n        h->entry.u.key = NULL;\n        if (i < n) {\n            h->entry.bam_record = bam_init1();\n            if (!h->entry.bam_record) goto mem_fail;\n        }\n        if (heap_add_read(h, n, fp, num_in_mem, in_mem, buf, keys, &idx, hout,\n                          lib_lookup) < 0) {\n            assert(i < n);\n            print_error(cmd, \"failed to read first record from \\\"%s\\\"\", fn[i]);\n            goto fail;\n        }\n    }\n\n    // Open output file and write header\n    if ((fpout = sam_open_format(out, mode, out_fmt)) == 0) {\n        print_error_errno(cmd, \"failed to create \\\"%s\\\"\", out);\n        return -1;\n    }\n    hts_set_opt(fpout, HTS_OPT_BLOCK_SIZE, BAM_BLOCK_SIZE);\n\n    if (!no_pg && sam_hdr_add_pg(hout, \"samtools\",\n                                 \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL)) {\n        print_error(cmd, \"failed to add PG line to the header of \\\"%s\\\"\", out);\n        sam_close(fpout);\n        return -1;\n    }\n\n    if (htspool->pool)\n        hts_set_opt(fpout, HTS_OPT_THREAD_POOL, htspool);\n\n    if (sam_hdr_write(fpout, hout) != 0) {\n        print_error_errno(cmd, \"failed to write header to \\\"%s\\\"\", out);\n        sam_close(fpout);\n        return -1;\n    }\n\n    if (write_index) {\n        if (!(out_idx_fn = auto_index(fpout, out, hout))){\n            sam_close(fpout);\n            return -1;\n        }\n    }\n\n    // Now do the merge\n    ks_heapmake(heap, heap_size, heap);\n    while (heap->pos != HEAP_EMPTY) {\n        bam1_t *b = heap->entry.bam_record;\n        if (g_sam_order == MinHash && b->core.tid == -1 && final_out) {\n            // Remove the cached minhash value\n            b->core.pos = -1;\n            b->core.mpos = -1;\n            b->core.isize = 0;\n        }\n        if (sam_write1(fpout, hout, b) < 0) {\n            print_error_errno(cmd, \"failed writing to \\\"%s\\\"\", out);\n            goto fail;\n        }\n        if (heap_add_read(heap, n, fp, num_in_mem, in_mem, buf, keys, &idx,\n                          hout, lib_lookup) < 0) {\n            assert(heap->i < n);\n            print_error(cmd, \"Error reading \\\"%s\\\" : %s\",\n                        fn[heap->i], strerror(errno));\n            goto fail;\n        }\n        ks_heapadjust(heap, 0, heap_size, heap);\n    }\n    // Clean up and close\n    for (i = 0; i < n; i++) {\n        if (sam_close(fp[i]) != 0) {\n            print_error(cmd, \"Error on closing \\\"%s\\\" : %s\",\n                        fn[i], strerror(errno));\n        }\n    }\n    free(fp);\n    free(heap);\n\n    if (write_index) {\n        if (sam_idx_save(fpout) < 0) {\n            print_error_errno(\"merge\", \"writing index failed\");\n            goto fail;\n        }\n        free(out_idx_fn);\n    }\n\n    if (sam_close(fpout) < 0) {\n        print_error_errno(cmd, \"error closing output file \\\"%s\\\"\", out);\n        return -1;\n    }\n    return 0;\n mem_fail:\n    print_error(cmd, \"Out of memory\");\n\n fail:\n    for (i = 0; i < n; i++) {\n        if (fp && fp[i]) sam_close(fp[i]);\n    }\n    for (i = 0; i < heap_size; i++) {\n        if (heap && heap[i].i < n && heap[i].entry.bam_record)\n            bam_destroy1(heap[i].entry.bam_record);\n    }\n    free(fp);\n    free(heap);\n    if (fpout) sam_close(fpout);\n    free(out_idx_fn);\n    return -1;\n}\n\n// Function to compare reads and determine which one is < or > the other\n// Handle sort-by-pos and sort-by-name. Used as the secondary sort in bam1_lt_by_tag, if reads are equivalent by tag.\n// Returns a value less than, equal to or greater than zero if a is less than,\n// equal to or greater than b, respectively.\nstatic inline int bam1_cmp_core(const bam1_tag a, const bam1_tag b)\n{\n    uint64_t pa, pb;\n    if (!a.bam_record) return 1;\n    if (!b.bam_record) return 0;\n\n    if (g_sam_order == QueryName || g_sam_order == TagQueryName) {\n        int t = strnum_cmp(bam_get_qname(a.bam_record), bam_get_qname(b.bam_record));\n        if (t != 0) return t;\n        int af = a.bam_record->core.flag;\n        int bf = b.bam_record->core.flag;\n        // Sort order is READ1, READ2, (PRIMARY), SUPPLEMENTARY, SECONDARY\n        // Get the bits in this order so sort is a natural a-b\n        af = ((af&0xc0)<<8)|((af&0x100)<<3)|((af&0x800)>>3);\n        bf = ((bf&0xc0)<<8)|((bf&0x100)<<3)|((bf&0x800)>>3);\n        return af - bf;\n    } else {\n        pa = a.bam_record->core.tid;\n        pb = b.bam_record->core.tid;\n\n        if (pa == pb) {\n            pa = (uint64_t)(a.bam_record->core.pos+1);\n            pb = (uint64_t)(b.bam_record->core.pos+1);\n        }\n\n        if (pa == pb) {\n            pa = bam_is_rev(a.bam_record);\n            pb = bam_is_rev(b.bam_record);\n        }\n\n        return pa < pb ? -1 : (pa > pb ? 1 : 0);\n    }\n}\n\nuint8_t normalize_type(const uint8_t* aux) {\n    if (*aux == 'c' || *aux == 'C' || *aux == 's' || *aux == 'S' || *aux == 'i' || *aux == 'I') {\n        return 'c';\n    } else if (*aux == 'f' || *aux == 'd') {\n        return 'f';\n    } else if (*aux == 'H' || *aux == 'Z') {\n         return 'H';\n    } else {\n        return *aux;\n    }\n}\n\n// Sort record by tag, using pos or read name as a secondary key if tags are identical. Reads not carrying the tag sort first.\n// Tags are first sorted by the type character (in case the types differ), or by the appropriate comparator for that type if they agree.\n// Returns a value less than, equal to or greater than zero if a is less than,\n// equal to or greater than b, respectively.\nstatic inline int bam1_cmp_by_tag(const bam1_tag a, const bam1_tag b)\n{\n    const uint8_t* aux_a = a.u.tag;\n    const uint8_t* aux_b = b.u.tag;\n\n    if (aux_a == NULL && aux_b != NULL) {\n        return -1;\n    } else if (aux_a != NULL && aux_b == NULL) {\n        return 1;\n    } else if (aux_a == NULL && aux_b == NULL) {\n        return bam1_cmp_core(a,b);\n    }\n\n    // 'Normalize' the letters of the datatypes to a canonical letter,\n    // so that comparison of different types\n    // forms a correct total ordering.\n    uint8_t a_type = normalize_type(aux_a);\n    uint8_t b_type = normalize_type(aux_b);\n\n    if (a_type != b_type) {\n        // Fix int to float comparisons by using bam_aux2f() to read the int\n        if (a_type == 'c' && b_type == 'f') {\n            a_type = 'f';\n        } else if (a_type == 'f' && b_type == 'c') {\n            b_type = 'f';\n        } else {\n            // Unfixable mismatched types\n            return a_type < b_type ? -1 : 1;\n        }\n    }\n\n    if (a_type == 'c') {\n        int64_t va = bam_aux2i(aux_a);\n        int64_t vb = bam_aux2i(aux_b);\n        if (va != vb) return va < vb ? -1 : 1;\n        return bam1_cmp_core(a, b);\n    } else if (a_type == 'f') {\n        double va = bam_aux2f(aux_a);\n        double vb = bam_aux2f(aux_b);\n        if (va != vb) return va < vb ? -1 : 1;\n        return bam1_cmp_core(a, b);\n    } else if (a_type == 'A') {\n        unsigned char va = bam_aux2A(aux_a);\n        unsigned char vb = bam_aux2A(aux_b);\n        if (va != vb) return va < vb ? -1 : 1;\n        return bam1_cmp_core(a, b);\n    } else if (a_type == 'H') {\n        int t = strcmp(bam_aux2Z(aux_a), bam_aux2Z(aux_b));\n        if (t) return t;\n        return bam1_cmp_core(a, b);\n    } else {\n        return bam1_cmp_core(a,b);\n    }\n}\n\n// Sort by minimiser (stored in bam1_tag.u.pos).\n// If equal, sort by position.\n//\n// The 64-bit sort key is split over the bam pos and isize fields.\n// This permits it to survive writing to temporary file and coming back.\n\n#ifdef DEBUG_MINHASH\nstatic int ntot = 0, nmis = 0, ndup = 0;\n#endif\n\nstatic inline int bam1_cmp_by_minhash(const bam1_tag a, const bam1_tag b)\n{\n    const bam1_t *A = a.bam_record;\n    const bam1_t *B = b.bam_record;\n\n    if (!A) return 1;\n    if (!B) return 0;\n\n    if (A->core.tid != -1 || B->core.tid != -1) return bam1_cmp_core(a,b);\n\n    const uint64_t m_a = (((uint64_t)A->core.pos)<<31)|(uint32_t)A->core.mpos;\n    const uint64_t m_b = (((uint64_t)B->core.pos)<<31)|(uint32_t)B->core.mpos;\n\n    if (m_a < m_b) // by hash\n        return -1;\n    else if (m_a > m_b)\n        return 1;\n\n    // Bigger pos with size minhash means starts further to left\n    else if (A->core.isize > B->core.isize) // by hash location in seq\n        return -1;\n    else if (A->core.isize < B->core.isize)\n        return 1;\n    else\n        return bam1_cmp_core(a,b);\n}\n\n// compares to molecular identifiers, ignoring any trailing slash and subsequent single-character\n// * if mid1 is less than mid2, then -1 will be returned\n// * if mid1 is greater than mid2, then 1 will be returned\nstatic inline int template_coordinate_key_compare_mid(const char* mid1, const char* mid2) {\n    size_t i = 0;\n    size_t len1 = strlen(mid1);\n    size_t len2 = strlen(mid2);\n    size_t shortest;\n\n    // Snip off trailing slash followed by a single character, if present\n    if (len1 >= 2 && mid1[len1-2] == '/') len1 -= 2;\n    if (len2 >= 2 && mid2[len2-2] == '/') len2 -= 2;\n    shortest = len1 < len2 ? len1 : len2;\n\n    // find first mismatching character\n    while (i < shortest && mid1[i] == mid2[i]) i++;\n\n    // compare last characters\n    if (i == len1 && i < len2) return -1; // mid1 shorter\n    if (i == len2 && i < len1) return  1; // mid2 shorter\n    if (i == len1 && i == len2) return 0; // all characters match\n    if (mid1[i] < mid2[i]) return -1; // mid1 earlier\n    else return 1;\n}\n\n\n// Builds a key use to sort in TemplateCoordinate order.  Returns NULL if the key could not be created (e.g. MC\n// tag is missing), otherwise the pointer to the provided key.\nstatic template_coordinate_key_t* template_coordinate_key(bam1_t *b, template_coordinate_key_t *key, sam_hdr_t *hdr, khash_t(const_c2c) *lib_lookup) {\n    uint8_t *data;\n    char *rg;\n    khiter_t k;\n\n    // defaults\n    key->tid1 = key->tid2 = INT32_MAX;\n    key->pos1 = key->pos2 = HTS_POS_MAX;\n    key->neg1 = key->neg2 = false;\n    key->mid  = \"\";\n\n    // update values\n    rg = (char *)bam_aux_get(b, \"RG\");\n    if (rg && rg[0] == 'Z'\n        &&(k = kh_get(const_c2c, lib_lookup, rg + 1)) < kh_end(lib_lookup)) {\n        key->library = kh_value(lib_lookup, k);\n    } else {\n        key->library = \"\";\n    }\n    key->name = bam_get_qname(b);\n    if (!(b->core.flag & BAM_FUNMAP)) { // read is mapped, update coordinates\n        key->tid1 = b->core.tid;\n        key->neg1 = bam_is_rev(b);\n        key->pos1 = (key->neg1) ? unclipped_end(b) : unclipped_start(b);\n    }\n    if (b->core.flag & BAM_FPAIRED && !(b->core.flag & BAM_FMUNMAP)) { // mate is mapped, update coordinates\n        char *cigar;\n        if ((data = bam_aux_get(b, \"MC\"))) {\n            if (!(cigar = bam_aux2Z(data))) {\n                fprintf(stderr, \"[bam_sort] error: MC tag wrong type. Please use the MC tag provided by samtools fixmate.\\n\");\n                return NULL;\n            }\n        } else {\n            fprintf(stderr, \"[bam_sort] error: no MC tag. Please run samtools fixmate on file first.\\n\");\n            return NULL;\n        }\n        key->tid2 = b->core.mtid;\n        key->neg2 = bam_is_mrev(b);\n        key->pos2 = (key->neg2) ? unclipped_other_end(b->core.mpos, cigar) : unclipped_other_start(b->core.mpos, cigar);\n    }\n\n    if ((data = bam_aux_get(b, \"MI\"))) {\n        if (!(key->mid=bam_aux2Z(data))) {\n            fprintf(stderr, \"[bam_sort] error: MI tag wrong type (not a string).\\n\");\n            return NULL;\n        }\n    }\n\n    // set is_upper_of_pair, and swap if we get the same key regardless of which end\n    // of the pair it is\n    if (key->tid1 < key->tid2\n            || (key->tid1 == key->tid2 && key->pos1 < key->pos2)\n            || (key->tid1 == key->tid2 && key->pos1 == key->pos2 && !key->neg1)) {\n        key->is_upper_of_pair = false;\n    } else {\n        key->is_upper_of_pair = true;\n        // swap\n        int tmp_tid;\n        hts_pos_t tmp_pos;\n        bool tmp_neg;\n        tmp_tid = key->tid1;\n        key->tid1 = key->tid2;\n        key->tid2 = tmp_tid;\n        tmp_pos = key->pos1;\n        key->pos1 = key->pos2;\n        key->pos2 = tmp_pos;\n        tmp_neg = key->neg1;\n        key->neg1 = key->neg2;\n        key->neg2 = tmp_neg;\n    }\n\n    return key;\n}\n\n// Function to compare reads and determine which one is < or > the other\n// Handles template-coordinate, which sorts by:\n// 1. the earlier unclipped 5' coordinate of the read pair\n// 2. the higher unclipped 5' coordinate of the read pair\n// 3. library (from read group)\n// 4. the molecular identifier (if present)\n// 5. read name\n// 6. if unpaired, or if R1 has the lower coordinates of the pair\n// Returns a value less than, equal to or greater than zero if a is less than,\n// equal to or greater than b, respectively.\nstatic inline int bam1_cmp_template_coordinate(const bam1_tag a, const bam1_tag b)\n{\n    if (!a.bam_record) return 1;\n    if (!b.bam_record) return 0;\n\n    const template_coordinate_key_t* key_a = a.u.key;\n    const template_coordinate_key_t* key_b = b.u.key;\n\n    int retval = 0;\n    if (0 == retval) retval = key_a->tid1 - key_b->tid1;\n    if (0 == retval) retval = key_a->tid2 - key_b->tid2;\n    if (0 == retval) retval = key_a->pos1 < key_b->pos1 ? -1 : (key_a->pos1 > key_b->pos1 ? 1 : 0);\n    if (0 == retval) retval = key_a->pos2 < key_b->pos2 ? -1 : (key_a->pos2 > key_b->pos2 ? 1 : 0);\n    if (0 == retval) retval = key_a->neg1 == key_b->neg1 ? 0 : (key_a->neg1 ? -1 : 1);\n    if (0 == retval) retval = key_a->neg2 == key_b->neg2 ? 0 : (key_a->neg2 ? -1 : 1);\n    if (0 == retval) retval = strcmp(key_a->library, key_b->library);\n    if (0 == retval) retval = template_coordinate_key_compare_mid(key_a->mid, key_b->mid);\n    if (0 == retval) retval = strcmp(key_a->name, key_b->name);\n    if (0 == retval) retval = key_a->is_upper_of_pair == key_b->is_upper_of_pair ? 0 : (key_a->is_upper_of_pair ? 1 : -1);\n    return retval < 0 ? -1 : (retval > 0 ? 1 : 0);\n}\n\n\n// Function to compare reads and determine which one is < the other\n// Handle sort-by-pos, sort-by-name, sort-by-tag, or sort-by-template-coordinate.\nstatic inline int bam1_lt(const bam1_tag a, const bam1_tag b)\n{\n    switch (g_sam_order) {\n        case Coordinate:\n        case QueryName:\n            return bam1_cmp_core(a, b) < 0;\n        case TagQueryName:\n        case TagCoordinate:\n            return bam1_cmp_by_tag(a, b) < 0;\n        case MinHash:\n            return bam1_cmp_by_minhash(a, b) < 0;\n        case TemplateCoordinate:\n            return bam1_cmp_template_coordinate(a, b) < 0;\n        default:\n            return bam1_cmp_core(a,b) < 0;\n    }\n}\n\n\n\nKSORT_INIT(sort, bam1_tag, bam1_lt)\n\ntypedef struct {\n    size_t buf_len;\n    bam1_tag *buf;\n    const sam_hdr_t *h;\n    int error;\n    int large_pos;\n    int minimiser_kmer;\n    bool try_rev;\n    bool no_squash;\n} worker_t;\n\n// Returns 0 for success\n//        -1 for failure\nstatic int write_buffer(const char *fn, const char *mode, size_t l, bam1_tag *buf,\n                        const sam_hdr_t *h, int n_threads, const htsFormat *fmt,\n                        int clear_minhash, char *arg_list, int no_pg, int write_index)\n{\n    size_t i;\n    samFile* fp;\n    char *out_idx_fn = NULL;\n\n    fp = sam_open_format(fn, mode, fmt);\n    if (fp == NULL) return -1;\n    hts_set_opt(fp, HTS_OPT_BLOCK_SIZE, BAM_BLOCK_SIZE);\n    if (!no_pg && sam_hdr_add_pg((sam_hdr_t *)h, \"samtools\", \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL)) {\n        goto fail;\n    }\n    if (sam_hdr_write(fp, h) != 0) goto fail;\n\n    if (write_index)\n        if (!(out_idx_fn = auto_index(fp, fn, (sam_hdr_t *)h))) goto fail;\n\n    if (n_threads > 1) hts_set_threads(fp, n_threads);\n    for (i = 0; i < l; ++i) {\n        bam1_t *b = buf[i].bam_record;\n        if (clear_minhash && b->core.tid == -1) {\n            // To see the position for debugging\n            // b->core.pos = ((((uint64_t)b->core.pos)<<31)|(uint32_t)b->core.mpos) + b->core.isize;\n            // Remove the cached minhash value\n            b->core.pos = -1;\n            b->core.mpos = -1;\n            b->core.isize = 0;\n        }\n        if (sam_write1(fp, h, b) < 0) goto fail;\n    }\n\n    if (write_index) {\n        if (sam_idx_save(fp) < 0) {\n            print_error_errno(\"merge\", \"writing index failed\");\n            goto fail;\n        }\n        free(out_idx_fn);\n    }\n\n\n    if (sam_close(fp) < 0) return -1;\n    return 0;\n fail:\n    sam_close(fp);\n    free(out_idx_fn);\n    return -1;\n}\n\n#define NUMBASE 256\n\nstatic int ks_radixsort(size_t n, bam1_tag *buf, const sam_hdr_t *h)\n{\n    int curr = 0, ret = -1;\n    ssize_t i;\n    bam1_tag *buf_ar2[2], *bam_a, *bam_b;\n    uint64_t max_pos = 1;\n    uint32_t max_tid = 1, tid_bytes = 0, pos_bytes = 0, byte = 0;\n    uint32_t tid_shift_l, tid_shift_r;\n    int nref = sam_hdr_nref(h);\n\n    // Count number of bytes needed for biggest tid and pos\n    //  Notes: Add 1 to core.pos so always positive.\n    //         Convert unmapped tid (-1) to number of references so unmapped\n    //         sort to the end.\n    for (i = 0; i < n; i++) {\n        bam1_t *b = buf[i].bam_record;\n        uint32_t tid = b->core.tid == -1 ? nref : b->core.tid;\n        uint64_t pos = ((uint64_t)(b->core.pos + 1) << 1) | bam_is_rev(b);\n        if (max_tid < tid)\n            max_tid = tid;\n        if (max_pos < pos)\n            max_pos = pos;\n    }\n\n    for (; max_pos > 0; max_pos >>= 8) pos_bytes++;\n    for (; max_tid > 0; max_tid >>= 8) tid_bytes++;\n    assert(pos_bytes + tid_bytes < sizeof(buf[0].u.pos_tid));\n\n    tid_shift_l = pos_bytes * 8;\n    tid_shift_r = 64 - tid_shift_l;\n\n    // Write position and tid into bam1_tag::u::pos_tid using minimum number\n    // of bytes required.  Values are stored little-endian so that we\n    // get a least-significant digit (byte) radix sort.\n    for (i = 0; i < n; i++) {\n        bam1_t *b = buf[i].bam_record;\n        uint32_t tid = b->core.tid == -1 ? nref : b->core.tid;\n        // 'pos' here includes as many bytes of tid as will fit\n        // in the space remaining above pos_bytes.  The rest of tid\n        // is written out separately.\n        uint64_t pos = (bam_is_rev(b) |\n                        ((uint64_t)(b->core.pos + 1) << 1) |\n                        (tid_shift_l < 64 ? (uint64_t) tid << tid_shift_l : 0));\n        u64_to_le(pos, buf[i].u.pos_tid);\n        u32_to_le(tid_shift_r < 32 ? tid >> tid_shift_r : 0,\n                  &buf[i].u.pos_tid[8]);\n    }\n\n    buf_ar2[0] = buf;\n    buf_ar2[1] = (bam1_tag *)malloc(sizeof(bam1_tag) * n);\n    if (buf_ar2[1] == NULL) {\n        print_error(\"sort\", \"couldn't allocate memory for temporary buf\");\n        goto err;\n    }\n\n    // Least-significant digit radix sort (where \"digits\" are bytes)\n    for (byte = 0; byte < pos_bytes + tid_bytes; byte++) {\n        size_t remainders[NUMBASE] = { 0 };\n        bam_a = buf_ar2[curr]; bam_b = buf_ar2[1-curr];\n        for (i = 0; i < n; ++i)\n            remainders[bam_a[i].u.pos_tid[byte]]++;\n        for (i = 1; i < NUMBASE; ++i)\n            remainders[i] += remainders[i - 1];\n        for (i = n - 1; i >= 0; i--) {\n            size_t j = --remainders[bam_a[i].u.pos_tid[byte]];\n            bam_b[j] = bam_a[i];\n        }\n        curr = 1 - curr;\n    }\n    if (curr == 1) {\n        bam1_tag *end = buf + n;\n        bam_a = buf_ar2[0]; bam_b = buf_ar2[1];\n        while (bam_a < end) *bam_a++ = *bam_b++;\n    }\n\n    ret = 0;\nerr:\n    free(buf_ar2[1]);\n    return ret;\n}\n\nKHASH_MAP_INIT_INT64(kmer, int64_t)\nstatic khash_t(kmer) *kmer_h = NULL;\n\n// Punt homopolymers somewhere central in the hash space\n#define XOR 0xdead7878beef7878\n\n/*\n * Computes the minhash of a sequence using forward strand and if requested\n * reverse strand.\n *\n * This is used as a sort key for unmapped data, to collate like sequences\n * together and to improve compression ratio.\n *\n * The minhash is returned and *pos filled out with location of this hash\n * key in the sequence if pos != NULL.\n */\nstatic uint64_t minhash(bam1_t *b, int kmer, int window, int *curr_pos,\n                        int *end, int *is_rev, int try_fwd, int try_rev,\n                        int no_squash) {\n    uint64_t hashf = 0, minhashf = UINT64_MAX;\n    int minhashpf = *curr_pos, i, j;\n    uint64_t mask = (1L<<(2*kmer))-1;\n    uint8_t *seq = bam_get_seq(b);\n    int len = b->core.l_qseq;\n    uint64_t xor = XOR & mask;\n\n    if (is_rev) *is_rev = 0;\n\n    // Lookup tables for bam_seqi to 0123 fwd/rev hashes\n    // =ACM GRSV TWYH KDBN\n#define X 0\n    static unsigned char L[16] = {\n        X,0,1,X,  2,X,X,X,  3,X,X,X,  X,X,X,X,\n    };\n    uint64_t R[16] = {\n        X,3,2,X,  1,X,X,X,  0,X,X,X,  X,X,X,X,\n    };\n    for (i = 0; i < 16; i++)\n        R[i] <<= 2*(kmer-1);\n\n    int i_start = *curr_pos;\n    int i_end = MIN(i_start + window, len);\n    int last_base = -1;\n\n    if (try_fwd) {\n        // Initialise hash keys\n        for (i = i_start, j = 0; j < kmer-1 && i < i_end; i++) {\n            int base = bam_seqi(seq, i);\n            // collapse homopolymers\n            if (no_squash || last_base != base) {\n                last_base = base;\n                hashf = (hashf<<2) | L[base];\n                j++;\n            }\n        }\n\n        // Loop to find minimum\n        if (no_squash) {\n            for (; i < i_end; i++) {\n                int base = bam_seqi(seq, i);\n                hashf = (hashf<<2) | L[base];\n                uint64_t hashfx = (hashf ^ XOR) & mask;\n                if (minhashf > hashfx)\n                    minhashf = hashfx, minhashpf = i;\n            }\n        } else {\n            for (; i < i_end; i++) {\n                int base = bam_seqi(seq, i);\n                if (last_base != base) {\n                    last_base = base;\n                    hashf = (hashf<<2) | L[base];\n                    uint64_t hashfx = (hashf ^ XOR) & mask;\n                    if (minhashf > hashfx)\n                        minhashf = hashfx, minhashpf = i;\n                }\n            }\n        }\n    }\n\n    // Same as above for the reverse strand.\n    // Not used for now, but we may wish to consider indexing in both\n    // strands, recording the strand in value (pos), and comparing in one\n    // strand only.  Right now we compare on both against a single-stranded\n    // index.\n    if (try_rev) {\n        uint64_t hashr = 0, minhashr = UINT64_MAX;\n        int minhashpr = *curr_pos;\n        int last_base = -1;\n\n        for (i = i_start, j = 0; j < kmer-1 && i < len; i++) {\n            int base = bam_seqi(seq, i);\n            if (no_squash || last_base != base) {\n                last_base = base;\n                hashr = (hashr>>2) | R[base];\n                j++;\n            }\n        }\n\n        if (no_squash) {\n            for (; i < i_end; i++) {\n                int base = bam_seqi(seq, i);\n                hashr =  (hashr>>2) | R[base];\n                if (minhashr > (hashr^xor))\n                    minhashr = (hashr^xor), minhashpr = len-i+kmer-2;\n            }\n        } else {\n            for (; i < i_end; i++) {\n                int base = bam_seqi(seq, i);\n                if (last_base != base) {\n                    last_base = base;\n                    hashr =  (hashr>>2) | R[base];\n                    if (minhashr > (hashr^xor))\n                        minhashr = (hashr^xor), minhashpr = len-i+kmer-2;\n                }\n            }\n        }\n\n        if (minhashr < minhashf) {\n            minhashf  = minhashr;\n            minhashpf = minhashpr;\n            if (is_rev) *is_rev = 1;\n        }\n    }\n\n    // \"*curr_pos = minhashpf\" is faster here, but is sometimes\n    // poorer in compression.  Eg 10 million novaseq records with\n    // 75.1MB vs 76.9MB cram BA field.\n    //*curr_pos = minhashpf;\n    *curr_pos = minhashpf - (kmer-1);\n    if (end) *end = (i_end == len);\n    return minhashf;\n}\n\n#define UNIQ_BIT  60\n#define UNIQ_TEST(x) (((x) & (1ULL<<UNIQ_BIT))==0)\n#define UNIQ_MASK ((1ULL<<UNIQ_BIT)-1)\nstatic int build_minhash_index(char *fn, int kmer, int window, int no_squash) {\n    int ret = 1;\n    samFile *in;\n    sam_hdr_t *h = NULL;\n    bam1_t *b = NULL;\n\n    in = sam_open(fn, \"r\");\n    if (!in) {\n        perror(fn);\n        return 1;\n    }\n\n    kmer_h = kh_init(kmer);\n    if (!kmer_h)\n        goto err;\n\n    if (!(h = sam_hdr_read(in)))\n        goto err;\n\n    if (!(b = bam_init1()))\n        goto err;\n\n    int r;\n    uint64_t tpos = 0;\n    while ((r = sam_read1(in, h, b)) >= 0) {\n        //fprintf(stderr, \"LEN\\t%d\\t%s\\n\", b->core.l_qseq, bam_get_qname(b));\n        uint64_t hashf;\n        int pos = 0, end = 0;\n        khiter_t k;\n        int ret;\n\n        if (b->core.l_qseq < window)\n            continue;\n\n        // fwd\n        while (!end) {\n            int last_pos = pos;\n            hashf = minhash(b, kmer, window, &pos, &end, NULL, 1, 0,\n                            no_squash);\n            k = kh_put(kmer, kmer_h, hashf, &ret);\n            kh_value(kmer_h, k) = tpos+pos + (((uint64_t)!ret)<<UNIQ_BIT);\n            pos = MAX(last_pos+kmer, pos+1);\n            //pos++;  Slower, but indexes a bit better?\n        }\n        tpos += b->core.l_qseq;\n\n// We could also add reverse keys to the index here.\n// This would avoid reverse complementing during the matching stage.\n// We'd need to add a flag (another high bit of kh_value) to indicate\n// strand.\n// I'm unsure if this is a good trade-off or not.\n\n//        // rev\n//        pos = 0; end = 0;\n//        while (!end) {\n//            hashf = minhash(b, kmer, window, &pos, &end, NULL, 0, 1,\n//                            no_squash);\n//            k = kh_put(kmer, kmer_h, hashf, &ret);\n//            kh_value(kmer_h, k) = tpos+pos + (((uint64_t)!ret)<<UNIQ_BIT);\n//            pos++;\n//        }\n//\n//        tpos += b->core.l_qseq;\n    }\n    if (r < -1)\n        goto err;\n\n    ret = 0;\n err:\n    if (b) bam_destroy1(b);\n    if (h) sam_hdr_destroy(h);\n    sam_close(in);\n\n    return ret;\n}\n\n/*\n * A variant of minhash that compares against a previously built index.\n *\n * We follow the same steps of scanning through this sequence to find the\n * minimum hash, but we prefer hash keys that have unique placement in the\n * index, or if not unique, then non-uniquely placed, over ones that\n * are absent from the index.\n */\nstatic uint64_t minhash_with_idx(bam1_t *b, int kmer, int *pos, int *rev,\n                                 bool try_rev) {\n    uint64_t hashf = 0, minhashf = UINT64_MAX, minhashfi = UINT64_MAX;\n    uint64_t minhashfd = UINT64_MAX;\n    int minhashpf = 0, minhashpfi = 0, minhashpfd = 0, i, j;\n    uint64_t mask = (1L<<(2*kmer))-1;\n    unsigned char *seq = bam_get_seq(b);\n    int len = b->core.l_qseq;\n    const uint64_t xor = XOR & mask;\n\n    // Lookup tables for bam_seqi to 0123 fwd/rev hashes\n    // =ACM GRSV TWYH KDBN\n#define X 0\n    unsigned char L[16] = {\n        X,0,1,X,  2,X,X,X,  3,X,X,X,  X,X,X,X,\n    };\n    uint64_t R[16] = {\n        X,3,2,X,  1,X,X,X,  0,X,X,X,  X,X,X,X,\n    };\n    for (i = 0; i < 16; i++)\n        R[i] <<= 2*(kmer-1);\n\n    // Initialise hash keys\n    for (i = j = 0; j < kmer-1 && i < len; i++, j++) {\n        int base = bam_seqi(seq, i);\n        hashf = (hashf<<2) | L[base];\n    }\n\n    // Loop to find minimum\n    int found_f = 0, found_r = 0;\n    for (; i < len; i++) {\n        int base = bam_seqi(seq, i);\n        hashf = ((hashf<<2) | L[base]) & mask;\n        const uint64_t hashfx = hashf^xor;\n\n        // Priority for sorting\n        // 1. Unique key in index\n        // 2. Dup key in index\n        // 3. Everything else\n        int index = 0;\n        if (minhashfi > hashfx || (found_f < 2 && minhashfd > hashfx)) {\n            khiter_t k = kh_get(kmer, kmer_h, hashfx);\n            if (k != kh_end(kmer_h))\n                index = UNIQ_TEST(kh_value(kmer_h, k)) ? 2 : 1;\n        }\n        found_f |= index;\n        switch (index) {\n        case 2: minhashfi = hashfx, minhashpfi = i; break;\n        case 1: minhashfd = hashfx, minhashpfd = i; break;\n\n        default:\n            if (minhashf > hashfx)\n                minhashf = hashfx, minhashpf = i;\n        }\n    }\n\n    if (minhashfi != UINT64_MAX)\n        minhashf = minhashfi, minhashpf = minhashpfi;\n    else if (minhashfd != UINT64_MAX)\n        minhashf = minhashfd, minhashpf = minhashpfd;\n\n    // Same as above for the reverse strand\n    int dir = 0;\n    if (try_rev) {\n        uint64_t hashr = 0, minhashr = UINT64_MAX, minhashri = UINT64_MAX;\n        uint64_t minhashrd = UINT64_MAX;\n        int minhashpr = 0, minhashpri = 0, minhashprd = 0;\n\n        for (i = j = 0; j < kmer-1 && i < len; i++, j++) {\n            int base = bam_seqi(seq, i);\n            hashr = (hashr>>2) | R[base];\n        }\n        for (; i < len; i++) {\n            int base = bam_seqi(seq, i);\n            hashr =  (hashr>>2) | R[base];\n            const uint64_t hashrx = hashr^xor;\n\n            int index = 0;\n            if (minhashri > hashrx || (found_r < 2 && minhashrd > hashrx)) {\n                khiter_t k = kh_get(kmer, kmer_h, hashrx);\n                if (k != kh_end(kmer_h))\n                    index = UNIQ_TEST(kh_value(kmer_h, k)) ? 2 : 1;\n            }\n            found_r |= index;\n            switch (index) {\n            case 2: minhashri = hashrx, minhashpri = i; break;\n            case 1: minhashrd = hashrx, minhashprd = i; break;\n\n            default:\n                if (minhashr > hashrx)\n                    minhashr = hashrx, minhashpr = i;\n            }\n        }\n        if (minhashri != UINT64_MAX)\n            minhashr = minhashri, minhashpr = minhashpri;\n        else if (minhashrd != UINT64_MAX)\n            minhashr = minhashrd, minhashpr = minhashprd;\n\n        // Pick reverse if better mapping\n        if ((minhashf > minhashr) || (!found_f && found_r)) {\n            if (!found_f || found_r) {\n                minhashf  = minhashr;\n                minhashpf = b->core.l_qseq - minhashpr + kmer - 2;\n                dir = 1;\n            }\n        }\n    }\n\n#ifdef DEBUG_MINHASH\n    ntot++;\n    khiter_t k = kh_get(kmer, kmer_h, minhashf);\n    if (k != kh_end(kmer_h)) {\n        if (!UNIQ_TEST(kh_value(kmer_h, k)))\n            ndup++;\n        minhashf = kh_value(kmer_h, k) & UNIQ_MASK;\n    } else {\n        nmis++;\n    }\n#else\n    // For indexed kmers, our hash key is the position the kmer\n    // occurs in the concatenated reference rather than the hash itself.\n    khiter_t k = kh_get(kmer, kmer_h, minhashf);\n    if (k != kh_end(kmer_h))\n        minhashf = kh_value(kmer_h, k) & UNIQ_MASK;\n#endif\n\n    if (rev) *rev = dir;\n    if (pos) *pos = minhashpf;\n\n    return minhashf != UINT64_MAX ? minhashf : 0;\n}\n\n// As per minhash_with_idx but with homopolymer squashing enabled.\n// This function is duplicated to remove conditionals and speed up the\n// hashing code. (Minus the ifdef-ed out code, which is kept above mainly\n// for posterity.)\nstatic uint64_t minhash_with_idx_squash(bam1_t *b, int kmer, int *pos,\n                                        int *rev, bool try_rev) {\n    uint64_t hashf = 0, minhashf = UINT64_MAX, minhashfi = UINT64_MAX;\n    uint64_t minhashfd = UINT64_MAX;\n    int minhashpf = 0, minhashpfi = 0, minhashpfd = 0, i, j;\n    uint64_t mask = (1L<<(2*kmer))-1;\n    unsigned char *seq = bam_get_seq(b);\n    int len = b->core.l_qseq;\n    const uint64_t xor = XOR & mask;\n\n    // Lookup tables for bam_seqi to 0123 fwd/rev hashes\n    // =ACM GRSV TWYH KDBN\n#define X 0\n    unsigned char L[16] = {\n        X,0,1,X,  2,X,X,X,  3,X,X,X,  X,X,X,X,\n    };\n    uint64_t R[16] = {\n        X,3,2,X,  1,X,X,X,  0,X,X,X,  X,X,X,X,\n    };\n    for (i = 0; i < 16; i++)\n        R[i] <<= 2*(kmer-1);\n\n    // Initialise hash keys\n    int last_base = -1;\n    for (i = j = 0; j < kmer-1 && i < len; i++) {\n        int base = bam_seqi(seq, i);\n        if (base == last_base)\n            continue;\n        last_base = base;\n        j++;\n        hashf = (hashf<<2) | L[base];\n    }\n\n    // Loop to find minimum\n    int found_f = 0, found_r = 0;\n    for (; i < len; i++) {\n        int base = bam_seqi(seq, i);\n        if (base == last_base)\n            continue;\n        last_base = base;\n        hashf = ((hashf<<2) | L[base]) & mask;\n        const uint64_t hashfx = hashf^xor;\n\n        // Priority for sorting\n        // 1. Unique key in index\n        // 2. Dup key in index\n        // 3. Everything else\n        int index = 0;\n        if (minhashfi > hashfx || (found_f < 2 && minhashfd > hashfx)) {\n            khiter_t k = kh_get(kmer, kmer_h, hashfx);\n            if (k != kh_end(kmer_h))\n                index = UNIQ_TEST(kh_value(kmer_h, k)) ? 2 : 1;\n        }\n        found_f |= index;\n        switch (index) {\n        case 2: minhashfi = hashfx, minhashpfi = i; break;\n        case 1: minhashfd = hashfx, minhashpfd = i; break;\n\n        default:\n            if (minhashf > hashfx)\n                minhashf = hashfx, minhashpf = i;\n        }\n    }\n\n    if (minhashfi != UINT64_MAX)\n        minhashf = minhashfi, minhashpf = minhashpfi;\n    else if (minhashfd != UINT64_MAX)\n        minhashf = minhashfd, minhashpf = minhashpfd;\n\n    // Same as above for the reverse strand\n    int dir = 0;\n    if (try_rev) {\n        uint64_t hashr = 0, minhashr = UINT64_MAX, minhashri = UINT64_MAX;\n        uint64_t minhashrd = UINT64_MAX;\n        int minhashpr = 0, minhashpri = 0, minhashprd = 0;\n        int last_base = -1;\n\n        for (i = j = 0; j < kmer-1 && i < len; i++) {\n            int base = bam_seqi(seq, i);\n            if (base == last_base)\n                continue;\n            last_base = base;\n            j++;\n            hashr = (hashr>>2) | R[base];\n        }\n        for (; i < len; i++) {\n            int base = bam_seqi(seq, i);\n            if (base == last_base)\n                continue;\n            last_base = base;\n            hashr =  (hashr>>2) | R[base];\n            const uint64_t hashrx = hashr^xor;\n\n            int index = 0;\n            if (minhashri > hashrx || (found_r < 2 && minhashrd > hashrx)) {\n                khiter_t k = kh_get(kmer, kmer_h, hashrx);\n                if (k != kh_end(kmer_h))\n                    index = UNIQ_TEST(kh_value(kmer_h, k)) ? 2 : 1;\n            }\n            found_r |= index;\n            switch (index) {\n            case 2: minhashri = hashrx, minhashpri = i; break;\n            case 1: minhashrd = hashrx, minhashprd = i; break;\n\n            default:\n                if (minhashr > hashrx)\n                    minhashr = hashrx, minhashpr = i;\n            }\n        }\n        if (minhashri != UINT64_MAX)\n            minhashr = minhashri, minhashpr = minhashpri;\n        else if (minhashrd != UINT64_MAX)\n            minhashr = minhashrd, minhashpr = minhashprd;\n\n        // Pick reverse if better mapping\n        if ((minhashf > minhashr) || (!found_f && found_r)) {\n            if (!found_f || found_r) {\n                minhashf  = minhashr;\n                minhashpf = b->core.l_qseq - minhashpr + kmer - 2;\n                dir = 1;\n            }\n        }\n    }\n\n#ifdef DEBUG_MINHASH\n    ntot++;\n    khiter_t k = kh_get(kmer, kmer_h, minhashf);\n    if (k != kh_end(kmer_h)) {\n        if (!UNIQ_TEST(kh_value(kmer_h, k)))\n            ndup++;\n        minhashf = kh_value(kmer_h, k) & UNIQ_MASK;\n    } else {\n        nmis++;\n    }\n#else\n    // For indexed kmers, our hash key is the position the kmer\n    // occurs in the concatenated reference rather than the hash itself.\n    khiter_t k = kh_get(kmer, kmer_h, minhashf);\n    if (k != kh_end(kmer_h))\n        minhashf = kh_value(kmer_h, k) & UNIQ_MASK;\n#endif\n\n    if (rev) *rev = dir;\n    if (pos) *pos = minhashpf;\n\n    return minhashf != UINT64_MAX ? minhashf : 0;\n}\n\n//--- Start of candidates to punt to htslib\n/*!\n * @abstract\n * Extracts the sequence (in current alignment orientation) from\n * a bam record and places it in buf, which is nul terminated.\n *\n * @param b     The bam structure\n * @param buf   A buffer at least b->core.l_qseq+1 bytes long\n */\nstatic void bam_to_seq(bam1_t *b, char *buf) {\n    int i;\n    uint8_t *seq = bam_get_seq(b);\n    for (i = 0; i < b->core.l_qseq; i++)\n        buf[i] = seq_nt16_str[bam_seqi(seq, i)];\n    buf[i] = 0;\n}\n\n/*!\n * @abstract\n * Writes a new sequence, of length b->core.l_qseq, to a BAM record.\n *\n * If a sequence of a new length is required the caller must first make\n * room for it by updating the bam1_t struct.\n *\n * @param b     The bam structure\n * @param buf   A buffer at least b->core.l_qseq bytes long\n */\nstatic void seq_to_bam(bam1_t *b, char *buf) {\n    int i;\n    uint8_t *seq = bam_get_seq(b);\n    for (i = 0; i < b->core.l_qseq; i++)\n        bam_set_seqi(seq, i, seq_nt16_table[(unsigned char)buf[i]]);\n}\n\n/*!\n * @abstract Reverse complements a BAM record.\n *\n * It's possible to do this inline, but complex due to the 4-bit sequence\n * encoding.  For now I take the dumb approach.\n *\n * @param b  Pointer to a BAM alignment\n *\n * @return   0 on success, -1 on failure (ENOMEM)\n */\nstatic int reverse_complement(bam1_t *b) {\n    static char comp[256] = {\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//00\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//10\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//20\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//30\n\n       //    *   *   *    *   E   F   *    *   I   J   *    L   *   *   O\n        '@','T','V','G', 'H','E','F','C', 'D','I','H','M', 'L','K','N','O',//40\n       //P   Q   *   *    *   *   *   *    X   Y   Z   [    \\   ]   ^   _\n        'P','Q','Y','S', 'A','A','B','W', 'X','Y','Z','[','\\\\','[','^','_',//50\n       //`   *   *   *    *   E   F   *    *   I   J   *    L   *   *   O\n        '`','t','v','g', 'h','e','f','c', 'd','i','j','m', 'l','k','n','o',//60\n       //P   Q   *   *    *   *   *   *    X   Y   Z   {    |   }   ~   DEL\n        'p','q','y','s', 'a','a','b','w', 'x','y','z','{', '|','}','~',127,//70\n\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//80\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//90\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//A0\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//B0\n\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//C0\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//D0\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//E0\n        'N','N','N','N', 'N','N','N','N', 'N','N','N','N', 'N','N','N','N',//F0\n    };\n    char seq_[10000], *seq = seq_;\n    uint8_t *qual = bam_get_qual(b);\n    int i, j;\n\n    if (b->core.l_qseq >= 10000)\n        if (!(seq = malloc(b->core.l_qseq+1)))\n            return -1;\n\n    bam_to_seq(b, seq);\n\n    for (i = 0, j = b->core.l_qseq-1; i < j; i++, j--) {\n        unsigned char tmp = seq[i];\n        seq[i] = comp[(unsigned char)seq[j]];\n        seq[j] = comp[tmp];\n        tmp = qual[i];\n        qual[i] = qual[j];\n        qual[j] = tmp;\n    }\n    if (i ==j)\n        seq[i] = comp[(unsigned char)seq[i]];\n\n    seq_to_bam(b, seq);\n\n    if (seq != seq_)\n        free(seq);\n\n    b->core.flag ^= 0x10;\n\n    return 0;\n}\n//--- End of candidates to punt to htslib\n\n\nstatic inline void worker_minhash(worker_t *w) {\n    int i;\n    for (i = 0; i < w->buf_len; i++) {\n        bam1_t *b = w->buf[i].bam_record;\n        if (b->core.tid != -1)\n            continue;\n\n        int pos = 0, rev = 0;\n        uint64_t mh = kmer_h\n            ? (w->no_squash\n               ? minhash_with_idx(b, w->minimiser_kmer, &pos, &rev,\n                                  w->try_rev)\n               : minhash_with_idx_squash(b, w->minimiser_kmer, &pos, &rev,\n                                         w->try_rev)\n               )\n            : minhash(b, w->minimiser_kmer, b->core.l_qseq,\n                      &pos, NULL, &rev, 1, w->try_rev, w->no_squash);\n        if (rev)\n            reverse_complement(b);\n\n        if (!kmer_h) {\n            mh += 1LL<<30;\n            pos = 65535-pos >= 0 ? 65535-pos : 0;\n        } else {\n            mh -= pos;\n            pos = 0;\n        }\n\n\n        // Store 64-bit hash in unmapped pos and mpos fields.\n        // The position of hash is in isize, which we use for\n        // resolving ties when sorting by hash key.\n        // These are unused for completely unmapped data and\n        // will be reset during final output.\n        b->core.pos = (mh>>31) & 0x7fffffff;\n        b->core.mpos = mh&0x7fffffff;\n        b->core.isize = pos;\n    }\n}\n\nstatic void *worker(void *data)\n{\n    worker_t *w = (worker_t*)data;\n    w->error = 0;\n\n    switch (g_sam_order) {\n        case Coordinate:\n            if (ks_radixsort(w->buf_len, w->buf, w->h) < 0) {\n                w->error = errno;\n                return NULL;\n            }\n            break;\n        case MinHash:\n            worker_minhash(w);\n            // fall-through\n        default:\n            ks_mergesort(sort, w->buf_len, w->buf, 0);\n    }\n\n    return 0;\n}\n\nstatic int sort_blocks(size_t k, bam1_tag *buf, const sam_hdr_t *h,\n                       int n_threads, buf_region *in_mem,\n                       int large_pos, int minimiser_kmer, bool try_rev,\n                       bool no_squash)\n{\n    int i;\n    size_t pos, rest;\n    pthread_t *tid;\n    pthread_attr_t attr;\n    worker_t *w;\n    int n_failed = 0;\n\n    if (n_threads < 1) n_threads = 1;\n    if (k < n_threads * 64) n_threads = 1; // use a single thread if we only sort a small batch of records\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    w = (worker_t*)calloc(n_threads, sizeof(worker_t));\n    if (!w) return -1;\n    tid = (pthread_t*)calloc(n_threads, sizeof(pthread_t));\n    if (!tid) { free(w); return -1; }\n    pos = 0; rest = k;\n    for (i = 0; i < n_threads; ++i) {\n        w[i].buf_len = rest / (n_threads - i);\n        w[i].buf = &buf[pos];\n        w[i].h = h;\n        w[i].large_pos = large_pos;\n        w[i].minimiser_kmer = minimiser_kmer;\n        w[i].try_rev = try_rev;\n        w[i].no_squash = no_squash;\n        in_mem[i].from = pos;\n        in_mem[i].to = pos + w[i].buf_len;\n        pos += w[i].buf_len; rest -= w[i].buf_len;\n        pthread_create(&tid[i], &attr, worker, &w[i]);\n    }\n    for (i = 0; i < n_threads; ++i) {\n        pthread_join(tid[i], 0);\n        if (w[i].error != 0) {\n            errno = w[i].error;\n            print_error_errno(\"sort\", \"failed to sort block %d\", i);\n            n_failed++;\n        }\n    }\n    free(w);\n    free(tid);\n\n    return n_failed ? -1 : n_threads;\n}\n\nstatic void lib_lookup_destroy(khash_t(const_c2c) *lib_lookup) {\n    khiter_t k;\n    if (lib_lookup == NULL)\n        return;\n    for (k = kh_begin(lib_lookup); k < kh_end(lib_lookup); k++) {\n        if (kh_exist(lib_lookup, k))\n            free(kh_value(lib_lookup, k));\n    }\n    kh_destroy(const_c2c, lib_lookup);\n}\n\n// Build an RG to LB lookup table, for the template coordinate sort.\n// Returns a populated hash table (which may be empty) on success;\n// NULL on failure.\nstatic khash_t(const_c2c) * lookup_libraries(sam_hdr_t *header)\n{\n    khash_t(const_c2c) *lib_lookup = kh_init(const_c2c);\n    kstring_t lib_name = KS_INITIALIZE;\n    int num_rg, i, res;\n    if (!lib_lookup)\n        return NULL;\n\n    // Iterate through any RG lines and look for library information\n    num_rg = sam_hdr_count_lines(header, \"RG\");\n    if (num_rg < 0)\n        goto fail;\n\n    for (i = 0; i < num_rg; i++) {\n        const char *rg_id = sam_hdr_line_name(header, \"RG\", i);\n        khiter_t k;\n        if (!rg_id)\n            goto fail;\n        res = sam_hdr_find_tag_pos(header, \"RG\", i, \"LB\", &lib_name);\n        if (res < -1) // Error\n            goto fail;\n        if (res < 0 || !lib_name.s) // No LB tag\n            continue;\n        // Add to lookup table\n        k = kh_put(const_c2c, lib_lookup, rg_id, &res);\n        if (res < 0) // Error\n            goto fail;\n        if (res > 0) { // Inserted\n            kh_value(lib_lookup, k) = ks_release(&lib_name);\n        }\n    }\n\n    free(lib_name.s);\n\n    return lib_lookup;\n\n fail:\n    lib_lookup_destroy(lib_lookup);\n    free(lib_name.s);\n    return NULL;\n}\n\n// Updates header fields, adding the header if absent.\n// Done as a macro instead of a function as we don't have va_list versions of\n// these functions.\n#define sam_hdr_update_sort(h, ...) (                                       \\\n    (-1 == sam_hdr_update_line((h), \"HD\", NULL, NULL, __VA_ARGS__, NULL) && \\\n     -1 == sam_hdr_add_line((h), \"HD\", \"VN\", SAM_FORMAT_VERSION,            \\\n                            __VA_ARGS__, NULL))                             \\\n    ? -1 : 0)\n\n/*\n * Sets the header sort order, group order and sub sort fields.\n * Returns 0 on success\n *        -1 on failure\n */\nstatic int set_sort_order(sam_hdr_t *h, int mapped) {\n    const char *new_so = NULL;\n    const char *new_go = NULL;\n    const char *new_ss = NULL;\n\n    switch (g_sam_order) {\n        case Coordinate:\n            new_so = \"coordinate\";\n            break;\n        case QueryName:\n            new_so = \"queryname\";\n            new_ss = natural_sort\n                ? \"queryname:natural\"\n                : \"queryname:lexicographical\";\n            break;\n        case MinHash:\n            new_so = mapped\n                ? \"coordinate\"\n                : \"unsorted\";\n            new_ss = mapped\n                ? \"coordinate:minhash\"\n                : \"unsorted:minhash\";\n            break;\n        case TagQueryName:\n        case TagCoordinate:\n            new_so = \"unknown\";\n            break;\n        case TemplateCoordinate:\n            new_so = \"unsorted\";\n            new_go = \"query\";\n            new_ss = \"unsorted:template-coordinate\";\n            break;\n        default:\n            new_so = \"unknown\";\n            break;\n    }\n\n    // Add or update HD\n    if (!new_ss && !new_go) {\n        // SO only\n        if (sam_hdr_update_sort(h, \"SO\", new_so) == -1) {\n            print_error(\"sort\", \"failed to change sort order header to \"\n                        \"'SO:%s'\\n\", new_so);\n            return -1;\n        }\n    } else if (new_ss && !new_go) {\n        // SO and SS\n        if (sam_hdr_update_sort(h, \"SO\", new_so, \"SS\", new_ss) == -1) {\n            print_error(\"sort\", \"failed to change sort order header to \"\n                        \"'SO:%s SS:%s'\\n\", new_so, new_ss);\n            return -1;\n        }\n    } else if (!new_ss && new_go) {\n        // SO and GO\n        if (sam_hdr_update_sort(h, \"SO\", new_so, \"GO\", new_go) == -1) {\n            print_error(\"sort\", \"failed to change sort order header to \"\n                        \"'SO:%s GO:%s'\\n\", new_so, new_go);\n            return -1;\n        }\n    } else {\n        // SO, GO and SS\n        if (sam_hdr_update_sort(h, \"SO\", new_so, \"GO\", new_go,\n                                \"SS\", new_ss) == -1) {\n            print_error(\"sort\", \"failed to change sort order header to \"\n                        \"'SO:%s GO:%s SS:%s'\\n\", new_so, new_go, new_ss);\n            return -1;\n        }\n    }\n\n    // Remove old HD entries\n    if (!new_go && sam_hdr_remove_tag_hd(h, \"GO\") == -1) {\n        print_error(\"sort\", \"failed to delete group order in header\\n\");\n        return -1;\n    }\n\n    if (!new_ss && sam_hdr_remove_tag_hd(h, \"SS\") == -1) {\n        print_error(\"sort\", \"failed to delete sub sort in header\\n\");\n        return -1;\n    }\n\n    return 0;\n}\n\n\n/*!\n  @abstract Sort an unsorted BAM file based on the provided sort order\n\n  @param  sam_order the order in which the sort should occur\n  @param  sort_tag  the tag to use if sorting by Tag\n  @param  minimiser_kmer the kmer size when sorting by MinHash\n  @param  try_rev  try reverse strand when sorting by MinHash\n  @param  fn       name of the file to be sorted\n  @param  prefix   prefix of the temporary files (prefix.NNNN.bam are written)\n  @param  fnout    name of the final output file to be written\n  @param  modeout  sam_open() mode to be used to create the final output file\n  @param  max_mem  approxiate maximum memory (very inaccurate)\n  @param  in_fmt   input file format options\n  @param  out_fmt  output file format and options\n  @param  arg_list    command string for PG line\n  @param  no_pg       if 1, do not add a new PG line\n  @paran  write_index create index for the output file\n  @return 0 for successful sorting, negative on errors\n\n  @discussion It may create multiple temporary subalignment files\n  and then merge them by calling bam_merge_simple(). This function is\n  NOT thread safe.\n */\nint bam_sort_core_ext(SamOrder sam_order, char* sort_tag, int minimiser_kmer,\n                      bool try_rev, bool no_squash, const char *fn,\n                      const char *prefix, const char *fnout,\n                      const char *modeout, size_t _max_mem, int n_threads,\n                      const htsFormat *in_fmt, const htsFormat *out_fmt,\n                      char *arg_list, int no_pg, int write_index)\n{\n    int ret = -1, res, i, nref, n_files = 0, n_big_files = 0, fn_counter = 0;\n    size_t max_k, k, max_mem, bam_mem_offset;\n    sam_hdr_t *header = NULL;\n    samFile *fp = NULL;\n    bam1_tag *buf = NULL;\n    template_coordinate_keys_t *keys = NULL;\n    bam1_t *b = bam_init1();\n    uint8_t *bam_mem = NULL;\n    char **fns = NULL;\n    size_t fns_size = 0;\n    buf_region *in_mem = NULL;\n    khash_t(const_c2c) *lib_lookup = NULL;\n    htsThreadPool htspool = { NULL, 0 };\n    int num_in_mem = 0;\n    int large_pos = 0;\n\n    if (!b) {\n        print_error(\"sort\", \"couldn't allocate memory for bam record\");\n        return -1;\n    }\n\n    if (n_threads < 2) n_threads = 1;\n    g_sam_order = sam_order;\n    if (g_sam_order == TagQueryName || g_sam_order == TagCoordinate) {\n        g_sort_tag[0] = sort_tag[0];\n        g_sort_tag[1] = sort_tag[0] ? sort_tag[1] : '\\0';\n    }\n\n    if (sam_order == TemplateCoordinate) {\n        if ((keys = malloc(sizeof(template_coordinate_keys_t))) == NULL) {\n            print_error(\"sort\", \"could not allocate memory for the top-level keys\");\n            goto err;\n        }\n        keys->n = 0;\n        keys->m = 0;\n        keys->buffer_size = 0x10000;\n        keys->buffers = NULL;\n    }\n\n    max_mem = _max_mem * n_threads;\n    buf = NULL;\n    fp = sam_open_format(fn, \"r\", in_fmt);\n    if (fp == NULL) {\n        print_error_errno(\"sort\", \"can't open \\\"%s\\\"\", fn);\n        goto err;\n    }\n    hts_set_opt(fp, HTS_OPT_BLOCK_SIZE, BAM_BLOCK_SIZE);\n    header = sam_hdr_read(fp);\n    if (header == NULL) {\n        print_error(\"sort\", \"failed to read header from \\\"%s\\\"\", fn);\n        goto err;\n    }\n\n    // Inspect the header looking for long chromosomes\n    // If there is one, we need to write temporary files in SAM format\n    nref = sam_hdr_nref(header);\n    for (i = 0; i < nref; i++) {\n        if (sam_hdr_tid2len(header, i) > INT32_MAX)\n            large_pos = 1;\n    }\n\n    // Also check the output format is large position compatible\n    if (large_pos) {\n        int compatible = (out_fmt->format == sam\n                          || (out_fmt->format == cram\n                              && out_fmt->version.major >= 4)\n                          || (out_fmt->format == unknown_format\n                              && modeout[0] == 'w'\n                              && (modeout[1] == 'z' || modeout[1] == '\\0')));\n        if (!compatible) {\n            print_error(\"sort\", \"output format is not compatible with very large references\");\n            goto err;\n        }\n    }\n\n    if (g_sam_order == TemplateCoordinate) {\n        lib_lookup = lookup_libraries(header);\n        if (!lib_lookup)\n            goto err;\n    }\n\n    if (n_threads > 1) {\n        htspool.pool = hts_tpool_init(n_threads);\n        if (!htspool.pool) {\n            print_error_errno(\"sort\", \"failed to set up thread pool\");\n            goto err;\n        }\n        hts_set_opt(fp, HTS_OPT_THREAD_POOL, &htspool);\n    }\n\n    if ((bam_mem = malloc(max_mem)) == NULL) {\n        print_error(\"sort\", \"couldn't allocate memory for bam_mem\");\n        goto err;\n    }\n\n    in_mem = calloc(n_threads > 0 ? n_threads : 1, sizeof(in_mem[0]));\n    if (!in_mem) goto err;\n\n    // write sub files\n    k = max_k = bam_mem_offset = 0;\n    size_t name_len = strlen(prefix) + 30;\n    int placed = 0;\n    while ((res = sam_read1(fp, header, b)) >= 0) {\n        int mem_full = 0;\n\n        placed |= b->core.tid >= 0;\n\n        if (k == max_k) {\n            bam1_tag *new_buf;\n            max_k = max_k? max_k<<1 : 0x10000;\n            if ((new_buf = realloc(buf, max_k * sizeof(bam1_tag))) == NULL) {\n                print_error(\"sort\", \"couldn't allocate memory for buf\");\n                goto err;\n            }\n            buf = new_buf;\n        }\n        if (sam_order == TemplateCoordinate && k >= keys->m * keys->buffer_size) {\n            if (template_coordinate_keys_realloc(keys, k + 1) == -1) {\n                goto err;\n            }\n        }\n\n        // Check if the BAM record will fit in the memory limit\n        if (bam_mem_offset + sizeof(*b) + b->l_data < max_mem) {\n            // Copy record into the memory block\n            buf[k].bam_record = (bam1_t *)(bam_mem + bam_mem_offset);\n            *buf[k].bam_record = *b;\n            buf[k].bam_record->data = (uint8_t *)((char *)buf[k].bam_record + sizeof(bam1_t));\n            memcpy(buf[k].bam_record->data, b->data, b->l_data);\n            // store next BAM record in next 8-byte-aligned address after\n            // current one\n            bam_mem_offset = (bam_mem_offset + sizeof(*b) + b->l_data + 8 - 1) & ~((size_t)(8 - 1));\n        } else {\n            // Add a pointer to the remaining record\n            buf[k].bam_record = b;\n            mem_full = 1;\n        }\n\n        // Set the tag if sorting by tag, or the key for template cooridinate sorting\n        switch (g_sam_order) {\n            case TagQueryName:\n            case TagCoordinate:\n                buf[k].u.tag = bam_aux_get(buf[k].bam_record, g_sort_tag);\n                break;\n            case TemplateCoordinate:\n                ++keys->n;\n                template_coordinate_key_t *key = template_coordinate_keys_get(keys, k);\n                buf[k].u.key = template_coordinate_key(buf[k].bam_record, key, header, lib_lookup);\n                if (buf[k].u.key == NULL) goto err;\n                break;\n            default:\n                buf[k].u.tag = NULL;\n                buf[k].u.key = NULL;\n        }\n        ++k;\n\n        if (mem_full) {\n            if (hts_resize(char *, n_files + 1, &fns_size, &fns, 0) < 0)\n                goto err;\n\n            int sort_res = sort_blocks(k, buf, header, n_threads,\n                                       in_mem, large_pos, minimiser_kmer,\n                                       try_rev, no_squash);\n            if (sort_res < 0)\n                goto err;\n\n            fns[n_files] = calloc(name_len, 1);\n            if (!fns[n_files])\n                goto err;\n            const int MAX_TRIES = 1000;\n            int tries = 0, merge_res = -1;\n            char *sort_by_tag = (g_sam_order == TagQueryName || g_sam_order == TagCoordinate) ? sort_tag : NULL;\n            int consolidate_from = n_files;\n            if (n_files - n_big_files >= MAX_TMP_FILES/2)\n                consolidate_from = n_big_files;\n            else if (n_files >= MAX_TMP_FILES)\n                consolidate_from = 0;\n\n            for (;;) {\n                if (tries) {\n                    snprintf(fns[n_files], name_len, \"%s.%.4d-%.3d.bam\",\n                             prefix, fn_counter, tries);\n                } else {\n                    snprintf(fns[n_files], name_len, \"%s.%.4d.bam\", prefix,\n                             fn_counter);\n                }\n                if (bam_merge_simple(g_sam_order, sort_by_tag, fns[n_files],\n                                     large_pos ? \"wzx1\" : \"wbx1\", header,\n                                     n_files - consolidate_from,\n                                     &fns[consolidate_from], n_threads,\n                                     in_mem, buf, keys,\n                                     lib_lookup, &htspool, \"sort\", NULL, NULL,\n                                     NULL, 1, 0, 0) >= 0) {\n                    merge_res = 0;\n                    break;\n                }\n                if (errno == EEXIST && tries < MAX_TRIES) {\n                    tries++;\n                } else {\n                    break;\n                }\n            }\n            fn_counter++;\n            if (merge_res < 0) {\n                if (errno != EEXIST)\n                    unlink(fns[n_files]);\n                free(fns[n_files]);\n                goto err;\n            }\n\n            if (consolidate_from < n_files) {\n                for (i = consolidate_from; i < n_files; i++) {\n                    unlink(fns[i]);\n                    free(fns[i]);\n                }\n                fns[consolidate_from] = fns[n_files];\n                n_files = consolidate_from;\n                n_big_files = consolidate_from + 1;\n            }\n\n            n_files++;\n            k = 0;\n            if (keys != NULL) keys->n = 0;\n            bam_mem_offset = 0;\n\n        }\n    }\n    if (res != -1) {\n        print_error(\"sort\", \"truncated file. Aborting\");\n        goto err;\n    }\n\n    // Sort last records\n    if (k > 0) {\n        num_in_mem = sort_blocks(k, buf, header, n_threads,\n                                 in_mem, large_pos, minimiser_kmer, try_rev,\n                                 no_squash);\n        if (num_in_mem < 0) goto err;\n    } else {\n        num_in_mem = 0;\n    }\n\n    // Set the order here as we need to know if entirely unmapped.\n    if (set_sort_order(header, placed) < 0)\n        goto err;\n\n    // write the final output\n    if (n_files == 0 && num_in_mem < 2) { // a single block\n        if (write_buffer(fnout, modeout, k, buf, header, n_threads, out_fmt,\n                         minimiser_kmer, arg_list, no_pg, write_index) != 0) {\n            print_error_errno(\"sort\", \"failed to create \\\"%s\\\"\", fnout);\n            goto err;\n        }\n    } else { // then merge\n        fprintf(stderr,\n                \"[bam_sort_core] merging from %d files and %d in-memory blocks...\\n\",\n                n_files, num_in_mem);\n        // Paranoia check - all temporary files should have a name\n        for (i = 0; i < n_files; ++i) {\n            if (!fns[i]) {\n                print_error(\"sort\",\n                            \"BUG: no name stored for temporary file %d\", i);\n                abort();\n            }\n        }\n        char *sort_by_tag = (sam_order == TagQueryName || sam_order == TagCoordinate) ? sort_tag : NULL;\n        if (bam_merge_simple(sam_order, sort_by_tag, fnout, modeout, header,\n                             n_files, fns, num_in_mem, in_mem, buf, keys,\n                             lib_lookup, &htspool, \"sort\", in_fmt, out_fmt,\n                             arg_list, no_pg, write_index, 1) < 0) {\n            // Propagate bam_merge_simple() failure; it has already emitted a\n            // message explaining the failure, so no further message is needed.\n            goto err;\n        }\n    }\n\n    ret = 0;\n\n err:\n    // free\n    if (fns) {\n        for (i = 0; i < n_files; ++i) {\n            if (fns[i]) {\n                unlink(fns[i]);\n                free(fns[i]);\n            }\n        }\n        free(fns);\n    }\n    bam_destroy1(b);\n    free(buf);\n    if (keys != NULL) {\n        for (i = 0; i < keys->m; ++i) {\n            free(keys->buffers[i]);\n        }\n        free(keys->buffers);\n        free(keys);\n    }\n    free(bam_mem);\n    free(in_mem);\n    lib_lookup_destroy(lib_lookup);\n    sam_hdr_destroy(header);\n    if (fp) sam_close(fp);\n    if (htspool.pool)\n        hts_tpool_destroy(htspool.pool);\n\n    return ret;\n}\n\n// Unused here but may be used by legacy samtools-using third-party code\nint bam_sort_core(int is_by_qname, const char *fn, const char *prefix, size_t max_mem)\n{\n    int ret;\n    char *fnout = calloc(strlen(prefix) + 4 + 1, 1);\n    if (!fnout) return -1;\n    sprintf(fnout, \"%s.bam\", prefix);\n    SamOrder sam_order = is_by_qname ? QueryName : Coordinate;\n    g_sam_order = sam_order;\n    ret = bam_sort_core_ext(sam_order, NULL, 0, false, true, fn, prefix,\n                            fnout, \"wb\", max_mem, 0, NULL, NULL, NULL, 1, 0);\n    free(fnout);\n    return ret;\n}\n\nstatic void sort_usage(FILE *fp)\n{\n    fprintf(fp,\n\"Usage: samtools sort [options...] [in.bam]\\n\"\n\"Options:\\n\"\n\"  -l INT     Set compression level, from 0 (uncompressed) to 9 (best)\\n\"\n\"  -u         Output uncompressed data (equivalent to -l 0)\\n\"\n\"  -m INT     Set maximum memory per thread; suffix K/M/G recognized [768M]\\n\"\n\"  -M         Use minimiser for clustering unaligned/unplaced reads\\n\"\n\"  -R         Do not use reverse strand (only compatible with -M)\\n\"\n\"  -K INT     Kmer size to use for minimiser [20]\\n\"\n\"  -I FILE    Order minimisers by their position in FILE FASTA\\n\"\n\"  -w INT     Window size for minimiser indexing via -I ref.fa [100]\\n\"\n\"  -H         Squash homopolymers when computing minimiser\\n\"\n\"  -n         Sort by read name (natural): cannot be used with samtools index\\n\"\n\"  -N         Sort by read name (ASCII): cannot be used with samtools index\\n\"\n\"  -t TAG     Sort by value of TAG. Uses position as secondary index (or read name if -n is set)\\n\"\n\"  -o FILE    Write final output to FILE rather than standard output\\n\"\n\"  -T PREFIX  Write temporary files to PREFIX.nnnn.bam\\n\"\n\"      --no-PG\\n\"\n\"               Do not add a PG line\\n\"\n\"      --template-coordinate\\n\"\n\"               Sort by template-coordinate\\n\");\n    sam_global_opt_help(fp, \"-.O..@..\");\n}\n\nstatic void complain_about_memory_setting(size_t max_mem) {\n    char  *suffix = \"\";\n    const size_t nine_k = 9<<10;\n    if (max_mem > nine_k) { max_mem >>= 10; suffix = \"K\"; }\n    if (max_mem > nine_k) { max_mem >>= 10; suffix = \"M\"; }\n\n    fprintf(stderr,\n\"[bam_sort] -m setting (%zu%s bytes) is less than the minimum required (%zuM).\\n\\n\"\n\"Trying to run with -m too small can lead to the creation of a very large number\\n\"\n\"of temporary files.  This may make sort fail due to it exceeding limits on the\\n\"\n\"number of files it can have open at the same time.\\n\\n\"\n\"Please check your -m parameter.  It should be an integer followed by one of the\\n\"\n\"letters K (for kilobytes), M (megabytes) or G (gigabytes).  You should ensure it\\n\"\n\"is at least the minimum above, and much higher if you are sorting a large file.\\n\",\n            max_mem, suffix, SORT_MIN_MEGS_PER_THREAD);\n}\n\nint bam_sort(int argc, char *argv[])\n{\n    size_t max_mem = SORT_DEFAULT_MEGS_PER_THREAD << 20;\n    int c, nargs, ret, o_seen = 0, level = -1, no_pg = 0;\n    SamOrder sam_order = Coordinate;\n    bool by_tag = false;\n    int minimiser_kmer = 20;\n    bool try_rev = true;\n    char* sort_tag = NULL, *arg_list = NULL;\n    char *fnout = \"-\", modeout[12];\n    kstring_t tmpprefix = { 0, 0, NULL };\n    struct stat st;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    int window = 100;\n    char *minimiser_ref = NULL;\n    int no_squash = 1;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', 0, 0, '@'),\n        { \"threads\", required_argument, NULL, '@' },\n        {\"no-PG\", no_argument, NULL, 1},\n        { \"template-coordinate\", no_argument, NULL, 2},\n        { NULL, 0, NULL, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \"l:m:nNo:O:T:@:t:MI:K:uRw:H\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'o': fnout = optarg; o_seen = 1; break;\n        case 'N': natural_sort = 0; // fall through\n        case 'n': sam_order = QueryName; break;\n        case 't': by_tag = true; sort_tag = optarg; break;\n        case 'm': {\n                char *q;\n                max_mem = strtol(optarg, &q, 0);\n                if (*q == 'k' || *q == 'K') max_mem <<= 10;\n                else if (*q == 'm' || *q == 'M') max_mem <<= 20;\n                else if (*q == 'g' || *q == 'G') max_mem <<= 30;\n                break;\n            }\n        case 'T': kputs(optarg, &tmpprefix); break;\n        case 'l': level = atoi(optarg); break;\n        case 'u': level = 0; break;\n        case   1: no_pg = 1; break;\n        case   2: sam_order = TemplateCoordinate; break;\n        case 'M': sam_order = MinHash; break;\n        case 'I':\n            sam_order = MinHash; // implicit option\n            minimiser_ref = optarg;\n            break;\n        case 'H': no_squash = 0; break;\n\n        case 'w': window = atoi(optarg); break;\n\n        case 'R': try_rev = false; break;\n        case 'K':\n            minimiser_kmer = atoi(optarg);\n            if (minimiser_kmer < 1)\n                minimiser_kmer = 1;\n            else if (minimiser_kmer > 31)\n                minimiser_kmer = 31;\n            break;\n\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                  /* else fall-through */\n        case '?': sort_usage(stderr); ret = EXIT_FAILURE; goto sort_end;\n        }\n    }\n\n    if (minimiser_ref) {\n        fprintf(stderr, \"Building index ... \");\n        fflush(stderr);\n        if (build_minhash_index(minimiser_ref, minimiser_kmer, window,\n                                no_squash)) {\n            ret = EXIT_FAILURE;\n            goto sort_end;\n        }\n        fprintf(stderr, \"done\\n\");\n    }\n\n    // Change sort order if tag sorting is requested.  Must update based on secondary index\n    if (by_tag) {\n        sam_order = sam_order == QueryName ? TagQueryName : TagCoordinate;\n    }\n\n    nargs = argc - optind;\n    if (nargs == 0 && isatty(STDIN_FILENO)) {\n        sort_usage(stdout);\n        ret = EXIT_SUCCESS;\n        goto sort_end;\n    }\n    else if (nargs >= 2) {\n        // If exactly two, user probably tried to specify legacy <out.prefix>\n        if (nargs == 2)\n            fprintf(stderr, \"[bam_sort] Use -T PREFIX / -o FILE to specify temporary and final output files\\n\");\n\n        sort_usage(stderr);\n        ret = EXIT_FAILURE;\n        goto sort_end;\n    }\n\n    if (ga.write_index && sam_order != Coordinate && sam_order != MinHash) {\n        fprintf(stderr, \"[W::bam_sort] Ignoring --write-index as it only works for position sorted files.\\n\");\n        ga.write_index = 0;\n    }\n\n    if (!no_pg && !(arg_list = stringify_argv(argc+1, argv-1))) {\n        print_error(\"sort\", \"failed to create arg_list\");\n        return 1;\n    }\n\n    if (max_mem < (SORT_MIN_MEGS_PER_THREAD << 20)) {\n        complain_about_memory_setting(max_mem);\n        ret = EXIT_FAILURE;\n        goto sort_end;\n    }\n\n    strcpy(modeout, \"wb\");\n    sam_open_mode(modeout+1, fnout, NULL);\n    if (level >= 0) sprintf(strchr(modeout, '\\0'), \"%d\", level < 9? level : 9);\n\n    if (tmpprefix.l == 0) {\n        if (strcmp(fnout, \"-\") != 0) {\n            char *idx = strstr(fnout, HTS_IDX_DELIM);\n            kputsn(fnout, idx ? idx - fnout : strlen(fnout), &tmpprefix);\n            kputs(\".tmp\", &tmpprefix);\n        } else {\n            kputc('.', &tmpprefix);\n        }\n    }\n    if (stat(tmpprefix.s, &st) == 0 && S_ISDIR(st.st_mode)) {\n        unsigned t = ((unsigned) time(NULL)) ^ ((unsigned) clock());\n        if (tmpprefix.s[tmpprefix.l-1] != '/') kputc('/', &tmpprefix);\n        ksprintf(&tmpprefix, \"samtools.%d.%u.tmp\", (int) getpid(), t % 10000);\n    }\n\n    ret = bam_sort_core_ext(sam_order, sort_tag,\n                            (sam_order == MinHash) ? minimiser_kmer : 0,\n                            try_rev, no_squash,\n                            (nargs > 0) ? argv[optind] : \"-\",\n                            tmpprefix.s, fnout, modeout, max_mem, ga.nthreads,\n                            &ga.in, &ga.out, arg_list, no_pg, ga.write_index);\n    if (ret >= 0)\n        ret = EXIT_SUCCESS;\n    else {\n        char dummy[4];\n        // If we failed on opening the input file & it has no .bam/.cram/etc\n        // extension, the user probably tried legacy -o <infile> <out.prefix>\n        if (ret == -2 && o_seen && nargs > 0 && sam_open_mode(dummy, argv[optind], NULL) < 0)\n            fprintf(stderr, \"[bam_sort] Note the <out.prefix> argument has been replaced by -T/-o options\\n\");\n\n        ret = EXIT_FAILURE;\n    }\n\n#ifdef DEBUG_MINHASH\n    fprintf(stderr, \"Missed %.1f%%, dup %.1f%%\\n\",\n            100.0*nmis/(ntot+.1),\n            100.0*ndup/(ntot+.1));\n#endif\n\nsort_end:\n    free(tmpprefix.s);\n    free(arg_list);\n    sam_global_args_free(&ga);\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_split.c",
          "type": "blob",
          "size": 31.421875,
          "content": "/*  bam_split.c -- split subcommand.\n\n    Copyright (C) 2013-2016,2018-2019,2023,2024 Genome Research Ltd.\n\n    Author: Martin Pollard <mp15@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <unistd.h>\n#include <regex.h>\n#include <assert.h>\n#include <htslib/sam.h>\n#include <htslib/khash.h>\n#include <htslib/kstring.h>\n#include <htslib/cram.h>\n#include \"htslib/thread_pool.h\"\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n\n\nKHASH_MAP_INIT_STR(c2i, int)\n\nstruct parsed_opts {\n    const char *merged_input_name;\n    const char *unaccounted_header_name;\n    const char *unaccounted_name;\n    const char *output_format_string;\n    const char *tag;\n    long max_split;\n    bool verbose;\n    int no_pg;\n    int zero_pad;\n    sam_global_args ga;\n};\n\n#define DEFAULT_MAX_SPLIT 100\n\ntypedef struct parsed_opts parsed_opts_t;\n\nstruct state {\n    samFile* merged_input_file;\n    sam_hdr_t* merged_input_header;\n    samFile* unaccounted_file;\n    sam_hdr_t* unaccounted_header;\n    char *unaccounted_idx_fn;\n    size_t output_count;\n    char **tag_vals;\n    char **index_file_name;\n    char **output_file_name;\n    samFile **output_file;\n    sam_hdr_t **output_header;\n    kh_c2i_t* tag_val_hash;\n    htsThreadPool p;\n    int write_index;\n};\n\ntypedef struct state state_t;\n\nstatic int cleanup_state(state_t* status, bool check_close);\nstatic void cleanup_opts(parsed_opts_t* opts);\n\nstatic void usage(FILE *write_to)\n{\n    fprintf(write_to,\n\"Usage: samtools split [-u <unaccounted.bam>] [-h <unaccounted_header.sam>]\\n\"\n\"                      [-f <format_string>] [-v] <merged.bam>\\n\"\n\"Options:\\n\"\n\"  -f STRING           output filename format string [\\\"%%*_%%#.%%.\\\"]\\n\"\n\"  -u FILE1            put left-over reads in FILE1\\n\"\n\"  -h FILE2            ... and override the header with FILE2 (-u file only)\\n\"\n\"  -d TAG              split by TAG value. TAG value must be a string.\\n\"\n\"  -p NUMBER           zero-pad numbers in filenames to NUMBER digits\\n\"\n\"  -M,--max-split NUM  limit number of output files from -d to NUM [%d]\\n\"\n\"  -v                  verbose output\\n\"\n\"  --no-PG             do not add a PG line\\n\",\n            DEFAULT_MAX_SPLIT);\n    sam_global_opt_help(write_to, \"-....@..\");\n    fprintf(write_to,\n\"\\n\"\n\"Format string expansions:\\n\"\n\"  %%%%     %%\\n\"\n\"  %%*     basename\\n\"\n\"  %%#     index (of @RG in the header, or count of TAG values seen so far)\\n\"\n\"  %%!     @RG ID or TAG value\\n\"\n\"  %%.     filename extension for output format\\n\"\n      );\n}\n\n// Takes the command line options and turns them into something we can understand\nstatic parsed_opts_t* parse_args(int argc, char** argv)\n{\n    if (argc == 1) { usage(stdout); return NULL; }\n\n    const char *optstring = \"vf:h:u:d:M:p:@:\";\n    char *default_format_string = \"%*_%#.%.\";\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 0, 0, 0, '@'),\n        {\"no-PG\", no_argument, NULL, 1},\n        {\"max-split\", required_argument, NULL, 'M'},\n        {\"zero-pad\", required_argument, NULL, 'p'},\n        { NULL, 0, NULL, 0 }\n    };\n\n    parsed_opts_t* retval = calloc(sizeof(parsed_opts_t), 1);\n    if (! retval ) { perror(\"cannot allocate option parsing memory\"); return NULL; }\n\n    retval->max_split = DEFAULT_MAX_SPLIT;\n    sam_global_args_init(&retval->ga);\n\n    int opt;\n    while ((opt = getopt_long(argc, argv, optstring, lopts, NULL)) != -1) {\n        switch (opt) {\n        case 'f':\n            retval->output_format_string = optarg;\n            break;\n        case 'h':\n            retval->unaccounted_header_name = optarg;\n            break;\n        case 'v':\n            retval->verbose = true;\n            break;\n        case 'u':\n            retval->unaccounted_name = optarg;\n            break;\n        case 'd':\n            retval->tag = optarg;\n            default_format_string = \"%*_%!.%.\";\n            break;\n        case 'M': {\n            char *end = optarg;\n            retval->max_split = strtol(optarg, &end, 10);\n            if (*optarg == '\\0' || *end != '\\0' || retval->max_split == 0) {\n                print_error(\"split\", \"Invalid -M argument: \\\"%s\\\"\", optarg);\n                free(retval);\n                return NULL;\n            }\n            if (retval->max_split < 0) // No limit requested\n                retval->max_split = LONG_MAX;\n            break;\n        }\n        case 'p': {\n            char *end = optarg;\n            unsigned long val = strtoul(optarg, &end, 10);\n            if (*optarg == '\\0' || *end != '\\0' || val > 20) {\n                print_error(\"split\", \"Invalid -p argument: \\\"%s\\\"\", optarg);\n                free(retval);\n                return NULL;\n            }\n            retval->zero_pad = (int) val;\n            break;\n        }\n        case 1:\n            retval->no_pg = 1;\n            break;\n\n        default:\n            if (parse_sam_global_opt(opt, optarg, lopts, &retval->ga) == 0) break;\n            /* else fall-through */\n        case '?':\n            usage(stdout);\n            free(retval);\n            return NULL;\n        }\n    }\n\n    if (retval->output_format_string == NULL) retval->output_format_string = default_format_string;\n\n    argc -= optind;\n    argv += optind;\n\n    if (argc != 1) {\n        print_error(\"split\", \"Invalid number of arguments: %d\", argc);\n        usage(stderr);\n        free(retval);\n        return NULL;\n    }\n\n    retval->merged_input_name = argv[0];\n\n    return retval;\n}\n\n// Expands a output filename format string\nstatic char* expand_format_string(const char* format_string,\n                                  const char* basename, const char* tag_val,\n                                  const int file_idx, const int zero_pad,\n                                  const htsFormat *format)\n{\n    kstring_t str = { 0, 0, NULL };\n    const char* pointer = format_string;\n    const char* next;\n    while ((next = strchr(pointer, '%')) != NULL) {\n        if (kputsn(pointer, next-pointer, &str) < 0) goto memfail;\n        ++next;\n        switch (*next) {\n            case '%':\n                if (kputc('%', &str) < 0) goto memfail;\n                break;\n            case '*':\n                if (kputs(basename, &str) < 0) goto memfail;\n                break;\n            case '#':\n                if (zero_pad == 0) {\n                    if (kputl(file_idx, &str) < 0) goto memfail;\n                } else {\n                    if (ksprintf(&str, \"%0*d\", zero_pad, file_idx) < 0)\n                        goto memfail;\n                }\n                break;\n            case '!':\n                if (kputs(tag_val, &str) < 0) goto memfail;\n                break;\n            case '.':\n                // Only really need to cope with sam, bam, cram\n                if (format->format != unknown_format) {\n                    if (kputs(hts_format_file_extension(format), &str) < 0)\n                        goto memfail;\n                } else {\n                    if (kputs(\"bam\", &str) < 0) goto memfail;\n                }\n                break;\n            case '\\0':\n                print_error(\"split\", \"Trailing %% in filename format string\");\n                goto fail;\n            default:\n                // Error is: fprintf(stderr, \"bad format string, unknown format specifier\\n\");\n                print_error(\"split\", \"Unknown specifier %%%c in filename format string\", *next);\n                goto fail;\n        }\n        pointer = next + 1;\n    }\n    if (kputs(pointer, &str) < 0) goto memfail;\n    return ks_release(&str);\n\n memfail:\n    print_error_errno(\"split\", \"Couldn't build output filename\");\n fail:\n    free(str.s);\n    return NULL;\n}\n\n// Parse the header, count the number of RG tags and return a list of their names\nstatic bool count_RG(sam_hdr_t* hdr, size_t* count, char*** output_name)\n{\n    char **names = NULL;\n    kstring_t id_val = KS_INITIALIZE;\n    int i, n_rg = sam_hdr_count_lines(hdr, \"RG\");\n\n    if (n_rg < 0) {\n        print_error(\"split\", \"Failed to get @RG IDs\");\n        *count = 0;\n        *output_name = NULL;\n        return false;\n    }\n\n    if (n_rg == 0) {\n        *count = 0;\n        *output_name = NULL;\n        return true;\n    }\n\n    names = calloc(n_rg, sizeof(names[0]));\n    if (!names) goto memfail;\n\n    for (i = 0; i < n_rg; i++) {\n        if (sam_hdr_find_tag_pos(hdr, \"RG\", i, \"ID\", &id_val) < 0) goto memfail;\n        names[i] = ks_release(&id_val);\n    }\n\n    *count = n_rg;\n    *output_name = names;\n    return true;\n\n memfail:\n    print_error_errno(\"split\", \"Failed to get @RG IDs\");\n    *count = 0;\n    *output_name = NULL;\n    ks_free(&id_val);\n    free(names);\n    return false;\n}\n\nstatic int header_compatible(sam_hdr_t *hdr1, sam_hdr_t *hdr2)\n{\n    size_t n;\n    if (sam_hdr_nref(hdr1) != sam_hdr_nref(hdr2)) {\n        print_error(\"split\",\n                    \"Unaccounted header contains wrong number of references\");\n        return -1;\n    }\n    for (n = 0; n < sam_hdr_nref(hdr1); n++) {\n        hts_pos_t h1_len = sam_hdr_tid2len(hdr1, n);\n        hts_pos_t h2_len = sam_hdr_tid2len(hdr2, n);\n        if (h1_len != h2_len) {\n            print_error(\"split\",\n                        \"Unaccounted header reference %zu \\\"%s\\\" is not the same length as in the input file\",\n                        n + 1, sam_hdr_tid2name(hdr2, n));\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int grow_output_lists(state_t *state, size_t count) {\n    char **new_list = realloc(state->tag_vals, count * sizeof(char *));\n    if (!new_list)\n        return -1;\n    state->tag_vals = new_list;\n    new_list = realloc(state->index_file_name, count * sizeof(char *));\n    if (!new_list)\n        return -1;\n    state->index_file_name = new_list;\n    new_list = realloc(state->output_file_name, count * sizeof(char *));\n    if (!new_list)\n        return -1;\n    state->output_file_name = new_list;\n    samFile **new_file = realloc(state->output_file,\n                                 count * sizeof(samFile *));\n    if (!new_file)\n        return -1;\n    state->output_file = new_file;\n    sam_hdr_t **new_hdr = realloc(state->output_header,\n                                  count * sizeof(sam_hdr_t *));\n    if (!new_hdr)\n        return -1;\n    state->output_header = new_hdr;\n    return 0;\n}\n\nstatic khiter_t prep_sam_file(parsed_opts_t *opts, state_t *state,\n                              const char *tag, const char *arg_list,\n                              int is_rg) {\n    char *input_base_name = NULL, *new_file_name = NULL, *tag_val = NULL;\n    char *new_idx_fn = NULL;\n    sam_hdr_t *new_hdr = NULL;\n    samFile *new_sam_file = NULL;\n\n    khiter_t i = kh_get_c2i(state->tag_val_hash, tag);\n    if (i != kh_end(state->tag_val_hash)) {\n        return i;\n    }\n    // create new file\n    if (grow_output_lists(state, state->output_count + 1) != 0) {\n        print_error_errno(\"split\", \"Couldn't grow output lists\");\n        return kh_end(state->tag_val_hash);\n    }\n    tag_val = strdup(tag);\n    if (!tag_val) {\n        print_error_errno(\"split\", \"Couldn't copy tag value\");\n        return kh_end(state->tag_val_hash);\n    }\n    char *dirsep = strrchr(opts->merged_input_name, '/');\n    input_base_name = strdup(dirsep? dirsep+1 : opts->merged_input_name);\n    if (!input_base_name) {\n        print_error_errno(\"split\", \"Filename parsing failed\");\n        goto fail;\n    }\n\n    char* extension = strrchr(input_base_name, '.');\n    if (extension) *extension = '\\0';\n\n    new_file_name = expand_format_string(opts->output_format_string,\n                                         input_base_name, tag,\n                                         kh_size(state->tag_val_hash),\n                                         opts->zero_pad, &opts->ga.out);\n    if (!new_file_name) {\n        print_error_errno(\"split\", \"Filename creation failed\");\n        goto fail;\n    }\n\n    new_hdr = sam_hdr_dup(state->merged_input_header);\n    if (!new_hdr) {\n        print_error_errno(\"split\", \"Duplicating header for file \\\"%s\\\" failed\", new_file_name);\n        goto fail;\n    }\n    if (!opts->no_pg && sam_hdr_add_pg(new_hdr, \"samtools\",\n                                       \"VN\", samtools_version(),\n                                       arg_list ? \"CL\": NULL,\n                                       arg_list ? arg_list : NULL,\n                                       NULL)) {\n        print_error_errno(\"split\", \"Adding PG line to file \\\"%s\\\" failed\", new_file_name);\n        goto fail;\n    }\n\n    if (is_rg) {\n        // If here, we've found an RG:Z: tag without a corresponding @RG\n        // line in the header.\n        if (sam_hdr_remove_lines(new_hdr, \"RG\", \"ID\", NULL) != 0) {\n            print_error_errno(\"split\",\n                              \"Failed to remove @RG lines from file \\\"%s\\\"\",\n                              new_file_name);\n            goto fail;\n        }\n        if (sam_hdr_add_line(new_hdr, \"RG\", \"ID\", tag_val, NULL) != 0) {\n            print_error_errno(\"split\",\n                              \"Failed to add @RG line to file \\\"%s\\\"\",\n                              new_file_name);\n            goto fail;\n        }\n    }\n\n    char outmode[4] = \"w\";\n    sam_open_mode(outmode + 1, new_file_name, NULL);\n    new_sam_file = sam_open_format(new_file_name, outmode, &opts->ga.out);\n    if (!new_sam_file) {\n        print_error_errno(\"split\", \"Opening filename for writing \\\"%s\\\" failed\", new_file_name);\n        goto fail;\n    }\n    if (state->p.pool)\n        hts_set_opt(new_sam_file, HTS_OPT_THREAD_POOL, &state->p);\n\n    if (sam_hdr_write(new_sam_file, new_hdr) != 0) {\n        print_error_errno(\"split\", \"Couldn't write header to \\\"%s\\\"\",\n                          new_file_name);\n        goto fail;\n    }\n\n    if (state->write_index) {\n        new_idx_fn = auto_index(new_sam_file, new_file_name, new_hdr);\n        if (!new_idx_fn) {\n            print_error_errno(\"split\", \"Creating index file for file \\\"%s\\\" failed\", new_file_name);\n            goto fail;\n        }\n    }\n\n    int ret = -1;\n    i = kh_put_c2i(state->tag_val_hash, tag_val, &ret);\n    if (ret < 0) {\n        print_error_errno(\"split\", \"Adding file \\\"%s\\\" failed\", new_file_name);\n        goto fail;\n    }\n\n    kh_val(state->tag_val_hash, i) = state->output_count;\n    state->tag_vals[state->output_count] = tag_val;\n    state->index_file_name[state->output_count] = new_idx_fn;\n    state->output_file_name[state->output_count] = new_file_name;\n    state->output_file[state->output_count] = new_sam_file;\n    state->output_header[state->output_count] = new_hdr;\n    state->output_count++;\n    free(input_base_name);\n    return i;\n\n fail:\n    free(input_base_name);\n    free(new_file_name);\n    free(tag_val);\n    free(new_idx_fn);\n    if (new_hdr)\n        sam_hdr_destroy(new_hdr);\n    if (new_sam_file)\n        sam_close(new_sam_file);\n    return kh_end(state->tag_val_hash);\n}\n\n// Set the initial state\nstatic state_t* init(parsed_opts_t* opts, const char *arg_list)\n{\n    state_t* retval = calloc(sizeof(state_t), 1);\n    if (!retval) {\n        print_error_errno(\"split\", \"Initialisation failed\");\n        return NULL;\n    }\n\n    if (opts->ga.nthreads > 0) {\n        if (!(retval->p.pool = hts_tpool_init(opts->ga.nthreads))) {\n            fprintf(stderr, \"Error creating thread pool\\n\");\n            cleanup_state(retval, false);\n            return NULL;\n        }\n    }\n\n    retval->merged_input_file = sam_open_format(opts->merged_input_name, \"r\", &opts->ga.in);\n    if (!retval->merged_input_file) {\n        print_error_errno(\"split\", \"Could not open \\\"%s\\\"\", opts->merged_input_name);\n        cleanup_state(retval, false);\n        return NULL;\n    }\n    if (retval->p.pool)\n        hts_set_opt(retval->merged_input_file, HTS_OPT_THREAD_POOL, &retval->p);\n    retval->merged_input_header = sam_hdr_read(retval->merged_input_file);\n    if (retval->merged_input_header == NULL) {\n        print_error(\"split\", \"Could not read header from \\\"%s\\\"\", opts->merged_input_name);\n        cleanup_state(retval, false);\n        return NULL;\n    }\n    retval->write_index = opts->ga.write_index;\n\n    if (opts->unaccounted_name) {\n        if (opts->unaccounted_header_name) {\n            samFile* hdr_load = sam_open_format(opts->unaccounted_header_name, \"r\", &opts->ga.in);\n            if (!hdr_load) {\n                print_error_errno(\"split\", \"Could not open unaccounted header file \\\"%s\\\"\", opts->unaccounted_header_name);\n                cleanup_state(retval, false);\n                return NULL;\n            }\n            retval->unaccounted_header = sam_hdr_read(hdr_load);\n            if (retval->unaccounted_header == NULL) {\n                print_error(\"split\", \"Could not read header from \\\"%s\\\"\", opts->unaccounted_header_name);\n                cleanup_state(retval, false);\n                sam_close(hdr_load);\n                return NULL;\n            }\n            sam_close(hdr_load);\n            if (header_compatible(retval->merged_input_header,\n                                  retval->unaccounted_header) != 0) {\n                cleanup_state(retval, false);\n                return NULL;\n            }\n        } else {\n            retval->unaccounted_header = sam_hdr_dup(retval->merged_input_header);\n            if (!opts->no_pg && sam_hdr_add_pg(retval->unaccounted_header, \"samtools\",\n                                               \"VN\", samtools_version(),\n                                               arg_list ? \"CL\": NULL,\n                                               arg_list ? arg_list : NULL,\n                                               NULL)) {\n                print_error(\"split\", \"Could not rewrite header for \\\"%s\\\"\", opts->unaccounted_name);\n                cleanup_state(retval, false);\n                return NULL;\n            }\n        }\n\n        char outmode[4] = \"w\";\n        sam_open_mode(outmode + 1, opts->unaccounted_name, NULL);\n        retval->unaccounted_file = sam_open_format(opts->unaccounted_name, outmode, &opts->ga.out);\n\n        if (retval->unaccounted_file == NULL) {\n            print_error_errno(\"split\", \"Could not open unaccounted output file \\\"%s\\\"\", opts->unaccounted_name);\n            cleanup_state(retval, false);\n            return NULL;\n        }\n        if (retval->p.pool)\n            hts_set_opt(retval->unaccounted_file, HTS_OPT_THREAD_POOL, &retval->p);\n    }\n\n    int is_rg = !opts->tag || strcmp(opts->tag, \"RG\") == 0;\n    if (is_rg) {\n        if (!count_RG(retval->merged_input_header,\n                      &retval->output_count, &retval->tag_vals)) {\n            cleanup_state(retval, false);\n            return NULL;\n        }\n        if (opts->verbose)\n            fprintf(stderr, \"@RG's found %zu\\n\",retval->output_count);\n    } else {\n        retval->output_count = 0;\n    }\n\n    // Prevent calloc(0, size);\n    size_t num = retval->output_count ? retval->output_count : 1;\n    retval->index_file_name = (char **)calloc(num, sizeof(char *));\n    retval->output_file_name = (char **)calloc(num, sizeof(char *));\n    retval->output_file = (samFile**)calloc(num, sizeof(samFile*));\n    retval->output_header = (sam_hdr_t**)calloc(num, sizeof(sam_hdr_t*));\n    retval->tag_val_hash = kh_init_c2i();\n    if (!retval->output_file_name || !retval->output_file || !retval->output_header ||\n        !retval->tag_val_hash || !retval->index_file_name) {\n        print_error_errno(\"split\", \"Could not initialise output file array\");\n        cleanup_state(retval, false);\n        return NULL;\n    }\n    if (!is_rg)\n        return retval;  // Done for this case - outputs will be opened later\n\n    // Adjust max_split if too small for the read-groups listed in the header\n    if (opts->max_split < retval->output_count)\n        opts->max_split = retval->output_count;\n\n    // Open output files for RGs\n    char* dirsep = strrchr(opts->merged_input_name, '/');\n    char* input_base_name = strdup(dirsep? dirsep+1 : opts->merged_input_name);\n    if (!input_base_name) {\n        print_error_errno(\"split\", \"Filename manipulation failed\");\n        cleanup_state(retval, false);\n        return NULL;\n    }\n    char* extension = strrchr(input_base_name, '.');\n    if (extension) *extension = '\\0';\n\n    size_t i;\n    for (i = 0; i < retval->output_count; i++) {\n        char* output_filename = NULL;\n        char outmode[4] = \"w\";\n\n        output_filename = expand_format_string(opts->output_format_string,\n                                               input_base_name,\n                                               retval->tag_vals[i], i,\n                                               opts->zero_pad, &opts->ga.out);\n\n        if ( output_filename == NULL ) {\n            cleanup_state(retval, false);\n            free(input_base_name);\n            return NULL;\n        }\n\n        retval->output_file_name[i] = output_filename;\n        sam_open_mode(outmode + 1, output_filename, NULL);\n        retval->output_file[i] = sam_open_format(output_filename, outmode, &opts->ga.out);\n\n        if (retval->output_file[i] == NULL) {\n            print_error_errno(\"split\", \"Could not open \\\"%s\\\"\", output_filename);\n            cleanup_state(retval, false);\n            free(input_base_name);\n            return NULL;\n        }\n        if (retval->p.pool)\n            hts_set_opt(retval->output_file[i], HTS_OPT_THREAD_POOL, &retval->p);\n\n        // Record index in hash\n        int ret;\n        khiter_t iter = kh_put_c2i(retval->tag_val_hash, retval->tag_vals[i], &ret);\n        if (ret < 0) {\n            print_error_errno(\"split\", \"Couldn't add @RG ID to look-up table\");\n            cleanup_state(retval, false);\n            free(input_base_name);\n            return NULL;\n        }\n        kh_val(retval->tag_val_hash,iter) = i;\n\n        // Set and edit header\n        retval->output_header[i] = sam_hdr_dup(retval->merged_input_header);\n        if (sam_hdr_remove_except(retval->output_header[i], \"RG\", \"ID\", retval->tag_vals[i]) ||\n            (!opts->no_pg &&\n             sam_hdr_add_pg(retval->output_header[i], \"samtools\",\n                            \"VN\", samtools_version(),\n                            arg_list ? \"CL\": NULL,\n                            arg_list ? arg_list : NULL,\n                            NULL))) {\n            print_error(\"split\", \"Could not rewrite header for \\\"%s\\\"\", output_filename);\n            cleanup_state(retval, false);\n            free(input_base_name);\n            return NULL;\n        }\n    }\n\n    free(input_base_name);\n\n    return retval;\n}\n\nstatic bool split(state_t* state, parsed_opts_t *opts, char *arg_list)\n{\n    int is_rg = !opts->tag || strcmp(opts->tag, \"RG\") == 0;\n    if (state->unaccounted_file) {\n        if (sam_hdr_write(state->unaccounted_file, state->unaccounted_header) != 0) {\n            print_error_errno(\"split\", \"Could not write output file header\");\n            return false;\n        }\n        if (opts->ga.write_index) {\n            state->unaccounted_idx_fn = auto_index(state->unaccounted_file,\n                                                   opts->unaccounted_name,\n                                                   state->unaccounted_header);\n            if (!state->unaccounted_idx_fn) {\n                print_error_errno(\"split\",\n                                  \"Creating index file for file \\\"%s\\\" failed\",\n                                  opts->unaccounted_name);\n                return false;\n            }\n        }\n    }\n    bam1_t* file_read = bam_init1();\n    // Read the first record\n    int r;\n    if ((r=sam_read1(state->merged_input_file, state->merged_input_header, file_read)) < 0) {\n        // Nothing more to read?  Ignore this file\n        bam_destroy1(file_read);\n        file_read = NULL;\n        if (r < -1) {\n            print_error(\"split\", \"Could not read first input record\");\n            return false;\n        }\n    }\n\n    if (is_rg) {\n        size_t i;\n        for (i = 0; i < state->output_count; i++) {\n            if (sam_hdr_write(state->output_file[i], state->output_header[i]) != 0) {\n                print_error_errno(\"split\", \"Could not write file header to \\\"%s\\\"\", state->output_file_name[i]);\n                goto error;\n            }\n            if (state->write_index) {\n                state->index_file_name[i] = auto_index(state->output_file[i],\n                        state->output_file_name[i],\n                        state->output_header[i]);\n                if (!state->index_file_name[i]) {\n                    print_error_errno(\"split\", \"Could not create index for file \\\"%s\\\"\", state->output_file_name[i]);\n                    goto error;\n                }\n            }\n        }\n    }\n    while (file_read != NULL) {\n        // Get RG tag from read and look it up in hash to find file to output it to\n        uint8_t* tag = bam_aux_get(file_read, is_rg ? \"RG\" : opts->tag);\n        char *val = NULL;\n        char number[28];\n        khiter_t iter;\n        if (tag) {\n            switch (*tag) {\n            case 'Z': case 'H':\n                val = bam_aux2Z(tag);\n                break;\n            case 'c': case 'C': case 's': case 'S': case 'i': case 'I':\n                if (opts->zero_pad == 0) {\n                    snprintf(number, sizeof(number), \"%\"PRId64, bam_aux2i(tag));\n                } else {\n                    int64_t v = bam_aux2i(tag);\n                    snprintf(number, sizeof(number), \"%0*\"PRId64,\n                             v < 0 ? opts->zero_pad + 1 : opts->zero_pad, v);\n                }\n                val = number;\n                break;\n            default:\n                break;\n            }\n        }\n        if ( val != NULL ) {\n            iter = kh_get_c2i(state->tag_val_hash, val);\n        } else {\n            iter = kh_end(state->tag_val_hash);\n        }\n\n        // Check for opts->tag here instead of !is_rg so we open new\n        // files if the user specified '-d RG' and we find a RG:Z: value\n        // that wasn't listed in the header.  If the '-d' option is\n        // not used, we don't open a file to preserve existing behaviour.\n        if (opts->tag && val && iter == kh_end(state->tag_val_hash)\n            && state->output_count < opts->max_split) {\n            // Need to open a new output file\n            iter = prep_sam_file(opts, state, val, arg_list, is_rg);\n            if (iter == kh_end(state->tag_val_hash)) { // Open failed\n                print_error(\"split\",\n                            \"Could not create output file for tag \\\"%s:%s\\\"\",\n                            opts->tag, bam_aux2Z(tag));\n                goto error;\n\n            }\n        }\n\n        // Write the read out to correct file\n        if (iter != kh_end(state->tag_val_hash)) {\n            // if found write to the appropriate untangled bam\n            int i = kh_val(state->tag_val_hash,iter);\n            if (sam_write1(state->output_file[i], state->output_header[i], file_read) < 0) {\n                print_error_errno(\"split\", \"Could not write to \\\"%s\\\"\", state->output_file_name[i]);\n                goto error;\n            }\n        } else {\n            // otherwise write to the unaccounted bam if there is one or fail\n            if (state->unaccounted_file == NULL) {\n                if (tag) {\n                    fprintf(stderr, \"Read \\\"%s\\\" with unaccounted for tag \\\"%s\\\".\\n\", bam_get_qname(file_read), bam_aux2Z(tag));\n                } else {\n                    fprintf(stderr, \"Read \\\"%s\\\" has no %s tag.\\n\",\n                            bam_get_qname(file_read), is_rg ? \"RG\" : opts->tag);\n                }\n                goto error;\n            } else {\n                if (sam_write1(state->unaccounted_file, state->unaccounted_header, file_read) < 0) {\n                    print_error_errno(\"split\", \"Could not write to unaccounted output file\");\n                    goto error;\n                }\n            }\n        }\n\n        // Replace written read with the next one to process\n        if ((r=sam_read1(state->merged_input_file, state->merged_input_header, file_read)) < 0) {\n            // Nothing more to read?  Ignore this file in future\n            bam_destroy1(file_read);\n            file_read = NULL;\n            if (r < -1) {\n                print_error(\"split\", \"Could not read input record\");\n                return false;\n            }\n        }\n    }\n\n    if (state->write_index) {\n        size_t i;\n        for (i = 0; i < state->output_count; i++) {\n            if (sam_idx_save(state->output_file[i]) < 0) {\n                print_error_errno(\"split\", \"writing index \\\"%s\\\" failed\",\n                                  state->index_file_name[i]);\n                return false;\n            }\n        }\n        if (state->unaccounted_file) {\n            if (sam_idx_save(state->unaccounted_file) < 0) {\n                print_error_errno(\"split\", \"writing index \\\"%s\\\" failed\",\n                                  state->unaccounted_idx_fn);\n                return false;\n            }\n        }\n    }\n\n    return true;\nerror:\n    bam_destroy1(file_read);\n    return false;\n}\n\nstatic int cleanup_state(state_t* status, bool check_close)\n{\n    int ret = 0;\n\n    if (!status) return 0;\n    if (status->unaccounted_header) sam_hdr_destroy(status->unaccounted_header);\n    if (status->unaccounted_file) {\n        if (sam_close(status->unaccounted_file) < 0 && check_close) {\n            print_error(\"split\", \"Error on closing unaccounted file\");\n            ret = -1;\n        }\n    }\n    sam_close(status->merged_input_file);\n    size_t i;\n    for (i = 0; i < status->output_count; i++) {\n        if (status->output_header && status->output_header[i])\n            sam_hdr_destroy(status->output_header[i]);\n        if (status->output_file && status->output_file[i]) {\n            if (sam_close(status->output_file[i]) < 0 && check_close) {\n                print_error(\"split\", \"Error on closing output file \\\"%s\\\"\", status->output_file_name[i]);\n                ret = -1;\n            }\n        }\n        if (status->tag_vals) free(status->tag_vals[i]);\n        if (status->output_file_name) free(status->output_file_name[i]);\n        if (status->index_file_name[i]) free(status->index_file_name[i]);\n    }\n    if (status->merged_input_header)\n        sam_hdr_destroy(status->merged_input_header);\n    free(status->output_header);\n    free(status->output_file);\n    free(status->output_file_name);\n    free(status->index_file_name);\n    free(status->unaccounted_idx_fn);\n    kh_destroy_c2i(status->tag_val_hash);\n\n    free(status->tag_vals);\n    if (status->p.pool)\n        hts_tpool_destroy(status->p.pool);\n    free(status);\n\n    return ret;\n}\n\nstatic void cleanup_opts(parsed_opts_t* opts)\n{\n    if (!opts) return;\n    sam_global_args_free(&opts->ga);\n    free(opts);\n}\n\nint main_split(int argc, char** argv)\n{\n    int ret = 1;\n    char *arg_list = NULL;\n    parsed_opts_t* opts = parse_args(argc, argv);\n    if (!opts) goto cleanup_opts;\n    if (!opts->no_pg && !(arg_list = stringify_argv(argc+1, argv-1)))\n        goto cleanup_opts;\n    state_t* status = init(opts, arg_list);\n    if (!status) goto cleanup_opts;\n\n    if (!split(status, opts, arg_list)) {\n        cleanup_state(status, false);\n        goto cleanup_opts;\n    }\n\n    ret = cleanup_state(status, true);\n\ncleanup_opts:\n    cleanup_opts(opts);\n    free(arg_list);\n\n    return ret;\n}\n"
        },
        {
          "name": "bam_stat.c",
          "type": "blob",
          "size": 13.3203125,
          "content": "/*  bam_stat.c -- flagstat subcommand.\n\n    Copyright (C) 2009, 2011, 2013-2015, 2019, 2021 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <unistd.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <getopt.h>\n\n#include \"htslib/sam.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\ntypedef struct {\n    long long n_reads[2], n_mapped[2], n_pair_all[2], n_pair_map[2], n_pair_good[2];\n    long long n_sgltn[2], n_read1[2], n_read2[2];\n    long long n_dup[2];\n    long long n_diffchr[2], n_diffhigh[2];\n    long long n_secondary[2], n_supp[2];\n    long long n_primary[2], n_pmapped[2], n_pdup[2];\n} bam_flagstat_t;\n\ninline static void flagstat_loop(bam_flagstat_t *s, bam1_core_t *c)\n{\n    int w = (c->flag & BAM_FQCFAIL)? 1 : 0;\n    ++s->n_reads[w];\n    if (c->flag & BAM_FSECONDARY ) {\n        ++s->n_secondary[w];\n    } else if (c->flag & BAM_FSUPPLEMENTARY ) {\n        ++s->n_supp[w];\n    } else {\n        ++s->n_primary[w];\n\n        if (c->flag & BAM_FPAIRED) {\n            ++s->n_pair_all[w];\n            if ((c->flag & BAM_FPROPER_PAIR) && !(c->flag & BAM_FUNMAP) ) ++s->n_pair_good[w];\n            if (c->flag & BAM_FREAD1) ++s->n_read1[w];\n            if (c->flag & BAM_FREAD2) ++s->n_read2[w];\n            if ((c->flag & BAM_FMUNMAP) && !(c->flag & BAM_FUNMAP)) ++s->n_sgltn[w];\n            if (!(c->flag & BAM_FUNMAP) && !(c->flag & BAM_FMUNMAP)) {\n                ++s->n_pair_map[w];\n                if (c->mtid != c->tid) {\n                    ++s->n_diffchr[w];\n                    if (c->qual >= 5) ++s->n_diffhigh[w];\n                }\n            }\n        }\n\n        if (!(c->flag & BAM_FUNMAP)) ++s->n_pmapped[w];\n        if (c->flag & BAM_FDUP) ++s->n_pdup[w];\n    }\n    if (!(c->flag & BAM_FUNMAP)) ++s->n_mapped[w];\n    if (c->flag & BAM_FDUP) ++s->n_dup[w];\n}\n\nbam_flagstat_t *bam_flagstat_core(samFile *fp, sam_hdr_t *h)\n{\n    bam_flagstat_t *s;\n    bam1_t *b;\n    bam1_core_t *c;\n    int ret;\n    s = (bam_flagstat_t*)calloc(1, sizeof(bam_flagstat_t));\n    b = bam_init1();\n    c = &b->core;\n    while ((ret = sam_read1(fp, h, b)) >= 0)\n        flagstat_loop(s, c);\n    bam_destroy1(b);\n    if (ret != -1) {\n        free(s);\n        return NULL;\n    }\n    return s;\n}\n\nstatic const char *percent(char *buffer, long long n, long long total)\n{\n    if (total != 0) sprintf(buffer, \"%.2f%%\", (float)n / total * 100.0);\n    else strcpy(buffer, \"N/A\");\n    return buffer;\n}\n\nstatic const char *percent_json(char *buffer, long long n, long long total)\n{\n    if (total != 0) sprintf(buffer, \"%.2f\", (float)n / total * 100.0);\n    else strcpy(buffer, \"null\");\n    return buffer;\n}\n\nstatic void usage_exit(FILE *fp, int exit_status)\n{\n    fprintf(fp, \"Usage: samtools flagstat [options] <in.bam>\\n\");\n    sam_global_opt_help(fp, \"-.---@-.\");\n    fprintf(fp, \"  -O, --\");\n    fprintf(fp, \"output-fmt FORMAT[,OPT[=VAL]]...\\n\"\n            \"               Specify output format (json, tsv)\\n\");\n    exit(exit_status);\n}\n\nstatic void out_fmt_default(bam_flagstat_t *s)\n{\n    char b0[16], b1[16];\n    printf(\"%lld + %lld in total (QC-passed reads + QC-failed reads)\\n\", s->n_reads[0], s->n_reads[1]);\n    printf(\"%lld + %lld primary\\n\", s->n_primary[0], s->n_primary[1]);\n    printf(\"%lld + %lld secondary\\n\", s->n_secondary[0], s->n_secondary[1]);\n    printf(\"%lld + %lld supplementary\\n\", s->n_supp[0], s->n_supp[1]);\n    printf(\"%lld + %lld duplicates\\n\", s->n_dup[0], s->n_dup[1]);\n    printf(\"%lld + %lld primary duplicates\\n\", s->n_pdup[0], s->n_pdup[1]);\n    printf(\"%lld + %lld mapped (%s : %s)\\n\", s->n_mapped[0], s->n_mapped[1], percent(b0, s->n_mapped[0], s->n_reads[0]), percent(b1, s->n_mapped[1], s->n_reads[1]));\n    printf(\"%lld + %lld primary mapped (%s : %s)\\n\", s->n_pmapped[0], s->n_pmapped[1], percent(b0, s->n_pmapped[0], s->n_primary[0]), percent(b1, s->n_pmapped[1], s->n_primary[1]));\n    printf(\"%lld + %lld paired in sequencing\\n\", s->n_pair_all[0], s->n_pair_all[1]);\n    printf(\"%lld + %lld read1\\n\", s->n_read1[0], s->n_read1[1]);\n    printf(\"%lld + %lld read2\\n\", s->n_read2[0], s->n_read2[1]);\n    printf(\"%lld + %lld properly paired (%s : %s)\\n\", s->n_pair_good[0], s->n_pair_good[1], percent(b0, s->n_pair_good[0], s->n_pair_all[0]), percent(b1, s->n_pair_good[1], s->n_pair_all[1]));\n    printf(\"%lld + %lld with itself and mate mapped\\n\", s->n_pair_map[0], s->n_pair_map[1]);\n    printf(\"%lld + %lld singletons (%s : %s)\\n\", s->n_sgltn[0], s->n_sgltn[1], percent(b0, s->n_sgltn[0], s->n_pair_all[0]), percent(b1, s->n_sgltn[1], s->n_pair_all[1]));\n    printf(\"%lld + %lld with mate mapped to a different chr\\n\", s->n_diffchr[0], s->n_diffchr[1]);\n    printf(\"%lld + %lld with mate mapped to a different chr (mapQ>=5)\\n\", s->n_diffhigh[0], s->n_diffhigh[1]);\n}\n\nstatic void out_fmt_json(bam_flagstat_t *s) {\n    char b0[16], b1[16], p0[16], p1[16], pp0[16], pp1[16], s0[16], s1[16];\n    printf(\"{\\n \\\"QC-passed reads\\\": { \\n\"\n                 \"  \\\"total\\\": %lld, \\n\"\n                 \"  \\\"primary\\\": %lld, \\n\"\n                 \"  \\\"secondary\\\": %lld, \\n\"\n                 \"  \\\"supplementary\\\": %lld, \\n\"\n                 \"  \\\"duplicates\\\": %lld, \\n\"\n                 \"  \\\"primary duplicates\\\": %lld, \\n\"\n                 \"  \\\"mapped\\\": %lld, \\n\"\n                 \"  \\\"mapped %%\\\": %s, \\n\"\n                 \"  \\\"primary mapped\\\": %lld, \\n\"\n                 \"  \\\"primary mapped %%\\\": %s, \\n\"\n                 \"  \\\"paired in sequencing\\\": %lld, \\n\"\n                 \"  \\\"read1\\\": %lld, \\n\"\n                 \"  \\\"read2\\\": %lld, \\n\"\n                 \"  \\\"properly paired\\\": %lld, \\n\"\n                 \"  \\\"properly paired %%\\\": %s, \\n\"\n                 \"  \\\"with itself and mate mapped\\\": %lld, \\n\"\n                 \"  \\\"singletons\\\": %lld, \\n\"\n                 \"  \\\"singletons %%\\\": %s, \\n\"\n                 \"  \\\"with mate mapped to a different chr\\\": %lld, \\n\"\n                 \"  \\\"with mate mapped to a different chr (mapQ >= 5)\\\": %lld \\n\"\n                 \" },\"\n            \"\\n \\\"QC-failed reads\\\": { \\n\"\n                 \"  \\\"total\\\": %lld, \\n\"\n                 \"  \\\"primary\\\": %lld, \\n\"\n                 \"  \\\"secondary\\\": %lld, \\n\"\n                 \"  \\\"supplementary\\\": %lld, \\n\"\n                 \"  \\\"duplicates\\\": %lld, \\n\"\n                 \"  \\\"primary duplicates\\\": %lld, \\n\"\n                 \"  \\\"mapped\\\": %lld, \\n\"\n                 \"  \\\"mapped %%\\\": %s, \\n\"\n                 \"  \\\"primary mapped\\\": %lld, \\n\"\n                 \"  \\\"primary mapped %%\\\": %s, \\n\"\n                 \"  \\\"paired in sequencing\\\": %lld, \\n\"\n                 \"  \\\"read1\\\": %lld, \\n\"\n                 \"  \\\"read2\\\": %lld, \\n\"\n                 \"  \\\"properly paired\\\": %lld, \\n\"\n                 \"  \\\"properly paired %%\\\": %s, \\n\"\n                 \"  \\\"with itself and mate mapped\\\": %lld, \\n\"\n                 \"  \\\"singletons\\\": %lld, \\n\"\n                 \"  \\\"singletons %%\\\": %s, \\n\"\n                 \"  \\\"with mate mapped to a different chr\\\": %lld, \\n\"\n                 \"  \\\"with mate mapped to a different chr (mapQ >= 5)\\\": %lld \\n\"\n                 \" }\\n\"\n            \"}\\n\",\n        s->n_reads[0],\n        s->n_primary[0],\n        s->n_secondary[0],\n        s->n_supp[0],\n        s->n_dup[0],\n        s->n_pdup[0],\n        s->n_mapped[0],\n        percent_json(b0, s->n_mapped[0], s->n_reads[0]),\n        s->n_pmapped[0],\n        percent_json(p0, s->n_pmapped[0], s->n_primary[0]),\n        s->n_pair_all[0],\n        s->n_read1[0],\n        s->n_read2[0],\n        s->n_pair_good[0],\n        percent_json(pp0, s->n_pair_good[0], s->n_pair_all[0]),\n        s->n_pair_map[0],\n        s->n_sgltn[0],\n        percent_json(s0, s->n_sgltn[0], s->n_pair_all[0]),\n        s->n_diffchr[0],\n        s->n_diffhigh[0],\n        s->n_reads[1],\n        s->n_primary[1],\n        s->n_secondary[1],\n        s->n_supp[1],\n        s->n_dup[1],\n        s->n_pdup[1],\n        s->n_mapped[1],\n        percent_json(b1, s->n_mapped[1], s->n_reads[1]),\n        s->n_pmapped[1],\n        percent_json(p1, s->n_pmapped[1], s->n_primary[1]),\n        s->n_pair_all[1],\n        s->n_read1[1],\n        s->n_read2[1],\n        s->n_pair_good[1],\n        percent_json(pp1, s->n_pair_good[1], s->n_pair_all[1]),\n        s->n_pair_map[1],\n        s->n_sgltn[1],\n        percent_json(s1, s->n_sgltn[1], s->n_pair_all[1]),\n        s->n_diffchr[1],\n        s->n_diffhigh[1]\n    );\n}\n\nstatic void out_fmt_tsv(bam_flagstat_t *s) {\n    char b0[16], b1[16];\n    printf(\"%lld\\t%lld\\ttotal (QC-passed reads + QC-failed reads)\\n\", s->n_reads[0], s->n_reads[1]);\n    printf(\"%lld\\t%lld\\tprimary\\n\", s->n_primary[0], s->n_primary[1]);\n    printf(\"%lld\\t%lld\\tsecondary\\n\", s->n_secondary[0], s->n_secondary[1]);\n    printf(\"%lld\\t%lld\\tsupplementary\\n\", s->n_supp[0], s->n_supp[1]);\n    printf(\"%lld\\t%lld\\tduplicates\\n\", s->n_dup[0], s->n_dup[1]);\n    printf(\"%lld\\t%lld\\tprimary duplicates\\n\", s->n_pdup[0], s->n_pdup[1]);\n    printf(\"%lld\\t%lld\\tmapped\\n\", s->n_mapped[0], s->n_mapped[1]);\n    printf(\"%s\\t%s\\tmapped %%\\n\", percent(b0, s->n_mapped[0], s->n_reads[0]), percent(b1, s->n_mapped[1], s->n_reads[1]));\n    printf(\"%lld\\t%lld\\tprimary mapped\\n\", s->n_pmapped[0], s->n_pmapped[1]);\n    printf(\"%s\\t%s\\tprimary mapped %%\\n\", percent(b0, s->n_pmapped[0], s->n_primary[0]), percent(b1, s->n_pmapped[1], s->n_primary[1]));\n    printf(\"%lld\\t%lld\\tpaired in sequencing\\n\", s->n_pair_all[0], s->n_pair_all[1]);\n    printf(\"%lld\\t%lld\\tread1\\n\", s->n_read1[0], s->n_read1[1]);\n    printf(\"%lld\\t%lld\\tread2\\n\", s->n_read2[0], s->n_read2[1]);\n    printf(\"%lld\\t%lld\\tproperly paired\\n\", s->n_pair_good[0], s->n_pair_good[1]);\n    printf(\"%s\\t%s\\tproperly paired %%\\n\", percent(b0, s->n_pair_good[0], s->n_pair_all[0]), percent(b1, s->n_pair_good[1], s->n_pair_all[1]));\n    printf(\"%lld\\t%lld\\twith itself and mate mapped\\n\", s->n_pair_map[0], s->n_pair_map[1]);\n    printf(\"%lld\\t%lld\\tsingletons\\n\", s->n_sgltn[0], s->n_sgltn[1]);\n    printf(\"%s\\t%s\\tsingletons %%\\n\", percent(b0, s->n_sgltn[0], s->n_pair_all[0]), percent(b1, s->n_sgltn[1], s->n_pair_all[1]));\n    printf(\"%lld\\t%lld\\twith mate mapped to a different chr\\n\", s->n_diffchr[0], s->n_diffchr[1]);\n    printf(\"%lld\\t%lld\\twith mate mapped to a different chr (mapQ>=5)\\n\", s->n_diffhigh[0], s->n_diffhigh[1]);\n}\n\n/*\n * Select flagstats output format to print.\n */\nstatic void output_fmt(bam_flagstat_t *s, const char *out_fmt)\n{\n  if (strcmp(out_fmt, \"json\") == 0 || strcmp(out_fmt, \"JSON\") == 0) {\n    out_fmt_json(s);\n  } else if (strcmp(out_fmt, \"tsv\") == 0 || strcmp(out_fmt, \"TSV\") == 0) {\n    out_fmt_tsv(s);\n  } else {\n    out_fmt_default(s);\n  }\n}\n\nint bam_flagstat(int argc, char *argv[])\n{\n    samFile *fp;\n    sam_hdr_t *header;\n    bam_flagstat_t *s;\n    const char *out_fmt = \"default\";\n    int c, status = EXIT_SUCCESS;\n\n    enum {\n        INPUT_FMT_OPTION = CHAR_MAX+1,\n    };\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', '-', '-', '@'),\n        {NULL, 0, NULL, 0}\n    };\n\n    while ((c = getopt_long(argc, argv, \"@:O:\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'O':\n          out_fmt = optarg;\n          break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?':\n            usage_exit(stderr, EXIT_FAILURE);\n        }\n    }\n\n    if (argc != optind+1) {\n        if (argc == optind) usage_exit(stdout, EXIT_SUCCESS);\n        else usage_exit(stderr, EXIT_FAILURE);\n    }\n    fp = sam_open_format(argv[optind], \"r\", &ga.in);\n    if (fp == NULL) {\n        print_error_errno(\"flagstat\", \"Cannot open input file \\\"%s\\\"\", argv[optind]);\n        return 1;\n    }\n    if (ga.nthreads > 0)\n        hts_set_threads(fp, ga.nthreads);\n\n    if (hts_set_opt(fp, CRAM_OPT_REQUIRED_FIELDS,\n                    SAM_FLAG | SAM_MAPQ | SAM_RNEXT)) {\n        fprintf(stderr, \"Failed to set CRAM_OPT_REQUIRED_FIELDS value\\n\");\n        return 1;\n    }\n\n    if (hts_set_opt(fp, CRAM_OPT_DECODE_MD, 0)) {\n        fprintf(stderr, \"Failed to set CRAM_OPT_DECODE_MD value\\n\");\n        return 1;\n    }\n\n    header = sam_hdr_read(fp);\n    if (header == NULL) {\n        fprintf(stderr, \"Failed to read header for \\\"%s\\\"\\n\", argv[optind]);\n        return 1;\n    }\n\n    s = bam_flagstat_core(fp, header);\n    if (s) {\n        output_fmt(s, out_fmt);\n        free(s);\n    }\n    else {\n        print_error(\"flagstat\", \"error reading from \\\"%s\\\"\", argv[optind]);\n        status = EXIT_FAILURE;\n    }\n\n    sam_hdr_destroy(header);\n    sam_close(fp);\n    sam_global_args_free(&ga);\n    return status;\n}\n"
        },
        {
          "name": "bam_tview.c",
          "type": "blob",
          "size": 19.5419921875,
          "content": "/*  bam_tview.c -- tview subcommand.\n\n    Copyright (C) 2008-2016, 2019-2020 Genome Research Ltd.\n    Portions copyright (C) 2013 Pierre Lindenbaum, Institut du Thorax, INSERM U1087, Université de Nantes.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <regex.h>\n#include <assert.h>\n#include \"bam_tview.h\"\n#include <htslib/faidx.h>\n#include <htslib/sam.h>\n#include <htslib/bgzf.h>\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\n// Threshold where spacing of numbers on the scale line changes from 10 to 20\n// to stop them running into each other.\n#define TEN_DIGITS 1000000000\n\nstatic void destroy_rg_hash(khash_t(kh_rg)* rg_hash)\n{\n    khiter_t k;\n\n    if (!rg_hash)\n        return;\n\n    for (k = 0; k < kh_end(rg_hash); k++) {\n        if (kh_exist(rg_hash, k))\n            free((char *) kh_key(rg_hash, k));\n    }\n    kh_destroy(kh_rg, rg_hash);\n}\n\nstatic\nkhash_t(kh_rg)* get_rg_sample(sam_hdr_t* header, const char* sample)\n{\n    int n_rg, i;\n    kstring_t id_val = KS_INITIALIZE, sm_val = KS_INITIALIZE;\n    khash_t(kh_rg)* rg_hash = kh_init(kh_rg);\n    if (!rg_hash) return NULL;\n\n    // There may be more than one @RG with a given SM:, so iterate through them\n    n_rg = sam_hdr_count_lines(header, \"RG\");\n    if (n_rg < 0) {\n        print_error(\"tview\", \"couldn't parse header\");\n        goto fail;\n    }\n\n    for (i = 0; i < n_rg; i++) {\n        // Try ID: first\n        int r = sam_hdr_find_tag_pos(header, \"RG\", i, \"ID\", &id_val);\n        if (r < -1) goto memfail;\n        if (r == -1) continue;  // Shouldn't happen as ID is compulsory\n\n        if (strcmp(sample, id_val.s) != 0) {\n            // No match, try SM:\n            r = sam_hdr_find_tag_pos(header, \"RG\", i, \"SM\", &sm_val);\n            if (r < -1) goto memfail;\n            if (r < 0 || strcmp(sample, sm_val.s) != 0)\n                continue;\n        }\n\n        // Found a match, add ID to rg_hash\n        kh_put(kh_rg, rg_hash, id_val.s, &r);\n        if (r < 0) goto memfail;\n        ks_release(&id_val); // Now owned by hash table\n    }\n\n    ks_free(&id_val);\n    ks_free(&sm_val);\n    return rg_hash;\n\n memfail:\n    perror(\"tview\");\n fail:\n    ks_free(&id_val);\n    ks_free(&sm_val);\n    destroy_rg_hash(rg_hash);\n    return NULL;\n}\n\nint base_tv_init(tview_t* tv, const char *fn, const char *fn_fa, const char *fn_idx,\n                 const char *samples, const htsFormat *fmt)\n{\n    assert(tv!=NULL);\n    assert(fn!=NULL);\n    tv->mrow = 24; tv->mcol = 80;\n    tv->color_for = TV_COLOR_MAPQ;\n    tv->is_dot = 1;\n\n    tv->fp = sam_open_format(fn, \"r\", fmt);\n    if(tv->fp == NULL)\n    {\n        print_error_errno(\"tview\", \"can't open \\\"%s\\\"\", fn);\n        exit(EXIT_FAILURE);\n    }\n    // TODO bgzf_set_cache_size(tv->fp->fp.bgzf, 8 * 1024 *1024);\n    assert(tv->fp);\n\n    tv->header = sam_hdr_read(tv->fp);\n    if(tv->header == NULL)\n    {\n        print_error(\"tview\", \"cannot read \\\"%s\\\"\", fn);\n        exit(EXIT_FAILURE);\n    }\n    // If index filename has not been specfied, look in BAM folder\n    if (fn_idx != NULL) {\n        tv->idx = sam_index_load2(tv->fp, fn, fn_idx);\n    } else {\n        tv->idx = sam_index_load(tv->fp, fn);\n    }\n\n    if (tv->idx == NULL)\n    {\n        print_error(\"tview\", \"cannot read index for \\\"%s\\\"\", fn);\n        exit(EXIT_FAILURE);\n    }\n    tv->lplbuf = bam_lplbuf_init(tv_pl_func, tv);\n    if (fn_fa) tv->fai = fai_load(fn_fa);\n    tv->bca = bcf_call_init(0.83, 13);\n    tv->ins = 1;\n\n    // If the user has asked for specific samples find out create a list of readgroups make up these samples\n    if ( samples )\n    {\n        tv->rg_hash = get_rg_sample(tv->header, samples); // Init the list of rg's\n        if (kh_size(tv->rg_hash) == 0) {\n            print_error(\"tview\",\n                        \"The sample or read group \\\"%s\\\" not present.\",\n                        samples);\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    return 0;\n}\n\n\nvoid base_tv_destroy(tview_t* tv)\n{\n    bam_lplbuf_destroy(tv->lplbuf);\n    bcf_call_destroy(tv->bca);\n    hts_idx_destroy(tv->idx);\n    if (tv->fai) fai_destroy(tv->fai);\n    free(tv->ref);\n    sam_hdr_destroy(tv->header);\n    destroy_rg_hash(tv->rg_hash);\n    sam_close(tv->fp);\n}\n\n\nint tv_pl_func(uint32_t tid, hts_pos_t pos, int n, const bam_pileup1_t *pl, void *data)\n{\n    tview_t *tv = (tview_t*)data;\n    hts_pos_t cp;\n    int i, j, c, rb, attr, max_ins = 0, interval;\n    uint32_t call = 0;\n    kstring_t ks = KS_INITIALIZE;\n    if (pos < tv->left_pos || tv->ccol > tv->mcol) return 0; // out of screen\n    // print reference\n    rb = (tv->ref && pos - tv->left_pos < tv->l_ref)? tv->ref[pos - tv->left_pos] : 'N';\n    for (cp = tv->last_pos + 1; cp < pos; ++cp) {\n        interval = cp < TEN_DIGITS ? 10 : 20;\n        if (cp%interval == 0 && tv->mcol - tv->ccol >= 10) tv->my_mvprintw(tv,0, tv->ccol, \"%-\"PRIhts_pos, cp+1);\n        c = tv->ref? tv->ref[cp - tv->left_pos] : 'N';\n        tv->my_mvaddch(tv,1, tv->ccol++, c);\n    }\n    interval = pos < TEN_DIGITS ? 10 : 20;\n    if (pos%interval == 0 && tv->mcol - tv->ccol >= 10) tv->my_mvprintw(tv,0, tv->ccol, \"%-\"PRIhts_pos, pos+1);\n    { // call consensus\n        bcf_callret1_t bcr;\n        memset(&bcr, 0, sizeof bcr);\n        int qsum[4], a1, a2, tmp;\n        double p[3], prior = 30;\n        bcf_call_glfgen(n, pl, seq_nt16_table[rb], tv->bca, &bcr);\n        for (i = 0; i < 4; ++i) qsum[i] = ((int)bcr.qsum[i])<<2 | i;\n        for (i = 1; i < 4; ++i) // insertion sort\n            for (j = i; j > 0 && qsum[j] > qsum[j-1]; --j)\n                tmp = qsum[j], qsum[j] = qsum[j-1], qsum[j-1] = tmp;\n        a1 = qsum[0]&3; a2 = qsum[1]&3;\n        p[0] = bcr.p[a1*5+a1]; p[1] = bcr.p[a1*5+a2] + prior; p[2] = bcr.p[a2*5+a2];\n        if (\"ACGT\"[a1] != toupper(rb)) p[0] += prior + 3;\n        if (\"ACGT\"[a2] != toupper(rb)) p[2] += prior + 3;\n        if (p[0] < p[1] && p[0] < p[2]) call = (1<<a1)<<16 | (int)((p[1]<p[2]?p[1]:p[2]) - p[0] + .499);\n        else if (p[2] < p[1] && p[2] < p[0]) call = (1<<a2)<<16 | (int)((p[0]<p[1]?p[0]:p[1]) - p[2] + .499);\n        else call = (1<<a1|1<<a2)<<16 | (int)((p[0]<p[2]?p[0]:p[2]) - p[1] + .499);\n    }\n    attr = tv->my_underline(tv);\n    c = \",ACMGRSVTWYHKDBN\"[call>>16&0xf];\n    i = (call&0xffff)/10+1;\n    if (i > 4) i = 4;\n    attr |= tv->my_colorpair(tv,i);\n    if (c == toupper(rb)) c = '.';\n    tv->my_attron(tv,attr);\n    tv->my_mvaddch(tv,2, tv->ccol, c);\n    tv->my_attroff(tv,attr);\n    if(tv->ins) {\n        // calculate maximum insert\n        for (i = 0; i < n; ++i) {\n            const bam_pileup1_t *p = pl + i;\n            int len = bam_plp_insertion(p, &ks, NULL);\n            if (len < 0) {\n                print_error(\"tview\", \"Memory allocation failure.\");\n                exit(1);\n            }\n            if (max_ins < len) max_ins = len;\n        }\n    }\n    // core loop\n    for (j = 0; j <= max_ins; ++j) {\n        for (i = 0; i < n; ++i) {\n            const bam_pileup1_t *p = pl + i;\n            int row = TV_MIN_ALNROW + p->level - tv->row_shift;\n            if (j == 0) {\n                if (!p->is_del) {\n                    if (tv->base_for == TV_BASE_COLOR_SPACE &&\n                            (c = bam_aux_getCSi(p->b, p->qpos))) {\n                        // assume that if we found one color, we will be able to get the color error\n                        if (tv->is_dot && '-' == bam_aux_getCEi(p->b, p->qpos)) c = bam_is_rev(p->b)? ',' : '.';\n                    } else {\n                        if (tv->show_name) {\n                            char *name = bam_get_qname(p->b);\n                            c = (p->qpos + 1 >= p->b->core.l_qname)? ' ' : name[p->qpos];\n                       } else {\n                            c = p->qpos < p->b->core.l_qseq\n                                ? seq_nt16_str[bam_seqi(bam_get_seq(p->b), p->qpos)]\n                                : 'N';\n                            if (tv->is_dot && toupper(c) == toupper(rb)) c = bam_is_rev(p->b)? ',' : '.';\n                        }\n                    }\n                } else c = p->is_refskip? (bam_is_rev(p->b)? '<' : '>') : '*';\n            } else { // padding\n                int len = bam_plp_insertion(p, &ks, NULL);\n                if (len < 0) {\n                    print_error(\"tview\", \"Memory allocation failure.\");\n                    exit(1);\n                }\n\n                if (j > len) c = '*';\n                else { // insertion\n                    if (tv->base_for ==  TV_BASE_NUCL) {\n                        if (tv->show_name) {\n                            char *name = bam_get_qname(p->b);\n                            c = (p->qpos + j + 1 >= p->b->core.l_qname)? ' ' : name[p->qpos + j];\n                        } else {\n                            c = ks.s[j-1];\n                            if (j == 0 && tv->is_dot && toupper(c) == toupper(rb)) c = bam_is_rev(p->b)? ',' : '.';\n                        }\n                    } else {\n                        c = bam_aux_getCSi(p->b, p->qpos + j);\n                        if (tv->is_dot && '-' == bam_aux_getCEi(p->b, p->qpos + j)) c = bam_is_rev(p->b)? ',' : '.';\n                    }\n                }\n            }\n            if (row > TV_MIN_ALNROW && row < tv->mrow) {\n                int x;\n                attr = 0;\n                if (((p->b->core.flag&BAM_FPAIRED) && !(p->b->core.flag&BAM_FPROPER_PAIR))\n                        || (p->b->core.flag & BAM_FSECONDARY)) attr |= tv->my_underline(tv);\n                if (tv->color_for == TV_COLOR_BASEQ) {\n                    x = bam_get_qual(p->b)[p->qpos]/10 + 1;\n                    if (x > 4) x = 4;\n                    attr |= tv->my_colorpair(tv,x);\n                } else if (tv->color_for == TV_COLOR_MAPQ) {\n                    x = p->b->core.qual/10 + 1;\n                    if (x > 4) x = 4;\n                    attr |= tv->my_colorpair(tv,x);\n                } else if (tv->color_for == TV_COLOR_NUCL) {\n                    x = p->qpos < p->b->core.l_qseq\n                        ? seq_nt16_int[bam_seqi(bam_get_seq(p->b), p->qpos)] + 5\n                        : 4;\n                    attr |= tv->my_colorpair(tv,x);\n                } else if(tv->color_for == TV_COLOR_COL) {\n                    x = 0;\n                    switch(bam_aux_getCSi(p->b, p->qpos)) {\n                        case '0': x = 0; break;\n                        case '1': x = 1; break;\n                        case '2': x = 2; break;\n                        case '3': x = 3; break;\n                        case '4': x = 4; break;\n                        default: x = seq_nt16_int[bam_seqi(bam_get_seq(p->b), p->qpos)]; break;\n                    }\n                    x+=5;\n                    attr |= tv->my_colorpair(tv,x);\n                } else if(tv->color_for == TV_COLOR_COLQ) {\n                    x = bam_aux_getCQi(p->b, p->qpos);\n                    if(0 == x) x = bam_get_qual(p->b)[p->qpos];\n                    x = x/10 + 1;\n                    if (x > 4) x = 4;\n                    attr |= tv->my_colorpair(tv,x);\n                }\n                tv->my_attron(tv,attr);\n                tv->my_mvaddch(tv,row, tv->ccol, bam_is_rev(p->b)? tolower(c) : toupper(c));\n                tv->my_attroff(tv,attr);\n            }\n        }\n        c = j? '*' : rb;\n        if (c == '*') {\n            attr = tv->my_colorpair(tv,8);\n            tv->my_attron(tv,attr);\n            tv->my_mvaddch(tv,1, tv->ccol++, c);\n            tv->my_attroff(tv,attr);\n        } else tv->my_mvaddch(tv,1, tv->ccol++, c);\n    }\n    tv->last_pos = pos;\n    ks_free(&ks);\n    return 0;\n}\n\n\n\n\nstatic int tv_push_aln(const bam1_t *b, tview_t *tv)\n{\n    /* If we are restricted to specific readgroups check RG is in the list */\n    if ( tv->rg_hash )\n    {\n        const uint8_t *rg = bam_aux_get(b, \"RG\");\n        if ( !rg ) return 0; // If we don't have an RG tag exclude read\n        khiter_t k = kh_get(kh_rg, tv->rg_hash, (const char*)(rg + 1));\n        if ( k == kh_end(tv->rg_hash) ) return 0; // if RG tag is not in list of allowed tags exclude read\n    }\n    if (tv->no_skip) {\n        uint32_t *cigar = bam_get_cigar(b); // this is cheating...\n        int i;\n        for (i = 0; i <b->core.n_cigar; ++i) {\n            if ((cigar[i]&0xf) == BAM_CREF_SKIP)\n                cigar[i] = cigar[i]>>4<<4 | BAM_CDEL;\n        }\n    }\n    bam_lplbuf_push(b, tv->lplbuf);\n    return 0;\n}\n\nint base_draw_aln(tview_t *tv, int tid, hts_pos_t pos)\n{\n    int ret;\n    assert(tv!=NULL);\n    // reset\n    tv->my_clear(tv);\n    tv->curr_tid = tid; tv->left_pos = pos;\n    tv->last_pos = tv->left_pos - 1;\n    tv->ccol = 0;\n    // print ref and consensus\n    if (tv->fai) {\n        if (tv->ref) free(tv->ref);\n        assert(tv->curr_tid>=0);\n\n        const char *ref_name = sam_hdr_tid2name(tv->header, tv->curr_tid);\n        tv->ref = faidx_fetch_seq64(tv->fai, ref_name, tv->left_pos, tv->left_pos + tv->mcol - 1, &tv->l_ref);\n        if ( !tv->ref )\n        {\n            fprintf(stderr,\"Could not read the reference sequence. Is it seekable (plain text or compressed + .gzi indexed with bgzip)?\\n\");\n            exit(1);\n        }\n    }\n    // draw aln\n    bam_lplbuf_reset(tv->lplbuf);\n    hts_itr_t *iter = sam_itr_queryi(tv->idx, tv->curr_tid, tv->left_pos, tv->left_pos + tv->mcol);\n    bam1_t *b = bam_init1();\n    while ((ret = sam_itr_next(tv->fp, iter, b)) >= 0) tv_push_aln(b, tv);\n    bam_destroy1(b);\n    hts_itr_destroy(iter);\n    if (ret < -1) {\n        print_error(\"tview\", \"could not read from input file\");\n        exit(1);\n    }\n\n    bam_lplbuf_push(0, tv->lplbuf);\n\n    while (tv->ccol < tv->mcol) {\n        hts_pos_t pos = tv->last_pos + 1;\n        int interval = pos < TEN_DIGITS ? 10 : 20;\n        if (pos%interval == 0 && tv->mcol - tv->ccol >= 10) tv->my_mvprintw(tv,0, tv->ccol, \"%-\"PRIhts_pos, pos+1);\n        tv->my_mvaddch(tv,1, tv->ccol++, (tv->ref && pos - tv->left_pos < tv->l_ref)? tv->ref[pos - tv->left_pos] : 'N');\n        ++tv->last_pos;\n    }\n    return 0;\n}\n\n\n\n\nstatic void HTS_FORMAT(HTS_PRINTF_FMT, 1, 2) error(const char *format, ...)\n{\n    if ( !format )\n    {\n        fprintf(stderr,\n\"Usage: samtools tview [options] <aln.bam> [ref.fasta]\\n\"\n\"Options:\\n\"\n\"   -d display      output as (H)tml or (C)urses or (T)ext \\n\"\n\"   -X              include customized index file\\n\"\n\"   -p chr:pos      go directly to this position\\n\"\n\"   -s STR          display only reads from this sample or group\\n\"\n\"   -w INT          display width (with -d T only)\\n\"\n\"   -i              hide inserts\\n\");\n        sam_global_opt_help(stderr, \"-.--.--.\");\n    }\n    else\n    {\n        va_list ap;\n        va_start(ap, format);\n        vfprintf(stderr, format, ap);\n        va_end(ap);\n    }\n    exit(-1);\n}\n\nenum dipsay_mode {display_ncurses,display_html,display_text};\nextern tview_t* curses_tv_init(const char *fn, const char *fn_fa,\n                               const char *samples, const htsFormat *fmt);\nextern tview_t* html_tv_init(const char *fn, const char *fn_fa, const char *fn_idx,\n                             const char *samples, const htsFormat *fmt);\nextern tview_t* text_tv_init(const char *fn, const char *fn_fa, const char *fn_idx,\n                             const char *samples, const htsFormat *fmt);\n\nint bam_tview_main(int argc, char *argv[])\n{\n    int view_mode=display_ncurses, display_width = 0;\n    tview_t* tv=NULL;\n    char *samples=NULL, *position=NULL, *ref, *fn_idx=NULL;\n    int show_inserts = 1;\n    int c, has_index_file = 0, ref_index = 0;\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 0, '-'),\n        { NULL, 0, NULL, 0 }\n    };\n\n    char *tmp;\n    while ((c = getopt_long(argc, argv, \"s:p:d:Xw:i\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'w':\n                display_width = strtol(optarg,&tmp,10);\n                if ( tmp==optarg || *tmp || display_width<1 ) error(\"Could not parse: -w %s\\n\",optarg);\n                break;\n            case 's': samples=optarg; break;\n            case 'p': position=optarg; break;\n            case 'X': has_index_file=1; break; // -X flag for index filename\n            case 'i': show_inserts=0; break;\n            case 'd':\n            {\n                switch(optarg[0])\n                {\n                    case 'H': case 'h': view_mode=display_html;break;\n                    case 'T': case 't': view_mode=display_text;break;\n                    case 'C': case 'c': view_mode=display_ncurses;break;\n                    default: view_mode=display_ncurses;break;\n                }\n                break;\n            }\n            default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                      /* else fall-through */\n            case '?': error(NULL);\n        }\n    }\n    if (argc==optind) error(NULL);\n    if (display_width && view_mode == display_ncurses)\n        error(\"The -w option is currently supported only with -d T and -d H\\n\");\n\n    ref = NULL;\n    ref_index = optind;\n    if (!has_index_file) {\n        ref = (optind+1>=argc)? ga.reference : argv[optind+1];\n    }\n    else {\n        ref = (optind+2>=argc)? ga.reference : argv[optind+2];\n        if (optind+1 >= argc) {\n            fprintf(stderr, \"Incorrect number of arguments provided! Aborting...\\n\");\n            return 1;\n        }\n        fn_idx = argv[optind+1];\n        ref_index = optind+1;\n    }\n\n    switch(view_mode)\n    {\n        case display_ncurses:\n            tv = curses_tv_init(argv[ref_index], ref, samples, &ga.in);\n            break;\n\n        case display_text:\n            tv = text_tv_init(argv[ref_index], ref, fn_idx, samples, &ga.in);\n            if ( display_width ) tv->mcol = display_width;\n            break;\n\n        case display_html:\n            tv = html_tv_init(argv[ref_index], ref, fn_idx, samples, &ga.in);\n            if ( display_width ) tv->mcol = display_width;\n            break;\n    }\n    if (tv==NULL)\n    {\n        error(\"cannot create view\");\n        return EXIT_FAILURE;\n    }\n\n    tv->ins = show_inserts;\n    if ( position )\n    {\n        int tid;\n        hts_pos_t beg, end;\n        if (!sam_parse_region(tv->header, position, &tid, &beg, &end, 0)) {\n            tv->my_destroy(tv);\n            fprintf(stderr, \"Unknown reference or malformed region\\n\");\n            exit(EXIT_FAILURE);\n        }\n        tv->curr_tid = tid;\n        tv->left_pos = beg;\n    }\n    else if ( tv->fai )\n    {\n        // find the first sequence present in both BAM and the reference file\n        int i;\n        for (i=0; i < sam_hdr_nref(tv->header); i++)\n        {\n            if ( faidx_has_seq(tv->fai, sam_hdr_tid2name(tv->header, i)) ) break;\n        }\n        if ( i==sam_hdr_nref(tv->header) )\n        {\n            tv->my_destroy(tv);\n            fprintf(stderr,\"None of the BAM sequence names present in the fasta file\\n\");\n            exit(EXIT_FAILURE);\n        }\n        tv->curr_tid = i;\n    }\n    tv->my_drawaln(tv, tv->curr_tid, tv->left_pos);\n    tv->my_loop(tv);\n    tv->my_destroy(tv);\n\n    return EXIT_SUCCESS;\n}\n"
        },
        {
          "name": "bam_tview.h",
          "type": "blob",
          "size": 3.451171875,
          "content": "/*  bam_tview.h -- tview subcommand.\n\n    Copyright (C) 2008, 2013, 2019 Genome Research Ltd.\n    Portions copyright (C) 2013 Pierre Lindenbaum, Institut du Thorax, INSERM U1087, Université de Nantes.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BAM_TVIEW_H\n#define BAM_TVIEW_H\n\n#include <ctype.h>\n#include <string.h>\n#include <math.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <htslib/sam.h>\n#include \"bam2bcf.h\"\n#include <htslib/khash.h>\n#include <htslib/hts.h>\n#include <htslib/faidx.h>\n#include \"bam_lpileup.h\"\n\n\nKHASH_MAP_INIT_STR(kh_rg, const char *)\n\n/* Holds state of Tview */\ntypedef struct AbstractTview {\n    int mrow, mcol;\n\n    hts_idx_t* idx;\n    bam_lplbuf_t* lplbuf;\n    sam_hdr_t* header;\n    samFile* fp;\n    faidx_t* fai;\n    bcf_callaux_t* bca;\n\n    hts_pos_t left_pos, last_pos, l_ref;\n    int curr_tid, ccol, row_shift, base_for, color_for, is_dot, ins;\n    int no_skip, show_name, inverse;\n    char *ref;\n    /* maps @RG ID => SM (sample), in practice only used to determine whether a particular RG is in the list of allowed ones */\n    khash_t(kh_rg) *rg_hash;\n    /* callbacks */\n    void (*my_destroy)(struct AbstractTview* );\n    void (*my_mvprintw)(struct AbstractTview* ,int,int,const char*,...);\n    void (*my_mvaddch)(struct AbstractTview*,int,int,int);\n    void (*my_attron)(struct AbstractTview*,int);\n    void (*my_attroff)(struct AbstractTview*,int);\n    void (*my_clear)(struct AbstractTview*);\n    int (*my_colorpair)(struct AbstractTview*,int);\n    int (*my_drawaln)(struct AbstractTview*,int,hts_pos_t);\n    int (*my_loop)(struct AbstractTview*);\n    int (*my_underline)(struct AbstractTview*);\n} tview_t;\n\n\nchar bam_aux_getCEi(bam1_t *b, int i);\nchar bam_aux_getCSi(bam1_t *b, int i);\nchar bam_aux_getCQi(bam1_t *b, int i);\n\n#define TV_MIN_ALNROW 2\n#define TV_MAX_GOTO  48\n#define TV_MAX_LISTREF 6\n#define TV_LOW_MAPQ  10\n\n#define TV_COLOR_MAPQ   0\n#define TV_COLOR_BASEQ  1\n#define TV_COLOR_NUCL   2\n#define TV_COLOR_COL    3\n#define TV_COLOR_COLQ   4\n\n#define TV_BASE_NUCL 0\n#define TV_BASE_COLOR_SPACE 1\n\nint tv_pl_func(uint32_t tid, hts_pos_t pos, int n, const bam_pileup1_t *pl, void *data);\n// Added fn_idx to arguments as index file\nint base_tv_init(tview_t*,const char *fn, const char *fn_fa, const char *fn_idx,\n                 const char *samples, const htsFormat *fmt);\nvoid base_tv_destroy(tview_t*);\nint base_draw_aln(tview_t *tv, int tid, hts_pos_t pos);\n\ntypedef struct Tixel\n    {\n    int ch;\n    int attributes;\n    }tixel_t;\n\n#endif\n\n"
        },
        {
          "name": "bam_tview_curses.c",
          "type": "blob",
          "size": 16.1171875,
          "content": "/*  bam_tview_curses.c -- curses tview implementation.\n\n    Copyright (C) 2008-2015, 2019, 2021 Genome Research Ltd.\n    Portions copyright (C) 2013 Pierre Lindenbaum, Institut du Thorax, INSERM U1087, Université de Nantes.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n#include <stdbool.h>\n\n#include \"bam_tview.h\"\n\n#ifdef HAVE_CURSES\n\n#if defined HAVE_NCURSESW_CURSES_H\n#include <ncursesw/curses.h>\n#elif defined HAVE_NCURSESW_H\n#include <ncursesw.h>\n#elif defined HAVE_NCURSES_CURSES_H\n#include <ncurses/curses.h>\n#elif defined HAVE_NCURSES_H\n#include <ncurses.h>\n#elif defined HAVE_CURSES_H\n#include <curses.h>\n#else\n// Have the library, but no header file\n#warning \"Curses header file not found; tview with curses is disabled.\"\n#undef HAVE_CURSES\n#endif\n#else\n#warning \"No curses library is available; tview with curses is disabled.\"\n#endif\n\n#ifdef HAVE_CURSES\n\ntypedef struct CursesTview {\n    tview_t view;\n    WINDOW *wgoto, *whelp, *wlistref;\n} curses_tview_t;\n\n#define FROM_TV(ptr) ((curses_tview_t*)ptr)\n\nstatic void curses_destroy(tview_t* base) {\n    curses_tview_t* tv=(curses_tview_t*)base;\n\n    delwin(tv->wgoto); delwin(tv->whelp); delwin(tv->wlistref);\n    endwin();\n\n    base_tv_destroy(base);\n\n    free(tv);\n}\n\n/*\n void (*my_mvprintw)(struct AbstractTview* ,int,int,const char*,...);\n    void (*my_)(struct AbstractTview*,int,int,int);\n    void (*my_attron)(struct AbstractTview*,int);\n    void (*my_attroff)(struct AbstractTview*,int);\n    void (*my_clear)(struct AbstractTview*);\n    int (*my_colorpair)(struct AbstractTview*,int);\n*/\n\nstatic HTS_FORMAT(HTS_PRINTF_FMT, 4, 5)\nvoid curses_mvprintw(struct AbstractTview* tv,int y ,int x,const char* fmt,...) {\n    va_list argptr;\n    va_start(argptr, fmt);\n    if (wmove(stdscr, y, x) != ERR)\n        vw_printw(stdscr, fmt, argptr);\n    va_end(argptr);\n}\n\nstatic void curses_mvaddch(struct AbstractTview* tv,int y,int x,int ch) {\n    mvaddch(y,x,ch);\n}\n\nstatic void curses_attron(struct AbstractTview* tv,int flag) {\n    attron(flag);\n}\n\nstatic void curses_attroff(struct AbstractTview* tv,int flag) {\n    attroff(flag);\n}\n\nstatic void curses_clear(struct AbstractTview* tv) {\n    clear();\n}\n\nstatic int curses_init_colors(int inverse)\n{\n    if (inverse) {\n        init_pair(1, COLOR_WHITE, COLOR_BLUE);\n        init_pair(2, COLOR_BLACK, COLOR_GREEN);\n        init_pair(3, COLOR_BLACK, COLOR_YELLOW);\n        init_pair(4, COLOR_BLACK, COLOR_WHITE);\n        init_pair(5, COLOR_BLACK, COLOR_GREEN);\n        init_pair(6, COLOR_BLACK, COLOR_CYAN);\n        init_pair(7, COLOR_WHITE, COLOR_MAGENTA);\n        init_pair(8, COLOR_WHITE, COLOR_RED);\n        init_pair(9, COLOR_WHITE, COLOR_BLUE);\n    } else {\n        init_pair(1, COLOR_BLUE, COLOR_BLACK);\n        init_pair(2, COLOR_GREEN, COLOR_BLACK);\n        init_pair(3, COLOR_YELLOW, COLOR_BLACK);\n        init_pair(4, COLOR_WHITE, COLOR_BLACK);\n        init_pair(5, COLOR_GREEN, COLOR_BLACK);\n        init_pair(6, COLOR_CYAN, COLOR_BLACK);\n        init_pair(7, COLOR_MAGENTA, COLOR_BLACK);\n        init_pair(8, COLOR_RED, COLOR_BLACK);\n        init_pair(9, COLOR_BLUE, COLOR_BLACK);\n    }\n\n    return 0;\n}\n\nstatic int curses_colorpair(struct AbstractTview* tv,int flag) {\n    return COLOR_PAIR(flag);\n}\n\nstatic int curses_drawaln(struct AbstractTview* tv, int tid, hts_pos_t pos) {\n    return base_draw_aln(tv,  tid, pos);\n}\n\nstatic int tv_win_goto_get_completions(curses_tview_t *tv, char *str,\n                                       int **matches, int *matches_size) {\n\n\n    char **references = tv->view.header->target_name;\n    uint32_t *references_lengths = tv->view.header->target_len;\n    int num_references = tv->view.header->n_targets;\n    int i, num_matches = 0;\n    char new_str[TV_MAX_GOTO+1] = {'\\0'};\n    for (i = 0; i < TV_MAX_GOTO; i++) {\n        if (str[i] == ':' || str[i] == '\\0') break;\n        new_str[i] = str[i];\n    }\n\n    size_t l_str = strlen(new_str);\n    bool is_different = l_str != strlen(str);\n\n    for (i = 0; i < num_references; i++) {\n        char *ref = references[i];\n        uint32_t *len = references_lengths + i;\n        if (ref == NULL || len == NULL) return -1;\n        if (strncmp(ref, new_str, l_str) == 0) {\n\n            // Special case handling if the reference is already selected\n            if (is_different && strlen(ref) == l_str) {\n                num_matches = 1;\n                if (hts_resize(int, num_matches, matches_size, matches, 0) == -1)\n                    return -1;\n                (*matches)[num_matches-1] = i;\n\n                break;\n            } else if (!is_different) {\n                num_matches++;\n\n                if (hts_resize(int, num_matches, matches_size, matches, 0) == -1)\n                    return -1;\n\n                (*matches)[num_matches-1] = i;\n\n            }\n        }\n    }\n\n    return num_matches;\n}\n\nstatic void tv_win_listref(curses_tview_t *tv, int* matches, int num_matches,\n                           int tab_index, int upper_bound) {\n    int i;\n    char str[TV_MAX_GOTO+1];\n    char **refs = tv->view.header->target_name;\n    uint32_t *lengths = tv->view.header->target_len;\n\n    wclear(tv->wlistref);\n    wborder(tv->wlistref, '|', '|', '-', '-', '+', '+', '+', '+');\n\n    if (num_matches == 0) {\n        mvwprintw(tv->wlistref, 3, 18, \"No references found.\");\n    }\n\n    int offset = upper_bound < TV_MAX_LISTREF ? 0 : upper_bound - TV_MAX_LISTREF;\n    int max = num_matches < TV_MAX_LISTREF ? num_matches : TV_MAX_LISTREF;\n    for (i = 0; i < max; i++) {\n        uint32_t match_idx = matches[i+offset];\n        char *ref = refs[match_idx];\n        uint32_t len = lengths[match_idx];\n\n        if (tab_index == i+offset) {\n            mvwprintw(tv->wlistref, i+1, 1, \">\");\n        }\n        snprintf(str, TV_MAX_GOTO, \"%s  length: %d\", ref, len);\n        mvwprintw(tv->wlistref, i+1, 2, \"%s\", str);\n   }\n\n    if (upper_bound < num_matches) {\n        mvwprintw(tv->wlistref, TV_MAX_LISTREF-1, TV_MAX_GOTO+8, \"|\");\n        mvwprintw(tv->wlistref, TV_MAX_LISTREF,   TV_MAX_GOTO+8, \"v\");\n    }\n    if (offset > 0) {\n        mvwprintw(tv->wlistref, 1, TV_MAX_GOTO+8, \"^\");\n        mvwprintw(tv->wlistref, 2, TV_MAX_GOTO+8, \"|\");\n    }\n\n    wrefresh(tv->wlistref);\n}\n\nstatic void tv_win_goto(curses_tview_t *tv, int *tid, hts_pos_t *pos) {\n    char str[TV_MAX_GOTO+1], *p;\n    int *matches = NULL;\n    int i, l, tab_index = 0, num_matches = 0, matches_size = 0, upper_bound = TV_MAX_LISTREF;\n    bool is_tabbing = false;\n    tview_t *base=(tview_t*)tv;\n    str[0] = '\\0';\n    wclear(tv->wgoto);\n    wborder(tv->wgoto, '|', '|', '-', '-', '+', '+', '+', '+');\n\n    if (tv->view.header->n_targets > *tid) {\n        char *ref = tv->view.header->target_name[*tid];\n        snprintf(str, TV_MAX_GOTO+1, \"%s:%\"PRIhts_pos, ref, tv->view.left_pos+1);\n    }\n    mvwprintw(tv->wgoto, 1, 2, \"Goto: %s\", str);\n    l = strlen(str);\n\n    num_matches = tv_win_goto_get_completions(tv, str, &matches, &matches_size);\n    tv_win_listref(tv, matches, num_matches, tab_index, upper_bound);\n\n    for (;;) {\n        int invalid = 0;\n        int c = wgetch(tv->wgoto);\n        wrefresh(tv->wgoto);\n        if (c == KEY_BACKSPACE || c == '\\010' || c == '\\177') {\n            if(l > 0) str[--l] = '\\0';\n        } else if (c == KEY_ENTER || c == '\\012' || c == '\\015') {\n            int _tid = -1;\n            hts_pos_t _beg, _end;\n            if (str[0] == '=') {\n                _beg = strtoll(str+1, &p, 10) - 1;\n                if (_beg > 0) {\n                    *pos = _beg;\n                    free(matches);\n                    return;\n                }\n            } else {\n                if (sam_parse_region(base->header, str, &_tid, &_beg, &_end, 0) && _tid >= 0) {\n                    *tid = _tid; *pos = _beg;\n                    free(matches);\n                    return;\n                }\n            }\n\n            // If we get here, the region string is invalid\n            invalid = 1;\n        } else if (c == KEY_STAB || c == 9 || c == KEY_UP || c == KEY_DOWN || c == KEY_BTAB) {\n            if (is_tabbing) {\n\n                if (c == KEY_UP || c == KEY_BTAB) {\n                    tab_index--;\n                } else {\n                    tab_index++;\n                }\n\n                if (tab_index >= num_matches) {\n                    tab_index = 0;\n                    upper_bound = TV_MAX_LISTREF;\n                } else if (tab_index < 0) {\n                    tab_index = num_matches == 0 ? 0 : num_matches-1;\n                    upper_bound = num_matches == 0 ? TV_MAX_LISTREF : num_matches-1;\n                }\n\n                if (num_matches > 0) {\n                    if (tab_index >= upper_bound) {\n                        upper_bound++;\n                    }\n                    if (tab_index < upper_bound-TV_MAX_LISTREF) {\n                        upper_bound--;\n                    }\n                }\n            } else {\n                is_tabbing = true;\n            }\n\n            if (num_matches > 0) {\n                snprintf(str, TV_MAX_GOTO+1, \"%s:\", tv->view.header->target_name[matches[tab_index]]);\n                l = strlen(str);\n            }\n        } else if (isgraph(c)) {\n            if (l < TV_MAX_GOTO) str[l++] = c;\n        } else if (c == '\\027') l = 0;\n        else if (c == '\\033') {\n            free(matches);\n            return;\n        }\n        str[l] = '\\0';\n        for (i = 0; i < TV_MAX_GOTO; ++i) mvwaddch(tv->wgoto, 1, 8 + i, ' ');\n        if (invalid) mvwprintw(tv->wgoto, 1, TV_MAX_GOTO - 1, \"[Invalid]\");\n        mvwprintw(tv->wgoto, 1, 8, \"%s\", str);\n\n        // regenerate completion list if not navigating through them\n        if (c != KEY_STAB && c != 9 && c != KEY_DOWN && c != KEY_UP && c!= KEY_BTAB) {\n            tab_index = 0;\n            upper_bound = TV_MAX_LISTREF;\n            num_matches = tv_win_goto_get_completions(tv, str, &matches, &matches_size);\n        }\n\n        tv_win_listref(tv, matches, num_matches, tab_index, upper_bound);\n\n    }\n\n    free(matches);\n}\n\nstatic void tv_win_help(curses_tview_t *tv) {\n    int r = 1;\n    WINDOW *win = tv->whelp;\n    wborder(win, '|', '|', '-', '-', '+', '+', '+', '+');\n    mvwprintw(win, r++, 2, \"        -=-    Help    -=- \");\n    r++;\n    mvwprintw(win, r++, 2, \"?          This window\");\n    mvwprintw(win, r++, 2, \"Arrows     Small scroll movement\");\n    mvwprintw(win, r++, 2, \"h,j,k,l    Small scroll movement\");\n    mvwprintw(win, r++, 2, \"H,J,K,L    Large scroll movement\");\n    mvwprintw(win, r++, 2, \"ctrl-H     Scroll 1k left\");\n    mvwprintw(win, r++, 2, \"ctrl-L     Scroll 1k right\");\n    mvwprintw(win, r++, 2, \"space      Scroll one screen\");\n    mvwprintw(win, r++, 2, \"backspace  Scroll back one screen\");\n    mvwprintw(win, r++, 2, \"g          Go to specific location\");\n    mvwprintw(win, r++, 2, \"m          Color for mapping qual\");\n    mvwprintw(win, r++, 2, \"n          Color for nucleotide\");\n    mvwprintw(win, r++, 2, \"b          Color for base quality\");\n    mvwprintw(win, r++, 2, \"c          Color for cs color\");\n    mvwprintw(win, r++, 2, \"z          Color for cs qual\");\n    mvwprintw(win, r++, 2, \".          Toggle on/off dot view\");\n    mvwprintw(win, r++, 2, \"s          Toggle on/off ref skip\");\n    mvwprintw(win, r++, 2, \"r          Toggle on/off rd name\");\n    mvwprintw(win, r++, 2, \"N          Turn on nt view\");\n    mvwprintw(win, r++, 2, \"C          Turn on cs view\");\n    mvwprintw(win, r++, 2, \"i          Toggle on/off ins\");\n    mvwprintw(win, r++, 2, \"v          Inverse video\");\n    mvwprintw(win, r++, 2, \"q          Exit\");\n    r++;\n    mvwprintw(win, r++, 2, \"Underline:      Secondary or orphan\");\n    mvwprintw(win, r++, 2, \"Blue:    0-9    Green: 10-19\");\n    mvwprintw(win, r++, 2, \"Yellow: 20-29   White: >=30\");\n    wrefresh(win);\n    wgetch(win);\n}\n\nstatic int curses_underline(tview_t* tv) {\n    return A_UNDERLINE;\n}\n\nstatic int curses_loop(tview_t* tv) {\n    int tid;\n    hts_pos_t pos;\n    curses_tview_t *CTV=(curses_tview_t *)tv;\n    tid = tv->curr_tid; pos = tv->left_pos;\n    while (1) {\n        int c = getch();\n        switch (c) {\n            case '?': tv_win_help(CTV); break;\n            case '\\033':\n            case 'q': goto end_loop;\n            case '/':\n            case 'g': tv_win_goto(CTV, &tid, &pos); break;\n            case 'm': tv->color_for = TV_COLOR_MAPQ; break;\n            case 'b': tv->color_for = TV_COLOR_BASEQ; break;\n            case 'n': tv->color_for = TV_COLOR_NUCL; break;\n            case 'c': tv->color_for = TV_COLOR_COL; break;\n            case 'z': tv->color_for = TV_COLOR_COLQ; break;\n            case 'v': curses_init_colors(tv->inverse = !tv->inverse); break;\n            case 's': tv->no_skip = !tv->no_skip; break;\n            case 'r': tv->show_name = !tv->show_name; break;\n            case KEY_LEFT:\n            case 'h': --pos; break;\n            case KEY_RIGHT:\n            case 'l': ++pos; break;\n            case KEY_SLEFT:\n            case 'H': pos -= 20; break;\n            case KEY_SRIGHT:\n            case 'L': pos += 20; break;\n            case '.': tv->is_dot = !tv->is_dot; break;\n            case 'N': tv->base_for = TV_BASE_NUCL; break;\n            case 'C': tv->base_for = TV_BASE_COLOR_SPACE; break;\n            case 'i': tv->ins = !tv->ins; break;\n            case '\\010': pos -= 1000; break;\n            case '\\014': pos += 1000; break;\n            case ' ': pos += tv->mcol; break;\n            case KEY_UP:\n            case 'j': --tv->row_shift; break;\n            case 'J': tv->row_shift -= 20; break;\n            case KEY_DOWN:\n            case 'k': ++tv->row_shift; break;\n            case 'K': tv->row_shift += 20; break;\n            case KEY_BACKSPACE:\n            case '\\177': pos -= tv->mcol; break;\n#ifdef KEY_RESIZE\n            case KEY_RESIZE: getmaxyx(stdscr, tv->mrow, tv->mcol); break;\n#endif\n            default: continue;\n        }\n        if (pos < 0) pos = 0;\n        if (tv->row_shift < 0) tv->row_shift = 0;\n        tv->my_drawaln(tv, tid, pos);\n    }\nend_loop:\n    return 0;\n}\n\ntview_t* curses_tv_init(const char *fn, const char *fn_fa, const char *samples,\n                        const htsFormat *fmt) {\n    curses_tview_t *tv = (curses_tview_t*)calloc(1, sizeof(curses_tview_t));\n    tview_t* base=(tview_t*)tv;\n    if(tv==0) {\n        fprintf(stderr,\"Calloc failed\\n\");\n        return 0;\n    }\n\n    base_tv_init(base,fn,fn_fa,NULL,samples,fmt);\n    /* initialize callbacks */\n#define SET_CALLBACK(fun) base->my_##fun=curses_##fun;\n    SET_CALLBACK(destroy);\n    SET_CALLBACK(mvprintw);\n    SET_CALLBACK(mvaddch);\n    SET_CALLBACK(attron);\n    SET_CALLBACK(attroff);\n    SET_CALLBACK(clear);\n    SET_CALLBACK(colorpair);\n    SET_CALLBACK(drawaln);\n    SET_CALLBACK(loop);\n    SET_CALLBACK(underline);\n#undef SET_CALLBACK\n\n    initscr();\n    keypad(stdscr, TRUE);\n    clear();\n    noecho();\n    cbreak();\n\n    getmaxyx(stdscr, base->mrow, base->mcol);\n    tv->wgoto = newwin(3, TV_MAX_GOTO + 10, 10, 5);\n    keypad(tv->wgoto, TRUE);\n    set_escdelay(0);\n    tv->whelp = newwin(30, 40, 5, 5);\n    tv->wlistref = newwin(8, TV_MAX_GOTO + 10, 3, 5);\n\n    start_color();\n    curses_init_colors(0);\n    return base;\n}\n\n#else // !HAVE_CURSES\n\nextern tview_t* text_tv_init(const char *fn, const char *fn_fa, const char *fn_idx, const char *samples,\n                             const htsFormat *fmt);\n\ntview_t* curses_tv_init(const char *fn, const char *fn_fa, const char *samples,\n                        const htsFormat *fmt) {\n    return text_tv_init(fn,fn_fa,NULL,samples,fmt);\n}\n\n#endif\n"
        },
        {
          "name": "bam_tview_html.c",
          "type": "blob",
          "size": 10.814453125,
          "content": "/*  bam_tview_html.c -- HTML tview output.\n\n    Copyright (C) 2013 Pierre Lindenbaum, Institut du Thorax, INSERM U1087, Université de Nantes.\n    Copyright (C) 2019 Genome Research Ltd.\n\n    Author: Pierre Lindenbaum <plindenbaum@yahoo.fr>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <unistd.h>\n#include \"bam_tview.h\"\n\n#define UNDERLINE_FLAG 10\n\ntypedef struct HtmlTview {\n    tview_t view;\n    int row_count;\n    tixel_t** screen;\n    FILE* out;\n    int attributes;/* color... */\n    } html_tview_t;\n\n#define FROM_TV(ptr) ((html_tview_t*)ptr)\n\nstatic void html_destroy(tview_t* base)\n    {\n    int i;\n    html_tview_t* tv=(html_tview_t*)base;\n    if(tv->screen!=NULL)\n        {\n        for(i=0;i< tv->row_count;++i) free(tv->screen[i]);\n        free(tv->screen);\n        }\n    base_tv_destroy(base);\n    free(tv);\n    }\n\n/*\n void (*my_mvprintw)(struct AbstractTview* ,int,int,const char*,...);\n    void (*my_)(struct AbstractTview*,int,int,int);\n    void (*my_attron)(struct AbstractTview*,int);\n    void (*my_attroff)(struct AbstractTview*,int);\n    void (*my_clear)(struct AbstractTview*);\n    int (*my_colorpair)(struct AbstractTview*,int);\n*/\n\nstatic void  HTS_FORMAT(HTS_PRINTF_FMT, 4, 5)\nhtml_mvprintw(struct AbstractTview* tv,int y ,int x,const char* fmt,...)\n    {\n    int i,nchars=0;\n    unsigned int size=tv->mcol+2;\n    char* str=malloc(size);\n    if(str==0) exit(EXIT_FAILURE);\n    va_list argptr;\n    va_start(argptr, fmt);\n    nchars=vsnprintf(str,size, fmt, argptr);\n    va_end(argptr);\n\n    for(i=0;i< nchars;++i)\n        {\n        tv->my_mvaddch(tv,y,x+i,str[i]);\n        }\n    free(str);\n    }\n\nstatic void html_mvaddch(struct AbstractTview* tv,int y,int x,int ch)\n    {\n    tixel_t* row=NULL;\n    html_tview_t* ptr=FROM_TV(tv);\n    if( x >= tv->mcol ) return; //out of screen\n    while(ptr->row_count<=y)\n        {\n        int x;\n        row=(tixel_t*)calloc(tv->mcol,sizeof(tixel_t));\n        if(row==0)  exit(EXIT_FAILURE);\n        for(x=0;x<tv->mcol;++x) {row[x].ch=' ';row[x].attributes=0;}\n        ptr->screen=(tixel_t**)realloc(ptr->screen,sizeof(tixel_t*)*(ptr->row_count+1));\n        ptr->screen[ptr->row_count++]=row;\n        }\n    row=ptr->screen[y];\n    row[x].ch=ch;\n    row[x].attributes=ptr->attributes;\n    }\n\nstatic void html_attron(struct AbstractTview* tv,int flag)\n    {\n    html_tview_t* ptr=FROM_TV(tv);\n    ptr->attributes |=  flag;\n\n\n    }\n\nstatic void html_attroff(struct AbstractTview* tv,int flag)\n    {\n    html_tview_t* ptr=FROM_TV(tv);\n    ptr->attributes &= ~(flag);\n    }\n\nstatic void html_clear(struct AbstractTview* tv)\n    {\n    html_tview_t* ptr=FROM_TV(tv);\n    if(ptr->screen!=NULL)\n    {\n    int i;\n    for(i=0;i< ptr->row_count;++i) free(ptr->screen[i]);\n    free(ptr->screen);\n    ptr->screen=NULL;\n    }\n    ptr->row_count=0;\n    ptr->attributes=0;\n    }\n\nstatic int html_colorpair(struct AbstractTview* tv,int flag)\n    {\n    return (1 << (flag));\n    }\n\nstatic int html_drawaln(struct AbstractTview* tv, int tid, hts_pos_t pos)\n    {\n    int y,x;\n    html_tview_t* ptr=FROM_TV(tv);\n    html_clear(tv);\n    base_draw_aln(tv,  tid, pos);\n    fputs(\"<html><head>\",ptr->out);\n    fprintf(ptr->out,\"<title>%s:%\"PRIhts_pos\"</title>\",\n        sam_hdr_tid2name(tv->header, tid),\n        pos+1\n        );\n    //style\n\n    fputs(\"<style type='text/css'>\\n\",ptr->out);\n    fputs(\".tviewbody { margin:5px; background-color:white;text-align:center;}\\n\",ptr->out);\n    fputs(\".tviewtitle {text-align:center;}\\n\",ptr->out);\n    fputs(\".tviewpre { margin:5px; background-color:white;}\\n\",ptr->out);\n    #define CSS(id,col) fprintf(ptr->out,\".tviewc%d {color:%s;}\\n.tviewcu%d {color:%s;text-decoration:underline;}\\n\",id,col,id,col);\n        CSS(0, \"black\");\n        CSS(1, \"blue\");\n    CSS(2, \"green\");\n    CSS(3, \"yellow\");\n    CSS(4, \"black\");\n    CSS(5, \"green\");\n    CSS(6, \"cyan\");\n    CSS(7, \"yellow\");\n    CSS(8, \"red\");\n    CSS(9, \"blue\");\n    #undef CSS\n    fputs(\"</style>\",ptr->out);\n\n    fputs(\"</head><body>\",ptr->out);\n\n      fprintf(ptr->out,\"<div class='tviewbody'><div class='tviewtitle'>%s:%\"PRIhts_pos\"</div>\",\n        sam_hdr_tid2name(tv->header, tid),\n        pos+1\n        );\n\n    fputs(\"<pre class='tviewpre'>\",ptr->out);\n    for(y=0;y< ptr->row_count;++y)\n        {\n\n        for(x=0;x< tv->mcol;++x)\n            {\n\n\n        if(x== 0 || ptr->screen[y][x].attributes != ptr->screen[y][x-1].attributes)\n                {\n                int css=0;\n            fprintf(ptr->out,\"<span\");\n                while(css<32)\n                    {\n                    //if(y>1) fprintf(stderr,\"css=%d pow2=%d vs %d\\n\",css,(1 << (css)),ptr->screen[y][x].attributes);\n                    if(( (ptr->screen[y][x].attributes) & (1 << (css)))!=0)\n                        {\n\n                        fprintf(ptr->out,\" class='tviewc%s%d'\",\n                            (( (ptr->screen[y][x].attributes) & (1 << (UNDERLINE_FLAG)) )!=0?\"u\":\"\"),\n                            css);\n                        break;\n                        }\n                    ++css;\n                    }\n\n\n                fputs(\">\",ptr->out);\n                }\n\n        int ch=ptr->screen[y][x].ch;\n        switch(ch)\n            {\n            case '<': fputs(\"&lt;\",ptr->out);break;\n            case '>': fputs(\"&gt;\",ptr->out);break;\n            case '&': fputs(\"&amp;\",ptr->out);break;\n            default: fputc(ch,ptr->out); break;\n            }\n\n\n            if(x+1 == tv->mcol  || ptr->screen[y][x].attributes!=ptr->screen[y][x+1].attributes)\n                {\n                fputs(\"</span>\",ptr->out);\n                }\n            }\n        if(y+1 < ptr->row_count) fputs(\"<br/>\",ptr->out);\n        }\n    fputs(\"</pre></div></body></html>\",ptr->out);\n    return 0;\n    }\n\n\n#define ANSI_COLOR_RED \"\\x1b[31m\"\n#define ANSI_COLOR_GREEN \"\\x1b[32m\"\n#define ANSI_COLOR_YELLOW \"\\x1b[33m\"\n#define ANSI_COLOR_BLUE \"\\x1b[34m\"\n#define ANSI_COLOR_MAGENTA \"\\x1b[35m\"\n#define ANSI_COLOR_CYAN \"\\x1b[36m\"\n#define ANSI_COLOR_BLACK \"\\x1b[0m\"\n#define ANSI_COLOR_RESET ANSI_COLOR_BLACK\n\n#define ANSI_UNDERLINE_SET \"\\033[4m\"\n#define ANSI_UNDERLINE_UNSET \"\\033[0m\"\n\nstatic int text_drawaln(struct AbstractTview* tv, int tid, hts_pos_t pos)\n    {\n    int y,x;\n    html_tview_t* ptr=FROM_TV(tv);\n    html_clear(tv);\n    base_draw_aln(tv,  tid, pos);\n    int is_term= isatty(fileno(ptr->out));\n\n    for(y=0;y< ptr->row_count;++y)\n        {\n        for(x=0;x< tv->mcol;++x)\n            {\n            if(is_term)\n                {\n                int css=0;\n                while(css<32)\n                    {\n                    if(( (ptr->screen[y][x].attributes) & (1 << (css)))!=0)\n                        {\n                        break;\n                        }\n                    ++css;\n                    }\n                switch(css)\n                    {\n                    //CSS(0, \"black\");\n                    case 1: fputs(ANSI_COLOR_BLUE,ptr->out); break;\n                case 2: fputs(ANSI_COLOR_GREEN,ptr->out); break;\n                case 3: fputs(ANSI_COLOR_YELLOW,ptr->out); break;\n                //CSS(4, \"black\");\n                case 5: fputs(ANSI_COLOR_GREEN,ptr->out); break;\n                case 6: fputs(ANSI_COLOR_CYAN,ptr->out); break;\n                case 7: fputs(ANSI_COLOR_YELLOW,ptr->out); break;\n                case 8: fputs(ANSI_COLOR_RED,ptr->out); break;\n                case 9: fputs(ANSI_COLOR_BLUE,ptr->out); break;\n                default:break;\n                    }\n                if(( (ptr->screen[y][x].attributes) & (1 << (UNDERLINE_FLAG)))!=0)\n                    {\n                    fputs(ANSI_UNDERLINE_SET,ptr->out);\n                    }\n\n                }\n\n\n            int ch=ptr->screen[y][x].ch;\n\n            fputc(ch,ptr->out);\n            if(is_term)\n                {\n                fputs(ANSI_COLOR_RESET,ptr->out);\n                if(( (ptr->screen[y][x].attributes) & (1 << (UNDERLINE_FLAG)))!=0)\n                    {\n                    fputs(ANSI_UNDERLINE_UNSET,ptr->out);\n                    }\n                }\n            }\n        fputc('\\n',ptr->out);\n        }\n    return 0;\n    }\n\n\nstatic int html_loop(tview_t* tv)\n    {\n    //tv->my_drawaln(tv, tv->curr_tid, tv->left_pos);\n    return 0;\n    }\n\nstatic int html_underline(tview_t* tv)\n    {\n    return (1 << UNDERLINE_FLAG);\n    }\n\n/*\nstatic void init_pair(html_tview_t *tv,int id_ge_1, const char* pen, const char* paper)\n    {\n\n    }\n*/\n\ntview_t* html_tv_init(const char *fn, const char *fn_fa, const char *fn_idx, const char *samples,\n                      const htsFormat *fmt)\n    {\n    char* colstr=getenv(\"COLUMNS\");\n    html_tview_t *tv = (html_tview_t*)calloc(1, sizeof(html_tview_t));\n    tview_t* base=(tview_t*)tv;\n    if(tv==0)\n        {\n        fprintf(stderr,\"Calloc failed\\n\");\n        return 0;\n        }\n    tv->row_count=0;\n    tv->screen=NULL;\n    tv->out=stdout;\n    tv->attributes=0;\n    base_tv_init(base,fn,fn_fa,fn_idx,samples,fmt);\n    /* initialize callbacks */\n#define SET_CALLBACK(fun) base->my_##fun=html_##fun;\n    SET_CALLBACK(destroy);\n    SET_CALLBACK(mvprintw);\n    SET_CALLBACK(mvaddch);\n    SET_CALLBACK(attron);\n    SET_CALLBACK(attroff);\n    SET_CALLBACK(clear);\n    SET_CALLBACK(colorpair);\n    SET_CALLBACK(drawaln);\n    SET_CALLBACK(loop);\n    SET_CALLBACK(underline);\n#undef SET_CALLBACK\n\n\n    if(colstr!=0)\n        {\n        base->mcol=atoi(colstr);\n        if(base->mcol<10) base->mcol=80;\n        }\n    base->mrow=99999;\n\n/*\n    init_pair(tv,1, \"blue\", \"white\");\n    init_pair(tv,2, \"green\", \"white\");\n    init_pair(tv,3, \"yellow\", \"white\");\n    init_pair(tv,4, \"white\", \"white\");\n    init_pair(tv,5, \"green\", \"white\");\n    init_pair(tv,6, \"cyan\", \"white\");\n    init_pair(tv,7, \"yellow\", \"white\");\n    init_pair(tv,8, \"red\", \"white\");\n    init_pair(tv,9, \"blue\", \"white\");\n    */\n    return base;\n    }\n\n\ntview_t* text_tv_init(const char *fn, const char *fn_fa, const char *fn_idx, const char *samples,\n                      const htsFormat *fmt)\n    {\n    tview_t* tv=html_tv_init(fn,fn_fa,fn_idx,samples,fmt);\n    tv->my_drawaln=text_drawaln;\n    return tv;\n    }\n\n"
        },
        {
          "name": "bamshuf.c",
          "type": "blob",
          "size": 20.14453125,
          "content": "/*  bamshuf.c -- collate subcommand.\n\n    Copyright (C) 2012 Broad Institute.\n    Copyright (C) 2013, 2015-2019,2023 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n#ifdef _WIN32\n#  define WIN32_LEAN_AND_MEAN\n#  include <windows.h>\n#endif\n#include \"htslib/sam.h\"\n#include \"htslib/hts.h\"\n#include \"htslib/ksort.h\"\n#include \"samtools.h\"\n#include \"htslib/thread_pool.h\"\n#include \"sam_opts.h\"\n#include \"htslib/khash.h\"\n\n#define DEF_CLEVEL 1\n\nstatic inline unsigned hash_Wang(unsigned key)\n{\n    key += ~(key << 15);\n    key ^=  (key >> 10);\n    key +=  (key << 3);\n    key ^=  (key >> 6);\n    key += ~(key << 11);\n    key ^=  (key >> 16);\n    return key;\n}\n\nstatic inline unsigned hash_X31_Wang(const char *s)\n{\n    unsigned h = *s;\n    if (h) {\n        for (++s ; *s; ++s) h = (h << 5) - h + *s;\n        return hash_Wang(h);\n    } else return 0;\n}\n\ntypedef struct {\n    unsigned key;\n    bam1_t *b;\n} elem_t;\n\nstatic inline int elem_lt(elem_t x, elem_t y)\n{\n    if (x.key < y.key) return 1;\n    if (x.key == y.key) {\n        int t;\n        t = strcmp(bam_get_qname(x.b), bam_get_qname(y.b));\n        if (t < 0) return 1;\n        return (t == 0 && ((x.b->core.flag>>6&3) < (y.b->core.flag>>6&3)));\n    } else return 0;\n}\n\nKSORT_INIT(bamshuf, elem_t, elem_lt)\n\n\ntypedef struct {\n    int written;\n    bam1_t *b;\n} bam_item_t;\n\ntypedef struct {\n    bam1_t *bam_pool;\n    bam_item_t *items;\n    size_t size;\n    size_t index;\n} bam_list_t;\n\ntypedef struct {\n    bam_item_t *bi;\n} store_item_t;\n\nKHASH_MAP_INIT_STR(bam_store, store_item_t)\n\n\nstatic bam_item_t *store_bam(bam_list_t *list) {\n    size_t old_index = list->index;\n\n    list->items[list->index++].written = 0;\n\n    if (list->index >= list->size)\n        list->index = 0;\n\n    return &list->items[old_index];\n}\n\n\nstatic int write_bam_needed(bam_list_t *list) {\n    return !list->items[list->index].written;\n}\n\n\nstatic void mark_bam_as_written(bam_list_t *list) {\n    list->items[list->index].written = 1;\n}\n\n\nstatic int create_bam_list(bam_list_t *list, size_t max_size) {\n    size_t i;\n\n    list->size = list->index = 0;\n    list->items    = NULL;\n    list->bam_pool = NULL;\n\n    if ((list->items = malloc(max_size * sizeof(bam_item_t))) == NULL) {\n        return 1;\n    }\n\n    if ((list->bam_pool = calloc(max_size, sizeof(bam1_t))) == NULL) {\n        return 1;\n    }\n\n    for (i = 0; i < max_size; i++) {\n        list->items[i].b = &list->bam_pool[i];\n        list->items[i].written = 1;\n    }\n\n    list->size  = max_size;\n    list->index = 0;\n\n    return 0;\n}\n\n\nstatic void destroy_bam_list(bam_list_t *list) {\n    size_t i;\n\n    for (i = 0; i < list->size; i++) {\n        free(list->bam_pool[i].data);\n    }\n\n    free(list->bam_pool);\n    free(list->items);\n}\n\n\nstatic inline int write_to_bin_file(bam1_t *bam, int64_t *count, samFile **bin_files, char **names, sam_hdr_t *header, int files) {\n    uint32_t x;\n\n    x = hash_X31_Wang(bam_get_qname(bam)) % files;\n\n    if (sam_write1(bin_files[x], header, bam) < 0) {\n        print_error_errno(\"collate\", \"Couldn't write to intermediate file \\\"%s\\\"\", names[x]);\n        return 1;\n    }\n\n    ++count[x];\n\n    return 0;\n}\n\n\nstatic int bamshuf(const char *fn, int n_files, const char *pre, int clevel,\n                   int is_stdout, const char *output_file, int fast, int store_max, sam_global_args *ga, char *arg_list, int no_pg)\n{\n    samFile *fp, *fpw = NULL, **fpt = NULL;\n    char **fnt = NULL, modew[8];\n    bam1_t *b = NULL;\n    int i, counter, l, r;\n    sam_hdr_t *h = NULL;\n    int64_t j, max_cnt = 0, *cnt = NULL;\n    elem_t *a = NULL;\n    htsThreadPool p = {NULL, 0};\n\n    if (ga->nthreads > 0) {\n        if (!(p.pool = hts_tpool_init(ga->nthreads))) {\n            print_error_errno(\"collate\", \"Error creating thread pool\\n\");\n            return 1;\n        }\n    }\n\n    // Read input, distribute reads pseudo-randomly into n_files temporary\n    // files.\n    fp = sam_open_format(fn ? fn : \"-\", \"r\", &ga->in);\n    if (fp == NULL) {\n        print_error_errno(\"collate\", \"Cannot open input file \\\"%s\\\"\", fn);\n        return 1;\n    }\n    if (p.pool) hts_set_opt(fp, HTS_OPT_THREAD_POOL, &p);\n\n    h = sam_hdr_read(fp);\n    if (h == NULL) {\n        fprintf(stderr, \"Couldn't read header for '%s'\\n\", fn);\n        goto fail;\n    }\n\n    if ((-1 == sam_hdr_update_hd(h, \"SO\", \"unsorted\", \"GO\", \"query\"))\n     && (-1 == sam_hdr_add_line(h, \"HD\", \"VN\", SAM_FORMAT_VERSION, \"SO\", \"unsorted\", \"GO\", \"query\", NULL))\n     ) {\n        print_error(\"collate\", \"failed to update HD line\\n\");\n        goto fail;\n    }\n\n    // open final output file\n    l = strlen(pre);\n\n    sprintf(modew, \"wb%d\", (clevel >= 0 && clevel <= 9)? clevel : DEF_CLEVEL);\n\n    if (!is_stdout && !output_file) { // output to a file (name based on prefix)\n        char *fnw = (char*)calloc(l + 5, 1);\n        if (!fnw) goto mem_fail;\n        if (ga->out.format == unknown_format)\n            sprintf(fnw, \"%s.bam\", pre); // \"wb\" above makes BAM the default\n        else\n            sprintf(fnw, \"%s.%s\", pre,  hts_format_file_extension(&ga->out));\n        fpw = sam_open_format(fnw, modew, &ga->out);\n        free(fnw);\n    } else if (output_file) { // output to a given file\n        modew[0] = 'w'; modew[1] = '\\0';\n        sam_open_mode(modew + 1, output_file, NULL);\n        j = strlen(modew);\n        snprintf(modew + j, sizeof(modew) - j, \"%d\",\n                 (clevel >= 0 && clevel <= 9)? clevel : DEF_CLEVEL);\n        fpw = sam_open_format(output_file, modew, &ga->out);\n    } else fpw = sam_open_format(\"-\", modew, &ga->out); // output to stdout\n    if (fpw == NULL) {\n        if (is_stdout) print_error_errno(\"collate\", \"Cannot open standard output\");\n        else print_error_errno(\"collate\", \"Cannot open output file \\\"%s.bam\\\"\", pre);\n        goto fail;\n    }\n    if (p.pool) hts_set_opt(fpw, HTS_OPT_THREAD_POOL, &p);\n\n    if (!no_pg && sam_hdr_add_pg(h, \"samtools\",\n                                 \"VN\", samtools_version(),\n                                 arg_list ? \"CL\": NULL,\n                                 arg_list ? arg_list : NULL,\n                                 NULL)) {\n        print_error(\"collate\", \"failed to add PG line to header of \\\"%s\\\"\", output_file);\n        goto fail;\n    }\n\n    if (sam_hdr_write(fpw, h) < 0) {\n        print_error_errno(\"collate\", \"Couldn't write header\");\n        goto fail;\n    }\n\n    fnt = (char**)calloc(n_files, sizeof(char*));\n    if (!fnt) goto mem_fail;\n    fpt = (samFile**)calloc(n_files, sizeof(samFile*));\n    if (!fpt) goto mem_fail;\n    cnt = (int64_t*)calloc(n_files, 8);\n    if (!cnt) goto mem_fail;\n\n    for (i = counter = 0; i < n_files; ++i) {\n        fnt[i] = (char*)calloc(l + 20, 1);\n        if (!fnt[i]) goto mem_fail;\n        do {\n            sprintf(fnt[i], \"%s.%04d.bam\", pre, counter++);\n            fpt[i] = sam_open(fnt[i], \"wxb1\");\n        } while (!fpt[i] && errno == EEXIST);\n        if (fpt[i] == NULL) {\n            print_error_errno(\"collate\", \"Cannot open intermediate file \\\"%s\\\"\", fnt[i]);\n            goto fail;\n        }\n        if (p.pool) hts_set_opt(fpt[i], HTS_OPT_THREAD_POOL, &p);\n        if (sam_hdr_write(fpt[i], h) < 0) {\n            print_error_errno(\"collate\", \"Couldn't write header to intermediate file \\\"%s\\\"\", fnt[i]);\n            goto fail;\n        }\n    }\n\n    if (fast) {\n        khash_t(bam_store) *stored = kh_init(bam_store);\n        khiter_t itr;\n        bam_list_t list;\n        int err = 0;\n        if (!stored) goto mem_fail;\n\n        if (store_max < 2) store_max = 2;\n\n        if (create_bam_list(&list, store_max)) {\n            fprintf(stderr, \"[collate[ ERROR: unable to create bam list.\\n\");\n            err = 1;\n            goto fast_fail;\n        }\n\n        while ((r = sam_read1(fp, h, list.items[list.index].b)) >= 0) {\n            int ret;\n            bam1_t *b = list.items[list.index].b;\n            int readflag = b->core.flag & (BAM_FREAD1 | BAM_FREAD2);\n\n            // strictly paired reads only\n            if (!(b->core.flag & (BAM_FSECONDARY | BAM_FSUPPLEMENTARY)) && (readflag == BAM_FREAD1 || readflag == BAM_FREAD2)) {\n\n                itr = kh_get(bam_store, stored, bam_get_qname(b));\n\n                if (itr == kh_end(stored)) {\n                    // new read\n                    itr = kh_put(bam_store, stored, bam_get_qname(b), &ret);\n\n                    if (ret > 0) { // okay to go ahead store it\n                        kh_value(stored, itr).bi = store_bam(&list);\n\n                        // see if the next one on the list needs to be written out\n                        if (write_bam_needed(&list)) {\n                            if (write_to_bin_file(list.items[list.index].b, cnt, fpt, fnt, h, n_files) < 0) {\n                                fprintf(stderr, \"[collate] ERROR: could not write line.\\n\");\n                                err = 1;\n                                goto fast_fail;\n                            } else {\n                                mark_bam_as_written(&list);\n\n                                itr = kh_get(bam_store, stored, bam_get_qname(list.items[list.index].b));\n\n                                if (itr != kh_end(stored)) {\n                                    kh_del(bam_store, stored, itr);\n                                } else {\n                                    fprintf(stderr, \"[collate] ERROR: stored value not in hash.\\n\");\n                                    err = 1;\n                                    goto fast_fail;\n                                }\n                            }\n                        }\n                    } else if (ret == 0) {\n                        fprintf(stderr, \"[collate] ERROR: value already in hash.\\n\");\n                        err = 1;\n                        goto fast_fail;\n                    } else {\n                        fprintf(stderr, \"[collate] ERROR: unable to store in hash.\\n\");\n                        err = 1;\n                        goto fast_fail;\n                    }\n                } else { // we have a match\n                    // write out the reads in R1 R2 order\n                    bam1_t *r1, *r2;\n\n                    if (b->core.flag & BAM_FREAD1) {\n                        r1 = b;\n                        r2 = kh_value(stored, itr).bi->b;\n                    } else {\n                        r1 = kh_value(stored, itr).bi->b;\n                        r2 = b;\n                    }\n\n                    if (sam_write1(fpw, h, r1) < 0) {\n                        fprintf(stderr, \"[collate] ERROR: could not write r1 alignment.\\n\");\n                        err = 1;\n                        goto fast_fail;\n                    }\n\n                    if (sam_write1(fpw, h, r2) < 0) {\n                        fprintf(stderr, \"[collate] ERROR: could not write r2 alignment.\\n\");\n                        err = 1;\n                        goto fast_fail;\n                    }\n\n                    mark_bam_as_written(&list);\n\n                    // remove stored read\n                    kh_value(stored, itr).bi->written = 1;\n                    kh_del(bam_store, stored, itr);\n                }\n            }\n        }\n\n        for (list.index = 0; list.index < list.size; list.index++) {\n            if (write_bam_needed(&list)) {\n                bam1_t *b = list.items[list.index].b;\n\n                if (write_to_bin_file(b, cnt, fpt, fnt, h, n_files)) {\n                    err = 1;\n                    goto fast_fail;\n                } else {\n                    itr = kh_get(bam_store, stored, bam_get_qname(b));\n                    kh_del(bam_store, stored, itr);\n                }\n            }\n        }\n\n fast_fail:\n        if (err) {\n            for (itr = kh_begin(stored); itr != kh_end(stored); ++itr) {\n                if (kh_exist(stored, itr)) {\n                    kh_del(bam_store, stored, itr);\n                }\n            }\n\n            kh_destroy(bam_store, stored);\n            destroy_bam_list(&list);\n            goto fail;\n        } else {\n            kh_destroy(bam_store, stored);\n            destroy_bam_list(&list);\n        }\n\n    } else {\n        b = bam_init1();\n        if (!b) goto mem_fail;\n\n        while ((r = sam_read1(fp, h, b)) >= 0) {\n            if (write_to_bin_file(b, cnt, fpt, fnt, h, n_files)) {\n                bam_destroy1(b);\n                goto fail;\n            }\n        }\n\n        bam_destroy1(b);\n    }\n\n    if (r < -1) {\n        fprintf(stderr, \"Error reading input file\\n\");\n        goto fail;\n    }\n    for (i = 0; i < n_files; ++i) {\n        // Close split output\n        r = sam_close(fpt[i]);\n        fpt[i] = NULL;\n        if (r < 0) {\n            fprintf(stderr, \"Error on closing '%s'\\n\", fnt[i]);\n            return 1;\n        }\n\n        // Find biggest count\n        if (max_cnt < cnt[i]) max_cnt = cnt[i];\n    }\n    free(fpt);\n    fpt = NULL;\n    sam_close(fp);\n    fp = NULL;\n\n    // merge\n    a = malloc(max_cnt * sizeof(elem_t));\n    if (!a) goto mem_fail;\n    for (j = 0; j < max_cnt; ++j) {\n        a[j].b = bam_init1();\n        if (!a[j].b) { max_cnt = j; goto mem_fail; }\n    }\n\n    for (i = 0; i < n_files; ++i) {\n        int64_t c = cnt[i];\n        fp = sam_open_format(fnt[i], \"r\", &ga->in);\n        if (NULL == fp) {\n            print_error_errno(\"collate\", \"Couldn't open \\\"%s\\\"\", fnt[i]);\n            goto fail;\n        }\n        if (p.pool) hts_set_opt(fp, HTS_OPT_THREAD_POOL, &p);\n        sam_hdr_destroy(sam_hdr_read(fp)); // Skip over header\n\n        // Slurp in one of the split files\n        for (j = 0; j < c; ++j) {\n            if (sam_read1(fp, h, a[j].b) < 0) {\n                fprintf(stderr, \"Error reading '%s'\\n\", fnt[i]);\n                goto fail;\n            }\n            a[j].key = hash_X31_Wang(bam_get_qname(a[j].b));\n        }\n        sam_close(fp);\n        unlink(fnt[i]);\n        free(fnt[i]);\n        fnt[i] = NULL;\n\n        ks_introsort(bamshuf, c, a); // Shuffle all the reads\n\n        // Write them out again\n        for (j = 0; j < c; ++j) {\n            if (sam_write1(fpw, h, a[j].b) < 0) {\n                print_error_errno(\"collate\", \"Error writing to output\");\n                goto fail;\n            }\n        }\n    }\n\n    sam_hdr_destroy(h);\n    for (j = 0; j < max_cnt; ++j) bam_destroy1(a[j].b);\n    free(a); free(fnt); free(cnt);\n    sam_global_args_free(ga);\n    if (sam_close(fpw) < 0) {\n        fprintf(stderr, \"Error on closing output\\n\");\n        return 1;\n    }\n\n    if (p.pool) hts_tpool_destroy(p.pool);\n    return 0;\n\n mem_fail:\n    fprintf(stderr, \"Out of memory\\n\");\n\n fail:\n    if (fp) sam_close(fp);\n    if (fpw) sam_close(fpw);\n    if (h) sam_hdr_destroy(h);\n    for (i = 0; i < n_files; ++i) {\n        if (fnt) free(fnt[i]);\n        if (fpt && fpt[i]) sam_close(fpt[i]);\n    }\n    if (a) {\n        for (j = 0; j < max_cnt; ++j) bam_destroy1(a[j].b);\n        free(a);\n    }\n    free(fnt);\n    free(fpt);\n    free(cnt);\n    if (p.pool) hts_tpool_destroy(p.pool);\n    sam_global_args_free(ga);\n    return 1;\n}\n\nstatic int usage(FILE *fp, int n_files, int reads_store) {\n    fprintf(fp,\n            \"Usage: samtools collate [options...] <in.bam> [<prefix>]\\n\\n\"\n            \"Options:\\n\"\n            \"      -O       Output to stdout\\n\"\n            \"      -o       Output file name (use prefix if not set)\\n\"\n            \"      -u       Uncompressed BAM output\\n\"\n            \"      -f       Fast (only primary alignments)\\n\"\n            \"      -r       Working reads stored (with -f) [%d]\\n\" // reads_store\n            \"      -l INT   Compression level [%d]\\n\" // DEF_CLEVEL\n            \"      -n INT   Number of temporary files [%d]\\n\" // n_files\n            \"      -T PREFIX\\n\"\n            \"               Write temporary files to PREFIX.nnnn.bam\\n\"\n            \"      --no-PG  do not add a PG line\\n\",\n            reads_store, DEF_CLEVEL, n_files);\n\n    sam_global_opt_help(fp, \"-....@-.\");\n    fprintf(fp,\n            \"  <prefix> is required unless the -o or -O options are used.\\n\");\n\n    return 1;\n}\n\nchar *generate_prefix(const char *out_fn) {\n    char *prefix;\n    unsigned int pid = getpid();\n\n    if (out_fn && !(*out_fn == '-' && out_fn[1] == '\\0')) {\n        // <out_fn>.<collate><pid>.<nnnn>.<bam>\n        size_t plen = strlen(out_fn) + 50;\n        if (!(prefix = malloc(plen))) {\n            perror(\"collate\");\n            return NULL;\n        }\n        snprintf(prefix, plen, \"%s.collate%x\", out_fn, pid);\n        return prefix;\n    }\n\n#ifdef _WIN32\n#  define PREFIX_LEN (MAX_PATH + 16)\n    DWORD ret;\n    prefix = calloc(PREFIX_LEN, sizeof(*prefix));\n    if (!prefix) {\n        perror(\"collate\");\n        return NULL;\n    }\n    ret = GetTempPathA(MAX_PATH, prefix);\n    if (ret > MAX_PATH || ret == 0) {\n        fprintf(stderr,\n                \"[E::collate] Couldn't get path for temporary files.\\n\");\n        free(prefix);\n        return NULL;\n    }\n    snprintf(prefix + ret, PREFIX_LEN - ret, \"\\\\%x\", pid);\n    return prefix;\n#else\n    char *tmp_env = getenv(\"TMPDIR\");\n    if (!tmp_env)\n        tmp_env = \"/tmp\";\n\n    size_t prefix_len = strlen(tmp_env)+20;\n    prefix = malloc(prefix_len);\n    if (!prefix) {\n        perror(\"collate\");\n        return NULL;\n    }\n    snprintf(prefix, prefix_len, \"%s/collate%x\", tmp_env, pid);\n\n    return prefix;\n#endif\n}\n\nint main_bamshuf(int argc, char *argv[])\n{\n    int c, n_files = 64, clevel = DEF_CLEVEL, is_stdout = 0, is_un = 0, fast_coll = 0, reads_store = 10000, ret, pre_mem = 0, no_pg = 0;\n    const char *output_file = NULL;\n    char *prefix = NULL, *arg_list = NULL;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 0, 0, 0, '@'),\n        {\"no-PG\", no_argument, NULL, 1},\n        { NULL, 0, NULL, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \"n:l:uOo:@:fr:T:\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'n': n_files = atoi(optarg); break;\n        case 'l': clevel = atoi(optarg); break;\n        case 'u': is_un = 1; break;\n        case 'O': is_stdout = 1; break;\n        case 'o': output_file = optarg; break;\n        case 'f': fast_coll = 1; break;\n        case 'r': reads_store = atoi(optarg); break;\n        case 'T': prefix = optarg; break;\n        case 1: no_pg = 1; break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                  /* else fall-through */\n        case '?': return usage(stderr, n_files, reads_store);\n        }\n    }\n    if (is_un) clevel = 0;\n    if (argc >= optind + 2) prefix = argv[optind+1];\n    if (argc == optind) {\n        if (argc > 1 || !isatty(STDIN_FILENO))\n            fprintf(stderr, \"collate: no input filename specified.\\n\");\n        return usage(argc > 1 || !isatty(STDIN_FILENO) ? stderr : stdout,\n                     n_files, reads_store);\n    }\n    if (!(prefix || is_stdout || output_file))\n        return usage(stderr, n_files, reads_store);\n    if (is_stdout && output_file) {\n        fprintf(stderr, \"collate: -o and -O options cannot be used together.\\n\");\n        return usage(stderr, n_files, reads_store);\n    }\n    if (!prefix) {\n        prefix = generate_prefix(output_file);\n        pre_mem = 1;\n    }\n\n    if (!prefix) return EXIT_FAILURE;\n\n    if (!no_pg && !(arg_list = stringify_argv(argc+1, argv-1))) {\n        print_error(\"collate\", \"failed to create arg_list\");\n        return 1;\n    }\n\n    ret = bamshuf(argv[optind], n_files, prefix, clevel, is_stdout,\n                   output_file, fast_coll, reads_store, &ga, arg_list, no_pg);\n\n    if (pre_mem) free(prefix);\n    free(arg_list);\n\n    return ret;\n}\n"
        },
        {
          "name": "bamtk.c",
          "type": "blob",
          "size": 13.4228515625,
          "content": "/*  bamtk.c -- main samtools command front-end.\n\n    Copyright (C) 2008-2023 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n\n#include \"htslib/hts.h\"\n#include \"htslib/hfile.h\"\n#include \"samtools.h\"\n#include \"version.h\"\n\nint bam_taf2baf(int argc, char *argv[]);\nint bam_mpileup(int argc, char *argv[]);\nint bam_merge(int argc, char *argv[]);\nint bam_index(int argc, char *argv[]);\nint bam_sort(int argc, char *argv[]);\nint bam_tview_main(int argc, char *argv[]);\nint bam_mating(int argc, char *argv[]);\nint bam_rmdup(int argc, char *argv[]);\nint bam_flagstat(int argc, char *argv[]);\nint bam_fillmd(int argc, char *argv[]);\nint bam_idxstats(int argc, char *argv[]);\nint bam_markdup(int argc, char *argv[]);\nint main_samview(int argc, char *argv[]);\nint main_head(int argc, char *argv[]);\nint main_reheader(int argc, char *argv[]);\nint main_cut_target(int argc, char *argv[]);\nint main_phase(int argc, char *argv[]);\nint main_cat(int argc, char *argv[]);\nint main_depth(int argc, char *argv[]);\nint main_coverage(int argc, char *argv[]);\nint main_bam2fq(int argc, char *argv[]);\nint main_pad2unpad(int argc, char *argv[]);\nint main_bedcov(int argc, char *argv[]);\nint main_bamshuf(int argc, char *argv[]);\nint main_stats(int argc, char *argv[]);\nint main_flags(int argc, char *argv[]);\nint main_split(int argc, char *argv[]);\nint main_quickcheck(int argc, char *argv[]);\nint main_addreplacerg(int argc, char *argv[]);\nint faidx_main(int argc, char *argv[]);\nint dict_main(int argc, char *argv[]);\nint fqidx_main(int argc, char *argv[]);\nint amplicon_clip_main(int argc, char *argv[]);\nint main_ampliconstats(int argc, char *argv[]);\nint main_import(int argc, char *argv[]);\nint main_samples(int argc, char *argv[]);\nint main_consensus(int argc, char *argv[]);\nint main_reference(int argc, char *argv[]);\nint main_reset(int argc, char *argv[]);\nint main_cram_size(int argc, char *argv[]);\nint main_checksum(int argc, char *argv[]);\n\nconst char *samtools_version(void)\n{\n    return SAMTOOLS_VERSION;\n}\n\n// These come out of the config.h file built by autoconf or Makefile\nconst char *samtools_feature_string(void) {\n    const char *fmt =\n\n#ifdef PACKAGE_URL\n    \"build=configure \"\n#else\n    \"build=Makefile \"\n#endif\n\n#ifdef HAVE_CURSES\n    \"curses=yes \"\n#else\n    \"curses=no \"\n#endif\n    ;\n\n    return fmt;\n}\n\nstatic void long_version(void) {\n    printf(\"samtools %s\\n\"\n           \"Using htslib %s\\n\"\n           \"Copyright (C) 2024 Genome Research Ltd.\\n\",\n           samtools_version(), hts_version());\n\n    printf(\"\\nSamtools compilation details:\\n\");\n    printf(\"    Features:       %s\\n\", samtools_feature_string());\n    printf(\"    CC:             %s\\n\", SAMTOOLS_CC);\n    printf(\"    CPPFLAGS:       %s\\n\", SAMTOOLS_CPPFLAGS);\n    printf(\"    CFLAGS:         %s\\n\", SAMTOOLS_CFLAGS);\n    printf(\"    LDFLAGS:        %s\\n\", SAMTOOLS_LDFLAGS);\n    printf(\"    HTSDIR:         %s\\n\", SAMTOOLS_HTSDIR);\n    printf(\"    LIBS:           %s\\n\", SAMTOOLS_LIBS);\n    printf(\"    CURSES_LIB:     %s\\n\", SAMTOOLS_CURSES_LIB);\n\n    printf(\"\\nHTSlib compilation details:\\n\");\n    printf(\"    Features:       %s\\n\", hts_feature_string());\n    printf(\"    CC:             %s\\n\", hts_test_feature(HTS_FEATURE_CC));\n    printf(\"    CPPFLAGS:       %s\\n\", hts_test_feature(HTS_FEATURE_CPPFLAGS));\n    printf(\"    CFLAGS:         %s\\n\", hts_test_feature(HTS_FEATURE_CFLAGS));\n    printf(\"    LDFLAGS:        %s\\n\", hts_test_feature(HTS_FEATURE_LDFLAGS));\n\n    // Plugins and schemes\n    printf(\"\\nHTSlib URL scheme handlers present:\\n\");\n    const char *plugins[100];\n    int np = 100, i, j;\n\n    if (hfile_list_plugins(plugins, &np) < 0)\n        return;\n\n    for (i = 0; i < np; i++) {\n        const char *sc_list[100];\n        int nschemes = 100;\n        if (hfile_list_schemes(plugins[i], sc_list, &nschemes) < 0)\n            return;\n\n        printf(\"    %s:\\t\", plugins[i]);\n        for (j = 0; j < nschemes; j++)\n            printf(\" %s%c\", sc_list[j], \",\\n\"[j+1==nschemes]);\n    }\n}\n\nstatic void usage(FILE *fp)\n{\n    /* Please improve the grouping */\n\n    fprintf(fp,\n\"\\n\"\n\"Program: samtools (Tools for alignments in the SAM format)\\n\"\n\"Version: %s (using htslib %s)\\n\\n\", samtools_version(), hts_version());\n    fprintf(fp,\n\"Usage:   samtools <command> [options]\\n\"\n\"\\n\"\n\"Commands:\\n\"\n\"  -- Indexing\\n\"\n\"     dict           create a sequence dictionary file\\n\"\n\"     faidx          index/extract FASTA\\n\"\n\"     fqidx          index/extract FASTQ\\n\"\n\"     index          index alignment\\n\"\n\"\\n\"\n\"  -- Editing\\n\"\n\"     calmd          recalculate MD/NM tags and '=' bases\\n\"\n\"     fixmate        fix mate information\\n\"\n\"     reheader       replace BAM header\\n\"\n\"     targetcut      cut fosmid regions (for fosmid pool only)\\n\"\n\"     addreplacerg   adds or replaces RG tags\\n\"\n\"     markdup        mark duplicates\\n\"\n\"     ampliconclip   clip oligos from the end of reads\\n\"\n\"\\n\"\n\"  -- File operations\\n\"\n\"     collate        shuffle and group alignments by name\\n\"\n\"     cat            concatenate BAMs\\n\"\n\"     consensus      produce a consensus Pileup/FASTA/FASTQ\\n\"\n\"     merge          merge sorted alignments\\n\"\n\"     mpileup        multi-way pileup\\n\"\n\"     sort           sort alignment file\\n\"\n\"     split          splits a file by read group\\n\"\n\"     quickcheck     quickly check if SAM/BAM/CRAM file appears intact\\n\"\n\"     fastq          converts a BAM to a FASTQ\\n\"\n\"     fasta          converts a BAM to a FASTA\\n\"\n\"     import         Converts FASTA or FASTQ files to SAM/BAM/CRAM\\n\"\n\"     reference      Generates a reference from aligned data\\n\"\n\"     reset          Reverts aligner changes in reads\\n\"\n\"\\n\"\n\"  -- Statistics\\n\"\n\"     bedcov         read depth per BED region\\n\"\n\"     coverage       alignment depth and percent coverage\\n\"\n\"     depth          compute the depth\\n\"\n\"     flagstat       simple stats\\n\"\n\"     idxstats       BAM index stats\\n\"\n\"     cram-size      list CRAM Content-ID and Data-Series sizes\\n\"\n\"     phase          phase heterozygotes\\n\"\n\"     stats          generate stats (former bamcheck)\\n\"\n\"     ampliconstats  generate amplicon specific stats\\n\"\n\"     checksum       produce order-agnostic checksums of sequence content\\n\"\n\"\\n\"\n\"  -- Viewing\\n\"\n\"     flags          explain BAM flags\\n\"\n\"     head           header viewer\\n\"\n\"     tview          text alignment viewer\\n\"\n\"     view           SAM<->BAM<->CRAM conversion\\n\"\n\"     depad          convert padded BAM to unpadded BAM\\n\"\n\"     samples        list the samples in a set of SAM/BAM/CRAM files\\n\"\n\"\\n\"\n\"  -- Misc\\n\"\n\"     help [cmd]     display this help message or help for [cmd]\\n\"\n\"     version        detailed version information\\n\"\n\"\\n\");\n}\n\n// This is a tricky one, but on Windows the filename wildcard expansion is done by\n// the application and not by the shell, as traditionally it never had a \"shell\".\n// Even now, DOS and Powershell do not do this expansion (but bash does).\n//\n// This means that Mingw/Msys implements code before main() that takes e.g. \"*\" and\n// expands it up to a list of matching filenames.  This in turn breaks things like\n// specifying \"*\" as a region (all the unmapped reads).  We take a hard line here -\n// filename expansion is the task of the shell, not our application!\n#ifdef _WIN32\nint _CRT_glob = 0;\n#endif\n\nint main(int argc, char *argv[])\n{\n#ifdef _WIN32\n    setmode(fileno(stdout), O_BINARY);\n    setmode(fileno(stdin),  O_BINARY);\n#endif\n    if (argc < 2) { usage(stderr); return 1; }\n\n    if (strcmp(argv[1], \"help\") == 0 || strcmp(argv[1], \"--help\") == 0) {\n        if (argc == 2) { usage(stdout); return 0; }\n\n        // Otherwise change \"samtools help COMMAND [...]\" to \"samtools COMMAND\";\n        // main_xyz() functions by convention display the subcommand's usage\n        // when invoked without any arguments.\n        argv++;\n        argc = 2;\n    }\n\n    int ret = 0;\n    if (strcmp(argv[1], \"view\") == 0)           ret = main_samview(argc-1, argv+1);\n    else if (strcmp(argv[1], \"import\") == 0)    ret = main_import(argc-1, argv+1);\n    else if (strcmp(argv[1], \"mpileup\") == 0)   ret = bam_mpileup(argc-1, argv+1);\n    else if (strcmp(argv[1], \"merge\") == 0)     ret = bam_merge(argc-1, argv+1);\n    else if (strcmp(argv[1], \"sort\") == 0)      ret = bam_sort(argc-1, argv+1);\n    else if (strcmp(argv[1], \"index\") == 0)     ret = bam_index(argc-1, argv+1);\n    else if (strcmp(argv[1], \"idxstat\") == 0 ||\n             strcmp(argv[1], \"idxstats\") == 0)  ret = bam_idxstats(argc-1, argv+1);\n    else if (strcmp(argv[1], \"faidx\") == 0)     ret = faidx_main(argc-1, argv+1);\n    else if (strcmp(argv[1], \"fqidx\") == 0)     ret = fqidx_main(argc-1, argv+1);\n    else if (strcmp(argv[1], \"dict\") == 0)      ret = dict_main(argc-1, argv+1);\n    else if (strcmp(argv[1], \"head\") == 0)      ret = main_head(argc-1, argv+1);\n    else if (strcmp(argv[1], \"fixmate\") == 0)   ret = bam_mating(argc-1, argv+1);\n    else if (strcmp(argv[1], \"rmdup\") == 0)     ret = bam_rmdup(argc-1, argv+1);\n    else if (strcmp(argv[1], \"markdup\") == 0)   ret = bam_markdup(argc-1, argv+1);\n    else if (strcmp(argv[1], \"ampliconclip\") == 0) ret = amplicon_clip_main(argc-1, argv+1);\n    else if (strcmp(argv[1], \"flagstat\") == 0 ||\n             strcmp(argv[1], \"flagstats\") == 0) ret = bam_flagstat(argc-1, argv+1);\n    else if (strcmp(argv[1], \"calmd\") == 0)     ret = bam_fillmd(argc-1, argv+1);\n    else if (strcmp(argv[1], \"fillmd\") == 0)    ret = bam_fillmd(argc-1, argv+1);\n    else if (strcmp(argv[1], \"reheader\") == 0)  ret = main_reheader(argc-1, argv+1);\n    else if (strcmp(argv[1], \"cat\") == 0)       ret = main_cat(argc-1, argv+1);\n    else if (strcmp(argv[1], \"targetcut\") == 0) ret = main_cut_target(argc-1, argv+1);\n    else if (strcmp(argv[1], \"phase\") == 0)     ret = main_phase(argc-1, argv+1);\n    else if (strcmp(argv[1], \"depth\") == 0)     ret = main_depth(argc-1, argv+1);\n    else if (strcmp(argv[1], \"coverage\") == 0)  ret = main_coverage(argc-1, argv+1);\n    else if (strcmp(argv[1], \"bam2fq\") == 0 ||\n             strcmp(argv[1], \"fastq\") == 0 ||\n             strcmp(argv[1], \"fasta\") == 0)     ret = main_bam2fq(argc-1, argv+1);\n    else if (strcmp(argv[1], \"pad2unpad\") == 0) ret = main_pad2unpad(argc-1, argv+1);\n    else if (strcmp(argv[1], \"depad\") == 0)     ret = main_pad2unpad(argc-1, argv+1);\n    else if (strcmp(argv[1], \"bedcov\") == 0)    ret = main_bedcov(argc-1, argv+1);\n    else if (strcmp(argv[1], \"bamshuf\") == 0)   ret = main_bamshuf(argc-1, argv+1);\n    else if (strcmp(argv[1], \"collate\") == 0)   ret = main_bamshuf(argc-1, argv+1);\n    else if (strcmp(argv[1], \"stat\") == 0 ||\n             strcmp(argv[1], \"stats\") == 0)     ret = main_stats(argc-1, argv+1);\n    else if (strcmp(argv[1], \"flag\") == 0 ||\n             strcmp(argv[1], \"flags\") == 0)     ret = main_flags(argc-1, argv+1);\n    else if (strcmp(argv[1], \"split\") == 0)     ret = main_split(argc-1, argv+1);\n    else if (strcmp(argv[1], \"quickcheck\") == 0)  ret = main_quickcheck(argc-1, argv+1);\n    else if (strcmp(argv[1], \"addreplacerg\") == 0) ret = main_addreplacerg(argc-1, argv+1);\n    else if (strcmp(argv[1], \"pileup\") == 0) {\n        fprintf(stderr, \"[main] The `pileup' command has been removed. Please use `mpileup' instead.\\n\");\n        return 1;\n    }\n    else if (strcmp(argv[1], \"tview\") == 0)   ret = bam_tview_main(argc-1, argv+1);\n    else if (strcmp(argv[1], \"ampliconstats\") == 0)     ret = main_ampliconstats(argc-1, argv+1);\n    else if (strcmp(argv[1], \"samples\") == 0)     ret = main_samples(argc-1, argv+1);\n    else if (strcmp(argv[1], \"consensus\") == 0) ret = main_consensus(argc-1, argv+1);\n    else if (strcmp(argv[1], \"reference\") == 0) ret = main_reference(argc-1, argv+1);\n    else if (strcmp(argv[1], \"cram-size\") == 0) ret = main_cram_size(argc-1, argv+1);\n    else if (strcmp(argv[1], \"checksum\") == 0) ret = main_checksum(argc-1, argv+1);\n    else if (strcmp(argv[1], \"version\") == 0 || \\\n             strcmp(argv[1], \"--version\") == 0)\n        long_version();\n    else if (strcmp(argv[1], \"--version-only\") == 0) {\n        printf(\"%s+htslib-%s\\n\", samtools_version(), hts_version());\n    }\n    else if (strcmp(argv[1], \"reset\") == 0) ret = main_reset(argc-1, argv+1);\n    else {\n        fprintf(stderr, \"[main] unrecognized command '%s'\\n\", argv[1]);\n        return 1;\n    }\n\n    // For subcommands that may have produced substantial output on stdout,\n    // make a final check for delayed I/O errors. Ignore EBADF as other code\n    // may have already closed stdout.\n    if (fclose(stdout) != 0 && errno != EBADF) {\n        print_error_errno(argv[1], \"closing standard output failed\");\n        return 1;\n    }\n\n    return ret;\n}\n"
        },
        {
          "name": "bedcov.c",
          "type": "blob",
          "size": 13.6240234375,
          "content": "/*  bedcov.c -- bedcov subcommand.\n\n    Copyright (C) 2012 Broad Institute.\n    Copyright (C) 2013-2014, 2018-2022, 2024 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <zlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"htslib/kstring.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/thread_pool.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\n#include \"htslib/kseq.h\"\nKSTREAM_INIT(gzFile, gzread, 16384)\n\n#define DEFAULT_DEPTH INT_MAX\n\ntypedef struct {\n    htsFile *fp;\n    sam_hdr_t *header;\n    hts_itr_t *iter;\n    int min_mapQ;\n    uint32_t flags;  // read filtering flags\n    int64_t rcnt;\n} aux_t;\n\n#define HDR_CHROM \"#chrom\\t\"\n\nstatic int read_bam(void *data, bam1_t *b)\n{\n    aux_t *aux = (aux_t*)data; // data in fact is a pointer to an auxiliary structure\n    int ret;\n    while (1)\n    {\n        ret = aux->iter? sam_itr_next(aux->fp, aux->iter, b) :\n            sam_read1(aux->fp, aux->header, b);\n        if ( ret<0 ) break;\n        if ( b->core.flag & aux->flags ) continue;\n        if ( (int)b->core.qual < aux->min_mapQ ) continue;\n        break;\n    }\n    return ret;\n}\n\nstatic int incr_rcnt(void *data, const bam1_t *b, bam_pileup_cd *cd) {\n    aux_t *aux = (aux_t *)data;\n    aux->rcnt++;\n    return 0;\n}\n\n/// output_header - dump the header in output\n/** @param fp     - pointer to output file\n*   @param hdr    - header from bed file, when it has one\n*   @param fields - field count to fill with \\t when it doesn't have a header\n*   @param filecount - no. of input files\n*   @param argv   - input files, for header naming\n*   @param depth  - depth threshold configuration\n*   @param rcount - show read count configuration\n* returns nothing\n*/\nstatic void output_header(FILE *fp, char *hdr, int fields, int filecount,\n    char *argv[], int depth, int rcount)\n{\n    int i = 0;\n    if (hdr) {  //header available from bed file\n        fprintf(fp, \"%s\", hdr);\n    } else {\n        /* no header in bed, add one. add headers as defined in format.\n        use empty header with tab separation for fields above those defined in\n        format */\n        char *bedcols[] = { \"chrom\", \"chromStart\", \"chromEnd\", \"name\", \"score\",\n            \"strand\", \"thickStart\", \"thickEnd\", \"itemRgb\", \"blockCount\",\n            \"blockSizes\", \"blockStarts\"};\n        for (i = 0; i < fields; ++i) {\n            fprintf(fp, \"%s%s\", (i ? \"\\t\" : \"#\"),\n                (i < sizeof(bedcols)/sizeof(bedcols[i]) ? bedcols[i] : \".\"));\n        }\n    }\n    for (i = 0; i < filecount; ++i) {   //coverage header\n        fprintf(fp, \"\\t%s_cov\", argv[i + optind + 1]);\n    }\n    if (depth >= 0) {                   //depth header\n        for (i = 0; i < filecount; ++i) {\n            fprintf(fp, \"\\t%s_depth\", argv[i + optind + 1]);\n        }\n    }\n    if (rcount) {                       //read count header\n        for (i = 0; i < filecount; ++i) {\n            fprintf(fp, \"\\t%s_count\", argv[i + optind + 1]);\n        }\n    }\n    fprintf(fp, \"\\n\");\n}\n\nint main_bedcov(int argc, char *argv[])\n{\n    gzFile fp;\n    kstring_t str;\n    kstream_t *ks;\n    hts_idx_t **idx;\n    aux_t **aux;\n    int *n_plp, dret, i, j, m, n, c, ret, status = 0, min_mapQ = 0;\n    int skip_DN = 0, do_rcount = 0;\n    int64_t *cnt, *pcov = NULL;\n    const bam_pileup1_t **plp;\n    int usage = 0, has_index_file = 0;\n    uint32_t flags = (BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP);\n    int tflags = 0, min_depth = -1, max_depth = DEFAULT_DEPTH, print_header=0,\n        hdr = 0;\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        {\"min-MQ\", required_argument, NULL, 'Q'},\n        {\"min-mq\", required_argument, NULL, 'Q'},\n        {\"max-depth\", required_argument, NULL, 'd'+1000},\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 0, '-'),\n        { NULL, 0, NULL, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \"Q:Xg:G:jd:Hc\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'Q': min_mapQ = atoi(optarg); break;\n        case 'X': has_index_file = 1; break;\n        case 'c': do_rcount = 1; break;\n        case 'H': print_header = 1; break;\n        case 'g':\n            tflags = bam_str2flag(optarg);\n            if (tflags < 0 || tflags > ((BAM_FSUPPLEMENTARY << 1) - 1)) {\n                print_error(\"bedcov\", \"Flag value \\\"%s\\\" is not supported\", optarg);\n                return 1;\n            }\n            flags &= ~tflags;\n            break;\n        case 'G':\n            tflags = bam_str2flag(optarg);\n            if (tflags < 0 || tflags > ((BAM_FSUPPLEMENTARY << 1) - 1)) {\n                print_error(\"bedcov\", \"Flag value \\\"%s\\\" is not supported\", optarg);\n                return 1;\n            }\n            flags |= tflags;\n            break;\n        case 'j': skip_DN = 1; break;\n        case 'd': min_depth = atoi(optarg); break;\n        case 'd'+1000: max_depth = atoi(optarg); break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                  /* else fall-through */\n        case '?': usage = 1; break;\n        }\n        if (usage) break;\n    }\n    if (usage || optind + 2 > argc) {\n        fprintf(stderr, \"Usage: samtools bedcov [options] <in.bed> <in1.bam> [...]\\n\\n\");\n        fprintf(stderr, \"Options:\\n\");\n        fprintf(stderr, \"      -Q, --min-MQ <int>  mapping quality threshold [0]\\n\");\n        fprintf(stderr, \"      -X                  use customized index files\\n\");\n        fprintf(stderr, \"      -g <flags>          remove the specified flags from the set used to filter out reads\\n\");\n        fprintf(stderr, \"      -G <flags>          add the specified flags to the set used to filter out reads\\n\"\n                        \"                          The default set is UNMAP,SECONDARY,QCFAIL,DUP or 0x704\\n\");\n        fprintf(stderr, \"      -j                  do not include deletions (D) and ref skips (N) in bedcov computation\\n\");\n        fprintf(stderr, \"      --max-depth <int>   sets the maximum depth used in the mpileup algorithm\\n\");\n        fprintf(stderr, \"      -d <int>            depth threshold. Number of reference bases with coverage above and\\n\"\n                        \"                          including this value will be displayed in a separate column\\n\");\n        fprintf(stderr, \"      -c                  add an additional column showing read count\\n\");\n        fprintf(stderr, \"      -H                  print a comment/header line with column information.\\n\");\n        sam_global_opt_help(stderr, \"-.--.--.\");\n        return 1;\n    }\n    if (has_index_file) {\n        if ((argc - optind - 1) % 2 != 0) { // Calculate # of input BAM files\n            fprintf(stderr, \"ERROR: odd number of filenames detected! Each BAM file should have an index file\\n\");\n            return 1;\n        }\n        n = (argc - optind - 1) / 2;\n    } else {\n        n = argc - optind - 1;\n    }\n\n    if (!print_header) { // no header output needed, avoid check for header line\n        hdr = 1;\n    }\n    memset(&str, 0, sizeof(kstring_t));\n    aux = calloc(n, sizeof(aux_t*));\n    idx = calloc(n, sizeof(hts_idx_t*));\n    for (i = 0; i < n; ++i) {\n        aux[i] = calloc(1, sizeof(aux_t));\n        aux[i]->min_mapQ = min_mapQ;\n        aux[i]->fp = sam_open_format(argv[i+optind+1], \"r\", &ga.in);\n        if (aux[i]->fp) {\n            // If index filename has not been specfied, look in BAM folder\n            if (has_index_file) {\n                idx[i] = sam_index_load2(aux[i]->fp, argv[i+optind+1], argv[i+optind+n+1]);\n            } else {\n                idx[i] = sam_index_load(aux[i]->fp, argv[i+optind+1]);\n            }\n        }\n        if (aux[i]->fp == 0 || idx[i] == 0) {\n            fprintf(stderr, \"ERROR: fail to open index BAM file '%s'\\n\", argv[i+optind+1]);\n            return 2;\n        }\n        // TODO bgzf_set_cache_size(aux[i]->fp, 20);\n        aux[i]->header = sam_hdr_read(aux[i]->fp);\n        if (aux[i]->header == NULL) {\n            fprintf(stderr, \"ERROR: failed to read header for '%s'\\n\",\n                    argv[i+optind+1]);\n            return 2;\n        }\n        aux[i]->flags = flags;\n    }\n    cnt = calloc(n, sizeof(*cnt));\n\n    if (min_depth >= 0) pcov = calloc(n, sizeof(*pcov));\n    if (!cnt || (min_depth >= 0 && !pcov)) {\n        print_error_errno(\"bedcov\", \"failed to allocate memory\");\n        return 2;\n    }\n\n    fp = gzopen(argv[optind], \"rb\");\n    if (fp == NULL) {\n        print_error_errno(\"bedcov\", \"can't open BED file '%s'\", argv[optind]);\n        return 2;\n    }\n\n    ks = ks_init(fp);\n    n_plp = calloc(n, sizeof(int));\n    plp = calloc(n, sizeof(bam_pileup1_t*));\n    while (ks_getuntil(ks, KS_SEP_LINE, &str, &dret) >= 0) {\n        char *p, *q;\n        int tid, pos, num = 0;\n        int64_t beg = 0, end = 0;\n        bam_mplp_t mplp;\n\n        if (str.l == 0) {\n            continue; /* empty */\n        }\n        if (*str.s == '#') { // header or comment\n            if (!hdr && !strncmp(str.s, HDR_CHROM, sizeof(HDR_CHROM) - 1)) {\n                //header line and header output set\n                output_header(stdout, str.s, -1, n, argv, min_depth, do_rcount);\n                hdr = 1;\n            }\n            continue; // comment line or header\n        }\n        /* Track and browser lines.  Also look for a trailing *space* in\n           case someone has badly-chosen a chromosome name (it would\n           be followed by a tab in that case). */\n        if (strncmp(str.s, \"track \", 6) == 0) continue;\n        if (strncmp(str.s, \"browser \", 8) == 0) continue;\n        if (!hdr) {\n            //no header line, header output set, find no of fields from bed line\n            //no header line yet and need header, find no of fields in bed line\n            int fields = 0;\n            char *tmp = str.s;\n            while (*tmp) {\n                if (*tmp++ == '\\t') {\n                    fields++;\n                }\n            }\n            output_header(stdout, NULL, fields + 1, n, argv, min_depth, do_rcount);\n            hdr = 1;\n            //continue the processing of bed data line\n        }\n        for (p = q = str.s; *p && !isspace(*p); ++p);\n        if (*p == 0) goto bed_error;\n        char c = *p;\n        *p = 0; tid = bam_name2id(aux[0]->header, q); *p = c;\n        if (tid < 0) goto bed_error;\n        num = sscanf(p + 1, \"%\"SCNd64\" %\"SCNd64, &beg, &end);\n        if (num < 2 || end < beg) goto bed_error;\n\n        for (i = 0; i < n; ++i) {\n            if (aux[i]->iter) hts_itr_destroy(aux[i]->iter);\n            aux[i]->iter = sam_itr_queryi(idx[i], tid, beg, end);\n            aux[i]->rcnt = 0;\n        }\n\n        mplp = bam_mplp_init(n, read_bam, (void**)aux);\n        if (min_depth > max_depth)\n            // NB: never happens given current DEFAULT_DEPTH of INT_MAX\n            bam_mplp_set_maxcnt(mplp, min_depth);\n        else\n            bam_mplp_set_maxcnt(mplp, max_depth);\n\n        memset(cnt, 0, sizeof(*cnt) * n);\n        if (min_depth >= 0) memset(pcov, 0, sizeof(*pcov) * n);\n\n        if (do_rcount)\n            bam_mplp_constructor(mplp, incr_rcnt);\n\n        while ((ret = bam_mplp_auto(mplp, &tid, &pos, n_plp, plp)) > 0)\n            if (pos >= beg && pos < end) {\n                for (i = 0; i < n; ++i) {\n                    m = 0;\n                    if (skip_DN || min_depth >= 0) {\n                        for (j = 0; j < n_plp[i]; ++j) {\n                            const bam_pileup1_t *pi = plp[i] + j;\n                            if (pi->is_del || pi->is_refskip) ++m;\n                        }\n                    }\n                    int pd = n_plp[i] - m;\n                    cnt[i] += pd;\n                    if (min_depth >= 0 && pd >= min_depth) pcov[i]++;\n                }\n            }\n\n        if (ret < 0) {\n            print_error(\"bedcov\", \"error reading from input file\");\n            status = 2;\n            bam_mplp_destroy(mplp);\n            break;\n        }\n\n        for (i = 0; i < n; ++i) {\n            kputc('\\t', &str);\n            kputl(cnt[i], &str);\n        }\n        if (min_depth >= 0) {\n            for (i = 0; i < n; ++i) {\n                kputc('\\t', &str);\n                kputl(pcov[i], &str);\n            }\n        }\n        if (do_rcount) {\n            for (i = 0; i < n; ++i) {\n                kputc('\\t', &str);\n                kputl(aux[i]->rcnt, &str);\n            }\n        }\n        puts(str.s);\n        bam_mplp_destroy(mplp);\n        continue;\n\nbed_error:\n        fprintf(stderr, \"Errors in BED line '%s'\\n\", str.s);\n        status = 2;\n    }\n    free(n_plp); free(plp);\n    ks_destroy(ks);\n    gzclose(fp);\n\n    free(cnt);\n    free(pcov);\n    for (i = 0; i < n; ++i) {\n        if (aux[i]->iter) hts_itr_destroy(aux[i]->iter);\n        hts_idx_destroy(idx[i]);\n        sam_hdr_destroy(aux[i]->header);\n        sam_close(aux[i]->fp);\n        free(aux[i]);\n    }\n    free(aux); free(idx);\n    free(str.s);\n    sam_global_args_free(&ga);\n    return status;\n}\n"
        },
        {
          "name": "bedidx.c",
          "type": "blob",
          "size": 19.572265625,
          "content": "/*  bedidx.c -- BED file indexing.\n\n    Copyright (C) 2011 Broad Institute.\n    Copyright (C) 2014, 2017-2019, 2024 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <zlib.h>\n#include \"bedidx.h\"\n\n#include \"htslib/ksort.h\"\n\n#include \"htslib/kseq.h\"\nKSTREAM_INIT(gzFile, gzread, 8192)\n\nstatic inline int lt_pair_pos(hts_pair_pos_t a, hts_pair_pos_t b) {\n    if (a.beg == b.beg) return a.end < b.end;\n    return a.beg < b.beg;\n}\nKSORT_INIT_STATIC(hts_pair_pos_t, hts_pair_pos_t, lt_pair_pos)\n\n/*! @typedef\n * @abstract bed_reglist_t - value type of the BED hash table\n * This structure encodes the list of intervals (ranges) for the regions provided via BED file or\n * command line arguments.\n * @field *a           pointer to the array of intervals.\n * @field n            actual number of elements contained by a\n * @field m            number of allocated elements to a (n <= m)\n * @field *idx         index array for computing the minimum offset\n */\ntypedef struct {\n    int n, m;\n    hts_pair_pos_t *a;\n    int *idx;\n    int filter;\n    hts_pos_t max_idx;\n} bed_reglist_t;\n\n#include \"htslib/khash.h\"\nKHASH_MAP_INIT_STR(reg, bed_reglist_t)\n\ntypedef kh_reg_t reghash_t;\n\n#if 0\n// Debug function\nstatic void bed_print(void *reg_hash) {\n    reghash_t *h = (reghash_t *)reg_hash;\n    bed_reglist_t *p;\n    khint_t k;\n    int i;\n    const char *reg;\n\n    if (!h) {\n        printf(\"Hash table is empty!\\n\");\n        return;\n    }\n    for (k = kh_begin(h); k < kh_end(h); k++) {\n        if (kh_exist(h,k)) {\n            reg = kh_key(h,k);\n            printf(\"Region: '%s'\\n\", reg);\n            if ((p = &kh_val(h,k)) != NULL && p->n > 0) {\n                printf(\"Filter: %d\\n\", p->filter);\n                for (i=0; i<p->n; i++) {\n                    printf(\"\\tinterval[%d]: %\"PRIhts_pos\"-%\"PRIhts_pos\"\\n\",\n                           i,p->a[i].beg,p->a[i].end);\n                }\n            } else {\n                printf(\"Region '%s' has no intervals!\\n\", reg);\n            }\n        }\n    }\n}\n#endif\n\nstatic int bed_index_core(bed_reglist_t *regions)\n{\n    int i, *idx = NULL;\n    size_t idx_size = 0;\n    hts_pos_t last_end = 0;\n    hts_pair_pos_t *a = regions->a;\n\n    // Construct a linear index on regions, to allow rapid lookup of\n    // where to start searching for matches\n    for (i = 0; i < regions->n; ++i) {\n        hts_pos_t beg = a[i].beg >= 0 ? a[i].beg >> LIDX_SHIFT : 0;\n        hts_pos_t end = a[i].end >= 0 ? a[i].end >> LIDX_SHIFT : 0;\n        hts_pos_t j;\n        if (end < last_end)\n            continue;  // Can happen for a containment\n        if (end + 1 >= SIZE_MAX / sizeof(*idx)) { // Ensure no overflow\n            errno = ENOMEM;\n            free(idx);\n            return -1;\n        }\n        if (hts_resize(int, (size_t) end + 1, &idx_size, &idx, 0) < 0) {\n            free(idx);\n            return -1;\n        }\n        // Fill any gap prior to this region by pointing to the previous one\n        for (j = last_end; j < beg; j++)\n            idx[j] = i > 0 ? i - 1 : 0;\n        // Fill from max(last_end, beg) to `end` (inclusive) with current region\n        for (; j <= end; j++)\n            idx[j] = i;\n        // Remember where finished for the next gap\n        last_end = end + 1;\n    }\n    regions->idx = idx;\n    regions->max_idx = last_end;\n    return 0;\n}\n\nstatic int bed_index(reghash_t *h)\n{\n    khint_t k;\n    for (k = 0; k < kh_end(h); ++k) {\n        if (kh_exist(h, k)) {\n            bed_reglist_t *p = &kh_val(h, k);\n            if (p->idx) {\n                free(p->idx);\n                p->idx = NULL;\n            }\n            ks_introsort(hts_pair_pos_t, p->n, p->a);\n            if (bed_index_core(p) != 0) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int bed_minoff(const bed_reglist_t *p, hts_pos_t beg) {\n    int min_off=0;\n\n    if (p && p->idx && p->max_idx > 0 && beg >= 0) {\n        min_off = (beg>>LIDX_SHIFT >= p->max_idx)? p->idx[p->max_idx-1] : p->idx[beg>>LIDX_SHIFT];\n    }\n\n    return min_off;\n}\n\nstatic int bed_overlap_core(const bed_reglist_t *p, hts_pos_t beg, hts_pos_t end)\n{\n    int i, min_off;\n    if (p->n == 0) return 0;\n    min_off = bed_minoff(p, beg);\n\n    for (i = min_off; i < p->n; ++i) {\n        if (p->a[i].beg >= end) break; // out of range; no need to proceed\n        if (p->a[i].end > beg && p->a[i].beg < end)\n            return 1; // find the overlap; return\n    }\n    return 0;\n}\n\nint bed_overlap(const void *_h, const char *chr, hts_pos_t beg, hts_pos_t end)\n{\n    const reghash_t *h = (const reghash_t*)_h;\n    khint_t k;\n    if (!h) return 0;\n    k = kh_get(reg, h, chr);\n    if (k == kh_end(h)) return 0;\n    return bed_overlap_core(&kh_val(h, k), beg, end);\n}\n\n/** @brief Trim a sorted interval list, inside a region hash table,\n *   by removing completely contained intervals and merging adjacent or\n *   overlapping intervals.\n *  @param reg_hash    the region hash table with interval lists as values\n */\n\nvoid bed_unify(void *reg_hash) {\n\n    int i, j, new_n;\n    reghash_t *h;\n    bed_reglist_t *p;\n\n    if (!reg_hash)\n        return;\n\n    h = (reghash_t *)reg_hash;\n\n    for (i = kh_begin(h); i < kh_end(h); i++) {\n        if (!kh_exist(h,i) || !(p = &kh_val(h,i)) || !(p->n))\n            continue;\n\n        for (new_n = 0, j = 1; j < p->n; j++) {\n            if (p->a[new_n].end < p->a[j].beg) {\n                p->a[++new_n] = p->a[j];\n            } else {\n                if (p->a[new_n].end < p->a[j].end)\n                    p->a[new_n].end = p->a[j].end;\n            }\n        }\n\n        p->n = ++new_n;\n    }\n}\n\n/* \"BED\" file reader, which actually reads two different formats.\n\n   BED files contain between three and nine fields per line, of which\n   only the first three (reference, start, end) are of interest to us.\n   BED counts positions from base 0, and the end is the base after the\n   region of interest.  While not properly documented in the specification,\n   it is also possible to have 'browser' and 'track' lines in BED files that\n   do not follow the standard format and should be ignored.  Examination\n   of the BED file reading code in\n   http://genome-source.cse.ucsc.edu/gitweb/?p=kent.git shows that BED\n   files can also have comment lines starting with '#', leading whitespace\n   is stripped, and that fields are separated by one or more consecutive\n   whitespace characters.\n\n   The alternative format was originally for reading positions in VCF\n   format.  This expects two columns, which indicate the reference and\n   a position.  The position corresponds to a single base, and unlike\n   BED counts from 1.\n\n   Which format is in use is determined based on whether one or two\n   numbers can be decoded on the line.  As this choice is made line-by-line\n   in this implementation, it is possible (but probably a bad idea) to mix\n   both formats in the same file.  If trying to read a VCF file by this\n   method, it would be important to ensure that the third column (ID) does\n   not contain any entries that start with a digit, to avoid the line\n   erroneously being parsed as a BED file entry.\n\n   The BED specification is at http://www.genome.ucsc.edu/FAQ/FAQformat.html\n   The VCF specification is at https://github.com/samtools/hts-specs\n */\n\nvoid *bed_read(const char *fn)\n{\n    reghash_t *h = kh_init(reg);\n    gzFile fp;\n    kstream_t *ks = NULL;\n    int dret;\n    unsigned int line = 0, save_errno;\n    kstring_t str = { 0, 0, NULL };\n\n    if (NULL == h) return NULL;\n    // read the list\n    fp = strcmp(fn, \"-\")? gzopen(fn, \"r\") : gzdopen(fileno(stdin), \"r\");\n    if (fp == 0) goto fail;\n    ks = ks_init(fp);\n    if (NULL == ks) goto fail;  // In case ks_init ever gets error checking...\n    int ks_len;\n    while ((ks_len = ks_getuntil(ks, KS_SEP_LINE, &str, &dret)) >= 0) { // read a line\n        char *ref = str.s, *ref_end;\n        uint64_t beg = 0, end = 0;\n        int num = 0;\n        khint_t k;\n        bed_reglist_t *p;\n\n        if (ks_len == 0)\n            continue; // skip blank lines\n\n        line++;\n        while (*ref && isspace(*ref)) ref++;\n        if ('\\0' == *ref) continue;  // Skip blank lines\n        if ('#'  == *ref) continue;  // Skip BED file comments\n        ref_end = ref;   // look for the end of the reference name\n        while (*ref_end && !isspace(*ref_end)) ref_end++;\n        if ('\\0' != *ref_end) {\n            *ref_end = '\\0';  // terminate ref and look for start, end\n            num = sscanf(ref_end + 1, \"%\"SCNu64\" %\"SCNu64, &beg, &end);\n        }\n        if (1 == num) {  // VCF-style format\n            end = beg--; // Counts from 1 instead of 0 for BED files\n        }\n        if (num < 1 || end < beg) {\n            // These two are special lines that can occur in BED files.\n            // Check for them here instead of earlier in case someone really\n            // has called their reference \"browser\" or \"track\".\n            if (0 == strcmp(ref, \"browser\")) continue;\n            if (0 == strcmp(ref, \"track\")) continue;\n            if (num < 1) {\n                fprintf(stderr,\n                        \"[bed_read] Parse error reading \\\"%s\\\" at line %u\\n\",\n                        fn, line);\n            } else {\n                fprintf(stderr,\n                        \"[bed_read] Parse error reading \\\"%s\\\" at line %u : \"\n                        \"end (%\"PRIu64\") must not be less \"\n                        \"than start (%\"PRIu64\")\\n\",\n                        fn, line, end, beg);\n            }\n            errno = 0; // Prevent caller from printing misleading error messages\n            goto fail;\n        }\n\n        // Put reg in the hash table if not already there\n        k = kh_get(reg, h, ref);\n        if (k == kh_end(h)) { // absent from the hash table\n            int ret;\n            char *s = strdup(ref);\n            if (NULL == s) goto fail;\n            k = kh_put(reg, h, s, &ret);\n            if (-1 == ret) {\n                free(s);\n                goto fail;\n            }\n            memset(&kh_val(h, k), 0, sizeof(bed_reglist_t));\n        }\n        p = &kh_val(h, k);\n\n        // Add begin,end to the list\n        if (p->n == p->m) {\n            p->m = p->m ? p->m<<1 : 4;\n            hts_pair_pos_t *new_a = realloc(p->a, p->m * sizeof(p->a[0]));\n            if (NULL == new_a) goto fail;\n            p->a = new_a;\n        }\n        p->a[p->n].beg = beg;\n        p->a[p->n++].end = end;\n    }\n    // FIXME: Need to check for errors in ks_getuntil.  At the moment it\n    // doesn't look like it can return one.  Possibly use gzgets instead?\n\n    if (gzclose(fp) != Z_OK) {\n        fp = NULL;\n        goto fail;\n    }\n    if (bed_index(h) != 0)\n        goto fail;\n    ks_destroy(ks);\n    free(str.s);\n    //bed_unify(h);\n    return h;\n fail:\n    save_errno = errno;\n    if (ks) ks_destroy(ks);\n    if (fp) gzclose(fp);\n    free(str.s);\n    bed_destroy(h);\n    errno = save_errno;\n    return NULL;\n}\n\nvoid bed_destroy(void *_h)\n{\n    reghash_t *h;\n    khint_t k;\n\n    if (!_h)\n        return;\n\n    h = (reghash_t*)_h;\n    for (k = 0; k < kh_end(h); ++k) {\n        if (kh_exist(h, k)) {\n            free(kh_val(h, k).a);\n            free(kh_val(h, k).idx);\n            free((char*)kh_key(h, k));\n        }\n    }\n    kh_destroy(reg, h);\n}\n\nstatic void *bed_insert(void *reg_hash, char *reg, hts_pos_t beg, hts_pos_t end) {\n\n    reghash_t *h;\n    khint_t k;\n    bed_reglist_t *p;\n\n    if (!reg_hash)\n        return NULL;\n\n    h = (reghash_t *)reg_hash;\n\n    // Put reg in the hash table if not already there\n    k = kh_get(reg, h, reg); //looks strange, but only the second reg is the actual region name.\n    if (k == kh_end(h)) { // absent from the hash table\n        int ret;\n        char *s = strdup(reg);\n        if (NULL == s) goto fail;\n        k = kh_put(reg, h, s, &ret);\n        if (-1 == ret) {\n            free(s);\n            goto fail;\n        }\n        memset(&kh_val(h, k), 0, sizeof(bed_reglist_t));\n    }\n    p = &kh_val(h, k);\n\n    // Add beg and end to the list\n    if (p->n == p->m) {\n        p->m = p->m ? p->m<<1 : 4;\n        hts_pair_pos_t *new_a = realloc(p->a, p->m * sizeof(p->a[0]));\n        if (NULL == new_a) goto fail;\n        p->a = new_a;\n    }\n    p->a[p->n].beg = beg;\n    p->a[p->n++].end = end;\n\nfail:\n    return h;\n}\n\n/* @brief Filter a region hash table (coming from the BED file) by another\n *  region hash table (coming from CLI), so that only intervals contained in\n *  both hash tables are kept.\n * @param reg_hash    the target region hash table\n * @param tmp_hash    the filter region hash table\n * @return            pointer to the filtered hash table\n */\n\nstatic void *bed_filter(void *reg_hash, void *tmp_hash) {\n\n    reghash_t *h;\n    reghash_t *t;\n    bed_reglist_t *p, *q;\n    khint_t l, k;\n    hts_pair_pos_t *new_a;\n    int i, j, new_n, min_off;\n    const char *reg;\n    hts_pos_t beg, end;\n\n    h = (reghash_t *)reg_hash;\n    t = (reghash_t *)tmp_hash;\n    if (!h)\n        return NULL;\n    if (!t)\n        return h;\n\n    for (l = kh_begin(t); l < kh_end(t); l++) {\n        if (!kh_exist(t,l) || !(q = &kh_val(t,l)) || !(q->n))\n            continue;\n\n        reg = kh_key(t,l);\n        k = kh_get(reg, h, reg); //looks strange, but only the second reg is a proper argument.\n        if (k == kh_end(h) || !(p = &kh_val(h, k)) || !(p->n))\n            continue;\n\n        new_a = calloc(q->n + p->n, sizeof(new_a[0]));\n        if (!new_a)\n            return NULL;\n        new_n = 0;\n\n        for (i = 0; i < q->n; i++) {\n            beg = q->a[i].beg;\n            end = q->a[i].end;\n\n            min_off = bed_minoff(p, beg);\n            for (j = min_off; j < p->n; ++j) {\n                if (p->a[j].beg >= end) break; // out of range; no need to proceed\n                if (p->a[j].end > beg && p->a[j].beg < end) {\n                    new_a[new_n].beg = MAX(p->a[j].beg, beg);\n                    new_a[new_n++].end = MIN(p->a[j].end, end);\n                }\n            }\n        }\n\n        if (new_n > 0) {\n            free(p->a);\n            p->a = new_a;\n            p->n = new_n;\n            p->m = new_n;\n            p->filter = FILTERED;\n        } else {\n            free(new_a);\n            p->filter = ALL;\n        }\n    }\n\n    return h;\n}\n\nvoid *bed_hash_regions(void *reg_hash, char **regs, int first, int last, int *op) {\n\n    reghash_t *h = (reghash_t *)reg_hash;\n    reghash_t *t = NULL;\n\n    int i;\n    char reg[1024];\n    const char *q;\n    int beg, end;\n\n    if (h) {\n        t = kh_init(reg);\n        if (!t) {\n            fprintf(stderr, \"Error when creating the temporary region hash table!\\n\");\n            return NULL;\n        }\n    } else {\n        h = kh_init(reg);\n        if (!h) {\n            fprintf(stderr, \"Error when creating the region hash table!\\n\");\n            return NULL;\n        }\n        *op = 1;\n    }\n\n    for (i=first; i<last; i++) {\n\n        // Note, ideally we would call sam_parse_region here, but it's complicated by not\n        // having the sam header known and the likelihood of the bed file containing data for other\n        // references too which we currently just ignore.\n        //\n        // TO DO...\n        q = hts_parse_reg(regs[i], &beg, &end);\n        if (q) {\n            if ((int)(q - regs[i] + 1) > 1024) {\n                fprintf(stderr, \"Region name '%s' is too long (bigger than %d).\\n\", regs[i], 1024);\n                continue;\n            }\n            strncpy(reg, regs[i], q - regs[i]);\n            reg[q - regs[i]] = 0;\n        } else {\n            // not parsable as a region, but possibly a sequence named \"foo:a\"\n            if (strlen(regs[i]) + 1 > 1024) {\n                fprintf(stderr, \"Region name '%s' is too long (bigger than %d).\\n\", regs[i], 1024);\n                continue;\n            }\n            strcpy(reg, regs[i]);\n            beg = 0; end = INT_MAX;\n        }\n\n        //if op==1 insert reg to the bed hash table\n        if (*op && !(bed_insert(h, reg, beg, end))) {\n            fprintf(stderr, \"Error when inserting region='%s' in the bed hash table at address=%p!\\n\", regs[i], (void *)h);\n        }\n        //if op==0, first insert the regions in the temporary hash table,\n        //then filter the bed hash table using it\n        if (!(*op) && !(bed_insert(t, reg, beg, end))) {\n            fprintf(stderr, \"Error when inserting region='%s' in the temporary hash table at address=%p!\\n\", regs[i], (void *)t);\n        }\n    }\n\n    if (!(*op)) {\n        if (bed_index(t) != 0)\n            goto fail;\n        bed_unify(t);\n        if (bed_filter(h, t) == NULL)\n            goto fail;\n        bed_destroy(t);\n        t = NULL;\n    }\n\n    if (h) {\n        if (bed_index(h) != 0)\n            goto fail;\n        bed_unify(h);\n    }\n\n    return h;\n\n fail:\n    // Clean up whichever hash we made\n    if (reg_hash) {\n        if (t)\n            bed_destroy(t);\n    } else {\n        if (h)\n            bed_destroy(h);\n    }\n    return NULL;\n}\n\nconst char* bed_get(void *reg_hash, int i, int filter) {\n\n    reghash_t *h;\n    bed_reglist_t *p;\n\n    if (!reg_hash)\n        return NULL;\n\n    h = (reghash_t *)reg_hash;\n    if (!kh_exist(h,i) || !(p = &kh_val(h,i)) || (p->filter < filter))\n        return NULL;\n\n    return kh_key(h, i);\n}\n\n/**\n * Create a region list from a the region hash table\n * @param  reg_hash  The region hash table\n * @param  filter    0 - allow all regions, 1 - allow only selected regions\n * @param  n_reg     Pointer to the returned region number\n * @return           The regions list as a hts_reglist_t\n */\n\nhts_reglist_t *bed_reglist(void *reg_hash, int filter, int *n_reg) {\n\n    reghash_t *h;\n    bed_reglist_t *p;\n    khint_t i;\n    hts_reglist_t *reglist = NULL;\n    int count = 0;\n    int j;\n\n    if (!reg_hash)\n        return NULL;\n\n    h = (reghash_t *)reg_hash;\n\n    for (i = kh_begin(h); i < kh_end(h); i++) {\n        if (!kh_exist(h,i) || !(p = &kh_val(h,i)) || (p->filter < filter))\n            continue;\n        count++;\n    }\n    if (!count)\n        return NULL;\n\n    reglist = (hts_reglist_t *)calloc(count, sizeof(hts_reglist_t));\n    if (!reglist)\n        return NULL;\n\n    *n_reg = count;\n    count = 0;\n\n    for (i = kh_begin(h); i < kh_end(h) && count < *n_reg; i++) {\n        if (!kh_exist(h,i) || !(p = &kh_val(h,i)) || (p->filter < filter))\n            continue;\n\n        reglist[count].reg = kh_key(h,i);\n        reglist[count].intervals = (hts_pair32_t *)calloc(p->n, sizeof(hts_pair32_t));\n        if(!(reglist[count].intervals)) {\n            hts_reglist_free(reglist, count);\n            return NULL;\n        }\n        reglist[count].count = p->n;\n        reglist[count].max_end = 0;\n\n        for (j = 0; j < p->n; j++) {\n            reglist[count].intervals[j].beg = p->a[j].beg;\n            reglist[count].intervals[j].end = p->a[j].end;\n\n            if (reglist[count].intervals[j].end > reglist[count].max_end)\n                reglist[count].max_end = reglist[count].intervals[j].end;\n        }\n        count++;\n    }\n\n    return reglist;\n}\n"
        },
        {
          "name": "bedidx.h",
          "type": "blob",
          "size": 1.7255859375,
          "content": "/*  bedidx.h -- BED file indexing header file.\n\n    Copyright (C) 2017 Genome Research Ltd.\n\n    Author: Valeriu Ohan <vo2@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BEDIDX_H\n#define BEDIDX_H\n\n#include \"htslib/hts.h\"\n\n#define LIDX_SHIFT 13\n#define ALL 0\n#define FILTERED 1\n\n#define MIN(A,B) ( ( (A) < (B) ) ? (A) : (B) )\n#define MAX(A,B) ( ( (A) > (B) ) ? (A) : (B) )\n\nvoid *bed_read(const char *fn);\nvoid bed_destroy(void *_h);\nint bed_overlap(const void *_h, const char *chr, hts_pos_t beg, hts_pos_t end);\nvoid *bed_hash_regions(void *reg_hash, char **regs, int first, int last, int *op);\nconst char* bed_get(void *reg_hash, int index, int filter);\nhts_reglist_t *bed_reglist(void *reg_hash, int filter, int *count_regs);\nvoid bed_unify(void *_h);\n\n#endif\n"
        },
        {
          "name": "config.mk.in",
          "type": "blob",
          "size": 2.080078125,
          "content": "#  Optional configure Makefile overrides for samtools.\n#\n#    Copyright (C) 2015,2017 Genome Research Ltd.\n#\n#    Author: John Marshall <jm18@sanger.ac.uk>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n\n# This is @configure_input@\n#\n# If you use configure, this file overrides variables and augments rules\n# in the Makefile to reflect your configuration choices.  If you don't run\n# configure, the main Makefile contains suitable conservative defaults.\n\nprefix       = @prefix@\nexec_prefix  = @exec_prefix@\nbindir       = @bindir@\ndatarootdir  = @datarootdir@\nmandir       = @mandir@\n\nAWK      = @AWK@\nCC       = @CC@\nCPPFLAGS = @CPPFLAGS@\nCFLAGS   = @CFLAGS@\nLDFLAGS  = @LDFLAGS@\nLIBS     = @LIBS@\n\n@Hsource@HTSDIR = @HTSDIR@\n@Hsource@include $(HTSDIR)/htslib.mk\n@Hsource@include $(HTSDIR)/htslib_static.mk\n@Hsource@HTSLIB = $(HTSDIR)/libhts.a\n@Hsource@HTSLIB_LIB = $(HTSLIB) $(HTSLIB_static_LIBS)\n@Hsource@HTSLIB_LDFLAGS = $(HTSLIB_static_LDFLAGS)\n@Hsource@BGZIP = $(HTSDIR)/bgzip\nHTSLIB_CPPFLAGS = @HTSLIB_CPPFLAGS@\n@Hinstall@HTSLIB_LDFLAGS = @HTSLIB_LDFLAGS@\n@Hinstall@HTSLIB_LIB = -lhts\n\nCURSES_LIB = @CURSES_LIB@\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 5.6357421875,
          "content": "# Configure script for samtools, utilities for Sequence Alignment/Map files.\n#\n#    Copyright (C) 2015, 2017, 2019 Genome Research Ltd.\n#\n#    Author: John Marshall <jm18@sanger.ac.uk>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n\ndnl Process this file with autoconf to produce a configure script\nAC_INIT([Samtools], m4_esyscmd_s([./version.sh 2>/dev/null]),\n        [samtools-help@lists.sourceforge.net], [], [http://www.htslib.org/])\nAC_PREREQ([2.63])  dnl This version introduced 4-argument AC_CHECK_HEADER\nAC_CONFIG_SRCDIR([bamtk.c])\nAC_CONFIG_HEADERS([config.h])\n\nm4_include([m4/hts_prog_cc_warnings.m4])\nm4_include([m4/hts_with_curses.m4])\nm4_include([m4/ax_with_htslib.m4])\n\ndnl Copyright notice to be copied into the generated configure script\nAC_COPYRIGHT([Portions copyright (C) 2015,2017, 2019 Genome Research Ltd.\n\nThis configure script is free software: you are free to change and\nredistribute it.  There is NO WARRANTY, to the extent permitted by law.])\n\ndnl Notes to be copied (by autoheader) into the generated config.h.in\nAH_TOP([/* If you use configure, this file provides @%:@defines reflecting your\n   configuration choices.  If you have not run configure, suitable\n   conservative defaults will be used.\n\n   Autoheader adds a number of items to this template file that are not\n   used by samtools: STDC_HEADERS and most HAVE_*_H header file defines\n   are immaterial, as we assume standard ISO C headers and facilities;\n   the PACKAGE_* defines are unused and are overridden by the more\n   accurate PACKAGE_VERSION as computed by the Makefile.  */])\n\nAC_PROG_AWK\nAC_PROG_CC\n\ndnl Turn on compiler warnings, if possible\nHTS_PROG_CC_WARNINGS\ndnl Flags to treat warnings as errors.  These need to be applied to CFLAGS\ndnl later as they can interfere with some of the tests (notably AC_SEARCH_LIBS)\nHTS_PROG_CC_WERROR(hts_late_cflags)\n\nAC_SYS_LARGEFILE\n\nAX_WITH_HTSLIB\nif test \"$ax_cv_htslib\" != yes; then\n  AC_MSG_ERROR([HTSlib development files not found\n\nSamtools uses HTSlib to parse bioinformatics file formats etc.  Building it\nrequires an unpacked HTSlib source tree (which will be built in conjunction\nwith samtools) or a previously-installed HTSlib.  In either case you may\nneed to configure --with-htslib=DIR to locate the appropriate HTSlib.\n\nFAILED.  You must supply an HTSlib in order to build samtools successfully.])\nfi\n\nif test \"$ax_cv_htslib_which\" = source; then\n  Hsource=\n  Hinstall='#'\nelse\n  Hsource='#'\n  Hinstall=\nfi\nAC_SUBST([Hsource])\nAC_SUBST([Hinstall])\n\nAC_ARG_WITH([curses],\n  [AS_HELP_STRING([--without-curses],\n                  [omit curses support, so no curses library needed])])\n\nif test \"$with_curses\" != no; then\n  HTS_WITH_CURSES\n  if test \"$ax_cv_curses\" != yes; then\n    AC_MSG_ERROR([curses development files not found\n\nThe 'samtools tview' command uses the curses text user interface library.\nBuilding samtools with tview requires curses/ncurses/etc development files\nto be installed on the build machine; you may need to ensure a package such\nas libncurses5-dev (on Debian or Ubuntu Linux) or ncurses-devel (on RPM-based\nLinux distributions) is installed.\n\nFAILED.  Either configure --without-curses or resolve this error to build\nsamtools successfully.])\n  fi\nelse\n  CURSES_LIB=\n  AC_SUBST([CURSES_LIB])\nfi\n\nsave_LIBS=$LIBS\nzlib_devel=ok\ndnl Set a trivial non-empty INCLUDES to avoid excess default includes tests\nAC_CHECK_HEADER([zlib.h], [], [zlib_devel=missing], [;])\nAC_CHECK_LIB(z, inflate,  [], [zlib_devel=missing])\nLIBS=$save_LIBS\n\nif test $zlib_devel != ok; then\n  AC_MSG_ERROR([zlib development files not found\n\nSamtools uses compression routines from the zlib library <http://zlib.net>.\nBuilding samtools requires zlib development files to be installed on the build\nmachine; you may need to ensure a package such as zlib1g-dev (on Debian or\nUbuntu Linux) or zlib-devel (on RPM-based Linux distributions) is installed.\n\nFAILED.  This error must be resolved in order to build samtools successfully.])\nfi\n\ndnl Look for regcomp in various libraries (needed on windows/mingw).\nAC_SEARCH_LIBS(regcomp, regex, [libregex=needed], [])\n\ndnl Force POSIX mode on Windows/Mingw\ntest -n \"$host_alias\" || host_alias=unknown-`uname -s`\ncase $host_alias in\n  *-msys* | *-MSYS* | *-mingw* | *-MINGW*)\n    host_result=\"MSYS dll\"\n    PLATFORM=MSYS\n    PLUGIN_EXT=.dll\n    # This also sets __USE_MINGW_ANSI_STDIO which in turn makes PRId64,\n    # %lld and %z printf formats work.  It also enforces the snprintf to\n    # be C99 compliant so it returns the correct values (in kstring.c).\n    CPPFLAGS=\"$CPPFLAGS -D_XOPEN_SOURCE=600\"\n    ;;\nesac\n\ndnl Apply value from HTS_PROG_CC_WERROR (if set)\nAS_IF([test \"x$hts_late_cflags\" != x],[CFLAGS=\"$CFLAGS $hts_late_cflags\"])\n\nAC_CONFIG_FILES([config.mk])\nAC_OUTPUT\n"
        },
        {
          "name": "consensus_pileup.c",
          "type": "blob",
          "size": 18.494140625,
          "content": "/*  consensus__pileup.h -- Pileup orientated data per consensus column\n\n    Copyright (C) 2013-2016, 2020-2022 Genome Research Ltd.\n\n    Author: James Bonfied <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n#include <htslib/sam.h>\n\n#ifdef __SSE__\n#   include <xmmintrin.h>\n#else\n#   define _mm_prefetch(a,b)\n#endif\n\n#include \"consensus_pileup.h\"\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define bam_strand(b)  (((b)->core.flag & BAM_FREVERSE) != 0)\n\n/*\n * START_WITH_DEL is the mode that Gap5 uses when building this. It prepends\n * all cigar strings with 1D and decrements the position by one. (And then\n * has code to reverse this operation in the pileup handler.)\n *\n * The reason for this is that it means reads starting with an insertion work.\n * Otherwise the inserted bases are silently lost. (Try it with \"samtools\n * mpileup\" and you can see it has the same issue.)\n *\n * However it's probably not want most people expect.\n */\n//#define START_WITH_DEL\n\n/* --------------------------------------------------------------------------\n * The pileup code itself.\n *\n * This consists of the external pileup_loop() function, which takes a\n * sam/bam samfile_t pointer and a callback function. The callback function\n * is called once per column of aligned data (so once per base in an\n * insertion).\n *\n * Current known issues.\n * 1) zero length matches, ie 2S2S cause failures.\n * 2) Insertions at starts of sequences get included in the soft clip, so\n *    2S2I2M is treated as if it's 4S2M\n * 3) From 1 and 2 above, 1S1I2S becomes 2S2S which fails.\n */\n\n\n/*\n * Fetches the next base => the nth base at unpadded position pos. (Nth can\n * be greater than 0 if we have an insertion in this column). Do not call this\n * with pos/nth lower than the previous query, although higher is better.\n * (This allows it to be initialised at base 0.)\n *\n * Stores the result in base and also updates is_insert to indicate that\n * this sequence still has more bases in this position beyond the current\n * nth parameter.\n *\n * Returns 1 if a base was fetched\n *         0 if not (eg ran off the end of sequence)\n */\nstatic int get_next_base(pileup_t *p, hts_pos_t pos, int nth, int *is_insert) {\n    bam1_t *b = &p->b;\n    int op = p->cigar_op;\n\n    p->start -= p->start>0;\n    if (p->first_del && op != BAM_CPAD)\n        p->first_del = 0;\n\n    *is_insert = 0;\n\n    /* Find pos first */\n    while (p->pos < pos) {\n        p->nth = 0;\n\n        if (p->cigar_len == 0) {\n            if (p->cigar_ind >= b->core.n_cigar) {\n                p->eof = 1;\n                return 0;\n            }\n\n            op=p->cigar_op  = p->b_cigar[p->cigar_ind] & BAM_CIGAR_MASK;\n            p->cigar_len = p->b_cigar[p->cigar_ind] >> BAM_CIGAR_SHIFT;\n            p->cigar_ind++;\n        }\n\n        if ((op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF)\n            && p->cigar_len <= pos - p->pos) {\n            p->seq_offset += p->cigar_len;\n            p->pos += p->cigar_len;\n            p->cigar_len = 0;\n        } else {\n            switch (op) {\n            case BAM_CMATCH:\n            case BAM_CEQUAL:\n            case BAM_CDIFF:\n                p->seq_offset++;\n                /* Fall through */\n            case BAM_CDEL:\n            case BAM_CREF_SKIP:\n                p->pos++;\n                p->cigar_len--;\n                break;\n\n            case BAM_CINS:\n            case BAM_CSOFT_CLIP:\n                p->seq_offset += p->cigar_len;\n                /* Fall through */\n            case BAM_CPAD:\n            case BAM_CHARD_CLIP:\n                p->cigar_len = 0;\n                break;\n\n            default:\n                fprintf(stderr, \"Unhandled cigar_op %d\\n\", op);\n                return -1;\n            }\n        }\n    }\n\n    /* Now at pos, find nth base */\n    while (p->nth < nth) {\n        if (p->cigar_len == 0) {\n            if (p->cigar_ind >= b->core.n_cigar) {\n                p->eof = 1;\n                return 0; /* off end of seq */\n            }\n\n            op=p->cigar_op  = p->b_cigar[p->cigar_ind] & BAM_CIGAR_MASK;\n            p->cigar_len = p->b_cigar[p->cigar_ind] >> BAM_CIGAR_SHIFT;\n            p->cigar_ind++;\n        }\n\n        switch (op) {\n        case BAM_CMATCH:\n        case BAM_CEQUAL:\n        case BAM_CDIFF:\n        case BAM_CSOFT_CLIP:\n        case BAM_CDEL:\n        case BAM_CREF_SKIP:\n            goto at_nth; /* sorry, but it's fast! */\n\n        case BAM_CINS:\n            p->seq_offset++;\n            /* Fall through */\n        case BAM_CPAD:\n            p->cigar_len--;\n            p->nth++;\n            break;\n\n        case BAM_CHARD_CLIP:\n            p->cigar_len = 0;\n            break;\n\n        default:\n            fprintf(stderr, \"Unhandled cigar_op %d\\n\", op);\n            return -1;\n        }\n    }\n at_nth:\n\n    /* Fill out base & qual fields */\n    p->ref_skip = 0;\n    if (p->nth < nth && op != BAM_CINS) {\n        //p->base = '-';\n        p->base = '*';\n        p->base4 = 16;\n        p->padding = 1;\n        if (p->seq_offset < b->core.l_qseq)\n            p->qual = MIN(p->qual, p->b_qual[p->seq_offset+1]);\n        else\n            p->qual = 0;\n    } else {\n        p->padding = 0;\n        switch(op) {\n        case BAM_CDEL:\n            p->base = '*';\n            p->base4 = 16;\n            if (p->seq_offset+1 < b->core.l_qseq)\n                p->qual = MIN(p->qual, p->b_qual[p->seq_offset+1]);\n            else\n                p->qual = MIN(p->qual, p->b_qual[p->seq_offset]);\n            break;\n\n        case BAM_CPAD:\n            //p->base = '+';\n            p->base = '*';\n            p->base4 = 16;\n            if (p->seq_offset+1 < b->core.l_qseq)\n                p->qual = MIN(p->qual, p->b_qual[p->seq_offset+1]);\n            else\n                p->qual = MIN(p->qual, p->b_qual[p->seq_offset]);\n            break;\n\n        case BAM_CREF_SKIP:\n            p->base = '.';\n            p->base4 = 0;\n            p->qual = 0;\n            /* end of fragment, but not sequence */\n            p->eof = p->eof ? 2 : 3;\n            p->ref_skip = 1;\n            break;\n\n        default:\n            if (p->seq_offset < b->core.l_qseq) {\n                p->qual = p->b_qual[p->seq_offset];\n                p->base4 = p->b_seq[p->seq_offset/2] >>\n                    ((~p->seq_offset&1)<<2) & 0xf;\n                p->base = \"NACMGRSVTWYHKDBN\"[p->base4];\n            } else {\n                p->base = 'N';\n                p->base4 = 15;\n                p->qual = 0xff;\n            }\n\n            break;\n        }\n    }\n\n    /* Handle moving out of N (skip) into sequence again */\n    if (p->eof && p->base != '.') {\n        p->start = 1;\n        p->ref_skip = 1;\n        p->eof = 0;\n    }\n\n    /* Starting with an indel needs a minor fudge */\n    if (p->start && p->cigar_op == BAM_CDEL) {\n        p->first_del = 1;\n    }\n\n    /* Check if next op is an insertion of some sort */\n    if (p->cigar_len == 0) {\n        if (p->cigar_ind < b->core.n_cigar) {\n            op=p->cigar_op  = p->b_cigar[p->cigar_ind] & BAM_CIGAR_MASK;\n            p->cigar_len = p->b_cigar[p->cigar_ind] >> BAM_CIGAR_SHIFT;\n            p->cigar_ind++;\n            if (op == BAM_CREF_SKIP) {\n                p->eof = 3;\n                p->ref_skip = 1;\n            }\n        } else {\n            p->eof = 1;\n        }\n    }\n\n    switch (op) {\n    case BAM_CPAD:\n    case BAM_CINS:\n        *is_insert = p->cigar_len;\n        break;\n\n    case BAM_CSOFT_CLIP:\n        /* Last op 'S' => eof */\n        p->eof = (p->cigar_ind == b->core.n_cigar ||\n                  (p->cigar_ind+1 == b->core.n_cigar &&\n                   (p->b_cigar[p->cigar_ind] & BAM_CIGAR_MASK)\n                   == BAM_CHARD_CLIP))\n            ? 1\n            : 0;\n        break;\n\n    case BAM_CHARD_CLIP:\n        p->eof = 1;\n        break;\n\n    default:\n        break;\n    }\n\n    return 1;\n}\n\n/*\n * Loops through a set of supplied ranges producing columns of data.\n * When found, it calls func with clientdata as a callback. Func should\n * return 0 for success and non-zero for failure. seq_init() is called\n * on each new entry before we start processing it. It should return 0 or 1\n * to indicate reject or accept status (eg to filter unmapped data).\n * If seq_init() returns -1 we abort the pileup_loop with an error.\n * seq_init may be NULL.\n *\n * Returns 0 on success\n *        -1 on failure\n */\nint pileup_loop(samFile *fp,\n                sam_hdr_t *h,\n                int (*seq_fetch)(void *client_data,\n                                 samFile *fp,\n                                 sam_hdr_t *h,\n                                 bam1_t *b),\n                int (*seq_init)(void *client_data,\n                                samFile *fp,\n                                sam_hdr_t *h,\n                                pileup_t *p),\n                int (*seq_column)(void *client_data,\n                                  samFile *fp,\n                                  sam_hdr_t *h,\n                                  pileup_t *p,\n                                  int depth,\n                                  hts_pos_t pos,\n                                  int nth,\n                                  int is_insert),\n                void (*seq_free)(void *client_data,\n                                 samFile *fp,\n                                 sam_hdr_t *h,\n                                 pileup_t *p),\n                void *client_data) {\n    int ret = -1;\n    pileup_t *phead = NULL, *p, *pfree = NULL, *last, *next, *ptail = NULL;\n    pileup_t *pnew = NULL;\n    int is_insert, nth = 0, r;\n    hts_pos_t col = 0;\n    int last_ref = -1;\n\n    /* FIXME: allow for start/stop boundaries rather than consuming all data */\n\n    if (NULL == (pnew = calloc(1, sizeof(*p))))\n        return -1;\n\n    do {\n        bam1_t *b;\n        hts_pos_t pos;\n\n        r = seq_fetch(client_data, fp, h, &pnew->b);\n        if (r < -1) {\n            fprintf(stderr, \"bam_next_seq() failure.\\n\");\n            goto error;\n        }\n\n        b = &pnew->b;\n\n        /* Force realloc */\n        //fp->bs = NULL;\n        //fp->bs_size = 0;\n\n        //r = samread(fp, pnew->b);\n        if (r >= 0) {\n            if (b->core.flag & BAM_FUNMAP)\n                continue;\n\n            if (b->core.tid == -1) {\n                /* Another indicator for unmapped */\n                continue;\n            } else if (b->core.tid == last_ref) {\n                pos = b->core.pos+1;\n                //printf(\"New seq at pos %d @ %d %s\\n\", pos, b->core.tid,\n                //       bam_name(b));\n            } else {\n                //printf(\"New ctg at pos %ld @ %d\\n\",b->core.pos+1,b->core.tid);\n                pos = HTS_POS_MAX;\n            }\n        } else {\n            pos = HTS_POS_MAX;\n        }\n\n        if (col > pos) {\n            fprintf(stderr, \"BAM/SAM file is not sorted by position. \"\n                    \"Aborting\\n\");\n            goto error;\n        }\n\n        /* Process data between the last column and our latest addition */\n        while (col < pos && phead) {\n            struct pileup *eof_head = NULL, *eofp = NULL;\n            int v, ins, depth = 0;\n            //printf(\"Col=%ld pos=%ld nth=%d\\n\", col, pos, nth);\n\n            /* Pileup */\n            is_insert = 0;\n            pileup_t *pnext = phead ? phead->next : NULL;\n            for (p = phead, last = NULL; p; p = pnext) {\n#if 0\n                // Simple prefetching\n                pnext = p->next;\n                if (pnext)\n                    _mm_prefetch(pnext, _MM_HINT_T0);\n#else\n                // More complex prefetching => more instructions, but\n                // usually faster.\n                pnext = p->next;\n                if (pnext) {\n                    // start memory fetches; a big help on very deep data\n                    if (pnext->next)\n                        // struct 2 ahead\n                        _mm_prefetch(pnext->next, _MM_HINT_T0);\n                    // seq/qual 1 ahead\n                    _mm_prefetch(pnext->b_qual + pnext->seq_offset,\n                                 _MM_HINT_T0);\n                    _mm_prefetch(pnext->b_seq  + pnext->seq_offset/2,\n                                 _MM_HINT_T0);\n                }\n#endif\n\n                if (!get_next_base(p, col, nth, &ins))\n                    p->eof = 1;\n                if (p->eof == 1) {\n                    if (eofp)\n                        eofp->eofn = p;\n                    eofp = p;\n                    eofp->eofl = last;\n                    if (!eof_head)\n                        eof_head = eofp;\n                } else {\n                    last = p;\n                }\n\n                if (is_insert < ins)\n                    is_insert = ins;\n\n                depth++;\n            }\n            if ((ptail = last) == NULL)\n                ptail = phead;\n\n            /* Call our function on phead linked list */\n            v = seq_column(client_data, fp, h, phead, depth,\n#ifdef START_WITH_DEL\n                           col-1,\n#else\n                           col,\n#endif\n                           nth, is_insert);\n\n            /* Remove dead seqs */\n            for (p = eof_head ; p; p = p->eofn) {\n                if (p->eofl)\n                    p->eofl->next = p->next;\n                else\n                    phead = p->next;\n\n                p->next = pfree;\n                pfree = p;\n\n                if (seq_free)\n                    seq_free(client_data, fp, h, p);\n            }\n\n            if (v == 1)\n                break; /* early abort */\n\n            if (v != 0)\n                goto error;\n\n            /* Next column */\n            if (is_insert) {\n                nth++;\n            } else {\n                nth = 0;\n                col++;\n            }\n        }\n\n        /* May happen if we have a hole in the contig */\n        col = pos;\n\n        /* New contig */\n        if (b && b->core.tid != last_ref) {\n            last_ref = b->core.tid;\n            pos = b->core.pos+1;\n            nth = 0;\n            col = pos;\n        }\n\n        /*\n         * Add this seq.\n         * Note: cigars starting with I or P ops (eg 2P3I10M) mean we have\n         * alignment instructions that take place before the designated\n         * starting location listed in the SAM file. They won't get included\n         * in the callback function until they officially start, which is\n         * already too late.\n         *\n         * So to workaround this, we prefix all CIGAR with 1D, move the\n         * position by 1bp, and then force the callback code to remove\n         * leaving pads (either P or D generated).\n         *\n         * Ie it's a level 10 hack!\n         */\n        if (r >= 0) {\n            p = pnew;\n            p->next       = NULL;\n            p->cd         = NULL;\n            p->eofn       = NULL;\n            p->eofl       = NULL;\n            p->start      = 2;\n            p->eof        = 0;\n#ifdef START_WITH_DEL\n            p->pos        = pos-1;\n            p->cigar_ind  = 0;\n            p->b_cigar    = bam_get_cigar(&p->b);\n            if ((p->b_cigar[0] & BAM_CIGAR_MASK) == BAM_CHARD_CLIP) {\n                p->cigar_len  = p->b_cigar[0] >> BAM_CIGAR_SHIFT;\n                p->cigar_op   = BAM_CHARD_CLIP;\n                if ((p->b_cigar[1] & BAM_CIGAR_MASK) == BAM_CSOFT_CLIP) {\n                    /* xHxS... => xHxS1D... */\n                    p->b_cigar[0] = p->b_cigar[1];\n                    p->b_cigar[1] = (1 << BAM_CIGAR_SHIFT) | BAM_CDEL;\n                } else {\n                    /* xH... => xH1D... */\n                    p->b_cigar[0] = (1 << BAM_CIGAR_SHIFT) | BAM_CDEL;\n                }\n            } else {\n                if ((p->b_cigar[0] & BAM_CIGAR_MASK) == BAM_CSOFT_CLIP) {\n                    /* xS... => xS1D... */\n                    p->cigar_len  = p->b_cigar[0] >> BAM_CIGAR_SHIFT;\n                    p->cigar_op   = BAM_CSOFT_CLIP;\n                    p->b_cigar[0] = (1 << BAM_CIGAR_SHIFT) | BAM_CDEL;\n                } else {\n                    /* ... => 1D... */\n                    p->cigar_len  = 1;        /* was  0  */\n                    p->cigar_op   = BAM_CDEL; /* was 'X' */\n                }\n            }\n            p->seq_offset = -1;\n            p->first_del  = 1;\n#else\n            p->pos        = pos-1;\n            p->cigar_ind  = 0;\n            p->b_cigar    = bam_get_cigar(&p->b);\n            p->cigar_len  = 0;\n            p->cigar_op   = -1;\n            p->seq_offset = -1;\n            p->first_del  = 0;\n#endif\n            p->b_is_rev   = bam_is_rev(&p->b);\n            p->b_qual     = (uint8_t *)bam_get_qual(&p->b);\n            p->b_seq      = (uint8_t *)bam_get_seq(&p->b);\n\n            if (seq_init) {\n                int v;\n                v = seq_init(client_data, fp, h, p);\n                if (v == -1)\n                    goto error;\n\n                if (v == 1) {\n                    /* Keep this seq */\n                    if (phead) {\n                        ptail->next = p;\n                    } else {\n                        phead = p;\n                    }\n                    ptail = p;\n                } else {\n                    /* Push back on free list */\n                    p->next = pfree;\n                    pfree = p;\n                }\n            } else {\n                if (phead)\n                    ptail->next = p;\n                else\n                    phead = p;\n                ptail = p;\n            }\n\n            /* Allocate the next pileup rec */\n            if (pfree) {\n                pnew = pfree;\n                pfree = pfree->next;\n            } else {\n                if (NULL == (pnew = calloc(1, sizeof(*pnew))))\n                    goto error;\n            }\n        }\n    } while (r >= 0);\n\n    ret = 0;\n error:\n\n    if (pnew) {\n        free(pnew->b.data);\n        free(pnew);\n    }\n\n    /* Tidy up */\n    for (p = pfree; p; p = next) {\n        next = p->next;\n        if (seq_free)\n            seq_free(client_data, fp, h, p);\n        free(p->b.data);\n        free(p);\n    }\n\n    return ret;\n}\n"
        },
        {
          "name": "consensus_pileup.h",
          "type": "blob",
          "size": 4.5009765625,
          "content": "/*  consensus_pileup.h -- Pileup orientated data per consensus column\n\n    Copyright (C) 2013-2016, 2020-2022 Genome Research Ltd.\n\n    Author: James Bonfied <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <htslib/sam.h>\n\ntypedef struct pileup {\n    // commonly used things together, to fit in a cache line (64 bytes)\n    struct pileup *next;  // A link list, for active seqs\n    void *cd;             // General purpose per-seq client-data\n    int  eof;             // True if this sequence has finished\n    int  qual;            // Current qual (for active seq only)\n    char start;           // True if this is a new sequence\n    char base;            // Current base (for active seq only) in ASCII\n    char ref_skip;        // True if the cause of eof or start is cigar N\n    char padding;         // True if the base was added due to another seq\n    int  base4;           // Base in 4-bit notation (0-15)\n    hts_pos_t pos;        // Current unpadded position in seq\n    int  nth;             // nth base at unpadded position 'pos'\n    int  b_is_rev;        // 0 => fwd, 1 => rev\n    int  seq_offset;      // Current base position in s->seq[] array.\n\n    unsigned char *b_qual;// cached bam_qual\n    unsigned char *b_seq; // cached bam_seq\n\n    // --- 64 bytes\n    struct pileup *eofn;  // p->eof set, next eof member\n    struct pileup *eofl;  // last non-eof that points to p with p->eof\n\n    uint32_t *b_cigar;    // cached bam_cigar\n\n    int  cigar_ind;       // Current location in s->alignment cigar str\n    int  cigar_op;        // Current cigar operation\n    int  cigar_len;       // Remaining length of this cigar op\n\n    int  first_del;       // Used when first base is a deletion\n\n    bam1_t b;             // Bam entry associated with struct\n} pileup_t;\n\n/*\n * The pileup loop executes and calls callbacks to perform the work.\n *\n * seq_fetch returns the next sequence.  Return 0 from this indicates no\n *   more data.\n *\n * seq_init is called, if non-NULL, when a sequence is added to the pileup,\n * seq_free likewise, if non-NULL, is called when a sequence is removed\n *   from the pileup.\n * These two functions are akin to the constructor and destructors added\n * to mpileup.\n *\n * seq_column is the primary work horse which is executed for each\n *   reference position, and for each inserted base per ref pos.\n *\n * If we were to invert this from a loop generating callbacks to a polled\n * style interface like mpileup, then the seq_column bit would be dropped\n * and replaced by the returned pileup and associated parameters.\n */\nint pileup_loop(samFile *fp,\n                sam_hdr_t *h,\n                int (*seq_fetch)(void *client_data,\n                                 samFile *fp,\n                                 sam_hdr_t *h,\n                                 bam1_t *b),\n                int (*seq_init)(void *client_data,\n                                samFile *fp,\n                                sam_hdr_t *h,\n                                pileup_t *p),\n                int (*seq_column)(void *client_data,\n                                  samFile *fp,\n                                  sam_hdr_t *h,\n                                  pileup_t *p,\n                                  int depth,\n                                  hts_pos_t pos,\n                                  int nth,\n                                  int is_insert),\n                void (*seq_free)(void *client_data,\n                                 samFile *fp,\n                                 sam_hdr_t *h,\n                                 pileup_t *p),\n                void *client_data);\n"
        },
        {
          "name": "coverage.c",
          "type": "blob",
          "size": 28.4111328125,
          "content": "/* coverage.c -- samtools coverage subcommand\n\n    Copyright (C) 2018,2019 Florian Breitwieser\n    Portions copyright (C) 2019-2021, 2023-2024 Genome Research Ltd.\n\n    Author: Florian P Breitwieser <florian.bw@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n/* This program calculates coverage from multiple BAMs\n * simultaneously, to achieve random access and to use the BED interface.\n * To compile this program separately, you may:\n *\n *   gcc -g -O2 -Wall -o bamcov -D_MAIN_BAMCOV coverage.c -lhts -lz\n */\n\n// C headers\n#include <config.h>\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>  // variadic functions\n#include <limits.h>  // INT_MAX\n#include <math.h>    // round\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <sys/ioctl.h>\n#endif\n\n#include \"htslib/sam.h\"\n#include \"htslib/hts.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\ntypedef struct {  // auxiliary data structure to hold stats on coverage\n    unsigned long long n_covered_bases;\n    unsigned long long summed_coverage;\n    unsigned long long summed_baseQ;\n    unsigned long long summed_mapQ;\n    unsigned long long quality_bases;\n    unsigned int n_reads;\n    unsigned int n_selected_reads;\n    bool covered;\n    hts_pos_t beg;\n    hts_pos_t end;\n    int64_t bin_width;\n} stats_aux_t;\n\ntypedef struct {  // auxiliary data structure to hold a BAM file\n    samFile *fp;     // file handle\n    sam_hdr_t *hdr;  // file header\n    hts_itr_t *iter; // iterator to a region - NULL for us by default\n    int min_mapQ;    // mapQ filter\n    int min_len;     // length filter\n    int fail_flags;\n    int required_flags;\n    stats_aux_t *stats;\n} bam_aux_t;\n\n#if __STDC_VERSION__ >= 199901L\n#define VERTICAL_LINE \"\\u2502\" // BOX DRAWINGS LIGHT VERTICAL\n\n// UTF8 specifies block characters in eights going from \\u2581 (lower one eight block) to \\u2588 (full block)\n//   https://en.wikipedia.org/wiki/Block_Elements\n// LOWER ONE EIGHTH BLOCK … FULL BLOCK\nstatic const char *const BLOCK_CHARS8[8] = {\"\\u2581\", \"\\u2582\", \"\\u2583\", \"\\u2584\", \"\\u2585\", \"\\u2586\", \"\\u2587\", \"\\u2588\"};\n// In some terminals / with some fonts not all UTF8 block characters are supported (e.g. Putty). Use only half and full block for those\nstatic const char *const BLOCK_CHARS2[2] = {\".\", \":\"};\n\n#else\n\n// Fall back to explicit UTF-8 encodings of the same characters\n#define VERTICAL_LINE \"\\xE2\\x94\\x82\"\n\nstatic const char *const BLOCK_CHARS8[8] = {\n    \"\\xE2\\x96\\x81\", \"\\xE2\\x96\\x82\", \"\\xE2\\x96\\x83\", \"\\xE2\\x96\\x84\",\n    \"\\xE2\\x96\\x85\", \"\\xE2\\x96\\x86\", \"\\xE2\\x96\\x87\", \"\\xE2\\x96\\x88\" };\n\nstatic const char *const BLOCK_CHARS2[2] = {\".\", \":\"};\n\n#endif\n\n// in bam_plcmd.c\nint read_file_list(const char *file_list, int *n, char **argv[]);\n\nstatic int usage(void) {\n    fprintf(stdout, \"Usage: samtools coverage [options] in1.bam [in2.bam [...]]\\n\\n\"\n            \"Input options:\\n\"\n            \"  -b, --bam-list FILE     list of input BAM filenames, one per line\\n\"\n            \"  -l, --min-read-len INT  ignore reads shorter than INT bp [0]\\n\"\n            \"  -q, --min-MQ INT        mapping quality threshold [0]\\n\"\n            \"  -Q, --min-BQ INT        base quality threshold [0]\\n\"\n            \"  --rf <int|str>          required flags: skip reads with mask bits unset []\\n\"\n            \"  --ff <int|str>          filter flags: skip reads with mask bits set \\n\"\n            \"                                      [UNMAP,SECONDARY,QCFAIL,DUP]\\n\"\n            \"  -d, --depth INT         maximum allowed coverage depth [1000000].\\n\"\n            \"                          If 0, depth is set to the maximum integer value,\\n\"\n            \"                          effectively removing any depth limit.\\n\"\n            \"Output options:\\n\"\n            \"  -m, --histogram         show histogram instead of tabular output\\n\"\n            \"  -D, --plot-depth        plot depth instead of tabular output\\n\"\n            \"  -A, --ascii             show only ASCII characters in histogram\\n\"\n            \"  -o, --output FILE       write output to FILE [stdout]\\n\"\n            \"  -H, --no-header         don't print a header in tabular mode\\n\"\n            \"  -w, --n-bins INT        number of bins in histogram [terminal width - 40]\\n\"\n            \"  -r, --region REG        show specified region. Format: chr:start-end. \\n\"\n            \"  -h, --help              help (this page)\\n\");\n\n    fprintf(stdout, \"\\nGeneric options:\\n\");\n    sam_global_opt_help(stdout, \"-.--.--.\");\n\n    fprintf(stdout,\n            \"\\nSee manpage for additional details.\\n\"\n            \"  rname       Reference name / chromosome\\n\"\n            \"  startpos    Start position\\n\"\n            \"  endpos      End position (or sequence length)\\n\"\n            \"  numreads    Number reads aligned to the region (after filtering)\\n\"\n            \"  covbases    Number of covered bases with depth >= 1\\n\"\n            \"  coverage    Percentage of covered bases [0..100]\\n\"\n            \"  meandepth   Mean depth of coverage\\n\"\n            \"  meanbaseq   Mean baseQ in covered region\\n\"\n            \"  meanmapq    Mean mapQ of selected reads\\n\"\n           );\n\n    return EXIT_SUCCESS;\n}\n\nstatic char* center_text(char *text, char *buf, int width) {\n    int len = strlen(text);\n    assert(len <= width);\n    int padding = (width - len) / 2;\n    int padding_ex = (width - len) % 2;\n    if (padding >= 1)\n        sprintf(buf, \" %*s%*s\", len+padding, text, padding-1+padding_ex, \" \");\n    else\n        sprintf(buf, \"%s\", text);\n\n    return buf;\n}\n\nstatic char* readable_bps(double base_pairs, char *buf) {\n    const char* units[] = {\"\", \"K\", \"M\", \"G\", \"T\"};\n    int i = 0;\n    while (base_pairs >= 1000 && i < (sizeof(units)/sizeof(units[0]) - 1)) {\n        base_pairs /= 1000;\n        i++;\n    }\n    sprintf(buf, \"%.*f%s\", i, base_pairs, units[i]);\n    return buf;\n}\n\n// read one alignment from one BAM file\nstatic int read_bam(void *data, bam1_t *b) {\n    bam_aux_t *aux = (bam_aux_t*)data; // data in fact is a pointer to an auxiliary structure\n    int nref = sam_hdr_nref(aux->hdr);\n    int ret;\n    while (1) {\n        if((ret = aux->iter? sam_itr_next(aux->fp, aux->iter, b) : sam_read1(aux->fp, aux->hdr, b)) < 0) break;\n        if (b->core.tid >= 0 && b->core.tid < nref)\n            aux->stats[b->core.tid].n_reads++;\n\n        if ( aux->fail_flags && (b->core.flag & aux->fail_flags) ) continue;\n        if ( aux->required_flags && !(b->core.flag & aux->required_flags) ) continue;\n        if ( b->core.qual < aux->min_mapQ ) continue;\n        if ( aux->min_len && bam_cigar2qlen(b->core.n_cigar, bam_get_cigar(b)) < aux->min_len ) continue;\n        if (b->core.tid >= 0 && b->core.tid < nref) {\n            aux->stats[b->core.tid].n_selected_reads++;\n            aux->stats[b->core.tid].summed_mapQ += b->core.qual;\n        }\n        break;\n    }\n    return ret;\n}\n\nvoid print_tabular_line(FILE *file_out, const sam_hdr_t *h, const stats_aux_t *stats, int tid) {\n    fputs(sam_hdr_tid2name(h, tid), file_out);\n    double region_len = (double) stats[tid].end - stats[tid].beg;\n    fprintf(file_out, \"\\t%\"PRId64\"\\t%\"PRId64\"\\t%u\\t%llu\\t%g\\t%g\\t%.3g\\t%.3g\\n\",\n            stats[tid].beg+1,\n            stats[tid].end,\n            stats[tid].n_selected_reads,\n            stats[tid].n_covered_bases,\n            100.0 * stats[tid].n_covered_bases / region_len,\n            stats[tid].summed_coverage / region_len,\n            stats[tid].quality_bases > 0? stats[tid].summed_baseQ/(double) stats[tid].quality_bases : 0,\n            stats[tid].n_selected_reads > 0? stats[tid].summed_mapQ/(double) stats[tid].n_selected_reads : 0\n           );\n}\n\nvoid print_hist(FILE *file_out, const sam_hdr_t *h, const stats_aux_t *stats, int tid, const uint32_t *hist,\n        const int hist_size, const bool full_utf, const bool plot_coverage) {\n    int i, col;\n    bool show_percentiles = false;\n    const int n_rows = 10;\n    const char * const * BLOCK_CHARS = full_utf? BLOCK_CHARS8 : BLOCK_CHARS2;\n    const int blockchar_len = full_utf? 8 : 2;\n    double region_len = stats[tid].end - stats[tid].beg;\n\n    // Calculate histogram that contains percent covered\n    double hist_data[hist_size];\n    double max_val = 0.0;\n    for (i = 0; i < hist_size; ++i) {\n        hist_data[i] = (plot_coverage?1:100) * hist[i] / (double) stats[tid].bin_width;\n        if (hist_data[i] > max_val) max_val = hist_data[i];\n    }\n\n    char buf[30];\n    fprintf(file_out, \"%s (%sbp)\\n\", sam_hdr_tid2name(h, tid), readable_bps(sam_hdr_tid2len(h, tid), buf));\n\n    double row_bin_size = max_val / (double) n_rows;\n    for (i = n_rows-1; i >= 0; --i) {\n        double current_bin = row_bin_size * i;\n        if (plot_coverage) {\n            fprintf(file_out, \">%8.1f \",i*row_bin_size);\n        } else if (show_percentiles) {\n            fprintf(file_out, \">%3i%% \", i*10);\n        } else {\n            fprintf(file_out, \">%7.2f%% \", current_bin);\n        }\n        fprintf(file_out, full_utf ? VERTICAL_LINE : \"|\");\n        for (col = 0; col < hist_size; ++col) {\n            // get the difference in eights, or halfs when full UTF8 is not supported\n            int cur_val_diff = round(blockchar_len * (hist_data[col] - current_bin) / row_bin_size) - 1;\n            if (cur_val_diff < 0) {\n                fputc(' ', file_out);\n            } else {\n                if (cur_val_diff >= blockchar_len)\n                    cur_val_diff = blockchar_len - 1;\n\n                fprintf(file_out, \"%s\", BLOCK_CHARS[cur_val_diff]);\n            }\n        }\n        fprintf(file_out, full_utf ? VERTICAL_LINE : \"|\");\n        fputc(' ', file_out);\n        switch (i) {\n            case 9: fprintf(file_out, \"Number of reads: %u\", stats[tid].n_selected_reads); break;\n            case 8: if (stats[tid].n_reads - stats[tid].n_selected_reads > 0) fprintf(file_out, \"    (%i filtered)\", stats[tid].n_reads - stats[tid].n_selected_reads); break;\n            case 7: fprintf(file_out, \"Covered bases:   %sbp\", readable_bps(stats[tid].n_covered_bases, buf)); break;\n            case 6: fprintf(file_out, \"Percent covered: %.4g%%\",\n                            100.0 * stats[tid].n_covered_bases / region_len); break;\n            case 5: fprintf(file_out, \"Mean coverage:   %.3gx\",\n                            stats[tid].summed_coverage / region_len); break;\n            case 4: fprintf(file_out, \"Mean baseQ:      %.3g\",\n                            stats[tid].quality_bases > 0? stats[tid].summed_baseQ/(double) stats[tid].quality_bases : 0); break;\n            case 3: fprintf(file_out, \"Mean mapQ:       %.3g\",\n                            stats[tid].summed_mapQ/(double) stats[tid].n_selected_reads); break;\n            case 1: fprintf(file_out, \"Histo bin width: %sbp\",\n                            readable_bps(stats[tid].bin_width, buf)); break;\n            case 0: if (plot_coverage) {\n                        fprintf(file_out, \"Histo max cov:   %.5g\",  max_val);\n                    } else {\n                        fprintf(file_out, \"Histo max bin:   %.5g%%\", max_val);\n                    }\n                    break;\n\n        };\n        fputc('\\n', file_out);\n    }\n\n    // print x axis. Could be made pretty for widths that are not divisible\n    // by 10 by variable spacing of the labels, instead of placing a label every 10 characters\n    char buf2[50];\n    fprintf(file_out, \"     %s\", center_text(readable_bps(stats[tid].beg + 1, buf), buf2, 10));\n    int rest;\n    for (rest = 10; rest < 10*(hist_size/10); rest += 10) {\n        fprintf(file_out, \"%s\", center_text(readable_bps(stats[tid].beg + stats[tid].bin_width*rest, buf), buf2, 10));\n    }\n    int last_padding = hist_size%10;\n    fprintf(file_out, \"%*s%s\", last_padding, \" \", center_text(readable_bps(stats[tid].end, buf), buf2, 10));\n    fprintf(file_out, \"\\n\");\n}\n\nint main_coverage(int argc, char *argv[]) {\n    int status = EXIT_SUCCESS;\n\n    int ret, tid = -1, old_tid = -1, pos, i, j;\n\n    int max_depth = 1000000;\n    int opt_min_baseQ = 0;\n    int opt_min_mapQ = 0;\n    int opt_min_len = 0;\n    int opt_n_bins = 50;\n    bool opt_full_width = true;\n    char *opt_output_file = NULL;\n    bam_aux_t **data = NULL;\n    bam_mplp_t mplp = NULL;\n    const bam_pileup1_t **plp = NULL;\n    uint32_t *hist = NULL;\n    stats_aux_t *stats = NULL;\n    char *opt_reg = 0; // specified region\n    char *opt_file_list = NULL;\n    int n_bam_files = 0;\n    char **fn = NULL;\n    int fail_flags = (BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP); // Default fail flags\n    int required_flags = 0;\n    int print_value_warning = 0;\n\n    int *n_plp = NULL;\n    sam_hdr_t *h = NULL; // BAM header of the 1st input\n\n    bool opt_print_header = true;\n    bool opt_print_tabular = true;\n    bool opt_print_histogram = false;\n    bool opt_plot_coverage = false;\n    bool opt_full_utf = true;\n\n    FILE *file_out = stdout;\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 0, '-'),\n        {\"rf\", required_argument, NULL, 1}, // require flag\n        {\"ff\", required_argument, NULL, 2}, // filter flag\n        {\"incl-flags\", required_argument, NULL, 1}, // require flag\n        {\"excl-flags\", required_argument, NULL, 2}, // filter flag\n        {\"bam-list\", required_argument, NULL, 'b'},\n        {\"min-read-len\", required_argument, NULL, 'l'},\n        {\"min-MQ\", required_argument, NULL, 'q'},\n        {\"min-mq\", required_argument, NULL, 'q'},\n        {\"min-BQ\", required_argument, NULL, 'Q'},\n        {\"min-bq\", required_argument, NULL, 'Q'},\n        {\"histogram\", no_argument, NULL, 'm'},\n        {\"ascii\", no_argument, NULL, 'A'},\n        {\"plot-depth\", no_argument, NULL, 'D'},\n        {\"output\", required_argument, NULL, 'o'},\n        {\"no-header\", no_argument, NULL, 'H'},\n        {\"n-bins\", required_argument, NULL, 'w'},\n        {\"region\", required_argument, NULL, 'r'},\n        {\"help\", no_argument, NULL, 'h'},\n        {\"depth\", required_argument, NULL, 'd'},\n        { NULL, 0, NULL, 0 }\n    };\n\n    // parse the command line\n    int c;\n    opterr = 0;\n    while ((c = getopt_long(argc, argv, \"Ao:l:q:Q:hHw:r:b:md:D\", lopts, NULL)) != -1) {\n        switch (c) {\n            case 1:\n                if ((required_flags = bam_str2flag(optarg)) < 0) {\n                    fprintf(stderr,\"Could not parse --rf %s\\n\", optarg); return EXIT_FAILURE;\n                }; break;\n            case 2:\n                if ((fail_flags = bam_str2flag(optarg)) < 0) {\n                    fprintf(stderr,\"Could not parse --ff %s\\n\", optarg); return EXIT_FAILURE;\n                }; break;\n            case 'o': opt_output_file = optarg; opt_full_width = false; break;\n            case 'l': opt_min_len = atoi(optarg); break;\n            case 'q': opt_min_mapQ = atoi(optarg); break;\n            case 'Q': opt_min_baseQ = atoi(optarg); break;\n            case 'd': max_depth = atoi(optarg); break; // maximum coverage depth\n            case 'w': opt_n_bins = atoi(optarg); opt_full_width = false;\n                      opt_print_histogram = true; opt_print_tabular = false;\n                      break;\n            case 'r': opt_reg = optarg; break;   // parsing a region requires a BAM header (strdup unnecessary)\n            case 'b': opt_file_list = optarg; break;\n            case 'm': opt_print_histogram = true; opt_print_tabular = false; break;\n            case 'A': opt_full_utf = false;\n                      opt_print_histogram = true; opt_print_tabular = false;\n                      break;\n            case 'D': opt_print_histogram = true;\n                     opt_print_tabular = false;\n                     opt_plot_coverage = true;\n                     break;\n            case 'H': opt_print_header = false; break;\n            case 'h': return usage();\n            default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                          /* else fall-through */\n            case '?':\n                if (optopt != '?') {  // '-?' appeared on command line\n                    if (optopt) { // Bad short option\n                        print_error(\"coverage\", \"invalid option -- '%c'\", optopt);\n                    } else { // Bad long option\n                        // Do our best.  There is no good solution to finding\n                        // out what the bad option was.\n                        // See, e.g. https://stackoverflow.com/questions/2723888/where-does-getopt-long-store-an-unrecognized-option\n                        if (optind > 0 && strncmp(argv[optind - 1], \"--\", 2) == 0) {\n                            print_error(\"coverage\", \"unrecognised option '%s'\",\n                                        argv[optind - 1]);\n                        }\n                    }\n                }\n                return usage();\n        }\n    }\n    if (optind == argc && !opt_file_list)\n        return usage();\n\n    // output file provided by user\n    if (opt_output_file != NULL && strcmp(opt_output_file,\"-\")!=0) {\n        file_out = fopen( opt_output_file, \"w\" );\n        if (file_out == NULL) {\n            print_error_errno(\"coverage\", \"Cannot open \\\"%s\\\" for writing.\", opt_output_file);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (opt_n_bins <= 0 || opt_full_width) {\n        // get number of columns of terminal\n        const char* env_columns = getenv(\"COLUMNS\");\n        int columns = 0;\n        if (env_columns == NULL) {\n#ifdef _WIN32\n            CONSOLE_SCREEN_BUFFER_INFO csbi;\n            if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {\n                columns = csbi.srWindow.Right - csbi.srWindow.Left + 1;\n            }\n#elif defined TIOCGWINSZ\n            struct winsize w;\n            if (ioctl(2, TIOCGWINSZ, &w) == 0)\n                columns = w.ws_col;\n#endif\n        } else {\n            columns = atoi(env_columns); // atoi(NULL) returns 0\n        }\n\n        if (columns > 60) {\n            opt_n_bins = columns - 40;\n        } else {\n            opt_n_bins = 40;\n        }\n    }\n\n    // setvbuf(file_out, NULL, _IONBF, 0); //turn off buffering\n\n    // Open all BAM files\n    if (opt_file_list) {\n        // Read file names from opt_file_list into argv, and record the number of files in n_bam_files\n        if (read_file_list(opt_file_list, &n_bam_files, &fn)) {\n            print_error_errno(\"coverage\", \"Cannot open file list \\\"%s\\\".\", opt_file_list);\n            return EXIT_FAILURE;\n        }\n        argv = fn;\n        optind = 0;\n    } else {\n        n_bam_files = argc - optind; // the number of BAMs on the command line\n    }\n\n    data = (bam_aux_t **)calloc(n_bam_files, sizeof(bam_aux_t*)); // data[i] for the i-th BAM file\n    if (!data) {\n        print_error_errno(\"coverage\", \"Failed to allocate memory\");\n        status = EXIT_FAILURE;\n        goto coverage_end;\n    }\n\n    for (i = 0; i < n_bam_files; ++i) {\n        int rf;\n        data[i] = (bam_aux_t *) calloc(1, sizeof(bam_aux_t));\n        if (!data[i]) {\n            print_error_errno(\"coverage\", \"Failed to allocate memory\");\n            status = EXIT_FAILURE;\n            goto coverage_end;\n        }\n        data[i]->fp = sam_open_format(argv[optind+i], \"r\", &ga.in); // open BAM\n\n        if (data[i]->fp == NULL) {\n            print_error_errno(\"coverage\", \"Could not open \\\"%s\\\"\", argv[optind+i]);\n            status = EXIT_FAILURE;\n            goto coverage_end;\n        }\n        rf = SAM_FLAG | SAM_RNAME | SAM_POS | SAM_MAPQ | SAM_CIGAR | SAM_SEQ;\n        if (opt_min_baseQ) rf |= SAM_QUAL;\n\n        // Set CRAM options on file handle - returns 0 on success\n        if (hts_set_opt(data[i]->fp, CRAM_OPT_REQUIRED_FIELDS, rf)) {\n            print_error(\"coverage\", \"Failed to set CRAM_OPT_REQUIRED_FIELDS value\");\n            status = EXIT_FAILURE;\n            goto coverage_end;\n        }\n        if (hts_set_opt(data[i]->fp, CRAM_OPT_DECODE_MD, 0)) {\n            print_error(\"coverage\", \"Failed to set CRAM_OPT_DECODE_MD value\");\n            status = EXIT_FAILURE;\n            goto coverage_end;\n        }\n        data[i]->min_mapQ = opt_min_mapQ;            // set the mapQ filter\n        data[i]->min_len  = opt_min_len;             // set the qlen filter\n        data[i]->hdr = sam_hdr_read(data[i]->fp);    // read the BAM header\n        data[i]->fail_flags = fail_flags;\n        data[i]->required_flags = required_flags;\n        if (data[i]->hdr == NULL) {\n            print_error_errno(\"coverage\", \"Could not read header for \\\"%s\\\"\", argv[optind+i]);\n            status = EXIT_FAILURE;\n            goto coverage_end;\n        }\n\n        // Lookup region if specified\n        if (opt_reg) { // if a region is specified\n            hts_idx_t *idx = sam_index_load(data[i]->fp, argv[optind+i]);  // load the index\n            if (idx == NULL) {\n                print_error_errno(\"coverage\", \"Failed to load index for \\\"%s\\\"\", argv[optind+i]);\n                status = EXIT_FAILURE;\n                goto coverage_end;\n            }\n            data[i]->iter = sam_itr_querys(idx, data[i]->hdr, opt_reg); // set the iterator\n            hts_idx_destroy(idx); // the index is not needed any more; free the memory\n            if (data[i]->iter == NULL) {\n                print_error(\"coverage\", \"Failed to parse region \\\"%s\\\". Check the region format or region name presence in the file \\\"%s\\\"\", opt_reg, argv[optind+i]);\n                status = EXIT_FAILURE;\n                goto coverage_end;\n            }\n        }\n    }\n\n    if (opt_print_tabular && opt_print_header)\n        fputs(\"#rname\\tstartpos\\tendpos\\tnumreads\\tcovbases\\tcoverage\\tmeandepth\\tmeanbaseq\\tmeanmapq\\n\", file_out);\n\n    h = data[0]->hdr; // easy access to the header of the 1st BAM\n    int n_targets = sam_hdr_nref(h);\n    stats = calloc(n_targets, sizeof(stats_aux_t));\n    if (!stats) {\n        print_error_errno(\"coverage\", \"Failed to allocate memory\");\n        status = EXIT_FAILURE;\n        goto coverage_end;\n    }\n\n    int64_t n_bins = opt_n_bins;\n    if (opt_reg) {\n        stats_aux_t *s = stats + data[0]->iter->tid;\n        s->beg = data[0]->iter->beg; // and to the parsed region coordinates\n        s->end = data[0]->iter->end;\n        if (s->end == HTS_POS_MAX) {\n            s->end = sam_hdr_tid2len(h, data[0]->iter->tid);\n        }\n        if (opt_n_bins > s->end - s->beg) {\n            n_bins = s->end - s->beg;\n        }\n        s->bin_width = (s->end-s->beg) / (n_bins > 0 ? n_bins : 1);\n    }\n\n    for (i=0; i<n_bam_files; i++)\n        data[i]->stats = stats;\n\n    int64_t current_bin = 0;\n\n    // the core multi-pileup loop\n    mplp = bam_mplp_init(n_bam_files, read_bam, (void**)data); // initialization\n    if (max_depth > 0)\n        bam_mplp_set_maxcnt(mplp, max_depth);  // set maximum coverage depth\n    else if (!max_depth)\n        bam_mplp_set_maxcnt(mplp, INT_MAX);\n\n\n    // Extra info for histogram and coverage counting\n    hist = (uint32_t*) calloc(opt_n_bins, sizeof(uint32_t));\n    n_plp = (int*) calloc(n_bam_files, sizeof(int*)); // n_plp[i] is the number of covering reads from the i-th BAM\n    plp = (const bam_pileup1_t**) calloc(n_bam_files, sizeof(bam_pileup1_t*)); // plp[i] points to the array of covering reads (internal in mplp)\n    if (!hist || !n_plp || !plp) {\n        print_error_errno(\"coverage\", \"Failed to allocate memory\");\n        status = EXIT_FAILURE;\n        goto coverage_end;\n    }\n\n    while ((ret=bam_mplp_auto(mplp, &tid, &pos, n_plp, plp)) > 0) { // come to the next covered position\n\n        if (tid != old_tid) { // Next target sequence\n            if (old_tid >= 0) {\n                if (opt_print_histogram) {\n                    print_hist(file_out, h, stats, old_tid, hist, n_bins, opt_full_utf, opt_plot_coverage);\n                    fputc('\\n', file_out);\n                } else if (opt_print_tabular) {\n                    print_tabular_line(file_out, h, stats, old_tid);\n                }\n\n                if (opt_print_histogram)\n                    memset(hist, 0, n_bins*sizeof(uint32_t));\n            }\n\n            stats[tid].covered = true;\n            if (!opt_reg)\n                stats[tid].end = sam_hdr_tid2len(h, tid);\n\n            if (opt_print_histogram) {\n                n_bins = opt_n_bins > stats[tid].end-stats[tid].beg? stats[tid].end-stats[tid].beg : opt_n_bins;\n                stats[tid].bin_width = (stats[tid].end-stats[tid].beg) / n_bins;\n            }\n\n            old_tid = tid;\n        }\n        if (pos < stats[tid].beg || pos >= stats[tid].end) continue; // out of range; skip\n        if (tid >= n_targets) continue;     // diff number of @SQ lines per file?\n\n        if (opt_print_histogram) {\n            current_bin = (pos - stats[tid].beg) / stats[tid].bin_width;\n        }\n\n        bool count_base = false;\n        for (i = 0; i < n_bam_files; ++i) { // base level filters have to go here\n            int depth_at_pos = n_plp[i];\n            for (j = 0; j < n_plp[i]; ++j) {\n                const bam_pileup1_t *p = plp[i] + j; // DON'T modify plp[][] unless you really know\n\n                if (p->is_del || p->is_refskip) {\n                    --depth_at_pos; // having dels or refskips at tid:pos\n                } else if (p->qpos < p->b->core.l_qseq) {\n                    if (bam_get_qual(p->b)[p->qpos] < opt_min_baseQ) {\n                        --depth_at_pos; // low base quality\n                    } else {\n                        stats[tid].summed_baseQ += bam_get_qual(p->b)[p->qpos];\n                        stats[tid].quality_bases++;\n                    }\n                } else {\n                    print_value_warning = 1; // no quality at position\n                }\n            }\n\n            if (depth_at_pos > 0) {\n                count_base = true;\n                stats[tid].summed_coverage += depth_at_pos;\n            }\n\n            if(current_bin < n_bins && opt_plot_coverage) {\n                hist[current_bin] += depth_at_pos;\n            }\n        }\n        if (count_base) {\n            stats[tid].n_covered_bases++;\n            if (opt_print_histogram && current_bin < n_bins && !opt_plot_coverage)\n                ++(hist[current_bin]); // Histogram based on breadth of coverage\n        }\n    }\n\n    if (tid == -1 && opt_reg && *opt_reg != '*')\n        // Region specified but no data covering it.\n        tid = data[0]->iter->tid;\n\n    if (tid < n_targets && tid >=0) {\n        if (opt_print_histogram) {\n            print_hist(file_out, h, stats, tid, hist, n_bins, opt_full_utf, opt_plot_coverage);\n        } else if (opt_print_tabular) {\n            print_tabular_line(file_out, h, stats, tid);\n        }\n    }\n\n\n    if (!opt_reg && opt_print_tabular) {\n        for (i = 0; i < n_targets; ++i) {\n            if (!stats[i].covered) {\n                stats[i].end = sam_hdr_tid2len(h, i);\n                print_tabular_line(file_out, h, stats, i);\n            }\n        }\n    }\n\n    if (print_value_warning) {\n        print_error(\"coverage\", \"Warning:  Missing quality values in alignments.  Mean base quality calculated only on available values.\");\n    }\n\n    if (ret < 0) status = EXIT_FAILURE;\n\ncoverage_end:\n    if (n_plp) free(n_plp);\n    if (plp) free(plp);\n    if (mplp) bam_mplp_destroy(mplp);\n\n    if (hist) free(hist);\n    if (stats) free(stats);\n\n    // Close files and free data structures\n    if (!(file_out == stdout || fclose(file_out) == 0)) {\n        if (status == EXIT_SUCCESS) {\n            print_error_errno(\"coverage\", \"error on closing \\\"%s\\\"\",\n                    (opt_output_file && strcmp(opt_output_file, \"-\") != 0?\n                     opt_output_file : \"stdout\"));\n            status = EXIT_FAILURE;\n        }\n    }\n\n    if (data) {\n        for (i = 0; i < n_bam_files && data[i]; ++i) {\n            sam_hdr_destroy(data[i]->hdr);\n            if (data[i]->fp) sam_close(data[i]->fp);\n            hts_itr_destroy(data[i]->iter);\n            free(data[i]);\n        }\n        free(data);\n    }\n\n    if (opt_file_list && fn) {\n        for (i = 0; i < n_bam_files; ++i)\n            free(fn[i]);\n        free(fn);\n    }\n    sam_global_args_free(&ga);\n\n    return status;\n}\n\n#ifdef _MAIN_BAMCOV\nint main(int argc, char *argv[]) {\n    return main_coverage(argc, argv);\n}\n#endif\n"
        },
        {
          "name": "cram_size.c",
          "type": "blob",
          "size": 20.1435546875,
          "content": "/*  cram_size.c -- produces summary of the size of each cram data-series\n\n    Copyright (C) 2023 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n// TODO: add range query.  Eg the ability to look at size for \"*\" only\n// (unmapped), or in a specific region such as a centromere.\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <strings.h>\n\n#include \"htslib/bgzf.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/cram.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/khash.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n#include \"htslib/hfile.h\"\n\n/*----------------------------------------------------------------------\n * Compression method handling\n */\n\n// A numeric version of the cram_method_details struct.\n// We expand the myriad of struct field combinations into a single\n// enumerated type so we can index and accumulate statistics for\n// purposes of reporting.\n//\n// These expanded numeric values have no definition within CRAM itself\n// and never occur within the file format.\nenum comp_expanded {\n    //----\n    // Copies from htslib cram_block_method enum\n    COMP_RAW    = CRAM_COMP_RAW,\n    COMP_GZIP   = CRAM_COMP_GZIP,\n    COMP_BZIP2  = CRAM_COMP_BZIP2,\n    COMP_LZMA   = CRAM_COMP_LZMA,\n    COMP_RANS8  = CRAM_COMP_RANS4x8,\n    COMP_RANS16 = CRAM_COMP_RANSNx16,\n    COMP_ARITH  = CRAM_COMP_ARITH,\n    COMP_FQZ    = CRAM_COMP_FQZ,\n    COMP_TOK3   = CRAM_COMP_TOK3,\n\n    //----\n    // Localised variants.\n\n    // Gzip\n    COMP_GZIP_1,\n    COMP_GZIP_9,\n\n    // Bzip2\n    COMP_BZIP2_1,\n    COMP_BZIP2_2,\n    COMP_BZIP2_3,\n    COMP_BZIP2_4,\n    COMP_BZIP2_5,\n    COMP_BZIP2_6,\n    COMP_BZIP2_7,\n    COMP_BZIP2_8,\n    COMP_BZIP2_9,\n\n    // rans 4x8\n    COMP_RANS4x8_O0,\n    COMP_RANS4x8_O1,\n\n    // rans Nx16.  Note order here is to enable selection via bit-fields\n    // bit 0: O0/O1\n    // bit 1: RLE\n    // bit 2: PACK\n    // bit 3: 32x16\n    COMP_RANS4x16_O0,\n    COMP_RANS4x16_O1,\n    COMP_RANS4x16_O0R,   // +RLE\n    COMP_RANS4x16_O1R,\n    COMP_RANS4x16_O0P,   // +PACK\n    COMP_RANS4x16_O1P,\n    COMP_RANS4x16_O0PR,  // +PACK+RLE\n    COMP_RANS4x16_O1PR,\n    COMP_RANS32x16_O0,   // SIMD variants\n    COMP_RANS32x16_O1,\n    COMP_RANS32x16_O0R,  // +RLE\n    COMP_RANS32x16_O1R,\n    COMP_RANS32x16_O0P,  // +PACK\n    COMP_RANS32x16_O1P,\n    COMP_RANS32x16_O0PR, // +PACK+RLE\n    COMP_RANS32x16_O1PR,\n    COMP_RANSNx16_STRIPE,\n    COMP_RANSNx16_CAT,\n\n    // Arith\n    COMP_ARITH_O0,\n    COMP_ARITH_O1,\n    COMP_ARITH_O0R,   // +RLE\n    COMP_ARITH_O1R,\n    COMP_ARITH_O0P,   // +PACK\n    COMP_ARITH_O1P,\n    COMP_ARITH_O0PR,  // +PACK+RLE\n    COMP_ARITH_O1PR,\n    COMP_ARITH_STRIPE,\n    COMP_ARITH_CAT,   // no entropy encoder\n    COMP_ARITH_EXT,   // external entropy encode\n\n    // Nake tokeniser\n    COMP_TOK3_RANS,\n    COMP_TOK3_ARITH,\n\n    // To mark maximum size\n    COMP_MAX,\n};\n\nstatic enum comp_expanded comp_method2expanded(cram_method_details *cm) {\n    switch (cm->method) {\n    case CRAM_COMP_GZIP:\n        switch (cm->level) {\n        case 1:  return COMP_GZIP_1;\n        case 9:  return COMP_GZIP_9;\n        default: return COMP_GZIP;\n        }\n        break;\n\n    case CRAM_COMP_BZIP2:\n        if (cm->level >= 1 && cm->level <= 9)\n            return COMP_BZIP2_1 + cm->level-1;\n        else\n            return COMP_BZIP2;\n        break;\n\n    case CRAM_COMP_RANS4x8:\n        return cm->order ? COMP_RANS4x8_O1 : COMP_RANS4x8_O0;\n\n    case CRAM_COMP_RANSNx16: {\n        // 8 4x16, 8 32x16 and 2 stripe/cat\n        if (cm->stripe) return COMP_RANSNx16_STRIPE;\n        if (cm->cat)    return COMP_RANSNx16_CAT;\n        int c = COMP_RANS4x16_O0;\n        c += 1*cm->order;\n        c += 2*cm->rle;\n        c += 4*cm->pack;\n        c += 8*(cm->Nway==32);\n        return c;\n    }\n\n    case CRAM_COMP_ARITH: {\n        // 8 4x16, 8 32x16 and 2 stripe/cat\n        if (cm->stripe) return COMP_ARITH_STRIPE;\n        if (cm->cat)    return COMP_ARITH_CAT;\n        if (cm->ext)    return COMP_ARITH_EXT;\n        int c = COMP_ARITH_O0;\n        c += 1*cm->order;\n        c += 2*cm->rle;\n        c += 4*cm->pack;\n        return c;\n    }\n\n    case CRAM_COMP_TOK3:\n        return cm->level < 10\n            ? COMP_TOK3_RANS\n            : COMP_TOK3_ARITH;\n\n    default:\n        // Any unspecialised method\n        return (enum comp_expanded)cm->method;\n    }\n}\n\n// Short form of cram_block_method_int type\nstatic char comp_method2char[COMP_MAX] =\n    \".gblr0afn\"           // standard CRAM methods\n    \"_G\"                  // gzip\n    \"bbbbbbbbB\"           // bzip2\n    \"rR\"                  // rans4x8\n    \"010101014545454582\"  // ransNx16\n    \"aAaAaAaAaaa\"         // arith\n    \"nN\";                 // tok3\n\n// Long form of cram_block_method_int type\nstatic char *comp_method2str[COMP_MAX] = {\n    // Standard CRAM methods\n    \"raw\", \"gzip\", \"bzip2\", \"lzma\", \"r4x8\", \"rNx16\",\n    \"arith\", \"fqzcomp\", \"tok3\",\n\n    // custom gzip\n    \"gzip-min\", \"gzip-max\",\n\n    // custom bzip2\n    \"bzip2-1\", \"bzip2-2\", \"bzip2-3\", \"bzip2-4\", \"bzip2-5\",\n    \"bzip2-6\", \"bzip2-7\", \"bzip2-8\", \"bzip2-9\",\n\n    // rANS 4x8\n    \"r4x8-o0\", \"r4x8-o1\",\n\n    // rANS 4x16\n    \"r4x16-o0\",   \"r4x16-o1\",\n\n    \"r4x16-o0R\",  \"r4x16-o1R\",\n    \"r4x16-o0P\",  \"r4x16-o1P\",\n    \"r4x16-o0PR\", \"r4x16-o1PR\",\n    \"r32x16-o0\",  \"r32x16-o1\",\n    \"r32x16-o0R\", \"r32x16-o1R\",\n    \"r32x16-o0P\", \"r32x16-o1P\",\n    \"r32x16-o0PR\",\"r32x16-o1PR\",\n    \"rNx16-xo0\",  \"rNx16-cat\",\n\n    // Arith\n    \"arith-o0\",   \"arith-o1\",\n    \"arith-o0R\",  \"arith-o1R\",\n    \"arith-o0P\",  \"arith-o1P\",\n    \"arith-o0PR\", \"arith-o1PR\",\n    \"arith-stripe\", \"arith-cat\", \"arith-ext\",\n\n    // Name tokeniser\n    \"tok3-rans\", \"tok3-arith\",\n};\n\n/*----------------------------------------------------------------------\n * Manipulation and sorting of Block Content-ID arrays and hashes\n */\n\ntypedef struct {\n    int64_t csize[COMP_MAX];\n    int64_t usize[COMP_MAX];\n} cusize_t;\n\nstatic int64_t total_csize(cusize_t *cu) {\n    int i;\n    int64_t tot = 0;\n    for (i = 0; i < COMP_MAX; i++)\n        tot += cu->csize[i];\n    return tot;\n}\n\nstatic int64_t total_usize(cusize_t *cu) {\n    int i;\n    int64_t tot = 0;\n    for (i = 0; i < COMP_MAX; i++)\n        tot += cu->usize[i];\n    return tot;\n}\n\n// cusize_t array and sorting by compressed size\nstatic cusize_t *sort_cusize_global; // avoids a messy extra data type\nstatic int sort_cusize_compar(const void *i1, const void *i2) {\n    int64_t n = sort_cusize_global->csize[*(const int *)i2] -\n                sort_cusize_global->csize[*(const int *)i1];\n    return n > 0 ? 1 : (n < 0 ? -1 : *(const int *)i1 - *(const int *)i2);\n}\n\n// Sort a cusize array by size of used method.\n// Returns cu->csize[comp] indices in descending size, as static mem\nstatic int *sort_cusize(cusize_t *cu) {\n    static int idx[COMP_MAX];\n    int i;\n    for (i = 0; i < COMP_MAX; i++)\n        idx[i] = i;\n    sort_cusize_global = cu;\n    qsort(idx, COMP_MAX, sizeof(*idx), sort_cusize_compar);\n\n    return idx;\n}\n\n// Hash table of cusize_t and sorting by key (content-id)\nKHASH_MAP_INIT_INT(cu, cusize_t)\n\n/* Sort by hash key. Global due to rubbish qsort API, but it's simple. */\nstatic khash_t(cu) *global_cu_hash = NULL;\nstatic int cu_compar(const void *i1, const void *i2) {\n    return kh_key(global_cu_hash, *(const int *)i1) -\n           kh_key(global_cu_hash, *(const int *)i2);\n}\n\n/*----------------------------------------------------------------------\n * Main cram_size reporting and aggregation\n */\nstatic off_t report_size(FILE *outfp, int verbose, int ref_seq_blk,\n                         khash_t(cu) *cu_size, cram_cid2ds_t *cid2ds) {\n    if (!cu_size || !cid2ds)\n        return -1;\n\n    khiter_t k;\n    off_t tot_size = 0;\n\n    fprintf(outfp, \"#   Content_ID  Uncomp.size    Comp.size   Ratio Method%.*s  Data_series\\n\", verbose ? 4 : 0, \"    \");\n    int *sorted_blocks = malloc(kh_end(cu_size)*sizeof(int));\n    if (!sorted_blocks)\n        return -1;\n    int nblocks = 0;\n    for (k = kh_begin(cu_size); k != kh_end(cu_size); k++) {\n        if (!kh_exist(cu_size, k))\n            continue;\n        sorted_blocks[nblocks++] = k;\n    }\n    global_cu_hash = cu_size;\n    qsort(sorted_blocks, nblocks, sizeof(int), cu_compar);\n\n    int i;\n    for (i = 0; i < nblocks; i++) {\n        k = sorted_blocks[i];\n\n        if (verbose) {\n            // FULL output\n            int *comp_idx = sort_cusize(&kh_value(cu_size, k));\n            int first_line = 1, c, j;\n            for (c = 0; c < COMP_MAX; c++) {\n                int comp = comp_idx[c];\n                if (!kh_value(cu_size, k).csize[comp] && c)\n                    break;\n\n                if (!first_line)\n                    fprintf(outfp, \"\\n\");\n                first_line = 0;\n\n                if ((int)kh_key(cu_size, k) < 0)\n                    fprintf(outfp, \"BLOCK %8s\", \"CORE\");\n                else\n                    fprintf(outfp, \"BLOCK %8d\", kh_key(cu_size, k));\n\n                fprintf(outfp, \" %12\"PRId64\" %12\"PRId64,\n                        kh_value(cu_size, k).usize[comp],\n                        kh_value(cu_size, k).csize[comp]);\n                double f = (100.0*(kh_value(cu_size, k).csize[comp]+.0001)) /\n                    (kh_value(cu_size, k).usize[comp]+.0001);\n                if (f > 999)\n                    fprintf(outfp, \"   >999%% %-11s\", comp_method2str[comp]);\n                else\n                    fprintf(outfp, \" %6.2f%% %-11s\",f, comp_method2str[comp]);\n\n                int n, *dsa = cram_cid2ds_query(cid2ds, kh_key(cu_size, k), &n);\n                for (j = 0; j < n; j++) {\n                    int d = dsa[j];\n                    if (d > 65535)\n                        fprintf(outfp, \" %c%c%c\", d>>16, (d>>8)&0xff, d&0xff);\n                    else\n                        fprintf(outfp, \" %c%c\", (d>>8)&0xff, d&0xff);\n                }\n            }\n        } else {\n            // aggregate by compression type.\n            int64_t csize = total_csize(&kh_value(cu_size, k));\n            int64_t usize = total_usize(&kh_value(cu_size, k));\n            int *comp_idx = sort_cusize(&kh_value(cu_size, k));\n\n            char cstr[COMP_MAX+1] = {0};\n            int cidx = 0, c;\n            for (c = 0; c < COMP_MAX; c++) {\n                if (!kh_value(cu_size, k).csize[comp_idx[c]])\n                    break;\n                cstr[cidx++] = comp_method2char[comp_idx[c]];\n            }\n            if (!*cstr) *cstr = '.';\n\n            if ((int)kh_key(cu_size, k) < 0)\n                fprintf(outfp, \"BLOCK %8s\", \"CORE\");\n            else\n                fprintf(outfp, \"BLOCK %8d\", kh_key(cu_size, k));\n            fprintf(outfp, \" %12\"PRId64\" %12\"PRId64, usize, csize);\n            double f = 100*(csize+.0001)/(usize+.0001);\n            if (f > 999)\n                fprintf(outfp, \"   >999%% %-7s\", cstr);\n            else\n                fprintf(outfp, \" %6.2f%% %-7s\", f, cstr);\n\n            int n, j, *dsa = cram_cid2ds_query(cid2ds, kh_key(cu_size, k), &n);\n            for (j = 0; j < n; j++) {\n                int d = dsa[j];\n                if (d > 65535)\n                    fprintf(outfp, \" %c%c%c\", d>>16, (d>>8)&0xff, d&0xff);\n                else\n                    fprintf(outfp, \" %c%c\", (d>>8)&0xff, d&0xff);\n            }\n        }\n\n        if ((int)kh_key(cu_size, k) >= 0 &&\n            (int)kh_key(cu_size, k) == ref_seq_blk) {\n            fprintf(outfp, \" embedded_ref\");\n        }\n        fprintf(outfp, \"\\n\");\n\n        tot_size += total_csize(&kh_value(cu_size, k));\n    }\n\n    free(sorted_blocks);\n\n    return tot_size;\n}\n\n/* Main processing loop */\nstatic int cram_size(hFILE *hf_in, samFile *in, sam_hdr_t *h, FILE *outfp,\n                     int verbose, int encodings) {\n    cram_fd *in_c;\n    cram_container *c = NULL;\n    cram_block *blk = NULL;\n    cram_block_slice_hdr *shdr = NULL;\n    khiter_t k;\n    int ret;\n    cram_cid2ds_t *cid2ds = NULL;\n    khash_t(cu) *cu_size = kh_init(cu);\n    int ref_seq_blk_used = -1;\n    int64_t nseqs = 0, nbases = 0, ncont = 0, nslice = 0;\n\n    if (!in->is_cram) {\n        print_error(\"cram_size\", \"Input is not a CRAM file\");\n        goto err;\n    }\n    in_c = in->fp.cram; // low level htslib abuse?\n    while ((c = cram_read_container(in_c))) {\n        if (cram_container_is_empty(in_c)) {\n            cram_block *blk;\n            // Container compression header\n            if (!(blk = cram_read_block(in_c)))\n                goto err;\n            cram_free_block(blk);\n            cram_free_container(c);\n            c = NULL; blk = NULL;\n            continue;\n        }\n\n        nseqs  += cram_container_get_num_records(c);\n        nbases += cram_container_get_num_bases(c);\n\n        // Container compression header\n        int32_t num_slices;\n        if (!(blk = cram_read_block(in_c)))\n            goto err;\n\n        // Decode compression header...\n        cram_block_compression_hdr *chdr;\n        chdr = cram_decode_compression_header(in_c, blk);\n\n        if (encodings) {\n            kstring_t ks = KS_INITIALIZE;\n            if (cram_describe_encodings(chdr, &ks) < 0)\n                goto err;\n\n            fprintf(outfp, \"Container encodings\\n%s\\n\", ks_str(&ks));\n\n            ks_free(&ks);\n        }\n\n        cid2ds = cram_update_cid2ds_map(chdr, cid2ds);\n\n        cram_free_block(blk);\n        blk = NULL;\n\n        cram_free_compression_header(chdr);\n\n        // Container num_blocks can be invalid, due to a bug.\n        // Instead we iterate in slice context instead.\n        (void)cram_container_get_landmarks(c, &num_slices);\n        ncont++;\n        nslice += num_slices;\n\n        int i, j;\n        for (i = 0; i < num_slices; i++) {\n            // Slice header\n            if (!(blk = cram_read_block(in_c)))\n                goto err;\n            if (!(shdr = cram_decode_slice_header(in_c, blk)))\n                goto err;\n            cram_free_block(blk);\n            blk = NULL;\n\n            int ref_seq_blk = cram_slice_hdr_get_embed_ref_id(shdr);\n            int num_blocks = cram_slice_hdr_get_num_blocks(shdr);\n\n            // Embedded reference.  Check it's consistent (if used this is\n            // an almost guaranteed certainty, so we take the easy route).\n            if (ref_seq_blk >= 0) {\n                if (ref_seq_blk_used == -1)\n                    ref_seq_blk_used = ref_seq_blk;\n                else if (ref_seq_blk_used != ref_seq_blk)\n                    fprintf(stderr, \"Embedded reference is not consistently using the same Content-Id.\\n\"\n                            \"Reported figures for reference will be invalid.\\n\");\n            }\n\n            // Slice data blocks\n            for (j = 0; j < num_blocks; j++) {\n                // read and discard, unless it's the ref-ID block\n                if (!(blk = cram_read_block(in_c)))\n                    goto err;\n\n                int32_t csize = cram_block_get_comp_size(blk);\n                int32_t usize = cram_block_get_uncomp_size(blk);\n                int cid = cram_block_get_content_id(blk);\n                enum cram_block_method method = cram_block_get_method(blk);\n\n                // Expand comp to the internal sub-formats, eg\n                // rANS order-0/1, PACK+RLE, etc.\n                cram_method_details *cm;\n                cm = cram_expand_method(cram_block_get_data(blk),\n                                        cram_block_get_comp_size(blk),\n                                        method);\n                if (!cm)\n                    goto err;\n                enum comp_expanded comp\n                    = comp_method2expanded(cm);\n                free(cm);\n\n                k = kh_put(cu, cu_size, cid, &ret);\n                if (ret < 0)\n                    goto err;\n                if (ret == 0) {\n                    kh_value(cu_size, k).csize[comp] += csize;\n                    kh_value(cu_size, k).usize[comp] += usize;\n                } else {\n                    memset(&kh_value(cu_size, k), 0, sizeof(cusize_t));\n                    kh_value(cu_size, k).csize[comp]  = csize;\n                    kh_value(cu_size, k).usize[comp]  = usize;\n                }\n\n                cram_free_block(blk);\n                blk = NULL;\n            }\n            cram_free_slice_header(shdr);\n            shdr = NULL;\n        }\n\n        cram_free_container(c);\n        c = NULL;\n    }\n\n    off_t tot_size = report_size(outfp, verbose, ref_seq_blk_used,\n                                 cu_size, cid2ds);\n    if (tot_size < 0)\n        goto err;\n\n    kh_destroy(cu, cu_size);\n    cram_cid2ds_free(cid2ds);\n\n    off_t end = htell(hf_in);\n\n    fprintf(outfp, \"\\n\");\n    fprintf(outfp, \"Number of containers  %18\"PRId64\"\\n\", ncont);\n    fprintf(outfp, \"Number of slices      %18\"PRId64\"\\n\", nslice);\n    fprintf(outfp, \"Number of sequences   %18\"PRId64\"\\n\", nseqs);\n    fprintf(outfp, \"Number of bases       %18\"PRId64\"\\n\", nbases);\n    fprintf(outfp, \"Total file size       %18\"PRId64\"\\n\", (int64_t) end);\n    fprintf(outfp, \"Format overhead size  %18\"PRId64\"\\n\", (int64_t) (end - tot_size));\n\n    return 0;\n\n err:\n    // Report anyway so we can get stats on partial files, but be\n    // sure to error too.\n    report_size(outfp, verbose, ref_seq_blk_used, cu_size, cid2ds);\n\n    print_error(\"cram_size\", \"Failed in decoding CRAM file\");\n    if (blk)\n        cram_free_block(blk);\n    if (shdr)\n        cram_free_slice_header(shdr);\n    if (c)\n        cram_free_container(c);\n    if (cid2ds)\n        cram_cid2ds_free(cid2ds);\n\n    return -1;\n}\n\n/* main() for cram_size */\nint main_cram_size(int argc, char *argv[]) {\n    int c, usage = 0, verbose = 0, encodings = 0;\n    sam_hdr_t *h = 0;\n    hFILE *hf_in = NULL;\n    samFile *in = NULL;\n    sam_global_args ga;\n    FILE *outfp = stdout;\n\n    static const struct option lopts[] = {\n        {\"output\", required_argument, NULL, 'o'},\n        {\"verbose\",  no_argument, NULL, 'v'},\n        {\"encodings\", no_argument, NULL, 'e'},\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', '-', '-'),\n        { NULL, 0, NULL, 0 }\n    };\n\n    sam_global_args_init(&ga);\n\n    while ((c = getopt_long(argc, argv, \"vo:e\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'o':\n            if (!(outfp = fopen(optarg, \"w\"))) {\n                perror(optarg);\n                goto err;\n            }\n            break;\n\n        case 'v':\n            verbose++;\n            break;\n\n        case 'e':\n            encodings++;\n            break;\n\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?': usage=1; break;\n        }\n    }\n\n    if ((optind == argc && isatty(0)) || usage) {\n        printf(\"Usage: samtools cram_size [-ve] [-o out.size] [in.cram]\\n\");\n        return 0;\n    }\n\n    char *fn = optind < argc ? argv[optind] : \"-\";\n\n    // We want access to in->fp.cram->fp, but this is an opaque struct so we\n    // can't get that.  However we opened with hopen and then reopen as\n    // CRAM with hts_hopen, which will swallow the initial hFILE and take\n    // owenership of it.  Hence we now know in->fp.cram->fp.\n    if (!(hf_in = hopen(fn, \"r\"))) {\n        print_error_errno(\"cram_size\", \"failed to open file '%s'\", fn);\n        return 1;\n    }\n    if (!(in = hts_hopen(hf_in, fn, \"r\"))) {\n        print_error_errno(\"cram_size\", \"failed to open file '%s'\", fn);\n        goto err;\n    }\n\n    if (!(h = sam_hdr_read(in)))\n        goto err;\n\n    int ret = cram_size(hf_in, in, h, outfp, verbose, encodings);\n    sam_hdr_destroy(h);\n    sam_close(in);\n    if (outfp != stdout)\n        fclose(outfp);\n\n    return ret ? 1 : 0;\n\n err:\n    if (in)\n        sam_close(in);\n    if (h)\n        sam_hdr_destroy(h);\n\n    return 1;\n}\n"
        },
        {
          "name": "cut_target.c",
          "type": "blob",
          "size": 8.6904296875,
          "content": "/*  cut_target.c -- targetcut subcommand.\n\n    Copyright (C) 2011 Broad Institute.\n    Copyright (C) 2012-2013, 2015, 2016, 2019 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"htslib/hts.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/faidx.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\n#define ERR_DEP 0.83\n\ntypedef struct {\n    int e[2][3], p[2][2];\n} score_param_t;\n\n/* Note that although the two matrics have 10 parameters in total, only 4\n * (probably 3) are free.  Changing the scoring matrices in a sort of symmetric\n * way will not change the result. */\nstatic score_param_t g_param = { {{0,0,0},{-4,1,6}}, {{0,-14000}, {0,0}} };\n\ntypedef struct {\n    int min_baseQ, tid, max_bases;\n    uint16_t *bases;\n    samFile *fp;\n    sam_hdr_t *h;\n    char *ref;\n    hts_pos_t len;\n    faidx_t *fai;\n    errmod_t *em;\n} ct_t;\n\nstatic uint16_t gencns(ct_t *g, int n, const bam_pileup1_t *plp)\n{\n    int i, j, ret, tmp, k, sum[4], qual;\n    float q[16];\n    if (n > g->max_bases) { // enlarge g->bases\n        g->max_bases = n;\n        kroundup32(g->max_bases);\n        g->bases = realloc(g->bases, (size_t) g->max_bases * 2);\n    }\n    for (i = k = 0; i < n; ++i) {\n        const bam_pileup1_t *p = plp + i;\n        uint8_t *seq;\n        int q, baseQ, b;\n        if (p->is_refskip || p->is_del) continue;\n        baseQ = bam_get_qual(p->b)[p->qpos];\n        if (baseQ < g->min_baseQ) continue;\n        seq = bam_get_seq(p->b);\n        b = seq_nt16_int[bam_seqi(seq, p->qpos)];\n        if (b > 3) continue;\n        q = baseQ < p->b->core.qual? baseQ : p->b->core.qual;\n        if (q < 4) q = 4;\n        if (q > 63) q = 63;\n        g->bases[k++] = q<<5 | bam_is_rev(p->b)<<4 | b;\n    }\n    if (k == 0) return 0;\n    errmod_cal(g->em, k, 4, g->bases, q);\n    for (i = 0; i < 4; ++i) sum[i] = (int)(q[i<<2|i] + .499) << 2 | i;\n    for (i = 1; i < 4; ++i) // insertion sort\n        for (j = i; j > 0 && sum[j] < sum[j-1]; --j)\n            tmp = sum[j], sum[j] = sum[j-1], sum[j-1] = tmp;\n    qual = (sum[1]>>2) - (sum[0]>>2);\n    k = k < 256? k : 255;\n    ret = (qual < 63? qual : 63) << 2 | (sum[0]&3);\n    return ret<<8|k;\n}\n\nstatic void process_cns(sam_hdr_t *h, int tid, hts_pos_t l, uint16_t *cns)\n{\n    int64_t i, s;\n    int f[2][2], *prev, *curr, *swap_tmp;\n    uint8_t *b; // backtrack array\n    b = calloc(l, 1);\n    f[0][0] = f[0][1] = 0;\n    prev = f[0]; curr = f[1];\n    // fill the backtrack matrix\n    for (i = 0; i < l; ++i) {\n        int c = (cns[i] == 0)? 0 : (cns[i]>>8 == 0)? 1 : 2;\n        int tmp0, tmp1;\n        // compute f[0]\n        tmp0 = prev[0] + g_param.e[0][c] + g_param.p[0][0]; // (s[i+1],s[i])=(0,0)\n        tmp1 = prev[1] + g_param.e[0][c] + g_param.p[1][0]; // (0,1)\n        if (tmp0 > tmp1) curr[0] = tmp0, b[i] = 0;\n        else curr[0] = tmp1, b[i] = 1;\n        // compute f[1]\n        tmp0 = prev[0] + g_param.e[1][c] + g_param.p[0][1]; // (s[i+1],s[i])=(1,0)\n        tmp1 = prev[1] + g_param.e[1][c] + g_param.p[1][1]; // (1,1)\n        if (tmp0 > tmp1) curr[1] = tmp0, b[i] |= 0<<1;\n        else curr[1] = tmp1, b[i] |= 1<<1;\n        // swap\n        swap_tmp = prev; prev = curr; curr = swap_tmp;\n    }\n    // backtrack\n    s = prev[0] > prev[1]? 0 : 1;\n    for (i = l - 1; i > 0; --i) {\n        b[i] |= s<<2;\n        s = b[i]>>s&1;\n    }\n    // print\n    for (i = 0, s = -1; i < INT64_MAX && i <= l; ++i) {\n        if (i == l || ((b[i]>>2&3) == 0 && s >= 0)) {\n            if (s >= 0) {\n                int64_t j;\n                printf(\"%s:%\"PRId64\"-%\"PRId64\"\\t0\\t%s\\t%\"PRId64\"\\t60\\t%\"PRId64\"M\\t*\\t0\\t0\\t\", sam_hdr_tid2name(h, tid), s+1, i, sam_hdr_tid2name(h, tid), s+1, i-s);\n                for (j = s; j < i; ++j) {\n                    int c = cns[j]>>8;\n                    if (c == 0) putchar('N');\n                    else putchar(\"ACGT\"[c&3]);\n                }\n                putchar('\\t');\n                for (j = s; j < i; ++j)\n                    putchar(33 + (cns[j]>>8>>2));\n                putchar('\\n');\n            }\n            //if (s >= 0) printf(\"%s\\t%d\\t%d\\t%d\\n\", h->target_name[tid], s, i, i - s);\n            s = -1;\n        } else if ((b[i]>>2&3) && s < 0) s = i;\n    }\n    free(b);\n}\n\nstatic int read_aln(void *data, bam1_t *b)\n{\n    ct_t *g = (ct_t*)data;\n    int ret;\n    while (1)\n    {\n        ret = sam_read1(g->fp, g->h, b);\n        if ( ret<0 ) break;\n        if ( b->core.flag & (BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP) ) continue;\n        if ( g->fai && b->core.tid >= 0 ) {\n            if (b->core.tid != g->tid) { // then load the sequence\n                free(g->ref);\n                g->ref = fai_fetch64(g->fai, sam_hdr_tid2name(g->h, b->core.tid), &g->len);\n                g->tid = b->core.tid;\n            }\n            sam_prob_realn(b, g->ref, g->len, 1<<1|1);\n        }\n        break;\n    }\n    return ret;\n}\n\nint main_cut_target(int argc, char *argv[])\n{\n    int c, tid, pos, n, lasttid = -1, usage = 0, status = EXIT_SUCCESS;\n    hts_pos_t l, max_l;\n    const bam_pileup1_t *p;\n    bam_plp_t plp;\n    uint16_t *cns;\n    ct_t g;\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 'f', '-'),\n        { NULL, 0, NULL, 0 }\n    };\n\n    memset(&g, 0, sizeof(ct_t));\n    g.min_baseQ = 13; g.tid = -1;\n    while ((c = getopt_long(argc, argv, \"f:Q:i:o:0:1:2:\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'Q': g.min_baseQ = atoi(optarg); break; // quality cutoff\n            case 'i': g_param.p[0][1] = -atoi(optarg); break; // 0->1 transition (in) PENALTY\n            case '0': g_param.e[1][0] = atoi(optarg); break; // emission SCORE\n            case '1': g_param.e[1][1] = atoi(optarg); break;\n            case '2': g_param.e[1][2] = atoi(optarg); break;\n            default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                      /* else fall-through */\n            case '?': usage=1; break;\n        }\n    }\n    if (ga.reference) {\n        g.fai = fai_load(ga.reference);\n        if (g.fai == 0) fprintf(stderr, \"[%s] fail to load the fasta index.\\n\", __func__);\n    }\n    if (usage || argc == optind) {\n        fprintf(stderr, \"Usage: samtools targetcut [-Q minQ] [-i inPen] [-0 em0] [-1 em1] [-2 em2] <in.bam>\\n\");\n        sam_global_opt_help(stderr, \"-.--f--.\");\n        return 1;\n    }\n    l = max_l = 0; cns = 0;\n    g.fp = sam_open_format(argv[optind], \"r\", &ga.in);\n    if (g.fp == NULL) {\n        print_error_errno(\"targetcut\", \"can't open \\\"%s\\\"\", argv[optind]);\n        return 1;\n    }\n\n    g.h = sam_hdr_read(g.fp);\n    if (g.h == NULL) {\n        print_error(\"targetcut\", \"couldn't read header for \\\"%s\\\"\", argv[optind]);\n        sam_close(g.fp);\n        return 1;\n    }\n    g.em = errmod_init(1. - ERR_DEP);\n    plp = bam_plp_init(read_aln, &g);\n    while ((p = bam_plp_auto(plp, &tid, &pos, &n)) != 0) {\n        if (tid < 0) break;\n        if (tid != lasttid) { // change of chromosome\n            if (cns) process_cns(g.h, lasttid, l, cns);\n            if (max_l < sam_hdr_tid2len(g.h, tid)) {\n                max_l = sam_hdr_tid2len(g.h, tid);\n                kroundup32(max_l);\n                cns = realloc(cns, max_l * 2);\n            }\n            l = sam_hdr_tid2len(g.h, tid);\n            memset(cns, 0, max_l * 2);\n            lasttid = tid;\n        }\n        cns[pos] = gencns(&g, n, p);\n    }\n    process_cns(g.h, lasttid, l, cns);\n\n    if (n < 0) {\n        print_error(\"targetcut\", \"error reading from \\\"%s\\\"\", argv[optind]);\n        status = EXIT_FAILURE;\n    }\n\n    free(cns);\n    sam_hdr_destroy(g.h);\n    bam_plp_destroy(plp);\n    sam_close(g.fp);\n    if (g.fai) {\n        fai_destroy(g.fai); free(g.ref);\n    }\n    errmod_destroy(g.em);\n    free(g.bases);\n    sam_global_args_free(&ga);\n    return status;\n}\n"
        },
        {
          "name": "dict.c",
          "type": "blob",
          "size": 7.349609375,
          "content": "/*  dict.c -- create a sequence dictionary file.\n\n    Copyright (C) 2015, 2020 Genome Research Ltd.\n\n    Author: Shane McCarthy <sm15@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <zlib.h>\n#include <getopt.h>\n#include \"htslib/khash.h\"\n#include \"htslib/kseq.h\"\n#include \"htslib/hts.h\"\n#include \"samtools.h\"\n\nKHASH_SET_INIT_STR(str)\nKSEQ_INIT(gzFile, gzread)\n\ntypedef struct _args_t\n{\n    char *output_fname, *alt_fname;\n    char *assembly, *species, *uri;\n    int  alias, header;\n    khash_t(str) *is_alt;\n}\nargs_t;\n\nstatic void write_dict(const char *fn, args_t *args)\n{\n    hts_md5_context *md5;\n    int l, i, k;\n    gzFile fp;\n    kseq_t *seq;\n    unsigned char digest[16];\n    char hex[33];\n\n    fp = strcmp(fn, \"-\") ? gzopen(fn, \"r\") : gzdopen(fileno(stdin), \"r\");\n    if (fp == 0) {\n        print_error_errno(\"dict\", \"Cannot open %s\", fn);\n        exit(1);\n    }\n    FILE *out = stdout;\n    if (args->output_fname) {\n        out = fopen(args->output_fname, \"w\");\n        if (out == NULL) {\n          print_error_errno(\"dict\", \"Cannot open %s for writing\", args->output_fname);\n          exit(1);\n        }\n    }\n\n    if (!(md5 = hts_md5_init()))\n        exit(1);\n\n    seq = kseq_init(fp);\n    if (args->header) fprintf(out, \"@HD\\tVN:1.0\\tSO:unsorted\\n\");\n    while ((l = kseq_read(seq)) >= 0) {\n        for (i = k = 0; i < seq->seq.l; ++i) {\n            if (seq->seq.s[i] >= '!' && seq->seq.s[i] <= '~')\n                seq->seq.s[k++] = toupper(seq->seq.s[i]);\n        }\n        hts_md5_reset(md5);\n        hts_md5_update(md5, (unsigned char*)seq->seq.s, k);\n        hts_md5_final(digest, md5);\n        hts_md5_hex(hex, digest);\n        fprintf(out, \"@SQ\\tSN:%s\\tLN:%d\\tM5:%s\", seq->name.s, k, hex);\n        if (args->is_alt && kh_get(str, args->is_alt, seq->name.s) != kh_end(args->is_alt))\n            fprintf(out, \"\\tAH:*\");\n        if (args->alias) {\n            const char *name = seq->name.s;\n            if (strncmp(name, \"chr\", 3) == 0) {\n                name += 3;\n                fprintf(out, \"\\tAN:%s\", name);\n            }\n            else\n                fprintf(out, \"\\tAN:chr%s\", name);\n\n            if (strcmp(name, \"M\") == 0)\n                fprintf(out, \",chrMT,MT\");\n            else if (strcmp(name, \"MT\") == 0)\n                fprintf(out, \",chrM,M\");\n        }\n        if (args->uri)\n            fprintf(out, \"\\tUR:%s\", args->uri);\n        else if (strcmp(fn, \"-\") != 0) {\n#ifdef _WIN32\n            char *real_path = _fullpath(NULL, fn, PATH_MAX);\n#else\n            char *real_path = realpath(fn, NULL);\n#endif\n            fprintf(out, \"\\tUR:file://%s\", real_path);\n            free(real_path);\n        }\n        if (args->assembly) fprintf(out, \"\\tAS:%s\", args->assembly);\n        if (args->species) fprintf(out, \"\\tSP:%s\", args->species);\n        fprintf(out, \"\\n\");\n    }\n    kseq_destroy(seq);\n    hts_md5_destroy(md5);\n\n    if (args->output_fname) fclose(out);\n    gzclose(fp);\n}\n\nstatic void read_alt_file(khash_t(str) *is_alt, const char *fname)\n{\n    htsFile *fp = hts_open(fname, \"r\");\n    if (fp == NULL) {\n        print_error_errno(\"dict\", \"Cannot open %s\", fname);\n        exit(1);\n    }\n\n    // .alt files are in a SAM-like format, but we don't use sam_read1()\n    // as these files may not have a complete set of @SQ headers.\n\n    kstring_t str = KS_INITIALIZE;\n    while (hts_getline(fp, KS_SEP_LINE, &str) >= 0) {\n        if (str.l == 0 || str.s[0] == '@') continue;\n\n        char *tab = strchr(str.s, '\\t');\n        if (tab) *tab = '\\0';\n\n        int ret;\n        char *seqname = strdup(str.s);\n        kh_put(str, is_alt, seqname, &ret);\n        if (ret == 0) free(seqname); // Already present\n    }\n\n    ks_free(&str);\n    hts_close(fp);\n}\n\nstatic int dict_usage(void)\n{\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"About:   Create a sequence dictionary file from a fasta file\\n\");\n    fprintf(stderr, \"Usage:   samtools dict [options] <file.fa|file.fa.gz>\\n\\n\");\n    fprintf(stderr, \"Options: -a, --assembly STR    assembly\\n\");\n    fprintf(stderr, \"         -A, --alias, --alternative-name\\n\");\n    fprintf(stderr, \"                               add AN tag by adding/removing 'chr'\\n\");\n    fprintf(stderr, \"         -H, --no-header       do not print @HD line\\n\");\n    fprintf(stderr, \"         -l, --alt FILE        add AH:* tag to alternate locus sequences\\n\");\n    fprintf(stderr, \"         -o, --output FILE     file to write out dict file [stdout]\\n\");\n    fprintf(stderr, \"         -s, --species STR     species\\n\");\n    fprintf(stderr, \"         -u, --uri STR         URI [file:///abs/path/to/file.fa]\\n\");\n    fprintf(stderr, \"\\n\");\n    return 1;\n}\n\nint dict_main(int argc, char *argv[])\n{\n    args_t *args = (args_t*) calloc(1,sizeof(args_t));\n    args->header = 1;\n\n    static const struct option loptions[] =\n    {\n        {\"help\", no_argument, NULL, 'h'},\n        {\"no-header\", no_argument, NULL, 'H'},\n        {\"alias\", no_argument, NULL, 'A'},\n        {\"alt\", required_argument, NULL, 'l'},\n        {\"alternative-name\", no_argument, NULL, 'A'},\n        {\"assembly\", required_argument, NULL, 'a'},\n        {\"species\", required_argument, NULL, 's'},\n        {\"uri\", required_argument, NULL, 'u'},\n        {\"output\", required_argument, NULL, 'o'},\n        {NULL, 0, NULL, 0}\n    };\n    int c;\n    while ( (c=getopt_long(argc,argv,\"?AhHa:l:s:u:o:\",loptions,NULL))>0 )\n    {\n        switch (c)\n        {\n            case 'A': args->alias = 1; break;\n            case 'a': args->assembly = optarg; break;\n            case 'l': args->alt_fname = optarg; break;\n            case 's': args->species = optarg; break;\n            case 'u': args->uri = optarg; break;\n            case 'o': args->output_fname = optarg; break;\n            case 'H': args->header = 0; break;\n            case 'h': return dict_usage();\n            default: return dict_usage();\n        }\n    }\n\n    char *fname = NULL;\n    if ( optind>=argc )\n    {\n        if ( !isatty(STDIN_FILENO) ) fname = \"-\";  // reading from stdin\n        else return dict_usage();\n    }\n    else fname = argv[optind];\n\n    if (args->alt_fname) {\n        args->is_alt = kh_init(str);\n        read_alt_file(args->is_alt, args->alt_fname);\n    }\n\n    write_dict(fname, args);\n\n    if (args->is_alt) {\n        khint_t k;\n        for (k = 0; k < kh_end(args->is_alt); ++k)\n            if (kh_exist(args->is_alt, k)) free((char *) kh_key(args->is_alt, k));\n        kh_destroy(str, args->is_alt);\n    }\n\n    free(args);\n    return 0;\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "faidx.c",
          "type": "blob",
          "size": 24.2705078125,
          "content": "/*  faidx.c -- faidx subcommand.\n\n    Copyright (C) 2008, 2009, 2013, 2016, 2018-2020, 2022, 2024 Genome Research Ltd.\n    Portions copyright (C) 2011 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n\nHistory:\n\n  * 2016-01-12: Pierre Lindenbaum @yokofakun : added options -o -n\n\n*/\n\n#include <config.h>\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <getopt.h>\n#include <limits.h>\n#include <htslib/faidx.h>\n#include <htslib/hts.h>\n#include <htslib/hfile.h>\n#include <htslib/kstring.h>\n#include <htslib/bgzf.h>\n#include <htslib/thread_pool.h>\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n\n// Negative indicates the same as input data\n#define DEFAULT_FASTA_LINE_LEN -60\n\n#ifndef ABS\n#   define ABS(x) ((x)>=0?(x):-(x))\n#endif\n\n/// holds the indexing info for each read name and offsets\ntypedef struct idx_entry {\n    char *name;                 //name\n    uint64_t seq_offset;        //offset to sequence for given read/reference\n    uint64_t seq_length;        //length of sequence\n    uint64_t qual_offset;       //offset to qualify val for given read\n    uint64_t line_length;       //line length with output is made\n} idx_entry;\n\n/// index information about output\ntypedef struct idx {\n    size_t n, m;                    //no of used and max items in index\n    enum fai_format_options format; //fasta or fastq\n    idx_entry *indx;                //array of index info per sequence\n    uint64_t offset;                //accumulated offset\n} idx;\n\n//new params required for output creation\ntypedef struct output {\n    int isbgzip;                //is bgzip or uncompressed file\n    BGZF *bgzf_fp;              //bgzf file pointer\n    sam_global_args *gopt;      //options\n    idx *idxdata;               //index information\n    kstring_t buffer;\n} output;\n\nstatic unsigned char comp_base[256] = {\n  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,\n 16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,\n 32, '!', '\"', '#', '$', '%', '&', '\\'','(', ')', '*', '+', ',', '-', '.', '/',\n'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',\n'@', 'T', 'V', 'G', 'H', 'E', 'F', 'C', 'D', 'I', 'J', 'M', 'L', 'K', 'N', 'O',\n'P', 'Q', 'Y', 'S', 'A', 'A', 'B', 'W', 'X', 'R', 'Z', '[', '\\\\',']', '^', '_',\n'`', 't', 'v', 'g', 'h', 'e', 'f', 'c', 'd', 'i', 'j', 'm', 'l', 'k', 'n', 'o',\n'p', 'q', 'y', 's', 'a', 'a', 'b', 'w', 'x', 'r', 'z', '{', '|', '}', '~', 127,\n128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\n144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\n176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\n192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,\n208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,\n224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,\n};\n\nstatic void reverse_complement(char *str, const hts_pos_t len) {\n    char c;\n    hts_pos_t i = 0, j = len - 1;\n\n    while (i <= j) {\n        c = str[i];\n        str[i] = comp_base[(unsigned char)str[j]];\n        str[j] = comp_base[(unsigned char)c];\n        i++;\n        j--;\n    }\n}\n\nstatic void reverse(char *str, const hts_pos_t len) {\n    char c;\n    hts_pos_t i = 0, j = len - 1;\n\n    while (i < j) {\n        c = str[i];\n        str[i] = str[j];\n        str[j] = c;\n        i++;\n        j--;\n    }\n}\n\n/// allocidx - allocates required index data buffers\n/** @param in - pointer to idx structure\n returns NULL on failure\n returns index data buffer on success\n*/\nstatic inline idx_entry* allocidx(idx* in)\n{\n    if (in && in->n >= in->m) {\n        size_t newlen = in->m < 1 ? 16 : in->m << 1;   //double on reallocation\n        idx_entry *tmp = realloc(in->indx, newlen * sizeof(*tmp));\n        if (!tmp) {\n            return NULL;\n        }\n        size_t count = newlen - in->n;\n        memset(tmp + in->n, 0, count * sizeof(*tmp));\n        in->indx = tmp;\n        in->m = newlen;\n    }\n\n    return &in->indx[in->n++];\n}\n\n/// writeindex - writes index data\n/** @param out - pointer to output structure\n *  @param output_file - pointer to output file name\n returns non zero on failure\n returns 0 on success\n seq name and offsets are written on fai index, for both compressed and\n uncompressed outputs. gzi index, dumped through bgzf api, gives the index\n of plain offsets in compressed file\n*/\nint writeindex(output *out, char *output_file)\n{\n    idx *idxdata = out->idxdata;\n    kstring_t fainame = KS_INITIALIZE, buffer = KS_INITIALIZE;\n    int ret = 0;\n    FILE *fp = NULL;\n    size_t i = 0;\n\n    ksprintf(&fainame, \"%s.fai\", output_file);\n\n    if (!(fp = fopen(fainame.s, \"w\"))) {\n        fprintf(stderr, \"[faidx] Failed to create index file for output.\\n\");\n        ret = 1;\n        goto end;\n    }\n\n    // Write fai index data / index on plain - uncompressed data.\n    // Note on Windows htslib's hfile_oflags() and hopen_fd_stdinout()\n    // functions guarantee we'll set O_BINARY so the line length is always\n    // sequence length +1 regardless of the system native line ending.\n    for (i = 0; i < idxdata->n; ++i) {\n        idx_entry *e = &idxdata->indx[i];\n        ks_clear(&buffer);\n        if (idxdata->format == FAI_FASTA) {\n            //name, seq leng, seq offset, seq per line, char per line\n            ksprintf(&buffer, \"%s\\t%\"PRIu64\"\\t%\"PRIu64\"\\t%\"PRIu64\"\\t%\"\n                     PRIu64\"\\n\",\n                     e->name, e->seq_length, e->seq_offset, e->line_length,\n                     e->line_length + 1);\n        } else {    //FAI_FASTQ\n            //name, seq leng, seq offset, seq/line, char/line, qual offset\n            ksprintf(&buffer, \"%s\\t%\"PRIu64\"\\t%\"PRIu64\"\\t%\"PRIu64\"\\t%\"\n                     PRIu64\"\\t%\"PRIu64\"\\n\",\n                     e->name, e->seq_length, e->seq_offset, e->line_length,\n                     e->line_length + 1, e->qual_offset);\n        }\n        if (buffer.l != fwrite(buffer.s, 1, buffer.l, fp)) {\n            fprintf(stderr, \"[faidx] Failed to create fai index file for \"\n                    \"output.\\n\");\n            ret = 1;\n            goto end;\n        }\n    }\n    //write gzi index data, index on compressed file\n    if (out->isbgzip && bgzf_index_dump(out->bgzf_fp, output_file, \".gzi\")) {\n        fprintf(stderr, \"[faidx] Failed to create index gzi file for \"\n                \"output.\\n\");\n        ret = 1;\n    }\nend:\n    if (fp) {\n        fclose(fp);\n    }\n    ks_free(&buffer);\n    ks_free(&fainame);\n\n    return ret;\n}\n\nstatic int write_line(faidx_t *faid, output *out, const char *line,\n                      const char *name, const int ignore,\n                      const hts_pos_t length, const hts_pos_t seq_len) {\n    int id;\n    hts_pos_t beg, end;\n\n    if (seq_len < 0) {\n        fprintf(stderr, \"[faidx] Failed to fetch sequence in %s\\n\", name);\n\n        if (ignore && seq_len == -2) {\n            return 0;\n        } else {\n            return -1;\n        }\n    } else if (seq_len == 0) {\n        fprintf(stderr, \"[faidx] Zero length sequence: %s\\n\", name);\n    } else if (fai_parse_region(faid, name, &id, &beg, &end, 0)\n               && (end < HTS_POS_MAX) && (seq_len != end - beg)) {\n        fprintf(stderr, \"[faidx] Truncated sequence: %s\\n\", name);\n    }\n\n    hts_pos_t i, seq_sz = seq_len;\n\n    for (i = 0; i < seq_sz; i += length)\n    {\n        hts_pos_t len = i + length < seq_sz ? length : seq_sz - i;\n        if (bgzf_write(out->bgzf_fp, line + i, len) < len ||\n              bgzf_write(out->bgzf_fp, \"\\n\", 1) < 1) {\n            print_error_errno(\"faidx\", \"failed to write output\");\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int write_output(faidx_t *faid, output *out, const char *name,\n                        const int ignore, const hts_pos_t length, const int rev,\n                        const char *pos_strand_name,\n                        const char *neg_strand_name,\n                        enum fai_format_options format) {\n    hts_pos_t seq_len, wrap_len = length, len = 0;\n    char *seq =  NULL, *qual = NULL;\n    int ret = EXIT_FAILURE;\n    char *idx_name = NULL;\n\n    if (wrap_len < 0)\n        wrap_len = fai_line_length(faid, name);\n    if (wrap_len <= 0)\n        wrap_len = HTS_POS_MAX;\n\n    seq = fai_fetch64(faid, name, &seq_len);\n    if (rev && seq_len > 0) {\n        reverse_complement(seq, seq_len);\n    }\n\n    //write the name\n    ks_clear(&out->buffer);\n    len = ksprintf(&out->buffer, \"%c%s%s\\n\",\n                   format == FAI_FASTA ? '>' : '@', name,\n                   rev ? neg_strand_name : pos_strand_name);\n    if (out->gopt->write_index) {\n        if (!(idx_name = strdup(out->buffer.s+1))) {\n            fprintf(stderr,\"[faidx] Failed to allocate memory.\\n\");\n            goto end;\n        }\n        idx_name[out->buffer.l-2] = 0; // remove \\n\n    }\n    if (bgzf_write(out->bgzf_fp, out->buffer.s, out->buffer.l) < len) {\n        fprintf(stderr,\"[faidx] Failed to write buffer.\\n\");\n        goto end;\n    }\n\n    //write bases\n    if (write_line(faid, out, seq, name, ignore, wrap_len, seq_len) < 0)\n        goto end;\n\n    uint64_t seq_sz;\n    seq_sz = seq_len + seq_len / wrap_len + ((seq_len % wrap_len) ? 1 : 0);\n\n    if (format == FAI_FASTQ) {\n        //write quality\n        qual = fai_fetchqual64(faid, name, &seq_len);\n        if (rev && seq_len > 0)\n            reverse(qual, seq_len);\n\n        if (bgzf_write(out->bgzf_fp, \"+\\n\", 2) != 2) {\n            fprintf(stderr,\"[faidx] Failed to write buffer\\n\");\n            goto end;\n        }\n\n        if (write_line(faid, out, qual, name, ignore, wrap_len, seq_len) < 0)\n            goto end;\n    }\n\n    if (out->gopt->write_index) {\n        // On-the-fly index construction\n        idx_entry *e = NULL;\n        if (out->gopt->write_index && !(e = allocidx(out->idxdata))) {\n            fprintf(stderr, \"[faidx] Failed to allocate memory.\\n\");\n            goto end;\n        }\n\n        e->name = idx_name;\n        e->seq_offset = out->idxdata->offset + len;\n        e->seq_length = seq_len;\n        e->line_length = seq_len < wrap_len ? seq_len : wrap_len;\n        idx_name = NULL;\n        if (out->idxdata->format == FAI_FASTA) {\n            out->idxdata->offset = e->seq_offset + seq_sz;\n        } else { // FASTQ\n            e->qual_offset = e->seq_offset + seq_sz + 2; // \"+\\n\"\n            out->idxdata->offset = e->qual_offset + seq_sz;\n        }\n    }\n\n    ret = EXIT_SUCCESS;\n\nend:\n    free(seq);\n    free(qual);\n    free(idx_name);\n\n    return ret;\n}\n\n\nstatic int read_regions_from_file(faidx_t *faid, hFILE *in_file, output *out, const int ignore,\n                                  const hts_pos_t length, const int rev,\n                                  const char *pos_strand_name,\n                                  const char *neg_strand_name,\n                                  enum fai_format_options format) {\n    kstring_t line = {0, 0, NULL};\n    int ret = EXIT_FAILURE;\n\n    while (line.l = 0, kgetline(&line, (kgets_func *)hgets, in_file) >= 0) {\n        if ((ret = write_output(faid, out, line.s, ignore, length, rev, pos_strand_name, neg_strand_name, format)) == EXIT_FAILURE) {\n            break;\n        }\n    }\n\n    free(line.s);\n\n    return ret;\n}\n\nstatic int usage(FILE *fp, enum fai_format_options format, int exit_status)\n{\n    char *tool, *file_type, *index_name;\n\n    if (format == FAI_FASTA) {\n        tool = \"faidx <file.fa|file.fa.gz>\";\n        file_type = \"FASTA\";\n        index_name = \"file.fa\";\n    } else {\n        tool = \"fqidx <file.fq|file.fq.gz>\";\n        file_type = \"FASTQ\";\n        index_name = \"file.fq\";\n    }\n\n    fprintf(fp, \"Usage: samtools %s [<reg> [...]]\\n\", tool);\n    fprintf(fp, \"Option: \\n\"\n                \"  -o, --output FILE        Write %s to file.\\n\"\n                \"  -n, --length INT         Length of %s sequence line. [60]\\n\"\n                \"  -c, --continue           Continue after trying to retrieve missing region.\\n\"\n                \"  -r, --region-file FILE   File of regions.  Format is chr:from-to. One per line.\\n\"\n                \"  -i, --reverse-complement Reverse complement sequences.\\n\"\n                \"      --mark-strand TYPE   Add strand indicator to sequence name\\n\"\n                \"                           TYPE = rc   for /rc on negative strand (default)\\n\"\n                \"                                  no   for no strand indicator\\n\"\n                \"                                  sign for (+) / (-)\\n\"\n                \"                                  custom,<pos>,<neg> for custom indicator\\n\"\n                \"      --fai-idx      FILE  name of the index file (default %s.fai).\\n\"\n                \"      --gzi-idx      FILE  name of compressed file index (default %s.gz.gzi).\\n\",\n                file_type, file_type, index_name, index_name);\n\n\n    if (format == FAI_FASTA) {\n       fprintf(fp, \"  -f, --fastq              File and index in FASTQ format.\\n\");\n    }\n\n    fprintf(fp, \"  -h, --help               This message.\\n\");\n    sam_global_opt_help(fp, \"---.-@.-\");\n\n    return exit_status;\n}\n\nint faidx_core(int argc, char *argv[], enum fai_format_options format)\n{\n    int c, ignore_error = 0, rev = 0;\n    hts_pos_t line_len = DEFAULT_FASTA_LINE_LEN ;/* fasta line len */\n    char* output_file = NULL; /* output file (default is stdout ) */\n    char *region_file = NULL; // list of regions from file, one per line\n    char *pos_strand_name = \"\"; // Extension to add to name for +ve strand\n    char *neg_strand_name = \"/rc\"; // Extension to add to name for -ve strand\n    char *strand_names = NULL; // Used for custom strand annotation\n    char *fai_name = NULL; // specified index name\n    char *gzi_name = NULL; // specified compressed index name\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    int exit_status = EXIT_FAILURE;\n    idx idxdata = { 0, 0, FAI_FASTA, NULL};\n    struct output out = { 0, NULL, &ga, &idxdata, KS_INITIALIZE}; //data required for output writing\n    faidx_t *fai = NULL;\n    hts_tpool *pool = NULL;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', '-', '-', 0, '-', '@'),     //output format opt and thread count - long options\n        { \"output\", required_argument,       NULL, 'o' },\n        { \"help\",   no_argument,             NULL, 'h' },\n        { \"length\", required_argument,       NULL, 'n' },\n        { \"continue\", no_argument,           NULL, 'c' },\n        { \"region-file\", required_argument,  NULL, 'r' },\n        { \"fastq\", no_argument,              NULL, 'f' },\n        { \"reverse-complement\", no_argument, NULL, 'i' },\n        { \"mark-strand\", required_argument, NULL, 1000 },\n        { \"fai-idx\", required_argument,     NULL, 1001 },\n        { \"gzi-idx\", required_argument,     NULL, 1002 },\n        { NULL, 0, NULL, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \"ho:n:cr:fi@:\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'o':\n                {\n                    output_file = optarg;\n                    char *ext = strrchr(output_file, '.');\n                    if (!ext) {\n                        break;\n                    }\n                    if (!strcmp(ext, \".gz\") || !strcmp(ext, \".bgz\") || !strcmp(ext, \".bgzf\")) {\n                        out.isbgzip = 1;        //bgzip output\n                    }\n                    break;\n                }\n            case 'n': line_len = strtol(optarg, NULL, 10);\n                      if (line_len < 0) {\n                        fprintf(stderr,\"[faidx] bad line length '%s', using default:%d\\n\",optarg,ABS(DEFAULT_FASTA_LINE_LEN));\n                        line_len= ABS(DEFAULT_FASTA_LINE_LEN);\n                      }\n                      break;\n            case 'c': ignore_error = 1; break;\n            case 'r': region_file = optarg; break;\n            case 'f': format = FAI_FASTQ; break;\n            case 'i': rev = 1; break;\n            case '?':\n                exit_status = usage(stderr, format, EXIT_FAILURE);\n                goto exit2;\n                break;\n            case 'h':\n                exit_status = usage(stdout, format, EXIT_SUCCESS);\n                goto exit2;\n                break;\n            case 1000:\n                if (strcmp(optarg, \"no\") == 0) {\n                    pos_strand_name = neg_strand_name = \"\";\n                } else if (strcmp(optarg, \"sign\") == 0) {\n                    pos_strand_name = \"(+)\";\n                    neg_strand_name = \"(-)\";\n                } else if (strcmp(optarg, \"rc\") == 0) {\n                    pos_strand_name = \"\";\n                    neg_strand_name = \"/rc\";\n                } else if (strncmp(optarg, \"custom,\", 7) == 0) {\n                    size_t len = strlen(optarg + 7);\n                    size_t comma = strcspn(optarg + 7, \",\");\n                    free(strand_names);\n                    strand_names = pos_strand_name = malloc(len + 2);\n                    if (!strand_names) {\n                        fprintf(stderr, \"[faidx] Out of memory\\n\");\n                        goto exit2;\n                    }\n                    neg_strand_name = pos_strand_name + comma + 1;\n                    memcpy(pos_strand_name, optarg + 7, comma);\n                    pos_strand_name[comma] = '\\0';\n                    if (comma < len)\n                        memcpy(neg_strand_name, optarg + 7 + comma + 1,\n                               len - comma);\n                    neg_strand_name[len - comma] = '\\0';\n                } else {\n                    fprintf(stderr, \"[faidx] Unknown --mark-strand option \\\"%s\\\"\\n\", optarg);\n                    exit_status = usage(stderr, format, EXIT_FAILURE);\n                    goto exit2;\n                }\n                break;\n            case 1001: fai_name = optarg; break;\n            case 1002: gzi_name = optarg; break;\n            // handle standard samtools options like thread count, compression level...\n            default:\n                if (parse_sam_global_opt(c, optarg, lopts, &ga)) {\n                    fprintf(stderr, \"[faidx] Invalid option \\\"%s\\\"\\n\", optarg);\n                    goto exit2;\n                }\n                break;\n        }\n    }\n\n    if ( argc==optind ) {\n        exit_status = usage(stdout, format, EXIT_SUCCESS);\n        goto exit2;\n    }\n\n    if (optind+1 == argc && !region_file) {\n        if (output_file && !fai_name)\n            fai_name = output_file;\n\n        if (fai_build3(argv[optind], fai_name, gzi_name) != 0) {\n            if (fai_name)\n                fprintf(stderr, \"[faidx] Could not build fai index %s\", fai_name);\n            else\n                fprintf(stderr, \"[faidx] Could not build fai index %s.fai\", argv[optind]);\n\n            if (gzi_name)\n                fprintf(stderr, \" or compressed index %s\\n\", gzi_name);\n            else\n                fprintf(stderr, \"\\n\");\n\n            goto exit2;\n        }\n        exit_status = EXIT_SUCCESS;\n        goto exit2;\n    }\n\n    if (out.gopt->nthreads > 0) {       //setup thread pool\n        if (!(pool = hts_tpool_init(out.gopt->nthreads))) {\n            fprintf(stderr, \"Failed to setup thread pool\\n\");\n        }\n    }\n\n    fai = fai_load3_format(argv[optind], fai_name, gzi_name, FAI_CREATE, format);\n\n    if (!fai) {\n        if (fai_name)\n            fprintf(stderr, \"[faidx] Could not load fai index %s\", fai_name);\n        else\n            fprintf(stderr, \"[faidx] Could not load fai index %s.fai\", argv[optind]);\n\n        if (gzi_name)\n            fprintf(stderr, \" or compressed index %s\\n\", gzi_name);\n        else\n            fprintf(stderr, \"\\n\");\n\n        goto exit2;\n    }\n\n    if (pool) {                         //use thread pool if set\n        if (fai_thread_pool(fai, pool, 0)) {\n            fprintf(stderr, \"Failed to set thread pool for reading\\n\");\n        }\n    }\n\n    /** output file provided by user */\n    if( output_file != NULL ) {\n        if( strcmp( output_file, argv[optind] ) == 0 ) {\n            fprintf(stderr,\"[faidx] Same input/output : %s\\n\", output_file);\n            goto exit2;\n        }\n        char mode[13] = \"\";\n        if (out.isbgzip) {\n            hts_opt *opts = (hts_opt *)(out.gopt->out.specific);\n            int level = 4;                                      //default compression level\n            while (opts) {\n                if (opts->opt == HTS_OPT_COMPRESSION_LEVEL) {   //compression level\n                    level = opts->val.i;\n                    break;\n                }\n                opts = opts->next;\n            }\n            if (level >= 0) {\n                snprintf(mode, sizeof(mode), \"w%d\", level);     //pass compression with mode\n            }\n        } else {\n            snprintf(mode, sizeof(mode), \"wu\");                 //uncompressed output\n        }\n        out.bgzf_fp = bgzf_open(output_file, mode);\n\n        if( out.bgzf_fp == NULL) {\n            fprintf(stderr,\"[faidx] Cannot open \\\"%s\\\" for writing :%s.\\n\", output_file, strerror(errno) );\n            goto exit2;\n        }\n\n        if (ga.write_index) {\n            out.idxdata->format = format;\n            if(out.isbgzip && bgzf_index_build_init(out.bgzf_fp)) {\n                fprintf(stderr, \"[faidx] Failed to setup indexing.\\n\");\n                goto exit1;\n            }\n        }\n\n        if (pool) {                              //use thread pool if set\n            if (bgzf_thread_pool(out.bgzf_fp, pool, 0)) {\n                fprintf(stderr, \"Failed to set thread pool for writing\\n\");\n            }\n        }\n    } else {\n        if (!(out.bgzf_fp = bgzf_open(\"-\", \"wu\"))) {\n            fprintf(stderr,\"[faidx] Cannot open output for writing :%s.\\n\", strerror(errno) );\n            goto exit2;\n        }\n    }\n\n    if (region_file) {\n        hFILE *rf;\n\n        if ((rf = hopen(region_file, \"r\"))) {\n            exit_status = read_regions_from_file(fai, rf, &out, ignore_error, line_len, rev, pos_strand_name, neg_strand_name, format);\n\n            if (hclose(rf) != 0) {\n                fprintf(stderr, \"[faidx] Warning: failed to close %s\", region_file);\n            }\n            if (exit_status == EXIT_FAILURE) {\n                goto exit1;\n            }\n        } else {\n            fprintf(stderr, \"[faidx] Failed to open \\\"%s\\\" for reading.\\n\", region_file);\n            goto exit1;\n        }\n    }\n\n    exit_status = EXIT_SUCCESS;\n    while ( ++optind<argc && exit_status == EXIT_SUCCESS) {\n        exit_status = write_output(fai, &out, argv[optind], ignore_error, line_len, rev, pos_strand_name, neg_strand_name, format);\n    }\n\n    if (bgzf_flush(out.bgzf_fp) == EOF) {\n        print_error_errno(\"faidx\", \"Failed to flush output\\n\");\n        exit_status = EXIT_FAILURE;\n    }\n\nexit1:\n\n    if(ga.write_index && output_file) {\n        if (writeindex(&out, output_file)) {\n            print_error_errno(\"faidx\", \"Failed to create index\\n\");\n            exit_status = EXIT_FAILURE;\n        }\n    }\n        if (bgzf_close(out.bgzf_fp) < 0) {\n            print_error_errno(\"faidx\", \"Failed to close output\\n\");\n            exit_status = EXIT_FAILURE;\n        }\n\nexit2:\n    if (strand_names) {\n        free(strand_names);\n    }\n    if (fai) {\n        fai_destroy(fai);\n    }\n    if (pool) {\n        hts_tpool_destroy(pool);\n    }\n    if (out.idxdata) {\n        int i;\n        for (i = 0; i < out.idxdata->n; ++i) {\n            free(out.idxdata->indx[i].name);\n        }\n        free(out.idxdata->indx);\n    }\n    sam_global_args_free(&ga);\n    ks_free(&out.buffer);\n\n    return exit_status;\n}\n\n\nint faidx_main(int argc, char *argv[]) {\n    return faidx_core(argc, argv, FAI_FASTA);\n}\n\n\nint fqidx_main(int argc, char *argv[]) {\n    return faidx_core(argc, argv, FAI_FASTQ);\n}\n\n"
        },
        {
          "name": "install-sh",
          "type": "blob",
          "size": 14.3310546875,
          "content": "#!/bin/sh\n# install - install a program, script, or datafile\n\nscriptversion=2013-12-25.23; # UTC\n\n# This originates from X11R5 (mit/util/scripts/install.sh), which was\n# later released in X11R6 (xc/config/util/install.sh) with the\n# following copyright and license.\n#\n# Copyright (C) 1994 X Consortium\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to\n# deal in the Software without restriction, including without limitation the\n# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n# sell copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-\n# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n# Except as contained in this notice, the name of the X Consortium shall not\n# be used in advertising or otherwise to promote the sale, use or other deal-\n# ings in this Software without prior written authorization from the X Consor-\n# tium.\n#\n#\n# FSF changes to this file are in the public domain.\n#\n# Calling this script install-sh is preferred over install.sh, to prevent\n# 'make' implicit rules from creating a file called install from it\n# when there is no Makefile.\n#\n# This script is compatible with the BSD install script, but was written\n# from scratch.\n\ntab='\t'\nnl='\n'\nIFS=\" $tab$nl\"\n\n# Set DOITPROG to \"echo\" to test this script.\n\ndoit=${DOITPROG-}\ndoit_exec=${doit:-exec}\n\n# Put in absolute file names if you don't have them in your path;\n# or use environment vars.\n\nchgrpprog=${CHGRPPROG-chgrp}\nchmodprog=${CHMODPROG-chmod}\nchownprog=${CHOWNPROG-chown}\ncmpprog=${CMPPROG-cmp}\ncpprog=${CPPROG-cp}\nmkdirprog=${MKDIRPROG-mkdir}\nmvprog=${MVPROG-mv}\nrmprog=${RMPROG-rm}\nstripprog=${STRIPPROG-strip}\n\nposix_mkdir=\n\n# Desired mode of installed file.\nmode=0755\n\nchgrpcmd=\nchmodcmd=$chmodprog\nchowncmd=\nmvcmd=$mvprog\nrmcmd=\"$rmprog -f\"\nstripcmd=\n\nsrc=\ndst=\ndir_arg=\ndst_arg=\n\ncopy_on_change=false\nis_target_a_directory=possibly\n\nusage=\"\\\nUsage: $0 [OPTION]... [-T] SRCFILE DSTFILE\n   or: $0 [OPTION]... SRCFILES... DIRECTORY\n   or: $0 [OPTION]... -t DIRECTORY SRCFILES...\n   or: $0 [OPTION]... -d DIRECTORIES...\n\nIn the 1st form, copy SRCFILE to DSTFILE.\nIn the 2nd and 3rd, copy all SRCFILES to DIRECTORY.\nIn the 4th, create DIRECTORIES.\n\nOptions:\n     --help     display this help and exit.\n     --version  display version info and exit.\n\n  -c            (ignored)\n  -C            install only if different (preserve the last data modification time)\n  -d            create directories instead of installing files.\n  -g GROUP      $chgrpprog installed files to GROUP.\n  -m MODE       $chmodprog installed files to MODE.\n  -o USER       $chownprog installed files to USER.\n  -s            $stripprog installed files.\n  -t DIRECTORY  install into DIRECTORY.\n  -T            report an error if DSTFILE is a directory.\n\nEnvironment variables override the default commands:\n  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG\n  RMPROG STRIPPROG\n\"\n\nwhile test $# -ne 0; do\n  case $1 in\n    -c) ;;\n\n    -C) copy_on_change=true;;\n\n    -d) dir_arg=true;;\n\n    -g) chgrpcmd=\"$chgrpprog $2\"\n        shift;;\n\n    --help) echo \"$usage\"; exit $?;;\n\n    -m) mode=$2\n        case $mode in\n          *' '* | *\"$tab\"* | *\"$nl\"* | *'*'* | *'?'* | *'['*)\n            echo \"$0: invalid mode: $mode\" >&2\n            exit 1;;\n        esac\n        shift;;\n\n    -o) chowncmd=\"$chownprog $2\"\n        shift;;\n\n    -s) stripcmd=$stripprog;;\n\n    -t)\n        is_target_a_directory=always\n        dst_arg=$2\n        # Protect names problematic for 'test' and other utilities.\n        case $dst_arg in\n          -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n        esac\n        shift;;\n\n    -T) is_target_a_directory=never;;\n\n    --version) echo \"$0 $scriptversion\"; exit $?;;\n\n    --) shift\n        break;;\n\n    -*) echo \"$0: invalid option: $1\" >&2\n        exit 1;;\n\n    *)  break;;\n  esac\n  shift\ndone\n\n# We allow the use of options -d and -T together, by making -d\n# take the precedence; this is for compatibility with GNU install.\n\nif test -n \"$dir_arg\"; then\n  if test -n \"$dst_arg\"; then\n    echo \"$0: target directory not allowed when installing a directory.\" >&2\n    exit 1\n  fi\nfi\n\nif test $# -ne 0 && test -z \"$dir_arg$dst_arg\"; then\n  # When -d is used, all remaining arguments are directories to create.\n  # When -t is used, the destination is already specified.\n  # Otherwise, the last argument is the destination.  Remove it from $@.\n  for arg\n  do\n    if test -n \"$dst_arg\"; then\n      # $@ is not empty: it contains at least $arg.\n      set fnord \"$@\" \"$dst_arg\"\n      shift # fnord\n    fi\n    shift # arg\n    dst_arg=$arg\n    # Protect names problematic for 'test' and other utilities.\n    case $dst_arg in\n      -* | [=\\(\\)!]) dst_arg=./$dst_arg;;\n    esac\n  done\nfi\n\nif test $# -eq 0; then\n  if test -z \"$dir_arg\"; then\n    echo \"$0: no input file specified.\" >&2\n    exit 1\n  fi\n  # It's OK to call 'install-sh -d' without argument.\n  # This can happen when creating conditional directories.\n  exit 0\nfi\n\nif test -z \"$dir_arg\"; then\n  if test $# -gt 1 || test \"$is_target_a_directory\" = always; then\n    if test ! -d \"$dst_arg\"; then\n      echo \"$0: $dst_arg: Is not a directory.\" >&2\n      exit 1\n    fi\n  fi\nfi\n\nif test -z \"$dir_arg\"; then\n  do_exit='(exit $ret); exit $ret'\n  trap \"ret=129; $do_exit\" 1\n  trap \"ret=130; $do_exit\" 2\n  trap \"ret=141; $do_exit\" 13\n  trap \"ret=143; $do_exit\" 15\n\n  # Set umask so as not to create temps with too-generous modes.\n  # However, 'strip' requires both read and write access to temps.\n  case $mode in\n    # Optimize common cases.\n    *644) cp_umask=133;;\n    *755) cp_umask=22;;\n\n    *[0-7])\n      if test -z \"$stripcmd\"; then\n        u_plus_rw=\n      else\n        u_plus_rw='% 200'\n      fi\n      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;\n    *)\n      if test -z \"$stripcmd\"; then\n        u_plus_rw=\n      else\n        u_plus_rw=,u+rw\n      fi\n      cp_umask=$mode$u_plus_rw;;\n  esac\nfi\n\nfor src\ndo\n  # Protect names problematic for 'test' and other utilities.\n  case $src in\n    -* | [=\\(\\)!]) src=./$src;;\n  esac\n\n  if test -n \"$dir_arg\"; then\n    dst=$src\n    dstdir=$dst\n    test -d \"$dstdir\"\n    dstdir_status=$?\n  else\n\n    # Waiting for this to be detected by the \"$cpprog $src $dsttmp\" command\n    # might cause directories to be created, which would be especially bad\n    # if $src (and thus $dsttmp) contains '*'.\n    if test ! -f \"$src\" && test ! -d \"$src\"; then\n      echo \"$0: $src does not exist.\" >&2\n      exit 1\n    fi\n\n    if test -z \"$dst_arg\"; then\n      echo \"$0: no destination specified.\" >&2\n      exit 1\n    fi\n    dst=$dst_arg\n\n    # If destination is a directory, append the input filename; won't work\n    # if double slashes aren't ignored.\n    if test -d \"$dst\"; then\n      if test \"$is_target_a_directory\" = never; then\n        echo \"$0: $dst_arg: Is a directory\" >&2\n        exit 1\n      fi\n      dstdir=$dst\n      dst=$dstdir/`basename \"$src\"`\n      dstdir_status=0\n    else\n      dstdir=`dirname \"$dst\"`\n      test -d \"$dstdir\"\n      dstdir_status=$?\n    fi\n  fi\n\n  obsolete_mkdir_used=false\n\n  if test $dstdir_status != 0; then\n    case $posix_mkdir in\n      '')\n        # Create intermediate dirs using mode 755 as modified by the umask.\n        # This is like FreeBSD 'install' as of 1997-10-28.\n        umask=`umask`\n        case $stripcmd.$umask in\n          # Optimize common cases.\n          *[2367][2367]) mkdir_umask=$umask;;\n          .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;\n\n          *[0-7])\n            mkdir_umask=`expr $umask + 22 \\\n              - $umask % 100 % 40 + $umask % 20 \\\n              - $umask % 10 % 4 + $umask % 2\n            `;;\n          *) mkdir_umask=$umask,go-w;;\n        esac\n\n        # With -d, create the new directory with the user-specified mode.\n        # Otherwise, rely on $mkdir_umask.\n        if test -n \"$dir_arg\"; then\n          mkdir_mode=-m$mode\n        else\n          mkdir_mode=\n        fi\n\n        posix_mkdir=false\n        case $umask in\n          *[123567][0-7][0-7])\n            # POSIX mkdir -p sets u+wx bits regardless of umask, which\n            # is incompatible with FreeBSD 'install' when (umask & 300) != 0.\n            ;;\n          *)\n            tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$\n            trap 'ret=$?; rmdir \"$tmpdir/d\" \"$tmpdir\" 2>/dev/null; exit $ret' 0\n\n            if (umask $mkdir_umask &&\n                exec $mkdirprog $mkdir_mode -p -- \"$tmpdir/d\") >/dev/null 2>&1\n            then\n              if test -z \"$dir_arg\" || {\n                   # Check for POSIX incompatibilities with -m.\n                   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or\n                   # other-writable bit of parent directory when it shouldn't.\n                   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.\n                   ls_ld_tmpdir=`ls -ld \"$tmpdir\"`\n                   case $ls_ld_tmpdir in\n                     d????-?r-*) different_mode=700;;\n                     d????-?--*) different_mode=755;;\n                     *) false;;\n                   esac &&\n                   $mkdirprog -m$different_mode -p -- \"$tmpdir\" && {\n                     ls_ld_tmpdir_1=`ls -ld \"$tmpdir\"`\n                     test \"$ls_ld_tmpdir\" = \"$ls_ld_tmpdir_1\"\n                   }\n                 }\n              then posix_mkdir=:\n              fi\n              rmdir \"$tmpdir/d\" \"$tmpdir\"\n            else\n              # Remove any dirs left behind by ancient mkdir implementations.\n              rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null\n            fi\n            trap '' 0;;\n        esac;;\n    esac\n\n    if\n      $posix_mkdir && (\n        umask $mkdir_umask &&\n        $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\"\n      )\n    then :\n    else\n\n      # The umask is ridiculous, or mkdir does not conform to POSIX,\n      # or it failed possibly due to a race condition.  Create the\n      # directory the slow way, step by step, checking for races as we go.\n\n      case $dstdir in\n        /*) prefix='/';;\n        [-=\\(\\)!]*) prefix='./';;\n        *)  prefix='';;\n      esac\n\n      oIFS=$IFS\n      IFS=/\n      set -f\n      set fnord $dstdir\n      shift\n      set +f\n      IFS=$oIFS\n\n      prefixes=\n\n      for d\n      do\n        test X\"$d\" = X && continue\n\n        prefix=$prefix$d\n        if test -d \"$prefix\"; then\n          prefixes=\n        else\n          if $posix_mkdir; then\n            (umask=$mkdir_umask &&\n             $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\") && break\n            # Don't fail if two instances are running concurrently.\n            test -d \"$prefix\" || exit 1\n          else\n            case $prefix in\n              *\\'*) qprefix=`echo \"$prefix\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;;\n              *) qprefix=$prefix;;\n            esac\n            prefixes=\"$prefixes '$qprefix'\"\n          fi\n        fi\n        prefix=$prefix/\n      done\n\n      if test -n \"$prefixes\"; then\n        # Don't fail if two instances are running concurrently.\n        (umask $mkdir_umask &&\n         eval \"\\$doit_exec \\$mkdirprog $prefixes\") ||\n          test -d \"$dstdir\" || exit 1\n        obsolete_mkdir_used=true\n      fi\n    fi\n  fi\n\n  if test -n \"$dir_arg\"; then\n    { test -z \"$chowncmd\" || $doit $chowncmd \"$dst\"; } &&\n    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dst\"; } &&\n    { test \"$obsolete_mkdir_used$chowncmd$chgrpcmd\" = false ||\n      test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dst\"; } || exit 1\n  else\n\n    # Make a couple of temp file names in the proper directory.\n    dsttmp=$dstdir/_inst.$$_\n    rmtmp=$dstdir/_rm.$$_\n\n    # Trap to clean up those temp files at exit.\n    trap 'ret=$?; rm -f \"$dsttmp\" \"$rmtmp\" && exit $ret' 0\n\n    # Copy the file name to the temp name.\n    (umask $cp_umask && $doit_exec $cpprog \"$src\" \"$dsttmp\") &&\n\n    # and set any options; do chmod last to preserve setuid bits.\n    #\n    # If any of these fail, we abort the whole thing.  If we want to\n    # ignore errors from any of these, just make sure not to ignore\n    # errors from the above \"$doit $cpprog $src $dsttmp\" command.\n    #\n    { test -z \"$chowncmd\" || $doit $chowncmd \"$dsttmp\"; } &&\n    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dsttmp\"; } &&\n    { test -z \"$stripcmd\" || $doit $stripcmd \"$dsttmp\"; } &&\n    { test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dsttmp\"; } &&\n\n    # If -C, don't bother to copy if it wouldn't change the file.\n    if $copy_on_change &&\n       old=`LC_ALL=C ls -dlL \"$dst\"     2>/dev/null` &&\n       new=`LC_ALL=C ls -dlL \"$dsttmp\"  2>/dev/null` &&\n       set -f &&\n       set X $old && old=:$2:$4:$5:$6 &&\n       set X $new && new=:$2:$4:$5:$6 &&\n       set +f &&\n       test \"$old\" = \"$new\" &&\n       $cmpprog \"$dst\" \"$dsttmp\" >/dev/null 2>&1\n    then\n      rm -f \"$dsttmp\"\n    else\n      # Rename the file to the real destination.\n      $doit $mvcmd -f \"$dsttmp\" \"$dst\" 2>/dev/null ||\n\n      # The rename failed, perhaps because mv can't rename something else\n      # to itself, or perhaps because mv is so ancient that it does not\n      # support -f.\n      {\n        # Now remove or move aside any old file at destination location.\n        # We try this two ways since rm can't unlink itself on some\n        # systems and the destination file might be busy for other\n        # reasons.  In this case, the final cleanup might fail but the new\n        # file should still install successfully.\n        {\n          test ! -f \"$dst\" ||\n          $doit $rmcmd -f \"$dst\" 2>/dev/null ||\n          { $doit $mvcmd -f \"$dst\" \"$rmtmp\" 2>/dev/null &&\n            { $doit $rmcmd -f \"$rmtmp\" 2>/dev/null; :; }\n          } ||\n          { echo \"$0: cannot unlink or rename $dst\" >&2\n            (exit 1); exit 1\n          }\n        } &&\n\n        # Now rename the file to the real destination.\n        $doit $mvcmd \"$dsttmp\" \"$dst\"\n      }\n    fi || exit 1\n\n    trap '' 0\n  fi\ndone\n\n# Local variables:\n# eval: (add-hook 'write-file-hooks 'time-stamp)\n# time-stamp-start: \"scriptversion=\"\n# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n# time-stamp-time-zone: \"UTC\"\n# time-stamp-end: \"; # UTC\"\n# End:\n"
        },
        {
          "name": "lz4",
          "type": "tree",
          "content": null
        },
        {
          "name": "m4",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "padding.c",
          "type": "blob",
          "size": 24.767578125,
          "content": "/*  padding.c -- depad subcommand.\n\n    Copyright (C) 2011, 2012 Broad Institute.\n    Copyright (C) 2014-2016, 2019-2020 Genome Research Ltd.\n    Portions copyright (C) 2012, 2013 Peter Cock, The James Hutton Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <string.h>\n#include <assert.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <htslib/kstring.h>\n#include <htslib/sam.h>\n#include <htslib/faidx.h>\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n\n#define bam_reg2bin(b,e) hts_reg2bin((b),(e), 14, 5)\n\nstatic int replace_cigar(bam1_t *b, uint32_t n, uint32_t *cigar)\n{\n    int diff = 0;\n    if (n != b->core.n_cigar) {\n        int o = b->core.l_qname + b->core.n_cigar * 4;\n        if (n > b->core.n_cigar) {\n            diff = (n - b->core.n_cigar) * 4;\n            if ((INT_MAX - b->l_data)/4 < (n - b->core.n_cigar)) {\n                fprintf(stderr, \"[depad] ERROR: BAM record too big\\n\");\n                return -1;\n            }\n            if (b->l_data + diff > b->m_data) {\n                b->m_data = b->l_data + diff;\n                kroundup32(b->m_data);\n                uint8_t *tmp = (uint8_t*)realloc(b->data, b->m_data);\n                if (!tmp) {\n                    fprintf(stderr, \"[depad] ERROR: Memory allocation failure.\\n\");\n                    return -1;\n                }\n                b->data = tmp;\n            }\n        } else {\n            diff = -(int)((b->core.n_cigar - n) * 4);\n        }\n        memmove(b->data + b->core.l_qname + n * 4, b->data + o, b->l_data - o);\n        b->core.n_cigar = n;\n    }\n\n    memcpy(b->data + b->core.l_qname, cigar, n * 4);\n    b->l_data += diff;\n\n    return 0;\n}\n\n#define write_cigar(_c, _n, _m, _v) do { \\\n        if (_n == _m) { \\\n            _m = _m? _m<<1 : 4; \\\n            _c = (uint32_t*)realloc(_c, _m * 4); \\\n            if (!(_c)) { \\\n                fprintf(stderr, \"[depad] ERROR: Memory allocation failure.\\n\"); \\\n                return -1; \\\n            } \\\n        } \\\n        _c[_n++] = (_v); \\\n    } while (0)\n\nstatic int unpad_seq(bam1_t *b, kstring_t *s)\n{\n    // Returns 0 on success, -1 on an error\n    int k, j, i;\n    int length;\n    int cigar_n_warning = 0; /* Make this a global and limit to one CIGAR N warning? */\n    uint32_t *cigar = bam_get_cigar(b);\n    uint8_t *seq = bam_get_seq(b);\n\n    // b->core.l_qseq gives length of the SEQ entry (including soft clips, S)\n    // We need the padded length after alignment from the CIGAR (excluding\n    // soft clips S, but including pads from CIGAR D operations)\n    length = bam_cigar2rlen(b->core.n_cigar, cigar);\n    ks_resize(s, length);\n    for (k = 0, s->l = 0, j = 0; k < b->core.n_cigar; ++k) {\n        int op, ol;\n        op = bam_cigar_op(cigar[k]);\n        ol = bam_cigar_oplen(cigar[k]);\n        if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {\n            for (i = 0; i < ol; ++i, ++j) s->s[s->l++] = bam_seqi(seq, j);\n        } else if (op == BAM_CSOFT_CLIP) {\n            j += ol;\n        } else if (op == BAM_CHARD_CLIP) {\n            /* do nothing */\n        } else if (op == BAM_CDEL) {\n            for (i = 0; i < ol; ++i) s->s[s->l++] = 0;\n        } else if (op == BAM_CREF_SKIP) {\n            /* Treat CIGAR N as D (not ideal, but better than ignoring it) */\n            for (i = 0; i < ol; ++i) s->s[s->l++] = 0;\n            if (0 == cigar_n_warning) {\n                cigar_n_warning = -1;\n                fprintf(stderr, \"[depad] WARNING: CIGAR op N treated as op D in read %s\\n\", bam_get_qname(b));\n            }\n        } else {\n            fprintf(stderr, \"[depad] ERROR: Didn't expect CIGAR op %c in read %s\\n\", BAM_CIGAR_STR[op], bam_get_qname(b));\n            return -1;\n        }\n    }\n    return length != s->l;\n}\n\nint load_unpadded_ref(faidx_t *fai, const char *ref_name, hts_pos_t ref_len, kstring_t *seq)\n{\n    char base;\n    char *fai_ref = 0;\n    hts_pos_t fai_ref_len = 0, k;\n\n    fai_ref = fai_fetch64(fai, ref_name, &fai_ref_len);\n    if (fai_ref_len != ref_len) {\n        fprintf(stderr, \"[depad] ERROR: FASTA sequence %s length %\"PRIhts_pos\", expected %\"PRIhts_pos\"\\n\", ref_name, fai_ref_len, ref_len);\n        free(fai_ref);\n        return -1;\n    }\n    ks_resize(seq, ref_len);\n    seq->l = 0;\n    for (k = 0; k < ref_len; ++k) {\n        base = fai_ref[k];\n        if (base == '-' || base == '*') {\n            // Map gaps to null to match unpad_seq function\n            seq->s[seq->l++] = 0;\n        } else {\n            int i = seq_nt16_table[(int)base];\n            if (i == 0 || i==16) { // Equals maps to 0, anything unexpected to 16\n                fprintf(stderr, \"[depad] ERROR: Invalid character %c (ASCII %i) in FASTA sequence %s\\n\", base, (int)base, ref_name);\n                free(fai_ref);\n                return -1;\n            }\n            seq->s[seq->l++] = i;\n        }\n    }\n    assert(ref_len == seq->l);\n    free(fai_ref);\n    return 0;\n}\n\nhts_pos_t get_unpadded_len(faidx_t *fai, const char *ref_name, hts_pos_t padded_len)\n{\n    char base;\n    char *fai_ref = 0;\n    hts_pos_t fai_ref_len = 0, k;\n    hts_pos_t bases=0, gaps=0;\n\n    fai_ref = fai_fetch64(fai, ref_name, &fai_ref_len);\n    if (fai_ref_len != padded_len) {\n        fprintf(stderr, \"[depad] ERROR: FASTA sequence '%s' length %\"PRIhts_pos\", expected %\"PRIhts_pos\"\\n\", ref_name, fai_ref_len, padded_len);\n        free(fai_ref);\n        return -1;\n    }\n    for (k = 0; k < padded_len; ++k) {\n        //fprintf(stderr, \"[depad] checking base %i of %i or %i\\n\", k+1, ref_len, strlen(fai_ref));\n        base = fai_ref[k];\n        if (base == '-' || base == '*') {\n            gaps += 1;\n        } else {\n            int i = seq_nt16_table[(int)base];\n            if (i == 0 || i==16) { // Equals maps to 0, anything unexpected to 16\n                fprintf(stderr, \"[depad] ERROR: Invalid character %c (ASCII %i) in FASTA sequence '%s'\\n\", base, (int)base, ref_name);\n                free(fai_ref);\n                return -1;\n            }\n            bases += 1;\n        }\n    }\n    free(fai_ref);\n    assert (padded_len == bases + gaps);\n    return bases;\n}\n\nstatic inline int * update_posmap(int *posmap, kstring_t ref)\n{\n    int i, k;\n    posmap = realloc(posmap, ref.m * sizeof(int));\n    for (i = k = 0; i < ref.l; ++i) {\n        posmap[i] = k;\n        if (ref.s[i]) ++k;\n    }\n    return posmap;\n}\n\nint bam_pad2unpad(samFile *in, samFile *out,  sam_hdr_t *h, faidx_t *fai)\n{\n    bam1_t *b = 0;\n    kstring_t r, q;\n    int r_tid = -1;\n    uint32_t *cigar2 = 0;\n    int ret = 0, *posmap = 0;\n    uint32_t n2 = 0, m2 = 0;\n\n    b = bam_init1();\n    if (!b) {\n        fprintf(stderr, \"[depad] Couldn't allocate bam struct\\n\");\n        return -1;\n    }\n    r.l = r.m = q.l = q.m = 0; r.s = q.s = 0;\n    int read_ret;\n    while ((read_ret = sam_read1(in, h, b)) >= 0) { // read one alignment from `in'\n        // Cannot depad unmapped CRAM data\n        if (b->core.flag & BAM_FUNMAP)\n            goto next_seq;\n\n        uint32_t *cigar = bam_get_cigar(b);\n        n2 = 0;\n        if (b->core.pos == 0 && b->core.tid >= 0 && strcmp(bam_get_qname(b), sam_hdr_tid2name(h, b->core.tid)) == 0) {\n            // fprintf(stderr, \"[depad] Found embedded reference '%s'\\n\", bam_get_qname(b));\n            r_tid = b->core.tid;\n            if (0!=unpad_seq(b, &r)) {\n                fprintf(stderr, \"[depad] ERROR: Problem parsing SEQ and/or CIGAR in reference %s\\n\", bam_get_qname(b));\n                return -1;\n            };\n            if (sam_hdr_tid2len(h, r_tid) != r.l) {\n                fprintf(stderr, \"[depad] ERROR: (Padded) length of '%s' is %\"PRId64\" in BAM header, but %zu in embedded reference\\n\", bam_get_qname(b), (int64_t) sam_hdr_tid2len(h, r_tid), r.l);\n                return -1;\n            }\n            if (fai) {\n                // Check the embedded reference matches the FASTA file\n                if (load_unpadded_ref(fai, sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), &q)) {\n                    fprintf(stderr, \"[depad] ERROR: Failed to load embedded reference '%s' from FASTA\\n\", sam_hdr_tid2name(h, b->core.tid));\n                    return -1;\n                }\n                assert(r.l == q.l);\n                int i;\n                for (i = 0; i < r.l; ++i) {\n                    if (r.s[i] != q.s[i]) {\n                        // Show gaps as ASCII 45\n                        fprintf(stderr, \"[depad] ERROR: Embedded sequence and reference FASTA don't match for %s base %i, '%c' vs '%c'\\n\",\n                            sam_hdr_tid2name(h, b->core.tid), i+1,\n                            r.s[i] ? seq_nt16_str[(int)r.s[i]] : 45,\n                            q.s[i] ? seq_nt16_str[(int)q.s[i]] : 45);\n                        return -1;\n                    }\n                }\n            }\n            write_cigar(cigar2, n2, m2, bam_cigar_gen(b->core.l_qseq, BAM_CMATCH));\n            if (replace_cigar(b, n2, cigar2) < 0)\n                return -1;\n            posmap = update_posmap(posmap, r);\n        } else if (b->core.n_cigar > 0) {\n            int i, k, op;\n            if (b->core.tid < 0) {\n                fprintf(stderr, \"[depad] ERROR: Read '%s' has CIGAR but no RNAME\\n\", bam_get_qname(b));\n                return -1;\n            } else if (b->core.tid == r_tid) {\n                ; // good case, reference available\n                //fprintf(stderr, \"[depad] Have ref '%s' for read '%s'\\n\", h->target_name[b->core.tid], bam_get_qname(b));\n            } else if (fai) {\n                if (load_unpadded_ref(fai, sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), &r)) {\n                    fprintf(stderr, \"[depad] ERROR: Failed to load '%s' from reference FASTA\\n\", sam_hdr_tid2name(h, b->core.tid));\n                    return -1;\n                }\n                posmap = update_posmap(posmap, r);\n                r_tid = b->core.tid;\n                // fprintf(stderr, \"[depad] Loaded %s from FASTA file\\n\", h->target_name[b->core.tid]);\n            } else {\n                fprintf(stderr, \"[depad] ERROR: Missing %s embedded reference sequence (and no FASTA file)\\n\", sam_hdr_tid2name(h, b->core.tid));\n                return -1;\n            }\n            if (0!=unpad_seq(b, &q)) {\n                fprintf(stderr, \"[depad] ERROR: Problem parsing SEQ and/or CIGAR in read %s\\n\", bam_get_qname(b));\n                return -1;\n            };\n            if (bam_cigar_op(cigar[0]) == BAM_CSOFT_CLIP) {\n                write_cigar(cigar2, n2, m2, cigar[0]);\n            } else if (bam_cigar_op(cigar[0]) == BAM_CHARD_CLIP) {\n                write_cigar(cigar2, n2, m2, cigar[0]);\n                if (b->core.n_cigar > 2 && bam_cigar_op(cigar[1]) == BAM_CSOFT_CLIP) {\n                    write_cigar(cigar2, n2, m2, cigar[1]);\n                }\n            }\n            /* Determine CIGAR operator for each base in the aligned read */\n            for (i = 0, k = b->core.pos; i < q.l; ++i, ++k)\n                q.s[i] = q.s[i]? (r.s[k]? BAM_CMATCH : BAM_CINS) : (r.s[k]? BAM_CDEL : BAM_CPAD);\n            /* Include any pads if starts with an insert */\n            if (q.s[0] == BAM_CINS) {\n                for (k = 0; k+1 < b->core.pos && !r.s[b->core.pos - k - 1]; ++k);\n                if (k) write_cigar(cigar2, n2, m2, bam_cigar_gen(k, BAM_CPAD));\n                k = 0;\n            } else if (q.s[0] == BAM_CPAD) {\n                // Join 'k' CPAD to our first cigar op CPAD too.\n                for (k = 0; k+1 < b->core.pos && !r.s[b->core.pos - k - 1]; ++k);\n            } else {\n                k = 0;\n            }\n            /* Count consecutive CIGAR operators to turn into a CIGAR string */\n            for (i = 1, k++, op = q.s[0]; i < q.l; ++i) {\n                if (op != q.s[i]) {\n                    write_cigar(cigar2, n2, m2, bam_cigar_gen(k, op));\n                    op = q.s[i]; k = 1;\n                } else ++k;\n            }\n            write_cigar(cigar2, n2, m2, bam_cigar_gen(k, op));\n            if (bam_cigar_op(cigar[b->core.n_cigar-1]) == BAM_CSOFT_CLIP) {\n                write_cigar(cigar2, n2, m2, cigar[b->core.n_cigar-1]);\n            } else if (bam_cigar_op(cigar[b->core.n_cigar-1]) == BAM_CHARD_CLIP) {\n                if (b->core.n_cigar > 2 && bam_cigar_op(cigar[b->core.n_cigar-2]) == BAM_CSOFT_CLIP) {\n                    write_cigar(cigar2, n2, m2, cigar[b->core.n_cigar-2]);\n                }\n                write_cigar(cigar2, n2, m2, cigar[b->core.n_cigar-1]);\n            }\n            /* Remove redundant P operators between M/X/=/D operators, e.g. 5M2P10M -> 15M */\n            int pre_op, post_op;\n            for (i = 2; i < n2; ++i)\n                if (bam_cigar_op(cigar2[i-1]) == BAM_CPAD) {\n                    pre_op = bam_cigar_op(cigar2[i-2]);\n                    post_op = bam_cigar_op(cigar2[i]);\n                    /* Note don't need to check for X/= as code above will use M only */\n                    if ((pre_op == BAM_CMATCH || pre_op == BAM_CDEL) && (post_op == BAM_CMATCH || post_op == BAM_CDEL)) {\n                        /* This is a redundant P operator */\n                        cigar2[i-1] = 0; // i.e. 0M\n                        /* If had same operator either side, combine them in post_op */\n                        if (pre_op == post_op) {\n                            /* If CIGAR M, could treat as simple integers since BAM_CMATCH is zero*/\n                            cigar2[i] = bam_cigar_gen(bam_cigar_oplen(cigar2[i-2]) + bam_cigar_oplen(cigar2[i]), post_op);\n                            cigar2[i-2] = 0; // i.e. 0M\n                        }\n                    }\n                }\n            /* Remove the zero'd operators (0M) */\n            for (i = k = 0; i < n2; ++i)\n                if (cigar2[i]) cigar2[k++] = cigar2[i];\n            n2 = k;\n            if (replace_cigar(b, n2, cigar2) < 0)\n                return -1;\n        }\n        /* Even unmapped reads can have a POS value, e.g. if their mate was mapped */\n        if (b->core.pos != -1) b->core.pos = posmap[b->core.pos];\n        if (b->core.mtid < 0 || b->core.mpos < 0) {\n            /* Nice case, no mate to worry about*/\n            // fprintf(stderr, \"[depad] Read '%s' mate not mapped\\n\", bam_get_qname(b));\n            /* TODO - Warning if FLAG says mate should be mapped? */\n            /* Clean up funny input where mate position is given but mate reference is missing: */\n            b->core.mtid = -1;\n            b->core.mpos = -1;\n        } else if (b->core.mtid == b->core.tid) {\n            /* Nice case, same reference */\n            // fprintf(stderr, \"[depad] Read '%s' mate mapped to same ref\\n\", bam_get_qname(b));\n            b->core.mpos = posmap[b->core.mpos];\n        } else {\n            /* Nasty case, Must load alternative posmap */\n            // fprintf(stderr, \"[depad] Loading reference '%s' temporarily\\n\", h->target_name[b->core.mtid]);\n            if (!fai) {\n                fprintf(stderr, \"[depad] ERROR: Needed reference %s sequence for mate (and no FASTA file)\\n\", sam_hdr_tid2name(h, b->core.mtid));\n                return -1;\n            }\n            /* Temporarily load the other reference sequence */\n            if (load_unpadded_ref(fai, sam_hdr_tid2name(h, b->core.mtid), sam_hdr_tid2len(h, b->core.mtid), &r)) {\n                fprintf(stderr, \"[depad] ERROR: Failed to load '%s' from reference FASTA\\n\", sam_hdr_tid2name(h, b->core.mtid));\n                return -1;\n            }\n            posmap = update_posmap(posmap, r);\n            b->core.mpos = posmap[b->core.mpos];\n            /* Restore the reference and posmap*/\n            if (load_unpadded_ref(fai, sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), &r)) {\n                fprintf(stderr, \"[depad] ERROR: Failed to load '%s' from reference FASTA\\n\", sam_hdr_tid2name(h, b->core.tid));\n                return -1;\n            }\n            posmap = update_posmap(posmap, r);\n        }\n        /* Most reads will have been moved so safest to always recalculate the BIN value */\n        b->core.bin = bam_reg2bin(b->core.pos, bam_endpos(b));\n\n    next_seq:\n        if (sam_write1(out, h, b) < 0) {\n            print_error_errno(\"depad\", \"error writing to output\");\n            return -1;\n        }\n    }\n    if (read_ret < -1) {\n        fprintf(stderr, \"[depad] truncated file.\\n\");\n        ret = 1;\n    }\n    free(r.s); free(q.s); free(posmap);\n    free(cigar2);\n    bam_destroy1(b);\n    return ret;\n}\n\nsam_hdr_t * fix_header(sam_hdr_t *old, faidx_t *fai)\n{\n    int i = 0, ret = 0;\n    hts_pos_t unpadded_len = 0;\n    sam_hdr_t *header = sam_hdr_dup(old);\n    if (!header)\n        return NULL;\n\n    int nref = sam_hdr_nref(old);\n    char len_buf[64];\n\n    for (i = 0; i < nref; ++i) {\n        unpadded_len = get_unpadded_len(fai, sam_hdr_tid2name(old, i), sam_hdr_tid2len(old, i));\n        if (unpadded_len < 0) {\n            fprintf(stderr, \"[depad] ERROR getting unpadded length of '%s', padded length %\"PRIhts_pos\"\\n\", sam_hdr_tid2name(old, i), (hts_pos_t) sam_hdr_tid2len(old, i));\n        } else if (unpadded_len > sam_hdr_tid2len(old, i)) {\n            fprintf(stderr, \"[depad] New unpadded length of '%s' is larger than the padded length (%\"PRIhts_pos\" > %\"PRIhts_pos\")\\n\",\n                    sam_hdr_tid2name(old, i), unpadded_len,\n                    (hts_pos_t) sam_hdr_tid2len(old, i));\n            ret = 1;\n        } else {\n            sprintf(len_buf, \"%\"PRIhts_pos\"\", unpadded_len);\n            if ((ret |= sam_hdr_update_line(header, \"SQ\", \"SN\", sam_hdr_tid2name(header, i), \"LN\", len_buf, NULL)))\n                fprintf(stderr, \"[depad] Error updating length of '%s' from %\"PRIhts_pos\" to %\"PRIhts_pos\"\\n\",\n                        sam_hdr_tid2name(header, i),\n                        (hts_pos_t) sam_hdr_tid2len(header, i),\n                        unpadded_len);\n            //fprintf(stderr, \"[depad] Recalculating '%s' length %i -> %i\\n\", old->target_name[i], old->target_len[i], header->target_len[i]);\n        }\n    }\n\n    if (ret) {\n        sam_hdr_destroy(header);\n        return NULL;\n    }\n\n    return header;\n}\n\nstatic int usage(int is_long_help);\n\nint main_pad2unpad(int argc, char *argv[])\n{\n    samFile *in = 0, *out = 0;\n    sam_hdr_t *h = 0, *h_fix = 0;\n    faidx_t *fai = 0;\n    int c, compress_level = -1, is_long_help = 0, no_pg = 0;\n    char in_mode[5], out_mode[6], *fn_out = 0, *fn_fai = 0, *fn_out_idx = NULL;\n    int ret=0;\n    char *arg_list = NULL;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 0, 0, 'T', '-'),\n        {\"no-PG\", no_argument, NULL, 1},\n        { NULL, 0, NULL, 0 }\n    };\n\n    /* parse command-line options */\n    strcpy(in_mode, \"r\"); strcpy(out_mode, \"w\");\n    while ((c = getopt_long(argc, argv, \"SCso:u1T:?\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'S': break;\n        case 'C': hts_parse_format(&ga.out, \"cram\"); break;\n        case 's': assert(compress_level == -1); hts_parse_format(&ga.out, \"sam\"); break;\n        case 'o': fn_out = strdup(optarg); break;\n        case 'u':\n            compress_level = 0;\n            if (ga.out.format == unknown_format)\n                hts_parse_format(&ga.out, \"bam\");\n            break;\n        case '1':\n            compress_level = 1;\n            if (ga.out.format == unknown_format)\n                hts_parse_format(&ga.out, \"bam\");\n            break;\n        case 1: no_pg = 1; break;\n        case '?': is_long_help = 1; break;\n        default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            fprintf(stderr, \"[bam_fillmd] unrecognized option '-%c'\\n\\n\", c);\n            return usage(is_long_help);\n        }\n    }\n    if (argc == optind) return usage(is_long_help);\n\n    strcat(out_mode, \"h\");\n    if (compress_level >= 0) {\n        char tmp[2];\n        tmp[0] = compress_level + '0'; tmp[1] = '\\0';\n        strcat(out_mode, tmp);\n    }\n\n    // Load FASTA reference (also needed for SAM -> BAM if missing header)\n    if (ga.reference) {\n        fn_fai = fai_path(ga.reference);\n        fai = fai_load3(ga.reference, fn_fai, NULL, FAI_CREATE);\n    }\n    // open file handlers\n    if ((in = sam_open_format(argv[optind], in_mode, &ga.in)) == 0) {\n        print_error_errno(\"depad\", \"failed to open \\\"%s\\\" for reading\", argv[optind]);\n        ret = 1;\n        goto depad_end;\n    }\n    if (fn_fai && hts_set_fai_filename(in, fn_fai) != 0) {\n        fprintf(stderr, \"[depad] failed to load reference file \\\"%s\\\".\\n\", fn_fai);\n        ret = 1;\n        goto depad_end;\n    }\n    if ((h = sam_hdr_read(in)) == 0) {\n        fprintf(stderr, \"[depad] failed to read the header from \\\"%s\\\".\\n\", argv[optind]);\n        ret = 1;\n        goto depad_end;\n    }\n    if (fai) {\n        if (!(h_fix = fix_header(h, fai))){\n            fprintf(stderr, \"[depad] failed to fix the header from\\n\");\n            ret = 1;\n            goto depad_end;\n        }\n    } else {\n        fprintf(stderr, \"[depad] Warning - reference lengths will not be corrected without FASTA reference\\n\");\n        h_fix = h;\n    }\n    char wmode[2];\n    strcat(out_mode, sam_open_mode(wmode, fn_out, NULL)==0 ? wmode : \"b\");\n    if ((out = sam_open_format(fn_out? fn_out : \"-\", out_mode, &ga.out)) == 0) {\n        print_error_errno(\"depad\", \"failed to open \\\"%s\\\" for writing\", fn_out? fn_out : \"standard output\");\n        ret = 1;\n        goto depad_end;\n    }\n\n    // Reference-based CRAM won't work unless we also create a new reference.\n    // We could embed this, but for now we take the easy option.\n    if (ga.out.format == cram)\n        hts_set_opt(out, CRAM_OPT_NO_REF, 1);\n\n    if (!no_pg) {\n        if(!(arg_list = stringify_argv(argc+1, argv-1))) {\n            fprintf(stderr, \"[depad] failed to create arg_list\\n\");\n            ret = 1;\n            goto depad_end;\n            }\n\n        if (sam_hdr_add_pg(h_fix, \"samtools\",\n                           \"VN\", samtools_version(),\n                           arg_list ? \"CL\": NULL,\n                           arg_list ? arg_list : NULL,\n                           NULL)) {\n            fprintf(stderr, \"[depad] failed to add PG line to header\\n\");\n            ret = 1;\n            goto depad_end;\n        }\n    }\n\n    if (sam_hdr_write(out, h_fix) != 0) {\n        fprintf(stderr, \"[depad] failed to write header.\\n\");\n        ret = 1;\n        goto depad_end;\n    }\n    if (ga.write_index) {\n        if (!(fn_out_idx = auto_index(out, fn_out, h_fix))) {\n            ret = 1;\n            goto depad_end;\n        }\n    }\n\n    // Do the depad\n    if (bam_pad2unpad(in, out, h, fai) != 0) ret = 1;\n\n    if (ga.write_index) {\n        if (sam_idx_save(out) < 0) {\n            print_error_errno(\"depad\", \"writing index failed\");\n            ret = 1;\n        }\n    }\n\ndepad_end:\n    // close files, free and return\n    free(arg_list);\n    if (fai) fai_destroy(fai);\n    if (h) sam_hdr_destroy(h);\n    if (h_fix && h_fix != h) sam_hdr_destroy(h_fix);\n    if (in) sam_close(in);\n    if (out && sam_close(out) < 0) {\n        fprintf(stderr, \"[depad] error on closing output file.\\n\");\n        ret = 1;\n    }\n    free(fn_fai); free(fn_out);\n    if (fn_out_idx)\n        free(fn_out_idx);\n    sam_global_args_free(&ga);\n    return ret;\n}\n\nstatic int usage(int is_long_help)\n{\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"Usage:   samtools depad <in.bam>\\n\\n\");\n    fprintf(stderr, \"Options:\\n\");\n    fprintf(stderr, \"  -s           Output is SAM (default is BAM)\\n\");\n    fprintf(stderr, \"  -S           Input is SAM (default is BAM)\\n\");\n    fprintf(stderr, \"  -u           Uncompressed BAM output (can't use with -s)\\n\");\n    fprintf(stderr, \"  -1           Fast compression BAM output (can't use with -s)\\n\");\n    fprintf(stderr, \"  -T, --reference FILE\\n\");\n    fprintf(stderr, \"               Padded reference sequence file [null]\\n\");\n    fprintf(stderr, \"  -o FILE      Output file name [stdout]\\n\");\n    fprintf(stderr, \"  --no-PG      do not add a PG line\\n\");\n    fprintf(stderr, \"  -?           Longer help\\n\");\n    sam_global_opt_help(stderr, \"-...--..\");\n\n    if (is_long_help)\n        fprintf(stderr,\n\"Notes:\\n\"\n\"\\n\"\n\"1. Requires embedded reference sequences (before the reads for that reference),\\n\"\n\"   or ideally a FASTA file of the padded reference sequences (via a -T option).\\n\"\n\"\\n\"\n\"2. Input padded alignment reads' CIGAR strings must not use P or I operators.\\n\"\n\"\\n\");\n    return 1;\n}\n"
        },
        {
          "name": "phase.c",
          "type": "blob",
          "size": 29.3544921875,
          "content": "/*  phase.c -- phase subcommand.\n\n    Copyright (C) 2011 Broad Institute.\n    Copyright (C) 2013-2016, 2019 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <math.h>\n#include <zlib.h>\n#include \"htslib/hts.h\"\n#include \"htslib/sam.h\"\n#include \"htslib/kstring.h\"\n#include \"sam_opts.h\"\n#include \"samtools.h\"\n#include \"htslib/hts_os.h\"\n\n#include \"htslib/kseq.h\"\nKSTREAM_INIT(gzFile, gzread, 16384)\n\n#define MAX_VARS 256\n#define FLIP_PENALTY 2\n#define FLIP_THRES 4\n#define MASK_THRES 3\n\n#define FLAG_FIX_CHIMERA 0x1\n#define FLAG_LIST_EXCL   0x4\n#define FLAG_DROP_AMBI   0x8\n\ntypedef struct {\n    // configurations, initialized in the main function\n    int flag, k, min_baseQ, min_varLOD, max_depth, no_pg;\n    // other global variables\n    int vpos_shift;\n    samFile* fp;\n    sam_hdr_t* fp_hdr;\n    char *pre, *arg_list;\n    char *out_name[3];\n    samFile* out[3];\n    sam_hdr_t* out_hdr[3];\n    // alignment queue\n    int n, m;\n    bam1_t **b;\n} phaseg_t;\n\ntypedef struct {\n    int8_t seq[MAX_VARS]; // TODO: change to dynamic memory allocation!\n    int vpos, beg, end;\n    uint32_t vlen:16, single:1, flip:1, phase:1, phased:1, ambig:1;\n    uint32_t in:16, out:16; // in-phase and out-phase\n} frag_t, *frag_p;\n\n#define rseq_lt(a,b) ((a)->vpos < (b)->vpos)\n\n#include \"htslib/khash.h\"\nKHASH_SET_INIT_INT64(set64)\nKHASH_MAP_INIT_INT64(64, frag_t)\n\ntypedef khash_t(64) nseq_t;\n\n#include \"htslib/ksort.h\"\nKSORT_INIT(rseq, frag_p, rseq_lt)\n\nstatic inline uint64_t X31_hash_string(const char *s)\n{\n    uint64_t h = *s;\n    if (h) for (++s ; *s; ++s) h = (h << 5) - h + *s;\n    return h;\n}\n\nstatic void count1(int l, const uint8_t *seq, int *cnt)\n{\n    int i, j, n_ambi;\n    uint32_t z, x;\n    if (seq[l-1] == 0) return; // do nothing is the last base is ambiguous\n    for (i = n_ambi = 0; i < l; ++i) // collect ambiguous bases\n        if (seq[i] == 0) ++n_ambi;\n    if (l - n_ambi <= 1) return; // only one SNP\n    for (x = 0; x < 1u<<n_ambi; ++x) { // count\n        for (i = j = 0, z = 0; i < l; ++i) {\n            int c;\n            if (seq[i]) c = seq[i] - 1;\n            else {\n                c = x>>j&1;\n                ++j;\n            }\n            z = z<<1 | c;\n        }\n        ++cnt[z];\n    }\n}\n\nstatic int **count_all(int l, int vpos, nseq_t *hash)\n{\n    khint_t k;\n    int i, j, **cnt = NULL;\n    uint8_t *seq = NULL;\n    size_t cnt_sz = ((size_t)1) << l;\n    if (cnt_sz > SSIZE_MAX / sizeof(int) / vpos) {\n        errno = ENOMEM;\n        goto fail;\n    }\n    seq = calloc(l, 1);\n    if (!seq) goto fail;\n    cnt = calloc(vpos, sizeof(int*));\n    if (!cnt) goto fail;\n    for (i = 0; i < vpos; ++i) {\n        cnt[i] = calloc(cnt_sz, sizeof(int));\n        if (!cnt[i]) goto fail;\n    }\n    for (k = 0; k < kh_end(hash); ++k) {\n        if (kh_exist(hash, k)) {\n            frag_t *f = &kh_val(hash, k);\n            if (f->vpos >= vpos || f->single) continue; // out of region; or singleton\n            if (f->vlen == 1) { // such reads should be flagged as deleted previously if everything is right\n                f->single = 1;\n                continue;\n            }\n            for (j = 1; j < f->vlen; ++j) {\n                for (i = 0; i < l; ++i)\n                    seq[i] = j < l - 1 - i? 0 : f->seq[j - (l - 1 - i)];\n                count1(l, seq, cnt[f->vpos + j]);\n            }\n        }\n    }\n    free(seq);\n    return cnt;\n fail:\n    free(seq);\n    if (cnt) {\n        for (i = 0; i < vpos; i++)\n            free(cnt[i]);\n        free(cnt);\n    }\n    print_error_errno(\"phase\", \"Couldn't allocate memory for counts\");\n    return NULL;\n}\n\n// phasing\nstatic int8_t *dynaprog(int l, int vpos, int **w)\n{\n    int *f[2], *curr, *prev, max, i;\n    int8_t **b, *h = 0;\n    uint32_t x, z = 1u<<(l-1), mask = (1u<<l) - 1;\n    f[0] = calloc(z, sizeof(int));\n    f[1] = calloc(z, sizeof(int));\n    b = calloc(vpos, sizeof(int8_t*));\n    prev = f[0]; curr = f[1];\n    // fill the backtrack matrix\n    for (i = 0; i < vpos; ++i) {\n        int *wi = w[i], *tmp;\n        int8_t *bi;\n        bi = b[i] = calloc(z, 1);\n        /* In the following, x is the current state, which is the\n         * lexicographically smaller local haplotype. xc is the complement of\n         * x, or the larger local haplotype; y0 and y1 are the two predecessors\n         * of x. */\n        for (x = 0; x < z; ++x) { // x0 is the smaller\n            uint32_t y0, y1, xc;\n            int c0, c1;\n            xc = ~x&mask; y0 = x>>1; y1 = xc>>1;\n            c0 = prev[y0] + wi[x] + wi[xc];\n            c1 = prev[y1] + wi[x] + wi[xc];\n            if (c0 > c1) bi[x] = 0, curr[x] = c0;\n            else bi[x] = 1, curr[x] = c1;\n        }\n        tmp = prev; prev = curr; curr = tmp; // swap\n    }\n    { // backtrack\n        uint32_t max_x = 0;\n        int which = 0;\n        h = calloc(vpos, 1);\n        for (x = 0, max = 0, max_x = 0; x < z; ++x)\n            if (prev[x] > max) max = prev[x], max_x = x;\n        for (i = vpos - 1, x = max_x; i >= 0; --i) {\n            h[i] = which? (~x&1) : (x&1);\n            which = b[i][x]? !which : which;\n            x = b[i][x]? (~x&mask)>>1 : x>>1;\n        }\n    }\n    // free\n    for (i = 0; i < vpos; ++i) free(b[i]);\n    free(f[0]); free(f[1]); free(b);\n    return h;\n}\n\n// phase each fragment\nstatic uint64_t *fragphase(int vpos, const int8_t *path, nseq_t *hash, int flip)\n{\n    khint_t k;\n    uint64_t *pcnt;\n    uint32_t *left, *rght, max;\n    left = rght = 0; max = 0;\n    pcnt = calloc(vpos, 8);\n    for (k = 0; k < kh_end(hash); ++k) {\n        if (kh_exist(hash, k)) {\n            int i, c[2];\n            frag_t *f = &kh_val(hash, k);\n            if (f->vpos >= vpos) continue;\n            // get the phase\n            c[0] = c[1] = 0;\n            for (i = 0; i < f->vlen; ++i) {\n                if (f->seq[i] == 0) continue;\n                ++c[f->seq[i] == path[f->vpos + i] + 1? 0 : 1];\n            }\n            f->phase = c[0] > c[1]? 0 : 1;\n            f->in = c[f->phase]; f->out = c[1 - f->phase];\n            f->phased = f->in == f->out? 0 : 1;\n            f->ambig = (f->in && f->out && f->out < 3 && f->in <= f->out + 1)? 1 : 0;\n            // fix chimera\n            f->flip = 0;\n            if (flip && c[0] >= 3 && c[1] >= 3) {\n                int sum[2], m, mi, md;\n                if (f->vlen > max) { // enlarge the array\n                    max = f->vlen;\n                    kroundup32(max);\n                    left = realloc(left, max * 4);\n                    rght = realloc(rght, max * 4);\n                }\n                for (i = 0, sum[0] = sum[1] = 0; i < f->vlen; ++i) { // get left counts\n                    if (f->seq[i]) {\n                        int c = f->phase? 2 - f->seq[i] : f->seq[i] - 1;\n                        ++sum[c == path[f->vpos + i]? 0 : 1];\n                    }\n                    left[i] = sum[1]<<16 | sum[0];\n                }\n                for (i = f->vlen - 1, sum[0] = sum[1] = 0; i >= 0; --i) { // get right counts\n                    if (f->seq[i]) {\n                        int c = f->phase? 2 - f->seq[i] : f->seq[i] - 1;\n                        ++sum[c == path[f->vpos + i]? 0 : 1];\n                    }\n                    rght[i] = sum[1]<<16 | sum[0];\n                }\n                // find the best flip point\n                for (i = m = 0, mi = -1, md = -1; i < f->vlen - 1; ++i) {\n                    int a[2];\n                    a[0] = (left[i]&0xffff) + (rght[i+1]>>16&0xffff) - (rght[i+1]&0xffff) * FLIP_PENALTY;\n                    a[1] = (left[i]>>16&0xffff) + (rght[i+1]&0xffff) - (rght[i+1]>>16&0xffff) * FLIP_PENALTY;\n                    if (a[0] > a[1]) {\n                        if (a[0] > m) m = a[0], md = 0, mi = i;\n                    } else {\n                        if (a[1] > m) m = a[1], md = 1, mi = i;\n                    }\n                }\n                if (m - c[0] >= FLIP_THRES && m - c[1] >= FLIP_THRES) { // then flip\n                    f->flip = 1;\n                    if (md == 0) { // flip the tail\n                        for (i = mi + 1; i < f->vlen; ++i)\n                            if (f->seq[i] == 1) f->seq[i] = 2;\n                            else if (f->seq[i] == 2) f->seq[i] = 1;\n                    } else { // flip the head\n                        for (i = 0; i <= mi; ++i)\n                            if (f->seq[i] == 1) f->seq[i] = 2;\n                            else if (f->seq[i] == 2) f->seq[i] = 1;\n                    }\n                }\n            }\n            // update pcnt[]\n            if (!f->single) {\n                for (i = 0; i < f->vlen; ++i) {\n                    int c;\n                    if (f->seq[i] == 0) continue;\n                    c = f->phase? 2 - f->seq[i] : f->seq[i] - 1;\n                    if (c == path[f->vpos + i]) {\n                        if (f->phase == 0) ++pcnt[f->vpos + i];\n                        else pcnt[f->vpos + i] += 1ull<<32;\n                    } else {\n                        if (f->phase == 0) pcnt[f->vpos + i] += 1<<16;\n                        else pcnt[f->vpos + i] += 1ull<<48;\n                    }\n                }\n            }\n        }\n    }\n    free(left); free(rght);\n    return pcnt;\n}\n\nstatic uint64_t *genmask(int vpos, const uint64_t *pcnt, int *_n)\n{\n    int i, max = 0, max_i = -1, m = 0, n = 0, beg = 0, score = 0;\n    uint64_t *list = 0;\n    for (i = 0; i < vpos; ++i) {\n        uint64_t x = pcnt[i];\n        int c[4], pre = score, s;\n        c[0] = x&0xffff; c[1] = x>>16&0xffff; c[2] = x>>32&0xffff; c[3] = x>>48&0xffff;\n        s = (c[1] + c[3] == 0)? -(c[0] + c[2]) : (c[1] + c[3] - 1);\n        if (c[3] > c[2]) s += c[3] - c[2];\n        if (c[1] > c[0]) s += c[1] - c[0];\n        score += s;\n        if (score < 0) score = 0;\n        if (pre == 0 && score > 0) beg = i; // change from zero to non-zero\n        if ((i == vpos - 1 || score == 0) && max >= MASK_THRES) {\n            if (n == m) {\n                m = m? m<<1 : 4;\n                list = realloc(list, m * 8);\n            }\n            list[n++] = (uint64_t)beg<<32 | max_i;\n            i = max_i; // reset i to max_i\n            score = 0;\n        } else if (score > max) max = score, max_i = i;\n        if (score == 0) max = 0;\n    }\n    *_n = n;\n    return list;\n}\n\n// trim heading and tailing ambiguous bases; mark deleted and remove sequence\nstatic int clean_seqs(int vpos, nseq_t *hash)\n{\n    khint_t k;\n    int ret = 0;\n    for (k = 0; k < kh_end(hash); ++k) {\n        if (kh_exist(hash, k)) {\n            frag_t *f = &kh_val(hash, k);\n            int beg, end, i;\n            if (f->vpos >= vpos) {\n                ret = 1;\n                continue;\n            }\n            for (i = 0; i < f->vlen; ++i)\n                if (f->seq[i] != 0) break;\n            beg = i;\n            for (i = f->vlen - 1; i >= 0; --i)\n                if (f->seq[i] != 0) break;\n            end = i + 1;\n            if (end - beg <= 0) kh_del(64, hash, k);\n            else {\n                if (beg != 0) memmove(f->seq, f->seq + beg, end - beg);\n                f->vpos += beg; f->vlen = end - beg;\n                f->single = f->vlen == 1? 1 : 0;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic int dump_aln(phaseg_t *g, int min_pos, const nseq_t *hash)\n{\n    int i, is_flip, drop_ambi;\n    drop_ambi = g->flag & FLAG_DROP_AMBI;\n    is_flip = (drand48() < 0.5);\n    for (i = 0; i < g->n; ++i) {\n        int end, which;\n        uint64_t key;\n        khint_t k;\n        bam1_t *b = g->b[i];\n        key = X31_hash_string(bam_get_qname(b));\n        end = bam_endpos(b);\n        if (end > min_pos) break;\n        k = kh_get(64, hash, key);\n        if (k == kh_end(hash)) which = 3;\n        else {\n            frag_t *f = &kh_val(hash, k);\n            if (f->ambig) which = drop_ambi? 2 : 3;\n            else if (f->phased && f->flip) which = 2;\n            else if (f->phased == 0) which = 3;\n            else { // phased and not flipped\n                char c = 'Y';\n                which = f->phase;\n                bam_aux_append(b, \"ZP\", 'A', 1, (uint8_t*)&c);\n            }\n            if (which < 2 && is_flip) which = 1 - which; // increase the randomness\n        }\n        if (which == 3) which = (drand48() < 0.5);\n        if (sam_write1(g->out[which], g->out_hdr[which], b) < 0) {\n            print_error_errno(\"phase\", \"error writing to '%s'\", g->out_name[which]);\n            return -1;\n        }\n        bam_destroy1(b);\n        g->b[i] = 0;\n    }\n    memmove(g->b, g->b + i, (g->n - i) * sizeof(void*));\n    g->n -= i;\n    return 0;\n}\n\nstatic int phase(phaseg_t *g, const char *chr, int vpos, uint64_t *cns, nseq_t *hash)\n{\n    int i, j, n_seqs = kh_size(hash), n_masked = 0, min_pos;\n    khint_t k;\n    frag_t **seqs;\n    int8_t *path, *sitemask;\n    uint64_t *pcnt, *regmask;\n\n    if (vpos == 0) return 0;\n    i = clean_seqs(vpos, hash); // i is true if hash has an element with its vpos >= vpos\n    min_pos = i? cns[vpos]>>32 : 0x7fffffff;\n    if (vpos == 1) {\n        printf(\"PS\\t%s\\t%d\\t%d\\n\", chr, (int)(cns[0]>>32) + 1, (int)(cns[0]>>32) + 1);\n        printf(\"M0\\t%s\\t%d\\t%d\\t%c\\t%c\\t%d\\t0\\t0\\t0\\t0\\n//\\n\", chr, (int)(cns[0]>>32) + 1, (int)(cns[0]>>32) + 1,\n            \"ACGTX\"[cns[0]&3], \"ACGTX\"[cns[0]>>16&3], g->vpos_shift + 1);\n        for (k = 0; k < kh_end(hash); ++k) {\n            if (kh_exist(hash, k)) {\n                frag_t *f = &kh_val(hash, k);\n                if (f->vpos) continue;\n                f->flip = 0;\n                if (f->seq[0] == 0) f->phased = 0;\n                else f->phased = 1, f->phase = f->seq[0] - 1;\n            }\n        }\n        if (dump_aln(g, min_pos, hash) < 0) return -1;\n        ++g->vpos_shift;\n        return 1;\n    }\n    { // phase\n        int **cnt;\n        uint64_t *mask;\n        printf(\"PS\\t%s\\t%d\\t%d\\n\", chr, (int)(cns[0]>>32) + 1, (int)(cns[vpos-1]>>32) + 1);\n        sitemask = calloc(vpos, 1);\n        cnt = count_all(g->k, vpos, hash);\n        if (!cnt) return -1;\n        path = dynaprog(g->k, vpos, cnt);\n        for (i = 0; i < vpos; ++i) free(cnt[i]);\n        free(cnt);\n        pcnt = fragphase(vpos, path, hash, 0); // do not fix chimeras when masking\n        mask = genmask(vpos, pcnt, &n_masked);\n        regmask = calloc(n_masked, 8);\n        for (i = 0; i < n_masked; ++i) {\n            regmask[i] = cns[mask[i]>>32]>>32<<32 | cns[(uint32_t)mask[i]]>>32;\n            for (j = mask[i]>>32; j <= (int32_t)mask[i]; ++j)\n                sitemask[j] = 1;\n        }\n        free(mask);\n        if (g->flag & FLAG_FIX_CHIMERA) {\n            free(pcnt);\n            pcnt = fragphase(vpos, path, hash, 1);\n        }\n    }\n    for (i = 0; i < n_masked; ++i)\n        printf(\"FL\\t%s\\t%d\\t%d\\n\", chr, (int)(regmask[i]>>32) + 1, (int)regmask[i] + 1);\n    for (i = 0; i < vpos; ++i) {\n        uint64_t x = pcnt[i];\n        int8_t c[2];\n        c[0] = (cns[i]&0xffff)>>2 == 0? 4 : (cns[i]&3);\n        c[1] = (cns[i]>>16&0xffff)>>2 == 0? 4 : (cns[i]>>16&3);\n        printf(\"M%d\\t%s\\t%d\\t%d\\t%c\\t%c\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", sitemask[i]+1, chr, (int)(cns[0]>>32) + 1, (int)(cns[i]>>32) + 1, \"ACGTX\"[c[path[i]]], \"ACGTX\"[c[1-path[i]]],\n            i + g->vpos_shift + 1, (int)(x&0xffff), (int)(x>>16&0xffff), (int)(x>>32&0xffff), (int)(x>>48&0xffff));\n    }\n    free(path); free(pcnt); free(regmask); free(sitemask);\n    seqs = calloc(n_seqs, sizeof(frag_t*));\n    for (k = 0, i = 0; k < kh_end(hash); ++k)\n        if (kh_exist(hash, k) && kh_val(hash, k).vpos < vpos && !kh_val(hash, k).single)\n            seqs[i++] = &kh_val(hash, k);\n    n_seqs = i;\n    ks_introsort_rseq(n_seqs, seqs);\n    for (i = 0; i < n_seqs; ++i) {\n        frag_t *f = seqs[i];\n        printf(\"EV\\t0\\t%s\\t%d\\t40\\t%dM\\t*\\t0\\t0\\t\", chr, f->vpos + 1 + g->vpos_shift, f->vlen);\n        for (j = 0; j < f->vlen; ++j) {\n            uint32_t c = cns[f->vpos + j];\n            if (f->seq[j] == 0) putchar('N');\n            else putchar(\"ACGT\"[f->seq[j] == 1? (c&3) : (c>>16&3)]);\n        }\n        printf(\"\\t*\\tYP:i:%d\\tYF:i:%d\\tYI:i:%d\\tYO:i:%d\\tYS:i:%d\\n\", f->phase, f->flip, f->in, f->out, f->beg+1);\n    }\n    free(seqs);\n    printf(\"//\\n\");\n    fflush(stdout);\n    g->vpos_shift += vpos;\n    if (dump_aln(g, min_pos, hash) < 0) return -1;\n    return vpos;\n}\n\nstatic void update_vpos(int vpos, nseq_t *hash)\n{\n    khint_t k;\n    for (k = 0; k < kh_end(hash); ++k) {\n        if (kh_exist(hash, k)) {\n            frag_t *f = &kh_val(hash, k);\n            if (f->vpos < vpos) kh_del(64, hash, k); // TODO: if frag_t::seq is allocated dynamically, free it\n            else f->vpos -= vpos;\n        }\n    }\n}\n\nstatic nseq_t *shrink_hash(nseq_t *hash) // TODO: to implement\n{\n    return hash;\n}\n\nstatic int readaln(void *data, bam1_t *b)\n{\n    phaseg_t *g = (phaseg_t*)data;\n    int ret;\n    while (1)\n    {\n        ret = sam_read1(g->fp, g->fp_hdr, b);\n        if (ret < 0) break;\n        if ( b->core.flag & (BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP) ) continue;\n        if ( g->pre ) {\n            if (g->n == g->m) {\n                g->m = g->m? g->m<<1 : 16;\n                g->b = realloc(g->b, g->m * sizeof(bam1_t*));\n            }\n            g->b[g->n++] = bam_dup1(b);\n        }\n        break;\n    }\n    return ret;\n}\n\nstatic khash_t(set64) *loadpos(const char *fn, sam_hdr_t *h)\n{\n    gzFile fp;\n    kstream_t *ks;\n    int ret, dret;\n    kstring_t *str;\n    khash_t(set64) *hash;\n\n    fp = strcmp(fn, \"-\")? gzopen(fn, \"r\") : gzdopen(fileno(stdin), \"r\");\n    if (fp == NULL) {\n        print_error_errno(\"phase\", \"Couldn't open site file '%s'\", fn);\n        return NULL;\n    }\n\n    hash = kh_init(set64);\n    str = calloc(1, sizeof(kstring_t));\n\n    ks = ks_init(fp);\n    while (ks_getuntil(ks, 0, str, &dret) >= 0) {\n        int tid = bam_name2id(h, str->s);\n        if (tid >= 0 && dret != '\\n') {\n            if (ks_getuntil(ks, 0, str, &dret) >= 0) {\n                uint64_t x = (uint64_t)tid<<32 | (atoi(str->s) - 1);\n                kh_put(set64, hash, x, &ret);\n            } else break;\n        }\n        if (dret != '\\n') while ((dret = ks_getc(ks)) > 0 && dret != '\\n');\n        if (dret < 0) break;\n    }\n    ks_destroy(ks);\n    gzclose(fp);\n    free(str->s); free(str);\n    return hash;\n}\n\nstatic int gl2cns(float q[16])\n{\n    int i, j, min_ij;\n    float min, min2;\n    min = min2 = 1e30; min_ij = -1;\n    for (i = 0; i < 4; ++i) {\n        for (j = i; j < 4; ++j) {\n            if (q[i<<2|j] < min) min_ij = i<<2|j, min2 = min, min = q[i<<2|j];\n            else if (q[i<<2|j] < min2) min2 = q[i<<2|j];\n        }\n    }\n    return (min_ij>>2&3) == (min_ij&3)? 0 : 1<<18 | (min_ij>>2&3)<<16 | (min_ij&3) | (int)(min2 - min + .499) << 2;\n}\n\nstatic int start_output(phaseg_t *g, int c, const char *middle, const htsFormat *fmt)\n{\n    kstring_t s = { 0, 0, NULL };\n    ksprintf(&s, \"%s.%s.%s\", g->pre, middle, hts_format_file_extension(fmt));\n    g->out_name[c] = ks_release(&s);\n    g->out[c] = sam_open_format(g->out_name[c], \"wb\", fmt);\n    if (! g->out[c]) {\n        print_error_errno(\"phase\", \"Failed to open output file '%s'\", g->out_name[c]);\n        return -1;\n    }\n\n    g->out_hdr[c] = sam_hdr_dup(g->fp_hdr);\n    if (!g->no_pg && sam_hdr_add_pg(g->out_hdr[c], \"samtools\",\n                                    \"VN\", samtools_version(),\n                                    g->arg_list ? \"CL\": NULL,\n                                    g->arg_list ? g->arg_list : NULL,\n                                    NULL)) {\n        print_error(\"phase\", \"failed to add PG line to header\");\n        return -1;\n    }\n    if (sam_hdr_write(g->out[c], g->out_hdr[c]) < 0) {\n        print_error_errno(\"phase\", \"Failed to write header for '%s'\", g->out_name[c]);\n        return -1;\n    }\n\n    return 0;\n}\n\nint main_phase(int argc, char *argv[])\n{\n    int c, tid, pos, vpos = 0, n, lasttid = -1, max_vpos = 0, usage = 0;\n    int status = EXIT_SUCCESS;\n    const bam_pileup1_t *plp;\n    bam_plp_t iter;\n    nseq_t *seqs;\n    uint64_t *cns = 0;\n    phaseg_t g;\n    char *fn_list = 0;\n    khash_t(set64) *set = 0;\n    errmod_t *em;\n    uint16_t *bases;\n\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 0, 0, 0, '-'),\n        {\"min-BQ\", required_argument, NULL, 'Q'},\n        {\"min-bq\", required_argument, NULL, 'Q'},\n        {\"no-PG\", no_argument, NULL, 1},\n        { NULL, 0, NULL, 0 }\n    };\n\n    // FIXME Leaks galore in the case of error returns\n\n    memset(&g, 0, sizeof(phaseg_t));\n    g.flag = FLAG_FIX_CHIMERA;\n    g.min_varLOD = 37; g.k = 13; g.min_baseQ = 13; g.max_depth = 256;\n    while ((c = getopt_long(argc, argv, \"Q:eFq:k:b:l:D:A\", lopts, NULL)) >= 0) {\n        switch (c) {\n            case 'D': g.max_depth = atoi(optarg); break;\n            case 'q': g.min_varLOD = atoi(optarg); break;\n            case 'Q': g.min_baseQ = atoi(optarg); break;\n            case 'k': g.k = atoi(optarg); break;\n            case 'F': g.flag &= ~FLAG_FIX_CHIMERA; break;\n            case 'e': g.flag |= FLAG_LIST_EXCL; break;\n            case 'A': g.flag |= FLAG_DROP_AMBI; break;\n            case 'b': g.pre = strdup(optarg); break;\n            case 'l': fn_list = strdup(optarg); break;\n            case 1: g.no_pg = 1; break;\n            default:  if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n                      /* else fall-through */\n            case '?': usage=1; break;\n        }\n        if (usage) break;\n    }\n    if (usage || argc == optind) {\n        fprintf(stderr, \"\\n\");\n        fprintf(stderr, \"Usage:   samtools phase [options] <in.bam>\\n\\n\");\n        fprintf(stderr, \"Options: -k INT    block length [%d]\\n\", g.k);\n        fprintf(stderr, \"         -b STR    prefix of BAMs to output [null]\\n\");\n        fprintf(stderr, \"         -q INT    min het phred-LOD [%d]\\n\", g.min_varLOD);\n        fprintf(stderr, \"         -Q, --min-BQ INT\\n\"\n                        \"                   min base quality in het calling [%d]\\n\", g.min_baseQ);\n        fprintf(stderr, \"         -D INT    max read depth [%d]\\n\", g.max_depth);\n//      fprintf(stderr, \"         -l FILE   list of sites to phase [null]\\n\");\n        fprintf(stderr, \"         -F        do not attempt to fix chimeras\\n\");\n        fprintf(stderr, \"         -A        drop reads with ambiguous phase\\n\");\n        fprintf(stderr, \"         --no-PG   do not add a PG line\\n\");\n//      fprintf(stderr, \"         -e        do not discover SNPs (effective with -l)\\n\");\n        fprintf(stderr, \"\\n\");\n\n        sam_global_opt_help(stderr, \"-....--.\");\n\n        return 1;\n    }\n    g.fp = sam_open_format(argv[optind], \"r\", &ga.in);\n    if (!g.fp) {\n        print_error_errno(\"phase\", \"Couldn't open '%s'\", argv[optind]);\n        return 1;\n    }\n    g.fp_hdr = sam_hdr_read(g.fp);\n    if (g.fp_hdr == NULL) {\n        fprintf(stderr, \"[%s] Failed to read header for '%s'\\n\",\n                __func__, argv[optind]);\n        return 1;\n    }\n    if (!g.no_pg && !(g.arg_list = stringify_argv(argc+1, argv-1))) {\n        print_error(\"phase\", \"failed to create arg_list\");\n        return 1;\n    }\n    if (fn_list) { // read the list of sites to phase\n        set = loadpos(fn_list, g.fp_hdr);\n        if (set == NULL) return 1;\n        free(fn_list);\n    } else g.flag &= ~FLAG_LIST_EXCL;\n    if (g.pre) { // open BAMs to write\n        if (ga.out.format == unknown_format)\n            ga.out.format = bam; // default via \"wb\".\n\n        // Open each output file g.out[0..2], dupping and writing the header\n        if (start_output(&g, 0, \"0\", &ga.out) < 0 ||\n            start_output(&g, 1, \"1\", &ga.out) < 0 ||\n            start_output(&g, 2, \"chimera\", &ga.out) < 0) return 1;\n    }\n\n    iter = bam_plp_init(readaln, &g);\n    g.vpos_shift = 0;\n    seqs = kh_init(64);\n    em = errmod_init(1. - 0.83);\n    bases = calloc(g.max_depth, 2);\n    printf(\"CC\\n\");\n    printf(\"CC\\tDescriptions:\\nCC\\n\");\n    printf(\"CC\\t  CC      comments\\n\");\n    printf(\"CC\\t  PS      start of a phase set\\n\");\n    printf(\"CC\\t  FL      filtered region\\n\");\n    printf(\"CC\\t  M[012]  markers; 0 for singletons, 1 for phased and 2 for filtered\\n\");\n    printf(\"CC\\t  EV      supporting reads; SAM format\\n\");\n    printf(\"CC\\t  //      end of a phase set\\nCC\\n\");\n    printf(\"CC\\tFormats of PS, FL and M[012] lines (1-based coordinates):\\nCC\\n\");\n    printf(\"CC\\t  PS  chr  phaseSetStart  phaseSetEnd\\n\");\n    printf(\"CC\\t  FL  chr  filterStart    filterEnd\\n\");\n    printf(\"CC\\t  M?  chr  PS  pos  allele0  allele1  hetIndex  #supports0  #errors0  #supp1  #err1\\n\");\n    printf(\"CC\\nCC\\n\");\n    fflush(stdout);\n    while ((plp = bam_plp_auto(iter, &tid, &pos, &n)) != 0) {\n        int i, k, c, tmp, dophase = 1, in_set = 0;\n        float q[16];\n        if (tid < 0) break;\n        if (tid != lasttid) { // change of chromosome\n            g.vpos_shift = 0;\n            if (lasttid >= 0) {\n                seqs = shrink_hash(seqs);\n                if (phase(&g, sam_hdr_tid2name(g.fp_hdr, lasttid),\n                          vpos, cns, seqs) < 0) {\n                    return 1;\n                }\n                update_vpos(0x7fffffff, seqs);\n            }\n            lasttid = tid;\n            vpos = 0;\n        }\n        if (set && kh_get(set64, set, (uint64_t)tid<<32 | pos) != kh_end(set)) in_set = 1;\n        if (n > g.max_depth) continue; // do not proceed if the depth is too high\n        // fill the bases array and check if there is a variant\n        for (i = k = 0; i < n; ++i) {\n            const bam_pileup1_t *p = plp + i;\n            uint8_t *seq;\n            int q, baseQ, b;\n            if (p->is_del || p->is_refskip) continue;\n            baseQ = bam_get_qual(p->b)[p->qpos];\n            if (baseQ < g.min_baseQ) continue;\n            seq = bam_get_seq(p->b);\n            b = seq_nt16_int[bam_seqi(seq, p->qpos)];\n            if (b > 3) continue;\n            q = baseQ < p->b->core.qual? baseQ : p->b->core.qual;\n            if (q < 4) q = 4;\n            if (q > 63) q = 63;\n            bases[k++] = q<<5 | (int)bam_is_rev(p->b)<<4 | b;\n        }\n        if (k == 0) continue;\n        errmod_cal(em, k, 4, bases, q); // compute genotype likelihood\n        c = gl2cns(q); // get the consensus\n        // tell if to proceed\n        if (set && (g.flag&FLAG_LIST_EXCL) && !in_set) continue; // not in the list\n        if (!in_set && (c&0xffff)>>2 < g.min_varLOD) continue; // not a variant\n        // add the variant\n        if (vpos == max_vpos) {\n            max_vpos = max_vpos? max_vpos<<1 : 128;\n            cns = realloc(cns, max_vpos * 8);\n        }\n        cns[vpos] = (uint64_t)pos<<32 | c;\n        for (i = 0; i < n; ++i) {\n            const bam_pileup1_t *p = plp + i;\n            uint64_t key;\n            khint_t k;\n            uint8_t *seq = bam_get_seq(p->b);\n            frag_t *f;\n            if (p->is_del || p->is_refskip) continue;\n            if (p->b->core.qual == 0) continue;\n            // get the base code\n            c = seq_nt16_int[bam_seqi(seq, p->qpos)];\n            if (c == (cns[vpos]&3)) c = 1;\n            else if (c == (cns[vpos]>>16&3)) c = 2;\n            else c = 0;\n            // write to seqs\n            key = X31_hash_string(bam_get_qname(p->b));\n            k = kh_put(64, seqs, key, &tmp);\n            f = &kh_val(seqs, k);\n            if (tmp == 0) { // present in the hash table\n                if (vpos - f->vpos + 1 < MAX_VARS) {\n                    f->vlen = vpos - f->vpos + 1;\n                    f->seq[f->vlen-1] = c;\n                    f->end = bam_endpos(p->b);\n                }\n                dophase = 0;\n            } else { // absent\n                memset(f->seq, 0, MAX_VARS);\n                f->beg = p->b->core.pos;\n                f->end = bam_endpos(p->b);\n                f->vpos = vpos, f->vlen = 1, f->seq[0] = c, f->single = f->phased = f->flip = f->ambig = 0;\n            }\n        }\n        if (dophase) {\n            seqs = shrink_hash(seqs);\n            if (phase(&g, sam_hdr_tid2name(g.fp_hdr, tid), vpos, cns, seqs) < 0) {\n                return 1;\n            }\n            update_vpos(vpos, seqs);\n            cns[0] = cns[vpos];\n            vpos = 0;\n        }\n        ++vpos;\n    }\n    if (tid >= 0) {\n        if (phase(&g, sam_hdr_tid2name(g.fp_hdr, tid), vpos, cns, seqs) < 0) {\n            return 1;\n        }\n    }\n\n    if (n < 0) {\n        print_error(\"phase\", \"error reading from '%s'\", argv[optind]);\n        status = EXIT_FAILURE;\n    }\n\n    sam_hdr_destroy(g.fp_hdr);\n    bam_plp_destroy(iter);\n    sam_close(g.fp);\n    kh_destroy(64, seqs);\n    kh_destroy(set64, set);\n    free(cns);\n    errmod_destroy(em);\n    free(bases);\n    if (g.pre) {\n        int res = 0;\n        for (c = 0; c <= 2; ++c) {\n            if (sam_close(g.out[c]) < 0) {\n                fprintf(stderr, \"[%s] error on closing '%s'\\n\",\n                        __func__, g.out_name[c]);\n                res = 1;\n            }\n            sam_hdr_destroy(g.out_hdr[c]);\n            free(g.out_name[c]);\n        }\n        free(g.pre); free(g.b);\n        if (res) return 1;\n    }\n    free(g.arg_list);\n    sam_global_args_free(&ga);\n    return status;\n}\n"
        },
        {
          "name": "reference.c",
          "type": "blob",
          "size": 18.208984375,
          "content": "/*  bam_reference.c -- extracts an embedded reference from a CRAM file,\n                       or creates it from alignments plus MD:Z tags.\n\n    Copyright (C) 2022 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"htslib/sam.h\"\n#include \"htslib/cram.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n\n\n/*\n * There are two main modes of operation.\n *\n * 1. Extracting the reference from the CRAM file embed_ref blocks.\n * 2. Generation of reference by analysing consensus plus patches applied\n *    via MD tags.\n *\n * The first is very rapid, but only applies to a CRAM files generated with\n * the specific options (not commonly used and not the default).  The second\n * is a slow operation, but applies to any data type.\n *\n * This is also a testing ground for a future CRAM auto-embed-ref option that\n * permits the use of an embedded reference without having to first extract\n * the reference.  (Note this may require the creation of MD tags during\n * decode by use of an existing embedded reference, if the records don't\n * have an MD tag themselves, but that's an issue for htslib when we get\n * there.)\n */\n\n/*\n * ---------------------------------------------------------------------------\n * Shared utility functions by both methods.\n */\n\n#define haszero(x) (((x)-0x0101010101010101UL)&~(x)&0x8080808080808080UL)\n#define MIN(a,b) ((a)<(b)?(a):(b))\nstatic int dump_ref(sam_hdr_t *h, hts_itr_t *iter, int ref_id,\n                    char *ref, uint64_t ref_len, FILE *fp, int verbose) {\n    int N = 0;\n    if (iter && iter->end >= HTS_POS_MAX)\n        iter->end = ref_len;\n    if (iter && (iter->beg > 0 || iter->end < ref_len)) {\n        fprintf(fp, \">%s:%\"PRIhts_pos\"-%\"PRIhts_pos\"\\n\",\n                sam_hdr_tid2name(h, ref_id), iter->beg+1, iter->end);\n        ref += iter->beg;\n        ref_len = MIN(ref_len, iter->end) - iter->beg;\n    } else {\n        fprintf(fp, \">%s\\n\", sam_hdr_tid2name(h, ref_id));\n    }\n\n    int i, j;\n    uint64_t rem = ref_len;\n\n    // Count coverage, purely for information purposes.\n    // About 90% of dump_ref CPU is here, so maybe this isn't useful,\n    // but this is still 3-4x faster than the obvious naive loop.\n    //\n    // Overall though it's only about 5% overhead of the entire process\n    // (was ~20%).\n    if (verbose) {\n        int n4[8] = {0};\n        for (j = 0; j < ref_len && (((uintptr_t) &ref[j] & 7) != 0); j++)\n            N += ref[j] == 'N';\n        uint64_t fast_end = ((ref_len - j) & ~7) + j;\n        for (; j < fast_end; j+=8) {\n            uint64_t i64 = *(uint64_t *)&ref[j];\n            if (!haszero(i64 ^ 0x4e4e4e4e4e4e4e4eUL)) // 'N' <-> 0\n                continue;\n\n            n4[0] += ref[j+0] == 'N';\n            n4[1] += ref[j+1] == 'N';\n            n4[2] += ref[j+2] == 'N';\n            n4[3] += ref[j+3] == 'N';\n            n4[4] += ref[j+4] == 'N';\n            n4[5] += ref[j+5] == 'N';\n            n4[6] += ref[j+6] == 'N';\n            n4[7] += ref[j+7] == 'N';\n        }\n        for (; j < ref_len; j++)\n            N += ref[j] == 'N';\n        N += n4[0]+n4[1]+n4[2]+n4[3]+\n            n4[4]+n4[5]+n4[6]+n4[7];\n    }\n\n    // Format reference\n    for (i = 0; i < ref_len; i += 60, rem -= 60) {\n        int len = (int)(rem < 60 ? rem : 60);\n        if (fwrite(ref, 1, len, fp) != len)\n            return -1;\n        putc('\\n', fp);\n        ref += 60;\n    }\n\n    if (verbose)\n        fprintf(stderr, \"Dump ref %d len %\"PRId64\", coverage %.2f%%\\n\",\n                ref_id, ref_len, 100 - N*100.0 / ref_len);\n\n    return 0;\n}\n\n/*\n * ---------------------------------------------------------------------------\n * CRAM embedded reference method of reference construction\n */\n\n/*\n * Extracts an embedded reference from a sorted CRAM file.\n * Modelled on the CRAM container copy loop from bam_cat.c.\n */\nstatic int cram2ref(samFile *in, sam_hdr_t *h, hts_idx_t *idx, char *reg,\n                    FILE *outfp, int verbose) {\n    cram_fd *in_c;\n    cram_container *c = NULL;\n    cram_block *blk = NULL;\n    cram_block_slice_hdr *shdr = NULL;\n\n    int curr_ref_id = -99;\n    char *ref = NULL;\n    uint64_t ref_len = 0;\n\n    // We have no direct public API for seeking in CRAM to a specific\n    // location by genome coordinates.  The sam_itr_query API is\n    // designed for fetching records, rather than seeks to specific\n    // file locations.\n    //\n    // TODO: consider exposing cram_range and cram_seek_to_refpos API.\n    // After a sam_index_load which will add the index to infp, these\n    // functions should seek direct to the start of a container.\n    // Or use cram_index *e =cram_index_query(cram, tid, beg, NULL);\n    //\n    // However, fortuitously(?) sam_itr_querys calls cram_seek_to_refpos\n    // so we can do a region query and let that do the initial seek.\n    // We still need to do our own end-range detection though.\n\n    hts_itr_t *iter = NULL;\n    if (reg) {\n        iter = sam_itr_querys(idx, h, reg);\n        if (!iter) {\n            print_error(\"reference\", \"failed to parse region '%s'\", reg);\n            goto err;\n        }\n    }\n\n    in_c = in->fp.cram; // low level htslib abuse?\n    int eor = 0;\n    while (!eor && (c = cram_read_container(in_c))) {\n        if (cram_container_is_empty(in_c)) {\n            cram_block *blk;\n            // Container compression header\n            if (!(blk = cram_read_block(in_c)))\n                goto err;\n            cram_free_block(blk);\n            cram_free_container(c);\n            c = NULL; blk = NULL;\n            continue;\n        }\n\n        // Container compression header; read and discard\n        int32_t num_slices;\n        if (!(blk = cram_read_block(in_c)))\n            goto err;\n        cram_free_block(blk);\n        blk = NULL;\n\n        // Container num_blocks can be invalid, due to a bug.\n        // Instead we iterate in slice context instead.\n        (void)cram_container_get_landmarks(c, &num_slices);\n        int i, j;\n        for (i = 0; i < num_slices; i++) {\n            // Slice header\n            if (!(blk = cram_read_block(in_c)))\n                goto err;\n            if (!(shdr = cram_decode_slice_header(in_c, blk)))\n                goto err;\n            cram_free_block(blk);\n            blk = NULL;\n\n            int num_blocks = cram_slice_hdr_get_num_blocks(shdr);\n            int embed_id = cram_slice_hdr_get_embed_ref_id(shdr);\n            int ref_id;\n            hts_pos_t ref_start, ref_span;\n            cram_slice_hdr_get_coords(shdr, &ref_id, &ref_start, &ref_span);\n\n            if (iter) {\n                if (iter->tid != ref_id || ref_start > iter->end) {\n                    // Beyond end of specified region.\n                    cram_free_slice_header(shdr);\n                    eor = 1;\n                    break;\n                }\n            }\n\n            if (embed_id < 0 && ref_id != -1) {\n                fprintf(stderr, \"CRAM file has slice without embedded \"\n                        \"reference\\n\");\n                goto err;\n            }\n\n            if (ref_id != curr_ref_id) {\n                if (curr_ref_id >= 0) {\n                    if (dump_ref(h, iter, curr_ref_id, ref, ref_len,\n                                 outfp, verbose) < 0)\n                        goto err;\n                }\n\n                ref_len = sam_hdr_tid2len(h, ref_id);\n                if (ref_len) {\n                    char *ref2 = realloc(ref, ref_len);\n                    if (!ref2)\n                        goto err;\n                    else\n                        ref = ref2;\n                    memset(ref, 'N', ref_len);\n                }\n                curr_ref_id = ref_id;\n            }\n\n            // Slice data blocks\n            for (j = 0; j < num_blocks; j++) {\n                // read and discard, unless it's the ref-ID block\n                if (!(blk = cram_read_block(in_c)))\n                    goto err;\n                if (cram_block_get_content_id(blk) == embed_id) {\n                    cram_uncompress_block(blk);\n                    //printf(\"%.*s\\n\", blk->uncomp_size, blk->data);\n\n                    int32_t usize = cram_block_get_uncomp_size(blk);\n                    int ref_end = ref_start + usize;\n                    if (ref_end > ref_len+1)\n                        ref_end = ref_len+1;\n                    if (ref_end > ref_start)\n                        memcpy(ref + ref_start-1, cram_block_get_data(blk),\n                               ref_end - ref_start);\n                }\n                cram_free_block(blk);\n                blk = NULL;\n            }\n            cram_free_slice_header(shdr);\n            shdr = NULL;\n        }\n\n        cram_free_container(c);\n        c = NULL;\n    }\n\n    int ret = 0;\n    if (curr_ref_id >= 0) {\n        ret = dump_ref(h, iter, curr_ref_id, ref, ref_len, outfp, verbose);\n    } else if (reg) {\n        // no data present\n        // no data present, but we explicitly asked for the reference so\n        // report it still as Ns.\n        ref_len = MIN(iter->end,  sam_hdr_tid2len(h, iter->tid));\n        ref = malloc(ref_len);\n        memset(ref, 'N', ref_len);\n        if (!ref)\n            goto err;\n        ret = dump_ref(h, iter, iter->tid, ref, ref_len, outfp, verbose);\n    }\n\n    free(ref);\n    if (iter)\n        hts_itr_destroy(iter);\n\n    return ret;\n\n err:\n    free(ref);\n    if (blk)\n        cram_free_block(blk);\n    if (shdr)\n        cram_free_slice_header(shdr);\n    if (c)\n        cram_free_container(c);\n    if (iter)\n        hts_itr_destroy(iter);\n\n    return -1;\n}\n\n/*\n * ---------------------------------------------------------------------------\n * MD method of reference construction\n */\n\n// Returns the next cigar op code: one of the BAM_C* codes,\n// or -1 if no more are present.\nstatic inline\nint next_cigar_op(uint32_t *cigar, int *ncigar, int *skip, int *spos,\n                  uint32_t *cig_ind, uint32_t *cig_op, uint32_t *cig_len) {\n    for(;;) {\n        while (*cig_len == 0) {\n            if (*cig_ind < *ncigar) {\n                *cig_op  = cigar[*cig_ind] & BAM_CIGAR_MASK;\n                *cig_len = cigar[*cig_ind] >> BAM_CIGAR_SHIFT;\n                (*cig_ind)++;\n            } else {\n                return -1;\n            }\n        }\n\n        if (skip[*cig_op]) {\n            *spos += (bam_cigar_type(*cig_op)&1) * *cig_len;\n            *cig_len = 0;\n            continue;\n        }\n\n        (*cig_len)--;\n        break;\n    }\n\n    return *cig_op;\n}\n\n// Converts a bam object with SEQ, POS/CIGAR and MD:Z to a reference.\n// Updates ref[] array.\n//\n// Returns >0 on success,\n//          0 on no-MD found,\n//         -1 on failure (eg inconsistent data)\nstatic int build_ref(bam1_t *b, char *ref, size_t ref_len) {\n    uint8_t *seq = bam_get_seq(b);\n    uint32_t *cigar = bam_get_cigar(b);\n    int ncigar = b->core.n_cigar;\n    uint32_t cig_op = 0, cig_len = 0, cig_ind = 0;\n\n    const uint8_t *MD = bam_aux_get(b, \"MD\");\n    if (!MD || *MD != 'Z')\n        return 0;\n    MD++;\n\n    // Walk through MD + seq to generate ref\n    int iseq = 0, iref = b->core.pos, next_op;\n    int cig_skip[16] = {0,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1};\n    while (iseq < b->core.l_qseq && *MD) {\n        if (isdigit(*MD)) {\n            // match\n            int len = strtol((char *)MD, (char **)&MD, 10);\n            while (iseq < b->core.l_qseq && len) {\n                if ((next_op = next_cigar_op(cigar, &ncigar, cig_skip,\n                                             &iseq, &cig_ind, &cig_op,\n                                             &cig_len)) < 0)\n                    return -1;\n\n                if (next_op != BAM_CMATCH &&\n                    next_op != BAM_CEQUAL) {\n                    print_error(\"MD2ref\",\n                                \"MD:Z and CIGAR are incompatible\");\n                    return -1;\n                }\n\n                if (iref < ref_len)\n                    ref[iref] = seq_nt16_str[bam_seqi(seq, iseq)];\n                iseq++;\n                iref++;\n                len--;\n            }\n        } else if (*MD == '^') {\n            // deletion\n            MD++;\n            while (*MD && isalpha(*MD)) {\n                if ((next_op = next_cigar_op(cigar, &ncigar, cig_skip,\n                                             &iseq, &cig_ind, &cig_op,\n                                             &cig_len)) < 0)\n                    return -1;\n\n                if (next_op != BAM_CDEL) {\n                    print_error(\"MD2ref\",\n                                \"MD:Z and CIGAR are incompatible\");\n                    return -1;\n                }\n\n                if (iref < ref_len)\n                    ref[iref] = *MD;\n\n                MD++;\n                iref++;\n            }\n        } else {\n            // substitution\n            if ((next_op = next_cigar_op(cigar, &ncigar, cig_skip,\n                                         &iseq, &cig_ind, &cig_op,\n                                         &cig_len)) < 0)\n                return -1;\n\n            if (next_op != BAM_CMATCH && next_op != BAM_CDIFF) {\n                print_error(\"MD2ref\", \"MD:Z and CIGAR are incompatible\");\n                return -1;\n            }\n            if (iref < ref_len)\n                ref[iref] = *MD;\n\n            MD++;\n            iref++;\n            iseq++;\n        }\n    }\n\n    return 1;\n}\n\nstatic int MD2ref(samFile *in, sam_hdr_t *h, hts_idx_t *idx, char *reg,\n                  FILE *outfp, int verbose) {\n    bam1_t *b = bam_init1();\n    int r, last_tid = -99;\n    size_t ref_len = 0;\n    char *ref = NULL;\n    int ret = -1;\n\n    hts_itr_t *iter = NULL;\n    if (idx && reg) {\n        iter = sam_itr_querys(idx, h, reg);\n        if (!iter) {\n            print_error(\"reference\", \"failed to parse region '%s'\", reg);\n            goto err;\n        }\n    }\n\n    while ((r = iter\n                ? sam_itr_next(in, iter, b)\n                : sam_read1(in, h, b)) >= 0) {\n        // check b->core.tid and flush old seq.\n        if (b->core.tid != last_tid) {\n            if (last_tid >= 0)\n                if (dump_ref(h, iter, last_tid, ref, ref_len, outfp,\n                             verbose) < 0)\n                    goto err;\n\n            last_tid = b->core.tid;\n            ref_len = sam_hdr_tid2len(h, last_tid);\n            if (ref_len) {\n                char *ref2 = realloc(ref, ref_len);\n                if (!ref2)\n                    goto err;\n                else\n                    ref = ref2;\n                memset(ref, 'N', ref_len);\n            }\n        }\n\n        if (build_ref(b, ref, ref_len) < 0)\n            goto err;\n    }\n\n    if (last_tid >= 0) {\n        if (dump_ref(h, iter, last_tid, ref, ref_len, outfp, verbose) < 0)\n            goto err;\n    } else if (reg) {\n        // no data present, but we explicitly asked for the reference so\n        // report it still as Ns.\n        ref_len = MIN(iter->end,  sam_hdr_tid2len(h, iter->tid));\n        ref = malloc(ref_len);\n        memset(ref, 'N', ref_len);\n        if (!ref)\n            goto err;\n        if (dump_ref(h, iter, iter->tid, ref, ref_len, outfp, verbose) < 0)\n            goto err;\n    }\n\n    if (r < -1)\n        goto err;\n\n    ret = 0;\n\n err:\n    if (iter)\n        hts_itr_destroy(iter);\n    bam_destroy1(b);\n    free(ref);\n    return ret;\n}\n\nint main_reference(int argc, char *argv[])\n{\n    int c, usage = 0, verbose = 1, use_embedded = 0;\n    sam_hdr_t *h = 0;\n    samFile *in = NULL;\n    hts_idx_t *idx = NULL;\n    sam_global_args ga;\n    FILE *outfp = stdout;\n    char *reg = NULL;\n\n    static const struct option lopts[] = {\n        {\"output\",   required_argument, NULL, 'o'},\n        {\"quiet\",    no_argument,       NULL, 'q'},\n        {\"embedded\", no_argument,       NULL, 'e'},\n        {\"region\",   required_argument, NULL, 'r'},\n        SAM_OPT_GLOBAL_OPTIONS('-', '-', '-', '-', '-', '@'),\n        { NULL, 0, NULL, 0 }\n    };\n\n    sam_global_args_init(&ga);\n\n    while ((c = getopt_long(argc, argv, \"@:qo:er:\", lopts, NULL)) >= 0) {\n        switch (c) {\n        case 'o':\n            if (!(outfp = fopen(optarg, \"w\"))) {\n                perror(optarg);\n                goto err;\n            }\n            break;\n\n        case 'q':\n            verbose = 0;\n            break;\n\n        case 'e':\n            use_embedded = 1;\n            break;\n\n        case 'r':\n            reg = optarg;\n            break;\n\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?': usage=1; break;\n        }\n    }\n\n    if ((optind == argc && isatty(0)) || usage) {\n        printf(\"Usage: samtools reference [-@ N] [-r region] [-e] [-q] [-o out.fa] [in.cram]\\n\");\n        return 0;\n    }\n\n    char *fn = optind < argc ? argv[optind] : \"-\";\n    if (!(in = sam_open(fn, \"r\"))) {\n        print_error_errno(\"reference\", \"failed to open file '%s'\", fn);\n        return 1;\n    }\n\n    if (ga.nthreads > 0)\n        hts_set_threads(in, ga.nthreads);\n\n    if (!(h = sam_hdr_read(in)))\n        goto err;\n\n    if (reg) {\n        idx = sam_index_load(in, fn);\n        if (!idx) {\n            print_error_errno(\"reference\", \"Failed to load the index\");\n            goto err;\n        }\n    }\n\n    int ret = use_embedded\n        ? cram2ref(in, h, idx, reg, outfp, verbose)\n        : MD2ref(in, h, idx, reg, outfp, verbose);\n\n    sam_hdr_destroy(h);\n    if (outfp != stdout)\n        fclose(outfp);\n    if (idx)\n        hts_idx_destroy(idx);\n    sam_close(in);\n\n    return ret;\n\n err:\n    if (idx)\n        hts_idx_destroy(idx);\n    if (in)\n        sam_close(in);\n    if (h)\n        sam_hdr_destroy(h);\n\n    return 1;\n}\n"
        },
        {
          "name": "reset.c",
          "type": "blob",
          "size": 21.72265625,
          "content": "/*  reset.c --  removes aligner updates and reference data from input sam /\n                bam / cram file and makes read data raw for new processing\n\n    Copyright (C) 2022 - 2024 Genome Research Ltd.\n\n    Author: Vasudeva Sarma <vasudeva.sarma@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE\n\n*/\n\n#include <config.h>\n\n#include \"samtools.h\"\n#include \"htslib/sam.h\"\n#include \"sam_opts.h\"\n#include \"htslib/thread_pool.h\"\n#include \"htslib/khash.h\"\n#include \"sam_utils.h\"\n#include <unistd.h>\n\n#define TAGNUM(X) (((X)[0] << 8) | (X)[1])  //to create key for aux tags, like type key in htslib\n#define LONG_OPT(X) (128 + (X))             //to handle long and short options with same char\n\n#define RESET_KEEPDUPFLAG   1               //keep dup flag as such, as in initial implementation\n\ntypedef struct conf_data\n{\n    int keepRGs;                    //RG line handling\n    int noPGentry;                  //PG line for reset op or not\n    int ctrlFlags;                  //control flags\n    auxhash_t aux_keep;             //SET that holds the aux tags to be retained\n    auxhash_t aux_remove;           //SET that holds the aux tags to be removed\n    char *pgid;                     //PG id onwards which to be removed\n} conf_data;\n\n/// usage - print the usage\n/** @param fp pointer to the file / terminal to which usage to be dumped\nreturns nothing\n*/\nstatic void usage(FILE *fp)\n{\n    fprintf(fp, \"Usage: samtools reset [options]\\n\\\n  -o FILE      Output file\\n\\\n  -x, --remove-tag STR\\n\\\n               Aux tags to be removed\\n\\\n      --keep-tag STR\\n\\\n               Aux tags to be retained. Equivalent to -x ^STR\\n\\\n      --reject-PG ID\\n\\\n               Removes PG line with ID matching to input and succeeding PG lines\\n\\\n      --no-RG  To have RG lines or not\\n\\\n      --no-PG  To have PG entry or not for reset operation\\n\\\n      --dupflag\\n\\\n               Keeps the duplicate flag as it is\\n\");\n\n    sam_global_opt_help(fp, \"--O--@--\");\n    return;\n}\n\n/// update_aux_conf - update the user given aux tag configuration with defaults\n/** @param config - pointer to conf_data\nreturns nothing\n*/\nvoid update_aux_conf(conf_data *config)\n{\n    const char rg[] = \"RG\";\n    const char *default_tags[] = {\"AS\", \"CC\", \"CG\", \"CP\", \"H1\", \"H2\", \"HI\", \"H0\", \"IH\",\n                                    \"MC\", \"MD\", \"MQ\", \"NM\", \"SA\", \"TS\"};\n    khint_t iter = 0;\n    int ret = 0, i = 0;\n\n    if (!config)\n        return;\n\n    if (!config->aux_keep && !config->aux_remove) {\n        //none of aux tag filter in use, create remove filter\n        config->aux_remove = kh_init(aux_exists);\n    }\n    if (config->aux_keep) {\n        //keep set in use, remove RG if present\n        if (!config->keepRGs) {\n            iter = kh_get(aux_exists, config->aux_keep, TAGNUM(rg));\n            if (iter != kh_end(config->aux_keep)) {\n                kh_del(aux_exists, config->aux_keep, iter);\n            }\n        }\n    }\n    if (config->aux_remove) {\n        if (!config->keepRGs) {\n            //remove set in use, add RG if not present\n            iter = kh_get(aux_exists, config->aux_remove, TAGNUM(rg));\n            if (iter == kh_end(config->aux_remove)) {\n                kh_put(aux_exists, config->aux_remove, TAGNUM(rg), &ret);\n            }\n        }\n        //add the default tags if not present in remove set\n        //note, keep has priority and this may not be honoured\n        for (i = 0; i < sizeof(default_tags) / sizeof(default_tags[0]); ++i) {\n            iter = kh_get(aux_exists, config->aux_remove, TAGNUM(default_tags[i]));\n            if (iter == kh_end(config->aux_remove)) {\n                kh_put(aux_exists, config->aux_remove, TAGNUM(default_tags[i]), &ret);\n            }\n        }\n    }\n}\n\n/// removeauxtags - remove aux tags in bam data which are not present in acceptable tag set\n/** @param bamdata - pointer to the bamdata from which needs the filtering\n *  @param config - pointer to conf_data\nreturns nothing\n*/\nvoid removeauxtags(bam1_t *bamdata, conf_data *config)\n{\n    uint8_t *auxdata = NULL;\n    const char *tag = NULL;\n    khint_t iter = 0;\n\n    if (!bamdata || !config)\n        return;\n\n    for (auxdata = bam_aux_first(bamdata); auxdata; ) {\n        tag = bam_aux_tag(auxdata);\n        if (config->aux_keep) {                         //keep option or remove option with ^ in use\n            iter = kh_get(aux_exists, config->aux_keep, TAGNUM(tag));\n            if (iter == kh_end(config->aux_keep)) {     //not present in keep, remove\n                auxdata = bam_aux_remove(bamdata, auxdata);\n            }\n            else {                                      //present, keep\n                auxdata = bam_aux_next(bamdata, auxdata);\n            }\n        }\n        else if (config->aux_remove) {                  //remove option in use\n            iter = kh_get(aux_exists, config->aux_remove, TAGNUM(tag));\n            if (iter != kh_end(config->aux_remove)) {   //present in remove, remove\n                auxdata = bam_aux_remove(bamdata, auxdata);\n            }\n            else {                                      //not present, keep\n                auxdata = bam_aux_next(bamdata, auxdata);\n            }\n        }\n        //else impossible\n    }\n}\n\n/// getRGlines - add RG lines from input header to output header\n/** @param in_samhdr - pointer to input sam header data\n *  @param out_samhdr - pointer to output sam header data\nreturns 1 on failure 0 on success\n*/\nint getRGlines(sam_hdr_t *in_samhdr, sam_hdr_t *out_samhdr)\n{\n    kstring_t line = KS_INITIALIZE;\n    int i = 0, ret = 0, count = 0;\n    const char rg[] = \"RG\";\n\n    if (!in_samhdr || !out_samhdr) {\n        fprintf(stderr, \"Invalid parameters in getRGlines!\\n\");\n        return 1;\n    }\n\n    if (-1 == (count = sam_hdr_count_lines(in_samhdr, rg))) {\n        fprintf(stderr, \"Failed to get RG count!\\n\");\n        return 1;\n    }\n\n    for (i = 0; i < count; ++i)\n    {\n        ks_clear(&line);\n        if (sam_hdr_find_line_pos(in_samhdr, rg, i, &line)) {\n            fprintf(stderr, \"Failed to get RG data!\\n\");\n            ret = 1;\n            break;\n        }\n        if (sam_hdr_add_lines(out_samhdr, line.s, line.l)) {\n            fprintf(stderr, \"Failed to add RG data!\\n\");\n            ret = 1;\n            break;\n        }\n    }\n    ks_free(&line);\n\n    return ret;\n}\n\n/// getPGlines - add PG lines from input header to output header based on user option\n/** @param in_samhdr - pointer to input sam header data\n *  @param out_samhdr - pointer to output sam header data\n *  @param config - pointer to internal configuration data\n *  @param argdump - string containing dump of command line invocation\nreturns 1 on failure 0 on success\n*/\nint getPGlines(sam_hdr_t *in_samhdr, sam_hdr_t *out_samhdr, conf_data *config, const char *argdump)\n{\n    kstring_t line = KS_INITIALIZE, id = KS_INITIALIZE;\n    int i = 0, ret = 0, count = 0;\n    const char pg[] = \"PG\";\n\n    if (!in_samhdr || !out_samhdr || !config) {\n        fprintf(stderr, \"Invalid parameters in getPGlines!\\n\");\n        return 1;\n    }\n\n    if (-1 == (count = sam_hdr_count_lines(in_samhdr, pg))) {\n        fprintf(stderr, \"Failed to get PG count!\\n\");\n        return 1;\n    }\n\n    if (config->pgid && config->pgid[0]) {            //when reject-PG is given, and is not empty, remove given pg onwards\n        for (i = 0; i < count; ++i) {\n            if (sam_hdr_find_tag_pos(in_samhdr, pg, i, \"ID\", &id)) {\n                fprintf(stderr, \"Failed to get PG entry fields for line %d!\\n\", i + 1);\n                break;\n            }\n\n            if (!strcmp(id.s, config->pgid))\n                break;\n\n            //either current PG is prior to rejected one or all PGs are in, get PG line and add\n            ks_clear(&line);\n            if (sam_hdr_find_line_pos(in_samhdr, \"PG\", i, &line)) {\n                fprintf(stderr, \"Failed to get PG data at %d!\\n\", i + 1);\n                ret = 1;\n                break;\n            }\n\n            //add to output\n            if (sam_hdr_add_lines(out_samhdr, line.s, line.l)) {\n                fprintf(stderr, \"Failed to add PG data!\\n\");\n                ret = 1;\n                break;\n            }\n        }\n    }\n    else {        //keep all\n        for (i = 0; i < count; ++i) {\n            if (sam_hdr_find_line_pos(in_samhdr, \"PG\", i, &line)) {\n                fprintf(stderr, \"Failed to get PG data at %d!\\n\", i + 1);\n                ret = 1;\n                break;\n            }\n            //line has the required PG data\n            if (sam_hdr_add_lines(out_samhdr, line.s, line.l)) {\n                fprintf(stderr, \"Failed to add PG data!\\n\");\n                ret = 1;\n                break;\n            }\n        }\n    }\n\n    if (!ret && !config->noPGentry) {\n        //add PG entry with reset command\n        if (-1 == (ret = sam_hdr_add_pg(out_samhdr, \"samtools\", \"CL\", argdump, NULL))) {\n            fprintf(stderr, \"Failed to set PG entry!\\n\");\n        }\n    }\n    ks_free(&line);\n    ks_free(&id);\n\n    return ret;\n}\n\n/// reset - do the reset of data and create output; create output header with required rg/pg data, add bamdata with flags set to unmapped, pair info and orientation reset,\n// reerse and complement alignment if required\n/** @param infile - input samfile pointer\n *  @param outfile - output sam file pointer\n *  @param config - pointer to internal configuration data\n *  @param args - string containing dump of command line invocation\nreturns 1 on failure 0 on success\n*/\nint reset(samFile *infile, samFile *outfile, conf_data *config, char *args)\n{\n    sam_hdr_t *in_samhdr = NULL, *out_samhdr = NULL;\n    int ret = EXIT_FAILURE, ret_r = 0, ret_w = 0, i = 0;\n    bam1_t *bamdata = NULL, *outdata = NULL;\n    kstring_t querydata = KS_INITIALIZE, qualdata = KS_INITIALIZE;\n    char *sp = NULL, *qp = NULL;\n    uint8_t *bamquery = NULL, *bamqual = NULL;\n\n    if (!infile || !outfile) {\n        fprintf(stderr, \"Invalid parameters in reset!\\n\");\n        goto error;\n    }\n\n    //read input header\n    in_samhdr = sam_hdr_read(infile);\n    if (!in_samhdr)\n    {\n        fprintf(stderr, \"Failed to read header from file!\\n\");\n        goto error;\n    }\n    //create output header\n    if (!(out_samhdr = sam_hdr_init()))\n    {\n        fprintf(stderr, \"Failed to create output header!\\n\");\n        goto error;\n    }\n\n    //add version to output header\n    if  (-1 == sam_hdr_add_line(out_samhdr,\"HD\", \"VN\", SAM_FORMAT_VERSION, NULL)) {\n        fprintf(stderr, \"Failed to set header data!\\n\");\n        goto error;\n    }\n    //add RG / PG lines if configured\n    if ((config->keepRGs && getRGlines(in_samhdr, out_samhdr)) ||\n            getPGlines(in_samhdr, out_samhdr, config, args)) {\n        goto error;\n    }\n\n    //write output header\n    if (sam_hdr_write(outfile, out_samhdr)) {\n        print_error_errno(\"reset\", \"Output header write failed (%d)!\\n\", errno);\n        goto error;\n    }\n\n    bamdata = bam_init1();      //input bam\n    outdata = bam_init1();      //output bam\n    if (!bamdata || !outdata)\n    {\n        fprintf(stderr, \"Failed to allocate data memory!\\n\");\n        goto error;\n    }\n\n    errno = 0; i = 0;\n    sp = NULL; qp = NULL;\n    bamquery = NULL; bamqual = NULL;\n\n    //get bam data, make updates and dump to output\n    while (0 <= (ret_r = sam_read1(infile, in_samhdr, bamdata)))\n    {\n        sp = NULL; qp = NULL;\n        bamquery = NULL; bamqual = NULL;\n\n        // read data\n        if (bamdata->core.flag & BAM_FSECONDARY || bamdata->core.flag & BAM_FSUPPLEMENTARY) {\n            continue;\n        }\n        //update flags\n        uint16_t flags = bamdata->core.flag & ~BAM_FPROPER_PAIR;    //reset pair info\n        flags |= BAM_FUNMAP;                                        //mark as unmapped\n        if (bamdata->core.flag & BAM_FPAIRED) {\n            flags |= BAM_FMUNMAP;                                   //mark mate as unmapped, if it was a pair\n        }\n        flags &= ~BAM_FMREVERSE;                                    //reset mate orientation\n        if (!(config->ctrlFlags & RESET_KEEPDUPFLAG)) {\n            flags &= ~BAM_FDUP;                                     //reset dup flag from alignment\n        }\n\n        if (0 > ks_resize(&querydata, bamdata->core.l_qseq) ||\n            0 > ks_resize(&qualdata, bamdata->core.l_qseq)) {\n            fprintf(stderr, \"Failed to get allocate memory!\\n\");\n            ret_r = -4;\n            break;\n        }\n        ks_clear(&querydata);\n        ks_clear(&qualdata);\n\n        sp = ks_str(&querydata);\n        qp = ks_str(&qualdata);\n        bamquery = bam_get_seq(bamdata);\n        bamqual = bam_get_qual(bamdata);\n        if (bamdata->core.flag & BAM_FREVERSE) {\n            //sequence data ordered as reverse complemented, reorder/complement sequence and quality data as read and clear the flag\n            for (i = bamdata->core.l_qseq - 1; i >= 0; --i) {\n                *sp++ = \"=TGKCYSBAWRDMHVN\"[bam_seqi(bamquery, i)];\n                *qp++ = bamqual[i];\n            }\n            flags &= ~BAM_FREVERSE;                                 //reset flag as well\n        }\n        else {\n            //data in read order itself\n            for (i = 0; i < bamdata->core.l_qseq ; ++i) {\n                *sp++ = seq_nt16_str[bam_seqi(bamquery, i)];\n            }\n            memcpy(qp, bam_get_qual(bamdata), bamdata->core.l_qseq);\n        }\n\n        removeauxtags(bamdata, config);\n        if (0 > (ret_w = bam_set1(outdata, bamdata->core.l_qname - bamdata->core.l_extranul - 1, bam_get_qname(bamdata), flags, -1, -1, 0, 0, NULL, -1, -1, 0, bamdata->core.l_qseq, querydata.s, qualdata.s, bam_get_l_aux(bamdata)))) {\n            print_error_errno(\"reset\", \"Failed to set output data (%d)!\\n\", errno);\n            break;\n        }\n\n        memcpy(bam_get_aux(outdata), bam_get_aux(bamdata), bam_get_l_aux(bamdata));\n        outdata->l_data += bam_get_l_aux(bamdata);\n\n        errno = 0;\n        //write bam data to output\n        if (0 > (ret_w = sam_write1(outfile, out_samhdr, outdata)))\n        {\n            print_error_errno(\"reset\", \"Failed to write output data (%d)!\\n\", errno);\n            break;\n        }\n        // wrote the data, continue read/write cycle\n        errno = 0;\n    }\n\n    if (-1 > ret_r || 0 > ret_w) {\n        //some error\n        fprintf(stderr, \"Error during %s!\\n\", (-1 > ret_r)? \"read\" : \"write\");\n    }\n    else {\n        // no error!\n        ret = EXIT_SUCCESS;\n    }\n\nerror:\n    // clean up and return result\n    if (in_samhdr)\n        sam_hdr_destroy(in_samhdr);\n    if (out_samhdr)\n        sam_hdr_destroy(out_samhdr);\n\n    if (bamdata)\n        bam_destroy1(bamdata);\n    if (outdata)\n        bam_destroy1(outdata);\n\n    if (qualdata.s)\n        ks_free(&qualdata);\n    if (querydata.s)\n        ks_free(&querydata);\n    return ret;\n}\n\n/// cleanup - free up allocations made\n/** @param config - pointer to internal configuration data\nreturns nothing\n*/\nvoid cleanup(conf_data *config)\n{\n    if (config->aux_keep) {\n        kh_destroy(aux_exists, config->aux_keep);\n        config->aux_keep = NULL;\n    }\n    if (config->aux_remove) {\n        kh_destroy(aux_exists, config->aux_remove);\n        config->aux_remove = NULL;\n    }\n}\n\n/// main_reset - starts the reset of data\n/** @param argc - count of arguments\n *  @param argv - pointer to array of arguments\nreturns 1 on failure 0 on success\n*/\nint main_reset(int argc, char *argv[])\n{\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', '-', 'O', '-', '-', '@'),       //let output format and thread count be given by user - long options\n        {\"keep-tag\", required_argument, NULL, LONG_OPT('x')},       //aux tags to be retained, supports ^ STR\n        {\"remove-tag\", required_argument, NULL, 'x'},               //aux tags to be removed\n        {\"no-RG\", no_argument, NULL, 1},                            //no RG lines in output, default is to keep them\n        //reject PG lines from input, default is to keep them (i.e. option not given); without optional filename, all PGs removed and those given in file are filtered when optional filename is given\n        {\"reject-PG\", required_argument, NULL, 'p'},                //reject entries from this PG onwards\n        {\"no-PG\", no_argument, NULL, 2},                            //do not add PG entry for reset operation, default is to add it\n        {\"dupflag\", no_argument, NULL, 3},                          //keep the dup flag as it is - as in initial reset implementation\n        {NULL, 0, NULL, 0}\n    };\n    samFile *infile = NULL, *outfile = NULL;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    htsThreadPool tpool = {NULL, 0};\n    const char *inname = NULL, *outname = NULL;\n    int c = 0, ret = EXIT_FAILURE;\n    char outmode[4] = \"w\", *args = NULL;\n    conf_data resetconf = {1, 0, 0, NULL, NULL, NULL};              //keep RGs and PGs by default, ctrlflags = 0\n\n    //samtools reset -o outfile -x/--remove-tag ... --keep-tag ... --threads=n --output-fmt=fmt --no-RG --reject-PG pgid --no-PG [<infile>]\n    while ((c = getopt_long(argc, argv, \"o:@:x:O:\", lopts, NULL)) >= 0)\n    {\n        switch (c)\n        {\n        case 1:                             //--no-RG\n            if (!resetconf.keepRGs) {\n                usage(stderr);              //already given!\n                goto exit;\n            }\n            resetconf.keepRGs = 0;\n            break;\n        case 2:                             //--no-PG\n            if (resetconf.noPGentry) {\n                usage(stderr);              //already given!\n                goto exit;\n            }\n            resetconf.noPGentry = 1;\n            break;\n        case 3:                             //keep dup flag as it is / no reset\n            resetconf.ctrlFlags |= RESET_KEEPDUPFLAG;\n            break;\n        case 'p':                           //--reject-PG=<id>\n            if (resetconf.pgid) {\n                usage(stderr);              //already given!\n                goto exit;\n            }\n            resetconf.pgid = optarg;\n            break;\n        case 'o':                           //output file name\n            if (outname) {                  //already given!\n                usage(stderr);\n                goto exit;\n\n            }\n            outname = optarg;\n            break;\n        case 'x':                           //remove aux tag\n            if (*optarg == '^') {           //remove all except given ones!\n                if (parse_aux_list(&resetconf.aux_keep, optarg+1, \"main_reset\")) {\n                    usage(stderr);\n                    goto exit;\n                }\n            }\n            else {                          //remove given ones\n                if (parse_aux_list(&resetconf.aux_remove, optarg, \"main_reset\")) {\n                    usage(stderr);\n                    goto exit;\n                }\n            }\n            break;\n        case LONG_OPT('x'):                 //keep aux tags\n            if (parse_aux_list(&resetconf.aux_keep, optarg, \"main_reset\")) {\n                usage(stderr);\n                goto exit;\n            }\n            break;\n        // handle standard samtool options like thread count, verbosity...\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0)\n                break;\n            // else fall-through\n            // couldn't parse or unknown options, show usage!\n        case '?':                           //unknown options found!\n            usage(stderr);\n            goto exit;\n            break;\n        }\n    }\n\n    if (argc == 1 && isatty(STDIN_FILENO)) {\n        //no args and input is stdin -- it is the usage check\n        usage(stdout);\n        ret = EXIT_SUCCESS;\n        goto exit;\n    }\n    //else have other args or input from redirection/pipe/other device -- validate and work\n\n    if (!outname)\n        outname = \"-\";\n\n    //check and fail if unnecessary parameters are given\n    c = argc - optind;\n    if (c > 1) {\n        usage(stderr);\n        goto exit;\n    }\n\n    if (c == 1) {\n        inname = argv[optind];\n    }\n    else {\n        inname = \"-\";\n    }\n\n    //update aux tag configuration\n    update_aux_conf(&resetconf);\n    //set output file format based on name\n    sam_open_mode(outmode + 1, outname, NULL);\n\n    //open input and output files\n    infile = sam_open(inname, \"r\");\n    outfile = sam_open_format(outname, outmode, &ga.out);\n    if (!infile || !outfile) {\n        fprintf(stderr, \"Could not open %s%s%s\\n\", !infile ? inname : \"\", (!infile && !outfile)? \", \" : \"\", !outfile ? outname : \"\");\n        goto exit;\n    }\n\n    // set the thread count if given as argument\n    if (ga.nthreads > 0)\n    {\n        if (!(tpool.pool = hts_tpool_init(ga.nthreads)))\n        {\n            fprintf(stderr, \"\\nFailed to setup thread pool\\n\");\n            goto exit;\n        }\n\n        hts_set_opt(infile, HTS_OPT_THREAD_POOL, &tpool);\n        hts_set_opt(outfile, HTS_OPT_THREAD_POOL, &tpool);\n    }\n\n    args = stringify_argv(argc + 1, argv - 1);              //to dump invocation in PG line\n\n    //do the reset!\n    ret = reset(infile, outfile, &resetconf, args);\n\nexit:\n    if (args)\n        free(args);\n    if (infile)\n        sam_close(infile);\n    if (outfile)\n        sam_close(outfile);\n    if (tpool.pool)\n        hts_tpool_destroy(tpool.pool);\n    cleanup(&resetconf);\n    sam_global_args_free(&ga);\n\n    return ret;\n}\n"
        },
        {
          "name": "sam_opts.c",
          "type": "blob",
          "size": 6.8447265625,
          "content": "/*  sam_opts.c -- utilities to aid parsing common command line options.\n\n    Copyright (C) 2015, 2019 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"sam_opts.h\"\n\n/*\n * Processes a standard \"global\" samtools long option.\n *\n * The 'c' value is the return value from a getopt_long() call.  It is checked\n * against the lopt[] array to find the corresponding value as this may have\n * been reassigned by the individual subcommand.\n *\n * Having found the entry, the corresponding long form is used to apply the\n * option, storing the setting in sam_global_args *ga.\n *\n * Returns 0 on success,\n *        -1 on failure.\n */\nint parse_sam_global_opt(int c, const char *optarg, const struct option *lopt,\n                         sam_global_args *ga) {\n    int r = 0;\n\n    while (lopt->name) {\n        if (c != lopt->val) {\n            lopt++;\n            continue;\n        }\n\n        if (strcmp(lopt->name, \"input-fmt\") == 0) {\n            r = hts_parse_format(&ga->in, optarg);\n            break;\n        } else if (strcmp(lopt->name, \"input-fmt-option\") == 0) {\n            r = hts_opt_add((hts_opt **)&ga->in.specific, optarg);\n            break;\n        } else if (strcmp(lopt->name, \"output-fmt\") == 0) {\n            r = hts_parse_format(&ga->out, optarg);\n            break;\n        } else if (strcmp(lopt->name, \"output-fmt-option\") == 0) {\n            r = hts_opt_add((hts_opt **)&ga->out.specific, optarg);\n            break;\n        } else if (strcmp(lopt->name, \"reference\") == 0) {\n            char *ref = malloc(10 + strlen(optarg) + 1);\n\n            if (!ref) {\n                fprintf(stderr, \"Unable to allocate memory in \"\n                                \"parse_sam_global_opt.\\n\");\n\n                return -1;\n            }\n\n            sprintf(ref, \"reference=%s\", optarg);\n\n            if (!(ga->reference = strdup(optarg))) {\n                fprintf(stderr, \"Unable to allocate memory in \"\n                                \"parse_sam_global_opt.\\n\");\n\n                return -1;\n            }\n\n            r  = hts_opt_add((hts_opt **)&ga->in.specific, ref);\n            r |= hts_opt_add((hts_opt **)&ga->out.specific, ref);\n            free(ref);\n            break;\n        } else if (strcmp(lopt->name, \"threads\") == 0) {\n            ga->nthreads = atoi(optarg);\n            break;\n        } else if (strcmp(lopt->name, \"write-index\") == 0) {\n            ga->write_index = 1;\n            break;\n        } else if (strcmp(lopt->name, \"verbosity\") == 0) {\n            hts_verbose = atoi(optarg);\n            break;\n        }\n    }\n\n    if (!lopt->name) {\n        fprintf(stderr, \"Unexpected global option.\\n\");\n        return -1;\n    }\n\n    /*\n     * SAM format with compression enabled implies SAM.bgzf\n     */\n    if (ga->out.format == sam) {\n        hts_opt *opts = (hts_opt *)ga->out.specific;\n        while (opts) {\n            if (opts->opt == HTS_OPT_COMPRESSION_LEVEL)\n                ga->out.compression = bgzf;\n            opts = opts->next;\n        }\n    }\n\n    return r;\n}\n\n/*\n * Report the usage for global options.\n *\n * This accepts a string with one character per SAM_OPT_GLOBAL_OPTIONS option\n * to determine which options need to be printed and how.\n * Each character should be one of:\n * '.'    No short option has been assigned. Use --long-opt only.\n * '-'    The long (and short) option has been disabled.\n * <c>    Otherwise the short option is character <c>.\n */\nvoid sam_global_opt_help(FILE *fp, const char *shortopts) {\n    int i = 0;\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS(0,0,0,0,0,0),\n        { NULL, 0, NULL, 0 }\n    };\n\n    for (i = 0; shortopts && shortopts[i] && lopts[i].name; i++) {\n        if (shortopts[i] == '-')\n            continue;\n\n        if (shortopts[i] == '.')\n            fprintf(fp, \"      --\");\n        else\n            fprintf(fp, \"  -%c, --\", shortopts[i]);\n\n        if (strcmp(lopts[i].name, \"input-fmt\") == 0)\n            fprintf(fp,\"input-fmt FORMAT[,OPT[=VAL]]...\\n\"\n                    \"               Specify input format (SAM, BAM, CRAM)\\n\");\n        else if (strcmp(lopts[i].name, \"input-fmt-option\") == 0)\n            fprintf(fp,\"input-fmt-option OPT[=VAL]\\n\"\n                    \"               Specify a single input file format option in the form\\n\"\n                    \"               of OPTION or OPTION=VALUE\\n\");\n        else if (strcmp(lopts[i].name, \"output-fmt\") == 0)\n            fprintf(fp,\"output-fmt FORMAT[,OPT[=VAL]]...\\n\"\n                    \"               Specify output format (SAM, BAM, CRAM)\\n\");\n        else if (strcmp(lopts[i].name, \"output-fmt-option\") == 0)\n            fprintf(fp,\"output-fmt-option OPT[=VAL]\\n\"\n                    \"               Specify a single output file format option in the form\\n\"\n                    \"               of OPTION or OPTION=VALUE\\n\");\n        else if (strcmp(lopts[i].name, \"reference\") == 0)\n            fprintf(fp,\"reference FILE\\n\"\n                    \"               Reference sequence FASTA FILE [null]\\n\");\n        else if (strcmp(lopts[i].name, \"threads\") == 0)\n            fprintf(fp,\"threads INT\\n\"\n                    \"               Number of additional threads to use [0]\\n\");\n        else if (strcmp(lopts[i].name, \"write-index\") == 0)\n            fprintf(fp,\"write-index\\n\"\n                    \"               Automatically index the output files [off]\\n\");\n        else if (strcmp(lopts[i].name, \"verbosity\") == 0)\n            fprintf(fp,\"verbosity INT\\n\"\n                    \"               Set level of verbosity\\n\");\n    }\n}\n\nvoid sam_global_args_init(sam_global_args *ga) {\n    if (!ga)\n        return;\n\n    memset(ga, 0, sizeof(*ga));\n}\n\nvoid sam_global_args_free(sam_global_args *ga) {\n    if (ga->in.specific)\n        hts_opt_free(ga->in.specific);\n\n    if (ga->out.specific)\n        hts_opt_free(ga->out.specific);\n\n    if (ga->reference)\n        free(ga->reference);\n}\n"
        },
        {
          "name": "sam_opts.h",
          "type": "blob",
          "size": 4.025390625,
          "content": "/*  sam_opts.h -- utilities to aid parsing common command line options.\n\n    Copyright (C) 2015, 2019 Genome Research Ltd.\n\n    Author: James Bonfield <jkb@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef SAM_OPTS_H\n#define SAM_OPTS_H\n\n#include <stdio.h>\n#include <limits.h>\n#include <getopt.h>\n#include <htslib/hts.h>\n\ntypedef struct sam_global_args {\n    htsFormat in;\n    htsFormat out;\n    char *reference;\n    int nthreads;\n    int write_index;\n} sam_global_args;\n\n#define SAM_GLOBAL_ARGS_INIT {{0},{0}}\n\nenum {\n    SAM_OPT_INPUT_FMT = CHAR_MAX+1,\n    SAM_OPT_INPUT_FMT_OPTION,\n    SAM_OPT_OUTPUT_FMT,\n    SAM_OPT_OUTPUT_FMT_OPTION,\n    SAM_OPT_REFERENCE,\n    SAM_OPT_NTHREADS,\n    SAM_OPT_WRITE_INDEX,\n    SAM_OPT_VERBOSITY,\n};\n\n#define SAM_OPT_VAL(val, defval) ((val) == '-')? '?' : (val)? (val) : (defval)\n\n// Use this within struct option lopts[] = {...} to add the standard global\n// options.  The arguments determine whether the corresponding option is\n// enabled and, if so, whether it has a short option equivalent:\n// 0      No short option has been assigned. Use --long-opt only.\n// '-'    Both long and short options are disabled.\n// <c>    Otherwise the equivalent short option is character <c>.\n#define SAM_OPT_GLOBAL_OPTIONS(o1, o2, o3, o4, o5, o6) \\\n    {\"input-fmt\",         required_argument, NULL, SAM_OPT_VAL(o1, SAM_OPT_INPUT_FMT)}, \\\n    {\"input-fmt-option\",  required_argument, NULL, SAM_OPT_VAL(o2, SAM_OPT_INPUT_FMT_OPTION)}, \\\n    {\"output-fmt\",        required_argument, NULL, SAM_OPT_VAL(o3, SAM_OPT_OUTPUT_FMT)}, \\\n    {\"output-fmt-option\", required_argument, NULL, SAM_OPT_VAL(o4, SAM_OPT_OUTPUT_FMT_OPTION)}, \\\n    {\"reference\",         required_argument, NULL, SAM_OPT_VAL(o5, SAM_OPT_REFERENCE)}, \\\n    {\"threads\",           required_argument, NULL, SAM_OPT_VAL(o6, SAM_OPT_NTHREADS)}, \\\n    {\"write-index\",       no_argument,       NULL, SAM_OPT_WRITE_INDEX}, \\\n    {\"verbosity\",         required_argument, NULL, SAM_OPT_VERBOSITY}\n\n/*\n * Processes a standard \"global\" samtools long option.\n *\n * The 'c' value is the return value from a getopt_long() call.  It is checked\n * against the lopt[] array to find the corresponding value as this may have\n * been reassigned by the individual subcommand.\n *\n * Having found the entry, the corresponding long form is used to apply the\n * option, storing the setting in sam_global_args *ga.\n *\n * Returns 0 on success,\n *        -1 on failure.\n */\nint parse_sam_global_opt(int c, const char *optarg, const struct option *lopt,\n                         sam_global_args *ga);\n\n/*\n * Report the usage for global options.\n *\n * This accepts a string with one character per SAM_OPT_GLOBAL_OPTIONS option\n * to determine which options need to be printed and how.\n * Each character should be one of:\n * '.'    No short option has been assigned. Use --long-opt only.\n * '-'    The long (and short) option has been disabled.\n * <c>    Otherwise the short option is character <c>.\n */\nvoid sam_global_opt_help(FILE *fp, const char *shortopts);\n\n\nvoid sam_global_args_init(sam_global_args *ga);\nvoid sam_global_args_free(sam_global_args *ga);\n\n#endif\n"
        },
        {
          "name": "sam_utils.c",
          "type": "blob",
          "size": 5.716796875,
          "content": "/*  sam_utils.c -- various utilities internal to samtools.\n\n    Copyright (C) 2014-2016, 2018, 2019, 2023 Genome Research Ltd.\n\n    Author: John Marshall <jm18@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n#include <stdlib.h>\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"sam_utils.h\"\n\nstatic htsFile *samtools_stdout = NULL;\n\nvoid autoflush_if_stdout(htsFile *fp, const char *fname) {\n    if (fname == NULL || strcmp(fname, \"-\") == 0) samtools_stdout = fp;\n}\n\nvoid release_autoflush(htsFile *fp) {\n    if (samtools_stdout == fp) samtools_stdout = NULL;\n}\n\nstatic void HTS_FORMAT(HTS_PRINTF_FMT, 2, 0)\nvprint_error_core(const char *subcommand, const char *format, va_list args, const char *extra)\n{\n    fflush(stdout);\n    if (samtools_stdout) hts_flush(samtools_stdout);\n\n    if (subcommand && *subcommand) fprintf(stderr, \"samtools %s: \", subcommand);\n    else fprintf(stderr, \"samtools: \");\n    vfprintf(stderr, format, args);\n    if (extra) fprintf(stderr, \": %s\\n\", extra);\n    else fprintf(stderr, \"\\n\");\n    fflush(stderr);\n}\n\nvoid print_error(const char *subcommand, const char *format, ...)\n{\n    va_list args;\n    va_start(args, format);\n    vprint_error_core(subcommand, format, args, NULL);\n    va_end(args);\n}\n\nvoid print_error_errno(const char *subcommand, const char *format, ...)\n{\n    int err = errno;\n    va_list args;\n    va_start(args, format);\n    vprint_error_core(subcommand, format, args, err? strerror(err) : NULL);\n    va_end(args);\n}\n\nvoid check_sam_close(const char *subcmd, samFile *fp, const char *fname, const char *null_fname, int *retp)\n{\n    release_autoflush(fp);\n    int r = sam_close(fp);\n    if (r >= 0) return;\n\n    // TODO Need error infrastructure so we can print a message instead of r\n    if (fname) print_error(subcmd, \"error closing \\\"%s\\\": %d\", fname, r);\n    else print_error(subcmd, \"error closing %s: %d\", null_fname, r);\n\n    *retp = EXIT_FAILURE;\n}\n\n/* Pick an index suffix based on the output file descriptor type. */\nstatic char *idx_suffix(htsFile *fp) {\n    switch (fp->format.format) {\n    case sam:\n    case bam:\n        // Tough cheese if you wanted bai!\n        // New feature => mandatory new index too, for simplicity of CLI.\n        return \"csi\";\n\n    case cram:\n        return \"crai\";\n\n    default:\n        return NULL;\n    }\n}\n\n/*\n * Utility function to add an index to a file we've opened for write.\n * NB: Call this after writing the header and before writing sequences.\n *\n * The returned index filename should be freed by the caller, but only\n * after sam_idx_save has been called.\n *\n * Returns index filename on success,\n *         NULL on failure.\n */\nchar *auto_index(htsFile *fp, const char *fn, bam_hdr_t *header) {\n    char *fn_idx;\n    int min_shift = 14; /* CSI */\n    if (!fn || !*fn || strcmp(fn, \"-\") == 0)\n        return NULL;\n\n    char *delim = strstr(fn, HTS_IDX_DELIM);\n    if (delim != NULL) {\n        delim += strlen(HTS_IDX_DELIM);\n\n        fn_idx = strdup(delim);\n        if (!fn_idx)\n            return NULL;\n\n        size_t l = strlen(fn_idx);\n        if (l >= 4 && strcmp(fn_idx + l - 4, \".bai\") == 0)\n            min_shift = 0;\n    } else {\n        char *suffix = idx_suffix(fp);\n        if (!suffix)\n            return NULL;\n\n        fn_idx = malloc(strlen(fn)+6);\n        if (!fn_idx)\n            return NULL;\n\n        sprintf(fn_idx, \"%s.%s\", fn, suffix);\n    }\n\n    if (sam_idx_init(fp, header, min_shift, fn_idx) < 0) {\n        print_error_errno(\"auto_index\", \"failed to open index \\\"%s\\\" for writing\", fn_idx);\n        free(fn_idx);\n        return NULL;\n    }\n\n    return fn_idx;\n}\n\n\n/// parse_aux_list - parses given string for aux tags which are ',' separated\n/** @param h - pointer to a SET holding aux tags\n * @param optarg - string having the ',' separated aux tags\n * @param msgheader - string to be used during error output as a header\nreturns -1 on failure and 0 on success\nmoved from sam_view.c to here for common usage at different source files\n*/\nint parse_aux_list(auxhash_t *h, char *optarg, const char *msgheader)\n{\n    if (!*h)\n        *h = kh_init(aux_exists);\n\n    while (strlen(optarg) >= 2) {\n        int x = optarg[0]<<8 | optarg[1];\n        int ret = 0;\n        kh_put(aux_exists, *h, x, &ret);\n        if (ret < 0) {\n            kh_destroy(aux_exists, *h);\n            *h = NULL;\n            return -1;\n        }\n\n        optarg += 2;\n        if (*optarg == ',') // allow white-space too for easy `cat file`?\n            optarg++;\n        else if (*optarg != 0)\n            break;\n    }\n\n    if (strlen(optarg) != 0) {\n        fprintf(stderr, \"%s: Error parsing option, \"\n                \"auxiliary tags should be exactly two characters long.\\n\", msgheader ? msgheader : \"\");\n        kh_destroy(aux_exists, *h);\n        *h = NULL;\n        return -1;\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "sam_utils.h",
          "type": "blob",
          "size": 3.271484375,
          "content": "/*  sam_utils.c -- to hold utility functions and types\n\n    Copyright (C) 2023 Genome Research Ltd.\n\n    Author: Vasudeva Sarma <vasudeva.sarma@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef SAM_UTIL_H\n#define SAM_UTIL_H\n\n#include \"htslib/khash.h\"\n#include \"htslib/sam.h\"\n\n//this file may contain any utility functions and data types to be shared across\n\n/*below parse_aux_list and aux_exists are moved from sam_view.c to here for common\n *usage at different source files\n */\n\nKHASH_SET_INIT_INT(aux_exists)                      //SET data type to hold aux tags\ntypedef khash_t(aux_exists) *auxhash_t;\n\n/// parse_aux_list - parses given string for aux tags which are ',' separated\n/** @param h - pointer to a SET holding aux tags\n * @param optarg - string having the ',' separated aux tags\n * @param msgheader - string to be used during error output as a header\nreturns -1 on failure and 0 on success\nmoved from sam_view.c to here for common usage at different source files\n*/\nint parse_aux_list(auxhash_t *h, char *optarg, const char *msgheader);\n\n\n// below utility function declarations moved from samtools.h to here and this header is included in samtools.h\n\n#define CHECK_PRINTF(fmt,args) HTS_FORMAT(HTS_PRINTF_FMT, (fmt), (args))\n\nvoid print_error(const char *subcommand, const char *format, ...) CHECK_PRINTF(2, 3);\nvoid print_error_errno(const char *subcommand, const char *format, ...) CHECK_PRINTF(2, 3);\n\nvoid check_sam_close(const char *subcmd, samFile *fp, const char *fname, const char *null_fname, int *retp);\n\n/* Utility functions to register an output htsFile/samFile/vcfFile that\n * might be stdout. If FNAME is \"-\" or NULL, records FP so that print_error()\n * et al can automatically flush it before printing an error message.\n */\nvoid autoflush_if_stdout(htsFile *fp, const char *fname);\n\n/* Call this before closing FP; check_sam_close() does this automatically.\n */\nvoid release_autoflush(htsFile *fp);\n\n/*\n * Utility function to add an index to a file we've opened for write.\n * NB: Call this after writing the header and before writing sequences.\n *\n * The returned index filename should be freed by the caller, but only\n * after sam_idx_save has been called.\n *\n * Returns index filename on success,\n *         NULL on failure.\n */\nchar *auto_index(htsFile *fp, const char *fn, bam_hdr_t *header);\n\n#endif  //SAM_UTIL_H\n\n\n"
        },
        {
          "name": "sam_view.c",
          "type": "blob",
          "size": 63.419921875,
          "content": "/*  sam_view.c -- SAM<->BAM<->CRAM conversion.\n\n    Copyright (C) 2009-2024 Genome Research Ltd.\n    Portions copyright (C) 2009, 2011, 2012 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notices and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <math.h>\n#include <inttypes.h>\n#include <getopt.h>\n#include \"htslib/sam.h\"\n#include \"htslib/faidx.h\"\n#include \"htslib/khash.h\"\n#include \"htslib/kstring.h\"\n#include \"htslib/hfile.h\"\n#include \"htslib/thread_pool.h\"\n#include \"htslib/hts_expr.h\"\n#include \"samtools.h\"\n#include \"sam_opts.h\"\n#include \"bam.h\" // for bam_get_library and bam_remove_B\n#include \"bedidx.h\"\n#include \"sam_utils.h\"\n\nKHASH_SET_INIT_STR(str)\ntypedef khash_t(str) *strhash_t;\n\n// This structure contains the settings for a samview run\ntypedef struct samview_settings {\n    strhash_t rghash;\n    strhash_t rnhash;\n    strhash_t tvhash;\n    int min_mapQ;\n    int rghash_discard; // 0 keep, 1 discard\n    int rnhash_discard; // 0 keep, 1 discard\n\n    // Described here in the same terms as the usage statement.\n    // The code however always negates to \"reject if\"         keep if:\n    int flag_on;     // keep   if (FLAG & N) == N             (all on)\n    int flag_off;    // keep   if (FLAG & N) == 0             (all off)\n    int flag_anyon;  // keep   if (FLAG & N) != 0             (any on)\n    int flag_alloff; // reject if (FLAG & N) == N             (any off)\n\n    int min_qlen;\n    int remove_B;\n    uint32_t subsam_seed;\n    double subsam_frac;\n    char* library;\n    void* bed;\n    size_t remove_aux_len;\n    char** remove_aux;\n    int multi_region;\n    char* tag;\n    hts_filter_t *filter;\n    int remove_flag;\n    int add_flag;\n    int unmap;\n    auxhash_t remove_tag;\n    auxhash_t keep_tag;\n\n    hts_idx_t *hts_idx;\n    sam_hdr_t *header;\n    samFile *in, *out, *un_out;\n    int64_t count;\n    int64_t processed;\n    int is_count;\n    char *fn_in, *fn_idx_in, *fn_out, *fn_fai, *fn_un_out, *fn_out_idx, *fn_un_out_idx;\n    char *fn_counts;\n    int fetch_pairs, nreglist;\n    hts_reglist_t *reglist;\n    int sanitize;\n    int count_rf; // CRAM_OPT_REQUIRED_FIELDS for view -c\n} samview_settings_t;\n\n// Copied from htslib/sam.c.\n// TODO: we need a proper interface to find the length of an aux tag,\n// or at the very make exportable versions of these in htslib.\nstatic inline int aux_type2size(uint8_t type)\n{\n    switch (type) {\n    case 'A': case 'c': case 'C':\n        return 1;\n    case 's': case 'S':\n        return 2;\n    case 'i': case 'I': case 'f':\n        return 4;\n    case 'd':\n        return 8;\n    case 'Z': case 'H': case 'B':\n        return type;\n    default:\n        return 0;\n    }\n}\n\n// Copied from htslib/sam.c.\nstatic inline uint8_t *skip_aux(uint8_t *s, uint8_t *end)\n{\n    int size;\n    uint32_t n;\n    if (s >= end) return end;\n    size = aux_type2size(*s); ++s; // skip type\n    switch (size) {\n    case 'Z':\n    case 'H':\n        while (s < end && *s) ++s;\n        return s < end ? s + 1 : end;\n    case 'B':\n        if (end - s < 5) return NULL;\n        size = aux_type2size(*s); ++s;\n        n = le_to_u32(s);\n        s += 4;\n        if (size == 0 || end - s < size * n) return NULL;\n        return s + size * n;\n    case 0:\n        return NULL;\n    default:\n        if (end - s < size) return NULL;\n        return s + size;\n    }\n}\n\n// Returns 0 to indicate read should be output 1 otherwise,\n// and -1 on error.\nstatic int process_aln(const sam_hdr_t *h, bam1_t *b, samview_settings_t* settings)\n{\n    if (settings->filter) {\n        int r = sam_passes_filter(h, b, settings->filter);\n        if (r < 0)  // err\n            return -1;\n        if (r == 0) // filter-out\n            return 1;\n    }\n\n    if (settings->remove_B) bam_remove_B(b);\n    if (settings->min_qlen > 0) {\n        int k, qlen = 0;\n        uint32_t *cigar = bam_get_cigar(b);\n        for (k = 0; k < b->core.n_cigar; ++k)\n            if ((bam_cigar_type(bam_cigar_op(cigar[k]))&1) || bam_cigar_op(cigar[k]) == BAM_CHARD_CLIP)\n                qlen += bam_cigar_oplen(cigar[k]);\n        if (qlen < settings->min_qlen) return 1;\n    }\n    if (b->core.qual < settings->min_mapQ || ((b->core.flag & settings->flag_on) != settings->flag_on) || (b->core.flag & settings->flag_off))\n        return 1;\n    if (settings->flag_alloff && ((b->core.flag & settings->flag_alloff) == settings->flag_alloff))\n        return 1;\n    if (settings->flag_anyon && ((b->core.flag & settings->flag_anyon) == 0))\n        return 1;\n    if (!settings->multi_region && settings->bed && (b->core.tid < 0 || !bed_overlap(settings->bed, sam_hdr_tid2name(h, b->core.tid), b->core.pos, bam_endpos(b))))\n        return 1;\n    if (settings->subsam_frac > 0.) {\n        uint32_t k = __ac_Wang_hash(__ac_X31_hash_string(bam_get_qname(b)) ^ settings->subsam_seed);\n        if ((double)(k&0xffffff) / 0x1000000 >= settings->subsam_frac) return 1;\n    }\n    if (settings->rghash) {\n        uint8_t *s = bam_aux_get(b, \"RG\");\n        if (s) {\n            khint_t k = kh_get(str, settings->rghash, (char*)(s + 1));\n            if ((k == kh_end(settings->rghash)) != settings->rghash_discard)\n                return 1;\n        }\n    }\n    if (settings->tag) {\n        uint8_t *s = bam_aux_get(b, settings->tag);\n        if (s) {\n            if (settings->tvhash) {\n                char t[32], *val;\n                if (*s == 'i' || *s == 'I' || *s == 's' || *s == 'S' || *s == 'c' || *s == 'C') {\n                    int ret = snprintf(t, 32, \"%\"PRId64, bam_aux2i(s));\n                    if (ret > 0) val = t;\n                    else return 1;\n                } else if (*s == 'A') {\n                    t[0] = *(s+1);\n                    t[1] = 0;\n                    val = t;\n                } else {\n                    val = (char *)(s+1);\n                }\n                khint_t k = kh_get(str, settings->tvhash, val);\n                if (k == kh_end(settings->tvhash)) return 1;\n            }\n        } else {\n            return 1;\n        }\n    }\n    if (settings->rnhash) {\n        const char* rn = bam_get_qname(b);\n        strhash_t h = settings->rnhash;\n        if (!rn && !settings->rnhash_discard)\n            return 1;\n        if ((kh_get(str, h, rn) == kh_end(h)) != settings->rnhash_discard)\n            return 1;\n    }\n    if (settings->library) {\n        const char *p = bam_get_library((sam_hdr_t*)h, b);\n        if (!p || strcmp(p, settings->library) != 0) return 1;\n    }\n    return 0;\n}\n\nstatic int adjust_tags(const sam_hdr_t *h, bam1_t *b,\n                       samview_settings_t* settings) {\n    if (settings->keep_tag) {\n        uint8_t *s_from, *s_to, *end = b->data + b->l_data;\n        auxhash_t h = settings->keep_tag;\n\n        s_from = s_to = bam_get_aux(b);\n        while (s_from < end) {\n            int x = (int)s_from[0]<<8 | s_from[1];\n            uint8_t *s = skip_aux(s_from+2, end);\n            if (s == NULL) {\n                print_error(\"view\", \"malformed aux data for record \\\"%s\\\"\",\n                            bam_get_qname(b));\n                return -1;\n            }\n\n            if (kh_get(aux_exists, h, x) != kh_end(h) ) {\n                if (s_to != s_from) memmove(s_to, s_from, s - s_from);\n                s_to += s - s_from;\n            }\n            s_from = s;\n        }\n        b->l_data = s_to - b->data;\n\n    } else if (settings->remove_tag) {\n        uint8_t *s_from, *s_to, *end = b->data + b->l_data;\n        auxhash_t h = settings->remove_tag;\n\n        s_from = s_to = bam_get_aux(b);\n        while (s_from < end) {\n            int x = (int)s_from[0]<<8 | s_from[1];\n            uint8_t *s = skip_aux(s_from+2, end);\n            if (s == NULL) {\n                print_error(\"view\", \"malformed aux data for record \\\"%s\\\"\",\n                            bam_get_qname(b));\n                return -1;\n            }\n\n            if (kh_get(aux_exists, h, x) == kh_end(h) ) {\n                if (s_to != s_from) memmove(s_to, s_from, s - s_from);\n                s_to += s - s_from;\n            }\n            s_from = s;\n        }\n        b->l_data = s_to - b->data;\n    }\n\n    return 0;\n}\n\nstatic int usage(FILE *fp, int exit_status, int is_long_help);\n\nstatic int populate_lookup_from_file(const char *subcmd, strhash_t lookup, char *fn)\n{\n    FILE *fp;\n    char buf[1024];\n    int ret = 0;\n    fp = fopen(fn, \"r\");\n    if (fp == NULL) {\n        print_error_errno(subcmd, \"failed to open \\\"%s\\\" for reading\", fn);\n        return -1;\n    }\n\n    while (ret != -1 && !feof(fp) && fscanf(fp, \"%1023s\", buf) > 0) {\n        char *d = strdup(buf);\n        if (d != NULL) {\n            kh_put(str, lookup, d, &ret);\n            if (ret == 0) free(d); /* Duplicate */\n        } else {\n            ret = -1;\n        }\n    }\n    if (ferror(fp)) ret = -1;\n    if (ret == -1) {\n        print_error_errno(subcmd, \"failed to read \\\"%s\\\"\", fn);\n    }\n    fclose(fp);\n    return (ret != -1) ? 0 : -1;\n}\n\nstatic int add_read_group_single(const char *subcmd, samview_settings_t *settings, char *name)\n{\n    char *d = strdup(name);\n    int ret = 0;\n\n    if (d == NULL) goto err;\n\n    if (settings->rghash == NULL) {\n        settings->rghash = kh_init(str);\n        if (settings->rghash == NULL) goto err;\n    } else if (settings->rghash_discard == 1) {\n        print_error(\"view\", \"cannot mix include and exclude read-group files in the same command line\");\n        free(d);\n        return -1;\n    }\n    settings->rghash_discard = 0;\n\n    kh_put(str, settings->rghash, d, &ret);\n    if (ret == -1) goto err;\n    if (ret ==  0) free(d); /* Duplicate */\n    return 0;\n\n err:\n    print_error(subcmd, \"Couldn't add \\\"%s\\\" to read group list: memory exhausted?\", name);\n    free(d);\n    return -1;\n}\n\nstatic int add_read_names_file(const char *subcmd, samview_settings_t *settings, char *fn)\n{\n    if (settings->rnhash == NULL) {\n        settings->rnhash = kh_init(str);\n        if (settings->rnhash == NULL) {\n            perror(NULL);\n            return -1;\n        }\n    } else if ((settings->rnhash_discard == 0 && *fn == '^') ||\n        (settings->rnhash_discard == 1 && *fn != '^')) {\n        print_error(\"view\", \"cannot mix include and exclude read-name files in the same command line\");\n        return -1;\n    }\n    settings->rnhash_discard = (*fn == '^');\n    return populate_lookup_from_file(subcmd, settings->rnhash,\n                                     fn + (*fn == '^'));\n}\n\nstatic int add_read_groups_file(const char *subcmd, samview_settings_t *settings, char *fn)\n{\n    if (settings->rghash == NULL) {\n        settings->rghash = kh_init(str);\n        if (settings->rghash == NULL) {\n            perror(NULL);\n            return -1;\n        }\n    } else if ((settings->rghash_discard == 0 && *fn == '^') ||\n        (settings->rghash_discard == 1 && *fn != '^')) {\n        print_error(\"view\", \"cannot mix include and exclude read-group files in the same command line\");\n        return -1;\n    }\n    settings->rghash_discard = (*fn == '^');\n    return populate_lookup_from_file(subcmd, settings->rghash,\n                                     fn + (*fn == '^'));\n}\n\nstatic int add_tag_value_single(const char *subcmd, samview_settings_t *settings, char *name)\n{\n    char *d = strdup(name);\n    int ret = 0;\n\n    if (d == NULL) goto err;\n\n    if (settings->tvhash == NULL) {\n        settings->tvhash = kh_init(str);\n        if (settings->tvhash == NULL) goto err;\n    }\n\n    kh_put(str, settings->tvhash, d, &ret);\n    if (ret == -1) goto err;\n    if (ret ==  0) free(d); /* Duplicate */\n    return 0;\n\n err:\n    print_error(subcmd, \"Couldn't add \\\"%s\\\" to tag values list: memory exhausted?\", name);\n    free(d);\n    return -1;\n}\n\nstatic int add_tag_values_file(const char *subcmd, samview_settings_t *settings, char *fn)\n{\n    if (settings->tvhash == NULL) {\n        settings->tvhash = kh_init(str);\n        if (settings->tvhash == NULL) {\n            perror(NULL);\n            return -1;\n        }\n    }\n    return populate_lookup_from_file(subcmd, settings->tvhash, fn);\n}\n\nstatic inline int check_sam_write1(samFile *fp, const sam_hdr_t *h, const bam1_t *b, const char *fname, int *retp)\n{\n    int r = sam_write1(fp, h, b);\n    if (r >= 0) return r;\n\n    if (fname) print_error_errno(\"view\", \"writing to \\\"%s\\\" failed\", fname);\n    else print_error_errno(\"view\", \"writing to standard output failed\");\n\n    *retp = EXIT_FAILURE;\n    return r;\n}\n\nstatic inline void change_flag(bam1_t *b, samview_settings_t *settings)\n{\n    if (settings->add_flag)\n        b->core.flag |= settings->add_flag;\n\n    if (settings->remove_flag)\n        b->core.flag &= ~settings->remove_flag;\n}\n\nstatic int cmp_reglist_intervals(const void *aptr, const void *bptr)\n{\n    hts_pair_pos_t *a = (hts_pair_pos_t*)aptr;\n    hts_pair_pos_t *b = (hts_pair_pos_t*)bptr;\n    if ( a->beg < b->beg ) return -1;\n    if ( a->beg > b->beg ) return 1;\n    if ( a->end < b->end ) return -1;\n    if ( a->end > b->end ) return 1;\n    return 0;\n}\nstatic int cmp_reglist_tids(const void *aptr, const void *bptr)\n{\n    hts_reglist_t *a = (hts_reglist_t*)aptr;\n    hts_reglist_t *b = (hts_reglist_t*)bptr;\n    if ( b->tid==HTS_IDX_NOCOOR || a->tid < b->tid ) return -1;\n    if ( a->tid==HTS_IDX_NOCOOR || a->tid > b->tid ) return 1;\n    return 0;\n}\n\nstatic hts_reglist_t *_reglist_dup(sam_hdr_t *hdr, hts_reglist_t *src, int nsrc)\n{\n    int i,j;\n    hts_reglist_t *dst = (hts_reglist_t*)calloc(nsrc,sizeof(hts_reglist_t));\n    if ( !dst ) {\n        print_error_errno(\"view\", \"[%s:%d] could not allocate region list\"\n                          ,__FILE__ ,__LINE__);\n        return NULL;\n    }\n    for (i=0; i<nsrc; i++)\n    {\n        // Assume tid is not set correctly, reg is informative but may not point to a long-lived memory\n        dst[i].tid = sam_hdr_name2tid(hdr,src[i].reg);\n        dst[i].min_beg = src[i].min_beg;\n        dst[i].max_end = src[i].max_end;\n        dst[i].count = src[i].count;\n        dst[i].intervals = (hts_pair_pos_t*)malloc(sizeof(hts_pair_pos_t)*dst[i].count);\n        if ( !dst[i].intervals ) {\n            print_error_errno(\"view\", \"[%s:%d] could not allocate region list\",\n                              __FILE__, __LINE__);\n            goto fail;\n        }\n        for (j=0; j<dst[i].count; j++)\n            dst[i].intervals[j] = src[i].intervals[j];\n    }\n    qsort(dst,nsrc,sizeof(*dst),cmp_reglist_tids);\n    return dst;\n\n fail:\n    for (j = 0; j < i; j++)\n        free(dst[j].intervals);\n    free(dst);\n    return NULL;\n}\nstatic inline int _reglist_find_tid(hts_reglist_t *reg, int nreg, int tid) // binary search\n{\n    int i = -1, imin = 0, imax = nreg - 1;\n    while ( imin <= imax )\n    {\n        i = (imin+imax)/2;\n        if ( tid==HTS_IDX_NOCOOR || reg[i].tid < tid ) imin = i + 1;\n        else if ( reg[i].tid==HTS_IDX_NOCOOR || reg[i].tid > tid ) imax = i - 1;\n        else break;\n    }\n    if ( i<0 || reg[i].tid < tid ) i++;    // not found, i will be the index of the inserted element\n    return i;\n}\nstatic int _reglist_push(hts_reglist_t **_reg, int *_nreg, int tid, hts_pos_t beg, hts_pos_t end)\n{\n    hts_reglist_t *reg = *_reg;\n    int nreg = *_nreg;\n    int i = _reglist_find_tid(reg,nreg,tid);\n    if ( i>=nreg || reg[i].tid!=tid ) {\n        nreg++;\n        reg = (hts_reglist_t*)realloc(reg,sizeof(hts_reglist_t)*nreg);\n        if ( !reg ) {\n            print_error_errno(\"view\", \"[%s:%d] could not extend region list\",\n                              __FILE__, __LINE__);\n            return -1;\n        }\n        if ( i+1 < nreg )\n            memmove(reg + i + 1, reg + i, sizeof(hts_reglist_t)*(nreg - i - 1));\n        reg[i].reg = NULL;\n        reg[i].tid = tid;\n        reg[i].min_beg = beg;\n        reg[i].max_end = end;\n        reg[i].intervals = NULL;\n        reg[i].count = 0;\n    }\n    *_reg = reg;\n    *_nreg = nreg;\n    if ( reg[i].count > 0\n         && reg[i].intervals[reg[i].count - 1].beg==beg\n         && reg[i].intervals[reg[i].count - 1].end==end ) {\n        return 0;\n    }\n    hts_pair_pos_t *new_intervals = realloc(reg[i].intervals, sizeof(hts_pair_pos_t)*(reg[i].count + 1));\n    if (!new_intervals) {\n        print_error_errno(\"view\", \"[%s:%d] could not extend region list\",\n                          __FILE__, __LINE__);\n        return -1;\n    }\n    reg[i].intervals = new_intervals;\n    reg[i].intervals[reg[i].count].beg = beg;\n    reg[i].intervals[reg[i].count].end = end;\n    reg[i].count++;\n    return 0;\n}\n\nstatic void _reglist_merge(hts_reglist_t *reg, int nreg)\n{\n    int i,j;\n    for (i=0; i<nreg; i++)\n    {\n        qsort(reg[i].intervals,reg[i].count,sizeof(*reg[i].intervals),cmp_reglist_intervals);\n        int k = 1;\n        for (j=1; j<reg[i].count; j++)\n        {\n            if ( reg[i].intervals[k-1].end < reg[i].intervals[j].beg )\n            {\n                if ( k < j ) reg[i].intervals[k] = reg[i].intervals[j];\n                k++;\n                continue;\n            }\n            if ( reg[i].intervals[k-1].end < reg[i].intervals[j].end ) reg[i].intervals[k-1].end = reg[i].intervals[j].end;\n        }\n        reg[i].count = k;\n        reg[i].max_end = reg[i].intervals[k-1].end;\n    }\n}\nhts_itr_multi_t *multi_region_init(samview_settings_t *conf, char **regs, int nregs)\n{\n    hts_itr_multi_t *iter = NULL;\n    int filter_state = ALL;\n    if ( nregs ) {\n        int filter_op = 0;\n        void *bed = bed_hash_regions(conf->bed, regs, 0, nregs, &filter_op); // insert(1) or filter out(0) the regions from the command line in the same hash table as the bed file\n        if (!bed) {\n            print_error_errno(\"view\", \"Couldn't %s region list\",\n                              filter_op ? \"build\" : \"filter\");\n            return NULL;\n        }\n        conf->bed = bed;\n        if ( !filter_op )\n            filter_state = FILTERED;\n    }\n    else\n        bed_unify(conf->bed);\n\n    // This check is probably redundant, but left just in case\n    if ( !conf->bed) { // index is unavailable or no regions have been specified\n        print_error(\"view\", \"No regions or BED file have been provided. Aborting.\");\n        return NULL;\n    }\n\n    int regcount = 0;\n    hts_reglist_t *reglist = bed_reglist(conf->bed, filter_state, &regcount);\n    if (!reglist) {\n        print_error(\"view\", \"Region list is empty or could not be created. Aborting.\");\n        return NULL;\n    }\n\n    if ( conf->fetch_pairs ) {\n        conf->reglist  = _reglist_dup(conf->header,reglist,regcount);\n        if (!conf->reglist)\n            return NULL;\n        conf->nreglist = regcount;\n    }\n\n    iter = sam_itr_regions(conf->hts_idx, conf->header, reglist, regcount);\n    if ( !iter ) {\n        print_error(\"view\", \"Iterator could not be created. Aborting.\");\n        return NULL;\n    }\n    return iter;\n}\n\nKHASH_SET_INIT_STR(names)\n\nstatic int fetch_pairs_collect_mates(samview_settings_t *conf, hts_itr_multi_t *iter)\n{\n    khint_t k;\n    int nunmap = 0, r = 0, nmates = 0, write_error = 0, retval = EXIT_FAILURE;\n    kh_names_t *mate_names = kh_init(names);\n    bam1_t *rec = bam_init1();\n\n    if (!mate_names) {\n        print_error_errno(\"view\", \"could not allocate mate names table\");\n        goto out;\n    }\n    if (!rec) {\n        print_error_errno(\"view\", \"could not allocate bam record\");\n        goto out;\n    }\n\n    while ((r =sam_itr_multi_next(conf->in, iter, rec))>=0) {\n        if ( (rec->core.flag & BAM_FPAIRED) == 0 ) continue;\n        if ( rec->core.mtid>=0 && bed_overlap(conf->bed, sam_hdr_tid2name(conf->header,rec->core.mtid), rec->core.mpos, rec->core.mpos) ) continue;\n        int p = process_aln(conf->header, rec, conf);\n        if (p < 0)  goto out;\n        if (p == 1) continue;\n\n        nmates++;\n\n        k = kh_get(names,mate_names,bam_get_qname(rec));\n        if ( k == kh_end(mate_names) ) {\n            int ret = 0;\n            char *name_copy = strdup(bam_get_qname(rec));\n            if (!name_copy) {\n                print_error_errno(\"view\", \"[%s:%d] could not store sample name, %d elements\", __FILE__,__LINE__,nmates);\n                goto out;\n            }\n            kh_put(names, mate_names, name_copy, &ret);\n            if ( ret<0 ) {\n                print_error_errno(\"view\", \"[%s:%d] could not store sample name, %d elements\",__FILE__,__LINE__,nmates);\n                free(name_copy);\n                goto out;\n            }\n        }\n\n        if ( rec->core.mtid < 0 ) {\n            nunmap = 1;\n        } else {\n            if (_reglist_push(&conf->reglist, &conf->nreglist, rec->core.mtid, rec->core.mpos,rec->core.mpos+1) != 0)\n                goto out;\n        }\n    }\n\n    if (r < -1) {\n        print_error_errno(\"view\", \"error reading file \\\"%s\\\"\", conf->fn_in);\n        goto out;\n    }\n\n    _reglist_merge(conf->reglist, conf->nreglist);\n    if ( nunmap ) {\n        if (_reglist_push(&conf->reglist,&conf->nreglist,HTS_IDX_NOCOOR,0,HTS_POS_MAX) != 0)\n            goto out;\n    }\n    hts_itr_multi_destroy(iter);\n    iter = sam_itr_regions(conf->hts_idx, conf->header, conf->reglist, conf->nreglist);\n    if ( !iter ) {\n        print_error_errno(\"view\", \"[%s:%d] iterator could not be created\",__FILE__,__LINE__);\n        goto out;\n    }\n    while ((r = sam_itr_multi_next(conf->in, iter, rec))>=0) {\n        int drop = 1;\n        if (rec->core.tid >=0 &&\n            bed_overlap(conf->bed, sam_hdr_tid2name(conf->header,rec->core.tid), rec->core.pos, bam_endpos(rec))) drop = 0;\n        if ( drop ) {\n             k = kh_get(names,mate_names,bam_get_qname(rec));\n             if ( k != kh_end(mate_names) ) drop = 0;\n        }\n        if ( drop )\n            continue;\n        int p = 0;\n        conf->processed++;\n        if ((p=process_aln(conf->header, rec, conf)) == 0) {\n            if (adjust_tags(conf->header, rec, conf) != 0)\n                goto out;\n            if (check_sam_write1(conf->out, conf->header, rec, conf->fn_out,\n                                 &write_error) < 0)\n                goto out;\n            conf->count++;\n        }\n        if (p < 0)\n            goto out;\n    }\n\n    if (r < -1) {\n        print_error_errno(\"view\", \"error reading file \\\"%s\\\"\", conf->fn_in);\n        goto out;\n    }\n\n    retval = EXIT_SUCCESS;\n\n out:\n    hts_itr_multi_destroy(iter);\n    hts_idx_destroy(conf->hts_idx); // destroy the BAM index\n    conf->hts_idx = NULL;\n    if (mate_names) {\n        // free khash keys\n        for (k = 0; k < kh_end(mate_names); ++k)\n            if ( kh_exist(mate_names,k) ) free((char*)kh_key(mate_names, k));\n        kh_destroy(names,mate_names);\n    }\n    bam_destroy1(rec);\n    return retval;\n}\n\n// Common code for processing and writing a record\nstatic inline int process_one_record(samview_settings_t *conf, bam1_t *b,\n                                     int *write_error) {\n    conf->processed++;\n    if (conf->sanitize)\n        if (bam_sanitize(conf->header, b, conf->sanitize) < 0)\n            return -1;\n\n    int p;\n    if ((p = process_aln(conf->header, b, conf)) < 0) {\n        // error\n        return -1;\n    } else if (p == 0) {\n        // emit read\n        if (!conf->is_count) {\n            change_flag(b, conf);\n            if (adjust_tags(conf->header, b, conf) != 0)\n                return -1;\n            if (check_sam_write1(conf->out, conf->header,\n                                 b, conf->fn_out, write_error) < 0) {\n                return -1;\n            }\n        }\n        conf->count++;\n    } else if (conf->unmap) {\n        b->core.flag |= BAM_FUNMAP;\n        b->core.qual = 0;\n        b->core.isize = 0;\n\n        // remove CIGAR\n        if (b->core.n_cigar) {\n            memmove(bam_get_cigar(b), bam_get_seq(b),\n                    b->data + b->l_data - bam_get_seq(b));\n            b->l_data -= 4*b->core.n_cigar;\n            b->core.n_cigar = 0;\n        }\n\n        if (check_sam_write1(conf->out, conf->header,\n                             b, conf->fn_out, write_error) < 0) {\n            return -1;\n        }\n    } else {\n        if (conf->un_out) {\n            if (check_sam_write1(conf->un_out, conf->header,\n                                 b, conf->fn_un_out, write_error) < 0) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int stream_view(samview_settings_t *conf) {\n    bam1_t *b = bam_init1();\n    int write_error = 0, r, p = 0;\n    if (!b) {\n        print_error_errno(\"view\", \"could not allocate bam record\");\n        return 1;\n    }\n    errno = 0; // prevent false error messages.\n    while ((r = sam_read1(conf->in, conf->header, b)) >= 0) {\n        if ((p = process_one_record(conf, b, &write_error)) < 0) break;\n    }\n    bam_destroy1(b);\n    if (r < -1 || p < 0) {\n        print_error_errno(\"view\", \"error reading file \\\"%s\\\"\", conf->fn_in);\n        return 1;\n    }\n    return write_error;\n}\n\nstatic int multi_region_view(samview_settings_t *conf, hts_itr_multi_t *iter)\n{\n    bam1_t *b = bam_init1();\n    int write_error = 0, result;\n    if (!b) {\n        print_error_errno(\"view\", \"could not allocate bam record\");\n        return 1;\n    }\n    // fetch alignments\n    while ((result = sam_itr_multi_next(conf->in, iter, b)) >= 0) {\n        if (process_one_record(conf, b, &write_error) < 0) break;\n    }\n    bam_destroy1(b);\n\n    if (result < -1) {\n        print_error(\"view\", \"retrieval of region #%d failed\", iter->curr_tid);\n        write_error = 1;\n    }\n    hts_itr_multi_destroy(iter);\n    return write_error;\n}\n\n// Make mnemonic distinct values for longoption-only options\n#define LONGOPT(c)  ((c) + 128)\n\n// Check for \".sam\" filenames as sam_open_mode cannot distinguish between\n// foo.sam and foo.unknown, both getting mode \"\".\nstatic int is_sam(const char *fn) {\n    if (!fn)\n        return 0;\n    size_t l = strlen(fn);\n    return (l >= 4 && strcasecmp(fn + l-4, \".sam\") == 0);\n}\n\nstatic void aux_list_free(samview_settings_t *settings) {\n    if (settings->keep_tag)\n        kh_destroy(aux_exists, settings->keep_tag);\n    if (settings->remove_tag)\n        kh_destroy(aux_exists, settings->remove_tag);\n}\n\nstatic int write_counts_to_file(samview_settings_t *settings) {\n    kstring_t text = KS_INITIALIZE;\n    hFILE *outfile = NULL;\n    int ret = -1;\n    int r = ksprintf(&text,\n                     \"{\\n\"\n                     \"    \\\"records_processed\\\" : %\"PRId64\",\\n\"\n                     \"    \\\"records_filter_accepted\\\" : %\"PRId64\",\\n\"\n                     \"    \\\"records_filter_rejected\\\" : %\"PRId64\"\\n\"\n                     \"}\\n\",\n                     settings->processed, settings->count,\n                     settings->processed - settings->count);\n    if (r < 0) {\n        print_error_errno(\"view\", \"failed to make read counts text\");\n        goto out;\n    }\n    outfile = hopen(settings->fn_counts, \"w\");\n    if (!outfile) {\n        print_error_errno(\"view\", \"failed to open \\\"%s\\\"\", settings->fn_counts);\n        goto out;\n    }\n    if (hwrite(outfile, ks_c_str(&text), ks_len(&text)) != ks_len(&text)) {\n        print_error_errno(\"view\", \"failed to write to \\\"%s\\\"\",\n                          settings->fn_counts);\n        goto out;\n    }\n    r = hclose(outfile);\n    outfile = NULL;\n    if (r < 0) {\n        print_error_errno(\"view\", \"error on closing \\\"%s\\\"\",\n                          settings->fn_counts);\n        goto out;\n    }\n    ret = 0;\n\n out:\n    ks_free(&text);\n    if (outfile)\n        hclose_abruptly(outfile);\n    return ret;\n}\n\nint main_samview(int argc, char *argv[])\n{\n    samview_settings_t settings;\n    int c, is_header = 0, is_header_only = 0, ret = 0, compress_level = -1, has_index_file = 0, no_pg = 0;\n    FILE *fp_out = NULL;\n    char out_mode[6] = {0}, out_un_mode[6] = {0};\n    char *out_format = \"\";\n    char *arg_list = NULL;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n    htsThreadPool p = {NULL, 0};\n\n    memset(&settings,0,sizeof(settings));\n    settings.subsam_frac = -1.0;\n    settings.count_rf = SAM_FLAG; // don't want 0, and this is quick\n\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, 'O', 0, 'T', '@'),\n        {\"add-flags\", required_argument, NULL, LONGOPT('a')},\n        {\"bam\", no_argument, NULL, 'b'},\n        {\"count\", no_argument, NULL, 'c'},\n        {\"cram\", no_argument, NULL, 'C'},\n        {\"customised-index\", no_argument, NULL, 'X'},\n        {\"customized-index\", no_argument, NULL, 'X'},\n        {\"excl-flags\", required_argument, NULL, 'F'},\n        {\"exclude-flags\", required_argument, NULL, 'F'},\n        {\"expr\", required_argument, NULL, 'e'},\n        {\"expression\", required_argument, NULL, 'e'},\n        {\"fai-reference\", required_argument, NULL, 't'},\n        {\"fast\", no_argument, NULL, '1'},\n        {\"fetch-pairs\", no_argument, NULL, 'P'},\n        {\"header-only\", no_argument, NULL, 'H'},\n        {\"help\", no_argument, NULL, LONGOPT('?')},\n        {\"incl-flags\", required_argument, NULL, LONGOPT('g')},\n        {\"include-flags\", required_argument, NULL, LONGOPT('g')},\n        {\"rf\", required_argument, NULL, LONGOPT('g')}, // aka incl-flags\n        {\"keep-tag\", required_argument, NULL, LONGOPT('x') },\n        {\"library\", required_argument, NULL, 'l'},\n        {\"min-mapq\", required_argument, NULL, 'q'},\n        {\"min-MQ\", required_argument, NULL, 'q'},\n        {\"min-mq\", required_argument, NULL, 'q'},\n        {\"min-qlen\", required_argument, NULL, 'm'},\n        {\"no-header\", no_argument, NULL, LONGOPT('H')},\n        {\"no-PG\", no_argument, NULL, LONGOPT('P')},\n        {\"output\", required_argument, NULL, 'o'},\n        {\"output-unselected\", required_argument, NULL, 'U'},\n        {\"QNAME-file\", required_argument, NULL, 'N'},\n        {\"qname-file\", required_argument, NULL, 'N'},\n        {\"read-group\", required_argument, NULL, 'r'},\n        {\"read-group-file\", required_argument, NULL, 'R'},\n        {\"readgroup\", required_argument, NULL, 'r'},\n        {\"readgroup-file\", required_argument, NULL, 'R'},\n        {\"region-file\", required_argument, NULL, LONGOPT('L')},\n        {\"regions-file\", required_argument, NULL, LONGOPT('L')},\n        {\"remove-B\", no_argument, NULL, 'B'},\n        {\"remove-flags\", required_argument, NULL, LONGOPT('r')},\n        {\"remove-tag\", required_argument, NULL, 'x'},\n        {\"require-flags\", required_argument, NULL, 'f'},\n        {\"save-counts\", required_argument, NULL, LONGOPT('c')},\n        {\"subsample\", required_argument, NULL, LONGOPT('s')},\n        {\"subsample-seed\", required_argument, NULL, LONGOPT('S')},\n        {\"tag\", required_argument, NULL, 'd'},\n        {\"tag-file\", required_argument, NULL, 'D'},\n        {\"target-file\", required_argument, NULL, 'L'},\n        {\"targets-file\", required_argument, NULL, 'L'},\n        {\"uncompressed\", no_argument, NULL, 'u'},\n        {\"unmap\", no_argument, NULL, 'p'},\n        {\"unoutput\", required_argument, NULL, 'U'},\n        {\"use-index\", no_argument, NULL, 'M'},\n        {\"with-header\", no_argument, NULL, 'h'},\n        {\"sanitize\", required_argument, NULL, 'z'},\n        {NULL, 0, NULL, 0}\n    };\n\n    /* parse command-line options */\n    strcpy(out_mode, \"w\");\n    strcpy(out_un_mode, \"w\");\n    if (argc == 1 && isatty(STDIN_FILENO))\n        return usage(stdout, EXIT_SUCCESS, 0);\n\n    // Suppress complaints about '?' being an unrecognised option.  Without\n    // this we have to put '?' in the options list, which makes it hard to\n    // tell a bad long option from the use of '-?' (both return '?' and\n    // set optopt to '\\0').\n    opterr = 0;\n\n    char *tmp;\n    int tmp_flag;\n\n    while ((c = getopt_long(argc, argv,\n                            \"SbBcCt:h1Ho:O:q:f:F:G:ul:r:T:R:N:d:D:L:s:@:m:x:U:MXe:pPz:\",\n                            lopts, NULL)) >= 0) {\n        switch (c) {\n        case 's':\n            settings.subsam_seed = strtol(optarg, &tmp, 10);\n            if (tmp && *tmp == '.') {\n                settings.subsam_frac = strtod(tmp, &tmp);\n                if (*tmp) ret = 1;\n            } else {\n                ret = 1;\n            }\n\n            if (ret == 1) {\n                print_error(\"view\", \"Incorrect sampling argument \\\"%s\\\"\", optarg);\n                goto view_end;\n            }\n            settings.count_rf |= SAM_QNAME;\n            break;\n        case LONGOPT('s'):\n            settings.subsam_frac = strtod(optarg, &tmp);\n            if (*tmp || settings.subsam_frac < 0.0 || settings.subsam_frac > 1.0) {\n                print_error(\"view\", \"Incorrect sampling argument \\\"%s\\\"\", optarg);\n                goto view_end;\n            }\n            settings.count_rf |= SAM_QNAME;\n            break;\n        case LONGOPT('S'): settings.subsam_seed = atoi(optarg); break;\n        case 'm':\n            settings.min_qlen = atoi(optarg);\n            settings.count_rf |= SAM_SEQ;\n            break;\n        case 'c': settings.is_count = 1; break;\n        case LONGOPT('c'): settings.fn_counts = optarg; break;\n        case 'S': break;\n        case 'b': out_format = \"b\"; break;\n        case 'C': out_format = \"c\"; break;\n        case 't': settings.fn_fai = strdup(optarg); break;\n        case 'h': is_header = 1; break;\n        case 'H': is_header_only = 1; break;\n        case LONGOPT('H'): is_header = is_header_only = 0; break;\n        case 'o': settings.fn_out = strdup(optarg); break;\n        case 'U': settings.fn_un_out = strdup(optarg); break;\n        case 'X': has_index_file = 1; break;\n        case 'f':\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"view\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            settings.flag_on |= tmp_flag;\n            settings.count_rf |= SAM_FLAG | SAM_RNEXT;\n            break;\n        case 'F':\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"view\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            settings.flag_off |= tmp_flag;\n            settings.count_rf |= SAM_FLAG | SAM_RNEXT;\n            break;\n        case LONGOPT('g'):\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"view\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            settings.flag_anyon |= tmp_flag;\n            settings.count_rf |= SAM_FLAG | SAM_RNEXT;\n            break;\n        case 'G':\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"view\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            settings.flag_alloff |= tmp_flag;\n            settings.count_rf |= SAM_FLAG | SAM_RNEXT;\n            break;\n        case 'q':\n            settings.min_mapQ = atoi(optarg);\n            settings.count_rf |= SAM_MAPQ;\n            break;\n        case 'u': compress_level = 0; break;\n        case '1': compress_level = 1; break;\n        case 'l':\n            settings.library = strdup(optarg);\n            settings.count_rf |= SAM_RGAUX;\n            break;\n        case 'p': settings.unmap = 1; break;\n        case 'P': settings.fetch_pairs = 1; settings.multi_region = 1; break;\n        case 'z':\n            if ((settings.sanitize = bam_sanitize_options(optarg)) < 0) {\n                ret = 1;\n                goto view_end;\n            }\n            break;\n        case LONGOPT('L'):\n            settings.multi_region = 1;\n            // fall through\n        case 'L':\n            if ((settings.bed = bed_read(optarg)) == NULL) {\n                print_error_errno(\"view\", \"Could not read file \\\"%s\\\"\", optarg);\n                ret = 1;\n                goto view_end;\n            }\n            settings.count_rf |= SAM_POS | SAM_RNAME | SAM_CIGAR;\n            break;\n        case 'r':\n            if (add_read_group_single(\"view\", &settings, optarg) != 0) {\n                ret = 1;\n                goto view_end;\n            }\n            settings.count_rf |= SAM_RGAUX;\n            break;\n        case 'R':\n            if (add_read_groups_file(\"view\", &settings, optarg) != 0) {\n                ret = 1;\n                goto view_end;\n            }\n            settings.count_rf |= SAM_RGAUX;\n            break;\n        case 'N':\n            if (add_read_names_file(\"view\", &settings, optarg) != 0) {\n                ret = 1;\n                goto view_end;\n            }\n            settings.count_rf |= SAM_QNAME;\n            break;\n\n        case 'd':\n            if (strlen(optarg) < 2 || (strlen(optarg) > 2 && optarg[2] != ':')) {\n                print_error(\"view\", \"Invalid \\\"tag:value\\\" option: \\\"%s\\\"\", optarg);\n                ret = 1;\n                goto view_end;\n            }\n\n            if (settings.tag) {\n                if (settings.tag[0] != optarg[0] || settings.tag[1] != optarg[1]) {\n                    print_error(\"view\", \"Different tag \\\"%s\\\" was specified before: \\\"%s\\\"\", settings.tag, optarg);\n                    ret = 1;\n                    goto view_end;\n                }\n            } else {\n                if (!(settings.tag = calloc(3, 1))) {\n                    print_error(\"view\", \"Could not allocate memory for tag: \\\"%s\\\"\", optarg);\n                    ret = 1;\n                    goto view_end;\n                }\n                memcpy(settings.tag, optarg, 2);\n            }\n\n            if (strlen(optarg) > 3 && add_tag_value_single(\"view\", &settings, optarg+3) != 0) {\n                print_error(\"view\", \"Could not add tag:value \\\"%s\\\"\", optarg);\n                ret = 1;\n                goto view_end;\n            }\n            // Some tag filtering affects other fields\n            if (memcmp(settings.tag, \"NM\", 2) == 0 ||\n                memcmp(settings.tag, \"MD\", 2) == 0)\n                settings.count_rf |= SAM_AUX | SAM_SEQ;\n            else if (memcmp(settings.tag, \"RG\", 2) == 0)\n                settings.count_rf |= SAM_RGAUX;\n            else\n                settings.count_rf |= SAM_AUX;\n            break;\n\n        case 'D':\n            // Allow \";\" as delimiter besides \":\" to support MinGW CLI POSIX\n            // path translation as described at:\n            // http://www.mingw.org/wiki/Posix_path_conversion\n            if (strlen(optarg) < 4 || (optarg[2] != ':' && optarg[2] != ';')) {\n                print_error(\"view\", \"Invalid \\\"tag:file\\\" option: \\\"%s\\\"\", optarg);\n                ret = 1;\n                goto view_end;\n            }\n\n            if (settings.tag) {\n                if (settings.tag[0] != optarg[0] || settings.tag[1] != optarg[1]) {\n                    print_error(\"view\", \"Different tag \\\"%s\\\" was specified before: \\\"%s\\\"\", settings.tag, optarg);\n                    ret = 1;\n                    goto view_end;\n                }\n            } else {\n                if (!(settings.tag = calloc(3, 1))) {\n                    print_error(\"view\", \"Could not allocate memory for tag: \\\"%s\\\"\", optarg);\n                    ret = 1;\n                    goto view_end;\n                }\n                memcpy(settings.tag, optarg, 2);\n            }\n\n            if (add_tag_values_file(\"view\", &settings, optarg+3) != 0) {\n                ret = 1;\n                goto view_end;\n            }\n            // Some tag filtering affects other fields\n            if (memcmp(settings.tag, \"NM\", 2) == 0 ||\n                memcmp(settings.tag, \"MD\", 2) == 0)\n                settings.count_rf |= SAM_AUX | SAM_SEQ;\n            else if (memcmp(settings.tag, \"RG\", 2) == 0)\n                settings.count_rf |= SAM_RGAUX;\n            else\n                settings.count_rf |= SAM_AUX;\n            break;\n\n        case LONGOPT('?'):\n            return usage(stdout, EXIT_SUCCESS, 1);\n        case '?':\n            if (optopt == '?') {  // '-?' appeared on command line\n                return usage(stdout, EXIT_SUCCESS, 1);\n            } else {\n                if (optopt) { // Bad short option\n                    print_error(\"view\", \"invalid option -- '%c'\", optopt);\n                } else { // Bad long option\n                    // Do our best.  There is no good solution to finding\n                    // out what the bad option was.\n                    // See, e.g. https://stackoverflow.com/questions/2723888/where-does-getopt-long-store-an-unrecognized-option\n                    if (optind > 0 && strncmp(argv[optind - 1], \"--\", 2) == 0) {\n                        print_error(\"view\", \"unrecognised option '%s'\",\n                                    argv[optind - 1]);\n                    }\n                }\n                return usage(stderr, EXIT_FAILURE, 0);\n            }\n        case 'B': settings.remove_B = 1; break;\n\n        case 'M': settings.multi_region = 1; break;\n        case LONGOPT('P'): no_pg = 1; break;\n        case 'e':\n            if (!(settings.filter = hts_filter_init(optarg))) {\n                print_error(\"main_samview\", \"Couldn't initialise filter\");\n                return 1;\n            }\n            settings.count_rf = INT_MAX; // no way to know what we need\n            break;\n        case LONGOPT('r'):\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"view\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            settings.remove_flag |= tmp_flag;\n            break;\n\n        case LONGOPT('a'):\n            tmp_flag = bam_str2flag(optarg);\n\n            if (tmp_flag < 0) {\n                print_error(\"view\", \"Unknown flag '%s'\", optarg);\n                return 1;\n            }\n\n            settings.add_flag |= tmp_flag;\n            break;\n\n        case 'x':\n            if (*optarg == '^') {\n                if (parse_aux_list(&settings.keep_tag, optarg+1, \"main_samview\")) {\n                    aux_list_free(&settings);\n                    return usage(stderr, EXIT_FAILURE, 0);\n                }\n            } else {\n                if (parse_aux_list(&settings.remove_tag, optarg, \"main_samview\")) {\n                    aux_list_free(&settings);\n                    return usage(stderr, EXIT_FAILURE, 0);\n                }\n            }\n            break;\n\n        case LONGOPT('x'):\n            if (parse_aux_list(&settings.keep_tag, optarg, \"main_samview\")) {\n                aux_list_free(&settings);\n                return usage(stderr, EXIT_FAILURE, 0);\n            }\n            break;\n\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &ga) != 0)\n                return usage(stderr, EXIT_FAILURE, 0);\n            break;\n        }\n    }\n    if (settings.is_count && settings.fetch_pairs)\n    {\n        print_error(\"view\",\"The options -P and -c cannot be combined\\n\");\n        return 1;\n    }\n    if (settings.fn_fai == 0 && ga.reference) settings.fn_fai = fai_path(ga.reference);\n    if (is_header_only) is_header = 1;\n    // File format auto-detection first\n    if (settings.fn_out)    sam_open_mode(out_mode+1,    settings.fn_out,    NULL);\n    if (settings.fn_un_out) sam_open_mode(out_un_mode+1, settings.fn_un_out, NULL);\n\n    // -1 or -u without an explicit format (-b, -C) => check fn extensions\n    if (!*out_format && compress_level >= 0) {\n        if (compress_level == 0 &&\n            (out_mode[strlen(out_mode)-1] == 'z' ||\n             out_un_mode[strlen(out_un_mode)-1] == 'z'))\n            // z, fz, Fz sanity check\n            fprintf(stderr, \"[view] Warning option -u ignored due to\"\n                    \" filename suffix\\n\");\n\n        // If known extension, use it, otherwise BAM\n        if (!(out_mode[1] || is_sam(settings.fn_out)))\n            out_mode[1] = 'b';\n\n        if (!(out_un_mode[1] || is_sam(settings.fn_un_out)))\n            out_un_mode[1] = 'b';\n    } else if (*out_format) {\n        out_mode[1] = out_un_mode[1] = *out_format;\n    }\n\n    if (compress_level >= 0) {\n        char tmp[2];\n        tmp[0] = compress_level + '0'; tmp[1] = '\\0';\n        strcat(out_mode, tmp);\n        strcat(out_un_mode, tmp);\n    }\n    if (argc == optind && isatty(STDIN_FILENO)) {\n        print_error(\"view\", \"No input provided or missing option argument.\");\n        return usage(stderr, EXIT_FAILURE, 0); // potential memory leak...\n    }\n\n    if (settings.unmap && settings.fn_un_out) {\n        print_error(\"view\", \"Options --unoutput and --unmap are mutually exclusive.\");\n        ret = 1;\n        goto view_end;\n    }\n\n    if (settings.subsam_seed != 0) {\n        // Convert likely user input 1,2,... to pseudo-random\n        // values with more entropy and more bits set\n        srand(settings.subsam_seed);\n        settings.subsam_seed = rand();\n    }\n\n    settings.fn_in = (optind < argc)? argv[optind] : \"-\";\n    if ((settings.in = sam_open_format(settings.fn_in, \"r\", &ga.in)) == 0) {\n        print_error_errno(\"view\", \"failed to open \\\"%s\\\" for reading\", settings.fn_in);\n        ret = 1;\n        goto view_end;\n    }\n\n    if (settings.fn_fai) {\n        if (hts_set_fai_filename(settings.in, settings.fn_fai) != 0) {\n            fprintf(stderr, \"[main_samview] failed to use reference \\\"%s\\\".\\n\", settings.fn_fai);\n            ret = 1;\n            goto view_end;\n        }\n    }\n    if ((settings.header = sam_hdr_read(settings.in)) == 0) {\n        fprintf(stderr, \"[main_samview] fail to read the header from \\\"%s\\\".\\n\", settings.fn_in);\n        ret = 1;\n        goto view_end;\n    }\n    if (settings.rghash) {\n        sam_hdr_remove_lines(settings.header, \"RG\", \"ID\", settings.rghash);\n    }\n    if (!settings.is_count) {\n        if ((settings.out = sam_open_format(settings.fn_out? settings.fn_out : \"-\", out_mode, &ga.out)) == 0) {\n            print_error_errno(\"view\", \"failed to open \\\"%s\\\" for writing\", settings.fn_out? settings.fn_out : \"standard output\");\n            ret = 1;\n            goto view_end;\n        }\n        if (settings.fn_fai) {\n            if (hts_set_fai_filename(settings.out, settings.fn_fai) != 0) {\n                fprintf(stderr, \"[main_samview] failed to use reference \\\"%s\\\".\\n\", settings.fn_fai);\n                ret = 1;\n                goto view_end;\n            }\n        }\n        autoflush_if_stdout(settings.out, settings.fn_out);\n\n        if (!no_pg) {\n            if (!(arg_list = stringify_argv(argc+1, argv-1))) {\n                print_error(\"view\", \"failed to create arg_list\");\n                ret = 1;\n                goto view_end;\n            }\n            if (sam_hdr_add_pg(settings.header, \"samtools\",\n                                         \"VN\", samtools_version(),\n                                         arg_list ? \"CL\": NULL,\n                                         arg_list ? arg_list : NULL,\n                                         NULL)) {\n                print_error(\"view\", \"failed to add PG line to the header\");\n                ret = 1;\n                goto view_end;\n            }\n        }\n\n        if (ga.write_index || is_header ||\n            out_mode[1] == 'b' || out_mode[1] == 'c' ||\n            (ga.out.format != sam && ga.out.format != unknown_format))  {\n            if (sam_hdr_write(settings.out, settings.header) != 0) {\n                fprintf(stderr, \"[main_samview] failed to write the SAM header\\n\");\n                ret = 1;\n                goto view_end;\n            }\n        }\n        if (ga.write_index) {\n            if (!(settings.fn_out_idx = auto_index(settings.out, settings.fn_out, settings.header))) {\n                ret = 1;\n                goto view_end;\n            }\n        }\n\n        if (settings.fn_un_out) {\n            if ((settings.un_out = sam_open_format(settings.fn_un_out, out_un_mode, &ga.out)) == 0) {\n                print_error_errno(\"view\", \"failed to open \\\"%s\\\" for writing\", settings.fn_un_out);\n                ret = 1;\n                goto view_end;\n            }\n            if (settings.fn_fai) {\n                if (hts_set_fai_filename(settings.un_out, settings.fn_fai) != 0) {\n                    fprintf(stderr, \"[main_samview] failed to use reference \\\"%s\\\".\\n\", settings.fn_fai);\n                    ret = 1;\n                    goto view_end;\n                }\n            }\n            autoflush_if_stdout(settings.un_out, settings.fn_un_out);\n            if (ga.write_index || is_header ||\n                out_un_mode[1] == 'b' || out_un_mode[1] == 'c' ||\n                (ga.out.format != sam && ga.out.format != unknown_format))  {\n                if (sam_hdr_write(settings.un_out, settings.header) != 0) {\n                    fprintf(stderr, \"[main_samview] failed to write the SAM header\\n\");\n                    ret = 1;\n                    goto view_end;\n                }\n            }\n            if (ga.write_index) {\n                if (!(settings.fn_un_out_idx = auto_index(settings.un_out, settings.fn_un_out, settings.header))) {\n                    ret = 1;\n                    goto view_end;\n                }\n            }\n        }\n    }\n    else {\n        if (settings.fn_out) {\n            fp_out = fopen(settings.fn_out, \"w\");\n            if (fp_out == NULL) {\n                print_error_errno(\"view\", \"can't create \\\"%s\\\"\", settings.fn_out);\n                ret = EXIT_FAILURE;\n                goto view_end;\n            }\n        }\n        settings.unmap = 0;  // Not valid in counting mode\n    }\n\n    if (ga.nthreads > 0) {\n        if (!(p.pool = hts_tpool_init(ga.nthreads))) {\n            fprintf(stderr, \"Error creating thread pool\\n\");\n            ret = 1;\n            goto view_end;\n        }\n        hts_set_opt(settings.in,  HTS_OPT_THREAD_POOL, &p);\n        if (settings.out) hts_set_opt(settings.out, HTS_OPT_THREAD_POOL, &p);\n    }\n    if (is_header_only) goto view_end; // no need to print alignments\n\n\n    // Initialize BAM/CRAM index\n    char **regs = NULL;\n    int nregs = 0;\n    if ( has_index_file && optind <= argc - 2 ) {\n        regs = optind < argc-2 ? &argv[optind+2] : NULL;\n        nregs = argc - optind - 2;\n        settings.fn_idx_in = argv[optind+1];\n    } else if (!has_index_file && optind < argc - 1 ) {\n        regs = &argv[optind+1];\n        nregs = argc - optind - 1;\n    } else if ( has_index_file && argc-optind < 2) {\n        print_error(\"view\", \"Incorrect number of arguments for -X option. Aborting.\");\n        return 1;\n    }\n    if (regs)\n        settings.count_rf |= SAM_POS | SAM_RNAME | SAM_CIGAR;\n\n    if ( settings.fn_idx_in || nregs || settings.multi_region )\n    {\n        settings.hts_idx = settings.fn_idx_in ? sam_index_load2(settings.in, settings.fn_in, settings.fn_idx_in) : sam_index_load(settings.in, settings.fn_in);\n        if ( !settings.hts_idx )\n        {\n            print_error(\"view\", \"Random alignment retrieval only works for indexed SAM.gz, BAM or CRAM files.\");\n            return 1;\n        }\n    }\n\n    if (settings.is_count)\n        // Won't fail, but also wouldn't matter if it did\n        hts_set_opt(settings.in, CRAM_OPT_REQUIRED_FIELDS, settings.count_rf);\n\n    if ( settings.fetch_pairs )\n    {\n        hts_itr_multi_t *iter = multi_region_init(&settings, regs, nregs);\n        ret = iter ? fetch_pairs_collect_mates(&settings, iter) : 1;\n        if (ret) goto view_end;\n    }\n    else if ( settings.multi_region )\n    {\n        hts_itr_multi_t *iter = multi_region_init(&settings, regs, nregs);\n        ret = iter ? multi_region_view(&settings, iter) : 1;\n        if (ret) goto view_end;\n    }\n    else if ( !settings.hts_idx || optind+1 >= argc-has_index_file ) {\n        // stream through the entire file\n        ret = stream_view(&settings);\n        if (ret) goto view_end;\n    } else {   // retrieve alignments in specified regions\n        int i;\n        for (i = (has_index_file)? optind+2 : optind+1; i < argc; ++i) {\n            hts_itr_t *iter = sam_itr_querys(settings.hts_idx, settings.header, argv[i]); // parse a region in the format like `chr2:100-200'\n            if (iter == NULL) { // region invalid or reference name not found\n                fprintf(stderr, \"[main_samview] region \\\"%s\\\" specifies an invalid region or unknown reference. Continue anyway.\\n\", argv[i]);\n                continue;\n            }\n            // fetch alignments\n            ret = multi_region_view(&settings, iter);\n            if (ret) goto view_end;\n        }\n    }\n\n    if (ga.write_index) {\n        if (sam_idx_save(settings.out) < 0) {\n            print_error_errno(\"view\", \"writing index failed\");\n            ret = 1;\n        }\n        if (settings.un_out && sam_idx_save(settings.un_out) < 0) {\n            print_error_errno(\"view\", \"writing index failed\");\n            ret = 1;\n        }\n    }\n\nview_end:\n    if ( settings.hts_idx ) hts_idx_destroy(settings.hts_idx);\n\n    if (settings.is_count && ret == 0) {\n        if (fprintf(settings.fn_out? fp_out : stdout, \"%\" PRId64 \"\\n\", settings.count) < 0) {\n            if (settings.fn_out) print_error_errno(\"view\", \"writing to \\\"%s\\\" failed\", settings.fn_out);\n            else print_error_errno(\"view\", \"writing to standard output failed\");\n            ret = EXIT_FAILURE;\n        }\n    }\n\n    if (settings.fn_counts && ret == 0) {\n        if (write_counts_to_file(&settings) < 0)\n            ret = EXIT_FAILURE;\n    }\n\n    // close files, free and return\n    if (settings.in) check_sam_close(\"view\", settings.in, settings.fn_in, \"standard input\", &ret);\n    if (settings.out) check_sam_close(\"view\", settings.out, settings.fn_out, \"standard output\", &ret);\n    if (settings.un_out) check_sam_close(\"view\", settings.un_out, settings.fn_un_out, \"file\", &ret);\n    if (fp_out) fclose(fp_out);\n\n    free(settings.fn_fai); free(settings.fn_out); free(settings.library);  free(settings.fn_un_out);\n    sam_global_args_free(&ga);\n    if ( settings.header ) sam_hdr_destroy(settings.header);\n    if (settings.bed) bed_destroy(settings.bed);\n    if (settings.rghash) {\n        khint_t k;\n        for (k = 0; k < kh_end(settings.rghash); ++k)\n            if (kh_exist(settings.rghash, k)) free((char*)kh_key(settings.rghash, k));\n        kh_destroy(str, settings.rghash);\n    }\n    if (settings.rnhash) {\n        khint_t k;\n        for (k = 0; k < kh_end(settings.rnhash); ++k)\n            if (kh_exist(settings.rnhash, k)) free((char*)kh_key(settings.rnhash, k));\n        kh_destroy(str, settings.rnhash);\n    }\n    if (settings.tvhash) {\n        khint_t k;\n        for (k = 0; k < kh_end(settings.tvhash); ++k)\n            if (kh_exist(settings.tvhash, k)) free((char*)kh_key(settings.tvhash, k));\n        kh_destroy(str, settings.tvhash);\n    }\n\n    if (settings.remove_aux_len) {\n        free(settings.remove_aux);\n    }\n    if (settings.tag) {\n        free(settings.tag);\n    }\n    if (settings.filter)\n        hts_filter_free(settings.filter);\n\n    if (p.pool)\n        hts_tpool_destroy(p.pool);\n\n    if (settings.fn_out_idx)\n        free(settings.fn_out_idx);\n    if (settings.fn_un_out_idx)\n        free(settings.fn_un_out_idx);\n    free(arg_list);\n\n    aux_list_free(&settings);\n\n    return ret;\n}\n\nstatic int usage(FILE *fp, int exit_status, int is_long_help)\n{\n    fprintf(fp,\n\"\\n\"\n\"Usage: samtools view [options] <in.bam>|<in.sam>|<in.cram> [region ...]\\n\"\n\"\\n\"\n\n\"Output options:\\n\"\n\"  -b, --bam                  Output BAM\\n\"\n\"  -C, --cram                 Output CRAM (requires -T)\\n\"\n\"  -1, --fast                 Use fast BAM compression (and default to --bam)\\n\"\n\"  -u, --uncompressed         Uncompressed BAM output (and default to --bam)\\n\"\n\"  -h, --with-header          Include header in SAM output\\n\"\n\"  -H, --header-only          Print SAM header only (no alignments)\\n\"\n\"      --no-header            Print SAM alignment records only [default]\\n\"\n\"  -c, --count                Print only the count of matching records\\n\"\n\"      --save-counts FILE     Write counts of passed/failed records to FILE\\n\"\n\"  -o, --output FILE          Write output to FILE [standard output]\\n\"\n\"  -U, --unoutput FILE, --output-unselected FILE\\n\"\n\"                             Output reads not selected by filters to FILE\\n\"\n\"  -p, --unmap                Set flag to UNMAP on reads not selected\\n\"\n\"                             then write to output file.\\n\"\n\"  -P, --fetch-pairs          Retrieve complete pairs even when outside of region\\n\"\n\"Input options:\\n\"\n\"  -t, --fai-reference FILE   FILE listing reference names and lengths\\n\"\n\"  -M, --use-index            Use index and multi-region iterator for regions\\n\"\n\"      --region[s]-file FILE  Use index to include only reads overlapping FILE\\n\"\n\"  -X, --customized-index     Expect extra index file argument after <in.bam>\\n\"\n\"\\n\"\n\"Filtering options (Only include in output reads that...):\\n\"\n\"  -L, --target[s]-file FILE  ...overlap (BED) regions in FILE\\n\"\n\"  -N, --qname-file [^]FILE   ...whose read name is listed in FILE (\\\"^\\\" negates)\\n\"\n\"  -r, --read-group STR       ...are in read group STR\\n\"\n\"  -R, --read-group-file [^]FILE\\n\"\n\"                             ...are in a read group listed in FILE\\n\"\n\"  -d, --tag STR1[:STR2]      ...have a tag STR1 (with associated value STR2)\\n\"\n\"  -D, --tag-file STR:FILE    ...have a tag STR whose value is listed in FILE\\n\"\n\"  -q, --min-MQ INT           ...have mapping quality >= INT\\n\"\n\"  -l, --library STR          ...are in library STR\\n\"\n\"  -m, --min-qlen INT         ...cover >= INT query bases (as measured via CIGAR)\\n\"\n\"  -e, --expr STR             ...match the filter expression STR\\n\"\n\"  -f, --require-flags FLAG   ...have all of the FLAGs present\\n\"             //   F&x == x\n\"  -F, --excl[ude]-flags FLAG ...have none of the FLAGs present\\n\"            //   F&x == 0\n\"      --rf, --incl-flags, --include-flags FLAG\\n\"\n\"                             ...have some of the FLAGs present\\n\"\n\"  -G FLAG                    EXCLUDE reads with all of the FLAGs present\\n\"  // !(F&x == x)  TODO long option\n\"      --subsample FLOAT      Keep only FLOAT fraction of templates/read pairs\\n\"\n\"      --subsample-seed INT   Influence WHICH reads are kept in subsampling [0]\\n\"\n\"  -s INT.FRAC                Same as --subsample 0.FRAC --subsample-seed INT\\n\"\n\"\\n\"\n\"Processing options:\\n\"\n\"      --add-flags FLAG       Add FLAGs to reads\\n\"\n\"      --remove-flags FLAG    Remove FLAGs from reads\\n\"\n\"  -x, --remove-tag STR\\n\"\n\"               Comma-separated read tags to strip (repeatable) [null]\\n\"\n\"      --keep-tag STR\\n\"\n\"               Comma-separated read tags to preserve (repeatable) [null].\\n\"\n\"               Equivalent to \\\"-x ^STR\\\"\\n\"\n\"  -B, --remove-B             Collapse the backward CIGAR operation\\n\"\n\"  -z, --sanitize FLAGS       Perform sanitity checking and fixing on records.\\n\"\n\"                             FLAGS is comma separated (see manual). [off]\\n\"\n\"\\n\"\n\"General options:\\n\"\n\"  -?, --help   Print long help, including note about region specification\\n\"\n\"  -S           Ignored (input format is auto-detected)\\n\"\n\"      --no-PG  Do not add a PG line\\n\");\n\n    sam_global_opt_help(fp, \"-.O.T@..\");\n    fprintf(fp, \"\\n\");\n\n    if (is_long_help)\n        fprintf(fp,\n\"Notes:\\n\"\n\"\\n\"\n\"1. This command now auto-detects the input format (BAM/CRAM/SAM).\\n\"\n\"   Further control over the CRAM format can be specified by using the\\n\"\n\"   --output-fmt-option, e.g. to specify the number of sequences per slice\\n\"\n\"   and to use avoid reference based compression:\\n\"\n\"\\n\"\n\"\\tsamtools view -C --output-fmt-option seqs_per_slice=5000 \\\\\\n\"\n\"\\t   --output-fmt-option no_ref -o out.cram in.bam\\n\"\n\"\\n\"\n\"   Options can also be specified as a comma separated list within the\\n\"\n\"   --output-fmt value too.  For example this is equivalent to the above\\n\"\n\"\\n\"\n\"\\tsamtools view --output-fmt cram,seqs_per_slice=5000,no_ref \\\\\\n\"\n\"\\t   -o out.cram in.bam\\n\"\n\"\\n\"\n\"2. The file supplied with `-t' is SPACE/TAB delimited with the first\\n\"\n\"   two fields of each line consisting of the reference name and the\\n\"\n\"   corresponding sequence length. The `.fai' file generated by \\n\"\n\"   `samtools faidx' is suitable for use as this file. This may be an\\n\"\n\"   empty file if reads are unaligned.\\n\"\n\"\\n\"\n\"3. SAM->BAM conversion:  samtools view -bT ref.fa in.sam.gz\\n\"\n\"\\n\"\n\"4. BAM->SAM conversion:  samtools view -h in.bam\\n\"\n\"\\n\"\n\"5. A region should be presented in one of the following formats:\\n\"\n\"   `chr1', `chr2:1,000' and `chr3:1000-2,000'. When a region is\\n\"\n\"   specified, the input alignment file must be a sorted and indexed\\n\"\n\"   alignment (BAM/CRAM) file.\\n\"\n\"\\n\"\n\"6. Option `-u' is preferred over `-b' when the output is piped to\\n\"\n\"   another samtools command.\\n\"\n\"\\n\"\n\"7. Option `-M`/`--use-index` causes overlaps with `-L` BED file regions and\\n\"\n\"   command-line region arguments to be computed using the multi-region iterator\\n\"\n\"   and an index. This increases speed, omits duplicates, and outputs the reads\\n\"\n\"   as they are ordered in the input SAM/BAM/CRAM file.\\n\"\n\"\\n\"\n\"8. Options `-L`/`--target[s]-file` and `--region[s]-file` may not be used\\n\"\n\"   together. `--region[s]-file FILE` is simply equivalent to `-M -L FILE`,\\n\"\n\"   so using both causes one of the specified BED files to be ignored.\\n\"\n\"\\n\");\n\n    return exit_status;\n}\n\nstatic int head_usage(FILE *fp, int exit_status)\n{\n    fprintf(fp,\n\"Usage: samtools head [OPTION]... [FILE]\\n\"\n\"Options:\\n\"\n\"  -h, --headers INT   Display INT header lines [all]\\n\"\n\"  -n, --records INT   Display INT alignment record lines [none]\\n\"\n);\n    sam_global_opt_help(fp, \"-.--T@-.\");\n    return exit_status;\n}\n\nint main_head(int argc, char *argv[])\n{\n    static const struct option lopts[] = {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 'T', '@'),\n        { \"headers\", required_argument, NULL, 'h' },\n        { \"records\", required_argument, NULL, 'n' },\n        { NULL, 0, NULL, 0 }\n    };\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n\n    int all_headers = 1;\n    uint64_t nheaders = 0;\n    uint64_t nrecords = 0;\n\n    int c, nargs;\n    while ((c = getopt_long(argc, argv, \"h:n:T:@:\", lopts, NULL)) >= 0)\n        switch (c) {\n        case 'h': all_headers = 0; nheaders = strtoull(optarg, NULL, 0); break;\n        case 'n': nrecords = strtoull(optarg, NULL, 0); break;\n        default:\n            if (parse_sam_global_opt(c, optarg, lopts, &ga) == 0) break;\n            /* else fall-through */\n        case '?':\n            return head_usage(stderr, EXIT_FAILURE);\n        }\n\n    nargs = argc - optind;\n    if (nargs == 0 && isatty(STDIN_FILENO))\n        return head_usage(stdout, EXIT_SUCCESS);\n    else if (nargs > 1)\n        return head_usage(stderr, EXIT_FAILURE);\n\n    samFile *fp = NULL;\n    sam_hdr_t *hdr = NULL;\n    kstring_t str = KS_INITIALIZE;\n    bam1_t *b = NULL;\n\n    const char *fname = (nargs == 1)? argv[optind] : \"-\";\n    fp = sam_open_format(fname, \"r\", &ga.in);\n    if (fp == NULL) {\n        if (strcmp(fname, \"-\") != 0)\n            print_error_errno(\"head\", \"failed to open \\\"%s\\\" for reading\", fname);\n        else\n            print_error_errno(\"head\", \"failed to open standard input for reading\");\n        goto err;\n    }\n\n    if (ga.nthreads > 0) hts_set_threads(fp, ga.nthreads);\n\n    hdr = sam_hdr_read(fp);\n    if (hdr == NULL) {\n        if (strcmp(fname, \"-\") != 0)\n            print_error(\"head\", \"failed to read the header from \\\"%s\\\"\", fname);\n        else\n            print_error(\"head\", \"failed to read the header\");\n        goto err;\n    }\n\n    if (all_headers) {\n        fputs(sam_hdr_str(hdr), stdout);\n    }\n    else if (nheaders > 0) {\n        const char *text = sam_hdr_str(hdr);\n        const char *lim = text;\n        uint64_t n;\n        for (n = 0; n < nheaders; n++) {\n            lim = strchr(lim, '\\n');\n            if (lim) lim++;\n            else break;\n        }\n        if (lim) fwrite(text, lim - text, 1, stdout);\n        else fputs(text, stdout);\n    }\n\n    if (nrecords > 0) {\n        b = bam_init1();\n        uint64_t n;\n        int r = 0;\n        for (n = 0; n < nrecords && (r = sam_read1(fp, hdr, b)) >= 0; n++) {\n            if (sam_format1(hdr, b, &str) < 0) {\n                print_error_errno(\"head\", \"couldn't format record\");\n                goto err;\n            }\n            puts(ks_str(&str));\n        }\n        if (r < -1) {\n            print_error(\"head\", \"\\\"%s\\\" is truncated\", fname);\n            goto err;\n        }\n        bam_destroy1(b);\n        ks_free(&str);\n    }\n\n    sam_hdr_destroy(hdr);\n    sam_close(fp);\n    sam_global_args_free(&ga);\n\n    return EXIT_SUCCESS;\n\nerr:\n    if (fp) sam_close(fp);\n    sam_hdr_destroy(hdr);\n    bam_destroy1(b);\n    ks_free(&str);\n    sam_global_args_free(&ga);\n    return EXIT_FAILURE;\n}\n"
        },
        {
          "name": "sample.c",
          "type": "blob",
          "size": 4.43359375,
          "content": "/*  sample.c -- group data by sample.\n\n    Copyright (C) 2010, 2011 Broad Institute.\n    Copyright (C) 2013 Genome Research Ltd.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include \"sample.h\"\n#include \"htslib/khash.h\"\nKHASH_MAP_INIT_STR(sm, int)\n\nbam_sample_t *bam_smpl_init(void)\n{\n    bam_sample_t *s;\n    s = calloc(1, sizeof(bam_sample_t));\n    s->rg2smid = kh_init(sm);\n    s->sm2id = kh_init(sm);\n    return s;\n}\n\nvoid bam_smpl_destroy(bam_sample_t *sm)\n{\n    int i;\n    khint_t k;\n    khash_t(sm) *rg2smid = (khash_t(sm)*)sm->rg2smid;\n    if (sm == 0) return;\n    for (i = 0; i < sm->n; ++i) free(sm->smpl[i]);\n    free(sm->smpl);\n    for (k = kh_begin(rg2smid); k != kh_end(rg2smid); ++k)\n        if (kh_exist(rg2smid, k)) free((char*)kh_key(rg2smid, k));\n    kh_destroy(sm, sm->rg2smid);\n    kh_destroy(sm, sm->sm2id);\n    free(sm);\n}\n\nstatic void add_pair(bam_sample_t *sm, khash_t(sm) *sm2id, const char *key, const char *val)\n{\n    khint_t k_rg, k_sm;\n    int ret;\n    khash_t(sm) *rg2smid = (khash_t(sm)*)sm->rg2smid;\n    k_rg = kh_get(sm, rg2smid, key);\n    if (k_rg != kh_end(rg2smid)) return; // duplicated @RG-ID\n    k_rg = kh_put(sm, rg2smid, strdup(key), &ret);\n    k_sm = kh_get(sm, sm2id, val);\n    if (k_sm == kh_end(sm2id)) { // absent\n        if (sm->n == sm->m) {\n            sm->m = sm->m? sm->m<<1 : 1;\n            sm->smpl = realloc(sm->smpl, sizeof(char*) * sm->m);\n        }\n        sm->smpl[sm->n] = strdup(val);\n        k_sm = kh_put(sm, sm2id, sm->smpl[sm->n], &ret);\n        kh_val(sm2id, k_sm) = sm->n++;\n    }\n    kh_val(rg2smid, k_rg) = kh_val(sm2id, k_sm);\n}\n\nint bam_smpl_add(bam_sample_t *sm, const char *fn, const char *txt)\n{\n    const char *p = txt, *q, *r;\n    kstring_t buf, first_sm;\n    int n = 0;\n    khash_t(sm) *sm2id = (khash_t(sm)*)sm->sm2id;\n    if (txt == 0) {\n        add_pair(sm, sm2id, fn, fn);\n        return 0;\n    }\n    memset(&buf, 0, sizeof(kstring_t));\n    memset(&first_sm, 0, sizeof(kstring_t));\n    while ((q = strstr(p, \"@RG\")) != 0) {\n        p = q + 3;\n        r = q = 0;\n        if ((q = strstr(p, \"\\tID:\")) != 0) q += 4;\n        if ((r = strstr(p, \"\\tSM:\")) != 0) r += 4;\n        if (r && q) {\n            char *u, *v;\n            int oq, or;\n            for (u = (char*)q; *u && *u != '\\t' && *u != '\\n'; ++u);\n            for (v = (char*)r; *v && *v != '\\t' && *v != '\\n'; ++v);\n            oq = *u; or = *v; *u = *v = '\\0';\n            buf.l = 0; kputs(fn, &buf); kputc('/', &buf); kputs(q, &buf);\n            add_pair(sm, sm2id, buf.s, r);\n            if ( !first_sm.s )\n                kputs(r,&first_sm);\n            *u = oq; *v = or;\n        } else break;\n        p = q > r? q : r;\n        ++n;\n    }\n    if (n == 0) add_pair(sm, sm2id, fn, fn);\n    // If there is only one RG tag present in the header and reads are not annotated, don't refuse to work but\n    //  use the tag instead.\n    else if ( n==1 && first_sm.s )\n        add_pair(sm,sm2id,fn,first_sm.s);\n    if ( first_sm.s )\n        free(first_sm.s);\n\n//  add_pair(sm, sm2id, fn, fn);\n    free(buf.s);\n    return 0;\n}\n\nint bam_smpl_rg2smid(const bam_sample_t *sm, const char *fn, const char *rg, kstring_t *str)\n{\n    khint_t k;\n    khash_t(sm) *rg2smid = (khash_t(sm)*)sm->rg2smid;\n    if (rg) {\n        str->l = 0;\n        kputs(fn, str); kputc('/', str); kputs(rg, str);\n        k = kh_get(sm, rg2smid, str->s);\n    } else k = kh_get(sm, rg2smid, fn);\n    return k == kh_end(rg2smid)? -1 : kh_val(rg2smid, k);\n}\n"
        },
        {
          "name": "sample.h",
          "type": "blob",
          "size": 1.5234375,
          "content": "/*  sample.h -- group data by sample.\n\n    Copyright (C) 2010 Broad Institute.\n\n    Author: Heng Li <lh3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef BAM_SAMPLE_H\n#define BAM_SAMPLE_H\n\n#include \"htslib/kstring.h\"\n\ntypedef struct {\n    int n, m;\n    char **smpl;\n    void *rg2smid, *sm2id;\n} bam_sample_t;\n\nbam_sample_t *bam_smpl_init(void);\nint bam_smpl_add(bam_sample_t *sm, const char *abs, const char *txt);\nint bam_smpl_rg2smid(const bam_sample_t *sm, const char *fn, const char *rg, kstring_t *str);\nvoid bam_smpl_destroy(bam_sample_t *sm);\n\n#endif\n"
        },
        {
          "name": "samtools.h",
          "type": "blob",
          "size": 1.9453125,
          "content": "/*  samtools.h -- utility routines.\n\n    Copyright (C) 2013-2015, 2019, 2023 Genome Research Ltd.\n\n    Author: Petr Danecek <pd3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#ifndef SAMTOOLS_H\n#define SAMTOOLS_H\n\n#include \"htslib/hts_defs.h\"\n#include \"htslib/sam.h\"\n#include \"sam_utils.h\"\n\nconst char *samtools_version(void);\n\n/* BAM sanitizer options */\n#define FIX_POS     2\n#define FIX_MQUAL   4\n#define FIX_UNMAP   8\n#define FIX_CIGAR   16\n#define FIX_AUX     32\n#define FIX_CIGDUP  64\n#define FIX_CIGARX  128\n\n// default for position sorted data\n#define FIX_ON (FIX_MQUAL|FIX_UNMAP|FIX_CIGAR|FIX_AUX|FIX_CIGDUP)\n#define FIX_ALL 127\n\n// Parses a comma-separated list of \"pos\", \"mqual\", \"unmap\", \"cigar\", \"cigdup\",\n// \"cigarx\" and \"aux\" keywords for the bam sanitizer.\nint bam_sanitize_options(const char *str);\n\n// Sanitize a BAM record, using FIX_* bit flags as defined above.\n// Returns 0 on success,\n//        <0 on failure.\nint bam_sanitize(sam_hdr_t *h, bam1_t *b, int flags);\n\n#endif\n"
        },
        {
          "name": "splaysort.h",
          "type": "blob",
          "size": 14.2783203125,
          "content": "/* The MIT License\n\n   Copyright (c) 2021 Genome Research Ltd (GRL).\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#ifndef SPLAYSORT_H\n#define SPLAYSORT_H\n\n#define SPLAYSORT_INIT(name, type_t, __sort_lt)                               \\\n    typedef struct splaynode_##name {                                         \\\n        type_t value;                                                         \\\n        struct splaynode_##name *left;                                        \\\n        struct splaynode_##name *right;                                       \\\n        struct splaynode_##name *parent;                                      \\\n    } splaynode_##name;                                                       \\\n                                                                              \\\n    void rotate_left_##name(splaynode_##name *node);                          \\\n    void rotate_right_##name(splaynode_##name *node);                         \\\n    int splay_sort_##name(size_t n, type_t array[] );                         \\\n    int splay_flatten_##name(splaynode_##name *node, type_t dest[], size_t n);\\\n    splaynode_##name *splay_tree_##name(splaynode_##name *node);              \\\n    splaynode_##name *splay_insert_##name(splaynode_##name *node,             \\\n                                          type_t value,                       \\\n                                          splaynode_##name *node_ptr);        \\\n                                                                              \\\n    void rotate_left_##name(splaynode_##name *node) {                         \\\n        splaynode_##name *parent = node->parent;                              \\\n        splaynode_##name *grandparent = parent->parent;                       \\\n        parent->right = node->left;                                           \\\n        if (node->left != NULL) {                                             \\\n            node->left->parent = parent;                                      \\\n        }                                                                     \\\n        node->left = parent;                                                  \\\n        parent->parent = node;                                                \\\n        node->parent = grandparent;                                           \\\n                                                                              \\\n        if (grandparent != NULL) {                                            \\\n            if (grandparent->left == parent) {                                \\\n                grandparent->left = node;                                     \\\n            } else {                                                          \\\n                grandparent->right = node;                                    \\\n            }                                                                 \\\n        }                                                                     \\\n    }                                                                         \\\n                                                                              \\\n    void rotate_right_##name(splaynode_##name *node) {                        \\\n        splaynode_##name *parent = node->parent;                              \\\n        splaynode_##name *grandparent = parent->parent;                       \\\n        parent->left = node->right;                                           \\\n                                                                              \\\n        if (node->right != NULL) {                                            \\\n            node->right->parent = parent;                                     \\\n        }                                                                     \\\n        node->right = parent;                                                 \\\n        parent->parent = node;                                                \\\n        node->parent = grandparent;                                           \\\n                                                                              \\\n        if (grandparent != NULL) {                                            \\\n            if (grandparent->left == parent) {                                \\\n                grandparent->left = node;                                     \\\n            } else {                                                          \\\n                grandparent->right = node;                                    \\\n            }                                                                 \\\n        }                                                                     \\\n    }                                                                         \\\n    int splay_sort_##name(size_t n, type_t array[] ) {                        \\\n        if (n < 1) {                                                          \\\n            return 0;                                                         \\\n        }                                                                     \\\n        int i;                                                                \\\n        splaynode_##name *node_pool = malloc(sizeof(splaynode_##name) * n);   \\\n        if (node_pool == NULL) return -1;                                     \\\n        splaynode_##name *head = node_pool;                                   \\\n        head->value = array[0];                                               \\\n        head->left = NULL; head->right = NULL; head->parent = NULL;           \\\n        for (i = 1; i < n; i++) {                                             \\\n            head = splay_insert_##name(head, array[i], node_pool + i );       \\\n        }                                                                     \\\n                                                                              \\\n        if (splay_flatten_##name(head, array, n) == -1) {                     \\\n            free(node_pool);                                                  \\\n            return -1;                                                        \\\n        }                                                                     \\\n        free(node_pool);                                                      \\\n        return 0;                                                             \\\n    }                                                                         \\\n                                                                              \\\n    int splay_flatten_##name(splaynode_##name *head, type_t *dest, size_t n) {\\\n        int sp = 0, i = 0;                                                    \\\n        splaynode_##name *current = head;                                     \\\n        splaynode_##name **stack = malloc(sizeof(current)*n);                 \\\n        if (stack == NULL) return -1;                                         \\\n                                                                              \\\n        do {                                                                  \\\n            while (current != NULL && sp < n) {                               \\\n                stack[sp++] = current;                                        \\\n                current = current->left;                                      \\\n            }                                                                 \\\n            if (sp != 0) {                                                    \\\n                sp--;                                                         \\\n                dest[i++] = stack[sp]->value;                                 \\\n                current = stack[sp]->right;                                   \\\n            }                                                                 \\\n        } while (!(current == NULL && sp == 0));                              \\\n                                                                              \\\n        free(stack);                                                          \\\n        return 0;                                                             \\\n    }                                                                         \\\n    splaynode_##name *splay_insert_##name(splaynode_##name *head,             \\\n                                          type_t value,                       \\\n                                          splaynode_##name *node_ptr) {       \\\n        splaynode_##name *parent = NULL;                                      \\\n        while (head != NULL) {                                                \\\n            parent = head;                                                    \\\n            if (__sort_lt(value, head->value)) {                              \\\n                head = head->left;                                            \\\n            } else {                                                          \\\n                head = head->right;                                           \\\n            }                                                                 \\\n        }                                                                     \\\n        splaynode_##name *new_node = node_ptr;                                \\\n        new_node->value = value;                                              \\\n        new_node->left = NULL;                                                \\\n        new_node->right = NULL;                                               \\\n        new_node->parent = parent;                                            \\\n        if (parent) {                                                         \\\n            if (__sort_lt(value, parent->value)) {                            \\\n                parent->left = new_node;                                      \\\n            } else {                                                          \\\n                parent->right = new_node;                                     \\\n            }                                                                 \\\n        }                                                                     \\\n        new_node = splay_tree_##name(new_node);                               \\\n        return new_node;                                                      \\\n    }                                                                         \\\n                                                                              \\\n    splaynode_##name *splay_tree_##name(splaynode_##name *node) {             \\\n        splaynode_##name *parent = node->parent;                              \\\n                                                                              \\\n        if (node->parent == NULL) {                                           \\\n            return node;                                                      \\\n        }                                                                     \\\n        if (node == parent->left) {                                           \\\n            if (parent->parent == NULL) {                                     \\\n                /* zig */                                                     \\\n                rotate_right_##name(node);                                    \\\n            } else if (parent->parent->left == parent) {                      \\\n                /* left zig zig */                                            \\\n                rotate_right_##name(node);                                    \\\n                rotate_right_##name(node);                                    \\\n            } else {                                                          \\\n                /* right left zig zag */                                      \\\n                rotate_right_##name(node);                                    \\\n                rotate_left_##name(node);                                     \\\n            }                                                                 \\\n        } else {                                                              \\\n            if (parent->parent == NULL) {                                     \\\n            /* zig */                                                         \\\n            rotate_left_##name(node);                                         \\\n            } else if (parent->parent->right == parent) {                     \\\n                /* right zig zig */                                           \\\n                rotate_left_##name(node);                                     \\\n                rotate_left_##name(node);                                     \\\n            } else  {                                                         \\\n                /* left right zig zag */                                      \\\n                rotate_left_##name(node);                                     \\\n                rotate_right_##name(node);                                    \\\n            }                                                                 \\\n        }                                                                     \\\n                                                                              \\\n        if (node->parent != NULL) {                                           \\\n            return splay_tree_##name(node);                                   \\\n        }                                                                     \\\n        return node;                                                          \\\n    }                                                                         \\\n\n\n#define splaysort(name, n, array) splay_sort_##name(n, array)\n\n#endif\n"
        },
        {
          "name": "stats.c",
          "type": "blob",
          "size": 106.8955078125,
          "content": "/*  stats.c -- This is the former bamcheck integrated into samtools/htslib.\n\n    Copyright (C) 2012-2024 Genome Research Ltd.\n\n    Author: Petr Danecek <pd3@sanger.ac.uk>\n    Author: Sam Nicholls <sam@samnicholls.net>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n/*  Assumptions, approximations and other issues:\n        - GC-depth graph does not split reads, the starting position determines which bin is incremented.\n            There are small overlaps between bins (max readlen-1). However, the bins are big (20k).\n        - coverage distribution ignores softclips and deletions\n        - some stats require sorted BAMs\n        - GC content graph can have an untidy, step-like pattern when BAM contains multiple read lengths.\n        - 'bases mapped' (stats->nbases_mapped) is calculated from read lengths given by BAM (core.l_qseq)\n        - With the -t option, the whole reads are used. Except for the number of mapped bases (cigar)\n            counts, no splicing is done, no indels or soft clips are considered, even small overlap is\n            good enough to include the read in the stats.\n        - GC content of reads not calculated for \"=\" sequences\n\n*/\n\n#include <config.h>\n\n#include <unistd.h> // for isatty()\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <getopt.h>\n#include <errno.h>\n#include <assert.h>\n#include <zlib.h>   // for crc32\n#include <htslib/faidx.h>\n#include <htslib/sam.h>\n#include <htslib/hts.h>\n#include <htslib/hts_defs.h>\n#include \"samtools.h\"\n#include <htslib/khash.h>\n#include <htslib/kstring.h>\n#include \"stats_isize.h\"\n#include \"sam_opts.h\"\n#include \"bedidx.h\"\n\n#define BWA_MIN_RDLEN 35\n#define DEFAULT_CHUNK_NO 8\n#define DEFAULT_PAIR_MAX 10000\n#define ERROR_LIMIT 200\n// From the spec\n// If 0x4 is set, no assumptions can be made about RNAME, POS, CIGAR, MAPQ, bits 0x2, 0x10, 0x100 and 0x800, and the bit 0x20 of the previous read in the template.\n#define IS_PAIRED(bam) ((bam)->core.flag&BAM_FPAIRED)\n#define IS_PAIRED_AND_MAPPED(bam) (((bam)->core.flag&BAM_FPAIRED) && !((bam)->core.flag&BAM_FUNMAP) && !((bam)->core.flag&BAM_FMUNMAP))\n#define IS_PROPERLYPAIRED(bam) (((bam)->core.flag&(BAM_FPAIRED|BAM_FPROPER_PAIR)) == (BAM_FPAIRED|BAM_FPROPER_PAIR) && !((bam)->core.flag&BAM_FUNMAP))\n#define IS_UNMAPPED(bam) ((bam)->core.flag&BAM_FUNMAP)\n#define IS_REVERSE(bam) ((bam)->core.flag&BAM_FREVERSE)\n#define IS_MATE_REVERSE(bam) ((bam)->core.flag&BAM_FMREVERSE)\n#define IS_READ1(bam) ((bam)->core.flag&BAM_FREAD1)\n#define IS_READ2(bam) ((bam)->core.flag&BAM_FREAD2)\n#define IS_DUP(bam) ((bam)->core.flag&BAM_FDUP)\n#define IS_ORIGINAL(bam) (((bam)->core.flag&(BAM_FSECONDARY|BAM_FSUPPLEMENTARY)) == 0)\n\n#define READ_ORDER_NONE 0\n#define READ_ORDER_FIRST 1\n#define READ_ORDER_LAST 2\n#define READ_ORDER_MIDDLE 3\n\n#define REG_INC 100\n#define POS_INC 1000\n\n// The GC-depth graph works as follows: split the reference sequence into\n// segments and calculate GC content and depth in each bin. Then sort\n// these segments by their GC and plot the depth distribution by means\n// of 10th, 25th, etc. depth percentiles.\ntypedef struct\n{\n    float gc;\n    uint32_t depth;\n}\ngc_depth_t;\n\n// For coverage distribution, a simple pileup\ntypedef struct\n{\n    hts_pos_t pos;\n    int size, start;\n    int *buffer;\n}\nround_buffer_t;\n\ntypedef struct\n{\n    int npos, mpos, cpos;\n    hts_pair_pos_t *pos;\n}\nregions_t;\n\ntypedef struct\n{\n    uint64_t a;\n    uint64_t c;\n    uint64_t g;\n    uint64_t t;\n    uint64_t n;\n    uint64_t other;\n}\nacgtno_count_t;\n\ntypedef struct\n{\n    char tag_name[3];\n    char qual_name[3];\n    uint32_t nbases;\n    int32_t tag_sep;    // Index of the separator (if present)\n    int32_t max_qual;\n    uint32_t offset;    // Where the tag stats info is located in the allocated memory\n}\nbarcode_info_t;\n\ntypedef struct\n{\n    // Auxiliary data\n    int flag_require, flag_filter;\n    faidx_t *fai;                   // Reference sequence for GC-depth graph\n    int argc;                       // Command line arguments to be printed on the output\n    char **argv;\n    int gcd_bin_size;           // The size of GC-depth bin\n    int nisize;         // The maximum insert size that the allocated array can hold - 0 indicates no limit\n    int trim_qual;      // bwa trim quality\n    float isize_main_bulk;  // There are always some unrealistically big insert sizes, report only the main part\n    int cov_min,cov_max,cov_step;   // Minimum, maximum coverage and size of the coverage bins\n    samFile* sam;\n    sam_hdr_t* sam_header;\n\n    // Filters\n    int filter_readlen;\n\n    // Misc\n    char *split_tag;      // Tag on which to perform stats splitting\n    char *split_prefix;   // Path or string prefix for filenames created when splitting\n    int remove_overlaps;\n    int cov_threshold;\n}\nstats_info_t;\n\ntypedef struct\n{\n    // Dimensions of the quality histogram holder (quals_1st,quals_2nd), GC content holder (gc_1st,gc_2nd),\n    //  insert size histogram holder\n    int nquals;         // The number of quality bins\n    int nbases;         // The maximum sequence length the allocated array can hold\n    int ngc;            // The size of gc_1st and gc_2nd\n    int nindels;        // The maximum indel length for indel distribution\n\n    // Arrays for the histogram data\n    uint64_t *quals_1st, *quals_2nd;\n    uint64_t *gc_1st, *gc_2nd;\n    acgtno_count_t *acgtno_cycles_1st, *acgtno_cycles_2nd;\n    acgtno_count_t *acgtno_revcomp;\n    uint64_t *read_lengths, *read_lengths_1st, *read_lengths_2nd;\n    uint64_t *insertions, *deletions;\n    uint64_t *ins_cycles_1st, *ins_cycles_2nd, *del_cycles_1st, *del_cycles_2nd;\n    isize_t *isize;\n    uint64_t* mapping_qualities;\n\n    // The extremes encountered\n    int max_len;            // Maximum read length\n    int max_len_1st;        // Maximum read length for forward reads\n    int max_len_2nd;        // Maximum read length for reverse reads\n    int max_qual;           // Maximum quality\n    int is_sorted;\n\n    // Summary numbers\n    uint64_t total_len;\n    uint64_t total_len_1st;\n    uint64_t total_len_2nd;\n    uint64_t total_len_dup;\n    uint64_t nreads_1st;\n    uint64_t nreads_2nd;\n    uint64_t nreads_other;\n    uint64_t nreads_filtered;\n    uint64_t nreads_dup;\n    uint64_t nreads_unmapped;\n    uint64_t nreads_single_mapped;\n    uint64_t nreads_paired_and_mapped;\n    uint64_t nreads_properly_paired;\n    uint64_t nreads_paired_tech;\n    uint64_t nreads_anomalous;\n    uint64_t nreads_mq0;\n    uint64_t nbases_mapped;\n    uint64_t nbases_mapped_cigar;\n    uint64_t nbases_trimmed;  // bwa trimmed bases\n    uint64_t nmismatches;\n    uint64_t nreads_QCfailed, nreads_secondary, nreads_supplementary;\n    struct {\n        uint32_t names, reads, quals;\n    } checksum;\n\n    // GC-depth related data\n    uint32_t ngcd, igcd;        // The maximum number of GC depth bins and index of the current bin\n    gc_depth_t *gcd;            // The GC-depth bins holder\n    int32_t tid;                // Position of the current bin\n    hts_pos_t gcd_pos, pos;     // Position of the last read\n\n    // Coverage distribution related data\n    int ncov;                       // The number of coverage bins\n    uint64_t *cov;                  // The coverage frequencies\n    round_buffer_t cov_rbuf;        // Pileup round buffer\n\n    // Mismatches by read cycle\n    uint8_t *rseq_buf;              // A buffer for reference sequence to check the mismatches against\n    int mrseq_buf;                  // The size of the buffer\n    hts_pos_t rseq_pos;             // The coordinate of the first base in the buffer\n    int64_t nrseq_buf;              // The used part of the buffer\n    uint64_t *mpc_buf;              // Mismatches per cycle\n\n    // Target regions\n    int nregions;\n    hts_pos_t reg_from, reg_to;\n    regions_t *regions;\n\n    // Auxiliary data\n    double sum_qual;                // For calculating average quality value\n    void *rg_hash;                  // Read groups to include, the array is null-terminated\n\n    // Split\n    char* split_name;\n\n    stats_info_t* info;             // Pointer to options and settings struct\n    hts_pair_pos_t *chunks;\n    uint32_t nchunks;\n\n    uint32_t pair_count;          // Number of active pairs in the pairing hash table\n    uint64_t target_count;        // Number of bases covered by the target file\n    uint32_t last_pair_tid;\n    uint32_t last_read_flush;\n\n    // Barcode statistics\n    acgtno_count_t *acgtno_barcode;\n    uint64_t *quals_barcode;\n    barcode_info_t *tags_barcode;\n    uint32_t ntags;\n    uint32_t error_number;\n}\nstats_t;\nKHASH_MAP_INIT_STR(c2stats, stats_t*)\n\ntypedef struct {\n    uint32_t first;     // 1 - first read, 2 - second read\n    uint32_t n, m;      // number of chunks, allocated chunks\n    hts_pair_pos_t *chunks;      // chunk array of size m\n} pair_t;\nKHASH_MAP_INIT_STR(qn2pair, pair_t*)\n\nKHASH_SET_INIT_STR(rg)\n\n\nstatic void HTS_NORETURN error(const char *format, ...);\nint is_in_regions(bam1_t *bam_line, stats_t *stats);\nvoid realloc_buffers(stats_t *stats, int seq_len);\n\nstatic int regions_lt(const void *r1, const void *r2) {\n    int64_t from_diff = ((hts_pair_pos_t *)r1)->beg - ((hts_pair_pos_t *)r2)->beg;\n    int64_t to_diff   = ((hts_pair_pos_t *)r1)->end - ((hts_pair_pos_t *)r2)->end;\n\n    return from_diff > 0 ? 1 : from_diff < 0 ? -1 : to_diff > 0 ? 1 : to_diff < 0 ? -1 : 0;\n}\n\n// Coverage distribution methods\nstatic inline int coverage_idx(int min, int max, int n, int step, int depth)\n{\n    if ( depth < min )\n        return 0;\n\n    if ( depth > max )\n        return n-1;\n\n    return 1 + (depth - min) / step;\n}\n\nstatic inline int round_buffer_lidx2ridx(int offset, int size, hts_pos_t refpos, hts_pos_t pos)\n{\n    return (offset + (pos-refpos) % size) % size;\n}\n\nvoid round_buffer_flush(stats_t *stats, hts_pos_t pos)\n{\n    int ibuf,idp;\n\n    if ( pos==stats->cov_rbuf.pos )\n        return;\n\n    hts_pos_t new_pos = pos;\n    if ( pos==-1 || pos - stats->cov_rbuf.pos >= stats->cov_rbuf.size )\n    {\n        // Flush the whole buffer, but in sequential order,\n        pos = stats->cov_rbuf.pos + stats->cov_rbuf.size - 1;\n    }\n\n    if ( pos < stats->cov_rbuf.pos )\n        error(\"Expected coordinates in ascending order, got %\"PRIhts_pos\" after %\"PRIhts_pos\"\\n\", pos, stats->cov_rbuf.pos);\n\n    int ifrom = stats->cov_rbuf.start;\n    int ito = round_buffer_lidx2ridx(stats->cov_rbuf.start, stats->cov_rbuf.size, stats->cov_rbuf.pos, pos-1);\n    if ( ifrom>ito )\n    {\n        for (ibuf=ifrom; ibuf<stats->cov_rbuf.size; ibuf++)\n        {\n            if ( !stats->cov_rbuf.buffer[ibuf] )\n                continue;\n            idp = coverage_idx(stats->info->cov_min,stats->info->cov_max,stats->ncov,stats->info->cov_step,stats->cov_rbuf.buffer[ibuf]);\n            stats->cov[idp]++;\n            stats->cov_rbuf.buffer[ibuf] = 0;\n        }\n        ifrom = 0;\n    }\n    for (ibuf=ifrom; ibuf<=ito; ibuf++)\n    {\n        if ( !stats->cov_rbuf.buffer[ibuf] )\n            continue;\n        idp = coverage_idx(stats->info->cov_min,stats->info->cov_max,stats->ncov,stats->info->cov_step,stats->cov_rbuf.buffer[ibuf]);\n        stats->cov[idp]++;\n        stats->cov_rbuf.buffer[ibuf] = 0;\n    }\n    stats->cov_rbuf.start = (new_pos==-1) ? 0 : round_buffer_lidx2ridx(stats->cov_rbuf.start, stats->cov_rbuf.size, stats->cov_rbuf.pos, pos);\n    stats->cov_rbuf.pos   = new_pos;\n}\n\n/**\n * [from, to) - 0 based half-open\n */\nstatic void round_buffer_insert_read(round_buffer_t *rbuf, hts_pos_t from, hts_pos_t to)\n{\n    if ( to-from > rbuf->size )\n        error(\"The read length too big (%\"PRIhts_pos\"), please increase the buffer length (currently %d)\\n\", to-from, rbuf->size);\n    if ( from < rbuf->pos )\n        error(\"The reads are not sorted (%\"PRIhts_pos\" comes after %\"PRIhts_pos\").\\n\", from, rbuf->pos);\n\n    int ifrom, ito, ibuf;\n    ifrom = round_buffer_lidx2ridx(rbuf->start, rbuf->size, rbuf->pos, from);\n    ito   = round_buffer_lidx2ridx(rbuf->start, rbuf->size, rbuf->pos, to);\n    if ( ifrom>ito )\n    {\n        for (ibuf=ifrom; ibuf<rbuf->size; ibuf++)\n            rbuf->buffer[ibuf]++;\n        ifrom = 0;\n    }\n    for (ibuf=ifrom; ibuf<ito; ibuf++)\n        rbuf->buffer[ibuf]++;\n}\n\n// Calculate the number of bases in the read trimmed by BWA\nint bwa_trim_read(int trim_qual, uint8_t *quals, int len, int reverse)\n{\n    if ( len<BWA_MIN_RDLEN ) return 0;\n\n    // Although the name implies that the read cannot be trimmed to more than BWA_MIN_RDLEN,\n    //  the calculation can in fact trim it to (BWA_MIN_RDLEN-1). (bwa_trim_read in bwa/bwaseqio.c).\n    int max_trimmed = len - BWA_MIN_RDLEN + 1;\n    int l, sum=0, max_sum=0, max_l=0;\n\n    for (l=0; l<max_trimmed; l++)\n    {\n        sum += trim_qual - quals[ reverse ? l : len-1-l ];\n        if ( sum<0 ) break;\n        if ( sum>max_sum )\n        {\n            max_sum = sum;\n            // This is the correct way, but bwa clips from some reason one base less\n            // max_l   = l+1;\n            max_l   = l;\n        }\n    }\n    return max_l;\n}\n\n\nvoid count_indels(stats_t *stats,bam1_t *bam_line)\n{\n    int is_fwd = IS_REVERSE(bam_line) ? 0 : 1;\n    uint32_t order = IS_PAIRED(bam_line) ? (IS_READ1(bam_line) ? READ_ORDER_FIRST : 0) + (IS_READ2(bam_line) ? READ_ORDER_LAST : 0) : READ_ORDER_FIRST;\n    int icig;\n    int icycle = 0;\n    int read_len = bam_line->core.l_qseq;\n    for (icig=0; icig<bam_line->core.n_cigar; icig++)\n    {\n        int cig  = bam_cigar_op(bam_get_cigar(bam_line)[icig]);\n        int ncig = bam_cigar_oplen(bam_get_cigar(bam_line)[icig]);\n        if ( !ncig ) continue;  // curiously, this can happen: 0D\n\n        if ( cig==BAM_CINS )\n        {\n            int idx = is_fwd ? icycle : read_len-icycle-ncig;\n            if ( idx<0 )\n                error(\"FIXME: read_len=%d vs icycle=%d\\n\", read_len,icycle);\n            if ( idx >= stats->nbases || idx<0 ) error(\"FIXME: %d vs %d, %s:%\"PRIhts_pos\" %s\\n\", idx, stats->nbases, sam_hdr_tid2name(stats->info->sam_header, bam_line->core.tid), bam_line->core.pos+1, bam_get_qname(bam_line));\n            if ( order == READ_ORDER_FIRST )\n                stats->ins_cycles_1st[idx]++;\n            if ( order == READ_ORDER_LAST )\n                stats->ins_cycles_2nd[idx]++;\n            icycle += ncig;\n            if ( ncig<=stats->nindels )\n                stats->insertions[ncig-1]++;\n            continue;\n        }\n        if ( cig==BAM_CDEL )\n        {\n            int idx = is_fwd ? icycle-1 : read_len-icycle-1;\n            if ( idx<0 ) continue;  // discard meaningless deletions\n            if ( idx >= stats->nbases ) error(\"FIXME: %d vs %d\\n\", idx,stats->nbases);\n            if ( order == READ_ORDER_FIRST )\n                stats->del_cycles_1st[idx]++;\n            if ( order == READ_ORDER_LAST )\n                stats->del_cycles_2nd[idx]++;\n            if ( ncig<=stats->nindels )\n                stats->deletions[ncig-1]++;\n            continue;\n        }\n        if ( cig!=BAM_CREF_SKIP && cig!=BAM_CHARD_CLIP && cig!=BAM_CPAD )\n            icycle += ncig;\n    }\n}\n\nint unclipped_length(bam1_t *bam_line)\n{\n    int icig, read_len = bam_line->core.l_qseq;\n    for (icig=0; icig<bam_line->core.n_cigar; icig++)\n    {\n        int cig = bam_cigar_op(bam_get_cigar(bam_line)[icig]);\n        if ( cig==BAM_CHARD_CLIP )\n            read_len += bam_cigar_oplen(bam_get_cigar(bam_line)[icig]);\n    }\n    return read_len;\n}\n\nvoid count_mismatches_per_cycle(stats_t *stats, bam1_t *bam_line, int read_len)\n{\n    int is_fwd = IS_REVERSE(bam_line) ? 0 : 1;\n    int icig, iread=0, icycle=0;\n    hts_pos_t iref = bam_line->core.pos - stats->rseq_pos;\n    uint8_t *read  = bam_get_seq(bam_line);\n    uint8_t *quals = bam_get_qual(bam_line);\n    uint64_t *mpc_buf = stats->mpc_buf;\n    for (icig=0; icig<bam_line->core.n_cigar; icig++)\n    {\n        int cig  = bam_cigar_op(bam_get_cigar(bam_line)[icig]);\n        int ncig = bam_cigar_oplen(bam_get_cigar(bam_line)[icig]);\n        if ( cig==BAM_CINS )\n        {\n            iread  += ncig;\n            icycle += ncig;\n            continue;\n        }\n        if ( cig==BAM_CDEL )\n        {\n            iref += ncig;\n            continue;\n        }\n        if ( cig==BAM_CSOFT_CLIP )\n        {\n            icycle += ncig;\n            // Soft-clips are present in the sequence, but the position of the read marks a start of the sequence after clipping\n            //   iref += ncig;\n            iread  += ncig;\n            continue;\n        }\n        if ( cig==BAM_CHARD_CLIP )\n        {\n            icycle += ncig;\n            continue;\n        }\n        // Ignore H and N CIGARs. The letter are inserted e.g. by TopHat and often require very large\n        //  chunk of refseq in memory. Not very frequent and not noticeable in the stats.\n        if ( cig==BAM_CREF_SKIP || cig==BAM_CHARD_CLIP || cig==BAM_CPAD ) continue;\n        if ( cig!=BAM_CMATCH && cig!=BAM_CEQUAL && cig!=BAM_CDIFF ) // not relying on precalculated diffs\n            error(\"TODO: cigar %d, %s:%\"PRIhts_pos\" %s\\n\", cig, sam_hdr_tid2name(stats->info->sam_header, bam_line->core.tid), bam_line->core.pos+1, bam_get_qname(bam_line));\n\n        if ( ncig+iref > stats->nrseq_buf )\n            error(\"FIXME: %d+%\"PRIhts_pos\" > %\"PRId64\", %s, %s:%\"PRIhts_pos\"\\n\", ncig, iref, stats->nrseq_buf, bam_get_qname(bam_line), sam_hdr_tid2name(stats->info->sam_header, bam_line->core.tid), bam_line->core.pos+1);\n\n        int im;\n        for (im=0; im<ncig; im++)\n        {\n            uint8_t cread = bam_seqi(read,iread);\n            uint8_t cref  = stats->rseq_buf[iref];\n\n            // ---------------15\n            // =ACMGRSVTWYHKDBN\n            if ( cread==15 )\n            {\n                int idx = is_fwd ? icycle : read_len-icycle-1;\n                if ( idx>stats->max_len )\n                    error(\"mpc: %d>%d\\n\",idx,stats->max_len);\n                idx = idx*stats->nquals;\n                if ( idx>=stats->nquals*stats->nbases )\n                    error(\"FIXME: mpc_buf overflow\\n\");\n                mpc_buf[idx]++;\n            }\n            else if ( cref && cread && cref!=cread )\n            {\n                uint8_t qual = quals[iread] + 1;\n                if ( qual>=stats->nquals )\n                    error(\"TODO: quality too high %d>=%d (%s %\"PRIhts_pos\" %s)\\n\", qual, stats->nquals, sam_hdr_tid2name(stats->info->sam_header, bam_line->core.tid), bam_line->core.pos+1, bam_get_qname(bam_line));\n\n                int idx = is_fwd ? icycle : read_len-icycle-1;\n                if ( idx>stats->max_len )\n                    error(\"mpc: %d>%d (%s %\"PRIhts_pos\" %s)\\n\", idx, stats->max_len, sam_hdr_tid2name(stats->info->sam_header, bam_line->core.tid), bam_line->core.pos+1, bam_get_qname(bam_line));\n\n                idx = idx*stats->nquals + qual;\n                if ( idx>=stats->nquals*stats->nbases )\n                    error(\"FIXME: mpc_buf overflow\\n\");\n                mpc_buf[idx]++;\n            }\n\n            iref++;\n            iread++;\n            icycle++;\n        }\n    }\n}\n\nvoid read_ref_seq(stats_t *stats, int32_t tid, hts_pos_t pos, hts_pos_t end)\n{\n    int i;\n    hts_pos_t fai_ref_len;\n    char *fai_ref;\n\n    if (end < pos+stats->mrseq_buf-1)\n        end = pos+stats->mrseq_buf-1;\n    else if (stats->mrseq_buf < end - pos) {\n        size_t sz = end - pos;\n        uint8_t *new_rseq = realloc(stats->rseq_buf, sz);\n        if (!new_rseq)\n            error(\"Couldn't expand the reference sequence buffer\\n\");\n        stats->rseq_buf = new_rseq;\n        stats->mrseq_buf = sz;\n    }\n\n    fai_ref = faidx_fetch_seq64(stats->info->fai, sam_hdr_tid2name(stats->info->sam_header, tid), pos, pos+stats->mrseq_buf-1, &fai_ref_len);\n    if ( fai_ref_len < 0 ) error(\"Failed to fetch the sequence \\\"%s\\\"\\n\", sam_hdr_tid2name(stats->info->sam_header, tid));\n\n    uint8_t *ptr = stats->rseq_buf;\n    for (i=0; i<fai_ref_len; i++)\n    {\n        // Conversion between uint8_t coding and ACGT\n        //      -12-4---8-------\n        //      =ACMGRSVTWYHKDBN\n        switch (fai_ref[i])\n        {\n            case 'A':\n            case 'a': *ptr = 1; break;\n            case 'C':\n            case 'c': *ptr = 2; break;\n            case 'G':\n            case 'g': *ptr = 4; break;\n            case 'T':\n            case 't': *ptr = 8; break;\n            default:  *ptr = 0; break;\n        }\n        ptr++;\n    }\n    free(fai_ref);\n\n    if ( fai_ref_len < stats->mrseq_buf ) memset(ptr,0, stats->mrseq_buf - fai_ref_len);\n    stats->nrseq_buf = fai_ref_len;\n    stats->rseq_pos  = pos;\n    stats->tid       = tid;\n}\n\nfloat fai_gc_content(stats_t *stats, hts_pos_t pos, int len)\n{\n    uint32_t gc,count,c;\n    hts_pos_t i = pos - stats->rseq_pos, ito = i + len;\n    assert( i>=0 );\n\n    if (  ito > stats->nrseq_buf ) ito = stats->nrseq_buf;\n\n    // Count GC content\n    gc = count = 0;\n    for (; i<ito; i++)\n    {\n        c = stats->rseq_buf[i];\n        if ( c==2 || c==4 )\n        {\n            gc++;\n            count++;\n        }\n        else if ( c==1 || c==8 )\n            count++;\n    }\n    return count ? (float)gc/count : 0;\n}\n\nvoid realloc_rseq_buffer(stats_t *stats)\n{\n    int n = stats->nbases*10;\n    if ( stats->info->gcd_bin_size > n ) n = stats->info->gcd_bin_size;\n    if ( stats->mrseq_buf<n )\n    {\n        stats->rseq_buf = realloc(stats->rseq_buf,sizeof(uint8_t)*n);\n        if (!stats->rseq_buf) {\n            error(\"Could not reallocate reference sequence buffer\");\n        }\n        stats->mrseq_buf = n;\n    }\n}\n\nvoid realloc_gcd_buffer(stats_t *stats, int seq_len)\n{\n    hts_expand0(gc_depth_t,stats->igcd+1,stats->ngcd,stats->gcd);\n    realloc_rseq_buffer(stats);\n}\n\nvoid realloc_buffers(stats_t *stats, int seq_len)\n{\n    int n = 2*(1 + seq_len - stats->nbases) + stats->nbases;\n\n    stats->quals_1st = realloc(stats->quals_1st, n*stats->nquals*sizeof(uint64_t));\n    if ( !stats->quals_1st )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,n*stats->nquals*sizeof(uint64_t));\n    memset(stats->quals_1st + stats->nbases*stats->nquals, 0, (n-stats->nbases)*stats->nquals*sizeof(uint64_t));\n\n    stats->quals_2nd = realloc(stats->quals_2nd, n*stats->nquals*sizeof(uint64_t));\n    if ( !stats->quals_2nd )\n        error(\"Could not realloc buffers, the sequence too long: %d (2x%ld)\\n\", seq_len,n*stats->nquals*sizeof(uint64_t));\n    memset(stats->quals_2nd + stats->nbases*stats->nquals, 0, (n-stats->nbases)*stats->nquals*sizeof(uint64_t));\n\n    if ( stats->mpc_buf )\n    {\n        stats->mpc_buf = realloc(stats->mpc_buf, n*stats->nquals*sizeof(uint64_t));\n        if ( !stats->mpc_buf )\n            error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,n*stats->nquals*sizeof(uint64_t));\n        memset(stats->mpc_buf + stats->nbases*stats->nquals, 0, (n-stats->nbases)*stats->nquals*sizeof(uint64_t));\n    }\n\n    stats->acgtno_cycles_1st = realloc(stats->acgtno_cycles_1st, n*sizeof(acgtno_count_t));\n    if ( !stats->acgtno_cycles_1st )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len, n*sizeof(acgtno_count_t));\n    memset(stats->acgtno_cycles_1st + stats->nbases, 0, (n-stats->nbases)*sizeof(acgtno_count_t));\n\n    stats->acgtno_cycles_2nd = realloc(stats->acgtno_cycles_2nd, n*sizeof(acgtno_count_t));\n    if ( !stats->acgtno_cycles_2nd )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len, n*sizeof(acgtno_count_t));\n    memset(stats->acgtno_cycles_2nd + stats->nbases, 0, (n-stats->nbases)*sizeof(acgtno_count_t));\n\n    stats->acgtno_revcomp = realloc(stats->acgtno_revcomp, n*sizeof(acgtno_count_t));\n    if ( !stats->acgtno_revcomp )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len, n*sizeof(acgtno_count_t));\n    memset(stats->acgtno_revcomp + stats->nbases, 0, (n-stats->nbases)*sizeof(acgtno_count_t));\n\n    stats->read_lengths = realloc(stats->read_lengths, n*sizeof(uint64_t));\n    if ( !stats->read_lengths )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,n*sizeof(uint64_t));\n    memset(stats->read_lengths + stats->nbases, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->read_lengths_1st = realloc(stats->read_lengths_1st, n*sizeof(uint64_t));\n    if ( !stats->read_lengths_1st )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,n*sizeof(uint64_t));\n    memset(stats->read_lengths_1st + stats->nbases, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->read_lengths_2nd = realloc(stats->read_lengths_2nd, n*sizeof(uint64_t));\n    if ( !stats->read_lengths_2nd )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,n*sizeof(uint64_t));\n    memset(stats->read_lengths_2nd + stats->nbases, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->insertions = realloc(stats->insertions, n*sizeof(uint64_t));\n    if ( !stats->insertions )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,n*sizeof(uint64_t));\n    memset(stats->insertions + stats->nbases, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->deletions = realloc(stats->deletions, n*sizeof(uint64_t));\n    if ( !stats->deletions )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,n*sizeof(uint64_t));\n    memset(stats->deletions + stats->nbases, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->ins_cycles_1st = realloc(stats->ins_cycles_1st, (n+1)*sizeof(uint64_t));\n    if ( !stats->ins_cycles_1st )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,(n+1)*sizeof(uint64_t));\n    memset(stats->ins_cycles_1st + stats->nbases + 1, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->ins_cycles_2nd = realloc(stats->ins_cycles_2nd, (n+1)*sizeof(uint64_t));\n    if ( !stats->ins_cycles_2nd )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,(n+1)*sizeof(uint64_t));\n    memset(stats->ins_cycles_2nd + stats->nbases + 1, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->del_cycles_1st = realloc(stats->del_cycles_1st, (n+1)*sizeof(uint64_t));\n    if ( !stats->del_cycles_1st )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,(n+1)*sizeof(uint64_t));\n    memset(stats->del_cycles_1st + stats->nbases + 1, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->del_cycles_2nd = realloc(stats->del_cycles_2nd, (n+1)*sizeof(uint64_t));\n    if ( !stats->del_cycles_2nd )\n        error(\"Could not realloc buffers, the sequence too long: %d (%ld)\\n\", seq_len,(n+1)*sizeof(uint64_t));\n    memset(stats->del_cycles_2nd + stats->nbases + 1, 0, (n-stats->nbases)*sizeof(uint64_t));\n\n    stats->nbases = n;\n\n    // Realloc the coverage distribution buffer\n    int *rbuffer = calloc(sizeof(int),seq_len*5);\n    if (!rbuffer) {\n        error(\"Could not allocate coverage distribution buffer\");\n    }\n    n = stats->cov_rbuf.size-stats->cov_rbuf.start;\n    memcpy(rbuffer,stats->cov_rbuf.buffer+stats->cov_rbuf.start,n);\n    if ( stats->cov_rbuf.start>1 )\n        memcpy(rbuffer+n,stats->cov_rbuf.buffer,stats->cov_rbuf.start);\n    stats->cov_rbuf.start = 0;\n    free(stats->cov_rbuf.buffer);\n    stats->cov_rbuf.buffer = rbuffer;\n    stats->cov_rbuf.size = seq_len*5;\n\n    realloc_rseq_buffer(stats);\n}\n\nvoid update_checksum(bam1_t *bam_line, stats_t *stats)\n{\n    uint8_t *name = (uint8_t*) bam_get_qname(bam_line);\n    int len = 0;\n    while ( name[len] ) len++;\n    stats->checksum.names +=  crc32(0L, name, len);\n\n    int seq_len = bam_line->core.l_qseq;\n    if ( !seq_len ) return;\n\n    uint8_t *seq = bam_get_seq(bam_line);\n    stats->checksum.reads += crc32(0L, seq, (seq_len+1)/2);\n\n    uint8_t *qual = bam_get_qual(bam_line);\n    stats->checksum.quals += crc32(0L, qual, (seq_len+1)/2);\n}\n\n// Collect statistics about the barcode tags specified by init_barcode_tags method\nstatic void collect_barcode_stats(bam1_t* bam_line, stats_t* stats) {\n    uint32_t nbases, tag, i;\n    acgtno_count_t *acgtno;\n    uint64_t *quals;\n    int32_t *separator, *maxqual;\n\n    for (tag = 0; tag < stats->ntags; tag++) {\n        const char *barcode_tag = stats->tags_barcode[tag].tag_name, *qual_tag = stats->tags_barcode[tag].qual_name;\n        uint8_t* bc = bam_aux_get(bam_line, barcode_tag);\n        if (!bc)\n            continue;\n\n        char* barcode = bam_aux2Z(bc);\n        if (!barcode)\n            continue;\n\n        uint32_t barcode_len = strlen(barcode);\n        if (!barcode_len) {\n            continue;        //consider 0 size barcode same as no barcode - avoids issues with realloc below\n        }\n        if (!stats->tags_barcode[tag].nbases) { // tag seen for the first time\n            uint32_t offset = 0;\n            for (i = 0; i < stats->ntags; i++)\n                offset += stats->tags_barcode[i].nbases;\n\n            stats->tags_barcode[tag].offset = offset;\n            stats->tags_barcode[tag].nbases = barcode_len;\n            stats->acgtno_barcode = realloc(stats->acgtno_barcode, (offset + barcode_len) * sizeof(acgtno_count_t));\n            stats->quals_barcode  = realloc(stats->quals_barcode, (offset + barcode_len) * stats->nquals * sizeof(uint64_t));\n\n            if (!stats->acgtno_barcode || !stats->quals_barcode)\n                error(\"Error allocating memory. Aborting!\\n\");\n\n            memset(stats->acgtno_barcode + offset, 0, barcode_len*sizeof(acgtno_count_t));\n            memset(stats->quals_barcode + offset*stats->nquals, 0, barcode_len*stats->nquals*sizeof(uint64_t));\n        }\n\n        nbases = stats->tags_barcode[tag].nbases;\n        if (barcode_len > nbases) {\n            fprintf(stderr, \"Barcodes with tag %s differ in length at sequence '%s'\\n\", barcode_tag, bam_get_qname(bam_line));\n            continue;\n        }\n\n        acgtno = stats->acgtno_barcode + stats->tags_barcode[tag].offset;\n        quals = stats->quals_barcode + stats->tags_barcode[tag].offset*stats->nquals;\n        maxqual = &stats->tags_barcode[tag].max_qual;\n        separator = &stats->tags_barcode[tag].tag_sep;\n        int error_flag = 0;\n\n        for (i = 0; i < barcode_len; i++) {\n            switch (barcode[i]) {\n            case 'A':\n                acgtno[i].a++;\n                break;\n            case 'C':\n                acgtno[i].c++;\n                break;\n            case 'G':\n                acgtno[i].g++;\n                break;\n            case 'T':\n                acgtno[i].t++;\n                break;\n            case 'N':\n                acgtno[i].n++;\n                break;\n            default:\n                if (*separator >= 0) {\n                    if (*separator != i) {\n                        if (stats->error_number < ERROR_LIMIT) {\n                            fprintf(stderr, \"Barcode separator for tag %s is in a different position or wrong barcode content('%s') at sequence '%s'\\n\", barcode_tag, barcode, bam_get_qname(bam_line));\n                            stats->error_number++;\n                        }\n                        error_flag = 1;\n                    }\n                } else {\n                    *separator = i;\n                }\n            }\n\n            /* don't process the rest of the tag bases */\n            if (error_flag)\n                break;\n        }\n\n        /* skip to the next tag */\n        if (error_flag)\n            continue;\n\n        uint8_t* qt = bam_aux_get(bam_line, qual_tag);\n        if (!qt)\n            continue;\n\n        char* barqual = bam_aux2Z(qt);\n        if (!barqual)\n            continue;\n\n        uint32_t barqual_len = strlen(barqual);\n        if (barqual_len == barcode_len) {\n            for (i = 0; i < barcode_len; i++) {\n                int32_t qual = (int32_t)barqual[i] - '!';  // Phred + 33\n                if (qual >= 0 && qual < stats->nquals) {\n                    quals[i * stats->nquals + qual]++;\n                    if (qual > *maxqual)\n                        *maxqual = qual;\n                }\n            }\n        } else {\n            if (stats->error_number++ < ERROR_LIMIT) {\n                fprintf(stderr, \"%s length and %s length don't match for sequence '%s'\\n\", barcode_tag, qual_tag, bam_get_qname(bam_line));\n            }\n        }\n    }\n}\n\n// These stats should only be calculated for the original reads ignoring\n// supplementary artificial reads otherwise we'll accidentally double count\nvoid collect_orig_read_stats(bam1_t *bam_line, stats_t *stats, int* gc_count_out)\n{\n    int seq_len = bam_line->core.l_qseq;\n    stats->total_len += seq_len; // This ignores clipping so only count primary\n\n    if ( bam_line->core.flag & BAM_FQCFAIL ) stats->nreads_QCfailed++;\n    if ( bam_line->core.flag & BAM_FPAIRED ) stats->nreads_paired_tech++;\n\n    uint32_t order = IS_PAIRED(bam_line) ? (IS_READ1(bam_line) ? READ_ORDER_FIRST : 0) + (IS_READ2(bam_line) ? READ_ORDER_LAST : 0) : READ_ORDER_FIRST;\n\n    // Count GC and ACGT per cycle. Note that cycle is approximate, clipping is ignored\n    uint8_t *seq  = bam_get_seq(bam_line);\n    int i, read_cycle, gc_count = 0, reverse = IS_REVERSE(bam_line);\n\n    acgtno_count_t *acgtno_cycles = (order == READ_ORDER_FIRST) ? stats->acgtno_cycles_1st : (order == READ_ORDER_LAST) ?  stats->acgtno_cycles_2nd : NULL ;\n    if (acgtno_cycles) {\n        for (i=0; i<seq_len; i++)\n        {\n            // Read cycle for current index\n            read_cycle = (reverse ? seq_len-i-1 : i);\n\n            // Conversion from uint8_t coding:\n            //      -12-4---8------5\n            //      =ACMGRSVTWYHKDBN\n            switch (bam_seqi(seq, i)) {\n            case 1:\n                acgtno_cycles[ read_cycle ].a++;\n                reverse ? stats->acgtno_revcomp[ read_cycle ].t++ : stats->acgtno_revcomp[ read_cycle ].a++;\n                break;\n            case 2:\n                acgtno_cycles[ read_cycle ].c++;\n                reverse ? stats->acgtno_revcomp[ read_cycle ].g++ : stats->acgtno_revcomp[ read_cycle ].c++;\n                gc_count++;\n                break;\n            case 4:\n                acgtno_cycles[ read_cycle ].g++;\n                reverse ? stats->acgtno_revcomp[ read_cycle ].c++ : stats->acgtno_revcomp[ read_cycle ].g++;\n                gc_count++;\n                break;\n            case 8:\n                reverse ? stats->acgtno_revcomp[ read_cycle ].a++ : stats->acgtno_revcomp[ read_cycle ].t++;\n                acgtno_cycles[ read_cycle ].t++;\n                break;\n            case 15:\n                acgtno_cycles[ read_cycle ].n++;\n                break;\n            default:\n                /*\n                 * count \"=\" sequences in \"other\" along\n                 * with MRSVWYHKDB ambiguity codes\n                 */\n                acgtno_cycles[ read_cycle ].other++;\n                break;\n            }\n        }\n    }\n    int gc_idx_min = gc_count*(stats->ngc-1)/seq_len;\n    int gc_idx_max = (gc_count+1)*(stats->ngc-1)/seq_len;\n    if ( gc_idx_max >= stats->ngc ) gc_idx_max = stats->ngc - 1;\n\n    // Determine which array (1st or 2nd read) will these stats go to,\n    //  trim low quality bases from end the same way BWA does,\n    //  fill GC histogram\n    uint64_t *quals = NULL;\n    uint8_t *bam_quals = bam_get_qual(bam_line);\n\n    switch (order) {\n    case READ_ORDER_FIRST:\n        quals = stats->quals_1st;\n        stats->nreads_1st++;\n        stats->total_len_1st += seq_len;\n        for (i=gc_idx_min; i<gc_idx_max; i++)\n            stats->gc_1st[i]++;\n        break;\n    case READ_ORDER_LAST:\n        quals  = stats->quals_2nd;\n        stats->nreads_2nd++;\n        stats->total_len_2nd += seq_len;\n        for (i=gc_idx_min; i<gc_idx_max; i++)\n            stats->gc_2nd[i]++;\n        break;\n    default:\n        stats->nreads_other++;\n    }\n    if ( stats->info->trim_qual>0 )\n        stats->nbases_trimmed += bwa_trim_read(stats->info->trim_qual, bam_quals, seq_len, reverse);\n\n    // Quality histogram and average quality. Clipping is neglected.\n    if (quals) {\n        for (i=0; i<seq_len; i++)\n        {\n            uint8_t qual = bam_quals[ reverse ? seq_len-i-1 : i];\n            if ( qual>=stats->nquals )\n                error(\"TODO: quality too high %d>=%d (%s %\"PRIhts_pos\" %s)\\n\", qual, stats->nquals, sam_hdr_tid2name(stats->info->sam_header, bam_line->core.tid), bam_line->core.pos+1, bam_get_qname(bam_line));\n            if ( qual>stats->max_qual )\n                stats->max_qual = qual;\n\n            quals[ i*stats->nquals+qual ]++;\n            stats->sum_qual += qual;\n        }\n    }\n\n    // Barcode statistics\n    if (order == READ_ORDER_FIRST) {\n        collect_barcode_stats(bam_line, stats);\n    }\n\n    // Look at the flags and increment appropriate counters (mapped, paired, etc)\n    if ( IS_UNMAPPED(bam_line) )\n    {\n        stats->nreads_unmapped++;\n    }\n    else\n    {\n        stats->nbases_mapped += seq_len; // This ignores clipping so only count primary\n\n        if ( !bam_line->core.qual )\n            stats->nreads_mq0++;\n        if ( !IS_PAIRED_AND_MAPPED(bam_line) )\n            stats->nreads_single_mapped++;\n        else\n        {\n            stats->nreads_paired_and_mapped++;\n\n            if (IS_PROPERLYPAIRED(bam_line)) stats->nreads_properly_paired++;\n\n            if ( bam_line->core.tid!=bam_line->core.mtid )\n                stats->nreads_anomalous++;\n        }\n    }\n    *gc_count_out = gc_count;\n}\n\nstatic int cleanup_overlaps(khash_t(qn2pair) *read_pairs, hts_pos_t max) {\n    if ( !read_pairs )\n        return 0;\n\n    int count = 0;\n    khint_t k;\n    for (k = kh_begin(read_pairs); k < kh_end(read_pairs); k++) {\n        if ( kh_exist(read_pairs, k) ) {\n            char *key = (char *)kh_key(read_pairs, k);\n            pair_t *val = kh_val(read_pairs, k);\n            if ( val && val->chunks ) {\n                if ( val->chunks[val->n-1].end < max ) {\n                    free(val->chunks);\n                    free(val);\n                    free(key);\n                    kh_del(qn2pair, read_pairs, k);\n                    count++;\n                }\n            } else {\n                free(key);\n                kh_del(qn2pair, read_pairs, k);\n                count++;\n            }\n        }\n    }\n    if ( max == INT64_MAX )\n        kh_destroy(qn2pair, read_pairs);\n\n    return count;\n}\n\n/**\n * [pmin, pmax) - 0 based half-open\n */\nstatic void remove_overlaps(bam1_t *bam_line, khash_t(qn2pair) *read_pairs, stats_t *stats, hts_pos_t pmin, hts_pos_t pmax) {\n    if ( !bam_line || !read_pairs || !stats )\n        return;\n\n    uint32_t order = (IS_READ1(bam_line) ? READ_ORDER_FIRST : 0) + (IS_READ2(bam_line) ? READ_ORDER_LAST : 0);\n    if ( !(bam_line->core.flag & BAM_FPAIRED) ||\n         (bam_line->core.flag & BAM_FMUNMAP) ||\n         (llabs(bam_line->core.isize) >= 2*bam_line->core.l_qseq) ||\n         (order != READ_ORDER_FIRST && order != READ_ORDER_LAST) ) {\n        if ( pmin >= 0 )\n            round_buffer_insert_read(&(stats->cov_rbuf), pmin, pmax);\n        return;\n    }\n\n    char *qname = bam_get_qname(bam_line);\n    if ( !qname ) {\n        fprintf(stderr, \"Error retrieving qname for line starting at pos %\"PRIhts_pos\"\\n\", bam_line->core.pos);\n        return;\n    }\n\n    khint_t k = kh_get(qn2pair, read_pairs, qname);\n    if ( k == kh_end(read_pairs) ) { //first chunk from this template\n        if ( pmin == -1 )\n            return;\n\n        int ret;\n        char *s = strdup(qname);\n        if ( !s ) {\n            fprintf(stderr, \"Error allocating memory\\n\");\n            return;\n        }\n\n        k = kh_put(qn2pair, read_pairs, s, &ret);\n        if ( -1 == ret ) {\n            error(\"Error inserting read '%s' in pair hash table\\n\", qname);\n        }\n\n        pair_t *pc = calloc(1, sizeof(pair_t));\n        if ( !pc ) {\n            fprintf(stderr, \"Error allocating memory\\n\");\n            return;\n        }\n\n        pc->m = DEFAULT_CHUNK_NO;\n        pc->chunks = calloc(pc->m, sizeof(hts_pair_pos_t));\n        if ( !pc->chunks ) {\n            fprintf(stderr, \"Error allocating memory\\n\");\n            free(pc);\n            return;\n        }\n\n        pc->chunks[0].beg = pmin;\n        pc->chunks[0].end = pmax;\n        pc->n = 1;\n        pc->first = order;\n\n        kh_val(read_pairs, k) = pc;\n        stats->pair_count++;\n    } else { //template already present\n        pair_t *pc = kh_val(read_pairs, k);\n        if ( !pc ) {\n            fprintf(stderr, \"Invalid hash table entry\\n\");\n            return;\n        }\n\n        if ( order == pc->first ) { //chunk from an existing line\n            if ( pmin == -1 )\n                return;\n\n            if ( pc->n == pc->m ) {\n                hts_pair_pos_t *tmp = realloc(pc->chunks, (pc->m<<1)*sizeof(hts_pair_pos_t));\n                if ( !tmp ) {\n                    fprintf(stderr, \"Error allocating memory\\n\");\n                    return;\n                }\n                pc->chunks = tmp;\n                pc->m<<=1;\n            }\n\n            pc->chunks[pc->n].beg = pmin;\n            pc->chunks[pc->n].end = pmax;\n            pc->n++;\n        } else { //the other line, check for overlapping\n            if ( pmin == -1 && kh_exist(read_pairs, k) ) { //job done, delete entry\n                char *key = (char *)kh_key(read_pairs, k);\n                pair_t *val = kh_val(read_pairs, k);\n                if ( val) {\n                    free(val->chunks);\n                    free(val);\n                }\n                free(key);\n                kh_del(qn2pair, read_pairs, k);\n                stats->pair_count--;\n                return;\n            }\n\n            int i;\n            for (i=0; i<pc->n; i++) {\n                if ( pmin >= pc->chunks[i].end )\n                    continue;\n\n                if ( pmax <= pc->chunks[i].beg ) //no overlap\n                    break;\n\n                if ( pmin < pc->chunks[i].beg ) { //overlap at the beginning\n                    round_buffer_insert_read(&(stats->cov_rbuf), pmin, pc->chunks[i].beg);\n                    pmin = pc->chunks[i].beg;\n                }\n\n                if ( pmax <= pc->chunks[i].end ) { //completely contained\n                    stats->nbases_mapped_cigar -= (pmax - pmin);\n                    return;\n                } else {                           //overlap at the end\n                    stats->nbases_mapped_cigar -= (pc->chunks[i].end - pmin);\n                    pmin = pc->chunks[i].end;\n                }\n            }\n        }\n    }\n    round_buffer_insert_read(&(stats->cov_rbuf), pmin, pmax);\n}\n\nvoid collect_stats(bam1_t *bam_line, stats_t *stats, khash_t(qn2pair) *read_pairs)\n{\n    if ( !is_in_regions(bam_line,stats) )\n        return;\n    if ( stats->rg_hash )\n    {\n        const uint8_t *rg = bam_aux_get(bam_line, \"RG\");\n        if ( !rg ) return;  // certain read groups were requested but this record has none\n        khint_t k = kh_get(rg, stats->rg_hash, (const char*)(rg + 1));\n        if ( k == kh_end((kh_rg_t *)stats->rg_hash) ) return;\n    }\n    if ( stats->info->flag_require && (bam_line->core.flag & stats->info->flag_require)!=stats->info->flag_require )\n    {\n        stats->nreads_filtered++;\n        return;\n    }\n    if ( stats->info->flag_filter && (bam_line->core.flag & stats->info->flag_filter) )\n    {\n        stats->nreads_filtered++;\n        return;\n    }\n    if ( stats->info->filter_readlen!=-1 && bam_line->core.l_qseq!=stats->info->filter_readlen )\n        return;\n\n    update_checksum(bam_line, stats);\n\n    // Secondary reads don't count for most stats purposes\n    if ( bam_line->core.flag & BAM_FSECONDARY )\n    {\n        stats->nreads_secondary++;\n        return;\n    }\n\n    if ( bam_line->core.flag & BAM_FSUPPLEMENTARY )\n    {\n        stats->nreads_supplementary++;\n    }\n\n    // If line has no sequence cannot continue\n    int seq_len = bam_line->core.l_qseq;\n    if ( !seq_len ) return;\n\n    if ( IS_DUP(bam_line) )\n    {\n        stats->total_len_dup += seq_len;\n        stats->nreads_dup++;\n    }\n\n    uint32_t order = IS_PAIRED(bam_line) ? (IS_READ1(bam_line) ? READ_ORDER_FIRST : 0) + (IS_READ2(bam_line) ? READ_ORDER_LAST : 0) : READ_ORDER_FIRST;\n\n    int read_len = unclipped_length(bam_line);\n    if ( read_len >= stats->nbases )\n        realloc_buffers(stats,read_len);\n    // Update max_len observed\n    if ( stats->max_len<read_len )\n        stats->max_len = read_len;\n    if ( order == READ_ORDER_FIRST && stats->max_len_1st < read_len )\n        stats->max_len_1st = read_len;\n    if ( order == READ_ORDER_LAST && stats->max_len_2nd < read_len )\n        stats->max_len_2nd = read_len;\n    if ( ( bam_line->core.flag & (BAM_FUNMAP|BAM_FSECONDARY|BAM_FSUPPLEMENTARY|BAM_FQCFAIL|BAM_FDUP) ) == 0 )\n        stats->mapping_qualities[bam_line->core.qual]++;\n\n    int i;\n    int gc_count = 0;\n\n    // These stats should only be calculated for the original reads ignoring supplementary artificial reads\n    // otherwise we'll accidentally double count\n    if ( IS_ORIGINAL(bam_line) ) {\n        stats->read_lengths[read_len]++;\n        if ( order == READ_ORDER_FIRST ) stats->read_lengths_1st[read_len]++;\n        if ( order == READ_ORDER_LAST ) stats->read_lengths_2nd[read_len]++;\n        collect_orig_read_stats(bam_line, stats, &gc_count);\n    }\n\n    // Look at the flags and increment appropriate counters (mapped, paired, etc)\n    if ( IS_UNMAPPED(bam_line) ) return;\n\n    count_indels(stats, bam_line);\n\n    if ( IS_PAIRED_AND_MAPPED(bam_line) && IS_ORIGINAL(bam_line) )\n    {\n        // The insert size is tricky, because for long inserts the libraries are\n        // prepared differently and the pairs point in other direction. BWA does\n        // not set the paired flag for them.  Similar thing is true also for 454\n        // reads. Mates mapped to different chromosomes have isize==0.\n        int32_t isize = bam_line->core.isize;\n        if ( isize<0 ) isize = -isize;\n        if ( stats->info->nisize > 0 && isize > stats->info->nisize )\n            isize = stats->info->nisize;\n        if ( isize>0 || bam_line->core.tid==bam_line->core.mtid )\n        {\n            hts_pos_t pos_fst = bam_line->core.mpos - bam_line->core.pos;\n            int is_fst  = IS_READ1(bam_line) ? 1 : -1;\n            int is_fwd  = IS_REVERSE(bam_line) ? -1 : 1;\n            int is_mfwd = IS_MATE_REVERSE(bam_line) ? -1 : 1;\n\n            if ( is_fwd*is_mfwd>0 )\n                stats->isize->inc_other(stats->isize->data, isize);\n            else if ( is_fst*pos_fst>=0 )\n            {\n                if ( is_fst*is_fwd>0 )\n                    stats->isize->inc_inward(stats->isize->data, isize);\n                else\n                    stats->isize->inc_outward(stats->isize->data, isize);\n            }\n            else if ( is_fst*pos_fst<0 )\n            {\n                if ( is_fst*is_fwd>0 )\n                    stats->isize->inc_outward(stats->isize->data, isize);\n                else\n                    stats->isize->inc_inward(stats->isize->data, isize);\n            }\n        }\n    }\n\n    // Number of mismatches\n    uint8_t *nm = bam_aux_get(bam_line,\"NM\");\n    if (nm)\n        stats->nmismatches += bam_aux2i(nm);\n\n    // Number of mapped bases from cigar\n    if ( bam_line->core.n_cigar == 0)\n        error(\"FIXME: mapped read with no cigar?\\n\");\n    int readlen=seq_len;\n    if ( stats->regions )\n    {\n        // Count only on-target bases\n        hts_pos_t iref = bam_line->core.pos + 1;\n        for (i=0; i<bam_line->core.n_cigar; i++)\n        {\n            int cig  = bam_cigar_op(bam_get_cigar(bam_line)[i]);\n            int ncig = bam_cigar_oplen(bam_get_cigar(bam_line)[i]);\n            if ( !ncig ) continue;  // curiously, this can happen: 0D\n            if ( cig==BAM_CDEL ) readlen += ncig;\n            else if ( cig==BAM_CMATCH || cig==BAM_CEQUAL || cig==BAM_CDIFF )\n            {\n                if ( iref < stats->reg_from ) ncig -= stats->reg_from-iref;\n                else if ( iref+ncig-1 > stats->reg_to ) ncig -= iref+ncig-1 - stats->reg_to;\n                if ( ncig<0 ) ncig = 0;\n                stats->nbases_mapped_cigar += ncig;\n                iref += bam_cigar_oplen(bam_get_cigar(bam_line)[i]);\n            }\n            else if ( cig==BAM_CINS )\n            {\n                iref += ncig;\n                if ( iref>=stats->reg_from && iref<=stats->reg_to )\n                    stats->nbases_mapped_cigar += ncig;\n            }\n        }\n    }\n    else\n    {\n        // Count the whole read\n        for (i=0; i<bam_line->core.n_cigar; i++)\n        {\n            int cig  = bam_cigar_op(bam_get_cigar(bam_line)[i]);\n            if ( cig==BAM_CMATCH || cig==BAM_CINS || cig==BAM_CEQUAL || cig==BAM_CDIFF )\n                stats->nbases_mapped_cigar += bam_cigar_oplen(bam_get_cigar(bam_line)[i]);\n            if ( cig==BAM_CDEL )\n                readlen += bam_cigar_oplen(bam_get_cigar(bam_line)[i]);\n        }\n    }\n\n    if ( stats->tid==bam_line->core.tid && bam_line->core.pos<stats->pos )\n        stats->is_sorted = 0;\n    stats->pos = bam_line->core.pos;\n\n    if ( stats->is_sorted )\n    {\n        if ( stats->tid==-1 || stats->tid!=bam_line->core.tid ) {\n            round_buffer_flush(stats, -1);\n        }\n\n        //cleanup the pair hash table to free memory\n        stats->last_read_flush++;\n        if ( stats->pair_count > DEFAULT_PAIR_MAX && stats->last_read_flush > DEFAULT_PAIR_MAX) {\n            stats->pair_count -= cleanup_overlaps(read_pairs, bam_line->core.pos);\n            stats->last_read_flush = 0;\n        }\n\n        if ( stats->last_pair_tid != bam_line->core.tid) {\n            stats->pair_count -= cleanup_overlaps(read_pairs, INT64_MAX-1);\n            stats->last_pair_tid = bam_line->core.tid;\n            stats->last_read_flush = 0;\n        }\n\n        // Mismatches per cycle and GC-depth graph. For simplicity, reads overlapping GCD bins\n        //  are not splitted which results in up to seq_len-1 overlaps. The default bin size is\n        //  20kbp, so the effect is negligible.\n        if ( stats->info->fai )\n        {\n            hts_pos_t inc_ref = 0;\n            int inc_gcd = 0;\n            // First pass or new chromosome, or read goes beyond the rseq buffer\n            if ( stats->rseq_pos==-1 || stats->tid != bam_line->core.tid\n                 || stats->rseq_pos+stats->nrseq_buf < bam_line->core.pos+readlen) {\n                inc_ref=bam_line->core.pos+readlen;\n                inc_gcd=1;\n            }\n            // Read overlaps the next gcd bin\n            else if ( stats->gcd_pos+stats->info->gcd_bin_size < bam_line->core.pos+readlen )\n            {\n                inc_gcd = 1;\n                if ( stats->rseq_pos+stats->nrseq_buf < bam_line->core.pos+stats->info->gcd_bin_size ) inc_ref = bam_line->core.pos+stats->info->gcd_bin_size;\n            }\n            if ( inc_gcd )\n            {\n                stats->igcd++;\n                if ( stats->igcd >= stats->ngcd )\n                    realloc_gcd_buffer(stats, readlen);\n                if ( inc_ref )\n                    read_ref_seq(stats, bam_line->core.tid,\n                                 bam_line->core.pos, inc_ref);\n                stats->gcd_pos = bam_line->core.pos;\n                stats->gcd[ stats->igcd ].gc = fai_gc_content(stats, stats->gcd_pos, stats->info->gcd_bin_size);\n            }\n\n            count_mismatches_per_cycle(stats,bam_line,read_len);\n        }\n        // No reference and first pass, new chromosome or sequence going beyond the end of the gcd bin\n        else if ( stats->gcd_pos==-1 || stats->tid != bam_line->core.tid || bam_line->core.pos - stats->gcd_pos > stats->info->gcd_bin_size )\n        {\n            // First pass or a new chromosome\n            stats->tid     = bam_line->core.tid;\n            stats->gcd_pos = bam_line->core.pos;\n            stats->igcd++;\n            if ( stats->igcd >= stats->ngcd )\n                realloc_gcd_buffer(stats, readlen);\n        }\n        stats->gcd[ stats->igcd ].depth++;\n        // When no reference sequence is given, approximate the GC from the read (much shorter window, but otherwise OK)\n        if ( !stats->info->fai )\n            stats->gcd[ stats->igcd ].gc += (float) gc_count / seq_len;\n\n        // Coverage distribution graph\n        round_buffer_flush(stats,bam_line->core.pos);\n        if ( stats->regions ) {\n            hts_pos_t p = bam_line->core.pos, pnew, pmin = 0, pmax = 0;\n            uint32_t j = 0;\n            i = 0;\n            while ( j < bam_line->core.n_cigar && i < stats->nchunks ) {\n                int op = bam_cigar_op(bam_get_cigar(bam_line)[j]);\n                int oplen = bam_cigar_oplen(bam_get_cigar(bam_line)[j]);\n                switch(op) {\n                case BAM_CMATCH:\n                case BAM_CEQUAL:\n                case BAM_CDIFF:\n                    pmin = MAX(p, stats->chunks[i].beg-1); // 0 based\n                    pmax = MIN(p+oplen, stats->chunks[i].end); // 1 based\n                    if ( pmax > pmin ) {\n                        if ( stats->info->remove_overlaps )\n                            remove_overlaps(bam_line, read_pairs, stats, pmin, pmax);\n                        else\n                            round_buffer_insert_read(&(stats->cov_rbuf), pmin, pmax);\n                    }\n                    break;\n                case BAM_CDEL:\n                    break;\n                }\n                pnew = p + (bam_cigar_type(op)&2 ? oplen : 0); // consumes reference\n\n                if ( pnew >= stats->chunks[i].end ) {\n                    // go to the next chunk\n                    i++;\n                } else {\n                    // go to the next CIGAR op\n                    j++;\n                    p = pnew;\n                }\n            }\n        } else {\n            hts_pos_t p = bam_line->core.pos;\n            uint32_t j;\n            for (j = 0; j < bam_line->core.n_cigar; j++) {\n                int op = bam_cigar_op(bam_get_cigar(bam_line)[j]);\n                int oplen = bam_cigar_oplen(bam_get_cigar(bam_line)[j]);\n                switch(op) {\n                case BAM_CMATCH:\n                case BAM_CEQUAL:\n                case BAM_CDIFF:\n                    if ( stats->info->remove_overlaps )\n                        remove_overlaps(bam_line, read_pairs, stats, p, p+oplen);\n                    else\n                        round_buffer_insert_read(&(stats->cov_rbuf), p, p+oplen);\n                    break;\n                case BAM_CDEL:\n                    break;\n                }\n                p += bam_cigar_type(op)&2 ? oplen : 0; // consumes reference\n            }\n        }\n        if ( stats->info->remove_overlaps )\n           remove_overlaps(bam_line, read_pairs, stats, -1LL, -1LL); //remove the line from the hash table\n    }\n}\n\n// Sort by GC and depth\n#define GCD_t(x) ((gc_depth_t *)x)\nstatic int gcd_cmp(const void *a, const void *b)\n{\n    if ( GCD_t(a)->gc < GCD_t(b)->gc ) return -1;\n    if ( GCD_t(a)->gc > GCD_t(b)->gc ) return 1;\n    if ( GCD_t(a)->depth < GCD_t(b)->depth ) return -1;\n    if ( GCD_t(a)->depth > GCD_t(b)->depth ) return 1;\n    return 0;\n}\n#undef GCD_t\n\nfloat gcd_percentile(gc_depth_t *gcd, int N, int p)\n{\n    float n,d;\n    int k;\n\n    n = (float)p*(N+1)/100;\n    k = n;\n    if ( k<=0 )\n        return gcd[0].depth;\n    if ( k>=N )\n        return gcd[N-1].depth;\n\n    d = n - k;\n    return gcd[k-1].depth + d*(gcd[k].depth - gcd[k-1].depth);\n}\n\nvoid output_stats(FILE *to, stats_t *stats, int sparse)\n{\n    // Calculate average insert size and standard deviation (from the main bulk data only)\n    int isize, ibulk=0, icov, imapq=0;\n    uint64_t nisize=0, nisize_inward=0, nisize_outward=0, nisize_other=0, cov_sum=0;\n    double bulk=0, avg_isize=0, sd_isize=0;\n    for (isize=0; isize<stats->isize->nitems(stats->isize->data); isize++)\n    {\n        // Each pair was counted twice\n        stats->isize->set_inward(stats->isize->data, isize, stats->isize->inward(stats->isize->data, isize) * 0.5);\n        stats->isize->set_outward(stats->isize->data, isize, stats->isize->outward(stats->isize->data, isize) * 0.5);\n        stats->isize->set_other(stats->isize->data, isize, stats->isize->other(stats->isize->data, isize) * 0.5);\n\n        nisize_inward += stats->isize->inward(stats->isize->data, isize);\n        nisize_outward += stats->isize->outward(stats->isize->data, isize);\n        nisize_other += stats->isize->other(stats->isize->data, isize);\n        nisize += stats->isize->inward(stats->isize->data, isize) + stats->isize->outward(stats->isize->data, isize) + stats->isize->other(stats->isize->data, isize);\n    }\n\n    for (isize=0; isize<stats->isize->nitems(stats->isize->data); isize++)\n    {\n        uint64_t num = stats->isize->inward(stats->isize->data, isize) +  stats->isize->outward(stats->isize->data, isize) + stats->isize->other(stats->isize->data, isize);\n        if (num > 0) ibulk = isize + 1;\n        bulk += num;\n        avg_isize += isize * (stats->isize->inward(stats->isize->data, isize) +  stats->isize->outward(stats->isize->data, isize) + stats->isize->other(stats->isize->data, isize));\n\n        if ( bulk/nisize > stats->info->isize_main_bulk )\n        {\n            ibulk  = isize+1;\n            nisize = bulk;\n            break;\n        }\n    }\n    avg_isize /= nisize ? nisize : 1;\n    for (isize=1; isize<ibulk; isize++)\n        sd_isize += (stats->isize->inward(stats->isize->data, isize) + stats->isize->outward(stats->isize->data, isize) +stats->isize->other(stats->isize->data, isize)) * (isize-avg_isize)*(isize-avg_isize) / (nisize ? nisize : 1);\n    sd_isize = sqrt(sd_isize);\n\n    fprintf(to, \"# This file was produced by samtools stats (%s+htslib-%s) and can be plotted using plot-bamstats\\n\", samtools_version(), hts_version());\n    if( stats->split_name != NULL ){\n        fprintf(to, \"# This file contains statistics only for reads with tag: %s=%s\\n\", stats->info->split_tag, stats->split_name);\n    }\n    else{\n        fprintf(to, \"# This file contains statistics for all reads.\\n\");\n    }\n    fprintf(to, \"# The command line was:  %s\",stats->info->argv[0]);\n    int i;\n    for (i=1; i<stats->info->argc; i++)\n        fprintf(to, \" %s\", stats->info->argv[i]);\n    fprintf(to, \"\\n\");\n    fprintf(to, \"# CHK, Checksum\\t[2]Read Names\\t[3]Sequences\\t[4]Qualities\\n\");\n    fprintf(to, \"# CHK, CRC32 of reads which passed filtering followed by addition (32bit overflow)\\n\");\n    fprintf(to, \"CHK\\t%08x\\t%08x\\t%08x\\n\", stats->checksum.names,stats->checksum.reads,stats->checksum.quals);\n    fprintf(to, \"# Summary Numbers. Use `grep ^SN | cut -f 2-` to extract this part.\\n\");\n    fprintf(to, \"SN\\traw total sequences:\\t%ld\\t# excluding supplementary and secondary reads\\n\", (long)(stats->nreads_filtered+stats->nreads_1st+stats->nreads_2nd+stats->nreads_other));  // not counting excluded seqs (and none of the below)\n    fprintf(to, \"SN\\tfiltered sequences:\\t%ld\\n\", (long)stats->nreads_filtered);\n    fprintf(to, \"SN\\tsequences:\\t%ld\\n\", (long)(stats->nreads_1st+stats->nreads_2nd+stats->nreads_other));\n    fprintf(to, \"SN\\tis sorted:\\t%d\\n\", stats->is_sorted ? 1 : 0);\n    fprintf(to, \"SN\\t1st fragments:\\t%ld\\n\", (long)stats->nreads_1st);\n    fprintf(to, \"SN\\tlast fragments:\\t%ld\\n\", (long)stats->nreads_2nd);\n    fprintf(to, \"SN\\treads mapped:\\t%ld\\n\", (long)(stats->nreads_paired_and_mapped+stats->nreads_single_mapped));\n    fprintf(to, \"SN\\treads mapped and paired:\\t%ld\\t# paired-end technology bit set + both mates mapped\\n\", (long)stats->nreads_paired_and_mapped);\n    fprintf(to, \"SN\\treads unmapped:\\t%ld\\n\", (long)stats->nreads_unmapped);\n    fprintf(to, \"SN\\treads properly paired:\\t%ld\\t# proper-pair bit set\\n\", (long)stats->nreads_properly_paired);\n    fprintf(to, \"SN\\treads paired:\\t%ld\\t# paired-end technology bit set\\n\", (long)stats->nreads_paired_tech);\n    fprintf(to, \"SN\\treads duplicated:\\t%ld\\t# PCR or optical duplicate bit set\\n\", (long)stats->nreads_dup);\n    fprintf(to, \"SN\\treads MQ0:\\t%ld\\t# mapped and MQ=0\\n\", (long)stats->nreads_mq0);\n    fprintf(to, \"SN\\treads QC failed:\\t%ld\\n\", (long)stats->nreads_QCfailed);\n    fprintf(to, \"SN\\tnon-primary alignments:\\t%ld\\n\", (long)stats->nreads_secondary);\n    fprintf(to, \"SN\\tsupplementary alignments:\\t%ld\\n\", (long)stats->nreads_supplementary);\n    fprintf(to, \"SN\\ttotal length:\\t%ld\\t# ignores clipping\\n\", (long)stats->total_len);\n    fprintf(to, \"SN\\ttotal first fragment length:\\t%ld\\t# ignores clipping\\n\", (long)stats->total_len_1st);\n    fprintf(to, \"SN\\ttotal last fragment length:\\t%ld\\t# ignores clipping\\n\", (long)stats->total_len_2nd);\n    fprintf(to, \"SN\\tbases mapped:\\t%ld\\t# ignores clipping\\n\", (long)stats->nbases_mapped);                 // the length of the whole read goes here, including soft-clips etc.\n    fprintf(to, \"SN\\tbases mapped (cigar):\\t%ld\\t# more accurate\\n\", (long)stats->nbases_mapped_cigar);   // only matched and inserted bases are counted here\n    fprintf(to, \"SN\\tbases trimmed:\\t%ld\\n\", (long)stats->nbases_trimmed);\n    fprintf(to, \"SN\\tbases duplicated:\\t%ld\\n\", (long)stats->total_len_dup);\n    fprintf(to, \"SN\\tmismatches:\\t%ld\\t# from NM fields\\n\", (long)stats->nmismatches);\n    fprintf(to, \"SN\\terror rate:\\t%e\\t# mismatches / bases mapped (cigar)\\n\", stats->nbases_mapped_cigar ? (float)stats->nmismatches/stats->nbases_mapped_cigar : 0);\n    float avg_read_length = (stats->nreads_1st +\n                             stats->nreads_2nd +\n                             stats->nreads_other)\n        ? (float)stats->total_len / (stats->nreads_1st +\n                                     stats->nreads_2nd +\n                                     stats->nreads_other)\n        : 0;\n    fprintf(to, \"SN\\taverage length:\\t%.0f\\n\", avg_read_length);\n    fprintf(to, \"SN\\taverage first fragment length:\\t%.0f\\n\", stats->nreads_1st? (float)stats->total_len_1st/stats->nreads_1st:0);\n    fprintf(to, \"SN\\taverage last fragment length:\\t%.0f\\n\", stats->nreads_2nd? (float)stats->total_len_2nd/stats->nreads_2nd:0);\n    fprintf(to, \"SN\\tmaximum length:\\t%d\\n\", stats->max_len);\n    fprintf(to, \"SN\\tmaximum first fragment length:\\t%d\\n\", stats->max_len_1st);\n    fprintf(to, \"SN\\tmaximum last fragment length:\\t%d\\n\", stats->max_len_2nd);\n    fprintf(to, \"SN\\taverage quality:\\t%.1f\\n\", stats->total_len?stats->sum_qual/stats->total_len:0);\n    fprintf(to, \"SN\\tinsert size average:\\t%.1f\\n\", avg_isize);\n    fprintf(to, \"SN\\tinsert size standard deviation:\\t%.1f\\n\", sd_isize);\n    fprintf(to, \"SN\\tinward oriented pairs:\\t%ld\\n\", (long)nisize_inward);\n    fprintf(to, \"SN\\toutward oriented pairs:\\t%ld\\n\", (long)nisize_outward);\n    fprintf(to, \"SN\\tpairs with other orientation:\\t%ld\\n\", (long)nisize_other);\n    fprintf(to, \"SN\\tpairs on different chromosomes:\\t%ld\\n\", (long)stats->nreads_anomalous/2);\n    fprintf(to, \"SN\\tpercentage of properly paired reads (%%):\\t%.1f\\n\", (stats->nreads_1st+stats->nreads_2nd+stats->nreads_other)? (float)(100*stats->nreads_properly_paired)/(stats->nreads_1st+stats->nreads_2nd+stats->nreads_other):0);\n    if ( stats->target_count ) {\n        fprintf(to, \"SN\\tbases inside the target:\\t%\" PRIu64 \"\\n\", stats->target_count);\n        for (icov=stats->info->cov_threshold+1; icov<stats->ncov; icov++)\n            cov_sum += stats->cov[icov];\n        fprintf(to, \"SN\\tpercentage of target genome with coverage > %d (%%):\\t%.2f\\n\", stats->info->cov_threshold, (float)(100*cov_sum)/stats->target_count);\n    }\n\n    int ibase,iqual;\n    if ( stats->max_len<stats->nbases ) stats->max_len++;\n    if ( stats->max_qual+1<stats->nquals ) stats->max_qual++;\n    fprintf(to, \"# First Fragment Qualities. Use `grep ^FFQ | cut -f 2-` to extract this part.\\n\");\n    fprintf(to, \"# Columns correspond to qualities and rows to cycles. First column is the cycle number.\\n\");\n    for (ibase=0; ibase<stats->max_len_1st; ibase++)\n    {\n        fprintf(to, \"FFQ\\t%d\",ibase+1);\n        for (iqual=0; iqual<=stats->max_qual; iqual++)\n        {\n            fprintf(to, \"\\t%ld\", (long)stats->quals_1st[ibase*stats->nquals+iqual]);\n        }\n        fprintf(to, \"\\n\");\n    }\n    fprintf(to, \"# Last Fragment Qualities. Use `grep ^LFQ | cut -f 2-` to extract this part.\\n\");\n    fprintf(to, \"# Columns correspond to qualities and rows to cycles. First column is the cycle number.\\n\");\n    for (ibase=0; ibase<stats->max_len_2nd; ibase++)\n    {\n        fprintf(to, \"LFQ\\t%d\",ibase+1);\n        for (iqual=0; iqual<=stats->max_qual; iqual++)\n        {\n            fprintf(to, \"\\t%ld\", (long)stats->quals_2nd[ibase*stats->nquals+iqual]);\n        }\n        fprintf(to, \"\\n\");\n    }\n    if ( stats->mpc_buf )\n    {\n        fprintf(to, \"# Mismatches per cycle and quality. Use `grep ^MPC | cut -f 2-` to extract this part.\\n\");\n        fprintf(to, \"# Columns correspond to qualities, rows to cycles. First column is the cycle number, second\\n\");\n        fprintf(to, \"# is the number of N's and the rest is the number of mismatches\\n\");\n        for (ibase=0; ibase<stats->max_len; ibase++)\n        {\n            fprintf(to, \"MPC\\t%d\",ibase+1);\n            for (iqual=0; iqual<=stats->max_qual; iqual++)\n            {\n                fprintf(to, \"\\t%ld\", (long)stats->mpc_buf[ibase*stats->nquals+iqual]);\n            }\n            fprintf(to, \"\\n\");\n        }\n    }\n    fprintf(to, \"# GC Content of first fragments. Use `grep ^GCF | cut -f 2-` to extract this part.\\n\");\n    int ibase_prev = 0;\n    for (ibase=0; ibase<stats->ngc; ibase++)\n    {\n        if ( stats->gc_1st[ibase]==stats->gc_1st[ibase_prev] ) continue;\n        fprintf(to, \"GCF\\t%.2f\\t%ld\\n\", (ibase+ibase_prev)*0.5*100./(stats->ngc-1), (long)stats->gc_1st[ibase_prev]);\n        ibase_prev = ibase;\n    }\n    fprintf(to, \"# GC Content of last fragments. Use `grep ^GCL | cut -f 2-` to extract this part.\\n\");\n    ibase_prev = 0;\n    for (ibase=0; ibase<stats->ngc; ibase++)\n    {\n        if ( stats->gc_2nd[ibase]==stats->gc_2nd[ibase_prev] ) continue;\n        fprintf(to, \"GCL\\t%.2f\\t%ld\\n\", (ibase+ibase_prev)*0.5*100./(stats->ngc-1), (long)stats->gc_2nd[ibase_prev]);\n        ibase_prev = ibase;\n    }\n    fprintf(to, \"# ACGT content per cycle. Use `grep ^GCC | cut -f 2-` to extract this part. The columns are: cycle; A,C,G,T base counts as a percentage of all A/C/G/T bases [%%]; and N and O counts as a percentage of all A/C/G/T bases [%%]\\n\");\n    for (ibase=0; ibase<stats->max_len; ibase++)\n    {\n        acgtno_count_t *acgtno_count_1st = &(stats->acgtno_cycles_1st[ibase]);\n        acgtno_count_t *acgtno_count_2nd = &(stats->acgtno_cycles_2nd[ibase]);\n        uint64_t acgt_sum = acgtno_count_1st->a + acgtno_count_1st->c + acgtno_count_1st->g + acgtno_count_1st->t +\n                acgtno_count_2nd->a + acgtno_count_2nd->c + acgtno_count_2nd->g + acgtno_count_2nd->t;\n        if ( ! acgt_sum ) continue;\n        fprintf(to, \"GCC\\t%d\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\n\", ibase+1,\n                100.*(acgtno_count_1st->a + acgtno_count_2nd->a)/acgt_sum,\n                100.*(acgtno_count_1st->c + acgtno_count_2nd->c)/acgt_sum,\n                100.*(acgtno_count_1st->g + acgtno_count_2nd->g)/acgt_sum,\n                100.*(acgtno_count_1st->t + acgtno_count_2nd->t)/acgt_sum,\n                100.*(acgtno_count_1st->n + acgtno_count_2nd->n)/acgt_sum,\n                100.*(acgtno_count_1st->other + acgtno_count_2nd->other)/acgt_sum);\n    }\n    fprintf(to, \"# ACGT content per cycle, read oriented. Use `grep ^GCT | cut -f 2-` to extract this part. The columns are: cycle; A,C,G,T base counts as a percentage of all A/C/G/T bases [%%]\\n\");\n    for (ibase=0; ibase<stats->max_len; ibase++)\n    {\n        acgtno_count_t *acgtno_count = &(stats->acgtno_revcomp[ibase]);\n        uint64_t acgt_sum = acgtno_count->a + acgtno_count->c + acgtno_count->g + acgtno_count->t;\n        if ( ! acgt_sum ) continue;\n        fprintf(to, \"GCT\\t%d\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\n\", ibase+1,\n                100.*(acgtno_count->a)/acgt_sum,\n                100.*(acgtno_count->c)/acgt_sum,\n                100.*(acgtno_count->g)/acgt_sum,\n                100.*(acgtno_count->t)/acgt_sum);\n    }\n\n    uint64_t tA=0, tC=0, tG=0, tT=0, tN=0;\n    fprintf(to, \"# ACGT content per cycle for first fragments. Use `grep ^FBC | cut -f 2-` to extract this part. The columns are: cycle; A,C,G,T base counts as a percentage of all A/C/G/T bases [%%]; and N and O counts as a percentage of all A/C/G/T bases [%%]\\n\");\n    for (ibase=0; ibase<stats->max_len; ibase++)\n    {\n        acgtno_count_t *acgtno_count_1st = &(stats->acgtno_cycles_1st[ibase]);\n        uint64_t acgt_sum_1st = acgtno_count_1st->a + acgtno_count_1st->c + acgtno_count_1st->g + acgtno_count_1st->t;\n        tA += acgtno_count_1st->a;\n        tC += acgtno_count_1st->c;\n        tG += acgtno_count_1st->g;\n        tT += acgtno_count_1st->t;\n        tN += acgtno_count_1st->n;\n\n        if ( acgt_sum_1st )\n            fprintf(to, \"FBC\\t%d\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\n\", ibase+1,\n                    100.*acgtno_count_1st->a/acgt_sum_1st,\n                    100.*acgtno_count_1st->c/acgt_sum_1st,\n                    100.*acgtno_count_1st->g/acgt_sum_1st,\n                    100.*acgtno_count_1st->t/acgt_sum_1st,\n                    100.*acgtno_count_1st->n/acgt_sum_1st,\n                    100.*acgtno_count_1st->other/acgt_sum_1st);\n\n    }\n    fprintf(to, \"# ACGT raw counters for first fragments. Use `grep ^FTC | cut -f 2-` to extract this part. The columns are: A,C,G,T,N base counters\\n\");\n    fprintf(to, \"FTC\\t%\" PRId64 \"\\t%\" PRId64 \"\\t%\" PRId64 \"\\t%\" PRId64 \"\\t%\" PRId64 \"\\n\", tA, tC, tG, tT, tN);\n    tA=0, tC=0, tG=0, tT=0, tN=0;\n    fprintf(to, \"# ACGT content per cycle for last fragments. Use `grep ^LBC | cut -f 2-` to extract this part. The columns are: cycle; A,C,G,T base counts as a percentage of all A/C/G/T bases [%%]; and N and O counts as a percentage of all A/C/G/T bases [%%]\\n\");\n    for (ibase=0; ibase<stats->max_len; ibase++)\n    {\n        acgtno_count_t *acgtno_count_2nd = &(stats->acgtno_cycles_2nd[ibase]);\n        uint64_t acgt_sum_2nd = acgtno_count_2nd->a + acgtno_count_2nd->c + acgtno_count_2nd->g + acgtno_count_2nd->t;\n        tA += acgtno_count_2nd->a;\n        tC += acgtno_count_2nd->c;\n        tG += acgtno_count_2nd->g;\n        tT += acgtno_count_2nd->t;\n        tN += acgtno_count_2nd->n;\n\n        if ( acgt_sum_2nd )\n            fprintf(to, \"LBC\\t%d\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\n\", ibase+1,\n                    100.*acgtno_count_2nd->a/acgt_sum_2nd,\n                    100.*acgtno_count_2nd->c/acgt_sum_2nd,\n                    100.*acgtno_count_2nd->g/acgt_sum_2nd,\n                    100.*acgtno_count_2nd->t/acgt_sum_2nd,\n                    100.*acgtno_count_2nd->n/acgt_sum_2nd,\n                    100.*acgtno_count_2nd->other/acgt_sum_2nd);\n\n    }\n    fprintf(to, \"# ACGT raw counters for last fragments. Use `grep ^LTC | cut -f 2-` to extract this part. The columns are: A,C,G,T,N base counters\\n\");\n    fprintf(to, \"LTC\\t%\" PRId64 \"\\t%\" PRId64 \"\\t%\" PRId64 \"\\t%\" PRId64 \"\\t%\" PRId64 \"\\n\", tA, tC, tG, tT, tN);\n\n    int tag;\n    for (tag=0; tag<stats->ntags; tag++) {\n        if (stats->tags_barcode[tag].nbases) {\n            fprintf(to, \"# ACGT content per cycle for barcodes. Use `grep ^%sC | cut -f 2-` to extract this part. The columns are: cycle; A,C,G,T base counts as a percentage of all A/C/G/T bases [%%]; and N counts as a percentage of all A/C/G/T bases [%%]\\n\",\n                    stats->tags_barcode[tag].tag_name);\n            for (ibase=0; ibase<stats->tags_barcode[tag].nbases; ibase++)\n            {\n                if (ibase == stats->tags_barcode[tag].tag_sep)\n                    continue;\n\n                acgtno_count_t *acgtno_count = stats->acgtno_barcode + stats->tags_barcode[tag].offset + ibase;\n                uint64_t acgt_sum = acgtno_count->a + acgtno_count->c + acgtno_count->g + acgtno_count->t;\n\n                if ( acgt_sum )\n                    fprintf(to, \"%sC%d\\t%d\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\t%.2f\\n\", stats->tags_barcode[tag].tag_name,\n                            stats->tags_barcode[tag].tag_sep < 0 || ibase < stats->tags_barcode[tag].tag_sep ? 1 : 2,\n                            stats->tags_barcode[tag].tag_sep < 0 || ibase < stats->tags_barcode[tag].tag_sep ? ibase+1 : ibase-stats->tags_barcode[tag].tag_sep,\n                                    100.*acgtno_count->a/acgt_sum,\n                                    100.*acgtno_count->c/acgt_sum,\n                                    100.*acgtno_count->g/acgt_sum,\n                                    100.*acgtno_count->t/acgt_sum,\n                                    100.*acgtno_count->n/acgt_sum);\n            }\n\n            fprintf(to, \"# Barcode Qualities. Use `grep ^%sQ | cut -f 2-` to extract this part.\\n\", stats->tags_barcode[tag].qual_name);\n            fprintf(to, \"# Columns correspond to qualities and rows to barcode cycles. First column is the cycle number.\\n\");\n            for (ibase=0; ibase<stats->tags_barcode[tag].nbases; ibase++)\n            {\n                if (ibase == stats->tags_barcode[tag].tag_sep)\n                    continue;\n\n                fprintf(to, \"%sQ%d\\t%d\", stats->tags_barcode[tag].qual_name,\n                        stats->tags_barcode[tag].tag_sep < 0 || ibase < stats->tags_barcode[tag].tag_sep ? 1 : 2,\n                        stats->tags_barcode[tag].tag_sep < 0 || ibase < stats->tags_barcode[tag].tag_sep ? ibase+1 : ibase-stats->tags_barcode[tag].tag_sep);\n                for (iqual=0; iqual<=stats->tags_barcode[tag].max_qual; iqual++)\n                {\n                    fprintf(to, \"\\t%ld\", (long)stats->quals_barcode[(stats->tags_barcode[tag].offset + ibase)*stats->nquals+iqual]);\n                }\n                fprintf(to, \"\\n\");\n            }\n        }\n    }\n\n    fprintf(to, \"# Insert sizes. Use `grep ^IS | cut -f 2-` to extract this part. The columns are: insert size, pairs total, inward oriented pairs, outward oriented pairs, other pairs\\n\");\n    for (isize=0; isize<ibulk; isize++) {\n        long in = (long)(stats->isize->inward(stats->isize->data, isize));\n        long out = (long)(stats->isize->outward(stats->isize->data, isize));\n        long other = (long)(stats->isize->other(stats->isize->data, isize));\n        if (!sparse || in + out + other > 0) {\n            fprintf(to, \"IS\\t%d\\t%ld\\t%ld\\t%ld\\t%ld\\n\", isize,  in+out+other,\n                in , out, other);\n        }\n    }\n\n    fprintf(to, \"# Read lengths. Use `grep ^RL | cut -f 2-` to extract this part. The columns are: read length, count\\n\");\n    int ilen;\n    for (ilen=0; ilen<stats->max_len; ilen++)\n    {\n        if ( stats->read_lengths[ilen+1]>0 )\n            fprintf(to, \"RL\\t%d\\t%ld\\n\", ilen+1, (long)stats->read_lengths[ilen+1]);\n    }\n\n    fprintf(to, \"# Read lengths - first fragments. Use `grep ^FRL | cut -f 2-` to extract this part. The columns are: read length, count\\n\");\n    for (ilen=0; ilen<stats->max_len_1st; ilen++)\n    {\n        if ( stats->read_lengths_1st[ilen+1]>0 )\n            fprintf(to, \"FRL\\t%d\\t%ld\\n\", ilen+1, (long)stats->read_lengths_1st[ilen+1]);\n    }\n\n    fprintf(to, \"# Read lengths - last fragments. Use `grep ^LRL | cut -f 2-` to extract this part. The columns are: read length, count\\n\");\n    for (ilen=0; ilen<stats->max_len_2nd; ilen++)\n    {\n        if ( stats->read_lengths_2nd[ilen+1]>0 )\n            fprintf(to, \"LRL\\t%d\\t%ld\\n\", ilen+1, (long)stats->read_lengths_2nd[ilen+1]);\n    }\n\n    fprintf(to, \"# Mapping qualities for reads !(UNMAP|SECOND|SUPPL|QCFAIL|DUP). Use `grep ^MAPQ | cut -f 2-` to extract this part. The columns are: mapq, count\\n\");\n    for (imapq=0; imapq < 256; imapq++)\n    {\n        if ( stats->mapping_qualities[imapq]>0 )\n            fprintf(to, \"MAPQ\\t%d\\t%ld\\n\", imapq, (long)stats->mapping_qualities[imapq]);\n    }\n\n    fprintf(to, \"# Indel distribution. Use `grep ^ID | cut -f 2-` to extract this part. The columns are: length, number of insertions, number of deletions\\n\");\n\n    for (ilen=0; ilen<stats->nindels; ilen++)\n    {\n        if ( stats->insertions[ilen]>0 || stats->deletions[ilen]>0 )\n            fprintf(to, \"ID\\t%d\\t%ld\\t%ld\\n\", ilen+1, (long)stats->insertions[ilen], (long)stats->deletions[ilen]);\n    }\n\n    fprintf(to, \"# Indels per cycle. Use `grep ^IC | cut -f 2-` to extract this part. The columns are: cycle, number of insertions (fwd), .. (rev) , number of deletions (fwd), .. (rev)\\n\");\n    for (ilen=0; ilen<=stats->nbases; ilen++)\n    {\n        // For deletions we print the index of the cycle before the deleted base (1-based) and for insertions\n        //  the index of the cycle of the first inserted base (also 1-based)\n        if ( stats->ins_cycles_1st[ilen]>0 || stats->ins_cycles_2nd[ilen]>0 || stats->del_cycles_1st[ilen]>0 || stats->del_cycles_2nd[ilen]>0 )\n            fprintf(to, \"IC\\t%d\\t%ld\\t%ld\\t%ld\\t%ld\\n\", ilen+1, (long)stats->ins_cycles_1st[ilen], (long)stats->ins_cycles_2nd[ilen], (long)stats->del_cycles_1st[ilen], (long)stats->del_cycles_2nd[ilen]);\n    }\n\n    fprintf(to, \"# Coverage distribution. Use `grep ^COV | cut -f 2-` to extract this part.\\n\");\n    if  ( stats->cov[0] )\n        fprintf(to, \"COV\\t[<%d]\\t%d\\t%ld\\n\",stats->info->cov_min,stats->info->cov_min-1, (long)stats->cov[0]);\n    for (icov=1; icov<stats->ncov-1; icov++)\n        if ( stats->cov[icov] )\n            fprintf(to, \"COV\\t[%d-%d]\\t%d\\t%ld\\n\",stats->info->cov_min + (icov-1)*stats->info->cov_step, stats->info->cov_min + icov*stats->info->cov_step-1,stats->info->cov_min + icov*stats->info->cov_step-1, (long)stats->cov[icov]);\n    if ( stats->cov[stats->ncov-1] )\n        fprintf(to, \"COV\\t[%d<]\\t%d\\t%ld\\n\",stats->info->cov_min + (stats->ncov-2)*stats->info->cov_step-1,stats->info->cov_min + (stats->ncov-2)*stats->info->cov_step-1, (long)stats->cov[stats->ncov-1]);\n\n    // Calculate average GC content, then sort by GC and depth\n    fprintf(to, \"# GC-depth. Use `grep ^GCD | cut -f 2-` to extract this part. The columns are: GC%%, unique sequence percentiles, 10th, 25th, 50th, 75th and 90th depth percentile\\n\");\n    uint32_t igcd;\n    for (igcd=0; igcd<stats->igcd; igcd++)\n    {\n        if ( stats->info->fai )\n            stats->gcd[igcd].gc = rint(100. * stats->gcd[igcd].gc);\n        else\n            if ( stats->gcd[igcd].depth )\n                stats->gcd[igcd].gc = rint(100. * stats->gcd[igcd].gc / stats->gcd[igcd].depth);\n    }\n    if ( stats->ngcd )\n        qsort(stats->gcd, stats->igcd+1, sizeof(gc_depth_t), gcd_cmp);\n    igcd = 0;\n    while ( igcd < stats->igcd )\n    {\n        // Calculate percentiles (10,25,50,75,90th) for the current GC content and print\n        uint32_t nbins=0, itmp=igcd;\n        float gc = stats->gcd[igcd].gc;\n        while ( itmp<stats->igcd && fabs(stats->gcd[itmp].gc-gc)<0.1 )\n        {\n            nbins++;\n            itmp++;\n        }\n        fprintf(to, \"GCD\\t%.1f\\t%.3f\\t%.3f\\t%.3f\\t%.3f\\t%.3f\\t%.3f\\n\", gc, (igcd+nbins+1)*100./(stats->igcd+1),\n                gcd_percentile(&(stats->gcd[igcd]),nbins,10) *avg_read_length/stats->info->gcd_bin_size,\n                gcd_percentile(&(stats->gcd[igcd]),nbins,25) *avg_read_length/stats->info->gcd_bin_size,\n                gcd_percentile(&(stats->gcd[igcd]),nbins,50) *avg_read_length/stats->info->gcd_bin_size,\n                gcd_percentile(&(stats->gcd[igcd]),nbins,75) *avg_read_length/stats->info->gcd_bin_size,\n                gcd_percentile(&(stats->gcd[igcd]),nbins,90) *avg_read_length/stats->info->gcd_bin_size\n              );\n        igcd += nbins;\n    }\n}\n\nstatic void init_regions(stats_t *stats, const char *file, stats_info_t* info)\n{\n    FILE *fp = fopen(file,\"r\");\n    if ( !fp ) error(\"%s: %s\\n\",file,strerror(errno));\n\n    kstring_t line = { 0, 0, NULL };\n    int warned = 0, r, p, new_p;\n    int prev_tid=-1;\n    hts_pos_t prev_pos=-1LL;\n    while (line.l = 0, kgetline(&line, (kgets_func *)fgets, fp) >= 0)\n    {\n        if ( line.s[0] == '#' ) continue;\n\n        int i = 0;\n        while ( i<line.l && !isspace(line.s[i]) ) i++;\n        if ( i>=line.l ) error(\"Could not parse the file: %s [%s]\\n\", file, line.s);\n        line.s[i] = '\\0';\n\n        int tid = bam_name2id(stats->info->sam_header, line.s);\n        if ( tid < 0 )\n        {\n            if ( !warned )\n                fprintf(stderr,\"Warning: Some sequences not present in the BAM, e.g. \\\"%s\\\". This message is printed only once.\\n\", line.s);\n            warned = 1;\n            continue;\n        }\n\n        if ( tid >= stats->nregions )\n        {\n            if(!(stats->regions = realloc(stats->regions,sizeof(regions_t)*(tid+REG_INC))))\n                error(\"Could not allocate memory for region.\\n\");\n\n            int j;\n            for (j=stats->nregions; j<tid+REG_INC; j++)\n            {\n                stats->regions[j].npos = stats->regions[j].mpos = stats->regions[j].cpos = 0;\n                stats->regions[j].pos = NULL;\n            }\n            stats->nregions = tid+REG_INC;\n        }\n        int npos = stats->regions[tid].npos;\n        if ( npos >= stats->regions[tid].mpos )\n        {\n            stats->regions[tid].mpos = npos+POS_INC;\n            if (!(stats->regions[tid].pos = realloc(stats->regions[tid].pos, sizeof(hts_pair_pos_t)*stats->regions[tid].mpos)))\n                error(\"Could not allocate memory for interval.\\n\");\n        }\n\n        if ( (sscanf(&line.s[i+1],\"%\"SCNd64\" %\"SCNd64, &stats->regions[tid].pos[npos].beg, &stats->regions[tid].pos[npos].end))!=2 ) error(\"Could not parse the region [%s]\\n\", &line.s[i+1]);\n        if ( prev_tid==-1 || prev_tid!=tid )\n        {\n            prev_tid = tid;\n            prev_pos = stats->regions[tid].pos[npos].beg;\n        }\n        if ( prev_pos>stats->regions[tid].pos[npos].beg )\n            error(\"The positions are not in chromosomal order (%s:%\"PRIhts_pos\" comes after %\"PRIhts_pos\")\\n\", line.s, stats->regions[tid].pos[npos].beg, prev_pos);\n        stats->regions[tid].npos++;\n        if ( stats->regions[tid].npos > stats->nchunks )\n            stats->nchunks = stats->regions[tid].npos;\n    }\n    free(line.s);\n    if ( !stats->regions ) error(\"Unable to map the -t sequences to the BAM sequences.\\n\");\n    fclose(fp);\n\n    // sort region intervals and remove duplicates\n    for (r = 0; r < stats->nregions; r++) {\n        regions_t *reg = &stats->regions[r];\n        if ( reg->npos > 1 ) {\n            qsort(reg->pos, reg->npos, sizeof(hts_pair_pos_t), regions_lt);\n            for (new_p = 0, p = 1; p < reg->npos; p++) {\n                if ( reg->pos[new_p].end < reg->pos[p].beg )\n                    reg->pos[++new_p] = reg->pos[p];\n                else if ( reg->pos[new_p].end < reg->pos[p].end )\n                    reg->pos[new_p].end = reg->pos[p].end;\n            }\n            reg->npos = ++new_p;\n        }\n        for (p = 0; p < reg->npos; p++) {\n            if (reg->pos[p].end < HTS_POS_MAX) {\n                stats->target_count += (reg->pos[p].end - reg->pos[p].beg + 1);\n            } else {\n                uint64_t hdr_end = sam_hdr_tid2len(info->sam_header, r);\n                if (hdr_end)\n                    stats->target_count += (hdr_end - reg->pos[p].beg + 1);\n            }\n        }\n    }\n\n    if (!(stats->chunks = calloc(stats->nchunks, sizeof(hts_pair_pos_t))))\n        error(\"Could not allocate memory for chunk.\\n\");\n}\n\nvoid destroy_regions(stats_t *stats)\n{\n    int i;\n    for (i=0; i<stats->nregions; i++)\n    {\n        if ( !stats->regions[i].mpos ) continue;\n        free(stats->regions[i].pos);\n    }\n    if ( stats->regions ) free(stats->regions);\n    if ( stats->chunks ) free(stats->chunks);\n}\n\nvoid reset_regions(stats_t *stats)\n{\n    int i;\n    for (i=0; i<stats->nregions; i++)\n        stats->regions[i].cpos = 0;\n}\n\nint is_in_regions(bam1_t *bam_line, stats_t *stats)\n{\n    if ( !stats->regions ) return 1;\n\n    if ( bam_line->core.tid >= stats->nregions || bam_line->core.tid<0 ) return 0;\n    if ( !stats->is_sorted ) error(\"The BAM must be sorted in order for -t to work.\\n\");\n\n    regions_t *reg = &stats->regions[bam_line->core.tid];\n    if ( reg->cpos==reg->npos ) return 0;       // done for this chr\n\n    // Find a matching interval or skip this read. No splicing of reads is done, no indels or soft clips considered,\n    //  even small overlap is enough to include the read in the stats.\n    int i = reg->cpos;\n    while ( i<reg->npos && reg->pos[i].end<=bam_line->core.pos ) i++;\n    if ( i>=reg->npos ) { reg->cpos = reg->npos; return 0; }\n    int64_t endpos = bam_endpos(bam_line);\n    if ( endpos < reg->pos[i].beg ) return 0;\n\n    //found a read overlapping a region\n    reg->cpos = i;\n    stats->reg_from = reg->pos[i].beg;\n    stats->reg_to   = reg->pos[i].end;\n\n    //now find all the overlapping chunks\n    stats->nchunks = 0;\n    while (i < reg->npos) {\n        if (bam_line->core.pos < reg->pos[i].end && endpos >= reg->pos[i].beg) {\n            stats->chunks[stats->nchunks].beg = MAX(bam_line->core.pos+1, reg->pos[i].beg);\n            stats->chunks[stats->nchunks].end = MIN(endpos, reg->pos[i].end);\n            stats->nchunks++;\n        }\n        i++;\n    }\n\n    return 1;\n}\n\nint replicate_regions(stats_t *stats, hts_itr_multi_t *iter, stats_info_t *info) {\n    if ( !stats || !iter)\n        return 1;\n\n    int i, j, tid;\n    stats->nregions = iter->n_reg;\n    stats->regions = calloc(stats->nregions, sizeof(regions_t));\n    stats->chunks = calloc(stats->nchunks, sizeof(hts_pair_pos_t));\n    if ( !stats->regions || !stats->chunks )\n        return 1;\n\n    for (i = 0; i < iter->n_reg; i++) {\n        tid = iter->reg_list[i].tid;\n        if ( tid < 0 )\n            continue;\n\n        if ( tid >= stats->nregions ) {\n            regions_t *tmp = realloc(stats->regions, (tid+10) * sizeof(regions_t));\n            if ( !tmp )\n                return 1;\n            stats->regions = tmp;\n            memset(stats->regions + stats->nregions, 0,\n                   (tid+10-stats->nregions) * sizeof(regions_t));\n            stats->nregions = tid+10;\n        }\n\n        stats->regions[tid].mpos = stats->regions[tid].npos = iter->reg_list[i].count;\n        stats->regions[tid].pos = calloc(stats->regions[tid].mpos, sizeof(hts_pair_pos_t));\n        if ( !stats->regions[tid].pos )\n            return 1;\n\n        for (j = 0; j < stats->regions[tid].npos; j++) {\n            stats->regions[tid].pos[j].beg = iter->reg_list[i].intervals[j].beg+1;\n            stats->regions[tid].pos[j].end = iter->reg_list[i].intervals[j].end;\n            if (stats->regions[tid].pos[j].end < HTS_POS_MAX) {\n                stats->target_count += (stats->regions[tid].pos[j].end - stats->regions[tid].pos[j].beg + 1);\n            } else {\n                uint64_t hdr_end = sam_hdr_tid2len(info->sam_header, tid);\n                if (hdr_end)\n                    stats->target_count += (hdr_end - stats->regions[tid].pos[j].beg + 1);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic void init_group_id(stats_t *stats, stats_info_t *info, const char *id)\n{\n    stats->rg_hash = kh_init(rg);\n    if (!stats->rg_hash) error(\"Could not initialise RG set\\n\");\n    sam_hdr_t *hdr = info->sam_header;\n    const char *key;\n    kstring_t sm = KS_INITIALIZE;\n    int i, ret, nrg = sam_hdr_count_lines(hdr, \"RG\");\n    if (nrg < 0) error(\"Could not parse header\\n\");\n\n    for (i=0; i<nrg; i++) {\n        key = sam_hdr_line_name(hdr, \"RG\", i);\n        if (!strcmp(key, id)) {\n            kh_put(rg, stats->rg_hash, key, &ret);\n            if (ret == -1) { ks_free(&sm); error(\"Could not add key \\\"%s\\\" to RG set\\n\", key); }\n        } else { /* Check for SM name, as per manual */\n            if (!sam_hdr_find_tag_pos(hdr, \"RG\", i, \"SM\", &sm)) {\n                if (!strcmp(ks_c_str(&sm), id)) {\n                    kh_put(rg, stats->rg_hash, key, &ret);\n                    if (ret == -1) { ks_free(&sm); error(\"Could not add key \\\"%s\\\" to RG set\\n\", key); }\n                }\n            }\n        }\n    }\n\n    ks_free(&sm);\n}\n\n\nstatic void  HTS_FORMAT(HTS_PRINTF_FMT, 1, 2) HTS_NORETURN\nerror(const char *format, ...)\n{\n    if ( !format )\n    {\n        printf(\"About: The program collects statistics from BAM files. The output can be visualized using plot-bamstats.\\n\");\n        printf(\"Usage: samtools stats [OPTIONS] file.bam\\n\");\n        printf(\"       samtools stats [OPTIONS] file.bam chr:from-to\\n\");\n        printf(\"Options:\\n\");\n        printf(\"    -c, --coverage <int>,<int>,<int>    Coverage distribution min,max,step [1,1000,1]\\n\");\n        printf(\"    -d, --remove-dups                   Exclude from statistics reads marked as duplicates\\n\");\n        printf(\"    -X, --customized-index-file         Use a customized index file\\n\");\n        printf(\"    -f, --required-flag  <str|int>      Required flag, 0 for unset. See also `samtools flags` [0]\\n\");\n        printf(\"    -F, --filtering-flag <str|int>      Filtering flag, 0 for unset. See also `samtools flags` [0]\\n\");\n        printf(\"        --GC-depth <float>              the size of GC-depth bins (decreasing bin size increases memory requirement) [2e4]\\n\");\n        printf(\"    -h, --help                          This help message\\n\");\n        printf(\"    -i, --insert-size <int>             Maximum insert size [8000]\\n\");\n        printf(\"    -I, --id <string>                   Include only listed read group or sample name\\n\");\n        printf(\"    -l, --read-length <int>             Include in the statistics only reads with the given read length [-1]\\n\");\n        printf(\"    -m, --most-inserts <float>          Report only the main part of inserts [0.99]\\n\");\n        printf(\"    -P, --split-prefix <str>            Path or string prefix for filepaths output by -S (default is input filename)\\n\");\n        printf(\"    -q, --trim-quality <int>            The BWA trimming parameter [0]\\n\");\n        printf(\"    -r, --ref-seq <file>                Reference sequence (required for GC-depth and mismatches-per-cycle calculation).\\n\");\n        printf(\"    -s, --sam                           Ignored (input format is auto-detected).\\n\");\n        printf(\"    -S, --split <tag>                   Also write statistics to separate files split by tagged field.\\n\");\n        printf(\"    -t, --target-regions <file>         Do stats in these regions only. Tab-delimited file chr,from,to, 1-based, inclusive.\\n\");\n        printf(\"    -x, --sparse                        Suppress outputting IS rows where there are no insertions.\\n\");\n        printf(\"    -p, --remove-overlaps               Remove overlaps of paired-end reads from coverage and base count computations.\\n\");\n        printf(\"    -g, --cov-threshold <int>           Only bases with coverage above this value will be included in the target percentage computation [0]\\n\");\n        sam_global_opt_help(stdout, \"-.--.@-.\");\n        printf(\"\\n\");\n    }\n    else\n    {\n        va_list ap;\n        va_start(ap, format);\n        vfprintf(stderr, format, ap);\n        va_end(ap);\n    }\n    exit(1);\n}\n\nvoid cleanup_stats_info(stats_info_t* info){\n    if (info->fai) fai_destroy(info->fai);\n    if (info->sam) sam_close(info->sam);\n    free(info);\n}\n\nvoid cleanup_stats(stats_t* stats)\n{\n    free(stats->cov_rbuf.buffer); free(stats->cov);\n    free(stats->quals_1st); free(stats->quals_2nd);\n    free(stats->gc_1st); free(stats->gc_2nd);\n    stats->isize->isize_free(stats->isize->data);\n    free(stats->isize);\n    free(stats->gcd);\n    free(stats->rseq_buf);\n    free(stats->mpc_buf);\n    free(stats->acgtno_cycles_1st);\n    free(stats->acgtno_cycles_2nd);\n    free(stats->acgtno_revcomp);\n    free(stats->read_lengths);\n    free(stats->read_lengths_1st);\n    free(stats->read_lengths_2nd);\n    free(stats->insertions);\n    free(stats->deletions);\n    free(stats->ins_cycles_1st);\n    free(stats->ins_cycles_2nd);\n    free(stats->del_cycles_1st);\n    free(stats->del_cycles_2nd);\n    if (stats->acgtno_barcode) free(stats->acgtno_barcode);\n    if (stats->quals_barcode) free(stats->quals_barcode);\n    free(stats->tags_barcode);\n    destroy_regions(stats);\n    if ( stats->rg_hash ) kh_destroy(rg, stats->rg_hash);\n    free(stats->split_name);\n    free(stats->mapping_qualities);\n    free(stats);\n}\n\nvoid output_split_stats(khash_t(c2stats) *split_hash, char* bam_fname, int sparse)\n{\n    int i = 0;\n    kstring_t output_filename = { 0, 0, NULL };\n    stats_t *curr_stats = NULL;\n    for(i = kh_begin(split_hash); i != kh_end(split_hash); ++i){\n        if(!kh_exist(split_hash, i)) continue;\n        curr_stats = kh_value(split_hash, i);\n        round_buffer_flush(curr_stats, -1);\n\n        output_filename.l = 0;\n        if (curr_stats->info->split_prefix)\n            kputs(curr_stats->info->split_prefix, &output_filename);\n        else\n            kputs(bam_fname, &output_filename);\n        kputc('_', &output_filename);\n        kputs(curr_stats->split_name, &output_filename);\n        kputs(\".bamstat\", &output_filename);\n\n        FILE *to = fopen(output_filename.s, \"w\");\n        if(to == NULL){\n            error(\"Could not open '%s' for writing.\\n\", output_filename.s);\n        }\n        output_stats(to, curr_stats, sparse);\n        fclose(to);\n    }\n\n    free(output_filename.s);\n}\n\nvoid destroy_split_stats(khash_t(c2stats) *split_hash)\n{\n    if (!split_hash)\n        return;\n\n    int i = 0;\n    stats_t *curr_stats = NULL;\n    for(i = kh_begin(split_hash); i != kh_end(split_hash); ++i){\n        if(!kh_exist(split_hash, i)) continue;\n        curr_stats = kh_value(split_hash, i);\n        cleanup_stats(curr_stats);\n    }\n    kh_destroy(c2stats, split_hash);\n}\n\nstats_info_t* stats_info_init(int argc, char *argv[])\n{\n    stats_info_t* info = calloc(1, sizeof(stats_info_t));\n    if (!info) {\n        return NULL;\n    }\n\n    info->nisize = 8000;\n    info->isize_main_bulk = 0.99;   // There are always outliers at the far end\n    info->gcd_bin_size = 20e3;\n    info->cov_min  = 1;\n    info->cov_max  = 1000;\n    info->cov_step = 1;\n    info->filter_readlen = -1;\n    info->argc = argc;\n    info->argv = argv;\n    info->remove_overlaps = 0;\n    info->cov_threshold = 0;\n\n    return info;\n}\n\nint init_stat_info_fname(stats_info_t* info, const char* bam_fname, const htsFormat* in_fmt)\n{\n    // .. bam\n    samFile* sam;\n    if ((sam = sam_open_format(bam_fname, \"r\", in_fmt)) == 0) {\n        print_error_errno(\"stats\", \"failed to open \\\"%s\\\"\", bam_fname);\n        return 1;\n    }\n    info->sam = sam;\n    info->sam_header = sam_hdr_read(sam);\n    if (info->sam_header == NULL) {\n        print_error(\"stats\", \"failed to read header for \\\"%s\\\"\", bam_fname);\n        return 1;\n    }\n    return 0;\n}\n\nstats_t* stats_init(void)\n{\n    stats_t *stats = calloc(1,sizeof(stats_t));\n    if (!stats)\n        return NULL;\n\n    stats->ngc    = 200;\n    stats->nquals = 256;\n    stats->nbases = 300;\n    stats->rseq_pos     = -1;\n    stats->tid = -1;\n    stats->gcd_pos = -1LL;\n    stats->igcd = 0;\n    stats->is_sorted = 1;\n    stats->nindels = stats->nbases;\n    stats->split_name = NULL;\n    stats->nchunks = 0;\n    stats->pair_count = 0;\n    stats->last_pair_tid = -2;\n    stats->last_read_flush = 0;\n    stats->target_count = 0;\n\n    return stats;\n}\n\nstatic int init_barcode_tags(stats_t* stats) {\n    stats->ntags = 4;\n    stats->tags_barcode = calloc(stats->ntags, sizeof(barcode_info_t));\n    if (!stats->tags_barcode)\n        return -1;\n    stats->tags_barcode[0] = (barcode_info_t){\"BC\", \"QT\", 0, -1, -1, 0};\n    stats->tags_barcode[1] = (barcode_info_t){\"CR\", \"CY\", 0, -1, -1, 0};\n    stats->tags_barcode[2] = (barcode_info_t){\"OX\", \"BZ\", 0, -1, -1, 0};\n    stats->tags_barcode[3] = (barcode_info_t){\"RX\", \"QX\", 0, -1, -1, 0};\n    return 0;\n}\n\nstatic void init_stat_structs(stats_t* stats, stats_info_t* info, const char* group_id, const char* targets)\n{\n    // Give stats_t a pointer to the info struct\n    // This saves us having to pass the stats_info_t to every function\n    stats->info = info;\n\n    // Init structures\n    //  .. coverage bins and round buffer\n    if ( info->cov_step > info->cov_max - info->cov_min + 1 )\n    {\n        info->cov_step = info->cov_max - info->cov_min;\n        if ( info->cov_step <= 0 )\n            info->cov_step = 1;\n    }\n    stats->ncov = 3 + (info->cov_max-info->cov_min) / info->cov_step;\n    info->cov_max = info->cov_min + ((info->cov_max-info->cov_min)/info->cov_step +1)*info->cov_step - 1;\n    stats->cov = calloc(sizeof(uint64_t),stats->ncov);\n    if (!stats->cov) goto nomem;\n    stats->cov_rbuf.size = stats->nbases*5;\n    stats->cov_rbuf.buffer = calloc(sizeof(int32_t),stats->cov_rbuf.size);\n    if (!stats->cov_rbuf.buffer) goto nomem;\n    if ( group_id ) init_group_id(stats, info, group_id);\n    // .. arrays\n    stats->quals_1st      = calloc(stats->nquals*stats->nbases,sizeof(uint64_t));\n    if (!stats->quals_1st) goto nomem;\n    stats->quals_2nd      = calloc(stats->nquals*stats->nbases,sizeof(uint64_t));\n    if (!stats->quals_2nd) goto nomem;\n    stats->gc_1st         = calloc(stats->ngc,sizeof(uint64_t));\n    if (!stats->gc_1st) goto nomem;\n    stats->gc_2nd         = calloc(stats->ngc,sizeof(uint64_t));\n    if (!stats->gc_2nd) goto nomem;\n    stats->isize          = init_isize_t(info->nisize ?info->nisize+1 :0);\n    if (!stats->isize) goto nomem;\n    stats->gcd            = calloc(stats->ngcd,sizeof(gc_depth_t));\n    if (!stats->gcd) goto nomem;\n    if (info->fai) {\n        stats->mpc_buf    = calloc(stats->nquals*stats->nbases,sizeof(uint64_t));\n        if (!stats->mpc_buf) goto nomem;\n    } else {\n        stats->mpc_buf    = NULL;\n    }\n    stats->acgtno_cycles_1st  = calloc(stats->nbases,sizeof(acgtno_count_t));\n    if (!stats->acgtno_cycles_1st) goto nomem;\n    stats->acgtno_cycles_2nd  = calloc(stats->nbases,sizeof(acgtno_count_t));\n    if (!stats->acgtno_cycles_2nd) goto nomem;\n    stats->acgtno_revcomp  = calloc(stats->nbases,sizeof(acgtno_count_t));\n    if (!stats->acgtno_revcomp) goto nomem;\n    stats->read_lengths   = calloc(stats->nbases,sizeof(uint64_t));\n    if (!stats->read_lengths)     goto nomem;\n    stats->read_lengths_1st   = calloc(stats->nbases,sizeof(uint64_t));\n    if (!stats->read_lengths_1st) goto nomem;\n    stats->read_lengths_2nd   = calloc(stats->nbases,sizeof(uint64_t));\n    if (!stats->read_lengths_2nd) goto nomem;\n    stats->insertions     = calloc(stats->nbases,sizeof(uint64_t));\n    if (!stats->insertions) goto nomem;\n    stats->deletions      = calloc(stats->nbases,sizeof(uint64_t));\n    if (!stats->deletions)  goto nomem;\n    stats->ins_cycles_1st = calloc(stats->nbases+1,sizeof(uint64_t));\n    if (!stats->ins_cycles_1st) goto nomem;\n    stats->ins_cycles_2nd = calloc(stats->nbases+1,sizeof(uint64_t));\n    if (!stats->ins_cycles_2nd) goto nomem;\n    stats->del_cycles_1st = calloc(stats->nbases+1,sizeof(uint64_t));\n    if (!stats->del_cycles_1st) goto nomem;\n    stats->del_cycles_2nd = calloc(stats->nbases+1,sizeof(uint64_t));\n    if (!stats->del_cycles_2nd) goto nomem;\n    stats->mapping_qualities = calloc(256,sizeof(uint64_t));\n    if(!stats->mapping_qualities) goto nomem;\n    if (init_barcode_tags(stats) < 0)\n        goto nomem;\n    realloc_rseq_buffer(stats);\n    if ( targets )\n        init_regions(stats, targets, info);\n    return;\n nomem:\n    error(\"Out of memory\");\n}\n\nstatic stats_t* get_curr_split_stats(bam1_t* bam_line, khash_t(c2stats)* split_hash, stats_info_t* info, char* targets)\n{\n    stats_t *curr_stats = NULL;\n    const uint8_t *tag_val = bam_aux_get(bam_line, info->split_tag);\n    if(tag_val == 0){\n        error(\"Tag '%s' not found in bam_line.\\n\", info->split_tag);\n    }\n    char* split_name = strdup(bam_aux2Z(tag_val));\n\n    // New stats object, under split\n    khiter_t k = kh_get(c2stats, split_hash, split_name);\n    if(k == kh_end(split_hash)){\n        curr_stats = stats_init(); // mallocs new instance\n        if (!curr_stats) {\n            error(\"Couldn't allocate split stats\");\n        }\n        init_stat_structs(curr_stats, info, NULL, targets);\n        curr_stats->split_name = split_name;\n\n        // Record index in hash\n        int ret = 0;\n        khiter_t iter = kh_put(c2stats, split_hash, split_name, &ret);\n        if( ret < 0 ){\n            error(\"Failed to insert key '%s' into split_hash\", split_name);\n        }\n        kh_val(split_hash, iter) = curr_stats; // store pointer to stats\n    }\n    else{\n        curr_stats = kh_value(split_hash, k);\n        free(split_name); // don't need to hold on to this if it wasn't new\n    }\n    return curr_stats;\n}\n\nint main_stats(int argc, char *argv[])\n{\n    char *targets = NULL;\n    char *bam_fname = NULL;\n    char *bam_idx_fname = NULL;\n    char *group_id = NULL;\n    int sparse = 0, has_index_file = 0, ret = 1;\n    sam_global_args ga = SAM_GLOBAL_ARGS_INIT;\n\n    stats_info_t *info = stats_info_init(argc, argv);\n    if (!info) {\n        fprintf(stderr, \"Could not allocate memory for info.\\n\");\n        return 1;\n    }\n\n    static const struct option loptions[] =\n    {\n        SAM_OPT_GLOBAL_OPTIONS('-', 0, '-', '-', 0, '@'),\n        {\"help\", no_argument, NULL, 'h'},\n        {\"remove-dups\", no_argument, NULL, 'd'},\n        {\"sam\", no_argument, NULL, 's'},\n        {\"customized-index-file\", required_argument, NULL, 'X'},\n        {\"ref-seq\", required_argument, NULL, 'r'},\n        {\"coverage\", required_argument, NULL, 'c'},\n        {\"read-length\", required_argument, NULL, 'l'},\n        {\"insert-size\", required_argument, NULL, 'i'},\n        {\"most-inserts\", required_argument, NULL, 'm'},\n        {\"trim-quality\", required_argument, NULL, 'q'},\n        {\"target-regions\", required_argument, NULL, 't'},\n        {\"required-flag\", required_argument, NULL, 'f'},\n        {\"filtering-flag\", required_argument, NULL, 'F'},\n        {\"id\", required_argument, NULL, 'I'},\n        {\"GC-depth\", required_argument, NULL, 1},\n        {\"sparse\", no_argument, NULL, 'x'},\n        {\"split\", required_argument, NULL, 'S'},\n        {\"split-prefix\", required_argument, NULL, 'P'},\n        {\"remove-overlaps\", no_argument, NULL, 'p'},\n        {\"cov-threshold\", required_argument, NULL, 'g'},\n        {NULL, 0, NULL, 0}\n    };\n    int opt, tmp_flag;\n\n    while ( (opt=getopt_long(argc,argv,\"?hdsXxpr:c:l:i:t:m:q:f:F:g:I:S:P:@:\",loptions,NULL))>0 )\n    {\n        switch (opt)\n        {\n            case 'f':\n                tmp_flag = bam_str2flag(optarg);\n\n                if (tmp_flag < 0) {\n                    print_error(\"stats\", \"Unknown flag '%s'\", optarg);\n                    return 1;\n                }\n\n                info->flag_require = tmp_flag;\n                break;\n\n            case 'F':\n                tmp_flag = bam_str2flag(optarg);\n\n                if (tmp_flag < 0) {\n                    print_error(\"stats\", \"Unknown flag '%s'\", optarg);\n                    return 1;\n                }\n\n                info->flag_filter |= tmp_flag;\n                break;\n\n            case 'd': info->flag_filter |= BAM_FDUP; break;\n            case 'X': has_index_file = 1; break;\n            case 's': break;\n            case 'r': info->fai = fai_load(optarg);\n                      if (info->fai==NULL)\n                          error(\"Could not load faidx: %s\\n\", optarg);\n                      break;\n            case  1 : info->gcd_bin_size = atof(optarg); break;\n            case 'c': if ( sscanf(optarg,\"%d,%d,%d\",&info->cov_min,&info->cov_max,&info->cov_step)!= 3 )\n                          error(\"Unable to parse -c %s\\n\", optarg);\n                      break;\n            case 'l': info->filter_readlen = atoi(optarg); break;\n            case 'i': info->nisize = atoi(optarg); break;\n            case 'm': info->isize_main_bulk = atof(optarg); break;\n            case 'q': info->trim_qual = atoi(optarg); break;\n            case 't': targets = optarg; break;\n            case 'I': group_id = optarg; break;\n            case 'x': sparse = 1; break;\n            case 'S': info->split_tag = optarg; break;\n            case 'P': info->split_prefix = optarg; break;\n            case 'p': info->remove_overlaps = 1; break;\n            case 'g': info->cov_threshold = atoi(optarg);\n                      if ( info->cov_threshold < 0 || info->cov_threshold == INT_MAX )\n                          error(\"Unsupported value for coverage threshold %d\\n\", info->cov_threshold);\n                      break;\n            case '?':\n            case 'h': error(NULL);\n            /* no break */\n            default:\n                if (parse_sam_global_opt(opt, optarg, loptions, &ga) != 0)\n                    error(\"Unknown argument: %s\\n\", optarg);\n                break;\n        }\n    }\n\n    bam_fname = argv[optind++];\n    if ( !bam_fname )\n    {\n        if ( isatty(STDIN_FILENO) )\n            error(NULL);\n        bam_fname = \"-\";\n    }\n\n    if (init_stat_info_fname(info, bam_fname, &ga.in)) {\n        cleanup_stats_info(info);\n        return 1;\n    }\n\n    if (has_index_file && !(bam_idx_fname = argv[optind++])) {\n        fprintf(stderr, \"No index file provided\\n\");\n        cleanup_stats_info(info);\n        return 1;\n    }\n\n    if (ga.nthreads > 0)\n        hts_set_threads(info->sam, ga.nthreads);\n\n    stats_t *all_stats = stats_init();\n    if (!all_stats) {\n        fprintf(stderr, \"Could not allocate memory for stats.\\n\");\n        cleanup_stats_info(info);\n        return 1;\n    }\n    stats_t *curr_stats = NULL;\n    init_stat_structs(all_stats, info, group_id, targets);\n    // Init\n    // .. hash\n    khash_t(c2stats)* split_hash = kh_init(c2stats);\n    if (!split_hash) goto cleanup_all_stats;\n\n    khash_t(qn2pair)* read_pairs = kh_init(qn2pair);\n    if (!read_pairs) goto cleanup_split_hash;\n\n    // Collect statistics\n    bam1_t *bam_line = bam_init1();\n    if (!bam_line) goto cleanup_read_pairs;\n\n    if (optind < argc) {\n        // Region:interval arguments in the command line\n        hts_idx_t *bam_idx = NULL;\n        if (has_index_file) {\n            bam_idx = sam_index_load2(info->sam, bam_fname, bam_idx_fname);\n        } else {\n            // If an index filename has not been specified, look alongside the alignment file\n            bam_idx = sam_index_load(info->sam, bam_fname);\n        }\n\n        if (bam_idx) {\n            hts_itr_multi_t *iter = sam_itr_regarray(bam_idx, info->sam_header, &argv[optind], argc - optind);\n            if (iter) {\n                if (!targets) {\n                    all_stats->nchunks = argc-optind;\n                    if (replicate_regions(all_stats, iter, info))\n                        fprintf(stderr, \"Replications of the regions failed\\n\");\n                }\n\n                if ( all_stats->nregions && all_stats->regions ) {\n                    while ((ret = sam_itr_next(info->sam, iter, bam_line)) >= 0) {\n                        if (info->split_tag) {\n                            curr_stats = get_curr_split_stats(bam_line, split_hash, info, targets);\n                            collect_stats(bam_line, curr_stats, read_pairs);\n                        }\n                        collect_stats(bam_line, all_stats, read_pairs);\n                    }\n\n                    if (ret < -1) {\n                        fprintf(stderr, \"Failure while running the iterator\\n\");\n                        hts_itr_multi_destroy(iter);\n                        hts_idx_destroy(bam_idx);\n                        goto cleanup;\n                    }\n                }\n                hts_itr_multi_destroy(iter);\n            } else {\n                fprintf(stderr, \"Multi-region iterator could not be created\\n\");\n                hts_idx_destroy(bam_idx);\n                goto cleanup;\n            }\n            hts_idx_destroy(bam_idx);\n        } else {\n            if (has_index_file)\n                fprintf(stderr, \"Invalid index file '%s'\\n\", bam_idx_fname);\n            fprintf(stderr, \"Random alignment retrieval only works for indexed files\\n\");\n            goto cleanup;\n        }\n    } else {\n        if ( info->cov_threshold > 0 && !targets ) {\n            fprintf(stderr, \"Coverage percentage calculation requires a list of target regions\\n\");\n            goto cleanup;\n        }\n\n        // Stream through the entire BAM ignoring off-target regions if -t is given\n        while ((ret = sam_read1(info->sam, info->sam_header, bam_line)) >= 0) {\n            if (info->split_tag) {\n                curr_stats = get_curr_split_stats(bam_line, split_hash, info, targets);\n                collect_stats(bam_line, curr_stats, read_pairs);\n            }\n            collect_stats(bam_line, all_stats, read_pairs);\n        }\n\n        if (ret < -1) {\n            fprintf(stderr, \"Failure while decoding file\\n\");\n            goto cleanup;\n        }\n    }\n\n    round_buffer_flush(all_stats, -1);\n    output_stats(stdout, all_stats, sparse);\n    if (info->split_tag)\n        output_split_stats(split_hash, bam_fname, sparse);\n\n    ret = 0;\ncleanup:\n    bam_destroy1(bam_line);\n    sam_hdr_destroy(info->sam_header);\n    sam_global_args_free(&ga);\n\ncleanup_read_pairs:\n    cleanup_overlaps(read_pairs, INT64_MAX);\ncleanup_split_hash:\n    destroy_split_stats(split_hash);\ncleanup_all_stats:\n    cleanup_stats(all_stats);\n    cleanup_stats_info(info);\n\n    return ret;\n}\n"
        },
        {
          "name": "stats_isize.c",
          "type": "blob",
          "size": 7.8857421875,
          "content": "/*  stats_isize.c -- generalised insert size calculation for samtools stats.\n\n    Copyright (C) 2014, 2018 Genome Research Ltd.\n\n    Author: Nicholas Clarke <nc6@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include \"stats_isize.h\"\n#include <htslib/khash.h>\n\ntypedef enum {IN,OUT,OTHER} isize_insert_t;\n\nstatic int max(int a, int b) {\n    if (a < b) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nstatic isize_sparse_record_t * sparse_get_f(isize_data_t data, int at) {\n    isize_sparse_data_t *a = data.sparse;\n    khash_t(m32) *h = a->array;\n\n    khint_t k = kh_get(m32, h, at);\n    if (k != kh_end(h)) {\n        return kh_value(h, k);\n    } else {\n        return NULL;\n    }\n}\n\nstatic uint64_t sparse_in_f(isize_data_t data, int at) {\n    isize_sparse_record_t* a = sparse_get_f(data, at);\n    if (a != NULL) {\n        return a->isize_inward;\n    } else {\n        return 0;\n    }\n}\nstatic uint64_t sparse_out_f(isize_data_t data, int at) {\n    isize_sparse_record_t* a = sparse_get_f(data, at);\n    if (a != NULL) {\n        return a->isize_outward;\n    } else {\n        return 0;\n    }\n}\nstatic uint64_t sparse_other_f(isize_data_t data, int at) {\n    isize_sparse_record_t* a = sparse_get_f(data, at);\n    if (a != NULL) {\n        return a->isize_other;\n    } else {\n        return 0;\n    }\n}\n\nstatic void sparse_set_f(isize_data_t data, int at, isize_insert_t field, uint64_t value) {\n    isize_sparse_data_t *a = data.sparse;\n    khash_t(m32) *h = a->array;\n\n    khint_t k = kh_get(m32, h, at);\n    isize_sparse_record_t *rec;\n    if (k != kh_end(h)) {\n        rec = kh_value(h, k);\n    } else if (value != 0) {\n        rec = malloc(sizeof(isize_sparse_record_t));\n        if (rec != NULL) {\n            rec->isize_inward = 0;\n            rec->isize_outward = 0;\n            rec->isize_other = 0;\n            int stupid = 0;\n            khint_t it = kh_put(m32, h, at, & stupid);\n            kh_value(h, it) = rec;\n            a->max = max(at, a->max);\n        } else {\n            fprintf(stderr, \"%s\\n\", \"Failed to allocate memory for isize_sparse_record_t\");\n            exit(11);\n        }\n    } else {\n        return;\n    }\n    if (field == IN) {\n        rec->isize_inward = value;\n    } else if (field == OUT) {\n        rec->isize_outward = value;\n    } else {\n        rec->isize_other = value;\n    }\n\n}\n\nstatic void sparse_set_in_f(isize_data_t data, int at, uint64_t value) { sparse_set_f(data, at, IN, value); }\nstatic void sparse_set_out_f(isize_data_t data, int at, uint64_t value) { sparse_set_f(data, at, OUT, value); }\nstatic void sparse_set_other_f(isize_data_t data, int at, uint64_t value) { sparse_set_f(data, at, OTHER, value); }\n\nstatic void sparse_inc_in_f(isize_data_t data, int at) { sparse_set_in_f(data, at, sparse_in_f(data, at) + 1); }\nstatic void sparse_inc_out_f(isize_data_t data, int at) { sparse_set_out_f(data, at, sparse_out_f(data, at) + 1); }\nstatic void sparse_inc_other_f(isize_data_t data, int at) { sparse_set_other_f(data, at, sparse_other_f(data, at) + 1); }\n\nstatic void sparse_isize_free(isize_data_t data) {\n    isize_sparse_data_t *a = data.sparse;\n    khint_t k;\n    for (k = 0; k < kh_end(a->array); ++k)\n        if (kh_exist(a->array, k)) free(kh_val(a->array, k));\n    kh_destroy(m32, a->array);\n    free(a);\n}\n\nstatic int sparse_nitems(isize_data_t data) {\n    isize_sparse_data_t *a = data.sparse;\n    return a->max + 1;\n}\n\nstatic uint64_t dense_in_f(isize_data_t data, int at) { return data.dense->isize_inward[at]; }\nstatic uint64_t dense_out_f(isize_data_t data, int at) { return data.dense->isize_outward[at]; }\nstatic uint64_t dense_other_f(isize_data_t data, int at) { return data.dense->isize_other[at]; }\n\nstatic void dense_set_in_f(isize_data_t data, int at, uint64_t value) { data.dense->isize_inward[at] = value; }\nstatic void dense_set_out_f(isize_data_t data, int at, uint64_t value) { data.dense->isize_outward[at] = value; }\nstatic void dense_set_other_f(isize_data_t data, int at, uint64_t value) { data.dense->isize_other[at] = value; }\n\nstatic void dense_inc_in_f(isize_data_t data, int at) { data.dense->isize_inward[at] += 1; }\nstatic void dense_inc_out_f(isize_data_t data, int at) { data.dense->isize_outward[at] += 1; }\nstatic void dense_inc_other_f(isize_data_t data, int at) { data.dense->isize_other[at] += 1; }\n\nstatic void dense_isize_free(isize_data_t data) {\n    isize_dense_data_t *a = data.dense;\n    free(a->isize_inward);\n    free(a->isize_outward);\n    free(a->isize_other);\n    free(a);\n}\n\nstatic int dense_nitems(isize_data_t data) {\n    isize_dense_data_t *a = data.dense;\n    return a->total;\n}\n\n// Construct a relevant isize_t given the bound.\nisize_t *init_isize_t(int bound) {\n    if (bound <= 0) {\n        // Use sparse data structure.\n        isize_sparse_data_t *data = (isize_sparse_data_t *) malloc(sizeof(isize_sparse_data_t));\n        if (!data)\n            return NULL;\n\n        // Initialise\n        data->max = 0;\n        data->array = kh_init(m32);\n        if (!data->array) {\n            free(data);\n            return NULL;\n        }\n\n        isize_t *isize = (isize_t *)malloc(sizeof(isize_t));\n        if (!isize) {\n            kh_destroy(m32, data->array);\n            free(data);\n            return NULL;\n        }\n\n        isize->data.sparse = data;\n        isize->nitems = & sparse_nitems;\n\n        isize->inward = & sparse_in_f;\n        isize->outward = & sparse_out_f;\n        isize->other = & sparse_other_f;\n\n        isize->set_inward = & sparse_set_in_f;\n        isize->set_outward = & sparse_set_out_f;\n        isize->set_other = & sparse_set_other_f;\n\n        isize->inc_inward = & sparse_inc_in_f;\n        isize->inc_outward = & sparse_inc_out_f;\n        isize->inc_other = & sparse_inc_other_f;\n\n        isize->isize_free = & sparse_isize_free;\n\n        return isize;\n    } else {\n        uint64_t* in = calloc(bound,sizeof(uint64_t));\n        uint64_t* out = calloc(bound,sizeof(uint64_t));\n        uint64_t* other = calloc(bound,sizeof(uint64_t));\n        isize_dense_data_t *rec = (isize_dense_data_t *)malloc(sizeof(isize_dense_data_t));\n        isize_t *isize = (isize_t *)malloc(sizeof(isize_t));\n        if (!in || !out || !other || !rec || !isize) {\n            free(in);\n            free(out);\n            free(other);\n            free(rec);\n            free(isize);\n            return NULL;\n        }\n        rec->isize_inward = in;\n        rec->isize_outward = out;\n        rec->isize_other = other;\n        rec->total=bound;\n\n        isize->data.dense = rec;\n        isize->nitems = & dense_nitems;\n\n        isize->inward = & dense_in_f;\n        isize->outward = & dense_out_f;\n        isize->other = & dense_other_f;\n\n        isize->set_inward = & dense_set_in_f;\n        isize->set_outward = & dense_set_out_f;\n        isize->set_other = & dense_set_other_f;\n\n        isize->inc_inward = & dense_inc_in_f;\n        isize->inc_outward = & dense_inc_out_f;\n        isize->inc_other = & dense_inc_other_f;\n\n        isize->isize_free = & dense_isize_free;\n\n        return isize;\n    }\n}\n"
        },
        {
          "name": "stats_isize.h",
          "type": "blob",
          "size": 2.42578125,
          "content": "/*  stats_isize.h -- generalised insert size calculation for samtools stats.\n\n    Copyright (C) 2014 Genome Research Ltd.\n\n    Author: Nicholas Clarke <nc6@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <htslib/khash.h>\n#include <stdint.h>\n\ntypedef struct\n{\n    int total;\n    uint64_t *isize_inward, *isize_outward, *isize_other;\n}\nisize_dense_data_t;\n\ntypedef struct\n{\n    uint64_t isize_inward, isize_outward, isize_other;\n}\nisize_sparse_record_t;\n\nKHASH_MAP_INIT_INT(m32, isize_sparse_record_t *)\n\ntypedef struct\n{\n    int max;\n    khash_t(m32) *array;\n}\nisize_sparse_data_t;\n\ntypedef union {\n    isize_sparse_data_t *sparse;\n    isize_dense_data_t *dense;\n} isize_data_t;\n\n// Insert size structure\ntypedef struct\n{\n    isize_data_t data;\n\n    // Maximum\n    int (*nitems)(isize_data_t);\n\n    // Fetch the number of inserts of a given size\n    uint64_t (*inward)(isize_data_t, int);\n    uint64_t (*outward)(isize_data_t, int);\n    uint64_t (*other)(isize_data_t, int);\n\n    // Set the number of inserts of a given size\n    void (*set_inward)(isize_data_t, int, uint64_t);\n    void (*set_outward)(isize_data_t, int, uint64_t);\n    void (*set_other)(isize_data_t, int, uint64_t);\n\n    // Increment the number of inserts of a given size\n    void (*inc_inward)(isize_data_t, int);\n    void (*inc_outward)(isize_data_t, int);\n    void (*inc_other)(isize_data_t, int);\n\n    // Free this structure\n    void (*isize_free)(isize_data_t);\n}\nisize_t;\n\nisize_t *init_isize_t(int bound);\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tmp_file.c",
          "type": "blob",
          "size": 13.4599609375,
          "content": "/*\n    tmp_file.c - write to and read from a temporary binary file\n    for fast storage plus added compression.\n\n    Copyright (C) 2017, 2018 Genome Research Ltd.\n\n    Author: Andrew Whitwham <aw7@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE\n*/\n\n#include <config.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#endif /* _WIN32 */\n\n#include \"tmp_file.h\"\n#include \"htslib/sam.h\"\n\n\nstatic void HTS_FORMAT(HTS_PRINTF_FMT, 2, 3)\ntmp_print_error(tmp_file_t *tmp, const char *fmt, ...) {\n    va_list argp;\n\n    if (tmp->verbose) {\n        va_start(argp, fmt);\n        vfprintf(stderr, fmt, argp);\n        va_end(argp);\n    }\n}\n\n\nstatic int tmp_file_init(tmp_file_t *tmp, int verbose) {\n    tmp->stream       = LZ4_createStream();\n    tmp->data_size    = 0;\n    tmp->group_size   = TMP_SAM_GROUP_SIZE;\n    tmp->input_size   = 0;\n    tmp->read_size    = 0;\n    tmp->output_size  = 0;\n    tmp->entry_number = 0;\n    tmp->offset = 0;\n    tmp->max_data_size    = TMP_SAM_MAX_DATA + sizeof(bam1_t); // arbitrary but growable\n    tmp->ring_buffer_size = TMP_SAM_RING_SIZE; // arbitrary (min 64K) but growable\n    tmp->comp_buffer_size = LZ4_COMPRESSBOUND(tmp->max_data_size * tmp->group_size);\n    tmp->ring_buffer = malloc(sizeof(uint8_t) * tmp->ring_buffer_size);\n    tmp->ring_index  = tmp->ring_buffer;\n    tmp->comp_buffer = malloc(tmp->comp_buffer_size);\n    tmp->verbose = verbose;\n    tmp->dict = NULL;\n    tmp->groups_written = 0;\n\n    if (!tmp->ring_buffer || !tmp->comp_buffer || !tmp->stream) {\n        tmp_print_error(tmp, \"[tmp_file] Error: unable to allocate compression buffers.\\n\");\n        return TMP_SAM_MEM_ERROR;\n    }\n\n    return TMP_SAM_OK;\n}\n\n\n/*\n * Opens the temp file and initialises memory.\n * Verbose mode prints out error messages to stderr.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_open_write(tmp_file_t *tmp, char *tmp_name, int verbose) {\n    int ret;\n    unsigned int count = 1;\n    const unsigned int max_count = 100000; // more tries than this then something else is wrong\n    int fd;\n\n    if ((ret = tmp_file_init(tmp, verbose))) {\n        return ret;\n    }\n\n    // make space to write extended file name\n    if ((tmp->name = malloc(strlen(tmp_name) + 7)) == NULL) {\n        tmp_print_error(tmp, \"[tmp_file] Error: unable to allocate memory for %s.\\n\", tmp_name);\n        return TMP_SAM_MEM_ERROR;\n    }\n\n    // make sure temp file has a unique name\n    while (count < max_count) {\n        sprintf(tmp->name, \"%s.%d\", tmp_name, count);\n\n\n        #ifdef _WIN32\n        if ((fd = _open(tmp->name, O_RDWR|O_CREAT|O_EXCL|O_BINARY|O_TEMPORARY, 0600)) == -1) {\n        #else\n        if ((fd = open(tmp->name, O_RDWR|O_CREAT|O_EXCL, 0600)) == -1) {\n        #endif /* _WIN32 */\n\n            if (errno != EEXIST) {\n                tmp_print_error(tmp, \"[tmp_file] Error: unable to create tmp file %s.\\n\", tmp->name);\n                return TMP_SAM_FILE_ERROR;\n            }\n\n            count++;\n            continue;\n        }\n\n        break;\n    }\n\n    if (count >= max_count) {\n        tmp_print_error(tmp, \"[tmp_file] Error: unable to create unique temp file.\\n\");\n        return TMP_SAM_FILE_ERROR;\n    }\n\n    if ((tmp->fp = fdopen(fd, \"w+b\")) == NULL) {\n        tmp_print_error(tmp, \"[tmp_file] Error: unable to open write file %s.\\n\", tmp->name);\n        return TMP_SAM_FILE_ERROR;\n    }\n\n    #ifndef _WIN32\n    unlink(tmp->name); // should auto delete when closed on linux\n    #endif\n\n    return TMP_SAM_OK;\n}\n\n\n/*\n * The ring buffer stores precompressionn/post decompression data.  LZ4 requires that\n * previous data (64K worth) be available for efficient compression.  This function grows\n * the ring buffer when needed.\n * Returns 0 on success, a negative number on failure.\n */\nstatic int tmp_file_grow_ring_buffer(tmp_file_t *tmp, size_t new_size) {\n    // save the dictionary so lz4 can continue to function\n    int dict_size = 64 * 1024; // 64K max size\n\n    if (tmp->groups_written) {\n        // if compression has been done then there is a dictionary to save\n\n        if (tmp->dict == NULL) {\n\n            if ((tmp->dict = malloc(sizeof(char) * dict_size)) == NULL) {\n                tmp_print_error(tmp, \"[tmp_file] Error: unable to allocate memory for compression dictionary.\\n\");\n                return TMP_SAM_MEM_ERROR;\n            }\n        }\n\n        if (LZ4_saveDict(tmp->stream, tmp->dict, dict_size) == 0) {\n            tmp_print_error(tmp, \"[tmp_file] Error: unable to save compression dictionary.\\n\");\n            return TMP_SAM_LZ4_ERROR;\n        }\n    }\n\n    if ((tmp->ring_buffer = realloc(tmp->ring_buffer, sizeof(char) * new_size)) == NULL) {\n        tmp_print_error(tmp, \"[tmp_file] Error: unable to reallocate ring buffer.\\n\");\n        return TMP_SAM_MEM_ERROR;\n    }\n\n    tmp->ring_buffer_size = new_size;\n\n    return TMP_SAM_OK;\n}\n\n\n/*\n * This does the actual compression and writing to a file.  The file format consists of a\n * single size_t for the size of the compressed data followed by the data itself.\n * Returns 0 on success, a negative number on failure.\n */\nstatic int tmp_file_write_to_file(tmp_file_t *tmp) {\n    size_t comp_size;\n\n    if (tmp->input_size > tmp->max_data_size) {\n        tmp->max_data_size += tmp->input_size + sizeof(bam1_t);\n        tmp->comp_buffer_size = LZ4_COMPRESSBOUND(tmp->max_data_size);\n\n        if ((tmp->comp_buffer = realloc(tmp->comp_buffer, sizeof(char) * tmp->comp_buffer_size)) == NULL) {\n            tmp_print_error(tmp, \"[tmp_file] Error: unable to reallocate compression buffer.\\n\");\n            return TMP_SAM_MEM_ERROR;\n        }\n\n        // make sure the ring buffer is big enough to accommodate the new max_data_size\n        if (tmp->ring_buffer_size < tmp->max_data_size * 5) {\n            int ret;\n            if ((ret = tmp_file_grow_ring_buffer(tmp, tmp->max_data_size * 5))) {\n                return ret;\n            }\n        }\n    }\n\n    tmp->ring_index = tmp->ring_buffer + tmp->offset;\n\n    comp_size = LZ4_compress_fast_continue(tmp->stream, (const char *)tmp->ring_index,\n                   tmp->comp_buffer, tmp->input_size, tmp->comp_buffer_size, 1);\n\n    if (comp_size == 0) {\n        tmp_print_error(tmp, \"[tmp_file] Error: compression failed.\\n\");\n        return TMP_SAM_LZ4_ERROR;\n    }\n\n    if (fwrite(&comp_size, sizeof(size_t), 1, tmp->fp) < 1) {\n        tmp_print_error(tmp, \"[tmp_file] Error: tmp file write size failed.\\n\");\n        return TMP_SAM_FILE_ERROR;\n    }\n\n    if (fwrite(tmp->comp_buffer, sizeof(char), comp_size, tmp->fp) < comp_size) {\n        tmp_print_error(tmp, \"[tmp_file] Error: tmp file write data failed.\\n\");\n        return TMP_SAM_FILE_ERROR;\n    }\n\n    tmp->offset += tmp->input_size;\n\n    if (tmp->offset >= tmp->ring_buffer_size - tmp->max_data_size)\n        tmp->offset = 0;\n\n    tmp->input_size = 0;\n    tmp->entry_number = 0;\n    tmp->groups_written++;\n\n    return TMP_SAM_OK;\n}\n\n\n/*\n * Stores an in memory bam structure for writing and if enough are gathered together writes\n * it to a file.  Multiple alignments compress better that single ones though after a certain number\n * there is a law of diminishing returns.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_write(tmp_file_t *tmp, bam1_t *inbam) {\n\n    if ((tmp->offset + tmp->input_size + sizeof(bam1_t) + inbam->l_data) >= tmp->ring_buffer_size) {\n        int ret;\n\n        if ((ret = tmp_file_grow_ring_buffer(tmp, (tmp->offset + tmp->input_size + sizeof(bam1_t) + inbam->l_data) * 2))) {\n            tmp_print_error(tmp, \"[tmp_file] Error: input line too big. (%zu).\\n\",\n                            (tmp->input_size + inbam->l_data));\n\n            return ret;\n        }\n    }\n\n    tmp->ring_index = tmp->ring_buffer + tmp->offset + tmp->input_size;\n\n    // copy data into the ring buffer\n    memcpy(tmp->ring_index, inbam, sizeof(bam1_t));\n    memcpy(tmp->ring_index + sizeof(bam1_t) , inbam->data, inbam->l_data);\n    tmp->input_size += sizeof(bam1_t) + inbam->l_data;\n    tmp->entry_number++;\n\n    if (tmp->entry_number == tmp->group_size) {\n        // actually write out the data\n        int ret;\n\n        if ((ret = tmp_file_write_to_file(tmp))) {\n            return ret;\n        }\n    }\n\n    return TMP_SAM_OK;\n}\n\n\n/*\n * Marks the end of file writing.  Adds a size_t 0 to mark the end of\n * the file. Companion function to tmp_file_begin_read below.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_end_write(tmp_file_t *tmp) {\n    size_t terminator = 0;\n\n    if (tmp->entry_number) {\n        int ret;\n\n        if ((ret = tmp_file_write_to_file(tmp))) {\n            return ret;\n        }\n    }\n\n    if (fwrite(&terminator, sizeof(size_t), 1, tmp->fp) < 1) {\n        tmp_print_error(tmp, \"[tmp_file] Error: tmp file write terminator failed.\\n\");\n        return TMP_SAM_FILE_ERROR;\n    }\n\n    fflush(tmp->fp);\n\n    LZ4_freeStream(tmp->stream);\n\n    return TMP_SAM_OK;\n}\n\n\n/*\n * Prepares the file for reading.\n * Companion function to tmp_file_end_write above.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_begin_read(tmp_file_t *tmp) {\n\n    rewind(tmp->fp);\n\n    tmp->dstream = LZ4_createStreamDecode();\n    tmp->offset  = 0;\n    tmp->entry_number = tmp->group_size;\n\n    if (!tmp->dstream) {\n        tmp_print_error(tmp, \"[tmp_file] Error: unable to allocate compression stream.\\n\");\n        return TMP_SAM_MEM_ERROR;\n    }\n\n    return TMP_SAM_OK;\n}\n\n\n/*\n * Read the next alignment, either from memory or from a file.\n * Returns size of entry on success, 0 on end of file or a negative on error.\n */\nint tmp_file_read(tmp_file_t *tmp, bam1_t *inbam) {\n    int entry_size;\n    uint8_t *data = inbam->data;\n\n    /* while tmp_file_read assumes that the same bam1_t variable\n       is being used in each call, this may not be the case. So\n       default to the lowest memory size for safety. */\n    if (tmp->data_size > inbam->m_data) {\n        tmp->data_size = inbam->m_data;\n    }\n\n    if (tmp->entry_number == tmp->group_size) {\n        // read more data\n        size_t comp_size;\n\n        if (fread(&comp_size, sizeof(size_t), 1, tmp->fp) == 0 || comp_size == 0) {\n            return TMP_SAM_OK;\n        }\n\n        if  (tmp->offset >= tmp->ring_buffer_size - tmp->max_data_size)\n            tmp->offset = 0;\n\n        tmp->ring_index = tmp->ring_buffer + tmp->offset;\n\n        if (fread(tmp->comp_buffer, sizeof(char), comp_size, tmp->fp) > comp_size) {\n            tmp_print_error(tmp, \"[tmp_file] Error: error reading compressed data.\\n\");\n            return TMP_SAM_FILE_ERROR;\n        }\n\n        tmp->output_size = LZ4_decompress_safe_continue(tmp->dstream, tmp->comp_buffer,\n                        (char *)tmp->ring_index, comp_size, tmp->max_data_size);\n\n        if (tmp->output_size == 0) {\n            tmp_print_error(tmp, \"[tmp_file] Error: decompression failed.\\n\");\n            return TMP_SAM_LZ4_ERROR;\n        }\n\n        tmp->entry_number = 0;\n        tmp->read_size    = 0;\n    }\n\n    tmp->ring_index = tmp->ring_buffer + tmp->offset;\n    memcpy(inbam, tmp->ring_index, sizeof(bam1_t));\n    inbam->data = data; // put the pointer to real bam data back\n\n    if ((unsigned int)inbam->l_data > tmp->data_size) {\n        uint8_t *tmp_data;\n        tmp->data_size = inbam->l_data; kroundup32(tmp->data_size);\n\n        if ((tmp_data = realloc(inbam->data, sizeof(uint8_t) * tmp->data_size)) == NULL) {\n            tmp_print_error(tmp, \"[tmp_file] Error: unable to allocate tmp bam data memory.\\n\");\n            return TMP_SAM_MEM_ERROR;\n        }\n\n        inbam->data = tmp_data;\n    }\n\n    inbam->m_data = tmp->data_size; // set to the actual data size\n\n    entry_size = sizeof(bam1_t);\n\n    memcpy(inbam->data, tmp->ring_index + entry_size, inbam->l_data);\n    entry_size += inbam->l_data;\n\n    tmp->offset += entry_size;\n    tmp->read_size += entry_size;\n    tmp->entry_number++;\n\n    if (tmp->read_size > tmp->output_size) {\n        tmp_print_error(tmp, \"[tmp_file] Error: wrong size of data returned RS:%zu OS:%zu EN:%zu GS:%zu.\\n\",\n            tmp->read_size, tmp->output_size, tmp->entry_number, tmp->group_size);\n        return TMP_SAM_LZ4_ERROR;\n    }\n\n    if (tmp->read_size == tmp->output_size && tmp->entry_number != tmp->group_size) {\n        // hopefully the last entries in the read file\n        tmp->entry_number = tmp->group_size;\n    }\n\n    return entry_size;\n}\n\n\n/*\n * Frees up memory, closes the file and deletes it.\n * Returns 0 on success or EOF on failure.\n */\nint tmp_file_destroy(tmp_file_t *tmp) {\n    int ret = 0;\n\n    ret = fclose(tmp->fp);\n\n    LZ4_freeStreamDecode(tmp->dstream);\n    free(tmp->ring_buffer);\n    free(tmp->comp_buffer);\n    free(tmp->name);\n    free(tmp->dict);\n\n    return ret;\n}\n"
        },
        {
          "name": "tmp_file.h",
          "type": "blob",
          "size": 3.5576171875,
          "content": "/*\n    tmp_file.h - write to and read from a temporary binary file\n    for fast storage plus added compression.\n\n    Copyright (C) 2017, 2018 Genome Research Ltd.\n\n    Author: Andrew Whitwham <aw7@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE\n*/\n\n#ifndef _TMP_SAM_FILE_H_\n#define _TMP_SAM_FILE_H_\n\n#include <lz4.h>\n#include \"htslib/sam.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Group size that seems to give reasonable compression.\n#define TMP_SAM_GROUP_SIZE 100\n\n// Arbitrary initial size values but growable.\n#define TMP_SAM_MAX_DATA 1024\n#define TMP_SAM_RING_SIZE 1048576\n\n// Error numbers.\n#define TMP_SAM_OK 0\n#define TMP_SAM_MEM_ERROR -1\n#define TMP_SAM_FILE_ERROR -2\n#define TMP_SAM_LZ4_ERROR -3\n#define TMP_SAM_INPUT_ERROR -4\n\ntypedef struct {\n    FILE *fp;\n    LZ4_stream_t *stream;\n    LZ4_streamDecode_t *dstream;\n    size_t data_size;\n    size_t max_data_size;\n    size_t ring_buffer_size;\n    size_t comp_buffer_size;\n    size_t offset;\n    uint8_t *ring_buffer;\n    uint8_t *ring_index;\n    char *comp_buffer;\n    char *name;\n    size_t group_size;\n    size_t input_size;\n    size_t read_size;\n    size_t output_size;\n    size_t entry_number;\n    int verbose;\n    char *dict;\n    size_t groups_written;\n} tmp_file_t;\n\n\n/*\n * Opens the temp file and initialises memory.\n * Verbose mode prints out error messages to stderr.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_open_write(tmp_file_t *tmp, char *tmp_name, int verbose);\n\n\n/*\n * Stores an in memory bam structure for writing and if enough are gathered together writes\n * it to a file.  Multiple alignments compress better that single ones though after a certain number\n * there is a law of diminishing returns.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_write(tmp_file_t *tmp, bam1_t *inbam);\n\n\n/*\n * Marks the end of file writing.  Adds a size_t 0 to mark the end of\n * the file. Companion function to tmp_file_begin_read below.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_end_write(tmp_file_t *tmp);\n\n/*\n * Prepares the file for reading.\n * Companion function to tmp_file_end_write above.\n * Returns 0 on success, a negative number on failure.\n */\nint tmp_file_begin_read(tmp_file_t *tmp);\n\n/*\n * Read the next alignment, either from memory or from a file.\n * Returns size of entry on success, 0 on end of file or a negative on error.\n */\nint tmp_file_read(tmp_file_t *tmp, bam1_t *inbam);\n\n\n/*\n * Frees up memory, closes the file and deletes it.\n * Returns 0 on success or EOF on failure.\n */\nint tmp_file_destroy(tmp_file_t *tmp);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _TMP_SAM_FILE_H_ */\n"
        },
        {
          "name": "version.sh",
          "type": "blob",
          "size": 1.5009765625,
          "content": "#!/bin/sh\n# version.sh -- Script to build the htslib version string\n#\n#     Author : James Bonfield <jkb@sanger.ac.uk>\n#\n#     Copyright (C) 2017, 2019 Genome Research Ltd.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n# DEALINGS IN THE SOFTWARE.\n\n# Master version, for use in tarballs or non-git source copies\nVERSION=1.21\n\n# If we have a git clone, then check against the current tag\nif [ -e .git ]\nthen\n    # If we ever get to 10.x this will need to be more liberal\n    VERSION=`git describe --match '[0-9].[0-9]*' --dirty --always`\nfi\n\necho $VERSION\n"
        }
      ]
    }
  ]
}