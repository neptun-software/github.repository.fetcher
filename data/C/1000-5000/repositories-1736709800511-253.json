{
  "metadata": {
    "timestamp": 1736709800511,
    "page": 253,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "spdk/spdk",
      "stars": 3139,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".astylerc",
          "type": "blob",
          "size": 0.7509765625,
          "content": "# Bracket Style\nstyle=kr # K&R brackets\nj # Add braces to one-line conditional statements\nkeep-one-line-blocks # Don't break blocks that are on one line\n\n# Indentation\nindent=force-tab=8 # Use tabs for indentation, spaces for minor alignment\nmin-conditional-indent=0\n\n# Padding\nunpad-paren # Remove all spaces with parens that aren't requested below\npad-oper # Put spaces around operators\npad-header # Put spaces between if/while/for etc. and the first paren\n\n# Pointers\nalign-pointer=name # Align the * next to the variable name\n\n# Line wrapping\nmax-code-length=100 # 100 character line limit\nbreak-after-logical # For if statements, wrap to the next line after logical operator\n\n# Line endings\nlineend=linux # LF line endings\n\n# General options\nsuffix=none\nformatted\n"
        },
        {
          "name": ".githooks",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.48828125,
          "content": "*.~\n*.a\n*.cmd\n*.d\n*.dll\n*.exe\n*.gcda\n*.gcno\n*.kdev4\n*.ko\n*.lib\n*.log\n*.o\n*.obj\n*.pdb\n*.pyc\n*.so\n*.so.*\n*.swp\n*.DS_Store\nbuild/\nut_coverage/\ntags\ncscope.out\ndpdk-*\nCUnit-Memory-Dump.xml\ninclude/spdk/config.h\ninclude/spdk/version.h\nCONFIG.local\n*VC.db\n.vscode\n.project\n.cproject\n.settings\n.gitreview\nmk/cc.mk\nmk/config.mk\nmk/cc.flags.mk\nPYTHON_COMMAND\npython/spdk/version.py\ntest_completions.txt\ntiming.txt\ntest/common/build_config.sh\n.coredump_path\n.run_test_name\n.spdk-isal.log\n.spdk-isal-crypto.log\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.576171875,
          "content": "[submodule \"dpdk\"]\n\tpath = dpdk\n\turl = https://github.com/spdk/dpdk.git\n[submodule \"intel-ipsec-mb\"]\n\tpath = intel-ipsec-mb\n\turl = https://github.com/spdk/intel-ipsec-mb.git\n[submodule \"isa-l\"]\n\tpath = isa-l\n\turl = https://github.com/spdk/isa-l.git\n[submodule \"ocf\"]\n\tpath = ocf\n\turl = https://github.com/Open-CAS/ocf.git\n[submodule \"libvfio-user\"]\n\tpath = libvfio-user\n\turl = https://github.com/nutanix/libvfio-user.git\n[submodule \"xnvme\"]\n\tpath = xnvme\n\turl = https://github.com/xnvme/xnvme.git\n[submodule \"isa-l-crypto\"]\n\tpath = isa-l-crypto\n\turl = https://github.com/intel/isa-l_crypto\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 201.2822265625,
          "content": "# Changelog\n\n## v25.01: (Upcoming Release)\n\n### bdev_nvme\n\nAdded controller configuration consistency check, so all controllers created with the same name will\nbe forced to have consistent setting, either multipath or failover. No mixing of different '-x'\noptions will be allowed.\n\nChanged default mode: if no '-x' option is specified in bdev_nvme_attach_controller RPC call,\nthe multipath mode will be assigned as a default.\n\nChanged `spdk_bdev_nvme_create` API function, the `multipath` parameter was removed as it is redundant\nto `multipath` field in spdk_bdev_nvme_ctrlr_opts structure passed as a parameter to this function.\nIf multipathing shall be enabled for nvme bdev, `bdev_opts.multipath` shall be set to `true`. When\n`bdev_opts.multipath` is set to `false`, failover mode is enabled.\n\nAdded public APIs `spdk_bdev_nvme_get_opts` and `spdk_bdev_nvme_set_opts` to get default bdev nvme\noptions and set them respectively.\n\n### env\n\nAdded 3 APIs to handle multiple interrupts for PCI device `spdk_pci_device_enable_interrupts()`,\n`spdk_pci_device_disable_interrupts()`, and `spdk_pci_device_get_interrupt_efd_by_index()`.\n\n### nvme\n\nAdded `enable_interrupts` option to `spdk_nvme_ctrlr_opts`. If set to true then interrupts may be\nenabled during initialization. Make sure to check the resulting value after the attach step to\ncheck for success. This mode is currently only supported for PCIe transport. This is only\nsupported within a primary SPDK process, and if enabled SPDK will not support secondary processes.\n\nAdded APIs `spdk_nvme_qpair_get_fd()` and `spdk_nvme_ctrlr_get_admin_qp_fd()` to retrieve the file\ndescriptor for an I/O and the admin queue pair of a given NVMe controller respectively.\nThese APIs accept `spdk_event_handler_opts` structure, and if specified the transport layer will\nfill it out which can be used by the application to register interrupts on the queue pairs.\n\nAdded `opts_size` in `spdk_nvme_io_qpair_opts` structure to align it with other opts structures.\n\n`spdk_nvme_poll_group_create()` now creates a fd group to manage interrupt events.\n\nTwo new APIs have been added to manage interrupt events in poll group.\n\n`spdk_nvme_poll_group_get_fd()` retrieves the internal epoll file descriptor of the poll group.\n\n`spdk_nvme_poll_group_wait()` waits for interrupt events on all the I/O queue pair file descriptors\nin a poll group. When an interrupt event gets generated, it processes any outstanding completions\non the I/O queue pair with interrupts. These interrupt events are registered at the the time of I/O\nqueue pair creation.\n\n### nvmf\n\nAdded public API `spdk_nvmf_send_discovery_log_notice` to send discovery log page\nchange notice to client.\n\n### reduce\n\nAdd `spdk_reduce_vol_get_info()` to get the information for the compressed volume.\n\n### thread\n\nAdded `spdk_interrupt_register_ext()` API which can receive `spdk_event_handler_opts` structure.\nThis is to prevent any further expansion of `spdk_interrupt_register()` API.\n\n### util\n\nAdded `spdk_fd_group_add_ext()` API which can receive `spdk_event_handler_opts` structure. This is\nto prevent any further expansion of `spdk_fd_group_add()` API.\n\n## v24.09\n\n### accel\n\nAdded `spdk_accel_submit_compress_ext()` and `spdk_accel_submit_decompress_ext()` API.  They differ\nfrom the non-ext variants in that these functions allow users to specify a compression algorithm and\ncompression level.\n\nAdded `spdk_accel_get_compress_level_range()` to get the valid level range of a given compression\nalgorithm.\n\nAdded API to generate and verify DIX.\n\nAdded append version of `dif_verify`, `dif_verify_copy`, `dif_generate`, and `dif_generate_copy`.\n\nAdded support for lz4 compression.\n\n### bdev\n\n`spdk_bdev_io_get_aux_buf` and `spdk_bdev_io_put_aux_buf` are deprecated and\nwill be removed in the 25.01 release. We do not believe these are in use currently.\n\n### bdev_compress\n\nAdded support for specifying compression algorithm and level.\n\n### bdev_nvme\n\nIntroduced new header file /module/bdev/nvme.h and added public APIs `spdk_bdev_nvme_create`,\n`spdk_bdev_nvme_set_multipath_policy` and `spdk_bdev_nvme_get_default_ctrlr_opts`\nto get connectivity and multipathing capabilities of `bdev_nvme`.\n\nAdded `bdev_nvme_set_keys` RPC to change DH-HMAC-CHAP keys and force reauthentication of all qpairs\nof a controller.\n\n### dif\n\nEach element in `enum spdk_dif_pi_format` was subtracted by 1 to match the definition\nof the Protection Information Format in the NVMe specification. This is necessary change\nbut breaks ABI compatibility. Please recompile your application if you added code using\nthis enum of older SPDK.\n\n### dma\n\nAdded `spdk_memory_domain_transfer_data()` function to transfer data between two memory domains.\n\n### env\n\nAdded `spdk_env_core_get_smt_cpuset()` API to get the list of SMT sibling\ncores for a given core ID.\n\nAdded `spdk_pci_device_get_numa_id()`, `spdk_env_get_numa_id()`, and `SPDK_ENV_NUMA_ID_ANY` to\nreplace `socket_id` with `numa_id` when referring to a NUMA node.\n\nAdded `spdk_env_get_first_numa_id()`, `spdk_env_get_last_numa_id()`, `spdk_env_get_next_numa_id()`,\nand `SPDK_ENV_FOREACH_NUMA_ID()` API to iterate over available NUMA nodes in a system.\n\nAdded `enforce_numa` option to `spdk_env_opts`.  This option forces all hugepage memory\nallocations to allocate memory only from the specified NUMA node without trying to fallback to other\nNUMA nodes if it fails.\n\n### env_dpdk\n\n`spdk_get_tid` is added to get the tid of the current thread.\n\n### event\n\nThe `framework_get_reactors` RPC method supports getting pid and tid.\n\n### fsdev\n\nAdded the fsdev library providing a filesystem abstraction.\n\n### fuse_dispatcher\n\nAdded the `fuse_dispatcher` library that manages fsdevs and implements FUSE <-> fsdev API\ntranslation.\n\n### idxd\n\nAdded `spdk_idxd_submit_dix_generate()` function to generate DIX using DSA.\n\n### nvme\n\nAdded `spdk_nvme_ctrlr_set_keys()`, `spdk_nvme_ctrlr_authenticate()`, and\n`spdk_nvme_qpair_authenticate()` API to change the DH-HMAC-CHAP keys of a given controller and force\nreauthentication on its qpairs.\n\n### nvmf\n\nAdded support for interrupt mode in the NVMe-of TCP transport.\n\nEnable iobuf based queuing for nvmf requests when there is not enough free buffers available.\nPerspective from the user of the `spdk_nvmf_request_get_buffers()` API is that whenever all iovecs\nare allocated immediately then nothing changes compared to the previous implementation.\nIf iobuf does not have enough buffers then there are two flows now:\n\n- if `req_get_buffers_done` is not set in the `spdk_nvmf_transport_ops` then again, nothing\n  changes. All (if there were any) ioves are released and caller must try again later.\n- if callback was set then caller will be notified once all iovecs are allocated.\n\nAs requests waiting for the buffer might get aborted, another API to remove such request from\nthe iobuf queue is also added.\n\nAdded public API `spdk_nvmf_subsystem_set_cntlid_range()` to set controller ID range for a\nsubsystem.\n\nAdded `nvmf_subsystem_set_keys` RPC to change DH-HMAC-CHAP keys for a given subsystem/host pair\nwithout having to remove and readd a host.\n\nAdded `spdk_nvmf_subsystem_set_ns_ana_group()` function to change ANA group ID of an active\nnamespace of a subsystem.\n\n### scheduler\n\nAdded `framework_get_governor` RPC to retrieve the power governor name,\npower env and the frequencies available, frequency set to the cpu cores.\n\n### sock\n\nNew functions that allows to register interrupt for given socket group:\n`spdk_sock_group_register_interrupt()` and `spdk_sock_group_unregister_interrupt()`. Both uses API\nexposed by the thread.h, see below for details.  Support implemented only for the POSIX and SSL\nsockets.\n\n### thread\n\nNew function `spdk_interrupt_register_for_events()` build on top of `spdk_fd_group_add_for_events()`.\nSee below for details.\n\n### util\n\nNew function `spdk_fd_group_add_for_events()` was added alongside the existing `spdk_fd_group_add()`.\nDifference is that new API allows for specifying a set of events to be monitored instead of default\n`SPDK_INTERRUPT_EVENT_IN`.\n\nAdded API to calculate md5 hash.\n\n## v24.05\n\n### accel\n\n`spdk_accel_get/set_opts()` has changed to act more like spdk_bdev's variant.\n\n### bdev\n\nAdded `spdk_bdev_get_nvme_ctratt()` API to get controller attributes of bdev.\n\n### bdev_raid\n\nAdded support for interleaved metadata.\n\nAdded RAID1 I/O error handling.\n\nExamining a bdev with RAID superblock now searches for other base bdevs that may be present.\n\nRe-adding a removed base bdev with superblock will now begin rebuild on applicable RAID levels.\n\nBase bdevs can now be added back if were removed while in configuring state.\n\nRAID in configuring state will not be removed if the last base bdev is removed.\n\n### bdev_uring\n\nAdded `bdev_uring_rescan` RPC to allow rescaning the size of uring bdev.\n\n### blobstore\n\nAdded new API `spdk_bs_blob_shallow_copy()` to make a shallow copy from a blob to a blobstore device. Only clusters\nallocated to the blob will be written on the device.\n\nAdded new APIs `spdk_bs_blob_set_parent()` and `spdk_bs_blob_set_external_parent()` to change the parent of an\nexisting lvol. With these new API a thin provisioned blob can become a clone of an existing snapshot\nor of an existing external snapshot.\n\n### event\n\nSPDK applications can now start with `--wait-for-rpc` and JSON configuration provided at the same time.\n\nStruct `spdk_app_opts` was extended by `json_data` and `json_data_size` fields\nallowing user to provide a buffer with JSON config as alternative to providing JSON config file path\n(these fields are mutually exclusive).\n\n### init\n\nFunction `spdk_subsystem_init_from_json_config()` is deprecated and will be removed in 24.09 release.\nPlease use `spdk_subsystem_load_config()` instead.\n\n### iscsi\n\nAdded `iscsi_get_stats` RPC method to get stat information about all active connections.\n\nAdded `iscsi_enable_histogram` RPC method to enable or disable histogram for specified iSCSI target.\n\nAdded `iscsi_get_histogram` RPC method to get histogram for specified iSCSI target.\n\n### keyring\n\nAdded keyring library.  Its purpose is to provide secure access to cryptographic keys from other\nlibraries.  Prior to being used, keys need to be attached to the keyring using one of the modules,\nwhich are responsible for retrieving keying material in a secure manner.  Currently, there are two\nkeyring modules implemented: `keyring_file` (keys are stored in files on a filesystem) and\n`keyring_linux` (based on Linux kernel keyring).  The module interface is pluggable, so users can\nimplement their own keyring modules.\n\n### lvol\n\nAdded `bdev_lvol_start_shallow_copy` RPC to start a shallow copy of an lvol over a given bdev and\n`bdev_lvol_check_shallow_copy` RPC to get the status of the operation.\nThese RPCs use the new API `spdk_lvol_shallow_copy()`.\n\nAdded `bdev_lvol_set_parent` and `bdev_lvol_set_parent_bdev` RPC to change the parent of an existing lvol\nwith the use of the new APIs `spdk_lvol_set_parent()` and `spdk_lvol_set_external_parent()`.\n\n### nvme\n\nAdded `spdk_nvme_ctrlr_get_max_sges()` API to retrieve maximum number of SGEs per request\nfor the given NVMe controller.\n\nThe NVMe driver now supports in-band authentication using the DH-HMAC-CHAP protocol.  To enable it,\nusers need to specify keys in the `bdev_nvme_attach_controller` RPC.  Additionally, it's possible to\nlimit the allowed digests and Diffie-Hellman groups via `bdev_nvme_set_options`.\n\n### nvmf\n\nAdded support for namespace masking using new C APIs `spdk_nvmf_ns_add_host()` and\n`spdk_nvmf_ns_remove_host()` and RPCs `nvmf_ns_add_host` and `nvmf_ns_remove_host`.\nUsers must pass new `--no-auto-visible` parameter to `nvmf_subsystem_add_ns` RPC to allow\nnamespace masking to be controlled by these new RPCs.\n\nAdded `spdk_nvmf_subsystem_get_ana_state()` API to get current ANA state of\na particular ANA group ID.\n\nAdded support for enabling mDNS-based discovery of nvmf target for\nTCP transport with the addition of `nvmf_publish_mdns_prr` and\n`nvmf_stop_mdns_prr` RPCs.\n\nThe NVMe-oF target now supports in-band authentication using the DH-HMAC-CHAP protocol.  The target\nwill request hosts to authenticate if they're configured to use DH-HMAC-CHAP keys.  The keys can be\nset in the `nvmf_subsystem_add_host` RPC.  Additionally, it's possible to limit the allowed digests\nand Diffie-Hellman groups via `nvmf_set_config`.\n\n### spdk_trace\n\n`spdk_trace` has learned how to use the most recent trace file in /dev/shm when\nthe user has specified neither `-f` nor `-s` options. This is only available on\nLinux since FreeBSD does not mount have a /dev/shm mount.\n\n### thread\n\nChanged `spdk_iobuf_get/set_opts()` API to act more like spdk_bdev's variant.\n\n### trace\n\nMerged `struct spdk_trace_flags` and `struct spdk_trace_histories` into\nnew `struct spdk_trace_file`. Also renamed `spdk_get_trace_histories_size()`\nto `spdk_get_trace_file_size()`.\n\n## v24.01\n\n### accel\n\nAdded support for new operations for computing Data Integrity Field (DIF),\n`spdk_accel_submit_dif_verify()`, `spdk_accel_submit_dif_generate()` and\n`spdk_accel_submit_dif_generate_copy()`.\n\nAdded `spdk_accel_get_opcode_name()` API that returns name of an operation.\n\nAdded `spdk_accel_get_module()` API that returns pointer to a module.\n\nAdded optional `init()` and `fini()` callbacks to `spdk_accel_driver` in order to allow\ndrivers to initialize and clean up resources by the driver.\n\n### accel_error\n\nAdded new `error` accel module that allows user to inject error to selected accel operations.\n\n### bdev\n\nAdded `spdk_bdev_nvme_iov_passthru_md()` API to allow sending larger passthru commands.\n\nAdded `max_rw_size` field to `spdk_bdev` structure allowing bdev modules to specify maximum\nsize of an I/O.\n\nAdded `iobuf_small_cache_size` and `iobuf_large_cache_size` parameters to\n`bdev_set_options` RPC making iobuf use in bdev configurable.\n\n### bdev_raid\n\nAdded support for rebuild in raid1 and raid5f levels.\n\nAdded `superblock` argument to `bdev_raid_create` RPC to allow writing out raid metadata to\na superblock. It can be then re-created from examined base bdevs, without the need\nto issue `bdev_raid_create`.\n\nAdded `bdev_raid_add_base_bdev` RPC to add a base bdevs to an existing raid bdev.\n\nAdded `bdev_raid_set_options` RPC that changes options for raid bdev module,\ncurrently allows setting `process_window_size_kb` affecting background operations\nlike rebuild.\n\n### blobstore\n\nAdded `spdk_bs_grow_live()` and `spdk_bdev_update_bs_blockcnt()` API that can be used to\nincrease size of blobstore filling the underlying device without first closing the blobstore.\n\n### env\n\nAdded SPDK command line parameter `--no-huge`, which enables SPDK to run without hugepages.\n\n### event\n\nAdded SPDK command line parameter `--interrupt-mode`, which enables to run SPDK in interrupt\nmode. Effective only if all components used in the application, support interrupt mode.\n\n### ftl\n\nAdded `rpc_bdev_ftl_get_properties` and `bdev_ftl_set_property` RPC with matching API calls,\nto allow modification of FTL device properties.\n\n### idxd\n\nAdded `spdk_idxd_submit_dif_check()` and `spdk_idxd_submit_dif_insert()` API to support\nnew operations for computing Data Integrity Field (DIF).\n\n### json\n\nAdded `spdk_json_write_uuid()`, `spdk_json_write_named_uuid()` and `spdk_json_decode_uuid()`\nto help with writing and decoding UUID.\n\n### nvme\n\nA new transport option `rdma_max_cq_size` was added to limit indefinite growth of CQ size.\n\nAdded `spdk_nvme_ctrlr_cmd_iov_raw_with_md()` API to allow sending larger passthru commands.\n\n### nvmf\n\nAdded `max_discard_size_kib` and `max_write_zeroes_size_kib` to `nvmf_create_subsystem` RPC to set the\nmaximum discard size and maximum write zeroes size.\n\nAdded new optional `--ana-state` (or shortly `-n`) parameter to `nvmf_subsystem_add_listener` RPC.\n\nAdded public APIs `spdk_nvmf_subsystem_get_ana_reporting()` and `spdk_nvmf_subsystem_set_ana_state()`,\nreplacing the internal functions `nvmf_subsystem_get_ana_reporting()` and `nvmf_subsystem_set_ana_state()`\nrespectively.\n\nAdded support for NVMe-oF referrals in NVMe-oF target with addition of\n`spdk_nvmf_tgt_add_referral()` and `spdk_nvmf_tgt_remove_referral()` API and `nvmf_discovery_add_referral`,\n`nvmf_discovery_remove_referral` and `nvmf_discovery_get_referrals` RPC.\n\nAdded `spdk_nvmf_set_custom_ns_reservation_ops()` API allowing to register custom handlers for reservation\noperations.\n\n### scsi\n\nAdded support for `SPDK_SBC_WRITE_SAME_10` and `SPDK_SBC_WRITE_SAME_16`.\n\n### thread\n\nAdded `iobuf_get_stats` RPC and `spdk_iobuf_get_stats()` API to track iobuf use across components.\n\n### trace\n\nAdded `spdk_trace_register_user_thread()` to initialize trace environment and\n`spdk_trace_unregister_user_thread()` to de-initialize trace environment\nfor a user created thread.\n\nModified `spdk_trace_init()` to take number of user created threads as a parameter.\n\n### ublk\n\nAdded `ublk_recover_disk` RPC to support recovering after restarting ublk target.\n\n### vhost\n\nAdded `caw_iov` field to struct `spdk_scsi_task` to support SBC-3 compare_and_write IO.\n\nAdded parameter `delay` to `vhost_create_scsi_controller` RPC which allows user to defer starting\nthe vhost-scsi controller until adding the scsi target is completed.\n\nAdded `vhost_start_scsi_controller` RPC to start vhost-scsi controller, it could be used to support\nlive recovery feature of vhost-scsi target.\n\n### rpc\n\nFunctions `spdk_rpc_listen`, `spdk_rpc_accept` and `spdk_rpc_close` are deprecated and will be\nremoved in 24.09 release. Please use `spdk_rpc_server_listen`, `spdk_rpc_server_accept` and\n`spdk_rpc_server_close` instead.\n\n## v23.09\n\n### accel\n\nAdded `spdk_accel_get_buf_align()` API to get minimum buffer alignment to execute a given operation.\n\nAdded `get_operation_info()` callback for accel_modules to return constraints for a given operation.\n\n### bdev\n\nAdded `spdk_bdev_open_async()` API to allow asynchronous bdev open that waits for specified time\nuntil the block device appears.\n\n### bdev_nvme\n\nAdded `bdev_nvme_enable_controller` and `bdev_nvme_disable_controller` RPC to enable and disable\nNVMe controller. For NVMe multipath `cntlid` is used to select only one NVMe-oF controller.\n\nAdded `cntlid` field to `bdev_nvme_reset_controller` RPC to support resetting only one NVMe-oF\ncontroller in multipath configuration.\n\n### bdev_raid\n\nAdded `bdev_raid_remove_base_bdev` RPC to remove a base bdev from existing raid bdev.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 23.07.\n\n### env\n\nThe `phys_addr` parameter in `spdk_*_malloc()` functions is now invalid. Passing non-NULL value\nwill return NULL from the functions. The parameter was deprecated in SPDK 19.04.\nFor retrieving physical addresses, `spdk_vtophys()` should be used instead.\n\n### go\n\nAdded JSON-RPC 2.0 client written in Go to ease communication with SPDK.\nPlease see the documentation at `go/rpc/` and example at `examples/go/`.\n\n### init\n\nOptions for the JSON-RPC server initialization were added. The options are defined via the\n`spdk_rpc_opts` structure and is passed to the existing API `spdk_rpc_initialize()` as a new\nargument. The options include `log_file` and `log_level`.\n\n### intel-ipsec-mb\n\nUpdated intel-ipsec-mb submodule to v1.4.\n\n### jsonrpc\n\nNew APIs, `spdk_jsonrpc_set_log_level` and `spdk_jsonrpc_set_log_file`, were added to enable\nlogging JSON RPC calls history.\n\n### log\n\nNew APIs, `spdk_flog` and `spdk_vflog`, were added to write messages to the specified log file.\n\n### nvme\n\nThe `spdk_nvme_accel_fn_table` interface has been extended with callbacks allowing users to chain\nmultiple accel operations.  Users can now send requests with an existing accel sequence by setting\nthe `accel_sequence` field in `spdk_nvme_ns_cmd_ext_io_opts` if the controller supports it (i.e.\nsets the `SPDK_NVME_CTRLR_ACCEL_SEQUENCE_SUPPORTED` flag) and the user implements the necessary\n`spdk_nvme_accel_fn_table` callbacks.\n\nThe NVMe bdev will now advertise support for accel sequences if the `allow_accel_sequence` flag is\nset in `bdev_nvme_set_options` and the underlying controller also supports them.\n\nThe TCP transport will now calculate data digest using the accel sequence APIs if they're available.\n\nAdded `spdk_nvme_qpair_is_connected()` API to check the connection status.\n\n### nvmf\n\nThe `spdk_nvmf_request::data` field has been removed: instead, clients should set\n`->iov` and `->iovcnt` appropriately, as nvmf request APIs now expect any data\nbuffers to be described there. `spdk_nvmf_request_get_data()` has been removed.\n\n`transport` field in `listen_addresses` of `nvmf_get_subsystems` RPC is deprecated.\n`trtype` field should be used instead. `transport` field will be removed in 24.01 release.\n\nAdded `spdk_nvmf_subsystem_add_listener_ext()` API for accepting new connections on the provided\naddress, now allowing to specify additional options for the listener.\n\nDeprecated `spdk_nvmf_subsystem_any_listener_allowed()` API (to be removed in 24.01) and replaced with\nspdk_nvmf_subsystem_any_listener_allowed()` API fixing the typo.\n\nAdded `spdk_nvmf_subsystem_is_discovery()` API to check whether a given susbystem is discovery subsystem.\n\n### scripts\n\n`setup.sh` now supports interactive mode for device selection and hugepage reservation.\n\nAdded `backport.sh` script that formalizes process of backporting commits from latest SPDK,\nto specific release branches. Please see [documentation](https://spdk.io/doc/backporting.html).\n\n### thread\n\nAdded `spdk_thread_is_app_thread()` API to check if specified spdk_thread is the app thread.\n\n### util\n\nExtended DIF support to CRC-32 and CRC-64 format of the Protection Information.\n\nAdded `spdk_crc64_nvme()` and `spdk_crc32c_nvme()`, CRC-64 and CRC-32C checksums compatible with\nNVMe Protection Information.\n\n## v23.05\n\n### accel\n\nAdded API `spdk_accel_submit_xor` to perform XOR.\n\nConfiguration of `mlx5_pci` driver of `accel_dpdk_cryptodev` module was changed. Now key and key2\nshould have equal length and key size in hexlified form can be either 32 bytes for 128b XTS key or\n64 bytes for 256b XTS key.  Support of the wrapped crypto credentials mode for this driver is\ndropped, only plain text mode is supported.\n\nThe accel library will now collect statistics on the number of executed operations and processed\nbytes.  These statistics can be retrieved using the `accel_get_stats` RPC.\n\nAdded support for appending a crc32 calculation to an accel sequence.\n\n### bdev\n\nA new API `spdk_bdev_module_claim_bdev_desc` was added. Unlike `spdk_bdev_module_claim_bdev`, this\nfunction requires a bdev descriptor to be passed and the claim is automatically released when the\ndescriptor is closed. It allows bdev modules to claim bdevs as a single writer, multiple writers, or\nmultiple readers.\n\nNew APIs `spdk_bdev_quiesce`, `spdk_bdev_unquiesce`, `spdk_bdev_quiesce_range` and\n`spdk_bdev_unquiesce_range` were added. These allow I/O to be quiesced on an entire bdev or\na specified LBA range.\n\nRemoved `spdk_bdev_ext_io_opts` from `spdk_bdev_io` and replaced it with fields that were missing in\n`spdk_bdev_io`.\n\nIt is now possible to submit an I/O with an associated accel sequence.  All operations in such\nsequence will be executed prior to sending the I/O (writes) or after its completion (reads).\n\n### env\n\nNew functions `spdk_env_get_main_core` and `spdk_env_get_cpuset` were added.\n\nIt is now possible to run applications on cores with IDs greater than 128 by passing a core map\nusing the `--lcores` parameter.\n\n### examples\n\n`examples/nvme/perf` application now accepts `--use-every-core` parameter that changes\nthe existing worker and namespace association logic to access every namespace from each worker.\nThis replicates behavior of bdevperf application when `-C` option is provided.\n\n### gpt\n\nGPT bdevs now use the GPT Unique Partition ID as the bdev's UUID.\n\n### idxd\n\nRemoved the `SPDK_IDXD_FLAG_PERSISTENT` flag.\n\n### lvol\n\nNew API `spdk_lvol_iter_immediate_clones` was added to iterate the clones of an lvol.\n\nNew APIs `spdk_lvol_get_by_uuid` and `spdk_lvol_get_by_names` to get lvols by the lvol's UUID or\nlvstore and lvol names.\n\nNew `bdev_lvol_get_lvols` RPC to list logical volumes. This provides information about logical\nvolumes without providing information about the bdevs. It is useful for listing the lvols\nassociated with specific lvol stores and for listing lvols that are degraded and have no\nassociated bdev.\n\nAdded support for external snapshots making it possible to create clones of any (including non-lvol)\nbdev.  Users can create such clones using the `bdev_lvol_clone_bdev` RPC.\n\n### nvme\n\nNew API `spdk_nvme_ns_get_format_index` was added to calculate the exact format index, that\nwas used to format the namespace.\n\nAdded two new APIs `spdk_nvme_ns_cmd_io_mgmt_recv` and `spdk_nvme_ns_cmd_io_mgmt_send` to\nreceive and send the I/O management commands.\n\n### nvmf\n\nNew `spdk_nvmf_request_copy_to/from_buf()` APIs have been added, which support\niovecs, unlike the deprecated `spdk_nvmf_request_get_data()`.\n\nTwo functions related to Asynchronous Event and error handling have been made public:\n\n- `spdk_nvmf_ctrlr_async_event_error_event`,\n- `spdk_nvmf_ctrlr_abort_aer`.\n\nNew `spdk_nvmf_transport_create_async` was added, it accepts a callback and callback argument.\n`spdk_nvmf_transport_create` is marked deprecated.\n\nParameters `cb_fn` and `ctx` of `spdk_nvmf_qpair_disconnect` API are deprecated. These parameters\nwill be removed in 23.09 release.\n\nAdded a `secure_channel` parameter to the `nvmf_subsystem_add_listener` RPC. When true, all\nconnections established via this listener will immediately attempt to establish a secure channel,\nprior to any authentication. Only valid for the TCP transport.\n\nAdded two optional transport module callbacks: `subsystem_add_host()` and `subsystem_remove_host()`.\nThese functions will notify a transport about adding/removing hosts' access.\n\nTLS PSK identity is now generated from subsystem NQN and host NQN.  PSK interchange format is now\nexpected as input, when configuring TLS in SPDK.  TLS feature is considered experimental.\n\n### part\n\nNew API `spdk_bdev_part_construct_ext` is added and allows the bdev's UUID to be specified.\n\n### sock\n\nAdded a zero copy receive interface allowing users to provide buffers to a socket group (via\n`spdk_sock_group_provide_buf()`), which will then get filled with the next portions of the stream on\neach socket.  After that, pointer to the buffer holding the next part of the data can be obtained\nusing `spdk_sock_recv_next()`.\n\nAdded a callback `get_key()` to `spdk_sock_impl_opts` structure.\n\nNew function `spdk_sock_get_impl_name()` was added to retrieve current socket implementation name.\n\n### thread\n\nAdded two new APIs `spdk_thread_bind` and `spdk_thread_is_bound` to bind or unbind `spdk_thread`\nto its current CPU core, and check bound status.\n\n### ublk\n\nEnabled support for `UBLK_F_NEED_GET_DATA`.  The buffers are no longer pre-allocated during\ninitialization, but are allocated on-demand.  Additionally, they're now allocated from the `iobuf`\nbuffer pools.\n\n### util\n\nNew APIs `spdk_uuid_is_null` and `spdk_uuid_set_null` were added to compare and\nset UUID to NULL value.\n\nAdded new functions, `spdk_fd_group_{nest,unnest}`, providing efficient way of adding one\n`fd_group`'s file descriptors to another `fd_group`.\n\n## v23.01\n\n### accel\n\nNew library isa-l-crypto has been added, it is used by accel library in crypto operations.\n\nNew functions `spdk_accel_submit_encrypt` and `spdk_accel_submit_decrypt` were added.\n\nNew accel module `dpdk_cryptodev` has been added. It uses DPDK crypto PMD and support encrypt and\ndecrypt operations. New RPC `dpdk_cryptodev_scan_accel_module` has been added to enable this accel module.\n\nNew accel module `mlx5` was added. It implements crypto operations, enabled when SPDK is configured with\nRDMA provider is mlx5_dv and crypto support.\n\nIntroduced the concept of chaining multiple accel operations together and executing them all in a\nsingle call.  The operation can be chained via one of the `spdk_accel_append_*` functions and then\nexecuted using `spdk_accel_sequence_finish`.  Currently, copy, decompress, decrypt, encrypt, and\nfill operations support this mode.  This feature is considered experimental.\n\n### bdev\n\nA new API `spkd_bdev_part_submit_request_ext` was added to specify a custom completion callback.\n\nNew APIs `spdk_bdev_for_each_channel` and `spdk_bdev_for_each_channel_continue` and\nassociated function pointers were added to iterate each channel of the required bdev.\n\nThe RPC `bdev_get_iostat` now allows a user to query the per channel IO statistics for\nrequired bdev, and displays maximum and minimum latencies and I/O error counts.\n\nNew `spdk_bdev_copy_blocks` and `spdk_bdev_get_max_copy` APIs to support copy commands.\n\nA new API `spdk_bdev_io_get_submit_tsc` was added to get the submit_tsc of the bdev I/O.\n\nBdevs will no longer have UUIDs generated based on timestamp and are responsible for\nsetting this field themselves. Generation of UUIDs for NVMe bdevs may be enabled by\nrunning `bdev_nvme_set_options` RPC with `--generate-uuids` option. These identifiers\nare based on serial number and namespace ID and will always be the same for a given\ndevice.\n\nA new API `spdk_bdev_channel_get_histogram` was added to get the histogram of a specified\nchannel for a bdev.\n\nConverted internal use of `pthread_mutex_t` to `struct spdk_spinlock`. Consumers of bdev\nAPI functions must be on an SPDK thread or the program will abort. It is now enforced\nthat no internal bdev locks can be held when a poller or message goes off CPU.\n\nA new RPC `bdev_reset_iostat` was added to reset I/O statistics of bdevs. Note that if one\nconsumer reset I/O statistics, it affects all other consumers.\n\nAdd function pointers, `dump_device_stat_json` and `reset_device_stat` to the bdev module\nfunction table to display and reset I/O statistics specific for the module specific bdev\ncontext.\n\nNew APIs `spdk_bdev_reset_io_stat`, `spdk_bdev_add_io_stat` and `spdk_bdev_dump_io_stat_json`\nwere added to process I/O statistics outside the generic bdev layer, especially in bdev modules.\n\n### bdev_crypto\n\nvbdev_crypto is updated to use accel framework instead of DPDK PMDs.\n\n### bdev_daos\n\nNew RPC `bdev_daos_resize` was added to allow resizing the daos bdev.\n\n### bdev_malloc\n\nBoth of interleaved and separated metadata are now supported by the malloc bdev module.\n\nProtection information is now supported by the malloc bdev module.\n\n### bdev_nvme\n\nUpdated `bdev_nvme_set_options` RPC (and rpc.py) to support the new `transport_tos` parameter.\n\nFor the active-active policy of the multipath mode, in addition to the default round-robin path\nselector, the minimum queue depth path selector was added. The minimum queue depth path selector\nselects an I/O path according to the number of outstanding requests of each nvme qpair.\n\nAdded RPCs `bdev_nvme_start_mdns_discovery`, `bdev_nvme_get_mdns_discovery_info` and\n`bdev_nvme_stop_mdns_discovery` to perform Avahi based mDNS discovery service,\nas per NVMe TP 8009 - Automated Discovery of Ethernet Discovery Controllers.\n\nA new option `nvme_error_stat` was added to the `bdev_nvme_set_options` RPC to enable\ncollecting NVMe error counts.\n\nAdded I/O statistics per I/O path to the NVMe bdev module for NVMe bdev multipath. It can be\nenabled by a new option `io_path_stat` of RPC `bdev_nvme_set_options`.\n\nAdded RPC `bdev_nvme_get_path_iostat` to get I/O statistics for IO paths of the NVMe bdev.\n\nAdded `selector` parameter to `bdev_nvme_set_multipath_policy` RPC to set path selector for multipath.\nOption `round_robin` and `queue_depth` are available.\n\nAdded `rr_min_io` option to RPC `bdev_nvme_set_multipath_policy`. It switches I/O to\nanother path after rr_min_io I/Os are routed to current io path for the round-robin\npath selector.\n\nAdded option `--io-path-stat` for RPC `bdev_nvme_set_option` to enable collecting io path stat.\n\n### bdev_raid\n\nChanged `bdev_raid_get_bdevs` RPC output format to include raid_bdev details.\n\n### bdevperf\n\nPromoted the application to example to match similar programs: fio_plugin and perf.\nIt can now be found inside `examples/bdev/bdevperf`.\n\n### env\n\nAdded `spdk_mempool_mem_iter` that allows to get start address and length of each memory\nchunk in order to create app-specific resources.\n\n### event\n\nAdded core lock file mechanism to prevent the same CPU cores from being used by multiple\nSPDK application instances.\n\nAdded `--disable-cpumask-locks` command line switch to disable CPU locks on SPDK startup.\n\nAdded RPCs `framework_enable_cpumask_locks` and `framework_disable_cpumask_locks` to enable\nand disable CPU core locks in runtime.\n\nAdded `--rpcs-allowed` command line option. Users can specify a comma-separated list of RPC\nnames with this option to restrict allowed RPCs to only that list.\n\nAdded `--vfio-vf-token` command line option to specify a VF token (UUID)\nshared between SR-IOV PF and VFs for vfio_pci driver.\n\nThe `spdk_iov_xfer_*()` APIs were added for handling incremental copying between\nan iovec and a buffer.\n\n### json\n\nAdded API `spdk_json_write_double` and `spdk_json_write_named_double` to allow\nfor writing and decoding of the the double data type.\n\n### log\n\nAdded consistent tracking of use of deprecated behavior. Deprecations continue to be\nlisted in deprecation.md and now are in subsections with headers matching a tag\nused in `SPDK_LOG_DEPRECATED()` calls. When deprecated behavior is used, these\ntags will appear in SPDK's log at the warn level. As the SPDK application exits, it\nwill log a summary of how many times `SPDK_LOG_DEPRECATED()` was called for each\ntag that was logged at least once.\n\n### nvme\n\nNVMe transport options were newly introduced. The NVMe transport options are defined via\nthe `spdk_nvme_transport_opts` structure and configured via `spdk_nvme_transport_get_opts`\nand `spdk_nvme_transport_get_opts` functions.\n\nShared receive queue was supported by the RDMA transport. It can be configured by\na new NVMe transport option `rdma_srq_size`.\n\nAdded `transport_tos` to `spdk_nvme_ctrlr_opts` to support setting of the \"type of service\"\nvalue in the IPv4 header. Only RDMA is supported at this time.\n\nAdded API `spdk_nvme_qpair_get_num_outstanding_reqs` to get the number of outstanding reqs of\na specified qpair.\n\n### nvmf\n\nAdded API `spdk_nvmf_tgt_pause_polling` and `spdk_nvmf_tgt_resume_polling` to allow\npausing polling on poll group of a given target.\n\nThe `num_shared_buffers` option now controls the maximum number of buffers a transport will\npull from the central `iobuf` pool. It will not allocate additional memory. If the requested\namount cannot be satisfied, a warning will be displayed to increase the size of the `iobuf`\npool.\n\n### rpc\n\nAdded `spdk_rpc_set_allowlist` to restrict allowed RPCs to the specified list.\n\n### scheduler\n\nChanging scheduler from dynamic back to static is no longer possible,\nas there is no way of saving original SPDK thread distribution on reactors.\n\n### thread\n\nAdded `spdk_thread_get_app_thread` which returns the first thread that was created using\n`spdk_thread_create`.\n\nAdded `spdk_thread_is_running`.  This returns `true` for a running thread, or `false` if\nits exit process has started using `spdk_thread_exit`.\n\nAdded API `spdk_spin_init`, `spdk_spin_destroy`, `spdk_spin_lock`, `spdk_spin_unlock`, and\n`spdk_spin_held` to support spinlocks that are aware of the SPDK concurrency model.\n\nAdded iobuf buffer pool, set of API calls for allocating data buffers across libraries.\nPlease see new API `spdk_iobuf_*`.\n\n### trace\n\nNew `trace_get_info` RPC was added to get name of shared memory file, list of the\navailable trace point groups and mask of the available trace points for each group.\n\n### ublk device\n\nThe ublk application supports the ublk kernel driver. It's implemented as a ublk backend\nin spdk_tgt and could be started with specifying configuration. See the\n[ublk](https://www.kernel.org/doc/html/latest/block/ublk.html) documentation for more details.\n\nublk bdev could export a block device via Linux ublk. It will move this backend device into userspace\nas `/dev/ublkb*`. Before to adding ublk device, need to create ublk target by RPC method.\n\n### util\n\nNew API `spdk_fd_group_get_epoll_event` that returns the epoll(7) event that\ncaused a function callback in file descriptor group to execute.\n\nAdded API `spdk_strarray_from_string`, `spdk_strarray_dup` and `spdk_strarray_free`\nfor handling arrays of strings.\n\nA new API `spdk_strcpy_replace` was added to replace all occurrences of the search string\nwith the replacement string.\n\nNew API `spdk_iov_memset()` was added to memset an iovec.\n\nNew API `spdk_iov_one()` was added to initialize an iovec for a single buffer.\n\n## v22.09\n\n### accel\n\nMany names were changed in the accel framework to make them consistent both with themselves and\nthe rest of SPDK. The primary public header file is now named `include/spdk/accel.h`.\n\nAdded a new runtime RPC `accel_get_opc_assignments` to get a list of current opcode to engine\nassignments.\n\nAdded a new startup RPC `accel_assign_opc` to assign/override a specific opcode to\nan engine.\n\n### bdev\n\nNew RPCs `bdev_xnvme_create` and `bdev_xnvme_delete` were added to support the xNVMe bdev.\n\nA new API `spdk_bdev_for_each_bdev_io` was added to execute the function on the appropriate\nthread for each bdev_io submitted to the bdev.\n\nA new API `spdk_bdev_get_current_qd` was added to measure and return the queue depth from a\nbdev. This API is available even when queue depth sampling is disabled.\n\nAdded `spdk_bdev_seek_data`, `spdk_bdev_seek_hole` and `spdk_bdev_io_get_seek_offset` functions\nthat start from a given offset and seek for next data or for next hole. At this time only\nsupported by lvol bdev module.\n\nA new parameter `io_drain_timeout` has been added to `spdk_bdev` structure. It controls how long\na bdev reset must wait for IO to complete prior to issuing a reset to the underlying device.\nIf there is no outstanding IO at the end of that period, the reset is skipped.\nBest defined for bdevs that share an underlying bdev, such as multiple lvol bdevs sharing\nan nvme device, to avoid unnecessarily resetting the underlying bdev and affecting other\nbdevs that are sharing it.\nModifying this field is optional. Setting the value to 0 keeps the original behavior\nto always send resets immediately, even if there is no I/O outstanding.\n\n### blobstore\n\nReserve space for `used_clusters` bitmap. The reserved space could be used for blobstore growing\nin the future.\n\nAdded `is_zeroes` operation to `spdk_bs_dev`. It allows to detect if logical blocks are backed\nby zeroes device and do a shortcut in copy-on-write flow by excluding copy part from zeroes device.\n\nAdded `spdk_blob_get_next_allocated_io_unit` and `spdk_blob_get_next_unallocated_io_unit` functions\nthat start from a given offset and seek for first io_unit belonging to an allocated cluster\nor first io_unit belonging to an unallocated cluster.\n\nAdded `spdk_bs_grow` function to grow blobstore size if the underlying bdev size is increased.\nThis is used by lvol bdev via `bdev_lvol_grow_lvstore` RPC.\n\n### daos\n\nAdded new DAOS bdev module, that creates SPDK block device on top of DAOS DFS.\nPlease see [documentation](https://spdk.io/doc/bdev.html#bdev_config_daos) for more details.\n\n### env\n\nAdded `spdk_pci_register_device_provider` and matching `SPDK_PCI_REGISTER_DEVICE_PROVIDER`\nfunctions for registering PCI device providers. That allow the VMD driver to be notified\nwhen users want to attach a device under a given BDF and when a device is detached.\n\n### init\n\n`spdk_subsystem_init_from_json_config` now fails if the JSON configuration file is not\nan object with an array named \"subsystems\".\n\n### iscsi\n\nAdded `bdev_iscsi_set_options` RPC to modify options of the iSCSI bdev module.\n\n### json\n\nAdded `spdk_json_find` API return errcode: EPROTOTYPE - json not enclosed in {}.\n`spdk_json_find` now returns -EPROTOTYPE instead of -ENOENT if the object parameter\ndoes not point to a JSON object (i.e. is not enclosed with {}).\n\n### lvol\n\nAdd `num_md_pages_per_cluster_ratio` parameter to the `bdev_lvol_create_lvstore` RPC.\nCalculate `num_md_pages` from `num_md_pages_per_cluster_ratio`, and pass it to `spdk_bs_opts`.\n\n### nvme\n\nAdded SPDK_NVME_TRANSPORT_CUSTOM_FABRICS to enum `spdk_nvme_transport_type` to support custom\nfabric transport. SPDK_NVME_TRANSPORT_CUSTOM was intended to be non-fabric custom transport.\n\nAdded a new function `spdk_nvme_ns_cmd_verify` to submit a Verify Command to a Namespace.\n\nAdded `spdk_nvme_ctrlr_disable_read_changed_ns_list_log_page` to allow an application to\ntell the driver to not read the CHANGED_NS_LIST log page in response to a NS_ATTR_CHANGED\nAEN.  When called the application is required to read this log page instead to clear the\nAEN.\n\nAdded `psk` field to `spdk_nvme_ctrlr_opts` struct in order to enable SSL socket implementation\nof TCP connection and set the PSK. Applicable for TCP transport only.\n\n### raid\n\nRenamed the `raid5` module to `raid5f` to reflect that it is not a traditional\nRAID5 implementation - only full stripe writes are supported, partial stripe\nwrites (read-modify-write) are not.\n\n### rpc\n\nAdded `psk` parameter to `bdev_nvme_attach_controller` RPC in order to enable SSL socket implementation\nof TCP connection and set the PSK. Applicable for TCP transport only.\n\nNew options `enable_ktls` and `tls_version` were added to the `sock_impl_set_options` structure.\nNew options `psk_key` and `psk_identity` were added to the `sock_impl_set_options` structure.\n\nAdded warning message for `bdev_rbd_create`, if it is used without -c.\n`bdev_rbd_create()` API without specifying -c is deprecated and will be removed in future release.\n\nRenamed `enable_vmd` RPC to `vmd_enable` to make it consistent with our naming scheme of\n`<subsystem>_<action>`.  For now, the old name is still available, but is marked as deprecated.\n\nNew function `spdk_rpc_get_method_state_mask` was added to RPC library.\n\n### sma\n\nExtended `VolumeParameters` with crypto parameters allowing the user to configure crypto when\nattaching a volume to a device.  This interface is now supported by all upstream device types\n(nvmf-tcp, virtio-blk, vfio-user) using `bdev_crypto`.  Users must specify the crypto engine to use\nunder `crypto` section in config.  It is also possible to register out-of-tree crypto engines by\ninheriting from the `CryptoEngine` class.\n\nAdded two new methods: `SetQos` and `GetQosCapabilities` allowing the user to configure QoS on a\nper-device or per-volume level.  Not all QoS settings have to be supported by each device, so users\ncan use `GetQosCapabilities` to query them for that.  All upstream device types support QoS on a\nper-volume level using bdev layer's QoS mechanism.\n\n### sock\n\nAdded new `ssl` based socket implementation, the code is located in `module/sock/posix`.\nFor now we are using hard-coded PSK and only support TLS 1.3.\n\n### util\n\nAdded new functions: `spdk_hexlify` and `spdk_unhexlify`.\n\nA new API `spdk_xor_gen` was added to generate XOR from multiple source buffers. It is going to be\nused by `raid5f` for calculating parity.\n\n### vfu_tgt\n\nAdded vfu_tgt library abstraction based on libvfio-user for PCI device emulation.\nBesides the NVMe device emulation, its now possible to emulate virtio-blk and virtio-scsi\ndevices.\n\n### virtio\n\nvirtio-vhost-user no longer tries to support dynamic memory allocation.  The vhost target does\nnot support the high rate of SET_MEM_TABLE vhost messages that result from dynamic memory\nallocation, so a virtio-vhost-user device will now present an ERRLOG, assert, and skip the\nSET_MEM_TABLE vhost message if a memory notification is received outside of the normal device\nstart/stop. Applications using the virtio library in vhost-user mode should now pre-allocate\nthe application's memory using the -s/--mem-size option and use single shared memory file\nsegments using the -g/--single-file-segments option.\n\nAdded `vfio-user` transport type for virtio-blk and virtio-scsi devices.\n\n### vmd\n\nFixed hotplug when a device is inserted in a slot in which a disk was already enumerated previously.\nAdded two new RPCs: `vmd_remove_device` simulating a hotremove, and `vmd_rescan`, which rescans all\nbuses managed by the VMD driver and hotplugs all newfound devices.\n\n## v22.05\n\n### sock\n\nA new option `ack_timeout` was added to the `spdk_sock_opts` structure.\n\n### util\n\nA new parameter `bounce_iovcnt` was added to `spdk_dif_generate_copy` and `spdk_dif_verify_copy`.\nThe `bounce_iovcnt` is used to specify the number of bounce_iov to support multiple block-aligned\nfragment copies.\n\nA new API `spdk_copy_iovs_to_buf` and `spdk_copy_buf_to_iovs` were added to copy iovs to buf or\ncopy buf to iovs. There're many cases need to use these two APIs.\n\n### bdev\n\nRemoved deprecated spdk_bdev_module_finish_done(). Use spdk_bdev_module_fini_done() instead.\n\nA new API `spdk_bdev_unregister_by_name` was added to handle race conditions correctly.\n\nNew APIs, `spdk_for_each_bdev` and `spdk_for_each_bdev_leaf`, were added to provide iteration\nsafe for race conditions.\n\nA new RPC `bdev_nvme_get_io_paths` was added to get all active I/O paths.\n\nA new RPC `bdev_nvme_set_preferred_path` was added to set preferred I/O path for an NVMe bdev\nwhen in multipath mode. This RPC does not support NVMe bdevs in failover mode.\n\nA new RPC `bdev_nvme_set_multipath_policy` was added to set multipath policy of a NVMe bdev\nin multipath mode.\n\nA new option `disable_auto_failback` was added to the `bdev_nvme_set_options` RPC to disable\nautomatic failback.\n\n### idxd / dsa\n\nA new parameter `flags` was added to all low level submission and preparation\nAPIs to enable the caller to pass operation flags per the DSA specification.\n\nA new flag 'SPDK_IDXD_FLAG_PERSISTENT' was added to let DSA know that\nthe destination is persistent.\n\nThe RPC `idxd_scan_accel_engine` has been renamed to `dsa_scan_accel_engine`\n\nThe RPC `iaa_scan_accel_engine` has been added.\n\nMany HW related structs/functions with the name `idxd` have been renamed `dsa`\nto more accurately represent the HW they are associated with.\n\nTwo new functions were added to the library `spdk_idxd_submit_compress` and\n`spdk_idxd_submit_decompress`\n\n### accel_fw\n\nA new parameter `flags` was added to accel API.\nThe APIs include:\n`spdk_accel_submit_copy`\n`spdk_accel_submit_dualcast`\n`spdk_accel_submit_fill`\n`spdk_accel_submit_copy_crc32c`\n`spdk_accel_submit_copy_crc32cv`\n`spdk_accel_submit_compress`\n`spdk_accel_submit_decompress`\n\nA new flag `ACCEL_FLAG_PERSISTENT` was added to indicate the target memory is PMEM.\n\nThe API `spdk_accel_get_capabilities` has been removed.\n\n### crypto\n\nSupport for AES_XTS was added for MLX5 polled mode driver (pmd).\n\nbdev_crypto_create RPC now requires hexlified 'key' and 'key2' params for all pmd drivers.\nUnhexlifying is performed during RPC command processing and the vbdev crypto module runs on\nbinary keys as before.\n\n### bdev\n\nAdded a timeout option to the `bdev_get_bdevs` RPC.  It allows the user to specify the amount of\ntime to wait until a bdev with a given name appears in the system.\n\n### bdev_nvme\n\nAdded `bdev_nvme_add_error_injection` and `bdev_nvme_remove_error_injection` RPCs to add and\nremove NVMe error injections.\n\nNew parameters, `ctrlr_loss_timeout_sec`, `reconnect_delay_sec`, and `fast_io_fail_timeout_sec`, are\nadded to the RPC `bdev_nvme_set_options`. They can be overridden if they are given by the RPC\n`bdev_nvme_attach_controller`.\n\n### blobstore\n\nNew functions `spdk_blob_io_writev_ext` and `spdk_blob_io_readv_ext` are added. The new functions accept\n`spdk_blob_ext_io_opts` structure with extended IO request options.\n\n### event\n\nAdded `msg_mempool_size` parameter to `spdk_reactors_init` and `spdk_thread_lib_init_ext`.\nThe size of `g_spdk_msg_mempool` can now be controlled through the same-named\nuser option of `spdk_app_opts` structure.\n\n### nvme\n\nThe API `spdk_nvme_ctrlr_prepare_for_reset()` was deprecated. The functionality provided by the\n`spdk_nvme_ctrlr_prepare_for_reset()` was merged into the API `spdk_nvme_ctrlr_disconnect()`.\n\n### nvmf\n\nRemoved deprecated max_qpairs_per_ctrlr parameter from nvmf_create_transport RPC. Use\nmax_io_qpairs_per_ctrlr instead.\n\nDeprecated the ability for hosts to connect to the discovery subsystem automatically on any\nexisting listener. Users should now explicitly add listeners for the discovery subsystem.\nHost can still connect to the discovery subsystem as before, but a warning message will be\nemitted if no listener was configured for the transport ID of the incoming connection.\n\nAdded adaptive interrupt feature for vfio-user transport. New parameter `disable_adaptive_irq`\nis added to the RPC `nvmf_create_transport`.\n\n### thread\n\nAdded `spdk_thread_exec_msg()` API.\n\n### scheduler\n\n`framework_set_scheduler` can now be called after application initialization.\nAdded callbacks to set custom parameters specific for each scheduler implementation\nand `framework_get_scheduler` to retrieve them.\n\nAdded `dynamic` scheduler options: load_limit, core_limit, core_busy. Their descriptions\nare available in JSON-RPC document, in section\n[framework_set_scheduler](jsonrpc.html#rpc_framework_set_scheduler).\n\n### raid\n\nAdd concat as a special raid module. The concat module could create a virtual bdev.  The\nvirtual bdev combines multiple underlying bdevs together. The layout of the underlying\nbdevs is one after another. The concat bdev is extendable. When the free space of the\nconcat bdev is not enough, the user can deconstruct the concat bdev, then reconstruct it\nwith an additional underlying bdev.\n\n### sock\n\nAllow MSG_ZEROCOPY flag to be set or not according to data size, which can be enabled and\nset by setting \"zerocopy_threshold\". zerocopy_threshold = 0 means disable this function;\nzerocopy_threshold > 0 means enable it and use this value as the threshold.\n\n### rpc\n\nIntroduced `zerocopy_threshold` to enable zerocopy on send for server sockets according to\ndata size to be flushed.\n\n## v22.01\n\n### accel\n\nThe batching capability was removed. Batching is now considered an implementation\ndetail of the low level drivers.\n\n### bdev\n\nThe NVMe bdev module supports multipath and improved I/O error resiliency.\n\nThe parameter `retry_count` of the RPC `bdev_nvme_set_options` was deprecated and will be\nremoved in SPDK 22.04, and the parameter `transport_retry_count` is added and used instead.\n\nAn new parameter `bdev_retry_count` is added to the RPC `bdev_nvme_set_options`.\n\nNew parameters, `ctrlr_loss_timeout_sec`, `reconnect_delay_sec`, and `fast_io_fail_timeout_sec`, are\nadded to the RPC `bdev_nvme_attach_controller`.\n\nAn new parameter `num_io_queues` is added to `bdev_nvme_attach_controller` RPC to allow specifying amount\nof requested IO queues.\n\nAdded `key_file` parameter to the `rbd_register_cluster` RPC.  It is an optional parameter to\nspecify a keyring file to connect to a RADOS cluster.\n\nAdded `spdk_bdev_get_zone_id` API to retrieve zone_id for a certain LBA.\n\n### bdev_aio\n\nAdded `bdev_aio_rescan` RPC to allow rescanning the size of aio bdev.\n\n### bdev_nvme\n\nAdded discovery service to bdev_nvme module, which now can connect to a discovery controller.\nbdev_nvme will connect to all current and future subsystems in the discovery controller.\nAdded `bdev_nvme_start_discovery` and `bdev_nvme_stop_discovery` RPC.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 21.11.\n\n### env\n\nAdded `spdk_pci_for_each_device`.\n\nRemoved `spdk_pci_get_first_device` and `spdk_pci_get_next_device`.  These APIs were unsafe, because\nthey did not account for PCI devices being inserted or removed while the caller was using handles\nreturned from these APIs.  Existing users of these APIs should switch to `spdk_pci_for_each_device`\ninstead.\n\nAdded 3 experimental APIs to handle PCI device interrupts (`spdk_pci_device_enable_interrupt`,\n`spdk_pci_device_disable_interrupt`, `spdk_pci_device_get_interrupt_efd`).\n\nAdded `framework_get_pci_devices` RPC to list PCIe devices attached to an SPDK application.\n\n### idxd\n\nMany APIs are now vectored rather than scalar, meaning they take iovecs instead of individual pointers.\n\n### json\n\nAdded `spdk_json_write_bytearray` API to serialize a buffer as a hex string.\n\n### nvme\n\nAPI `spdk_nvme_trtype_is_fabrics` was added to return existing transport type\nis fabric or not.\n\nAPI `spdk_nvme_poll_group_remove` was limited to be available only for a\ndisconnected qpair in the group.\n\nNew APIs, `spdk_nvme_ctrlr_disconnect`, `spdk_nvme_ctrlr_reconnect_async`, and\n`spdk_nvme_ctrlr_reconnect_poll_async`, have been added to improve error recovery, and\nthe existing APIs,`spdk_nvme_ctrlr_reset_async` and `spdk_nvme_ctrlr_reset_poll_async`\nwere deprecated.\n\nAdded `spdk_nvme_ctrlr_get_discovery_log_page` API for getting the full discovery log page\nfrom a discovery controller.\n\n### nvmf\n\nAdded support for zero-copy operations in the NVMe-oF TCP target. It can be enabled via\nthe `zcopy` parameter when creating a transport. The zero-copy operations are only used\nfor requests not using in-capsule data.\n\nAdded a `subsystem` parameter to `spdk_nvmf_transport_stop_listen_async`. When not NULL,\nit will only disconnect qpairs for controllers associated with the specified subsystem.\n\nRemoved accept poller from transport layer. Each transport can have its own policy of\nhandling new connections. To notify transport layer `spdk_nvmf_poll_group_add` and\n`spdk_nvmf_tgt_new_qpair` can be used.\n\n### scsi\n\nStructure `spdk_scsi_lun` has been extended with new member `resizing` so that SCSI layer now reports\nunit attention for disk resize.\n\n### trace\n\nAdded `spdk_trace_create_tpoint_group_mask` to return tracepoint group mask from\na tracepoint group name.\n\nAdded `trace_set_tpoint_mask` and `trace_clear_tpoint_mask` RPC to allow enabling\nindividual traces.\n\n### util\n\nAdded `spdk_ioviter_first` and `spdk_ioviter_next` to iterate over two iovecs and\nyield pointers to common length segments.\n\n### sock\n\nA new parameter `hint` is added to `spdk_sock_get_optimal_sock_group`. It allows to suggest\na poll group when no optimal poll group is found.\n\n## v21.10\n\nStructure `spdk_nvmf_target_opts` has been extended with new member `discovery_filter` which allows to specify\nfiltering rules applied during discovery log generation. Refer to `enum spdk_nvmf_tgt_discovery_filter` for more info.\n\n### bdev\n\nNew API `spdk_bdev_get_memory_domains` has been added, it allows to get SPDK memory domains used by bdev.\n\nNew API functions `spdk_bdev_readv_blocks_ext` and `spdk_bdev_writev_blocks_ext` have been added.\nThese functions accept `spdk_bdev_ext_io_opts` structure with extended IO request\noptions, e.g. DMA memory domain which describes data that may belong to another memory domain and\ncan't be accessed directly.\n\nAdded `async_fini_start` to allow bdev modules to complete the `fini_start` asynchronously,\nwith new `spdk_bdev_module_fini_start_done` API.\n\nDeprecated `spdk_bdev_module_finish_done()` API, which will be removed in SPDK 22.01.\nBdev modules should use `spdk_bdev_module_fini_done()` instead.\n\nThe `ocssd` bdev has been removed. The Open Channel specification has been largely superseded by\nzoned namespaces, few if any devices have been brought to market, and there is little reason to\ncontinue to support this. OCSSD support in the nvme driver will remain for now.\n\n### dma\n\nA new library, lib/dma, has been added. This library provides the necessary infrastructure for\nhandling systems and devices with multiple memory domains. For example, a PCIe add-in card with an\nSoC may be running SPDK on the SoC. That SoC has its own local memory, but SPDK may be controlling\ndevices that can also access the host system memory. This library provides infrastructure to enumerate\nthe memory domains and request hardware perform DMA transfers between them.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 21.08.\n\n### event\n\nAdded the `disable_signal_handlers` flag to the `spdk_app_opts` struct.\n\n### idxd\n\nAdded `spdk_idxd_get_socket` to query the socket that the idxd device\nis on.\n\n### json\n\nAdded API to allow for writing and decoding of new types:\n\n- `spdk_json_write_named_uint16`\n- `spdk_json_write_named_uint8`\n- `spdk_json_write_uint16`\n- `spdk_json_write_uint8`\n- `spdk_json_number_to_uint8`\n- `spdk_json_decode_uint8`\n\n### log\n\nAdded API `spdk_log_to_syslog_level` to return syslog level based on SPDK's\nlog level.\n\n### nvme\n\nAdded new functions `spdk_nvme_zns_set_zone_desc_ext` and `spdk_nvme_zns_ext_report_zones`\nto set zone descriptor extension and to get extended zone report respectively.\n\nNew API `spdk_nvme_ctrlr_get_memory_domains` has been added, it allows to get SPDK memory domains used by nvme controller.\n\nNew API functions `spdk_nvme_ns_cmd_readv_ext` and `spdk_nvme_ns_cmd_writev_ext`\nhave been added. These functions accept `spdk_nvme_ns_cmd_ext_io_opts` structure with extended IO request\noptions, e.g. DMA memory domain which describes data that may belong to another memory domain and\ncan't be accessed directly.\n\nAdded a new function `spdk_nvme_ctrlr_get_regs_bpinfo` to get boot partition info of a controller.\nAdded new functions `spdk_nvme_ctrlr_write_boot_partition`,\n`spdk_nvme_ctrlr_read_boot_partition_start` and `spdk_nvme_ctrlr_read_boot_partition_poll`\nto write and read the boot partitions of a controller.\n\nAdded `spdk_nvme_ctrlr_get_opts` to retrieve the current controller options.\n\nAdded `async_mode` to `spdk_nvme_io_qpair_opts` to enable creation of submission and completion\nqueues asynchronously. This mode is currently supported at PCIe layer,\nwhich tracks the qpair creation with state machine and returns to the user immediately.\nDefault mode is set to false to create io qpairs synchronously.\n\nAdded `spdk_nvme_ctrlr_get_regs_cc` to retrieve NVMe controller CC (Configuration) register.\n\nAdded `spdk_nvme_ctrlr_prepare_for_reset` to inform the driver that the application is preparing\nto reset the specified NVMe controller. This function allows the driver to make decisions\nknowing that a reset is about to happen.\n\n### nvmf\n\nAdded `oncs` to `struct spdk_nvmf_ctrlr_data` so that the transport layer\ncan decide support RESERVATION feature or not.\n\nAn `opts_size` element was added in the `spdk_nvmf_ns_opts` structure to solve the\nABI compatibility issue between different SPDK version. An new option `anagrpid` was\nadded in the `spdk_nvmf_ns_opts` structure.\n\nAn new parameter `anagrpid` was added to the RPC `nvmf_subsystem_add_ns`.\n\nAn new parameter `anagrpid` was added to the RPC `nvmf_subsystem_listener_set_ana_state`.\n\n`spdk_nvmf_subsystem_destroy` is now can be asynchronous, it accepts a callback and callback argument.\n\nA new parameter, `poll_groups_mask` was added to the `nvmf_set_config` RPC that allows specifying\na subset of cores for the nvmf poll groups. This helps to avoid imbalances when some cores are\nbusy with periodic timer tasks that run very frequently.\n\nA new parameter, `commit` was added to `nvmf_bdev_ctrlr_end_zcopy` that allows indicating whether\nthe buffers should be committed.\n\nAdded `listen_dump_opts` to `spdk_nvmf_transport_ops` so that the transport layer can display\nlisten opts.\n\nAdded `fabrics_connect_timeout_us` to `bdev_nvme_attach_controller` RPC to allow specifying\ntimeout for connect operation.\n\nAdded `multipath` to `bdev_nvme_attach_controller` RPC to allow specifying multipath behavior.\n\n### scheduler\n\nNew API for implementing schedulers and governors. Please see `include/spdk/scheduler.h` for details.\n\n### scsi\n\nNew functions, `spdk_scsi_dev_get_first_lun` and `spdk_scsi_dev_get_next_lun`\nhave been added to iterate LUNs of a SCSI device.\n\nEach SCSI device supports 256 LUNs at the maximum now and the macro constant\n`SPDK_SCSI_DEV_MAX_LUN` was removed.\n\n### trace_parser\n\nA new library, lib/trace_parser, has been added. This library provides functions that parse traces\nrecorded by an SPDK application. That includes merging traces from multiple cores,\nsorting them by their timestamp and constructing trace entries spanning across multiple buffers.\n\n### util\n\nThe `spdk_fd_group_add` API now takes a `name` parameter.\n\n## v21.07\n\n### accel_fw\n\nAdded API `spdk_accel_submit_copy_crc32c` to perform a CRC32C while copying data.\n\nAdded API `spdk_accel_batch_prep_copy_crc32c` to batch CRC32C + copy commands.\n\nAdded API `spdk_accel_submit_copy_crc32cv` to submit chained CRC32C + copy commands.\n\n### bdev\n\nChange `spdk_bdev_read_blocks_with_md` arg offset definition from int64_t to uint64_t.\n\nRed-black tree has been used to organize the bdev names and aliases uniformly\nto provide faster lookup.\n\nRemoved ZCOPY emulation: The bdev module can be checked to see if it supports ZCOPY\nand if not supported then use existing READ/WRITE commands.\n\nAdded iov to spdk_bdev_zcopy_start.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 21.05.\n\n### idxd\n\nRemove the `probe_cb` parameter in `spdk_idxd_probe` function. And remove the definition\nof `spdk_idxd_probe_cb` function pointer. It should be implemented in idxd_user.c.\n\nAdded API `spdk_idxd_submit_copy_crc32c` to perform a CRC32C while copying data.\n\nAdded API `spdk_idxd_batch_prep_copy_crc32c` to prepare a batch operation to perform\na CRC32C while copying data.\n\nWe have userspace idxd driver under accel_engine library (module/accel/idxd/accel_engine).\nAnd kernel idxd driver usage is also added under the accel_engine library. This approach\nimplemented a wrapper library to use IDXD device by leveraging the kernel DSA driver in\nSPDK idxd library (lib/idxd). Then users can leverage the RPC later to configure how to\nuse the DSA device by user space driver or kernel driver.\n\n### init\n\nAdded new `init` library that initializes the SPDK subsystems, which previously was\ninternal to application framework. That functionality has been made public and for\nuse by applications which don't leverage SPDK's application framework.\n\n### iscsi\n\nNew parameters, `pdu_pool_size`, `immediate_data_pool_size`, and `data_out_pool_size`,\nwere added to the RPC `iscsi_set_options` to run iSCSI target with varying amount of\navailable memory.\n\n### json\n\nAdded API `spdk_json_write_named_uint128` and `spdk_json_write_uint128` to perform\nthe uint128 related data.\n\n### net\n\nRemoved deprecated `net` library.\n\nAdded support for ZCOPY.  ZCOPY is used in preference to READ and WRITE if the\nbdev module supports ZCOPY and the bdev module has ZCOPY enabled.\n\n### nvme\n\n`spdk_nvme_map_prps` and `spdk_nvme_map_cmd` were moved to nvmf/vfio-user as internal APIs\nas vfio-user is the only user for the above two APIs.\n\nAdded a new function `spdk_nvme_ns_cmd_copy` to submit a Simple Copy Command to a Namespace.\n\nUpdate the `spdk_nvme_generic_command_status_code` structure with new status code\naccording to the definition in NVMe 1.4 spec.\n\n`spdk_nvme_ctrlr_get_default_ctrlr_opts` now sets `use_cmb_sqs` to false. This means\nthat if a controller has a CMB and supports SQs in the CMB, SPDK will not use\nthe CMB for SQs by default - the user must set `use_cmb_sqs` to true in\nthe `spdk_nvme_ctrlr_opts` structure prior to controller attach.\n\nAdd a new function `spdk_nvme_detach_poll` to simplify a common use case to continue\npolling until all detachments complete.\n\nAdded new argument `timeout_admin_us` to `spdk_nvme_ctrlr_register_timeout_callback` so callers\ncan specify a different timeout for admin commands vs. io commands.\n\nAn existing function `spdk_nvme_detach_async` was updated to add one or more detachments\nto an active context while it is being polled.\n\nRename a variable in the member `cmic` of the struct `spdk_nvme_ctrlr_data` from\n`multi_host` to `multi_ctrlr`. The variable means that the NVM subsystem may have two or\nmore controllers if set to 1. However `multi_host` had indicated a particular use case\nsuch that the NVM subsystem is used by multiple hosts.\n\nA new option `disable_read_ana_log_page` was added to struct `spdk_nvme_ctrlr_opts` to disable\nreading ANA log page. The upper layer is expected to read ANA log page instead if `true`.\nThe default value is `false`.\n\nNew APIs, `spdk_nvme_ctrlr_reset_async` and `spdk_nvme_ctrlr_reset_poll_async`, have been added to\nreset a controller asynchronously.\n\nNew RPC `bdev_nvme_reset_controller` was added, to reset an NVMe controller.\n\nAdded `spdk_nvme_ns_get_nguid` function to get NGUID for the given namespace.\n\nAdded `spdk_nvme_ctrlr_is_fabrics` function to indicate whether a ctrlr handle\nis associated with a fabrics controller.\n\n### nvmf\n\nAdded `min_cntlid` and `max_cntlid` to `nvmf_create_subsystem` to limit the controller ID range.\nAdded `spdk_nvmf_subsystem_get_min_cntlid` and `spdk_nvmf_subsystem_get_max_cntlid` to request those values.\n\n`spdk_nvmf_request_get_buffers_multi` API is removed.\n\nAdded the `nvmf_set_crdt` RPC for setting command retry delay times.\n\nExpanded `spdk_nvmf_poll_group_stat` with current qpair count statistics.\n\nRemoved following deprecated APIs:\n\n- `spdk_nvmf_poll_group_get_stat` (function in `nvmf.h`),\n- `spdk_nvmf_transport_poll_group_get_stat` (function in `nvmf.h`),\n- `spdk_nvmf_transport_poll_group_free_stat`(function in `nvmf.h`),\n- `spdk_nvmf_rdma_device_stat` (struct in `nvmf.h`),\n- `spdk_nvmf_transport_poll_group_stat` (struct in `nvmf.h`),\n- `poll_group_get_stat` (transport op in `nvmf_transport.h`),\n- `poll_group_free_stat` (transport op in `nvmf_transport.h`).\n\n### rpc\n\nNew RPC `bdev_rbd_register_cluster` and `bdev_rbd_unregister_cluster` was added, it allows to create\nand delete the rados object cluster, then users can choose the cluster to create related rbd\ndevice.\n\nRevised `bdev_rbd_create` parameter, it allows to use an optional parameter `--cluster-name`\nto create a rbd bdev with  an already registered Rados Cluster Object.\n\nNew RPC `bdev_rbd_get_clusters_info` was added, it allows to get the info of the registered\nRados Cluster names.\n\nNew optional parameter, `timeout_admin_us`, added to the bdev_nvme_set_options RPC.\n\nRevised a parameter `--stripe-size_kb` to `--stripe-size-kb` of `bdev_raid_create` method\nprovided in `scripts/rpc.py` for consistency.\n\nAn new optional parameter `config_kernel_mode` was added to the RPC `idxd_scan_accel_engine`,\nand this is used to enable using the kernel mode IDXD driver.\n\nRemoved deprecated parameter `enable-zerocopy-send` of RPC `sock_impl_set_options`,\nuse `enable-zerocopy-send-server` or `enable-zerocopy-send-client` instead.\nRemoved deprecated parameter `disable-zerocopy-send` of RPC `sock_impl_set_options`,\nuse `disable-zerocopy-send-server` or `disable-zerocopy-send-client` instead.\n\n### rpm\n\nRemoved deprecated `pkg/spdk.spec`, please use `rpmbuild/spdk.spec` instead.\nSee [RPM documentation](https://spdk.io/doc/rpm.html) for more details.\n\n### thread\n\nRed-black tree has been used for timed pollers to provide faster insertion and deletion\nand for io_devices to provide faster lookup.\n\nRemoved `spdk_io_channel` structure from public header and moved it to thread_internal.h.\n\n### trace\n\nAdded `spdk_trace_register_description_ext` function to register variable number of tracepoint arguments.\n\nAdded ability to chain multiple trace entries together to extend the size of the argument buffer.\n\n### util\n\nRed-black tree macros has been added by using the macros provided by the FreeBSD operating system\nunder the same BSD license.\n\nAdd an new macro `SPDK_SIZEOF_MEMBER` to get the size of a member of a struct.\n\n`spdk_crc32c_iov_update` function was added to support calculating the crc32c of the iovs.\n\nAdded zipf random number generator with power law probability distribution.\nWhen applied to performance testing of block devices, it will select blocks over\nthe full range of LBAs, but will more frequently select lower-numbered LBAs.\n\n## v21.04\n\n### accel\n\nTwo new accelerated crc32 functions `spdk_accel_submit_crc32cv` and\n`spdk_accel_batch_prep_crc32cv` are added in order to provide the\nchained accelerated CRC32 computation support.\n\n### bdev\n\nFor `bdev_ocssd_create` RPC, the optional parameter `range` was removed.\nOnly one OCSSD bdev can be created for one OCSSD namespace.\n\nRemoved the `spdk_bdev_open` from bdev library API.\nRemoved the `spdk_vbdev_register` and `spdk_bdev_part_base_construct` from bdev module API.\nRemoved the `config_text` function for bdev modules to report legacy config.\n\nAdded `spdk_bdev_get_max_active_zones` API to display maximum number active zones of a given bdev.\n\nAdded `spdk_bdev_get_max_zone_append_size` API to display maximum zone append data transfer size.\n\n### bdev_nvme\n\nAdded support for zoned namespaces.\n\n### blobstore\n\nRemoved the `spdk_bdev_create_bs_dev_from_desc` and `spdk_bdev_create_bs_dev` API.\n\n### env\n\nAdded `spdk_pci_device_allow` API to allow applications to add PCI addresses to\nthe allowed list after the application has started.\n\nRemoved the `pci_whitelist`, `pci_blacklist` and `master_core` members of struct `spdk_env_opts`.\n\nAdded hotplug support based on uevent in `pci_event.c`. Added usage of this functionality in\nnvme, virtio-scsi and virtio_blk libraries. Please see the new API `spdk_pci_event_listen`,\n`spdk_pci_get_event`, `spdk_pci_register_error_handler` and `spdk_pci_unregister_error_handler`.\n\n### event\n\nRemoved the `config_file`, `max_delay_us`, `pci_whitelist`\nand `pci_blacklist` members of struct `spdk_app_opts`.\n\n### idxd\n\nA new API `spdk_idxd_device_needs_rebalance` was added so that users of the library\ncan know whether they need to rebalance the flow control for the channel\nthat was just added/removed.  This is based on how the low level library\nshares devices amongst channels.\n\nThe API `spdk_idxd_reconfigure_chan` had the `num_channels` removed as this\nis now tracked in the library.  The app makes use the new API above to\ndetermine whether to rebalance or not. This applies to `spdk_idxd_configure_chan`\nas well.\n\nThe API `spdk_idxd_put_channel` now returns the rebalance state for the\nunderlying device.\n\n### iscsi\n\nA security vulnerability has been identified and fixed in the SPDK iSCSI target.\nA TEXT PDU with no data, but CONTINUE flag set, would result in a NULL pointer dereference\nand crash the SPDK iSCSI target process. All users of the SPDK iSCSI target\nare recommended to update. All SPDK versions <= v21.01 are affected.\n\n### net\n\nThe net library is deprecated and will be removed in the 21.07 release.\n\n### nvme\n\nAdded a new function `spdk_nvme_ctrlr_get_regs_pmrcap` to get the PMR capabilities.\n\nAdded an accelerated table pointer in `spdk_nvme_poll_group`\nwhich can be used to provide the accelerated functions by users with\nhardware engine, such as crc32c accelerated function.\n\nAdded new functions `spdk_nvme_ctrlr_get_pmrsz`, `spdk_nvme_ctrlr_enable_pmr`,\n`spdk_nvme_ctrlr_disable_pmr`, `spdk_nvme_ctrlr_map_pmr` and `spdk_nvme_ctrlr_unmap_pmr`.\n\nAdded NVMe transport operations to enable, disable, map and unmap the PMR.\n\nAdded `spdk_nvme_qpair_get_optimal_poll_group` function and `qpair_get_optimal_poll_group`\nfunction pointer in spdk_nvmf_transport_ops structure in order to add the qpair to the most\nsuitable polling group.\n\nAdded OPTPERF and namespace optimal performance fields to nvme_spec.h.\n\nAdded `spdk_nvme_set_hotplug_filter` API to allow applications to choose which\nhot-inserted SSDs should be probed. This is useful for use cases where multiple\nindependent SPDK processes are running on one node. The filter function can\nthen be implemented in these processes to decide which SSDs to probe based on\nthe new SSD's PCI address.\n\nNew functions `spdk_nvme_poll_group_get_stats` and `spdk_nvme_poll_group_free_stats`\nwere added. These functions allow to get transport statistics per NVME poll group.\n\nAdded `spdk_nvme_map_cmd` API to map the NVMe command with SGL cases.\n\nAdded support for vector variant of ZNS zone append commands with new API\n`spdk_nvme_zns_zone_appendv` and `spdk_nvme_zns_zone_appendv_with_md`.\n\nAdded `spdk_nvme_zns_ns_get_max_open_zones` and `spdk_nvme_zns_ns_get_max_active_zones` API,\nto display maximum number of open and active zones of the given namespace.\n\nAdded `spdk_nvme_zns_ns_get_zone_size_sectors` API to provide size of zone in number of\nsectors.\n\nAdded `spdk_nvme_qpair_get_id` API to display the ID of the specified qpair.\n\n### nvmf\n\nRemoved the `spdk_nvmf_tgt_listen` and `spdk_nvmf_subsystem_add_ns` API.\n\nAdded new APIs:\n\n- `spdk_nvmf_poll_group_dump_stat` (function in `nvmf.h`).\n- `poll_group_dump_stat` (transport op in `nvmf_transport.h`).\n\nThe following APIs have been deprecated and will be removed in SPDK 21.07:\n\n- `spdk_nvmf_poll_group_get_stat` (function in `nvmf.h`),\n- `spdk_nvmf_transport_poll_group_get_stat` (function in `nvmf.h`),\n- `spdk_nvmf_transport_poll_group_free_stat`(function in `nvmf.h`),\n- `spdk_nvmf_rdma_device_stat` (struct in `nvmf.h`),\n- `spdk_nvmf_transport_poll_group_stat` (struct in `nvmf.h`),\n- `poll_group_get_stat` (transport op in `nvmf_transport.h`),\n- `poll_group_free_stat` (transport op in `nvmf_transport.h`).\n\nSee header files for details.\n\nThe `trtype` field in JSON returned by `nvmf_get_stats` RPC contains now the name of the transport,\nwhich is the same as the type for defined transports and more informative for a custom transport.\n\nAdded `hdgst` and `ddgst` parameters to `bdev_nvme_attach_controller` RPC in order change\nstate of TCP header and data digest.\n\nAdded `num_cqe` parameter to `nvmf_create_transport` RPC to set number of completion queues (CQ)\nfor RDMA transport. Useful when CQ resize operation is not supported, for example iWARP.\n\n### ocf\n\nUpdated OCF submodule to v20.12.2\n\nAdded `bdev_ocf_set_cache_mode` RPC to dynamically switch cache mode of OCF bdev.\n\nOCF deprecation notice has removed as Huawei is picking up support for the OCF project.\n\n### opal\n\nRemoved the `spdk_opal_supported` API.\n\n### raid\n\nFor `bdev_raid_create` RPC, the deprecated parameter `strip_size` was removed.\n\n### rpc\n\nNew RPC `bdev_nvme_get_transport_statistics` was added, it allows to get transport statistics\nof nvme poll groups.\n\nParameter `enable-zerocopy-send` of RPC `sock_impl_set_options` is deprecated and will be removed in SPDK 21.07,\nuse `enable-zerocopy-send-server` or `enable-zerocopy-send-client` instead.\nParameter `disable-zerocopy-send` of RPC `sock_impl_set_options` is deprecated and will be removed in SPDK 21.07,\nuse `disable-zerocopy-send-server` or `disable-zerocopy-send-client` instead.\n\nAdded cmd_parser.py used to parse the args from argparse. There are\ntwo benefit to use command parser:\n\n- Simplify the definition of rpc method. It will reduce the rpc method code.\n- Make the rpc call more versatile. User can add private args into rpc method.\n\n### rpm\n\nAdded support for new RPM spec, rpmbuild/spdk.spec, which can be used for packaging the\nSPDK. The pkg/spdk.spec is considered to be deprecated and scheduled for removal in SPDK 21.07.\nSee [RPM documentation](https://spdk.io/doc/rpm.html) for more details.\n\n### sock\n\nThe type of `enable_placement_id` in struct `spdk_sock_impl_opts` is changed from\nbool to int. We can use RPC to configure different value of `enable_placement_id`.\nThen we can leverage SO_INCOMING_CPU to get placement_id, which aims to utilize\nCPU cache locality, enabled by setting enable_placement_id=2.\n\nA new socket placement mode called PLACEMENT_MARK has been added. Some NICs allow\nsockets to be marked using the SO_MARK socket option as a hint for which hardware\nqueue they should be associated with. This mode leverages that by setting the same\nvalue for all sockets within a poll group.\n\nNew parameters `enable_zerocopy_send_server` and `enable_zerocopy_send_client` were added\nto struct spdk_sock_impl_opts, these parameters enable or disable zero copy send for server\nand client sockets which are created using `spdk_sock_listen` and `spdk_sock_listen_ext` (server);\n`spdk_sock_connect` and `spdk_sock_connect_ext` (client) functions. Existing parameter\n`enable_zerocopy_send`  enables or disables zero copy send for both server and client sockets.\n\n### thread\n\nA new API `spdk_io_channel_get_io_device` was added to get the io_device for the specified\nI/O channel.\n\nAdded `spdk_thread_set_interrupt_mode` function in order to set present spdk_thread into\ninterrupt mode or back to poll mode. It is valid only when thread interrupt facility is\nenabled by `spdk_interrupt_mode_enable`.\n\nAdded `spdk_poller_register_interrupt` function to mark that the poller is capable of\nentering interrupt mode. Callback function will be called when the poller must transition\ninto or out of interrupt mode.\n\n### virtio\n\nAdded the `bdev_virtio_blk_set_hotplug` RPC for the virtio blk pci device.\n\n## v21.01\n\n### bdev\n\nAn `opts_size` element was added in the `spdk_bdev_opts` structure to solve the\nABI compatibility issue between different SPDK version. And also add `opts_size`\nparameter in spdk_bdev_get_opts function. Two fields `small_buf_pool_size` and\n`large_buf_pool_size` were added into spdk_bdev_opts, which were used to determine\nthe small and large buffer pool size of the whole bdev module.\n\nA new API `spdk_bdev_wait_for_examine` was added to allow for checking state of\nexamine process. Along with corresponding `bdev_wait_for_examine` RPC, which\nis now always called during `spdk_bdev_subsystem_config_json` making sure\nevery bdev is ready to be used.\n\nA new API `spdk_bdev_io_get_aio_status` was added for getting the status of\nbdev_io as Linux AIO errno. Also `spdk_bdev_io_complete_aio_status` function\nand `SPDK_BDEV_IO_STATUS_AIO_ERROR` were added for bdev module to complete\na bdev_io with Linux AIO errno.\n\nA new API `spdk_bdev_get_module_name` was added for getting block device module name.\nAlso `spdk_bdev_get_module_ctx` was added to obtain a bdev module context for\nthe block device opened by the specified descriptor.\n\nAdded `max_segment_size` and `max_num_segments` to `spdk_bdev` structure for\nbdev modules to specify splitting requirements.\n\n### blob\n\nAn `opts_size` element was added in the `spdk_bs_opts` structure to solve the\nABI compatibility issue between different SPDK version. And also add `opts_size`\nparameter in `spdk_bs_opts_init` function.\n\nAn `opts_size` element was added in the `spdk_blob_opts` structure to solve the\nABI compatibility issue between different SPDK version. And also add `opts_size`\nparameter in `spdk_blob_opts_init` function.\n\nAn `opts_size` element was added in the `spdk_blob_open_opts` structure to solve the\nABI compatibility issue between different SPDK version. And also add `opts_size`\nparameter in `spdk_blob_open_opts_init` function.\n\n### build\n\nSPDK now generates pkg-config files to simplify the process of determining which\nlibraries must be linked into an SPDK application.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 20.11.\n\nRemoved `--with-igb-uio-driver` configure option. Since DPDK 20.11 igb_uio driver\nwas moved to separate dpdk-kmods repository. If required, users need to refer to\ndpdk-kmods repository to build the driver.\n\n### env\n\nThe `pci_whitelist`, `pci_blacklist` and `master_core` members of struct `spdk_env_opts`\nhave been deprecated.  The new members are named `pci_allowed`, `pci_blocked` and\n`main_core` respectively.\n\nAn `opts_size` element was added in the `spdk_app_opts` structure\nto solve the ABI compatibility issue between different SPDK version. An `opts_size`\nparameter is added into `spdk_app_opts_init` function.\n\n### event\n\nThe `pci_whitelist` and `pci_blacklist` members of struct `spdk_app_opts` have been\ndeprecated.  The new members are named `pci_allowed` and `pci_blocked` respectively.\n\nThe `--pci-blacklist` command line option has been deprecated, replaced with\n`--pci-blocked`.\n\nThe `--pci-whitelist/-W` command line options have been deprecated, replaced with\n`--pci-allowed/-A`.\n\nAdded new experimental `dynamic` scheduler that rebalances idle threads, adjusts CPU frequency\nusing dpdk_governor and turns idle reactor cores to interrupt mode. Please see\n[scheduler documentation](https://www.spdk.io/doc/scheduler.html) for details.\n\n## ioat\n\nThe PCI BDF whitelist option has been removed from the `ioat_scan_accel_engine` RPC.\nIOAT PCI functions can still be allowed or denied using SPDK application command\nline options.\n\n### isa-l\n\nUpdated ISA-L submodule to v2.30.0.\n\n### json\n\nA new API `spdk_jsonrpc_send_bool_response` was added to allow sending response for\nwriting json bool results into one function.\nUpdate API `bdev_nvme_set_options` and add a `keep_alive_timeout_ms` parameter. Now you\ncan specify the `keep_alive_timeout` before creating NVMe bdev.\n\n### nbd\n\nChange the return type of function `spdk_nbd_stop` from void to int. And update the\n`spdk_nbd_fini` with two parameters to make its behavior from sync to async.\n\n### nvme\n\nDirectives support was added to the NVMe driver.\n\nTwo async APIs `spdk_nvme_ctrlr_cmd_directive_receive` and `spdk_nvme_ctrlr_cmd_directive_send`\nare added for Directive Send and Directive Receive command, respectively.\n\nAdded a new function `spdk_nvme_ctrlr_reset_subsystem` to perform a NVMe\nsubsystem reset. Note: The NVMe-oF target does not support the subsystem reset yet.\n\nAdd a new function `spdk_nvme_bytes_to_numd` to transfer bytes to number of\ndwords.\n\nAdded a new custom transport `SPDK_NVME_TRANSPORT_VFIOUSER` to enable NVMe\ndriver running with NVMe over vfio-user target.\n\nAdded the vfio-user custom transport implementation in NVMe driver which can connect\nto NVMe over vfio-user target via vfio-user transport.\n\nAdded a new function `spdk_nvme_ctrlr_set_remove_cb` to remove or override\n`remove_cb` and `remove_ctx` specified when the controller was probed.\n\nAdded support for ZNS zone append command with new API `spdk_nvme_zns_zone_append` and\n`spdk_nvme_zns_zone_append_with_md`.\n\n### nvmf\n\n`nvmf_fc_lld_fini` now takes callback and hence updating FC Broadcom LLD driver\nto the latest is required.\n\nFC transport supported primary tagging and VMID.\n\nBroadcom FC LLD driver and SPDK NVMe-oF FC transport consolidated one LLD API,\n`nvmf_fc_init_poller_queues` into another LLD API `nvmf_fc_init_q`.\nHence updating Broadcom FC LLD driver to the latest is required.\n\nThe functions `destroy` and `qpair_fini` in the transport interface now accept a\n`cb_fn` and `cb_arg` to call upon completion, and their execution can be asynchronous.\n\nThe SPDK NVMe-oF target now supports async event notification for discovery log changes.\nThis allows the initiator to create persistent connection to discovery controller and\nbe notified of any discovery log changes.\n\nAn `opts_size` element was added in the `spdk_nvmf_transport_opts` structure\nto solve the ABI compatibility issue between different SPDK version. And also add\n`opts_size` parameter in `spdk_nvmf_transport_opts_init` function.\n\nAdded a new custom vfio-user transport implementation in NVMe-oF which can provide\nemulated NVMe devices to QEMU and SPDK NVMe driver.\n\nAdded new API `spdk_nvmf_tgt_listen_ext` that uses `spdk_nvmf_listen_opts` to allow\npassing generic options to specific transport. This functionality replaces one provided\nwith `nvmf_subsystem_set_options`. Also removed `nvmf_subsystem_set_options` RPC\nthat allowed transport specific options within subsystem.\n\nThe `trsvcid` in `nvmf_subsystem_add_listener` RPC is now optional.\n\nPausing a subsystem now only pauses all admin queues. This allows for the\nmanagement of hosts and listeners, plus the addition of namespaces without a\nfull subsystem pause. Additionally, the target now allows for pausing\nindividual namespaces within a subsystem. To remove a namespace from a\nsubsystem, only the specific namespace must be paused. I/O will continue to\nother namespaces while these operations execute.\n\n### rpc\n\nAn new optional parameter `wait` was added to the RPC `iscsi_create_portal_group`,\nand an new RPC `iscsi_start_portal_group` was added. They will be used not to start\nlistening on portals for a portal group until all associated target nodes are created\nat startup, otherwise some iSCSI initiators may fail to re-login when SPDK iSCSI\ntarget application restarts.\n\nTwo optional parameter `--small-buf-pool-size` and `--large-buf-pool-size` were added\ninto `bdev_set_options` function.\n\n### vhost\n\nAdded optional `packed_ring_recovery` parameter to `vhost_create_blk_controller` RPC\nenabling packed ring live recovery.\n\n## v20.10\n\n### accel\n\nNew APIs `spdk_accel_batch_cancel` and `spdk_idxd_batch_cancel` were added to allow\ncancelling a batch sequence.\n\n### bdev\n\nA new `spdk_bdev_part_base_construct_ext` function has been added and the\n`spdk_bdev_part_base_construct` has been deprecated.  The\n`spdk_bdev_part_base_construct_ext` function takes bdev name as an argument instead\nof bdev structure to avoid a race condition that can happen when the bdev is being\nremoved between a call to get its structure based on a name and actually opening it.\n\nRemoved `spdk_bdev_config_text` function for bdev modules to report legacy config.\n\n### blobstore\n\nA new `spdk_bdev_create_bs_dev_ext` function has been added and `spdk_bdev_create_bs_dev_from_desc`\nfunction has been deprecated.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 20.08.\n\n### env\n\nA new API `spdk_mem_get_fd_and_offset` was added to get file descriptor and offset for\na given virtual address.\n\n### event\n\nRemoved `spdk_subsystem_config` callback for submodules as part of legacy config removal.\n\nRemoved `spdk_app_get_running_config` function that printed configuration in legacy format,\nand removed `usr1_handler` from `struct spdk_app_opts` callback that was used to call it.\n\nAdded SPDK thread scheduler framework which is used to rebalance load among CPU cores.\nThe scheduler implementation is pluggable and two schedulers are added first, `static` scheduler\nand `gscheduler` scheduler.\n\n`static` scheduler is used by default and does not reschedule threads and keeps the initial\nassignments.\n\nCPU frequency governor framework and implementation are also added.\n`dpdk_governor` is the first implementation and is based on rte_power library of DPDK.\n`gscheduler` scheduler utilizes the CPU frequency governor.\n\nScheduler and governor frameworks are experimental features.\n\n### fio\n\nBdev fio_plugin no longer supports legacy configuration files. Options `spdk_conf` and\n`spdk_json_conf` have to point to valid JSON configuration.\n\n### gpt\n\nRemoved option to disable GPT probing via legacy configuration. Please use generic\nbdev functionality to replicate the behavior. See `bdev_set_options --disable-auto-examine`\nand `bdev_examine` RPC.\n\n### intel-ipsec-mb\n\nUpdated intel-ipsec-mb submodule to v0.54\n\n### isa-l\n\nUpdated ISA-L submodule to v2.29.0.\n\n### iscsi\n\nThe iSCSI target supports iSCSI login redirection feature to achieve fault tolerance\nand load balancing particularly in scale out iSCSI target system, which runs multiple\nSPDK iSCSI targets.\n\n### json\n\nA new API `spdk_json_decode_object_relaxed` was added to allow parsing json values\neven if decoder for a given key is not found.\n\nA new API `spdk_json_free_object` was added to free memory allocated by `spdk_json_decode_object`.\n\n### log\n\nA log flag structure, `spdk_log_register_flag`, `spdk_log_get_first_flag`,\n`spdk_log_get_next_flag` and macro `SPDK_LOG_REGISTER_COMPONENT`, have been added which\nenable registering and interacting with log flags. Added `SPDK_INFOLOG`, `SPDK_DEBUGLOG`\nand `SPDK_LOGDUMP` macros to display logs for specified log flag.\n\nThe log flags in the event framework `-L` and several SPDK applications has been enabled on\nrelease builds of SPDK. On debug builds this option will additionally set\nlog print level to `SPDK_LOG_DEBUG`.\n\nA new API `spdk_log_enable_timestamps` and new RPC `log_enable_timestamps` was added to\ntoggle log timestamps.\n\n### miscellaneous\n\nThe contents of the log_rpc library have been moved to the event library. The log_rpc\nlibrary now no longer exists.\n\nThe contents of the app_rpc library have been moved to the event library. The app_rpc\nlibrary now no longer exists.\n\nThe contents of the bdev_rpc library have been moved to the bdev library. The app_rpc\nlibrary now no longer exists.\n\nThe bdevperf application now disables the zcopy API by default. Prior to this change,\nbdevperf enabled using the zcopy API by default which caused a performance impact of\nup to 25% on bdevs that don't natively support zcopy because the API emulates zero-copy\nby allocating a buffer. The bdevperf `-x` param was renamed to `-Z` and the default\nvalue changed to false. For bdevs that support zcopy, use the -Z flag to enable\nusing zcopy API.\n\n### net\n\nNet framework intended for use by user-space TCP stacks was removed.\n\n### nvme\n\nZoned Namespace Command Set support has been added to NVMe driver, see `nvme_zns.h` for details.\n\nNew APIs, `spdk_nvme_detach_async` and `spdk_nvme_detach_poll_async`, have been added to\ndetach multiple controllers in parallel to mitigate lengthy shutdown notification of\na few NVMe SSDs.\n\nNew APIs, `spdk_nvme_ns_get_ana_group_id` and `spdk_nvme_ns_get_ana_state`, have been\nadded to get ANA group ID and ANA state of the given namespace, respectively.\n\nIf no specific command set is requested (by setting the command_set member in the\n`spdk_nvme_ctrlr_opts` structure), SPDK will automatically select the most appropriate\ncommand set based on what the controller supports.\n\n### nvmf\n\nA new API `spdk_nvmf_subsystem_add_ns_ext` has been added and the API `spdk_nvmf_subsystem_add_ns`\nhas been deprecated.\n\nThe NVMe-oF target now supports Asymmetric Namespace Access (ANA) Reporting to provide\nmultipath to NVMe-oF initiator.\n\nAdd `no_wr_batching` parameter to `spdk_nvmf_transport_opts` struct to disable\nWork Requests batching in RDMA transport.\n\nNVMf Target transports can now parse any additional JSON params in the nvmf_create_transport RPC\nthrough the JSON context provided via spdk_nvmf_target_opts->transport_specific.\n\nA new RPC `nvmf_subsystem_set_options` was added to allow transport specific options within subsystem.\n\nA new API `spdk_nvmf_transport_stop_listen_async` was added to stop accepting new connections\nat the provided address. `nvmf_subsystem_remove_listener` RPC now uses this function.\n\nA new API `spdk_nvmf_subsystem_disconnect_host` was added to disconnect all connections\noriginating from the provided hostnqn. `nvmf_subsystem_remove_host` RPC now uses this function.\n\n### ocf\n\nUpdated OCF submodule to v20.03.1\n\n### rpc\n\nNew optional parameters, `enable_placement_id` and `enable_quickack` were added to the\n`sock_impl_set_options` RPC.\n\nA new RPC `bdev_examine_bdev` was added to allow users to examine a bdev explicitly.\nIt can be used only if bdev_auto_examine is set to false by the RPC `bdev_set_options`.\n\nNew optional parameters `no_wr_batching` and `control_msg_num` were added to the RPC\n'nvmf_create_transport'.\n\nNew RPCs, `iscsi_target_node_set_redirect` and `iscsi_target_node_request_logout`, have\nbeen added, and a new optional parameter `private` has been added to the RPC\n`iscsi_create_portal_group` to support iSCSI login redirection feature.\n\nA new optional parameter `ana_reporting` was added to the RPC `nvmf_create_subsystem`, and\na new RPC `nvmf_subsystem_listener_set_ana_state` was added for ANA reporting.\n\nNew RPCs, `nvmf_subsystem_get_listeners` and `nvmf_subsystem_get_qpairs`, were added to\nretrieve configuration of the NVMe-oF subsystem.\n\n### scsi\n\nTwo new APIs have been added `spdk_scsi_dev_construct_ext` and\n`spdk_scsi_dev_add_lun_ext` that allow the upper layer(e.g. vhost-scsi) to\nreceive the notification when the scsi bdev has been resized.\n\nThe `spdk_scsi_dev_construct` and `spdk_scsi_dev_add_lun` eventually may be\ndeprecated and removed.\n\n### sock\n\nThe `enable_placement_id` field was added in the `struct spdk_sock_impl_opts` to\nmake the placement_id feature configurable by users. The default setting is\nnot enabled.\n\nThe `enable_quick_ack` field was added in the `struct spdk_sock_impl_opts` to enable\nor disable quick ack for the POSIX sock module. The default setting is not enabled.\n\n### thread\n\n`fd_group` is applied to support interrupt mode.\nNew APIs were added to support an experimental interrupt mode.  This allows modules or\nlibraries to selectively register file descriptors that the spdk_thread can wait on,\nas an alternative to polling. In v20.10, this functionality is enabled in a very small\nsubset of SPDK libraries and modules.\n\n### util\n\nA new utility named `fd_group` was add. It is now\nimplemented by epoll on Linux platform. It can be used by\nspdk_thread and reactor to implement interrupt mode.\n\nAdded `spdk_bit_pool` utility, see `bit_pool.h` for details.\n\n### vhost\n\nSPDK has switched to DPDK's rte_vhost library since 19.07 release, removed the internal\nrte_vhost library which is used for DPDK older than 19.05, removed the experimental vhost\nnvme target which depends on the internal rte_vhost library.\n\n### vpp\n\nRemoved socket abstraction for VPP.\n\n## v20.07: SPDK CSI driver, new accel_fw commands, I/O abort support\n\nspdk_json_free_object() was added to free memory allocated by spdk_json_decode_object().\n\n### accel\n\nA new API was added `spdk_accel_get_capabilities` that allows applications to\nquery the capabilities of the currently enabled accel engine back-end.\n\nA new capability, CRC-32C, was added via `spdk_accel_submit_crc32c`.\n\nThe software accel engine implementation has added support for CRC-32C.\n\nA new capability, compare, was added via `spdk_accel_submit_compare`.\n\nThe software accel engine implementation has added support for compare.\n\nSeveral APIs were added to `accel_engine.h` to support batched submission\nof operations.\n\nSeveral APIs were added to `accel_engine.h` to support dualcast operations.\n\n### accel_fw\n\nThe accel_fw was updated to no longer require the app to allocate an\naccel_task on its behalf. All public APIs now take a callback arg as\nthe parameter that used to be the accel_task.\n\nThe accel_fw API `spdk_accel_task_size` was removed as it is no longer\nrequired.\n\nThe accel_fw was updated to support compare, dualcast, crc32c.\n\nThe accel_fw introduced batching support for all commands in all plug-ins.\nSee docs for detailed information.\n\n### bdev\n\nA new API `spdk_bdev_abort` has been added to submit abort requests to abort all I/Os\nwhose callback context match to the bdev on the given channel.\n\n### build\n\nThe fio plugins now compile to `build/fio` and are named `spdk_bdev` and `spdk_nvme`.\nExisting fio configuration files will need to be updated.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 20.05.\n\n### env\n\nSeveral new APIs have been added to provide greater flexibility in registering and\naccessing polled mode PCI drivers. See `env.h` for more details.\n\n### idxd\n\nThe idxd library and plug-in module for the accel_fw were updated to support\nall accel_fw commands as well as batching.  Batching is supported both\nthrough the library and the plug-in module.\n\nIDXD engine support for CRC-32C has been added.\n\n### ioat\n\nA new API `spdk_ioat_get_max_descriptors` was added.\n\n### nvme\n\nAn `opts_size`element was added in the  `spdk_nvme_ctrlr_opts` structure\nto solve the ABI compatibility issue between different SPDK version.\n\nA new API `spdk_nvme_ctrlr_cmd_abort_ext` has been added to abort previously submitted\ncommands whose callback argument match.\n\nConvenience functions, `spdk_nvme_print_command` and `spdk_nvme-print_completion` were added\nto the public API.\n\nA new function, `spdk_nvmf_cuse_update_namespaces`, updates the cuse representation of an NVMe\ncontroller.\n\nA new function `qpair_iterate_requests` has been added to the nvme transport interface. ALl\nimplementations of the transport interface will have to implement that function.\n\n### nvmf\n\nThe NVMe-oF target no longer supports connecting scheduling configuration and instead\nalways uses what was previously called \"transport\" scheduling.\n\n`spdk_nvmf_tgt_accept` no longer exists. The accept process now occurs automatically after\nthe creation of an nvmf target and queue pairs are assigned to poll groups by the underlying\ntransport. Further, `spdk_nvmf_transport_ops` has changed such that the accept function\npointer no longer takes a function pointer as an argument. Instead, transports should call\n`spdk_nvmf_tgt_new_qpair` whenever they previously would have called that callback.\n\nThe NVMe-oF target now supports aborting any submitted NVM or Admin command. Previously,\nthe NVMe-oF target could abort only Asynchronous Event Request commands.\n\n### rdma\n\nA new `rdma` library has been added. It is an abstraction layer over different RDMA providers.\nTwo providers are available - verbs (used by default when RDMA is enabled or enabled explicitly\nusing --with-rdma=verbs) and mlx5 Direct Verbs aka DV (enabled by --with-rdma=mlx5_dv).\nUsing mlx5_dv requires libmlx5 installed on the system.\n\n### rpc\n\nParameter `-p` or `--max-qpairs-per-ctrlr` of `nvmf_create_transport` RPC command accepted by the\nrpc.py script is deprecated, new parameter `-m` or `--max-io-qpairs-per-ctrlr` was added.\n\nAdded `sock_impl_get_options` and `sock_impl_set_options` RPC methods.\n\nCommand line parameters `-r` and `--rpc-socket` will longer accept TCP ports. RPC server\nmust now be started on a Unix domain socket. Exposing RPC on the network, as well as providing\nproper authentication (if needed) is now a responsibility of the user.\n\nThe `bdev_set_options` RPC has a new option, `bdev_auto_examine` to control the auto examine function\nof bdev modules.\n\nNew RPCs `sock_impl_get_options` and `sock_impl_set_options` been added to expose new socket features.\nSee `sock` section for more details.\n\n### sock\n\nAdded `spdk_sock_impl_get_opts` and `spdk_sock_impl_set_opts` functions to set/get socket layer configuration\noptions. Options can be set independently for each implementation.\n\nAdded `recv_buf_size` and 'send_buf_size' socket layer options. They are used only in posix implementation.\n\nAdded `uring` based socket implementation, the code is located in module/sock/uring. This feature is only\navailable in Linux which requires kernel version is greater than 5.4.3. Currently, our CI pool added the uring\nbased socket tests for iSCSI target and also the tests for SPDK NVMe-oF tcp transport.\n\nAdded `enable_recv_pipe` socket layer option to allow disabling of double buffering on receive.\nNew option is used only in posix implementation.\n\nAdded `enable_zerocopy_send` socket layer option to allow disabling of zero copy flow on send.\nNew option is used only in posix implementation.\n\n### util\n\nSome previously exposed CRC32 functions have been removed from the public API -\n`spdk_crc32_update`, `spdk_crc32_table_init`, and the `spdk_crc32_table` struct.\n\n### vhost\n\nThe function `spdk_vhost_blk_get_dev` has been removed.\n\n## v20.04: SPDK Top, IDXD, NVMe qpair groups\n\nIDXD engine support for compare has been added.\n\n### configuration\n\nLegacy INI style configuration for SPDK applications has been deprecated and will be\nremoved in future release.\nPlease switch to JSON-RPC configuration files and/or RPC driven run-time configuration.\n\n### copy\n\nThe copy engine library, modules and public APIs have been renamed. Use of the word `copy`\nhas been replaced with the word `accel` short for accelerator in preparation for adding new\ncapabilities in the future. Additionally, APIs for what was previously called the `memcpy`\nengine have been renamed to identify the engine as a software accelerator.\n\n### crypto\n\nSupport for AES_XTS was added for the QAT polled mode driver (pmd).  The create RPC\n`bdev_crypto_create` has 2 new optional parameters: cipher and key2. Cipher can be either\nAES_CBC (default) or AES_XTS. AES_XTS is only valid when using the QAT polled mode driver.\nThe key2 parameter is the second key required for AES_XTS.\n\n### event\n\nReactors now accumulate CPU stats and they are retrieved by the RPC `framework_get_reactors`.\n\n### idxd\n\nIDXD support was added in the form of a low level library that can directly\nutilize the IDXD offload engine as well as an accel plug-in module allowing for use\nwith the generic accel framework API. IDXD is the first in a family of offload\nengines that share the same interface, specifically DSA is added here. More info\ncan be found here: https://01.org/blogs/2019/introducing-intel-data-streaming-accelerator\n\nMuch of the implementation models IOAT, however the low level interfaces are very\ndifferent. The RPC to enable IDXD requires a configuration number as well. The\ncode includes two pre-defined configurations of IDXD groups/work queues/engines. A future\nversion will provide an interface to allow for setting of individual configuration\nparameters.\n\nIDXD is not yet available so this feature should be considered experimental. It will\nbe built up with additional documentation as an ongoing activity.\n\n### iscsi\n\nThe iSCSI target now creates a lightweight thread per poll group instead of assuming a pool\nof lightweight threads already exist at start up time. A poll group is a collection of\nunrelated iSCSI connections. Each poll group is only accessed from the associated\nlightweight thread.\n\n### ftl\n\nSeveral changes have been made to the `spdk_ftl_conf`, `spdk_ftl_dev_init_ops`, and\n`spdk_ftl_attrs` structs. Please see `include/spdk/ftl.h` for more details.\n\n### miscellaneous\n\nThe `--json-ignore-init-errors` command line parameter has been added to ignore\ninitialization errors on JSON config load.\n\nThe public header file io_channel.h has been removed. Please use thread.h which has the\nexact same API.\n\n### nvme\n\nExported internal nvme_ctrlr_cmd_security_receive/send() APIs as public APIs with \"the spdk_\"\nprefix.\n\nAdded `priority` field in `spdk_nvme_transport_id`, this field is used to specify the priority\nof the NVMe-oF connection, and currently it is used for NVMe-oF tcp connection.\n\nA new poll group API has been added to allow for pooling of nvme qpairs across a single\nentity which can be polled for completions. This new API consists of the `spdk_nvme_poll_group`\nfamily of functions. As a result of this new API, all NVMe transports are expected to implement\nseveral poll group related functions.\n\nA new flag, `create_only`, has been added to the `spdk_nvme_io_qpair_opts` structure. This flag\nallows a user to call `spdk_nvme_ctrlr_get_default_io_qpair` without also connecting the qpair\nwithin the context of that call.\n\nAs a result of the `create_only` flag, two new API functions, `spdk_nvme_ctrlr_connect_io_qpair`\nand `spdk_nvme_ctrlr_disconnect_io_qpair`, have been added to facilitate connecting newly created\nqpairs (for example, after they have been added to a poll group) and disconnecting qpairs without\ndestroying them (for example to disconnect a qpair before migrating it to a new poll group and\nreconnecting it).\n\nThe functions `spdk_nvme_ctrlr_alloc_cmb_io_buffer` and `spdk_nvme_ctrlr_free_cmb_io_buffer`\nhave been changed to `spdk_nvme_ctrlr_map_cmb` and `spdk_nvme_ctrlr_unmap_cmb` respectively.\n\nAn additional function, `spdk_nvme_ctrlr_reserve_cmb`, has been added to facilitate reserving\nthe entire size of the controller memory buffer for data transfer.\n\n### nvme_cuse\n\n`spdk_nvme_cuse_get_ctrlr_name` now takes two additional parameters, `char *name` which\nstores the pointer to the controller name, and `size_t *size` which stores the length of\nthe name. The return type has also been changed from char * to int.\n\n`spdk_nvme_cuse_get_ns_name` now takes two additional parameters, `char *name` which\nstores the pointer to the namespace name, and `size_t *size` which stores the length of\nthe name. The return type has also been changed from char * to int.\n\n### nvme_opal\n\nSeveral public OPAL structure definitions have been changed since the last release.\n\n### nvmf\n\n`spdk_nvmf_poll_group_destroy()` is now asynchronous and accepts a completion callback.\n\nThe NVMe-oF target now creates a lightweight thread per poll group instead of assuming a pool\nof lightweight threads already exist at start up time. A poll group is a collection of\nunrelated NVMe-oF connections. Each poll group is only accessed from the associated\nlightweight thread.\n\nA new struct, `spdk_nvmf_subsystem_listener`, has been added to encapsulate the subsystem specific\nnature of a listener object.\n\n`spdk_nvmf_tgt_listen` no longer accepts a callback function or argument. It also returns an\nint to indicate the status of the listen call.\n\nThe execution of `spdk_nvme_poll_group_destroy` is now asynchronous and the function accepts\na cb_fn and cb_arg to call upon completion.\n\nThe execution of `spdk_nvmf_subsystem_add_listener` is now asynchronous and the function accepts\na cb_fn and cb_arg to call upon completion.\n\nThe `nvmf_transport.h` header has been made public to allow custom NVMe-oF transports to integrate\nwith NVMe-oF libraries without using internal APIs.\n\n### ocf\n\nUpdated the OCF submodule to OCF v20.03\n\nNew version of OCF comes with API changes and bug fixes\n\n### rpc\n\nA new RPC `thread_set_cpumask` has been added to set the cpumask of the thread\nto the specified value.\n\nA new RPC `thread_get_pollers` has been added to retrieve pollers from SPDK threads.\n\nA new RPC `thread_get_io_channels` has been added to retrieve I/O channels from SPDK threads.\n\nA new RPC `bdev_rbd_resize` has been added to resize Ceph RBD bdevs.\n\n### sock\n\nThe `spdk_sock_set_priority` function has been removed since the feature to set the sock priority\nwill be contained in two new functions, i.e., `spdk_sock_listen_ext` and `spdk_sock_connect_ext`.\nUsers may now specify the priority of the socket in the opts that they want to use.\n\n### spdk_top\n\nA new application, `spdk_top`, has been added which allows users to monitor resource consumption\nby a running SPDK application. More information on this application can be found in\n`app/spdk_top/README`.\n\n### thread\n\nA new function `spdk_thread_lib_init_ext` has been added, and the function\n`spdk_thread_lib_init` has been deprecated. The user of `spdk_thread_lib_init_ext` is\nexpected to implement both functions `spdk_thread_op_fn` and `spdk_thread_op_supported_fn`.\n`spdk_thread_op_supported_fn` is called to check whether the SPDK thread operation\nis supported. `spdk_thread_op_fn` is called to execute the SPDK thread operation.\nCurrent SPDK operation types are `SPDK_THREAD_OP_NEW` and `SPDK_THREAD_OP_RESCHED`.\nThe operation `SPDK_THREAD_OP_NEW` is called each time a new thread is created.\nThe operation `SPDK_THREAD_OP_RESCHED` is called when SPDK thread needs to be rescheduled.\n\nA unique ID has been added for each created SPDK thread, it is retrieved by a new function\n`spdk_thread_get_id`, and the SPDK thread which has the specific ID is got by\na new function `spdk_thread_get_by_id`.\n\nA new function `spdk_thread_cpumask` has been added to set the current thread's cpumask\nto the specified value. The function requires the operation `SPDK_THREAD_OP_RESCHED`\nis supported.\n\nA new function `spdk_poller_register_named` has been added to set arbitrary name to the\ncreated poller. If NULL, the name is set to the pointer of the poller function.\n\nThe function `spdk_thread_poll` now measures run time per call correctly on multiple SPDK\nthreads configuration, and a new function `spdk_thread_get_last_tsc` has been added to use together.\n\nVoluntary termination of SPDK thread has been supported by refining the functions `spdk_thread_exit`\nand `spdk_thread_poll`.\n\n### util\n\nNew functions `spdk_sn32_lt` and `spdk_sn32_gt` have been added. They compare two sequence\nnumbers based on serial number arithmetic.\n\n### vhost\n\nPoll groups per session have been replaced by SPDK threads per vhost controller.\n\n### vmd\n\nA new function, `spdk_vmd_fini`, has been added. It releases all resources acquired by the VMD\nlibrary through the `spdk_vmd_init` call.\n\n## v20.01: Optimized thin provisioning, FTL bdev, VMD hot plug, FUSED support\n\n### bdev\n\nA new function, `spdk_bdev_set_timeout`, has been added to set per descriptor I/O timeouts.\n\nA new class of functions `spdk_bdev_compare*`, have been added to allow native bdev support\nof block comparisons and compare-and-write.\n\nA new class of bdev events, `SPDK_BDEV_EVENT_MEDIA_MANAGEMENT`, has been added to allow bdevs\nwhich expose raw media to alert all I/O channels of pending media management events.\n\nA new API was added `spdk_bdev_io_get_aux_buf` allowing the caller to request\nan auxiliary buffer for its own private use. The API is used in the same manner that\n`spdk_bdev_io_get_buf` is used and the length of the buffer is always the same as the\nbdev_io primary buffer. 'spdk_bdev_io_put_aux_buf' frees the allocated auxiliary\nbuffer.\n\n### blobfs\n\nAdded boolean return value for function spdk_fs_set_cache_size to indicate its operation result.\n\nAdded `blobfs_set_cache_size` RPC method to set cache size for blobstore filesystem.\n\n### blobstore\n\nAdded new `use_extent_table` option to `spdk_blob_opts` for creating blobs with Extent Table descriptor.\nUsing this metadata format, dramatically decreases number of writes required to persist each cluster allocation\nfor thin provisioned blobs. Extent Table descriptor is enabled by default.\nSee the [Blobstore Programmer's Guide](https://spdk.io/doc/blob.html#blob_pg_cluster_layout) for more details.\n\n### dpdk\n\nUpdated DPDK submodule to DPDK 19.11.\n\n### env_dpdk\n\n`spdk_env_dpdk_post_init` now takes a boolean, `legacy_mem`, as an argument.\n\nA new function, `spdk_env_dpdk_dump_mem_stats`, prints information about the memory consumed by DPDK to a file specified by\nthe user. A new utility, `scripts/dpdk_mem_info.py`, wraps this function and prints the output in an easy to read way.\n\n### event\n\nThe functions `spdk_reactor_enable_framework_monitor_context_switch()` and\n`spdk_reactor_framework_monitor_context_switch_enabled()` have been changed to\n`spdk_framework_enable_context_switch_monitor()` and\n`spdk_framework_context_switch_monitor_enabled()`, respectively.\n\n### ftl\n\nAll NVMe dependencies were removed from ftl library.\nFrom now ftl library is using bdev_zone API.\nbdev_ftl becomes virtual bdev.\n\n`ctrlr` and `trid` fields in `spdk_ftl_dev_init_opts` structure  were replaced by\n`base_bdev_desc`.\n\n`bdev_ftl_create` RPC method `trtype` and `traddr` parameters were replaced by `base_bdev`\nparameter.\n\n`spdk_ftl_module_init` and `spdk_ftl_module_fini` functions were removed.\n\n`spdk_ftl_punit_range` and `ftl_module_init_opts` structures were removed.\n\n### isa-l\n\nUpdated ISA-L submodule to commit f3993f5c0b6911 which includes implementation and\noptimization for aarch64.\n\nEnabled ISA-L on aarch64 by default in addition to x86.\n\n### nvme\n\n`delayed_pcie_doorbell` parameter in `spdk_nvme_io_qpair_opts` was renamed to `delay_cmd_submit`\nto allow reuse in other transports.\n\nAdded RDMA WR batching to NVMf RDMA initiator. Send and receive WRs are chained together\nand posted with a single call to ibv_post_send(receive) in the next call to qpair completion\nprocessing function. Batching is controlled by 'delay_cmd_submit' qpair option.\n\nThe NVMe-oF initiator now supports plugging out of tree NVMe-oF transports. In order\nto facilitate this feature, several small API changes have been made:\n\nThe `spdk_nvme_transport_id` struct now contains a trstring member used to identify the transport.\nA new function, `spdk_nvme_transport_available_by_name`, has been added.\nA function table, `spdk_nvme_transport_ops`, and macro, `SPDK_NVME_TRANSPORT_REGISTER`, have been added which\nenable registering out of tree transports.\n\nA new function, `spdk_nvme_ns_supports_compare`, allows a user to check whether a given namespace supports the compare\noperation.\n\nA new family of functions, `spdk_nvme_ns_compare*`, give the user access to submitting compare commands to NVMe namespaces.\n\nA new function, `spdk_nvme_ctrlr_cmd_get_log_page_ext`, gives users more granular control over the command dwords sent in\nlog page requests.\n\n### nvmf\n\nAdd SockPriority option in [Transport] section, this can be used for NVMe-oF target\non TCP transport to set sock priority for the incoming TCP connections.\n\nThe NVMe-oF target now supports plugging out of tree NVMe-oF transports. In order\nto facilitate this feature, several small API changes have been made:\n\nThe `spdk_nvme_transport_id` struct now contains a trstring member used to identify the transport.\n`spdk_nvmf_tgt_get_transport`, `spdk_nvmf_transport_opts_init`, and `spdk_nvmf_transport_create` all have been\nmodified to take a string.\nA function table, `spdk_nvmf_transport_ops`, and macro, `SPDK_NVMF_TRANSPORT_REGISTER`, have been added which\nenable registering out of tree transports.\n\nAdd `spdk_nvmf_tgt_stop_listen()` that can be used to stop listening for\nincoming connections for specified target and trid. Listener is not stopped\nimplicitly upon destruction of a subsystem any more.\n\nA custom NVMe admin command handler has been added which allows the user to use the real drive\nattributes from one of the target NVMe drives when reporting drive attributes to the initiator.\nThis handler can be enabled via the `nvmf_set_config` RPC.\nNote: In a future version of SPDK, this handler will be enabled by default.\n\nThe SPDK target and initiator both now include compare-and-write functionality with one caveat. If using the RDMA transport,\nthe target expects the initiator to send both the compare command and write command either with, or without inline data. The\nSPDK initiator currently respects this requirement, but this note is included as a flag for other initiators attempting\ncompatibility with this version of SPDK.\n\nThe `spdk_nvme_ctrlr_opts` struct has been extended with new field `transport_ack_timeout` which allows\nto configure transport ACK timeout. Applicable for RDMA transport only.\n\n### rpc\n\nA new RPC, `bdev_zone_block_create`, enables creating an emulated zoned bdev on top of a standard block device.\n\nA new RPC, `bdev_ocssd_create`, enables creating an emulated zoned bdev on top of an Open Channel SSD.\n\nA new RPC, `blobfs_set_cache_size`, enables managing blobfs cache size.\n\nA new RPC, `env_dpdk_get_mem_stats`, has been added to facilitate reading DPDK related memory\nconsumption stats. Please see the env_dpdk section above for more details.\n\nA new RPC, `framework_get_reactors`, has been added to retrieve a list of all reactors.\n\n`bdev_ftl_create` now takes a `base_bdev` argument in lieu of `trtype`, `traddr`, and `punits`.\n\n`bdev_nvme_set_options` now allows users to disable I/O submission batching with the `-d` flag\n\n`bdev_nvme_cuse_register` now accepts a `name` parameter.\n\n`bdev_uring_create` now takes arguments for `bdev_name` and `block_size`\n\n`nvmf_set_config` now takes an argument to enable passthru of identify commands to base NVMe devices.\nPlease see the nvmf section above for more details.\n\n### scsi\n\n`spdk_scsi_lun_get_dif_ctx` now takes an additional argument of type `spdk_scsi_task`.\n\n### sock\n\nAdded spdk_sock_writev_async for performing asynchronous writes to sockets. This call will\nnever return EAGAIN, instead queueing internally until the data has all been sent. This can\nsimplify many code flows that create pollers to continue attempting to flush writes\non sockets.\n\nAdded `impl_name` parameter in spdk_sock_listen and spdk_sock_connect functions. Users may now\nspecify the sock layer implementation they'd prefer to use. Valid implementations are currently\n\"vpp\" and \"posix\" and NULL, where NULL results in the previous behavior of the functions.\n\n### thread\n\n`spdk_thread_send_msg` now returns int indicating if the message was successfully\nsent.\n\nA new function `spdk_thread_send_critical_msg`, has been added to support sending a single message from\na context that may be interrupted, e.g. a signal handler.\n\nTwo new functions, `spdk_poller_pause`, and `spdk_poller_resume`, have been added to give greater control\nof pollers to the application owner.\n\n### util\n\n`spdk_pipe`, a new utility for buffering data from sockets or files for parsing\nhas been added. The public API is available at `include/spdk/pipe.h`.\n\n### bdev\n\nAdded spdk_bdev_io_get_nvme_fused_status function for translating bdev_io status to NVMe status\ncode for fused compare-and-write operation.\n\nAdded spdk_bdev_get_acwu function for getting block device atomic compare and write unit size.\n\n## v19.10: Zoned bdev API, Opal bdev, NVMe character devices\n\n### rpc\n\nMany of SPDK's RPCs were renamed to be more consistent and intuitive in this release.\nThe old names will continue to function, but will display a deprecation warning.\n\nAdded optional parameters '--arbitration-burst' and '--low/medium/high-priority-weight' to\n'bdev_nvme_set_options' RPC method.\n\nAdded optional parameter '--md-size' to 'construct_null_bdev' RPC method.\n\nAdded optional parameters '--dif-type' and '--dif-is-head-of-md' to 'construct_null_bdev'\nRPC method.\n\nAdded `blobfs_detect` RPC method to detect whether a blobfs exists on given bdev.\n\nAdded `blobfs_create` RPC method to build blobfs on given bdev.\n\nAdded `blobfs_mount` RPC method to mount blobfs on given bdev to a host path by FUSE.\nThen on the host path, user can directly do some file operations which will be mapped\nto blobfs.\n\n### bdev\n\nAdded new parameter `cdw0` to `spdk_bdev_io_complete_nvme_status()` and\n`spdk_bdev_io_get_nvme_status()` that allows setting/getting\nthe NVMe completion queue DW0 entry. This allows vendor specific IO commands\nto return command specific completion info back to the initiator.\n\nAdded `spdk_bdev_get_write_unit_size()` function for retrieving required number\nof logical blocks for write operation.\n\nNew zone-related fields were added to the result of the `get_bdevs` RPC call:\n\n- `zoned`: indicates whether the device is zoned or a regular\n  block device\n- `zone_size`: number of blocks in a single zone\n- `max_open_zones`: maximum number of open zones\n- `optimal_open_zones`: optimal number of open zones\n\nThe `zoned` field is a boolean and is always present, while the rest is only available for zoned\nbdevs.\n\nA new `spdk_bdev_open_ext` function has been added and `spdk_bdev_open` function has been deprecated.\nThe new open function introduces requirement to provide callback function that will be called by\nasynchronous event such as bdev removal. `spdk_bdev_open_ext` function takes bdev name as\nan argument instead of bdev structure to avoid a race condition that can happen when the bdev\nis being removed between a call to get its structure based on a name and actually opening it.\n\nNew 'resize' event has been added to notify about change of block count property of block device.\nEvent is delivered only if block device was opened with `spdk_bdev_open_ext` function.\n\n### bdev zone\n\nAdded new public header for zoned bdev. Zoned bdev is an extension\nof the bdev interface.\n\n`spdk_bdev_get_zone_size()`, `spdk_bdev_get_max_open_zones()`, `spdk_bdev_get_optimal_open_zones()`\nAPIs were added for retrieving zoned device information.\n`spdk_bdev_get_zone_info()` API was added for retrieving information about zones in zoned\ndevice.\nAdded `spdk_bdev_zone_management()` API for changing zone state.\n`spdk_bdev_zone_append()` and `spdk_bdev_zone_append_with_md()` APIs were added for\nappending data to a zone.\nAdded `spdk_bdev_io_get_append location()` function for retrieving append location for I/O.\nAdded `spdk_bdev_is_zoned()` function for checking if bdev supports zoned namespace semantics.\n\n### bdev opal\n\nEXPERIMENTAL: A new opal bdev has been added to support management of\nNVMe self-encrypting drives through the Opal specification. Users can\ncreate opal bdevs from an NVMe namespace bdev, if the controller\ncontaining that namespace supports Opal. Currently this is only\nsupported for namespace ID=1. The following RPCs have been added to\nsupport Opal: `bdev_nvme_opal_init`, `bdev_nvme_opal_revert`,\n`bdev_opal_create`, `bdev_opal_delete`, `bdev_opal_get_info`,\n`bdev_opal_new_user`, `bdev_opal_set_lock_state`.\nIt does not yet support recreating the opal bdevs after application restart.\nThis bdev module should be considered very experimental, and the RPCs may\nchange significantly in future releases.\n\n### delay bdev\n\nThe `bdev_delay_update_latency` has been added to allow users to update\na latency value for a given delay bdev.\n\n### compress bdev\n\nA new RPC `bdev_compress_get_orphans` has been added to list compress bdevs\nthat were not loaded due to a missing pm metadata file. In this state they\ncan only be deleted.\n\n### null bdev\n\nMetadata support has been added to Null bdev module.\n\nProtection information support has been added to Null bdev module.\n\n### nvme\n\nAdded `no_shn_notification` to NVMe controller initialization options, users can enable\nit for NVMe controllers.  When the option is enabled, the controller will not do the\nshutdown process and just disable the controller, users can start their application\nlater again to initialize the controller to the ready state.\n\nA controller flag `SPDK_NVME_CTRLR_WRR_SUPPORTED` was added to indicate the controller\ncan support weighted round robin arbitration feature with submission queue.\n\nAdded `arbitration_burst` option for arbitration feature, and added three\n`low/medium/high_priority_weight` options for weighted round robin arbitration.\n\nAdded `spdk_nvme_ns_cmd_write_uncorrectable`.\n\nAdded new error handling and reporting functionality. This includes several\nnew API functions to facilitate applications recovering when a qpair or\ncontroller fails.\n\n`spdk_nvme_ctrlr_reconnect_io_qpair` - Reconnects a failed I/O qpair.\n`spdk_nvme_ctrlr_set_trid` - Sets the trid of an existing controller. Can be used to\nchange the trid for failover cases.\n`spdk_nvme_ctrlr_is_failed` - Returns the failed state of a controller.\n`spdk_nvme_ctrlr_fail` - Forces a controller into a failed state.\n\nModified the return behavior of several API functions to better indicate to\napplications when a qpair is failed. This list of functions includes:\n\n`spdk_nvme_qpair_process_completions`\n`spdk_nvme_ns_cmd_*`\n`spdk_nvme_ctrlr_process_admin_completions`\n`spdk_nvme_ctrlr_cmd_*`\n\nThese functions now return -ENXIO when the qpair or controller on which they\noperate is failed.\n\nEXPERIMENTAL: Added NVMe character device support to allow to create NVMe device nodes in Linux\nkernel for controller as well as for namespace and process ioctl requests as usual\nfrom linux environment.\n\n### nvmf\n\nThe `spdk_nvmf_tgt_create` function now accepts an object of type `spdk_nvmf_target_opts`\nas its only parameter. This new structure contains the max_subsystems parameter previously\npassed into that function.\n\nA new public API function `spdk_nvmf_get_tgt` has been added which allows users to\nretrieve a pointer to an `spdk_nvmf_tgt` object by supplying its name. In the special\ncase where an RPC or application only creates a single target, this function can accept\na null name parameter and will return the only available target.\n\nThe majority of the NVMe-oF RPCs now accept an optional tgt_name parameter. This will\nallow those RPCs to work with applications that create more than one target.\n\nThree new NVMe-oF RPCs have been added `nvmf_create_target`, `nvmf_delete_target`, and\n`nvmf_get_targets`. These new RPCs provide a basic interface for managing multiple target\nobjects. In SPDK the target object defines a unique discovery service. As of this release,\nthese RPCs are not intended to be used with the in-tree SPDK target applications, spdk_tgt and\nnvmf_tgt, which use a single, global target structure. As such, they are not included in scripts/rpc.py\n\nThree new header functions have also been added to help deal with multiple targets.\n`spdk_nvmf_tgt_get_name` takes a target pointer as an argument and returns its human readable name.\n`spdk_nvmf_get_first_target` takes no arguments and returns the first target in the global list.\n`spdk_nvmf_get_next_tgt` takes a target pointer as an argument and returns the next one in the global list.\n\nThe `spdk_nvmf_tgt_accept` takes additional argument allowing to pass arbitrary context\ninformation to the `new_qpair` callback. This will simplify the code when having multiple\nnvmf targets or when retrieving the context information from globals is not suitable.\n\n### blobstore\n\nA new `spdk_bdev_create_bs_dev_from_desc` function has been added and `spdk_bdev_create_bs_dev`\nfunction has been deprecated.\nThe new create function can cowork with `spdk_bdev_open_ext` function, which provides callback\nfunction that will be called by asynchronous event such as bdev removal.\n\n### blobfs_bdev\n\nA new blobfs module `bdev` has been added to simplify the operations of blobfs on bdev.\n\nFunction `spdk_blobfs_bdev_detect` is added to detect whether blobfs exists on the given block device.\n\nFunction `spdk_blobfs_bdev_create` is added to create a blobfs on the given block device.\n\nFunction `spdk_blobfs_bdev_mount` is added to mount a blobfs on the given block device to\na host path by FUSE. Then, a new thread is created dedicatedly for one mountpoint to handle\nFUSE request by blobfs API.\n\n### build\n\nOption to build FUSE components into blobfs_bdev module for mounting a blobfs filesystem.\nIt requires the installation of libfuse3. By default, it is disabled. And it will be\nenabled if run `./configure` with `--with-fuse` option.\n\n### iSCSI\n\nPortals may no longer be associated with a cpumask. The scheduling of\nconnections is moving to a more dynamic model.\n\nAn new RPC `iscsi_portal_group_set_auth` has been added to set CHAP authentication\nfor discovery sessions specific for the existing iSCSI portal group. This RPC overwrites\nthe setting by the global parameters for the iSCSI portal group.\n\n### socket\n\nAdded `spdk_sock_is_connected` to check whether the socket is currently connected.\n`spdk_sock_group_poll` now returns number of events on success.\n\n### env\n\nAdded `spdk_pci_device_unclaim()` function to cleanup pci claim file.\n\n### event\n\n`framework_start_init` RPC no longer stops the application on error during\ninitialization.\n\n### DPDK\n\nUpdated DPDK submodule to DPDK 19.08.\n\n### ocf\n\nUpdated OCF submodule to OCF v19.06\n\nAlong with update, new cache mode 'write only' was added.\n\nNew cache modes added to use via RPC, wi - write invalidate and wa - write around.\n\nNew version of OCF provides fully asynchronous management API.\n\n## v19.07: NVMe-oF FC Transport, VMD, NVMe-oF Persistent reservations, Bdev I/O with separate metadata\n\n### ftl\n\nEXPERIMENTAL: Added ability to mirror writes to persistent write buffer cache\nto allow for recovery from dirty shutdown event.\n\nAdded handling of Asynchronous Nand Management Events (ANM).\n\n### vmd\n\nEXPERIMENTAL: Added Intel Volume Management Device (VMD) driver. VMD is an integrated\ncontroller inside the CPU PCIe root complex. It enables virtual HBAs for the connected\nNVMe SSDs. `spdk_vmd_init()` enumerates NVMe SSDs behind VMD device and hook them into\nSPDK PCI subsystem. `spdk_nvme_probe()` or `spdk_nvme_connect()` can be used to connect\nNVMe driver to the device located at the given transport ID.\n\nTo obtain transport ID of NVMe SSD behind VMD `spdk_lspci` can be used.\n\nCurrent implementation does not support hotplug.\n\n### blobfs\n\nBlobfs file asynchronous operations were added to public APIs.\n\n### util\n\nA new file API `spdk_posix_file_load` was added to load file content into a data buffer.\n\nNew APIs `spdk_dif_ctx_set_data_offset`, `spdk_dif_verify_stream`,\n`spdk_dif_get_range_with_md`, `spdk_dif_get_length_with_md` have been added,\nand existing APIs `spdk_dif_ctx_init`, `spdk_dif_set_md_interleave_iovs`, and\n`spdk_dif_generate_stream` have been refined to insert or strip DIF into iovs\nwindows of any alignment.\n\nNew APIs `spdk_dif_ctx_set_remapped_init_ref_tag`, `spdk_dif_remap_ref_tag`,\nand `spdk_dix_remap_ref_tag` have been added to remap DIF reference tag.\n\nNew APIs `spdk_dif_update_crc32c` and `spdk_dif_update_crc32c_stream` have been\nadded to compute CRC-32C checksum for extended LBA payload.\n\nBdevperf and bdevio applications now support starting tests with application specific\nRPCs. Please see helper Python scripts in their respective directories.\nThis is a move towards simpler RPC-only configuration for all main\nand auxiliary applications.\n\nLegacy INI style configuration for SPDK applications will become deprecated in SPDK 19.10,\nand removed in SPDK 20.01. Please consider moving to JSON-RPC configuration files and/or\nRPC driven run-time configuration.\n\n### nvmf\n\nEXPERIMENTAL: A Fibre Channel transport that supports Broadcom HBAs has been\nadded. This depends on the FC HBA driver at\nhttps://github.com/ecdufcdrvr/bcmufctdrvr. See [the documentation](https://spdk.io/doc/nvmf.html#nvmf_fc_transport)\nfor more information.\n\nPersistent reservation emulation has been added to the NVMe-oF target. Persistent reservation\nstate is stored in a JSON file on the local filesystem between target restart. To support this,\nan optional parameter to the RPC method `nvmf_subsystem_add_ns` called `--ptpl-file` was added.\nThis allows the user to specify which file to store the persistent reservation state in.  Note\nthat this is done per namespace.\n\nThe c2h success optimization under which a command capsule response is not sent\nfor reads is turned on by default. A config knob was added to allow disabling\nthe optimization. This will mostly be used for integration testing with 5.0.x kernels\nwhile some compatibility fixes make their way down the pipeline for 5.1.x kernels.\n\nThe sock priority setting of the TCP connection owned by the tcp transport is added. It is\nused to optimize the TCP connection performance under designated traffic classes. And the\npriority is used to differentiate the sock priority between SPDK NVMe-oF TCP target application\nand other TCP based applications.\n\nShared receive queue can now be disabled even for NICs that support it using the\n`nvmf_create_transport` RPC method parameter `no_srq`. The actual use of a shared\nreceive queue is predicated on hardware support when this flag is not used.\n\nspdk_nvmf_get_optimal_poll_group was added, which is used to return the optimal\npoll group for the qpair. And `ConnectionScheduler` configuration is added into the\n[Nvmf] section in etc/spdk/nvmf.conf.in to demonstrate how to configure the connection\nscheduling strategy among different spdk threads.\n\nAdded infrastructure to retrieve global and per poll group NVMf statistics.\n\nDIF strip and insert is now supported for TCP transport. When it is enabled, DIF\nsetting is not exposed to the NVMe-oF initiator, and DIF is attached into data\nfor write I/O and stripped from data for read I/O.\n\nAdded a field `dif_insert_or_strip` to struct spdk_nvmf_transport_opts, and\nupdated the related rpc function nvmf_create_transport to make this\nconfigurable parameter available to users. The `dif_insert_or_strip` is relevant\nfor TCP transport for now and used to configure the DIF strip and insert.\n\nAdded infrastructure to retrieve NVMf transport statistics.\n\n### notify\n\nThe function `spdk_notify_get_types()` and `spdk_notify_get_events()` were\nrenamed to `spdk_notify_foreach_type()` and `spdk_notify_foreach_event()`,\nrespectively. And update type name of callback accordingly.\n\n### bdev\n\nThe format of the data returned by the get_bdevs_iostat RPC has changed to\nmake it easier to parse.  It now returns an object with a \"ticks\" object\nand \"bdevs\" array with the per-bdev statistics.\n\nA new bdev module `delay` has been added which simulates a drive latency when placed\non top of a Null bdev. This module is intended only for testing and can be created using\nthe new RPC `bdev_delay_create`. That RPC takes the name of the underlying bdev as well\nas average and p99 latency arguments for both read and write operations. Average latency is\ndefined as a value close to what you would expect a perf tool such as FIO to report back as\nthe mean latency of all I/O submitted to the drive. p99 latency is defined as the value one\nwould expect the drive to see the slowest 1% of I/O report. For underlying drives with already\nsignificant latency, the latency values provided to the drive will be additive. This should be\ntaken into account if trying to achieve an artificial latency on top of an nvme drive or aio device.\n\nDIF reference tag remapping is now supported for partition type virtual bdev\nmodules. When using partition type virtual bdevs, block address space is\nremapped during I/O processing and DIF reference tag is remapped accordingly.\n\nAdded spdk_bdev_*_with_md() functions allowing for IO with metadata being transferred in\nseparate buffer. To check support for separate metadata, use spdk_bdev_is_md_separate().\n\nAll bdevs now have a UUID. For devices whose backing hardware does not provide a UUID,\none is automatically generated. Across runs of SPDK, bdevs whose UUID is automatically\ngenerated may change.\n\nA new virtual bdev module `compress` has been added to provide compression services on top of\na thinly provisioned logical volume.  See documentation for complete details.\n\n### nvme\n\nAdded an optional parameter `--io-queue-requests` to RPC `set_bdev_nvme_options`, which\ncan be used to change the number of requests allocated for one NVMe I/O queue.  For\nvery big I/O size, e.g. 128MiB, with this option user will not get an error due to\nlimited requests in NVMe driver layer.\n\nAdded spdk_nvme_ctrlr_get_transport_id() to get the transport ID from a\npreviously attached controller.\n\nNvme Opal library spdk_opal_cmd deprecated. Adding separate command APIs.\nNVMe Opal library add support for activating locking SP which will make the transaction\nfrom \"Manufactured-Inactive\" state to \"Manufactured\" state. Upon successfully invoking\nof this method, lock and unlock features will be enabled.\nNVMe Opal library add support for locking/unlocking range and list locking range info.\nNVMe opal library add support for multiuser. Admin can enable user and add user to specific\nlocking range and the user can lock/unlock his range.\n\nAdded spdk_nvme_ctrlr_io_cmd_raw_no_payload_build() allowing a caller to pass\na completely formed command to an NVMe submission queue (buffer addresses and all).\nThis is supported on the PCIe transport only.\n\nAdded spdk_nvme_get_ctrlr_registers() to return a pointer to the virtual address\nof the NVMe controller registers.  This is supported on the PCIe transport only.\n\nAdded additional options to the spdk_nvme_ctrlr_alloc_qpair() option parameter\nstructure to allow caller to override the virtual and optionally physical address\nof the submission and completion queue pair to be created.  This is supported on\nthe PCIe transport only.\n\nAdded `disable_error_logging` to struct spdk_nvme_ctrlr_opts, which disables\nlogging of failed requests. By default logging is enabled.\n\nAdded spdk_nvme_qpair_print_command(), spdk_nvme_qpair_print_completion() and\nspdk_nvme_cpl_get_status_string(). Allowing for easier display of error messages.\n\nAdded support for NVMe Sanitize command.\n\n### env\n\nThe parameter `free_space` has been added to spdk_ring_enqueue() to wait when\nthe ring is almost full and resume when there is enough space available in\nthe ring.\n\nA new API `spdk_mempool_lookup` has been added to lookup the memory pool created\nby the primary process.\n\nAdded spdk_pci_get_first_device() and spdk_pci_get_next_device() to allow\niterating over PCI devices detected by SPDK. Because of this, all SPDK APIs\nto attach/detach PCI devices are no longer thread safe. They are now meant to\nbe called from only a single thread only, the same only that called spdk_env_init().\nThis applies to the newly added APIs as well.\n\n### vpp\n\nSPDK now supports VPP version 19.04.2, up from VPP 18.01.\n\nVPP socket abstraction now uses VPP Session API, instead of VLC (VPP Communications Library).\nThis allows for better control over sessions and queues.\nPlease see VPP documentation for more details:\n[VPP Host Stack](https://wiki.fd.io/view/VPP/HostStack)\n\n### sock\n\nAdd spdk_sock_get_optimal_sock_group(), which returns the optimal sock group for\nthis socket. When a socket is created, it is often assigned to a sock group using\nspdk_sock_group_add_sock so that a set of sockets can be polled more efficiently.\nFor some network devices, it is optimal to assign particular sockets to specific\nsock groups. This API is intended to provide the user with that information.\n\nspdk_sock_group_get_ctx() was added to return the context of the spdk_sock_group.\nspdk_sock_group_create() is updated to allow input the user provided ctx.\nspdk_sock_set_priority() is added to set the priority of the socket.\n\n### rpc\n\nAdded thread_get_stats RPC method to retrieve existing statistics.\n\nAdded nvmf_get_stats RPC method to retrieve NVMf subsystem statistics.\n\nResponse buffers for RPC requests are now always pre-allocated, which implies\nthat all spdk_jsonrpc_begin_result() calls always succeed and return a valid\nbuffer for JSON response. RPC calls no longer need to check if the buffer is\nnon-NULL.\n\nAdded SPDK_RPC_REGISTER_ALIAS_DEPRECATED to help with deprecation process when\nrenaming existing RPC. First time a deprecated alias is used, it will print\na warning message.\n\nRPC `get_rpc_methods` was renamed `rpc_get_methods`. The old name is still usable,\nbut is now deprecated.\n\n### blobstore\n\nA snapshot can now be deleted if there is only a single clone on top of it.\n\n### build\n\nPreliminary support for cross compilation is now available. Targeting an older\nCPU on the same architecture using your native compiler can be accomplished by\nusing the `--target-arch` option to `configure` as follows:\n\n~~~bash\n./configure --target-arch=broadwell\n~~~\n\nAdditionally, some support for cross-compiling to other architectures has been\nadded via the `--cross-prefix` argument to `configure`. To cross-compile, set CC\nand CXX to the cross compilers, then run configure as follows:\n\n~~~bash\n./configure --target-arch=aarm64 --cross-prefix=aarch64-linux-gnu\n~~~\n\n### vhost\n\nA security vulnerability has been identified and fixed in SPDK Vhost-SCSI target.\nA malicious client (e.g. a virtual machine) could send a carefully prepared,\ninvalid I/O request to crash the entire SPDK process. All users of SPDK Vhost-SCSI\ntarget are strongly recommended to update. All SPDK versions < 19.07 are affected.\n\nBy default, SPDK will now rely on upstream DPDK's rte_vhost instead of its fork\nlocated inside SPDK repo. The internal fork is still kept around to support older\nDPDK versions, but is considered legacy and will be eventually removed.\n\n`configure` will now automatically use the upstream rte_vhost if the used DPDK\nversion is >= 19.05.\n\nspdk_vhost_init() is now asynchronous and accepts a completion callback.\n\n### iscsi target\n\nA security vulnerability has been identified and fixed in SPDK iSCSI target.\nA malicious client (e.g. an iSCSI initiator) could send a carefully prepared,\ninvalid I/O request to crash the entire SPDK process. All users of SPDK iSCSI\ntarget are strongly recommended to update. All SPDK versions < 19.07 are affected.\n\n### thread\n\nExposed spdk_set_thread() in order for applications to associate\nwith SPDK thread when necessary.\n\nAdded spdk_thread_destroy() to allow framework polling the thread to\nrelease resources associated with that thread.\n\n## v19.04: Compression bdev, Notification library, NVMe Opal support\n\n### nvme\n\nAdded asynchronous probe support. New APIs spdk_nvme_probe_async(),\nspdk_nvme_connect_async() and spdk_nvme_probe_poll_async() were added to enable\nthis feature. spdk_nvme_probe_async() and spdk_nvme_connect_async() return a\ncontext associated with the specified controllers. Users then call\nspdk_nvme_probe_poll_async() until it returns 0, indicating that the operation\ncompleted.\n\nA new qpair creation option, delay_pcie_doorbell, was added. This can be passed\nto spdk_nvme_alloc_io_qpair(). This makes the I/O submission functions, such as\nspdk_nvme_ns_writev(), skip ringing the submission queue doorbell. Instead the\ndoorbell will be rung as necessary inside spdk_nvme_qpair_process_completions().\nThis can result in significantly fewer MMIO writes to the doorbell register\nunder heavy load, greatly improving performance.\n\nspdk_nvme_ctrlr_get_regs_cmbsz() was added to report the size of the controller\nmemory buffer, if available.\n\nspdk_nvme_ctrlr_get_flags() was added to return controller feature\nflags. Two flags are currently tracked:\nSPDK_NVME_CTRLR_SGL_SUPPORTED\nSPDK_NVME_CTRLR_SECURITY_SEND_RECV_SUPPORTED\n\nThe NVMe hotplug poller is now able to detach devices hot-removed from the system\nvia `/sys/bus/pci/devices/<bdf>/remove` and `/sys/bus/pci/devices/<bdf>/driver/unbind`.\n\nOpal support was added for scan, take ownership, revert TPer, and dumping device\ninfo. The nvme_manage tool can be used to perform these operations. The public\nAPI functions are spdk_nvme_ctrlr_security_receive() and\nspdk_nvme_ctrlr_security_send(). This module should be considered experimental\npending additional features and tests.\n\nThe NVMe-oF initiator is now able to transfer IO whose size is more than 128KiB\nif the corresponding NVMe-oF target allows.\n\n### raid\n\nAdded new strip_size_kb rpc param on create to replace the more ambiguous\nstrip_size. The strip_size rpc param is deprecated.\n\nChanged the raid bdev product_name from \"Pooled Device\" to \"Raid Volume\"\n\n### thread\n\nAdded spdk_thread_has_pollers() function to verify if there are any registered\npollers to be run on the thread. Added spdk_thread_is_idle() function to check\nif there are any scheduled operations to be performed on the thread at given\ntime.\n\nspdk_thread_create() now takes an optional CPU affinity mask that is passed to\nthe scheduler.\n\nspdk_thread_lib_init() now takes an optional context size. For each thread\ncreated, an additional region of memory of this size will be allocated. A\npointer to this region of memory can be obtained by calling\nspdk_thread_get_ctx(). The inverse operation is also available via\nspdk_thread_get_from_ctx().\n\nspdk_thread_poll() now optionally accepts the current time, in ticks. This can\nbe used to avoid some calls to spdk_get_ticks() internally.\n\nspdk_app_start() now only accepts a single context argument.\n\n### bdev\n\nAn new API `spdk_bdev_get_data_block_size` has been added to get size of data\nblock except for metadata.\n\nspdk_vbdev_register() has been deprecated.  spdk_bdev_register() should be used\ninstead.\n\nA mechanism for acquiring and releasing data buffers from bdev modules, used\nto perform zero copy operations, was added.\n\nNew APIs spdk_bdev_get_md_size(), spdk_bdev_is_md_interleaved(), spdk_bdev_get_dif_type(),\nspdk_bdev_is_dif_head_of_md(), and spdk_bdev_is_dif_check_enabled() have been\nadded to get metadata and DIF settings.\n\nBdevs claimed by the `examine_config` callback will be now further examined in the\n`examine_disk` callback.\n\nspdk_bdev_io_get_io_channel() was added as a convenient way to get an io_channel\nfrom a bdev_io.\n\n### ocf\n\nUpdated OCF submodule to OCF v19.3.2\n\nAdded support for many-to-one configuration for OCF bdev.\nMultiple core devices can now be cached on single cache device.\n\nAdded persistent metadata support, allowing to restore cache state after shutdown.\nDuring start of SPDK application, the devices are examined and if OCF metadata\nis present - appropriate OCF bdevs will be recreated.\n\nAdded Write-Back mode support. In this mode, data is first written to\ncaching device and periodically synchronized to the core devices.\nDirty data is saved as persistent metadata on cache device,\nallowing for safe restore during application restart.\nFor more details please see OCF documentation:\n[OpenCAS cache configuration](https://open-cas.github.io/cache_configuration.html)\n\n### NVMe-oF Target\n\nSupport for per-device shared receive queues in the RDMA transport has been added.\nIt is enabled by default for any device that supports it.\n\nThe size of a shared receive queue is defined by transport configuration file parameter\n`MaxSRQDepth` and `nvmf_create_transport` RPC method parameter `max_srq_depth`.\nDefault size is 4096.\n\nAdd model number as parameter to construct_nvmf_subsystem (-d option),\nrather than using hardcoded define.\n\nDIF passthrough feature has been added. DIF setting of the allocated bdevs is\nexposed to the NVMe-oF initiator and data with DIF from the NVMe-oF initiator is\npassed through to the allocated bdevs.\n\n### env\n\nThe `phys_addr` parameter in spdk_malloc() and spdk_zmalloc() has been deprecated.\nFor retrieving physical addresses, spdk_vtophys() should be used instead.\n\nspdk_realloc() has been added to reallocate DMA/shared memory.\n\nspdk_pci_device_is_removed() has been added to let the upper-layer SPDK drivers know\nthat device has a pending external hotremove request.\n\nspdk_env_fini() and spdk_env_dpdk_post_fini() were added to release any resources\nallocated by spdk_env_init() or spdk_env_dpdk_post_init() respectively. It is expected\nthat common usage of those functions is to call them just before terminating the process.\n\nAdded spdk_iommu_is_enabled() to report if SPDK application is using IOMMU for DMA.\n\n### DPDK\n\nDropped support for DPDK 17.07 and earlier, which SPDK won't even compile with right now.\n\nUpdated DPDK submodule to DPDK 19.02.\n\n### rpc\n\nNew `get_spdk_version` RPC method is introduced to get version info of the running SPDK application.\n\nThe `start_nbd_disk` RPC method now take nbd_device as an optional parameter. If nbd_device\nis specified, use that specified nbd device. If it's not specified, pick available one.\n\n### iSCSI target\n\nDIF strip and insert is now supported. DIF settings are not exposed to the iSCSI initiator.\nDIF is attached into data for write I/O and stripped from data for read I/O.\n\n### vhost\n\nAdded experimental support for running with the external, upstream rte_vhost library.\nThis can be enabled by configuring SPDK with an `--without-internal-vhost-lib` flag.\nThe minimum supported rte_vhost version (DPDK version) is 19.05-rc1.\n\nAs a result of fuzz testing, a lot of data races in vhost-scsi LUN hotplug path were identified and\nfixed. Those data races could have potentially resulted in SPDK crashes, RPC hangs, or memory leaks\nif Vhost-SCSI LUN hotplug RPCs were executed while connected VMs were in the middle of restarting.\n\nThe SCSI target id in `add_vhost_scsi_lun` RPC is now optional. If `-1` is passed, the first\nunoccupied target id will be used.\n\n### AIO\n\nAIO bdev module can now reap I/O completions directly from userspace, significantly improving\nthe overall performance.\n\n### blobfs\n\nSynchronous IO operations no longer use spdk_io_channel, but instead use\nspdk_fs_thread_ctx. The behavior is otherwise identical.\n\n### OCF\n\nAdded support for caching multiple bdevs using a single bdev as a cache.\n\n### notify\n\nAdded the notify library that provides a high performance local event bus\nbetween libraries. Example usage was added to bdev module, which reports\nnotifications for added and removed bdevs via RPC.\n\n### sock\n\nAdded new API spdk_sock_readv() to the sock library for performing vectored\nreads.\n\n### event\n\nThe function spdk_subsystem_init() no longer requires spdk_event as an argument.\n\nChanged API of spdk_subsystem_config_json() to no longer be asynchronous.\n\n### io_uring\n\nA bdev module that issues I/O to kernel block devices using the new io_uring Linux kernel\nAPI was added. This module requires liburing.\n\n### build\n\nOptions to easily compile with profile guided optimization have been added to\n`configure`. To use profile guided optimization with SPDK, run\n`./configure --with-pgo-capture`, build SPDK, then run a workload of your\nchoosing. Then, simply run `./configure --with-pgo-enable` and recompile to\nbuild using the generated profile data. Profile guided optimization can yield\nvery large performance improvements, especially on GCC 8 and clang 7. This may\nbe combined with link time optimization which has been available under the\n`--enable-lto` configure option for several releases.\n\n### compression bdev/reduce library\n\nAdded \"reduce\" block compression scheme based on using SSDs for storing\ncompressed blocks of storage and persistent memory for metadata. Please see\n[compression](https://spdk.io/doc/bdev.html) for more details.\n\n## v19.01: NVMe-oF TCP/IP Transport, Open Channel SSD Flash Translation Layer, Caching bdev based on OCF, ISA-L Support, DIF/DIX library\n\n### ocf bdev\n\nNew virtual bdev module based on [Open CAS Framework](https://open-cas.github.io/) has been added.\nThis module allows for the use of one bdev to act as a high performance cache in front of another bdev.\nPlease see [documentation](https://spdk.io/doc/bdev.html#bdev_config_cas) for more details.\nOnly write through mode is currently supported and this feature is considered experimental.\n\n### event framework\n\nFor `spdk_app_parse_args`, add return value to the callback which parses application\nspecific command line parameters to protect SPDK applications from crashing by invalid\nvalues from user input.\n\nBy default, all SPDK applications will now reserve all hugepages at runtime. The pre-reserved\nmemory size can be still set with `-s` or `--mem-size` option, although the default value\nwas reduced down to 0.\n\nA custom hugetlbfs directory can now be specified via spdk_app_opts.\nThis can be used to configure hugepages with different sizes, a different size limit,\nor different access permissions than the system's default hugepage pool.\nSPDK applications can specify a custom hugetlbfs mount with the `--huge-dir` option.\n\n### environment\n\nspdk_vtophys() has been refactored to accept length of the translated region as a new\nparameter. The function will now update that parameter with the largest possible value\nfor which the memory is contiguous in the physical memory address space.\n\nThe following functions were removed:\n\n- spdk_pci_nvme_device_attach()\n- spdk_pci_nvme_enumerate()\n- spdk_pci_ioat_device_attach()\n- spdk_pci_ioat_enumerate()\n- spdk_pci_virtio_device_attach()\n- spdk_pci_virtio_enumerate()\n\nThey were replaced with generic spdk_pci_device_attach() and spdk_pci_enumerate() which\nrequire a new spdk_pci_driver object to be provided. It can be one of the following:\n\n- spdk_pci_nvme_get_driver()\n- spdk_pci_ioat_get_driver()\n- spdk_pci_virtio_get_driver()\n\nspdk_pci_hook_device() and spdk_pci_unhook_device() were added. Those allow adding a virtual\nspdk_pci_device into the SPDK PCI subsystem. A virtual device calls provided callbacks for\neach BAR mapping request or PCI config access. It's attachable with spdk_pci_device_attach()\nor spdk_pci_enumerate() like any other device.\n\nA new spdk_pause() function was added to pause CPU execution for an implementation specific\namount of time. Quoting from DPDK function this is based on: \"This call is intended for\ntight loops which poll a shared resource or wait for an event. A short pause within the loop\nmay reduce the power consumption.\"\n\nA new public header file env_dpdk.h has been introduced, and function spdk_env_dpdk_post_init\nis added into it. If user is using DPDK, and already called rte_eal_init, then include\ninclude/spdk/env_dpdk.h, and call spdk_env_dpdk_post_init() instead of spdk_env_init.\n\nISA-L has been added as an SPDK submodule.  ISA-L is enabled by default on x86 architecture\nto accelerate algorithms such as CRC for iSCSI and NVMe-oF.  Users may still disable ISA-L\nby explicitly passing --without-isal to the configure script.\n\n### util\n\nA new uuid API `spdk_uuid_copy` was added to make a copy of the source uuid.\n\nAn new parameter `init_crc` representing the initial CRC value was added to\n`spdk_crc16_t10dif`. The parameter can be used to calculate a CRC value spanning\nmultiple separate buffers.\n\nNew DIF APIs were added to generate and verify DIF by byte granularity for both DIF and DIX\nformats. Among them, DIF with copy APIs will be usable to emulate DIF operations such as DIF\ninsert and strip.\n\nAdded `spdk_strtol` and `spdk_strtoll` to provide additional error checking around `strtol`\nand `strtoll`.\n\nAdded `spdk_sprintf_append_realloc` and `spdk_vsprintf_append_realloc` for appending a string\nwith automatic buffer re-allocation.\n\n### nvme\n\nWrapper functions spdk_nvme_ctrlr_security_send() and spdk_nvme_ctrlr_security_receive() are\nintroduced to support further security protocol development.\n\nadmin_timeout_ms was added to NVMe controller initialization options, users\ncan change the default value when probing a controller.\n\nAdd two new fields \"header_digest\" and \"data_digest\" in struct spdk_nvme_ctrlr_opts,\nit will be used to enable the digest support for the NVMe/TCP transport.\n\nAdd a new TCP/IP transport(located in lib/nvme/nvme_tcp.c) in nvme driver. With\nthis new transport, it can be used to connect the NVMe-oF target with the\nsame TCP/IP support.\n\nAdded API, spdk_nvme_ctrlr_is_discovery(), to indicate whether the ctrlr\narg refers to a Discovery Controller or not.\n\nAdded an API function `spdk_nvme_host_id_parse` and corresponding object `spdk_nvme_host_id`\nfor parsing host address and host service ID arguments on a per connection basis.\n\nThe RPC `construct_nvme_bdev` now allows a user to specify a source address and service id for the host to\nuse when connecting to the controller backing the NVMe bdev.\n\n### NVMe-oF Target\n\nThe `spdk_nvmf_tgt_opts` struct has been deprecated in favor of `spdk_nvmf_transport_opts`.\nUsers will no longer be able to specify target wide I/O parameters. `spdk_nvmf_tgt_listen`\nwill also no longer implicitly initialize a transport with the default target options (since\nthere are none). Instead, a user must manually instantiate the transport with `spdk_nvmf_transport_create`\nprior to calling `spdk_nvmf_tgt_listen`.\n\nRelated to the previous change, the rpc `set_nvmf_target_options` has been renamed to\n`set_nvmf_target_max_subsystems` to indicate that this is the only target option available for the user to edit.\n\nAdded fields `num_shared_buffers` and `buf_cache_size` in struct spdk_nvmf_transport_opts,\nand also updated the related rpc function nvmf_create_transport, to make this\nconfigurable parameter available to users. The `num_shared_buffers` is used to\nconfigure the shared buffer numbers of the transport used by RDMA or TCP transport.\n`buf_cache_size` configures number of shared buffers to cache per poll group.\n\n### nvmf\n\nAdd a new TCP/IP transport (located in lib/nvmf/tcp.c). With this transport,\nthe SPDK NVMe-oF target can have a new transport, and can serve the NVMe-oF\nprotocol via TCP/IP from the host.\n\nAdded optional mechanism to modify the RDMA transport's behavior when creating protection domains and registering memory.\nBy default, the RDMA transport will use the ibverbs library to create protection domains and register memory.\nUsing `spdk_nvme_rdma_init_hooks` will subvert that and use an existing registration.\n\n### bdev\n\nAdded `enable_bdev_histogram` and `get_bdev_histogram` RPC commands to allow gathering latency data for specified bdev.\nPlease see [documentation](https://spdk.io/doc/bdev.html#rpc_bdev_histogram) for more details.\n\nAdded `required_alignment` field to `spdk_bdev`, that specifies an alignment requirement for data buffers associated with an spdk_bdev_io.\nBdev layer will automatically double buffer any spdk_bdev_io that violates this alignment, before the spdk_bdev_io is submitted to the bdev module.\n\nOn shutdown, bdev unregister now proceeds in top-down fashion, with\nclaimed bdevs skipped (these will be unregistered later, when virtual\nbdev built on top of the respective base bdev unclaims it). This\nallows virtual bdevs to be shut down cleanly as opposed to the\nprevious behavior that didn't differentiate between hotremove and\nplanned shutdown.\n\nThe `delete_bdev` RPC is now deprecated. Users should instead use the specific deletion RPC\nfor the bdev type to be removed (i.e. delete_malloc_bdev).\n\nAdded support for separate bandwidth rate limits for read and write to QoS in bdev layer.\n\nBdev I/O statistics now track unmap operations.\n\n### logical volumes\n\nLogical volume bdev can now be marked as read only using `set_read_only_lvol_bdev` RPC.\nThis allows for basing clones on top of lvol_bdev without first creating a snapshot.\n\nAdded option to change method for data erasure when deleting lvol or resizing down.\nDefault of unmapping clusters can now be changed to writing zeroes or no operation.\n\nAdded option to change method for erasing data region on lvol store creation.\nDefault of unmapping can now be changed to writing zeroes or no operation.\n\n### log\n\n\"trace flags\" are now referred to as \"log flags\" in the SPDK log API.  The\nset_trace_flag, clear_trace_flag and get_trace_flags RPCs are now deprecated,\nand set_log_flag, clear_log_flag and get_log_flags RPCs have been added.\n\n### trace\n\nNew `trace_record` application was added. It can be used to poll spdk trace shm file and\nappend any new trace entries into another specified file. This can help retain those entries\nthat would otherwise be overwritten in the shm file. See\n[Capturing sufficient trace events](https://spdk.io/doc/nvmf_tgt_tracepoints.html#capture_trace_events)\nfor more details.\n\nNumber of trace entries in circular buffer per lcore can now be assigned by starting SPDK app\nwith argument \"--num-trace-entries <NUM>\" provided.\n\nNew `get_tpoint_group_mask` RPC was added to get current tpoint_group_mask, and\neach tpoint group status.\nNew `enable_tpoint_group` and `disable_tpoint_group` RPC were added to enable or\ndisable a specific tpoint group.\n\n### ftl\n\nEXPERIMENTAL: Added basic flash translation layer module allowing for using Open Channel SSDs as\nblock devices. The module is split into the library (located in lib/ftl) and bdev_ftl\n(lib/bdev/ftl). See the [documentation](https://spdk.io/doc/ftl.html) for more details.\n\n### vhost\n\nA security vulnerability has been identified and fixed in the SPDK vhost target.  A malicious\nvhost client (i.e. virtual machine) could carefully construct a circular descriptor chain which\nwould result in a partial denial of service in the SPDK vhost target.  These types of descriptor\nchains are now properly detected by the vhost target.  All SPDK vhost users serving untrusted\nvhost clients are strongly recommended to upgrade. (Reported by Dima Stepanov and Evgeny\nYakovlev.)\n\nVhost SCSI and Vhost Block devices can now accept multiple connections on the same socket file.\nEach connection (internally called a vhost session) will have access to the same storage, but\nwill use different virtqueues, different features and possibly different memory.\n\n### vhost scsi\n\nSCSI target hotremove can now be performed even without the VIRTIO_SCSI_F_HOTPLUG feature negotiated.\nRegardless of VIRTIO_SCSI_F_HOTPLUG support, the hotremoval will be still reported through SCSI sense codes.\n\n### DPDK\n\nDPDK submodule was updated to DPDK 18.11. Note that SPDK does not fully leverage the new\nmulti-process device hotplug yet and continues to work the same way it always did.\n\nDropped support for DPDK 16.07 and earlier, which SPDK won't even compile with right now.\n\n### RPC\n\nThe following RPC commands deprecated in the previous release are now removed:\n\n- construct_virtio_user_scsi_bdev\n- construct_virtio_pci_scsi_bdev\n- construct_virtio_user_blk_bdev\n- construct_virtio_pci_blk_bdev\n- remove_virtio_scsi_bdev\n- construct_nvmf_subsystem\n\n### Miscellaneous\n\nThe configure options `--with-raid` and `--without-raid` that were deprecated in the previous\nrelease are now removed.\n\n### nbd\n\nStarting nbd using `spdk_nbd_start` is now performed asynchronously.\n\n### net framework\n\nNet framework initialization and finish is now done asynchronously.\n\n### rpc\n\nAdded `spdk_rpc_is_method_allowed` function for checking whether method is permitted in a given state.\nAdded `spdk_rpc_get_state` to check current state of RPC server.\nRPC `wait_subsystem_init` has been added to allow clients to block until all subsystems are initialized.\n\n### json rpc\n\nJSON RPC client is now running in non-blocking mode. Requests are sent and received during spdk_jsonrpc_client_poll.\nJSON RPC server can now receive a callback on connection termination or server shutdown using `spdk_jsonrpc_conn_add_close_cb`\nand `spdk_jsonrpc_conn_del_close_cb`.\n\n## v18.10: Dynamic memory allocation, Crypto Virtual Bdev, jsonrpc-client, SPDKCLI iSCSI and NVMe-oF support\n\n### nvme\n\nspdk_nvme_ctrlr_cmd_security_send() and spdk_nvme_ctrlr_cmd_security_receive()\nwere added to support sending or receiving security protocol data to or from\nnvme controller.\n\nspdk_nvme_ns_get_extended_sector_size() was added.  This function includes\nthe metadata size per sector (if any).  spdk_nvme_ns_get_sector_size() still\nreturns only the data size per sector, not including metadata.\n\nNew `send_nvme_cmd` RPC was added to allow sending NVMe commands directly to NVMe controller.\nSee the [send_nvme_cmd](http://spdk.io/doc/jsonrpc.html#rpc_send_nvme_cmd) documentation\nfor more details.\n\n### Build System\n\nNew `configure` options, `--with-shared` and `--without-shared`\n[default], provide the capability to build, or not, SPDK shared libraries.\nThis includes the single SPDK shared lib encompassing all of the SPDK\nstatic libs as well as individual SPDK shared libs corresponding to\neach of the SPDK static ones.  Although the production of the shared\nlibs conforms with conventional version naming practices, such naming\ndoes not at this time confer any SPDK ABI compatibility claims.\n\n### bdev\n\nspdk_bdev_alias_del_all() was added to delete all alias from block device.\n\nA new virtual bdev module has been added to perform at rest data encryption using the DPDK CryptoDev\nFramework.  The module initially uses a software AESNI CBC cipher with experimental support for the\nIntel QAT hardware accelerator also currently implemented with support for CBC cipher. Future work\nmay include additional ciphers as well as consideration for authentication.\n\nThe RAID virtual bdev module is now always enabled by default.  The configure --with-raid and\n--without-raid options are now ignored and deprecated and will be removed in the next release.\n\nEnforcement of bandwidth limits for quality of service (QoS) has been added to the bdev layer.\nSee the new [set_bdev_qos_limit](http://www.spdk.io/doc/jsonrpc.html#rpc_set_bdev_qos_limit)\ndocumentation for more details. The previous set_bdev_qos_limit_iops RPC method introduced at\n18.04 release has been deprecated. The new set_bdev_qos_limit RPC method can support both\nbandwidth and IOPS limits.\n\nspdk_bdev_config_json() and corresponding `get_bdevs_config` RPC was removed.\n\n### Environment Abstraction Layer and Event Framework\n\nThe size parameter of spdk_mem_map_translate is now a pointer. This allows the\nfunction to report back the actual size of the translation relative to the original\nrequest made by the user.\n\nA new structure spdk_mem_map_ops has been introduced to hold memory map related\ncallbacks. This structure is now passed as the second argument of spdk_mem_map_alloc\nin lieu of the notify callback.\n\n### DPDK 18.08\n\nThe DPDK submodule has been updated to the DPDK 18.08 release. SPDK will now automatically\nutilize DPDK's dynamic memory management with DPDK versions >= 18.05.1.\n\nHugepages can be still reserved with `[-s|--mem-size <size>]` option at application startup,\nbut once we use them all up, instead of failing user allocations with -ENOMEM, we'll try\nto dynamically reserve even more. This allows starting SPDK with `--mem-size 0` and using\nonly as many hugepages as it is really needed.\n\nDue to this change, the memory buffers returned by `spdk_*malloc()` are no longer guaranteed\nto be physically contiguous.\n\n### I/OAT\n\nI/OAT driver can now reinitialize I/OAT channels after encountering DMA errors.\n\n### iscsi target\n\nParameter names of `set_iscsi_options` and `get_iscsi_global_params` RPC\nmethod for CHAP authentication in discovery sessions have been changed to\nalign with `construct_target_node` RPC method. Old names are still usable\nbut will be removed in future release.\n\n`set_iscsi_discovery_auth` and `set_iscsi_target_node_auth` RPC methods have\nbeen added to set CHAP authentication for discovery sessions and existing\ntarget nodes, respectively.\n\nThe SPDK iSCSI target supports an AuthFile which can be used to load CHAP\nshared secrets when the iSCSI target starts. SPDK previously provided a\ndefault location for this file (`/usr/local/etc/spdk/auth.conf`) if none was\nspecified. This default has been removed. Users must now explicitly specify\nthe location of this file to load CHAP shared secrets from a file, or use\nthe related iSCSI RPC methods to add them at runtime.\n\n### iscsi initiator\n\nThe SPDK iSCSI initiator is no longer considered experimental and becomes\na first-class citizen among bdev modules. The basic usage has been briefly\ndescribed in the bdev user guide: [iSCSI bdev](https://spdk.io/doc/bdev.html#bdev_config_iscsi)\n\n### Miscellaneous\n\nThe SPDK application framework can now parse long name command line parameters.\nMost single-character parameters have a long name equivalent now. See the\n[Command Line Parameters](https://spdk.io/doc/app_overview.html) documentation\nfor details or use the `--help` command line parameter to list all available\nparams.\n\nbdevperf `-s` param (io size) was renamed to `-o` as `-s` had been already\nused by existing apps for memory size.\n\nbdevio can now accept all SPDK command line parameters. The config now has to\nbe provided with `-c` or `--config` param.\n\nThe following ioat/perf and nvme/perf parameters were renamed as well:\n `-s` (io size) to `-o`\n `-d` (mem size) to `-s`\n\nThe ReactorMask config file parameter has been deprecated.  Users should\nuse the -m or --cpumask command line option to specify the CPU core mask\nfor the application.\n\nDefault config file pathnames have been removed from iscsi_tgt, nvmf_tgt\nand vhost.  Config file pathnames may now only be specified using the\n-c command line option.\n\nUsers may no longer set DPDK_DIR in their environment to specify the\nlocation of the DPDK installation used to build SPDK.  Using DPDK_DIR\nhas not been the documented nor recommended way to specify the DPDK\nlocation for several releases, but removing it ensures no unexpected\nsurprises for users who may have DPDK_DIR defined for other reasons.\nUsers should just use the \"configure\" script to specify the DPDK\nlocation before building SPDK.\n\nAlthough we know that many developers still use Python 2 we are officially\nswitching to Python3 with requirement that all new code must be valid also\nfor Python 2 up to the EOL which is year 2020.\n\nInvoking interpreter explicitly is forbidden for executable scripts. There\nis no need to use syntax like \"python ./scripts/rpc.py\". All executable\nscripts must contain proper shebang pointing to the right interpreter.\nScripts without shebang mustn't be executable.\n\nA Python script has been added to enable conversion of old INI config file\nto new JSON-RPC config file format. This script can be found at\nscripts/config_converter.py. Example how this script can be used:\n~~~{.sh}\ncat old_format.ini | scripts/config_converter.py > new_json_format.json\n~~~\n\n### Sock\n\nTwo additional parameters were added to spdk_sock_get_addr() for the server\nport and client port. These parameters are named \"sport\" and \"cport\"\nrespectively.\n\n### Virtio\n\nThe following RPC commands have been deprecated:\n\n- construct_virtio_user_scsi_bdev\n- construct_virtio_pci_scsi_bdev\n- construct_virtio_user_blk_bdev\n- construct_virtio_pci_blk_bdev\n- remove_virtio_scsi_bdev\n\nThe `construct_virtio_*` ones were replaced with a single `construct_virtio_dev`\ncommand that can create any type of Virtio bdev(s). `remove_virtio_scsi_bdev`\nwas replaced with `remove_virtio_bdev` that can delete both Virtio Block and SCSI\ndevices.\n\n### Blobfs\n\nspdk_file_get_id() returning unique ID for the file was added.\n\n### JSON\n\nAdded jsonrpc-client C library intended for issuing RPC commands from applications.\n\nAdded API enabling iteration over JSON object:\n\n- spdk_json_find()\n- spdk_json_find_string()\n- spdk_json_find_array()\n- spdk_json_object_first()\n- spdk_json_array_first()\n- spdk_json_next()\n\n### Blobstore\n\nBlobstore I/O operations are now based on io_units, instead of blobstore page size.\nThe io_unit size is now the same as the underlying block device's block size.\nLogical volumes built on a block device with 512B block size can now be used as boot devices\nin QEMU.\n\n### SPDKCLI\n\nThe SPDKCLI interactive command tool for managing SPDK is no longer considered experimental.\nSupport for the iSCSI and NVMe-oF targets has been added.\n\n## v18.07: Raid, Infrastructure Improvements, Bug Fixes\n\n### bdev\n\nA new public header file bdev_module.h has been introduced to facilitate the\ndevelopment of new bdev modules. This header includes an interface for the\nspdk_bdev_part and spdk_bdev_part_base objects to enable the creation of\nmultiple virtual bdevs on top of a single base bdev and should act as the\nprimary API for module authors.\n\nspdk_bdev_get_opts() and spdk_bdev_set_opts() were added to set bdev-wide\noptions.\n\nA mechanism for handling out of memory condition errors (ENOMEM) returned from\nI/O submission requests at the bdev layer has been added. See\nspdk_bdev_queue_io_wait().\n\nThe spdk_bdev_get_io_stat() function now returns cumulative totals instead of\nresetting on each call. This allows multiple callers to query I/O statistics\nwithout conflicting with each other. Existing users will need to adjust their\ncode to record the previous I/O statistics to calculate the delta between calls.\n\nI/O queue depth tracking and samples options have been added. See\nspdk_bdev_get_qd(), spdk_bdev_get_qd_sampling_period(), and\nspdk_bdev_set_qd_sampling_period().\n\n### RAID module\n\nA new bdev module called \"raid\" has been added as experimental module which\naggregates underlying NVMe bdevs and exposes a single raid bdev. Please note\nthat vhost will not work with this module because it does not yet have support\nfor multi-element io vectors.\n\n### Log\n\nThe debug log component flag available on several SPDK applications has been\nrenamed from `-t` to `-L` to prevent confusion with tracepoints and to allow the\noption to be added to tools that already use `-t` to mean something else.\n\n### Blobstore\n\nA new function, spdk_bs_dump(), has been added that dumps all of the contents of\na blobstore to a file pointer. This includes the metadata and is very useful for\ndebugging.\n\nTwo new operations have been added for thin-provisioned blobs.\nspdk_bs_inflate_blob() will allocate clusters for all thinly provisioned regions\nof the blob and populate them with the correct data by reading from the backing\nblob(s). spdk_bs_blob_decouple_parent() works similarly, but will only allocate\nclusters that correspond to data in the blob's immediate parent. Clusters\nallocated to grandparents or that aren't allocated at all will remain\nthin-provisioned.\n\n### BlobFS\n\nChanged the return type of spdk_file_truncate() from void to int to allow the\npropagation of `ENOMEM` errors.\n\n### NVMe Driver\n\nThe new API functions spdk_nvme_qpair_add_cmd_error_injection() and\nspdk_nvme_qpair_remove_cmd_error_injection() have been added for NVMe error\nemulation. Users can set a specified command to fail with a particular error\nstatus.\n\nChanged the name `timeout_sec` parameter to `timeout_us` in\nspdk_nvme_ctrlr_register_timeout_callback(), and also changed the type from\nuint32_t to uint64_t. This will give users more fine-grained control over the\ntimeout period.\n\nBasic support for Open Channel SSDs was added. See nvme_ocssd.h\n\n### NVMe Over Fabrics\n\nThe spdk_nvmf_tgt_destroy() function is now asynchronous and takes a callback\nas a parameter.\n\nspdk_nvmf_qpair_disconnect() was added to allow the user to disconnect qpairs.\n\nspdk_nvmf_subsystem_get_max_namespaces() was added to query the maximum allowed\nnumber of namespaces for a given subsystem.\n\n### Build System\n\nThe build system now generates a combined shared library (libspdk.so) that may\nbe used in place of the individual static libraries (libspdk_*.a). The combined\nlibrary includes all components of SPDK and is intended to make linking against\nSPDK easier. The static libraries are also still provided for users that prefer\nto link only the minimal set of components required.\n\n### git pre-commit and pre-push hooks\n\nThe pre-commit hook will run `scripts/check_format.sh` and verify there are no\nformatting errors before allowing `git commit` to run. The pre-push hook runs\n`make CONFIG_WERROR=y` with and without `CONFIG_DEBUG=y` using both the gcc and\nclang compiler before allowing `git push` to run. Following each DEBUG build\n`test/unit/unittest.sh` is run and verified. Results are recorded in the\n`make.log` file.\n\nTo enable type: 'git config core.hooksPath .githooks'. To override after\nconfiguration use the `git --no-verify` flag.\n\n### RPC\n\nThe `start_nbd_disk` RPC method now returns the path to the kernel NBD device node\nrather than always returning `true`.\n\n### DPDK 18.05\n\nThe DPDK submodule has been rebased on the DPDK 18.05 release.  DPDK 18.05 supports\ndynamic memory allocation, but due to some issues found after the DPDK 18.05 release,\nthat support is not enabled for SPDK 18.07.  Therefore, SPDK 18.07 will continue to use\nthe legacy memory allocation model.  The plan is to enable dynamic memory allocation\nafter the DPDK 18.08 release which should fix these issues.\n\n### Environment Abstraction Layer and Event Framework\n\nThe spdk_mem_map_translate() function now takes a size parameter to indicate the size of\nthe memory region.  This can be used by environment implementations to validate the\nrequested translation.\n\nThe I/O Channel implementation has been moved to its own library - lib/thread. The\npublic API that was previously in spdk/io_channel.h is now in spdk/thread.h The\nfile spdk/io_channel.h remains and includes spdk/thread.h.\n\nspdk_reactor_get_tsc_stats was added to return interesting statistics for each\nreactor.\n\n### IOAT\n\nIOAT for copy engine is disabled by default. It can be enabled by specifying the Enable\noption with \"Yes\" in `[Ioat]` section of the configuration file. The Disable option is\nnow deprecated and will be removed in a future release.\n\n## v18.04: Logical Volume Snapshot/Clone, iSCSI Initiator, Bdev QoS, VPP Userspace TCP/IP\n\n### vhost\n\nThe SPDK vhost-scsi, vhost-blk and vhost-nvme applications have fixes to address the\nDPDK rte_vhost vulnerability [CVE-2018-1059](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1059).\nPlease see this [security advisory](https://access.redhat.com/security/cve/cve-2018-1059)\nfor additional information on the DPDK vulnerability.\n\nWorkarounds have been added to ensure vhost compatibility with QEMU 2.12.\n\nEXPERIMENTAL: Support for vhost-nvme has been added to the SPDK vhost target. See the\n[vhost documentation](http://www.spdk.io/doc/vhost.html) for more details.\n\n### Unified Target Application\n\nA new unified SPDK target application, `spdk_tgt`, has been added. This application combines the\nfunctionality of several existing SPDK applications, including the iSCSI target, NVMe-oF target,\nand vhost target. The new application can be managed through the existing configuration file and\n[JSON-RPC](http://www.spdk.io/doc/jsonrpc.html) methods.\n\n### Env\n\nspdk_mempool_get_bulk() has been added to wrap DPDK rte_mempool_get_bulk().\n\nNew memory management functions spdk_malloc(), spdk_zmalloc(), and spdk_free() have been added.\nThese new functions have a `flags` parameter that allows the user to specify whether the allocated\nmemory needs to be suitable for DMA and whether it should be shared across processes with the same\nshm_id. The new functions are intended to replace spdk_dma_malloc() and related functions, which will\neventually be deprecated and removed.\n\n### Bdev\n\nA new optional bdev module interface function, `init_complete`, has been added to notify bdev modules\nwhen the bdev subsystem initialization is complete. This may be useful for virtual bdevs that require\nnotification that the set of initialization examine() calls is complete.\n\nThe bdev layer now allows modules to provide an optional per-bdev UUID, which can be retrieved with\nthe spdk_bdev_get_uuid() function.\n\nEnforcement of IOPS limits for quality of service (QoS) has been added to the bdev layer. See the\n[set_bdev_qos_limit_iops](http://www.spdk.io/doc/jsonrpc.html#rpc_set_bdev_qos_limit_iops) documentation\nfor more details.\n\n### RPC\n\nThe `[Rpc]` configuration file section, which was deprecated in v18.01, has been removed.\nUsers should switch to the `-r` command-line parameter instead.\n\nThe JSON-RPC server implementation now allows up to 32 megabyte responses, growing as\nneeded; previously, the response was limited to 32 kilobytes.\n\n### SPDKCLI\n\nEXPERIMENTAL: New SPDKCLI interactive command tool for managing SPDK is available.\nSee the [SPDKCLI](http://www.spdk.io/doc/spdkcli.html) documentation for more details.\n\n### NVMe Driver\n\nEXPERIMENTAL: Support for WDS and RDS capable CMBs in NVMe controllers has been added. This support is\nexperimental pending a functional allocator to free and reallocate CMB buffers.\n\nspdk_nvme_ns_get_uuid() has been added to allow retrieval of per-namespace UUIDs when available.\n\nNew API functions spdk_nvme_ctrlr_get_first_active_ns() and spdk_nvme_ctrlr_get_next_active_ns()\nhave been added to iterate active namespaces, as well as spdk_nvme_ctrlr_is_active_ns() to check if\na namespace ID is active.\n\n### NVMe-oF Target\n\nNamespaces may now be assigned unique identifiers via new optional `eui64` and `nguid` parameters\nto the `nvmf_subsystem_add_ns` RPC method. Additionally, the NVMe-oF target automatically exposes\nthe backing bdev's UUID as the namespace UUID when available.\n\nspdk_nvmf_subsystem_remove_ns() is now asynchronous and requires a callback to indicate completion.\n\n### Blobstore\n\nA number of functions have been renamed:\n\n- spdk_bs_io_write_blob() => spdk_blob_io_write()\n- spdk_bs_io_read_blob() => spdk_blob_io_read()\n- spdk_bs_io_writev_blob() => spdk_blob_io_writev()\n- spdk_bs_io_readv_blob() => spdk_blob_io_readv()\n- spdk_bs_io_unmap_blob() => spdk_blob_io_unmap()\n- spdk_bs_io_write_zeroes_blob() => spdk_blob_io_write_zeroes()\n\nThe old names still exist but are deprecated.  They will be removed in the v18.07 release.\n\nspdk_blob_resize() is now an asynchronous operation to enable resizing a blob while I/O\nare in progress to that blob on other threads.  An explicit spdk_blob_sync_md() is still\nrequired to sync the updated metadata to disk.\n\n### Logical Volumes\n\nA new `destroy_lvol_bdev` RPC method to delete logical volumes has been added.\n\nLvols now have their own UUIDs which replace previous LvolStoreUUID_BlobID combination.\n\nNew Snapshot and Clone functionalities have been added. User may create Snapshots of existing Lvols\nand Clones of existing Snapshots.\nSee the [lvol snapshots](http://www.spdk.io/doc/logical_volumes.html#lvol_snapshots) documentation\nfor more details.\n\nResizing logical volumes is now supported via the `resize_lvol_bdev` RPC method.\n\n### Lib\n\nA set of changes were made in the SPDK's lib code altering\ninstances of calls to `exit()` and `abort()` to return a failure instead\nwherever reasonably possible.\n\nspdk_app_start() no longer exit()'s on an internal failure, but\ninstead returns a non-zero error status.\n\nspdk_app_parse_args() no longer exit()'s on help, '-h', or an invalid\noption, but instead returns SPDK_APP_PARSE_ARGS_HELP and\nSPDK_APP_PARSE_ARGS_FAIL, respectively, and SPDK_APP_PARSE_ARGS_SUCCESS\non success.\n\nspdk_pci_get_device() has been deprecated and will be removed in SPDK v18.07.\n\n### I/O Channels\n\nThe prototype for spdk_poller_fn() has been modified; it now returns a value indicating\nwhether or not the poller did any work.  Existing pollers will need to be updated to\nreturn a value.\n\n### iSCSI Target\n\nThe SPDK iSCSI target now supports the fd.io Vector Packet Processing (VPP) framework userspace\nTCP/IP stack. See the [iSCSI VPP documentation](http://www.spdk.io/doc/iscsi.html#vpp) for more\ndetails.\n\n### iSCSI initiator\n\nAn iSCSI initiator bdev module has been added to SPDK.  This module should be considered\nexperimental pending additional features and tests.  More details can be found in\nlib/bdev/iscsi/README.\n\n### PMDK\n\nThe persistent memory (PMDK) bdev module is now enabled using `--with-pmdk` instead of\n`--with-nvml`.  This reflects the renaming of the persistent memory library from NVML to\nPMDK.\n\n### Virtio Block driver\n\nA userspace driver for Virtio Block devices has been added. It was built on top of the\n[Virtio](http://www.spdk.io/doc/virtio.html) library and can be managed similarly to\nthe Virtio SCSI driver. See the\n[Virtio Block](http://www.spdk.io/doc/bdev.html#bdev_config_virtio_blk) reference for\nmore information.\n\n### Virtio with 2MB hugepages\n\nThe previous 1GB hugepage limitation has now been lifted. A new `-g` command-line option\nenables SPDK Virtio to work with 2MB hugepages.\nSee [2MB hugepages](http://www.spdk.io/doc/virtio.html#virtio_2mb) for details.\n\n## v18.01: Blobstore Thin Provisioning\n\n### Build System\n\nThe build system now includes a `make install` rule, including support for the common\n`DESTDIR` and `prefix` variables as used in other build systems.  Additionally, the prefix\nmay be set via the configure `--prefix` option.  Example: `make install prefix=/usr`.\n\n### RPC\n\nA JSON RPC listener is now enabled by default using a UNIX domain socket at /var/tmp/spdk.sock.\nA -r option command line option has been added to enable an alternative UNIX domain socket location,\nor a TCP port in the format ip_addr:tcp_port (i.e. 127.0.0.1:5260).  The Rpc configuration file\nsection is now deprecated and will be removed in the v18.04 release.\n\n### I/O Channels\n\nspdk_poller_register() and spdk_poller_unregister() were moved from the event\nframework (include/spdk/event.h) to the I/O channel library\n(include/spdk/io_channel.h). This allows code that doesn't depend on the event\nframework to request registration and unregistration of pollers.\n\nspdk_for_each_channel() now allows asynchronous operations during iteration.\nInstead of immediately continuing the interaction upon returning from the iteration\ncallback, the user must call spdk_for_each_channel_continue() to resume iteration.\n\n### Block Device Abstraction Layer (bdev)\n\nThe poller abstraction was removed from the bdev layer. There is now a general purpose\nabstraction for pollers available in include/spdk/io_channel.h\n\n### Lib\n\nA set of changes were made in the SPDK's lib code altering,\ninstances of calls to `exit()` and `abort()` to return a failure instead\nwherever reasonably possible.  This has resulted in return type changes of\nthe API for:\n\n- spdk_env_init() from type `void` to `int`.\n- spdk_mem_map_init() from type `void` to `int`.\n\nApplications making use of these APIs should be modified to check for\na non-zero return value instead of relying on them to fail without return.\n\n### NVMe Driver\n\nSPDK now supports hotplug for vfio-attached devices. But there is one thing keep in mind:\nOnly physical removal events are supported; removing devices via the sysfs `remove` file will not work.\n\n### NVMe-oF Target\n\nSubsystems are no longer tied explicitly to CPU cores. Instead, connections are handed out to the available\ncores round-robin. The \"Core\" option in the configuration file has been removed.\n\n### Blobstore\n\nA number of functions have been renamed:\n\n- spdk_bs_md_resize_blob() => spdk_blob_resize()\n- spdk_bs_md_sync_blob() => spdk_blob_sync_md()\n- spdk_bs_md_close_blob() => spdk_blob_close()\n- spdk_bs_md_get_xattr_names() => spdk_blob_get_xattr_names()\n- spdk_bs_md_get_xattr_value() => spdk_blob_get_xattr_value()\n- spdk_blob_md_set_xattr() => spdk_blob_set_xattr()\n- spdk_blob_md_remove_xattr() => spdk_blob_remove_xattr()\n- spdk_bs_md_create_blob() => spdk_bs_create_blob()\n- spdk_bs_md_open_blob() => spdk_bs_open_blob()\n- spdk_bs_md_delete_blob() => spdk_bs_delete_blob()\n- spdk_bs_md_iter_first() => spdk_bs_iter_first()\n- spdk_bs_md_iter_next() => spdk_bs_iter_next()\n\nThe function signature of spdk_blob_close() has changed.  It now takes a struct spdk_blob * argument\nrather than struct spdk_blob **.\n\nThe function signature of spdk_bs_iter_next() has changed.  It now takes a struct spdk_blob * argument\nrather than struct spdk_blob **.\n\nThin provisioning support has been added to the blobstore.  It can be enabled by setting the\n`thin_provision` flag in struct spdk_blob_opts when calling spdk_bs_create_blob_ext().\n\n### NBD device\n\nThe NBD application (test/lib/bdev/nbd) has been removed; Same functionality can now be\nachieved by using the test/app/bdev_svc application and start_nbd_disk RPC method.\nSee the [GPT](http://www.spdk.io/doc/bdev.html#bdev_config_gpt) documentation for more details.\n\n### FIO plugin\n\nSPDK `fio_plugin` now supports FIO 3.3. The support for previous FIO 2.21 has been dropped,\nalthough it still remains to work for now. The new FIO contains huge amount of bugfixes and\nit's recommended to do an update.\n\n### Virtio library\n\nPreviously a part of the bdev_virtio module, now a separate library. Virtio is now available\nvia `spdk_internal/virtio.h` file. This is an internal interface to be used when implementing\nnew Virtio backends, namely Virtio-BLK.\n\n### iSCSI\n\nThe MinConnectionIdleInterval parameter has been removed, and connections are no longer migrated\nto an epoll/kqueue descriptor on the master core when idle.\n\n## v17.10: Logical Volumes\n\n### New dependencies\n\nlibuuid was added as new dependency for logical volumes.\n\nlibnuma is now required unconditionally now that the DPDK submodule has been updated to DPDK 17.08.\n\n### Block Device Abstraction Layer (bdev)\n\nAn [fio](http://github.com/axboe/fio) plugin was added that can route\nI/O to the bdev layer. See the [plugin documentation](https://github.com/spdk/spdk/tree/master/examples/bdev/fio_plugin/)\nfor more information.\n\nspdk_bdev_unmap() was modified to take an offset and a length in bytes as\narguments instead of requiring the user to provide an array of SCSI\nunmap descriptors. This limits unmaps to a single contiguous range.\n\nspdk_bdev_write_zeroes() was introduced.  It ensures that all specified blocks will be zeroed out.\nIf a block device doesn't natively support a write zeroes command, the bdev layer emulates it using\nwrite commands.\n\nNew API functions that accept I/O parameters in units of blocks instead of bytes\nhave been added:\n\n- spdk_bdev_read_blocks(), spdk_bdev_readv_blocks()\n- spdk_bdev_write_blocks(), spdk_bdev_writev_blocks()\n- spdk_bdev_write_zeroes_blocks()\n- spdk_bdev_unmap_blocks()\n\nThe bdev layer now handles temporary out-of-memory I/O failures internally by queueing the I/O to be\nretried later.\n\n### Linux AIO bdev\n\nThe AIO bdev now allows the user to override the auto-detected block size.\n\n### NVMe driver\n\nThe NVMe driver now recognizes the NVMe 1.3 Namespace Optimal I/O Boundary field.\nNVMe 1.3 devices may report an optimal I/O boundary, which the driver will take\ninto account when splitting I/O requests.\n\nThe HotplugEnable option in `[Nvme]` sections of the configuration file is now\n\"No\" by default. It was previously \"Yes\".\n\nThe NVMe library now includes a spdk_nvme_ns_get_ctrlr() function which returns the\nNVMe Controller associated with a given namespace.\n\nThe NVMe library now allows the user to specify a host identifier when attaching\nto a controller.  The host identifier is used as part of the Reservations feature,\nas well as in the NVMe-oF Connect command.  The default host ID is also now a\nrandomly-generated UUID, and the default host NQN uses the host ID to generate\na UUID-based NQN.\n\nspdk_nvme_connect() was added to allow the user to connect directly to a single\nNVMe or NVMe-oF controller.\n\n### NVMe-oF Target (nvmf_tgt)\n\nThe NVMe-oF target no longer requires any in-capsule data buffers to run, and\nthe feature is now entirely optional. Previously, at least 4 KiB in-capsule\ndata buffers were required.\n\nNVMe-oF subsystems have a new configuration option, AllowAnyHost, to control\nwhether the host NQN whitelist is enforced when accepting new connections.\nIf no Host options have been specified and AllowAnyHost is disabled, the\nconnection will be denied; this is a behavior change from previous releases,\nwhich allowed any host NQN to connect if the Host list was empty.\nAllowAnyHost is disabled by default.\n\nNVMe-oF namespaces may now be assigned arbitrary namespace IDs, and the number\nof namespaces per subsystem is no longer limited.\n\nThe NVMe-oF target now supports the Write Zeroes command.\n\n### Environment Abstraction Layer\n\nA new default value, SPDK_MEMPOOL_DEFAULT_CACHE_SIZE, was added to provide\nadditional clarity when constructing spdk_mempools. Previously, -1 could be\npassed and the library would choose a reasonable default, but this new value\nmakes it explicit that the default is being used.\n\n### Blobstore\n\nThe blobstore super block now contains a bstype field to identify the type of the blobstore.\nExisting code should be updated to fill out bstype when calling spdk_bs_init() and spdk_bs_load().\n\nspdk_bs_destroy() was added to allow destroying blobstore on device\nwith an initialized blobstore.\n\nspdk_bs_io_readv_blob() and spdk_bs_io_writev_blob() were added to enable\nscattered payloads.\n\nA CLI tool for blobstore has been added, allowing basic operations through either command\nline or shell interface.  See the [blobcli](https://github.com/spdk/spdk/tree/master/examples/blob/cli)\ndocumentation for more details.\n\n### Event Framework\n\nThe ability to set a thread name, previously only used by the reactor code, is\nnow part of the spdk_thread_allocate() API.  Users may specify a thread name\nwhich will show up in tools like `gdb`.\n\n### Log\n\nThe spdk_trace_dump() function now takes a new parameter to allow the caller to\nspecify an output file handle (stdout or stderr, for example).\n\n### Logical Volumes\n\nLogical volumes library built on top of SPDK blobstore has been added.\nIt is possible to create logical volumes on top of other devices using RPC.\n\nSee the [logical volumes](http://www.spdk.io/doc/logical_volumes.html) documentation for more information.\n\n### Persistent Memory\n\nA new persistent memory bdev type has been added.\nThe persistent memory block device is built on top of [libpmemblk](http://pmem.io/nvml/libpmemblk/).\nIt is possible to create pmem devices on top of pmem pool files using RPC.\n\nSee the [Pmem Block Device](http://www.spdk.io/doc/bdev.html#bdev_config_pmem) documentation for more information.\n\n### Virtio SCSI driver\n\nA userspace driver for Virtio SCSI devices has been added.\nThe driver is capable of creating block devices on top of LUNs exposed by another SPDK vhost-scsi application.\n\nSee the [Virtio SCSI](http://www.spdk.io/doc/virtio.html) documentation and\n[Getting Started](http://www.spdk.io/doc/bdev.html#bdev_config_virtio_scsi) guide for more information.\n\n### Vhost target\n\nThe vhost target application now supports live migration between QEMU instances.\n\n## v17.07: Build system improvements, userspace vhost-blk target, and GPT bdev\n\n### Build System\n\nA `configure` script has been added to simplify the build configuration process.\nThe existing CONFIG file and `make CONFIG_...` options are also still supported.\nRun `./configure --help` for information about available configuration options.\n\nA DPDK submodule has been added to make building SPDK easier.  If no `--with-dpdk`\noption is specified to configure, the SPDK build system will automatically build a\nknown-good configuration of DPDK with the minimal options enabled.  See the Building\nsection of README.md for more information.\n\nA [Vagrant](https://www.vagrantup.com/) setup has been added to make it easier to\ndevelop and use SPDK on systems without suitable NVMe hardware.  See the Vagrant\nsection of README.md for more information.\n\n### Userspace vhost-blk target\n\nThe vhost library and example app have been updated to support the vhost-blk\nprotocol in addition to the existing vhost-scsi protocol.\nSee the [vhost documentation](http://www.spdk.io/doc/vhost.html) for more details.\n\n### Block device abstraction layer (bdev)\n\nA GPT virtual block device has been added, which automatically exposes GPT partitions\nwith a special SPDK-specific partition type as bdevs.\nSee the [GPT bdev documentation](http://www.spdk.io/doc/bdev.md#bdev_config_gpt) for\nmore information.\n\n### NVMe driver\n\nThe NVMe driver has been updated to support recent Intel SSDs, including the Intel®\nOptane™ SSD DC P4800X series.\n\nA workaround has been added for devices that failed to recognize register writes\nduring controller reset.\n\nThe NVMe driver now allocates request tracking objects on a per-queue basis.  The\nnumber of requests allowed on an I/O queue may be set during `spdk_nvme_probe()` by\nmodifying `io_queue_requests` in the opts structure.\n\nThe SPDK NVMe `fio_plugin` has been updated to support multiple threads (`numjobs`).\n\nspdk_nvme_ctrlr_alloc_io_qpair() has been modified to allow the user to override\ncontroller-level options for each individual I/O queue pair.\nExisting callers with qprio == 0 can be updated to:\n~~~\n... = spdk_nvme_ctrlr_alloc_io_qpair(ctrlr, NULL, 0);\n~~~\nCallers that need to specify a non-default qprio should be updated to:\n~~~\nstruct spdk_nvme_io_qpair_opts opts;\nspdk_nvme_ctrlr_get_default_io_qpair_opts(ctrlr, &opts, sizeof(opts));\nopts.qprio = SPDK_NVME_QPRIO_...;\n... = spdk_nvme_ctrlr_alloc_io_qpair(ctrlr, &opts, sizeof(opts));\n~~~\n\n### Environment Abstraction Layer\n\nThe environment abstraction layer has been updated to include several new functions\nin order to wrap additional DPDK functionality. See `include/spdk/env.h` for the\ncurrent set of functions.\n\n### SPDK Performance Analysis with Intel® VTune™ Amplifier\n\nSupport for SPDK performance analysis has been added to Intel® VTune™ Amplifier 2018.\n\nThis analysis provides:\n\n- I/O performance monitoring (calculating standard I/O metrics like IOPS, throughput, etc.)\n- Tuning insights on the interplay of I/O and compute devices by estimating how many cores\n  would be reasonable to provide for SPDK to keep up with a current storage workload.\n\nSee the VTune Amplifier documentation for more information.\n\n## v17.03: Blobstore and userspace vhost-scsi target\n\n### Blobstore and BlobFS\n\nThe blobstore is a persistent, power-fail safe block allocator designed to be\nused as the local storage system backing a higher-level storage service.\nSee the [blobstore documentation](http://www.spdk.io/doc/blob.html) for more details.\n\nBlobFS adds basic filesystem functionality like filenames on top of the blobstore.\nThis release also includes a RocksDB Env implementation using BlobFS in place of the\nkernel filesystem.\nSee the [BlobFS documentation](http://www.spdk.io/doc/blobfs.html) for more details.\n\n### Userspace vhost-scsi target\n\nA userspace implementation of the QEMU vhost-scsi protocol has been added.\nThe vhost target is capable of exporting SPDK bdevs to QEMU-based VMs as virtio devices.\nSee the [vhost documentation](http://www.spdk.io/doc/vhost.html) for more details.\n\n### Event framework\n\nThe overhead of the main reactor event loop was reduced by optimizing the number of\ncalls to spdk_get_ticks() per iteration.\n\n### NVMe library\n\nThe NVMe library will now automatically split readv/writev requests with scatter-gather\nlists that do not map to valid PRP lists when the NVMe controller does not natively\nsupport SGLs.\n\nThe `identify` and `perf` NVMe examples were modified to add a consistent format for\nspecifying remote NVMe over Fabrics devices via the `-r` option.\nThis is implemented using the new `spdk_nvme_transport_id_parse()` function.\n\n### iSCSI Target\n\nThe [Nvme] section of the configuration file was modified to remove the `BDF` directive\nand replace it with a `TransportID` directive. Both local (PCIe) and remote (NVMe-oF)\ndevices can now be specified as the backing block device. A script to generate an\nentire [Nvme] section based on the local NVMe devices attached was added at\n`scripts/gen_nvme.sh`.\n\n### NVMe-oF Target\n\nThe [Nvme] section of the configuration file was modified to remove the `BDF` directive\nand replace it with a `TransportID` directive. Both local (PCIe) and remote (NVMe-oF)\ndevices can now be specified as the backing block device. A script to generate an\nentire [Nvme] section based on the local NVMe devices attached was added at\n`scripts/gen_nvme.sh`.\n\n## v16.12: NVMe over Fabrics host, hotplug, and multi-process\n\n### NVMe library\n\nThe NVMe library has been changed to create its own request memory pool rather than\nrequiring the user to initialize the global `request_mempool` variable.  Apps can be\nupdated by simply removing the initialization of `request_mempool`.  Since the NVMe\nlibrary user no longer needs to know the size of the internal NVMe request\nstructure to create the pool, the `spdk_nvme_request_size()` function was also removed.\n\nThe `spdk_nvme_ns_cmd_deallocate()` function was renamed and extended to become\n`spdk_nvme_ns_cmd_dataset_management()`, which allows access to all of the NVMe\nDataset Management command's parameters.  Existing callers can be updated to use\n`spdk_nvme_ns_cmd_dataset_management()` with `SPDK_NVME_DSM_ATTR_DEALLOCATE` as the\n`type` parameter.\n\nThe NVMe library SGL callback prototype has been changed to return virtual addresses\nrather than physical addresses.  Callers of `spdk_nvme_ns_cmd_readv()` and\n`spdk_nvme_ns_cmd_writev()` must update their `next_sge_fn` callbacks to match.\n\nThe NVMe library now supports NVMe over Fabrics devices in addition to the existing\nsupport for local PCIe-attached NVMe devices.  For an example of how to enable\nNVMe over Fabrics support in an application, see `examples/nvme/identify` and\n`examples/nvme/perf`.\n\nHot insert/remove support for NVMe devices has been added.  To enable NVMe hotplug\nsupport, an application should call the `spdk_nvme_probe()` function on a regular\nbasis to probe for new devices (reported via the existing `probe_cb` callback) and\nremoved devices (reported via a new `remove_cb` callback).  Hotplug is currently\nonly supported on Linux with the `uio_pci_generic` driver, and newly-added NVMe\ndevices must be bound to `uio_pci_generic` by an external script or tool.\n\nMultiple processes may now coordinate and use a single NVMe device simultaneously\nusing [DPDK Multi-process Support](http://dpdk.org/doc/guides/prog_guide/multi_proc_support.html).\n\n### NVMe over Fabrics target (`nvmf_tgt`)\n\nThe `nvmf_tgt` configuration file format has been updated significantly to enable\nnew features.  See the example configuration file `etc/spdk/nvmf.conf.in` for\nmore details on the new and changed options.\n\nThe NVMe over Fabrics target now supports virtual mode subsystems, which allow the\nuser to export devices from the SPDK block device abstraction layer as NVMe over\nFabrics subsystems.  Direct mode (raw NVMe device access) is also still supported,\nand a single `nvmf_tgt` may export both types of subsystems simultaneously.\n\n### Block device abstraction layer (bdev)\n\nThe bdev layer now supports scatter/gather read and write I/O APIs, and the NVMe\nblockdev driver has been updated to support scatter/gather.  Apps can use the\nnew scatter/gather support via the `spdk_bdev_readv()` and `spdk_bdev_writev()`\nfunctions.\n\nThe bdev status returned from each I/O has been extended to pass through NVMe\nor SCSI status codes directly in cases where the underlying device can provide\na more specific status code.\n\nA Ceph RBD (RADOS Block Device) blockdev driver has been added.  This allows the\n`iscsi_tgt` and `nvmf_tgt` apps to export Ceph RBD volumes as iSCSI LUNs or\nNVMe namespaces.\n\n### General changes\n\n`libpciaccess` has been removed as a dependency and DPDK PCI enumeration is\nused instead. Prior to DPDK 16.07 enumeration by class code was not supported,\nso for earlier DPDK versions, only Intel SSD DC P3x00 devices will be discovered\nby the NVMe library.\n\nThe `env` environment abstraction library has been introduced, and a default\nDPDK-based implementation is provided as part of SPDK.  The goal of the `env`\nlayer is to enable use of alternate user-mode memory allocation and PCI access\nlibraries.  See `doc/porting.md` for more details.\n\nThe build process has been modified to produce all of the library files in the\n`build/lib` directory.  This is intended to simplify the use of SPDK from external\nprojects, which can now link to SPDK libraries by adding the `build/lib` directory\nto the library path via `-L` and linking the SPDK libraries by name (for example,\n`-lspdk_nvme -lspdk_log -lspdk_util`).\n\n`nvmf_tgt` and `iscsi_tgt` now have a JSON-RPC interface, which allows the user\nto query and modify the configuration at runtime.  The RPC service is disabled by\ndefault, since it currently does not provide any authentication or security\nmechanisms; it should only be enabled on systems with controlled user access\nbehind a firewall. An example RPC client implemented in Python is provided in\n`scripts/rpc.py`.\n\n## v16.08: iSCSI target, NVMe over Fabrics maturity\n\nThis release adds a userspace iSCSI target. The iSCSI target is capable of exporting\nNVMe devices over a network using the iSCSI protocol. The application is located\nin app/iscsi_tgt and a documented configuration file can be found at etc/spdk/spdk.conf.in.\n\nThis release also significantly improves the existing NVMe over Fabrics target.\n\n- The configuration file format was changed, which will require updates to\n  any existing nvmf.conf files (see `etc/spdk/nvmf.conf.in`):\n  - `SubsystemGroup` was renamed to `Subsystem`.\n  - `AuthFile` was removed (it was unimplemented).\n  - `nvmf_tgt` was updated to correctly recognize NQN (NVMe Qualified Names)\n    when naming subsystems.  The default node name was changed to reflect this;\n    it is now \"nqn.2016-06.io.spdk\".\n  - `Port` and `Host` sections were merged into the `Subsystem` section\n  - Global options to control max queue depth, number of queues, max I/O\n    size, and max in-capsule data size were added.\n  - The Nvme section was removed. Now a list of devices is specified by\n    bus/device/function directly in the Subsystem section.\n  - Subsystems now have a Mode, which can be Direct or Virtual. This is an attempt\n    to future-proof the interface, so the only mode supported by this release\n    is \"Direct\".\n- Many bug fixes and cleanups were applied to the `nvmf_tgt` app and library.\n- The target now supports discovery.\n\nThis release also adds one new feature and provides some better examples and tools\nfor the NVMe driver.\n\n- The Weighted Round Robin arbitration method is now supported. This allows\n  the user to specify different priorities on a per-I/O-queue basis.  To\n  enable WRR, set the `arb_mechanism` field during `spdk_nvme_probe()`.\n- A simplified \"Hello World\" example was added to show the proper way to use\n  the NVMe library API; see `examples/nvme/hello_world/hello_world.c`.\n- A test for measuring software overhead was added. See `test/lib/nvme/overhead`.\n\n## v16.06: NVMf userspace target\n\nThis release adds a userspace NVMf (NVMe over Fabrics) target, conforming to the\nnewly-released NVMf 1.0/NVMe 1.2.1 specification.  The NVMf target exports NVMe\ndevices from a host machine over the network via RDMA.  Currently, the target is\nlimited to directly exporting physical NVMe devices, and the discovery subsystem\nis not supported.\n\nThis release includes a general API cleanup, including renaming all declarations\nin public headers to include a `spdk` prefix to prevent namespace clashes with\nuser code.\n\n- NVMe\n  - The `nvme_attach()` API was reworked into a new probe/attach model, which\n  moves device detection into the NVMe library.  The new API also allows\n  parallel initialization of NVMe controllers, providing a major reduction in\n  startup time when using multiple controllers.\n  - I/O queue allocation was changed to be explicit in the API.  Each function\n  that generates I/O requests now takes a queue pair (`spdk_nvme_qpair *`)\n  argument, and I/O queues may be allocated using\n  `spdk_nvme_ctrlr_alloc_io_qpair()`.  This allows more flexible assignment of\n  queue pairs than the previous model, which only allowed a single queue\n  per thread and limited the total number of I/O queues to the lowest number\n  supported on any attached controller.\n  - Added support for the Write Zeroes command.\n  - `examples/nvme/perf` can now report I/O command latency from the\n  the controller's viewpoint using the Intel vendor-specific read/write latency\n  log page.\n  - Added namespace reservation command support, which can be used to coordinate\n  sharing of a namespace between multiple hosts.\n  - Added hardware SGL support, which enables use of scattered buffers that\n  don't conform to the PRP list alignment and length requirements on supported\n  NVMe controllers.\n  - Added end-to-end data protection support, including the ability to write and\n  read metadata in extended LBA (metadata appended to each block of data in the\n  buffer) and separate metadata buffer modes.\n  See `spdk_nvme_ns_cmd_write_with_md()` and `spdk_nvme_ns_cmd_read_with_md()`\n  for details.\n- IOAT\n  - The DMA block fill feature is now exposed via the `ioat_submit_fill()`\n  function.  This is functionally similar to `memset()`, except the memory is\n  filled with an 8-byte repeating pattern instead of a single byte like memset.\n- PCI\n  - Added support for using DPDK for PCI device mapping in addition to the\n  existing libpciaccess option.  Using the DPDK PCI support also allows use of\n  the Linux VFIO driver model, which means that SPDK userspace drivers will work\n  with the IOMMU enabled.  Additionally, SPDK applications may be run as an\n  unprivileged user with access restricted to a specific set of PCIe devices.\n  - The PCI library API was made more generic to abstract away differences\n  between the underlying PCI access implementations.\n\n## v1.2.0: IOAT user-space driver\n\nThis release adds a user-space driver with support for the Intel I/O Acceleration Technology\n(I/OAT, also known as \"Crystal Beach\") DMA offload engine.\n\n- IOAT\n  - New user-space driver supporting DMA memory copy offload\n  - Example programs `ioat/perf` and `ioat/verify`\n  - Kernel-mode DMA engine test driver `kperf` for performance comparison\n- NVMe\n  - Per-I/O flags for Force Unit Access (FUA) and Limited Retry\n  - Public API for retrieving log pages\n  - Reservation register/acquire/release/report command support\n  - Scattered payload support - an alternate API to provide I/O buffers via a sequence of callbacks\n  - Declarations and `nvme/identify` support for Intel SSD DC P3700 series vendor-specific log pages and features\n- Updated to support DPDK 2.2.0\n\n## v1.0.0: NVMe user-space driver\n\nThis is the initial open source release of the Storage Performance Development Kit (SPDK).\n\nFeatures:\n\n- NVMe user-space driver\n- NVMe example programs\n  - `examples/nvme/perf` tests performance (IOPS) using the NVMe user-space driver\n  - `examples/nvme/identify` displays NVMe controller information in a human-readable format\n- Linux and FreeBSD support\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.3125,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual\nidentity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the overall\n  community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or advances of\n  any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email address,\n  without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nSPDK core [maintainers](https://spdk.io/development/) are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nSPDK core maintainers have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported privately to any of the SPDK core maintainers. All complaints will be\nreviewed and investigated promptly and fairly.\n\nAll SPDK core maintainers are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nSPDK core maintainers will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from SPDK core maintainers, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series of\nactions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or permanent\nban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior, harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within the\ncommunity.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.1, available at\n[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].\n\nCommunity Impact Guidelines were inspired by\n[Mozilla's code of conduct enforcement ladder][Mozilla CoC].\n\nFor answers to common questions about this code of conduct, see the FAQ at\n[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at\n[https://www.contributor-covenant.org/translations][translations].\n\n[homepage]: https://www.contributor-covenant.org\n[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html\n[Mozilla CoC]: https://github.com/mozilla/diversity\n[FAQ]: https://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONFIG",
          "type": "blob",
          "size": 5.5029296875,
          "content": "#  SPDX-License-Identifier: BSD-3-Clause\n#  Copyright (C) 2015 Intel Corporation.\n#  All rights reserved.\n#  Copyright (c) 2021, 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n#  Copyright (c) 2022 Dell Inc, or its subsidiaries.\n#\n\n# configure options: __CONFIGURE_OPTIONS__\n\n# Installation prefix\nCONFIG_PREFIX=\"/usr/local\"\n\n# Target architecture\nCONFIG_ARCH=native\n\n# Destination directory for the libraries\nCONFIG_LIBDIR=\n\n# Prefix for cross compilation\nCONFIG_CROSS_PREFIX=\n\n# Build with debug logging. Turn off for performance testing and normal usage\nCONFIG_DEBUG=n\n\n# Treat warnings as errors (fail the build on any warning).\nCONFIG_WERROR=n\n\n# Build with link-time optimization.\nCONFIG_LTO=n\n\n# Generate profile guided optimization data.\nCONFIG_PGO_CAPTURE=n\n\n# Use profile guided optimization data.\nCONFIG_PGO_USE=n\n\n# Place profile data in this directory\nCONFIG_PGO_DIR=\n\n# Build with code coverage instrumentation.\nCONFIG_COVERAGE=n\n\n# Build with Address Sanitizer enabled\nCONFIG_ASAN=n\n\n# Build with Undefined Behavior Sanitizer enabled\nCONFIG_UBSAN=n\n\n# Build with LLVM fuzzing enabled\nCONFIG_FUZZER=n\nCONFIG_FUZZER_LIB=\n\n# Build with Thread Sanitizer enabled\nCONFIG_TSAN=n\n\n# Build functional tests\nCONFIG_TESTS=y\n\n# Build unit tests\nCONFIG_UNIT_TESTS=y\n\n# Build examples\nCONFIG_EXAMPLES=y\n\n# Build apps\nCONFIG_APPS=y\n\n# Build with Control-flow Enforcement Technology (CET)\nCONFIG_CET=n\n\n# Directory that contains the desired SPDK environment library.\n# By default, this is implemented using DPDK.\nCONFIG_ENV=\n\n# This directory should contain 'include' and 'lib' directories for your DPDK\n# installation.\nCONFIG_DPDK_DIR=\n# Automatically set via pkg-config when bare --with-dpdk is set\nCONFIG_DPDK_LIB_DIR=\nCONFIG_DPDK_INC_DIR=\nCONFIG_DPDK_PKG_CONFIG=n\n\n# This directory should contain 'include' and 'lib' directories for WPDK.\nCONFIG_WPDK_DIR=\n\n# Build SPDK FIO plugin. Requires CONFIG_FIO_SOURCE_DIR set to a valid\n# fio source code directory.\nCONFIG_FIO_PLUGIN=n\n\n# This directory should contain the source code directory for fio\n# which is required for building the SPDK FIO plugin.\nCONFIG_FIO_SOURCE_DIR=/usr/src/fio\n\n# Enable RDMA support for the NVMf target.\n# Requires ibverbs development libraries.\nCONFIG_RDMA=n\nCONFIG_RDMA_SEND_WITH_INVAL=n\nCONFIG_RDMA_SET_ACK_TIMEOUT=n\nCONFIG_RDMA_SET_TOS=n\nCONFIG_RDMA_PROV=verbs\n\n# Enable NVMe Character Devices.\nCONFIG_NVME_CUSE=y\n\n# Enable FC support for the NVMf target.\n# Requires FC low level driver (from FC vendor)\nCONFIG_FC=n\nCONFIG_FC_PATH=\n\n# Build Ceph RBD support in bdev modules\n# Requires librbd development libraries\nCONFIG_RBD=n\n\n# Build DAOS support in bdev modules\n# Requires daos development libraries\nCONFIG_DAOS=n\nCONFIG_DAOS_DIR=\n\n# Build UBLK support\nCONFIG_UBLK=n\n\n# Build vhost library.\nCONFIG_VHOST=y\n\n# Build vhost initiator (Virtio) driver.\nCONFIG_VIRTIO=y\n\n# Build custom vfio-user transport for NVMf target and NVMe initiator.\nCONFIG_VFIO_USER=n\nCONFIG_VFIO_USER_DIR=\n\n# Build with xNVMe\nCONFIG_XNVME=n\n\n# Enable the dependencies for building the DPDK accel compress module\nCONFIG_DPDK_COMPRESSDEV=n\n\n# Enable the dependencies for building the compress vbdev, includes the reduce library\nCONFIG_VBDEV_COMPRESS=n\n\n# Enable mlx5_pci dpdk compress PMD, enabled automatically if CONFIG_VBDEV_COMPRESS=y and libmlx5 exists\nCONFIG_VBDEV_COMPRESS_MLX5=n\n\n# Enable mlx5_pci dpdk crypto PMD, enabled automatically if CONFIG_CRYPTO=y and libmlx5 exists\nCONFIG_CRYPTO_MLX5=n\n\n# Enable UADK dpdk crypto PMD\nCONFIG_DPDK_UADK=n\n\n# Requires libiscsi development libraries.\nCONFIG_ISCSI_INITIATOR=n\n\n# Enable the dependencies for building the crypto vbdev\nCONFIG_CRYPTO=n\n\n# Build spdk shared libraries in addition to the static ones.\nCONFIG_SHARED=n\n\n# Build with VTune support.\nCONFIG_VTUNE=n\nCONFIG_VTUNE_DIR=\n\n# Build Intel IPSEC_MB library\nCONFIG_IPSEC_MB=n\n\n# Enable OCF module\nCONFIG_OCF=n\nCONFIG_OCF_PATH=\nCONFIG_CUSTOMOCF=n\n\n# Build ISA-L library\nCONFIG_ISAL=y\n\n# Build ISA-L-crypto library\nCONFIG_ISAL_CRYPTO=y\n\n# Build with IO_URING support\nCONFIG_URING=n\n\n# Build IO_URING bdev with ZNS support\nCONFIG_URING_ZNS=n\n\n# Path to custom built IO_URING library\nCONFIG_URING_PATH=\n\n# Path to custom built OPENSSL library\nCONFIG_OPENSSL_PATH=\n\n# Build with FUSE support\nCONFIG_FUSE=n\n\n# Build with RAID5f support\nCONFIG_RAID5F=n\n\n# Build with IDXD support\n# In this mode, SPDK fully controls the DSA device.\nCONFIG_IDXD=n\n\n# Build with USDT support\nCONFIG_USDT=n\n\n# Build with IDXD kernel support.\n# In this mode, SPDK shares the DSA device with the kernel.\nCONFIG_IDXD_KERNEL=n\n\n# arc4random is available in stdlib.h\nCONFIG_HAVE_ARC4RANDOM=n\n\n# uuid_generate_sha1 is available in uuid/uuid.h\nCONFIG_HAVE_UUID_GENERATE_SHA1=n\n\n# Is DPDK using libbsd?\nCONFIG_HAVE_LIBBSD=n\n\n# Is DPDK using libarchive?\nCONFIG_HAVE_LIBARCHIVE=n\n\n# execinfo.h is available\nCONFIG_HAVE_EXECINFO_H=n\n\n# libkeytuils is available\nCONFIG_HAVE_KEYUTILS=n\n\n# OpenSSL has EVP_MAC definitions\nCONFIG_HAVE_EVP_MAC=n\n\n# Path to IPSEC_MB used by DPDK\nCONFIG_IPSEC_MB_DIR=\n\n# Generate Storage Management Agent's protobuf interface\nCONFIG_SMA=n\n\n# Build with Avahi support\nCONFIG_AVAHI=n\n\n# Setup DPDK's RTE_MAX_LCORES\nCONFIG_MAX_LCORES=128\n\n# Maximum number of iobuf NUMA nodes supported\nCONFIG_MAX_NUMA_NODES=1\n\n# Build all Go components\nCONFIG_GOLANG=n\n\n# Build fsdev\nCONFIG_FSDEV=y\n\n# Build with aio fsdev\nCONFIG_AIO_FSDEV=y\n\n# struct stat has st_atime field\nCONFIG_HAVE_STRUCT_STAT_ST_ATIM=n\n\n# struct stat has st_atimespec field\nCONFIG_HAVE_STRUCT_STAT_ST_ATIMESPEC=n\n\n# libc contains the copy_file_range\nCONFIG_COPY_FILE_RANGE=n\n\n# liblz4 is available\nCONFIG_HAVE_LZ4=n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.1318359375,
          "content": "# Contributing\n\nPlease see the [SPDK development guide](http://www.spdk.io/development/) for information on how to contribute to SPDK.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1005859375,
          "content": "The SPDK repo contains multiple git submodules each with its own\nlicense info.\n\nSubmodule license info:\ndpdk: see dpdk/license\nintel-ipsec-mb: see intel-ipsec-mb/LICENSE\nisa-l: see isa-l/LICENSE\nlibvfio-user: see libvfio-user/LICENSE\nocf: see ocf/LICENSE\n\nThe rest of the SPDK repository uses the Open Source BSD-3-Clause\nlicense.  SPDK also uses SPDX Unique License Identifiers to eliminate\nthe need to copy the license text into each individual file.\n\nAny new file contributions to SPDK shall adhere to the BSD-3-Clause\nlicense and use SPDX identifiers. Exceptions are subject to usual\nreview and must be listed in this file.\n\nExceptions:\n\n* include/linux/* header files are BSD-3-Clause but do not use SPDX\n  identifier to keep them identical to the same header files in the\n  Linux kernel source tree.\n\n* include/spdk/tree.h and include/spdk/queue_extras are BSD-2-Clause,\n  since there were primarily imported from FreeBSD.  tree.h uses an SPDX\n  identifier but also the license text to reduce differences from the\n  FreeBSD source tree.\n\n* lib/util/base64_neon.c is BSD-2-Clause.\n\n* lib/mlx5/mlx5_ifc.h is BSD-2-Clause .\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.5048828125,
          "content": "#  SPDX-License-Identifier: BSD-3-Clause\n#  Copyright (C) 2015 Intel Corporation.\n#  Copyright (c) 2020, Mellanox Corporation.\n#  Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES\n#  All rights reserved.\n#\n\nS :=\n\nSPDK_ROOT_DIR := $(CURDIR)\ninclude $(SPDK_ROOT_DIR)/mk/spdk.common.mk\n\nDIRS-y += lib\nDIRS-y += module\nDIRS-$(CONFIG_SHARED) += shared_lib\nDIRS-y += include\nDIRS-$(CONFIG_EXAMPLES) += examples\nDIRS-$(CONFIG_APPS) += app\nDIRS-y += test\nDIRS-$(CONFIG_IPSEC_MB) += ipsecbuild\nDIRS-$(CONFIG_ISAL) += isalbuild\nDIRS-$(CONFIG_ISAL_CRYPTO) += isalcryptobuild\nDIRS-$(CONFIG_VFIO_USER) += vfiouserbuild\nDIRS-$(CONFIG_SMA) += proto\nDIRS-$(CONFIG_XNVME) += xnvmebuild\nDIRS-$(CONFIG_GOLANG) += go/rpc\nDIRS-y += python\n\n.PHONY: all clean $(DIRS-y) include/spdk/config.h mk/config.mk \\\n\tcc_version cxx_version .libs_only_other .ldflags ldflags install \\\n\tuninstall\n\n# Workaround for ninja. See dpdkbuild/Makefile\nexport MAKE_PID := $(shell echo $$PPID)\n\nifeq ($(SPDK_ROOT_DIR)/lib/env_dpdk,$(CONFIG_ENV))\nifeq ($(CURDIR)/dpdk/build,$(CONFIG_DPDK_DIR))\nifneq ($(SKIP_DPDK_BUILD),1)\nifneq ($(CONFIG_DPDK_PKG_CONFIG),y)\nDPDKBUILD = dpdkbuild\nDIRS-y += dpdkbuild\nendif\nendif\nendif\nendif\n\nifeq ($(OS),Windows)\nifeq ($(CURDIR)/wpdk/build,$(CONFIG_WPDK_DIR))\nWPDK = wpdk\nDIRS-y += wpdk\nendif\nendif\n\nifeq ($(CONFIG_SHARED),y)\nLIB = shared_lib\nelse\nLIB = module\nendif\n\nifeq ($(CONFIG_IPSEC_MB),y)\nLIB += ipsecbuild\nDPDK_DEPS += ipsecbuild\nendif\n\nifeq ($(CONFIG_ISAL),y)\nISALBUILD = isalbuild\nLIB += isalbuild\nDPDK_DEPS += isalbuild\nifeq ($(CONFIG_ISAL_CRYPTO),y)\nISALCRYPTOBUILD = isalcryptobuild\nLIB += isalcryptobuild\nendif\nendif\n\nifeq ($(CONFIG_VFIO_USER),y)\nVFIOUSERBUILD = vfiouserbuild\nLIB += vfiouserbuild\nendif\n\nifeq ($(CONFIG_XNVME),y)\nXNVMEBUILD = xnvmebuild\nLIB += xnvmebuild\nendif\n\nall: mk/cc.mk $(DIRS-y)\nclean: $(DIRS-y)\n\t$(Q)rm -f include/spdk/config.h\n\t$(Q)rm -f include/spdk/version.h\n\t$(Q)rm -rf build\n\ninstall: all\n\t$(Q)echo \"Installed to $(DESTDIR)$(CONFIG_PREFIX)\"\n\nuninstall: $(DIRS-y)\n\t$(Q)echo \"Uninstalled spdk\"\n\nifneq ($(SKIP_DPDK_BUILD),1)\ndpdkdeps $(DPDK_DEPS): $(WPDK)\ndpdkbuild: $(WPDK) $(DPDK_DEPS)\nendif\n\nlib: $(WPDK) $(DPDKBUILD) $(VFIOUSERBUILD) $(XNVMEBUILD) $(ISALBUILD) $(ISALCRYPTOBUILD)\nmodule: lib\nshared_lib: module\napp: $(LIB)\ntest: $(LIB)\nexamples: $(LIB)\npkgdep:\n\tsh ./scripts/pkgdep.sh\n\n$(DIRS-y): mk/cc.mk build_dir include/spdk/config.h include/spdk/version.h\n\nmk/cc.mk:\n\t$(Q)echo \"Please run configure prior to make\"\n\tfalse\n\nbuild_dir: mk/cc.mk\n\t$(Q)mkdir -p build/lib/pkgconfig/tmp\n\t$(Q)mkdir -p build/bin\n\t$(Q)mkdir -p build/fio\n\t$(Q)mkdir -p build/examples\n\t$(Q)mkdir -p build/include/spdk\n\ninclude/spdk/config.h: mk/config.mk scripts/genconfig.py\n\t$(Q)echo \"#ifndef SPDK_CONFIG_H\" > $@.tmp; \\\n\techo \"#define SPDK_CONFIG_H\" >> $@.tmp; \\\n\tscripts/genconfig.py $(MAKEFLAGS) >> $@.tmp; \\\n\techo \"#endif /* SPDK_CONFIG_H */\" >> $@.tmp; \\\n\tcmp -s $@.tmp $@ || mv $@.tmp $@ ; \\\n\trm -f $@.tmp\n\ninclude/spdk/version.h: include/spdk/version.h.in VERSION\n\t$(Q)sed \" \\\n\t\ts/\\$$SPDK_VERSION_MAJOR/$(version_major)/g; \\\n\t\ts/\\$$SPDK_VERSION_MINOR/$(version_minor)/g; \\\n\t\ts/\\$$SPDK_VERSION_PATCH/$(version_patch)/g; \\\n\t\ts/\\$$SPDK_VERSION_SUFFIX/$(version_suffix)/g;\" \\\n\t\t$@.in > $@\n\ncc_version: mk/cc.mk\n\t$(Q)echo \"SPDK using CC=$(CC)\"; $(CC) -v\n\ncxx_version: mk/cc.mk\n\t$(Q)echo \"SPDK using CXX=$(CXX)\"; $(CXX) -v\n\n.libs_only_other:\n\t$(Q)echo -n '$(SYS_LIBS) '\n\t$(Q)if [ \"$(CONFIG_SHARED)\" = \"y\" ]; then \\\n\t\techo -n '-lspdk '; \\\n\tfi\n\n.ldflags:\n\t$(Q)echo -n '$(LDFLAGS) '\n\nldflags: .ldflags .libs_only_other\n\t$(Q)echo ''\n\ninclude $(SPDK_ROOT_DIR)/mk/spdk.subdirs.mk\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.3349609375,
          "content": "# Storage Performance Development Kit\n\n[![License](https://img.shields.io/github/license/spdk/spdk?style=flat-square&color=blue&label=License)](https://github.com/spdk/spdk/blob/master/LICENSE)\n[![Build Status](https://travis-ci.org/spdk/spdk.svg?branch=master)](https://travis-ci.org/spdk/spdk)\n[![Go Doc](https://img.shields.io/badge/godoc-reference-blue.svg)](http://godoc.org/github.com/spdk/spdk/go/rpc)\n[![Go Report Card](https://goreportcard.com/badge/github.com/spdk/spdk/go/rpc)](https://goreportcard.com/report/github.com/spdk/spdk/go/rpc)\n\nNOTE: The SPDK mailing list has moved to a new location. Please visit\n[this URL](https://lists.linuxfoundation.org/mailman/listinfo/spdk) to subscribe\nat the new location. Subscribers from the old location will not be automatically\nmigrated to the new location.\n\nThe Storage Performance Development Kit ([SPDK](http://www.spdk.io)) provides a set of tools\nand libraries for writing high performance, scalable, user-mode storage\napplications. It achieves high performance by moving all of the necessary\ndrivers into userspace and operating in a polled mode instead of relying on\ninterrupts, which avoids kernel context switches and eliminates interrupt\nhandling overhead.\n\nThe development kit currently includes:\n\n* [NVMe driver](http://www.spdk.io/doc/nvme.html)\n* [I/OAT (DMA engine) driver](http://www.spdk.io/doc/ioat.html)\n* [NVMe over Fabrics target](http://www.spdk.io/doc/nvmf.html)\n* [iSCSI target](http://www.spdk.io/doc/iscsi.html)\n* [vhost target](http://www.spdk.io/doc/vhost.html)\n* [Virtio-SCSI driver](http://www.spdk.io/doc/virtio.html)\n\n## In this readme\n\n* [Documentation](#documentation)\n* [Prerequisites](#prerequisites)\n* [Source Code](#source)\n* [Build](#libraries)\n* [Unit Tests](#tests)\n* [Vagrant](#vagrant)\n* [AWS](#aws)\n* [Advanced Build Options](#advanced)\n* [Shared libraries](#shared)\n* [Hugepages and Device Binding](#huge)\n* [Example Code](#examples)\n* [Contributing](#contributing)\n\n<a id=\"documentation\"></a>\n## Documentation\n\n[Doxygen API documentation](http://www.spdk.io/doc/) is available, as\nwell as a [Porting Guide](http://www.spdk.io/doc/porting.html) for porting SPDK to different frameworks\nand operating systems.\n\n<a id=\"source\"></a>\n## Source Code\n\n~~~{.sh}\ngit clone https://github.com/spdk/spdk\ncd spdk\ngit submodule update --init\n~~~\n\n<a id=\"prerequisites\"></a>\n## Prerequisites\n\nThe dependencies can be installed automatically by `scripts/pkgdep.sh`.\nThe `scripts/pkgdep.sh` script will automatically install the bare minimum\ndependencies required to build SPDK.\nUse `--help` to see information on installing dependencies for optional components\n\n~~~{.sh}\n./scripts/pkgdep.sh\n~~~\n\n<a id=\"libraries\"></a>\n## Build\n\nLinux:\n\n~~~{.sh}\n./configure\nmake\n~~~\n\nFreeBSD:\nNote: Make sure you have the matching kernel source in /usr/src/ and\nalso note that CONFIG_COVERAGE option is not available right now\nfor FreeBSD builds.\n\n~~~{.sh}\n./configure\ngmake\n~~~\n\n<a id=\"tests\"></a>\n## Unit Tests\n\n~~~{.sh}\n./test/unit/unittest.sh\n~~~\n\nYou will see several error messages when running the unit tests, but they are\npart of the test suite. The final message at the end of the script indicates\nsuccess or failure.\n\n<a id=\"vagrant\"></a>\n## Vagrant\n\nA [Vagrant](https://www.vagrantup.com/downloads.html) setup is also provided\nto create a Linux VM with a virtual NVMe controller to get up and running\nquickly.  Currently this has been tested on MacOS, Ubuntu 16.04.2 LTS and\nUbuntu 18.04.3 LTS with the VirtualBox and Libvirt provider.\nThe [VirtualBox Extension Pack](https://www.virtualbox.org/wiki/Downloads)\nor [Vagrant Libvirt] (https://github.com/vagrant-libvirt/vagrant-libvirt) must\nalso be installed in order to get the required NVMe support.\n\nDetails on the Vagrant setup can be found in the\n[SPDK Vagrant documentation](http://spdk.io/doc/vagrant.html).\n\n<a id=\"aws\"></a>\n## AWS\n\nThe following setup is known to work on AWS:\nImage: Ubuntu 18.04\nBefore running  `setup.sh`, run `modprobe vfio-pci`\nthen: `DRIVER_OVERRIDE=vfio-pci ./setup.sh`\n\n<a id=\"advanced\"></a>\n## Advanced Build Options\n\nOptional components and other build-time configuration are controlled by\nsettings in the Makefile configuration file in the root of the repository. `CONFIG`\ncontains the base settings for the `configure` script. This script generates a new\nfile, `mk/config.mk`, that contains final build settings. For advanced configuration,\nthere are a number of additional options to `configure` that may be used, or\n`mk/config.mk` can simply be created and edited by hand. A description of all\npossible options is located in `CONFIG`.\n\nBoolean (on/off) options are configured with a 'y' (yes) or 'n' (no). For\nexample, this line of `CONFIG` controls whether the optional RDMA (libibverbs)\nsupport is enabled:\n\n~~~{.sh}\nCONFIG_RDMA?=n\n~~~\n\nTo enable RDMA, this line may be added to `mk/config.mk` with a 'y' instead of\n'n'. For the majority of options this can be done using the `configure` script.\nFor example:\n\n~~~{.sh}\n./configure --with-rdma\n~~~\n\nAdditionally, `CONFIG` options may also be overridden on the `make` command\nline:\n\n~~~{.sh}\nmake CONFIG_RDMA=y\n~~~\n\nUsers may wish to use a version of DPDK different from the submodule included\nin the SPDK repository.  Note, this includes the ability to build not only\nfrom DPDK sources, but also just with the includes and libraries\ninstalled via the dpdk and dpdk-devel packages.  To specify an alternate DPDK\ninstallation, run configure with the --with-dpdk option.  For example:\n\nLinux:\n\n~~~{.sh}\n./configure --with-dpdk=/path/to/dpdk/x86_64-native-linuxapp-gcc\nmake\n~~~\n\nFreeBSD:\n\n~~~{.sh}\n./configure --with-dpdk=/path/to/dpdk/x86_64-native-bsdapp-clang\ngmake\n~~~\n\nThe options specified on the `make` command line take precedence over the\nvalues in `mk/config.mk`. This can be useful if you, for example, generate\na `mk/config.mk` using the `configure` script and then have one or two\noptions (i.e. debug builds) that you wish to turn on and off frequently.\n\n<a id=\"shared\"></a>\n## Shared libraries\n\nBy default, the build of the SPDK yields static libraries against which\nthe SPDK applications and examples are linked.\nConfigure option `--with-shared` provides the ability to produce SPDK shared\nlibraries, in addition to the default static ones.  Use of this flag also\nresults in the SPDK executables linked to the shared versions of libraries.\nSPDK shared libraries by default, are located in `./build/lib`.  This includes\nthe single SPDK shared lib encompassing all of the SPDK static libs\n(`libspdk.so`) as well as individual SPDK shared libs corresponding to each\nof the SPDK static ones.\n\nIn order to start a SPDK app linked with SPDK shared libraries, make sure\nto do the following steps:\n\n- run ldconfig specifying the directory containing SPDK shared libraries\n- provide proper `LD_LIBRARY_PATH`\n\nIf DPDK shared libraries are used, you may also need to add DPDK shared\nlibraries to `LD_LIBRARY_PATH`\n\nLinux:\n\n~~~{.sh}\n./configure --with-shared\nmake\nldconfig -v -n ./build/lib\nLD_LIBRARY_PATH=./build/lib/:./dpdk/build/lib/ ./build/bin/spdk_tgt\n~~~\n\n<a id=\"huge\"></a>\n## Hugepages and Device Binding\n\nBefore running an SPDK application, some hugepages must be allocated and\nany NVMe and I/OAT devices must be unbound from the native kernel drivers.\nSPDK includes a script to automate this process on both Linux and FreeBSD.\nThis script should be run as root.\n\n~~~{.sh}\nsudo scripts/setup.sh\n~~~\n\nUsers may wish to configure a specific memory size. Below is an example of\nconfiguring 8192MB memory.\n\n~~~{.sh}\nsudo HUGEMEM=8192 scripts/setup.sh\n~~~\n\nThere are a lot of other environment variables that can be set to configure\nsetup.sh for advanced users. To see the full list, run:\n\n~~~{.sh}\nscripts/setup.sh --help\n~~~\n\n<a id=\"targets\"></a>\n## Target applications\n\nAfter completing the build process, SPDK target applications can be found in\n`spdk/build/bin` directory:\n\n* [nvmf_tgt](https://spdk.io/doc/nvmf.html) - SPDK NVMe over Fabrics target\n  presents block devices over a fabrics,\n* [iscsi_tgt](https://spdk.io/doc/iscsi.html) - SPDK iSCSI target runs I/O\n  operations remotely with TCP/IP protocol,\n* [vhost](https://spdk.io/doc/vhost.html) - A vhost target provides a local\n  storage service as a process running on a local machine,\n* spdk_tgt - combines capabilities of all three applications.\n\nSPDK runs in a polled mode, which means it continuously checks for operation completions.\nThis approach assures faster response than interrupt mode, but also lessens usefulness\nof tools like `top`, which only shows 100% CPU usage for SPDK assigned cores.\n[spdk_top](https://spdk.io/doc/spdk_top.html) is a program which simulates `top` application\nand uses SPDK's [JSON RPC](https://spdk.io/doc/jsonrpc.html) interface to present statistics\nabout SPDK threads, pollers and CPU cores as an interactive list.\n\n<a id=\"examples\"></a>\n## Example Code\n\nExample code is located in the examples directory. The examples are compiled\nautomatically as part of the build process. Simply call any of the examples\nwith no arguments to see the help output. You'll likely need to run the examples\nas a privileged user (root) unless you've done additional configuration\nto grant your user permission to allocate huge pages and map devices through\nvfio.\n\n<a id=\"contributing\"></a>\n## Contributing\n\nFor additional details on how to get more involved in the community, including\n[contributing code](http://www.spdk.io/development) and participating in discussions and other activities, please\nrefer to [spdk.io](http://www.spdk.io/community)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.20703125,
          "content": "# Security Policy\n\nThe SPDK community has a documented CVE process [here](https://spdk.io/cve_threat/) that describes\nboth how to report a potential security issue as well as who to contact for more information.\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.01171875,
          "content": "25.01.0-pre\n"
        },
        {
          "name": "app",
          "type": "tree",
          "content": null
        },
        {
          "name": "autobuild.sh",
          "type": "blob",
          "size": 1.5498046875,
          "content": "#!/usr/bin/env bash\n#  SPDX-License-Identifier: BSD-3-Clause\n#  Copyright (C) 2015 Intel Corporation\n#  All rights reserved.\n#\n\nrootdir=$(readlink -f $(dirname $0))\n\nsource \"$rootdir/test/common/autobuild_common.sh\"\n\nSPDK_TEST_AUTOBUILD=${SPDK_TEST_AUTOBUILD:-}\numask 022\ncd $rootdir\n\n# Print some test system info out for the log\ndate -u\ngit describe --tags\n\nif [ $SPDK_RUN_ASAN -eq 1 ]; then\n\trun_test \"asan\" echo \"using asan\"\nfi\n\nif [ $SPDK_RUN_UBSAN -eq 1 ]; then\n\trun_test \"ubsan\" echo \"using ubsan\"\nfi\n\nif [ -n \"$SPDK_TEST_NATIVE_DPDK\" ]; then\n\tbuild_native_dpdk\nfi\n\ncase \"$SPDK_TEST_AUTOBUILD\" in\n\tfull)\n\t\t$rootdir/configure $config_params\n\t\techo \"** START ** Info for Hostname: $HOSTNAME\"\n\t\tuname -a\n\t\t$MAKE cc_version\n\t\t$MAKE cxx_version\n\t\techo \"** END ** Info for Hostname: $HOSTNAME\"\n\t\t;;\n\text | tiny | \"\") ;;\n\t*)\n\t\techo \"ERROR: supported values for SPDK_TEST_AUTOBUILD are 'full', 'tiny' and 'ext'\"\n\t\texit 1\n\t\t;;\nesac\n\nif [[ $SPDK_TEST_OCF -eq 1 ]]; then\n\tocf_precompile\nfi\n\nif [[ $SPDK_TEST_FUZZER -eq 1 ]]; then\n\tllvm_precompile\nfi\n\nif [[ -n $SPDK_TEST_AUTOBUILD ]]; then\n\tautobuild_test_suite\nelif [[ $SPDK_TEST_UNITTEST -eq 1 ]]; then\n\tunittest_build\nelif [[ $SPDK_TEST_SCANBUILD -eq 1 ]]; then\n\tscanbuild_make\nelse\n\tif [[ $SPDK_TEST_FUZZER -eq 1 ]]; then\n\t\t# if we are testing nvmf fuzz with llvm lib, --with-shared will cause lib link fail\n\t\t$rootdir/configure $config_params\n\telse\n\t\t# if we aren't testing the unittests, build with shared objects.\n\t\t$rootdir/configure $config_params --with-shared\n\tfi\n\t# shellcheck disable=SC2031\n\trun_test \"make\" $MAKE $MAKEFLAGS\nfi\n"
        },
        {
          "name": "autorun.sh",
          "type": "blob",
          "size": 0.634765625,
          "content": "#!/usr/bin/env bash\n#  SPDX-License-Identifier: BSD-3-Clause\n#  Copyright (C) 2016 Intel Corporation\n#  All rights reserved.\n#\n\nset -e\n\nrootdir=$(readlink -f $(dirname $0))\n\ndefault_conf=~/autorun-spdk.conf\nconf=${1:-${default_conf}}\n\n# If the configuration of tests is not provided, no tests will be carried out.\nif [[ ! -f $conf ]]; then\n\techo \"ERROR: $conf doesn't exist\"\n\texit 1\nfi\nsource \"$rootdir/test/common/autotest_common.sh\"\nsource \"$conf\"\n\ntrap 'timing_finish || exit 1' EXIT\n\n# Runs agent scripts\n$rootdir/autobuild.sh \"$conf\"\nif ((SPDK_TEST_UNITTEST == 1 || SPDK_RUN_FUNCTIONAL_TEST == 1)); then\n\tsudo -E $rootdir/autotest.sh \"$conf\"\nfi\n"
        },
        {
          "name": "autorun_post.py",
          "type": "blob",
          "size": 8.4189453125,
          "content": "#!/usr/bin/python3\n#  SPDX-License-Identifier: BSD-3-Clause\n#  Copyright (C) 2017 Intel Corporation.\n#  All rights reserved.\n\n\nimport shutil\nimport subprocess\nimport argparse\nimport itertools\nimport os\nimport sys\nimport glob\nimport re\nimport pandas as pd\n\n\ndef generateTestCompletionTableByTest(output_dir, data_table):\n    columns_to_group = ['Domain', 'Test', 'Agent']\n\n    total_tests_number = len(data_table.groupby('Test'))\n\n    has_agent = data_table['Agent'] != 'None'\n    data_table_with_agent = data_table[has_agent]\n    executed_tests = len(data_table_with_agent.groupby('Test'))\n    tests_executions = len(data_table_with_agent.groupby(columns_to_group))\n\n    pivot_by_test = pd.pivot_table(data_table, index=columns_to_group, aggfunc=any)\n\n    output_file = os.path.join(output_dir, 'post_process', 'completions_table_by_test.html')\n    with open(output_file, 'w') as f:\n        table_row = '<tr><td>{}</td><td>{}</td>\\n'\n        f.write('<table>\\n')\n        f.write(table_row.format('Total number of tests', total_tests_number))\n        f.write(table_row.format('Tests executed', executed_tests))\n        f.write(table_row.format('Number of test executions', tests_executions))\n        f.write('</table>\\n')\n        f.write(pivot_by_test.to_html(None))\n\n\ndef generateTestCompletionTables(output_dir, completion_table):\n    data_table = pd.DataFrame(completion_table, columns=[\"Agent\", \"Domain\", \"Test\", \"With Asan\", \"With UBsan\"])\n    data_table.to_html(os.path.join(output_dir, 'completions_table.html'))\n    os.makedirs(os.path.join(output_dir, \"post_process\"), exist_ok=True)\n\n    pivot_by_agent = pd.pivot_table(data_table, index=[\"Agent\", \"Domain\", \"Test\"], aggfunc=any)\n    pivot_by_agent.to_html(os.path.join(output_dir, \"post_process\", 'completions_table_by_agent.html'))\n\n    generateTestCompletionTableByTest(output_dir, data_table)\n\n    pivot_by_asan = pd.pivot_table(data_table, index=[\"Domain\", \"Test\"], values=[\"With Asan\"], aggfunc=any)\n    pivot_by_asan.to_html(os.path.join(output_dir, \"post_process\", 'completions_table_by_asan.html'))\n    pivot_by_ubsan = pd.pivot_table(data_table, index=[\"Domain\", \"Test\"], values=[\"With UBsan\"], aggfunc=any)\n    pivot_by_ubsan.to_html(os.path.join(output_dir, \"post_process\", 'completions_table_by_ubsan.html'))\n\n\ndef generateCoverageReport(output_dir, repo_dir):\n    coveragePath = os.path.join(output_dir, '**', 'cov_total.info')\n    covfiles = [os.path.abspath(p) for p in glob.glob(coveragePath, recursive=True)]\n    for f in covfiles:\n        print(f)\n    if len(covfiles) == 0:\n        return\n    lcov_opts = [\n        '--rc', 'lcov_branch_coverage=1',\n        '--rc', 'lcov_function_coverage=1',\n        '--rc', 'genhtml_branch_coverage=1',\n        '--rc', 'genhtml_function_coverage=1',\n        '--rc', 'genhtml_legend=1',\n        '--rc', 'geninfo_all_blocks=1',\n    ]\n\n    # HACK: This is a workaround for some odd CI assumptions\n    details = '--show-details'\n\n    cov_total = os.path.abspath(os.path.join(output_dir, 'cov_total.info'))\n    coverage = os.path.join(output_dir, 'coverage')\n    lcov = ['lcov', *lcov_opts, '-q', *itertools.chain(*[('-a', f) for f in covfiles]), '-o', cov_total]\n    genhtml = ['genhtml', *lcov_opts, '-q', cov_total, '--legend', '-t', 'Combined', *details.split(), '-o', coverage]\n    try:\n        subprocess.check_call(lcov)\n    except subprocess.CalledProcessError as e:\n        print(\"lcov failed\")\n        print(e)\n        return\n\n    with open(cov_total, 'r') as cov_total_file:\n        file_contents = cov_total_file.readlines()\n\n    replacement = \"SF:\" + repo_dir\n    os.remove(cov_total)\n    with open(cov_total, 'w+') as file:\n        for Line in file_contents:\n            Line = re.sub(\"^SF:.*/repo\", replacement, Line)\n            file.write(Line + '\\n')\n    try:\n        subprocess.check_call(genhtml)\n    except subprocess.CalledProcessError as e:\n        print(\"genhtml failed\")\n        print(e)\n    for f in covfiles:\n        os.remove(f)\n\n\ndef collectOne(output_dir, dir_name):\n    dirs = glob.glob(os.path.join(output_dir, '*', dir_name))\n    dirs.sort()\n    if len(dirs) == 0:\n        return\n\n    # Collect first instance of dir_name and move it to the top level\n    collect_dir = dirs.pop(0)\n    shutil.move(collect_dir, os.path.join(output_dir, dir_name))\n\n    # Delete all other instances\n    for d in dirs:\n        shutil.rmtree(d)\n\n\ndef getCompletions(completionFile, test_list, test_completion_table):\n    agent_name = os.path.basename(os.path.dirname(completionFile))\n    with open(completionFile, 'r') as completionList:\n        completions = completionList.read()\n\n    asan_enabled = \"asan\" in completions\n    ubsan_enabled = \"ubsan\" in completions\n\n    for line in completions.splitlines():\n        try:\n            domain, test_name = line.strip().split()\n            test_list[test_name] = (True, asan_enabled | test_list[test_name][1], ubsan_enabled | test_list[test_name][2])\n            test_completion_table.append([agent_name, domain, test_name, asan_enabled, ubsan_enabled])\n            try:\n                test_completion_table.remove([\"None\", \"None\", test_name, False, False])\n            except ValueError:\n                continue\n        except KeyError:\n            continue\n\n\ndef printList(header, test_list, index, condition):\n    print(\"\\n\\n-----%s------\" % header)\n    executed_tests = [x for x in sorted(test_list) if test_list[x][index] is condition]\n    print(*executed_tests, sep=\"\\n\")\n\n\ndef printListInformation(table_type, test_list):\n    printList(\"%s Executed in Build\" % table_type, test_list, 0, True)\n    printList(\"%s Missing From Build\" % table_type, test_list, 0, False)\n    printList(\"%s Missing ASAN\" % table_type, test_list, 1, False)\n    printList(\"%s Missing UBSAN\" % table_type, test_list, 2, False)\n\n\ndef getSkippedTests(repo_dir):\n    skipped_test_file = os.path.join(repo_dir, \"test\", \"common\", \"skipped_tests.txt\")\n    if not os.path.exists(skipped_test_file):\n        return []\n\n    with open(skipped_test_file, \"r\") as skipped_test_data:\n        return [x.strip() for x in skipped_test_data.readlines() if \"#\" not in x and x.strip() != '']\n\n\ndef confirmPerPatchTests(test_list, skiplist):\n    missing_tests = [x for x in sorted(test_list) if test_list[x][0] is False\n                     and x not in skiplist]\n    if len(missing_tests) > 0:\n        print(\"Not all tests were run. Failing the build.\")\n        print(missing_tests)\n        sys.exit(1)\n\n\ndef aggregateCompletedTests(output_dir, repo_dir, skip_confirm=False):\n    test_list = {}\n    test_completion_table = []\n\n    testFiles = glob.glob(os.path.join(output_dir, '**', 'all_tests.txt'), recursive=True)\n    completionFiles = glob.glob(os.path.join(output_dir, '**', 'test_completions.txt'), recursive=True)\n\n    if len(testFiles) == 0:\n        print(\"Unable to perform test completion aggregator. No input files.\")\n        return 0\n\n    with open(testFiles[0], 'r') as raw_test_list:\n        for line in raw_test_list:\n            try:\n                test_name = line.strip()\n            except Exception:\n                print(\"Failed to parse a test type.\")\n                return 1\n\n            test_list[test_name] = (False, False, False)\n            test_completion_table.append([\"None\", \"None\", test_name, False, False])\n\n    for completionFile in completionFiles:\n        getCompletions(completionFile, test_list, test_completion_table)\n\n    printListInformation(\"Tests\", test_list)\n    generateTestCompletionTables(output_dir, test_completion_table)\n    skipped_tests = getSkippedTests(repo_dir)\n    if not skip_confirm:\n        confirmPerPatchTests(test_list, skipped_tests)\n\n    return 0\n\n\ndef main(output_dir, repo_dir, skip_confirm=False):\n    print(\"-----Begin Post Process Script------\")\n    generateCoverageReport(output_dir, repo_dir)\n    collectOne(output_dir, 'doc')\n    collectOne(output_dir, 'ut_coverage')\n    aggregateCompletedTests(output_dir, repo_dir, skip_confirm)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"SPDK Coverage Processor\")\n    parser.add_argument(\"-d\", \"--directory_location\", type=str, required=True,\n                        help=\"The location of your build's output directory\")\n    parser.add_argument(\"-r\", \"--repo_directory\", type=str, required=True,\n                        help=\"The location of your spdk repository\")\n    parser.add_argument(\"-s\", \"--skip_confirm\", required=False, action=\"store_true\",\n                        help=\"Do not check if all autotest.sh tests were executed.\")\n    args = parser.parse_args()\n    main(args.directory_location, args.repo_directory, args.skip_confirm)\n"
        },
        {
          "name": "autotest.sh",
          "type": "blob",
          "size": 13.7744140625,
          "content": "#!/usr/bin/env bash\n#  SPDX-License-Identifier: BSD-3-Clause\n#  Copyright (C) 2015 Intel Corporation\n#  All rights reserved.\n#\n\nrootdir=$(readlink -f $(dirname $0))\n\n# In autotest_common.sh all tests are disabled by default.\n# If the configuration of tests is not provided, no tests will be carried out.\nif [[ ! -f $1 ]]; then\n\techo \"ERROR: SPDK test configuration not specified\"\n\texit 1\nfi\n\n# Autotest.sh, as part of autorun.sh, runs in a different\n# shell process than autobuild.sh. Use helper file to pass\n# over env variable containing libraries paths.\nif [[ -e /tmp/spdk-ld-path ]]; then\n\tsource /tmp/spdk-ld-path\nfi\n\nsource \"$1\"\nsource \"$rootdir/test/common/autotest_common.sh\"\nsource \"$rootdir/test/nvmf/common.sh\"\n\nif [ $EUID -ne 0 ]; then\n\techo \"$0 must be run as root\"\n\texit 1\nfi\n\nif [ $(uname -s) = Linux ]; then\n\told_core_pattern=$(< /proc/sys/kernel/core_pattern)\n\tmkdir -p \"$output_dir/coredumps\"\n\t# Set core_pattern to a known value to avoid ABRT, systemd-coredump, etc.\n\t# Dump the $output_dir path to a file so collector can pick it up while executing.\n\t# We don't set in in the core_pattern command line because of the string length limitation\n\t# of 128 bytes. See 'man core 5' for details.\n\techo \"|$rootdir/scripts/core-collector.sh %P %s %t\" > /proc/sys/kernel/core_pattern\n\techo \"$output_dir/coredumps\" > \"$rootdir/.coredump_path\"\n\n\t# make sure nbd (network block device) driver is loaded if it is available\n\t# this ensures that when tests need to use nbd, it will be fully initialized\n\tmodprobe nbd || true\n\n\tif udevadm=$(type -P udevadm); then\n\t\t\"$udevadm\" monitor --property &> \"$output_dir/udev.log\" &\n\t\tudevadm_pid=$!\n\tfi\n\nfi\n\nstart_monitor_resources\n\ntrap \"autotest_cleanup || :; exit 1\" SIGINT SIGTERM EXIT\n\ntiming_enter autotest\n\ncreate_test_list\n\nsrc=$(readlink -f $(dirname $0))\nout=$output_dir\ncd $src\n\nfreebsd_update_contigmem_mod\nfreebsd_set_maxsock_buf\n\nif [[ $CONFIG_COVERAGE == y ]]; then\n\t# Print lcov version to log\n\t$LCOV --version\n\t# zero out coverage data\n\t$LCOV -q -c --no-external -i -t \"Baseline\" -d $src -o $out/cov_base.info\nfi\n\n# Make sure the disks are clean (no leftover partition tables)\ntiming_enter pre_cleanup\n# Remove old domain socket pathname just in case\nrm -f /var/tmp/spdk*.sock\n\n# Load the kernel driver\n$rootdir/scripts/setup.sh reset\n\nget_zoned_devs\n\nif ((${#zoned_devs[@]} > 0)); then\n\t# FIXME: For now make sure zoned devices are tested on-demand by\n\t# a designated tests instead of falling into any other. The main\n\t# concern here are fio workloads where specific configuration\n\t# must be in place for it to work with the zoned device.\n\texport PCI_BLOCKED=\"${zoned_devs[*]}\"\n\texport PCI_ZONED=\"${zoned_devs[*]}\"\nfi\n\n# Delete all leftover lvols and gpt partitions\n# Matches both /dev/nvmeXnY on Linux and /dev/nvmeXnsY on BSD\n# Filter out nvme with partitions - the \"p*\" suffix\nfor dev in /dev/nvme*n!(*p*); do\n\t# Skip zoned devices as non-sequential IO will always fail\n\t[[ -z ${zoned_devs[\"${dev##*/}\"]} ]] || continue\n\tif ! block_in_use \"$dev\"; then\n\t\tdd if=/dev/zero of=\"$dev\" bs=1M count=1\n\tfi\ndone\n\nsync\n\nif ! xtrace_disable_per_cmd reap_spdk_processes; then\n\techo \"WARNING: Lingering SPDK processes were detected. Testing environment may be unstable\" >&2\nfi\n\nif [[ $(uname -s) == Linux && $SPDK_TEST_SETUP -eq 1 ]]; then\n\trun_test \"setup.sh\" \"$rootdir/test/setup/test-setup.sh\"\nfi\n\n$rootdir/scripts/setup.sh status\n\nif [[ $(uname -s) == Linux ]]; then\n\t# Revert NVMe namespaces to default state\n\tnvme_namespace_revert\nfi\n\ntiming_exit pre_cleanup\n\n# set up huge pages\ntiming_enter afterboot\n$rootdir/scripts/setup.sh\ntiming_exit afterboot\n\n# Revert existing OPAL to factory settings that may have been left from earlier failed tests.\n# This ensures we won't hit any unexpected failures due to NVMe SSDs being locked.\nopal_revert_cleanup\n\n#####################\n# Unit Tests\n#####################\n\nif [ $SPDK_TEST_UNITTEST -eq 1 ]; then\n\trun_test \"unittest\" $rootdir/test/unit/unittest.sh\nfi\n\nif [ $SPDK_RUN_FUNCTIONAL_TEST -eq 1 ]; then\n\tif [[ $SPDK_TEST_CRYPTO -eq 1 || $SPDK_TEST_VBDEV_COMPRESS -eq 1 ]]; then\n\t\tif [[ $SPDK_TEST_USE_IGB_UIO -eq 1 ]]; then\n\t\t\t$rootdir/scripts/qat_setup.sh igb_uio\n\t\telse\n\t\t\t$rootdir/scripts/qat_setup.sh\n\t\tfi\n\tfi\n\ttiming_enter lib\n\n\tif [[ $SPDK_TEST_URING -eq 1 ]]; then\n\t\texport SPDK_SOCK_IMPL_DEFAULT=\"uring\"\n\tfi\n\n\trun_test \"env\" $rootdir/test/env/env.sh\n\trun_test \"rpc\" $rootdir/test/rpc/rpc.sh\n\trun_test \"skip_rpc\" $rootdir/test/rpc/skip_rpc.sh\n\trun_test \"rpc_client\" $rootdir/test/rpc_client/rpc_client.sh\n\trun_test \"json_config\" $rootdir/test/json_config/json_config.sh\n\trun_test \"json_config_extra_key\" $rootdir/test/json_config/json_config_extra_key.sh\n\trun_test \"alias_rpc\" $rootdir/test/json_config/alias_rpc/alias_rpc.sh\n\n\tif [[ $SPDK_JSONRPC_GO_CLIENT -eq 0 ]]; then\n\t\trun_test \"spdkcli_tcp\" $rootdir/test/spdkcli/tcp.sh\n\tfi\n\n\trun_test \"dpdk_mem_utility\" $rootdir/test/dpdk_memory_utility/test_dpdk_mem_info.sh\n\trun_test \"event\" $rootdir/test/event/event.sh\n\trun_test \"thread\" $rootdir/test/thread/thread.sh\n\n\tif [[ $SPDK_TEST_ACCEL -eq 1 ]]; then\n\t\trun_test \"accel\" $rootdir/test/accel/accel.sh\n\t\trun_test \"accel_rpc\" $rootdir/test/accel/accel_rpc.sh\n\tfi\n\n\trun_test \"app_cmdline\" $rootdir/test/app/cmdline.sh\n\trun_test \"version\" $rootdir/test/app/version.sh\n\n\tif [ $SPDK_TEST_BLOCKDEV -eq 1 ]; then\n\t\trun_test \"blockdev_general\" $rootdir/test/bdev/blockdev.sh\n\t\trun_test \"bdevperf_config\" $rootdir/test/bdev/bdevperf/test_config.sh\n\t\tif [[ $(uname -s) == Linux ]]; then\n\t\t\trun_test \"reactor_set_interrupt\" $rootdir/test/interrupt/reactor_set_interrupt.sh\n\t\t\trun_test \"reap_unregistered_poller\" $rootdir/test/interrupt/reap_unregistered_poller.sh\n\t\tfi\n\tfi\n\n\tif [[ $SPDK_TEST_RAID -eq 1 ]]; then\n\t\trun_test \"bdev_raid\" $rootdir/test/bdev/bdev_raid.sh\n\t\trun_test \"spdkcli_raid\" $rootdir/test/spdkcli/raid.sh\n\t\trun_test \"blockdev_raid5f\" $rootdir/test/bdev/blockdev.sh \"raid5f\"\n\tfi\n\n\tif [[ $(uname -s) == Linux ]]; then\n\t\tif [[ $SPDK_TEST_BLOCKDEV -eq 1 || $SPDK_TEST_URING -eq 1 ]]; then\n\t\t\t# The crypto job also includes the SPDK_TEST_BLOCKDEV in its configuration hence the\n\t\t\t# dd tests are executed there as well. However, these tests can take a significant\n\t\t\t# amount of time to complete (up to 4min) on a physical system leading to a potential\n\t\t\t# job timeout. Avoid that by skipping these tests - this should not affect the coverage\n\t\t\t# since dd tests are still run as part of the vg jobs.\n\t\t\tif [[ $SPDK_TEST_CRYPTO -eq 0 ]]; then\n\t\t\t\trun_test \"spdk_dd\" $rootdir/test/dd/dd.sh\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tif [ $SPDK_TEST_NVME -eq 1 ]; then\n\t\trun_test \"blockdev_nvme\" $rootdir/test/bdev/blockdev.sh \"nvme\"\n\t\tif [[ $(uname -s) == Linux ]]; then\n\t\t\trun_test \"blockdev_nvme_gpt\" $rootdir/test/bdev/blockdev.sh \"gpt\"\n\t\tfi\n\t\trun_test \"nvme\" $rootdir/test/nvme/nvme.sh\n\t\tif [[ $SPDK_TEST_NVME_PMR -eq 1 ]]; then\n\t\t\trun_test \"nvme_pmr\" $rootdir/test/nvme/nvme_pmr.sh\n\t\tfi\n\n\t\trun_test \"nvme_scc\" $rootdir/test/nvme/nvme_scc.sh\n\n\t\tif [[ $SPDK_TEST_NVME_BP -eq 1 ]]; then\n\t\t\trun_test \"nvme_bp\" $rootdir/test/nvme/nvme_bp.sh\n\t\tfi\n\t\tif [[ $SPDK_TEST_NVME_CUSE -eq 1 ]]; then\n\t\t\trun_test \"nvme_cuse\" $rootdir/test/nvme/cuse/nvme_cuse.sh\n\t\tfi\n\t\tif [[ $SPDK_TEST_NVME_CMB -eq 1 ]]; then\n\t\t\trun_test \"nvme_cmb\" $rootdir/test/nvme/cmb/cmb.sh\n\t\tfi\n\t\tif [[ $SPDK_TEST_NVME_FDP -eq 1 ]]; then\n\t\t\trun_test \"nvme_fdp\" test/nvme/nvme_fdp.sh\n\t\tfi\n\n\t\tif [[ $SPDK_TEST_NVME_ZNS -eq 1 ]]; then\n\t\t\trun_test \"nvme_zns\" $rootdir/test/nvme/zns/zns.sh\n\t\tfi\n\n\t\trun_test \"nvme_rpc\" $rootdir/test/nvme/nvme_rpc.sh\n\t\trun_test \"nvme_rpc_timeouts\" $rootdir/test/nvme/nvme_rpc_timeouts.sh\n\n\t\tif [ $(uname -s) = Linux ]; then\n\t\t\trun_test \"sw_hotplug\" $rootdir/test/nvme/sw_hotplug.sh\n\t\tfi\n\n\t\tif [[ $SPDK_TEST_XNVME -eq 1 ]]; then\n\t\t\trun_test \"nvme_xnvme\" $rootdir/test/nvme/xnvme/xnvme.sh\n\t\t\trun_test \"blockdev_xnvme\" $rootdir/test/bdev/blockdev.sh \"xnvme\"\n\t\t\t# Run ublk with xnvme since they have similar kernel dependencies\n\t\t\trun_test \"ublk\" $rootdir/test/ublk/ublk.sh\n\t\t\trun_test \"ublk_recovery\" $rootdir/test/ublk/ublk_recovery.sh\n\t\tfi\n\n\t\tif [[ $SPDK_TEST_NVME_INTERRUPT -eq 1 ]]; then\n\t\t\trun_test \"nvme_interrupt\" \"$rootdir/test/nvme/interrupt.sh\"\n\t\tfi\n\tfi\n\n\tif [ $SPDK_TEST_IOAT -eq 1 ]; then\n\t\trun_test \"ioat\" $rootdir/test/ioat/ioat.sh\n\tfi\n\n\ttiming_exit lib\n\n\tif [ $SPDK_TEST_ISCSI -eq 1 ]; then\n\t\trun_test \"iscsi_tgt\" $rootdir/test/iscsi_tgt/iscsi_tgt.sh\n\t\trun_test \"spdkcli_iscsi\" $rootdir/test/spdkcli/iscsi.sh\n\tfi\n\n\tif [ $SPDK_TEST_BLOBFS -eq 1 ]; then\n\t\trun_test \"rocksdb\" $rootdir/test/blobfs/rocksdb/rocksdb.sh\n\t\trun_test \"blobstore\" $rootdir/test/blobstore/blobstore.sh\n\t\trun_test \"blobstore_grow\" $rootdir/test/blobstore/blobstore_grow/blobstore_grow.sh\n\t\trun_test \"blobfs\" $rootdir/test/blobfs/blobfs.sh\n\t\trun_test \"hello_blob\" $SPDK_EXAMPLE_DIR/hello_blob \\\n\t\t\texamples/blob/hello_world/hello_blob.json\n\tfi\n\n\tif [ $SPDK_TEST_NVMF -eq 1 ]; then\n\t\texport NET_TYPE\n\t\t# The NVMe-oF run test cases are split out like this so that the parser that compiles the\n\t\t# list of all tests can properly differentiate them. Please do not merge them into one line.\n\t\tif [ \"$SPDK_TEST_NVMF_TRANSPORT\" = \"rdma\" ]; then\n\t\t\trun_test \"nvmf_rdma\" $rootdir/test/nvmf/nvmf.sh --transport=$SPDK_TEST_NVMF_TRANSPORT\n\t\t\trun_test \"spdkcli_nvmf_rdma\" $rootdir/test/spdkcli/nvmf.sh --transport=$SPDK_TEST_NVMF_TRANSPORT\n\t\telif [ \"$SPDK_TEST_NVMF_TRANSPORT\" = \"tcp\" ]; then\n\t\t\trun_test \"nvmf_tcp\" $rootdir/test/nvmf/nvmf.sh --transport=$SPDK_TEST_NVMF_TRANSPORT\n\t\t\tif [[ $SPDK_TEST_URING -eq 0 ]]; then\n\t\t\t\trun_test \"spdkcli_nvmf_tcp\" $rootdir/test/spdkcli/nvmf.sh --transport=$SPDK_TEST_NVMF_TRANSPORT\n\t\t\t\trun_test \"nvmf_identify_passthru\" $rootdir/test/nvmf/target/identify_passthru.sh --transport=$SPDK_TEST_NVMF_TRANSPORT\n\t\t\tfi\n\t\t\trun_test \"nvmf_dif\" $rootdir/test/nvmf/target/dif.sh\n\t\t\trun_test \"nvmf_abort_qd_sizes\" $rootdir/test/nvmf/target/abort_qd_sizes.sh\n\t\t\t# The keyring tests utilize NVMe/TLS\n\t\t\trun_test \"keyring_file\" \"$rootdir/test/keyring/file.sh\"\n\t\t\tif [[ \"$CONFIG_HAVE_KEYUTILS\" == y ]]; then\n\t\t\t\trun_test \"keyring_linux\" \"$rootdir/scripts/keyctl-session-wrapper\" \\\n\t\t\t\t\t\"$rootdir/test/keyring/linux.sh\"\n\t\t\tfi\n\t\telif [ \"$SPDK_TEST_NVMF_TRANSPORT\" = \"fc\" ]; then\n\t\t\trun_test \"nvmf_fc\" $rootdir/test/nvmf/nvmf.sh --transport=$SPDK_TEST_NVMF_TRANSPORT\n\t\t\trun_test \"spdkcli_nvmf_fc\" $rootdir/test/spdkcli/nvmf.sh\n\t\telse\n\t\t\techo \"unknown NVMe transport, please specify rdma, tcp, or fc.\"\n\t\t\texit 1\n\t\tfi\n\tfi\n\n\t# For vfio_user and vhost tests We need to make sure entire HUGEMEM default\n\t# goes to a single node as we share hugepages with qemu instance(s) and we\n\t# cannot split it across all numa nodes without making sure there's enough\n\t# memory available.\n\n\tif [ $SPDK_TEST_VHOST -eq 1 ]; then\n\t\tHUGENODE=0 run_test \"vhost\" $rootdir/test/vhost/vhost.sh --iso\n\tfi\n\n\tif [ $SPDK_TEST_VFIOUSER_QEMU -eq 1 ]; then\n\t\tHUGENODE=0 run_test \"vfio_user_qemu\" $rootdir/test/vfio_user/vfio_user.sh --iso\n\tfi\n\n\tif [ $SPDK_TEST_LVOL -eq 1 ]; then\n\t\trun_test \"lvol\" $rootdir/test/lvol/lvol.sh\n\t\trun_test \"blob_io_wait\" $rootdir/test/blobstore/blob_io_wait/blob_io_wait.sh\n\tfi\n\n\tif [ $SPDK_TEST_VHOST_INIT -eq 1 ]; then\n\t\ttiming_enter vhost_initiator\n\t\trun_test \"vhost_blockdev\" $rootdir/test/vhost/initiator/blockdev.sh\n\t\trun_test \"spdkcli_virtio\" $rootdir/test/spdkcli/virtio.sh\n\t\trun_test \"vhost_shared\" $rootdir/test/vhost/shared/shared.sh\n\t\trun_test \"vhost_fuzz\" $rootdir/test/vhost/fuzz/fuzz.sh\n\t\ttiming_exit vhost_initiator\n\tfi\n\n\tif [ $SPDK_TEST_RBD -eq 1 ]; then\n\t\trun_test \"blockdev_rbd\" $rootdir/test/bdev/blockdev.sh \"rbd\"\n\t\trun_test \"spdkcli_rbd\" $rootdir/test/spdkcli/rbd.sh\n\tfi\n\n\tif [ $SPDK_TEST_OCF -eq 1 ]; then\n\t\trun_test \"ocf\" $rootdir/test/ocf/ocf.sh\n\tfi\n\n\tif [ $SPDK_TEST_FTL -eq 1 ]; then\n\t\trun_test \"ftl\" $rootdir/test/ftl/ftl.sh\n\tfi\n\n\tif [ $SPDK_TEST_VMD -eq 1 ]; then\n\t\trun_test \"vmd\" $rootdir/test/vmd/vmd.sh\n\tfi\n\n\tif [ $SPDK_TEST_VBDEV_COMPRESS -eq 1 ]; then\n\t\trun_test \"compress_compdev\" $rootdir/test/compress/compress.sh \"compdev\"\n\t\trun_test \"compress_isal\" $rootdir/test/compress/compress.sh \"isal\"\n\tfi\n\n\tif [ $SPDK_TEST_OPAL -eq 1 ]; then\n\t\trun_test \"nvme_opal\" $rootdir/test/nvme/nvme_opal.sh\n\tfi\n\n\tif [ $SPDK_TEST_CRYPTO -eq 1 ]; then\n\t\trun_test \"blockdev_crypto_aesni\" $rootdir/test/bdev/blockdev.sh \"crypto_aesni\"\n\t\trun_test \"blockdev_crypto_sw\" $rootdir/test/bdev/blockdev.sh \"crypto_sw\"\n\t\trun_test \"blockdev_crypto_qat\" $rootdir/test/bdev/blockdev.sh \"crypto_qat\"\n\t\trun_test \"chaining\" $rootdir/test/bdev/chaining.sh\n\tfi\n\n\tif [[ $SPDK_TEST_SCHEDULER -eq 1 ]]; then\n\t\trun_test \"scheduler\" $rootdir/test/scheduler/scheduler.sh\n\tfi\n\n\tif [[ $SPDK_TEST_SMA -eq 1 ]]; then\n\t\trun_test \"sma\" $rootdir/test/sma/sma.sh\n\tfi\n\n\tif [[ $SPDK_TEST_FUZZER -eq 1 ]]; then\n\t\trun_test \"llvm_fuzz\" $rootdir/test/fuzz/llvm.sh\n\tfi\n\n\tif [[ $SPDK_TEST_ACCEL_MLX5 -eq 1 ]]; then\n\t\trun_test \"accel_mlx5_crypto\" $rootdir/test/accel/mlx5/accel_mlx5_crypto.sh\n\t\trun_test \"accel_mlx5_copy\" $rootdir/test/accel/mlx5/accel_mlx5_copy.sh\n\t\trun_test \"accel_mlx5_crc32c\" $rootdir/test/accel/mlx5/accel_mlx5_crc32c.sh\n\tfi\nfi\n\ntrap - SIGINT SIGTERM EXIT\n\ntiming_enter post_cleanup\nautotest_cleanup\ntiming_exit post_cleanup\n\ntiming_exit autotest\nchmod a+r $output_dir/timing.txt\n\n[[ -f \"$output_dir/udev.log\" ]] && rm -f \"$output_dir/udev.log\"\n\nif [[ $CONFIG_COVERAGE == y ]]; then\n\t# generate coverage data and combine with baseline\n\t$LCOV -q -c --no-external -d $src -t \"$(hostname)\" -o $out/cov_test.info\n\t$LCOV -q -a $out/cov_base.info -a $out/cov_test.info -o $out/cov_total.info\n\t$LCOV -q -r $out/cov_total.info '*/dpdk/*' -o $out/cov_total.info\n\t# C++ headers in /usr can sometimes generate data even when specifying\n\t# --no-external, so remove them. But we need to add an ignore-errors\n\t# flag to squash warnings on systems where they don't generate data.\n\t$LCOV -q -r $out/cov_total.info --ignore-errors unused,unused '/usr/*' -o $out/cov_total.info\n\t$LCOV -q -r $out/cov_total.info '*/examples/vmd/*' -o $out/cov_total.info\n\t$LCOV -q -r $out/cov_total.info '*/app/spdk_lspci/*' -o $out/cov_total.info\n\t$LCOV -q -r $out/cov_total.info '*/app/spdk_top/*' -o $out/cov_total.info\n\trm -f cov_base.info cov_test.info OLD_STDOUT OLD_STDERR\nfi\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 47.3564453125,
          "content": "#!/usr/bin/env bash\n#  SPDX-License-Identifier: BSD-3-Clause\n#  Copyright (C) 2017 Intel Corporation\n#  All rights reserved.\n#  Copyright (c) 2022 Dell Inc, or its subsidiaries.\n#\n\nset -e\n\ntrap 'echo -e \"\\n\\nConfiguration failed\\n\\n\" >&2' ERR\n\nrootdir=$(readlink -f $(dirname $0))\nsource \"$rootdir/scripts/common.sh\"\n\nfunction usage() {\n\techo \"'configure' configures SPDK to compile on supported platforms.\"\n\techo \"\"\n\techo \"Usage: ./configure [OPTION]...\"\n\techo \"\"\n\techo \"Defaults for the options are specified in brackets.\"\n\techo \"\"\n\techo \"General:\"\n\techo \" -h, --help                Display this help and exit\"\n\techo \"\"\n\techo \" --prefix=path             Configure installation prefix (default: /usr/local)\"\n\techo \" --target-arch=arch        Target build architecture. Must be a valid GNU arch. Default: native\"\n\techo \"\"\n\techo \" --cross-prefix=prefix     Prefix for cross compilation (default: none)\"\n\techo \"                           example: aarch64-linux-gnu\"\n\techo \" --libdir=path             Configure installation path for the libraries (default: \\$prefix/lib)\"\n\techo \" --max-lcores=VAL          DPDK configuration. VAL defines maximum number of lcores supported\"\n\techo \"                           by EAL, or enables autodetection if set to 'detect'. When 'detect'\"\n\techo \"                           is specified, DPDK will detect number of cores in the system during\"\n\techo \"                           compilation, and will set maximum number of lcores to this value\"\n\techo \" --max-numa-nodes=VAL      VAL defines maximum number of NUMA nodes supported for iobuf\"\n\techo \"                           buffer pools.\"\n\techo \" --enable-debug            Configure for debug builds\"\n\techo \" --enable-werror           Treat compiler warnings as errors\"\n\techo \" --enable-asan             Enable address sanitizer\"\n\techo \" --enable-ubsan            Enable undefined behavior sanitizer\"\n\techo \" --enable-coverage         Enable code coverage tracking\"\n\techo \" --enable-lto              Enable link-time optimization\"\n\techo \" --enable-pgo-capture[=PATH]      Enable generation of profile guided optimization data\"\n\techo \" --enable-pgo-use[=PATH]   Use previously captured profile guided optimization data\"\n\techo \" --enable-cet              Enable Intel Control-flow Enforcement Technology (CET)\"\n\techo \" --disable-tests           Disable building of functional tests\"\n\techo \" --disable-unit-tests      Disable building of unit tests\"\n\techo \" --disable-examples        Disable building of examples\"\n\techo \" --disable-apps            Disable building of apps\"\n\techo \"\"\n\techo \"Specifying Dependencies:\"\n\techo \"--with-DEPENDENCY[=path]   Use the given dependency. Optionally, provide the\"\n\techo \"                           path.\"\n\techo \"--without-DEPENDENCY       Do not link to the given dependency. This may\"\n\techo \"                           disable features and components.\"\n\techo \"\"\n\techo \"Valid dependencies are listed below.\"\n\techo \" --with-dpdk[=DIR]         Build against a custom dpdk version. By default, the dpdk\"\n\techo \" --without-dpdk            submodule in spdk tree will be used.\"\n\techo \"                           example: /usr/share/dpdk/x86_64-default-linuxapp-gcc\"\n\techo \" --with-env=DIR            Use an alternate environment implementation instead of DPDK.\"\n\techo \"                           Implies --without-dpdk.\"\n\techo \" --with-idxd               Build the IDXD library and accel framework plug-in module.\"\n\techo \" --without-idxd            Disabled while experimental. Only built for x86 when enabled.\"\n\techo \" --with-crypto             Build isa-l-crypto and vbdev crypto module. No path required.\"\n\techo \" --without-crypto          Disable isa-l-crypto and vbdev crypto module.\"\n\techo \" --with-fio[=DIR]          Build fio_plugin.\"\n\techo \" --without-fio             default: /usr/src/fio\"\n\techo \" --with-xnvme              Build xNVMe bdev module.\"\n\techo \" --without-xnvme           No path required.\"\n\techo \" --with-vhost              Build vhost target. Enabled by default.\"\n\techo \" --without-vhost           No path required.\"\n\techo \" --with-virtio             Build vhost initiator and virtio-pci bdev modules.\"\n\techo \" --without-virtio          No path required.\"\n\techo \" --with-vfio-user[=DIR]    Build custom vfio-user transport for NVMf target and vfio-user target.\"\n\techo \"                           vfio-user initiator is always built-in in Linux.\"\n\techo \"                           example: /usr/src/libvfio-user\"\n\techo \" --without-vfio-user       No path required.\"\n\techo \" --with-vbdev-compress     Build vbdev compression module and dependencies.\"\n\techo \" --without-vbdev-compress  No path required.\"\n\techo \" --with-dpdk-compressdev   Build accel DPDK compression module and dependencies.\"\n\techo \" --without-dpdk-compressdev No path required.\"\n\techo \" --with-rbd                Build Ceph RBD bdev module.\"\n\techo \" --without-rbd             No path required.\"\n\techo \" --with-ublk               Build ublk library.\"\n\techo \" --without-ublk            No path required.\"\n\techo \" --with-rdma[=PROVIDER]    Build RDMA transport for NVMf target and initiator.\"\n\techo \" --without-rdma            Accepts optional RDMA provider name. Can be \\\"verbs\\\" or \\\"mlx5_dv\\\".\"\n\techo \"                           If no provider specified, \\\"verbs\\\" provider is used by default.\"\n\techo \" --with-fc[=DIR]           Build FC transport for NVMf target.\"\n\techo \" --without-fc              If an argument is provided, it is considered a directory containing\"\n\techo \"                           libufc.a and fc_lld.h. Otherwise the regular system paths will\"\n\techo \"                           be searched.\"\n\techo \" --with-daos[=DIR]         Build DAOS bdev module.\"\n\techo \" --without-daos            No path required.\"\n\techo \" --with-shared             Build spdk shared libraries.\"\n\techo \" --without-shared          No path required.\"\n\techo \" --with-iscsi-initiator    Build with iscsi bdev module.\"\n\techo \" --without-iscsi-initiator No path required.\"\n\techo \" --with-vtune=DIR          Required to profile I/O under Intel VTune Profiler.\"\n\techo \"                           example: /opt/intel/oneapi/vtune/version\"\n\techo \" --without-vtune           Support for Intel VTune Profiler will not be provided.\"\n\techo \" --with-ocf[=DIR]          Build OCF library and bdev module.\"\n\techo \" --without-ocf             If argument is directory, interpret it as root of OCF repo\"\n\techo \"                           If argument is file, interpret it as compiled OCF lib\"\n\techo \"                           If no argument is specified, OCF git submodule is used by default\"\n\techo \"                           example: /usr/src/ocf/\"\n\techo \" --with-uring[=DIR]        Build I/O uring bdev or socket module.\"\n\techo \" --without-uring           If an argument is provided, it is considered a directory containing\"\n\techo \"                           liburing.a and io_uring.h. Otherwise the regular system paths will\"\n\techo \"                           be searched.\"\n\techo \" --with-dpdk-uadk          Build uadk DPDK module. No path required.\"\n\techo \" --without-dpdk-uadk       Disable uadk DPDK module.\"\n\techo \" --without-uring-zns       Build I/O uring module without ZNS (zoned namespaces) support.\"\n\techo \" --with-openssl[=DIR]      Build OPENSSL with custom path. Otherwise the regular system paths will\"\n\techo \"                           be searched.\"\n\techo \" --with-fuse               Build FUSE components for mounting a blobfs filesystem.\"\n\techo \" --without-fuse            No path required.\"\n\techo \" --with-nvme-cuse          Build NVMe driver with support for CUSE-based character devices.\"\n\techo \" --without-nvme-cuse       No path required.\"\n\techo \" --with-raid5f             Build with bdev_raid module RAID5f support.\"\n\techo \" --without-raid5f          No path required.\"\n\techo \" --with-wpdk=DIR           Build using WPDK to provide support for Windows (experimental).\"\n\techo \" --without-wpdk            The argument must be a directory containing lib and include.\"\n\techo \" --with-usdt               Build with userspace DTrace probes enabled.\"\n\techo \" --without-usdt            No path required.\"\n\techo \" --with-fuzzer             Build with LLVM fuzzing enabled.\"\n\techo \"                           Path to clang_rt.fuzzer_no_main library required.\"\n\techo \"                           Requires setting CC and CXX to clang.\"\n\techo \"                           (Typically /usr/lib/llvm-VER/lib/clang/VER/lib/linux/libclang_rt.fuzzer_no_main-ARCH.a)\"\n\techo \" --with-sma                Generate Storage Management Agent's protobuf interface\"\n\techo \" --without-sma             No path required.\"\n\techo \" --with-avahi              Build with Avahi mDNS discovery client service enabled in bdev-nvme module.\"\n\techo \" --without-avahi           No path required.\"\n\techo \" --with-golang             Build with components written in Go\"\n\techo \" --without-golang          No path required.\"\n\techo \" --with-aio-fsdev          Build aio FSDEV component.\"\n\techo \" --without-aio-fsdev       No path required.\"\n\techo \"\"\n\techo \"Environment variables:\"\n\techo \"\"\n\techo \"CC                         C compiler\"\n\techo \"CFLAGS                     C compiler flags\"\n\techo \"CXX                        C++ compiler\"\n\techo \"CXXFLAGS                   C++ compiler flags\"\n\techo \"LD                         Linker\"\n\techo \"LDFLAGS                    Linker flags\"\n\techo \"DESTDIR                    Destination for 'make install'\"\n\techo \"\"\n}\n\n# Load default values\n# Convert config to sourceable configuration file\nsed -r 's/CONFIG_([[:alnum:]_]+)=(.*)/CONFIG[\\1]=\\2/g' $rootdir/CONFIG > $rootdir/CONFIG.sh\ndeclare -A CONFIG\nsource $rootdir/CONFIG.sh\nrm $rootdir/CONFIG.sh\n\n# Try to expand literal ~ that might have been passed as an option via --long-opt=~/dir.\nset -- \"${@//\\~/~}\"\n\nfor i in \"$@\"; do\n\tcase \"$i\" in\n\t\t--cross-prefix=*)\n\t\t\tCONFIG[CROSS_PREFIX]=\"${i#*=}\"\n\t\t\t;;\n\t\t--enable-lto)\n\t\t\tCONFIG[LTO]=y\n\t\t\t;;\n\t\t--disable-lto)\n\t\t\tCONFIG[LTO]=n\n\t\t\t;;\n\tesac\ndone\n\n# Detect the compiler toolchain\n$rootdir/scripts/detect_cc.sh --cc=\"$CC\" --cxx=\"$CXX\" --lto=\"${CONFIG[LTO]}\" --ld=\"$LD\" --cross-prefix=\"${CONFIG[CROSS_PREFIX]}\" > $rootdir/mk/cc.mk\n\nmapfile -t cc < <(grep \"=\" \"$rootdir/mk/cc.mk\")\nsource <(printf '%q\\n' \"${cc[@]}\")\nCC=$DEFAULT_CC\n\narch=$($CC -dumpmachine)\nsys_name=$(uname -s)\n\nif [[ $arch == *mingw* ]] || [[ $arch == *windows* ]]; then\n\tsys_name=Windows\nfi\n\nif [[ $sys_name != \"Linux\" ]]; then\n\t# Vhost, rte_vhost library and virtio are only supported on Linux.\n\tCONFIG[VHOST]=\"n\"\n\tCONFIG[VIRTIO]=\"n\"\n\tCONFIG[NVME_CUSE]=\"n\"\n\techo \"Notice: Vhost, rte_vhost library, virtio, and fuse\"\n\techo \"are only supported on Linux. Turning off default feature.\"\nfi\n\nfunction check_dir() {\n\targ=\"$1\"\n\tdir=\"${arg#*=}\"\n\tif [ ! -d \"$dir\" ]; then\n\t\techo \"$arg: directory not found\"\n\t\texit 1\n\tfi\n}\n\n# On x86_64 'clang -dumpmachine' produces x86_64-pc-linux-gnu\n# whereas the dpdk might be built with gcc and its libs lie in\n# x86_64-linux-gnu. Let's find the right libdir for dpdk libs.\nfunction find_dpdk_arch_libdir() {\n\tlocal dpdk_libdir=\"$1/lib\"\n\n\t# Use libdir with 'lib' or 'lib64'\n\tif [[ ! -d \"$dpdk_libdir\" ]]; then\n\t\tdpdk_libdir+=\"64\"\n\tfi\n\n\t# Checking first what we have with $arch, then clang\n\t# variant of arch.\n\tarches=(\"$arch\" \"$(echo $arch | sed 's/-pc//g')\")\n\tfor a in \"${arches[@]}\"; do\n\t\tlocal libdir_arch=\"$dpdk_libdir/$a\"\n\t\tif [[ -d \"$libdir_arch\" ]]; then\n\t\t\techo \"$libdir_arch\"\n\t\t\treturn\n\t\tfi\n\tdone\n\n\t# Fallback to the libdir without arch component\n\techo \"$dpdk_libdir\"\n}\n\nfunction check_IPSec_mb() {\n\tlocal mode=$1\n\tlocal dpdk_libdir=$2\n\tlocal dpdk_incdir=$3\n\tlocal have_ipsec_mb=n\n\n\tif [[ $mode = \"pkg-config\" ]]; then\n\t\tlocal dpdk_libs\n\n\t\t# Request libdpdk pkg-config settings to figure out if the IPSec_MB is used\n\t\t# as a dependency.\n\t\t# Due to some reason pkg-config shows -lIPSec_MB only with --static option\n\t\tdpdk_libs=$(PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$dpdk_libdir/pkgconfig\" pkg-config --libs --static libdpdk)\n\t\tif echo \"$dpdk_libs\" | grep \"\\-lIPSec_MB\" > /dev/null 2>&1; then\n\t\t\thave_ipsec_mb=y\n\t\tfi\n\telif [[ $mode = \"build-config\" ]]; then\n\t\t# Use dpdk build config header to check if the IPSec_MB was used.\n\t\tif grep -F \"define RTE_CRYPTO_IPSEC_MB 1\" \"$dpdk_incdir/rte_build_config.h\" > /dev/null 2>&1; then\n\t\t\thave_ipsec_mb=y\n\t\tfi\n\telse\n\t\techo \"ERROR: Invalid IPSec_MB checking mode $mode.\"\n\t\techo \"ERROR: Only \\\"pkg-config\\\" and \\\"build-config\\\" available.\"\n\t\texit 1\n\tfi\n\tif [[ $have_ipsec_mb = \"n\" ]]; then\n\t\tCONFIG[IPSEC_MB]=n\n\t\treturn\n\tfi\n\n\t# Since we don't know the library path where the IPSec_MB is located\n\t# let's find it out with the ldd utility. This can be a standard location\n\t# or a custom build.\n\tlocal librte_crypto_ipsec_mb=\"$dpdk_libdir/librte_crypto_ipsec_mb.so\"\n\tif [[ -f \"$librte_crypto_ipsec_mb\" ]]; then\n\t\tlocal ipsec_mb_libdir\n\n\t\tipsec_mb_libdir=$(ldd \"$librte_crypto_ipsec_mb\" | grep \"libIPSec_MB.so\" \\\n\t\t\t| sed -e 's/\\s*libIPSec_MB.so.*=>\\s//' -e 's/\\/libIPSec_MB.so.*$//')\n\t\tif [[ -d $ipsec_mb_libdir ]]; then\n\t\t\tCONFIG[IPSEC_MB]=y\n\t\t\tCONFIG[IPSEC_MB_DIR]=\"$ipsec_mb_libdir\"\n\t\telif [[ $ipsec_mb_libdir = \"not found\" ]]; then\n\t\t\t# ldconfig cache is broken, old build with refs to non-existing libs, etc.\n\t\t\techo \"ERROR: Invalid IPSec_MB installation. Library is not found and/or ldconfig cache is broken!\"\n\t\t\texit 1\n\t\telse\n\t\t\t# Failed to check for IPSec_MB lib path. Let's just assume it is lives\n\t\t\t# in one of the standard locations (/usr/lib, etc.).\n\t\t\tCONFIG[IPSEC_MB]=y\n\t\tfi\n\telse\n\t\t# pkg-config says there is IPSec_mb and dpdk lib does not have it. Let's just\n\t\t# assume it is installed in the system in one of the standard locations.\n\t\tCONFIG[IPSEC_MB]=y\n\tfi\n}\n\nfor i in \"$@\"; do\n\tcase \"$i\" in\n\t\t-h | --help)\n\t\t\tusage\n\t\t\texit 0\n\t\t\t;;\n\t\t--cross-prefix=*) ;&\n\t\t--enable-lto) ;&\n\t\t--disable-lto)\n\t\t\t# Options handled before detecting CC.\n\t\t\t;;\n\t\t--prefix=*)\n\t\t\tCONFIG[PREFIX]=\"${i#*=}\"\n\t\t\t;;\n\t\t--target-arch=*)\n\t\t\tCONFIG[ARCH]=\"${i#*=}\"\n\t\t\t;;\n\t\t--libdir=*)\n\t\t\tCONFIG[LIBDIR]=\"${i#*=}\"\n\t\t\t;;\n\t\t--enable-debug)\n\t\t\tCONFIG[DEBUG]=y\n\t\t\t;;\n\t\t--disable-debug)\n\t\t\tCONFIG[DEBUG]=n\n\t\t\t;;\n\t\t--enable-asan)\n\t\t\tCONFIG[ASAN]=y\n\t\t\t;;\n\t\t--disable-asan)\n\t\t\tCONFIG[ASAN]=n\n\t\t\t;;\n\t\t--enable-ubsan)\n\t\t\tCONFIG[UBSAN]=y\n\t\t\t;;\n\t\t--disable-ubsan)\n\t\t\tCONFIG[UBSAN]=n\n\t\t\t;;\n\t\t--enable-tsan)\n\t\t\tCONFIG[TSAN]=y\n\t\t\t;;\n\t\t--disable-tsan)\n\t\t\tCONFIG[TSAN]=n\n\t\t\t;;\n\t\t--enable-coverage)\n\t\t\tCONFIG[COVERAGE]=y\n\t\t\t;;\n\t\t--disable-coverage)\n\t\t\tCONFIG[COVERAGE]=n\n\t\t\t;;\n\t\t--enable-pgo-capture)\n\t\t\tCONFIG[PGO_CAPTURE]=y\n\t\t\t;;\n\t\t--enable-pgo-capture=*)\n\t\t\tCONFIG[PGO_CAPTURE]=y\n\t\t\tCONFIG[PGO_DIR]=\"${i#*=}\"\n\t\t\t;;\n\t\t--disable-pgo-capture)\n\t\t\tCONFIG[PGO_CAPTURE]=n\n\t\t\t;;\n\t\t--enable-pgo-use)\n\t\t\tCONFIG[PGO_USE]=y\n\t\t\t;;\n\t\t--enable-pgo-use=*)\n\t\t\tCONFIG[PGO_USE]=y\n\t\t\tCONFIG[PGO_DIR]=\"${i#*=}\"\n\t\t\t;;\n\t\t--disable-pgo-use)\n\t\t\tCONFIG[PGO_USE]=n\n\t\t\t;;\n\t\t--enable-tests)\n\t\t\tCONFIG[TESTS]=y\n\t\t\t;;\n\t\t--disable-tests)\n\t\t\tCONFIG[TESTS]=n\n\t\t\t;;\n\t\t--enable-unit-tests)\n\t\t\tCONFIG[UNIT_TESTS]=y\n\t\t\t;;\n\t\t--disable-unit-tests)\n\t\t\tCONFIG[UNIT_TESTS]=n\n\t\t\t;;\n\t\t--enable-examples)\n\t\t\tCONFIG[EXAMPLES]=y\n\t\t\t;;\n\t\t--disable-examples)\n\t\t\tCONFIG[EXAMPLES]=n\n\t\t\t;;\n\t\t--enable-apps)\n\t\t\tCONFIG[APPS]=y\n\t\t\t;;\n\t\t--disable-apps)\n\t\t\tCONFIG[APPS]=N\n\t\t\t;;\n\t\t--enable-werror)\n\t\t\tCONFIG[WERROR]=y\n\t\t\t;;\n\t\t--disable-werror)\n\t\t\tCONFIG[WERROR]=n\n\t\t\t;;\n\t\t--enable-cet)\n\t\t\tCONFIG[CET]=y\n\t\t\t;;\n\t\t--disable-cet)\n\t\t\tCONFIG[CET]=n\n\t\t\t;;\n\t\t--with-dpdk)\n\t\t\t# Can we use pkg-config?\n\t\t\tif command -v \"pkg-config\" > /dev/null 2>&1 && pkg-config --exists libdpdk; then\n\t\t\t\tdpdk_libdir=$(pkg-config --variable=libdir libdpdk)\n\t\t\t\tdpdk_libdir=$(readlink -f $dpdk_libdir)\n\t\t\t\tdpdk_incdir=$(pkg-config --variable=includedir libdpdk)\n\t\t\t\techo \"Using DPDK lib dir $dpdk_libdir\"\n\t\t\t\tCONFIG[DPDK_LIB_DIR]=$dpdk_libdir\n\t\t\t\tCONFIG[DPDK_INC_DIR]=$dpdk_incdir\n\t\t\t\tCONFIG[DPDK_PKG_CONFIG]=y\n\t\t\t\tCFLAGS=\"${CFLAGS:+$CFLAGS }$(pkg-config --cflags libdpdk)\"\n\t\t\t\tcheck_IPSec_mb \"pkg-config\" \"$dpdk_libdir\" \"$dpdk_incdir\"\n\t\t\telse\n\t\t\t\techo \"libdpdk.pc not found, aborting\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\t;;\n\t\t--with-dpdk=*)\n\t\t\tcheck_dir \"$i\"\n\t\t\tdpdk_dir=$(readlink -f ${i#*=})\n\t\t\tdpdk_libdir=$(find_dpdk_arch_libdir $dpdk_dir)\n\t\t\tdpdk_incdir=\"$dpdk_dir/include\"\n\n\t\t\t# Can we use pkg-config?\n\t\t\tif command -v \"pkg-config\" > /dev/null 2>&1 && PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$dpdk_libdir/pkgconfig\" pkg-config --exists libdpdk; then\n\t\t\t\techo \"Using $dpdk_libdir/pkgconfig for additional libs...\"\n\t\t\t\tsysroot_dir=$(PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$dpdk_libdir/pkgconfig\" pkg-config --variable=pc_sysrootdir libdpdk)\n\t\t\t\tdpdk_libdir=$(PKG_CONFIG_SYSROOT_DIR='' PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$dpdk_libdir/pkgconfig\" pkg-config --variable=libdir libdpdk)\n\t\t\t\tdpdk_libdir=$(readlink -f \"${sysroot_dir}$dpdk_libdir\")\n\t\t\t\tif ! echo $dpdk_libdir | grep $dpdk_dir > /dev/null 2>&1; then\n\t\t\t\t\techo \"ERROR: pkg-config reported DPDK libdir $dpdk_libdir is out of the directory specified with --with-dpdk=\"\n\t\t\t\t\techo \"ERROR: do you have another DPDK installed in the system?\"\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\t\tCFLAGS=\"${CFLAGS:+$CFLAGS }$(PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$dpdk_libdir/pkgconfig\" pkg-config --cflags libdpdk)\"\n\t\t\t\tdpdk_incdir=\"${sysroot_dir}$(PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:$dpdk_libdir/pkgconfig\" pkg-config --variable=includedir libdpdk)\"\n\t\t\t\tcheck_IPSec_mb \"pkg-config\" \"$dpdk_libdir\" \"$dpdk_incdir\"\n\t\t\telse\n\t\t\t\techo \"Using $dpdk_incdir/rte_build_config.h for additional libs...\"\n\n\t\t\t\tcheck_IPSec_mb \"build-config\" \"$dpdk_libdir\" \"$dpdk_incdir\"\n\t\t\tfi\n\t\t\techo \"DPDK libraries: $dpdk_libdir\"\n\t\t\techo \"DPDK includes: $dpdk_incdir\"\n\t\t\tCONFIG[DPDK_DIR]=$dpdk_dir\n\t\t\tCONFIG[DPDK_LIB_DIR]=\"$dpdk_libdir\"\n\t\t\tCONFIG[DPDK_INC_DIR]=\"$dpdk_incdir\"\n\t\t\tCONFIG[DPDK_PKG_CONFIG]=n\n\t\t\t;;\n\t\t--without-dpdk)\n\t\t\tCONFIG[DPDK_DIR]=\n\t\t\t;;\n\t\t--with-wpdk=*)\n\t\t\tcheck_dir \"$i\"\n\t\t\tCONFIG[WPDK_DIR]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--without-wpdk)\n\t\t\tCONFIG[WPDK_DIR]=\n\t\t\t;;\n\t\t--with-env=*)\n\t\t\tCONFIG[ENV]=\"${i#*=}\"\n\t\t\t;;\n\t\t--with-ublk)\n\t\t\tCONFIG[UBLK]=y\n\t\t\t;;\n\t\t--without-ublk)\n\t\t\tCONFIG[UBLK]=n\n\t\t\t;;\n\t\t--with-rbd)\n\t\t\tCONFIG[RBD]=y\n\t\t\t;;\n\t\t--without-rbd)\n\t\t\tCONFIG[RBD]=n\n\t\t\t;;\n\t\t--with-rdma=*)\n\t\t\tCONFIG[RDMA]=y\n\t\t\tCONFIG[RDMA_PROV]=${i#*=}\n\t\t\t;;\n\t\t--with-rdma)\n\t\t\tCONFIG[RDMA]=y\n\t\t\tCONFIG[RDMA_PROV]=\"verbs\"\n\t\t\t;;\n\t\t--without-rdma)\n\t\t\tCONFIG[RDMA]=n\n\t\t\t;;\n\t\t--with-fc=*)\n\t\t\tCONFIG[FC]=y\n\t\t\tCONFIG[FC_PATH]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--with-fc)\n\t\t\tCONFIG[FC]=y\n\t\t\tCONFIG[FC_PATH]=\n\t\t\t;;\n\t\t--without-fc)\n\t\t\tCONFIG[FC]=n\n\t\t\tCONFIG[FC_PATH]=\n\t\t\t;;\n\t\t--with-daos)\n\t\t\tCONFIG[DAOS]=y\n\t\t\tCONFIG[DAOS_DIR]=\"\"\n\t\t\t;;\n\t\t--with-daos=*)\n\t\t\tCONFIG[DAOS]=y\n\t\t\tcheck_dir \"$i\"\n\t\t\tCONFIG[DAOS_DIR]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--without-daos)\n\t\t\tCONFIG[DAOS]=n\n\t\t\t;;\n\t\t--with-shared)\n\t\t\tCONFIG[SHARED]=y\n\t\t\t;;\n\t\t--without-shared)\n\t\t\tCONFIG[SHARED]=n\n\t\t\t;;\n\t\t--with-iscsi-initiator)\n\t\t\tCONFIG[ISCSI_INITIATOR]=y\n\t\t\t;;\n\t\t--without-iscsi-initiator)\n\t\t\tCONFIG[ISCSI_INITIATOR]=n\n\t\t\t;;\n\t\t--with-crypto)\n\t\t\tCONFIG[CRYPTO]=y\n\t\t\t;;\n\t\t--without-crypto)\n\t\t\tCONFIG[CRYPTO]=n\n\t\t\t;;\n\t\t--with-dpdk-uadk)\n\t\t\tCONFIG[DPDK_UADK]=y\n\t\t\t;;\n\t\t--without-dpdk-uadk)\n\t\t\tCONFIG[DPDK_UADK]=n\n\t\t\t;;\n\t\t--with-vhost)\n\t\t\tCONFIG[VHOST]=y\n\t\t\t;;\n\t\t--without-vhost)\n\t\t\tCONFIG[VHOST]=n\n\t\t\t;;\n\t\t--with-virtio)\n\t\t\tCONFIG[VIRTIO]=y\n\t\t\t;;\n\t\t--without-virtio)\n\t\t\tCONFIG[VIRTIO]=n\n\t\t\t;;\n\t\t--with-vfio-user)\n\t\t\tCONFIG[VFIO_USER]=y\n\t\t\tCONFIG[VFIO_USER_DIR]=\"\"\n\t\t\t;;\n\t\t--with-vfio-user=*)\n\t\t\tCONFIG[VFIO_USER]=y\n\t\t\tcheck_dir \"$i\"\n\t\t\tCONFIG[VFIO_USER_DIR]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--without-vfio-user)\n\t\t\tCONFIG[VFIO_USER]=n\n\t\t\t;;\n\t\t--with-vbdev-compress)\n\t\t\tCONFIG[VBDEV_COMPRESS]=y\n\t\t\t;;\n\t\t--without-vbdev-compress)\n\t\t\tCONFIG[VBDEV_COMPRESS]=n\n\t\t\t;;\n\t\t--with-dpdk-compressdev)\n\t\t\tCONFIG[DPDK_COMPRESSDEV]=y\n\t\t\t;;\n\t\t--without-dpdk-compressdev)\n\t\t\tCONFIG[DPDK_COMPRESSDEV]=n\n\t\t\t;;\n\t\t--with-xnvme)\n\t\t\tCONFIG[XNVME]=y\n\t\t\t;;\n\t\t--without-xnvme)\n\t\t\tCONFIG[XNVME]=n\n\t\t\t;;\n\t\t--with-fio) ;&\n\t\t--with-fio=*)\n\t\t\tif [[ ${i#*=} != \"$i\" ]]; then\n\t\t\t\tCONFIG[FIO_SOURCE_DIR]=${i#*=}\n\t\t\tfi\n\t\t\tcheck_dir \"--with-fio=${CONFIG[FIO_SOURCE_DIR]}\"\n\t\t\tCONFIG[FIO_SOURCE_DIR]=$(readlink -f \"${CONFIG[FIO_SOURCE_DIR]}\")\n\t\t\tCONFIG[FIO_PLUGIN]=y\n\t\t\t;;\n\t\t--without-fio)\n\t\t\tCONFIG[FIO_PLUGIN]=n\n\t\t\t;;\n\t\t--with-vtune=*)\n\t\t\tcheck_dir \"$i\"\n\t\t\tCONFIG[VTUNE_DIR]=\"${i#*=}\"\n\t\t\tCONFIG[VTUNE]=y\n\t\t\t;;\n\t\t--without-vtune)\n\t\t\tCONFIG[VTUNE_DIR]=\n\t\t\tCONFIG[VTUNE]=n\n\t\t\t;;\n\t\t--with-ocf)\n\t\t\tCONFIG[OCF]=y\n\t\t\tCONFIG[OCF_PATH]=$(readlink -f \"$rootdir/ocf\")\n\t\t\t;;\n\t\t--with-ocf=*)\n\t\t\tCONFIG[OCF]=y\n\t\t\tCONFIG[OCF_PATH]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--without-ocf)\n\t\t\tCONFIG[OCF]=n\n\t\t\tCONFIG[OCF_PATH]=\n\t\t\t;;\n\t\t--with-uring=*)\n\t\t\tCONFIG[URING]=y\n\t\t\tCONFIG[URING_PATH]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--with-uring)\n\t\t\tCONFIG[URING]=y\n\t\t\tCONFIG[URING_ZNS]=y\n\t\t\tCONFIG[URING_PATH]=\n\t\t\t;;\n\t\t--without-uring)\n\t\t\tCONFIG[URING]=n\n\t\t\tCONFIG[URING_PATH]=\n\t\t\t;;\n\t\t--without-uring-zns)\n\t\t\tCONFIG[URING_ZNS]=n\n\t\t\t;;\n\t\t--with-openssl=*)\n\t\t\tcheck_dir \"$i\"\n\t\t\tCONFIG[OPENSSL_PATH]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--with-fuse)\n\t\t\tCONFIG[FUSE]=y\n\t\t\t;;\n\t\t--without-fuse)\n\t\t\tCONFIG[FUSE]=n\n\t\t\t;;\n\t\t--with-nvme-cuse)\n\t\t\tCONFIG[NVME_CUSE]=y\n\t\t\t;;\n\t\t--without-nvme-cuse)\n\t\t\tCONFIG[NVME_CUSE]=n\n\t\t\t;;\n\t\t--with-raid5f)\n\t\t\tCONFIG[RAID5F]=y\n\t\t\t;;\n\t\t--without-raid5f)\n\t\t\tCONFIG[RAID5F]=n\n\t\t\t;;\n\t\t--with-idxd)\n\t\t\tCONFIG[IDXD]=y\n\t\t\tCONFIG[IDXD_KERNEL]=n\n\t\t\t;;\n\t\t--without-idxd)\n\t\t\tCONFIG[IDXD]=n\n\t\t\t;;\n\t\t--with-usdt)\n\t\t\tCONFIG[USDT]=y\n\t\t\t;;\n\t\t--without-usdt)\n\t\t\tCONFIG[USDT]=n\n\t\t\t;;\n\t\t--with-fuzzer)\n\t\t\techo \"Must specify fuzzer library path with --with-fuzzer\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\t--with-fuzzer=*)\n\t\t\tCONFIG[FUZZER]=y\n\t\t\tCONFIG[FUZZER_LIB]=$(readlink -f ${i#*=})\n\t\t\t;;\n\t\t--without-fuzzer)\n\t\t\tCONFIG[FUZZER]=n\n\t\t\tCONFIG[FUZZER_LIB]=\n\t\t\t;;\n\t\t--with-sma)\n\t\t\tCONFIG[SMA]=y\n\t\t\t;;\n\t\t--without-sma)\n\t\t\tCONFIG[SMA]=n\n\t\t\t;;\n\t\t--with-avahi)\n\t\t\tCONFIG[AVAHI]=y\n\t\t\t;;\n\t\t--without-avahi)\n\t\t\tCONFIG[AVAHI]=n\n\t\t\t;;\n\t\t--with-golang)\n\t\t\tCONFIG[GOLANG]=y\n\t\t\t;;\n\t\t--without-golang)\n\t\t\tCONFIG[GOLANG]=n\n\t\t\t;;\n\t\t--max-lcores='')\n\t\t\techo \"Must specify max number of lcores for --max-lcores\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\t--max-lcores=*)\n\t\t\tCONFIG[MAX_LCORES]=\"${i#*=}\"\n\t\t\tCONFIG[\"MAX_LCORES\"]=${CONFIG[\"MAX_LCORES\"],,}\n\t\t\t;;\n\t\t--max-numa-nodes='')\n\t\t\techo \"Must specify max number of nodes for --max-numa-nodes\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\t--max-numa-nodes=*)\n\t\t\tCONFIG[MAX_NUMA_NODES]=\"${i#*=}\"\n\t\t\tCONFIG[\"MAX_NUMA_NODES\"]=${CONFIG[\"MAX_NUMA_NODES\"],,}\n\t\t\t;;\n\t\t--with-aio-fsdev)\n\t\t\tCONFIG[AIO_FSDEV]=y\n\t\t\tAIO_FSDEV_REQUIRED=y\n\t\t\t;;\n\t\t--without-aio-fsdev)\n\t\t\tCONFIG[AIO_FSDEV]=n\n\t\t\t;;\n\t\t--)\n\t\t\tbreak\n\t\t\t;;\n\t\t*)\n\t\t\techo \"Unrecognized option $i\"\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\tesac\ndone\n\nif [[ $arch == x86_64* ]]; then\n\tBUILD_CMD=($CC -o /dev/null -x c $CPPFLAGS $CFLAGS $LDFLAGS \"-march=native\")\nelse\n\tBUILD_CMD=($CC -o /dev/null -x c $CPPFLAGS $CFLAGS $LDFLAGS)\nfi\nBUILD_CMD+=(-I/usr/local/include -L/usr/local/lib)\nBUILD_CMD+=(\"-fuse-ld=$LD_TYPE\")\nif [[ -n \"${CONFIG[OPENSSL_PATH]}\" ]]; then\n\tBUILD_CMD+=(\"-I${CONFIG[OPENSSL_PATH]}/include\" \"-L${CONFIG[OPENSSL_PATH]}\")\nfi\n\nif [[ \"${CONFIG[VFIO_USER]}\" = \"y\" ]]; then\n\tif ! echo -e '#include <json-c/json.h>' \\\n\t\t| \"${BUILD_CMD[@]}\" -E - 2> /dev/null; then\n\t\techo \"ERROR: --with-vfio-user requires json-c-devel\"\n\t\techo \"Please install then re-run this script\"\n\t\texit 1\n\tfi\n\tif ! echo -e '#include <cmocka.h>' \\\n\t\t| \"${BUILD_CMD[@]}\" -E - 2> /dev/null; then\n\t\techo \"ERROR: --with-vfio-user requires libcmocka-devel\"\n\t\techo \"Please install then re-run this script\"\n\t\texit 1\n\tfi\nfi\n\n# IDXD uses Intel specific instructions.\nif [[ \"${CONFIG[IDXD]}\" = \"y\" ]]; then\n\tif [ $(uname -s) == \"FreeBSD\" ]; then\n\t\tintel=\"hw.model: Intel\"\n\t\tcpu_vendor=$(sysctl -a | grep hw.model | cut -c 1-15)\n\telse\n\t\tintel=\"GenuineIntel\"\n\t\tcpu_vendor=$(grep -i 'vendor' /proc/cpuinfo --max-count=1)\n\tfi\n\tif [[ \"$cpu_vendor\" != *\"$intel\"* ]]; then\n\t\techo \"WARNING: IDXD cannot be used due to CPU incompatibility.\"\n\tfi\n\tif [ -e /usr/include/accel-config/libaccel_config.h ]; then\n\t\tCONFIG[IDXD_KERNEL]=y\n\tfi\n\nfi\n\nif [ -z \"${CONFIG[ENV]}\" ]; then\n\tCONFIG[ENV]=$rootdir/lib/env_dpdk\n\techo \"Using default SPDK env in ${CONFIG[ENV]}\"\n\tif [[ -z \"${CONFIG[DPDK_DIR]}\" && \"${CONFIG[DPDK_PKG_CONFIG]}\" == n ]]; then\n\t\tif [ ! -f \"$rootdir\"/dpdk/config/meson.build ]; then\n\t\t\techo \"DPDK not found; please specify --with-dpdk=<path> or run:\"\n\t\t\techo\n\t\t\techo \"  git submodule update --init\"\n\t\t\texit 1\n\t\telse\n\t\t\tCONFIG[DPDK_DIR]=\"${rootdir}/dpdk/build\"\n\t\t\t# Default ipsec libs\n\t\t\tif [[ \"${CONFIG[CRYPTO]}\" = \"y\" ]] && [[ $arch = x86_64* ]]; then\n\t\t\t\tCONFIG[IPSEC_MB]=y\n\t\t\t\tCONFIG[IPSEC_MB_DIR]=\"${rootdir}/intel-ipsec-mb/lib\"\n\t\t\tfi\n\t\t\techo \"Using default DPDK in ${CONFIG[DPDK_DIR]}\"\n\t\tfi\n\tfi\nelse\n\tif [[ -n \"${CONFIG[DPDK_DIR]}\" || \"${CONFIG[DPDK_PKG_CONFIG]}\" == y ]]; then\n\t\techo \"--with-env and --with-dpdk are mutually exclusive.\"\n\t\texit 1\n\tfi\n\n\tif [ \"${CONFIG[VHOST]}\" = \"y\" ]; then\n\t\techo \"Vhost is only supported when using the default DPDK environment. Disabling it.\"\n\tfi\n\t# Always disable vhost, but only print the error message if the user explicitly turned it on.\n\tCONFIG[VHOST]=\"n\"\n\tif [ \"${CONFIG[VIRTIO]}\" = \"y\" ]; then\n\t\techo \"Virtio is only supported when using the default DPDK environment. Disabling it.\"\n\tfi\n\t# Always disable virtio, but only print the error message if the user explicitly turned it on.\n\tCONFIG[VIRTIO]=\"n\"\nfi\n\nif [[ \"${CONFIG[DPDK_PKG_CONFIG]}\" == y ]]; then\n\tif [[ \"${CONFIG[SHARED]}\" == n ]]; then\n\t\t# dpdk-devel doesn't provide static libs\n\t\techo \"Build against packaged DPDK requested, enabling shared libraries\"\n\t\tCONFIG[SHARED]=y\n\tfi\nfi\n\nif [[ $sys_name == \"Windows\" ]]; then\n\tif [ -z \"${CONFIG[WPDK_DIR]}\" ]; then\n\t\tif [ ! -f \"$rootdir\"/wpdk/Makefile ]; then\n\t\t\techo \"WPDK not found; please specify --with-wpdk=<path>. See https://wpdk.github.io.\"\n\t\t\texit 1\n\t\telse\n\t\t\tCONFIG[WPDK_DIR]=\"${rootdir}/wpdk/build\"\n\t\t\techo \"Using default WPDK in ${CONFIG[WPDK_DIR]}\"\n\t\tfi\n\tfi\nelse\n\tif [ -n \"${CONFIG[WPDK_DIR]}\" ]; then\n\t\techo \"ERROR: --with-wpdk is only supported for Windows\"\n\t\texit 1\n\tfi\nfi\n\nif [ \"${CONFIG[VTUNE]}\" = \"y\" ]; then\n\tif [ -z \"${CONFIG[VTUNE_DIR]}\" ]; then\n\t\techo \"When VTune is enabled, you must specify the VTune directory using --with-vtune=path\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[ASAN]}\" = \"y\" && \"${CONFIG[TSAN]}\" = \"y\" ]]; then\n\techo \"ERROR: ASAN and TSAN cannot be enabled at the same time.\"\n\texit 1\nfi\n\nif [[ \"${CONFIG[FIO_PLUGIN]}\" = \"y\" && \"${CONFIG[EXAMPLES]}\" = \"n\" ]]; then\n\techo \"ERROR: --with-fio and --disable-examples are mutually exclusive.\"\n\texit 1\nfi\n\nif [[ $sys_name == \"FreeBSD\" ]]; then\n\t# FreeBSD doesn't support all configurations\n\tCONFIG[FSDEV]=n\nfi\n\nif [[ $sys_name == \"Linux\" ]]; then\n\tif pkg-config libbsd; then\n\t\tCONFIG[HAVE_LIBBSD]=y\n\tfi\nfi\n\nif pkg-config libarchive; then\n\tCONFIG[HAVE_LIBARCHIVE]=y\nfi\n\nif [[ $sys_name != \"Linux\" ]]; then\n\tif [[ \"${CONFIG[VHOST]}\" == \"y\" ]]; then\n\t\techo \"Vhost is only supported on Linux.\"\n\t\texit 1\n\tfi\n\tif [[ \"${CONFIG[VIRTIO]}\" == \"y\" ]]; then\n\t\techo \"Virtio is only supported on Linux.\"\n\t\texit 1\n\tfi\nfi\n\nif [ \"${CONFIG[RDMA]}\" = \"y\" ]; then\n\tif [[ ! \"${CONFIG[RDMA_PROV]}\" == \"verbs\" ]] && [[ ! \"${CONFIG[RDMA_PROV]}\" == \"mlx5_dv\" ]]; then\n\t\techo \"Invalid RDMA provider specified, must be \\\"verbs\\\" or \\\"mlx5_dv\\\"\"\n\t\texit 1\n\tfi\n\n\tif ! echo -e '#include <infiniband/verbs.h>\\n#include <rdma/rdma_verbs.h>\\n' \\\n\t\t'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -libverbs -lrdmacm - 2> /dev/null; then\n\t\techo \"--with-rdma requires libverbs and librdmacm.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\n\n\tif echo -e '#include <infiniband/verbs.h>\\n' \\\n\t\t'int main(void) { return !!IBV_WR_SEND_WITH_INV; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -c - 2> /dev/null; then\n\t\tCONFIG[RDMA_SEND_WITH_INVAL]=\"y\"\n\telse\n\t\tCONFIG[RDMA_SEND_WITH_INVAL]=\"n\"\n\t\techo \"\n*******************************************************************************\nWARNING: The Infiniband Verbs opcode Send With Invalidate is either not\nsupported or is not functional with the current version of libibverbs installed\non this system. Please upgrade to at least version 1.1.\n\nBeginning with Linux kernel 4.14, the kernel NVMe-oF initiator leverages Send\nWith Invalidate RDMA operations to improve performance. Failing to use the\nSend With Invalidate operation on the NVMe-oF target side results in full\nfunctionality, but greatly reduced performance. The SPDK NVMe-oF target will\nbe unable to leverage that operation using the currently installed version\nof libibverbs, so Linux kernel NVMe-oF initiators based on kernels greater\nthan or equal to 4.14 will see significantly reduced performance.\n*******************************************************************************\"\n\tfi\n\n\tif echo -e '#include <rdma/rdma_cma.h>\\n' \\\n\t\t'int main(void) { return !!RDMA_OPTION_ID_ACK_TIMEOUT; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -c - 2> /dev/null; then\n\t\tCONFIG[RDMA_SET_ACK_TIMEOUT]=\"y\"\n\telse\n\t\tCONFIG[RDMA_SET_ACK_TIMEOUT]=\"n\"\n\t\techo \"RDMA_OPTION_ID_ACK_TIMEOUT is not supported\"\n\tfi\n\n\tif echo -e '#include <rdma/rdma_cma.h>\\n' \\\n\t\t'int main(void) { return !!RDMA_OPTION_ID_TOS; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -c - 2> /dev/null; then\n\t\tCONFIG[RDMA_SET_TOS]=\"y\"\n\telse\n\t\tCONFIG[RDMA_SET_TOS]=\"n\"\n\t\techo \"RDMA_OPTION_ID_TOS is not supported\"\n\tfi\n\n\tif [ \"${CONFIG[RDMA_PROV]}\" == \"mlx5_dv\" ]; then\n\t\tMLX5_DV_BUILD_BUILD_CMD=\"\n\t\t#include <infiniband/mlx5dv.h>\\n\n\t\t#include <rdma/rdma_cma.h>\\n\n\t\tint main(void) { return rdma_establish(NULL) ||\\n\n\t\t!!IBV_QP_INIT_ATTR_SEND_OPS_FLAGS || !!MLX5_OPCODE_RDMA_WRITE\"\n\t\tif [ \"${CONFIG[CRYPTO]}\" = \"y\" ]; then\n\t\t\tMLX5_DV_BUILD_BUILD_CMD+=\"|| !!MLX5DV_CRYPTO_ENGINES_CAP_AES_XTS_SINGLE_BLOCK\"\n\t\tfi\n\t\tMLX5_DV_BUILD_BUILD_CMD+=\";}\"\n\t\tif ! echo -e $MLX5_DV_BUILD_BUILD_CMD | \"${BUILD_CMD[@]}\" -lmlx5 -I${rootdir}/include -c -; then\n\t\t\techo \"mlx5_dv provider is not supported\"\n\t\t\texit 1\n\t\tfi\n\tfi\n\n\techo \"Using '${CONFIG[RDMA_PROV]}' RDMA provider\"\nfi\n\nif [[ \"${CONFIG[FC]}\" = \"y\" ]]; then\n\tif [[ -n \"${CONFIG[FC_PATH]}\" ]]; then\n\t\tcheck_dir \"${CONFIG[FC_PATH]}\"\n\tfi\nfi\n\nfunction dpdk_version() {\n\t# Check DPDK version to determine if mlx5_pci driver is supported\n\tlocal dpdk_ver=\"none\"\n\tif [[ \"${CONFIG[DPDK_DIR]}\" == \"$rootdir/dpdk/build\" ]]; then\n\t\t# DPDK_DIR points at our submodule so ./build may not exist yet. Use\n\t\t# absolute path to lookup the version.\n\t\tdpdk_ver=$(< \"$rootdir/dpdk/VERSION\")\n\telif [[ -f \"${CONFIG[DPDK_DIR]}\"/../VERSION ]]; then\n\t\tdpdk_ver=$(< \"${CONFIG[DPDK_DIR]}\"/../VERSION)\n\tfi\n\techo $dpdk_ver\n}\n\nfunction mlx5_build() {\n\t# Check if libmlx5 exists to enable mlx5_pci compress/crypto PMD\n\tif ! echo -e '#include <spdk/stdinc.h>\\n' \\\n\t\t'#include <infiniband/mlx5dv.h>\\n' \\\n\t\t'#include <infiniband/verbs.h>\\n' \\\n\t\t'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -lmlx5 -libverbs -I${rootdir}/include -c - 2> /dev/null; then\n\t\treturn 1\n\tfi\n\treturn 0\n}\n\nif [[ \"${CONFIG[VBDEV_COMPRESS]}\" = \"y\" ]]; then\n\tif ! echo -e '#include <libpmem.h>\\nint main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -lpmem - 2> /dev/null; then\n\t\techo \"--with-vbdev-compress requires libpmem.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\n\t# Try to enable mlx5 compress\n\tCONFIG[VBDEV_COMPRESS_MLX5]=\"y\"\n\n\t# Check if libmlx5 exists to enable mlx5_pci compress PMD\n\tif ! mlx5_build; then\n\t\techo \"libmlx5 is not found, so disabling DPDK mlx5_pci compress PMD\"\n\t\tCONFIG[VBDEV_COMPRESS_MLX5]=\"n\"\n\telse\n\t\tif [[ \"${CONFIG[DPDK_PKG_CONFIG]}\" = \"y\" ]]; then\n\t\t\t# Check if librte_compress_mlx5 exists in DPDK package\n\t\t\tif [ ! -f \"${CONFIG[DPDK_LIB_DIR]}\"/librte_compress_mlx5.so ]; then\n\t\t\t\techo \"librte_compress_mlx5 is not found, so disabling DPDK mlx5_pci compress PMD\"\n\t\t\t\tCONFIG[VBDEV_COMPRESS_MLX5]=\"n\"\n\t\t\tfi\n\t\telse\n\t\t\t# Check DPDK version to determine if mlx5_pci driver is supported\n\t\t\tdpdk_ver=$(dpdk_version)\n\t\t\tif [[ $dpdk_ver = \"none\" ]]; then\n\t\t\t\techo \"Cannot get DPDK version, so disabling DPDK mlx5_pci compress PMD\"\n\t\t\t\tCONFIG[VBDEV_COMPRESS_MLX5]=\"n\"\n\t\t\telif [[ -n $dpdk_ver ]] && lt \"$dpdk_ver\" 21.02.0; then\n\t\t\t\t# mlx5_pci for compress is supported by DPDK >- 21.02.0\n\t\t\t\techo \"DPDK version ${dpdk_ver} doesn't support mlx5_pci compress PMD\"\n\t\t\t\tCONFIG[VBDEV_COMPRESS_MLX5]=\"n\"\n\t\t\telif [[ -n ${CONFIG[DPDK_LIB_DIR]} ]] && [ ! -f \"${CONFIG[DPDK_LIB_DIR]}\"/librte_compress_mlx5.so ]; then\n\t\t\t\t# This is only checked when --with-dpdk or --with-dpdk=* is used\n\t\t\t\techo \"librte_compress_mlx5 is not found, so disabling DPDK mlx5_pci compress PMD\"\n\t\t\t\tCONFIG[VBDEV_COMPRESS_MLX5]=\"n\"\n\t\t\tfi\n\t\tfi\n\tfi\nfi\n\nif [[ \"${CONFIG[CRYPTO]}\" = \"y\" ]]; then\n\t# Try to enable mlx5 crypto\n\tCONFIG[CRYPTO_MLX5]=\"y\"\n\n\t# Check if libmlx5 exists to enable mlx5_pci compress PMD\n\tif ! mlx5_build; then\n\t\techo \"libmlx5 is not found, so disabling DPDK mlx5_pci crypto PMD\"\n\t\tCONFIG[CRYPTO_MLX5]=\"n\"\n\telse\n\t\tif [[ \"${CONFIG[DPDK_PKG_CONFIG]}\" = \"y\" ]]; then\n\t\t\t# Check if librte_crypto_mlx5 exists in DPDK package\n\t\t\tif [ ! -f \"${CONFIG[DPDK_LIB_DIR]}\"/librte_crypto_mlx5.so ]; then\n\t\t\t\techo \"librte_crypto_mlx5 is not found, so disabling DPDK mlx5_pci crypto PMD\"\n\t\t\t\tCONFIG[CRYPTO_MLX5]=\"n\"\n\t\t\tfi\n\t\telse\n\t\t\t# Check DPDK version to determine if mlx5_pci driver is supported\n\t\t\tdpdk_ver=$(dpdk_version)\n\t\t\tif [[ $dpdk_ver = \"none\" ]]; then\n\t\t\t\techo \"Cannot get DPDK version, so disabling DPDK mlx5_pci crypto PMD\"\n\t\t\t\tCONFIG[CRYPTO_MLX5]=\"n\"\n\t\t\telif [[ -n $dpdk_ver ]] && lt \"$dpdk_ver\" 21.11.0; then\n\t\t\t\t# mlx5_pci for crypto is supported by DPDK >- 21.11.0\n\t\t\t\techo \"DPDK version ${dpdk_ver} doesn't support mlx5_pci crypto PMD\"\n\t\t\t\tCONFIG[CRYPTO_MLX5]=\"n\"\n\t\t\telif [[ -n ${CONFIG[DPDK_LIB_DIR]} ]] && [ ! -f \"${CONFIG[DPDK_LIB_DIR]}\"/librte_crypto_mlx5.so ]; then\n\t\t\t\t# This is only checked when --with-dpdk or --with-dpdk=* is used\n\t\t\t\techo \"librte_crypto_mlx5 is not found, so disabling DPDK mlx5_pci crypto PMD\"\n\t\t\t\tCONFIG[CRYPTO_MLX5]=\"n\"\n\t\t\tfi\n\t\tfi\n\tfi\nfi\n\nif [[ \"${CONFIG[NVME_CUSE]}\" = \"y\" ]]; then\n\tif ! echo -e '#define FUSE_USE_VERSION 31\\n#include <fuse3/cuse_lowlevel.h>\\n#include <fuse3/fuse_lowlevel.h>\\n#include <fuse3/fuse_opt.h>\\nint main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -lfuse3 -D_FILE_OFFSET_BITS=64 - 2> /dev/null; then\n\t\techo \"--with-nvme-cuse requires libfuse3.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[RBD]}\" = \"y\" ]]; then\n\tif ! echo -e '#include <rbd/librbd.h>\\n#include <rados/librados.h>\\n' \\\n\t\t'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -lrados -lrbd - 2> /dev/null; then\n\t\techo \"--with-rbd requires librados and librbd.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[UBLK]}\" = \"y\" ]]; then\n\tif ! echo -e '#include <linux/ublk_cmd.h>\\n#include <liburing.h>\\n' \\\n\t\t'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -luring - 2> /dev/null; then\n\t\techo \"--with-ublk requires liburing and ublk_drv.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[DPDK_UADK]}\" = \"y\" ]]; then\n\tif ! pkg-config --exists libwd; then\n\t\techo \"--with-dpdk-uadk requires uadk library.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[ISCSI_INITIATOR]}\" = \"y\" ]]; then\n\t# Fedora installs libiscsi to /usr/lib64/iscsi for some reason.\n\tif ! echo -e '#include <iscsi/iscsi.h>\\n#include <iscsi/scsi-lowlevel.h>\\n' \\\n\t\t'#if LIBISCSI_API_VERSION < 20150621\\n' \\\n\t\t'#error\\n' \\\n\t\t'#endif\\n' \\\n\t\t'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -L/usr/lib64/iscsi -liscsi - 2> /dev/null; then\n\t\techo \"--with-iscsi-initiator requires libiscsi with\"\n\t\techo \"LIBISCSI_API_VERSION >= 20150621.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[DAOS]}\" = \"y\" ]]; then\n\tdaos_build_cmd=(\"${BUILD_CMD[@]}\")\n\tif [[ -n \"${CONFIG[DAOS_DIR]}\" ]]; then\n\t\tdaos_build_cmd+=(-I\"${CONFIG[DAOS_DIR]}\"/include -L\"${CONFIG[DAOS_DIR]}\"/lib64)\n\tfi\n\tif ! echo -e '#include <daos.h>\\n#include <daos_fs.h>\\n' \\\n\t\t'int main(void) { return 0; }\\n' \\\n\t\t| \"${daos_build_cmd[@]}\" -lgurt -ldaos -ldaos_common -ldfs - 2> /dev/null; then\n\t\techo \"--with-daos requires libdaos, libdaos_common, libdfs and libgurt\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[ASAN]}\" = \"y\" ]]; then\n\tif ! echo -e 'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -fsanitize=address - 2> /dev/null; then\n\t\techo \"--enable-asan requires libasan.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[UBSAN]}\" = \"y\" ]]; then\n\tif ! echo -e 'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -fsanitize=undefined - 2> /dev/null; then\n\t\techo \"--enable-ubsan requires libubsan.\"\n\t\techo \"Please install then re-run this script.\"\n\t\techo \"If installed, please check that the GCC version is at least 6.4\"\n\t\techo \"and synchronize CC accordingly.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[TSAN]}\" = \"y\" ]]; then\n\tif ! echo -e 'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -fsanitize=thread - 2> /dev/null; then\n\t\techo \"--enable-tsan requires libtsan.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif echo -e '#include <stdlib.h>\\nint main(void) { arc4random(); return 0; }\\n' \\\n\t| \"${BUILD_CMD[@]}\" - 2> /dev/null; then\n\tCONFIG[HAVE_ARC4RANDOM]=\"y\"\nfi\n\nif echo -e '#include <uuid/uuid.h>\\nint main(void) { uuid_generate_sha1(NULL, NULL, NULL, 0); return 0; }\\n' \\\n\t| \"${BUILD_CMD[@]}\" - -luuid 2> /dev/null; then\n\tCONFIG[HAVE_UUID_GENERATE_SHA1]=\"y\"\nfi\n\nif echo -e '#include <execinfo.h>' | \"${BUILD_CMD[@]}\" -c - 2> /dev/null; then\n\tCONFIG[HAVE_EXECINFO_H]=y\nfi\n\nif echo -e '#include <keyutils.h>\\nint main(void) { request_key(0, 0, 0, -1); return 0; }' \\\n\t| \"${BUILD_CMD[@]}\" - -lkeyutils 2> /dev/null; then\n\tCONFIG[HAVE_KEYUTILS]=y\nfi\n\nif echo -e '#include <openssl/evp.h>\\nint main(void) { EVP_MAC *m = EVP_MAC_fetch(0, 0, 0); return 0; }' \\\n\t| \"${BUILD_CMD[@]}\" - -lcrypto 2> /dev/null; then\n\tCONFIG[HAVE_EVP_MAC]=y\nfi\n\nif echo -e '#include <lz4.h>\\nint main(void) { return 0; }\\n' \\\n\t| \"${BUILD_CMD[@]}\" -llz4 - 2> /dev/null; then\n\tCONFIG[HAVE_LZ4]=\"y\"\nfi\n\nif [[ \"${CONFIG[OCF]}\" = \"y\" ]]; then\n\t# If OCF_PATH is a file, assume it is a library and use it to compile with\n\tif [ -f ${CONFIG[OCF_PATH]} ]; then\n\t\tCONFIG[CUSTOMOCF]=y\n\telse\n\t\tCONFIG[CUSTOMOCF]=n\n\tfi\nfi\n\nif [[ \"${CONFIG[PGO_CAPTURE]}\" = \"y\" && \"${CONFIG[PGO_USE]}\" = \"y\" ]]; then\n\techo \"ERROR: --enable-pgo-capture and --enable-pgo-use are mutually exclusive.\"\n\texit 1\nelif [[ \"${CONFIG[PGO_CAPTURE]}\" = \"y\" || \"${CONFI[PGO_USE]}\" = \"y\" ]]; then\n\tif [[ -z \"${CONFIG[PGO_DIR]}\" ]]; then\n\t\tCONFIG[PGO_DIR]=$(realpath $rootdir/build/pgo)\n\tfi\nfi\n\nif [[ \"${CONFIG[PGO_USE]}\" = \"y\" ]]; then\n\tif [[ \"$CC_TYPE\" = \"clang\" ]]; then\n\t\t# For clang we need to run an extra step on gathered profiling data.\n\t\techo \"Generating suitable profile data\"\n\t\tllvm-profdata merge -output=${CONFIG[PGO_DIR]}/default.profdata ${CONFIG[PGO_DIR]}\n\tfi\nfi\n\nif [[ \"${CONFIG[URING]}\" = \"y\" || \"${CONFIG[XNVME]}\" = \"y\" ]]; then\n\tif [[ -n \"${CONFIG[URING_PATH]}\" ]]; then\n\t\tcheck_dir \"${CONFIG[URING_PATH]}\"\n\telif ! echo -e '#include <liburing.h>\\nint main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -luring - 2> /dev/null; then\n\t\techo \"--with-uring requires liburing.\"\n\t\techo \"Please build and install then re-run this script.\"\n\t\texit 1\n\tfi\n\t# Support for Zoned devices is enabled by default for Uring bdev. Check appropriate support in kernel.\n\tif [[ \"${CONFIG[URING_ZNS]}\" = \"y\" ]]; then\n\t\tif ! echo -e '#include<linux/blkzoned.h>\\nint main(void) { return BLK_ZONE_REP_CAPACITY; }\\n' \\\n\t\t\t| \"${BUILD_CMD[@]}\" -c - 2> /dev/null; then\n\t\t\techo \"Disabling Zoned NS support in Uring! Requires blkzoned.h from kernel >= linux-5.9.\"\n\t\t\tCONFIG[URING_ZNS]=n\n\t\tfi\n\tfi\nfi\n\nif [[ \"${CONFIG[FUSE]}\" = \"y\" ]]; then\n\tif [[ ! -d /usr/include/fuse3 ]] && [[ ! -d /usr/local/include/fuse3 ]]; then\n\t\techo \"--with-fuse requires libfuse3.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [ \"${CONFIG[CET]}\" = \"y\" ]; then\n\tif ! echo -e 'int main(void) { return 0; }\\n' | \"${BUILD_CMD[@]}\" -fcf-protection - 2> /dev/null; then\n\t\techo \"--enable-cet requires compiler/linker that supports CET.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[FUZZER]}\" = \"y\" && \"$CC_TYPE\" != \"clang\" ]]; then\n\techo \"--with-fuzzer requires setting CC and CXX to clang.\"\n\texit 1\nfi\n\nif [[ $arch == x86_64* ]] || [[ $arch == aarch64* ]]; then\n\tCONFIG[ISAL]=y\n\t# make sure the submodule is initialized\n\tif [ ! -f \"$rootdir\"/isa-l/autogen.sh ]; then\n\t\techo \"ISA-L is required but was not found, please init the submodule with:\"\n\t\techo \"  git submodule update --init\"\n\t\techo \"and then re-run this script.\"\n\t\texit 1\n\tfi\n\t# for x86 only, check the nasm version for ISA-L and IPSEC\n\tif [[ $arch == x86_64* ]]; then\n\t\tver=$(nasm -v 2> /dev/null | awk '{print $3}' | awk -Fr '{print $1}')\n\t\tif lt \"$ver\" 2.14; then\n\t\t\tCONFIG[ISAL]=n\n\t\t\t# IPSEC has nasm requirement and DPDK crypto relies on IPSEC\n\t\t\tCONFIG[IPSEC_MB]=n\n\t\t\techo \"WARNING: ISA-L & DPDK crypto cannot be used as nasm ver must be 2.14 or newer.\"\n\t\tfi\n\tfi\n\t# check gas version on aarch64\n\tif [[ $arch == aarch64* ]]; then\n\t\tver=$(as --version 2> /dev/null | awk '/GNU assembler/{print $NF}')\n\t\tif lt \"$ver\" 2.24; then\n\t\t\t# ISA-L, compression & crypto require gas version 2.24 or newer.\n\t\t\tCONFIG[ISAL]=n\n\t\t\techo \"Notice: ISA-L, compression & crypto require GAS version 2.24 or newer. Turning off default ISA-L and crypto features.\"\n\t\telif lt \"$ver\" 2.34; then\n\t\t\t#For gas v2.24~v2.34, sve2 instructions are not supported. To workaround it, sve2 optimization should be disabled\n\t\t\tISAL_CRYPTO_OPTS+=(\"--disable-sve2\")\n\t\tfi\n\tfi\nelse\n\t# for PPC\n\tCONFIG[ISAL]=n\n\techo \"WARNING: ISA-L cannot be used due to architecture incompatibility.\"\nfi\n\n# now either configure ISA-L or disable unavailable features\nif [[ \"${CONFIG[ISAL]}\" = \"y\" ]]; then\n\tcd $rootdir/isa-l\n\tISAL_LOG=$rootdir/.spdk-isal.log\n\tif [[ -n \"${CONFIG[CROSS_PREFIX]}\" ]]; then\n\t\tISAL_OPTS=(\"--host=${CONFIG[CROSS_PREFIX]}\")\n\telse\n\t\tISAL_OPTS=()\n\tfi\n\tif [[ \"${CONFIG[SHARED]}\" = \"y\" ]]; then\n\t\tISAL_OPTS+=(\"--enable-shared=yes\")\n\telse\n\t\tISAL_OPTS+=(\"--enable-shared=no\")\n\tfi\n\tISAL_OPTS+=(\"--prefix=${CONFIG[PREFIX]}\")\n\techo -n \"Configuring ISA-L (logfile: $ISAL_LOG)...\"\n\t./autogen.sh &> $ISAL_LOG\n\t./configure CFLAGS=\"-fPIC -g -O2 -fuse-ld=$LD_TYPE -Wno-unused-command-line-argument\" \"${ISAL_OPTS[@]}\" --enable-shared=no >> $ISAL_LOG 2>&1\n\techo \"done.\"\n\tcd $rootdir\nelse\n\techo \"Without ISA-L, there is no software support for crypto or compression,\"\n\techo \"so these features will be disabled.\"\n\tCONFIG[CRYPTO]=n\n\tCONFIG[VBDEV_COMPRESS]=n\n\tCONFIG[DPDK_COMPRESSDEV]=n\nfi\n\n# ISA-L-crypto complements ISA-L functionality, it is only enabled together with ISA-L\nif [[ \"${CONFIG[ISAL]}\" = \"y\" ]]; then\n\tif [ ! -f \"$rootdir\"/isa-l-crypto/autogen.sh ]; then\n\t\techo \"ISA-L-crypto is required but was not found, please init the submodule with:\"\n\t\techo \"  git submodule update --init\"\n\t\techo \"and then re-run this script.\"\n\t\texit 1\n\tfi\n\n\tcd $rootdir/isa-l-crypto\n\tISAL_CRYPTO_LOG=$rootdir/.spdk-isal-crypto.log\n\tif [[ -n \"${CONFIG[CROSS_PREFIX]}\" ]]; then\n\t\tISAL_CRYPTO_OPTS+=(\"--host=${CONFIG[CROSS_PREFIX]}\")\n\tfi\n\tif [[ \"${CONFIG[SHARED]}\" = \"y\" ]]; then\n\t\tISAL_CRYPTO_OPTS+=(\"--enable-shared=yes\")\n\telse\n\t\tISAL_CRYPTO_OPTS+=(\"--enable-shared=no\")\n\tfi\n\tISAL_CRYPTO_OPTS+=(\"--prefix=${CONFIG[PREFIX]}\")\n\techo -n \"Configuring ISA-L-crypto (logfile: $ISAL_CRYPTO_LOG)...\"\n\t./autogen.sh &> $ISAL_CRYPTO_LOG\n\t./configure CFLAGS=\"-fPIC -g -O2 -fuse-ld=$LD_TYPE -Wno-unused-command-line-argument\" \"${ISAL_CRYPTO_OPTS[@]}\" >> $ISAL_CRYPTO_LOG 2>&1\n\techo \"done.\"\n\tcd $rootdir\n\tCONFIG[ISAL_CRYPTO]=y\nelse\n\tCONFIG[ISAL_CRYPTO]=n\nfi\n\nif [[ \"${CONFIG[SMA]}\" = \"y\" ]]; then\n\tif ! python3 -c 'import grpc; import grpc_tools' 2> /dev/null; then\n\t\techo \"--with-sma requires grpcio and grpcio-tools python packages.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[AVAHI]}\" = \"y\" ]]; then\n\tif ! echo -e '#include <avahi-client/client.h>\\n#include <avahi-common/malloc.h>\\n' \\\n\t\t'int main(void) { return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" -lavahi-client -lavahi-common - 2> /dev/null; then\n\t\techo \"--with-avahi requires libavahi-client and libavahi-common.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[GOLANG]}\" = \"y\" ]]; then\n\tif ! go version 2> /dev/null; then\n\t\techo \"--with-golang requires Go installation.\"\n\t\techo \"Please install then re-run this script.\"\n\t\texit 1\n\tfi\nfi\n\nif [[ -n ${CONFIG[MAX_LCORES]} ]]; then\n\tif [[ ! ${CONFIG[MAX_LCORES]} =~ ^([1-9][0-9]*|detect)$ ]] || ((CONFIG[MAX_LCORES] > 1024)); then\n\t\techo \"ERROR: Max number of lcores must be a decimal number in range [1..1024] or 'detect' (given: ${CONFIG[MAX_LCORES]})\"\n\t\texit 1\n\tfi\nfi\n\nif [[ -n ${CONFIG[MAX_NUMA_NODES]} ]]; then\n\tif [[ ! ${CONFIG[MAX_NUMA_NODES]} =~ ^([1-9][0-9]*)$ ]] || ((CONFIG[MAX_NUMA_NODES] > 16)); then\n\t\techo \"ERROR: Max number of lcores must be a decimal number in range [1..16] (given: ${CONFIG[MAX_LCORES]})\"\n\t\texit 1\n\tfi\nfi\n\nif [[ \"${CONFIG[FSDEV]}\" = \"n\" ]]; then\n\tif [[ \"$AIO_FSDEV_REQUIRED\" = \"y\" ]]; then\n\t\techo \"ERROR: --with-aio-fsdev cannot be specified as fsdev is disabled.\"\n\t\texit 1\n\tfi\n\n\t# if AIO_FSDEV is not explicitly required by user, we just silently disable it\n\tCONFIG[AIO_FSDEV]=n\nfi\n\nif [[ \"${CONFIG[AIO_FSDEV]}\" = \"y\" ]]; then\n\tif echo -e '#define _GNU_SOURCE\\n#include <unistd.h>\\n' \\\n\t\t'int main(void) { return copy_file_range(0, 0, 0, 0, 0, 0); }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" - 2> /dev/null; then\n\t\tCONFIG[COPY_FILE_RANGE]=y\n\telse\n\t\tCONFIG[COPY_FILE_RANGE]=n\n\tfi\n\tif echo -e '#include <sys/stat.h>\\n' \\\n\t\t'int main(void) { struct stat s; s.st_atime = s.st_atime; return 0 ;}\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" - 2> /dev/null; then\n\t\tCONFIG[HAVE_STRUCT_STAT_ST_ATIM]=y\n\t\tCONFIG[HAVE_STRUCT_STAT_ST_ATIMESPEC]=n\n\telif echo -e '#include <sys/stat.h>\\n' \\\n\t\t'int main(void) { struct stat s; s.st_atimespec = s.st_atimespec; return 0; }\\n' \\\n\t\t| \"${BUILD_CMD[@]}\" - 2> /dev/null; then\n\t\tCONFIG[HAVE_STRUCT_STAT_ST_ATIM]=n\n\t\tCONFIG[HAVE_STRUCT_STAT_ST_ATIMESPEC]=y\n\telse\n\t\tCONFIG[HAVE_STRUCT_STAT_ST_ATIM]=n\n\t\tCONFIG[HAVE_STRUCT_STAT_ST_ATIMESPEC]=n\n\tfi\nfi\n\n# For ARM Neoverse-N1 platform, debug build needs gcc version newer than 8.4\nif [[ \"${CONFIG[DEBUG]}\" = \"y\" && $arch = aarch64* && \"$CC_TYPE\" = \"gcc\" ]]; then\n\tGCC_VERSION=$($CC -dumpfullversion)\n\tPART_NUM=$(grep -i -m 1 \"CPU part\" /proc/cpuinfo | awk '{print $4}')\n\n\tif [[ \"$(printf '%s\\n' \"8.4.0\" \"$GCC_VERSION\" | sort -V | head -n1)\" != \"8.4.0\" ]]; then\n\t\tif [[ $PART_NUM = 0xd0c ]]; then\n\t\t\techo \"WARNING: For ARM Neoverse-N1 platform, debug build needs GCC version newer than 8.4.\"\n\t\t\techo \"         Will work around this by using armv8.2-a+crypto as target architecture for now.\"\n\t\t\tCONFIG[ARCH]=armv8.2-a+crypto\n\t\telif [[ $PART_NUM = 0x0b2 ]]; then\n\t\t\techo \"WARNING: For ARM octeontx2 platform, debug build needs GCC version newer than 8.4.\"\n\t\t\techo \"         Will work around this by using armv8.2-a+crypto as target architecture for now.\"\n\t\t\tCONFIG[ARCH]=armv8.2-a+crypto\n\t\tfi\n\tfi\nfi\n\n# We are now ready to generate final configuration. But first do sanity\n# check to see if all keys in CONFIG array have its reflection in CONFIG file.\nif (($(grep -cE \"^\\s*CONFIG_[[:alnum:]_]+=\" \"$rootdir/CONFIG\") != ${#CONFIG[@]})); then\n\techo \"\"\n\techo \"BUG: Some configuration options are not present in CONFIG file. Please update this file.\"\n\techo \"Missing options in CONFIG (+) file and in current config (-): \"\n\tdiff -u --label \"CONFIG file\" --label \"CONFIG[@]\" \\\n\t\t<(sed -r -e '/^[[:space:]]*$/d; /^[[:space:]]*#.*/d; s/(CONFIG_[[:alnum:]_]+)=.*/\\1/g' CONFIG | sort) \\\n\t\t<(printf \"CONFIG_%s\\n\" \"${!CONFIG[@]}\" | sort)\n\texit 1\nfi\n\necho -n \"Creating mk/config.mk...\"\ncp -f $rootdir/CONFIG $rootdir/mk/config.mk\nARGS=$(echo \"$@\" | sed 's/ /\\\\ /g')\nsed -i.bak -r \"s#__CONFIGURE_OPTIONS__#${ARGS}#g\" $rootdir/mk/config.mk\nfor key in \"${!CONFIG[@]}\"; do\n\tsed -i.bak -r \"s#[[:space:]]*CONFIG_${key}=.*#CONFIG_${key}\\?=${CONFIG[$key]}#g\" $rootdir/mk/config.mk\ndone\n# On FreeBSD sed -i 'SUFFIX' - SUFFIX is mandatory. So no way but to delete the backed file.\nrm -f $rootdir/mk/config.mk.bak\necho \"done.\"\n\n# Environment variables\necho -n \"Creating mk/cc.flags.mk...\"\nrm -f $rootdir/mk/cc.flags.mk\n[ -n \"$CFLAGS\" ] && echo \"CFLAGS?=$CFLAGS\" > $rootdir/mk/cc.flags.mk\n[ -n \"$CXXFLAGS\" ] && echo \"CXXFLAGS?=$CXXFLAGS\" >> $rootdir/mk/cc.flags.mk\n[ -n \"$LDFLAGS\" ] && echo \"LDFLAGS?=$LDFLAGS\" >> $rootdir/mk/cc.flags.mk\n[ -n \"$DESTDIR\" ] && echo \"DESTDIR?=$DESTDIR\" >> $rootdir/mk/cc.flags.mk\necho \"done.\"\n\n# Create .sh with build config for easy sourcing|lookup during the tests.\nfor conf in \"${!CONFIG[@]}\"; do\n\techo \"CONFIG_$conf=${CONFIG[$conf]}\"\ndone > \"$rootdir/test/common/build_config.sh\"\n\nif [[ $sys_name == \"FreeBSD\" ]]; then\n\techo \"Type 'gmake' to build.\"\nelse\n\techo \"Type 'make' to build.\"\nfi\n\nexit 0\n"
        },
        {
          "name": "deprecation.md",
          "type": "blob",
          "size": 2.08203125,
          "content": "# Deprecation\n\n## ABI and API Deprecation\n\nThis document details the policy for maintaining stability of SPDK ABI and API.\n\nMajor ABI version can change at most once for each SPDK release.\nABI versions are managed separately for each library and follow [Semantic Versioning](https://semver.org/).\n\nAPI and ABI deprecation notices shall be posted in the next section.\nEach entry must describe what will be removed and can suggest the future use or alternative.\nSpecific future SPDK release for the removal must be provided.\nABI cannot be removed without providing deprecation notice for at least single SPDK release.\n\nDeprecated code paths must be registered with `SPDK_LOG_DEPRECATION_REGISTER()` and logged with\n`SPDK_LOG_DEPRECATED()`. The tag used with these macros will appear in the SPDK\nlog at the warn level when `SPDK_LOG_DEPRECATED()` is called, subject to rate limits.\nThe tags can be matched with the level 4 headers below.\n\n## Deprecation Notices\n\n### gpt\n\n#### `old_gpt_guid`\n\nDeprecated the SPDK partition type GUID `7c5222bd-8f5d-4087-9c00-bf9843c7b58c`. Partitions of this\ntype have bdevs created that are one block less than the actual size of the partition. Existing\npartitions using the deprecated GUID can continue to use that GUID; support for the deprecated GUID\nwill remain in SPDK indefinitely, and will continue to exhibit the off-by-one bug so that on-disk\nmetadata layouts based on the incorrect size are not affected.\n\nSee GitHub issue [2801](https://github.com/spdk/spdk/issues/2801) for additional details on the bug.\n\nNew SPDK partition types should use GUID `6527994e-2c5a-4eec-9613-8f5944074e8b` which will create\na bdev of the correct size.\n\n### rpc\n\n#### `spdk_rpc_listen` `spdk_rpc_accept` `spdk_rpc_close`\n\nThese functions are deprecated and will be removed in 24.09 release. Please use\n`spdk_rpc_server_listen`, `spdk_rpc_server_accept` and `spdk_rpc_server_close` instead.\n\n### env\n\n#### `spdk_env_get_socket_id`, `spdk_pci_device_get_socket_id`\n\nThese functions are deprecated and will be removed in 25.05 release. Please use\n`spdk_env_get_numa_id` and `spdk_pci_device_get_numa_id` instead.\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "dpdk",
          "type": "commit",
          "content": null
        },
        {
          "name": "dpdkbuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "intel-ipsec-mb",
          "type": "commit",
          "content": null
        },
        {
          "name": "ipsecbuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "isa-l",
          "type": "commit",
          "content": null
        },
        {
          "name": "isa-l-crypto",
          "type": "commit",
          "content": null
        },
        {
          "name": "isalbuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "isalcryptobuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "libvfio-user",
          "type": "commit",
          "content": null
        },
        {
          "name": "licenses",
          "type": "tree",
          "content": null
        },
        {
          "name": "mdl_rules.rb",
          "type": "blob",
          "size": 0.240234375,
          "content": "all\nexclude_rule 'MD004'\nrule 'MD007', :indent => 2\nexclude_rule 'MD010'\nrule 'MD013', :line_length => 170\nexclude_rule 'MD024'\nrule 'MD029', :style => \"ordered\"\nexclude_rule 'MD031'\nexclude_rule 'MD033'\nexclude_rule 'MD034'\nexclude_rule 'MD041'\n"
        },
        {
          "name": "mk",
          "type": "tree",
          "content": null
        },
        {
          "name": "module",
          "type": "tree",
          "content": null
        },
        {
          "name": "ocf",
          "type": "commit",
          "content": null
        },
        {
          "name": "proto",
          "type": "tree",
          "content": null
        },
        {
          "name": "python",
          "type": "tree",
          "content": null
        },
        {
          "name": "rpmbuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "shared_lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "vfiouserbuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "xnvme",
          "type": "commit",
          "content": null
        },
        {
          "name": "xnvmebuild",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}