{
  "metadata": {
    "timestamp": 1736709889781,
    "page": 379,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "orangeduck/mpc",
      "stars": 2705,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.015625,
          "content": "\"* text=auto\" \r\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1259765625,
          "content": "*~\n*.exe\n*.dSYM\ntest\nexamples/doge\nexamples/lispy\nexamples/maths\nexamples/smallc\nexamples/foobar\nexamples/tree_traversal\nbuild/*\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.5,
          "content": "Licensed Under BSD\n\nCopyright (c) 2013, Daniel Holden\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: \n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies, \neither expressed or implied, of the FreeBSD Project."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.6787109375,
          "content": "PROJ = mpc\r\nCC ?= gcc\r\nSTD ?= -ansi\r\nDIST = build\r\nMKDIR  ?= mkdir -p\r\nPREFIX ?= /usr/local\r\nCFLAGS ?= $(STD) -pedantic -O3 -g -Wall -Werror -Wextra -Wformat=2 -Wshadow \\\r\n  -Wno-long-long -Wno-overlength-strings -Wno-format-nonliteral -Wcast-align \\\r\n  -Wwrite-strings -Wstrict-prototypes -Wold-style-definition -Wredundant-decls \\\r\n  -Wnested-externs -Wmissing-include-dirs -Wswitch-default\r\n\r\nTESTS = $(wildcard tests/*.c)\r\nEXAMPLES = $(wildcard examples/*.c)\r\nEXAMPLESEXE = $(EXAMPLES:.c=)\r\n\r\n.PHONY: all check clean libs $(DIST)/$(PROJ).pc\r\n\r\nall: $(EXAMPLESEXE) check libs $(DIST)/$(PROJ).pc\r\n\r\n$(DIST)/.dirstamp:\n\t$(MKDIR) $(DIST)\r\n\t$(MKDIR) $(DIST)/examples\r\n\ttouch $@\n\r\ncheck: $(DIST)/.dirstamp $(DIST)/test-file $(DIST)/test-static $(DIST)/test-dynamic\n\t./$(DIST)/test-file\r\n\t./$(DIST)/test-static\r\n\tLD_LIBRARY_PATH=$(DIST) ./$(DIST)/test-dynamic\r\n\r\n$(DIST)/test-file: $(TESTS) $(PROJ).c $(PROJ).h tests/ptest.h\r\n\t$(CC) $(filter-out -Werror, $(CFLAGS)) $(TESTS) $(PROJ).c -lm -o $(DIST)/test-file\r\n\r\n$(DIST)/test-dynamic: $(TESTS) $(DIST)/lib$(PROJ).so $(PROJ).h tests/ptest.h\r\n\t$(CC) $(filter-out -Werror, $(CFLAGS)) $(TESTS) -lm -L$(DIST) -l$(PROJ) -o $(DIST)/test-dynamic\r\n\r\n$(DIST)/test-static: $(TESTS) $(DIST)/lib$(PROJ).a $(PROJ).h tests/ptest.h\r\n\t$(CC) $(filter-out -Werror, $(CFLAGS)) $(TESTS) -lm -L$(DIST) -l$(PROJ) -static -o $(DIST)/test-static\r\n\r\nexamples/%: $(DIST)/.dirstamp examples/%.c $(PROJ).c $(PROJ).h\n\t$(CC) $(CFLAGS) $(filter-out $(DIST)/.dirstamp $(PROJ).h, $^) -lm -o $(DIST)/$@\n\r\n$(DIST)/lib$(PROJ).so: $(DIST)/.dirstamp $(PROJ).c $(PROJ).h\nifneq ($(OS),Windows_NT)\r\n\t$(CC) $(CFLAGS) -fPIC -shared $(PROJ).c -o $(DIST)/lib$(PROJ).so\r\nelse\r\n\t$(CC) $(CFLAGS) -shared $(PROJ).c -o $(DIST)/lib$(PROJ).so\r\nendif\r\n\r\n$(DIST)/lib$(PROJ).a: $(DIST)/.dirstamp $(PROJ).c $(PROJ).h\n\t$(CC) $(CFLAGS) -c $(PROJ).c -o $(DIST)/$(PROJ).o\r\n\t$(AR) rcs $(DIST)/lib$(PROJ).a $(DIST)/$(PROJ).o\r\n\r\nlibs: $(DIST)/lib$(PROJ).so $(DIST)/lib$(PROJ).a\r\n\r\n$(DIST)/$(PROJ).pc: $(DIST)/.dirstamp $(PROJ).pc\n\tcp $(PROJ).pc $(DIST)/$(PROJ).pc\r\n\tsed -i '1i\\prefix=$(PREFIX)/' $(DIST)/$(PROJ).pc\r\n\r\nclean:\r\n\trm -rf -- $(DIST)\r\n\r\ninstall: all\r\n\tinstall -d -m645 $(DESTDIR)$(PREFIX)/include\n\tinstall -d -m645 $(DESTDIR)$(PREFIX)/lib/pkgconfig\n\tinstall -d -m645 $(DESTDIR)$(PREFIX)/share/$(PROJ)\n\tinstall -m755 -t $(DESTDIR)$(PREFIX)/lib $(DIST)/lib*\r\n\tinstall -m644 -t $(DESTDIR)$(PREFIX)/share/$(PROJ) $(PROJ).c $(PROJ).h\r\n\tinstall -m644 $(PROJ).h $(DESTDIR)$(PREFIX)/include/$(PROJ).h\r\n\tinstall -m644 $(DIST)/$(PROJ).pc \\\r\n\t  $(DESTDIR)$(PREFIX)/lib/pkgconfig/$(PROJ).pc\r\n\r\nuninstall:\r\n\trm -rf -- \\\r\n\t\t$(DESTDIR)$(PREFIX)/include/$(PROJ).h \\\r\n\t\t$(DESTDIR)$(PREFIX)/share/$(PROJ)/$(PROJ).{c,h} \\\r\n\t\t$(DESTDIR)$(PREFIX)/lib/lib$(PROJ).{so,a}\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 43.39453125,
          "content": "Micro Parser Combinators\r\n========================\r\n\r\nVersion 0.9.0\r\n\r\n\r\nAbout\r\n-----\r\n\r\n_mpc_ is a lightweight and powerful Parser Combinator library for C.\r\n\r\nUsing _mpc_ might be of interest to you if you are...\r\n\r\n* Building a new programming language\r\n* Building a new data format\r\n* Parsing an existing programming language\r\n* Parsing an existing data format\r\n* Embedding a Domain Specific Language\r\n* Implementing [Greenspun's Tenth Rule](http://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)\r\n\r\n\r\nFeatures\r\n--------\r\n\r\n* Type-Generic\r\n* Predictive, Recursive Descent\r\n* Easy to Integrate (One Source File in ANSI C)\r\n* Automatic Error Message Generation\r\n* Regular Expression Parser Generator\r\n* Language/Grammar Parser Generator\r\n\r\n\r\nAlternatives\r\n------------\r\n\r\nThe current main alternative for a C based parser combinator library is a branch of [Cesium3](https://github.com/wbhart/Cesium3/tree/combinators).\r\n\r\n_mpc_ provides a number of features that this project does not offer, and also overcomes a number of potential downsides:\r\n\r\n* _mpc_ Works for Generic Types\r\n* _mpc_ Doesn't rely on Boehm-Demers-Weiser Garbage Collection\r\n* _mpc_ Doesn't use `setjmp` and `longjmp` for errors\r\n* _mpc_ Doesn't pollute the namespace\r\n\r\n\r\nQuickstart\r\n==========\r\n\r\nHere is how one would use _mpc_ to create a parser for a basic mathematical expression language.\r\n\r\n```c\r\nmpc_parser_t *Expr  = mpc_new(\"expression\");\r\nmpc_parser_t *Prod  = mpc_new(\"product\");\r\nmpc_parser_t *Value = mpc_new(\"value\");\r\nmpc_parser_t *Maths = mpc_new(\"maths\");\r\n\r\nmpca_lang(MPCA_LANG_DEFAULT,\r\n  \" expression : <product> (('+' | '-') <product>)*; \"\r\n  \" product    : <value>   (('*' | '/')   <value>)*; \"\r\n  \" value      : /[0-9]+/ | '(' <expression> ')';    \"\r\n  \" maths      : /^/ <expression> /$/;               \",\r\n  Expr, Prod, Value, Maths, NULL);\r\n\r\nmpc_result_t r;\r\n\r\nif (mpc_parse(\"input\", input, Maths, &r)) {\r\n  mpc_ast_print(r.output);\r\n  mpc_ast_delete(r.output);\r\n} else {\r\n  mpc_err_print(r.error);\r\n  mpc_err_delete(r.error);\r\n}\r\n\r\nmpc_cleanup(4, Expr, Prod, Value, Maths);\r\n```\r\n\r\nIf you were to set `input` to the string `(4 * 2 * 11 + 2) - 5`, the printed output would look like this.\r\n\r\n```\r\n>\r\n  regex\r\n  expression|>\r\n    value|>\r\n      char:1:1 '('\r\n      expression|>\r\n        product|>\r\n          value|regex:1:2 '4'\r\n          char:1:4 '*'\r\n          value|regex:1:6 '2'\r\n          char:1:8 '*'\r\n          value|regex:1:10 '11'\r\n        char:1:13 '+'\r\n        product|value|regex:1:15 '2'\r\n      char:1:16 ')'\r\n    char:1:18 '-'\r\n    product|value|regex:1:20 '5'\r\n  regex\r\n```\r\n\r\nGetting Started\r\n===============\r\n\r\nIntroduction\r\n------------\r\n\r\nParser Combinators are structures that encode how to parse particular languages. They can be combined using intuitive operators to create new parsers of increasing complexity. Using these operators detailed grammars and languages can be parsed and processed in a quick, efficient, and easy way.\r\n\r\nThe trick behind Parser Combinators is the observation that by structuring the library in a particular way, one can make building parser combinators look like writing a grammar itself. Therefore instead of describing _how to parse a language_, a user must only specify _the language itself_, and the library will work out how to parse it ... as if by magic!\r\n\r\n_mpc_ can be used in this mode, or, as shown in the above example, you can specify the grammar directly as a string or in a file.\r\n\r\nBasic Parsers\r\n-------------\r\n\r\n### String Parsers\r\n\r\nAll the following functions construct new basic parsers of the type `mpc_parser_t *`. All of those parsers return a newly allocated `char *` with the character(s) they manage to match. If unsuccessful they will return an error. They have the following functionality.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_any(void);\r\n```\r\n\r\nMatches any individual character\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_char(char c);\r\n```\r\n\r\nMatches a single given character `c`\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_range(char s, char e);\r\n```\r\n\r\nMatches any single given character in the range `s` to `e` (inclusive)\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_oneof(const char *s);\r\n```\r\n\r\nMatches any single given character in the string  `s`\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_noneof(const char *s);\r\n```\r\n\r\nMatches any single given character not in the string `s`\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_satisfy(int(*f)(char));\r\n```\r\n\r\nMatches any single given character satisfying function `f`\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_string(const char *s);\r\n```\r\n\r\nMatches exactly the string `s`\r\n\r\n\r\n### Other Parsers\r\n\r\nSeveral other functions exist that construct parsers with some other special functionality.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_pass(void);\r\n```\r\n\r\nConsumes no input, always successful, returns `NULL`\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_fail(const char *m);\r\nmpc_parser_t *mpc_failf(const char *fmt, ...);\r\n```\r\n\r\nConsumes no input, always fails with message `m` or formatted string `fmt`.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_lift(mpc_ctor_t f);\r\n```\r\n\r\nConsumes no input, always successful, returns the result of function `f`\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_lift_val(mpc_val_t *x);\r\n```\r\n\r\nConsumes no input, always successful, returns `x`\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_state(void);\r\n```\r\n\r\nConsumes no input, always successful, returns a copy of the parser state as a `mpc_state_t *`. This state is newly allocated and so needs to be released with `free` when finished with.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_anchor(int(*f)(char,char));\r\n```\r\n\r\nConsumes no input. Successful when function `f` returns true. Always returns `NULL`.\r\n\r\nFunction `f` is a _anchor_ function. It takes as input the last character parsed, and the next character in the input, and returns success or failure. This function can be set by the user to ensure some condition is met. For example to test that the input is at a boundary between words and non-words.\r\n\r\nAt the start of the input the first argument is set to `'\\0'`. At the end of the input the second argument is set to `'\\0'`.\r\n\r\n\r\n\r\nParsing\r\n-------\r\n\r\nOnce you've build a parser, you can run it on some input using one of the following functions. These functions return `1` on success and `0` on failure. They output either the result, or an error to a `mpc_result_t` variable. This type is defined as follows.\r\n\r\n```c\r\ntypedef union {\r\n  mpc_err_t *error;\r\n  mpc_val_t *output;\r\n} mpc_result_t;\r\n```\r\n\r\nwhere `mpc_val_t *` is synonymous with `void *` and simply represents some pointer to data - the exact type of which is dependant on the parser.\r\n\r\n\r\n* * *\r\n\r\n```c\r\nint mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r);\r\n```\r\n\r\nRun a parser on some string.\r\n\r\n* * *\r\n\r\n```c\r\nint mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r);\r\n```\r\n\r\nRun a parser on some file.\r\n\r\n* * *\r\n\r\n```c\r\nint mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r);\r\n```\r\n\r\nRun a parser on some pipe (such as `stdin`).\r\n\r\n* * *\r\n\r\n```c\r\nint mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r);\r\n```\r\n\r\nRun a parser on the contents of some file.\r\n\r\n\r\nCombinators\r\n-----------\r\n\r\nCombinators are functions that take one or more parsers and return a new parser of some given functionality.\r\n\r\nThese combinators work independently of exactly what data type the parser(s) supplied as input return. In languages such as Haskell ensuring you don't input one type of data into a parser requiring a different type is done by the compiler. But in C we don't have that luxury. So it is at the discretion of the programmer to ensure that he or she deals correctly with the outputs of different parser types.\r\n\r\nA second annoyance in C is that of manual memory management. Some parsers might get half-way and then fail. This means they need to clean up any partial result that has been collected in the parse. In Haskell this is handled by the Garbage Collector, but in C these combinators will need to take _destructor_ functions as input, which say how clean up any partial data that has been collected.\r\n\r\nHere are the main combinators and how to use then.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_expect(mpc_parser_t *a, const char *e);\r\nmpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...);\r\n```\r\n\r\nReturns a parser that runs `a`, and on success returns the result of `a`, while on failure reports that `e` was expected.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f);\r\nmpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x);\r\n```\r\n\r\nReturns a parser that applies function `f` (optionality taking extra input `x`) to the result of parser `a`.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_check(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *e);\r\nmpc_parser_t *mpc_check_with(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *e);\r\nmpc_parser_t *mpc_checkf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *fmt, ...);\r\nmpc_parser_t *mpc_check_withf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *fmt, ...);\r\n```\r\n\r\nReturns a parser that applies function `f` (optionally taking extra input `x`) to the result of parser `a`. If `f` returns non-zero, then the parser succeeds and returns the value of `a` (possibly modified by `f`). If `f` returns zero, then the parser fails with message `e`, and the result of `a` is destroyed with the destructor `da`.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da);\r\nmpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf);\r\n```\r\n\r\nReturns a parser with the following behaviour. If parser `a` succeeds, then it fails and consumes no input. If parser `a` fails, then it succeeds, consumes no input and returns `NULL` (or the result of lift function `lf`). Destructor `da` is used to destroy the result of `a` on success.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_maybe(mpc_parser_t *a);\r\nmpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf);\r\n```\r\n\r\nReturns a parser that runs `a`. If `a` is successful then it returns the result of `a`. If `a` is unsuccessful then it succeeds, but returns `NULL` (or the result of `lf`).\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a);\r\n```\r\n\r\nRuns `a` zero or more times until it fails. Results are combined using fold function `f`. See the _Function Types_ section for more details.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a);\r\n```\r\n\r\nRuns `a` one or more times until it fails. Results are combined with fold function `f`.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_sepby1(mpc_fold_t f, mpc_parser_t *sep, mpc_parser_t *a);\r\n```\r\n\r\nRuns `a` one or more times, separated by `sep`. Results are combined with fold function `f`.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da);\r\n```\r\n\r\nRuns `a` exactly `n` times. If this fails, any partial results are destructed with `da`. If successful results of `a` are combined using fold function `f`.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_or(int n, ...);\r\n```\r\n\r\nAttempts to run `n` parsers in sequence, returning the first one that succeeds. If all fail, returns an error.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_and(int n, mpc_fold_t f, ...);\r\n```\r\n\r\nAttempts to run `n` parsers in sequence, returning the fold of the results using fold function `f`. First parsers must be specified, followed by destructors for each parser, excluding the final parser. These are used in case of partial success. For example: `mpc_and(3, mpcf_strfold, mpc_char('a'), mpc_char('b'), mpc_char('c'), free, free);` would attempt to match `'a'` followed by `'b'` followed by `'c'`, and if successful would concatenate them using `mpcf_strfold`. Otherwise would use `free` on the partial results.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_predictive(mpc_parser_t *a);\r\n```\r\n\r\nReturns a parser that runs `a` with backtracking disabled. This means if `a` consumes more than one character, it will not be reverted, even on failure. Turning backtracking off has good performance benefits for grammars which are `LL(1)`. These are grammars where the first character completely determines the parse result - such as the decision of parsing either a C identifier, number, or string literal. This option should not be used for non `LL(1)` grammars or it will produce incorrect results or crash the parser.\r\n\r\nAnother way to think of `mpc_predictive` is that it can be applied to a parser (for a performance improvement) if either successfully parsing the first character will result in a completely successful parse, or all of the referenced sub-parsers are also `LL(1)`.\r\n\r\n\r\nFunction Types\r\n--------------\r\n\r\nThe combinator functions take a number of special function types as function pointers. Here is a short explanation of those types are how they are expected to behave. It is important that these behave correctly otherwise it is easy to introduce memory leaks or crashes into the system.\r\n\r\n* * *\r\n\r\n```c\r\ntypedef void(*mpc_dtor_t)(mpc_val_t*);\r\n```\r\n\r\nGiven some pointer to a data value it will ensure the memory it points to is freed correctly.\r\n\r\n* * *\r\n\r\n```c\r\ntypedef mpc_val_t*(*mpc_ctor_t)(void);\r\n```\r\n\r\nReturns some data value when called. It can be used to create _empty_ versions of data types when certain combinators have no known default value to return. For example it may be used to return a newly allocated empty string.\r\n\r\n* * *\r\n\r\n```c\r\ntypedef mpc_val_t*(*mpc_apply_t)(mpc_val_t*);\r\ntypedef mpc_val_t*(*mpc_apply_to_t)(mpc_val_t*,void*);\r\n```\r\n\r\nThis takes in some pointer to data and outputs some new or modified pointer to data, ensuring to free the input data if it is no longer used. The `apply_to` variation takes in an extra pointer to some data such as global state.\r\n\r\n* * *\r\n\r\n```c\r\ntypedef int(*mpc_check_t)(mpc_val_t**);\r\ntypedef int(*mpc_check_with_t)(mpc_val_t**,void*);\r\n```\r\n\r\nThis takes in some pointer to data and outputs 0 if parsing should stop with an error. Additionally, this may change or free the input data. The `check_with` variation takes in an extra pointer to some data such as global state.\r\n\r\n* * *\r\n\r\n```c\r\ntypedef mpc_val_t*(*mpc_fold_t)(int,mpc_val_t**);\r\n```\r\n\r\nThis takes a list of pointers to data values and must return some combined or folded version of these data values. It must ensure to free any input data that is no longer used once the combination has taken place.\r\n\r\n\r\nCase Study - Identifier\r\n=======================\r\n\r\nCombinator Method\r\n-----------------\r\n\r\nUsing the above combinators we can create a parser that matches a C identifier.\r\n\r\nWhen using the combinators we need to supply a function that says how to combine two `char *`.\r\n\r\nFor this we build a fold function that will concatenate zero or more strings together. For this sake of this tutorial we will write it by hand, but this (as well as many other useful fold functions), are actually included in _mpc_ under the `mpcf_*` namespace, such as `mpcf_strfold`.\r\n\r\n```c\r\nmpc_val_t *strfold(int n, mpc_val_t **xs) {\r\n  char *x = calloc(1, 1);\r\n  int i;\r\n  for (i = 0; i < n; i++) {\r\n    x = realloc(x, strlen(x) + strlen(xs[i]) + 1);\r\n    strcat(x, xs[i]);\r\n    free(xs[i]);\r\n  }\r\n  return x;\r\n}\r\n```\r\n\r\nWe can use this to specify a C identifier, making use of some combinators to say how the basic parsers are combined.\r\n\r\n```c\r\nmpc_parser_t *alpha = mpc_or(2, mpc_range('a', 'z'), mpc_range('A', 'Z'));\r\nmpc_parser_t *digit = mpc_range('0', '9');\r\nmpc_parser_t *underscore = mpc_char('_');\r\n\r\nmpc_parser_t *ident = mpc_and(2, strfold,\r\n  mpc_or(2, alpha, underscore),\r\n  mpc_many(strfold, mpc_or(3, alpha, digit, underscore)),\r\n  free);\r\n\r\n/* Do Some Parsing... */\r\n\r\nmpc_delete(ident);\r\n```\r\n\r\nNotice that previous parsers are used as input to new parsers we construct from the combinators. Note that only the final parser `ident` must be deleted. When we input a parser into a combinator we should consider it to be part of the output of that combinator.\r\n\r\nBecause of this we shouldn't create a parser and input it into multiple places, or it will be doubly freed.\r\n\r\n\r\nRegex Method\r\n------------\r\n\r\nThere is an easier way to do this than the above method. _mpc_ comes with a handy regex function for constructing parsers using regex syntax. We can specify an identifier using a regex pattern as shown below.\r\n\r\n```c\r\nmpc_parser_t *ident = mpc_re(\"[a-zA-Z_][a-zA-Z_0-9]*\");\r\n\r\n/* Do Some Parsing... */\r\n\r\nmpc_delete(ident);\r\n```\r\n\r\n\r\nLibrary Method\r\n--------------\r\n\r\nAlthough if we really wanted to create a parser for C identifiers, a function for creating this parser comes included in _mpc_ along with many other common parsers.\r\n\r\n```c\r\nmpc_parser_t *ident = mpc_ident();\r\n\r\n/* Do Some Parsing... */\r\n\r\nmpc_delete(ident);\r\n```\r\n\r\nParser References\r\n=================\r\n\r\nBuilding parsers in the above way can have issues with self-reference or cyclic-reference. To overcome this we can separate the construction of parsers into two different steps. Construction and Definition.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_new(const char *name);\r\n```\r\n\r\nThis will construct a parser called `name` which can then be used as input to others, including itself, without fear of being deleted. Any parser created using `mpc_new` is said to be _retained_. This means it will behave differently to a normal parser when referenced. When deleting a parser that includes a _retained_ parser, the _retained_ parser will not be deleted along with it. To delete a retained parser `mpc_delete` must be used on it directly.\r\n\r\nA _retained_ parser can then be _defined_ using...\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a);\r\n```\r\n\r\nThis assigns the contents of parser `a` to `p`, and deletes `a`. With this technique parsers can now reference each other, as well as themselves, without trouble.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_undefine(mpc_parser_t *p);\r\n```\r\n\r\nA final step is required. Parsers that reference each other must all be undefined before they are deleted. It is important to do any undefining before deletion. The reason for this is that to delete a parser it must look at each sub-parser that is used by it. If any of these have already been deleted a segfault is unavoidable - even if they were retained beforehand.\r\n\r\n* * *\r\n\r\n```c\r\nvoid mpc_cleanup(int n, ...);\r\n```\r\n\r\nTo ease the task of undefining and then deleting parsers `mpc_cleanup` can be used. It takes `n` parsers as input, and undefines them all, before deleting them all.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_copy(mpc_parser_t *a);\r\n```\r\n\r\nThis function makes a copy of a parser `a`. This can be useful when you want to\r\nuse a parser as input for some other parsers multiple times without retaining\r\nit.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpc_re(const char *re);\r\nmpc_parser_t *mpc_re_mode(const char *re, int mode);\r\n```\r\n\r\nThis function takes as input the regular expression `re` and builds a parser\r\nfor it. With the `mpc_re_mode` function optional mode flags can also be given.\r\nAvailable flags are `MPC_RE_MULTILINE` / `MPC_RE_M` where the start of input\r\ncharacter `^` also matches the beginning of new lines and the end of input `$`\r\ncharacter also matches new lines, and `MPC_RE_DOTALL` / `MPC_RE_S` where the\r\nany character token `.` also matches newlines (by default it doesn't).\r\n\r\n\r\nLibrary Reference\r\n=================\r\n\r\nCommon Parsers\r\n--------------\r\n\r\n\r\n<table>\r\n\r\n  <tr><td><code>mpc_soi</code></td><td>Matches only the start of input, returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_eoi</code></td><td>Matches only the end of input, returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_boundary</code></td><td>Matches only the boundary between words, returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_boundary_newline</code></td><td>Matches the start of a new line, returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_whitespace</code></td><td>Matches any whitespace character <code>\" \\f\\n\\r\\t\\v\"</code></td></tr>\r\n  <tr><td><code>mpc_whitespaces</code></td><td>Matches zero or more whitespace characters</td></tr>\r\n  <tr><td><code>mpc_blank</code></td><td>Matches whitespaces and frees the result, returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_newline</code></td><td>Matches <code>'\\n'</code></td></tr>\r\n  <tr><td><code>mpc_tab</code></td><td>Matches <code>'\\t'</code></td></tr>\r\n  <tr><td><code>mpc_escape</code></td><td>Matches a backslash followed by any character</td></tr>\r\n  <tr><td><code>mpc_digit</code></td><td>Matches any character in the range <code>'0'</code> - <code>'9'</code></td></tr>\r\n  <tr><td><code>mpc_hexdigit</code></td><td>Matches any character in the range <code>'0</code> - <code>'9'</code> as well as <code>'A'</code> - <code>'F'</code> and <code>'a'</code> - <code>'f'</code></td></tr>\r\n  <tr><td><code>mpc_octdigit</code></td><td>Matches any character in the range <code>'0'</code> - <code>'7'</code></td></tr>\r\n  <tr><td><code>mpc_digits</code></td><td>Matches one or more digit</td></tr>\r\n  <tr><td><code>mpc_hexdigits</code></td><td>Matches one or more hexdigit</td></tr>\r\n  <tr><td><code>mpc_octdigits</code></td><td>Matches one or more octdigit</td></tr>\r\n  <tr><td><code>mpc_lower</code></td><td>Matches any lower case character</td></tr>\r\n  <tr><td><code>mpc_upper</code></td><td>Matches any upper case character</td></tr>\r\n  <tr><td><code>mpc_alpha</code></td><td>Matches any alphabet character</td></tr>\r\n  <tr><td><code>mpc_underscore</code></td><td>Matches <code>'_'</code></td></tr>\r\n  <tr><td><code>mpc_alphanum</code></td><td>Matches any alphabet character, underscore or digit</td></tr>\r\n  <tr><td><code>mpc_int</code></td><td>Matches digits and returns an <code>int*</code></td></tr>\r\n  <tr><td><code>mpc_hex</code></td><td>Matches hexdigits and returns an <code>int*</code></td></tr>\r\n  <tr><td><code>mpc_oct</code></td><td>Matches octdigits and returns an <code>int*</code></td></tr>\r\n  <tr><td><code>mpc_number</code></td><td>Matches <code>mpc_int</code>, <code>mpc_hex</code> or <code>mpc_oct</code></td></tr>\r\n  <tr><td><code>mpc_real</code></td><td>Matches some floating point number as a string</td></tr>\r\n  <tr><td><code>mpc_float</code></td><td>Matches some floating point number and returns a <code>float*</code></td></tr>\r\n  <tr><td><code>mpc_char_lit</code></td><td>Matches some character literal surrounded by <code>'</code></td></tr>\r\n  <tr><td><code>mpc_string_lit</code></td><td>Matches some string literal surrounded by <code>\"</code></td></tr>\r\n  <tr><td><code>mpc_regex_lit</code></td><td>Matches some regex literal surrounded by <code>/</code></td></tr>\r\n  <tr><td><code>mpc_ident</code></td><td>Matches a C style identifier</td></tr>\r\n\r\n</table>\r\n\r\n\r\nUseful Parsers\r\n--------------\r\n\r\n<table>\r\n\r\n  <tr><td><code>mpc_startswith(mpc_parser_t *a);</code></td><td>Matches the start of input followed by <code>a</code></td></tr>\r\n  <tr><td><code>mpc_endswith(mpc_parser_t *a, mpc_dtor_t da);</code></td><td>Matches <code>a</code> followed by the end of input</td></tr>\r\n  <tr><td><code>mpc_whole(mpc_parser_t *a, mpc_dtor_t da);</code></td><td>Matches the start of input, <code>a</code>, and the end of input</td></tr>\r\n  <tr><td><code>mpc_stripl(mpc_parser_t *a);</code></td><td>Matches <code>a</code> first consuming any whitespace to the left</td></tr>\r\n  <tr><td><code>mpc_stripr(mpc_parser_t *a);</code></td><td>Matches <code>a</code> then consumes any whitespace to the right</td></tr>\r\n  <tr><td><code>mpc_strip(mpc_parser_t *a);</code></td><td>Matches <code>a</code> consuming any surrounding whitespace</td></tr>\r\n  <tr><td><code>mpc_tok(mpc_parser_t *a);</code></td><td>Matches <code>a</code> and consumes any trailing whitespace</td></tr>\r\n  <tr><td><code>mpc_sym(const char *s);</code></td><td>Matches string <code>s</code> and consumes any trailing whitespace</td></tr>\r\n  <tr><td><code>mpc_total(mpc_parser_t *a, mpc_dtor_t da);</code></td><td>Matches the whitespace consumed <code>a</code>, enclosed in the start and end of input</td></tr>\r\n  <tr><td><code>mpc_between(mpc_parser_t *a, mpc_dtor_t ad, <br /> const char *o, const char *c);</code></td><td> Matches <code>a</code> between strings <code>o</code> and <code>c</code></td></tr>\r\n  <tr><td><code>mpc_parens(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>\"(\"</code> and <code>\")\"</code></td></tr>\r\n  <tr><td><code>mpc_braces(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>\"<\"</code> and <code>\">\"</code></td></tr>\r\n  <tr><td><code>mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>\"{\"</code> and <code>\"}\"</code></td></tr>\r\n  <tr><td><code>mpc_squares(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>\"[\"</code> and <code>\"]\"</code></td></tr>\r\n  <tr><td><code>mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, <br /> const char *o, const char *c);</code></td><td>Matches <code>a</code> between <code>o</code> and <code>c</code>, where <code>o</code> and <code>c</code> have their trailing whitespace striped.</td></tr>\r\n  <tr><td><code>mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>\"(\"</code> and <code>\")\"</code></td></tr>\r\n  <tr><td><code>mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>\"<\"</code> and <code>\">\"</code></td></tr>\r\n  <tr><td><code>mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>\"{\"</code> and <code>\"}\"</code></td></tr>\r\n  <tr><td><code>mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>\"[\"</code> and <code>\"]\"</code></td></tr>\r\n\r\n</table>\r\n\r\n\r\nApply Functions\r\n---------------\r\n\r\n<table>\r\n\r\n  <tr><td><code>void mpcf_dtor_null(mpc_val_t *x);</code></td><td>Empty destructor. Does nothing</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_ctor_null(void);</code></td><td>Returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_ctor_str(void);</code></td><td>Returns <code>\"\"</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_free(mpc_val_t *x);</code></td><td>Frees <code>x</code> and returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_int(mpc_val_t *x);</code></td><td>Converts a decimal string <code>x</code> to an <code>int*</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_hex(mpc_val_t *x);</code></td><td>Converts a hex string <code>x</code> to an <code>int*</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_oct(mpc_val_t *x);</code></td><td>Converts a oct string <code>x</code> to an <code>int*</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_float(mpc_val_t *x);</code></td><td>Converts a string <code>x</code> to a <code>float*</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_escape(mpc_val_t *x);</code></td><td>Converts a string <code>x</code> to an escaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_escape_regex(mpc_val_t *x);</code></td><td>Converts a regex <code>x</code> to an escaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_escape_string_raw(mpc_val_t *x);</code></td><td>Converts a raw string <code>x</code> to an escaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_escape_char_raw(mpc_val_t *x);</code></td><td>Converts a raw character <code>x</code> to an escaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_unescape(mpc_val_t *x);</code></td><td>Converts a string <code>x</code> to an unescaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_unescape_regex(mpc_val_t *x);</code></td><td>Converts a regex <code>x</code> to an unescaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x);</code></td><td>Converts a raw string <code>x</code> to an unescaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x);</code></td><td>Converts a raw character <code>x</code> to an unescaped version</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_strtriml(mpc_val_t *x);</code></td><td>Trims whitespace from the left of string <code>x</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_strtrimr(mpc_val_t *x);</code></td><td>Trims whitespace from the right of string <code>x</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_strtrim(mpc_val_t *x);</code></td><td>Trims whitespace from either side of string <code>x</code></td></tr>\r\n</table>\r\n\r\n\r\nFold Functions\r\n--------------\r\n\r\n<table>\r\n\r\n\r\n  <tr><td><code>mpc_val_t *mpcf_null(int n, mpc_val_t** xs);</code></td><td>Returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_fst(int n, mpc_val_t** xs);</code></td><td>Returns first element of <code>xs</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_snd(int n, mpc_val_t** xs);</code></td><td>Returns second element of <code>xs</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_trd(int n, mpc_val_t** xs);</code></td><td>Returns third element of <code>xs</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_fst_free(int n, mpc_val_t** xs);</code></td><td>Returns first element of <code>xs</code> and calls <code>free</code> on others</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_snd_free(int n, mpc_val_t** xs);</code></td><td>Returns second element of <code>xs</code> and calls <code>free</code> on others</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_trd_free(int n, mpc_val_t** xs);</code></td><td>Returns third element of <code>xs</code> and calls <code>free</code> on others</td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_all_free(int n, mpc_val_t** xs);</code></td><td>Calls <code>free</code> on all elements of <code>xs</code> and returns <code>NULL</code></td></tr>\r\n  <tr><td><code>mpc_val_t *mpcf_strfold(int n, mpc_val_t** xs);</code></td><td>Concatenates all <code>xs</code> together as strings and returns result </td></tr>\r\n\r\n</table>\r\n\r\n\r\nCase Study - Maths Language\r\n===========================\r\n\r\nCombinator Approach\r\n-------------------\r\n\r\nPassing around all these function pointers might seem clumsy, but having parsers be type-generic is important as it lets users define their own output types for parsers. For example we could design our own syntax tree type to use. We can also use this method to do some specific house-keeping or data processing in the parsing phase.\r\n\r\nAs an example of this power, we can specify a simple maths grammar, that outputs `int *`, and computes the result of the expression as it goes along.\r\n\r\nWe start with a fold function that will fold two `int *` into a new `int *` based on some `char *` operator.\r\n\r\n```c\r\nmpc_val_t *fold_maths(int n, mpc_val_t **xs) {\r\n\r\n  int **vs = (int**)xs;\r\n\r\n  if (strcmp(xs[1], \"*\") == 0) { *vs[0] *= *vs[2]; }\r\n  if (strcmp(xs[1], \"/\") == 0) { *vs[0] /= *vs[2]; }\r\n  if (strcmp(xs[1], \"%\") == 0) { *vs[0] %= *vs[2]; }\r\n  if (strcmp(xs[1], \"+\") == 0) { *vs[0] += *vs[2]; }\r\n  if (strcmp(xs[1], \"-\") == 0) { *vs[0] -= *vs[2]; }\r\n\r\n  free(xs[1]); free(xs[2]);\r\n\r\n  return xs[0];\r\n}\r\n```\r\n\r\nAnd then we use this to specify a basic grammar, which folds together any results.\r\n\r\n```c\r\nmpc_parser_t *Expr   = mpc_new(\"expr\");\r\nmpc_parser_t *Factor = mpc_new(\"factor\");\r\nmpc_parser_t *Term   = mpc_new(\"term\");\r\nmpc_parser_t *Maths  = mpc_new(\"maths\");\r\n\r\nmpc_define(Expr, mpc_or(2,\r\n  mpc_and(3, fold_maths,\r\n    Factor, mpc_oneof(\"+-\"), Factor,\r\n    free, free),\r\n  Factor\r\n));\r\n\r\nmpc_define(Factor, mpc_or(2,\r\n  mpc_and(3, fold_maths,\r\n    Term, mpc_oneof(\"*/\"), Term,\r\n    free, free),\r\n  Term\r\n));\r\n\r\nmpc_define(Term, mpc_or(2, mpc_int(), mpc_parens(Expr, free)));\r\nmpc_define(Maths, mpc_whole(Expr, free));\r\n\r\n/* Do Some Parsing... */\r\n\r\nmpc_delete(Maths);\r\n```\r\n\r\nIf we supply this function with something like `(4*2)+5`, we can expect it to output `13`.\r\n\r\n\r\nLanguage Approach\r\n-----------------\r\n\r\nIt is possible to avoid passing in and around all those function pointers, if you don't care what type is output by _mpc_. For this, a generic Abstract Syntax Tree type `mpc_ast_t` is included in _mpc_. The combinator functions which act on this don't need information on how to destruct or fold instances of the result as they know it will be a `mpc_ast_t`. So there are a number of combinator functions which work specifically (and only) on parsers that return this type. They reside under `mpca_*`.\r\n\r\nDoing things via this method means that all the data processing must take place after the parsing. In many instances this is not an issue, or even preferable.\r\n\r\nIt also allows for one more trick. As all the fold and destructor functions are implicit, the user can simply specify the grammar of the language in some nice way and the system can try to build a parser for the AST type from this alone. For this there are a few functions supplied which take in a string, and output a parser. The format for these grammars is simple and familiar to those who have used parser generators before. It looks something like this.\r\n\r\n```\r\nnumber \"number\" : /[0-9]+/ ;\r\nexpression      : <product> (('+' | '-') <product>)* ;\r\nproduct         : <value>   (('*' | '/')   <value>)* ;\r\nvalue           : <number> | '(' <expression> ')' ;\r\nmaths           : /^/ <expression> /$/ ;\r\n```\r\n\r\nThe syntax for this is defined as follows.\r\n\r\n<table class='table'>\r\n  <tr><td><code>\"ab\"</code></td><td>The string <code>ab</code> is required.</td></tr>\r\n  <tr><td><code>'a'</code></td><td>The character <code>a</code> is required.</td></tr>\r\n  <tr><td><code>'a' 'b'</code></td><td>First <code>'a'</code> is required, then <code>'b'</code> is required..</td></tr>\r\n  <tr><td><code>'a' | 'b'</code></td><td>Either <code>'a'</code> is required, or <code>'b'</code> is required.</td></tr>\r\n  <tr><td><code>'a'*</code></td><td>Zero or more <code>'a'</code> are required.</td></tr>\r\n  <tr><td><code>'a'+</code></td><td>One or more <code>'a'</code> are required.</td></tr>\r\n  <tr><td><code>'a'?</code></td><td>Zero or one <code>'a'</code> is required.</td></tr>\r\n  <tr><td><code>'a'{x}</code></td><td>Exactly <code>x</code> (integer) copies of <code>'a'</code> are required.</td></tr>\r\n  <tr><td><code>&lt;abba&gt;</code></td><td>The rule called <code>abba</code> is required.</td></tr>\r\n</table>\r\n\r\nRules are specified by rule name, optionally followed by an _expected_ string, followed by a colon `:`, followed by the definition, and ending in a semicolon `;`. Multiple rules can be specified. The _rule names_ must match the names given to any parsers created by `mpc_new`, otherwise the function will crash.\r\n\r\nThe flags variable is a set of flags `MPCA_LANG_DEFAULT`, `MPCA_LANG_PREDICTIVE`, or `MPCA_LANG_WHITESPACE_SENSITIVE`. For specifying if the language is predictive or whitespace sensitive.\r\n\r\nLike with the regular expressions, this user input is parsed by existing parts of the _mpc_ library. It provides one of the more powerful features of the library.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_parser_t *mpca_grammar(int flags, const char *grammar, ...);\r\n```\r\n\r\nThis takes in some single right hand side of a rule, as well as a list of any of the parsers referenced, and outputs a parser that does what is specified by the rule. The list of parsers referenced can be terminated with `NULL` to get an error instead of a crash when a parser required is not supplied.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_err_t *mpca_lang(int flags, const char *lang, ...);\r\n```\r\n\r\nThis takes in a full language (zero or more rules) as well as any parsers referred to by either the right or left hand sides. Any parsers specified on the left hand side of any rule will be assigned a parser equivalent to what is specified on the right. On valid user input this returns `NULL`, while if there are any errors in the user input it will return an instance of `mpc_err_t` describing the issues. The list of parsers referenced can be terminated with `NULL` to get an error instead of a crash when a parser required is not supplied.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_err_t *mpca_lang_file(int flags, FILE* f, ...);\r\n```\r\n\r\nThis reads in the contents of file `f` and inputs it into `mpca_lang`.\r\n\r\n* * *\r\n\r\n```c\r\nmpc_err_t *mpca_lang_contents(int flags, const char *filename, ...);\r\n```\r\n\r\nThis opens and reads in the contents of the file given by `filename` and passes it to `mpca_lang`.\r\n\r\nCase Study - Tokenizer\r\n======================\r\n\r\nAnother common task we might be interested in doing is tokenizing some block of\r\ntext (splitting the text into individual elements) and performing some function\r\non each one of these elements as it is read. We can do this with `mpc` too.\r\n\r\nFirst, we can build a regular expression which parses an individual token. For\r\nexample if our tokens are identifiers, integers, commas, periods and colons we\r\ncould build something like this `mpc_re(\"\\\\s*([a-zA-Z_]+|[0-9]+|,|\\\\.|:)\")`.\r\nNext we can strip any whitespace, and add a callback function using `mpc_apply`\r\nwhich gets called every time this regex is parsed successfully\r\n`mpc_apply(mpc_strip(mpc_re(\"\\\\s*([a-zA-Z_]+|[0-9]+|,|\\\\.|:)\")), print_token)`.\r\nFinally we can surround all of this in `mpc_many` to parse it zero or more\r\ntimes. The final code might look something like this:\r\n\r\n```c\r\nstatic mpc_val_t *print_token(mpc_val_t *x) {\r\n  printf(\"Token: '%s'\\n\", (char*)x);\r\n  return x;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n\r\n  const char *input = \"  hello 4352 ,  \\n foo.bar   \\n\\n  test:ing   \";\r\n\r\n  mpc_parser_t* Tokens = mpc_many(\r\n    mpcf_all_free,\r\n    mpc_apply(mpc_strip(mpc_re(\"\\\\s*([a-zA-Z_]+|[0-9]+|,|\\\\.|:)\")), print_token));\r\n\r\n  mpc_result_t r;\r\n  mpc_parse(\"input\", input, Tokens, &r);\r\n\r\n  mpc_delete(Tokens);\r\n\r\n  return 0;\r\n}\r\n```\r\n\r\nRunning this program will produce an output something like this:\r\n\r\n```\r\nToken: 'hello'\r\nToken: '4352'\r\nToken: ','\r\nToken: 'foo'\r\nToken: '.'\r\nToken: 'bar'\r\nToken: 'test'\r\nToken: ':'\r\nToken: 'ing'\r\n```\r\n\r\nBy extending the regex we can easily extend this to parse many more types of\r\ntokens and quickly and easily build a tokenizer for whatever language we are\r\ninterested in.\r\n\r\n\r\nError Reporting\r\n===============\r\n\r\n_mpc_ provides some automatic generation of error messages. These can be enhanced by the user, with use of `mpc_expect`, but many of the defaults should provide both useful and readable. An example of an error message might look something like this:\r\n\r\n```\r\n<test>:0:3: error: expected one or more of 'a' or 'd' at 'k'\r\n```\r\n\r\nMisc\r\n====\r\n\r\nHere are some other misc functions that mpc provides. These functions are susceptible to change between versions so use them with some care.\r\n\r\n* * *\r\n\r\n```c\r\nvoid mpc_print(mpc_parser_t *p);\r\n```\r\n\r\nPrints out a parser in some weird format. This is generally used for debugging so don't expect to be able to understand the output right away without looking at the source code a little bit.\r\n\r\n* * *\r\n\r\n```c\r\nvoid mpc_stats(mpc_parser_t *p);\r\n```\r\n\r\nPrints out some basic stats about a parser. Again used for debugging and optimisation.\r\n\r\n* * *\r\n\r\n```c\r\nvoid mpc_optimise(mpc_parser_t *p);\r\n```\r\n\r\nPerforms some basic optimisations on a parser to reduce it's size and increase its running speed.\r\n\r\n\r\nLimitations & FAQ\r\n=================\r\n\r\n### I'm getting namespace issues due to `libmpc`, what can I do?\r\n\r\nThere is a re-naming of this project to `pcq` hosted on the [pcq branch](https://github.com/orangeduck/mpc/tree/pcq) which should be usable without namespace issues.\r\n\r\n### Does _mpc_ support Unicode?\r\n\r\n_mpc_ Only supports ASCII. Sorry! Writing a parser library that supports Unicode is pretty difficult. I welcome contributions!\r\n\r\n\r\n### Is _mpc_ binary safe?\r\n\r\nNo. Sorry! Including NULL characters in a string or a file will probably break it. Avoid this if possible.\r\n\r\n\r\n### The Parser is going into an infinite loop!\r\n\r\nWhile it is certainly possible there is an issue with _mpc_, it is probably the case that your grammar contains _left recursion_. This is something _mpc_ cannot deal with. _Left recursion_ is when a rule directly or indirectly references itself on the left hand side of a derivation. For example consider this left recursive grammar intended to parse an expression.\r\n\r\n```\r\nexpr : <expr> '+' (<expr> | <int> | <string>);\r\n```\r\n\r\nWhen the rule `expr` is called, it looks the first rule on the left. This happens to be the rule `expr` again. So again it looks for the first rule on the left. Which is `expr` again. And so on. To avoid left recursion this can be rewritten (for example) as the following. Note that rewriting as follows also changes the operator associativity.\r\n\r\n```\r\nvalue : <int> | <string> ;\r\nexpr  : <value> ('+' <expr>)* ;\r\n```\r\n\r\nAvoiding left recursion can be tricky, but is easy once you get a feel for it. For more information you can look on [wikipedia](http://en.wikipedia.org/wiki/Left_recursion) which covers some common techniques and more examples. Possibly in the future _mpc_ will support functionality to warn the user or re-write grammars which contain left recursion, but it wont for now.\r\n\r\n\r\n### Backtracking isn't working!\r\n\r\n_mpc_ supports backtracking, but it may not work as you expect. It isn't a silver bullet, and you still must structure your grammar to be unambiguous. To demonstrate this behaviour examine the following erroneous grammar, intended to parse either a C style identifier, or a C style function call.\r\n\r\n```\r\nfactor : <ident>\r\n       | <ident> '('  <expr>? (',' <expr>)* ')' ;\r\n```\r\n\r\nThis grammar will never correctly parse a function call because it will always first succeed parsing the initial identifier and return a factor. At this point it will encounter the parenthesis of the function call, give up, and throw an error. Even if it were to try and parse a factor again on this failure it would never reach the correct function call option because it always tries the other options first, and always succeeds with the identifier.\r\n\r\nThe solution to this is to always structure grammars with the most specific clause first, and more general clauses afterwards. This is the natural technique used for avoiding left-recursive grammars and unambiguity, so is a good habit to get into anyway.\r\n\r\nNow the parser will try to match a function first, and if this fails backtrack and try to match just an identifier.\r\n\r\n```\r\nfactor : <ident> '('  <expr>? (',' <expr>)* ')'\r\n       | <ident> ;\r\n```\r\n\r\nAn alternative, and better option is to remove the ambiguity completely by factoring out the first identifier. This is better because it removes any need for backtracking at all! Now the grammar is predictive!\r\n\r\n```\r\nfactor : <ident> ('('  <expr>? (',' <expr>)* ')')? ;\r\n```\r\n\r\n\r\n### How can I avoid the maximum string literal length?\r\n\r\nSome compilers limit the maximum length of string literals. If you have a huge language string in the source file to be passed into `mpca_lang` you might encounter this. The ANSI standard says that 509 is the maximum length allowed for a string literal. Most compilers support greater than this. Visual Studio supports up to 2048 characters, while gcc allocates memory dynamically and so has no real limit.\r\n\r\nThere are a couple of ways to overcome this issue if it arises. You could instead use `mpca_lang_contents` and load the language from file or you could use a string literal for each line and let the preprocessor automatically concatenate them together, avoiding the limit. The final option is to upgrade your compiler. In C99 this limit has been increased to 4095.\r\n\r\n\r\n### The automatic tags in the AST are annoying!\r\n\r\nWhen parsing from a grammar, the abstract syntax tree is tagged with different tags for each primitive type it encounters. For example a regular expression will be automatically tagged as `regex`. Character literals as `char` and strings as `string`. This is to help people wondering exactly how they might need to convert the node contents.\r\n\r\nIf you have a rule in your grammar called `string`, `char` or `regex`, you may encounter some confusion. This is because nodes will be tagged with (for example) `string` _either_ if they are a string primitive, _or_ if they were parsed via your `string` rule. If you are detecting node type using something like `strstr`, in this situation it might break. One solution to this is to always check that `string` is the innermost tag to test for string primitives, or to rename your rule called `string` to something that doesn't conflict.\r\n\r\nYes it is annoying but its probably not going to change!\r\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "mpc.c",
          "type": "blob",
          "size": 110.9296875,
          "content": "#include \"mpc.h\"\r\n\r\n/*\r\n** State Type\r\n*/\r\n\r\nstatic mpc_state_t mpc_state_invalid(void) {\r\n  mpc_state_t s;\r\n  s.pos = -1;\r\n  s.row = -1;\r\n  s.col = -1;\r\n  s.term = 0;\r\n  return s;\r\n}\r\n\r\nstatic mpc_state_t mpc_state_new(void) {\r\n  mpc_state_t s;\r\n  s.pos = 0;\r\n  s.row = 0;\r\n  s.col = 0;\r\n  s.term = 0;\r\n  return s;\r\n}\r\n\r\n/*\r\n** Input Type\r\n*/\r\n\r\n/*\r\n** In mpc the input type has three modes of\r\n** operation: String, File and Pipe.\r\n**\r\n** String is easy. The whole contents are\r\n** loaded into a buffer and scanned through.\r\n** The cursor can jump around at will making\r\n** backtracking easy.\r\n**\r\n** The second is a File which is also somewhat\r\n** easy. The contents are never loaded into\r\n** memory but backtracking can still be achieved\r\n** by seeking in the file at different positions.\r\n**\r\n** The final mode is Pipe. This is the difficult\r\n** one. As we assume pipes cannot be seeked - and\r\n** only support a single character lookahead at\r\n** any point, when the input is marked for a\r\n** potential backtracking we start buffering any\r\n** input.\r\n**\r\n** This means that if we are requested to seek\r\n** back we can simply start reading from the\r\n** buffer instead of the input.\r\n**\r\n** Of course using `mpc_predictive` will disable\r\n** backtracking and make LL(1) grammars easy\r\n** to parse for all input methods.\r\n**\r\n*/\r\n\r\nenum {\r\n  MPC_INPUT_STRING = 0,\r\n  MPC_INPUT_FILE   = 1,\r\n  MPC_INPUT_PIPE   = 2\r\n};\r\n\r\nenum {\r\n  MPC_INPUT_MARKS_MIN = 32\r\n};\r\n\r\nenum {\r\n  MPC_INPUT_MEM_NUM = 512\r\n};\r\n\r\ntypedef struct {\r\n  char mem[64];\r\n} mpc_mem_t;\r\n\r\ntypedef struct {\r\n\r\n  int type;\r\n  char *filename;\r\n  mpc_state_t state;\r\n\r\n  char *string;\r\n  char *buffer;\r\n  FILE *file;\r\n\r\n  int suppress;\r\n  int backtrack;\r\n  int marks_slots;\r\n  int marks_num;\r\n  mpc_state_t *marks;\r\n\r\n  char *lasts;\r\n  char last;\r\n\r\n  size_t mem_index;\r\n  char mem_full[MPC_INPUT_MEM_NUM];\r\n  mpc_mem_t mem[MPC_INPUT_MEM_NUM];\r\n\r\n} mpc_input_t;\r\n\r\nstatic mpc_input_t *mpc_input_new_string(const char *filename, const char *string) {\r\n\r\n  mpc_input_t *i = malloc(sizeof(mpc_input_t));\r\n\r\n  i->filename = malloc(strlen(filename) + 1);\r\n  strcpy(i->filename, filename);\r\n  i->type = MPC_INPUT_STRING;\r\n\r\n  i->state = mpc_state_new();\r\n\r\n  i->string = malloc(strlen(string) + 1);\r\n  strcpy(i->string, string);\r\n  i->buffer = NULL;\r\n  i->file = NULL;\r\n\r\n  i->suppress = 0;\r\n  i->backtrack = 1;\r\n  i->marks_num = 0;\r\n  i->marks_slots = MPC_INPUT_MARKS_MIN;\r\n  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);\r\n  i->lasts = malloc(sizeof(char) * i->marks_slots);\r\n  i->last = '\\0';\r\n\r\n  i->mem_index = 0;\r\n  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);\r\n\r\n  return i;\r\n}\r\n\r\nstatic mpc_input_t *mpc_input_new_nstring(const char *filename, const char *string, size_t length) {\r\n\r\n  mpc_input_t *i = malloc(sizeof(mpc_input_t));\r\n\r\n  i->filename = malloc(strlen(filename) + 1);\r\n  strcpy(i->filename, filename);\r\n  i->type = MPC_INPUT_STRING;\r\n\r\n  i->state = mpc_state_new();\r\n\r\n  i->string = malloc(length + 1);\r\n  strncpy(i->string, string, length);\r\n  i->string[length] = '\\0';\r\n  i->buffer = NULL;\r\n  i->file = NULL;\r\n\r\n  i->suppress = 0;\r\n  i->backtrack = 1;\r\n  i->marks_num = 0;\r\n  i->marks_slots = MPC_INPUT_MARKS_MIN;\r\n  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);\r\n  i->lasts = malloc(sizeof(char) * i->marks_slots);\r\n  i->last = '\\0';\r\n\r\n  i->mem_index = 0;\r\n  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);\r\n\r\n  return i;\r\n\r\n}\r\n\r\nstatic mpc_input_t *mpc_input_new_pipe(const char *filename, FILE *pipe) {\r\n\r\n  mpc_input_t *i = malloc(sizeof(mpc_input_t));\r\n\r\n  i->filename = malloc(strlen(filename) + 1);\r\n  strcpy(i->filename, filename);\r\n\r\n  i->type = MPC_INPUT_PIPE;\r\n  i->state = mpc_state_new();\r\n\r\n  i->string = NULL;\r\n  i->buffer = NULL;\r\n  i->file = pipe;\r\n\r\n  i->suppress = 0;\r\n  i->backtrack = 1;\r\n  i->marks_num = 0;\r\n  i->marks_slots = MPC_INPUT_MARKS_MIN;\r\n  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);\r\n  i->lasts = malloc(sizeof(char) * i->marks_slots);\r\n  i->last = '\\0';\r\n\r\n  i->mem_index = 0;\r\n  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);\r\n\r\n  return i;\r\n\r\n}\r\n\r\nstatic mpc_input_t *mpc_input_new_file(const char *filename, FILE *file) {\r\n\r\n  mpc_input_t *i = malloc(sizeof(mpc_input_t));\r\n\r\n  i->filename = malloc(strlen(filename) + 1);\r\n  strcpy(i->filename, filename);\r\n  i->type = MPC_INPUT_FILE;\r\n  i->state = mpc_state_new();\r\n\r\n  i->string = NULL;\r\n  i->buffer = NULL;\r\n  i->file = file;\r\n\r\n  i->suppress = 0;\r\n  i->backtrack = 1;\r\n  i->marks_num = 0;\r\n  i->marks_slots = MPC_INPUT_MARKS_MIN;\r\n  i->marks = malloc(sizeof(mpc_state_t) * i->marks_slots);\r\n  i->lasts = malloc(sizeof(char) * i->marks_slots);\r\n  i->last = '\\0';\r\n\r\n  i->mem_index = 0;\r\n  memset(i->mem_full, 0, sizeof(char) * MPC_INPUT_MEM_NUM);\r\n\r\n  return i;\r\n}\r\n\r\nstatic void mpc_input_delete(mpc_input_t *i) {\r\n\r\n  free(i->filename);\r\n\r\n  if (i->type == MPC_INPUT_STRING) { free(i->string); }\r\n  if (i->type == MPC_INPUT_PIPE) { free(i->buffer); }\r\n\r\n  free(i->marks);\r\n  free(i->lasts);\r\n  free(i);\r\n}\r\n\r\nstatic int mpc_mem_ptr(mpc_input_t *i, void *p) {\r\n  return\r\n    (char*)p >= (char*)(i->mem) &&\r\n    (char*)p <  (char*)(i->mem) + (MPC_INPUT_MEM_NUM * sizeof(mpc_mem_t));\r\n}\r\n\r\nstatic void *mpc_malloc(mpc_input_t *i, size_t n) {\r\n  size_t j;\r\n  char *p;\r\n\r\n  if (n > sizeof(mpc_mem_t)) { return malloc(n); }\r\n\r\n  j = i->mem_index;\r\n  do {\r\n    if (!i->mem_full[i->mem_index]) {\r\n      p = (void*)(i->mem + i->mem_index);\r\n      i->mem_full[i->mem_index] = 1;\r\n      i->mem_index = (i->mem_index+1) % MPC_INPUT_MEM_NUM;\r\n      return p;\r\n    }\r\n    i->mem_index = (i->mem_index+1) % MPC_INPUT_MEM_NUM;\r\n  } while (j != i->mem_index);\r\n\r\n  return malloc(n);\r\n}\r\n\r\nstatic void *mpc_calloc(mpc_input_t *i, size_t n, size_t m) {\r\n  char *x = mpc_malloc(i, n * m);\r\n  memset(x, 0, n * m);\r\n  return x;\r\n}\r\n\r\nstatic void mpc_free(mpc_input_t *i, void *p) {\r\n  size_t j;\r\n  if (!mpc_mem_ptr(i, p)) { free(p); return; }\r\n  j = ((size_t)(((char*)p) - ((char*)i->mem))) / sizeof(mpc_mem_t);\r\n  i->mem_full[j] = 0;\r\n}\r\n\r\nstatic void *mpc_realloc(mpc_input_t *i, void *p, size_t n) {\r\n\r\n  char *q = NULL;\r\n\r\n  if (!mpc_mem_ptr(i, p)) { return realloc(p, n); }\r\n\r\n  if (n > sizeof(mpc_mem_t)) {\r\n    q = malloc(n);\r\n    memcpy(q, p, sizeof(mpc_mem_t));\r\n    mpc_free(i, p);\r\n    return q;\r\n  }\r\n\r\n  return p;\r\n}\r\n\r\nstatic void *mpc_export(mpc_input_t *i, void *p) {\r\n  char *q = NULL;\r\n  if (!mpc_mem_ptr(i, p)) { return p; }\r\n  q = malloc(sizeof(mpc_mem_t));\r\n  memcpy(q, p, sizeof(mpc_mem_t));\r\n  mpc_free(i, p);\r\n  return q;\r\n}\r\n\r\nstatic void mpc_input_backtrack_disable(mpc_input_t *i) { i->backtrack--; }\r\nstatic void mpc_input_backtrack_enable(mpc_input_t *i) { i->backtrack++; }\r\n\r\nstatic void mpc_input_suppress_disable(mpc_input_t *i) { i->suppress--; }\r\nstatic void mpc_input_suppress_enable(mpc_input_t *i) { i->suppress++; }\r\n\r\nstatic void mpc_input_mark(mpc_input_t *i) {\r\n\r\n  if (i->backtrack < 1) { return; }\r\n\r\n  i->marks_num++;\r\n\r\n  if (i->marks_num > i->marks_slots) {\r\n    i->marks_slots = i->marks_num + i->marks_num / 2;\r\n    i->marks = realloc(i->marks, sizeof(mpc_state_t) * i->marks_slots);\r\n    i->lasts = realloc(i->lasts, sizeof(char) * i->marks_slots);\r\n  }\r\n\r\n  i->marks[i->marks_num-1] = i->state;\r\n  i->lasts[i->marks_num-1] = i->last;\r\n\r\n  if (i->type == MPC_INPUT_PIPE && i->marks_num == 1) {\r\n    i->buffer = calloc(1, 1);\r\n  }\r\n\r\n}\r\n\r\nstatic void mpc_input_unmark(mpc_input_t *i) {\r\n  int j;\r\n\r\n  if (i->backtrack < 1) { return; }\r\n\r\n  i->marks_num--;\r\n\r\n  if (i->marks_slots > i->marks_num + i->marks_num / 2\r\n  &&  i->marks_slots > MPC_INPUT_MARKS_MIN) {\r\n    i->marks_slots =\r\n      i->marks_num > MPC_INPUT_MARKS_MIN ?\r\n      i->marks_num : MPC_INPUT_MARKS_MIN;\r\n    i->marks = realloc(i->marks, sizeof(mpc_state_t) * i->marks_slots);\r\n    i->lasts = realloc(i->lasts, sizeof(char) * i->marks_slots);\r\n  }\r\n\r\n  if (i->type == MPC_INPUT_PIPE && i->marks_num == 0) {\r\n    for (j = strlen(i->buffer) - 1; j >= 0; j--)\r\n      ungetc(i->buffer[j], i->file);\r\n\r\n    free(i->buffer);\r\n    i->buffer = NULL;\r\n  }\r\n\r\n}\r\n\r\nstatic void mpc_input_rewind(mpc_input_t *i) {\r\n\r\n  if (i->backtrack < 1) { return; }\r\n\r\n  i->state = i->marks[i->marks_num-1];\r\n  i->last  = i->lasts[i->marks_num-1];\r\n\r\n  if (i->type == MPC_INPUT_FILE) {\r\n    fseek(i->file, i->state.pos, SEEK_SET);\r\n  }\r\n\r\n  mpc_input_unmark(i);\r\n}\r\n\r\nstatic int mpc_input_buffer_in_range(mpc_input_t *i) {\r\n  return i->state.pos < (long)(strlen(i->buffer) + i->marks[0].pos);\r\n}\r\n\r\nstatic char mpc_input_buffer_get(mpc_input_t *i) {\r\n  return i->buffer[i->state.pos - i->marks[0].pos];\r\n}\r\n\r\nstatic char mpc_input_getc(mpc_input_t *i) {\r\n\r\n  char c = '\\0';\r\n\r\n  switch (i->type) {\r\n\r\n    case MPC_INPUT_STRING: return i->string[i->state.pos];\r\n    case MPC_INPUT_FILE: c = fgetc(i->file); return c;\r\n    case MPC_INPUT_PIPE:\r\n\r\n      if (!i->buffer) { c = getc(i->file); return c; }\r\n\r\n      if (i->buffer && mpc_input_buffer_in_range(i)) {\r\n        c = mpc_input_buffer_get(i);\r\n        return c;\r\n      } else {\r\n        c = getc(i->file);\r\n        return c;\r\n      }\r\n\r\n    default: return c;\r\n  }\r\n}\r\n\r\nstatic char mpc_input_peekc(mpc_input_t *i) {\r\n\r\n  char c = '\\0';\r\n\r\n  switch (i->type) {\r\n    case MPC_INPUT_STRING: return i->string[i->state.pos];\r\n    case MPC_INPUT_FILE:\r\n\r\n      c = fgetc(i->file);\r\n      if (feof(i->file)) { return '\\0'; }\r\n\r\n      fseek(i->file, -1, SEEK_CUR);\r\n      return c;\r\n\r\n    case MPC_INPUT_PIPE:\r\n\r\n      if (!i->buffer) {\r\n        c = getc(i->file);\r\n        if (feof(i->file)) { return '\\0'; }\r\n        ungetc(c, i->file);\r\n        return c;\r\n      }\r\n\r\n      if (i->buffer && mpc_input_buffer_in_range(i)) {\r\n        return mpc_input_buffer_get(i);\r\n      } else {\r\n        c = getc(i->file);\r\n        if (feof(i->file)) { return '\\0'; }\r\n        ungetc(c, i->file);\r\n        return c;\r\n      }\r\n\r\n    default: return c;\r\n  }\r\n\r\n}\r\n\r\nstatic int mpc_input_terminated(mpc_input_t *i) {\r\n  return mpc_input_peekc(i) == '\\0';\r\n}\r\n\r\nstatic int mpc_input_failure(mpc_input_t *i, char c) {\r\n\r\n  switch (i->type) {\r\n    case MPC_INPUT_STRING: { break; }\r\n    case MPC_INPUT_FILE: fseek(i->file, -1, SEEK_CUR); { break; }\r\n    case MPC_INPUT_PIPE: {\r\n\r\n      if (!i->buffer) { ungetc(c, i->file); break; }\r\n\r\n      if (i->buffer && mpc_input_buffer_in_range(i)) {\r\n        break;\r\n      } else {\r\n        ungetc(c, i->file);\r\n      }\r\n    }\r\n    default: { break; }\r\n  }\r\n  return 0;\r\n}\r\n\r\nstatic int mpc_input_success(mpc_input_t *i, char c, char **o) {\r\n\r\n  if (i->type == MPC_INPUT_PIPE\r\n  &&  i->buffer && !mpc_input_buffer_in_range(i)) {\r\n    i->buffer = realloc(i->buffer, strlen(i->buffer) + 2);\r\n    i->buffer[strlen(i->buffer) + 1] = '\\0';\r\n    i->buffer[strlen(i->buffer) + 0] = c;\r\n  }\r\n\r\n  i->last = c;\r\n  i->state.pos++;\r\n  i->state.col++;\r\n\r\n  if (c == '\\n') {\r\n    i->state.col = 0;\r\n    i->state.row++;\r\n  }\r\n\r\n  if (o) {\r\n    (*o) = mpc_malloc(i, 2);\r\n    (*o)[0] = c;\r\n    (*o)[1] = '\\0';\r\n  }\r\n\r\n  return 1;\r\n}\r\n\r\nstatic int mpc_input_any(mpc_input_t *i, char **o) {\r\n  char x;\r\n  if (mpc_input_terminated(i)) { return 0; }\r\n  x = mpc_input_getc(i);\r\n  return mpc_input_success(i, x, o);\r\n}\r\n\r\nstatic int mpc_input_char(mpc_input_t *i, char c, char **o) {\r\n  char x;\r\n  if (mpc_input_terminated(i)) { return 0; }\r\n  x = mpc_input_getc(i);\r\n  return x == c ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);\r\n}\r\n\r\nstatic int mpc_input_range(mpc_input_t *i, char c, char d, char **o) {\r\n  char x;\r\n  if (mpc_input_terminated(i)) { return 0; }\r\n  x = mpc_input_getc(i);\r\n  return x >= c && x <= d ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);\r\n}\r\n\r\nstatic int mpc_input_oneof(mpc_input_t *i, const char *c, char **o) {\r\n  char x;\r\n  if (mpc_input_terminated(i)) { return 0; }\r\n  x = mpc_input_getc(i);\r\n  return strchr(c, x) != 0 ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);\r\n}\r\n\r\nstatic int mpc_input_noneof(mpc_input_t *i, const char *c, char **o) {\r\n  char x;\r\n  if (mpc_input_terminated(i)) { return 0; }\r\n  x = mpc_input_getc(i);\r\n  return strchr(c, x) == 0 ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);\r\n}\r\n\r\nstatic int mpc_input_satisfy(mpc_input_t *i, int(*cond)(char), char **o) {\r\n  char x;\r\n  if (mpc_input_terminated(i)) { return 0; }\r\n  x = mpc_input_getc(i);\r\n  return cond(x) ? mpc_input_success(i, x, o) : mpc_input_failure(i, x);\r\n}\r\n\r\nstatic int mpc_input_string(mpc_input_t *i, const char *c, char **o) {\r\n\r\n  const char *x = c;\r\n\r\n  mpc_input_mark(i);\r\n  while (*x) {\r\n    if (!mpc_input_char(i, *x, NULL)) {\r\n      mpc_input_rewind(i);\r\n      return 0;\r\n    }\r\n    x++;\r\n  }\r\n  mpc_input_unmark(i);\r\n\r\n  *o = mpc_malloc(i, strlen(c) + 1);\r\n  strcpy(*o, c);\r\n  return 1;\r\n}\r\n\r\nstatic int mpc_input_anchor(mpc_input_t* i, int(*f)(char,char), char **o) {\r\n  *o = NULL;\r\n  return f(i->last, mpc_input_peekc(i));\r\n}\r\n\r\nstatic int mpc_input_soi(mpc_input_t* i, char **o) {\r\n  *o = NULL;\r\n  return i->last == '\\0';\r\n}\r\n\r\nstatic int mpc_input_eoi(mpc_input_t* i, char **o) {\r\n  *o = NULL;\r\n  if (i->state.term) {\r\n    return 0;\r\n  } else if (mpc_input_terminated(i)) {\r\n    i->state.term = 1;\r\n    return 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\nstatic mpc_state_t *mpc_input_state_copy(mpc_input_t *i) {\r\n  mpc_state_t *r = mpc_malloc(i, sizeof(mpc_state_t));\r\n  memcpy(r, &i->state, sizeof(mpc_state_t));\r\n  return r;\r\n}\r\n\r\n/*\r\n** Error Type\r\n*/\r\n\r\nvoid mpc_err_delete(mpc_err_t *x) {\r\n  int i;\r\n  for (i = 0; i < x->expected_num; i++) { free(x->expected[i]); }\r\n  free(x->expected);\r\n  free(x->filename);\r\n  free(x->failure);\r\n  free(x);\r\n}\r\n\r\nvoid mpc_err_print(mpc_err_t *x) {\r\n  mpc_err_print_to(x, stdout);\r\n}\r\n\r\nvoid mpc_err_print_to(mpc_err_t *x, FILE *f) {\r\n  char *str = mpc_err_string(x);\r\n  fprintf(f, \"%s\", str);\r\n  free(str);\r\n}\r\n\r\nstatic void mpc_err_string_cat(char *buffer, int *pos, int *max, char const *fmt, ...) {\r\n  /* TODO: Error Checking on Length */\r\n  int left = ((*max) - (*pos));\r\n  va_list va;\r\n  va_start(va, fmt);\r\n  if (left < 0) { left = 0;}\r\n  (*pos) += vsprintf(buffer + (*pos), fmt, va);\r\n  va_end(va);\r\n}\r\n\r\nstatic const char *mpc_err_char_unescape(char c, char char_unescape_buffer[4]) {\r\n\r\n  char_unescape_buffer[0] = '\\'';\r\n  char_unescape_buffer[1] = ' ';\r\n  char_unescape_buffer[2] = '\\'';\r\n  char_unescape_buffer[3] = '\\0';\r\n\r\n  switch (c) {\r\n    case '\\a': return \"bell\";\r\n    case '\\b': return \"backspace\";\r\n    case '\\f': return \"formfeed\";\r\n    case '\\r': return \"carriage return\";\r\n    case '\\v': return \"vertical tab\";\r\n    case '\\0': return \"end of input\";\r\n    case '\\n': return \"newline\";\r\n    case '\\t': return \"tab\";\r\n    case ' ' : return \"space\";\r\n    default:\r\n      char_unescape_buffer[1] = c;\r\n      return char_unescape_buffer;\r\n  }\r\n\r\n}\r\n\r\nchar *mpc_err_string(mpc_err_t *x) {\r\n\r\n  int i;\r\n  int pos = 0;\r\n  int max = 1023;\r\n  char *buffer = calloc(1, 1024);\r\n  char char_unescape_buffer[4];\r\n\r\n  if (x->failure) {\r\n    mpc_err_string_cat(buffer, &pos, &max,\r\n    \"%s: error: %s\\n\", x->filename, x->failure);\r\n    return buffer;\r\n  }\r\n\r\n  mpc_err_string_cat(buffer, &pos, &max,\r\n    \"%s:%li:%li: error: expected \", x->filename, x->state.row+1, x->state.col+1);\r\n\r\n  if (x->expected_num == 0) { mpc_err_string_cat(buffer, &pos, &max, \"ERROR: NOTHING EXPECTED\"); }\r\n  if (x->expected_num == 1) { mpc_err_string_cat(buffer, &pos, &max, \"%s\", x->expected[0]); }\r\n  if (x->expected_num >= 2) {\r\n\r\n    for (i = 0; i < x->expected_num-2; i++) {\r\n      mpc_err_string_cat(buffer, &pos, &max, \"%s, \", x->expected[i]);\r\n    }\r\n\r\n    mpc_err_string_cat(buffer, &pos, &max, \"%s or %s\",\r\n      x->expected[x->expected_num-2],\r\n      x->expected[x->expected_num-1]);\r\n  }\r\n\r\n  mpc_err_string_cat(buffer, &pos, &max, \" at \");\r\n  mpc_err_string_cat(buffer, &pos, &max, mpc_err_char_unescape(x->received, char_unescape_buffer));\r\n  mpc_err_string_cat(buffer, &pos, &max, \"\\n\");\r\n\r\n  return realloc(buffer, strlen(buffer) + 1);\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_new(mpc_input_t *i, const char *expected) {\r\n  mpc_err_t *x;\r\n  if (i->suppress) { return NULL; }\r\n  x = mpc_malloc(i, sizeof(mpc_err_t));\r\n  x->filename = mpc_malloc(i, strlen(i->filename) + 1);\r\n  strcpy(x->filename, i->filename);\r\n  x->state = i->state;\r\n  x->expected_num = 1;\r\n  x->expected = mpc_malloc(i, sizeof(char*));\r\n  x->expected[0] = mpc_malloc(i, strlen(expected) + 1);\r\n  strcpy(x->expected[0], expected);\r\n  x->failure = NULL;\r\n  x->received = mpc_input_peekc(i);\r\n  return x;\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_fail(mpc_input_t *i, const char *failure) {\r\n  mpc_err_t *x;\r\n  if (i->suppress) { return NULL; }\r\n  x = mpc_malloc(i, sizeof(mpc_err_t));\r\n  x->filename = mpc_malloc(i, strlen(i->filename) + 1);\r\n  strcpy(x->filename, i->filename);\r\n  x->state = i->state;\r\n  x->expected_num = 0;\r\n  x->expected = NULL;\r\n  x->failure = mpc_malloc(i, strlen(failure) + 1);\r\n  strcpy(x->failure, failure);\r\n  x->received = ' ';\r\n  return x;\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_file(const char *filename, const char *failure) {\r\n  mpc_err_t *x;\r\n  x = malloc(sizeof(mpc_err_t));\r\n  x->filename = malloc(strlen(filename) + 1);\r\n  strcpy(x->filename, filename);\r\n  x->state = mpc_state_new();\r\n  x->expected_num = 0;\r\n  x->expected = NULL;\r\n  x->failure = malloc(strlen(failure) + 1);\r\n  strcpy(x->failure, failure);\r\n  x->received = ' ';\r\n  return x;\r\n}\r\n\r\nstatic void mpc_err_delete_internal(mpc_input_t *i, mpc_err_t *x) {\r\n  int j;\r\n  if (x == NULL) { return; }\r\n  for (j = 0; j < x->expected_num; j++) { mpc_free(i, x->expected[j]); }\r\n  mpc_free(i, x->expected);\r\n  mpc_free(i, x->filename);\r\n  mpc_free(i, x->failure);\r\n  mpc_free(i, x);\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_export(mpc_input_t *i, mpc_err_t *x) {\r\n  int j;\r\n  for (j = 0; j < x->expected_num; j++) {\r\n    x->expected[j] = mpc_export(i, x->expected[j]);\r\n  }\r\n  x->expected = mpc_export(i, x->expected);\r\n  x->filename = mpc_export(i, x->filename);\r\n  x->failure = mpc_export(i, x->failure);\r\n  return mpc_export(i, x);\r\n}\r\n\r\nstatic int mpc_err_contains_expected(mpc_input_t *i, mpc_err_t *x, char *expected) {\r\n  int j;\r\n  (void)i;\r\n  for (j = 0; j < x->expected_num; j++) {\r\n    if (strcmp(x->expected[j], expected) == 0) { return 1; }\r\n  }\r\n  return 0;\r\n}\r\n\r\nstatic void mpc_err_add_expected(mpc_input_t *i, mpc_err_t *x, char *expected) {\r\n  (void)i;\r\n  x->expected_num++;\r\n  x->expected = mpc_realloc(i, x->expected, sizeof(char*) * x->expected_num);\r\n  x->expected[x->expected_num-1] = mpc_malloc(i, strlen(expected) + 1);\r\n  strcpy(x->expected[x->expected_num-1], expected);\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_or(mpc_input_t *i, mpc_err_t** x, int n) {\r\n\r\n  int j, k, fst;\r\n  mpc_err_t *e;\r\n\r\n  fst = -1;\r\n  for (j = 0; j < n; j++) {\r\n    if (x[j] != NULL) { fst = j; }\r\n  }\r\n\r\n  if (fst == -1) { return NULL; }\r\n\r\n  e = mpc_malloc(i, sizeof(mpc_err_t));\r\n  e->state = mpc_state_invalid();\r\n  e->expected_num = 0;\r\n  e->expected = NULL;\r\n  e->failure = NULL;\r\n  e->filename = mpc_malloc(i, strlen(x[fst]->filename)+1);\r\n  strcpy(e->filename, x[fst]->filename);\r\n\r\n  for (j = 0; j < n; j++) {\r\n    if (x[j] == NULL) { continue; }\r\n    if (x[j]->state.pos > e->state.pos) { e->state = x[j]->state; }\r\n  }\r\n\r\n  for (j = 0; j < n; j++) {\r\n    if (x[j] == NULL) { continue; }\r\n    if (x[j]->state.pos < e->state.pos) { continue; }\r\n\r\n    if (x[j]->failure) {\r\n      e->failure = mpc_malloc(i, strlen(x[j]->failure)+1);\r\n      strcpy(e->failure, x[j]->failure);\r\n      break;\r\n    }\r\n\r\n    e->received = x[j]->received;\r\n\r\n    for (k = 0; k < x[j]->expected_num; k++) {\r\n      if (!mpc_err_contains_expected(i, e, x[j]->expected[k])) {\r\n        mpc_err_add_expected(i, e, x[j]->expected[k]);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (j = 0; j < n; j++) {\r\n    if (x[j] == NULL) { continue; }\r\n    mpc_err_delete_internal(i, x[j]);\r\n  }\r\n\r\n  return e;\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_repeat(mpc_input_t *i, mpc_err_t *x, const char *prefix) {\r\n\r\n  int j = 0;\r\n  size_t l = 0;\r\n  char *expect = NULL;\r\n\r\n  if (x == NULL) { return NULL; }\r\n\r\n  if (x->expected_num == 0) {\r\n    expect = mpc_calloc(i, 1, 1);\r\n    x->expected_num = 1;\r\n    x->expected = mpc_realloc(i, x->expected, sizeof(char*) * x->expected_num);\r\n    x->expected[0] = expect;\r\n    return x;\r\n  }\r\n\r\n  else if (x->expected_num == 1) {\r\n    expect = mpc_malloc(i, strlen(prefix) + strlen(x->expected[0]) + 1);\r\n    strcpy(expect, prefix);\r\n    strcat(expect, x->expected[0]);\r\n    mpc_free(i, x->expected[0]);\r\n    x->expected[0] = expect;\r\n    return x;\r\n  }\r\n\r\n  else if (x->expected_num > 1) {\r\n\r\n    l += strlen(prefix);\r\n    for (j = 0; j < x->expected_num-2; j++) {\r\n      l += strlen(x->expected[j]) + strlen(\", \");\r\n    }\r\n    l += strlen(x->expected[x->expected_num-2]);\r\n    l += strlen(\" or \");\r\n    l += strlen(x->expected[x->expected_num-1]);\r\n\r\n    expect = mpc_malloc(i, l + 1);\r\n\r\n    strcpy(expect, prefix);\r\n    for (j = 0; j < x->expected_num-2; j++) {\r\n      strcat(expect, x->expected[j]); strcat(expect, \", \");\r\n    }\r\n    strcat(expect, x->expected[x->expected_num-2]);\r\n    strcat(expect, \" or \");\r\n    strcat(expect, x->expected[x->expected_num-1]);\r\n\r\n    for (j = 0; j < x->expected_num; j++) { mpc_free(i, x->expected[j]); }\r\n\r\n    x->expected_num = 1;\r\n    x->expected = mpc_realloc(i, x->expected, sizeof(char*) * x->expected_num);\r\n    x->expected[0] = expect;\r\n    return x;\r\n  }\r\n\r\n  return NULL;\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_many1(mpc_input_t *i, mpc_err_t *x) {\r\n  return mpc_err_repeat(i, x, \"one or more of \");\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_count(mpc_input_t *i, mpc_err_t *x, int n) {\r\n  mpc_err_t *y;\r\n  int digits = n/10 + 1;\r\n  char *prefix;\r\n  prefix = mpc_malloc(i, digits + strlen(\" of \") + 1);\r\n  if (!prefix) {\r\n    return NULL;\r\n  }\r\n  sprintf(prefix, \"%i of \", n);\r\n  y = mpc_err_repeat(i, x, prefix);\r\n  mpc_free(i, prefix);\r\n  return y;\r\n}\r\n\r\nstatic mpc_err_t *mpc_err_merge(mpc_input_t *i, mpc_err_t *x, mpc_err_t *y) {\r\n  mpc_err_t *errs[2];\r\n  errs[0] = x;\r\n  errs[1] = y;\r\n  return mpc_err_or(i, errs, 2);\r\n}\r\n\r\n/*\r\n** Parser Type\r\n*/\r\n\r\nenum {\r\n  MPC_TYPE_UNDEFINED  = 0,\r\n  MPC_TYPE_PASS       = 1,\r\n  MPC_TYPE_FAIL       = 2,\r\n  MPC_TYPE_LIFT       = 3,\r\n  MPC_TYPE_LIFT_VAL   = 4,\r\n  MPC_TYPE_EXPECT     = 5,\r\n  MPC_TYPE_ANCHOR     = 6,\r\n  MPC_TYPE_STATE      = 7,\r\n\r\n  MPC_TYPE_ANY        = 8,\r\n  MPC_TYPE_SINGLE     = 9,\r\n  MPC_TYPE_ONEOF      = 10,\r\n  MPC_TYPE_NONEOF     = 11,\r\n  MPC_TYPE_RANGE      = 12,\r\n  MPC_TYPE_SATISFY    = 13,\r\n  MPC_TYPE_STRING     = 14,\r\n\r\n  MPC_TYPE_APPLY      = 15,\r\n  MPC_TYPE_APPLY_TO   = 16,\r\n  MPC_TYPE_PREDICT    = 17,\r\n  MPC_TYPE_NOT        = 18,\r\n  MPC_TYPE_MAYBE      = 19,\r\n  MPC_TYPE_MANY       = 20,\r\n  MPC_TYPE_MANY1      = 21,\r\n  MPC_TYPE_COUNT      = 22,\r\n\r\n  MPC_TYPE_OR         = 23,\r\n  MPC_TYPE_AND        = 24,\r\n\r\n  MPC_TYPE_CHECK      = 25,\r\n  MPC_TYPE_CHECK_WITH = 26,\r\n\r\n  MPC_TYPE_SOI        = 27,\r\n  MPC_TYPE_EOI        = 28,\r\n\r\n  MPC_TYPE_SEPBY1     = 29\r\n};\r\n\r\ntypedef struct { char *m; } mpc_pdata_fail_t;\r\ntypedef struct { mpc_ctor_t lf; void *x; } mpc_pdata_lift_t;\r\ntypedef struct { mpc_parser_t *x; char *m; } mpc_pdata_expect_t;\r\ntypedef struct { int(*f)(char,char); } mpc_pdata_anchor_t;\r\ntypedef struct { char x; } mpc_pdata_single_t;\r\ntypedef struct { char x; char y; } mpc_pdata_range_t;\r\ntypedef struct { int(*f)(char); } mpc_pdata_satisfy_t;\r\ntypedef struct { char *x; } mpc_pdata_string_t;\r\ntypedef struct { mpc_parser_t *x; mpc_apply_t f; } mpc_pdata_apply_t;\r\ntypedef struct { mpc_parser_t *x; mpc_apply_to_t f; void *d; } mpc_pdata_apply_to_t;\r\ntypedef struct { mpc_parser_t *x; mpc_dtor_t dx; mpc_check_t f; char *e; } mpc_pdata_check_t;\r\ntypedef struct { mpc_parser_t *x; mpc_dtor_t dx; mpc_check_with_t f; void *d; char *e; } mpc_pdata_check_with_t;\r\ntypedef struct { mpc_parser_t *x; } mpc_pdata_predict_t;\r\ntypedef struct { mpc_parser_t *x; mpc_dtor_t dx; mpc_ctor_t lf; } mpc_pdata_not_t;\r\ntypedef struct { int n; mpc_fold_t f; mpc_parser_t *x; mpc_dtor_t dx; } mpc_pdata_repeat_t;\r\ntypedef struct { int n; mpc_parser_t **xs; } mpc_pdata_or_t;\r\ntypedef struct { int n; mpc_fold_t f; mpc_parser_t **xs; mpc_dtor_t *dxs;  } mpc_pdata_and_t;\r\ntypedef struct { int n; mpc_fold_t f; mpc_parser_t *x; mpc_parser_t *sep; } mpc_pdata_sepby1;\r\n\r\ntypedef union {\r\n  mpc_pdata_fail_t fail;\r\n  mpc_pdata_lift_t lift;\r\n  mpc_pdata_expect_t expect;\r\n  mpc_pdata_anchor_t anchor;\r\n  mpc_pdata_single_t single;\r\n  mpc_pdata_range_t range;\r\n  mpc_pdata_satisfy_t satisfy;\r\n  mpc_pdata_string_t string;\r\n  mpc_pdata_apply_t apply;\r\n  mpc_pdata_apply_to_t apply_to;\r\n  mpc_pdata_check_t check;\r\n  mpc_pdata_check_with_t check_with;\r\n  mpc_pdata_predict_t predict;\r\n  mpc_pdata_not_t not;\r\n  mpc_pdata_repeat_t repeat;\r\n  mpc_pdata_and_t and;\r\n  mpc_pdata_or_t or;\r\n  mpc_pdata_sepby1 sepby1;\r\n} mpc_pdata_t;\r\n\r\nstruct mpc_parser_t {\r\n  char *name;\r\n  mpc_pdata_t data;\r\n  char type;\r\n  char retained;\r\n};\r\n\r\nstatic mpc_val_t *mpcf_input_nth_free(mpc_input_t *i, int n, mpc_val_t **xs, int x) {\r\n  int j;\r\n  for (j = 0; j < n; j++) { if (j != x) { mpc_free(i, xs[j]); } }\r\n  return xs[x];\r\n}\r\n\r\nstatic mpc_val_t *mpcf_input_fst_free(mpc_input_t *i, int n, mpc_val_t **xs) { return mpcf_input_nth_free(i, n, xs, 0); }\r\nstatic mpc_val_t *mpcf_input_snd_free(mpc_input_t *i, int n, mpc_val_t **xs) { return mpcf_input_nth_free(i, n, xs, 1); }\r\nstatic mpc_val_t *mpcf_input_trd_free(mpc_input_t *i, int n, mpc_val_t **xs) { return mpcf_input_nth_free(i, n, xs, 2); }\r\n\r\nstatic mpc_val_t *mpcf_input_strfold(mpc_input_t *i, int n, mpc_val_t **xs) {\r\n  int j;\r\n  size_t l = 0;\r\n  if (n == 0) { return mpc_calloc(i, 1, 1); }\r\n  for (j = 0; j < n; j++) { l += strlen(xs[j]); }\r\n  xs[0] = mpc_realloc(i, xs[0], l + 1);\r\n  for (j = 1; j < n; j++) { strcat(xs[0], xs[j]); mpc_free(i, xs[j]); }\r\n  return xs[0];\r\n}\r\n\r\nstatic mpc_val_t *mpcf_input_state_ast(mpc_input_t *i, int n, mpc_val_t **xs) {\r\n  mpc_state_t *s = ((mpc_state_t**)xs)[0];\r\n  mpc_ast_t *a = ((mpc_ast_t**)xs)[1];\r\n  a = mpc_ast_state(a, *s);\r\n  mpc_free(i, s);\r\n  (void) n;\r\n  return a;\r\n}\r\n\r\nstatic mpc_val_t *mpc_parse_fold(mpc_input_t *i, mpc_fold_t f, int n, mpc_val_t **xs) {\r\n  int j;\r\n  if (f == mpcf_null)      { return mpcf_null(n, xs); }\r\n  if (f == mpcf_fst)       { return mpcf_fst(n, xs); }\r\n  if (f == mpcf_snd)       { return mpcf_snd(n, xs); }\r\n  if (f == mpcf_trd)       { return mpcf_trd(n, xs); }\r\n  if (f == mpcf_fst_free)  { return mpcf_input_fst_free(i, n, xs); }\r\n  if (f == mpcf_snd_free)  { return mpcf_input_snd_free(i, n, xs); }\r\n  if (f == mpcf_trd_free)  { return mpcf_input_trd_free(i, n, xs); }\r\n  if (f == mpcf_strfold)   { return mpcf_input_strfold(i, n, xs); }\r\n  if (f == mpcf_state_ast) { return mpcf_input_state_ast(i, n, xs); }\r\n  for (j = 0; j < n; j++) { xs[j] = mpc_export(i, xs[j]); }\r\n  return f(j, xs);\r\n}\r\n\r\nstatic mpc_val_t *mpcf_input_free(mpc_input_t *i, mpc_val_t *x) {\r\n  mpc_free(i, x);\r\n  return NULL;\r\n}\r\n\r\nstatic mpc_val_t *mpcf_input_str_ast(mpc_input_t *i, mpc_val_t *c) {\r\n  mpc_ast_t *a = mpc_ast_new(\"\", c);\r\n  mpc_free(i, c);\r\n  return a;\r\n}\r\n\r\nstatic mpc_val_t *mpc_parse_apply(mpc_input_t *i, mpc_apply_t f, mpc_val_t *x) {\r\n  if (f == mpcf_free)     { return mpcf_input_free(i, x); }\r\n  if (f == mpcf_str_ast)  { return mpcf_input_str_ast(i, x); }\r\n  return f(mpc_export(i, x));\r\n}\r\n\r\nstatic mpc_val_t *mpc_parse_apply_to(mpc_input_t *i, mpc_apply_to_t f, mpc_val_t *x, mpc_val_t *d) {\r\n  return f(mpc_export(i, x), d);\r\n}\r\n\r\nstatic void mpc_parse_dtor(mpc_input_t *i, mpc_dtor_t d, mpc_val_t *x) {\r\n  if (d == free) { mpc_free(i, x); return; }\r\n  d(mpc_export(i, x));\r\n}\r\n\r\nenum {\r\n  MPC_PARSE_STACK_MIN = 4\r\n};\r\n\r\n#define MPC_SUCCESS(x) r->output = x; return 1\r\n#define MPC_FAILURE(x) r->error = x; return 0\r\n#define MPC_PRIMITIVE(x) \\\r\n  if (x) { MPC_SUCCESS(r->output); } \\\r\n  else { MPC_FAILURE(NULL); }\r\n\r\n#define MPC_MAX_RECURSION_DEPTH 1000\r\n\r\nstatic mpc_result_t *mpc_grow_results(mpc_input_t *i, int j, mpc_result_t *results_stk, mpc_result_t *results){\r\n  mpc_result_t *tmp_results = results;\r\n\r\n  if (j == MPC_PARSE_STACK_MIN) {\r\n    int results_slots = j + j / 2;\r\n    tmp_results = mpc_malloc(i, sizeof(mpc_result_t) * results_slots);\r\n    memcpy(tmp_results, results_stk, sizeof(mpc_result_t) * MPC_PARSE_STACK_MIN);\r\n  } else if (j >= MPC_PARSE_STACK_MIN) {\r\n    int results_slots = j + j / 2;\r\n    tmp_results = mpc_realloc(i, tmp_results, sizeof(mpc_result_t) * results_slots);\r\n  }\r\n\r\n  return tmp_results;\r\n}\r\n\r\nstatic int mpc_parse_run(mpc_input_t *i, mpc_parser_t *p, mpc_result_t *r, mpc_err_t **e, int depth) {\r\n\r\n  int j = 0, k = 0;\r\n  mpc_result_t results_stk[MPC_PARSE_STACK_MIN];\r\n  mpc_result_t *results;\r\n\r\n  if (depth == MPC_MAX_RECURSION_DEPTH)\r\n  {\r\n    MPC_FAILURE(mpc_err_fail(i, \"Maximum recursion depth exceeded!\"));\r\n  }\r\n\r\n  switch (p->type) {\r\n\r\n    /* Basic Parsers */\r\n\r\n    case MPC_TYPE_ANY:     MPC_PRIMITIVE(mpc_input_any(i, (char**)&r->output));\r\n    case MPC_TYPE_SINGLE:  MPC_PRIMITIVE(mpc_input_char(i, p->data.single.x, (char**)&r->output));\r\n    case MPC_TYPE_RANGE:   MPC_PRIMITIVE(mpc_input_range(i, p->data.range.x, p->data.range.y, (char**)&r->output));\r\n    case MPC_TYPE_ONEOF:   MPC_PRIMITIVE(mpc_input_oneof(i, p->data.string.x, (char**)&r->output));\r\n    case MPC_TYPE_NONEOF:  MPC_PRIMITIVE(mpc_input_noneof(i, p->data.string.x, (char**)&r->output));\r\n    case MPC_TYPE_SATISFY: MPC_PRIMITIVE(mpc_input_satisfy(i, p->data.satisfy.f, (char**)&r->output));\r\n    case MPC_TYPE_STRING:  MPC_PRIMITIVE(mpc_input_string(i, p->data.string.x, (char**)&r->output));\r\n    case MPC_TYPE_ANCHOR:  MPC_PRIMITIVE(mpc_input_anchor(i, p->data.anchor.f, (char**)&r->output));\r\n    case MPC_TYPE_SOI:     MPC_PRIMITIVE(mpc_input_soi(i, (char**)&r->output));\r\n    case MPC_TYPE_EOI:     MPC_PRIMITIVE(mpc_input_eoi(i, (char**)&r->output));\r\n\r\n    /* Other parsers */\r\n\r\n    case MPC_TYPE_UNDEFINED: MPC_FAILURE(mpc_err_fail(i, \"Parser Undefined!\"));\r\n    case MPC_TYPE_PASS:      MPC_SUCCESS(NULL);\r\n    case MPC_TYPE_FAIL:      MPC_FAILURE(mpc_err_fail(i, p->data.fail.m));\r\n    case MPC_TYPE_LIFT:      MPC_SUCCESS(p->data.lift.lf());\r\n    case MPC_TYPE_LIFT_VAL:  MPC_SUCCESS(p->data.lift.x);\r\n    case MPC_TYPE_STATE:     MPC_SUCCESS(mpc_input_state_copy(i));\r\n\r\n    /* Application Parsers */\r\n\r\n    case MPC_TYPE_APPLY:\r\n      if (mpc_parse_run(i, p->data.apply.x, r, e, depth+1)) {\r\n        MPC_SUCCESS(mpc_parse_apply(i, p->data.apply.f, r->output));\r\n      } else {\r\n        MPC_FAILURE(r->output);\r\n      }\r\n\r\n    case MPC_TYPE_APPLY_TO:\r\n      if (mpc_parse_run(i, p->data.apply_to.x, r, e, depth+1)) {\r\n        MPC_SUCCESS(mpc_parse_apply_to(i, p->data.apply_to.f, r->output, p->data.apply_to.d));\r\n      } else {\r\n        MPC_FAILURE(r->error);\r\n      }\r\n\r\n    case MPC_TYPE_CHECK:\r\n      if (mpc_parse_run(i, p->data.check.x, r, e, depth+1)) {\r\n        if (p->data.check.f(&r->output)) {\r\n          MPC_SUCCESS(r->output);\r\n        } else {\r\n          mpc_parse_dtor(i, p->data.check.dx, r->output);\r\n          MPC_FAILURE(mpc_err_fail(i, p->data.check.e));\r\n        }\r\n      } else {\r\n        MPC_FAILURE(r->error);\r\n      }\r\n\r\n    case MPC_TYPE_CHECK_WITH:\r\n      if (mpc_parse_run(i, p->data.check_with.x, r, e, depth+1)) {\r\n        if (p->data.check_with.f(&r->output, p->data.check_with.d)) {\r\n          MPC_SUCCESS(r->output);\r\n        } else {\r\n          mpc_parse_dtor(i, p->data.check.dx, r->output);\r\n          MPC_FAILURE(mpc_err_fail(i, p->data.check_with.e));\r\n        }\r\n      } else {\r\n        MPC_FAILURE(r->error);\r\n      }\r\n\r\n    case MPC_TYPE_EXPECT:\r\n      mpc_input_suppress_enable(i);\r\n      if (mpc_parse_run(i, p->data.expect.x, r, e, depth+1)) {\r\n        mpc_input_suppress_disable(i);\r\n        MPC_SUCCESS(r->output);\r\n      } else {\r\n        mpc_input_suppress_disable(i);\r\n        MPC_FAILURE(mpc_err_new(i, p->data.expect.m));\r\n      }\r\n\r\n    case MPC_TYPE_PREDICT:\r\n      mpc_input_backtrack_disable(i);\r\n      if (mpc_parse_run(i, p->data.predict.x, r, e, depth+1)) {\r\n        mpc_input_backtrack_enable(i);\r\n        MPC_SUCCESS(r->output);\r\n      } else {\r\n        mpc_input_backtrack_enable(i);\r\n        MPC_FAILURE(r->error);\r\n      }\r\n\r\n    /* Optional Parsers */\r\n\r\n    /* TODO: Update Not Error Message */\r\n\r\n    case MPC_TYPE_NOT:\r\n      mpc_input_mark(i);\r\n      mpc_input_suppress_enable(i);\r\n      if (mpc_parse_run(i, p->data.not.x, r, e, depth+1)) {\r\n        mpc_input_rewind(i);\r\n        mpc_input_suppress_disable(i);\r\n        mpc_parse_dtor(i, p->data.not.dx, r->output);\r\n        MPC_FAILURE(mpc_err_new(i, \"opposite\"));\r\n      } else {\r\n        mpc_input_unmark(i);\r\n        mpc_input_suppress_disable(i);\r\n        MPC_SUCCESS(p->data.not.lf());\r\n      }\r\n\r\n    case MPC_TYPE_MAYBE:\r\n      if (mpc_parse_run(i, p->data.not.x, r, e, depth+1)) {\r\n        MPC_SUCCESS(r->output);\r\n      } else {\r\n        *e = mpc_err_merge(i, *e, r->error);\r\n        MPC_SUCCESS(p->data.not.lf());\r\n      }\r\n\r\n    /* Repeat Parsers */\r\n\r\n    case MPC_TYPE_MANY:\r\n\r\n      results = results_stk;\r\n\r\n      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {\r\n        j++;\r\n        results = mpc_grow_results(i, j, results_stk, results);\r\n      }\r\n\r\n      *e = mpc_err_merge(i, *e, results[j].error);\r\n\r\n      MPC_SUCCESS(\r\n        mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results);\r\n        if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n\r\n    case MPC_TYPE_MANY1:\r\n\r\n      results = results_stk;\r\n\r\n      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {\r\n        j++;\r\n        results = mpc_grow_results(i, j, results_stk, results);\r\n      }\r\n\r\n      if (j == 0) {\r\n        MPC_FAILURE(\r\n          mpc_err_many1(i, results[j].error);\r\n          if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n      } else {\r\n\r\n        *e = mpc_err_merge(i, *e, results[j].error);\r\n\r\n        MPC_SUCCESS(\r\n          mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results);\r\n          if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n      }\r\n\r\n   case MPC_TYPE_SEPBY1:\r\n\r\n      results = results_stk;\r\n\r\n      if(mpc_parse_run(i, p->data.sepby1.x, &results[j], e, depth+1)){\r\n        j++;\r\n        results = mpc_grow_results(i, j, results_stk, results);\r\n\r\n        while (\r\n          mpc_parse_run(i, p->data.sepby1.sep, &results[j], e, depth+1) &&\r\n          mpc_parse_run(i, p->data.sepby1.x, &results[j], e, depth+1)\r\n        ) {\r\n          j++;\r\n          results = mpc_grow_results(i, j, results_stk, results);\r\n        }\r\n      }\r\n\r\n      if (j == 0) {\r\n        MPC_FAILURE(\r\n          mpc_err_many1(i, results[j].error);\r\n          if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n      } else {\r\n        *e = mpc_err_merge(i, *e, results[j].error);\r\n\r\n        MPC_SUCCESS(\r\n          mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results);\r\n          if (j >= MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n      }\r\n\r\n    case MPC_TYPE_COUNT:\r\n\r\n      results = p->data.repeat.n > MPC_PARSE_STACK_MIN\r\n        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.repeat.n)\r\n        : results_stk;\r\n\r\n      while (mpc_parse_run(i, p->data.repeat.x, &results[j], e, depth+1)) {\r\n        j++;\r\n        if (j == p->data.repeat.n) { break; }\r\n      }\r\n\r\n      if (j == p->data.repeat.n) {\r\n        MPC_SUCCESS(\r\n          mpc_parse_fold(i, p->data.repeat.f, j, (mpc_val_t**)results);\r\n          if (p->data.repeat.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n      } else {\r\n        for (k = 0; k < j; k++) {\r\n          mpc_parse_dtor(i, p->data.repeat.dx, results[k].output);\r\n        }\r\n        MPC_FAILURE(\r\n          mpc_err_count(i, results[j].error, p->data.repeat.n);\r\n          if (p->data.repeat.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n      }\r\n\r\n    /* Combinatory Parsers */\r\n\r\n    case MPC_TYPE_OR:\r\n\r\n      if (p->data.or.n == 0) { MPC_SUCCESS(NULL); }\r\n\r\n      results = p->data.or.n > MPC_PARSE_STACK_MIN\r\n        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.or.n)\r\n        : results_stk;\r\n\r\n      for (j = 0; j < p->data.or.n; j++) {\r\n        if (mpc_parse_run(i, p->data.or.xs[j], &results[j], e, depth+1)) {\r\n          MPC_SUCCESS(results[j].output;\r\n            if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n        } else {\r\n          *e = mpc_err_merge(i, *e, results[j].error);\r\n        }\r\n      }\r\n\r\n      MPC_FAILURE(NULL;\r\n        if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n\r\n    case MPC_TYPE_AND:\r\n      if (p->data.and.n == 0) { MPC_SUCCESS(NULL); }\r\n\r\n      results = p->data.or.n > MPC_PARSE_STACK_MIN\r\n        ? mpc_malloc(i, sizeof(mpc_result_t) * p->data.or.n)\r\n        : results_stk;\r\n\r\n      mpc_input_mark(i);\r\n      for (j = 0; j < p->data.and.n; j++) {\r\n        if (!mpc_parse_run(i, p->data.and.xs[j], &results[j], e, depth+1)) {\r\n          mpc_input_rewind(i);\r\n          for (k = 0; k < j; k++) {\r\n            mpc_parse_dtor(i, p->data.and.dxs[k], results[k].output);\r\n          }\r\n          MPC_FAILURE(results[j].error;\r\n            if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n        }\r\n      }\r\n      mpc_input_unmark(i);\r\n      MPC_SUCCESS(\r\n        mpc_parse_fold(i, p->data.and.f, j, (mpc_val_t**)results);\r\n        if (p->data.or.n > MPC_PARSE_STACK_MIN) { mpc_free(i, results); });\r\n\r\n    /* End */\r\n\r\n    default:\r\n\r\n      MPC_FAILURE(mpc_err_fail(i, \"Unknown Parser Type Id!\"));\r\n  }\r\n\r\n  return 0;\r\n\r\n}\r\n\r\n#undef MPC_SUCCESS\r\n#undef MPC_FAILURE\r\n#undef MPC_PRIMITIVE\r\n\r\nint mpc_parse_input(mpc_input_t *i, mpc_parser_t *p, mpc_result_t *r) {\r\n  int x;\r\n  mpc_err_t *e = mpc_err_fail(i, \"Unknown Error\");\r\n  e->state = mpc_state_invalid();\r\n  x = mpc_parse_run(i, p, r, &e, 0);\r\n  if (x) {\r\n    mpc_err_delete_internal(i, e);\r\n    r->output = mpc_export(i, r->output);\r\n  } else {\r\n    r->error = mpc_err_export(i, mpc_err_merge(i, e, r->error));\r\n  }\r\n  return x;\r\n}\r\n\r\nint mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r) {\r\n  int x;\r\n  mpc_input_t *i = mpc_input_new_string(filename, string);\r\n  x = mpc_parse_input(i, p, r);\r\n  mpc_input_delete(i);\r\n  return x;\r\n}\r\n\r\nint mpc_nparse(const char *filename, const char *string, size_t length, mpc_parser_t *p, mpc_result_t *r) {\r\n  int x;\r\n  mpc_input_t *i = mpc_input_new_nstring(filename, string, length);\r\n  x = mpc_parse_input(i, p, r);\r\n  mpc_input_delete(i);\r\n  return x;\r\n}\r\n\r\nint mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r) {\r\n  int x;\r\n  mpc_input_t *i = mpc_input_new_file(filename, file);\r\n  x = mpc_parse_input(i, p, r);\r\n  mpc_input_delete(i);\r\n  return x;\r\n}\r\n\r\nint mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r) {\r\n  int x;\r\n  mpc_input_t *i = mpc_input_new_pipe(filename, pipe);\r\n  x = mpc_parse_input(i, p, r);\r\n  mpc_input_delete(i);\r\n  return x;\r\n}\r\n\r\nint mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r) {\r\n\r\n  FILE *f = fopen(filename, \"rb\");\r\n  int res;\r\n\r\n  if (f == NULL) {\r\n    r->output = NULL;\r\n    r->error = mpc_err_file(filename, \"Unable to open file!\");\r\n    return 0;\r\n  }\r\n\r\n  res = mpc_parse_file(filename, f, p, r);\r\n  fclose(f);\r\n  return res;\r\n}\r\n\r\n/*\r\n** Building a Parser\r\n*/\r\n\r\nstatic void mpc_undefine_unretained(mpc_parser_t *p, int force);\r\n\r\nstatic void mpc_undefine_or(mpc_parser_t *p) {\r\n\r\n  int i;\r\n  for (i = 0; i < p->data.or.n; i++) {\r\n    mpc_undefine_unretained(p->data.or.xs[i], 0);\r\n  }\r\n  free(p->data.or.xs);\r\n\r\n}\r\n\r\nstatic void mpc_undefine_and(mpc_parser_t *p) {\r\n\r\n  int i;\r\n  for (i = 0; i < p->data.and.n; i++) {\r\n    mpc_undefine_unretained(p->data.and.xs[i], 0);\r\n  }\r\n  free(p->data.and.xs);\r\n  free(p->data.and.dxs);\r\n\r\n}\r\n\r\nstatic void mpc_undefine_unretained(mpc_parser_t *p, int force) {\r\n\r\n  if (p->retained && !force) { return; }\r\n\r\n  switch (p->type) {\r\n\r\n    case MPC_TYPE_FAIL: free(p->data.fail.m); break;\r\n\r\n    case MPC_TYPE_ONEOF:\r\n    case MPC_TYPE_NONEOF:\r\n    case MPC_TYPE_STRING:\r\n      free(p->data.string.x);\r\n      break;\r\n\r\n    case MPC_TYPE_APPLY:    mpc_undefine_unretained(p->data.apply.x, 0);    break;\r\n    case MPC_TYPE_APPLY_TO: mpc_undefine_unretained(p->data.apply_to.x, 0); break;\r\n    case MPC_TYPE_PREDICT:  mpc_undefine_unretained(p->data.predict.x, 0);  break;\r\n\r\n    case MPC_TYPE_MAYBE:\r\n    case MPC_TYPE_NOT:\r\n      mpc_undefine_unretained(p->data.not.x, 0);\r\n      break;\r\n\r\n    case MPC_TYPE_EXPECT:\r\n      mpc_undefine_unretained(p->data.expect.x, 0);\r\n      free(p->data.expect.m);\r\n      break;\r\n\r\n    case MPC_TYPE_MANY:\r\n    case MPC_TYPE_MANY1:\r\n    case MPC_TYPE_COUNT:\r\n      mpc_undefine_unretained(p->data.repeat.x, 0);\r\n      break;\r\n\r\n    case MPC_TYPE_SEPBY1:\r\n      mpc_undefine_unretained(p->data.sepby1.x, 0);\r\n      mpc_undefine_unretained(p->data.sepby1.sep, 0);\r\n      break;\r\n\r\n    case MPC_TYPE_OR:  mpc_undefine_or(p);  break;\r\n    case MPC_TYPE_AND: mpc_undefine_and(p); break;\r\n\r\n    case MPC_TYPE_CHECK:\r\n      mpc_undefine_unretained(p->data.check.x, 0);\r\n      free(p->data.check.e);\r\n      break;\r\n\r\n    case MPC_TYPE_CHECK_WITH:\r\n      mpc_undefine_unretained(p->data.check_with.x, 0);\r\n      free(p->data.check_with.e);\r\n      break;\r\n\r\n    default: break;\r\n  }\r\n\r\n  if (!force) {\r\n    free(p->name);\r\n    free(p);\r\n  }\r\n\r\n}\r\n\r\nvoid mpc_delete(mpc_parser_t *p) {\r\n  if (p->retained) {\r\n\r\n    if (p->type != MPC_TYPE_UNDEFINED) {\r\n      mpc_undefine_unretained(p, 0);\r\n    }\r\n\r\n    free(p->name);\r\n    free(p);\r\n\r\n  } else {\r\n    mpc_undefine_unretained(p, 0);\r\n  }\r\n}\r\n\r\nstatic void mpc_soft_delete(mpc_val_t *x) {\r\n  mpc_undefine_unretained(x, 0);\r\n}\r\n\r\nstatic mpc_parser_t *mpc_undefined(void) {\r\n  mpc_parser_t *p = calloc(1, sizeof(mpc_parser_t));\r\n  p->retained = 0;\r\n  p->type = MPC_TYPE_UNDEFINED;\r\n  p->name = NULL;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_new(const char *name) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->retained = 1;\r\n  p->name = realloc(p->name, strlen(name) + 1);\r\n  strcpy(p->name, name);\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_copy(mpc_parser_t *a) {\r\n  int i = 0;\r\n  mpc_parser_t *p;\r\n\r\n  if (a->retained) { return a; }\r\n\r\n  p = mpc_undefined();\r\n  p->retained = a->retained;\r\n  p->type = a->type;\r\n  p->data = a->data;\r\n\r\n  if (a->name) {\r\n    p->name = malloc(strlen(a->name)+1);\r\n    strcpy(p->name, a->name);\r\n  }\r\n\r\n  switch (a->type) {\r\n\r\n    case MPC_TYPE_FAIL:\r\n      p->data.fail.m = malloc(strlen(a->data.fail.m)+1);\r\n      strcpy(p->data.fail.m, a->data.fail.m);\r\n    break;\r\n\r\n    case MPC_TYPE_ONEOF:\r\n    case MPC_TYPE_NONEOF:\r\n    case MPC_TYPE_STRING:\r\n      p->data.string.x = malloc(strlen(a->data.string.x)+1);\r\n      strcpy(p->data.string.x, a->data.string.x);\r\n      break;\r\n\r\n    case MPC_TYPE_APPLY:    p->data.apply.x    = mpc_copy(a->data.apply.x);    break;\r\n    case MPC_TYPE_APPLY_TO: p->data.apply_to.x = mpc_copy(a->data.apply_to.x); break;\r\n    case MPC_TYPE_PREDICT:  p->data.predict.x  = mpc_copy(a->data.predict.x);  break;\r\n\r\n    case MPC_TYPE_MAYBE:\r\n    case MPC_TYPE_NOT:\r\n      p->data.not.x = mpc_copy(a->data.not.x);\r\n      break;\r\n\r\n    case MPC_TYPE_EXPECT:\r\n      p->data.expect.x = mpc_copy(a->data.expect.x);\r\n      p->data.expect.m = malloc(strlen(a->data.expect.m)+1);\r\n      strcpy(p->data.expect.m, a->data.expect.m);\r\n      break;\r\n\r\n    case MPC_TYPE_MANY:\r\n    case MPC_TYPE_MANY1:\r\n    case MPC_TYPE_COUNT:\r\n      p->data.repeat.x = mpc_copy(a->data.repeat.x);\r\n      break;\r\n\r\n    case MPC_TYPE_SEPBY1:\r\n      p->data.sepby1.x   = mpc_copy(a->data.sepby1.x);\r\n      p->data.sepby1.sep = mpc_copy(a->data.sepby1.sep);\r\n      break;\r\n\r\n    case MPC_TYPE_OR:\r\n      p->data.or.xs = malloc(a->data.or.n * sizeof(mpc_parser_t*));\r\n      for (i = 0; i < a->data.or.n; i++) {\r\n        p->data.or.xs[i] = mpc_copy(a->data.or.xs[i]);\r\n      }\r\n    break;\r\n    case MPC_TYPE_AND:\r\n      p->data.and.xs = malloc(a->data.and.n * sizeof(mpc_parser_t*));\r\n      for (i = 0; i < a->data.and.n; i++) {\r\n        p->data.and.xs[i] = mpc_copy(a->data.and.xs[i]);\r\n      }\r\n      p->data.and.dxs = malloc((a->data.and.n-1) * sizeof(mpc_dtor_t));\r\n      for (i = 0; i < a->data.and.n-1; i++) {\r\n        p->data.and.dxs[i] = a->data.and.dxs[i];\r\n      }\r\n    break;\r\n\r\n    case MPC_TYPE_CHECK:\r\n      p->data.check.x      = mpc_copy(a->data.check.x);\r\n      p->data.check.e      = malloc(strlen(a->data.check.e)+1);\r\n      strcpy(p->data.check.e, a->data.check.e);\r\n      break;\r\n    case MPC_TYPE_CHECK_WITH:\r\n      p->data.check_with.x = mpc_copy(a->data.check_with.x);\r\n      p->data.check_with.e = malloc(strlen(a->data.check_with.e)+1);\r\n      strcpy(p->data.check_with.e, a->data.check_with.e);\r\n      break;\r\n\r\n    default: break;\r\n  }\r\n\r\n\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_undefine(mpc_parser_t *p) {\r\n  mpc_undefine_unretained(p, 1);\r\n  p->type = MPC_TYPE_UNDEFINED;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a) {\r\n\r\n  if (p->retained) {\r\n    p->type = a->type;\r\n    p->data = a->data;\r\n  } else {\r\n    mpc_parser_t *a2 = mpc_failf(\"Attempt to assign to Unretained Parser!\");\r\n    p->type = a2->type;\r\n    p->data = a2->data;\r\n    free(a2);\r\n  }\r\n\r\n  free(a);\r\n  return p;\r\n}\r\n\r\nvoid mpc_cleanup(int n, ...) {\r\n  int i;\r\n  mpc_parser_t **list = malloc(sizeof(mpc_parser_t*) * n);\r\n\r\n  va_list va;\r\n  va_start(va, n);\r\n  for (i = 0; i < n; i++) { list[i] = va_arg(va, mpc_parser_t*); }\r\n  for (i = 0; i < n; i++) { mpc_undefine(list[i]); }\r\n  for (i = 0; i < n; i++) { mpc_delete(list[i]); }\r\n  va_end(va);\r\n\r\n  free(list);\r\n}\r\n\r\nmpc_parser_t *mpc_pass(void) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_PASS;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_fail(const char *m) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_FAIL;\r\n  p->data.fail.m = malloc(strlen(m) + 1);\r\n  strcpy(p->data.fail.m, m);\r\n  return p;\r\n}\r\n\r\n/*\r\n** As `snprintf` is not ANSI standard this\r\n** function `mpc_failf` should be considered\r\n** unsafe.\r\n**\r\n** You have a few options if this is going to be\r\n** trouble.\r\n**\r\n** - Ensure the format string does not exceed\r\n**   the buffer length using precision specifiers\r\n**   such as `%.512s`.\r\n**\r\n** - Patch this function in your code base to\r\n**   use `snprintf` or whatever variant your\r\n**   system supports.\r\n**\r\n** - Avoid it altogether.\r\n**\r\n*/\r\n\r\nmpc_parser_t *mpc_failf(const char *fmt, ...) {\r\n\r\n  va_list va;\r\n  char *buffer;\r\n\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_FAIL;\r\n\r\n  va_start(va, fmt);\r\n  buffer = malloc(2048);\r\n  if (!buffer) {\r\n    return NULL;\r\n  }\r\n  vsprintf(buffer, fmt, va);\r\n  va_end(va);\r\n\r\n  buffer = realloc(buffer, strlen(buffer) + 1);\r\n  p->data.fail.m = buffer;\r\n  return p;\r\n\r\n}\r\n\r\nmpc_parser_t *mpc_lift_val(mpc_val_t *x) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_LIFT_VAL;\r\n  p->data.lift.x = x;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_lift(mpc_ctor_t lf) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_LIFT;\r\n  p->data.lift.lf = lf;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_anchor(int(*f)(char,char)) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_ANCHOR;\r\n  p->data.anchor.f = f;\r\n  return mpc_expect(p, \"anchor\");\r\n}\r\n\r\nmpc_parser_t *mpc_state(void) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_STATE;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_expect(mpc_parser_t *a, const char *expected) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_EXPECT;\r\n  p->data.expect.x = a;\r\n  p->data.expect.m = malloc(strlen(expected) + 1);\r\n  strcpy(p->data.expect.m, expected);\r\n  return p;\r\n}\r\n\r\n/*\r\n** As `snprintf` is not ANSI standard this\r\n** function `mpc_expectf` should be considered\r\n** unsafe.\r\n**\r\n** You have a few options if this is going to be\r\n** trouble.\r\n**\r\n** - Ensure the format string does not exceed\r\n**   the buffer length using precision specifiers\r\n**   such as `%.512s`.\r\n**\r\n** - Patch this function in your code base to\r\n**   use `snprintf` or whatever variant your\r\n**   system supports.\r\n**\r\n** - Avoid it altogether.\r\n**\r\n*/\r\n\r\nmpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...) {\r\n  va_list va;\r\n  char *buffer;\r\n\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_EXPECT;\r\n\r\n  va_start(va, fmt);\r\n  buffer = malloc(2048);\r\n  if (!buffer) {\r\n    return NULL;\r\n  }\r\n  vsprintf(buffer, fmt, va);\r\n  va_end(va);\r\n\r\n  buffer = realloc(buffer, strlen(buffer) + 1);\r\n  p->data.expect.x = a;\r\n  p->data.expect.m = buffer;\r\n  return p;\r\n}\r\n\r\n/*\r\n** Basic Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_any(void) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_ANY;\r\n  return mpc_expect(p, \"any character\");\r\n}\r\n\r\nmpc_parser_t *mpc_char(char c) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_SINGLE;\r\n  p->data.single.x = c;\r\n  return mpc_expectf(p, \"'%c'\", c);\r\n}\r\n\r\nmpc_parser_t *mpc_range(char s, char e) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_RANGE;\r\n  p->data.range.x = s;\r\n  p->data.range.y = e;\r\n  return mpc_expectf(p, \"character between '%c' and '%c'\", s, e);\r\n}\r\n\r\nmpc_parser_t *mpc_oneof(const char *s) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_ONEOF;\r\n  p->data.string.x = malloc(strlen(s) + 1);\r\n  strcpy(p->data.string.x, s);\r\n  return mpc_expectf(p, \"one of '%s'\", s);\r\n}\r\n\r\nmpc_parser_t *mpc_noneof(const char *s) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_NONEOF;\r\n  p->data.string.x = malloc(strlen(s) + 1);\r\n  strcpy(p->data.string.x, s);\r\n  return mpc_expectf(p, \"none of '%s'\", s);\r\n\r\n}\r\n\r\nmpc_parser_t *mpc_satisfy(int(*f)(char)) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_SATISFY;\r\n  p->data.satisfy.f = f;\r\n  return mpc_expectf(p, \"character satisfying function %p\", f);\r\n}\r\n\r\nmpc_parser_t *mpc_string(const char *s) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_STRING;\r\n  p->data.string.x = malloc(strlen(s) + 1);\r\n  strcpy(p->data.string.x, s);\r\n  return mpc_expectf(p, \"\\\"%s\\\"\", s);\r\n}\r\n\r\n/*\r\n** Core Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_APPLY;\r\n  p->data.apply.x = a;\r\n  p->data.apply.f = f;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_APPLY_TO;\r\n  p->data.apply_to.x = a;\r\n  p->data.apply_to.f = f;\r\n  p->data.apply_to.d = x;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_check(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *e) {\r\n  mpc_parser_t  *p = mpc_undefined();\r\n  p->type = MPC_TYPE_CHECK;\r\n  p->data.check.x = a;\r\n  p->data.check.dx = da;\r\n  p->data.check.f = f;\r\n  p->data.check.e = malloc(strlen(e) + 1);\r\n  strcpy(p->data.check.e, e);\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_check_with(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *e) {\r\n  mpc_parser_t  *p = mpc_undefined();\r\n  p->type = MPC_TYPE_CHECK_WITH;\r\n  p->data.check_with.x = a;\r\n  p->data.check_with.dx = da;\r\n  p->data.check_with.f = f;\r\n  p->data.check_with.d = x;\r\n  p->data.check_with.e = malloc(strlen(e) + 1);\r\n  strcpy(p->data.check_with.e, e);\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_checkf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *fmt, ...) {\r\n  va_list va;\r\n  char *buffer;\r\n  mpc_parser_t *p;\r\n\r\n  va_start(va, fmt);\r\n  buffer = malloc(2048);\r\n  vsprintf(buffer, fmt, va);\r\n  va_end(va);\r\n\r\n  p = mpc_check(a, da, f, buffer);\r\n  free(buffer);\r\n\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_check_withf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *fmt, ...) {\r\n  va_list va;\r\n  char *buffer;\r\n  mpc_parser_t *p;\r\n\r\n  va_start(va, fmt);\r\n  buffer = malloc(2048);\r\n  vsprintf(buffer, fmt, va);\r\n  va_end(va);\r\n\r\n  p = mpc_check_with(a, da, f, x, buffer);\r\n  free(buffer);\r\n\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_predictive(mpc_parser_t *a) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_PREDICT;\r\n  p->data.predict.x = a;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_NOT;\r\n  p->data.not.x = a;\r\n  p->data.not.dx = da;\r\n  p->data.not.lf = lf;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da) {\r\n  return mpc_not_lift(a, da, mpcf_ctor_null);\r\n}\r\n\r\nmpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_MAYBE;\r\n  p->data.not.x = a;\r\n  p->data.not.lf = lf;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_maybe(mpc_parser_t *a) {\r\n  return mpc_maybe_lift(a, mpcf_ctor_null);\r\n}\r\n\r\nmpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_MANY;\r\n  p->data.repeat.x = a;\r\n  p->data.repeat.f = f;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_MANY1;\r\n  p->data.repeat.x = a;\r\n  p->data.repeat.f = f;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_COUNT;\r\n  p->data.repeat.n = n;\r\n  p->data.repeat.f = f;\r\n  p->data.repeat.x = a;\r\n  p->data.repeat.dx = da;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_sepby1(mpc_fold_t f, mpc_parser_t *sep, mpc_parser_t *a) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_SEPBY1;\r\n  p->data.sepby1.x   = a;\r\n  p->data.sepby1.f   = f;\r\n  p->data.sepby1.sep = sep;\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_or(int n, ...) {\r\n\r\n  int i;\r\n  va_list va;\r\n\r\n  mpc_parser_t *p = mpc_undefined();\r\n\r\n  p->type = MPC_TYPE_OR;\r\n  p->data.or.n = n;\r\n  p->data.or.xs = malloc(sizeof(mpc_parser_t*) * n);\r\n\r\n  va_start(va, n);\r\n  for (i = 0; i < n; i++) {\r\n    p->data.or.xs[i] = va_arg(va, mpc_parser_t*);\r\n  }\r\n  va_end(va);\r\n\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpc_and(int n, mpc_fold_t f, ...) {\r\n\r\n  int i;\r\n  va_list va;\r\n\r\n  mpc_parser_t *p = mpc_undefined();\r\n\r\n  p->type = MPC_TYPE_AND;\r\n  p->data.and.n = n;\r\n  p->data.and.f = f;\r\n  p->data.and.xs = malloc(sizeof(mpc_parser_t*) * n);\r\n  p->data.and.dxs = malloc(sizeof(mpc_dtor_t) * (n-1));\r\n\r\n  va_start(va, f);\r\n  for (i = 0; i < n; i++) {\r\n    p->data.and.xs[i] = va_arg(va, mpc_parser_t*);\r\n  }\r\n  for (i = 0; i < (n-1); i++) {\r\n    p->data.and.dxs[i] = va_arg(va, mpc_dtor_t);\r\n  }\r\n  va_end(va);\r\n\r\n  return p;\r\n}\r\n\r\n/*\r\n** Common Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_soi(void) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_SOI;\r\n  return mpc_expect(p, \"start of input\");\r\n}\r\n\r\nmpc_parser_t *mpc_eoi(void) {\r\n  mpc_parser_t *p = mpc_undefined();\r\n  p->type = MPC_TYPE_EOI;\r\n  return mpc_expect(p, \"end of input\");\r\n}\r\n\r\nstatic int mpc_boundary_anchor(char prev, char next) {\r\n  const char* word = \"abcdefghijklmnopqrstuvwxyz\"\r\n                     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n                     \"0123456789_\";\r\n  if ( strchr(word, next) &&  prev == '\\0') { return 1; }\r\n  if ( strchr(word, prev) &&  next == '\\0') { return 1; }\r\n  if ( strchr(word, next) && !strchr(word, prev)) { return 1; }\r\n  if (!strchr(word, next) &&  strchr(word, prev)) { return 1; }\r\n  return 0;\r\n}\r\n\r\nstatic int mpc_boundary_newline_anchor(char prev, char next) {\r\n  (void)next;\r\n  return prev == '\\n';\r\n}\r\n\r\nmpc_parser_t *mpc_boundary(void) { return mpc_expect(mpc_anchor(mpc_boundary_anchor), \"word boundary\"); }\r\nmpc_parser_t *mpc_boundary_newline(void) { return mpc_expect(mpc_anchor(mpc_boundary_newline_anchor), \"start of newline\"); }\r\n\r\nmpc_parser_t *mpc_whitespace(void) { return mpc_expect(mpc_oneof(\" \\f\\n\\r\\t\\v\"), \"whitespace\"); }\r\nmpc_parser_t *mpc_whitespaces(void) { return mpc_expect(mpc_many(mpcf_strfold, mpc_whitespace()), \"spaces\"); }\r\nmpc_parser_t *mpc_blank(void) { return mpc_expect(mpc_apply(mpc_whitespaces(), mpcf_free), \"whitespace\"); }\r\n\r\nmpc_parser_t *mpc_newline(void) { return mpc_expect(mpc_char('\\n'), \"newline\"); }\r\nmpc_parser_t *mpc_tab(void) { return mpc_expect(mpc_char('\\t'), \"tab\"); }\r\nmpc_parser_t *mpc_escape(void) { return mpc_and(2, mpcf_strfold, mpc_char('\\\\'), mpc_any(), free); }\r\n\r\nmpc_parser_t *mpc_digit(void) { return mpc_expect(mpc_oneof(\"0123456789\"), \"digit\"); }\r\nmpc_parser_t *mpc_hexdigit(void) { return mpc_expect(mpc_oneof(\"0123456789ABCDEFabcdef\"), \"hex digit\"); }\r\nmpc_parser_t *mpc_octdigit(void) { return mpc_expect(mpc_oneof(\"01234567\"), \"oct digit\"); }\r\nmpc_parser_t *mpc_digits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_digit()), \"digits\"); }\r\nmpc_parser_t *mpc_hexdigits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_hexdigit()), \"hex digits\"); }\r\nmpc_parser_t *mpc_octdigits(void) { return mpc_expect(mpc_many1(mpcf_strfold, mpc_octdigit()), \"oct digits\"); }\r\n\r\nmpc_parser_t *mpc_lower(void) { return mpc_expect(mpc_oneof(\"abcdefghijklmnopqrstuvwxyz\"), \"lowercase letter\"); }\r\nmpc_parser_t *mpc_upper(void) { return mpc_expect(mpc_oneof(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"uppercase letter\"); }\r\nmpc_parser_t *mpc_alpha(void) { return mpc_expect(mpc_oneof(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"), \"letter\"); }\r\nmpc_parser_t *mpc_underscore(void) { return mpc_expect(mpc_char('_'), \"underscore\"); }\r\nmpc_parser_t *mpc_alphanum(void) { return mpc_expect(mpc_or(3, mpc_alpha(), mpc_digit(), mpc_underscore()), \"alphanumeric\"); }\r\n\r\nmpc_parser_t *mpc_int(void) { return mpc_expect(mpc_apply(mpc_digits(), mpcf_int), \"integer\"); }\r\nmpc_parser_t *mpc_hex(void) { return mpc_expect(mpc_apply(mpc_hexdigits(), mpcf_hex), \"hexadecimal\"); }\r\nmpc_parser_t *mpc_oct(void) { return mpc_expect(mpc_apply(mpc_octdigits(), mpcf_oct), \"octadecimal\"); }\r\nmpc_parser_t *mpc_number(void) { return mpc_expect(mpc_or(3, mpc_int(), mpc_hex(), mpc_oct()), \"number\"); }\r\n\r\nmpc_parser_t *mpc_real(void) {\r\n\r\n  /* [+-]?\\d+(\\.\\d+)?([eE][+-]?[0-9]+)? */\r\n\r\n  mpc_parser_t *p0, *p1, *p2, *p30, *p31, *p32, *p3;\r\n\r\n  p0 = mpc_maybe_lift(mpc_oneof(\"+-\"), mpcf_ctor_str);\r\n  p1 = mpc_digits();\r\n  p2 = mpc_maybe_lift(mpc_and(2, mpcf_strfold, mpc_char('.'), mpc_digits(), free), mpcf_ctor_str);\r\n  p30 = mpc_oneof(\"eE\");\r\n  p31 = mpc_maybe_lift(mpc_oneof(\"+-\"), mpcf_ctor_str);\r\n  p32 = mpc_digits();\r\n  p3 = mpc_maybe_lift(mpc_and(3, mpcf_strfold, p30, p31, p32, free, free), mpcf_ctor_str);\r\n\r\n  return mpc_expect(mpc_and(4, mpcf_strfold, p0, p1, p2, p3, free, free, free), \"real\");\r\n\r\n}\r\n\r\nmpc_parser_t *mpc_float(void) {\r\n  return mpc_expect(mpc_apply(mpc_real(), mpcf_float), \"float\");\r\n}\r\n\r\nmpc_parser_t *mpc_char_lit(void) {\r\n  return mpc_expect(mpc_between(mpc_or(2, mpc_escape(), mpc_any()), free, \"'\", \"'\"), \"char\");\r\n}\r\n\r\nmpc_parser_t *mpc_string_lit(void) {\r\n  mpc_parser_t *strchar = mpc_or(2, mpc_escape(), mpc_noneof(\"\\\"\"));\r\n  return mpc_expect(mpc_between(mpc_many(mpcf_strfold, strchar), free, \"\\\"\", \"\\\"\"), \"string\");\r\n}\r\n\r\nmpc_parser_t *mpc_regex_lit(void) {\r\n  mpc_parser_t *regexchar = mpc_or(2, mpc_escape(), mpc_noneof(\"/\"));\r\n  return mpc_expect(mpc_between(mpc_many(mpcf_strfold, regexchar), free, \"/\", \"/\"), \"regex\");\r\n}\r\n\r\nmpc_parser_t *mpc_ident(void) {\r\n  mpc_parser_t *p0, *p1;\r\n  p0 = mpc_or(2, mpc_alpha(), mpc_underscore());\r\n  p1 = mpc_many(mpcf_strfold, mpc_alphanum());\r\n  return mpc_and(2, mpcf_strfold, p0, p1, free);\r\n}\r\n\r\n/*\r\n** Useful Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_startwith(mpc_parser_t *a) { return mpc_and(2, mpcf_snd, mpc_soi(), a, mpcf_dtor_null); }\r\nmpc_parser_t *mpc_endwith(mpc_parser_t *a, mpc_dtor_t da) { return mpc_and(2, mpcf_fst, a, mpc_eoi(), da); }\r\nmpc_parser_t *mpc_whole(mpc_parser_t *a, mpc_dtor_t da) { return mpc_and(3, mpcf_snd, mpc_soi(), a, mpc_eoi(), mpcf_dtor_null, da); }\r\n\r\nmpc_parser_t *mpc_stripl(mpc_parser_t *a) { return mpc_and(2, mpcf_snd, mpc_blank(), a, mpcf_dtor_null); }\r\nmpc_parser_t *mpc_stripr(mpc_parser_t *a) { return mpc_and(2, mpcf_fst, a, mpc_blank(), mpcf_dtor_null); }\r\nmpc_parser_t *mpc_strip(mpc_parser_t *a) { return mpc_and(3, mpcf_snd, mpc_blank(), a, mpc_blank(), mpcf_dtor_null, mpcf_dtor_null); }\r\nmpc_parser_t *mpc_tok(mpc_parser_t *a) { return mpc_and(2, mpcf_fst, a, mpc_blank(), mpcf_dtor_null); }\r\nmpc_parser_t *mpc_sym(const char *s) { return mpc_tok(mpc_string(s)); }\r\n\r\nmpc_parser_t *mpc_total(mpc_parser_t *a, mpc_dtor_t da) { return mpc_whole(mpc_strip(a), da); }\r\n\r\nmpc_parser_t *mpc_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c) {\r\n  return mpc_and(3, mpcf_snd_free,\r\n    mpc_string(o), a, mpc_string(c),\r\n    free, ad);\r\n}\r\n\r\nmpc_parser_t *mpc_parens(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_between(a, ad, \"(\", \")\"); }\r\nmpc_parser_t *mpc_braces(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_between(a, ad, \"<\", \">\"); }\r\nmpc_parser_t *mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad) { return mpc_between(a, ad, \"{\", \"}\"); }\r\nmpc_parser_t *mpc_squares(mpc_parser_t *a, mpc_dtor_t ad)  { return mpc_between(a, ad, \"[\", \"]\"); }\r\n\r\nmpc_parser_t *mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c) {\r\n  return mpc_and(3, mpcf_snd_free,\r\n    mpc_sym(o), mpc_tok(a), mpc_sym(c),\r\n    free, ad);\r\n}\r\n\r\nmpc_parser_t *mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_tok_between(a, ad, \"(\", \")\"); }\r\nmpc_parser_t *mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad)   { return mpc_tok_between(a, ad, \"<\", \">\"); }\r\nmpc_parser_t *mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad) { return mpc_tok_between(a, ad, \"{\", \"}\"); }\r\nmpc_parser_t *mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad)  { return mpc_tok_between(a, ad, \"[\", \"]\"); }\r\n\r\n/*\r\n** Regular Expression Parsers\r\n*/\r\n\r\n/*\r\n** So here is a cute bootstrapping.\r\n**\r\n** I'm using the previously defined\r\n** mpc constructs and functions to\r\n** parse the user regex string and\r\n** construct a parser from it.\r\n**\r\n** As it turns out lots of the standard\r\n** mpc functions look a lot like `fold`\r\n** functions and so can be used indirectly\r\n** by many of the parsing functions to build\r\n** a parser directly - as we are parsing.\r\n**\r\n** This is certainly something that\r\n** would be less elegant/interesting\r\n** in a two-phase parser which first\r\n** builds an AST and then traverses it\r\n** to generate the object.\r\n**\r\n** This whole thing acts as a great\r\n** case study for how trivial it can be\r\n** to write a great parser in a few\r\n** lines of code using mpc.\r\n*/\r\n\r\n/*\r\n**\r\n**  ### Regular Expression Grammar\r\n**\r\n**      <regex> : <term> | (<term> \"|\" <regex>)\r\n**\r\n**      <term> : <factor>*\r\n**\r\n**      <factor> : <base>\r\n**               | <base> \"*\"\r\n**               | <base> \"+\"\r\n**               | <base> \"?\"\r\n**               | <base> \"{\" <digits> \"}\"\r\n**\r\n**      <base> : <char>\r\n**             | \"\\\" <char>\r\n**             | \"(\" <regex> \")\"\r\n**             | \"[\" <range> \"]\"\r\n*/\r\n\r\nstatic mpc_val_t *mpcf_re_or(int n, mpc_val_t **xs) {\r\n  (void) n;\r\n  if (xs[1] == NULL) { return xs[0]; }\r\n  else { return mpc_or(2, xs[0], xs[1]); }\r\n}\r\n\r\nstatic mpc_val_t *mpcf_re_and(int n, mpc_val_t **xs) {\r\n  int i;\r\n  mpc_parser_t *p = mpc_lift(mpcf_ctor_str);\r\n  for (i = 0; i < n; i++) {\r\n    p = mpc_and(2, mpcf_strfold, p, xs[i], free);\r\n  }\r\n  return p;\r\n}\r\n\r\nstatic mpc_val_t *mpcf_re_repeat(int n, mpc_val_t **xs) {\r\n  int num;\r\n  (void) n;\r\n  if (xs[1] == NULL) { return xs[0]; }\r\n  switch(((char*)xs[1])[0])\r\n  {\r\n    case '*': { free(xs[1]); return mpc_many(mpcf_strfold, xs[0]); }; break;\r\n    case '+': { free(xs[1]); return mpc_many1(mpcf_strfold, xs[0]); }; break;\r\n    case '?': { free(xs[1]); return mpc_maybe_lift(xs[0], mpcf_ctor_str); }; break;\r\n    default:\r\n      num = *(int*)xs[1];\r\n      free(xs[1]);\r\n  }\r\n\r\n  return mpc_count(num, mpcf_strfold, xs[0], free);\r\n}\r\n\r\nstatic mpc_parser_t *mpc_re_escape_char(char c) {\r\n  switch (c) {\r\n    case 'a': return mpc_char('\\a');\r\n    case 'f': return mpc_char('\\f');\r\n    case 'n': return mpc_char('\\n');\r\n    case 'r': return mpc_char('\\r');\r\n    case 't': return mpc_char('\\t');\r\n    case 'v': return mpc_char('\\v');\r\n    case 'b': return mpc_and(2, mpcf_snd, mpc_boundary(), mpc_lift(mpcf_ctor_str), free);\r\n    case 'B': return mpc_not_lift(mpc_boundary(), free, mpcf_ctor_str);\r\n    case 'A': return mpc_and(2, mpcf_snd, mpc_soi(), mpc_lift(mpcf_ctor_str), free);\r\n    case 'Z': return mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free);\r\n    case 'd': return mpc_digit();\r\n    case 'D': return mpc_not_lift(mpc_digit(), free, mpcf_ctor_str);\r\n    case 's': return mpc_whitespace();\r\n    case 'S': return mpc_not_lift(mpc_whitespace(), free, mpcf_ctor_str);\r\n    case 'w': return mpc_alphanum();\r\n    case 'W': return mpc_not_lift(mpc_alphanum(), free, mpcf_ctor_str);\r\n    default: return NULL;\r\n  }\r\n}\r\n\r\nstatic mpc_val_t *mpcf_re_escape(mpc_val_t *x, void* data) {\r\n\r\n  int mode = *((int*)data);\r\n  char *s = x;\r\n  mpc_parser_t *p;\r\n\r\n  /* Any Character */\r\n  if (s[0] == '.') {\r\n    free(s);\r\n    if (mode & MPC_RE_DOTALL) {\r\n      return mpc_any();\r\n    } else {\r\n      return mpc_expect(mpc_noneof(\"\\n\"), \"any character except a newline\");\r\n    }\r\n  }\r\n\r\n  /* Start of Input */\r\n  if (s[0] == '^') {\r\n    free(s);\r\n    if (mode & MPC_RE_MULTILINE) {\r\n      return mpc_and(2, mpcf_snd, mpc_or(2, mpc_soi(), mpc_boundary_newline()), mpc_lift(mpcf_ctor_str), free);\r\n    } else {\r\n      return mpc_and(2, mpcf_snd, mpc_soi(), mpc_lift(mpcf_ctor_str), free);\r\n    }\r\n  }\r\n\r\n  /* End of Input */\r\n  if (s[0] == '$') {\r\n    free(s);\r\n    if (mode & MPC_RE_MULTILINE) {\r\n      return mpc_or(2,\r\n        mpc_newline(),\r\n        mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free));\r\n    } else {\r\n      return mpc_or(2,\r\n        mpc_and(2, mpcf_fst, mpc_newline(), mpc_eoi(), free),\r\n        mpc_and(2, mpcf_snd, mpc_eoi(), mpc_lift(mpcf_ctor_str), free));\r\n    }\r\n  }\r\n\r\n  /* Regex Escape */\r\n  if (s[0] == '\\\\') {\r\n    p = mpc_re_escape_char(s[1]);\r\n    p = (p == NULL) ? mpc_char(s[1]) : p;\r\n    free(s);\r\n    return p;\r\n  }\r\n\r\n  /* Regex Standard */\r\n  p = mpc_char(s[0]);\r\n  free(s);\r\n  return p;\r\n}\r\n\r\nstatic const char *mpc_re_range_escape_char(char c) {\r\n  switch (c) {\r\n    case '-': return \"-\";\r\n    case 'a': return \"\\a\";\r\n    case 'f': return \"\\f\";\r\n    case 'n': return \"\\n\";\r\n    case 'r': return \"\\r\";\r\n    case 't': return \"\\t\";\r\n    case 'v': return \"\\v\";\r\n    case 'b': return \"\\b\";\r\n    case 'd': return \"0123456789\";\r\n    case 's': return \" \\f\\n\\r\\t\\v\";\r\n    case 'w': return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\r\n    default: return NULL;\r\n  }\r\n}\r\n\r\nstatic mpc_val_t *mpcf_re_range(mpc_val_t *x) {\r\n\r\n  mpc_parser_t *out;\r\n  size_t i, j;\r\n  size_t start, end;\r\n  const char *tmp = NULL;\r\n  const char *s = x;\r\n  int comp = s[0] == '^' ? 1 : 0;\r\n  char *range = calloc(1,1);\r\n\r\n  if (s[0] == '\\0') { free(range); free(x); return mpc_fail(\"Invalid Regex Range Expression\"); }\r\n  if (s[0] == '^' &&\r\n      s[1] == '\\0') { free(range); free(x); return mpc_fail(\"Invalid Regex Range Expression\"); }\r\n\r\n  for (i = comp; i < strlen(s); i++){\r\n\r\n    /* Regex Range Escape */\r\n    if (s[i] == '\\\\') {\r\n      tmp = mpc_re_range_escape_char(s[i+1]);\r\n      if (tmp != NULL) {\r\n        range = realloc(range, strlen(range) + strlen(tmp) + 1);\r\n        strcat(range, tmp);\r\n      } else {\r\n        range = realloc(range, strlen(range) + 1 + 1);\r\n        range[strlen(range) + 1] = '\\0';\r\n        range[strlen(range) + 0] = s[i+1];\r\n      }\r\n      i++;\r\n    }\r\n\r\n    /* Regex Range...Range */\r\n    else if (s[i] == '-') {\r\n      if (s[i+1] == '\\0' || i == 0) {\r\n          range = realloc(range, strlen(range) + strlen(\"-\") + 1);\r\n          strcat(range, \"-\");\r\n      } else {\r\n        start = s[i-1]+1;\r\n        end = s[i+1]-1;\r\n        for (j = start; j <= end; j++) {\r\n          range = realloc(range, strlen(range) + 1 + 1 + 1);\r\n          range[strlen(range) + 1] = '\\0';\r\n          range[strlen(range) + 0] = (char)j;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Regex Range Normal */\r\n    else {\r\n      range = realloc(range, strlen(range) + 1 + 1);\r\n      range[strlen(range) + 1] = '\\0';\r\n      range[strlen(range) + 0] = s[i];\r\n    }\r\n\r\n  }\r\n\r\n  out = comp == 1 ? mpc_noneof(range) : mpc_oneof(range);\r\n\r\n  free(x);\r\n  free(range);\r\n\r\n  return out;\r\n}\r\n\r\nmpc_parser_t *mpc_re(const char *re) {\r\n  return mpc_re_mode(re, MPC_RE_DEFAULT);\r\n}\r\n\r\nmpc_parser_t *mpc_re_mode(const char *re, int mode) {\r\n\r\n  char *err_msg;\r\n  mpc_parser_t *err_out;\r\n  mpc_result_t r;\r\n  mpc_parser_t *Regex, *Term, *Factor, *Base, *Range, *RegexEnclose;\r\n\r\n  Regex  = mpc_new(\"regex\");\r\n  Term   = mpc_new(\"term\");\r\n  Factor = mpc_new(\"factor\");\r\n  Base   = mpc_new(\"base\");\r\n  Range  = mpc_new(\"range\");\r\n\r\n  mpc_define(Regex, mpc_and(2, mpcf_re_or,\r\n    Term,\r\n    mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_char('|'), Regex, free)),\r\n    (mpc_dtor_t)mpc_delete\r\n  ));\r\n\r\n  mpc_define(Term, mpc_many(mpcf_re_and, Factor));\r\n\r\n  mpc_define(Factor, mpc_and(2, mpcf_re_repeat,\r\n    Base,\r\n    mpc_or(5,\r\n      mpc_char('*'), mpc_char('+'), mpc_char('?'),\r\n      mpc_brackets(mpc_int(), free),\r\n      mpc_pass()),\r\n    (mpc_dtor_t)mpc_delete\r\n  ));\r\n\r\n  mpc_define(Base, mpc_or(4,\r\n    mpc_parens(Regex, (mpc_dtor_t)mpc_delete),\r\n    mpc_squares(Range, (mpc_dtor_t)mpc_delete),\r\n    mpc_apply_to(mpc_escape(), mpcf_re_escape, &mode),\r\n    mpc_apply_to(mpc_noneof(\")|\"), mpcf_re_escape, &mode)\r\n  ));\r\n\r\n  mpc_define(Range, mpc_apply(\r\n    mpc_many(mpcf_strfold, mpc_or(2, mpc_escape(), mpc_noneof(\"]\"))),\r\n    mpcf_re_range\r\n  ));\r\n\r\n  RegexEnclose = mpc_whole(mpc_predictive(Regex), (mpc_dtor_t)mpc_delete);\r\n\r\n  mpc_optimise(RegexEnclose);\r\n  mpc_optimise(Regex);\r\n  mpc_optimise(Term);\r\n  mpc_optimise(Factor);\r\n  mpc_optimise(Base);\r\n  mpc_optimise(Range);\r\n\r\n  if(!mpc_parse(\"<mpc_re_compiler>\", re, RegexEnclose, &r)) {\r\n    err_msg = mpc_err_string(r.error);\r\n    err_out = mpc_failf(\"Invalid Regex: %s\", err_msg);\r\n    mpc_err_delete(r.error);\r\n    free(err_msg);\r\n    r.output = err_out;\r\n  }\r\n\r\n  mpc_cleanup(6, RegexEnclose, Regex, Term, Factor, Base, Range);\r\n\r\n  mpc_optimise(r.output);\r\n\r\n  return r.output;\r\n\r\n}\r\n\r\n/*\r\n** Common Fold Functions\r\n*/\r\n\r\nvoid mpcf_dtor_null(mpc_val_t *x) { (void) x; return; }\r\n\r\nmpc_val_t *mpcf_ctor_null(void) { return NULL; }\r\nmpc_val_t *mpcf_ctor_str(void) { return calloc(1, 1); }\r\nmpc_val_t *mpcf_free(mpc_val_t *x) { free(x); return NULL; }\r\n\r\nmpc_val_t *mpcf_int(mpc_val_t *x) {\r\n  int *y = malloc(sizeof(int));\r\n  *y = strtol(x, NULL, 10);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_hex(mpc_val_t *x) {\r\n  int *y = malloc(sizeof(int));\r\n  *y = strtol(x, NULL, 16);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_oct(mpc_val_t *x) {\r\n  int *y = malloc(sizeof(int));\r\n  *y = strtol(x, NULL, 8);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_float(mpc_val_t *x) {\r\n  float *y = malloc(sizeof(float));\r\n  *y = strtod(x, NULL);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_strtriml(mpc_val_t *x) {\r\n  char *s = x;\r\n  while (isspace((unsigned char)*s)) {\r\n    memmove(s, s+1, strlen(s));\r\n  }\r\n  return s;\r\n}\r\n\r\nmpc_val_t *mpcf_strtrimr(mpc_val_t *x) {\r\n  char *s = x;\r\n  size_t l = strlen(s);\r\n  while (l > 0 && isspace((unsigned char)s[l-1])) {\r\n    s[l-1] = '\\0'; l--;\r\n  }\r\n  return s;\r\n}\r\n\r\nmpc_val_t *mpcf_strtrim(mpc_val_t *x) {\r\n  return mpcf_strtriml(mpcf_strtrimr(x));\r\n}\r\n\r\nstatic const char mpc_escape_input_c[]  = {\r\n  '\\a', '\\b', '\\f', '\\n', '\\r',\r\n  '\\t', '\\v', '\\\\', '\\'', '\\\"', '\\0'};\r\n\r\nstatic const char *mpc_escape_output_c[] = {\r\n  \"\\\\a\", \"\\\\b\", \"\\\\f\", \"\\\\n\", \"\\\\r\", \"\\\\t\",\r\n  \"\\\\v\", \"\\\\\\\\\", \"\\\\'\", \"\\\\\\\"\", \"\\\\0\", NULL};\r\n\r\nstatic const char mpc_escape_input_raw_re[] = { '/' };\r\nstatic const char *mpc_escape_output_raw_re[] = { \"\\\\/\", NULL };\r\n\r\nstatic const char mpc_escape_input_raw_cstr[] = { '\"' };\r\nstatic const char *mpc_escape_output_raw_cstr[] = { \"\\\\\\\"\", NULL };\r\n\r\nstatic const char mpc_escape_input_raw_cchar[] = { '\\'' };\r\nstatic const char *mpc_escape_output_raw_cchar[] = { \"\\\\'\", NULL };\r\n\r\nstatic mpc_val_t *mpcf_escape_new(mpc_val_t *x, const char *input, const char **output) {\r\n\r\n  int i;\r\n  int found;\r\n  char buff[2];\r\n  char *s = x;\r\n  char *y = calloc(1, 1);\r\n\r\n  while (*s) {\r\n\r\n    i = 0;\r\n    found = 0;\r\n\r\n    while (output[i]) {\r\n      if (*s == input[i]) {\r\n        y = realloc(y, strlen(y) + strlen(output[i]) + 1);\r\n        strcat(y, output[i]);\r\n        found = 1;\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    if (!found) {\r\n      y = realloc(y, strlen(y) + 2);\r\n      buff[0] = *s; buff[1] = '\\0';\r\n      strcat(y, buff);\r\n    }\r\n\r\n    s++;\r\n  }\r\n\r\n\r\n  return y;\r\n}\r\n\r\nstatic mpc_val_t *mpcf_unescape_new(mpc_val_t *x, const char *input, const char **output) {\r\n\r\n  int i;\r\n  int found = 0;\r\n  char buff[2];\r\n  char *s = x;\r\n  char *y = calloc(1, 1);\r\n\r\n  while (*s) {\r\n\r\n    i = 0;\r\n    found = 0;\r\n\r\n    while (output[i]) {\r\n      if ((*(s+0)) == output[i][0] &&\r\n          (*(s+1)) == output[i][1]) {\r\n        y = realloc(y, strlen(y) + 1 + 1);\r\n        buff[0] = input[i]; buff[1] = '\\0';\r\n        strcat(y, buff);\r\n        found = 1;\r\n        s++;\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    if (!found) {\r\n      y = realloc(y, strlen(y) + 1 + 1);\r\n      buff[0] = *s; buff[1] = '\\0';\r\n      strcat(y, buff);\r\n    }\r\n\r\n    if (*s == '\\0') { break; }\r\n    else { s++; }\r\n  }\r\n\r\n  return y;\r\n\r\n}\r\n\r\nmpc_val_t *mpcf_escape(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_c, mpc_escape_output_c);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_unescape(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_c, mpc_escape_output_c);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_escape_regex(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_re, mpc_escape_output_raw_re);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_unescape_regex(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_re, mpc_escape_output_raw_re);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_escape_string_raw(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_cstr, mpc_escape_output_raw_cstr);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_cstr, mpc_escape_output_raw_cstr);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_escape_char_raw(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_escape_new(x, mpc_escape_input_raw_cchar, mpc_escape_output_raw_cchar);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x) {\r\n  mpc_val_t *y = mpcf_unescape_new(x, mpc_escape_input_raw_cchar, mpc_escape_output_raw_cchar);\r\n  free(x);\r\n  return y;\r\n}\r\n\r\nmpc_val_t *mpcf_null(int n, mpc_val_t** xs) { (void) n; (void) xs; return NULL; }\r\nmpc_val_t *mpcf_fst(int n, mpc_val_t **xs) { (void) n; return xs[0]; }\r\nmpc_val_t *mpcf_snd(int n, mpc_val_t **xs) { (void) n; return xs[1]; }\r\nmpc_val_t *mpcf_trd(int n, mpc_val_t **xs) { (void) n; return xs[2]; }\r\n\r\nstatic mpc_val_t *mpcf_nth_free(int n, mpc_val_t **xs, int x) {\r\n  int i;\r\n  for (i = 0; i < n; i++) {\r\n    if (i != x) { free(xs[i]); }\r\n  }\r\n  return xs[x];\r\n}\r\n\r\nmpc_val_t *mpcf_fst_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 0); }\r\nmpc_val_t *mpcf_snd_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 1); }\r\nmpc_val_t *mpcf_trd_free(int n, mpc_val_t **xs) { return mpcf_nth_free(n, xs, 2); }\r\nmpc_val_t *mpcf_all_free(int n, mpc_val_t** xs) {\r\n  int i;\r\n  for (i = 0; i < n; i++) {\r\n    free(xs[i]);\r\n  }\r\n  return NULL;\r\n}\r\n\r\nmpc_val_t *mpcf_strfold(int n, mpc_val_t **xs) {\r\n  int i;\r\n  size_t l = 0;\r\n\r\n  if (n == 0) { return calloc(1, 1); }\r\n\r\n  for (i = 0; i < n; i++) { l += strlen(xs[i]); }\r\n\r\n  xs[0] = realloc(xs[0], l + 1);\r\n\r\n  for (i = 1; i < n; i++) {\r\n    strcat(xs[0], xs[i]); free(xs[i]);\r\n  }\r\n\r\n  return xs[0];\r\n}\r\n\r\n/*\r\n** Printing\r\n*/\r\n\r\nstatic void mpc_print_unretained(mpc_parser_t *p, int force) {\r\n\r\n  /* TODO: Print Everything Escaped */\r\n\r\n  int i;\r\n  char *s, *e;\r\n  char buff[2];\r\n\r\n  if (p->retained && !force) {;\r\n    if (p->name) { printf(\"<%s>\", p->name); }\r\n    else { printf(\"<anon>\"); }\r\n    return;\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_UNDEFINED) { printf(\"<?>\"); }\r\n  if (p->type == MPC_TYPE_PASS)   { printf(\"<:>\"); }\r\n  if (p->type == MPC_TYPE_FAIL)   { printf(\"<!>\"); }\r\n  if (p->type == MPC_TYPE_LIFT)   { printf(\"<#>\"); }\r\n  if (p->type == MPC_TYPE_STATE)  { printf(\"<S>\"); }\r\n  if (p->type == MPC_TYPE_ANCHOR) { printf(\"<@>\"); }\r\n  if (p->type == MPC_TYPE_EXPECT) {\r\n    printf(\"%s\", p->data.expect.m);\r\n    /*mpc_print_unretained(p->data.expect.x, 0);*/\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_ANY) { printf(\"<.>\"); }\r\n  if (p->type == MPC_TYPE_SATISFY) { printf(\"<f>\"); }\r\n\r\n  if (p->type == MPC_TYPE_SINGLE) {\r\n    buff[0] = p->data.single.x; buff[1] = '\\0';\r\n    s = mpcf_escape_new(\r\n      buff,\r\n      mpc_escape_input_c,\r\n      mpc_escape_output_c);\r\n    printf(\"'%s'\", s);\r\n    free(s);\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_RANGE) {\r\n    buff[0] = p->data.range.x; buff[1] = '\\0';\r\n    s = mpcf_escape_new(\r\n      buff,\r\n      mpc_escape_input_c,\r\n      mpc_escape_output_c);\r\n    buff[0] = p->data.range.y; buff[1] = '\\0';\r\n    e = mpcf_escape_new(\r\n      buff,\r\n      mpc_escape_input_c,\r\n      mpc_escape_output_c);\r\n    printf(\"[%s-%s]\", s, e);\r\n    free(s);\r\n    free(e);\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_ONEOF) {\r\n    s = mpcf_escape_new(\r\n      p->data.string.x,\r\n      mpc_escape_input_c,\r\n      mpc_escape_output_c);\r\n    printf(\"[%s]\", s);\r\n    free(s);\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_NONEOF) {\r\n    s = mpcf_escape_new(\r\n      p->data.string.x,\r\n      mpc_escape_input_c,\r\n      mpc_escape_output_c);\r\n    printf(\"[^%s]\", s);\r\n    free(s);\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_STRING) {\r\n    s = mpcf_escape_new(\r\n      p->data.string.x,\r\n      mpc_escape_input_c,\r\n      mpc_escape_output_c);\r\n    printf(\"\\\"%s\\\"\", s);\r\n    free(s);\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_APPLY)    { mpc_print_unretained(p->data.apply.x, 0); }\r\n  if (p->type == MPC_TYPE_APPLY_TO) { mpc_print_unretained(p->data.apply_to.x, 0); }\r\n  if (p->type == MPC_TYPE_PREDICT)  { mpc_print_unretained(p->data.predict.x, 0); }\r\n\r\n  if (p->type == MPC_TYPE_NOT)   { mpc_print_unretained(p->data.not.x, 0); printf(\"!\"); }\r\n  if (p->type == MPC_TYPE_MAYBE) { mpc_print_unretained(p->data.not.x, 0); printf(\"?\"); }\r\n\r\n  if (p->type == MPC_TYPE_MANY)  { mpc_print_unretained(p->data.repeat.x, 0); printf(\"*\"); }\r\n  if (p->type == MPC_TYPE_MANY1) { mpc_print_unretained(p->data.repeat.x, 0); printf(\"+\"); }\r\n  if (p->type == MPC_TYPE_COUNT) { mpc_print_unretained(p->data.repeat.x, 0); printf(\"{%i}\", p->data.repeat.n); }\r\n  if (p->type == MPC_TYPE_SEPBY1) {\r\n    mpc_print_unretained(p->data.sepby1.x, 0);\r\n    printf(\" (\");\r\n    mpc_print_unretained(p->data.sepby1.sep, 0);\r\n    printf(\" \");\r\n    mpc_print_unretained(p->data.sepby1.x, 0);\r\n    printf(\")\");\r\n    printf(\"*\");\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_OR) {\r\n    printf(\"(\");\r\n    for(i = 0; i < p->data.or.n-1; i++) {\r\n      mpc_print_unretained(p->data.or.xs[i], 0);\r\n      printf(\" | \");\r\n    }\r\n    mpc_print_unretained(p->data.or.xs[p->data.or.n-1], 0);\r\n    printf(\")\");\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_AND) {\r\n    printf(\"(\");\r\n    for(i = 0; i < p->data.and.n-1; i++) {\r\n      mpc_print_unretained(p->data.and.xs[i], 0);\r\n      printf(\" \");\r\n    }\r\n    mpc_print_unretained(p->data.and.xs[p->data.and.n-1], 0);\r\n    printf(\")\");\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_CHECK) {\r\n    mpc_print_unretained(p->data.check.x, 0);\r\n    printf(\"->?\");\r\n  }\r\n  if (p->type == MPC_TYPE_CHECK_WITH) {\r\n    mpc_print_unretained(p->data.check_with.x, 0);\r\n    printf(\"->?\");\r\n  }\r\n\r\n}\r\n\r\nvoid mpc_print(mpc_parser_t *p) {\r\n  mpc_print_unretained(p, 1);\r\n  printf(\"\\n\");\r\n}\r\n\r\n/*\r\n** Testing\r\n*/\r\n\r\n/*\r\n** These functions are slightly unwieldy and\r\n** also the whole of the testing suite for mpc\r\n** mpc is pretty shaky.\r\n**\r\n** It could do with a lot more tests and more\r\n** precision. Currently I am only really testing\r\n** changes off of the examples.\r\n**\r\n*/\r\n\r\nint mpc_test_fail(mpc_parser_t *p, const char *s, const void *d,\r\n  int(*tester)(const void*, const void*),\r\n  mpc_dtor_t destructor,\r\n  void(*printer)(const void*)) {\r\n  mpc_result_t r;\r\n  (void) printer;\r\n  if (mpc_parse(\"<test>\", s, p, &r)) {\r\n\r\n    if (tester(r.output, d)) {\r\n      destructor(r.output);\r\n      return 0;\r\n    } else {\r\n      destructor(r.output);\r\n      return 1;\r\n    }\r\n\r\n  } else {\r\n    mpc_err_delete(r.error);\r\n    return 1;\r\n  }\r\n\r\n}\r\n\r\nint mpc_test_pass(mpc_parser_t *p, const char *s, const void *d,\r\n  int(*tester)(const void*, const void*),\r\n  mpc_dtor_t destructor,\r\n  void(*printer)(const void*)) {\r\n\r\n  mpc_result_t r;\r\n  if (mpc_parse(\"<test>\", s, p, &r)) {\r\n\r\n    if (tester(r.output, d)) {\r\n      destructor(r.output);\r\n      return 1;\r\n    } else {\r\n      printf(\"Got \"); printer(r.output); printf(\"\\n\");\r\n      printf(\"Expected \"); printer(d); printf(\"\\n\");\r\n      destructor(r.output);\r\n      return 0;\r\n    }\r\n\r\n  } else {\r\n    mpc_err_print(r.error);\r\n    mpc_err_delete(r.error);\r\n    return 0;\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n/*\r\n** AST\r\n*/\r\n\r\nvoid mpc_ast_delete(mpc_ast_t *a) {\r\n\r\n  int i;\r\n\r\n  if (a == NULL) { return; }\r\n\r\n  for (i = 0; i < a->children_num; i++) {\r\n    mpc_ast_delete(a->children[i]);\r\n  }\r\n\r\n  free(a->children);\r\n  free(a->tag);\r\n  free(a->contents);\r\n  free(a);\r\n\r\n}\r\n\r\nstatic void mpc_ast_delete_no_children(mpc_ast_t *a) {\r\n  free(a->children);\r\n  free(a->tag);\r\n  free(a->contents);\r\n  free(a);\r\n}\r\n\r\nmpc_ast_t *mpc_ast_new(const char *tag, const char *contents) {\r\n\r\n  mpc_ast_t *a = malloc(sizeof(mpc_ast_t));\r\n\r\n  a->tag = malloc(strlen(tag) + 1);\r\n  strcpy(a->tag, tag);\r\n\r\n  a->contents = malloc(strlen(contents) + 1);\r\n  strcpy(a->contents, contents);\r\n\r\n  a->state = mpc_state_new();\r\n\r\n  a->children_num = 0;\r\n  a->children = NULL;\r\n  return a;\r\n\r\n}\r\n\r\nmpc_ast_t *mpc_ast_build(int n, const char *tag, ...) {\r\n\r\n  mpc_ast_t *a = mpc_ast_new(tag, \"\");\r\n\r\n  int i;\r\n  va_list va;\r\n  va_start(va, tag);\r\n\r\n  for (i = 0; i < n; i++) {\r\n    mpc_ast_add_child(a, va_arg(va, mpc_ast_t*));\r\n  }\r\n\r\n  va_end(va);\r\n\r\n  return a;\r\n\r\n}\r\n\r\nmpc_ast_t *mpc_ast_add_root(mpc_ast_t *a) {\r\n\r\n  mpc_ast_t *r;\r\n\r\n  if (a == NULL) { return a; }\r\n  if (a->children_num == 0) { return a; }\r\n  if (a->children_num == 1) { return a; }\r\n\r\n  r = mpc_ast_new(\">\", \"\");\r\n  mpc_ast_add_child(r, a);\r\n  return r;\r\n}\r\n\r\nint mpc_ast_eq(mpc_ast_t *a, mpc_ast_t *b) {\r\n\r\n  int i;\r\n\r\n  if (strcmp(a->tag, b->tag) != 0) { return 0; }\r\n  if (strcmp(a->contents, b->contents) != 0) { return 0; }\r\n  if (a->children_num != b->children_num) { return 0; }\r\n\r\n  for (i = 0; i < a->children_num; i++) {\r\n    if (!mpc_ast_eq(a->children[i], b->children[i])) { return 0; }\r\n  }\r\n\r\n  return 1;\r\n}\r\n\r\nmpc_ast_t *mpc_ast_add_child(mpc_ast_t *r, mpc_ast_t *a) {\r\n  r->children_num++;\r\n  r->children = realloc(r->children, sizeof(mpc_ast_t*) * r->children_num);\r\n  r->children[r->children_num-1] = a;\r\n  return r;\r\n}\r\n\r\nmpc_ast_t *mpc_ast_add_tag(mpc_ast_t *a, const char *t) {\r\n  if (a == NULL) { return a; }\r\n  a->tag = realloc(a->tag, strlen(t) + 1 + strlen(a->tag) + 1);\r\n  memmove(a->tag + strlen(t) + 1, a->tag, strlen(a->tag)+1);\r\n  memmove(a->tag, t, strlen(t));\r\n  memmove(a->tag + strlen(t), \"|\", 1);\r\n  return a;\r\n}\r\n\r\nmpc_ast_t *mpc_ast_add_root_tag(mpc_ast_t *a, const char *t) {\r\n  if (a == NULL) { return a; }\r\n  a->tag = realloc(a->tag, (strlen(t)-1) + strlen(a->tag) + 1);\r\n  memmove(a->tag + (strlen(t)-1), a->tag, strlen(a->tag)+1);\r\n  memmove(a->tag, t, (strlen(t)-1));\r\n  return a;\r\n}\r\n\r\nmpc_ast_t *mpc_ast_tag(mpc_ast_t *a, const char *t) {\r\n  a->tag = realloc(a->tag, strlen(t) + 1);\r\n  strcpy(a->tag, t);\r\n  return a;\r\n}\r\n\r\nmpc_ast_t *mpc_ast_state(mpc_ast_t *a, mpc_state_t s) {\r\n  if (a == NULL) { return a; }\r\n  a->state = s;\r\n  return a;\r\n}\r\n\r\nstatic void mpc_ast_print_depth(mpc_ast_t *a, int d, FILE *fp) {\r\n\r\n  int i;\r\n\r\n  if (a == NULL) {\r\n    fprintf(fp, \"NULL\\n\");\r\n    return;\r\n  }\r\n\r\n  for (i = 0; i < d; i++) { fprintf(fp, \"  \"); }\r\n\r\n  if (strlen(a->contents)) {\r\n    fprintf(fp, \"%s:%lu:%lu '%s'\\n\", a->tag,\r\n      (long unsigned int)(a->state.row+1),\r\n      (long unsigned int)(a->state.col+1),\r\n      a->contents);\r\n  } else {\r\n    fprintf(fp, \"%s \\n\", a->tag);\r\n  }\r\n\r\n  for (i = 0; i < a->children_num; i++) {\r\n    mpc_ast_print_depth(a->children[i], d+1, fp);\r\n  }\r\n\r\n}\r\n\r\nvoid mpc_ast_print(mpc_ast_t *a) {\r\n  mpc_ast_print_depth(a, 0, stdout);\r\n}\r\n\r\nvoid mpc_ast_print_to(mpc_ast_t *a, FILE *fp) {\r\n  mpc_ast_print_depth(a, 0, fp);\r\n}\r\n\r\nint mpc_ast_get_index(mpc_ast_t *ast, const char *tag) {\r\n  return mpc_ast_get_index_lb(ast, tag, 0);\r\n}\r\n\r\nint mpc_ast_get_index_lb(mpc_ast_t *ast, const char *tag, int lb) {\r\n  int i;\r\n\r\n  for(i=lb; i<ast->children_num; i++) {\r\n    if(strcmp(ast->children[i]->tag, tag) == 0) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nmpc_ast_t *mpc_ast_get_child(mpc_ast_t *ast, const char *tag) {\r\n  return mpc_ast_get_child_lb(ast, tag, 0);\r\n}\r\n\r\nmpc_ast_t *mpc_ast_get_child_lb(mpc_ast_t *ast, const char *tag, int lb) {\r\n  int i;\r\n\r\n  for(i=lb; i<ast->children_num; i++) {\r\n    if(strcmp(ast->children[i]->tag, tag) == 0) {\r\n      return ast->children[i];\r\n    }\r\n  }\r\n\r\n  return NULL;\r\n}\r\n\r\nmpc_ast_trav_t *mpc_ast_traverse_start(mpc_ast_t *ast,\r\n                                       mpc_ast_trav_order_t order)\r\n{\r\n  mpc_ast_trav_t *trav, *n_trav;\r\n  mpc_ast_t *cnode = ast;\r\n\r\n  /* Create the traversal structure */\r\n  trav = malloc(sizeof(mpc_ast_trav_t));\r\n  trav->curr_node = cnode;\r\n  trav->parent = NULL;\r\n  trav->curr_child = 0;\r\n  trav->order = order;\r\n\r\n  /* Get start node */\r\n  switch(order) {\r\n    case mpc_ast_trav_order_pre:\r\n      /* Nothing else is needed for pre order start */\r\n      break;\r\n\r\n    case mpc_ast_trav_order_post:\r\n      while(cnode->children_num > 0) {\r\n        cnode = cnode->children[0];\r\n\r\n        n_trav = malloc(sizeof(mpc_ast_trav_t));\r\n        n_trav->curr_node = cnode;\r\n        n_trav->parent = trav;\r\n        n_trav->curr_child = 0;\r\n        n_trav->order = order;\r\n\r\n        trav = n_trav;\r\n      }\r\n\r\n      break;\r\n\r\n    default:\r\n      /* Unreachable, but compiler complaints */\r\n      break;\r\n  }\r\n\r\n  return trav;\r\n}\r\n\r\nmpc_ast_t *mpc_ast_traverse_next(mpc_ast_trav_t **trav) {\r\n  mpc_ast_trav_t *n_trav, *to_free;\r\n  mpc_ast_t *ret = NULL;\r\n  int cchild;\r\n\r\n  /* The end of traversal was reached */\r\n  if(*trav == NULL) return NULL;\r\n\r\n  switch((*trav)->order) {\r\n    case mpc_ast_trav_order_pre:\r\n      ret = (*trav)->curr_node;\r\n\r\n      /* If there aren't any more children, go up */\r\n      while(*trav != NULL &&\r\n        (*trav)->curr_child >= (*trav)->curr_node->children_num)\r\n      {\r\n        to_free = *trav;\r\n        *trav = (*trav)->parent;\r\n        free(to_free);\r\n      }\r\n\r\n      /* If trav is NULL, the end was reached */\r\n      if(*trav == NULL) {\r\n        break;\r\n      }\r\n\r\n      /* Go to next child */\r\n      n_trav = malloc(sizeof(mpc_ast_trav_t));\r\n\r\n      cchild = (*trav)->curr_child;\r\n      n_trav->curr_node = (*trav)->curr_node->children[cchild];\r\n      n_trav->parent = *trav;\r\n      n_trav->curr_child = 0;\r\n      n_trav->order = (*trav)->order;\r\n\r\n      (*trav)->curr_child++;\r\n      *trav = n_trav;\r\n\r\n      break;\r\n\r\n    case mpc_ast_trav_order_post:\r\n      ret = (*trav)->curr_node;\r\n\r\n      /* Move up tree to the parent If the parent doesn't have any more nodes,\r\n       * then this is the current node. If it does, move down to its left most\r\n       * child. Also, free the previous traversal node */\r\n      to_free = *trav;\r\n      *trav = (*trav)->parent;\r\n      free(to_free);\r\n\r\n      if(*trav == NULL)\r\n        break;\r\n\r\n      /* Next child */\r\n      (*trav)->curr_child++;\r\n\r\n      /* If there aren't any more children, this is the next node */\r\n      if((*trav)->curr_child >= (*trav)->curr_node->children_num) {\r\n        break;\r\n      }\r\n\r\n      /* If there are still more children, find the leftmost child from this\r\n       * node */\r\n      while((*trav)->curr_node->children_num > 0) {\r\n        n_trav = malloc(sizeof(mpc_ast_trav_t));\r\n\r\n        cchild = (*trav)->curr_child;\r\n        n_trav->curr_node = (*trav)->curr_node->children[cchild];\r\n        n_trav->parent = *trav;\r\n        n_trav->curr_child = 0;\r\n        n_trav->order = (*trav)->order;\r\n\r\n        *trav = n_trav;\r\n      }\r\n\r\n    default:\r\n      /* Unreachable, but compiler complaints */\r\n      break;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nvoid mpc_ast_traverse_free(mpc_ast_trav_t **trav) {\r\n  mpc_ast_trav_t *n_trav;\r\n\r\n  /* Go through parents until all are free */\r\n  while(*trav != NULL) {\r\n      n_trav = (*trav)->parent;\r\n      free(*trav);\r\n      *trav = n_trav;\r\n  }\r\n}\r\n\r\nmpc_val_t *mpcf_fold_ast(int n, mpc_val_t **xs) {\r\n\r\n  int i, j;\r\n  mpc_ast_t** as = (mpc_ast_t**)xs;\r\n  mpc_ast_t *r;\r\n\r\n  if (n == 0) { return NULL; }\r\n  if (n == 1) { return xs[0]; }\r\n  if (n == 2 && xs[1] == NULL) { return xs[0]; }\r\n  if (n == 2 && xs[0] == NULL) { return xs[1]; }\r\n\r\n  r = mpc_ast_new(\">\", \"\");\r\n\r\n  for (i = 0; i < n; i++) {\r\n\r\n    if (as[i] == NULL) { continue; }\r\n\r\n    if        (as[i] && as[i]->children_num == 0) {\r\n      mpc_ast_add_child(r, as[i]);\r\n    } else if (as[i] && as[i]->children_num == 1) {\r\n      mpc_ast_add_child(r, mpc_ast_add_root_tag(as[i]->children[0], as[i]->tag));\r\n      mpc_ast_delete_no_children(as[i]);\r\n    } else if (as[i] && as[i]->children_num >= 2) {\r\n      for (j = 0; j < as[i]->children_num; j++) {\r\n        mpc_ast_add_child(r, as[i]->children[j]);\r\n      }\r\n      mpc_ast_delete_no_children(as[i]);\r\n    }\r\n\r\n  }\r\n\r\n  if (r->children_num) {\r\n    r->state = r->children[0]->state;\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\nmpc_val_t *mpcf_str_ast(mpc_val_t *c) {\r\n  mpc_ast_t *a = mpc_ast_new(\"\", c);\r\n  free(c);\r\n  return a;\r\n}\r\n\r\nmpc_val_t *mpcf_state_ast(int n, mpc_val_t **xs) {\r\n  mpc_state_t *s = ((mpc_state_t**)xs)[0];\r\n  mpc_ast_t *a = ((mpc_ast_t**)xs)[1];\r\n  (void)n;\r\n  a = mpc_ast_state(a, *s);\r\n  free(s);\r\n  return a;\r\n}\r\n\r\nmpc_parser_t *mpca_state(mpc_parser_t *a) {\r\n  return mpc_and(2, mpcf_state_ast, mpc_state(), a, free);\r\n}\r\n\r\nmpc_parser_t *mpca_tag(mpc_parser_t *a, const char *t) {\r\n  return mpc_apply_to(a, (mpc_apply_to_t)mpc_ast_tag, (void*)t);\r\n}\r\n\r\nmpc_parser_t *mpca_add_tag(mpc_parser_t *a, const char *t) {\r\n  return mpc_apply_to(a, (mpc_apply_to_t)mpc_ast_add_tag, (void*)t);\r\n}\r\n\r\nmpc_parser_t *mpca_root(mpc_parser_t *a) {\r\n  return mpc_apply(a, (mpc_apply_t)mpc_ast_add_root);\r\n}\r\n\r\nmpc_parser_t *mpca_not(mpc_parser_t *a) { return mpc_not(a, (mpc_dtor_t)mpc_ast_delete); }\r\nmpc_parser_t *mpca_maybe(mpc_parser_t *a) { return mpc_maybe(a); }\r\nmpc_parser_t *mpca_many(mpc_parser_t *a) { return mpc_many(mpcf_fold_ast, a); }\r\nmpc_parser_t *mpca_many1(mpc_parser_t *a) { return mpc_many1(mpcf_fold_ast, a); }\r\nmpc_parser_t *mpca_count(int n, mpc_parser_t *a) { return mpc_count(n, mpcf_fold_ast, a, (mpc_dtor_t)mpc_ast_delete); }\r\n\r\nmpc_parser_t *mpca_or(int n, ...) {\r\n\r\n  int i;\r\n  va_list va;\r\n\r\n  mpc_parser_t *p = mpc_undefined();\r\n\r\n  p->type = MPC_TYPE_OR;\r\n  p->data.or.n = n;\r\n  p->data.or.xs = malloc(sizeof(mpc_parser_t*) * n);\r\n\r\n  va_start(va, n);\r\n  for (i = 0; i < n; i++) {\r\n    p->data.or.xs[i] = va_arg(va, mpc_parser_t*);\r\n  }\r\n  va_end(va);\r\n\r\n  return p;\r\n\r\n}\r\n\r\nmpc_parser_t *mpca_and(int n, ...) {\r\n\r\n  int i;\r\n  va_list va;\r\n\r\n  mpc_parser_t *p = mpc_undefined();\r\n\r\n  p->type = MPC_TYPE_AND;\r\n  p->data.and.n = n;\r\n  p->data.and.f = mpcf_fold_ast;\r\n  p->data.and.xs = malloc(sizeof(mpc_parser_t*) * n);\r\n  p->data.and.dxs = malloc(sizeof(mpc_dtor_t) * (n-1));\r\n\r\n  va_start(va, n);\r\n  for (i = 0; i < n; i++) {\r\n    p->data.and.xs[i] = va_arg(va, mpc_parser_t*);\r\n  }\r\n  for (i = 0; i < (n-1); i++) {\r\n    p->data.and.dxs[i] = (mpc_dtor_t)mpc_ast_delete;\r\n  }\r\n  va_end(va);\r\n\r\n  return p;\r\n}\r\n\r\nmpc_parser_t *mpca_total(mpc_parser_t *a) { return mpc_total(a, (mpc_dtor_t)mpc_ast_delete); }\r\n\r\n/*\r\n** Grammar Parser\r\n*/\r\n\r\n/*\r\n** This is another interesting bootstrapping.\r\n**\r\n** Having a general purpose AST type allows\r\n** users to specify the grammar alone and\r\n** let all fold rules be automatically taken\r\n** care of by existing functions.\r\n**\r\n** You don't get to control the type spat\r\n** out but this means you can make a nice\r\n** parser to take in some grammar in nice\r\n** syntax and spit out a parser that works.\r\n**\r\n** The grammar for this looks surprisingly\r\n** like regex but the main difference is that\r\n** it is now whitespace insensitive and the\r\n** base type takes literals of some form.\r\n*/\r\n\r\n/*\r\n**\r\n**  ### Grammar Grammar\r\n**\r\n**      <grammar> : (<term> \"|\" <grammar>) | <term>\r\n**\r\n**      <term> : <factor>*\r\n**\r\n**      <factor> : <base>\r\n**               | <base> \"*\"\r\n**               | <base> \"+\"\r\n**               | <base> \"?\"\r\n**               | <base> \"{\" <digits> \"}\"\r\n**\r\n**      <base> : \"<\" (<digits> | <ident>) \">\"\r\n**             | <string_lit>\r\n**             | <char_lit>\r\n**             | <regex_lit> <regex_mode>\r\n**             | \"(\" <grammar> \")\"\r\n*/\r\n\r\ntypedef struct {\r\n  va_list *va;\r\n  int parsers_num;\r\n  mpc_parser_t **parsers;\r\n  int flags;\r\n} mpca_grammar_st_t;\r\n\r\nstatic mpc_val_t *mpcaf_grammar_or(int n, mpc_val_t **xs) {\r\n  (void) n;\r\n  if (xs[1] == NULL) { return xs[0]; }\r\n  else { return mpca_or(2, xs[0], xs[1]); }\r\n}\r\n\r\nstatic mpc_val_t *mpcaf_grammar_and(int n, mpc_val_t **xs) {\r\n  int i;\r\n  mpc_parser_t *p = mpc_pass();\r\n  for (i = 0; i < n; i++) {\r\n    if (xs[i] != NULL) { p = mpca_and(2, p, xs[i]); }\r\n  }\r\n  return p;\r\n}\r\n\r\nstatic mpc_val_t *mpcaf_grammar_repeat(int n, mpc_val_t **xs) {\r\n  int num;\r\n  (void) n;\r\n  if (xs[1] == NULL) { return xs[0]; }\r\n  switch(((char*)xs[1])[0])\r\n  {\r\n    case '*': { free(xs[1]); return mpca_many(xs[0]); }; break;\r\n    case '+': { free(xs[1]); return mpca_many1(xs[0]); }; break;\r\n    case '?': { free(xs[1]); return mpca_maybe(xs[0]); }; break;\r\n    case '!': { free(xs[1]); return mpca_not(xs[0]); }; break;\r\n    default:\r\n      num = *((int*)xs[1]);\r\n      free(xs[1]);\r\n  }\r\n  return mpca_count(num, xs[0]);\r\n}\r\n\r\nstatic mpc_val_t *mpcaf_grammar_string(mpc_val_t *x, void *s) {\r\n  mpca_grammar_st_t *st = s;\r\n  char *y = mpcf_unescape(x);\r\n  mpc_parser_t *p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_string(y) : mpc_tok(mpc_string(y));\r\n  free(y);\r\n  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), \"string\"));\r\n}\r\n\r\nstatic mpc_val_t *mpcaf_grammar_char(mpc_val_t *x, void *s) {\r\n  mpca_grammar_st_t *st = s;\r\n  char *y = mpcf_unescape(x);\r\n  mpc_parser_t *p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_char(y[0]) : mpc_tok(mpc_char(y[0]));\r\n  free(y);\r\n  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), \"char\"));\r\n}\r\n\r\nstatic mpc_val_t *mpcaf_fold_regex(int n, mpc_val_t **xs) {\r\n  char *y = xs[0];\r\n  char *m = xs[1];\r\n  mpca_grammar_st_t *st = xs[2];\r\n  mpc_parser_t *p;\r\n  int mode = MPC_RE_DEFAULT;\r\n\r\n  (void)n;\r\n  if (strchr(m, 'm')) { mode |= MPC_RE_MULTILINE; }\r\n  if (strchr(m, 's')) { mode |= MPC_RE_DOTALL; }\r\n  y = mpcf_unescape_regex(y);\r\n  p = (st->flags & MPCA_LANG_WHITESPACE_SENSITIVE) ? mpc_re_mode(y, mode) : mpc_tok(mpc_re_mode(y, mode));\r\n  free(y);\r\n  free(m);\r\n\r\n  return mpca_state(mpca_tag(mpc_apply(p, mpcf_str_ast), \"regex\"));\r\n}\r\n\r\n/* Should this just use `isdigit` instead? */\r\nstatic int is_number(const char* s) {\r\n  size_t i;\r\n  for (i = 0; i < strlen(s); i++) { if (!strchr(\"0123456789\", s[i])) { return 0; } }\r\n  return 1;\r\n}\r\n\r\nstatic mpc_parser_t *mpca_grammar_find_parser(char *x, mpca_grammar_st_t *st) {\r\n\r\n  int i;\r\n  mpc_parser_t *p;\r\n\r\n  /* Case of Number */\r\n  if (is_number(x)) {\r\n\r\n    i = strtol(x, NULL, 10);\r\n\r\n    while (st->parsers_num <= i) {\r\n      st->parsers_num++;\r\n      st->parsers = realloc(st->parsers, sizeof(mpc_parser_t*) * st->parsers_num);\r\n      st->parsers[st->parsers_num-1] = va_arg(*st->va, mpc_parser_t*);\r\n      if (st->parsers[st->parsers_num-1] == NULL) {\r\n        return mpc_failf(\"No Parser in position %i! Only supplied %i Parsers!\", i, st->parsers_num);\r\n      }\r\n    }\r\n\r\n    return st->parsers[st->parsers_num-1];\r\n\r\n  /* Case of Identifier */\r\n  } else {\r\n\r\n    /* Search Existing Parsers */\r\n    for (i = 0; i < st->parsers_num; i++) {\r\n      mpc_parser_t *q = st->parsers[i];\r\n      if (q == NULL) { return mpc_failf(\"Unknown Parser '%s'!\", x); }\r\n      if (q->name && strcmp(q->name, x) == 0) { return q; }\r\n    }\r\n\r\n    /* Search New Parsers */\r\n    while (1) {\r\n\r\n      p = va_arg(*st->va, mpc_parser_t*);\r\n\r\n      st->parsers_num++;\r\n      st->parsers = realloc(st->parsers, sizeof(mpc_parser_t*) * st->parsers_num);\r\n      st->parsers[st->parsers_num-1] = p;\r\n\r\n      if (p == NULL || p->name == NULL) { return mpc_failf(\"Unknown Parser '%s'!\", x); }\r\n      if (p->name && strcmp(p->name, x) == 0) { return p; }\r\n\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\nstatic mpc_val_t *mpcaf_grammar_id(mpc_val_t *x, void *s) {\r\n\r\n  mpca_grammar_st_t *st = s;\r\n  mpc_parser_t *p = mpca_grammar_find_parser(x, st);\r\n  free(x);\r\n\r\n  if (p->name) {\r\n    return mpca_state(mpca_root(mpca_add_tag(p, p->name)));\r\n  } else {\r\n    return mpca_state(mpca_root(p));\r\n  }\r\n}\r\n\r\nmpc_parser_t *mpca_grammar_st(const char *grammar, mpca_grammar_st_t *st) {\r\n\r\n  char *err_msg;\r\n  mpc_parser_t *err_out;\r\n  mpc_result_t r;\r\n  mpc_parser_t *GrammarTotal, *Grammar, *Term, *Factor, *Base;\r\n\r\n  GrammarTotal = mpc_new(\"grammar_total\");\r\n  Grammar = mpc_new(\"grammar\");\r\n  Term = mpc_new(\"term\");\r\n  Factor = mpc_new(\"factor\");\r\n  Base = mpc_new(\"base\");\r\n\r\n  mpc_define(GrammarTotal,\r\n    mpc_predictive(mpc_total(Grammar, mpc_soft_delete))\r\n  );\r\n\r\n  mpc_define(Grammar, mpc_and(2, mpcaf_grammar_or,\r\n    Term,\r\n    mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_sym(\"|\"), Grammar, free)),\r\n    mpc_soft_delete\r\n  ));\r\n\r\n  mpc_define(Term, mpc_many1(mpcaf_grammar_and, Factor));\r\n\r\n  mpc_define(Factor, mpc_and(2, mpcaf_grammar_repeat,\r\n    Base,\r\n      mpc_or(6,\r\n        mpc_sym(\"*\"),\r\n        mpc_sym(\"+\"),\r\n        mpc_sym(\"?\"),\r\n        mpc_sym(\"!\"),\r\n        mpc_tok_brackets(mpc_int(), free),\r\n        mpc_pass()),\r\n    mpc_soft_delete\r\n  ));\r\n\r\n  mpc_define(Base, mpc_or(5,\r\n    mpc_apply_to(mpc_tok(mpc_string_lit()), mpcaf_grammar_string, st),\r\n    mpc_apply_to(mpc_tok(mpc_char_lit()),   mpcaf_grammar_char, st),\r\n    mpc_tok(mpc_and(3, mpcaf_fold_regex, mpc_regex_lit(), mpc_many(mpcf_strfold, mpc_oneof(\"ms\")), mpc_lift_val(st), free, free)),\r\n    mpc_apply_to(mpc_tok_braces(mpc_or(2, mpc_digits(), mpc_ident()), free), mpcaf_grammar_id, st),\r\n    mpc_tok_parens(Grammar, mpc_soft_delete)\r\n  ));\r\n\r\n  mpc_optimise(GrammarTotal);\r\n  mpc_optimise(Grammar);\r\n  mpc_optimise(Factor);\r\n  mpc_optimise(Term);\r\n  mpc_optimise(Base);\r\n\r\n  if(!mpc_parse(\"<mpc_grammar_compiler>\", grammar, GrammarTotal, &r)) {\r\n    err_msg = mpc_err_string(r.error);\r\n    err_out = mpc_failf(\"Invalid Grammar: %s\", err_msg);\r\n    mpc_err_delete(r.error);\r\n    free(err_msg);\r\n    r.output = err_out;\r\n  }\r\n\r\n  mpc_cleanup(5, GrammarTotal, Grammar, Term, Factor, Base);\r\n\r\n  mpc_optimise(r.output);\r\n\r\n  return (st->flags & MPCA_LANG_PREDICTIVE) ? mpc_predictive(r.output) : r.output;\r\n\r\n}\r\n\r\nmpc_parser_t *mpca_grammar(int flags, const char *grammar, ...) {\r\n  mpca_grammar_st_t st;\r\n  mpc_parser_t *res;\r\n  va_list va;\r\n  va_start(va, grammar);\r\n\r\n  st.va = &va;\r\n  st.parsers_num = 0;\r\n  st.parsers = NULL;\r\n  st.flags = flags;\r\n\r\n  res = mpca_grammar_st(grammar, &st);\r\n  free(st.parsers);\r\n  va_end(va);\r\n  return res;\r\n}\r\n\r\ntypedef struct {\r\n  char *ident;\r\n  char *name;\r\n  mpc_parser_t *grammar;\r\n} mpca_stmt_t;\r\n\r\nstatic mpc_val_t *mpca_stmt_afold(int n, mpc_val_t **xs) {\r\n  mpca_stmt_t *stmt = malloc(sizeof(mpca_stmt_t));\r\n  stmt->ident = ((char**)xs)[0];\r\n  stmt->name = ((char**)xs)[1];\r\n  stmt->grammar = ((mpc_parser_t**)xs)[3];\r\n  (void) n;\r\n  free(((char**)xs)[2]);\r\n  free(((char**)xs)[4]);\r\n\r\n  return stmt;\r\n}\r\n\r\nstatic mpc_val_t *mpca_stmt_fold(int n, mpc_val_t **xs) {\r\n\r\n  int i;\r\n  mpca_stmt_t **stmts = malloc(sizeof(mpca_stmt_t*) * (n+1));\r\n\r\n  for (i = 0; i < n; i++) {\r\n    stmts[i] = xs[i];\r\n  }\r\n  stmts[n] = NULL;\r\n\r\n  return stmts;\r\n}\r\n\r\nstatic void mpca_stmt_list_delete(mpc_val_t *x) {\r\n\r\n  mpca_stmt_t **stmts = x;\r\n\r\n  while(*stmts) {\r\n    mpca_stmt_t *stmt = *stmts;\r\n    free(stmt->ident);\r\n    free(stmt->name);\r\n    mpc_soft_delete(stmt->grammar);\r\n    free(stmt);\r\n    stmts++;\r\n  }\r\n  free(x);\r\n\r\n}\r\n\r\nstatic mpc_val_t *mpca_stmt_list_apply_to(mpc_val_t *x, void *s) {\r\n\r\n  mpca_grammar_st_t *st = s;\r\n  mpca_stmt_t *stmt;\r\n  mpca_stmt_t **stmts = x;\r\n  mpc_parser_t *left;\r\n\r\n  while(*stmts) {\r\n    stmt = *stmts;\r\n    left = mpca_grammar_find_parser(stmt->ident, st);\r\n    if (st->flags & MPCA_LANG_PREDICTIVE) { stmt->grammar = mpc_predictive(stmt->grammar); }\r\n    if (stmt->name) { stmt->grammar = mpc_expect(stmt->grammar, stmt->name); }\r\n    mpc_optimise(stmt->grammar);\r\n    mpc_define(left, stmt->grammar);\r\n    free(stmt->ident);\r\n    free(stmt->name);\r\n    free(stmt);\r\n    stmts++;\r\n  }\r\n\r\n  free(x);\r\n\r\n  return NULL;\r\n}\r\n\r\nstatic mpc_err_t *mpca_lang_st(mpc_input_t *i, mpca_grammar_st_t *st) {\r\n\r\n  mpc_result_t r;\r\n  mpc_err_t *e;\r\n  mpc_parser_t *Lang, *Stmt, *Grammar, *Term, *Factor, *Base;\r\n\r\n  Lang    = mpc_new(\"lang\");\r\n  Stmt    = mpc_new(\"stmt\");\r\n  Grammar = mpc_new(\"grammar\");\r\n  Term    = mpc_new(\"term\");\r\n  Factor  = mpc_new(\"factor\");\r\n  Base    = mpc_new(\"base\");\r\n\r\n  mpc_define(Lang, mpc_apply_to(\r\n    mpc_total(mpc_predictive(mpc_many(mpca_stmt_fold, Stmt)), mpca_stmt_list_delete),\r\n    mpca_stmt_list_apply_to, st\r\n  ));\r\n\r\n  mpc_define(Stmt, mpc_and(5, mpca_stmt_afold,\r\n    mpc_tok(mpc_ident()), mpc_maybe(mpc_tok(mpc_string_lit())), mpc_sym(\":\"), Grammar, mpc_sym(\";\"),\r\n    free, free, free, mpc_soft_delete\r\n  ));\r\n\r\n  mpc_define(Grammar, mpc_and(2, mpcaf_grammar_or,\r\n      Term,\r\n      mpc_maybe(mpc_and(2, mpcf_snd_free, mpc_sym(\"|\"), Grammar, free)),\r\n      mpc_soft_delete\r\n  ));\r\n\r\n  mpc_define(Term, mpc_many1(mpcaf_grammar_and, Factor));\r\n\r\n  mpc_define(Factor, mpc_and(2, mpcaf_grammar_repeat,\r\n    Base,\r\n      mpc_or(6,\r\n        mpc_sym(\"*\"),\r\n        mpc_sym(\"+\"),\r\n        mpc_sym(\"?\"),\r\n        mpc_sym(\"!\"),\r\n        mpc_tok_brackets(mpc_int(), free),\r\n        mpc_pass()),\r\n    mpc_soft_delete\r\n  ));\r\n\r\n  mpc_define(Base, mpc_or(5,\r\n    mpc_apply_to(mpc_tok(mpc_string_lit()), mpcaf_grammar_string, st),\r\n    mpc_apply_to(mpc_tok(mpc_char_lit()),   mpcaf_grammar_char, st),\r\n    mpc_tok(mpc_and(3, mpcaf_fold_regex, mpc_regex_lit(), mpc_many(mpcf_strfold, mpc_oneof(\"ms\")), mpc_lift_val(st), free, free)),\r\n    mpc_apply_to(mpc_tok_braces(mpc_or(2, mpc_digits(), mpc_ident()), free), mpcaf_grammar_id, st),\r\n    mpc_tok_parens(Grammar, mpc_soft_delete)\r\n  ));\r\n\r\n  mpc_optimise(Lang);\r\n  mpc_optimise(Stmt);\r\n  mpc_optimise(Grammar);\r\n  mpc_optimise(Term);\r\n  mpc_optimise(Factor);\r\n  mpc_optimise(Base);\r\n\r\n  if (!mpc_parse_input(i, Lang, &r)) {\r\n    e = r.error;\r\n  } else {\r\n    e = NULL;\r\n  }\r\n\r\n  mpc_cleanup(6, Lang, Stmt, Grammar, Term, Factor, Base);\r\n\r\n  return e;\r\n}\r\n\r\nmpc_err_t *mpca_lang_file(int flags, FILE *f, ...) {\r\n  mpca_grammar_st_t st;\r\n  mpc_input_t *i;\r\n  mpc_err_t *err;\r\n\r\n  va_list va;\r\n  va_start(va, f);\r\n\r\n  st.va = &va;\r\n  st.parsers_num = 0;\r\n  st.parsers = NULL;\r\n  st.flags = flags;\r\n\r\n  i = mpc_input_new_file(\"<mpca_lang_file>\", f);\r\n  err = mpca_lang_st(i, &st);\r\n  mpc_input_delete(i);\r\n\r\n  free(st.parsers);\r\n  va_end(va);\r\n  return err;\r\n}\r\n\r\nmpc_err_t *mpca_lang_pipe(int flags, FILE *p, ...) {\r\n  mpca_grammar_st_t st;\r\n  mpc_input_t *i;\r\n  mpc_err_t *err;\r\n\r\n  va_list va;\r\n  va_start(va, p);\r\n\r\n  st.va = &va;\r\n  st.parsers_num = 0;\r\n  st.parsers = NULL;\r\n  st.flags = flags;\r\n\r\n  i = mpc_input_new_pipe(\"<mpca_lang_pipe>\", p);\r\n  err = mpca_lang_st(i, &st);\r\n  mpc_input_delete(i);\r\n\r\n  free(st.parsers);\r\n  va_end(va);\r\n  return err;\r\n}\r\n\r\nmpc_err_t *mpca_lang(int flags, const char *language, ...) {\r\n\r\n  mpca_grammar_st_t st;\r\n  mpc_input_t *i;\r\n  mpc_err_t *err;\r\n\r\n  va_list va;\r\n  va_start(va, language);\r\n\r\n  st.va = &va;\r\n  st.parsers_num = 0;\r\n  st.parsers = NULL;\r\n  st.flags = flags;\r\n\r\n  i = mpc_input_new_string(\"<mpca_lang>\", language);\r\n  err = mpca_lang_st(i, &st);\r\n  mpc_input_delete(i);\r\n\r\n  free(st.parsers);\r\n  va_end(va);\r\n  return err;\r\n}\r\n\r\nmpc_err_t *mpca_lang_contents(int flags, const char *filename, ...) {\r\n\r\n  mpca_grammar_st_t st;\r\n  mpc_input_t *i;\r\n  mpc_err_t *err;\r\n\r\n  va_list va;\r\n\r\n  FILE *f = fopen(filename, \"rb\");\r\n\r\n  if (f == NULL) {\r\n    err = mpc_err_file(filename, \"Unable to open file!\");\r\n    return err;\r\n  }\r\n\r\n  va_start(va, filename);\r\n\r\n  st.va = &va;\r\n  st.parsers_num = 0;\r\n  st.parsers = NULL;\r\n  st.flags = flags;\r\n\r\n  i = mpc_input_new_file(filename, f);\r\n  err = mpca_lang_st(i, &st);\r\n  mpc_input_delete(i);\r\n\r\n  free(st.parsers);\r\n  va_end(va);\r\n\r\n  fclose(f);\r\n\r\n  return err;\r\n}\r\n\r\nstatic int mpc_nodecount_unretained(mpc_parser_t* p, int force) {\r\n\r\n  int i, total;\r\n\r\n  if (p->retained && !force) { return 0; }\r\n\r\n  if (p->type == MPC_TYPE_EXPECT) { return 1 + mpc_nodecount_unretained(p->data.expect.x, 0); }\r\n\r\n  if (p->type == MPC_TYPE_APPLY)    { return 1 + mpc_nodecount_unretained(p->data.apply.x, 0); }\r\n  if (p->type == MPC_TYPE_APPLY_TO) { return 1 + mpc_nodecount_unretained(p->data.apply_to.x, 0); }\r\n  if (p->type == MPC_TYPE_PREDICT)  { return 1 + mpc_nodecount_unretained(p->data.predict.x, 0); }\r\n\r\n  if (p->type == MPC_TYPE_CHECK)    { return 1 + mpc_nodecount_unretained(p->data.check.x, 0); }\r\n  if (p->type == MPC_TYPE_CHECK_WITH) { return 1 + mpc_nodecount_unretained(p->data.check_with.x, 0); }\r\n\r\n  if (p->type == MPC_TYPE_NOT)   { return 1 + mpc_nodecount_unretained(p->data.not.x, 0); }\r\n  if (p->type == MPC_TYPE_MAYBE) { return 1 + mpc_nodecount_unretained(p->data.not.x, 0); }\r\n\r\n  if (p->type == MPC_TYPE_MANY)  { return 1 + mpc_nodecount_unretained(p->data.repeat.x, 0); }\r\n  if (p->type == MPC_TYPE_MANY1) { return 1 + mpc_nodecount_unretained(p->data.repeat.x, 0); }\r\n  if (p->type == MPC_TYPE_COUNT) { return 1 + mpc_nodecount_unretained(p->data.repeat.x, 0); }\r\n  if (p->type == MPC_TYPE_SEPBY1) {\r\n    total = 1;\r\n    total += mpc_nodecount_unretained(p->data.sepby1.x, 0);\r\n    total += mpc_nodecount_unretained(p->data.sepby1.sep, 0);\r\n    total += mpc_nodecount_unretained(p->data.sepby1.x, 0);\r\n    return total;\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_OR) {\r\n    total = 1;\r\n    for(i = 0; i < p->data.or.n; i++) {\r\n      total += mpc_nodecount_unretained(p->data.or.xs[i], 0);\r\n    }\r\n    return total;\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_AND) {\r\n    total = 1;\r\n    for(i = 0; i < p->data.and.n; i++) {\r\n      total += mpc_nodecount_unretained(p->data.and.xs[i], 0);\r\n    }\r\n    return total;\r\n  }\r\n\r\n  return 1;\r\n\r\n}\r\n\r\nvoid mpc_stats(mpc_parser_t* p) {\r\n  printf(\"Stats\\n\");\r\n  printf(\"=====\\n\");\r\n  printf(\"Node Count: %i\\n\", mpc_nodecount_unretained(p, 1));\r\n}\r\n\r\nstatic void mpc_optimise_unretained(mpc_parser_t *p, int force) {\r\n\r\n  int i, n, m;\r\n  mpc_parser_t *t;\r\n\r\n  if (p->retained && !force) { return; }\r\n\r\n  /* Optimise Subexpressions */\r\n\r\n  if (p->type == MPC_TYPE_EXPECT)     { mpc_optimise_unretained(p->data.expect.x, 0); }\r\n  if (p->type == MPC_TYPE_APPLY)      { mpc_optimise_unretained(p->data.apply.x, 0); }\r\n  if (p->type == MPC_TYPE_APPLY_TO)   { mpc_optimise_unretained(p->data.apply_to.x, 0); }\r\n  if (p->type == MPC_TYPE_CHECK)      { mpc_optimise_unretained(p->data.check.x, 0); }\r\n  if (p->type == MPC_TYPE_CHECK_WITH) { mpc_optimise_unretained(p->data.check_with.x, 0); }\r\n  if (p->type == MPC_TYPE_PREDICT)    { mpc_optimise_unretained(p->data.predict.x, 0); }\r\n  if (p->type == MPC_TYPE_NOT)        { mpc_optimise_unretained(p->data.not.x, 0); }\r\n  if (p->type == MPC_TYPE_MAYBE)      { mpc_optimise_unretained(p->data.not.x, 0); }\r\n  if (p->type == MPC_TYPE_MANY)       { mpc_optimise_unretained(p->data.repeat.x, 0); }\r\n  if (p->type == MPC_TYPE_MANY1)      { mpc_optimise_unretained(p->data.repeat.x, 0); }\r\n  if (p->type == MPC_TYPE_COUNT)      { mpc_optimise_unretained(p->data.repeat.x, 0); }\r\n  if (p->type == MPC_TYPE_SEPBY1)     {\r\n    mpc_optimise_unretained(p->data.sepby1.x, 0);\r\n    mpc_optimise_unretained(p->data.sepby1.sep, 0);\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_OR) {\r\n    for(i = 0; i < p->data.or.n; i++) {\r\n      mpc_optimise_unretained(p->data.or.xs[i], 0);\r\n    }\r\n  }\r\n\r\n  if (p->type == MPC_TYPE_AND) {\r\n    for(i = 0; i < p->data.and.n; i++) {\r\n      mpc_optimise_unretained(p->data.and.xs[i], 0);\r\n    }\r\n  }\r\n\r\n  /* Perform optimisations */\r\n\r\n  while (1) {\r\n\r\n    /* Merge rhs `or` */\r\n    if (p->type == MPC_TYPE_OR\r\n    &&  p->data.or.xs[p->data.or.n-1]->type == MPC_TYPE_OR\r\n    && !p->data.or.xs[p->data.or.n-1]->retained) {\r\n      t = p->data.or.xs[p->data.or.n-1];\r\n      n = p->data.or.n; m = t->data.or.n;\r\n      p->data.or.n = n + m - 1;\r\n      p->data.or.xs = realloc(p->data.or.xs, sizeof(mpc_parser_t*) * (n + m -1));\r\n      memmove(p->data.or.xs + n - 1, t->data.or.xs, m * sizeof(mpc_parser_t*));\r\n      free(t->data.or.xs); free(t->name); free(t);\r\n      continue;\r\n    }\r\n\r\n    /* Merge lhs `or` */\r\n    if (p->type == MPC_TYPE_OR\r\n    &&  p->data.or.xs[0]->type == MPC_TYPE_OR\r\n    && !p->data.or.xs[0]->retained) {\r\n      t = p->data.or.xs[0];\r\n      n = p->data.or.n; m = t->data.or.n;\r\n      p->data.or.n = n + m - 1;\r\n      p->data.or.xs = realloc(p->data.or.xs, sizeof(mpc_parser_t*) * (n + m -1));\r\n      memmove(p->data.or.xs + m, p->data.or.xs + 1, (n - 1) * sizeof(mpc_parser_t*));\r\n      memmove(p->data.or.xs, t->data.or.xs, m * sizeof(mpc_parser_t*));\r\n      free(t->data.or.xs); free(t->name); free(t);\r\n      continue;\r\n    }\r\n\r\n    /* Remove ast `pass` */\r\n    if (p->type == MPC_TYPE_AND\r\n    &&  p->data.and.n == 2\r\n    &&  p->data.and.xs[0]->type == MPC_TYPE_PASS\r\n    && !p->data.and.xs[0]->retained\r\n    &&  p->data.and.f == mpcf_fold_ast) {\r\n      t = p->data.and.xs[1];\r\n      mpc_delete(p->data.and.xs[0]);\r\n      free(p->data.and.xs); free(p->data.and.dxs); free(p->name);\r\n      memcpy(p, t, sizeof(mpc_parser_t));\r\n      free(t);\r\n      continue;\r\n    }\r\n\r\n    /* Merge ast lhs `and` */\r\n    if (p->type == MPC_TYPE_AND\r\n    &&  p->data.and.f == mpcf_fold_ast\r\n    &&  p->data.and.xs[0]->type == MPC_TYPE_AND\r\n    && !p->data.and.xs[0]->retained\r\n    &&  p->data.and.xs[0]->data.and.f == mpcf_fold_ast) {\r\n      t = p->data.and.xs[0];\r\n      n = p->data.and.n; m = t->data.and.n;\r\n      p->data.and.n = n + m - 1;\r\n      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m - 1));\r\n      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));\r\n      memmove(p->data.and.xs + m, p->data.and.xs + 1, (n - 1) * sizeof(mpc_parser_t*));\r\n      memmove(p->data.and.xs, t->data.and.xs, m * sizeof(mpc_parser_t*));\r\n      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = (mpc_dtor_t)mpc_ast_delete; }\r\n      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);\r\n      continue;\r\n    }\r\n\r\n    /* Merge ast rhs `and` */\r\n    if (p->type == MPC_TYPE_AND\r\n    &&  p->data.and.f == mpcf_fold_ast\r\n    &&  p->data.and.xs[p->data.and.n-1]->type == MPC_TYPE_AND\r\n    && !p->data.and.xs[p->data.and.n-1]->retained\r\n    &&  p->data.and.xs[p->data.and.n-1]->data.and.f == mpcf_fold_ast) {\r\n      t = p->data.and.xs[p->data.and.n-1];\r\n      n = p->data.and.n; m = t->data.and.n;\r\n      p->data.and.n = n + m - 1;\r\n      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m -1));\r\n      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));\r\n      memmove(p->data.and.xs + n - 1, t->data.and.xs, m * sizeof(mpc_parser_t*));\r\n      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = (mpc_dtor_t)mpc_ast_delete; }\r\n      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);\r\n      continue;\r\n    }\r\n\r\n    /* Remove re `lift` */\r\n    if (p->type == MPC_TYPE_AND\r\n    &&  p->data.and.n == 2\r\n    &&  p->data.and.xs[0]->type == MPC_TYPE_LIFT\r\n    &&  p->data.and.xs[0]->data.lift.lf == mpcf_ctor_str\r\n    && !p->data.and.xs[0]->retained\r\n    &&  p->data.and.f == mpcf_strfold) {\r\n      t = p->data.and.xs[1];\r\n      mpc_delete(p->data.and.xs[0]);\r\n      free(p->data.and.xs); free(p->data.and.dxs); free(p->name);\r\n      memcpy(p, t, sizeof(mpc_parser_t));\r\n      free(t);\r\n      continue;\r\n    }\r\n\r\n    /* Merge re lhs `and` */\r\n    if (p->type == MPC_TYPE_AND\r\n    &&  p->data.and.f == mpcf_strfold\r\n    &&  p->data.and.xs[0]->type == MPC_TYPE_AND\r\n    && !p->data.and.xs[0]->retained\r\n    &&  p->data.and.xs[0]->data.and.f == mpcf_strfold) {\r\n      t = p->data.and.xs[0];\r\n      n = p->data.and.n; m = t->data.and.n;\r\n      p->data.and.n = n + m - 1;\r\n      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m - 1));\r\n      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));\r\n      memmove(p->data.and.xs + m, p->data.and.xs + 1, (n - 1) * sizeof(mpc_parser_t*));\r\n      memmove(p->data.and.xs, t->data.and.xs, m * sizeof(mpc_parser_t*));\r\n      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = free; }\r\n      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);\r\n      continue;\r\n    }\r\n\r\n    /* Merge re rhs `and` */\r\n    if (p->type == MPC_TYPE_AND\r\n    &&  p->data.and.f == mpcf_strfold\r\n    &&  p->data.and.xs[p->data.and.n-1]->type == MPC_TYPE_AND\r\n    && !p->data.and.xs[p->data.and.n-1]->retained\r\n    &&  p->data.and.xs[p->data.and.n-1]->data.and.f == mpcf_strfold) {\r\n      t = p->data.and.xs[p->data.and.n-1];\r\n      n = p->data.and.n; m = t->data.and.n;\r\n      p->data.and.n = n + m - 1;\r\n      p->data.and.xs = realloc(p->data.and.xs, sizeof(mpc_parser_t*) * (n + m -1));\r\n      p->data.and.dxs = realloc(p->data.and.dxs, sizeof(mpc_dtor_t) * (n + m - 1 - 1));\r\n      memmove(p->data.and.xs + n - 1, t->data.and.xs, m * sizeof(mpc_parser_t*));\r\n      for (i = 0; i < p->data.and.n-1; i++) { p->data.and.dxs[i] = free; }\r\n      free(t->data.and.xs); free(t->data.and.dxs); free(t->name); free(t);\r\n      continue;\r\n    }\r\n\r\n    return;\r\n\r\n  }\r\n\r\n}\r\n\r\nvoid mpc_optimise(mpc_parser_t *p) {\r\n  mpc_optimise_unretained(p, 1);\r\n}\r\n\r\n"
        },
        {
          "name": "mpc.h",
          "type": "blob",
          "size": 11.01171875,
          "content": "/*\r\n** mpc - Micro Parser Combinator library for C\r\n**\r\n** https://github.com/orangeduck/mpc\r\n**\r\n** Daniel Holden - contact@daniel-holden.com\r\n** Licensed under BSD3\r\n*/\r\n\r\n#ifndef mpc_h\r\n#define mpc_h\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <stdarg.h>\r\n#include <string.h>\r\n#include <math.h>\r\n#include <errno.h>\r\n#include <ctype.h>\r\n\r\n/*\r\n** State Type\r\n*/\r\n\r\ntypedef struct {\r\n  long pos;\r\n  long row;\r\n  long col;\r\n  int term;\r\n} mpc_state_t;\r\n\r\n/*\r\n** Error Type\r\n*/\r\n\r\ntypedef struct {\r\n  mpc_state_t state;\r\n  int expected_num;\r\n  char *filename;\r\n  char *failure;\r\n  char **expected;\r\n  char received;\r\n} mpc_err_t;\r\n\r\nvoid mpc_err_delete(mpc_err_t *e);\r\nchar *mpc_err_string(mpc_err_t *e);\r\nvoid mpc_err_print(mpc_err_t *e);\r\nvoid mpc_err_print_to(mpc_err_t *e, FILE *f);\r\n\r\n/*\r\n** Parsing\r\n*/\r\n\r\ntypedef void mpc_val_t;\r\n\r\ntypedef union {\r\n  mpc_err_t *error;\r\n  mpc_val_t *output;\r\n} mpc_result_t;\r\n\r\nstruct mpc_parser_t;\r\ntypedef struct mpc_parser_t mpc_parser_t;\r\n\r\nint mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r);\r\nint mpc_nparse(const char *filename, const char *string, size_t length, mpc_parser_t *p, mpc_result_t *r);\r\nint mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r);\r\nint mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r);\r\nint mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r);\r\n\r\n/*\r\n** Function Types\r\n*/\r\n\r\ntypedef void(*mpc_dtor_t)(mpc_val_t*);\r\ntypedef mpc_val_t*(*mpc_ctor_t)(void);\r\n\r\ntypedef mpc_val_t*(*mpc_apply_t)(mpc_val_t*);\r\ntypedef mpc_val_t*(*mpc_apply_to_t)(mpc_val_t*,void*);\r\ntypedef mpc_val_t*(*mpc_fold_t)(int,mpc_val_t**);\r\n\r\ntypedef int(*mpc_check_t)(mpc_val_t**);\r\ntypedef int(*mpc_check_with_t)(mpc_val_t**,void*);\r\n\r\n/*\r\n** Building a Parser\r\n*/\r\n\r\nmpc_parser_t *mpc_new(const char *name);\r\nmpc_parser_t *mpc_copy(mpc_parser_t *a);\r\nmpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a);\r\nmpc_parser_t *mpc_undefine(mpc_parser_t *p);\r\n\r\nvoid mpc_delete(mpc_parser_t *p);\r\nvoid mpc_cleanup(int n, ...);\r\n\r\n/*\r\n** Basic Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_any(void);\r\nmpc_parser_t *mpc_char(char c);\r\nmpc_parser_t *mpc_range(char s, char e);\r\nmpc_parser_t *mpc_oneof(const char *s);\r\nmpc_parser_t *mpc_noneof(const char *s);\r\nmpc_parser_t *mpc_satisfy(int(*f)(char));\r\nmpc_parser_t *mpc_string(const char *s);\r\n\r\n/*\r\n** Other Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_pass(void);\r\nmpc_parser_t *mpc_fail(const char *m);\r\nmpc_parser_t *mpc_failf(const char *fmt, ...);\r\nmpc_parser_t *mpc_lift(mpc_ctor_t f);\r\nmpc_parser_t *mpc_lift_val(mpc_val_t *x);\r\nmpc_parser_t *mpc_anchor(int(*f)(char,char));\r\nmpc_parser_t *mpc_state(void);\r\n\r\n/*\r\n** Combinator Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_expect(mpc_parser_t *a, const char *e);\r\nmpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...);\r\nmpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f);\r\nmpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x);\r\nmpc_parser_t *mpc_check(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *e);\r\nmpc_parser_t *mpc_check_with(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *e);\r\nmpc_parser_t *mpc_checkf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *fmt, ...);\r\nmpc_parser_t *mpc_check_withf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *fmt, ...);\r\n\r\nmpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da);\r\nmpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf);\r\nmpc_parser_t *mpc_maybe(mpc_parser_t *a);\r\nmpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf);\r\n\r\nmpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a);\r\nmpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a);\r\nmpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da);\r\n\r\nmpc_parser_t *mpc_or(int n, ...);\r\nmpc_parser_t *mpc_and(int n, mpc_fold_t f, ...);\r\n\r\nmpc_parser_t *mpc_predictive(mpc_parser_t *a);\r\n\r\n/*\r\n** Common Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_eoi(void);\r\nmpc_parser_t *mpc_soi(void);\r\n\r\nmpc_parser_t *mpc_boundary(void);\r\nmpc_parser_t *mpc_boundary_newline(void);\r\n\r\nmpc_parser_t *mpc_whitespace(void);\r\nmpc_parser_t *mpc_whitespaces(void);\r\nmpc_parser_t *mpc_blank(void);\r\n\r\nmpc_parser_t *mpc_newline(void);\r\nmpc_parser_t *mpc_tab(void);\r\nmpc_parser_t *mpc_escape(void);\r\n\r\nmpc_parser_t *mpc_digit(void);\r\nmpc_parser_t *mpc_hexdigit(void);\r\nmpc_parser_t *mpc_octdigit(void);\r\nmpc_parser_t *mpc_digits(void);\r\nmpc_parser_t *mpc_hexdigits(void);\r\nmpc_parser_t *mpc_octdigits(void);\r\n\r\nmpc_parser_t *mpc_lower(void);\r\nmpc_parser_t *mpc_upper(void);\r\nmpc_parser_t *mpc_alpha(void);\r\nmpc_parser_t *mpc_underscore(void);\r\nmpc_parser_t *mpc_alphanum(void);\r\n\r\nmpc_parser_t *mpc_int(void);\r\nmpc_parser_t *mpc_hex(void);\r\nmpc_parser_t *mpc_oct(void);\r\nmpc_parser_t *mpc_number(void);\r\n\r\nmpc_parser_t *mpc_real(void);\r\nmpc_parser_t *mpc_float(void);\r\n\r\nmpc_parser_t *mpc_char_lit(void);\r\nmpc_parser_t *mpc_string_lit(void);\r\nmpc_parser_t *mpc_regex_lit(void);\r\n\r\nmpc_parser_t *mpc_ident(void);\r\n\r\n/*\r\n** Useful Parsers\r\n*/\r\n\r\nmpc_parser_t *mpc_startwith(mpc_parser_t *a);\r\nmpc_parser_t *mpc_endwith(mpc_parser_t *a, mpc_dtor_t da);\r\nmpc_parser_t *mpc_whole(mpc_parser_t *a, mpc_dtor_t da);\r\n\r\nmpc_parser_t *mpc_stripl(mpc_parser_t *a);\r\nmpc_parser_t *mpc_stripr(mpc_parser_t *a);\r\nmpc_parser_t *mpc_strip(mpc_parser_t *a);\r\nmpc_parser_t *mpc_tok(mpc_parser_t *a);\r\nmpc_parser_t *mpc_sym(const char *s);\r\nmpc_parser_t *mpc_total(mpc_parser_t *a, mpc_dtor_t da);\r\n\r\nmpc_parser_t *mpc_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c);\r\nmpc_parser_t *mpc_parens(mpc_parser_t *a, mpc_dtor_t ad);\r\nmpc_parser_t *mpc_braces(mpc_parser_t *a, mpc_dtor_t ad);\r\nmpc_parser_t *mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad);\r\nmpc_parser_t *mpc_squares(mpc_parser_t *a, mpc_dtor_t ad);\r\n\r\nmpc_parser_t *mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, const char *o, const char *c);\r\nmpc_parser_t *mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad);\r\nmpc_parser_t *mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad);\r\nmpc_parser_t *mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad);\r\nmpc_parser_t *mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad);\r\n\r\nmpc_parser_t *mpc_sepby1(mpc_fold_t f, mpc_parser_t *sep, mpc_parser_t *a);\r\n\r\n/*\r\n** Common Function Parameters\r\n*/\r\n\r\nvoid mpcf_dtor_null(mpc_val_t *x);\r\n\r\nmpc_val_t *mpcf_ctor_null(void);\r\nmpc_val_t *mpcf_ctor_str(void);\r\n\r\nmpc_val_t *mpcf_free(mpc_val_t *x);\r\nmpc_val_t *mpcf_int(mpc_val_t *x);\r\nmpc_val_t *mpcf_hex(mpc_val_t *x);\r\nmpc_val_t *mpcf_oct(mpc_val_t *x);\r\nmpc_val_t *mpcf_float(mpc_val_t *x);\r\nmpc_val_t *mpcf_strtriml(mpc_val_t *x);\r\nmpc_val_t *mpcf_strtrimr(mpc_val_t *x);\r\nmpc_val_t *mpcf_strtrim(mpc_val_t *x);\r\n\r\nmpc_val_t *mpcf_escape(mpc_val_t *x);\r\nmpc_val_t *mpcf_escape_regex(mpc_val_t *x);\r\nmpc_val_t *mpcf_escape_string_raw(mpc_val_t *x);\r\nmpc_val_t *mpcf_escape_char_raw(mpc_val_t *x);\r\n\r\nmpc_val_t *mpcf_unescape(mpc_val_t *x);\r\nmpc_val_t *mpcf_unescape_regex(mpc_val_t *x);\r\nmpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x);\r\nmpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x);\r\n\r\nmpc_val_t *mpcf_null(int n, mpc_val_t** xs);\r\nmpc_val_t *mpcf_fst(int n, mpc_val_t** xs);\r\nmpc_val_t *mpcf_snd(int n, mpc_val_t** xs);\r\nmpc_val_t *mpcf_trd(int n, mpc_val_t** xs);\r\n\r\nmpc_val_t *mpcf_fst_free(int n, mpc_val_t** xs);\r\nmpc_val_t *mpcf_snd_free(int n, mpc_val_t** xs);\r\nmpc_val_t *mpcf_trd_free(int n, mpc_val_t** xs);\r\nmpc_val_t *mpcf_all_free(int n, mpc_val_t** xs);\r\n\r\nmpc_val_t *mpcf_freefold(int n, mpc_val_t** xs);\r\nmpc_val_t *mpcf_strfold(int n, mpc_val_t** xs);\r\n\r\n/*\r\n** Regular Expression Parsers\r\n*/\r\n\r\nenum {\r\n  MPC_RE_DEFAULT   = 0,\r\n  MPC_RE_M         = 1,\r\n  MPC_RE_S         = 2,\r\n  MPC_RE_MULTILINE = 1,\r\n  MPC_RE_DOTALL    = 2\r\n};\r\n\r\nmpc_parser_t *mpc_re(const char *re);\r\nmpc_parser_t *mpc_re_mode(const char *re, int mode);\r\n\r\n/*\r\n** AST\r\n*/\r\n\r\ntypedef struct mpc_ast_t {\r\n  char *tag;\r\n  char *contents;\r\n  mpc_state_t state;\r\n  int children_num;\r\n  struct mpc_ast_t** children;\r\n} mpc_ast_t;\r\n\r\nmpc_ast_t *mpc_ast_new(const char *tag, const char *contents);\r\nmpc_ast_t *mpc_ast_build(int n, const char *tag, ...);\r\nmpc_ast_t *mpc_ast_add_root(mpc_ast_t *a);\r\nmpc_ast_t *mpc_ast_add_child(mpc_ast_t *r, mpc_ast_t *a);\r\nmpc_ast_t *mpc_ast_add_tag(mpc_ast_t *a, const char *t);\r\nmpc_ast_t *mpc_ast_add_root_tag(mpc_ast_t *a, const char *t);\r\nmpc_ast_t *mpc_ast_tag(mpc_ast_t *a, const char *t);\r\nmpc_ast_t *mpc_ast_state(mpc_ast_t *a, mpc_state_t s);\r\n\r\nvoid mpc_ast_delete(mpc_ast_t *a);\r\nvoid mpc_ast_print(mpc_ast_t *a);\r\nvoid mpc_ast_print_to(mpc_ast_t *a, FILE *fp);\r\n\r\nint mpc_ast_get_index(mpc_ast_t *ast, const char *tag);\r\nint mpc_ast_get_index_lb(mpc_ast_t *ast, const char *tag, int lb);\r\nmpc_ast_t *mpc_ast_get_child(mpc_ast_t *ast, const char *tag);\r\nmpc_ast_t *mpc_ast_get_child_lb(mpc_ast_t *ast, const char *tag, int lb);\r\n\r\ntypedef enum {\r\n  mpc_ast_trav_order_pre,\r\n  mpc_ast_trav_order_post\r\n} mpc_ast_trav_order_t;\r\n\r\ntypedef struct mpc_ast_trav_t {\r\n  mpc_ast_t             *curr_node;\r\n  struct mpc_ast_trav_t *parent;\r\n  int                    curr_child;\r\n  mpc_ast_trav_order_t   order;\r\n} mpc_ast_trav_t;\r\n\r\nmpc_ast_trav_t *mpc_ast_traverse_start(mpc_ast_t *ast,\r\n                                       mpc_ast_trav_order_t order);\r\n\r\nmpc_ast_t *mpc_ast_traverse_next(mpc_ast_trav_t **trav);\r\n\r\nvoid mpc_ast_traverse_free(mpc_ast_trav_t **trav);\r\n\r\n/*\r\n** Warning: This function currently doesn't test for equality of the `state` member!\r\n*/\r\nint mpc_ast_eq(mpc_ast_t *a, mpc_ast_t *b);\r\n\r\nmpc_val_t *mpcf_fold_ast(int n, mpc_val_t **as);\r\nmpc_val_t *mpcf_str_ast(mpc_val_t *c);\r\nmpc_val_t *mpcf_state_ast(int n, mpc_val_t **xs);\r\n\r\nmpc_parser_t *mpca_tag(mpc_parser_t *a, const char *t);\r\nmpc_parser_t *mpca_add_tag(mpc_parser_t *a, const char *t);\r\nmpc_parser_t *mpca_root(mpc_parser_t *a);\r\nmpc_parser_t *mpca_state(mpc_parser_t *a);\r\nmpc_parser_t *mpca_total(mpc_parser_t *a);\r\n\r\nmpc_parser_t *mpca_not(mpc_parser_t *a);\r\nmpc_parser_t *mpca_maybe(mpc_parser_t *a);\r\n\r\nmpc_parser_t *mpca_many(mpc_parser_t *a);\r\nmpc_parser_t *mpca_many1(mpc_parser_t *a);\r\nmpc_parser_t *mpca_count(int n, mpc_parser_t *a);\r\n\r\nmpc_parser_t *mpca_or(int n, ...);\r\nmpc_parser_t *mpca_and(int n, ...);\r\n\r\nenum {\r\n  MPCA_LANG_DEFAULT              = 0,\r\n  MPCA_LANG_PREDICTIVE           = 1,\r\n  MPCA_LANG_WHITESPACE_SENSITIVE = 2\r\n};\r\n\r\nmpc_parser_t *mpca_grammar(int flags, const char *grammar, ...);\r\n\r\nmpc_err_t *mpca_lang(int flags, const char *language, ...);\r\nmpc_err_t *mpca_lang_file(int flags, FILE *f, ...);\r\nmpc_err_t *mpca_lang_pipe(int flags, FILE *f, ...);\r\nmpc_err_t *mpca_lang_contents(int flags, const char *filename, ...);\r\n\r\n/*\r\n** Misc\r\n*/\r\n\r\n\r\nvoid mpc_print(mpc_parser_t *p);\r\nvoid mpc_optimise(mpc_parser_t *p);\r\nvoid mpc_stats(mpc_parser_t *p);\r\n\r\nint mpc_test_pass(mpc_parser_t *p, const char *s, const void *d,\r\n  int(*tester)(const void*, const void*),\r\n  mpc_dtor_t destructor,\r\n  void(*printer)(const void*));\r\n\r\nint mpc_test_fail(mpc_parser_t *p, const char *s, const void *d,\r\n  int(*tester)(const void*, const void*),\r\n  mpc_dtor_t destructor,\r\n  void(*printer)(const void*));\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "mpc.pc",
          "type": "blob",
          "size": 0.1728515625,
          "content": "libdir=${prefix}/lib\nincludedir=${prefix}/include\n\nName: mpc\nDescription: Library for creating parser combinators\nVersion: 0.9.0\nLibs: -L${libdir} -lmpc\nCflags: -I${includedir}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.23046875,
          "content": "{\n  \"name\": \"mpc\",\n  \"version\": \"0.9.8\",\n  \"repo\": \"orangeduck/mpc\",\n  \"description\": \"A Parser Combinator library for C\",\n  \"keywords\": [\"parser\", \"combinator\", \"library\", \"c\", \"mpc\"],\n  \"license\": \"BSD\",\n  \"src\": [\"mpc.c\", \"mpc.h\"]\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}