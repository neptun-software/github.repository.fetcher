{
  "metadata": {
    "timestamp": 1736709731771,
    "page": 134,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/AFL",
      "stars": 3787,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2666015625,
          "content": "# Binaries produced by \"make\".\nafl-analyze\nafl-as\nafl-clang\nafl-clang++\nafl-fuzz\nafl-g++\nafl-gcc\nafl-gotcpu\nafl-showmap\nafl-tmin\nas\n\n# Binaries produced by \"make -C llvm_mode\"\nafl-clang-fast\nafl-clang-fast++\nafl-llvm-pass.so\nafl-llvm-rt-32.o\nafl-llvm-rt-64.o\nafl-llvm-rt.o\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.603515625,
          "content": "language: c\n\nenv:\n  - AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 AFL_NO_UI=1 AFL_STOP_MANUALLY=1\n  - AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 AFL_NO_UI=1 AFL_EXIT_WHEN_DONE=1\n # TODO: test AFL_BENCH_UNTIL_CRASH once we have a target that crashes\n  - AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1 AFL_NO_UI=1 AFL_BENCH_JUST_ONE=1\n\nbefore_install:\n  - sudo apt update\n  - sudo apt install -y libtool libtool-bin automake bison libglib2.0\n\n# TODO: Look into splitting off some builds using a build matrix.\n# TODO: Move this all into a bash script so we don't need to write bash in yaml.\nscript:\n  - make\n  - ./afl-gcc ./test-instr.c -o test-instr-gcc\n  - mkdir seeds\n  - echo \"\" > seeds/nil_seed\n  - if [ -z \"$AFL_STOP_MANUALLY\" ];\n    then ./afl-fuzz -i seeds -o out/ -- ./test-instr-gcc;\n    else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-gcc;\n    fi\n  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 3\n  - rm -r out/*\n  - ./afl-clang ./test-instr.c -o test-instr-clang\n  - if [ -z \"$AFL_STOP_MANUALLY\" ];\n    then ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang;\n    else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang;\n    fi\n  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 2\n  - make clean\n  - CC=clang CXX=clang++ make\n  - cd llvm_mode\n  # TODO: Build with different versions of clang/LLVM since LLVM passes don't\n  # have a stable API.\n  - CC=clang CXX=clang++ LLVM_CONFIG=llvm-config make\n  - cd ..\n  - rm -r out/*\n  - ./afl-clang-fast ./test-instr.c -o test-instr-clang-fast\n  - if [ -z \"$AFL_STOP_MANUALLY\" ];\n    then ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang-fast;\n    else timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-instr-clang-fast;\n    fi\n  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 1 -p 3\n  # Test fuzzing libFuzzer targets and trace-pc-guard instrumentation.\n  - clang -g -fsanitize-coverage=trace-pc-guard ./test-libfuzzer-target.c -c\n  - clang -c -w llvm_mode/afl-llvm-rt.o.c\n  - wget https://raw.githubusercontent.com/llvm/llvm-project/main/compiler-rt/lib/fuzzer/afl/afl_driver.cpp\n  - clang++ afl_driver.cpp afl-llvm-rt.o.o test-libfuzzer-target.o -o test-libfuzzer-target\n  - timeout --preserve-status 5s ./afl-fuzz -i seeds -o out/ -- ./test-libfuzzer-target\n  - cd qemu_mode\n  - ./build_qemu_support.sh\n  - cd ..\n  - gcc ./test-instr.c -o test-no-instr\n  - if [ -z \"$AFL_STOP_MANUALLY\" ];\n    then ./afl-fuzz -Q -i seeds -o out/ -- ./test-no-instr;\n    else timeout --preserve-status 5s ./afl-fuzz -Q -i seeds -o out/ -- ./test-no-instr;\n    fi\n  - .travis/check_fuzzer_stats.sh -o out -k peak_rss_mb -v 12 -p 9\n"
        },
        {
          "name": ".travis",
          "type": "tree",
          "content": null
        },
        {
          "name": "Android.bp",
          "type": "blob",
          "size": 1.9208984375,
          "content": "cc_defaults {\n  name: \"afl-defaults\",\n\n  cflags: [\n    \"-funroll-loops\",\n    \"-Wno-pointer-sign\",\n    \"-Wno-pointer-arith\",\n    \"-Wno-sign-compare\",\n    \"-Wno-unused-parameter\",\n    \"-Wno-unused-function\",\n    \"-Wno-format\",\n    \"-Wno-user-defined-warnings\",\n    \"-DUSE_TRACE_PC=1\",\n    \"-DBIN_PATH=\\\"out/host/linux-x86/bin\\\"\",\n    \"-DDOC_PATH=\\\"out/host/linux-x86/shared/doc/afl\\\"\",\n    \"-D__USE_GNU\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-fuzz\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"afl-fuzz.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-showmap\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"afl-showmap.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-tmin\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"afl-tmin.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-analyze\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"afl-analyze.c\",\n  ],\n}\n\ncc_binary {\n  name: \"afl-gotcpu\",\n  static_executable: true,\n  host_supported: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"afl-gotcpu.c\",\n  ],\n}\n\ncc_binary_host {\n  name: \"afl-clang-fast\",\n  static_executable: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  cflags: [\n    \"-D__ANDROID__\",\n    \"-DAFL_PATH=\\\"out/host/linux-x86/lib64\\\"\",\n  ],\n\n  srcs: [\n    \"llvm_mode/afl-clang-fast.c\",\n  ],\n}\n\ncc_binary_host {\n  name: \"afl-clang-fast++\",\n  static_executable: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  cflags: [\n    \"-D__ANDROID__\",\n    \"-DAFL_PATH=\\\"out/host/linux-x86/lib64\\\"\",\n  ],\n\n  srcs: [\n    \"llvm_mode/afl-clang-fast.c\",\n  ],\n}\n\ncc_library_static {\n  name: \"afl-llvm-rt\",\n  compile_multilib: \"both\",\n  vendor_available: true,\n  host_supported: true,\n  recovery_available: true,\n\n  defaults: [\n    \"afl-defaults\",\n  ],\n\n  srcs: [\n    \"llvm_mode/afl-llvm-rt.o.c\",\n  ],\n}\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.0751953125,
          "content": "# How to Contribute\n\nWe'd love to accept your patches and contributions to this project. There are\njust a few small guidelines you need to follow.\n\n## Contributor License Agreement\n\nContributions to this project must be accompanied by a Contributor License\nAgreement. You (or your employer) retain the copyright to your contribution;\nthis simply gives us permission to use and redistribute your contributions as\npart of the project. Head over to <https://cla.developers.google.com/> to see\nyour current agreements on file or to sign a new one.\n\nYou generally only need to submit a CLA once, so if you've already submitted one\n(even if it was for a different project), you probably don't need to do it\nagain.\n\n## Code reviews\n\nAll submissions, including submissions by project members, require review. We\nuse GitHub pull requests for this purpose. Consult\n[GitHub Help](https://help.github.com/articles/about-pull-requests/) for more\ninformation on using pull requests.\n\n## Community Guidelines\n\nThis project follows [Google's Open Source Community\nGuidelines](https://opensource.google.com/conduct/).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 6.8232421875,
          "content": "#\n# american fuzzy lop - makefile\n# -----------------------------\n#\n# Written and maintained by Michal Zalewski <lcamtuf@google.com>\n# \n# Copyright 2013, 2014, 2015, 2016, 2017 Google LLC All rights reserved.\n# \n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n# \n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n\nPROGNAME    = afl\nVERSION     = $(shell grep '^\\#define VERSION ' config.h | cut -d '\"' -f2)\n\nPREFIX     ?= /usr/local\nBIN_PATH    = $(PREFIX)/bin\nHELPER_PATH = $(PREFIX)/lib/afl\nDOC_PATH    = $(PREFIX)/share/doc/afl\nMISC_PATH   = $(PREFIX)/share/afl\n\n# PROGS intentionally omit afl-as, which gets installed elsewhere.\n\nPROGS       = afl-gcc afl-fuzz afl-showmap afl-tmin afl-gotcpu afl-analyze\nSH_PROGS    = afl-plot afl-cmin afl-whatsup\n\nCFLAGS     ?= -O3 -funroll-loops\nCFLAGS     += -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign \\\n\t      -DAFL_PATH=\\\"$(HELPER_PATH)\\\" -DDOC_PATH=\\\"$(DOC_PATH)\\\" \\\n\t      -DBIN_PATH=\\\"$(BIN_PATH)\\\"\n\nifneq \"$(filter Linux GNU%,$(shell uname))\" \"\"\n  LDFLAGS  += -ldl\nendif\n\nifeq \"$(findstring clang, $(shell $(CC) --version 2>/dev/null))\" \"\"\n  TEST_CC   = afl-gcc\nelse\n  TEST_CC   = afl-clang\nendif\n\nCOMM_HDR    = alloc-inl.h config.h debug.h types.h\n\nall: test_x86 $(PROGS) afl-as test_build all_done\n\nifndef AFL_NO_X86\n\ntest_x86:\n\t@echo \"[*] Checking for the ability to compile x86 code...\"\n\t@echo 'main() { __asm__(\"xorb %al, %al\"); }' | $(CC) -w -x c - -o .test || ( echo; echo \"Oops, looks like your compiler can't generate x86 code.\"; echo; echo \"Don't panic! You can use the LLVM or QEMU mode, but see docs/INSTALL first.\"; echo \"(To ignore this error, set AFL_NO_X86=1 and try again.)\"; echo; exit 1 )\n\t@rm -f .test\n\t@echo \"[+] Everything seems to be working, ready to compile.\"\n\nelse\n\ntest_x86:\n\t@echo \"[!] Note: skipping x86 compilation checks (AFL_NO_X86 set).\"\n\nendif\n\nafl-gcc: afl-gcc.c $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\tset -e; for i in afl-g++ afl-clang afl-clang++; do ln -sf afl-gcc $$i; done\n\nafl-as: afl-as.c afl-as.h $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\tln -sf afl-as as\n\nafl-fuzz: afl-fuzz.c $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\nafl-showmap: afl-showmap.c $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\nafl-tmin: afl-tmin.c $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\nafl-analyze: afl-analyze.c $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\nafl-gotcpu: afl-gotcpu.c $(COMM_HDR) | test_x86\n\t$(CC) $(CFLAGS) $@.c -o $@ $(LDFLAGS)\n\nifndef AFL_NO_X86\n\ntest_build: afl-gcc afl-as afl-showmap\n\t@echo \"[*] Testing the CC wrapper and instrumentation output...\"\n\tunset AFL_USE_ASAN AFL_USE_MSAN; AFL_QUIET=1 AFL_INST_RATIO=100 AFL_PATH=. ./$(TEST_CC) $(CFLAGS) test-instr.c -o test-instr $(LDFLAGS)\n\t./afl-showmap -m none -q -o .test-instr0 ./test-instr < /dev/null\n\techo 1 | ./afl-showmap -m none -q -o .test-instr1 ./test-instr\n\t@rm -f test-instr\n\t@cmp -s .test-instr0 .test-instr1; DR=\"$$?\"; rm -f .test-instr0 .test-instr1; if [ \"$$DR\" = \"0\" ]; then echo; echo \"Oops, the instrumentation does not seem to be behaving correctly!\"; echo; echo \"Please ping <lcamtuf@google.com> to troubleshoot the issue.\"; echo; exit 1; fi\n\t@echo \"[+] All right, the instrumentation seems to be working!\"\n\nelse\n\ntest_build: afl-gcc afl-as afl-showmap\n\t@echo \"[!] Note: skipping build tests (you may need to use LLVM or QEMU mode).\"\n\nendif\n\nall_done: test_build\n\t@if [ ! \"`which clang 2>/dev/null`\" = \"\" ]; then echo \"[+] LLVM users: see llvm_mode/README.llvm for a faster alternative to afl-gcc.\"; fi\n\t@echo \"[+] All done! Be sure to review README - it's pretty short and useful.\"\n\t@if [ \"`uname`\" = \"Darwin\" ]; then printf \"\\nWARNING: Fuzzing on MacOS X is slow because of the unusually high overhead of\\nfork() on this OS. Consider using Linux or *BSD. You can also use VirtualBox\\n(virtualbox.org) to put AFL inside a Linux or *BSD VM.\\n\\n\"; fi\n\t@! tty <&1 >/dev/null || printf \"\\033[0;30mNOTE: If you can read this, your terminal probably uses white background.\\nThis will make the UI hard to read. See docs/status_screen.txt for advice.\\033[0m\\n\" 2>/dev/null\n\n.NOTPARALLEL: clean\n\nclean:\n\trm -f $(PROGS) afl-as as afl-g++ afl-clang afl-clang++ *.o *~ a.out core core.[1-9][0-9]* *.stackdump test .test test-instr .test-instr0 .test-instr1 qemu_mode/qemu-2.10.0.tar.bz2 afl-qemu-trace\n\trm -rf out_dir qemu_mode/qemu-2.10.0\n\t$(MAKE) -C llvm_mode clean\n\t$(MAKE) -C libdislocator clean\n\t$(MAKE) -C libtokencap clean\n\ninstall: all\n\tmkdir -p -m 755 $${DESTDIR}$(BIN_PATH) $${DESTDIR}$(HELPER_PATH) $${DESTDIR}$(DOC_PATH) $${DESTDIR}$(MISC_PATH)\n\trm -f $${DESTDIR}$(BIN_PATH)/afl-plot.sh\n\tinstall -m 755 $(PROGS) $(SH_PROGS) $${DESTDIR}$(BIN_PATH)\n\trm -f $${DESTDIR}$(BIN_PATH)/afl-as\n\tif [ -f afl-qemu-trace ]; then install -m 755 afl-qemu-trace $${DESTDIR}$(BIN_PATH); fi\nifndef AFL_TRACE_PC\n\tif [ -f afl-clang-fast -a -f afl-llvm-pass.so -a -f afl-llvm-rt.o ]; then set -e; install -m 755 afl-clang-fast $${DESTDIR}$(BIN_PATH); ln -sf afl-clang-fast $${DESTDIR}$(BIN_PATH)/afl-clang-fast++; install -m 755 afl-llvm-pass.so afl-llvm-rt.o $${DESTDIR}$(HELPER_PATH); fi\nelse\n\tif [ -f afl-clang-fast -a -f afl-llvm-rt.o ]; then set -e; install -m 755 afl-clang-fast $${DESTDIR}$(BIN_PATH); ln -sf afl-clang-fast $${DESTDIR}$(BIN_PATH)/afl-clang-fast++; install -m 755 afl-llvm-rt.o $${DESTDIR}$(HELPER_PATH); fi\nendif\n\tif [ -f afl-llvm-rt-32.o ]; then set -e; install -m 755 afl-llvm-rt-32.o $${DESTDIR}$(HELPER_PATH); fi\n\tif [ -f afl-llvm-rt-64.o ]; then set -e; install -m 755 afl-llvm-rt-64.o $${DESTDIR}$(HELPER_PATH); fi\n\tset -e; for i in afl-g++ afl-clang afl-clang++; do ln -sf afl-gcc $${DESTDIR}$(BIN_PATH)/$$i; done\n\tinstall -m 755 afl-as $${DESTDIR}$(HELPER_PATH)\n\tln -sf afl-as $${DESTDIR}$(HELPER_PATH)/as\n\tinstall -m 644 README.md docs/ChangeLog docs/*.txt $${DESTDIR}$(DOC_PATH)\n\tcp -r testcases/ $${DESTDIR}$(MISC_PATH)\n\tcp -r dictionaries/ $${DESTDIR}$(MISC_PATH)\n\npublish: clean\n\ttest \"`basename $$PWD`\" = \"AFL\" || exit 1\n\ttest -f ~/www/afl/releases/$(PROGNAME)-$(VERSION).tgz; if [ \"$$?\" = \"0\" ]; then echo; echo \"Change program version in config.h, mmkay?\"; echo; exit 1; fi\n\tcd ..; rm -rf $(PROGNAME)-$(VERSION); cp -pr $(PROGNAME) $(PROGNAME)-$(VERSION); \\\n\t  tar -cvz -f ~/www/afl/releases/$(PROGNAME)-$(VERSION).tgz $(PROGNAME)-$(VERSION)\n\tchmod 644 ~/www/afl/releases/$(PROGNAME)-$(VERSION).tgz\n\t( cd ~/www/afl/releases/; ln -s -f $(PROGNAME)-$(VERSION).tgz $(PROGNAME)-latest.tgz )\n\tcat docs/README >~/www/afl/README.txt\n\tcat docs/status_screen.txt >~/www/afl/status_screen.txt\n\tcat docs/historical_notes.txt >~/www/afl/historical_notes.txt\n\tcat docs/technical_details.txt >~/www/afl/technical_details.txt\n\tcat docs/ChangeLog >~/www/afl/ChangeLog.txt\n\tcat docs/QuickStartGuide.txt >~/www/afl/QuickStartGuide.txt\n\techo -n \"$(VERSION)\" >~/www/afl/version.txt\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.06640625,
          "content": "# american fuzzy lop\n\n[![Build Status](https://travis-ci.org/google/AFL.svg?branch=master)](https://travis-ci.org/google/AFL)\n\nOriginally developed by Michal Zalewski <lcamtuf@google.com>.\n\nSee [QuickStartGuide.txt](docs/QuickStartGuide.txt) if you don't have time to read\nthis file.\n\n## 1) Challenges of guided fuzzing\n\nFuzzing is one of the most powerful and proven strategies for identifying\nsecurity issues in real-world software; it is responsible for the vast\nmajority of remote code execution and privilege escalation bugs found to date\nin security-critical software.\n\nUnfortunately, fuzzing is also relatively shallow; blind, random mutations\nmake it very unlikely to reach certain code paths in the tested code, leaving\nsome vulnerabilities firmly outside the reach of this technique.\n\nThere have been numerous attempts to solve this problem. One of the early\napproaches - pioneered by Tavis Ormandy - is corpus distillation. The method\nrelies on coverage signals to select a subset of interesting seeds from a\nmassive, high-quality corpus of candidate files, and then fuzz them by\ntraditional means. The approach works exceptionally well, but requires such\na corpus to be readily available. In addition, block coverage measurements\nprovide only a very simplistic understanding of program state, and are less\nuseful for guiding the fuzzing effort in the long haul.\n\nOther, more sophisticated research has focused on techniques such as program\nflow analysis (\"concolic execution\"), symbolic execution, or static analysis.\nAll these methods are extremely promising in experimental settings, but tend\nto suffer from reliability and performance problems in practical uses - and\ncurrently do not offer a viable alternative to \"dumb\" fuzzing techniques.\n\n## 2) The afl-fuzz approach\n\nAmerican Fuzzy Lop is a brute-force fuzzer coupled with an exceedingly simple\nbut rock-solid instrumentation-guided genetic algorithm. It uses a modified\nform of edge coverage to effortlessly pick up subtle, local-scale changes to\nprogram control flow.\n\nSimplifying a bit, the overall algorithm can be summed up as:\n\n  1) Load user-supplied initial test cases into the queue,\n\n  2) Take next input file from the queue,\n\n  3) Attempt to trim the test case to the smallest size that doesn't alter\n     the measured behavior of the program,\n\n  4) Repeatedly mutate the file using a balanced and well-researched variety\n     of traditional fuzzing strategies,\n\n  5) If any of the generated mutations resulted in a new state transition\n     recorded by the instrumentation, add mutated output as a new entry in the\n     queue.\n\n  6) Go to 2.\n\nThe discovered test cases are also periodically culled to eliminate ones that\nhave been obsoleted by newer, higher-coverage finds; and undergo several other\ninstrumentation-driven effort minimization steps.\n\nAs a side result of the fuzzing process, the tool creates a small,\nself-contained corpus of interesting test cases. These are extremely useful\nfor seeding other, labor- or resource-intensive testing regimes - for example,\nfor stress-testing browsers, office applications, graphics suites, or\nclosed-source tools.\n\nThe fuzzer is thoroughly tested to deliver out-of-the-box performance far\nsuperior to blind fuzzing or coverage-only tools.\n\n## 3) Instrumenting programs for use with AFL\n\nWhen source code is available, instrumentation can be injected by a companion\ntool that works as a drop-in replacement for gcc or clang in any standard build\nprocess for third-party code.\n\nThe instrumentation has a fairly modest performance impact; in conjunction with\nother optimizations implemented by afl-fuzz, most programs can be fuzzed as fast\nor even faster than possible with traditional tools.\n\nThe correct way to recompile the target program may vary depending on the\nspecifics of the build process, but a nearly-universal approach would be:\n\n```shell\n$ CC=/path/to/afl/afl-gcc ./configure\n$ make clean all\n```\n\nFor C++ programs, you'd would also want to set `CXX=/path/to/afl/afl-g++`.\n\nThe clang wrappers (afl-clang and afl-clang++) can be used in the same way;\nclang users may also opt to leverage a higher-performance instrumentation mode,\nas described in llvm_mode/README.llvm.\n\nWhen testing libraries, you need to find or write a simple program that reads\ndata from stdin or from a file and passes it to the tested library. In such a\ncase, it is essential to link this executable against a static version of the\ninstrumented library, or to make sure that the correct .so file is loaded at\nruntime (usually by setting `LD_LIBRARY_PATH`). The simplest option is a static\nbuild, usually possible via:\n\n```shell\n$ CC=/path/to/afl/afl-gcc ./configure --disable-shared\n```\n\nSetting `AFL_HARDEN=1` when calling 'make' will cause the CC wrapper to\nautomatically enable code hardening options that make it easier to detect\nsimple memory bugs. Libdislocator, a helper library included with AFL (see\nlibdislocator/README.dislocator) can help uncover heap corruption issues, too.\n\nPS. ASAN users are advised to review [notes_for_asan.txt](docs/notes_for_asan.txt) file for important\ncaveats.\n\n## 4) Instrumenting binary-only apps\n\nWhen source code is *NOT* available, the fuzzer offers experimental support for\nfast, on-the-fly instrumentation of black-box binaries. This is accomplished\nwith a version of QEMU running in the lesser-known \"user space emulation\" mode.\n\nQEMU is a project separate from AFL, but you can conveniently build the\nfeature by doing:\n\n```shell\n$ cd qemu_mode\n$ ./build_qemu_support.sh\n```\n\nFor additional instructions and caveats, see qemu_mode/README.qemu.\n\nThe mode is approximately 2-5x slower than compile-time instrumentation, is\nless conducive to parallelization, and may have some other quirks.\n\n## 5) Choosing initial test cases\n\nTo operate correctly, the fuzzer requires one or more starting file that\ncontains a good example of the input data normally expected by the targeted\napplication. There are two basic rules:\n\n  - Keep the files small. Under 1 kB is ideal, although not strictly necessary.\n    For a discussion of why size matters, see [perf_tips.txt](docs/perf_tips.txt).\n\n  - Use multiple test cases only if they are functionally different from\n    each other. There is no point in using fifty different vacation photos\n    to fuzz an image library.\n\nYou can find many good examples of starting files in the testcases/ subdirectory\nthat comes with this tool.\n\nPS. If a large corpus of data is available for screening, you may want to use\nthe afl-cmin utility to identify a subset of functionally distinct files that\nexercise different code paths in the target binary.\n\n## 6) Fuzzing binaries\n\nThe fuzzing process itself is carried out by the afl-fuzz utility. This program\nrequires a read-only directory with initial test cases, a separate place to\nstore its findings, plus a path to the binary to test.\n\nFor target binaries that accept input directly from stdin, the usual syntax is:\n\n```shell\n$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]\n```\n\nFor programs that take input from a file, use '@@' to mark the location in\nthe target's command line where the input file name should be placed. The\nfuzzer will substitute this for you:\n\n```shell\n$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@\n```\n\nYou can also use the -f option to have the mutated data written to a specific\nfile. This is useful if the program expects a particular file extension or so.\n\nNon-instrumented binaries can be fuzzed in the QEMU mode (add -Q in the command\nline) or in a traditional, blind-fuzzer mode (specify -n).\n\nYou can use -t and -m to override the default timeout and memory limit for the\nexecuted process; rare examples of targets that may need these settings touched\ninclude compilers and video decoders.\n\nTips for optimizing fuzzing performance are discussed in [perf_tips.txt](docs/perf_tips.txt).\n\nNote that afl-fuzz starts by performing an array of deterministic fuzzing\nsteps, which can take several days, but tend to produce neat test cases. If you\nwant quick & dirty results right away - akin to zzuf and other traditional\nfuzzers - add the -d option to the command line.\n\n## 7) Interpreting output\n\nSee the [status_screen.txt](docs/status_screen.txt) file for information on\nhow to interpret the displayed stats and monitor the health of the process.\nBe sure to consult this file especially if any UI elements are highlighted in\nred.\n\nThe fuzzing process will continue until you press Ctrl-C. At minimum, you want\nto allow the fuzzer to complete one queue cycle, which may take anywhere from a\ncouple of hours to a week or so.\n\nThere are three subdirectories created within the output directory and updated\nin real time:\n\n  - queue/   - test cases for every distinctive execution path, plus all the\n               starting files given by the user. This is the synthesized corpus\n               mentioned in section 2.\n               Before using this corpus for any other purposes, you can shrink\n               it to a smaller size using the afl-cmin tool. The tool will find\n               a smaller subset of files offering equivalent edge coverage.\n\n  - crashes/ - unique test cases that cause the tested program to receive a\n               fatal signal (e.g., SIGSEGV, SIGILL, SIGABRT). The entries are\n               grouped by the received signal.\n\n  - hangs/   - unique test cases that cause the tested program to time out. The\n               default time limit before something is classified as a hang is\n               the larger of 1 second and the value of the -t parameter.\n               The value can be fine-tuned by setting AFL_HANG_TMOUT, but this\n               is rarely necessary.\n\nCrashes and hangs are considered \"unique\" if the associated execution paths\ninvolve any state transitions not seen in previously-recorded faults. If a\nsingle bug can be reached in multiple ways, there will be some count inflation\nearly in the process, but this should quickly taper off.\n\nThe file names for crashes and hangs are correlated with parent, non-faulting\nqueue entries. This should help with debugging.\n\nWhen you can't reproduce a crash found by afl-fuzz, the most likely cause is\nthat you are not setting the same memory limit as used by the tool. Try:\n\n```shell\n$ LIMIT_MB=50\n$ ( ulimit -Sv $[LIMIT_MB << 10]; /path/to/tested_binary ... )\n```\n\nChange LIMIT_MB to match the -m parameter passed to afl-fuzz. On OpenBSD,\nalso change -Sv to -Sd.\n\nAny existing output directory can be also used to resume aborted jobs; try:\n\n```shell\n$ ./afl-fuzz -i- -o existing_output_dir [...etc...]\n```\n\nIf you have gnuplot installed, you can also generate some pretty graphs for any\nactive fuzzing task using afl-plot. For an example of how this looks like,\nsee [http://lcamtuf.coredump.cx/afl/plot/](http://lcamtuf.coredump.cx/afl/plot/).\n\n## 8) Parallelized fuzzing\n\nEvery instance of afl-fuzz takes up roughly one core. This means that on\nmulti-core systems, parallelization is necessary to fully utilize the hardware.\nFor tips on how to fuzz a common target on multiple cores or multiple networked\nmachines, please refer to [parallel_fuzzing.txt](docs/parallel_fuzzing.txt).\n\nThe parallel fuzzing mode also offers a simple way for interfacing AFL to other\nfuzzers, to symbolic or concolic execution engines, and so forth; again, see the\nlast section of [parallel_fuzzing.txt](docs/parallel_fuzzing.txt) for tips.\n\n## 9) Fuzzer dictionaries\n\nBy default, afl-fuzz mutation engine is optimized for compact data formats -\nsay, images, multimedia, compressed data, regular expression syntax, or shell\nscripts. It is somewhat less suited for languages with particularly verbose and\nredundant verbiage - notably including HTML, SQL, or JavaScript.\n\nTo avoid the hassle of building syntax-aware tools, afl-fuzz provides a way to\nseed the fuzzing process with an optional dictionary of language keywords,\nmagic headers, or other special tokens associated with the targeted data type\n-- and use that to reconstruct the underlying grammar on the go:\n\n  [http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html](http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html)\n\nTo use this feature, you first need to create a dictionary in one of the two\nformats discussed in dictionaries/README.dictionaries; and then point the fuzzer\nto it via the -x option in the command line.\n\n(Several common dictionaries are already provided in that subdirectory, too.)\n\nThere is no way to provide more structured descriptions of the underlying\nsyntax, but the fuzzer will likely figure out some of this based on the\ninstrumentation feedback alone. This actually works in practice, say:\n\n  [http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html](http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html)\n\nPS. Even when no explicit dictionary is given, afl-fuzz will try to extract\nexisting syntax tokens in the input corpus by watching the instrumentation\nvery closely during deterministic byte flips. This works for some types of\nparsers and grammars, but isn't nearly as good as the -x mode.\n\nIf a dictionary is really hard to come by, another option is to let AFL run\nfor a while, and then use the token capture library that comes as a companion\nutility with AFL. For that, see libtokencap/README.tokencap.\n\n## 10) Crash triage\n\nThe coverage-based grouping of crashes usually produces a small data set that\ncan be quickly triaged manually or with a very simple GDB or Valgrind script.\nEvery crash is also traceable to its parent non-crashing test case in the\nqueue, making it easier to diagnose faults.\n\nHaving said that, it's important to acknowledge that some fuzzing crashes can be\ndifficult to quickly evaluate for exploitability without a lot of debugging and\ncode analysis work. To assist with this task, afl-fuzz supports a very unique\n\"crash exploration\" mode enabled with the -C flag.\n\nIn this mode, the fuzzer takes one or more crashing test cases as the input,\nand uses its feedback-driven fuzzing strategies to very quickly enumerate all\ncode paths that can be reached in the program while keeping it in the\ncrashing state.\n\nMutations that do not result in a crash are rejected; so are any changes that\ndo not affect the execution path.\n\nThe output is a small corpus of files that can be very rapidly examined to see\nwhat degree of control the attacker has over the faulting address, or whether\nit is possible to get past an initial out-of-bounds read - and see what lies\nbeneath.\n\nOh, one more thing: for test case minimization, give afl-tmin a try. The tool\ncan be operated in a very simple way:\n\n```shell\n$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]\n```\n\nThe tool works with crashing and non-crashing test cases alike. In the crash\nmode, it will happily accept instrumented and non-instrumented binaries. In the\nnon-crashing mode, the minimizer relies on standard AFL instrumentation to make\nthe file simpler without altering the execution path.\n\nThe minimizer accepts the -m, -t, -f and @@ syntax in a manner compatible with\nafl-fuzz.\n\nAnother recent addition to AFL is the afl-analyze tool. It takes an input\nfile, attempts to sequentially flip bytes, and observes the behavior of the\ntested program. It then color-codes the input based on which sections appear to\nbe critical, and which are not; while not bulletproof, it can often offer quick\ninsights into complex file formats. More info about its operation can be found\nnear the end of [technical_details.txt](docs/technical_details.txt).\n\n## 11) Going beyond crashes\n\nFuzzing is a wonderful and underutilized technique for discovering non-crashing\ndesign and implementation errors, too. Quite a few interesting bugs have been\nfound by modifying the target programs to call abort() when, say:\n\n  - Two bignum libraries produce different outputs when given the same\n    fuzzer-generated input,\n\n  - An image library produces different outputs when asked to decode the same\n    input image several times in a row,\n\n  - A serialization / deserialization library fails to produce stable outputs\n    when iteratively serializing and deserializing fuzzer-supplied data,\n\n  - A compression library produces an output inconsistent with the input file\n    when asked to compress and then decompress a particular blob.\n\nImplementing these or similar sanity checks usually takes very little time;\nif you are the maintainer of a particular package, you can make this code\nconditional with `#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION` (a flag also\nshared with libfuzzer) or `#ifdef __AFL_COMPILER` (this one is just for AFL).\n\n## 12) Common-sense risks\n\nPlease keep in mind that, similarly to many other computationally-intensive\ntasks, fuzzing may put strain on your hardware and on the OS. In particular:\n\n  - Your CPU will run hot and will need adequate cooling. In most cases, if\n    cooling is insufficient or stops working properly, CPU speeds will be\n    automatically throttled. That said, especially when fuzzing on less\n    suitable hardware (laptops, smartphones, etc), it's not entirely impossible\n    for something to blow up.\n\n  - Targeted programs may end up erratically grabbing gigabytes of memory or\n    filling up disk space with junk files. AFL tries to enforce basic memory\n    limits, but can't prevent each and every possible mishap. The bottom line\n    is that you shouldn't be fuzzing on systems where the prospect of data loss\n    is not an acceptable risk.\n\n  - Fuzzing involves billions of reads and writes to the filesystem. On modern\n    systems, this will be usually heavily cached, resulting in fairly modest\n    \"physical\" I/O - but there are many factors that may alter this equation.\n    It is your responsibility to monitor for potential trouble; with very heavy\n    I/O, the lifespan of many HDDs and SSDs may be reduced.\n\n    A good way to monitor disk I/O on Linux is the 'iostat' command:\n\n```shell\n    $ iostat -d 3 -x -k [...optional disk ID...]\n```\n\n## 13) Known limitations & areas for improvement\n\nHere are some of the most important caveats for AFL:\n\n  - AFL detects faults by checking for the first spawned process dying due to\n    a signal (SIGSEGV, SIGABRT, etc). Programs that install custom handlers for\n    these signals may need to have the relevant code commented out. In the same\n    vein, faults in child processed spawned by the fuzzed target may evade\n    detection unless you manually add some code to catch that.\n\n  - As with any other brute-force tool, the fuzzer offers limited coverage if\n    encryption, checksums, cryptographic signatures, or compression are used to\n    wholly wrap the actual data format to be tested.\n\n    To work around this, you can comment out the relevant checks (see\n    experimental/libpng_no_checksum/ for inspiration); if this is not possible,\n    you can also write a postprocessor, as explained in\n    experimental/post_library/.\n\n  - There are some unfortunate trade-offs with ASAN and 64-bit binaries. This\n    isn't due to any specific fault of afl-fuzz; see [notes_for_asan.txt](docs/notes_for_asan.txt)\n    for tips.\n\n  - There is no direct support for fuzzing network services, background\n    daemons, or interactive apps that require UI interaction to work. You may\n    need to make simple code changes to make them behave in a more traditional\n    way. Preeny may offer a relatively simple option, too - see:\n    https://github.com/zardus/preeny\n\n    Some useful tips for modifying network-based services can be also found at:\n    https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop\n\n  - AFL doesn't output human-readable coverage data. If you want to monitor\n    coverage, use afl-cov from Michael Rash: https://github.com/mrash/afl-cov\n\n  - Occasionally, sentient machines rise against their creators. If this\n    happens to you, please consult http://lcamtuf.coredump.cx/prep/.\n\nBeyond this, see INSTALL for platform-specific tips.\n\n## 14) Special thanks\n\nMany of the improvements to afl-fuzz wouldn't be possible without feedback,\nbug reports, or patches from:\n\n```\n  Jann Horn                             Hanno Boeck\n  Felix Groebert                        Jakub Wilk\n  Richard W. M. Jones                   Alexander Cherepanov\n  Tom Ritter                            Hovik Manucharyan\n  Sebastian Roschke                     Eberhard Mattes\n  Padraig Brady                         Ben Laurie\n  @dronesec                             Luca Barbato\n  Tobias Ospelt                         Thomas Jarosch\n  Martin Carpenter                      Mudge Zatko\n  Joe Zbiciak                           Ryan Govostes\n  Michael Rash                          William Robinet\n  Jonathan Gray                         Filipe Cabecinhas\n  Nico Weber                            Jodie Cunningham\n  Andrew Griffiths                      Parker Thompson\n  Jonathan Neuschfer                    Tyler Nighswander\n  Ben Nagy                              Samir Aguiar\n  Aidan Thornton                        Aleksandar Nikolich\n  Sam Hakim                             Laszlo Szekeres\n  David A. Wheeler                      Turo Lamminen\n  Andreas Stieger                       Richard Godbee\n  Louis Dassy                           teor2345\n  Alex Moneger                          Dmitry Vyukov\n  Keegan McAllister                     Kostya Serebryany\n  Richo Healey                          Martijn Bogaard\n  rc0r                                  Jonathan Foote\n  Christian Holler                      Dominique Pelle\n  Jacek Wielemborek                     Leo Barnes\n  Jeremy Barnes                         Jeff Trull\n  Guillaume Endignoux                   ilovezfs\n  Daniel Godas-Lopez                    Franjo Ivancic\n  Austin Seipp                          Daniel Komaromy\n  Daniel Binderman                      Jonathan Metzman\n  Vegard Nossum                         Jan Kneschke\n  Kurt Roeckx                           Marcel Bohme\n  Van-Thuan Pham                        Abhik Roychoudhury\n  Joshua J. Drake                       Toby Hutton\n  Rene Freingruber                      Sergey Davidoff\n  Sami Liedes                           Craig Young\n  Andrzej Jackowski                     Daniel Hodson\n```\n\nThank you!\n\n## 15) Contact\n\nQuestions? Concerns? Bug reports? Please use GitHub.\n\nThere is also a mailing list for the project; to join, send a mail to\n<afl-users+subscribe@googlegroups.com>. Or, if you prefer to browse\narchives first, try: [https://groups.google.com/group/afl-users](https://groups.google.com/group/afl-users).\n"
        },
        {
          "name": "afl-analyze.c",
          "type": "blob",
          "size": 23.751953125,
          "content": "/*\n  Copyright 2016 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - file format analyzer\n   -----------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   A nifty utility that grabs an input file and takes a stab at explaining\n   its structure by observing how changes to it affect the execution path.\n\n   If the output scrolls past the edge of the screen, pipe it to 'less -r'.\n\n*/\n\n#define AFL_MAIN\n#include \"android-ashmem.h\"\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <ctype.h>\n\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/shm.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n\nstatic s32 child_pid;                 /* PID of the tested program         */\n\nstatic u8* trace_bits;                /* SHM with instrumentation bitmap   */\n\nstatic u8 *in_file,                   /* Analyzer input test case          */\n          *prog_in,                   /* Targeted program input file       */\n          *target_path,               /* Path to target binary             */\n          *doc_path;                  /* Path to docs                      */\n\nstatic u8 *in_data;                   /* Input data for analysis           */\n\nstatic u32 in_len,                    /* Input data length                 */\n           orig_cksum,                /* Original checksum                 */\n           total_execs,               /* Total number of execs             */\n           exec_hangs,                /* Total number of hangs             */\n           exec_tmout = EXEC_TIMEOUT; /* Exec timeout (ms)                 */\n\nstatic u64 mem_limit = MEM_LIMIT;     /* Memory limit (MB)                 */\n\nstatic s32 shm_id,                    /* ID of the SHM region              */\n           dev_null_fd = -1;          /* FD to /dev/null                   */\n\nstatic u8  edges_only,                /* Ignore hit counts?                */\n           use_hex_offsets,           /* Show hex offsets?                 */\n           use_stdin = 1;             /* Use stdin for program input?      */\n\nstatic volatile u8\n           stop_soon,                 /* Ctrl-C pressed?                   */\n           child_timed_out;           /* Child timed out?                  */\n\n\n/* Constants used for describing byte behavior. */\n\n#define RESP_NONE       0x00          /* Changing byte is a no-op.         */\n#define RESP_MINOR      0x01          /* Some changes have no effect.      */\n#define RESP_VARIABLE   0x02          /* Changes produce variable paths.   */\n#define RESP_FIXED      0x03          /* Changes produce fixed patterns.   */\n\n#define RESP_LEN        0x04          /* Potential length field            */\n#define RESP_CKSUM      0x05          /* Potential checksum                */\n#define RESP_SUSPECT    0x06          /* Potential \"suspect\" blob          */\n\n\n/* Classify tuple counts. This is a slow & naive version, but good enough here. */\n\nstatic u8 count_class_lookup[256] = {\n\n  [0]           = 0,\n  [1]           = 1,\n  [2]           = 2,\n  [3]           = 4,\n  [4 ... 7]     = 8,\n  [8 ... 15]    = 16,\n  [16 ... 31]   = 32,\n  [32 ... 127]  = 64,\n  [128 ... 255] = 128\n\n};\n\nstatic void classify_counts(u8* mem) {\n\n  u32 i = MAP_SIZE;\n\n  if (edges_only) {\n\n    while (i--) {\n      if (*mem) *mem = 1;\n      mem++;\n    }\n\n  } else {\n\n    while (i--) {\n      *mem = count_class_lookup[*mem];\n      mem++;\n    }\n\n  }\n\n}\n\n\n/* See if any bytes are set in the bitmap. */\n\nstatic inline u8 anything_set(void) {\n\n  u32* ptr = (u32*)trace_bits;\n  u32  i   = (MAP_SIZE >> 2);\n\n  while (i--) if (*(ptr++)) return 1;\n\n  return 0;\n\n}\n\n\n/* Get rid of shared memory and temp files (atexit handler). */\n\nstatic void remove_shm(void) {\n\n  unlink(prog_in); /* Ignore errors */\n  shmctl(shm_id, IPC_RMID, NULL);\n\n}\n\n\n/* Configure shared memory. */\n\nstatic void setup_shm(void) {\n\n  u8* shm_str;\n\n  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);\n\n  if (shm_id < 0) PFATAL(\"shmget() failed\");\n\n  atexit(remove_shm);\n\n  shm_str = alloc_printf(\"%d\", shm_id);\n\n  setenv(SHM_ENV_VAR, shm_str, 1);\n\n  ck_free(shm_str);\n\n  trace_bits = shmat(shm_id, NULL, 0);\n  \n  if (trace_bits == (void *)-1) PFATAL(\"shmat() failed\");\n\n}\n\n\n/* Read initial file. */\n\nstatic void read_initial_file(void) {\n\n  struct stat st;\n  s32 fd = open(in_file, O_RDONLY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", in_file);\n\n  if (fstat(fd, &st) || !st.st_size)\n    FATAL(\"Zero-sized input file.\");\n\n  if (st.st_size >= TMIN_MAX_FILE)\n    FATAL(\"Input file is too large (%u MB max)\", TMIN_MAX_FILE / 1024 / 1024);\n\n  in_len  = st.st_size;\n  in_data = ck_alloc_nozero(in_len);\n\n  ck_read(fd, in_data, in_len, in_file);\n\n  close(fd);\n\n  OKF(\"Read %u byte%s from '%s'.\", in_len, in_len == 1 ? \"\" : \"s\", in_file);\n\n}\n\n\n/* Write output file. */\n\nstatic s32 write_to_file(u8* path, u8* mem, u32 len) {\n\n  s32 ret;\n\n  unlink(path); /* Ignore errors */\n\n  ret = open(path, O_RDWR | O_CREAT | O_EXCL, 0600);\n\n  if (ret < 0) PFATAL(\"Unable to create '%s'\", path);\n\n  ck_write(ret, mem, len, path);\n\n  lseek(ret, 0, SEEK_SET);\n\n  return ret;\n\n}\n\n\n/* Handle timeout signal. */\n\nstatic void handle_timeout(int sig) {\n\n  child_timed_out = 1;\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}\n\n\n/* Execute target application. Returns exec checksum, or 0 if program\n   times out. */\n\nstatic u32 run_target(char** argv, u8* mem, u32 len, u8 first_run) {\n\n  static struct itimerval it;\n  int status = 0;\n\n  s32 prog_in_fd;\n  u32 cksum;\n\n  memset(trace_bits, 0, MAP_SIZE);\n  MEM_BARRIER();\n\n  prog_in_fd = write_to_file(prog_in, mem, len);\n\n  child_pid = fork();\n\n  if (child_pid < 0) PFATAL(\"fork() failed\");\n\n  if (!child_pid) {\n\n    struct rlimit r;\n\n    if (dup2(use_stdin ? prog_in_fd : dev_null_fd, 0) < 0 ||\n        dup2(dev_null_fd, 1) < 0 ||\n        dup2(dev_null_fd, 2) < 0) {\n\n      *(u32*)trace_bits = EXEC_FAIL_SIG;\n      PFATAL(\"dup2() failed\");\n\n    }\n\n    close(dev_null_fd);\n    close(prog_in_fd);\n\n    if (mem_limit) {\n\n      r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;\n\n#ifdef RLIMIT_AS\n\n      setrlimit(RLIMIT_AS, &r); /* Ignore errors */\n\n#else\n\n      setrlimit(RLIMIT_DATA, &r); /* Ignore errors */\n\n#endif /* ^RLIMIT_AS */\n\n    }\n\n    r.rlim_max = r.rlim_cur = 0;\n    setrlimit(RLIMIT_CORE, &r); /* Ignore errors */\n\n    execv(target_path, argv);\n\n    *(u32*)trace_bits = EXEC_FAIL_SIG;\n    exit(0);\n\n  }\n\n  close(prog_in_fd);\n\n  /* Configure timeout, wait for child, cancel timeout. */\n\n  child_timed_out = 0;\n  it.it_value.tv_sec = (exec_tmout / 1000);\n  it.it_value.tv_usec = (exec_tmout % 1000) * 1000;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  if (waitpid(child_pid, &status, 0) <= 0) FATAL(\"waitpid() failed\");\n\n  child_pid = 0;\n  it.it_value.tv_sec = 0;\n  it.it_value.tv_usec = 0;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  MEM_BARRIER();\n\n  /* Clean up bitmap, analyze exit condition, etc. */\n\n  if (*(u32*)trace_bits == EXEC_FAIL_SIG)\n    FATAL(\"Unable to execute '%s'\", argv[0]);\n\n  classify_counts(trace_bits);\n  total_execs++;\n\n  if (stop_soon) {\n    SAYF(cRST cLRD \"\\n+++ Analysis aborted by user +++\\n\" cRST);\n    exit(1);\n  }\n\n  /* Always discard inputs that time out. */\n\n  if (child_timed_out) {\n\n    exec_hangs++;\n    return 0;\n\n  }\n\n  cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n  /* We don't actually care if the target is crashing or not,\n     except that when it does, the checksum should be different. */\n\n  if (WIFSIGNALED(status) ||\n      (WIFEXITED(status) && WEXITSTATUS(status) == MSAN_ERROR) ||\n      (WIFEXITED(status) && WEXITSTATUS(status))) {\n\n    cksum ^= 0xffffffff;\n\n  }\n\n  if (first_run) orig_cksum = cksum;\n\n  return cksum;\n\n}\n\n\n#ifdef USE_COLOR\n\n/* Helper function to display a human-readable character. */\n\nstatic void show_char(u8 val) {\n\n  switch (val) {\n\n    case 0 ... 32:\n    case 127 ... 255: SAYF(\"#%02x\", val); break;\n\n    default: SAYF(\" %c \", val);\n\n  }\n\n}\n\n\n/* Show the legend */\n\nstatic void show_legend(void) {\n\n  SAYF(\"    \" cLGR bgGRA \" 01 \" cRST \" - no-op block              \"\n              cBLK bgLGN \" 01 \" cRST \" - suspected length field\\n\"\n       \"    \" cBRI bgGRA \" 01 \" cRST \" - superficial content      \"\n              cBLK bgYEL \" 01 \" cRST \" - suspected cksum or magic int\\n\"\n       \"    \" cBLK bgCYA \" 01 \" cRST \" - critical stream          \"\n              cBLK bgLRD \" 01 \" cRST \" - suspected checksummed block\\n\"\n       \"    \" cBLK bgMGN \" 01 \" cRST \" - \\\"magic value\\\" section\\n\\n\");\n\n}\n\n#endif /* USE_COLOR */\n\n\n/* Interpret and report a pattern in the input file. */\n\nstatic void dump_hex(u8* buf, u32 len, u8* b_data) {\n\n  u32 i;\n\n  for (i = 0; i < len; i++) {\n\n#ifdef USE_COLOR\n    u32 rlen = 1, off;\n#else\n    u32 rlen = 1;\n#endif /* ^USE_COLOR */\n\n    u8  rtype = b_data[i] & 0x0f;\n\n    /* Look ahead to determine the length of run. */\n\n    while (i + rlen < len && (b_data[i] >> 7) == (b_data[i + rlen] >> 7)) {\n\n      if (rtype < (b_data[i + rlen] & 0x0f)) rtype = b_data[i + rlen] & 0x0f;\n      rlen++;\n\n    }\n\n    /* Try to do some further classification based on length & value. */\n\n    if (rtype == RESP_FIXED) {\n\n      switch (rlen) {\n\n        case 2: {\n\n            u16 val = *(u16*)(in_data + i);\n\n            /* Small integers may be length fields. */\n\n            if (val && (val <= in_len || SWAP16(val) <= in_len)) {\n              rtype = RESP_LEN;\n              break;\n            }\n\n            /* Uniform integers may be checksums. */\n\n            if (val && abs(in_data[i] - in_data[i + 1]) > 32) {\n              rtype = RESP_CKSUM;\n              break;\n            }\n\n            break;\n\n          }\n\n        case 4: {\n\n            u32 val = *(u32*)(in_data + i);\n\n            /* Small integers may be length fields. */\n\n            if (val && (val <= in_len || SWAP32(val) <= in_len)) {\n              rtype = RESP_LEN;\n              break;\n            }\n\n            /* Uniform integers may be checksums. */\n\n            if (val && (in_data[i] >> 7 != in_data[i + 1] >> 7 ||\n                in_data[i] >> 7 != in_data[i + 2] >> 7 ||\n                in_data[i] >> 7 != in_data[i + 3] >> 7)) {\n              rtype = RESP_CKSUM;\n              break;\n            }\n\n            break;\n\n          }\n\n        case 1: case 3: case 5 ... MAX_AUTO_EXTRA - 1: break;\n\n        default: rtype = RESP_SUSPECT;\n\n      }\n\n    }\n\n    /* Print out the entire run. */\n\n#ifdef USE_COLOR\n\n    for (off = 0; off < rlen; off++) {\n\n      /* Every 16 digits, display offset. */\n\n      if (!((i + off) % 16)) {\n\n        if (off) SAYF(cRST cLCY \">\");\n\n        if (use_hex_offsets)\n          SAYF(cRST cGRA \"%s[%06x] \" cRST, (i + off) ? \"\\n\" : \"\", i + off);\n        else\n          SAYF(cRST cGRA \"%s[%06u] \" cRST, (i + off) ? \"\\n\" : \"\", i + off);\n\n      }\n\n      switch (rtype) {\n\n        case RESP_NONE:     SAYF(cLGR bgGRA); break;\n        case RESP_MINOR:    SAYF(cBRI bgGRA); break;\n        case RESP_VARIABLE: SAYF(cBLK bgCYA); break;\n        case RESP_FIXED:    SAYF(cBLK bgMGN); break;\n        case RESP_LEN:      SAYF(cBLK bgLGN); break;\n        case RESP_CKSUM:    SAYF(cBLK bgYEL); break;\n        case RESP_SUSPECT:  SAYF(cBLK bgLRD); break;\n\n      }\n\n      show_char(in_data[i + off]);\n\n      if (off != rlen - 1 && (i + off + 1) % 16) SAYF(\" \"); else SAYF(cRST \" \");\n\n    }\n\n#else\n\n    if (use_hex_offsets)\n      SAYF(\"    Offset %x, length %u: \", i, rlen);\n    else\n      SAYF(\"    Offset %u, length %u: \", i, rlen);\n\n    switch (rtype) {\n\n      case RESP_NONE:     SAYF(\"no-op block\\n\"); break;\n      case RESP_MINOR:    SAYF(\"superficial content\\n\"); break;\n      case RESP_VARIABLE: SAYF(\"critical stream\\n\"); break;\n      case RESP_FIXED:    SAYF(\"\\\"magic value\\\" section\\n\"); break;\n      case RESP_LEN:      SAYF(\"suspected length field\\n\"); break;\n      case RESP_CKSUM:    SAYF(\"suspected cksum or magic int\\n\"); break;\n      case RESP_SUSPECT:  SAYF(\"suspected checksummed block\\n\"); break;\n\n    }\n\n#endif /* ^USE_COLOR */\n\n    i += rlen - 1;\n\n  }\n\n#ifdef USE_COLOR\n  SAYF(cRST \"\\n\");\n#endif /* USE_COLOR */\n\n}\n\n\n\n/* Actually analyze! */\n\nstatic void analyze(char** argv) {\n\n  u32 i;\n  u32 boring_len = 0, prev_xff = 0, prev_x01 = 0, prev_s10 = 0, prev_a10 = 0;\n\n  u8* b_data = ck_alloc(in_len + 1);\n  u8  seq_byte = 0;\n\n  b_data[in_len] = 0xff; /* Intentional terminator. */\n\n  ACTF(\"Analyzing input file (this may take a while)...\\n\");\n\n#ifdef USE_COLOR\n  show_legend();\n#endif /* USE_COLOR */\n\n  for (i = 0; i < in_len; i++) {\n\n    u32 xor_ff, xor_01, sub_10, add_10;\n    u8  xff_orig, x01_orig, s10_orig, a10_orig;\n\n    /* Perform walking byte adjustments across the file. We perform four\n       operations designed to elicit some response from the underlying\n       code. */\n\n    in_data[i] ^= 0xff;\n    xor_ff = run_target(argv, in_data, in_len, 0);\n\n    in_data[i] ^= 0xfe;\n    xor_01 = run_target(argv, in_data, in_len, 0);\n\n    in_data[i] = (in_data[i] ^ 0x01) - 0x10;\n    sub_10 = run_target(argv, in_data, in_len, 0);\n\n    in_data[i] += 0x20;\n    add_10 = run_target(argv, in_data, in_len, 0);\n    in_data[i] -= 0x10;\n\n    /* Classify current behavior. */\n\n    xff_orig = (xor_ff == orig_cksum);\n    x01_orig = (xor_01 == orig_cksum);\n    s10_orig = (sub_10 == orig_cksum);\n    a10_orig = (add_10 == orig_cksum);\n\n    if (xff_orig && x01_orig && s10_orig && a10_orig) {\n\n      b_data[i] = RESP_NONE;\n      boring_len++;\n\n    } else if (xff_orig || x01_orig || s10_orig || a10_orig) {\n\n      b_data[i] = RESP_MINOR;\n      boring_len++;\n\n    } else if (xor_ff == xor_01 && xor_ff == sub_10 && xor_ff == add_10) {\n\n      b_data[i] = RESP_FIXED;\n\n    } else b_data[i] = RESP_VARIABLE;\n\n    /* When all checksums change, flip most significant bit of b_data. */\n\n    if (prev_xff != xor_ff && prev_x01 != xor_01 &&\n        prev_s10 != sub_10 && prev_a10 != add_10) seq_byte ^= 0x80;\n\n    b_data[i] |= seq_byte;\n\n    prev_xff = xor_ff;\n    prev_x01 = xor_01;\n    prev_s10 = sub_10;\n    prev_a10 = add_10;\n\n  } \n\n  dump_hex(in_data, in_len, b_data);\n\n  SAYF(\"\\n\");\n\n  OKF(\"Analysis complete. Interesting bits: %0.02f%% of the input file.\",\n      100.0 - ((double)boring_len * 100) / in_len);\n\n  if (exec_hangs)\n    WARNF(cLRD \"Encountered %u timeouts - results may be skewed.\" cRST,\n          exec_hangs);\n\n  ck_free(b_data);\n\n}\n\n\n\n/* Handle Ctrl-C and the like. */\n\nstatic void handle_stop_sig(int sig) {\n\n  stop_soon = 1;\n\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}\n\n\n/* Do basic preparations - persistent fds, filenames, etc. */\n\nstatic void set_up_environment(void) {\n\n  u8* x;\n\n  dev_null_fd = open(\"/dev/null\", O_RDWR);\n  if (dev_null_fd < 0) PFATAL(\"Unable to open /dev/null\");\n\n  if (!prog_in) {\n\n    u8* use_dir = \".\";\n\n    if (access(use_dir, R_OK | W_OK | X_OK)) {\n\n      use_dir = getenv(\"TMPDIR\");\n      if (!use_dir) use_dir = \"/tmp\";\n\n    }\n\n    prog_in = alloc_printf(\"%s/.afl-analyze-temp-%u\", use_dir, getpid());\n\n  }\n\n  /* Set sane defaults... */\n\n  x = getenv(\"ASAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"abort_on_error=1\"))\n      FATAL(\"Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!\");\n\n    if (!strstr(x, \"symbolize=0\"))\n      FATAL(\"Custom ASAN_OPTIONS set without symbolize=0 - please fix!\");\n\n  }\n\n  x = getenv(\"MSAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"exit_code=\" STRINGIFY(MSAN_ERROR)))\n      FATAL(\"Custom MSAN_OPTIONS set without exit_code=\"\n            STRINGIFY(MSAN_ERROR) \" - please fix!\");\n\n    if (!strstr(x, \"symbolize=0\"))\n      FATAL(\"Custom MSAN_OPTIONS set without symbolize=0 - please fix!\");\n\n  }\n\n  setenv(\"ASAN_OPTIONS\", \"abort_on_error=1:\"\n                         \"detect_leaks=0:\"\n                         \"symbolize=0:\"\n                         \"allocator_may_return_null=1\", 0);\n\n  setenv(\"MSAN_OPTIONS\", \"exit_code=\" STRINGIFY(MSAN_ERROR) \":\"\n                         \"symbolize=0:\"\n                         \"abort_on_error=1:\"\n                         \"allocator_may_return_null=1:\"\n                         \"msan_track_origins=0\", 0);\n\n  if (getenv(\"AFL_PRELOAD\")) {\n    setenv(\"LD_PRELOAD\", getenv(\"AFL_PRELOAD\"), 1);\n    setenv(\"DYLD_INSERT_LIBRARIES\", getenv(\"AFL_PRELOAD\"), 1);\n  }\n\n}\n\n\n/* Setup signal handlers, duh. */\n\nstatic void setup_signal_handlers(void) {\n\n  struct sigaction sa;\n\n  sa.sa_handler   = NULL;\n  sa.sa_flags     = SA_RESTART;\n  sa.sa_sigaction = NULL;\n\n  sigemptyset(&sa.sa_mask);\n\n  /* Various ways of saying \"stop\". */\n\n  sa.sa_handler = handle_stop_sig;\n  sigaction(SIGHUP, &sa, NULL);\n  sigaction(SIGINT, &sa, NULL);\n  sigaction(SIGTERM, &sa, NULL);\n\n  /* Exec timeout notifications. */\n\n  sa.sa_handler = handle_timeout;\n  sigaction(SIGALRM, &sa, NULL);\n\n}\n\n\n/* Detect @@ in args. */\n\nstatic void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = getcwd(NULL, 0);\n\n  if (!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if (aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      /* Be sure that we're always using fully-qualified paths. */\n\n      if (prog_in[0] == '/') aa_subst = prog_in;\n      else aa_subst = alloc_printf(\"%s/%s\", cwd, prog_in);\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      if (prog_in[0] != '/') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  SAYF(\"\\n%s [ options ] -- /path/to/target_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -i file       - input test case to be analyzed by the tool\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -f file       - input file read by the tested program (stdin)\\n\"\n       \"  -t msec       - timeout for each run (%u ms)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n       \"  -Q            - use binary-only instrumentation (QEMU mode)\\n\\n\"\n\n       \"Analysis settings:\\n\\n\"\n\n       \"  -e            - look for edge coverage only, ignore hit counts\\n\\n\"\n\n       \"Other stuff:\\n\\n\"\n\n       \"  -V            - show version number and exit\\n\\n\"\n\n       \"For additional tips, please consult %s/README.\\n\\n\",\n\n       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Find binary. */\n\nstatic void find_binary(u8* fname) {\n\n  u8* env_path = 0;\n  struct stat st;\n\n  if (strchr(fname, '/') || !(env_path = getenv(\"PATH\"))) {\n\n    target_path = ck_strdup(fname);\n\n    if (stat(target_path, &st) || !S_ISREG(st.st_mode) ||\n        !(st.st_mode & 0111) || st.st_size < 4)\n      FATAL(\"Program '%s' not found or not executable\", fname);\n\n  } else {\n\n    while (env_path) {\n\n      u8 *cur_elem, *delim = strchr(env_path, ':');\n\n      if (delim) {\n\n        cur_elem = ck_alloc(delim - env_path + 1);\n        memcpy(cur_elem, env_path, delim - env_path);\n        delim++;\n\n      } else cur_elem = ck_strdup(env_path);\n\n      env_path = delim;\n\n      if (cur_elem[0])\n        target_path = alloc_printf(\"%s/%s\", cur_elem, fname);\n      else\n        target_path = ck_strdup(fname);\n\n      ck_free(cur_elem);\n\n      if (!stat(target_path, &st) && S_ISREG(st.st_mode) &&\n          (st.st_mode & 0111) && st.st_size >= 4) break;\n\n      ck_free(target_path);\n      target_path = 0;\n\n    }\n\n    if (!target_path) FATAL(\"Program '%s' not found or not executable\", fname);\n\n  }\n\n}\n\n\n/* Fix up argv for QEMU. */\n\nstatic char** get_qemu_argv(u8* own_loc, char** argv, int argc) {\n\n  char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));\n  u8 *tmp, *cp, *rsl, *own_copy;\n\n  /* Workaround for a QEMU stability glitch. */\n\n  setenv(\"QEMU_LOG\", \"nochain\", 1);\n\n  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);\n\n  /* Now we need to actually find qemu for argv[0]. */\n\n  new_argv[2] = target_path;\n  new_argv[1] = \"--\";\n\n  tmp = getenv(\"AFL_PATH\");\n\n  if (tmp) {\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", tmp);\n\n    if (access(cp, X_OK))\n      FATAL(\"Unable to find '%s'\", tmp);\n\n    target_path = new_argv[0] = cp;\n    return new_argv;\n\n  }\n\n  own_copy = ck_strdup(own_loc);\n  rsl = strrchr(own_copy, '/');\n\n  if (rsl) {\n\n    *rsl = 0;\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", own_copy);\n    ck_free(own_copy);\n\n    if (!access(cp, X_OK)) {\n\n      target_path = new_argv[0] = cp;\n      return new_argv;\n\n    }\n\n  } else ck_free(own_copy);\n\n  if (!access(BIN_PATH \"/afl-qemu-trace\", X_OK)) {\n\n    target_path = new_argv[0] = BIN_PATH \"/afl-qemu-trace\";\n    return new_argv;\n\n  }\n\n  FATAL(\"Unable to find 'afl-qemu-trace'.\");\n\n}\n\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;\n  char** use_argv;\n\n  doc_path = access(DOC_PATH, F_OK) ? \"docs\" : DOC_PATH;\n\n  SAYF(cCYA \"afl-analyze \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  while ((opt = getopt(argc,argv,\"+i:f:m:t:eQV\")) > 0)\n\n    switch (opt) {\n\n      case 'i':\n\n        if (in_file) FATAL(\"Multiple -i options not supported\");\n        in_file = optarg;\n        break;\n\n      case 'f':\n\n        if (prog_in) FATAL(\"Multiple -f options not supported\");\n        use_stdin = 0;\n        prog_in   = optarg;\n        break;\n\n      case 'e':\n\n        if (edges_only) FATAL(\"Multiple -e options not supported\");\n        edges_only = 1;\n        break;\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n          if (sizeof(rlim_t) == 4 && mem_limit > 2000)\n            FATAL(\"Value of -m out of range on 32-bit systems\");\n\n        }\n\n        break;\n\n      case 't':\n\n        if (timeout_given) FATAL(\"Multiple -t options not supported\");\n        timeout_given = 1;\n\n        exec_tmout = atoi(optarg);\n\n        if (exec_tmout < 10 || optarg[0] == '-')\n          FATAL(\"Dangerously low value of -t\");\n\n        break;\n\n      case 'Q':\n\n        if (qemu_mode) FATAL(\"Multiple -Q options not supported\");\n        if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;\n\n        qemu_mode = 1;\n        break;\n\n      case 'V': /* Show version number */\n\n        /* Version number has been printed already, just quit. */\n        exit(0);\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if (optind == argc || !in_file) usage(argv[0]);\n\n  use_hex_offsets = !!getenv(\"AFL_ANALYZE_HEX\");\n\n  setup_shm();\n  setup_signal_handlers();\n\n  set_up_environment();\n\n  find_binary(argv[optind]);\n  detect_file_args(argv + optind);\n\n  if (qemu_mode)\n    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);\n  else\n    use_argv = argv + optind;\n\n  SAYF(\"\\n\");\n\n  read_initial_file();\n\n  ACTF(\"Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...\",\n       mem_limit, exec_tmout, edges_only ? \", edges only\" : \"\");\n\n  run_target(use_argv, in_data, in_len, 1);\n\n  if (child_timed_out)\n    FATAL(\"Target binary times out (adjusting -t may help).\");\n\n  if (!anything_set()) FATAL(\"No instrumentation detected.\");\n\n  analyze(use_argv);\n\n  OKF(\"We're done here. Have a nice day!\\n\");\n\n  exit(0);\n\n}\n\n"
        },
        {
          "name": "afl-as.c",
          "type": "blob",
          "size": 15.2158203125,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - wrapper for GNU as\n   ---------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   The sole purpose of this wrapper is to preprocess assembly files generated\n   by GCC / clang and inject the instrumentation bits included from afl-as.h. It\n   is automatically invoked by the toolchain when compiling programs using\n   afl-gcc / afl-clang.\n\n   Note that it's an explicit non-goal to instrument hand-written assembly,\n   be it in separate .s files or in __asm__ blocks. The only aspiration this\n   utility has right now is to be able to skip them gracefully and allow the\n   compilation process to continue.\n\n   That said, see experimental/clang_asm_normalize/ for a solution that may\n   allow clang users to make things work even with hand-crafted assembly. Just\n   note that there is no equivalent for GCC.\n\n*/\n\n#define AFL_MAIN\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n\n#include \"afl-as.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <fcntl.h>\n\n#include <sys/wait.h>\n#include <sys/time.h>\n\nstatic u8** as_params;          /* Parameters passed to the real 'as'   */\n\nstatic u8*  input_file;         /* Originally specified input file      */\nstatic u8*  modified_file;      /* Instrumented file for the real 'as'  */\n\nstatic u8   be_quiet,           /* Quiet mode (no stderr output)        */\n            clang_mode,         /* Running in clang mode?               */\n            pass_thru,          /* Just pass data through?              */\n            just_version,       /* Just show version?                   */\n            sanitizer;          /* Using ASAN / MSAN                    */\n\nstatic u32  inst_ratio = 100,   /* Instrumentation probability (%)      */\n            as_par_cnt = 1;     /* Number of params to 'as'             */\n\n/* If we don't find --32 or --64 in the command line, default to \n   instrumentation for whichever mode we were compiled with. This is not\n   perfect, but should do the trick for almost all use cases. */\n\n#ifdef WORD_SIZE_64\n\nstatic u8   use_64bit = 1;\n\n#else\n\nstatic u8   use_64bit = 0;\n\n#ifdef __APPLE__\n#  error \"Sorry, 32-bit Apple platforms are not supported.\"\n#endif /* __APPLE__ */\n\n#endif /* ^WORD_SIZE_64 */\n\n\n/* Examine and modify parameters to pass to 'as'. Note that the file name\n   is always the last parameter passed by GCC, so we exploit this property\n   to keep the code simple. */\n\nstatic void edit_params(int argc, char** argv) {\n\n  u8 *tmp_dir = getenv(\"TMPDIR\"), *afl_as = getenv(\"AFL_AS\");\n  u32 i;\n\n#ifdef __APPLE__\n\n  u8 use_clang_as = 0;\n\n  /* On MacOS X, the Xcode cctool 'as' driver is a bit stale and does not work\n     with the code generated by newer versions of clang that are hand-built\n     by the user. See the thread here: http://goo.gl/HBWDtn.\n\n     To work around this, when using clang and running without AFL_AS\n     specified, we will actually call 'clang -c' instead of 'as -q' to\n     compile the assembly file.\n\n     The tools aren't cmdline-compatible, but at least for now, we can\n     seemingly get away with this by making only very minor tweaks. Thanks\n     to Nico Weber for the idea. */\n\n  if (clang_mode && !afl_as) {\n\n    use_clang_as = 1;\n\n    afl_as = getenv(\"AFL_CC\");\n    if (!afl_as) afl_as = getenv(\"AFL_CXX\");\n    if (!afl_as) afl_as = \"clang\";\n\n  }\n\n#endif /* __APPLE__ */\n\n  /* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR\n     is not set. We need to check these non-standard variables to properly\n     handle the pass_thru logic later on. */\n\n  if (!tmp_dir) tmp_dir = getenv(\"TEMP\");\n  if (!tmp_dir) tmp_dir = getenv(\"TMP\");\n  if (!tmp_dir) tmp_dir = \"/tmp\";\n\n  as_params = ck_alloc((argc + 32) * sizeof(u8*));\n\n  as_params[0] = afl_as ? afl_as : (u8*)\"as\";\n\n  as_params[argc] = 0;\n\n  for (i = 1; i < argc - 1; i++) {\n\n    if (!strcmp(argv[i], \"--64\")) use_64bit = 1;\n    else if (!strcmp(argv[i], \"--32\")) use_64bit = 0;\n\n#ifdef __APPLE__\n\n    /* The Apple case is a bit different... */\n\n    if (!strcmp(argv[i], \"-arch\") && i + 1 < argc) {\n\n      if (!strcmp(argv[i + 1], \"x86_64\")) use_64bit = 1;\n      else if (!strcmp(argv[i + 1], \"i386\"))\n        FATAL(\"Sorry, 32-bit Apple platforms are not supported.\");\n\n    }\n\n    /* Strip options that set the preference for a particular upstream\n       assembler in Xcode. */\n\n    if (clang_mode && (!strcmp(argv[i], \"-q\") || !strcmp(argv[i], \"-Q\")))\n      continue;\n\n#endif /* __APPLE__ */\n\n    as_params[as_par_cnt++] = argv[i];\n\n  }\n\n#ifdef __APPLE__\n\n  /* When calling clang as the upstream assembler, append -c -x assembler\n     and hope for the best. */\n\n  if (use_clang_as) {\n\n    as_params[as_par_cnt++] = \"-c\";\n    as_params[as_par_cnt++] = \"-x\";\n    as_params[as_par_cnt++] = \"assembler\";\n\n  }\n\n#endif /* __APPLE__ */\n\n  input_file = argv[argc - 1];\n\n  if (input_file[0] == '-') {\n\n    if (!strcmp(input_file + 1, \"-version\")) {\n      just_version = 1;\n      modified_file = input_file;\n      goto wrap_things_up;\n    }\n\n    if (input_file[1]) FATAL(\"Incorrect use (not called through afl-gcc?)\");\n      else input_file = NULL;\n\n  } else {\n\n    /* Check if this looks like a standard invocation as a part of an attempt\n       to compile a program, rather than using gcc on an ad-hoc .s file in\n       a format we may not understand. This works around an issue compiling\n       NSS. */\n\n    if (strncmp(input_file, tmp_dir, strlen(tmp_dir)) &&\n        strncmp(input_file, \"/var/tmp/\", 9) &&\n        strncmp(input_file, \"/tmp/\", 5)) pass_thru = 1;\n\n  }\n\n  modified_file = alloc_printf(\"%s/.afl-%u-%u.s\", tmp_dir, getpid(),\n                               (u32)time(NULL));\n\nwrap_things_up:\n\n  as_params[as_par_cnt++] = modified_file;\n  as_params[as_par_cnt]   = NULL;\n\n}\n\n\n/* Process input file, generate modified_file. Insert instrumentation in all\n   the appropriate places. */\n\nstatic void add_instrumentation(void) {\n\n  static u8 line[MAX_LINE];\n\n  FILE* inf;\n  FILE* outf;\n  s32 outfd;\n  u32 ins_lines = 0;\n\n  u8  instr_ok = 0, skip_csect = 0, skip_next_label = 0,\n      skip_intel = 0, skip_app = 0, instrument_next = 0;\n\n#ifdef __APPLE__\n\n  u8* colon_pos;\n\n#endif /* __APPLE__ */\n\n  if (input_file) {\n\n    inf = fopen(input_file, \"r\");\n    if (!inf) PFATAL(\"Unable to read '%s'\", input_file);\n\n  } else inf = stdin;\n\n  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);\n\n  if (outfd < 0) PFATAL(\"Unable to write to '%s'\", modified_file);\n\n  outf = fdopen(outfd, \"w\");\n\n  if (!outf) PFATAL(\"fdopen() failed\");  \n\n  while (fgets(line, MAX_LINE, inf)) {\n\n    /* In some cases, we want to defer writing the instrumentation trampoline\n       until after all the labels, macros, comments, etc. If we're in this\n       mode, and if the line starts with a tab followed by a character, dump\n       the trampoline now. */\n\n    if (!pass_thru && !skip_intel && !skip_app && !skip_csect && instr_ok &&\n        instrument_next && line[0] == '\\t' && isalpha(line[1])) {\n\n      fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,\n              R(MAP_SIZE));\n\n      instrument_next = 0;\n      ins_lines++;\n\n    }\n\n    /* Output the actual line, call it a day in pass-thru mode. */\n\n    fputs(line, outf);\n\n    if (pass_thru) continue;\n\n    /* All right, this is where the actual fun begins. For one, we only want to\n       instrument the .text section. So, let's keep track of that in processed\n       files - and let's set instr_ok accordingly. */\n\n    if (line[0] == '\\t' && line[1] == '.') {\n\n      /* OpenBSD puts jump tables directly inline with the code, which is\n         a bit annoying. They use a specific format of p2align directives\n         around them, so we use that as a signal. */\n\n      if (!clang_mode && instr_ok && !strncmp(line + 2, \"p2align \", 8) &&\n          isdigit(line[10]) && line[11] == '\\n') skip_next_label = 1;\n\n      if (!strncmp(line + 2, \"text\\n\", 5) ||\n          !strncmp(line + 2, \"section\\t.text\", 13) ||\n          !strncmp(line + 2, \"section\\t__TEXT,__text\", 21) ||\n          !strncmp(line + 2, \"section __TEXT,__text\", 21)) {\n        instr_ok = 1;\n        continue; \n      }\n\n      if (!strncmp(line + 2, \"section\\t\", 8) ||\n          !strncmp(line + 2, \"section \", 8) ||\n          !strncmp(line + 2, \"bss\\n\", 4) ||\n          !strncmp(line + 2, \"data\\n\", 5)) {\n        instr_ok = 0;\n        continue;\n      }\n\n    }\n\n    /* Detect off-flavor assembly (rare, happens in gdb). When this is\n       encountered, we set skip_csect until the opposite directive is\n       seen, and we do not instrument. */\n\n    if (strstr(line, \".code\")) {\n\n      if (strstr(line, \".code32\")) skip_csect = use_64bit;\n      if (strstr(line, \".code64\")) skip_csect = !use_64bit;\n\n    }\n\n    /* Detect syntax changes, as could happen with hand-written assembly.\n       Skip Intel blocks, resume instrumentation when back to AT&T. */\n\n    if (strstr(line, \".intel_syntax\")) skip_intel = 1;\n    if (strstr(line, \".att_syntax\")) skip_intel = 0;\n\n    /* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */\n\n    if (line[0] == '#' || line[1] == '#') {\n\n      if (strstr(line, \"#APP\")) skip_app = 1;\n      if (strstr(line, \"#NO_APP\")) skip_app = 0;\n\n    }\n\n    /* If we're in the right mood for instrumenting, check for function\n       names or conditional labels. This is a bit messy, but in essence,\n       we want to catch:\n\n         ^main:      - function entry point (always instrumented)\n         ^.L0:       - GCC branch label\n         ^.LBB0_0:   - clang branch label (but only in clang mode)\n         ^\\tjnz foo  - conditional branches\n\n       ...but not:\n\n         ^# BB#0:    - clang comments\n         ^ # BB#0:   - ditto\n         ^.Ltmp0:    - clang non-branch labels\n         ^.LC0       - GCC non-branch labels\n         ^.LBB0_0:   - ditto (when in GCC mode)\n         ^\\tjmp foo  - non-conditional jumps\n\n       Additionally, clang and GCC on MacOS X follow a different convention\n       with no leading dots on labels, hence the weird maze of #ifdefs\n       later on.\n\n     */\n\n    if (skip_intel || skip_app || skip_csect || !instr_ok ||\n        line[0] == '#' || line[0] == ' ') continue;\n\n    /* Conditional branch instruction (jnz, etc). We append the instrumentation\n       right after the branch (to instrument the not-taken path) and at the\n       branch destination label (handled later on). */\n\n    if (line[0] == '\\t') {\n\n      if (line[1] == 'j' && line[2] != 'm' && R(100) < inst_ratio) {\n\n        fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,\n                R(MAP_SIZE));\n\n        ins_lines++;\n\n      }\n\n      continue;\n\n    }\n\n    /* Label of some sort. This may be a branch destination, but we need to\n       tread carefully and account for several different formatting\n       conventions. */\n\n#ifdef __APPLE__\n\n    /* Apple: L<whatever><digit>: */\n\n    if ((colon_pos = strstr(line, \":\"))) {\n\n      if (line[0] == 'L' && isdigit(*(colon_pos - 1))) {\n\n#else\n\n    /* Everybody else: .L<whatever>: */\n\n    if (strstr(line, \":\")) {\n\n      if (line[0] == '.') {\n\n#endif /* __APPLE__ */\n\n        /* .L0: or LBB0_0: style jump destination */\n\n#ifdef __APPLE__\n\n        /* Apple: L<num> / LBB<num> */\n\n        if ((isdigit(line[1]) || (clang_mode && !strncmp(line, \"LBB\", 3)))\n            && R(100) < inst_ratio) {\n\n#else\n\n        /* Apple: .L<num> / .LBB<num> */\n\n        if ((isdigit(line[2]) || (clang_mode && !strncmp(line + 1, \"LBB\", 3)))\n            && R(100) < inst_ratio) {\n\n#endif /* __APPLE__ */\n\n          /* An optimization is possible here by adding the code only if the\n             label is mentioned in the code in contexts other than call / jmp.\n             That said, this complicates the code by requiring two-pass\n             processing (messy with stdin), and results in a speed gain\n             typically under 10%, because compilers are generally pretty good\n             about not generating spurious intra-function jumps.\n\n             We use deferred output chiefly to avoid disrupting\n             .Lfunc_begin0-style exception handling calculations (a problem on\n             MacOS X). */\n\n          if (!skip_next_label) instrument_next = 1; else skip_next_label = 0;\n\n        }\n\n      } else {\n\n        /* Function label (always instrumented, deferred mode). */\n\n        instrument_next = 1;\n    \n      }\n\n    }\n\n  }\n\n  if (ins_lines)\n    fputs(use_64bit ? main_payload_64 : main_payload_32, outf);\n\n  if (input_file) fclose(inf);\n  fclose(outf);\n\n  if (!be_quiet) {\n\n    if (!ins_lines) WARNF(\"No instrumentation targets found%s.\",\n                          pass_thru ? \" (pass-thru mode)\" : \"\");\n    else OKF(\"Instrumented %u locations (%s-bit, %s mode, ratio %u%%).\",\n             ins_lines, use_64bit ? \"64\" : \"32\",\n             getenv(\"AFL_HARDEN\") ? \"hardened\" : \n             (sanitizer ? \"ASAN/MSAN\" : \"non-hardened\"),\n             inst_ratio);\n \n  }\n\n}\n\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 pid;\n  u32 rand_seed;\n  int status;\n  u8* inst_ratio_str = getenv(\"AFL_INST_RATIO\");\n\n  struct timeval tv;\n  struct timezone tz;\n\n  clang_mode = !!getenv(CLANG_ENV_VAR);\n\n  if (isatty(2) && !getenv(\"AFL_QUIET\")) {\n\n    SAYF(cCYA \"afl-as \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n \n  } else be_quiet = 1;\n\n  if (argc < 2) {\n\n    SAYF(\"\\n\"\n         \"This is a helper application for afl-fuzz. It is a wrapper around GNU 'as',\\n\"\n         \"executed by the toolchain whenever using afl-gcc or afl-clang. You probably\\n\"\n         \"don't want to run this program directly.\\n\\n\"\n\n         \"Rarely, when dealing with extremely complex projects, it may be advisable to\\n\"\n         \"set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\\n\"\n         \"instrumenting every discovered branch.\\n\\n\");\n\n    exit(1);\n\n  }\n\n  gettimeofday(&tv, &tz);\n\n  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();\n\n  srandom(rand_seed);\n\n  edit_params(argc, argv);\n\n  if (inst_ratio_str) {\n\n    if (sscanf(inst_ratio_str, \"%u\", &inst_ratio) != 1 || inst_ratio > 100) \n      FATAL(\"Bad value of AFL_INST_RATIO (must be between 0 and 100)\");\n\n  }\n\n  if (getenv(AS_LOOP_ENV_VAR))\n    FATAL(\"Endless loop when calling 'as' (remove '.' from your PATH)\");\n\n  setenv(AS_LOOP_ENV_VAR, \"1\", 1);\n\n  /* When compiling with ASAN, we don't have a particularly elegant way to skip\n     ASAN-specific branches. But we can probabilistically compensate for\n     that... */\n\n  if (getenv(\"AFL_USE_ASAN\") || getenv(\"AFL_USE_MSAN\")) {\n    sanitizer = 1;\n    inst_ratio /= 3;\n  }\n\n  if (!just_version) add_instrumentation();\n\n  if (!(pid = fork())) {\n\n    execvp(as_params[0], (char**)as_params);\n    FATAL(\"Oops, failed to execute '%s' - check your PATH\", as_params[0]);\n\n  }\n\n  if (pid < 0) PFATAL(\"fork() failed\");\n\n  if (waitpid(pid, &status, 0) <= 0) PFATAL(\"waitpid() failed\");\n\n  if (!getenv(\"AFL_KEEP_ASSEMBLY\")) unlink(modified_file);\n\n  exit(WEXITSTATUS(status));\n\n}\n\n"
        },
        {
          "name": "afl-as.h",
          "type": "blob",
          "size": 20.892578125,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - injectable parts\n   -------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   Forkserver design by Jann Horn <jannhorn@googlemail.com>\n\n   This file houses the assembly-level instrumentation injected into fuzzed\n   programs. The instrumentation stores XORed pairs of data: identifiers of the\n   currently executing branch and the one that executed immediately before.\n\n   TL;DR: the instrumentation does shm_trace_map[cur_loc ^ prev_loc]++\n\n   The code is designed for 32-bit and 64-bit x86 systems. Both modes should\n   work everywhere except for Apple systems. Apple does relocations differently\n   from everybody else, so since their OSes have been 64-bit for a longer while,\n   I didn't go through the mental effort of porting the 32-bit code.\n\n   In principle, similar code should be easy to inject into any well-behaved\n   binary-only code (e.g., using DynamoRIO). Conditional jumps offer natural\n   targets for instrumentation, and should offer comparable probe density.\n\n*/\n\n#ifndef _HAVE_AFL_AS_H\n#define _HAVE_AFL_AS_H\n\n#include \"config.h\"\n#include \"types.h\"\n\n/* \n   ------------------\n   Performances notes\n   ------------------\n\n   Contributions to make this code faster are appreciated! Here are some\n   rough notes that may help with the task:\n\n   - Only the trampoline_fmt and the non-setup __afl_maybe_log code paths are\n     really worth optimizing; the setup / fork server stuff matters a lot less\n     and should be mostly just kept readable.\n\n   - We're aiming for modern CPUs with out-of-order execution and large\n     pipelines; the code is mostly follows intuitive, human-readable\n     instruction ordering, because \"textbook\" manual reorderings make no\n     substantial difference.\n\n   - Interestingly, instrumented execution isn't a lot faster if we store a\n     variable pointer to the setup, log, or return routine and then do a reg\n     call from within trampoline_fmt. It does speed up non-instrumented\n     execution quite a bit, though, since that path just becomes\n     push-call-ret-pop.\n\n   - There is also not a whole lot to be gained by doing SHM attach at a\n     fixed address instead of retrieving __afl_area_ptr. Although it allows us\n     to have a shorter log routine inserted for conditional jumps and jump\n     labels (for a ~10% perf gain), there is a risk of bumping into other\n     allocations created by the program or by tools such as ASAN.\n\n   - popf is *awfully* slow, which is why we're doing the lahf / sahf +\n     overflow test trick. Unfortunately, this forces us to taint eax / rax, but\n     this dependency on a commonly-used register still beats the alternative of\n     using pushf / popf.\n\n     One possible optimization is to avoid touching flags by using a circular\n     buffer that stores just a sequence of current locations, with the XOR stuff\n     happening offline. Alas, this doesn't seem to have a huge impact:\n\n     https://groups.google.com/d/msg/afl-users/MsajVf4fRLo/2u6t88ntUBIJ\n\n   - Preforking one child a bit sooner, and then waiting for the \"go\" command\n     from within the child, doesn't offer major performance gains; fork() seems\n     to be relatively inexpensive these days. Preforking multiple children does\n     help, but badly breaks the \"~1 core per fuzzer\" design, making it harder to\n     scale up. Maybe there is some middle ground.\n\n   Perhaps of note: in the 64-bit version for all platforms except for Apple,\n   the instrumentation is done slightly differently than on 32-bit, with\n   __afl_prev_loc and __afl_area_ptr being local to the object file (.lcomm),\n   rather than global (.comm). This is to avoid GOTRELPC lookups in the critical\n   code path, which AFAICT, are otherwise unavoidable if we want gcc -shared to\n   work; simple relocations between .bss and .text won't work on most 64-bit\n   platforms in such a case.\n\n   (Fun fact: on Apple systems, .lcomm can segfault the linker.)\n\n   The side effect is that state transitions are measured in a somewhat\n   different way, with previous tuple being recorded separately within the scope\n   of every .c file. This should have no impact in any practical sense.\n\n   Another side effect of this design is that getenv() will be called once per\n   every .o file when running in non-instrumented mode; and since getenv() tends\n   to be optimized in funny ways, we need to be very careful to save every\n   oddball register it may touch.\n\n */\n\nstatic const u8* trampoline_fmt_32 =\n\n  \"\\n\"\n  \"/* --- AFL TRAMPOLINE (32-BIT) --- */\\n\"\n  \"\\n\"\n  \".align 4\\n\"\n  \"\\n\"\n  \"leal -16(%%esp), %%esp\\n\"\n  \"movl %%edi,  0(%%esp)\\n\"\n  \"movl %%edx,  4(%%esp)\\n\"\n  \"movl %%ecx,  8(%%esp)\\n\"\n  \"movl %%eax, 12(%%esp)\\n\"\n  \"movl $0x%08x, %%ecx\\n\"\n  \"call __afl_maybe_log\\n\"\n  \"movl 12(%%esp), %%eax\\n\"\n  \"movl  8(%%esp), %%ecx\\n\"\n  \"movl  4(%%esp), %%edx\\n\"\n  \"movl  0(%%esp), %%edi\\n\"\n  \"leal 16(%%esp), %%esp\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\nstatic const u8* trampoline_fmt_64 =\n\n  \"\\n\"\n  \"/* --- AFL TRAMPOLINE (64-BIT) --- */\\n\"\n  \"\\n\"\n  \".align 4\\n\"\n  \"\\n\"\n  \"leaq -(128+24)(%%rsp), %%rsp\\n\"\n  \"movq %%rdx,  0(%%rsp)\\n\"\n  \"movq %%rcx,  8(%%rsp)\\n\"\n  \"movq %%rax, 16(%%rsp)\\n\"\n  \"movq $0x%08x, %%rcx\\n\"\n  \"call __afl_maybe_log\\n\"\n  \"movq 16(%%rsp), %%rax\\n\"\n  \"movq  8(%%rsp), %%rcx\\n\"\n  \"movq  0(%%rsp), %%rdx\\n\"\n  \"leaq (128+24)(%%rsp), %%rsp\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\nstatic const u8* main_payload_32 = \n\n  \"\\n\"\n  \"/* --- AFL MAIN PAYLOAD (32-BIT) --- */\\n\"\n  \"\\n\"\n  \".text\\n\"\n  \".att_syntax\\n\"\n  \".code32\\n\"\n  \".align 8\\n\"\n  \"\\n\"\n\n  \"__afl_maybe_log:\\n\"\n  \"\\n\"\n  \"  lahf\\n\"\n  \"  seto %al\\n\"\n  \"\\n\"\n  \"  /* Check if SHM region is already mapped. */\\n\"\n  \"\\n\"\n  \"  movl  __afl_area_ptr, %edx\\n\"\n  \"  testl %edx, %edx\\n\"\n  \"  je    __afl_setup\\n\"\n  \"\\n\"\n  \"__afl_store:\\n\"\n  \"\\n\"\n  \"  /* Calculate and store hit for the code location specified in ecx. There\\n\"\n  \"     is a double-XOR way of doing this without tainting another register,\\n\"\n  \"     and we use it on 64-bit systems; but it's slower for 32-bit ones. */\\n\"\n  \"\\n\"\n#ifndef COVERAGE_ONLY\n  \"  movl __afl_prev_loc, %edi\\n\"\n  \"  xorl %ecx, %edi\\n\"\n  \"  shrl $1, %ecx\\n\"\n  \"  movl %ecx, __afl_prev_loc\\n\"\n#else\n  \"  movl %ecx, %edi\\n\"\n#endif /* ^!COVERAGE_ONLY */\n  \"\\n\"\n#ifdef SKIP_COUNTS\n  \"  orb  $1, (%edx, %edi, 1)\\n\"\n#else\n  \"  incb (%edx, %edi, 1)\\n\"\n#endif /* ^SKIP_COUNTS */\n  \"\\n\"\n  \"__afl_return:\\n\"\n  \"\\n\"\n  \"  addb $127, %al\\n\"\n  \"  sahf\\n\"\n  \"  ret\\n\"\n  \"\\n\"\n  \".align 8\\n\"\n  \"\\n\"\n  \"__afl_setup:\\n\"\n  \"\\n\"\n  \"  /* Do not retry setup if we had previous failures. */\\n\"\n  \"\\n\"\n  \"  cmpb $0, __afl_setup_failure\\n\"\n  \"  jne  __afl_return\\n\"\n  \"\\n\"\n  \"  /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\\n\"\n  \"     We do not save FPU/MMX/SSE registers here, but hopefully, nobody\\n\"\n  \"     will notice this early in the game. */\\n\"\n  \"\\n\"\n  \"  pushl %eax\\n\"\n  \"  pushl %ecx\\n\"\n  \"\\n\"\n  \"  pushl $.AFL_SHM_ENV\\n\"\n  \"  call  getenv\\n\"\n  \"  addl  $4, %esp\\n\"\n  \"\\n\"\n  \"  testl %eax, %eax\\n\"\n  \"  je    __afl_setup_abort\\n\"\n  \"\\n\"\n  \"  pushl %eax\\n\"\n  \"  call  atoi\\n\"\n  \"  addl  $4, %esp\\n\"\n  \"\\n\"\n  \"  pushl $0          /* shmat flags    */\\n\"\n  \"  pushl $0          /* requested addr */\\n\"\n  \"  pushl %eax        /* SHM ID         */\\n\"\n  \"  call  shmat\\n\"\n  \"  addl  $12, %esp\\n\"\n  \"\\n\"\n  \"  cmpl $-1, %eax\\n\"\n  \"  je   __afl_setup_abort\\n\"\n  \"\\n\"\n  \"  /* Store the address of the SHM region. */\\n\"\n  \"\\n\"\n  \"  movl %eax, __afl_area_ptr\\n\"\n  \"  movl %eax, %edx\\n\"\n  \"\\n\"\n  \"  popl %ecx\\n\"\n  \"  popl %eax\\n\"\n  \"\\n\"\n  \"__afl_forkserver:\\n\"\n  \"\\n\"\n  \"  /* Enter the fork server mode to avoid the overhead of execve() calls. */\\n\"\n  \"\\n\"\n  \"  pushl %eax\\n\"\n  \"  pushl %ecx\\n\"\n  \"  pushl %edx\\n\"\n  \"\\n\"\n  \"  /* Phone home and tell the parent that we're OK. (Note that signals with\\n\"\n  \"     no SA_RESTART will mess it up). If this fails, assume that the fd is\\n\"\n  \"     closed because we were execve()d from an instrumented binary, or because\\n\" \n  \"     the parent doesn't want to use the fork server. */\\n\"\n  \"\\n\"\n  \"  pushl $4          /* length    */\\n\"\n  \"  pushl $__afl_temp /* data      */\\n\"\n  \"  pushl $\" STRINGIFY((FORKSRV_FD + 1)) \"  /* file desc */\\n\"\n  \"  call  write\\n\"\n  \"  addl  $12, %esp\\n\"\n  \"\\n\"\n  \"  cmpl  $4, %eax\\n\"\n  \"  jne   __afl_fork_resume\\n\"\n  \"\\n\"\n  \"__afl_fork_wait_loop:\\n\"\n  \"\\n\"\n  \"  /* Wait for parent by reading from the pipe. Abort if read fails. */\\n\"\n  \"\\n\"\n  \"  pushl $4          /* length    */\\n\"\n  \"  pushl $__afl_temp /* data      */\\n\"\n  \"  pushl $\" STRINGIFY(FORKSRV_FD) \"        /* file desc */\\n\"\n  \"  call  read\\n\"\n  \"  addl  $12, %esp\\n\"\n  \"\\n\"\n  \"  cmpl  $4, %eax\\n\"\n  \"  jne   __afl_die\\n\"\n  \"\\n\"\n  \"  /* Once woken up, create a clone of our process. This is an excellent use\\n\"\n  \"     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\\n\"\n  \"     caches getpid() results and offers no way to update the value, breaking\\n\"\n  \"     abort(), raise(), and a bunch of other things :-( */\\n\"\n  \"\\n\"\n  \"  call fork\\n\"\n  \"\\n\"\n  \"  cmpl $0, %eax\\n\"\n  \"  jl   __afl_die\\n\"\n  \"  je   __afl_fork_resume\\n\"\n  \"\\n\"\n  \"  /* In parent process: write PID to pipe, then wait for child. */\\n\"\n  \"\\n\"\n  \"  movl  %eax, __afl_fork_pid\\n\"\n  \"\\n\"\n  \"  pushl $4              /* length    */\\n\"\n  \"  pushl $__afl_fork_pid /* data      */\\n\"\n  \"  pushl $\" STRINGIFY((FORKSRV_FD + 1)) \"      /* file desc */\\n\"\n  \"  call  write\\n\"\n  \"  addl  $12, %esp\\n\"\n  \"\\n\"\n  \"  pushl $0             /* no flags  */\\n\"\n  \"  pushl $__afl_temp    /* status    */\\n\"\n  \"  pushl __afl_fork_pid /* PID       */\\n\"\n  \"  call  waitpid\\n\"\n  \"  addl  $12, %esp\\n\"\n  \"\\n\"\n  \"  cmpl  $0, %eax\\n\"\n  \"  jle   __afl_die\\n\"\n  \"\\n\"\n  \"  /* Relay wait status to pipe, then loop back. */\\n\"\n  \"\\n\"\n  \"  pushl $4          /* length    */\\n\"\n  \"  pushl $__afl_temp /* data      */\\n\"\n  \"  pushl $\" STRINGIFY((FORKSRV_FD + 1)) \"  /* file desc */\\n\"\n  \"  call  write\\n\"\n  \"  addl  $12, %esp\\n\"\n  \"\\n\"\n  \"  jmp __afl_fork_wait_loop\\n\"\n  \"\\n\"\n  \"__afl_fork_resume:\\n\"\n  \"\\n\"\n  \"  /* In child process: close fds, resume execution. */\\n\"\n  \"\\n\"\n  \"  pushl $\" STRINGIFY(FORKSRV_FD) \"\\n\"\n  \"  call  close\\n\"\n  \"\\n\"\n  \"  pushl $\" STRINGIFY((FORKSRV_FD + 1)) \"\\n\"\n  \"  call  close\\n\"\n  \"\\n\"\n  \"  addl  $8, %esp\\n\"\n  \"\\n\"\n  \"  popl %edx\\n\"\n  \"  popl %ecx\\n\"\n  \"  popl %eax\\n\"\n  \"  jmp  __afl_store\\n\"\n  \"\\n\"\n  \"__afl_die:\\n\"\n  \"\\n\"\n  \"  xorl %eax, %eax\\n\"\n  \"  call _exit\\n\"\n  \"\\n\"\n  \"__afl_setup_abort:\\n\"\n  \"\\n\"\n  \"  /* Record setup failure so that we don't keep calling\\n\"\n  \"     shmget() / shmat() over and over again. */\\n\"\n  \"\\n\"\n  \"  incb __afl_setup_failure\\n\"\n  \"  popl %ecx\\n\"\n  \"  popl %eax\\n\"\n  \"  jmp __afl_return\\n\"\n  \"\\n\"\n  \".AFL_VARS:\\n\"\n  \"\\n\"\n  \"  .comm   __afl_area_ptr, 4, 32\\n\"\n  \"  .comm   __afl_setup_failure, 1, 32\\n\"\n#ifndef COVERAGE_ONLY\n  \"  .comm   __afl_prev_loc, 4, 32\\n\"\n#endif /* !COVERAGE_ONLY */\n  \"  .comm   __afl_fork_pid, 4, 32\\n\"\n  \"  .comm   __afl_temp, 4, 32\\n\"\n  \"\\n\"\n  \".AFL_SHM_ENV:\\n\"\n  \"  .asciz \\\"\" SHM_ENV_VAR \"\\\"\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\n/* The OpenBSD hack is due to lahf and sahf not being recognized by some\n   versions of binutils: http://marc.info/?l=openbsd-cvs&m=141636589924400\n\n   The Apple code is a bit different when calling libc functions because\n   they are doing relocations differently from everybody else. We also need\n   to work around the crash issue with .lcomm and the fact that they don't\n   recognize .string. */\n\n#ifdef __APPLE__\n#  define CALL_L64(str)\t\t\"call _\" str \"\\n\"\n#else\n#  define CALL_L64(str)\t\t\"call \" str \"@PLT\\n\"\n#endif /* ^__APPLE__ */\n\nstatic const u8* main_payload_64 = \n\n  \"\\n\"\n  \"/* --- AFL MAIN PAYLOAD (64-BIT) --- */\\n\"\n  \"\\n\"\n  \".text\\n\"\n  \".att_syntax\\n\"\n  \".code64\\n\"\n  \".align 8\\n\"\n  \"\\n\"\n  \"__afl_maybe_log:\\n\"\n  \"\\n\"\n#if defined(__OpenBSD__)  || (defined(__FreeBSD__) && (__FreeBSD__ < 9))\n  \"  .byte 0x9f /* lahf */\\n\"\n#else\n  \"  lahf\\n\"\n#endif /* ^__OpenBSD__, etc */\n  \"  seto  %al\\n\"\n  \"\\n\"\n  \"  /* Check if SHM region is already mapped. */\\n\"\n  \"\\n\"\n  \"  movq  __afl_area_ptr(%rip), %rdx\\n\"\n  \"  testq %rdx, %rdx\\n\"\n  \"  je    __afl_setup\\n\"\n  \"\\n\"\n  \"__afl_store:\\n\"\n  \"\\n\"\n  \"  /* Calculate and store hit for the code location specified in rcx. */\\n\"\n  \"\\n\"\n#ifndef COVERAGE_ONLY\n  \"  xorq __afl_prev_loc(%rip), %rcx\\n\"\n  \"  xorq %rcx, __afl_prev_loc(%rip)\\n\"\n  \"  shrq $1, __afl_prev_loc(%rip)\\n\"\n#endif /* ^!COVERAGE_ONLY */\n  \"\\n\"\n#ifdef SKIP_COUNTS\n  \"  orb  $1, (%rdx, %rcx, 1)\\n\"\n#else\n  \"  incb (%rdx, %rcx, 1)\\n\"\n#endif /* ^SKIP_COUNTS */\n  \"\\n\"\n  \"__afl_return:\\n\"\n  \"\\n\"\n  \"  addb $127, %al\\n\"\n#if defined(__OpenBSD__)  || (defined(__FreeBSD__) && (__FreeBSD__ < 9))\n  \"  .byte 0x9e /* sahf */\\n\"\n#else\n  \"  sahf\\n\"\n#endif /* ^__OpenBSD__, etc */\n  \"  ret\\n\"\n  \"\\n\"\n  \".align 8\\n\"\n  \"\\n\"\n  \"__afl_setup:\\n\"\n  \"\\n\"\n  \"  /* Do not retry setup if we had previous failures. */\\n\"\n  \"\\n\"\n  \"  cmpb $0, __afl_setup_failure(%rip)\\n\"\n  \"  jne __afl_return\\n\"\n  \"\\n\"\n  \"  /* Check out if we have a global pointer on file. */\\n\"\n  \"\\n\"\n#ifndef __APPLE__\n  \"  movq  __afl_global_area_ptr@GOTPCREL(%rip), %rdx\\n\"\n  \"  movq  (%rdx), %rdx\\n\"\n#else\n  \"  movq  __afl_global_area_ptr(%rip), %rdx\\n\"\n#endif /* !^__APPLE__ */\n  \"  testq %rdx, %rdx\\n\"\n  \"  je    __afl_setup_first\\n\"\n  \"\\n\"\n  \"  movq %rdx, __afl_area_ptr(%rip)\\n\"\n  \"  jmp  __afl_store\\n\" \n  \"\\n\"\n  \"__afl_setup_first:\\n\"\n  \"\\n\"\n  \"  /* Save everything that is not yet saved and that may be touched by\\n\"\n  \"     getenv() and several other libcalls we'll be relying on. */\\n\"\n  \"\\n\"\n  \"  leaq -352(%rsp), %rsp\\n\"\n  \"\\n\"\n  \"  movq %rax,   0(%rsp)\\n\"\n  \"  movq %rcx,   8(%rsp)\\n\"\n  \"  movq %rdi,  16(%rsp)\\n\"\n  \"  movq %rsi,  32(%rsp)\\n\"\n  \"  movq %r8,   40(%rsp)\\n\"\n  \"  movq %r9,   48(%rsp)\\n\"\n  \"  movq %r10,  56(%rsp)\\n\"\n  \"  movq %r11,  64(%rsp)\\n\"\n  \"\\n\"\n  \"  movq %xmm0,  96(%rsp)\\n\"\n  \"  movq %xmm1,  112(%rsp)\\n\"\n  \"  movq %xmm2,  128(%rsp)\\n\"\n  \"  movq %xmm3,  144(%rsp)\\n\"\n  \"  movq %xmm4,  160(%rsp)\\n\"\n  \"  movq %xmm5,  176(%rsp)\\n\"\n  \"  movq %xmm6,  192(%rsp)\\n\"\n  \"  movq %xmm7,  208(%rsp)\\n\"\n  \"  movq %xmm8,  224(%rsp)\\n\"\n  \"  movq %xmm9,  240(%rsp)\\n\"\n  \"  movq %xmm10, 256(%rsp)\\n\"\n  \"  movq %xmm11, 272(%rsp)\\n\"\n  \"  movq %xmm12, 288(%rsp)\\n\"\n  \"  movq %xmm13, 304(%rsp)\\n\"\n  \"  movq %xmm14, 320(%rsp)\\n\"\n  \"  movq %xmm15, 336(%rsp)\\n\"\n  \"\\n\"\n  \"  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */\\n\"\n  \"\\n\"\n  \"  /* The 64-bit ABI requires 16-byte stack alignment. We'll keep the\\n\"\n  \"     original stack ptr in the callee-saved r12. */\\n\"\n  \"\\n\"\n  \"  pushq %r12\\n\"\n  \"  movq  %rsp, %r12\\n\"\n  \"  subq  $16, %rsp\\n\"\n  \"  andq  $0xfffffffffffffff0, %rsp\\n\"\n  \"\\n\"\n  \"  leaq .AFL_SHM_ENV(%rip), %rdi\\n\"\n  CALL_L64(\"getenv\")\n  \"\\n\"\n  \"  testq %rax, %rax\\n\"\n  \"  je    __afl_setup_abort\\n\"\n  \"\\n\"\n  \"  movq  %rax, %rdi\\n\"\n  CALL_L64(\"atoi\")\n  \"\\n\"\n  \"  xorq %rdx, %rdx   /* shmat flags    */\\n\"\n  \"  xorq %rsi, %rsi   /* requested addr */\\n\"\n  \"  movq %rax, %rdi   /* SHM ID         */\\n\"\n  CALL_L64(\"shmat\")\n  \"\\n\"\n  \"  cmpq $-1, %rax\\n\"\n  \"  je   __afl_setup_abort\\n\"\n  \"\\n\"\n  \"  /* Store the address of the SHM region. */\\n\"\n  \"\\n\"\n  \"  movq %rax, %rdx\\n\"\n  \"  movq %rax, __afl_area_ptr(%rip)\\n\"\n  \"\\n\"\n#ifdef __APPLE__\n  \"  movq %rax, __afl_global_area_ptr(%rip)\\n\"\n#else\n  \"  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\\n\"\n  \"  movq %rax, (%rdx)\\n\"\n#endif /* ^__APPLE__ */\n  \"  movq %rax, %rdx\\n\"\n  \"\\n\"\n  \"__afl_forkserver:\\n\"\n  \"\\n\"\n  \"  /* Enter the fork server mode to avoid the overhead of execve() calls. We\\n\"\n  \"     push rdx (area ptr) twice to keep stack alignment neat. */\\n\"\n  \"\\n\"\n  \"  pushq %rdx\\n\"\n  \"  pushq %rdx\\n\"\n  \"\\n\"\n  \"  /* Phone home and tell the parent that we're OK. (Note that signals with\\n\"\n  \"     no SA_RESTART will mess it up). If this fails, assume that the fd is\\n\"\n  \"     closed because we were execve()d from an instrumented binary, or because\\n\"\n  \"     the parent doesn't want to use the fork server. */\\n\"\n  \"\\n\"\n  \"  movq $4, %rdx               /* length    */\\n\"\n  \"  leaq __afl_temp(%rip), %rsi /* data      */\\n\"\n  \"  movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi       /* file desc */\\n\"\n  CALL_L64(\"write\")\n  \"\\n\"\n  \"  cmpq $4, %rax\\n\"\n  \"  jne  __afl_fork_resume\\n\"\n  \"\\n\"\n  \"__afl_fork_wait_loop:\\n\"\n  \"\\n\"\n  \"  /* Wait for parent by reading from the pipe. Abort if read fails. */\\n\"\n  \"\\n\"\n  \"  movq $4, %rdx               /* length    */\\n\"\n  \"  leaq __afl_temp(%rip), %rsi /* data      */\\n\"\n  \"  movq $\" STRINGIFY(FORKSRV_FD) \", %rdi             /* file desc */\\n\"\n  CALL_L64(\"read\")\n  \"  cmpq $4, %rax\\n\"\n  \"  jne  __afl_die\\n\"\n  \"\\n\"\n  \"  /* Once woken up, create a clone of our process. This is an excellent use\\n\"\n  \"     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\\n\"\n  \"     caches getpid() results and offers no way to update the value, breaking\\n\"\n  \"     abort(), raise(), and a bunch of other things :-( */\\n\"\n  \"\\n\"\n  CALL_L64(\"fork\")\n  \"  cmpq $0, %rax\\n\"\n  \"  jl   __afl_die\\n\"\n  \"  je   __afl_fork_resume\\n\"\n  \"\\n\"\n  \"  /* In parent process: write PID to pipe, then wait for child. */\\n\"\n  \"\\n\"\n  \"  movl %eax, __afl_fork_pid(%rip)\\n\"\n  \"\\n\"\n  \"  movq $4, %rdx                   /* length    */\\n\"\n  \"  leaq __afl_fork_pid(%rip), %rsi /* data      */\\n\"\n  \"  movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi             /* file desc */\\n\"\n  CALL_L64(\"write\")\n  \"\\n\"\n  \"  movq $0, %rdx                   /* no flags  */\\n\"\n  \"  leaq __afl_temp(%rip), %rsi     /* status    */\\n\"\n  \"  movq __afl_fork_pid(%rip), %rdi /* PID       */\\n\"\n  CALL_L64(\"waitpid\")\n  \"  cmpq $0, %rax\\n\"\n  \"  jle  __afl_die\\n\"\n  \"\\n\"\n  \"  /* Relay wait status to pipe, then loop back. */\\n\"\n  \"\\n\"\n  \"  movq $4, %rdx               /* length    */\\n\"\n  \"  leaq __afl_temp(%rip), %rsi /* data      */\\n\"\n  \"  movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi         /* file desc */\\n\"\n  CALL_L64(\"write\")\n  \"\\n\"\n  \"  jmp  __afl_fork_wait_loop\\n\"\n  \"\\n\"\n  \"__afl_fork_resume:\\n\"\n  \"\\n\"\n  \"  /* In child process: close fds, resume execution. */\\n\"\n  \"\\n\"\n  \"  movq $\" STRINGIFY(FORKSRV_FD) \", %rdi\\n\"\n  CALL_L64(\"close\")\n  \"\\n\"\n  \"  movq $\" STRINGIFY((FORKSRV_FD + 1)) \", %rdi\\n\"\n  CALL_L64(\"close\")\n  \"\\n\"\n  \"  popq %rdx\\n\"\n  \"  popq %rdx\\n\"\n  \"\\n\"\n  \"  movq %r12, %rsp\\n\"\n  \"  popq %r12\\n\"\n  \"\\n\"\n  \"  movq  0(%rsp), %rax\\n\"\n  \"  movq  8(%rsp), %rcx\\n\"\n  \"  movq 16(%rsp), %rdi\\n\"\n  \"  movq 32(%rsp), %rsi\\n\"\n  \"  movq 40(%rsp), %r8\\n\"\n  \"  movq 48(%rsp), %r9\\n\"\n  \"  movq 56(%rsp), %r10\\n\"\n  \"  movq 64(%rsp), %r11\\n\"\n  \"\\n\"\n  \"  movq  96(%rsp), %xmm0\\n\"\n  \"  movq 112(%rsp), %xmm1\\n\"\n  \"  movq 128(%rsp), %xmm2\\n\"\n  \"  movq 144(%rsp), %xmm3\\n\"\n  \"  movq 160(%rsp), %xmm4\\n\"\n  \"  movq 176(%rsp), %xmm5\\n\"\n  \"  movq 192(%rsp), %xmm6\\n\"\n  \"  movq 208(%rsp), %xmm7\\n\"\n  \"  movq 224(%rsp), %xmm8\\n\"\n  \"  movq 240(%rsp), %xmm9\\n\"\n  \"  movq 256(%rsp), %xmm10\\n\"\n  \"  movq 272(%rsp), %xmm11\\n\"\n  \"  movq 288(%rsp), %xmm12\\n\"\n  \"  movq 304(%rsp), %xmm13\\n\"\n  \"  movq 320(%rsp), %xmm14\\n\"\n  \"  movq 336(%rsp), %xmm15\\n\"\n  \"\\n\"\n  \"  leaq 352(%rsp), %rsp\\n\"\n  \"\\n\"\n  \"  jmp  __afl_store\\n\"\n  \"\\n\"\n  \"__afl_die:\\n\"\n  \"\\n\"\n  \"  xorq %rax, %rax\\n\"\n  CALL_L64(\"_exit\")\n  \"\\n\"\n  \"__afl_setup_abort:\\n\"\n  \"\\n\"\n  \"  /* Record setup failure so that we don't keep calling\\n\"\n  \"     shmget() / shmat() over and over again. */\\n\"\n  \"\\n\"\n  \"  incb __afl_setup_failure(%rip)\\n\"\n  \"\\n\"\n  \"  movq %r12, %rsp\\n\"\n  \"  popq %r12\\n\"\n  \"\\n\"\n  \"  movq  0(%rsp), %rax\\n\"\n  \"  movq  8(%rsp), %rcx\\n\"\n  \"  movq 16(%rsp), %rdi\\n\"\n  \"  movq 32(%rsp), %rsi\\n\"\n  \"  movq 40(%rsp), %r8\\n\"\n  \"  movq 48(%rsp), %r9\\n\"\n  \"  movq 56(%rsp), %r10\\n\"\n  \"  movq 64(%rsp), %r11\\n\"\n  \"\\n\"\n  \"  movq  96(%rsp), %xmm0\\n\"\n  \"  movq 112(%rsp), %xmm1\\n\"\n  \"  movq 128(%rsp), %xmm2\\n\"\n  \"  movq 144(%rsp), %xmm3\\n\"\n  \"  movq 160(%rsp), %xmm4\\n\"\n  \"  movq 176(%rsp), %xmm5\\n\"\n  \"  movq 192(%rsp), %xmm6\\n\"\n  \"  movq 208(%rsp), %xmm7\\n\"\n  \"  movq 224(%rsp), %xmm8\\n\"\n  \"  movq 240(%rsp), %xmm9\\n\"\n  \"  movq 256(%rsp), %xmm10\\n\"\n  \"  movq 272(%rsp), %xmm11\\n\"\n  \"  movq 288(%rsp), %xmm12\\n\"\n  \"  movq 304(%rsp), %xmm13\\n\"\n  \"  movq 320(%rsp), %xmm14\\n\"\n  \"  movq 336(%rsp), %xmm15\\n\"\n  \"\\n\"\n  \"  leaq 352(%rsp), %rsp\\n\"\n  \"\\n\"\n  \"  jmp __afl_return\\n\"\n  \"\\n\"\n  \".AFL_VARS:\\n\"\n  \"\\n\"\n\n#ifdef __APPLE__\n\n  \"  .comm   __afl_area_ptr, 8\\n\"\n#ifndef COVERAGE_ONLY\n  \"  .comm   __afl_prev_loc, 8\\n\"\n#endif /* !COVERAGE_ONLY */\n  \"  .comm   __afl_fork_pid, 4\\n\"\n  \"  .comm   __afl_temp, 4\\n\"\n  \"  .comm   __afl_setup_failure, 1\\n\"\n\n#else\n\n  \"  .lcomm   __afl_area_ptr, 8\\n\"\n#ifndef COVERAGE_ONLY\n  \"  .lcomm   __afl_prev_loc, 8\\n\"\n#endif /* !COVERAGE_ONLY */\n  \"  .lcomm   __afl_fork_pid, 4\\n\"\n  \"  .lcomm   __afl_temp, 4\\n\"\n  \"  .lcomm   __afl_setup_failure, 1\\n\"\n\n#endif /* ^__APPLE__ */\n\n  \"  .comm    __afl_global_area_ptr, 8, 8\\n\"\n  \"\\n\"\n  \".AFL_SHM_ENV:\\n\"\n  \"  .asciz \\\"\" SHM_ENV_VAR \"\\\"\\n\"\n  \"\\n\"\n  \"/* --- END --- */\\n\"\n  \"\\n\";\n\n#endif /* !_HAVE_AFL_AS_H */\n"
        },
        {
          "name": "afl-cmin",
          "type": "blob",
          "size": 11.1240234375,
          "content": "#!/usr/bin/env bash\n#\n# american fuzzy lop - corpus minimization tool\n# ---------------------------------------------\n#\n# Written and maintained by Michal Zalewski <lcamtuf@google.com>\n#\n# Copyright 2014, 2015 Google LLC All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# This tool tries to find the smallest subset of files in the input directory\n# that still trigger the full range of instrumentation data points seen in\n# the starting corpus. This has two uses:\n#\n#   - Screening large corpora of input files before using them as a seed for\n#     afl-fuzz. The tool will remove functionally redundant files and likely\n#     leave you with a much smaller set.\n#\n#     (In this case, you probably also want to consider running afl-tmin on\n#     the individual files later on to reduce their size.)\n#\n#   - Minimizing the corpus generated organically by afl-fuzz, perhaps when\n#     planning to feed it to more resource-intensive tools. The tool achieves\n#     this by removing all entries that used to trigger unique behaviors in the\n#     past, but have been made obsolete by later finds.\n#\n# Note that the tool doesn't modify the files themselves. For that, you want\n# afl-tmin.\n#\n# This script must use bash because other shells may have hardcoded limits on\n# array sizes.\n#\n\necho \"corpus minimization tool for afl-fuzz by <lcamtuf@google.com>\"\necho\n\n#########\n# SETUP #\n#########\n\n# Process command-line options...\n\nMEM_LIMIT=100\nTIMEOUT=none\n\nunset IN_DIR OUT_DIR STDIN_FILE EXTRA_PAR MEM_LIMIT_GIVEN \\\n  AFL_CMIN_CRASHES_ONLY AFL_CMIN_ALLOW_ANY QEMU_MODE\n\nwhile getopts \"+i:o:f:m:t:eQC\" opt; do\n\n  case \"$opt\" in \n\n    \"i\")\n         IN_DIR=\"$OPTARG\"\n         ;;\n\n    \"o\")\n         OUT_DIR=\"$OPTARG\"\n         ;;\n    \"f\")\n         STDIN_FILE=\"$OPTARG\"\n         ;;\n    \"m\")\n         MEM_LIMIT=\"$OPTARG\"\n         MEM_LIMIT_GIVEN=1\n         ;;\n    \"t\")\n         TIMEOUT=\"$OPTARG\"\n         ;;\n    \"e\")\n         EXTRA_PAR=\"$EXTRA_PAR -e\"\n         ;;\n    \"C\")\n         export AFL_CMIN_CRASHES_ONLY=1\n         ;;\n    \"Q\")\n         EXTRA_PAR=\"$EXTRA_PAR -Q\"\n         test \"$MEM_LIMIT_GIVEN\" = \"\" && MEM_LIMIT=250\n         QEMU_MODE=1\n         ;;\n    \"?\")\n         exit 1\n         ;;\n\n   esac\n\ndone\n\nshift $((OPTIND-1))\n\nTARGET_BIN=\"$1\"\n\nif [ \"$TARGET_BIN\" = \"\" -o \"$IN_DIR\" = \"\" -o \"$OUT_DIR\" = \"\" ]; then\n\n  cat 1>&2 <<_EOF_\nUsage: $0 [ options ] -- /path/to/target_app [ ... ]\n\nRequired parameters:\n\n  -i dir        - input directory with the starting corpus\n  -o dir        - output directory for minimized files\n\nExecution control settings:\n\n  -f file       - location read by the fuzzed program (stdin)\n  -m megs       - memory limit for child process ($MEM_LIMIT MB)\n  -t msec       - run time limit for child process (none)\n  -Q            - use binary-only instrumentation (QEMU mode)\n\nMinimization settings:\n\n  -C            - keep crashing inputs, reject everything else\n  -e            - solve for edge coverage only, ignore hit counts\n\nFor additional tips, please consult docs/README.\n\n_EOF_\n  exit 1\nfi\n\n# Do a sanity check to discourage the use of /tmp, since we can't really\n# handle this safely from a shell script.\n\nif [ \"$AFL_ALLOW_TMP\" = \"\" ]; then\n\n  echo \"$IN_DIR\" | grep -qE '^(/var)?/tmp/'\n  T1=\"$?\"\n\n  echo \"$TARGET_BIN\" | grep -qE '^(/var)?/tmp/'\n  T2=\"$?\"\n\n  echo \"$OUT_DIR\" | grep -qE '^(/var)?/tmp/'\n  T3=\"$?\"\n\n  echo \"$STDIN_FILE\" | grep -qE '^(/var)?/tmp/'\n  T4=\"$?\"\n\n  echo \"$PWD\" | grep -qE '^(/var)?/tmp/'\n  T5=\"$?\"\n\n  if [ \"$T1\" = \"0\" -o \"$T2\" = \"0\" -o \"$T3\" = \"0\" -o \"$T4\" = \"0\" -o \"$T5\" = \"0\" ]; then\n    echo \"[-] Error: do not use this script in /tmp or /var/tmp.\" 1>&2\n    exit 1\n  fi\n\nfi\n\n# If @@ is specified, but there's no -f, let's come up with a temporary input\n# file name.\n\nTRACE_DIR=\"$OUT_DIR/.traces\"\n\nif [ \"$STDIN_FILE\" = \"\" ]; then\n\n  if echo \"$*\" | grep -qF '@@'; then\n    STDIN_FILE=\"$TRACE_DIR/.cur_input\"\n  fi\n\nfi\n\n# Check for obvious errors.\n\nif [ ! \"$MEM_LIMIT\" = \"none\" ]; then\n\n  if [ \"$MEM_LIMIT\" -lt \"5\" ]; then\n    echo \"[-] Error: dangerously low memory limit.\" 1>&2\n    exit 1\n  fi\n\nfi\n\nif [ ! \"$TIMEOUT\" = \"none\" ]; then\n\n  if [ \"$TIMEOUT\" -lt \"10\" ]; then\n    echo \"[-] Error: dangerously low timeout.\" 1>&2\n    exit 1\n  fi\n\nfi\n\nif [ ! -f \"$TARGET_BIN\" -o ! -x \"$TARGET_BIN\" ]; then\n\n  TNEW=\"`which \"$TARGET_BIN\" 2>/dev/null`\"\n\n  if [ ! -f \"$TNEW\" -o ! -x \"$TNEW\" ]; then\n    echo \"[-] Error: binary '$TARGET_BIN' not found or not executable.\" 1>&2\n    exit 1\n  fi\n\n  TARGET_BIN=\"$TNEW\"\n\nfi\n\nif [ \"$AFL_SKIP_BIN_CHECK\" = \"\" -a \"$QEMU_MODE\" = \"\" ]; then\n\n  if ! grep -qF \"__AFL_SHM_ID\" \"$TARGET_BIN\"; then\n    echo \"[-] Error: binary '$TARGET_BIN' doesn't appear to be instrumented.\" 1>&2\n    exit 1\n  fi\n\nfi\n\nif [ ! -d \"$IN_DIR\" ]; then\n  echo \"[-] Error: directory '$IN_DIR' not found.\" 1>&2\n  exit 1\nfi\n\ntest -d \"$IN_DIR/queue\" && IN_DIR=\"$IN_DIR/queue\"\n\nfind \"$OUT_DIR\" -name 'id[:_]*' -maxdepth 1 -exec rm -- {} \\; 2>/dev/null\nrm -rf \"$TRACE_DIR\" 2>/dev/null\n\nrmdir \"$OUT_DIR\" 2>/dev/null\n\nif [ -d \"$OUT_DIR\" ]; then\n  echo \"[-] Error: directory '$OUT_DIR' exists and is not empty - delete it first.\" 1>&2\n  exit 1\nfi\n\nmkdir -m 700 -p \"$TRACE_DIR\" || exit 1\n\nif [ ! \"$STDIN_FILE\" = \"\" ]; then\n  rm -f \"$STDIN_FILE\" || exit 1\n  touch \"$STDIN_FILE\" || exit 1\nfi\n\nif [ \"$AFL_PATH\" = \"\" ]; then\n  SHOWMAP=\"${0%/afl-cmin}/afl-showmap\"\nelse\n  SHOWMAP=\"$AFL_PATH/afl-showmap\"\nfi\n\nif [ ! -x \"$SHOWMAP\" ]; then\n  echo \"[-] Error: can't find 'afl-showmap' - please set AFL_PATH.\" 1>&2\n  rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\nIN_COUNT=$((`ls -- \"$IN_DIR\" 2>/dev/null | wc -l`))\n\nif [ \"$IN_COUNT\" = \"0\" ]; then\n  echo \"[+] Hmm, no inputs in the target directory. Nothing to be done.\"\n  rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\nFIRST_FILE=`ls \"$IN_DIR\" | head -1`\n\n# Make sure that we're not dealing with a directory.\n\nif [ -d \"$IN_DIR/$FIRST_FILE\" ]; then\n  echo \"[-] Error: The target directory contains subdirectories - please fix.\" 1>&2\n  rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\n# Check for the more efficient way to copy files...\n\nif ln \"$IN_DIR/$FIRST_FILE\" \"$TRACE_DIR/.link_test\" 2>/dev/null; then\n  CP_TOOL=ln\nelse\n  CP_TOOL=cp\nfi\n\n# Make sure that we can actually get anything out of afl-showmap before we\n# waste too much time.\n\necho \"[*] Testing the target binary...\"\n\nif [ \"$STDIN_FILE\" = \"\" ]; then\n\n  AFL_CMIN_ALLOW_ANY=1 \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/.run_test\" -Z $EXTRA_PAR -- \"$@\" <\"$IN_DIR/$FIRST_FILE\"\n\nelse\n\n  cp \"$IN_DIR/$FIRST_FILE\" \"$STDIN_FILE\"\n  AFL_CMIN_ALLOW_ANY=1 \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/.run_test\" -Z $EXTRA_PAR -A \"$STDIN_FILE\" -- \"$@\" </dev/null\n\nfi\n\nFIRST_COUNT=$((`grep -c . \"$TRACE_DIR/.run_test\"`))\n\nif [ \"$FIRST_COUNT\" -gt \"0\" ]; then\n\n  echo \"[+] OK, $FIRST_COUNT tuples recorded.\"\n\nelse\n\n  echo \"[-] Error: no instrumentation output detected (perhaps crash or timeout).\" 1>&2\n  test \"$AFL_KEEP_TRACES\" = \"\" && rm -rf \"$TRACE_DIR\"\n  exit 1\n\nfi\n\n# Let's roll!\n\n#############################\n# STEP 1: COLLECTING TRACES #\n#############################\n\necho \"[*] Obtaining traces for input files in '$IN_DIR'...\"\n\n(\n\n  CUR=0\n\n  if [ \"$STDIN_FILE\" = \"\" ]; then\n\n    while read -r fn; do\n\n      CUR=$((CUR+1))\n      printf \"\\\\r    Processing file $CUR/$IN_COUNT... \"\n\n      \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/$fn\" -Z $EXTRA_PAR -- \"$@\" <\"$IN_DIR/$fn\"\n\n    done < <(ls \"$IN_DIR\")\n\n  else\n\n    while read -r fn; do\n\n      CUR=$((CUR+1))\n      printf \"\\\\r    Processing file $CUR/$IN_COUNT... \"\n\n      cp \"$IN_DIR/$fn\" \"$STDIN_FILE\"\n\n      \"$SHOWMAP\" -m \"$MEM_LIMIT\" -t \"$TIMEOUT\" -o \"$TRACE_DIR/$fn\" -Z $EXTRA_PAR -A \"$STDIN_FILE\" -- \"$@\" </dev/null\n\n    done < <(ls \"$IN_DIR\")\n\n\n  fi\n\n)\n\necho\n\n##########################\n# STEP 2: SORTING TUPLES #\n##########################\n\n# With this out of the way, we sort all tuples by popularity across all\n# datasets. The reasoning here is that we won't be able to avoid the files\n# that trigger unique tuples anyway, so we will want to start with them and\n# see what's left.\n\necho \"[*] Sorting trace sets (this may take a while)...\"\n\nls \"$IN_DIR\" | sed \"s#^#$TRACE_DIR/#\" | tr '\\n' '\\0' | xargs -0 -n 1 cat | \\\n  sort | uniq -c | sort -n >\"$TRACE_DIR/.all_uniq\"\n\nTUPLE_COUNT=$((`grep -c . \"$TRACE_DIR/.all_uniq\"`))\n\necho \"[+] Found $TUPLE_COUNT unique tuples across $IN_COUNT files.\"\n\n#####################################\n# STEP 3: SELECTING CANDIDATE FILES #\n#####################################\n\n# The next step is to find the best candidate for each tuple. The \"best\"\n# part is understood simply as the smallest input that includes a particular\n# tuple in its trace. Empirical evidence suggests that this produces smaller\n# datasets than more involved algorithms that could be still pulled off in\n# a shell script.\n\necho \"[*] Finding best candidates for each tuple...\"\n\nCUR=0\n\nwhile read -r fn; do\n\n  CUR=$((CUR+1))\n  printf \"\\\\r    Processing file $CUR/$IN_COUNT... \"\n\n  sed \"s#\\$# $fn#\" \"$TRACE_DIR/$fn\" >>\"$TRACE_DIR/.candidate_list\"\n\ndone < <(ls -rS \"$IN_DIR\")\n\necho\n\n##############################\n# STEP 4: LOADING CANDIDATES #\n##############################\n\n# At this point, we have a file of tuple-file pairs, sorted by file size\n# in ascending order (as a consequence of ls -rS). By doing sort keyed\n# only by tuple (-k 1,1) and configured to output only the first line for\n# every key (-s -u), we end up with the smallest file for each tuple.\n\necho \"[*] Sorting candidate list (be patient)...\"\n\nsort -k1,1 -s -u \"$TRACE_DIR/.candidate_list\" | \\\n  sed 's/^/BEST_FILE[/;s/ /]=\"/;s/$/\"/' >\"$TRACE_DIR/.candidate_script\"\n\nif [ ! -s \"$TRACE_DIR/.candidate_script\" ]; then\n  echo \"[-] Error: no traces obtained from test cases, check syntax!\" 1>&2\n  test \"$AFL_KEEP_TRACES\" = \"\" && rm -rf \"$TRACE_DIR\"\n  exit 1\nfi\n\n# The sed command converted the sorted list to a shell script that populates\n# BEST_FILE[tuple]=\"fname\". Let's load that!\n\n. \"$TRACE_DIR/.candidate_script\"\n\n##########################\n# STEP 5: WRITING OUTPUT #\n##########################\n\n# The final trick is to grab the top pick for each tuple, unless said tuple is\n# already set due to the inclusion of an earlier candidate; and then put all\n# tuples associated with the newly-added file to the \"already have\" list. The\n# loop works from least popular tuples and toward the most common ones.\n\necho \"[*] Processing candidates and writing output files...\"\n\nCUR=0\n\ntouch \"$TRACE_DIR/.already_have\"\n\nwhile read -r cnt tuple; do\n\n  CUR=$((CUR+1))\n  printf \"\\\\r    Processing tuple $CUR/$TUPLE_COUNT... \"\n\n  # If we already have this tuple, skip it.\n\n  grep -q \"^$tuple\\$\" \"$TRACE_DIR/.already_have\" && continue\n\n  FN=${BEST_FILE[tuple]}\n\n  $CP_TOOL \"$IN_DIR/$FN\" \"$OUT_DIR/$FN\"\n\n  if [ \"$((CUR % 5))\" = \"0\" ]; then\n    sort -u \"$TRACE_DIR/$FN\" \"$TRACE_DIR/.already_have\" >\"$TRACE_DIR/.tmp\"\n    mv -f \"$TRACE_DIR/.tmp\" \"$TRACE_DIR/.already_have\"\n  else\n    cat \"$TRACE_DIR/$FN\" >>\"$TRACE_DIR/.already_have\"\n  fi\n\ndone <\"$TRACE_DIR/.all_uniq\"\n\necho\n\nOUT_COUNT=`ls -- \"$OUT_DIR\" | wc -l`\n\nif [ \"$OUT_COUNT\" = \"1\" ]; then\n  echo \"[!] WARNING: All test cases had the same traces, check syntax!\"\nfi\n\necho \"[+] Narrowed down to $OUT_COUNT files, saved in '$OUT_DIR'.\"\necho\n\ntest \"$AFL_KEEP_TRACES\" = \"\" && rm -rf \"$TRACE_DIR\"\n\nexit 0\n"
        },
        {
          "name": "afl-fuzz.c",
          "type": "blob",
          "size": 204.697265625,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - fuzzer code\n   --------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   Forkserver design by Jann Horn <jannhorn@googlemail.com>\n\n   This is the real deal: the program takes an instrumented binary and\n   attempts a variety of basic fuzzing tricks, paying close attention to\n   how they affect the execution path.\n\n*/\n\n#define AFL_MAIN\n#include \"android-ashmem.h\"\n#define MESSAGES_TO_STDOUT\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define _FILE_OFFSET_BITS 64\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <dlfcn.h>\n#include <sched.h>\n\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/shm.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n\n#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)\n#  include <sys/sysctl.h>\n#endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */\n\n/* For systems that have sched_setaffinity; right now just Linux, but one\n   can hope... */\n\n#ifdef __linux__\n#  define HAVE_AFFINITY 1\n#endif /* __linux__ */\n\n/* A toggle to export some variables when building as a library. Not very\n   useful for the general public. */\n\n#ifdef AFL_LIB\n#  define EXP_ST\n#else\n#  define EXP_ST static\n#endif /* ^AFL_LIB */\n\n/* Lots of globals, but mostly for the status UI and other things where it\n   really makes no sense to haul them around as function parameters. */\n\n\nEXP_ST u8 *in_dir,                    /* Input directory with test cases  */\n          *out_file,                  /* File to fuzz, if any             */\n          *out_dir,                   /* Working & output directory       */\n          *sync_dir,                  /* Synchronization directory        */\n          *sync_id,                   /* Fuzzer ID                        */\n          *use_banner,                /* Display banner                   */\n          *in_bitmap,                 /* Input bitmap                     */\n          *doc_path,                  /* Path to documentation dir        */\n          *target_path,               /* Path to target binary            */\n          *orig_cmdline;              /* Original command line            */\n\nEXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */\nstatic u32 hang_tmout = EXEC_TIMEOUT; /* Timeout used for hang det (ms)   */\n\nEXP_ST u64 mem_limit  = MEM_LIMIT;    /* Memory cap for child (MB)        */\n\nEXP_ST u32 cpu_to_bind = 0;           /* id of free CPU core to bind      */\n\nstatic u32 stats_update_freq = 1;     /* Stats update frequency (execs)   */\n\nEXP_ST u8  skip_deterministic,        /* Skip deterministic stages?       */\n           force_deterministic,       /* Force deterministic stages?      */\n           use_splicing,              /* Recombine input files?           */\n           dumb_mode,                 /* Run in non-instrumented mode?    */\n           score_changed,             /* Scoring for favorites changed?   */\n           kill_signal,               /* Signal that killed the child     */\n           resuming_fuzz,             /* Resuming an older fuzzing job?   */\n           timeout_given,             /* Specific timeout given?          */\n           cpu_to_bind_given,         /* Specified cpu_to_bind given?     */\n           not_on_tty,                /* stdout is not a tty              */\n           term_too_small,            /* terminal dimensions too small    */\n           uses_asan,                 /* Target uses ASAN?                */\n           no_forkserver,             /* Disable forkserver?              */\n           crash_mode,                /* Crash mode! Yeah!                */\n           in_place_resume,           /* Attempt in-place resume?         */\n           auto_changed,              /* Auto-generated tokens changed?   */\n           no_cpu_meter_red,          /* Feng shui on the status screen   */\n           no_arith,                  /* Skip most arithmetic ops         */\n           shuffle_queue,             /* Shuffle input queue?             */\n           bitmap_changed = 1,        /* Time to update bitmap?           */\n           qemu_mode,                 /* Running in QEMU mode?            */\n           skip_requested,            /* Skip request, via SIGUSR1        */\n           run_over10m,               /* Run time over 10 minutes?        */\n           persistent_mode,           /* Running in persistent mode?      */\n           deferred_mode,             /* Deferred forkserver mode?        */\n           fast_cal;                  /* Try to calibrate faster?         */\n\nstatic s32 out_fd,                    /* Persistent fd for out_file       */\n           dev_urandom_fd = -1,       /* Persistent fd for /dev/urandom   */\n           dev_null_fd = -1,          /* Persistent fd for /dev/null      */\n           fsrv_ctl_fd,               /* Fork server control pipe (write) */\n           fsrv_st_fd;                /* Fork server status pipe (read)   */\n\nstatic s32 forksrv_pid,               /* PID of the fork server           */\n           child_pid = -1,            /* PID of the fuzzed program        */\n           out_dir_fd = -1;           /* FD of the lock file              */\n\nEXP_ST u8* trace_bits;                /* SHM with instrumentation bitmap  */\n\nEXP_ST u8  virgin_bits[MAP_SIZE],     /* Regions yet untouched by fuzzing */\n           virgin_tmout[MAP_SIZE],    /* Bits we haven't seen in tmouts   */\n           virgin_crash[MAP_SIZE];    /* Bits we haven't seen in crashes  */\n\nstatic u8  var_bytes[MAP_SIZE];       /* Bytes that appear to be variable */\n\nstatic s32 shm_id;                    /* ID of the SHM region             */\n\nstatic volatile u8 stop_soon,         /* Ctrl-C pressed?                  */\n                   clear_screen = 1,  /* Window resized?                  */\n                   child_timed_out;   /* Traced process timed out?        */\n\nEXP_ST u32 queued_paths,              /* Total number of queued testcases */\n           queued_variable,           /* Testcases with variable behavior */\n           queued_at_start,           /* Total number of initial inputs   */\n           queued_discovered,         /* Items discovered during this run */\n           queued_imported,           /* Items imported via -S            */\n           queued_favored,            /* Paths deemed favorable           */\n           queued_with_cov,           /* Paths with new coverage bytes    */\n           pending_not_fuzzed,        /* Queued but not done yet          */\n           pending_favored,           /* Pending favored paths            */\n           cur_skipped_paths,         /* Abandoned inputs in cur cycle    */\n           cur_depth,                 /* Current path depth               */\n           max_depth,                 /* Max path depth                   */\n           useless_at_start,          /* Number of useless starting paths */\n           var_byte_count,            /* Bitmap bytes with var behavior   */\n           current_entry,             /* Current queue entry ID           */\n           havoc_div = 1;             /* Cycle count divisor for havoc    */\n\nEXP_ST u64 total_crashes,             /* Total number of crashes          */\n           unique_crashes,            /* Crashes with unique signatures   */\n           total_tmouts,              /* Total number of timeouts         */\n           unique_tmouts,             /* Timeouts with unique signatures  */\n           unique_hangs,              /* Hangs with unique signatures     */\n           total_execs,               /* Total execve() calls             */\n           slowest_exec_ms,           /* Slowest testcase non hang in ms  */\n           start_time,                /* Unix start time (ms)             */\n           last_path_time,            /* Time for most recent path (ms)   */\n           last_crash_time,           /* Time for most recent crash (ms)  */\n           last_hang_time,            /* Time for most recent hang (ms)   */\n           last_crash_execs,          /* Exec counter at last crash       */\n           queue_cycle,               /* Queue round counter              */\n           cycles_wo_finds,           /* Cycles without any new paths     */\n           trim_execs,                /* Execs done to trim input files   */\n           bytes_trim_in,             /* Bytes coming into the trimmer    */\n           bytes_trim_out,            /* Bytes coming outa the trimmer    */\n           blocks_eff_total,          /* Blocks subject to effector maps  */\n           blocks_eff_select;         /* Blocks selected as fuzzable      */\n\nstatic u32 subseq_tmouts;             /* Number of timeouts in a row      */\n\nstatic u8 *stage_name = \"init\",       /* Name of the current fuzz stage   */\n          *stage_short,               /* Short stage name                 */\n          *syncing_party;             /* Currently syncing with...        */\n\nstatic s32 stage_cur, stage_max;      /* Stage progression                */\nstatic s32 splicing_with = -1;        /* Splicing with which test case?   */\n\nstatic u32 master_id, master_max;     /* Master instance job splitting    */\n\nstatic u32 syncing_case;              /* Syncing with case #...           */\n\nstatic s32 stage_cur_byte,            /* Byte offset of current stage op  */\n           stage_cur_val;             /* Value used for stage op          */\n\nstatic u8  stage_val_type;            /* Value type (STAGE_VAL_*)         */\n\nstatic u64 stage_finds[32],           /* Patterns found per fuzz stage    */\n           stage_cycles[32];          /* Execs per fuzz stage             */\n\nstatic u32 rand_cnt;                  /* Random number counter            */\n\nstatic u64 total_cal_us,              /* Total calibration time (us)      */\n           total_cal_cycles;          /* Total calibration cycles         */\n\nstatic u64 total_bitmap_size,         /* Total bit count for all bitmaps  */\n           total_bitmap_entries;      /* Number of bitmaps counted        */\n\nstatic s32 cpu_core_count;            /* CPU core count                   */\n\n#ifdef HAVE_AFFINITY\n\nstatic s32 cpu_aff = -1;       \t      /* Selected CPU core                */\n\n#endif /* HAVE_AFFINITY */\n\nstatic FILE* plot_file;               /* Gnuplot output file              */\n\nstruct queue_entry {\n\n  u8* fname;                          /* File name for the test case      */\n  u32 len;                            /* Input length                     */\n\n  u8  cal_failed,                     /* Calibration failed?              */\n      trim_done,                      /* Trimmed?                         */\n      was_fuzzed,                     /* Had any fuzzing done yet?        */\n      passed_det,                     /* Deterministic stages passed?     */\n      has_new_cov,                    /* Triggers new coverage?           */\n      var_behavior,                   /* Variable behavior?               */\n      favored,                        /* Currently favored?               */\n      fs_redundant;                   /* Marked as redundant in the fs?   */\n\n  u32 bitmap_size,                    /* Number of bits set in bitmap     */\n      exec_cksum;                     /* Checksum of the execution trace  */\n\n  u64 exec_us,                        /* Execution time (us)              */\n      handicap,                       /* Number of queue cycles behind    */\n      depth;                          /* Path depth                       */\n\n  u8* trace_mini;                     /* Trace bytes, if kept             */\n  u32 tc_ref;                         /* Trace bytes ref count            */\n\n  struct queue_entry *next,           /* Next element, if any             */\n                     *next_100;       /* 100 elements ahead               */\n\n};\n\nstatic struct queue_entry *queue,     /* Fuzzing queue (linked list)      */\n                          *queue_cur, /* Current offset within the queue  */\n                          *queue_top, /* Top of the list                  */\n                          *q_prev100; /* Previous 100 marker              */\n\nstatic struct queue_entry*\n  top_rated[MAP_SIZE];                /* Top entries for bitmap bytes     */\n\nstruct extra_data {\n  u8* data;                           /* Dictionary token data            */\n  u32 len;                            /* Dictionary token length          */\n  u32 hit_cnt;                        /* Use count in the corpus          */\n};\n\nstatic struct extra_data* extras;     /* Extra tokens to fuzz with        */\nstatic u32 extras_cnt;                /* Total number of tokens read      */\n\nstatic struct extra_data* a_extras;   /* Automatically selected extras    */\nstatic u32 a_extras_cnt;              /* Total number of tokens available */\n\nstatic u8* (*post_handler)(u8* buf, u32* len);\n\n/* Interesting values, as per config.h */\n\nstatic s8  interesting_8[]  = { INTERESTING_8 };\nstatic s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 };\nstatic s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 };\n\n/* Fuzzing stages */\n\nenum {\n  /* 00 */ STAGE_FLIP1,\n  /* 01 */ STAGE_FLIP2,\n  /* 02 */ STAGE_FLIP4,\n  /* 03 */ STAGE_FLIP8,\n  /* 04 */ STAGE_FLIP16,\n  /* 05 */ STAGE_FLIP32,\n  /* 06 */ STAGE_ARITH8,\n  /* 07 */ STAGE_ARITH16,\n  /* 08 */ STAGE_ARITH32,\n  /* 09 */ STAGE_INTEREST8,\n  /* 10 */ STAGE_INTEREST16,\n  /* 11 */ STAGE_INTEREST32,\n  /* 12 */ STAGE_EXTRAS_UO,\n  /* 13 */ STAGE_EXTRAS_UI,\n  /* 14 */ STAGE_EXTRAS_AO,\n  /* 15 */ STAGE_HAVOC,\n  /* 16 */ STAGE_SPLICE\n};\n\n/* Stage value types */\n\nenum {\n  /* 00 */ STAGE_VAL_NONE,\n  /* 01 */ STAGE_VAL_LE,\n  /* 02 */ STAGE_VAL_BE\n};\n\n/* Execution status fault codes */\n\nenum {\n  /* 00 */ FAULT_NONE,\n  /* 01 */ FAULT_TMOUT,\n  /* 02 */ FAULT_CRASH,\n  /* 03 */ FAULT_ERROR,\n  /* 04 */ FAULT_NOINST,\n  /* 05 */ FAULT_NOBITS\n};\n\n\n/* Get unix time in milliseconds */\n\nstatic u64 get_cur_time(void) {\n\n  struct timeval tv;\n  struct timezone tz;\n\n  gettimeofday(&tv, &tz);\n\n  return (tv.tv_sec * 1000ULL) + (tv.tv_usec / 1000);\n\n}\n\n\n/* Get unix time in microseconds */\n\nstatic u64 get_cur_time_us(void) {\n\n  struct timeval tv;\n  struct timezone tz;\n\n  gettimeofday(&tv, &tz);\n\n  return (tv.tv_sec * 1000000ULL) + tv.tv_usec;\n\n}\n\n\n/* Generate a random number (from 0 to limit - 1). This may\n   have slight bias. */\n\nstatic inline u32 UR(u32 limit) {\n\n  if (unlikely(!rand_cnt--)) {\n\n    u32 seed[2];\n\n    ck_read(dev_urandom_fd, &seed, sizeof(seed), \"/dev/urandom\");\n\n    srandom(seed[0]);\n    rand_cnt = (RESEED_RNG / 2) + (seed[1] % RESEED_RNG);\n\n  }\n\n  return random() % limit;\n\n}\n\n\n/* Shuffle an array of pointers. Might be slightly biased. */\n\nstatic void shuffle_ptrs(void** ptrs, u32 cnt) {\n\n  u32 i;\n\n  for (i = 0; i < cnt - 2; i++) {\n\n    u32 j = i + UR(cnt - i);\n    void *s = ptrs[i];\n    ptrs[i] = ptrs[j];\n    ptrs[j] = s;\n\n  }\n\n}\n\n\n#ifdef HAVE_AFFINITY\n\n/* Build a list of processes bound to specific cores. Returns -1 if nothing\n   can be found. Assumes an upper bound of 4k CPUs. */\n\nstatic void bind_to_free_cpu(void) {\n\n  DIR* d;\n  struct dirent* de;\n  cpu_set_t c;\n\n  u8 cpu_used[4096] = { 0 };\n  u32 i;\n\n  if (cpu_core_count < 2) return;\n\n  if (getenv(\"AFL_NO_AFFINITY\")) {\n\n    WARNF(\"Not binding to a CPU core (AFL_NO_AFFINITY set).\");\n    return;\n\n  }\n\n  d = opendir(\"/proc\");\n\n  if (!d) {\n\n    WARNF(\"Unable to access /proc - can't scan for free CPU cores.\");\n    return;\n\n  }\n\n  ACTF(\"Checking CPU core loadout...\");\n\n  /* Introduce some jitter, in case multiple AFL tasks are doing the same\n     thing at the same time... */\n\n  usleep(R(1000) * 250);\n\n  /* Scan all /proc/<pid>/status entries, checking for Cpus_allowed_list.\n     Flag all processes bound to a specific CPU using cpu_used[]. This will\n     fail for some exotic binding setups, but is likely good enough in almost\n     all real-world use cases. */\n\n  while ((de = readdir(d))) {\n\n    u8* fn;\n    FILE* f;\n    u8 tmp[MAX_LINE];\n    u8 has_vmsize = 0;\n\n    if (!isdigit(de->d_name[0])) continue;\n\n    fn = alloc_printf(\"/proc/%s/status\", de->d_name);\n\n    if (!(f = fopen(fn, \"r\"))) {\n      ck_free(fn);\n      continue;\n    }\n\n    while (fgets(tmp, MAX_LINE, f)) {\n\n      u32 hval;\n\n      /* Processes without VmSize are probably kernel tasks. */\n\n      if (!strncmp(tmp, \"VmSize:\\t\", 8)) has_vmsize = 1;\n\n      if (!strncmp(tmp, \"Cpus_allowed_list:\\t\", 19) &&\n          !strchr(tmp, '-') && !strchr(tmp, ',') &&\n          sscanf(tmp + 19, \"%u\", &hval) == 1 && hval < sizeof(cpu_used) &&\n          has_vmsize) {\n\n        cpu_used[hval] = 1;\n        break;\n\n      }\n\n    }\n\n    ck_free(fn);\n    fclose(f);\n\n  }\n\n  closedir(d);\n  if (cpu_to_bind_given) {\n\n    if (cpu_to_bind >= cpu_core_count)\n      FATAL(\"The CPU core id to bind should be between 0 and %u\", cpu_core_count - 1);\n    \n    if (cpu_used[cpu_to_bind])\n      FATAL(\"The CPU core #%u to bind is not free!\", cpu_to_bind);\n\n    i = cpu_to_bind;\n    \n  } else {\n\n    for (i = 0; i < cpu_core_count; i++) if (!cpu_used[i]) break;\n    \n  }\n\n  if (i == cpu_core_count) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Uh-oh, looks like all %u CPU cores on your system are allocated to\\n\"\n         \"    other instances of afl-fuzz (or similar CPU-locked tasks). Starting\\n\"\n         \"    another fuzzer on this machine is probably a bad plan, but if you are\\n\"\n         \"    absolutely sure, you can set AFL_NO_AFFINITY and try again.\\n\",\n         cpu_core_count);\n\n    FATAL(\"No more free CPU cores\");\n\n  }\n\n  OKF(\"Found a free CPU core, binding to #%u.\", i);\n\n  cpu_aff = i;\n\n  CPU_ZERO(&c);\n  CPU_SET(i, &c);\n\n  if (sched_setaffinity(0, sizeof(c), &c))\n    PFATAL(\"sched_setaffinity failed\");\n\n}\n\n#endif /* HAVE_AFFINITY */\n\n#ifndef IGNORE_FINDS\n\n/* Helper function to compare buffers; returns first and last differing offset. We\n   use this to find reasonable locations for splicing two files. */\n\nstatic void locate_diffs(u8* ptr1, u8* ptr2, u32 len, s32* first, s32* last) {\n\n  s32 f_loc = -1;\n  s32 l_loc = -1;\n  u32 pos;\n\n  for (pos = 0; pos < len; pos++) {\n\n    if (*(ptr1++) != *(ptr2++)) {\n\n      if (f_loc == -1) f_loc = pos;\n      l_loc = pos;\n\n    }\n\n  }\n\n  *first = f_loc;\n  *last = l_loc;\n\n  return;\n\n}\n\n#endif /* !IGNORE_FINDS */\n\n\n/* Describe integer. Uses 12 cyclic static buffers for return values. The value\n   returned should be five characters or less for all the integers we reasonably\n   expect to see. */\n\nstatic u8* DI(u64 val) {\n\n  static u8 tmp[12][16];\n  static u8 cur;\n\n  cur = (cur + 1) % 12;\n\n#define CHK_FORMAT(_divisor, _limit_mult, _fmt, _cast) do { \\\n    if (val < (_divisor) * (_limit_mult)) { \\\n      sprintf(tmp[cur], _fmt, ((_cast)val) / (_divisor)); \\\n      return tmp[cur]; \\\n    } \\\n  } while (0)\n\n  /* 0-9999 */\n  CHK_FORMAT(1, 10000, \"%llu\", u64);\n\n  /* 10.0k - 99.9k */\n  CHK_FORMAT(1000, 99.95, \"%0.01fk\", double);\n\n  /* 100k - 999k */\n  CHK_FORMAT(1000, 1000, \"%lluk\", u64);\n\n  /* 1.00M - 9.99M */\n  CHK_FORMAT(1000 * 1000, 9.995, \"%0.02fM\", double);\n\n  /* 10.0M - 99.9M */\n  CHK_FORMAT(1000 * 1000, 99.95, \"%0.01fM\", double);\n\n  /* 100M - 999M */\n  CHK_FORMAT(1000 * 1000, 1000, \"%lluM\", u64);\n\n  /* 1.00G - 9.99G */\n  CHK_FORMAT(1000LL * 1000 * 1000, 9.995, \"%0.02fG\", double);\n\n  /* 10.0G - 99.9G */\n  CHK_FORMAT(1000LL * 1000 * 1000, 99.95, \"%0.01fG\", double);\n\n  /* 100G - 999G */\n  CHK_FORMAT(1000LL * 1000 * 1000, 1000, \"%lluG\", u64);\n\n  /* 1.00T - 9.99G */\n  CHK_FORMAT(1000LL * 1000 * 1000 * 1000, 9.995, \"%0.02fT\", double);\n\n  /* 10.0T - 99.9T */\n  CHK_FORMAT(1000LL * 1000 * 1000 * 1000, 99.95, \"%0.01fT\", double);\n\n  /* 100T+ */\n  strcpy(tmp[cur], \"infty\");\n  return tmp[cur];\n\n}\n\n\n/* Describe float. Similar to the above, except with a single \n   static buffer. */\n\nstatic u8* DF(double val) {\n\n  static u8 tmp[16];\n\n  if (val < 99.995) {\n    sprintf(tmp, \"%0.02f\", val);\n    return tmp;\n  }\n\n  if (val < 999.95) {\n    sprintf(tmp, \"%0.01f\", val);\n    return tmp;\n  }\n\n  return DI((u64)val);\n\n}\n\n\n/* Describe integer as memory size. */\n\nstatic u8* DMS(u64 val) {\n\n  static u8 tmp[12][16];\n  static u8 cur;\n\n  cur = (cur + 1) % 12;\n\n  /* 0-9999 */\n  CHK_FORMAT(1, 10000, \"%llu B\", u64);\n\n  /* 10.0k - 99.9k */\n  CHK_FORMAT(1024, 99.95, \"%0.01f kB\", double);\n\n  /* 100k - 999k */\n  CHK_FORMAT(1024, 1000, \"%llu kB\", u64);\n\n  /* 1.00M - 9.99M */\n  CHK_FORMAT(1024 * 1024, 9.995, \"%0.02f MB\", double);\n\n  /* 10.0M - 99.9M */\n  CHK_FORMAT(1024 * 1024, 99.95, \"%0.01f MB\", double);\n\n  /* 100M - 999M */\n  CHK_FORMAT(1024 * 1024, 1000, \"%llu MB\", u64);\n\n  /* 1.00G - 9.99G */\n  CHK_FORMAT(1024LL * 1024 * 1024, 9.995, \"%0.02f GB\", double);\n\n  /* 10.0G - 99.9G */\n  CHK_FORMAT(1024LL * 1024 * 1024, 99.95, \"%0.01f GB\", double);\n\n  /* 100G - 999G */\n  CHK_FORMAT(1024LL * 1024 * 1024, 1000, \"%llu GB\", u64);\n\n  /* 1.00T - 9.99G */\n  CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 9.995, \"%0.02f TB\", double);\n\n  /* 10.0T - 99.9T */\n  CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 99.95, \"%0.01f TB\", double);\n\n#undef CHK_FORMAT\n\n  /* 100T+ */\n  strcpy(tmp[cur], \"infty\");\n  return tmp[cur];\n\n}\n\n\n/* Describe time delta. Returns one static buffer, 34 chars of less. */\n\nstatic u8* DTD(u64 cur_ms, u64 event_ms) {\n\n  static u8 tmp[64];\n  u64 delta;\n  s32 t_d, t_h, t_m, t_s;\n\n  if (!event_ms) return \"none seen yet\";\n\n  delta = cur_ms - event_ms;\n\n  t_d = delta / 1000 / 60 / 60 / 24;\n  t_h = (delta / 1000 / 60 / 60) % 24;\n  t_m = (delta / 1000 / 60) % 60;\n  t_s = (delta / 1000) % 60;\n\n  sprintf(tmp, \"%s days, %u hrs, %u min, %u sec\", DI(t_d), t_h, t_m, t_s);\n  return tmp;\n\n}\n\n\n/* Mark deterministic checks as done for a particular queue entry. We use the\n   .state file to avoid repeating deterministic fuzzing when resuming aborted\n   scans. */\n\nstatic void mark_as_det_done(struct queue_entry* q) {\n\n  u8* fn = strrchr(q->fname, '/');\n  s32 fd;\n\n  fn = alloc_printf(\"%s/queue/.state/deterministic_done/%s\", out_dir, fn + 1);\n\n  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);\n  if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n  close(fd);\n\n  ck_free(fn);\n\n  q->passed_det = 1;\n\n}\n\n\n/* Mark as variable. Create symlinks if possible to make it easier to examine\n   the files. */\n\nstatic void mark_as_variable(struct queue_entry* q) {\n\n  u8 *fn = strrchr(q->fname, '/') + 1, *ldest;\n\n  ldest = alloc_printf(\"../../%s\", fn);\n  fn = alloc_printf(\"%s/queue/.state/variable_behavior/%s\", out_dir, fn);\n\n  if (symlink(ldest, fn)) {\n\n    s32 fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n    close(fd);\n\n  }\n\n  ck_free(ldest);\n  ck_free(fn);\n\n  q->var_behavior = 1;\n\n}\n\n\n/* Mark / unmark as redundant (edge-only). This is not used for restoring state,\n   but may be useful for post-processing datasets. */\n\nstatic void mark_as_redundant(struct queue_entry* q, u8 state) {\n\n  u8* fn;\n  s32 fd;\n\n  if (state == q->fs_redundant) return;\n\n  q->fs_redundant = state;\n\n  fn = strrchr(q->fname, '/');\n  fn = alloc_printf(\"%s/queue/.state/redundant_edges/%s\", out_dir, fn + 1);\n\n  if (state) {\n\n    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n    close(fd);\n\n  } else {\n\n    if (unlink(fn)) PFATAL(\"Unable to remove '%s'\", fn);\n\n  }\n\n  ck_free(fn);\n\n}\n\n\n/* Append new test case to the queue. */\n\nstatic void add_to_queue(u8* fname, u32 len, u8 passed_det) {\n\n  struct queue_entry* q = ck_alloc(sizeof(struct queue_entry));\n\n  q->fname        = fname;\n  q->len          = len;\n  q->depth        = cur_depth + 1;\n  q->passed_det   = passed_det;\n\n  if (q->depth > max_depth) max_depth = q->depth;\n\n  if (queue_top) {\n\n    queue_top->next = q;\n    queue_top = q;\n\n  } else q_prev100 = queue = queue_top = q;\n\n  queued_paths++;\n  pending_not_fuzzed++;\n\n  cycles_wo_finds = 0;\n\n  /* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */\n  if ((queued_paths - 1) % 100 == 0 && queued_paths > 1) {\n\n    q_prev100->next_100 = q;\n    q_prev100 = q;\n\n  }\n\n  last_path_time = get_cur_time();\n\n}\n\n\n/* Destroy the entire queue. */\n\nEXP_ST void destroy_queue(void) {\n\n  struct queue_entry *q = queue, *n;\n\n  while (q) {\n\n    n = q->next;\n    ck_free(q->fname);\n    ck_free(q->trace_mini);\n    ck_free(q);\n    q = n;\n\n  }\n\n}\n\n\n/* Write bitmap to file. The bitmap is useful mostly for the secret\n   -B option, to focus a separate fuzzing session on a particular\n   interesting input without rediscovering all the others. */\n\nEXP_ST void write_bitmap(void) {\n\n  u8* fname;\n  s32 fd;\n\n  if (!bitmap_changed) return;\n  bitmap_changed = 0;\n\n  fname = alloc_printf(\"%s/fuzz_bitmap\", out_dir);\n  fd = open(fname, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", fname);\n\n  ck_write(fd, virgin_bits, MAP_SIZE, fname);\n\n  close(fd);\n  ck_free(fname);\n\n}\n\n\n/* Read bitmap from file. This is for the -B option again. */\n\nEXP_ST void read_bitmap(u8* fname) {\n\n  s32 fd = open(fname, O_RDONLY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", fname);\n\n  ck_read(fd, virgin_bits, MAP_SIZE, fname);\n\n  close(fd);\n\n}\n\n\n/* Check if the current execution path brings anything new to the table.\n   Update virgin bits to reflect the finds. Returns 1 if the only change is\n   the hit-count for a particular tuple; 2 if there are new tuples seen. \n   Updates the map, so subsequent calls will always return 0.\n\n   This function is called after every exec() on a fairly large buffer, so\n   it needs to be fast. We do this in 32-bit and 64-bit flavors. */\n\nstatic inline u8 has_new_bits(u8* virgin_map) {\n\n#ifdef WORD_SIZE_64\n\n  u64* current = (u64*)trace_bits;\n  u64* virgin  = (u64*)virgin_map;\n\n  u32  i = (MAP_SIZE >> 3);\n\n#else\n\n  u32* current = (u32*)trace_bits;\n  u32* virgin  = (u32*)virgin_map;\n\n  u32  i = (MAP_SIZE >> 2);\n\n#endif /* ^WORD_SIZE_64 */\n\n  u8   ret = 0;\n\n  while (i--) {\n\n    /* Optimize for (*current & *virgin) == 0 - i.e., no bits in current bitmap\n       that have not been already cleared from the virgin map - since this will\n       almost always be the case. */\n\n    if (unlikely(*current) && unlikely(*current & *virgin)) {\n\n      if (likely(ret < 2)) {\n\n        u8* cur = (u8*)current;\n        u8* vir = (u8*)virgin;\n\n        /* Looks like we have not found any new bytes yet; see if any non-zero\n           bytes in current[] are pristine in virgin[]. */\n\n#ifdef WORD_SIZE_64\n\n        if ((cur[0] && vir[0] == 0xff) || (cur[1] && vir[1] == 0xff) ||\n            (cur[2] && vir[2] == 0xff) || (cur[3] && vir[3] == 0xff) ||\n            (cur[4] && vir[4] == 0xff) || (cur[5] && vir[5] == 0xff) ||\n            (cur[6] && vir[6] == 0xff) || (cur[7] && vir[7] == 0xff)) ret = 2;\n        else ret = 1;\n\n#else\n\n        if ((cur[0] && vir[0] == 0xff) || (cur[1] && vir[1] == 0xff) ||\n            (cur[2] && vir[2] == 0xff) || (cur[3] && vir[3] == 0xff)) ret = 2;\n        else ret = 1;\n\n#endif /* ^WORD_SIZE_64 */\n\n      }\n\n      *virgin &= ~*current;\n\n    }\n\n    current++;\n    virgin++;\n\n  }\n\n  if (ret && virgin_map == virgin_bits) bitmap_changed = 1;\n\n  return ret;\n\n}\n\n\n/* Count the number of bits set in the provided bitmap. Used for the status\n   screen several times every second, does not have to be fast. */\n\nstatic u32 count_bits(u8* mem) {\n\n  u32* ptr = (u32*)mem;\n  u32  i   = (MAP_SIZE >> 2);\n  u32  ret = 0;\n\n  while (i--) {\n\n    u32 v = *(ptr++);\n\n    /* This gets called on the inverse, virgin bitmap; optimize for sparse\n       data. */\n\n    if (v == 0xffffffff) {\n      ret += 32;\n      continue;\n    }\n\n    v -= ((v >> 1) & 0x55555555);\n    v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n    ret += (((v + (v >> 4)) & 0xF0F0F0F) * 0x01010101) >> 24;\n\n  }\n\n  return ret;\n\n}\n\n\n#define FF(_b)  (0xff << ((_b) << 3))\n\n/* Count the number of bytes set in the bitmap. Called fairly sporadically,\n   mostly to update the status screen or calibrate and examine confirmed\n   new paths. */\n\nstatic u32 count_bytes(u8* mem) {\n\n  u32* ptr = (u32*)mem;\n  u32  i   = (MAP_SIZE >> 2);\n  u32  ret = 0;\n\n  while (i--) {\n\n    u32 v = *(ptr++);\n\n    if (!v) continue;\n    if (v & FF(0)) ret++;\n    if (v & FF(1)) ret++;\n    if (v & FF(2)) ret++;\n    if (v & FF(3)) ret++;\n\n  }\n\n  return ret;\n\n}\n\n\n/* Count the number of non-255 bytes set in the bitmap. Used strictly for the\n   status screen, several calls per second or so. */\n\nstatic u32 count_non_255_bytes(u8* mem) {\n\n  u32* ptr = (u32*)mem;\n  u32  i   = (MAP_SIZE >> 2);\n  u32  ret = 0;\n\n  while (i--) {\n\n    u32 v = *(ptr++);\n\n    /* This is called on the virgin bitmap, so optimize for the most likely\n       case. */\n\n    if (v == 0xffffffff) continue;\n    if ((v & FF(0)) != FF(0)) ret++;\n    if ((v & FF(1)) != FF(1)) ret++;\n    if ((v & FF(2)) != FF(2)) ret++;\n    if ((v & FF(3)) != FF(3)) ret++;\n\n  }\n\n  return ret;\n\n}\n\n\n/* Destructively simplify trace by eliminating hit count information\n   and replacing it with 0x80 or 0x01 depending on whether the tuple\n   is hit or not. Called on every new crash or timeout, should be\n   reasonably fast. */\n\nstatic const u8 simplify_lookup[256] = { \n\n  [0]         = 1,\n  [1 ... 255] = 128\n\n};\n\n#ifdef WORD_SIZE_64\n\nstatic void simplify_trace(u64* mem) {\n\n  u32 i = MAP_SIZE >> 3;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (unlikely(*mem)) {\n\n      u8* mem8 = (u8*)mem;\n\n      mem8[0] = simplify_lookup[mem8[0]];\n      mem8[1] = simplify_lookup[mem8[1]];\n      mem8[2] = simplify_lookup[mem8[2]];\n      mem8[3] = simplify_lookup[mem8[3]];\n      mem8[4] = simplify_lookup[mem8[4]];\n      mem8[5] = simplify_lookup[mem8[5]];\n      mem8[6] = simplify_lookup[mem8[6]];\n      mem8[7] = simplify_lookup[mem8[7]];\n\n    } else *mem = 0x0101010101010101ULL;\n\n    mem++;\n\n  }\n\n}\n\n#else\n\nstatic void simplify_trace(u32* mem) {\n\n  u32 i = MAP_SIZE >> 2;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (unlikely(*mem)) {\n\n      u8* mem8 = (u8*)mem;\n\n      mem8[0] = simplify_lookup[mem8[0]];\n      mem8[1] = simplify_lookup[mem8[1]];\n      mem8[2] = simplify_lookup[mem8[2]];\n      mem8[3] = simplify_lookup[mem8[3]];\n\n    } else *mem = 0x01010101;\n\n    mem++;\n  }\n\n}\n\n#endif /* ^WORD_SIZE_64 */\n\n\n/* Destructively classify execution counts in a trace. This is used as a\n   preprocessing step for any newly acquired traces. Called on every exec,\n   must be fast. */\n\nstatic const u8 count_class_lookup8[256] = {\n\n  [0]           = 0,\n  [1]           = 1,\n  [2]           = 2,\n  [3]           = 4,\n  [4 ... 7]     = 8,\n  [8 ... 15]    = 16,\n  [16 ... 31]   = 32,\n  [32 ... 127]  = 64,\n  [128 ... 255] = 128\n\n};\n\nstatic u16 count_class_lookup16[65536];\n\n\nEXP_ST void init_count_class16(void) {\n\n  u32 b1, b2;\n\n  for (b1 = 0; b1 < 256; b1++) \n    for (b2 = 0; b2 < 256; b2++)\n      count_class_lookup16[(b1 << 8) + b2] = \n        (count_class_lookup8[b1] << 8) |\n        count_class_lookup8[b2];\n\n}\n\n\n#ifdef WORD_SIZE_64\n\nstatic inline void classify_counts(u64* mem) {\n\n  u32 i = MAP_SIZE >> 3;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (unlikely(*mem)) {\n\n      u16* mem16 = (u16*)mem;\n\n      mem16[0] = count_class_lookup16[mem16[0]];\n      mem16[1] = count_class_lookup16[mem16[1]];\n      mem16[2] = count_class_lookup16[mem16[2]];\n      mem16[3] = count_class_lookup16[mem16[3]];\n\n    }\n\n    mem++;\n\n  }\n\n}\n\n#else\n\nstatic inline void classify_counts(u32* mem) {\n\n  u32 i = MAP_SIZE >> 2;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (unlikely(*mem)) {\n\n      u16* mem16 = (u16*)mem;\n\n      mem16[0] = count_class_lookup16[mem16[0]];\n      mem16[1] = count_class_lookup16[mem16[1]];\n\n    }\n\n    mem++;\n\n  }\n\n}\n\n#endif /* ^WORD_SIZE_64 */\n\n\n/* Get rid of shared memory (atexit handler). */\n\nstatic void remove_shm(void) {\n\n  shmctl(shm_id, IPC_RMID, NULL);\n\n}\n\n\n/* Compact trace bytes into a smaller bitmap. We effectively just drop the\n   count information here. This is called only sporadically, for some\n   new paths. */\n\nstatic void minimize_bits(u8* dst, u8* src) {\n\n  u32 i = 0;\n\n  while (i < MAP_SIZE) {\n\n    if (*(src++)) dst[i >> 3] |= 1 << (i & 7);\n    i++;\n\n  }\n\n}\n\n\n/* When we bump into a new path, we call this to see if the path appears\n   more \"favorable\" than any of the existing ones. The purpose of the\n   \"favorables\" is to have a minimal set of paths that trigger all the bits\n   seen in the bitmap so far, and focus on fuzzing them at the expense of\n   the rest.\n\n   The first step of the process is to maintain a list of top_rated[] entries\n   for every byte in the bitmap. We win that slot if there is no previous\n   contender, or if the contender has a more favorable speed x size factor. */\n\nstatic void update_bitmap_score(struct queue_entry* q) {\n\n  u32 i;\n  u64 fav_factor = q->exec_us * q->len;\n\n  /* For every byte set in trace_bits[], see if there is a previous winner,\n     and how it compares to us. */\n\n  for (i = 0; i < MAP_SIZE; i++)\n\n    if (trace_bits[i]) {\n\n       if (top_rated[i]) {\n\n         /* Faster-executing or smaller test cases are favored. */\n\n         if (fav_factor > top_rated[i]->exec_us * top_rated[i]->len) continue;\n\n         /* Looks like we're going to win. Decrease ref count for the\n            previous winner, discard its trace_bits[] if necessary. */\n\n         if (!--top_rated[i]->tc_ref) {\n           ck_free(top_rated[i]->trace_mini);\n           top_rated[i]->trace_mini = 0;\n         }\n\n       }\n\n       /* Insert ourselves as the new winner. */\n\n       top_rated[i] = q;\n       q->tc_ref++;\n\n       if (!q->trace_mini) {\n         q->trace_mini = ck_alloc(MAP_SIZE >> 3);\n         minimize_bits(q->trace_mini, trace_bits);\n       }\n\n       score_changed = 1;\n\n     }\n\n}\n\n\n/* The second part of the mechanism discussed above is a routine that\n   goes over top_rated[] entries, and then sequentially grabs winners for\n   previously-unseen bytes (temp_v) and marks them as favored, at least\n   until the next run. The favored entries are given more air time during\n   all fuzzing steps. */\n\nstatic void cull_queue(void) {\n\n  struct queue_entry* q;\n  static u8 temp_v[MAP_SIZE >> 3];\n  u32 i;\n\n  if (dumb_mode || !score_changed) return;\n\n  score_changed = 0;\n\n  memset(temp_v, 255, MAP_SIZE >> 3);\n\n  queued_favored  = 0;\n  pending_favored = 0;\n\n  q = queue;\n\n  while (q) {\n    q->favored = 0;\n    q = q->next;\n  }\n\n  /* Let's see if anything in the bitmap isn't captured in temp_v.\n     If yes, and if it has a top_rated[] contender, let's use it. */\n\n  for (i = 0; i < MAP_SIZE; i++)\n    if (top_rated[i] && (temp_v[i >> 3] & (1 << (i & 7)))) {\n\n      u32 j = MAP_SIZE >> 3;\n\n      /* Remove all bits belonging to the current entry from temp_v. */\n\n      while (j--) \n        if (top_rated[i]->trace_mini[j])\n          temp_v[j] &= ~top_rated[i]->trace_mini[j];\n\n      top_rated[i]->favored = 1;\n      queued_favored++;\n\n      if (!top_rated[i]->was_fuzzed) pending_favored++;\n\n    }\n\n  q = queue;\n\n  while (q) {\n    mark_as_redundant(q, !q->favored);\n    q = q->next;\n  }\n\n}\n\n\n/* Configure shared memory and virgin_bits. This is called at startup. */\n\nEXP_ST void setup_shm(void) {\n\n  u8* shm_str;\n\n  if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE);\n\n  memset(virgin_tmout, 255, MAP_SIZE);\n  memset(virgin_crash, 255, MAP_SIZE);\n\n  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);\n\n  if (shm_id < 0) PFATAL(\"shmget() failed\");\n\n  atexit(remove_shm);\n\n  shm_str = alloc_printf(\"%d\", shm_id);\n\n  /* If somebody is asking us to fuzz instrumented binaries in dumb mode,\n     we don't want them to detect instrumentation, since we won't be sending\n     fork server commands. This should be replaced with better auto-detection\n     later on, perhaps? */\n\n  if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1);\n\n  ck_free(shm_str);\n\n  trace_bits = shmat(shm_id, NULL, 0);\n  \n  if (trace_bits == (void *)-1) PFATAL(\"shmat() failed\");\n\n}\n\n\n/* Load postprocessor, if available. */\n\nstatic void setup_post(void) {\n\n  void* dh;\n  u8* fn = getenv(\"AFL_POST_LIBRARY\");\n  u32 tlen = 6;\n\n  if (!fn) return;\n\n  ACTF(\"Loading postprocessor from '%s'...\", fn);\n\n  dh = dlopen(fn, RTLD_NOW);\n  if (!dh) FATAL(\"%s\", dlerror());\n\n  post_handler = dlsym(dh, \"afl_postprocess\");\n  if (!post_handler) FATAL(\"Symbol 'afl_postprocess' not found.\");\n\n  /* Do a quick test. It's better to segfault now than later =) */\n\n  post_handler(\"hello\", &tlen);\n\n  OKF(\"Postprocessor installed successfully.\");\n\n}\n\n\n/* Read all testcases from the input directory, then queue them for testing.\n   Called at startup. */\n\nstatic void read_testcases(void) {\n\n  struct dirent **nl;\n  s32 nl_cnt;\n  u32 i;\n  u8* fn;\n\n  /* Auto-detect non-in-place resumption attempts. */\n\n  fn = alloc_printf(\"%s/queue\", in_dir);\n  if (!access(fn, F_OK)) in_dir = fn; else ck_free(fn);\n\n  ACTF(\"Scanning '%s'...\", in_dir);\n\n  /* We use scandir() + alphasort() rather than readdir() because otherwise,\n     the ordering  of test cases would vary somewhat randomly and would be\n     difficult to control. */\n\n  nl_cnt = scandir(in_dir, &nl, NULL, alphasort);\n\n  if (nl_cnt < 0) {\n\n    if (errno == ENOENT || errno == ENOTDIR)\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"The input directory does not seem to be valid - try again. The fuzzer needs\\n\"\n           \"    one or more test case to start with - ideally, a small file under 1 kB\\n\"\n           \"    or so. The cases must be stored as regular files directly in the input\\n\"\n           \"    directory.\\n\");\n\n    PFATAL(\"Unable to open '%s'\", in_dir);\n\n  }\n\n  if (shuffle_queue && nl_cnt > 1) {\n\n    ACTF(\"Shuffling queue...\");\n    shuffle_ptrs((void**)nl, nl_cnt);\n\n  }\n\n  for (i = 0; i < nl_cnt; i++) {\n\n    struct stat st;\n\n    u8* fn = alloc_printf(\"%s/%s\", in_dir, nl[i]->d_name);\n    u8* dfn = alloc_printf(\"%s/.state/deterministic_done/%s\", in_dir, nl[i]->d_name);\n\n    u8  passed_det = 0;\n\n    free(nl[i]); /* not tracked */\n \n    if (lstat(fn, &st) || access(fn, R_OK))\n      PFATAL(\"Unable to access '%s'\", fn);\n\n    /* This also takes care of . and .. */\n\n    if (!S_ISREG(st.st_mode) || !st.st_size || strstr(fn, \"/README.testcases\")) {\n\n      ck_free(fn);\n      ck_free(dfn);\n      continue;\n\n    }\n\n    if (st.st_size > MAX_FILE) \n      FATAL(\"Test case '%s' is too big (%s, limit is %s)\", fn,\n            DMS(st.st_size), DMS(MAX_FILE));\n\n    /* Check for metadata that indicates that deterministic fuzzing\n       is complete for this entry. We don't want to repeat deterministic\n       fuzzing when resuming aborted scans, because it would be pointless\n       and probably very time-consuming. */\n\n    if (!access(dfn, F_OK)) passed_det = 1;\n    ck_free(dfn);\n\n    add_to_queue(fn, st.st_size, passed_det);\n\n  }\n\n  free(nl); /* not tracked */\n\n  if (!queued_paths) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Looks like there are no valid test cases in the input directory! The fuzzer\\n\"\n         \"    needs one or more test case to start with - ideally, a small file under\\n\"\n         \"    1 kB or so. The cases must be stored as regular files directly in the\\n\"\n         \"    input directory.\\n\");\n\n    FATAL(\"No usable test cases in '%s'\", in_dir);\n\n  }\n\n  last_path_time = 0;\n  queued_at_start = queued_paths;\n\n}\n\n\n/* Helper function for load_extras. */\n\nstatic int compare_extras_len(const void* p1, const void* p2) {\n  struct extra_data *e1 = (struct extra_data*)p1,\n                    *e2 = (struct extra_data*)p2;\n\n  return e1->len - e2->len;\n}\n\nstatic int compare_extras_use_d(const void* p1, const void* p2) {\n  struct extra_data *e1 = (struct extra_data*)p1,\n                    *e2 = (struct extra_data*)p2;\n\n  return e2->hit_cnt - e1->hit_cnt;\n}\n\n\n/* Read extras from a file, sort by size. */\n\nstatic void load_extras_file(u8* fname, u32* min_len, u32* max_len,\n                             u32 dict_level) {\n\n  FILE* f;\n  u8  buf[MAX_LINE];\n  u8  *lptr;\n  u32 cur_line = 0;\n\n  f = fopen(fname, \"r\");\n\n  if (!f) PFATAL(\"Unable to open '%s'\", fname);\n\n  while ((lptr = fgets(buf, MAX_LINE, f))) {\n\n    u8 *rptr, *wptr;\n    u32 klen = 0;\n\n    cur_line++;\n\n    /* Trim on left and right. */\n\n    while (isspace(*lptr)) lptr++;\n\n    rptr = lptr + strlen(lptr) - 1;\n    while (rptr >= lptr && isspace(*rptr)) rptr--;\n    rptr++;\n    *rptr = 0;\n\n    /* Skip empty lines and comments. */\n\n    if (!*lptr || *lptr == '#') continue;\n\n    /* All other lines must end with '\"', which we can consume. */\n\n    rptr--;\n\n    if (rptr < lptr || *rptr != '\"')\n      FATAL(\"Malformed name=\\\"value\\\" pair in line %u.\", cur_line);\n\n    *rptr = 0;\n\n    /* Skip alphanumerics and dashes (label). */\n\n    while (isalnum(*lptr) || *lptr == '_') lptr++;\n\n    /* If @number follows, parse that. */\n\n    if (*lptr == '@') {\n\n      lptr++;\n      if (atoi(lptr) > dict_level) continue;\n      while (isdigit(*lptr)) lptr++;\n\n    }\n\n    /* Skip whitespace and = signs. */\n\n    while (isspace(*lptr) || *lptr == '=') lptr++;\n\n    /* Consume opening '\"'. */\n\n    if (*lptr != '\"')\n      FATAL(\"Malformed name=\\\"keyword\\\" pair in line %u.\", cur_line);\n\n    lptr++;\n\n    if (!*lptr) FATAL(\"Empty keyword in line %u.\", cur_line);\n\n    /* Okay, let's allocate memory and copy data between \"...\", handling\n       \\xNN escaping, \\\\, and \\\". */\n\n    extras = ck_realloc_block(extras, (extras_cnt + 1) *\n               sizeof(struct extra_data));\n\n    wptr = extras[extras_cnt].data = ck_alloc(rptr - lptr);\n\n    while (*lptr) {\n\n      char* hexdigits = \"0123456789abcdef\";\n\n      switch (*lptr) {\n\n        case 1 ... 31:\n        case 128 ... 255:\n          FATAL(\"Non-printable characters in line %u.\", cur_line);\n\n        case '\\\\':\n\n          lptr++;\n\n          if (*lptr == '\\\\' || *lptr == '\"') {\n            *(wptr++) = *(lptr++);\n            klen++;\n            break;\n          }\n\n          if (*lptr != 'x' || !isxdigit(lptr[1]) || !isxdigit(lptr[2]))\n            FATAL(\"Invalid escaping (not \\\\xNN) in line %u.\", cur_line);\n\n          *(wptr++) =\n            ((strchr(hexdigits, tolower(lptr[1])) - hexdigits) << 4) |\n            (strchr(hexdigits, tolower(lptr[2])) - hexdigits);\n\n          lptr += 3;\n          klen++;\n\n          break;\n\n        default:\n\n          *(wptr++) = *(lptr++);\n          klen++;\n\n      }\n\n    }\n\n    extras[extras_cnt].len = klen;\n\n    if (extras[extras_cnt].len > MAX_DICT_FILE)\n      FATAL(\"Keyword too big in line %u (%s, limit is %s)\", cur_line,\n            DMS(klen), DMS(MAX_DICT_FILE));\n\n    if (*min_len > klen) *min_len = klen;\n    if (*max_len < klen) *max_len = klen;\n\n    extras_cnt++;\n\n  }\n\n  fclose(f);\n\n}\n\n\n/* Read extras from the extras directory and sort them by size. */\n\nstatic void load_extras(u8* dir) {\n\n  DIR* d;\n  struct dirent* de;\n  u32 min_len = MAX_DICT_FILE, max_len = 0, dict_level = 0;\n  u8* x;\n\n  /* If the name ends with @, extract level and continue. */\n\n  if ((x = strchr(dir, '@'))) {\n\n    *x = 0;\n    dict_level = atoi(x + 1);\n\n  }\n\n  ACTF(\"Loading extra dictionary from '%s' (level %u)...\", dir, dict_level);\n\n  d = opendir(dir);\n\n  if (!d) {\n\n    if (errno == ENOTDIR) {\n      load_extras_file(dir, &min_len, &max_len, dict_level);\n      goto check_and_sort;\n    }\n\n    PFATAL(\"Unable to open '%s'\", dir);\n\n  }\n\n  if (x) FATAL(\"Dictionary levels not supported for directories.\");\n\n  while ((de = readdir(d))) {\n\n    struct stat st;\n    u8* fn = alloc_printf(\"%s/%s\", dir, de->d_name);\n    s32 fd;\n\n    if (lstat(fn, &st) || access(fn, R_OK))\n      PFATAL(\"Unable to access '%s'\", fn);\n\n    /* This also takes care of . and .. */\n    if (!S_ISREG(st.st_mode) || !st.st_size) {\n\n      ck_free(fn);\n      continue;\n\n    }\n\n    if (st.st_size > MAX_DICT_FILE)\n      FATAL(\"Extra '%s' is too big (%s, limit is %s)\", fn,\n            DMS(st.st_size), DMS(MAX_DICT_FILE));\n\n    if (min_len > st.st_size) min_len = st.st_size;\n    if (max_len < st.st_size) max_len = st.st_size;\n\n    extras = ck_realloc_block(extras, (extras_cnt + 1) *\n               sizeof(struct extra_data));\n\n    extras[extras_cnt].data = ck_alloc(st.st_size);\n    extras[extras_cnt].len  = st.st_size;\n\n    fd = open(fn, O_RDONLY);\n\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", fn);\n\n    ck_read(fd, extras[extras_cnt].data, st.st_size, fn);\n\n    close(fd);\n    ck_free(fn);\n\n    extras_cnt++;\n\n  }\n\n  closedir(d);\n\ncheck_and_sort:\n\n  if (!extras_cnt) FATAL(\"No usable files in '%s'\", dir);\n\n  qsort(extras, extras_cnt, sizeof(struct extra_data), compare_extras_len);\n\n  OKF(\"Loaded %u extra tokens, size range %s to %s.\", extras_cnt,\n      DMS(min_len), DMS(max_len));\n\n  if (max_len > 32)\n    WARNF(\"Some tokens are relatively large (%s) - consider trimming.\",\n          DMS(max_len));\n\n  if (extras_cnt > MAX_DET_EXTRAS)\n    WARNF(\"More than %u tokens - will use them probabilistically.\",\n          MAX_DET_EXTRAS);\n\n}\n\n\n\n\n/* Helper function for maybe_add_auto() */\n\nstatic inline u8 memcmp_nocase(u8* m1, u8* m2, u32 len) {\n\n  while (len--) if (tolower(*(m1++)) ^ tolower(*(m2++))) return 1;\n  return 0;\n\n}\n\n\n/* Maybe add automatic extra. */\n\nstatic void maybe_add_auto(u8* mem, u32 len) {\n\n  u32 i;\n\n  /* Allow users to specify that they don't want auto dictionaries. */\n\n  if (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) return;\n\n  /* Skip runs of identical bytes. */\n\n  for (i = 1; i < len; i++)\n    if (mem[0] ^ mem[i]) break;\n\n  if (i == len) return;\n\n  /* Reject builtin interesting values. */\n\n  if (len == 2) {\n\n    i = sizeof(interesting_16) >> 1;\n\n    while (i--) \n      if (*((u16*)mem) == interesting_16[i] ||\n          *((u16*)mem) == SWAP16(interesting_16[i])) return;\n\n  }\n\n  if (len == 4) {\n\n    i = sizeof(interesting_32) >> 2;\n\n    while (i--) \n      if (*((u32*)mem) == interesting_32[i] ||\n          *((u32*)mem) == SWAP32(interesting_32[i])) return;\n\n  }\n\n  /* Reject anything that matches existing extras. Do a case-insensitive\n     match. We optimize by exploiting the fact that extras[] are sorted\n     by size. */\n\n  for (i = 0; i < extras_cnt; i++)\n    if (extras[i].len >= len) break;\n\n  for (; i < extras_cnt && extras[i].len == len; i++)\n    if (!memcmp_nocase(extras[i].data, mem, len)) return;\n\n  /* Last but not least, check a_extras[] for matches. There are no\n     guarantees of a particular sort order. */\n\n  auto_changed = 1;\n\n  for (i = 0; i < a_extras_cnt; i++) {\n\n    if (a_extras[i].len == len && !memcmp_nocase(a_extras[i].data, mem, len)) {\n\n      a_extras[i].hit_cnt++;\n      goto sort_a_extras;\n\n    }\n\n  }\n\n  /* At this point, looks like we're dealing with a new entry. So, let's\n     append it if we have room. Otherwise, let's randomly evict some other\n     entry from the bottom half of the list. */\n\n  if (a_extras_cnt < MAX_AUTO_EXTRAS) {\n\n    a_extras = ck_realloc_block(a_extras, (a_extras_cnt + 1) *\n                                sizeof(struct extra_data));\n\n    a_extras[a_extras_cnt].data = ck_memdup(mem, len);\n    a_extras[a_extras_cnt].len  = len;\n    a_extras_cnt++;\n\n  } else {\n\n    i = MAX_AUTO_EXTRAS / 2 +\n        UR((MAX_AUTO_EXTRAS + 1) / 2);\n\n    ck_free(a_extras[i].data);\n\n    a_extras[i].data    = ck_memdup(mem, len);\n    a_extras[i].len     = len;\n    a_extras[i].hit_cnt = 0;\n\n  }\n\nsort_a_extras:\n\n  /* First, sort all auto extras by use count, descending order. */\n\n  qsort(a_extras, a_extras_cnt, sizeof(struct extra_data),\n        compare_extras_use_d);\n\n  /* Then, sort the top USE_AUTO_EXTRAS entries by size. */\n\n  qsort(a_extras, MIN(USE_AUTO_EXTRAS, a_extras_cnt),\n        sizeof(struct extra_data), compare_extras_len);\n\n}\n\n\n/* Save automatically generated extras. */\n\nstatic void save_auto(void) {\n\n  u32 i;\n\n  if (!auto_changed) return;\n  auto_changed = 0;\n\n  for (i = 0; i < MIN(USE_AUTO_EXTRAS, a_extras_cnt); i++) {\n\n    u8* fn = alloc_printf(\"%s/queue/.state/auto_extras/auto_%06u\", out_dir, i);\n    s32 fd;\n\n    fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n\n    ck_write(fd, a_extras[i].data, a_extras[i].len, fn);\n\n    close(fd);\n    ck_free(fn);\n\n  }\n\n}\n\n\n/* Load automatically generated extras. */\n\nstatic void load_auto(void) {\n\n  u32 i;\n\n  for (i = 0; i < USE_AUTO_EXTRAS; i++) {\n\n    u8  tmp[MAX_AUTO_EXTRA + 1];\n    u8* fn = alloc_printf(\"%s/.state/auto_extras/auto_%06u\", in_dir, i);\n    s32 fd, len;\n\n    fd = open(fn, O_RDONLY, 0600);\n\n    if (fd < 0) {\n\n      if (errno != ENOENT) PFATAL(\"Unable to open '%s'\", fn);\n      ck_free(fn);\n      break;\n\n    }\n\n    /* We read one byte more to cheaply detect tokens that are too\n       long (and skip them). */\n\n    len = read(fd, tmp, MAX_AUTO_EXTRA + 1);\n\n    if (len < 0) PFATAL(\"Unable to read from '%s'\", fn);\n\n    if (len >= MIN_AUTO_EXTRA && len <= MAX_AUTO_EXTRA)\n      maybe_add_auto(tmp, len);\n\n    close(fd);\n    ck_free(fn);\n\n  }\n\n  if (i) OKF(\"Loaded %u auto-discovered dictionary tokens.\", i);\n  else OKF(\"No auto-generated dictionary tokens to reuse.\");\n\n}\n\n\n/* Destroy extras. */\n\nstatic void destroy_extras(void) {\n\n  u32 i;\n\n  for (i = 0; i < extras_cnt; i++) \n    ck_free(extras[i].data);\n\n  ck_free(extras);\n\n  for (i = 0; i < a_extras_cnt; i++) \n    ck_free(a_extras[i].data);\n\n  ck_free(a_extras);\n\n}\n\n\n/* Spin up fork server (instrumented mode only). The idea is explained here:\n\n   http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html\n\n   In essence, the instrumentation allows us to skip execve(), and just keep\n   cloning a stopped child. So, we just execute once, and then send commands\n   through a pipe. The other part of this logic is in afl-as.h. */\n\nEXP_ST void init_forkserver(char** argv) {\n\n  static struct itimerval it;\n  int st_pipe[2], ctl_pipe[2];\n  int status;\n  s32 rlen;\n\n  ACTF(\"Spinning up the fork server...\");\n\n  if (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL(\"pipe() failed\");\n\n  forksrv_pid = fork();\n\n  if (forksrv_pid < 0) PFATAL(\"fork() failed\");\n\n  if (!forksrv_pid) {\n\n    struct rlimit r;\n\n    /* Umpf. On OpenBSD, the default fd limit for root users is set to\n       soft 128. Let's try to fix that... */\n\n    if (!getrlimit(RLIMIT_NOFILE, &r) && r.rlim_cur < FORKSRV_FD + 2) {\n\n      r.rlim_cur = FORKSRV_FD + 2;\n      setrlimit(RLIMIT_NOFILE, &r); /* Ignore errors */\n\n    }\n\n    if (mem_limit) {\n\n      r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;\n\n#ifdef RLIMIT_AS\n\n      setrlimit(RLIMIT_AS, &r); /* Ignore errors */\n\n#else\n\n      /* This takes care of OpenBSD, which doesn't have RLIMIT_AS, but\n         according to reliable sources, RLIMIT_DATA covers anonymous\n         maps - so we should be getting good protection against OOM bugs. */\n\n      setrlimit(RLIMIT_DATA, &r); /* Ignore errors */\n\n#endif /* ^RLIMIT_AS */\n\n\n    }\n\n    /* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered\n       before the dump is complete. */\n\n    r.rlim_max = r.rlim_cur = 0;\n\n    setrlimit(RLIMIT_CORE, &r); /* Ignore errors */\n\n    /* Isolate the process and configure standard descriptors. If out_file is\n       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */\n\n    setsid();\n\n    dup2(dev_null_fd, 1);\n    dup2(dev_null_fd, 2);\n\n    if (out_file) {\n\n      dup2(dev_null_fd, 0);\n\n    } else {\n\n      dup2(out_fd, 0);\n      close(out_fd);\n\n    }\n\n    /* Set up control and status pipes, close the unneeded original fds. */\n\n    if (dup2(ctl_pipe[0], FORKSRV_FD) < 0) PFATAL(\"dup2() failed\");\n    if (dup2(st_pipe[1], FORKSRV_FD + 1) < 0) PFATAL(\"dup2() failed\");\n\n    close(ctl_pipe[0]);\n    close(ctl_pipe[1]);\n    close(st_pipe[0]);\n    close(st_pipe[1]);\n\n    close(out_dir_fd);\n    close(dev_null_fd);\n    close(dev_urandom_fd);\n    close(fileno(plot_file));\n\n    /* This should improve performance a bit, since it stops the linker from\n       doing extra work post-fork(). */\n\n    if (!getenv(\"LD_BIND_LAZY\")) setenv(\"LD_BIND_NOW\", \"1\", 0);\n\n    /* Set sane defaults for ASAN if nothing else specified. */\n\n    setenv(\"ASAN_OPTIONS\", \"abort_on_error=1:\"\n                           \"detect_leaks=0:\"\n                           \"symbolize=0:\"\n                           \"allocator_may_return_null=1\", 0);\n\n    /* MSAN is tricky, because it doesn't support abort_on_error=1 at this\n       point. So, we do this in a very hacky way. */\n\n    setenv(\"MSAN_OPTIONS\", \"exit_code=\" STRINGIFY(MSAN_ERROR) \":\"\n                           \"symbolize=0:\"\n                           \"abort_on_error=1:\"\n                           \"allocator_may_return_null=1:\"\n                           \"msan_track_origins=0\", 0);\n\n    execv(target_path, argv);\n\n    /* Use a distinctive bitmap signature to tell the parent about execv()\n       falling through. */\n\n    *(u32*)trace_bits = EXEC_FAIL_SIG;\n    exit(0);\n\n  }\n\n  /* Close the unneeded endpoints. */\n\n  close(ctl_pipe[0]);\n  close(st_pipe[1]);\n\n  fsrv_ctl_fd = ctl_pipe[1];\n  fsrv_st_fd  = st_pipe[0];\n\n  /* Wait for the fork server to come up, but don't wait too long. */\n\n  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / 1000);\n  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % 1000) * 1000;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  rlen = read(fsrv_st_fd, &status, 4);\n\n  it.it_value.tv_sec = 0;\n  it.it_value.tv_usec = 0;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  /* If we have a four-byte \"hello\" message from the server, we're all set.\n     Otherwise, try to figure out what went wrong. */\n\n  if (rlen == 4) {\n    OKF(\"All right - fork server is up.\");\n    return;\n  }\n\n  if (child_timed_out)\n    FATAL(\"Timeout while initializing fork server (adjusting -t may help)\");\n\n  if (waitpid(forksrv_pid, &status, 0) <= 0)\n    PFATAL(\"waitpid() failed\");\n\n  if (WIFSIGNALED(status)) {\n\n    if (mem_limit && mem_limit < 500 && uses_asan) {\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"Whoops, the target binary crashed suddenly, before receiving any input\\n\"\n           \"    from the fuzzer! Since it seems to be built with ASAN and you have a\\n\"\n           \"    restrictive memory limit configured, this is expected; please read\\n\"\n           \"    %s/notes_for_asan.txt for help.\\n\", doc_path);\n\n    } else if (!mem_limit) {\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"Whoops, the target binary crashed suddenly, before receiving any input\\n\"\n           \"    from the fuzzer! There are several probable explanations:\\n\\n\"\n\n           \"    - The binary is just buggy and explodes entirely on its own. If so, you\\n\"\n           \"      need to fix the underlying problem or find a better replacement.\\n\\n\"\n\n#ifdef __APPLE__\n\n           \"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\\n\"\n           \"      break afl-fuzz performance optimizations when running platform-specific\\n\"\n           \"      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\\n\\n\"\n\n#endif /* __APPLE__ */\n\n           \"    - Less likely, there is a horrible bug in the fuzzer. If other options\\n\"\n           \"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\");\n\n    } else {\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"Whoops, the target binary crashed suddenly, before receiving any input\\n\"\n           \"    from the fuzzer! There are several probable explanations:\\n\\n\"\n\n           \"    - The current memory limit (%s) is too restrictive, causing the\\n\"\n           \"      target to hit an OOM condition in the dynamic linker. Try bumping up\\n\"\n           \"      the limit with the -m setting in the command line. A simple way confirm\\n\"\n           \"      this diagnosis would be:\\n\\n\"\n\n#ifdef RLIMIT_AS\n           \"      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\\n\\n\"\n#else\n           \"      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\\n\\n\"\n#endif /* ^RLIMIT_AS */\n\n           \"      Tip: you can use http://jwilk.net/software/recidivm to quickly\\n\"\n           \"      estimate the required amount of virtual memory for the binary.\\n\\n\"\n\n           \"    - The binary is just buggy and explodes entirely on its own. If so, you\\n\"\n           \"      need to fix the underlying problem or find a better replacement.\\n\\n\"\n\n#ifdef __APPLE__\n\n           \"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\\n\"\n           \"      break afl-fuzz performance optimizations when running platform-specific\\n\"\n           \"      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\\n\\n\"\n\n#endif /* __APPLE__ */\n\n           \"    - Less likely, there is a horrible bug in the fuzzer. If other options\\n\"\n           \"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\",\n           DMS(mem_limit << 20), mem_limit - 1);\n\n    }\n\n    FATAL(\"Fork server crashed with signal %d\", WTERMSIG(status));\n\n  }\n\n  if (*(u32*)trace_bits == EXEC_FAIL_SIG)\n    FATAL(\"Unable to execute target application ('%s')\", argv[0]);\n\n  if (mem_limit && mem_limit < 500 && uses_asan) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"Hmm, looks like the target binary terminated before we could complete a\\n\"\n           \"    handshake with the injected code. Since it seems to be built with ASAN and\\n\"\n           \"    you have a restrictive memory limit configured, this is expected; please\\n\"\n           \"    read %s/notes_for_asan.txt for help.\\n\", doc_path);\n\n  } else if (!mem_limit) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Hmm, looks like the target binary terminated before we could complete a\\n\"\n         \"    handshake with the injected code. Perhaps there is a horrible bug in the\\n\"\n         \"    fuzzer. Poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\");\n\n  } else {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Hmm, looks like the target binary terminated before we could complete a\\n\"\n         \"    handshake with the injected code. There are %s probable explanations:\\n\\n\"\n\n         \"%s\"\n         \"    - The current memory limit (%s) is too restrictive, causing an OOM\\n\"\n         \"      fault in the dynamic linker. This can be fixed with the -m option. A\\n\"\n         \"      simple way to confirm the diagnosis may be:\\n\\n\"\n\n#ifdef RLIMIT_AS\n         \"      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\\n\\n\"\n#else\n         \"      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\\n\\n\"\n#endif /* ^RLIMIT_AS */\n\n         \"      Tip: you can use http://jwilk.net/software/recidivm to quickly\\n\"\n         \"      estimate the required amount of virtual memory for the binary.\\n\\n\"\n\n         \"    - Less likely, there is a horrible bug in the fuzzer. If other options\\n\"\n         \"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\",\n         getenv(DEFER_ENV_VAR) ? \"three\" : \"two\",\n         getenv(DEFER_ENV_VAR) ?\n         \"    - You are using deferred forkserver, but __AFL_INIT() is never\\n\"\n         \"      reached before the program terminates.\\n\\n\" : \"\",\n         DMS(mem_limit << 20), mem_limit - 1);\n\n  }\n\n  FATAL(\"Fork server handshake failed\");\n\n}\n\n\n/* Execute target application, monitoring for timeouts. Return status\n   information. The called program will update trace_bits[]. */\n\nstatic u8 run_target(char** argv, u32 timeout) {\n\n  static struct itimerval it;\n  static u32 prev_timed_out = 0;\n  static u64 exec_ms = 0;\n\n  int status = 0;\n  u32 tb4;\n\n  child_timed_out = 0;\n\n  /* After this memset, trace_bits[] are effectively volatile, so we\n     must prevent any earlier operations from venturing into that\n     territory. */\n\n  memset(trace_bits, 0, MAP_SIZE);\n  MEM_BARRIER();\n\n  /* If we're running in \"dumb\" mode, we can't rely on the fork server\n     logic compiled into the target program, so we will just keep calling\n     execve(). There is a bit of code duplication between here and \n     init_forkserver(), but c'est la vie. */\n\n  if (dumb_mode == 1 || no_forkserver) {\n\n    child_pid = fork();\n\n    if (child_pid < 0) PFATAL(\"fork() failed\");\n\n    if (!child_pid) {\n\n      struct rlimit r;\n\n      if (mem_limit) {\n\n        r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;\n\n#ifdef RLIMIT_AS\n\n        setrlimit(RLIMIT_AS, &r); /* Ignore errors */\n\n#else\n\n        setrlimit(RLIMIT_DATA, &r); /* Ignore errors */\n\n#endif /* ^RLIMIT_AS */\n\n      }\n\n      r.rlim_max = r.rlim_cur = 0;\n\n      setrlimit(RLIMIT_CORE, &r); /* Ignore errors */\n\n      /* Isolate the process and configure standard descriptors. If out_file is\n         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */\n\n      setsid();\n\n      dup2(dev_null_fd, 1);\n      dup2(dev_null_fd, 2);\n\n      if (out_file) {\n\n        dup2(dev_null_fd, 0);\n\n      } else {\n\n        dup2(out_fd, 0);\n        close(out_fd);\n\n      }\n\n      /* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */\n\n      close(dev_null_fd);\n      close(out_dir_fd);\n      close(dev_urandom_fd);\n      close(fileno(plot_file));\n\n      /* Set sane defaults for ASAN if nothing else specified. */\n\n      setenv(\"ASAN_OPTIONS\", \"abort_on_error=1:\"\n                             \"detect_leaks=0:\"\n                             \"symbolize=0:\"\n                             \"allocator_may_return_null=1\", 0);\n\n      setenv(\"MSAN_OPTIONS\", \"exit_code=\" STRINGIFY(MSAN_ERROR) \":\"\n                             \"symbolize=0:\"\n                             \"msan_track_origins=0\", 0);\n\n      execv(target_path, argv);\n\n      /* Use a distinctive bitmap value to tell the parent about execv()\n         falling through. */\n\n      *(u32*)trace_bits = EXEC_FAIL_SIG;\n      exit(0);\n\n    }\n\n  } else {\n\n    s32 res;\n\n    /* In non-dumb mode, we have the fork server up and running, so simply\n       tell it to have at it, and then read back PID. */\n\n    if ((res = write(fsrv_ctl_fd, &prev_timed_out, 4)) != 4) {\n\n      if (stop_soon) return 0;\n      RPFATAL(res, \"Unable to request new process from fork server (OOM?)\");\n\n    }\n\n    if ((res = read(fsrv_st_fd, &child_pid, 4)) != 4) {\n\n      if (stop_soon) return 0;\n      RPFATAL(res, \"Unable to request new process from fork server (OOM?)\");\n\n    }\n\n    if (child_pid <= 0) FATAL(\"Fork server is misbehaving (OOM?)\");\n\n  }\n\n  /* Configure timeout, as requested by user, then wait for child to terminate. */\n\n  it.it_value.tv_sec = (timeout / 1000);\n  it.it_value.tv_usec = (timeout % 1000) * 1000;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  /* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */\n\n  if (dumb_mode == 1 || no_forkserver) {\n\n    if (waitpid(child_pid, &status, 0) <= 0) PFATAL(\"waitpid() failed\");\n\n  } else {\n\n    s32 res;\n\n    if ((res = read(fsrv_st_fd, &status, 4)) != 4) {\n\n      if (stop_soon) return 0;\n      RPFATAL(res, \"Unable to communicate with fork server (OOM?)\");\n\n    }\n\n  }\n\n  if (!WIFSTOPPED(status)) child_pid = 0;\n\n  getitimer(ITIMER_REAL, &it);\n  exec_ms = (u64) timeout - (it.it_value.tv_sec * 1000 +\n                             it.it_value.tv_usec / 1000);\n\n  it.it_value.tv_sec = 0;\n  it.it_value.tv_usec = 0;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  total_execs++;\n\n  /* Any subsequent operations on trace_bits must not be moved by the\n     compiler below this point. Past this location, trace_bits[] behave\n     very normally and do not have to be treated as volatile. */\n\n  MEM_BARRIER();\n\n  tb4 = *(u32*)trace_bits;\n\n#ifdef WORD_SIZE_64\n  classify_counts((u64*)trace_bits);\n#else\n  classify_counts((u32*)trace_bits);\n#endif /* ^WORD_SIZE_64 */\n\n  prev_timed_out = child_timed_out;\n\n  /* Report outcome to caller. */\n\n  if (WIFSIGNALED(status) && !stop_soon) {\n\n    kill_signal = WTERMSIG(status);\n\n    if (child_timed_out && kill_signal == SIGKILL) return FAULT_TMOUT;\n\n    return FAULT_CRASH;\n\n  }\n\n  /* A somewhat nasty hack for MSAN, which doesn't support abort_on_error and\n     must use a special exit code. */\n\n  if (uses_asan && WEXITSTATUS(status) == MSAN_ERROR) {\n    kill_signal = 0;\n    return FAULT_CRASH;\n  }\n\n  if ((dumb_mode == 1 || no_forkserver) && tb4 == EXEC_FAIL_SIG)\n    return FAULT_ERROR;\n\n  /* It makes sense to account for the slowest units only if the testcase was run\n  under the user defined timeout. */\n  if (!(timeout > exec_tmout) && (slowest_exec_ms < exec_ms)) {\n    slowest_exec_ms = exec_ms;\n  }\n\n  return FAULT_NONE;\n\n}\n\n\n/* Write modified data to file for testing. If out_file is set, the old file\n   is unlinked and a new one is created. Otherwise, out_fd is rewound and\n   truncated. */\n\nstatic void write_to_testcase(void* mem, u32 len) {\n\n  s32 fd = out_fd;\n\n  if (out_file) {\n\n    unlink(out_file); /* Ignore errors. */\n\n    fd = open(out_file, O_WRONLY | O_CREAT | O_EXCL, 0600);\n\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", out_file);\n\n  } else lseek(fd, 0, SEEK_SET);\n\n  ck_write(fd, mem, len, out_file);\n\n  if (!out_file) {\n\n    if (ftruncate(fd, len)) PFATAL(\"ftruncate() failed\");\n    lseek(fd, 0, SEEK_SET);\n\n  } else close(fd);\n\n}\n\n\n/* The same, but with an adjustable gap. Used for trimming. */\n\nstatic void write_with_gap(void* mem, u32 len, u32 skip_at, u32 skip_len) {\n\n  s32 fd = out_fd;\n  u32 tail_len = len - skip_at - skip_len;\n\n  if (out_file) {\n\n    unlink(out_file); /* Ignore errors. */\n\n    fd = open(out_file, O_WRONLY | O_CREAT | O_EXCL, 0600);\n\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", out_file);\n\n  } else lseek(fd, 0, SEEK_SET);\n\n  if (skip_at) ck_write(fd, mem, skip_at, out_file);\n\n  if (tail_len) ck_write(fd, mem + skip_at + skip_len, tail_len, out_file);\n\n  if (!out_file) {\n\n    if (ftruncate(fd, len - skip_len)) PFATAL(\"ftruncate() failed\");\n    lseek(fd, 0, SEEK_SET);\n\n  } else close(fd);\n\n}\n\n\nstatic void show_stats(void);\n\n/* Calibrate a new test case. This is done when processing the input directory\n   to warn about flaky or otherwise problematic test cases early on; and when\n   new paths are discovered to detect variable behavior and so on. */\n\nstatic u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem,\n                         u32 handicap, u8 from_queue) {\n\n  static u8 first_trace[MAP_SIZE];\n\n  u8  fault = 0, new_bits = 0, var_detected = 0, hnb = 0,\n      first_run = (q->exec_cksum == 0);\n\n  u64 start_us, stop_us;\n\n  s32 old_sc = stage_cur, old_sm = stage_max;\n  u32 use_tmout = exec_tmout;\n  u8* old_sn = stage_name;\n\n  /* Be a bit more generous about timeouts when resuming sessions, or when\n     trying to calibrate already-added finds. This helps avoid trouble due\n     to intermittent latency. */\n\n  if (!from_queue || resuming_fuzz)\n    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,\n                    exec_tmout * CAL_TMOUT_PERC / 100);\n\n  q->cal_failed++;\n\n  stage_name = \"calibration\";\n  stage_max  = fast_cal ? 3 : CAL_CYCLES;\n\n  /* Make sure the forkserver is up before we do anything, and let's not\n     count its spin-up time toward binary calibration. */\n\n  if (dumb_mode != 1 && !no_forkserver && !forksrv_pid)\n    init_forkserver(argv);\n\n  if (q->exec_cksum) {\n\n    memcpy(first_trace, trace_bits, MAP_SIZE);\n    hnb = has_new_bits(virgin_bits);\n    if (hnb > new_bits) new_bits = hnb;\n\n  }\n\n  start_us = get_cur_time_us();\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    u32 cksum;\n\n    if (!first_run && !(stage_cur % stats_update_freq)) show_stats();\n\n    write_to_testcase(use_mem, q->len);\n\n    fault = run_target(argv, use_tmout);\n\n    /* stop_soon is set by the handler for Ctrl+C. When it's pressed,\n       we want to bail out quickly. */\n\n    if (stop_soon || fault != crash_mode) goto abort_calibration;\n\n    if (!dumb_mode && !stage_cur && !count_bytes(trace_bits)) {\n      fault = FAULT_NOINST;\n      goto abort_calibration;\n    }\n\n    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n    if (q->exec_cksum != cksum) {\n\n      hnb = has_new_bits(virgin_bits);\n      if (hnb > new_bits) new_bits = hnb;\n\n      if (q->exec_cksum) {\n\n        u32 i;\n\n        for (i = 0; i < MAP_SIZE; i++) {\n\n          if (!var_bytes[i] && first_trace[i] != trace_bits[i]) {\n\n            var_bytes[i] = 1;\n            stage_max    = CAL_CYCLES_LONG;\n\n          }\n\n        }\n\n        var_detected = 1;\n\n      } else {\n\n        q->exec_cksum = cksum;\n        memcpy(first_trace, trace_bits, MAP_SIZE);\n\n      }\n\n    }\n\n  }\n\n  stop_us = get_cur_time_us();\n\n  total_cal_us     += stop_us - start_us;\n  total_cal_cycles += stage_max;\n\n  /* OK, let's collect some stats about the performance of this test case.\n     This is used for fuzzing air time calculations in calculate_score(). */\n\n  q->exec_us     = (stop_us - start_us) / stage_max;\n  q->bitmap_size = count_bytes(trace_bits);\n  q->handicap    = handicap;\n  q->cal_failed  = 0;\n\n  total_bitmap_size += q->bitmap_size;\n  total_bitmap_entries++;\n\n  update_bitmap_score(q);\n\n  /* If this case didn't result in new output from the instrumentation, tell\n     parent. This is a non-critical problem, but something to warn the user\n     about. */\n\n  if (!dumb_mode && first_run && !fault && !new_bits) fault = FAULT_NOBITS;\n\nabort_calibration:\n\n  if (new_bits == 2 && !q->has_new_cov) {\n    q->has_new_cov = 1;\n    queued_with_cov++;\n  }\n\n  /* Mark variable paths. */\n\n  if (var_detected) {\n\n    var_byte_count = count_bytes(var_bytes);\n\n    if (!q->var_behavior) {\n      mark_as_variable(q);\n      queued_variable++;\n    }\n\n  }\n\n  stage_name = old_sn;\n  stage_cur  = old_sc;\n  stage_max  = old_sm;\n\n  if (!first_run) show_stats();\n\n  return fault;\n\n}\n\n\n/* Examine map coverage. Called once, for first test case. */\n\nstatic void check_map_coverage(void) {\n\n  u32 i;\n\n  if (count_bytes(trace_bits) < 100) return;\n\n  for (i = (1 << (MAP_SIZE_POW2 - 1)); i < MAP_SIZE; i++)\n    if (trace_bits[i]) return;\n\n  WARNF(\"Recompile binary with newer version of afl to improve coverage!\");\n\n}\n\n\n/* Perform dry run of all test cases to confirm that the app is working as\n   expected. This is done only for the initial inputs, and only once. */\n\nstatic void perform_dry_run(char** argv) {\n\n  struct queue_entry* q = queue;\n  u32 cal_failures = 0;\n  u8* skip_crashes = getenv(\"AFL_SKIP_CRASHES\");\n\n  while (q) {\n\n    u8* use_mem;\n    u8  res;\n    s32 fd;\n\n    u8* fn = strrchr(q->fname, '/') + 1;\n\n    ACTF(\"Attempting dry run with '%s'...\", fn);\n\n    fd = open(q->fname, O_RDONLY);\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", q->fname);\n\n    use_mem = ck_alloc_nozero(q->len);\n\n    if (read(fd, use_mem, q->len) != q->len)\n      FATAL(\"Short read from '%s'\", q->fname);\n\n    close(fd);\n\n    res = calibrate_case(argv, q, use_mem, 0, 1);\n    ck_free(use_mem);\n\n    if (stop_soon) return;\n\n    if (res == crash_mode || res == FAULT_NOBITS)\n      SAYF(cGRA \"    len = %u, map size = %u, exec speed = %llu us\\n\" cRST, \n           q->len, q->bitmap_size, q->exec_us);\n\n    switch (res) {\n\n      case FAULT_NONE:\n\n        if (q == queue) check_map_coverage();\n\n        if (crash_mode) FATAL(\"Test case '%s' does *NOT* crash\", fn);\n\n        break;\n\n      case FAULT_TMOUT:\n\n        if (timeout_given) {\n\n          /* The -t nn+ syntax in the command line sets timeout_given to '2' and\n             instructs afl-fuzz to tolerate but skip queue entries that time\n             out. */\n\n          if (timeout_given > 1) {\n            WARNF(\"Test case results in a timeout (skipping)\");\n            q->cal_failed = CAL_CHANCES;\n            cal_failures++;\n            break;\n          }\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"The program took more than %u ms to process one of the initial test cases.\\n\"\n               \"    Usually, the right thing to do is to relax the -t option - or to delete it\\n\"\n               \"    altogether and allow the fuzzer to auto-calibrate. That said, if you know\\n\"\n               \"    what you are doing and want to simply skip the unruly test cases, append\\n\"\n               \"    '+' at the end of the value passed to -t ('-t %u+').\\n\", exec_tmout,\n               exec_tmout);\n\n          FATAL(\"Test case '%s' results in a timeout\", fn);\n\n        } else {\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"The program took more than %u ms to process one of the initial test cases.\\n\"\n               \"    This is bad news; raising the limit with the -t option is possible, but\\n\"\n               \"    will probably make the fuzzing process extremely slow.\\n\\n\"\n\n               \"    If this test case is just a fluke, the other option is to just avoid it\\n\"\n               \"    altogether, and find one that is less of a CPU hog.\\n\", exec_tmout);\n\n          FATAL(\"Test case '%s' results in a timeout\", fn);\n\n        }\n\n      case FAULT_CRASH:  \n\n        if (crash_mode) break;\n\n        if (skip_crashes) {\n          WARNF(\"Test case results in a crash (skipping)\");\n          q->cal_failed = CAL_CHANCES;\n          cal_failures++;\n          break;\n        }\n\n        if (mem_limit) {\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"Oops, the program crashed with one of the test cases provided. There are\\n\"\n               \"    several possible explanations:\\n\\n\"\n\n               \"    - The test case causes known crashes under normal working conditions. If\\n\"\n               \"      so, please remove it. The fuzzer should be seeded with interesting\\n\"\n               \"      inputs - but not ones that cause an outright crash.\\n\\n\"\n\n               \"    - The current memory limit (%s) is too low for this program, causing\\n\"\n               \"      it to die due to OOM when parsing valid files. To fix this, try\\n\"\n               \"      bumping it up with the -m setting in the command line. If in doubt,\\n\"\n               \"      try something along the lines of:\\n\\n\"\n\n#ifdef RLIMIT_AS\n               \"      ( ulimit -Sv $[%llu << 10]; /path/to/binary [...] <testcase )\\n\\n\"\n#else\n               \"      ( ulimit -Sd $[%llu << 10]; /path/to/binary [...] <testcase )\\n\\n\"\n#endif /* ^RLIMIT_AS */\n\n               \"      Tip: you can use http://jwilk.net/software/recidivm to quickly\\n\"\n               \"      estimate the required amount of virtual memory for the binary. Also,\\n\"\n               \"      if you are using ASAN, see %s/notes_for_asan.txt.\\n\\n\"\n\n#ifdef __APPLE__\n  \n               \"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\\n\"\n               \"      break afl-fuzz performance optimizations when running platform-specific\\n\"\n               \"      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\\n\\n\"\n\n#endif /* __APPLE__ */\n\n               \"    - Least likely, there is a horrible bug in the fuzzer. If other options\\n\"\n               \"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\",\n               DMS(mem_limit << 20), mem_limit - 1, doc_path);\n\n        } else {\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"Oops, the program crashed with one of the test cases provided. There are\\n\"\n               \"    several possible explanations:\\n\\n\"\n\n               \"    - The test case causes known crashes under normal working conditions. If\\n\"\n               \"      so, please remove it. The fuzzer should be seeded with interesting\\n\"\n               \"      inputs - but not ones that cause an outright crash.\\n\\n\"\n\n#ifdef __APPLE__\n  \n               \"    - On MacOS X, the semantics of fork() syscalls are non-standard and may\\n\"\n               \"      break afl-fuzz performance optimizations when running platform-specific\\n\"\n               \"      binaries. To fix this, set AFL_NO_FORKSRV=1 in the environment.\\n\\n\"\n\n#endif /* __APPLE__ */\n\n               \"    - Least likely, there is a horrible bug in the fuzzer. If other options\\n\"\n               \"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\");\n\n        }\n\n        FATAL(\"Test case '%s' results in a crash\", fn);\n\n      case FAULT_ERROR:\n\n        FATAL(\"Unable to execute target application ('%s')\", argv[0]);\n\n      case FAULT_NOINST:\n\n        FATAL(\"No instrumentation detected\");\n\n      case FAULT_NOBITS: \n\n        useless_at_start++;\n\n        if (!in_bitmap && !shuffle_queue)\n          WARNF(\"No new instrumentation output, test case may be useless.\");\n\n        break;\n\n    }\n\n    if (q->var_behavior) WARNF(\"Instrumentation output varies across runs.\");\n\n    q = q->next;\n\n  }\n\n  if (cal_failures) {\n\n    if (cal_failures == queued_paths)\n      FATAL(\"All test cases time out%s, giving up!\",\n            skip_crashes ? \" or crash\" : \"\");\n\n    WARNF(\"Skipped %u test cases (%0.02f%%) due to timeouts%s.\", cal_failures,\n          ((double)cal_failures) * 100 / queued_paths,\n          skip_crashes ? \" or crashes\" : \"\");\n\n    if (cal_failures * 5 > queued_paths)\n      WARNF(cLRD \"High percentage of rejected test cases, check settings!\");\n\n  }\n\n  OKF(\"All test cases processed.\");\n\n}\n\n\n/* Helper function: link() if possible, copy otherwise. */\n\nstatic void link_or_copy(u8* old_path, u8* new_path) {\n\n  s32 i = link(old_path, new_path);\n  s32 sfd, dfd;\n  u8* tmp;\n\n  if (!i) return;\n\n  sfd = open(old_path, O_RDONLY);\n  if (sfd < 0) PFATAL(\"Unable to open '%s'\", old_path);\n\n  dfd = open(new_path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n  if (dfd < 0) PFATAL(\"Unable to create '%s'\", new_path);\n\n  tmp = ck_alloc(64 * 1024);\n\n  while ((i = read(sfd, tmp, 64 * 1024)) > 0) \n    ck_write(dfd, tmp, i, new_path);\n\n  if (i < 0) PFATAL(\"read() failed\");\n\n  ck_free(tmp);\n  close(sfd);\n  close(dfd);\n\n}\n\n\nstatic void nuke_resume_dir(void);\n\n/* Create hard links for input test cases in the output directory, choosing\n   good names and pivoting accordingly. */\n\nstatic void pivot_inputs(void) {\n\n  struct queue_entry* q = queue;\n  u32 id = 0;\n\n  ACTF(\"Creating hard links for all input files...\");\n\n  while (q) {\n\n    u8  *nfn, *rsl = strrchr(q->fname, '/');\n    u32 orig_id;\n\n    if (!rsl) rsl = q->fname; else rsl++;\n\n    /* If the original file name conforms to the syntax and the recorded\n       ID matches the one we'd assign, just use the original file name.\n       This is valuable for resuming fuzzing runs. */\n\n#ifndef SIMPLE_FILES\n#  define CASE_PREFIX \"id:\"\n#else\n#  define CASE_PREFIX \"id_\"\n#endif /* ^!SIMPLE_FILES */\n\n    if (!strncmp(rsl, CASE_PREFIX, 3) &&\n        sscanf(rsl + 3, \"%06u\", &orig_id) == 1 && orig_id == id) {\n\n      u8* src_str;\n      u32 src_id;\n\n      resuming_fuzz = 1;\n      nfn = alloc_printf(\"%s/queue/%s\", out_dir, rsl);\n\n      /* Since we're at it, let's also try to find parent and figure out the\n         appropriate depth for this entry. */\n\n      src_str = strchr(rsl + 3, ':');\n\n      if (src_str && sscanf(src_str + 1, \"%06u\", &src_id) == 1) {\n\n        struct queue_entry* s = queue;\n        while (src_id-- && s) s = s->next;\n        if (s) q->depth = s->depth + 1;\n\n        if (max_depth < q->depth) max_depth = q->depth;\n\n      }\n\n    } else {\n\n      /* No dice - invent a new name, capturing the original one as a\n         substring. */\n\n#ifndef SIMPLE_FILES\n\n      u8* use_name = strstr(rsl, \",orig:\");\n\n      if (use_name) use_name += 6; else use_name = rsl;\n      nfn = alloc_printf(\"%s/queue/id:%06u,orig:%s\", out_dir, id, use_name);\n\n#else\n\n      nfn = alloc_printf(\"%s/queue/id_%06u\", out_dir, id);\n\n#endif /* ^!SIMPLE_FILES */\n\n    }\n\n    /* Pivot to the new queue entry. */\n\n    link_or_copy(q->fname, nfn);\n    ck_free(q->fname);\n    q->fname = nfn;\n\n    /* Make sure that the passed_det value carries over, too. */\n\n    if (q->passed_det) mark_as_det_done(q);\n\n    q = q->next;\n    id++;\n\n  }\n\n  if (in_place_resume) nuke_resume_dir();\n\n}\n\n\n#ifndef SIMPLE_FILES\n\n/* Construct a file name for a new test case, capturing the operation\n   that led to its discovery. Uses a static buffer. */\n\nstatic u8* describe_op(u8 hnb) {\n\n  static u8 ret[256];\n\n  if (syncing_party) {\n\n    sprintf(ret, \"sync:%s,src:%06u\", syncing_party, syncing_case);\n\n  } else {\n\n    sprintf(ret, \"src:%06u\", current_entry);\n\n    if (splicing_with >= 0)\n      sprintf(ret + strlen(ret), \"+%06u\", splicing_with);\n\n    sprintf(ret + strlen(ret), \",op:%s\", stage_short);\n\n    if (stage_cur_byte >= 0) {\n\n      sprintf(ret + strlen(ret), \",pos:%u\", stage_cur_byte);\n\n      if (stage_val_type != STAGE_VAL_NONE)\n        sprintf(ret + strlen(ret), \",val:%s%+d\", \n                (stage_val_type == STAGE_VAL_BE) ? \"be:\" : \"\",\n                stage_cur_val);\n\n    } else sprintf(ret + strlen(ret), \",rep:%u\", stage_cur_val);\n\n  }\n\n  if (hnb == 2) strcat(ret, \",+cov\");\n\n  return ret;\n\n}\n\n#endif /* !SIMPLE_FILES */\n\n\n/* Write a message accompanying the crash directory :-) */\n\nstatic void write_crash_readme(void) {\n\n  u8* fn = alloc_printf(\"%s/crashes/README.txt\", out_dir);\n  s32 fd;\n  FILE* f;\n\n  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);\n  ck_free(fn);\n\n  /* Do not die on errors here - that would be impolite. */\n\n  if (fd < 0) return;\n\n  f = fdopen(fd, \"w\");\n\n  if (!f) {\n    close(fd);\n    return;\n  }\n\n  fprintf(f, \"Command line used to find this crash:\\n\\n\"\n\n             \"%s\\n\\n\"\n\n             \"If you can't reproduce a bug outside of afl-fuzz, be sure to set the same\\n\"\n             \"memory limit. The limit used for this fuzzing session was %s.\\n\\n\"\n\n             \"Need a tool to minimize test cases before investigating the crashes or sending\\n\"\n             \"them to a vendor? Check out the afl-tmin that comes with the fuzzer!\\n\\n\"\n\n             \"Found any cool bugs in open-source tools using afl-fuzz? If yes, please drop\\n\"\n             \"me a mail at <lcamtuf@coredump.cx> once the issues are fixed - I'd love to\\n\"\n             \"add your finds to the gallery at:\\n\\n\"\n\n             \"  http://lcamtuf.coredump.cx/afl/\\n\\n\"\n\n             \"Thanks :-)\\n\",\n\n             orig_cmdline, DMS(mem_limit << 20)); /* ignore errors */\n\n  fclose(f);\n\n}\n\n\n/* Check if the result of an execve() during routine fuzzing is interesting,\n   save or queue the input test case for further analysis if so. Returns 1 if\n   entry is saved, 0 otherwise. */\n\nstatic u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault) {\n\n  u8  *fn = \"\";\n  u8  hnb;\n  s32 fd;\n  u8  keeping = 0, res;\n\n  if (fault == crash_mode) {\n\n    /* Keep only if there are new bits in the map, add to queue for\n       future fuzzing, etc. */\n\n    if (!(hnb = has_new_bits(virgin_bits))) {\n      if (crash_mode) total_crashes++;\n      return 0;\n    }    \n\n#ifndef SIMPLE_FILES\n\n    fn = alloc_printf(\"%s/queue/id:%06u,%s\", out_dir, queued_paths,\n                      describe_op(hnb));\n\n#else\n\n    fn = alloc_printf(\"%s/queue/id_%06u\", out_dir, queued_paths);\n\n#endif /* ^!SIMPLE_FILES */\n\n    add_to_queue(fn, len, 0);\n\n    if (hnb == 2) {\n      queue_top->has_new_cov = 1;\n      queued_with_cov++;\n    }\n\n    queue_top->exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n    /* Try to calibrate inline; this also calls update_bitmap_score() when\n       successful. */\n\n    res = calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0);\n\n    if (res == FAULT_ERROR)\n      FATAL(\"Unable to execute target application\");\n\n    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n    ck_write(fd, mem, len, fn);\n    close(fd);\n\n    keeping = 1;\n\n  }\n\n  switch (fault) {\n\n    case FAULT_TMOUT:\n\n      /* Timeouts are not very interesting, but we're still obliged to keep\n         a handful of samples. We use the presence of new bits in the\n         hang-specific bitmap as a signal of uniqueness. In \"dumb\" mode, we\n         just keep everything. */\n\n      total_tmouts++;\n\n      if (unique_hangs >= KEEP_UNIQUE_HANG) return keeping;\n\n      if (!dumb_mode) {\n\n#ifdef WORD_SIZE_64\n        simplify_trace((u64*)trace_bits);\n#else\n        simplify_trace((u32*)trace_bits);\n#endif /* ^WORD_SIZE_64 */\n\n        if (!has_new_bits(virgin_tmout)) return keeping;\n\n      }\n\n      unique_tmouts++;\n\n      /* Before saving, we make sure that it's a genuine hang by re-running\n         the target with a more generous timeout (unless the default timeout\n         is already generous). */\n\n      if (exec_tmout < hang_tmout) {\n\n        u8 new_fault;\n        write_to_testcase(mem, len);\n        new_fault = run_target(argv, hang_tmout);\n\n        /* A corner case that one user reported bumping into: increasing the\n           timeout actually uncovers a crash. Make sure we don't discard it if\n           so. */\n\n        if (!stop_soon && new_fault == FAULT_CRASH) goto keep_as_crash;\n\n        if (stop_soon || new_fault != FAULT_TMOUT) return keeping;\n\n      }\n\n#ifndef SIMPLE_FILES\n\n      fn = alloc_printf(\"%s/hangs/id:%06llu,%s\", out_dir,\n                        unique_hangs, describe_op(0));\n\n#else\n\n      fn = alloc_printf(\"%s/hangs/id_%06llu\", out_dir,\n                        unique_hangs);\n\n#endif /* ^!SIMPLE_FILES */\n\n      unique_hangs++;\n\n      last_hang_time = get_cur_time();\n\n      break;\n\n    case FAULT_CRASH:\n\nkeep_as_crash:\n\n      /* This is handled in a manner roughly similar to timeouts,\n         except for slightly different limits and no need to re-run test\n         cases. */\n\n      total_crashes++;\n\n      if (unique_crashes >= KEEP_UNIQUE_CRASH) return keeping;\n\n      if (!dumb_mode) {\n\n#ifdef WORD_SIZE_64\n        simplify_trace((u64*)trace_bits);\n#else\n        simplify_trace((u32*)trace_bits);\n#endif /* ^WORD_SIZE_64 */\n\n        if (!has_new_bits(virgin_crash)) return keeping;\n\n      }\n\n      if (!unique_crashes) write_crash_readme();\n\n#ifndef SIMPLE_FILES\n\n      fn = alloc_printf(\"%s/crashes/id:%06llu,sig:%02u,%s\", out_dir,\n                        unique_crashes, kill_signal, describe_op(0));\n\n#else\n\n      fn = alloc_printf(\"%s/crashes/id_%06llu_%02u\", out_dir, unique_crashes,\n                        kill_signal);\n\n#endif /* ^!SIMPLE_FILES */\n\n      unique_crashes++;\n\n      last_crash_time = get_cur_time();\n      last_crash_execs = total_execs;\n\n      break;\n\n    case FAULT_ERROR: FATAL(\"Unable to execute target application\");\n\n    default: return keeping;\n\n  }\n\n  /* If we're here, we apparently want to save the crash or hang\n     test case, too. */\n\n  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, 0600);\n  if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n  ck_write(fd, mem, len, fn);\n  close(fd);\n\n  ck_free(fn);\n\n  return keeping;\n\n}\n\n\n/* When resuming, try to find the queue position to start from. This makes sense\n   only when resuming, and when we can find the original fuzzer_stats. */\n\nstatic u32 find_start_position(void) {\n\n  static u8 tmp[4096]; /* Ought to be enough for anybody. */\n\n  u8  *fn, *off;\n  s32 fd, i;\n  u32 ret;\n\n  if (!resuming_fuzz) return 0;\n\n  if (in_place_resume) fn = alloc_printf(\"%s/fuzzer_stats\", out_dir);\n  else fn = alloc_printf(\"%s/../fuzzer_stats\", in_dir);\n\n  fd = open(fn, O_RDONLY);\n  ck_free(fn);\n\n  if (fd < 0) return 0;\n\n  i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */\n  close(fd);\n\n  off = strstr(tmp, \"cur_path          : \");\n  if (!off) return 0;\n\n  ret = atoi(off + 20);\n  if (ret >= queued_paths) ret = 0;\n  return ret;\n\n}\n\n\n/* The same, but for timeouts. The idea is that when resuming sessions without\n   -t given, we don't want to keep auto-scaling the timeout over and over\n   again to prevent it from growing due to random flukes. */\n\nstatic void find_timeout(void) {\n\n  static u8 tmp[4096]; /* Ought to be enough for anybody. */\n\n  u8  *fn, *off;\n  s32 fd, i;\n  u32 ret;\n\n  if (!resuming_fuzz) return;\n\n  if (in_place_resume) fn = alloc_printf(\"%s/fuzzer_stats\", out_dir);\n  else fn = alloc_printf(\"%s/../fuzzer_stats\", in_dir);\n\n  fd = open(fn, O_RDONLY);\n  ck_free(fn);\n\n  if (fd < 0) return;\n\n  i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */\n  close(fd);\n\n  off = strstr(tmp, \"exec_timeout      : \");\n  if (!off) return;\n\n  ret = atoi(off + 20);\n  if (ret <= 4) return;\n\n  exec_tmout = ret;\n  timeout_given = 3;\n\n}\n\n\n/* Update stats file for unattended monitoring. */\n\nstatic void write_stats_file(double bitmap_cvg, double stability, double eps) {\n\n  static double last_bcvg, last_stab, last_eps;\n  static struct rusage usage;\n\n  u8* fn = alloc_printf(\"%s/fuzzer_stats\", out_dir);\n  s32 fd;\n  FILE* f;\n\n  fd = open(fn, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n\n  if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n\n  ck_free(fn);\n\n  f = fdopen(fd, \"w\");\n\n  if (!f) PFATAL(\"fdopen() failed\");\n\n  /* Keep last values in case we're called from another context\n     where exec/sec stats and such are not readily available. */\n\n  if (!bitmap_cvg && !stability && !eps) {\n    bitmap_cvg = last_bcvg;\n    stability  = last_stab;\n    eps        = last_eps;\n  } else {\n    last_bcvg = bitmap_cvg;\n    last_stab = stability;\n    last_eps  = eps;\n  }\n\n  fprintf(f, \"start_time        : %llu\\n\"\n             \"last_update       : %llu\\n\"\n             \"fuzzer_pid        : %u\\n\"\n             \"cycles_done       : %llu\\n\"\n             \"execs_done        : %llu\\n\"\n             \"execs_per_sec     : %0.02f\\n\"\n             \"paths_total       : %u\\n\"\n             \"paths_favored     : %u\\n\"\n             \"paths_found       : %u\\n\"\n             \"paths_imported    : %u\\n\"\n             \"max_depth         : %u\\n\"\n             \"cur_path          : %u\\n\" /* Must match find_start_position() */\n             \"pending_favs      : %u\\n\"\n             \"pending_total     : %u\\n\"\n             \"variable_paths    : %u\\n\"\n             \"stability         : %0.02f%%\\n\"\n             \"bitmap_cvg        : %0.02f%%\\n\"\n             \"unique_crashes    : %llu\\n\"\n             \"unique_hangs      : %llu\\n\"\n             \"last_path         : %llu\\n\"\n             \"last_crash        : %llu\\n\"\n             \"last_hang         : %llu\\n\"\n             \"execs_since_crash : %llu\\n\"\n             \"exec_timeout      : %u\\n\" /* Must match find_timeout() */\n             \"afl_banner        : %s\\n\"\n             \"afl_version       : \" VERSION \"\\n\"\n             \"target_mode       : %s%s%s%s%s%s%s\\n\"\n             \"command_line      : %s\\n\"\n             \"slowest_exec_ms   : %llu\\n\",\n             start_time / 1000, get_cur_time() / 1000, getpid(),\n             queue_cycle ? (queue_cycle - 1) : 0, total_execs, eps,\n             queued_paths, queued_favored, queued_discovered, queued_imported,\n             max_depth, current_entry, pending_favored, pending_not_fuzzed,\n             queued_variable, stability, bitmap_cvg, unique_crashes,\n             unique_hangs, last_path_time / 1000, last_crash_time / 1000,\n             last_hang_time / 1000, total_execs - last_crash_execs,\n             exec_tmout, use_banner,\n             qemu_mode ? \"qemu \" : \"\", dumb_mode ? \" dumb \" : \"\",\n             no_forkserver ? \"no_forksrv \" : \"\", crash_mode ? \"crash \" : \"\",\n             persistent_mode ? \"persistent \" : \"\", deferred_mode ? \"deferred \" : \"\",\n             (qemu_mode || dumb_mode || no_forkserver || crash_mode ||\n              persistent_mode || deferred_mode) ? \"\" : \"default\",\n             orig_cmdline, slowest_exec_ms);\n             /* ignore errors */\n\n  /* Get rss value from the children\n     We must have killed the forkserver process and called waitpid\n     before calling getrusage */\n  if (getrusage(RUSAGE_CHILDREN, &usage)) {\n      WARNF(\"getrusage failed\");\n  } else if (usage.ru_maxrss == 0) {\n    fprintf(f, \"peak_rss_mb       : not available while afl is running\\n\");\n  } else {\n#ifdef __APPLE__\n    fprintf(f, \"peak_rss_mb       : %zu\\n\", usage.ru_maxrss >> 20);\n#else\n    fprintf(f, \"peak_rss_mb       : %zu\\n\", usage.ru_maxrss >> 10);\n#endif /* ^__APPLE__ */\n  }\n\n  fclose(f);\n\n}\n\n\n/* Update the plot file if there is a reason to. */\n\nstatic void maybe_update_plot_file(double bitmap_cvg, double eps) {\n\n  static u32 prev_qp, prev_pf, prev_pnf, prev_ce, prev_md;\n  static u64 prev_qc, prev_uc, prev_uh;\n\n  if (prev_qp == queued_paths && prev_pf == pending_favored && \n      prev_pnf == pending_not_fuzzed && prev_ce == current_entry &&\n      prev_qc == queue_cycle && prev_uc == unique_crashes &&\n      prev_uh == unique_hangs && prev_md == max_depth) return;\n\n  prev_qp  = queued_paths;\n  prev_pf  = pending_favored;\n  prev_pnf = pending_not_fuzzed;\n  prev_ce  = current_entry;\n  prev_qc  = queue_cycle;\n  prev_uc  = unique_crashes;\n  prev_uh  = unique_hangs;\n  prev_md  = max_depth;\n\n  /* Fields in the file:\n\n     unix_time, cycles_done, cur_path, paths_total, paths_not_fuzzed,\n     favored_not_fuzzed, unique_crashes, unique_hangs, max_depth,\n     execs_per_sec */\n\n  fprintf(plot_file, \n          \"%llu, %llu, %u, %u, %u, %u, %0.02f%%, %llu, %llu, %u, %0.02f\\n\",\n          get_cur_time() / 1000, queue_cycle - 1, current_entry, queued_paths,\n          pending_not_fuzzed, pending_favored, bitmap_cvg, unique_crashes,\n          unique_hangs, max_depth, eps); /* ignore errors */\n\n  fflush(plot_file);\n\n}\n\n\n\n/* A helper function for maybe_delete_out_dir(), deleting all prefixed\n   files in a directory. */\n\nstatic u8 delete_files(u8* path, u8* prefix) {\n\n  DIR* d;\n  struct dirent* d_ent;\n\n  d = opendir(path);\n\n  if (!d) return 0;\n\n  while ((d_ent = readdir(d))) {\n\n    if (d_ent->d_name[0] != '.' && (!prefix ||\n        !strncmp(d_ent->d_name, prefix, strlen(prefix)))) {\n\n      u8* fname = alloc_printf(\"%s/%s\", path, d_ent->d_name);\n      if (unlink(fname)) PFATAL(\"Unable to delete '%s'\", fname);\n      ck_free(fname);\n\n    }\n\n  }\n\n  closedir(d);\n\n  return !!rmdir(path);\n\n}\n\n\n/* Get the number of runnable processes, with some simple smoothing. */\n\nstatic double get_runnable_processes(void) {\n\n  static double res;\n\n#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)\n\n  /* I don't see any portable sysctl or so that would quickly give us the\n     number of runnable processes; the 1-minute load average can be a\n     semi-decent approximation, though. */\n\n  if (getloadavg(&res, 1) != 1) return 0;\n\n#else\n\n  /* On Linux, /proc/stat is probably the best way; load averages are\n     computed in funny ways and sometimes don't reflect extremely short-lived\n     processes well. */\n\n  FILE* f = fopen(\"/proc/stat\", \"r\");\n  u8 tmp[1024];\n  u32 val = 0;\n\n  if (!f) return 0;\n\n  while (fgets(tmp, sizeof(tmp), f)) {\n\n    if (!strncmp(tmp, \"procs_running \", 14) ||\n        !strncmp(tmp, \"procs_blocked \", 14)) val += atoi(tmp + 14);\n\n  }\n \n  fclose(f);\n\n  if (!res) {\n\n    res = val;\n\n  } else {\n\n    res = res * (1.0 - 1.0 / AVG_SMOOTHING) +\n          ((double)val) * (1.0 / AVG_SMOOTHING);\n\n  }\n\n#endif /* ^(__APPLE__ || __FreeBSD__ || __OpenBSD__) */\n\n  return res;\n\n}\n\n\n/* Delete the temporary directory used for in-place session resume. */\n\nstatic void nuke_resume_dir(void) {\n\n  u8* fn;\n\n  fn = alloc_printf(\"%s/_resume/.state/deterministic_done\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/_resume/.state/auto_extras\", out_dir);\n  if (delete_files(fn, \"auto_\")) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/_resume/.state/redundant_edges\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/_resume/.state/variable_behavior\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/_resume/.state\", out_dir);\n  if (rmdir(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/_resume\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  return;\n\ndir_cleanup_failed:\n\n  FATAL(\"_resume directory cleanup failed\");\n\n}\n\n\n/* Delete fuzzer output directory if we recognize it as ours, if the fuzzer\n   is not currently running, and if the last run time isn't too great. */\n\nstatic void maybe_delete_out_dir(void) {\n\n  FILE* f;\n  u8 *fn = alloc_printf(\"%s/fuzzer_stats\", out_dir);\n\n  /* See if the output directory is locked. If yes, bail out. If not,\n     create a lock that will persist for the lifetime of the process\n     (this requires leaving the descriptor open).*/\n\n  out_dir_fd = open(out_dir, O_RDONLY);\n  if (out_dir_fd < 0) PFATAL(\"Unable to open '%s'\", out_dir);\n\n#ifndef __sun\n\n  if (flock(out_dir_fd, LOCK_EX | LOCK_NB) && errno == EWOULDBLOCK) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Looks like the job output directory is being actively used by another\\n\"\n         \"    instance of afl-fuzz. You will need to choose a different %s\\n\"\n         \"    or stop the other process first.\\n\",\n         sync_id ? \"fuzzer ID\" : \"output location\");\n\n    FATAL(\"Directory '%s' is in use\", out_dir);\n\n  }\n\n#endif /* !__sun */\n\n  f = fopen(fn, \"r\");\n\n  if (f) {\n\n    u64 start_time, last_update;\n\n    if (fscanf(f, \"start_time     : %llu\\n\"\n                  \"last_update    : %llu\\n\", &start_time, &last_update) != 2)\n      FATAL(\"Malformed data in '%s'\", fn);\n\n    fclose(f);\n\n    /* Let's see how much work is at stake. */\n\n    if (!in_place_resume && last_update - start_time > OUTPUT_GRACE * 60) {\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"The job output directory already exists and contains the results of more\\n\"\n           \"    than %u minutes worth of fuzzing. To avoid data loss, afl-fuzz will *NOT*\\n\"\n           \"    automatically delete this data for you.\\n\\n\"\n\n           \"    If you wish to start a new session, remove or rename the directory manually,\\n\"\n           \"    or specify a different output location for this job. To resume the old\\n\"\n           \"    session, put '-' as the input directory in the command line ('-i -') and\\n\"\n           \"    try again.\\n\", OUTPUT_GRACE);\n\n       FATAL(\"At-risk data found in '%s'\", out_dir);\n\n    }\n\n  }\n\n  ck_free(fn);\n\n  /* The idea for in-place resume is pretty simple: we temporarily move the old\n     queue/ to a new location that gets deleted once import to the new queue/\n     is finished. If _resume/ already exists, the current queue/ may be\n     incomplete due to an earlier abort, so we want to use the old _resume/\n     dir instead, and we let rename() fail silently. */\n\n  if (in_place_resume) {\n\n    u8* orig_q = alloc_printf(\"%s/queue\", out_dir);\n\n    in_dir = alloc_printf(\"%s/_resume\", out_dir);\n\n    rename(orig_q, in_dir); /* Ignore errors */\n\n    OKF(\"Output directory exists, will attempt session resume.\");\n\n    ck_free(orig_q);\n\n  } else {\n\n    OKF(\"Output directory exists but deemed OK to reuse.\");\n\n  }\n\n  ACTF(\"Deleting old session data...\");\n\n  /* Okay, let's get the ball rolling! First, we need to get rid of the entries\n     in <out_dir>/.synced/.../id:*, if any are present. */\n\n  if (!in_place_resume) {\n\n    fn = alloc_printf(\"%s/.synced\", out_dir);\n    if (delete_files(fn, NULL)) goto dir_cleanup_failed;\n    ck_free(fn);\n\n  }\n\n  /* Next, we need to clean up <out_dir>/queue/.state/ subdirectories: */\n\n  fn = alloc_printf(\"%s/queue/.state/deterministic_done\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/queue/.state/auto_extras\", out_dir);\n  if (delete_files(fn, \"auto_\")) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/queue/.state/redundant_edges\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/queue/.state/variable_behavior\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  /* Then, get rid of the .state subdirectory itself (should be empty by now)\n     and everything matching <out_dir>/queue/id:*. */\n\n  fn = alloc_printf(\"%s/queue/.state\", out_dir);\n  if (rmdir(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/queue\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  /* All right, let's do <out_dir>/crashes/id:* and <out_dir>/hangs/id:*. */\n\n  if (!in_place_resume) {\n\n    fn = alloc_printf(\"%s/crashes/README.txt\", out_dir);\n    unlink(fn); /* Ignore errors */\n    ck_free(fn);\n\n  }\n\n  fn = alloc_printf(\"%s/crashes\", out_dir);\n\n  /* Make backup of the crashes directory if it's not empty and if we're\n     doing in-place resume. */\n\n  if (in_place_resume && rmdir(fn)) {\n\n    time_t cur_t = time(0);\n    struct tm* t = localtime(&cur_t);\n\n#ifndef SIMPLE_FILES\n\n    u8* nfn = alloc_printf(\"%s.%04u-%02u-%02u-%02u:%02u:%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#else\n\n    u8* nfn = alloc_printf(\"%s_%04u%02u%02u%02u%02u%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#endif /* ^!SIMPLE_FILES */\n\n    rename(fn, nfn); /* Ignore errors. */\n    ck_free(nfn);\n\n  }\n\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/hangs\", out_dir);\n\n  /* Backup hangs, too. */\n\n  if (in_place_resume && rmdir(fn)) {\n\n    time_t cur_t = time(0);\n    struct tm* t = localtime(&cur_t);\n\n#ifndef SIMPLE_FILES\n\n    u8* nfn = alloc_printf(\"%s.%04u-%02u-%02u-%02u:%02u:%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#else\n\n    u8* nfn = alloc_printf(\"%s_%04u%02u%02u%02u%02u%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#endif /* ^!SIMPLE_FILES */\n\n    rename(fn, nfn); /* Ignore errors. */\n    ck_free(nfn);\n\n  }\n\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  /* And now, for some finishing touches. */\n\n  fn = alloc_printf(\"%s/.cur_input\", out_dir);\n  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s/fuzz_bitmap\", out_dir);\n  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  if (!in_place_resume) {\n    fn  = alloc_printf(\"%s/fuzzer_stats\", out_dir);\n    if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n    ck_free(fn);\n  }\n\n  fn = alloc_printf(\"%s/plot_data\", out_dir);\n  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  OKF(\"Output dir cleanup successful.\");\n\n  /* Wow... is that all? If yes, celebrate! */\n\n  return;\n\ndir_cleanup_failed:\n\n  SAYF(\"\\n\" cLRD \"[-] \" cRST\n       \"Whoops, the fuzzer tried to reuse your output directory, but bumped into\\n\"\n       \"    some files that shouldn't be there or that couldn't be removed - so it\\n\"\n       \"    decided to abort! This happened while processing this path:\\n\\n\"\n\n       \"    %s\\n\\n\"\n       \"    Please examine and manually delete the files, or specify a different\\n\"\n       \"    output location for the tool.\\n\", fn);\n\n  FATAL(\"Output directory cleanup failed\");\n\n}\n\n\nstatic void check_term_size(void);\n\n\n/* A spiffy retro stats screen! This is called every stats_update_freq\n   execve() calls, plus in several other circumstances. */\n\nstatic void show_stats(void) {\n\n  static u64 last_stats_ms, last_plot_ms, last_ms, last_execs;\n  static double avg_exec;\n  double t_byte_ratio, stab_ratio;\n\n  u64 cur_ms;\n  u32 t_bytes, t_bits;\n\n  u32 banner_len, banner_pad;\n  u8  tmp[256];\n\n  cur_ms = get_cur_time();\n\n  /* If not enough time has passed since last UI update, bail out. */\n\n  if (cur_ms - last_ms < 1000 / UI_TARGET_HZ) return;\n\n  /* Check if we're past the 10 minute mark. */\n\n  if (cur_ms - start_time > 10 * 60 * 1000) run_over10m = 1;\n\n  /* Calculate smoothed exec speed stats. */\n\n  if (!last_execs) {\n  \n    avg_exec = ((double)total_execs) * 1000 / (cur_ms - start_time);\n\n  } else {\n\n    double cur_avg = ((double)(total_execs - last_execs)) * 1000 /\n                     (cur_ms - last_ms);\n\n    /* If there is a dramatic (5x+) jump in speed, reset the indicator\n       more quickly. */\n\n    if (cur_avg * 5 < avg_exec || cur_avg / 5 > avg_exec)\n      avg_exec = cur_avg;\n\n    avg_exec = avg_exec * (1.0 - 1.0 / AVG_SMOOTHING) +\n               cur_avg * (1.0 / AVG_SMOOTHING);\n\n  }\n\n  last_ms = cur_ms;\n  last_execs = total_execs;\n\n  /* Tell the callers when to contact us (as measured in execs). */\n\n  stats_update_freq = avg_exec / (UI_TARGET_HZ * 10);\n  if (!stats_update_freq) stats_update_freq = 1;\n\n  /* Do some bitmap stats. */\n\n  t_bytes = count_non_255_bytes(virgin_bits);\n  t_byte_ratio = ((double)t_bytes * 100) / MAP_SIZE;\n\n  if (t_bytes) \n    stab_ratio = 100 - ((double)var_byte_count) * 100 / t_bytes;\n  else\n    stab_ratio = 100;\n\n  /* Roughly every minute, update fuzzer stats and save auto tokens. */\n\n  if (cur_ms - last_stats_ms > STATS_UPDATE_SEC * 1000) {\n\n    last_stats_ms = cur_ms;\n    write_stats_file(t_byte_ratio, stab_ratio, avg_exec);\n    save_auto();\n    write_bitmap();\n\n  }\n\n  /* Every now and then, write plot data. */\n\n  if (cur_ms - last_plot_ms > PLOT_UPDATE_SEC * 1000) {\n\n    last_plot_ms = cur_ms;\n    maybe_update_plot_file(t_byte_ratio, avg_exec);\n \n  }\n\n  /* Honor AFL_EXIT_WHEN_DONE and AFL_BENCH_UNTIL_CRASH. */\n\n  if (!dumb_mode && cycles_wo_finds > 100 && !pending_not_fuzzed &&\n      getenv(\"AFL_EXIT_WHEN_DONE\")) stop_soon = 2;\n\n  if (total_crashes && getenv(\"AFL_BENCH_UNTIL_CRASH\")) stop_soon = 2;\n\n  /* If we're not on TTY, bail out. */\n\n  if (not_on_tty) return;\n\n  /* Compute some mildly useful bitmap stats. */\n\n  t_bits = (MAP_SIZE << 3) - count_bits(virgin_bits);\n\n  /* Now, for the visuals... */\n\n  if (clear_screen) {\n\n    SAYF(TERM_CLEAR CURSOR_HIDE);\n    clear_screen = 0;\n\n    check_term_size();\n\n  }\n\n  SAYF(TERM_HOME);\n\n  if (term_too_small) {\n\n    SAYF(cBRI \"Your terminal is too small to display the UI.\\n\"\n         \"Please resize terminal window to at least 80x25.\\n\" cRST);\n\n    return;\n\n  }\n\n  /* Let's start by drawing a centered banner. */\n\n  banner_len = (crash_mode ? 24 : 22) + strlen(VERSION) + strlen(use_banner);\n  banner_pad = (80 - banner_len) / 2;\n  memset(tmp, ' ', banner_pad);\n\n  sprintf(tmp + banner_pad, \"%s \" cLCY VERSION cLGN\n          \" (%s)\",  crash_mode ? cPIN \"peruvian were-rabbit\" : \n          cYEL \"american fuzzy lop\", use_banner);\n\n  SAYF(\"\\n%s\\n\\n\", tmp);\n\n  /* \"Handy\" shortcuts for drawing boxes... */\n\n#define bSTG    bSTART cGRA\n#define bH2     bH bH\n#define bH5     bH2 bH2 bH\n#define bH10    bH5 bH5\n#define bH20    bH10 bH10\n#define bH30    bH20 bH10\n#define SP5     \"     \"\n#define SP10    SP5 SP5\n#define SP20    SP10 SP10\n\n  /* Lord, forgive me this. */\n\n  SAYF(SET_G1 bSTG bLT bH bSTOP cCYA \" process timing \" bSTG bH30 bH5 bH2 bHB\n       bH bSTOP cCYA \" overall results \" bSTG bH5 bRT \"\\n\");\n\n  if (dumb_mode) {\n\n    strcpy(tmp, cRST);\n\n  } else {\n\n    u64 min_wo_finds = (cur_ms - last_path_time) / 1000 / 60;\n\n    /* First queue cycle: don't stop now! */\n    if (queue_cycle == 1 || min_wo_finds < 15) strcpy(tmp, cMGN); else\n\n    /* Subsequent cycles, but we're still making finds. */\n    if (cycles_wo_finds < 25 || min_wo_finds < 30) strcpy(tmp, cYEL); else\n\n    /* No finds for a long time and no test cases to try. */\n    if (cycles_wo_finds > 100 && !pending_not_fuzzed && min_wo_finds > 120)\n      strcpy(tmp, cLGN);\n\n    /* Default: cautiously OK to stop? */\n    else strcpy(tmp, cLBL);\n\n  }\n\n  SAYF(bV bSTOP \"        run time : \" cRST \"%-34s \" bSTG bV bSTOP\n       \"  cycles done : %s%-5s  \" bSTG bV \"\\n\",\n       DTD(cur_ms, start_time), tmp, DI(queue_cycle - 1));\n\n  /* We want to warn people about not seeing new paths after a full cycle,\n     except when resuming fuzzing or running in non-instrumented mode. */\n\n  if (!dumb_mode && (last_path_time || resuming_fuzz || queue_cycle == 1 ||\n      in_bitmap || crash_mode)) {\n\n    SAYF(bV bSTOP \"   last new path : \" cRST \"%-34s \",\n         DTD(cur_ms, last_path_time));\n\n  } else {\n\n    if (dumb_mode)\n\n      SAYF(bV bSTOP \"   last new path : \" cPIN \"n/a\" cRST \n           \" (non-instrumented mode)        \");\n\n     else\n\n      SAYF(bV bSTOP \"   last new path : \" cRST \"none yet \" cLRD\n           \"(odd, check syntax!)      \");\n\n  }\n\n  SAYF(bSTG bV bSTOP \"  total paths : \" cRST \"%-5s  \" bSTG bV \"\\n\",\n       DI(queued_paths));\n\n  /* Highlight crashes in red if found, denote going over the KEEP_UNIQUE_CRASH\n     limit with a '+' appended to the count. */\n\n  sprintf(tmp, \"%s%s\", DI(unique_crashes),\n          (unique_crashes >= KEEP_UNIQUE_CRASH) ? \"+\" : \"\");\n\n  SAYF(bV bSTOP \" last uniq crash : \" cRST \"%-34s \" bSTG bV bSTOP\n       \" uniq crashes : %s%-6s \" bSTG bV \"\\n\",\n       DTD(cur_ms, last_crash_time), unique_crashes ? cLRD : cRST,\n       tmp);\n\n  sprintf(tmp, \"%s%s\", DI(unique_hangs),\n         (unique_hangs >= KEEP_UNIQUE_HANG) ? \"+\" : \"\");\n\n  SAYF(bV bSTOP \"  last uniq hang : \" cRST \"%-34s \" bSTG bV bSTOP \n       \"   uniq hangs : \" cRST \"%-6s \" bSTG bV \"\\n\",\n       DTD(cur_ms, last_hang_time), tmp);\n\n  SAYF(bVR bH bSTOP cCYA \" cycle progress \" bSTG bH20 bHB bH bSTOP cCYA\n       \" map coverage \" bSTG bH bHT bH20 bH2 bH bVL \"\\n\");\n\n  /* This gets funny because we want to print several variable-length variables\n     together, but then cram them into a fixed-width field - so we need to\n     put them in a temporary buffer first. */\n\n  sprintf(tmp, \"%s%s (%0.02f%%)\", DI(current_entry),\n          queue_cur->favored ? \"\" : \"*\",\n          ((double)current_entry * 100) / queued_paths);\n\n  SAYF(bV bSTOP \"  now processing : \" cRST \"%-17s \" bSTG bV bSTOP, tmp);\n\n  sprintf(tmp, \"%0.02f%% / %0.02f%%\", ((double)queue_cur->bitmap_size) * \n          100 / MAP_SIZE, t_byte_ratio);\n\n  SAYF(\"    map density : %s%-21s \" bSTG bV \"\\n\", t_byte_ratio > 70 ? cLRD : \n       ((t_bytes < 200 && !dumb_mode) ? cPIN : cRST), tmp);\n\n  sprintf(tmp, \"%s (%0.02f%%)\", DI(cur_skipped_paths),\n          ((double)cur_skipped_paths * 100) / queued_paths);\n\n  SAYF(bV bSTOP \" paths timed out : \" cRST \"%-17s \" bSTG bV, tmp);\n\n  sprintf(tmp, \"%0.02f bits/tuple\",\n          t_bytes ? (((double)t_bits) / t_bytes) : 0);\n\n  SAYF(bSTOP \" count coverage : \" cRST \"%-21s \" bSTG bV \"\\n\", tmp);\n\n  SAYF(bVR bH bSTOP cCYA \" stage progress \" bSTG bH20 bX bH bSTOP cCYA\n       \" findings in depth \" bSTG bH20 bVL \"\\n\");\n\n  sprintf(tmp, \"%s (%0.02f%%)\", DI(queued_favored),\n          ((double)queued_favored) * 100 / queued_paths);\n\n  /* Yeah... it's still going on... halp? */\n\n  SAYF(bV bSTOP \"  now trying : \" cRST \"%-21s \" bSTG bV bSTOP \n       \" favored paths : \" cRST \"%-22s \" bSTG bV \"\\n\", stage_name, tmp);\n\n  if (!stage_max) {\n\n    sprintf(tmp, \"%s/-\", DI(stage_cur));\n\n  } else {\n\n    sprintf(tmp, \"%s/%s (%0.02f%%)\", DI(stage_cur), DI(stage_max),\n            ((double)stage_cur) * 100 / stage_max);\n\n  }\n\n  SAYF(bV bSTOP \" stage execs : \" cRST \"%-21s \" bSTG bV bSTOP, tmp);\n\n  sprintf(tmp, \"%s (%0.02f%%)\", DI(queued_with_cov),\n          ((double)queued_with_cov) * 100 / queued_paths);\n\n  SAYF(\"  new edges on : \" cRST \"%-22s \" bSTG bV \"\\n\", tmp);\n\n  sprintf(tmp, \"%s (%s%s unique)\", DI(total_crashes), DI(unique_crashes),\n          (unique_crashes >= KEEP_UNIQUE_CRASH) ? \"+\" : \"\");\n\n  if (crash_mode) {\n\n    SAYF(bV bSTOP \" total execs : \" cRST \"%-21s \" bSTG bV bSTOP\n         \"   new crashes : %s%-22s \" bSTG bV \"\\n\", DI(total_execs),\n         unique_crashes ? cLRD : cRST, tmp);\n\n  } else {\n\n    SAYF(bV bSTOP \" total execs : \" cRST \"%-21s \" bSTG bV bSTOP\n         \" total crashes : %s%-22s \" bSTG bV \"\\n\", DI(total_execs),\n         unique_crashes ? cLRD : cRST, tmp);\n\n  }\n\n  /* Show a warning about slow execution. */\n\n  if (avg_exec < 100) {\n\n    sprintf(tmp, \"%s/sec (%s)\", DF(avg_exec), avg_exec < 20 ?\n            \"zzzz...\" : \"slow!\");\n\n    SAYF(bV bSTOP \"  exec speed : \" cLRD \"%-21s \", tmp);\n\n  } else {\n\n    sprintf(tmp, \"%s/sec\", DF(avg_exec));\n    SAYF(bV bSTOP \"  exec speed : \" cRST \"%-21s \", tmp);\n\n  }\n\n  sprintf(tmp, \"%s (%s%s unique)\", DI(total_tmouts), DI(unique_tmouts),\n          (unique_hangs >= KEEP_UNIQUE_HANG) ? \"+\" : \"\");\n\n  SAYF (bSTG bV bSTOP \"  total tmouts : \" cRST \"%-22s \" bSTG bV \"\\n\", tmp);\n\n  /* Aaaalmost there... hold on! */\n\n  SAYF(bVR bH cCYA bSTOP \" fuzzing strategy yields \" bSTG bH10 bH bHT bH10\n       bH5 bHB bH bSTOP cCYA \" path geometry \" bSTG bH5 bH2 bH bVL \"\\n\");\n\n  if (skip_deterministic) {\n\n    strcpy(tmp, \"n/a, n/a, n/a\");\n\n  } else {\n\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_FLIP1]), DI(stage_cycles[STAGE_FLIP1]),\n            DI(stage_finds[STAGE_FLIP2]), DI(stage_cycles[STAGE_FLIP2]),\n            DI(stage_finds[STAGE_FLIP4]), DI(stage_cycles[STAGE_FLIP4]));\n\n  }\n\n  SAYF(bV bSTOP \"   bit flips : \" cRST \"%-37s \" bSTG bV bSTOP \"    levels : \"\n       cRST \"%-10s \" bSTG bV \"\\n\", tmp, DI(max_depth));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_FLIP8]), DI(stage_cycles[STAGE_FLIP8]),\n            DI(stage_finds[STAGE_FLIP16]), DI(stage_cycles[STAGE_FLIP16]),\n            DI(stage_finds[STAGE_FLIP32]), DI(stage_cycles[STAGE_FLIP32]));\n\n  SAYF(bV bSTOP \"  byte flips : \" cRST \"%-37s \" bSTG bV bSTOP \"   pending : \"\n       cRST \"%-10s \" bSTG bV \"\\n\", tmp, DI(pending_not_fuzzed));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_ARITH8]), DI(stage_cycles[STAGE_ARITH8]),\n            DI(stage_finds[STAGE_ARITH16]), DI(stage_cycles[STAGE_ARITH16]),\n            DI(stage_finds[STAGE_ARITH32]), DI(stage_cycles[STAGE_ARITH32]));\n\n  SAYF(bV bSTOP \" arithmetics : \" cRST \"%-37s \" bSTG bV bSTOP \"  pend fav : \"\n       cRST \"%-10s \" bSTG bV \"\\n\", tmp, DI(pending_favored));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_INTEREST8]), DI(stage_cycles[STAGE_INTEREST8]),\n            DI(stage_finds[STAGE_INTEREST16]), DI(stage_cycles[STAGE_INTEREST16]),\n            DI(stage_finds[STAGE_INTEREST32]), DI(stage_cycles[STAGE_INTEREST32]));\n\n  SAYF(bV bSTOP \"  known ints : \" cRST \"%-37s \" bSTG bV bSTOP \" own finds : \"\n       cRST \"%-10s \" bSTG bV \"\\n\", tmp, DI(queued_discovered));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_EXTRAS_UO]), DI(stage_cycles[STAGE_EXTRAS_UO]),\n            DI(stage_finds[STAGE_EXTRAS_UI]), DI(stage_cycles[STAGE_EXTRAS_UI]),\n            DI(stage_finds[STAGE_EXTRAS_AO]), DI(stage_cycles[STAGE_EXTRAS_AO]));\n\n  SAYF(bV bSTOP \"  dictionary : \" cRST \"%-37s \" bSTG bV bSTOP\n       \"  imported : \" cRST \"%-10s \" bSTG bV \"\\n\", tmp,\n       sync_id ? DI(queued_imported) : (u8*)\"n/a\");\n\n  sprintf(tmp, \"%s/%s, %s/%s\",\n          DI(stage_finds[STAGE_HAVOC]), DI(stage_cycles[STAGE_HAVOC]),\n          DI(stage_finds[STAGE_SPLICE]), DI(stage_cycles[STAGE_SPLICE]));\n\n  SAYF(bV bSTOP \"       havoc : \" cRST \"%-37s \" bSTG bV bSTOP, tmp);\n\n  if (t_bytes) sprintf(tmp, \"%0.02f%%\", stab_ratio);\n    else strcpy(tmp, \"n/a\");\n\n  SAYF(\" stability : %s%-10s \" bSTG bV \"\\n\", (stab_ratio < 85 && var_byte_count > 40) \n       ? cLRD : ((queued_variable && (!persistent_mode || var_byte_count > 20))\n       ? cMGN : cRST), tmp);\n\n  if (!bytes_trim_out) {\n\n    sprintf(tmp, \"n/a, \");\n\n  } else {\n\n    sprintf(tmp, \"%0.02f%%/%s, \",\n            ((double)(bytes_trim_in - bytes_trim_out)) * 100 / bytes_trim_in,\n            DI(trim_execs));\n\n  }\n\n  if (!blocks_eff_total) {\n\n    u8 tmp2[128];\n\n    sprintf(tmp2, \"n/a\");\n    strcat(tmp, tmp2);\n\n  } else {\n\n    u8 tmp2[128];\n\n    sprintf(tmp2, \"%0.02f%%\",\n            ((double)(blocks_eff_total - blocks_eff_select)) * 100 /\n            blocks_eff_total);\n\n    strcat(tmp, tmp2);\n\n  }\n\n  SAYF(bV bSTOP \"        trim : \" cRST \"%-37s \" bSTG bVR bH20 bH2 bH2 bRB \"\\n\"\n       bLB bH30 bH20 bH2 bH bRB bSTOP cRST RESET_G1, tmp);\n\n  /* Provide some CPU utilization stats. */\n\n  if (cpu_core_count) {\n\n    double cur_runnable = get_runnable_processes();\n    u32 cur_utilization = cur_runnable * 100 / cpu_core_count;\n\n    u8* cpu_color = cCYA;\n\n    /* If we could still run one or more processes, use green. */\n\n    if (cpu_core_count > 1 && cur_runnable + 1 <= cpu_core_count)\n      cpu_color = cLGN;\n\n    /* If we're clearly oversubscribed, use red. */\n\n    if (!no_cpu_meter_red && cur_utilization >= 150) cpu_color = cLRD;\n\n#ifdef HAVE_AFFINITY\n\n    if (cpu_aff >= 0) {\n\n      SAYF(SP10 cGRA \"[cpu%03u:%s%3u%%\" cGRA \"]\\r\" cRST, \n           MIN(cpu_aff, 999), cpu_color,\n           MIN(cur_utilization, 999));\n\n    } else {\n\n      SAYF(SP10 cGRA \"   [cpu:%s%3u%%\" cGRA \"]\\r\" cRST,\n           cpu_color, MIN(cur_utilization, 999));\n \n   }\n\n#else\n\n    SAYF(SP10 cGRA \"   [cpu:%s%3u%%\" cGRA \"]\\r\" cRST,\n         cpu_color, MIN(cur_utilization, 999));\n\n#endif /* ^HAVE_AFFINITY */\n\n  } else SAYF(\"\\r\");\n\n  /* Hallelujah! */\n\n  fflush(0);\n\n}\n\n\n/* Display quick statistics at the end of processing the input directory,\n   plus a bunch of warnings. Some calibration stuff also ended up here,\n   along with several hardcoded constants. Maybe clean up eventually. */\n\nstatic void show_init_stats(void) {\n\n  struct queue_entry* q = queue;\n  u32 min_bits = 0, max_bits = 0;\n  u64 min_us = 0, max_us = 0;\n  u64 avg_us = 0;\n  u32 max_len = 0;\n\n  if (total_cal_cycles) avg_us = total_cal_us / total_cal_cycles;\n\n  while (q) {\n\n    if (!min_us || q->exec_us < min_us) min_us = q->exec_us;\n    if (q->exec_us > max_us) max_us = q->exec_us;\n\n    if (!min_bits || q->bitmap_size < min_bits) min_bits = q->bitmap_size;\n    if (q->bitmap_size > max_bits) max_bits = q->bitmap_size;\n\n    if (q->len > max_len) max_len = q->len;\n\n    q = q->next;\n\n  }\n\n  SAYF(\"\\n\");\n\n  if (avg_us > (qemu_mode ? 50000 : 10000)) \n    WARNF(cLRD \"The target binary is pretty slow! See %s/perf_tips.txt.\",\n          doc_path);\n\n  /* Let's keep things moving with slow binaries. */\n\n  if (avg_us > 50000) havoc_div = 10;     /* 0-19 execs/sec   */\n  else if (avg_us > 20000) havoc_div = 5; /* 20-49 execs/sec  */\n  else if (avg_us > 10000) havoc_div = 2; /* 50-100 execs/sec */\n\n  if (!resuming_fuzz) {\n\n    if (max_len > 50 * 1024)\n      WARNF(cLRD \"Some test cases are huge (%s) - see %s/perf_tips.txt!\",\n            DMS(max_len), doc_path);\n    else if (max_len > 10 * 1024)\n      WARNF(\"Some test cases are big (%s) - see %s/perf_tips.txt.\",\n            DMS(max_len), doc_path);\n\n    if (useless_at_start && !in_bitmap)\n      WARNF(cLRD \"Some test cases look useless. Consider using a smaller set.\");\n\n    if (queued_paths > 100)\n      WARNF(cLRD \"You probably have far too many input files! Consider trimming down.\");\n    else if (queued_paths > 20)\n      WARNF(\"You have lots of input files; try starting small.\");\n\n  }\n\n  OKF(\"Here are some useful stats:\\n\\n\"\n\n      cGRA \"    Test case count : \" cRST \"%u favored, %u variable, %u total\\n\"\n      cGRA \"       Bitmap range : \" cRST \"%u to %u bits (average: %0.02f bits)\\n\"\n      cGRA \"        Exec timing : \" cRST \"%s to %s us (average: %s us)\\n\",\n      queued_favored, queued_variable, queued_paths, min_bits, max_bits, \n      ((double)total_bitmap_size) / (total_bitmap_entries ? total_bitmap_entries : 1),\n      DI(min_us), DI(max_us), DI(avg_us));\n\n  if (!timeout_given) {\n\n    /* Figure out the appropriate timeout. The basic idea is: 5x average or\n       1x max, rounded up to EXEC_TM_ROUND ms and capped at 1 second.\n\n       If the program is slow, the multiplier is lowered to 2x or 3x, because\n       random scheduler jitter is less likely to have any impact, and because\n       our patience is wearing thin =) */\n\n    if (avg_us > 50000) exec_tmout = avg_us * 2 / 1000;\n    else if (avg_us > 10000) exec_tmout = avg_us * 3 / 1000;\n    else exec_tmout = avg_us * 5 / 1000;\n\n    exec_tmout = MAX(exec_tmout, max_us / 1000);\n    exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;\n\n    if (exec_tmout > EXEC_TIMEOUT) exec_tmout = EXEC_TIMEOUT;\n\n    ACTF(\"No -t option specified, so I'll use exec timeout of %u ms.\", \n         exec_tmout);\n\n    timeout_given = 1;\n\n  } else if (timeout_given == 3) {\n\n    ACTF(\"Applying timeout settings from resumed session (%u ms).\", exec_tmout);\n\n  }\n\n  /* In dumb mode, re-running every timing out test case with a generous time\n     limit is very expensive, so let's select a more conservative default. */\n\n  if (dumb_mode && !getenv(\"AFL_HANG_TMOUT\"))\n    hang_tmout = MIN(EXEC_TIMEOUT, exec_tmout * 2 + 100);\n\n  OKF(\"All set and ready to roll!\");\n\n}\n\n\n/* Find first power of two greater or equal to val (assuming val under\n   2^31). */\n\nstatic u32 next_p2(u32 val) {\n\n  u32 ret = 1;\n  while (val > ret) ret <<= 1;\n  return ret;\n\n} \n\n\n/* Trim all new test cases to save cycles when doing deterministic checks. The\n   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of\n   file size, to keep the stage short and sweet. */\n\nstatic u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf) {\n\n  static u8 tmp[64];\n  static u8 clean_trace[MAP_SIZE];\n\n  u8  needs_write = 0, fault = 0;\n  u32 trim_exec = 0;\n  u32 remove_len;\n  u32 len_p2;\n\n  /* Although the trimmer will be less useful when variable behavior is\n     detected, it will still work to some extent, so we don't check for\n     this. */\n\n  if (q->len < 5) return 0;\n\n  stage_name = tmp;\n  bytes_trim_in += q->len;\n\n  /* Select initial chunk len, starting with large steps. */\n\n  len_p2 = next_p2(q->len);\n\n  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);\n\n  /* Continue until the number of steps gets too high or the stepover\n     gets too small. */\n\n  while (remove_len >= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) {\n\n    u32 remove_pos = remove_len;\n\n    sprintf(tmp, \"trim %s/%s\", DI(remove_len), DI(remove_len));\n\n    stage_cur = 0;\n    stage_max = q->len / remove_len;\n\n    while (remove_pos < q->len) {\n\n      u32 trim_avail = MIN(remove_len, q->len - remove_pos);\n      u32 cksum;\n\n      write_with_gap(in_buf, q->len, remove_pos, trim_avail);\n\n      fault = run_target(argv, exec_tmout);\n      trim_execs++;\n\n      if (stop_soon || fault == FAULT_ERROR) goto abort_trimming;\n\n      /* Note that we don't keep track of crashes or hangs here; maybe TODO? */\n\n      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n      /* If the deletion had no impact on the trace, make it permanent. This\n         isn't perfect for variable-path inputs, but we're just making a\n         best-effort pass, so it's not a big deal if we end up with false\n         negatives every now and then. */\n\n      if (cksum == q->exec_cksum) {\n\n        u32 move_tail = q->len - remove_pos - trim_avail;\n\n        q->len -= trim_avail;\n        len_p2  = next_p2(q->len);\n\n        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, \n                move_tail);\n\n        /* Let's save a clean trace, which will be needed by\n           update_bitmap_score once we're done with the trimming stuff. */\n\n        if (!needs_write) {\n\n          needs_write = 1;\n          memcpy(clean_trace, trace_bits, MAP_SIZE);\n\n        }\n\n      } else remove_pos += remove_len;\n\n      /* Since this can be slow, update the screen every now and then. */\n\n      if (!(trim_exec++ % stats_update_freq)) show_stats();\n      stage_cur++;\n\n    }\n\n    remove_len >>= 1;\n\n  }\n\n  /* If we have made changes to in_buf, we also need to update the on-disk\n     version of the test case. */\n\n  if (needs_write) {\n\n    s32 fd;\n\n    unlink(q->fname); /* ignore errors */\n\n    fd = open(q->fname, O_WRONLY | O_CREAT | O_EXCL, 0600);\n\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", q->fname);\n\n    ck_write(fd, in_buf, q->len, q->fname);\n    close(fd);\n\n    memcpy(trace_bits, clean_trace, MAP_SIZE);\n    update_bitmap_score(q);\n\n  }\n\nabort_trimming:\n\n  bytes_trim_out += q->len;\n  return fault;\n\n}\n\n\n/* Write a modified test case, run program, process results. Handle\n   error conditions, returning 1 if it's time to bail out. This is\n   a helper function for fuzz_one(). */\n\nEXP_ST u8 common_fuzz_stuff(char** argv, u8* out_buf, u32 len) {\n\n  u8 fault;\n\n  if (post_handler) {\n\n    out_buf = post_handler(out_buf, &len);\n    if (!out_buf || !len) return 0;\n\n  }\n\n  write_to_testcase(out_buf, len);\n\n  fault = run_target(argv, exec_tmout);\n\n  if (stop_soon) return 1;\n\n  if (fault == FAULT_TMOUT) {\n\n    if (subseq_tmouts++ > TMOUT_LIMIT) {\n      cur_skipped_paths++;\n      return 1;\n    }\n\n  } else subseq_tmouts = 0;\n\n  /* Users can hit us with SIGUSR1 to request the current input\n     to be abandoned. */\n\n  if (skip_requested) {\n\n     skip_requested = 0;\n     cur_skipped_paths++;\n     return 1;\n\n  }\n\n  /* This handles FAULT_ERROR for us: */\n\n  queued_discovered += save_if_interesting(argv, out_buf, len, fault);\n\n  if (!(stage_cur % stats_update_freq) || stage_cur + 1 == stage_max)\n    show_stats();\n\n  return 0;\n\n}\n\n\n/* Helper to choose random block len for block operations in fuzz_one().\n   Doesn't return zero, provided that max_len is > 0. */\n\nstatic u32 choose_block_len(u32 limit) {\n\n  u32 min_value, max_value;\n  u32 rlim = MIN(queue_cycle, 3);\n\n  if (!run_over10m) rlim = 1;\n\n  switch (UR(rlim)) {\n\n    case 0:  min_value = 1;\n             max_value = HAVOC_BLK_SMALL;\n             break;\n\n    case 1:  min_value = HAVOC_BLK_SMALL;\n             max_value = HAVOC_BLK_MEDIUM;\n             break;\n\n    default: \n\n             if (UR(10)) {\n\n               min_value = HAVOC_BLK_MEDIUM;\n               max_value = HAVOC_BLK_LARGE;\n\n             } else {\n\n               min_value = HAVOC_BLK_LARGE;\n               max_value = HAVOC_BLK_XL;\n\n             }\n\n  }\n\n  if (min_value >= limit) min_value = 1;\n\n  return min_value + UR(MIN(max_value, limit) - min_value + 1);\n\n}\n\n\n/* Calculate case desirability score to adjust the length of havoc fuzzing.\n   A helper function for fuzz_one(). Maybe some of these constants should\n   go into config.h. */\n\nstatic u32 calculate_score(struct queue_entry* q) {\n\n  u32 avg_exec_us = total_cal_us / total_cal_cycles;\n  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;\n  u32 perf_score = 100;\n\n  /* Adjust score based on execution speed of this path, compared to the\n     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are\n     less expensive to fuzz, so we're giving them more air time. */\n\n  if (q->exec_us * 0.1 > avg_exec_us) perf_score = 10;\n  else if (q->exec_us * 0.25 > avg_exec_us) perf_score = 25;\n  else if (q->exec_us * 0.5 > avg_exec_us) perf_score = 50;\n  else if (q->exec_us * 0.75 > avg_exec_us) perf_score = 75;\n  else if (q->exec_us * 4 < avg_exec_us) perf_score = 300;\n  else if (q->exec_us * 3 < avg_exec_us) perf_score = 200;\n  else if (q->exec_us * 2 < avg_exec_us) perf_score = 150;\n\n  /* Adjust score based on bitmap size. The working theory is that better\n     coverage translates to better targets. Multiplier from 0.25x to 3x. */\n\n  if (q->bitmap_size * 0.3 > avg_bitmap_size) perf_score *= 3;\n  else if (q->bitmap_size * 0.5 > avg_bitmap_size) perf_score *= 2;\n  else if (q->bitmap_size * 0.75 > avg_bitmap_size) perf_score *= 1.5;\n  else if (q->bitmap_size * 3 < avg_bitmap_size) perf_score *= 0.25;\n  else if (q->bitmap_size * 2 < avg_bitmap_size) perf_score *= 0.5;\n  else if (q->bitmap_size * 1.5 < avg_bitmap_size) perf_score *= 0.75;\n\n  /* Adjust score based on handicap. Handicap is proportional to how late\n     in the game we learned about this path. Latecomers are allowed to run\n     for a bit longer until they catch up with the rest. */\n\n  if (q->handicap >= 4) {\n\n    perf_score *= 4;\n    q->handicap -= 4;\n\n  } else if (q->handicap) {\n\n    perf_score *= 2;\n    q->handicap--;\n\n  }\n\n  /* Final adjustment based on input depth, under the assumption that fuzzing\n     deeper test cases is more likely to reveal stuff that can't be\n     discovered with traditional fuzzers. */\n\n  switch (q->depth) {\n\n    case 0 ... 3:   break;\n    case 4 ... 7:   perf_score *= 2; break;\n    case 8 ... 13:  perf_score *= 3; break;\n    case 14 ... 25: perf_score *= 4; break;\n    default:        perf_score *= 5;\n\n  }\n\n  /* Make sure that we don't go over limit. */\n\n  if (perf_score > HAVOC_MAX_MULT * 100) perf_score = HAVOC_MAX_MULT * 100;\n\n  return perf_score;\n\n}\n\n\n/* Helper function to see if a particular change (xor_val = old ^ new) could\n   be a product of deterministic bit flips with the lengths and stepovers\n   attempted by afl-fuzz. This is used to avoid dupes in some of the\n   deterministic fuzzing operations that follow bit flips. We also\n   return 1 if xor_val is zero, which implies that the old and attempted new\n   values are identical and the exec would be a waste of time. */\n\nstatic u8 could_be_bitflip(u32 xor_val) {\n\n  u32 sh = 0;\n\n  if (!xor_val) return 1;\n\n  /* Shift left until first bit set. */\n\n  while (!(xor_val & 1)) { sh++; xor_val >>= 1; }\n\n  /* 1-, 2-, and 4-bit patterns are OK anywhere. */\n\n  if (xor_val == 1 || xor_val == 3 || xor_val == 15) return 1;\n\n  /* 8-, 16-, and 32-bit patterns are OK only if shift factor is\n     divisible by 8, since that's the stepover for these ops. */\n\n  if (sh & 7) return 0;\n\n  if (xor_val == 0xff || xor_val == 0xffff || xor_val == 0xffffffff)\n    return 1;\n\n  return 0;\n\n}\n\n\n/* Helper function to see if a particular value is reachable through\n   arithmetic operations. Used for similar purposes. */\n\nstatic u8 could_be_arith(u32 old_val, u32 new_val, u8 blen) {\n\n  u32 i, ov = 0, nv = 0, diffs = 0;\n\n  if (old_val == new_val) return 1;\n\n  /* See if one-byte adjustments to any byte could produce this result. */\n\n  for (i = 0; i < blen; i++) {\n\n    u8 a = old_val >> (8 * i),\n       b = new_val >> (8 * i);\n\n    if (a != b) { diffs++; ov = a; nv = b; }\n\n  }\n\n  /* If only one byte differs and the values are within range, return 1. */\n\n  if (diffs == 1) {\n\n    if ((u8)(ov - nv) <= ARITH_MAX ||\n        (u8)(nv - ov) <= ARITH_MAX) return 1;\n\n  }\n\n  if (blen == 1) return 0;\n\n  /* See if two-byte adjustments to any byte would produce this result. */\n\n  diffs = 0;\n\n  for (i = 0; i < blen / 2; i++) {\n\n    u16 a = old_val >> (16 * i),\n        b = new_val >> (16 * i);\n\n    if (a != b) { diffs++; ov = a; nv = b; }\n\n  }\n\n  /* If only one word differs and the values are within range, return 1. */\n\n  if (diffs == 1) {\n\n    if ((u16)(ov - nv) <= ARITH_MAX ||\n        (u16)(nv - ov) <= ARITH_MAX) return 1;\n\n    ov = SWAP16(ov); nv = SWAP16(nv);\n\n    if ((u16)(ov - nv) <= ARITH_MAX ||\n        (u16)(nv - ov) <= ARITH_MAX) return 1;\n\n  }\n\n  /* Finally, let's do the same thing for dwords. */\n\n  if (blen == 4) {\n\n    if ((u32)(old_val - new_val) <= ARITH_MAX ||\n        (u32)(new_val - old_val) <= ARITH_MAX) return 1;\n\n    new_val = SWAP32(new_val);\n    old_val = SWAP32(old_val);\n\n    if ((u32)(old_val - new_val) <= ARITH_MAX ||\n        (u32)(new_val - old_val) <= ARITH_MAX) return 1;\n\n  }\n\n  return 0;\n\n}\n\n\n/* Last but not least, a similar helper to see if insertion of an \n   interesting integer is redundant given the insertions done for\n   shorter blen. The last param (check_le) is set if the caller\n   already executed LE insertion for current blen and wants to see\n   if BE variant passed in new_val is unique. */\n\nstatic u8 could_be_interest(u32 old_val, u32 new_val, u8 blen, u8 check_le) {\n\n  u32 i, j;\n\n  if (old_val == new_val) return 1;\n\n  /* See if one-byte insertions from interesting_8 over old_val could\n     produce new_val. */\n\n  for (i = 0; i < blen; i++) {\n\n    for (j = 0; j < sizeof(interesting_8); j++) {\n\n      u32 tval = (old_val & ~(0xff << (i * 8))) |\n                 (((u8)interesting_8[j]) << (i * 8));\n\n      if (new_val == tval) return 1;\n\n    }\n\n  }\n\n  /* Bail out unless we're also asked to examine two-byte LE insertions\n     as a preparation for BE attempts. */\n\n  if (blen == 2 && !check_le) return 0;\n\n  /* See if two-byte insertions over old_val could give us new_val. */\n\n  for (i = 0; i < blen - 1; i++) {\n\n    for (j = 0; j < sizeof(interesting_16) / 2; j++) {\n\n      u32 tval = (old_val & ~(0xffff << (i * 8))) |\n                 (((u16)interesting_16[j]) << (i * 8));\n\n      if (new_val == tval) return 1;\n\n      /* Continue here only if blen > 2. */\n\n      if (blen > 2) {\n\n        tval = (old_val & ~(0xffff << (i * 8))) |\n               (SWAP16(interesting_16[j]) << (i * 8));\n\n        if (new_val == tval) return 1;\n\n      }\n\n    }\n\n  }\n\n  if (blen == 4 && check_le) {\n\n    /* See if four-byte insertions could produce the same result\n       (LE only). */\n\n    for (j = 0; j < sizeof(interesting_32) / 4; j++)\n      if (new_val == (u32)interesting_32[j]) return 1;\n\n  }\n\n  return 0;\n\n}\n\n\n/* Take the current entry from the queue, fuzz it for a while. This\n   function is a tad too long... returns 0 if fuzzed successfully, 1 if\n   skipped or bailed out. */\n\nstatic u8 fuzz_one(char** argv) {\n\n  s32 len, fd, temp_len, i, j;\n  u8  *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = 0;\n  u64 havoc_queued,  orig_hit_cnt, new_hit_cnt;\n  u32 splice_cycle = 0, perf_score = 100, orig_perf, prev_cksum, eff_cnt = 1;\n\n  u8  ret_val = 1, doing_det = 0;\n\n  u8  a_collect[MAX_AUTO_EXTRA];\n  u32 a_len = 0;\n\n#ifdef IGNORE_FINDS\n\n  /* In IGNORE_FINDS mode, skip any entries that weren't in the\n     initial data set. */\n\n  if (queue_cur->depth > 1) return 1;\n\n#else\n\n  if (pending_favored) {\n\n    /* If we have any favored, non-fuzzed new arrivals in the queue,\n       possibly skip to them at the expense of already-fuzzed or non-favored\n       cases. */\n\n    if ((queue_cur->was_fuzzed || !queue_cur->favored) &&\n        UR(100) < SKIP_TO_NEW_PROB) return 1;\n\n  } else if (!dumb_mode && !queue_cur->favored && queued_paths > 10) {\n\n    /* Otherwise, still possibly skip non-favored cases, albeit less often.\n       The odds of skipping stuff are higher for already-fuzzed inputs and\n       lower for never-fuzzed entries. */\n\n    if (queue_cycle > 1 && !queue_cur->was_fuzzed) {\n\n      if (UR(100) < SKIP_NFAV_NEW_PROB) return 1;\n\n    } else {\n\n      if (UR(100) < SKIP_NFAV_OLD_PROB) return 1;\n\n    }\n\n  }\n\n#endif /* ^IGNORE_FINDS */\n\n  if (not_on_tty) {\n    ACTF(\"Fuzzing test case #%u (%u total, %llu uniq crashes found)...\",\n         current_entry, queued_paths, unique_crashes);\n    fflush(stdout);\n  }\n\n  /* Map the test case into memory. */\n\n  fd = open(queue_cur->fname, O_RDONLY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", queue_cur->fname);\n\n  len = queue_cur->len;\n\n  orig_in = in_buf = mmap(0, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n\n  if (orig_in == MAP_FAILED) PFATAL(\"Unable to mmap '%s'\", queue_cur->fname);\n\n  close(fd);\n\n  /* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every\n     single byte anyway, so it wouldn't give us any performance or memory usage\n     benefits. */\n\n  out_buf = ck_alloc_nozero(len);\n\n  subseq_tmouts = 0;\n\n  cur_depth = queue_cur->depth;\n\n  /*******************************************\n   * CALIBRATION (only if failed earlier on) *\n   *******************************************/\n\n  if (queue_cur->cal_failed) {\n\n    u8 res = FAULT_TMOUT;\n\n    if (queue_cur->cal_failed < CAL_CHANCES) {\n\n      /* Reset exec_cksum to tell calibrate_case to re-execute the testcase\n         avoiding the usage of an invalid trace_bits.\n         For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */\n\n      queue_cur->exec_cksum = 0;\n\n      res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - 1, 0);\n\n      if (res == FAULT_ERROR)\n        FATAL(\"Unable to execute target application\");\n\n    }\n\n    if (stop_soon || res != crash_mode) {\n      cur_skipped_paths++;\n      goto abandon_entry;\n    }\n\n  }\n\n  /************\n   * TRIMMING *\n   ************/\n\n  if (!dumb_mode && !queue_cur->trim_done) {\n\n    u8 res = trim_case(argv, queue_cur, in_buf);\n\n    if (res == FAULT_ERROR)\n      FATAL(\"Unable to execute target application\");\n\n    if (stop_soon) {\n      cur_skipped_paths++;\n      goto abandon_entry;\n    }\n\n    /* Don't retry trimming, even if it failed. */\n\n    queue_cur->trim_done = 1;\n\n    if (len != queue_cur->len) len = queue_cur->len;\n\n  }\n\n  memcpy(out_buf, in_buf, len);\n\n  /*********************\n   * PERFORMANCE SCORE *\n   *********************/\n\n  orig_perf = perf_score = calculate_score(queue_cur);\n\n  /* Skip right away if -d is given, if we have done deterministic fuzzing on\n     this entry ourselves (was_fuzzed), or if it has gone through deterministic\n     testing in earlier, resumed runs (passed_det). */\n\n  if (skip_deterministic || queue_cur->was_fuzzed || queue_cur->passed_det)\n    goto havoc_stage;\n\n  /* Skip deterministic fuzzing if exec path checksum puts this out of scope\n     for this master instance. */\n\n  if (master_max && (queue_cur->exec_cksum % master_max) != master_id - 1)\n    goto havoc_stage;\n\n  doing_det = 1;\n\n  /*********************************************\n   * SIMPLE BITFLIP (+dictionary construction) *\n   *********************************************/\n\n#define FLIP_BIT(_ar, _b) do { \\\n    u8* _arf = (u8*)(_ar); \\\n    u32 _bf = (_b); \\\n    _arf[(_bf) >> 3] ^= (128 >> ((_bf) & 7)); \\\n  } while (0)\n\n  /* Single walking bit. */\n\n  stage_short = \"flip1\";\n  stage_max   = len << 3;\n  stage_name  = \"bitflip 1/1\";\n\n  stage_val_type = STAGE_VAL_NONE;\n\n  orig_hit_cnt = queued_paths + unique_crashes;\n\n  prev_cksum = queue_cur->exec_cksum;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur >> 3;\n\n    FLIP_BIT(out_buf, stage_cur);\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    FLIP_BIT(out_buf, stage_cur);\n\n    /* While flipping the least significant bit in every byte, pull of an extra\n       trick to detect possible syntax tokens. In essence, the idea is that if\n       you have a binary blob like this:\n\n       xxxxxxxxIHDRxxxxxxxx\n\n       ...and changing the leading and trailing bytes causes variable or no\n       changes in program flow, but touching any character in the \"IHDR\" string\n       always produces the same, distinctive path, it's highly likely that\n       \"IHDR\" is an atomically-checked magic value of special significance to\n       the fuzzed format.\n\n       We do this here, rather than as a separate stage, because it's a nice\n       way to keep the operation approximately \"free\" (i.e., no extra execs).\n       \n       Empirically, performing the check when flipping the least significant bit\n       is advantageous, compared to doing it at the time of more disruptive\n       changes, where the program flow may be affected in more violent ways.\n\n       The caveat is that we won't generate dictionaries in the -d mode or -S\n       mode - but that's probably a fair trade-off.\n\n       This won't work particularly well with paths that exhibit variable\n       behavior, but fails gracefully, so we'll carry out the checks anyway.\n\n      */\n\n    if (!dumb_mode && (stage_cur & 7) == 7) {\n\n      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n      if (stage_cur == stage_max - 1 && cksum == prev_cksum) {\n\n        /* If at end of file and we are still collecting a string, grab the\n           final character and force output. */\n\n        if (a_len < MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur >> 3];\n        a_len++;\n\n        if (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)\n          maybe_add_auto(a_collect, a_len);\n\n      } else if (cksum != prev_cksum) {\n\n        /* Otherwise, if the checksum has changed, see if we have something\n           worthwhile queued up, and collect that if the answer is yes. */\n\n        if (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)\n          maybe_add_auto(a_collect, a_len);\n\n        a_len = 0;\n        prev_cksum = cksum;\n\n      }\n\n      /* Continue collecting string, but only if the bit flip actually made\n         any difference - we don't want no-op tokens. */\n\n      if (cksum != queue_cur->exec_cksum) {\n\n        if (a_len < MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur >> 3];        \n        a_len++;\n\n      }\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP1] += stage_max;\n\n  /* Two walking bits. */\n\n  stage_name  = \"bitflip 2/1\";\n  stage_short = \"flip2\";\n  stage_max   = (len << 3) - 1;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur >> 3;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP2] += stage_max;\n\n  /* Four walking bits. */\n\n  stage_name  = \"bitflip 4/1\";\n  stage_short = \"flip4\";\n  stage_max   = (len << 3) - 3;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur >> 3;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n    FLIP_BIT(out_buf, stage_cur + 2);\n    FLIP_BIT(out_buf, stage_cur + 3);\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n    FLIP_BIT(out_buf, stage_cur + 2);\n    FLIP_BIT(out_buf, stage_cur + 3);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP4] += stage_max;\n\n  /* Effector map setup. These macros calculate:\n\n     EFF_APOS      - position of a particular file offset in the map.\n     EFF_ALEN      - length of a map with a particular number of bytes.\n     EFF_SPAN_ALEN - map span for a sequence of bytes.\n\n   */\n\n#define EFF_APOS(_p)          ((_p) >> EFF_MAP_SCALE2)\n#define EFF_REM(_x)           ((_x) & ((1 << EFF_MAP_SCALE2) - 1))\n#define EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))\n#define EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)\n\n  /* Initialize effector map for the next step (see comments below). Always\n     flag first and last byte as doing something. */\n\n  eff_map    = ck_alloc(EFF_ALEN(len));\n  eff_map[0] = 1;\n\n  if (EFF_APOS(len - 1) != 0) {\n    eff_map[EFF_APOS(len - 1)] = 1;\n    eff_cnt++;\n  }\n\n  /* Walking byte. */\n\n  stage_name  = \"bitflip 8/8\";\n  stage_short = \"flip8\";\n  stage_max   = len;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur;\n\n    out_buf[stage_cur] ^= 0xFF;\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    /* We also use this stage to pull off a simple trick: we identify\n       bytes that seem to have no effect on the current execution path\n       even when fully flipped - and we skip them during more expensive\n       deterministic stages, such as arithmetics or known ints. */\n\n    if (!eff_map[EFF_APOS(stage_cur)]) {\n\n      u32 cksum;\n\n      /* If in dumb mode or if the file is very short, just flag everything\n         without wasting time on checksums. */\n\n      if (!dumb_mode && len >= EFF_MIN_LEN)\n        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n      else\n        cksum = ~queue_cur->exec_cksum;\n\n      if (cksum != queue_cur->exec_cksum) {\n        eff_map[EFF_APOS(stage_cur)] = 1;\n        eff_cnt++;\n      }\n\n    }\n\n    out_buf[stage_cur] ^= 0xFF;\n\n  }\n\n  /* If the effector map is more than EFF_MAX_PERC dense, just flag the\n     whole thing as worth fuzzing, since we wouldn't be saving much time\n     anyway. */\n\n  if (eff_cnt != EFF_ALEN(len) &&\n      eff_cnt * 100 / EFF_ALEN(len) > EFF_MAX_PERC) {\n\n    memset(eff_map, 1, EFF_ALEN(len));\n\n    blocks_eff_select += EFF_ALEN(len);\n\n  } else {\n\n    blocks_eff_select += eff_cnt;\n\n  }\n\n  blocks_eff_total += EFF_ALEN(len);\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP8] += stage_max;\n\n  /* Two walking bytes. */\n\n  if (len < 2) goto skip_bitflip;\n\n  stage_name  = \"bitflip 16/8\";\n  stage_short = \"flip16\";\n  stage_cur   = 0;\n  stage_max   = len - 1;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 1; i++) {\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {\n      stage_max--;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    *(u16*)(out_buf + i) ^= 0xFFFF;\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n    stage_cur++;\n\n    *(u16*)(out_buf + i) ^= 0xFFFF;\n\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP16] += stage_max;\n\n  if (len < 4) goto skip_bitflip;\n\n  /* Four walking bytes. */\n\n  stage_name  = \"bitflip 32/8\";\n  stage_short = \"flip32\";\n  stage_cur   = 0;\n  stage_max   = len - 3;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 3; i++) {\n\n    /* Let's consult the effector map... */\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&\n        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {\n      stage_max--;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    *(u32*)(out_buf + i) ^= 0xFFFFFFFF;\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n    stage_cur++;\n\n    *(u32*)(out_buf + i) ^= 0xFFFFFFFF;\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP32] += stage_max;\n\nskip_bitflip:\n\n  if (no_arith) goto skip_arith;\n\n  /**********************\n   * ARITHMETIC INC/DEC *\n   **********************/\n\n  /* 8-bit arithmetics. */\n\n  stage_name  = \"arith 8/8\";\n  stage_short = \"arith8\";\n  stage_cur   = 0;\n  stage_max   = 2 * len * ARITH_MAX;\n\n  stage_val_type = STAGE_VAL_LE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len; i++) {\n\n    u8 orig = out_buf[i];\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)]) {\n      stage_max -= 2 * ARITH_MAX;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 1; j <= ARITH_MAX; j++) {\n\n      u8 r = orig ^ (orig + j);\n\n      /* Do arithmetic operations only if the result couldn't be a product\n         of a bitflip. */\n\n      if (!could_be_bitflip(r)) {\n\n        stage_cur_val = j;\n        out_buf[i] = orig + j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      r =  orig ^ (orig - j);\n\n      if (!could_be_bitflip(r)) {\n\n        stage_cur_val = -j;\n        out_buf[i] = orig - j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      out_buf[i] = orig;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_ARITH8] += stage_max;\n\n  /* 16-bit arithmetics, both endians. */\n\n  if (len < 2) goto skip_arith;\n\n  stage_name  = \"arith 16/8\";\n  stage_short = \"arith16\";\n  stage_cur   = 0;\n  stage_max   = 4 * (len - 1) * ARITH_MAX;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 1; i++) {\n\n    u16 orig = *(u16*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {\n      stage_max -= 4 * ARITH_MAX;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 1; j <= ARITH_MAX; j++) {\n\n      u16 r1 = orig ^ (orig + j),\n          r2 = orig ^ (orig - j),\n          r3 = orig ^ SWAP16(SWAP16(orig) + j),\n          r4 = orig ^ SWAP16(SWAP16(orig) - j);\n\n      /* Try little endian addition and subtraction first. Do it only\n         if the operation would affect more than one byte (hence the \n         & 0xff overflow checks) and if it couldn't be a product of\n         a bitflip. */\n\n      stage_val_type = STAGE_VAL_LE; \n\n      if ((orig & 0xff) + j > 0xff && !could_be_bitflip(r1)) {\n\n        stage_cur_val = j;\n        *(u16*)(out_buf + i) = orig + j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n \n      } else stage_max--;\n\n      if ((orig & 0xff) < j && !could_be_bitflip(r2)) {\n\n        stage_cur_val = -j;\n        *(u16*)(out_buf + i) = orig - j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      /* Big endian comes next. Same deal. */\n\n      stage_val_type = STAGE_VAL_BE;\n\n\n      if ((orig >> 8) + j > 0xff && !could_be_bitflip(r3)) {\n\n        stage_cur_val = j;\n        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) + j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((orig >> 8) < j && !could_be_bitflip(r4)) {\n\n        stage_cur_val = -j;\n        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) - j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      *(u16*)(out_buf + i) = orig;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_ARITH16]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_ARITH16] += stage_max;\n\n  /* 32-bit arithmetics, both endians. */\n\n  if (len < 4) goto skip_arith;\n\n  stage_name  = \"arith 32/8\";\n  stage_short = \"arith32\";\n  stage_cur   = 0;\n  stage_max   = 4 * (len - 3) * ARITH_MAX;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 3; i++) {\n\n    u32 orig = *(u32*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&\n        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {\n      stage_max -= 4 * ARITH_MAX;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 1; j <= ARITH_MAX; j++) {\n\n      u32 r1 = orig ^ (orig + j),\n          r2 = orig ^ (orig - j),\n          r3 = orig ^ SWAP32(SWAP32(orig) + j),\n          r4 = orig ^ SWAP32(SWAP32(orig) - j);\n\n      /* Little endian first. Same deal as with 16-bit: we only want to\n         try if the operation would have effect on more than two bytes. */\n\n      stage_val_type = STAGE_VAL_LE;\n\n      if ((orig & 0xffff) + j > 0xffff && !could_be_bitflip(r1)) {\n\n        stage_cur_val = j;\n        *(u32*)(out_buf + i) = orig + j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((orig & 0xffff) < j && !could_be_bitflip(r2)) {\n\n        stage_cur_val = -j;\n        *(u32*)(out_buf + i) = orig - j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      /* Big endian next. */\n\n      stage_val_type = STAGE_VAL_BE;\n\n      if ((SWAP32(orig) & 0xffff) + j > 0xffff && !could_be_bitflip(r3)) {\n\n        stage_cur_val = j;\n        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) + j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((SWAP32(orig) & 0xffff) < j && !could_be_bitflip(r4)) {\n\n        stage_cur_val = -j;\n        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) - j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      *(u32*)(out_buf + i) = orig;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_ARITH32]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_ARITH32] += stage_max;\n\nskip_arith:\n\n  /**********************\n   * INTERESTING VALUES *\n   **********************/\n\n  stage_name  = \"interest 8/8\";\n  stage_short = \"int8\";\n  stage_cur   = 0;\n  stage_max   = len * sizeof(interesting_8);\n\n  stage_val_type = STAGE_VAL_LE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  /* Setting 8-bit integers. */\n\n  for (i = 0; i < len; i++) {\n\n    u8 orig = out_buf[i];\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)]) {\n      stage_max -= sizeof(interesting_8);\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < sizeof(interesting_8); j++) {\n\n      /* Skip if the value could be a product of bitflips or arithmetics. */\n\n      if (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||\n          could_be_arith(orig, (u8)interesting_8[j], 1)) {\n        stage_max--;\n        continue;\n      }\n\n      stage_cur_val = interesting_8[j];\n      out_buf[i] = interesting_8[j];\n\n      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n      out_buf[i] = orig;\n      stage_cur++;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_INTEREST8] += stage_max;\n\n  /* Setting 16-bit integers, both endians. */\n\n  if (no_arith || len < 2) goto skip_interest;\n\n  stage_name  = \"interest 16/8\";\n  stage_short = \"int16\";\n  stage_cur   = 0;\n  stage_max   = 2 * (len - 1) * (sizeof(interesting_16) >> 1);\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 1; i++) {\n\n    u16 orig = *(u16*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {\n      stage_max -= sizeof(interesting_16);\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < sizeof(interesting_16) / 2; j++) {\n\n      stage_cur_val = interesting_16[j];\n\n      /* Skip if this could be a product of a bitflip, arithmetics,\n         or single-byte interesting value insertion. */\n\n      if (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &&\n          !could_be_arith(orig, (u16)interesting_16[j], 2) &&\n          !could_be_interest(orig, (u16)interesting_16[j], 2, 0)) {\n\n        stage_val_type = STAGE_VAL_LE;\n\n        *(u16*)(out_buf + i) = interesting_16[j];\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &&\n          !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &&\n          !could_be_arith(orig, SWAP16(interesting_16[j]), 2) &&\n          !could_be_interest(orig, SWAP16(interesting_16[j]), 2, 1)) {\n\n        stage_val_type = STAGE_VAL_BE;\n\n        *(u16*)(out_buf + i) = SWAP16(interesting_16[j]);\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n    }\n\n    *(u16*)(out_buf + i) = orig;\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_INTEREST16]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_INTEREST16] += stage_max;\n\n  if (len < 4) goto skip_interest;\n\n  /* Setting 32-bit integers, both endians. */\n\n  stage_name  = \"interest 32/8\";\n  stage_short = \"int32\";\n  stage_cur   = 0;\n  stage_max   = 2 * (len - 3) * (sizeof(interesting_32) >> 2);\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 3; i++) {\n\n    u32 orig = *(u32*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&\n        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {\n      stage_max -= sizeof(interesting_32) >> 1;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < sizeof(interesting_32) / 4; j++) {\n\n      stage_cur_val = interesting_32[j];\n\n      /* Skip if this could be a product of a bitflip, arithmetics,\n         or word interesting value insertion. */\n\n      if (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &&\n          !could_be_arith(orig, interesting_32[j], 4) &&\n          !could_be_interest(orig, interesting_32[j], 4, 0)) {\n\n        stage_val_type = STAGE_VAL_LE;\n\n        *(u32*)(out_buf + i) = interesting_32[j];\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &&\n          !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &&\n          !could_be_arith(orig, SWAP32(interesting_32[j]), 4) &&\n          !could_be_interest(orig, SWAP32(interesting_32[j]), 4, 1)) {\n\n        stage_val_type = STAGE_VAL_BE;\n\n        *(u32*)(out_buf + i) = SWAP32(interesting_32[j]);\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n    }\n\n    *(u32*)(out_buf + i) = orig;\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_INTEREST32]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_INTEREST32] += stage_max;\n\nskip_interest:\n\n  /********************\n   * DICTIONARY STUFF *\n   ********************/\n\n  if (!extras_cnt) goto skip_user_extras;\n\n  /* Overwrite with user-supplied extras. */\n\n  stage_name  = \"user extras (over)\";\n  stage_short = \"ext_UO\";\n  stage_cur   = 0;\n  stage_max   = extras_cnt * len;\n\n  stage_val_type = STAGE_VAL_NONE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len; i++) {\n\n    u32 last_len = 0;\n\n    stage_cur_byte = i;\n\n    /* Extras are sorted by size, from smallest to largest. This means\n       that we don't have to worry about restoring the buffer in\n       between writes at a particular offset determined by the outer\n       loop. */\n\n    for (j = 0; j < extras_cnt; j++) {\n\n      /* Skip extras probabilistically if extras_cnt > MAX_DET_EXTRAS. Also\n         skip them if there's no room to insert the payload, if the token\n         is redundant, or if its entire span has no bytes set in the effector\n         map. */\n\n      if ((extras_cnt > MAX_DET_EXTRAS && UR(extras_cnt) >= MAX_DET_EXTRAS) ||\n          extras[j].len > len - i ||\n          !memcmp(extras[j].data, out_buf + i, extras[j].len) ||\n          !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, extras[j].len))) {\n\n        stage_max--;\n        continue;\n\n      }\n\n      last_len = extras[j].len;\n      memcpy(out_buf + i, extras[j].data, last_len);\n\n      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n      stage_cur++;\n\n    }\n\n    /* Restore all the clobbered memory. */\n    memcpy(out_buf + i, in_buf + i, last_len);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_EXTRAS_UO] += stage_max;\n\n  /* Insertion of user-supplied extras. */\n\n  stage_name  = \"user extras (insert)\";\n  stage_short = \"ext_UI\";\n  stage_cur   = 0;\n  stage_max   = extras_cnt * (len + 1);\n\n  orig_hit_cnt = new_hit_cnt;\n\n  ex_tmp = ck_alloc(len + MAX_DICT_FILE);\n\n  for (i = 0; i <= len; i++) {\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < extras_cnt; j++) {\n\n      if (len + extras[j].len > MAX_FILE) {\n        stage_max--; \n        continue;\n      }\n\n      /* Insert token */\n      memcpy(ex_tmp + i, extras[j].data, extras[j].len);\n\n      /* Copy tail */\n      memcpy(ex_tmp + i + extras[j].len, out_buf + i, len - i);\n\n      if (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) {\n        ck_free(ex_tmp);\n        goto abandon_entry;\n      }\n\n      stage_cur++;\n\n    }\n\n    /* Copy head */\n    ex_tmp[i] = out_buf[i];\n\n  }\n\n  ck_free(ex_tmp);\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_EXTRAS_UI] += stage_max;\n\nskip_user_extras:\n\n  if (!a_extras_cnt) goto skip_extras;\n\n  stage_name  = \"auto extras (over)\";\n  stage_short = \"ext_AO\";\n  stage_cur   = 0;\n  stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;\n\n  stage_val_type = STAGE_VAL_NONE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len; i++) {\n\n    u32 last_len = 0;\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) {\n\n      /* See the comment in the earlier code; extras are sorted by size. */\n\n      if (a_extras[j].len > len - i ||\n          !memcmp(a_extras[j].data, out_buf + i, a_extras[j].len) ||\n          !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, a_extras[j].len))) {\n\n        stage_max--;\n        continue;\n\n      }\n\n      last_len = a_extras[j].len;\n      memcpy(out_buf + i, a_extras[j].data, last_len);\n\n      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n      stage_cur++;\n\n    }\n\n    /* Restore all the clobbered memory. */\n    memcpy(out_buf + i, in_buf + i, last_len);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_EXTRAS_AO] += stage_max;\n\nskip_extras:\n\n  /* If we made this to here without jumping to havoc_stage or abandon_entry,\n     we're properly done with deterministic steps and can mark it as such\n     in the .state/ directory. */\n\n  if (!queue_cur->passed_det) mark_as_det_done(queue_cur);\n\n  /****************\n   * RANDOM HAVOC *\n   ****************/\n\nhavoc_stage:\n\n  stage_cur_byte = -1;\n\n  /* The havoc stage mutation code is also invoked when splicing files; if the\n     splice_cycle variable is set, generate different descriptions and such. */\n\n  if (!splice_cycle) {\n\n    stage_name  = \"havoc\";\n    stage_short = \"havoc\";\n    stage_max   = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *\n                  perf_score / havoc_div / 100;\n\n  } else {\n\n    static u8 tmp[32];\n\n    perf_score = orig_perf;\n\n    sprintf(tmp, \"splice %u\", splice_cycle);\n    stage_name  = tmp;\n    stage_short = \"splice\";\n    stage_max   = SPLICE_HAVOC * perf_score / havoc_div / 100;\n\n  }\n\n  if (stage_max < HAVOC_MIN) stage_max = HAVOC_MIN;\n\n  temp_len = len;\n\n  orig_hit_cnt = queued_paths + unique_crashes;\n\n  havoc_queued = queued_paths;\n\n  /* We essentially just do several thousand runs (depending on perf_score)\n     where we take the input file and make random stacked tweaks. */\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    u32 use_stacking = 1 << (1 + UR(HAVOC_STACK_POW2));\n\n    stage_cur_val = use_stacking;\n \n    for (i = 0; i < use_stacking; i++) {\n\n      switch (UR(15 + ((extras_cnt + a_extras_cnt) ? 2 : 0))) {\n\n        case 0:\n\n          /* Flip a single bit somewhere. Spooky! */\n\n          FLIP_BIT(out_buf, UR(temp_len << 3));\n          break;\n\n        case 1: \n\n          /* Set byte to interesting value. */\n\n          out_buf[UR(temp_len)] = interesting_8[UR(sizeof(interesting_8))];\n          break;\n\n        case 2:\n\n          /* Set word to interesting value, randomly choosing endian. */\n\n          if (temp_len < 2) break;\n\n          if (UR(2)) {\n\n            *(u16*)(out_buf + UR(temp_len - 1)) =\n              interesting_16[UR(sizeof(interesting_16) >> 1)];\n\n          } else {\n\n            *(u16*)(out_buf + UR(temp_len - 1)) = SWAP16(\n              interesting_16[UR(sizeof(interesting_16) >> 1)]);\n\n          }\n\n          break;\n\n        case 3:\n\n          /* Set dword to interesting value, randomly choosing endian. */\n\n          if (temp_len < 4) break;\n\n          if (UR(2)) {\n  \n            *(u32*)(out_buf + UR(temp_len - 3)) =\n              interesting_32[UR(sizeof(interesting_32) >> 2)];\n\n          } else {\n\n            *(u32*)(out_buf + UR(temp_len - 3)) = SWAP32(\n              interesting_32[UR(sizeof(interesting_32) >> 2)]);\n\n          }\n\n          break;\n\n        case 4:\n\n          /* Randomly subtract from byte. */\n\n          out_buf[UR(temp_len)] -= 1 + UR(ARITH_MAX);\n          break;\n\n        case 5:\n\n          /* Randomly add to byte. */\n\n          out_buf[UR(temp_len)] += 1 + UR(ARITH_MAX);\n          break;\n\n        case 6:\n\n          /* Randomly subtract from word, random endian. */\n\n          if (temp_len < 2) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 1);\n\n            *(u16*)(out_buf + pos) -= 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 1);\n            u16 num = 1 + UR(ARITH_MAX);\n\n            *(u16*)(out_buf + pos) =\n              SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);\n\n          }\n\n          break;\n\n        case 7:\n\n          /* Randomly add to word, random endian. */\n\n          if (temp_len < 2) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 1);\n\n            *(u16*)(out_buf + pos) += 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 1);\n            u16 num = 1 + UR(ARITH_MAX);\n\n            *(u16*)(out_buf + pos) =\n              SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);\n\n          }\n\n          break;\n\n        case 8:\n\n          /* Randomly subtract from dword, random endian. */\n\n          if (temp_len < 4) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 3);\n\n            *(u32*)(out_buf + pos) -= 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 3);\n            u32 num = 1 + UR(ARITH_MAX);\n\n            *(u32*)(out_buf + pos) =\n              SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);\n\n          }\n\n          break;\n\n        case 9:\n\n          /* Randomly add to dword, random endian. */\n\n          if (temp_len < 4) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 3);\n\n            *(u32*)(out_buf + pos) += 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 3);\n            u32 num = 1 + UR(ARITH_MAX);\n\n            *(u32*)(out_buf + pos) =\n              SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);\n\n          }\n\n          break;\n\n        case 10:\n\n          /* Just set a random byte to a random value. Because,\n             why not. We use XOR with 1-255 to eliminate the\n             possibility of a no-op. */\n\n          out_buf[UR(temp_len)] ^= 1 + UR(255);\n          break;\n\n        case 11 ... 12: {\n\n            /* Delete bytes. We're making this a bit more likely\n               than insertion (the next option) in hopes of keeping\n               files reasonably small. */\n\n            u32 del_from, del_len;\n\n            if (temp_len < 2) break;\n\n            /* Don't delete too much. */\n\n            del_len = choose_block_len(temp_len - 1);\n\n            del_from = UR(temp_len - del_len + 1);\n\n            memmove(out_buf + del_from, out_buf + del_from + del_len,\n                    temp_len - del_from - del_len);\n\n            temp_len -= del_len;\n\n            break;\n\n          }\n\n        case 13:\n\n          if (temp_len + HAVOC_BLK_XL < MAX_FILE) {\n\n            /* Clone bytes (75%) or insert a block of constant bytes (25%). */\n\n            u8  actually_clone = UR(4);\n            u32 clone_from, clone_to, clone_len;\n            u8* new_buf;\n\n            if (actually_clone) {\n\n              clone_len  = choose_block_len(temp_len);\n              clone_from = UR(temp_len - clone_len + 1);\n\n            } else {\n\n              clone_len = choose_block_len(HAVOC_BLK_XL);\n              clone_from = 0;\n\n            }\n\n            clone_to   = UR(temp_len);\n\n            new_buf = ck_alloc_nozero(temp_len + clone_len);\n\n            /* Head */\n\n            memcpy(new_buf, out_buf, clone_to);\n\n            /* Inserted part */\n\n            if (actually_clone)\n              memcpy(new_buf + clone_to, out_buf + clone_from, clone_len);\n            else\n              memset(new_buf + clone_to,\n                     UR(2) ? UR(256) : out_buf[UR(temp_len)], clone_len);\n\n            /* Tail */\n            memcpy(new_buf + clone_to + clone_len, out_buf + clone_to,\n                   temp_len - clone_to);\n\n            ck_free(out_buf);\n            out_buf = new_buf;\n            temp_len += clone_len;\n\n          }\n\n          break;\n\n        case 14: {\n\n            /* Overwrite bytes with a randomly selected chunk (75%) or fixed\n               bytes (25%). */\n\n            u32 copy_from, copy_to, copy_len;\n\n            if (temp_len < 2) break;\n\n            copy_len  = choose_block_len(temp_len - 1);\n\n            copy_from = UR(temp_len - copy_len + 1);\n            copy_to   = UR(temp_len - copy_len + 1);\n\n            if (UR(4)) {\n\n              if (copy_from != copy_to)\n                memmove(out_buf + copy_to, out_buf + copy_from, copy_len);\n\n            } else memset(out_buf + copy_to,\n                          UR(2) ? UR(256) : out_buf[UR(temp_len)], copy_len);\n\n            break;\n\n          }\n\n        /* Values 15 and 16 can be selected only if there are any extras\n           present in the dictionaries. */\n\n        case 15: {\n\n            /* Overwrite bytes with an extra. */\n\n            if (!extras_cnt || (a_extras_cnt && UR(2))) {\n\n              /* No user-specified extras or odds in our favor. Let's use an\n                 auto-detected one. */\n\n              u32 use_extra = UR(a_extras_cnt);\n              u32 extra_len = a_extras[use_extra].len;\n              u32 insert_at;\n\n              if (extra_len > temp_len) break;\n\n              insert_at = UR(temp_len - extra_len + 1);\n              memcpy(out_buf + insert_at, a_extras[use_extra].data, extra_len);\n\n            } else {\n\n              /* No auto extras or odds in our favor. Use the dictionary. */\n\n              u32 use_extra = UR(extras_cnt);\n              u32 extra_len = extras[use_extra].len;\n              u32 insert_at;\n\n              if (extra_len > temp_len) break;\n\n              insert_at = UR(temp_len - extra_len + 1);\n              memcpy(out_buf + insert_at, extras[use_extra].data, extra_len);\n\n            }\n\n            break;\n\n          }\n\n        case 16: {\n\n            u32 use_extra, extra_len, insert_at = UR(temp_len + 1);\n            u8* new_buf;\n\n            /* Insert an extra. Do the same dice-rolling stuff as for the\n               previous case. */\n\n            if (!extras_cnt || (a_extras_cnt && UR(2))) {\n\n              use_extra = UR(a_extras_cnt);\n              extra_len = a_extras[use_extra].len;\n\n              if (temp_len + extra_len >= MAX_FILE) break;\n\n              new_buf = ck_alloc_nozero(temp_len + extra_len);\n\n              /* Head */\n              memcpy(new_buf, out_buf, insert_at);\n\n              /* Inserted part */\n              memcpy(new_buf + insert_at, a_extras[use_extra].data, extra_len);\n\n            } else {\n\n              use_extra = UR(extras_cnt);\n              extra_len = extras[use_extra].len;\n\n              if (temp_len + extra_len >= MAX_FILE) break;\n\n              new_buf = ck_alloc_nozero(temp_len + extra_len);\n\n              /* Head */\n              memcpy(new_buf, out_buf, insert_at);\n\n              /* Inserted part */\n              memcpy(new_buf + insert_at, extras[use_extra].data, extra_len);\n\n            }\n\n            /* Tail */\n            memcpy(new_buf + insert_at + extra_len, out_buf + insert_at,\n                   temp_len - insert_at);\n\n            ck_free(out_buf);\n            out_buf   = new_buf;\n            temp_len += extra_len;\n\n            break;\n\n          }\n\n      }\n\n    }\n\n    if (common_fuzz_stuff(argv, out_buf, temp_len))\n      goto abandon_entry;\n\n    /* out_buf might have been mangled a bit, so let's restore it to its\n       original size and shape. */\n\n    if (temp_len < len) out_buf = ck_realloc(out_buf, len);\n    temp_len = len;\n    memcpy(out_buf, in_buf, len);\n\n    /* If we're finding new stuff, let's run for a bit longer, limits\n       permitting. */\n\n    if (queued_paths != havoc_queued) {\n\n      if (perf_score <= HAVOC_MAX_MULT * 100) {\n        stage_max  *= 2;\n        perf_score *= 2;\n      }\n\n      havoc_queued = queued_paths;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  if (!splice_cycle) {\n    stage_finds[STAGE_HAVOC]  += new_hit_cnt - orig_hit_cnt;\n    stage_cycles[STAGE_HAVOC] += stage_max;\n  } else {\n    stage_finds[STAGE_SPLICE]  += new_hit_cnt - orig_hit_cnt;\n    stage_cycles[STAGE_SPLICE] += stage_max;\n  }\n\n#ifndef IGNORE_FINDS\n\n  /************\n   * SPLICING *\n   ************/\n\n  /* This is a last-resort strategy triggered by a full round with no findings.\n     It takes the current input file, randomly selects another input, and\n     splices them together at some offset, then relies on the havoc\n     code to mutate that blob. */\n\nretry_splicing:\n\n  if (use_splicing && splice_cycle++ < SPLICE_CYCLES &&\n      queued_paths > 1 && queue_cur->len > 1) {\n\n    struct queue_entry* target;\n    u32 tid, split_at;\n    u8* new_buf;\n    s32 f_diff, l_diff;\n\n    /* First of all, if we've modified in_buf for havoc, let's clean that\n       up... */\n\n    if (in_buf != orig_in) {\n      ck_free(in_buf);\n      in_buf = orig_in;\n      len = queue_cur->len;\n    }\n\n    /* Pick a random queue entry and seek to it. Don't splice with yourself. */\n\n    do { tid = UR(queued_paths); } while (tid == current_entry);\n\n    splicing_with = tid;\n    target = queue;\n\n    while (tid >= 100) { target = target->next_100; tid -= 100; }\n    while (tid--) target = target->next;\n\n    /* Make sure that the target has a reasonable length. */\n\n    while (target && (target->len < 2 || target == queue_cur)) {\n      target = target->next;\n      splicing_with++;\n    }\n\n    if (!target) goto retry_splicing;\n\n    /* Read the testcase into a new buffer. */\n\n    fd = open(target->fname, O_RDONLY);\n\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", target->fname);\n\n    new_buf = ck_alloc_nozero(target->len);\n\n    ck_read(fd, new_buf, target->len, target->fname);\n\n    close(fd);\n\n    /* Find a suitable splicing location, somewhere between the first and\n       the last differing byte. Bail out if the difference is just a single\n       byte or so. */\n\n    locate_diffs(in_buf, new_buf, MIN(len, target->len), &f_diff, &l_diff);\n\n    if (f_diff < 0 || l_diff < 2 || f_diff == l_diff) {\n      ck_free(new_buf);\n      goto retry_splicing;\n    }\n\n    /* Split somewhere between the first and last differing byte. */\n\n    split_at = f_diff + UR(l_diff - f_diff);\n\n    /* Do the thing. */\n\n    len = target->len;\n    memcpy(new_buf, in_buf, split_at);\n    in_buf = new_buf;\n\n    ck_free(out_buf);\n    out_buf = ck_alloc_nozero(len);\n    memcpy(out_buf, in_buf, len);\n\n    goto havoc_stage;\n\n  }\n\n#endif /* !IGNORE_FINDS */\n\n  ret_val = 0;\n\nabandon_entry:\n\n  splicing_with = -1;\n\n  /* Update pending_not_fuzzed count if we made it through the calibration\n     cycle and have not seen this entry before. */\n\n  if (!stop_soon && !queue_cur->cal_failed && !queue_cur->was_fuzzed) {\n    queue_cur->was_fuzzed = 1;\n    pending_not_fuzzed--;\n    if (queue_cur->favored) pending_favored--;\n  }\n\n  munmap(orig_in, queue_cur->len);\n\n  if (in_buf != orig_in) ck_free(in_buf);\n  ck_free(out_buf);\n  ck_free(eff_map);\n\n  return ret_val;\n\n#undef FLIP_BIT\n\n}\n\n\n/* Grab interesting test cases from other fuzzers. */\n\nstatic void sync_fuzzers(char** argv) {\n\n  DIR* sd;\n  struct dirent* sd_ent;\n  u32 sync_cnt = 0;\n\n  sd = opendir(sync_dir);\n  if (!sd) PFATAL(\"Unable to open '%s'\", sync_dir);\n\n  stage_max = stage_cur = 0;\n  cur_depth = 0;\n\n  /* Look at the entries created for every other fuzzer in the sync directory. */\n\n  while ((sd_ent = readdir(sd))) {\n\n    static u8 stage_tmp[128];\n\n    DIR* qd;\n    struct dirent* qd_ent;\n    u8 *qd_path, *qd_synced_path;\n    u32 min_accept = 0, next_min_accept;\n\n    s32 id_fd;\n\n    /* Skip dot files and our own output directory. */\n\n    if (sd_ent->d_name[0] == '.' || !strcmp(sync_id, sd_ent->d_name)) continue;\n\n    /* Skip anything that doesn't have a queue/ subdirectory. */\n\n    qd_path = alloc_printf(\"%s/%s/queue\", sync_dir, sd_ent->d_name);\n\n    if (!(qd = opendir(qd_path))) {\n      ck_free(qd_path);\n      continue;\n    }\n\n    /* Retrieve the ID of the last seen test case. */\n\n    qd_synced_path = alloc_printf(\"%s/.synced/%s\", out_dir, sd_ent->d_name);\n\n    id_fd = open(qd_synced_path, O_RDWR | O_CREAT, 0600);\n\n    if (id_fd < 0) PFATAL(\"Unable to create '%s'\", qd_synced_path);\n\n    if (read(id_fd, &min_accept, sizeof(u32)) > 0) \n      lseek(id_fd, 0, SEEK_SET);\n\n    next_min_accept = min_accept;\n\n    /* Show stats */    \n\n    sprintf(stage_tmp, \"sync %u\", ++sync_cnt);\n    stage_name = stage_tmp;\n    stage_cur  = 0;\n    stage_max  = 0;\n\n    /* For every file queued by this fuzzer, parse ID and see if we have looked at\n       it before; exec a test case if not. */\n\n    while ((qd_ent = readdir(qd))) {\n\n      u8* path;\n      s32 fd;\n      struct stat st;\n\n      if (qd_ent->d_name[0] == '.' ||\n          sscanf(qd_ent->d_name, CASE_PREFIX \"%06u\", &syncing_case) != 1 || \n          syncing_case < min_accept) continue;\n\n      /* OK, sounds like a new one. Let's give it a try. */\n\n      if (syncing_case >= next_min_accept)\n        next_min_accept = syncing_case + 1;\n\n      path = alloc_printf(\"%s/%s\", qd_path, qd_ent->d_name);\n\n      /* Allow this to fail in case the other fuzzer is resuming or so... */\n\n      fd = open(path, O_RDONLY);\n\n      if (fd < 0) {\n         ck_free(path);\n         continue;\n      }\n\n      if (fstat(fd, &st)) PFATAL(\"fstat() failed\");\n\n      /* Ignore zero-sized or oversized files. */\n\n      if (st.st_size && st.st_size <= MAX_FILE) {\n\n        u8  fault;\n        u8* mem = mmap(0, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n        if (mem == MAP_FAILED) PFATAL(\"Unable to mmap '%s'\", path);\n\n        /* See what happens. We rely on save_if_interesting() to catch major\n           errors and save the test case. */\n\n        write_to_testcase(mem, st.st_size);\n\n        fault = run_target(argv, exec_tmout);\n\n        if (stop_soon) return;\n\n        syncing_party = sd_ent->d_name;\n        queued_imported += save_if_interesting(argv, mem, st.st_size, fault);\n        syncing_party = 0;\n\n        munmap(mem, st.st_size);\n\n        if (!(stage_cur++ % stats_update_freq)) show_stats();\n\n      }\n\n      ck_free(path);\n      close(fd);\n\n    }\n\n    ck_write(id_fd, &next_min_accept, sizeof(u32), qd_synced_path);\n\n    close(id_fd);\n    closedir(qd);\n    ck_free(qd_path);\n    ck_free(qd_synced_path);\n    \n  }  \n\n  closedir(sd);\n\n}\n\n\n/* Handle stop signal (Ctrl-C, etc). */\n\nstatic void handle_stop_sig(int sig) {\n\n  stop_soon = 1; \n\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n  if (forksrv_pid > 0) kill(forksrv_pid, SIGKILL);\n\n}\n\n\n/* Handle skip request (SIGUSR1). */\n\nstatic void handle_skipreq(int sig) {\n\n  skip_requested = 1;\n\n}\n\n/* Handle timeout (SIGALRM). */\n\nstatic void handle_timeout(int sig) {\n\n  if (child_pid > 0) {\n\n    child_timed_out = 1; \n    kill(child_pid, SIGKILL);\n\n  } else if (child_pid == -1 && forksrv_pid > 0) {\n\n    child_timed_out = 1; \n    kill(forksrv_pid, SIGKILL);\n\n  }\n\n}\n\n\n/* Do a PATH search and find target binary to see that it exists and\n   isn't a shell script - a common and painful mistake. We also check for\n   a valid ELF header and for evidence of AFL instrumentation. */\n\nEXP_ST void check_binary(u8* fname) {\n\n  u8* env_path = 0;\n  struct stat st;\n\n  s32 fd;\n  u8* f_data;\n  u32 f_len = 0;\n\n  ACTF(\"Validating target binary...\");\n\n  if (strchr(fname, '/') || !(env_path = getenv(\"PATH\"))) {\n\n    target_path = ck_strdup(fname);\n    if (stat(target_path, &st) || !S_ISREG(st.st_mode) ||\n        !(st.st_mode & 0111) || (f_len = st.st_size) < 4)\n      FATAL(\"Program '%s' not found or not executable\", fname);\n\n  } else {\n\n    while (env_path) {\n\n      u8 *cur_elem, *delim = strchr(env_path, ':');\n\n      if (delim) {\n\n        cur_elem = ck_alloc(delim - env_path + 1);\n        memcpy(cur_elem, env_path, delim - env_path);\n        delim++;\n\n      } else cur_elem = ck_strdup(env_path);\n\n      env_path = delim;\n\n      if (cur_elem[0])\n        target_path = alloc_printf(\"%s/%s\", cur_elem, fname);\n      else\n        target_path = ck_strdup(fname);\n\n      ck_free(cur_elem);\n\n      if (!stat(target_path, &st) && S_ISREG(st.st_mode) &&\n          (st.st_mode & 0111) && (f_len = st.st_size) >= 4) break;\n\n      ck_free(target_path);\n      target_path = 0;\n\n    }\n\n    if (!target_path) FATAL(\"Program '%s' not found or not executable\", fname);\n\n  }\n\n  if (getenv(\"AFL_SKIP_BIN_CHECK\")) return;\n\n  /* Check for blatant user errors. */\n\n  if ((!strncmp(target_path, \"/tmp/\", 5) && !strchr(target_path + 5, '/')) ||\n      (!strncmp(target_path, \"/var/tmp/\", 9) && !strchr(target_path + 9, '/')))\n     FATAL(\"Please don't keep binaries in /tmp or /var/tmp\");\n\n  fd = open(target_path, O_RDONLY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", target_path);\n\n  f_data = mmap(0, f_len, PROT_READ, MAP_PRIVATE, fd, 0);\n\n  if (f_data == MAP_FAILED) PFATAL(\"Unable to mmap file '%s'\", target_path);\n\n  close(fd);\n\n  if (f_data[0] == '#' && f_data[1] == '!') {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Oops, the target binary looks like a shell script. Some build systems will\\n\"\n         \"    sometimes generate shell stubs for dynamically linked programs; try static\\n\"\n         \"    library mode (./configure --disable-shared) if that's the case.\\n\\n\"\n\n         \"    Another possible cause is that you are actually trying to use a shell\\n\" \n         \"    wrapper around the fuzzed component. Invoking shell can slow down the\\n\" \n         \"    fuzzing process by a factor of 20x or more; it's best to write the wrapper\\n\"\n         \"    in a compiled language instead.\\n\");\n\n    FATAL(\"Program '%s' is a shell script\", target_path);\n\n  }\n\n#ifndef __APPLE__\n\n  if (f_data[0] != 0x7f || memcmp(f_data + 1, \"ELF\", 3))\n    FATAL(\"Program '%s' is not an ELF binary\", target_path);\n\n#else\n\n  if (f_data[0] != 0xCF || f_data[1] != 0xFA || f_data[2] != 0xED)\n    FATAL(\"Program '%s' is not a 64-bit Mach-O binary\", target_path);\n\n#endif /* ^!__APPLE__ */\n\n  if (!qemu_mode && !dumb_mode &&\n      !memmem(f_data, f_len, SHM_ENV_VAR, strlen(SHM_ENV_VAR) + 1)) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Looks like the target binary is not instrumented! The fuzzer depends on\\n\"\n         \"    compile-time instrumentation to isolate interesting test cases while\\n\"\n         \"    mutating the input data. For more information, and for tips on how to\\n\"\n         \"    instrument binaries, please see %s/README.\\n\\n\"\n\n         \"    When source code is not available, you may be able to leverage QEMU\\n\"\n         \"    mode support. Consult the README for tips on how to enable this.\\n\"\n\n         \"    (It is also possible to use afl-fuzz as a traditional, \\\"dumb\\\" fuzzer.\\n\"\n         \"    For that, you can use the -n option - but expect much worse results.)\\n\",\n         doc_path);\n\n    FATAL(\"No instrumentation detected\");\n\n  }\n\n  if (qemu_mode &&\n      memmem(f_data, f_len, SHM_ENV_VAR, strlen(SHM_ENV_VAR) + 1)) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"This program appears to be instrumented with afl-gcc, but is being run in\\n\"\n         \"    QEMU mode (-Q). This is probably not what you want - this setup will be\\n\"\n         \"    slow and offer no practical benefits.\\n\");\n\n    FATAL(\"Instrumentation found in -Q mode\");\n\n  }\n\n  if (memmem(f_data, f_len, \"libasan.so\", 10) ||\n      memmem(f_data, f_len, \"__msan_init\", 11)) uses_asan = 1;\n\n  /* Detect persistent & deferred init signatures in the binary. */\n\n  if (memmem(f_data, f_len, PERSIST_SIG, strlen(PERSIST_SIG) + 1)) {\n\n    OKF(cPIN \"Persistent mode binary detected.\");\n    setenv(PERSIST_ENV_VAR, \"1\", 1);\n    persistent_mode = 1;\n\n  } else if (getenv(\"AFL_PERSISTENT\")) {\n\n    WARNF(\"AFL_PERSISTENT is no longer supported and may misbehave!\");\n\n  }\n\n  if (memmem(f_data, f_len, DEFER_SIG, strlen(DEFER_SIG) + 1)) {\n\n    OKF(cPIN \"Deferred forkserver binary detected.\");\n    setenv(DEFER_ENV_VAR, \"1\", 1);\n    deferred_mode = 1;\n\n  } else if (getenv(\"AFL_DEFER_FORKSRV\")) {\n\n    WARNF(\"AFL_DEFER_FORKSRV is no longer supported and may misbehave!\");\n\n  }\n\n  if (munmap(f_data, f_len)) PFATAL(\"unmap() failed\");\n\n}\n\n\n/* Trim and possibly create a banner for the run. */\n\nstatic void fix_up_banner(u8* name) {\n\n  if (!use_banner) {\n\n    if (sync_id) {\n\n      use_banner = sync_id;\n\n    } else {\n\n      u8* trim = strrchr(name, '/');\n      if (!trim) use_banner = name; else use_banner = trim + 1;\n\n    }\n\n  }\n\n  if (strlen(use_banner) > 40) {\n\n    u8* tmp = ck_alloc(44);\n    sprintf(tmp, \"%.40s...\", use_banner);\n    use_banner = tmp;\n\n  }\n\n}\n\n\n/* Check if we're on TTY. */\n\nstatic void check_if_tty(void) {\n\n  struct winsize ws;\n\n  if (getenv(\"AFL_NO_UI\")) {\n    OKF(\"Disabling the UI because AFL_NO_UI is set.\");\n    not_on_tty = 1;\n    return;\n  }\n\n  if (ioctl(1, TIOCGWINSZ, &ws)) {\n\n    if (errno == ENOTTY) {\n      OKF(\"Looks like we're not running on a tty, so I'll be a bit less verbose.\");\n      not_on_tty = 1;\n    }\n\n    return;\n  }\n\n}\n\n\n/* Check terminal dimensions after resize. */\n\nstatic void check_term_size(void) {\n\n  struct winsize ws;\n\n  term_too_small = 0;\n\n  if (ioctl(1, TIOCGWINSZ, &ws)) return;\n\n  if (ws.ws_row == 0 && ws.ws_col == 0) return;\n  if (ws.ws_row < 25 || ws.ws_col < 80) term_too_small = 1;\n\n}\n\n\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  SAYF(\"\\n%s [ options ] -- /path/to/fuzzed_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -i dir        - input directory with test cases\\n\"\n       \"  -o dir        - output directory for fuzzer findings\\n\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -f file       - location read by the fuzzed program (stdin)\\n\"\n       \"  -t msec       - timeout for each run (auto-scaled, 50-%u ms)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n       \"  -Q            - use binary-only instrumentation (QEMU mode)\\n\\n\"     \n \n       \"Fuzzing behavior settings:\\n\\n\"\n\n       \"  -d            - quick & dirty mode (skips deterministic steps)\\n\"\n       \"  -n            - fuzz without instrumentation (dumb mode)\\n\"\n       \"  -x dir        - optional fuzzer dictionary (see README)\\n\\n\"\n\n       \"Other stuff:\\n\\n\"\n\n       \"  -T text       - text banner to show on the screen\\n\"\n       \"  -M / -S id    - distributed mode (see parallel_fuzzing.txt)\\n\"\n       \"  -C            - crash exploration mode (the peruvian rabbit thing)\\n\"\n       \"  -V            - show version number and exit\\n\\n\"\n       \"  -b cpu_id     - bind the fuzzing process to the specified CPU core\\n\\n\"\n\n       \"For additional tips, please consult %s/README.\\n\\n\",\n\n       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Prepare output directories and fds. */\n\nEXP_ST void setup_dirs_fds(void) {\n\n  u8* tmp;\n  s32 fd;\n\n  ACTF(\"Setting up output directories...\");\n\n  if (sync_id && mkdir(sync_dir, 0700) && errno != EEXIST)\n      PFATAL(\"Unable to create '%s'\", sync_dir);\n\n  if (mkdir(out_dir, 0700)) {\n\n    if (errno != EEXIST) PFATAL(\"Unable to create '%s'\", out_dir);\n\n    maybe_delete_out_dir();\n\n  } else {\n\n    if (in_place_resume)\n      FATAL(\"Resume attempted but old output directory not found\");\n\n    out_dir_fd = open(out_dir, O_RDONLY);\n\n#ifndef __sun\n\n    if (out_dir_fd < 0 || flock(out_dir_fd, LOCK_EX | LOCK_NB))\n      PFATAL(\"Unable to flock() output directory.\");\n\n#endif /* !__sun */\n\n  }\n\n  /* Queue directory for any starting & discovered paths. */\n\n  tmp = alloc_printf(\"%s/queue\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Top-level directory for queue metadata used for session\n     resume and related tasks. */\n\n  tmp = alloc_printf(\"%s/queue/.state/\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Directory for flagging queue entries that went through\n     deterministic fuzzing in the past. */\n\n  tmp = alloc_printf(\"%s/queue/.state/deterministic_done/\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Directory with the auto-selected dictionary entries. */\n\n  tmp = alloc_printf(\"%s/queue/.state/auto_extras/\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* The set of paths currently deemed redundant. */\n\n  tmp = alloc_printf(\"%s/queue/.state/redundant_edges/\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* The set of paths showing variable behavior. */\n\n  tmp = alloc_printf(\"%s/queue/.state/variable_behavior/\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Sync directory for keeping track of cooperating fuzzers. */\n\n  if (sync_id) {\n\n    tmp = alloc_printf(\"%s/.synced/\", out_dir);\n\n    if (mkdir(tmp, 0700) && (!in_place_resume || errno != EEXIST))\n      PFATAL(\"Unable to create '%s'\", tmp);\n\n    ck_free(tmp);\n\n  }\n\n  /* All recorded crashes. */\n\n  tmp = alloc_printf(\"%s/crashes\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* All recorded hangs. */\n\n  tmp = alloc_printf(\"%s/hangs\", out_dir);\n  if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Generally useful file descriptors. */\n\n  dev_null_fd = open(\"/dev/null\", O_RDWR);\n  if (dev_null_fd < 0) PFATAL(\"Unable to open /dev/null\");\n\n  dev_urandom_fd = open(\"/dev/urandom\", O_RDONLY);\n  if (dev_urandom_fd < 0) PFATAL(\"Unable to open /dev/urandom\");\n\n  /* Gnuplot output file. */\n\n  tmp = alloc_printf(\"%s/plot_data\", out_dir);\n  fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, 0600);\n  if (fd < 0) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  plot_file = fdopen(fd, \"w\");\n  if (!plot_file) PFATAL(\"fdopen() failed\");\n\n  fprintf(plot_file, \"# unix_time, cycles_done, cur_path, paths_total, \"\n                     \"pending_total, pending_favs, map_size, unique_crashes, \"\n                     \"unique_hangs, max_depth, execs_per_sec\\n\");\n                     /* ignore errors */\n\n}\n\n\n/* Setup the output file for fuzzed data, if not using -f. */\n\nEXP_ST void setup_stdio_file(void) {\n\n  u8* fn = alloc_printf(\"%s/.cur_input\", out_dir);\n\n  unlink(fn); /* Ignore errors */\n\n  out_fd = open(fn, O_RDWR | O_CREAT | O_EXCL, 0600);\n\n  if (out_fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n\n  ck_free(fn);\n\n}\n\n\n/* Make sure that core dumps don't go to a program. */\n\nstatic void check_crash_handling(void) {\n\n#ifdef __APPLE__\n\n  /* Yuck! There appears to be no simple C API to query for the state of \n     loaded daemons on MacOS X, and I'm a bit hesitant to do something\n     more sophisticated, such as disabling crash reporting via Mach ports,\n     until I get a box to test the code. So, for now, we check for crash\n     reporting the awful way. */\n  \n  if (system(\"launchctl list 2>/dev/null | grep -q '\\\\.ReportCrash$'\")) return;\n\n  SAYF(\"\\n\" cLRD \"[-] \" cRST\n       \"Whoops, your system is configured to forward crash notifications to an\\n\"\n       \"    external crash reporting utility. This will cause issues due to the\\n\"\n       \"    extended delay between the fuzzed binary malfunctioning and this fact\\n\"\n       \"    being relayed to the fuzzer via the standard waitpid() API.\\n\\n\"\n       \"    To avoid having crashes misinterpreted as timeouts, please run the\\n\" \n       \"    following commands:\\n\\n\"\n\n       \"    SL=/System/Library; PL=com.apple.ReportCrash\\n\"\n       \"    launchctl unload -w ${SL}/LaunchAgents/${PL}.plist\\n\"\n       \"    sudo launchctl unload -w ${SL}/LaunchDaemons/${PL}.Root.plist\\n\");\n\n  if (!getenv(\"AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES\"))\n    FATAL(\"Crash reporter detected\");\n\n#else\n\n  /* This is Linux specific, but I don't think there's anything equivalent on\n     *BSD, so we can just let it slide for now. */\n\n  s32 fd = open(\"/proc/sys/kernel/core_pattern\", O_RDONLY);\n  u8  fchar;\n\n  if (fd < 0) return;\n\n  ACTF(\"Checking core_pattern...\");\n\n  if (read(fd, &fchar, 1) == 1 && fchar == '|') {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Hmm, your system is configured to send core dump notifications to an\\n\"\n         \"    external utility. This will cause issues: there will be an extended delay\\n\"\n         \"    between stumbling upon a crash and having this information relayed to the\\n\"\n         \"    fuzzer via the standard waitpid() API.\\n\\n\"\n\n         \"    To avoid having crashes misinterpreted as timeouts, please log in as root\\n\" \n         \"    and temporarily modify /proc/sys/kernel/core_pattern, like so:\\n\\n\"\n\n         \"    echo core >/proc/sys/kernel/core_pattern\\n\");\n\n    if (!getenv(\"AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES\"))\n      FATAL(\"Pipe at the beginning of 'core_pattern'\");\n\n  }\n \n  close(fd);\n\n#endif /* ^__APPLE__ */\n\n}\n\n\n/* Check CPU governor. */\n\nstatic void check_cpu_governor(void) {\n\n  FILE* f;\n  u8 tmp[128];\n  u64 min = 0, max = 0;\n\n  if (getenv(\"AFL_SKIP_CPUFREQ\")) return;\n\n  f = fopen(\"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\", \"r\");\n  if (!f) return;\n\n  ACTF(\"Checking CPU scaling governor...\");\n\n  if (!fgets(tmp, 128, f)) PFATAL(\"fgets() failed\");\n\n  fclose(f);\n\n  if (!strncmp(tmp, \"perf\", 4)) return;\n\n  f = fopen(\"/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq\", \"r\");\n\n  if (f) {\n    if (fscanf(f, \"%llu\", &min) != 1) min = 0;\n    fclose(f);\n  }\n\n  f = fopen(\"/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq\", \"r\");\n\n  if (f) {\n    if (fscanf(f, \"%llu\", &max) != 1) max = 0;\n    fclose(f);\n  }\n\n  if (min == max) return;\n\n  SAYF(\"\\n\" cLRD \"[-] \" cRST\n       \"Whoops, your system uses on-demand CPU frequency scaling, adjusted\\n\"\n       \"    between %llu and %llu MHz. Unfortunately, the scaling algorithm in the\\n\"\n       \"    kernel is imperfect and can miss the short-lived processes spawned by\\n\"\n       \"    afl-fuzz. To keep things moving, run these commands as root:\\n\\n\"\n\n       \"    cd /sys/devices/system/cpu\\n\"\n       \"    echo performance | tee cpu*/cpufreq/scaling_governor\\n\\n\"\n\n       \"    You can later go back to the original state by replacing 'performance' with\\n\"\n       \"    'ondemand'. If you don't want to change the settings, set AFL_SKIP_CPUFREQ\\n\"\n       \"    to make afl-fuzz skip this check - but expect some performance drop.\\n\",\n       min / 1024, max / 1024);\n\n  FATAL(\"Suboptimal CPU scaling governor\");\n\n}\n\n\n/* Count the number of logical CPU cores. */\n\nstatic void get_core_count(void) {\n\n  u32 cur_runnable = 0;\n\n#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)\n\n  size_t s = sizeof(cpu_core_count);\n\n  /* On *BSD systems, we can just use a sysctl to get the number of CPUs. */\n\n#ifdef __APPLE__\n\n  if (sysctlbyname(\"hw.logicalcpu\", &cpu_core_count, &s, NULL, 0) < 0)\n    return;\n\n#else\n\n  int s_name[2] = { CTL_HW, HW_NCPU };\n\n  if (sysctl(s_name, 2, &cpu_core_count, &s, NULL, 0) < 0) return;\n\n#endif /* ^__APPLE__ */\n\n#else\n\n#ifdef HAVE_AFFINITY\n\n  cpu_core_count = sysconf(_SC_NPROCESSORS_ONLN);\n\n#else\n\n  FILE* f = fopen(\"/proc/stat\", \"r\");\n  u8 tmp[1024];\n\n  if (!f) return;\n\n  while (fgets(tmp, sizeof(tmp), f))\n    if (!strncmp(tmp, \"cpu\", 3) && isdigit(tmp[3])) cpu_core_count++;\n\n  fclose(f);\n\n#endif /* ^HAVE_AFFINITY */\n\n#endif /* ^(__APPLE__ || __FreeBSD__ || __OpenBSD__) */\n\n  if (cpu_core_count > 0) {\n\n    cur_runnable = (u32)get_runnable_processes();\n\n#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)\n\n    /* Add ourselves, since the 1-minute average doesn't include that yet. */\n\n    cur_runnable++;\n\n#endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */\n\n    OKF(\"You have %u CPU core%s and %u runnable tasks (utilization: %0.0f%%).\",\n        cpu_core_count, cpu_core_count > 1 ? \"s\" : \"\",\n        cur_runnable, cur_runnable * 100.0 / cpu_core_count);\n\n    if (cpu_core_count > 1) {\n\n      if (cur_runnable > cpu_core_count * 1.5) {\n\n        WARNF(\"System under apparent load, performance may be spotty.\");\n\n      } else if (cur_runnable + 1 <= cpu_core_count) {\n\n        OKF(\"Try parallel jobs - see %s/parallel_fuzzing.txt.\", doc_path);\n  \n      }\n\n    }\n\n  } else {\n\n    cpu_core_count = 0;\n    WARNF(\"Unable to figure out the number of CPU cores.\");\n\n  }\n\n}\n\n\n/* Validate and fix up out_dir and sync_dir when using -S. */\n\nstatic void fix_up_sync(void) {\n\n  u8* x = sync_id;\n\n  if (dumb_mode)\n    FATAL(\"-S / -M and -n are mutually exclusive\");\n\n  if (skip_deterministic) {\n\n    if (force_deterministic)\n      FATAL(\"use -S instead of -M -d\");\n    else\n      FATAL(\"-S already implies -d\");\n\n  }\n\n  while (*x) {\n\n    if (!isalnum(*x) && *x != '_' && *x != '-')\n      FATAL(\"Non-alphanumeric fuzzer ID specified via -S or -M\");\n\n    x++;\n\n  }\n\n  if (strlen(sync_id) > 32) FATAL(\"Fuzzer ID too long\");\n\n  x = alloc_printf(\"%s/%s\", out_dir, sync_id);\n\n  sync_dir = out_dir;\n  out_dir  = x;\n\n  if (!force_deterministic) {\n    skip_deterministic = 1;\n    use_splicing = 1;\n  }\n\n}\n\n\n/* Handle screen resize (SIGWINCH). */\n\nstatic void handle_resize(int sig) {\n  clear_screen = 1;\n}\n\n\n/* Check ASAN options. */\n\nstatic void check_asan_opts(void) {\n  u8* x = getenv(\"ASAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"abort_on_error=1\"))\n      FATAL(\"Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!\");\n\n    if (!strstr(x, \"symbolize=0\"))\n      FATAL(\"Custom ASAN_OPTIONS set without symbolize=0 - please fix!\");\n\n  }\n\n  x = getenv(\"MSAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"exit_code=\" STRINGIFY(MSAN_ERROR)))\n      FATAL(\"Custom MSAN_OPTIONS set without exit_code=\"\n            STRINGIFY(MSAN_ERROR) \" - please fix!\");\n\n    if (!strstr(x, \"symbolize=0\"))\n      FATAL(\"Custom MSAN_OPTIONS set without symbolize=0 - please fix!\");\n\n  }\n\n} \n\n\n/* Detect @@ in args. */\n\nEXP_ST void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = getcwd(NULL, 0);\n\n  if (!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if (aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      /* If we don't have a file name chosen yet, use a safe default. */\n\n      if (!out_file)\n        out_file = alloc_printf(\"%s/.cur_input\", out_dir);\n\n      /* Be sure that we're always using fully-qualified paths. */\n\n      if (out_file[0] == '/') aa_subst = out_file;\n      else aa_subst = alloc_printf(\"%s/%s\", cwd, out_file);\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      if (out_file[0] != '/') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Set up signal handlers. More complicated that needs to be, because libc on\n   Solaris doesn't resume interrupted reads(), sets SA_RESETHAND when you call\n   siginterrupt(), and does other unnecessary things. */\n\nEXP_ST void setup_signal_handlers(void) {\n\n  struct sigaction sa;\n\n  sa.sa_handler   = NULL;\n  sa.sa_flags     = SA_RESTART;\n  sa.sa_sigaction = NULL;\n\n  sigemptyset(&sa.sa_mask);\n\n  /* Various ways of saying \"stop\". */\n\n  sa.sa_handler = handle_stop_sig;\n  sigaction(SIGHUP, &sa, NULL);\n  sigaction(SIGINT, &sa, NULL);\n  sigaction(SIGTERM, &sa, NULL);\n\n  /* Exec timeout notifications. */\n\n  sa.sa_handler = handle_timeout;\n  sigaction(SIGALRM, &sa, NULL);\n\n  /* Window resize */\n\n  sa.sa_handler = handle_resize;\n  sigaction(SIGWINCH, &sa, NULL);\n\n  /* SIGUSR1: skip entry */\n\n  sa.sa_handler = handle_skipreq;\n  sigaction(SIGUSR1, &sa, NULL);\n\n  /* Things we don't care about. */\n\n  sa.sa_handler = SIG_IGN;\n  sigaction(SIGTSTP, &sa, NULL);\n  sigaction(SIGPIPE, &sa, NULL);\n\n}\n\n\n/* Rewrite argv for QEMU. */\n\nstatic char** get_qemu_argv(u8* own_loc, char** argv, int argc) {\n\n  char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));\n  u8 *tmp, *cp, *rsl, *own_copy;\n\n  /* Workaround for a QEMU stability glitch. */\n\n  setenv(\"QEMU_LOG\", \"nochain\", 1);\n\n  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);\n\n  new_argv[2] = target_path;\n  new_argv[1] = \"--\";\n\n  /* Now we need to actually find the QEMU binary to put in argv[0]. */\n\n  tmp = getenv(\"AFL_PATH\");\n\n  if (tmp) {\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", tmp);\n\n    if (access(cp, X_OK))\n      FATAL(\"Unable to find '%s'\", tmp);\n\n    target_path = new_argv[0] = cp;\n    return new_argv;\n\n  }\n\n  own_copy = ck_strdup(own_loc);\n  rsl = strrchr(own_copy, '/');\n\n  if (rsl) {\n\n    *rsl = 0;\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", own_copy);\n    ck_free(own_copy);\n\n    if (!access(cp, X_OK)) {\n\n      target_path = new_argv[0] = cp;\n      return new_argv;\n\n    }\n\n  } else ck_free(own_copy);\n\n  if (!access(BIN_PATH \"/afl-qemu-trace\", X_OK)) {\n\n    target_path = new_argv[0] = ck_strdup(BIN_PATH \"/afl-qemu-trace\");\n    return new_argv;\n\n  }\n\n  SAYF(\"\\n\" cLRD \"[-] \" cRST\n       \"Oops, unable to find the 'afl-qemu-trace' binary. The binary must be built\\n\"\n       \"    separately by following the instructions in qemu_mode/README.qemu. If you\\n\"\n       \"    already have the binary installed, you may need to specify AFL_PATH in the\\n\"\n       \"    environment.\\n\\n\"\n\n       \"    Of course, even without QEMU, afl-fuzz can still work with binaries that are\\n\"\n       \"    instrumented at compile time with afl-gcc. It is also possible to use it as a\\n\"\n       \"    traditional \\\"dumb\\\" fuzzer by specifying '-n' in the command line.\\n\");\n\n  FATAL(\"Failed to locate 'afl-qemu-trace'.\");\n\n}\n\n\n/* Make a copy of the current command line. */\n\nstatic void save_cmdline(u32 argc, char** argv) {\n\n  u32 len = 1, i;\n  u8* buf;\n\n  for (i = 0; i < argc; i++)\n    len += strlen(argv[i]) + 1;\n  \n  buf = orig_cmdline = ck_alloc(len);\n\n  for (i = 0; i < argc; i++) {\n\n    u32 l = strlen(argv[i]);\n\n    memcpy(buf, argv[i], l);\n    buf += l;\n\n    if (i != argc - 1) *(buf++) = ' ';\n\n  }\n\n  *buf = 0;\n\n}\n\n\n#ifndef AFL_LIB\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u64 prev_queued = 0;\n  u32 sync_interval_cnt = 0, seek_to;\n  u8  *extras_dir = 0;\n  u8  mem_limit_given = 0;\n  u8  exit_1 = !!getenv(\"AFL_BENCH_JUST_ONE\");\n  char** use_argv;\n\n  struct timeval tv;\n  struct timezone tz;\n\n  SAYF(cCYA \"afl-fuzz \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  doc_path = access(DOC_PATH, F_OK) ? \"docs\" : DOC_PATH;\n\n  gettimeofday(&tv, &tz);\n  srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());\n\n  while ((opt = getopt(argc, argv, \"+i:o:f:m:b:t:T:dnCB:S:M:x:QV\")) > 0)\n\n    switch (opt) {\n\n      case 'i': /* input dir */\n\n        if (in_dir) FATAL(\"Multiple -i options not supported\");\n        in_dir = optarg;\n\n        if (!strcmp(in_dir, \"-\")) in_place_resume = 1;\n\n        break;\n\n      case 'o': /* output dir */\n\n        if (out_dir) FATAL(\"Multiple -o options not supported\");\n        out_dir = optarg;\n        break;\n\n      case 'M': { /* master sync ID */\n\n          u8* c;\n\n          if (sync_id) FATAL(\"Multiple -S or -M options not supported\");\n          sync_id = ck_strdup(optarg);\n\n          if ((c = strchr(sync_id, ':'))) {\n\n            *c = 0;\n\n            if (sscanf(c + 1, \"%u/%u\", &master_id, &master_max) != 2 ||\n                !master_id || !master_max || master_id > master_max ||\n                master_max > 1000000) FATAL(\"Bogus master ID passed to -M\");\n\n          }\n\n          force_deterministic = 1;\n\n        }\n\n        break;\n\n      case 'S': \n\n        if (sync_id) FATAL(\"Multiple -S or -M options not supported\");\n        sync_id = ck_strdup(optarg);\n        break;\n\n      case 'f': /* target file */\n\n        if (out_file) FATAL(\"Multiple -f options not supported\");\n        out_file = optarg;\n        break;\n\n      case 'x': /* dictionary */\n\n        if (extras_dir) FATAL(\"Multiple -x options not supported\");\n        extras_dir = optarg;\n        break;\n\n      case 't': { /* timeout */\n\n          u8 suffix = 0;\n\n          if (timeout_given) FATAL(\"Multiple -t options not supported\");\n\n          if (sscanf(optarg, \"%u%c\", &exec_tmout, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -t\");\n\n          if (exec_tmout < 5) FATAL(\"Dangerously low value of -t\");\n\n          if (suffix == '+') timeout_given = 2; else timeout_given = 1;\n\n          break;\n\n      }\n\n      case 'm': { /* mem limit */\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n          if (sizeof(rlim_t) == 4 && mem_limit > 2000)\n            FATAL(\"Value of -m out of range on 32-bit systems\");\n\n        }\n\n        break;\n      \n      case 'b': { /* bind CPU core */\n\n          if (cpu_to_bind_given) FATAL(\"Multiple -b options not supported\");\n          cpu_to_bind_given = 1;\n\n          if (sscanf(optarg, \"%u\", &cpu_to_bind) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -b\");\n\n          break;\n\n      }\n\n      case 'd': /* skip deterministic */\n\n        if (skip_deterministic) FATAL(\"Multiple -d options not supported\");\n        skip_deterministic = 1;\n        use_splicing = 1;\n        break;\n\n      case 'B': /* load bitmap */\n\n        /* This is a secret undocumented option! It is useful if you find\n           an interesting test case during a normal fuzzing process, and want\n           to mutate it without rediscovering any of the test cases already\n           found during an earlier run.\n\n           To use this mode, you need to point -B to the fuzz_bitmap produced\n           by an earlier run for the exact same binary... and that's it.\n\n           I only used this once or twice to get variants of a particular\n           file, so I'm not making this an official setting. */\n\n        if (in_bitmap) FATAL(\"Multiple -B options not supported\");\n\n        in_bitmap = optarg;\n        read_bitmap(in_bitmap);\n        break;\n\n      case 'C': /* crash mode */\n\n        if (crash_mode) FATAL(\"Multiple -C options not supported\");\n        crash_mode = FAULT_CRASH;\n        break;\n\n      case 'n': /* dumb mode */\n\n        if (dumb_mode) FATAL(\"Multiple -n options not supported\");\n        if (getenv(\"AFL_DUMB_FORKSRV\")) dumb_mode = 2; else dumb_mode = 1;\n\n        break;\n\n      case 'T': /* banner */\n\n        if (use_banner) FATAL(\"Multiple -T options not supported\");\n        use_banner = optarg;\n        break;\n\n      case 'Q': /* QEMU mode */\n\n        if (qemu_mode) FATAL(\"Multiple -Q options not supported\");\n        qemu_mode = 1;\n\n        if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;\n\n        break;\n\n      case 'V': /* Show version number */\n\n        /* Version number has been printed already, just quit. */\n        exit(0);\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if (optind == argc || !in_dir || !out_dir) usage(argv[0]);\n\n  setup_signal_handlers();\n  check_asan_opts();\n\n  if (sync_id) fix_up_sync();\n\n  if (!strcmp(in_dir, out_dir))\n    FATAL(\"Input and output directories can't be the same\");\n\n  if (dumb_mode) {\n\n    if (crash_mode) FATAL(\"-C and -n are mutually exclusive\");\n    if (qemu_mode)  FATAL(\"-Q and -n are mutually exclusive\");\n\n  }\n\n  if (getenv(\"AFL_NO_FORKSRV\"))    no_forkserver    = 1;\n  if (getenv(\"AFL_NO_CPU_RED\"))    no_cpu_meter_red = 1;\n  if (getenv(\"AFL_NO_ARITH\"))      no_arith         = 1;\n  if (getenv(\"AFL_SHUFFLE_QUEUE\")) shuffle_queue    = 1;\n  if (getenv(\"AFL_FAST_CAL\"))      fast_cal         = 1;\n\n  if (getenv(\"AFL_HANG_TMOUT\")) {\n    hang_tmout = atoi(getenv(\"AFL_HANG_TMOUT\"));\n    if (!hang_tmout) FATAL(\"Invalid value of AFL_HANG_TMOUT\");\n  }\n\n  if (dumb_mode == 2 && no_forkserver)\n    FATAL(\"AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive\");\n\n  if (getenv(\"AFL_PRELOAD\")) {\n    setenv(\"LD_PRELOAD\", getenv(\"AFL_PRELOAD\"), 1);\n    setenv(\"DYLD_INSERT_LIBRARIES\", getenv(\"AFL_PRELOAD\"), 1);\n  }\n\n  if (getenv(\"AFL_LD_PRELOAD\"))\n    FATAL(\"Use AFL_PRELOAD instead of AFL_LD_PRELOAD\");\n\n  save_cmdline(argc, argv);\n\n  fix_up_banner(argv[optind]);\n\n  check_if_tty();\n\n  get_core_count();\n\n#ifdef HAVE_AFFINITY\n  bind_to_free_cpu();\n#endif /* HAVE_AFFINITY */\n\n  check_crash_handling();\n  check_cpu_governor();\n\n  setup_post();\n  setup_shm();\n  init_count_class16();\n\n  setup_dirs_fds();\n  read_testcases();\n  load_auto();\n\n  pivot_inputs();\n\n  if (extras_dir) load_extras(extras_dir);\n\n  if (!timeout_given) find_timeout();\n\n  detect_file_args(argv + optind + 1);\n\n  if (!out_file) setup_stdio_file();\n\n  check_binary(argv[optind]);\n\n  start_time = get_cur_time();\n\n  if (qemu_mode)\n    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);\n  else\n    use_argv = argv + optind;\n\n  perform_dry_run(use_argv);\n\n  cull_queue();\n\n  show_init_stats();\n\n  seek_to = find_start_position();\n\n  write_stats_file(0, 0, 0);\n  save_auto();\n\n  if (stop_soon) goto stop_fuzzing;\n\n  /* Woop woop woop */\n\n  if (!not_on_tty) {\n    sleep(4);\n    start_time += 4000;\n    if (stop_soon) goto stop_fuzzing;\n  }\n\n  while (1) {\n\n    u8 skipped_fuzz;\n\n    cull_queue();\n\n    if (!queue_cur) {\n\n      queue_cycle++;\n      current_entry     = 0;\n      cur_skipped_paths = 0;\n      queue_cur         = queue;\n\n      while (seek_to) {\n        current_entry++;\n        seek_to--;\n        queue_cur = queue_cur->next;\n      }\n\n      show_stats();\n\n      if (not_on_tty) {\n        ACTF(\"Entering queue cycle %llu.\", queue_cycle);\n        fflush(stdout);\n      }\n\n      /* If we had a full queue cycle with no new finds, try\n         recombination strategies next. */\n\n      if (queued_paths == prev_queued) {\n\n        if (use_splicing) cycles_wo_finds++; else use_splicing = 1;\n\n      } else cycles_wo_finds = 0;\n\n      prev_queued = queued_paths;\n\n      if (sync_id && queue_cycle == 1 && getenv(\"AFL_IMPORT_FIRST\"))\n        sync_fuzzers(use_argv);\n\n    }\n\n    skipped_fuzz = fuzz_one(use_argv);\n\n    if (!stop_soon && sync_id && !skipped_fuzz) {\n      \n      if (!(sync_interval_cnt++ % SYNC_INTERVAL))\n        sync_fuzzers(use_argv);\n\n    }\n\n    if (!stop_soon && exit_1) stop_soon = 2;\n\n    if (stop_soon) break;\n\n    queue_cur = queue_cur->next;\n    current_entry++;\n\n  }\n\n  if (queue_cur) show_stats();\n\n  /* If we stopped programmatically, we kill the forkserver and the current runner. \n     If we stopped manually, this is done by the signal handler. */\n  if (stop_soon == 2) {\n      if (child_pid > 0) kill(child_pid, SIGKILL);\n      if (forksrv_pid > 0) kill(forksrv_pid, SIGKILL);\n  }\n  /* Now that we've killed the forkserver, we wait for it to be able to get rusage stats. */\n  if (waitpid(forksrv_pid, NULL, 0) <= 0) {\n    WARNF(\"error waitpid\\n\");\n  }\n\n  write_bitmap();\n  write_stats_file(0, 0, 0);\n  save_auto();\n\nstop_fuzzing:\n\n  SAYF(CURSOR_SHOW cLRD \"\\n\\n+++ Testing aborted %s +++\\n\" cRST,\n       stop_soon == 2 ? \"programmatically\" : \"by user\");\n\n  /* Running for more than 30 minutes but still doing first cycle? */\n\n  if (queue_cycle == 1 && get_cur_time() - start_time > 30 * 60 * 1000) {\n\n    SAYF(\"\\n\" cYEL \"[!] \" cRST\n           \"Stopped during the first cycle, results may be incomplete.\\n\"\n           \"    (For info on resuming, see %s/README.)\\n\", doc_path);\n\n  }\n\n  fclose(plot_file);\n  destroy_queue();\n  destroy_extras();\n  ck_free(target_path);\n  ck_free(sync_id);\n\n  alloc_report();\n\n  OKF(\"We're done here. Have a nice day!\\n\");\n\n  exit(0);\n\n}\n\n#endif /* !AFL_LIB */\n"
        },
        {
          "name": "afl-gcc.c",
          "type": "blob",
          "size": 8.6923828125,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - wrapper for GCC and clang\n   ----------------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   This program is a drop-in replacement for GCC or clang. The most common way\n   of using it is to pass the path to afl-gcc or afl-clang via CC when invoking\n   ./configure.\n\n   (Of course, use CXX and point it to afl-g++ / afl-clang++ for C++ code.)\n\n   The wrapper needs to know the path to afl-as (renamed to 'as'). The default\n   is /usr/local/lib/afl/. A convenient way to specify alternative directories\n   would be to set AFL_PATH.\n\n   If AFL_HARDEN is set, the wrapper will compile the target app with various\n   hardening options that may help detect memory management issues more\n   reliably. You can also specify AFL_USE_ASAN to enable ASAN.\n\n   If you want to call a non-default compiler as a next step of the chain,\n   specify its location via AFL_CC or AFL_CXX.\n\n*/\n\n#define AFL_MAIN\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic u8*  as_path;                /* Path to the AFL 'as' wrapper      */\nstatic u8** cc_params;              /* Parameters passed to the real CC  */\nstatic u32  cc_par_cnt = 1;         /* Param count, including argv0      */\nstatic u8   be_quiet,               /* Quiet mode                        */\n            clang_mode;             /* Invoked as afl-clang*?            */\n\n\n/* Try to find our \"fake\" GNU assembler in AFL_PATH or at the location derived\n   from argv[0]. If that fails, abort. */\n\nstatic void find_as(u8* argv0) {\n\n  u8 *afl_path = getenv(\"AFL_PATH\");\n  u8 *slash, *tmp;\n\n  if (afl_path) {\n\n    tmp = alloc_printf(\"%s/as\", afl_path);\n\n    if (!access(tmp, X_OK)) {\n      as_path = afl_path;\n      ck_free(tmp);\n      return;\n    }\n\n    ck_free(tmp);\n\n  }\n\n  slash = strrchr(argv0, '/');\n\n  if (slash) {\n\n    u8 *dir;\n\n    *slash = 0;\n    dir = ck_strdup(argv0);\n    *slash = '/';\n\n    tmp = alloc_printf(\"%s/afl-as\", dir);\n\n    if (!access(tmp, X_OK)) {\n      as_path = dir;\n      ck_free(tmp);\n      return;\n    }\n\n    ck_free(tmp);\n    ck_free(dir);\n\n  }\n\n  if (!access(AFL_PATH \"/as\", X_OK)) {\n    as_path = AFL_PATH;\n    return;\n  }\n\n  FATAL(\"Unable to find AFL wrapper binary for 'as'. Please set AFL_PATH\");\n \n}\n\n\n/* Copy argv to cc_params, making the necessary edits. */\n\nstatic void edit_params(u32 argc, char** argv) {\n\n  u8 fortify_set = 0, asan_set = 0;\n  u8 *name;\n\n#if defined(__FreeBSD__) && defined(__x86_64__)\n  u8 m32_set = 0;\n#endif\n\n  cc_params = ck_alloc((argc + 128) * sizeof(u8*));\n\n  name = strrchr(argv[0], '/');\n  if (!name) name = argv[0]; else name++;\n\n  if (!strncmp(name, \"afl-clang\", 9)) {\n\n    clang_mode = 1;\n\n    setenv(CLANG_ENV_VAR, \"1\", 1);\n\n    if (!strcmp(name, \"afl-clang++\")) {\n      u8* alt_cxx = getenv(\"AFL_CXX\");\n      cc_params[0] = alt_cxx ? alt_cxx : (u8*)\"clang++\";\n    } else {\n      u8* alt_cc = getenv(\"AFL_CC\");\n      cc_params[0] = alt_cc ? alt_cc : (u8*)\"clang\";\n    }\n\n  } else {\n\n    /* With GCJ and Eclipse installed, you can actually compile Java! The\n       instrumentation will work (amazingly). Alas, unhandled exceptions do\n       not call abort(), so afl-fuzz would need to be modified to equate\n       non-zero exit codes with crash conditions when working with Java\n       binaries. Meh. */\n\n#ifdef __APPLE__\n\n    if (!strcmp(name, \"afl-g++\")) cc_params[0] = getenv(\"AFL_CXX\");\n    else if (!strcmp(name, \"afl-gcj\")) cc_params[0] = getenv(\"AFL_GCJ\");\n    else cc_params[0] = getenv(\"AFL_CC\");\n\n    if (!cc_params[0]) {\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"On Apple systems, 'gcc' is usually just a wrapper for clang. Please use the\\n\"\n           \"    'afl-clang' utility instead of 'afl-gcc'. If you really have GCC installed,\\n\"\n           \"    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\\n\");\n\n      FATAL(\"AFL_CC or AFL_CXX required on MacOS X\");\n\n    }\n\n#else\n\n    if (!strcmp(name, \"afl-g++\")) {\n      u8* alt_cxx = getenv(\"AFL_CXX\");\n      cc_params[0] = alt_cxx ? alt_cxx : (u8*)\"g++\";\n    } else if (!strcmp(name, \"afl-gcj\")) {\n      u8* alt_cc = getenv(\"AFL_GCJ\");\n      cc_params[0] = alt_cc ? alt_cc : (u8*)\"gcj\";\n    } else {\n      u8* alt_cc = getenv(\"AFL_CC\");\n      cc_params[0] = alt_cc ? alt_cc : (u8*)\"gcc\";\n    }\n\n#endif /* __APPLE__ */\n\n  }\n\n  while (--argc) {\n    u8* cur = *(++argv);\n\n    if (!strncmp(cur, \"-B\", 2)) {\n\n      if (!be_quiet) WARNF(\"-B is already set, overriding\");\n\n      if (!cur[2] && argc > 1) { argc--; argv++; }\n      continue;\n\n    }\n\n    if (!strcmp(cur, \"-integrated-as\")) continue;\n\n    if (!strcmp(cur, \"-pipe\")) continue;\n\n#if defined(__FreeBSD__) && defined(__x86_64__)\n    if (!strcmp(cur, \"-m32\")) m32_set = 1;\n#endif\n\n    if (!strcmp(cur, \"-fsanitize=address\") ||\n        !strcmp(cur, \"-fsanitize=memory\")) asan_set = 1;\n\n    if (strstr(cur, \"FORTIFY_SOURCE\")) fortify_set = 1;\n\n    cc_params[cc_par_cnt++] = cur;\n\n  }\n\n  cc_params[cc_par_cnt++] = \"-B\";\n  cc_params[cc_par_cnt++] = as_path;\n\n  if (clang_mode)\n    cc_params[cc_par_cnt++] = \"-no-integrated-as\";\n\n  if (getenv(\"AFL_HARDEN\")) {\n\n    cc_params[cc_par_cnt++] = \"-fstack-protector-all\";\n\n    if (!fortify_set)\n      cc_params[cc_par_cnt++] = \"-D_FORTIFY_SOURCE=2\";\n\n  }\n\n  if (asan_set) {\n\n    /* Pass this on to afl-as to adjust map density. */\n\n    setenv(\"AFL_USE_ASAN\", \"1\", 1);\n\n  } else if (getenv(\"AFL_USE_ASAN\")) {\n\n    if (getenv(\"AFL_USE_MSAN\"))\n      FATAL(\"ASAN and MSAN are mutually exclusive\");\n\n    if (getenv(\"AFL_HARDEN\"))\n      FATAL(\"ASAN and AFL_HARDEN are mutually exclusive\");\n\n    cc_params[cc_par_cnt++] = \"-U_FORTIFY_SOURCE\";\n    cc_params[cc_par_cnt++] = \"-fsanitize=address\";\n\n  } else if (getenv(\"AFL_USE_MSAN\")) {\n\n    if (getenv(\"AFL_USE_ASAN\"))\n      FATAL(\"ASAN and MSAN are mutually exclusive\");\n\n    if (getenv(\"AFL_HARDEN\"))\n      FATAL(\"MSAN and AFL_HARDEN are mutually exclusive\");\n\n    cc_params[cc_par_cnt++] = \"-U_FORTIFY_SOURCE\";\n    cc_params[cc_par_cnt++] = \"-fsanitize=memory\";\n\n\n  }\n\n  if (!getenv(\"AFL_DONT_OPTIMIZE\")) {\n\n#if defined(__FreeBSD__) && defined(__x86_64__)\n\n    /* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself\n       works OK. This has nothing to do with us, but let's avoid triggering\n       that bug. */\n\n    if (!clang_mode || !m32_set)\n      cc_params[cc_par_cnt++] = \"-g\";\n\n#else\n\n      cc_params[cc_par_cnt++] = \"-g\";\n\n#endif\n\n    cc_params[cc_par_cnt++] = \"-O3\";\n    cc_params[cc_par_cnt++] = \"-funroll-loops\";\n\n    /* Two indicators that you're building for fuzzing; one of them is\n       AFL-specific, the other is shared with libfuzzer. */\n\n    cc_params[cc_par_cnt++] = \"-D__AFL_COMPILER=1\";\n    cc_params[cc_par_cnt++] = \"-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1\";\n\n  }\n\n  if (getenv(\"AFL_NO_BUILTIN\")) {\n\n    cc_params[cc_par_cnt++] = \"-fno-builtin-strcmp\";\n    cc_params[cc_par_cnt++] = \"-fno-builtin-strncmp\";\n    cc_params[cc_par_cnt++] = \"-fno-builtin-strcasecmp\";\n    cc_params[cc_par_cnt++] = \"-fno-builtin-strncasecmp\";\n    cc_params[cc_par_cnt++] = \"-fno-builtin-memcmp\";\n    cc_params[cc_par_cnt++] = \"-fno-builtin-strstr\";\n    cc_params[cc_par_cnt++] = \"-fno-builtin-strcasestr\";\n\n  }\n\n  cc_params[cc_par_cnt] = NULL;\n\n}\n\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  if (isatty(2) && !getenv(\"AFL_QUIET\")) {\n\n    SAYF(cCYA \"afl-cc \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  } else be_quiet = 1;\n\n  if (argc < 2) {\n\n    SAYF(\"\\n\"\n         \"This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n\"\n         \"for gcc or clang, letting you recompile third-party code with the required\\n\"\n         \"runtime instrumentation. A common use pattern would be one of the following:\\n\\n\"\n\n         \"  CC=%s/afl-gcc ./configure\\n\"\n         \"  CXX=%s/afl-g++ ./configure\\n\\n\"\n\n         \"You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n\"\n         \"Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n\",\n         BIN_PATH, BIN_PATH);\n\n    exit(1);\n\n  }\n\n  find_as(argv[0]);\n\n  edit_params(argc, argv);\n\n  execvp(cc_params[0], (char**)cc_params);\n\n  FATAL(\"Oops, failed to execute '%s' - check your PATH\", cc_params[0]);\n\n  return 0;\n\n}\n"
        },
        {
          "name": "afl-gotcpu.c",
          "type": "blob",
          "size": 5.57421875,
          "content": "/*\n  Copyright 2015 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - free CPU gizmo\n   -----------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   This tool provides a fairly accurate measurement of CPU preemption rate.\n   It is meant to complement the quick-and-dirty load average widget shown\n   in the afl-fuzz UI. See docs/parallel_fuzzing.txt for more info.\n\n   For some work loads, the tool may actually suggest running more instances\n   than you have CPU cores. This can happen if the tested program is spending\n   a portion of its run time waiting for I/O, rather than being 100%\n   CPU-bound.\n\n   The idea for the getrusage()-based approach comes from Jakub Wilk.\n*/\n\n#define AFL_MAIN\n#include \"android-ashmem.h\"\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sched.h>\n\n#include <sys/time.h>\n#include <sys/times.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n\n#include \"types.h\"\n#include \"debug.h\"\n\n#ifdef __linux__\n#  define HAVE_AFFINITY 1\n#endif /* __linux__ */\n\n\n/* Get unix time in microseconds. */\n\nstatic u64 get_cur_time_us(void) {\n\n  struct timeval tv;\n  struct timezone tz;\n\n  gettimeofday(&tv, &tz);\n\n  return (tv.tv_sec * 1000000ULL) + tv.tv_usec;\n\n}\n\n\n/* Get CPU usage in microseconds. */\n\nstatic u64 get_cpu_usage_us(void) {\n\n  struct rusage u;\n\n  getrusage(RUSAGE_SELF, &u);\n\n  return (u.ru_utime.tv_sec * 1000000ULL) + u.ru_utime.tv_usec +\n         (u.ru_stime.tv_sec * 1000000ULL) + u.ru_stime.tv_usec;\n\n}\n\n\n/* Measure preemption rate. */\n\nstatic u32 measure_preemption(u32 target_ms) {\n\n  static volatile u32 v1, v2;\n\n  u64 st_t, en_t, st_c, en_c, real_delta, slice_delta;\n  s32 loop_repeats = 0;\n\n  st_t = get_cur_time_us();\n  st_c = get_cpu_usage_us();\n\nrepeat_loop:\n\n  v1 = CTEST_BUSY_CYCLES;\n\n  while (v1--) v2++;\n  sched_yield();\n\n  en_t = get_cur_time_us();\n\n  if (en_t - st_t < target_ms * 1000) {\n    loop_repeats++;\n    goto repeat_loop;\n  }\n\n  /* Let's see what percentage of this time we actually had a chance to\n     run, and how much time was spent in the penalty box. */\n\n  en_c = get_cpu_usage_us();\n\n  real_delta  = (en_t - st_t) / 1000;\n  slice_delta = (en_c - st_c) / 1000;\n\n  return real_delta * 100 / slice_delta;\n\n}\n\n\n/* Do the benchmark thing. */\n\nint main(int argc, char** argv) {\n\n#ifdef HAVE_AFFINITY\n\n  u32 cpu_cnt = sysconf(_SC_NPROCESSORS_ONLN),\n      idle_cpus = 0, maybe_cpus = 0, i;\n\n  SAYF(cCYA \"afl-gotcpu \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  ACTF(\"Measuring per-core preemption rate (this will take %0.02f sec)...\",\n       ((double)CTEST_CORE_TRG_MS) / 1000);\n\n  for (i = 0; i < cpu_cnt; i++) {\n\n    s32 fr = fork();\n\n    if (fr < 0) PFATAL(\"fork failed\");\n\n    if (!fr) {\n\n      cpu_set_t c;\n      u32 util_perc;\n\n      CPU_ZERO(&c);\n      CPU_SET(i, &c);\n\n      if (sched_setaffinity(0, sizeof(c), &c))\n        PFATAL(\"sched_setaffinity failed for cpu %d\", i);\n\n      util_perc = measure_preemption(CTEST_CORE_TRG_MS);\n\n      if (util_perc < 110) {\n\n        SAYF(\"    Core #%u: \" cLGN \"AVAILABLE \" cRST \"(%u%%)\\n\", i, util_perc);\n        exit(0);\n\n      } else if (util_perc < 250) {\n\n        SAYF(\"    Core #%u: \" cYEL \"CAUTION \" cRST \"(%u%%)\\n\", i, util_perc); \n        exit(1);\n\n      }\n\n      SAYF(\"    Core #%u: \" cLRD \"OVERBOOKED \" cRST \"(%u%%)\\n\" cRST, i,\n           util_perc);\n      exit(2);\n\n    }\n\n  }\n\n  for (i = 0; i < cpu_cnt; i++) {\n\n    int ret;\n    if (waitpid(-1, &ret, 0) < 0) PFATAL(\"waitpid failed\");\n\n    if (WEXITSTATUS(ret) == 0) idle_cpus++;\n    if (WEXITSTATUS(ret) <= 1) maybe_cpus++;\n\n  }\n\n  SAYF(cGRA \"\\n>>> \");\n\n  if (idle_cpus) {\n\n    if (maybe_cpus == idle_cpus) {\n\n      SAYF(cLGN \"PASS: \" cRST \"You can run more processes on %u core%s.\",\n           idle_cpus, idle_cpus > 1 ? \"s\" : \"\");\n\n    } else {\n\n      SAYF(cLGN \"PASS: \" cRST \"You can run more processes on %u to %u core%s.\",\n           idle_cpus, maybe_cpus, maybe_cpus > 1 ? \"s\" : \"\");\n\n    }\n\n    SAYF(cGRA \" <<<\" cRST \"\\n\\n\");\n    return 0;\n\n  }\n\n  if (maybe_cpus) {\n\n    SAYF(cYEL \"CAUTION: \" cRST \"You may still have %u core%s available.\",\n         maybe_cpus, maybe_cpus > 1 ? \"s\" : \"\");\n    SAYF(cGRA \" <<<\" cRST \"\\n\\n\");\n    return 1;\n\n  }\n\n  SAYF(cLRD \"FAIL: \" cRST \"All cores are overbooked.\");\n  SAYF(cGRA \" <<<\" cRST \"\\n\\n\");\n  return 2;\n\n#else\n\n  u32 util_perc;\n\n  SAYF(cCYA \"afl-gotcpu \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  /* Run a busy loop for CTEST_TARGET_MS. */\n\n  ACTF(\"Measuring gross preemption rate (this will take %0.02f sec)...\",\n       ((double)CTEST_TARGET_MS) / 1000);\n\n  util_perc = measure_preemption(CTEST_TARGET_MS);\n\n  /* Deliver the final verdict. */\n\n  SAYF(cGRA \"\\n>>> \");\n\n  if (util_perc < 105) {\n\n    SAYF(cLGN \"PASS: \" cRST \"You can probably run additional processes.\");\n\n  } else if (util_perc < 130) {\n\n    SAYF(cYEL \"CAUTION: \" cRST \"Your CPU may be somewhat overbooked (%u%%).\",\n         util_perc);\n\n  } else {\n\n    SAYF(cLRD \"FAIL: \" cRST \"Your CPU is overbooked (%u%%).\", util_perc);\n\n  }\n\n  SAYF(cGRA \" <<<\" cRST \"\\n\\n\");\n\n  return (util_perc > 105) + (util_perc > 130);\n\n#endif /* ^HAVE_AFFINITY */\n\n}\n"
        },
        {
          "name": "afl-plot",
          "type": "blob",
          "size": 4.796875,
          "content": "#!/bin/sh\n#\n# american fuzzy lop - Advanced Persistent Graphing\n# -------------------------------------------------\n#\n# Written and maintained by Michal Zalewski <lcamtuf@google.com>\n# Based on a design & prototype by Michael Rash.\n#\n# Copyright 2014, 2015 Google LLC All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n\necho \"progress plotting utility for afl-fuzz by <lcamtuf@google.com>\"\necho\n\nif [ ! \"$#\" = \"2\" ]; then\n\n  cat 1>&2 <<_EOF_\nThis program generates gnuplot images from afl-fuzz output data. Usage:\n\n$0 afl_state_dir graph_output_dir\n\nThe afl_state_dir parameter should point to an existing state directory for any\nactive or stopped instance of afl-fuzz; while graph_output_dir should point to\nan empty directory where this tool can write the resulting plots to.\n\nThe program will put index.html and three PNG images in the output directory;\nyou should be able to view it with any web browser of your choice.\n\n_EOF_\n\n  exit 1\n\nfi\n\nif [ \"$AFL_ALLOW_TMP\" = \"\" ]; then\n\n  echo \"$1\" | grep -qE '^(/var)?/tmp/'\n  T1=\"$?\"\n\n  echo \"$2\" | grep -qE '^(/var)?/tmp/'\n  T2=\"$?\"\n\n  if [ \"$T1\" = \"0\" -o \"$T2\" = \"0\" ]; then\n\n    echo \"[-] Error: this script shouldn't be used with shared /tmp directories.\" 1>&2\n    exit 1\n\n  fi\n\nfi\n\nif [ ! -f \"$1/plot_data\" ]; then\n\n  echo \"[-] Error: input directory is not valid (missing 'plot_data').\" 1>&2\n  exit 1\n\nfi\n\nBANNER=\"`cat \"$1/fuzzer_stats\" | grep '^afl_banner ' | cut -d: -f2- | cut -b2-`\"\n\ntest \"$BANNER\" = \"\" && BANNER=\"(none)\"\n\nGNUPLOT=`which gnuplot 2>/dev/null`\n\nif [ \"$GNUPLOT\" = \"\" ]; then\n\n  echo \"[-] Error: can't find 'gnuplot' in your \\$PATH.\" 1>&2\n  exit 1\n\nfi\n\nmkdir \"$2\" 2>/dev/null\n\nif [ ! -d \"$2\" ]; then\n\n  echo \"[-] Error: unable to create the output directory - pick another location.\" 1>&2\n  exit 1\n\nfi\n\nrm -f \"$2/high_freq.png\" \"$2/low_freq.png\" \"$2/exec_speed.png\"\nmv -f \"$2/index.html\" \"$2/index.html.orig\" 2>/dev/null\n\necho \"[*] Generating plots...\"\n\n(\n\ncat <<_EOF_\nset terminal png truecolor enhanced size 1000,300 butt\n\nset output '$2/high_freq.png'\n\nset xdata time\nset timefmt '%s'\nset format x \"%b %d\\n%H:%M\"\nset tics font 'small'\nunset mxtics\nunset mytics\n\nset grid xtics linetype 0 linecolor rgb '#e0e0e0'\nset grid ytics linetype 0 linecolor rgb '#e0e0e0'\nset border linecolor rgb '#50c0f0'\nset tics textcolor rgb '#000000'\nset key outside\n\nset autoscale xfixmin\nset autoscale xfixmax\n\nplot '$1/plot_data' using 1:4 with filledcurve x1 title 'total paths' linecolor rgb '#000000' fillstyle transparent solid 0.2 noborder, \\\\\n     '' using 1:3 with filledcurve x1 title 'current path' linecolor rgb '#f0f0f0' fillstyle transparent solid 0.5 noborder, \\\\\n     '' using 1:5 with lines title 'pending paths' linecolor rgb '#0090ff' linewidth 3, \\\\\n     '' using 1:6 with lines title 'pending favs' linecolor rgb '#c00080' linewidth 3, \\\\\n     '' using 1:2 with lines title 'cycles done' linecolor rgb '#c000f0' linewidth 3\n\nset terminal png truecolor enhanced size 1000,200 butt\nset output '$2/low_freq.png'\n\nplot '$1/plot_data' using 1:8 with filledcurve x1 title '' linecolor rgb '#c00080' fillstyle transparent solid 0.2 noborder, \\\\\n     '' using 1:8 with lines title ' uniq crashes' linecolor rgb '#c00080' linewidth 3, \\\\\n     '' using 1:9 with lines title 'uniq hangs' linecolor rgb '#c000f0' linewidth 3, \\\\\n     '' using 1:10 with lines title 'levels' linecolor rgb '#0090ff' linewidth 3\n\nset terminal png truecolor enhanced size 1000,200 butt\nset output '$2/exec_speed.png'\n\nplot '$1/plot_data' using 1:11 with filledcurve x1 title '' linecolor rgb '#0090ff' fillstyle transparent solid 0.2 noborder, \\\\\n     '$1/plot_data' using 1:11 with lines title '    execs/sec' linecolor rgb '#0090ff' linewidth 3 smooth bezier;\n\n_EOF_\n\n) | gnuplot \n\nif [ ! -s \"$2/exec_speed.png\" ]; then\n\n  echo \"[-] Error: something went wrong! Perhaps you have an ancient version of gnuplot?\" 1>&2\n  exit 1\n\nfi\n\necho \"[*] Generating index.html...\"\n\ncat >\"$2/index.html\" <<_EOF_\n<table style=\"font-family: 'Trebuchet MS', 'Tahoma', 'Arial', 'Helvetica'\">\n<tr><td style=\"width: 18ex\"><b>Banner:</b></td><td>$BANNER</td></tr>\n<tr><td><b>Directory:</b></td><td>$1</td></tr>\n<tr><td><b>Generated on:</b></td><td>`date`</td></tr>\n</table>\n<p>\n<img src=\"high_freq.png\" width=1000 height=300><p>\n<img src=\"low_freq.png\" width=1000 height=200><p>\n<img src=\"exec_speed.png\" width=1000 height=200>\n\n_EOF_\n\n# Make it easy to remotely view results when outputting directly to a directory\n# served by Apache or other HTTP daemon. Since the plots aren't horribly\n# sensitive, this seems like a reasonable trade-off.\n\nchmod 755 \"$2\"\nchmod 644 \"$2/high_freq.png\" \"$2/low_freq.png\" \"$2/exec_speed.png\" \"$2/index.html\"\n\necho \"[+] All done - enjoy your charts!\"\n\nexit 0\n"
        },
        {
          "name": "afl-showmap.c",
          "type": "blob",
          "size": 16.578125,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - map display utility\n   ----------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   A very simple tool that runs the targeted binary and displays\n   the contents of the trace bitmap in a human-readable form. Useful in\n   scripts to eliminate redundant inputs and perform other checks.\n\n   Exit code is 2 if the target program crashes; 1 if it times out or\n   there is a problem executing it; or 0 if execution is successful.\n*/\n\n#define AFL_MAIN\n#include \"android-ashmem.h\"\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <dirent.h>\n#include <fcntl.h>\n\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/shm.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n\nstatic s32 child_pid;                 /* PID of the tested program         */\n\nstatic u8* trace_bits;                /* SHM with instrumentation bitmap   */\n\nstatic u8 *out_file,                  /* Trace output file                 */\n          *doc_path,                  /* Path to docs                      */\n          *target_path,               /* Path to target binary             */\n          *at_file;                   /* Substitution string for @@        */\n\nstatic u32 exec_tmout;                /* Exec timeout (ms)                 */\n\nstatic u64 mem_limit = MEM_LIMIT;     /* Memory limit (MB)                 */\n\nstatic s32 shm_id;                    /* ID of the SHM region              */\n\nstatic u8  quiet_mode,                /* Hide non-essential messages?      */\n           edges_only,                /* Ignore hit counts?                */\n           cmin_mode,                 /* Generate output in afl-cmin mode? */\n           binary_mode,               /* Write output as a binary map      */\n           keep_cores;                /* Allow coredumps?                  */\n\nstatic volatile u8\n           stop_soon,                 /* Ctrl-C pressed?                   */\n           child_timed_out,           /* Child timed out?                  */\n           child_crashed;             /* Child crashed?                    */\n\n/* Classify tuple counts. Instead of mapping to individual bits, as in\n   afl-fuzz.c, we map to more user-friendly numbers between 1 and 8. */\n\nstatic const u8 count_class_human[256] = {\n\n  [0]           = 0,\n  [1]           = 1,\n  [2]           = 2,\n  [3]           = 3,\n  [4 ... 7]     = 4,\n  [8 ... 15]    = 5,\n  [16 ... 31]   = 6,\n  [32 ... 127]  = 7,\n  [128 ... 255] = 8\n\n};\n\nstatic const u8 count_class_binary[256] = {\n\n  [0]           = 0,\n  [1]           = 1,\n  [2]           = 2,\n  [3]           = 4,\n  [4 ... 7]     = 8,\n  [8 ... 15]    = 16,\n  [16 ... 31]   = 32,\n  [32 ... 127]  = 64,\n  [128 ... 255] = 128\n\n};\n\nstatic void classify_counts(u8* mem, const u8* map) {\n\n  u32 i = MAP_SIZE;\n\n  if (edges_only) {\n\n    while (i--) {\n      if (*mem) *mem = 1;\n      mem++;\n    }\n\n  } else {\n\n    while (i--) {\n      *mem = map[*mem];\n      mem++;\n    }\n\n  }\n\n}\n\n\n/* Get rid of shared memory (atexit handler). */\n\nstatic void remove_shm(void) {\n\n  shmctl(shm_id, IPC_RMID, NULL);\n\n}\n\n\n/* Configure shared memory. */\n\nstatic void setup_shm(void) {\n\n  u8* shm_str;\n\n  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);\n\n  if (shm_id < 0) PFATAL(\"shmget() failed\");\n\n  atexit(remove_shm);\n\n  shm_str = alloc_printf(\"%d\", shm_id);\n\n  setenv(SHM_ENV_VAR, shm_str, 1);\n\n  ck_free(shm_str);\n\n  trace_bits = shmat(shm_id, NULL, 0);\n  \n  if (trace_bits == (void *)-1) PFATAL(\"shmat() failed\");\n\n}\n\n/* Write results. */\n\nstatic u32 write_results(void) {\n\n  s32 fd;\n  u32 i, ret = 0;\n\n  u8  cco = !!getenv(\"AFL_CMIN_CRASHES_ONLY\"),\n      caa = !!getenv(\"AFL_CMIN_ALLOW_ANY\");\n\n  if (!strncmp(out_file, \"/dev/\", 5)) {\n\n    fd = open(out_file, O_WRONLY, 0600);\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", out_file);\n\n  } else if (!strcmp(out_file, \"-\")) {\n\n    fd = dup(1);\n    if (fd < 0) PFATAL(\"Unable to open stdout\");\n\n  } else {\n\n    unlink(out_file); /* Ignore errors */\n    fd = open(out_file, O_WRONLY | O_CREAT | O_EXCL, 0600);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", out_file);\n\n  }\n\n\n  if (binary_mode) {\n\n    for (i = 0; i < MAP_SIZE; i++)\n      if (trace_bits[i]) ret++;\n    \n    ck_write(fd, trace_bits, MAP_SIZE, out_file);\n    close(fd);\n\n  } else {\n\n    FILE* f = fdopen(fd, \"w\");\n\n    if (!f) PFATAL(\"fdopen() failed\");\n\n    for (i = 0; i < MAP_SIZE; i++) {\n\n      if (!trace_bits[i]) continue;\n      ret++;\n\n      if (cmin_mode) {\n\n        if (child_timed_out) break;\n        if (!caa && child_crashed != cco) break;\n\n        fprintf(f, \"%u%u\\n\", trace_bits[i], i);\n\n      } else fprintf(f, \"%06u:%u\\n\", i, trace_bits[i]);\n\n    }\n  \n    fclose(f);\n\n  }\n\n  return ret;\n\n}\n\n\n/* Handle timeout signal. */\n\nstatic void handle_timeout(int sig) {\n\n  child_timed_out = 1;\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}\n\n\n/* Execute target application. */\n\nstatic void run_target(char** argv) {\n\n  static struct itimerval it;\n  int status = 0;\n\n  if (!quiet_mode)\n    SAYF(\"-- Program output begins --\\n\" cRST);\n\n  MEM_BARRIER();\n\n  child_pid = fork();\n\n  if (child_pid < 0) PFATAL(\"fork() failed\");\n\n  if (!child_pid) {\n\n    struct rlimit r;\n\n    if (quiet_mode) {\n\n      s32 fd = open(\"/dev/null\", O_RDWR);\n\n      if (fd < 0 || dup2(fd, 1) < 0 || dup2(fd, 2) < 0) {\n        *(u32*)trace_bits = EXEC_FAIL_SIG;\n        PFATAL(\"Descriptor initialization failed\");\n      }\n\n      close(fd);\n\n    }\n\n    if (mem_limit) {\n\n      r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;\n\n#ifdef RLIMIT_AS\n\n      setrlimit(RLIMIT_AS, &r); /* Ignore errors */\n\n#else\n\n      setrlimit(RLIMIT_DATA, &r); /* Ignore errors */\n\n#endif /* ^RLIMIT_AS */\n\n    }\n\n    if (!keep_cores) r.rlim_max = r.rlim_cur = 0;\n    else r.rlim_max = r.rlim_cur = RLIM_INFINITY;\n\n    setrlimit(RLIMIT_CORE, &r); /* Ignore errors */\n\n    if (!getenv(\"LD_BIND_LAZY\")) setenv(\"LD_BIND_NOW\", \"1\", 0);\n\n    setsid();\n\n    execv(target_path, argv);\n\n    *(u32*)trace_bits = EXEC_FAIL_SIG;\n    exit(0);\n\n  }\n\n  /* Configure timeout, wait for child, cancel timeout. */\n\n  if (exec_tmout) {\n\n    child_timed_out = 0;\n    it.it_value.tv_sec = (exec_tmout / 1000);\n    it.it_value.tv_usec = (exec_tmout % 1000) * 1000;\n\n  }\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  if (waitpid(child_pid, &status, 0) <= 0) FATAL(\"waitpid() failed\");\n\n  child_pid = 0;\n  it.it_value.tv_sec = 0;\n  it.it_value.tv_usec = 0;\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  MEM_BARRIER();\n\n  /* Clean up bitmap, analyze exit condition, etc. */\n\n  if (*(u32*)trace_bits == EXEC_FAIL_SIG)\n    FATAL(\"Unable to execute '%s'\", argv[0]);\n\n  classify_counts(trace_bits, binary_mode ?\n                  count_class_binary : count_class_human);\n\n  if (!quiet_mode)\n    SAYF(cRST \"-- Program output ends --\\n\");\n\n  if (!child_timed_out && !stop_soon && WIFSIGNALED(status))\n    child_crashed = 1;\n\n  if (!quiet_mode) {\n\n    if (child_timed_out)\n      SAYF(cLRD \"\\n+++ Program timed off +++\\n\" cRST);\n    else if (stop_soon)\n      SAYF(cLRD \"\\n+++ Program aborted by user +++\\n\" cRST);\n    else if (child_crashed)\n      SAYF(cLRD \"\\n+++ Program killed by signal %u +++\\n\" cRST, WTERMSIG(status));\n\n  }\n\n\n}\n\n\n/* Handle Ctrl-C and the like. */\n\nstatic void handle_stop_sig(int sig) {\n\n  stop_soon = 1;\n\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}\n\n\n/* Do basic preparations - persistent fds, filenames, etc. */\n\nstatic void set_up_environment(void) {\n\n  setenv(\"ASAN_OPTIONS\", \"abort_on_error=1:\"\n                         \"detect_leaks=0:\"\n                         \"symbolize=0:\"\n                         \"allocator_may_return_null=1\", 0);\n\n  setenv(\"MSAN_OPTIONS\", \"exit_code=\" STRINGIFY(MSAN_ERROR) \":\"\n                         \"symbolize=0:\"\n                         \"abort_on_error=1:\"\n                         \"allocator_may_return_null=1:\"\n                         \"msan_track_origins=0\", 0);\n\n  if (getenv(\"AFL_PRELOAD\")) {\n    setenv(\"LD_PRELOAD\", getenv(\"AFL_PRELOAD\"), 1);\n    setenv(\"DYLD_INSERT_LIBRARIES\", getenv(\"AFL_PRELOAD\"), 1);\n  }\n\n}\n\n\n/* Setup signal handlers, duh. */\n\nstatic void setup_signal_handlers(void) {\n\n  struct sigaction sa;\n\n  sa.sa_handler   = NULL;\n  sa.sa_flags     = SA_RESTART;\n  sa.sa_sigaction = NULL;\n\n  sigemptyset(&sa.sa_mask);\n\n  /* Various ways of saying \"stop\". */\n\n  sa.sa_handler = handle_stop_sig;\n  sigaction(SIGHUP, &sa, NULL);\n  sigaction(SIGINT, &sa, NULL);\n  sigaction(SIGTERM, &sa, NULL);\n\n  /* Exec timeout notifications. */\n\n  sa.sa_handler = handle_timeout;\n  sigaction(SIGALRM, &sa, NULL);\n\n}\n\n\n/* Detect @@ in args. */\n\nstatic void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = getcwd(NULL, 0);\n\n  if (!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if (aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      if (!at_file) FATAL(\"@@ syntax is not supported by this tool.\");\n\n      /* Be sure that we're always using fully-qualified paths. */\n\n      if (at_file[0] == '/') aa_subst = at_file;\n      else aa_subst = alloc_printf(\"%s/%s\", cwd, at_file);\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      if (at_file[0] != '/') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Show banner. */\n\nstatic void show_banner(void) {\n\n  SAYF(cCYA \"afl-showmap \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n}\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  show_banner();\n\n  SAYF(\"\\n%s [ options ] -- /path/to/target_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -o file       - file to write the trace data to\\n\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -t msec       - timeout for each run (none)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n       \"  -Q            - use binary-only instrumentation (QEMU mode)\\n\\n\"\n\n       \"Other settings:\\n\\n\"\n\n       \"  -q            - sink program's output and don't show messages\\n\"\n       \"  -e            - show edge coverage only, ignore hit counts\\n\"\n       \"  -c            - allow core dumps\\n\"\n       \"  -V            - show version number and exit\\n\\n\"\n\n       \"This tool displays raw tuple data captured by AFL instrumentation.\\n\"\n       \"For additional help, consult %s/README.\\n\\n\" cRST,\n\n       argv0, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Find binary. */\n\nstatic void find_binary(u8* fname) {\n\n  u8* env_path = 0;\n  struct stat st;\n\n  if (strchr(fname, '/') || !(env_path = getenv(\"PATH\"))) {\n\n    target_path = ck_strdup(fname);\n\n    if (stat(target_path, &st) || !S_ISREG(st.st_mode) ||\n        !(st.st_mode & 0111) || st.st_size < 4)\n      FATAL(\"Program '%s' not found or not executable\", fname);\n\n  } else {\n\n    while (env_path) {\n\n      u8 *cur_elem, *delim = strchr(env_path, ':');\n\n      if (delim) {\n\n        cur_elem = ck_alloc(delim - env_path + 1);\n        memcpy(cur_elem, env_path, delim - env_path);\n        delim++;\n\n      } else cur_elem = ck_strdup(env_path);\n\n      env_path = delim;\n\n      if (cur_elem[0])\n        target_path = alloc_printf(\"%s/%s\", cur_elem, fname);\n      else\n        target_path = ck_strdup(fname);\n\n      ck_free(cur_elem);\n\n      if (!stat(target_path, &st) && S_ISREG(st.st_mode) &&\n          (st.st_mode & 0111) && st.st_size >= 4) break;\n\n      ck_free(target_path);\n      target_path = 0;\n\n    }\n\n    if (!target_path) FATAL(\"Program '%s' not found or not executable\", fname);\n\n  }\n\n}\n\n\n/* Fix up argv for QEMU. */\n\nstatic char** get_qemu_argv(u8* own_loc, char** argv, int argc) {\n\n  char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));\n  u8 *tmp, *cp, *rsl, *own_copy;\n\n  /* Workaround for a QEMU stability glitch. */\n\n  setenv(\"QEMU_LOG\", \"nochain\", 1);\n\n  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);\n\n  new_argv[2] = target_path;\n  new_argv[1] = \"--\";\n\n  /* Now we need to actually find qemu for argv[0]. */\n\n  tmp = getenv(\"AFL_PATH\");\n\n  if (tmp) {\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", tmp);\n\n    if (access(cp, X_OK))\n      FATAL(\"Unable to find '%s'\", tmp);\n\n    target_path = new_argv[0] = cp;\n    return new_argv;\n\n  }\n\n  own_copy = ck_strdup(own_loc);\n  rsl = strrchr(own_copy, '/');\n\n  if (rsl) {\n\n    *rsl = 0;\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", own_copy);\n    ck_free(own_copy);\n\n    if (!access(cp, X_OK)) {\n\n      target_path = new_argv[0] = cp;\n      return new_argv;\n\n    }\n\n  } else ck_free(own_copy);\n\n  if (!access(BIN_PATH \"/afl-qemu-trace\", X_OK)) {\n\n    target_path = new_argv[0] = BIN_PATH \"/afl-qemu-trace\";\n    return new_argv;\n\n  }\n\n  FATAL(\"Unable to find 'afl-qemu-trace'.\");\n\n}\n\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;\n  u32 tcnt;\n  char** use_argv;\n\n  doc_path = access(DOC_PATH, F_OK) ? \"docs\" : DOC_PATH;\n\n  while ((opt = getopt(argc,argv,\"+o:m:t:A:eqZQbcV\")) > 0)\n\n    switch (opt) {\n\n      case 'o':\n\n        if (out_file) FATAL(\"Multiple -o options not supported\");\n        out_file = optarg;\n        break;\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n          if (sizeof(rlim_t) == 4 && mem_limit > 2000)\n            FATAL(\"Value of -m out of range on 32-bit systems\");\n\n        }\n\n        break;\n\n      case 't':\n\n        if (timeout_given) FATAL(\"Multiple -t options not supported\");\n        timeout_given = 1;\n\n        if (strcmp(optarg, \"none\")) {\n          exec_tmout = atoi(optarg);\n\n          if (exec_tmout < 20 || optarg[0] == '-')\n            FATAL(\"Dangerously low value of -t\");\n\n        }\n\n        break;\n\n      case 'e':\n\n        if (edges_only) FATAL(\"Multiple -e options not supported\");\n        edges_only = 1;\n        break;\n\n      case 'q':\n\n        if (quiet_mode) FATAL(\"Multiple -q options not supported\");\n        quiet_mode = 1;\n        break;\n\n      case 'Z':\n\n        /* This is an undocumented option to write data in the syntax expected\n           by afl-cmin. Nobody else should have any use for this. */\n\n        cmin_mode  = 1;\n        quiet_mode = 1;\n        break;\n\n      case 'A':\n\n        /* Another afl-cmin specific feature. */\n        at_file = optarg;\n        break;\n\n      case 'Q':\n\n        if (qemu_mode) FATAL(\"Multiple -Q options not supported\");\n        if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;\n\n        qemu_mode = 1;\n        break;\n\n      case 'b':\n\n        /* Secret undocumented mode. Writes output in raw binary format\n           similar to that dumped by afl-fuzz in <out_dir/queue/fuzz_bitmap. */\n\n        binary_mode = 1;\n        break;\n\n      case 'c':\n\n        if (keep_cores) FATAL(\"Multiple -c options not supported\");\n        keep_cores = 1;\n        break;\n\n      case 'V':\n\n        show_banner();\n        exit(0);\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if (optind == argc || !out_file) usage(argv[0]);\n\n  setup_shm();\n  setup_signal_handlers();\n\n  set_up_environment();\n\n  find_binary(argv[optind]);\n\n  if (!quiet_mode) {\n    show_banner();\n    ACTF(\"Executing '%s'...\\n\", target_path);\n  }\n\n  detect_file_args(argv + optind);\n\n  if (qemu_mode)\n    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);\n  else\n    use_argv = argv + optind;\n\n  run_target(use_argv);\n\n  tcnt = write_results();\n\n  if (!quiet_mode) {\n\n    if (!tcnt) FATAL(\"No instrumentation detected\" cRST);\n    OKF(\"Captured %u tuples in '%s'.\" cRST, tcnt, out_file);\n\n  }\n\n  exit(child_crashed * 2 + child_timed_out);\n\n}\n\n"
        },
        {
          "name": "afl-tmin.c",
          "type": "blob",
          "size": 25.1904296875,
          "content": "/*\n  Copyright 2015 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - test case minimizer\n   ----------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   A simple test case minimizer that takes an input file and tries to remove\n   as much data as possible while keeping the binary in a crashing state\n   *or* producing consistent instrumentation output (the mode is auto-selected\n   based on the initially observed behavior).\n*/\n\n#define AFL_MAIN\n#include \"android-ashmem.h\"\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <dirent.h>\n#include <fcntl.h>\n\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/shm.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n\nstatic s32 child_pid;                 /* PID of the tested program         */\n\nstatic u8 *trace_bits,                /* SHM with instrumentation bitmap   */\n          *mask_bitmap;               /* Mask for trace bits (-B)          */\n\nstatic u8 *in_file,                   /* Minimizer input test case         */\n          *out_file,                  /* Minimizer output file             */\n          *prog_in,                   /* Targeted program input file       */\n          *target_path,               /* Path to target binary             */\n          *doc_path;                  /* Path to docs                      */\n\nstatic u8* in_data;                   /* Input data for trimming           */\n\nstatic u32 in_len,                    /* Input data length                 */\n           orig_cksum,                /* Original checksum                 */\n           total_execs,               /* Total number of execs             */\n           missed_hangs,              /* Misses due to hangs               */\n           missed_crashes,            /* Misses due to crashes             */\n           missed_paths,              /* Misses due to exec path diffs     */\n           exec_tmout = EXEC_TIMEOUT; /* Exec timeout (ms)                 */\n\nstatic u64 mem_limit = MEM_LIMIT;     /* Memory limit (MB)                 */\n\nstatic s32 shm_id,                    /* ID of the SHM region              */\n           dev_null_fd = -1;          /* FD to /dev/null                   */\n\nstatic u8  crash_mode,                /* Crash-centric mode?               */\n           exit_crash,                /* Treat non-zero exit as crash?     */\n           edges_only,                /* Ignore hit counts?                */\n           exact_mode,                /* Require path match for crashes?   */\n           use_stdin = 1;             /* Use stdin for program input?      */\n\nstatic volatile u8\n           stop_soon,                 /* Ctrl-C pressed?                   */\n           child_timed_out;           /* Child timed out?                  */\n\n\n/* Classify tuple counts. This is a slow & naive version, but good enough here. */\n\nstatic const u8 count_class_lookup[256] = {\n\n  [0]           = 0,\n  [1]           = 1,\n  [2]           = 2,\n  [3]           = 4,\n  [4 ... 7]     = 8,\n  [8 ... 15]    = 16,\n  [16 ... 31]   = 32,\n  [32 ... 127]  = 64,\n  [128 ... 255] = 128\n\n};\n\nstatic void classify_counts(u8* mem) {\n\n  u32 i = MAP_SIZE;\n\n  if (edges_only) {\n\n    while (i--) {\n      if (*mem) *mem = 1;\n      mem++;\n    }\n\n  } else {\n\n    while (i--) {\n      *mem = count_class_lookup[*mem];\n      mem++;\n    }\n\n  }\n\n}\n\n\n/* Apply mask to classified bitmap (if set). */\n\nstatic void apply_mask(u32* mem, u32* mask) {\n\n  u32 i = (MAP_SIZE >> 2);\n\n  if (!mask) return;\n\n  while (i--) {\n\n    *mem &= ~*mask;\n    mem++;\n    mask++;\n\n  }\n\n}\n\n\n/* See if any bytes are set in the bitmap. */\n\nstatic inline u8 anything_set(void) {\n\n  u32* ptr = (u32*)trace_bits;\n  u32  i   = (MAP_SIZE >> 2);\n\n  while (i--) if (*(ptr++)) return 1;\n\n  return 0;\n\n}\n\n\n\n/* Get rid of shared memory and temp files (atexit handler). */\n\nstatic void remove_shm(void) {\n\n  if (prog_in) unlink(prog_in); /* Ignore errors */\n  shmctl(shm_id, IPC_RMID, NULL);\n\n}\n\n\n/* Configure shared memory. */\n\nstatic void setup_shm(void) {\n\n  u8* shm_str;\n\n  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);\n\n  if (shm_id < 0) PFATAL(\"shmget() failed\");\n\n  atexit(remove_shm);\n\n  shm_str = alloc_printf(\"%d\", shm_id);\n\n  setenv(SHM_ENV_VAR, shm_str, 1);\n\n  ck_free(shm_str);\n\n  trace_bits = shmat(shm_id, NULL, 0);\n  \n  if (trace_bits == (void *)-1) PFATAL(\"shmat() failed\");\n\n}\n\n\n/* Read initial file. */\n\nstatic void read_initial_file(void) {\n\n  struct stat st;\n  s32 fd = open(in_file, O_RDONLY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", in_file);\n\n  if (fstat(fd, &st) || !st.st_size)\n    FATAL(\"Zero-sized input file.\");\n\n  if (st.st_size >= TMIN_MAX_FILE)\n    FATAL(\"Input file is too large (%u MB max)\", TMIN_MAX_FILE / 1024 / 1024);\n\n  in_len  = st.st_size;\n  in_data = ck_alloc_nozero(in_len);\n\n  ck_read(fd, in_data, in_len, in_file);\n\n  close(fd);\n\n  OKF(\"Read %u byte%s from '%s'.\", in_len, in_len == 1 ? \"\" : \"s\", in_file);\n\n}\n\n\n/* Write output file. */\n\nstatic s32 write_to_file(u8* path, u8* mem, u32 len) {\n\n  s32 ret;\n\n  unlink(path); /* Ignore errors */\n\n  ret = open(path, O_RDWR | O_CREAT | O_EXCL, 0600);\n\n  if (ret < 0) PFATAL(\"Unable to create '%s'\", path);\n\n  ck_write(ret, mem, len, path);\n\n  lseek(ret, 0, SEEK_SET);\n\n  return ret;\n\n}\n\n\n/* Handle timeout signal. */\n\nstatic void handle_timeout(int sig) {\n\n  child_timed_out = 1;\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}\n\n\n/* Execute target application. Returns 0 if the changes are a dud, or\n   1 if they should be kept. */\n\nstatic u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {\n\n  static struct itimerval it;\n  int status = 0;\n\n  s32 prog_in_fd;\n  u32 cksum;\n\n  memset(trace_bits, 0, MAP_SIZE);\n  MEM_BARRIER();\n\n  prog_in_fd = write_to_file(prog_in, mem, len);\n\n  child_pid = fork();\n\n  if (child_pid < 0) PFATAL(\"fork() failed\");\n\n  if (!child_pid) {\n\n    struct rlimit r;\n\n    if (dup2(use_stdin ? prog_in_fd : dev_null_fd, 0) < 0 ||\n        dup2(dev_null_fd, 1) < 0 ||\n        dup2(dev_null_fd, 2) < 0) {\n\n      *(u32*)trace_bits = EXEC_FAIL_SIG;\n      PFATAL(\"dup2() failed\");\n\n    }\n\n    close(dev_null_fd);\n    close(prog_in_fd);\n\n    setsid();\n\n    if (mem_limit) {\n\n      r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;\n\n#ifdef RLIMIT_AS\n\n      setrlimit(RLIMIT_AS, &r); /* Ignore errors */\n\n#else\n\n      setrlimit(RLIMIT_DATA, &r); /* Ignore errors */\n\n#endif /* ^RLIMIT_AS */\n\n    }\n\n    r.rlim_max = r.rlim_cur = 0;\n    setrlimit(RLIMIT_CORE, &r); /* Ignore errors */\n\n    execv(target_path, argv);\n\n    *(u32*)trace_bits = EXEC_FAIL_SIG;\n    exit(0);\n\n  }\n\n  close(prog_in_fd);\n\n  /* Configure timeout, wait for child, cancel timeout. */\n\n  child_timed_out = 0;\n  it.it_value.tv_sec = (exec_tmout / 1000);\n  it.it_value.tv_usec = (exec_tmout % 1000) * 1000;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  if (waitpid(child_pid, &status, 0) <= 0) FATAL(\"waitpid() failed\");\n\n  child_pid = 0;\n  it.it_value.tv_sec = 0;\n  it.it_value.tv_usec = 0;\n\n  setitimer(ITIMER_REAL, &it, NULL);\n\n  MEM_BARRIER();\n\n  /* Clean up bitmap, analyze exit condition, etc. */\n\n  if (*(u32*)trace_bits == EXEC_FAIL_SIG)\n    FATAL(\"Unable to execute '%s'\", argv[0]);\n\n  classify_counts(trace_bits);\n  apply_mask((u32*)trace_bits, (u32*)mask_bitmap);\n  total_execs++;\n\n  if (stop_soon) {\n\n    SAYF(cRST cLRD \"\\n+++ Minimization aborted by user +++\\n\" cRST);\n    close(write_to_file(out_file, in_data, in_len));\n    exit(1);\n\n  }\n\n  /* Always discard inputs that time out. */\n\n  if (child_timed_out) {\n\n    missed_hangs++;\n    return 0;\n\n  }\n\n  /* Handle crashing inputs depending on current mode. */\n\n  if (WIFSIGNALED(status) ||\n      (WIFEXITED(status) && WEXITSTATUS(status) == MSAN_ERROR) ||\n      (WIFEXITED(status) && WEXITSTATUS(status) && exit_crash)) {\n\n    if (first_run) crash_mode = 1;\n\n    if (crash_mode) {\n\n      if (!exact_mode) return 1;\n\n    } else {\n\n      missed_crashes++;\n      return 0;\n\n    }\n\n  } else\n\n  /* Handle non-crashing inputs appropriately. */\n\n  if (crash_mode) {\n\n    missed_paths++;\n    return 0;\n\n  }\n\n  cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n  if (first_run) orig_cksum = cksum;\n\n  if (orig_cksum == cksum) return 1;\n  \n  missed_paths++;\n  return 0;\n\n}\n\n\n/* Find first power of two greater or equal to val. */\n\nstatic u32 next_p2(u32 val) {\n\n  u32 ret = 1;\n  while (val > ret) ret <<= 1;\n  return ret;\n\n}\n\n\n/* Actually minimize! */\n\nstatic void minimize(char** argv) {\n\n  static u32 alpha_map[256];\n\n  u8* tmp_buf = ck_alloc_nozero(in_len);\n  u32 orig_len = in_len, stage_o_len;\n\n  u32 del_len, set_len, del_pos, set_pos, i, alpha_size, cur_pass = 0;\n  u32 syms_removed, alpha_del0 = 0, alpha_del1, alpha_del2, alpha_d_total = 0;\n  u8  changed_any, prev_del;\n\n  /***********************\n   * BLOCK NORMALIZATION *\n   ***********************/\n\n  set_len    = next_p2(in_len / TMIN_SET_STEPS);\n  set_pos    = 0;\n\n  if (set_len < TMIN_SET_MIN_SIZE) set_len = TMIN_SET_MIN_SIZE;\n\n  ACTF(cBRI \"Stage #0: \" cRST \"One-time block normalization...\");\n\n  while (set_pos < in_len) {\n\n    u8  res;\n    u32 use_len = MIN(set_len, in_len - set_pos);\n\n    for (i = 0; i < use_len; i++)\n      if (in_data[set_pos + i] != '0') break;\n\n    if (i != use_len) {\n\n      memcpy(tmp_buf, in_data, in_len);\n      memset(tmp_buf + set_pos, '0', use_len);\n  \n      res = run_target(argv, tmp_buf, in_len, 0);\n\n      if (res) {\n\n        memset(in_data + set_pos, '0', use_len);\n        changed_any = 1;\n        alpha_del0 += use_len;\n\n      }\n\n    }\n\n    set_pos += set_len;\n\n  }\n\n  alpha_d_total += alpha_del0;\n\n  OKF(\"Block normalization complete, %u byte%s replaced.\", alpha_del0,\n      alpha_del0 == 1 ? \"\" : \"s\");\n\nnext_pass:\n\n  ACTF(cYEL \"--- \" cBRI \"Pass #%u \" cYEL \"---\", ++cur_pass);\n  changed_any = 0;\n\n  /******************\n   * BLOCK DELETION *\n   ******************/\n\n  del_len = next_p2(in_len / TRIM_START_STEPS);\n  stage_o_len = in_len;\n\n  ACTF(cBRI \"Stage #1: \" cRST \"Removing blocks of data...\");\n\nnext_del_blksize:\n\n  if (!del_len) del_len = 1;\n  del_pos  = 0;\n  prev_del = 1;\n\n  SAYF(cGRA \"    Block length = %u, remaining size = %u\\n\" cRST,\n       del_len, in_len);\n\n  while (del_pos < in_len) {\n\n    u8  res;\n    s32 tail_len;\n\n    tail_len = in_len - del_pos - del_len;\n    if (tail_len < 0) tail_len = 0;\n\n    /* If we have processed at least one full block (initially, prev_del == 1),\n       and we did so without deleting the previous one, and we aren't at the\n       very end of the buffer (tail_len > 0), and the current block is the same\n       as the previous one... skip this step as a no-op. */\n\n    if (!prev_del && tail_len && !memcmp(in_data + del_pos - del_len,\n        in_data + del_pos, del_len)) {\n\n      del_pos += del_len;\n      continue;\n\n    }\n\n    prev_del = 0;\n\n    /* Head */\n    memcpy(tmp_buf, in_data, del_pos);\n\n    /* Tail */\n    memcpy(tmp_buf + del_pos, in_data + del_pos + del_len, tail_len);\n\n    res = run_target(argv, tmp_buf, del_pos + tail_len, 0);\n\n    if (res) {\n\n      memcpy(in_data, tmp_buf, del_pos + tail_len);\n      prev_del = 1;\n      in_len   = del_pos + tail_len;\n\n      changed_any = 1;\n\n    } else del_pos += del_len;\n\n  }\n\n  if (del_len > 1 && in_len >= 1) {\n\n    del_len /= 2;\n    goto next_del_blksize;\n\n  }\n\n  OKF(\"Block removal complete, %u bytes deleted.\", stage_o_len - in_len);\n\n  if (!in_len && changed_any)\n    WARNF(cLRD \"Down to zero bytes - check the command line and mem limit!\" cRST);\n\n  if (cur_pass > 1 && !changed_any) goto finalize_all;\n\n  /*************************\n   * ALPHABET MINIMIZATION *\n   *************************/\n\n  alpha_size   = 0;\n  alpha_del1   = 0;\n  syms_removed = 0;\n\n  memset(alpha_map, 0, 256 * sizeof(u32));\n\n  for (i = 0; i < in_len; i++) {\n    if (!alpha_map[in_data[i]]) alpha_size++;\n    alpha_map[in_data[i]]++;\n  }\n\n  ACTF(cBRI \"Stage #2: \" cRST \"Minimizing symbols (%u code point%s)...\",\n       alpha_size, alpha_size == 1 ? \"\" : \"s\");\n\n  for (i = 0; i < 256; i++) {\n\n    u32 r;\n    u8 res;\n\n    if (i == '0' || !alpha_map[i]) continue;\n\n    memcpy(tmp_buf, in_data, in_len);\n\n    for (r = 0; r < in_len; r++)\n      if (tmp_buf[r] == i) tmp_buf[r] = '0'; \n\n    res = run_target(argv, tmp_buf, in_len, 0);\n\n    if (res) {\n\n      memcpy(in_data, tmp_buf, in_len);\n      syms_removed++;\n      alpha_del1 += alpha_map[i];\n      changed_any = 1;\n\n    }\n\n  }\n\n  alpha_d_total += alpha_del1;\n\n  OKF(\"Symbol minimization finished, %u symbol%s (%u byte%s) replaced.\",\n      syms_removed, syms_removed == 1 ? \"\" : \"s\",\n      alpha_del1, alpha_del1 == 1 ? \"\" : \"s\");\n\n  /**************************\n   * CHARACTER MINIMIZATION *\n   **************************/\n\n  alpha_del2 = 0;\n\n  ACTF(cBRI \"Stage #3: \" cRST \"Character minimization...\");\n\n  memcpy(tmp_buf, in_data, in_len);\n\n  for (i = 0; i < in_len; i++) {\n\n    u8 res, orig = tmp_buf[i];\n\n    if (orig == '0') continue;\n    tmp_buf[i] = '0';\n\n    res = run_target(argv, tmp_buf, in_len, 0);\n\n    if (res) {\n\n      in_data[i] = '0';\n      alpha_del2++;\n      changed_any = 1;\n\n    } else tmp_buf[i] = orig;\n\n  }\n\n  alpha_d_total += alpha_del2;\n\n  OKF(\"Character minimization done, %u byte%s replaced.\",\n      alpha_del2, alpha_del2 == 1 ? \"\" : \"s\");\n\n  if (changed_any) goto next_pass;\n\nfinalize_all:\n\n  SAYF(\"\\n\"\n       cGRA \"     File size reduced by : \" cRST \"%0.02f%% (to %u byte%s)\\n\"\n       cGRA \"    Characters simplified : \" cRST \"%0.02f%%\\n\"\n       cGRA \"     Number of execs done : \" cRST \"%u\\n\"\n       cGRA \"          Fruitless execs : \" cRST \"path=%u crash=%u hang=%s%u\\n\\n\",\n       100 - ((double)in_len) * 100 / orig_len, in_len, in_len == 1 ? \"\" : \"s\",\n       ((double)(alpha_d_total)) * 100 / (in_len ? in_len : 1),\n       total_execs, missed_paths, missed_crashes, missed_hangs ? cLRD : \"\",\n       missed_hangs);\n\n  if (total_execs > 50 && missed_hangs * 10 > total_execs)\n    WARNF(cLRD \"Frequent timeouts - results may be skewed.\" cRST);\n\n}\n\n\n\n/* Handle Ctrl-C and the like. */\n\nstatic void handle_stop_sig(int sig) {\n\n  stop_soon = 1;\n\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}\n\n\n/* Do basic preparations - persistent fds, filenames, etc. */\n\nstatic void set_up_environment(void) {\n\n  u8* x;\n\n  dev_null_fd = open(\"/dev/null\", O_RDWR);\n  if (dev_null_fd < 0) PFATAL(\"Unable to open /dev/null\");\n\n  if (!prog_in) {\n\n    u8* use_dir = \".\";\n\n    if (access(use_dir, R_OK | W_OK | X_OK)) {\n\n      use_dir = getenv(\"TMPDIR\");\n      if (!use_dir) use_dir = \"/tmp\";\n\n    }\n\n    prog_in = alloc_printf(\"%s/.afl-tmin-temp-%u\", use_dir, getpid());\n\n  }\n\n  /* Set sane defaults... */\n\n  x = getenv(\"ASAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"abort_on_error=1\"))\n      FATAL(\"Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!\");\n\n    if (!strstr(x, \"symbolize=0\"))\n      FATAL(\"Custom ASAN_OPTIONS set without symbolize=0 - please fix!\");\n\n  }\n\n  x = getenv(\"MSAN_OPTIONS\");\n\n  if (x) {\n\n    if (!strstr(x, \"exit_code=\" STRINGIFY(MSAN_ERROR)))\n      FATAL(\"Custom MSAN_OPTIONS set without exit_code=\"\n            STRINGIFY(MSAN_ERROR) \" - please fix!\");\n\n    if (!strstr(x, \"symbolize=0\"))\n      FATAL(\"Custom MSAN_OPTIONS set without symbolize=0 - please fix!\");\n\n  }\n\n  setenv(\"ASAN_OPTIONS\", \"abort_on_error=1:\"\n                         \"detect_leaks=0:\"\n                         \"symbolize=0:\"\n                         \"allocator_may_return_null=1\", 0);\n\n  setenv(\"MSAN_OPTIONS\", \"exit_code=\" STRINGIFY(MSAN_ERROR) \":\"\n                         \"symbolize=0:\"\n                         \"abort_on_error=1:\"\n                         \"allocator_may_return_null=1:\"\n                         \"msan_track_origins=0\", 0);\n\n  if (getenv(\"AFL_PRELOAD\")) {\n    setenv(\"LD_PRELOAD\", getenv(\"AFL_PRELOAD\"), 1);\n    setenv(\"DYLD_INSERT_LIBRARIES\", getenv(\"AFL_PRELOAD\"), 1);\n  }\n\n}\n\n\n/* Setup signal handlers, duh. */\n\nstatic void setup_signal_handlers(void) {\n\n  struct sigaction sa;\n\n  sa.sa_handler   = NULL;\n  sa.sa_flags     = SA_RESTART;\n  sa.sa_sigaction = NULL;\n\n  sigemptyset(&sa.sa_mask);\n\n  /* Various ways of saying \"stop\". */\n\n  sa.sa_handler = handle_stop_sig;\n  sigaction(SIGHUP, &sa, NULL);\n  sigaction(SIGINT, &sa, NULL);\n  sigaction(SIGTERM, &sa, NULL);\n\n  /* Exec timeout notifications. */\n\n  sa.sa_handler = handle_timeout;\n  sigaction(SIGALRM, &sa, NULL);\n\n}\n\n\n/* Detect @@ in args. */\n\nstatic void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = getcwd(NULL, 0);\n\n  if (!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if (aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      /* Be sure that we're always using fully-qualified paths. */\n\n      if (prog_in[0] == '/') aa_subst = prog_in;\n      else aa_subst = alloc_printf(\"%s/%s\", cwd, prog_in);\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      if (prog_in[0] != '/') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  SAYF(\"\\n%s [ options ] -- /path/to/target_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -i file       - input test case to be shrunk by the tool\\n\"\n       \"  -o file       - final output location for the minimized data\\n\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -f file       - input file read by the tested program (stdin)\\n\"\n       \"  -t msec       - timeout for each run (%u ms)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n       \"  -Q            - use binary-only instrumentation (QEMU mode)\\n\\n\"\n\n       \"Minimization settings:\\n\\n\"\n\n       \"  -e            - solve for edge coverage only, ignore hit counts\\n\"\n       \"  -x            - treat non-zero exit codes as crashes\\n\\n\"\n\n       \"Other stuff:\\n\\n\"\n\n       \"  -V            - show version number and exit\\n\\n\"\n\n       \"For additional tips, please consult %s/README.\\n\\n\",\n\n       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Find binary. */\n\nstatic void find_binary(u8* fname) {\n\n  u8* env_path = 0;\n  struct stat st;\n\n  if (strchr(fname, '/') || !(env_path = getenv(\"PATH\"))) {\n\n    target_path = ck_strdup(fname);\n\n    if (stat(target_path, &st) || !S_ISREG(st.st_mode) ||\n        !(st.st_mode & 0111) || st.st_size < 4)\n      FATAL(\"Program '%s' not found or not executable\", fname);\n\n  } else {\n\n    while (env_path) {\n\n      u8 *cur_elem, *delim = strchr(env_path, ':');\n\n      if (delim) {\n\n        cur_elem = ck_alloc(delim - env_path + 1);\n        memcpy(cur_elem, env_path, delim - env_path);\n        delim++;\n\n      } else cur_elem = ck_strdup(env_path);\n\n      env_path = delim;\n\n      if (cur_elem[0])\n        target_path = alloc_printf(\"%s/%s\", cur_elem, fname);\n      else\n        target_path = ck_strdup(fname);\n\n      ck_free(cur_elem);\n\n      if (!stat(target_path, &st) && S_ISREG(st.st_mode) &&\n          (st.st_mode & 0111) && st.st_size >= 4) break;\n\n      ck_free(target_path);\n      target_path = 0;\n\n    }\n\n    if (!target_path) FATAL(\"Program '%s' not found or not executable\", fname);\n\n  }\n\n}\n\n\n/* Fix up argv for QEMU. */\n\nstatic char** get_qemu_argv(u8* own_loc, char** argv, int argc) {\n\n  char** new_argv = ck_alloc(sizeof(char*) * (argc + 4));\n  u8 *tmp, *cp, *rsl, *own_copy;\n\n  /* Workaround for a QEMU stability glitch. */\n\n  setenv(\"QEMU_LOG\", \"nochain\", 1);\n\n  memcpy(new_argv + 3, argv + 1, sizeof(char*) * argc);\n\n  /* Now we need to actually find qemu for argv[0]. */\n\n  new_argv[2] = target_path;\n  new_argv[1] = \"--\";\n\n  tmp = getenv(\"AFL_PATH\");\n\n  if (tmp) {\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", tmp);\n\n    if (access(cp, X_OK))\n      FATAL(\"Unable to find '%s'\", tmp);\n\n    target_path = new_argv[0] = cp;\n    return new_argv;\n\n  }\n\n  own_copy = ck_strdup(own_loc);\n  rsl = strrchr(own_copy, '/');\n\n  if (rsl) {\n\n    *rsl = 0;\n\n    cp = alloc_printf(\"%s/afl-qemu-trace\", own_copy);\n    ck_free(own_copy);\n\n    if (!access(cp, X_OK)) {\n\n      target_path = new_argv[0] = cp;\n      return new_argv;\n\n    }\n\n  } else ck_free(own_copy);\n\n  if (!access(BIN_PATH \"/afl-qemu-trace\", X_OK)) {\n\n    target_path = new_argv[0] = BIN_PATH \"/afl-qemu-trace\";\n    return new_argv;\n\n  }\n\n  FATAL(\"Unable to find 'afl-qemu-trace'.\");\n\n}\n\n\n/* Read mask bitmap from file. This is for the -B option. */\n\nstatic void read_bitmap(u8* fname) {\n\n  s32 fd = open(fname, O_RDONLY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", fname);\n\n  ck_read(fd, mask_bitmap, MAP_SIZE, fname);\n\n  close(fd);\n\n}\n\n\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;\n  char** use_argv;\n\n  doc_path = access(DOC_PATH, F_OK) ? \"docs\" : DOC_PATH;\n\n  SAYF(cCYA \"afl-tmin \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  while ((opt = getopt(argc,argv,\"+i:o:f:m:t:B:xeQV\")) > 0)\n\n    switch (opt) {\n\n      case 'i':\n\n        if (in_file) FATAL(\"Multiple -i options not supported\");\n        in_file = optarg;\n        break;\n\n      case 'o':\n\n        if (out_file) FATAL(\"Multiple -o options not supported\");\n        out_file = optarg;\n        break;\n\n      case 'f':\n\n        if (prog_in) FATAL(\"Multiple -f options not supported\");\n        use_stdin = 0;\n        prog_in   = optarg;\n        break;\n\n      case 'e':\n\n        if (edges_only) FATAL(\"Multiple -e options not supported\");\n        edges_only = 1;\n        break;\n\n      case 'x':\n\n        if (exit_crash) FATAL(\"Multiple -x options not supported\");\n        exit_crash = 1;\n        break;\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n          if (sizeof(rlim_t) == 4 && mem_limit > 2000)\n            FATAL(\"Value of -m out of range on 32-bit systems\");\n\n        }\n\n        break;\n\n      case 't':\n\n        if (timeout_given) FATAL(\"Multiple -t options not supported\");\n        timeout_given = 1;\n\n        exec_tmout = atoi(optarg);\n\n        if (exec_tmout < 10 || optarg[0] == '-')\n          FATAL(\"Dangerously low value of -t\");\n\n        break;\n\n      case 'Q':\n\n        if (qemu_mode) FATAL(\"Multiple -Q options not supported\");\n        if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;\n\n        qemu_mode = 1;\n        break;\n\n      case 'B': /* load bitmap */\n\n        /* This is a secret undocumented option! It is speculated to be useful\n           if you have a baseline \"boring\" input file and another \"interesting\"\n           file you want to minimize.\n\n           You can dump a binary bitmap for the boring file using\n           afl-showmap -b, and then load it into afl-tmin via -B. The minimizer\n           will then minimize to preserve only the edges that are unique to\n           the interesting input file, but ignoring everything from the\n           original map.\n\n           The option may be extended and made more official if it proves\n           to be useful. */\n\n        if (mask_bitmap) FATAL(\"Multiple -B options not supported\");\n        mask_bitmap = ck_alloc(MAP_SIZE);\n        read_bitmap(optarg);\n        break;\n\n      case 'V': /* Show version number */\n\n        /* Version number has been printed already, just quit. */\n        exit(0);\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if (optind == argc || !in_file || !out_file) usage(argv[0]);\n\n  setup_shm();\n  setup_signal_handlers();\n\n  set_up_environment();\n\n  find_binary(argv[optind]);\n  detect_file_args(argv + optind);\n\n  if (qemu_mode)\n    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);\n  else\n    use_argv = argv + optind;\n\n  exact_mode = !!getenv(\"AFL_TMIN_EXACT\");\n\n  SAYF(\"\\n\");\n\n  read_initial_file();\n\n  ACTF(\"Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...\",\n       mem_limit, exec_tmout, edges_only ? \", edges only\" : \"\");\n\n  run_target(use_argv, in_data, in_len, 1);\n\n  if (child_timed_out)\n    FATAL(\"Target binary times out (adjusting -t may help).\");\n\n  if (!crash_mode) {\n\n     OKF(\"Program terminates normally, minimizing in \" \n         cCYA \"instrumented\" cRST \" mode.\");\n\n     if (!anything_set()) FATAL(\"No instrumentation detected.\");\n\n  } else {\n\n     OKF(\"Program exits with a signal, minimizing in \" cMGN \"%scrash\" cRST\n         \" mode.\", exact_mode ? \"EXACT \" : \"\");\n\n  }\n\n  minimize(use_argv);\n\n  ACTF(\"Writing output to '%s'...\", out_file);\n\n  unlink(prog_in);\n  prog_in = NULL;\n\n  close(write_to_file(out_file, in_data, in_len));\n\n  OKF(\"We're done here. Have a nice day!\\n\");\n\n  exit(0);\n\n}\n\n"
        },
        {
          "name": "afl-whatsup",
          "type": "blob",
          "size": 3.6240234375,
          "content": "#!/bin/sh\n#\n# american fuzzy lop - status check tool\n# --------------------------------------\n#\n# Written and maintained by Michal Zalewski <lcamtuf@google.com>\n#\n# Copyright 2015 Google LLC All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at:\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# This tool summarizes the status of any locally-running synchronized\n# instances of afl-fuzz.\n#\n\necho \"status check tool for afl-fuzz by <lcamtuf@google.com>\"\necho\n\nif [ \"$1\" = \"-s\" ]; then\n\n  SUMMARY_ONLY=1\n  DIR=\"$2\"\n\nelse\n\n  unset SUMMARY_ONLY\n  DIR=\"$1\"\n\nfi\n\nif [ \"$DIR\" = \"\" ]; then\n\n  echo \"Usage: $0 [ -s ] afl_sync_dir\" 1>&2\n  echo 1>&2\n  echo \"The -s option causes the tool to skip all the per-fuzzer trivia and show\" 1>&2\n  echo \"just the summary results. See docs/parallel_fuzzing.txt for additional tips.\" 1>&2\n  echo 1>&2\n  exit 1\n\nfi\n\ncd \"$DIR\" || exit 1\n\nif [ -d queue ]; then\n\n  echo \"[-] Error: parameter is an individual output directory, not a sync dir.\" 1>&2\n  exit 1\n\nfi\n\nCUR_TIME=`date +%s`\n\nTMP=`mktemp -t .afl-whatsup-XXXXXXXX` || TMP=`mktemp -p /data/local/tmp .afl-whatsup-XXXXXXXX` || exit 1\n\nALIVE_CNT=0\nDEAD_CNT=0\n\nTOTAL_TIME=0\nTOTAL_EXECS=0\nTOTAL_EPS=0\nTOTAL_CRASHES=0\nTOTAL_PFAV=0\nTOTAL_PENDING=0\n\nif [ \"$SUMMARY_ONLY\" = \"\" ]; then\n\n  echo \"Individual fuzzers\"\n  echo \"==================\"\n  echo\n\nfi\n\nfor i in `find . -maxdepth 2 -iname fuzzer_stats | sort`; do\n\n  sed 's/^command_line.*$/_skip:1/;s/[ ]*:[ ]*/=\"/;s/$/\"/' \"$i\" >\"$TMP\"\n  . \"$TMP\"\n\n  RUN_UNIX=$((CUR_TIME - start_time))\n  RUN_DAYS=$((RUN_UNIX / 60 / 60 / 24))\n  RUN_HRS=$(((RUN_UNIX / 60 / 60) % 24))\n\n  if [ \"$SUMMARY_ONLY\" = \"\" ]; then\n\n    echo \">>> $afl_banner ($RUN_DAYS days, $RUN_HRS hrs) <<<\"\n    echo\n\n  fi\n\n  if ! kill -0 \"$fuzzer_pid\" 2>/dev/null; then\n\n    if [ \"$SUMMARY_ONLY\" = \"\" ]; then\n\n      echo \"  Instance is dead or running remotely, skipping.\"\n      echo\n\n    fi\n\n    DEAD_CNT=$((DEAD_CNT + 1))\n    continue\n\n  fi\n\n  ALIVE_CNT=$((ALIVE_CNT + 1))\n\n  EXEC_SEC=$((execs_done / RUN_UNIX))\n  PATH_PERC=$((cur_path * 100 / paths_total))\n\n  TOTAL_TIME=$((TOTAL_TIME + RUN_UNIX))\n  TOTAL_EPS=$((TOTAL_EPS + EXEC_SEC))\n  TOTAL_EXECS=$((TOTAL_EXECS + execs_done))\n  TOTAL_CRASHES=$((TOTAL_CRASHES + unique_crashes))\n  TOTAL_PENDING=$((TOTAL_PENDING + pending_total))\n  TOTAL_PFAV=$((TOTAL_PFAV + pending_favs))\n\n  if [ \"$SUMMARY_ONLY\" = \"\" ]; then\n\n    echo \"  cycle $((cycles_done + 1)), lifetime speed $EXEC_SEC execs/sec, path $cur_path/$paths_total (${PATH_PERC}%)\"\n\n    if [ \"$unique_crashes\" = \"0\" ]; then\n      echo \"  pending $pending_favs/$pending_total, coverage $bitmap_cvg, no crashes yet\"\n    else\n      echo \"  pending $pending_favs/$pending_total, coverage $bitmap_cvg, crash count $unique_crashes (!)\"\n    fi\n\n    echo\n\n  fi\n\ndone\n\nrm -f \"$TMP\"\n\nTOTAL_DAYS=$((TOTAL_TIME / 60 / 60 / 24))\nTOTAL_HRS=$(((TOTAL_TIME / 60 / 60) % 24))\n\ntest \"$TOTAL_TIME\" = \"0\" && TOTAL_TIME=1\n\necho \"Summary stats\"\necho \"=============\"\necho\necho \"       Fuzzers alive : $ALIVE_CNT\"\n\nif [ ! \"$DEAD_CNT\" = \"0\" ]; then\n  echo \"      Dead or remote : $DEAD_CNT (excluded from stats)\"\nfi\n\necho \"      Total run time : $TOTAL_DAYS days, $TOTAL_HRS hours\"\necho \"         Total execs : $((TOTAL_EXECS / 1000 / 1000)) million\"\necho \"    Cumulative speed : $TOTAL_EPS execs/sec\"\necho \"       Pending paths : $TOTAL_PFAV faves, $TOTAL_PENDING total\"\n\nif [ \"$ALIVE_CNT\" -gt \"1\" ]; then\n  echo \"  Pending per fuzzer : $((TOTAL_PFAV/ALIVE_CNT)) faves, $((TOTAL_PENDING/ALIVE_CNT)) total (on average)\"\nfi\n\necho \"       Crashes found : $TOTAL_CRASHES locally unique\"\necho\n\nexit 0\n"
        },
        {
          "name": "alloc-inl.h",
          "type": "blob",
          "size": 12.56640625,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - error-checking, memory-zeroing alloc routines\n   ------------------------------------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   This allocator is not designed to resist malicious attackers (the canaries\n   are small and predictable), but provides a robust and portable way to detect\n   use-after-free, off-by-one writes, stale pointers, and so on.\n*/\n\n#ifndef _HAVE_ALLOC_INL_H\n#define _HAVE_ALLOC_INL_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n\n/* User-facing macro to sprintf() to a dynamically allocated buffer. */\n\n#define alloc_printf(_str...) ({ \\\n    u8* _tmp; \\\n    s32 _len = snprintf(NULL, 0, _str); \\\n    if (_len < 0) FATAL(\"Whoa, snprintf() fails?!\"); \\\n    _tmp = ck_alloc(_len + 1); \\\n    snprintf((char*)_tmp, _len + 1, _str); \\\n    _tmp; \\\n  })\n\n/* Macro to enforce allocation limits as a last-resort defense against\n   integer overflows. */\n\n#define ALLOC_CHECK_SIZE(_s) do { \\\n    if ((_s) > MAX_ALLOC) \\\n      ABORT(\"Bad alloc request: %u bytes\", (_s)); \\\n  } while (0)\n\n/* Macro to check malloc() failures and the like. */\n\n#define ALLOC_CHECK_RESULT(_r, _s) do { \\\n    if (!(_r)) \\\n      ABORT(\"Out of memory: can't allocate %u bytes\", (_s)); \\\n  } while (0)\n\n/* Magic tokens used to mark used / freed chunks. */\n\n#define ALLOC_MAGIC_C1  0xFF00FF00 /* Used head (dword)  */\n#define ALLOC_MAGIC_F   0xFE00FE00 /* Freed head (dword) */\n#define ALLOC_MAGIC_C2  0xF0       /* Used tail (byte)   */\n\n/* Positions of guard tokens in relation to the user-visible pointer. */\n\n#define ALLOC_C1(_ptr)  (((u32*)(_ptr))[-2])\n#define ALLOC_S(_ptr)   (((u32*)(_ptr))[-1])\n#define ALLOC_C2(_ptr)  (((u8*)(_ptr))[ALLOC_S(_ptr)])\n\n#define ALLOC_OFF_HEAD  8\n#define ALLOC_OFF_TOTAL (ALLOC_OFF_HEAD + 1)\n\n/* Allocator increments for ck_realloc_block(). */\n\n#define ALLOC_BLK_INC    256\n\n/* Sanity-checking macros for pointers. */\n\n#define CHECK_PTR(_p) do { \\\n    if (_p) { \\\n      if (ALLOC_C1(_p) ^ ALLOC_MAGIC_C1) {\\\n        if (ALLOC_C1(_p) == ALLOC_MAGIC_F) \\\n          ABORT(\"Use after free.\"); \\\n        else ABORT(\"Corrupted head alloc canary.\"); \\\n      } \\\n      if (ALLOC_C2(_p) ^ ALLOC_MAGIC_C2) \\\n        ABORT(\"Corrupted tail alloc canary.\"); \\\n    } \\\n  } while (0)\n\n#define CHECK_PTR_EXPR(_p) ({ \\\n    typeof (_p) _tmp = (_p); \\\n    CHECK_PTR(_tmp); \\\n    _tmp; \\\n  })\n\n\n/* Allocate a buffer, explicitly not zeroing it. Returns NULL for zero-sized\n   requests. */\n\nstatic inline void* DFL_ck_alloc_nozero(u32 size) {\n\n  void* ret;\n\n  if (!size) return NULL;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc(size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  return ret;\n\n}\n\n\n/* Allocate a buffer, returning zeroed memory. */\n\nstatic inline void* DFL_ck_alloc(u32 size) {\n\n  void* mem;\n\n  if (!size) return NULL;\n  mem = DFL_ck_alloc_nozero(size);\n\n  return memset(mem, 0, size);\n\n}\n\n\n/* Free memory, checking for double free and corrupted heap. When DEBUG_BUILD\n   is set, the old memory will be also clobbered with 0xFF. */\n\nstatic inline void DFL_ck_free(void* mem) {\n\n  if (!mem) return;\n\n  CHECK_PTR(mem);\n\n#ifdef DEBUG_BUILD\n\n  /* Catch pointer issues sooner. */\n  memset(mem, 0xFF, ALLOC_S(mem));\n\n#endif /* DEBUG_BUILD */\n\n  ALLOC_C1(mem) = ALLOC_MAGIC_F;\n\n  free(mem - ALLOC_OFF_HEAD);\n\n}\n\n\n/* Re-allocate a buffer, checking for issues and zeroing any newly-added tail.\n   With DEBUG_BUILD, the buffer is always reallocated to a new addresses and the\n   old memory is clobbered with 0xFF. */\n\nstatic inline void* DFL_ck_realloc(void* orig, u32 size) {\n\n  void* ret;\n  u32   old_size = 0;\n\n  if (!size) {\n\n    DFL_ck_free(orig);\n    return NULL;\n\n  }\n\n  if (orig) {\n\n    CHECK_PTR(orig);\n\n#ifndef DEBUG_BUILD\n    ALLOC_C1(orig) = ALLOC_MAGIC_F;\n#endif /* !DEBUG_BUILD */\n\n    old_size  = ALLOC_S(orig);\n    orig     -= ALLOC_OFF_HEAD;\n\n    ALLOC_CHECK_SIZE(old_size);\n\n  }\n\n  ALLOC_CHECK_SIZE(size);\n\n#ifndef DEBUG_BUILD\n\n  ret = realloc(orig, size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n#else\n\n  /* Catch pointer issues sooner: force relocation and make sure that the\n     original buffer is wiped. */\n\n  ret = malloc(size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n  if (orig) {\n\n    memcpy(ret + ALLOC_OFF_HEAD, orig + ALLOC_OFF_HEAD, MIN(size, old_size));\n    memset(orig + ALLOC_OFF_HEAD, 0xFF, old_size);\n\n    ALLOC_C1(orig + ALLOC_OFF_HEAD) = ALLOC_MAGIC_F;\n\n    free(orig);\n\n  }\n\n#endif /* ^!DEBUG_BUILD */\n\n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  if (size > old_size)\n    memset(ret + old_size, 0, size - old_size);\n\n  return ret;\n\n}\n\n\n/* Re-allocate a buffer with ALLOC_BLK_INC increments (used to speed up\n   repeated small reallocs without complicating the user code). */\n\nstatic inline void* DFL_ck_realloc_block(void* orig, u32 size) {\n\n#ifndef DEBUG_BUILD\n\n  if (orig) {\n\n    CHECK_PTR(orig);\n\n    if (ALLOC_S(orig) >= size) return orig;\n\n    size += ALLOC_BLK_INC;\n\n  }\n\n#endif /* !DEBUG_BUILD */\n\n  return DFL_ck_realloc(orig, size);\n\n}\n\n\n/* Create a buffer with a copy of a string. Returns NULL for NULL inputs. */\n\nstatic inline u8* DFL_ck_strdup(u8* str) {\n\n  void* ret;\n  u32   size;\n\n  if (!str) return NULL;\n\n  size = strlen((char*)str) + 1;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc(size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  return memcpy(ret, str, size);\n\n}\n\n\n/* Create a buffer with a copy of a memory block. Returns NULL for zero-sized\n   or NULL inputs. */\n\nstatic inline void* DFL_ck_memdup(void* mem, u32 size) {\n\n  void* ret;\n\n  if (!mem || !size) return NULL;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc(size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n  \n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  return memcpy(ret, mem, size);\n\n}\n\n\n/* Create a buffer with a block of text, appending a NUL terminator at the end.\n   Returns NULL for zero-sized or NULL inputs. */\n\nstatic inline u8* DFL_ck_memdup_str(u8* mem, u32 size) {\n\n  u8* ret;\n\n  if (!mem || !size) return NULL;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc(size + ALLOC_OFF_TOTAL + 1);\n  ALLOC_CHECK_RESULT(ret, size);\n  \n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  memcpy(ret, mem, size);\n  ret[size] = 0;\n\n  return ret;\n\n}\n\n\n#ifndef DEBUG_BUILD\n\n/* In non-debug mode, we just do straightforward aliasing of the above functions\n   to user-visible names such as ck_alloc(). */\n\n#define ck_alloc          DFL_ck_alloc\n#define ck_alloc_nozero   DFL_ck_alloc_nozero\n#define ck_realloc        DFL_ck_realloc\n#define ck_realloc_block  DFL_ck_realloc_block\n#define ck_strdup         DFL_ck_strdup\n#define ck_memdup         DFL_ck_memdup\n#define ck_memdup_str     DFL_ck_memdup_str\n#define ck_free           DFL_ck_free\n\n#define alloc_report()\n\n#else\n\n/* In debugging mode, we also track allocations to detect memory leaks, and the\n   flow goes through one more layer of indirection. */\n\n/* Alloc tracking data structures: */\n\n#define ALLOC_BUCKETS     4096\n\nstruct TRK_obj {\n  void *ptr;\n  char *file, *func;\n  u32  line;\n};\n\n#ifdef AFL_MAIN\n\nstruct TRK_obj* TRK[ALLOC_BUCKETS];\nu32 TRK_cnt[ALLOC_BUCKETS];\n\n#  define alloc_report() TRK_report()\n\n#else\n\nextern struct TRK_obj* TRK[ALLOC_BUCKETS];\nextern u32 TRK_cnt[ALLOC_BUCKETS];\n\n#  define alloc_report()\n\n#endif /* ^AFL_MAIN */\n\n/* Bucket-assigning function for a given pointer: */\n\n#define TRKH(_ptr) (((((u32)(_ptr)) >> 16) ^ ((u32)(_ptr))) % ALLOC_BUCKETS)\n\n\n/* Add a new entry to the list of allocated objects. */\n\nstatic inline void TRK_alloc_buf(void* ptr, const char* file, const char* func,\n                                 u32 line) {\n\n  u32 i, bucket;\n\n  if (!ptr) return;\n\n  bucket = TRKH(ptr);\n\n  /* Find a free slot in the list of entries for that bucket. */\n\n  for (i = 0; i < TRK_cnt[bucket]; i++)\n\n    if (!TRK[bucket][i].ptr) {\n\n      TRK[bucket][i].ptr  = ptr;\n      TRK[bucket][i].file = (char*)file;\n      TRK[bucket][i].func = (char*)func;\n      TRK[bucket][i].line = line;\n      return;\n\n    }\n\n  /* No space available - allocate more. */\n\n  TRK[bucket] = DFL_ck_realloc_block(TRK[bucket],\n    (TRK_cnt[bucket] + 1) * sizeof(struct TRK_obj));\n\n  TRK[bucket][i].ptr  = ptr;\n  TRK[bucket][i].file = (char*)file;\n  TRK[bucket][i].func = (char*)func;\n  TRK[bucket][i].line = line;\n\n  TRK_cnt[bucket]++;\n\n}\n\n\n/* Remove entry from the list of allocated objects. */\n\nstatic inline void TRK_free_buf(void* ptr, const char* file, const char* func,\n                                u32 line) {\n\n  u32 i, bucket;\n\n  if (!ptr) return;\n\n  bucket = TRKH(ptr);\n\n  /* Find the element on the list... */\n\n  for (i = 0; i < TRK_cnt[bucket]; i++)\n\n    if (TRK[bucket][i].ptr == ptr) {\n\n      TRK[bucket][i].ptr = 0;\n      return;\n\n    }\n\n  WARNF(\"ALLOC: Attempt to free non-allocated memory in %s (%s:%u)\",\n        func, file, line);\n\n}\n\n\n/* Do a final report on all non-deallocated objects. */\n\nstatic inline void TRK_report(void) {\n\n  u32 i, bucket;\n\n  fflush(0);\n\n  for (bucket = 0; bucket < ALLOC_BUCKETS; bucket++)\n    for (i = 0; i < TRK_cnt[bucket]; i++)\n      if (TRK[bucket][i].ptr)\n        WARNF(\"ALLOC: Memory never freed, created in %s (%s:%u)\",\n              TRK[bucket][i].func, TRK[bucket][i].file, TRK[bucket][i].line);\n\n}\n\n\n/* Simple wrappers for non-debugging functions: */\n\nstatic inline void* TRK_ck_alloc(u32 size, const char* file, const char* func,\n                                 u32 line) {\n\n  void* ret = DFL_ck_alloc(size);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_realloc(void* orig, u32 size, const char* file,\n                                   const char* func, u32 line) {\n\n  void* ret = DFL_ck_realloc(orig, size);\n  TRK_free_buf(orig, file, func, line);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_realloc_block(void* orig, u32 size, const char* file,\n                                         const char* func, u32 line) {\n\n  void* ret = DFL_ck_realloc_block(orig, size);\n  TRK_free_buf(orig, file, func, line);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_strdup(u8* str, const char* file, const char* func,\n                                  u32 line) {\n\n  void* ret = DFL_ck_strdup(str);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_memdup(void* mem, u32 size, const char* file,\n                                  const char* func, u32 line) {\n\n  void* ret = DFL_ck_memdup(mem, size);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_memdup_str(void* mem, u32 size, const char* file,\n                                      const char* func, u32 line) {\n\n  void* ret = DFL_ck_memdup_str(mem, size);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void TRK_ck_free(void* ptr, const char* file,\n                                const char* func, u32 line) {\n\n  TRK_free_buf(ptr, file, func, line);\n  DFL_ck_free(ptr);\n\n}\n\n/* Aliasing user-facing names to tracking functions: */\n\n#define ck_alloc(_p1) \\\n  TRK_ck_alloc(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_alloc_nozero(_p1) \\\n  TRK_ck_alloc(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_realloc(_p1, _p2) \\\n  TRK_ck_realloc(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_realloc_block(_p1, _p2) \\\n  TRK_ck_realloc_block(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_strdup(_p1) \\\n  TRK_ck_strdup(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_memdup(_p1, _p2) \\\n  TRK_ck_memdup(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_memdup_str(_p1, _p2) \\\n  TRK_ck_memdup_str(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_free(_p1) \\\n  TRK_ck_free(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#endif /* ^!DEBUG_BUILD */\n\n#endif /* ! _HAVE_ALLOC_INL_H */\n"
        },
        {
          "name": "android-ashmem.h",
          "type": "blob",
          "size": 1.560546875,
          "content": "#ifdef __ANDROID__\n#ifndef _ANDROID_ASHMEM_H\n#define _ANDROID_ASHMEM_H\n\n#include <fcntl.h>\n#include <linux/ashmem.h>\n#include <linux/shm.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n\n#if __ANDROID_API__ >= 26\n#define shmat bionic_shmat\n#define shmctl bionic_shmctl\n#define shmdt bionic_shmdt\n#define shmget bionic_shmget\n#endif\n#include <sys/shm.h>\n#undef shmat\n#undef shmctl\n#undef shmdt\n#undef shmget\n#include <stdio.h>\n\n#define ASHMEM_DEVICE \"/dev/ashmem\"\n\nstatic inline int shmctl(int __shmid, int __cmd, struct shmid_ds *__buf) {\n  int ret = 0;\n  if (__cmd == IPC_RMID) {\n    int length = ioctl(__shmid, ASHMEM_GET_SIZE, NULL);\n    struct ashmem_pin pin = {0, length};\n    ret = ioctl(__shmid, ASHMEM_UNPIN, &pin);\n    close(__shmid);\n  }\n\n  return ret;\n}\n\nstatic inline int shmget(key_t __key, size_t __size, int __shmflg) {\n  (void) __shmflg;\n  int fd, ret;\n  char ourkey[11];\n\n  fd = open(ASHMEM_DEVICE, O_RDWR);\n  if (fd < 0)\n    return fd;\n\n  sprintf(ourkey, \"%d\", __key);\n  ret = ioctl(fd, ASHMEM_SET_NAME, ourkey);\n  if (ret < 0)\n    goto error;\n\n  ret = ioctl(fd, ASHMEM_SET_SIZE, __size);\n  if (ret < 0)\n    goto error;\n\n  return fd;\n\nerror:\n  close(fd);\n  return ret;\n}\n\nstatic inline void *shmat(int __shmid, const void *__shmaddr, int __shmflg) {\n  (void) __shmflg;\n  int size;\n  void *ptr;\n\n  size = ioctl(__shmid, ASHMEM_GET_SIZE, NULL);\n  if (size < 0) {\n    return NULL;\n  }\n\n  ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, __shmid, 0);\n  if (ptr == MAP_FAILED) {\n    return NULL;\n  }\n\n  return ptr;\n}\n\n#endif /* !_ANDROID_ASHMEM_H */\n#endif /* !__ANDROID__ */\n"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 11.3720703125,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - vaguely configurable bits\n   ----------------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n*/\n\n#ifndef _HAVE_CONFIG_H\n#define _HAVE_CONFIG_H\n\n#include \"types.h\"\n\n/* Version string: */\n\n#define VERSION             \"2.57b\"\n\n/******************************************************\n *                                                    *\n *  Settings that may be of interest to power users:  *\n *                                                    *\n ******************************************************/\n\n/* Comment out to disable terminal colors (note that this makes afl-analyze\n   a lot less nice): */\n\n#define USE_COLOR\n\n/* Comment out to disable fancy ANSI boxes and use poor man's 7-bit UI: */\n\n#define FANCY_BOXES\n\n/* Default timeout for fuzzed code (milliseconds). This is the upper bound,\n   also used for detecting hangs; the actual value is auto-scaled: */\n\n#define EXEC_TIMEOUT        1000\n\n/* Timeout rounding factor when auto-scaling (milliseconds): */\n\n#define EXEC_TM_ROUND       20\n\n/* 64bit arch MACRO */\n#if (defined (__x86_64__) || defined (__arm64__) || defined (__aarch64__))\n#define WORD_SIZE_64 1\n#endif\n\n/* Default memory limit for child process (MB): */\n\n#ifndef WORD_SIZE_64\n#  define MEM_LIMIT         25\n#else\n#  define MEM_LIMIT         50\n#endif /* ^!WORD_SIZE_64 */\n\n/* Default memory limit when running in QEMU mode (MB): */\n\n#define MEM_LIMIT_QEMU      200\n\n/* Number of calibration cycles per every new test case (and for test\n   cases that show variable behavior): */\n\n#define CAL_CYCLES          8\n#define CAL_CYCLES_LONG     40\n\n/* Number of subsequent timeouts before abandoning an input file: */\n\n#define TMOUT_LIMIT         250\n\n/* Maximum number of unique hangs or crashes to record: */\n\n#define KEEP_UNIQUE_HANG    500\n#define KEEP_UNIQUE_CRASH   5000\n\n/* Baseline number of random tweaks during a single 'havoc' stage: */\n\n#define HAVOC_CYCLES        256\n#define HAVOC_CYCLES_INIT   1024\n\n/* Maximum multiplier for the above (should be a power of two, beware\n   of 32-bit int overflows): */\n\n#define HAVOC_MAX_MULT      16\n\n/* Absolute minimum number of havoc cycles (after all adjustments): */\n\n#define HAVOC_MIN           16\n\n/* Maximum stacking for havoc-stage tweaks. The actual value is calculated\n   like this: \n\n   n = random between 1 and HAVOC_STACK_POW2\n   stacking = 2^n\n\n   In other words, the default (n = 7) produces 2, 4, 8, 16, 32, 64, or\n   128 stacked tweaks: */\n\n#define HAVOC_STACK_POW2    7\n\n/* Caps on block sizes for cloning and deletion operations. Each of these\n   ranges has a 33% probability of getting picked, except for the first\n   two cycles where smaller blocks are favored: */\n\n#define HAVOC_BLK_SMALL     32\n#define HAVOC_BLK_MEDIUM    128\n#define HAVOC_BLK_LARGE     1500\n\n/* Extra-large blocks, selected very rarely (<5% of the time): */\n\n#define HAVOC_BLK_XL        32768\n\n/* Probabilities of skipping non-favored entries in the queue, expressed as\n   percentages: */\n\n#define SKIP_TO_NEW_PROB    99 /* ...when there are new, pending favorites */\n#define SKIP_NFAV_OLD_PROB  95 /* ...no new favs, cur entry already fuzzed */\n#define SKIP_NFAV_NEW_PROB  75 /* ...no new favs, cur entry not fuzzed yet */\n\n/* Splicing cycle count: */\n\n#define SPLICE_CYCLES       15\n\n/* Nominal per-splice havoc cycle length: */\n\n#define SPLICE_HAVOC        32\n\n/* Maximum offset for integer addition / subtraction stages: */\n\n#define ARITH_MAX           35\n\n/* Limits for the test case trimmer. The absolute minimum chunk size; and\n   the starting and ending divisors for chopping up the input file: */\n\n#define TRIM_MIN_BYTES      4\n#define TRIM_START_STEPS    16\n#define TRIM_END_STEPS      1024\n\n/* Maximum size of input file, in bytes (keep under 100MB): */\n\n#define MAX_FILE            (1 * 1024 * 1024)\n\n/* The same, for the test case minimizer: */\n\n#define TMIN_MAX_FILE       (10 * 1024 * 1024)\n\n/* Block normalization steps for afl-tmin: */\n\n#define TMIN_SET_MIN_SIZE   4\n#define TMIN_SET_STEPS      128\n\n/* Maximum dictionary token size (-x), in bytes: */\n\n#define MAX_DICT_FILE       128\n\n/* Length limits for auto-detected dictionary tokens: */\n\n#define MIN_AUTO_EXTRA      3\n#define MAX_AUTO_EXTRA      32\n\n/* Maximum number of user-specified dictionary tokens to use in deterministic\n   steps; past this point, the \"extras/user\" step will be still carried out,\n   but with proportionally lower odds: */\n\n#define MAX_DET_EXTRAS      200\n\n/* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing\n   (first value), and to keep in memory as candidates. The latter should be much\n   higher than the former. */\n\n#define USE_AUTO_EXTRAS     50\n#define MAX_AUTO_EXTRAS     (USE_AUTO_EXTRAS * 10)\n\n/* Scaling factor for the effector map used to skip some of the more\n   expensive deterministic steps. The actual divisor is set to\n   2^EFF_MAP_SCALE2 bytes: */\n\n#define EFF_MAP_SCALE2      3\n\n/* Minimum input file length at which the effector logic kicks in: */\n\n#define EFF_MIN_LEN         128\n\n/* Maximum effector density past which everything is just fuzzed\n   unconditionally (%): */\n\n#define EFF_MAX_PERC        90\n\n/* UI refresh frequency (Hz): */\n\n#define UI_TARGET_HZ        5\n\n/* Fuzzer stats file and plot update intervals (sec): */\n\n#define STATS_UPDATE_SEC    60\n#define PLOT_UPDATE_SEC     5\n\n/* Smoothing divisor for CPU load and exec speed stats (1 - no smoothing). */\n\n#define AVG_SMOOTHING       16\n\n/* Sync interval (every n havoc cycles): */\n\n#define SYNC_INTERVAL       5\n\n/* Output directory reuse grace period (minutes): */\n\n#define OUTPUT_GRACE        25\n\n/* Uncomment to use simple file names (id_NNNNNN): */\n\n// #define SIMPLE_FILES\n\n/* List of interesting values to use in fuzzing. */\n\n#define INTERESTING_8 \\\n  -128,          /* Overflow signed 8-bit when decremented  */ \\\n  -1,            /*                                         */ \\\n   0,            /*                                         */ \\\n   1,            /*                                         */ \\\n   16,           /* One-off with common buffer size         */ \\\n   32,           /* One-off with common buffer size         */ \\\n   64,           /* One-off with common buffer size         */ \\\n   100,          /* One-off with common buffer size         */ \\\n   127           /* Overflow signed 8-bit when incremented  */\n\n#define INTERESTING_16 \\\n  -32768,        /* Overflow signed 16-bit when decremented */ \\\n  -129,          /* Overflow signed 8-bit                   */ \\\n   128,          /* Overflow signed 8-bit                   */ \\\n   255,          /* Overflow unsig 8-bit when incremented   */ \\\n   256,          /* Overflow unsig 8-bit                    */ \\\n   512,          /* One-off with common buffer size         */ \\\n   1000,         /* One-off with common buffer size         */ \\\n   1024,         /* One-off with common buffer size         */ \\\n   4096,         /* One-off with common buffer size         */ \\\n   32767         /* Overflow signed 16-bit when incremented */\n\n#define INTERESTING_32 \\\n  -2147483648LL, /* Overflow signed 32-bit when decremented */ \\\n  -100663046,    /* Large negative number (endian-agnostic) */ \\\n  -32769,        /* Overflow signed 16-bit                  */ \\\n   32768,        /* Overflow signed 16-bit                  */ \\\n   65535,        /* Overflow unsig 16-bit when incremented  */ \\\n   65536,        /* Overflow unsig 16 bit                   */ \\\n   100663045,    /* Large positive number (endian-agnostic) */ \\\n   2147483647    /* Overflow signed 32-bit when incremented */\n\n/***********************************************************\n *                                                         *\n *  Really exotic stuff you probably don't want to touch:  *\n *                                                         *\n ***********************************************************/\n\n/* Call count interval between reseeding the libc PRNG from /dev/urandom: */\n\n#define RESEED_RNG          10000\n\n/* Maximum line length passed from GCC to 'as' and used for parsing\n   configuration files: */\n\n#define MAX_LINE            8192\n\n/* Environment variable used to pass SHM ID to the called program. */\n\n#define SHM_ENV_VAR         \"__AFL_SHM_ID\"\n\n/* Other less interesting, internal-only variables. */\n\n#define CLANG_ENV_VAR       \"__AFL_CLANG_MODE\"\n#define AS_LOOP_ENV_VAR     \"__AFL_AS_LOOPCHECK\"\n#define PERSIST_ENV_VAR     \"__AFL_PERSISTENT\"\n#define DEFER_ENV_VAR       \"__AFL_DEFER_FORKSRV\"\n\n/* In-code signatures for deferred and persistent mode. */\n\n#define PERSIST_SIG         \"##SIG_AFL_PERSISTENT##\"\n#define DEFER_SIG           \"##SIG_AFL_DEFER_FORKSRV##\"\n\n/* Distinctive bitmap signature used to indicate failed execution: */\n\n#define EXEC_FAIL_SIG       0xfee1dead\n\n/* Distinctive exit code used to indicate MSAN trip condition: */\n\n#define MSAN_ERROR          86\n\n/* Designated file descriptors for forkserver commands (the application will\n   use FORKSRV_FD and FORKSRV_FD + 1): */\n\n#define FORKSRV_FD          198\n\n/* Fork server init timeout multiplier: we'll wait the user-selected\n   timeout plus this much for the fork server to spin up. */\n\n#define FORK_WAIT_MULT      10\n\n/* Calibration timeout adjustments, to be a bit more generous when resuming\n   fuzzing sessions or trying to calibrate already-added internal finds.\n   The first value is a percentage, the other is in milliseconds: */\n\n#define CAL_TMOUT_PERC      125\n#define CAL_TMOUT_ADD       50\n\n/* Number of chances to calibrate a case before giving up: */\n\n#define CAL_CHANCES         3\n\n/* Map size for the traced binary (2^MAP_SIZE_POW2). Must be greater than\n   2; you probably want to keep it under 18 or so for performance reasons\n   (adjusting AFL_INST_RATIO when compiling is probably a better way to solve\n   problems with complex programs). You need to recompile the target binary\n   after changing this - otherwise, SEGVs may ensue. */\n\n#define MAP_SIZE_POW2       16\n#define MAP_SIZE            (1 << MAP_SIZE_POW2)\n\n/* Maximum allocator request size (keep well under INT_MAX): */\n\n#define MAX_ALLOC           0x40000000\n\n/* A made-up hashing seed: */\n\n#define HASH_CONST          0xa5b35705\n\n/* Constants for afl-gotcpu to control busy loop timing: */\n\n#define  CTEST_TARGET_MS    5000\n#define  CTEST_CORE_TRG_MS  1000\n#define  CTEST_BUSY_CYCLES  (10 * 1000 * 1000)\n\n/* Uncomment this to use inferior block-coverage-based instrumentation. Note\n   that you need to recompile the target binary for this to have any effect: */\n\n// #define COVERAGE_ONLY\n\n/* Uncomment this to ignore hit counts and output just one bit per tuple.\n   As with the previous setting, you will need to recompile the target\n   binary: */\n\n// #define SKIP_COUNTS\n\n/* Uncomment this to use instrumentation data to record newly discovered paths,\n   but do not use them as seeds for fuzzing. This is useful for conveniently\n   measuring coverage that could be attained by a \"dumb\" fuzzing algorithm: */\n\n// #define IGNORE_FINDS\n\n#endif /* ! _HAVE_CONFIG_H */\n"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 6.7099609375,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - debug / error handling macros\n   --------------------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n*/\n\n#ifndef _HAVE_DEBUG_H\n#define _HAVE_DEBUG_H\n\n#include <errno.h>\n\n#include \"types.h\"\n#include \"config.h\"\n\n/*******************\n * Terminal colors *\n *******************/\n\n#ifdef USE_COLOR\n\n#  define cBLK \"\\x1b[0;30m\"\n#  define cRED \"\\x1b[0;31m\"\n#  define cGRN \"\\x1b[0;32m\"\n#  define cBRN \"\\x1b[0;33m\"\n#  define cBLU \"\\x1b[0;34m\"\n#  define cMGN \"\\x1b[0;35m\"\n#  define cCYA \"\\x1b[0;36m\"\n#  define cLGR \"\\x1b[0;37m\"\n#  define cGRA \"\\x1b[1;90m\"\n#  define cLRD \"\\x1b[1;91m\"\n#  define cLGN \"\\x1b[1;92m\"\n#  define cYEL \"\\x1b[1;93m\"\n#  define cLBL \"\\x1b[1;94m\"\n#  define cPIN \"\\x1b[1;95m\"\n#  define cLCY \"\\x1b[1;96m\"\n#  define cBRI \"\\x1b[1;97m\"\n#  define cRST \"\\x1b[0m\"\n\n#  define bgBLK \"\\x1b[40m\"\n#  define bgRED \"\\x1b[41m\"\n#  define bgGRN \"\\x1b[42m\"\n#  define bgBRN \"\\x1b[43m\"\n#  define bgBLU \"\\x1b[44m\"\n#  define bgMGN \"\\x1b[45m\"\n#  define bgCYA \"\\x1b[46m\"\n#  define bgLGR \"\\x1b[47m\"\n#  define bgGRA \"\\x1b[100m\"\n#  define bgLRD \"\\x1b[101m\"\n#  define bgLGN \"\\x1b[102m\"\n#  define bgYEL \"\\x1b[103m\"\n#  define bgLBL \"\\x1b[104m\"\n#  define bgPIN \"\\x1b[105m\"\n#  define bgLCY \"\\x1b[106m\"\n#  define bgBRI \"\\x1b[107m\"\n\n#else\n\n#  define cBLK \"\"\n#  define cRED \"\"\n#  define cGRN \"\"\n#  define cBRN \"\"\n#  define cBLU \"\"\n#  define cMGN \"\"\n#  define cCYA \"\"\n#  define cLGR \"\"\n#  define cGRA \"\"\n#  define cLRD \"\"\n#  define cLGN \"\"\n#  define cYEL \"\"\n#  define cLBL \"\"\n#  define cPIN \"\"\n#  define cLCY \"\"\n#  define cBRI \"\"\n#  define cRST \"\"\n\n#  define bgBLK \"\"\n#  define bgRED \"\"\n#  define bgGRN \"\"\n#  define bgBRN \"\"\n#  define bgBLU \"\"\n#  define bgMGN \"\"\n#  define bgCYA \"\"\n#  define bgLGR \"\"\n#  define bgGRA \"\"\n#  define bgLRD \"\"\n#  define bgLGN \"\"\n#  define bgYEL \"\"\n#  define bgLBL \"\"\n#  define bgPIN \"\"\n#  define bgLCY \"\"\n#  define bgBRI \"\"\n\n#endif /* ^USE_COLOR */\n\n/*************************\n * Box drawing sequences *\n *************************/\n\n#ifdef FANCY_BOXES\n\n#  define SET_G1   \"\\x1b)0\"       /* Set G1 for box drawing    */\n#  define RESET_G1 \"\\x1b)B\"       /* Reset G1 to ASCII         */\n#  define bSTART   \"\\x0e\"         /* Enter G1 drawing mode     */\n#  define bSTOP    \"\\x0f\"         /* Leave G1 drawing mode     */\n#  define bH       \"q\"            /* Horizontal line           */\n#  define bV       \"x\"            /* Vertical line             */\n#  define bLT      \"l\"            /* Left top corner           */\n#  define bRT      \"k\"            /* Right top corner          */\n#  define bLB      \"m\"            /* Left bottom corner        */\n#  define bRB      \"j\"            /* Right bottom corner       */\n#  define bX       \"n\"            /* Cross                     */\n#  define bVR      \"t\"            /* Vertical, branch right    */\n#  define bVL      \"u\"            /* Vertical, branch left     */\n#  define bHT      \"v\"            /* Horizontal, branch top    */\n#  define bHB      \"w\"            /* Horizontal, branch bottom */\n\n#else\n\n#  define SET_G1   \"\"\n#  define RESET_G1 \"\"\n#  define bSTART   \"\"\n#  define bSTOP    \"\"\n#  define bH       \"-\"\n#  define bV       \"|\"\n#  define bLT      \"+\"\n#  define bRT      \"+\"\n#  define bLB      \"+\"\n#  define bRB      \"+\"\n#  define bX       \"+\"\n#  define bVR      \"+\"\n#  define bVL      \"+\"\n#  define bHT      \"+\"\n#  define bHB      \"+\"\n\n#endif /* ^FANCY_BOXES */\n\n/***********************\n * Misc terminal codes *\n ***********************/\n\n#define TERM_HOME     \"\\x1b[H\"\n#define TERM_CLEAR    TERM_HOME \"\\x1b[2J\"\n#define cEOL          \"\\x1b[0K\"\n#define CURSOR_HIDE   \"\\x1b[?25l\"\n#define CURSOR_SHOW   \"\\x1b[?25h\"\n\n/************************\n * Debug & error macros *\n ************************/\n\n/* Just print stuff to the appropriate stream. */\n\n#ifdef MESSAGES_TO_STDOUT\n#  define SAYF(x...)    printf(x)\n#else \n#  define SAYF(x...)    fprintf(stderr, x)\n#endif /* ^MESSAGES_TO_STDOUT */\n\n/* Show a prefixed warning. */\n\n#define WARNF(x...) do { \\\n    SAYF(cYEL \"[!] \" cBRI \"WARNING: \" cRST x); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Show a prefixed \"doing something\" message. */\n\n#define ACTF(x...) do { \\\n    SAYF(cLBL \"[*] \" cRST x); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Show a prefixed \"success\" message. */\n\n#define OKF(x...) do { \\\n    SAYF(cLGN \"[+] \" cRST x); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Show a prefixed fatal error message (not used in afl). */\n\n#define BADF(x...) do { \\\n    SAYF(cLRD \"\\n[-] \" cRST x); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Die with a verbose non-OS fatal error message. */\n\n#define FATAL(x...) do { \\\n    SAYF(bSTOP RESET_G1 CURSOR_SHOW cRST cLRD \"\\n[-] PROGRAM ABORT : \" \\\n         cBRI x); \\\n    SAYF(cLRD \"\\n         Location : \" cRST \"%s(), %s:%u\\n\\n\", \\\n         __FUNCTION__, __FILE__, __LINE__); \\\n    exit(1); \\\n  } while (0)\n\n/* Die by calling abort() to provide a core dump. */\n\n#define ABORT(x...) do { \\\n    SAYF(bSTOP RESET_G1 CURSOR_SHOW cRST cLRD \"\\n[-] PROGRAM ABORT : \" \\\n         cBRI x); \\\n    SAYF(cLRD \"\\n    Stop location : \" cRST \"%s(), %s:%u\\n\\n\", \\\n         __FUNCTION__, __FILE__, __LINE__); \\\n    abort(); \\\n  } while (0)\n\n/* Die while also including the output of perror(). */\n\n#define PFATAL(x...) do { \\\n    fflush(stdout); \\\n    SAYF(bSTOP RESET_G1 CURSOR_SHOW cRST cLRD \"\\n[-]  SYSTEM ERROR : \" \\\n         cBRI x); \\\n    SAYF(cLRD \"\\n    Stop location : \" cRST \"%s(), %s:%u\\n\", \\\n         __FUNCTION__, __FILE__, __LINE__); \\\n    SAYF(cLRD \"       OS message : \" cRST \"%s\\n\", strerror(errno)); \\\n    exit(1); \\\n  } while (0)\n\n/* Die with FAULT() or PFAULT() depending on the value of res (used to\n   interpret different failure modes for read(), write(), etc). */\n\n#define RPFATAL(res, x...) do { \\\n    if (res < 0) PFATAL(x); else FATAL(x); \\\n  } while (0)\n\n/* Error-checking versions of read() and write() that call RPFATAL() as\n   appropriate. */\n\n#define ck_write(fd, buf, len, fn) do { \\\n    u32 _len = (len); \\\n    s32 _res = write(fd, buf, _len); \\\n    if (_res != _len) RPFATAL(_res, \"Short write to %s\", fn); \\\n  } while (0)\n\n#define ck_read(fd, buf, len, fn) do { \\\n    u32 _len = (len); \\\n    s32 _res = read(fd, buf, _len); \\\n    if (_res != _len) RPFATAL(_res, \"Short read from %s\", fn); \\\n  } while (0)\n\n#endif /* ! _HAVE_DEBUG_H */\n"
        },
        {
          "name": "dictionaries",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "experimental",
          "type": "tree",
          "content": null
        },
        {
          "name": "hash.h",
          "type": "blob",
          "size": 2.32421875,
          "content": "/*\n  Copyright 2016 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n/*\n   american fuzzy lop - hashing function\n   -------------------------------------\n\n   The hash32() function is a variant of MurmurHash3, a good\n   non-cryptosafe hashing function developed by Austin Appleby.\n\n   For simplicity, this variant does *NOT* accept buffer lengths\n   that are not divisible by 8 bytes. The 32-bit version is otherwise\n   similar to the original; the 64-bit one is a custom hack with\n   mostly-unproven properties.\n\n   Austin's original code is public domain.\n\n   Other code written and maintained by Michal Zalewski <lcamtuf@google.com>\n*/\n\n#ifndef _HAVE_HASH_H\n#define _HAVE_HASH_H\n\n#include \"types.h\"\n\n#ifdef __x86_64__\n\n#define ROL64(_x, _r)  ((((u64)(_x)) << (_r)) | (((u64)(_x)) >> (64 - (_r))))\n\nstatic inline u32 hash32(const void* key, u32 len, u32 seed) {\n\n  const u64* data = (u64*)key;\n  u64 h1 = seed ^ len;\n\n  len >>= 3;\n\n  while (len--) {\n\n    u64 k1 = *data++;\n\n    k1 *= 0x87c37b91114253d5ULL;\n    k1  = ROL64(k1, 31);\n    k1 *= 0x4cf5ad432745937fULL;\n\n    h1 ^= k1;\n    h1  = ROL64(h1, 27);\n    h1  = h1 * 5 + 0x52dce729;\n\n  }\n\n  h1 ^= h1 >> 33;\n  h1 *= 0xff51afd7ed558ccdULL;\n  h1 ^= h1 >> 33;\n  h1 *= 0xc4ceb9fe1a85ec53ULL;\n  h1 ^= h1 >> 33;\n\n  return h1;\n\n}\n\n#else \n\n#define ROL32(_x, _r)  ((((u32)(_x)) << (_r)) | (((u32)(_x)) >> (32 - (_r))))\n\nstatic inline u32 hash32(const void* key, u32 len, u32 seed) {\n\n  const u32* data  = (u32*)key;\n  u32 h1 = seed ^ len;\n\n  len >>= 2;\n\n  while (len--) {\n\n    u32 k1 = *data++;\n\n    k1 *= 0xcc9e2d51;\n    k1  = ROL32(k1, 15);\n    k1 *= 0x1b873593;\n\n    h1 ^= k1;\n    h1  = ROL32(h1, 13);\n    h1  = h1 * 5 + 0xe6546b64;\n\n  }\n\n  h1 ^= h1 >> 16;\n  h1 *= 0x85ebca6b;\n  h1 ^= h1 >> 13;\n  h1 *= 0xc2b2ae35;\n  h1 ^= h1 >> 16;\n\n  return h1;\n\n}\n\n#endif /* ^__x86_64__ */\n\n#endif /* !_HAVE_HASH_H */\n"
        },
        {
          "name": "libdislocator",
          "type": "tree",
          "content": null
        },
        {
          "name": "libtokencap",
          "type": "tree",
          "content": null
        },
        {
          "name": "llvm_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "qemu_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "test-instr.c",
          "type": "blob",
          "size": 1.0791015625,
          "content": "/*\n  Copyright 2014 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n\n/*\n   american fuzzy lop - a trivial program to test the build\n   --------------------------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char** argv) {\n\n  char buf[8];\n\n  if (read(0, buf, 8) < 1) {\n    printf(\"Hum?\\n\");\n    exit(1);\n  }\n\n  if (buf[0] == '0')\n    printf(\"Looks like a zero to me!\\n\");\n  else\n    printf(\"A non-zero value? How quaint!\\n\");\n\n  exit(0);\n\n}\n"
        },
        {
          "name": "test-libfuzzer-target.c",
          "type": "blob",
          "size": 1.1513671875,
          "content": "/*\n  Copyright 2019 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n\n/*\n   american fuzzy lop - a trivial program to test libFuzzer target fuzzing.\n   ------------------------------------------------------------------------\n\n   Initially written and maintained by Michal Zalewski.\n*/\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n\n// TODO(metzman): Create a test/ directory to store this and other similar\n// files.\nint LLVMFuzzerTestOneInput(uint8_t* buf, size_t size) {\n  if (size < 2)\n    return 0;\n\n  if (buf[0] == '0')\n    printf(\"Looks like a zero to me!\\n\");\n  else\n    printf(\"A non-zero value? How quaint!\\n\");\n\n  return 0;\n}\n"
        },
        {
          "name": "testcases",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.h",
          "type": "blob",
          "size": 2.5390625,
          "content": "/*\n  Copyright 2013 Google LLC All rights reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at:\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n\n/*\n   american fuzzy lop - type definitions and minor macros\n   ------------------------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n*/\n\n#ifndef _HAVE_TYPES_H\n#define _HAVE_TYPES_H\n\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\n\n/*\n\n   Ugh. There is an unintended compiler / glibc #include glitch caused by\n   combining the u64 type an %llu in format strings, necessitating a workaround.\n\n   In essence, the compiler is always looking for 'unsigned long long' for %llu.\n   On 32-bit systems, the u64 type (aliased to uint64_t) is expanded to\n   'unsigned long long' in <bits/types.h>, so everything checks out.\n\n   But on 64-bit systems, it is #ifdef'ed in the same file as 'unsigned long'.\n   Now, it only happens in circumstances where the type happens to have the\n   expected bit width, *but* the compiler does not know that... and complains\n   about 'unsigned long' being unsafe to pass to %llu.\n\n */\n\n#ifdef __x86_64__\ntypedef unsigned long long u64;\n#else\ntypedef uint64_t u64;\n#endif /* ^__x86_64__ */\n\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\n#ifndef MIN\n#  define MIN(_a,_b) ((_a) > (_b) ? (_b) : (_a))\n#  define MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))\n#endif /* !MIN */\n\n#define SWAP16(_x) ({ \\\n    u16 _ret = (_x); \\\n    (u16)((_ret << 8) | (_ret >> 8)); \\\n  })\n\n#define SWAP32(_x) ({ \\\n    u32 _ret = (_x); \\\n    (u32)((_ret << 24) | (_ret >> 24) | \\\n          ((_ret << 8) & 0x00FF0000) | \\\n          ((_ret >> 8) & 0x0000FF00)); \\\n  })\n\n#ifdef AFL_LLVM_PASS\n#  define AFL_R(x) (random() % (x))\n#else\n#  define R(x) (random() % (x))\n#endif /* ^AFL_LLVM_PASS */\n\n#define STRINGIFY_INTERNAL(x) #x\n#define STRINGIFY(x) STRINGIFY_INTERNAL(x)\n\n#define MEM_BARRIER() \\\n  __asm__ volatile(\"\" ::: \"memory\")\n\n#define likely(_x)   __builtin_expect(!!(_x), 1)\n#define unlikely(_x)  __builtin_expect(!!(_x), 0)\n\n#endif /* ! _HAVE_TYPES_H */\n"
        }
      ]
    }
  ]
}