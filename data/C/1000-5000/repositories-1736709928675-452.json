{
  "metadata": {
    "timestamp": 1736709928675,
    "page": 452,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "landley/toybox",
      "stars": 2472,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1201171875,
          "content": "syntax: glob\n/.config*\n/.single*\n/change/\n/generated/\n/kconfig/mconf\n/kconfig/conf\n/kconfig/*.c\n/toybox\n/toybox_unstripped\n"
        },
        {
          "name": "Config.in",
          "type": "blob",
          "size": 6.0419921875,
          "content": "mainmenu \"Toybox Configuration\"\n\n\nsource generated/Config.probed\nsource generated/Config.in\n\ncomment \"\"\n\nmenu \"Toybox global settings\"\n\n# This entry controls the multiplexer, disabled for single command builds\nconfig TOYBOX\n\tbool\n\tdefault y\n\thelp\n\t  usage: toybox [--long | --help | --version | [COMMAND] [ARGUMENTS...]]\n\n\t  With no arguments, \"toybox\" shows available COMMAND names. Add --long\n\t  to include suggested install path for each command, see\n\t  https://landley.net/toybox/faq.html#install for details.\n\n\t  First argument is name of a COMMAND to run, followed by any ARGUMENTS\n\t  to that command. Most toybox commands also understand:\n\n\t  --help\t\tShow command help (only)\n\t  --version\tShow toybox version (only)\n\n\t  The filename \"-\" means stdin/stdout, and \"--\" stops argument parsing.\n\n\t  Numerical arguments accept a single letter suffix for\n\t  kilo, mega, giga, tera, peta, and exabytes, plus an additional\n\t  \"d\" to indicate decimal 1000's instead of 1024.\n\n\t  Durations can be decimal fractions and accept minute (\"m\"), hour (\"h\"),\n\t  or day (\"d\") suffixes (so 0.1m = 6s).\n\nconfig TOYBOX_SUID\n\tbool \"SUID support\"\n\tdefault y\n\thelp\n\t  Support for the Set User ID bit, to install toybox suid root and drop\n\t  permissions for commands which do not require root access. To use\n\t  this change ownership of the file to the root user and set the suid\n\t  bit in the file permissions:\n\n\t  chown root:root toybox; chmod +s toybox\n\nchoice\n\tprompt \"Security Blanket\"\n\tdefault TOYBOX_LSM_NONE\n\thelp\n\t  Select a Linux Security Module to complicate your system\n\t  until you can't find holes in it.\n\nconfig TOYBOX_LSM_NONE\n\tbool \"None\"\n\thelp\n          Don't try to achieve \"watertight\" by plugging the holes in a\n          collander, instead use conventional unix security (and possibly\n          Linux Containers) for a simple straightforward system.\n\t  \nconfig TOYBOX_SELINUX\n\tbool \"SELinux support\"\n\thelp\n\t  Include SELinux options in commands such as ls, and add\n\t  SELinux-specific commands such as chcon to the Android menu.\n\nconfig TOYBOX_SMACK\n\tbool \"SMACK support\"\n\thelp\n\t  Include SMACK options in commands like ls for systems like Tizen.\n\nendchoice\n\nconfig TOYBOX_LIBCRYPTO\n       bool \"Use libcrypto (OpenSSL/BoringSSL)\"\n       default n\n       help\n         Use faster hash functions out of external -lcrypto library.\n\nconfig TOYBOX_LIBZ\n       bool \"Use libz (zlib)\"\n       default n\n       help\n         Use libz for gz support.\n\nconfig TOYBOX_FLOAT\n\tbool \"Floating point support\"\n\tdefault y\n\thelp\n\t  Include floating point support infrastructure and commands that\n\t  require it.\n\nconfig TOYBOX_HELP\n\tbool \"Help messages\"\n\tdefault y\n\thelp\n\t  Include help text for each command.\n\nconfig TOYBOX_HELP_DASHDASH\n\tbool \"--help and --version\"\n\tdefault y\n\tdepends on TOYBOX_HELP\n\thelp\n\t  Support --help argument in all commands, even ones with a NULL\n\t  optstring. (Use TOYFLAG_NOHELP to disable.) Produces the same output\n\t  as \"help command\". --version shows toybox version.\n\nconfig TOYBOX_ZHELP\n\tbool \"compress help text\"\n\tdefault y\n\tdepends on TOYBOX_HELP\n\thelp\n\t  Compress help with gzip -9, deflating when displayed. This makes the\n\t  binary smaller but can increase runtime memory usage.\n\nconfig TOYBOX_FREE\n\tbool \"Free memory unnecessarily\"\n\tdefault n\n\thelp\n\t  When a program exits, the operating system will clean up after it\n\t  (free memory, close files, etc). To save size, toybox usually relies\n\t  on this behavior. If you're running toybox under a debugger or\n\t  without a real OS (ala newlib+libgloss), enable this to make toybox\n\t  clean up after itself.\n\nconfig TOYBOX_NORECURSE\n\tbool \"Disable recursive execution\"\n\tdefault n\n\thelp\n\t  When one toybox command calls another, usually it just calls the new\n\t  command's main() function rather than searching the $PATH and calling\n\t  exec on another file (which is much slower).\n\n\t  This disables that optimization, so toybox will run external commands\n          even when it has a built-in version of that command. This requires\n          toybox symlinks to be installed in the $PATH, or re-invoking the\n          \"toybox\" multiplexer command by name.\n\nconfig TOYBOX_DEBUG\n\tbool \"Debugging tests\"\n\tdefault n\n\thelp\n\t  Enable extra checks for debugging purposes. All of them catch\n\t  things that can only go wrong at development time, not runtime.\n\nconfig TOYBOX_UID_SYS\n\tint \"First system UID\"\n\tdefault 100\n\thelp\n\t  When commands like useradd/groupadd allocate system IDs, start here.\n\nconfig TOYBOX_UID_USR\n\tint \"First user UID\"\n\tdefault 500\n\thelp\n\t  When commands like useradd/groupadd allocate user IDs, start here.\n\nconfig TOYBOX_FORCE_NOMMU\n\tbool \"Enable nommu support when the build can't detect it.\"\n\tdefault n\n\thelp\n\t  When using musl-libc on a nommu system, you'll need to say \"y\" here\n\t  unless you used the patch in the mcm-buildall.sh script. You can also\n\t  say \"y\" here to test the nommu codepaths on an mmu system.\n\n\t  A nommu system can't use fork(), it can only vfork() which suspends\n\t  the parent until the child calls exec() or exits. When a program\n\t  needs a second instance of itself to run specific code at the same\n\t  time as the parent, it must use a more complicated approach (such as\n\t  exec(\"/proc/self/exe\") then pass data to the new child through a pipe)\n\t  which is larger and slower, especially for things like toysh subshells\n\t  that need to duplicate a lot of internal state in the child process\n\t  fork() gives you for free.\n\n\t  Libraries like uclibc omit fork() on nommu systems, allowing\n\t  compile-time probes to select which codepath to use. But musl\n\t  intentionally includes a broken version of fork() that always returns\n\t  -ENOSYS on nommu systems, and goes out of its way to prevent any\n\t  cross-compile compatible compile-time probes for a nommu system.\n\t  (It doesn't even #define __MUSL__ in features.h.) Musl does this\n\t  despite the fact that a nommu system can't even run standard ELF\n\t  binaries (requiring specially packaged executables) because it wants\n\t  to force every program to either include all nommu code in every\n\t  instance ever built, or drop nommu support altogether.\n\n\t  Building a scripts/mcm-buildall.sh toolchain patches musl to fix this.\n\nendmenu\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.650390625,
          "content": "Copyright (C) 2006, 2019 by Rob Landley <rob@landley.net>\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.185546875,
          "content": "# Makefile for toybox.\n# Copyright 2006 Rob Landley <rob@landley.net>\n\n# If people set these on the make command line, use 'em\n# Note that CC defaults to \"cc\" so the one in configure doesn't get\n# used when scripts/make.sh and such called through \"make\".\n\nHOSTCC?=cc\n\nexport CROSS_COMPILE CFLAGS OPTIMIZE LDOPTIMIZE CC HOSTCC V STRIP ASAN\n\nall: toybox\n\nKCONFIG_CONFIG ?= .config\n\ntoybox generated/unstripped/toybox: $(KCONFIG_CONFIG) *.[ch] lib/*.[ch] toys/*/*.c scripts/*.sh Config.in\n\tscripts/make.sh\n\n.PHONY: clean distclean baseline bloatcheck install install_flat \\\n\tuninstall uninstall_flat tests help change \\\n\tlist list_example list_pending root run_root\n.SUFFIXES: # Disable legacy behavior\n\ninclude kconfig/Makefile\n-include .singlemake\n\n$(KCONFIG_CONFIG): $(KCONFIG_TOP)\n\t@if [ -e \"$(KCONFIG_CONFIG)\" ]; then $(MAKE) silentoldconfig; \\\n\telse echo \"Not configured (run '$(MAKE) defconfig' or '$(MAKE) menuconfig')\";\\\n\texit 1; fi\n\n$(KCONFIG_TOP): generated/Config.in generated/Config.probed\ngenerated/Config.probed: generated/Config.in\ngenerated/Config.in: toys/*/*.c scripts/genconfig.sh\n\tscripts/genconfig.sh\n\n# Development targets\nbaseline: generated/unstripped/toybox\n\t@cp generated/unstripped/toybox generated/unstripped/toybox_old\n\nbloatcheck: generated/unstripped/toybox_old generated/unstripped/toybox\n\t@scripts/probes/bloatcheck generated/unstripped/toybox_old generated/unstripped/toybox\n\ninstall_flat: toybox\n\tscripts/install.sh --symlink --force\n\ninstall_airlock: toybox\n\tscripts/install.sh --symlink --force --airlock\n\ninstall: toybox\n\tscripts/install.sh --long --symlink --force\n\nuninstall_flat:\n\tscripts/install.sh --uninstall\n\nuninstall:\n\tscripts/install.sh --long --uninstall\n\nchange:\n\tscripts/change.sh\n\nroot_clean:\n\t@rm -rf root\n\t@echo root cleaned\n\nclean::\n\t@chmod -fR 700 generated 2>/dev/null || true\n\t@rm -rf toybox generated change install .singleconfig*\n\t@echo cleaned\n\n# If singlemake was in generated/ \"make clean; make test_ls\" wouldn't work.\ndistclean: clean root_clean\n\t@rm -f toybox* .config* .singlemake\n\t@echo removed .config\n\ntests: ASAN=1\ntests: toybox\n\tscripts/test.sh\n\nroot:\n\tmkroot/mkroot.sh $(MAKEFLAGS)\n\nrun_root:\n\tcd root/\"$${CROSS:-host}\" && ./run-qemu.sh\n\nhelp::\n\t@cat scripts/help.txt\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 6.197265625,
          "content": "Toybox: all-in-one Linux command line.\n\n--- Getting started\n\nYou can download static binaries for various targets from:\n\n  http://landley.net/toybox/bin\n\nThe special name \".\" indicates the current directory (just like \"..\" means\nthe parent directory), and you can run a program that isn't in the $PATH by\nspecifying a path to it, so this should work:\n\n  wget http://landley.net/toybox/bin/toybox-x86_64\n  chmod +x toybox-x86_64\n  ./toybox-x86_64 echo hello world\n\n--- Building toybox\n\nType \"make help\" for build instructions.\n\nToybox uses the \"make menuconfig; make; make install\" idiom same as\nthe Linux kernel. Usually you want something like:\n\n  make defconfig\n  make\n  make install\n\nOr maybe:\n\n  LDFLAGS=\"--static\" CROSS_COMPILE=armv5l- make defconfig toybox\n  PREFIX=/path/to/root/filesystem/bin make install_flat\n\nThe file \"configure\" defines default values for many environment variables\nthat control the toybox build; if you export any of these variables into your\nenvironment, your value is used instead of the default in that file.\n\nThe CROSS_COMPILE argument above is optional, the default builds a version of\ntoybox to run on the current machine. Cross compiling requires an appropriately\nprefixed cross compiler toolchain, several example toolchains (built using\nthe file \"scripts/mcm-buildall.sh\" in the toybox source) are available at:\n\n  https://landley.net/toybox/downloads/binaries/toolchains/latest\n\nFor the \"CROSS_COMPILE=armv5l-\" example above, download\narmv5l-linux-musleabihf-cross.tar.xz, extract it, and add its \"bin\"\nsubdirectory to your $PATH. (And yes, the trailing - is significant,\nbecause the prefix includes a dash.)\n\nFor more about cross compiling, see:\n\n  https://landley.net/toybox/faq.html#cross\n  http://landley.net/writing/docs/cross-compiling.html\n  http://landley.net/aboriginal/architectures.html\n\nFor a more thorough description of the toybox build process, see:\n\n  http://landley.net/toybox/code.html#building\n\n--- Using toybox\n\nThe toybox build produces a multicall binary, a \"swiss-army-knife\" program\nthat acts differently depending on the name it was called by (cp, mv, cat...).\nInstalling toybox adds symlinks for each command name to the $PATH.\n\nThe special \"toybox\" command treats its first argument as the command to run.\nWith no arguments, it lists available commands. This allows you to use toybox\nwithout installing it, and is the only command that can have an arbitrary\nsuffix (hence \"toybox-armv5l\").\n\nThe \"help\" command provides information about each command (ala \"help cat\"),\nand \"help toybox\" provides general information about toybox.\n\n--- Configuring toybox\n\nIt works like the Linux kernel: allnoconfig, defconfig, and menuconfig edit\na \".config\" file that selects which features to include in the resulting\nbinary. You can save and re-use your .config file, but may want to\nrun \"make oldconfig\" to re-run the dependency resolver when migrating to\nnew versions.\n\nThe maximum sane configuration is \"make defconfig\": allyesconfig isn't\nrecommended as a starting point for toybox because it enables unfinished\ncommands, debug code, and optional dependencies your build environment may\nnot provide.\n\n--- Creating a Toybox-based Linux system\n\nToybox has a built-in simple system builder (scripts/mkroot.sh) with a\nMakefile target:\n\n  make root\n  sudo chroot root/host/fs /init\n\nType \"exit\" to get back out. If you install appropriate cross compilers and\npoint it at Linux source code, it can build simple three-package systems\nthat boot to a shell prompt under qemu:\n\n  make root CROSS_COMPILE=sh4-linux-musl- LINUX=~/linux\n  cd root/sh4\n  ./qemu-sh4.sh\n\nBy calling scripts/mkroot.sh directly you can add additional packages\nto the build, see scripts/root/dropbear as an example.\n\nThe FAQ explains this in a lot more detail:\n\n  https://landley.net/toybox/faq.html#system\n  https://landley.net/toybox/faq.html#mkroot\n\n--- Presentations\n\n1) \"Why Toybox?\" talk at the Embedded Linux Conference in 2013\n\n    outline: http://landley.net/talks/celf-2013.txt\n    video: http://youtu.be/SGmtP5Lg_t0\n\n    The https://landley.net/toybox/about.html page has nav links breaking that\n    talk down into sections.\n\n2) \"Why Public Domain?\" The rise and fall of copyleft, Ohio LinuxFest 2013\n\n    outline: http://landley.net/talks/ohio-2013.txt\n    audio: https://archive.org/download/OhioLinuxfest2013/24-Rob_Landley-The_Rise_and_Fall_of_Copyleft.mp3\n\n3) Why did I do Aboriginal Linux (which led me here)\n\n    260 slide presentation:\n      https://speakerdeck.com/landley/developing-for-non-x86-targets-using-qemu\n\n    How and why to make android self-hosting:\n      http://landley.net/aboriginal/about.html#selfhost\n\n    More backstory than strictly necessary:\n      https://landley.net/aboriginal/history.html\n\n4) What's new with toybox (ELC 2015 status update):\n\n    video: http://elinux.org/ELC_2015_Presentations\n    outline: http://landley.net/talks/celf-2015.txt\n\n5) Toybox vs BusyBox (2019 ELC talk):\n\n    outline: http://landley.net/talks/elc-2019.txt\n    video: https://www.youtube.com/watch?v=MkJkyMuBm3g\n\n--- Contributing\n\nThe three important URLs for communicating with the toybox project are:\n\n  web page: http://landley.net/toybox\n\n  mailing list: http://lists.landley.net/listinfo.cgi/toybox-landley.net\n\n  git repo: http://github.com/landley/toybox\n\nThe maintainer prefers patches be sent to the mailing list. If you use git,\nthe easy thing to do is:\n\n  git format-patch -1 $HASH\n\nThen send a file attachment. The list holds messages from non-subscribers\nfor moderation, but I usually get to them in a day or two.\n\nI download github pull requests as patches and apply them with \"git am\"\n(which avoids gratuitous merge commits). Sometimes I even remember to close\nthe pull request.\n\nIf I haven't responded to your patch after one week, feel free to remind\nme of it.\n\nAndroid's policy for toybox patches is that non-build patches should go\nupstream first (into vanilla toybox, with discussion on the toybox mailing\nlist) and then be pulled into android's toybox repo from there. (They\ngenerally resync on fridays). The exception is patches to their build scripts\n(Android.mk and the checked-in generated/* files) which go directly to AOSP.\n\n(As for the other meaning of \"contributing\", https://patreon.com/landley is\nalways welcome but I warn you up front I'm terrible about updating it.)\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 0.8837890625,
          "content": "#!/bin/bash\n\n# set environment variables used by scripts/make.sh\n\n# People run ./configure out of habit, so do \"defconfig\" for them.\n\nif [ \"$(basename \"$0\")\" == configure ]\nthen\n  echo \"Assuming you want 'make defconfig', but you should probably check the README.\"\n  make defconfig\n  exit $?\nfi\n\n# Warn about stuff, disable stupid warnings, be 8-bit clean for utf8.\n[ \"${CFLAGS/-funsigned-char//}\" == \"$CFLAGS\" ] &&\n  CFLAGS+=\" -Wall -Wundef -Werror=implicit-function-declaration -Wno-char-subscripts -Wno-pointer-sign -funsigned-char\"\n\n# Set default values if variable not already set\n: ${CC:=cc} ${HOSTCC:=cc} ${GENDIR:=generated} ${KCONFIG_CONFIG:=.config}\n: ${UNSTRIPPED:=$GENDIR/unstripped} ${OUTNAME:=toybox${TARGET:+-$TARGET}}\n: ${OPTIMIZE:=-Os -ffunction-sections -fdata-sections -fno-asynchronous-unwind-tables -fno-strict-aliasing}\n\n# We accept LDFLAGS, but by default don't have anything in it\n"
        },
        {
          "name": "kconfig",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 9.4306640625,
          "content": "/* Toybox infrastructure.\n *\n * Copyright 2006 Rob Landley <rob@landley.net>\n */\n\n#include \"toys.h\"\n\n// Populate toy_list[].\n\n#undef NEWTOY\n#undef OLDTOY\n#define NEWTOY(name, opts, flags) {#name, name##_main, OPTSTR_##name, flags},\n#define OLDTOY(name, oldname, flags) \\\n  {#name, oldname##_main, OPTSTR_##oldname, flags},\n\nstruct toy_list toy_list[] = {\n#include \"generated/newtoys.h\"\n};\n\n// global context for this command.\n\nstruct toy_context toys;\nunion global_union this;\nchar *toybox_version = TOYBOX_VERSION, toybuf[4096], libbuf[4096];\n\nstruct toy_list *toy_find(char *name)\n{\n  int top, bottom, middle;\n\n  if (!CFG_TOYBOX || strchr(name, '/')) return 0;\n\n  // Multiplexer name works as prefix, else skip first entry (it's out of order)\n  if (!toys.which && strstart(&name, toy_list->name)) return toy_list;\n  bottom = 1;\n\n  // Binary search to find this command.\n  top = ARRAY_LEN(toy_list)-1;\n  for (;;) {\n    int result;\n\n    middle = (top+bottom)/2;\n    if (middle<bottom || middle>top) return 0;\n    result = strcmp(name,toy_list[middle].name);\n    if (!result) return toy_list+middle;\n    if (result<0) top = --middle;\n    else bottom = ++middle;\n  }\n}\n\n// Figure out whether or not anything is using the option parsing logic,\n// because the compiler can't figure out whether or not to optimize it away\n// on its' own.  NEED_OPTIONS becomes a constant allowing if() to optimize\n// stuff out via dead code elimination.\n\n#undef NEWTOY\n#undef OLDTOY\n#define NEWTOY(name, opts, flags) opts ||\n#define OLDTOY(name, oldname, flags) OPTSTR_##oldname ||\nstatic const int NEED_OPTIONS =\n#include \"generated/newtoys.h\"\n0;  // Ends the opts || opts || opts...\n\n// Populate help text array\n\n#undef NEWTOY\n#undef OLDTOY\n#define NEWTOY(name,opt,flags) HELP_##name \"\\0\"\n#if CFG_TOYBOX\n#define OLDTOY(name,oldname,flags) \"\\xff\" #oldname \"\\0\"\n#else\n#define OLDTOY(name, oldname, flags) HELP_##oldname \"\\0\"\n#endif\n\n#include \"generated/help.h\"\nstatic const char help_data[] =\n#include \"generated/newtoys.h\"\n;\n\n#if CFG_TOYBOX_ZHELP\n#include \"generated/zhelp.h\"\n#else\nstatic char *zhelp_data = 0;\n#define ZHELP_LEN 0\n#endif\n\nvoid show_help(FILE *out, int flags)\n{\n  int i = toys.which-toy_list;\n  char *s, *ss, *hd;\n\n  if (!CFG_TOYBOX_HELP) return;\n\n  if (CFG_TOYBOX_ZHELP)\n    gunzip_mem(zhelp_data, sizeof(zhelp_data), hd = xmalloc(ZHELP_LEN),\n      ZHELP_LEN);\n  else hd = (void *)help_data;\n\n  if (flags & HELP_HEADER)\n    fprintf(out, \"Toybox %s\"USE_TOYBOX(\" multicall binary\")\"%s\\n\\n\",\n      toybox_version, (CFG_TOYBOX && i) ? \" (see toybox --help)\"\n      : \" (see https://landley.net/toybox)\");\n\n  for (;;) {\n    s = (void *)help_data;\n    while (i--) s += strlen(s) + 1;\n    // If it's an alias, restart search for real name\n    if (*s != 255) break;\n    i = toy_find(++s)-toy_list;\n    if ((flags & HELP_SEE) && toy_list[i].flags) {\n      if (flags & HELP_HTML) fprintf(out, \"See <a href=#%s>%s</a>\\n\", s, s);\n      else fprintf(out, \"%s see %s\\n\", toys.which->name, s);\n\n      return;\n    }\n  }\n\n  if (!(flags & HELP_USAGE)) fprintf(out, \"%s\\n\", s);\n  else {\n    strstart(&s, \"usage: \");\n    for (ss = s; *ss && *ss!='\\n'; ss++);\n    fprintf(out, \"%.*s\\n\", (int)(ss-s), s);\n  }\n}\n\nstatic void unknown(char *name)\n{\n  toys.exitval = 127;\n  toys.which = toy_list;\n  help_exit(\"Unknown command %s\", name);\n}\n\n// Parse --help and --version for (almost) all commands\nvoid check_help(char **arg)\n{\n  long flags = toys.which->flags;\n\n  if (!CFG_TOYBOX_HELP_DASHDASH || !*arg) return;\n  if (!CFG_TOYBOX || toys.which!=toy_list) if (flags&TOYFLAG_NOHELP) return;\n\n  if (!strcmp(*arg, \"--help\")) {\n    if (CFG_TOYBOX && toys.which == toy_list && arg[1]) {\n      toys.which = 0;\n      if (!(toys.which = toy_find(arg[1]))) unknown(arg[1]);\n    }\n    show_help(stdout, HELP_HEADER);\n    xexit();\n  }\n\n  if (!strcmp(*arg, \"--version\")) {\n    // Lie to autoconf when it asks stupid questions, so configure regexes\n    // that look for \"GNU sed version %f\" greater than some old buggy number\n    // don't fail us for not matching their narrow expectations.\n    *toybuf = 0;\n    if (flags&TOYFLAG_AUTOCONF)\n      sprintf(toybuf, \" (is not GNU %s 9.0)\", toys.which->name);\n    xprintf(\"toybox %s%s\\n\", toybox_version, toybuf);\n    xexit();\n  }\n}\n\n// Setup toybox global state for this command.\nvoid toy_singleinit(struct toy_list *which, char *argv[])\n{\n  toys.which = which;\n  toys.argv = argv;\n  toys.toycount = ARRAY_LEN(toy_list);\n\n  if (NEED_OPTIONS && which->options) get_optflags();\n  else {\n    check_help(toys.optargs = argv+1);\n    for (toys.optc = 0; toys.optargs[toys.optc]; toys.optc++);\n  }\n\n  // Setup we only want to do once: skip for multiplexer or NOFORK reentry\n  if (!(CFG_TOYBOX && which == toy_list) && !(which->flags & TOYFLAG_NOFORK)) {\n    char *buf = 0;\n    int btype = _IOFBF;\n\n    toys.old_umask = umask(0);\n    if (!(which->flags & TOYFLAG_UMASK)) umask(toys.old_umask);\n\n    // Try user's locale, but if that isn't UTF-8 merge in a UTF-8 locale's\n    // character type data. (Fall back to en_US for MacOS.)\n    setlocale(LC_CTYPE, \"\");\n    if (strcmp(\"UTF-8\", nl_langinfo(CODESET)))\n      uselocale(newlocale(LC_CTYPE_MASK, \"C.UTF-8\", 0) ? :\n        newlocale(LC_CTYPE_MASK, \"en_US.UTF-8\", 0));\n\n    if (which->flags & TOYFLAG_LINEBUF) btype = _IOLBF;\n    else if (which->flags & TOYFLAG_NOBUF) btype = _IONBF;\n    else buf = xmalloc(4096);\n    setvbuf(stdout, buf, btype, buf ? 4096 : 0);\n  }\n}\n\n// Full init needed by multiplexer or reentrant calls, calls singleinit at end\nvoid toy_init(struct toy_list *which, char *argv[])\n{\n  void *oldwhich = toys.which;\n\n  // Drop permissions for non-suid commands.\n  if (CFG_TOYBOX_SUID) {\n    if (!toys.which) toys.which = toy_list;\n\n    uid_t uid = getuid(), euid = geteuid();\n\n    if (!(which->flags & TOYFLAG_STAYROOT)) {\n      if (uid != euid) {\n        if (setuid(uid)) perror_exit(\"setuid %d->%d\", euid, uid); // drop root\n        euid = uid;\n        toys.wasroot++;\n      }\n    } else if (CFG_TOYBOX_DEBUG && uid && which != toy_list)\n      error_msg(\"Not installed suid root\");\n\n    if ((which->flags & TOYFLAG_NEEDROOT) && euid) {\n      toys.which = which;\n      check_help(argv+1);\n      help_exit(\"Not root\");\n    }\n  }\n\n  memset(&toys, 0, offsetof(struct toy_context, rebound));\n  if (oldwhich) memset(&this, 0, sizeof(this));\n\n  // Continue to portion of init needed by standalone commands\n  toy_singleinit(which, argv);\n}\n\n// Run an internal toybox command.\n// Only returns if it can't run command internally, otherwise xexit() when done.\nvoid toy_exec_which(struct toy_list *which, char *argv[])\n{\n  // Return if we can't find it (which includes no multiplexer case),\n  if (!which || (which->flags&TOYFLAG_NOFORK)) return;\n\n  // Return if stack depth getting noticeable (proxy for leaked heap, etc).\n\n  // Compiler writers have decided subtracting char * is undefined behavior,\n  // so convert to integers. (LP64 says sizeof(long)==sizeof(pointer).)\n  // Signed typecast so stack growth direction is irrelevant: we're measuring\n  // the distance between two pointers on the same stack, hence the labs().\n  if (!CFG_TOYBOX_NORECURSE && toys.stacktop)\n    if (labs((long)toys.stacktop-(long)&which)>24000) return;\n\n  // Return if we need to re-exec to acquire root via suid bit.\n  if (toys.which && (which->flags&TOYFLAG_ROOTONLY) && toys.wasroot) return;\n\n  // Run command\n  toy_init(which, argv);\n  if (toys.which) toys.which->toy_main();\n  xexit();\n}\n\n// Lookup internal toybox command to run via argv[0]\nvoid toy_exec(char *argv[])\n{\n  toy_exec_which(toy_find(*argv), argv);\n}\n\n// Multiplexer command, first argument is command to run, rest are args to that.\n// If first argument starts with - output list of command install paths.\nvoid toybox_main(void)\n{\n  char *toy_paths[] = {\"usr/\", \"bin/\", \"sbin/\", 0}, *s = toys.argv[1];\n  int i, len = 0;\n  unsigned width = 80;\n\n  // fast path: try to exec immediately.\n  // (Leave toys.which null to disable suid return logic.)\n  // Try dereferencing symlinks until we hit a recognized name\n  while (s) {\n    char *ss = basename(s);\n    struct toy_list *tl = toy_find(ss);\n\n    if (tl==toy_list && s!=toys.argv[1]) unknown(ss);\n    toy_exec_which(tl, toys.argv+1);\n    s = (0<readlink(s, libbuf, sizeof(libbuf))) ? libbuf : 0;\n  }\n\n  // For early error reporting\n  toys.which = toy_list;\n\n  if (toys.argv[1] && strcmp(toys.argv[1], \"--long\")) unknown(toys.argv[1]);\n\n  // Output list of commands.\n  terminal_size(&width, 0);\n  for (i = 1; i<ARRAY_LEN(toy_list); i++) {\n    int fl = toy_list[i].flags;\n    if (fl & TOYMASK_LOCATION) {\n      if (toys.argv[1]) {\n        int j;\n        for (j = 0; toy_paths[j]; j++)\n          if (fl & (1<<j)) len += printf(\"%s\", toy_paths[j]);\n      }\n      len += printf(\"%s\",toy_list[i].name);\n      if (++len > width-15) len = 0;\n      xputc(len ? ' ' : '\\n');\n    }\n  }\n  xputc('\\n');\n}\n\nint main(int argc, char *argv[])\n{\n  // don't segfault if our environment is crazy\n  // TODO mooted by kernel commit dcd46d897adb7 5.17 kernel Jan 2022\n  if (!*argv) return 127;\n\n  // Snapshot stack location so we can detect recursion depth later.\n  // Nommu has special reentry path, !stacktop = \"vfork/exec self happened\"\n  if (!CFG_TOYBOX_FORK && (0x80 & **argv)) **argv &= 0x7f;\n  else {\n    int stack_start;  // here so probe var won't permanently eat stack\n\n    toys.stacktop = &stack_start;\n  }\n\n  if (CFG_TOYBOX) {\n    // Call the multiplexer with argv[] as its arguments so it can toy_find()\n    toys.argv = argv-1;\n    toybox_main();\n  } else {\n    // single command built standalone with no multiplexer is first list entry\n    toy_singleinit(toy_list, argv);\n    toy_list->toy_main();\n  }\n\n  xexit();\n}\n"
        },
        {
          "name": "mkroot",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "toys.h",
          "type": "blob",
          "size": 3.98046875,
          "content": "/* Toybox infrastructure.\n *\n * Copyright 2006 Rob Landley <rob@landley.net>\n */\n\n// Stuff that needs to go before the standard headers\n\n#include \"generated/config.h\"\n#include \"lib/portability.h\"\n\n// General posix-2008 headers\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <math.h>\n#include <paths.h>\n#include <pwd.h>\n#include <regex.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <sys/times.h>\n#include <sys/uio.h>\n#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <syslog.h>\n#include <termios.h>\n#include <time.h>\n#include <unistd.h>\n#include <utime.h>\n\n// Posix networking\n\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <poll.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n\n// Internationalization support (also in POSIX)\n\n#include <langinfo.h>\n#include <locale.h>\n#include <wchar.h>\n#include <wctype.h>\n\n// Non-posix headers\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <sys/ttydefaults.h>\n\n#include \"lib/lib.h\"\n#include \"lib/lsm.h\"\n#include \"lib/toyflags.h\"\n\n// Get list of function prototypes for all enabled command_main() functions.\n\n#define NEWTOY(name, opts, flags) void name##_main(void);\n#define OLDTOY(name, oldname, flags) void oldname##_main(void);\n#include \"generated/newtoys.h\"\n#include \"generated/flags.h\"\n#include \"generated/globals.h\"\n#include \"generated/tags.h\"\n\n// These live in main.c\n\n#define HELP_USAGE   1  // usage: line only\n#define HELP_HEADER  2  // Add Toybox header line to help output\n#define HELP_SEE     4  // \"See COMMAND\" instead of dereferencing alias\n#define HELP_HTML    8  // Output HTML\n\nstruct toy_list *toy_find(char *name);\nvoid show_help(FILE *out, int full);\nvoid check_help(char **arg);\nvoid toy_singleinit(struct toy_list *which, char *argv[]);\nvoid toy_init(struct toy_list *which, char *argv[]);\nvoid toy_exec_which(struct toy_list *which, char *argv[]);\nvoid toy_exec(char *argv[]);\n\n// Array of available commands\n\nextern struct toy_list {\n  char *name;\n  void (*toy_main)(void);\n  char *options;\n  unsigned flags;\n} toy_list[];\n\n// Global context shared by all commands.\n\nextern struct toy_context {\n  struct toy_list *which;  // Which entry in toy_list is this one?\n  char **argv;             // Original command line arguments\n  char **optargs;          // Arguments left over from get_optflags()\n  unsigned long long optflags; // Command line option flags from get_optflags()\n  int optc;                // Count of optargs\n  short toycount;          // Total number of commands in this build\n  char exitval;            // Value error_exit feeds to exit()\n  char wasroot;            // dropped setuid\n\n  // toy_init() should not zero past here.\n  sigjmp_buf *rebound;     // siglongjmp here instead of exit when do_rebound\n  struct arg_list *xexit;  // atexit() functions for xexit(), set by sigatexit()\n  void *stacktop;          // nested toy_exec() call count, or 0 if vforked\n  int envc;                // Count of original environ entries\n  int old_umask;           // Old umask preserved by TOYFLAG_UMASK\n  short signal;            // generic_signal() records what signal it saw here\n  int signalfd;            // and writes signal to this fd, if set\n} toys;\n\n// Two big temporary buffers: one for use by commands, one for library functions\n\nextern char **environ, *toybox_version, toybuf[4096], libbuf[4096];\n\n#define FLAG(x) (!!(toys.optflags&FLAG_##x))  // Return 1 if flag set, 0 if not\n\n#define GLOBALS(...)\n#define ARRAY_LEN(array) (sizeof(array)/sizeof(*array))\n#define TAGGED_ARRAY(X, ...) {__VA_ARGS__}\n\n#ifndef TOYBOX_VERSION\n#ifndef TOYBOX_VENDOR\n#define TOYBOX_VENDOR \"\"\n#endif\n#define TOYBOX_VERSION \"0.8.11\"TOYBOX_VENDOR\n#endif\n"
        },
        {
          "name": "toys",
          "type": "tree",
          "content": null
        },
        {
          "name": "www",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}