{
  "metadata": {
    "timestamp": 1736710199051,
    "page": 902,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "codeplea/tinyexpr",
      "stars": 1630,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0537109375,
          "content": "language: c\n\ncompiler:\n  - clang\n  - gcc\n\nscript: make\n"
        },
        {
          "name": "CONTRIBUTING",
          "type": "blob",
          "size": 0.5166015625,
          "content": "A core strength of TinyExpr is that it is small and simple. This makes it easy\nto add new features. However, if we keep adding new features, it'll no longer\nbe small or simple. In other words, each new feature corrodes away at the core\nstrength of TinyExpr.\n\nIf you want to add a new feature, and you expect me to merge it, please discuss\nit with me before you go to that work. Open an issue at\nhttps://github.com/codeplea/tinyexpr and let us know what you're proposing.\n\nBug fixes are always welcome and appreciated, of course.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.8564453125,
          "content": "zlib License\n\nCopyright (C) 2015, 2016 Lewis Van Winkle\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgement in the product documentation would be\n   appreciated but is not required.\n2. Altered source versions must be plainly marked as such, and must not be\n   misrepresented as being the original software.\n3. This notice may not be removed or altered from any source distribution.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.8974609375,
          "content": "CC = gcc\nCCFLAGS = -Wall -Wshadow -O2\nLFLAGS = -lm\n\n.PHONY = all clean\n\nall: smoke smoke_pr repl bench example example2 example3\n\n\nsmoke: smoke.c tinyexpr.c\n\t$(CC) $(CCFLAGS) -o $@ $^ $(LFLAGS)\n\t./$@\n\nsmoke_pr: smoke.c tinyexpr.c\n\t$(CC) $(CCFLAGS) -DTE_POW_FROM_RIGHT -DTE_NAT_LOG -o $@ $^ $(LFLAGS)\n\t./$@\n\nrepl: repl.o tinyexpr.o\n\t$(CC) $(CCFLAGS) -o $@ $^ $(LFLAGS)\n\nrepl-readline: repl-readline.o tinyexpr.o\n\t$(CC) $(CCFLAGS) -o $@ $^ $(LFLAGS) -lreadline\n\nbench: benchmark.o tinyexpr.o\n\t$(CC) $(CCFLAGS) -o $@ $^ $(LFLAGS)\n\nexample: example.o tinyexpr.o\n\t$(CC) $(CCFLAGS) -o $@ $^ $(LFLAGS)\n\nexample2: example2.o tinyexpr.o\n\t$(CC) $(CCFLAGS) -o $@ $^ $(LFLAGS)\n\nexample3: example3.o tinyexpr.o\n\t$(CC) $(CCFLAGS) -o $@ $^ $(LFLAGS)\n\nrepl-readline.o: repl.c\n\t$(CC) -c -DUSE_READLINE $(CCFLAGS) $< -o $@\n\n.c.o:\n\t$(CC) -c $(CCFLAGS) $< -o $@\n\nclean:\n\trm -f *.o *.exe example example2 example3 bench repl smoke_pr smoke\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.7783203125,
          "content": "[![Build Status](https://travis-ci.com/codeplea/tinyexpr.svg?branch=master)](https://travis-ci.com/codeplea/tinyexpr)\n\n\n<img alt=\"TinyExpr logo\" src=\"https://codeplea.com/public/content/tinyexpr_logo.png\" align=\"right\"/>\n\n# TinyExpr\n\nTinyExpr is a very small recursive descent parser and evaluation engine for\nmath expressions. It's handy when you want to add the ability to evaluate\nmath expressions at runtime without adding a bunch of cruft to your project.\n\nIn addition to the standard math operators and precedence, TinyExpr also supports\nthe standard C math functions and runtime binding of variables.\n\n## Features\n\n- **C99 with no dependencies**.\n- Single source file and header file.\n- Simple and fast.\n- Implements standard operators precedence.\n- Exposes standard C math functions (sin, sqrt, ln, etc.).\n- Can add custom functions and variables easily.\n- Can bind variables at eval-time.\n- Released under the zlib license - free for nearly any use.\n- Easy to use and integrate with your code\n- Thread-safe, provided that your *malloc* is.\n\n## Building\n\nTinyExpr is self-contained in two files: `tinyexpr.c` and `tinyexpr.h`. To use\nTinyExpr, simply add those two files to your project.\n\n## Short Example\n\nHere is a minimal example to evaluate an expression at runtime.\n\n```C\n    #include \"tinyexpr.h\"\n    printf(\"%f\\n\", te_interp(\"5*5\", 0)); /* Prints 25. */\n```\n\n\n## Usage\n\nTinyExpr defines only four functions:\n\n```C\n    double te_interp(const char *expression, int *error);\n    te_expr *te_compile(const char *expression, const te_variable *variables, int var_count, int *error);\n    double te_eval(const te_expr *expr);\n    void te_free(te_expr *expr);\n```\n\n## te_interp\n```C\n    double te_interp(const char *expression, int *error);\n```\n\n`te_interp()` takes an expression and immediately returns the result of it. If there\nis a parse error, `te_interp()` returns NaN.\n\nIf the `error` pointer argument is not 0, then `te_interp()` will set `*error` to the position\nof the parse error on failure, and set `*error` to 0 on success.\n\n**example usage:**\n\n```C\n    int error;\n\n    double a = te_interp(\"(5+5)\", 0); /* Returns 10. */\n    double b = te_interp(\"(5+5)\", &error); /* Returns 10, error is set to 0. */\n    double c = te_interp(\"(5+5\", &error); /* Returns NaN, error is set to 4. */\n```\n\n## te_compile, te_eval, te_free\n```C\n    te_expr *te_compile(const char *expression, const te_variable *lookup, int lookup_len, int *error);\n    double te_eval(const te_expr *n);\n    void te_free(te_expr *n);\n```\n\nGive `te_compile()` an expression with unbound variables and a list of\nvariable names and pointers. `te_compile()` will return a `te_expr*` which can\nbe evaluated later using `te_eval()`. On failure, `te_compile()` will return 0\nand optionally set the passed in `*error` to the location of the parse error.\n\nYou may also compile expressions without variables by passing `te_compile()`'s second\nand third arguments as 0.\n\nGive `te_eval()` a `te_expr*` from `te_compile()`. `te_eval()` will evaluate the expression\nusing the current variable values.\n\nAfter you're finished, make sure to call `te_free()`.\n\n**example usage:**\n\n```C\n    double x, y;\n    /* Store variable names and pointers. */\n    te_variable vars[] = {{\"x\", &x}, {\"y\", &y}};\n\n    int err;\n    /* Compile the expression with variables. */\n    te_expr *expr = te_compile(\"sqrt(x^2+y^2)\", vars, 2, &err);\n\n    if (expr) {\n        x = 3; y = 4;\n        const double h1 = te_eval(expr); /* Returns 5. */\n\n        x = 5; y = 12;\n        const double h2 = te_eval(expr); /* Returns 13. */\n\n        te_free(expr);\n    } else {\n        printf(\"Parse error at %d\\n\", err);\n    }\n\n```\n\n## Longer Example\n\nHere is a complete example that will evaluate an expression passed in from the command\nline. It also does error checking and binds the variables `x` and `y` to *3* and *4*, respectively.\n\n```C\n    #include \"tinyexpr.h\"\n    #include <stdio.h>\n\n    int main(int argc, char *argv[])\n    {\n        if (argc < 2) {\n            printf(\"Usage: example2 \\\"expression\\\"\\n\");\n            return 0;\n        }\n\n        const char *expression = argv[1];\n        printf(\"Evaluating:\\n\\t%s\\n\", expression);\n\n        /* This shows an example where the variables\n         * x and y are bound at eval-time. */\n        double x, y;\n        te_variable vars[] = {{\"x\", &x}, {\"y\", &y}};\n\n        /* This will compile the expression and check for errors. */\n        int err;\n        te_expr *n = te_compile(expression, vars, 2, &err);\n\n        if (n) {\n            /* The variables can be changed here, and eval can be called as many\n             * times as you like. This is fairly efficient because the parsing has\n             * already been done. */\n            x = 3; y = 4;\n            const double r = te_eval(n); printf(\"Result:\\n\\t%f\\n\", r);\n            te_free(n);\n        } else {\n            /* Show the user where the error is at. */\n            printf(\"\\t%*s^\\nError near here\", err-1, \"\");\n        }\n\n        return 0;\n    }\n```\n\n\nThis produces the output:\n\n    $ example2 \"sqrt(x^2+y2)\"\n        Evaluating:\n                sqrt(x^2+y2)\n                          ^\n        Error near here\n\n\n    $ example2 \"sqrt(x^2+y^2)\"\n        Evaluating:\n                sqrt(x^2+y^2)\n        Result:\n                5.000000\n\n\n## Binding to Custom Functions\n\nTinyExpr can also call to custom functions implemented in C. Here is a short example:\n\n```C\ndouble my_sum(double a, double b) {\n    /* Example C function that adds two numbers together. */\n    return a + b;\n}\n\nte_variable vars[] = {\n    {\"mysum\", my_sum, TE_FUNCTION2} /* TE_FUNCTION2 used because my_sum takes two arguments. */\n};\n\nte_expr *n = te_compile(\"mysum(5, 6)\", vars, 1, 0);\n\n```\n\n\n## How it works\n\n`te_compile()` uses a simple recursive descent parser to compile your\nexpression into a syntax tree. For example, the expression `\"sin x + 1/4\"`\nparses as:\n\n![example syntax tree](doc/e1.png?raw=true)\n\n`te_compile()` also automatically prunes constant branches. In this example,\nthe compiled expression returned by `te_compile()` would become:\n\n![example syntax tree](doc/e2.png?raw=true)\n\n`te_eval()` will automatically load in any variables by their pointer, and then evaluate\nand return the result of the expression.\n\n`te_free()` should always be called when you're done with the compiled expression.\n\n\n## Speed\n\n\nTinyExpr is pretty fast compared to C when the expression is short, when the\nexpression does hard calculations (e.g. exponentiation), and when some of the\nwork can be simplified by `te_compile()`. TinyExpr is slow compared to C when the\nexpression is long and involves only basic arithmetic.\n\nHere is some example performance numbers taken from the included\n**benchmark.c** program:\n\n| Expression | te_eval time | native C time | slowdown  |\n| :------------- |-------------:| -----:|----:|\n| sqrt(a^1.5+a^2.5) | 15,641 ms | 14,478 ms | 8% slower |\n| a+5 | 765 ms | 563 ms | 36% slower |\n| a+(5*2) | 765 ms | 563 ms | 36% slower |\n| (a+5)*2 | 1422 ms | 563 ms | 153% slower |\n| (1/(a+1)+2/(a+2)+3/(a+3)) | 5,516 ms | 1,266 ms | 336% slower |\n\n\n\n## Grammar\n\nTinyExpr parses the following grammar:\n\n    <list>      =    <expr> {\",\" <expr>}\n    <expr>      =    <term> {(\"+\" | \"-\") <term>}\n    <term>      =    <factor> {(\"*\" | \"/\" | \"%\") <factor>}\n    <factor>    =    <power> {\"^\" <power>}\n    <power>     =    {(\"-\" | \"+\")} <base>\n    <base>      =    <constant>\n                   | <variable>\n                   | <function-0> {\"(\" \")\"}\n                   | <function-1> <power>\n                   | <function-X> \"(\" <expr> {\",\" <expr>} \")\"\n                   | \"(\" <list> \")\"\n\nIn addition, whitespace between tokens is ignored.\n\nValid variable names consist of a letter followed by any combination of:\nletters, the digits *0* through *9*, and underscore. Constants can be integers\nor floating-point numbers, and can be in decimal, hexadecimal (e.g., *0x57CEF7*),\nor scientific notation (e.g., *1e3* for *1000*).\nA leading zero is not required (e.g., *.5* for *0.5*).\n\n\n## Functions supported\n\nTinyExpr supports addition (+), subtraction/negation (-), multiplication (\\*),\ndivision (/), exponentiation (^) and modulus (%) with the normal operator\nprecedence (the one exception being that exponentiation is evaluated\nleft-to-right, but this can be changed - see below).\n\nThe following C math functions are also supported:\n\n- abs (calls to *fabs*), acos, asin, atan, atan2, ceil, cos, cosh, exp, floor, ln (calls to *log*), log (calls to *log10* by default, see below), log10, pow, sin, sinh, sqrt, tan, tanh\n\nThe following functions are also built-in and provided by TinyExpr:\n\n- fac (factorials e.g. `fac 5` == 120)\n- ncr (combinations e.g. `ncr(6,2)` == 15)\n- npr (permutations e.g. `npr(6,2)` == 30)\n\nAlso, the following constants are available:\n\n- `pi`, `e`\n\n\n## Compile-time options\n\n\nBy default, TinyExpr does exponentiation from left to right. For example:\n\n`a^b^c == (a^b)^c` and `-a^b == (-a)^b`\n\nThis is by design. It's the way that spreadsheets do it (e.g. Excel, Google Sheets).\n\n\nIf you would rather have exponentiation work from right to left, you need to\ndefine `TE_POW_FROM_RIGHT` when compiling `tinyexpr.c`. There is a\ncommented-out define near the top of that file. With this option enabled, the\nbehaviour is:\n\n`a^b^c == a^(b^c)` and `-a^b == -(a^b)`\n\nThat will match how many scripting languages do it (e.g. Python, Ruby).\n\nAlso, if you'd like `log` to default to the natural log instead of `log10`,\nthen you can define `TE_NAT_LOG`.\n\n## Hints\n\n- All functions/types start with the letters *te*.\n\n- To allow constant optimization, surround constant expressions in parentheses.\n  For example \"x+(1+5)\" will evaluate the \"(1+5)\" expression at compile time and\n  compile the entire expression as \"x+6\", saving a runtime calculation. The\n  parentheses are important, because TinyExpr will not change the order of\n  evaluation. If you instead compiled \"x+1+5\" TinyExpr will insist that \"1\" is\n  added to \"x\" first, and \"5\" is added the result second.\n\n"
        },
        {
          "name": "benchmark.c",
          "type": "blob",
          "size": 2.970703125,
          "content": "/*\n * TINYEXPR - Tiny recursive descent parser and evaluation engine in C\n *\n * Copyright (c) 2015, 2016 Lewis Van Winkle\n *\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgement in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n#include \"tinyexpr.h\"\n\n\n\n#define loops 10000\n\n\n\ntypedef double (*function1)(double);\n\nvoid bench(const char *expr, function1 func) {\n    int i, j;\n    volatile double d;\n    double tmp;\n    clock_t start;\n\n    te_variable lk = {\"a\", &tmp};\n\n    printf(\"Expression: %s\\n\", expr);\n\n    printf(\"native \");\n    start = clock();\n    d = 0;\n    for (j = 0; j < loops; ++j)\n        for (i = 0; i < loops; ++i) {\n            tmp = i;\n            d += func(tmp);\n        }\n    const int nelapsed = (clock() - start) * 1000 / CLOCKS_PER_SEC;\n\n    /*Million floats per second input.*/\n    printf(\" %.5g\", d);\n    if (nelapsed)\n        printf(\"\\t%5dms\\t%5dmfps\\n\", nelapsed, loops * loops / nelapsed / 1000);\n    else\n        printf(\"\\tinf\\n\");\n\n\n\n\n    printf(\"interp \");\n    te_expr *n = te_compile(expr, &lk, 1, 0);\n    start = clock();\n    d = 0;\n    for (j = 0; j < loops; ++j)\n        for (i = 0; i < loops; ++i) {\n            tmp = i;\n            d += te_eval(n);\n        }\n    const int eelapsed = (clock() - start) * 1000 / CLOCKS_PER_SEC;\n    te_free(n);\n\n    /*Million floats per second input.*/\n    printf(\" %.5g\", d);\n    if (eelapsed)\n        printf(\"\\t%5dms\\t%5dmfps\\n\", eelapsed, loops * loops / eelapsed / 1000);\n    else\n        printf(\"\\tinf\\n\");\n\n\n    printf(\"%.2f%% longer\\n\", (((double)eelapsed / nelapsed) - 1.0) * 100.0);\n\n\n    printf(\"\\n\");\n}\n\n\ndouble a5(double a) {\n    return a+5;\n}\n\ndouble a55(double a) {\n    return 5+a+5;\n}\n\ndouble a5abs(double a) {\n    return fabs(a+5);\n}\n\ndouble a52(double a) {\n    return (a+5)*2;\n}\n\ndouble a10(double a) {\n    return a+(5*2);\n}\n\ndouble as(double a) {\n    return sqrt(pow(a, 1.5) + pow(a, 2.5));\n}\n\ndouble al(double a) {\n    return (1/(a+1)+2/(a+2)+3/(a+3));\n}\n\nint main(int argc, char *argv[])\n{\n\n    bench(\"a+5\", a5);\n    bench(\"5+a+5\", a55);\n    bench(\"abs(a+5)\", a5abs);\n\n    bench(\"sqrt(a^1.5+a^2.5)\", as);\n    bench(\"a+(5*2)\", a10);\n    bench(\"(a+5)*2\", a52);\n    bench(\"(1/(a+1)+2/(a+2)+3/(a+3))\", al);\n\n    return 0;\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "example.c",
          "type": "blob",
          "size": 0.2353515625,
          "content": "#include \"tinyexpr.h\"\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    const char *c = \"sqrt(5^2+7^2+11^2+(8-2)^2)\";\n    double r = te_interp(c, 0);\n    printf(\"The expression:\\n\\t%s\\nevaluates to:\\n\\t%f\\n\", c, r);\n    return 0;\n}\n"
        },
        {
          "name": "example2.c",
          "type": "blob",
          "size": 0.9833984375,
          "content": "#include \"tinyexpr.h\"\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    if (argc < 2) {\n        printf(\"Usage: example2 \\\"expression\\\"\\n\");\n        return 0;\n    }\n\n    const char *expression = argv[1];\n    printf(\"Evaluating:\\n\\t%s\\n\", expression);\n\n    /* This shows an example where the variables\n     * x and y are bound at eval-time. */\n    double x, y;\n    te_variable vars[] = {{\"x\", &x}, {\"y\", &y}};\n\n    /* This will compile the expression and check for errors. */\n    int err;\n    te_expr *n = te_compile(expression, vars, 2, &err);\n\n    if (n) {\n        /* The variables can be changed here, and eval can be called as many\n         * times as you like. This is fairly efficient because the parsing has\n         * already been done. */\n        x = 3; y = 4;\n        const double r = te_eval(n); printf(\"Result:\\n\\t%f\\n\", r);\n\n        te_free(n);\n    } else {\n        /* Show the user where the error is at. */\n        printf(\"\\t%*s^\\nError near here\", err-1, \"\");\n    }\n\n\n    return 0;\n}\n"
        },
        {
          "name": "example3.c",
          "type": "blob",
          "size": 0.705078125,
          "content": "#include \"tinyexpr.h\"\n#include <stdio.h>\n\n\n/* An example of calling a C function. */\ndouble my_sum(double a, double b) {\n    printf(\"Called C function with %f and %f.\\n\", a, b);\n    return a + b;\n}\n\n\nint main(int argc, char *argv[])\n{\n    te_variable vars[] = {\n        {\"mysum\", my_sum, TE_FUNCTION2}\n    };\n\n    const char *expression = \"mysum(5, 6)\";\n    printf(\"Evaluating:\\n\\t%s\\n\", expression);\n\n    int err;\n    te_expr *n = te_compile(expression, vars, 1, &err);\n\n    if (n) {\n        const double r = te_eval(n);\n        printf(\"Result:\\n\\t%f\\n\", r);\n        te_free(n);\n    } else {\n        /* Show the user where the error is at. */\n        printf(\"\\t%*s^\\nError near here\", err-1, \"\");\n    }\n\n\n    return 0;\n}\n"
        },
        {
          "name": "minctest.h",
          "type": "blob",
          "size": 3.2236328125,
          "content": "/*\n *\n * MINCTEST - Minimal C Test Library - 0.1\n *\n * Copyright (c) 2014, 2015 Lewis Van Winkle\n *\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n *    claim that you wrote the original software. If you use this software\n *    in a product, an acknowledgement in the product documentation would be\n *    appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n *\n */\n\n\n\n/*\n * MINCTEST - Minimal testing library for C\n *\n *\n * Example:\n *\n *      void test1() {\n *           lok('a' == 'a');\n *      }\n *\n *      void test2() {\n *           lequal(5, 6);\n *           lfequal(5.5, 5.6);\n *      }\n *\n *      int main() {\n *           lrun(\"test1\", test1);\n *           lrun(\"test2\", test2);\n *           lresults();\n *           return lfails != 0;\n *      }\n *\n *\n *\n * Hints:\n *      All functions/variables start with the letter 'l'.\n *\n */\n\n\n#ifndef __MINCTEST_H__\n#define __MINCTEST_H__\n\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n\n\n/* How far apart can floats be before we consider them unequal. */\n#define LTEST_FLOAT_TOLERANCE 0.001\n\n\n/* Track the number of passes, fails. */\n/* NB this is made for all tests to be in one file. */\nstatic int ltests = 0;\nstatic int lfails = 0;\n\n\n/* Display the test results. */\n#define lresults() do {\\\n    if (lfails == 0) {\\\n        printf(\"ALL TESTS PASSED (%d/%d)\\n\", ltests, ltests);\\\n    } else {\\\n        printf(\"SOME TESTS FAILED (%d/%d)\\n\", ltests-lfails, ltests);\\\n    }\\\n} while (0)\n\n\n/* Run a test. Name can be any string to print out, test is the function name to call. */\n#define lrun(name, test) do {\\\n    const int ts = ltests;\\\n    const int fs = lfails;\\\n    const clock_t start = clock();\\\n    printf(\"\\t%-14s\", name);\\\n    test();\\\n    printf(\"pass:%2d   fail:%2d   %4dms\\n\",\\\n            (ltests-ts)-(lfails-fs), lfails-fs,\\\n            (int)((clock() - start) * 1000 / CLOCKS_PER_SEC));\\\n} while (0)\n\n\n/* Assert a true statement. */\n#define lok(test) do {\\\n    ++ltests;\\\n    if (!(test)) {\\\n        ++lfails;\\\n        printf(\"%s:%d error \\n\", __FILE__, __LINE__);\\\n    }} while (0)\n\n\n/* Assert two integers are equal. */\n#define lequal(a, b) do {\\\n    ++ltests;\\\n    if ((a) != (b)) {\\\n        ++lfails;\\\n        printf(\"%s:%d (%d != %d)\\n\", __FILE__, __LINE__, (a), (b));\\\n    }} while (0)\n\n\n/* Assert two floats are equal (Within LTEST_FLOAT_TOLERANCE). */\n#define lfequal(a, b) do {\\\n    ++ltests;\\\n    const double __LF_COMPARE = fabs((double)(a)-(double)(b));\\\n    if (__LF_COMPARE > LTEST_FLOAT_TOLERANCE || (__LF_COMPARE != __LF_COMPARE)) {\\\n        ++lfails;\\\n        printf(\"%s:%d (%f != %f)\\n\", __FILE__, __LINE__, (double)(a), (double)(b));\\\n    }} while (0)\n\n\n#endif /*__MINCTEST_H__*/\n"
        },
        {
          "name": "repl.c",
          "type": "blob",
          "size": 1.685546875,
          "content": "#include \"tinyexpr.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifdef USE_READLINE\n#include <readline/readline.h>\n#include <readline/history.h>\n#else\nstatic char *readline(const char *prompt) {\n    fprintf(stderr, \"%s\", prompt);\n    char buf[1024];\n    char *line = fgets(buf, sizeof(buf), stdin);\n    if (line == NULL && feof(stdin)) {\n        return NULL;\n    } else if (line == NULL) {\n        perror(\"fgets\");\n        return NULL;\n    }\n\n    size_t len = strlen(line);\n\n    if (len < 1)\n        return NULL;\n\n    if (line[len - 1] == '\\n') {\n        line[len - 1] = '\\0';\n        len -= 1;\n    }\n\n    line = malloc(len + 1);\n    strcpy(line, buf);\n    return line;\n}\n\nstatic void add_history(const char *line) {}\n#endif\n\nstatic int eval(const char *str) {\n    int err = 0;\n    double r = te_interp(str, &err);\n    if (err != 0) {\n        printf(\"Error at position %i\\n\", err);\n        return -1;\n    } else {\n        printf(\"%g\\n\", r);\n        return 0;\n    }\n}\n\nstatic void repl() {\n    while (1) {\n        char *line = readline(\"> \");\n        if (line == NULL) {\n            break;\n        } else if (strcmp(line, \"q\") == 0 || strcmp(line, \"quit\") == 0) {\n            free(line);\n            break;\n        }\n\n        if (eval(line) != -1) {\n            add_history(line);\n        }\n\n        free(line);\n    }\n}\n\nint main(int argc, char **argv) {\n    if (argc == 3 && strcmp(argv[1], \"-e\") == 0) {\n        if (eval(argv[2]) == -1) {\n            return 1;\n        } else {\n            return 0;\n        }\n    } else if (argc == 1) {\n        repl();\n        return 0;\n    } else {\n        printf(\"Usage: %s\\n\", argv[0]);\n        printf(\"       %s -e <expression>\\n\", argv[0]);\n        return 1;\n    }\n}\n"
        },
        {
          "name": "smoke.c",
          "type": "blob",
          "size": 16.27734375,
          "content": "/*\n * TINYEXPR - Tiny recursive descent parser and evaluation engine in C\n *\n * Copyright (c) 2015-2020 Lewis Van Winkle\n *\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgement in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n#include \"tinyexpr.h\"\n#include <stdio.h>\n#include \"minctest.h\"\n\n\ntypedef struct {\n    const char *expr;\n    double answer;\n} test_case;\n\ntypedef struct {\n    const char *expr1;\n    const char *expr2;\n} test_equ;\n\n\n\nvoid test_results() {\n    test_case cases[] = {\n        {\"1\", 1},\n        {\"1 \", 1},\n        {\"(1)\", 1},\n\n        {\"pi\", 3.14159},\n        {\"atan(1)*4 - pi\", 0},\n        {\"e\", 2.71828},\n\n        {\"2+1\", 2+1},\n        {\"(((2+(1))))\", 2+1},\n        {\"3+2\", 3+2},\n\n        {\"3+2+4\", 3+2+4},\n        {\"(3+2)+4\", 3+2+4},\n        {\"3+(2+4)\", 3+2+4},\n        {\"(3+2+4)\", 3+2+4},\n\n        {\"3*2*4\", 3*2*4},\n        {\"(3*2)*4\", 3*2*4},\n        {\"3*(2*4)\", 3*2*4},\n        {\"(3*2*4)\", 3*2*4},\n\n        {\"3-2-4\", 3-2-4},\n        {\"(3-2)-4\", (3-2)-4},\n        {\"3-(2-4)\", 3-(2-4)},\n        {\"(3-2-4)\", 3-2-4},\n\n        {\"3/2/4\", 3.0/2.0/4.0},\n        {\"(3/2)/4\", (3.0/2.0)/4.0},\n        {\"3/(2/4)\", 3.0/(2.0/4.0)},\n        {\"(3/2/4)\", 3.0/2.0/4.0},\n\n        {\"(3*2/4)\", 3.0*2.0/4.0},\n        {\"(3/2*4)\", 3.0/2.0*4.0},\n        {\"3*(2/4)\", 3.0*(2.0/4.0)},\n\n        {\"asin sin .5\", 0.5},\n        {\"sin asin .5\", 0.5},\n        {\"ln exp .5\", 0.5},\n        {\"exp ln .5\", 0.5},\n\n        {\"asin sin-.5\", -0.5},\n        {\"asin sin-0.5\", -0.5},\n        {\"asin sin -0.5\", -0.5},\n        {\"asin (sin -0.5)\", -0.5},\n        {\"asin (sin (-0.5))\", -0.5},\n        {\"asin sin (-0.5)\", -0.5},\n        {\"(asin sin (-0.5))\", -0.5},\n\n        {\"log10 1000\", 3},\n        {\"log10 1e3\", 3},\n        {\"log10 1000\", 3},\n        {\"log10 1e3\", 3},\n        {\"log10(1000)\", 3},\n        {\"log10(1e3)\", 3},\n        {\"log10 1.0e3\", 3},\n        {\"10^5*5e-5\", 5},\n\n#ifdef TE_NAT_LOG\n        {\"log 1000\", 6.9078},\n        {\"log e\", 1},\n        {\"log (e^10)\", 10},\n#else\n        {\"log 1000\", 3},\n#endif\n\n        {\"ln (e^10)\", 10},\n        {\"100^.5+1\", 11},\n        {\"100 ^.5+1\", 11},\n        {\"100^+.5+1\", 11},\n        {\"100^--.5+1\", 11},\n        {\"100^---+-++---++-+-+-.5+1\", 11},\n\n        {\"100^-.5+1\", 1.1},\n        {\"100^---.5+1\", 1.1},\n        {\"100^+---.5+1\", 1.1},\n        {\"1e2^+---.5e0+1e0\", 1.1},\n        {\"--(1e2^(+(-(-(-.5e0))))+1e0)\", 1.1},\n\n        {\"sqrt 100 + 7\", 17},\n        {\"sqrt 100 * 7\", 70},\n        {\"sqrt (100 * 100)\", 100},\n\n        {\"1,2\", 2},\n        {\"1,2+1\", 3},\n        {\"1+1,2+2,2+1\", 3},\n        {\"1,2,3\", 3},\n        {\"(1,2),3\", 3},\n        {\"1,(2,3)\", 3},\n        {\"-(1,(2,3))\", -3},\n\n        {\"2^2\", 4},\n        {\"pow(2,2)\", 4},\n\n        {\"atan2(1,1)\", 0.7854},\n        {\"atan2(1,2)\", 0.4636},\n        {\"atan2(2,1)\", 1.1071},\n        {\"atan2(3,4)\", 0.6435},\n        {\"atan2(3+3,4*2)\", 0.6435},\n        {\"atan2(3+3,(4*2))\", 0.6435},\n        {\"atan2((3+3),4*2)\", 0.6435},\n        {\"atan2((3+3),(4*2))\", 0.6435},\n\n    };\n\n\n    int i;\n    for (i = 0; i < sizeof(cases) / sizeof(test_case); ++i) {\n        const char *expr = cases[i].expr;\n        const double answer = cases[i].answer;\n\n        int err;\n        const double ev = te_interp(expr, &err);\n        lok(!err);\n        lfequal(ev, answer);\n\n        if (err) {\n            printf(\"FAILED: %s (%d)\\n\", expr, err);\n        }\n    }\n}\n\n\nvoid test_syntax() {\n    test_case errors[] = {\n        {\"\", 1},\n        {\"1+\", 2},\n        {\"1)\", 2},\n        {\"(1\", 2},\n        {\"1**1\", 3},\n        {\"1*2(+4\", 4},\n        {\"1*2(1+4\", 4},\n        {\"a+5\", 1},\n        {\"!+5\", 1},\n        {\"_a+5\", 1},\n        {\"#a+5\", 1},\n        {\"1^^5\", 3},\n        {\"1**5\", 3},\n        {\"sin(cos5\", 8},\n    };\n\n\n    int i;\n    for (i = 0; i < sizeof(errors) / sizeof(test_case); ++i) {\n        const char *expr = errors[i].expr;\n        const int e = errors[i].answer;\n\n        int err;\n        const double r = te_interp(expr, &err);\n        lequal(err, e);\n        lok(r != r);\n\n        te_expr *n = te_compile(expr, 0, 0, &err);\n        lequal(err, e);\n        lok(!n);\n\n        if (err != e) {\n            printf(\"FAILED: %s\\n\", expr);\n        }\n\n        const double k = te_interp(expr, 0);\n        lok(k != k);\n    }\n}\n\n\nvoid test_nans() {\n\n    const char *nans[] = {\n        \"0/0\",\n        \"1%0\",\n        \"1%(1%0)\",\n        \"(1%0)%1\",\n        \"fac(-1)\",\n        \"ncr(2, 4)\",\n        \"ncr(-2, 4)\",\n        \"ncr(2, -4)\",\n        \"npr(2, 4)\",\n        \"npr(-2, 4)\",\n        \"npr(2, -4)\",\n    };\n\n    int i;\n    for (i = 0; i < sizeof(nans) / sizeof(const char *); ++i) {\n        const char *expr = nans[i];\n\n        int err;\n        const double r = te_interp(expr, &err);\n        lequal(err, 0);\n        lok(r != r);\n\n        te_expr *n = te_compile(expr, 0, 0, &err);\n        lok(n);\n        lequal(err, 0);\n        const double c = te_eval(n);\n        lok(c != c);\n        te_free(n);\n    }\n}\n\n\nvoid test_infs() {\n\n    const char *infs[] = {\n            \"1/0\",\n            \"log(0)\",\n            \"pow(2,10000000)\",\n            \"fac(300)\",\n            \"ncr(300,100)\",\n            \"ncr(300000,100)\",\n            \"ncr(300000,100)*8\",\n            \"npr(3,2)*ncr(300000,100)\",\n            \"npr(100,90)\",\n            \"npr(30,25)\",\n    };\n\n    int i;\n    for (i = 0; i < sizeof(infs) / sizeof(const char *); ++i) {\n        const char *expr = infs[i];\n\n        int err;\n        const double r = te_interp(expr, &err);\n        lequal(err, 0);\n        lok(r == r + 1);\n\n        te_expr *n = te_compile(expr, 0, 0, &err);\n        lok(n);\n        lequal(err, 0);\n        const double c = te_eval(n);\n        lok(c == c + 1);\n        te_free(n);\n    }\n}\n\n\nvoid test_variables() {\n\n    double x, y, test;\n    te_variable lookup[] = {{\"x\", &x}, {\"y\", &y}, {\"te_st\", &test}};\n\n    int err;\n\n    te_expr *expr1 = te_compile(\"cos x + sin y\", lookup, 2, &err);\n    lok(expr1);\n    lok(!err);\n\n    te_expr *expr2 = te_compile(\"x+x+x-y\", lookup, 2, &err);\n    lok(expr2);\n    lok(!err);\n\n    te_expr *expr3 = te_compile(\"x*y^3\", lookup, 2, &err);\n    lok(expr3);\n    lok(!err);\n\n    te_expr *expr4 = te_compile(\"te_st+5\", lookup, 3, &err);\n    lok(expr4);\n    lok(!err);\n\n    for (y = 2; y < 3; ++y) {\n        for (x = 0; x < 5; ++x) {\n            double ev;\n\n            ev = te_eval(expr1);\n            lfequal(ev, cos(x) + sin(y));\n\n            ev = te_eval(expr2);\n            lfequal(ev, x+x+x-y);\n\n            ev = te_eval(expr3);\n            lfequal(ev, x*y*y*y);\n\n            test = x;\n            ev = te_eval(expr4);\n            lfequal(ev, x+5);\n        }\n    }\n\n    te_free(expr1);\n    te_free(expr2);\n    te_free(expr3);\n    te_free(expr4);\n\n\n\n    te_expr *expr5 = te_compile(\"xx*y^3\", lookup, 2, &err);\n    lok(!expr5);\n    lok(err);\n\n    te_expr *expr6 = te_compile(\"tes\", lookup, 3, &err);\n    lok(!expr6);\n    lok(err);\n\n    te_expr *expr7 = te_compile(\"sinn x\", lookup, 2, &err);\n    lok(!expr7);\n    lok(err);\n\n    te_expr *expr8 = te_compile(\"si x\", lookup, 2, &err);\n    lok(!expr8);\n    lok(err);\n}\n\n\n\n#define cross_check(a, b) do {\\\n    if ((b)!=(b)) break;\\\n    expr = te_compile((a), lookup, 2, &err);\\\n    lfequal(te_eval(expr), (b));\\\n    lok(!err);\\\n    te_free(expr);\\\n}while(0)\n\nvoid test_functions() {\n\n    double x, y;\n    te_variable lookup[] = {{\"x\", &x}, {\"y\", &y}};\n\n    int err;\n    te_expr *expr;\n\n    for (x = -5; x < 5; x += .2) {\n        cross_check(\"abs x\", fabs(x));\n        cross_check(\"acos x\", acos(x));\n        cross_check(\"asin x\", asin(x));\n        cross_check(\"atan x\", atan(x));\n        cross_check(\"ceil x\", ceil(x));\n        cross_check(\"cos x\", cos(x));\n        cross_check(\"cosh x\", cosh(x));\n        cross_check(\"exp x\", exp(x));\n        cross_check(\"floor x\", floor(x));\n        cross_check(\"ln x\", log(x));\n        cross_check(\"log10 x\", log10(x));\n        cross_check(\"sin x\", sin(x));\n        cross_check(\"sinh x\", sinh(x));\n        cross_check(\"sqrt x\", sqrt(x));\n        cross_check(\"tan x\", tan(x));\n        cross_check(\"tanh x\", tanh(x));\n\n        for (y = -2; y < 2; y += .2) {\n            if (fabs(x) < 0.01) break;\n            cross_check(\"atan2(x,y)\", atan2(x, y));\n            cross_check(\"pow(x,y)\", pow(x, y));\n        }\n    }\n}\n\n\ndouble sum0() {\n    return 6;\n}\ndouble sum1(double a) {\n    return a * 2;\n}\ndouble sum2(double a, double b) {\n    return a + b;\n}\ndouble sum3(double a, double b, double c) {\n    return a + b + c;\n}\ndouble sum4(double a, double b, double c, double d) {\n    return a + b + c + d;\n}\ndouble sum5(double a, double b, double c, double d, double e) {\n    return a + b + c + d + e;\n}\ndouble sum6(double a, double b, double c, double d, double e, double f) {\n    return a + b + c + d + e + f;\n}\ndouble sum7(double a, double b, double c, double d, double e, double f, double g) {\n    return a + b + c + d + e + f + g;\n}\n\n\nvoid test_dynamic() {\n\n    double x, f;\n    te_variable lookup[] = {\n        {\"x\", &x},\n        {\"f\", &f},\n        {\"sum0\", sum0, TE_FUNCTION0},\n        {\"sum1\", sum1, TE_FUNCTION1},\n        {\"sum2\", sum2, TE_FUNCTION2},\n        {\"sum3\", sum3, TE_FUNCTION3},\n        {\"sum4\", sum4, TE_FUNCTION4},\n        {\"sum5\", sum5, TE_FUNCTION5},\n        {\"sum6\", sum6, TE_FUNCTION6},\n        {\"sum7\", sum7, TE_FUNCTION7},\n    };\n\n    test_case cases[] = {\n        {\"x\", 2},\n        {\"f+x\", 7},\n        {\"x+x\", 4},\n        {\"x+f\", 7},\n        {\"f+f\", 10},\n        {\"f+sum0\", 11},\n        {\"sum0+sum0\", 12},\n        {\"sum0()+sum0\", 12},\n        {\"sum0+sum0()\", 12},\n        {\"sum0()+(0)+sum0()\", 12},\n        {\"sum1 sum0\", 12},\n        {\"sum1(sum0)\", 12},\n        {\"sum1 f\", 10},\n        {\"sum1 x\", 4},\n        {\"sum2 (sum0, x)\", 8},\n        {\"sum3 (sum0, x, 2)\", 10},\n        {\"sum2(2,3)\", 5},\n        {\"sum3(2,3,4)\", 9},\n        {\"sum4(2,3,4,5)\", 14},\n        {\"sum5(2,3,4,5,6)\", 20},\n        {\"sum6(2,3,4,5,6,7)\", 27},\n        {\"sum7(2,3,4,5,6,7,8)\", 35},\n    };\n\n    x = 2;\n    f = 5;\n\n    int i;\n    for (i = 0; i < sizeof(cases) / sizeof(test_case); ++i) {\n        const char *expr = cases[i].expr;\n        const double answer = cases[i].answer;\n\n        int err;\n        te_expr *ex = te_compile(expr, lookup, sizeof(lookup)/sizeof(te_variable), &err);\n        lok(ex);\n        lfequal(te_eval(ex), answer);\n        te_free(ex);\n    }\n}\n\n\ndouble clo0(void *context) {\n    if (context) return *((double*)context) + 6;\n    return 6;\n}\ndouble clo1(void *context, double a) {\n    if (context) return *((double*)context) + a * 2;\n    return a * 2;\n}\ndouble clo2(void *context, double a, double b) {\n    if (context) return *((double*)context) + a + b;\n    return a + b;\n}\n\ndouble cell(void *context, double a) {\n    double *c = context;\n    return c[(int)a];\n}\n\nvoid test_closure() {\n\n    double extra;\n    double c[] = {5,6,7,8,9};\n\n    te_variable lookup[] = {\n        {\"c0\", clo0, TE_CLOSURE0, &extra},\n        {\"c1\", clo1, TE_CLOSURE1, &extra},\n        {\"c2\", clo2, TE_CLOSURE2, &extra},\n        {\"cell\", cell, TE_CLOSURE1, c},\n    };\n\n    test_case cases[] = {\n        {\"c0\", 6},\n        {\"c1 4\", 8},\n        {\"c2 (10, 20)\", 30},\n    };\n\n    int i;\n    for (i = 0; i < sizeof(cases) / sizeof(test_case); ++i) {\n        const char *expr = cases[i].expr;\n        const double answer = cases[i].answer;\n\n        int err;\n        te_expr *ex = te_compile(expr, lookup, sizeof(lookup)/sizeof(te_variable), &err);\n        lok(ex);\n\n        extra = 0;\n        lfequal(te_eval(ex), answer + extra);\n\n        extra = 10;\n        lfequal(te_eval(ex), answer + extra);\n\n        te_free(ex);\n    }\n\n\n    test_case cases2[] = {\n        {\"cell 0\", 5},\n        {\"cell 1\", 6},\n        {\"cell 0 + cell 1\", 11},\n        {\"cell 1 * cell 3 + cell 4\", 57},\n    };\n\n    for (i = 0; i < sizeof(cases2) / sizeof(test_case); ++i) {\n        const char *expr = cases2[i].expr;\n        const double answer = cases2[i].answer;\n\n        int err;\n        te_expr *ex = te_compile(expr, lookup, sizeof(lookup)/sizeof(te_variable), &err);\n        lok(ex);\n        lfequal(te_eval(ex), answer);\n        te_free(ex);\n    }\n}\n\nvoid test_optimize() {\n\n    test_case cases[] = {\n        {\"5+5\", 10},\n        {\"pow(2,2)\", 4},\n        {\"sqrt 100\", 10},\n        {\"pi * 2\", 6.2832},\n    };\n\n    int i;\n    for (i = 0; i < sizeof(cases) / sizeof(test_case); ++i) {\n        const char *expr = cases[i].expr;\n        const double answer = cases[i].answer;\n\n        int err;\n        te_expr *ex = te_compile(expr, 0, 0, &err);\n        lok(ex);\n\n        /* The answer should be know without\n         * even running eval. */\n        lfequal(ex->value, answer);\n        lfequal(te_eval(ex), answer);\n\n        te_free(ex);\n    }\n}\n\nvoid test_pow() {\n#ifdef TE_POW_FROM_RIGHT\n    test_equ cases[] = {\n        {\"2^3^4\", \"2^(3^4)\"},\n        {\"-2^2\", \"-(2^2)\"},\n        {\"--2^2\", \"(2^2)\"},\n        {\"---2^2\", \"-(2^2)\"},\n        {\"-(2*1)^2\", \"-(2^2)\"},\n        {\"-2^2\", \"-4\"},\n        {\"2^1.1^1.2^1.3\", \"2^(1.1^(1.2^1.3))\"},\n        {\"-a^b\", \"-(a^b)\"},\n        {\"-a^-b\", \"-(a^-b)\"},\n        {\"1^0\", \"1\"},\n        {\"(1)^0\", \"1\"},\n        {\"-(2)^2\", \"-(2^2)\"}\n        /* TODO POW FROM RIGHT IS STILL BUGGY\n        {\"(-2)^2\", \"4\"},\n        {\"(-1)^0\", \"1\"},\n        {\"(-5)^0\", \"1\"},\n        {\"-2^-3^-4\", \"-(2^(-(3^-4)))\"}*/\n    };\n#else\n    test_equ cases[] = {\n        {\"2^3^4\", \"(2^3)^4\"},\n        {\"-2^2\", \"(-2)^2\"},\n        {\"(-2)^2\", \"4\"},\n        {\"--2^2\", \"2^2\"},\n        {\"---2^2\", \"(-2)^2\"},\n        {\"-2^2\", \"4\"},\n        {\"2^1.1^1.2^1.3\", \"((2^1.1)^1.2)^1.3\"},\n        {\"-a^b\", \"(-a)^b\"},\n        {\"-a^-b\", \"(-a)^(-b)\"},\n        {\"1^0\", \"1\"},\n        {\"(1)^0\", \"1\"},\n        {\"(-1)^0\", \"1\"},\n        {\"(-5)^0\", \"1\"},\n        {\"-2^-3^-4\", \"((-2)^(-3))^(-4)\"}\n    };\n#endif\n\n    double a = 2, b = 3;\n\n    te_variable lookup[] = {\n        {\"a\", &a},\n        {\"b\", &b}\n    };\n\n    int i;\n    for (i = 0; i < sizeof(cases) / sizeof(test_equ); ++i) {\n        const char *expr1 = cases[i].expr1;\n        const char *expr2 = cases[i].expr2;\n\n        te_expr *ex1 = te_compile(expr1, lookup, sizeof(lookup)/sizeof(te_variable), 0);\n        te_expr *ex2 = te_compile(expr2, lookup, sizeof(lookup)/sizeof(te_variable), 0);\n\n        lok(ex1);\n        lok(ex2);\n\n        double r1 = te_eval(ex1);\n        double r2 = te_eval(ex2);\n\n        fflush(stdout);\n        const int olfail = lfails;\n        lfequal(r1, r2);\n        if (olfail != lfails) {\n            printf(\"Failed expression: %s <> %s\\n\", expr1, expr2);\n        }\n\n        te_free(ex1);\n        te_free(ex2);\n    }\n\n}\n\nvoid test_combinatorics() {\n    test_case cases[] = {\n            {\"fac(0)\", 1},\n            {\"fac(0.2)\", 1},\n            {\"fac(1)\", 1},\n            {\"fac(2)\", 2},\n            {\"fac(3)\", 6},\n            {\"fac(4.8)\", 24},\n            {\"fac(10)\", 3628800},\n\n            {\"ncr(0,0)\", 1},\n            {\"ncr(10,1)\", 10},\n            {\"ncr(10,0)\", 1},\n            {\"ncr(10,10)\", 1},\n            {\"ncr(16,7)\", 11440},\n            {\"ncr(16,9)\", 11440},\n            {\"ncr(100,95)\", 75287520},\n\n            {\"npr(0,0)\", 1},\n            {\"npr(10,1)\", 10},\n            {\"npr(10,0)\", 1},\n            {\"npr(10,10)\", 3628800},\n            {\"npr(20,5)\", 1860480},\n            {\"npr(100,4)\", 94109400},\n    };\n\n\n    int i;\n    for (i = 0; i < sizeof(cases) / sizeof(test_case); ++i) {\n        const char *expr = cases[i].expr;\n        const double answer = cases[i].answer;\n\n        int err;\n        const double ev = te_interp(expr, &err);\n        lok(!err);\n        lfequal(ev, answer);\n\n        if (err) {\n            printf(\"FAILED: %s (%d)\\n\", expr, err);\n        }\n    }\n}\n\n\nint main(int argc, char *argv[])\n{\n    lrun(\"Results\", test_results);\n    lrun(\"Syntax\", test_syntax);\n    lrun(\"NaNs\", test_nans);\n    lrun(\"INFs\", test_infs);\n    lrun(\"Variables\", test_variables);\n    lrun(\"Functions\", test_functions);\n    lrun(\"Dynamic\", test_dynamic);\n    lrun(\"Closure\", test_closure);\n    lrun(\"Optimize\", test_optimize);\n    lrun(\"Pow\", test_pow);\n    lrun(\"Combinatorics\", test_combinatorics);\n    lresults();\n\n    return lfails != 0;\n}\n"
        },
        {
          "name": "tinyexpr.c",
          "type": "blob",
          "size": 22.375,
          "content": "// SPDX-License-Identifier: Zlib\n/*\n * TINYEXPR - Tiny recursive descent parser and evaluation engine in C\n *\n * Copyright (c) 2015-2020 Lewis Van Winkle\n *\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgement in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n/* COMPILE TIME OPTIONS */\n\n/* Exponentiation associativity:\nFor a^b^c = (a^b)^c and -a^b = (-a)^b do nothing.\nFor a^b^c = a^(b^c) and -a^b = -(a^b) uncomment the next line.*/\n/* #define TE_POW_FROM_RIGHT */\n\n/* Logarithms\nFor log = base 10 log do nothing\nFor log = natural log uncomment the next line. */\n/* #define TE_NAT_LOG */\n\n#include \"tinyexpr.h\"\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n\n#ifndef NAN\n#define NAN (0.0/0.0)\n#endif\n\n#ifndef INFINITY\n#define INFINITY (1.0/0.0)\n#endif\n\n\ntypedef double (*te_fun2)(double, double);\n\nenum {\n    TOK_NULL = TE_CLOSURE7+1, TOK_ERROR, TOK_END, TOK_SEP,\n    TOK_OPEN, TOK_CLOSE, TOK_NUMBER, TOK_VARIABLE, TOK_INFIX\n};\n\n\nenum {TE_CONSTANT = 1};\n\n\ntypedef struct state {\n    const char *start;\n    const char *next;\n    int type;\n    union {double value; const double *bound; const void *function;};\n    void *context;\n\n    const te_variable *lookup;\n    int lookup_len;\n} state;\n\n\n#define TYPE_MASK(TYPE) ((TYPE)&0x0000001F)\n\n#define IS_PURE(TYPE) (((TYPE) & TE_FLAG_PURE) != 0)\n#define IS_FUNCTION(TYPE) (((TYPE) & TE_FUNCTION0) != 0)\n#define IS_CLOSURE(TYPE) (((TYPE) & TE_CLOSURE0) != 0)\n#define ARITY(TYPE) ( ((TYPE) & (TE_FUNCTION0 | TE_CLOSURE0)) ? ((TYPE) & 0x00000007) : 0 )\n#define NEW_EXPR(type, ...) new_expr((type), (const te_expr*[]){__VA_ARGS__})\n#define CHECK_NULL(ptr, ...) if ((ptr) == NULL) { __VA_ARGS__; return NULL; }\n\nstatic te_expr *new_expr(const int type, const te_expr *parameters[]) {\n    const int arity = ARITY(type);\n    const int psize = sizeof(void*) * arity;\n    const int size = (sizeof(te_expr) - sizeof(void*)) + psize + (IS_CLOSURE(type) ? sizeof(void*) : 0);\n    te_expr *ret = malloc(size);\n    CHECK_NULL(ret);\n\n    memset(ret, 0, size);\n    if (arity && parameters) {\n        memcpy(ret->parameters, parameters, psize);\n    }\n    ret->type = type;\n    ret->bound = 0;\n    return ret;\n}\n\n\nvoid te_free_parameters(te_expr *n) {\n    if (!n) return;\n    switch (TYPE_MASK(n->type)) {\n        case TE_FUNCTION7: case TE_CLOSURE7: te_free(n->parameters[6]);     /* Falls through. */\n        case TE_FUNCTION6: case TE_CLOSURE6: te_free(n->parameters[5]);     /* Falls through. */\n        case TE_FUNCTION5: case TE_CLOSURE5: te_free(n->parameters[4]);     /* Falls through. */\n        case TE_FUNCTION4: case TE_CLOSURE4: te_free(n->parameters[3]);     /* Falls through. */\n        case TE_FUNCTION3: case TE_CLOSURE3: te_free(n->parameters[2]);     /* Falls through. */\n        case TE_FUNCTION2: case TE_CLOSURE2: te_free(n->parameters[1]);     /* Falls through. */\n        case TE_FUNCTION1: case TE_CLOSURE1: te_free(n->parameters[0]);\n    }\n}\n\n\nvoid te_free(te_expr *n) {\n    if (!n) return;\n    te_free_parameters(n);\n    free(n);\n}\n\n\nstatic double pi(void) {return 3.14159265358979323846;}\nstatic double e(void) {return 2.71828182845904523536;}\nstatic double fac(double a) {/* simplest version of fac */\n    if (a < 0.0)\n        return NAN;\n    if (a > UINT_MAX)\n        return INFINITY;\n    unsigned int ua = (unsigned int)(a);\n    unsigned long int result = 1, i;\n    for (i = 1; i <= ua; i++) {\n        if (i > ULONG_MAX / result)\n            return INFINITY;\n        result *= i;\n    }\n    return (double)result;\n}\nstatic double ncr(double n, double r) {\n    if (n < 0.0 || r < 0.0 || n < r) return NAN;\n    if (n > UINT_MAX || r > UINT_MAX) return INFINITY;\n    unsigned long int un = (unsigned int)(n), ur = (unsigned int)(r), i;\n    unsigned long int result = 1;\n    if (ur > un / 2) ur = un - ur;\n    for (i = 1; i <= ur; i++) {\n        if (result > ULONG_MAX / (un - ur + i))\n            return INFINITY;\n        result *= un - ur + i;\n        result /= i;\n    }\n    return result;\n}\nstatic double npr(double n, double r) {return ncr(n, r) * fac(r);}\n\n#ifdef _MSC_VER\n#pragma function (ceil)\n#pragma function (floor)\n#endif\n\nstatic const te_variable functions[] = {\n    /* must be in alphabetical order */\n    {\"abs\", fabs,     TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"acos\", acos,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"asin\", asin,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"atan\", atan,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"atan2\", atan2,  TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"ceil\", ceil,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"cos\", cos,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"cosh\", cosh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"e\", e,          TE_FUNCTION0 | TE_FLAG_PURE, 0},\n    {\"exp\", exp,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"fac\", fac,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"floor\", floor,  TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"ln\", log,       TE_FUNCTION1 | TE_FLAG_PURE, 0},\n#ifdef TE_NAT_LOG\n    {\"log\", log,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n#else\n    {\"log\", log10,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n#endif\n    {\"log10\", log10,  TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"ncr\", ncr,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"npr\", npr,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"pi\", pi,        TE_FUNCTION0 | TE_FLAG_PURE, 0},\n    {\"pow\", pow,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"sin\", sin,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"sinh\", sinh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"sqrt\", sqrt,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"tan\", tan,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"tanh\", tanh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {0, 0, 0, 0}\n};\n\nstatic const te_variable *find_builtin(const char *name, int len) {\n    int imin = 0;\n    int imax = sizeof(functions) / sizeof(te_variable) - 2;\n\n    /*Binary search.*/\n    while (imax >= imin) {\n        const int i = (imin + ((imax-imin)/2));\n        int c = strncmp(name, functions[i].name, len);\n        if (!c) c = '\\0' - functions[i].name[len];\n        if (c == 0) {\n            return functions + i;\n        } else if (c > 0) {\n            imin = i + 1;\n        } else {\n            imax = i - 1;\n        }\n    }\n\n    return 0;\n}\n\nstatic const te_variable *find_lookup(const state *s, const char *name, int len) {\n    int iters;\n    const te_variable *var;\n    if (!s->lookup) return 0;\n\n    for (var = s->lookup, iters = s->lookup_len; iters; ++var, --iters) {\n        if (strncmp(name, var->name, len) == 0 && var->name[len] == '\\0') {\n            return var;\n        }\n    }\n    return 0;\n}\n\n\n\nstatic double add(double a, double b) {return a + b;}\nstatic double sub(double a, double b) {return a - b;}\nstatic double mul(double a, double b) {return a * b;}\nstatic double divide(double a, double b) {return a / b;}\nstatic double negate(double a) {return -a;}\nstatic double comma(double a, double b) {(void)a; return b;}\n\n\nvoid next_token(state *s) {\n    s->type = TOK_NULL;\n\n    do {\n\n        if (!*s->next){\n            s->type = TOK_END;\n            return;\n        }\n\n        /* Try reading a number. */\n        if ((s->next[0] >= '0' && s->next[0] <= '9') || s->next[0] == '.') {\n            s->value = strtod(s->next, (char**)&s->next);\n            s->type = TOK_NUMBER;\n        } else {\n            /* Look for a variable or builtin function call. */\n            if (isalpha(s->next[0])) {\n                const char *start;\n                start = s->next;\n                while (isalpha(s->next[0]) || isdigit(s->next[0]) || (s->next[0] == '_')) s->next++;\n                \n                const te_variable *var = find_lookup(s, start, s->next - start);\n                if (!var) var = find_builtin(start, s->next - start);\n\n                if (!var) {\n                    s->type = TOK_ERROR;\n                } else {\n                    switch(TYPE_MASK(var->type))\n                    {\n                        case TE_VARIABLE:\n                            s->type = TOK_VARIABLE;\n                            s->bound = var->address;\n                            break;\n\n                        case TE_CLOSURE0: case TE_CLOSURE1: case TE_CLOSURE2: case TE_CLOSURE3:         /* Falls through. */\n                        case TE_CLOSURE4: case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:         /* Falls through. */\n                            s->context = var->context;                                                  /* Falls through. */\n\n                        case TE_FUNCTION0: case TE_FUNCTION1: case TE_FUNCTION2: case TE_FUNCTION3:     /* Falls through. */\n                        case TE_FUNCTION4: case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:     /* Falls through. */\n                            s->type = var->type;\n                            s->function = var->address;\n                            break;\n                    }\n                }\n\n            } else {\n                /* Look for an operator or special character. */\n                switch (s->next++[0]) {\n                    case '+': s->type = TOK_INFIX; s->function = add; break;\n                    case '-': s->type = TOK_INFIX; s->function = sub; break;\n                    case '*': s->type = TOK_INFIX; s->function = mul; break;\n                    case '/': s->type = TOK_INFIX; s->function = divide; break;\n                    case '^': s->type = TOK_INFIX; s->function = pow; break;\n                    case '%': s->type = TOK_INFIX; s->function = fmod; break;\n                    case '(': s->type = TOK_OPEN; break;\n                    case ')': s->type = TOK_CLOSE; break;\n                    case ',': s->type = TOK_SEP; break;\n                    case ' ': case '\\t': case '\\n': case '\\r': break;\n                    default: s->type = TOK_ERROR; break;\n                }\n            }\n        }\n    } while (s->type == TOK_NULL);\n}\n\n\nstatic te_expr *list(state *s);\nstatic te_expr *expr(state *s);\nstatic te_expr *power(state *s);\n\nstatic te_expr *base(state *s) {\n    /* <base>      =    <constant> | <variable> | <function-0> {\"(\" \")\"} | <function-1> <power> | <function-X> \"(\" <expr> {\",\" <expr>} \")\" | \"(\" <list> \")\" */\n    te_expr *ret;\n    int arity;\n\n    switch (TYPE_MASK(s->type)) {\n        case TOK_NUMBER:\n            ret = new_expr(TE_CONSTANT, 0);\n            CHECK_NULL(ret);\n\n            ret->value = s->value;\n            next_token(s);\n            break;\n\n        case TOK_VARIABLE:\n            ret = new_expr(TE_VARIABLE, 0);\n            CHECK_NULL(ret);\n\n            ret->bound = s->bound;\n            next_token(s);\n            break;\n\n        case TE_FUNCTION0:\n        case TE_CLOSURE0:\n            ret = new_expr(s->type, 0);\n            CHECK_NULL(ret);\n\n            ret->function = s->function;\n            if (IS_CLOSURE(s->type)) ret->parameters[0] = s->context;\n            next_token(s);\n            if (s->type == TOK_OPEN) {\n                next_token(s);\n                if (s->type != TOK_CLOSE) {\n                    s->type = TOK_ERROR;\n                } else {\n                    next_token(s);\n                }\n            }\n            break;\n\n        case TE_FUNCTION1:\n        case TE_CLOSURE1:\n            ret = new_expr(s->type, 0);\n            CHECK_NULL(ret);\n\n            ret->function = s->function;\n            if (IS_CLOSURE(s->type)) ret->parameters[1] = s->context;\n            next_token(s);\n            ret->parameters[0] = power(s);\n            CHECK_NULL(ret->parameters[0], te_free(ret));\n            break;\n\n        case TE_FUNCTION2: case TE_FUNCTION3: case TE_FUNCTION4:\n        case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:\n        case TE_CLOSURE2: case TE_CLOSURE3: case TE_CLOSURE4:\n        case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:\n            arity = ARITY(s->type);\n\n            ret = new_expr(s->type, 0);\n            CHECK_NULL(ret);\n\n            ret->function = s->function;\n            if (IS_CLOSURE(s->type)) ret->parameters[arity] = s->context;\n            next_token(s);\n\n            if (s->type != TOK_OPEN) {\n                s->type = TOK_ERROR;\n            } else {\n                int i;\n                for(i = 0; i < arity; i++) {\n                    next_token(s);\n                    ret->parameters[i] = expr(s);\n                    CHECK_NULL(ret->parameters[i], te_free(ret));\n\n                    if(s->type != TOK_SEP) {\n                        break;\n                    }\n                }\n                if(s->type != TOK_CLOSE || i != arity - 1) {\n                    s->type = TOK_ERROR;\n                } else {\n                    next_token(s);\n                }\n            }\n\n            break;\n\n        case TOK_OPEN:\n            next_token(s);\n            ret = list(s);\n            CHECK_NULL(ret);\n\n            if (s->type != TOK_CLOSE) {\n                s->type = TOK_ERROR;\n            } else {\n                next_token(s);\n            }\n            break;\n\n        default:\n            ret = new_expr(0, 0);\n            CHECK_NULL(ret);\n\n            s->type = TOK_ERROR;\n            ret->value = NAN;\n            break;\n    }\n\n    return ret;\n}\n\n\nstatic te_expr *power(state *s) {\n    /* <power>     =    {(\"-\" | \"+\")} <base> */\n    int sign = 1;\n    while (s->type == TOK_INFIX && (s->function == add || s->function == sub)) {\n        if (s->function == sub) sign = -sign;\n        next_token(s);\n    }\n\n    te_expr *ret;\n\n    if (sign == 1) {\n        ret = base(s);\n    } else {\n        te_expr *b = base(s);\n        CHECK_NULL(b);\n\n        ret = NEW_EXPR(TE_FUNCTION1 | TE_FLAG_PURE, b);\n        CHECK_NULL(ret, te_free(b));\n\n        ret->function = negate;\n    }\n\n    return ret;\n}\n\n#ifdef TE_POW_FROM_RIGHT\nstatic te_expr *factor(state *s) {\n    /* <factor>    =    <power> {\"^\" <power>} */\n    te_expr *ret = power(s);\n    CHECK_NULL(ret);\n\n    int neg = 0;\n\n    if (ret->type == (TE_FUNCTION1 | TE_FLAG_PURE) && ret->function == negate) {\n        te_expr *se = ret->parameters[0];\n        free(ret);\n        ret = se;\n        neg = 1;\n    }\n\n    te_expr *insertion = 0;\n\n    while (s->type == TOK_INFIX && (s->function == pow)) {\n        te_fun2 t = s->function;\n        next_token(s);\n\n        if (insertion) {\n            /* Make exponentiation go right-to-left. */\n            te_expr *p = power(s);\n            CHECK_NULL(p, te_free(ret));\n\n            te_expr *insert = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, insertion->parameters[1], p);\n            CHECK_NULL(insert, te_free(p), te_free(ret));\n\n            insert->function = t;\n            insertion->parameters[1] = insert;\n            insertion = insert;\n        } else {\n            te_expr *p = power(s);\n            CHECK_NULL(p, te_free(ret));\n\n            te_expr *prev = ret;\n            ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, p);\n            CHECK_NULL(ret, te_free(p), te_free(prev));\n\n            ret->function = t;\n            insertion = ret;\n        }\n    }\n\n    if (neg) {\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION1 | TE_FLAG_PURE, ret);\n        CHECK_NULL(ret, te_free(prev));\n\n        ret->function = negate;\n    }\n\n    return ret;\n}\n#else\nstatic te_expr *factor(state *s) {\n    /* <factor>    =    <power> {\"^\" <power>} */\n    te_expr *ret = power(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_INFIX && (s->function == pow)) {\n        te_fun2 t = s->function;\n        next_token(s);\n        te_expr *p = power(s);\n        CHECK_NULL(p, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, p);\n        CHECK_NULL(ret, te_free(p), te_free(prev));\n\n        ret->function = t;\n    }\n\n    return ret;\n}\n#endif\n\n\n\nstatic te_expr *term(state *s) {\n    /* <term>      =    <factor> {(\"*\" | \"/\" | \"%\") <factor>} */\n    te_expr *ret = factor(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_INFIX && (s->function == mul || s->function == divide || s->function == fmod)) {\n        te_fun2 t = s->function;\n        next_token(s);\n        te_expr *f = factor(s);\n        CHECK_NULL(f, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, f);\n        CHECK_NULL(ret, te_free(f), te_free(prev));\n\n        ret->function = t;\n    }\n\n    return ret;\n}\n\n\nstatic te_expr *expr(state *s) {\n    /* <expr>      =    <term> {(\"+\" | \"-\") <term>} */\n    te_expr *ret = term(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_INFIX && (s->function == add || s->function == sub)) {\n        te_fun2 t = s->function;\n        next_token(s);\n        te_expr *te = term(s);\n        CHECK_NULL(te, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, te);\n        CHECK_NULL(ret, te_free(te), te_free(prev));\n\n        ret->function = t;\n    }\n\n    return ret;\n}\n\n\nstatic te_expr *list(state *s) {\n    /* <list>      =    <expr> {\",\" <expr>} */\n    te_expr *ret = expr(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_SEP) {\n        next_token(s);\n        te_expr *e = expr(s);\n        CHECK_NULL(e, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, e);\n        CHECK_NULL(ret, te_free(e), te_free(prev));\n\n        ret->function = comma;\n    }\n\n    return ret;\n}\n\n\n#define TE_FUN(...) ((double(*)(__VA_ARGS__))n->function)\n#define M(e) te_eval(n->parameters[e])\n\n\ndouble te_eval(const te_expr *n) {\n    if (!n) return NAN;\n\n    switch(TYPE_MASK(n->type)) {\n        case TE_CONSTANT: return n->value;\n        case TE_VARIABLE: return *n->bound;\n\n        case TE_FUNCTION0: case TE_FUNCTION1: case TE_FUNCTION2: case TE_FUNCTION3:\n        case TE_FUNCTION4: case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:\n            switch(ARITY(n->type)) {\n                case 0: return TE_FUN(void)();\n                case 1: return TE_FUN(double)(M(0));\n                case 2: return TE_FUN(double, double)(M(0), M(1));\n                case 3: return TE_FUN(double, double, double)(M(0), M(1), M(2));\n                case 4: return TE_FUN(double, double, double, double)(M(0), M(1), M(2), M(3));\n                case 5: return TE_FUN(double, double, double, double, double)(M(0), M(1), M(2), M(3), M(4));\n                case 6: return TE_FUN(double, double, double, double, double, double)(M(0), M(1), M(2), M(3), M(4), M(5));\n                case 7: return TE_FUN(double, double, double, double, double, double, double)(M(0), M(1), M(2), M(3), M(4), M(5), M(6));\n                default: return NAN;\n            }\n\n        case TE_CLOSURE0: case TE_CLOSURE1: case TE_CLOSURE2: case TE_CLOSURE3:\n        case TE_CLOSURE4: case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:\n            switch(ARITY(n->type)) {\n                case 0: return TE_FUN(void*)(n->parameters[0]);\n                case 1: return TE_FUN(void*, double)(n->parameters[1], M(0));\n                case 2: return TE_FUN(void*, double, double)(n->parameters[2], M(0), M(1));\n                case 3: return TE_FUN(void*, double, double, double)(n->parameters[3], M(0), M(1), M(2));\n                case 4: return TE_FUN(void*, double, double, double, double)(n->parameters[4], M(0), M(1), M(2), M(3));\n                case 5: return TE_FUN(void*, double, double, double, double, double)(n->parameters[5], M(0), M(1), M(2), M(3), M(4));\n                case 6: return TE_FUN(void*, double, double, double, double, double, double)(n->parameters[6], M(0), M(1), M(2), M(3), M(4), M(5));\n                case 7: return TE_FUN(void*, double, double, double, double, double, double, double)(n->parameters[7], M(0), M(1), M(2), M(3), M(4), M(5), M(6));\n                default: return NAN;\n            }\n\n        default: return NAN;\n    }\n\n}\n\n#undef TE_FUN\n#undef M\n\nstatic void optimize(te_expr *n) {\n    /* Evaluates as much as possible. */\n    if (n->type == TE_CONSTANT) return;\n    if (n->type == TE_VARIABLE) return;\n\n    /* Only optimize out functions flagged as pure. */\n    if (IS_PURE(n->type)) {\n        const int arity = ARITY(n->type);\n        int known = 1;\n        int i;\n        for (i = 0; i < arity; ++i) {\n            optimize(n->parameters[i]);\n            if (((te_expr*)(n->parameters[i]))->type != TE_CONSTANT) {\n                known = 0;\n            }\n        }\n        if (known) {\n            const double value = te_eval(n);\n            te_free_parameters(n);\n            n->type = TE_CONSTANT;\n            n->value = value;\n        }\n    }\n}\n\n\nte_expr *te_compile(const char *expression, const te_variable *variables, int var_count, int *error) {\n    state s;\n    s.start = s.next = expression;\n    s.lookup = variables;\n    s.lookup_len = var_count;\n\n    next_token(&s);\n    te_expr *root = list(&s);\n    if (root == NULL) {\n        if (error) *error = -1;\n        return NULL;\n    }\n\n    if (s.type != TOK_END) {\n        te_free(root);\n        if (error) {\n            *error = (s.next - s.start);\n            if (*error == 0) *error = 1;\n        }\n        return 0;\n    } else {\n        optimize(root);\n        if (error) *error = 0;\n        return root;\n    }\n}\n\n\ndouble te_interp(const char *expression, int *error) {\n    te_expr *n = te_compile(expression, 0, 0, error);\n\n    double ret;\n    if (n) {\n        ret = te_eval(n);\n        te_free(n);\n    } else {\n        ret = NAN;\n    }\n    return ret;\n}\n\nstatic void pn (const te_expr *n, int depth) {\n    int i, arity;\n    printf(\"%*s\", depth, \"\");\n\n    switch(TYPE_MASK(n->type)) {\n    case TE_CONSTANT: printf(\"%f\\n\", n->value); break;\n    case TE_VARIABLE: printf(\"bound %p\\n\", n->bound); break;\n\n    case TE_FUNCTION0: case TE_FUNCTION1: case TE_FUNCTION2: case TE_FUNCTION3:\n    case TE_FUNCTION4: case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:\n    case TE_CLOSURE0: case TE_CLOSURE1: case TE_CLOSURE2: case TE_CLOSURE3:\n    case TE_CLOSURE4: case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:\n         arity = ARITY(n->type);\n         printf(\"f%d\", arity);\n         for(i = 0; i < arity; i++) {\n             printf(\" %p\", n->parameters[i]);\n         }\n         printf(\"\\n\");\n         for(i = 0; i < arity; i++) {\n             pn(n->parameters[i], depth + 1);\n         }\n         break;\n    }\n}\n\n\nvoid te_print(const te_expr *n) {\n    pn(n, 0);\n}\n"
        },
        {
          "name": "tinyexpr.h",
          "type": "blob",
          "size": 2.2783203125,
          "content": "// SPDX-License-Identifier: Zlib\n/*\n * TINYEXPR - Tiny recursive descent parser and evaluation engine in C\n *\n * Copyright (c) 2015-2020 Lewis Van Winkle\n *\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgement in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n#ifndef TINYEXPR_H\n#define TINYEXPR_H\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\ntypedef struct te_expr {\n    int type;\n    union {double value; const double *bound; const void *function;};\n    void *parameters[1];\n} te_expr;\n\n\nenum {\n    TE_VARIABLE = 0,\n\n    TE_FUNCTION0 = 8, TE_FUNCTION1, TE_FUNCTION2, TE_FUNCTION3,\n    TE_FUNCTION4, TE_FUNCTION5, TE_FUNCTION6, TE_FUNCTION7,\n\n    TE_CLOSURE0 = 16, TE_CLOSURE1, TE_CLOSURE2, TE_CLOSURE3,\n    TE_CLOSURE4, TE_CLOSURE5, TE_CLOSURE6, TE_CLOSURE7,\n\n    TE_FLAG_PURE = 32\n};\n\ntypedef struct te_variable {\n    const char *name;\n    const void *address;\n    int type;\n    void *context;\n} te_variable;\n\n\n\n/* Parses the input expression, evaluates it, and frees it. */\n/* Returns NaN on error. */\ndouble te_interp(const char *expression, int *error);\n\n/* Parses the input expression and binds variables. */\n/* Returns NULL on error. */\nte_expr *te_compile(const char *expression, const te_variable *variables, int var_count, int *error);\n\n/* Evaluates the expression. */\ndouble te_eval(const te_expr *n);\n\n/* Prints debugging information on the syntax tree. */\nvoid te_print(const te_expr *n);\n\n/* Frees the expression. */\n/* This is safe to call on NULL pointers. */\nvoid te_free(te_expr *n);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*TINYEXPR_H*/\n"
        }
      ]
    }
  ]
}