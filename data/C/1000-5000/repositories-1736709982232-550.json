{
  "metadata": {
    "timestamp": 1736709982232,
    "page": 550,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "skywind3000/mini3d",
      "stars": 2225,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2763671875,
          "content": "# Object files\n*.o\n*.ko\n*.obj\n*.elf\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Libraries\n*.lib\n*.a\n*.la\n*.lo\n\n# Shared objects (inc. Windows DLLs)\n*.dll\n*.so\n*.so.*\n*.dylib\n\n# Executables\n*.exe\n*.out\n*.app\n*.i*86\n*.x86_64\n*.hex\n\n# Debug files\n*.dSYM/\n\n/.vscode/*\n*.jpg\n*.jpeg\n*.png\n*.bmp\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Linwei\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "Mini3D.sln",
          "type": "blob",
          "size": 0.857421875,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 11.00\r\n# Visual Studio 2010\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"Mini3D\", \"Mini3D.vcxproj\", \"{433E9031-0101-4ADF-A6DA-283375FD1898}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Win32 = Debug|Win32\r\n\t\tRelease|Win32 = Release|Win32\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{433E9031-0101-4ADF-A6DA-283375FD1898}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{433E9031-0101-4ADF-A6DA-283375FD1898}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{433E9031-0101-4ADF-A6DA-283375FD1898}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{433E9031-0101-4ADF-A6DA-283375FD1898}.Release|Win32.Build.0 = Release|Win32\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "Mini3D.vcxproj",
          "type": "blob",
          "size": 3.82421875,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup Label=\"ProjectConfigurations\">\r\n    <ProjectConfiguration Include=\"Debug|Win32\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|Win32\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n  </ItemGroup>\r\n  <PropertyGroup Label=\"Globals\">\r\n    <ProjectGuid>{433E9031-0101-4ADF-A6DA-283375FD1898}</ProjectGuid>\r\n    <Keyword>Win32Proj</Keyword>\r\n    <RootNamespace>Mini3D</RootNamespace>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseDebugLibraries>true</UseDebugLibraries>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Application</ConfigurationType>\r\n    <UseDebugLibraries>false</UseDebugLibraries>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\r\n  <ImportGroup Label=\"ExtensionSettings\">\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <PropertyGroup Label=\"UserMacros\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <LinkIncremental>true</LinkIncremental>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <LinkIncremental>false</LinkIncremental>\r\n  </PropertyGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <ClCompile>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <Optimization>Disabled</Optimization>\r\n      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <Link>\r\n      <SubSystem>Console</SubSystem>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <ClCompile>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <PrecompiledHeader>\r\n      </PrecompiledHeader>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n    <Link>\r\n      <SubSystem>Console</SubSystem>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"mini3d.c\" />\r\n  </ItemGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\r\n  <ImportGroup Label=\"ExtensionTargets\">\r\n  </ImportGroup>\r\n</Project>"
        },
        {
          "name": "Mini3D.vcxproj.filters",
          "type": "blob",
          "size": 0.20703125,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup>\r\n    <ClCompile Include=\"mini3d.c\" />\r\n  </ItemGroup>\r\n</Project>"
        },
        {
          "name": "README.en.md",
          "type": "blob",
          "size": 3.4228515625,
          "content": "# mini3d\r\n\r\n3D software rendering tutorial, without any performance optimization, mainly explains how to write a fixed pipeline software renderer. Although the main code is only 700 lines, it is small but complete.\r\n\r\n## Features\r\n\r\n* Single File: The source code consists of only one file, mini3d.c, which implements all the functionality. It is easy to read and understand.\r\n* Independent Compilation: There is no third-party library dependency and no complex project directory.\r\n* Model Standard: Uses the standard D3D coordinate model, left-handed system with WORLD/VIEW/PROJECTION matrices.\r\n* Clipping Implementation: Implements simple CVV (Canonical View Volume) clipping.\r\n* Texture Support: Supports textures up to a maximum of 1024 x 1024.\r\n* Depth Buffering: Uses a depth buffer to determine the order of image rendering.\r\n* Perspective Texture Mapping: Implements perspective texture mapping and perspective color filling.\r\n* Edge Calculation: Accurately calculates polygon edge coverage.\r\n* Simplified Implementation: The rendering engine consists of only 700 lines of code, with clear modules and a prominent main structure.\r\n* Detailed Comments: The primary code is well-documented with detailed comments.\r\n\r\n## Compile\r\n\r\n* mingw: \r\n\t\tgcc -O3 mini3d.c -o mini3d.exe -lgdi32\r\n* msvc:\r\n\t\tcl -O2 -nologo mini3d.c \r\n* Compiled version:\r\n[https://github.com/skywind3000/mini3d/releases](https://github.com/skywind3000/mini3d/releases)\r\n\r\n## Demonstration\r\n\r\nTexture Mapping：RENDER_STATE_TEXTURE\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_1.png)\r\n\r\nColor Filling：RENDER_STATE_COLOR\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_0.png)\r\n\r\nWireframe Rendering：RENDER_STATE_WIREFRAME\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_2.png)\r\n\r\nAdded Lighting and Bicubic Interpolation (screenshot of lighting effect added by a friend to Mini3D)\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_3.png)\r\n\r\n## Basic TO-DO:\r\n\r\n* Add backface culling\r\n* Implement simple lighting\r\n* Provide more rendering modes\r\n* Implement texture sampling with bicubic interpolation\r\n\r\n## Advanced TO-DO:\r\n\r\n* Derive and prove all geometric knowledge used in the program\r\n* Optimize vertex computation performance\r\n* Optimize draw_scanline performance\r\n* Load textures from BMP/TGA files\r\n* Load BSP scenes and implement roaming.\r\n\r\n## Explanation of principles\r\n\r\n- [Wei Yixiao: How do OpenGL and DirectX determine the position of pixels only based on vertices?](https://skywind.me/blog/archives/2594)\r\n- [Wei Yixiao: How does the computer access the graphics card at a low level?](https://skywind.me/blog/archives/1774)\r\n\r\n## Related Projects\r\n\r\n- [RenderHelp](https://github.com/skywind3000/RenderHelp)：Another implementation of a streamlined software renderer with support for programmable rendering pipelines, for more details see https://skywind.me/blog/archives/2589\r\n\r\n## Welcome to donate:\r\n\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/donation.png)\r\n\r\nYour donation is the greatest recognition for this tutorial. You are welcome to use Alipay to scan the QR code above to make a donation. The donated funds will be used to improve the tutorial documentation and illustrations, as well as to help me write more interesting tutorials.\r\n\r\n\r\n\r\n## Welcome to follow us:\r\n\r\nblog: https://skywind.me/blog\r\n\r\nzhihu: https://www.zhihu.com/people/skywind3000 \r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.8662109375,
          "content": "# mini3d\r\n\r\n3D软件渲染教程，并没有任何性能优化，主要向人说明如何写一个固定管线的软件渲染器。虽然主体代码只有 700行，但是麻雀虽小，五脏俱全。\r\n\r\n【[README in English](README.en.md)】\r\n\r\n## 特性\r\n\r\n* 单个文件：源代码只有一个 mini3d.c，单个文件实现所有内容，容易阅读。\r\n* 独立编译：没有任何第三方库依赖，没有复杂的工程目录。\r\n* 模型标准：标准 D3D 坐标模型，左手系加 WORLD / VIEW / PROJECTION 三矩阵\r\n* 实现裁剪：简单 CVV 裁剪\r\n* 纹理支持：最大支持 1024 x 1024 的纹理\r\n* 深度缓存：使用深度缓存判断图像前后\r\n* 透视贴图：透视纹理映射以及透视色彩填充\r\n* 边缘计算：精确的多边形边缘覆盖计算\r\n* 实现精简：渲染引擎只有 700行，模块清晰，主干突出。\r\n* 详细注释：主要代码详细注释\r\n\r\n## 编译\r\n\r\n* mingw: \r\n\t\tgcc -O3 mini3d.c -o mini3d.exe -lgdi32\r\n* msvc:\r\n\t\tcl -O2 -nologo mini3d.c \r\n* 已编译版本：\r\n[https://github.com/skywind3000/mini3d/releases](https://github.com/skywind3000/mini3d/releases)\r\n\r\n## 演示\r\n\r\n纹理填充：RENDER_STATE_TEXTURE\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_1.png)\r\n\r\n色彩填充：RENDER_STATE_COLOR\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_0.png)\r\n\r\n线框绘制：RENDER_STATE_WIREFRAME\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_2.png)\r\n\r\n增加光照和二次线性插值（朋友给 Mini3D 增加的光照效果截图）\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/mini_3.png)\r\n\r\n## 基础作业\r\n\r\n* 增加背面剔除\r\n* 增加简单光照\r\n* 提供更多渲染模式\r\n* 实现二次线性差值的纹理读取\r\n\r\n## 进阶作业\r\n\r\n* 推导并证明程序中用到的所有几何知识\r\n* 优化顶点计算性能\r\n* 优化 draw_scanline 性能\r\n* 从 BMP/TGA 文件加载纹理\r\n* 载入 BSP 场景并实现漫游\r\n\r\n## 原理讲解\r\n\r\n- [韦易笑：OpenGL 和 DirectX 是如何在只知道顶点的情况下得出像素位置的？](https://skywind.me/blog/archives/2594)\r\n- [韦易笑：计算机底层是如何访问显卡的？](https://skywind.me/blog/archives/1774)\r\n\r\n## 相关项目\r\n\r\n- [RenderHelp](https://github.com/skywind3000/RenderHelp)：另外一个支持可编程渲染管线的精简软渲染器实现，详细见 [介绍](https://skywind.me/blog/archives/2589)。\r\n\r\n## 欢迎捐赠\r\n\r\n![](https://raw.githubusercontent.com/skywind3000/mini3d/master/images/donation.png)\r\n\r\n您的捐助是对该教程的最大肯定，欢迎使用支付宝手扫描上面的二维码，进行捐赠。捐赠款项将用于完善教程文档和图例，以及帮助我写出更多有意思的教程来。\r\n\r\n\r\n\r\n欢迎关注\r\n\r\nblog: https://skywind.me/blog\r\n\r\nzhihu: https://www.zhihu.com/people/skywind3000 \r\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "mini3d.c",
          "type": "blob",
          "size": 29.11328125,
          "content": "//=====================================================================\r\n// \r\n// mini3d.c - Mini Software Render All-In-One\r\n//\r\n// build:\r\n//   mingw: gcc -O3 mini3d.c -o mini3d.exe -lgdi32\r\n//   msvc:  cl -O2 -nologo mini3d.c \r\n//\r\n// history:\r\n//   2007.7.01  skywind  create this file as a tutorial\r\n//   2007.7.02  skywind  implementate texture and color render\r\n//   2008.3.15  skywind  fixed a trapezoid issue\r\n//   2015.8.09  skywind  rewrite with more comment\r\n//   2015.8.12  skywind  adjust interfaces for clearity \r\n// \r\n//=====================================================================\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <assert.h>\r\n\r\n#include <windows.h>\r\n#include <tchar.h>\r\n\r\ntypedef unsigned int IUINT32;\r\n\r\n//=====================================================================\r\n// 数学库：此部分应该不用详解，熟悉 D3D 矩阵变换即可\r\n//=====================================================================\r\ntypedef struct { float m[4][4]; } matrix_t;\r\ntypedef struct { float x, y, z, w; } vector_t;\r\ntypedef vector_t point_t;\r\n\r\nint CMID(int x, int min, int max) { return (x < min)? min : ((x > max)? max : x); }\r\n\r\n// 计算插值：t 为 [0, 1] 之间的数值\r\nfloat interp(float x1, float x2, float t) { return x1 + (x2 - x1) * t; }\r\n\r\n// | v |\r\nfloat vector_length(const vector_t *v) {\r\n\tfloat sq = v->x * v->x + v->y * v->y + v->z * v->z;\r\n\treturn (float)sqrt(sq);\r\n}\r\n\r\n// z = x + y\r\nvoid vector_add(vector_t *z, const vector_t *x, const vector_t *y) {\r\n\tz->x = x->x + y->x;\r\n\tz->y = x->y + y->y;\r\n\tz->z = x->z + y->z;\r\n\tz->w = 1.0;\r\n}\r\n\r\n// z = x - y\r\nvoid vector_sub(vector_t *z, const vector_t *x, const vector_t *y) {\r\n\tz->x = x->x - y->x;\r\n\tz->y = x->y - y->y;\r\n\tz->z = x->z - y->z;\r\n\tz->w = 1.0;\r\n}\r\n\r\n// 矢量点乘\r\nfloat vector_dotproduct(const vector_t *x, const vector_t *y) {\r\n\treturn x->x * y->x + x->y * y->y + x->z * y->z;\r\n}\r\n\r\n// 矢量叉乘\r\nvoid vector_crossproduct(vector_t *z, const vector_t *x, const vector_t *y) {\r\n\tfloat m1, m2, m3;\r\n\tm1 = x->y * y->z - x->z * y->y;\r\n\tm2 = x->z * y->x - x->x * y->z;\r\n\tm3 = x->x * y->y - x->y * y->x;\r\n\tz->x = m1;\r\n\tz->y = m2;\r\n\tz->z = m3;\r\n\tz->w = 1.0f;\r\n}\r\n\r\n// 矢量插值，t取值 [0, 1]\r\nvoid vector_interp(vector_t *z, const vector_t *x1, const vector_t *x2, float t) {\r\n\tz->x = interp(x1->x, x2->x, t);\r\n\tz->y = interp(x1->y, x2->y, t);\r\n\tz->z = interp(x1->z, x2->z, t);\r\n\tz->w = 1.0f;\r\n}\r\n\r\n// 矢量归一化\r\nvoid vector_normalize(vector_t *v) {\r\n\tfloat length = vector_length(v);\r\n\tif (length != 0.0f) {\r\n\t\tfloat inv = 1.0f / length;\r\n\t\tv->x *= inv; \r\n\t\tv->y *= inv;\r\n\t\tv->z *= inv;\r\n\t}\r\n}\r\n\r\n// c = a + b\r\nvoid matrix_add(matrix_t *c, const matrix_t *a, const matrix_t *b) {\r\n\tint i, j;\r\n\tfor (i = 0; i < 4; i++) {\r\n\t\tfor (j = 0; j < 4; j++)\r\n\t\t\tc->m[i][j] = a->m[i][j] + b->m[i][j];\r\n\t}\r\n}\r\n\r\n// c = a - b\r\nvoid matrix_sub(matrix_t *c, const matrix_t *a, const matrix_t *b) {\r\n\tint i, j;\r\n\tfor (i = 0; i < 4; i++) {\r\n\t\tfor (j = 0; j < 4; j++)\r\n\t\t\tc->m[i][j] = a->m[i][j] - b->m[i][j];\r\n\t}\r\n}\r\n\r\n// c = a * b\r\nvoid matrix_mul(matrix_t *c, const matrix_t *a, const matrix_t *b) {\r\n\tmatrix_t z;\r\n\tint i, j;\r\n\tfor (i = 0; i < 4; i++) {\r\n\t\tfor (j = 0; j < 4; j++) {\r\n\t\t\tz.m[j][i] = (a->m[j][0] * b->m[0][i]) +\r\n\t\t\t\t\t\t(a->m[j][1] * b->m[1][i]) +\r\n\t\t\t\t\t\t(a->m[j][2] * b->m[2][i]) +\r\n\t\t\t\t\t\t(a->m[j][3] * b->m[3][i]);\r\n\t\t}\r\n\t}\r\n\tc[0] = z;\r\n}\r\n\r\n// c = a * f\r\nvoid matrix_scale(matrix_t *c, const matrix_t *a, float f) {\r\n\tint i, j;\r\n\tfor (i = 0; i < 4; i++) {\r\n\t\tfor (j = 0; j < 4; j++) \r\n\t\t\tc->m[i][j] = a->m[i][j] * f;\r\n\t}\r\n}\r\n\r\n// y = x * m\r\nvoid matrix_apply(vector_t *y, const vector_t *x, const matrix_t *m) {\r\n\tfloat X = x->x, Y = x->y, Z = x->z, W = x->w;\r\n\ty->x = X * m->m[0][0] + Y * m->m[1][0] + Z * m->m[2][0] + W * m->m[3][0];\r\n\ty->y = X * m->m[0][1] + Y * m->m[1][1] + Z * m->m[2][1] + W * m->m[3][1];\r\n\ty->z = X * m->m[0][2] + Y * m->m[1][2] + Z * m->m[2][2] + W * m->m[3][2];\r\n\ty->w = X * m->m[0][3] + Y * m->m[1][3] + Z * m->m[2][3] + W * m->m[3][3];\r\n}\r\n\r\nvoid matrix_set_identity(matrix_t *m) {\r\n\tm->m[0][0] = m->m[1][1] = m->m[2][2] = m->m[3][3] = 1.0f; \r\n\tm->m[0][1] = m->m[0][2] = m->m[0][3] = 0.0f;\r\n\tm->m[1][0] = m->m[1][2] = m->m[1][3] = 0.0f;\r\n\tm->m[2][0] = m->m[2][1] = m->m[2][3] = 0.0f;\r\n\tm->m[3][0] = m->m[3][1] = m->m[3][2] = 0.0f;\r\n}\r\n\r\nvoid matrix_set_zero(matrix_t *m) {\r\n\tm->m[0][0] = m->m[0][1] = m->m[0][2] = m->m[0][3] = 0.0f;\r\n\tm->m[1][0] = m->m[1][1] = m->m[1][2] = m->m[1][3] = 0.0f;\r\n\tm->m[2][0] = m->m[2][1] = m->m[2][2] = m->m[2][3] = 0.0f;\r\n\tm->m[3][0] = m->m[3][1] = m->m[3][2] = m->m[3][3] = 0.0f;\r\n}\r\n\r\n// 平移变换\r\nvoid matrix_set_translate(matrix_t *m, float x, float y, float z) {\r\n\tmatrix_set_identity(m);\r\n\tm->m[3][0] = x;\r\n\tm->m[3][1] = y;\r\n\tm->m[3][2] = z;\r\n}\r\n\r\n// 缩放变换\r\nvoid matrix_set_scale(matrix_t *m, float x, float y, float z) {\r\n\tmatrix_set_identity(m);\r\n\tm->m[0][0] = x;\r\n\tm->m[1][1] = y;\r\n\tm->m[2][2] = z;\r\n}\r\n\r\n// 旋转矩阵\r\nvoid matrix_set_rotate(matrix_t *m, float x, float y, float z, float theta) {\r\n\tfloat qsin = (float)sin(theta * 0.5f);\r\n\tfloat qcos = (float)cos(theta * 0.5f);\r\n\tvector_t vec = { x, y, z, 1.0f };\r\n\tfloat w = qcos;\r\n\tvector_normalize(&vec);\r\n\tx = vec.x * qsin;\r\n\ty = vec.y * qsin;\r\n\tz = vec.z * qsin;\r\n\tm->m[0][0] = 1 - 2 * y * y - 2 * z * z;\r\n\tm->m[1][0] = 2 * x * y - 2 * w * z;\r\n\tm->m[2][0] = 2 * x * z + 2 * w * y;\r\n\tm->m[0][1] = 2 * x * y + 2 * w * z;\r\n\tm->m[1][1] = 1 - 2 * x * x - 2 * z * z;\r\n\tm->m[2][1] = 2 * y * z - 2 * w * x;\r\n\tm->m[0][2] = 2 * x * z - 2 * w * y;\r\n\tm->m[1][2] = 2 * y * z + 2 * w * x;\r\n\tm->m[2][2] = 1 - 2 * x * x - 2 * y * y;\r\n\tm->m[0][3] = m->m[1][3] = m->m[2][3] = 0.0f;\r\n\tm->m[3][0] = m->m[3][1] = m->m[3][2] = 0.0f;\t\r\n\tm->m[3][3] = 1.0f;\r\n}\r\n\r\n// 设置摄像机\r\nvoid matrix_set_lookat(matrix_t *m, const vector_t *eye, const vector_t *at, const vector_t *up) {\r\n\tvector_t xaxis, yaxis, zaxis;\r\n\r\n\tvector_sub(&zaxis, at, eye);\r\n\tvector_normalize(&zaxis);\r\n\tvector_crossproduct(&xaxis, up, &zaxis);\r\n\tvector_normalize(&xaxis);\r\n\tvector_crossproduct(&yaxis, &zaxis, &xaxis);\r\n\r\n\tm->m[0][0] = xaxis.x;\r\n\tm->m[1][0] = xaxis.y;\r\n\tm->m[2][0] = xaxis.z;\r\n\tm->m[3][0] = -vector_dotproduct(&xaxis, eye);\r\n\r\n\tm->m[0][1] = yaxis.x;\r\n\tm->m[1][1] = yaxis.y;\r\n\tm->m[2][1] = yaxis.z;\r\n\tm->m[3][1] = -vector_dotproduct(&yaxis, eye);\r\n\r\n\tm->m[0][2] = zaxis.x;\r\n\tm->m[1][2] = zaxis.y;\r\n\tm->m[2][2] = zaxis.z;\r\n\tm->m[3][2] = -vector_dotproduct(&zaxis, eye);\r\n\t\r\n\tm->m[0][3] = m->m[1][3] = m->m[2][3] = 0.0f;\r\n\tm->m[3][3] = 1.0f;\r\n}\r\n\r\n// D3DXMatrixPerspectiveFovLH\r\nvoid matrix_set_perspective(matrix_t *m, float fovy, float aspect, float zn, float zf) {\r\n\tfloat fax = 1.0f / (float)tan(fovy * 0.5f);\r\n\tmatrix_set_zero(m);\r\n\tm->m[0][0] = (float)(fax / aspect);\r\n\tm->m[1][1] = (float)(fax);\r\n\tm->m[2][2] = zf / (zf - zn);\r\n\tm->m[3][2] = - zn * zf / (zf - zn);\r\n\tm->m[2][3] = 1;\r\n}\r\n\r\n\r\n//=====================================================================\r\n// 坐标变换\r\n//=====================================================================\r\ntypedef struct { \r\n\tmatrix_t world;         // 世界坐标变换\r\n\tmatrix_t view;          // 摄影机坐标变换\r\n\tmatrix_t projection;    // 投影变换\r\n\tmatrix_t transform;     // transform = world * view * projection\r\n\tfloat w, h;             // 屏幕大小\r\n}\ttransform_t;\r\n\r\n\r\n// 矩阵更新，计算 transform = world * view * projection\r\nvoid transform_update(transform_t *ts) {\r\n\tmatrix_t m;\r\n\tmatrix_mul(&m, &ts->world, &ts->view);\r\n\tmatrix_mul(&ts->transform, &m, &ts->projection);\r\n}\r\n\r\n// 初始化，设置屏幕长宽\r\nvoid transform_init(transform_t *ts, int width, int height) {\r\n\tfloat aspect = (float)width / ((float)height);\r\n\tmatrix_set_identity(&ts->world);\r\n\tmatrix_set_identity(&ts->view);\r\n\tmatrix_set_perspective(&ts->projection, 3.1415926f * 0.5f, aspect, 1.0f, 500.0f);\r\n\tts->w = (float)width;\r\n\tts->h = (float)height;\r\n\ttransform_update(ts);\r\n}\r\n\r\n// 将矢量 x 进行 project \r\nvoid transform_apply(const transform_t *ts, vector_t *y, const vector_t *x) {\r\n\tmatrix_apply(y, x, &ts->transform);\r\n}\r\n\r\n// 检查齐次坐标同 cvv 的边界用于视锥裁剪\r\nint transform_check_cvv(const vector_t *v) {\r\n\tfloat w = v->w;\r\n\tint check = 0;\r\n\tif (v->z < 0.0f) check |= 1;\r\n\tif (v->z >  w) check |= 2;\r\n\tif (v->x < -w) check |= 4;\r\n\tif (v->x >  w) check |= 8;\r\n\tif (v->y < -w) check |= 16;\r\n\tif (v->y >  w) check |= 32;\r\n\treturn check;\r\n}\r\n\r\n// 归一化，得到屏幕坐标\r\nvoid transform_homogenize(const transform_t *ts, vector_t *y, const vector_t *x) {\r\n\tfloat rhw = 1.0f / x->w;\r\n\ty->x = (x->x * rhw + 1.0f) * ts->w * 0.5f;\r\n\ty->y = (1.0f - x->y * rhw) * ts->h * 0.5f;\r\n\ty->z = x->z * rhw;\r\n\ty->w = 1.0f;\r\n}\r\n\r\n\r\n//=====================================================================\r\n// 几何计算：顶点、扫描线、边缘、矩形、步长计算\r\n//=====================================================================\r\ntypedef struct { float r, g, b; } color_t;\r\ntypedef struct { float u, v; } texcoord_t;\r\ntypedef struct { point_t pos; texcoord_t tc; color_t color; float rhw; } vertex_t;\r\n\r\ntypedef struct { vertex_t v, v1, v2; } edge_t;\r\ntypedef struct { float top, bottom; edge_t left, right; } trapezoid_t;\r\ntypedef struct { vertex_t v, step; int x, y, w; } scanline_t;\r\n\r\n\r\nvoid vertex_rhw_init(vertex_t *v) {\r\n\tfloat rhw = 1.0f / v->pos.w;\r\n\tv->rhw = rhw;\r\n\tv->tc.u *= rhw;\r\n\tv->tc.v *= rhw;\r\n\tv->color.r *= rhw;\r\n\tv->color.g *= rhw;\r\n\tv->color.b *= rhw;\r\n}\r\n\r\nvoid vertex_interp(vertex_t *y, const vertex_t *x1, const vertex_t *x2, float t) {\r\n\tvector_interp(&y->pos, &x1->pos, &x2->pos, t);\r\n\ty->tc.u = interp(x1->tc.u, x2->tc.u, t);\r\n\ty->tc.v = interp(x1->tc.v, x2->tc.v, t);\r\n\ty->color.r = interp(x1->color.r, x2->color.r, t);\r\n\ty->color.g = interp(x1->color.g, x2->color.g, t);\r\n\ty->color.b = interp(x1->color.b, x2->color.b, t);\r\n\ty->rhw = interp(x1->rhw, x2->rhw, t);\r\n}\r\n\r\nvoid vertex_division(vertex_t *y, const vertex_t *x1, const vertex_t *x2, float w) {\r\n\tfloat inv = 1.0f / w;\r\n\ty->pos.x = (x2->pos.x - x1->pos.x) * inv;\r\n\ty->pos.y = (x2->pos.y - x1->pos.y) * inv;\r\n\ty->pos.z = (x2->pos.z - x1->pos.z) * inv;\r\n\ty->pos.w = (x2->pos.w - x1->pos.w) * inv;\r\n\ty->tc.u = (x2->tc.u - x1->tc.u) * inv;\r\n\ty->tc.v = (x2->tc.v - x1->tc.v) * inv;\r\n\ty->color.r = (x2->color.r - x1->color.r) * inv;\r\n\ty->color.g = (x2->color.g - x1->color.g) * inv;\r\n\ty->color.b = (x2->color.b - x1->color.b) * inv;\r\n\ty->rhw = (x2->rhw - x1->rhw) * inv;\r\n}\r\n\r\nvoid vertex_add(vertex_t *y, const vertex_t *x) {\r\n\ty->pos.x += x->pos.x;\r\n\ty->pos.y += x->pos.y;\r\n\ty->pos.z += x->pos.z;\r\n\ty->pos.w += x->pos.w;\r\n\ty->rhw += x->rhw;\r\n\ty->tc.u += x->tc.u;\r\n\ty->tc.v += x->tc.v;\r\n\ty->color.r += x->color.r;\r\n\ty->color.g += x->color.g;\r\n\ty->color.b += x->color.b;\r\n}\r\n\r\n// 根据三角形生成 0-2 个梯形，并且返回合法梯形的数量\r\nint trapezoid_init_triangle(trapezoid_t *trap, const vertex_t *p1, \r\n\tconst vertex_t *p2, const vertex_t *p3) {\r\n\tconst vertex_t *p;\r\n\tfloat k, x;\r\n\r\n\tif (p1->pos.y > p2->pos.y) p = p1, p1 = p2, p2 = p;\r\n\tif (p1->pos.y > p3->pos.y) p = p1, p1 = p3, p3 = p;\r\n\tif (p2->pos.y > p3->pos.y) p = p2, p2 = p3, p3 = p;\r\n\tif (p1->pos.y == p2->pos.y && p1->pos.y == p3->pos.y) return 0;\r\n\tif (p1->pos.x == p2->pos.x && p1->pos.x == p3->pos.x) return 0;\r\n\r\n\tif (p1->pos.y == p2->pos.y) {\t// triangle down\r\n\t\tif (p1->pos.x > p2->pos.x) p = p1, p1 = p2, p2 = p;\r\n\t\ttrap[0].top = p1->pos.y;\r\n\t\ttrap[0].bottom = p3->pos.y;\r\n\t\ttrap[0].left.v1 = *p1;\r\n\t\ttrap[0].left.v2 = *p3;\r\n\t\ttrap[0].right.v1 = *p2;\r\n\t\ttrap[0].right.v2 = *p3;\r\n\t\treturn (trap[0].top < trap[0].bottom)? 1 : 0;\r\n\t}\r\n\r\n\tif (p2->pos.y == p3->pos.y) {\t// triangle up\r\n\t\tif (p2->pos.x > p3->pos.x) p = p2, p2 = p3, p3 = p;\r\n\t\ttrap[0].top = p1->pos.y;\r\n\t\ttrap[0].bottom = p3->pos.y;\r\n\t\ttrap[0].left.v1 = *p1;\r\n\t\ttrap[0].left.v2 = *p2;\r\n\t\ttrap[0].right.v1 = *p1;\r\n\t\ttrap[0].right.v2 = *p3;\r\n\t\treturn (trap[0].top < trap[0].bottom)? 1 : 0;\r\n\t}\r\n\r\n\ttrap[0].top = p1->pos.y;\r\n\ttrap[0].bottom = p2->pos.y;\r\n\ttrap[1].top = p2->pos.y;\r\n\ttrap[1].bottom = p3->pos.y;\r\n\r\n\tk = (p3->pos.y - p1->pos.y) / (p2->pos.y - p1->pos.y);\r\n\tx = p1->pos.x + (p2->pos.x - p1->pos.x) * k;\r\n\r\n\tif (x <= p3->pos.x) {\t\t// triangle left\r\n\t\ttrap[0].left.v1 = *p1;\r\n\t\ttrap[0].left.v2 = *p2;\r\n\t\ttrap[0].right.v1 = *p1;\r\n\t\ttrap[0].right.v2 = *p3;\r\n\t\ttrap[1].left.v1 = *p2;\r\n\t\ttrap[1].left.v2 = *p3;\r\n\t\ttrap[1].right.v1 = *p1;\r\n\t\ttrap[1].right.v2 = *p3;\r\n\t}\telse {\t\t\t\t\t// triangle right\r\n\t\ttrap[0].left.v1 = *p1;\r\n\t\ttrap[0].left.v2 = *p3;\r\n\t\ttrap[0].right.v1 = *p1;\r\n\t\ttrap[0].right.v2 = *p2;\r\n\t\ttrap[1].left.v1 = *p1;\r\n\t\ttrap[1].left.v2 = *p3;\r\n\t\ttrap[1].right.v1 = *p2;\r\n\t\ttrap[1].right.v2 = *p3;\r\n\t}\r\n\r\n\treturn 2;\r\n}\r\n\r\n// 按照 Y 坐标计算出左右两条边纵坐标等于 Y 的顶点\r\nvoid trapezoid_edge_interp(trapezoid_t *trap, float y) {\r\n\tfloat s1 = trap->left.v2.pos.y - trap->left.v1.pos.y;\r\n\tfloat s2 = trap->right.v2.pos.y - trap->right.v1.pos.y;\r\n\tfloat t1 = (y - trap->left.v1.pos.y) / s1;\r\n\tfloat t2 = (y - trap->right.v1.pos.y) / s2;\r\n\tvertex_interp(&trap->left.v, &trap->left.v1, &trap->left.v2, t1);\r\n\tvertex_interp(&trap->right.v, &trap->right.v1, &trap->right.v2, t2);\r\n}\r\n\r\n// 根据左右两边的端点，初始化计算出扫描线的起点和步长\r\nvoid trapezoid_init_scan_line(const trapezoid_t *trap, scanline_t *scanline, int y) {\r\n\tfloat width = trap->right.v.pos.x - trap->left.v.pos.x;\r\n\tscanline->x = (int)(trap->left.v.pos.x + 0.5f);\r\n\tscanline->w = (int)(trap->right.v.pos.x + 0.5f) - scanline->x;\r\n\tscanline->y = y;\r\n\tscanline->v = trap->left.v;\r\n\tif (trap->left.v.pos.x >= trap->right.v.pos.x) scanline->w = 0;\r\n\tvertex_division(&scanline->step, &trap->left.v, &trap->right.v, width);\r\n}\r\n\r\n\r\n//=====================================================================\r\n// 渲染设备\r\n//=====================================================================\r\ntypedef struct {\r\n\ttransform_t transform;      // 坐标变换器\r\n\tint width;                  // 窗口宽度\r\n\tint height;                 // 窗口高度\r\n\tIUINT32 **framebuffer;      // 像素缓存：framebuffer[y] 代表第 y行\r\n\tfloat **zbuffer;            // 深度缓存：zbuffer[y] 为第 y行指针\r\n\tIUINT32 **texture;          // 纹理：同样是每行索引\r\n\tint tex_width;              // 纹理宽度\r\n\tint tex_height;             // 纹理高度\r\n\tfloat max_u;                // 纹理最大宽度：tex_width - 1\r\n\tfloat max_v;                // 纹理最大高度：tex_height - 1\r\n\tint render_state;           // 渲染状态\r\n\tIUINT32 background;         // 背景颜色\r\n\tIUINT32 foreground;         // 线框颜色\r\n}\tdevice_t;\r\n\r\n#define RENDER_STATE_WIREFRAME      1\t\t// 渲染线框\r\n#define RENDER_STATE_TEXTURE        2\t\t// 渲染纹理\r\n#define RENDER_STATE_COLOR          4\t\t// 渲染颜色\r\n\r\n// 设备初始化，fb为外部帧缓存，非 NULL 将引用外部帧缓存（每行 4字节对齐）\r\nvoid device_init(device_t *device, int width, int height, void *fb) {\r\n\tint need = sizeof(void*) * (height * 2 + 1024) + width * height * 8;\r\n\tchar *ptr = (char*)malloc(need + 64);\r\n\tchar *framebuf, *zbuf;\r\n\tint j;\r\n\tassert(ptr);\r\n\tdevice->framebuffer = (IUINT32**)ptr;\r\n\tdevice->zbuffer = (float**)(ptr + sizeof(void*) * height);\r\n\tptr += sizeof(void*) * height * 2;\r\n\tdevice->texture = (IUINT32**)ptr;\r\n\tptr += sizeof(void*) * 1024;\r\n\tframebuf = (char*)ptr;\r\n\tzbuf = (char*)ptr + width * height * 4;\r\n\tptr += width * height * 8;\r\n\tif (fb != NULL) framebuf = (char*)fb;\r\n\tfor (j = 0; j < height; j++) {\r\n\t\tdevice->framebuffer[j] = (IUINT32*)(framebuf + width * 4 * j);\r\n\t\tdevice->zbuffer[j] = (float*)(zbuf + width * 4 * j);\r\n\t}\r\n\tdevice->texture[0] = (IUINT32*)ptr;\r\n\tdevice->texture[1] = (IUINT32*)(ptr + 16);\r\n\tmemset(device->texture[0], 0, 64);\r\n\tdevice->tex_width = 2;\r\n\tdevice->tex_height = 2;\r\n\tdevice->max_u = 1.0f;\r\n\tdevice->max_v = 1.0f;\r\n\tdevice->width = width;\r\n\tdevice->height = height;\r\n\tdevice->background = 0xc0c0c0;\r\n\tdevice->foreground = 0;\r\n\ttransform_init(&device->transform, width, height);\r\n\tdevice->render_state = RENDER_STATE_WIREFRAME;\r\n}\r\n\r\n// 删除设备\r\nvoid device_destroy(device_t *device) {\r\n\tif (device->framebuffer) \r\n\t\tfree(device->framebuffer);\r\n\tdevice->framebuffer = NULL;\r\n\tdevice->zbuffer = NULL;\r\n\tdevice->texture = NULL;\r\n}\r\n\r\n// 设置当前纹理\r\nvoid device_set_texture(device_t *device, void *bits, long pitch, int w, int h) {\r\n\tchar *ptr = (char*)bits;\r\n\tint j;\r\n\tassert(w <= 1024 && h <= 1024);\r\n\tfor (j = 0; j < h; ptr += pitch, j++) \t// 重新计算每行纹理的指针\r\n\t\tdevice->texture[j] = (IUINT32*)ptr;\r\n\tdevice->tex_width = w;\r\n\tdevice->tex_height = h;\r\n\tdevice->max_u = (float)(w - 1);\r\n\tdevice->max_v = (float)(h - 1);\r\n}\r\n\r\n// 清空 framebuffer 和 zbuffer\r\nvoid device_clear(device_t *device, int mode) {\r\n\tint y, x, height = device->height;\r\n\tfor (y = 0; y < device->height; y++) {\r\n\t\tIUINT32 *dst = device->framebuffer[y];\r\n\t\tIUINT32 cc = (height - 1 - y) * 230 / (height - 1);\r\n\t\tcc = (cc << 16) | (cc << 8) | cc;\r\n\t\tif (mode == 0) cc = device->background;\r\n\t\tfor (x = device->width; x > 0; dst++, x--) dst[0] = cc;\r\n\t}\r\n\tfor (y = 0; y < device->height; y++) {\r\n\t\tfloat *dst = device->zbuffer[y];\r\n\t\tfor (x = device->width; x > 0; dst++, x--) dst[0] = 0.0f;\r\n\t}\r\n}\r\n\r\n// 画点\r\nvoid device_pixel(device_t *device, int x, int y, IUINT32 color) {\r\n\tif (((IUINT32)x) < (IUINT32)device->width && ((IUINT32)y) < (IUINT32)device->height) {\r\n\t\tdevice->framebuffer[y][x] = color;\r\n\t}\r\n}\r\n\r\n// 绘制线段\r\nvoid device_draw_line(device_t *device, int x1, int y1, int x2, int y2, IUINT32 c) {\r\n\tint x, y, rem = 0;\r\n\tif (x1 == x2 && y1 == y2) {\r\n\t\tdevice_pixel(device, x1, y1, c);\r\n\t}\telse if (x1 == x2) {\r\n\t\tint inc = (y1 <= y2)? 1 : -1;\r\n\t\tfor (y = y1; y != y2; y += inc) device_pixel(device, x1, y, c);\r\n\t\tdevice_pixel(device, x2, y2, c);\r\n\t}\telse if (y1 == y2) {\r\n\t\tint inc = (x1 <= x2)? 1 : -1;\r\n\t\tfor (x = x1; x != x2; x += inc) device_pixel(device, x, y1, c);\r\n\t\tdevice_pixel(device, x2, y2, c);\r\n\t}\telse {\r\n\t\tint dx = (x1 < x2)? x2 - x1 : x1 - x2;\r\n\t\tint dy = (y1 < y2)? y2 - y1 : y1 - y2;\r\n\t\tif (dx >= dy) {\r\n\t\t\tif (x2 < x1) x = x1, y = y1, x1 = x2, y1 = y2, x2 = x, y2 = y;\r\n\t\t\tfor (x = x1, y = y1; x <= x2; x++) {\r\n\t\t\t\tdevice_pixel(device, x, y, c);\r\n\t\t\t\trem += dy;\r\n\t\t\t\tif (rem >= dx) {\r\n\t\t\t\t\trem -= dx;\r\n\t\t\t\t\ty += (y2 >= y1)? 1 : -1;\r\n\t\t\t\t\tdevice_pixel(device, x, y, c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdevice_pixel(device, x2, y2, c);\r\n\t\t}\telse {\r\n\t\t\tif (y2 < y1) x = x1, y = y1, x1 = x2, y1 = y2, x2 = x, y2 = y;\r\n\t\t\tfor (x = x1, y = y1; y <= y2; y++) {\r\n\t\t\t\tdevice_pixel(device, x, y, c);\r\n\t\t\t\trem += dx;\r\n\t\t\t\tif (rem >= dy) {\r\n\t\t\t\t\trem -= dy;\r\n\t\t\t\t\tx += (x2 >= x1)? 1 : -1;\r\n\t\t\t\t\tdevice_pixel(device, x, y, c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdevice_pixel(device, x2, y2, c);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// 根据坐标读取纹理\r\nIUINT32 device_texture_read(const device_t *device, float u, float v) {\r\n\tint x, y;\r\n\tu = u * device->max_u;\r\n\tv = v * device->max_v;\r\n\tx = (int)(u + 0.5f);\r\n\ty = (int)(v + 0.5f);\r\n\tx = CMID(x, 0, device->tex_width - 1);\r\n\ty = CMID(y, 0, device->tex_height - 1);\r\n\treturn device->texture[y][x];\r\n}\r\n\r\n\r\n//=====================================================================\r\n// 渲染实现\r\n//=====================================================================\r\n\r\n// 绘制扫描线\r\nvoid device_draw_scanline(device_t *device, scanline_t *scanline) {\r\n\tIUINT32 *framebuffer = device->framebuffer[scanline->y];\r\n\tfloat *zbuffer = device->zbuffer[scanline->y];\r\n\tint x = scanline->x;\r\n\tint w = scanline->w;\r\n\tint width = device->width;\r\n\tint render_state = device->render_state;\r\n\tfor (; w > 0; x++, w--) {\r\n\t\tif (x >= 0 && x < width) {\r\n\t\t\tfloat rhw = scanline->v.rhw;\r\n\t\t\tif (rhw >= zbuffer[x]) {\t\r\n\t\t\t\tfloat w = 1.0f / rhw;\r\n\t\t\t\tzbuffer[x] = rhw;\r\n\t\t\t\tif (render_state & RENDER_STATE_COLOR) {\r\n\t\t\t\t\tfloat r = scanline->v.color.r * w;\r\n\t\t\t\t\tfloat g = scanline->v.color.g * w;\r\n\t\t\t\t\tfloat b = scanline->v.color.b * w;\r\n\t\t\t\t\tint R = (int)(r * 255.0f);\r\n\t\t\t\t\tint G = (int)(g * 255.0f);\r\n\t\t\t\t\tint B = (int)(b * 255.0f);\r\n\t\t\t\t\tR = CMID(R, 0, 255);\r\n\t\t\t\t\tG = CMID(G, 0, 255);\r\n\t\t\t\t\tB = CMID(B, 0, 255);\r\n\t\t\t\t\tframebuffer[x] = (R << 16) | (G << 8) | (B);\r\n\t\t\t\t}\r\n\t\t\t\tif (render_state & RENDER_STATE_TEXTURE) {\r\n\t\t\t\t\tfloat u = scanline->v.tc.u * w;\r\n\t\t\t\t\tfloat v = scanline->v.tc.v * w;\r\n\t\t\t\t\tIUINT32 cc = device_texture_read(device, u, v);\r\n\t\t\t\t\tframebuffer[x] = cc;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvertex_add(&scanline->v, &scanline->step);\r\n\t\tif (x >= width) break;\r\n\t}\r\n}\r\n\r\n// 主渲染函数\r\nvoid device_render_trap(device_t *device, trapezoid_t *trap) {\r\n\tscanline_t scanline;\r\n\tint j, top, bottom;\r\n\ttop = (int)(trap->top + 0.5f);\r\n\tbottom = (int)(trap->bottom + 0.5f);\r\n\tfor (j = top; j < bottom; j++) {\r\n\t\tif (j >= 0 && j < device->height) {\r\n\t\t\ttrapezoid_edge_interp(trap, (float)j + 0.5f);\r\n\t\t\ttrapezoid_init_scan_line(trap, &scanline, j);\r\n\t\t\tdevice_draw_scanline(device, &scanline);\r\n\t\t}\r\n\t\tif (j >= device->height) break;\r\n\t}\r\n}\r\n\r\n// 根据 render_state 绘制原始三角形\r\nvoid device_draw_primitive(device_t *device, const vertex_t *v1, \r\n\tconst vertex_t *v2, const vertex_t *v3) {\r\n\tpoint_t p1, p2, p3, c1, c2, c3;\r\n\tint render_state = device->render_state;\r\n\r\n\t// 按照 Transform 变化\r\n\ttransform_apply(&device->transform, &c1, &v1->pos);\r\n\ttransform_apply(&device->transform, &c2, &v2->pos);\r\n\ttransform_apply(&device->transform, &c3, &v3->pos);\r\n\r\n\t// 裁剪，注意此处可以完善为具体判断几个点在 cvv内以及同cvv相交平面的坐标比例\r\n\t// 进行进一步精细裁剪，将一个分解为几个完全处在 cvv内的三角形\r\n\tif (transform_check_cvv(&c1) != 0) return;\r\n\tif (transform_check_cvv(&c2) != 0) return;\r\n\tif (transform_check_cvv(&c3) != 0) return;\r\n\r\n\t// 归一化\r\n\ttransform_homogenize(&device->transform, &p1, &c1);\r\n\ttransform_homogenize(&device->transform, &p2, &c2);\r\n\ttransform_homogenize(&device->transform, &p3, &c3);\r\n\r\n\t// 纹理或者色彩绘制\r\n\tif (render_state & (RENDER_STATE_TEXTURE | RENDER_STATE_COLOR)) {\r\n\t\tvertex_t t1 = *v1, t2 = *v2, t3 = *v3;\r\n\t\ttrapezoid_t traps[2];\r\n\t\tint n;\r\n\r\n\t\tt1.pos = p1; \r\n\t\tt2.pos = p2;\r\n\t\tt3.pos = p3;\r\n\t\tt1.pos.w = c1.w;\r\n\t\tt2.pos.w = c2.w;\r\n\t\tt3.pos.w = c3.w;\r\n\t\t\r\n\t\tvertex_rhw_init(&t1);\t// 初始化 w\r\n\t\tvertex_rhw_init(&t2);\t// 初始化 w\r\n\t\tvertex_rhw_init(&t3);\t// 初始化 w\r\n\t\t\r\n\t\t// 拆分三角形为0-2个梯形，并且返回可用梯形数量\r\n\t\tn = trapezoid_init_triangle(traps, &t1, &t2, &t3);\r\n\r\n\t\tif (n >= 1) device_render_trap(device, &traps[0]);\r\n\t\tif (n >= 2) device_render_trap(device, &traps[1]);\r\n\t}\r\n\r\n\tif (render_state & RENDER_STATE_WIREFRAME) {\t\t// 线框绘制\r\n\t\tdevice_draw_line(device, (int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y, device->foreground);\r\n\t\tdevice_draw_line(device, (int)p1.x, (int)p1.y, (int)p3.x, (int)p3.y, device->foreground);\r\n\t\tdevice_draw_line(device, (int)p3.x, (int)p3.y, (int)p2.x, (int)p2.y, device->foreground);\r\n\t}\r\n}\r\n\r\n\r\n//=====================================================================\r\n// Win32 窗口及图形绘制：为 device 提供一个 DibSection 的 FB\r\n//=====================================================================\r\nint screen_w, screen_h, screen_exit = 0;\r\nint screen_mx = 0, screen_my = 0, screen_mb = 0;\r\nint screen_keys[512];\t// 当前键盘按下状态\r\nstatic HWND screen_handle = NULL;\t\t// 主窗口 HWND\r\nstatic HDC screen_dc = NULL;\t\t\t// 配套的 HDC\r\nstatic HBITMAP screen_hb = NULL;\t\t// DIB\r\nstatic HBITMAP screen_ob = NULL;\t\t// 老的 BITMAP\r\nunsigned char *screen_fb = NULL;\t\t// frame buffer\r\nlong screen_pitch = 0;\r\n\r\nint screen_init(int w, int h, const TCHAR *title);\t// 屏幕初始化\r\nint screen_close(void);\t\t\t\t\t\t\t\t// 关闭屏幕\r\nvoid screen_dispatch(void);\t\t\t\t\t\t\t// 处理消息\r\nvoid screen_update(void);\t\t\t\t\t\t\t// 显示 FrameBuffer\r\n\r\n// win32 event handler\r\nstatic LRESULT screen_events(HWND, UINT, WPARAM, LPARAM);\t\r\n\r\n#ifdef _MSC_VER\r\n#pragma comment(lib, \"gdi32.lib\")\r\n#pragma comment(lib, \"user32.lib\")\r\n#endif\r\n\r\n// 初始化窗口并设置标题\r\nint screen_init(int w, int h, const TCHAR *title) {\r\n\tWNDCLASS wc = { CS_BYTEALIGNCLIENT, (WNDPROC)screen_events, 0, 0, 0, \r\n\t\tNULL, NULL, NULL, NULL, _T(\"SCREEN3.1415926\") };\r\n\tBITMAPINFO bi = { { sizeof(BITMAPINFOHEADER), w, -h, 1, 32, BI_RGB, \r\n\t\tw * h * 4, 0, 0, 0, 0 }  };\r\n\tRECT rect = { 0, 0, w, h };\r\n\tint wx, wy, sx, sy;\r\n\tLPVOID ptr;\r\n\tHDC hDC;\r\n\r\n\tscreen_close();\r\n\r\n\twc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);\r\n\twc.hInstance = GetModuleHandle(NULL);\r\n\twc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n\tif (!RegisterClass(&wc)) return -1;\r\n\r\n\tscreen_handle = CreateWindow(_T(\"SCREEN3.1415926\"), title,\r\n\t\tWS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,\r\n\t\t0, 0, 0, 0, NULL, NULL, wc.hInstance, NULL);\r\n\tif (screen_handle == NULL) return -2;\r\n\r\n\tscreen_exit = 0;\r\n\thDC = GetDC(screen_handle);\r\n\tscreen_dc = CreateCompatibleDC(hDC);\r\n\tReleaseDC(screen_handle, hDC);\r\n\r\n\tscreen_hb = CreateDIBSection(screen_dc, &bi, DIB_RGB_COLORS, &ptr, 0, 0);\r\n\tif (screen_hb == NULL) return -3;\r\n\r\n\tscreen_ob = (HBITMAP)SelectObject(screen_dc, screen_hb);\r\n\tscreen_fb = (unsigned char*)ptr;\r\n\tscreen_w = w;\r\n\tscreen_h = h;\r\n\tscreen_pitch = w * 4;\r\n\t\r\n\tAdjustWindowRect(&rect, GetWindowLong(screen_handle, GWL_STYLE), 0);\r\n\twx = rect.right - rect.left;\r\n\twy = rect.bottom - rect.top;\r\n\tsx = (GetSystemMetrics(SM_CXSCREEN) - wx) / 2;\r\n\tsy = (GetSystemMetrics(SM_CYSCREEN) - wy) / 2;\r\n\tif (sy < 0) sy = 0;\r\n\tSetWindowPos(screen_handle, NULL, sx, sy, wx, wy, (SWP_NOCOPYBITS | SWP_NOZORDER | SWP_SHOWWINDOW));\r\n\tSetForegroundWindow(screen_handle);\r\n\r\n\tShowWindow(screen_handle, SW_NORMAL);\r\n\tscreen_dispatch();\r\n\r\n\tmemset(screen_keys, 0, sizeof(int) * 512);\r\n\tmemset(screen_fb, 0, w * h * 4);\r\n\r\n\treturn 0;\r\n}\r\n\r\nint screen_close(void) {\r\n\tif (screen_dc) {\r\n\t\tif (screen_ob) { \r\n\t\t\tSelectObject(screen_dc, screen_ob); \r\n\t\t\tscreen_ob = NULL; \r\n\t\t}\r\n\t\tDeleteDC(screen_dc);\r\n\t\tscreen_dc = NULL;\r\n\t}\r\n\tif (screen_hb) { \r\n\t\tDeleteObject(screen_hb); \r\n\t\tscreen_hb = NULL; \r\n\t}\r\n\tif (screen_handle) { \r\n\t\tCloseWindow(screen_handle); \r\n\t\tscreen_handle = NULL; \r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nstatic LRESULT screen_events(HWND hWnd, UINT msg, \r\n\tWPARAM wParam, LPARAM lParam) {\r\n\tswitch (msg) {\r\n\tcase WM_CLOSE: screen_exit = 1; break;\r\n\tcase WM_KEYDOWN: screen_keys[wParam & 511] = 1; break;\r\n\tcase WM_KEYUP: screen_keys[wParam & 511] = 0; break;\r\n\tdefault: return DefWindowProc(hWnd, msg, wParam, lParam);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nvoid screen_dispatch(void) {\r\n\tMSG msg;\r\n\twhile (1) {\r\n\t\tif (!PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)) break;\r\n\t\tif (!GetMessage(&msg, NULL, 0, 0)) break;\r\n\t\tDispatchMessage(&msg);\r\n\t}\r\n}\r\n\r\nvoid screen_update(void) {\r\n\tHDC hDC = GetDC(screen_handle);\r\n\tBitBlt(hDC, 0, 0, screen_w, screen_h, screen_dc, 0, 0, SRCCOPY);\r\n\tReleaseDC(screen_handle, hDC);\r\n\tscreen_dispatch();\r\n}\r\n\r\n\r\n//=====================================================================\r\n// 主程序\r\n//=====================================================================\r\nvertex_t mesh[8] = {\r\n\t{ { -1, -1,  1, 1 }, { 0, 0 }, { 1.0f, 0.2f, 0.2f }, 1 },\r\n\t{ {  1, -1,  1, 1 }, { 0, 1 }, { 0.2f, 1.0f, 0.2f }, 1 },\r\n\t{ {  1,  1,  1, 1 }, { 1, 1 }, { 0.2f, 0.2f, 1.0f }, 1 },\r\n\t{ { -1,  1,  1, 1 }, { 1, 0 }, { 1.0f, 0.2f, 1.0f }, 1 },\r\n\t{ { -1, -1, -1, 1 }, { 0, 0 }, { 1.0f, 1.0f, 0.2f }, 1 },\r\n\t{ {  1, -1, -1, 1 }, { 0, 1 }, { 0.2f, 1.0f, 1.0f }, 1 },\r\n\t{ {  1,  1, -1, 1 }, { 1, 1 }, { 1.0f, 0.3f, 0.3f }, 1 },\r\n\t{ { -1,  1, -1, 1 }, { 1, 0 }, { 0.2f, 1.0f, 0.3f }, 1 },\r\n};\r\n\r\nvoid draw_plane(device_t *device, int a, int b, int c, int d) {\r\n\tvertex_t p1 = mesh[a], p2 = mesh[b], p3 = mesh[c], p4 = mesh[d];\r\n\tp1.tc.u = 0, p1.tc.v = 0, p2.tc.u = 0, p2.tc.v = 1;\r\n\tp3.tc.u = 1, p3.tc.v = 1, p4.tc.u = 1, p4.tc.v = 0;\r\n\tdevice_draw_primitive(device, &p1, &p2, &p3);\r\n\tdevice_draw_primitive(device, &p3, &p4, &p1);\r\n}\r\n\r\nvoid draw_box(device_t *device, float theta) {\r\n\tmatrix_t m;\r\n\tmatrix_set_rotate(&m, -1, -0.5, 1, theta);\r\n\tdevice->transform.world = m;\r\n\ttransform_update(&device->transform);\r\n\tdraw_plane(device, 0, 1, 2, 3);\r\n\tdraw_plane(device, 7, 6, 5, 4);\r\n\tdraw_plane(device, 0, 4, 5, 1);\r\n\tdraw_plane(device, 1, 5, 6, 2);\r\n\tdraw_plane(device, 2, 6, 7, 3);\r\n\tdraw_plane(device, 3, 7, 4, 0);\r\n}\r\n\r\nvoid camera_at_zero(device_t *device, float x, float y, float z) {\r\n\tpoint_t eye = { x, y, z, 1 }, at = { 0, 0, 0, 1 }, up = { 0, 0, 1, 1 };\r\n\tmatrix_set_lookat(&device->transform.view, &eye, &at, &up);\r\n\ttransform_update(&device->transform);\r\n}\r\n\r\nvoid init_texture(device_t *device) {\r\n\tstatic IUINT32 texture[256][256];\r\n\tint i, j;\r\n\tfor (j = 0; j < 256; j++) {\r\n\t\tfor (i = 0; i < 256; i++) {\r\n\t\t\tint x = i / 32, y = j / 32;\r\n\t\t\ttexture[j][i] = ((x + y) & 1)? 0xffffff : 0x3fbcef;\r\n\t\t}\r\n\t}\r\n\tdevice_set_texture(device, texture, 256 * 4, 256, 256);\r\n}\r\n\r\nint main(void)\r\n{\r\n\tdevice_t device;\r\n\tint states[] = { RENDER_STATE_TEXTURE, RENDER_STATE_COLOR, RENDER_STATE_WIREFRAME };\r\n\tint indicator = 0;\r\n\tint kbhit = 0;\r\n\tfloat alpha = 1;\r\n\tfloat pos = 3.5;\r\n\r\n\tTCHAR *title = _T(\"Mini3d (software render tutorial) - \")\r\n\t\t_T(\"Left/Right: rotation, Up/Down: forward/backward, Space: switch state\");\r\n\r\n\tif (screen_init(800, 600, title)) \r\n\t\treturn -1;\r\n\r\n\tdevice_init(&device, 800, 600, screen_fb);\r\n\tcamera_at_zero(&device, 3, 0, 0);\r\n\r\n\tinit_texture(&device);\r\n\tdevice.render_state = RENDER_STATE_TEXTURE;\r\n\r\n\twhile (screen_exit == 0 && screen_keys[VK_ESCAPE] == 0) {\r\n\t\tscreen_dispatch();\r\n\t\tdevice_clear(&device, 1);\r\n\t\tcamera_at_zero(&device, pos, 0, 0);\r\n\t\t\r\n\t\tif (screen_keys[VK_UP]) pos -= 0.01f;\r\n\t\tif (screen_keys[VK_DOWN]) pos += 0.01f;\r\n\t\tif (screen_keys[VK_LEFT]) alpha += 0.01f;\r\n\t\tif (screen_keys[VK_RIGHT]) alpha -= 0.01f;\r\n\r\n\t\tif (screen_keys[VK_SPACE]) {\r\n\t\t\tif (kbhit == 0) {\r\n\t\t\t\tkbhit = 1;\r\n\t\t\t\tif (++indicator >= 3) indicator = 0;\r\n\t\t\t\tdevice.render_state = states[indicator];\r\n\t\t\t}\r\n\t\t}\telse {\r\n\t\t\tkbhit = 0;\r\n\t\t}\r\n\r\n\t\tdraw_box(&device, alpha);\r\n\t\tscreen_update();\r\n\t\tSleep(1);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n"
        }
      ]
    }
  ]
}