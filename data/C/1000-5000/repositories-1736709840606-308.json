{
  "metadata": {
    "timestamp": 1736709840606,
    "page": 308,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sustrik/libmill",
      "stars": 2964,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.818359375,
          "content": "*.o\n*.la\n*.lo\n*.tar.gz\n.deps\n.libs\nMakefile\nMakefile.in\naclocal.m4\nautom4te.cache/\ncompile\nconfig.guess\nconfig.h\nconfig.log\nconfig.status\nconfig.sub\nconfigure\ndepcomp\ndoltcompile\ndoltlibtool\ninstall-sh\nlibmill.pc\nlibtool\nltmain.sh\nmissing\ntest-suite.log\ntest-driver\ntests/.dirstamp\ntests/example\ntests/go\ntests/cls\ntests/chan\ntests/choose\ntests/sleep\ntests/fdwait\ntests/tcp\ntests/udp\ntests/unix\ntests/signals\ntests/overload\ntests/ip\ntests/*.trs\ntests/*.log\ntests/file\ntests/mfork1\ntests/mfork2\ntests/mfork3\ntests/ssl\nperf/.dirstamp\nperf/go\nperf/ctxswitch\nperf/chan\nperf/chs\nperf/chr\nperf/whispers\nperf/c10k\ntutorial/.dirstamp\ntutorial/step1\ntutorial/step2\ntutorial/step3\ntutorial/step4\ntutorial/step5\ntutorial/step6\ntutorial/step7\ntutorial/step8\nm4/libtool.m4\nm4/ltoptions.m4\nm4/ltsugar.m4\nm4/ltversion.m4\nm4/lt~obsolete.m4\ndns/.dirstamp\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.306640625,
          "content": "language: c\n\nsudo: false\n\nos:\n  - osx\n  - linux\n\ncompiler:\n  - gcc\n  - clang\n\nenv:\n  matrix:\n   - CONF=\"autotools-shared\"\n   - CONF=\"autotools-static\"\n   - CONF=\"autotools-shared-poll\"\n   - CONF=\"cmake-shared\"\n\naddons:\n  apt:\n    sources:\n      - ubuntu-toolchain-r-test\n    packages:\n      - gcc-4.8\n      - clang\n\nbranches:\n  only:\n    - master\n\nbefore_install:\n  - 'if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then export CFLAGS=\"-I/usr/local/opt/openssl/include $CFLAGS\" LDFLAGS=\"-L/usr/local/opt/openssl/lib $LDFLAGS\"; fi'\n\ninstall:\n  - if [[ $CONF == \"autotools-shared\" ]]; then ./autogen.sh && ./configure --enable-ssl  && make; fi\n  - if [[ $CONF == \"autotools-static\" ]]; then ./autogen.sh && ./configure --enable-ssl --disable-shared && make; fi\n  - if [[ $CONF == \"autotools-shared-poll\" ]]; then ./autogen.sh && ./configure --enable-ssl CFLAGS=\"-DMILL_POLL $CFLAGS\" && make; fi\n  - if [[ $CONF == \"cmake-shared\"  ]]; then cmake . && make; fi\n\nscript:\n  - if [[ $CONF == \"autotools-shared\" ]]; then make check; fi\n  - if [[ $CONF == \"autotools-static\" ]]; then make check; fi\n  - if [[ $CONF == \"autotools-shared-poll\" ]]; then make check; fi\n  - if [[ $CONF == \"cmake-shared\"  ]]; then make test; fi\n\nafter_failure:\n  - for f in tests/*.log; do echo; echo \"${f}:\"; cat $f; done;\n  - cat test-suite.log\n\nnotifications:\n  email: false\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 1.0146484375,
          "content": "Full list of copyright holders:\n\nAlex Cornejo <acornejo@gmail.com>\nAmit Saha <amitsaha.in@gmail.com>\nAnton Mescheryakov <anton@mescher.pro> *\nBent Cardan <bent@nothingsatisfies.com> *\nChris Grieger <chris@scolp.de>\nChris Miller <chris@cmiller.me>\nConstantine Tarasenkov <constantine@protonmail.com> *\nDanny Thomas <d.thomas@its.uq.edu.au>\nJean-Francois Smigielski <jf.smigielski@gmail.com>\nJim Jagielski <jimjag@gmail.com> *\nJim Schimpf <jim.schimpf@gmail.com>\nJohn E. Haque <j.e.haque@gmail.com> *\nLuca Barbato <luca.barbato@gmail.com>\nMartin Lucina <martin@lucina.net>\nMartin Sustrik <sustrik@250bpm.com>\nMichael Gehring <mg@ebfe.org> *\nNick Desaulniers <nick@mozilla.com>\nNir Soffer <nsoffer@redhat.com> *\nPaul Banks <banks@banksdesigns.co.uk>\nPaulo Faria <paulo@zewo.io>\nTai Chi Minh Ralph Eastwood <tcmreastwood@gmail.com>\nYue Xu <red_angelx@qq.com>\n\n* Future patches by this author are submitted under MIT/X11 license\n\nCoprights for DNS resolution library in dns subdirectory are held by:\n\nWilliam Ahern <william@25thandClement.com>\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 4.1103515625,
          "content": "cmake_minimum_required(VERSION 3.1)\nproject(libmill VERSION 1.18 LANGUAGES C)\n\ninclude(CheckSymbolExists)\ninclude(CheckFunctionExists)\n\nif(CMAKE_C_COMPILER_ID EQUAL \"Clang\" OR CMAKE_C_COMPILER_ID EQUAL \"GNU\")\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wall -Wextra\")\nendif()\n\n# static and shared libs\nfile(GLOB sources *.c dns/*.c)\nset_source_files_properties(dns/dns.c PROPERTIES COMPILE_FLAGS -std=c99)\nadd_library(mill STATIC ${sources})\nadd_library(mill_s SHARED ${sources})\nset_target_properties(mill_s PROPERTIES OUTPUT_NAME mill)\n\n# check and enable rt if available\nlist(APPEND CMAKE_REQUIRED_LIBRARIES rt)\ncheck_symbol_exists(clock_gettime time.h HAVE_CLOCK_GETTIME)\nif(HAVE_CLOCK_GETTIME)\n  target_link_libraries(mill rt)\n  target_link_libraries(mill_s rt)\nendif()\n\n# Installation (https://github.com/forexample/package-example)\n\n# Layout. This works for all platforms:\n#   * <prefix>/lib/cmake/<PROJECT-NAME>\n#   * <prefix>/lib/\n#   * <prefix>/include/\nset(config_install_dir \"lib/cmake/${PROJECT_NAME}\")\nset(include_install_dir \"include\")\n\nset(generated_dir \"${CMAKE_CURRENT_BINARY_DIR}/generated\")\n\n# Configuration\nset(version_config \"${generated_dir}/${PROJECT_NAME}ConfigVersion.cmake\")\nset(project_config \"${generated_dir}/${PROJECT_NAME}Config.cmake\")\nset(TARGETS_EXPORT_NAME \"${PROJECT_NAME}Targets\")\nset(namespace \"${PROJECT_NAME}::\")\n\n# Include module with fuction 'write_basic_package_version_file'\ninclude(CMakePackageConfigHelpers)\n\n# Configure '<PROJECT-NAME>ConfigVersion.cmake'\n# Use:\n#   * PROJECT_VERSION\nwrite_basic_package_version_file(\n    \"${version_config}\" COMPATIBILITY SameMajorVersion\n)\n\n# Configure '<PROJECT-NAME>Config.cmake'\n# Use variables:\n#   * TARGETS_EXPORT_NAME\n#   * PROJECT_NAME\nconfigure_package_config_file(\n    \"cmake/Config.cmake.in\"\n    \"${project_config}\"\n    INSTALL_DESTINATION \"${config_install_dir}\"\n)\n\n# Targets:\n#   * <prefix>/lib/libmill.a\n#   * header location after install: <prefix>/include/libmill.h\ninstall(\n    TARGETS mill mill_s\n    EXPORT \"${TARGETS_EXPORT_NAME}\"\n    LIBRARY DESTINATION \"lib\"\n    ARCHIVE DESTINATION \"lib\"\n    RUNTIME DESTINATION \"bin\"\n    INCLUDES DESTINATION \"${include_install_dir}\"\n)\n\n# Headers:\n#   * libmill.h -> <prefix>/include/libmill.h\ninstall(\n    FILES libmill.h\n    DESTINATION \"${include_install_dir}\"\n)\n\n# Config\n#   * <prefix>/lib/cmake/libmill/libmillConfig.cmake\n#   * <prefix>/lib/cmake/libmill/libmillConfigVersion.cmake\ninstall(\n    FILES \"${project_config}\" \"${version_config}\"\n    DESTINATION \"${config_install_dir}\"\n)\n\n# Config\n#   * <prefix>/lib/cmake/libmill/libmillTargets.cmake\ninstall(\n    EXPORT \"${TARGETS_EXPORT_NAME}\"\n    NAMESPACE \"${namespace}\"\n    DESTINATION \"${config_install_dir}\"\n)\n\nset(CMAKE_REQUIRED_LIBRARIES )\n\n# check and enable stack guard and dns if available\nlist(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)\n\nset(CMAKE_REQUIRED_LIBRARIES )\nset(CMAKE_REQUIRED_DEFINITIONS )\n\ncheck_function_exists(mprotect HAVE_MPROTECT)\nif(HAVE_MPROTECT)\n  add_definitions(-DHAVE_MPROTECT)\nendif()\n\ncheck_function_exists(posix_memalign HAVE_POSIX_MEMALIGN)\nif(HAVE_POSIX_MEMALIGN)\n  add_definitions(-DHAVE_POSIX_MEMALIGN)\nendif()\n\n# tests\ninclude(CTest)\nif(BUILD_TESTING)\n    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/tests)\n    file(GLOB test_files tests/*.c)\n    foreach(test_file IN LISTS test_files)\n      get_filename_component(test_name ${test_file} NAME_WE)\n      add_executable(test_${test_name} ${test_file})\n      set_target_properties(test_${test_name} PROPERTIES\n        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests\n        OUTPUT_NAME ${test_name})\n      target_link_libraries(test_${test_name} mill)\n      add_test(test_${test_name} tests/${test_name})\n    endforeach()\nendif()\n\n# perf\nif(BUILD_PERF)\n    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/perf)\n    file(GLOB perf_files perf/*.c)\n    foreach(perf_file IN LISTS perf_files)\n      get_filename_component(perf_name ${perf_file} NAME_WE)\n      add_executable(perf_${perf_name} ${perf_file})\n      set_target_properties(perf_${perf_name} PROPERTIES\n        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/perf\n        OUTPUT_NAME ${perf_name})\n      target_link_libraries(perf_${perf_name} mill)\n    endforeach()\nendif()\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0009765625,
          "content": "\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom\nthe Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 4.775390625,
          "content": "#\n# Copyright (c) 2015 Martin Sustrik  All rights reserved.\n# Copyright (c) 2013 Luca Barbato\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nACLOCAL_AMFLAGS = -I m4\n\n################################################################################\n#  mill library                                                                #\n################################################################################\n\nmillincludedir = $(includedir)\nmillinclude_HEADERS = libmill.h\n\nlib_LTLIBRARIES = libmill.la\n\nlibmill_la_SOURCES = \\\n    chan.h \\\n    chan.c \\\n    cr.h \\\n    cr.c \\\n    debug.h \\\n    debug.c \\\n    ip.h \\\n    ip.c \\\n    list.h \\\n    list.c \\\n    mfork.c \\\n    poller.h \\\n    poller.c \\\n    slist.h \\\n    slist.c \\\n    stack.h \\\n    stack.c \\\n    tcp.c \\\n    timer.h \\\n    timer.c \\\n    udp.c \\\n    unix.c \\\n    utils.h \\\n    poll.inc \\\n    epoll.inc \\\n    kqueue.inc \\\n    dns/dns.h \\\n    dns/dns.c \\\n    file.c \\\n    ssl.c\n\npkgconfigdir = $(libdir)/pkgconfig\npkgconfig_DATA = libmill.pc\n\nlibmill_la_LDFLAGS = -no-undefined -version-info @MILL_LIBTOOL_VERSION@\n\n# Turn the source fortification in glibc off - otherwise it would panic\n# because of the stack pointer black magic in 'go' macro.\nlibmill_la_CFLAGS = \\\n    -fvisibility=hidden\\\n    -DMILL_EXPORTS \\\n    -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0\n\n################################################################################\n#  automated tests                                                             #\n################################################################################\n\nnoinst_PROGRAMS =\n\ncheck_PROGRAMS = \\\n    tests/example\\\n    tests/go\\\n    tests/cls\\\n    tests/chan\\\n    tests/choose\\\n    tests/sleep\\\n    tests/fdwait\\\n    tests/tcp\\\n    tests/udp\\\n    tests/unix\\\n    tests/signals\\\n    tests/overload\\\n    tests/ip\\\n    tests/file\\\n    tests/mfork1\\\n    tests/mfork2\\\n    tests/mfork3\\\n    tests/ssl\n\nEXTRA_DIST = \\\n    tests/cert.pem \\\n    tests/key.pem\n\nLDADD = libmill.la\n\nTESTS = $(check_PROGRAMS)\n\n################################################################################\n#  performance tests                                                           #\n################################################################################\n\nnoinst_PROGRAMS += \\\n    perf/go\\\n    perf/ctxswitch\\\n    perf/chan\\\n    perf/chs\\\n    perf/chr\\\n    perf/whispers\\\n    perf/c10k\n\n################################################################################\n#  tutorial                                                                    #\n################################################################################\n\nnoinst_PROGRAMS += \\\n    tutorial/step1 \\\n    tutorial/step2 \\\n    tutorial/step3 \\\n    tutorial/step4 \\\n    tutorial/step5 \\\n    tutorial/step6 \\\n    tutorial/step7 \\\n    tutorial/step8\n\n################################################################################\n#  additional packaging-related stuff                                          #\n################################################################################\n\n#  Generate ChangeLog file from git.\n#  Also, there's no git availabe when building from the source package and\n#  thus no way to obtain package version. Therefore, package version is\n#  saved into a file when building a source package.\ndist-hook:\n\t@if test -d \"$(srcdir)/.git\"; \\\n\tthen \\\n\t\techo Creating ChangeLog; \\\n\t\tcd \"$(top_srcdir)\"; \\\n\t\t(echo '# Generated by Makefile. Do not edit.'; echo; \\\n\t\t  ./missing --run git log --decorate ) > ChangeLog.tmp; \\\n\t\tmv -f ChangeLog.tmp $(top_distdir)/ChangeLog; \\\n\t\trm -f ChangeLog.tmp; \\\n    else \\\n        cp -f ChangeLog $(top_distdir)/ChangeLog || \\\n        echo Failed to generate ChangeLog >&2; \\\n\tfi; \\\n\t$(srcdir)/package_version.sh > $(distdir)/.version\n\nEXTRA_DIST += \\\n    ./abi_version.sh \\\n    ./package_version.sh \\\n    ./CMakeLists.txt\n\ndistclean-local:\n\t-rm -f config.h\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.3466796875,
          "content": "LIBMILL [![Build Status](https://travis-ci.org/sustrik/libmill.svg?branch=master)](https://travis-ci.org/sustrik/libmill)\n=======\n\nLibmill is a library that introduces Go-style concurrency to C.\n\nDocumentation\n-------------\n\nFor the documentation check the project website:\n\nhttp://libmill.org\n\nLicense\n-------\n\nLibmill is licensed under MIT/X11 license.\n"
        },
        {
          "name": "abi_version.sh",
          "type": "blob",
          "size": 1.79296875,
          "content": "#!/bin/sh\n\n# Copyright (c) 2013 Luca Barbato\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nif [ ! -f libmill.h ]; then\n    echo \"abi_version.sh: error: libmill.h does not exist\" 1>&2\n    exit 1\nfi\n\nCURRENT=`egrep '^#define +MILL_VERSION_CURRENT +[0-9]+$' libmill.h`\nREVISION=`egrep '^#define +MILL_VERSION_REVISION +[0-9]+$' libmill.h`\nAGE=`egrep '^#define +MILL_VERSION_AGE +[0-9]+$' libmill.h`\n\nif [ -z \"$CURRENT\" -o -z \"$REVISION\" -o -z \"$AGE\" ]; then\n    echo \"abi_version.sh: error: could not extract version from libmill.h\" 1>&2\n    exit 1\nfi\n\nCURRENT=`echo $CURRENT | awk '{ print $3 }'`\nREVISION=`echo $REVISION | awk '{ print $3 }'`\nAGE=`echo $AGE | awk '{ print $3 }'`\n\ncase $1 in\n    -libtool)\n        printf '%s' \"$CURRENT:$REVISION:$AGE\"\n    ;;\n    *)\n        printf '%s' \"$CURRENT.$REVISION.$AGE\"\n    ;;\nesac\n\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.0263671875,
          "content": "#!/bin/sh\n\nautoreconf -ifv\n"
        },
        {
          "name": "chan.c",
          "type": "blob",
          "size": 13.9580078125,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <assert.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"chan.h\"\n#include \"cr.h\"\n#include \"debug.h\"\n#include \"libmill.h\"\n#include \"utils.h\"\n\nMILL_CT_ASSERT(MILL_CLAUSELEN_ == sizeof(struct mill_clause));\n\nstatic int mill_choose_seqnum = 0;\n\nstruct mill_chan_ *mill_getchan(struct mill_ep *ep) {\n    switch(ep->type) {\n    case MILL_SENDER:\n        return mill_cont(ep, struct mill_chan_, sender);\n    case MILL_RECEIVER:\n        return mill_cont(ep, struct mill_chan_, receiver);\n    default:\n        assert(0);\n    }\n}\n\nstruct mill_chan_ *mill_chmake_(size_t sz, size_t bufsz, const char *created) {\n    /* If there's at least one channel created in the user's code\n       we want the debug functions to get into the binary. */\n    mill_preserve_debug();\n    /* We are allocating 1 additional element after the channel buffer to\n       store the done-with value. It can't be stored in the regular buffer\n       because that would mean chdone() would block when buffer is full. */\n    struct mill_chan_ *ch = (struct mill_chan_*)\n        malloc(sizeof(struct mill_chan_) + (sz * (bufsz + 1)));\n    if(!ch)\n        return NULL;\n    mill_register_chan(&ch->debug, created);\n    ch->sz = sz;\n    ch->sender.type = MILL_SENDER;\n    ch->sender.seqnum = mill_choose_seqnum;\n    mill_list_init(&ch->sender.clauses);\n    ch->receiver.type = MILL_RECEIVER;\n    ch->receiver.seqnum = mill_choose_seqnum;\n    mill_list_init(&ch->receiver.clauses);\n    ch->refcount = 1;\n    ch->done = 0;\n    ch->bufsz = bufsz;\n    ch->items = 0;\n    ch->first = 0;\n    mill_trace(created, \"<%d>=chmake(%d)\", (int)ch->debug.id, (int)bufsz);\n    return ch;\n}\n\nstruct mill_chan_ *mill_chdup_(struct mill_chan_ *ch, const char *current) {\n    if(mill_slow(!ch))\n        mill_panic(\"null channel used\");\n    mill_trace(current, \"chdup(<%d>)\", (int)ch->debug.id);\n    ++ch->refcount;\n    return ch;\n}\n\nvoid mill_chclose_(struct mill_chan_ *ch, const char *current) {\n    if(mill_slow(!ch))\n        mill_panic(\"null channel used\");\n    mill_trace(current, \"chclose(<%d>)\", (int)ch->debug.id);\n    assert(ch->refcount > 0);\n    --ch->refcount;\n    if(ch->refcount)\n        return;\n    if(!mill_list_empty(&ch->sender.clauses) ||\n          !mill_list_empty(&ch->receiver.clauses))\n        mill_panic(\"attempt to close a channel while it is still being used\");\n    mill_unregister_chan(&ch->debug);\n    free(ch);\n}\n\n/* Unblock a coroutine blocked in mill_choose_wait_() function.\n   It also cleans up the associated clause list. */\nstatic void mill_choose_unblock(struct mill_clause *cl) {\n    struct mill_slist_item *it;\n    struct mill_clause *itcl;\n    for(it = mill_slist_begin(&cl->cr->choosedata.clauses);\n          it; it = mill_slist_next(it)) {\n        itcl = mill_cont(it, struct mill_clause, chitem);\n        if(!itcl->used)\n            continue;\n        mill_list_erase(&itcl->ep->clauses, &itcl->epitem);\n    }\n    if(cl->cr->choosedata.ddline >= 0)\n        mill_timer_rm(&cl->cr->timer);\n    mill_resume(cl->cr, cl->idx);\n}\n\nstatic void mill_choose_init(const char *current) {\n    mill_set_current(&mill_running->debug, current);\n    mill_slist_init(&mill_running->choosedata.clauses);\n    mill_running->choosedata.othws = 0;\n    mill_running->choosedata.ddline = -1;\n    mill_running->choosedata.available = 0;\n    ++mill_choose_seqnum;\n}\n\nvoid mill_choose_init_(const char *current) {\n    mill_trace(current, \"choose()\");\n    mill_running->state = MILL_CHOOSE;\n    mill_choose_init(current);\n}\n\nvoid mill_choose_in_(void *clause, struct mill_chan_ *ch, size_t sz, int idx) {\n    if(mill_slow(!ch))\n        mill_panic(\"null channel used\");\n    if(mill_slow(ch->sz != sz))\n        mill_panic(\"receive of a type not matching the channel\");\n    /* Find out whether the clause is immediately available. */\n    int available = ch->done || !mill_list_empty(&ch->sender.clauses) ||\n        ch->items ? 1 : 0;\n    if(available)\n        ++mill_running->choosedata.available;\n    /* If there are available clauses don't bother with non-available ones. */\n    if(!available && mill_running->choosedata.available)\n        return;\n    /* Fill in the clause entry. */\n    struct mill_clause *cl = (struct mill_clause*) clause;\n    cl->cr = mill_running;\n    cl->ep = &ch->receiver;\n    cl->val = NULL;\n    cl->idx = idx;\n    cl->available = available;\n    cl->used = 1;\n    mill_slist_push_back(&mill_running->choosedata.clauses, &cl->chitem);\n    if(cl->ep->seqnum == mill_choose_seqnum) {\n        ++cl->ep->refs;\n        return;\n    }\n    cl->ep->seqnum = mill_choose_seqnum;\n    cl->ep->refs = 1;\n    cl->ep->tmp = -1;\n}\n\nvoid mill_choose_out_(void *clause, struct mill_chan_ *ch, void *val, size_t sz,\n      int idx) {\n    if(mill_slow(!ch))\n        mill_panic(\"null channel used\");\n    if(mill_slow(ch->done))\n        mill_panic(\"send to done-with channel\");\n    if(mill_slow(ch->sz != sz))\n        mill_panic(\"send of a type not matching the channel\");\n    /* Find out whether the clause is immediately available. */\n    int available = !mill_list_empty(&ch->receiver.clauses) ||\n        ch->items < ch->bufsz ? 1 : 0;\n    if(available)\n        ++mill_running->choosedata.available;\n    /* If there are available clauses don't bother with non-available ones. */\n    if(!available && mill_running->choosedata.available)\n        return;\n    /* Fill in the clause entry. */\n    struct mill_clause *cl = (struct mill_clause*) clause;\n    cl->cr = mill_running;\n    cl->ep = &ch->sender;\n    cl->val = val;\n    cl->available = available;\n    cl->idx = idx;\n    cl->used = 1;\n    mill_slist_push_back(&mill_running->choosedata.clauses, &cl->chitem);\n    if(cl->ep->seqnum == mill_choose_seqnum) {\n        ++cl->ep->refs;\n        return;\n    }\n    cl->ep->seqnum = mill_choose_seqnum;\n    cl->ep->refs = 1;\n    cl->ep->tmp = -1;\n}\n\nstatic void mill_choose_callback(struct mill_timer *timer) {\n    struct mill_cr *cr = mill_cont(timer, struct mill_cr, timer);\n    struct mill_slist_item *it;\n    for(it = mill_slist_begin(&cr->choosedata.clauses);\n          it; it = mill_slist_next(it)) {\n        struct mill_clause *itcl = mill_cont(it, struct mill_clause, chitem);\n        mill_assert(itcl->used);\n        mill_list_erase(&itcl->ep->clauses, &itcl->epitem);\n    }\n    mill_resume(cr, -1);\n}\n\nvoid mill_choose_deadline_(int64_t ddline) {\n    if(mill_slow(mill_running->choosedata.othws ||\n          mill_running->choosedata.ddline >= 0))\n        mill_panic(\n            \"multiple 'otherwise' or 'deadline' clauses in a choose statement\");\n    /* Infinite deadline clause can never fire so we can as well ignore it. */\n    if(ddline < 0)\n        return;\n    mill_running->choosedata.ddline = ddline;\n}\n\nvoid mill_choose_otherwise_(void) {\n    if(mill_slow(mill_running->choosedata.othws ||\n          mill_running->choosedata.ddline >= 0))\n        mill_panic(\n            \"multiple 'otherwise' or 'deadline' clauses in a choose statement\");\n    mill_running->choosedata.othws = 1;\n}\n\n/* Push new item to the channel. */\nstatic void mill_enqueue(struct mill_chan_ *ch, void *val) {\n    /* If there's a receiver already waiting, let's resume it. */\n    if(!mill_list_empty(&ch->receiver.clauses)) {\n        mill_assert(ch->items == 0);\n        struct mill_clause *cl = mill_cont(\n            mill_list_begin(&ch->receiver.clauses), struct mill_clause, epitem);\n        memcpy(mill_valbuf(cl->cr, ch->sz), val, ch->sz);\n        mill_choose_unblock(cl);\n        return;\n    }\n    /* Write the value to the buffer. */\n    assert(ch->items < ch->bufsz);\n    size_t pos = (ch->first + ch->items) % ch->bufsz;\n    memcpy(((char*)(ch + 1)) + (pos * ch->sz) , val, ch->sz);\n    ++ch->items;\n}\n\n/* Pop one value from the channel. */\nstatic void mill_dequeue(struct mill_chan_ *ch, void *val) {\n    /* Get a blocked sender, if any. */\n    struct mill_clause *cl = mill_cont(\n        mill_list_begin(&ch->sender.clauses), struct mill_clause, epitem);\n    if(!ch->items) {\n        /* If chdone was already called we can return the value immediately.\n           There are no senders waiting to send. */\n        if(mill_slow(ch->done)) {\n            mill_assert(!cl);\n            memcpy(val, ((char*)(ch + 1)) + (ch->bufsz * ch->sz), ch->sz);\n            return;\n        }\n        /* Otherwise there must be a sender waiting to send. */\n        mill_assert(cl);\n        memcpy(val, cl->val, ch->sz);\n        mill_choose_unblock(cl);\n        return;\n    }\n    /* If there's a value in the buffer start by retrieving it. */\n    memcpy(val, ((char*)(ch + 1)) + (ch->first * ch->sz), ch->sz);\n    ch->first = (ch->first + 1) % ch->bufsz;\n    --ch->items;\n    /* And if there was a sender waiting, unblock it. */\n    if(cl) {\n        assert(ch->items < ch->bufsz);\n        size_t pos = (ch->first + ch->items) % ch->bufsz;\n        memcpy(((char*)(ch + 1)) + (pos * ch->sz) , cl->val, ch->sz);\n        ++ch->items;\n        mill_choose_unblock(cl);\n    }\n}\n\nint mill_choose_wait_(void) {\n    struct mill_choosedata *cd = &mill_running->choosedata;\n    struct mill_slist_item *it;\n    struct mill_clause *cl;\n\n    /* If there are clauses that are immediately available\n       randomly choose one of them. */\n    if(cd->available > 0) {\n        int chosen = cd->available == 1 ? 0 : (int)(random() % (cd->available));\n        for(it = mill_slist_begin(&cd->clauses); it; it = mill_slist_next(it)) {\n            cl = mill_cont(it, struct mill_clause, chitem);\n            if(!cl->available)\n                continue;\n            if(!chosen)\n                break;\n            --chosen;\n        }\n        struct mill_chan_ *ch = mill_getchan(cl->ep);\n        if(cl->ep->type == MILL_SENDER)\n            mill_enqueue(ch, cl->val);\n        else\n            mill_dequeue(ch, mill_valbuf(cl->cr, ch->sz));\n        mill_resume(mill_running, cl->idx);\n        return mill_suspend();\n    }\n\n    /* If not so but there's an 'otherwise' clause we can go straight to it. */\n    if(cd->othws) {\n        mill_resume(mill_running, -1);\n        return mill_suspend();\n    }\n\n    /* If deadline was specified, start the timer. */\n    if(cd->ddline >= 0)\n        mill_timer_add(&mill_running->timer, cd->ddline, mill_choose_callback);\n\n    /* In all other cases register this coroutine with the queried channels\n       and wait till one of the clauses unblocks. */\n    for(it = mill_slist_begin(&cd->clauses); it; it = mill_slist_next(it)) {\n        cl = mill_cont(it, struct mill_clause, chitem);\n        if(mill_slow(cl->ep->refs > 1)) {\n            if(cl->ep->tmp == -1)\n                cl->ep->tmp =\n                    cl->ep->refs == 1 ? 0 : (int)(random() % cl->ep->refs);\n            if(cl->ep->tmp) {\n                --cl->ep->tmp;\n                cl->used = 0;\n                continue;\n            }\n            cl->ep->tmp = -2;\n        }\n        mill_list_insert(&cl->ep->clauses, &cl->epitem, NULL);\n    }\n    /* If there are multiple parallel chooses done from different coroutines\n       all but one must be blocked on the following line. */\n    return mill_suspend();\n}\n\nvoid *mill_choose_val_(size_t sz) {\n    /* The assumption here is that by supplying the same size as before\n       we are going to get the same buffer which already has the data\n       written into it. */\n    return mill_valbuf(mill_running, sz);\n}\n\nvoid mill_chs_(struct mill_chan_ *ch, void *val, size_t sz,\n      const char *current) {\n    if(mill_slow(!ch))\n        mill_panic(\"null channel used\");\n    mill_trace(current, \"chs(<%d>)\", (int)ch->debug.id);\n    mill_choose_init(current);\n    mill_running->state = MILL_CHS;\n    struct mill_clause cl;\n    mill_choose_out_(&cl, ch, val, sz, 0);\n    mill_choose_wait_();\n}\n\nvoid *mill_chr_(struct mill_chan_ *ch, size_t sz, const char *current) {\n    if(mill_slow(!ch))\n        mill_panic(\"null channel used\");\n    mill_trace(current, \"chr(<%d>)\", (int)ch->debug.id);\n    mill_running->state = MILL_CHR;\n    mill_choose_init(current);\n    struct mill_clause cl;\n    mill_choose_in_(&cl, ch, sz, 0);\n    mill_choose_wait_();\n    return mill_choose_val_(sz);\n}\n\nvoid mill_chdone_(struct mill_chan_ *ch, void *val, size_t sz,\n      const char *current) {\n    if(mill_slow(!ch))\n        mill_panic(\"null channel used\");\n    mill_trace(current, \"chdone(<%d>)\", (int)ch->debug.id);\n    if(mill_slow(ch->done))\n        mill_panic(\"chdone on already done-with channel\");\n    if(mill_slow(ch->sz != sz))\n        mill_panic(\"send of a type not matching the channel\");\n    /* Panic if there are other senders on the same channel. */\n    if(mill_slow(!mill_list_empty(&ch->sender.clauses)))\n        mill_panic(\"send to done-with channel\");\n    /* Put the channel into done-with mode. */\n    ch->done = 1;\n    /* Store the terminal value into a special position in the channel. */\n    memcpy(((char*)(ch + 1)) + (ch->bufsz * ch->sz) , val, ch->sz);\n    /* Resume all the receivers currently waiting on the channel. */\n    while(!mill_list_empty(&ch->receiver.clauses)) {\n        struct mill_clause *cl = mill_cont(\n            mill_list_begin(&ch->receiver.clauses), struct mill_clause, epitem);\n        memcpy(mill_valbuf(cl->cr, ch->sz), val, ch->sz);\n        mill_choose_unblock(cl);\n    }\n}\n\n"
        },
        {
          "name": "chan.h",
          "type": "blob",
          "size": 4.0166015625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_CHAN_INCLUDED\n#define MILL_CHAN_INCLUDED\n\n#include <stddef.h>\n\n#include \"debug.h\"\n#include \"list.h\"\n#include \"slist.h\"\n\n/* One of these structures is preallocated for every coroutine. */\nstruct mill_choosedata {\n    /* List of clauses in the 'choose' statement. */\n    struct mill_slist clauses;\n    /* 1 if there is 'otherwise' clause. 0 if there is not. */\n    int othws;\n    /* Deadline specified in 'deadline' clause. -1 if none. */\n    int64_t ddline;\n    /* Number of clauses that are immediately available. */\n    int available;\n};\n\n/* Channel endpoint. */\nstruct mill_ep {\n    /* Thanks to this flag we can cast from ep pointer to chan pointer. */\n    enum {MILL_SENDER, MILL_RECEIVER} type;\n    /* Sequence number of the choose operation being initialised. */\n    int seqnum;\n    /* Number of clauses referring to this endpoint within the choose\n       operation being initialised. */\n    int refs;\n    /* Number of refs already processed. */\n    int tmp;\n    /* List of clauses waiting for this endpoint. */\n    struct mill_list clauses;\n};\n\n/* Channel. */\nstruct mill_chan_ {\n    /* The size of the elements stored in the channel, in bytes. */\n    size_t sz;\n    /* Channel holds two lists, the list of clauses waiting to send and list\n       of clauses waiting to receive. */\n    struct mill_ep sender;\n    struct mill_ep receiver;\n    /* Number of open handles to this channel. */\n    int refcount;\n    /* 1 is chdone() was already called. 0 otherwise. */\n    int done;\n\n    /* The message buffer directly follows the chan structure. 'bufsz' specifies\n       the maximum capacity of the buffer. 'items' is the number of messages\n       currently in the buffer. 'first' is the index of the next message to\n       be received from the buffer. There's one extra element at the end of\n       the buffer used to store the message supplied by chdone() function. */\n    size_t bufsz;\n    size_t items;\n    size_t first;\n\n    /* Debugging info. */\n    struct mill_debug_chan debug;\n};\n\n/* This structure represents a single clause in a choose statement.\n   Similarly, both chs() and chr() each create a single clause. */\nstruct mill_clause {\n    /* Member of list of clauses waiting for a channel endpoint. */\n    struct mill_list_item epitem;\n    /* Linked list of clauses in the choose statement. */\n    struct mill_slist_item chitem;\n    /* The coroutine which created the clause. */\n    struct mill_cr *cr;\n    /* Channel endpoint the clause is waiting for. */\n    struct mill_ep *ep;\n    /* For out clauses, pointer to the value to send. NULL for in clauses. */\n    void *val;\n    /* The index to jump to when the clause is executed. */\n    int idx;\n    /* If 0, there's no peer waiting for the clause at the moment.\n       If 1, there is one. */\n    int available;\n    /* If 1, the clause is in the list of channel's senders/receivers. */\n    int used;\n};\n\n/* Returns pointer to the channel that contains specified endpoint. */\nstruct mill_chan_ *mill_getchan(struct mill_ep *ep);\n\n#endif\n\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 5.232421875,
          "content": "#\n# Copyright (c) 2013 Luca Barbato\n# Copyright (c) 2015 Martin Sustrik  All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\n################################################################################\n#  Start the configuration phase.                                              #\n################################################################################\n\nAC_PREREQ([2.53])\n\nAC_INIT([libmill], [m4_esyscmd([./package_version.sh])],\n   [libmill@freelists.org], [libmill], [http://libmill.org/])\nAC_CONFIG_SRCDIR([libmill.pc.in])\nAM_INIT_AUTOMAKE([1.6 foreign subdir-objects tar-ustar])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nAC_CANONICAL_HOST\n\n################################################################################\n#  Retrieve the versions.                                                      #\n################################################################################\n\nAC_PROG_SED\nAC_PROG_AWK\n\nMILL_ABI_VERSION=m4_esyscmd([./abi_version.sh])\nMILL_PACKAGE_VERSION=m4_esyscmd([./package_version.sh])\nMILL_LIBTOOL_VERSION=m4_esyscmd([./abi_version.sh -libtool])\n\nAC_SUBST(MILL_ABI_VERSION)\nAC_SUBST(MILL_PACKAGE_VERSION)\nAC_SUBST(MILL_LIBTOOL_VERSION)\n\nAC_MSG_NOTICE([Mill package version: $MILL_PACKAGE_VERSION])\nAC_MSG_NOTICE([Mill ABI version: $MILL_ABI_VERSION])\n\n################################################################################\n#  Check the compilers.                                                        #\n################################################################################\n\nAC_PROG_CC_C99\nAM_PROG_CC_C_O\n\n################################################################################\n#  --enable-ssl                                                                #\n################################################################################\n\nAC_ARG_ENABLE([ssl], [AS_HELP_STRING([--enable-ssl],\n    [Enable SSL sockets [default=no]])])\n\nif test \"x$enable_ssl\" = \"xyes\"; then\n    AC_DEFINE(HAVE_SSL)\n    AC_CHECK_LIB([ssl], [SSL_ctrl], [],\n        AC_MSG_ERROR([libssl not found; install OpenSSL]))\n    AC_CHECK_LIB([crypto], [BIO_read], [],\n        AC_MSG_ERROR([libcrypto not found; install OpenSSL]))\nfi\n\n################################################################################\n#  --enable-debug                                                              #\n################################################################################\n\nAC_ARG_ENABLE([debug], [AS_HELP_STRING([--enable-debug],\n    [Enable debugging information [default=no]])])\n\nif test \"x$enable_debug\" = \"xyes\"; then\n    # Override original optimisation level - last option specified wins.\n    CFLAGS=\"$CFLAGS -g -O0\"\nfi\n\n################################################################################\n#  --enable-valgrind                                                           #\n################################################################################\n\nAC_ARG_ENABLE([valgrind], [AS_HELP_STRING([--enable-valgrind],\n    [Provide information about coroutine stacks to valgrind [default=no]])])\n\nif test \"x$enable_valgrind\" = \"xyes\"; then\n    AC_DEFINE(MILL_VALGRIND)\nfi\n\n################################################################################\n#  Feature checks.                                                             #\n################################################################################\n\nAC_CHECK_FUNC([posix_memalign], [AC_DEFINE([HAVE_POSIX_MEMALIGN])])\nAC_CHECK_FUNC([mprotect], [AC_DEFINE([HAVE_MPROTECT])])\nAC_CHECK_LIB([rt], [clock_gettime])\nAC_CHECK_FUNCS([clock_gettime])\nAC_CHECK_LIB([socket], [socket])\nAC_CHECK_FUNCS([epoll_create], [] ,[AC_DEFINE([MILL_NO_EPOLL])])\nAC_CHECK_FUNCS([kqueue], [] ,[AC_DEFINE([MILL_NO_KQUEUE])])\n\n################################################################################\n#  Libtool                                                                     #\n################################################################################\n\nLT_INIT\n\n################################################################################\n#  Finish the configuration phase.                                             #\n################################################################################\n\nAC_CONFIG_MACRO_DIR([m4])\n\nAC_OUTPUT([Makefile libmill.pc])\ncp confdefs.h config.h\n\n"
        },
        {
          "name": "cr.c",
          "type": "blob",
          "size": 7.6796875,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined MILL_VALGRIND\n#include <valgrind/valgrind.h>\n#endif\n\n#include \"cr.h\"\n#include \"debug.h\"\n#include \"libmill.h\"\n#include \"poller.h\"\n#include \"stack.h\"\n#include \"utils.h\"\n\n/* Size of the buffer for temporary storage of values received from channels.\n   It should be properly aligned and never change if there are any stacks\n   allocated at the moment. */\nsize_t mill_valbuf_size = 128;\n\n/* Valbuf for tha main coroutine. */\nchar mill_main_valbuf[128];\n\nvolatile int mill_unoptimisable1_ = 1;\nvolatile void *mill_unoptimisable2_ = NULL;\n\nstruct mill_cr mill_main = {0};\n\nstruct mill_cr *mill_running = &mill_main;\n\n/* Queue of coroutines scheduled for execution. */\nstruct mill_slist mill_ready = {0};\n\ninline mill_ctx mill_getctx_(void) {\n#if defined __x86_64__\n    return mill_running->ctx;\n#else\n    return &mill_running->ctx;\n#endif\n}\n\nstatic void *mill_getvalbuf(struct mill_cr *cr, size_t size) {\n    /* Small valbufs don't require dynamic allocation. Also note that main\n       coroutine doesn't have a stack allocated on the heap like other\n       coroutines, so we have to handle valbuf in a special way. */\n    if(mill_fast(cr != &mill_main)) {\n        if(mill_fast(size <= mill_valbuf_size))\n            return (void*)(((char*)cr) - mill_valbuf_size);\n    }\n    else {\n        if(mill_fast(size <= sizeof(mill_main_valbuf)))\n            return (void*)mill_main_valbuf;\n    }\n    /* Large valbufs are simply allocated on heap. */\n    if(mill_fast(cr->valbuf && cr->valbuf_sz <= size))\n        return cr->valbuf;\n    void *ptr = realloc(cr->valbuf, size);\n    if(!ptr)\n        return NULL;\n    cr->valbuf = ptr;\n    cr->valbuf_sz = size;\n    return cr->valbuf;\n}\n\nvoid mill_goprepare_(int count, size_t stack_size, size_t val_size) {\n    if(mill_slow(mill_hascrs())) {errno = EAGAIN; return;}\n    /* Allocate any resources needed by the polling mechanism. */\n    mill_poller_init();\n    if(mill_slow(errno != 0)) return;\n    /* If needed, make val size slightly bigger to align properly. */\n    mill_valbuf_size = (val_size + 15) & ~((size_t)0xf);\n    /* Preallocate the valbuf for the main coroutine. */\n    if(mill_slow(!mill_getvalbuf(&mill_main, mill_valbuf_size))) {\n        errno = ENOMEM; return;}\n    /* Allocate the stacks. */\n    mill_preparestacks(count, stack_size + mill_valbuf_size +\n        sizeof(struct mill_cr));\n}\n\nint mill_suspend(void) {\n    /* Even if process never gets idle, we have to process external events\n       once in a while. The external signal may very well be a deadline or\n       a user-issued command that cancels the CPU intensive operation. */\n    static int counter = 0;\n    if(counter >= 103) {\n        mill_wait(0);\n        counter = 0;\n    }\n    /* Store the context of the current coroutine, if any. */\n    if(mill_running) {\n        mill_ctx ctx = mill_getctx_();\n        if (mill_setjmp_(ctx))\n            return mill_running->result;\n    }\n    while(1) {\n        /* If there's a coroutine ready to be executed go for it. */\n        if(!mill_slist_empty(&mill_ready)) {\n            ++counter;\n            struct mill_slist_item *it = mill_slist_pop(&mill_ready);\n            mill_running = mill_cont(it, struct mill_cr, ready);\n            mill_assert(mill_running->is_ready == 1);\n            mill_running->is_ready = 0;\n            mill_longjmp_(mill_getctx_());\n        }\n        /* Otherwise, we are going to wait for sleeping coroutines\n           and for external events. */\n        mill_wait(1);\n        mill_assert(!mill_slist_empty(&mill_ready));\n        counter = 0;\n    }\n}\n\ninline void mill_resume(struct mill_cr *cr, int result) {\n    mill_assert(!cr->is_ready);\n    cr->result = result;\n    cr->state = MILL_READY;\n    cr->is_ready = 1;\n    mill_slist_push_back(&mill_ready, &cr->ready);\n}\n\n/* mill_prologue_() and mill_epilogue_() live in the same scope with\n   libdill's stack-switching black magic. As such, they are extremely\n   fragile. Therefore, the optimiser is prohibited to touch them. */\n#if defined __clang__\n#define dill_noopt __attribute__((optnone))\n#elif defined __GNUC__\n#define dill_noopt __attribute__((optimize(\"O0\")))\n#else\n#error \"Unsupported compiler!\"\n#endif\n\n/* The intial part of go(). Starts the new coroutine.\n   Returns the pointer to the top of its stack. */\n__attribute__((noinline)) dill_noopt\nvoid *mill_prologue_(const char *created) {\n    /* Ensure that debug functions are available whenever a single go()\n       statement is present in the user's code. */\n    mill_preserve_debug();\n    /* Allocate and initialise new stack. */\n#if defined MILL_VALGRIND\n    size_t stack_size;\n    struct mill_cr *cr = ((struct mill_cr*)mill_allocstack(&stack_size));\n    int sid = VALGRIND_STACK_REGISTER(((char*)cr) - stack_size, cr);\n    --cr;\n    cr->sid = sid;\n#else\n    struct mill_cr *cr = ((struct mill_cr*)mill_allocstack(NULL)) - 1;\n#endif\n    mill_register_cr(&cr->debug, created);\n    cr->is_ready = 0;\n    cr->valbuf = NULL;\n    cr->valbuf_sz = 0;\n    cr->clsval = NULL;\n    cr->timer.expiry = -1;\n    cr->fd = -1;\n    cr->events = 0;\n    mill_trace(created, \"{%d}=go()\", (int)cr->debug.id);\n    /* Suspend the parent coroutine and make the new one running. */\n    mill_resume(mill_running, 0);    \n    mill_running = cr;\n    /* Return pointer to the top of the stack. There's valbuf interposed\n       between the mill_cr structure and the stack itself. */\n    return (void*)(((char*)cr) - mill_valbuf_size);\n}\n\n/* The final part of go(). Cleans up after the coroutine is finished. */\n__attribute__((noinline)) dill_noopt\nvoid mill_epilogue_(void) {\n    mill_trace(NULL, \"go() done\");\n    mill_unregister_cr(&mill_running->debug);\n    if(mill_running->valbuf)\n        free(mill_running->valbuf);\n#if defined MILL_VALGRIND\n    VALGRIND_STACK_DEREGISTER(mill_running->sid);\n#endif\n    mill_freestack(mill_running + 1);\n    mill_running = NULL;\n    /* Given that there's no running coroutine at this point\n       this call will never return. */\n    mill_suspend();\n}\n\nvoid mill_yield_(const char *current) {\n    mill_trace(current, \"yield()\");\n    mill_set_current(&mill_running->debug, current);\n    /* This looks fishy, but yes, we can resume the coroutine even before\n       suspending it. */\n    mill_resume(mill_running, 0);\n    mill_suspend();\n}\n\nvoid *mill_valbuf(struct mill_cr *cr, size_t size) {\n    void *ptr = mill_getvalbuf(cr, size);\n    if(!ptr)\n        mill_panic(\"not enough memory to receive from channel\");\n    return ptr;\n}\n\nvoid *mill_cls_(void) {\n    return mill_running->clsval;\n}\n\nvoid mill_setcls_(void *val) {\n    mill_running->clsval = val;\n}\n\nvoid mill_cr_postfork(void) {\n    /* Drop all coroutines in the \"ready to execute\" list. */\n    mill_slist_init(&mill_ready);\n}\n\n"
        },
        {
          "name": "cr.h",
          "type": "blob",
          "size": 4.384765625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_CR_INCLUDED\n#define MILL_CR_INCLUDED\n\n#include <setjmp.h>\n#include <stdint.h>\n\n#include \"chan.h\"\n#include \"debug.h\"\n#include \"list.h\"\n#include \"slist.h\"\n#include \"timer.h\"\n#include \"utils.h\"\n\nenum mill_state {\n    MILL_READY,\n    MILL_MSLEEP,\n    MILL_FDWAIT,\n    MILL_CHR,\n    MILL_CHS,\n    MILL_CHOOSE\n};\n\n/* The coroutine. The memory layout looks like this:\n\n   +----------------------------------------------------+--------+---------+\n   |                                              stack | valbuf | mill_cr |\n   +----------------------------------------------------+--------+---------+\n\n   - mill_cr contains generic book-keeping info about the coroutine\n   - valbuf is a buffer for temporarily storing values received from channels\n   - stack is a standard C stack; it grows downwards (at the moment libmill\n     doesn't support microarchitectures where stack grows upwards)\n\n*/\nstruct mill_cr {\n    /* Status of the coroutine. Used for debugging purposes. */\n    enum mill_state state;\n\n    /* The coroutine is stored in this list if it is not blocked and it is\n       waiting to be executed. In such case 'is_ready' is set to 1, otherwise\n       it's set to 0. */\n    int is_ready;\n    struct mill_slist_item ready;\n\n    /* If the coroutine is waiting for a deadline, it uses this timer. */\n    struct mill_timer timer;\n\n    /* The file descriptor for which the coroutine waits for an event\n       when blocked in fdwait(). -1 when it isn't waiting for any event. */\n    int fd;\n\n    /* When the coroutine is blocked in fdwait(), the events that the function\n       waits for. This is used only for debugging purposes. */\n    int events;\n\n    /* This structure is used when the coroutine is executing a choose\n       statement. */\n    struct mill_choosedata choosedata;\n\n    /* Stored coroutine context while it is not executing. */\n#if defined(__x86_64__)\n    uint64_t ctx[10];\n#else\n    sigjmp_buf ctx;\n#endif\n\n    /* Argument to resume() call being passed to the blocked suspend() call. */\n    int result;\n\n    /* If size of the valbuf needs to be larger than mill_valbuf size it is\n       allocated dyncamically and the pointer, along with the size of the buffer\n       is stored here. */\n    void *valbuf;\n    size_t valbuf_sz;\n\n    /* Coroutine-local storage. */\n    void *clsval;\n\n#if defined MILL_VALGRIND\n    /* Valgrind stack identifier. */\n    int sid;\n#endif\n\n    /* Debugging info. */\n    struct mill_debug_cr debug;\n};\n\n/* Fake coroutine corresponding to the main thread of execution. */\nextern struct mill_cr mill_main;\n\n/* The coroutine that is running at the moment. */\nextern struct mill_cr *mill_running;\n\n/* Suspend running coroutine. Move to executing different coroutines. Once\n   someone resumes this coroutine using mill_resume function 'result' argument\n   of that function will be returned. */\nint mill_suspend(void);\n\n/* Schedules preiously suspended coroutine for execution. Keep in mind that\n   it doesn't immediately run it, just puts it into the queue of ready\n   coroutines. */\nvoid mill_resume(struct mill_cr *cr, int result);\n\n/* Returns pointer to the value buffer. The returned buffer is guaranteed\n   to be at least 'size' bytes long. */\nvoid *mill_valbuf(struct mill_cr *cr, size_t size);\n\n/* Called in the child process after fork to stop all the coroutines \n   inherited from the parent. */\nvoid mill_cr_postfork(void);\n\n#endif\n"
        },
        {
          "name": "debug.c",
          "type": "blob",
          "size": 8.0009765625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <assert.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <time.h>\n\n#include \"chan.h\"\n#include \"cr.h\"\n#include \"libmill.h\"\n#include \"list.h\"\n#include \"stack.h\"\n#include \"utils.h\"\n\n/* ID to be assigned to next launched coroutine. */\nstatic int mill_next_cr_id = 1;\n\n/* List of all coroutines. */\nstatic struct mill_list mill_all_crs = {\n    &mill_main.debug.item, &mill_main.debug.item};\n\n/* ID to be assigned to the next created channel. */\nstatic int mill_next_chan_id = 1;\n\n/* List of all channels. */\nstatic struct mill_list mill_all_chans = {0};\n\nvoid mill_panic(const char *text) {\n    fprintf(stderr, \"panic: %s\\n\", text);\n    abort();\n}\n\nvoid mill_register_cr(struct mill_debug_cr *cr, const char *created) {\n    mill_list_insert(&mill_all_crs, &cr->item, NULL);\n    cr->id = mill_next_cr_id;\n    ++mill_next_cr_id;\n    cr->created = created;\n    cr->current = NULL;\n}\n\nvoid mill_unregister_cr(struct mill_debug_cr *cr) {\n    mill_list_erase(&mill_all_crs, &cr->item);\n}\n\nvoid mill_register_chan(struct mill_debug_chan *ch, const char *created) {\n    mill_list_insert(&mill_all_chans, &ch->item, NULL);\n    ch->id = mill_next_chan_id;\n    ++mill_next_chan_id;\n    ch->created = created;\n}\n\nvoid mill_unregister_chan(struct mill_debug_chan *ch) {\n    mill_list_erase(&mill_all_chans, &ch->item);\n}\n\nvoid mill_set_current(struct mill_debug_cr *cr, const char *current) {\n    cr->current = current;\n}\n\nvoid goredump(void) {\n    char buf[256];\n    char idbuf[10];\n\n    fprintf(stderr,\n        \"\\nCOROUTINE  state                                      \"\n        \"current                                  created\\n\");\n    fprintf(stderr,\n        \"----------------------------------------------------------------------\"\n        \"--------------------------------------------------\\n\");\n    struct mill_list_item *it;\n    for(it = mill_list_begin(&mill_all_crs); it; it = mill_list_next(it)) {\n        struct mill_cr *cr = mill_cont(it, struct mill_cr, debug.item);\n        switch(cr->state) {\n        case MILL_READY:\n            sprintf(buf, \"%s\", mill_running == cr ? \"RUNNING\" : \"ready\");\n            break;\n        case MILL_MSLEEP:\n            sprintf(buf, \"msleep()\");\n            break;\n        case MILL_FDWAIT:\n            sprintf(buf, \"fdwait(%d, %s)\", cr->fd,\n                (cr->events & FDW_IN) &&\n                    (cr->events & FDW_OUT) ? \"FDW_IN | FDW_OUT\" :\n                cr->events & FDW_IN ? \"FDW_IN\" :\n                cr->events & FDW_OUT ? \"FDW_OUT\" : 0);\n            break;\n        case MILL_CHR:\n        case MILL_CHS:\n        case MILL_CHOOSE:\n            {\n                int pos = 0;\n                if(cr->state == MILL_CHR)\n                    pos += sprintf(&buf[pos], \"chr(\");\n                else if(cr->state == MILL_CHS)\n                    pos += sprintf(&buf[pos], \"chs(\");\n                else\n                    pos += sprintf(&buf[pos], \"choose(\");\n                int first = 1;\n                struct mill_slist_item *it;\n                for(it = mill_slist_begin(&cr->choosedata.clauses); it;\n                      it = mill_slist_next(it)) {\n                if(first)\n                    first = 0;\n                else\n                    pos += sprintf(&buf[pos], \",\");\n                pos += sprintf(&buf[pos], \"<%d>\", mill_getchan(\n                        mill_cont(it, struct mill_clause,\n                        chitem)->ep)->debug.id);\n            }\n            sprintf(&buf[pos], \")\");\n            }\n            break;\n        default:\n            assert(0);\n        }\n        snprintf(idbuf, sizeof(idbuf), \"{%d}\", (int)cr->debug.id);\n        fprintf(stderr, \"%-8s   %-42s %-40s %s\\n\",\n            idbuf,\n            buf,\n            cr == mill_running ? \"---\" : cr->debug.current,\n            cr->debug.created ? cr->debug.created : \"<main>\");\n    }\n    fprintf(stderr,\"\\n\");\n\n    if(mill_list_empty(&mill_all_chans))\n        return;\n    fprintf(stderr,\n        \"CHANNEL  msgs/max    senders/receivers                          \"\n        \"refs  done  created\\n\");\n    fprintf(stderr,\n        \"----------------------------------------------------------------------\"\n        \"--------------------------------------------------\\n\");\n    for(it = mill_list_begin(&mill_all_chans); it; it = mill_list_next(it)) {\n        struct mill_chan_ *ch = mill_cont(it, struct mill_chan_, debug.item);\n        snprintf(idbuf, sizeof(idbuf), \"<%d>\", (int)ch->debug.id);\n        sprintf(buf, \"%d/%d\",\n            (int)ch->items,\n            (int)ch->bufsz);\n        fprintf(stderr, \"%-8s %-11s \",\n            idbuf,\n            buf);\n        int pos;\n        struct mill_list *clauselist;\n        if(!mill_list_empty(&ch->sender.clauses)) {\n            pos = sprintf(buf, \"s:\");\n            clauselist = &ch->sender.clauses;\n        }\n        else if(!mill_list_empty(&ch->receiver.clauses)) {\n            pos = sprintf(buf, \"r:\");\n            clauselist = &ch->receiver.clauses;\n        }\n        else {\n            sprintf(buf, \" \");\n            clauselist = NULL;\n        }\n        struct mill_clause *cl = NULL;\n        if(clauselist)\n            cl = mill_cont(mill_list_begin(clauselist),\n                struct mill_clause, epitem);\n        int first = 1;\n        while(cl) {\n            if(first)\n                first = 0;\n            else\n                pos += sprintf(&buf[pos], \",\");\n            pos += sprintf(&buf[pos], \"{%d}\", (int)cl->cr->debug.id);\n            cl = mill_cont(mill_list_next(&cl->epitem),\n                struct mill_clause, epitem);\n        }\n        fprintf(stderr, \"%-42s %-5d %-5s %s\\n\",\n            buf,\n            (int)ch->refcount,\n            ch->done ? \"yes\" : \"no\",\n            ch->debug.created);\n    }\n    fprintf(stderr,\"\\n\");\n}\n\nint mill_tracelevel = 0;\n\nvoid gotrace(int level) {\n    mill_tracelevel = level;\n}\n\nvoid mill_trace_(const char *location, const char *format, ...) {\n    if(mill_fast(mill_tracelevel <= 0))\n        return;\n\n    char buf[256];\n\n    /* First print the timestamp. */\n    struct timeval nw;\n    gettimeofday(&nw, NULL);\n    struct tm *nwtm = localtime(&nw.tv_sec);\n    snprintf(buf, sizeof buf, \"%02d:%02d:%02d\",\n        (int)nwtm->tm_hour, (int)nwtm->tm_min, (int)nwtm->tm_sec);\n    fprintf(stderr, \"==> %s.%06d \", buf, (int)nw.tv_usec);\n\n    /* Coroutine ID. */\n    snprintf(buf, sizeof(buf), \"{%d}\", (int)mill_running->debug.id);\n    fprintf(stderr, \"%-8s \", buf);\n\n    va_list va;\n    va_start(va ,format);\n    vfprintf(stderr, format, va);\n    va_end(va);\n    if(location)\n        fprintf(stderr, \" at %s\\n\", location);\n    else\n        fprintf(stderr, \"\\n\");\n    fflush(stderr);\n}\n\nvoid mill_preserve_debug(void) {\n    /* Do nothing, but trick the compiler into thinking that the debug\n       functions are being used so that it does not optimise them away. */\n    static volatile int unoptimisable = 1;\n    if(unoptimisable)\n        return;\n    goredump();\n    gotrace(0);\n}\n\nint mill_hascrs(void) {\n    return (mill_all_crs.first == &mill_main.debug.item &&\n        mill_all_crs.last == &mill_main.debug.item) ? 0 : 1;\n}\n\n"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 2.6337890625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_DEBUG_INCLUDED\n#define MILL_DEBUG_INCLUDED\n\n#include \"list.h\"\n#include \"utils.h\"\n\nstruct mill_debug_cr {\n    /* List of all coroutines. */\n    struct mill_list_item item;\n    /* Unique ID of the coroutine. */\n    int id;\n    /* File and line where the coroutine was launched. */\n    const char *created;\n    /* File and line where the current blocking operation was invoked from. */\n    const char *current;\n};\n\nstruct mill_debug_chan {\n    /* List of all channels. */\n    struct mill_list_item item;\n    /* Unique ID of the channel. */\n    int id;\n    /* File and line where the channel was created. */\n    const char *created;\n};\n\n/* Cause panic. */\nvoid mill_panic(const char *text);\n\n/* No-op, but ensures that debugging functions get compiled into the binary. */\nvoid mill_preserve_debug(void);\n\n/* (Un)register coroutines and channels with the debugging subsystem. */\nvoid mill_register_cr(struct mill_debug_cr *cr, const char *created);\nvoid mill_unregister_cr(struct mill_debug_cr *cr);\nvoid mill_register_chan(struct mill_debug_chan *ch, const char *created);\nvoid mill_unregister_chan(struct mill_debug_chan *ch);\n\n/* While doing a blocking operation coroutine should register where\n   the operation was invoked from. */\nvoid mill_set_current(struct mill_debug_cr *cr, const char *current);\n\nextern int mill_tracelevel;\n\n/* Create a trace record. */\n#define mill_trace if(mill_slow(mill_tracelevel)) mill_trace_\nvoid mill_trace_(const char *location, const char *format, ...);\n\n/* Returns 1 if there are any coroutines running, 0 otherwise. */\nint mill_hascrs(void);\n\n#endif\n"
        },
        {
          "name": "dns",
          "type": "tree",
          "content": null
        },
        {
          "name": "epoll.inc",
          "type": "blob",
          "size": 6.9404296875,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <stdint.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/resource.h>\n\n#include \"cr.h\"\n#include \"utils.h\"\n\n#define MILL_ENDLIST 0xffffffff\n\n#define MILL_EPOLLSETSIZE 128\n\n/* Global pollset. */\nstatic int mill_efd = -1;\n\n/* Epoll allows to register only a single pointer with a file decriptor.\n   However, we may need two pointers to coroutines. One for the coroutine\n   waiting to receive data from the descriptor, one for the coroutine waiting\n   to send data to the descriptor. Thus, we are going to keep an array of\n   pointer pairs for each file descriptor. */\nstruct mill_crpair {\n    struct mill_cr *in;\n    struct mill_cr *out;\n    uint32_t currevs;\n    /* 1-based index, 0 stands for \"not part of the list\", MILL_ENDLIST\n       stads for \"no more elements in the list. */\n    uint32_t next;\n};\n\nstatic struct mill_crpair *mill_crpairs = NULL;\nstatic int mill_ncrpairs = 0;\nstatic uint32_t mill_changelist = MILL_ENDLIST;\n\nvoid mill_poller_init(void) {\n    struct rlimit rlim;\n    int rc = getrlimit(RLIMIT_NOFILE, &rlim);\n    if(mill_slow(rc < 0)) return;\n    mill_ncrpairs = rlim.rlim_max;\n    mill_crpairs = (struct mill_crpair*)\n        calloc(mill_ncrpairs, sizeof(struct mill_crpair));\n    if(mill_slow(!mill_crpairs)) {errno = ENOMEM; return;}\n    mill_efd = epoll_create(1);\n    if(mill_slow(mill_efd < 0)) {\n        free(mill_crpairs);\n        mill_crpairs = NULL;\n        return;\n    }\n    errno = 0;\n}\n\nvoid mill_poller_postfork(void) {\n    if(mill_efd != -1) {\n        int rc = close(mill_efd);\n        mill_assert(rc == 0);\n    }\n    mill_efd = -1;\n    mill_crpairs = NULL;\n    mill_ncrpairs = 0;\n    mill_changelist = MILL_ENDLIST;\n    mill_poller_init();\n}\n\nstatic void mill_poller_add(int fd, int events) {\n    struct mill_crpair *crp = &mill_crpairs[fd];\n    if(events & FDW_IN) {\n        if(crp->in)\n            mill_panic(\n                \"multiple coroutines waiting for a single file descriptor\");\n        crp->in = mill_running;\n    }\n    if(events & FDW_OUT) {\n        if(crp->out)\n            mill_panic(\n                \"multiple coroutines waiting for a single file descriptor\");\n        crp->out = mill_running;\n    }\n    if(!crp->next) {\n        crp->next = mill_changelist;\n        mill_changelist = fd + 1;\n    }\n}\n\nstatic void mill_poller_rm(struct mill_cr *cr) {\n    int fd = cr->fd;\n    mill_assert(fd != -1);\n    struct mill_crpair *crp = &mill_crpairs[fd];\n    if(crp->in == cr) {\n        crp->in = NULL;\n        cr->fd = -1;\n    }\n    if(crp->out == cr) {\n        crp->out = NULL;\n        cr->fd = -1;\n    }\n    if(!crp->next) {\n        crp->next = mill_changelist;\n        mill_changelist = fd + 1;\n    }\n}\n\nstatic void mill_poller_clean(int fd) {\n    struct mill_crpair *crp = &mill_crpairs[fd];\n    mill_assert(!crp->in);\n    mill_assert(!crp->out);\n    /* Remove the file descriptor from the pollset, if it is still present. */\n    if(crp->currevs) {   \n        struct epoll_event ev;\n        ev.data.fd = fd;\n        ev.events = 0;\n        int rc = epoll_ctl(mill_efd, EPOLL_CTL_DEL, fd, &ev);\n        mill_assert(rc == 0 || errno == ENOENT);\n    }\n    /* Clean the cache. */\n    crp->currevs = 0;\n    if(!crp->next) {\n        crp->next = mill_changelist;\n        mill_changelist = fd + 1;\n    }\n}\n\nstatic int mill_poller_wait(int timeout) {\n    /* Apply any changes to the pollset.\n       TODO: Use epoll_ctl_batch once available. */\n    while(mill_changelist != MILL_ENDLIST) {\n        int fd = mill_changelist - 1;\n        struct mill_crpair *crp = &mill_crpairs[fd];\n        struct epoll_event ev;\n        ev.data.fd = fd;\n        ev.events = 0;\n        if(crp->in)\n            ev.events |= EPOLLIN;\n        if(crp->out)\n            ev.events |= EPOLLOUT;\n        if(crp->currevs != ev.events) {\n            int op;\n            if(!ev.events)\n                 op = EPOLL_CTL_DEL;\n            else if(!crp->currevs)\n                 op = EPOLL_CTL_ADD;\n            else\n                 op = EPOLL_CTL_MOD;\n            crp->currevs = ev.events;\n            int rc = epoll_ctl(mill_efd, op, fd, &ev);\n            mill_assert(rc == 0);\n        }\n        mill_changelist = crp->next;\n        crp->next = 0;\n    }\n    /* Wait for events. */\n    struct epoll_event evs[MILL_EPOLLSETSIZE];\n    int numevs;\n    while(1) {\n        numevs = epoll_wait(mill_efd, evs, MILL_EPOLLSETSIZE, timeout);\n        if(numevs < 0 && errno == EINTR)\n            continue;\n        mill_assert(numevs >= 0);\n        break;\n    }\n    /* Fire file descriptor events. */\n    int i;\n    for(i = 0; i != numevs; ++i) {\n        struct mill_crpair *crp = &mill_crpairs[evs[i].data.fd];\n        int inevents = 0;\n        int outevents = 0;\n        /* Set the result values. */\n        if(evs[i].events & EPOLLIN)\n            inevents |= FDW_IN;\n        if(evs[i].events & EPOLLOUT)\n            outevents |= FDW_OUT;\n        if(evs[i].events & (EPOLLERR | EPOLLHUP)) {\n            inevents |= FDW_ERR;\n            outevents |= FDW_ERR;\n        }\n        /* Resume the blocked coroutines. */  \n        if(crp->in == crp->out) {\n            struct mill_cr *cr = crp->in;\n            mill_resume(cr, inevents | outevents);\n            mill_poller_rm(cr);\n            if(mill_timer_enabled(&cr->timer))\n                mill_timer_rm(&cr->timer);\n        }\n        else {\n            if(crp->in && inevents) {\n                struct mill_cr *cr = crp->in;\n                mill_resume(cr, inevents);\n                mill_poller_rm(cr);\n                if(mill_timer_enabled(&cr->timer))\n                    mill_timer_rm(&cr->timer);\n            }\n            if(crp->out && outevents) {\n                struct mill_cr *cr = crp->out;\n                mill_resume(cr, outevents);\n                mill_poller_rm(cr);\n                if(mill_timer_enabled(&cr->timer))\n                    mill_timer_rm(&cr->timer);\n            }\n        }\n    }\n    /* Return 0 in case of time out. 1 if at least one coroutine was resumed. */\n    return numevs > 0 ? 1 : 0;\n}\n\n"
        },
        {
          "name": "file.c",
          "type": "blob",
          "size": 7.9140625,
          "content": "/*\n\n  Copyright (c) 2016 Paulo Faria\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"libmill.h\"\n#include \"utils.h\"\n\n#ifndef MILL_FILE_BUFLEN\n#define MILL_FILE_BUFLEN (4096)\n#endif\n\nstruct mill_file {\n    int fd;\n    size_t ifirst;\n    size_t ilen;\n    size_t olen;\n    char ibuf[MILL_FILE_BUFLEN];\n    char obuf[MILL_FILE_BUFLEN];\n};\n\nstatic void mill_filetune(int fd) {\n    /* Make the file descriptor non-blocking. */\n    int opt = fcntl(fd, F_GETFL, 0);\n    if (opt == -1)\n        opt = 0;\n    int rc = fcntl(fd, F_SETFL, opt | O_NONBLOCK);\n    mill_assert(rc != -1);\n}\n\n\nstruct mill_file *mill_mfopen_(const char *pathname, int flags, mode_t mode) {\n    /* Open the file. */\n    int fd = open(pathname, flags, mode);\n    if (fd == -1)\n        return NULL;\n    mill_filetune(fd);\n\n    /* Create the object. */\n    struct mill_file *f = malloc(sizeof(struct mill_file));\n    if(!f) {\n        fdclean(fd);\n        close(fd);\n        errno = ENOMEM;\n        return NULL;\n    }\n    f->fd = fd;\n    f->ifirst = 0;\n    f->ilen = 0;\n    f->olen = 0;\n    errno = 0;\n    return f;\n}\n\nsize_t mill_mfwrite_(struct mill_file *f, const void *buf, size_t len,\n      int64_t deadline) {\n    /* If it fits into the output buffer copy it there and be done. */\n    if(f->olen + len <= MILL_FILE_BUFLEN) {\n        memcpy(&f->obuf[f->olen], buf, len);\n        f->olen += len;\n        errno = 0;\n        return len;\n    }\n\n    /* If it doesn't fit, flush the output buffer first. */\n    mfflush(f, deadline);\n    if(errno != 0)\n        return 0;\n\n    /* Try to fit it into the buffer once again. */\n    if(f->olen + len <= MILL_FILE_BUFLEN) {\n        memcpy(&f->obuf[f->olen], buf, len);\n        f->olen += len;\n        errno = 0;\n        return len;\n    }\n\n    /* The data chunk to send is longer than the output buffer.\n     Let's do the writing in-place. */\n    char *pos = (char*)buf;\n    size_t remaining = len;\n    while(remaining) {\n        ssize_t sz = write(f->fd, pos, remaining);\n        if(sz == -1) {\n            if(errno != EAGAIN && errno != EWOULDBLOCK)\n                return 0;\n            int rc = fdwait(f->fd, FDW_OUT, deadline);\n            if(rc == 0) {\n                errno = ETIMEDOUT;\n                return len - remaining;\n            }\n            mill_assert(rc == FDW_OUT);\n            continue;\n        }\n        pos += sz;\n        remaining -= sz;\n    }\n    return len;\n}\n\nvoid mill_mfflush_(struct mill_file *f, int64_t deadline) {\n    if(!f->olen) {\n        errno = 0;\n        return;\n    }\n    char *pos = f->obuf;\n    size_t remaining = f->olen;\n    while(remaining) {\n        ssize_t sz = write(f->fd, pos, remaining);\n        if(sz == -1) {\n            if(errno != EAGAIN && errno != EWOULDBLOCK)\n                return;\n            int rc = fdwait(f->fd, FDW_OUT, deadline);\n            if(rc == 0) {\n                errno = ETIMEDOUT;\n                return;\n            }\n            mill_assert(rc == FDW_OUT);\n            continue;\n        }\n        pos += sz;\n        remaining -= sz;\n    }\n    f->olen = 0;\n    errno = 0;\n}\n\nsize_t mill_mfread_(struct mill_file *f, void *buf, size_t len,\n      int64_t deadline) {\n    /* If there's enough data in the buffer it's easy. */\n    if(f->ilen >= len) {\n        memcpy(buf, &f->ibuf[f->ifirst], len);\n        f->ifirst += len;\n        f->ilen -= len;\n        errno = 0;\n        return len;\n    }\n\n    /* Let's move all the data from the buffer first. */\n    char *pos = (char*)buf;\n    size_t remaining = len;\n    memcpy(pos, &f->ibuf[f->ifirst], f->ilen);\n    pos += f->ilen;\n    remaining -= f->ilen;\n    f->ifirst = 0;\n    f->ilen = 0;\n\n    mill_assert(remaining);\n    while(1) {\n        if(remaining > MILL_FILE_BUFLEN) {\n            /* If we still have a lot to read try to read it in one go directly\n             into the destination buffer. */\n            ssize_t sz = read(f->fd, pos, remaining);\n            if(!sz) {\n                return len - remaining;\n            }\n            if(sz == -1) {\n                if(errno != EAGAIN && errno != EWOULDBLOCK)\n                    return len - remaining;\n                sz = 0;\n            }\n            if((size_t)sz == remaining) {\n                errno = 0;\n                return len;\n            }\n            pos += sz;\n            remaining -= sz;\n            if (sz != 0 && mfeof(f)) {\n                return len - remaining;\n            }\n        }\n        else {\n            /* If we have just a little to read try to read the full connection\n             buffer to minimise the number of system calls. */\n            ssize_t sz = read(f->fd, f->ibuf, MILL_FILE_BUFLEN);\n            if(!sz) {\n                return len - remaining;\n            }\n            if(sz == -1) {\n                if(errno != EAGAIN && errno != EWOULDBLOCK)\n                    return len - remaining;\n                sz = 0;\n            }\n            if((size_t)sz < remaining) {\n                memcpy(pos, f->ibuf, sz);\n                pos += sz;\n                remaining -= sz;\n                f->ifirst = 0;\n                f->ilen = 0;\n            }\n            else {\n                memcpy(pos, f->ibuf, remaining);\n                f->ifirst = remaining;\n                f->ilen = sz - remaining;\n                errno = 0;\n                return len;\n            }\n            if (sz != 0 && mfeof(f)) {\n                return len - remaining;\n            }\n        }\n\n        /* Wait till there's more data to read. */\n        int res = fdwait(f->fd, FDW_IN, deadline);\n        if (!res) {\n            errno = ETIMEDOUT;\n            return len - remaining;\n        }\n    }\n}\n\nvoid mill_mfclose_(struct mill_file *f) {\n    fdclean(f->fd);\n    int rc = close(f->fd);\n    mill_assert(rc == 0);\n    free(f);\n    return;\n}\n\noff_t mill_mftell_(struct mill_file *f) {\n    return lseek(f->fd, 0, SEEK_CUR) - f->ilen;\n}\n\noff_t mill_mfseek_(struct mill_file *f, off_t offset) {\n    f->ifirst = 0;\n    f->ilen = 0;\n    f->olen = 0;\n    return lseek(f->fd, offset, SEEK_SET);\n}\n\nint mill_mfeof_(struct mill_file *f) {\n    off_t current = lseek(f->fd, 0, SEEK_CUR);\n    if (current == -1)\n        return -1;\n    off_t eof = lseek(f->fd, 0, SEEK_END);\n    if (eof == -1)\n        return -1;\n    off_t res = lseek(f->fd, current, SEEK_SET);\n    if (res == -1)\n        return -1;\n    return (current == eof);\n}\n\nstruct mill_file *mill_mfin_(void) {\n    static struct mill_file f = {-1, 0, 0, 0};\n    if(mill_slow(f.fd < 0)) {\n        mill_filetune(STDIN_FILENO);\n        f.fd = STDIN_FILENO;\n    }\n    return &f;\n}\n\nstruct mill_file *mill_mfout_(void) {\n    static struct mill_file f = {-1, 0, 0, 0};\n    if(mill_slow(f.fd < 0)) {\n        mill_filetune(STDOUT_FILENO);\n        f.fd = STDOUT_FILENO;\n    }\n    return &f;\n}\n\nstruct mill_file *mill_mferr_(void) {\n    static struct mill_file f = {-1, 0, 0, 0};\n    if(mill_slow(f.fd < 0)) {\n        mill_filetune(STDERR_FILENO);\n        f.fd = STDERR_FILENO;\n    }\n    return &f;\n}\n\n"
        },
        {
          "name": "ip.c",
          "type": "blob",
          "size": 10.6396484375,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#if defined __linux__\n#define _GNU_SOURCE\n#include <netdb.h>\n#include <sys/eventfd.h>\n#endif\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#if !defined __sun\n#include <ifaddrs.h>\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"dns/dns.h\"\n\n#include \"ip.h\"\n#include \"libmill.h\"\n#include \"utils.h\"\n\nMILL_CT_ASSERT(sizeof(ipaddr) >= sizeof(struct sockaddr_in));\nMILL_CT_ASSERT(sizeof(ipaddr) >= sizeof(struct sockaddr_in6));\n\nstatic struct dns_resolv_conf *mill_dns_conf = NULL;\nstatic struct dns_hosts *mill_dns_hosts = NULL;\nstatic struct dns_hints *mill_dns_hints = NULL;\n\nstatic ipaddr mill_ipany(int port, int mode)\n{\n    ipaddr addr;\n    if(mill_slow(port < 0 || port > 0xffff)) {\n        ((struct sockaddr*)&addr)->sa_family = AF_UNSPEC;\n        errno = EINVAL;\n        return addr;\n    }\n    if (mode == 0 || mode == IPADDR_IPV4 || mode == IPADDR_PREF_IPV4) {\n        struct sockaddr_in *ipv4 = (struct sockaddr_in*)&addr;\n        ipv4->sin_family = AF_INET;\n        ipv4->sin_addr.s_addr = htonl(INADDR_ANY);\n        ipv4->sin_port = htons((uint16_t)port);\n    }\n    else {\n        struct sockaddr_in6 *ipv6 = (struct sockaddr_in6*)&addr;\n        ipv6->sin6_family = AF_INET6;\n        memcpy(&ipv6->sin6_addr, &in6addr_any, sizeof(in6addr_any));\n        ipv6->sin6_port = htons((uint16_t)port);\n    }\n    errno = 0;\n    return addr;\n}\n\n/* Convert literal IPv4 address to a binary one. */\nstatic ipaddr mill_ipv4_literal(const char *addr, int port) {\n    ipaddr raddr;\n    struct sockaddr_in *ipv4 = (struct sockaddr_in*)&raddr;\n    int rc = inet_pton(AF_INET, addr, &ipv4->sin_addr);\n    mill_assert(rc >= 0);\n    if(rc == 1) {\n        ipv4->sin_family = AF_INET;\n        ipv4->sin_port = htons((uint16_t)port);\n        errno = 0;\n        return raddr;\n    }\n    ipv4->sin_family = AF_UNSPEC;\n    errno = EINVAL;\n    return raddr;\n}\n\n/* Convert literal IPv6 address to a binary one. */\nstatic ipaddr mill_ipv6_literal(const char *addr, int port) {\n    ipaddr raddr;\n    struct sockaddr_in6 *ipv6 = (struct sockaddr_in6*)&raddr;\n    int rc = inet_pton(AF_INET6, addr, &ipv6->sin6_addr);\n    mill_assert(rc >= 0);\n    if(rc == 1) {\n        ipv6->sin6_family = AF_INET6;\n        ipv6->sin6_port = htons((uint16_t)port);\n        errno = 0;\n        return raddr;\n    }\n    ipv6->sin6_family = AF_UNSPEC;\n    errno = EINVAL;\n    return raddr;\n}\n\n/* Convert literal IPv4 or IPv6 address to a binary one. */\nstatic ipaddr mill_ipliteral(const char *addr, int port, int mode) {\n    ipaddr raddr;\n    struct sockaddr *sa = (struct sockaddr*)&raddr;\n    if(mill_slow(!addr || port < 0 || port > 0xffff)) {\n        sa->sa_family = AF_UNSPEC;\n        errno = EINVAL;\n        return raddr;\n    }\n    switch(mode) {\n    case IPADDR_IPV4:\n        return mill_ipv4_literal(addr, port);\n    case IPADDR_IPV6:\n        return mill_ipv6_literal(addr, port);\n    case 0:\n    case IPADDR_PREF_IPV4:\n        raddr = mill_ipv4_literal(addr, port);\n        if(errno == 0)\n            return raddr;\n        return mill_ipv6_literal(addr, port);\n    case IPADDR_PREF_IPV6:\n        raddr = mill_ipv6_literal(addr, port);\n        if(errno == 0)\n            return raddr;\n        return mill_ipv4_literal(addr, port);\n    default:\n        mill_assert(0);\n    }\n}\n\nint mill_ipfamily(ipaddr addr) {\n    return ((struct sockaddr*)&addr)->sa_family;\n}\n\nint mill_iplen(ipaddr addr) {\n    return mill_ipfamily(addr) == AF_INET ?\n        sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);\n}\n\nint mill_ipport(ipaddr addr) {\n    return ntohs(mill_ipfamily(addr) == AF_INET ?\n        ((struct sockaddr_in*)&addr)->sin_port :\n        ((struct sockaddr_in6*)&addr)->sin6_port);\n}\n\n/* Convert IP address from network format to ASCII dot notation. */\nconst char *mill_ipaddrstr_(ipaddr addr, char *ipstr) {\n    if (mill_ipfamily(addr) == AF_INET) {\n        return inet_ntop(AF_INET, &(((struct sockaddr_in*)&addr)->sin_addr),\n            ipstr, INET_ADDRSTRLEN);\n    }\n    else {\n        return inet_ntop(AF_INET6, &(((struct sockaddr_in6*)&addr)->sin6_addr),\n            ipstr, INET6_ADDRSTRLEN);\n    }\n}\n\nipaddr mill_iplocal_(const char *name, int port, int mode) {\n    if(!name)\n        return mill_ipany(port, mode);\n    ipaddr addr = mill_ipliteral(name, port, mode);\n#if defined __sun\n    return addr;\n#else\n    if(errno == 0)\n       return addr;\n    /* Address is not a literal. It must be an interface name then. */\n    struct ifaddrs *ifaces = NULL;\n    int rc = getifaddrs (&ifaces);\n    mill_assert (rc == 0);\n    mill_assert (ifaces);\n    /*  Find first IPv4 and first IPv6 address. */\n    struct ifaddrs *ipv4 = NULL;\n    struct ifaddrs *ipv6 = NULL;\n    struct ifaddrs *it;\n    for(it = ifaces; it != NULL; it = it->ifa_next) {\n        if(!it->ifa_addr)\n            continue;\n        if(strcmp(it->ifa_name, name) != 0)\n            continue;\n        switch(it->ifa_addr->sa_family) {\n        case AF_INET:\n            mill_assert(!ipv4);\n            ipv4 = it;\n            break;\n        case AF_INET6:\n            mill_assert(!ipv6);\n            ipv6 = it;\n            break;\n        }\n        if(ipv4 && ipv6)\n            break;\n    }\n    /* Choose the correct address family based on mode. */\n    switch(mode) {\n    case IPADDR_IPV4:\n        ipv6 = NULL;\n        break;\n    case IPADDR_IPV6:\n        ipv4 = NULL;\n        break;\n    case 0:\n    case IPADDR_PREF_IPV4:\n        if(ipv4)\n           ipv6 = NULL;\n        break;\n    case IPADDR_PREF_IPV6:\n        if(ipv6)\n           ipv4 = NULL;\n        break;\n    default:\n        mill_assert(0);\n    }\n    if(ipv4) {\n        struct sockaddr_in *inaddr = (struct sockaddr_in*)&addr;\n        memcpy(inaddr, ipv4->ifa_addr, sizeof (struct sockaddr_in));\n        inaddr->sin_port = htons(port);\n        freeifaddrs(ifaces);\n        errno = 0;\n        return addr;\n    }\n    if(ipv6) {\n        struct sockaddr_in6 *inaddr = (struct sockaddr_in6*)&addr;\n        memcpy(inaddr, ipv6->ifa_addr, sizeof (struct sockaddr_in6));\n        inaddr->sin6_port = htons(port);\n        freeifaddrs(ifaces);\n        errno = 0;\n        return addr;\n    }\n    freeifaddrs(ifaces);\n    ((struct sockaddr*)&addr)->sa_family = AF_UNSPEC;\n    errno = ENODEV;\n    return addr;\n#endif\n}\n\nipaddr mill_ipremote_(const char *name, int port, int mode, int64_t deadline) {\n    int rc;\n    ipaddr addr = mill_ipliteral(name, port, mode);\n    if(errno == 0)\n       return addr;\n    /* Load DNS config files, unless they are already chached. */\n    if(mill_slow(!mill_dns_conf)) {\n        /* TODO: Maybe re-read the configuration once in a while? */\n        mill_dns_conf = dns_resconf_local(&rc);\n        mill_assert(mill_dns_conf);\n        mill_dns_hosts = dns_hosts_local(&rc);\n        mill_assert(mill_dns_hosts);\n        mill_dns_hints = dns_hints_local(mill_dns_conf, &rc);\n        mill_assert(mill_dns_hints);\n    }\n    /* Let's do asynchronous DNS query here. */\n    struct dns_resolver *resolver = dns_res_open(mill_dns_conf, mill_dns_hosts,\n        mill_dns_hints, NULL, dns_opts(), &rc);\n    mill_assert(resolver);\n    mill_assert(port >= 0 && port <= 0xffff);\n    char portstr[8];\n    snprintf(portstr, sizeof(portstr), \"%d\", port);\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = PF_UNSPEC;\n    struct dns_addrinfo *ai = dns_ai_open(name, portstr, DNS_T_A, &hints,\n        resolver, &rc);\n    mill_assert(ai);\n    dns_res_close(resolver);\n    struct addrinfo *ipv4 = NULL;\n    struct addrinfo *ipv6 = NULL;\n    struct addrinfo *it = NULL;\n    while(1) {\n        rc = dns_ai_nextent(&it, ai);\n        if(rc == EAGAIN) {\n            int fd = dns_ai_pollfd(ai);\n            mill_assert(fd >= 0);\n            int events = fdwait(fd, FDW_IN, deadline);\n            /* There's no guarantee that the file descriptor will be reused\n               in next iteration. We have to clean the fdwait cache here\n               to be on the safe side. */\n            fdclean(fd);\n            if(mill_slow(!events)) {\n                errno = ETIMEDOUT;\n                return addr;\n            }\n            mill_assert(events == FDW_IN);\n            continue;\n        }\n        if(rc == ENOENT)\n            break;\n\n        if(!ipv4 && it && it->ai_family == AF_INET) {\n            ipv4 = it;\n        }\n        else if(!ipv6 && it && it->ai_family == AF_INET6) {\n            ipv6 = it;\n        }\n        else {\n            free(it);\n        }\n        \n        if(ipv4 && ipv6)\n            break;\n    }\n    switch(mode) {\n    case IPADDR_IPV4:\n        if(ipv6) {\n            free(ipv6);\n            ipv6 = NULL;\n        }\n        break;\n    case IPADDR_IPV6:\n        if(ipv4) {\n            free(ipv4);\n            ipv4 = NULL;\n        }\n        break;\n    case 0:\n    case IPADDR_PREF_IPV4:\n        if(ipv4 && ipv6) {\n            free(ipv6);\n            ipv6 = NULL;\n        }\n        break;\n    case IPADDR_PREF_IPV6:\n        if(ipv6 && ipv4) {\n            free(ipv4);\n            ipv4 = NULL;\n        }\n        break;\n    default:\n        mill_assert(0);\n    }\n    if(ipv4) {\n        struct sockaddr_in *inaddr = (struct sockaddr_in*)&addr;\n        memcpy(inaddr, ipv4->ai_addr, sizeof (struct sockaddr_in));\n        inaddr->sin_port = htons(port);\n        dns_ai_close(ai);\n        free(ipv4);\n        errno = 0;\n        return addr;\n    }\n    if(ipv6) {\n        struct sockaddr_in6 *inaddr = (struct sockaddr_in6*)&addr;\n        memcpy(inaddr, ipv6->ai_addr, sizeof (struct sockaddr_in6));\n        inaddr->sin6_port = htons(port);\n        dns_ai_close(ai);\n        free(ipv6);\n        errno = 0;\n        return addr;\n    }\n    dns_ai_close(ai);\n    ((struct sockaddr*)&addr)->sa_family = AF_UNSPEC;\n    errno = EADDRNOTAVAIL;\n    return addr;\n}\n\n"
        },
        {
          "name": "ip.h",
          "type": "blob",
          "size": 1.2421875,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_IP_INCLUDED\n#define MILL_IP_INCLUDED\n\n#include \"libmill.h\"\n\nint mill_ipfamily(ipaddr addr);\nint mill_iplen(ipaddr addr);\nint mill_ipport(ipaddr addr);\n\n#endif\n\n"
        },
        {
          "name": "kqueue.inc",
          "type": "blob",
          "size": 8.744140625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/event.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n\n#include \"cr.h\"\n#include \"utils.h\"\n\n#define MILL_ENDLIST 0xffffffff\n\n#define MILL_CHNGSSIZE 128\n#define MILL_EVSSIZE 128\n\nstatic int mill_kfd = -1;\n\nstruct mill_crpair {\n    struct mill_cr *in;\n    struct mill_cr *out;\n    uint16_t currevs;\n    uint16_t firing;\n    /* 1-based index, 0 stands for \"not part of the list\", MILL_ENDLIST\n       stads for \"no more elements in the list. */\n    uint32_t next;\n};\n\nstatic struct mill_crpair *mill_crpairs = NULL;\nstatic int mill_ncrpairs = 0;\nstatic uint32_t mill_changelist = MILL_ENDLIST;\n\nvoid mill_poller_init(void) {\n    struct rlimit rlim;\n    int rc = getrlimit(RLIMIT_NOFILE, &rlim);\n    if(mill_slow(rc < 0)) return;\n    mill_ncrpairs = rlim.rlim_max;\n    /* The above behaves weirdly on newer versions of OSX, ruturning limit\n       of -1. Fix it by using OPEN_MAX instead. */\n    if(mill_ncrpairs < 0)\n        mill_ncrpairs = OPEN_MAX;\n    mill_crpairs = (struct mill_crpair*)\n        calloc(mill_ncrpairs, sizeof(struct mill_crpair));\n    if(mill_slow(!mill_crpairs)) {errno = ENOMEM; return;}\n    mill_kfd = kqueue();\n    if(mill_slow(mill_kfd < 0)) {\n        free(mill_crpairs);\n        mill_crpairs = NULL;\n        return;\n    }\n    errno = 0;\n}\n\nvoid mill_poller_postfork(void) {\n    if(mill_kfd != -1) {\n        /* TODO: kqueue documentation says that a kqueue descriptor won't\n           survive a fork. However, implementations seem to diverge.\n           On FreeBSD the following function succeeds. On OSX it returns\n           EACCESS. Therefore we ignore the return value. */\n        close(mill_kfd);\n    }\n    mill_kfd = -1;\n    mill_crpairs = NULL;\n    mill_ncrpairs = 0;\n    mill_changelist = MILL_ENDLIST;\n    mill_poller_init();\n}\n\nstatic void mill_poller_add(int fd, int events) {\n    struct mill_crpair *crp = &mill_crpairs[fd];\n    if(events & FDW_IN) {\n        if(crp->in)\n            mill_panic(\n                \"multiple coroutines waiting for a single file descriptor\");\n        crp->in = mill_running;\n    }\n    if(events & FDW_OUT) {\n        if(crp->out)\n            mill_panic(\n                \"multiple coroutines waiting for a single file descriptor\");\n        crp->out = mill_running;\n    }\n    if(!crp->next) {\n        crp->next = mill_changelist;\n        mill_changelist = fd + 1;\n    }\n}\n\nstatic void mill_poller_rm(struct mill_cr *cr) {\n    int fd = cr->fd;\n    mill_assert(fd != -1);\n    struct mill_crpair *crp = &mill_crpairs[fd];\n    if(crp->in == cr) {\n        crp->in = NULL;\n        cr->fd = -1;\n    }\n    if(crp->out == cr) {\n        crp->out = NULL;\n        cr->fd = -1;\n    }\n    if(!crp->next) {\n        crp->next = mill_changelist;\n        mill_changelist = fd + 1;\n    }\n}\n\nstatic void mill_poller_clean(int fd) {\n    struct mill_crpair *crp = &mill_crpairs[fd];\n    mill_assert(!crp->in);\n    mill_assert(!crp->out);\n    /* Remove the file descriptor from the pollset, if it is still there. */\n    int nevs = 0;\n    struct kevent evs[2];\n    if(crp->currevs & FDW_IN) {\n        EV_SET(&evs[nevs], fd, EVFILT_READ, EV_DELETE, 0, 0, 0);\n        ++nevs;\n    }\n    if(crp->currevs & FDW_OUT) {\n        EV_SET(&evs[nevs], fd, EVFILT_WRITE, EV_DELETE, 0, 0, 0);\n        ++nevs;\n    }\n    if(nevs) {\n        int rc = kevent(mill_kfd, evs, nevs, NULL, 0, NULL);\n        mill_assert(rc != -1);\n    }\n    /* Clean up the cache. */\n    crp->currevs = 0;\n    if(!crp->next) {\n        crp->next = mill_changelist;\n        mill_changelist = fd + 1;\n    }\n}\n\nstatic int mill_poller_wait(int timeout) {\n    /* Apply any changes to the pollset. */\n    struct kevent chngs[MILL_CHNGSSIZE];\n    int nchngs = 0;\n    while(mill_changelist != MILL_ENDLIST) {\n        /* Flush the changes to the pollset even if there is one emtpy entry\n           left in the changeset. That way we make sure that both in & out\n           associated with the next file descriptor can be filled in if we\n           choose not to flush the changes yet. */\n        if(nchngs >= MILL_CHNGSSIZE - 1) {\n            int rc = kevent(mill_kfd, chngs, nchngs, NULL, 0, NULL);\n            mill_assert(rc != -1);\n            nchngs = 0;\n        }\n        int fd = mill_changelist - 1;\n        struct mill_crpair *crp = &mill_crpairs[fd];\n        if(crp->in) {\n            if(!(crp->currevs & FDW_IN)) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_READ, EV_ADD, 0, 0, 0);\n                crp->currevs |= FDW_IN;\n                ++nchngs;\n            }\n        }\n        else {\n            if(crp->currevs & FDW_IN) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_READ, EV_DELETE, 0, 0, 0);\n                crp->currevs &= ~FDW_IN;\n                ++nchngs;\n            }\n        }\n        if(crp->out) {\n            if(!(crp->currevs & FDW_OUT)) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_WRITE, EV_ADD, 0, 0, 0);\n                crp->currevs |= FDW_OUT;\n                ++nchngs;\n           }\n        }\n        else {\n            if(crp->currevs & FDW_OUT) {\n                EV_SET(&chngs[nchngs], fd, EVFILT_WRITE, EV_DELETE, 0, 0, 0);\n                crp->currevs &= ~FDW_OUT;\n                ++nchngs;\n            }\n        }\n        crp->firing = 0;\n        mill_changelist = crp->next;\n        crp->next = 0;\n    }\n    /* Wait for events. */\n    struct kevent evs[MILL_EVSSIZE];\n    int nevs;\n    while(1) {\n        struct timespec ts;\n        if(timeout >= 0) {\n            ts.tv_sec = timeout / 1000;\n            ts.tv_nsec = (((long)timeout) % 1000) * 1000000;\n        }\n        nevs = kevent(mill_kfd, chngs, nchngs, evs, MILL_EVSSIZE,\n            timeout < 0 ? NULL : &ts);\n        if(nevs < 0 && errno == EINTR)\n            continue;\n        mill_assert(nevs >= 0);\n        break;\n    }\n    /* Join events on file descriptor basis. */\n    int i;\n    for(i = 0; i != nevs; ++i) {\n        mill_assert(evs[i].flags != EV_ERROR);\n        int fd = (int)evs[i].ident;\n        struct mill_crpair *crp = &mill_crpairs[fd];\n        /* Add firing event to the result list. */\n        if(evs[i].flags == EV_EOF)\n            crp->firing |= FDW_ERR;\n        else {\n            if(evs[i].filter == EVFILT_READ)\n                crp->firing |= FDW_IN;\n            if(evs[i].filter == EVFILT_WRITE)\n                crp->firing |= FDW_OUT;\n        }\n        if(!crp->next) {\n            crp->next = mill_changelist;\n            mill_changelist = fd + 1;\n        }\n    }\n    /* Resume the blocked coroutines. */\n    uint32_t chl = mill_changelist;\n    while(chl != MILL_ENDLIST) {\n        int fd = chl - 1;\n        struct mill_crpair *crp = &mill_crpairs[fd];\n        if(crp->in == crp->out) {\n            struct mill_cr *cr = crp->in;\n            mill_assert(crp->in);\n            mill_resume(cr, crp->firing);\n            cr->fd = -1;\n            crp->in = NULL;\n            crp->out = NULL;\n            if(mill_timer_enabled(&cr->timer))\n                mill_timer_rm(&cr->timer);\n        }\n        else {\n            if(crp->in) {\n                struct mill_cr *cr = crp->in;\n                mill_resume(cr, crp->firing & (FDW_IN | FDW_ERR));\n                cr->fd = -1;\n                crp->in = NULL;\n                if(mill_timer_enabled(&cr->timer))\n                    mill_timer_rm(&cr->timer);\n            }\n            if(crp->out) {\n                struct mill_cr *cr = crp->out;\n                mill_resume(cr, crp->firing & (FDW_OUT | FDW_ERR));\n                cr->fd = -1;\n                crp->out = NULL;\n                if(mill_timer_enabled(&cr->timer))\n                    mill_timer_rm(&cr->timer);\n            }\n        }\n        crp->firing = 0;\n        chl = crp->next;\n    }    \n    /* Return 0 in case of time out. 1 if at least one coroutine was resumed. */\n    return nevs > 0 ? 1 : 0;\n}\n\n"
        },
        {
          "name": "libmill.h",
          "type": "blob",
          "size": 25.2666015625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef LIBMILL_H_INCLUDED\n#define LIBMILL_H_INCLUDED\n\n#include <errno.h>\n#include <setjmp.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/******************************************************************************/\n/*  ABI versioning support                                                    */\n/******************************************************************************/\n\n/*  Don't change this unless you know exactly what you're doing and have      */\n/*  read and understand the following documents:                              */\n/*  www.gnu.org/software/libtool/manual/html_node/Libtool-versioning.html     */\n/*  www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html  */\n\n/*  The current interface version. */\n#define MILL_VERSION_CURRENT 19\n\n/*  The latest revision of the current interface. */\n#define MILL_VERSION_REVISION 1\n\n/*  How many past interface versions are still supported. */\n#define MILL_VERSION_AGE 1\n\n/******************************************************************************/\n/*  Symbol visibility                                                         */\n/******************************************************************************/\n\n#if !defined __GNUC__ && !defined __clang__\n#error \"Unsupported compiler!\"\n#endif\n\n#if defined MILL_NO_EXPORTS\n#   define MILL_EXPORT\n#else\n#   if defined _WIN32\n#      if defined MILL_EXPORTS\n#          define MILL_EXPORT __declspec(dllexport)\n#      else\n#          define MILL_EXPORT __declspec(dllimport)\n#      endif\n#   else\n#      if defined __SUNPRO_C\n#          define MILL_EXPORT __global\n#      elif (defined __GNUC__ && __GNUC__ >= 4) || \\\n             defined __INTEL_COMPILER || defined __clang__\n#          define MILL_EXPORT __attribute__ ((visibility(\"default\")))\n#      else\n#          define MILL_EXPORT\n#      endif\n#   endif\n#endif\n\n/******************************************************************************/\n/*  Helpers                                                                   */\n/******************************************************************************/\n\n#define mill_string2_(x) #x\n#define mill_string1_(x) mill_string2_(x)\n#define MILL_HERE_ (__FILE__ \":\" mill_string1_(__LINE__))\n\n#define mill_concat_(x,y) x##y\n\nMILL_EXPORT int64_t mill_now_(\n    void);\nMILL_EXPORT pid_t mill_mfork_(\n    void);\n\n#if defined MILL_USE_PREFIX\n#define mill_now mill_now_\n#define mill_mfork mill_mfork_\n#else\n#define now mill_now_\n#define mfork mill_mfork_\n#endif\n\n/******************************************************************************/\n/*  Coroutines                                                                */\n/******************************************************************************/\n\n#define MILL_FDW_IN_ 1\n#define MILL_FDW_OUT_ 2\n#define MILL_FDW_ERR_ 4\n\nMILL_EXPORT extern volatile int mill_unoptimisable1_;\nMILL_EXPORT extern volatile void *mill_unoptimisable2_;\n\n#if defined __x86_64__\ntypedef uint64_t *mill_ctx;\n#else\ntypedef sigjmp_buf *mill_ctx;\n#endif\n\nMILL_EXPORT mill_ctx mill_getctx_(\n    void);\nMILL_EXPORT __attribute__((noinline)) void *mill_prologue_(\n    const char *created);\nMILL_EXPORT __attribute__((noinline)) void mill_epilogue_(\n    void);\n\nMILL_EXPORT void mill_goprepare_(\n    int count,\n    size_t stack_size,\n    size_t val_size);\nMILL_EXPORT void mill_yield_(\n    const char *current);\nMILL_EXPORT void mill_msleep_(\n    int64_t deadline,\n    const char *current);\nMILL_EXPORT int mill_fdwait_(\n    int fd,\n    int events,\n    int64_t deadline,\n    const char *current);\nMILL_EXPORT void mill_fdclean_(\n    int fd);\nMILL_EXPORT void *mill_cls_(\n    void);\nMILL_EXPORT void mill_setcls_(\n    void *val);\n\n\n#if defined(__x86_64__)\n#if defined(__AVX__)\n#define MILL_CLOBBER \\\n        , \"ymm0\", \"ymm1\", \"ymm2\", \"ymm3\", \"ymm4\", \"ymm5\", \"ymm6\", \"ymm7\",\\\n        \"ymm8\", \"ymm9\", \"ymm10\", \"ymm11\", \"ymm12\", \"ymm13\", \"ymm14\", \"ymm15\"\n#else\n#define MILL_CLOBBER\n#endif\n#define mill_setjmp_(ctx) ({\\\n    int ret;\\\n    asm(\"lea     LJMPRET%=(%%rip), %%rcx\\n\\t\"\\\n        \"xor     %%rax, %%rax\\n\\t\"\\\n        \"mov     %%rbx, (%%rdx)\\n\\t\"\\\n        \"mov     %%rbp, 8(%%rdx)\\n\\t\"\\\n        \"mov     %%r12, 16(%%rdx)\\n\\t\"\\\n        \"mov     %%rsp, 24(%%rdx)\\n\\t\"\\\n        \"mov     %%r13, 32(%%rdx)\\n\\t\"\\\n        \"mov     %%r14, 40(%%rdx)\\n\\t\"\\\n        \"mov     %%r15, 48(%%rdx)\\n\\t\"\\\n        \"mov     %%rcx, 56(%%rdx)\\n\\t\"\\\n        \"mov     %%rdi, 64(%%rdx)\\n\\t\"\\\n        \"mov     %%rsi, 72(%%rdx)\\n\\t\"\\\n        \"LJMPRET%=:\\n\\t\"\\\n        : \"=a\" (ret)\\\n        : \"d\" (ctx)\\\n        : \"memory\", \"rcx\", \"r8\", \"r9\", \"r10\", \"r11\",\\\n          \"xmm0\", \"xmm1\", \"xmm2\", \"xmm3\", \"xmm4\", \"xmm5\", \"xmm6\", \"xmm7\",\\\n          \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\", \"xmm12\", \"xmm13\", \"xmm14\", \"xmm15\"\\\n          MILL_CLOBBER\\\n          );\\\n    ret;\\\n})\n#define mill_longjmp_(ctx) \\\n    asm(\"movq   (%%rax), %%rbx\\n\\t\"\\\n\t    \"movq   8(%%rax), %%rbp\\n\\t\"\\\n\t    \"movq   16(%%rax), %%r12\\n\\t\"\\\n\t    \"movq   24(%%rax), %%rdx\\n\\t\"\\\n\t    \"movq   32(%%rax), %%r13\\n\\t\"\\\n\t    \"movq   40(%%rax), %%r14\\n\\t\"\\\n\t    \"mov    %%rdx, %%rsp\\n\\t\"\\\n\t    \"movq   48(%%rax), %%r15\\n\\t\"\\\n\t    \"movq   56(%%rax), %%rdx\\n\\t\"\\\n\t    \"movq   64(%%rax), %%rdi\\n\\t\"\\\n\t    \"movq   72(%%rax), %%rsi\\n\\t\"\\\n\t    \"jmp    *%%rdx\\n\\t\"\\\n        : : \"a\" (ctx) : \"rdx\" \\\n    )\n#else\n#define mill_setjmp_(ctx) \\\n    sigsetjmp(*ctx, 0)\n#define mill_longjmp_(ctx) \\\n    siglongjmp(*ctx, 1)\n#endif\n\n#define mill_go_(fn) \\\n    do {\\\n        void *mill_sp;\\\n        mill_ctx ctx = mill_getctx_();\\\n        if(!mill_setjmp_(ctx)) {\\\n            mill_sp = mill_prologue_(MILL_HERE_);\\\n            int mill_anchor[mill_unoptimisable1_];\\\n            mill_unoptimisable2_ = &mill_anchor;\\\n            char mill_filler[(char*)&mill_anchor - (char*)(mill_sp)];\\\n            mill_unoptimisable2_ = &mill_filler;\\\n            fn;\\\n            mill_epilogue_();\\\n        }\\\n    } while(0)\n\n#if defined MILL_USE_PREFIX\n#define MILL_FDW_IN MILL_FDW_IN_\n#define MILL_FDW_OUT MILL_FDW_OUT_\n#define MILL_FDW_ERR MILL_FDW_ERR_\n#define mill_coroutine __attribute__((noinline))\n#define mill_go(fn) mill_go_(fn)\n#define mill_goprepare mill_goprepare_\n#define mill_yield() mill_yield_(MILL_HERE_)\n#define mill_msleep(dd) mill_msleep_((dd), MILL_HERE_)\n#define mill_fdwait(fd, ev, dd) mill_fdwait_((fd), (ev), (dd), MILL_HERE_)\n#define mill_fdclean mill_fdclean_\n#define mill_cls mill_cls_\n#define mill_setcls mill_setcls_\n#else\n#define FDW_IN MILL_FDW_IN_\n#define FDW_OUT MILL_FDW_OUT_\n#define FDW_ERR MILL_FDW_ERR_\n#define coroutine __attribute__((noinline))\n#define go(fn) mill_go_(fn)\n#define goprepare mill_goprepare_\n#define yield() mill_yield_(MILL_HERE_)\n#define msleep(deadline) mill_msleep_((deadline), MILL_HERE_)\n#define fdwait(fd, ev, dd) mill_fdwait_((fd), (ev), (dd), MILL_HERE_)\n#define fdclean mill_fdclean_\n#define cls mill_cls_\n#define setcls mill_setcls_\n#endif\n\n/******************************************************************************/\n/*  Channels                                                                  */\n/******************************************************************************/\n\nstruct mill_chan_;\n\ntypedef struct{void *f1; void *f2; void *f3; void *f4;\n    void *f5; void *f6; int f7; int f8; int f9;} mill_clause_;\n#define MILL_CLAUSELEN_ (sizeof(mill_clause_))\n\nMILL_EXPORT struct mill_chan_ *mill_chmake_(\n    size_t sz,\n    size_t bufsz,\n    const char *created);\nMILL_EXPORT struct mill_chan_ *mill_chdup_(\n    struct mill_chan_ *ch,\n    const char *created);\nMILL_EXPORT void mill_chclose_(\n    struct mill_chan_ *ch,\n    const char *current);\nMILL_EXPORT void mill_chs_(\n    struct mill_chan_ *ch,\n    void *val,\n    size_t sz,\n    const char *current);\nMILL_EXPORT void *mill_chr_(\n    struct mill_chan_ *ch,\n    size_t sz,\n    const char *current);\nMILL_EXPORT void mill_chdone_(\n    struct mill_chan_ *ch,\n    void *val,\n    size_t sz,\n    const char *current);\nMILL_EXPORT void mill_choose_init_(\n    const char *current);\nMILL_EXPORT void mill_choose_in_(\n    void *clause,\n    struct mill_chan_ *ch,\n    size_t sz,\n    int idx);\nMILL_EXPORT void mill_choose_out_(\n    void *clause,\n    struct mill_chan_ *ch,\n    void *val,\n    size_t sz,\n    int idx);\nMILL_EXPORT void mill_choose_deadline_(\n    int64_t deadline);\nMILL_EXPORT void mill_choose_otherwise_(\n    void);\nMILL_EXPORT int mill_choose_wait_(\n    void);\nMILL_EXPORT void *mill_choose_val_(\n    size_t sz);\n\n#define mill_chs__(channel, type, value) \\\n    do {\\\n        type mill_val = (value);\\\n        mill_chs_((channel), &mill_val, sizeof(type), MILL_HERE_);\\\n    } while(0)\n\n#define mill_chr__(channel, type) \\\n    (*(type*)mill_chr_((channel), sizeof(type), MILL_HERE_))\n\n#define mill_chdone__(channel, type, value) \\\n    do {\\\n        type mill_val = (value);\\\n        mill_chdone_((channel), &mill_val, sizeof(type), MILL_HERE_);\\\n    } while(0)\n\n#define mill_choose_init__ \\\n    {\\\n        mill_choose_init_(MILL_HERE_);\\\n        int mill_idx = -2;\\\n        while(1) {\\\n            if(mill_idx != -2) {\\\n                if(0)\n\n#define mill_choose_in__(chan, type, name, idx) \\\n                    break;\\\n                }\\\n                goto mill_concat_(mill_label, idx);\\\n            }\\\n            char mill_concat_(mill_clause, idx)[MILL_CLAUSELEN_];\\\n            mill_choose_in_(\\\n                &mill_concat_(mill_clause, idx)[0],\\\n                (chan),\\\n                sizeof(type),\\\n                idx);\\\n            if(0) {\\\n                type name;\\\n                mill_concat_(mill_label, idx):\\\n                if(mill_idx == idx) {\\\n                    name = *(type*)mill_choose_val_(sizeof(type));\\\n                    goto mill_concat_(mill_dummylabel, idx);\\\n                    mill_concat_(mill_dummylabel, idx)\n\n#define mill_choose_out__(chan, type, val, idx) \\\n                    break;\\\n                }\\\n                goto mill_concat_(mill_label, idx);\\\n            }\\\n            char mill_concat_(mill_clause, idx)[MILL_CLAUSELEN_];\\\n            type mill_concat_(mill_val, idx) = (val);\\\n            mill_choose_out_(\\\n                &mill_concat_(mill_clause, idx)[0],\\\n                (chan),\\\n                &mill_concat_(mill_val, idx),\\\n                sizeof(type),\\\n                idx);\\\n            if(0) {\\\n                mill_concat_(mill_label, idx):\\\n                if(mill_idx == idx) {\\\n                    goto mill_concat_(mill_dummylabel, idx);\\\n                    mill_concat_(mill_dummylabel, idx)\n\n#define mill_choose_deadline__(ddline, idx) \\\n                    break;\\\n                }\\\n                goto mill_concat_(mill_label, idx);\\\n            }\\\n            mill_choose_deadline_(ddline);\\\n            if(0) {\\\n                mill_concat_(mill_label, idx):\\\n                if(mill_idx == -1) {\\\n                    goto mill_concat_(mill_dummylabel, idx);\\\n                    mill_concat_(mill_dummylabel, idx)\n\n#define mill_choose_otherwise__(idx) \\\n                    break;\\\n                }\\\n                goto mill_concat_(mill_label, idx);\\\n            }\\\n            mill_choose_otherwise_();\\\n            if(0) {\\\n                mill_concat_(mill_label, idx):\\\n                if(mill_idx == -1) {\\\n                    goto mill_concat_(mill_dummylabel, idx);\\\n                    mill_concat_(mill_dummylabel, idx)\n\n#define mill_choose_end__ \\\n                    break;\\\n                }\\\n            }\\\n            mill_idx = mill_choose_wait_();\\\n        }\n\n#if defined MILL_USE_PREFIX\ntypedef struct mill_chan_ *mill_chan;\n#define mill_chmake(tp, sz) mill_chmake_(sizeof(tp), sz, MILL_HERE_)\n#define mill_chdup(ch) mill_chdup_((ch), MILL_HERE_)\n#define mill_chclose(ch) mill_chclose_((ch), MILL_HERE_)\n#define mill_chs(ch, tp, val) mill_chs__((ch), tp, (val))\n#define mill_chr(ch, tp) mill_chr__((ch), tp)\n#define mill_chdone(ch, tp, val) mill_chdone__((ch), tp, (val))\n#define mill_choose mill_choose_init__\n#define mill_in(ch, tp, nm) mill_choose_in__((ch), tp, nm, __COUNTER__)\n#define mill_out(ch, tp, val) mill_choose_out__((ch), tp, (val), __COUNTER__)\n#define mill_deadline(dd) mill_choose_deadline__(dd, __COUNTER__)\n#define mill_otherwise mill_choose_otherwise__(__COUNTER__)\n#define mill_end mill_choose_end__\n#else\ntypedef struct mill_chan_ *chan;\n#define chmake(tp, sz) mill_chmake_(sizeof(tp), sz, MILL_HERE_)\n#define chdup(ch) mill_chdup_((ch), MILL_HERE_)\n#define chclose(ch) mill_chclose_((ch), MILL_HERE_)\n#define chs(ch, tp, val) mill_chs__((ch), tp, (val))\n#define chr(ch, tp) mill_chr__((ch), tp)\n#define chdone(ch, tp, val) mill_chdone__((ch), tp, (val))\n#define choose mill_choose_init__\n#define in(ch, tp, nm) mill_choose_in__((ch), tp, nm, __COUNTER__)\n#define out(ch, tp, val) mill_choose_out__((ch), tp, (val), __COUNTER__)\n#define deadline(dd) mill_choose_deadline__(dd, __COUNTER__)\n#define otherwise mill_choose_otherwise__(__COUNTER__)\n#define end mill_choose_end__\n#endif\n\n/******************************************************************************/\n/*  IP address library                                                        */\n/******************************************************************************/\n\n#define MILL_IPADDR_IPV4_ 1\n#define MILL_IPADDR_IPV6_ 2\n#define MILL_IPADDR_PREF_IPV4_ 3\n#define MILL_IPADDR_PREF_IPV6_ 4\n#define MILL_IPADDR_MAXSTRLEN_ 46\n\nstruct mill_ipaddr {char data[32];};\n\nMILL_EXPORT struct mill_ipaddr mill_iplocal_(\n    const char *name,\n    int port,\n    int mode);\nMILL_EXPORT struct mill_ipaddr mill_ipremote_(\n    const char *name,\n    int port,\n    int mode,\n    int64_t deadline);\nMILL_EXPORT const char *mill_ipaddrstr_(\n    struct mill_ipaddr addr,\n    char *ipstr);\n\n#if defined MILL_USE_PREFIX\n#define MILL_IPADDR_IPV4 MILL_IPADDR_IPV4_\n#define MILL_IPADDR_IPV6 MILL_IPADDR_IPV6_\n#define MILL_IPADDR_PREF_IPV4 MILL_IPADDR_PREF_IPV4_\n#define MILL_IPADDR_PREF_IPV6 MILL_IPADDR_PREF_IPV6_\n#define MILL_IPADDR_MAXSTRLEN MILL_IPADDR_MAXSTRLEN_\ntypedef struct mill_ipaddr mill_ipaddr;\n#define mill_iplocal mill_iplocal_\n#define mill_ipremote mill_ipremote_\n#define mill_ipaddrstr mill_ipaddrstr_\n#else\n#define IPADDR_IPV4 MILL_IPADDR_IPV4_\n#define IPADDR_IPV6 MILL_IPADDR_IPV6_\n#define IPADDR_PREF_IPV4 MILL_IPADDR_PREF_IPV4_\n#define IPADDR_PREF_IPV6 MILL_IPADDR_PREF_IPV6_\n#define IPADDR_MAXSTRLEN MILL_IPADDR_MAXSTRLEN_\ntypedef struct mill_ipaddr ipaddr;\n#define iplocal mill_iplocal_\n#define ipremote mill_ipremote_\n#define ipaddrstr mill_ipaddrstr_\n#endif\n\n/******************************************************************************/\n/*  TCP library                                                               */\n/******************************************************************************/\n\nstruct mill_tcpsock_;\n\nMILL_EXPORT struct mill_tcpsock_ *mill_tcplisten_(\n    struct mill_ipaddr addr,\n    int backlog);\nMILL_EXPORT int mill_tcpport_(\n    struct mill_tcpsock_ *s);\nMILL_EXPORT struct mill_tcpsock_ *mill_tcpaccept_(\n    struct mill_tcpsock_ *s,\n    int64_t deadline);\nMILL_EXPORT struct mill_ipaddr mill_tcpaddr_(\n    struct mill_tcpsock_ *s);\nMILL_EXPORT struct mill_tcpsock_ *mill_tcpconnect_(\n    struct mill_ipaddr addr,\n    int64_t deadline);\nMILL_EXPORT size_t mill_tcpsend_(\n    struct mill_tcpsock_ *s,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nMILL_EXPORT void mill_tcpflush_(\n    struct mill_tcpsock_ *s,\n    int64_t deadline);\nMILL_EXPORT size_t mill_tcprecv_(\n    struct mill_tcpsock_ *s,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nMILL_EXPORT size_t mill_tcprecvuntil_(\n    struct mill_tcpsock_ *s,\n    void *buf,\n    size_t len,\n    const char *delims,\n    size_t delimcount,\n    int64_t deadline);\nMILL_EXPORT void mill_tcpshutdown_(\n    struct mill_tcpsock_ *s, int how);\nMILL_EXPORT void mill_tcpclose_(\n    struct mill_tcpsock_ *s);\n\n#if defined MILL_USE_PREFIX\ntypedef struct mill_tcpsock_ *mill_tcpsock;\n#define mill_tcplisten mill_tcplisten_\n#define mill_tcpport mill_tcpport_\n#define mill_tcpaccept mill_tcpaccept_\n#define mill_tcpaddr mill_tcpaddr_\n#define mill_tcpconnect mill_tcpconnect_\n#define mill_tcpsend mill_tcpsend_\n#define mill_tcpflush mill_tcpflush_\n#define mill_tcprecv mill_tcprecv_\n#define mill_tcprecvuntil mill_tcprecvuntil_\n#define mill_tcpshutdown mill_tcpshutdown_\n#define mill_tcpclose mill_tcpclose_\n#else\ntypedef struct mill_tcpsock_ *tcpsock;\n#define tcplisten mill_tcplisten_\n#define tcpport mill_tcpport_\n#define tcpaccept mill_tcpaccept_\n#define tcpaddr mill_tcpaddr_\n#define tcpconnect mill_tcpconnect_\n#define tcpsend mill_tcpsend_\n#define tcpflush mill_tcpflush_\n#define tcprecv mill_tcprecv_\n#define tcprecvuntil mill_tcprecvuntil_\n#define tcpshutdown mill_tcpshutdown_\n#define tcpclose mill_tcpclose_\n#endif\n\n/******************************************************************************/\n/*  UDP library                                                               */\n/******************************************************************************/\n\nstruct mill_udpsock_;\n\nMILL_EXPORT struct mill_udpsock_ *mill_udplisten_(\n    struct mill_ipaddr addr);\nMILL_EXPORT int mill_udpport_(\n    struct mill_udpsock_ *s);\nMILL_EXPORT void mill_udpsend_(\n    struct mill_udpsock_ *s,\n    struct mill_ipaddr addr,\n    const void *buf,\n    size_t len);\nMILL_EXPORT size_t mill_udprecv_(\n    struct mill_udpsock_ *s,\n    struct mill_ipaddr *addr,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nMILL_EXPORT void mill_udpclose_(\n    struct mill_udpsock_ *s);\n\n#if defined MILL_USE_PREFIX\ntypedef struct mill_udpsock_ *mill_udpsock;\n#define mill_udplisten mill_udplisten_\n#define mill_udpport mill_udpport_\n#define mill_udpsend mill_udpsend_\n#define mill_udprecv mill_udprecv_\n#define mill_udpclose mill_udpclose_\n#else\ntypedef struct mill_udpsock_ *udpsock;\n#define udplisten mill_udplisten_\n#define udpport mill_udpport_\n#define udpsend mill_udpsend_\n#define udprecv mill_udprecv_\n#define udpclose mill_udpclose_\n#endif\n\n/******************************************************************************/\n/*  UNIX library                                                              */\n/******************************************************************************/\n\nstruct mill_unixsock_;\n\nMILL_EXPORT struct mill_unixsock_ *mill_unixlisten_(\n    const char *addr,\n    int backlog);\nMILL_EXPORT struct mill_unixsock_ *mill_unixaccept_(\n    struct mill_unixsock_ *s,\n    int64_t deadline);\nMILL_EXPORT struct mill_unixsock_ *mill_unixconnect_(\n    const char *addr);\nMILL_EXPORT void mill_unixpair_(\n    struct mill_unixsock_ **a,\n    struct mill_unixsock_ **b);\nMILL_EXPORT size_t mill_unixsend_(\n    struct mill_unixsock_ *s,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nMILL_EXPORT void mill_unixflush_(\n    struct mill_unixsock_ *s,\n    int64_t deadline);\nMILL_EXPORT size_t mill_unixrecv_(\n    struct mill_unixsock_ *s,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nMILL_EXPORT size_t mill_unixrecvuntil_(\n    struct mill_unixsock_ *s,\n    void *buf,\n    size_t len,\n    const char *delims,\n    size_t delimcount,\n    int64_t deadline);\nMILL_EXPORT void mill_unixshutdown_(\n    struct mill_unixsock_ *s, int how);\nMILL_EXPORT void mill_unixclose_(\n    struct mill_unixsock_ *s);\n\n#if defined MILL_USE_PREFIX\ntypedef struct mill_unixsock_ *mill_unixsock;\n#define mill_unixlisten mill_unixlisten_\n#define mill_unixaccept mill_unixaccept_\n#define mill_unixconnect mill_unixconnect_\n#define mill_unixpair mill_unixpair_\n#define mill_unixsend mill_unixsend_\n#define mill_unixflush mill_unixflush_\n#define mill_unixrecv mill_unixrecv_\n#define mill_unixrecvuntil mill_unixrecvuntil_\n#define mill_unixshutdown mill_unixshutdown_\n#define mill_unixclose mill_unixclose_\n#else\ntypedef struct mill_unixsock_ *unixsock;\n#define unixlisten mill_unixlisten_\n#define unixaccept mill_unixaccept_\n#define unixconnect mill_unixconnect_\n#define unixpair mill_unixpair_\n#define unixsend mill_unixsend_\n#define unixflush mill_unixflush_\n#define unixrecv mill_unixrecv_\n#define unixrecvuntil mill_unixrecvuntil_\n#define unixshutdown mill_unixshutdown_\n#define unixclose mill_unixclose_\n#endif\n\n/******************************************************************************/\n/*  SSL library (experimental, subject to change)                             */\n/******************************************************************************/\n\nstruct mill_sslsock_;\n\nMILL_EXPORT struct mill_sslsock_ *mill_ssllisten_(\n    struct mill_ipaddr addr,\n    const char *cert_file,\n    const char *key_file,\n    int backlog);\nMILL_EXPORT int mill_sslport_(\n    struct mill_sslsock_ *s);\nMILL_EXPORT struct mill_sslsock_ *mill_sslconnect_(\n    struct mill_ipaddr addr,\n    int64_t deadline);\nMILL_EXPORT struct mill_sslsock_ *mill_sslaccept_(\n    struct mill_sslsock_ *s,\n    int64_t deadline);\nMILL_EXPORT struct mill_ipaddr mill_ssladdr_(\n    struct mill_sslsock_ *s);\nMILL_EXPORT size_t mill_sslrecv_(\n    struct mill_sslsock_ *s,\n    void *buf,\n    int len,\n    int64_t deadline);\nMILL_EXPORT size_t mill_sslrecvuntil_(\n    struct mill_sslsock_ *s,\n    void *buf,\n    size_t len,\n    const char *delims,\n    size_t delimcount,\n    int64_t deadline);\nMILL_EXPORT size_t mill_sslsend_(\n    struct mill_sslsock_ *s,\n    const void *buf,\n    int len,\n    int64_t deadline);\nMILL_EXPORT void mill_sslflush_(\n    struct mill_sslsock_ *s,\n    int64_t deadline);\nMILL_EXPORT void mill_sslclose_(\n    struct mill_sslsock_ *s);\n\n#if defined MILL_USE_PREFIX\ntypedef struct mill_sslsock_ *mill_sslsock;\n#define mill_ssllisten mill_ssllisten_\n#define mill_sslport mill_sslport_\n#define mill_sslconnect mill_sslconnect_\n#define mill_sslaccept mill_sslaccept_\n#define mill_ssladdr mill_ssladdr_\n#define mill_sslrecv mill_sslrecv_\n#define mill_sslrecvuntil mill_sslrecvuntil_\n#define mill_sslsend mill_sslsend_\n#define mill_sslflush mill_sslflush_\n#define mill_sslclose mill_sslclose_\n#else\ntypedef struct mill_sslsock_ *sslsock;\n#define ssllisten mill_ssllisten_\n#define sslport mill_sslport_\n#define sslconnect mill_sslconnect_\n#define sslaccept mill_sslaccept_\n#define ssladdr mill_ssladdr_\n#define sslrecv mill_sslrecv_\n#define sslrecvuntil mill_sslrecvuntil_\n#define sslsend mill_sslsend_\n#define sslflush mill_sslflush_\n#define sslclose mill_sslclose_\n#endif\n\n/******************************************************************************/\n/*  File library                                                              */\n/******************************************************************************/\n\nstruct mill_file;\n\nMILL_EXPORT struct mill_file *mill_mfopen_(\n    const char *pathname,\n    int flags,\n    mode_t mode);\nMILL_EXPORT size_t mill_mfwrite_(\n    struct mill_file *f,\n    const void *buf,\n    size_t len,\n    int64_t deadline);\nMILL_EXPORT void mill_mfflush_(\n    struct mill_file *f,\n    int64_t deadline);\nMILL_EXPORT size_t mill_mfread_(\n    struct mill_file *f,\n    void *buf,\n    size_t len,\n    int64_t deadline);\nMILL_EXPORT void mill_mfclose_(\n    struct mill_file *f);\nMILL_EXPORT off_t mill_mftell_(\n    struct mill_file *f);\nMILL_EXPORT off_t mill_mfseek_(\n    struct mill_file *f,\n    off_t offset);\nMILL_EXPORT int mill_mfeof_(\n    struct mill_file *f);\nMILL_EXPORT struct mill_file *mill_mfin_(\n    void);\nMILL_EXPORT struct mill_file *mill_mfout_(\n    void);\nMILL_EXPORT struct mill_file *mill_mferr_(\n    void);\n\n#if defined MILL_USE_PREFIX\ntypedef struct mill_file *mill_mfile;\n#define mill_mfopen mill_mfopen_\n#define mill_mfwrite mill_mfwrite_\n#define mill_mfflush mill_mfflush_\n#define mill_mfread mill_mfread_\n#define mill_mfclose mill_mfclose_\n#define mill_mftell mill_mftell_\n#define mill_mfseek mill_mfseek_\n#define mill_mfeof mill_mfeof_\n#define mill_mfin mill_mfin_()\n#define mill_mfout mill_mfout_()\n#define mill_mferr mill_mferr_()\n#else\ntypedef struct mill_file *mfile;\n#define mfopen mill_mfopen_\n#define mfwrite mill_mfwrite_\n#define mfflush mill_mfflush_\n#define mfread mill_mfread_\n#define mfclose mill_mfclose_\n#define mftell mill_mftell_\n#define mfseek mill_mfseek_\n#define mfeof mill_mfeof_\n#define mfin mill_mfin_()\n#define mfout mill_mfout_()\n#define mferr mill_mferr_()\n#endif\n\n/******************************************************************************/\n/*  Debugging                                                                 */\n/******************************************************************************/\n\n/* These symbols are not wrapped in macros so that they can be used\n   directly from the debugger. */\nMILL_EXPORT void goredump(\n    void);\nMILL_EXPORT void gotrace(\n    int level);\n\n#if defined MILL_USE_PREFIX\n#define mill_goredump goredump\n#define mill_gotrace gotrace\n#endif\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "libmill.pc.in",
          "type": "blob",
          "size": 0.2490234375,
          "content": "prefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nincludedir=@includedir@\n\nName: libmill\nDescription: Go-style concurrency in C\nURL: http://libmill.org/\nVersion: @MILL_ABI_VERSION@\nRequires:\nLibs: -L${libdir} -lmill @LIBS@\nCflags: -I${includedir}\n"
        },
        {
          "name": "list.c",
          "type": "blob",
          "size": 2.001953125,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stddef.h>\n\n#include \"list.h\"\n\nvoid mill_list_init(struct mill_list *self)\n{\n    self->first = NULL;\n    self->last = NULL;\n}\n\nvoid mill_list_insert(struct mill_list *self, struct mill_list_item *item,\n    struct mill_list_item *it)\n{\n    item->prev = it ? it->prev : self->last;\n    item->next = it;\n    if(item->prev)\n        item->prev->next = item;\n    if(item->next)\n        item->next->prev = item;\n    if(!self->first || self->first == it)\n        self->first = item;\n    if(!it)\n        self->last = item;\n}\n\nstruct mill_list_item *mill_list_erase(struct mill_list *self,\n    struct mill_list_item *item)\n{\n    struct mill_list_item *next;\n\n    if(item->prev)\n        item->prev->next = item->next;\n    else\n        self->first = item->next;\n    if(item->next)\n        item->next->prev = item->prev;\n    else\n        self->last = item->prev;\n\n    next = item->next;\n\n    item->prev = NULL;\n    item->next = NULL;\n\n    return next;\n}\n\n"
        },
        {
          "name": "list.h",
          "type": "blob",
          "size": 2.2216796875,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_LIST_INCLUDED\n#define MILL_LIST_INCLUDED\n\n/* Doubly-linked list. */\n\nstruct mill_list_item {\n    struct mill_list_item *next;\n    struct mill_list_item *prev;\n};\n\nstruct mill_list {\n    struct mill_list_item *first;\n    struct mill_list_item *last;\n};\n\n/* Initialise the list. To statically initialise the list use = {0}. */\nvoid mill_list_init(struct mill_list *self);\n\n/* True is the list has no items. */\n#define mill_list_empty(self) (!((self)->first))\n\n/* Returns iterator to the first item in the list or NULL if\n   the list is empty. */\n#define mill_list_begin(self) ((self)->first)\n\n/* Returns iterator to one past the item pointed to by 'it'. */\n#define mill_list_next(it) ((it)->next)\n\n/* Adds the item to the list before the item pointed to by 'it'.\n   If 'it' is NULL the item is inserted to the end of the list. */\nvoid mill_list_insert(struct mill_list *self, struct mill_list_item *item,\n    struct mill_list_item *it);\n\n/* Removes the item from the list and returns pointer to the next item in the\n   list. Item must be part of the list. */\nstruct mill_list_item *mill_list_erase(struct mill_list *self,\n    struct mill_list_item *item);\n\n#endif\n\n"
        },
        {
          "name": "m4",
          "type": "tree",
          "content": null
        },
        {
          "name": "mfork.c",
          "type": "blob",
          "size": 1.392578125,
          "content": "/*\n\n  Copyright (c) 2016 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <unistd.h>\n\n#include \"cr.h\"\n#include \"libmill.h\"\n#include \"poller.h\"\n#include \"timer.h\"\n\npid_t mill_mfork_(void) {\n    pid_t pid = fork();\n    if(pid != 0) {\n        /* Parent. */\n        return pid;\n    }\n    /* Child. */\n    mill_cr_postfork();\n    mill_poller_postfork();\n    mill_timer_postfork();\n    return 0;\n}\n"
        },
        {
          "name": "package_version.sh",
          "type": "blob",
          "size": 1.634765625,
          "content": "#!/bin/sh\n\n# Copyright (c) 2013 Luca Barbato\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"),\n# to deal in the Software without restriction, including without limitation\n# the rights to use, copy, modify, merge, publish, distribute, sublicense,\n# and/or sell copies of the Software, and to permit persons to whom\n# the Software is furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nif [ -d .git ]; then\n    #  Retrieve the version from the last git tag.\n    VER=`git describe --always | sed -e \"s:v::\"`\n    if [ x\"`git diff-index --name-only HEAD`\" != x ]; then\n        #  If the sources have been changed locally, add -dirty to the version.\n        VER=\"${VER}-dirty\"\n    fi\nelif [ -f .version ]; then\n    #  If git is not available (e.g. when building from source package)\n    #  we can extract the package version from .version file.\n    VER=`< .version`\nelse\n    #  The package version cannot be retrieved.\n    VER=\"Unknown\"\nfi\n\nprintf '%s' \"$VER\"\n\n"
        },
        {
          "name": "perf",
          "type": "tree",
          "content": null
        },
        {
          "name": "poll.inc",
          "type": "blob",
          "size": 7.0888671875,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <poll.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"cr.h\"\n#include \"list.h\"\n#include \"utils.h\"\n\n/* Pollset used for waiting for file descriptors. */\nstatic int mill_pollset_size = 0;\nstatic int mill_pollset_capacity = 0;\nstatic struct pollfd *mill_pollset_fds = NULL;\n\n/* The item at a specific index in this array corresponds to the entry\n   in mill_pollset fds with the same index. */\nstruct mill_pollset_item {\n    struct mill_cr *in;\n    struct mill_cr *out;\n};\nstatic struct mill_pollset_item *mill_pollset_items = NULL;\n\n/* Find pollset index by fd. If fd is not in pollset, return the index after\n   the last item. TODO: This is O(n) operation! */\nstatic int mill_find_pollset(int fd) {\n    int i;\n    for(i = 0; i != mill_pollset_size; ++i) {\n        if(mill_pollset_fds[i].fd == fd)\n            break;\n    }\n    return i;\n}\n\nvoid mill_poller_init(void) {\n    errno = 0;\n}\n\nvoid mill_poller_postfork(void) {\n    mill_pollset_size = 0;\n    mill_pollset_capacity = 0;\n    mill_pollset_fds = NULL;\n    mill_pollset_items = NULL;\n}\n\nstatic void mill_poller_add(int fd, int events) {\n    int i = mill_find_pollset(fd);\n    /* Grow the pollset as needed. */\n    if(i == mill_pollset_size) {\n        if(mill_pollset_size == mill_pollset_capacity) {\n            mill_pollset_capacity = mill_pollset_capacity ?\n                mill_pollset_capacity * 2 : 64;\n            mill_pollset_fds = realloc(mill_pollset_fds,\n                mill_pollset_capacity * sizeof(struct pollfd));\n            mill_pollset_items = realloc(mill_pollset_items,\n                mill_pollset_capacity * sizeof(struct mill_pollset_item));\n        }\n        ++mill_pollset_size;\n        mill_pollset_fds[i].fd = fd;\n        mill_pollset_fds[i].events = 0;\n        mill_pollset_fds[i].revents = 0;\n        mill_pollset_items[i].in = NULL;\n        mill_pollset_items[i].out = NULL;\n    }\n    /* Register the new file descriptor in the pollset. */\n    if(events & FDW_IN) {\n        if(mill_slow(mill_pollset_items[i].in))\n            mill_panic(\n                \"multiple coroutines waiting for a single file descriptor\");\n        mill_pollset_fds[i].events |= POLLIN;\n        mill_pollset_items[i].in = mill_running;\n    }\n    if(events & FDW_OUT) {\n        if(mill_slow(mill_pollset_items[i].out))\n            mill_panic(\n                \"multiple coroutines waiting for a single file descriptor\");\n        mill_pollset_fds[i].events |= POLLOUT;\n        mill_pollset_items[i].out = mill_running;\n    }\n}\n\nstatic void mill_poller_rm(struct mill_cr *cr) {\n    mill_assert(cr->fd != -1);\n    int i = mill_find_pollset(cr->fd);\n    mill_assert(i < mill_pollset_size);\n    if(mill_pollset_items[i].in == cr) {\n        mill_pollset_items[i].in = NULL;\n        mill_pollset_fds[i].events &= ~POLLIN;\n        cr->fd = -1;\n    }\n    if(mill_pollset_items[i].out == cr) {\n        mill_pollset_items[i].out = NULL;\n        mill_pollset_fds[i].events &= ~POLLOUT;\n        cr->fd = -1;\n    }\n    if(!mill_pollset_fds[i].events) {\n        --mill_pollset_size;\n        if(i < mill_pollset_size) {\n            mill_pollset_items[i] = mill_pollset_items[mill_pollset_size];\n            mill_pollset_fds[i] = mill_pollset_fds[mill_pollset_size];\n        }\n    }\n}\n\nstatic void mill_poller_clean(int fd) {\n}\n\nstatic int mill_poller_wait(int timeout) {\n    /* Wait for events. */\n    int numevs;\n    while(1) {\n        numevs = poll(mill_pollset_fds, mill_pollset_size, timeout);\n        if(numevs < 0 && errno == EINTR)\n            continue;\n        mill_assert(numevs >= 0);\n        break;  \n    }\n    /* Fire file descriptor events. */\n    int result = numevs > 0 ? 1 : 0;\n    int i;\n    for(i = 0; i < mill_pollset_size && numevs; ++i) {\n        int inevents = 0;\n        int outevents = 0;\n        if (!mill_pollset_fds[i].revents)\n            continue;\n        /* Set the result values. */\n        if(mill_pollset_fds[i].revents & POLLIN)\n            inevents |= FDW_IN;\n        if(mill_pollset_fds[i].revents & POLLOUT)\n            outevents |= FDW_OUT;\n        if(mill_pollset_fds[i].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            inevents |= FDW_ERR;\n            outevents |= FDW_ERR;\n        }\n        mill_pollset_fds[i].revents = 0;\n        /* Resume the blocked coroutines. */\n        if(mill_pollset_items[i].in &&\n              mill_pollset_items[i].in == mill_pollset_items[i].out) {\n            struct mill_cr *cr = mill_pollset_items[i].in;\n            cr->fd = -1;\n            mill_resume(cr, inevents | outevents);\n            mill_pollset_fds[i].events = 0;\n            mill_pollset_items[i].in = NULL;\n            mill_pollset_items[i].out = NULL;\n            if(mill_timer_enabled(&cr->timer))\n                mill_timer_rm(&cr->timer);\n        }\n        else {\n            if(mill_pollset_items[i].in && inevents) {\n                struct mill_cr *cr = mill_pollset_items[i].in;\n                cr->fd = -1;\n                mill_resume(cr, inevents);\n                mill_pollset_fds[i].events &= ~POLLIN;\n                mill_pollset_items[i].in = NULL;\n                if(mill_timer_enabled(&cr->timer))\n                    mill_timer_rm(&cr->timer);\n            }\n            if(mill_pollset_items[i].out && outevents) {\n                struct mill_cr *cr = mill_pollset_items[i].out;\n                cr->fd = -1;\n                mill_resume(cr, outevents);\n                mill_pollset_fds[i].events &= ~POLLOUT;\n                mill_pollset_items[i].out = NULL;\n                if(mill_timer_enabled(&cr->timer))\n                    mill_timer_rm(&cr->timer);\n            }\n        }\n        /* If nobody is polling for the fd remove it from the pollset. */\n        if(!mill_pollset_fds[i].events) {\n            mill_assert(!mill_pollset_items[i].in &&\n                !mill_pollset_items[i].out);\n            --mill_pollset_size;\n            if(i < mill_pollset_size) {\n                mill_pollset_fds[i] = mill_pollset_fds[mill_pollset_size];\n                mill_pollset_items[i] = mill_pollset_items[mill_pollset_size];\n            }\n            --i;\n        }\n        --numevs;\n    }\n    return result;\n}\n\n"
        },
        {
          "name": "poller.c",
          "type": "blob",
          "size": 4.24609375,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stdint.h>\n#include <sys/param.h>\n\n#include \"cr.h\"\n#include \"libmill.h\"\n#include \"list.h\"\n#include \"poller.h\"\n#include \"timer.h\"\n\n/* Forward declarations for the functions implemented by specific poller\n   mechanisms (poll, epoll, kqueue). */\nvoid mill_poller_init(void);\nstatic void mill_poller_add(int fd, int events);\nstatic void mill_poller_rm(struct mill_cr *cr);\nstatic void mill_poller_clean(int fd);\nstatic int mill_poller_wait(int timeout);\n\n/* If 1, mill_poller_init was already called. */\nstatic int mill_poller_initialised = 0;\n\n#define check_poller_initialised() \\\ndo {\\\n    if(mill_slow(!mill_poller_initialised)) {\\\n        mill_poller_init();\\\n        mill_assert(errno == 0);\\\n        mill_main.fd = -1;\\\n        mill_main.timer.expiry = -1;\\\n        mill_poller_initialised = 1;\\\n    }\\\n} while(0)\n\n/* Pause current coroutine for a specified time interval. */\nvoid mill_msleep_(int64_t deadline, const char *current) {\n    mill_fdwait_(-1, 0, deadline, current);\n}\n\nstatic void mill_poller_callback(struct mill_timer *timer) {\n    struct mill_cr *cr = mill_cont(timer, struct mill_cr, timer);\n    mill_resume(cr, -1);\n    if (cr->fd != -1)\n        mill_poller_rm(cr);\n}\n\nint mill_fdwait_(int fd, int events, int64_t deadline, const char *current) {\n    check_poller_initialised();\n    /* If required, start waiting for the timeout. */\n    if(deadline >= 0)\n        mill_timer_add(&mill_running->timer, deadline, mill_poller_callback);\n    /* If required, start waiting for the file descriptor. */\n    if(fd >= 0)\n        mill_poller_add(fd, events);\n    /* Do actual waiting. */\n    mill_running->state = fd < 0 ? MILL_MSLEEP : MILL_FDWAIT;\n    mill_running->fd = fd;\n    mill_running->events = events;\n    mill_set_current(&mill_running->debug, current);\n    int rc = mill_suspend();\n    /* Handle file descriptor events. */\n    if(rc >= 0) {\n        mill_assert(!mill_timer_enabled(&mill_running->timer));\n        return rc;\n    }\n    /* Handle the timeout. */\n    mill_assert(mill_running->fd == -1);\n    return 0;\n}\n\nvoid mill_fdclean_(int fd) {\n    check_poller_initialised();\n    mill_poller_clean(fd);\n}\n\nvoid mill_wait(int block) {\n    check_poller_initialised();\n    while(1) {\n        /* Compute timeout for the subsequent poll. */\n        int timeout = block ? mill_timer_next() : 0;\n        /* Wait for events. */\n        int fd_fired = mill_poller_wait(timeout);\n        /* Fire all expired timers. */\n        int timer_fired = mill_timer_fire();\n        /* Never retry the poll in non-blocking mode. */\n        if(!block || fd_fired || timer_fired)\n            break;\n        /* If timeout was hit but there were no expired timers do the poll\n           again. This should not happen in theory but let's be ready for the\n           case when the system timers are not precise. */\n    }\n}\n\n/* Include the poll-mechanism-specific stuff. */\n\n/* User overloads. */\n#if defined MILL_EPOLL\n#include \"epoll.inc\"\n#elif defined MILL_KQUEUE\n#include \"kqueue.inc\"\n#elif defined MILL_POLL\n#include \"poll.inc\"\n/* Defaults. */\n#elif defined __linux__ && !defined MILL_NO_EPOLL\n#include \"epoll.inc\"\n#elif (defined BSD || defined __APPLE__) && !defined MILL_NO_KQUEUE\n#include \"kqueue.inc\"\n#else\n#include \"poll.inc\"\n#endif\n\n"
        },
        {
          "name": "poller.h",
          "type": "blob",
          "size": 1.63671875,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_POLLER_INCLUDED\n#define MILL_POLLER_INCLUDED\n\nvoid mill_poller_init(void);\n\n/* poller.c also implements mill_wait() and mill_fdwait() declared\n   in libmill.h. */\n\n/* Wait till at least one coroutine is resumed. If block is set to 0 the\n   function will poll for events and return immediately. If it is set to 1\n   it will block until there's at least one event to process. */\nvoid mill_wait(int block);\n\n/* Called in the child process after fork to create a fresh new pollset\n   independent from the parent's pollset. */\nvoid mill_poller_postfork(void);\n\n#endif\n\n"
        },
        {
          "name": "slist.c",
          "type": "blob",
          "size": 1.8603515625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stddef.h>\n\n#include \"slist.h\"\n\nvoid mill_slist_init(struct mill_slist *self) {\n    self->first = NULL;\n    self->last = NULL;\n}\n\nvoid mill_slist_push(struct mill_slist *self, struct mill_slist_item *item) {\n    item->next = self->first;\n    self->first = item;\n    if(!self->last)\n        self->last = item;\n}\n\nvoid mill_slist_push_back(struct mill_slist *self,\n      struct mill_slist_item *item) {\n    item->next = NULL;\n    if(!self->last)\n        self->first = item;\n    else\n        self->last->next = item;\n    self->last = item;\n}\n\nstruct mill_slist_item *mill_slist_pop(struct mill_slist *self) {\n    if(!self->first)\n        return NULL;\n    struct mill_slist_item *it = self->first;\n    self->first = self->first->next;\n    if(!self->first)\n        self->last = NULL;\n    return it;\n}\n\n"
        },
        {
          "name": "slist.h",
          "type": "blob",
          "size": 2.26171875,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_SLIST_INCLUDED\n#define MILL_SLIST_INCLUDED\n\n/* Singly-linked list. Having both push and push_back functions means that\n   it can be used both as a queue and as a stack. */\n\nstruct mill_slist_item {\n    struct mill_slist_item *next;\n};\n\nstruct mill_slist {\n    struct mill_slist_item *first;\n    struct mill_slist_item *last;\n};\n\n/* Initialise the list. To statically initialise the list use = {0}. */\nvoid mill_slist_init(struct mill_slist *self);\n\n/* True is the list has no items. */\n#define mill_slist_empty(self) (!((self)->first))\n\n/* Returns iterator to the first item in the list or NULL if\n   the list is empty. */\n#define mill_slist_begin(self) ((self)->first)\n\n/* Returns iterator to one past the item pointed to by 'it'.\n   If there are no more items returns NULL. */\n#define mill_slist_next(it) ((it)->next)\n\n/* Push the item to the beginning of the list. */\nvoid mill_slist_push(struct mill_slist *self, struct mill_slist_item *item);\n\n/* Push the item to the end of the list. */\nvoid mill_slist_push_back(struct mill_slist *self,\n    struct mill_slist_item *item);\n\n/* Pop an item from the beginning of the list. */\nstruct mill_slist_item *mill_slist_pop(struct mill_slist *self);\n\n#endif\n\n"
        },
        {
          "name": "ssl.c",
          "type": "blob",
          "size": 8.732421875,
          "content": "/*\n\n  Copyright (c) 2016 John E. Haque\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#if defined HAVE_SSL\n\n#include <openssl/bio.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n\n#include \"debug.h\"\n#include \"libmill.h\"\n#include \"utils.h\"\n\n/* Defined in tcp.c, not exposed via libmill.h */\nint mill_tcpfd(struct mill_tcpsock_ *s);\n\n/* Only one client context is needed, so let's make it global. */\nstatic SSL_CTX *ssl_cli_ctx;\n\nenum mill_ssltype {\n   MILL_SSLLISTENER,\n   MILL_SSLCONN\n};\n\nstruct mill_sslsock_ {\n    enum mill_ssltype type;\n};\n\nstruct mill_ssllistener {\n    struct mill_sslsock_ sock;\n    tcpsock s;\n    SSL_CTX *ctx;\n};\n\nstruct mill_sslconn {\n    struct mill_sslsock_ sock;\n    tcpsock s;\n    BIO *bio;\n};\n\n/* Initialise OpenSSL library. */\nstatic void ssl_init(void) {\n    static int initialised = 0;\n    if(mill_fast(initialised))\n        return;\n    initialised = 1;\n    OpenSSL_add_all_algorithms();\n    SSL_library_init();\n\n    /* TODO: Move to sslconnect() */\n    ssl_cli_ctx = SSL_CTX_new(SSLv23_client_method());\n    mill_assert(ssl_cli_ctx);\n}\n\nstruct mill_sslsock_ *mill_ssllisten_(struct mill_ipaddr addr,\n      const char *cert_file, const char *key_file, int backlog) {\n    ssl_init();\n    /* Load certificates. */\n    SSL_CTX *ctx = SSL_CTX_new(SSLv23_server_method());\n    if(!ctx)\n        return NULL;\n    if(cert_file && SSL_CTX_use_certificate_chain_file(ctx, cert_file) <= 0)\n        return NULL;\n    if(key_file && SSL_CTX_use_PrivateKey_file(ctx,\n          key_file, SSL_FILETYPE_PEM) <= 0)\n        return NULL;\n    /* Check for inconsistent private key. */\n    if(SSL_CTX_check_private_key(ctx) <= 0)\n        return NULL;\n    /* Open the listening socket. */\n    tcpsock s = tcplisten(addr, backlog);\n    if(!s) {\n        /* TODO: close the context */\n        return NULL;\n    }\n    /* Create the object. */\n    struct mill_ssllistener *l = malloc(sizeof(struct mill_ssllistener));\n    if(!l) {\n        /* TODO: close the context */\n        tcpclose(s);\n        errno = ENOMEM;\n        return NULL;\n    }\n    l->sock.type = MILL_SSLLISTENER;\n    l->s = s;\n    l->ctx = ctx;\n    errno = 0;\n    return &l->sock;\n}\n\nint mill_sslport_(struct mill_sslsock_ *s) {\n    if(s->type == MILL_SSLLISTENER) {\n        struct mill_ssllistener *l = (struct mill_ssllistener*)s;\n        return tcpport(l->s);\n    }\n    if(s->type == MILL_SSLCONN) {\n        struct mill_sslconn *c = (struct mill_sslconn*)s;\n        return tcpport(c->s);\n    }\n    mill_assert(0);\n}\n\n\nstatic int ssl_wait(struct mill_sslconn *c, int64_t deadline) {\n    if(!BIO_should_retry(c->bio)) {\n        unsigned long sslerr = ERR_get_error();\n        /* XXX: Ref. openssl/source/ssl/ssl_lib.c .. */\n        if(ERR_GET_LIB(sslerr) != ERR_LIB_SYS)\n            errno = ECONNRESET;\n        return -1;\n    }\n\n    if(BIO_should_read(c->bio)) {\n        int rc = fdwait(mill_tcpfd(c->s), FDW_IN, deadline);\n        if(rc == 0) {\n            errno = ETIMEDOUT;\n            return -1;\n        }\n        return rc;\n    }\n    if(BIO_should_write(c->bio)) {\n        int rc = fdwait(mill_tcpfd(c->s), FDW_OUT, deadline);\n        if(rc == 0) {\n            errno = ETIMEDOUT;\n            return -1;\n        }\n        return rc;\n    }\n    /* mill_assert(!BIO_should_io_special(c->bio)); */\n    errno = ECONNRESET;\n    return -1;  /* should not happen ? */\n}\n\nvoid mill_sslclose_(struct mill_sslsock_ *s) {\n    switch(s->type) {\n    case MILL_SSLLISTENER:;\n        struct mill_ssllistener *l = (struct mill_ssllistener*)s;\n        SSL_CTX_free(l->ctx);\n        /* TODO: close the context */\n        tcpclose(l->s);\n        free(l);\n        break;\n    case MILL_SSLCONN:;\n        struct mill_sslconn *c = (struct mill_sslconn*)s;\n        tcpclose(c->s);\n        BIO_ssl_shutdown(c->bio);\n        BIO_free_all(c->bio);\n        free(c);\n        break;\n    default:\n        mill_assert(0);\n    }\n    errno = 0;\n}\n\nstatic struct mill_sslsock_ *ssl_conn_new(tcpsock s, SSL_CTX *ctx, int client) {\n    mill_assert(ctx);\n    SSL *ssl = NULL;\n    BIO *sbio = BIO_new_ssl(ctx, client);\n    if(!sbio)\n        return NULL;\n    BIO_get_ssl(sbio, &ssl);\n    if(!ssl) {\n        BIO_free(sbio);\n        return NULL;\n    }\n\n    /* set .._PARTIAL_WRITE for non-blocking operation */\n    SSL_set_mode(ssl, SSL_MODE_ENABLE_PARTIAL_WRITE);\n    BIO *cbio = BIO_new_socket(mill_tcpfd(s), BIO_NOCLOSE);\n    if(!cbio) {\n        BIO_free(sbio);\n        return NULL;\n    } \n    BIO_push(sbio, cbio);\n    struct mill_sslconn *c = malloc(sizeof (struct mill_sslconn));\n    if(!c) {\n        BIO_free_all(sbio);\n        return NULL;\n    }\n\n    /*  mill_assert(BIO_get_fd(sbio, NULL) == fd); */\n\n    c->sock.type = MILL_SSLCONN;\n    c->bio = sbio;\n    c->s = s;\n    /* OPTIONAL: call ssl_handshake() to check/verify peer certificate */\n    return &c->sock;\n}\n\nsize_t mill_sslrecv_(struct mill_sslsock_ *s, void *buf, int len,\n      int64_t deadline) {\n    if(s->type != MILL_SSLCONN)\n        mill_panic(\"trying to use an unconnected socket\");\n    struct mill_sslconn *c = (struct mill_sslconn*)s;\n\n    int rc;\n    if(len < 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    while(1) {\n        rc = BIO_read(c->bio, buf, len);\n        if(rc >= 0)\n            return rc;\n        if(ssl_wait(c, deadline) < 0)\n            return 0;\n    }\n}\n\nsize_t mill_sslrecvuntil_(struct mill_sslsock_ *s, void *buf, size_t len,\n      const char *delims, size_t delimcount, int64_t deadline) {\n    if(s->type != MILL_SSLCONN)\n        mill_panic(\"trying to receive from an unconnected socket\");\n    char *pos = (char*)buf;\n    size_t i;\n    for(i = 0; i != len; ++i, ++pos) {\n        size_t res = sslrecv(s, pos, 1, deadline);\n        if(res == 1) {\n            size_t j;\n            for(j = 0; j != delimcount; ++j)\n                if(*pos == delims[j])\n                    return i + 1;\n        }\n        if (errno != 0)\n            return i + res;\n    }\n    errno = ENOBUFS;\n    return len;\n}\n\nsize_t mill_sslsend_(struct mill_sslsock_ *s, const void *buf, int len,\n      int64_t deadline) {\n    if(s->type != MILL_SSLCONN)\n        mill_panic(\"trying to use an unconnected socket\");\n    struct mill_sslconn *c = (struct mill_sslconn*)s;\n\n    int rc;\n    if(len < 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    while(1) {\n        rc = BIO_write(c->bio, buf, len);\n        if (rc >= 0)\n            return rc;\n        if(ssl_wait(c, deadline) < 0)\n            return 0;\n    }\n}\n\nvoid mill_sslflush_(struct mill_sslsock_ *s, int64_t deadline) {\n    if(s->type != MILL_SSLCONN)\n        mill_panic(\"trying to use an unconnected socket\");\n    struct mill_sslconn *c = (struct mill_sslconn*)s;\n\n    int rc;\n    while(1) {\n        rc = BIO_flush(c->bio);\n        if (rc >= 0)\n            break;\n        if(ssl_wait(c, deadline) < 0)\n            return;\n    }\n    errno = 0;\n}\n\nstruct mill_sslsock_ *mill_sslconnect_(struct mill_ipaddr addr,\n      int64_t deadline) {\n    ssl_init();\n    tcpsock sock = tcpconnect(addr, deadline);\n    if(!sock)\n        return NULL;\n    struct mill_sslsock_ *c = ssl_conn_new(sock, ssl_cli_ctx, 1);\n    if(!c) {\n        tcpclose(sock);\n        errno = ENOMEM;\n        return NULL;\n    }\n    return c;\n}\n\nstruct mill_sslsock_ *mill_sslaccept_(struct mill_sslsock_ *s, int64_t deadline) {\n    if(s->type != MILL_SSLLISTENER)\n        mill_panic(\"trying to accept on a socket that isn't listening\");\n    struct mill_ssllistener *l = (struct mill_ssllistener*)s;\n    tcpsock sock = tcpaccept(l->s, deadline);\n    if(!sock)\n        return NULL;\n    struct mill_sslsock_ *c = ssl_conn_new(sock, l->ctx, 0);\n    if(!c) {\n        tcpclose(sock);\n        errno = ENOMEM;\n        return NULL;\n    }\n    return c;\n}\n\nipaddr mill_ssladdr_(struct mill_sslsock_ *s) {\n    if(s->type != MILL_SSLCONN)\n        mill_panic(\"trying to get address from a socket that isn't connected\");\n    struct mill_sslconn *c = (struct mill_sslconn*)s;\n    return tcpaddr(c->s);\n}\n\n#endif\n\n"
        },
        {
          "name": "stack.c",
          "type": "blob",
          "size": 6.458984375,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n#include \"debug.h\"\n#include \"slist.h\"\n#include \"stack.h\"\n#include \"utils.h\"\n\n/* Get memory page size. The query is done once only. The value is cached. */\nstatic size_t mill_page_size(void) {\n    static long pgsz = 0;\n    if(mill_fast(pgsz))\n        return (size_t)pgsz;\n    pgsz = sysconf(_SC_PAGE_SIZE);\n    mill_assert(pgsz > 0);\n    return (size_t)pgsz;\n}\n\n/* Stack size, as specified by the user. */\nstatic size_t mill_stack_size = 256 * 1024 - 256;\n/* Actual stack size. */\nstatic size_t mill_sanitised_stack_size = 0;\n\nstatic size_t mill_get_stack_size(void) {\n#if defined HAVE_POSIX_MEMALIGN && HAVE_MPROTECT\n    /* If sanitisation was already done, return the precomputed size. */\n    if(mill_fast(mill_sanitised_stack_size))\n        return mill_sanitised_stack_size;\n    mill_assert(mill_stack_size > mill_page_size());\n    /* Amount of memory allocated must be multiply of the page size otherwise\n       the behaviour of posix_memalign() is undefined. */\n    size_t sz = (mill_stack_size + mill_page_size() - 1) &\n        ~(mill_page_size() - 1);\n    /* Allocate one additional guard page. */\n    mill_sanitised_stack_size = sz + mill_page_size();\n    return mill_sanitised_stack_size;\n#else\n    return mill_stack_size;\n#endif\n}\n\n/* Maximum number of unused cached stacks. Keep in mind that we can't\n   deallocate the stack you are running on. Thus we need at least one cached\n   stack. */\nstatic int mill_max_cached_stacks = 64;\n\n/* A stack of unused coroutine stacks. This allows for extra-fast allocation\n   of a new stack. The LIFO nature of this structure minimises cache misses.\n   When the stack is cached its mill_slist_item is placed on its top rather\n   then on the bottom. That way we minimise page misses. */\nstatic int mill_num_cached_stacks = 0;\nstatic struct mill_slist mill_cached_stacks = {0};\n\nstatic void *mill_allocstackmem(void) {\n    void *ptr;\n#if defined HAVE_POSIX_MEMALIGN && HAVE_MPROTECT\n    /* Allocate the stack so that it's memory-page-aligned. */\n    int rc = posix_memalign(&ptr, mill_page_size(), mill_get_stack_size());\n    if(mill_slow(rc != 0)) {\n        errno = rc;\n        return NULL;\n    }\n    /* The bottom page is used as a stack guard. This way stack overflow will\n       cause segfault rather than randomly overwrite the heap. */\n    rc = mprotect(ptr, mill_page_size(), PROT_NONE);\n    if(mill_slow(rc != 0)) {\n        int err = errno;\n        free(ptr);\n        errno = err;\n        return NULL;\n    }\n#else\n    ptr = malloc(mill_get_stack_size());\n    if(mill_slow(!ptr)) {\n        errno = ENOMEM;\n        return NULL;\n    }\n#endif\n    return (void*)(((char*)ptr) + mill_get_stack_size());\n}\n\n\nvoid mill_preparestacks(int count, size_t stack_size) {\n    /* Purge the cached stacks. */\n    while(1) {\n        struct mill_slist_item *item = mill_slist_pop(&mill_cached_stacks);\n        if(!item)\n            break;\n        free(((char*)(item + 1)) - mill_get_stack_size());\n    }\n    /* Now that there are no stacks allocated, we can adjust the stack size. */\n    size_t old_stack_size = mill_stack_size;\n    size_t old_sanitised_stack_size = mill_sanitised_stack_size;\n    mill_stack_size = stack_size;\n    mill_sanitised_stack_size = 0;\n    /* Allocate the new stacks. */\n    int i;\n    for(i = 0; i != count; ++i) {\n        void *ptr = mill_allocstackmem();\n        if(!ptr) goto error;\n        struct mill_slist_item *item = ((struct mill_slist_item*)ptr) - 1;\n        mill_slist_push_back(&mill_cached_stacks, item);\n    }\n    mill_num_cached_stacks = count;\n    /* Make sure that the stacks won't get deallocated even if they aren't used\n       at the moment. */\n    mill_max_cached_stacks = count;\n    errno = 0;\n    return;\nerror:\n    /* If we can't allocate all the stacks, allocate none, restore state and\n       return error. */\n    while(1) {\n        struct mill_slist_item *item = mill_slist_pop(&mill_cached_stacks);\n        if(!item)\n            break;\n        free(((char*)(item + 1)) - mill_get_stack_size());\n    }\n    mill_num_cached_stacks = 0;\n    mill_stack_size = old_stack_size;\n    mill_sanitised_stack_size = old_sanitised_stack_size;\n    errno = ENOMEM;\n}\n\nvoid *mill_allocstack(size_t *stack_size) {\n    if(!mill_slist_empty(&mill_cached_stacks)) {\n        --mill_num_cached_stacks;\n        return (void*)(mill_slist_pop(&mill_cached_stacks) + 1);\n    }\n    void *ptr = mill_allocstackmem();\n    if(!ptr)\n        mill_panic(\"not enough memory to allocate coroutine stack\");\n    if(stack_size)\n        *stack_size = mill_get_stack_size();\n    return ptr;\n}\n\nvoid mill_freestack(void *stack) {\n    /* Put the stack to the list of cached stacks. */\n    struct mill_slist_item *item = ((struct mill_slist_item*)stack) - 1;\n    mill_slist_push_back(&mill_cached_stacks, item);\n    if(mill_num_cached_stacks < mill_max_cached_stacks) {\n        ++mill_num_cached_stacks;\n        return;\n    }\n    /* We can't deallocate the stack we are running on at the moment.\n       Standard C free() is not required to work when it deallocates its\n       own stack from underneath itself. Instead, we'll deallocate one of\n       the unused cached stacks. */\n    item = mill_slist_pop(&mill_cached_stacks);\n    void *ptr = ((char*)(item + 1)) - mill_get_stack_size();\n#if HAVE_POSIX_MEMALIGN && HAVE_MPROTECT\n    int rc = mprotect(ptr, mill_page_size(), PROT_READ|PROT_WRITE);\n    mill_assert(rc == 0);\n#endif\n    free(ptr);\n}\n\n"
        },
        {
          "name": "stack.h",
          "type": "blob",
          "size": 1.61328125,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_STACK_INCLUDED\n#define MILL_STACK_INCLUDED\n\n#include <stddef.h>\n\n/* Purges all the existing cached stacks and preallocates 'count' new stacks\n   of size 'stack_size'. Sets errno in case of error. */\nvoid mill_preparestacks(int count, size_t stack_size);\n\n/* Allocates new stack. Returns pointer to the *top* of the stack.\n   For now we assume that the stack grows downwards. */\nvoid *mill_allocstack(size_t *stack_size);\n\n/* Deallocates a stack. The argument is pointer to the top of the stack. */\nvoid mill_freestack(void *stack);\n\n#endif\n"
        },
        {
          "name": "tcp.c",
          "type": "blob",
          "size": 14.154296875,
          "content": "    /*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include \"debug.h\"\n#include \"ip.h\"\n#include \"libmill.h\"\n#include \"utils.h\"\n\n/* The buffer size is based on typical Ethernet MTU (1500 bytes). Making it\n   smaller would yield small suboptimal packets. Making it higher would bring\n   no substantial benefit. The value is made smaller to account for IPv4/IPv6\n   and TCP headers. Few more bytes are subtracted to account for any possible\n   IP or TCP options */\n#ifndef MILL_TCP_BUFLEN\n#define MILL_TCP_BUFLEN (1500 - 68)\n#endif\n\nenum mill_tcptype {\n   MILL_TCPLISTENER,\n   MILL_TCPCONN\n};\n\nstruct mill_tcpsock_ {\n    enum mill_tcptype type;\n};\n\nstruct mill_tcplistener {\n    struct mill_tcpsock_ sock;\n    int fd;\n    int port;\n};\n\nstruct mill_tcpconn {\n    struct mill_tcpsock_ sock;\n    int fd;\n    size_t ifirst;\n    size_t ilen;\n    size_t olen;\n    char ibuf[MILL_TCP_BUFLEN];\n    char obuf[MILL_TCP_BUFLEN];\n    ipaddr addr;\n};\n\nstatic void mill_tcptune(int s) {\n    /* Make the socket non-blocking. */\n    int opt = fcntl(s, F_GETFL, 0);\n    if (opt == -1)\n        opt = 0;\n    int rc = fcntl(s, F_SETFL, opt | O_NONBLOCK);\n    mill_assert(rc != -1);\n    /*  Allow re-using the same local address rapidly. */\n    opt = 1;\n    rc = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt));\n    mill_assert(rc == 0);\n    /* If possible, prevent SIGPIPE signal when writing to the connection\n        already closed by the peer. */\n#ifdef SO_NOSIGPIPE\n    opt = 1;\n    rc = setsockopt (s, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof (opt));\n    mill_assert (rc == 0 || errno == EINVAL);\n#endif\n}\n\nstatic void tcpconn_init(struct mill_tcpconn *conn, int fd) {\n    conn->sock.type = MILL_TCPCONN;\n    conn->fd = fd;\n    conn->ifirst = 0;\n    conn->ilen = 0;\n    conn->olen = 0;\n}\n\nstruct mill_tcpsock_ *mill_tcplisten_(ipaddr addr, int backlog) {\n    /* Open the listening socket. */\n    int s = socket(mill_ipfamily(addr), SOCK_STREAM, 0);\n    if(s == -1)\n        return NULL;\n    mill_tcptune(s);\n\n    /* Start listening. */\n    int rc = bind(s, (struct sockaddr*)&addr, mill_iplen(addr));\n    if(rc != 0)\n        return NULL;\n    rc = listen(s, backlog);\n    if(rc != 0)\n        return NULL;\n\n    /* If the user requested an ephemeral port,\n       retrieve the port number assigned by the OS now. */\n    int port = mill_ipport(addr);\n    if(!port) {\n        ipaddr baddr;\n        socklen_t len = sizeof(ipaddr);\n        rc = getsockname(s, (struct sockaddr*)&baddr, &len);\n        if(rc == -1) {\n            int err = errno;\n            fdclean(s);\n            close(s);\n            errno = err;\n            return NULL;\n        }\n        port = mill_ipport(baddr);\n    }\n\n    /* Create the object. */\n    struct mill_tcplistener *l = malloc(sizeof(struct mill_tcplistener));\n    if(!l) {\n        fdclean(s);\n        close(s);\n        errno = ENOMEM;\n        return NULL;\n    }\n    l->sock.type = MILL_TCPLISTENER;\n    l->fd = s;\n    l->port = port;\n    errno = 0;\n    return &l->sock;\n}\n\nint mill_tcpport_(struct mill_tcpsock_ *s) {\n    if(s->type == MILL_TCPCONN) {\n        struct mill_tcpconn *c = (struct mill_tcpconn*)s;\n        return mill_ipport(c->addr);\n    }\n    else if(s->type == MILL_TCPLISTENER) {\n        struct mill_tcplistener *l = (struct mill_tcplistener*)s;\n        return l->port;\n    }\n    mill_assert(0);\n}\n\nstruct mill_tcpsock_ *mill_tcpaccept_(struct mill_tcpsock_ *s, int64_t deadline) {\n    if(s->type != MILL_TCPLISTENER)\n        mill_panic(\"trying to accept on a socket that isn't listening\");\n    struct mill_tcplistener *l = (struct mill_tcplistener*)s;\n    socklen_t addrlen;\n    ipaddr addr;\n    while(1) {\n        /* Try to get new connection (non-blocking). */\n        addrlen = sizeof(addr);\n        int as = accept(l->fd, (struct sockaddr *)&addr, &addrlen);\n        if (as >= 0) {\n            mill_tcptune(as);\n            struct mill_tcpconn *conn = malloc(sizeof(struct mill_tcpconn));\n            if(!conn) {\n                fdclean(as);\n                close(as);\n                errno = ENOMEM;\n                return NULL;\n            }\n            tcpconn_init(conn, as);\n            conn->addr = addr;\n            errno = 0;\n            return (tcpsock)conn;\n        }\n        mill_assert(as == -1);\n        if(errno != EAGAIN && errno != EWOULDBLOCK)\n            return NULL;\n        /* Wait till new connection is available. */\n        int rc = fdwait(l->fd, FDW_IN, deadline);\n        if(rc == 0) {\n            errno = ETIMEDOUT;\n            return NULL;\n        }\n        if(rc & FDW_ERR)\n            return NULL;\n        mill_assert(rc == FDW_IN);\n    }\n}\n\nstruct mill_tcpsock_ *mill_tcpconnect_(ipaddr addr, int64_t deadline) {\n    /* Open a socket. */\n    int s = socket(mill_ipfamily(addr), SOCK_STREAM, 0);\n    if(s == -1)\n        return NULL;\n    mill_tcptune(s);\n\n    /* Connect to the remote endpoint. */\n    int rc = connect(s, (struct sockaddr*)&addr, mill_iplen(addr));\n    if(rc != 0) {\n        mill_assert(rc == -1);\n        if(errno != EINPROGRESS)\n            return NULL;\n        rc = fdwait(s, FDW_OUT, deadline);\n        if(rc == 0) {\n            errno = ETIMEDOUT;\n            return NULL;\n        }\n        int err;\n        socklen_t errsz = sizeof(err);\n        rc = getsockopt(s, SOL_SOCKET, SO_ERROR, (void*)&err, &errsz);\n        if(rc != 0) {\n            err = errno;\n            fdclean(s);\n            close(s);\n            errno = err;\n            return NULL;\n        }\n        if(err != 0) {\n            fdclean(s);\n            close(s);\n            errno = err;\n            return NULL;\n        }\n    }\n\n    /* Create the object. */\n    struct mill_tcpconn *conn = malloc(sizeof(struct mill_tcpconn));\n    if(!conn) {\n        fdclean(s);\n        close(s);\n        errno = ENOMEM;\n        return NULL;\n    }\n    tcpconn_init(conn, s);\n    errno = 0;\n    return (tcpsock)conn;\n}\n\nsize_t mill_tcpsend_(struct mill_tcpsock_ *s, const void *buf, size_t len,\n      int64_t deadline) {\n    if(s->type != MILL_TCPCONN)\n        mill_panic(\"trying to send to an unconnected socket\");\n    struct mill_tcpconn *conn = (struct mill_tcpconn*)s;\n\n    /* If it fits into the output buffer copy it there and be done. */\n    if(conn->olen + len <= MILL_TCP_BUFLEN) {\n        memcpy(&conn->obuf[conn->olen], buf, len);\n        conn->olen += len;\n        errno = 0;\n        return len;\n    }\n\n    /* If it doesn't fit, flush the output buffer first. */\n    tcpflush(s, deadline);\n    if(errno != 0)\n        return 0;\n\n    /* Try to fit it into the buffer once again. */\n    if(conn->olen + len <= MILL_TCP_BUFLEN) {\n        memcpy(&conn->obuf[conn->olen], buf, len);\n        conn->olen += len;\n        errno = 0;\n        return len;\n    }\n\n    /* The data chunk to send is longer than the output buffer.\n       Let's do the sending in-place. */\n    char *pos = (char*)buf;\n    size_t remaining = len;\n    while(remaining) {\n        ssize_t sz = send(conn->fd, pos, remaining, 0);\n        if(sz == -1) {\n            /* Operating systems are inconsistent w.r.t. returning EPIPE and\n               ECONNRESET. Let's paper over it like this. */\n            if(errno == EPIPE) {\n                errno = ECONNRESET;\n                return 0;\n            }\n            if(errno != EAGAIN && errno != EWOULDBLOCK)\n                return 0;\n            int rc = fdwait(conn->fd, FDW_OUT, deadline);\n            if(rc == 0) {\n                errno = ETIMEDOUT;\n                return len - remaining;\n            }\n            continue;\n        }\n        pos += sz;\n        remaining -= sz;\n    }\n    errno = 0;\n    return len;\n}\n\nvoid mill_tcpflush_(struct mill_tcpsock_ *s, int64_t deadline) {\n    if(s->type != MILL_TCPCONN)\n        mill_panic(\"trying to send to an unconnected socket\");\n    struct mill_tcpconn *conn = (struct mill_tcpconn*)s;\n    if(!conn->olen) {\n        errno = 0;\n        return;\n    }\n    char *pos = conn->obuf;\n    size_t remaining = conn->olen;\n    while(remaining) {\n        ssize_t sz = send(conn->fd, pos, remaining, 0);\n        if(sz == -1) {\n            /* Operating systems are inconsistent w.r.t. returning EPIPE and\n               ECONNRESET. Let's paper over it like this. */\n            if(errno == EPIPE) {\n                errno = ECONNRESET;\n                return;\n            }\n            if(errno != EAGAIN && errno != EWOULDBLOCK)\n                return;\n            int rc = fdwait(conn->fd, FDW_OUT, deadline);\n            if(rc == 0) {\n                errno = ETIMEDOUT;\n                return;\n            }\n            continue;\n        }\n        pos += sz;\n        remaining -= sz;\n    }\n    conn->olen = 0;\n    errno = 0;\n}\n\nsize_t mill_tcprecv_(struct mill_tcpsock_ *s, void *buf, size_t len,\n      int64_t deadline) {\n    if(s->type != MILL_TCPCONN)\n        mill_panic(\"trying to receive from an unconnected socket\");\n    struct mill_tcpconn *conn = (struct mill_tcpconn*)s;\n    /* If there's enough data in the buffer it's easy. */\n    if(conn->ilen >= len) {\n        memcpy(buf, &conn->ibuf[conn->ifirst], len);\n        conn->ifirst += len;\n        conn->ilen -= len;\n        errno = 0;\n        return len;\n    }\n\n    /* Let's move all the data from the buffer first. */\n    char *pos = (char*)buf;\n    size_t remaining = len;\n    memcpy(pos, &conn->ibuf[conn->ifirst], conn->ilen);\n    pos += conn->ilen;\n    remaining -= conn->ilen;\n    conn->ifirst = 0;\n    conn->ilen = 0;\n\n    mill_assert(remaining);\n    while(1) {\n        if(remaining > MILL_TCP_BUFLEN) {\n            /* If we still have a lot to read try to read it in one go directly\n               into the destination buffer. */\n            ssize_t sz = recv(conn->fd, pos, remaining, 0);\n            if(!sz) {\n\t\t        errno = ECONNRESET;\n\t\t        return len - remaining;\n            }\n            if(sz == -1) {\n                if(errno != EAGAIN && errno != EWOULDBLOCK)\n                    return len - remaining;\n                sz = 0;\n            }\n            if((size_t)sz == remaining) {\n                errno = 0;\n                return len;\n            }\n            pos += sz;\n            remaining -= sz;\n        }\n        else {\n            /* If we have just a little to read try to read the full connection\n               buffer to minimise the number of system calls. */\n            ssize_t sz = recv(conn->fd, conn->ibuf, MILL_TCP_BUFLEN, 0);\n            if(!sz) {\n\t\t        errno = ECONNRESET;\n\t\t        return len - remaining;\n            }\n            if(sz == -1) {\n                if(errno != EAGAIN && errno != EWOULDBLOCK)\n                    return len - remaining;\n                sz = 0;\n            }\n            if((size_t)sz < remaining) {\n                memcpy(pos, conn->ibuf, sz);\n                pos += sz;\n                remaining -= sz;\n                conn->ifirst = 0;\n                conn->ilen = 0;\n            }\n            else {\n                memcpy(pos, conn->ibuf, remaining);\n                conn->ifirst = remaining;\n                conn->ilen = sz - remaining;\n                errno = 0;\n                return len;\n            }\n        }\n\n        /* Wait till there's more data to read. */\n        int res = fdwait(conn->fd, FDW_IN, deadline);\n        if(!res) {\n            errno = ETIMEDOUT;\n            return len - remaining;\n        }\n    }\n}\n\nsize_t mill_tcprecvuntil_(struct mill_tcpsock_ *s, void *buf, size_t len,\n      const char *delims, size_t delimcount, int64_t deadline) {\n    if(s->type != MILL_TCPCONN)\n        mill_panic(\"trying to receive from an unconnected socket\");\n    char *pos = (char*)buf;\n    size_t i;\n    for(i = 0; i != len; ++i, ++pos) {\n        size_t res = tcprecv(s, pos, 1, deadline);\n        if(res == 1) {\n            size_t j;\n            for(j = 0; j != delimcount; ++j)\n                if(*pos == delims[j])\n                    return i + 1;\n        }\n        if (errno != 0)\n            return i + res;\n    }\n    errno = ENOBUFS;\n    return len;\n}\n\nvoid mill_tcpshutdown_(struct mill_tcpsock_ *s, int how) {\n    mill_assert(s->type == MILL_TCPCONN);\n    struct mill_tcpconn *c = (struct mill_tcpconn*)s;\n    int rc = shutdown(c->fd, how);\n    mill_assert(rc == 0 || errno == ENOTCONN);\n}\n\nvoid mill_tcpclose_(struct mill_tcpsock_ *s) {\n    if(s->type == MILL_TCPLISTENER) {\n        struct mill_tcplistener *l = (struct mill_tcplistener*)s;\n        fdclean(l->fd);\n        int rc = close(l->fd);\n        mill_assert(rc == 0);\n        free(l);\n        return;\n    }\n    if(s->type == MILL_TCPCONN) {\n        struct mill_tcpconn *c = (struct mill_tcpconn*)s;\n        fdclean(c->fd);\n        int rc = close(c->fd);\n        mill_assert(rc == 0);\n        free(c);\n        return;\n    }\n    mill_assert(0);\n}\n\nipaddr mill_tcpaddr_(struct mill_tcpsock_ *s) {\n    if(s->type != MILL_TCPCONN)\n        mill_panic(\"trying to get address from a socket that isn't connected\");\n    struct mill_tcpconn *l = (struct mill_tcpconn *)s;\n    return l->addr;\n}\n\n/* This function is to be used only internally by libmill. Take into account\n   that once there are data in tcpsock's tx/rx buffers, the state of fd may\n   not match the state of tcpsock object. Works only on connected sockets. */\nint mill_tcpfd(struct mill_tcpsock_ *s) {\n    return ((struct mill_tcpconn*)s)->fd;\n}\n\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "timer.c",
          "type": "blob",
          "size": 5.4453125,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <stdint.h>\n#include <sys/time.h>\n#include <time.h>\n\n#if defined __APPLE__\n#include <mach/mach_time.h>\nstatic mach_timebase_info_data_t mill_mtid = {0};\n#endif\n\n#include \"libmill.h\"\n#include \"timer.h\"\n#include \"utils.h\"\n\n/* 1 millisecond expressed in CPU ticks. The value is chosen is such a way that\n   it works reasonably well for CPU frequencies above 500MHz. On significanly\n   slower machines you may wish to reconsider. */\n#define MILL_CLOCK_PRECISION 1000000\n\n/* Returns current time by querying the operating system. */\nstatic int64_t mill_os_time(void) {\n#if defined __APPLE__\n    if (mill_slow(!mill_mtid.denom))\n        mach_timebase_info(&mill_mtid);\n    uint64_t ticks = mach_absolute_time();\n    return (int64_t)(ticks * mill_mtid.numer / mill_mtid.denom / 1000000);\n#elif defined CLOCK_MONOTONIC\n    struct timespec ts;\n    int rc = clock_gettime(CLOCK_MONOTONIC, &ts);\n    mill_assert (rc == 0);\n    return ((int64_t)ts.tv_sec) * 1000 + (((int64_t)ts.tv_nsec) / 1000000);\n#else\n    struct timeval tv;\n    int rc = gettimeofday(&tv, NULL);\n    assert(rc == 0);\n    return ((int64_t)tv.tv_sec) * 1000 + (((int64_t)tv.tv_usec) / 1000);\n#endif\n}\n\nint64_t mill_now_(void) {\n#if (defined __GNUC__ || defined __clang__) && \\\n      (defined __i386__ || defined __x86_64__)\n    /* Get the timestamp counter. This is time since startup, expressed in CPU\n       cycles. Unlike gettimeofday() or similar function, it's extremely fast -\n       it takes only few CPU cycles to evaluate. */\n    uint32_t low;\n    uint32_t high;\n    __asm__ volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n    int64_t tsc = (int64_t)((uint64_t)high << 32 | low);\n    /* These global variables are used to hold the last seen timestamp counter\n       and last seen time measurement. We'll initilise them the first time\n       this function is called. */\n    static int64_t last_tsc = -1;\n    static int64_t last_now = -1;\n    if(mill_slow(last_tsc < 0)) {\n        last_tsc = tsc;\n        last_now = mill_os_time();\n    }   \n    /* If TSC haven't jumped back or progressed more than 1/2 ms, we can use\n       the cached time value. */\n    if(mill_fast(tsc - last_tsc <= (MILL_CLOCK_PRECISION / 2) &&\n          tsc >= last_tsc))\n        return last_now;\n    /* It's more than 1/2 ms since we've last measured the time.\n       We'll do a new measurement now. */\n    last_tsc = tsc;\n    last_now = mill_os_time();\n    return last_now;\n#else\n    return mill_os_time();\n#endif\n}\n\n/* Global linked list of all timers. The list is ordered.\n   First timer to be resume comes first and so on. */\nstatic struct mill_list mill_timers = {0};\n\nvoid mill_timer_add(struct mill_timer *timer, int64_t deadline,\n      mill_timer_callback callback) {\n    mill_assert(deadline >= 0);\n    timer->expiry = deadline;\n    timer->callback = callback;\n    /* Move the timer into the right place in the ordered list\n       of existing timers. TODO: This is an O(n) operation! */\n    struct mill_list_item *it = mill_list_begin(&mill_timers);\n    while(it) {\n        struct mill_timer *tm = mill_cont(it, struct mill_timer, item);\n        /* If multiple timers expire at the same momemt they will be fired\n           in the order they were created in (> rather than >=). */\n        if(tm->expiry > timer->expiry)\n            break;\n        it = mill_list_next(it);\n    }\n    mill_list_insert(&mill_timers, &timer->item, it);\n}\n\nvoid mill_timer_rm(struct mill_timer *timer) {\n    mill_assert(timer->expiry >= 0);\n    mill_list_erase(&mill_timers, &timer->item);\n    timer->expiry = -1;\n}\n\nint mill_timer_next(void) {\n    if(mill_list_empty(&mill_timers))\n        return -1;\n    int64_t nw = now();\n    int64_t expiry = mill_cont(mill_list_begin(&mill_timers),\n        struct mill_timer, item)->expiry;\n    return (int) (nw >= expiry ? 0 : expiry - nw);\n}\n\nint mill_timer_fire(void) {\n    /* Avoid getting current time if there are no timers anyway. */\n    if(mill_list_empty(&mill_timers))\n        return 0;\n    int64_t nw = now();\n    int fired = 0;\n    while(!mill_list_empty(&mill_timers)) {\n        struct mill_timer *tm = mill_cont(\n            mill_list_begin(&mill_timers), struct mill_timer, item);\n        if(tm->expiry > nw)\n            break;\n        mill_list_erase(&mill_timers, mill_list_begin(&mill_timers));\n        tm->expiry = -1;\n        if(tm->callback)\n            tm->callback(tm);\n        fired = 1;\n    }\n    return fired;\n}\n\nvoid mill_timer_postfork(void) {\n    mill_list_init(&mill_timers);\n}\n\n"
        },
        {
          "name": "timer.h",
          "type": "blob",
          "size": 2.2890625,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_TIMER_INCLUDED\n#define MILL_TIMER_INCLUDED\n\n#include <stdint.h>\n\n#include \"list.h\"\n\nstruct mill_timer;\n\ntypedef void (*mill_timer_callback)(struct mill_timer *timer);\n\nstruct mill_timer {\n    /* Item in the global list of all timers. */\n    struct mill_list_item item;\n    /* The deadline when the timer expires. -1 if the timer is not active. */\n    int64_t expiry;\n    /* Callback invoked when timer expires. Pfui Teufel! */\n    mill_timer_callback callback;\n};\n\n/* Test wheather the timer is active. */\n#define mill_timer_enabled(tm)  ((tm)->expiry >= 0)\n\n/* Add a timer for the running coroutine. */\nvoid mill_timer_add(struct mill_timer *timer, int64_t deadline,\n    mill_timer_callback callback);\n\n/* Remove the timer associated with the running coroutine. */\nvoid mill_timer_rm(struct mill_timer *timer);\n\n/* Number of milliseconds till the next timer expires.\n   If there are no timers returns -1. */\nint mill_timer_next(void);\n\n/* Resumes all coroutines whose timers have already expired.\n   Returns zero if no coroutine was resumed, 1 otherwise. */\nint mill_timer_fire(void);\n\n/* Called after fork in the child process to deactivate all the timers\n   inherited from the parent. */\nvoid mill_timer_postfork(void);\n\n#endif\n\n"
        },
        {
          "name": "tutorial",
          "type": "tree",
          "content": null
        },
        {
          "name": "udp.c",
          "type": "blob",
          "size": 3.8818359375,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include \"ip.h\"\n#include \"libmill.h\"\n#include \"utils.h\"\n\nstruct mill_udpsock_ {\n    int fd;\n    int port;\n};\n\nstatic void mill_udptune(int s) {\n    /* Make the socket non-blocking. */\n    int opt = fcntl(s, F_GETFL, 0);\n    if (opt == -1)\n        opt = 0;\n    int rc = fcntl(s, F_SETFL, opt | O_NONBLOCK);\n    mill_assert(rc != -1);\n}\n\nstruct mill_udpsock_ *mill_udplisten_(ipaddr addr) {\n    /* Open the listening socket. */\n    int s = socket(mill_ipfamily(addr), SOCK_DGRAM, 0);\n    if(s == -1)\n        return NULL;\n    mill_udptune(s);\n\n    /* Start listening. */\n    int rc = bind(s, (struct sockaddr*)&addr, mill_iplen(addr));\n    if(rc != 0)\n        return NULL;\n\n    /* If the user requested an ephemeral port,\n       retrieve the port number assigned by the OS now. */\n    int port = mill_ipport(addr);\n    if(!port) {\n        ipaddr baddr;\n        socklen_t len = sizeof(ipaddr);\n        rc = getsockname(s, (struct sockaddr*)&baddr, &len);\n        if(rc == -1) {\n            int err = errno;\n            fdclean(s);\n            close(s);\n            errno = err;\n            return NULL;\n        }\n        port = mill_ipport(baddr);\n    }\n\n    /* Create the object. */\n    struct mill_udpsock_ *us = malloc(sizeof(struct mill_udpsock_));\n    if(!us) {\n        fdclean(s);\n        close(s);\n        errno = ENOMEM;\n        return NULL;\n    }\n    us->fd = s;\n    us->port = port;\n    errno = 0;\n    return us;\n}\n\nint mill_udpport_(struct mill_udpsock_ *s) {\n    return s->port;\n}\n\nvoid mill_udpsend_(struct mill_udpsock_ *s, ipaddr addr,\n        const void *buf, size_t len) {\n    struct sockaddr *saddr = (struct sockaddr*) &addr;\n    ssize_t ss = sendto(s->fd, buf, len, 0, saddr, saddr->sa_family ==\n        AF_INET ? sizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6));\n    if(mill_fast(ss == (ssize_t)len)) {\n        errno = 0;\n        return;\n    }\n    mill_assert(ss < 0);\n    if(errno == EAGAIN || errno == EWOULDBLOCK)\n        errno = 0;\n}\n\nsize_t mill_udprecv_(struct mill_udpsock_ *s, ipaddr *addr,\n      void *buf, size_t len, int64_t deadline) {\n    ssize_t ss;\n    while(1) {\n        socklen_t slen = sizeof(ipaddr);\n        ss = recvfrom(s->fd, buf, len, 0,\n            (struct sockaddr*)addr, &slen);\n        if(ss >= 0)\n            break;\n        if(errno != EAGAIN && errno != EWOULDBLOCK)\n            return 0;\n        int rc = fdwait(s->fd, FDW_IN, deadline);\n        if(rc == 0) {\n            errno = ETIMEDOUT;\n            return 0;\n        }\n    }\n    errno = 0;\n    return (size_t)ss;\n}\n\nvoid mill_udpclose_(struct mill_udpsock_ *s) {\n    fdclean(s->fd);\n    int rc = close(s->fd);\n    mill_assert(rc == 0);\n    free(s);\n}\n\n"
        },
        {
          "name": "unix.c",
          "type": "blob",
          "size": 13.146484375,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <unistd.h>\n\n#include \"debug.h\"\n#include \"libmill.h\"\n#include \"utils.h\"\n\n#ifndef MILL_UNIX_BUFLEN\n#define MILL_UNIX_BUFLEN (4096)\n#endif\n\nenum mill_unixtype {\n   MILL_UNIXLISTENER,\n   MILL_UNIXCONN\n};\n\nstruct mill_unixsock_ {\n    enum mill_unixtype type;\n};\n\nstruct mill_unixlistener {\n    struct mill_unixsock_ sock;\n    int fd;\n};\n\nstruct mill_unixconn {\n    struct mill_unixsock_ sock;\n    int fd;\n    size_t ifirst;\n    size_t ilen;\n    size_t olen;\n    char ibuf[MILL_UNIX_BUFLEN];\n    char obuf[MILL_UNIX_BUFLEN];\n};\n\nstatic void mill_unixtune(int s) {\n    /* Make the socket non-blocking. */\n    int opt = fcntl(s, F_GETFL, 0);\n    if (opt == -1)\n        opt = 0;\n    int rc = fcntl(s, F_SETFL, opt | O_NONBLOCK);\n    mill_assert(rc != -1);\n    /* If possible, prevent SIGPIPE signal when writing to the connection\n        already closed by the peer. */\n#ifdef SO_NOSIGPIPE\n    opt = 1;\n    rc = setsockopt (s, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof (opt));\n    mill_assert (rc == 0 || errno == EINVAL);\n#endif\n}\n\nstatic int mill_unixresolve(const char *addr, struct sockaddr_un *su) {\n    mill_assert(su);\n    if (strlen(addr) >= sizeof(su->sun_path)) {\n        errno = EINVAL;\n        return -1;\n    }\n    su->sun_family = AF_UNIX;\n    strncpy(su->sun_path, addr, sizeof(su->sun_path));\n    errno = 0;\n    return 0;\n}\n\nstatic void unixconn_init(struct mill_unixconn *conn, int fd) {\n    conn->sock.type = MILL_UNIXCONN;\n    conn->fd = fd;\n    conn->ifirst = 0;\n    conn->ilen = 0;\n    conn->olen = 0;\n}\n\nstruct mill_unixsock_ *mill_unixlisten_(const char *addr, int backlog) {\n    struct sockaddr_un su;\n    int rc = mill_unixresolve(addr, &su);\n    if (rc != 0) {\n        return NULL;\n    }\n    /* Open the listening socket. */\n    int s = socket(AF_UNIX, SOCK_STREAM, 0);\n    if(s == -1)\n        return NULL;\n    mill_unixtune(s);\n\n    /* Start listening. */\n    rc = bind(s, (struct sockaddr*)&su, sizeof(struct sockaddr_un));\n    if(rc != 0)\n        return NULL;\n    rc = listen(s, backlog);\n    if(rc != 0)\n        return NULL;\n\n    /* Create the object. */\n    struct mill_unixlistener *l = malloc(sizeof(struct mill_unixlistener));\n    if(!l) {\n        fdclean(s);\n        close(s);\n        errno = ENOMEM;\n        return NULL;\n    }\n    l->sock.type = MILL_UNIXLISTENER;\n    l->fd = s;\n    errno = 0;\n    return &l->sock;\n}\n\nstruct mill_unixsock_ *mill_unixaccept_(struct mill_unixsock_ *s,\n      int64_t deadline) {\n    if(s->type != MILL_UNIXLISTENER)\n        mill_panic(\"trying to accept on a socket that isn't listening\");\n    struct mill_unixlistener *l = (struct mill_unixlistener*)s;\n    while(1) {\n        /* Try to get new connection (non-blocking). */\n        int as = accept(l->fd, NULL, NULL);\n        if (as >= 0) {\n            mill_unixtune(as);\n            struct mill_unixconn *conn = malloc(sizeof(struct mill_unixconn));\n            if(!conn) {\n                fdclean(as);\n                close(as);\n                errno = ENOMEM;\n                return NULL;\n            }\n            unixconn_init(conn, as);\n            errno = 0;\n            return (struct mill_unixsock_*)conn;\n        }\n        mill_assert(as == -1);\n        if(errno != EAGAIN && errno != EWOULDBLOCK)\n            return NULL;\n        /* Wait till new connection is available. */\n        int rc = fdwait(l->fd, FDW_IN, deadline);\n        if(rc == 0) {\n            errno = ETIMEDOUT;\n            return NULL;\n        }\n        if(rc & FDW_ERR)\n            return NULL;\n        mill_assert(rc == FDW_IN);\n    }\n}\n\nstruct mill_unixsock_ *mill_unixconnect_(const char *addr) {\n    struct sockaddr_un su;\n    int rc = mill_unixresolve(addr, &su);\n    if (rc != 0) {\n        return NULL;\n    }\n\n    /* Open a socket. */\n    int s = socket(AF_UNIX,  SOCK_STREAM, 0);\n    if(s == -1)\n        return NULL;\n    mill_unixtune(s);\n\n    /* Connect to the remote endpoint. */\n    rc = connect(s, (struct sockaddr*)&su, sizeof(struct sockaddr_un));\n    if(rc != 0) {\n        int err = errno;\n        mill_assert(rc == -1);\n        fdclean(s);\n        close(s);\n        errno = err;\n        return NULL;\n    }\n\n    /* Create the object. */\n    struct mill_unixconn *conn = malloc(sizeof(struct mill_unixconn));\n    if(!conn) {\n        fdclean(s);\n        close(s);\n        errno = ENOMEM;\n        return NULL;\n    }\n    unixconn_init(conn, s);\n    errno = 0;\n    return (struct mill_unixsock_*)conn;\n}\n\nvoid mill_unixpair_(struct mill_unixsock_ **a, struct mill_unixsock_ **b) {\n    if(!a || !b) {\n        errno = EINVAL;\n        return;\n    }\n    int fd[2];\n    int rc = socketpair(AF_UNIX, SOCK_STREAM, 0, fd);\n    if (rc != 0)\n        return;\n    mill_unixtune(fd[0]);\n    mill_unixtune(fd[1]);\n    struct mill_unixconn *conn = malloc(sizeof(struct mill_unixconn));\n    if(!conn) {\n        fdclean(fd[0]);\n        close(fd[0]);\n        fdclean(fd[1]);\n        close(fd[1]);\n        errno = ENOMEM;\n        return;\n    }\n    unixconn_init(conn, fd[0]);\n    *a = (struct mill_unixsock_*)conn;\n    conn = malloc(sizeof(struct mill_unixconn));\n    if(!conn) {\n        free(*a);\n        fdclean(fd[0]);\n        close(fd[0]);\n        fdclean(fd[1]);\n        close(fd[1]);\n        errno = ENOMEM;\n        return;\n    }\n    unixconn_init(conn, fd[1]);\n    *b = (struct mill_unixsock_*)conn;\n    errno = 0;\n}\n\nsize_t mill_unixsend_(struct mill_unixsock_ *s, const void *buf, size_t len,\n      int64_t deadline) {\n    if(s->type != MILL_UNIXCONN)\n        mill_panic(\"trying to send to an unconnected socket\");\n    struct mill_unixconn *conn = (struct mill_unixconn*)s;\n\n    /* If it fits into the output buffer copy it there and be done. */\n    if(conn->olen + len <= MILL_UNIX_BUFLEN) {\n        memcpy(&conn->obuf[conn->olen], buf, len);\n        conn->olen += len;\n        errno = 0;\n        return len;\n    }\n\n    /* If it doesn't fit, flush the output buffer first. */\n    unixflush(s, deadline);\n    if(errno != 0)\n        return 0;\n\n    /* Try to fit it into the buffer once again. */\n    if(conn->olen + len <= MILL_UNIX_BUFLEN) {\n        memcpy(&conn->obuf[conn->olen], buf, len);\n        conn->olen += len;\n        errno = 0;\n        return len;\n    }\n\n    /* The data chunk to send is longer than the output buffer.\n       Let's do the sending in-place. */\n    char *pos = (char*)buf;\n    size_t remaining = len;\n    while(remaining) {\n        ssize_t sz = send(conn->fd, pos, remaining, 0);\n        if(sz == -1) {\n            /* Operating systems are inconsistent w.r.t. returning EPIPE and\n               ECONNRESET. Let's paper over it like this. */\n            if(errno == EPIPE) {\n                errno = ECONNRESET;\n                return 0;\n            }\n            if(errno != EAGAIN && errno != EWOULDBLOCK)\n                return 0;\n            int rc = fdwait(conn->fd, FDW_OUT, deadline);\n            if(rc == 0) {\n                errno = ETIMEDOUT;\n                return len - remaining;\n            }\n            continue;\n        }\n        pos += sz;\n        remaining -= sz;\n    }\n    errno = 0;\n    return len;\n}\n\nvoid mill_unixflush_(struct mill_unixsock_ *s, int64_t deadline) {\n    if(s->type != MILL_UNIXCONN)\n        mill_panic(\"trying to send to an unconnected socket\");\n    struct mill_unixconn *conn = (struct mill_unixconn*)s;\n    if(!conn->olen) {\n        errno = 0;\n        return;\n    }\n    char *pos = conn->obuf;\n    size_t remaining = conn->olen;\n    while(remaining) {\n        ssize_t sz = send(conn->fd, pos, remaining, 0);\n        if(sz == -1) {\n            /* Operating systems are inconsistent w.r.t. returning EPIPE and\n               ECONNRESET. Let's paper over it like this. */\n            if(errno == EPIPE) {\n                errno = ECONNRESET;\n                return;\n            }\n            if(errno != EAGAIN && errno != EWOULDBLOCK)\n                return;\n            int rc = fdwait(conn->fd, FDW_OUT, deadline);\n            if(rc == 0) {\n                errno = ETIMEDOUT;\n                return;\n            }\n            continue;\n        }\n        pos += sz;\n        remaining -= sz;\n    }\n    conn->olen = 0;\n    errno = 0;\n}\n\nsize_t mill_unixrecv_(struct mill_unixsock_ *s, void *buf, size_t len,\n      int64_t deadline) {\n    if(s->type != MILL_UNIXCONN)\n        mill_panic(\"trying to receive from an unconnected socket\");\n    struct mill_unixconn *conn = (struct mill_unixconn*)s;\n    /* If there's enough data in the buffer it's easy. */\n    if(conn->ilen >= len) {\n        memcpy(buf, &conn->ibuf[conn->ifirst], len);\n        conn->ifirst += len;\n        conn->ilen -= len;\n        errno = 0;\n        return len;\n    }\n\n    /* Let's move all the data from the buffer first. */\n    char *pos = (char*)buf;\n    size_t remaining = len;\n    memcpy(pos, &conn->ibuf[conn->ifirst], conn->ilen);\n    pos += conn->ilen;\n    remaining -= conn->ilen;\n    conn->ifirst = 0;\n    conn->ilen = 0;\n\n    mill_assert(remaining);\n    while(1) {\n        if(remaining > MILL_UNIX_BUFLEN) {\n            /* If we still have a lot to read try to read it in one go directly\n               into the destination buffer. */\n            ssize_t sz = recv(conn->fd, pos, remaining, 0);\n            if(!sz) {\n                errno = ECONNRESET;\n                return len - remaining;\n            }\n            if(sz == -1) {\n                if(errno != EAGAIN && errno != EWOULDBLOCK)\n                    return len - remaining;\n                sz = 0;\n            }\n            if((size_t)sz == remaining) {\n                errno = 0;\n                return len;\n            }\n            pos += sz;\n            remaining -= sz;\n        }\n        else {\n            /* If we have just a little to read try to read the full connection\n               buffer to minimise the number of system calls. */\n            ssize_t sz = recv(conn->fd, conn->ibuf, MILL_UNIX_BUFLEN, 0);\n            if(!sz) {\n                errno = ECONNRESET;\n                return len - remaining;\n            }\n            if(sz == -1) {\n                if(errno != EAGAIN && errno != EWOULDBLOCK)\n                    return len - remaining;\n                sz = 0;\n            }\n            if((size_t)sz < remaining) {\n                memcpy(pos, conn->ibuf, sz);\n                pos += sz;\n                remaining -= sz;\n                conn->ifirst = 0;\n                conn->ilen = 0;\n            }\n            else {\n                memcpy(pos, conn->ibuf, remaining);\n                conn->ifirst = remaining;\n                conn->ilen = sz - remaining;\n                errno = 0;\n                return len;\n            }\n        }\n\n        /* Wait till there's more data to read. */\n        int res = fdwait(conn->fd, FDW_IN, deadline);\n        if(!res) {\n            errno = ETIMEDOUT;\n            return len - remaining;\n        }\n    }\n}\n\nsize_t mill_unixrecvuntil_(struct mill_unixsock_ *s, void *buf, size_t len,\n      const char *delims, size_t delimcount, int64_t deadline) {\n    if(s->type != MILL_UNIXCONN)\n        mill_panic(\"trying to receive from an unconnected socket\");\n    unsigned char *pos = (unsigned char*)buf;\n    size_t i;\n    for(i = 0; i != len; ++i, ++pos) {\n        size_t res = unixrecv(s, pos, 1, deadline);\n        if(res == 1) {\n            size_t j;\n            for(j = 0; j != delimcount; ++j)\n                if(*pos == delims[j])\n                    return i + 1;\n        }\n        if (errno != 0)\n            return i + res;\n    }\n    errno = ENOBUFS;\n    return len;\n}\n\nvoid mill_unixshutdown_(struct mill_unixsock_ *s, int how) {\n    mill_assert(s->type == MILL_UNIXCONN);\n    struct mill_unixconn *c = (struct mill_unixconn*)s;\n    int rc = shutdown(c->fd, how);\n    mill_assert(rc == 0 || errno == ENOTCONN);\n}\n\nvoid mill_unixclose_(struct mill_unixsock_ *s) {\n    if(s->type == MILL_UNIXLISTENER) {\n        struct mill_unixlistener *l = (struct mill_unixlistener*)s;\n        fdclean(l->fd);\n        int rc = close(l->fd);\n        mill_assert(rc == 0);\n        free(l);\n        return;\n    }\n    if(s->type == MILL_UNIXCONN) {\n        struct mill_unixconn *c = (struct mill_unixconn*)s;\n        fdclean(c->fd);\n        int rc = close(c->fd);\n        mill_assert(rc == 0);\n        free(c);\n        return;\n    }\n    mill_assert(0);\n}\n\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 2.333984375,
          "content": "/*\n\n  Copyright (c) 2015 Martin Sustrik\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"),\n  to deal in the Software without restriction, including without limitation\n  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom\n  the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n*/\n\n#ifndef MILL_UTILS_H_INCLUDED\n#define MILL_UTILS_H_INCLUDED\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*  Takes a pointer to a member variable and computes pointer to the structure\n    that contains it. 'type' is type of the structure, not the member. */\n#define mill_cont(ptr, type, member) \\\n    (ptr ? ((type*) (((char*) ptr) - offsetof(type, member))) : NULL)\n\n/* Compile-time assert. */\n#define MILL_CT_ASSERT_HELPER2(prefix, line) \\\n    prefix##line\n#define MILL_CT_ASSERT_HELPER1(prefix, line) \\\n    MILL_CT_ASSERT_HELPER2(prefix, line)\n#define MILL_CT_ASSERT(x) \\\n    typedef int MILL_CT_ASSERT_HELPER1(ct_assert_,__COUNTER__) [(x) ? 1 : -1]\n\n#if defined __GNUC__ || defined __llvm__\n#define mill_fast(x) __builtin_expect(!!(x), 1)\n#define mill_slow(x) __builtin_expect(!!(x), 0)\n#else\n#define mill_fast(x) (x)\n#define mill_slow(x) (x)\n#endif\n\n/* Define our own assert. This way we are sure that it stays in place even\n   if the standard C assert would be thrown away by the compiler. */\n#define mill_assert(x) \\\n    do {\\\n        if (mill_slow(!(x))) {\\\n            fprintf(stderr, \"Assert failed: \" #x \" (%s:%d)\\n\",\\\n                __FILE__, __LINE__);\\\n            fflush(stderr);\\\n            abort();\\\n        }\\\n    } while (0)\n\n#endif\n\n"
        }
      ]
    }
  ]
}