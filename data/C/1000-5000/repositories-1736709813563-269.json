{
  "metadata": {
    "timestamp": 1736709813563,
    "page": 269,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "MiSTer-devel/Main_MiSTer",
      "stars": 3095,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.259765625,
          "content": "# ignore backup files\n*~\n\n# ignore vi swapfiles\n.*.swp\n\n# ignore compiled python\n*pyc\n\n# ignore some backup files\n*bak\n\n# ignore some c files\n*\\.o\n*\\.d\n\n# ignore dropbox files\n.dropbox.attr\n\n# ignore directories\nDebug\ngcc-*\n\nhost\n*.lst\n*.elf\n*.map\n*.user\n.vs\nMiSTer\n"
        },
        {
          "name": "DiskImage.cpp",
          "type": "blob",
          "size": 134.4033203125,
          "content": "#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"DiskImage.h\"\n\n#define ERR_OPEN        \"Error: can't open source file\"\n#define ERR_GETLEN      \"Error: can't get file length!\"\n#define ERR_NOMEM       \"Error: no memory!\"\n#define ERR_FORMAT      \"Error: incorrect format\"\n#define ERR_FILEVER     \"Error: unknown version of\"\n#define ERR_FILECRC     \"Error: bad file CRC\"\n#define ERR_CANTWRITE   \"Error: write to file failed!\"\n#define ERR_UNKFORMAT   \"Error: Unknown format of source file!\"\n#define ERR_MANYCYLS    \"Error: out of 256 cylinders in opening source file!\"\n#define ERR_MANYSIDS    \"Error: out of 2 surfaces in opening source file!\"\n#define ERR_IMPOSSIBLE  \"Error: impossible format in opening source file!\"\n#define ERR_CORRUPT     \"Error: source file is corrupted!\"\n#define ERR_TD0DOSALLOC \"Error: files TD0 in 'DOS Allocated sectors were copied' format not supported!\"\n\n#define STR_CREATEDISKNAME \"MiSTer    \"\n\nchar errsect[] = \"ERROR: THIS SECTOR NOT FOUND OR IN NON TR-DOS FORMAT!\";\n\nenum TDiskImageType { DIT_UNK, DIT_SCL, DIT_FDI, DIT_TD0, DIT_UDI, DIT_HOB, DIT_FDD };\n\nstruct VGFIND_TRACK\n{\n\tunsigned char *TrackPointer;\n\tunsigned char *ClkPointer;\n\tunsigned int TrackLength;\n\tbool FoundTrack;\n};\n\n\nstruct VGFIND_ADM\n{\n\tunsigned char* TrackPointer;\n\tunsigned char* ClkPointer;\n\tunsigned int TrackLength;\n\n\tunsigned char *ADMPointer;\n\tunsigned int ADMLength;\n\n\tunsigned int MarkedOffsetADM;\n\tunsigned int OffsetADM;\n\tunsigned int OffsetEndADM;\n\tbool FoundADM;\n\tbool CRCOK;\n};\n\n\nstruct VGFIND_SECTOR\n{\n\tVGFIND_ADM vgfa;\n\n\tunsigned char *SectorPointer;\n\tunsigned int SectorLength;\n\n\tunsigned int MarkedOffsetSector;\n\tunsigned int OffsetSector;\n\tunsigned int OffsetEndSector;\n\tbool FoundDATA;\n\tbool CRCOK;\n\tunsigned char DataMarker;\n};\n\n\nclass TDiskImage\n{\n\tunsigned int FTrackLength[256][256];\n\tunsigned char* FTracksPtr[256][256][2];\n\n\tTDiskImageType FType;\n\n\tunsigned short MakeVGCRC(unsigned char *data, unsigned long length);\npublic:\n\tbool Changed;\n\n\tbool ReadOnly;\n\tbool DiskPresent;\n\tunsigned char MaxTrack;\n\tunsigned char MaxSide;\n\n\tTDiskImage();\n\t~TDiskImage();\n\n\tbool FindTrack(unsigned char CYL, unsigned char SIDE, VGFIND_TRACK *vgft);\n\tbool FindADMark(unsigned char CYL, unsigned char SIDE,\n\t\tunsigned int FromOffset,\n\t\tVGFIND_ADM *vgfa);\n\tbool FindSector(unsigned char CYL, unsigned char SIDE,\n\t\tunsigned char SECT,\n\t\tVGFIND_SECTOR *vgfs, unsigned int FromOffset = 0);\n\tvoid ApplySectorCRC(VGFIND_SECTOR vgfs);\n\n\n\tvoid Open(const char *filename, bool ReadOnly);\n\n\tvoid writeTRD(fileTYPE *hfile);\n\n\tvoid readSCL(int hfile, bool readonly);\n\tvoid readFDI(int hfile, bool readonly);\n\tvoid readUDI(int hfile, bool readonly);\n\tvoid readTD0(int hfile, bool readonly);\n\tvoid readFDD(int hfile, bool readonly);\n\tvoid readHOB(int hfile);\n\n\tvoid formatTRDOS(unsigned int tracks, unsigned int sides);\n\n\tvoid ShowError(const char *str);\n};\n\n#pragma pack(1)\nstruct UDI_HEADER               // 16 bytes\n{\n\tunsigned char ID[4];\n\tunsigned long UnpackedLength;\n\tunsigned char Version;\n\tunsigned char MaxCylinder;\n\tunsigned char MaxSide;\n\tunsigned char _zero;\n\tunsigned long ExtHdrLength;\n};\n\nstruct TD0_MAIN_HEADER          // 12 bytes\n{\n\tchar ID[2];                  // +0:  \"TD\" - 'Normal'; \"td\" - packed LZH ('New Advanced data compression')\n\tunsigned char __t;           // +2:  = 0x00\n\tunsigned char __1;           // +3:  ???\n\tunsigned char Ver;           // +4:  Source version  (1.0 -> 10, ..., 2.1 -> 21)\n\tunsigned char __2;           // +5:  ???\n\tunsigned char DiskType;      // +6:  Source disk type\n\tunsigned char Info;          // +7:  D7-наличие image info\n\tunsigned char DataDOS;       // +8:  if(=0)'All sectors were copied', else'DOS Allocated sectors were copied'\n\tunsigned char ChkdSides;     // +9:  if(=1)'One side was checked', else'Both sides were checked'\n\tunsigned short CRC;          // +A:  CRC хидера TD0_MAIN_HEADER (кроме байт с CRC)\n};\n\nstruct TD0_INFO_DATA             // 10 байт без строки коментария...\n{\n\tunsigned short CRC;          // +0:  CRC для структуры COMMENT_DATA (без байтов CRC)\n\tunsigned short strLen;       // +2:  Длина строки коментария\n\tunsigned char Year;          // +4:  Дата создания - год (1900 + X)\n\tunsigned char Month;         // +5:  Дата создания - месяц (Январь=0, Февраль=1,...)\n\tunsigned char Day;           // +6:  Дата создания - число\n\tunsigned char Hours;         // +7:  Время создания - часы\n\tunsigned char Minutes;       // +8:  Время создания - минуты\n\tunsigned char Seconds;       // +9:  Время создания - секунды\n};\n\nstruct TD0_TRACK_HEADER         // 4 bytes\n{\n\tunsigned char SectorCount;\n\tunsigned char Track;\n\tunsigned char Side;\n\tunsigned char CRCL;\n};\n\nstruct TD0_SECT_HEADER          // 8 bytes\n{\n\tunsigned char ADRM[6];\n\tunsigned short DataLength;\n};\n\nstruct FDD_MAIN_HEADER\n{\n\tchar ID[30];                /* сигнатура */\n\tunsigned char MaxTracks;    /* число треков (цилиндров) */\n\tunsigned char MaxHeads;     /* число головок (1 или 2) */\n\tlong diskIndex;             /* unused */\n\tlong DataOffset[512 * 2];     /* смещение в файле к структурам заголовков */\n\t\t\t\t\t\t\t\t/* треков       */\n};\n\nstruct FDD_TRACK_HEADER\n{\n\tunsigned char trkType;      /* unused */\n\tunsigned char SectNum;      /* число секторов на треке */\n\tstruct\n\t{\n\t\t/* заголовок сектора */\n\t\tunsigned char trk;     /* номер трека */\n\t\tunsigned char side;    /* номер стороны */\n\t\t\t\t\t\t\t   /* 7 бит этого байта указывает бит a */\n\t\tunsigned char sect;    /* номер сектора */\n\t\tunsigned char size;    /* размер сектора (код) */\n\t\tlong SectPos;          /* смещение в файле к данным сектора */\n\t} sect[256];\n};\n\n\nstruct TRDOS_DIR_ELEMENT        // 16 bytes\n{\n\tchar FileName[8];\n\tchar Type;\n\tunsigned short Start;\n\tunsigned short Length;\n\tunsigned char SecLen;\n\tunsigned char FirstSec;\n\tunsigned char FirstTrk;\n};\n#pragma pack()\n\nstatic const unsigned char sbootimage[] = {\n\t0x00, 0x01, 0x1a, 0x00, 0xf9, 0xc0, 0xb0, 0x22, 0x31, 0x35, 0x36, 0x31, 0x39, 0x22, 0x3a, 0xea,\n\t0x3a, 0xf7, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x20, 0x0d, 0x00, 0x02,\n\t0x0f, 0x00, 0xf9, 0xc0, 0xb0, 0x22, 0x31, 0x35, 0x36, 0x31, 0x39, 0x22, 0x3a, 0xea, 0x3a, 0xf7,\n\t0x0d, 0x00, 0x03, 0x0b, 0x00, 0xf9, 0xc0, 0xb0, 0x22, 0x31, 0x35, 0x36, 0x31, 0x36, 0x22, 0x0d,\n\t0x00, 0x04, 0x47, 0x00, 0xea, 0x21, 0xa8, 0x61, 0x11, 0xa9, 0x61, 0x01, 0x07, 0x9d, 0x36, 0x00,\n\t0xed, 0xb0, 0x21, 0xa8, 0x61, 0xed, 0x5b, 0xf4, 0x5c, 0x01, 0x05, 0x0f, 0xcd, 0x13, 0x3d, 0x21,\n\t0x00, 0xa6, 0xed, 0x5b, 0xf4, 0x5c, 0x01, 0x05, 0x08, 0xcd, 0x13, 0x3d, 0x21, 0x50, 0xeb, 0xed,\n\t0x5b, 0xf4, 0x5c, 0x01, 0x05, 0x0d, 0xcd, 0x13, 0x3d, 0xcd, 0xa8, 0x61, 0x21, 0xa8, 0x61, 0x11,\n\t0xa9, 0x61, 0x01, 0x07, 0x9d, 0x36, 0x00, 0xed, 0xb0, 0xc9, 0x0d, 0x00, 0x0a, 0x25, 0x00, 0xe7,\n\t0xc3, 0xa7, 0x3a, 0xda, 0xc3, 0xa7, 0x3a, 0xd9, 0xb0, 0x22, 0x37, 0x22, 0x3a, 0xfd, 0xb0, 0x22,\n\t0x36, 0x35, 0x33, 0x34, 0x37, 0x22, 0x3a, 0xf9, 0xc0, 0xb0, 0x22, 0x32, 0x33, 0x39, 0x33, 0x36,\n\t0x22, 0x3a, 0xf7, 0x0d, 0x80, 0xaa, 0x0a, 0x00, 0x6f, 0x6f, 0x74, 0x31, 0x31, 0x22, 0xca, 0x31,\n\t0x30, 0x0d, 0x80, 0x31, 0x35, 0x36, 0x31, 0x36, 0x0e, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x0d, 0x80,\n\t0xca, 0xf3, 0x5e, 0x06, 0x00, 0x00, 0x00, 0xf3, 0x5e, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0xfd, 0x22, 0xc8, 0xaf, 0xd9, 0x22, 0xca, 0xaf, 0xed, 0x73, 0xcc, 0xaf, 0xed, 0x57, 0x32, 0xce,\n\t0xaf, 0x11, 0x00, 0x00, 0x21, 0x00, 0x9d, 0x01, 0x05, 0x08, 0xcd, 0x13, 0x3d, 0x31, 0x68, 0xbf,\n\t0xf3, 0x21, 0x00, 0xfd, 0x11, 0x01, 0xfd, 0x01, 0x00, 0x01, 0x36, 0xfc, 0xed, 0xb0, 0x21, 0x5a,\n\t0x67, 0x22, 0xfd, 0xfc, 0x3e, 0xc3, 0x32, 0xfc, 0xfc, 0xed, 0x5e, 0x3e, 0xfd, 0xed, 0x47, 0xcd,\n\t0x53, 0xeb, 0xcd, 0x50, 0xeb, 0xcd, 0x13, 0x65, 0xfb, 0x21, 0x9b, 0x6e, 0x11, 0x00, 0x77, 0x01,\n\t0xc8, 0x00, 0xed, 0xb0, 0x21, 0x77, 0x6b, 0x11, 0x00, 0x76, 0x0e, 0x28, 0xed, 0xb0, 0x21, 0x9f,\n\t0x6b, 0x11, 0x5c, 0x76, 0x0e, 0x09, 0xed, 0xb0, 0x11, 0x00, 0x78, 0x3e, 0x40, 0x32, 0x8e, 0x76,\n\t0xcd, 0xf4, 0x62, 0x21, 0x00, 0x78, 0x11, 0x00, 0x81, 0x06, 0x08, 0xc5, 0xcd, 0xd9, 0x63, 0x24,\n\t0x14, 0xc1, 0x10, 0xf7, 0x21, 0x00, 0x77, 0xcd, 0x25, 0x64, 0xcd, 0x25, 0x64, 0xcd, 0x25, 0x64,\n\t0x11, 0x00, 0x8a, 0x3e, 0x80, 0x32, 0x8e, 0x76, 0xcd, 0xf4, 0x62, 0x21, 0x00, 0x8a, 0x11, 0x00,\n\t0x93, 0x06, 0x08, 0xc5, 0xcd, 0xd9, 0x63, 0x24, 0x14, 0xc1, 0x10, 0xf7, 0x06, 0x11, 0x21, 0x00,\n\t0x8a, 0xc5, 0xcd, 0x25, 0x64, 0x24, 0xc1, 0x10, 0xf8, 0xcd, 0xc9, 0x6d, 0x3e, 0xff, 0x32, 0xb0,\n\t0xb3, 0x3c, 0x32, 0xb1, 0xb3, 0x3e, 0x05, 0x32, 0xb2, 0xb3, 0x3e, 0x08, 0x32, 0xb3, 0xb3, 0x3e,\n\t0x0e, 0x32, 0xb4, 0xb3, 0xcd, 0x61, 0x64, 0x3a, 0xb0, 0xb3, 0x3c, 0x32, 0xb0, 0xb3, 0x3a, 0xb0,\n\t0xb3, 0xe6, 0x01, 0xfe, 0x01, 0x20, 0x18, 0x21, 0x84, 0xac, 0x22, 0x87, 0x64, 0xcd, 0x85, 0x64,\n\t0xcd, 0x85, 0x64, 0x21, 0xfc, 0xac, 0x22, 0x87, 0x64, 0xcd, 0x85, 0x64, 0xcd, 0x85, 0x64, 0x3a,\n\t0xb0, 0xb3, 0xe6, 0x03, 0xfe, 0x03, 0x20, 0x21, 0x21, 0x00, 0x40, 0x11, 0x00, 0x78, 0x01, 0xb1,\n\t0xb3, 0xcd, 0xdd, 0x64, 0x21, 0x1b, 0x40, 0x11, 0x00, 0x8a, 0x01, 0xb2, 0xb3, 0xcd, 0xdd, 0x64,\n\t0x21, 0x74, 0xad, 0x22, 0x87, 0x64, 0xcd, 0x85, 0x64, 0x3a, 0xb0, 0xb3, 0xe6, 0x07, 0xfe, 0x07,\n\t0x20, 0xa5, 0x21, 0x60, 0x50, 0x11, 0x00, 0x8a, 0x01, 0xb3, 0xb3, 0xcd, 0xdd, 0x64, 0x21, 0x7b,\n\t0x50, 0x11, 0x00, 0x78, 0x01, 0xb4, 0xb3, 0xcd, 0xdd, 0x64, 0x18, 0x8b, 0xfd, 0x21, 0x5c, 0x76,\n\t0x0e, 0x08, 0x21, 0x00, 0x77, 0x06, 0x28, 0xdd, 0x21, 0x00, 0x76, 0xcd, 0x3e, 0x63, 0xc5, 0x06,\n\t0x05, 0xdd, 0x7e, 0x00, 0xe6, 0x3f, 0xcd, 0x57, 0x63, 0xdd, 0x2c, 0x10, 0xf4, 0x0d, 0x20, 0xef,\n\t0xc1, 0xcd, 0x67, 0x63, 0x10, 0xe1, 0x14, 0x1e, 0x00, 0x0d, 0x20, 0xd6, 0xeb, 0x11, 0x00, 0x76,\n\t0x3a, 0x8e, 0x76, 0x47, 0x2c, 0x2c, 0x1a, 0xb8, 0x38, 0x02, 0x36, 0x18, 0x2c, 0x2c, 0x2c, 0x1c,\n\t0x7d, 0xfe, 0xc8, 0x20, 0xef, 0xc9, 0xd9, 0x21, 0x98, 0x76, 0x11, 0x99, 0x76, 0x01, 0x27, 0x00,\n\t0x70, 0xed, 0xb0, 0xd9, 0x79, 0x32, 0x52, 0x63, 0xfd, 0x7e, 0x00, 0x32, 0xc0, 0x76, 0xc9, 0xdd,\n\t0xe5, 0xdd, 0x21, 0x98, 0x76, 0x32, 0x62, 0x63, 0xdd, 0x36, 0x00, 0x01, 0xdd, 0xe1, 0xc9, 0xc5,\n\t0xfd, 0xe5, 0xd5, 0xe5, 0xdd, 0xe1, 0xe5, 0x3a, 0xc0, 0x76, 0xe6, 0xf8, 0x0f, 0x0f, 0x0f, 0x4f,\n\t0x06, 0x00, 0xeb, 0x09, 0xe5, 0xfd, 0xe1, 0x21, 0x98, 0x76, 0x3a, 0xc0, 0x76, 0xe6, 0x07, 0x4f,\n\t0x3e, 0x07, 0x91, 0x4f, 0x16, 0x05, 0x1e, 0x7e, 0x7b, 0x32, 0x98, 0x63, 0xaf, 0xdd, 0xcb, 0x00,\n\t0x46, 0x28, 0x02, 0x3e, 0x40, 0x08, 0x7e, 0xfe, 0x01, 0x20, 0x1b, 0x06, 0x86, 0x08, 0xb0, 0x47,\n\t0x79, 0x07, 0x07, 0x07, 0xb0, 0x32, 0xb3, 0x63, 0xfd, 0xcb, 0x00, 0x86, 0x0d, 0x79, 0xfe, 0xff,\n\t0x20, 0x04, 0xfd, 0x2c, 0x0e, 0x07, 0x2c, 0x7b, 0xd6, 0x08, 0x5f, 0xfe, 0x3e, 0x20, 0xc9, 0xdd,\n\t0x23, 0x15, 0x20, 0xc2, 0xe1, 0xd1, 0x01, 0x05, 0x00, 0x09, 0xeb, 0x09, 0xeb, 0xfd, 0xe1, 0xc1,\n\t0xc9, 0xe5, 0xdd, 0xe1, 0xd5, 0xfd, 0xe1, 0x06, 0x28, 0xc5, 0xdd, 0x4e, 0x00, 0xcd, 0x1c, 0x64,\n\t0xdd, 0x7e, 0x04, 0xfd, 0x71, 0x04, 0x4f, 0xcd, 0x1c, 0x64, 0xfd, 0x71, 0x00, 0xdd, 0x4e, 0x01,\n\t0xcd, 0x1c, 0x64, 0xdd, 0x7e, 0x03, 0xfd, 0x71, 0x03, 0x4f, 0xcd, 0x1c, 0x64, 0xfd, 0x71, 0x01,\n\t0xdd, 0x4e, 0x02, 0xcd, 0x1c, 0x64, 0xfd, 0x71, 0x02, 0x01, 0x05, 0x00, 0xdd, 0x09, 0xfd, 0x09,\n\t0xc1, 0x10, 0xc6, 0xc9, 0x06, 0x08, 0xcb, 0x19, 0x17, 0x10, 0xfb, 0x4f, 0xc9, 0xe5, 0x11, 0x00,\n\t0x9c, 0x06, 0x05, 0xc5, 0xe5, 0x06, 0x08, 0xc5, 0xe5, 0x06, 0x28, 0xc5, 0xcb, 0x16, 0xd5, 0x06,\n\t0x05, 0x1a, 0x1f, 0x12, 0x1c, 0x10, 0xfa, 0xd1, 0x01, 0x05, 0x00, 0x09, 0xc1, 0x10, 0xec, 0x1c,\n\t0x1c, 0x1c, 0x1c, 0x1c, 0xe1, 0xc1, 0x10, 0xdf, 0xe1, 0xc1, 0x23, 0x10, 0xd6, 0xd1, 0xd5, 0x21,\n\t0x00, 0x9c, 0x01, 0xc8, 0x00, 0xed, 0xb0, 0xe1, 0xc9, 0xdd, 0x21, 0x84, 0xac, 0x06, 0x3c, 0xdd,\n\t0x6e, 0x00, 0xdd, 0x66, 0x01, 0xdd, 0x7e, 0x04, 0x32, 0x75, 0x64, 0xaf, 0xcb, 0x46, 0x28, 0x02,\n\t0x3e, 0x01, 0xdd, 0x77, 0x05, 0x11, 0x06, 0x00, 0xdd, 0x19, 0x10, 0xe3, 0xc9, 0xdd, 0x21, 0x84,\n\t0xac, 0x06, 0x14, 0xc5, 0xdd, 0x6e, 0x00, 0xdd, 0x66, 0x01, 0xdd, 0x56, 0x02, 0xdd, 0x5e, 0x03,\n\t0xdd, 0x7e, 0x05, 0xfe, 0x01, 0x7a, 0x20, 0x01, 0x7b, 0x32, 0xa5, 0x64, 0xcb, 0x86, 0x24, 0x7c,\n\t0xe6, 0x07, 0x20, 0x18, 0x7c, 0xd6, 0x08, 0x67, 0x7d, 0xc6, 0x20, 0x6f, 0xe6, 0xe0, 0x20, 0x0c,\n\t0x7c, 0xc6, 0x08, 0x67, 0xe6, 0x18, 0xfe, 0x18, 0x20, 0x02, 0x26, 0x40, 0xdd, 0x75, 0x00, 0xdd,\n\t0x74, 0x01, 0x06, 0x01, 0xcd, 0x67, 0x64, 0x3a, 0xa5, 0x64, 0xcb, 0xf7, 0x32, 0xd8, 0x64, 0xcb,\n\t0xc6, 0xc1, 0x10, 0xaf, 0xc9, 0x0a, 0xc5, 0x4f, 0x06, 0x00, 0xdd, 0x21, 0xe0, 0x6a, 0xdd, 0x09,\n\t0xdd, 0x7e, 0x00, 0x82, 0x57, 0xcd, 0xf7, 0x64, 0xe1, 0x7e, 0x3c, 0xe6, 0x1f, 0x77, 0xc9, 0x06,\n\t0x05, 0xc5, 0x06, 0x08, 0xc5, 0x01, 0x05, 0x00, 0xeb, 0xed, 0xb0, 0xeb, 0x01, 0xfb, 0x00, 0x09,\n\t0xc1, 0x10, 0xf1, 0x01, 0x20, 0xf8, 0x09, 0xc1, 0x10, 0xe7, 0xc9, 0x11, 0x9b, 0x6e, 0xd5, 0xd5,\n\t0xd5, 0x21, 0x00, 0x40, 0xcd, 0xf7, 0x64, 0x21, 0x1b, 0x40, 0xd1, 0xcd, 0xf7, 0x64, 0x21, 0x60,\n\t0x50, 0xd1, 0xcd, 0xf7, 0x64, 0x21, 0x7b, 0x50, 0xd1, 0xcd, 0xf7, 0x64, 0x11, 0x00, 0xa9, 0x21,\n\t0x06, 0x40, 0xcd, 0xf7, 0x64, 0x11, 0xc8, 0xa9, 0x21, 0x0b, 0x40, 0xcd, 0xf7, 0x64, 0x11, 0x90,\n\t0xaa, 0x21, 0x10, 0x40, 0xcd, 0xf7, 0x64, 0x11, 0x58, 0xab, 0x21, 0x15, 0x40, 0xcd, 0xf7, 0x64,\n\t0x11, 0x06, 0x58, 0x21, 0x20, 0xac, 0x06, 0x05, 0xc5, 0x01, 0x14, 0x00, 0xed, 0xb0, 0x01, 0x0c,\n\t0x00, 0xeb, 0x09, 0xeb, 0xc1, 0x10, 0xf1, 0xcd, 0xc2, 0x6c, 0x21, 0x00, 0xa5, 0x22, 0x36, 0x5c,\n\t0x21, 0x00, 0x6b, 0xcd, 0x23, 0x67, 0x21, 0x00, 0x40, 0x11, 0x00, 0xc0, 0x01, 0x00, 0x1b, 0xed,\n\t0xb0, 0xcd, 0x44, 0x6e, 0x21, 0x00, 0xc0, 0x11, 0x00, 0x40, 0x01, 0x00, 0x1b, 0xed, 0xb0, 0xcd,\n\t0x33, 0x69, 0x3e, 0x01, 0x32, 0xbf, 0xb3, 0xdd, 0x21, 0x00, 0x9d, 0xcd, 0xca, 0x65, 0xcd, 0x4b,\n\t0x68, 0x7e, 0x32, 0xcb, 0xb3, 0xdd, 0x22, 0xc1, 0xb3, 0x21, 0x00, 0x00, 0x22, 0x78, 0x5c, 0xaf,\n\t0x32, 0xac, 0xde, 0x21, 0x00, 0x40, 0x11, 0x00, 0xc0, 0x01, 0x00, 0x1b, 0xed, 0xb0, 0xcd, 0x61,\n\t0x64, 0xc9, 0xdd, 0xe5, 0xe1, 0xaf, 0x32, 0x78, 0x5c, 0x16, 0x00, 0x7e, 0xcd, 0x50, 0x67, 0xa7,\n\t0x28, 0x22, 0xcd, 0x3a, 0x67, 0x7e, 0xa3, 0xfe, 0x42, 0x20, 0x01, 0x14, 0xfe, 0x43, 0xf5, 0x01,\n\t0x05, 0x00, 0x09, 0xf1, 0x20, 0x06, 0x7e, 0xfe, 0xc0, 0x20, 0x01, 0x14, 0x23, 0x23, 0x23, 0x7c,\n\t0xfe, 0xa5, 0x20, 0xd7, 0x7a, 0x32, 0xb5, 0xb3, 0x21, 0x00, 0x00, 0x22, 0xb8, 0xb3, 0x22, 0xba,\n\t0xb3, 0x22, 0xbc, 0xb3, 0xa7, 0x20, 0x12, 0x21, 0x44, 0x6b, 0xcd, 0x23, 0x67, 0x21, 0x0b, 0x09,\n\t0x22, 0xb6, 0xb3, 0x3e, 0x0e, 0x32, 0xbe, 0xb3, 0xc9, 0xfe, 0x0d, 0x30, 0x22, 0x32, 0xbb, 0xb3,\n\t0x21, 0x06, 0x0e, 0x22, 0xb6, 0xb3, 0x3e, 0x01, 0x32, 0xb8, 0xb3, 0x32, 0xc0, 0xb3, 0x3e, 0x08,\n\t0x32, 0xbe, 0xb3, 0xdd, 0xe5, 0xe1, 0x01, 0x06, 0x0a, 0x1e, 0x41, 0xcd, 0x91, 0x66, 0xc9, 0xfe,\n\t0x19, 0x30, 0x38, 0xa7, 0x1f, 0x32, 0xbc, 0xb3, 0xce, 0x00, 0x32, 0xbb, 0xb3, 0x21, 0x06, 0x06,\n\t0x22, 0xb6, 0xb3, 0x3e, 0x02, 0x32, 0xb8, 0xb3, 0x3d, 0x32, 0xc0, 0xb3, 0x3e, 0x08, 0x32, 0xbe,\n\t0xb3, 0xdd, 0xe5, 0xe1, 0x01, 0x06, 0x02, 0x1e, 0x41, 0x3a, 0xbb, 0xb3, 0x57, 0xcd, 0x91, 0x66,\n\t0x01, 0x06, 0x12, 0x3a, 0xbc, 0xb3, 0x57, 0xcd, 0x91, 0x66, 0xc9, 0x3e, 0x18, 0xcd, 0x4b, 0x66,\n\t0x22, 0xc3, 0xb3, 0x3e, 0x01, 0x32, 0xb9, 0xb3, 0xc9, 0xed, 0x43, 0xcf, 0xb3, 0xd5, 0x7e, 0xcd,\n\t0x50, 0x67, 0x1e, 0xff, 0xcd, 0x3a, 0x67, 0x16, 0x06, 0x7e, 0xa3, 0xfe, 0x42, 0x28, 0x14, 0xfe,\n\t0x43, 0xf5, 0x01, 0x05, 0x00, 0x09, 0xf1, 0x20, 0x05, 0x7e, 0xfe, 0xc0, 0x28, 0x0b, 0x23, 0x23,\n\t0x23, 0x18, 0xdb, 0x01, 0x05, 0x00, 0x09, 0x16, 0x04, 0x01, 0x0d, 0x00, 0xa7, 0xed, 0x42, 0x7a,\n\t0x32, 0xda, 0xb3, 0x11, 0xdb, 0xb3, 0x06, 0x08, 0x7e, 0xfe, 0x20, 0x30, 0x02, 0x3e, 0x2e, 0xfe,\n\t0x80, 0x38, 0x02, 0x3e, 0x2e, 0x12, 0x13, 0x23, 0x10, 0xee, 0x3e, 0xff, 0x12, 0xd1, 0xe5, 0x6b,\n\t0x26, 0x3e, 0x22, 0xd5, 0xb3, 0x21, 0x20, 0x20, 0x22, 0xd7, 0xb3, 0x3e, 0x10, 0x32, 0xd9, 0xb3,\n\t0x3e, 0x16, 0x32, 0xce, 0xb3, 0x21, 0x13, 0x01, 0x22, 0xd1, 0xb3, 0x21, 0x10, 0x05, 0x22, 0xd3,\n\t0xb3, 0xd5, 0x21, 0xce, 0xb3, 0xcd, 0x23, 0x67, 0xd1, 0xe1, 0x01, 0x08, 0x00, 0x09, 0x3a, 0xcf,\n\t0xb3, 0x3c, 0x32, 0xcf, 0xb3, 0x1c, 0x15, 0xc2, 0x95, 0x66, 0xc9, 0xe5, 0x2a, 0xca, 0xaf, 0xd9,\n\t0xfd, 0x2a, 0xc8, 0xaf, 0x3e, 0x02, 0xcd, 0x01, 0x16, 0xe1, 0x7e, 0xfe, 0xff, 0xc8, 0xd7, 0x23,\n\t0x18, 0xf8, 0xd5, 0x0e, 0x00, 0x06, 0x09, 0x11, 0x6e, 0x6b, 0x1a, 0xbe, 0x28, 0x02, 0x0e, 0xff,\n\t0x23, 0x13, 0x10, 0xf6, 0xd1, 0x59, 0x2b, 0xc9, 0xfe, 0x01, 0xc0, 0x01, 0x10, 0x00, 0x09, 0x7e,\n\t0x18, 0xf6, 0xfd, 0xe5, 0xdd, 0xe5, 0xe5, 0xd5, 0xc5, 0xf5, 0xd9, 0xe5, 0xd5, 0xc5, 0x2a, 0xca,\n\t0xaf, 0xd9, 0x08, 0xf5, 0xfd, 0x2a, 0xc8, 0xaf, 0xcd, 0x56, 0xeb, 0x2a, 0x78, 0x5c, 0x23, 0x22,\n\t0x78, 0x5c, 0x3a, 0xac, 0xde, 0xc6, 0x02, 0x32, 0xac, 0xde, 0xcd, 0xa8, 0x6b, 0xcd, 0x07, 0x6d,\n\t0x3a, 0x78, 0x5c, 0xe6, 0x03, 0xfe, 0x03, 0x20, 0x21, 0xcd, 0x4b, 0x68, 0xed, 0x5b, 0xbe, 0xb3,\n\t0x43, 0x72, 0x23, 0x10, 0xfc, 0xcb, 0x72, 0xcb, 0xf2, 0x28, 0x0b, 0xcb, 0xb2, 0x14, 0xcb, 0x5a,\n\t0x28, 0x04, 0x14, 0x14, 0xcb, 0x9a, 0x7a, 0x32, 0xbf, 0xb3, 0x3a, 0x78, 0x5c, 0xfe, 0x32, 0x20,\n\t0x58, 0x2a, 0xb6, 0xb3, 0x22, 0xcc, 0xb3, 0x3a, 0xbe, 0xb3, 0x32, 0xec, 0xb3, 0x21, 0xcc, 0xb3,\n\t0x22, 0x4d, 0x68, 0xcd, 0x4b, 0x68, 0x2a, 0xc9, 0xb3, 0x7c, 0x07, 0x07, 0x07, 0xf6, 0xc0, 0x67,\n\t0x22, 0xae, 0xde, 0x3a, 0xec, 0xb3, 0x47, 0xc5, 0xe5, 0x11, 0xed, 0xb3, 0xd5, 0x06, 0x08, 0x7e,\n\t0x12, 0x24, 0x13, 0x10, 0xfa, 0xe1, 0xd1, 0xd5, 0x06, 0x08, 0x0e, 0x08, 0xe5, 0xcb, 0x16, 0x1f,\n\t0x23, 0x0d, 0x20, 0xf9, 0x12, 0x14, 0xe1, 0x10, 0xf1, 0xe1, 0x23, 0xc1, 0x10, 0xd9, 0x21, 0xb6,\n\t0xb3, 0x22, 0x4d, 0x68, 0xcd, 0xa5, 0x6c, 0x18, 0x1f, 0xfe, 0x3c, 0x28, 0xb0, 0xfe, 0x46, 0x28,\n\t0xac, 0xfe, 0x50, 0x28, 0xa8, 0xfe, 0x5a, 0x20, 0x0f, 0x3e, 0xc9, 0x32, 0xdb, 0x67, 0xcd, 0xc5,\n\t0x67, 0x3e, 0x3a, 0x32, 0xdb, 0x67, 0x18, 0xd6, 0x3a, 0x78, 0x5c, 0xe6, 0x07, 0xfe, 0x07, 0xcc,\n\t0x67, 0x68, 0xd9, 0xf1, 0x08, 0xc1, 0xd1, 0xe1, 0xd9, 0xf1, 0xc1, 0xd1, 0xe1, 0xdd, 0xe1, 0xfd,\n\t0xe1, 0xfb, 0xc9, 0xed, 0x5b, 0xb6, 0xb3, 0x21, 0x00, 0x00, 0x01, 0x20, 0x00, 0x7b, 0xa7, 0x28,\n\t0x04, 0x09, 0x1d, 0x18, 0xf8, 0x4a, 0x09, 0x22, 0xc9, 0xb3, 0x01, 0x00, 0x58, 0x09, 0xc9, 0x0e,\n\t0x41, 0x21, 0x56, 0x6b, 0x7e, 0x0f, 0x0f, 0xe6, 0x38, 0xf6, 0x87, 0x32, 0x79, 0x68, 0x3e, 0xff,\n\t0xcb, 0x87, 0xdb, 0xfe, 0x2f, 0x47, 0x7e, 0xe6, 0x1f, 0xa0, 0xc4, 0x54, 0x6a, 0x0c, 0x23, 0x79,\n\t0xfe, 0x59, 0x20, 0xe0, 0x3e, 0xf7, 0xdb, 0xfe, 0x1f, 0xd4, 0x6a, 0x69, 0x1f, 0xd4, 0x6a, 0x69,\n\t0x1f, 0xd4, 0xc3, 0x69, 0x1f, 0xd4, 0x3d, 0x6a, 0x1f, 0xd4, 0x42, 0x6a, 0x3e, 0xef, 0xdb, 0xfe,\n\t0x1f, 0xd4, 0x42, 0x6a, 0x1f, 0xd4, 0x3d, 0x6a, 0x1f, 0xd4, 0xc3, 0x69, 0x1f, 0xd4, 0x6a, 0x69,\n\t0x1f, 0xd4, 0x6a, 0x69, 0x3e, 0x00, 0x1f, 0xdc, 0x6a, 0x69, 0x1f, 0xdc, 0x6a, 0x69, 0x1f, 0xdc,\n\t0xc3, 0x69, 0x1f, 0xdc, 0x3d, 0x6a, 0x1f, 0xdc, 0x42, 0x6a, 0x3e, 0xfe, 0xdb, 0xfe, 0x1f, 0x38,\n\t0x0f, 0x2a, 0xc1, 0xb3, 0x01, 0x01, 0x9d, 0xa7, 0xed, 0x42, 0x38, 0x04, 0xcd, 0x89, 0x65, 0xc9,\n\t0x3e, 0xbf, 0xdb, 0xfe, 0x1f, 0xd4, 0x42, 0x6a, 0x3e, 0x7f, 0xdb, 0xfe, 0x1f, 0x38, 0x21, 0x2a,\n\t0xca, 0xaf, 0xd9, 0xfd, 0x2a, 0xc8, 0xaf, 0xcd, 0x44, 0x6e, 0x21, 0x00, 0x9d, 0x11, 0x00, 0x00,\n\t0x01, 0x05, 0x08, 0xf3, 0xed, 0x56, 0xcd, 0x13, 0x3d, 0xf3, 0xed, 0x5e, 0xcd, 0x89, 0x65, 0xc9,\n\t0x1f, 0xd8, 0x3a, 0xb9, 0xb3, 0xa7, 0xc8, 0x2a, 0xc3, 0xb3, 0xaf, 0x32, 0xb9, 0xb3, 0x22, 0xa1,\n\t0x65, 0xcd, 0x89, 0x65, 0x21, 0x00, 0x9d, 0x22, 0xa1, 0x65, 0xc9, 0x21, 0xc0, 0x40, 0x0e, 0x60,\n\t0x06, 0x20, 0x36, 0x00, 0x2c, 0x10, 0xfb, 0x0d, 0x28, 0x1a, 0x7d, 0xd6, 0x20, 0x6f, 0x24, 0x7c,\n\t0xe6, 0x07, 0x20, 0xec, 0x7c, 0xd6, 0x08, 0x67, 0x7d, 0xc6, 0x20, 0x6f, 0x20, 0xe2, 0x7c, 0xc6,\n\t0x08, 0x67, 0x18, 0xdc, 0x21, 0xc0, 0x58, 0x11, 0xc1, 0x58, 0x01, 0x7f, 0x01, 0x36, 0x07, 0xed,\n\t0xb0, 0xc9, 0xf5, 0x3a, 0xbc, 0xb3, 0xa7, 0x20, 0x02, 0xf1, 0xc9, 0xcd, 0x4b, 0x68, 0x3a, 0xbe,\n\t0xb3, 0x47, 0x3a, 0xcb, 0xb3, 0x77, 0x23, 0x10, 0xfc, 0x3a, 0xbb, 0xb3, 0x47, 0x3a, 0xc0, 0xb3,\n\t0x4f, 0x3d, 0x90, 0x30, 0x23, 0xfe, 0xff, 0x20, 0x13, 0x2a, 0xbb, 0xb3, 0x7c, 0xbd, 0x28, 0x0c,\n\t0x3e, 0x01, 0x32, 0xc0, 0xb3, 0x3e, 0x06, 0x32, 0xb6, 0xb3, 0x18, 0x16, 0x79, 0x80, 0x32, 0xc0,\n\t0xb3, 0x3e, 0x16, 0x32, 0xb7, 0xb3, 0x18, 0x0a, 0x79, 0x90, 0x32, 0xc0, 0xb3, 0x3e, 0x06, 0x32,\n\t0xb7, 0xb3, 0xcd, 0x4b, 0x68, 0x7e, 0x32, 0xcb, 0xb3, 0xf1, 0xc9, 0xf5, 0x06, 0x00, 0x3a, 0xbc,\n\t0xb3, 0xa7, 0x20, 0x09, 0x3a, 0xbb, 0xb3, 0xa7, 0x28, 0x9f, 0x3d, 0x28, 0x9c, 0xc5, 0xcd, 0x4b,\n\t0x68, 0x3a, 0xbe, 0xb3, 0x47, 0x3a, 0xcb, 0xb3, 0x77, 0x23, 0x10, 0xfc, 0xc1, 0x3a, 0xc0, 0xb3,\n\t0x4f, 0xed, 0x5b, 0xbb, 0xb3, 0x3a, 0xb6, 0xb3, 0x6f, 0x3a, 0xb7, 0xb3, 0xfe, 0x16, 0x28, 0x21,\n\t0x78, 0xa7, 0x20, 0x0e, 0x79, 0xbb, 0x3e, 0x06, 0x26, 0x01, 0x28, 0x2f, 0x61, 0x24, 0x7d, 0x3c,\n\t0x18, 0x29, 0x79, 0xfe, 0x01, 0x20, 0x04, 0x63, 0x7b, 0x18, 0x1e, 0x61, 0x25, 0x7d, 0x3d, 0x18,\n\t0x1a, 0x78, 0xa7, 0x20, 0x0b, 0x7b, 0x82, 0xb9, 0x20, 0xe2, 0x63, 0x24, 0x3e, 0x06, 0x18, 0x0b,\n\t0x7b, 0x3c, 0xb9, 0x20, 0xe6, 0x7b, 0x82, 0x67, 0x7a, 0xc6, 0x05, 0x32, 0xb6, 0xb3, 0x7c, 0x32,\n\t0xc0, 0xb3, 0xc3, 0xba, 0x69, 0x06, 0x01, 0xf5, 0x18, 0x84, 0xf5, 0x3a, 0xbb, 0xb3, 0x47, 0x3a,\n\t0xbc, 0xb3, 0xb0, 0xca, 0x71, 0x69, 0x3a, 0xc0, 0xb3, 0xc6, 0x40, 0x4f, 0x3a, 0xb5, 0xb3, 0xc6,\n\t0x40, 0xb9, 0xd8, 0x06, 0x40, 0xd9, 0x2a, 0xc1, 0xb3, 0x7e, 0xcd, 0x50, 0x67, 0x1e, 0xff, 0xcd,\n\t0x3a, 0x67, 0x16, 0xec, 0x7e, 0xa3, 0xfe, 0x42, 0x28, 0x14, 0xfe, 0x43, 0xf5, 0x01, 0x05, 0x00,\n\t0x09, 0xf1, 0x20, 0x05, 0x7e, 0xfe, 0xc0, 0x28, 0x0b, 0x23, 0x23, 0x23, 0x18, 0xdb, 0x01, 0x05,\n\t0x00, 0x09, 0x16, 0xf7, 0x01, 0x0d, 0x00, 0xa7, 0xed, 0x42, 0xd9, 0x04, 0x78, 0xb9, 0xd9, 0x7e,\n\t0x36, 0x01, 0x20, 0xc5, 0x77, 0xd5, 0xe5, 0x21, 0x4c, 0x5d, 0x72, 0x23, 0x23, 0xeb, 0xe1, 0x01,\n\t0x08, 0x00, 0xed, 0xb0, 0x13, 0x0e, 0x20, 0xe1, 0x7c, 0xfe, 0xf7, 0x28, 0x02, 0x0e, 0xaf, 0x79,\n\t0x12, 0x21, 0x00, 0x00, 0x22, 0x78, 0x5c, 0x3a, 0xce, 0xaf, 0xed, 0x47, 0x2a, 0xca, 0xaf, 0xd9,\n\t0xfd, 0x2a, 0xc8, 0xaf, 0xed, 0x7b, 0xcc, 0xaf, 0x21, 0x00, 0x3c, 0x22, 0x36, 0x5c, 0xcd, 0x4b,\n\t0x6e, 0xcd, 0x75, 0x6e, 0xed, 0x56, 0xfb, 0xc9, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t0x08, 0x10, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n\t0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x16, 0x13, 0x07, 0x13, 0x01, 0x10, 0x05, 0x53,\n\t0x50, 0x41, 0x43, 0x45, 0x20, 0x20, 0x54, 0x4f, 0x20, 0x4e, 0x45, 0x57, 0x20, 0x44, 0x49, 0x53,\n\t0x4b, 0x16, 0x14, 0x07, 0x22, 0x53, 0x53, 0x22, 0x20, 0x54, 0x4f, 0x20, 0x4e, 0x45, 0x58, 0x54,\n\t0x20, 0x50, 0x41, 0x47, 0x45, 0x53, 0x16, 0x15, 0x07, 0x22, 0x43, 0x53, 0x22, 0x20, 0x54, 0x4f,\n\t0x20, 0x46, 0x49, 0x52, 0x53, 0x54, 0x20, 0x50, 0x41, 0x47, 0x45, 0xff, 0x16, 0x0b, 0x09, 0x4e,\n\t0x4f, 0x20, 0x45, 0x58, 0x45, 0x20, 0x46, 0x49, 0x4c, 0x45, 0x53, 0x20, 0x21, 0xff, 0x21, 0xf0,\n\t0x08, 0x24, 0x44, 0x28, 0x30, 0xd0, 0xa4, 0xc8, 0xc4, 0xc2, 0xe4, 0xe8, 0xa2, 0xa1, 0x41, 0x48,\n\t0x22, 0x50, 0xa8, 0x10, 0x42, 0x04, 0x62, 0x6f, 0x6f, 0x74, 0x20, 0x20, 0x20, 0x20, 0x42, 0x08,\n\t0x10, 0x13, 0x17, 0x1f, 0x05, 0x0c, 0x15, 0x1b, 0x22, 0x01, 0x03, 0x0a, 0x1d, 0x24, 0x27, 0x07,\n\t0x0e, 0x19, 0x20, 0x02, 0x0b, 0x12, 0x16, 0x1c, 0x26, 0x00, 0x0f, 0x1e, 0x23, 0x09, 0x04, 0x11,\n\t0x18, 0x25, 0x14, 0x06, 0x0d, 0x1a, 0x21, 0x13, 0x12, 0x0f, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x00,\n\t0x3a, 0xac, 0xde, 0xa7, 0x20, 0x20, 0x2a, 0xa8, 0xde, 0x23, 0x7c, 0xe6, 0x07, 0x67, 0x22, 0xa8,\n\t0xde, 0x06, 0x08, 0x4e, 0x21, 0xec, 0xad, 0xed, 0x5f, 0xae, 0xa9, 0x81, 0x4f, 0x3a, 0xb0, 0xb3,\n\t0xa9, 0x77, 0x23, 0x10, 0xf2, 0xc9, 0x3a, 0xac, 0xde, 0xe6, 0x3f, 0xfe, 0x3e, 0x20, 0x21, 0x3a,\n\t0xb0, 0xde, 0x3c, 0xe6, 0x07, 0x32, 0xb0, 0xde, 0x28, 0x08, 0x3a, 0xac, 0xde, 0xd6, 0x02, 0x32,\n\t0xac, 0xde, 0x3e, 0xc9, 0x32, 0x1c, 0x6c, 0xcd, 0x00, 0x6c, 0x3e, 0x3a, 0x32, 0x1c, 0x6c, 0xc9,\n\t0x3a, 0xac, 0xde, 0xe6, 0x07, 0xfe, 0x02, 0xc0, 0x3a, 0xac, 0xde, 0x07, 0x07, 0x07, 0xe6, 0x06,\n\t0x4f, 0x06, 0x00, 0x21, 0xec, 0xad, 0x09, 0xcd, 0x59, 0x6c, 0xf5, 0xd4, 0xae, 0x6b, 0xf1, 0x30,\n\t0xe7, 0xcd, 0x74, 0x6c, 0x3a, 0xac, 0xde, 0xe6, 0x20, 0x0e, 0x60, 0x20, 0x02, 0x0e, 0x00, 0x3a,\n\t0xac, 0xde, 0x07, 0x07, 0xa9, 0xe6, 0x60, 0x4f, 0x06, 0x00, 0x21, 0x63, 0x6f, 0x09, 0xeb, 0x06,\n\t0x10, 0x2a, 0xaa, 0xde, 0x4e, 0x1a, 0xb1, 0x77, 0x2c, 0x13, 0x4e, 0x1a, 0xb1, 0x77, 0x13, 0x2d,\n\t0x24, 0x7c, 0xe6, 0x07, 0x20, 0x08, 0x7c, 0xd6, 0x08, 0x67, 0x7d, 0xc6, 0x20, 0x6f, 0x10, 0xe4,\n\t0xc9, 0x06, 0x1a, 0x23, 0x7e, 0xe6, 0x18, 0x28, 0x06, 0xfe, 0x10, 0x28, 0x02, 0x06, 0x1f, 0x2b,\n\t0x7e, 0xfe, 0xe0, 0xd0, 0xe6, 0x1f, 0xb8, 0xd0, 0xee, 0x1f, 0xb8, 0xc9, 0x23, 0x7e, 0xe6, 0x18,\n\t0xfe, 0x18, 0x20, 0x02, 0x3e, 0x08, 0x2b, 0x6e, 0xf6, 0x40, 0x67, 0x22, 0xaa, 0xde, 0x06, 0x10,\n\t0x7c, 0xf6, 0x80, 0x57, 0x5d, 0x1a, 0x77, 0x2c, 0x1c, 0x1a, 0x77, 0x2d, 0x24, 0x7c, 0xe6, 0x07,\n\t0x20, 0x08, 0x7c, 0xd6, 0x08, 0x67, 0x7d, 0xc6, 0x20, 0x6f, 0x10, 0xe4, 0xc9, 0x2a, 0xae, 0xde,\n\t0x7c, 0xe6, 0x7f, 0x57, 0x5d, 0x06, 0x08, 0xc5, 0x3a, 0xec, 0xb3, 0x4f, 0x06, 0x00, 0xe5, 0xd5,\n\t0xed, 0xb0, 0xd1, 0xe1, 0x24, 0x14, 0xc1, 0x10, 0xee, 0xc9, 0x21, 0x00, 0x58, 0xcd, 0xdb, 0x6c,\n\t0x21, 0x7b, 0x5a, 0xcd, 0xdb, 0x6c, 0x11, 0x1b, 0x58, 0xcd, 0xf2, 0x6c, 0x11, 0x60, 0x5a, 0xcd,\n\t0xf2, 0x6c, 0xc9, 0x06, 0x05, 0x11, 0xf4, 0xad, 0x0e, 0x05, 0x1a, 0x77, 0x23, 0x0d, 0x20, 0xfb,\n\t0x13, 0xc5, 0x01, 0x1b, 0x00, 0x09, 0xc1, 0x10, 0xef, 0xc9, 0x06, 0x05, 0xc5, 0x01, 0x05, 0x00,\n\t0x21, 0xf4, 0xad, 0xed, 0xb0, 0xeb, 0x01, 0x1b, 0x00, 0x09, 0xeb, 0xc1, 0x10, 0xee, 0xc9, 0x3a,\n\t0x78, 0x5c, 0xfe, 0x40, 0xd0, 0x21, 0x06, 0x58, 0x22, 0x41, 0x6d, 0x21, 0x19, 0x58, 0x22, 0x44,\n\t0x6d, 0x21, 0x80, 0x58, 0x22, 0x57, 0x6d, 0x3a, 0x79, 0x5c, 0xe6, 0x01, 0x28, 0x12, 0x21, 0x66,\n\t0x5a, 0x22, 0x41, 0x6d, 0x21, 0x79, 0x5a, 0x22, 0x44, 0x6d, 0x21, 0xe0, 0x5a, 0x22, 0x57, 0x6d,\n\t0x3a, 0x78, 0x5c, 0xa7, 0x20, 0x09, 0x3e, 0x02, 0x32, 0x06, 0x58, 0x32, 0x19, 0x58, 0xc9, 0xe6,\n\t0x01, 0xc0, 0x3a, 0x78, 0x5c, 0x0f, 0xe6, 0x1f, 0xfe, 0x1b, 0xd0, 0x4f, 0x06, 0x05, 0x21, 0x80,\n\t0x58, 0x0d, 0xcd, 0x6d, 0x6d, 0x0c, 0xcd, 0x8d, 0x6d, 0x0c, 0xc5, 0x01, 0x20, 0x00, 0xa7, 0xed,\n\t0x42, 0xc1, 0x10, 0xed, 0xc9, 0xc5, 0xe5, 0x7d, 0xb1, 0x6f, 0x5d, 0x7c, 0xf6, 0x80, 0x57, 0xe5,\n\t0xd5, 0xeb, 0x01, 0x03, 0x00, 0xed, 0xb0, 0xe1, 0xd1, 0x7d, 0xee, 0x1f, 0x6f, 0x5d, 0x0e, 0x03,\n\t0xed, 0xb8, 0xe1, 0xc1, 0xc9, 0xc5, 0xe5, 0x7d, 0xb1, 0x6f, 0xe5, 0xcd, 0xb1, 0x6d, 0x23, 0xcd,\n\t0xbd, 0x6d, 0x23, 0xcd, 0xb1, 0x6d, 0xe1, 0x7d, 0xee, 0x1f, 0x6f, 0xcd, 0xb1, 0x6d, 0x2b, 0xcd,\n\t0xbd, 0x6d, 0x2b, 0xcd, 0xb1, 0x6d, 0xe1, 0xc1, 0xc9, 0x7d, 0xe6, 0x1f, 0xfe, 0x06, 0xd8, 0xfe,\n\t0x1a, 0xd0, 0x36, 0x02, 0xc9, 0x7d, 0xe6, 0x1f, 0xfe, 0x06, 0xd8, 0xfe, 0x1a, 0xd0, 0x36, 0x42,\n\t0xc9, 0x21, 0x00, 0xa9, 0xcd, 0x38, 0x6e, 0x21, 0xc8, 0xa9, 0xcd, 0x38, 0x6e, 0x21, 0x90, 0xaa,\n\t0xcd, 0x38, 0x6e, 0x21, 0x58, 0xab, 0xcd, 0x38, 0x6e, 0xf3, 0x11, 0x00, 0xa9, 0x21, 0x66, 0xd0,\n\t0xcd, 0xf7, 0x64, 0x11, 0xc8, 0xa9, 0x21, 0x6b, 0xd0, 0xcd, 0xf7, 0x64, 0x11, 0x90, 0xaa, 0x21,\n\t0x70, 0xd0, 0xcd, 0xf7, 0x64, 0x11, 0x58, 0xab, 0x21, 0x75, 0xd0, 0xcd, 0xf7, 0x64, 0x06, 0x05,\n\t0x21, 0x06, 0xd8, 0x11, 0xe6, 0xda, 0xc5, 0x01, 0x14, 0x00, 0xed, 0xb0, 0x0e, 0x0c, 0x09, 0x0e,\n\t0x34, 0xa7, 0xeb, 0xed, 0x42, 0xeb, 0xc1, 0x10, 0xed, 0x21, 0x00, 0xd0, 0x11, 0x00, 0x50, 0x01,\n\t0x00, 0x08, 0xed, 0xb0, 0x21, 0x60, 0xda, 0x11, 0x60, 0x5a, 0x0e, 0xa0, 0xed, 0xb0, 0xfb, 0xc9,\n\t0xcd, 0x25, 0x64, 0xcd, 0x25, 0x64, 0x54, 0x5d, 0xcd, 0xd9, 0x63, 0xc9, 0x21, 0x30, 0x75, 0xcd,\n\t0x52, 0x6e, 0xc9, 0x21, 0x67, 0x6e, 0xcd, 0x52, 0x6e, 0xc9, 0xaf, 0x01, 0xfd, 0xff, 0xed, 0x79,\n\t0xf5, 0x7e, 0x01, 0xfd, 0xbf, 0xed, 0x79, 0x23, 0xf1, 0x3c, 0xfe, 0x0e, 0xc8, 0x18, 0xec, 0x30,\n\t0x00, 0x01, 0x00, 0x50, 0x00, 0x00, 0x38, 0x10, 0x10, 0x10, 0xc4, 0x50, 0x01, 0x16, 0x08, 0x0e,\n\t0x10, 0x21, 0x00, 0x40, 0x41, 0xaf, 0xcb, 0x1e, 0x23, 0xaf, 0xcb, 0x16, 0x23, 0x10, 0xf6, 0x41,\n\t0xaf, 0xcb, 0x16, 0x23, 0xaf, 0xcb, 0x1e, 0x23, 0x10, 0xf6, 0x7c, 0xfe, 0x58, 0x20, 0xe5, 0x15,\n\t0x20, 0xdd, 0xc9, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x72,\n\t0x00, 0x00, 0x00, 0x00, 0xb1, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x80, 0x00, 0x00, 0x03, 0xd0, 0x40,\n\t0x00, 0x00, 0x07, 0xa8, 0x20, 0x00, 0x00, 0x0b, 0x54, 0x10, 0x00, 0x00, 0x1e, 0xaa, 0x08, 0x00,\n\t0x00, 0x2d, 0x55, 0x04, 0x00, 0x00, 0x7a, 0xaa, 0x82, 0x00, 0x00, 0xb5, 0x55, 0x41, 0x00, 0x01,\n\t0x6a, 0xaa, 0xa0, 0x80, 0x02, 0xd5, 0x45, 0x50, 0x40, 0x05, 0x2a, 0x82, 0xa8, 0x20, 0x09, 0x55,\n\t0x01, 0x54, 0x10, 0x12, 0xaa, 0x00, 0xaa, 0x08, 0x25, 0x54, 0x00, 0x55, 0x04, 0x22, 0xa8, 0x00,\n\t0x2a, 0x84, 0x25, 0x50, 0x00, 0x15, 0x44, 0x2a, 0xa4, 0x00, 0x3a, 0xa4, 0x35, 0x42, 0x00, 0x7d,\n\t0x54, 0x2a, 0xa1, 0x00, 0xba, 0xa8, 0x15, 0x51, 0x01, 0xf5, 0x50, 0x0a, 0xa9, 0x03, 0xea, 0xa0,\n\t0x05, 0x55, 0x05, 0xd5, 0x40, 0x02, 0xab, 0x0f, 0xaa, 0x80, 0x01, 0x55, 0x17, 0x55, 0x00, 0x00,\n\t0xaa, 0x2e, 0xaa, 0x00, 0x00, 0x54, 0x55, 0x54, 0x00, 0x00, 0x28, 0x9a, 0xa8, 0x00, 0x00, 0x11,\n\t0x35, 0x50, 0x00, 0x00, 0x01, 0x2a, 0xa0, 0x00, 0x00, 0x01, 0x55, 0x40, 0x00, 0x00, 0x01, 0xaa,\n\t0x80, 0x00, 0x00, 0x01, 0x55, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00,\n\t0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0xc0, 0x00, 0x80, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x05, 0xd0, 0x00, 0x80, 0x00,\n\t0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x90, 0x02, 0x80, 0x01, 0xc0, 0x2f, 0xf4, 0x01, 0xc0, 0x00,\n\t0xa0, 0x04, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,\n\t0x80, 0x10, 0x08, 0x00, 0x80, 0x04, 0x80, 0x02, 0xa0, 0x01, 0xc0, 0x5f, 0xfd, 0x01, 0xc0, 0x02,\n\t0x80, 0x04, 0x90, 0x00, 0x88, 0x10, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x10, 0x10, 0x00, 0x10, 0x00,\n\t0x00, 0x36, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x7e, 0x24, 0x24, 0x7e, 0x24, 0x00,\n\t0x00, 0x08, 0x3e, 0x68, 0x3e, 0x0a, 0x7e, 0x08, 0x00, 0x66, 0x4c, 0x18, 0x30, 0x66, 0x4e, 0x00,\n\t0x18, 0x24, 0x2c, 0x78, 0xda, 0xcc, 0x7e, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x30, 0x18, 0x18, 0x18, 0x18, 0x30, 0x00,\n\t0x00, 0x00, 0x14, 0x08, 0x7e, 0x18, 0x2c, 0x00, 0x00, 0x00, 0x08, 0x08, 0x7e, 0x18, 0x18, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x78, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00,\n\t0x38, 0x6c, 0xce, 0xd6, 0xe6, 0x6c, 0x38, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x3e, 0x7c, 0x00,\n\t0x78, 0xcc, 0x1c, 0x38, 0x70, 0xe6, 0xfe, 0x00, 0x7e, 0xcc, 0x18, 0x3c, 0x0e, 0xce, 0x7c, 0x00,\n\t0x24, 0x6c, 0xcc, 0xcc, 0xfc, 0x0c, 0x0c, 0x00, 0xfe, 0xc2, 0xf8, 0xcc, 0x0e, 0xce, 0x7c, 0x00,\n\t0x7c, 0xc6, 0xc0, 0xfc, 0xc6, 0xc6, 0x7c, 0x00, 0x7e, 0x66, 0x0e, 0x1c, 0x38, 0x30, 0x30, 0x00,\n\t0x7c, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x7c, 0xc6, 0xc6, 0x7e, 0x06, 0xc6, 0x7c, 0x00,\n\t0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30,\n\t0x00, 0x00, 0x0c, 0x18, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x7e, 0x00, 0x00,\n\t0x00, 0x00, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x00, 0x7c, 0xc6, 0xc6, 0x1c, 0x30, 0x00, 0x30, 0x00,\n\t0x00, 0x3c, 0x4a, 0x56, 0xfe, 0xc0, 0x7c, 0x00, 0x3c, 0x66, 0xc6, 0xfe, 0xc6, 0xe6, 0x66, 0x00,\n\t0xf8, 0xcc, 0xcc, 0xfc, 0xc6, 0xc6, 0xfc, 0x00, 0x38, 0x6c, 0xc6, 0xc0, 0xc0, 0xe6, 0x7c, 0x00,\n\t0xf8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0xf8, 0x00, 0xfe, 0xe6, 0x60, 0x7c, 0x60, 0xe6, 0xfe, 0x00,\n\t0xfe, 0xe6, 0x60, 0x7c, 0x60, 0xe0, 0xc0, 0x00, 0x3c, 0x66, 0xc0, 0xde, 0xc6, 0xee, 0x7c, 0x00,\n\t0xc4, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x46, 0x00, 0x7e, 0x98, 0x30, 0x30, 0x30, 0x1a, 0xfc, 0x00,\n\t0x3e, 0x0c, 0x0c, 0xe6, 0x66, 0xc6, 0x7c, 0x00, 0xe6, 0x6c, 0x78, 0x70, 0x78, 0x6c, 0xc6, 0x00,\n\t0xc0, 0xe0, 0x60, 0x60, 0x60, 0xe6, 0xfe, 0x00, 0x46, 0xee, 0xfe, 0xd6, 0xd6, 0xc6, 0x46, 0x00,\n\t0xc4, 0xe6, 0xf6, 0xde, 0xce, 0xce, 0x46, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xee, 0x7c, 0x00,\n\t0xfc, 0xe6, 0xc6, 0xce, 0xfc, 0xc0, 0xc0, 0x00, 0x38, 0x6c, 0xc6, 0xd6, 0xce, 0xec, 0x7a, 0x00,\n\t0xfc, 0xc6, 0xc6, 0xfc, 0xd8, 0xcc, 0xc6, 0x00, 0x3e, 0x66, 0x70, 0x1c, 0xc6, 0xc6, 0x7c, 0x00,\n\t0xfe, 0xba, 0x18, 0x18, 0x18, 0x38, 0x30, 0x00, 0xe6, 0x66, 0xc6, 0xc6, 0xc6, 0xe6, 0x7c, 0x00,\n\t0xce, 0xcc, 0xc6, 0xc6, 0x66, 0x7c, 0x38, 0x00, 0xce, 0xc6, 0xd6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,\n\t0xc6, 0xee, 0x6c, 0x38, 0x6c, 0xee, 0xc6, 0x00, 0xc6, 0xc6, 0x6e, 0x3c, 0x18, 0x18, 0x18, 0x00,\n\t0x76, 0xec, 0x98, 0x30, 0x62, 0xde, 0xbc, 0x00, 0x00, 0x1c, 0x10, 0x10, 0x30, 0x30, 0x3c, 0x00,\n\t0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00, 0x00, 0x1c, 0x04, 0x04, 0x0c, 0x0c, 0x3c, 0x00,\n\t0x00, 0x08, 0x1c, 0x2a, 0x08, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n\t0x00, 0x1c, 0x22, 0x78, 0x60, 0x60, 0xfc, 0x00, 0x00, 0x00, 0x1c, 0x02, 0x3e, 0x66, 0x3e, 0x00,\n\t0x00, 0x20, 0x20, 0x3c, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00, 0x1c, 0x20, 0x60, 0x60, 0x3c, 0x00,\n\t0x00, 0x02, 0x02, 0x1e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 0x1c, 0x22, 0x7c, 0x60, 0x3e, 0x00,\n\t0x00, 0x0c, 0x10, 0x18, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x1e, 0x22, 0x66, 0x3e, 0x06, 0x3c,\n\t0x00, 0x20, 0x20, 0x3c, 0x66, 0x66, 0x66, 0x00, 0x00, 0x08, 0x00, 0x08, 0x18, 0x18, 0x3c, 0x00,\n\t0x00, 0x04, 0x00, 0x04, 0x0c, 0x0c, 0x6c, 0x38, 0x00, 0x20, 0x28, 0x30, 0x70, 0x78, 0x6c, 0x00,\n\t0x00, 0x10, 0x10, 0x10, 0x30, 0x30, 0x1c, 0x00, 0x00, 0x00, 0x34, 0x2a, 0x6a, 0x6a, 0x6a, 0x00,\n\t0x00, 0x00, 0x3c, 0x22, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x1c, 0x22, 0x66, 0x66, 0x3c, 0x00,\n\t0x00, 0x00, 0x3c, 0x22, 0x66, 0x7c, 0x60, 0x60, 0x00, 0x00, 0x3c, 0x44, 0xcc, 0x7c, 0x0c, 0x0e,\n\t0x00, 0x00, 0x1c, 0x20, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x1c, 0x20, 0x3c, 0x06, 0x7c, 0x00,\n\t0x00, 0x10, 0x38, 0x10, 0x30, 0x30, 0x1c, 0x00, 0x00, 0x00, 0x22, 0x22, 0x66, 0x66, 0x3c, 0x00,\n\t0x00, 0x00, 0x44, 0x44, 0x6c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x22, 0x2a, 0x6a, 0x7e, 0x3c, 0x00,\n\t0x00, 0x00, 0x22, 0x14, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x22, 0x22, 0x66, 0x3e, 0x06, 0x3c,\n\t0x00, 0x00, 0x3e, 0x04, 0x18, 0x30, 0x7e, 0x00, 0x00, 0x0e, 0x08, 0x30, 0x10, 0x18, 0x1e, 0x00,\n\t0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x38, 0x08, 0x04, 0x08, 0x18, 0x78, 0x00,\n\t0x00, 0x12, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x99, 0xa1, 0xa1, 0x99, 0x42, 0x3c,\n\t0x09, 0x20, 0x00, 0x00, 0x00, 0x05, 0x4c, 0x00, 0x00, 0x00, 0x02, 0x91, 0xc0, 0x00, 0x07, 0xbe,\n\t0xe4, 0x1e, 0x00, 0x70, 0x02, 0x7e, 0xa0, 0xff, 0x02, 0x01, 0x21, 0xf5, 0x00, 0x57, 0x09, 0x60,\n\t0x1f, 0x95, 0xf8, 0x01, 0x20, 0x00, 0xff, 0xe0, 0x01, 0x11, 0xfc, 0x2d, 0xff, 0x01, 0x13, 0x9f,\n\t0xff, 0xe1, 0x00, 0x17, 0xff, 0xff, 0x99, 0x01, 0x16, 0x04, 0xbf, 0xfe, 0x00, 0x2c, 0x01, 0xfd,\n\t0xdf, 0x01, 0x2c, 0xff, 0x07, 0x57, 0x00, 0x3f, 0x00, 0x0e, 0xbb, 0x00, 0x78, 0x00, 0x0a, 0x96,\n\t0x00, 0x00, 0x00, 0x15, 0x02, 0x00, 0x10, 0x00, 0x20, 0x0c, 0x00, 0x00, 0x00, 0x51, 0x04, 0x00,\n\t0x10, 0x00, 0x80, 0x09, 0x00, 0x10, 0x83, 0x00, 0x12, 0x01, 0x10, 0x0a, 0x00, 0xa4, 0x00, 0x12,\n\t0x3c, 0x21, 0x48, 0x00, 0x54, 0xd2, 0x12, 0xb0, 0x00, 0x3b, 0x29, 0x41, 0x50, 0x57, 0xec, 0xd1,\n\t0x22, 0xa0, 0x00, 0x5b, 0xe4, 0x0c, 0x40, 0x00, 0xbf, 0x5b, 0x58, 0x80, 0x00, 0x77, 0xff, 0xf1,\n\t0x03, 0x02, 0xdf, 0xb7, 0x56, 0xfc, 0x01, 0xbf, 0xff, 0xe8, 0x00, 0x01, 0x3f, 0x7f, 0xc7, 0x29,\n\t0x02, 0x63, 0xc7, 0xf1, 0xff, 0x02, 0xdf, 0x8b, 0xf8, 0x1b, 0x04, 0x07, 0xfe, 0xdf, 0xff, 0x04,\n\t0x01, 0xff, 0xff, 0xff, 0x04, 0xf8, 0x7f, 0xef, 0xff, 0x0b, 0x07, 0x8b, 0xff, 0x02, 0x0c, 0x00,\n\t0x7f, 0x74, 0x1f, 0x08, 0x00, 0x00, 0xff, 0xf0, 0x07, 0x00, 0x00, 0x0f, 0xc0, 0x71, 0x00, 0x00,\n\t0x10, 0x38, 0x02, 0x80, 0x00, 0x2f, 0x8c, 0x5e, 0x80, 0x00, 0x60, 0x72, 0xe4, 0x80, 0x00, 0x40,\n\t0x99, 0x85, 0x00, 0x00, 0x43, 0x79, 0x09, 0x00, 0x00, 0x45, 0xfc, 0x0a, 0x00, 0x00, 0x4b, 0xb4,\n\t0x12, 0x00, 0x00, 0x2f, 0x94, 0x92, 0x00, 0x00, 0x2f, 0x12, 0xe4, 0x00, 0x01, 0x17, 0x9a, 0xd8,\n\t0x00, 0x00, 0x17, 0x89, 0xa8, 0x00, 0x00, 0x0f, 0xdd, 0x90, 0x00, 0x01, 0x05, 0xfc, 0x60, 0x00,\n\t0x00, 0x03, 0xfc, 0xa0, 0x00, 0x21, 0x01, 0x7e, 0xc0, 0x00, 0x09, 0x00, 0xef, 0x40, 0x00, 0x05,\n\t0x40, 0x3f, 0x80, 0x00, 0x03, 0x80, 0x0b, 0x00, 0x05, 0xbe, 0xea, 0x45, 0x00, 0x00, 0x01, 0x80,\n\t0x02, 0x00, 0x00, 0x03, 0x40, 0x02, 0x00, 0x00, 0x0d, 0x00, 0x01, 0x00, 0x00, 0x31, 0x10, 0x01,\n\t0x00, 0x00, 0xe1, 0x00, 0x00, 0x00, 0x0f, 0x79, 0x00, 0x00, 0x00, 0x77, 0xb7, 0x00, 0x00, 0x0f,\n\t0x98, 0xb3, 0x00, 0x09, 0xf0, 0x26, 0x6a, 0x00, 0x01, 0x02, 0xbc, 0x4a, 0x00, 0x09, 0xa7, 0xfd,\n\t0x84, 0x00, 0x82, 0xf9, 0xf7, 0x18, 0x00, 0x0b, 0xe1, 0xbc, 0x70, 0x00, 0x2a, 0x8f, 0xf0, 0xc0,\n\t0x00, 0x1a, 0xff, 0xe3, 0x00, 0x05, 0xf4, 0xff, 0x8c, 0x00, 0x00, 0x1c, 0xec, 0xf0, 0x00, 0x00,\n\t0x2c, 0xff, 0x00, 0x00, 0x00, 0x4c, 0xe0, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x09,\n\t0x00, 0x00, 0x01, 0x00, 0x0f, 0x40, 0x0e, 0x00, 0x00, 0x30, 0x00, 0x11, 0xc1, 0x10, 0x4f, 0x48,\n\t0x2c, 0x31, 0x00, 0x70, 0x50, 0x43, 0x89, 0x40, 0x80, 0x2d, 0x40, 0x75, 0x80, 0x83, 0xd0, 0x81,\n\t0x92, 0xea, 0x87, 0xc0, 0x87, 0x8b, 0x80, 0x47, 0x80, 0x9f, 0xcb, 0x00, 0x4d, 0x41, 0x3d, 0xcb,\n\t0x20, 0x2e, 0x41, 0x7d, 0x93, 0x00, 0x3e, 0x42, 0xf7, 0x95, 0x00, 0x16, 0x27, 0xe7, 0xa4, 0x00,\n\t0x0e, 0x95, 0xcf, 0x29, 0x00, 0x05, 0x4f, 0xdf, 0x48, 0x00, 0x02, 0x6f, 0xfe, 0x91, 0x00, 0x01,\n\t0xfb, 0xff, 0xa0, 0x00, 0x00, 0xdf, 0xfb, 0x40, 0x00, 0x00, 0xff, 0xb6, 0x80, 0x00, 0x00, 0xbf,\n\t0xa4, 0x80, 0x00, 0x40, 0xdb, 0x45, 0x00, 0x00, 0x00, 0x58, 0x05, 0x00, 0x00, 0x40, 0x00, 0x0a,\n\t0x00, 0x00, 0x00, 0x04, 0x0a, 0x00, 0x04, 0x42, 0x80, 0x8a, 0x00, 0x00, 0x47, 0x80, 0x01, 0x00,\n\t0x01, 0x4f, 0x80, 0x25, 0x00, 0x00, 0xf7, 0x52, 0x45, 0x01, 0x5f, 0xaf, 0x41, 0xa8, 0x80, 0x00,\n\t0x3f, 0x56, 0xf2, 0x80, 0x01, 0x5f, 0xfb, 0xb6, 0x80, 0x02, 0xbb, 0xff, 0xfa, 0x40, 0x00, 0xbf,\n\t0xe6, 0xfd, 0x40, 0x09, 0x6f, 0xcf, 0xf9, 0x40, 0x01, 0x5d, 0xe7, 0xf8, 0x80, 0x01, 0x1f, 0x7f,\n\t0xf1, 0x00, 0x02, 0x17, 0x12, 0x8e, 0x00, 0x02, 0x0f, 0x00, 0x1c, 0x00, 0x02, 0x04, 0x03, 0xe0,\n\t0x00, 0x03, 0x01, 0xfc, 0x00, 0x00, 0x01, 0xfe, 0xf0, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x3e,\n\t0xa8, 0x00, 0xec, 0x00, 0x41, 0xf0, 0x00, 0x72, 0x00, 0xbc, 0xdf, 0x60, 0xca, 0x01, 0x03, 0x30,\n\t0x00, 0xc9, 0x02, 0x60, 0xa8, 0x00, 0xe5, 0x04, 0xf0, 0xa0, 0x00, 0xf4, 0x85, 0xcc, 0xa2, 0x00,\n\t0xfa, 0x4f, 0xce, 0x20, 0x00, 0x7f, 0x5b, 0x8d, 0x40, 0x00, 0x7b, 0x3f, 0x9e, 0x40, 0x00, 0x7f,\n\t0xbf, 0xba, 0xa0, 0x00, 0xdb, 0xfd, 0x74, 0xa0, 0x00, 0xbf, 0xb7, 0xf5, 0x00, 0x00, 0x4d, 0xf7,\n\t0x49, 0x20, 0x00, 0x19, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x54, 0xb2, 0x00, 0x00, 0x42, 0x01, 0x2c,\n\t0x00, 0x00, 0x20, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x40, 0x10, 0xc5, 0x00,\n\t0x00, 0xa1, 0x04, 0x24, 0x80, 0x00, 0x02, 0x00, 0x2a, 0x40, 0x00, 0x74, 0x20, 0x6b, 0x40, 0x00,\n\t0x69, 0x59, 0x5f, 0x21, 0x00, 0xad, 0x5b, 0xde, 0xa0, 0x00, 0xfd, 0xaf, 0xf7, 0x91, 0x00, 0x6f,\n\t0x27, 0x73, 0x50, 0x00, 0xff, 0x47, 0xfb, 0xc9, 0x00, 0xde, 0x85, 0xb9, 0xa9, 0x10, 0xbd, 0x03,\n\t0xbc, 0xa5, 0x00, 0x3d, 0x02, 0xfc, 0xd5, 0x40, 0x3a, 0x02, 0xdc, 0xd5, 0x80, 0xba, 0x01, 0x5c,\n\t0xd2, 0xf5, 0xf4, 0x01, 0x3c, 0xcb, 0x80, 0x68, 0x00, 0x8b, 0xcd, 0x00, 0xb0, 0x00, 0x82, 0x89,\n\t0x20, 0xc0, 0x00, 0x80, 0x10, 0x00, 0x80, 0x00, 0x40, 0xe1, 0x00, 0x00, 0x00, 0x3f, 0x01, 0x00,\n\t0x47, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x47, 0x47, 0x47, 0x47, 0x47, 0x07, 0x47, 0x47,\n\t0x47, 0x47, 0x47, 0x07, 0x47, 0x47, 0x07, 0x07, 0x47, 0x07, 0x47, 0x07, 0x47, 0x47, 0x47, 0x07,\n\t0x07, 0x47, 0x07, 0x07, 0x47, 0x47, 0x07, 0x07, 0x05, 0x45, 0x47, 0x47, 0x47, 0x07, 0x45, 0x47,\n\t0x07, 0x47, 0x07, 0x07, 0x07, 0x07, 0x47, 0x07, 0x47, 0x07, 0x07, 0x07, 0x05, 0x45, 0x45, 0x45,\n\t0x05, 0x05, 0x45, 0x05, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05, 0x45, 0x45, 0x45, 0x45, 0x05, 0x07,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x45, 0x45, 0x05, 0x45, 0x45, 0x05, 0x45, 0x45, 0x05,\n\t0x45, 0x05, 0x45, 0x07, 0x78, 0x41, 0xa6, 0xe6, 0x66, 0x00, 0x78, 0x41, 0x9e, 0xde, 0x5e, 0x00,\n\t0xfe, 0x42, 0x9e, 0xde, 0x5e, 0x00, 0xfe, 0x42, 0x96, 0xd6, 0x56, 0x00, 0x82, 0x43, 0x9e, 0xde,\n\t0x5e, 0x00, 0x82, 0x43, 0x96, 0xd6, 0x56, 0x00, 0xac, 0x46, 0xa6, 0xe6, 0x66, 0x00, 0xac, 0x46,\n\t0x9e, 0xde, 0x5e, 0x00, 0xdb, 0x48, 0xbe, 0xfe, 0x7e, 0x00, 0xdb, 0x48, 0xb6, 0xf6, 0x76, 0x00,\n\t0xe8, 0x49, 0xa6, 0xe6, 0x66, 0x00, 0xe8, 0x49, 0x9e, 0xde, 0x5e, 0x00, 0x25, 0x4e, 0xbe, 0xfe,\n\t0x7e, 0x00, 0x25, 0x4e, 0xb6, 0xf6, 0x76, 0x00, 0x53, 0x4e, 0xbe, 0xfe, 0x7e, 0x00, 0x53, 0x4e,\n\t0xb6, 0xf6, 0x76, 0x00, 0x8e, 0x56, 0x8e, 0xce, 0x4e, 0x00, 0x8e, 0x56, 0x86, 0xc6, 0x46, 0x00,\n\t0xa1, 0x56, 0xa6, 0xe6, 0x66, 0x00, 0xa1, 0x56, 0x9e, 0xde, 0x5e, 0x00, 0x78, 0x42, 0xa6, 0xe6,\n\t0x66, 0x00, 0x78, 0x42, 0x9e, 0xde, 0x5e, 0x00, 0xfe, 0x43, 0x9e, 0xde, 0x5e, 0x00, 0xfe, 0x43,\n\t0x96, 0xd6, 0x56, 0x00, 0x82, 0x44, 0x9e, 0xde, 0x5e, 0x00, 0x82, 0x44, 0x96, 0xd6, 0x56, 0x00,\n\t0xac, 0x47, 0xa6, 0xe6, 0x66, 0x00, 0xac, 0x47, 0x9e, 0xde, 0x5e, 0x00, 0xdb, 0x49, 0xbe, 0xfe,\n\t0x7e, 0x00, 0xdb, 0x49, 0xb6, 0xf6, 0x76, 0x00, 0xe8, 0x4a, 0xa6, 0xe6, 0x66, 0x00, 0xe8, 0x4a,\n\t0x9e, 0xde, 0x5e, 0x00, 0x25, 0x4f, 0xbe, 0xfe, 0x7e, 0x00, 0x25, 0x4f, 0xb6, 0xf6, 0x76, 0x00,\n\t0x53, 0x4f, 0xbe, 0xfe, 0x7e, 0x00, 0x53, 0x4f, 0xb6, 0xf6, 0x76, 0x00, 0x8e, 0x57, 0x8e, 0xce,\n\t0x4e, 0x00, 0x8e, 0x57, 0x86, 0xc6, 0x46, 0x00, 0xa1, 0x57, 0xa6, 0xe6, 0x66, 0x00, 0xa1, 0x57,\n\t0x9e, 0xde, 0x5e, 0x00, 0xad, 0x43, 0x8e, 0xce, 0x4e, 0x00, 0xe2, 0x43, 0xb6, 0xf6, 0x76, 0x00,\n\t0xea, 0x43, 0xa6, 0xe6, 0x66, 0x00, 0x46, 0x44, 0xbe, 0xfe, 0x7e, 0x00, 0x2f, 0x48, 0x86, 0xc6,\n\t0x46, 0x00, 0xa7, 0x49, 0x9e, 0xde, 0x5e, 0x00, 0xea, 0x49, 0x8e, 0xce, 0x4e, 0x00, 0x6c, 0x4a,\n\t0xb6, 0xf6, 0x76, 0x00, 0xb4, 0x4b, 0x8e, 0xce, 0x4e, 0x00, 0xe3, 0x4b, 0x86, 0xc6, 0x46, 0x00,\n\t0x3a, 0x4d, 0xbe, 0xfe, 0x7e, 0x00, 0x80, 0x4d, 0x96, 0xd6, 0x56, 0x00, 0x9d, 0x4d, 0x86, 0xc6,\n\t0x46, 0x00, 0xb0, 0x4d, 0x96, 0xd6, 0x56, 0x00, 0xd2, 0x52, 0x86, 0xc6, 0x46, 0x00, 0x2d, 0x53,\n\t0xae, 0xee, 0x6e, 0x00, 0x32, 0x53, 0x9e, 0xde, 0x5e, 0x00, 0x17, 0x54, 0xa6, 0xe6, 0x66, 0x00,\n\t0x9c, 0x55, 0xb6, 0xf6, 0x76, 0x00, 0x89, 0x57, 0xb6, 0xf6, 0x76, 0x00, 0x2c, 0x40, 0x06, 0x48,\n\t0xd4, 0x78, 0x49, 0x50, 0x07, 0x06, 0x46, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0xc3, 0x59, 0xeb, 0xc3, 0xda, 0xeb, 0xc3, 0x44, 0xed, 0xf3, 0x2a, 0x35, 0xf0, 0x22, 0x60, 0xec,\n\t0x2a, 0x37, 0xf0, 0x22, 0x74, 0xec, 0x2a, 0x39, 0xf0, 0x22, 0x88, 0xec, 0x3e, 0x01, 0x32, 0x62,\n\t0xec, 0x32, 0x76, 0xec, 0x32, 0x8a, 0xec, 0x3e, 0x08, 0x32, 0x63, 0xec, 0x32, 0x77, 0xec, 0x32,\n\t0x8b, 0xec, 0x21, 0x20, 0xec, 0x11, 0x20, 0x00, 0x22, 0xfa, 0xeb, 0x19, 0x22, 0xfc, 0xeb, 0x19,\n\t0x22, 0xfe, 0xeb, 0x21, 0x00, 0x00, 0x22, 0x6e, 0xec, 0x22, 0x82, 0xec, 0x22, 0x96, 0xec, 0x22,\n\t0x70, 0xec, 0x22, 0x84, 0xec, 0x22, 0x98, 0xec, 0xaf, 0x32, 0xf4, 0xeb, 0xc9, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xff, 0x16, 0x07, 0xcd, 0x9b,\n\t0xed, 0xcd, 0x85, 0xed, 0x00, 0xc9, 0xe3, 0xff, 0xf6, 0x03, 0xbd, 0x00, 0x0d, 0xff, 0x0a, 0x0d,\n\t0x0a, 0x00, 0x00, 0x00, 0x0d, 0x03, 0x4f, 0x69, 0x5c, 0xc4, 0x16, 0xc4, 0x3c, 0xc4, 0x5c, 0xc4,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc7, 0x1c, 0xd8, 0x94, 0xc7, 0x94, 0xc7,\n\t0x16, 0x95, 0xd7, 0xc7, 0xb5, 0xc6, 0x68, 0xaa, 0x5a, 0xaa, 0xfe, 0x07, 0x58, 0xaa, 0xfe, 0x06,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc7, 0x1c, 0xd8,\n\t0x94, 0xc7, 0xb5, 0xc6, 0xb5, 0xc6, 0x63, 0x8c, 0x94, 0xc7, 0xb5, 0xc6, 0x05, 0xab, 0xe6, 0x02,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc7, 0x94, 0xc7, 0x00, 0x94,\n\t0x94, 0xc7, 0x94, 0xc7, 0x57, 0x89, 0x94, 0xc7, 0x57, 0x89, 0xb5, 0xc6, 0xc5, 0xab, 0xe6, 0x02,\n\t0xfa, 0xaa, 0x05, 0x01, 0xd4, 0xaa, 0x01, 0xe3, 0xff, 0x0a, 0xcc, 0xaa, 0x05, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x4d, 0x0f, 0x09, 0xab, 0x0f, 0x08, 0x9d, 0xab, 0x01, 0xf6, 0x03, 0x0d, 0x97, 0xab,\n\t0xa7, 0xab, 0x00, 0x00, 0xa2, 0xab, 0x19, 0x08, 0xcf, 0xab, 0x05, 0x08, 0xd0, 0xad, 0x01, 0xbd,\n\t0x00, 0x0a, 0xc4, 0xad, 0xda, 0xad, 0x00, 0x00, 0xd5, 0xad, 0x36, 0x04, 0xbf, 0x0f, 0xdc, 0x0e,\n\t0x07, 0x0e, 0x3d, 0x0d, 0x7f, 0x0c, 0xcc, 0x0b, 0x22, 0x0b, 0x82, 0x0a, 0xeb, 0x09, 0x5d, 0x09,\n\t0xd6, 0x08, 0x57, 0x08, 0xdf, 0x07, 0x6e, 0x07, 0x03, 0x07, 0x9f, 0x06, 0x40, 0x06, 0xe6, 0x05,\n\t0x91, 0x05, 0x41, 0x05, 0xf6, 0x04, 0xae, 0x04, 0x6b, 0x04, 0x2c, 0x04, 0xf0, 0x03, 0xb7, 0x03,\n\t0x82, 0x03, 0x4f, 0x03, 0x20, 0x03, 0xf3, 0x02, 0xc8, 0x02, 0xa1, 0x02, 0x7b, 0x02, 0x57, 0x02,\n\t0x36, 0x02, 0x16, 0x02, 0xf8, 0x01, 0xdc, 0x01, 0xc1, 0x01, 0xa8, 0x01, 0x90, 0x01, 0x79, 0x01,\n\t0x64, 0x01, 0x50, 0x01, 0x3d, 0x01, 0x2c, 0x01, 0x1b, 0x01, 0x0b, 0x01, 0xfc, 0x00, 0xee, 0x00,\n\t0xe0, 0x00, 0xd4, 0x00, 0xc8, 0x00, 0xbd, 0x00, 0xb2, 0x00, 0xa8, 0x00, 0x9f, 0x00, 0x96, 0x00,\n\t0x8d, 0x00, 0x85, 0x00, 0x7e, 0x00, 0x77, 0x00, 0x70, 0x00, 0x6a, 0x00, 0x64, 0x00, 0x5e, 0x00,\n\t0x59, 0x00, 0x54, 0x00, 0x4f, 0x00, 0x4b, 0x00, 0x47, 0x00, 0x43, 0x00, 0x3f, 0x00, 0x3b, 0x00,\n\t0x38, 0x00, 0x35, 0x00, 0x32, 0x00, 0x2f, 0x00, 0x2d, 0x00, 0x2a, 0x00, 0x28, 0x00, 0x25, 0x00,\n\t0x23, 0x00, 0x21, 0x00, 0xdd, 0x21, 0x60, 0xec, 0x2a, 0xfa, 0xeb, 0x3e, 0x01, 0xcd, 0xb0, 0xed,\n\t0x22, 0xfa, 0xeb, 0xdd, 0x21, 0x74, 0xec, 0x2a, 0xfc, 0xeb, 0x3e, 0x02, 0xcd, 0xb0, 0xed, 0x22,\n\t0xfc, 0xeb, 0xdd, 0x21, 0x88, 0xec, 0x2a, 0xfe, 0xeb, 0x3e, 0x03, 0xcd, 0xb0, 0xed, 0x22, 0xfe,\n\t0xeb, 0x3a, 0x8b, 0xec, 0x07, 0x47, 0x3a, 0x77, 0xec, 0xb0, 0x07, 0x47, 0x3a, 0x63, 0xec, 0xb0,\n\t0x16, 0x07, 0xcd, 0x9b, 0xed, 0x16, 0x0d, 0x21, 0xf3, 0xeb, 0x7a, 0x01, 0xfd, 0xff, 0xed, 0x79,\n\t0x7e, 0x06, 0xbf, 0xed, 0x79, 0x2b, 0x15, 0xf2, 0x8a, 0xed, 0xc9, 0x01, 0xe6, 0xeb, 0x6a, 0x26,\n\t0x00, 0x09, 0x77, 0xc9, 0xed, 0x73, 0xf8, 0xeb, 0x2a, 0xf8, 0xeb, 0xed, 0x7b, 0xf6, 0xeb, 0xc9,\n\t0xed, 0x73, 0xf6, 0xeb, 0xf9, 0x32, 0xf5, 0xeb, 0xdd, 0x35, 0x02, 0xca, 0xbf, 0xee, 0xdd, 0x35,\n\t0x06, 0x20, 0x36, 0xdd, 0x6e, 0x04, 0xdd, 0x66, 0x05, 0x7e, 0xfe, 0x80, 0x20, 0x0c, 0x23, 0x5e,\n\t0x23, 0x56, 0xdd, 0x73, 0x04, 0xdd, 0x72, 0x05, 0x18, 0xe9, 0xfe, 0x1e, 0x38, 0x0c, 0xd6, 0x32,\n\t0xdd, 0x77, 0x09, 0xdd, 0x36, 0x06, 0x01, 0x23, 0x18, 0x09, 0xdd, 0x77, 0x09, 0x23, 0x7e, 0xdd,\n\t0x77, 0x06, 0x23, 0xdd, 0x75, 0x04, 0xdd, 0x74, 0x05, 0xdd, 0x7e, 0x07, 0xdd, 0xb6, 0x08, 0xca,\n\t0x82, 0xee, 0xdd, 0xcb, 0x0e, 0x56, 0xc2, 0x82, 0xee, 0xdd, 0x6e, 0x0c, 0xdd, 0x66, 0x0d, 0x7e,\n\t0x23, 0xdd, 0x75, 0x0c, 0xdd, 0x74, 0x0d, 0xfe, 0x80, 0x20, 0x06, 0x7e, 0x23, 0x66, 0x6f, 0x18,\n\t0xee, 0xfe, 0x82, 0xc2, 0x2d, 0xee, 0xdd, 0xcb, 0x0e, 0xde, 0xc3, 0x0f, 0xee, 0xfe, 0x83, 0xc2,\n\t0x39, 0xee, 0xdd, 0xcb, 0x0e, 0x9e, 0xc3, 0x0f, 0xee, 0xfe, 0x84, 0xc2, 0x49, 0xee, 0x3e, 0x09,\n\t0xdd, 0xae, 0x03, 0xdd, 0x77, 0x03, 0xc3, 0x0f, 0xee, 0xdd, 0xcb, 0x0e, 0x5e, 0xca, 0x6b, 0xee,\n\t0xdd, 0x86, 0x12, 0xdd, 0x77, 0x12, 0x3d, 0x87, 0x5f, 0x16, 0x00, 0x21, 0x9c, 0xec, 0x19, 0x7e,\n\t0xdd, 0x77, 0x07, 0x23, 0x7e, 0xdd, 0x77, 0x08, 0xc3, 0x82, 0xee, 0x5f, 0x16, 0x00, 0xdd, 0x6e,\n\t0x07, 0xdd, 0x66, 0x08, 0xe6, 0x80, 0xca, 0x7b, 0xee, 0x16, 0xff, 0x19, 0xdd, 0x75, 0x07, 0xdd,\n\t0x74, 0x08, 0x3a, 0xf4, 0xeb, 0x16, 0x06, 0xcd, 0x9b, 0xed, 0xdd, 0xcb, 0x0e, 0x96, 0x3a, 0xf5,\n\t0xeb, 0xc6, 0x07, 0x57, 0xdd, 0x7e, 0x07, 0xdd, 0xb6, 0x08, 0x28, 0x03, 0xdd, 0x7e, 0x09, 0xcd,\n\t0x9b, 0xed, 0x3a, 0xf5, 0xeb, 0x3d, 0x87, 0x57, 0xdd, 0x7e, 0x07, 0xcd, 0x9b, 0xed, 0x14, 0xdd,\n\t0x7e, 0x08, 0xcd, 0x9b, 0xed, 0xc3, 0xa4, 0xed, 0xdd, 0x75, 0x00, 0xdd, 0x74, 0x01, 0xc9, 0xdd,\n\t0x6e, 0x00, 0xdd, 0x66, 0x01, 0x7e, 0x23, 0xcd, 0xb8, 0xee, 0xcb, 0x7f, 0xc2, 0x3c, 0xef, 0x22,\n\t0xf8, 0xeb, 0xb7, 0x28, 0x1b, 0xdd, 0x86, 0x0f, 0xdd, 0x77, 0x12, 0xdd, 0xcb, 0x0e, 0x9e, 0x3d,\n\t0x87, 0x5f, 0x16, 0x00, 0x21, 0x9c, 0xec, 0x19, 0x5e, 0x23, 0x56, 0x2a, 0xf8, 0xeb, 0x18, 0x03,\n\t0x11, 0x00, 0x00, 0x7e, 0x23, 0xcd, 0xb8, 0xee, 0xdd, 0x77, 0x02, 0xdd, 0x73, 0x07, 0xdd, 0x72,\n\t0x08, 0xdd, 0x7e, 0x10, 0xdd, 0x77, 0x0c, 0xdd, 0x7e, 0x11, 0xdd, 0x77, 0x0d, 0xdd, 0xcb, 0x0e,\n\t0xd6, 0xdd, 0xcb, 0x0e, 0x4e, 0xc2, 0xbe, 0xed, 0xdd, 0xcb, 0x0e, 0x46, 0xca, 0x23, 0xef, 0xdd,\n\t0xcb, 0x0e, 0xce, 0xdd, 0x4e, 0x0a, 0xdd, 0x46, 0x0b, 0x0a, 0xdd, 0x77, 0x09, 0x03, 0x0a, 0x03,\n\t0xdd, 0x77, 0x06, 0xdd, 0x71, 0x04, 0xdd, 0x70, 0x05, 0xc3, 0x82, 0xee, 0xe6, 0x7f, 0x22, 0xf8,\n\t0xeb, 0x87, 0x5f, 0x16, 0x00, 0x21, 0x52, 0xef, 0x19, 0x7e, 0x23, 0x66, 0x6f, 0xe5, 0x2a, 0xf8,\n\t0xeb, 0xc9, 0x70, 0xef, 0x7c, 0xef, 0x8a, 0xef, 0x94, 0xef, 0xa6, 0xef, 0xb1, 0xef, 0xde, 0xef,\n\t0xbc, 0xef, 0xcc, 0xef, 0xd7, 0xef, 0xee, 0xef, 0xfc, 0xef, 0x0a, 0xf0, 0x17, 0xf0, 0x27, 0xf0,\n\t0x7e, 0xdd, 0x77, 0x00, 0x23, 0x7e, 0xdd, 0x77, 0x01, 0xc3, 0xbf, 0xee, 0x7e, 0xdd, 0x77, 0x00,\n\t0x23, 0x7e, 0xdd, 0x77, 0x01, 0x23, 0xe5, 0xc3, 0xbf, 0xee, 0x46, 0xc5, 0x23, 0xe5, 0xcd, 0xb8,\n\t0xee, 0xc3, 0xbf, 0xee, 0xd1, 0xc1, 0x10, 0x03, 0xc3, 0xbf, 0xee, 0xc5, 0xd5, 0xdd, 0x73, 0x00,\n\t0xdd, 0x72, 0x01, 0xc3, 0xbf, 0xee, 0x7e, 0x23, 0x32, 0xf4, 0xeb, 0xcd, 0xb8, 0xee, 0xc3, 0xbf,\n\t0xee, 0x7e, 0x23, 0xcd, 0xb8, 0xee, 0xdd, 0x77, 0x03, 0xc3, 0xbf, 0xee, 0x7e, 0xdd, 0x77, 0x0a,\n\t0x23, 0x7e, 0xdd, 0x77, 0x0b, 0x23, 0xcd, 0xb8, 0xee, 0xc3, 0xbf, 0xee, 0x7e, 0x23, 0xcd, 0xb8,\n\t0xee, 0xdd, 0x77, 0x0f, 0xc3, 0xbf, 0xee, 0xe1, 0xcd, 0xb8, 0xee, 0xc3, 0xbf, 0xee, 0x7e, 0xdd,\n\t0x77, 0x10, 0x23, 0x7e, 0xdd, 0x77, 0x11, 0x23, 0xcd, 0xb8, 0xee, 0xc3, 0xbf, 0xee, 0xdd, 0xcb,\n\t0x0e, 0xc6, 0xdd, 0xcb, 0x0e, 0x8e, 0xcd, 0xb8, 0xee, 0xc3, 0xbf, 0xee, 0xdd, 0xcb, 0x0e, 0x86,\n\t0xdd, 0xcb, 0x0e, 0x8e, 0xcd, 0xb8, 0xee, 0xc3, 0xbf, 0xee, 0x5e, 0x23, 0x56, 0x23, 0xcd, 0xb8,\n\t0xee, 0x01, 0xbf, 0xee, 0xc5, 0xd5, 0xc9, 0x3a, 0xf4, 0xeb, 0x86, 0xe6, 0x0f, 0x32, 0xf4, 0xeb,\n\t0x23, 0xcd, 0xb8, 0xee, 0xc3, 0xbf, 0xee, 0x7e, 0xdd, 0x86, 0x0f, 0xdd, 0x77, 0x0f, 0x23, 0xcd,\n\t0xb8, 0xee, 0xc3, 0xbf, 0xee, 0x99, 0xf5, 0x96, 0xf4, 0x3b, 0xf0, 0x82, 0x04, 0x81, 0x57, 0xf4,\n\t0x83, 0x81, 0x6d, 0xf3, 0x81, 0x6d, 0xf3, 0x81, 0x00, 0xf4, 0x81, 0x33, 0xf3, 0x81, 0x33, 0xf3,\n\t0x81, 0x17, 0xf3, 0x81, 0x6a, 0xf2, 0x81, 0x6a, 0xf2, 0x88, 0x00, 0x81, 0xba, 0xf2, 0x81, 0xba,\n\t0xf2, 0x88, 0x02, 0x81, 0xba, 0xf2, 0x88, 0x00, 0x81, 0xef, 0xf2, 0x82, 0x04, 0x81, 0x49, 0xf2,\n\t0x83, 0x81, 0x17, 0xf3, 0x81, 0x49, 0xf2, 0x81, 0x49, 0xf2, 0x81, 0x1a, 0xf3, 0x81, 0x49, 0xf2,\n\t0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7, 0x2b, 0x23, 0x86, 0x9b, 0xf7, 0x2b, 0x0c, 0x86, 0x5e, 0xf7,\n\t0x2d, 0x48, 0x2b, 0x0c, 0x2d, 0x0c, 0x32, 0x0c, 0x30, 0x0c, 0x2d, 0x18, 0x30, 0x24, 0x86, 0x9b,\n\t0xf7, 0x30, 0x0c, 0x86, 0x5e, 0xf7, 0x32, 0x48, 0x32, 0x0c, 0x37, 0x0c, 0x36, 0x0c, 0x32, 0x0c,\n\t0x2d, 0x18, 0x2b, 0x24, 0x86, 0x9b, 0xf7, 0x2b, 0x0c, 0x86, 0x5e, 0xf7, 0x2d, 0x48, 0x32, 0x0c,\n\t0x86, 0x97, 0xf7, 0x32, 0x0c, 0x86, 0x5e, 0xf7, 0x32, 0x0c, 0x30, 0x0c, 0x2d, 0x18, 0x32, 0x24,\n\t0x86, 0x97, 0xf7, 0x32, 0x0c, 0x86, 0x5e, 0xf7, 0x30, 0x48, 0x32, 0x0c, 0x34, 0x0c, 0x37, 0x0c,\n\t0x36, 0x0c, 0x37, 0x0c, 0x39, 0x0c, 0x37, 0x24, 0x86, 0x9b, 0xf7, 0x37, 0x0c, 0x86, 0x5e, 0xf7,\n\t0x39, 0x30, 0x37, 0x06, 0x39, 0x0c, 0x37, 0x06, 0x39, 0x0c, 0x37, 0x06, 0x36, 0x0c, 0x37, 0x06,\n\t0x36, 0x0c, 0x34, 0x0c, 0x32, 0x0c, 0x30, 0x06, 0x32, 0x0c, 0x30, 0x06, 0x32, 0x0c, 0x30, 0x06,\n\t0x2f, 0x0c, 0x30, 0x06, 0x2f, 0x0c, 0x2d, 0x0c, 0x2b, 0x0c, 0x2d, 0x06, 0x2d, 0x0c, 0x2b, 0x06,\n\t0x2d, 0x0c, 0x2f, 0x06, 0x30, 0x0c, 0x32, 0x06, 0x34, 0x0c, 0x36, 0x0c, 0x37, 0x0c, 0x3b, 0x24,\n\t0x86, 0x97, 0xf7, 0x3b, 0x0c, 0x86, 0x5e, 0xf7, 0x39, 0x48, 0x37, 0x0c, 0x39, 0x0c, 0x3c, 0x06,\n\t0x3c, 0x06, 0x39, 0x0c, 0x3e, 0x0c, 0x3c, 0x0c, 0x40, 0x24, 0x86, 0x97, 0xf7, 0x40, 0x0c, 0x86,\n\t0x5e, 0xf7, 0x3e, 0x60, 0x00, 0x06, 0x3e, 0x06, 0x3e, 0x06, 0x40, 0x06, 0x41, 0x06, 0x40, 0x06,\n\t0x3c, 0x06, 0x3e, 0x07, 0x81, 0xd9, 0xf1, 0x81, 0x11, 0xf2, 0x82, 0x02, 0x3d, 0x0b, 0x36, 0x0c,\n\t0x3b, 0x0c, 0x36, 0x06, 0x3a, 0x0c, 0x36, 0x06, 0x38, 0x0c, 0x36, 0x06, 0x36, 0x06, 0x3b, 0x06,\n\t0x3d, 0x06, 0x3d, 0x06, 0x3d, 0x06, 0x36, 0x0c, 0x3b, 0x0c, 0x36, 0x06, 0x3a, 0x0c, 0x36, 0x06,\n\t0x38, 0x0c, 0x36, 0x06, 0x36, 0x06, 0x3b, 0x06, 0x3d, 0x07, 0x83, 0x81, 0x6a, 0xf2, 0x81, 0x49,\n\t0xf2, 0x81, 0xc3, 0xf1, 0x81, 0x1a, 0xf3, 0x81, 0x4c, 0xf2, 0x81, 0xba, 0xf2, 0x81, 0x4c, 0xf2,\n\t0x88, 0x02, 0x81, 0xba, 0xf2, 0x88, 0x00, 0x81, 0xef, 0xf2, 0x81, 0x4c, 0xf2, 0x81, 0xc3, 0xf1,\n\t0x80, 0x3b, 0xf0, 0x87, 0xff, 0xf6, 0x46, 0x18, 0x00, 0x30, 0x87, 0x33, 0xf7, 0x86, 0x1b, 0xf7,\n\t0x28, 0x0b, 0x00, 0x01, 0x28, 0x0b, 0x00, 0x01, 0x89, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7, 0x82,\n\t0x02, 0x40, 0x0b, 0x39, 0x0c, 0x3e, 0x0c, 0x39, 0x06, 0x3c, 0x0c, 0x39, 0x06, 0x3b, 0x0c, 0x3c,\n\t0x06, 0x39, 0x06, 0x3c, 0x06, 0x3e, 0x06, 0x40, 0x06, 0x40, 0x06, 0x39, 0x0c, 0x3e, 0x0c, 0x39,\n\t0x06, 0x3c, 0x0c, 0x39, 0x06, 0x3b, 0x0c, 0x3c, 0x06, 0x39, 0x06, 0x3c, 0x06, 0x3e, 0x07, 0x83,\n\t0x89, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7, 0x82, 0x02, 0x40, 0x0b, 0x39, 0x0c, 0x3f, 0x0c, 0x39,\n\t0x06, 0x3d, 0x0c, 0x3d, 0x06, 0x3b, 0x0c, 0x3d, 0x06, 0x39, 0x06, 0x3d, 0x06, 0x3f, 0x06, 0x40,\n\t0x06, 0x40, 0x06, 0x39, 0x0c, 0x3f, 0x0c, 0x39, 0x06, 0x3d, 0x0c, 0x3d, 0x06, 0x3b, 0x0c, 0x3d,\n\t0x06, 0x39, 0x06, 0x3d, 0x06, 0x3f, 0x07, 0x83, 0x89, 0x81, 0x4c, 0xf2, 0x86, 0x45, 0xf7, 0x87,\n\t0x9f, 0xf7, 0x82, 0x04, 0x46, 0x06, 0x83, 0x46, 0x0c, 0x44, 0x06, 0x46, 0x0a, 0x00, 0x02, 0x44,\n\t0x06, 0x46, 0x0a, 0x00, 0x02, 0x46, 0x0c, 0x44, 0x0c, 0x89, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7,\n\t0x36, 0x23, 0x86, 0x97, 0xf7, 0x36, 0x0c, 0x86, 0x5e, 0xf7, 0x34, 0x18, 0x31, 0x0c, 0x2f, 0x18,\n\t0x2e, 0x0c, 0x2e, 0x0c, 0x81, 0xef, 0xf3, 0x8e, 0xfd, 0x81, 0xef, 0xf3, 0x8e, 0x03, 0x87, 0x4f,\n\t0xf7, 0x86, 0x5e, 0xf7, 0x2e, 0x0c, 0x2f, 0x0c, 0x31, 0x0c, 0x31, 0x12, 0x31, 0x12, 0x31, 0x0c,\n\t0x34, 0x12, 0x31, 0x12, 0x2f, 0x0c, 0x31, 0x18, 0x86, 0x97, 0xf7, 0x31, 0x30, 0x81, 0xef, 0xf3,\n\t0x8e, 0xfd, 0x81, 0xef, 0xf3, 0x00, 0x01, 0x8e, 0x03, 0x89, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7,\n\t0x32, 0x18, 0x81, 0xef, 0xf3, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7, 0x32, 0x06, 0x32, 0x06, 0x34,\n\t0x12, 0x32, 0x12, 0x30, 0x0c, 0x32, 0x18, 0x81, 0xef, 0xf3, 0x8e, 0xfb, 0x81, 0xef, 0xf3, 0x81,\n\t0x87, 0xf5, 0x86, 0x1b, 0xf7, 0x87, 0x33, 0xf7, 0x8e, 0x05, 0x2b, 0x0c, 0x28, 0x0c, 0x89, 0x87,\n\t0x4f, 0xf7, 0x86, 0x5e, 0xf7, 0x34, 0x18, 0x81, 0xef, 0xf3, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7,\n\t0x34, 0x06, 0x34, 0x06, 0x36, 0x12, 0x34, 0x12, 0x32, 0x0c, 0x34, 0x12, 0x36, 0x12, 0x38, 0x0c,\n\t0x36, 0x12, 0x38, 0x12, 0x39, 0x0c, 0x89, 0x81, 0x1a, 0xf3, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7,\n\t0x82, 0x02, 0x82, 0x02, 0x30, 0x06, 0x2f, 0x0c, 0x2e, 0x06, 0x2d, 0x0c, 0x83, 0x30, 0x0c, 0x32,\n\t0x0c, 0x83, 0x89, 0x87, 0x4f, 0xf7, 0x86, 0x7c, 0xf7, 0x82, 0x04, 0x30, 0x06, 0x2f, 0x0c, 0x2e,\n\t0x06, 0x2d, 0x0c, 0x83, 0x30, 0x06, 0x2f, 0x0c, 0x2d, 0x06, 0x35, 0x0c, 0x34, 0x0c, 0x82, 0x02,\n\t0x35, 0x06, 0x34, 0x0c, 0x33, 0x06, 0x32, 0x0c, 0x83, 0x35, 0x0c, 0x34, 0x0c, 0x82, 0x02, 0x2f,\n\t0x06, 0x2e, 0x0c, 0x2d, 0x06, 0x2c, 0x0c, 0x83, 0x30, 0x0c, 0x2f, 0x0c, 0x89, 0x87, 0x4f, 0xf7,\n\t0x86, 0x5e, 0xf7, 0x88, 0x00, 0x00, 0x05, 0x2d, 0x06, 0x2d, 0x0c, 0x2d, 0x0c, 0x2d, 0x0c, 0x2d,\n\t0x18, 0x2d, 0x1e, 0x2d, 0x06, 0x34, 0x0c, 0x34, 0x0c, 0x34, 0x0c, 0x34, 0x18, 0x81, 0xef, 0xf3,\n\t0x00, 0x0c, 0x35, 0x18, 0x34, 0x18, 0x35, 0x18, 0x34, 0x0c, 0x32, 0x12, 0x2f, 0x06, 0x2f, 0x0c,\n\t0x2f, 0x0c, 0x2f, 0x0c, 0x2f, 0x18, 0x81, 0xef, 0xf3, 0x00, 0x0c, 0x00, 0x06, 0x30, 0x06, 0x30,\n\t0x0c, 0x30, 0x0c, 0x30, 0x0c, 0x30, 0x18, 0x30, 0x1e, 0x30, 0x06, 0x37, 0x0c, 0x37, 0x0c, 0x37,\n\t0x0c, 0x37, 0x18, 0x81, 0xef, 0xf3, 0x00, 0x0c, 0x38, 0x18, 0x37, 0x18, 0x38, 0x18, 0x37, 0x0c,\n\t0x35, 0x12, 0x32, 0x06, 0x32, 0x0c, 0x32, 0x0c, 0x32, 0x0c, 0x32, 0x18, 0x87, 0x33, 0xf7, 0x86,\n\t0x1b, 0xf7, 0x00, 0x01, 0x2d, 0x0b, 0x00, 0x01, 0x28, 0x05, 0x00, 0x01, 0x28, 0x06, 0x89, 0x87,\n\t0x33, 0xf7, 0x86, 0x1b, 0xf7, 0x00, 0x01, 0x2b, 0x0b, 0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7, 0x89,\n\t0x87, 0x69, 0xf7, 0x84, 0x1f, 0x85, 0x01, 0x82, 0x04, 0x07, 0x06, 0x8d, 0xfe, 0x83, 0x85, 0x08,\n\t0x87, 0x4f, 0xf7, 0x86, 0x5e, 0xf7, 0x2d, 0x0b, 0x2d, 0x0c, 0x2d, 0x06, 0x2d, 0x06, 0x2d, 0x0c,\n\t0x2f, 0x0c, 0x30, 0x0c, 0x32, 0x06, 0x32, 0x06, 0x32, 0x0c, 0x32, 0x0c, 0x32, 0x0c, 0x32, 0x18,\n\t0x81, 0xef, 0xf3, 0x32, 0x06, 0x34, 0x06, 0x35, 0x06, 0x35, 0x06, 0x34, 0x0c, 0x32, 0x0c, 0x30,\n\t0x0c, 0x2f, 0x0c, 0x2d, 0x0c, 0x2c, 0x1e, 0x2d, 0x06, 0x2d, 0x0c, 0x2d, 0x0c, 0x2f, 0x0c, 0x2d,\n\t0x18, 0x81, 0xef, 0xf3, 0x00, 0x0d, 0x89, 0x88, 0x07, 0x87, 0x3e, 0xf7, 0x86, 0x45, 0xf7, 0x45,\n\t0x04, 0x00, 0x02, 0x45, 0x04, 0x00, 0x02, 0x39, 0x0c, 0x87, 0x1f, 0xf7, 0x86, 0x38, 0xf7, 0x2d,\n\t0x0b, 0x2d, 0x0c, 0x2e, 0x12, 0x2d, 0x12, 0x2b, 0x0c, 0x2b, 0x06, 0x2d, 0x06, 0x2d, 0x06, 0x2d,\n\t0x06, 0x2d, 0x0c, 0x2b, 0x0c, 0x2d, 0x06, 0x2b, 0x06, 0x2d, 0x0d, 0x87, 0x3e, 0xf7, 0x86, 0x45,\n\t0xf7, 0x40, 0x0c, 0x39, 0x0c, 0x89, 0x82, 0x04, 0x81, 0x6e, 0xf5, 0x83, 0x81, 0x60, 0xf5, 0x81,\n\t0x60, 0xf5, 0x82, 0x06, 0x81, 0x6e, 0xf5, 0x83, 0x81, 0x2f, 0xf5, 0x81, 0x2f, 0xf5, 0x8e, 0xf8,\n\t0x81, 0x2c, 0xf5, 0x81, 0x2c, 0xf5, 0x8e, 0x01, 0x81, 0x2c, 0xf5, 0x8e, 0x02, 0x81, 0x2c, 0xf5,\n\t0x8e, 0x05, 0x88, 0xf4, 0x82, 0x04, 0x81, 0x49, 0xf2, 0x83, 0x88, 0x00, 0x81, 0x2f, 0xf5, 0x81,\n\t0x2f, 0xf5, 0x88, 0xf4, 0x81, 0x49, 0xf2, 0x81, 0x49, 0xf2, 0x88, 0x00, 0x81, 0x2f, 0xf5, 0x88,\n\t0xf4, 0x81, 0x49, 0xf2, 0x88, 0x00, 0x82, 0x08, 0x81, 0x2f, 0xf5, 0x83, 0x81, 0x2c, 0xf5, 0x88,\n\t0xf8, 0x81, 0x2c, 0xf5, 0x81, 0x2c, 0xf5, 0x81, 0x2c, 0xf5, 0x88, 0xf4, 0x81, 0x49, 0xf2, 0x88,\n\t0xff, 0x81, 0xc3, 0xf1, 0x88, 0x00, 0x81, 0x2f, 0xf5, 0x81, 0x24, 0xf5, 0x88, 0xf9, 0x81, 0x2f,\n\t0xf5, 0x81, 0x24, 0xf5, 0x88, 0xfb, 0x81, 0x2c, 0xf5, 0x81, 0x24, 0xf5, 0x81, 0xc3, 0xf1, 0x88,\n\t0x00, 0x80, 0x96, 0xf4, 0x88, 0xf4, 0x81, 0x4c, 0xf2, 0x88, 0xff, 0x89, 0x81, 0x2f, 0xf5, 0x87,\n\t0x8c, 0xf7, 0x86, 0x38, 0xf7, 0x43, 0x0c, 0x45, 0x0c, 0x86, 0x84, 0xf7, 0x8e, 0x0c, 0x2d, 0x0c,\n\t0x2d, 0x0c, 0x2d, 0x24, 0x2b, 0x06, 0x2b, 0x0c, 0x2d, 0x06, 0x2d, 0x0c, 0x2d, 0x0c, 0x2b, 0x0c,\n\t0x2d, 0x06, 0x2b, 0x06, 0x2d, 0x0c, 0x8e, 0xf4, 0x86, 0x38, 0xf7, 0x43, 0x0c, 0x45, 0x0c, 0x89,\n\t0x81, 0x6b, 0xf5, 0x8e, 0x03, 0x81, 0x6b, 0xf5, 0x8e, 0xfd, 0x89, 0x81, 0x6e, 0xf5, 0x81, 0x87,\n\t0xf5, 0x34, 0x0c, 0x34, 0x0c, 0x35, 0x12, 0x34, 0x12, 0x32, 0x0c, 0x81, 0x87, 0xf5, 0x34, 0x0c,\n\t0x34, 0x0c, 0x34, 0x18, 0x00, 0x18, 0x89, 0x84, 0x0a, 0x85, 0x01, 0x87, 0x69, 0xf7, 0x86, 0x2b,\n\t0xf7, 0x07, 0x18, 0x85, 0x08, 0x87, 0x1f, 0xf7, 0x89, 0x81, 0xa0, 0xf6, 0x81, 0xa0, 0xf6, 0x81,\n\t0x95, 0xf6, 0x81, 0x95, 0xf6, 0x81, 0xb6, 0xf6, 0x88, 0x05, 0x81, 0xb6, 0xf6, 0x88, 0xfb, 0x81,\n\t0xb6, 0xf6, 0x88, 0x00, 0x81, 0xb6, 0xf6, 0x81, 0xa0, 0xf6, 0x81, 0xa0, 0xf6, 0x81, 0xb3, 0xf6,\n\t0x88, 0x05, 0x81, 0xb3, 0xf6, 0x88, 0xfd, 0x81, 0x8a, 0xf6, 0x81, 0x8a, 0xf6, 0x88, 0x05, 0x81,\n\t0xb0, 0xf6, 0x88, 0xfb, 0x81, 0xb0, 0xf6, 0x88, 0x00, 0x82, 0x04, 0x81, 0x55, 0xf6, 0x83, 0x81,\n\t0xb3, 0xf6, 0x88, 0x05, 0x81, 0xb3, 0xf6, 0x88, 0x00, 0x81, 0x55, 0xf6, 0x81, 0x55, 0xf6, 0x81,\n\t0xb6, 0xf6, 0x88, 0x05, 0x81, 0xb6, 0xf6, 0x88, 0x00, 0x81, 0x55, 0xf6, 0x82, 0x04, 0x88, 0x00,\n\t0x81, 0xb3, 0xf6, 0x88, 0x05, 0x81, 0xb3, 0xf6, 0x83, 0x88, 0x00, 0x81, 0xb3, 0xf6, 0x88, 0x05,\n\t0x81, 0xb3, 0xf6, 0x88, 0x04, 0x81, 0xb3, 0xf6, 0x88, 0x00, 0x81, 0xb3, 0xf6, 0x88, 0xfd, 0x81,\n\t0xb3, 0xf6, 0x88, 0x04, 0x81, 0xb3, 0xf6, 0x88, 0xfd, 0x81, 0x8a, 0xf6, 0x88, 0x00, 0x81, 0x55,\n\t0xf6, 0x00, 0x60, 0x81, 0xb6, 0xf6, 0x88, 0x05, 0x81, 0xb6, 0xf6, 0x81, 0x58, 0xf6, 0x88, 0x05,\n\t0x81, 0xb3, 0xf6, 0x81, 0x58, 0xf6, 0x88, 0xfb, 0x81, 0xb0, 0xf6, 0x81, 0x58, 0xf6, 0x00, 0x60,\n\t0x88, 0x00, 0x80, 0x99, 0xf5, 0x81, 0x58, 0xf6, 0x88, 0x00, 0x86, 0x1b, 0xf7, 0x82, 0x04, 0x81,\n\t0x76, 0xf6, 0x83, 0x2b, 0x09, 0x00, 0x03, 0x82, 0x06, 0x81, 0x76, 0xf6, 0x83, 0x2b, 0x09, 0x00,\n\t0x03, 0x27, 0x09, 0x00, 0x03, 0x89, 0x87, 0x33, 0xf7, 0x85, 0x01, 0x84, 0x1c, 0x07, 0x01, 0x00,\n\t0x01, 0x84, 0x02, 0x07, 0x01, 0x00, 0x03, 0x85, 0x08, 0x89, 0x81, 0xb3, 0xf6, 0x8e, 0x07, 0x81,\n\t0xb3, 0xf6, 0x8e, 0xf9, 0x89, 0x81, 0xa0, 0xf6, 0x8e, 0x03, 0x81, 0xa0, 0xf6, 0x8e, 0xfd, 0x89,\n\t0x81, 0xb3, 0xf6, 0x8e, 0x01, 0x81, 0xb6, 0xf6, 0x8e, 0xfa, 0x81, 0xb6, 0xf6, 0x8e, 0x05, 0x89,\n\t0x81, 0xb3, 0xf6, 0x81, 0xb6, 0xf6, 0x87, 0xeb, 0xf6, 0x86, 0xf4, 0xf6, 0x15, 0x0c, 0x15, 0x06,\n\t0x21, 0x06, 0x81, 0xd1, 0xf6, 0x15, 0x0c, 0x15, 0x18, 0x81, 0xd1, 0xf6, 0x1f, 0x06, 0x21, 0x06,\n\t0x89, 0x87, 0xff, 0xf6, 0x84, 0x1f, 0x85, 0x01, 0x8a, 0x82, 0x06, 0x07, 0x01, 0x8d, 0xf0, 0x07,\n\t0x01, 0x8d, 0x0e, 0x83, 0x8b, 0x85, 0x08, 0x87, 0xeb, 0xf6, 0x89, 0x0f, 0x01, 0x40, 0x3f, 0x0c,\n\t0xff, 0x80, 0xeb, 0xf6, 0x00, 0x00, 0x05, 0x05, 0x03, 0xfd, 0xfb, 0xfb, 0x80, 0xf4, 0xf6, 0x0f,\n\t0x01, 0x40, 0x3b, 0x3f, 0x3e, 0x3b, 0x3d, 0x3c, 0x3b, 0x3b, 0x3a, 0x3b, 0x39, 0x38, 0x3b, 0x37,\n\t0x36, 0x3b, 0x35, 0x34, 0x3b, 0x33, 0x00, 0xff, 0x80, 0xff, 0xf6, 0x32, 0x80, 0x1b, 0xf7, 0x0f,\n\t0x01, 0x40, 0x3f, 0x3e, 0x3d, 0x3a, 0x0b, 0x02, 0x80, 0x25, 0xf7, 0x82, 0x0c, 0xf4, 0x07, 0xf9,\n\t0x80, 0x2b, 0xf7, 0x0f, 0xff, 0x80, 0x33, 0xf7, 0x82, 0x0c, 0xf4, 0x80, 0x38, 0xf7, 0x0f, 0x01,\n\t0x3f, 0x3a, 0x80, 0x3e, 0xf7, 0x82, 0x05, 0x03, 0xf8, 0x05, 0x07, 0xf4, 0x80, 0x45, 0xf7, 0x00,\n\t0x01, 0x0f, 0x03, 0x0e, 0x04, 0x0d, 0x04, 0x0c, 0x04, 0x0b, 0xff, 0x80, 0x4f, 0xf7, 0x02, 0x01,\n\t0xff, 0xfe, 0xfe, 0xff, 0x01, 0x02, 0x80, 0x5e, 0xf7, 0x0f, 0x02, 0x00, 0x04, 0x0e, 0x02, 0x00,\n\t0x04, 0x0d, 0x03, 0x00, 0x03, 0x0c, 0x03, 0x00, 0x03, 0x80, 0x69, 0xf7, 0x83, 0x05, 0x82, 0x18,\n\t0xe8, 0x80, 0x7c, 0xf7, 0x82, 0x00, 0x0c, 0xf4, 0x00, 0x80, 0x84, 0xf7, 0x0e, 0x01, 0x3f, 0x3e,\n\t0x0b, 0x02, 0x0a, 0x02, 0x80, 0x90, 0xf7, 0x02, 0x80, 0x97, 0xf7, 0xfe, 0x80, 0x9b, 0xf7, 0x0e,\n\t0x01, 0x3f, 0x3e, 0x3d, 0x3c, 0x3b, 0x80, 0x9f, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nTRDOS_DIR_ELEMENT sbootdir = { {'b','o','o','t',' ',' ',' ',' '}, 'B', 0xB4, 0xB4, (sizeof(sbootimage)+255)/256, 0, 0 };\n\nlong CalcCRC32(long CRC, unsigned char Symbol)\n{\n\tlong temp;\n\tCRC ^= -1l ^ Symbol;\n\tfor (int k = 8; k--;)\n\t{\n\t\ttemp = -(CRC & 1), CRC >>= 1, CRC ^= 0xEDB88320ul & temp;\n\t}\n\tCRC ^= -1l;\n\treturn CRC;\n}\n\nlong filelength(int hfile)\n{\n\tlong ret = lseek(hfile, 0, SEEK_END);\n\tlseek(hfile, 0, SEEK_SET);\n\treturn ret;\n}\n\n//----------------------------------------------------------------------------\nTDiskImage::TDiskImage()\n{\n\tfor (int t = 0; t < 256; t++)\n\t\tfor (int s = 0; s < 256; s++)\n\t\t{\n\t\t\tFTrackLength[t][s] = 0;\n\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t}\n\n\tDiskPresent = false;\n\tReadOnly = true;\n\tChanged = false;\n\tFType = DIT_UNK;\n\tMaxTrack = 81;\n\tMaxSide = 0x01;\n}\n//-----------------------------------------------------------------------------\nTDiskImage::~TDiskImage()\n{\n\tReadOnly = true;\n\tDiskPresent = false;\n\tChanged = false;\n\tFType = DIT_UNK;\n\n\tfor (int t = 0; t < 256; t++)\n\t\tfor (int s = 0; s < 256; s++)\n\t\t{\n\t\t\tFTrackLength[t][s] = 0;\n\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t}\n}\n//-----------------------------------------------------------------------------\nunsigned short TDiskImage::MakeVGCRC(unsigned char *data, unsigned long length)\n{\n\tunsigned short CRC = 0xFFFF;\n\tfor (unsigned int i = 0; i < length; i++)\n\t{\n\t\tCRC ^= data[i] << 8;\n\t\tfor (unsigned int j = 0; j < 8; j++)\n\t\t{\n\t\t\tif (CRC & 0x8000) CRC = (CRC << 1) ^ 0x1021;\n\t\t\telse CRC <<= 1;\n\t\t}\n\t}\n\treturn CRC;          // H<-->L !!!\n}\n//-----------------------------------------------------------------------------\nvoid TDiskImage::ApplySectorCRC(VGFIND_SECTOR vgfs)\n{\n\tunsigned char *TrackPtr = vgfs.vgfa.TrackPointer;\n\tunsigned int TrackLen = vgfs.vgfa.TrackLength;\n\tunsigned int len = vgfs.OffsetEndSector - vgfs.MarkedOffsetSector;\n\tif (vgfs.OffsetEndSector < vgfs.MarkedOffsetSector)\n\t\tlen = (TrackLen - vgfs.MarkedOffsetSector) + vgfs.OffsetEndSector;\n\n\tunsigned int off1 = vgfs.MarkedOffsetSector;\n\tunsigned int len1 = TrackLen - vgfs.MarkedOffsetSector;\n\tif (len1 > len) len1 = len;\n\tunsigned int off2 = 0;\n\tunsigned int len2 = 0;\n\tif (len1 < len) len2 = len - len1;\n\n\tunsigned int i;\n\tunsigned short CRC = 0xFFFF;\n\tfor (i = 0; i < len1; i++)\n\t{\n\t\tCRC ^= TrackPtr[off1 + i] << 8;\n\t\tfor (unsigned int j = 0; j < 8; j++)\n\t\t{\n\t\t\tif (CRC & 0x8000) CRC = (CRC << 1) ^ 0x1021;\n\t\t\telse CRC <<= 1;\n\t\t}\n\t}\n\tfor (i = 0; i < len2; i++)\n\t{\n\t\tCRC ^= TrackPtr[off2 + i] << 8;\n\t\tfor (unsigned int j = 0; j < 8; j++)\n\t\t{\n\t\t\tif (CRC & 0x8000) CRC = (CRC << 1) ^ 0x1021;\n\t\t\telse CRC <<= 1;\n\t\t}\n\t}\n\tunsigned int crcoff = (off1 + len1) % TrackLen;\n\tif (len2) crcoff = (off2 + len2) % TrackLen;\n\n\tTrackPtr[crcoff] = (unsigned char)(CRC >> 8);\n\tTrackPtr[(crcoff + 1) % TrackLen] = (unsigned char)(CRC & 0xFF);\n}\n//-----------------------------------------------------------------------------\n//\n// DANGER!  CRC checking not prepared for track length overflow!\n//\nbool TDiskImage::FindADMark(unsigned char CYL, unsigned char SIDE,\n\tunsigned int FromOffset,\n\tVGFIND_ADM *vgfa)\n{\n\tvgfa->TrackPointer = NULL;\n\tvgfa->ClkPointer = NULL;\n\tvgfa->TrackLength = 0;\n\tvgfa->ADMPointer = NULL;\n\tvgfa->ADMLength = 0;\n\tvgfa->FoundADM = false;\n\tvgfa->CRCOK = false;\n\n\tif ((!DiskPresent) |\n\t\t((CYL > MaxTrack) || (SIDE > MaxSide)) |\n\t\t((!FTracksPtr[CYL][SIDE][0]) || (!FTracksPtr[CYL][SIDE][1])))\n\t{\n\t\treturn false;           // ERROR: disk not ready\n\t}\n\n\tunsigned char *track = vgfa->TrackPointer = FTracksPtr[CYL][SIDE][0];\n\tunsigned char *clks = vgfa->ClkPointer = FTracksPtr[CYL][SIDE][1];\n\tunsigned int tlen = vgfa->TrackLength = FTrackLength[CYL][SIDE];\n\n\tunsigned int off, rc;\n\n\tunsigned int pos = FromOffset;\n\tfor (; pos < tlen + FromOffset; pos++)\n\t{\n\t\toff = pos%tlen;\n\t\tif ((track[off] == 0xA1) && (clks[off])) // fnd Mark\n\t\t{\n\t\t\toff = (off + 1) % tlen;\n\n\t\t\trc = tlen;\n\t\t\twhile ((track[off] == 0xA1) && (clks[off])) // repeat Mark\n\t\t\t{\n\t\t\t\tif (!rc) return false;           // ERROR: MFM marks all disk\n\t\t\t\toff = (off + 1) % tlen;\n\t\t\t\trc--;\n\t\t\t}\n\n\t\t\tif (track[off] != 0xFE) continue;\n\n\t\t\toff = (off + 1) % tlen;\n\n\t\t\tvgfa->FoundADM = true;\n\t\t\tvgfa->MarkedOffsetADM = pos%tlen;\n\t\t\tvgfa->OffsetADM = off;\n\t\t\tvgfa->OffsetEndADM = (off + 6) % tlen;\n\t\t\tvgfa->ADMLength = 6;\n\t\t\tvgfa->ADMPointer = track + off;\n\n\t\t\tunsigned short crc = MakeVGCRC(track + (pos%tlen), (off - (pos%tlen)) + 4);\n\n\t\t\tvgfa->CRCOK = (track[(off + 4) % tlen] == (crc >> 8)) && (track[(off + 5) % tlen] == (crc & 0xFF));\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n//-----------------------------------------------------------------------------\n//\n// DANGER!  CRC checking not prepared for track length overflow!\n//\nbool TDiskImage::FindSector(unsigned char CYL, unsigned char SIDE,\n\tunsigned char SECT,\n\tVGFIND_SECTOR *vgfs, unsigned int FromOffset)\n{\n\tvgfs->SectorPointer = NULL;\n\tvgfs->SectorLength = 0;\n\tvgfs->FoundDATA = false;\n\tvgfs->CRCOK = false;\n\n\tif ((!DiskPresent) |\n\t\t((CYL > MaxTrack) || (SIDE > MaxSide)) |\n\t\t((!FTracksPtr[CYL][SIDE][0]) || (!FTracksPtr[CYL][SIDE][1])))\n\t{\n\t\tvgfs->vgfa.TrackPointer = NULL;\n\t\tvgfs->vgfa.ClkPointer = NULL;\n\t\tvgfs->vgfa.TrackLength = 0;\n\t\tvgfs->vgfa.ADMPointer = NULL;\n\t\tvgfs->vgfa.ADMLength = 0;\n\t\tvgfs->vgfa.FoundADM = false;\n\t\tvgfs->vgfa.CRCOK = false;\n\t\treturn false;           // ERROR: disk not ready\n\t}\n\n\tunsigned int TrackOffset = FromOffset;\n\n\tbool FirstFind = true;\n\tunsigned int FirstPos = 0;\n\n\t// Поиск адресной метки требуемого сектора...\n\tbool ADFOUND = false;\n\tfor (;;)\n\t{\n\t\tif (!FindADMark(CYL, SIDE, TrackOffset, &(vgfs->vgfa)))\n\t\t\treturn false;          // ERROR: No ADMARK found on track\n\n\t\tif (vgfs->vgfa.TrackPointer[(vgfs->vgfa.OffsetADM + 2) % vgfs->vgfa.TrackLength] == SECT)\n\t\t{\n\t\t\tADFOUND = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!FirstFind)\n\t\t{\n\t\t\tif (vgfs->vgfa.OffsetEndADM == FirstPos) break;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFirstPos = vgfs->vgfa.OffsetEndADM;\n\t\t\tFirstFind = false;\n\t\t}\n\n\t\tTrackOffset = vgfs->vgfa.OffsetEndADM;\n\t};\n\n\tif (!ADFOUND) return false;\n\n\t// ADRMARK нужного найден, поиск массива данных...\n\n\tunsigned char *track = vgfs->vgfa.TrackPointer;\n\tunsigned char *clks = vgfs->vgfa.ClkPointer;\n\tunsigned int tlen = vgfs->vgfa.TrackLength;\n\n\tunsigned int pos = vgfs->vgfa.OffsetEndADM;\n\n\tunsigned int off, rc;\n\n\tfor (; pos < tlen * 2; pos++)\n\t{\n\t\toff = pos%tlen;\n\t\tif ((track[off] == 0xA1) && (clks[off])) // fnd Mark\n\t\t{\n\t\t\toff = (off + 1) % tlen;\n\n\t\t\trc = tlen;\n\t\t\twhile ((track[off] == 0xA1) && (clks[off])) // repeat Mark\n\t\t\t{\n\t\t\t\tif (!rc) return false;       // ERROR: MFM marks all disk\n\t\t\t\toff = (off + 1) % tlen;\n\t\t\t\trc--;\n\t\t\t}\n\n\t\t\tif ((track[off] < 0xF8) || (track[off] > 0xFB))\n\t\t\t{\n\t\t\t\tbreak;                      // ERROR: data array not found\n\t\t\t}\n\t\t\tvgfs->DataMarker = track[off];\n\n\t\t\toff = (off + 1) % tlen;\n\n\t\t\tvgfs->FoundDATA = true;\n\n\t\t\tunsigned char SL = vgfs->vgfa.TrackPointer[(vgfs->vgfa.OffsetADM + 3) % vgfs->vgfa.TrackLength];\n\t\t\tvgfs->SectorLength = 128;\n\t\t\tif (SL) vgfs->SectorLength <<= SL;\n\t\t\tvgfs->SectorPointer = track + off;\n\n\t\t\tvgfs->MarkedOffsetSector = pos%tlen;\n\t\t\tvgfs->OffsetSector = off;\n\t\t\tvgfs->OffsetEndSector = (off + vgfs->SectorLength) % tlen;\n\n\t\t\tunsigned short crc = MakeVGCRC(track + (pos%tlen), (off - (pos%tlen)) + vgfs->SectorLength);\n\t\t\tvgfs->CRCOK = (track[(off + vgfs->SectorLength) % tlen] == (crc >> 8)) && (track[(off + vgfs->SectorLength + 1) % tlen] == (crc & 0xFF));\n\n\t\t\treturn true;                         // OK read\n\t\t}\n\t}\n\n\treturn false;\n}\n//-----------------------------------------------------------------------------\nbool TDiskImage::FindTrack(unsigned char CYL, unsigned char SIDE, VGFIND_TRACK *vgft)\n{\n\tvgft->FoundTrack = false;\n\tvgft->TrackPointer = NULL;\n\tvgft->ClkPointer = NULL;\n\tvgft->TrackLength = 0;\n\n\tif ((!DiskPresent) |\n\t\t((CYL > MaxTrack) || (SIDE > MaxSide)) |\n\t\t((!FTracksPtr[CYL][SIDE][0]) || (!FTracksPtr[CYL][SIDE][1])))\n\t{\n\t\treturn false;           // ERROR: disk not ready\n\t}\n\n\tvgft->TrackPointer = FTracksPtr[CYL][SIDE][0];\n\tvgft->ClkPointer = FTracksPtr[CYL][SIDE][1];\n\tvgft->TrackLength = FTrackLength[CYL][SIDE];\n\tvgft->FoundTrack = true;\n\treturn true;\n}\n\n//-----------------------------------------------------------------------------\nvoid TDiskImage::Open(const char *filename, bool ROnly)\n{\n\tconst char *ext = \"\";\n\tif (strlen(filename) > 4) ext = filename + strlen(filename) - 4;\n\n\tTDiskImageType typ = DIT_UNK;\n\tif (!strcasecmp(ext, \".SCL\")) typ = DIT_SCL;\n\tif (!strcasecmp(ext, \".FDI\")) typ = DIT_FDI;\n\tif (!strcasecmp(ext, \".UDI\")) typ = DIT_UDI;\n\tif (!strcasecmp(ext, \".TD0\")) typ = DIT_TD0;\n\tif (!strcasecmp(ext, \".FDD\")) typ = DIT_FDD;\n\tif (!memcmp(ext + 1, \".$\", 2)) typ = DIT_HOB;\n\tif (!memcmp(ext + 1, \".!\", 2)) typ = DIT_HOB;\n\n\tif (!((FType == DIT_HOB) && (typ == DIT_HOB)))     // if not hobeta clear disk...\n\t{\n\t\tReadOnly = true;\n\t\tDiskPresent = false;\n\t\tChanged = false;\n\t\tFType = DIT_UNK;\n\n\t\tfor (int t = 0; t < 256; t++)\n\t\t\tfor (int s = 0; s < 256; s++)\n\t\t\t{\n\t\t\t\tFTrackLength[t][s] = 0;\n\t\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t\t}\n\t}\n\n\tif (typ == DIT_UNK)\n\t{\n\t\tShowError(ERR_UNKFORMAT);\n\t\treturn;\n\t}\n\tFType = typ;\n\n\tint hfile = open(filename, O_RDONLY | O_CLOEXEC);\n\n\tif (hfile < 0)\n\t{\n\t\tchar sbuf[8192];\n\t\tsprintf(sbuf, ERR_OPEN\" %s\", filename);\n\t\tShowError(sbuf);\n\t\treturn;\n\t}\n\n\tif (typ == DIT_SCL) readSCL(hfile, ROnly);\n\tif (typ == DIT_FDI) readFDI(hfile, ROnly);\n\tif (typ == DIT_UDI) readUDI(hfile, ROnly);\n\tif (typ == DIT_TD0) readTD0(hfile, ROnly);\n\tif (typ == DIT_FDD) readFDD(hfile, ROnly);\n\tif (typ == DIT_HOB) readHOB(hfile);\n\n\tclose(hfile);\n}\n//-----------------------------------------------------------------------------\nvoid TDiskImage::formatTRDOS(unsigned int Tcount, unsigned int Scount)\n{\n\tMaxTrack = Tcount - 1;\n\tMaxSide = Scount - 1;\n\n\tunsigned short TotalSecs = Tcount*Scount * 16 - 16;\n\n\t// форматирование нового диска под TR-DOS (16 x 256bytes sector per track)...\n\tunsigned int ptrcrc;\n\tunsigned int r;\n\tunsigned short vgcrc;\n\tfor (unsigned int trk = 0; trk <= unsigned(MaxTrack); trk++)\n\t\tfor (unsigned int side = 0; side <= unsigned(MaxSide); side++)\n\t\t{\n\t\t\tFTrackLength[trk][side] = 6250;\n\n\t\t\tFTracksPtr[trk][side][0] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // trk img\n\t\t\tFTracksPtr[trk][side][1] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // clk img\n\n\t\t\tunsigned int tptr = 0;\n\t\t\tfor (int sec = 0; sec < 16; sec++)\n\t\t\t{\n\t\t\t\tfor (r = 0; r < 10; r++)        // Первый пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tfor (r = 0; r < 12; r++)        // Синхропромежуток\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tptrcrc = tptr;\n\t\t\t\tfor (r = 0; r < 3; r++)        // Синхроимпульс\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t\t}\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFE;   // Метка \"Адрес\"\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)trk; // cyl\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)0x00; // head (TR always 0)\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(sec + 1); // secN\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)0x01; // len=256b\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tfor (r = 0; r < 22; r++)        // Второй пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tfor (r = 0; r < 12; r++)        // Синхропромежуток\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tptrcrc = tptr;\n\t\t\t\tfor (r = 0; r < 3; r++)        // Синхроимпульс\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t\t}\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFB;   // Метка \"Данные\"\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tfor (r = 0; r < 256; r++)        // сектор 256байт\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tif ((trk == 0) && (side == 0) && (sec == 8))      // make TR-DOS id\n\t\t\t\t{\n\t\t\t\t\tint ssec = tptr - 256;\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xE1] = 0x00; // first free SECT\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xE2] = 0x01; // first free TRACK\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xE3] = 0x16; // 80trk DS\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xE4] = 0x00; // file count\n\t\t\t\t\t*(unsigned short*)(FTracksPtr[trk][side][0] + ssec + 0xE5)\n\t\t\t\t\t\t= TotalSecs; // free SECS count\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xE7] = 0x10; // TR-DOS id\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xF4] = 0x00; // deleted file count\n\n\t\t\t\t\tmemcpy(FTracksPtr[trk][side][0] + ssec + 0xF5,\n\t\t\t\t\t\tSTR_CREATEDISKNAME\"               \", 8); // disk name\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xFD] = 0x00; // zero\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xFE] = 0x00; // zero\n\t\t\t\t\tFTracksPtr[trk][side][0][ssec + 0xFF] = 0x00; // zero\n\t\t\t\t}\n\n\t\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tfor (r = 0; r < 60; r++)        // Третий пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int eoftrk = tptr; eoftrk < 6250; eoftrk++)\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\t\t}\n}\n//-----------------------------------------------------------------------------\nvoid TDiskImage::readUDI(int hfile, bool ronly)\n{\n\tlong fsize = filelength(hfile);\n\tif (fsize < 0)\n\t{\n\t\tShowError(ERR_GETLEN);\n\t\treturn;\n\t}\n\n\tunsigned char *ptr = (unsigned char*)new char[fsize + 1024 * 2048];\n\tif (!ptr)\n\t{\n\t\tShowError(ERR_NOMEM);\n\t\treturn;\n\t}\n\n\tunsigned long rsize = read(hfile, ptr, fsize + 1024);\n\tif (rsize < 16 + 4)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tif (memcmp(ptr, \"UDI!\", 4) != 0)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FORMAT\" UDI!\");\n\t\treturn;\n\t}\n\n\tUDI_HEADER *udi_hdr = (UDI_HEADER*)(ptr);\n\n\tif ((udi_hdr->Version != 0x00) || (udi_hdr->_zero != 0x00) || (udi_hdr->ExtHdrLength != 0))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FILEVER\" UDI!\");\n\t\treturn;\n\t}\n\tif (rsize != (udi_hdr->UnpackedLength + 4))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tMaxTrack = udi_hdr->MaxCylinder;\n\tMaxSide = udi_hdr->MaxSide;\n\n\n\t// checking for corrupt...\n\tunsigned int udiOFF = 0x10;\n\n\tunsigned int trk, side;\n\n\tfor (trk = 0; trk <= unsigned(MaxTrack); trk++)\n\t\tfor (side = 0; side <= unsigned(MaxSide); side++)\n\t\t{\n\t\t\tunsigned char frmt = ptr[udiOFF++];\n\t\t\tif (rsize < udiOFF + 4)\n\t\t\t{\n\t\t\t\tdelete ptr;\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (frmt)\n\t\t\t{\n\t\t\t\tudiOFF += *((unsigned long*)(ptr + udiOFF));\n\t\t\t\tudiOFF += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tunsigned ccctlen = *((unsigned short*)(ptr + udiOFF));\n\t\t\tudiOFF += ccctlen;\n\t\t\tudiOFF += 2;\n\t\t\tif (rsize < udiOFF + 4)\n\t\t\t{\n\t\t\t\tdelete ptr;\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tudiOFF += ccctlen / 8 + ((ccctlen - (ccctlen / 8) * 8) ? 1 : 0);\n\t\t\tif (rsize < udiOFF + 4)\n\t\t\t{\n\t\t\t\tdelete ptr;\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\tudiOFF = 0x10;\n\n\tunsigned int trklen;\n\n\tfor (trk = 0; trk <= unsigned(MaxTrack); trk++)\n\t\tfor (side = 0; side <= unsigned(MaxSide); side++)\n\t\t{\n\t\t\tif (udiOFF >= rsize) break;\n\n\t\t\tif (ptr[udiOFF++] != 0)        // non MFM track?\n\t\t\t{\n\t\t\t\tFTrackLength[trk][side] = 6250;\n\t\t\t\t// make unformatted track...\n\t\t\t\tFTracksPtr[trk][side][0] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // trk img\n\t\t\t\tFTracksPtr[trk][side][1] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // clk img\n\t\t\t\tfor (unsigned ij = 0; ij < 6250; ij++)\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][ij] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][ij] = 0x00;\n\t\t\t\t}\n\n\t\t\t\tudiOFF += *((unsigned long*)(ptr + udiOFF));\n\t\t\t\tudiOFF += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrklen = *((unsigned short*)(ptr + udiOFF));\n\t\t\tudiOFF += 2;\n\t\t\tFTrackLength[trk][side] = trklen;\n\n\t\t\t// make unformatted track...\n\t\t\tFTracksPtr[trk][side][0] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // trk img\n\t\t\tFTracksPtr[trk][side][1] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // clk img\n\t\t\tfor (unsigned ij = 0; ij < FTrackLength[trk][side]; ij++)\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][ij] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][1][ij] = 0x00;\n\t\t\t}\n\n\t\t\tmemcpy(FTracksPtr[trk][side][0], ptr + udiOFF, FTrackLength[trk][side]);\n\t\t\tudiOFF += trklen;\n\n\t\t\tunsigned int MFMinfoLen = trklen / 8 + ((trklen - (trklen / 8) * 8) ? 1 : 0);\n\n\t\t\tunsigned char mask;\n\t\t\tfor (unsigned i = 0; i < MFMinfoLen; i++)\n\t\t\t{\n\t\t\t\tmask = 0x01;\n\t\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\t{\n\t\t\t\t\tif (ptr[udiOFF] & mask) FTracksPtr[trk][side][1][i * 8 + j] = 0xFF;\n\t\t\t\t\telse FTracksPtr[trk][side][1][i * 8 + j] = 0x00;\n\t\t\t\t\tmask <<= 1;\n\t\t\t\t}\n\t\t\t\tudiOFF++;\n\t\t\t}\n\t\t}\n\tlong CRC = -1l;\n\tfor (unsigned int i = 0; i < udiOFF; i++) CRC = CalcCRC32(CRC, ptr[i]);\n\n\n\tif (udiOFF < rsize)\n\t\tif (*((long*)(ptr + udiOFF)) != CRC)\n\t\t\tShowError(ERR_FILECRC\" UDI!\");\n\n\tdelete ptr;\n\tReadOnly = ronly;\n\tFType = DIT_UDI;\n\tDiskPresent = true;\n}\n\n//-----------------------------------------------------------------------------\nvoid TDiskImage::writeTRD(fileTYPE *hfile)\n{\n\tVGFIND_SECTOR vgfs;\n\n\t// prepare nullbuf...\n\tunsigned char nullbuf[256];\n\tfor (int i = 0; i < 256; i++) nullbuf[i] = '*';\n\tmemcpy(nullbuf, errsect, sizeof(errsect));\n\n\tfor (unsigned int trk = 0; trk <= unsigned(MaxTrack); trk++)\n\t\tfor (unsigned int side = 0; side <= unsigned(MaxSide); side++)\n\t\t\tfor (unsigned int sec = 0; sec < 16; sec++)\n\t\t\t{\n\t\t\t\tif (FindSector(trk, side, sec + 1, &vgfs))\n\t\t\t\t{\n\t\t\t\t\tFileWriteAdv(hfile, vgfs.SectorPointer, 256);\n\t\t\t\t\tif ((!vgfs.CRCOK) || (!vgfs.vgfa.CRCOK)) printf(\"Warning: sector %d on track %d, side %d with BAD CRC!\\n\", sec + 1, trk, side);\n\t\t\t\t\tif (vgfs.SectorLength != 256) printf(\"Warning: sector %d on track %d, side %d is non 256 bytes!\\n\", sec + 1, trk, side);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFileWriteAdv(hfile, nullbuf, 256);\n\t\t\t\t\tprintf(\"DANGER! Sector %d on track %d, side %d not found!\\n\", sec + 1, trk, side);\n\t\t\t\t}\n\t\t\t}\n}\n\n//-----------------------------------------------------------------------------\nvoid TDiskImage::readFDI(int hfile, bool readonly)\n{\n\tlong fsize = filelength(hfile);\n\tif (fsize < 0)\n\t{\n\t\tShowError(ERR_GETLEN);\n\t\treturn;\n\t}\n\n\tunsigned char *ptr = (unsigned char*)new char[fsize + 1024 * 2048];\n\tif (!ptr)\n\t{\n\t\tShowError(ERR_NOMEM);\n\t\treturn;\n\t}\n\n\tunsigned long rsize = read(hfile, ptr, fsize);\n\tif (rsize < 14)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tif (memcmp(ptr, \"FDI\", 3) != 0)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FORMAT\" FDI!\");\n\t\treturn;\n\t}\n\n\t// ==========================================\n\t// ********** Analyse FDI header ************...\n\t// ------------------------------------------\n\tunsigned short *fdihead = (unsigned short*)(ptr + 4);\n\tunsigned int fdiCylCount = fdihead[0];      // +4\n\tunsigned int fdiSideCount = fdihead[1];      // +6\n\t\t\t\t\t\t\t\t\t\t\t\t //   unsigned int fdiOFFtext   = fdihead[2];      // +8\n\tunsigned int fdiOFFdata = fdihead[3];      // +A\n\tunsigned int fdiSIZEext = fdihead[4];      // +C\n\n\tif ((fdiCylCount > 256) || (fdiCylCount == 0))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_MANYCYLS);\n\t\treturn;\n\t}\n\tif ((fdiSideCount > 256) || (fdiSideCount == 0))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_MANYSIDS);\n\t\treturn;\n\t}\n\n\tMaxTrack = (unsigned char)(fdiCylCount - 1);\n\tMaxSide = (unsigned char)(fdiSideCount - 1);\n\n\tif (rsize < (0x0E + fdiSIZEext + (unsigned(MaxTrack) + 1)*(unsigned(MaxSide) + 1) * 7))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tstruct FDISECINFO\n\t{\n\t\tunsigned char ADAM[5];\n\t\tunsigned int SectorOffset;        // относит DataOffset\n\t};\n\tstruct FDITRACKHDR\n\t{\n\t\tunsigned int DataOffset;          // относит начала файла\n\t\tunsigned int SectorCount;\n\t\tFDISECINFO SectorsInfo[256];\n\t};\n\tFDITRACKHDR *tracksinfo = new FDITRACKHDR[(unsigned(MaxTrack) + 1)*(unsigned(MaxSide) + 1)];\n\n\tunsigned int fdiOFF = 0x0E + fdiSIZEext;\n\n\tunsigned int trk, side;\n\t// Анализ области заголовков треков...\n\tfor (trk = 0; trk <= unsigned(MaxTrack); trk++)\n\t\tfor (side = 0; side <= unsigned(MaxSide); side++)\n\t\t{\n\t\t\tif (rsize < fdiOFF)\n\t\t\t{\n\t\t\t\tdelete[] tracksinfo;\n\t\t\t\tdelete ptr;\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttracksinfo[trk*(MaxSide + 1) + side].DataOffset = *((unsigned long*)(ptr + fdiOFF));\n\t\t\tfdiOFF += 4;\n\n\t\t\tif (rsize < fdiOFFdata + tracksinfo[trk*(MaxSide + 1) + side].DataOffset)\n\t\t\t{\n\t\t\t\tdelete[] tracksinfo;\n\t\t\t\tdelete ptr;\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfdiOFF += 2;      // \"Всегда содержит 0 (резерв для модернизации)\"\n\n\t\t\ttracksinfo[trk*(MaxSide + 1) + side].SectorCount = unsigned(ptr[fdiOFF++]);\n\n\t\t\tfor (unsigned isec = 0; isec < tracksinfo[trk*(MaxSide + 1) + side].SectorCount; isec++)\n\t\t\t{\n\t\t\t\tmemcpy(tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[isec].ADAM, ptr + fdiOFF, 5);\n\t\t\t\tfdiOFF += 5;\n\t\t\t\ttracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[isec].SectorOffset = unsigned(*((unsigned short*)(ptr + fdiOFF)));\n\t\t\t\tfdiOFF += 2;\n\n\t\t\t\tif (rsize < fdiOFFdata + tracksinfo[trk*(MaxSide + 1) + side].DataOffset + tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[isec].SectorOffset)\n\t\t\t\t{\n\t\t\t\t\tdelete[] tracksinfo;\n\t\t\t\t\tdelete ptr;\n\t\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// форматирование нового диска и размещение FDI секторов...\n\tunsigned int ptrcrc;\n\tunsigned int r;\n\tunsigned short vgcrc;\n\tunsigned int trkdatalen;\n\tunsigned SecCount;\n\tunsigned SL;\n\n\tfor (trk = 0; trk <= unsigned(MaxTrack); trk++)\n\t\tfor (side = 0; side <= unsigned(MaxSide); side++)\n\t\t{\n\t\t\tFTrackLength[trk][side] = 6250;\n\n\t\t\t// make unformatted track...\n\t\t\tFTracksPtr[trk][side][0] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // trk img\n\t\t\tFTracksPtr[trk][side][1] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // clk img\n\t\t\tfor (unsigned ij = 0; ij < 6250; ij++)\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][ij] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][1][ij] = 0x00;\n\t\t\t}\n\n\t\t\tSecCount = tracksinfo[trk*(MaxSide + 1) + side].SectorCount;\n\n\t\t\t// Вычисляем необходимое число байт под данные:\n\t\t\ttrkdatalen = 0;\n\t\t\tfor (unsigned int ilsec = 0; ilsec < SecCount; ilsec++)\n\t\t\t{\n\t\t\t\ttrkdatalen += 2 + 6;     // for marks:   0xA1, 0xFE, 6bytes\n\t\t\t\tSL = unsigned(tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[ilsec].ADAM[3]);\n\t\t\t\tif (!SL) SL = 128;\n\t\t\t\telse SL = 128 << SL;\n\n\t\t\t\tif (tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[ilsec].ADAM[4] & 0x40)\n\t\t\t\t\tSL = 0;          // заголовок без массива данных\n\t\t\t\telse\n\t\t\t\t\ttrkdatalen += 4;       // for data header/crc: 0xA1, 0xFB, ...,2bytes\n\n\t\t\t\ttrkdatalen += SL;\n\t\t\t}\n\n\t\t\tif (trkdatalen + SecCount*(3 + 2) > 6250)    // 3x4E & 2x00 per sec checking\n\t\t\t{\n\t\t\t\tdelete[] tracksinfo;\n\t\t\t\tdelete ptr;\n\t\t\t\tfor (int t = 0; t < 256; t++)\n\t\t\t\t\tfor (int s = 0; s < 256; s++)\n\t\t\t\t\t{\n\t\t\t\t\t\tFTrackLength[t][s] = 0;\n\t\t\t\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\t\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\t\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\t\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t\t\t\t}\n\t\t\t\tShowError(ERR_IMPOSSIBLE);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tunsigned int FreeSpace = 6250 - (trkdatalen + SecCount*(3 + 2));\n\n\t\t\tunsigned int SynchroPulseLen = 1; // 1 уже учтен в trkdatalen...\n\t\t\tunsigned int FirstSpaceLen = 1;\n\t\t\tunsigned int SecondSpaceLen = 1;\n\t\t\tunsigned int ThirdSpaceLen = 1;\n\t\t\tunsigned int SynchroSpaceLen = 1;\n\t\t\tFreeSpace -= FirstSpaceLen + SecondSpaceLen + ThirdSpaceLen + SynchroSpaceLen;\n\n\t\t\t// Распределяем длины пробелов и синхропромежутка:\n\t\t\twhile (FreeSpace > 0)\n\t\t\t{\n\t\t\t\tif (FreeSpace >= (SecCount * 2))\n\t\t\t\t\tif (SynchroSpaceLen < 12) { SynchroSpaceLen++; FreeSpace -= SecCount * 2; } // Synchro for ADM & DATA\n\t\t\t\tif (FreeSpace < SecCount) break;\n\n\t\t\t\tif (FirstSpaceLen < 10) { FirstSpaceLen++; FreeSpace -= SecCount; }\n\t\t\t\tif (FreeSpace < SecCount) break;\n\t\t\t\tif (SecondSpaceLen < 22) { SecondSpaceLen++; FreeSpace -= SecCount; }\n\t\t\t\tif (FreeSpace < SecCount) break;\n\t\t\t\tif (ThirdSpaceLen < 60) { ThirdSpaceLen++; FreeSpace -= SecCount; }\n\t\t\t\tif (FreeSpace < SecCount) break;\n\n\t\t\t\tif ((SynchroSpaceLen >= 12) && (FirstSpaceLen >= 10) && (SecondSpaceLen >= 22) && (ThirdSpaceLen >= 60)) break;\n\t\t\t};\n\t\t\t// по возможности делаем три синхроимпульса...\n\t\t\tif (FreeSpace >(SecCount * 2) + 10) { SynchroPulseLen++; FreeSpace -= SecCount; }\n\t\t\tif (FreeSpace >(SecCount * 2) + 9) SynchroPulseLen++;\n\n\t\t\t// Форматируем дорожку...\n\n\t\t\tunsigned int tptr = 0;\n\t\t\tfor (unsigned sec = 0; sec < SecCount; sec++)\n\t\t\t{\n\t\t\t\tfor (r = 0; r < FirstSpaceLen; r++)        // Первый пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tfor (r = 0; r < SynchroSpaceLen; r++)        // Синхропромежуток\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tptrcrc = tptr;\n\t\t\t\tfor (r = 0; r < SynchroPulseLen; r++)        // Синхроимпульс\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t\t}\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFE;   // Метка \"Адрес\"\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[sec].ADAM[0]; // cyl\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[sec].ADAM[1]; // head\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[sec].ADAM[2]; // secN\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[sec].ADAM[3]; // len code\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tfor (r = 0; r < SecondSpaceLen; r++)        // Второй пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tfor (r = 0; r < SynchroSpaceLen; r++)        // Синхропромежуток\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\n\t\t\t\tunsigned char fdiSectorFlags = tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[sec].ADAM[4];\n\n\t\t\t\t// !!!!!!!!!\n\t\t\t\t// !WARNING! this feature of FDI format is NOT FULL DOCUMENTED!!!\n\t\t\t\t// !!!!!!!!!\n\t\t\t\t//\n\t\t\t\t//  Flags::bit6 - Возможно, 1 в данном разряде\n\t\t\t\t//                будет обозначать адресный маркер без области данных.\n\t\t\t\t//\n\n\t\t\t\tif (!(fdiSectorFlags & 0x40)) // oh-oh, data area not present... ;-)\n\t\t\t\t{\n\t\t\t\t\tptrcrc = tptr;\n\t\t\t\t\tfor (r = 0; r < SynchroPulseLen; r++)        // Синхроимпульс\n\t\t\t\t\t{\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fdiSectorFlags & 0x80)\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xF8;   // Метка \"Удаленные данные\"\n\t\t\t\t\telse\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFB;   // Метка \"Данные\"\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\n\t\t\t\t\tSL = unsigned(tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[sec].ADAM[3]);\n\t\t\t\t\tif (!SL) SL = 128;\n\t\t\t\t\telse SL = 128 << SL;\n\n\t\t\t\t\tunsigned int secDATAOFF = fdiOFFdata + tracksinfo[trk*(MaxSide + 1) + side].DataOffset + tracksinfo[trk*(MaxSide + 1) + side].SectorsInfo[sec].SectorOffset;\n\n\t\t\t\t\tfor (r = 0; r < SL; r++)        // сектор SL байт\n\t\t\t\t\t{\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = ptr[secDATAOFF + r];\n\t\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t\t}\n\n\t\t\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\n\n\t\t\t\t\tif (fdiSectorFlags & 0x3F)        // CRC correct?\n\t\t\t\t\t{\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t\t}\n\t\t\t\t\telse     // oh-oh, high technology... CRC bad... ;-)\n\t\t\t\t\t{\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8) ^ 0xFF; // emulation bad CRC... ;)\n\t\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF) ^ 0xFF;  // --//-- ;)\n\t\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tfor (r = 0; r < ThirdSpaceLen; r++)        // Третий пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int eoftrk = tptr; eoftrk < 6250; eoftrk++)\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\t\t}\n\n\tdelete[] tracksinfo;\n\tdelete ptr;\n\tReadOnly = readonly;\n\tFType = DIT_FDI;\n\tDiskPresent = true;\n}\n\n//-----------------------------------------------------------------------------\nvoid TDiskImage::readFDD(int hfile, bool readonly)\n{\n\n\tlong fsize = filelength(hfile);\n\tif (fsize < 0)\n\t{\n\t\tShowError(ERR_GETLEN);\n\t\treturn;\n\t}\n\n\tunsigned char *ptr = (unsigned char*)new char[fsize + 1024 * 32];\n\tif (!ptr)\n\t{\n\t\tShowError(ERR_NOMEM);\n\t\treturn;\n\t}\n\n\tunsigned long rsize = read(hfile, ptr, fsize);\n\tif (rsize < sizeof(FDD_MAIN_HEADER))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tFDD_MAIN_HEADER *fdd_hdr = (FDD_MAIN_HEADER*)ptr;\n\n\tint MaxC = fdd_hdr->MaxTracks;\n\tint MaxH = fdd_hdr->MaxHeads;\n\n\tif (MaxH > 2)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_MANYSIDS);\n\t\treturn;\n\t}\n\n\n\tMaxH = (MaxH - 1) & 0xFF;\n\tMaxC = (MaxC - 1) & 0xFF;\n\n\n\tMaxTrack = MaxC;\n\tMaxSide = MaxH;\n\n\n\t// форматирование нового диска и размещение FDD секторов...\n\tunsigned int ptrcrc;\n\tunsigned int r;\n\tunsigned short vgcrc;\n\tunsigned int trkdatalen;\n\tunsigned SecCount;\n\tunsigned SL;\n\n\tFDD_TRACK_HEADER *trackinfo;\n\n\tunsigned int trk, side;\n\n\tfor (trk = 0; trk <= unsigned(MaxTrack); trk++)\n\t\tfor (side = 0; side <= unsigned(MaxSide); side++)\n\t\t{\n\t\t\tFTrackLength[trk][side] = 6250;\n\n\t\t\t// make unformatted track...\n\t\t\tFTracksPtr[trk][side][0] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // trk img\n\t\t\tFTracksPtr[trk][side][1] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // clk img\n\t\t\tfor (unsigned ij = 0; ij < 6250; ij++)\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][ij] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][1][ij] = 0x00;\n\t\t\t}\n\n\t\t\tif ((fdd_hdr->DataOffset[trk*(MaxSide + 1) + side] + 2) > int(rsize))\n\t\t\t{\n\t\t\t\tdelete ptr;\n\t\t\t\tfor (int t = 0; t < 256; t++)\n\t\t\t\t\tfor (int s = 0; s < 256; s++)\n\t\t\t\t\t{\n\t\t\t\t\t\tFTrackLength[t][s] = 0;\n\t\t\t\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\t\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\t\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\t\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t\t\t\t}\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttrackinfo = (FDD_TRACK_HEADER *)(ptr + fdd_hdr->DataOffset[trk*(MaxSide + 1) + side]);\n\n\t\t\tSecCount = trackinfo->SectNum;\n\n\t\t\tif ((2 + SecCount * 8 + fdd_hdr->DataOffset[trk*(MaxSide + 1) + side]) > rsize)\n\t\t\t{\n\t\t\t\tdelete ptr;\n\t\t\t\tfor (int t = 0; t < 256; t++)\n\t\t\t\t\tfor (int s = 0; s < 256; s++)\n\t\t\t\t\t{\n\t\t\t\t\t\tFTrackLength[t][s] = 0;\n\t\t\t\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\t\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\t\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\t\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t\t\t\t}\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (trackinfo->sect[SecCount - 1].SectPos > int(rsize))\n\t\t\t{\n\t\t\t\tdelete ptr;\n\t\t\t\tfor (int t = 0; t < 256; t++)\n\t\t\t\t\tfor (int s = 0; s < 256; s++)\n\t\t\t\t\t{\n\t\t\t\t\t\tFTrackLength[t][s] = 0;\n\t\t\t\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\t\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\t\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\t\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t\t\t\t}\n\t\t\t\tShowError(ERR_CORRUPT);\n\t\t\t\treturn;\n\t\t\t}\n\n\n\n\t\t\t// Вычисляем необходимое число байт под данные:\n\t\t\ttrkdatalen = 0;\n\t\t\tfor (unsigned int ilsec = 0; ilsec < SecCount; ilsec++)\n\t\t\t{\n\t\t\t\ttrkdatalen += 2 + 6;     // for marks:   0xA1, 0xFE, 6bytes\n\t\t\t\tSL = unsigned(trackinfo->sect[ilsec].size);\n\t\t\t\tif (!SL) SL = 128;\n\t\t\t\telse SL = 128 << SL;\n\n\t\t\t\ttrkdatalen += 4;       // for data header/crc: 0xA1, 0xFB, ...,2bytes\n\n\t\t\t\ttrkdatalen += SL;\n\t\t\t}\n\n\t\t\tif (trkdatalen + SecCount*(3 + 2) > 6250)    // 3x4E & 2x00 per sec checking\n\t\t\t{\n\t\t\t\tdelete ptr;\n\t\t\t\tfor (int t = 0; t < 256; t++)\n\t\t\t\t\tfor (int s = 0; s < 256; s++)\n\t\t\t\t\t{\n\t\t\t\t\t\tFTrackLength[t][s] = 0;\n\t\t\t\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\t\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\t\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\t\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t\t\t\t}\n\t\t\t\tShowError(ERR_IMPOSSIBLE);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tunsigned int FreeSpace = 6250 - (trkdatalen + SecCount*(3 + 2));\n\n\t\t\tunsigned int SynchroPulseLen = 1; // 1 уже учтен в trkdatalen...\n\t\t\tunsigned int FirstSpaceLen = 1;\n\t\t\tunsigned int SecondSpaceLen = 1;\n\t\t\tunsigned int ThirdSpaceLen = 1;\n\t\t\tunsigned int SynchroSpaceLen = 1;\n\t\t\tFreeSpace -= FirstSpaceLen + SecondSpaceLen + ThirdSpaceLen + SynchroSpaceLen;\n\n\t\t\t// Распределяем длины пробелов и синхропромежутка:\n\t\t\twhile (FreeSpace > 0)\n\t\t\t{\n\t\t\t\tif (FreeSpace >= (SecCount * 2))\n\t\t\t\t\tif (SynchroSpaceLen < 12) { SynchroSpaceLen++; FreeSpace -= SecCount * 2; } // Synchro for ADM & DATA\n\t\t\t\tif (FreeSpace < SecCount) break;\n\n\t\t\t\tif (FirstSpaceLen < 10) { FirstSpaceLen++; FreeSpace -= SecCount; }\n\t\t\t\tif (FreeSpace < SecCount) break;\n\t\t\t\tif (SecondSpaceLen < 22) { SecondSpaceLen++; FreeSpace -= SecCount; }\n\t\t\t\tif (FreeSpace < SecCount) break;\n\t\t\t\tif (ThirdSpaceLen < 60) { ThirdSpaceLen++; FreeSpace -= SecCount; }\n\t\t\t\tif (FreeSpace < SecCount) break;\n\n\t\t\t\tif ((SynchroSpaceLen >= 12) && (FirstSpaceLen >= 10) && (SecondSpaceLen >= 22) && (ThirdSpaceLen >= 60)) break;\n\t\t\t};\n\t\t\t// по возможности делаем три синхроимпульса...\n\t\t\tif (FreeSpace >(SecCount * 2) + 10) { SynchroPulseLen++; FreeSpace -= SecCount; }\n\t\t\tif (FreeSpace >(SecCount * 2) + 9) SynchroPulseLen++;\n\n\t\t\t// Форматируем дорожку...\n\n\t\t\tunsigned int tptr = 0;\n\t\t\tfor (unsigned sec = 0; sec < SecCount; sec++)\n\t\t\t{\n\t\t\t\tfor (r = 0; r < FirstSpaceLen; r++)        // Первый пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tfor (r = 0; r < SynchroSpaceLen; r++)        // Синхропромежуток\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tptrcrc = tptr;\n\t\t\t\tfor (r = 0; r < SynchroPulseLen; r++)        // Синхроимпульс\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t\t}\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFE;   // Метка \"Адрес\"\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = trackinfo->sect[sec].trk;  // cyl\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = trackinfo->sect[sec].side; // head\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = trackinfo->sect[sec].sect; // secN\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = trackinfo->sect[sec].size; // len code\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\tfor (r = 0; r < SecondSpaceLen; r++)        // Второй пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\tfor (r = 0; r < SynchroSpaceLen; r++)        // Синхропромежуток\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\n\n\t\t\t\t// DATA AM\n\t\t\t\tptrcrc = tptr;\n\t\t\t\tfor (r = 0; r < SynchroPulseLen; r++)        // Синхроимпульс\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t\t}\n\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFB;   // Метка \"Данные\"\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\n\t\t\t\tSL = unsigned(trackinfo->sect[sec].size);\n\t\t\t\tif (!SL) SL = 128;\n\t\t\t\telse SL = 128 << SL;\n\n\t\t\t\tunsigned int secDATAOFF = trackinfo->sect[sec].SectPos;\n\n\t\t\t\tfor (r = 0; r < SL; r++)        // сектор SL байт\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = ptr[secDATAOFF + r];\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\n\t\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\n\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\n\t\t\t\tfor (r = 0; r < ThirdSpaceLen; r++)        // Третий пробел\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int eoftrk = tptr; eoftrk < 6250; eoftrk++)\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\t\t}\n\n\tdelete ptr;\n\tReadOnly = readonly;\n\tFType = DIT_FDD;\n\tDiskPresent = true;\n\n}\n\n//-----------------------------------------------------------------------------\nvoid TDiskImage::readSCL(int hfile, bool readonly)\n{\n\tlong fsize = filelength(hfile);\n\tif (fsize < 0)\n\t{\n\t\tShowError(ERR_GETLEN);\n\t\treturn;\n\t}\n\tunsigned char *ptr = (unsigned char*)new char[fsize + 1024 * 2048];\n\tif (!ptr)\n\t{\n\t\tShowError(ERR_NOMEM);\n\t\treturn;\n\t}\n\tunsigned long rsize = read(hfile, ptr, fsize);\n\n\tif (!rsize)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\tif (rsize < 9 + 4)      // header\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\tif (memcmp(ptr, \"SINCLAIR\", 8) != 0)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FORMAT\" SCL!\");\n\t\treturn;\n\t}\n\n\tunsigned int FileCount = ptr[8];\n\tif (rsize < 9 + 4 + FileCount * 14)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tTRDOS_DIR_ELEMENT *fileinfo[256];\n\n\tunsigned short FilesTotalSecs = 0;\n\n\t// checking for corrupt + SCL-CRC + FileDIRS parse\n\tunsigned long SCLCRC = 0;\n\tunsigned sclOFF = 0;\n\tunsigned int i, j;\n\tfor (i = 0; i < 9; i++) SCLCRC += unsigned(ptr[sclOFF++]);\n\n\tfor (i = 0; i < FileCount; i++)\n\t{\n\t\tfileinfo[i] = (TRDOS_DIR_ELEMENT*)(ptr + sclOFF);\n\t\tfor (j = 0; j < 14; j++) SCLCRC += unsigned(ptr[sclOFF++]);\n\t}\n\tfor (i = 0; i < FileCount; i++)\n\t{\n\t\tunsigned SL = unsigned(fileinfo[i]->SecLen) * 256;\n\t\tFilesTotalSecs += fileinfo[i]->SecLen;\n\t\tif (rsize < sclOFF + 4 + SL)\n\t\t{\n\t\t\tdelete ptr;\n\t\t\tShowError(ERR_CORRUPT);\n\t\t\treturn;\n\t\t}\n\t\tfor (j = 0; j < SL; j++) SCLCRC += unsigned(ptr[sclOFF++]);\n\t}\n\n\tif (*((unsigned long*)(ptr + sclOFF)) != SCLCRC)\n\t\tShowError(ERR_FILECRC\" SCL!\");\n\n\n\tif (FilesTotalSecs < 2544) FilesTotalSecs = 2544;\n\telse\n\t{\n\t\tint cyls = ((16 + FilesTotalSecs) / (16 * 2)) + (((16 + FilesTotalSecs) % (16 * 2)) ? 1 : 0);\n\t\tFilesTotalSecs = (cyls * 16 * 2) - 16;\n\t}\n\n\tformatTRDOS((FilesTotalSecs + 16) / (16 * 2), 2);\n\tReadOnly = true;\n\tFType = DIT_SCL;\n\tDiskPresent = true;\n\n\tsclOFF = 9 + 14 * FileCount;\n\n\tbool BOOTADD = true;\n\tunsigned char _FileCount = 0;\n\tunsigned char _DelFileCount = 0;\n\n\tfor (i = 0; i < FileCount; i++)\n\t{\n\t\tif (fileinfo[i]->FileName[0] == 0x01) _DelFileCount++;\n\t\t_FileCount++;\n\n\t\tif (!strncasecmp(fileinfo[i]->FileName, \"BOOT    B\", 9))\n\t\t{\n\t\t\tBOOTADD = false;\n\t\t}\n\t}\n\n\tunsigned char SEC = 0, TRK = 1;\n\tunsigned short FreeSEC = 2544;\n\tunsigned int cnt = 0;\n\tunsigned int dirsec;\n\n\tTRDOS_DIR_ELEMENT trdosde;\n\tVGFIND_SECTOR vgfs;\n\n\tif (BOOTADD && (unsigned(_FileCount) + unsigned(_DelFileCount) < 127))\n\t{\n\t\tdirsec = ((cnt * 16) / 256) + 1;\n\n\t\tmemcpy(&trdosde, &sbootdir, sizeof(sbootdir));\n\n\t\ttrdosde.FirstSec = SEC;\n\t\ttrdosde.FirstTrk = TRK;\n\n\t\tif (FindSector(0, 0, dirsec, &vgfs))         // DIR ELEMENT write\n\t\t{\n\t\t\tmemcpy(vgfs.SectorPointer + ((cnt * 16) % 256), &trdosde, sizeof(trdosde));\n\t\t\tApplySectorCRC(vgfs);\n\t\t}\n\t\t_FileCount++;\n\t\tcnt++;\n\t\tint _bOFF = 0;\n\n\t\tfor (j = 0; j < unsigned(trdosde.SecLen); j++)\n\t\t{\n\t\t\tif (FindSector(TRK / 2, TRK % 2, SEC + 1, &vgfs))       // SECTOR write\n\t\t\t{\n\t\t\t\tmemcpy(vgfs.SectorPointer, sbootimage + _bOFF, 256);\n\t\t\t\tApplySectorCRC(vgfs);\n\t\t\t}\n\t\t\t_bOFF += 256;\n\t\t\tSEC++;\n\t\t\tFreeSEC--;\n\t\t\tif (SEC > 15) { SEC = 0; TRK++; }\n\t\t}\n\t}\n\n\tfor (i = 0; i < FileCount; i++)\n\t{\n\t\tif (TRK >= (MaxTrack + 1)*(MaxSide + 1)) break;      // disk full ?\n\n\t\tmemcpy(&trdosde, fileinfo[i], 14);\n\n\t\ttrdosde.FirstSec = SEC;\n\t\ttrdosde.FirstTrk = TRK;\n\n\t\tunsigned int dirsec = ((cnt * 16) / 256) + 1;\n\t\tif (FindSector(0, 0, dirsec, &vgfs))         // DIR ELEMENT write\n\t\t{\n\t\t\tmemcpy(vgfs.SectorPointer + ((cnt * 16) % 256), &trdosde, 16);\n\t\t\tApplySectorCRC(vgfs);\n\t\t}\n\n\t\tcnt++;\n\n\t\tfor (j = 0; j < unsigned(trdosde.SecLen); j++)\n\t\t{\n\t\t\tif (FindSector(TRK / 2, TRK % 2, SEC + 1, &vgfs))       // SECTOR write\n\t\t\t{\n\t\t\t\tmemcpy(vgfs.SectorPointer, ptr + sclOFF, 256);\n\t\t\t\tApplySectorCRC(vgfs);\n\t\t\t}\n\t\t\tsclOFF += 256;\n\t\t\tSEC++;\n\t\t\tFreeSEC--;\n\t\t\tif (SEC > 15) { SEC = 0; TRK++; }\n\n\t\t\tif (TRK >= (MaxTrack + 1)*(MaxSide + 1)) break;      // disk full ?\n\t\t}\n\t}\n\n\tif (FindSector(0, 0, 9, &vgfs))         // update disk info\n\t{\n\t\tvgfs.SectorPointer[0xE1] = SEC;\n\t\tvgfs.SectorPointer[0xE2] = TRK;\n\t\tvgfs.SectorPointer[0xE4] = _FileCount;\n\t\tvgfs.SectorPointer[0xF4] = _DelFileCount;\n\t\t*((unsigned short*)(vgfs.SectorPointer + 0xE5)) = FreeSEC;\n\t\tApplySectorCRC(vgfs);\n\t}\n\n\tdelete ptr;\n\tReadOnly = readonly;\n}\n//-----------------------------------------------------------------------------\nvoid TDiskImage::readHOB(int hfile)\n{\n\tlong fsize = filelength(hfile);\n\tif (fsize < 0)\n\t{\n\t\tShowError(ERR_GETLEN);\n\t\treturn;\n\t}\n\tunsigned char *ptr = (unsigned char*)new char[fsize + 1024 * 2048];\n\tif (!ptr)\n\t{\n\t\tShowError(ERR_NOMEM);\n\t\treturn;\n\t}\n\tunsigned long rsize = read(hfile, ptr, fsize);\n\n\tif (!rsize)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\tif (rsize < 17)      // header\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tTRDOS_DIR_ELEMENT dired;\n\tmemcpy(&dired, ptr, 14);\n\n\tunsigned short hobRealCRC = *((unsigned short*)(ptr + 0x0F));\n\tunsigned int DataLength = *((unsigned short*)(ptr + 0x0D));\n\n\tif (rsize < 17 + (DataLength & 0xFF00))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tunsigned int i;\n\tunsigned short CRC = 0;\n\tfor (i = 0; i < 15; i++) CRC = CRC + ptr[i];\n\tCRC *= 257;\n\tCRC += 105;          // сумма чисел от 0 до 14\n\n\tif (CRC != hobRealCRC)\n\t\tShowError(ERR_FILECRC\" HOBETA!\");\n\n\n\n\n\tReadOnly = true;\n\tif (!DiskPresent)\n\t{\n\t\tformatTRDOS(80, 2);\n\t\tFType = DIT_HOB;\n\t\tDiskPresent = true;\n\t}\n\n\t// --- read file...\n\tdired.SecLen = ptr[0x0E];            // число секторов файла\n\n\tVGFIND_SECTOR vgfs9;\n\tif (!FindSector(0, 0, 9, &vgfs9)) { delete ptr; return; }\n\n\tdired.FirstSec = vgfs9.SectorPointer[0xE1];\n\tdired.FirstTrk = vgfs9.SectorPointer[0xE2];\n\n\tVGFIND_SECTOR vgfs;\n\n\tunsigned char SEC = dired.FirstSec, TRK = dired.FirstTrk;\n\tunsigned short FreeSEC = *((unsigned short*)(vgfs9.SectorPointer + 0xE5));\n\tunsigned char FileCount = vgfs9.SectorPointer[0xE4];\n\tunsigned char DelFileCount = vgfs9.SectorPointer[0xF4];\n\n\tif (TRK >= 160)       // disk full ?\n\t{\n\t\tdelete ptr;\n\t\treturn;\n\t}\n\n\tfor (unsigned int j = 0; j < unsigned(dired.SecLen); j++)\n\t{\n\t\tif (FindSector(TRK / 2, TRK % 2, SEC + 1, &vgfs))\n\t\t{\n\t\t\tmemcpy(vgfs.SectorPointer, ptr + 17 + j * 256, 256);\n\t\t\tApplySectorCRC(vgfs);\n\t\t}\n\t\tSEC++;\n\t\tFreeSEC--;\n\t\tif (SEC > 15) { SEC = 0; TRK++; }\n\n\t\tif (TRK >= 160) break;     // disk full?\n\t}\n\n\tif (FindSector(0, 0, ((FileCount * 16) / 256) + 1, &vgfs))\n\t{\n\t\tmemcpy(vgfs.SectorPointer + ((FileCount * 16) % 256), &dired, 16);\n\t\tApplySectorCRC(vgfs);\n\t}\n\n\tif (dired.FileName[0] == 0x01) DelFileCount++;\n\tFileCount++;\n\n\tvgfs9.SectorPointer[0xE1] = SEC;\n\tvgfs9.SectorPointer[0xE2] = TRK;\n\t*((unsigned short*)(vgfs9.SectorPointer + 0xE5)) = FreeSEC;\n\tvgfs9.SectorPointer[0xE4] = FileCount;\n\tvgfs9.SectorPointer[0xF4] = DelFileCount;\n\tApplySectorCRC(vgfs9);\n}\n//-----------------------------------------------------------------------------\nbool unpack_td0(unsigned char *data, long &size);\nunsigned short TD0CRC(unsigned char *buf, unsigned int len);\n\n#define WORD2(a,b) ((a)+(b)*0x100)\n\nvoid TDiskImage::readTD0(int hfile, bool readonly)\n{\n\tlong fsize = filelength(hfile);\n\tif (fsize < 0)\n\t{\n\t\tShowError(ERR_GETLEN);\n\t\treturn;\n\t}\n\tunsigned char *ptr = (unsigned char*)new char[fsize + 256 * 20000];\n\tif (!ptr)\n\t{\n\t\tShowError(ERR_NOMEM);\n\t\treturn;\n\t}\n\tlong rsize = read(hfile, ptr, fsize);\n\n\tTD0_MAIN_HEADER *td0hdr = (TD0_MAIN_HEADER*)ptr;\n\tTD0_INFO_DATA *td0inf = (TD0_INFO_DATA*)(ptr + 12);\n\n\tif (!rsize)\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\tif (rsize < 12)      // header\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_CORRUPT);\n\t\treturn;\n\t}\n\n\tif ((*(short*)ptr != WORD2('T', 'D')) && (*(short*)ptr != WORD2('t', 'd')))// non TD0\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FORMAT\" TD0!\");\n\t\treturn;\n\t}\n\tif (TD0CRC(ptr, 10) != td0hdr->CRC) // CRC bad...\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FILECRC\" TD0!\");\n\t\treturn;\n\t}\n\tif ((td0hdr->Ver > 21) || (td0hdr->Ver < 10))           // 1.0 <= version <= 2.1...\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FILEVER\" TD0!\");\n\t\treturn;\n\t}\n\tif (td0hdr->DataDOS != 0)           // if DOS allocated sectors only...\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_TD0DOSALLOC);\n\t\treturn;\n\t}\n\tif (!unpack_td0(ptr, rsize))\n\t{\n\t\tdelete ptr;\n\t\tShowError(ERR_FORMAT\" TD0!\");\n\t\treturn;\n\t}\n\n\t// loading unpacked TD0...\n\n\tint tdOFF = 12;\n\tif (ptr[7] & 0x80) tdOFF += sizeof(TD0_INFO_DATA) + td0inf->strLen;\n\n\tTD0_TRACK_HEADER *tdtrk;\n\tTD0_SECT_HEADER *tdsect;\n\n\tMaxTrack = 0;\n\tMaxSide = 0;\n\n\tfor (; tdOFF < rsize;)\n\t{\n\t\ttdtrk = (TD0_TRACK_HEADER*)(ptr + tdOFF);\n\t\ttdOFF += sizeof(TD0_TRACK_HEADER);\n\n\t\tif (tdOFF >= rsize) break;\n\t\tif (tdtrk->SectorCount == 0xFF) break;   // EOF marker\n\n\n\t\tunsigned trk = tdtrk->Track;\n\t\tunsigned side = tdtrk->Side;\n\t\tFTrackLength[trk][side] = 6250;\n\n\t\t// make unformatted track...\n\t\tFTracksPtr[trk][side][0] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // trk img\n\t\tFTracksPtr[trk][side][1] = (unsigned char*)new char[FTrackLength[trk][side] + 1024];      // clk img\n\t\tfor (unsigned ij = 0; ij < 6250; ij++)\n\t\t{\n\t\t\tFTracksPtr[trk][side][0][ij] = 0x00;\n\t\t\tFTracksPtr[trk][side][1][ij] = 0x00;\n\t\t}\n\n\n\t\tunsigned SecCount = tdtrk->SectorCount;\n\n\t\tunsigned int tmpOFF = tdOFF;\n\n\t\t// Вычисляем необходимое число байт под данные:\n\t\tunsigned int trkdatalen = 0;\n\t\tunsigned int SL;\n\t\tfor (unsigned int ilsec = 0; ilsec < SecCount; ilsec++)\n\t\t{\n\t\t\ttdsect = (TD0_SECT_HEADER*)(ptr + tmpOFF);\n\t\t\ttmpOFF += sizeof(TD0_SECT_HEADER) + tdsect->DataLength;\n\n\t\t\ttrkdatalen += 2 + 6;     // for marks:   0xA1, 0xFE, 6bytes\n\t\t\ttrkdatalen += 4;       // for data header/crc: 0xA1, 0xFB, ...,2bytes\n\t\t\t\t\t\t\t\t   //         SL = unsigned(tdsect->ADRM[3]);\n\t\t\t\t\t\t\t\t   //         if(!SL) SL = 128;\n\t\t\t\t\t\t\t\t   //         else SL = 128 << SL;\n\t\t\tSL = tdsect->DataLength - 1;\n\t\t\ttrkdatalen += SL;\n\t\t}\n\n\t\t// проверка на возможность формата...\n\t\tif (trkdatalen + SecCount*(3 + 2) > 6250)    // 3x4E & 2x00 per sec checking\n\t\t{\n\t\t\tdelete ptr;\n\t\t\tfor (int t = 0; t < 256; t++)\n\t\t\t\tfor (int s = 0; s < 256; s++)\n\t\t\t\t{\n\t\t\t\t\tFTrackLength[t][s] = 0;\n\t\t\t\t\tif (FTracksPtr[t][s][0]) delete FTracksPtr[t][s][0];\n\t\t\t\t\tFTracksPtr[t][s][0] = NULL;\n\t\t\t\t\tif (FTracksPtr[t][s][1]) delete FTracksPtr[t][s][1];\n\t\t\t\t\tFTracksPtr[t][s][1] = NULL;\n\t\t\t\t}\n\t\t\tShowError(ERR_IMPOSSIBLE);\n\t\t\treturn;\n\t\t}\n\n\t\tunsigned int FreeSpace = 6250 - (trkdatalen + SecCount*(3 + 2));\n\n\t\tunsigned int SynchroPulseLen = 1; // 1 уже учтен в trkdatalen...\n\t\tunsigned int FirstSpaceLen = 1;\n\t\tunsigned int SecondSpaceLen = 1;\n\t\tunsigned int ThirdSpaceLen = 1;\n\t\tunsigned int SynchroSpaceLen = 1;\n\t\tFreeSpace -= FirstSpaceLen + SecondSpaceLen + ThirdSpaceLen + SynchroSpaceLen;\n\n\t\t// Распределяем длины пробелов и синхропромежутка:\n\t\twhile (FreeSpace > 0)\n\t\t{\n\t\t\tif (FreeSpace >= (SecCount * 2))\n\t\t\t\tif (SynchroSpaceLen < 12) { SynchroSpaceLen++; FreeSpace -= SecCount * 2; } // Synchro for ADM & DATA\n\t\t\tif (FreeSpace < SecCount) break;\n\n\t\t\tif (FirstSpaceLen < 10) { FirstSpaceLen++; FreeSpace -= SecCount; }\n\t\t\tif (FreeSpace < SecCount) break;\n\t\t\tif (SecondSpaceLen < 22) { SecondSpaceLen++; FreeSpace -= SecCount; }\n\t\t\tif (FreeSpace < SecCount) break;\n\t\t\tif (ThirdSpaceLen < 60) { ThirdSpaceLen++; FreeSpace -= SecCount; }\n\t\t\tif (FreeSpace < SecCount) break;\n\n\t\t\tif ((SynchroSpaceLen >= 12) && (FirstSpaceLen >= 10) && (SecondSpaceLen >= 22) && (ThirdSpaceLen >= 60)) break;\n\t\t};\n\t\t// по возможности делаем три синхроимпульса...\n\t\tif (FreeSpace >(SecCount * 2) + 10) { SynchroPulseLen++; FreeSpace -= SecCount; }\n\t\tif (FreeSpace >(SecCount * 2) + 9) SynchroPulseLen++;\n\n\t\t// Форматируем дорожку...\n\n\t\tunsigned int tptr = 0;\n\t\tunsigned int ptrcrc;\n\t\tunsigned int r;\n\t\tunsigned short vgcrc;\n\t\tfor (unsigned sec = 0; sec < SecCount; sec++)\n\t\t{\n\t\t\ttdsect = (TD0_SECT_HEADER*)(ptr + tdOFF);\n\t\t\ttdOFF += sizeof(TD0_SECT_HEADER) + 1;\n\n\t\t\tfor (r = 0; r < FirstSpaceLen; r++)        // Первый пробел\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\t\t\tfor (r = 0; r < SynchroSpaceLen; r++)        // Синхропромежуток\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\t\t\tptrcrc = tptr;\n\t\t\tfor (r = 0; r < SynchroPulseLen; r++)        // Синхроимпульс\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t}\n\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFE;   // Метка \"Адрес\"\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\tFTracksPtr[trk][side][0][tptr] = tdsect->ADRM[0]; // cyl\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\tFTracksPtr[trk][side][0][tptr] = tdsect->ADRM[1]; // head\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\tFTracksPtr[trk][side][0][tptr] = tdsect->ADRM[2]; // secN\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\tFTracksPtr[trk][side][0][tptr] = tdsect->ADRM[3]; // len code\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\tfor (r = 0; r < SecondSpaceLen; r++)        // Второй пробел\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\t\t\tfor (r = 0; r < SynchroSpaceLen; r++)        // Синхропромежуток\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\n\t\t\tif (tdsect->DataLength - 1) // oh-oh, data area not present... ;-)\n\t\t\t{\n\t\t\t\tptrcrc = tptr;\n\t\t\t\tfor (r = 0; r < SynchroPulseLen; r++)        // Синхроимпульс\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xA1;\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0xFF;\n\t\t\t\t}\n\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0xFB;   // Метка \"Данные\"\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\n\t\t\t\t//            SL = unsigned(tdsect->ADRM[3]);\n\t\t\t\t//            if(!SL) SL = 128;\n\t\t\t\t//            else SL = 128 << SL;\n\t\t\t\tSL = tdsect->DataLength - 1;\n\n\t\t\t\tfor (r = 0; r < SL; r++)        // сектор SL байт\n\t\t\t\t{\n\t\t\t\t\tFTracksPtr[trk][side][0][tptr] = ptr[tdOFF + r];\n\t\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\t}\n\t\t\t\ttdOFF += SL;\n\n\t\t\t\tvgcrc = MakeVGCRC(FTracksPtr[trk][side][0] + ptrcrc, tptr - ptrcrc);\n\n\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc >> 8); // VG93 CRC\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = (unsigned char)(vgcrc & 0xFF);\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\n\t\t\tfor (r = 0; r < ThirdSpaceLen; r++)        // Третий пробел\n\t\t\t{\n\t\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t\t}\n\t\t}\n\t\tfor (int eoftrk = tptr; eoftrk < 6250; eoftrk++)\n\t\t{\n\t\t\tFTracksPtr[trk][side][0][tptr] = 0x4E;\n\t\t\tFTracksPtr[trk][side][1][tptr++] = 0x00;\n\t\t}\n\n\t\tif (unsigned(MaxTrack) < trk) MaxTrack = trk;\n\t\tif (unsigned(MaxSide) < side) MaxSide = side;\n\t}\n\n\tdelete ptr;\n\tReadOnly = readonly;\n\tFType = DIT_TD0;\n\tDiskPresent = true;\n}\n\n//-----------------------------------------------------------------------------\nvoid TDiskImage::ShowError(const char *str)\n{\n\tprintf(\"DiskImage Error: %s\\n\", str);\n}\n\n//-----------------------------------------------------------------------------\n// convert packed td0 to unpacked\nunsigned short TD0CRC(unsigned char *buf, unsigned int len);\nunsigned unpack_lzh(unsigned char *src, unsigned size, unsigned char *buf);\nunsigned char *td0_dst, *td0_src;\n\nvoid td0_move(unsigned size)\n{\n\tmemcpy(td0_dst, td0_src, size);\n\ttd0_dst += size;\n\ttd0_src += size;\n}\n\n//----------------------------------------------------------------------------\nbool unpack_td0(unsigned char *data, long &size)\n{\n\tif (size < 12) return false;\n\tif ((*(short*)data != WORD2('T', 'D')) && (*(short*)data != WORD2('t', 'd')))\n\t\treturn false;             // non TD0\n\tif (TD0CRC(data, 10) != *((unsigned short*)(data + 0x0A)))\n\t\treturn false;             // CRC bad...\n\tif (data[4] > 21)\n\t\treturn false;             // version > 2.1...\n\n\tunsigned char *snbuf = (unsigned char*)new char[size * 2 + 1500000];  // if compressed then UUUUFF ;-/\n\tif (!snbuf) return false;\n\n\tmemcpy(snbuf, data, size);\n\tif (*(short*)snbuf == WORD2('t', 'd')) // packed disk\n\t{\n\t\tif (snbuf[4] < 20)    // unsupported Old Advanced compression\n\t\t{\n\t\t\tdelete snbuf;\n\t\t\treturn false;\n\t\t}\n\t\tunpack_lzh((unsigned char*)data + 12, size - 12, (unsigned char*)snbuf + 12), *(short*)snbuf = WORD2('T', 'D');\n\t}\n\n\ttd0_src = snbuf, td0_dst = data;\n\ttd0_move(12);\n\n\tif (snbuf[7] & 0x80)  // additional info...\n\t{\n\t\tunsigned short *cs = (unsigned short*)(snbuf + 12 + 2);\n\n\t\tif (TD0CRC(snbuf + 12 + 2, 8 + *cs) != cs[-1])\n\t\t{\n\t\t\tdelete snbuf;\n\t\t\treturn false;\n\t\t}\n\t\ttd0_move(10);\n\t\ttd0_move(*((unsigned short*)(snbuf + 12 + 2)));\n\t}\n\n\tfor (;;)\n\t{\n\t\tunsigned char s = *td0_src;\n\t\ttd0_move(4);\n\t\tif (s == 0xFF) break;\n\t\tfor (; s; s--)\n\t\t{\n\t\t\t//         unsigned char *sec = td0_src;\n\t\t\tunsigned size = 128; if (td0_src[3]) size <<= td0_src[3];\n\t\t\ttd0_move(6);\n\t\t\t*(unsigned short*)td0_dst = size + 1; td0_dst += 2;\n\t\t\t*td0_dst++ = 0;\n\t\t\tunsigned char *dst = td0_dst;\n\t\t\tunsigned src_size = *(unsigned short*)td0_src; td0_src += 2;\n\t\t\tunsigned char *end_packed_data = td0_src + src_size;\n\t\t\tmemset(td0_dst, 0, size);\n\t\t\tswitch (*td0_src++)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tmemcpy(dst, td0_src, src_size - 1); break;\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tunsigned n = *(unsigned short*)td0_src;\n\t\t\t\ttd0_src += 2;\n\t\t\t\tunsigned short data = *(unsigned short*)td0_src;\n\t\t\t\tfor (; n; n--) *(unsigned short*)dst = data, dst += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tunsigned short data;\n\t\t\t\tunsigned char s;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tswitch (*td0_src++)\n\t\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tfor (s = *td0_src++; s; s--) *dst++ = *td0_src++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ts = *td0_src++;\n\t\t\t\t\t\tdata = *(unsigned short*)td0_src;\n\t\t\t\t\t\ttd0_src += 2;\n\t\t\t\t\t\tfor (; s; s--) *(unsigned short*)dst = data, dst += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: shit:\n\t\t\t\t\t\tdelete snbuf;\n\t\t\t\t\t\treturn false;  // \"bad TD0 file\"\n\t\t\t\t\t}\n\t\t\t\t} while (td0_src < end_packed_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: goto shit;\n\t\t\t}\n\t\t\ttd0_dst += size;\n\t\t\ttd0_src = end_packed_data;\n\t\t}\n\t}\n\tsize = unsigned(td0_dst) - unsigned(data);\n\tdelete snbuf;\n\treturn true;\n}\n//----------------------------------------------------------------------------\n//\n// TD0 CRC - table&proc grabed from TDCHECK.EXE by Alex Makeev\n//\nunsigned char tbltd0crc[512] = {\n\t0x00,0x00,0xA0,0x97,0xE1,0xB9,0x41,0x2E,0x63,0xE5,0xC3,0x72,0x82,0x5C,0x22,0xCB,\n\t0xC7,0xCA,0x67,0x5D,0x26,0x73,0x86,0xE4,0xA4,0x2F,0x04,0xB8,0x45,0x96,0xE5,0x01,\n\t0x2F,0x03,0x8F,0x94,0xCE,0xBA,0x6E,0x2D,0x4C,0xE6,0xEC,0x71,0xAD,0x5F,0x0D,0xC8,\n\t0xE8,0xC9,0x48,0x5E,0x09,0x70,0xA9,0xE7,0x8B,0x2C,0x2B,0xBB,0x6A,0x95,0xCA,0x02,\n\t0x5E,0x06,0xFE,0x91,0xBF,0xBF,0x1F,0x28,0x3D,0xE3,0x9D,0x74,0xDC,0x5A,0x7C,0xCD,\n\t0x99,0xCC,0x39,0x5B,0x78,0x75,0xD8,0xE2,0xFA,0x29,0x5A,0xBE,0x1B,0x90,0xBB,0x07,\n\t0x71,0x05,0xD1,0x92,0x90,0xBC,0x30,0x2B,0x12,0xE0,0xB2,0x77,0xF3,0x59,0x53,0xCE,\n\t0xB6,0xCF,0x16,0x58,0x57,0x76,0xF7,0xE1,0xD5,0x2A,0x75,0xBD,0x34,0x93,0x94,0x04,\n\t0xBC,0x0C,0x1C,0x9B,0x5D,0xB5,0xFD,0x22,0xDF,0xE9,0x7F,0x7E,0x3E,0x50,0x9E,0xC7,\n\t0x7B,0xC6,0xDB,0x51,0x9A,0x7F,0x3A,0xE8,0x18,0x23,0xB8,0xB4,0xF9,0x9A,0x59,0x0D,\n\t0x93,0x0F,0x33,0x98,0x72,0xB6,0xD2,0x21,0xF0,0xEA,0x50,0x7D,0x11,0x53,0xB1,0xC4,\n\t0x54,0xC5,0xF4,0x52,0xB5,0x7C,0x15,0xEB,0x37,0x20,0x97,0xB7,0xD6,0x99,0x76,0x0E,\n\t0xE2,0x0A,0x42,0x9D,0x03,0xB3,0xA3,0x24,0x81,0xEF,0x21,0x78,0x60,0x56,0xC0,0xC1,\n\t0x25,0xC0,0x85,0x57,0xC4,0x79,0x64,0xEE,0x46,0x25,0xE6,0xB2,0xA7,0x9C,0x07,0x0B,\n\t0xCD,0x09,0x6D,0x9E,0x2C,0xB0,0x8C,0x27,0xAE,0xEC,0x0E,0x7B,0x4F,0x55,0xEF,0xC2,\n\t0x0A,0xC3,0xAA,0x54,0xEB,0x7A,0x4B,0xED,0x69,0x26,0xC9,0xB1,0x88,0x9F,0x28,0x08,\n\t0xD8,0x8F,0x78,0x18,0x39,0x36,0x99,0xA1,0xBB,0x6A,0x1B,0xFD,0x5A,0xD3,0xFA,0x44,\n\t0x1F,0x45,0xBF,0xD2,0xFE,0xFC,0x5E,0x6B,0x7C,0xA0,0xDC,0x37,0x9D,0x19,0x3D,0x8E,\n\t0xF7,0x8C,0x57,0x1B,0x16,0x35,0xB6,0xA2,0x94,0x69,0x34,0xFE,0x75,0xD0,0xD5,0x47,\n\t0x30,0x46,0x90,0xD1,0xD1,0xFF,0x71,0x68,0x53,0xA3,0xF3,0x34,0xB2,0x1A,0x12,0x8D,\n\t0x86,0x89,0x26,0x1E,0x67,0x30,0xC7,0xA7,0xE5,0x6C,0x45,0xFB,0x04,0xD5,0xA4,0x42,\n\t0x41,0x43,0xE1,0xD4,0xA0,0xFA,0x00,0x6D,0x22,0xA6,0x82,0x31,0xC3,0x1F,0x63,0x88,\n\t0xA9,0x8A,0x09,0x1D,0x48,0x33,0xE8,0xA4,0xCA,0x6F,0x6A,0xF8,0x2B,0xD6,0x8B,0x41,\n\t0x6E,0x40,0xCE,0xD7,0x8F,0xF9,0x2F,0x6E,0x0D,0xA5,0xAD,0x32,0xEC,0x1C,0x4C,0x8B,\n\t0x64,0x83,0xC4,0x14,0x85,0x3A,0x25,0xAD,0x07,0x66,0xA7,0xF1,0xE6,0xDF,0x46,0x48,\n\t0xA3,0x49,0x03,0xDE,0x42,0xF0,0xE2,0x67,0xC0,0xAC,0x60,0x3B,0x21,0x15,0x81,0x82,\n\t0x4B,0x80,0xEB,0x17,0xAA,0x39,0x0A,0xAE,0x28,0x65,0x88,0xF2,0xC9,0xDC,0x69,0x4B,\n\t0x8C,0x4A,0x2C,0xDD,0x6D,0xF3,0xCD,0x64,0xEF,0xAF,0x4F,0x38,0x0E,0x16,0xAE,0x81,\n\t0x3A,0x85,0x9A,0x12,0xDB,0x3C,0x7B,0xAB,0x59,0x60,0xF9,0xF7,0xB8,0xD9,0x18,0x4E,\n\t0xFD,0x4F,0x5D,0xD8,0x1C,0xF6,0xBC,0x61,0x9E,0xAA,0x3E,0x3D,0x7F,0x13,0xDF,0x84,\n\t0x15,0x86,0xB5,0x11,0xF4,0x3F,0x54,0xA8,0x76,0x63,0xD6,0xF4,0x97,0xDA,0x37,0x4D,\n\t0xD2,0x4C,0x72,0xDB,0x33,0xF5,0x93,0x62,0xB1,0xA9,0x11,0x3E,0x50,0x10,0xF0,0x87,\n};\nunsigned short TD0CRC(unsigned char *buf, unsigned int len)\n{\n\tunsigned short CRC = 0;\n\tint j;\n\tfor (unsigned int i = 0; i < len; i++)\n\t{\n\t\tCRC ^= *buf++;\n\t\tj = CRC & 0xFF;\n\t\tCRC &= 0xFF00;\n\t\tCRC = (CRC << 8) | (CRC >> 8);\n\t\tCRC ^= ((unsigned short*)tbltd0crc)[j];\n\t}\n\treturn (CRC << 8) | (CRC >> 8);\n}\n// ----------------------------------------------------------------------------\n\nunsigned char *packed_ptr, *packed_end;\n\nint readChar(void)\n{\n\tif (packed_ptr < packed_end) return *packed_ptr++;\n\telse return -1;\n}\n\n// ------------------------------------------------------ LZH unpacker\n\nunsigned char d_code[256] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n\t0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,\n\t0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,\n\t0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,\n\t0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,\n\t0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,\n\t0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,\n\t0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,\n\t0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,\n\t0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,\n\t0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,\n\t0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,\n\t0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,\n\t0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,\n\t0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,\n\t0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,\n\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\n};\n\nunsigned char d_len[256] = {\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n};\n\n\nconst int N = 4096;     // buffer size\nconst int F = 60;       // lookahead buffer size\nconst int THRESHOLD = 2;\nconst int NIL = N;      // leaf of tree\n\nunsigned char text_buf[N + F - 1];\n\nconst int N_CHAR = (256 - THRESHOLD + F);       // kinds of characters (character code = 0..N_CHAR-1)\nconst int T = (N_CHAR * 2 - 1);       // size of table\nconst int R = (T - 1);                  // position of root\nconst int MAX_FREQ = 0x8000;            // updates tree when the\n\t\t\t\t\t\t\t\t\t\t// root frequency comes to this value.\n\nunsigned short freq[T + 1];        // frequency table\n\nshort prnt[T + N_CHAR]; // pointers to parent nodes, except for the\n\t\t\t\t\t\t// elements [T..T + N_CHAR - 1] which are used to get\n\t\t\t\t\t\t// the positions of leaves corresponding to the codes.\nshort son[T];           // pointers to child nodes (son[], son[] + 1)\n\n\nint r;\n\nunsigned getbuf;\nunsigned char getlen;\n\nint GetBit(void)      /* get one bit */\n{\n\tint i;\n\n\twhile (getlen <= 8)\n\t{\n\t\tif ((i = readChar()) == -1) i = 0;\n\t\tgetbuf |= i << (8 - getlen);\n\t\tgetlen += 8;\n\t}\n\ti = getbuf;\n\tgetbuf <<= 1;\n\tgetlen--;\n\treturn ((i >> 15) & 1);\n}\n\nint GetByte(void)     /* get one byte */\n{\n\tunsigned i;\n\n\twhile (getlen <= 8)\n\t{\n\t\tif ((int)(i = readChar()) == -1) i = 0;\n\t\tgetbuf |= i << (8 - getlen);\n\t\tgetlen += 8;\n\t}\n\ti = getbuf;\n\tgetbuf <<= 8;\n\tgetlen -= 8;\n\treturn (i >> 8) & 0xFF;\n}\n\nvoid StartHuff(void)\n{\n\tint i, j;\n\n\tgetbuf = 0, getlen = 0;\n\tfor (i = 0; i < N_CHAR; i++) {\n\t\tfreq[i] = 1;\n\t\tson[i] = i + T;\n\t\tprnt[i + T] = i;\n\t}\n\ti = 0; j = N_CHAR;\n\twhile (j <= R) {\n\t\tfreq[j] = freq[i] + freq[i + 1];\n\t\tson[j] = i;\n\t\tprnt[i] = prnt[i + 1] = j;\n\t\ti += 2; j++;\n\t}\n\tfreq[T] = 0xffff;\n\tprnt[R] = 0;\n\n\tfor (i = 0; i < N - F; i++) text_buf[i] = ' ';\n\tr = N - F;\n}\n\n/* reconstruction of tree */\nvoid reconst(void)\n{\n\tint i, j, k;\n\tint f, l;\n\n\t/* collect leaf nodes in the first half of the table */\n\t/* and replace the freq by (freq + 1) / 2. */\n\tj = 0;\n\tfor (i = 0; i < T; i++)\n\t{\n\t\tif (son[i] >= T)\n\t\t{\n\t\t\tfreq[j] = (freq[i] + 1) / 2;\n\t\t\tson[j] = son[i];\n\t\t\tj++;\n\t\t}\n\t}\n\t/* begin constructing tree by connecting sons */\n\tfor (i = 0, j = N_CHAR; j < T; i += 2, j++)\n\t{\n\t\tk = i + 1;\n\t\tf = freq[j] = freq[i] + freq[k];\n\t\tfor (k = j - 1; f < freq[k]; k--);\n\t\tk++;\n\t\tl = (j - k) * sizeof(*freq);\n\t\tmemmove(&freq[k + 1], &freq[k], l);\n\t\tfreq[k] = f;\n\t\tmemmove(&son[k + 1], &son[k], l);\n\t\tson[k] = i;\n\t}\n\t/* connect prnt */\n\tfor (i = 0; i < T; i++)\n\t\tif ((k = son[i]) >= T) prnt[k] = i;\n\t\telse prnt[k] = prnt[k + 1] = i;\n}\n\n\n/* increment frequency of given code by one, and update tree */\n\nvoid update(int c)\n{\n\tint i, j, k, l;\n\n\tif (freq[R] == MAX_FREQ) reconst();\n\n\tc = prnt[c + T];\n\tdo {\n\t\tk = ++freq[c];\n\n\t\t/* if the order is disturbed, exchange nodes */\n\t\tif (k > freq[l = c + 1])\n\t\t{\n\t\t\twhile (k > freq[++l]);\n\t\t\tl--;\n\t\t\tfreq[c] = freq[l];\n\t\t\tfreq[l] = k;\n\n\t\t\ti = son[c];\n\t\t\tprnt[i] = l;\n\t\t\tif (i < T) prnt[i + 1] = l;\n\n\t\t\tj = son[l];\n\t\t\tson[l] = i;\n\n\t\t\tprnt[j] = c;\n\t\t\tif (j < T) prnt[j + 1] = c;\n\t\t\tson[c] = j;\n\n\t\t\tc = l;\n\t\t}\n\t} while ((c = prnt[c]) != 0);  /* repeat up to root */\n}\n\nint DecodeChar(void)\n{\n\tint c;\n\n\tc = son[R];\n\n\t/* travel from root to leaf, */\n\t/* choosing the smaller child node (son[]) if the read bit is 0, */\n\t/* the bigger (son[]+1} if 1 */\n\twhile (c < T) c = son[c + GetBit()];\n\tc -= T;\n\tupdate(c);\n\treturn c;\n}\n\nint DecodePosition(void)\n{\n\tint i, j, c;\n\n\t/* recover upper 6 bits from table */\n\ti = GetByte();\n\tc = (int)d_code[i] << 6;\n\tj = d_len[i];\n\t/* read lower 6 bits verbatim */\n\tj -= 2;\n\twhile (j--) i = (i << 1) + GetBit();\n\treturn c | (i & 0x3f);\n}\n\nunsigned unpack_lzh(unsigned char *src, unsigned size, unsigned char *buf)\n{\n\tpacked_ptr = src;\n\tpacked_end = src + size;\n\tint  i, j, k, c;\n\tunsigned count = 0;\n\tStartHuff();\n\n\t//  while (count < textsize)  // textsize - sizeof unpacked data\n\twhile (packed_ptr < packed_end)\n\t{\n\t\tc = DecodeChar();\n\t\tif (c < 256)\n\t\t{\n\t\t\t*buf++ = c;\n\t\t\ttext_buf[r++] = c;\n\t\t\tr &= (N - 1);\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\ti = (r - DecodePosition() - 1) & (N - 1);\n\t\t\tj = c - 255 + THRESHOLD;\n\t\t\tfor (k = 0; k < j; k++)\n\t\t\t{\n\t\t\t\tc = text_buf[(i + k) & (N - 1)];\n\t\t\t\t*buf++ = c;\n\t\t\t\ttext_buf[r++] = c;\n\t\t\t\tr &= (N - 1);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n//--------------------------------------------------------------------------\n\n#define VOLUME_NUMBER 254\n\n#define TRACKS 35\n#define SECTORS 16\n#define SECTOR_SIZE 256\n#define DOS_TRACK_uint8_tS (SECTORS * SECTOR_SIZE)\n\n#define RAW_TRACK_uint8_tS 0x1A00\n\nstatic uint8_t *target; /* Where to write in the raw_track buffer */\n\n#define write_byte(x) (*target++ = (x))\n\nstatic uint8_t GCR_encoding_table[64] = {\n  0x96, 0x97, 0x9A, 0x9B, 0x9D, 0x9E, 0x9F, 0xA6,\n  0xA7, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB2, 0xB3,\n  0xB4, 0xB5, 0xB6, 0xB7, 0xB9, 0xBA, 0xBB, 0xBC,\n  0xBD, 0xBE, 0xBF, 0xCB, 0xCD, 0xCE, 0xCF, 0xD3,\n  0xD6, 0xD7, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE,\n  0xDF, 0xE5, 0xE6, 0xE7, 0xE9, 0xEA, 0xEB, 0xEC,\n  0xED, 0xEE, 0xEF, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,\n  0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF };\n\nint\tSwap_Bit[4] = { 0, 2, 1, 3 }; /* swap lower 2 bits */\nstatic uint8_t\tGCR_buffer[256];\nstatic uint8_t\tGCR_buffer2[86];\n\n/* physical sector no. to DOS 3.3 logical sector no. table */\nstatic int\tLogical_Sector[16] = {\n  0x0, 0x7, 0xE, 0x6, 0xD, 0x5, 0xC, 0x4,\n  0xB, 0x3, 0xA, 0x2, 0x9, 0x1, 0x8, 0xF };\n\nstatic int\tLogical_Sector_po[16] = {\n  0x0, 0xE, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8,\n  0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0xF };\n\n/*\n * write an FM encoded value, used in writing address fields\n */\nstatic void FM_encode(uint8_t data)\n{\n\twrite_byte((data >> 1) | 0xAA);\n\twrite_byte(data | 0xAA);\n}\n\n/*\n * Write 0xFF sync bytes\n */\nstatic void write_sync(int length)\n{\n\twhile (length--) write_byte(0xFF);\n}\n\nstatic void write_address_field(int volume, int track, int sector)\n{\n\t/*\n\t * write address mark\n\t */\n\twrite_byte(0xD5);\n\twrite_byte(0xAA);\n\twrite_byte(0x96);\n\n\t/*\n\t * write Volume, Track, Sector & Check-sum\n\t */\n\tFM_encode(volume);\n\tFM_encode(track);\n\tFM_encode(sector);\n\tFM_encode(volume ^ track ^ sector);\n\n\t/*\n\t * write epilogue\n\t */\n\twrite_byte(0xDE);\n\twrite_byte(0xAA);\n\twrite_byte(0xEB);\n}\n\n/*\n * 6-and-2 group encoding: the heart of the \"nibblization\" procedure\n */\nstatic void encode62(uint8_t *page)\n{\n\tint i, j;\n\n\t/* 86 * 3 = 258, so the first two byte are encoded twice */\n\tGCR_buffer2[0] = Swap_Bit[page[1] & 0x03];\n\tGCR_buffer2[1] = Swap_Bit[page[0] & 0x03];\n\n\t/* save higher 6 bits in GCR_buffer and lower 2 bits in GCR_buffer2 */\n\tfor (i = 255, j = 2; i >= 0; i--, j = j == 85 ? 0 : j + 1) {\n\t\tGCR_buffer2[j] = (GCR_buffer2[j] << 2) | Swap_Bit[page[i] & 0x03];\n\t\tGCR_buffer[i] = page[i] >> 2;\n\t}\n\n\t/* clear off higher 2 bits of GCR_buffer2 set in the last call */\n\tfor (i = 0; i < 86; i++)\n\t\tGCR_buffer2[i] &= 0x3f;\n}\n\nstatic void write_data_field(uint8_t *page)\n{\n\tint\ti;\n\tuint8_t\tlast, checksum;\n\n\tencode62(page);\n\n\t/* write prologue */\n\twrite_byte(0xD5);\n\twrite_byte(0xAA);\n\twrite_byte(0xAD);\n\n\t/* write GCR encoded data */\n\tfor (i = 0x55, last = 0; i >= 0; --i) {\n\t\tchecksum = last ^ GCR_buffer2[i];\n\t\twrite_byte(GCR_encoding_table[checksum]);\n\t\tlast = GCR_buffer2[i];\n\t}\n\tfor (i = 0; i < 256; ++i) {\n\t\tchecksum = last ^ GCR_buffer[i];\n\t\twrite_byte(GCR_encoding_table[checksum]);\n\t\tlast = GCR_buffer[i];\n\t}\n\n\t/* write checksum and epilogue */\n\twrite_byte(GCR_encoding_table[last]);\n\twrite_byte(0xDE);\n\twrite_byte(0xAA);\n\twrite_byte(0xEB);\n}\n\nint dsk2nib(const char *name, fileTYPE *f)\n{\n\tint len = strlen(name);\n\tint po = 0;\n\n\tif (len > 3 && !strcasecmp(name + len - 3, \".po\"))\n\t{\n\t\tpo = 1;\n\t}\n\telse if (!(len > 4 && !strcasecmp(name + len - 4, \".dsk\")) && !(len > 3 && !strcasecmp(name + len - 3, \".do\")))\n\t{\n\t\treturn 0;\n\t}\n\n\tstatic uint8_t dos_track[SECTORS * SECTOR_SIZE]; // , pro_track[SECTORS * SECTOR_SIZE];\n\tstatic uint8_t raw_track[RAW_TRACK_uint8_tS];\n\n\tfileTYPE disk_file = {};\n\n\tif (!FileOpen(&disk_file, name))\n\t{\n\t\tprintf(\"Unable to mount disk file \\\"%s\\\"\\n\", name);\n\t\treturn 0;\n\t}\n\n\tif (!FileOpenEx(f, \"vdsk\", -1))\n\t{\n\t\tFileClose(&disk_file);\n\t\tprintf(\"ERROR: fail to create vdsk\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Read, convert, and write each track */\n\tfor (int track = 0; track < TRACKS; ++track)\n\t{\n\t\tif (FileReadAdv(&disk_file, dos_track, DOS_TRACK_uint8_tS) != DOS_TRACK_uint8_tS)\n\t\t{\n\t\t\tprintf(\"Unexpected end of disk data\\n\");\n\t\t\tFileClose(&disk_file);\n\t\t\tFileClose(f);\n\t\t\treturn 0;\n\t\t}\n\n\t\ttarget = raw_track;\n\n\t\tfor (int sector = 0; sector < SECTORS; sector++)\n\t\t{\n\t\t\tint sec = po ? Logical_Sector_po[sector] : sector;\n\n\t\t\twrite_sync(38);    /* Inter-sector gap */\n\t\t\twrite_address_field(VOLUME_NUMBER, track, sector);\n\t\t\twrite_sync(8);\n\t\t\twrite_data_field(dos_track + Logical_Sector[sec] * SECTOR_SIZE);\n\t\t}\n\n\t\t/* Pad rest of buffer with sync bytes */\n\t\twhile (target != &raw_track[RAW_TRACK_uint8_tS]) write_byte(0xff);\n\n\t\tif (FileWriteAdv(f, raw_track, RAW_TRACK_uint8_tS) != RAW_TRACK_uint8_tS)\n\t\t{\n\t\t\tprintf(\"Error writing to vdsk file\\n\");\n\t\t\tFileClose(&disk_file);\n\t\t\tFileClose(f);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tFileClose(&disk_file);\n\n\tf->size = FileGetSize(f);\n\tFileSeekLBA(f, 0);\n\tprintf(\"dsk2nib: vdsk size=%llu.\\n\", f->size);\n\n\treturn 1;\n}\n\n//--------------------------------------------------------------------------\nint x2trd(const char *name, fileTYPE *f)\n{\n\tTDiskImage *img = new TDiskImage;\n\timg->Open(getFullPath(name), true);\n\n\tif (!FileOpenEx(f, \"vdsk\", -1))\n\t{\n\t\tdelete img;\n\t\tprintf(\"ERROR: fail to create vdsk\\n\");\n\t\treturn 0;\n\t}\n\n\timg->writeTRD(f);\n\tdelete(img);\n\n\tf->size = FileGetSize(f);\n\tFileSeekLBA(f, 0);\n\tprintf(\"x2trd: vdsk size=%llu.\\n\", f->size);\n\n\treturn 1;\n}\n\nint x2trd_ext_supp(const char *name)\n{\n\tconst char *ext = \"\";\n\tif (strlen(name) > 4) ext = name + strlen(name) - 4;\n\treturn (!strcasecmp(ext, \".scl\") || !strcasecmp(ext, \".fdi\") || !strcasecmp(ext, \".udi\"));\n}\n"
        },
        {
          "name": "DiskImage.h",
          "type": "blob",
          "size": 0.2724609375,
          "content": "#ifndef __DISKIMAGE_H\n#define __DISKIMAGE_H\n\n#include \"file_io.h\"\n\nint dsk2nib(const char *name, fileTYPE *f);\nint x2trd(const char *name, fileTYPE *f);\nint x2trd_ext_supp(const char *name);\n\n//-----------------------------------------------------------------------------\n#endif\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "LPF20000.txt",
          "type": "blob",
          "size": 0.341796875,
          "content": "# version\r\nv1\r\n\r\n# sampling frequency\r\n# must be multiple of 48000 for best results\r\n7056000\r\n\r\n#base gain\r\n0.00000774701983513660\r\n\r\n#gain scale for X0\r\n3\r\n\r\n#gain scale for X1\r\n3\r\n\r\n#gain scale for X2\r\n1\r\n\r\n#coefficient for Y0\r\n-2.96438150626551080000\r\n\r\n#coefficient for Y1\r\n2.92939452735121100000\r\n\r\n#coefficient for Y2\r\n-0.96500747158831091000\r\n"
        },
        {
          "name": "LPF2000_2tap.txt",
          "type": "blob",
          "size": 0.30078125,
          "content": "# version\r\nv1\r\n\r\n# sampling frequency\r\n# must be multiple of 48000 for best results\r\n7056000\r\n\r\n#base gain\r\n0.00000316778645516‬\r\n\r\n#gain scale for X0\r\n2\r\n\r\n#gain scale for X1\r\n1\r\n\r\n#gain scale for X2\r\n0\r\n\r\n#coefficient for Y0\r\n-1.9974813602\r\n\r\n#coefficient for Y1\r\n0.9974845280\r\n\r\n#coefficient for Y2\r\n0\r\n"
        },
        {
          "name": "LPF2000_3tap.txt",
          "type": "blob",
          "size": 0.3125,
          "content": "# version\r\nv1\r\n\r\n# sampling frequency\r\n# must be multiple of 48000 for best results\r\n1764000\r\n\r\n#base gain\r\n0.00000035895956448‬\r\n\r\n#gain scale for X0\r\n3\r\n\r\n#gain scale for X1\r\n3\r\n\r\n#gain scale for X2\r\n1\r\n\r\n#coefficient for Y0\r\n-2.9857524444\r\n\r\n#coefficient for Y1\r\n2.9716062045\r\n\r\n#coefficient for Y2\r\n-0.9858534011\r\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.6982421875,
          "content": "# makefile to fail if any command in pipe is failed.\nSHELL = /bin/bash -o pipefail\n\nMAKEFLAGS += \"-j $(shell nproc)\"\n\n# using gcc version 10.2.1\nBASE    = arm-none-linux-gnueabihf\n\nCC      = $(BASE)-gcc\nLD      = $(BASE)-ld\nSTRIP   = $(BASE)-strip\n\nifeq ($(V),1)\n\tQ :=\nelse\n\tQ := @\nendif\n\nINCLUDE\t= -I./\nINCLUDE\t+= -I./lib/libco\nINCLUDE\t+= -I./lib/miniz\nINCLUDE\t+= -I./lib/md5\nINCLUDE += -I./lib/lzma\nINCLUDE += -I./lib/zstd/lib\nINCLUDE += -I./lib/libchdr/include\nINCLUDE += -I./lib/bluetooth\nINCLUDE += -I./lib/serial_server/library\n\nPRJ = MiSTer\nC_SRC =   $(wildcard *.c) \\\n          $(wildcard ./lib/miniz/*.c) \\\n          $(wildcard ./lib/md5/*.c) \\\n          $(wildcard ./lib/lzma/*.c) \\\n\t\t\t\t\t$(wildcard ./lib/zstd/lib/common/*.c) \\\n\t\t\t\t\t$(wildcard ./lib/zstd/lib/decompress/*.c) \\\n          $(wildcard ./lib/libchdr/*.c) \\\n          lib/libco/arm.c \n\nCPP_SRC = $(wildcard *.cpp) \\\n          $(wildcard ./lib/serial_server/library/*.cpp) \\\n          $(wildcard ./support/*/*.cpp) \n\nIMG =     $(wildcard *.png)\n\nIMLIB2_LIB  = -Llib/imlib2 -lfreetype -lbz2 -lpng16 -lz -lImlib2\n\nOBJ\t= $(C_SRC:.c=.c.o) $(CPP_SRC:.cpp=.cpp.o) $(IMG:.png=.png.o)\nDEP\t= $(C_SRC:.c=.c.d) $(CPP_SRC:.cpp=.cpp.d)\n\nDFLAGS\t= $(INCLUDE) -D_7ZIP_ST -DPACKAGE_VERSION=\\\"1.3.3\\\" -DHAVE_LROUND -DHAVE_STDINT_H -DHAVE_STDLIB_H -DHAVE_SYS_PARAM_H -DENABLE_64_BIT_WORDS=0 -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -DVDATE=\\\"`date +\"%y%m%d\"`\\\"\nCFLAGS\t= $(DFLAGS) -Wall -Wextra -Wno-strict-aliasing -Wno-stringop-overflow -Wno-stringop-truncation -Wno-format-truncation -Wno-psabi -Wno-restrict -c -O3\nLFLAGS\t= -lc -lstdc++ -lm -lrt $(IMLIB2_LIB) -Llib/bluetooth -lbluetooth -lpthread\n\nOUTPUT_FILTER = sed -e 's/\\(.[a-zA-Z]\\+\\):\\([0-9]\\+\\):\\([0-9]\\+\\):/\\1(\\2,\\ \\3):/g'\r\n\r\nifeq ($(PROFILING),1)\n\tDFLAGS += -DPROFILING\nendif\n\n$(PRJ): $(OBJ)\n\t$(Q)$(info $@)\n\t$(Q)$(CC) -o $@ $+ $(LFLAGS) \n\t$(Q)cp $@ $@.elf\n\t$(Q)$(STRIP) $@\n\n.PHONY: clean\nclean:\n\t$(Q)rm -f *.elf *.map *.lst *.user *~ $(PRJ)\n\t$(Q)rm -rf obj DTAR* x64\n\t$(Q)find . \\( -name '*.o' -o -name '*.d' -o -name '*.bak' -o -name '*.rej' -o -name '*.org' \\) -exec rm -f {} \\;\n\n%.c.o: %.c\n\t$(Q)$(info $<)\n\t$(Q)$(CC) $(CFLAGS) -std=gnu99 -o $@ -c $< 2>&1 | $(OUTPUT_FILTER)\n\n%.cpp.o: %.cpp\n\t$(Q)$(info $<)\n\t$(Q)$(CC) $(CFLAGS) -std=gnu++14 -Wno-class-memaccess -o $@ -c $< 2>&1 | $(OUTPUT_FILTER)\n\n%.png.o: %.png\n\t$(Q)$(info $<)\n\t$(Q)$(LD) -r -b binary -o $@ $< 2>&1 | $(OUTPUT_FILTER)\n\nifneq ($(MAKECMDGOALS), clean)\n-include $(DEP)\nendif\n%.c.d: %.c\n\t$(Q)$(info $< >> $@)\n\t$(Q)$(CC) $(DFLAGS) -MM $< -MT $@ -MT $*.c.o -MF $@ 2>&1 | $(OUTPUT_FILTER)\n\n%.cpp.d: %.cpp\n\t$(Q)$(info $< >> $@)\n\t$(Q)$(CC) $(DFLAGS) -MM $< -MT $@ -MT $*.cpp.o -MF $@ 2>&1 | $(OUTPUT_FILTER)\n\n# Ensure correct time stamp\nmain.cpp.o: $(filter-out main.cpp.o, $(OBJ))\n"
        },
        {
          "name": "MiSTer.ini",
          "type": "blob",
          "size": 17.7724609375,
          "content": "[MiSTer]\r\n;debug=1               ; set to 1 to enable debugging messages. Default is 0(disabled).\r\nkey_menu_as_rgui=0     ; set to 1 to make the MENU key map to RGUI in Minimig (e.g. for Right Amiga)\r\nforced_scandoubler=0   ; set to 1 to run scandoubler on VGA output always (depends on core).\r\n;ypbpr=0               ; set to 1 for YPbPr on VGA output. (obsolete. see vga_mode)\r\nvga_mode=rgb           ; supported modes: rgb, ypbpr, svideo, cvbs. rgb is default.\r\nntsc_mode=0            ; Only for S-Video and CVBS vga_mode. 0 - normal NTSC, 1 - PAL-60, 2 - PAL-M.\r\ncomposite_sync=0       ; set to 1 for composite sync on HSync signal of VGA output.\r\nvga_scaler=0           ; set to 1 to connect VGA to scaler output.\r\nhdmi_audio_96k=0       ; set to 1 for 96khz/16bit HDMI audio (48khz/16bit otherwise)\r\nkeyrah_mode=0x18d80002 ; VIDPID of keyrah for special code translation (0x23418037 for Arduino Micro)\r\nvscale_mode=0          ; 0 - scale to fit the screen height.\r\n                       ; 1 - use integer scale only.\r\n                       ; 2 - use 0.5 steps of scale.\r\n                       ; 3 - use 0.25 steps of scale.\r\n                       ; 4 - integer resolution scaling, use core aspect ratio\r\n                       ; 5 - integer resolution scaling, maintain display aspect ratio\r\nvscale_border=0        ; set vertical border for TVs cutting the upper/bottom parts of screen (1-399)\r\n;bootscreen=0          ; uncomment to disable boot screen of some cores like Minimig. \r\n;mouse_throttle=10     ; 1-100 mouse speed divider. Useful for very sensitive mice\r\nrbf_hide_datecode=0    ; 1 - hides datecodes from rbf file names. Press F2 for quick temporary toggle\r\nmenu_pal=0             ; 1 - PAL mode for menu core\r\nhdmi_limited=0         ; 1 - use limited (16..235) color range over HDMI\r\n                       ; 2 - use limited (16..255) color range over HDMI, for VGA converters.\r\ndirect_video=0         ; 1 - enable core video timing over HDMI, use only with VGA converters.\r\nhdr=0                  ; 1 - enable HDR using HLG (recommended for most users)\r\n                       ; 2 - enable HDR using the DCI P3 color space (use color controls to tweak, suggestion: set saturation to 80).\r\nfb_size=0              ; 0 - automatic, 1 - full size, 2 - 1/2 of resolution, 4 - 1/4 of resolution.\r\nfb_terminal=1          ; 1 - enabled (default), 0 - disabled\r\nosd_timeout=30         ; 5-3600 timeout (in seconds) for OSD to disappear in Menu core. 0 - never timeout.\r\n                       ; Background picture will get darker after double timeout\r\nvideo_off=0            ; output black frame in Menu core after timeout (is seconds). Valid only if osd_timout is non zero.\r\nosd_rotate=0           ; Display OSD menu rotated,  0 - no rotation, 1 - rotate right (+90°), 2 - rotate left (-90°)                  \r\nvga_sog=0              ; 1 - enable sync on green (needs analog I/O board v6.0 or newer).\r\n\r\n\r\n; 1 - enables the recent file loaded/mounted.\r\n; WARNING: This option will enable write to SD card on every load/mount which may wear the SD card after many writes to the same place\r\n;          There is also higher chance to corrupt the File System if MiSTer will be reset or powered off while writing.\r\nrecents=0\r\n\r\n; lastcore - Autoboot the last loaded core (corename autosaved in CONFIG/lastcore.dat) first found on the SD/USB\r\n; lastexactcore - Autoboot the last loaded exact core (corename_yyyymmdd.rbf autosaved in CONFIG/lastcore.dat) first found on the SD/USB\r\n; corename - Autoboot first corename_*.rbf found on the SD/USB\r\n; corename_yyyymmdd.rbf - Autoboot first corename_yyyymmdd.rbf found on the SD/USB\r\n;bootcore=lastcore    ; uncomment to autoboot a core, as the last loaded core.\r\n\r\n; 10-30 timeout before autoboot, comment for autoboot without timeout.\r\nbootcore_timeout=10\r\n\r\n; Option to load the custom font. Format is plain bitmap 8x8.\r\n; Supported sizes of font:\r\n;   768 bytes - chars 32-127 (only alpha + numeric)\r\n;  1024 bytes - chars 0-127\r\n;  1136 bytes - chars 0-141\r\n;  up to 2048 - only chars 0-141 will be used.\r\n; if first 32 chars are empty (for sizes 1024 bytes and more) then they are skipped.\r\nfont=font/myfont.pf\r\n\r\n; USER button emulation using a keyboard. Usually it's the reset button.\r\n; 0 - lctrl+lalt+ralt (lctrl+lgui+rgui on keyrah)\r\n; 1 - lctrl+lgui+rgui\r\n; 2 - lctrl+lalt+del\r\n; 3 - same as 0 (lctrl+lalt+ralt on keyrah)\r\nreset_combo=0\r\n\r\n; !!!!\r\n; Attention: if video_mode is not set in INI, then MiSTer will try to detect\r\n; native mode of display and use it instead.\r\n; Additionally, if dvi_mode is not set (only if video_mode is not set), \r\n; then MiSTer will try to detect if display is DVI.\r\n; !!!!\r\n\r\n; set to 1 for DVI mode. Audio won't be transmitted through HDMI in DVI mode.\r\n;dvi_mode=0\r\n\r\n; 0 - 1280x720@60\r\n; 1 - 1024x768@60\r\n; 2 - 720x480@60\r\n; 3 - 720x576@50\r\n; 4 - 1280x1024@60\r\n; 5 - 800x600@60\r\n; 6 - 640x480@60\r\n; 7 - 1280x720@50\r\n; 8 - 1920x1080@60\r\n; 9 - 1920x1080@50\r\n;10 - 1366x768@60\r\n;11 - 1024x600@60\r\n;12 - 1920x1440@60\r\n;13 - 2048x1536@60\r\n;14 - 2560x1440@60\r\n;\r\n; custom mode: hact,hfp,hs,hbp,vact,vfp,vs,vbp,Fpix_in_KHz[,hsyncp,vsyncp]\r\n;  example: video_mode=1280,110,40,220,720,5,5,20,74250,+hsync,-vsync\r\n;\r\n; calculated mode: width,height,refresh[,flags]\r\n;  example: video_mode=1920,1200,60\r\n; flags - cvt=CVT timing, cvtrb=CVT-RB timing (default)\r\n;video_mode=0\r\n\r\n; set to 1-10 (seconds) to display video info on startup/change\r\nvideo_info=0\r\n\r\n; Set to 1 for automatic HDMI VSync rate adjust to match original VSync.\r\n; Set to 2 for low latency mode (single buffer).\r\n; This option makes video butter smooth like on original emulated system.\r\n; Adjusting is done by changing pixel clock. Not every display supports variable pixel clock.\r\n; For proper adjusting and to reduce possible out of range pixel clock, use 60Hz HDMI video\r\n; modes as a base even for 50Hz systems. \r\nvsync_adjust=0\r\n\r\n; If your monitor doesn't support either very low (NTSC monitors may not support PAL) or \r\n; very high (PAL monitors may not support NTSC) then you can set refresh_min and/or refresh_max\r\n; parameters, so vsync_adjust won't be applied for refreshes outside specified.\r\n; These parameters are valid only when vsync_adjust is non-zero.\r\nrefresh_min=0\r\nrefresh_max=0\r\n\r\n; These parameters have the same format as video_mode.\r\n; You need to supply both PAL and NTSC modes if you want vsync_adjust to switch between\r\n; predefined modes as a base. This will reduce the range of pixel clock.\r\n;video_mode_ntsc=0\r\n;video_mode_pal=7\r\n\r\n; Provided below are options for modulating color on the HDMI output.\r\n; Brightness, contrast and saturation can be set to any value between 0 and 100.\r\n; Hue can be set to 0 - 360, observing the HSL color model.\r\n; Each component of video_gain_offset can be set to any value between -2 and 2.\r\n; The order is \"gain,offset\" repeated three times to cover RGB.\r\n; Example 1, Inverted colors:\r\n; video_gain_offset= -1, 1, -1, 1, -1, 1\r\n; Example 2, Slightly desaturated, warm display:\r\n; video_saturation= 80\r\n; video_gain_offset= 1.5, -0.1, 1.3, -0.15, 0.9, 0.05\r\nvideo_brightness=50\r\nvideo_contrast=50\r\nvideo_saturation=100\r\nvideo_hue=0\r\nvideo_gain_offset=1,0,1,0,1,0\r\n\r\n; These controls have been provided so you can tweak the HDR metadata values regarding\r\n; peak brightness and average brightness. The defaults are 1000/250 for peak and average\r\n; respectively.\r\n; Some displays will completely ignore the values in the HDR packet, some will make use of them.\r\n; The recommendation is to set hdr_max_nits to your display's peak luminance, while\r\n; setting hdr_avg_nits to at least hdr_max_nits/4.\r\n; Please note that setting a peak brightness far above your display's capability may result\r\n; in clipping in bright parts of the image.\r\nhdr_max_nits=1000\r\nhdr_avg_nits=250\r\n\r\n; 1-10 (seconds) to display controller's button map upon first time key press\r\n; 0 - disable\r\ncontroller_info=6\r\n\r\n; JammaSD/J-PAC/I-PAC keys to joysticks translation\r\n; You have to provide correct VID and PID of your input device\r\n; Examples: Legacy J-PAC with Mini-USB or USB capable I-PAC with PS/2 connectors VID=0xD209/PID=0x0301\r\n; USB Capable J-PAC with only PS/2 connectors VID=0x04B4/PID=0x0101\r\n; JammaSD: VID=0x04D8/PID=0xF3AD\r\n;   jamma_vid/pid  (i.e. JammaSD) would be mapped to Players 1 and 2 controllers.\r\n;   jamma2_vid/pid (i.e. J-PAC  ) would be mapped to Players 3 and 4 controllers\r\n;                                 for a possible 4-player JAMMA-VERSUS scenario\r\n;                                 using two JAMMA USB controller interfaces.\r\njamma_vid=0x04D8\r\njamma_pid=0xF3AD\r\njamma2_vid=0x1111\r\njamma2_pid=0x2222\r\n\r\n; Disable merging input devices. Use if only player 1 works.\r\n; Leave no_merge_pid empty to apply this to all devices with the same VID.\r\n;no_merge_vid=0x045E\r\n;no_merge_pid=0x028E\r\n\r\n; Same as above but can add multiple devices (one entry per VIDPID). Format is VIDPID in hex number\r\n;no_merge_vidpid=0x12345678\r\n;no_merge_vidpid=0x11112222\r\n\r\n; Dead zone radius definitions. \r\n; Joystick movements smaller than a defined radius will be neglected. \r\n; This is good for worn or poorly made joysticks and converters.\r\n; Devices that match the identifier part of the string will be affected.\r\n; You can add multiple devices (one entry per identifier). \r\n; The identifier part is case-insensitive, and the radius can be up to 64 units. \r\n; Identifier and radius are separated by a whitespace (' ') and/or a comma (','). \r\n; Accepted formats are:\r\n;\r\n; - VIDPID as an eight digit hex number (\"0x\" can be omitted), then the radius (not hex).\r\n;deadzone=0x1E8F1603, 25\r\n;\r\n; - vid:VID as a four digit hex, then the radius.\r\n;deadzone=vid:0x1e8f, 25\r\n;\r\n; - pid:PID as a four digit hex, then the radius.\r\n;deadzone=PID:1603 25\r\n;\r\n; - The following formats are explained a bit further down:\r\n;deadzone=usb-1.2/, 10\r\n;deadzone=7c:10:c9:15:22:33/df:47:3a:12:44:55, 8\r\n;deadzone=1e8f_1603_55c4dd0c, 5\r\n\r\n; Permanently assign specific controller to specific player.\r\n; Normally you don't need to use this option, but if you use arcade cabinet with integrated controllers then\r\n; you may want to use it for specific player regardless which controller is used first.\r\n; To assign it, you need to provide unique part of this controller ID.\r\n; In USB debug log you may see list of input devices right after core has been loaded. \r\n; For example:\r\n;\r\n; opened 0( 0): /dev/input/event8 (1915:0040) 0 \"7c:10:c9:15:22:33/df:47:3a:12:44:55\" \"Flydigi APEX2\"\r\n; ...\r\n; opened 7( 7): /dev/input/event3 (1997:2535) 0 \"usb-ffb40000.usb-1.6/input0\" \"  mini keyboard\"\r\n; opened 9( 9): /dev/input/event0 (046d:4024) 0 \"usb-ffb40000.usb-1.2/input2:1/4024-19-a2-39-0a\" \"Logitech K400\"\r\n;\r\n; following part is unique identifier in system ^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n; So you need to provide part of this string identifying exactly this device. Don't include inputX part as it may change after reboot.\r\n; Wireless devices usually have format MAC/MAC, wired devices use usb-... format.\r\n; UPDATE: you may define up to 8 devices to the same player. Use player_1_controller in several lines to assign multiple devices to player 1.\r\n;\r\n; Example of such unique part of strings:\r\n;\r\n;player_1_controller=usb-1.2/  ;include / at the end so it won't match with something like usb-1.2.3\r\n;player_2_controller=7c:10:c9:15:22:33/df:47:3a:12:44:55\r\n;player_3_controller=1915_0040_55c4dd0c ; VID_PID_HASH - VID, PID and unique HASH\r\n;player_4_controller=1915_0040 ; VID_PID - warning, it will assign all input devices with these VID:PID to same player!\r\n\r\n\r\n; Speeds in sniper/non-sniper modes of mouse emulation by joystick \r\n; 0 - (default) - faster move in non-sniper mode, slower move in sniper mode.\r\n; 1 - movement speeds are swapped.\r\nsniper_mode=0\r\n\r\n; Uncomment following option if you don't want to see a second line for long file names in listing.\r\n;browse_expand=0\r\n\r\n; 0 - disable MiSTer logo in Menu core\r\nlogo=1\r\n\r\n; Custom shared folder for core supporting this feature (currently minimig and ao486 only)\r\n; Can be relative to core's home dir or absolute path.\r\n; Path must exist before core start to use it, or it will fail.\r\n; Make sure USB device is mounted before use shared folder on USB!\r\nshared_folder=\r\n\r\n; Custom aspect ratio\r\n;custom_aspect_ratio_1=16:10\r\n;custom_aspect_ratio_2=1:1\r\n\r\n; use specific (VID/PID) mouse X movement as a spinner and paddle. Use VID=0xFFFF/PID=0xFFFF to use all mice as spinners.\r\n;spinner_vid=0x1BCF\r\n;spinner_pid=0x0005\r\n\r\n; spinner_throttle with base value 100 gives one spinner step per one tick. Higher value makes spinner slower.\r\n; Lower than 100 makes spinner faster. Negative value gives opposite direction.\r\n;spinner_throttle=-50\r\n\r\n; 0 - X axis, 1 - Y axis, 2 - wheel.\r\n;spinner_axis=1\r\n\r\n; Default filters for video scaler. Paths must be relative to \"Filters\" folder without leading slash.\r\n;vfilter_default=LCD Effects/LCD_Effect_07.txt\r\n;vfilter_vertical_default=<some_file>\r\n;vfilter_scanlines_default=<some_file>\r\n\r\n; Default filters for audio. Paths must be relative to \"Filters_audio\" folder without leading slash.\r\n;afilter_default=LPF2000_3tap.txt\r\n\r\n; Defines internal joypad mapping from virtual SNES mapping in main to core mapping\r\n; Set to 0 for name mapping (jn) (e.g. A button in SNES core = A button on controller regardless of position on pad)\r\n; Set to 1 for positional mapping (jp) (e.g. A button in SNES core = East button on controller regardless of button name)\r\ngamepad_defaults=0\r\n\r\n; Write out file name under the cursor in browser for external integration\r\n; External application or script may parse the info and do some additional actions and/or send info to 3rd party server.\r\n; Warning: it may slowdown the system or add lag while browsing the files in OSD depending on external app/script.\r\nlog_file_entry=0\r\n\r\n; Automatically disconnect (and shutdown) Bluetooth input device if not use specified amount of time.\r\n; Some controllers have no automatic shutdown built in and will keep connection till battery dry out.\r\n; 0 - don't disconnect automatically, otherwise it's amount of minutes.\r\nbt_auto_disconnect=0\r\n\r\n; Reset Bluetooth dongle before pair dialog.\r\n; Some dongles may have problem to pair if not explicitly reset.\r\n; Some dongles (mostly CSR) have problem to pair with BLE if not reset in advance.\r\n; Consequence of reset: some input devices get shutdown after reset.\r\nbt_reset_before_pair=0\r\n\r\n;default Shadow Mask\r\n;shmask_default=VGA.txt\r\n\r\n;default shadow mask mode:\r\n; 0 - none, 1 - 1x, 2 - 2x, 3 - 1x Rotated, 4 - 2x Rotated\r\n;shmask_mode_default=1\r\n\r\n; Wait for specific mount before start the core. \r\n; Attention: waiting is performing BEFORE core start, so no message will be displayed on screen!\r\n; It's useful for debugging when core is loaded from USB blaster and games folder is on USB or Network drive.\r\n; This option cannot be used when defmra in CONFSTR is used (i.e. if arcade rbf is loaded directly not through MRA).\r\n; This option is ignored for Menu core.\r\n;waitmount=/media/usb0\r\n\r\n; Overrides for video mode\r\n; When the core's video mode matches the parameters in the section header, any options in the section override options from MiSTer and core sections.\r\n; Refresh rate in header is optional and, if present, must match exactly the output from video_info or the logs.  For example, if it says \"60.0Hz\", the header needs to be \"@60.0\" to match.\r\n; When the core changes video mode, MiSTer will first look for a matching WIDTHxHEIGHT@VREFRESH section.\r\n; If no match is found, it will fall back to a matching WIDTHxHEIGHT section with no refresh rate.\r\n; If there is still no match, MiSTer/core options will be used without overrides.\r\n; [video=640x400]\r\n; ...\r\n; [video=640x400@70.1]\r\n; ...\r\n\r\n; Wheel centering force 0-100. Default is 50.\r\n;wheel_force=50\r\n\r\n; Wheel steering angle range. Supported ranges depends on specific wheel model\r\n; If not set then default (depending on driver) range is used\r\n;wheel_range=200\r\n\r\n; Enable game mode on HDMI output. It may give you better optimization on some displays, but also \r\n; can give worse result on others. Default is 0 (non-game).\r\n;hdmi_game_mode=1\r\n\r\n; Variable Refresh Rate control\r\n; 0 - Do not enable VRR (send no VRR control frames)\r\n; 1 - Auto Detect VRR from display EDID. \r\n; 2 - Force Enable Freesync\r\n; 3 - Force Enable Vesa HDMI Forum VRR\r\nvrr_mode=0\r\n; Minimum framerate in VRR mode. \r\nvrr_min_framerate=0\r\n; Maximum framerate in VRR mode (currently only used in Freesync mode). \r\nvrr_max_framerate=0\r\n; VESA VRR base framerate. Normally set to the current video mode's output framerate\r\nvrr_vesa_framerate=0\r\n\r\n; disable autofire if for some reason it's not required and accidentally triggered\r\ndisable_autofire=0\r\n\r\n; Specify a default video processing preset that will be applied to cores.\r\n; Path is relative to the presets/ directory and can optionally include the .ini extension\r\n;preset_default=General Hardware/Console - 3rdGen\r\n\r\n; Enable per controller and per USB port mapping, both gamepads and keyboards\r\n; Even same model of controller connected to different USB ports will have different button sets,\r\n; thus make sure to define buttons for all controllers if you set this option to 1.\r\n; Option also accepts VIDPID value to define per-port mapping only for specific VID:PID device.\r\n; It's useful for DIY controllers using off-the-shelf boards like arduino.\r\n; You may use several controller_unique_mapping instances to assign several VID:PID.\r\n;controller_unique_mapping=0x23418037 ; example for Arduino Micro\r\ncontroller_unique_mapping=0\r\n\r\n\r\n; Protect access to the OSD when a core is running\r\n; When attempting to access the OSD players will be prompted for an unlock code.\r\n; U = Up, D = Down, L = Left, R = Right, A = Select, B = Back\r\n; Setting osd_lock to DUUUD would require entering the sequence Down, Up, Up, Up, Down\r\n;osd_lock=DUUUD\r\n\r\n; If osd_lock is enabled, allow the OSD to be opened without entering the unlock\r\n; code if less than osd_lock_time seconds have passed since the OSD was closed.\r\n; set to 0 for manual lock from OSD\r\nosd_lock_time=5\r\n\r\n; use custom main for specific core. This option should be used only inside specific core.\r\n;main=some_binary_file\r\n"
        },
        {
          "name": "MiSTer.jpg",
          "type": "blob",
          "size": 66.4345703125,
          "content": null
        },
        {
          "name": "MiSTer.sln",
          "type": "blob",
          "size": 0.734375,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio 14\r\nVisualStudioVersion = 14.0.23107.0\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"MiSTer\", \"MiSTer.vcxproj\", \"{C1D6BEA2-1469-4FBC-8A27-A82BDE9041AC}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|x86 = Debug|x86\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{C1D6BEA2-1469-4FBC-8A27-A82BDE9041AC}.Debug|x86.ActiveCfg = Debug|Win32\r\n\t\t{C1D6BEA2-1469-4FBC-8A27-A82BDE9041AC}.Debug|x86.Build.0 = Debug|Win32\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "MiSTer.vcxproj",
          "type": "blob",
          "size": 9.4912109375,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup Label=\"ProjectConfigurations\">\r\n    <ProjectConfiguration Include=\"Debug|Win32\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n  </ItemGroup>\r\n  <PropertyGroup Label=\"Globals\">\r\n    <ProjectGuid>{C1D6BEA2-1469-4FBC-8A27-A82BDE9041AC}</ProjectGuid>\r\n    <Keyword>MakeFileProj</Keyword>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>Makefile</ConfigurationType>\r\n    <UseDebugLibraries>true</UseDebugLibraries>\r\n    <PlatformToolset>v141</PlatformToolset>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\r\n  <ImportGroup Label=\"ExtensionSettings\">\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"Shared\">\r\n  </ImportGroup>\r\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n  </ImportGroup>\r\n  <PropertyGroup Label=\"UserMacros\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <NMakeBuildCommandLine>wsl bash -lic ./build.sh</NMakeBuildCommandLine>\r\n    <NMakeOutput>MiSTer</NMakeOutput>\r\n    <NMakeCleanCommandLine>wsl bash -lic ./clean.sh</NMakeCleanCommandLine>\r\n    <NMakePreprocessorDefinitions>__arm__;__GNUC__;__USE_GNU ;_GNU_SOURCE;VDATE=\"000000\";_FILE_OFFSET_BITS=64;_LARGEFILE64_SOURCE;$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>\r\n    <NMakeIncludeSearchPath>c:\\Work\\MiSTer\\toolchain\\gcc103\\arm-none-linux-gnueabihf\\libc\\usr\\include;c:\\Work\\MiSTer\\toolchain\\gcc103\\lib\\gcc\\arm-none-linux-gnueabihf\\10.3.1\\include;c:\\Work\\MiSTer\\toolchain\\gcc103\\arm-none-linux-gnueabihf\\include\\c++\\10.3.1;c:\\Work\\MiSTer\\toolchain\\gcc103\\arm-none-linux-gnueabihf\\include\\c++\\10.3.1\\arm-linux-gnueabihf;$(NMakeIncludeSearchPath);lib\\libco;lib\\miniz;lib\\lodepng;lib\\libchdr\\include;lib\\bluetooth</NMakeIncludeSearchPath>\r\n    <OutDir>$(TEMP)</OutDir>\r\n    <IntDir>$(TEMP)</IntDir>\r\n    <AdditionalOptions>\r\n    </AdditionalOptions>\r\n    <IncludePath />\r\n    <ReferencePath />\r\n    <LibraryPath />\r\n    <LibraryWPath />\r\n  </PropertyGroup>\r\n  <ItemDefinitionGroup>\r\n  </ItemDefinitionGroup>\r\n  <ItemGroup>\r\n    <None Include=\"build.sh\" />\r\n    <None Include=\"clean.sh\" />\r\n    <None Include=\"Makefile\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"audio.cpp\" />\r\n    <ClCompile Include=\"battery.cpp\" />\r\n    <ClCompile Include=\"bootcore.cpp\" />\r\n    <ClCompile Include=\"brightness.cpp\" />\r\n    <ClCompile Include=\"cfg.cpp\" />\r\n    <ClCompile Include=\"charrom.cpp\" />\r\n    <ClCompile Include=\"cheats.cpp\" />\r\n    <ClCompile Include=\"DiskImage.cpp\" />\r\n    <ClCompile Include=\"file_io.cpp\" />\r\n    <ClCompile Include=\"fpga_io.cpp\" />\r\n    <ClCompile Include=\"gamecontroller_db.cpp\" />\r\n    <ClCompile Include=\"hardware.cpp\" />\r\n    <ClCompile Include=\"ide.cpp\" />\r\n    <ClCompile Include=\"ide_cdrom.cpp\" />\r\n    <ClCompile Include=\"input.cpp\" />\r\n    <ClCompile Include=\"joymapping.cpp\" />\r\n    <ClCompile Include=\"lib\\libco\\arm.c\" />\r\n    <ClCompile Include=\"lib\\libco\\libco.c\" />\r\n    <ClCompile Include=\"lib\\lodepng\\lodepng.cpp\" />\r\n    <ClCompile Include=\"lib\\md5\\md5.c\" />\r\n    <ClCompile Include=\"lib\\miniz\\miniz.c\" />\r\n    <ClCompile Include=\"lib\\miniz\\miniz_tdef.c\" />\r\n    <ClCompile Include=\"lib\\miniz\\miniz_tinfl.c\" />\r\n    <ClCompile Include=\"lib\\miniz\\miniz_zip.c\" />\r\n    <ClCompile Include=\"main.cpp\" />\r\n    <ClCompile Include=\"menu.cpp\" />\r\n    <ClCompile Include=\"offload.cpp\" />\r\n    <ClCompile Include=\"osd.cpp\" />\r\n    <ClCompile Include=\"profiling.cpp\" />\r\n    <ClCompile Include=\"recent.cpp\" />\r\n    <ClCompile Include=\"scaler.cpp\" />\r\n    <ClCompile Include=\"scheduler.cpp\" />\r\n    <ClCompile Include=\"shmem.cpp\" />\r\n    <ClCompile Include=\"smbus.cpp\" />\r\n    <ClCompile Include=\"spi.cpp\" />\r\n    <ClCompile Include=\"str_util.cpp\" />\r\n    <ClCompile Include=\"support\\arcade\\buffer.cpp\" />\r\n    <ClCompile Include=\"support\\arcade\\mra_loader.cpp\" />\r\n    <ClCompile Include=\"support\\archie\\archie.cpp\" />\r\n    <ClCompile Include=\"support\\c64\\c64.cpp\" />\r\n    <ClCompile Include=\"support\\chd\\mister_chd.cpp\" />\r\n    <ClCompile Include=\"support\\megacd\\megacd.cpp\" />\r\n    <ClCompile Include=\"support\\megacd\\megacdd.cpp\" />\r\n    <ClCompile Include=\"support\\minimig\\minimig_boot.cpp\" />\r\n    <ClCompile Include=\"support\\minimig\\minimig_config.cpp\" />\r\n    <ClCompile Include=\"support\\minimig\\minimig_fdd.cpp\" />\r\n    <ClCompile Include=\"support\\minimig\\minimig_share.cpp\" />\r\n    <ClCompile Include=\"support\\n64\\n64.cpp\" />\r\n    <ClCompile Include=\"support\\n64\\n64_joy_emu.cpp\" />\r\n    <ClCompile Include=\"support\\neogeo\\neogeocd.cpp\" />\r\n    <ClCompile Include=\"support\\neogeo\\neogeo_loader.cpp\" />\r\n    <ClCompile Include=\"support\\pcecd\\pcecd.cpp\" />\r\n    <ClCompile Include=\"support\\pcecd\\pcecdd.cpp\" />\r\n    <ClCompile Include=\"support\\pcecd\\seektime.cpp\" />\r\n    <ClCompile Include=\"support\\psx\\psx.cpp\" />\r\n    <ClCompile Include=\"support\\saturn\\saturn.cpp\" />\r\n    <ClCompile Include=\"support\\saturn\\saturncdd.cpp\" />\r\n    <ClCompile Include=\"support\\sharpmz\\sharpmz.cpp\" />\r\n    <ClCompile Include=\"support\\snes\\snes.cpp\" />\r\n    <ClCompile Include=\"support\\st\\st_tos.cpp\" />\r\n    <ClCompile Include=\"support\\uef\\uef_reader.cpp\" />\r\n    <ClCompile Include=\"support\\x86\\x86.cpp\" />\r\n    <ClCompile Include=\"support\\x86\\x86_share.cpp\" />\r\n    <ClCompile Include=\"sxmlc.c\" />\r\n    <ClCompile Include=\"user_io.cpp\" />\r\n    <ClCompile Include=\"video.cpp\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"audio.h\" />\r\n    <ClInclude Include=\"battery.h\" />\r\n    <ClInclude Include=\"bootcore.h\" />\r\n    <ClInclude Include=\"brightness.h\" />\r\n    <ClInclude Include=\"cd.h\" />\r\n    <ClInclude Include=\"cfg.h\" />\r\n    <ClInclude Include=\"charrom.h\" />\r\n    <ClInclude Include=\"cheats.h\" />\r\n    <ClInclude Include=\"debug.h\" />\r\n    <ClInclude Include=\"DiskImage.h\" />\r\n    <ClInclude Include=\"file_io.h\" />\r\n    <ClInclude Include=\"fpga_base_addr_ac5.h\" />\r\n    <ClInclude Include=\"fpga_io.h\" />\r\n    <ClInclude Include=\"fpga_manager.h\" />\r\n    <ClInclude Include=\"fpga_nic301.h\" />\r\n    <ClInclude Include=\"fpga_reset_manager.h\" />\r\n    <ClInclude Include=\"fpga_system_manager.h\" />\r\n    <ClInclude Include=\"gamecontroller_db.h\" />\r\n    <ClInclude Include=\"hardware.h\" />\r\n    <ClInclude Include=\"ide.h\" />\r\n    <ClInclude Include=\"ide_cdrom.h\" />\r\n    <ClInclude Include=\"input.h\" />\r\n    <ClInclude Include=\"joymapping.h\" />\r\n    <ClInclude Include=\"mat4x4.h\" />\r\n    <ClInclude Include=\"lib\\imlib2\\Imlib2.h\" />\r\n    <ClInclude Include=\"lib\\libco\\libco.h\" />\r\n    <ClInclude Include=\"lib\\libco\\settings.h\" />\r\n    <ClInclude Include=\"lib\\lodepng\\lodepng.h\" />\r\n    <ClInclude Include=\"lib\\md5\\md5.h\" />\r\n    <ClInclude Include=\"lib\\miniz\\miniz.h\" />\r\n    <ClInclude Include=\"lib\\miniz\\miniz_common.h\" />\r\n    <ClInclude Include=\"lib\\miniz\\miniz_tdef.h\" />\r\n    <ClInclude Include=\"lib\\miniz\\miniz_tinfl.h\" />\r\n    <ClInclude Include=\"lib\\miniz\\miniz_zip.h\" />\r\n    <ClInclude Include=\"logo.h\" />\r\n    <ClInclude Include=\"menu.h\" />\r\n    <ClInclude Include=\"offload.h\" />\r\n    <ClInclude Include=\"osd.h\" />\r\n    <ClInclude Include=\"profiling.h\" />\r\n    <ClInclude Include=\"recent.h\" />\r\n    <ClInclude Include=\"scaler.h\" />\r\n    <ClInclude Include=\"scheduler.h\" />\r\n    <ClInclude Include=\"shmem.h\" />\r\n    <ClInclude Include=\"smbus.h\" />\r\n    <ClInclude Include=\"spi.h\" />\r\n    <ClInclude Include=\"str_util.h\" />\r\n    <ClInclude Include=\"support.h\" />\r\n    <ClInclude Include=\"support\\arcade\\buffer.h\" />\r\n    <ClInclude Include=\"support\\arcade\\mra_loader.h\" />\r\n    <ClInclude Include=\"support\\archie\\archie.h\" />\r\n    <ClInclude Include=\"support\\c64\\c64.h\" />\r\n    <ClInclude Include=\"support\\chd\\mister_chd.h\" />\r\n    <ClInclude Include=\"support\\megacd\\megacd.h\" />\r\n    <ClInclude Include=\"support\\minimig\\miminig_fs_messages.h\" />\r\n    <ClInclude Include=\"support\\minimig\\minimig_boot.h\" />\r\n    <ClInclude Include=\"support\\minimig\\minimig_config.h\" />\r\n    <ClInclude Include=\"support\\minimig\\minimig_fdd.h\" />\r\n    <ClInclude Include=\"support\\minimig\\minimig_hdd.h\" />\r\n    <ClInclude Include=\"support\\minimig\\minimig_share.h\" />\r\n    <ClInclude Include=\"support\\n64\\n64.h\" />\r\n    <ClInclude Include=\"support\\n64\\n64_cpak_header.h\" />\r\n    <ClInclude Include=\"support\\n64\\n64_joy_emu.h\" />\r\n    <ClInclude Include=\"support\\neogeo\\neogeocd.h\" />\r\n    <ClInclude Include=\"support\\neogeo\\neogeo_loader.h\" />\r\n    <ClInclude Include=\"support\\pcecd\\pcecd.h\" />\r\n    <ClInclude Include=\"support\\psx\\mcdheader.h\" />\r\n    <ClInclude Include=\"support\\psx\\psx.h\" />\r\n    <ClInclude Include=\"support\\saturn\\saturn.h\" />\r\n    <ClInclude Include=\"support\\sharpmz\\sharpmz.h\" />\r\n    <ClInclude Include=\"support\\snes\\snes.h\" />\r\n    <ClInclude Include=\"support\\st\\st_tos.h\" />\r\n    <ClInclude Include=\"support\\uef\\uef_reader.h\" />\r\n    <ClInclude Include=\"support\\uef\\zconf.h\" />\r\n    <ClInclude Include=\"support\\uef\\zlib.h\" />\r\n    <ClInclude Include=\"support\\x86\\x86.h\" />\r\n    <ClInclude Include=\"support\\x86\\x86_share.h\" />\r\n    <ClInclude Include=\"sxmlc.h\" />\r\n    <ClInclude Include=\"user_io.h\" />\r\n    <ClInclude Include=\"video.h\" />\r\n  </ItemGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\r\n  <ImportGroup Label=\"ExtensionTargets\">\r\n  </ImportGroup>\r\n</Project>\r\n"
        },
        {
          "name": "MiSTer.vcxproj.filters",
          "type": "blob",
          "size": 16.751953125,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup>\r\n    <Filter Include=\"Source Files\">\r\n      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>\r\n      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\">\r\n      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>\r\n      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\\libco\">\r\n      <UniqueIdentifier>{0c4bf53d-7986-4434-bbd2-734da3553be9}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Source Files\\libco\">\r\n      <UniqueIdentifier>{da657dc9-d7b4-417e-b916-6543cf17b67e}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\\miniz\">\r\n      <UniqueIdentifier>{344a14d0-22c5-4d62-a89a-7f3f1e005381}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Source Files\\miniz\">\r\n      <UniqueIdentifier>{83fcb534-f976-4615-bdeb-ba80fb510f9a}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\\md5\">\r\n      <UniqueIdentifier>{478f0e62-2042-41ff-8b48-b48e6b5aed88}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Source Files\\md5\">\r\n      <UniqueIdentifier>{30fe8838-348b-4aa5-b517-93cae495ce86}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\\support\">\r\n      <UniqueIdentifier>{e440dc55-22b0-40b2-887d-dfd701749ea0}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Source Files\\support\">\r\n      <UniqueIdentifier>{095305c7-e04b-4f03-b8d8-db2d888b449c}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\\imlib\">\r\n      <UniqueIdentifier>{a5ee9c49-ce79-4665-8a6e-751bd82eff23}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\\lodpng\">\r\n      <UniqueIdentifier>{f72c7b7a-09fd-4c2f-a8cb-14e1077e8acb}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Source Files\\lodepng\">\r\n      <UniqueIdentifier>{9e138a0b-53c4-4ae8-a59b-6b7bf2dcc01b}</UniqueIdentifier>\r\n    </Filter>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"build.sh\" />\r\n    <None Include=\"Makefile\" />\r\n    <None Include=\"clean.sh\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"battery.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"brightness.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"cfg.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"DiskImage.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"file_io.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"fpga_io.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"hardware.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"input.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"main.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"menu.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"osd.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"spi.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"sxmlc.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"user_io.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\libco\\arm.c\">\r\n      <Filter>Source Files\\libco</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\libco\\libco.c\">\r\n      <Filter>Source Files\\libco</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"scheduler.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\miniz\\miniz.c\">\r\n      <Filter>Source Files\\miniz</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\miniz\\miniz_tdef.c\">\r\n      <Filter>Source Files\\miniz</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\miniz\\miniz_tinfl.c\">\r\n      <Filter>Source Files\\miniz</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\miniz\\miniz_zip.c\">\r\n      <Filter>Source Files\\miniz</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"bootcore.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"charrom.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"cheats.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"scaler.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"video.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"joymapping.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\md5\\md5.c\">\r\n      <Filter>Source Files\\md5</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"lib\\lodepng\\lodepng.cpp\">\r\n      <Filter>Source Files\\lodepng</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\archie\\archie.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\megacd\\megacd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\minimig\\minimig_boot.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\minimig\\minimig_config.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\minimig\\minimig_fdd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\sharpmz\\sharpmz.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\snes\\snes.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\st\\st_tos.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\x86\\x86.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\arcade\\buffer.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"recent.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\c64\\c64.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\pcecd\\pcecd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\pcecd\\pcecdd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\megacd\\megacdd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\neogeo\\neogeo_loader.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\arcade\\mra_loader.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\pcecd\\seektime.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"audio.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\minimig\\minimig_share.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\x86\\x86_share.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"shmem.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ide.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"ide_cdrom.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\chd\\mister_chd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\psx\\psx.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\uef\\uef_reader.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"smbus.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"offload.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"profiling.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"str_util.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"gamecontroller_db.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n\t<ClCompile Include=\"support\\n64\\n64.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n\t<ClCompile Include=\"support\\n64\\n64_joy_emu.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\neogeo\\neogeocd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\saturn\\saturn.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"support\\saturn\\saturncdd.cpp\">\r\n      <Filter>Source Files\\support</Filter>\r\n    </ClCompile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"battery.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"brightness.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"cfg.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"charrom.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"debug.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"DiskImage.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"file_io.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"fpga_base_addr_ac5.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"fpga_io.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"fpga_manager.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"fpga_nic301.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"fpga_reset_manager.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"fpga_system_manager.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"hardware.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"input.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"logo.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"menu.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"osd.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"spi.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"sxmlc.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"user_io.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\libco\\libco.h\">\r\n      <Filter>Header Files\\libco</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\libco\\settings.h\">\r\n      <Filter>Header Files\\libco</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"scheduler.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\miniz\\miniz.h\">\r\n      <Filter>Header Files\\miniz</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\miniz\\miniz_common.h\">\r\n      <Filter>Header Files\\miniz</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\miniz\\miniz_tdef.h\">\r\n      <Filter>Header Files\\miniz</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\miniz\\miniz_tinfl.h\">\r\n      <Filter>Header Files\\miniz</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\miniz\\miniz_zip.h\">\r\n      <Filter>Header Files\\miniz</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"bootcore.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"cheats.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"scaler.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"video.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"joymapping.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\md5\\md5.h\">\r\n      <Filter>Header Files\\md5</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\archie\\archie.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\imlib2\\Imlib2.h\">\r\n      <Filter>Header Files\\imlib</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\st\\st_tos.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"lib\\lodepng\\lodepng.h\">\r\n      <Filter>Header Files\\lodpng</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\minimig\\minimig_boot.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\minimig\\minimig_config.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\minimig\\minimig_fdd.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\minimig\\minimig_hdd.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\x86\\x86.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\snes\\snes.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\sharpmz\\sharpmz.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\megacd\\megacd.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\arcade\\buffer.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"recent.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\c64\\c64.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"cd.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\pcecd\\pcecd.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\neogeo\\neogeo_loader.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\arcade\\mra_loader.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"audio.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\minimig\\minimig_share.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\minimig\\miminig_fs_messages.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\x86\\x86_share.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"shmem.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ide.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"ide_cdrom.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\chd\\mister_chd.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\psx\\psx.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\uef\\uef_reader.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\uef\\zlib.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\uef\\zconf.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\psx\\mcdheader.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"smbus.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"offload.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"profiling.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"str_util.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"gamecontroller_db.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n\t<ClInclude Include=\"support\\n64\\n64.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n\t<ClInclude Include=\"support\\n64\\n64_joy_emu.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\neogeo\\neogeocd.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"support\\saturn\\saturn.h\">\r\n      <Filter>Header Files\\support</Filter>\r\n    </ClInclude>\r\n  </ItemGroup>\r\n</Project>"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.380859375,
          "content": "# Main_MiSTer Main Binary and Wiki Repo\n\nThis repo serves as the home for the MiSTer Main binaries and the Wiki.\n\nFor the purposes of getting google to crawl the wiki, here's a link to the (not for humans) [crawlable wiki](https://github-wiki-see.page/m/MiSTer-devel/Wiki_MiSTer/wiki)\n\nIf you're a human looking for the wiki, that's [here](https://github.com/MiSTer-devel/Wiki_MiSTer/wiki)\n"
        },
        {
          "name": "audio.cpp",
          "type": "blob",
          "size": 5.6611328125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <linux/vt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"hardware.h\"\n#include \"user_io.h\"\n#include \"spi.h\"\n#include \"cfg.h\"\n#include \"file_io.h\"\n#include \"menu.h\"\n#include \"audio.h\"\n\nstatic uint8_t vol_att = 0;\nstatic uint8_t corevol_att = 0;\nunsigned long vol_set_timeout = 0;\nstatic int has_filter = 0;\n\nstatic char filter_cfg_path[1024] = {};\nstatic char filter_cfg[1024] = {};\n\nstatic void setFilter()\n{\n\tfileTYPE f = {};\n\n\thas_filter = spi_uio_cmd(UIO_SET_AFILTER);\n\tif (!has_filter) return;\n\n\tsnprintf(filter_cfg_path, sizeof(filter_cfg_path), AFILTER_DIR\"/%s\", filter_cfg + 1);\n\tif(filter_cfg[0]) printf(\"\\nLoading audio filter: %s\\n\", filter_cfg_path);\n\n\tif (filter_cfg[0] && FileExists(filter_cfg_path) && FileOpen(&f, filter_cfg_path))\n\t{\n\t\tchar *buf = (char*)malloc(f.size + 1);\n\t\tif (buf)\n\t\t{\n\t\t\tmemset(buf, 0, f.size + 1);\n\t\t\tint size;\n\t\t\tif ((size = FileReadAdv(&f, buf, f.size)))\n\t\t\t{\n\t\t\t\tint line = 0;\n\t\t\t\tspi_uio_cmd_cont(UIO_SET_AFILTER);\n\t\t\t\tspi_w((uint8_t)get_core_volume());\n\n\t\t\t\tchar *end = buf + size;\n\t\t\t\tchar *pos = buf;\n\t\t\t\twhile (pos < end && line < 9)\n\t\t\t\t{\n\t\t\t\t\tchar *st = pos;\n\t\t\t\t\twhile ((pos < end) && *pos && (*pos != 10)) pos++;\n\t\t\t\t\t*pos = 0;\n\t\t\t\t\twhile (*st == ' ' || *st == '\\t' || *st == 13) st++;\n\t\t\t\t\tif (*st == '#' || *st == ';' || !*st) pos++;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (line == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"version: %s\\n\", st);\n\t\t\t\t\t\t\tif (strncasecmp(st, \"v1\", 2)) break;\n\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (line == 1 || line == 3 || line == 4 || line == 5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint val = 0;\n\t\t\t\t\t\t\tint n = sscanf(st, \"%d\", &val);\n\t\t\t\t\t\t\tprintf(\"got %d values: %d\\n\", n, val);\n\t\t\t\t\t\t\tif (n == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tspi_w((uint16_t)val);\n\t\t\t\t\t\t\t\tif (line == 1) spi_w((uint16_t)(val >> 16));\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (line == 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble val = 0;\n\t\t\t\t\t\t\tint n = sscanf(st, \"%lg\", &val);\n\t\t\t\t\t\t\tprintf(\"got %d values: %g\\n\", n, val);\n\t\t\t\t\t\t\tif (n == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint64_t coeff = 0x8000000000 * val;\n\t\t\t\t\t\t\t\tprintf(\"  -> converted to: %lld\\n\", coeff);\n\t\t\t\t\t\t\t\tspi_w((uint16_t)coeff);\n\t\t\t\t\t\t\t\tspi_w((uint16_t)(coeff >> 16));\n\t\t\t\t\t\t\t\tspi_w((uint16_t)(coeff >> 32));\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble val = 0;\n\t\t\t\t\t\t\tint n = sscanf(st, \"%lg\", &val);\n\t\t\t\t\t\t\tprintf(\"got %d values: %g\\n\", n, val);\n\t\t\t\t\t\t\tif (n == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint32_t coeff = 0x200000 * val;\n\t\t\t\t\t\t\t\tprintf(\"  -> converted to: %d\\n\", coeff);\n\t\t\t\t\t\t\t\tspi_w((uint16_t)coeff);\n\t\t\t\t\t\t\t\tspi_w((uint16_t)(coeff >> 16));\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDisableIO();\n\t\t\t}\n\t\t\tfree(buf);\n\t\t}\n\t}\n\telse\n\t{\n\t\tspi_uio_cmd8(UIO_SET_AFILTER, (uint8_t)get_core_volume());\n\t}\n}\n\nvoid send_volume()\n{\n\tint vol = get_volume();\n\tget_core_volume();\n\n\tif (!has_filter)\n\t{\n\t\tif (!(vol_att & 0x10) && vol_att + corevol_att > 7) vol_att = 7 - corevol_att;\n\t\tvol = vol_att + corevol_att;\n\t}\n\tspi_uio_cmd8(UIO_AUDVOL, vol);\n}\n\nint get_volume()\n{\n\treturn vol_att & 0x17;\n}\n\nint get_core_volume()\n{\n\tcorevol_att &= 7;\n\tif (corevol_att > 6) corevol_att = 6;\n\treturn corevol_att;\n}\n\nvoid set_volume(int cmd)\n{\n\tvol_set_timeout = GetTimer(1000);\n\n\tvol_att &= 0x17;\n\tif ((cmd & 0xC0) == 0x80) vol_att = (vol_att & 0x7) | ((cmd & 1) << 4);\n\telse if ((cmd & 0xC0) == 0x40) vol_att = (vol_att & 0x10) | (~cmd & 7);\n\telse if (!cmd) vol_att ^= 0x10;\n\telse if (vol_att & 0x10) vol_att &= 0xF;\n\telse if (cmd < 0 && vol_att < 7) vol_att += 1;\n\telse if (cmd > 0 && vol_att > 0) vol_att -= 1;\n\n\tsend_volume();\n\n\tif (vol_att & 0x10)\n\t{\n\t\tInfo(\"\\x8d Mute\", 1000);\n\t}\n\telse\n\t{\n\t\tchar str[32];\n\t\tmemset(str, 0, sizeof(str));\n\n\t\tsprintf(str, \"\\x8d \");\n\t\tchar *bar = str + strlen(str);\n\n\t\tint vol = (audio_filter_en() < 0) ? get_core_volume() : 0;\n\t\tmemset(bar, 0x8C, 8 - vol);\n\t\tmemset(bar, 0x7f, 8 - vol - vol_att);\n\t\tInfo(str, 1000);\n\t}\n}\n\nvoid set_core_volume(int cmd)\n{\n\tvol_set_timeout = GetTimer(1000);\n\n\tcorevol_att &= 7;\n\tif (cmd < 0 && corevol_att < 6) corevol_att += 1;\n\tif (cmd > 0 && corevol_att > 0) corevol_att -= 1;\n\n\tif (has_filter) setFilter();\n\telse send_volume();\n}\n\nvoid save_volume()\n{\n\tif (vol_set_timeout && CheckTimer(vol_set_timeout))\n\t{\n\t\tvol_set_timeout = 0;\n\t\tFileSaveConfig(\"Volume.dat\", &vol_att, 1);\n\n\t\tstatic char cfg_name[128];\n\t\tsprintf(cfg_name, \"%s_volume.cfg\", user_io_get_core_name());\n\t\tFileSaveConfig(cfg_name, &corevol_att, 1);\n\t}\n}\n\nvoid load_volume()\n{\n\tsprintf(filter_cfg_path, \"%s_afilter.cfg\", user_io_get_core_name());\n\tif (!FileLoadConfig(filter_cfg_path, &filter_cfg, sizeof(filter_cfg) - 1) || filter_cfg[0] > 1)\n\t{\n\t\tmemset(filter_cfg, 0, sizeof(filter_cfg));\n\t\tif (cfg.afilter_default[0])\n\t\t{\n\t\t\tstrcpy(filter_cfg + 1, cfg.afilter_default);\n\t\t\tfilter_cfg[0] = 1;\n\t\t}\n\t}\n\n\tFileLoadConfig(\"Volume.dat\", &vol_att, 1);\n\tif (!is_menu())\n\t{\n\t\tstatic char cfg_name[128];\n\t\tsprintf(cfg_name, \"%s_volume.cfg\", user_io_get_core_name());\n\t\tFileLoadConfig(cfg_name, &corevol_att, 1);\n\t}\n\n\tget_volume();\n\tget_core_volume();\n\n\tsetFilter();\n\tsend_volume();\n}\n\nint audio_filter_en()\n{\n\treturn has_filter ? filter_cfg[0] : -1;\n}\n\nchar* audio_get_filter(int only_name)\n{\n\tchar *path = filter_cfg + 1;\n\tif (only_name)\n\t{\n\t\tchar *p = strrchr(path, '/');\n\t\tif (p) return p + 1;\n\t}\n\treturn path;\n\n}\n\nvoid audio_set_filter(const char *name)\n{\n\tstrcpy(filter_cfg + 1, name);\n\tsprintf(filter_cfg_path, \"%s_afilter.cfg\", user_io_get_core_name());\n\tFileSaveConfig(filter_cfg_path, &filter_cfg, sizeof(filter_cfg));\n\tsetFilter();\n}\n\nvoid audio_set_filter_en(int n)\n{\n\tfilter_cfg[0] = n ? 1 : 0;\n\tsprintf(filter_cfg_path, \"%s_afilter.cfg\", user_io_get_core_name());\n\tFileSaveConfig(filter_cfg_path, &filter_cfg, sizeof(filter_cfg));\n\tsetFilter();\n}\n"
        },
        {
          "name": "audio.h",
          "type": "blob",
          "size": 0.330078125,
          "content": "#ifndef AUDIO_H\n#define AUDIO_H\n\nvoid set_volume(int cmd);\nint  get_volume();\nint  get_core_volume();\nvoid set_core_volume(int cmd);\nvoid send_volume();\nvoid save_volume();\nvoid load_volume();\n\nint audio_filter_en();\nchar* audio_get_filter(int only_name);\nvoid audio_set_filter(const char *name);\nvoid audio_set_filter_en(int n);\n\n#endif\n"
        },
        {
          "name": "battery.cpp",
          "type": "blob",
          "size": 2.197265625,
          "content": "/*\n\n * battery.c\n * display pi-top battery status\n *\n * Copyright 2016, 2017  rricharz\n * MiSTer port. Copyright 2018 Sorgelig\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n\n#include <time.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <linux/types.h>\n#include \"smbus.h\"\n#include \"battery.h\"\n\n#define MAX_COUNT       20                     // Maximum number of trials\n#define SLEEP_TIME      500                    // time between two i2cget in microsec\n\nstatic int i2c_handle = -1;\n\nstatic int getReg(int reg, int min, int max)\n{\n\tint count = 0;\n\tshort value = -1;\n\twhile ((value == -1) && (count++ < MAX_COUNT))\n\t{\n\t\tvalue = i2c_smbus_read_word_data(i2c_handle, reg);\n\t\tif (value >= 0)\n\t\t{\n\t\t\tif ((value > max) || (value < min)) value = -1; // out of limits\n\t\t}\n\t\tusleep(SLEEP_TIME);\n\t}\n\n\treturn value;\n}\n\nint getBattery(int quick, struct battery_data_t *data)\n{\n\t// don't try to check if no battery device is present\n\tif (i2c_handle == -2) return 0;\n\n\ti2c_handle = i2c_open(0x0B, 1);\n\tif (i2c_handle < 0)\n\t{\n\t\tprintf(\"No battery found.\\n\");\n\t\ti2c_handle = -2;\n\t\treturn 0;\n\t}\n\n\tdata->capacity = getReg(0x0D, 0, 100);\n\tdata->load_current = getReg(0x0A, -5000, 5000);\n\tif (quick) return 1;\n\n\tdata->time = 0;\n\tif (data->load_current > 0)  data->time = getReg(0x13, 1, 999);\n\tif (data->load_current < -1) data->time = getReg(0x12, 1, 960);\n\n\tdata->current = getReg(0x0F, 0, 5000);\n\tdata->voltage = getReg(0x09, 5000, 20000);\n\n\treturn 1;\n}\n"
        },
        {
          "name": "battery.h",
          "type": "blob",
          "size": 0.23046875,
          "content": "#ifndef __BATTERY_H__\n#define __BATTERY_H__\n\nstruct battery_data_t\n{\n\tshort load_current;\n\tshort capacity;\n\tshort current;\n\tshort time;\n\tshort voltage;\n\tshort cell[4];\n};\n\nint getBattery(int quick, struct battery_data_t *data);\n\n#endif\n"
        },
        {
          "name": "bootcore.cpp",
          "type": "blob",
          "size": 4.3564453125,
          "content": "// bootcore.cpp\n// 2024, Aitor Gomez Garcia (info@aitorgomez.net)\n// Thanks to Sorgelig and BBond007 for their help and advice in the development of this feature.\n\n#include \"file_io.h\"\n#include \"cfg.h\"\n#include \"fpga_io.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dirent.h>\n\n\nextern int xml_load(const char *xml);\nint16_t btimeout;\nchar bootcoretype[64];\n\nbool isExactcoreName(char *path)\n{\n\tchar *spl = strrchr(path, '.');\n\treturn (spl && (!strcmp(spl, \".rbf\") || !strcmp(spl, \".mra\") || !strcmp(spl, \".mgl\")));\n}\n\nchar *getcoreName(char *path)\n{\n\tchar *spl = strrchr(path, '.');\n\tif (spl && !strcmp(spl, \".rbf\"))\n\t{\n\t\t*spl = '\\0';\n\t}\n\telse\n\t{\n\t\treturn NULL;\n\t}\n\tif ((spl = strrchr(path, '/')) != NULL)\n\t{\n\t\tpath = spl + 1;\n\t}\n\tif ((spl = strrchr(path, '_')) != NULL)\n\t{\n\t\t*spl = 0;\n\t}\n\n\treturn path;\n}\n\nchar *getcoreExactName(char *path)\n{\n\tchar *spl;\n\tif ((spl = strrchr(path, '/')) != NULL)\n\t{\n\t\tpath = spl + 1;\n\t}\n\n\treturn path;\n}\n\nchar *replaceStr(const char *str, const char *oldstr, const char *newstr)\n{\n\tchar *result;\n\tint i, cnt = 0;\n\tint newstrlen = strlen(newstr);\n\tint oldstrlen = strlen(oldstr);\n\n\tfor (i = 0; str[i] != '\\0'; i++)\n\t{\n\t\tif (strstr(&str[i], oldstr) == &str[i])\n\t\t{\n\t\t\tcnt++;\n\t\t\ti += oldstrlen - 1;\n\t\t}\n\t}\n\n\tresult = new char[i + cnt * (newstrlen - oldstrlen) + 1];\n\n\ti = 0;\n\twhile (*str)\n\t{\n\t\tif (strstr(str, oldstr) == str)\n\t\t{\n\t\t\tstrcpy(&result[i], newstr);\n\t\t\ti += newstrlen;\n\t\t\tstr += oldstrlen;\n\t\t}\n\t\telse\n\t\t\tresult[i++] = *str++;\n\t}\n\n\tresult[i] = '\\0';\n\treturn result;\n}\n\nchar* loadLastcore()\n{\n\tchar full_path[2100];\n\tchar path[256] = { CONFIG_DIR\"/\" };\n\tstrcat(path, \"lastcore.dat\");\n\tsprintf(full_path, \"%s/%s\", getRootDir(), path);\n\tFILE *fd = fopen(full_path, \"r\");\n\tif (!fd)\n\t{\n\t\treturn NULL;\n\t}\n\tfseek(fd, 0L, SEEK_END);\n\tlong size = ftell(fd);\n\n\tfseek(fd, 0L, SEEK_SET);\n\tchar *lastcore = new char[size + 1]();\n\tint ret = fread(lastcore, sizeof(char), size, fd);\n\tfclose(fd);\n\tif (ret == size)\n\t{\n\t\treturn lastcore;\n\t}\n\tdelete[] lastcore;\n\treturn NULL;\n\n}\n\nchar *findCore(const char *name, char *coreName, int indent)\n{\n\tchar *spl;\n\tDIR *dir;\n\tstruct dirent *entry;\n\n\tif (!(dir = opendir(name)))\n\t{\n\t\treturn NULL;\n\t}\n\n\n\tchar *indir;\n\tchar* path = new char[256];\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif (entry->d_type == DT_DIR) {\n\t\t\tif (entry->d_name[0] != '_')\n\t\t\t\tcontinue;\n\t\t\tsnprintf(path, 256, \"%s/%s\", name, entry->d_name);\n\t\t\tindir = findCore(path, coreName, indent + 2);\n\t\t\tif (indir != NULL)\n\t\t\t{\n\t\t\t\tclosedir(dir);\n\t\t\t\tdelete[] path;\n\t\t\t\treturn indir;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsnprintf(path, 256, \"%s/%s\", name, entry->d_name);\n\t\t\tif (strstr(path, coreName) != NULL) {\n\t\t\t\tspl = strrchr(path, '.');\n\t\t\t\tif (spl && (!strcmp(spl, \".rbf\") || !strcmp(spl, \".mra\") || !strcmp(spl, \".mgl\")))\n\t\t\t\t{\n\t\t\t\t\tclosedir(dir);\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(dir);\n\tdelete[] path;\n\treturn NULL;\n}\n\nvoid bootcore_init(const char *path)\n{\n\tchar *auxpointer;\n\tchar auxstr[256];\n\tchar bootcore[256];\n\tbool is_lastcore;\n\tconst char *rootdir = getRootDir();\n\tcfg.bootcore_timeout = cfg.bootcore_timeout * 10;\n\tbtimeout = cfg.bootcore_timeout;\n\tstrcpy(bootcore, cfg.bootcore);\n\n\tis_lastcore = (!strcmp(cfg.bootcore, \"lastcore\") || !strcmp(cfg.bootcore, \"lastexactcore\"));\n\n\tif (is_lastcore)\n\t{\n\t\tstrcpy(bootcoretype, cfg.bootcore);\n\t\tauxpointer = loadLastcore();\n\t\tif (auxpointer != NULL)\n\t\t{\n\t\t\tstrcpy(bootcore, auxpointer);\n\t\t\tdelete[] auxpointer;\n\t\t}\n\t}\n\telse\n\t{\n\t\tstrcpy(bootcoretype, isExactcoreName(cfg.bootcore) ? \"exactcorename\" : \"corename\");\n\t}\n\n\tauxpointer = findCore(rootdir, bootcore, 0);\n\tif (auxpointer != NULL)\n\t{\n\t\tstrcpy(bootcore, auxpointer);\n\t\tdelete[] auxpointer;\n\n\t\tsprintf(auxstr, \"%s/\", rootdir);\n\t\tauxpointer = replaceStr(bootcore, auxstr, \"\");\n\t\tif (auxpointer != NULL)\n\t\t{\n\t\t\tstrcpy(bootcore, auxpointer);\n\t\t\tdelete[] auxpointer;\n\n\t\t\tif (path[0] == '\\0')\n\t\t\t{\n\t\t\t\tif (!cfg.bootcore_timeout)\n\t\t\t\t{\n\t\t\t\t\tisXmlName(bootcore) ? xml_load(bootcore) : fpga_load_rbf(bootcore);\n\t\t\t\t}\n\n\t\t\t\tstrcpy(cfg.bootcore, strcmp(bootcore, \"menu.rbf\") ? bootcore : \"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_lastcore && path[0] != '\\0')\n\t{\n\n\t\tstrcpy(auxstr, path);\n\t\tauxpointer = (!strcmp(cfg.bootcore, \"lastexactcore\") || isXmlName(auxstr)) ? getcoreExactName(auxstr) : getcoreName(auxstr);\n\n\t\tif (auxpointer != NULL)\n\t\t{\n\t\t\tif (strcmp(bootcore, auxpointer))\n\t\t\t{\n\t\t\t\tFileSaveConfig(\"lastcore.dat\", (char*)auxpointer, strlen(auxpointer));\n\t\t\t}\n\t\t}\n\t}\n\tstrcpy(cfg.bootcore, \"\");\n\n}\n\n"
        },
        {
          "name": "bootcore.h",
          "type": "blob",
          "size": 0.5419921875,
          "content": "// bootcore.h\n// 2024, Aitor Gomez Garcia (info@aitorgomez.net)\n// Thanks to Sorgelig and BBond007 for their help and advice in the development of this feature.\n\n#ifndef __BOOTCORE_H__\n#define __BOOTCORE_H__\n\nchar *getcoreName(char *path);\nchar *getcoreExactName(char *path);\nchar *replaceStr(const char *str, const char *oldstr, const char *newstr);\nchar *loadLastcore();\nchar *findCore(const char *name, char *coreName, int indent);\nvoid bootcore_init(const char *path);\n\nextern char bootcoretype[64];\nextern int16_t btimeout;\n\n#endif // __BOOTCORE_H__\n"
        },
        {
          "name": "brightness.cpp",
          "type": "blob",
          "size": 5.69140625,
          "content": "/*\n * brightness.c\n *\n * Copyright 2016  rricharz\n * MiSTer port. Copyright 2018 Sorgelig\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n * MA 02110-1301, USA.\n *\n *\n */\n\n#include <stdint.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n#include \"brightness.h\"\n\n#define MAXCOUNT 10\t\t// maximum number of spi transfer attemps\n\n#define LIDBITMASK\t\t0x04\n#define\tSCREENOFFMASK\t0x02\n#define PARITYMASK\t\t0x80\n#define BRIGHTNESSMASK  0x78\n#define SHUTDOWNMASK\t0X01\n\n///////////////////////////////////////////////////\n\nstatic uint32_t    spiSpeed;\nstatic int         spiFd = -1;\n\nstatic const uint8_t  spiBPW   = 8;\nstatic const uint16_t spiDelay = 0;\n\nstatic int spi_rw(unsigned char *data, int len)\n{\n\tstruct spi_ioc_transfer spi;\n\n\tmemset (&spi, 0, sizeof (spi));\n\n\tspi.tx_buf        = (unsigned long)data;\n\tspi.rx_buf        = (unsigned long)data;\n\tspi.len           = len;\n\tspi.delay_usecs   = spiDelay;\n\tspi.speed_hz      = spiSpeed;\n\tspi.bits_per_word = spiBPW;\n\n\treturn ioctl (spiFd, SPI_IOC_MESSAGE(1), &spi);\n}\n\nstatic int spi_open(int speed, int mode)\n{\n\tint fd ;\n\tmode &= 3;\t// Mode is 0, 1, 2 or 3\n\n\tif ((fd = open(\"/dev/spidev1.0\", O_RDWR | O_CLOEXEC)) < 0)\n\t{\n\t\tprintf(\"Unable to open SPI device: %s\\n\", strerror (errno));\n\t\treturn -1;\n\t}\n\n\tif (ioctl (fd, SPI_IOC_WR_MODE, &mode) >= 0)\n\t{\n\t\tif (ioctl (fd, SPI_IOC_WR_BITS_PER_WORD, &spiBPW) >= 0)\n\t\t{\n\t\t\tif (ioctl (fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed) >= 0)\n\t\t\t{\n\t\t\t\tspiSpeed = speed;\n\t\t\t\tspiFd    = fd;\n\t\t\t\treturn fd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf (\"SPI Speed Change failure: %s\\n\", strerror (errno));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf (\"SPI BPW Change failure: %s\\n\", strerror (errno));\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf (\"SPI Mode Change failure: %s\\n\", strerror (errno));\n\t}\n\n\tclose(fd);\n\tfd = -1;\n\treturn -1;\n}\n\nstatic void spi_close()\n{\n\tif(spiFd >= 0) close(spiFd);\n\tspiFd = -1;\n}\n\n///////////////////////////////////////////////////\n\nstatic int lidbit;\nstatic int screenoffbit;\nstatic int parity;\nstatic int brightness = 6;\nstatic int shutdown;\n\n//////////////////////////////\n// Calclate the parity of bits 0 - 6\nstatic int parity7(unsigned char data)\n{\n\tint i;\n\tint p = 0;\n\tfor (i = 0; i < 7; i++) {\n\t\tif (data & 1) p = !p;\n\t\tdata = data >> 1;\n\t}\n\treturn p;\n}\n\n///////////////////////////////\n// analyze data byte and set global variables\n// return 1 of parity is ok\n// Sending: bit 8 = parity of bit 1-7\nstatic int analyze(unsigned char data)\n{\n\tlidbit\t\t\t= (data & LIDBITMASK) != 0;\n\tscreenoffbit\t= (data & SCREENOFFMASK) != 0;\n\tparity\t\t\t= (data & PARITYMASK) != 0;\n\tbrightness\t\t= (data & BRIGHTNESSMASK) >> 3;\n\tshutdown\t\t= (data & SHUTDOWNMASK) != 0;\n\n\t// printf(\"lid = %d, screen = %d, parity = %d, shutdown = %d, brightness = %d\\n\", lidbit, screenoffbit, parity, shutdown, brightness);\n\n\treturn (parity7(data) == parity);\n}\n\n///////////////\n// Calculate data byte using global variables\n// Set brightness and status parity bits\n// Receiving: bit 8 = brightness parity, bit 3 = status parity\nstatic int calculate()\n{\n\tint data = brightness << 3;\n\tif (parity7(brightness)) data += PARITYMASK;\n\tif (shutdown) data += SHUTDOWNMASK;\n\tif (screenoffbit) data += SCREENOFFMASK;\n\tif (parity7(data & 3)) data += LIDBITMASK;\t\t// parity ofthe two state bits\n\treturn data;\n}\n\nvoid setBrightness(int cmd, int val)\n{\n\tunsigned char data, new_data;\n\tint count, ok;\n\n\tif (spi_open(9600, 0) < 0)\n\t{\n\t\tprintf(\"Cannot initialize spi driver\\n\");\n\t\treturn;\n\t}\n\n\t// send 0xFF and receive current status of pi-top-hub\n\tcount = 0;\n\tdata = 0xff;\n\tprintf(\"Brighntess sending: 0x%X\\n\", data);\n\tdo\n\t{\n\t\tdata = 0xff;\n\t\tok = spi_rw(&data, 1);\n\t\tif (ok) ok = analyze(data);\n\t}\n\twhile ((!ok) && (count++ < MAXCOUNT));\n\t// printf(\"count = %d\\n\", count);\n\n\tif (ok)\n\t{\n\t\tprintf(\"Brighntess receiving: 0x%X - \", data);\n\t\tprintf(\"Current brightness = %d, \", brightness);\n\t\t//force to 0 as set to 1 if rebooted while in screenbitoff=0\n\t\t//the state is stored on pi-top-hub, but isn't reinitialised on reboot\n\t\tscreenoffbit=0;\n\t\tif(cmd == BRIGHTNESS_UP)\n\t\t{\n\t\t\tbrightness++;\n\t\t}\n\t\telse if (cmd == BRIGHTNESS_DOWN)\n\t\t{\n\t\t\tbrightness--;\n\t\t}\n\t\telse if (cmd == BRIGHTNESS_SET)\n\t\t{\n\t\t\tif(!val) screenoffbit=1;\n\t\t\telse screenoffbit = 0;\n\t\t\tbrightness = val;\n\t\t}\n\n\t\tif (brightness < 1) brightness = 1;\n\t\tif (brightness > 10) brightness = 10;\n\n\t\tprintf(\"Requested brightness = %d, \", brightness);\n        printf(\"Requested off = %d\\n\", screenoffbit);\n\n\t\t// calculate data to send\n\t\tshutdown = 0;\n\t\tnew_data = calculate();\n\n\t\t// send new data until accepted\n\t\tcount = 0;\n\t\tdata = new_data;\n\t\tprintf(\"Brighntess sending: 0x%X\\n\", data);\n\t\tdo\n\t\t{\n\t\t\tdata = new_data;\n\t\t\tok = spi_rw(&data, 1);\n\t\t\tif (ok) ok = (data & BRIGHTNESSMASK) == (new_data & BRIGHTNESSMASK);\n\t\t}\n\t\twhile ((!ok) && (count++ < MAXCOUNT));\n\n\t\t// printf(\"count = %d\\n\", count);\n\t\tif (ok)\n\t\t{\n\t\t\tprintf(\"Brighntess receiving: 0x%X - \", data);\n\t\t\tprintf(\"New brightness = %d\\n\", brightness);\n\t\t}\n\t}\n\telse printf(\"Reading current brightness not successful\\n\");\n\n\tspi_close();\n}\n\nint getBrightness()\n{\n\tif (screenoffbit) return 0;\n\treturn brightness;\n}\n"
        },
        {
          "name": "brightness.h",
          "type": "blob",
          "size": 0.1923828125,
          "content": "#ifndef __BRIGHTNESS_H__\n#define __BRIGHTNESS_H__\n\n#define BRIGHTNESS_SET  0\n#define BRIGHTNESS_UP   1\n#define BRIGHTNESS_DOWN 2\n\nvoid setBrightness(int cmd, int val);\nint getBrightness();\n\n#endif\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.5478515625,
          "content": "#!/bin/bash\n\n# create simple text file named 'host' in this folder with IP address of your MiSTer.\n\nHOST=192.168.1.75\n[ -f host ] && HOST=$(cat host)\n\n# make script fail if any command failed,\n# so we don't need to check the exit status of every command.\nset -e\nset -o pipefail\n\necho \"Start building...\"\nmake\n\nset +e\necho y|plink root@$HOST -pw 1 'killall MiSTer'\n\nset -e\nftp -n <<EOF\nopen $HOST\nuser root 1\npassive\nbinary\nput MiSTer /media/fat/MiSTer\nEOF\n\nplink root@$HOST -pw 1 -batch 'sync;PATH=/media/fat:$PATH;MiSTer >/dev/ttyS0 2>/dev/ttyS0 </dev/null &'\n"
        },
        {
          "name": "cd.h",
          "type": "blob",
          "size": 1.05078125,
          "content": "#ifndef CD_H\n#define CD_H\n\n#include <libchdr/chd.h>\n#include \"file_io.h\"\n\n\ntypedef enum\n{\n        SUBCODE_NONE = 0, SUBCODE_RW, SUBCODE_RW_RAW\n} cd_subcode_types_t;\n\ntypedef struct\n{\n\tfileTYPE f;\n\tint offset;\n\tint pregap;\n\tint start;\n\tint end;\n\tint type;\n\tint sector_size;\n\tint indexes[100];\n\tint index_num;\n\tcd_subcode_types_t sbc_type;\n} cd_track_t;\n\ntypedef struct\n{\n\tint end;\n\tint last;\n\tint sectorSize;\n\tchd_file *chd_f;\n\tint chd_hunksize;\n\tcd_track_t tracks[100];\n\tfileTYPE sub;\n\n\tint GetTrackByLBA(int lba)\n\t{\n\t\tint i = 0;\n\t\twhile ((this->tracks[i].end <= lba) && (i < this->last)) i++;\n\t\treturn i;\n\t}\n\n\tint GetIndexByLBA(int track, int lba)\n\t{\n\t\tif (lba - this->tracks[track].start < 0) \n\t\t\treturn 0;\n\n\t\tint i = 2;\n\t\twhile ((lba - this->tracks[track].start >= this->tracks[track].indexes[i]) && (i < this->tracks[track].index_num)) i++;\n\t\ti--;\n\t\treturn i;\n\t}\n} toc_t;\n\ntypedef struct\n{\n\tuint8_t m;\n\tuint8_t s;\n\tuint8_t f;\n} msf_t;\n\n#define BCD(v)\t\t\t\t ((uint8_t)((((v)/10) << 4) | ((v)%10)))\n\ntypedef int (*SendDataFunc) (uint8_t* buf, int len, uint8_t index);\n\n#endif\n"
        },
        {
          "name": "cfg.cpp",
          "type": "blob",
          "size": 22.8876953125,
          "content": "// cfg.c\n// 2015, rok.krajnc@gmail.com\n// 2017+, Sorgelig\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <inttypes.h>\n#include <ctype.h>\n#include \"cfg.h\"\n#include \"debug.h\"\n#include \"file_io.h\"\n#include \"user_io.h\"\n#include \"video.h\"\n#include \"support/arcade/mra_loader.h\"\n\ncfg_t cfg;\nstatic FILE *orig_stdout = NULL;\nstatic FILE *dev_null = NULL;\n\ntypedef enum\n{\n\tUINT8 = 0, INT8, UINT16, INT16, UINT32, INT32, HEX8, HEX16, HEX32, FLOAT, STRING, UINT32ARR, HEX32ARR, STRINGARR\n} ini_vartypes_t;\n\ntypedef struct\n{\n\tconst char* name;\n\tvoid* var;\n\tini_vartypes_t type;\n\tint64_t min;\n\tint64_t max;\n} ini_var_t;\n\nstatic const ini_var_t ini_vars[] =\n{\n\t{ \"YPBPR\", (void*)(&(cfg.vga_mode_int)), UINT8, 0, 1 },\n\t{ \"COMPOSITE_SYNC\", (void*)(&(cfg.csync)), UINT8, 0, 1 },\n\t{ \"FORCED_SCANDOUBLER\", (void*)(&(cfg.forced_scandoubler)), UINT8, 0, 1 },\n\t{ \"VGA_SCALER\", (void*)(&(cfg.vga_scaler)), UINT8, 0, 1 },\n\t{ \"VGA_SOG\", (void*)(&(cfg.vga_sog)), UINT8, 0, 1 },\n\t{ \"KEYRAH_MODE\", (void*)(&(cfg.keyrah_mode)), HEX32, 0, 0xFFFFFFFF },\n\t{ \"RESET_COMBO\", (void*)(&(cfg.reset_combo)), UINT8, 0, 3 },\n\t{ \"KEY_MENU_AS_RGUI\", (void*)(&(cfg.key_menu_as_rgui)), UINT8, 0, 1 },\n\t{ \"VIDEO_MODE\", (void*)(cfg.video_conf), STRING, 0, sizeof(cfg.video_conf) - 1 },\n\t{ \"VIDEO_MODE_PAL\", (void*)(cfg.video_conf_pal), STRING, 0, sizeof(cfg.video_conf_pal) - 1 },\n\t{ \"VIDEO_MODE_NTSC\", (void*)(cfg.video_conf_ntsc), STRING, 0, sizeof(cfg.video_conf_ntsc) - 1 },\n\t{ \"VIDEO_INFO\", (void*)(&(cfg.video_info)), UINT8, 0, 10 },\n\t{ \"VSYNC_ADJUST\", (void*)(&(cfg.vsync_adjust)), UINT8, 0, 2 },\n\t{ \"HDMI_AUDIO_96K\", (void*)(&(cfg.hdmi_audio_96k)), UINT8, 0, 1 },\n\t{ \"DVI_MODE\", (void*)(&(cfg.dvi_mode)), UINT8, 0, 1 },\n\t{ \"HDMI_LIMITED\", (void*)(&(cfg.hdmi_limited)), UINT8, 0, 2 },\n\t{ \"KBD_NOMOUSE\", (void*)(&(cfg.kbd_nomouse)), UINT8, 0, 1 },\n\t{ \"MOUSE_THROTTLE\", (void*)(&(cfg.mouse_throttle)), UINT8, 1, 100 },\n\t{ \"BOOTSCREEN\", (void*)(&(cfg.bootscreen)), UINT8, 0, 1 },\n\t{ \"VSCALE_MODE\", (void*)(&(cfg.vscale_mode)), UINT8, 0, 5 },\n\t{ \"VSCALE_BORDER\", (void*)(&(cfg.vscale_border)), UINT16, 0, 399 },\n\t{ \"RBF_HIDE_DATECODE\", (void*)(&(cfg.rbf_hide_datecode)), UINT8, 0, 1 },\n\t{ \"MENU_PAL\", (void*)(&(cfg.menu_pal)), UINT8, 0, 1 },\n\t{ \"BOOTCORE\", (void*)(&(cfg.bootcore)), STRING, 0, sizeof(cfg.bootcore) - 1 },\n\t{ \"BOOTCORE_TIMEOUT\", (void*)(&(cfg.bootcore_timeout)), INT16, 2, 30 },\n\t{ \"FONT\", (void*)(&(cfg.font)), STRING, 0, sizeof(cfg.font) - 1 },\n\t{ \"FB_SIZE\", (void*)(&(cfg.fb_size)), UINT8, 0, 4 },\n\t{ \"FB_TERMINAL\", (void*)(&(cfg.fb_terminal)), UINT8, 0, 1 },\n\t{ \"OSD_TIMEOUT\", (void*)(&(cfg.osd_timeout)), INT16, 0, 3600 },\n\t{ \"DIRECT_VIDEO\", (void*)(&(cfg.direct_video)), UINT8, 0, 1 },\n\t{ \"OSD_ROTATE\", (void*)(&(cfg.osd_rotate)), UINT8, 0, 2 },\n\t{ \"DEADZONE\", (void*)(&(cfg.controller_deadzone)), STRINGARR, sizeof(cfg.controller_deadzone) / sizeof(*cfg.controller_deadzone), sizeof(*cfg.controller_deadzone) },\n\t{ \"GAMEPAD_DEFAULTS\", (void*)(&(cfg.gamepad_defaults)), UINT8, 0, 1 },\n\t{ \"RECENTS\", (void*)(&(cfg.recents)), UINT8, 0, 1 },\n\t{ \"CONTROLLER_INFO\", (void*)(&(cfg.controller_info)), UINT8, 0, 10 },\n\t{ \"REFRESH_MIN\", (void*)(&(cfg.refresh_min)), FLOAT, 0, 150 },\n\t{ \"REFRESH_MAX\", (void*)(&(cfg.refresh_max)), FLOAT, 0, 150 },\n\t{ \"JAMMA_VID\", (void*)(&(cfg.jamma_vid)), HEX16, 0, 0xFFFF },\n\t{ \"JAMMA_PID\", (void*)(&(cfg.jamma_pid)), HEX16, 0, 0xFFFF },\n\t{ \"JAMMA2_VID\", (void*)(&(cfg.jamma2_vid)), HEX16, 0, 0xFFFF },\n\t{ \"JAMMA2_PID\", (void*)(&(cfg.jamma2_pid)), HEX16, 0, 0xFFFF },\n\t{ \"SNIPER_MODE\", (void*)(&(cfg.sniper_mode)), UINT8, 0, 1 },\n\t{ \"BROWSE_EXPAND\", (void*)(&(cfg.browse_expand)), UINT8, 0, 1 },\n\t{ \"LOGO\", (void*)(&(cfg.logo)), UINT8, 0, 1 },\n\t{ \"SHARED_FOLDER\", (void*)(&(cfg.shared_folder)), STRING, 0, sizeof(cfg.shared_folder) - 1 },\n\t{ \"NO_MERGE_VID\", (void*)(&(cfg.no_merge_vid)), HEX16, 0, 0xFFFF },\n\t{ \"NO_MERGE_PID\", (void*)(&(cfg.no_merge_pid)), HEX16, 0, 0xFFFF },\n\t{ \"NO_MERGE_VIDPID\", (void*)(cfg.no_merge_vidpid), HEX32ARR, 0, 0xFFFFFFFF },\n\t{ \"CUSTOM_ASPECT_RATIO_1\", (void*)(&(cfg.custom_aspect_ratio[0])), STRING, 0, sizeof(cfg.custom_aspect_ratio[0]) - 1 },\n\t{ \"CUSTOM_ASPECT_RATIO_2\", (void*)(&(cfg.custom_aspect_ratio[1])), STRING, 0, sizeof(cfg.custom_aspect_ratio[1]) - 1 },\n\t{ \"SPINNER_VID\", (void*)(&(cfg.spinner_vid)), HEX16, 0, 0xFFFF },\n\t{ \"SPINNER_PID\", (void*)(&(cfg.spinner_pid)), HEX16, 0, 0xFFFF },\n\t{ \"SPINNER_AXIS\", (void*)(&(cfg.spinner_axis)), UINT8, 0, 2 },\n\t{ \"SPINNER_THROTTLE\", (void*)(&(cfg.spinner_throttle)), INT32, -10000, 10000 },\n\t{ \"AFILTER_DEFAULT\", (void*)(&(cfg.afilter_default)), STRING, 0, sizeof(cfg.afilter_default) - 1 },\n\t{ \"VFILTER_DEFAULT\", (void*)(&(cfg.vfilter_default)), STRING, 0, sizeof(cfg.vfilter_default) - 1 },\n\t{ \"VFILTER_VERTICAL_DEFAULT\", (void*)(&(cfg.vfilter_vertical_default)), STRING, 0, sizeof(cfg.vfilter_vertical_default) - 1 },\n\t{ \"VFILTER_SCANLINES_DEFAULT\", (void*)(&(cfg.vfilter_scanlines_default)), STRING, 0, sizeof(cfg.vfilter_scanlines_default) - 1 },\n\t{ \"SHMASK_DEFAULT\", (void*)(&(cfg.shmask_default)), STRING, 0, sizeof(cfg.shmask_default) - 1 },\n\t{ \"SHMASK_MODE_DEFAULT\", (void*)(&(cfg.shmask_mode_default)), UINT8, 0, 255 },\n\t{ \"PRESET_DEFAULT\", (void*)(&(cfg.preset_default)), STRING, 0, sizeof(cfg.preset_default) - 1 },\n\t{ \"LOG_FILE_ENTRY\", (void*)(&(cfg.log_file_entry)), UINT8, 0, 1 },\n\t{ \"BT_AUTO_DISCONNECT\", (void*)(&(cfg.bt_auto_disconnect)), UINT32, 0, 180 },\n\t{ \"BT_RESET_BEFORE_PAIR\", (void*)(&(cfg.bt_reset_before_pair)), UINT8, 0, 1 },\n\t{ \"WAITMOUNT\", (void*)(&(cfg.waitmount)), STRING, 0, sizeof(cfg.waitmount) - 1 },\n\t{ \"RUMBLE\", (void *)(&(cfg.rumble)), UINT8, 0, 1 },\n\t{ \"WHEEL_FORCE\", (void*)(&(cfg.wheel_force)), UINT8, 0, 100 },\n\t{ \"WHEEL_RANGE\", (void*)(&(cfg.wheel_range)), UINT16, 0, 1000 },\n\t{ \"HDMI_GAME_MODE\", (void *)(&(cfg.hdmi_game_mode)), UINT8, 0, 1 },\n\t{ \"VRR_MODE\", (void *)(&(cfg.vrr_mode)), UINT8, 0, 3 },\n\t{ \"VRR_MIN_FRAMERATE\", (void *)(&(cfg.vrr_min_framerate)), UINT8, 0, 255 },\n\t{ \"VRR_MAX_FRAMERATE\", (void *)(&(cfg.vrr_max_framerate)), UINT8, 0, 255 },\n\t{ \"VRR_VESA_FRAMERATE\", (void *)(&(cfg.vrr_vesa_framerate)), UINT8, 0, 255 },\n\t{ \"VIDEO_OFF\", (void*)(&(cfg.video_off)), INT16, 0, 3600 },\n\t{ \"PLAYER_1_CONTROLLER\", (void*)(&(cfg.player_controller[0])), STRINGARR, sizeof(cfg.player_controller[0]) / sizeof(cfg.player_controller[0][0]), sizeof(cfg.player_controller[0][0]) },\n\t{ \"PLAYER_2_CONTROLLER\", (void*)(&(cfg.player_controller[1])), STRINGARR, sizeof(cfg.player_controller[0]) / sizeof(cfg.player_controller[0][0]), sizeof(cfg.player_controller[0][0]) },\n\t{ \"PLAYER_3_CONTROLLER\", (void*)(&(cfg.player_controller[2])), STRINGARR, sizeof(cfg.player_controller[0]) / sizeof(cfg.player_controller[0][0]), sizeof(cfg.player_controller[0][0]) },\n\t{ \"PLAYER_4_CONTROLLER\", (void*)(&(cfg.player_controller[3])), STRINGARR, sizeof(cfg.player_controller[0]) / sizeof(cfg.player_controller[0][0]), sizeof(cfg.player_controller[0][0]) },\n\t{ \"PLAYER_5_CONTROLLER\", (void*)(&(cfg.player_controller[4])), STRINGARR, sizeof(cfg.player_controller[0]) / sizeof(cfg.player_controller[0][0]), sizeof(cfg.player_controller[0][0]) },\n\t{ \"PLAYER_6_CONTROLLER\", (void*)(&(cfg.player_controller[5])), STRINGARR, sizeof(cfg.player_controller[0]) / sizeof(cfg.player_controller[0][0]), sizeof(cfg.player_controller[0][0]) },\n\t{ \"DISABLE_AUTOFIRE\", (void *)(&(cfg.disable_autofire)), UINT8, 0, 1 },\n\t{ \"VIDEO_BRIGHTNESS\", (void *)(&(cfg.video_brightness)), UINT8, 0, 100 },\n\t{ \"VIDEO_CONTRAST\", (void *)(&(cfg.video_contrast)), UINT8, 0, 100 },\n\t{ \"VIDEO_SATURATION\", (void *)(&(cfg.video_saturation)), UINT8, 0, 100 },\n\t{ \"VIDEO_HUE\", (void *)(&(cfg.video_hue)), UINT16, 0, 360 },\n\t{ \"VIDEO_GAIN_OFFSET\", (void *)(&(cfg.video_gain_offset)), STRING, 0, sizeof(cfg.video_gain_offset) },\n\t{ \"HDR\", (void*)(&cfg.hdr), UINT8, 0, 2 },\n\t{ \"HDR_MAX_NITS\", (void*)(&(cfg.hdr_max_nits)), UINT16, 100, 10000 },\n\t{ \"HDR_AVG_NITS\", (void*)(&(cfg.hdr_avg_nits)), UINT16, 100, 10000 },\n\t{ \"VGA_MODE\", (void*)(&(cfg.vga_mode)), STRING, 0, sizeof(cfg.vga_mode) - 1 },\n\t{ \"NTSC_MODE\", (void *)(&(cfg.ntsc_mode)), UINT8, 0, 2 },\n\t{ \"CONTROLLER_UNIQUE_MAPPING\", (void *)(cfg.controller_unique_mapping), UINT32ARR, 0, 0xFFFFFFFF },\n\t{ \"OSD_LOCK\", (void*)(&(cfg.osd_lock)), STRING, 0, sizeof(cfg.osd_lock) - 1 },\n\t{ \"OSD_LOCK_TIME\", (void*)(&(cfg.osd_lock_time)), UINT16, 0, 60 },\n\t{ \"DEBUG\", (void *)(&(cfg.debug)), UINT8, 0, 1 },\n\t{ \"MAIN\", (void*)(&(cfg.main)), STRING, 0, sizeof(cfg.main) - 1 },\n};\n\nstatic const int nvars = (int)(sizeof(ini_vars) / sizeof(ini_var_t));\n\n#define INI_LINE_SIZE           1024\n\n#define INI_SECTION_START       '['\n#define INI_SECTION_END         ']'\n#define INCL_SECTION            '+'\n\n#define CHAR_IS_NUM(c)          (((c) >= '0') && ((c) <= '9'))\n#define CHAR_IS_ALPHA_LOWER(c)  (((c) >= 'a') && ((c) <= 'z'))\n#define CHAR_IS_ALPHA_UPPER(c)  (((c) >= 'A') && ((c) <= 'Z'))\n#define CHAR_IS_ALPHANUM(c)     (CHAR_IS_ALPHA_LOWER(c) || CHAR_IS_ALPHA_UPPER(c) || CHAR_IS_NUM(c))\n#define CHAR_IS_SPECIAL(c)      (((c) == '[') || ((c) == ']') || ((c) == '(') || ((c) == ')') || \\\n                                 ((c) == '-') || ((c) == '+') || ((c) == '/') || ((c) == '=') || \\\n                                 ((c) == '#') || ((c) == '$') || ((c) == '@') || ((c) == '_') || \\\n                                 ((c) == ',') || ((c) == '.') || ((c) == '!') || ((c) == '*') || \\\n                                 ((c) == ':') || ((c) == '~'))\n\n#define CHAR_IS_VALID(c)        (CHAR_IS_ALPHANUM(c) || CHAR_IS_SPECIAL(c))\n#define CHAR_IS_SPACE(c)        (((c) == ' ') || ((c) == '\\t'))\n#define CHAR_IS_LINEEND(c)      (((c) == '\\n'))\n#define CHAR_IS_COMMENT(c)      (((c) == ';'))\n#define CHAR_IS_QUOTE(c)        (((c) == '\"'))\n\n\nfileTYPE ini_file;\n\nstatic bool has_video_sections = false;\nstatic bool using_video_section = false;\n\nint ini_pt = 0;\nstatic char ini_getch()\n{\n\tstatic uint8_t buf[512];\n\tif (!(ini_pt & 0x1ff)) FileReadSec(&ini_file, buf);\n\tif (ini_pt >= ini_file.size) return 0;\n\treturn buf[(ini_pt++) & 0x1ff];\n}\n\nstatic int ini_getline(char* line)\n{\n\tchar c, ignore = 0, skip = 1;\n\tint i = 0;\n\n\twhile ((c = ini_getch()))\n\t{\n\t\tif (!CHAR_IS_SPACE(c)) skip = 0;\n\t\tif (i >= (INI_LINE_SIZE - 1) || CHAR_IS_COMMENT(c)) ignore = 1;\n\n\t\tif (CHAR_IS_LINEEND(c)) break;\n\t\tif ((CHAR_IS_SPACE(c) || CHAR_IS_VALID(c)) && !ignore && !skip) line[i++] = c;\n\t}\n\tline[i] = 0;\n\twhile (i > 0 && CHAR_IS_SPACE(line[i - 1])) line[--i] = 0;\n\treturn c == 0;\n}\n\nstatic int ini_get_section(char* buf, const char *vmode)\n{\n\tint i = 0;\n\tint incl = (buf[0] == INCL_SECTION);\n\n\t// get section start marker\n\tif (buf[0] != INI_SECTION_START && buf[0] != INCL_SECTION)\n\t{\n\t\treturn 0;\n\t}\n\telse buf++;\n\n\tint wc_pos = -1;\n\tint eq_pos = -1;\n\n\t// get section stop marker\n\twhile (buf[i])\n\t{\n\t\tif (buf[i] == INI_SECTION_END)\n\t\t{\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf[i] == '*') wc_pos = i;\n\t\tif (buf[i] == '=') eq_pos = i;\n\n\t\ti++;\n\t\tif (i >= INI_LINE_SIZE) return 0;\n\t}\n\n\tif (!strcasecmp(buf, \"MiSTer\") ||\n\t\t(is_arcade() && !strcasecmp(buf, \"arcade\")) ||\n\t\t(arcade_is_vertical() && !strcasecmp(buf, \"arcade_vertical\")) ||\n\t\t((wc_pos >= 0) ? !strncasecmp(buf, user_io_get_core_name(1), wc_pos) : !strcasecmp(buf, user_io_get_core_name(1))) ||\n\t\t((wc_pos >= 0) ? !strncasecmp(buf, user_io_get_core_name(0), wc_pos) : !strcasecmp(buf, user_io_get_core_name(0))))\n\t{\n\t\tif (incl)\n\t\t{\n\t\t\tini_parser_debugf(\"included '%s'\", buf);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tini_parser_debugf(\"Got SECTION '%s'\", buf);\n\t\t}\n\t\treturn 1;\n\t}\n\telse if ((eq_pos >= 0) && !strncasecmp(buf, \"video\", eq_pos))\n\t{\n\t\thas_video_sections = true;\n\t\tif(!strcasecmp(&buf[eq_pos+1], vmode))\n\t\t{\n\t\t\tusing_video_section = true;\n\t\t\tini_parser_debugf(\"Got SECTION '%s'\", buf);\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ini_parse_numeric(const ini_var_t *var, const char *text, void *out)\n{\n\tuint32_t u32 = 0;\n\tint32_t i32 = 0;\n\tfloat f32 = 0.0f;\n\tchar *endptr = nullptr;\n\n\tbool out_of_range = true;\n\tbool invalid_format = false;\n\n\tswitch(var->type)\n\t{\n\tcase HEX8:\n\tcase HEX16:\n\tcase HEX32:\n\tcase HEX32ARR:\n\t\tinvalid_format = strncasecmp(text, \"0x\", 2);\n\t\t// fall through\n\n\tcase UINT8:\n\tcase UINT16:\n\tcase UINT32:\n\tcase UINT32ARR:\n\t\tu32 = strtoul(text, &endptr, 0);\n\t\tif (u32 < var->min) u32 = var->min;\n\t\telse if (u32 > var->max) u32 = var->max;\n\t\telse out_of_range = false;\n\t\tbreak;\n\n\tcase INT8:\n\tcase INT16:\n\tcase INT32:\n\t\ti32 = strtol(text, &endptr, 0);\n\t\tif (i32 < var->min) i32 = var->min;\n\t\telse if (i32 > var->max) i32 = var->max;\n\t\telse out_of_range = false;\n\t\tbreak;\n\n\tcase FLOAT:\n\t\tf32 = strtof(text, &endptr);\n\t\tif (f32 < var->min) f32 = var->min;\n\t\telse if (f32 > var->max) f32 = var->max;\n\t\telse out_of_range = false;\n\t\tbreak;\n\n\tdefault:\n\t\tout_of_range = false;\n\t\tbreak;\n\t}\n\n\tif (*endptr) cfg_error(\"%s: \\'%s\\' not a number\", var->name, text);\n\telse if (out_of_range) cfg_error(\"%s: \\'%s\\' out of range\", var->name, text);\n\telse if (invalid_format) cfg_error(\"%s: \\'%s\\' invalid format\", var->name, text);\n\n\tswitch (var->type)\n\t{\n\tcase HEX8:\n\tcase UINT8: *(uint8_t*)out = u32; break;\n\tcase INT8: *(int8_t*)out = i32; break;\n\tcase HEX16:\n\tcase UINT16: *(uint16_t*)out = u32; break;\n\tcase HEX32ARR:\n\tcase UINT32ARR: *(uint32_t*)out = u32; break;\n\tcase INT16: *(int16_t*)out = i32; break;\n\tcase HEX32:\n\tcase UINT32: *(uint32_t*)out = u32; break;\n\tcase INT32: *(int32_t*)out = i32; break;\n\tcase FLOAT: *(float*)out = f32; break;\n\tdefault: break;\n\t}\n}\n\n// Used to determine if an array variable should be appended or restarted.\nstatic bool var_array_append[sizeof(ini_vars) / sizeof(ini_var_t)] = {};\n\nstatic void ini_parse_var(char* buf)\n{\n\t// find var\n\tint i = 0;\n\twhile (1)\n\t{\n\t\tif (buf[i] == '=' || CHAR_IS_SPACE(buf[i]))\n\t\t{\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse if (!buf[i]) return;\n\t\ti++;\n\t}\n\n\t// parse var\n\tint var_id = -1;\n\tfor (int j = 0; j < (int)(sizeof(ini_vars) / sizeof(ini_var_t)); j++)\n\t{\n\t\tif (!strcasecmp(buf, ini_vars[j].name)) var_id = j;\n\t}\n\n\tif (var_id == -1)\n\t{\n\t\tcfg_error(\"%s: unknown option\", buf);\n\t}\n\telse // get data\n\t{\n\t\ti++;\n\t\twhile (buf[i] == '=' || CHAR_IS_SPACE(buf[i])) i++;\n\t\tini_parser_debugf(\"Got VAR '%s' with VALUE %s\", buf, buf+i);\n\n\t\tconst ini_var_t *var = &ini_vars[var_id];\n\n\t\tswitch (var->type)\n\t\t{\n\t\tcase STRING:\n\t\t\tmemset(var->var, 0, var->max);\n\t\t\tsnprintf((char*)(var->var), var->max, \"%s\", buf+i);\n\t\t\tbreak;\n\n\t\tcase STRINGARR:\n\t\t\t{\n\t\t\t\tint item_sz = var->max;\n\n\t\t\t\tif (!var_array_append[var_id])\n\t\t\t\t{\n\t\t\t\t\tvar_array_append[var_id] = true;\n\n\t\t\t\t\tfor (int n = 0; n < var->min; n++)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *str = ((char*)var->var) + (n * item_sz);\n\t\t\t\t\t\tstr[0] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int n = 0; n < var->min; n++)\n\t\t\t\t{\n\t\t\t\t\tchar *str = ((char*)var->var) + (n * item_sz);\n\t\t\t\t\tif (!strlen(str))\n\t\t\t\t\t{\n\t\t\t\t\t\tsnprintf(str, item_sz, \"%s\", buf + i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HEX32ARR:\n\t\tcase UINT32ARR:\n\t\t\t{\n\t\t\t\tif (!var_array_append[var_id])\n\t\t\t\t{\n\t\t\t\t\tvar_array_append[var_id] = true;\n\n\t\t\t\t\tuint32_t *arr = (uint32_t*)var->var;\n\t\t\t\t\tarr[0] = 0;\n\t\t\t\t}\n\n\t\t\t\tuint32_t *arr = (uint32_t*)var->var;\n\t\t\t\tuint32_t pos = ++arr[0];\n\t\t\t\tini_parse_numeric(var, &buf[i], &arr[pos]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tini_parse_numeric(var, &buf[i], var->var);\n\t\t\tif (!strcasecmp(var->name, \"DEBUG\"))\n\t\t\t{\n\t\t\t\tstdout = cfg.debug ? orig_stdout : dev_null;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ini_parse(int alt, const char *vmode)\n{\n\tstatic char line[INI_LINE_SIZE];\n\tint section = 0;\n\tint eof;\n\n\tif (!orig_stdout) orig_stdout = stdout;\n\tif (!dev_null)\n\t{\n\t\tdev_null = fopen(\"/dev/null\", \"w\");\n\t\tif (dev_null)\n\t\t{\n\t\t\tint null_fd = fileno(dev_null);\n\t\t\tif (null_fd >= 0) fcntl(null_fd, F_SETFD, FD_CLOEXEC);\n\t\t\tstdout = dev_null;\n\t\t}\n\t}\n\n\tini_parser_debugf(\"Start INI parser for core \\\"%s\\\"(%s), video mode \\\"%s\\\".\", user_io_get_core_name(0), user_io_get_core_name(1), vmode);\n\n\tmemset(line, 0, sizeof(line));\n\tmemset(&ini_file, 0, sizeof(ini_file));\n\n\tconst char *name = cfg_get_name(alt);\n\tif (!FileOpen(&ini_file, name))\treturn;\n\n\tini_parser_debugf(\"Opened file %s with size %llu bytes.\", name, ini_file.size);\n\n\tini_pt = 0;\n\n\t// parse ini\n\twhile (1)\n\t{\n\t\t// get line\n\t\teof = ini_getline(line);\n\t\tini_parser_debugf(\"line(%d): \\\"%s\\\".\", section, line);\n\n\t\tif (line[0] == INI_SECTION_START)\n\t\t{\n\t\t\t// if first char in line is INI_SECTION_START, get section\n\t\t\tsection = ini_get_section(line, vmode);\n\t\t\tif (section)\n\t\t\t{\n\t\t\t\tmemset(var_array_append, 0, sizeof(var_array_append));\n\t\t\t}\n\t\t}\n\t\telse if (line[0] == INCL_SECTION && !section)\n\t\t{\n\t\t\tsection = ini_get_section(line, vmode);\n\t\t\tif (section)\n\t\t\t{\n\t\t\t\tmemset(var_array_append, 0, sizeof(var_array_append));\n\t\t\t}\n\t\t}\n\t\telse if(section)\n\t\t{\n\t\t\t// otherwise this is a variable, get it\n\t\t\tini_parse_var(line);\n\t\t}\n\n\t\t// if end of file, stop\n\t\tif (eof) break;\n\t}\n\n\tFileClose(&ini_file);\n}\n\nstatic constexpr int CFG_ERRORS_MAX = 4;\nstatic constexpr int CFG_ERRORS_STRLEN = 128;\nstatic char cfg_errors[CFG_ERRORS_MAX][CFG_ERRORS_STRLEN];\nstatic int cfg_error_count = 0;\n\nconst char* cfg_get_name(uint8_t alt)\n{\n\tstatic int done = 0;\n\tstatic char names[3][64] = {};\n\tstatic char name[64];\n\n\tif (!done)\n\t{\n\t\tdone = 1;\n\t\tDIR *d = opendir(getRootDir());\n\t\tif (!d)\n\t\t{\n\t\t\tprintf(\"Couldn't open dir: %s\\n\", getRootDir());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstruct dirent *de;\n\t\t\tint i = 0;\n\t\t\twhile ((de = readdir(d)) && i < 3)\n\t\t\t{\n\t\t\t\tint len = strlen(de->d_name);\n\t\t\t\tif (!strncasecmp(de->d_name, \"MiSTer_\", 7) && !strcasecmp(de->d_name + len - 4, \".ini\"))\n\t\t\t\t{\n\t\t\t\t\tsnprintf(names[i], sizeof(names[0]), \"%s\", de->d_name);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(d);\n\t\t}\n\n\t\tfor (int i = 1; i < 3; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < 3; j++)\n\t\t\t{\n\t\t\t\tif ((!names[j - 1][0] && names[j][0]) || (names[j - 1][0] && names[j][0] && strcasecmp(names[j - 1], names[j]) > 0))\n\t\t\t\t{\n\t\t\t\t\tstrcpy(name, names[j - 1]);\n\t\t\t\t\tstrcpy(names[j - 1], names[j]);\n\t\t\t\t\tstrcpy(names[j], name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstrcpy(name, \"MiSTer.ini\");\n\tif (alt && alt < 4) strcpy(name, names[alt-1]);\n\treturn name;\n}\n\nconst char* cfg_get_label(uint8_t alt)\n{\n\tif (!alt) return \"Main\";\n\n\tconst char *name = cfg_get_name(alt);\n\tif (!name[0]) return \" -- \";\n\n\tstatic char label[6];\n\tsnprintf(label, sizeof(label), \"%s\", name + 7);\n\tchar *p = strrchr(label, '.');\n\tif (p) *p = 0;\n\tif (!strcasecmp(label, \"alt\"))   return \"Alt1\";\n\tif (!strcasecmp(label, \"alt_1\")) return \"Alt1\";\n\tif (!strcasecmp(label, \"alt_2\")) return \"Alt2\";\n\tif (!strcasecmp(label, \"alt_3\")) return \"Alt3\";\n\n\tfor (int i = 0; i < 4; i++) if (!label[i]) label[i] = ' ';\n\tlabel[4] = 0;\n\treturn label;\n}\n\nvoid cfg_parse()\n{\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.bootscreen = 1;\n\tcfg.fb_terminal = 1;\n\tcfg.controller_info = 6;\n\tcfg.browse_expand = 1;\n\tcfg.logo = 1;\n\tcfg.rumble = 1;\n\tcfg.wheel_force = 50;\n\tcfg.dvi_mode = 2;\n\tcfg.hdr = 0;\n\tcfg.hdr_max_nits = 1000;\n\tcfg.hdr_avg_nits = 250;\n\tcfg.video_brightness = 50;\n\tcfg.video_contrast = 50;\n\tcfg.video_saturation = 100;\n\tcfg.video_hue = 0;\n\tstrcpy(cfg.video_gain_offset, \"1, 0, 1, 0, 1, 0\");\n\tstrcpy(cfg.main, \"MiSTer\");\n\thas_video_sections = false;\n\tusing_video_section = false;\n\tcfg_error_count = 0;\n\tini_parse(altcfg(), video_get_core_mode_name(1));\n\tif (has_video_sections && !using_video_section)\n\t{\n\t\t// second pass to look for section without vrefresh\n\t\tini_parse(altcfg(), video_get_core_mode_name(0));\n\t}\n\n\tif (strlen(cfg.vga_mode))\n\t{\n\t\tif (!strcasecmp(cfg.vga_mode, \"rgb\")) cfg.vga_mode_int = 0;\n\t\tif (!strcasecmp(cfg.vga_mode, \"ypbpr\")) cfg.vga_mode_int = 1;\n\t\tif (!strcasecmp(cfg.vga_mode, \"svideo\")) cfg.vga_mode_int = 2;\n\t\tif (!strcasecmp(cfg.vga_mode, \"cvbs\")) cfg.vga_mode_int = 3;\n\t}\n}\n\nbool cfg_has_video_sections()\n{\n\treturn has_video_sections;\n}\n\n\nvoid cfg_error(const char *fmt, ...)\n{\n\tif (cfg_error_count >= CFG_ERRORS_MAX) return;\n\n\tva_list args;\n\tva_start(args, fmt);\n\tvsnprintf(cfg_errors[cfg_error_count], CFG_ERRORS_STRLEN, fmt, args);\n\tva_end(args);\n\n\tprintf(\"ERROR CFG: %s\\n\", cfg_errors[cfg_error_count]);\n\n\tcfg_error_count += 1;\n}\n\nbool cfg_check_errors(char *msg, size_t max_len)\n{\n\tmsg[0] = '\\0';\n\n\tif (cfg_error_count == 0) return false;\n\n\tint pos = snprintf(msg, max_len, \"%d INI Error%s\\n---\", cfg_error_count, cfg_error_count > 1 ? \"s\" : \"\");\n\n\tfor (int i = 0; i < cfg_error_count; i++)\n\t{\n\t\tpos += snprintf(msg + pos, max_len - pos, \"\\n%s\\n\", cfg_errors[i]);\n\t}\n\n\treturn true;\n}\n\nvoid cfg_print()\n{\n\tprintf(\"Loaded config:\\n--------------\\n\");\n\tfor (uint i = 0; i < (sizeof(ini_vars) / sizeof(ini_vars[0])); i++)\n\t{\n\t\tswitch (ini_vars[i].type)\n\t\t{\n\t\tcase UINT8:\n\t\t\tprintf(\"  %s=%u\\n\", ini_vars[i].name, *(uint8_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase UINT16:\n\t\t\tprintf(\"  %s=%u\\n\", ini_vars[i].name, *(uint16_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase UINT32:\n\t\t\tprintf(\"  %s=%u\\n\", ini_vars[i].name, *(uint32_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase UINT32ARR:\n\t\t\tif (*(uint32_t*)ini_vars[i].var)\n\t\t\t{\n\t\t\t\tuint32_t* arr = (uint32_t*)ini_vars[i].var;\n\t\t\t\tfor (uint32_t n = 0; n < arr[0]; n++) printf(\"  %s=%u\\n\", ini_vars[i].name, arr[n + 1]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HEX8:\n\t\t\tprintf(\"  %s=0x%02X\\n\", ini_vars[i].name, *(uint8_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase HEX16:\n\t\t\tprintf(\"  %s=0x%04X\\n\", ini_vars[i].name, *(uint16_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase HEX32:\n\t\t\tprintf(\"  %s=0x%08X\\n\", ini_vars[i].name, *(uint32_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase HEX32ARR:\n\t\t\tif (*(uint32_t*)ini_vars[i].var)\n\t\t\t{\n\t\t\t\tuint32_t* arr = (uint32_t*)ini_vars[i].var;\n\t\t\t\tfor (uint32_t n = 0; n < arr[0]; n++) printf(\"  %s=0x%08X\\n\", ini_vars[i].name, arr[n + 1]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase INT8:\n\t\t\tprintf(\"  %s=%d\\n\", ini_vars[i].name, *(int8_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase INT16:\n\t\t\tprintf(\"  %s=%d\\n\", ini_vars[i].name, *(int16_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase INT32:\n\t\t\tprintf(\"  %s=%d\\n\", ini_vars[i].name, *(int32_t*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase FLOAT:\n\t\t\tprintf(\"  %s=%f\\n\", ini_vars[i].name, *(float*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase STRING:\n\t\t\tif (*(uint32_t*)ini_vars[i].var) printf(\"  %s=%s\\n\", ini_vars[i].name, (char*)ini_vars[i].var);\n\t\t\tbreak;\n\n\t\tcase STRINGARR:\n\t\t\tfor (int n = 0; n < ini_vars[i].min; n++)\n\t\t\t{\n\t\t\t\tchar *str = ((char*)ini_vars[i].var) + (n*ini_vars[i].max);\n\t\t\t\tif (!strlen(str)) break;\n\t\t\t\tprintf(\"  %s=%s\\n\", ini_vars[i].name, str);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"--------------\\n\");\n}\n\nstatic int yc_parse_mode(char* buf, yc_mode *mode)\n{\n\tint i = 0;\n\twhile (1)\n\t{\n\t\tif (buf[i] == '=' || CHAR_IS_LINEEND(buf[i]))\n\t\t{\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse if (!buf[i]) return 0;\n\t\ti++;\n\t}\n\n\ti++;\n\twhile (buf[i] == '=' || CHAR_IS_SPACE(buf[i])) i++;\n\tini_parser_debugf(\"Got yc_mode '%s' with VALUE %s\", buf, buf + i);\n\n\tsnprintf(mode->key, sizeof(mode->key), \"%s\", buf);\n\tmode->phase_inc = strtoull(buf + i, 0, 0);\n\tif (!mode->phase_inc)\n\t{\n\t\tprintf(\"ERROR: cannot parse YC phase_inc: '%s'\\n\", buf + i);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid yc_parse(yc_mode *yc_table, int max)\n{\n\tmemset(yc_table, 0, max * sizeof(yc_mode));\n\n\tstatic char line[INI_LINE_SIZE];\n\tint eof;\n\n\tmemset(line, 0, sizeof(line));\n\tmemset(&ini_file, 0, sizeof(ini_file));\n\n\tconst char *corename = user_io_get_core_name(1);\n\tint corename_len = strlen(corename);\n\n\tconst char *name = \"yc.txt\";\n\tif (!FileOpen(&ini_file, name))\treturn;\n\n\tini_parser_debugf(\"Opened file %s with size %llu bytes.\", name, ini_file.size);\n\n\tini_pt = 0;\n\tint n = 0;\n\n\twhile (n < max)\n\t{\n\t\t// get line\n\t\teof = ini_getline(line);\n\t\tif (!strncasecmp(line, corename, corename_len))\n\t\t{\n\t\t\tint res = yc_parse_mode(line, &yc_table[n]);\n\t\t\tif (res) n++;\n\t\t}\n\n\t\t// if end of file, stop\n\t\tif (eof) break;\n\t}\n\n\tFileClose(&ini_file);\n}\n"
        },
        {
          "name": "cfg.h",
          "type": "blob",
          "size": 2.6767578125,
          "content": "// cfg.h\n// 2015, rok.krajnc@gmail.com\n// 2017+, Sorgelig\n\n#ifndef __CFG_H__\n#define __CFG_H__\n\n#include <inttypes.h>\n\n//// type definitions ////\ntypedef struct {\n\tuint32_t keyrah_mode;\n\tuint8_t forced_scandoubler;\n\tuint8_t key_menu_as_rgui;\n\tuint8_t reset_combo;\n\tuint8_t csync;\n\tuint8_t vga_scaler;\n\tuint8_t vga_sog;\n\tuint8_t hdmi_audio_96k;\n\tuint8_t dvi_mode;\n\tuint8_t hdmi_limited;\n\tuint8_t direct_video;\n\tuint8_t video_info;\n\tfloat refresh_min;\n\tfloat refresh_max;\n\tuint8_t controller_info;\n\tuint8_t vsync_adjust;\n\tuint8_t kbd_nomouse;\n\tuint8_t mouse_throttle;\n\tuint8_t bootscreen;\n\tuint8_t vscale_mode;\n\tuint16_t vscale_border;\n\tuint8_t rbf_hide_datecode;\n\tuint8_t menu_pal;\n\tint16_t bootcore_timeout;\n\tuint8_t fb_size;\n\tuint8_t fb_terminal;\n\tuint8_t osd_rotate;\n\tuint16_t osd_timeout;\n\tuint8_t gamepad_defaults;\n\tuint8_t recents;\n\tuint16_t jamma_vid;\n\tuint16_t jamma_pid;\n\tuint16_t jamma2_vid;\n\tuint16_t jamma2_pid;\n\tuint16_t no_merge_vid;\n\tuint16_t no_merge_pid;\n\tuint32_t no_merge_vidpid[256];\n\tuint16_t spinner_vid;\n\tuint16_t spinner_pid;\n\tint spinner_throttle;\n\tuint8_t spinner_axis;\n\tuint8_t sniper_mode;\n\tuint8_t browse_expand;\n\tuint8_t logo;\n\tuint8_t log_file_entry;\n\tuint8_t shmask_mode_default;\n\tint bt_auto_disconnect;\n\tint bt_reset_before_pair;\n\tchar bootcore[256];\n\tchar video_conf[1024];\n\tchar video_conf_pal[1024];\n\tchar video_conf_ntsc[1024];\n\tchar font[1024];\n\tchar shared_folder[1024];\n\tchar waitmount[1024];\n\tchar custom_aspect_ratio[2][16];\n\tchar afilter_default[1023];\n\tchar vfilter_default[1023];\n\tchar vfilter_vertical_default[1023];\n\tchar vfilter_scanlines_default[1023];\n\tchar shmask_default[1023];\n\tchar preset_default[1023];\n\tchar player_controller[6][8][256];\n\tchar controller_deadzone[32][256];\n\tuint8_t rumble;\n\tuint8_t wheel_force;\n\tuint16_t wheel_range;\n\tuint8_t hdmi_game_mode;\n\tuint8_t vrr_mode;\n\tuint8_t vrr_min_framerate;\n\tuint8_t vrr_max_framerate;\n\tuint8_t vrr_vesa_framerate;\n\tuint16_t video_off;\n\tuint8_t disable_autofire;\n\tuint8_t video_brightness;\n\tuint8_t video_contrast;\n\tuint8_t video_saturation;\n\tuint16_t video_hue;\n\tchar video_gain_offset[256];\n\tuint8_t hdr;\n\tuint16_t hdr_max_nits;\n\tuint16_t hdr_avg_nits;\n\tchar vga_mode[16];\n\tchar vga_mode_int;\n\tchar ntsc_mode;\n\tuint32_t controller_unique_mapping[256];\n\tchar osd_lock[25];\n\tuint16_t osd_lock_time;\n\tchar debug;\n\tchar main[1024];\n} cfg_t;\n\nextern cfg_t cfg;\n\n//// functions ////\nvoid cfg_parse();\nvoid cfg_print();\nconst char* cfg_get_name(uint8_t alt);\nconst char* cfg_get_label(uint8_t alt);\nbool cfg_has_video_sections();\n\nvoid cfg_error(const char *fmt, ...);\nbool cfg_check_errors(char *msg, size_t max_len);\n\nstruct yc_mode\n{\n\tchar key[64];\n\tint64_t phase_inc;\n};\n\nvoid yc_parse(yc_mode *yc_table, int max);\n\n#endif // __CFG_H__\n"
        },
        {
          "name": "charrom.cpp",
          "type": "blob",
          "size": 11.56640625,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <ctype.h>\n\n#include \"hardware.h\"\n#include \"file_io.h\"\n\n\n// *character font\nunsigned char charfont[256][8] =\n{\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 0    [0x0]\n\t{ 0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55 },         // 1    [0x1]\n\t{ 0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A },         // 2    [0x2]\n\t{ 0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14 },         // 3    [0x3]\n\t{ 0x7f,0x6b,0x77,0x41,0x55,0x6b,0x7f,0x00 },         // 4    [0x4] bluetooth\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 5    [0x5]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 6    [0x6]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 7    [0x7]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 8    [0x8]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 9    [0x9]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 10   [0xa]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 11   [0xb]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 12   [0xc]\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 13   [0xd]\n\t{ 0x00,0xc0,0xc0,0xe0,0x78,0x1f,0x00,0xff },         // 14   [0xe] atari logo left\n\t{ 0xff,0x00,0x1f,0x78,0xe0,0xc0,0xc0,0x00 },         // 15   [0xf] atari logo right\n\t{ 0x08,0x08,0x1C,0x1C,0x3E,0x3E,0x7F,0x7F },         // 16   [0x10] arrow left\n\t{ 0x7F,0x7F,0x3E,0x3E,0x1C,0x1C,0x08,0x08 },         // 17   [0x11] arrow right\n\t{ 0x00,0x10,0x18,0x7c,0x7c,0x18,0x10,0x00 },         // 18   [0x12] arrow up\n\t{ 0x00,0x10,0x30,0x7c,0x7c,0x30,0x10,0x00 },         // 19   [0x13] arrow down\n\t{ 0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x00,0x00 },         // 20   [0x14]\n\t{ 0x00,0x00,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C },         // 21   [0x15]\n\t{ 0x00,0x7C,0x7C,0x38,0x38,0x10,0x10,0x00 },         // 22   [0x16] mini arrow right\n\t{ 0x70,0x7c,0x72,0x72,0x72,0x7c,0x70,0x00 },         // 23   [0x17] write protect\n\t{ 0x70,0x70,0x70,0x70,0x7c,0x72,0x02,0x0c },         // 24   [0x18] write enable\n\t{ 0x3e,0x3e,0x22,0x22,0x22,0x3e,0x3e,0x00 },         // 25   [0x19] unchecked checkbox\n\t{ 0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x00 },         // 26   [0x1a] checked checkbox\n\t{ 0x00,0x00,0x00,0x0c,0x0c,0x00,0x00,0x00 },         // 27   [0x1b] middle dot\n\t{ 0x68,0x78,0x6b,0x0f,0x6b,0x78,0x68,0x00 },         // 28   [0x1c] ethernet\n\t{ 0x02,0x09,0x25,0x55,0x25,0x09,0x02,0x00 },         // 29   [0x1d] wifi\n\t{ 0x00,0x90,0xD8,0x7C,0x3E,0x1B,0x09,0x00 },         // 30   [0x1e] charge\n\t{ 0x7E,0x72,0x73,0x73,0x73,0x72,0x7E,0x00 },         // 31   [0x1f] battery\n\t{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },         // 32   [0x20]\n\t{ 0x00,0x00,0x6F,0x6F,0x00,0x00,0x00,0x00 },         // 33   [0x21]\n\t{ 0x05,0x03,0x00,0x00,0x05,0x03,0x00,0x00 },         // 34   [0x22]\n\t{ 0x14,0x7F,0x7F,0x14,0x7F,0x14,0x00,0x00 },         // 35   [0x23]\n\t{ 0x48,0xDC,0x74,0x5C,0x76,0x24,0x00,0x00 },         // 36   [0x24]\n\t{ 0x4C,0x2A,0x16,0x68,0x54,0x32,0x00,0x00 },         // 37   [0x25]\n\t{ 0x20,0x74,0x4A,0x5E,0x34,0x60,0x50,0x00 },         // 38   [0x26]\n\t{ 0x00,0x00,0x05,0x03,0x00,0x00,0x00,0x00 },         // 39   [0x27]\n\t{ 0x00,0x00,0x1C,0x3E,0x63,0x41,0x00,0x00 },         // 40   [0x28]\n\t{ 0x41,0x63,0x3E,0x1C,0x00,0x00,0x00,0x00 },         // 41   [0x29]\n\t{ 0x08,0x2A,0x1C,0x1C,0x2A,0x08,0x00,0x00 },         // 42   [0x2a]\n\t{ 0x08,0x08,0x3E,0x3E,0x08,0x08,0x00,0x00 },         // 43   [0x2b]\n\t{ 0x00,0x00,0xA0,0x60,0x00,0x00,0x00,0x00 },         // 44   [0x2c]\n\t{ 0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00 },         // 45   [0x2d]\n\t{ 0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x00 },         // 46   [0x2e]\n\t{ 0x60,0x30,0x18,0x0C,0x06,0x03,0x00,0x00 },         // 47   [0x2f]\n\t{ 0x3E,0x7F,0x41,0x5D,0x7F,0x3E,0x00,0x00 },         // 48   [0x30]\n\t{ 0x00,0x01,0x7F,0x7F,0x00,0x00,0x00,0x00 },         // 49   [0x31]\n\t{ 0x71,0x79,0x49,0x49,0x4F,0x46,0x00,0x00 },         // 50   [0x32]\n\t{ 0x41,0x49,0x49,0x49,0x7F,0x36,0x00,0x00 },         // 51   [0x33]\n\t{ 0x1C,0x1E,0x13,0x7F,0x7F,0x10,0x00,0x00 },         // 52   [0x34]\n\t{ 0x4F,0x4F,0x49,0x49,0x79,0x31,0x00,0x00 },         // 53   [0x35]\n\t{ 0x3E,0x7F,0x49,0x49,0x79,0x31,0x00,0x00 },         // 54   [0x36]\n\t{ 0x01,0x01,0x79,0x7D,0x07,0x03,0x00,0x00 },         // 55   [0x37]\n\t{ 0x36,0x7F,0x49,0x49,0x7F,0x36,0x00,0x00 },         // 56   [0x38]\n\t{ 0x46,0x4F,0x49,0x49,0x7F,0x3E,0x00,0x00 },         // 57   [0x39]\n\t{ 0x00,0x00,0x6C,0x6C,0x00,0x00,0x00,0x00 },         // 58   [0x3a]\n\t{ 0x00,0x00,0xAC,0x6C,0x00,0x00,0x00,0x00 },         // 59   [0x3b]\n\t{ 0x08,0x1C,0x36,0x63,0x41,0x00,0x00,0x00 },         // 60   [0x3c]\n\t{ 0x00,0x14,0x14,0x14,0x14,0x00,0x00,0x00 },         // 61   [0x3d]\n\t{ 0x00,0x41,0x63,0x36,0x1C,0x08,0x00,0x00 },         // 62   [0x3e]\n\t{ 0x06,0x07,0x51,0x59,0x0F,0x06,0x00,0x00 },         // 63   [0x3f]\n\t{ 0x3E,0x7F,0x41,0x5D,0x5F,0x4E,0x00,0x00 },         // 64   [0x40]\n\t{ 0x7E,0x7F,0x09,0x09,0x7F,0x7E,0x00,0x00 },         // 65   [0x41]\n\t{ 0x7F,0x7F,0x49,0x49,0x7F,0x36,0x00,0x00 },         // 66   [0x42]\n\t{ 0x3E,0x7F,0x41,0x41,0x41,0x41,0x00,0x00 },         // 67   [0x43]\n\t{ 0x7F,0x7F,0x41,0x41,0x7F,0x3E,0x00,0x00 },         // 68   [0x44]\n\t{ 0x3E,0x7F,0x49,0x49,0x41,0x41,0x00,0x00 },         // 69   [0x45]\n\t{ 0x7E,0x7F,0x09,0x09,0x01,0x01,0x00,0x00 },         // 70   [0x46]\n\t{ 0x3E,0x7F,0x41,0x49,0x7B,0x7B,0x00,0x00 },         // 71   [0x47]\n\t{ 0x7F,0x7F,0x08,0x08,0x7F,0x7F,0x00,0x00 },         // 72   [0x48]\n\t{ 0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00 },         // 73   [0x49]\n\t{ 0x60,0x60,0x40,0x40,0x7F,0x3F,0x00,0x00 },         // 74   [0x4a]\n\t{ 0x7F,0x7F,0x08,0x1C,0x77,0x63,0x00,0x00 },         // 75   [0x4b]\n\t{ 0x3F,0x7F,0x40,0x40,0x40,0x40,0x00,0x00 },         // 76   [0x4c]\n\t{ 0x7F,0x7F,0x06,0x0C,0x06,0x7F,0x7F,0x00 },         // 77   [0x4d]\n\t{ 0x7F,0x7F,0x0C,0x18,0x7F,0x7F,0x00,0x00 },         // 78   [0x4e]\n\t{ 0x7E,0x7F,0x41,0x41,0x7F,0x3F,0x00,0x00 },         // 79   [0x4f]\n\t{ 0x7F,0x7F,0x09,0x09,0x0F,0x06,0x00,0x00 },         // 80   [0x50]\n\t{ 0x7E,0x7F,0x41,0xF1,0xFF,0x3F,0x00,0x00 },         // 81   [0x51]\n\t{ 0x7F,0x7F,0x09,0x09,0x7F,0x76,0x00,0x00 },         // 82   [0x52]\n\t{ 0x46,0x4F,0x49,0x49,0x79,0x31,0x00,0x00 },         // 83   [0x53]\n\t{ 0x01,0x01,0x7F,0x7F,0x01,0x01,0x00,0x00 },         // 84   [0x54]\n\t{ 0x3F,0x7F,0x40,0x40,0x7F,0x7F,0x00,0x00 },         // 85   [0x55]\n\t{ 0x1F,0x3F,0x60,0x60,0x3F,0x1F,0x00,0x00 },         // 86   [0x56]\n\t{ 0x7F,0x7F,0x30,0x18,0x30,0x7F,0x7F,0x00 },         // 87   [0x57]\n\t{ 0x63,0x77,0x1C,0x1C,0x77,0x63,0x00,0x00 },         // 88   [0x58]\n\t{ 0x07,0x0F,0x78,0x78,0x0F,0x07,0x00,0x00 },         // 89   [0x59]\n\t{ 0x61,0x71,0x59,0x4D,0x47,0x43,0x00,0x00 },         // 90   [0x5a]\n\t{ 0x00,0x00,0x7F,0x7F,0x41,0x41,0x00,0x00 },         // 91   [0x5b]\n\t{ 0x03,0x06,0x0C,0x18,0x30,0x60,0x00,0x00 },         // 92   [0x5c]\n\t{ 0x41,0x41,0x7F,0x7F,0x00,0x00,0x00,0x00 },         // 93   [0x5d]\n\t{ 0x08,0x0C,0x06,0x03,0x06,0x0C,0x08,0x00 },         // 94   [0x5e]\n\t{ 0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00 },         // 95   [0x5f]\n\t{ 0x00,0x00,0x03,0x05,0x00,0x00,0x00,0x00 },         // 96   [0x60]\n\t{ 0x38,0x7C,0x44,0x44,0x7C,0x7C,0x00,0x00 },         // 97   [0x61]\n\t{ 0x3F,0x7F,0x44,0x44,0x7C,0x38,0x00,0x00 },         // 98   [0x62]\n\t{ 0x38,0x7C,0x44,0x44,0x44,0x44,0x00,0x00 },         // 99   [0x63]\n\t{ 0x38,0x7C,0x44,0x44,0x7F,0x3F,0x00,0x00 },         // 100  [0x64]\n\t{ 0x38,0x7C,0x54,0x54,0x5C,0x58,0x00,0x00 },         // 101  [0x65]\n\t{ 0x00,0x08,0x7E,0x7F,0x09,0x01,0x00,0x00 },         // 102  [0x66]\n\t{ 0x98,0xBC,0xA4,0xA4,0xFC,0x78,0x00,0x00 },         // 103  [0x67]\n\t{ 0x7F,0x7F,0x04,0x04,0x7C,0x78,0x00,0x00 },         // 104  [0x68]\n\t{ 0x00,0x00,0x7D,0x7D,0x00,0x00,0x00,0x00 },         // 105  [0x69]\n\t{ 0x80,0x80,0xFD,0x7D,0x00,0x00,0x00,0x00 },         // 106  [0x6a]\n\t{ 0x7F,0x7F,0x10,0x10,0x7C,0x6C,0x00,0x00 },         // 107  [0x6b]\n\t{ 0x00,0x00,0x7F,0x7F,0x40,0x00,0x00,0x00 },         // 108  [0x6c]\n\t{ 0x7C,0x7C,0x0C,0x18,0x0C,0x7C,0x78,0x00 },         // 109  [0x6d]\n\t{ 0x7C,0x7C,0x04,0x04,0x7C,0x78,0x00,0x00 },         // 110  [0x6e]\n\t{ 0x38,0x7C,0x44,0x44,0x7C,0x38,0x00,0x00 },         // 111  [0x6f]\n\t{ 0xF8,0xFC,0x44,0x44,0x7C,0x38,0x00,0x00 },         // 112  [0x70]\n\t{ 0x38,0x7C,0x44,0x44,0xFC,0xF8,0x00,0x00 },         // 113  [0x71]\n\t{ 0x7C,0x7C,0x08,0x04,0x04,0x04,0x00,0x00 },         // 114  [0x72]\n\t{ 0x48,0x5C,0x54,0x54,0x74,0x24,0x00,0x00 },         // 115  [0x73]\n\t{ 0x00,0x04,0x3F,0x7F,0x44,0x40,0x00,0x00 },         // 116  [0x74]\n\t{ 0x3C,0x7C,0x40,0x40,0x7C,0x7C,0x00,0x00 },         // 117  [0x75]\n\t{ 0x1C,0x3C,0x60,0x60,0x3C,0x1C,0x00,0x00 },         // 118  [0x76]\n\t{ 0x3C,0x7C,0x60,0x30,0x60,0x7C,0x3C,0x00 },         // 119  [0x77]\n\t{ 0x6C,0x6C,0x10,0x10,0x6C,0x6C,0x00,0x00 },         // 120  [0x78]\n\t{ 0x9C,0xBC,0xA0,0xA0,0xFC,0x7C,0x00,0x00 },         // 121  [0x79]\n\t{ 0x64,0x64,0x54,0x54,0x4C,0x4C,0x00,0x00 },         // 122  [0x7a]\n\t{ 0x08,0x08,0x3E,0x77,0x41,0x41,0x00,0x00 },         // 123  [0x7b]\n\t{ 0x00,0x00,0x77,0x77,0x00,0x00,0x00,0x00 },         // 124  [0x7c]\n\t{ 0x41,0x41,0x77,0x3E,0x08,0x08,0x00,0x00 },         // 125  [0x7d]\n\t{ 0x02,0x01,0x01,0x03,0x02,0x02,0x01,0x00 },         // 126  [0x7e]\n\t{ 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x00 },         // 127  [0x7f]\n\n\t//dotted frame\n\t{ 0x00,0x00,0x00,0xA8,0x00,0x08,0x00,0x08 },         // 128  [0x80] TL\n\t{ 0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08 },         // 129  [0x81] T/B\n\t{ 0x00,0x08,0x00,0xA8,0x00,0x00,0x00,0x00 },         // 130  [0x82] TR\n\t{ 0x00,0x00,0x00,0xAA,0x00,0x00,0x00,0x00 },         // 131  [0x83] L/R\n\t{ 0x00,0x08,0x00,0x0A,0x00,0x00,0x00,0x00 },         // 132  [0x84] BR\n\t{ 0x00,0x00,0x00,0x0A,0x00,0x08,0x00,0x08 },         // 133  [0x85] BL\n\n\t//solid frame\n\t{ 0x00,0x00,0x00,0xF8,0x08,0x08,0x08,0x08 },         // 134  [0x86] TL\n\t{ 0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08 },         // 135  [0x87] T/B\n\t{ 0x08,0x08,0x08,0xF8,0x00,0x00,0x00,0x00 },         // 136  [0x88] TR\n\t{ 0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00 },         // 137  [0x89] L/R\n\t{ 0x08,0x08,0x08,0x0F,0x00,0x00,0x00,0x00 },         // 138  [0x8A] BR\n\t{ 0x00,0x00,0x00,0x0F,0x08,0x08,0x08,0x08 },         // 139  [0x8B] BL\n\n\t{ 0x7F,0x41,0x41,0x41,0x41,0x41,0x7F,0x00 },         // 140  [0x8C] empty square\n\t{ 0x1C,0x1C,0x3E,0x7F,0x00,0x2A,0x49,0x00 },         // 141  [0x8D] speaker\n\t{ 0x7F,0x61,0x61,0x61,0x61,0x61,0x7F,0x00 },         // 142  [0x8E] fill 1\n\t{ 0x7F,0x71,0x71,0x71,0x71,0x71,0x7F,0x00 },         // 143  [0x8F] fill 2\n\t{ 0x7F,0x79,0x79,0x79,0x79,0x79,0x7F,0x00 },         // 144  [0x90] fill 3\n\t{ 0x7F,0x7D,0x7D,0x7D,0x7D,0x7D,0x7F,0x00 },         // 145  [0x91] fill 4\n\n\t{ 0x2A,0x7F,0x41,0x41,0x41,0x7F,0x2A,0x00 },         // 146  [0x92] mem-none\n\t{ 0x2A,0x7F,0x41,0x71,0x79,0x7F,0x2A,0x00 },         // 147  [0x93] mem32\n\t{ 0x2A,0x7F,0x79,0x79,0x79,0x7F,0x2A,0x00 },         // 148  [0x94] mem64\n\t{ 0x2A,0x7F,0x7F,0x7F,0x7F,0x7F,0x2A,0x00 },         // 149  [0x95] mem128\n\t{ 0x10,0x30,0x60,0x70,0x3C,0x0F,0x03,0x00 },         // 150  [0x96] Mark sign\n};\n\nstatic unsigned char tempfont[2048];\n\nvoid LoadFont(char* name)\n{\n\tmemset(tempfont, 0, sizeof(tempfont));\n\n\tint sz = FileLoad(name, tempfont, sizeof(tempfont));\n\tif (sz <= 0) return;\n\n\tint ch = 32;\n\tint start = 0;\n\tif (sz != 768)\n\t{\n\t\tstart = 32 * 8;\n\t\tfor (int i = 0; i < 32 * 8; i++) if (tempfont[i])\n\t\t{\n\t\t\tch = 0;\n\t\t\tstart = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int pos = start; pos < sz; pos += 8)\n\t{\n\t\tint n = 0;\n\t\tfor (int i = 128; i != 0; i >>= 1)\n\t\t{\n\t\t\tunsigned char b = 0;\n\t\t\tif (tempfont[pos + 0] & i) b |= 1;\n\t\t\tif (tempfont[pos + 1] & i) b |= 2;\n\t\t\tif (tempfont[pos + 2] & i) b |= 4;\n\t\t\tif (tempfont[pos + 3] & i) b |= 8;\n\t\t\tif (tempfont[pos + 4] & i) b |= 16;\n\t\t\tif (tempfont[pos + 5] & i) b |= 32;\n\t\t\tif (tempfont[pos + 6] & i) b |= 64;\n\t\t\tif (tempfont[pos + 7] & i) b |= 128;\n\n\t\t\tcharfont[ch][n++] = b;\n\t\t}\n\n\t\tch++;\n\t}\n}\n"
        },
        {
          "name": "charrom.h",
          "type": "blob",
          "size": 0.109375,
          "content": "#ifndef CHARROM_H\n#define CHARROM_H\n\nextern unsigned char charfont[256][8];\n\nvoid LoadFont(char* name);\n\n#endif\n"
        },
        {
          "name": "cheats.cpp",
          "type": "blob",
          "size": 11.21875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <ctype.h>\n#include <vector>\n#include <algorithm>\n\n#include \"hardware.h\"\n#include \"file_io.h\"\n#include \"user_io.h\"\n#include \"fpga_io.h\"\n#include \"miniz.h\"\n#include \"osd.h\"\n#include \"cheats.h\"\n#include \"support.h\"\n\nstruct cheat_rec_t\n{\n\tbool enabled;\n\tchar name[256];\n\tint cheatSize;\n\tchar *cheatData;\n\n\tcheat_rec_t()\n\t{\n\t\tthis->enabled = false;\n\t\tthis->cheatData = NULL;\n\t\tthis->cheatSize = 0;\n\t\tmemset(name, 0, sizeof(name));\n\t}\n\n\t~cheat_rec_t()\n\t{\n\t\tif (this->cheatData)\n\t\t{\n\t\t\tdelete[] this->cheatData;\n\t\t}\n\t}\n};\n\ntypedef std::vector<cheat_rec_t> CheatVector;\nstatic CheatVector cheats;\n\nstatic int iSelectedEntry = 0;\nstatic int iFirstEntry = 0;\nstatic int loaded = 0;\n\nstruct CheatComp\n{\n\tbool operator()(const cheat_rec_t& ce1, const cheat_rec_t& ce2)\n\t{\n\t\tint len1 = strlen(ce1.name);\n\t\tint len2 = strlen(ce2.name);\n\n\t\tint len = (len1 < len2) ? len1 : len2;\n\t\tint ret = strncasecmp(ce1.name, ce2.name, len);\n\t\tif (!ret)\n\t\t{\n\t\t\treturn len1 < len2;\n\t\t}\n\n\t\treturn ret < 0;\n\t}\n};\n\nstatic char cheat_zip[1024] = {};\n\nstatic int find_by_crc(uint32_t romcrc)\n{\n\tif (!romcrc) return 0;\n\n\tsprintf(cheat_zip, \"%s/cheats/%s\", getRootDir(), CoreName2);\n\tDIR *d = opendir(cheat_zip);\n\tif (!d)\n\t{\n\t\tprintf(\"Couldn't open dir: %s\\n\", cheat_zip);\n\t\treturn 0;\n\t}\n\n\tstruct dirent *de;\n\twhile ((de = readdir(d)))\n\t{\n\t\tif (de->d_type == DT_REG)\n\t\t{\n\t\t\tint len = strlen(de->d_name);\n\t\t\tif (len >= 14 && de->d_name[len - 14] == '[' && !strcasecmp(de->d_name + len - 5, \"].zip\"))\n\t\t\t{\n\t\t\t\tuint32_t crc = 0;\n\t\t\t\tif (sscanf(de->d_name + len - 14, \"[%X].zip\", &crc) == 1)\n\t\t\t\t{\n\t\t\t\t\tif (crc == romcrc)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcat(cheat_zip, \"/\");\n\t\t\t\t\t\tstrcat(cheat_zip, de->d_name);\n\t\t\t\t\t\tclosedir(d);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclosedir(d);\n\treturn 0;\n}\n\nstatic int find_in_same_dir(const char *name)\n{\n\tsprintf(cheat_zip, \"%s/%s\", getRootDir(), name);\n\tchar *p = strrchr(cheat_zip, '/'); //impossible to fail\n\t*p = 0;\n\n\tDIR *d = opendir(cheat_zip);\n\tif (!d)\n\t{\n\t\tprintf(\"Couldn't open dir: %s\\n\", cheat_zip);\n\t\treturn 0;\n\t}\n\n\tstruct dirent *de;\n\twhile ((de = readdir(d)))\n\t{\n\t\tif (de->d_type == DT_REG)\n\t\t{\n\t\t\tint len = strlen(de->d_name);\n\t\t\tif (len >= 4 && !strcasecmp(de->d_name + len - 4, \".zip\"))\n\t\t\t{\n\t\t\t\tstrcat(cheat_zip, \"/\");\n\t\t\t\tstrcat(cheat_zip, de->d_name);\n\t\t\t\tclosedir(d);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tclosedir(d);\n\treturn 0;\n}\n\n\nbool cheat_init_psx(mz_zip_archive* _z, const char *rom_path)\n{\n\t// lookup based on file name\n\tconst char *rom_name = strrchr(rom_path, '/');\n\tif (rom_name)\n\t{\n\t\tsprintf(cheat_zip, \"%s/cheats/%s%s\", getRootDir(), CoreName2, rom_name);\n\t\tchar *p = strrchr(cheat_zip, '.');\n\t\tif (p) *p = 0;\n\t\tstrcat(cheat_zip, \".zip\");\n\t\tprintf(\"Trying cheat file: %s\\n\", cheat_zip);\n\n\t\tmemset(_z, 0, sizeof(mz_zip_archive));\n\t\tif (mz_zip_reader_init_file(_z, cheat_zip, 0)) return true;\n\t}\n\n\t// lookup based on game ID\n\tconst char *game_id = psx_get_game_id();\n\tif (game_id && game_id[0])\n\t{\n\t\tsprintf(cheat_zip, \"%s/cheats/%s/%s.zip\", getRootDir(), CoreName2, psx_get_game_id());\n\t\tprintf(\"Trying cheat file: %s\\n\", cheat_zip);\n\t\tmemset(_z, 0, sizeof(mz_zip_archive));\n\t\tif (mz_zip_reader_init_file(_z, cheat_zip, 0)) return true;\n\t}\n\n\treturn false;\n}\n\nvoid cheats_init(const char *rom_path, uint32_t romcrc)\n{\n\tcheats.clear();\n\tloaded = 0;\n\tcheat_zip[0] = 0;\n\n\t// reset cheats\n\tif (!is_n64())\n\t{\n\t\tuser_io_set_index(255);\n\t\tuser_io_set_download(1);\n\t\tuser_io_file_tx_data((const uint8_t*)&loaded, 2);\n\t\tuser_io_set_download(0);\n\t}\n\n\tif (!strcasestr(rom_path, \".zip\"))\n\t{\n\t\tsprintf(cheat_zip, \"%s/%s\", getRootDir(), rom_path);\n\t\tchar *p = strrchr(cheat_zip, '.');\n\t\tif (p) *p = 0;\n\t\tstrcat(cheat_zip, \".zip\");\n\t}\n\n\tmz_zip_archive _z = {};\n\n\tif (is_psx() && !mz_zip_reader_init_file(&_z, cheat_zip, 0))\n\t{\n\t\tif (!cheat_init_psx(&_z, rom_path))\n\t\t{\n\t\t\tprintf(\"no cheat file found\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (!mz_zip_reader_init_file(&_z, cheat_zip, 0))\n\t{\n\t\tmemset(&_z, 0, sizeof(_z));\n\t\tif (!(pcecd_using_cd() || is_megacd()) || !find_in_same_dir(rom_path) || !mz_zip_reader_init_file(&_z, cheat_zip, 0))\n\t\t{\n\t\t\tmemset(&_z, 0, sizeof(_z));\n\t\t\tconst char *rom_name = strrchr(rom_path, '/');\n\t\t\tif (rom_name)\n\t\t\t{\n\t\t\t\tsprintf(cheat_zip, \"%s/cheats/%s%s%s\", getRootDir(), CoreName2, pcecd_using_cd() ? \"CD\" : \"\", rom_name);\n\t\t\t\tchar *p = strrchr(cheat_zip, '.');\n\t\t\t\tif (p) *p = 0;\n\t\t\t\tif (pcecd_using_cd() || is_megacd()) strcat(cheat_zip, \" []\");\n\t\t\t\tstrcat(cheat_zip, \".zip\");\n\n\t\t\t\tif (!mz_zip_reader_init_file(&_z, cheat_zip, 0))\n\t\t\t\t{\n\t\t\t\t\tmemset(&_z, 0, sizeof(_z));\n\t\t\t\t\tif (!find_by_crc(romcrc) || !mz_zip_reader_init_file(&_z, cheat_zip, 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"no cheat file found\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!find_by_crc(romcrc) || !mz_zip_reader_init_file(&_z, cheat_zip, 0))\n\t\t\t\t{\n\t\t\t\t\tprintf(\"no cheat file found\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Using cheat file: %s\\n\", cheat_zip);\n\n\tmz_zip_archive *z = new mz_zip_archive(_z);\n\tfor (size_t i = 0; i < mz_zip_reader_get_num_files(z); i++)\n\t{\n\t\tcheat_rec_t ch = {};\n\t\tmz_zip_reader_get_filename(z, i, ch.name, sizeof(ch.name));\n\n\t\tif (mz_zip_reader_is_file_a_directory(z, i))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tcheats.push_back(ch);\n\t}\n\n\tmz_zip_reader_end(z);\n\tdelete z;\n\n\tstd::sort(cheats.begin(), cheats.end(), CheatComp());\n\n\tprintf(\"cheats: %d\\n\", cheats_available());\n\tcheats_scan(SCANF_INIT);\n}\n\nint cheats_available()\n{\n\treturn cheats.size();\n}\n\nvoid cheats_scan(int mode)\n{\n\tif (mode == SCANF_INIT)\n\t{\n\t\tiFirstEntry = 0;\n\t\tiSelectedEntry = 0;\n\t}\n\telse\n\t{\n\t\tif (!cheats_available()) return;\n\n\t\tif (mode == SCANF_END || (mode == SCANF_PREV && iSelectedEntry <= 0))\n\t\t{\n\t\t\tiSelectedEntry = cheats_available() - 1;\n\t\t\tiFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t}\n\t\telse if (mode == SCANF_NEXT)\n\t\t{\n\t\t\tif (iSelectedEntry + 1 < cheats_available()) // scroll within visible items\n\t\t\t{\n\t\t\t\tiSelectedEntry++;\n\t\t\t\tif (iSelectedEntry > iFirstEntry + OsdGetSize() - 1) iFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// jump to first visible item\n\t\t\t\tiFirstEntry = 0;\n\t\t\t\tiSelectedEntry = 0;\n\t\t\t}\n\t\t}\n\t\telse if (mode == SCANF_PREV)\n\t\t{\n\t\t\tif (iSelectedEntry > 0) // scroll within visible items\n\t\t\t{\n\t\t\t\tiSelectedEntry--;\n\t\t\t\tif (iSelectedEntry < iFirstEntry) iFirstEntry = iSelectedEntry;\n\t\t\t}\n\t\t}\n\t\telse if (mode == SCANF_NEXT_PAGE)\n\t\t{\n\t\t\tif (iSelectedEntry < iFirstEntry + OsdGetSize() - 1)\n\t\t\t{\n\t\t\t\tiSelectedEntry = iFirstEntry + OsdGetSize() - 1;\n\t\t\t\tif (iSelectedEntry >= cheats_available()) iSelectedEntry = cheats_available() - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiSelectedEntry += OsdGetSize();\n\t\t\t\tiFirstEntry += OsdGetSize();\n\t\t\t\tif (iSelectedEntry >= cheats_available())\n\t\t\t\t{\n\t\t\t\t\tiSelectedEntry = cheats_available() - 1;\n\t\t\t\t\tiFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t\t}\n\t\t\t\telse if (iFirstEntry + OsdGetSize() > cheats_available())\n\t\t\t\t{\n\t\t\t\t\tiFirstEntry = cheats_available() - OsdGetSize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (mode == SCANF_PREV_PAGE)\n\t\t{\n\t\t\tif (iSelectedEntry != iFirstEntry)\n\t\t\t{\n\t\t\t\tiSelectedEntry = iFirstEntry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiFirstEntry -= OsdGetSize();\n\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t\tiSelectedEntry = iFirstEntry;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid cheats_scroll_name()\n{\n\t// this function is called periodically when file selection window is displayed\n\t// it checks if predefined period of time has elapsed and scrolls the name if necessary\n\tint len;\n\tint max_len;\n\tstatic char name[256 + 4];\n\n\tname[0] = 32;\n\tname[1] = cheats[iSelectedEntry].enabled ? 0x1a : 0x1b;\n\tname[2] = 32;\n\tstrcpy(name + 3, cheats[iSelectedEntry].name);\n\n\tlen = strlen(name); // get name length\n\tif (len > 3 && !strncasecmp(name + len - 3, \".gg\", 3)) len -= 3;\n\n\tmax_len = 30;\n\tScrollText(iSelectedEntry - iFirstEntry, name, 3, len, max_len, 1);\n}\n\nvoid cheats_print()\n{\n\tint k;\n\tint len;\n\n\tstatic char s[256 + 4];\n\n\tScrollReset();\n\n\tfor (int i = 0; i < OsdGetSize(); i++)\n\t{\n\t\tchar leftchar = 0;\n\t\tif (i < cheats_available())\n\t\t{\n\t\t\tk = iFirstEntry + i;\n\n\t\t\ts[0] = 32;\n\t\t\ts[1] = cheats[k].enabled ? 0x1a : 0x1b;\n\t\t\ts[2] = 32;\n\t\t\tstrcpy(s + 3, cheats[k].name);\n\n\t\t\tlen = strlen(s); // get name length\n\t\t\tif (len > 3 && !strncasecmp(s + len - 3, \".gg\", 3)) len -= 3;\n\t\t\ts[len] = 0;\n\n\t\t\tif (len > 28)\n\t\t\t{\n\t\t\t\tlen = 27; // trim display length if longer than 30 characters\n\t\t\t\ts[28] = 22;\n\t\t\t}\n\n\t\t\ts[29] = 0;\n\n\t\t\tif (!i && k) leftchar = 17;\n\t\t\tif ((i == OsdGetSize() - 1) && (k < cheats_available() - 1)) leftchar = 16;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(s, ' ', 32);\n\t\t}\n\n\t\tOsdWriteOffset(i, s, i == (iSelectedEntry - iFirstEntry), 0, 0, leftchar);\n\t}\n}\n\n#define CHEAT_SIZE (128*16) // 128 codes max\n\nstatic void cheats_send()\n{\n\tstatic uint8_t buff[CHEAT_SIZE];\n\tint pos = 0;\n\n\tfor (int i = 0; i < cheats_available(); i++)\n\t{\n\t\tif (cheats[i].enabled)\n\t\t{\n\t\t\tif (cheats[i].cheatData)\n\t\t\t{\n\t\t\t\tmemcpy(&buff[pos], cheats[i].cheatData, cheats[i].cheatSize);\n\t\t\t\tpos += cheats[i].cheatSize;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"Consistency error, memory for cheat not allocated, but cheat was enabled -> disable.\\n\");\n\t\t\t\tcheats[i].cheatSize = 0;\n\t\t\t\tcheats[i].enabled = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tloaded = pos / 16;\n\tprintf(\"Cheat codes: %d\\n\", loaded);\n\n\tif (is_n64())\n\t{\n\t\tn64_cheats_send(buff, loaded);\n\t}\n\telse\n\t{\n\t\tuser_io_set_index(255);\n\t\tuser_io_set_download(1);\n\t\tuser_io_file_tx_data(buff, pos ? pos : 2);\n\t\tuser_io_set_download(0);\n\t}\n}\n\nvoid cheats_toggle()\n{\n\tbool changedCheats = false;\n\n\tif (cheats[iSelectedEntry].enabled == true)\n\t{\n\t\t/* disabled loaded cheat, free data */\n\t\tif (cheats[iSelectedEntry].cheatData)\n\t\t{\n\t\t\tdelete[] cheats[iSelectedEntry].cheatData;\n\t\t\tcheats[iSelectedEntry].cheatData = NULL;\n\t\t}\n\n\t\tcheats[iSelectedEntry].enabled = false;\n\t\tcheats[iSelectedEntry].cheatSize = 0;\n\t\tchangedCheats = true;\n\t}\n\telse\n\t{\n\t\t/* enabled cheat, load data */\n\t\tstatic char filename[1024];\n\t\tfileTYPE f = {};\n\n\t\tif (cheats[iSelectedEntry].cheatData)\n\t\t{\n\t\t\tprintf(\"Consistency error, memory for cheat already allocated -> cleanup.\\n\");\n\t\t\tdelete[] cheats[iSelectedEntry].cheatData;\n\t\t\tcheats[iSelectedEntry].cheatData = NULL;\n\t\t\tcheats[iSelectedEntry].cheatSize = 0;\n\t\t}\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\", cheat_zip, cheats[iSelectedEntry].name);\n\t\tif (FileOpen(&f, filename))\n\t\t{\n\t\t\tint len = f.size;\n\t\t\tif (!len || (len & 15))\n\t\t\t{\n\t\t\t\tprintf(\"Cheat file %s has incorrect length %d -> skipping.\\n\", filename, len);\n\t\t\t}\n\t\t\telse if ((len + cheats_loaded() * 16) <= CHEAT_SIZE)\n\t\t\t{\n\t\t\t\tcheats[iSelectedEntry].cheatData = new char[len];\n\t\t\t\tif (cheats[iSelectedEntry].cheatData)\n\t\t\t\t{\n\t\t\t\t\tif (FileReadAdv(&f, cheats[iSelectedEntry].cheatData, len) == len)\n\t\t\t\t\t{\n\t\t\t\t\t\tcheats[iSelectedEntry].cheatSize = len;\n\t\t\t\t\t\tcheats[iSelectedEntry].enabled = true;\n\t\t\t\t\t\tchangedCheats = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"Cannot read cheat file %s.\\n\", filename);\n\t\t\t\t\t\tdelete[] cheats[iSelectedEntry].cheatData;\n\t\t\t\t\t\tcheats[iSelectedEntry].cheatData = NULL;\n\t\t\t\t\t\tcheats[iSelectedEntry].cheatSize = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Could not allocate required memory (%d) for cheat file %s.\\n\", len, filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"No more room in current selection for cheat file %s.\\n\", filename);\n\t\t\t}\n\t\t\tFileClose(&f);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Cannot open cheat file %s.\\n\", filename);\n\t\t}\n\t}\n\n\tif (changedCheats)\n\t{\n\t\tcheats_send();\n\t}\n}\n\nint cheats_loaded()\n{\n\treturn loaded;\n}"
        },
        {
          "name": "cheats.h",
          "type": "blob",
          "size": 0.2373046875,
          "content": "#ifndef CHEATS_H\n#define CHEATS_H\n\nvoid cheats_init(const char *rom_path, uint32_t romcrc);\nint cheats_available();\nvoid cheats_scan(int mode);\nvoid cheats_scroll_name();\nvoid cheats_print();\nvoid cheats_toggle();\nint cheats_loaded();\n\n#endif\n"
        },
        {
          "name": "clean.sh",
          "type": "blob",
          "size": 0.0302734375,
          "content": "#!/bin/bash\n\nmake clean\nexit 0\n"
        },
        {
          "name": "coeff_nn.txt",
          "type": "blob",
          "size": 0.625,
          "content": "# range -128..128\n# sum of line must not exceed the range!\n\n# Near Neighbor\n\n# horizontal coefficients\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n\n# vertical coefficients\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 128, 0, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n   0, 0, 128, 0\n"
        },
        {
          "name": "coeff_pp.txt",
          "type": "blob",
          "size": 0.7841796875,
          "content": "# range -128..128\r\n# sum of line must not exceed the range!\r\n\r\n# Lanczos2\r\n\r\n# horizontal coefficients\r\n -24, 176, -24,   0\r\n -20, 174, -26,   0\r\n -16, 169, -26,   1\r\n -11, 160, -23,   2\r\n  -6, 147, -16,   3\r\n  -1, 129,  -4,   4\r\n   2, 109,  11,   6\r\n   5,  84,  32,   7\r\n   6,  58,  58,   6\r\n   6,  22,  96,   4\r\n   5,   3, 119,   1\r\n   4, -12, 140,  -4\r\n   2, -20, 154,  -8\r\n   1, -25, 165, -13\r\n   0, -26, 172, -18\r\n   0, -25, 175, -22\r\n\r\n# vertical coefficients\r\n   0, 128,   0,   0\r\n  -4, 126,   6,   0\r\n  -8, 124,  13,  -1\r\n -10, 119,  20,  -1\r\n -11, 111,  30,  -2\r\n -11, 103,  40,  -4\r\n -10,  93,  50,  -5\r\n  -9,  82,  61,  -6\r\n  -8,  72,  72,  -8\r\n  -6,  56,  88, -10\r\n  -4,  45,  98, -11\r\n  -3,  35, 107, -11\r\n  -2,  25, 115, -10\r\n  -1,  17, 121,  -9\r\n   0,   9, 125,  -6\r\n   0,   3, 127,  -2\r\n"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 1.052734375,
          "content": "// this file allows to enabled and disable rs232 debugging on a detailed basis\n#ifndef DEBUG_H\n#define DEBUG_H\n\n#include \"hardware.h\"\n\n\n// ------------ generic debugging -----------\n#if 0\n#define menu_debugf(...) printf(__VA_ARGS__)\n#else\n#define menu_debugf(...)\n#endif\n\n#if 1\n// ini_parser debug output\n#define ini_parser_debugf(a, ...) printf(\"\\033[1;32mINI_PARSER : \" a \"\\033[0m\\n\",## __VA_ARGS__)\n#else\n#define ini_parser_debugf(...)\n#endif\n\n\n// ----------- minimig debugging -------------\n#if 0\n#define hdd_debugf(a, ...) printf(\"\\033[1;32mHDD: \" a \"\\033[0m\\n\", ##__VA_ARGS__)\n#else\n#define hdd_debugf(...)\n#endif\n\n#if 0\n#define fdd_debugf(...) iprintf(__VA_ARGS__)\n#else\n#define fdd_debugf(...)\n#endif\n\n\n// -------------- TOS debugging --------------\n#if 1\n#define tos_debugf(a, ...) printf(\"\\033[1;32mTOS: \" a \"\\033[0m\\n\", ##__VA_ARGS__)\n#else\n#define tos_debugf(...)\n#endif\n\n#if 1\n// ikbd debug output in red\n#define IKBD_DEBUG\n#define ikbd_debugf(a, ...) printf(\"\\033[1;32mIKBD: \" a \"\\033[0m\\n\", ##__VA_ARGS__)\n#else\n#define ikbd_debugf(...)\n#endif\n\n#endif // DEBUG_H\n"
        },
        {
          "name": "file_io.cpp",
          "type": "blob",
          "size": 43.88671875,
          "content": "#include \"file_io.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n#include <fcntl.h>\n#include <strings.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <ctype.h>\n#include <sys/vfs.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <sys/mount.h>\n#include <linux/magic.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include \"lib/miniz/miniz.h\"\n#include \"osd.h\"\n#include \"fpga_io.h\"\n#include \"menu.h\"\n#include \"errno.h\"\n#include \"DiskImage.h\"\n#include \"user_io.h\"\n#include \"cfg.h\"\n#include \"input.h\"\n#include \"miniz.h\"\n#include \"scheduler.h\"\n#include \"video.h\"\n#include \"support.h\"\n\n#define MIN(a,b) (((a)<(b)) ? (a) : (b))\n\ntypedef std::vector<direntext_t> DirentVector;\ntypedef std::set<std::string> DirNameSet;\n\nstatic const size_t YieldIterations = 128;\n\nDirentVector DirItem;\nDirNameSet DirNames;\n\n\n// Directory scanning can cause the same zip file to be opened multiple times\n// due to testing file types to adjust the path\n// (and the fact the code path is shared with regular files)\n// cache the opened mz_zip_archive so we only open it once\n// this has the extra benefit that if a user is navigating through multiple directories\n// in a zip archive, the zip will only be opened once and things will be more responsive\n// ** We have to open the file outselves with open() so we can set O_CLOEXEC to prevent\n// leaking the file descriptor when the user changes cores\n\nstatic mz_zip_archive last_zip_archive = {};\nstatic int last_zip_fd = -1;\nstatic FILE *last_zip_cfile = NULL;\nstatic char last_zip_fname[256] = {};\nstatic char scanned_path[1024] = {};\nstatic int scanned_opts = 0;\n\nstatic int iSelectedEntry = 0;       // selected entry index\nstatic int iFirstEntry = 0;\n\nstatic char full_path[2100];\nuint8_t loadbuf[LOADBUF_SZ];\n\nfileTYPE::fileTYPE()\n{\n\tfilp = 0;\n\tmode = 0;\n\ttype = 0;\n\tzip = 0;\n\tsize = 0;\n\toffset = 0;\n}\n\nfileTYPE::~fileTYPE()\n{\n\tFileClose(this);\n}\n\nint fileTYPE::opened()\n{\n\treturn filp || zip;\n}\n\nstruct fileZipArchive\n{\n\tmz_zip_archive                    archive;\n\tint                               index;\n\tmz_zip_reader_extract_iter_state* iter;\n\t__off64_t                         offset;\n};\n\n\nstatic int OpenZipfileCached(char *path, int flags)\n{\n  if (last_zip_fname[0] && !strcasecmp(path, last_zip_fname))\n  {\n    return 1;\n  }\n\n  mz_zip_reader_end(&last_zip_archive);\n  mz_zip_zero_struct(&last_zip_archive);\n  if (last_zip_cfile)\n  {\n    fclose(last_zip_cfile);\n    last_zip_cfile = nullptr;\n  }\n\n  last_zip_fname[0] = '\\0';\n  last_zip_fd = open(path, O_RDONLY|O_CLOEXEC);\n  if (last_zip_fd < 0)\n  {\n    return 0;\n  }\n\n  last_zip_cfile = fdopen(last_zip_fd, \"r\");\n  if (!last_zip_cfile)\n  {\n    close(last_zip_fd);\n    last_zip_fd = -1;\n    return 0;\n  }\n\n  int mz_ret = mz_zip_reader_init_cfile(&last_zip_archive, last_zip_cfile, 0, flags);\n  if (mz_ret)\n  {\n    strncpy(last_zip_fname, path, sizeof(last_zip_fname));\n  }\n  return mz_ret;\n}\n\n\nstatic int FileIsZipped(char* path, char** zip_path, char** file_path)\n{\n\tchar* z = strcasestr(path, \".zip\");\n\tif (z)\n\t{\n\t\tz += 4;\n\t\tif (!z[0]) z[1] = 0;\n\t\t*z++ = 0;\n\n\t\tif (zip_path) *zip_path = path;\n\t\tif (file_path) *file_path = z;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic char* make_fullpath(const char *path, int mode = 0)\n{\n\tif (path[0] != '/')\n\t{\n\t\tsprintf(full_path, \"%s/%s\", (mode == -1) ? \"\" : getRootDir(), path);\n\t}\n\telse\n\t{\n\t\tsprintf(full_path, \"%s\",path);\n\t}\n\n\treturn full_path;\n}\n\nstatic int get_stmode(const char *path)\n{\n\tstruct stat64 st;\n\treturn (stat64(path, &st) < 0) ? 0 : st.st_mode;\n}\n\nstruct stat64* getPathStat(const char *path)\n{\n\tmake_fullpath(path);\n\tstatic struct stat64 st;\n\treturn (stat64(full_path, &st) >= 0) ? &st : NULL;\n}\n\nstatic int isPathDirectory(const char *path, int use_zip = 1)\n{\n\tmake_fullpath(path);\n\n\tchar *zip_path, *file_path;\n\tif (use_zip && FileIsZipped(full_path, &zip_path, &file_path))\n\t{\n\t\tif (!*file_path)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!OpenZipfileCached(full_path, 0))\n\t\t{\n\t\t\tprintf(\"isPathDirectory(OpenZipfileCached) Zip:%s, error:%s\\n\", zip_path,\n\t\t\t\tmz_zip_get_error_string(mz_zip_get_last_error(&last_zip_archive)));\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Folder names always end with a slash in the zip\n\t\t// file central directory.\n\t\tstrcat(file_path, \"/\");\n\n\t\t// Some zip files don't have directory entries\n\t\t// Use the locate_file call to try and find the directory entry first, since\n\t\t// this is a binary search (usually) If that fails then scan for the first\n\t\t// entry that starts with file_path\n\n\t\tconst int file_index = mz_zip_reader_locate_file(&last_zip_archive, file_path, NULL, 0);\n\t\tif (file_index >= 0 && mz_zip_reader_is_file_a_directory(&last_zip_archive, file_index))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\tfor (size_t i = 0; i < mz_zip_reader_get_num_files(&last_zip_archive); i++)\n\t\t{\n\t\t\tchar zip_fname[256];\n\t\t\tmz_zip_reader_get_filename(&last_zip_archive, i, &zip_fname[0], sizeof(zip_fname));\n\t\t\tif (strcasestr(zip_fname, file_path))\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint stmode = get_stmode(full_path);\n\t\tif (!stmode)\n\t\t{\n\t\t\t//printf(\"isPathDirectory(stat) path: %s, error: %s.\\n\", full_path, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (stmode & S_IFDIR) return 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int isPathRegularFile(const char *path, int use_zip = 1)\n{\n\tmake_fullpath(path);\n\n\tchar *zip_path, *file_path;\n\tif (use_zip && FileIsZipped(full_path, &zip_path, &file_path))\n\t{\n\t\t//If there's no path into the zip file, don't bother opening it, we're a \"directory\"\n\t\tif (!*file_path)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (!OpenZipfileCached(full_path, 0))\n\t\t{\n\t\t\t//printf(\"isPathRegularFile(mz_zip_reader_init_file) Zip:%s, error:%s\\n\", zip_path,\n\t\t\t//       mz_zip_get_error_string(mz_zip_get_last_error(&z)));\n\t\t\treturn 0;\n\t\t}\n\t\tconst int file_index = mz_zip_reader_locate_file(&last_zip_archive, file_path, NULL, 0);\n\t\tif (file_index < 0)\n\t\t{\n\t\t\t//printf(\"isPathRegularFile(mz_zip_reader_locate_file) Zip:%s, file:%s, error: %s\\n\",\n\t\t\t//\t\t zip_path, file_path,\n\t\t\t//\t\t mz_zip_get_error_string(mz_zip_get_last_error(&z)));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!mz_zip_reader_is_file_a_directory(&last_zip_archive, file_index) && mz_zip_reader_is_file_supported(&last_zip_archive, file_index))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (get_stmode(full_path) & S_IFREG) return true;\n\t}\n\n\treturn 0;\n}\n\nvoid FileClose(fileTYPE *file)\n{\n\tif (file->zip)\n\t{\n\t\tif (file->zip->iter)\n\t\t{\n\t\t\tmz_zip_reader_extract_iter_free(file->zip->iter);\n\t\t}\n\t\tmz_zip_reader_end(&file->zip->archive);\n\n\t\tdelete file->zip;\n\t}\n\n\tif (file->filp)\n\t{\n\t\t//printf(\"closing %p\\n\", file->filp);\n\t\tfclose(file->filp);\n\t\tif (file->type == 1)\n\t\t{\n\t\t\tif (file->name[0] == '/')\n\t\t\t{\n\t\t\t\tshm_unlink(file->name);\n\t\t\t}\n\t\t\tfile->type = 0;\n\t\t}\n\t}\n\n\tfile->zip = nullptr;\n\tfile->filp = nullptr;\n\tfile->size = 0;\n}\n\nstatic int zip_search_by_crc(mz_zip_archive *zipArchive, uint32_t crc32)\n{\n\tfor (unsigned int file_index = 0; file_index < zipArchive->m_total_files; file_index++)\n\t{\n\t\tmz_zip_archive_file_stat s;\n\t\tif (mz_zip_reader_file_stat(zipArchive, file_index, &s))\n\t\t{\n\t\t\tif (s.m_crc32 == crc32)\n\t\t\t{\n\t\t\t\treturn file_index;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint FileOpenZip(fileTYPE *file, const char *name, uint32_t crc32)\n{\n\tmake_fullpath(name);\n\tFileClose(file);\n\tfile->mode = 0;\n\tfile->type = 0;\n\n\tchar *p = strrchr(full_path, '/');\n\tstrcpy(file->name, (p) ? p + 1 : full_path);\n\n\tchar *zip_path, *file_path;\n\tif (!FileIsZipped(full_path, &zip_path, &file_path))\n\t{\n\t\tprintf(\"FileOpenZip: %s, is not a zip.\\n\", full_path);\n\t\treturn 0;\n\t}\n\n\tfile->zip = new fileZipArchive{};\n\tif (!mz_zip_reader_init_file(&file->zip->archive, zip_path, 0))\n\t{\n\t\tprintf(\"FileOpenZip(mz_zip_reader_init_file) Zip:%s, error:%s\\n\", zip_path,\n\t\t\t\t\tmz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\treturn 0;\n\t}\n\n\tfile->zip->index = -1;\n\tif (crc32) file->zip->index = zip_search_by_crc(&file->zip->archive, crc32);\n\tif (file->zip->index < 0) file->zip->index = mz_zip_reader_locate_file(&file->zip->archive, file_path, NULL, 0);\n\tif (file->zip->index < 0)\n\t{\n\t\tprintf(\"FileOpenZip(mz_zip_reader_locate_file) Zip:%s, file:%s, error: %s\\n\",\n\t\t\t\t\tzip_path, file_path,\n\t\t\t\t\tmz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\tFileClose(file);\n\t\treturn 0;\n\t}\n\n\tmz_zip_archive_file_stat s;\n\tif (!mz_zip_reader_file_stat(&file->zip->archive, file->zip->index, &s))\n\t{\n\t\tprintf(\"FileOpenZip(mz_zip_reader_file_stat) Zip:%s, file:%s, error:%s\\n\",\n\t\t\t\t\tzip_path, file_path,\n\t\t\t\t\tmz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\tFileClose(file);\n\t\treturn 0;\n\t}\n\tfile->size = s.m_uncomp_size;\n\n\tfile->zip->iter = mz_zip_reader_extract_iter_new(&file->zip->archive, file->zip->index, 0);\n\tif (!file->zip->iter)\n\t{\n\t\tprintf(\"FileOpenZip(mz_zip_reader_extract_iter_new) Zip:%s, file:%s, error:%s\\n\",\n\t\t\t\t\tzip_path, file_path,\n\t\t\t\t\tmz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\tFileClose(file);\n\t\treturn 0;\n\t}\n\n\tfile->zip->offset = 0;\n\tfile->offset = 0;\n\tfile->mode = O_RDONLY;\n\treturn 1;\n}\n\nint FileOpenEx(fileTYPE *file, const char *name, int mode, char mute, int use_zip)\n{\n\tmake_fullpath((char*)name, mode);\n\tFileClose(file);\n\tfile->mode = 0;\n\tfile->type = 0;\n\n\tchar *p = strrchr(full_path, '/');\n\tstrcpy(file->name, (mode == -1) ? full_path : p + 1);\n\n\tchar *zip_path, *file_path;\n\tif (use_zip && (mode != -1) && FileIsZipped(full_path, &zip_path, &file_path))\n\t{\n\t\tif (mode & O_RDWR || mode & O_WRONLY)\n\t\t{\n\t\t\tif(!mute) printf(\"FileOpenEx(mode) Zip:%s, writing to zipped files is not supported.\\n\",\n\t\t\t\t\t full_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfile->zip = new fileZipArchive{};\n\t\tif (!mz_zip_reader_init_file(&file->zip->archive, zip_path, 0))\n\t\t{\n\t\t\tif(!mute) printf(\"FileOpenEx(mz_zip_reader_init_file) Zip:%s, error:%s\\n\", zip_path,\n\t\t\t\t\t mz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfile->zip->index = mz_zip_reader_locate_file(&file->zip->archive, file_path, NULL, 0);\n\t\tif (file->zip->index < 0)\n\t\t{\n\t\t\tif(!mute) printf(\"FileOpenEx(mz_zip_reader_locate_file) Zip:%s, file:%s, error: %s\\n\",\n\t\t\t\t\t zip_path, file_path,\n\t\t\t\t\t mz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\t\tFileClose(file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmz_zip_archive_file_stat s;\n\t\tif (!mz_zip_reader_file_stat(&file->zip->archive, file->zip->index, &s))\n\t\t{\n\t\t\tif(!mute) printf(\"FileOpenEx(mz_zip_reader_file_stat) Zip:%s, file:%s, error:%s\\n\",\n\t\t\t\t\t zip_path, file_path,\n\t\t\t\t\t mz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\t\tFileClose(file);\n\t\t\treturn 0;\n\t\t}\n\t\tfile->size = s.m_uncomp_size;\n\n\t\tfile->zip->iter = mz_zip_reader_extract_iter_new(&file->zip->archive, file->zip->index, 0);\n\t\tif (!file->zip->iter)\n\t\t{\n\t\t\tif(!mute) printf(\"FileOpenEx(mz_zip_reader_extract_iter_new) Zip:%s, file:%s, error:%s\\n\",\n\t\t\t\t\t zip_path, file_path,\n\t\t\t\t\t mz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\t\tFileClose(file);\n\t\t\treturn 0;\n\t\t}\n\t\tfile->zip->offset = 0;\n\t\tfile->offset = 0;\n\t\tfile->mode = mode;\n\t}\n\telse\n\t{\n\t\tint fd = (mode == -1) ? shm_open(\"/vdsk\", O_CREAT | O_RDWR | O_TRUNC | O_CLOEXEC, 0777) : open(full_path, mode | O_CLOEXEC, 0777);\n\t\tif (fd <= 0)\n\t\t{\n\t\t\tif(!mute) printf(\"FileOpenEx(open) File:%s, error: %s.\\n\", full_path, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\tconst char *fmode = mode & O_RDWR ? \"w+\" : \"r\";\n\t\tfile->filp = fdopen(fd, fmode);\n\t\tif (!file->filp)\n\t\t{\n\t\t\tif(!mute) printf(\"FileOpenEx(fdopen) File:%s, error: %s.\\n\", full_path, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (mode == -1)\n\t\t{\n\t\t\tfile->type = 1;\n\t\t\tfile->size = 0;\n\t\t\tfile->offset = 0;\n\t\t\tfile->mode = O_CREAT | O_RDWR | O_TRUNC;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstruct stat64 st;\n\t\t\tint ret = fstat64(fileno(file->filp), &st);\n\t\t\tif (ret < 0)\n\t\t\t{\n\t\t\t\tif (!mute) printf(\"FileOpenEx(fstat) File:%s, error: %d.\\n\", full_path, ret);\n\t\t\t\tFileClose(file);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfile->size = st.st_size;\n\t\t\tif (st.st_rdev && !st.st_size)  //for special files we need an ioctl call to get the correct size\n\t\t\t{\n\t\t\t\tunsigned long long blksize;\n\t\t\t\tint ret = ioctl(fd, BLKGETSIZE64, &blksize);\n\t\t\t\tif (ret < 0)\n\t\t\t\t{\n\t\t\t\t\tif (!mute) printf(\"FileOpenEx(ioctl) File:%s, error: %d.\\n\", full_path, ret);\n\t\t\t\t\tFileClose(file);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tfile->size = blksize;\n\t\t\t}\n\n\t\t\tfile->offset = 0;\n\t\t\tfile->mode = mode;\n\t\t}\n\t}\n\n\t//printf(\"opened %s, size %llu\\n\", full_path, file->size);\n\treturn 1;\n}\n\n__off64_t FileGetSize(fileTYPE *file)\n{\n\tif (file->filp)\n\t{\n\t\tstruct stat64 st;\n\t\tif (fstat64(fileno(file->filp), &st) < 0) return 0;\n\n\t\tif (st.st_rdev && !st.st_size)  //for special files we need an ioctl call to get the correct size\n\t\t{\n\t\t\tunsigned long long blksize;\n\t\t\tint ret = ioctl(fileno(file->filp), BLKGETSIZE64, &blksize);\n\t\t\tif (ret < 0) return 0;\n\t\t\treturn blksize;\n\t\t}\n\n\t\treturn st.st_size;\n\t}\n\telse if (file->zip)\n\t{\n\t\treturn file->size;\n\t}\n\treturn 0;\n}\n\nint FileOpen(fileTYPE *file, const char *name, char mute)\n{\n\treturn FileOpenEx(file, name, O_RDONLY, mute);\n}\n\nint FileSeek(fileTYPE *file, __off64_t offset, int origin)\n{\n\tif (file->filp)\n\t{\n\t\t__off64_t res = fseeko64(file->filp, offset, origin);\n\t\tif (res < 0)\n\t\t{\n\t\t\tprintf(\"Fail to seek the file: offset=%lld, %s.\\n\", offset, file->name);\n\t\t\treturn 0;\n\t\t}\n\t\toffset = ftello64(file->filp);\n\t}\n\telse if (file->zip)\n\t{\n\t\tif (origin == SEEK_CUR)\n\t\t{\n\t\t\toffset = file->zip->offset + offset;\n\t\t}\n\t\telse if (origin == SEEK_END)\n\t\t{\n\t\t\toffset = file->size - offset;\n\t\t}\n\n\t\tif (offset < file->zip->offset)\n\t\t{\n\t\t\tmz_zip_reader_extract_iter_state *iter = mz_zip_reader_extract_iter_new(&file->zip->archive, file->zip->index, 0);\n\t\t\tif (!iter)\n\t\t\t{\n\t\t\t\tprintf(\"FileSeek(mz_zip_reader_extract_iter_new) Failed to rewind iterator, error:%s\\n\",\n\t\t\t\t       mz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tmz_zip_reader_extract_iter_free(file->zip->iter);\n\t\t\tfile->zip->iter = iter;\n\t\t\tfile->zip->offset = 0;\n\t\t}\n\n\t\tstatic char buf[4*1024];\n\t\twhile (file->zip->offset < offset)\n\t\t{\n\t\t\tconst size_t want_len = MIN((__off64_t)sizeof(buf), offset - file->zip->offset);\n\t\t\tconst size_t read_len = mz_zip_reader_extract_iter_read(file->zip->iter, buf, want_len);\n\t\t\tfile->zip->offset += read_len;\n\t\t\tif (read_len < want_len)\n\t\t\t{\n\t\t\t\tprintf(\"FileSeek(mz_zip_reader_extract_iter_read) Failed to advance iterator, error:%s\\n\",\n\t\t\t\t       mz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n\tfile->offset = offset;\n\treturn 1;\n}\n\nint FileSeekLBA(fileTYPE *file, uint32_t offset)\n{\n\t__off64_t off64 = offset;\n\toff64 <<= 9;\n\treturn FileSeek(file, off64, SEEK_SET);\n}\n\n// Read with offset advancing\nint FileReadAdv(fileTYPE *file, void *pBuffer, int length, int failres)\n{\n\tssize_t ret = 0;\n\n\tif (file->filp)\n\t{\n\t\tret = fread(pBuffer, 1, length, file->filp);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tprintf(\"FileReadAdv error(%d).\\n\", ret);\n\t\t\treturn failres;\n\t\t}\n\t}\n\telse if (file->zip)\n\t{\n\t\tret = mz_zip_reader_extract_iter_read(file->zip->iter, pBuffer, length);\n\t\tif (!ret)\n\t\t{\n\t\t\tprintf(\"FileReadEx(mz_zip_reader_extract_iter_read) Failed to read, error:%s\\n\",\n\t\t\t       mz_zip_get_error_string(mz_zip_get_last_error(&file->zip->archive)));\n\t\t\treturn failres;\n\t\t}\n\t\tfile->zip->offset += ret;\n\t}\n\telse\n\t{\n\t\tprintf(\"FileReadAdv error(unknown file type).\\n\");\n\t\treturn failres;\n\t}\n\n\tfile->offset += ret;\n\treturn ret;\n}\n\nint FileReadSec(fileTYPE *file, void *pBuffer)\n{\n\treturn FileReadAdv(file, pBuffer, 512);\n}\n\n// Write with offset advancing\nint FileWriteAdv(fileTYPE *file, void *pBuffer, int length, int failres)\n{\n\tint ret;\n\n\tif (file->filp)\n\t{\n\t\tret = fwrite(pBuffer, 1, length, file->filp);\n\t\tfflush(file->filp);\n\n\t\tif (ret < 0)\n\t\t{\n\t\t\tprintf(\"FileWriteAdv error(%d).\\n\", ret);\n\t\t\treturn failres;\n\t\t}\n\n\t\tfile->offset += ret;\n\t\tif (file->offset > file->size) file->size = FileGetSize(file);\n\t\treturn ret;\n\t}\n\telse if (file->zip)\n\t{\n\t\tprintf(\"FileWriteAdv error(not supported for zip).\\n\");\n\t\treturn failres;\n\t}\n\telse\n\t{\n\t\tprintf(\"FileWriteAdv error(unknown file type).\\n\");\n\t\treturn failres;\n\t}\n}\n\nint FileWriteSec(fileTYPE *file, void *pBuffer)\n{\n\treturn FileWriteAdv(file, pBuffer, 512);\n}\n\nint FileSave(const char *name, void *pBuffer, int size)\n{\n\tmake_fullpath(name);\n\n\tint fd = open(full_path, O_WRONLY | O_CREAT | O_TRUNC | O_SYNC, S_IRWXU | S_IRWXG | S_IRWXO);\n\tif (fd < 0)\n\t{\n\t\tprintf(\"FileSave(open) File:%s, error: %d.\\n\", full_path, fd);\n\t\treturn 0;\n\t}\n\n\tint ret = write(fd, pBuffer, size);\n\tclose(fd);\n\n\tif (ret < 0)\n\t{\n\t\tprintf(\"FileSave(write) File:%s, error: %d.\\n\", full_path, ret);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nint FileDelete(const char *name)\n{\n\tmake_fullpath(name);\n\tprintf(\"delete %s\\n\", full_path);\n\treturn !unlink(full_path);\n}\n\nint DirDelete(const char *name)\n{\n\tmake_fullpath(name);\n\tprintf(\"rmdir %s\\n\", full_path);\n\treturn !rmdir(full_path);\n}\n\nconst char* GetNameFromPath(char *path)\n{\n\tstatic char res[32];\n\n\tchar* p = strrchr(path, '/');\n\tif (!p) p = path;\n\telse p++;\n\n\tif (strlen(p) < 19) strcpy(res, p);\n\telse\n\t{\n\t\tstrncpy(res, p, 19);\n\t\tres[19] = 0;\n\t}\n\n\treturn res;\n}\n\nint FileLoad(const char *name, void *pBuffer, int size)\n{\n\tfileTYPE f;\n\tif (!FileOpen(&f, name)) return 0;\n\n\tint ret = f.size;\n\tif (pBuffer) ret = FileReadAdv(&f, pBuffer, size ? size : f.size);\n\n\tFileClose(&f);\n\treturn ret;\n}\n\nint FileLoadConfig(const char *name, void *pBuffer, int size)\n{\n\tchar path[256] = { CONFIG_DIR\"/\" };\n\tstrcat(path, name);\n\treturn FileLoad(path, pBuffer, size);\n}\n\nint FileSaveConfig(const char *name, void *pBuffer, int size)\n{\n\tchar path[256] = { CONFIG_DIR };\n\tconst char *p;\n\twhile ((p = strchr(name, '/')))\n\t{\n\t\tstrcat(path, \"/\");\n\t\tstrncat(path, name, p - name);\n\t\tname = ++p;\n\t\tFileCreatePath(path);\n\t}\n\n\tstrcat(path, \"/\");\n\tstrcat(path, name);\n\treturn FileSave(path, pBuffer, size);\n}\n\nint FileDeleteConfig(const char *name)\n{\n\tchar path[256] = { CONFIG_DIR\"/\" };\n\tstrcat(path, name);\n\treturn FileDelete(path);\n}\n\nint FileExists(const char *name, int use_zip)\n{\n\treturn isPathRegularFile(name, use_zip);\n}\n\nint PathIsDir(const char *name, int use_zip)\n{\n\treturn isPathDirectory(name, use_zip);\n}\n\nint FileCanWrite(const char *name)\n{\n\tmake_fullpath(name);\n\n\tif (FileIsZipped(full_path, nullptr, nullptr))\n\t{\n\t\treturn 0;\n\t}\n\n\tstruct stat64 st;\n\tint ret = stat64(full_path, &st);\n\tif (ret < 0)\n\t{\n\t\tprintf(\"FileCanWrite(stat) File:%s, error: %d.\\n\", full_path, ret);\n\t\treturn 0;\n\t}\n\n\t//printf(\"FileCanWrite: mode=%04o.\\n\", st.st_mode);\n\treturn ((st.st_mode & S_IWUSR) != 0);\n}\n\nvoid create_path(const char *base_dir, const char* sub_dir)\n{\n\tmake_fullpath(base_dir);\n\tmkdir(full_path, S_IRWXU | S_IRWXG | S_IRWXO);\n\tstrcat(full_path, \"/\");\n\tstrcat(full_path, sub_dir);\n\tmkdir(full_path, S_IRWXU | S_IRWXG | S_IRWXO);\n}\n\nint FileCreatePath(const char *dir)\n{\n\tint res = 1;\n\tif (!isPathDirectory(dir)) {\n\t\tmake_fullpath(dir);\n\t\tres = !mkdir(full_path, S_IRWXU | S_IRWXG | S_IRWXO);\n\t}\n\treturn res;\n}\n\nvoid FileGenerateScreenshotName(const char *name, char *out_name, int buflen)\n{\n\t// If the name ends with .png then don't modify it\n\tif( !strcasecmp(name + strlen(name) - 4, \".png\") )\n\t{\n\t\tconst char *p = strrchr(name, '/');\n\t\tmake_fullpath(SCREENSHOT_DIR);\n\t\tif( p )\n\t\t{\n\t\t\tsnprintf(out_name, buflen, \"%s%s\", SCREENSHOT_DIR, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf(out_name, buflen, \"%s/%s\", SCREENSHOT_DIR, name);\n\t\t}\n\t}\n\telse\n\t{\n\t\tcreate_path(SCREENSHOT_DIR, CoreName2);\n\n\t\ttime_t t = time(NULL);\n\t\tstruct tm tm = *localtime(&t);\n\t\tchar datecode[32] = {};\n\t\tif (tm.tm_year >= 119) // 2019 or up considered valid time\n\t\t{\n\t\t\tstrftime(datecode, 31, \"%Y%m%d_%H%M%S\", &tm);\n\t\t\tsnprintf(out_name, buflen, \"%s/%s/%s-%s.png\", SCREENSHOT_DIR, CoreName2, datecode, name[0] ? name : SCREENSHOT_DEFAULT);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 1; i < 10000; i++)\n\t\t\t{\n\t\t\t\tsnprintf(out_name, buflen, \"%s/%s/NODATE-%s_%04d.png\", SCREENSHOT_DIR, CoreName2, name[0] ? name : SCREENSHOT_DEFAULT, i);\n\t\t\t\tif (!getFileType(out_name)) return;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FileGenerateSavePath(const char *name, char* out_name, int ext_replace)\n{\n\tcreate_path(SAVE_DIR, CoreName2);\n\n\tsprintf(out_name, \"%s/%s/\", SAVE_DIR, CoreName2);\n\tchar *fname = out_name + strlen(out_name);\n\n\tconst char *p = strrchr(name, '/');\n\tif (p)\n\t{\n\t\tstrcat(fname, p+1);\n\t}\n\telse\n\t{\n\t\tstrcat(fname, name);\n\t}\n\n\tchar *e = strrchr(fname, '.');\n\tif (ext_replace && e)\n\t{\n\t\tstrcpy(e,\".sav\");\n\t}\n\telse\n\t{\n\t\tstrcat(fname, \".sav\");\n\t}\n\n\tprintf(\"SavePath=%s\\n\", out_name);\n}\n\nvoid FileGenerateSavestatePath(const char *name, char* out_name, int sufx)\n{\n\tcreate_path(SAVESTATE_DIR, CoreName2);\n\n\tsprintf(out_name, \"%s/%s/\", SAVESTATE_DIR, CoreName2);\n\tchar *fname = out_name + strlen(out_name);\n\n\tconst char *p = strrchr(name, '/');\n\tif (p)\n\t{\n\t\tstrcat(fname, p + 1);\n\t}\n\telse\n\t{\n\t\tstrcat(fname, name);\n\t}\n\n\tchar *e = strrchr(fname, '.');\n\tif (e) e[0] = 0;\n\n\tif(sufx) sprintf(e, \"_%d.ss\", sufx);\n\telse strcat(e, \".ss\");\n}\n\nuint32_t getFileType(const char *name)\n{\n\tmake_fullpath(name);\n\n\tstruct stat64 st;\n\tif (stat64(full_path, &st)) return 0;\n\n\treturn st.st_mode;\n}\n\nint findPrefixDir(char *dir, size_t dir_len)\n{\n\t// Searches for the core's folder in the following order:\n\t// /media/usb<0..5>\n\t// /media/usb<0..5>/games\n\t// /media/network\n\t// /media/network/games\n\t// /media/fat/cifs\n\t// /media/fat/cifs/games\n\t// /media/fat\n\t// /media/fat/games/\n\t// if the core folder is not found anywhere,\n\t// it will be created in /media/fat/games/<dir>\n\tstatic char temp_dir[1024];\n\n\t// Usb<0..5>\n\tfor (int x = 0; x < 6; x++) {\n\t\tsnprintf(temp_dir, 1024, \"%s%d/%s\", \"../usb\", x, dir);\n\t\tif (isPathDirectory(temp_dir)) {\n\t\t\tprintf(\"Found USB dir: %s\\n\", temp_dir);\n\t\t\tstrncpy(dir, temp_dir, dir_len);\n\t\t\treturn 1;\n\t\t}\n\n\t\tsnprintf(temp_dir, 1024, \"%s%d/%s/%s\", \"../usb\", x, GAMES_DIR, dir);\n\t\tif (isPathDirectory(temp_dir)) {\n\t\t\tprintf(\"Found USB dir: %s\\n\", temp_dir);\n\t\t\tstrncpy(dir, temp_dir, dir_len);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// Network share in /media/network/\n\tsnprintf(temp_dir, 1024, \"%s/%s\", \"../network\", dir);\n\tif (isPathDirectory(temp_dir)) {\n\t\tprintf(\"Found network dir: %s\\n\", temp_dir);\n\t\tstrncpy(dir, temp_dir, dir_len);\n\t\treturn 1;\n\t}\n\n\t// Network share in /media/network/games\n\tsnprintf(temp_dir, 1024, \"%s/%s/%s\", \"../network\", GAMES_DIR, dir);\n\tif (isPathDirectory(temp_dir)) {\n\t\tprintf(\"Found network dir: %s\\n\", temp_dir);\n\t\tstrncpy(dir, temp_dir, dir_len);\n\t\treturn 1;\n\t}\n\n\t// CIFS_DIR directory in /media/fat/cifs\n\tsnprintf(temp_dir, 1024, \"%s/%s\", CIFS_DIR, dir);\n\tif (isPathDirectory(temp_dir)) {\n\t\tprintf(\"Found CIFS dir: %s\\n\", temp_dir);\n\t\tstrncpy(dir, temp_dir, dir_len);\n\t\treturn 1;\n\t}\n\n\t// CIFS_DIR/GAMES_DIR directory in /media/fat/cifs/games\n\tsnprintf(temp_dir, 1024, \"%s/%s/%s\", CIFS_DIR, GAMES_DIR, dir);\n\tif (isPathDirectory(temp_dir)) {\n\t\tprintf(\"Found CIFS dir: %s\\n\", temp_dir);\n\t\tstrncpy(dir, temp_dir, dir_len);\n\t\treturn 1;\n\t}\n\n\t// media/fat\n\tif (isPathDirectory(dir)) {\n\t\tprintf(\"Found existing: %s\\n\", dir);\n\t\treturn 1;\n\t}\n\n\t// media/fat/GAMES_DIR\n\tsnprintf(temp_dir, 1024, \"%s/%s\", GAMES_DIR, dir);\n\tif (isPathDirectory(temp_dir)) {\n\t\tprintf(\"Found dir: %s\\n\", temp_dir);\n\t\tstrncpy(dir, temp_dir, dir_len);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid prefixGameDir(char *dir, size_t dir_len)\n{\n\tif (!findPrefixDir(dir, dir_len))\n\t{\n\t\tstatic char temp_dir[1024];\n\n\t\t//FileCreatePath(GAMES_DIR);\n\t\tsnprintf(temp_dir, 1024, \"%s/%s\", GAMES_DIR, dir);\n\t\tstrncpy(dir, temp_dir, dir_len);\n\t\tprintf(\"Prefixed dir to %s\\n\", temp_dir);\n\t}\n}\n\nstatic int device = 0;\nstatic int usbnum = 0;\nconst char *getStorageDir(int dev)\n{\n\tstatic char path[32];\n\tif (!dev) return \"/media/fat\";\n\tsprintf(path, \"/media/usb%d\", usbnum);\n\treturn path;\n}\n\nconst char *getRootDir()\n{\n\treturn getStorageDir(device);\n}\n\nconst char *getFullPath(const char *name)\n{\n\tmake_fullpath(name);\n\treturn full_path;\n}\n\nvoid setStorage(int dev)\n{\n\tdevice = 0;\n\tFileSave(CONFIG_DIR\"/device.bin\", &dev, sizeof(int));\n\tfpga_load_rbf(\"menu.rbf\");\n}\n\nstatic int orig_device = 0;\nint getStorage(int from_setting)\n{\n\treturn from_setting ? orig_device : device;\n}\n\nint isPathMounted(int n)\n{\n\tchar path[32];\n\tsprintf(path, \"/media/usb%d\", n);\n\n\tstruct stat file_stat;\n\tstruct stat parent_stat;\n\n\tif (-1 == stat(path, &file_stat))\n\t{\n\t\tprintf(\"failed to stat %s\\n\", path);\n\t\treturn 0;\n\t}\n\n\tif (!(file_stat.st_mode & S_IFDIR))\n\t{\n\t\tprintf(\"%s is not a directory.\\n\", path);\n\t\treturn 0;\n\t}\n\n\tif (-1 == stat(\"/media\", &parent_stat))\n\t{\n\t\tprintf(\"failed to stat /media\\n\");\n\t\treturn 0;\n\t}\n\n\tif (file_stat.st_dev != parent_stat.st_dev ||\n\t\t(file_stat.st_dev == parent_stat.st_dev &&\n\t\t\tfile_stat.st_ino == parent_stat.st_ino))\n\t{\n\t\tprintf(\"%s IS a mountpoint.\\n\", path);\n\t\tstruct statfs fs_stat;\n\t\tif (!statfs(path, &fs_stat))\n\t\t{\n\t\t\tprintf(\"%s is FS: 0x%08X\\n\", path, fs_stat.f_type);\n\t\t\tif (fs_stat.f_type != EXT4_SUPER_MAGIC)\n\t\t\t{\n\t\t\t\tprintf(\"%s is not EXT2/3/4.\\n\", path);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%s is NOT a VFAT mountpoint.\\n\", path);\n\treturn 0;\n}\n\nint isUSBMounted()\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (isPathMounted(i))\n\t\t{\n\t\t\tusbnum = i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid FindStorage(void)\n{\n\tchar str[128];\n\tprintf(\"Looking for root device...\\n\");\n\tdevice = 0;\n\tFileLoad(CONFIG_DIR\"/device.bin\", &device, sizeof(int));\n\torig_device = device;\n\n\tif(device && !isUSBMounted())\n\t{\n\t\tuint8_t core_type = (fpga_core_id() & 0xFF);\n\t\tif (core_type == CORE_TYPE_8BIT)\n\t\t{\n\t\t\tuser_io_read_confstr();\n\t\t\tuser_io_read_core_name();\n\t\t}\n\n\t\tint saveddev = device;\n\t\tdevice = 0;\n\t\tcfg_parse();\n\t\tdevice = saveddev;\n\t\tvideo_init();\n\t\tuser_io_send_buttons(1);\n\n\t\tprintf(\"Waiting for USB...\\n\");\n\t\tint btn = 0;\n\t\tint done = 0;\n\n\t\tOsdWrite(16, \"\", 1);\n\t\tOsdWrite(17, \"       www.MiSTerFPGA.org       \", 1);\n\t\tOsdWrite(18, \"\", 1);\n\n\t\tfor (int i = 30; i >= 0; i--)\n\t\t{\n\t\t\tsprintf(str, \"\\n     Waiting for USB...\\n\\n             %d   \\n\\n\\n  OSD/USER or ESC to cancel\", i);\n\t\t\tInfoMessage(str);\n\t\t\tif (isUSBMounted())\n\t\t\t{\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tbtn = fpga_get_buttons();\n\t\t\t\tif (!btn) btn = input_poll(1);\n\t\t\t\tif (btn)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Button has been pressed %d\\n\", btn);\n\t\t\t\t\tInfoMessage(\"\\n\\n         Canceled!\\n\");\n\t\t\t\t\tusleep(500000);\n\t\t\t\t\tsetStorage(0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(100000);\n\t\t\t}\n\t\t\tif (done) break;\n\t\t}\n\n\t\tif (!done)\n\t\t{\n\t\t\tInfoMessage(\"\\n\\n     No USB storage found\\n   Falling back to SD card\\n\");\n\t\t\tusleep(2000000);\n\t\t\tsetStorage(0);\n\t\t}\n\t}\n\n\tif (device)\n\t{\n\t\tprintf(\"Using USB as a root device\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"Using SD card as a root device\\n\");\n\t}\n\n\tsprintf(full_path, \"%s/\" CONFIG_DIR, getRootDir());\n\tDIR* dir = opendir(full_path);\n\tif (dir) closedir(dir);\n\telse if (ENOENT == errno) mkdir(full_path, S_IRWXU | S_IRWXG | S_IRWXO);\n}\n\nstruct DirentComp\n{\n\tbool operator()(const direntext_t& de1, const direntext_t& de2)\n\t{\n\n#ifdef USE_SCHEDULER\n\t\tif (++iterations % YieldIterations == 0)\n\t\t{\n\t\t\tscheduler_yield();\n\t\t}\n#endif\n\n\t\tif ((de1.de.d_type == DT_DIR) && !strcmp(de1.altname, \"..\")) return true;\n\t\tif ((de2.de.d_type == DT_DIR) && !strcmp(de2.altname, \"..\")) return false;\n\n\t\tif ((de1.de.d_type == DT_DIR) && (de2.de.d_type != DT_DIR)) return true;\n\t\tif ((de1.de.d_type != DT_DIR) && (de2.de.d_type == DT_DIR)) return false;\n\n\t\tint len1 = strlen(de1.altname);\n\t\tint len2 = strlen(de2.altname);\n\t\tif ((len1 > 4) && (de1.altname[len1 - 4] == '.')) len1 -= 4;\n\t\tif ((len2 > 4) && (de2.altname[len2 - 4] == '.')) len2 -= 4;\n\n\t\tint len = (len1 < len2) ? len1 : len2;\n\t\tint ret = strncasecmp(de1.altname, de2.altname, len);\n\t\tif (!ret)\n\t\t{\n\t\t\tif(len1 != len2)\n\t\t\t{\n\t\t\t\treturn len1 < len2;\n\t\t\t}\n\t\t\tret = strcasecmp(de1.datecode, de2.datecode);\n\t\t}\n\n\t\treturn ret < 0;\n\t}\n\n\tsize_t iterations = 0;\n};\n\nvoid AdjustDirectory(char *path)\n{\n\tif (!FileExists(path)) return;\n\n\tchar *p = strrchr(path, '/');\n\tif (p)\n\t{\n\t\t*p = 0;\n\t}\n\telse\n\t{\n\t\tpath[0] = 0;\n\t}\n}\n\nstatic const char *GetRelativeFileName(const char *folder, const char *path)\n{\n\tif (!*folder) return path;\n\tif (strcasestr(path, folder) == path)\n\t{\n\t\tconst char *subpath = path + strlen(folder);\n\t\tif (*subpath == '/') return subpath + 1;\n\t}\n\treturn NULL;\n}\n\nstatic bool IsInSameFolder(const char *folder, const char *path)\n{\n\tconst char *p = strrchr(path, '/');\n\tsize_t len = p ? p - path : 0;\n\treturn (strlen(folder) == len) && !strncasecmp(path, folder, len);\n}\n\nstatic int names_loaded = 0;\nstatic void get_display_name(direntext_t *dext, const char *ext, int options)\n{\n\tstatic char *names = 0;\n\tmemcpy(dext->altname, dext->de.d_name, sizeof(dext->altname));\n\tif (dext->de.d_type == DT_DIR) return;\n\n\tint len = strlen(dext->altname);\n\tint xml = (len > 4 && (!strcasecmp(dext->altname + len - 4, \".mgl\") || !strcasecmp(dext->altname + len - 4, \".mra\")));\n\tint rbf = (len > 4 && !strcasecmp(dext->altname + len - 4, \".rbf\"));\n\tif (rbf || xml)\n\t{\n\t\tdext->altname[len - 4] = 0;\n\t\tif (rbf)\n\t\t{\n\t\t\tchar *p = strstr(dext->altname, \"_20\");\n\t\t\tif (p) if (strlen(p + 3) < 6) p = 0;\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\t*p = 0;\n\t\t\t\tstrncpy(dext->datecode, p + 3, 15);\n\t\t\t\tdext->datecode[15] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcpy(dext->datecode, \"------\");\n\t\t\t}\n\t\t}\n\n\t\tif (!names_loaded)\n\t\t{\n\t\t\tif (names)\n\t\t\t{\n\t\t\t\tfree(names);\n\t\t\t\tnames = 0;\n\t\t\t}\n\n\t\t\tint size = FileLoad(\"names.txt\", 0, 0);\n\t\t\tif (size)\n\t\t\t{\n\t\t\t\tnames = (char*)malloc(size + 1);\n\t\t\t\tif (names)\n\t\t\t\t{\n\t\t\t\t\tnames[0] = 0;\n\t\t\t\t\tFileLoad(\"names.txt\", names, 0);\n\t\t\t\t\tnames[size] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnames_loaded = 1;\n\t\t}\n\n\t\tif (names)\n\t\t{\n\t\t\tstrcat(dext->altname, \":\");\n\t\t\tlen = strlen(dext->altname);\n\t\t\tchar *transl = strstr(names, dext->altname);\n\t\t\tif (transl)\n\t\t\t{\n\t\t\t\tint copy = 0;\n\t\t\t\ttransl += len;\n\t\t\t\tlen = 0;\n\t\t\t\twhile (*transl && len < (int)sizeof(dext->altname) - 1)\n\t\t\t\t{\n\t\t\t\t\tif (!copy && *transl <= 32)\n\t\t\t\t\t{\n\t\t\t\t\t\ttransl++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (copy && *transl < 32) break;\n\n\t\t\t\t\tcopy = 1;\n\t\t\t\t\tdext->altname[len++] = *transl++;\n\t\t\t\t}\n\t\t\t\tlen++;\n\t\t\t}\n\n\t\t\tdext->altname[len - 1] = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\t//do not remove ext if core supplies more than 1 extension and it's not list of cores\n\tif (!(options & SCANO_CORES) && strlen(ext) > 3) return;\n\tif (strchr(ext, '*') || strchr(ext, '?')) return;\n\n\t/* find the extension on the end of the name*/\n\tchar *fext = strrchr(dext->altname, '.');\n\tif (fext) *fext = 0;\n}\n\nint ScanDirectory(char* path, int mode, const char *extension, int options, const char *prefix, const char *filter)\n{\n\tstatic char file_name[1024];\n\tstatic char full_path[1024];\n\n\tint has_trd = 0;\n\tconst char *ext = extension;\n\twhile (*ext)\n\t{\n\t\tif (!strncasecmp(ext, \"TRD\", 3)) has_trd = 1;\n\t\text += 3;\n\t}\n\n\tint extlen = strlen(extension);\n    int filterlen = filter ? strlen(filter) : 0;\n\t//printf(\"scan dir\\n\");\n\n\tif (mode == SCANF_INIT)\n\t{\n\t\tiFirstEntry = 0;\n\t\tiSelectedEntry = 0;\n\t\tDirItem.clear();\n\t\tDirNames.clear();\n\n\t\tfile_name[0] = 0;\n\n\t\tif ((options & SCANO_NOENTER) || isPathRegularFile(path))\n\t\t{\n\t\t\tchar *p = strrchr(path, '/');\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\tstrcpy(file_name, p + 1);\n\t\t\t\t*p = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcpy(file_name, path);\n\t\t\t\tpath[0] = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!isPathDirectory(path)) return 0;\n\t\tsnprintf(scanned_path, sizeof(scanned_path), \"%s\", path);\n\t\tscanned_opts = options;\n\n\t\tif (options & SCANO_NEOGEO) neogeo_scan_xml(path);\n\n\t\tsprintf(full_path, \"%s/%s\", getRootDir(), path);\n\t\tint path_len = strlen(full_path);\n\n\t\tconst char* is_zipped = strcasestr(full_path, \".zip\");\n\t\tif (is_zipped && strcasestr(is_zipped + 4, \".zip\"))\n\t\t{\n\t\t\tprintf(\"Nested zip-files are not supported: %s\\n\", full_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tprintf(\"Start to scan %sdir: %s\\n\", is_zipped ? \"zipped \" : \"\", full_path);\n\t\tprintf(\"Position on item: %s\\n\", file_name);\n\n\t\tchar *zip_path, *file_path_in_zip = (char*)\"\";\n\t\tFileIsZipped(full_path, &zip_path, &file_path_in_zip);\n\n\t\tDIR *d = nullptr;\n\t\tmz_zip_archive *z = nullptr;\n\t\tif (is_zipped)\n\t\t{\n\t\t\tif (!OpenZipfileCached(full_path, 0))\n\t\t\t{\n\t\t\t\tprintf(\"Couldn't open zip file %s: %s\\n\", full_path, mz_zip_get_error_string(mz_zip_get_last_error(&last_zip_archive)));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tz = &last_zip_archive;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td = opendir(full_path);\n\t\t\tif (!d)\n\t\t\t{\n\t\t\t\tprintf(\"Couldn't open dir: %s\\n\", full_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent64 *de = nullptr;\n\t\tfor (size_t i = 0; (d && (de = readdir64(d)))\n\t\t\t\t || (z && i < mz_zip_reader_get_num_files(z)); i++)\n\t\t{\n#ifdef USE_SCHEDULER\n\t\t\tif (0 < i && i % YieldIterations == 0)\n\t\t\t{\n\t\t\t\tscheduler_yield();\n\t\t\t}\n#endif\n\t\t\tstruct dirent64 _de = {};\n\t\t\tint isZip = 0;\n\n\t\t\tif (z)\n\t\t\t{\n\t\t\t\tmz_zip_reader_get_filename(z, i, &_de.d_name[0], sizeof(_de.d_name));\n\t\t\t\tconst char *rname = GetRelativeFileName(file_path_in_zip, _de.d_name);\n\t\t\t\tif (rname)\n\t\t\t\t{\n\t\t\t\t\tconst char *fslash = strchr(rname, '/');\n\t\t\t\t\tif (fslash)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar dirname[256] = {};\n\t\t\t\t\t\tstrncpy(dirname, rname, fslash - rname);\n\t\t\t\t\t\tif (rname[0] != '/' && !(DirNames.find(dirname) != DirNames.end()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdirentext_t dirext;\n\t\t\t\t\t\t\tmemset(&dirext, 0, sizeof(dirext));\n\t\t\t\t\t\t\tstrncpy(dirext.de.d_name, rname, fslash - rname);\n\t\t\t\t\t\t\tdirext.de.d_type = DT_DIR;\n\t\t\t\t\t\t\tmemcpy(dirext.altname, dirext.de.d_name, sizeof(dirext.de.d_name));\n\t\t\t\t\t\t\tDirItem.push_back(dirext);\n\t\t\t\t\t\t\tDirNames.insert(dirname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!IsInSameFolder(file_path_in_zip, _de.d_name))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Remove leading folders.\n\t\t\t\tconst char *subpath = _de.d_name + strlen(file_path_in_zip);\n\t\t\t\tif (*subpath == '/') subpath++;\n\t\t\t\tstrcpy(_de.d_name, subpath);\n\n\t\t\t\tde = &_de;\n\n\t\t\t\t_de.d_type = mz_zip_reader_is_file_a_directory(z, i) ? DT_DIR : DT_REG;\n\t\t\t\tif (_de.d_type == DT_DIR) {\n\t\t\t\t\t// Remove trailing slash.\n\t\t\t\t\tif (DirNames.find(_de.d_name) != DirNames.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tDirNames.insert(_de.d_name);\n\t\t\t\t\t\t_de.d_name[strlen(_de.d_name) - 1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Handle (possible) symbolic link type in the directory entry\n\t\t\telse if (de->d_type == DT_LNK || de->d_type == DT_REG)\n\t\t\t{\n\t\t\t\tsprintf(full_path + path_len, \"/%s\", de->d_name);\n\n\t\t\t\tstruct stat entrystat;\n\n\t\t\t\tif (!stat(full_path, &entrystat))\n\t\t\t\t{\n\t\t\t\t\tif (S_ISREG(entrystat.st_mode))\n\t\t\t\t\t{\n\t\t\t\t\t\tde->d_type = DT_REG;\n\t\t\t\t\t}\n\t\t\t\t\telse if (S_ISDIR(entrystat.st_mode))\n\t\t\t\t\t{\n\t\t\t\t\t\tde->d_type = DT_DIR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (filter)\n\t\t\t{\n                bool passes_filter = false;\n\n                for(const char *str = de->d_name; *str; str++)\n\t\t\t\t{\n                    if (strncasecmp(str, filter, filterlen) == 0)\n\t\t\t\t\t{\n                        passes_filter = true;\n                        break;\n                    }\n                }\n\n                if (!passes_filter) continue;\n            }\n\n\n\t\t\tif (options & SCANO_NEOGEO)\n\t\t\t{\n\t\t\t\tif (de->d_type == DT_REG && !strcasecmp(de->d_name + strlen(de->d_name) - 4, \".zip\"))\n\t\t\t\t{\n\t\t\t\t\tde->d_type = DT_DIR;\n\t\t\t\t}\n\n\t\t\t\tif (strcasecmp(de->d_name + strlen(de->d_name) - 4, \".neo\"))\n\t\t\t\t{\n\t\t\t\t\tif (de->d_type != DT_DIR) continue;\n\t\t\t\t}\n\n\t\t\t\tif (!strcmp(de->d_name, \"..\"))\n\t\t\t\t{\n\t\t\t\t\tif (!strlen(path)) continue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// skip hidden folders\n\t\t\t\t\tif (!strncasecmp(de->d_name, \".\", 1)) continue;\n\t\t\t\t}\n\n\t\t\t\tdirentext_t dext;\n\t\t\t\tmemset(&dext, 0, sizeof(dext));\n\t\t\t\tmemcpy(&dext.de, de, sizeof(dext.de));\n\t\t\t\tmemcpy(dext.altname, de->d_name, sizeof(dext.altname));\n\t\t\t\tif (!strcasecmp(dext.altname + strlen(dext.altname) - 4, \".zip\")) dext.altname[strlen(dext.altname) - 4] = 0;\n\n\t\t\t\tfull_path[path_len] = 0;\n\t\t\t\tchar *altname = neogeo_get_altname(full_path, dext.de.d_name, dext.altname);\n\t\t\t\tif (altname)\n\t\t\t\t{\n\t\t\t\t\tif (altname == (char*)-1) continue;\n\n\t\t\t\t\tdext.de.d_type = DT_REG;\n\t\t\t\t\tmemcpy(dext.altname, altname, sizeof(dext.altname));\n\t\t\t\t}\n\n\t\t\t\tDirItem.push_back(dext);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (de->d_type == DT_DIR)\n\t\t\t\t{\n\t\t\t\t\t// skip System Volume Information folder\n\t\t\t\t\tif (!strcmp(de->d_name, \"System Volume Information\")) continue;\n\t\t\t\t\tif (!strcmp(de->d_name, \"..\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!strlen(path)) continue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// skip hidden folder\n\t\t\t\t\t\tif (!strncasecmp(de->d_name, \".\", 1)) continue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(options & SCANO_DIR))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (de->d_name[0] != '_' && strcmp(de->d_name, \"..\")) continue;\n\t\t\t\t\t\tif (!(options & SCANO_CORES)) continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (de->d_type == DT_REG)\n\t\t\t\t{\n\t\t\t\t\t// skip hidden files\n\t\t\t\t\tif (!strncasecmp(de->d_name, \".\", 1)) continue;\n\t\t\t\t\t//skip non-selectable files\n\t\t\t\t\tif (!strcasecmp(de->d_name, \"menu.rbf\")) continue;\n\t\t\t\t\tif (!strncasecmp(de->d_name, \"menu_20\", 7)) continue;\n\t\t\t\t\tif (!strcasecmp(de->d_name, \"boot.rom\")) continue;\n\n\t\t\t\t\t//check the prefix if given\n\t\t\t\t\tif (prefix && strncasecmp(prefix, de->d_name, strlen(prefix))) continue;\n\n\t\t\t\t\tif (extlen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst char *ext = extension;\n\t\t\t\t\t\tint found = (has_trd && x2trd_ext_supp(de->d_name));\n\t\t\t\t\t\tif (!found && !(options & SCANO_NOZIP) && !strcasecmp(de->d_name + strlen(de->d_name) - 4, \".zip\") && (options & SCANO_DIR))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Fake that zip-file is a directory.\n\t\t\t\t\t\t\tde->d_type = DT_DIR;\n\t\t\t\t\t\t\tisZip = 1;\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found && is_minimig() && !memcmp(extension, \"HDF\", 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = !strcasecmp(de->d_name + strlen(de->d_name) - 4, \".iso\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchar *fext = strrchr(de->d_name, '.');\n\t\t\t\t\t\tif (fext) fext++;\n\t\t\t\t\t\twhile (!found && *ext && fext)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar e[4];\n\t\t\t\t\t\t\tmemcpy(e, ext, 3);\n\t\t\t\t\t\t\tif (e[2] == ' ')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\te[2] = 0;\n\t\t\t\t\t\t\t\tif (e[1] == ' ') e[1] = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\te[3] = 0;\n\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (e[i] == '*') break;\n\t\t\t\t\t\t\t\tif (e[i] == '?' && fext[i]) continue;\n\n\t\t\t\t\t\t\t\tif (tolower(e[i]) != tolower(fext[i])) found = 0;\n\n\t\t\t\t\t\t\t\tif (!e[i] || !found) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found) break;\n\n\t\t\t\t\t\t\tif (strlen(ext) < 3) break;\n\t\t\t\t\t\t\text += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found) continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n        {\n\t\t\t      direntext_t dext;\n\t\t\t\t    memset(&dext, 0, sizeof(dext));\n\t\t\t\t    memcpy(&dext.de, de, sizeof(dext.de));\n\t\t\t\t    if (isZip)\n\t\t\t\t        dext.flags |= DT_EXT_ZIP;\n\t\t\t\t    get_display_name(&dext, extension, options);\n\t\t\t\t    DirItem.push_back(dext);\n        }\n\t\t\t}\n\t\t}\n\n\t\tif (z)\n\t\t{\n\t\t\t// Since zip files aren't actually folders the entry to\n\t\t\t// exit the zip file must be added manually.\n\t\t\tdirentext_t dext;\n\t\t\tmemset(&dext, 0, sizeof(dext));\n\t\t\tdext.de.d_type = DT_DIR;\n\t\t\tstrcpy(dext.de.d_name, \"..\");\n\t\t\tget_display_name(&dext, extension, options);\n\t\t\tDirItem.push_back(dext);\n\t\t}\n\n\t\tif (d)\n\t\t{\n\t\t\tclosedir(d);\n\t\t}\n\n\t\tprintf(\"Got %d dir entries\\n\", flist_nDirEntries());\n\t\tif (!flist_nDirEntries()) return 0;\n\n\t\tstd::sort(DirItem.begin(), DirItem.end(), DirentComp());\n\t\tif (file_name[0])\n\t\t{\n\t\t\tint pos = -1;\n\t\t\tfor (int i = 0; i < flist_nDirEntries(); i++)\n\t\t\t{\n\t\t\t\tif (!strcmp(file_name, DirItem[i].de.d_name))\n\t\t\t\t{\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (!strcasecmp(file_name, DirItem[i].de.d_name))\n\t\t\t\t{\n\t\t\t\t\tpos = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pos>=0)\n\t\t\t{\n\t\t\t\tiSelectedEntry = pos;\n\t\t\t\tif (iSelectedEntry + (OsdGetSize() / 2) >= flist_nDirEntries()) iFirstEntry = flist_nDirEntries() - OsdGetSize();\n\t\t\t\telse iFirstEntry = iSelectedEntry - (OsdGetSize() / 2) + 1;\n\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t}\n\t\t}\n\t\treturn flist_nDirEntries();\n\t}\n\telse\n\t{\n\t\tif (flist_nDirEntries() == 0) // directory is empty so there is no point in searching for any entry\n\t\t\treturn 0;\n\n\t\tif (mode == SCANF_END || (mode == SCANF_PREV && iSelectedEntry <= 0))\n\t\t{\n\t\t\tiSelectedEntry = flist_nDirEntries() - 1;\n\t\t\tiFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\treturn 0;\n\t\t}\n\t\telse if (mode == SCANF_NEXT)\n\t\t{\n\t\t\tif(iSelectedEntry + 1 < flist_nDirEntries()) // scroll within visible items\n\t\t\t{\n\t\t\t\tiSelectedEntry++;\n\t\t\t\tif (iSelectedEntry > iFirstEntry + OsdGetSize() - 1) iFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\t}\n            else\n            {\n\t\t\t\t// jump to first visible item\n\t\t\t\tiFirstEntry = 0;\n\t\t\t\tiSelectedEntry = 0;\n            }\n            return 0;\n\t\t}\n\t\telse if (mode == SCANF_PREV)\n\t\t{\n\t\t\tif (iSelectedEntry > 0) // scroll within visible items\n\t\t\t{\n\t\t\t\tiSelectedEntry--;\n\t\t\t\tif (iSelectedEntry < iFirstEntry) iFirstEntry = iSelectedEntry;\n\t\t\t}\n            return 0;\n\t\t}\n\t\telse if (mode == SCANF_NEXT_PAGE)\n\t\t{\n\t\t\tif (iSelectedEntry < iFirstEntry + OsdGetSize() - 2)\n\t\t\t{\n\t\t\t\tiSelectedEntry = iFirstEntry + OsdGetSize() - 1;\n\t\t\t\tif (iSelectedEntry >= flist_nDirEntries()) iSelectedEntry = flist_nDirEntries() - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiSelectedEntry += OsdGetSize();\n\t\t\t\tiFirstEntry += OsdGetSize();\n\t\t\t\tif (iSelectedEntry >= flist_nDirEntries())\n\t\t\t\t{\n\t\t\t\t\tiSelectedEntry = flist_nDirEntries() - 1;\n\t\t\t\t\tiFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t\t}\n\t\t\t\telse if (iFirstEntry + OsdGetSize() > flist_nDirEntries())\n\t\t\t\t{\n\t\t\t\t\tiFirstEntry = flist_nDirEntries() - OsdGetSize();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse if (mode == SCANF_PREV_PAGE)\n\t\t{\n\t\t\tif(iSelectedEntry != iFirstEntry)\n\t\t\t{\n\t\t\t\tiSelectedEntry = iFirstEntry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiFirstEntry -= OsdGetSize();\n\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t\tiSelectedEntry = iFirstEntry;\n\t\t\t}\n\t\t}\n\t\telse if (mode == SCANF_SET_ITEM)\n\t\t{\n\t\t\tint pos = -1;\n\t\t\tfor (int i = 0; i < flist_nDirEntries(); i++)\n\t\t\t{\n\t\t\t\tif ((DirItem[i].de.d_type == DT_DIR) && !strcmp(DirItem[i].altname, extension))\n\t\t\t\t{\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if ((DirItem[i].de.d_type == DT_DIR) && !strcasecmp(DirItem[i].altname, extension))\n\t\t\t\t{\n\t\t\t\t\tpos = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pos>=0)\n\t\t\t{\n\t\t\t\tiSelectedEntry = pos;\n\t\t\t\tif (iSelectedEntry + (OsdGetSize() / 2) >= flist_nDirEntries()) iFirstEntry = flist_nDirEntries() - OsdGetSize();\n\t\t\t\telse iFirstEntry = iSelectedEntry - (OsdGetSize() / 2) + 1;\n\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//printf(\"dir scan for key: %x/%c\\n\", mode, mode);\n\t\t\tmode = toupper(mode);\n\t\t\tif ((mode >= '0' && mode <= '9') || (mode >= 'A' && mode <= 'Z'))\n\t\t\t{\n\t\t\t\tint found = -1;\n\t\t\t\tfor (int i = iSelectedEntry+1; i < flist_nDirEntries(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (toupper(DirItem[i].altname[0]) == mode)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (found < 0)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < flist_nDirEntries(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (toupper(DirItem[i].altname[0]) == mode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (found >= 0)\n\t\t\t\t{\n\t\t\t\t\tiSelectedEntry = found;\n\t\t\t\t\tif (iSelectedEntry + (OsdGetSize() / 2) >= flist_nDirEntries()) iFirstEntry = flist_nDirEntries() - OsdGetSize();\n\t\t\t\t\telse iFirstEntry = iSelectedEntry - (OsdGetSize()/2) + 1;\n\t\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nchar* flist_Path()\n{\n\treturn scanned_path;\n}\n\nint flist_nDirEntries()\n{\n\treturn DirItem.size();\n}\n\nint flist_iFirstEntry()\n{\n\treturn iFirstEntry;\n}\n\nvoid flist_iFirstEntryInc()\n{\n\tiFirstEntry++;\n}\n\nint flist_iSelectedEntry()\n{\n\treturn iSelectedEntry;\n}\n\ndirentext_t* flist_DirItem(int n)\n{\n\treturn &DirItem[n];\n}\n\ndirentext_t* flist_SelectedItem()\n{\n\treturn &DirItem[iSelectedEntry];\n}\n\nchar* flist_GetPrevNext(const char* base_path, const char* file, const char* ext, int next)\n{\n\tstatic char path[1024];\n\tsnprintf(path, sizeof(path), \"%s/%s\", base_path, file);\n\tchar *p = strrchr(path, '/');\n\tif (!FileExists(path))\n\t{\n\t\tsnprintf(path, sizeof(path), \"%s\", base_path);\n\t\tp = 0;\n\t}\n\n\tint len = (p) ? p - path : strlen(path);\n\tif (strncasecmp(scanned_path, path, len) || (scanned_opts & SCANO_DIR)) ScanDirectory(path, SCANF_INIT, ext, 0);\n\n\tif (!DirItem.size()) return NULL;\n\tif (p) ScanDirectory(path, next ? SCANF_NEXT : SCANF_PREV, \"\", 0);\n\tsnprintf(path, sizeof(path), \"%s/%s\", scanned_path, DirItem[iSelectedEntry].de.d_name);\n\n\treturn path + strlen(base_path) + 1;\n}\n\nint isXmlName(const char *path)\n{\n\tint len = strlen(path);\n\tif (len > 4)\n\t{\n\t\tif (!strcasecmp(path + len - 4, \".mra\")) return 1;\n\t\tif (!strcasecmp(path + len - 4, \".mgl\")) return 2;\n\t}\n\treturn 0;\n}\n\nfileTextReader::fileTextReader()\n{\n\tbuffer = nullptr;\n}\n\nfileTextReader::~fileTextReader()\n{\n\tif( buffer != nullptr )\n\t{\n\t\tfree(buffer);\n\t}\n\tbuffer = nullptr;\n}\n\nbool FileOpenTextReader( fileTextReader *reader, const char *filename )\n{\n\tfileTYPE f;\n\n\t// ensure buffer is freed if the reader is being reused\n\treader->~fileTextReader();\n\n\tif (FileOpen(&f, filename))\n\t{\n\t\tchar *buf = (char*)malloc(f.size+1);\n\t\tif (buf)\n\t\t{\n\t\t\tmemset(buf, 0, f.size + 1);\n\t\t\tint size;\n\t\t\tif ((size = FileReadAdv(&f, buf, f.size)))\n\t\t\t{\n\t\t\t\treader->size = f.size;\n\t\t\t\treader->buffer = buf;\n\t\t\t\treader->pos = reader->buffer;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n#define IS_NEWLINE(c) (((c) == '\\r') || ((c) == '\\n'))\n#define IS_WHITESPACE(c) (IS_NEWLINE(c) || ((c) == ' ') || ((c) == '\\t'))\n\nconst char *FileReadLine(fileTextReader *reader)\n{\n\tconst char *end = reader->buffer + reader->size;\n\twhile (reader->pos < end)\n\t{\n\t\tchar *st = reader->pos;\n\t\twhile ((reader->pos < end) && *reader->pos && !IS_NEWLINE(*reader->pos))\n\t\t\treader->pos++;\n\t\t*reader->pos = 0;\n\t\twhile (IS_WHITESPACE(*st)) st++;\n\t\tif (*st == '#' || *st == ';' || !*st)\n\t\t{\n\t\t\treader->pos++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn st;\n\t\t}\n\t}\n\treturn nullptr;\n}\n"
        },
        {
          "name": "file_io.h",
          "type": "blob",
          "size": 4.6396484375,
          "content": "#ifndef _FAT16_H_INCLUDED\n#define _FAT16_H_INCLUDED\n\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include \"spi.h\"\n\nstruct fileZipArchive;\n\nstruct fileTYPE\n{\n\tfileTYPE();\n\t~fileTYPE();\n\tint opened();\n\n\tFILE           *filp;\n\tint             mode;\n\tint             type;\n\tfileZipArchive *zip;\n\t__off64_t       size;\n\t__off64_t       offset;\n\tchar            path[1024];\n\tchar            name[261];\n};\n\nstruct direntext_t\n{\n\tdirent de;\n\tint  cookie;\n#define DT_EXT_ZIP    0x1\n\tunsigned int flags;\n\tchar datecode[16];\n\tchar altname[256];\n};\n\nstruct fileTextReader\n{\n\tfileTextReader();\n\t~fileTextReader();\n\n\tsize_t size;\n\tchar *buffer;\n\tchar *pos;\n};\n\nint flist_nDirEntries();\nint flist_iFirstEntry();\nvoid flist_iFirstEntryInc();\nint flist_iSelectedEntry();\ndirentext_t* flist_DirItem(int n);\ndirentext_t* flist_SelectedItem();\nchar* flist_Path();\nchar* flist_GetPrevNext(const char* base_path, const char* file, const char* ext, int next);\n\n// scanning flags\n#define SCANF_INIT       0 // start search from beginning of directory\n#define SCANF_NEXT       1 // find next file in directory\n#define SCANF_PREV      -1 // find previous file in directory\n#define SCANF_NEXT_PAGE  2 // find next 16 files in directory\n#define SCANF_PREV_PAGE -2 // find previous 16 files in directory\n#define SCANF_SET_ITEM   3 // find exact item\n#define SCANF_END        4 // find last file in directory\n\n// options flags\n#define SCANO_DIR        0b000000001 // include subdirectories\n#define SCANO_UMOUNT     0b000000010 // allow backspace key\n#define SCANO_CORES      0b000000100 // only include subdirectories with prefix '_'\n#define SCANO_TXT        0b000001000\n#define SCANO_NEOGEO     0b000010000\n#define SCANO_NOENTER    0b000100000\n#define SCANO_NOZIP      0b001000000\n#define SCANO_CLEAR      0b010000000 // allow backspace key, clear FC option\n#define SCANO_SAVES      0b100000000\n\nvoid FindStorage();\nint  getStorage(int from_setting);\nvoid setStorage(int dev);\nint  isUSBMounted();\n\nint  FileOpenZip(fileTYPE *file, const char *name, uint32_t crc32);\nint  FileOpenEx(fileTYPE *file, const char *name, int mode, char mute = 0, int use_zip = 1);\nint  FileOpen(fileTYPE *file, const char *name, char mute = 0);\nvoid FileClose(fileTYPE *file);\n\n__off64_t FileGetSize(fileTYPE *file);\n\nint FileSeek(fileTYPE *file, __off64_t offset, int origin);\nint FileSeekLBA(fileTYPE *file, uint32_t offset);\n\nint FileReadAdv(fileTYPE *file, void *pBuffer, int length, int failres = 0);\nint FileReadSec(fileTYPE *file, void *pBuffer);\nint FileWriteAdv(fileTYPE *file, void *pBuffer, int length, int failres = 0);\nint FileWriteSec(fileTYPE *file, void *pBuffer);\nint FileCreatePath(const char *dir);\n\nint FileExists(const char *name, int use_zip = 1);\nint FileCanWrite(const char *name);\nint PathIsDir(const char *name, int use_zip = 1);\nstruct stat64* getPathStat(const char *path);\n\n#define SAVE_DIR \"saves\"\nvoid FileGenerateSavePath(const char *name, char* out_name, int ext_replace = 1);\n\n#define SAVESTATE_DIR \"savestates\"\nvoid FileGenerateSavestatePath(const char *name, char* out_name, int sufx);\n\n#define SCREENSHOT_DIR \"screenshots\"\n#define SCREENSHOT_DEFAULT \"screen\"\nvoid FileGenerateScreenshotName(const char *name, char *out_name, int buflen);\n\nint FileSave(const char *name, void *pBuffer, int size);\nint FileLoad(const char *name, void *pBuffer, int size); // supply pBuffer = 0 to get the file size without loading\nint FileDelete(const char *name);\nint DirDelete(const char *name);\n\n//save/load from config dir\n#define CONFIG_DIR \"config\"\nconst char* GetNameFromPath(char* path);\nint FileSaveConfig(const char *name, void *pBuffer, int size);\nint FileLoadConfig(const char *name, void *pBuffer, int size); // supply pBuffer = 0 to get the file size without loading\nint FileDeleteConfig(const char *name);\n\nvoid AdjustDirectory(char *path);\nint ScanDirectory(char* path, int mode, const char *extension, int options, const char *prefix = NULL, const char *filter = NULL);\n\nvoid prefixGameDir(char *dir, size_t dir_len);\nint findPrefixDir(char *dir, size_t dir_len);\n\nconst char *getStorageDir(int dev);\nconst char *getRootDir();\nconst char *getFullPath(const char *name);\n\nuint32_t getFileType(const char *name);\nint isXmlName(const char *path); // 1 - MRA, 2 - MGL\n\nbool FileOpenTextReader(fileTextReader *reader, const char *path);\nconst char* FileReadLine(fileTextReader *reader);\n\n#define LOADBUF_SZ (1024*1024)\n\n#define COEFF_DIR \"filters\"\n#define GAMMA_DIR \"gamma\"\n#define AFILTER_DIR \"filters_audio\"\n#define SMASK_DIR \"shadow_masks\"\n#define PRESET_DIR \"presets\"\n#define GAMES_DIR \"games\"\n#define CIFS_DIR \"cifs\"\n#define DOCS_DIR \"docs\"\n\nvoid create_path(const char *base_dir, const char* sub_dir);\n\n#endif\n"
        },
        {
          "name": "fpga_base_addr_ac5.h",
          "type": "blob",
          "size": 2.392578125,
          "content": "/*\n*  Copyright (C) 2012 Altera Corporation <www.altera.com>\n*\n* SPDX-License-Identifier:\tGPL-2.0+\n*/\n\n#ifndef _SOCFPGA_BASE_ADDRS_H_\n#define _SOCFPGA_BASE_ADDRS_H_\n\n#define SOCFPGA_DAP_ADDRESS\t\t\t\t0xff000000\n#define SOCFPGA_EMAC0_ADDRESS\t\t\t0xff700000\n#define SOCFPGA_EMAC1_ADDRESS\t\t\t0xff702000\n#define SOCFPGA_SDMMC_ADDRESS\t\t\t0xff704000\n#define SOCFPGA_QSPI_ADDRESS\t\t\t0xff705000\n#define SOCFPGA_MGR_ADDRESS\t\t\t\t0xff706000\n#define SOCFPGA_GPIO0_ADDRESS\t\t\t0xff708000\n#define SOCFPGA_GPIO1_ADDRESS\t\t\t0xff709000\n#define SOCFPGA_GPIO2_ADDRESS\t\t\t0xff70a000\n#define SOCFPGA_L3REGS_ADDRESS\t\t\t0xff800000\n#define SOCFPGA_USB0_ADDRESS\t\t\t0xffb00000\n#define SOCFPGA_USB1_ADDRESS\t\t\t0xffb40000\n#define SOCFPGA_CAN0_ADDRESS\t\t\t0xffc00000\n#define SOCFPGA_CAN1_ADDRESS\t\t\t0xffc01000\n#define SOCFPGA_UART0_ADDRESS\t\t\t0xffc02000\n#define SOCFPGA_UART1_ADDRESS\t\t\t0xffc03000\n#define SOCFPGA_I2C0_ADDRESS\t\t\t0xffc04000\n#define SOCFPGA_I2C1_ADDRESS\t\t\t0xffc05000\n#define SOCFPGA_I2C2_ADDRESS\t\t\t0xffc06000\n#define SOCFPGA_I2C3_ADDRESS\t\t\t0xffc07000\n#define SOCFPGA_SDR_ADDRESS\t\t\t\t0xffc20000\n#define SOCFPGA_L4WD0_ADDRESS\t\t\t0xffd02000\n#define SOCFPGA_L4WD1_ADDRESS\t\t\t0xffd03000\n#define SOCFPGA_CLKMGR_ADDRESS\t\t\t0xffd04000\n#define SOCFPGA_RSTMGR_ADDRESS\t\t\t0xffd05000\n#define SOCFPGA_SYSMGR_ADDRESS\t\t\t0xffd08000\n#define SOCFPGA_SPIS0_ADDRESS\t\t\t0xffe02000\n#define SOCFPGA_SPIS1_ADDRESS\t\t\t0xffe03000\n#define SOCFPGA_SPIM0_ADDRESS\t\t\t0xfff00000\n#define SOCFPGA_SPIM1_ADDRESS\t\t\t0xfff01000\n#define SOCFPGA_SCANMGR_ADDRESS\t\t\t0xfff02000\n#define SOCFPGA_ROM_ADDRESS\t\t\t\t0xfffd0000\n#define SOCFPGA_MPUSCU_ADDRESS\t\t\t0xfffec000\n#define SOCFPGA_MPUL2_ADDRESS\t\t\t0xfffef000\n#define SOCFPGA_OCRAM_ADDRESS\t\t\t0xffff0000\n#define SOCFPGA_LWFPGASLAVES_ADDRESS\t0xff200000\n#define SOCFPGA_LWHPS2FPGAREGS_ADDRESS\t0xff400000\n#define SOCFPGA_HPS2FPGAREGS_ADDRESS\t0xff500000\n#define SOCFPGA_FPGA2HPSREGS_ADDRESS\t0xff600000\n#define SOCFPGA_FPGAMGRREGS_ADDRESS\t\t0xff706000\n#define SOCFPGA_ACPIDMAP_ADDRESS\t\t0xff707000\n#define SOCFPGA_NANDDATA_ADDRESS\t\t0xff900000\n#define SOCFPGA_QSPIDATA_ADDRESS\t\t0xffa00000\n#define SOCFPGA_NANDREGS_ADDRESS\t\t0xffb80000\n#define SOCFPGA_FPGAMGRDATA_ADDRESS\t\t0xffb90000\n#define SOCFPGA_SPTIMER0_ADDRESS\t\t0xffc08000\n#define SOCFPGA_SPTIMER1_ADDRESS\t\t0xffc09000\n#define SOCFPGA_OSC1TIMER0_ADDRESS\t\t0xffd00000\n#define SOCFPGA_OSC1TIMER1_ADDRESS\t\t0xffd01000\n#define SOCFPGA_DMANONSECURE_ADDRESS\t0xffe00000\n#define SOCFPGA_DMASECURE_ADDRESS\t\t0xffe01000\n\n#endif /* _SOCFPGA_BASE_ADDRS_H_ */\n"
        },
        {
          "name": "fpga_io.cpp",
          "type": "blob",
          "size": 22.64453125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <ctype.h>\n#include <termios.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"fpga_io.h\"\n#include \"file_io.h\"\n#include \"input.h\"\n#include \"osd.h\"\n#include \"menu.h\"\n#include \"shmem.h\"\n#include \"offload.h\"\n\n#include \"fpga_base_addr_ac5.h\"\n#include \"fpga_manager.h\"\n#include \"fpga_system_manager.h\"\n#include \"fpga_reset_manager.h\"\n#include \"fpga_nic301.h\"\n\n#define FPGA_REG_BASE 0xFF000000\n#define FPGA_REG_SIZE 0x01000000\n\n#define MAP_ADDR(x) (volatile uint32_t*)(&map_base[(((uint32_t)(x)) & 0xFFFFFF)>>2])\n#define IS_REG(x) (((((uint32_t)(x))-1)>=(FPGA_REG_BASE - 1)) && ((((uint32_t)(x))-1)<(FPGA_REG_BASE + FPGA_REG_SIZE - 1)))\n\n#define fatal(x) munmap((void*)map_base, FPGA_REG_SIZE); close(fd); exit(x)\n\nstatic struct socfpga_reset_manager  *reset_regs   = (socfpga_reset_manager *)SOCFPGA_RSTMGR_ADDRESS;\nstatic struct socfpga_fpga_manager   *fpgamgr_regs = (socfpga_fpga_manager *)SOCFPGA_FPGAMGRREGS_ADDRESS;\nstatic struct socfpga_system_manager *sysmgr_regs  = (socfpga_system_manager *)SOCFPGA_SYSMGR_ADDRESS;\nstatic struct nic301_registers       *nic301_regs  = (nic301_registers *)SOCFPGA_L3REGS_ADDRESS;\n\nstatic uint32_t *map_base;\n\n#define writel(val, reg) *MAP_ADDR(reg) = val\n#define readl(reg) *MAP_ADDR(reg)\n\n#define clrsetbits_le32(addr, clear, set) writel((readl(addr) & ~(clear)) | (set), addr)\n#define setbits_le32(addr, set)           writel( readl(addr) | (set), addr)\n#define clrbits_le32(addr, clear)         writel( readl(addr) & ~(clear), addr)\n\n/* Timeout count */\n#define FPGA_TIMEOUT_CNT\t\t0x1000000\n\n/* Set CD ratio */\nstatic void fpgamgr_set_cd_ratio(unsigned long ratio)\n{\n\tclrsetbits_le32(&fpgamgr_regs->ctrl,\n\t\t0x3 << FPGAMGRREGS_CTRL_CDRATIO_LSB,\n\t\t(ratio & 0x3) << FPGAMGRREGS_CTRL_CDRATIO_LSB);\n}\n\nstatic int fpgamgr_dclkcnt_set(unsigned long cnt)\n{\n\tunsigned long i;\n\n\t/* Clear any existing done status */\n\tif (readl(&fpgamgr_regs->dclkstat))\n\t\twritel(0x1, &fpgamgr_regs->dclkstat);\n\n\t/* Write the dclkcnt */\n\twritel(cnt, &fpgamgr_regs->dclkcnt);\n\n\t/* Wait till the dclkcnt done */\n\tfor (i = 0; i < FPGA_TIMEOUT_CNT; i++) {\n\t\tif (!readl(&fpgamgr_regs->dclkstat))\n\t\t\tcontinue;\n\n\t\twritel(0x1, &fpgamgr_regs->dclkstat);\n\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n/* Check whether FPGA Init_Done signal is high */\nstatic int is_fpgamgr_initdone_high(void)\n{\n\tunsigned long val;\n\n\tval = readl(&fpgamgr_regs->gpio_ext_porta);\n\treturn val & FPGAMGRREGS_MON_GPIO_EXT_PORTA_ID_MASK;\n}\n\n/* Get the FPGA mode */\nstatic int fpgamgr_get_mode(void)\n{\n\tunsigned long val;\n\n\tval = readl(&fpgamgr_regs->stat);\n\treturn val & FPGAMGRREGS_STAT_MODE_MASK;\n}\n\n/* Check whether FPGA is ready to be accessed */\nstatic int fpgamgr_test_fpga_ready(void)\n{\n\t/* Check for init done signal */\n\tif (!is_fpgamgr_initdone_high())\n\t\treturn 0;\n\n\t/* Check again to avoid false glitches */\n\tif (!is_fpgamgr_initdone_high())\n\t\treturn 0;\n\n\tif (fpgamgr_get_mode() != FPGAMGRREGS_MODE_USERMODE)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n// Poll until FPGA is ready to be accessed or timeout occurred\nstatic int fpgamgr_poll_fpga_ready(void)\n{\n\tunsigned long i;\n\n\t// If FPGA is blank, wait till WD invoke warm reset\n\tfor (i = 0; i < FPGA_TIMEOUT_CNT; i++) {\n\t\t// check for init done signal\n\t\tif (!is_fpgamgr_initdone_high())\n\t\t\tcontinue;\n\t\t// check again to avoid false glitches\n\t\tif (!is_fpgamgr_initdone_high())\n\t\t\tcontinue;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n*/\n\n/* Start the FPGA programming by initialize the FPGA Manager */\nstatic int fpgamgr_program_init(void)\n{\n\tunsigned long msel, i;\n\n\t/* Get the MSEL value */\n\tmsel = readl(&fpgamgr_regs->stat);\n\tmsel &= FPGAMGRREGS_STAT_MSEL_MASK;\n\tmsel >>= FPGAMGRREGS_STAT_MSEL_LSB;\n\n\t/*\n\t* Set the cfg width\n\t* If MSEL[3] = 1, cfg width = 32 bit\n\t*/\n\tif (msel & 0x8) {\n\t\tsetbits_le32(&fpgamgr_regs->ctrl,\n\t\t\tFPGAMGRREGS_CTRL_CFGWDTH_MASK);\n\n\t\t/* To determine the CD ratio */\n\t\t/* MSEL[1:0] = 0, CD Ratio = 1 */\n\t\tif ((msel & 0x3) == 0x0)\n\t\t\tfpgamgr_set_cd_ratio(CDRATIO_x1);\n\t\t/* MSEL[1:0] = 1, CD Ratio = 4 */\n\t\telse if ((msel & 0x3) == 0x1)\n\t\t\tfpgamgr_set_cd_ratio(CDRATIO_x4);\n\t\t/* MSEL[1:0] = 2, CD Ratio = 8 */\n\t\telse if ((msel & 0x3) == 0x2)\n\t\t\tfpgamgr_set_cd_ratio(CDRATIO_x8);\n\n\t}\n\telse {\t/* MSEL[3] = 0 */\n\t\tclrbits_le32(&fpgamgr_regs->ctrl,\n\t\t\tFPGAMGRREGS_CTRL_CFGWDTH_MASK);\n\n\t\t/* To determine the CD ratio */\n\t\t/* MSEL[1:0] = 0, CD Ratio = 1 */\n\t\tif ((msel & 0x3) == 0x0)\n\t\t\tfpgamgr_set_cd_ratio(CDRATIO_x1);\n\t\t/* MSEL[1:0] = 1, CD Ratio = 2 */\n\t\telse if ((msel & 0x3) == 0x1)\n\t\t\tfpgamgr_set_cd_ratio(CDRATIO_x2);\n\t\t/* MSEL[1:0] = 2, CD Ratio = 4 */\n\t\telse if ((msel & 0x3) == 0x2)\n\t\t\tfpgamgr_set_cd_ratio(CDRATIO_x4);\n\t}\n\n\t/* To enable FPGA Manager configuration */\n\tclrbits_le32(&fpgamgr_regs->ctrl, FPGAMGRREGS_CTRL_NCE_MASK);\n\n\t/* To enable FPGA Manager drive over configuration line */\n\tsetbits_le32(&fpgamgr_regs->ctrl, FPGAMGRREGS_CTRL_EN_MASK);\n\n\t/* Put FPGA into reset phase */\n\tsetbits_le32(&fpgamgr_regs->ctrl, FPGAMGRREGS_CTRL_NCONFIGPULL_MASK);\n\n\t/* (1) wait until FPGA enter reset phase */\n\tfor (i = 0; i < FPGA_TIMEOUT_CNT; i++) {\n\t\tif (fpgamgr_get_mode() == FPGAMGRREGS_MODE_RESETPHASE)\n\t\t\tbreak;\n\t}\n\n\t/* If not in reset state, return error */\n\tif (fpgamgr_get_mode() != FPGAMGRREGS_MODE_RESETPHASE) {\n\t\tputs(\"FPGA: Could not reset\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Release FPGA from reset phase */\n\tclrbits_le32(&fpgamgr_regs->ctrl, FPGAMGRREGS_CTRL_NCONFIGPULL_MASK);\n\n\t/* (2) wait until FPGA enter configuration phase */\n\tfor (i = 0; i < FPGA_TIMEOUT_CNT; i++) {\n\t\tif (fpgamgr_get_mode() == FPGAMGRREGS_MODE_CFGPHASE)\n\t\t\tbreak;\n\t}\n\n\t/* If not in configuration state, return error */\n\tif (fpgamgr_get_mode() != FPGAMGRREGS_MODE_CFGPHASE) {\n\t\tputs(\"FPGA: Could not configure\\n\");\n\t\treturn -2;\n\t}\n\n\t/* Clear all interrupts in CB Monitor */\n\twritel(0xFFF, &fpgamgr_regs->gpio_porta_eoi);\n\n\t/* Enable AXI configuration */\n\tsetbits_le32(&fpgamgr_regs->ctrl, FPGAMGRREGS_CTRL_AXICFGEN_MASK);\n\n\treturn 0;\n}\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))\n\n/* Write the RBF data to FPGA Manager */\nstatic void fpgamgr_program_write(const void *rbf_data, unsigned long rbf_size)\n{\n\tuint32_t src = (uint32_t)rbf_data;\n\tuint32_t dst = (uint32_t)MAP_ADDR(SOCFPGA_FPGAMGRDATA_ADDRESS);\n\n\t/* Number of loops for 32-byte long copying. */\n\tuint32_t loops32 = rbf_size / 32;\n\t/* Number of loops for 4-byte long copying + trailing bytes */\n\tuint32_t loops4 = DIV_ROUND_UP(rbf_size % 32, 4);\n\n\t__asm volatile(\n\t\t\"1:\tldmia %0!,{r0-r7}   \\n\"\n\t\t\"\tstmia %1!,{r0-r7}   \\n\"\n\t\t\"\tsub\t  %1, #32       \\n\"\n\t\t\"\tsubs  %2, #1        \\n\"\n\t\t\"\tbne   1b            \\n\"\n\t\t\"\tcmp   %3, #0        \\n\"\n\t\t\"\tbeq   3f            \\n\"\n\t\t\"2:\tldr\t  %2, [%0], #4  \\n\"\n\t\t\"\tstr   %2, [%1]      \\n\"\n\t\t\"\tsubs  %3, #1        \\n\"\n\t\t\"\tbne   2b            \\n\"\n\t\t\"3:\tnop                 \\n\"\n\t\t: \"+r\"(src), \"+r\"(dst), \"+r\"(loops32), \"+r\"(loops4) :\n\t\t: \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"cc\");\n}\n\n/* Ensure the FPGA entering config done */\nstatic int fpgamgr_program_poll_cd(void)\n{\n\tconst uint32_t mask = FPGAMGRREGS_MON_GPIO_EXT_PORTA_NS_MASK |\n\t\tFPGAMGRREGS_MON_GPIO_EXT_PORTA_CD_MASK;\n\tunsigned long reg, i;\n\n\t/* (3) wait until full config done */\n\tfor (i = 0; i < FPGA_TIMEOUT_CNT; i++) {\n\t\treg = readl(&fpgamgr_regs->gpio_ext_porta);\n\n\t\t/* Config error */\n\t\tif (!(reg & mask)) {\n\t\t\tprintf(\"FPGA: Configuration error.\\n\");\n\t\t\treturn -3;\n\t\t}\n\n\t\t/* Config done without error */\n\t\tif (reg & mask)\n\t\t\tbreak;\n\t}\n\n\t/* Timeout happened, return error */\n\tif (i == FPGA_TIMEOUT_CNT) {\n\t\tprintf(\"FPGA: Timeout waiting for program.\\n\");\n\t\treturn -4;\n\t}\n\n\t/* Disable AXI configuration */\n\tclrbits_le32(&fpgamgr_regs->ctrl, FPGAMGRREGS_CTRL_AXICFGEN_MASK);\n\n\treturn 0;\n}\n\n/* Ensure the FPGA entering init phase */\nstatic int fpgamgr_program_poll_initphase(void)\n{\n\tunsigned long i;\n\n\t/* Additional clocks for the CB to enter initialization phase */\n\tif (fpgamgr_dclkcnt_set(0x4))\n\t\treturn -5;\n\n\t/* (4) wait until FPGA enter init phase or user mode */\n\tfor (i = 0; i < FPGA_TIMEOUT_CNT; i++) {\n\t\tif (fpgamgr_get_mode() == FPGAMGRREGS_MODE_INITPHASE)\n\t\t\tbreak;\n\t\tif (fpgamgr_get_mode() == FPGAMGRREGS_MODE_USERMODE)\n\t\t\tbreak;\n\t}\n\n\t/* If not in configuration state, return error */\n\tif (i == FPGA_TIMEOUT_CNT)\n\t\treturn -6;\n\n\treturn 0;\n}\n\n/* Ensure the FPGA entering user mode */\nstatic int fpgamgr_program_poll_usermode(void)\n{\n\tunsigned long i;\n\n\t/* Additional clocks for the CB to exit initialization phase */\n\tif (fpgamgr_dclkcnt_set(0x5000))\n\t\treturn -7;\n\n\t/* (5) wait until FPGA enter user mode */\n\tfor (i = 0; i < FPGA_TIMEOUT_CNT; i++) {\n\t\tif (fpgamgr_get_mode() == FPGAMGRREGS_MODE_USERMODE)\n\t\t\tbreak;\n\t}\n\t/* If not in configuration state, return error */\n\tif (i == FPGA_TIMEOUT_CNT)\n\t\treturn -8;\n\n\t/* To release FPGA Manager drive over configuration line */\n\tclrbits_le32(&fpgamgr_regs->ctrl, FPGAMGRREGS_CTRL_EN_MASK);\n\n\treturn 0;\n}\n\n/*\n* FPGA Manager to program the FPGA. This is the interface used by FPGA driver.\n* Return 0 for sucess, non-zero for error.\n*/\nstatic int socfpga_load(const void *rbf_data, size_t rbf_size)\n{\n\tunsigned long status;\n\n\tif ((uint32_t)rbf_data & 0x3) {\n\t\tprintf(\"FPGA: Unaligned data, realign to 32bit boundary.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Initialize the FPGA Manager */\n\tstatus = fpgamgr_program_init();\n\tif (status)\n\t\treturn status;\n\n\t/* Write the RBF data to FPGA Manager */\n\tfpgamgr_program_write(rbf_data, rbf_size);\n\n\t/* Ensure the FPGA entering config done */\n\tstatus = fpgamgr_program_poll_cd();\n\tif (status)\n\t\treturn status;\n\n\t/* Ensure the FPGA entering init phase */\n\tstatus = fpgamgr_program_poll_initphase();\n\tif (status)\n\t\treturn status;\n\n\t/* Ensure the FPGA entering user mode */\n\treturn fpgamgr_program_poll_usermode();\n}\n\nstatic void do_bridge(uint32_t enable)\n{\n\tif (enable)\n\t{\n\t\twritel(0x00003FFF, (void*)(SOCFPGA_SDR_ADDRESS + 0x5080));\n\t\twritel(0x00000000, &reset_regs->brg_mod_reset);\n\t\twritel(0x00000019, &nic301_regs->remap);\n\t}\n\telse\n\t{\n\t\twritel(0, &sysmgr_regs->fpgaintfgrp_module);\n\t\twritel(0, (void*)(SOCFPGA_SDR_ADDRESS + 0x5080));\n\t\twritel(7, &reset_regs->brg_mod_reset);\n\t\twritel(1, &nic301_regs->remap);\n\t}\n}\n\nstatic int make_env(const char *name, const char *cfg)\n{\n\tvoid* buf = shmem_map(0x1FFFF000, 0x1000);\n\tif (!buf) return -1;\n\n\tvolatile char* str = (volatile char*)buf;\n\tmemset((void*)str, 0, 0xF00);\n\n\t*str++ = 0x21;\n\t*str++ = 0x43;\n\t*str++ = 0x65;\n\t*str++ = 0x87;\n\t*str++ = 'c';\n\t*str++ = 'o';\n\t*str++ = 'r';\n\t*str++ = 'e';\n\t*str++ = '=';\n\t*str++ = '\"';\n\n\tfor (uint32_t i = 0; i < strlen(name); i++)\n\t{\n\t\t*str++ = name[i];\n\t}\n\n\t*str++ = '\"';\n\t*str++ = '\\n';\n\tFileLoad(cfg, (void*)str, 0);\n\tshmem_unmap(buf, 0x1000);\n\treturn 0;\n}\n\nint fpga_load_rbf(const char *name, const char *cfg, const char *xml)\n{\n\tOsdDisable();\n\tstatic char path[1024];\n\tint ret = 0;\n\n\tif(cfg)\n\t{\n\t\tfpga_core_reset(1);\n\t\tmake_env(name, cfg);\n\t\tdo_bridge(0);\n\t\treboot(0);\n\t}\n\n\tprintf(\"Loading RBF: %s\\n\", name);\n\n\tif(name[0] == '/') strcpy(path, name);\n\telse sprintf(path, \"%s/%s\", !strcasecmp(name, \"menu.rbf\") ? getStorageDir(0) : getRootDir(), name);\n\n\tint rbf = open(path, O_RDONLY);\n\tif (rbf < 0)\n\t{\n\t\tchar error[4096];\n\t\tsnprintf(error,4096,\"%s\\nNot Found\", name);\n\t\tprintf(\"Couldn't open file %s\\n\", path);\n\t\tInfo(error,5000);\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tstruct stat64 st;\n\t\tif (fstat64(rbf, &st)<0)\n\t\t{\n\t\t\tprintf(\"Couldn't get info of file %s\\n\", path);\n\t\t\tret = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Bitstream size: %lld bytes\\n\", st.st_size);\n\n\t\t\tvoid *buf = malloc(st.st_size);\n\t\t\tif (!buf)\n\t\t\t{\n\t\t\t\tprintf(\"Couldn't allocate %llu bytes.\\n\", st.st_size);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfpga_core_reset(1);\n\t\t\t\tif (read(rbf, buf, st.st_size)<st.st_size)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Couldn't read file %s\\n\", name);\n\t\t\t\t\tret = -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvoid *p = buf;\n\t\t\t\t\t__off64_t sz = st.st_size;\n\t\t\t\t\tif (!memcmp(buf, \"MiSTer\", 6))\n\t\t\t\t\t{\n\t\t\t\t\t\tsz = *(uint32_t*)(((uint8_t*)buf) + 12);\n\t\t\t\t\t\tp = (void*)(((uint8_t*)buf) + 16);\n\t\t\t\t\t}\n\t\t\t\t\tdo_bridge(0);\n\t\t\t\t\tret = socfpga_load(p, sz);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"Error %d while loading %s\\n\", ret, path);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdo_bridge(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(buf);\n\t\t\t}\n\t\t}\n\t}\n\tclose(rbf);\n\n\tapp_restart(!strcasecmp(name, \"menu.rbf\") ? \"menu.rbf\" : path, xml);\n\treturn ret;\n}\n\nstatic uint32_t gpo_copy = 0;\nvoid inline fpga_gpo_write(uint32_t value)\n{\n\tgpo_copy = value;\n\twritel(value, (void*)(SOCFPGA_MGR_ADDRESS + 0x10));\n}\n\n#define fpga_gpo_writeN(value) writel((value), (void*)(SOCFPGA_MGR_ADDRESS + 0x10))\n#define fpga_gpo_read() gpo_copy //readl((void*)(SOCFPGA_MGR_ADDRESS + 0x10))\n#define fpga_gpi_read() (int)readl((void*)(SOCFPGA_MGR_ADDRESS + 0x14))\n\nvoid fpga_core_write(uint32_t offset, uint32_t value)\n{\n\tif (offset <= 0x1FFFFF) writel(value, (void*)(SOCFPGA_LWFPGASLAVES_ADDRESS + (offset & ~3)));\n}\n\nuint32_t fpga_core_read(uint32_t offset)\n{\n\tif (offset <= 0x1FFFFF) return readl((void*)(SOCFPGA_LWFPGASLAVES_ADDRESS + (offset & ~3)));\n\treturn 0;\n}\n\nint fpga_io_init()\n{\n\tmap_base = (uint32_t*)shmem_map(FPGA_REG_BASE, FPGA_REG_SIZE);\n\tif (!map_base) return -1;\n\n\tfpga_gpo_write(0);\n\treturn 0;\n}\n\nint fpga_core_id()\n{\n\tuint32_t gpo = (fpga_gpo_read() & 0x7FFFFFFF);\n\tfpga_gpo_write(gpo);\n\tuint32_t coretype = fpga_gpi_read();\n\tgpo |= 0x80000000;\n\tfpga_gpo_write(gpo);\n\n\tif ((coretype >> 8) != 0x5CA623) return -1;\n\treturn coretype & 0xFF;\n}\n\nint fpga_get_fio_size()\n{\n\treturn (fpga_gpi_read() >> 16) & 1;\n}\n\nint fpga_get_io_version()\n{\n\treturn (fpga_gpi_read() >> 18) & 3;\n}\n\nvoid fpga_set_led(uint32_t on)\n{\n\tuint32_t gpo = fpga_gpo_read();\n\tfpga_gpo_write(on ? gpo | 0x20000000 : gpo & ~0x20000000);\n}\n\nint fpga_get_buttons()\n{\n\tfpga_gpo_write(fpga_gpo_read() | 0x80000000);\n\tint gpi = fpga_gpi_read();\n\tif (gpi < 0) gpi = 0; // FPGA is not in user mode. Ignore the data;\n\treturn (gpi >> 29) & 3;\n}\n\nint fpga_get_io_type()\n{\n\tfpga_gpo_write(fpga_gpo_read() | 0x80000000);\n\treturn (fpga_gpi_read() >> 28) & 1;\n}\n\nvoid reboot(int cold)\n{\n\tsync();\n\tfpga_core_reset(1);\n\n\tusleep(500000);\n\n\tvoid* buf = shmem_map(0x1FFFF000, 0x1000);\n\tif (buf)\n\t{\n\t\tvolatile uint32_t* flg = (volatile uint32_t*)buf;\n\t\tflg += 0xF08/4;\n\t\t*flg = cold ? 0 : 0xBEEFB001;\n\t\tshmem_unmap(buf, 0x1000);\n\t}\n\n\twritel(1, &reset_regs->ctrl);\n\twhile (1) sleep(1);\n}\n\nchar *getappname()\n{\n\tstatic char dest[PATH_MAX];\n\tmemset(dest, 0, sizeof(dest));\n\n\tchar path[64];\n\tsprintf(path, \"/proc/%d/exe\", getpid());\n\treadlink(path, dest, PATH_MAX);\n\n\treturn dest;\n}\n\nvoid app_restart(const char *path, const char *xml, const char *exe)\n{\n\tsync();\n\tfpga_core_reset(1);\n\n\tinput_switch(0);\n\tinput_uinp_destroy();\n\n\toffload_stop();\n\n\tconst char *appname = exe ? exe : getappname();\n\tprintf(\"restarting to %s\\n\", appname);\n\texecl(appname, appname, path, xml, NULL);\n\n\tprintf(\"Something went wrong. Rebooting...\\n\");\n\treboot(1);\n}\n\nvoid fpga_core_reset(int reset)\n{\n\tuint32_t gpo = fpga_gpo_read() & ~0xC0000000;\n\tfpga_gpo_write(reset ? gpo | 0x40000000 : gpo | 0x80000000);\n}\n\nint is_fpga_ready(int quick)\n{\n\tif (quick)\n\t{\n\t\treturn (fpga_gpi_read() >= 0);\n\t}\n\n\treturn fpgamgr_test_fpga_ready();\n}\n\n#define SSPI_STROBE  (1<<17)\n#define SSPI_ACK     SSPI_STROBE\n\nvoid fpga_spi_en(uint32_t mask, uint32_t en)\n{\n\tuint32_t gpo = fpga_gpo_read() | 0x80000000;\n\tfpga_gpo_write(en ? gpo | mask : gpo & ~mask);\n}\n\nvoid fpga_wait_to_reset()\n{\n\tprintf(\"FPGA is not ready. JTAG uploading?\\n\");\n\tprintf(\"Waiting for FPGA to be ready...\\n\");\n\n\tfpga_core_reset(1);\n\n\twhile (!is_fpga_ready(0))\n\t{\n\t\tsleep(1);\n\t}\n\treboot(0);\n}\n\nuint16_t fpga_spi(uint16_t word)\n{\n\tuint32_t gpo = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE)) | word;\n\n\tfpga_gpo_write(gpo);\n\tfpga_gpo_write(gpo | SSPI_STROBE);\n\n\tint gpi;\n\tdo\n\t{\n\t\tgpi = fpga_gpi_read();\n\t\tif (gpi < 0)\n\t\t{\n\t\t\tprintf(\"GPI[31]==1. FPGA is uninitialized?\\n\");\n\t\t\tfpga_wait_to_reset();\n\t\t\treturn 0;\n\t\t}\n\t} while (!(gpi & SSPI_ACK));\n\n\tfpga_gpo_write(gpo);\n\n\tdo\n\t{\n\t\tgpi = fpga_gpi_read();\n\t\tif (gpi < 0)\n\t\t{\n\t\t\tprintf(\"GPI[31]==1. FPGA is uninitialized?\\n\");\n\t\t\tfpga_wait_to_reset();\n\t\t\treturn 0;\n\t\t}\n\t} while (gpi & SSPI_ACK);\n\n\treturn (uint16_t)gpi;\n}\n\nuint16_t fpga_spi_fast(uint16_t word)\n{\n\tuint32_t gpo = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE)) | word;\n\tfpga_gpo_write(gpo);\n\tfpga_gpo_write(gpo | SSPI_STROBE);\n\tfpga_gpo_write(gpo);\n\treturn (uint16_t)fpga_gpi_read();\n}\n\nvoid fpga_spi_fast_block_write(const uint16_t *buf, uint32_t length)\n{\n\tuint32_t gpoH = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE));\n\tuint32_t gpo = gpoH;\n\n\t// should be optimized for speed by compiler automatically\n\twhile (length--)\n\t{\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t}\n\tfpga_gpo_write(gpo);\n}\n\nvoid fpga_spi_fast_block_read(uint16_t *buf, uint32_t length)\n{\n\tuint32_t gpo = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE));\n\tuint32_t rem = length % 16;\n\tlength /= 16;\n\n\t// not optimized by compiler automatically\n\t// so do manual optimization for speed.\n\twhile (length--)\n\t{\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\t}\n\n\twhile (rem--)\n\t{\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint16_t)fpga_gpi_read();\n\t}\n}\n\nvoid fpga_spi_fast_block_write_8(const uint8_t *buf, uint32_t length)\n{\n\tuint32_t gpoH = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE));\n\tuint32_t gpo = gpoH;\n\tuint32_t rem = length % 16;\n\tlength /= 16;\n\n\t// not optimized by compiler automatically\n\t// so do manual optimization for speed.\n\twhile (length--)\n\t{\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t}\n\n\twhile (rem--)\n\t{\n\t\tgpo = gpoH | *buf++;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t}\n\n\tfpga_gpo_write(gpo);\n}\n\nvoid fpga_spi_fast_block_read_8(uint8_t *buf, uint32_t length)\n{\n\tuint32_t gpo = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE));\n\tuint32_t rem = length % 16;\n\tlength /= 16;\n\n\t// not optimized by compiler automatically\n\t// so do manual optimization for speed.\n\twhile (length--)\n\t{\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\t}\n\n\twhile (rem--)\n\t{\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\t*buf++ = (uint8_t)fpga_gpi_read();\n\t}\n}\n\nvoid fpga_spi_fast_block_write_be(const uint16_t *buf, uint32_t length)\n{\n\tuint32_t gpoH = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE));\n\tuint32_t gpo = gpoH;\n\n\t// should be optimized for speed by compiler automatically\n\twhile (length--)\n\t{\n\t\tuint16_t tmp = *buf++;\n\t\ttmp = (tmp << 8) | (tmp >> 8);\n\t\tgpo = gpoH | tmp;\n\t\tfpga_gpo_writeN(gpo);\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t}\n\tfpga_gpo_write(gpo);\n}\n\nvoid fpga_spi_fast_block_read_be(uint16_t *buf, uint32_t length)\n{\n\tuint32_t gpo = (fpga_gpo_read() & ~(0xFFFF | SSPI_STROBE));\n\n\t// should be optimized for speed by compiler automatically\n\twhile (length--)\n\t{\n\t\tfpga_gpo_writeN(gpo | SSPI_STROBE);\n\t\tfpga_gpo_writeN(gpo);\n\t\tuint16_t tmp = (uint16_t)fpga_gpi_read();\n\t\t*buf++ = (tmp << 8) | (tmp >> 8);\n\t}\n}\n"
        },
        {
          "name": "fpga_io.h",
          "type": "blob",
          "size": 1.17578125,
          "content": "\n#include <stdint.h>\n\n#ifndef FPGAIO_H\n#define FPGAIO_H\n\n#define BUTTON_OSD  1\n#define BUTTON_USR  2\n\nint fpga_io_init();\n\nvoid fpga_spi_en(uint32_t mask, uint32_t en);\nuint16_t fpga_spi(uint16_t word);\nuint16_t fpga_spi_fast(uint16_t word);\n\nvoid fpga_spi_fast_block_write(const uint16_t *buf, uint32_t length);\nvoid fpga_spi_fast_block_read(uint16_t *buf, uint32_t length);\nvoid fpga_spi_fast_block_write_8(const uint8_t *buf, uint32_t length);\nvoid fpga_spi_fast_block_read_8(uint8_t *buf, uint32_t length);\nvoid fpga_spi_fast_block_write_be(const uint16_t *buf, uint32_t length);\nvoid fpga_spi_fast_block_read_be(uint16_t *buf, uint32_t length);\n\nvoid fpga_set_led(uint32_t on);\nint  fpga_get_buttons();\nint fpga_get_io_type();\n\nvoid fpga_core_reset(int reset);\nvoid fpga_core_write(uint32_t offset, uint32_t value);\nuint32_t fpga_core_read(uint32_t offset);\nint fpga_core_id();\nint is_fpga_ready(int quick);\n\nint fpga_get_fio_size();\nint fpga_get_io_version();\n\nint fpga_load_rbf(const char *name, const char *cfg = 0, const char *xml = 0);\n\nvoid reboot(int cold);\nvoid app_restart(const char *path, const char *xml = 0, const char *exe = 0);\nchar *getappname();\n\nvoid fpga_wait_to_reset();\n\n#endif\n"
        },
        {
          "name": "fpga_manager.h",
          "type": "blob",
          "size": 1.8955078125,
          "content": "/*\n* Copyright (C) 2012 Altera Corporation <www.altera.com>\n* All rights reserved.\n*\n* SPDX-License-Identifier:    BSD-3-Clause\n*/\n\n#ifndef\t_FPGA_MANAGER_H_\n#define\t_FPGA_MANAGER_H_\n\nstruct socfpga_fpga_manager {\n\t/* FPGA Manager Module */\n\tuint32_t\tstat;\t\t\t/* 0x00 */\n\tuint32_t\tctrl;\n\tuint32_t\tdclkcnt;\n\tuint32_t\tdclkstat;\n\tuint32_t\tgpo;\t\t\t/* 0x10 */\n\tuint32_t\tgpi;\n\tuint32_t\tmisci;\t\t\t/* 0x18 */\n\tuint32_t\t_pad_0x1c_0x82c[517];\n\n\t/* Configuration Monitor (MON) Registers */\n\tuint32_t\tgpio_inten;\t\t/* 0x830 */\n\tuint32_t\tgpio_intmask;\n\tuint32_t\tgpio_inttype_level;\n\tuint32_t\tgpio_int_polarity;\n\tuint32_t\tgpio_intstatus;\t\t/* 0x840 */\n\tuint32_t\tgpio_raw_intstatus;\n\tuint32_t\t_pad_0x848;\n\tuint32_t\tgpio_porta_eoi;\n\tuint32_t\tgpio_ext_porta;\t\t/* 0x850 */\n\tuint32_t\t_pad_0x854_0x85c[3];\n\tuint32_t\tgpio_1s_sync;\t\t/* 0x860 */\n\tuint32_t\t_pad_0x864_0x868[2];\n\tuint32_t\tgpio_ver_id_code;\n\tuint32_t\tgpio_config_reg2;\t/* 0x870 */\n\tuint32_t\tgpio_config_reg1;\n};\n\n#define FPGAMGRREGS_STAT_MODE_MASK\t\t0x7\n#define FPGAMGRREGS_STAT_MSEL_MASK\t\t0xf8\n#define FPGAMGRREGS_STAT_MSEL_LSB\t\t3\n\n#define FPGAMGRREGS_CTRL_CFGWDTH_MASK\t\t0x200\n#define FPGAMGRREGS_CTRL_AXICFGEN_MASK\t\t0x100\n#define FPGAMGRREGS_CTRL_NCONFIGPULL_MASK\t0x4\n#define FPGAMGRREGS_CTRL_NCE_MASK\t\t0x2\n#define FPGAMGRREGS_CTRL_EN_MASK\t\t0x1\n#define FPGAMGRREGS_CTRL_CDRATIO_LSB\t\t6\n\n#define FPGAMGRREGS_MON_GPIO_EXT_PORTA_CRC_MASK\t0x8\n#define FPGAMGRREGS_MON_GPIO_EXT_PORTA_ID_MASK\t0x4\n#define FPGAMGRREGS_MON_GPIO_EXT_PORTA_CD_MASK\t0x2\n#define FPGAMGRREGS_MON_GPIO_EXT_PORTA_NS_MASK\t0x1\n\n/* FPGA Mode */\n#define FPGAMGRREGS_MODE_FPGAOFF\t\t0x0\n#define FPGAMGRREGS_MODE_RESETPHASE\t\t0x1\n#define FPGAMGRREGS_MODE_CFGPHASE\t\t0x2\n#define FPGAMGRREGS_MODE_INITPHASE\t\t0x3\n#define FPGAMGRREGS_MODE_USERMODE\t\t0x4\n#define FPGAMGRREGS_MODE_UNKNOWN\t\t0x5\n\n/* FPGA CD Ratio Value */\n#define CDRATIO_x1\t\t\t\t0x0\n#define CDRATIO_x2\t\t\t\t0x1\n#define CDRATIO_x4\t\t\t\t0x2\n#define CDRATIO_x8\t\t\t\t0x3\n\n#endif /* _FPGA_MANAGER_H_ */\n"
        },
        {
          "name": "fpga_nic301.h",
          "type": "blob",
          "size": 5.27734375,
          "content": "/*\n* Copyright (C) 2014 Marek Vasut <marex@denx.de>\n*\n* SPDX-License-Identifier:\tGPL-2.0+\n*/\n\n#ifndef\t_NIC301_REGISTERS_H_\n#define\t_NIC301_REGISTERS_H_\n\nstruct nic301_registers {\n\tuint32_t\tremap;\t\t\t\t/* 0x0 */\n\t\t\t\t\t\t\t\t\t/* Security Register Group */\n\tuint32_t\t_pad_0x4_0x8[1];\n\tuint32_t\tl4main;\n\tuint32_t\tl4sp;\n\tuint32_t\tl4mp;\t\t\t\t/* 0x10 */\n\tuint32_t\tl4osc1;\n\tuint32_t\tl4spim;\n\tuint32_t\tstm;\n\tuint32_t\tlwhps2fpgaregs;\t\t\t/* 0x20 */\n\tuint32_t\t_pad_0x24_0x28[1];\n\tuint32_t\tusb1;\n\tuint32_t\tnanddata;\n\tuint32_t\t_pad_0x30_0x80[20];\n\tuint32_t\tusb0;\t\t\t\t/* 0x80 */\n\tuint32_t\tnandregs;\n\tuint32_t\tqspidata;\n\tuint32_t\tfpgamgrdata;\n\tuint32_t\thps2fpgaregs;\t\t\t/* 0x90 */\n\tuint32_t\tacp;\n\tuint32_t\trom;\n\tuint32_t\tocram;\n\tuint32_t\tsdrdata;\t\t\t/* 0xA0 */\n\tuint32_t\t_pad_0xa4_0x1fd0[1995];\n\t/* ID Register Group */\n\tuint32_t\tperiph_id_4;\t\t\t/* 0x1FD0 */\n\tuint32_t\t_pad_0x1fd4_0x1fe0[3];\n\tuint32_t\tperiph_id_0;\t\t\t/* 0x1FE0 */\n\tuint32_t\tperiph_id_1;\n\tuint32_t\tperiph_id_2;\n\tuint32_t\tperiph_id_3;\n\tuint32_t\tcomp_id_0;\t\t\t/* 0x1FF0 */\n\tuint32_t\tcomp_id_1;\n\tuint32_t\tcomp_id_2;\n\tuint32_t\tcomp_id_3;\n\tuint32_t\t_pad_0x2000_0x2008[2];\n\t/* L4 MAIN */\n\tuint32_t\tl4main_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x200c_0x3008[1023];\n\t/* L4 SP */\n\tuint32_t\tl4sp_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x300c_0x4008[1023];\n\t/* L4 MP */\n\tuint32_t\tl4mp_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x400c_0x5008[1023];\n\t/* L4 OSC1 */\n\tuint32_t\tl4osc_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x500c_0x6008[1023];\n\t/* L4 SPIM */\n\tuint32_t\tl4spim_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x600c_0x7008[1023];\n\t/* STM */\n\tuint32_t\tstm_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x700c_0x7108[63];\n\tuint32_t\tstm_fn_mod;\n\tuint32_t\t_pad_0x710c_0x8008[959];\n\t/* LWHPS2FPGA */\n\tuint32_t\tlwhps2fpga_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x800c_0x8108[63];\n\tuint32_t\tlwhps2fpga_fn_mod;\n\tuint32_t\t_pad_0x810c_0xa008[1983];\n\t/* USB1 */\n\tuint32_t\tusb1_fn_mod_bm_iss;\n\tuint32_t\t_pad_0xa00c_0xa044[14];\n\tuint32_t\tusb1_ahb_cntl;\n\tuint32_t\t_pad_0xa048_0xb008[1008];\n\t/* NANDDATA */\n\tuint32_t\tnanddata_fn_mod_bm_iss;\n\tuint32_t\t_pad_0xb00c_0xb108[63];\n\tuint32_t\tnanddata_fn_mod;\n\tuint32_t\t_pad_0xb10c_0x20008[21439];\n\t/* USB0 */\n\tuint32_t\tusb0_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2000c_0x20044[14];\n\tuint32_t\tusb0_ahb_cntl;\n\tuint32_t\t_pad_0x20048_0x21008[1008];\n\t/* NANDREGS */\n\tuint32_t\tnandregs_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2100c_0x21108[63];\n\tuint32_t\tnandregs_fn_mod;\n\tuint32_t\t_pad_0x2110c_0x22008[959];\n\t/* QSPIDATA */\n\tuint32_t\tqspidata_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2200c_0x22044[14];\n\tuint32_t\tqspidata_ahb_cntl;\n\tuint32_t\t_pad_0x22048_0x23008[1008];\n\t/* FPGAMGRDATA */\n\tuint32_t\tfpgamgrdata_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2300c_0x23040[13];\n\tuint32_t\tfpgamgrdata_wr_tidemark;\t/* 0x23040 */\n\tuint32_t\t_pad_0x23044_0x23108[49];\n\tuint32_t\tfn_mod;\n\tuint32_t\t_pad_0x2310c_0x24008[959];\n\t/* HPS2FPGA */\n\tuint32_t\thps2fpga_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2400c_0x24040[13];\n\tuint32_t\thps2fpga_wr_tidemark;\t\t/* 0x24040 */\n\tuint32_t\t_pad_0x24044_0x24108[49];\n\tuint32_t\thps2fpga_fn_mod;\n\tuint32_t\t_pad_0x2410c_0x25008[959];\n\t/* ACP */\n\tuint32_t\tacp_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2500c_0x25108[63];\n\tuint32_t\tacp_fn_mod;\n\tuint32_t\t_pad_0x2510c_0x26008[959];\n\t/* Boot ROM */\n\tuint32_t\tbootrom_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2600c_0x26108[63];\n\tuint32_t\tbootrom_fn_mod;\n\tuint32_t\t_pad_0x2610c_0x27008[959];\n\t/* On-chip RAM */\n\tuint32_t\tocram_fn_mod_bm_iss;\n\tuint32_t\t_pad_0x2700c_0x27040[13];\n\tuint32_t\tocram_wr_tidemark;\t\t/* 0x27040 */\n\tuint32_t\t_pad_0x27044_0x27108[49];\n\tuint32_t\tocram_fn_mod;\n\tuint32_t\t_pad_0x2710c_0x42024[27590];\n\t/* DAP */\n\tuint32_t\tdap_fn_mod2;\n\tuint32_t\tdap_fn_mod_ahb;\n\tuint32_t\t_pad_0x4202c_0x42100[53];\n\tuint32_t\tdap_read_qos;\t\t\t/* 0x42100 */\n\tuint32_t\tdap_write_qos;\n\tuint32_t\tdap_fn_mod;\n\tuint32_t\t_pad_0x4210c_0x43100[1021];\n\t/* MPU */\n\tuint32_t\tmpu_read_qos;\t\t\t/* 0x43100 */\n\tuint32_t\tmpu_write_qos;\n\tuint32_t\tmpu_fn_mod;\n\tuint32_t\t_pad_0x4310c_0x44028[967];\n\t/* SDMMC */\n\tuint32_t\tsdmmc_fn_mod_ahb;\n\tuint32_t\t_pad_0x4402c_0x44100[53];\n\tuint32_t\tsdmmc_read_qos;\t\t\t/* 0x44100 */\n\tuint32_t\tsdmmc_write_qos;\n\tuint32_t\tsdmmc_fn_mod;\n\tuint32_t\t_pad_0x4410c_0x45100[1021];\n\t/* DMA */\n\tuint32_t\tdma_read_qos;\t\t\t/* 0x45100 */\n\tuint32_t\tdma_write_qos;\n\tuint32_t\tdma_fn_mod;\n\tuint32_t\t_pad_0x4510c_0x46040[973];\n\t/* FPGA2HPS */\n\tuint32_t\tfpga2hps_wr_tidemark;\t\t/* 0x46040 */\n\tuint32_t\t_pad_0x46044_0x46100[47];\n\tuint32_t\tfpga2hps_read_qos;\t\t/* 0x46100 */\n\tuint32_t\tfpga2hps_write_qos;\n\tuint32_t\tfpga2hps_fn_mod;\n\tuint32_t\t_pad_0x4610c_0x47100[1021];\n\t/* ETR */\n\tuint32_t\tetr_read_qos;\t\t\t/* 0x47100 */\n\tuint32_t\tetr_write_qos;\n\tuint32_t\tetr_fn_mod;\n\tuint32_t\t_pad_0x4710c_0x48100[1021];\n\t/* EMAC0 */\n\tuint32_t\temac0_read_qos;\t\t\t/* 0x48100 */\n\tuint32_t\temac0_write_qos;\n\tuint32_t\temac0_fn_mod;\n\tuint32_t\t_pad_0x4810c_0x49100[1021];\n\t/* EMAC1 */\n\tuint32_t\temac1_read_qos;\t\t\t/* 0x49100 */\n\tuint32_t\temac1_write_qos;\n\tuint32_t\temac1_fn_mod;\n\tuint32_t\t_pad_0x4910c_0x4a028[967];\n\t/* USB0 */\n\tuint32_t\tusb0_fn_mod_ahb;\n\tuint32_t\t_pad_0x4a02c_0x4a100[53];\n\tuint32_t\tusb0_read_qos;\t\t\t/* 0x4A100 */\n\tuint32_t\tusb0_write_qos;\n\tuint32_t\tusb0_fn_mod;\n\tuint32_t\t_pad_0x4a10c_0x4b100[1021];\n\t/* NAND */\n\tuint32_t\tnand_read_qos;\t\t\t/* 0x4B100 */\n\tuint32_t\tnand_write_qos;\n\tuint32_t\tnand_fn_mod;\n\tuint32_t\t_pad_0x4b10c_0x4c028[967];\n\t/* USB1 */\n\tuint32_t\tusb1_fn_mod_ahb;\n\tuint32_t\t_pad_0x4c02c_0x4c100[53];\n\tuint32_t\tusb1_read_qos;\t\t\t/* 0x4C100 */\n\tuint32_t\tusb1_write_qos;\n\tuint32_t\tusb1_fn_mod;\n};\n\n#endif\t/* _NIC301_REGISTERS_H_ */\n"
        },
        {
          "name": "fpga_reset_manager.h",
          "type": "blob",
          "size": 2.001953125,
          "content": "/*\n*  Copyright (C) 2012 Altera Corporation <www.altera.com>\n*\n* SPDX-License-Identifier:\tGPL-2.0+\n*/\n\n#ifndef\t_RESET_MANAGER_H_\n#define\t_RESET_MANAGER_H_\n\nstruct socfpga_reset_manager {\n\tuint32_t\tstatus;\n\tuint32_t\tctrl;\n\tuint32_t\tcounts;\n\tuint32_t\tpadding1;\n\tuint32_t\tmpu_mod_reset;\n\tuint32_t\tper_mod_reset;\n\tuint32_t\tper2_mod_reset;\n\tuint32_t\tbrg_mod_reset;\n\tuint32_t\tmisc_mod_reset;\n\tuint32_t\tpadding2[12];\n\tuint32_t\ttstscratch;\n};\n\n#if defined(CONFIG_SOCFPGA_VIRTUAL_TARGET)\n#define RSTMGR_CTRL_SWWARMRSTREQ_LSB 2\n#else\n#define RSTMGR_CTRL_SWWARMRSTREQ_LSB 1\n#endif\n\n/*\n* Define a reset identifier, from which a permodrst bank ID\n* and reset ID can be extracted using the subsequent macros\n* RSTMGR_RESET() and RSTMGR_BANK().\n*/\n#define RSTMGR_BANK_OFFSET\t8\n#define RSTMGR_BANK_MASK\t0x7\n#define RSTMGR_RESET_OFFSET\t0\n#define RSTMGR_RESET_MASK\t0x1f\n#define RSTMGR_DEFINE(_bank, _offset)\t\t\\\n\t((_bank) << RSTMGR_BANK_OFFSET) | ((_offset) << RSTMGR_RESET_OFFSET)\n\n/* Extract reset ID from the reset identifier. */\n#define RSTMGR_RESET(_reset)\t\t\t\\\n\t(((_reset) >> RSTMGR_RESET_OFFSET) & RSTMGR_RESET_MASK)\n\n/* Extract bank ID from the reset identifier. */\n#define RSTMGR_BANK(_reset)\t\t\t\\\n\t(((_reset) >> RSTMGR_BANK_OFFSET) & RSTMGR_BANK_MASK)\n\n/*\n* SocFPGA Cyclone V/Arria V reset IDs, bank mapping is as follows:\n* 0 ... mpumodrst\n* 1 ... permodrst\n* 2 ... per2modrst\n* 3 ... brgmodrst\n* 4 ... miscmodrst\n*/\n#define RSTMGR_EMAC0\t\tRSTMGR_DEFINE(1, 0)\n#define RSTMGR_EMAC1\t\tRSTMGR_DEFINE(1, 1)\n#define RSTMGR_NAND\t\tRSTMGR_DEFINE(1, 4)\n#define RSTMGR_QSPI\t\tRSTMGR_DEFINE(1, 5)\n#define RSTMGR_L4WD0\t\tRSTMGR_DEFINE(1, 6)\n#define RSTMGR_OSC1TIMER0\tRSTMGR_DEFINE(1, 8)\n#define RSTMGR_UART0\t\tRSTMGR_DEFINE(1, 16)\n#define RSTMGR_SPIM0\t\tRSTMGR_DEFINE(1, 18)\n#define RSTMGR_SPIM1\t\tRSTMGR_DEFINE(1, 19)\n#define RSTMGR_SDMMC\t\tRSTMGR_DEFINE(1, 22)\n#define RSTMGR_DMA\t\tRSTMGR_DEFINE(1, 28)\n#define RSTMGR_SDR\t\tRSTMGR_DEFINE(1, 29)\n\n/* Create a human-readable reference to SoCFPGA reset. */\n#define SOCFPGA_RESET(_name)\tRSTMGR_##_name\n\n#endif /* _RESET_MANAGER_H_ */\n"
        },
        {
          "name": "fpga_system_manager.h",
          "type": "blob",
          "size": 4.30078125,
          "content": "/*\n* Copyright (C) 2013 Altera Corporation <www.altera.com>\n*\n* SPDX-License-Identifier:\tGPL-2.0+\n*/\n\n#ifndef\t_SYSTEM_MANAGER_H_\n#define\t_SYSTEM_MANAGER_H_\n\nstruct socfpga_system_manager {\n\t/* System Manager Module */\n\tuint32_t\tsiliconid1;\t\t\t/* 0x00 */\n\tuint32_t\tsiliconid2;\n\tuint32_t\t_pad_0x8_0xf[2];\n\tuint32_t\twddbg;\t\t\t\t/* 0x10 */\n\tuint32_t\tbootinfo;\n\tuint32_t\thpsinfo;\n\tuint32_t\tparityinj;\n\t/* FPGA Interface Group */\n\tuint32_t\tfpgaintfgrp_gbl;\t\t/* 0x20 */\n\tuint32_t\tfpgaintfgrp_indiv;\n\tuint32_t\tfpgaintfgrp_module;\n\tuint32_t\t_pad_0x2c_0x2f;\n\t/* Scan Manager Group */\n\tuint32_t\tscanmgrgrp_ctrl;\t\t/* 0x30 */\n\tuint32_t\t_pad_0x34_0x3f[3];\n\t/* Freeze Control Group */\n\tuint32_t\tfrzctrl_vioctrl;\t\t/* 0x40 */\n\tuint32_t\t_pad_0x44_0x4f[3];\n\tuint32_t\tfrzctrl_hioctrl;\t\t/* 0x50 */\n\tuint32_t\tfrzctrl_src;\n\tuint32_t\tfrzctrl_hwctrl;\n\tuint32_t\t_pad_0x5c_0x5f;\n\t/* EMAC Group */\n\tuint32_t\temacgrp_ctrl;\t\t\t/* 0x60 */\n\tuint32_t\temacgrp_l3master;\n\tuint32_t\t_pad_0x68_0x6f[2];\n\t/* DMA Controller Group */\n\tuint32_t\tdmagrp_ctrl;\t\t\t/* 0x70 */\n\tuint32_t\tdmagrp_persecurity;\n\tuint32_t\t_pad_0x78_0x7f[2];\n\t/* Preloader (initial software) Group */\n\tuint32_t\tiswgrp_handoff[8];\t\t/* 0x80 */\n\tuint32_t\t_pad_0xa0_0xbf[8];\t\t/* 0xa0 */\n\t\t\t\t\t\t\t\t\t\t/* Boot ROM Code Register Group */\n\tuint32_t\tromcodegrp_ctrl;\t\t/* 0xc0 */\n\tuint32_t\tromcodegrp_cpu1startaddr;\n\tuint32_t\tromcodegrp_initswstate;\n\tuint32_t\tromcodegrp_initswlastld;\n\tuint32_t\tromcodegrp_bootromswstate;\t/* 0xd0 */\n\tuint32_t\t__pad_0xd4_0xdf[3];\n\t/* Warm Boot from On-Chip RAM Group */\n\tuint32_t\tromcodegrp_warmramgrp_enable;\t/* 0xe0 */\n\tuint32_t\tromcodegrp_warmramgrp_datastart;\n\tuint32_t\tromcodegrp_warmramgrp_length;\n\tuint32_t\tromcodegrp_warmramgrp_execution;\n\tuint32_t\tromcodegrp_warmramgrp_crc;\t/* 0xf0 */\n\tuint32_t\t__pad_0xf4_0xff[3];\n\t/* Boot ROM Hardware Register Group */\n\tuint32_t\tromhwgrp_ctrl;\t\t\t/* 0x100 */\n\tuint32_t\t_pad_0x104_0x107;\n\t/* SDMMC Controller Group */\n\tuint32_t\tsdmmcgrp_ctrl;\n\tuint32_t\tsdmmcgrp_l3master;\n\t/* NAND Flash Controller Register Group */\n\tuint32_t\tnandgrp_bootstrap;\t\t/* 0x110 */\n\tuint32_t\tnandgrp_l3master;\n\t/* USB Controller Group */\n\tuint32_t\tusbgrp_l3master;\n\tuint32_t\t_pad_0x11c_0x13f[9];\n\t/* ECC Management Register Group */\n\tuint32_t\teccgrp_l2;\t\t\t/* 0x140 */\n\tuint32_t\teccgrp_ocram;\n\tuint32_t\teccgrp_usb0;\n\tuint32_t\teccgrp_usb1;\n\tuint32_t\teccgrp_emac0;\t\t\t/* 0x150 */\n\tuint32_t\teccgrp_emac1;\n\tuint32_t\teccgrp_dma;\n\tuint32_t\teccgrp_can0;\n\tuint32_t\teccgrp_can1;\t\t\t/* 0x160 */\n\tuint32_t\teccgrp_nand;\n\tuint32_t\teccgrp_qspi;\n\tuint32_t\teccgrp_sdmmc;\n\tuint32_t\t_pad_0x170_0x3ff[164];\n\t/* Pin Mux Control Group */\n\tuint32_t\temacio[20];\t\t\t/* 0x400 */\n\tuint32_t\tflashio[12];\t\t\t/* 0x450 */\n\tuint32_t\tgeneralio[28];\t\t\t/* 0x480 */\n\tuint32_t\t_pad_0x4f0_0x4ff[4];\n\tuint32_t\tmixed1io[22];\t\t\t/* 0x500 */\n\tuint32_t\tmixed2io[8];\t\t\t/* 0x558 */\n\tuint32_t\tgplinmux[23];\t\t\t/* 0x578 */\n\tuint32_t\tgplmux[71];\t\t\t/* 0x5d4 */\n\tuint32_t\tnandusefpga;\t\t\t/* 0x6f0 */\n\tuint32_t\t_pad_0x6f4;\n\tuint32_t\trgmii1usefpga;\t\t\t/* 0x6f8 */\n\tuint32_t\t_pad_0x6fc_0x700[2];\n\tuint32_t\ti2c0usefpga;\t\t\t/* 0x704 */\n\tuint32_t\tsdmmcusefpga;\t\t\t/* 0x708 */\n\tuint32_t\t_pad_0x70c_0x710[2];\n\tuint32_t\trgmii0usefpga;\t\t\t/* 0x714 */\n\tuint32_t\t_pad_0x718_0x720[3];\n\tuint32_t\ti2c3usefpga;\t\t\t/* 0x724 */\n\tuint32_t\ti2c2usefpga;\t\t\t/* 0x728 */\n\tuint32_t\ti2c1usefpga;\t\t\t/* 0x72c */\n\tuint32_t\tspim1usefpga;\t\t\t/* 0x730 */\n\tuint32_t\t_pad_0x734;\n\tuint32_t\tspim0usefpga;\t\t\t/* 0x738 */\n};\n\n#define SYSMGR_ROMCODEGRP_CTRL_WARMRSTCFGPINMUX\t(1 << 0)\n#define SYSMGR_ROMCODEGRP_CTRL_WARMRSTCFGIO\t(1 << 1)\n#define SYSMGR_ECC_OCRAM_EN\t(1 << 0)\n#define SYSMGR_ECC_OCRAM_SERR\t(1 << 3)\n#define SYSMGR_ECC_OCRAM_DERR\t(1 << 4)\n#define SYSMGR_FPGAINTF_USEFPGA\t0x1\n#define SYSMGR_FPGAINTF_SPIM0\t(1 << 0)\n#define SYSMGR_FPGAINTF_SPIM1\t(1 << 1)\n#define SYSMGR_FPGAINTF_EMAC0\t(1 << 2)\n#define SYSMGR_FPGAINTF_EMAC1\t(1 << 3)\n#define SYSMGR_FPGAINTF_NAND\t(1 << 4)\n#define SYSMGR_FPGAINTF_SDMMC\t(1 << 5)\n\n#if defined(CONFIG_TARGET_SOCFPGA_GEN5)\n#define SYSMGR_SDMMC_SMPLSEL_SHIFT\t3\n#else\n#define SYSMGR_SDMMC_SMPLSEL_SHIFT\t4\n#endif\n\n#define SYSMGR_SDMMC_DRVSEL_SHIFT\t0\n\n/* EMAC Group Bit definitions */\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII\t0x0\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RGMII\t\t0x1\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RMII\t\t0x2\n\n#define SYSMGR_EMACGRP_CTRL_PHYSEL0_LSB\t\t\t0\n#define SYSMGR_EMACGRP_CTRL_PHYSEL1_LSB\t\t\t2\n#define SYSMGR_EMACGRP_CTRL_PHYSEL_MASK\t\t\t0x3\n\n#endif /* _SYSTEM_MANAGER_H_ */\n"
        },
        {
          "name": "gamecontroller_db.cpp",
          "type": "blob",
          "size": 14.705078125,
          "content": "#include \"gamecontroller_db.h\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include \"input.h\"\n#include \"file_io.h\"\n#include \"user_io.h\"\n#include \"profiling.h\"\n\n\n\n\n//Note: sdl gamecontrollerdb maps  a,b,x,y differently, so we need to swap each pair (a<->b, x<->y)\nstatic const char *sdlname_to_mister_idx[] = {\n\t\"dpright\",\n\t\"dpleft\",\n\t\"dpdown\",\n\t\"dpup\",\n\t\"b\",\n\t\"a\",\n\t\"y\",\n\t\"x\",\n\t\"leftshoulder\",\n\t\"rightshoulder\",\n\t\"back\",\n\t\"start\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL, //20\n\t\"guide\", //21\n\t\"guide2\", //Mister extension: guide2 is the 2nd button for OSD chord\n\t\"menufunc\", //Dummy entry so mister->sdl map string works\n\t\"leftx\",\n\t\"lefty\",\n\t\"rightx\",\n\t\"righty\",\n\t\"asysx\",\n\t\"asysy\",\n\tNULL,\n\tNULL,\n};\n\ntypedef struct {\n\tuint16_t id[4]; //bustype, vid, pid, version\n\tuint32_t map[NUMBUTTONS];\n} controllerdb_entry;\n\n\n\n\nstatic controllerdb_entry db_maps[MAX_GCDB_ENTRIES] = {};\nstatic int last_db_idx = 0;\n\n//platform should be at the end of mapping strings. this function will null the start of platform: if found\nstatic bool cdb_entry_matches(char *db_str)\n{\n\tchar *pl_ptr = NULL;\n\n\tif (!db_str || !strlen(db_str)) return false;\n\tpl_ptr = strcasestr(db_str, \"platform:\");\n\tif (!pl_ptr) return false;\n\n\t*pl_ptr = 0;\n\tpl_ptr += strlen(\"platform:\");\n\tif (!strncasecmp(pl_ptr, \"Linux\", 5)) return true;\n\tif (!strncasecmp(pl_ptr, \"MiSTer\", 6))\n\t{\n\t\tchar *core_ptr = NULL;\n\t\tcore_ptr = strcasestr(db_str, \"mistercore:\");\n\t\tif (!core_ptr) return true; //platform:MiSTer with no core designators is a generic match\n\t\twhile(core_ptr)\n\t\t{\n\t\t\t\tchar *nxt_c = NULL;\n\t\t\t\tchar *match_c = NULL;\n\t\t\t\tcore_ptr += 11;\n\t\t\t\tnxt_c = strchr(core_ptr, ',');\n\t\t\t\tif (!nxt_c) break;\n\t\t\t\tmatch_c = strchr(core_ptr, '*');\n\t\t\t\tif (!match_c || match_c >= nxt_c)\n\t\t\t\t{\n\t\t\t\t\tmatch_c = nxt_c;\n\t\t\t\t}\n\n\n\t\t\t\tif (!strncasecmp(core_ptr, user_io_get_core_name(), match_c - core_ptr)) return true;\n\t\t\t\tif (!strncasecmp(core_ptr, user_io_get_core_name(1), match_c - core_ptr)) return true;\n\t\t\t\tcore_ptr = strcasestr(nxt_c, \"mistercore:\");\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int find_mister_button_num(char *sdl_name, bool *idx_high)\n{\n\t*idx_high = false;\n\tfor(size_t i = 0; i < sizeof(sdlname_to_mister_idx)/sizeof(char *); i++)\n\t{\n\t\tconst char *map_str = sdlname_to_mister_idx[i];\n\t\tif (map_str && !strcmp(map_str, sdl_name)) return i;\n\t}\n\tif (!strcasecmp(sdl_name, \"menuok\"))\n\t{\n\t\t*idx_high = false;\n\t\treturn SYS_BTN_MENU_FUNC;\n\t}\n\n\tif (!strcasecmp(sdl_name, \"menuesc\"))\n\t{\n\t\t*idx_high = true;\n\t\treturn SYS_BTN_MENU_FUNC;\n\t}\n\treturn -1;\n}\n\n\nstatic int find_linux_code_for_button(char *btn_name, uint16_t *btn_map, uint16_t *abs_map)\n{\n\tif (!btn_name || !strlen(btn_name)) return -1;\n\n\tchar btn_sw = btn_name[0];\n\tint a_edge = 0;\n\tif (btn_name[0] == '-') a_edge = 1;\n\tif (btn_name[0] == '+') a_edge = 2;\n\tif (a_edge != 0)\n\t{\n\t\tbtn_sw = btn_name[1];\n\t}\n\tswitch(btn_sw)\n\t{\n\t\t\tcase 'b':\n\t\t\t{\n\t\t\t\t//Normal button\n\t\t\t\tint bidx = strtol(btn_name+1, NULL, 10);\n\t\t\t\treturn btn_map[bidx];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 'a':\n\t\t\t{\n\t\t\t\tint aidx = strtol(btn_name + (a_edge != 0 ? 2 : 1) , NULL, 10);\n\t\t\t\tint abs_axis = abs_map[aidx];\n\t\t\t\tif (a_edge)\n\t\t\t\t{\n\t\t\t\t\treturn KEY_EMU + (abs_axis << 1) - 1 + a_edge;\n\t\t\t\t} else {\n\t\t\t\t\t\treturn abs_axis;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'h':\n\t\t\t//Mister creates fake digital buttons for hats that depend on the code and axis direction.\n\t\t\t{\n\t\t\t\tchar *dot_ptr = NULL;\n\t\t\t\tint hidx = strtol(btn_name+1, NULL, 10);\n\t\t\t\tint base_hat = ABS_HAT0X + hidx*2;\n\t\t\t\t//base_hat is X, base_hat+1 is Y\n\t\t\t\tdot_ptr = strchr(btn_name, '.');\n\t\t\t\tif (dot_ptr)\n\t\t\t\t{\n\t\t\t\t\tint hat_dir = strtol(dot_ptr+1, NULL, 10);\n\t\t\t\t\tswitch(hat_dir)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 1: //UP\n\t\t\t\t\t\t\treturn KEY_EMU + ((base_hat+1) << 1); //up is min value of Y axis\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: // RIGHT\n\t\t\t\t\t\t\treturn KEY_EMU + (base_hat << 1) + 1; // (axis << 1) -1 + 2 right is max value\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4: //DOWN\n\t\t\t\t\t\t\treturn KEY_EMU + ((base_hat+1) << 1) + 1; //down is max value of Y axis\n\t\t\t\t\t\tcase 8: //LEFT\n\t\t\t\t\t\t\treturn KEY_EMU + (base_hat << 1); //(axis << 1) - 1 + 1 left is min value\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t}\n\treturn -1;\n}\n\n\n#define test_bit(bit, array)  (array [bit / 8] & (1 << (bit % 8)))\n\n\nstatic void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint16_t *abs_map)\n{\n\tunsigned char keybits[(KEY_MAX+7) / 8];\n\tunsigned char absbits[(ABS_MAX+7) / 8];\n\tuint16_t btn_cnt = 0;\n\tuint16_t abs_cnt = 0;\n\n\tprintf(\"Gamecontrollerdb: mapping buttons for %s \", guid);\n\tif (ioctl(dev_fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits) >= 0)\n\t{\n\t\tfor (int i = BTN_JOYSTICK; i < KEY_MAX; i++)\n\t\t{\n\t\t\t\tif (test_bit(i, keybits))\n\t\t\t\t{\n\t\t\t\t\t//printf(\"b%d->%d \", btn_cnt, i);\n\t\t\t\t\tbtn_map[btn_cnt] = i;\n\t\t\t\t\tbtn_cnt++;\n\t\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < BTN_JOYSTICK; i++)\n\t\t{\n\t\t\t\tif (test_bit(i, keybits))\n\t\t\t\t{\n\t\t\t\t\t//printf(\"b%d -> %d \", btn_cnt, i);\n\t\t\t\t\tbtn_map[btn_cnt] = i;\n\t\t\t\t\tbtn_cnt++;\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t}\n\n\tprintf(\"Gamecontrollerdb: mapping analog axes for %s \", guid);\n\tif (ioctl(dev_fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits) >= 0)\n\t{\n\t\t//The \"correct\" way is to test  all the way to ABS_MAX and skip any hats the device has.\n\t\t//Mister handles hats differently and it is unlikely most things in the db files have axes beyond\n\t\t//The normal sticks+triggers...\n\t\tfor (int i = 0; i < ABS_HAT0X; i++)\n\t\t{\n\t\t\tif (test_bit(i, absbits))\n\t\t\t{\n\t\t\t\t\t//printf(\"a%d->%d \", abs_cnt, i);\n\t\t\t\t\tabs_map[abs_cnt] = i;\n\t\t\t\t\tabs_cnt++;\n\t\t\t}\n\t\t}\n\n\t\t//Just for debugging purposes...\n\t\tfor (int i = ABS_HAT0X; i < ABS_MAX; i++)\n\t\t{\n\t\t\t\tif (test_bit(i, absbits))\n\t\t\t\t{\n\t\t\t\t\t//printf(\"(debug)a%d->%d \", abs_cnt, i);\n\t\t\t\t\tabs_cnt++;\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n\nvoid gcdb_show_string_for_ctrl_map(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version,int dev_fd, const char *name, uint32_t *cur_map)\n{\n\tstatic char map_guid[GUID_LEN] = {0};\n\tstatic uint16_t btn_map[KEY_MAX - BTN_JOYSTICK] = {0xFFFF};\n\tstatic uint16_t abs_map[ABS_MAX] = {0xFFFF};\n\tif (!cur_map) return;\n\n\tchar guid_str[GUID_LEN] = {0};\n\tsprintf(guid_str, \"%04x0000%04x0000%04x0000%04x0000\", (uint16_t)(bustype << 8 | bustype >> 8), (uint16_t)( vid << 8 |  vid >> 8), (uint16_t)(pid << 8 | pid >> 8), (uint16_t)(version << 8 | version >> 8));\n\tif (strcmp(map_guid, guid_str))\n\t{\n\n\t\tmemset(btn_map, 0xFFFF, sizeof(btn_map));\n\t\tmemset(abs_map, 0xFFFF, sizeof(abs_map));\n\t\tstrncpy(map_guid, guid_str, GUID_LEN);\n\t\tget_ctrl_index_maps(dev_fd, guid_str, btn_map, abs_map);\n\t}\n\t//Directions/hats+Buttons\n\tprintf(\"Gamecontrollerdb for mapping: %s,%s,\", guid_str, name);\n\tfor(int i=0; i < NUMBUTTONS; i++)\n\t{\n\t\t\tif (i > SYS_BTN_START && i < SYS_BTN_OSD_KTGL) continue; //Skip mouse buttons\n\t\t\tif (i == SYS_BTN_OSD_KTGL+2 && (cur_map[i] == cur_map[i-1])) continue;\n\t\t\tconst char *sdlname = sdlname_to_mister_idx[i];\n\t\t\tif (!sdlname) continue;\n\t\t\tif (cur_map[i])\n\t\t\t{\n\t\t\t\tuint32_t i_code = cur_map[i] & 0xFFFF;\n\t\t\t\tif (i_code > KEY_EMU) //hat/analog\n\t\t\t\t{\n\t\t\t\t\t\tbool is_max = i_code & 0x1;\n\t\t\t\t\t\tuint16_t axis_idx = (i_code - KEY_EMU) >> 1;\n\t\t\t\t\t\tif (axis_idx >= ABS_HAT0X && axis_idx <= ABS_HAT3Y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8_t hat_num = (axis_idx - ABS_HAT0X)/2;\n\t\t\t\t\t\t\tbool axis_is_y = (axis_idx - ABS_HAT0X)%2;\n\t\t\t\t\t\t\tuint8_t hat_sub = 0;\n\t\t\t\t\t\t\tif (axis_is_y)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\that_sub = is_max ? 4 : 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\that_sub = is_max ? 2 : 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hat_sub)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"%s:h%d.%d,\", sdlname, hat_num, hat_sub);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//Mister 'fake' analog digital inputs.\n\t\t\t\t\t\t\tfor(unsigned int j=0; j < sizeof(abs_map)/sizeof(uint16_t); j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (abs_map[j] == axis_idx)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (is_max)\n\t\t\t\t\t\t\t\t\t\tprintf(\"%s:+a%d,\", sdlname, j);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tprintf(\"%s:-a%d,\", sdlname, j);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t \t} else if (cur_map[i] & 0x20000) { //Analog\n\t\t\t\t\tfor(unsigned int j=0; j < sizeof(abs_map)/sizeof(uint16_t); j++)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tif (abs_map[j] == i_code)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"%s:a%d,\", sdlname, j);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//Ugh\n\t\t\t\t\tint menu_func_cnt = 0;\n\t\t\t\t\tfor(unsigned int j=0; j < sizeof(btn_map)/sizeof(uint16_t); j++)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tif (btn_map[j] == 0xFFFF) break;\n\t\t\t\t\t\t\tif (i == SYS_BTN_MENU_FUNC)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (btn_map[j] == (cur_map[i] & 0xFFFF))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintf(\"menuok:b%d,\", j);\n\t\t\t\t\t\t\t\t\tmenu_func_cnt++;\n\t\t\t\t\t\t\t\t} else if (btn_map[j] == (cur_map[i] >> 16)) {\n\t\t\t\t\t\t\t\t\tprintf(\"menuesc:b%d,\",j);\n\t\t\t\t\t\t\t\t\tmenu_func_cnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (menu_func_cnt == 2) break;\n\t\t\t\t\t\t\t} else if (btn_map[j] == i_code) {\n\t\t\t\t\t\t\t\tprintf(\"%s:b%d,\", sdlname, j);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(\"platform:MiSTer,\\n\");\n}\n\nstatic bool parse_mapping_string(char *map_str, char *guid, int dev_fd, uint32_t *fill_map)\n{\n\n\tstatic char map_guid[GUID_LEN] = {0};\n\tstatic uint16_t btn_map[KEY_MAX - BTN_JOYSTICK] = {0};\n\tstatic uint16_t abs_map[ABS_MAX] = {0};\n\n\tif (!map_str || !fill_map) return false;\n\n\n\t//gamecontrollerdb references buttons/axes numerically, and the number depends on the actual buttons supported\n\t//by the controller. Build a map of button number -> keycode (same with axes)\n\n\tif (strcmp(map_guid, guid)) //New guid, map out button indexes for this new controller\n\t{\n\t\tbzero(btn_map, sizeof(btn_map));\n\t\tbzero(abs_map, sizeof(abs_map));\n\t\tget_ctrl_index_maps(dev_fd, guid, btn_map, abs_map);\n\t}\n\n\tchar l_btn[20] = {};\n\tchar m_btn[20] = {};\n\tbool in_m_btn = true;\n\tsize_t i = 0;\n\tbool map_parsed = false;\n\tchar *cur_str = map_str;\n\n\twhile (cur_str && *cur_str)\n\t{\n\t\tif (*cur_str == ':')\n\t\t{\n\t\t\ti = 0;\n\t\t\tin_m_btn = false;\n\t\t} else if (*cur_str == ',') {\n\t\t\ti = 0;\n\t\t\tin_m_btn = true;\n\t\t\tif (l_btn[0] && m_btn[0])\n\t\t\t{\n\t\t\t\tbool m_button_high = false;\n\t\t\t\tint m_button_num = find_mister_button_num(m_btn, &m_button_high);\n\t\t\t\tint l_button_code = find_linux_code_for_button(l_btn, btn_map, abs_map);\n\t\t\t\tif (m_button_num != -1 && l_button_code != -1)\n\t\t\t\t{\n\t\t\t\t\tmap_parsed = true;\n\t\t\t\t\tfill_map[m_button_num] =  m_button_high ? ((l_button_code << 16) | fill_map[m_button_num]) : ((l_button_code & 0xFFFF)  | fill_map[m_button_num]);\n\t\t\t\t\tif (m_button_num >= SYS_AXIS1_X && m_button_num <= SYS_AXIS_MX)\n\t\t\t\t\t{\n\t\t\t\t\t\tfill_map[m_button_num] = l_button_code | 0x20000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzero(l_btn, sizeof(l_btn));\n\t\t\tbzero(m_btn, sizeof(m_btn));\n\t\t} else if (in_m_btn) {\n\t\t\t//Just truncate button names if they are too big\n\t\t\tif (i <= sizeof(m_btn))\n\t\t\t{\n\t\t\t\tm_btn[i] = *cur_str;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\t else {\n\t\t\tif (i <= sizeof(l_btn))\n\t\t\t{\n\t\t\t\tl_btn[i] = *cur_str;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tcur_str++;\n\t}\n\n\tif (map_parsed)\n\t{\n\t\tif ((fill_map[SYS_BTN_MENU_FUNC] & 0xFFFF) == 0)\n\t\t{\n\t\t\tfill_map[SYS_BTN_MENU_FUNC] = fill_map[SYS_BTN_A] & 0xFFFF;\n\t\t}\n\n\t\tif ((fill_map[SYS_BTN_MENU_FUNC] & 0xFFFF0000) == 0)\n\t\t{\n\t\t\tfill_map[SYS_BTN_MENU_FUNC] = (fill_map[SYS_BTN_B] << 16) | fill_map[SYS_BTN_MENU_FUNC];\n\t\t}\n\n\t\tif (fill_map[SYS_BTN_OSD_KTGL+2] == 0) fill_map[SYS_BTN_OSD_KTGL+2] = fill_map[SYS_BTN_OSD_KTGL+1];\n\n\n    //Some controllers without analog sticks use the left stick axes for the dpad instead of using the hat axes\n    //When these are mapped to dpad directions in an entry, it results in the mister \n    //having no mapping for the corresponding analog axis. \n    //any analog axis that isn't mapped to either SYS_AXIS1 or SYS_AXIS2 is treated like a trigger and only generates\n    //'fake' digital inputs on the axis max. This results in only two dpad directions working.\n    //Populate the entries for SYS_AXIS1 based on what the dpad was mapped to, but only if the entry didn't map the analog\n    //axes itself.\n    \n    if (!fill_map[SYS_AXIS1_X] && fill_map[SYS_BTN_RIGHT] > KEY_EMU)\n    {\n\t\t\t\t\t\tuint16_t axis_idx = (fill_map[SYS_BTN_RIGHT] - KEY_EMU) >> 1;\n            fill_map[SYS_AXIS1_X] = axis_idx | 0x20000;\n    }\n\n    if (!fill_map[SYS_AXIS1_Y] && fill_map[SYS_BTN_UP] > KEY_EMU)\n    {\n\t\t\t\t\t\tuint16_t axis_idx = (fill_map[SYS_BTN_UP] - KEY_EMU) >> 1;\n            fill_map[SYS_AXIS1_Y] = axis_idx | 0x20000;\n    }\n\n\n\t\tif (fill_map[SYS_AXIS_X] == 0) fill_map[SYS_AXIS_X] = fill_map[SYS_AXIS1_X];\n\t\tif (fill_map[SYS_AXIS_Y] == 0) fill_map[SYS_AXIS_Y] = fill_map[SYS_AXIS1_Y];\n\t}\n\n\n\treturn map_parsed;\n}\n\n\n#define GCDB_DIR  \"/media/fat/linux/gamecontrollerdb/\"\n\n\nbool read_controller_map_from_file(char *fname, char *guid, int dev_fd, uint32_t *fill_map)\n{\n\tfileTextReader reader;\n\tchar matched[1024] = {};\n\tchar *map_start = NULL;\n\n\tif (FileOpenTextReader(&reader, fname))\n\t{\n\t\tconst char *line;\n\t\tprintf(\"Gamecontrollerdb: searching for GUID %s in file %s\\n\", guid, fname);\n\t\twhile ((line = FileReadLine(&reader)))\n\t\t{\n\t\t\tif (line[0] == '#') continue;\n\t\t\tconst char *gcom = strchr(line, ',');\n\t\t\tif (!strncasecmp(line, guid, gcom-line))\n\t\t\t{\n\t\t\t\tif (cdb_entry_matches((char *)gcom))\n\t\t\t\t{\n\t\t\t\t\tmap_start = strchr((char *)gcom+1, ',');\n\t\t\t\t\tif (map_start)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(matched, map_start+1, sizeof(matched));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tif (matched[0] != 0)\n\t{\n\t\tprintf(\"Gamecontrollerdb: found match, using config %s\\n\", matched);\n\t\treturn parse_mapping_string(matched, guid, dev_fd, fill_map);\n\t}\n\n\treturn false;\n}\n\nstatic int gcdb_controller_idx(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version)\n{\n\tfor (int i=0; i < MAX_GCDB_ENTRIES; i++)\n\t{\n\t\tif (db_maps[i].id[0] == bustype && db_maps[i].id[1] == vid && db_maps[i].id[2] == pid && db_maps[i].id[3] == version)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void gcdb_cache_controller_map(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version, uint32_t *button_map)\n{\n\tif (gcdb_controller_idx(bustype, vid, pid, version) > -1)\n\t{\n\t\t//Already cached\n\t\treturn;\n\t}\n\n\tdb_maps[last_db_idx].id[0] = bustype;\n\tdb_maps[last_db_idx].id[1] = vid;\n\tdb_maps[last_db_idx].id[2] = pid;\n\tdb_maps[last_db_idx].id[3] = version;\n\tmemcpy(db_maps[last_db_idx].map, button_map, sizeof(uint32_t)*NUMBUTTONS);\n\tlast_db_idx = (last_db_idx +1) % MAX_GCDB_ENTRIES;\n}\n\nbool gcdb_map_for_controller(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version, int dev_fd, uint32_t *fill_map)\n{\n\t\tPROFILE_FUNCTION();\n\t\tchar guid_str[GUID_LEN] = {};\n\t\tint cache_idx = gcdb_controller_idx(bustype, vid, pid, version);\n\t\tif (cache_idx != -1)\n\t\t{\n\t\t\tmemcpy(fill_map, db_maps[cache_idx].map, sizeof(uint32_t)*NUMBUTTONS);\n\n\t\t\treturn true;\n\t\t}\n\t\tsprintf(guid_str, \"%04x0000%04x0000%04x0000%04x0000\", (uint16_t)(bustype << 8 | bustype >> 8), (uint16_t)( vid << 8 |  vid >> 8), (uint16_t)(pid << 8 | pid >> 8), (uint16_t)(version << 8 | version >> 8));\n\n\t\tchar path[256] = {GCDB_DIR};\n\t\tstrcat(path, \"gamecontrollerdb_user.txt\");\n\t\tbool found_entry = false;\n\t\tif (!(found_entry = read_controller_map_from_file(path, guid_str, dev_fd, fill_map)))\n\t\t{\n\t\t\tstrcpy(path, GCDB_DIR);\n\t\t\tstrcat(path, \"gamecontrollerdb.txt\");\n\t\t\tfound_entry = read_controller_map_from_file(path, guid_str, dev_fd, fill_map);\n\t\t}\n\n\n\t\tif (found_entry)\n\t\t{\n\t\t\tgcdb_cache_controller_map(bustype, vid, pid, version, fill_map);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n}\n"
        },
        {
          "name": "gamecontroller_db.h",
          "type": "blob",
          "size": 0.4755859375,
          "content": "#ifndef GAMECONTROLLER_DB_H\n#define GAMECONTROLLER_DB_H\n#include <linux/input.h>\n#include <sys/types.h>\n#include <stdint.h>\n\n#define MAX_GCDB_ENTRIES 6 \n\n//Including terminating nul\n#define GUID_LEN 33 \n\nbool gcdb_map_for_controller(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version, int dev_fd, uint32_t *fill_map);\nvoid gcdb_show_string_for_ctrl_map(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version,int dev_fd, const char *name, uint32_t *cur_map);\n#endif\n\n\n"
        },
        {
          "name": "hardware.cpp",
          "type": "blob",
          "size": 1.6923828125,
          "content": "/*\nCopyright 2008, 2009 Jakub Bednarski\n\nThis file is part of Minimig\n\nMinimig is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\nMinimig is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <ctype.h>\n#include <time.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdint.h>\n#include \"hardware.h\"\n#include \"user_io.h\"\n\nuint8_t rstval = 0;\n\nvoid hexdump(void *data, uint16_t size, uint16_t offset)\n{\n\tuint8_t i, b2c;\n\tuint16_t n = 0;\n\tchar *ptr = (char*)data;\n\n\tif (!size) return;\n\n\twhile (size>0) {\n\t\tprintf(\"%04x: \", n + offset);\n\n\t\tb2c = (size>16) ? 16 : size;\n\t\tfor (i = 0; i<b2c; i++) printf(\"%02x \", 0xff & ptr[i]);\n\t\tprintf(\"  \");\n\t\tfor (i = 0; i<(16 - b2c); i++) printf(\"   \");\n\t\tfor (i = 0; i<b2c; i++) printf(\"%c\", isprint(ptr[i]) ? ptr[i] : '.');\n\t\tprintf(\"\\n\");\n\t\tptr += b2c;\n\t\tsize -= b2c;\n\t\tn += b2c;\n\t}\n}\n\nunsigned long GetTimer(unsigned long offset)\n{\n\tstruct timespec tp;\n\n  \tclock_gettime(CLOCK_BOOTTIME, &tp);\n\n\tuint64_t res;\n\n\tres = tp.tv_sec;\n\tres *= 1000;\n\tres += (tp.tv_nsec / 1000000);\n\n\treturn (unsigned long)(res + offset);\n}\n\nunsigned long CheckTimer(unsigned long time)\n{\n\treturn (!time) || (GetTimer(0) >= time);\n}\n\nvoid WaitTimer(unsigned long time)\n{\n\ttime = GetTimer(time);\n\twhile (!CheckTimer(time));\n}\n"
        },
        {
          "name": "hardware.h",
          "type": "blob",
          "size": 0.423828125,
          "content": "#ifndef HARDWARE_H\n#define HARDWARE_H\n\n#include <inttypes.h>\n#include <stdio.h>\n\nunsigned long GetTimer(unsigned long offset);\nunsigned long CheckTimer(unsigned long t);\nvoid WaitTimer(unsigned long time);\n\nvoid hexdump(void *data, uint16_t size, uint16_t offset = 0);\n\n// minimig reset stuff\n#define SPI_RST_USR         0x1\n#define SPI_RST_CPU         0x2\n#define SPI_CPU_HLT         0x4\nextern uint8_t rstval;\n\n#endif // HARDWARE_H\n"
        },
        {
          "name": "ide.cpp",
          "type": "blob",
          "size": 30.251953125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <time.h>\n#include <ios>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <sys/stat.h>\n\n#include \"support/x86/x86.h\"\n#include \"support/minimig/minimig_hdd.h\"\n#include \"support/minimig/minimig_config.h\"\n#include \"spi.h\"\n#include \"user_io.h\"\n#include \"file_io.h\"\n#include \"hardware.h\"\n#include \"ide.h\"\n\n#if 0\n\t#define dbg_printf     printf\n\t#define dbg_print_regs ide_print_regs\n\t#define dbg_hexdump    hexdump\n#else\n\t#define dbg_printf(...)   void()\n\t#define dbg_print_regs    void\n\t#define dbg_hexdump(...)  void()\n#endif\n\n#if 0\n\t#define dbg2_printf     printf\n#else\n\t#define dbg2_printf(...)   void()\n#endif\n\n#define IDE0_BASE 0xF000\n#define IDE1_BASE 0xF100\n\n#define ide_send_data(databuf, size) ide_sendbuf(ide, 255, (size), (uint16_t*)(databuf))\n#define ide_recv_data(databuf, size) ide_recvbuf(ide, 255, (size), (uint16_t*)(databuf))\n\n#define SWAP(a)  ((((a)&0x000000ff)<<24)|(((a)&0x0000ff00)<<8)|(((a)&0x00ff0000)>>8)|(((a)&0xff000000)>>24))\n\nvoid ide_reg_set(ide_config *ide, uint16_t reg, uint16_t value)\n{\n\tEnableIO();\n\tspi8(UIO_DMA_WRITE);\n\tspi32_w(ide->base + reg);\n\tspi_w(value);\n\tDisableIO();\n}\n\nvoid ide_sendbuf(ide_config *ide, uint16_t reg, uint32_t length, uint16_t *data)\n{\n\tEnableIO();\n\tfpga_spi_fast(UIO_DMA_WRITE);\n\tfpga_spi_fast(ide->base + reg);\n\tfpga_spi_fast(0);\n\tfpga_spi_fast_block_write(data, length);\n\tDisableIO();\n}\n\nvoid ide_recvbuf(ide_config *ide, uint16_t reg, uint32_t length, uint16_t *data)\n{\n\tEnableIO();\n\tfpga_spi_fast(UIO_DMA_READ);\n\tfpga_spi_fast(ide->base + reg);\n\tfpga_spi_fast(0);\n\tfpga_spi_fast_block_read(data, length);\n\tDisableIO();\n}\n\nconst uint32_t ide_io_max_size = 32;\nuint8_t ide_buf[ide_io_max_size * 512];\n\nide_config ide_inst[2] = {};\n\nuint16_t ide_check()\n{\n\tuint16_t res;\n\tEnableIO();\n\tres = spi_w(UIO_DMA_SDIO);\n\tif (!res) res = (uint8_t)spi_w(0);\n\tDisableIO();\n\treturn res;\n}\n\nint ide_img_mount(fileTYPE *f, const char *name, int rw)\n{\n\tFileClose(f);\n\tint writable = 0, ret = 0;\n\n\tint len = strlen(name);\n\tif (len)\n\t{\n\t\tconst char *ext = name + len - 4;\n\t\tif (!strncasecmp(\".chd\", ext, 4))\n\t\t{\n\t\t\tret = 1;\n\t\t}\n\t\telse {\n\t\t\twritable = rw && FileCanWrite(name);\n\t\t\tret = FileOpenEx(f, name, writable ? (O_RDWR | O_SYNC) : O_RDONLY);\n\t\t\tif (!ret) printf(\"Failed to open file %s\\n\", name);\n\t\t}\n\t}\n\n\tif (!ret)\n\t{\n\t\tf->size = 0;\n\t\treturn 0;\n\t}\n\n\tprintf(\"Mount %s as %s\\n\", name, writable ? \"read-write\" : \"read-only\");\n\treturn 1;\n}\n\nvoid ide_print_regs(regs_t *regs)\n{\n\tprintf(\"\\nIDE regs:\\n\");\n\tprintf(\"   io_done:  %02X\\n\", regs->io_done);\n\tprintf(\"   features: %02X\\n\", regs->features);\n\tprintf(\"   sec_cnt:  %02X\\n\", regs->sector_count);\n\tprintf(\"   sector:   %02X\\n\", regs->sector);\n\tprintf(\"   cylinder: %04X\\n\", regs->cylinder);\n\tprintf(\"   head:     %02X\\n\", regs->head);\n\tprintf(\"   drv:      %02X\\n\", regs->drv);\n\tprintf(\"   lba:      %02X\\n\", regs->lba);\n\tprintf(\"   command:  %02X\\n\", regs->cmd);\n}\n\nvoid ide_get_regs(ide_config *ide)\n{\n\tuint32_t data[3];\n\tide_recvbuf(ide, 0, 6, (uint16_t*)data);\n\n\tide->regs.io_done = (uint8_t)(data[0] & 1);\n\tide->regs.io_fast = (uint8_t)(data[0] & 2);\n\tide->regs.features = (uint8_t)(data[0] >> 8);\n\tide->regs.sector_count = (uint8_t)(data[0] >> 16);\n\tide->regs.sector = (uint8_t)(data[0] >> 24);\n\n\tide->regs.cylinder = data[1] & 0xFFFF;\n\tide->regs.head = (data[2] >> 16) & 0xF;\n\tide->regs.drv = (data[2] >> 20) & 1;\n\tide->regs.lba = (data[2] >> 22) & 1;\n\tide->regs.cmd = data[2] >> 24;\n\n\tide->regs.error = 0;\n\tide->regs.status = 0;\n\n\tdbg_print_regs(&ide->regs);\n}\n\nvoid ide_set_regs(ide_config *ide)\n{\n\tif (!(ide->regs.status & (ATA_STATUS_BSY | ATA_STATUS_ERR))) ide->regs.status |= ATA_STATUS_DSC;\n\n\tuint8_t data[12] =\n\t{\n\t\t(uint8_t)((ide->drive[ide->regs.drv].cd) ? 0x80 : ide->regs.io_size),\n\t\t(uint8_t)(ide->regs.error),\n\t\t(uint8_t)(ide->regs.sector_count),\n\t\t(uint8_t)(ide->regs.sector),\n\n\t\t(uint8_t)(ide->regs.cylinder),\n\t\t(uint8_t)(ide->regs.cylinder >> 8),\n\t\t(uint8_t)(ide->regs.cylinder >> 16),\n\t\t(uint8_t)(ide->regs.cylinder >> 24),\n\n\t\t(uint8_t)(ide->drive[ide->regs.drv].cd ? ide->regs.pkt_io_size : 0),\n\t\t(uint8_t)(ide->drive[ide->regs.drv].cd ? ide->regs.pkt_io_size >> 8 : 0),\n\t\t(uint8_t)((ide->regs.lba ? 0xE0 : 0xA0) | (ide->regs.drv ? 0x10 : 0x00) | ide->regs.head),\n\t\t(uint8_t)(ide->regs.status)\n\t};\n\n\t//hexdump(data, 12, ide->base);\n\tide_sendbuf(ide, 0, 6, (uint16_t*)data);\n}\n\nstatic void calc_geometry(chs_t *chs, uint64_t size)\n{\n\tuint32_t head = 0, cyl = 0, spt = 0;\n\tuint32_t sptt[] = { 63, 127, 255, 0 };\n\tuint32_t total = size / 512;\n\tfor (int i = 0; sptt[i] != 0; i++)\n\t{\n\t\tspt = sptt[i];\n\t\tfor (head = 4; head <= 16; head++)\n\t\t{\n\t\t\tcyl = total / (head * spt);\n\t\t\tif (total <= 1024 * 1024)\n\t\t\t{\n\t\t\t\tif (cyl <= 1023) break;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cyl < 16383) break;\n\t\t\t\tif (cyl < 32767 && head >= 5) break;\n\t\t\t\tif (cyl <= 65536) break;\n\t\t\t}\n\t\t}\n\t\tif (head <= 16) break;\n\t}\n\n\tchs->cylinders = cyl;\n\tchs->heads = (uint16_t)head;\n\tchs->sectors = (uint16_t)spt;\n}\n\nstatic void get_rdb_geometry(RigidDiskBlock *rdb, chs_t *chs, uint64_t size)\n{\n\tchs->heads = SWAP(rdb->rdb_Heads);\n\tchs->sectors = SWAP(rdb->rdb_Sectors);\n\tchs->cylinders = SWAP(rdb->rdb_Cylinders);\n\tif (chs->sectors > 255 || chs->heads > 16)\n\t{\n\t\tprintf(\"ATTN: Illegal CHS value(s).\");\n\t\tif (!(chs->sectors & 1) && (chs->sectors < 512) && (chs->heads <= 8))\n\t\t{\n\t\t\tprintf(\" Translate: sectors %d->%d, heads %d->%d.\\n\", chs->sectors, chs->sectors / 2, chs->heads, chs->heads * 2);\n\t\t\tchs->sectors /= 2;\n\t\t\tchs->heads *= 2;\n\t\t\treturn;\n\t\t}\n\n\t\tprintf(\" DANGEROUS: Cannot translate to legal CHS values. Re-calculate the CHS.\\n\");\n\t\tcalc_geometry(chs, size);\n\t}\n}\n\nstatic void guess_geometry(fileTYPE *f, chs_t *chs, int allow_vrdb)\n{\n\tuint8_t flg = 0;\n\tchs->offset = 0;\n\n\tfor (int i = 0; i < 16; ++i)\n\t{\n\t\tstruct RigidDiskBlock *rdb = (struct RigidDiskBlock *)ide_buf;\n\t\tif (!FileReadSec(f, ide_buf)) break;\n\t\tfor (int i = 0; i < 512; i++) flg |= ide_buf[i];\n\n\t\tif (rdb->rdb_ID == RDB_MAGIC)\n\t\t{\n\t\t\tprintf(\"Found RDB header -> native Amiga image.\\n\");\n\t\t\tget_rdb_geometry(rdb, chs, f->size);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (allow_vrdb && flg)\n\t{\n\t\tchs->heads = 16;\n\t\tchs->sectors = 128;\n\n\t\tfor (int i = 32; i <= 2048; i <<= 1)\n\t\t{\n\t\t\tint cylinders = f->size / (512 * i) + 1;\n\t\t\tif (cylinders < 65536)\n\t\t\t{\n\t\t\t\tchs->sectors = (i < 128) ? i : 128;\n\t\t\t\tchs->heads = i / chs->sectors;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint spc = chs->heads * chs->sectors;\n\t\tchs->cylinders = f->size / (512 * spc) + 1;\n\t\tif (chs->cylinders > 65535) chs->cylinders = 65535;\n\t\tchs->offset = -spc;\n\t\tprintf(\"No RDB header found in HDF image. Assume it's image of single partition. Use Virtual RDB header.\\n\");\n\t}\n\telse\n\t{\n\t\tcalc_geometry(chs, f->size);\n\t\tif(allow_vrdb) printf(\"No RDB header found. Possible non-Amiga or empty image.\\n\");\n\t}\n}\n\nstatic void ide_set_geometry(drive_t *drive, uint16_t sectors, uint16_t heads)\n{\n\tint info = 0;\n\tif (drive->heads != heads || drive->spt != sectors)\n\t{\n\t\tinfo = 1;\n\t\tprintf(\"SPT=%d, Heads=%d\\n\", sectors, heads);\n\t}\n\n\tdrive->heads = heads ? heads : 16;\n\tdrive->spt = sectors ? sectors : 256;\n\n\tuint32_t cylinders = drive->f->size / (drive->heads * drive->spt * 512);\n\tif (drive->offset)\n\t{\n\t\tcylinders++;\n\t\tdrive->offset = drive->heads * drive->spt;\n\t}\n\tif (cylinders > 65535) cylinders = 65535;\n\n\t//Maximum 137GB images are supported.\n\tdrive->cylinders = cylinders;\n\tif(info) printf(\"New SPT=%d, Heads=%d, Cylinders=%d\\n\", drive->spt, drive->heads, drive->cylinders);\n}\n\nstatic uint32_t checksum_rdb(uint32_t *p, int set)\n{\n\tuint32_t count = SWAP(p[1]);\n\tuint32_t result = 0;\n\tif (set) p[2] = 0;\n\n\tfor (uint32_t i = 0; i < count; ++i) result += SWAP(p[i]);\n\tif (!set) return result;\n\n\tresult = 0 - result;\n\tp[2] = SWAP(result);\n\treturn 0;\n}\n\nstatic void fill_fake_rdb(drive_t *drive, uint32_t sector, int cnt)\n{\n\tprintf(\"fill_fake_rdb(%u,%d)\\n\", sector, cnt);\n\n\tuint8_t *buff = ide_buf;\n\tmemset(ide_buf, 0, sizeof(ide_buf));\n\n\twhile (cnt)\n\t{\n\t\t// if we're asked for LBA 0 we create an RDSK block, and if LBA 1, a PART block\n\t\tif (sector == 0)\n\t\t{\n\t\t\t// RDB\n\t\t\tstruct RigidDiskBlock *rdb = (struct RigidDiskBlock *)buff;\n\t\t\trdb->rdb_ID = 'R' << 24 | 'D' << 16 | 'S' << 8 | 'K';\n\t\t\trdb->rdb_Summedlongs = 0x40;\n\t\t\trdb->rdb_HostID = 0x07;\n\t\t\trdb->rdb_BlockBytes = 0x200;\n\t\t\trdb->rdb_Flags = 0x12;                 // (Disk ID valid, no LUNs after this one)\n\t\t\trdb->rdb_BadBlockList = 0xffffffff;    // We don't provide a bad block list\n\t\t\trdb->rdb_PartitionList = 1;\n\t\t\trdb->rdb_FileSysHeaderList = 0xffffffff;\n\t\t\trdb->rdb_DriveInit = 0xffffffff;\n\t\t\trdb->rdb_Reserved1[0] = 0xffffffff;\n\t\t\trdb->rdb_Reserved1[1] = 0xffffffff;\n\t\t\trdb->rdb_Reserved1[2] = 0xffffffff;\n\t\t\trdb->rdb_Reserved1[3] = 0xffffffff;\n\t\t\trdb->rdb_Reserved1[4] = 0xffffffff;\n\t\t\trdb->rdb_Reserved1[5] = 0xffffffff;\n\t\t\trdb->rdb_Cylinders = drive->cylinders;\n\t\t\trdb->rdb_Sectors = drive->spt;\n\t\t\trdb->rdb_Heads = drive->heads;\n\t\t\trdb->rdb_Interleave = 1;\n\t\t\trdb->rdb_Park = rdb->rdb_Cylinders;\n\t\t\trdb->rdb_WritePreComp = rdb->rdb_Cylinders;\n\t\t\trdb->rdb_ReducedWrite = rdb->rdb_Cylinders;\n\t\t\trdb->rdb_StepRate = 3;\n\t\t\trdb->rdb_RDBBlocksLo = 0;\n\t\t\trdb->rdb_RDBBlocksHi = 1;\n\t\t\trdb->rdb_LoCylinder = 1;\n\t\t\trdb->rdb_HiCylinder = rdb->rdb_Cylinders - 1;\n\t\t\trdb->rdb_CylBlocks = rdb->rdb_Heads * rdb->rdb_Sectors;\n\t\t\trdb->rdb_AutoParkSeconds = 0;\n\t\t\trdb->rdb_HighRDSKBlock = 1;\n\t\t\tstrcpy(rdb->rdb_DiskVendor, \"DON'T   REPARTITION!    0.00\");\n\t\t\tuint32_t *p = (uint32_t*)buff;\n\t\t\tfor (int i = 0; i < 40; i++) p[i] = SWAP(p[i]);\n\t\t}\n\t\telse if(sector == 1)\n\t\t{\n\t\t\t// Partition\n\t\t\tstruct PartitionBlock *pb = (struct PartitionBlock *)buff;\n\t\t\tpb->pb_ID = 'P' << 24 | 'A' << 16 | 'R' << 8 | 'T';\n\t\t\tpb->pb_Summedlongs = 0x40;\n\t\t\tpb->pb_HostID = 0x07;\n\t\t\tpb->pb_Next = 0xffffffff;\n\t\t\tpb->pb_Flags = 0x1; // bootable\n\t\t\tpb->pb_DevFlags = 0;\n\t\t\tstrcpy(pb->pb_DriveName, \"0HD\\003\");  // \"DHx\" BCPL string\n\t\t\tpb->pb_DriveName[0] = drive->drvnum + '0';\n\t\t\tpb->pb_Environment.de_TableSize = 0x10;\n\t\t\tpb->pb_Environment.de_SizeBlock = 0x80;\n\t\t\tpb->pb_Environment.de_Surfaces = drive->heads;\n\t\t\tpb->pb_Environment.de_SectorPerBlock = 1;\n\t\t\tpb->pb_Environment.de_BlocksPerTrack = drive->spt;\n\t\t\tpb->pb_Environment.de_Reserved = 2;\n\t\t\tpb->pb_Environment.de_LowCyl = 1;\n\t\t\tpb->pb_Environment.de_HighCyl = drive->cylinders - 1;\n\t\t\tpb->pb_Environment.de_NumBuffers = 30;\n\t\t\tpb->pb_Environment.de_MaxTransfer = 0xffffff;\n\t\t\tpb->pb_Environment.de_Mask = 0x7ffffffe;\n\t\t\tpb->pb_Environment.de_DosType = 0x444f5301;\n\t\t\tuint32_t *p = (uint32_t*)buff;\n\t\t\tfor (int i = 0; i < 64; i++) p[i] = SWAP(p[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tchecksum_rdb((uint32_t*)buff, 1);\n\t\t//hexdump(buff, 256);\n\t\tcnt--;\n\t\tsector++;\n\t\tbuff += 512;\n\t}\n}\n\nvoid ide_img_set(uint32_t drvnum, fileTYPE *f, int cd, int sectors, int heads, int offset, int type)\n{\n\tint drv = (drvnum & 1);\n\tint port = (drvnum >> 1);\n\n\tdrive_t *drive = &ide_inst[port].drive[drv];\n\n\tide_inst[port].base = port ? IDE1_BASE : IDE0_BASE;\n\tide_inst[port].drive[drv].drvnum = drvnum;\n\n\tif (drive->f && (f != drive->f) && drive->f->opened())\n\t{\n\t\tFileClose(drive->f);\n\t}\n\n\tdrive->f = f;\n\n\tdrive->cylinders = 0;\n\tdrive->heads = 0;\n\tdrive->spt = 0;\n\tdrive->spb = 16;\n\tdrive->offset = 0;\n\tdrive->type = 0;\n\n\tdrive->present = f ? 1 : 0;\n\tide_inst[port].state = IDE_STATE_RESET;\n\tide_inst[port].bitoff = port * 3;\n\n\tdrive->cd = drive->present && cd;\n\n\tif (f && drive->placeholder && !drive->cd)\n\t{\n\t\tprintf(\"Cannot hot-mount HDD image to CD!\\n\");\n\t\tFileClose(drive->f);\n\t\tdrive->f = 0;\n\t\tf = 0;\n\t\tdrive->present = 0;\n\t}\n\n\tdrive->placeholder = drive->allow_placeholder;\n\tif (drive->placeholder && drive->present && !drive->cd) drive->placeholder = 0;\n\tif (drive->placeholder) drive->cd = 1;\n\n\tide_reg_set(&ide_inst[port], 6, ((drive->present || drive->placeholder) ? 9 : 8) << (drv * 4));\n\tide_reg_set(&ide_inst[port], 6, 0x200);\n\n\tif(drive->f)\n\t{\n\t\tif (!drive->chd_f) drive->total_sectors = (drive->f->size / 512);\n\t}\n\telse\n\t{\n\t\tdrive->total_sectors = 0;\n\t}\n\n\tif (!drive->cd)\n\t{\n\t\tif (drive->present)\n\t\t{\n\t\t\tide_set_geometry(drive, sectors, heads);\n\t\t\tif (offset && drive->cylinders < 65535) drive->cylinders++;\n\t\t\tdrive->offset = offset;\n\t\t\tdrive->type = type;\n\t\t}\n\n\t\tuint16_t identify[256] =\n\t\t{\n\t\t\t0x0040, \t\t\t\t\t\t\t\t\t\t\t//word 0\n\t\t\tdrive->cylinders,\t\t\t\t\t\t\t\t\t//word 1\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 2 reserved\n\t\t\tdrive->heads,\t\t\t\t\t\t\t\t\t\t//word 3\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 4 obsolete\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 5 obsolete\n\t\t\tdrive->spt,\t\t\t\t\t\t\t\t\t\t\t//word 6\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 7 vendor specific\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 8 vendor specific\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 9 vendor specific\n\t\t\t('A' << 8) | 'O',\t\t\t\t\t\t\t\t\t//word 10\n\t\t\t('H' << 8) | 'D',\t\t\t\t\t\t\t\t\t//word 11\n\t\t\t('0' << 8) | '0',\t\t\t\t\t\t\t\t\t//word 12\n\t\t\t('0' << 8) | '0',\t\t\t\t\t\t\t\t\t//word 13\n\t\t\t('0' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 14\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 15\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 16\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 17\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 18\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 19\n\t\t\t3,   \t\t\t\t\t\t\t\t\t\t\t\t//word 20 buffer type\n\t\t\t512,\t\t\t\t\t\t\t\t\t\t\t\t//word 21 cache size\n\t\t\t4,\t\t\t\t\t\t\t\t\t\t\t\t\t//word 22 number of ecc bytes\n\t\t\t0,0,0,0,\t\t\t\t\t\t\t\t\t\t\t//words 23..26 firmware revision\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//words 27..46 model number\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t0x8020,\t\t\t\t\t\t\t\t\t\t\t\t//word 47 max multiple sectors\n\t\t\t1,\t\t\t\t\t\t\t\t\t\t\t\t\t//word 48 dword io\n\t\t\t1 << 9,\t\t\t\t\t\t\t\t\t\t\t\t//word 49 lba supported\n\t\t\t0x4001,\t\t\t\t\t\t\t\t\t\t\t\t//word 50 reserved\n\t\t\t0x0200,\t\t\t\t\t\t\t\t\t\t\t\t//word 51 pio timing\n\t\t\t0x0200,\t\t\t\t\t\t\t\t\t\t\t\t//word 52 pio timing\n\t\t\t0x0007,\t\t\t\t\t\t\t\t\t\t\t\t//word 53 valid fields\n\t\t\tdrive->cylinders, \t\t\t\t\t\t\t\t\t//word 54\n\t\t\tdrive->heads,\t\t\t\t\t\t\t\t\t\t//word 55\n\t\t\tdrive->spt,\t\t\t\t\t\t\t\t\t\t\t//word 56\n\t\t\t(uint16_t)(drive->total_sectors & 0xFFFF),\t\t\t//word 57\n\t\t\t(uint16_t)(drive->total_sectors >> 16),\t\t\t\t//word 58\n\t\t\t0x110,\t\t\t\t\t\t\t\t\t\t\t\t//word 59 multiple sectors\n\t\t\t(uint16_t)(drive->total_sectors & 0xFFFF),\t\t\t//word 60 LBA-28\n\t\t\t(uint16_t)(drive->total_sectors >> 16),\t\t\t\t//word 61 LBA-28\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 62 single word dma modes\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 63 multiple word dma modes\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 64 pio modes\n\t\t\t120,120,120,120,\t\t\t\t\t\t\t\t\t//word 65..68\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,\t\t\t\t\t\t\t\t//word 69..79\n\t\t\t0x007E,\t\t\t\t\t\t\t\t\t\t\t\t//word 80 ata modes\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 81 minor version number\n\t\t\t(1 << 14) | (1 << 9), \t\t\t\t\t\t\t\t//word 82 supported commands\n\t\t\t(1 << 14) | (1 << 13) | (1 << 12),\t\t\t\t\t//word 83\n\t\t\t1 << 14,\t    \t\t\t\t\t\t\t\t\t//word 84\n\t\t\t(1 << 14) | (1 << 9),  \t\t\t\t\t\t\t\t//word 85\n\t\t\t(1 << 14) | (1 << 13) | (1 << 12),\t\t\t\t\t//word 86\n\t\t\t1 << 14,\t    \t\t\t\t\t\t\t\t\t//word 87\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 88\n\t\t\t0,0,0,0,\t\t\t\t\t\t\t\t\t\t\t//word 89..92\n\t\t\t(1 << 14) | (1 << 13) | (1 << 9) | (1 << 8) | (1 << 3) | (1 << 1) | (1 << 0), //word 93\n\t\t\t0,0,0,0,0,0,\t\t\t\t\t\t\t\t\t\t//word 94..99\n\t\t\t(uint16_t)(drive->total_sectors & 0xFFFF),\t\t\t//word 100 LBA-48\n\t\t\t(uint16_t)(drive->total_sectors >> 16),\t\t\t\t//word 101 LBA-48\n\t\t\t0,\t\t\t\t\t\t\t\t\t\t\t\t\t//word 102 LBA-48\n\t\t\t0,\t\t\t\t\t\t\t\t\t\t\t\t\t//word 103 LBA-48\n\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t//word 104..127\n\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t\t\t\t//word 128..255\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\t\t};\n\t\tfor (int i = 0; i < 256; i++) drive->id[i] = identify[i];\n\t}\n\telse\n\t{\n\t\tuint16_t identify[256] =\n\t\t{\n\t\t\t0x8580, \t\t\t\t\t\t\t\t\t\t\t//word 0\n\t\t\t0x0000, \t\t\t\t\t\t\t\t\t\t\t//word 1\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 2 reserved\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 3\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 4\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 5\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 6\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 7 vendor specific\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 8 vendor specific\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 9 vendor specific\n\t\t\t('A' << 8) | 'O',\t\t\t\t\t\t\t\t\t//word 10\n\t\t\t('C' << 8) | 'D',\t\t\t\t\t\t\t\t\t//word 11\n\t\t\t('0' << 8) | '0',\t\t\t\t\t\t\t\t\t//word 12\n\t\t\t('0' << 8) | '0',\t\t\t\t\t\t\t\t\t//word 13\n\t\t\t('0' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 14\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 15\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 16\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 17\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 18\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//word 19\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 20 buffer type\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 21 cache size\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 22 number of ecc bytes\n\t\t\t0,0,0,0,\t\t\t\t\t\t\t\t\t\t\t//words 23..26 firmware revision\n\t\t\t(' ' << 8) | ' ',\t\t\t\t\t\t\t\t\t//words 27..46 model number\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t(' ' << 8) | ' ',\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 47\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 48\n\t\t\t1 << 9,\t\t\t\t\t\t\t\t\t\t\t\t//word 49 lba supported\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 50\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 51\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 52\n\t\t\t0x0007,\t\t\t\t\t\t\t\t\t\t\t\t//word 53 valid fields\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 54\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 55\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 56\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 57\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 58\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 59\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 60\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 61\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 62\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 63 multiple word dma modes\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 64 pio modes\n\t\t\t120,120,120,120,\t\t\t\t\t\t\t\t\t//word 65..68\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,\t\t\t\t\t\t\t\t//word 69..79\n\t\t\t0x007E,\t\t\t\t\t\t\t\t\t\t\t\t//word 80 ata modes\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 81 minor version number\n\t\t\t(1 << 9) | (1 << 4), \t\t\t\t\t\t\t\t//word 82 supported commands\n\t\t\t(1 << 14),\t\t\t\t\t\t\t\t\t\t\t//word 83\n\t\t\t1 << 14,\t    \t\t\t\t\t\t\t\t\t//word 84\n\t\t\t(1 << 14) | (1 << 9) | (1 << 4), \t\t\t\t\t//word 85\n\t\t\t0,\t\t\t\t\t\t\t\t\t\t\t\t\t//word 86\n\t\t\t1 << 14,\t    \t\t\t\t\t\t\t\t\t//word 87\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 88\n\t\t\t0,0,0,0,\t\t\t\t\t\t\t\t\t\t\t//word 89..92\n\t\t\t1 | (1 << 14) | (1 << 13) | (1 << 9) | (1 << 8) | (1 << 3) | (1 << 1) | (1 << 0), //word 93\n\t\t\t0,0,0,0,0,0,\t\t\t\t\t\t\t\t\t\t//word 94..99\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 100\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 101\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 102\n\t\t\t0x0000,\t\t\t\t\t\t\t\t\t\t\t\t//word 103\n\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t//word 104..127\n\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t\t\t\t//word 128..255\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n\t\t\t0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\t\t};\n\n\t\tfor (int i = 0; i < 256; i++) drive->id[i] = identify[i];\n\t\tdrive->load_state = (drive->f || drive->chd_f) ? 1 : 3;\n\t}\n\n\tif (ide_inst[port].drive[drv].present)\n\t{\n\t\tchar *name = ide_inst[port].drive[drv].f->name;\n\t\tfor (int i = 0; i < 20; i++)\n\t\t{\n\t\t\tif (*name) drive->id[27 + i] = ((*name++) << 8) | 0x20;\n\t\t\tif (*name) drive->id[27 + i] = (drive->id[27 + i] & 0xFF00) | (*name++);\n\t\t}\n\t\t//hexdump(drive->id, 256);\n\t}\n\n\tprintf(\"HDD%d:\\n  present %d\\n  hd_cylinders %d\\n  hd_heads %d\\n  hd_spt %d\\n  hd_total_sectors %d\\n\\n\",\n\t\tdrvnum, drive->present, drive->cylinders, drive->heads, drive->spt, drive->total_sectors);\n}\n\nstatic uint32_t get_lba(ide_config *ide)\n{\n\tuint32_t lba;\n\tif (ide->regs.lba)\n\t{\n\t\tlba = ide->regs.sector | (ide->regs.cylinder << 8) | (ide->regs.head << 24);\n\t}\n\telse\n\t{\n\t\tdrive_t *drive = &ide->drive[ide->regs.drv];\n\t\tdbg2_printf(\"  CHS: %d/%d/%d (%d/%d)\\n\", ide->regs.cylinder, ide->regs.head, ide->regs.sector, drive->heads, drive->spt);\n\t\tlba = ide->regs.cylinder;\n\t\tlba *= drive->heads;\n\t\tlba += ide->regs.head;\n\t\tlba *= drive->spt;\n\t\tlba += ide->regs.sector - 1;\n\t}\n\n\tdbg2_printf(\"  LBA: %u\\n\", lba);\n\treturn lba;\n}\n\nstatic void put_lba(ide_config *ide, uint32_t lba)\n{\n\tlba--;\n\tdbg2_printf(\"  putLBA: %u\\n\", lba);\n\tif (ide->regs.lba)\n\t{\n\t\tide->regs.sector = lba;\n\t\tlba >>= 8;\n\t\tide->regs.cylinder = lba;\n\t\tlba >>= 16;\n\t\tide->regs.head = lba & 0xF;\n\t}\n\telse\n\t{\n\t\tdrive_t *drive = &ide->drive[ide->regs.drv];\n\t\tuint32_t hspt = drive->heads * drive->spt;\n\t\tide->regs.cylinder = lba / hspt;\n\t\tlba = lba % hspt;\n\t\tide->regs.head = lba / drive->spt;\n\t\tlba = lba % drive->spt;\n\t\tide->regs.sector = lba + 1;\n\t}\n}\n\ninline uint16_t get_cnt(ide_config *ide)\n{\n\tdrive_t *drive = &ide->drive[ide->regs.drv];\n\tdbg2_printf(\"  Cnt: %d (max = %d)\\n\", ide->regs.sector_count, drive->spb);\n\tuint16_t cnt = ide->regs.sector_count;\n\tif (!cnt || cnt > drive->spb)\n\t{\n\t\tcnt = drive->spb;\n\t\tdbg2_printf(\"  New cnt: %d\\n\", cnt);\n\t}\n\treturn cnt;\n}\n\ninline int readhdd(drive_t *drive, uint32_t lba, int cnt)\n{\n\tif (lba < drive->offset)\n\t{\n\t\tif (!drive->type) fill_fake_rdb(drive, lba, cnt);\n\t\telse memset(ide_buf, 0, sizeof(ide_buf));\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn FileReadAdv(drive->f, ide_buf, cnt * 512, -1);\n\t}\n}\n\nstatic void process_read(ide_config *ide, int multi)\n{\n\tuint32_t lba = get_lba(ide);\n\tuint16_t ide_req = 0;\n\n\tdbg2_printf(\"  sector_count: %d\\n\", ide->regs.sector_count);\n\n\tuint32_t cnt = multi ? get_cnt(ide) : 1;\n\tide->null = !FileSeekLBA(ide->drive[ide->regs.drv].f, (lba <= ide->drive[ide->regs.drv].offset) ? 0 : (lba - ide->drive[ide->regs.drv].offset));\n\tif (!ide->null) ide->null = (readhdd(&ide->drive[ide->regs.drv], lba, cnt) <= 0);\n\tif (ide->null) memset(ide_buf, 0, cnt * 512);\n\n\twhile (1)\n\t{\n\t\tlba += cnt;\n\t\tide->regs.sector_count -= cnt;\n\t\tput_lba(ide, lba);\n\n\t\tide->regs.io_size = cnt;\n\t\tide->regs.status = ATA_STATUS_RDP | ATA_STATUS_RDY | ATA_STATUS_DRQ | ATA_STATUS_IRQ;\n\t\tif (!ide->regs.sector_count) ide->regs.status |= ATA_STATUS_END;\n\n\t\tif (ide->regs.io_fast)\n\t\t{\n\t\t\tide_set_regs(ide);\n\t\t\tide_send_data(ide_buf, cnt * 256);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tide_send_data(ide_buf, cnt * 256);\n\t\t\tide->regs.status &= ~ATA_STATUS_RDP;\n\t\t\tide_set_regs(ide);\n\t\t}\n\n\t\tif (!ide->regs.sector_count)\n\t\t{\n\t\t\t//ATA_STATUS_END will set ATA_STATUS_RDY at the end\n\t\t\tide->state = IDE_STATE_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tcnt = multi ? get_cnt(ide) : 1;\n\t\tif (!ide->null) ide->null = (readhdd(&ide->drive[ide->regs.drv], lba, cnt) <= 0);\n\t\tif (ide->null) memset(ide_buf, 0, cnt * 512);\n\n\t\tide_req = 0;\n\t\twhile (!ide_req) ide_req = (ide_check() >> ide->bitoff) & 7;\n\n\t\tif (ide_req != 5)\n\t\t{\n\t\t\tide->state = IDE_STATE_IDLE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg2_printf(\"  finish\\n\");\n}\n\nstatic void process_write(ide_config *ide, int multi)\n{\n\tuint32_t lba = get_lba(ide);\n\tuint32_t cnt = 1;\n\tuint16_t ide_req;\n\n\tide->null = (ide->regs.cmd != 0xFA) ? !FileSeekLBA(ide->drive[ide->regs.drv].f, (lba <= ide->drive[ide->regs.drv].offset) ? 0 : (lba - ide->drive[ide->regs.drv].offset)) : 1;\n\tuint8_t irq = 0;\n\n\twhile (1)\n\t{\n\t\tcnt = multi ? get_cnt(ide) : 1;\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_DRQ | irq;\n\t\tirq = ATA_STATUS_IRQ;\n\n\t\tide->regs.io_size = cnt;\n\t\tide_set_regs(ide);\n\n\t\tide_req = 0;\n\t\twhile (!ide_req) ide_req = (ide_check() >> ide->bitoff) & 7;\n\n\t\tif (ide_req != 5)\n\t\t{\n\t\t\tide->state = IDE_STATE_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tide_recv_data(ide_buf, cnt * 256);\n\n\t\tif (ide->regs.cmd == 0xFA)\n\t\t{\n\t\t\tide->regs.sector_count = 0;\n\t\t\tchar* filename = user_io_make_filepath(HomeDir(), (char*)ide_buf);\n\t\t\tint drvnum = (ide->regs.head == 1) ? 0 : (ide->regs.head == 2) ? 1 : (ide->drive[ide->regs.drv].drvnum + 2);\n\n\t\t\tstatic const char* names[6] = { \"fdd0\", \"fdd1\", \"ide00\", \"ide01\", \"ide10\", \"ide11\" };\n\t\t\tprintf(\"Request for new image for drive %s: %s\\n\", names[drvnum], filename);\n\t\t\tif(is_x86()) x86_set_image(drvnum, filename);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ide->null) ide->null = (lba < ide->drive[ide->regs.drv].offset) ? 0 : (FileWriteAdv(ide->drive[ide->regs.drv].f, ide_buf, cnt * 512, -1) <= 0);\n\t\t\tlba += cnt;\n\t\t\tide->regs.sector_count -= cnt;\n\t\t\tput_lba(ide, lba);\n\t\t}\n\n\t\tif (!ide->regs.sector_count)\n\t\t{\n\t\t\tide->state = IDE_STATE_IDLE;\n\t\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_IRQ;\n\t\t\tide_set_regs(ide);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int handle_hdd(ide_config *ide)\n{\n\tswitch (ide->regs.cmd)\n\t{\n\tcase 0xEC: // identify\n\t\t{\n\t\t\tuint8_t drv = ide->regs.drv;\n\t\t\tmemset(&ide->regs, 0, sizeof(ide->regs));\n\t\t\tide->regs.drv = drv;\n\t\t}\n\t\tide->regs.io_size = 1;\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_DRQ | ATA_STATUS_IRQ | ATA_STATUS_END;\n\t\tide_send_data(ide->drive[ide->regs.drv].id, 256);\n\t\tide_set_regs(ide);\n\t\tbreak;\n\n\tcase 0xC4: // read multiple\n\t\tprocess_read(ide, 1);\n\t\tbreak;\n\n\tcase 0x20: // read with retry\n\tcase 0x21: // read\n\t\tprocess_read(ide, 0);\n\t\tbreak;\n\n\tcase 0xC5: // write multiple\n\t\tprocess_write(ide, 1);\n\t\tbreak;\n\n\tcase 0x30: // write with retry\n\tcase 0x31: // write\n\t\tprocess_write(ide, 0);\n\t\tbreak;\n\n\tcase 0xFA: // mount image\n\t\tide->regs.pkt_io_size = 256;\n\t\tprocess_write(ide, 0);\n\t\tbreak;\n\n\tcase 0xC6: // set multople\n\t\tif (ide->regs.sector_count > ide_io_max_size)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tide->drive[ide->regs.drv].spb = ide->regs.sector_count;\n\t\tdbg_printf(\"New block size: %d\\n\", ide->drive[ide->regs.drv].spb);\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_IRQ;\n\t\tide_set_regs(ide);\n\t\tbreak;\n\n\tcase 0x08: // reset (fail)\n\t\tdbg_printf(\"Reset command (08h) for HDD not supported\\n\");\n\t\treturn 1;\n\n\tcase 0x10 ... 0x1F: // recalibrate\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_IRQ;\n\t\tide->regs.cylinder = 0;\n\t\tide_set_regs(ide);\n\t\tbreak;\n\n\tcase 0x40: // READ VERIFY\n\t\tdbg_printf(\"Received read verify command. Not implemented but returning OK.\\n\");\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_IRQ;\n\t\tide_set_regs(ide);\n\t\tbreak;\n\n\tcase 0x91: // initialize device parameters\n\t\tide_set_geometry(&ide->drive[ide->regs.drv], ide->regs.sector_count, ide->regs.head + 1);\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_IRQ;\n\t\tide_set_regs(ide);\n\t\tbreak;\n\n\tdefault:\n\t\tdbg_printf(\"(!) Unsupported command (%04X)\\n\", ide->base);\n\t\tdbg_print_regs(&ide->regs);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid ide_io(int num, int req)\n{\n\tide_config *ide = &ide_inst[num];\n\n\t//printf(\"req: %d, disk: %d\\n\", req, num);\n\n\tif (req == 0) // no request\n\t{\n\t\tif (ide->state == IDE_STATE_RESET)\n\t\t{\n\t\t\tide->state = IDE_STATE_IDLE;\n\n\t\t\tide->regs.status = ATA_STATUS_RDY;\n\t\t\tide_set_regs(ide);\n\n\t\t\tdbg_printf(\"IDE %04X reset finish\\n\", ide->base);\n\t\t}\n\t}\n\telse if (req == 4) // command\n\t{\n\t\tide->state = IDE_STATE_IDLE;\n\t\tide_get_regs(ide);\n\n\t\tdbg2_printf(\"IDE command: %02X (on %d)\\n\", ide->regs.cmd, ide->regs.drv);\n\t\tint err = 0;\n\n\t\tif(ide->regs.cmd == 0xFA) err = handle_hdd(ide);\n\t\telse if (ide->drive[ide->regs.drv].cd) err = cdrom_handle_cmd(ide);\n\t\telse if (!ide->drive[ide->regs.drv].present) err = 1;\n\t\telse err = handle_hdd(ide);\n\n\t\tif (err)\n\t\t{\n\t\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_ERR | ATA_STATUS_IRQ;\n\t\t\tide->regs.error = ATA_ERR_ABRT;\n\t\t\tide_set_regs(ide);\n\t\t}\n\t}\n\telse if (req == 5) // data request\n\t{\n\t\tdbg2_printf(\"IDE data request (on %d)\\n\", ide->regs.drv);\n\t\tif (ide->state == IDE_STATE_WAIT_PKT_CMD)\n\t\t{\n\t\t\tcdrom_handle_pkt(ide);\n\t\t}\n\t\telse if (ide->state == IDE_STATE_WAIT_PKT_RD)\n\t\t{\n\t\t\tif (ide->regs.pkt_cnt) cdrom_read(ide);\n\t\t\telse cdrom_reply(ide, 0);\n\t\t}\n\t\telse if (ide->state == IDE_STATE_WAIT_PKT_MODE)\n\t\t{\n\t\t\tide_recv_data(ide_buf, 256);\n\t\t\tprintf(\"mode select data:\\n\");\n\t\t\thexdump(ide_buf, ide->regs.cylinder);\n\t\t\tcdrom_mode_select(ide);\n\t\t\tcdrom_reply(ide, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"(!) IDE unknown state!\\n\");\n\t\t\tide->state = IDE_STATE_IDLE;\n\t\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_ERR | ATA_STATUS_IRQ;\n\t\t\tide->regs.error = ATA_ERR_ABRT;\n\t\t\tide_set_regs(ide);\n\t\t}\n\t}\n\telse if (req == 6) // reset\n\t{\n\t\tif (ide->state != IDE_STATE_RESET)\n\t\t{\n\t\t\tprintf(\"IDE %04X reset start\\n\", ide->base);\n\t\t}\n\n\t\tide->drive[0].playing = 0;\n\t\tide->drive[0].paused = 0;\n\t\tide->drive[1].playing = 0;\n\t\tide->drive[1].paused = 0;\n\n\t\tide_get_regs(ide);\n\t\tide->regs.head = 0;\n\t\tide->regs.error = 0;\n\t\tide->regs.sector = 1;\n\t\tide->regs.sector_count = 1;\n\t\tide->regs.cylinder = (!ide->drive[ide->regs.drv].present) ? 0xFFFF : ide->drive[ide->regs.drv].cd ? 0xEB14 : 0x0000;\n\t\tif (ide->drive[ide->regs.drv].placeholder) ide->regs.cylinder = 0xEB14;\n\t\tide->regs.status = ATA_STATUS_BSY;\n\t\tide_set_regs(ide);\n\n\t\tide->state = IDE_STATE_RESET;\n\t}\n}\n\nint ide_is_placeholder(int num)\n{\n\treturn ide_inst[num / 2].drive[num & 1].placeholder;\n}\n\nvoid ide_reset(uint8_t hotswap[4])\n{\n\tide_inst[0].drive[0].placeholder = 0;\n\tide_inst[0].drive[1].placeholder = 0;\n\tide_inst[1].drive[0].placeholder = 0;\n\tide_inst[1].drive[1].placeholder = 0;\n\n\tide_inst[0].drive[0].allow_placeholder = hotswap[0];\n\tide_inst[0].drive[1].allow_placeholder = hotswap[1];\n\tide_inst[1].drive[0].allow_placeholder = hotswap[2];\n\tide_inst[1].drive[1].allow_placeholder = hotswap[3];\n\n\n\tide_inst[0].drive[0].volume_r = 1.0f;\n\tide_inst[0].drive[1].volume_r = 1.0f;\n\tide_inst[1].drive[0].volume_r = 1.0f;\n\tide_inst[1].drive[1].volume_r = 1.0f;\n\n\tide_inst[0].drive[0].volume_l = 1.0f;\n\tide_inst[0].drive[1].volume_l = 1.0f;\n\tide_inst[1].drive[0].volume_l = 1.0f;\n\tide_inst[1].drive[1].volume_l = 1.0f;\n\n\tide_inst[0].drive[0].mcr_flag = false;\n\tide_inst[0].drive[1].mcr_flag = false;\n\tide_inst[1].drive[0].mcr_flag = false;\n\tide_inst[1].drive[1].mcr_flag = false;\n}\n\nint ide_open(uint8_t unit, const char* filename)\n{\n\tstatic fileTYPE hdd_file[4] = {};\n\tchs_t chs = {};\n\n\tif (!is_minimig() || ((minimig_config.ide_cfg & 1) && minimig_config.hardfile[unit].cfg))\n\t{\n\t\tprintf(\"\\nChecking HDD %d\\n\", unit);\n\t\tif (filename[0] && FileOpenEx(&hdd_file[unit], filename, FileCanWrite(filename) ? O_RDWR : O_RDONLY))\n\t\t{\n\t\t\tprintf(\"file: \\\"%s\\\": \", hdd_file[unit].name);\n\t\t\tguess_geometry(&hdd_file[unit], &chs, is_minimig() && !strcasecmp(\".hdf\", filename + strlen(filename) - 4));\n\t\t\tprintf(\"size: %llu (%llu MB)\\n\", hdd_file[unit].size, hdd_file[unit].size >> 20);\n\t\t\tprintf(\"CHS: %u/%u/%u\", chs.cylinders, chs.heads, chs.sectors);\n\t\t\tprintf(\" (%llu MB), \", ((((uint64_t)chs.cylinders) * chs.heads * chs.sectors) >> 11));\n\t\t\tprintf(\"Offset: %d\\n\", chs.offset);\n\n\t\t\tint present = 0;\n\t\t\tint cd = 0;\n\n\t\t\tint len = strlen(filename);\n\t\t\tconst char *ext = filename + len - 4;\n\t\t\tint vhd = (len > 4 && (!strcasecmp(ext, \".hdf\") || (!strcasecmp(ext, \".vhd\"))));\n\n\t\t\tif (!vhd)\n\t\t\t{\n\t\t\t\tconst char *img_name = cdrom_parse(unit, filename);\n\t\t\t\tif (img_name) present = ide_img_mount(&hdd_file[unit], img_name, 0);\n\t\t\t\tif (present) cd = 1;\n\t\t\t\telse vhd = 1;\n\t\t\t}\n\n\t\t\tif (!present && vhd) present = ide_img_mount(&hdd_file[unit], filename, 1);\n\t\t\tide_img_set(unit, present ? &hdd_file[unit] : 0, cd, chs.sectors, chs.heads, cd ? 0 : -chs.offset);\n\t\t\tif (present) return 1;\n\t\t}\n\n\t\tprintf(\"HDD %d: not present\\n\", unit);\n\t}\n\n\t// close if opened earlier.\n\tide_img_set(unit, 0, 0);\n\tFileClose(&hdd_file[unit]);\n\treturn 0;\n}\n"
        },
        {
          "name": "ide.h",
          "type": "blob",
          "size": 3.509765625,
          "content": "#ifndef IDE_H\n#define IDE_H\n\n#include \"support/chd/mister_chd.h\"\n\n#define ATA_STATUS_BSY  0x80  // busy\n#define ATA_STATUS_RDY  0x40  // ready\n#define ATA_STATUS_RDP  0x20  // performance read\n#define ATA_STATUS_DSC  0x10  // seek complete\n#define ATA_STATUS_SERV 0x10  // service\n#define ATA_STATUS_DRQ  0x08  // data request\n#define ATA_STATUS_IRQ  0x04  // rise IRQ\n#define ATA_STATUS_END  0x02  // last read\n#define ATA_STATUS_ERR  0x01  // error (ATA)\n#define ATA_STATUS_CHK  0x01  // check (ATAPI)\n\n#define ATA_ERR_ICRC    0x80    // ATA Ultra DMA bad CRC\n#define ATA_ERR_BBK     0x80    // ATA bad block\n#define ATA_ERR_UNC     0x40    // ATA uncorrected error\n#define ATA_ERR_MC      0x20    // ATA media change\n#define ATA_ERR_IDNF    0x10    // ATA id not found\n#define ATA_ERR_MCR     0x08    // ATA media change request\n#define ATA_ERR_ABRT    0x04    // ATA command aborted\n#define ATA_ERR_NTK0    0x02    // ATA track 0 not found\n#define ATA_ERR_NDAM    0x01    // ATA address mark not found\n\n#define IDE_STATE_IDLE          0\n#define IDE_STATE_RESET         1\n#define IDE_STATE_INIT_RW       2\n#define IDE_STATE_WAIT_PKT_CMD  3\n#define IDE_STATE_WAIT_PKT_RD   4\n#define IDE_STATE_WAIT_PKT_END  5\n#define IDE_STATE_WAIT_PKT_MODE 6\n\nstruct regs_t\n{\n\tuint8_t io_done;\n\tuint8_t io_fast;\n\tuint8_t features;\n\tuint8_t sector_count;\n\tuint8_t sector;\n\tuint16_t cylinder;\n\tuint8_t head;\n\tuint8_t drv;\n\tuint8_t lba;\n\tuint8_t cmd;\n\n\tuint16_t pkt_size_limit;\n\tuint16_t pkt_io_size;\n\tuint32_t pkt_lba;\n\tuint32_t pkt_cnt;\n\n\tuint8_t io_size;\n\tuint8_t error;\n\tuint8_t status;\n};\n\nstruct track_t\n{\n\tfileTYPE f;\n\tchar     filename[1024];\n\tuint32_t start;\n\tuint32_t length;\n\tuint32_t skip;\n\tuint16_t sectorSize;\n\tuint8_t  attr;\n\tuint8_t  mode2;\n\tuint8_t  number;\n\tint      chd_offset;\n};\n\nstruct drive_t\n{\n\tfileTYPE *f;\n\n\tuint8_t  present;\n\tuint8_t  drvnum;\n\n\tuint16_t cylinders;\n\tuint16_t heads;\n\tuint16_t spt;\n\tuint32_t total_sectors;\n\tuint32_t spb;\n\n\tuint32_t offset;\n\tuint32_t type;\n\n\tuint8_t  placeholder;\n\tuint8_t  allow_placeholder;\n\tuint8_t  cd;\n\tuint8_t  load_state;\n\tuint8_t  last_load_state;\n\tuint8_t  track_cnt;\n\tuint8_t  data_num;\n\ttrack_t  track[50];\n\n\tuint8_t  playing;\n\tuint8_t  paused;\n\tuint32_t play_start_lba;\n\tuint32_t play_end_lba;\n\tfloat    volume_l;\n\tfloat    volume_r;\n\tbool     mcr_flag;\n\tuint8_t\t atapi_sense_key;\n\tuint8_t  atapi_asc_code;\n\tuint8_t  atapi_ascq_code;\n\n\tchd_file *chd_f;\n\tint      chd_hunknum;\n\tuint8_t\t *chd_hunkbuf;\n\tuint32_t  chd_total_size;\n\tuint32_t  chd_last_partial_lba;\n\n\tuint16_t id[256];\n};\n\nstruct ide_config\n{\n\tuint32_t base;\n\tuint32_t bitoff;\n\tuint32_t state;\n\tuint32_t null;\n\tuint32_t prepcnt;\n\tregs_t   regs;\n\n\tdrive_t drive[2];\n};\n\nstruct chs_t\n{\n\tuint32_t sectors;\n\tuint32_t heads;\n\tuint32_t cylinders;\n\tuint32_t offset;\n};\n\n#include \"ide_cdrom.h\"\n\nextern ide_config ide_inst[2];\nextern const uint32_t ide_io_max_size;\nextern uint8_t ide_buf[];\n\nvoid ide_print_regs(regs_t *regs);\nvoid ide_get_regs(ide_config *ide);\nvoid ide_set_regs(ide_config *ide);\n\nvoid ide_sendbuf(ide_config *ide, uint16_t reg, uint32_t length, uint16_t *data);\nvoid ide_recvbuf(ide_config *ide, uint16_t reg, uint32_t length, uint16_t *data);\nvoid ide_reg_set(ide_config *ide, uint16_t reg, uint16_t value);\n\nuint16_t ide_check();\nint ide_img_mount(fileTYPE *f, const char *name, int rw);\nvoid ide_img_set(uint32_t drvnum, fileTYPE *f, int cd, int sectors = 0, int heads = 0, int offset = 0, int type = 0);\nint ide_is_placeholder(int num);\nvoid ide_reset(uint8_t hotswap[4]);\nint ide_open(uint8_t unit, const char* filename);\n\nvoid ide_io(int num, int req);\n\n#endif\n"
        },
        {
          "name": "ide_cdrom.cpp",
          "type": "blob",
          "size": 42.4091796875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <time.h>\n#include <ios>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <sys/stat.h>\n#include <cmath>\n#include <libchdr/chd.h>\n#include <byteswap.h>\n#include \"spi.h\"\n#include \"user_io.h\"\n#include \"file_io.h\"\n#include \"hardware.h\"\n#include \"cd.h\"\n#include \"ide.h\"\n\n#if 0\n#define dbg_printf     printf\n#define dbg_print_regs ide_print_regs\n#define dbg_hexdump    hexdump\n#else\n#define dbg_printf(...)   void()\n#define dbg_print_regs    void\n#define dbg_hexdump(...)  void()\n#endif\n\n#define ide_send_data(databuf, size) ide_sendbuf(ide, 255, (size), (uint16_t*)(databuf))\n#define ide_recv_data(databuf, size) ide_recvbuf(ide, 255, (size), (uint16_t*)(databuf))\n#define ide_reset_buf() ide_reg_set(ide, 7, 0)\n\n#define BYTES_PER_RAW_REDBOOK_FRAME    2352\n#define BYTES_PER_COOKED_REDBOOK_FRAME 2048\n#define REDBOOK_FRAMES_PER_SECOND      75\n#define REDBOOK_FRAME_PADDING          150\n\n#define CD_FPS 75\n#define MSF_TO_FRAMES(M, S, F) ((M)*60*CD_FPS+(S)*CD_FPS+(F))\n\n#define CD_ERR_NO_DISK 2 \n#define CD_ERR_ILLEGAL_REQUEST 5 \n#define CD_ERR_UNIT_ATTENTION 6 \n\n#define CD_ASC_CODE_COMMAND_SEQUENCE_ERR 0x2C\n#define CD_ASC_CODE_ILLEGAL_OPCODE 0x20\n\n\ntypedef struct\n{\n\tunsigned char   min;\n\tunsigned char   sec;\n\tunsigned char   fr;\n} TMSF;\n\nstatic int check_magic(fileTYPE *file, int sectorSize, int mode2)\n{\n\t// Initialize our array in the event file->read() doesn't fully write it\n\tstatic uint8_t pvd[BYTES_PER_COOKED_REDBOOK_FRAME];\n\tmemset(pvd, 0, sizeof(pvd));\n\n\tuint32_t seek = 16 * sectorSize;  // first vd is located at sector 16\n\tif (sectorSize == BYTES_PER_RAW_REDBOOK_FRAME && !mode2) seek += 16;\n\tif (mode2) seek += 24;\n\tFileSeek(file, seek, SEEK_SET);\n\tif (!FileReadAdv(file, pvd, BYTES_PER_COOKED_REDBOOK_FRAME)) return 0;\n\n\t// pvd[0] = descriptor type, pvd[1..5] = standard identifier,\n\t// pvd[6] = iso version (+8 for High Sierra)\n\treturn ((pvd[0] == 1 && !strncmp((char*)(&pvd[1]), \"CD001\", 5) && pvd[6] == 1) ||\n\t\t(pvd[8] == 1 && !strncmp((char*)(&pvd[9]), \"CDROM\", 5) && pvd[14] == 1));\n}\n\nstatic int check_iso_file(fileTYPE *f, uint8_t *mode2, uint16_t *sectorSize)\n{\n\tif (check_magic(f, BYTES_PER_COOKED_REDBOOK_FRAME, false))\n\t{\n\t\tif (sectorSize) *sectorSize = BYTES_PER_COOKED_REDBOOK_FRAME;\n\t\tif (mode2) *mode2 = 0;\n\t\treturn 1;\n\t}\n\telse if (check_magic(f, BYTES_PER_RAW_REDBOOK_FRAME, false))\n\t{\n\t\tif (sectorSize) *sectorSize = BYTES_PER_RAW_REDBOOK_FRAME;\n\t\tif (mode2) *mode2 = 0;\n\t\treturn 1;\n\t}\n\telse if (check_magic(f, 2336, true))\n\t{\n\t\tif (sectorSize) *sectorSize = 2336;\n\t\tif (mode2) *mode2 = 1;\n\t\treturn 1;\n\t}\n\telse if (check_magic(f, BYTES_PER_RAW_REDBOOK_FRAME, true))\n\t{\n\t\tif (sectorSize) *sectorSize = BYTES_PER_RAW_REDBOOK_FRAME;\n\t\tif (mode2) *mode2 = 1;\n\t\treturn 1;\n\t}\n\n\tif (sectorSize) *sectorSize = 0;\n\tif (mode2) *mode2 = 0;\n\treturn 0;\n}\n\nstatic const char * load_iso_file(drive_t *drv, const char* filename)\n{\n\tfileTYPE f;\n\tmemset(drv->track, 0, sizeof(drv->track));\n\tdrv->track_cnt = 0;\n\n\tstrcpy(drv->track[0].filename, filename);\n\tif (!FileOpen(&f, filename))\n\t{\n\t\tprintf(\"Cannot open ISO file!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!check_iso_file(&f, &drv->track[0].mode2, &drv->track[0].sectorSize))\n\t{\n\t\tprintf(\"Fail to parse ISO!\\n\");\n\t\tFileClose(&f);\n\t\treturn 0;\n\t}\n\n\tdrv->track[0].attr = 0x40; //data track\n\tdrv->track[0].length = f.size / drv->track[0].sectorSize;\n\tdrv->track[0].number = 1;\n\n\tFileClose(&f);\n\n\t// lead-out track (track 2)\n\tdrv->track[1].start = drv->track[0].length;\n\tdrv->track[2].number = 2;\n\n\tprintf(\"ISO: mode2 = %d, sectorSize = %d, sectors = %d\\n\", drv->track[0].mode2, drv->track[0].sectorSize, drv->track[0].length);\n\tdrv->track_cnt = 2;\n\n\tdrv->data_num = 0;\n\tif (!FileOpen(&drv->track[0].f, drv->track[0].filename))\n\t{\n\t\tprintf(\"Cannot open ISO file! (First track)\\n\");\n\t\treturn 0;\n\t}\n\treturn drv->track[0].filename;\n}\n\nstatic int get_word(std::string &keyword, std::istream &in)\n{\n\tin >> keyword;\n\tfor (uint32_t i = 0; i < keyword.size(); i++) keyword[i] = (char)toupper(keyword[i]);\n\treturn keyword.size();\n}\n\nstatic int get_timecode(uint32_t &frames, std::istream &in)\n{\n\tstd::string msf;\n\tin >> msf;\n\tTMSF tmp = { 0, 0, 0 };\n\tint success = sscanf(msf.c_str(), \"%hhu:%hhu:%hhu\", &tmp.min, &tmp.sec, &tmp.fr) == 3;\n\tframes = (int)MSF_TO_FRAMES(tmp.min, tmp.sec, tmp.fr);\n\treturn success;\n}\n\nstatic track_t *get_track_from_lba(drive_t *drive, uint32_t lba, bool &index0)\n{\n\ttrack_t *ret = NULL;\n\tindex0 = false;\n\tfor (int i = 0; i < drive->track_cnt; i++)\n\t{\n\t\tuint32_t start_lba = i ? drive->track[i-1].start + drive->track[i-1].length : 0;\n\t\tuint32_t end_lba = drive->track[i].start + drive->track[i].length;\n\n\t\tif (lba >= start_lba && lba <= end_lba)\n\t\t{\n\t\t\tret = &drive->track[i];\n\t\t\t//In the \"pregap\" section\n\t\t\tif (lba < drive->track[i].start) index0 = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int add_track(drive_t *drv, track_t *curr, uint32_t &shift, const int32_t prestart, uint32_t &totalPregap, uint32_t currPregap)\n{\n\tuint32_t skip = 0;\n\tif (drv->track_cnt >= sizeof(drv->track) / sizeof(drv->track[0]))\n\t{\n\t\tprintf(\"CDROM: too many tracks(%d)\\n\", drv->track_cnt);\n\t\treturn 0;\n\t}\n\n\t// frames between index 0(prestart) and 1(curr.start) must be skipped\n\tif (prestart >= 0)\n\t{\n\t\tif (prestart > static_cast<int>(curr->start))\n\t\t{\n\t\t\tprintf(\"CDROM: add_track => prestart %d cannot be > curr.start %u\\n\", prestart, curr->start);\n\t\t\treturn 0;\n\t\t}\n\t\tskip = static_cast<uint32_t>(static_cast<int>(curr->start) - prestart);\n\t}\n\n\t// Add the first track, if our vector is empty\n\tif (!drv->track_cnt)\n\t{\n\t\t//assertm(curr.number == 1, \"The first track must be labelled number 1 [BUG!]\");\n\t\tcurr->skip = skip * curr->sectorSize;\n\t\tcurr->start += currPregap;\n\t\ttotalPregap = currPregap;\n\n\t\tmemcpy(&drv->track[drv->track_cnt], curr, sizeof(track_t));\n\t\tFileOpenEx(&drv->track[drv->track_cnt].f, curr->filename, O_RDONLY);\n\t\tdrv->track_cnt++;\n\t\treturn 1;\n\t}\n\n\t// Guard against undefined behavior in subsequent tracks.back() call\n\t//assert(!tracks.empty());\n\ttrack_t *prev = &drv->track[drv->track_cnt - 1];\n\n\t// current track consumes data from the same file as the previous\n\tif (!strcmp(prev->filename, curr->filename))\n\t{\n\t\tcurr->start += shift;\n\t\tif (!prev->length)\n\t\t{\n\t\t\tprev->length = curr->start + totalPregap - prev->start - skip;\n\t\t}\n\t\tcurr->skip += prev->skip + prev->length * prev->sectorSize + skip * curr->sectorSize;\n\t\ttotalPregap += currPregap;\n\t\tcurr->start += totalPregap;\n\t\t// current track uses a different file as the previous track\n\t}\n\telse\n\t{\n\t\tuint32_t size = FileLoad(prev->filename, 0, 0);\n\t\tconst uint32_t tmp = size - prev->skip;\n\t\tprev->length = tmp / prev->sectorSize;\n\n\t\tif (tmp % prev->sectorSize != 0) prev->length++; // padding\n\n\t\tcurr->start += prev->start + prev->length + currPregap;\n\t\tcurr->skip = skip * curr->sectorSize;\n\t\tshift += prev->start + prev->length;\n\t\ttotalPregap = currPregap;\n\t}\n\n\t// error checks\n\tif (curr->number <= 1\n\t\t|| prev->number + 1 != curr->number\n\t\t|| curr->start < prev->start + prev->length) {\n\t\tprintf(\"add_track: failed consistency checks\\n\"\n\t\t\t\"\\tcurr.number (%d) <= 1\\n\"\n\t\t\t\"\\tprev.number (%d) + 1 != curr.number (%d)\\n\"\n\t\t\t\"\\tcurr.start (%d) < prev.start (%d) + prev.length (%d)\\n\",\n\t\t\tcurr->number, prev->number, curr->number,\n\t\t\tcurr->start, prev->start, prev->length);\n\t\treturn 0;\n\t}\n\n\tmemcpy(&drv->track[drv->track_cnt], curr, sizeof(track_t));\n\tFileOpenEx(&drv->track[drv->track_cnt].f, drv->track[drv->track_cnt].filename, O_RDONLY);\n\tdrv->track_cnt++;\n\treturn 1;\n}\n\nstatic const char* load_chd_file(drive_t *drv, const char *chdfile)\n{\n\n\t//Borrow the cd.h \"toc_t\" and mister_chd* parse function. Then translate the toc_t to drive_t+track_t.\n\t//TODO: abstract all the bin/cue+chd+iso parsing and reading into a shared class\n\t//\n\n\tconst char *ext = chdfile + strlen(chdfile) - 4;\n\tuint32_t total_sector_size = 0;\n\n\n\tif (strncasecmp(\".chd\", ext, 4))\n\t{\n\t\t//Not a CHD\n\t\treturn 0;\n\t}\n\ttoc_t tmpTOC = { };\n\tmemset(drv->track, 0, sizeof(drv->track));\n\tdrv->track_cnt = 0;\n\tchd_error err = mister_load_chd(chdfile, &tmpTOC);\n\tif (err != CHDERR_NONE)\n\t{\n\t\treturn 0;\n\t}\n\n\tif (drv->chd_hunkbuf)\n\t{\n\t\tfree(drv->chd_hunkbuf);\n\t}\n\n\tdrv->chd_hunkbuf = (uint8_t *)malloc(tmpTOC.chd_hunksize);\n\tdrv->chd_hunknum = -1;\n\tdrv->chd_f = tmpTOC.chd_f;\n\n\t//don't use add_track, just do it ourselves...\n\tfor (int i = 0; i < tmpTOC.last; i++)\n\t{\n\t\tcd_track_t *chd_track = &tmpTOC.tracks[i];\n\t\ttrack_t *trk = &drv->track[i];\n\t\ttrk->number = i + 1;\n\t\ttrk->sectorSize = chd_track->sector_size;\n\t\tif (chd_track->type)\n\t\t{\n\t\t\ttrk->attr = 0x40;\n\t\t\tif (chd_track->type == 2)\n\t\t\t{\n\t\t\t\ttrk->mode2 = true;\n\t\t\t}\n\n\t\t}\n\n\t\ttrk->chd_offset = chd_track->offset;\n\t\ttrk->start = chd_track->start;\n\t\ttrk->length = chd_track->end - chd_track->start;\n\t\tdrv->track_cnt++;\n\t\ttotal_sector_size += trk->length * trk->sectorSize;\n\t}\n\n\t//Add the lead-out track\n\n\ttrack_t *lead_out = &drv->track[drv->track_cnt];\n\tlead_out->number = drv->track_cnt + 1;\n\tlead_out->attr = 0;\n\tlead_out->start = tmpTOC.tracks[tmpTOC.last - 1].end;\n\tlead_out->length = 0;\n\tdrv->track_cnt++;\n\n\tdrv->total_sectors = total_sector_size / 512;\n\tdrv->chd_total_size = total_sector_size;\n\n\tfor (uint8_t i = 0; i < drv->track_cnt; i++)\n\t{\n\t\tif (drv->track[i].attr == 0x40)\n\t\t{\n\t\t\tdrv->data_num = i;\n\t\t}\n\t}\n\n\treturn chdfile;\n}\n\n\nstatic const char* load_cue_file(drive_t *drv, const char *cuefile)\n{\n\tmemset(drv->track, 0, sizeof(drv->track));\n\tdrv->track_cnt = 0;\n\n\ttrack_t track = {};\n\tuint32_t shift = 0;\n\tuint32_t currPregap = 0;\n\tuint32_t totalPregap = 0;\n\tint32_t prestart = -1;\n\tint track_number;\n\tint success;\n\tint canAddTrack = 0;\n\n\tstd::string pathname(cuefile);\n\tstd::size_t found = pathname.find_last_of('/');\n\tif (found == std::string::npos) return 0; // no folder name?\n\tpathname.resize(found + 1);\n\n\tstd::ifstream in;\n\tin.open(cuefile, std::ios::in);\n\tif (in.fail()) return 0;\n\n\twhile (!in.eof())\n\t{\n\t\t// get next line\n\t\tstd::string buf;\n\t\tstd::getline(in, buf);\n\n\t\tif (in.fail() && !in.eof()) return 0;  // probably a binary file\n\n\t\tstd::istringstream line(buf);\n\n\t\tstd::string command;\n\t\tget_word(command, line);\n\n\t\t//printf(\"command: %s\\n\", command.c_str());\n\n\t\tif (command == \"TRACK\")\n\t\t{\n\t\t\tif (canAddTrack) success = add_track(drv, &track, shift, prestart, totalPregap, currPregap);\n\t\t\telse success = 1;\n\n\t\t\ttrack.start = 0;\n\t\t\ttrack.skip = 0;\n\t\t\tcurrPregap = 0;\n\t\t\tprestart = -1;\n\n\t\t\tline >> track_number; // (cin) read into a true int first\n\n\t\t\ttrack.number = static_cast<uint8_t>(track_number);\n\n\t\t\tstd::string type;\n\t\t\tget_word(type, line);\n\n\t\t\t//printf(\"  type: %s\\n\", type.c_str());\n\n\t\t\tif (type == \"AUDIO\")\n\t\t\t{\n\t\t\t\ttrack.sectorSize = BYTES_PER_RAW_REDBOOK_FRAME;\n\t\t\t\ttrack.attr = 0;\n\t\t\t\ttrack.mode2 = false;\n\t\t\t}\n\t\t\telse if (type == \"MODE1/2048\")\n\t\t\t{\n\t\t\t\ttrack.sectorSize = BYTES_PER_COOKED_REDBOOK_FRAME;\n\t\t\t\ttrack.attr = 0x40;\n\t\t\t\ttrack.mode2 = false;\n\t\t\t}\n\t\t\telse if (type == \"MODE1/2352\")\n\t\t\t{\n\t\t\t\ttrack.sectorSize = BYTES_PER_RAW_REDBOOK_FRAME;\n\t\t\t\ttrack.attr = 0x40;\n\t\t\t\ttrack.mode2 = false;\n\t\t\t}\n\t\t\telse if (type == \"MODE2/2336\")\n\t\t\t{\n\t\t\t\ttrack.sectorSize = 2336;\n\t\t\t\ttrack.attr = 0x40;\n\t\t\t\ttrack.mode2 = true;\n\t\t\t}\n\t\t\telse if (type == \"MODE2/2352\")\n\t\t\t{\n\t\t\t\ttrack.sectorSize = BYTES_PER_RAW_REDBOOK_FRAME;\n\t\t\t\ttrack.attr = 0x40;\n\t\t\t\ttrack.mode2 = true;\n\t\t\t}\n\t\t\telse success = 0;\n\n\t\t\tcanAddTrack = 1;\n\t\t}\n\t\telse if (command == \"INDEX\")\n\t\t{\n\t\t\tint index;\n\t\t\tline >> index;\n\t\t\tuint32_t frame;\n\t\t\tsuccess = get_timecode(frame, line);\n\n\t\t\tif (index == 1) track.start = frame;\n\t\t\telse if (index == 0) prestart = static_cast<int32_t>(frame);\n\t\t\t// ignore other indices\n\t\t}\n\t\telse if (command == \"FILE\")\n\t\t{\n\t\t\tif (canAddTrack) success = add_track(drv, &track, shift, prestart, totalPregap, currPregap);\n\t\t\telse success = 1;\n\t\t\tcanAddTrack = 0;\n\n\t\t\tstd::string filename;\n\t\t\tstd::getline(std::getline(line, filename, '\"'), filename, '\"');\n\n\t\t\tstrcpy(track.filename, pathname.c_str());\n\t\t\tstrcat(track.filename, filename.c_str());\n\n\t\t\tprintf(\"cue: got new file name: %s\\n\", track.filename);\n\t\t}\n\t\telse if (command == \"PREGAP\") success = get_timecode(currPregap, line);\n\t\t// ignored commands\n\t\telse if (command == \"CATALOG\" || command == \"CDTEXTFILE\" || command == \"FLAGS\" || command == \"ISRC\" ||\n\t\t\tcommand == \"PERFORMER\" || command == \"POSTGAP\" || command == \"REM\" ||\n\t\t\tcommand == \"SONGWRITER\" || command == \"TITLE\" || command.empty())\n\t\t{\n\t\t\tsuccess = 1;\n\t\t}\n\t\t// failure\n\t\telse\n\t\t{\n\t\t\tsuccess = 0;\n\t\t}\n\n\t\tif (!success)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// add last track\n\tif (!add_track(drv, &track, shift, prestart, totalPregap, currPregap))\n\t{\n\t\treturn 0;\n\t}\n\n\t// add lead-out track\n\ttrack.number++;\n\ttrack.filename[0] = 0;\n\ttrack.attr = 0;//sync with load iso\n\ttrack.start = drv->track[track.number - 1].start + drv->track[track.number - 1].length;\n\ttrack.length = 0;\n\n\tif (!add_track(drv, &track, shift, -1, totalPregap, 0))\n\t{\n\t\treturn 0;\n\t}\n\n\tfor (uint8_t i = 0; i < drv->track_cnt; i++)\n\t{\n\t\tif (drv->track[i].attr == 0x40)\n\t\t{\n\t\t\tdrv->data_num = i;\n\t\t\treturn drv->track[i].filename;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\ninline TMSF frames_to_msf(uint32_t frames)\n{\n\tTMSF msf = { 0, 0, 0 };\n\tmsf.fr = frames % REDBOOK_FRAMES_PER_SECOND;\n\tframes /= REDBOOK_FRAMES_PER_SECOND;\n\tmsf.sec = frames % 60;\n\tframes /= 60;\n\tmsf.min = static_cast<uint8_t>(frames);\n\treturn msf;\n}\n\nstatic int get_tracks(drive_t *drv, int& start_track_num, int& end_track_num, TMSF& lead_out_msf)\n{\n\tif (drv->track_cnt < 2 || !drv->track[0].length) return 0;\n\n\tstart_track_num = drv->track[0].number;\n\tend_track_num = drv->track[drv->track_cnt - 2].number;\n\tlead_out_msf = frames_to_msf(drv->track[drv->track_cnt - 1].start + REDBOOK_FRAME_PADDING);\n\treturn 1;\n}\n\nstatic int get_track_info(drive_t *drv, int requested_track_num, TMSF& start_msf, unsigned char& attr)\n{\n\tif (drv->track_cnt < 2 || requested_track_num < 1 || requested_track_num >= drv->track_cnt)\n\t{\n\t\treturn 0;\n\t}\n\n\tstart_msf = frames_to_msf(drv->track[requested_track_num - 1].start + REDBOOK_FRAME_PADDING);\n\tattr = drv->track[requested_track_num - 1].attr;\n\treturn 1;\n}\n\nstatic int read_toc(drive_t *drv, uint8_t *cmdbuf)\n{\n\t/* NTS: The SCSI MMC standards say we're allowed to indicate the return data\n\t *      is longer than it's allocation length. But here's the thing: some MS-DOS\n\t *      CD-ROM drivers will ask for the TOC but only provide enough room for one\n\t *      entry (OAKCDROM.SYS) and if we signal more data than it's buffer, it will\n\t *      reject our response and render the CD-ROM drive inaccessible. So to make\n\t *      this emulation work, we have to cut our response short to the driver's\n\t *      allocation length */\n\tunsigned int AllocationLength = ((unsigned int)cmdbuf[7] << 8) + cmdbuf[8];\n\tunsigned char Format = cmdbuf[2] & 0xF;\n\tunsigned char Track = cmdbuf[6];\n\tbool TIME = !!(cmdbuf[1] & 2);\n\tunsigned char *write;\n\tint first, last, track;\n\tTMSF leadOut;\n\n\tprintf(\"read_toc in:\\n\");\n\thexdump(cmdbuf, 12);\n\n\tmemset(ide_buf, 0, 8);\n\n\tif (!get_tracks(drv, first, last, leadOut))\n\t{\n\t\tprintf(\"WARNING: ATAPI READ TOC failed to get track info\\n\");\n\t\treturn 8;\n\t}\n\n\t/* start 2 bytes out. we'll fill in the data length later */\n\twrite = ide_buf + 2;\n\n\tif (Format == 1) /* Read multisession info */\n\t{\n\t\tunsigned char attr;\n\t\tTMSF start;\n\n\t\t*write++ = (unsigned char)1;        /* @+2 first complete session */\n\t\t*write++ = (unsigned char)1;        /* @+3 last complete session */\n\n\t\tif (!get_track_info(drv, first, start, attr))\n\t\t{\n\t\t\tprintf(\"WARNING: ATAPI READ TOC unable to read track %u information\\n\", first);\n\t\t\tattr = 0x41; /* ADR=1 CONTROL=4 */\n\t\t\tstart.min = 0;\n\t\t\tstart.sec = 0;\n\t\t\tstart.fr = 0;\n\t\t}\n\n\t\tprintf(\"Track %u attr=0x%02x %02u:%02u:%02u\\n\", first, attr, start.min, start.sec, start.fr);\n\n\t\t*write++ = 0x00;        /* entry+0 RESERVED */\n\t\t*write++ = (attr >> 4) | 0x10;  /* entry+1 ADR=1 CONTROL=4 (DATA) */\n\t\t*write++ = (unsigned char)first;/* entry+2 TRACK */\n\t\t*write++ = 0x00;        /* entry+3 RESERVED */\n\n\t\t/* then, start address of first track in session */\n\t\tif (TIME)\n\t\t{\n\t\t\t*write++ = 0x00;\n\t\t\t*write++ = start.min;\n\t\t\t*write++ = start.sec;\n\t\t\t*write++ = start.fr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint32_t sec = (start.min * 60u * 75u) + (start.sec * 75u) + start.fr - 150u;\n\t\t\t*write++ = (unsigned char)(sec >> 24u);\n\t\t\t*write++ = (unsigned char)(sec >> 16u);\n\t\t\t*write++ = (unsigned char)(sec >> 8u);\n\t\t\t*write++ = (unsigned char)(sec >> 0u);\n\t\t}\n\t}\n\telse if (Format == 0) /* Read table of contents */\n\t{\n\t\t*write++ = (unsigned char)first;    /* @+2 */\n\t\t*write++ = (unsigned char)last;     /* @+3 */\n\n\t\tfor (track = first; track <= last; track++)\n\t\t{\n\t\t\tunsigned char attr;\n\t\t\tTMSF start;\n\n\t\t\tif (!get_track_info(drv, track, start, attr))\n\t\t\t{\n\t\t\t\tprintf(\"WARNING: ATAPI READ TOC unable to read track %u information\\n\", track);\n\t\t\t\tattr = 0x41; /* ADR=1 CONTROL=4 */\n\t\t\t\tstart.min = 0;\n\t\t\t\tstart.sec = 0;\n\t\t\t\tstart.fr = 0;\n\t\t\t}\n\n\t\t\tif (track < Track) continue;\n\t\t\tif ((write + 8) > (ide_buf + AllocationLength)) break;\n\n\t\t\tprintf(\"Track %u attr=0x%02x %02u:%02u:%02u\\n\", track, attr, start.min, start.sec, start.fr);\n\n\t\t\t*write++ = 0x00;        /* entry+0 RESERVED */\n\t\t\t*write++ = (attr >> 4) | 0x10; /* entry+1 ADR=1 CONTROL=4 (DATA) */\n\t\t\t*write++ = (unsigned char)track;/* entry+2 TRACK */\n\t\t\t*write++ = 0x00;        /* entry+3 RESERVED */\n\t\t\tif (TIME)\n\t\t\t{\n\t\t\t\t*write++ = 0x00;\n\t\t\t\t*write++ = start.min;\n\t\t\t\t*write++ = start.sec;\n\t\t\t\t*write++ = start.fr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32_t sec = (start.min * 60u * 75u) + (start.sec * 75u) + start.fr - 150u;\n\t\t\t\t*write++ = (unsigned char)(sec >> 24u);\n\t\t\t\t*write++ = (unsigned char)(sec >> 16u);\n\t\t\t\t*write++ = (unsigned char)(sec >> 8u);\n\t\t\t\t*write++ = (unsigned char)(sec >> 0u);\n\t\t\t}\n\t\t}\n\n\t\tif ((write + 8) <= (ide_buf + AllocationLength))\n\t\t{\n\t\t\t*write++ = 0x00;\n\t\t\t*write++ = 0x14;\n\t\t\t*write++ = 0xAA;/*TRACK*/\n\t\t\t*write++ = 0x00;\n\t\t\tif (TIME)\n\t\t\t{\n\t\t\t\t*write++ = 0x00;\n\t\t\t\t*write++ = leadOut.min;\n\t\t\t\t*write++ = leadOut.sec;\n\t\t\t\t*write++ = leadOut.fr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32_t sec = (leadOut.min * 60u * 75u) + (leadOut.sec * 75u) + leadOut.fr - 150u;\n\t\t\t\t*write++ = (unsigned char)(sec >> 24u);\n\t\t\t\t*write++ = (unsigned char)(sec >> 16u);\n\t\t\t\t*write++ = (unsigned char)(sec >> 8u);\n\t\t\t\t*write++ = (unsigned char)(sec >> 0u);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"WARNING: ATAPI READ TOC Format=%u not supported\\n\", Format);\n\t\treturn 8;\n\t}\n\n\t/* update the TOC data length field */\n\tunsigned int x = (unsigned int)(write - ide_buf) - 2;\n\tide_buf[0] = x >> 8;\n\tide_buf[1] = x & 0xFF;\n\n\tprintf(\"read_toc result:\\n\");\n\thexdump(ide_buf, write - ide_buf);\n\n\treturn write - ide_buf;\n}\n\nvoid cdrom_mode_select(ide_config *ide)\n{\n\n\tuint8_t *mode_page = &ide_buf[8];\n\tdrive_t *drv = &ide->drive[ide->regs.drv];\n\tuint8_t page_code = mode_page[0] & 0x3F;\n\n\tswitch (page_code) {\n\tcase 0x0E:\n\t{\n\t\tuint8_t p0vol = mode_page[9];\n\t\tuint8_t p1vol = mode_page[11];\n\t\t//in gain factor\n\t\tdrv->volume_l = (p0vol + 1) / 256.0f;\n\t\tdrv->volume_r = (p1vol + 1) / 256.0f;\n\t}\n\tbreak;\n\t}\n}\n\nstatic uint16_t mode_sense(drive_t *drv, int page)\n{\n\tuint8_t *write = ide_buf;\n\tuint8_t *plen;\n\n\tuint32_t x;\n\n\tint valid = 0;\n\n\tprintf(\"mode_sense page: %X\\n\", page);\n\n\t/* Mode Parameter List MMC-3 Table 340 */\n\t/* - Mode parameter header */\n\t/* - Page(s) */\n\n\t/* Mode Parameter Header (response for 10-byte MODE SENSE) SPC-2 Table 148 */\n\t*write++ = 0x00;    /* MODE DATA LENGTH                     (MSB) */\n\t*write++ = 0x00;    /*                                      (LSB) */\n\t*write++ = 0x00;    /* MEDIUM TYPE */\n\t*write++ = 0x00;    /* DEVICE-SPECIFIC PARAMETER */\n\t*write++ = 0x00;    /* Reserved */\n\t*write++ = 0x00;    /* Reserved */\n\t*write++ = 0x00;    /* BLOCK DESCRIPTOR LENGTH              (MSB) */\n\t*write++ = 0x00;    /*                                      (LSB) */\n\t/* NTS: MMC-3 Table 342 says that BLOCK DESCRIPTOR LENGTH is zero, where it would be 8 for legacy units */\n\n\t/* Mode Page Format MMC-3 Table 341 */\n\tif (page == 0x01 || page == 0x3F)\n\t{\n\t\tvalid = 1;\n\t\t*write++ = 1;       /* PS|reserved|Page Code */\n\t\tplen = write;\n\t\t*write++ = 0x00;    /* Page Length (n - 1) ... Length in bytes of the mode parameters that follow */\n\n\t\t*write++ = 0x00;    /* +2 Error recovery Parameter  AWRE|ARRE|TB|RC|Reserved|PER|DTE|DCR */\n\t\t*write++ = 3;       /* +3 Read Retry Count */\n\t\t*write++ = 0x00;    /* +4 Reserved */\n\t\t*write++ = 0x00;    /* +5 Reserved */\n\t\t*write++ = 0x00;    /* +6 Reserved */\n\t\t*write++ = 0x00;    /* +7 Reserved */\n\n\t\t*plen = write - plen - 1;\n\t}\n\n\t/* CD-ROM audio control MMC-3 Section 6.3.7 table 354 */\n\t/* also MMC-1 Section 5.2.3.1 table 97 */\n\tif (page == 0x0E || page == 0x3F)\n\t{\n\t\tvalid = 1;\n\t\t*write++ = 0x0E;    /* PS|reserved|Page Code */\n\t\tplen = write;\n\t\t*write++ = 0x00;    /* Page Length (n - 1) ... Length in bytes of the mode parameters that follow */\n\n\t\t*write++ = 0x04;    /* +2 Reserved|IMMED=1|SOTC=0|Reserved */\n\t\t*write++ = 0x00;    /* +3 Reserved */\n\t\t*write++ = 0x00;    /* +4 Reserved */\n\t\t*write++ = 0x00;    /* +5 Reserved */\n\t\t*write++ = 0x00;    /* +6 Obsolete (75) */\n\t\t*write++ = 75;      /* +7 Obsolete (75) */\n\t\t*write++ = 0x01;    /* +8 output port 0 selection (0001b = channel 0) */\n\t\t*write++ = (uint8_t)((drv->volume_l * 256) - 1);    /* +9 output port 0 volume (0xFF = 0dB atten.) */\n\t\t*write++ = 0x02;    /* +10 output port 1 selection (0010b = channel 1) */\n\t\t*write++ = (uint8_t)((drv->volume_l * 256) - 1);    /* +11 output port 1 volume (0xFF = 0dB atten.) */\n\t\t*write++ = 0x00;    /* +12 output port 2 selection (none) */\n\t\t*write++ = 0x00;    /* +13 output port 2 volume (0x00 = mute) */\n\t\t*write++ = 0x00;    /* +14 output port 3 selection (none) */\n\t\t*write++ = 0x00;    /* +15 output port 3 volume (0x00 = mute) */\n\n\t\t*plen = write - plen - 1;\n\t}\n\n\t/* CD-ROM mechanical status MMC-3 Section 6.3.11 table 361 */\n\tif (page == 0x2A || page == 0x3F)\n\t{\n\t\tvalid = 1;\n\t\t*write++ = 0x2A;    /* PS|reserved|Page Code */\n\t\tplen = write;\n\t\t*write++ = 0x00;    /* Page Length (n - 1) ... Length in bytes of the mode parameters that follow */\n\n\t\t\t\t\t\t\t/*    MSB            |             |             |             |              |               |              |       LSB */\n\t\t*write++ = 0x07;    /* +2 Reserved       |Reserved     |DVD-RAM read |DVD-R read   |DVD-ROM read  |   Method 2    | CD-RW read   | CD-R read */\n\t\t*write++ = 0x00;    /* +3 Reserved       |Reserved     |DVD-RAM write|DVD-R write  |   Reserved   |  Test Write   | CD-RW write  | CD-R write */\n\t\t*write++ = 0x71;    /* +4 Buffer Underrun|Multisession |Mode 2 form 2|Mode 2 form 1|Digital Port 2|Digital Port 1 |  Composite   | Audio play */\n\t\t*write++ = 0xFF;    /* +5 Read code bar  |UPC          |ISRC         |C2 Pointers  |R-W deintcorr | R-W supported |CDDA accurate |CDDA support */\n\t\t*write++ = 0x2F;    /* +6 Loading mechanism type                     |Reserved     |Eject         |Prevent Jumper |Lock state    |Lock */\n\t\t\t\t\t\t\t/*      0 (0x00) = Caddy\n\t\t\t\t\t\t\t *      1 (0x20) = Tray\n\t\t\t\t\t\t\t *      2 (0x40) = Popup\n\t\t\t\t\t\t\t *      3 (0x60) = Reserved\n\t\t\t\t\t\t\t *      4 (0x80) = Changer with indivually changeable discs\n\t\t\t\t\t\t\t *      5 (0xA0) = Changer using a magazine mechanism\n\t\t\t\t\t\t\t *      6 (0xC0) = Reserved\n\t\t\t\t\t\t\t *      6 (0xE0) = Reserved */\n\t\t*write++ = 0x03;    /* +7 Reserved       |Reserved     |R-W in leadin|Side chg cap |S/W slot sel  |Changer disc pr|Sep. ch. mute |Sep. volume levels */\n\n\t\tx = 176 * 8;        /* +8 maximum speed supported in kB: 8X  (obsolete in MMC-3) */\n\t\t*write++ = x >> 8;\n\t\t*write++ = x;\n\n\t\tx = 256;            /* +10 Number of volume levels supported */\n\t\t*write++ = x >> 8;\n\t\t*write++ = x;\n\n\t\tx = 6 * 256;        /* +12 buffer size supported by drive in kB */\n\t\t*write++ = x >> 8;\n\t\t*write++ = x;\n\n\t\tx = 176 * 8;        /* +14 current read speed selected in kB: 8X  (obsolete in MMC-3) */\n\t\t*write++ = x >> 8;\n\t\t*write++ = x;\n\n\t\t*plen = write - plen - 1;\n\t}\n\n\tif (!valid)\n\t{\n\t\t*write++ = page;    /* PS|reserved|Page Code */\n\t\t*write++ = 0x06;    /* Page Length (n - 1) ... Length in bytes of the mode parameters that follow */\n\n\t\tmemset(write, 0, 6); write += 6;\n\t\tprintf(\"WARNING: MODE SENSE on page 0x%02x not supported\\n\", page);\n\t}\n\n\t/* mode param header, data length */\n\tx = (uint32_t)(write - ide_buf) - 2;\n\tide_buf[0] = (unsigned char)(x >> 8u);\n\tide_buf[1] = (unsigned char)x;\n\n\thexdump(ide_buf, x + 2);\n\treturn x + 2;\n}\n\nstatic int get_subchan(drive_t *drv, unsigned char& attr, unsigned char& track_num, unsigned char& index, TMSF& relative_msf, TMSF& absolute_msf)\n{\n\tattr = 0;\n\ttrack_num = 1;\n\tindex = 1;\n\trelative_msf.min = relative_msf.fr = 0; relative_msf.sec = 2;\n\tabsolute_msf.min = absolute_msf.fr = 0; absolute_msf.sec = 2;\n\n\tif (drv->play_start_lba == 0xFFFFFFFF) return 0;\n\n\t//TODO: use current play position when audio playback will be implemented\n\tuint32_t cur_pos = drv->play_start_lba;\n\tbool is_index0;\n\ttrack_t *cur_track = NULL;\n\tcur_track = get_track_from_lba(drv, cur_pos, is_index0);\n\n\tif (cur_track)\n\t{\n\t\ttrack_num = cur_track->number;\n\t\tattr = cur_track->attr;\n\t\tabsolute_msf = frames_to_msf(cur_pos + REDBOOK_FRAME_PADDING);\n\t\tint relative_diff = cur_pos - cur_track->start;\n\n\t\trelative_msf = frames_to_msf(abs(relative_diff));\n\t\tindex = is_index0 ? 0 : 1;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_subchannel(drive_t *drv, uint8_t* cmdbuf)\n{\n\tunsigned char paramList = cmdbuf[3];\n\tunsigned char attr, track, index;\n\tbool SUBQ = !!(cmdbuf[2] & 0x40);\n\tbool TIME = !!(cmdbuf[1] & 2);\n\tunsigned char *write;\n\tTMSF rel, abs;\n\n\tif (paramList == 0 || paramList > 3)\n\t{\n\t\tprintf(\"ATAPI READ SUBCHANNEL unknown param list\\n\");\n\t\tmemset(ide_buf, 0, 8);\n\t\treturn 8;\n\t}\n\telse if (paramList == 2)\n\t{\n\t\tprintf(\"ATAPI READ SUBCHANNEL Media Catalog Number not supported\\n\");\n\t\tmemset(ide_buf, 0, 8);\n\t\treturn 8;\n\t}\n\telse if (paramList == 3) {\n\t\tprintf(\"ATAPI READ SUBCHANNEL ISRC not supported\\n\");\n\t\tmemset(ide_buf, 0, 8);\n\t\treturn 8;\n\t}\n\n\t/* get current subchannel position */\n\tif (!get_subchan(drv, attr, track, index, rel, abs))\n\t{\n\t\tprintf(\"ATAPI READ SUBCHANNEL unable to read current pos\\n\");\n\t\tmemset(ide_buf, 0, 8);\n\t\treturn 8;\n\t}\n\n\tmemset(ide_buf, 0, 8);\n\twrite = ide_buf;\n\t*write++ = 0x00;\n\t*write++ = (!drv->playing) ? 0x13 : drv->paused ? 0x12 : 0x11; /* AUDIO STATUS */\n\t*write++ = 0x00;  /* SUBCHANNEL DATA LENGTH */\n\t*write++ = 0x00;\n\n\tif (SUBQ)\n\t{\n\t\t*write++ = 0x01;    /* subchannel data format code */\n\t\t*write++ = (attr >> 4) | 0x10;  /* ADR/CONTROL */\n\t\t*write++ = track;\n\t\t*write++ = index;\n\t\tif (TIME)\n\t\t{\n\t\t\t*write++ = 0x00;\n\t\t\t*write++ = abs.min;\n\t\t\t*write++ = abs.sec;\n\t\t\t*write++ = abs.fr;\n\t\t\t*write++ = 0x00;\n\t\t\t*write++ = rel.min;\n\t\t\t*write++ = rel.sec;\n\t\t\t*write++ = rel.fr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint32_t sec;\n\n\t\t\tsec = (abs.min * 60u * 75u) + (abs.sec * 75u) + abs.fr - 150u;\n\t\t\t*write++ = (unsigned char)(sec >> 24u);\n\t\t\t*write++ = (unsigned char)(sec >> 16u);\n\t\t\t*write++ = (unsigned char)(sec >> 8u);\n\t\t\t*write++ = (unsigned char)(sec >> 0u);\n\n\t\t\tsec = (rel.min * 60u * 75u) + (rel.sec * 75u) + rel.fr - 150u;\n\t\t\t*write++ = (unsigned char)(sec >> 24u);\n\t\t\t*write++ = (unsigned char)(sec >> 16u);\n\t\t\t*write++ = (unsigned char)(sec >> 8u);\n\t\t\t*write++ = (unsigned char)(sec >> 0u);\n\t\t}\n\t}\n\n\tunsigned int x = (unsigned int)(write - ide_buf) - 4;\n\tide_buf[2] = x >> 8;\n\tide_buf[3] = x;\n\n\tdbg_hexdump(ide_buf, write - ide_buf);\n\treturn write - ide_buf;\n}\n\nstatic void pkt_send(ide_config *ide, void *data, uint16_t size)\n{\n\tide->regs.pkt_io_size = (size + 1) / 2;\n\tide_send_data(data, ide->regs.pkt_io_size);\n\n\tide->regs.cylinder = size;\n\tide->regs.sector_count = 2;\n\n\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_DRQ | ATA_STATUS_IRQ;\n\tide_set_regs(ide);\n\tide->state = IDE_STATE_WAIT_PKT_RD;\n}\n\nstatic void read_cd_sectors(ide_config *ide, track_t *track, int cnt)\n{\n\tdrive_t *drv = &ide->drive[ide->regs.drv];\n\tuint32_t sz = drv->track[drv->data_num].sectorSize;\n\n\tif (sz == 2048)\n\t{\n\t\tif (!ide->null) ide->null = (FileReadAdv(&track->f, ide_buf, cnt * sz, -1) <= 0);\n\t\tif (ide->null) memset(ide_buf, 0, cnt * sz);\n\t\treturn;\n\t}\n\n\tuint32_t pre = drv->track[drv->data_num].mode2 ? 24 : 16;\n\tuint32_t post = sz - pre - 2048;\n\tuint32_t off = 0;\n\n\twhile (cnt--)\n\t{\n\t\tif (!ide->null) ide->null = !FileSeek(&track->f, pre, SEEK_CUR);\n\t\tif (!ide->null) ide->null = (FileReadAdv(&track->f, ide_buf + off, 2048, -1) <= 0);\n\t\tif (ide->null) memset(ide_buf + off, 0, 2048);\n\t\tif (!ide->null) ide->null = !FileSeek(&track->f, post, SEEK_CUR);\n\t\toff += 2048;\n\t}\n}\n\nvoid cdrom_read(ide_config *ide)\n{\n\tbool is_index0 = false;\n\tuint32_t cnt = ide->regs.pkt_cnt;\n\tdrive_t *drive = &ide->drive[ide->regs.drv];\n\n\tif ((cnt * 4) > ide_io_max_size) cnt = ide_io_max_size / 4;\n\n\twhile ((cnt * 2048) > ide->regs.pkt_size_limit)\n\t{\n\t\tif (cnt <= 1) break;\n\t\tcnt--;\n\t}\n\n\n\tif (cnt != ide->regs.pkt_cnt)\n\t{\n\t\tdbg_printf(\"** partial CD read\\n\");\n\t}\n\n\n\ttrack_t *track = get_track_from_lba(drive, ide->regs.pkt_lba, is_index0);\n\n\tif (ide->state == IDE_STATE_INIT_RW && !drive->chd_f && track)\n\t{\n\t\tuint32_t pos = track->skip + (ide->regs.pkt_lba - track->start) * track->sectorSize;\n\t\tide->null = (FileSeek(&track->f, pos, SEEK_SET) < 0);\n\t}\n\n\n\tif (drive->chd_f) {\n\n\t\tuint32_t hdr = drive->track[drive->data_num].mode2 ? 24 : 16;\n\t\tif (drive->track[drive->data_num].sectorSize == 2048)\n\t\t{\n\t\t\thdr = 0;\n\t\t}\n\t\tuint32_t d_offset = 0;\n\n\t\tif (ide->state == IDE_STATE_INIT_RW)\n\t\t{\n\t\t\tdrive->chd_last_partial_lba = ide->regs.pkt_lba;\n\t\t}\n\n\t\tfor (uint32_t i = 0; i < cnt; i++)\n\t\t{\n\n\t\t\tif (mister_chd_read_sector(drive->chd_f, drive->chd_last_partial_lba + drive->track[drive->data_num].chd_offset, d_offset, hdr, 2048, ide_buf, drive->chd_hunkbuf, &drive->chd_hunknum) != CHDERR_NONE)\n\t\t\t{\n\t\t\t\t//I don't think anything else uses this, but set it just in case.\n\t\t\t\tide->null = 1;\n\t\t\t\tmemset(ide_buf + d_offset, 0, 2048);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tide->null = 0;\n\t\t\t}\n\t\t\td_offset += 2048;\n\t\t\tdrive->chd_last_partial_lba++;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tread_cd_sectors(ide, track, cnt);\n\t}\n\n\tdbg_printf(\"\\nsector:\\n\");\n\tdbg_hexdump(ide_buf, 512, 0);\n\n\tide->regs.pkt_cnt -= cnt;\n\tpkt_send(ide, ide_buf, cnt * 2048);\n}\n\nstatic int cd_inquiry(uint8_t maxlen)\n{\n\tstatic const char vendor[] = \"MiSTer  \";\n\tstatic const char product[] = \"CDROM           \";\n\n\tmemset(ide_buf, 0, 47);\n\tide_buf[0] = (0 << 5) | 5;  /* Peripheral qualifier=0   device type=5 (CDROM) */\n\tide_buf[1] = 0x80;\t\t\t/* RMB=1 removable media */\n\tide_buf[2] = 0x00;\t\t\t/* ANSI version */\n\tide_buf[3] = 0x21;\n\tide_buf[4] = maxlen - 5;    /* additional length */\n\n\tfor (int i = 0; i < 8; i++) ide_buf[i + 8] = (unsigned char)vendor[i];\n\tfor (int i = 0; i < 16; i++) ide_buf[i + 16] = (unsigned char)product[i];\n\tfor (int i = 0; i < 4; i++) ide_buf[i + 32] = ' ';\n\tfor (int i = 0; i < 11; i++) ide_buf[i + 36] = ' ';\n\n\thexdump(ide_buf, maxlen);\n\treturn maxlen;\n}\n\nstatic void set_sense(uint8_t SK, uint8_t ASC = 0, uint8_t ASCQ = 0)\n{\n\tint len = 18;\n\tmemset(ide_buf, 0, len);\n\n\tide_buf[0] = 0x70;      /* RESPONSE CODE */\n\tide_buf[2] = SK & 0xF;  /* SENSE KEY */\n\tide_buf[7] = len - 18;  /* additional sense length */\n\tide_buf[12] = ASC;\n\tide_buf[13] = ASCQ;\n}\n\nstatic int get_sense(drive_t *drv)\n{\n\tswitch (drv->load_state)\n\t{\n\tcase 3:\n\t\tset_sense(2, 0x3A);\n\t\tbreak;\n\n\tcase 2:\n\t\tset_sense(2, 4, 1);\n\t\tdrv->load_state--;\n\t\tbreak;\n\n\tcase 1:\n\t\tset_sense(2, 28, 0);\n\t\tdrv->load_state--;\n\t\tbreak;\n\n\tdefault:\n\t\tset_sense(drv->atapi_sense_key, drv->atapi_asc_code, drv->atapi_ascq_code);\n\t\tbreak;\n\t}\n\n\tdbg_hexdump(ide_buf, 18);\n\treturn 18;\n}\n\nstatic bool pause_resume(drive_t *drv, uint8_t *cmdbuf)\n{\n\tbool resume = !!(cmdbuf[8] & 1);\n\tif (drv->playing) \n\t{\n\t\tdrv->paused = !resume;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void play_audio_msf(drive_t *drv, uint8_t *cmdbuf)\n{\n\tif (cmdbuf[3] == 0xFF && cmdbuf[4] == 0xFF && cmdbuf[5] == 0xFF)\n\t{\n\t\tdrv->play_start_lba = 0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tdrv->play_start_lba = (cmdbuf[3] * 60u * 75u) + (cmdbuf[4] * 75u) + cmdbuf[5];\n\n\t\tif (drv->play_start_lba >= 150u) drv->play_start_lba -= 150u; /* LBA sector 0 == M:S:F sector 0:2:0 */\n\t\telse drv->play_start_lba = 0;\n\t}\n\n\tif (cmdbuf[6] == 0xFF && cmdbuf[7] == 0xFF && cmdbuf[8] == 0xFF)\n\t{\n\t\tdrv->play_end_lba = 0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tdrv->play_end_lba = (cmdbuf[6] * 60u * 75u) + (cmdbuf[7] * 75u) + cmdbuf[8];\n\t\tif (drv->play_end_lba >= 150u) drv->play_end_lba -= 150u; /* LBA sector 0 == M:S:F sector 0:2:0 */\n\t\telse drv->play_end_lba = 0;\n\t}\n\n\tif (drv->play_start_lba == drv->play_end_lba)\n\t{\n\t\tdrv->playing = 0;\n\t\tdrv->paused = 0;\n\t\treturn;\n\t}\n\n\t/* LBA 0xFFFFFFFF means start playing wherever the optics of the CD sit */\n\tif (drv->play_start_lba != 0xFFFFFFFF)\n\t{\n\t\tdrv->playing = 1;\n\t\tdrv->paused = 0;\n\t}\n\telse\n\t{\n\t\tdrv->playing = 0;\n\t\tdrv->paused = 1;\n\t}\n}\n\nvoid play_audio10(drive_t *drv, uint8_t *cmdbuf)\n{\n\tuint16_t play_length;\n\n\tdrv->play_start_lba = ((uint32_t)cmdbuf[2] << 24) + ((uint32_t)cmdbuf[3] << 16) + ((uint32_t)cmdbuf[4] << 8) + ((uint32_t)cmdbuf[5] << 0);\n\tplay_length = ((uint16_t)cmdbuf[7] << 8) + ((uint16_t)cmdbuf[8] << 0);\n\tdrv->play_end_lba = drv->play_start_lba + play_length;\n\n\tif (play_length == 0)\n\t{\n\t\tdrv->playing = 0;\n\t\tdrv->paused = 0;\n\t\treturn;\n\t}\n\n\t/* LBA 0xFFFFFFFF means start playing wherever the optics of the CD sit */\n\tif (drv->play_start_lba != 0xFFFFFFFF)\n\t{\n\t\tdrv->playing = 1;\n\t\tdrv->paused = 0;\n\t}\n\telse\n\t{\n\t\tdrv->playing = 0;\n\t\tdrv->paused = 1;\n\t}\n}\n\nstatic void cdrom_nodisk(ide_config *ide)\n{\n\tdrive_t *drv = &ide->drive[ide->regs.drv];\n\tdrv->last_load_state = drv->load_state;\n\tif (drv->load_state && drv->load_state < 3) drv->load_state--;\n\n\tcdrom_reply(ide, CD_ERR_NO_DISK);\n}\n\nvoid cdrom_handle_pkt(ide_config *ide)\n{\n\tdrive_t *drv = &ide->drive[ide->regs.drv];\n\tuint8_t cmdbuf[16];\n\n\tide_recv_data(cmdbuf, 6);\n\tide_reset_buf();\n\tdbg_hexdump(cmdbuf, 12, 0);\n\n\tide->regs.pkt_cnt = 0;\n\tint err = 0;\n\n\t//See MMC-5 section 4.1.6.1\n\t//If the no disk/load state isn't \"done\", most commands need to return CHECK CONDITION+sense data. \n\t//The only commands that ignore this are the ones listed below.\n\t//GET CONFIG ,GET EVENT STATUS NOTIFICATION, INQUIRY, REQUEST SENSE\n\t//0x46, 0x4A, 0x12, 0x3h\n\tif (drv->load_state || drv->mcr_flag)\n\t{\n\t\tif ((cmdbuf[0] != 0x46) && (cmdbuf[0] != 0x4A) && (cmdbuf[0] != 0x12) && (cmdbuf[0] != 0x3))\n\t\t{\n\t\t\tcdrom_nodisk(ide);\n\t\t\treturn;\n\t\t}\n\t}\n\tswitch (cmdbuf[0])\n\t{\n\tcase 0xA8: // read(12) sectors\n\tcase 0x28: // read(10) sectors\n\t\tdbg_printf(\"** Read Sectors\\n\");\n\t\t//hexdump(cmdbuf, 12, 0);\n\t\tide->regs.pkt_cnt = (cmdbuf[0] == 0x28) ? ((cmdbuf[7] << 8) | cmdbuf[8]) : ((cmdbuf[6] << 24) | (cmdbuf[7] << 16) | (cmdbuf[8] << 8) | cmdbuf[9]);\n\t\tide->regs.pkt_lba = ((cmdbuf[2] << 24) | (cmdbuf[3] << 16) | (cmdbuf[4] << 8) | cmdbuf[5]);\n\t\tif (!ide->regs.pkt_cnt)\n\t\t{\n\t\t\tdbg_printf(\"  length 0 is not a error.\\n\");\n\t\t\tcdrom_reply(ide, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tdbg_printf(\"** par: lba = %d, cnt = %d, load_state = %d\\n\", ide->regs.pkt_lba, ide->regs.pkt_cnt, drv->load_state);\n\t\tide->state = IDE_STATE_INIT_RW;\n\t\tif (!drv->load_state) cdrom_read(ide);\n\t\telse cdrom_nodisk(ide);\n\t\tbreak;\n\n\tcase 0x25: // read capacity\n\t\tdbg_printf(\"** Read Capacity\\n\");\n\t\tif (!drv->load_state)\n\t\t{\n\t\t\tuint32_t tmp = 0;\n\n\t\t\ttmp = drv->track[drv->track_cnt-1].start;\n\n\t\t\tide_buf[0] = tmp >> 24;\n\t\t\tide_buf[1] = tmp >> 16;\n\t\t\tide_buf[2] = tmp >> 8;\n\t\t\tide_buf[3] = tmp;\n\n\t\t\ttmp = 2048;\n\t\t\tide_buf[4] = tmp >> 24;\n\t\t\tide_buf[5] = tmp >> 16;\n\t\t\tide_buf[6] = tmp >> 8;\n\t\t\tide_buf[7] = tmp;\n\t\t\t//hexdump(buf, 8, 0);\n\t\t\tpkt_send(ide, ide_buf, 8);\n\t\t}\n\t\telse cdrom_nodisk(ide);\n\t\tbreak;\n\n\tcase 0x2B: // seek\n\n\t\tdbg_printf(\"** Seek\\n\");\n\t\tdrv->playing = 0;\n\t\tdrv->paused = 0;\n\t\tcdrom_reply(ide, 0);\n\t\tbreak;\n\n\tcase 0x1B: //START STOP UNIT\n\t\tdbg_printf(\"** Start Stop Unit\\n\");\n\t\tcdrom_reply(ide, 0);\n\t\tbreak;\n\n\tcase 0x1E: // lock the cd door - doing nothing.\n\t\tdbg_printf(\"** Lock Door\\n\");\n\t\tcdrom_reply(ide, 0);\n\t\tbreak;\n\n\tcase 0x5A: // mode sense\n\t\tdbg_printf(\"** Mode Sense\\n\");\n\t\tpkt_send(ide, ide_buf, mode_sense(drv, cmdbuf[2]));\n\t\tbreak;\n\n\tcase 0x42: // read sub\n\t\tdbg_printf(\"** read sub:\\n\");\n\t\tif (!drv->load_state)\n\t\t{\n\t\t\tpkt_send(ide, ide_buf, read_subchannel(drv, cmdbuf));\n\t\t}\n\t\telse cdrom_nodisk(ide);\n\t\tbreak;\n\n\tcase 0x43: // read TOC\n\t\tdbg_printf(\"** Read TOC\\n\");\n\t\tif (!drv->load_state) \n\t\t{\n\t\t\tpkt_send(ide, ide_buf, read_toc(drv, cmdbuf));\n\t\t} \n\t\telse cdrom_nodisk(ide);\n\t\tbreak;\n\n\tcase 0x12: // inquiry\n\t\tdbg_printf(\"** Inquiry\\n\");\n\t\tpkt_send(ide, ide_buf, cd_inquiry(cmdbuf[4]));\n\t\tbreak;\n\n\tcase 0x03: // mode sense\n\t\tdbg_printf(\"** get sense:\\n\");\n\t\tpkt_send(ide, ide_buf, get_sense(drv));\n\t\tbreak;\n\n\n\tcase 0x55: // mode select\n\t\tdbg_printf(\"** mode select\\n\");\n\t\tide->regs.cylinder = (cmdbuf[7] << 8) | cmdbuf[8];\n\t\tif (ide->regs.cylinder > 512) ide->regs.cylinder = 512;\n\t\tide->regs.pkt_io_size = (ide->regs.cylinder + 1) / 2;\n\t\tide->regs.sector_count = 0;\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_DRQ | ATA_STATUS_IRQ;\n\t\tide_set_regs(ide);\n\t\tide->state = IDE_STATE_WAIT_PKT_MODE;\n\t\tbreak;\n\n\tcase 0x00: // test unit ready\n\t\tdbg_printf(\"** Test Unit Ready\\n\");\n\t\tif (!drv->load_state) cdrom_reply(ide, 0, false);\n\t\telse cdrom_nodisk(ide);\n\t\tbreak;\n\n\tcase 0x45: // play lba\n\t\tdbg_printf(\"** CD PLAY AUDIO(10)\\n\");\n\t\tplay_audio10(drv, cmdbuf);\n\t\tcdrom_reply(ide, 0);\n\t\tbreak;\n\n\tcase 0x47: // play msf\n\t\tdbg_printf(\"** CD PLAY AUDIO MSF\\n\");\n\t\tplay_audio_msf(drv, cmdbuf);\n\t\tcdrom_reply(ide, 0);\n\t\tbreak;\n\n\tcase 0x4B: // pause/resume\n\t\tdbg_printf(\"** CD PAUSE/RESUME\\n\");\n\t\tcdrom_reply(ide, pause_resume(drv, cmdbuf) ? 0 : CD_ERR_ILLEGAL_REQUEST, CD_ASC_CODE_COMMAND_SEQUENCE_ERR);\n\t\tbreak;\n\n\tdefault:\n\t\terr = 1;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t{\n\t\tprintf(\"(!) Error in packet command %02X\\n\", cmdbuf[0]);\n\t\thexdump(cmdbuf, 12, 0);\n\t\tcdrom_reply(ide, CD_ERR_ILLEGAL_REQUEST, CD_ASC_CODE_ILLEGAL_OPCODE);\n\t}\n}\n\nint cdrom_handle_cmd(ide_config *ide)\n{\n\tuint8_t drv;\n\n\tswitch (ide->regs.cmd)\n\t{\n\tcase 0xA1: // identify packet\n\t\t//print_regs(&ide->regs);\n\t\tdbg_printf(\"identify packet\\n\");\n\t\tide_send_data(ide->drive[ide->regs.drv].id, 256);\n\t\tdrv = ide->regs.drv;\n\t\tmemset(&ide->regs, 0, sizeof(ide->regs));\n\t\tide->regs.drv = drv;\n\t\tide->regs.pkt_io_size = 256;\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_DRQ | ATA_STATUS_IRQ | ATA_STATUS_END;\n\t\tide_set_regs(ide);\n\t\tide->state = IDE_STATE_IDLE;\n\t\tbreak;\n\n\tcase 0xEC: // identify (fail)\n\t\tdbg_printf(\"identify (CD)\\n\");\n\t\tide->regs.sector = 1;\n\t\tide->regs.sector_count = 1;\n\t\tide->regs.cylinder = 0xEB14;\n\t\tide->regs.head = 0;\n\t\tide->regs.io_size = 0;\n\t\treturn 1;\n\n\tcase 0xA0: // packet\n\t\tdbg_printf(\"cmd A0: %02X\\n\", ide->regs.features);\n\t\tif (ide->regs.features & 1)\n\t\t{\n\t\t\tdbg_printf(\"Cancel A0 DMA transfer\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tide->regs.pkt_size_limit = ide->regs.cylinder;\n\t\tif (!ide->regs.pkt_size_limit) ide->regs.pkt_size_limit = ide_io_max_size * 512;\n\t\tide->regs.pkt_io_size = 6;\n\t\tide->regs.sector_count = 1;\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_DRQ; // | ATA_STATUS_IRQ;\n\t\tide_set_regs(ide);\n\t\tide->state = IDE_STATE_WAIT_PKT_CMD;\n\t\tbreak;\n\n\tcase 0x08: // reset\n\t\tdbg_printf(\"cmd 08\\n\");\n\t\tide->drive[ide->regs.drv].playing = 0;\n\t\tide->drive[ide->regs.drv].paused = 0;\n\t\tide->regs.sector = 1;\n\t\tide->regs.sector_count = 1;\n\t\tide->regs.cylinder = 0xEB14;\n\t\tide->regs.head = 0;\n\t\tide->regs.io_size = 0;\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_DSC;\n\t\tide_set_regs(ide);\n\t\tbreak;\n\n\tcase 0x00: // nop\n\t\tdbg_printf(\"cmd 00\\n\");\n\t\treturn 1; // must always fail\n\n\tdefault:\n\t\tprintf(\"(!) Unsupported command\\n\");\n\t\tide_print_regs(&ide->regs);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n//error is the atapi sense_key\nvoid cdrom_reply(ide_config *ide, uint8_t error, uint8_t asc_code, uint8_t ascq_code, bool unit_attention)\n{\n\tide->state = IDE_STATE_IDLE;\n\tide->regs.sector_count = 3;\n\tif (ide->drive[ide->regs.drv].mcr_flag && unit_attention) {\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_IRQ | ATA_STATUS_ERR;\n\t\tide->regs.error = (CD_ERR_UNIT_ATTENTION << 4) | ATA_ERR_MC;\n\t\tide->drive[ide->regs.drv].mcr_flag = false;\n\t}\n\telse\n\t{\n\t\tide->regs.status = ATA_STATUS_RDY | ATA_STATUS_IRQ | (error ? ATA_STATUS_ERR : 0);\n\t\tide->regs.error = error << 4;\n\t\tide->drive[ide->regs.drv].atapi_sense_key = error;\n\t\tide->drive[ide->regs.drv].atapi_asc_code = asc_code;\n\t\tide->drive[ide->regs.drv].atapi_ascq_code = ascq_code;\n\t}\n\n\tide_set_regs(ide);\n}\n\n\nvoid cdrom_close_chd(drive_t *drv)\n{\n\n\tif (drv->chd_f)\n\t{\n\t\tchd_close(drv->chd_f);\n\t\tdrv->chd_f = NULL;\n\t}\n\n\tif (drv->chd_hunkbuf)\n\t{\n\t\tfree(drv->chd_hunkbuf);\n\t\tdrv->chd_hunkbuf = NULL;\n\t}\n\tdrv->chd_hunknum = -1;\n}\n\nconst char* cdrom_parse(uint32_t num, const char *filename)\n{\n\tconst char *res = 0;\n\n\tint drv = num & 1;\n\tnum >>= 1;\n\n\t//always close files and reset state. empty filename == unmounted cd from OSD\n\tcdrom_close_chd(&ide_inst[num].drive[drv]);\n\tfor (uint8_t i = 0; i < sizeof(ide_inst[num].drive[drv].track) / sizeof(track_t); i++)\n\t{\n\t\tif (ide_inst[num].drive[drv].track[i].f.opened())\n\t\t{\n\t\t\tFileClose(&ide_inst[num].drive[drv].track[i].f);\n\t\t}\n\t}\n\tide_inst[num].drive[drv].mcr_flag = true;\n\tide_inst[num].drive[drv].playing = 0;\n\tide_inst[num].drive[drv].paused = 0;\n\tide_inst[num].drive[drv].play_start_lba = 0;\n\tide_inst[num].drive[drv].play_end_lba = 0;\n\tif (strlen(filename))\n\t{\n\t\tconst char *path = getFullPath(filename);\n\t\tres = load_chd_file(&ide_inst[num].drive[drv], path);\n\t\tif (!res) res = load_cue_file(&ide_inst[num].drive[drv], path);\n\t\tif (!res) res = load_iso_file(&ide_inst[num].drive[drv], path);\n\t}\n\treturn res;\n}\n\nvoid ide_cdda_send_sector()\n{\n\tbool is_index0 = false;\n\tstatic uint8_t cdda_buf[BYTES_PER_RAW_REDBOOK_FRAME];\n\tdrive_t *drv = NULL;\n\tide_config *ide = NULL;\n\tint ide_idx = -1;\n\tfor (ide_idx = 0; ide_idx < 2; ide_idx++)\n\t{\n\t\tfor (int drv_idx = 0; drv_idx < 2; drv_idx++)\n\t\t{\n\t\t\tif (ide_inst[ide_idx].drive[drv_idx].playing == 1 && ide_inst[ide_idx].drive[drv_idx].paused == 0)\n\t\t\t{\n\t\t\t\tdrv = &ide_inst[ide_idx].drive[drv_idx];\n\t\t\t\tide = &ide_inst[ide_idx];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (drv) break;\n\t}\n\n\tif (!drv || !ide) return;\n\n\tbool needs_swap = false;\n\ttrack_t *track = get_track_from_lba(drv, drv->play_start_lba, is_index0);\n\n\tif (!track->attr)\n\t{\n\t\tif (drv->chd_f)\n\t\t{\n\t\t\tmister_chd_read_sector(drv->chd_f, drv->play_start_lba + drv->track[drv->data_num].chd_offset, 0, 0, BYTES_PER_RAW_REDBOOK_FRAME, cdda_buf, drv->chd_hunkbuf, &drv->chd_hunknum);\n\t\t\tneeds_swap = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//If we're in the index0 area \"audio pregap\", that data is actually in the\n\t\t\t//previous track. Use that file object, seek and return the data from there.\n\t\t\t//If the seek fails just return zero data.\n\t\t\t//It may be a 'PREGAP' which indicates no stored data\n\n\t\t\ttrack_t *read_track = track;\n\t\t\tif (is_index0 && track->number > 1)\n\t\t\t{\n\t\t\t\t//track number is 1-based, track array is zero. \n\t\t\t\tread_track = &drv->track[track->number-2];\n\n\t\t\t}\n\t\t\tuint32_t pos = read_track->skip + (drv->play_start_lba - read_track->start) * read_track->sectorSize;\n\t\t\tif (FileSeek(&read_track->f, pos, SEEK_SET))\n\t\t\t{\n\t\t\t\tFileReadAdv(&read_track->f, cdda_buf, sizeof(cdda_buf), -1);\n\t\t\t} else {\n\t\t\t\tmemset(cdda_buf, 0, sizeof(cdda_buf));\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tmemset(cdda_buf, 0, sizeof(cdda_buf));\n\t}\n\n\tint16_t *cdda_buf16 = (int16_t *)cdda_buf;\n\tconst int buf_wsize = sizeof(cdda_buf) / 2;\n\n\tfor (int sidx = 0; sidx < buf_wsize; sidx++)\n\t{\n\t\tif (needs_swap) cdda_buf16[sidx] = bswap_16(cdda_buf16[sidx]);\n\t\tdouble tmps = (double)cdda_buf16[sidx];\n\t\tcdda_buf16[sidx] = (int16_t)(tmps*((sidx & 1) ? drv->volume_l : drv->volume_r));\n\t}\n\n\tide_sendbuf(ide, 0x200, buf_wsize, (uint16_t *)cdda_buf);\n\n\tdrv->play_start_lba++;\n\tif (drv->play_start_lba >= drv->play_end_lba)\n\t{\n\t\tdrv->playing = 0;\n\t\tdrv->paused = 0;\n\t}\n}\n"
        },
        {
          "name": "ide_cdrom.h",
          "type": "blob",
          "size": 0.4072265625,
          "content": "#ifndef X86_CDROM_H\n#define X86_CDROM_H\n\nint cdrom_handle_cmd(ide_config *ide);\nvoid cdrom_handle_pkt(ide_config *ide);\nvoid cdrom_reply(ide_config *ide, uint8_t error, uint8_t asc_code = 0, uint8_t ascq_code = 0, bool unit_attention = true);\nvoid cdrom_read(ide_config *ide);\nvoid cdrom_mode_select(ide_config *ide);\nvoid ide_cdda_send_sector();\n\nconst char* cdrom_parse(uint32_t num, const char *filename);\n\n#endif\n"
        },
        {
          "name": "input.cpp",
          "type": "blob",
          "size": 148.3515625,
          "content": "#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/inotify.h>\n#include <sys/poll.h>\n#include <sys/sysinfo.h>\n#include <dirent.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <linux/input.h>\n#include <linux/uinput.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <stdarg.h>\n#include <math.h>\n\n#include \"input.h\"\n#include \"user_io.h\"\n#include \"menu.h\"\n#include \"hardware.h\"\n#include \"cfg.h\"\n#include \"fpga_io.h\"\n#include \"osd.h\"\n#include \"video.h\"\n#include \"audio.h\"\n#include \"joymapping.h\"\n#include \"support.h\"\n#include \"profiling.h\"\n#include \"gamecontroller_db.h\"\n#include \"str_util.h\"\n\n#define NUMDEV 30\n#define NUMPLAYERS 6\n#define UINPUT_NAME \"MiSTer virtual input\"\n\nchar joy_bnames[NUMBUTTONS][32] = {};\nint  joy_bcount = 0;\nstatic struct pollfd pool[NUMDEV + 3];\n\nstatic int ev2amiga[] =\n{\n\tNONE, //0   KEY_RESERVED\n\t0x45, //1   KEY_ESC\n\t0x01, //2   KEY_1\n\t0x02, //3   KEY_2\n\t0x03, //4   KEY_3\n\t0x04, //5   KEY_4\n\t0x05, //6   KEY_5\n\t0x06, //7   KEY_6\n\t0x07, //8   KEY_7\n\t0x08, //9   KEY_8\n\t0x09, //10  KEY_9\n\t0x0a, //11  KEY_0\n\t0x0b, //12  KEY_MINUS\n\t0x0c, //13  KEY_EQUAL\n\t0x41, //14  KEY_BACKSPACE\n\t0x42, //15  KEY_TAB\n\t0x10, //16  KEY_Q\n\t0x11, //17  KEY_W\n\t0x12, //18  KEY_E\n\t0x13, //19  KEY_R\n\t0x14, //20  KEY_T\n\t0x15, //21  KEY_Y\n\t0x16, //22  KEY_U\n\t0x17, //23  KEY_I\n\t0x18, //24  KEY_O\n\t0x19, //25  KEY_P\n\t0x1a, //26  KEY_LEFTBRACE\n\t0x1b, //27  KEY_RIGHTBRACE\n\t0x44, //28  KEY_ENTER\n\t0x63, //29  KEY_LEFTCTRL\n\t0x20, //30  KEY_A\n\t0x21, //31  KEY_S\n\t0x22, //32  KEY_D\n\t0x23, //33  KEY_F\n\t0x24, //34  KEY_G\n\t0x25, //35  KEY_H\n\t0x26, //36  KEY_J\n\t0x27, //37  KEY_K\n\t0x28, //38  KEY_L\n\t0x29, //39  KEY_SEMICOLON\n\t0x2a, //40  KEY_APOSTROPHE\n\t0x00, //41  KEY_GRAVE\n\t0x60, //42  KEY_LEFTSHIFT\n\t0x0d, //43  KEY_BACKSLASH\n\t0x31, //44  KEY_Z\n\t0x32, //45  KEY_X\n\t0x33, //46  KEY_C\n\t0x34, //47  KEY_V\n\t0x35, //48  KEY_B\n\t0x36, //49  KEY_N\n\t0x37, //50  KEY_M\n\t0x38, //51  KEY_COMMA\n\t0x39, //52  KEY_DOT\n\t0x3a, //53  KEY_SLASH\n\t0x61, //54  KEY_RIGHTSHIFT\n\t0x5d, //55  KEY_KPASTERISK\n\t0x64, //56  KEY_LEFTALT\n\t0x40, //57  KEY_SPACE\n\t0x62 | CAPS_TOGGLE, //58  KEY_CAPSLOCK\n\t0x50, //59  KEY_F1\n\t0x51, //60  KEY_F2\n\t0x52, //61  KEY_F3\n\t0x53, //62  KEY_F4\n\t0x54, //63  KEY_F5\n\t0x55, //64  KEY_F6\n\t0x56, //65  KEY_F7\n\t0x57, //66  KEY_F8\n\t0x58, //67  KEY_F9\n\t0x59, //68  KEY_F10\n\tNONE, //69  KEY_NUMLOCK\n\tNONE, //70  KEY_SCROLLLOCK\n\t0x3d, //71  KEY_KP7\n\t0x3e, //72  KEY_KP8\n\t0x3f, //73  KEY_KP9\n\t0x4a, //74  KEY_KPMINUS\n\t0x2d, //75  KEY_KP4\n\t0x2e, //76  KEY_KP5\n\t0x2f, //77  KEY_KP6\n\t0x5e, //78  KEY_KPPLUS\n\t0x1d, //79  KEY_KP1\n\t0x1e, //80  KEY_KP2\n\t0x1f, //81  KEY_KP3\n\t0x0f, //82  KEY_KP0\n\t0x3c, //83  KEY_KPDOT\n\tNONE, //84  ???\n\tNONE, //85  KEY_ZENKAKU\n\t0x30, //86  KEY_102ND, '<' on most keyboards\n\t0x5f, //87  KEY_F11\n\tNONE, //88  KEY_F12\n\tNONE, //89  KEY_RO\n\tNONE, //90  KEY_KATAKANA\n\tNONE, //91  KEY_HIRAGANA\n\tNONE, //92  KEY_HENKAN\n\tNONE, //93  KEY_KATAKANA\n\tNONE, //94  KEY_MUHENKAN\n\tNONE, //95  KEY_KPJPCOMMA\n\t0x43, //96  KEY_KPENTER\n\t0x63, //97  KEY_RIGHTCTRL\n\t0x5c, //98  KEY_KPSLASH\n\tNONE, //99  KEY_SYSRQ\n\t0x65, //100 KEY_RIGHTALT\n\tNONE, //101 KEY_LINEFEED\n\t0x6a, //102 KEY_HOME\n\t0x4c, //103 KEY_UP\n\t0x5b, //104 KEY_PAGEUP\n\t0x4f, //105 KEY_LEFT\n\t0x4e, //106 KEY_RIGHT\n\tNONE, //107 KEY_END\n\t0x4d, //108 KEY_DOWN\n\t0x5a, //109 KEY_PAGEDOWN\n\t0x0d, //110 KEY_INSERT\n\t0x46, //111 KEY_DELETE\n\tNONE, //112 KEY_MACRO\n\tNONE, //113 KEY_MUTE\n\tNONE, //114 KEY_VOLUMEDOWN\n\tNONE, //115 KEY_VOLUMEUP\n\tNONE, //116 KEY_POWER\n\tNONE, //117 KEY_KPEQUAL\n\tNONE, //118 KEY_KPPLUSMINUS\n\tNONE, //119 KEY_PAUSE\n\tNONE, //120 KEY_SCALE\n\tNONE, //121 KEY_KPCOMMA\n\tNONE, //122 KEY_HANGEUL\n\tNONE, //123 KEY_HANJA\n\tNONE, //124 KEY_YEN\n\t0x66, //125 KEY_LEFTMETA\n\t0x67, //126 KEY_RIGHTMETA\n\tNONE, //127 KEY_COMPOSE\n\tNONE, //128 KEY_STOP\n\tNONE, //129 KEY_AGAIN\n\tNONE, //130 KEY_PROPS\n\tNONE, //131 KEY_UNDO\n\tNONE, //132 KEY_FRONT\n\tNONE, //133 KEY_COPY\n\tNONE, //134 KEY_OPEN\n\tNONE, //135 KEY_PASTE\n\tNONE, //136 KEY_FIND\n\tNONE, //137 KEY_CUT\n\tNONE, //138 KEY_HELP\n\tNONE, //139 KEY_MENU\n\tNONE, //140 KEY_CALC\n\tNONE, //141 KEY_SETUP\n\tNONE, //142 KEY_SLEEP\n\tNONE, //143 KEY_WAKEUP\n\tNONE, //144 KEY_FILE\n\tNONE, //145 KEY_SENDFILE\n\tNONE, //146 KEY_DELETEFILE\n\tNONE, //147 KEY_XFER\n\tNONE, //148 KEY_PROG1\n\tNONE, //149 KEY_PROG2\n\tNONE, //150 KEY_WWW\n\tNONE, //151 KEY_MSDOS\n\tNONE, //152 KEY_SCREENLOCK\n\tNONE, //153 KEY_DIRECTION\n\tNONE, //154 KEY_CYCLEWINDOWS\n\tNONE, //155 KEY_MAIL\n\tNONE, //156 KEY_BOOKMARKS\n\tNONE, //157 KEY_COMPUTER\n\tNONE, //158 KEY_BACK\n\tNONE, //159 KEY_FORWARD\n\tNONE, //160 KEY_CLOSECD\n\tNONE, //161 KEY_EJECTCD\n\tNONE, //162 KEY_EJECTCLOSECD\n\tNONE, //163 KEY_NEXTSONG\n\tNONE, //164 KEY_PLAYPAUSE\n\tNONE, //165 KEY_PREVIOUSSONG\n\tNONE, //166 KEY_STOPCD\n\tNONE, //167 KEY_RECORD\n\tNONE, //168 KEY_REWIND\n\tNONE, //169 KEY_PHONE\n\tNONE, //170 KEY_ISO\n\tNONE, //171 KEY_CONFIG\n\tNONE, //172 KEY_HOMEPAGE\n\tNONE, //173 KEY_REFRESH\n\tNONE, //174 KEY_EXIT\n\tNONE, //175 KEY_MOVE\n\tNONE, //176 KEY_EDIT\n\tNONE, //177 KEY_SCROLLUP\n\tNONE, //178 KEY_SCROLLDOWN\n\tNONE, //179 KEY_KPLEFTPAREN\n\tNONE, //180 KEY_KPRIGHTPAREN\n\tNONE, //181 KEY_NEW\n\tNONE, //182 KEY_REDO\n\t0x5a, //183 KEY_F13\n\t0x5b, //184 KEY_F14\n\tNONE, //185 KEY_F15\n\t0x5f, //186 KEY_F16\n\tNONE, //187 KEY_F17\n\tNONE, //188 KEY_F18\n\tNONE, //189 KEY_F19\n\tNONE, //190 KEY_F20\n\tNONE, //191 KEY_F21\n\tNONE, //192 KEY_F22\n\tNONE, //193 KEY_F23\n\t0x2b, //194 # on German keyboard, was 0x63 (CTRL on Amiga), 194 KEY_F24\n\tNONE, //195 ???\n\tNONE, //196 ???\n\tNONE, //197 ???\n\tNONE, //198 ???\n\tNONE, //199 ???\n\tNONE, //200 KEY_PLAYCD\n\tNONE, //201 KEY_PAUSECD\n\tNONE, //202 KEY_PROG3\n\tNONE, //203 KEY_PROG4\n\tNONE, //204 KEY_DASHBOARD\n\tNONE, //205 KEY_SUSPEND\n\tNONE, //206 KEY_CLOSE\n\tNONE, //207 KEY_PLAY\n\tNONE, //208 KEY_FASTFORWARD\n\tNONE, //209 KEY_BASSBOOST\n\tNONE, //210 KEY_PRINT\n\tNONE, //211 KEY_HP\n\tNONE, //212 KEY_CAMERA\n\tNONE, //213 KEY_SOUND\n\tNONE, //214 KEY_QUESTION\n\tNONE, //215 KEY_EMAIL\n\tNONE, //216 KEY_CHAT\n\tNONE, //217 KEY_SEARCH\n\tNONE, //218 KEY_CONNECT\n\tNONE, //219 KEY_FINANCE\n\tNONE, //220 KEY_SPORT\n\tNONE, //221 KEY_SHOP\n\tNONE, //222 KEY_ALTERASE\n\tNONE, //223 KEY_CANCEL\n\tNONE, //224 KEY_BRIGHT_DOWN\n\tNONE, //225 KEY_BRIGHT_UP\n\tNONE, //226 KEY_MEDIA\n\tNONE, //227 KEY_SWITCHVIDEO\n\tNONE, //228 KEY_DILLUMTOGGLE\n\tNONE, //229 KEY_DILLUMDOWN\n\tNONE, //230 KEY_DILLUMUP\n\tNONE, //231 KEY_SEND\n\tNONE, //232 KEY_REPLY\n\tNONE, //233 KEY_FORWARDMAIL\n\tNONE, //234 KEY_SAVE\n\tNONE, //235 KEY_DOCUMENTS\n\tNONE, //236 KEY_BATTERY\n\tNONE, //237 KEY_BLUETOOTH\n\tNONE, //238 KEY_WLAN\n\tNONE, //239 KEY_UWB\n\tNONE, //240 KEY_UNKNOWN\n\tNONE, //241 KEY_VIDEO_NEXT\n\tNONE, //242 KEY_VIDEO_PREV\n\tNONE, //243 KEY_BRIGHT_CYCLE\n\tNONE, //244 KEY_BRIGHT_AUTO\n\tNONE, //245 KEY_DISPLAY_OFF\n\tNONE, //246 KEY_WWAN\n\tNONE, //247 KEY_RFKILL\n\tNONE, //248 KEY_MICMUTE\n\tNONE, //249 ???\n\tNONE, //250 ???\n\tNONE, //251 ???\n\tNONE, //252 ???\n\tNONE, //253 ???\n\tNONE, //254 ???\n\tNONE  //255 ???\n};\n\n\nstatic const int ev2ps2[] =\n{\n\tNONE, //0   KEY_RESERVED\n\t0x76, //1   KEY_ESC\n\t0x16, //2   KEY_1\n\t0x1e, //3   KEY_2\n\t0x26, //4   KEY_3\n\t0x25, //5   KEY_4\n\t0x2e, //6   KEY_5\n\t0x36, //7   KEY_6\n\t0x3d, //8   KEY_7\n\t0x3e, //9   KEY_8\n\t0x46, //10  KEY_9\n\t0x45, //11  KEY_0\n\t0x4e, //12  KEY_MINUS\n\t0x55, //13  KEY_EQUAL\n\t0x66, //14  KEY_BACKSPACE\n\t0x0d, //15  KEY_TAB\n\t0x15, //16  KEY_Q\n\t0x1d, //17  KEY_W\n\t0x24, //18  KEY_E\n\t0x2d, //19  KEY_R\n\t0x2c, //20  KEY_T\n\t0x35, //21  KEY_Y\n\t0x3c, //22  KEY_U\n\t0x43, //23  KEY_I\n\t0x44, //24  KEY_O\n\t0x4d, //25  KEY_P\n\t0x54, //26  KEY_LEFTBRACE\n\t0x5b, //27  KEY_RIGHTBRACE\n\t0x5a, //28  KEY_ENTER\n\tLCTRL | 0x14, //29  KEY_LEFTCTRL\n\t0x1c, //30  KEY_A\n\t0x1b, //31  KEY_S\n\t0x23, //32  KEY_D\n\t0x2b, //33  KEY_F\n\t0x34, //34  KEY_G\n\t0x33, //35  KEY_H\n\t0x3b, //36  KEY_J\n\t0x42, //37  KEY_K\n\t0x4b, //38  KEY_L\n\t0x4c, //39  KEY_SEMICOLON\n\t0x52, //40  KEY_APOSTROPHE\n\t0x0e, //41  KEY_GRAVE\n\tLSHIFT | 0x12, //42  KEY_LEFTSHIFT\n\t0x5d, //43  KEY_BACKSLASH\n\t0x1a, //44  KEY_Z\n\t0x22, //45  KEY_X\n\t0x21, //46  KEY_C\n\t0x2a, //47  KEY_V\n\t0x32, //48  KEY_B\n\t0x31, //49  KEY_N\n\t0x3a, //50  KEY_M\n\t0x41, //51  KEY_COMMA\n\t0x49, //52  KEY_DOT\n\t0x4a, //53  KEY_SLASH\n\tRSHIFT | 0x59, //54  KEY_RIGHTSHIFT\n\t0x7c, //55  KEY_KPASTERISK\n\tLALT | 0x11, //56  KEY_LEFTALT\n\t0x29, //57  KEY_SPACE\n\t0x58, //58  KEY_CAPSLOCK\n\t0x05, //59  KEY_F1\n\t0x06, //60  KEY_F2\n\t0x04, //61  KEY_F3\n\t0x0c, //62  KEY_F4\n\t0x03, //63  KEY_F5\n\t0x0b, //64  KEY_F6\n\t0x83, //65  KEY_F7\n\t0x0a, //66  KEY_F8\n\t0x01, //67  KEY_F9\n\t0x09, //68  KEY_F10\n\tEMU_SWITCH_2 | 0x77, //69  KEY_NUMLOCK\n\tEMU_SWITCH_1 | 0x7E, //70  KEY_SCROLLLOCK\n\t0x6c, //71  KEY_KP7\n\t0x75, //72  KEY_KP8\n\t0x7d, //73  KEY_KP9\n\t0x7b, //74  KEY_KPMINUS\n\t0x6b, //75  KEY_KP4\n\t0x73, //76  KEY_KP5\n\t0x74, //77  KEY_KP6\n\t0x79, //78  KEY_KPPLUS\n\t0x69, //79  KEY_KP1\n\t0x72, //80  KEY_KP2\n\t0x7a, //81  KEY_KP3\n\t0x70, //82  KEY_KP0\n\t0x71, //83  KEY_KPDOT\n\tNONE, //84  ???\n\t0x0e, //85  KEY_ZENKAKU\n\t0x61, //86  KEY_102ND\n\t0x78, //87  KEY_F11\n\t0x07, //88  KEY_F12\n\t0x13, //89  KEY_RO\n\t0x13, //90  KEY_KATAKANA\n\t0x13, //91  KEY_HIRAGANA\n\t0x64, //92  KEY_HENKAN\n\t0x13, //93  KEY_KATAKANA\n\t0x67, //94  KEY_MUHENKAN\n\tNONE, //95  KEY_KPJPCOMMA\n\tEXT | 0x5a, //96  KEY_KPENTER\n\tRCTRL | EXT | 0x14, //97  KEY_RIGHTCTRL\n\tEXT | 0x4a, //98  KEY_KPSLASH\n\t0xE2, //99  KEY_SYSRQ\n\tRALT | EXT | 0x11, //100 KEY_RIGHTALT\n\tNONE, //101 KEY_LINEFEED\n\tEXT | 0x6c, //102 KEY_HOME\n\tEXT | 0x75, //103 KEY_UP\n\tEXT | 0x7d, //104 KEY_PAGEUP\n\tEXT | 0x6b, //105 KEY_LEFT\n\tEXT | 0x74, //106 KEY_RIGHT\n\tEXT | 0x69, //107 KEY_END\n\tEXT | 0x72, //108 KEY_DOWN\n\tEXT | 0x7a, //109 KEY_PAGEDOWN\n\tEXT | 0x70, //110 KEY_INSERT\n\tEXT | 0x71, //111 KEY_DELETE\n\tNONE, //112 KEY_MACRO\n\tNONE, //113 KEY_MUTE\n\tNONE, //114 KEY_VOLUMEDOWN\n\tNONE, //115 KEY_VOLUMEUP\n\tNONE, //116 KEY_POWER\n\tNONE, //117 KEY_KPEQUAL\n\tNONE, //118 KEY_KPPLUSMINUS\n\t0xE1, //119 KEY_PAUSE\n\tNONE, //120 KEY_SCALE\n\tNONE, //121 KEY_KPCOMMA\n\tNONE, //122 KEY_HANGEUL\n\tNONE, //123 KEY_HANJA\n\t0x6a, //124 KEY_YEN\n\tLGUI | EXT | 0x1f, //125 KEY_LEFTMETA\n\tRGUI | EXT | 0x27, //126 KEY_RIGHTMETA\n\tEXT | 0x2f, //127 KEY_COMPOSE\n\tNONE, //128 KEY_STOP\n\tNONE, //129 KEY_AGAIN\n\tNONE, //130 KEY_PROPS\n\tNONE, //131 KEY_UNDO\n\tNONE, //132 KEY_FRONT\n\tNONE, //133 KEY_COPY\n\tNONE, //134 KEY_OPEN\n\tNONE, //135 KEY_PASTE\n\tNONE, //136 KEY_FIND\n\tNONE, //137 KEY_CUT\n\tNONE, //138 KEY_HELP\n\tNONE, //139 KEY_MENU\n\tNONE, //140 KEY_CALC\n\tNONE, //141 KEY_SETUP\n\tNONE, //142 KEY_SLEEP\n\tNONE, //143 KEY_WAKEUP\n\tNONE, //144 KEY_FILE\n\tNONE, //145 KEY_SENDFILE\n\tNONE, //146 KEY_DELETEFILE\n\tNONE, //147 KEY_XFER\n\tNONE, //148 KEY_PROG1\n\tNONE, //149 KEY_PROG2\n\tNONE, //150 KEY_WWW\n\tNONE, //151 KEY_MSDOS\n\tNONE, //152 KEY_SCREENLOCK\n\tNONE, //153 KEY_DIRECTION\n\tNONE, //154 KEY_CYCLEWINDOWS\n\tNONE, //155 KEY_MAIL\n\tNONE, //156 KEY_BOOKMARKS\n\tNONE, //157 KEY_COMPUTER\n\tNONE, //158 KEY_BACK\n\tNONE, //159 KEY_FORWARD\n\tNONE, //160 KEY_CLOSECD\n\tNONE, //161 KEY_EJECTCD\n\tNONE, //162 KEY_EJECTCLOSECD\n\tNONE, //163 KEY_NEXTSONG\n\tNONE, //164 KEY_PLAYPAUSE\n\tNONE, //165 KEY_PREVIOUSSONG\n\tNONE, //166 KEY_STOPCD\n\tNONE, //167 KEY_RECORD\n\tNONE, //168 KEY_REWIND\n\tNONE, //169 KEY_PHONE\n\tNONE, //170 KEY_ISO\n\tNONE, //171 KEY_CONFIG\n\tNONE, //172 KEY_HOMEPAGE\n\tNONE, //173 KEY_REFRESH\n\tNONE, //174 KEY_EXIT\n\tNONE, //175 KEY_MOVE\n\tNONE, //176 KEY_EDIT\n\tNONE, //177 KEY_SCROLLUP\n\tNONE, //178 KEY_SCROLLDOWN\n\tNONE, //179 KEY_KPLEFTPAREN\n\tNONE, //180 KEY_KPRIGHTPAREN\n\tNONE, //181 KEY_NEW\n\tNONE, //182 KEY_REDO\n\tNONE, //183 KEY_F13\n\tNONE, //184 KEY_F14\n\tNONE, //185 KEY_F15\n\tNONE, //186 KEY_F16\n\tEMU_SWITCH_1 | 1, //187 KEY_F17\n\tEMU_SWITCH_1 | 2, //188 KEY_F18\n\tEMU_SWITCH_1 | 3, //189 KEY_F19\n\tEMU_SWITCH_1 | 4, //190 KEY_F20\n\tNONE, //191 KEY_F21\n\tNONE, //192 KEY_F22\n\tNONE, //193 KEY_F23\n\t0x5D, //194 U-mlaut on DE mapped to backslash\n\tNONE, //195 ???\n\tNONE, //196 ???\n\tNONE, //197 ???\n\tNONE, //198 ???\n\tNONE, //199 ???\n\tNONE, //200 KEY_PLAYCD\n\tNONE, //201 KEY_PAUSECD\n\tNONE, //202 KEY_PROG3\n\tNONE, //203 KEY_PROG4\n\tNONE, //204 KEY_DASHBOARD\n\tNONE, //205 KEY_SUSPEND\n\tNONE, //206 KEY_CLOSE\n\tNONE, //207 KEY_PLAY\n\tNONE, //208 KEY_FASTFORWARD\n\tNONE, //209 KEY_BASSBOOST\n\tNONE, //210 KEY_PRINT\n\tNONE, //211 KEY_HP\n\tNONE, //212 KEY_CAMERA\n\tNONE, //213 KEY_SOUND\n\tNONE, //214 KEY_QUESTION\n\tNONE, //215 KEY_EMAIL\n\tNONE, //216 KEY_CHAT\n\tNONE, //217 KEY_SEARCH\n\tNONE, //218 KEY_CONNECT\n\tNONE, //219 KEY_FINANCE\n\tNONE, //220 KEY_SPORT\n\tNONE, //221 KEY_SHOP\n\tNONE, //222 KEY_ALTERASE\n\tNONE, //223 KEY_CANCEL\n\tNONE, //224 KEY_BRIGHT_DOWN\n\tNONE, //225 KEY_BRIGHT_UP\n\tNONE, //226 KEY_MEDIA\n\tNONE, //227 KEY_SWITCHVIDEO\n\tNONE, //228 KEY_DILLUMTOGGLE\n\tNONE, //229 KEY_DILLUMDOWN\n\tNONE, //230 KEY_DILLUMUP\n\tNONE, //231 KEY_SEND\n\tNONE, //232 KEY_REPLY\n\tNONE, //233 KEY_FORWARDMAIL\n\tNONE, //234 KEY_SAVE\n\tNONE, //235 KEY_DOCUMENTS\n\tNONE, //236 KEY_BATTERY\n\tNONE, //237 KEY_BLUETOOTH\n\tNONE, //238 KEY_WLAN\n\tNONE, //239 KEY_UWB\n\tNONE, //240 KEY_UNKNOWN\n\tNONE, //241 KEY_VIDEO_NEXT\n\tNONE, //242 KEY_VIDEO_PREV\n\tNONE, //243 KEY_BRIGHT_CYCLE\n\tNONE, //244 KEY_BRIGHT_AUTO\n\tNONE, //245 KEY_DISPLAY_OFF\n\tNONE, //246 KEY_WWAN\n\tNONE, //247 KEY_RFKILL\n\tNONE, //248 KEY_MICMUTE\n\tNONE, //249 ???\n\tNONE, //250 ???\n\tNONE, //251 ???\n\tNONE, //252 ???\n\tNONE, //253 ???\n\tNONE, //254 ???\n\tNONE  //255 ???\n};\n\nstatic const int ev2ps2_set1[] =\n{\n\tNONE, //0   KEY_RESERVED\n\t0x01, //1   KEY_ESC\n\t0x02, //2   KEY_1\n\t0x03, //3   KEY_2\n\t0x04, //4   KEY_3\n\t0x05, //5   KEY_4\n\t0x06, //6   KEY_5\n\t0x07, //7   KEY_6\n\t0x08, //8   KEY_7\n\t0x09, //9   KEY_8\n\t0x0a, //10  KEY_9\n\t0x0b, //11  KEY_0\n\t0x0c, //12  KEY_MINUS\n\t0x0d, //13  KEY_EQUAL\n\t0x0e, //14  KEY_BACKSPACE\n\t0x0f, //15  KEY_TAB\n\t0x10, //16  KEY_Q\n\t0x11, //17  KEY_W\n\t0x12, //18  KEY_E\n\t0x13, //19  KEY_R\n\t0x14, //20  KEY_T\n\t0x15, //21  KEY_Y\n\t0x16, //22  KEY_U\n\t0x17, //23  KEY_I\n\t0x18, //24  KEY_O\n\t0x19, //25  KEY_P\n\t0x1a, //26  KEY_LEFTBRACE\n\t0x1b, //27  KEY_RIGHTBRACE\n\t0x1c, //28  KEY_ENTER\n\tLCTRL | 0x1d, //29  KEY_LEFTCTRL\n\t0x1e, //30  KEY_A\n\t0x1f, //31  KEY_S\n\t0x20, //32  KEY_D\n\t0x21, //33  KEY_F\n\t0x22, //34  KEY_G\n\t0x23, //35  KEY_H\n\t0x24, //36  KEY_J\n\t0x25, //37  KEY_K\n\t0x26, //38  KEY_L\n\t0x27, //39  KEY_SEMICOLON  ;\n\t0x28, //40  KEY_APOSTROPHE\n\t0x29, //41  KEY_GRAVE\n\tLSHIFT | 0x2a, //42  KEY_LEFTSHIFT\n\t0x2b, //43  KEY_BACKSLASH\n\t0x2c, //44  KEY_Z\n\t0x2d, //45  KEY_X\n\t0x2e, //46  KEY_C\n\t0x2f, //47  KEY_V\n\t0x30, //48  KEY_B\n\t0x31, //49  KEY_N\n\t0x32, //50  KEY_M\n\t0x33, //51  KEY_COMMA\n\t0x34, //52  KEY_DOT\n\t0x35, //53  KEY_SLASH\n\tRSHIFT | 0x36, //54  KEY_RIGHTSHIFT\n\t0x37, //55  KEY_KPASTERISK\n\tLALT | 0x38, //56  KEY_LEFTALT\n\t0x39, //57  KEY_SPACE\n\t0x3a, //58  KEY_CAPSLOCK\n\t0x3b, //59  KEY_F1\n\t0x3c, //60  KEY_F2\n\t0x3d, //61  KEY_F3\n\t0x3e, //62  KEY_F4\n\t0x3f, //63  KEY_F5\n\t0x40, //64  KEY_F6\n\t0x41, //65  KEY_F7\n\t0x42, //66  KEY_F8\n\t0x43, //67  KEY_F9\n\t0x44, //68  KEY_F10\n\tEMU_SWITCH_2 | 0x45, //69  KEY_NUMLOCK\n\tEMU_SWITCH_1 | 0x46, //70  KEY_SCROLLLOCK\n\t0x47, //71  KEY_KP7\n\t0x48, //72  KEY_KP8\n\t0x49, //73  KEY_KP9\n\t0x4a, //74  KEY_KPMINUS\n\t0x4b, //75  KEY_KP4\n\t0x4c, //76  KEY_KP5\n\t0x4d, //77  KEY_KP6\n\t0x4e, //78  KEY_KPPLUS\n\t0x4f, //79  KEY_KP1\n\t0x50, //80  KEY_KP2\n\t0x51, //81  KEY_KP3\n\t0x52, //82  KEY_KP0\n\t0x53, //83  KEY_KPDOT\n\tNONE, //84  ???\n\tNONE, //85  KEY_ZENKAKU\n\t0x56, //86  KEY_102ND\n\t0x57, //87  KEY_F11\n\t0x58, //88  KEY_F12\n\tNONE, //89  KEY_RO\n\tNONE, //90  KEY_KATAKANA\n\tNONE, //91  KEY_HIRAGANA\n\tNONE, //92  KEY_HENKAN\n\tNONE, //93  KEY_KATAKANA\n\tNONE, //94  KEY_MUHENKAN\n\tNONE, //95  KEY_KPJPCOMMA\n\tEXT | 0x1c, //96  KEY_KPENTER\n\tRCTRL | EXT | 0x1d, //97  KEY_RIGHTCTRL\n\tEXT | 0x35, //98  KEY_KPSLASH\n\t0xE2, //99  KEY_SYSRQ\n\tRALT | EXT | 0x38, //100 KEY_RIGHTALT\n\tNONE, //101 KEY_LINEFEED\n\tEXT | 0x47, //102 KEY_HOME\n\tEXT | 0x48, //103 KEY_UP\n\tEXT | 0x49, //104 KEY_PAGEUP\n\tEXT | 0x4b, //105 KEY_LEFT\n\tEXT | 0x4d, //106 KEY_RIGHT\n\tEXT | 0x4f, //107 KEY_END\n\tEXT | 0x50, //108 KEY_DOWN\n\tEXT | 0x51, //109 KEY_PAGEDOWN\n\tEXT | 0x52, //110 KEY_INSERT\n\tEXT | 0x53, //111 KEY_DELETE\n\tNONE, //112 KEY_MACRO\n\tNONE, //113 KEY_MUTE\n\tNONE, //114 KEY_VOLUMEDOWN\n\tNONE, //115 KEY_VOLUMEUP\n\tNONE, //116 KEY_POWER\n\tNONE, //117 KEY_KPEQUAL\n\tNONE, //118 KEY_KPPLUSMINUS\n\t0xE1, //119 KEY_PAUSE\n\tNONE, //120 KEY_SCALE\n\tNONE, //121 KEY_KPCOMMA\n\tNONE, //122 KEY_HANGEUL\n\tNONE, //123 KEY_HANJA\n\tNONE, //124 KEY_YEN\n\tLGUI | EXT | 0x5B, //125 KEY_LEFTMETA\n\tRGUI | EXT | 0x5C, //126 KEY_RIGHTMETA\n\tNONE, //127 KEY_COMPOSE\n\tNONE, //128 KEY_STOP\n\tNONE, //129 KEY_AGAIN\n\tNONE, //130 KEY_PROPS\n\tNONE, //131 KEY_UNDO\n\tNONE, //132 KEY_FRONT\n\tNONE, //133 KEY_COPY\n\tNONE, //134 KEY_OPEN\n\tNONE, //135 KEY_PASTE\n\tNONE, //136 KEY_FIND\n\tNONE, //137 KEY_CUT\n\tNONE, //138 KEY_HELP\n\tNONE, //139 KEY_MENU\n\tNONE, //140 KEY_CALC\n\tNONE, //141 KEY_SETUP\n\tNONE, //142 KEY_SLEEP\n\tNONE, //143 KEY_WAKEUP\n\tNONE, //144 KEY_FILE\n\tNONE, //145 KEY_SENDFILE\n\tNONE, //146 KEY_DELETEFILE\n\tNONE, //147 KEY_XFER\n\tNONE, //148 KEY_PROG1\n\tNONE, //149 KEY_PROG2\n\tNONE, //150 KEY_WWW\n\tNONE, //151 KEY_MSDOS\n\tNONE, //152 KEY_SCREENLOCK\n\tNONE, //153 KEY_DIRECTION\n\tNONE, //154 KEY_CYCLEWINDOWS\n\tNONE, //155 KEY_MAIL\n\tNONE, //156 KEY_BOOKMARKS\n\tNONE, //157 KEY_COMPUTER\n\tNONE, //158 KEY_BACK\n\tNONE, //159 KEY_FORWARD\n\tNONE, //160 KEY_CLOSECD\n\tNONE, //161 KEY_EJECTCD\n\tNONE, //162 KEY_EJECTCLOSECD\n\tNONE, //163 KEY_NEXTSONG\n\tNONE, //164 KEY_PLAYPAUSE\n\tNONE, //165 KEY_PREVIOUSSONG\n\tNONE, //166 KEY_STOPCD\n\tNONE, //167 KEY_RECORD\n\tNONE, //168 KEY_REWIND\n\tNONE, //169 KEY_PHONE\n\tNONE, //170 KEY_ISO\n\tNONE, //171 KEY_CONFIG\n\tNONE, //172 KEY_HOMEPAGE\n\tNONE, //173 KEY_REFRESH\n\tNONE, //174 KEY_EXIT\n\tNONE, //175 KEY_MOVE\n\tNONE, //176 KEY_EDIT\n\tNONE, //177 KEY_SCROLLUP\n\tNONE, //178 KEY_SCROLLDOWN\n\tNONE, //179 KEY_KPLEFTPAREN\n\tNONE, //180 KEY_KPRIGHTPAREN\n\tNONE, //181 KEY_NEW\n\tNONE, //182 KEY_REDO\n\tNONE, //183 KEY_F13\n\tNONE, //184 KEY_F14\n\tNONE, //185 KEY_F15\n\tNONE, //186 KEY_F16\n\tEMU_SWITCH_1 | 1, //187 KEY_F17\n\tEMU_SWITCH_1 | 2, //188 KEY_F18\n\tEMU_SWITCH_1 | 3, //189 KEY_F19\n\tEMU_SWITCH_1 | 4, //190 KEY_F20\n\tNONE, //191 KEY_F21\n\tNONE, //192 KEY_F22\n\tNONE, //193 KEY_F23\n\t0x2B, //194 U-mlaut on DE mapped to backslash\n\tNONE, //195 ???\n\tNONE, //196 ???\n\tNONE, //197 ???\n\tNONE, //198 ???\n\tNONE, //199 ???\n\tNONE, //200 KEY_PLAYCD\n\tNONE, //201 KEY_PAUSECD\n\tNONE, //202 KEY_PROG3\n\tNONE, //203 KEY_PROG4\n\tNONE, //204 KEY_DASHBOARD\n\tNONE, //205 KEY_SUSPEND\n\tNONE, //206 KEY_CLOSE\n\tNONE, //207 KEY_PLAY\n\tNONE, //208 KEY_FASTFORWARD\n\tNONE, //209 KEY_BASSBOOST\n\tNONE, //210 KEY_PRINT\n\tNONE, //211 KEY_HP\n\tNONE, //212 KEY_CAMERA\n\tNONE, //213 KEY_SOUND\n\tNONE, //214 KEY_QUESTION\n\tNONE, //215 KEY_EMAIL\n\tNONE, //216 KEY_CHAT\n\tNONE, //217 KEY_SEARCH\n\tNONE, //218 KEY_CONNECT\n\tNONE, //219 KEY_FINANCE\n\tNONE, //220 KEY_SPORT\n\tNONE, //221 KEY_SHOP\n\tNONE, //222 KEY_ALTERASE\n\tNONE, //223 KEY_CANCEL\n\tNONE, //224 KEY_BRIGHT_DOWN\n\tNONE, //225 KEY_BRIGHT_UP\n\tNONE, //226 KEY_MEDIA\n\tNONE, //227 KEY_SWITCHVIDEO\n\tNONE, //228 KEY_DILLUMTOGGLE\n\tNONE, //229 KEY_DILLUMDOWN\n\tNONE, //230 KEY_DILLUMUP\n\tNONE, //231 KEY_SEND\n\tNONE, //232 KEY_REPLY\n\tNONE, //233 KEY_FORWARDMAIL\n\tNONE, //234 KEY_SAVE\n\tNONE, //235 KEY_DOCUMENTS\n\tNONE, //236 KEY_BATTERY\n\tNONE, //237 KEY_BLUETOOTH\n\tNONE, //238 KEY_WLAN\n\tNONE, //239 KEY_UWB\n\tNONE, //240 KEY_UNKNOWN\n\tNONE, //241 KEY_VIDEO_NEXT\n\tNONE, //242 KEY_VIDEO_PREV\n\tNONE, //243 KEY_BRIGHT_CYCLE\n\tNONE, //244 KEY_BRIGHT_AUTO\n\tNONE, //245 KEY_DISPLAY_OFF\n\tNONE, //246 KEY_WWAN\n\tNONE, //247 KEY_RFKILL\n\tNONE, //248 KEY_MICMUTE\n\tNONE, //249 ???\n\tNONE, //250 ???\n\tNONE, //251 ???\n\tNONE, //252 ???\n\tNONE, //253 ???\n\tNONE, //254 ???\n\tNONE  //255 ???\n};\n\nstatic int ev2archie[] =\n{\n\tNONE, //0   KEY_RESERVED\n\t0x00, //1   KEY_ESC\n\t0x11, //2   KEY_1\n\t0x12, //3   KEY_2\n\t0x13, //4   KEY_3\n\t0x14, //5   KEY_4\n\t0x15, //6   KEY_5\n\t0x16, //7   KEY_6\n\t0x17, //8   KEY_7\n\t0x18, //9   KEY_8\n\t0x19, //10  KEY_9\n\t0x1a, //11  KEY_0\n\t0x1b, //12  KEY_MINUS\n\t0x1c, //13  KEY_EQUAL\n\t0x1e, //14  KEY_BACKSPACE\n\t0x26, //15  KEY_TAB\n\t0x27, //16  KEY_Q\n\t0x28, //17  KEY_W\n\t0x29, //18  KEY_E\n\t0x2a, //19  KEY_R\n\t0x2b, //20  KEY_T\n\t0x2c, //21  KEY_Y\n\t0x2d, //22  KEY_U\n\t0x2e, //23  KEY_I\n\t0x2f, //24  KEY_O\n\t0x30, //25  KEY_P\n\t0x31, //26  KEY_LEFTBRACE\n\t0x32, //27  KEY_RIGHTBRACE\n\t0x47, //28  KEY_ENTER\n\t0x3b, //29  KEY_LEFTCTRL\n\t0x3c, //30  KEY_A\n\t0x3d, //31  KEY_S\n\t0x3e, //32  KEY_D\n\t0x3f, //33  KEY_F\n\t0x40, //34  KEY_G\n\t0x41, //35  KEY_H\n\t0x42, //36  KEY_J\n\t0x43, //37  KEY_K\n\t0x44, //38  KEY_L\n\t0x45, //39  KEY_SEMICOLON\n\t0x46, //40  KEY_APOSTROPHE\n\t0x10, //41  KEY_GRAVE\n\t0x4c, //42  KEY_LEFTSHIFT\n\t0x33, //43  KEY_BACKSLASH\n\t0x4e, //44  KEY_Z\n\t0x4f, //45  KEY_X\n\t0x50, //46  KEY_C\n\t0x51, //47  KEY_V\n\t0x52, //48  KEY_B\n\t0x53, //49  KEY_N\n\t0x54, //50  KEY_M\n\t0x55, //51  KEY_COMMA\n\t0x56, //52  KEY_DOT\n\t0x57, //53  KEY_SLASH\n\t0x58, //54  KEY_RIGHTSHIFT\n\t0x24, //55  KEY_KPASTERISK\n\t0x5e, //56  KEY_LEFTALT\n\t0x5f, //57  KEY_SPACE\n\t0x5d, //58  KEY_CAPSLOCK\n\t0x01, //59  KEY_F1\n\t0x02, //60  KEY_F2\n\t0x03, //61  KEY_F3\n\t0x04, //62  KEY_F4\n\t0x05, //63  KEY_F5\n\t0x06, //64  KEY_F6\n\t0x07, //65  KEY_F7\n\t0x08, //66  KEY_F8\n\t0x09, //67  KEY_F9\n\t0x0a, //68  KEY_F10\n\t0x22, //69  KEY_NUMLOCK\n\tNONE, //70  KEY_SCROLLLOCK\n\t0x37, //71  KEY_KP7\n\t0x38, //72  KEY_KP8\n\t0x39, //73  KEY_KP9\n\t0x3a, //74  KEY_KPMINUS\n\t0x48, //75  KEY_KP4\n\t0x49, //76  KEY_KP5\n\t0x4a, //77  KEY_KP6\n\t0x4b, //78  KEY_KPPLUS\n\t0x5a, //79  KEY_KP1\n\t0x5b, //80  KEY_KP2\n\t0x5c, //81  KEY_KP3\n\t0x65, //82  KEY_KP0\n\t0x66, //83  KEY_KPDOT\n\tNONE, //84  ???\n\tNONE, //85  KEY_ZENKAKU\n\tNONE, //86  KEY_102ND\n\t0x0b, //87  KEY_F11\n\t0x0c, //88  KEY_F12\n\tNONE, //89  KEY_RO\n\tNONE, //90  KEY_KATAKANA\n\tNONE, //91  KEY_HIRAGANA\n\tNONE, //92  KEY_HENKAN\n\tNONE, //93  KEY_KATAKANA\n\tNONE, //94  KEY_MUHENKAN\n\tNONE, //95  KEY_KPJPCOMMA\n\t0x67, //96  KEY_KPENTER\n\t0x61, //97  KEY_RIGHTCTRL\n\t0x23, //98  KEY_KPSLASH\n\t0x0D, //99  KEY_SYSRQ\n\t0x60, //100 KEY_RIGHTALT\n\tNONE, //101 KEY_LINEFEED\n\t0x20, //102 KEY_HOME\n\t0x59, //103 KEY_UP\n\t0x21, //104 KEY_PAGEUP\n\t0x62, //105 KEY_LEFT\n\t0x64, //106 KEY_RIGHT\n\t0x35, //107 KEY_END\n\t0x63, //108 KEY_DOWN\n\t0x36, //109 KEY_PAGEDOWN\n\t0x1f, //110 KEY_INSERT\n\t0x34, //111 KEY_DELETE\n\tNONE, //112 KEY_MACRO\n\tNONE, //113 KEY_MUTE\n\tNONE, //114 KEY_VOLUMEDOWN\n\tNONE, //115 KEY_VOLUMEUP\n\tNONE, //116 KEY_POWER\n\tNONE, //117 KEY_KPEQUAL\n\tNONE, //118 KEY_KPPLUSMINUS\n\t0x0f, //119 KEY_PAUSE\n\tNONE, //120 KEY_SCALE\n\tNONE, //121 KEY_KPCOMMA\n\tNONE, //122 KEY_HANGEUL\n\tNONE, //123 KEY_HANJA\n\tNONE, //124 KEY_YEN\n\tNONE, //125 KEY_LEFTMETA\n\tNONE, //126 KEY_RIGHTMETA\n\t0x71, //127 KEY_COMPOSE\n\tNONE, //128 KEY_STOP\n\tNONE, //129 KEY_AGAIN\n\tNONE, //130 KEY_PROPS\n\tNONE, //131 KEY_UNDO\n\tNONE, //132 KEY_FRONT\n\tNONE, //133 KEY_COPY\n\tNONE, //134 KEY_OPEN\n\tNONE, //135 KEY_PASTE\n\tNONE, //136 KEY_FIND\n\tNONE, //137 KEY_CUT\n\tNONE, //138 KEY_HELP\n\tNONE, //139 KEY_MENU\n\tNONE, //140 KEY_CALC\n\tNONE, //141 KEY_SETUP\n\tNONE, //142 KEY_SLEEP\n\tNONE, //143 KEY_WAKEUP\n\tNONE, //144 KEY_FILE\n\tNONE, //145 KEY_SENDFILE\n\tNONE, //146 KEY_DELETEFILE\n\tNONE, //147 KEY_XFER\n\tNONE, //148 KEY_PROG1\n\tNONE, //149 KEY_PROG2\n\tNONE, //150 KEY_WWW\n\tNONE, //151 KEY_MSDOS\n\tNONE, //152 KEY_SCREENLOCK\n\tNONE, //153 KEY_DIRECTION\n\tNONE, //154 KEY_CYCLEWINDOWS\n\tNONE, //155 KEY_MAIL\n\tNONE, //156 KEY_BOOKMARKS\n\tNONE, //157 KEY_COMPUTER\n\tNONE, //158 KEY_BACK\n\tNONE, //159 KEY_FORWARD\n\tNONE, //160 KEY_CLOSECD\n\tNONE, //161 KEY_EJECTCD\n\tNONE, //162 KEY_EJECTCLOSECD\n\tNONE, //163 KEY_NEXTSONG\n\tNONE, //164 KEY_PLAYPAUSE\n\tNONE, //165 KEY_PREVIOUSSONG\n\tNONE, //166 KEY_STOPCD\n\tNONE, //167 KEY_RECORD\n\tNONE, //168 KEY_REWIND\n\tNONE, //169 KEY_PHONE\n\tNONE, //170 KEY_ISO\n\tNONE, //171 KEY_CONFIG\n\tNONE, //172 KEY_HOMEPAGE\n\tNONE, //173 KEY_REFRESH\n\tNONE, //174 KEY_EXIT\n\tNONE, //175 KEY_MOVE\n\tNONE, //176 KEY_EDIT\n\tNONE, //177 KEY_SCROLLUP\n\tNONE, //178 KEY_SCROLLDOWN\n\tNONE, //179 KEY_KPLEFTPAREN\n\tNONE, //180 KEY_KPRIGHTPAREN\n\tNONE, //181 KEY_NEW\n\tNONE, //182 KEY_REDO\n\tNONE, //183 KEY_F13\n\tNONE, //184 KEY_F14\n\tNONE, //185 KEY_F15\n\tNONE, //186 KEY_F16\n\tNONE, //187 KEY_F17\n\tNONE, //188 KEY_F18\n\tNONE, //189 KEY_F19\n\tNONE, //190 KEY_F20\n\tNONE, //191 KEY_F21\n\tNONE, //192 KEY_F22\n\tNONE, //193 KEY_F23\n\tNONE, //194 KEY_F24\n\tNONE, //195 ???\n\tNONE, //196 ???\n\tNONE, //197 ???\n\tNONE, //198 ???\n\tNONE, //199 ???\n\tNONE, //200 KEY_PLAYCD\n\tNONE, //201 KEY_PAUSECD\n\tNONE, //202 KEY_PROG3\n\tNONE, //203 KEY_PROG4\n\tNONE, //204 KEY_DASHBOARD\n\tNONE, //205 KEY_SUSPEND\n\tNONE, //206 KEY_CLOSE\n\tNONE, //207 KEY_PLAY\n\tNONE, //208 KEY_FASTFORWARD\n\tNONE, //209 KEY_BASSBOOST\n\tNONE, //210 KEY_PRINT\n\tNONE, //211 KEY_HP\n\tNONE, //212 KEY_CAMERA\n\tNONE, //213 KEY_SOUND\n\tNONE, //214 KEY_QUESTION\n\tNONE, //215 KEY_EMAIL\n\tNONE, //216 KEY_CHAT\n\tNONE, //217 KEY_SEARCH\n\tNONE, //218 KEY_CONNECT\n\tNONE, //219 KEY_FINANCE\n\tNONE, //220 KEY_SPORT\n\tNONE, //221 KEY_SHOP\n\tNONE, //222 KEY_ALTERASE\n\tNONE, //223 KEY_CANCEL\n\tNONE, //224 KEY_BRIGHT_DOWN\n\tNONE, //225 KEY_BRIGHT_UP\n\tNONE, //226 KEY_MEDIA\n\tNONE, //227 KEY_SWITCHVIDEO\n\tNONE, //228 KEY_DILLUMTOGGLE\n\tNONE, //229 KEY_DILLUMDOWN\n\tNONE, //230 KEY_DILLUMUP\n\tNONE, //231 KEY_SEND\n\tNONE, //232 KEY_REPLY\n\tNONE, //233 KEY_FORWARDMAIL\n\tNONE, //234 KEY_SAVE\n\tNONE, //235 KEY_DOCUMENTS\n\tNONE, //236 KEY_BATTERY\n\tNONE, //237 KEY_BLUETOOTH\n\tNONE, //238 KEY_WLAN\n\tNONE, //239 KEY_UWB\n\tNONE, //240 KEY_UNKNOWN\n\tNONE, //241 KEY_VIDEO_NEXT\n\tNONE, //242 KEY_VIDEO_PREV\n\tNONE, //243 KEY_BRIGHT_CYCLE\n\tNONE, //244 KEY_BRIGHT_AUTO\n\tNONE, //245 KEY_DISPLAY_OFF\n\tNONE, //246 KEY_WWAN\n\tNONE, //247 KEY_RFKILL\n\tNONE, //248 KEY_MICMUTE\n\tNONE, //249 ???\n\tNONE, //250 ???\n\tNONE, //251 ???\n\tNONE, //252 ???\n\tNONE, //253 ???\n\tNONE, //254 ???\n\tNONE  //255 ???\n};\n\nuint8_t ps2_kbd_scan_set = 2;\nuint32_t get_ps2_code(uint16_t key)\n{\n\tif (key > 255) return NONE;\n\treturn (ps2_kbd_scan_set == 1) ? ev2ps2_set1[key] : ev2ps2[key];\n}\n\nuint32_t get_amiga_code(uint16_t key)\n{\n\tif (key > 255) return NONE;\n\treturn ev2amiga[key];\n}\n\nuint32_t get_archie_code(uint16_t key)\n{\n\tif (key > 255) return NONE;\n\treturn ev2archie[key];\n}\n\nstatic uint32_t modifier = 0;\n\nuint32_t get_key_mod()\n{\n\treturn modifier & MODMASK;\n}\n\nenum QUIRK\n{\n\tQUIRK_NONE = 0,\n\tQUIRK_WIIMOTE,\n\tQUIRK_DS3,\n\tQUIRK_DS4,\n\tQUIRK_DS4TOUCH,\n\tQUIRK_MADCATZ360,\n\tQUIRK_PDSP,\n\tQUIRK_PDSP_ARCADE,\n\tQUIRK_JAMMA,\n\tQUIRK_JAMMA2,\n\tQUIRK_MSSP,\n\tQUIRK_TOUCHGUN,\n\tQUIRK_VCS,\n\tQUIRK_JOYCON,\n\tQUIRK_LIGHTGUN_CRT,\n\tQUIRK_LIGHTGUN,\n\tQUIRK_WHEEL,\n};\n\ntypedef struct\n{\n\tuint16_t bustype, vid, pid, version;\n\tchar     idstr[256];\n\tchar     mod;\n\n\tuint8_t  led;\n\tuint8_t  mouse;\n\tuint8_t  axis_edge[256];\n\tint8_t   axis_pos[256];\n\n\tuint8_t  num;\n\tuint8_t  has_map;\n\tuint32_t map[NUMBUTTONS];\n\tint      map_shown;\n\n\tuint8_t  osd_combo;\n\n\tuint8_t  has_mmap;\n\tuint32_t mmap[NUMBUTTONS];\n\tuint8_t  has_jkmap;\n\tuint16_t jkmap[1024];\n\tint      stick_l[2];\n\tint      stick_r[2];\n\n\tuint8_t  has_kbdmap;\n\tuint8_t  kbdmap[256];\n\n\tint32_t  guncal[4];\n\n\tint      accx, accy;\n\tint      startx, starty;\n\tint      lastx, lasty;\n\tint      quirk;\n\n\tint      misc_flags;\n\tint      paddle_val;\n\tint      spinner_prev;\n\tint      spinner_acc;\n\tint      spinner_prediv;\n\tint      spinner_dir;\n\tint      spinner_accept;\n\tint      old_btn;\n\tint      ds_mouse_emu;\n\n\tint      lightgun_req;\n\tint      lightgun;\n\n\tint      has_rumble;\n\tint      rumble_en;\n\tuint16_t last_rumble;\n\tff_effect rumble_effect;\n\n\tint8_t   wh_steer;\n\tint8_t   wh_accel;\n\tint8_t   wh_brake;\n\tint8_t   wh_clutch;\n\tint8_t   wh_combo;\n\tint8_t   wh_pedal_invert;\n\n\tint      timeout;\n\tchar     mac[64];\n\n\tint      bind;\n\tuint32_t unique_hash;\n\tchar     devname[32];\n\tchar     id[80];\n\tchar     name[128];\n\tchar     sysfs[512];\n\n\tint      ss_range[2];\n\tint \t max_cardinal[2];\n\tfloat    max_range[2];\n\n\tuint32_t deadzone;\n} devInput;\n\nstatic devInput input[NUMDEV] = {};\nstatic devInput player_pad[NUMPLAYERS] = {};\nstatic devInput player_pdsp[NUMPLAYERS] = {};\n\n#define JOYCON_COMBO(dev)    (input[(dev)].misc_flags & (1 << 31))\n#define JOYCON_LEFT(dev)     (input[(dev)].misc_flags & (1 << 30))\n#define JOYCON_RIGHT(dev)    (input[(dev)].misc_flags & (1 << 29))\n#define JOYCON_REQ(dev)      ((input[(dev)].misc_flags & 7) == 7)\n#define JOYCON_COMBINED(dev) (input[(dev)].quirk == QUIRK_JOYCON && JOYCON_COMBO((dev)))\n\n#define BTN_NUM (sizeof(devInput::map) / sizeof(devInput::map[0]))\n\nint mfd = -1;\nint mwd = -1;\n\nstatic int set_watch()\n{\n\tmwd = -1;\n\tmfd = inotify_init1(IN_CLOEXEC);\n\tif (mfd < 0)\n\t{\n\t\tprintf(\"ERR: inotify_init\");\n\t\treturn -1;\n\t}\n\n\tmwd = inotify_add_watch(mfd, \"/dev/input\", IN_MODIFY | IN_CREATE | IN_DELETE);\n\n\tif (mwd < 0)\n\t{\n\t\tprintf(\"ERR: inotify_add_watch\");\n\t\treturn -1;\n\t}\n\n\treturn mfd;\n}\n\n#define EVENT_SIZE  ( sizeof (struct inotify_event) )\n#define BUF_LEN     ( 1024 * ( EVENT_SIZE + 16 ) )\n\nstatic int check_devs()\n{\n\tint result = 0;\n\tint length, i = 0;\n\tchar buffer[BUF_LEN];\n\tlength = read(mfd, buffer, BUF_LEN);\n\n\tif (length < 0)\n\t{\n\t\tprintf(\"ERR: read\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (i<length)\n\t{\n\t\tstruct inotify_event *event = (struct inotify_event *) &buffer[i];\n\t\tif (event->len)\n\t\t{\n\t\t\tif (event->mask & IN_CREATE)\n\t\t\t{\n\t\t\t\tresult = 1;\n\t\t\t\tif (event->mask & IN_ISDIR)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"The directory %s was created.\\n\", event->name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\"The file %s was created.\\n\", event->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (event->mask & IN_DELETE)\n\t\t\t{\n\t\t\t\tresult = 1;\n\t\t\t\tif (event->mask & IN_ISDIR)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"The directory %s was deleted.\\n\", event->name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\"The file %s was deleted.\\n\", event->name);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\telse if ( event->mask & IN_MODIFY )\n\t\t\t{\n\t\t\t\tresult = 1;\n\t\t\t\tif ( event->mask & IN_ISDIR )\n\t\t\t\t{\n\t\t\t\t\tprintf( \"The directory %s was modified.\\n\", event->name );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf( \"The file %s was modified.\\n\", event->name );\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\ti += EVENT_SIZE + event->len;\n\t}\n\n\treturn result;\n}\n\nstatic void INThandler(int code)\n{\n\t(void)code;\n\n\tprintf(\"\\nExiting...\\n\");\n\n\tif (mwd >= 0) inotify_rm_watch(mfd, mwd);\n\tif (mfd >= 0) close(mfd);\n\n\texit(0);\n}\n\n#define test_bit(bit, array)  (array [bit / 8] & (1 << (bit % 8)))\n\n\nstatic char has_led(int fd)\n{\n\tunsigned char evtype_b[(EV_MAX + 7) / 8];\n\tif (fd<0) return 0;\n\n\tmemset(&evtype_b, 0, sizeof(evtype_b));\n\tif (ioctl(fd, EVIOCGBIT(0, sizeof(evtype_b)), evtype_b) < 0)\n\t{\n\t\tprintf(\"ERR: evdev ioctl.\\n\");\n\t\treturn 0;\n\t}\n\n\treturn test_bit(EV_LED, evtype_b) ? 1 : 0;\n}\n\nstatic char leds_state = 0;\nvoid set_kbdled(int mask, int state)\n{\n\tleds_state = state ? leds_state | (mask&HID_LED_MASK) : leds_state & ~(mask&HID_LED_MASK);\n}\n\nint get_kbdled(int mask)\n{\n\treturn (leds_state & (mask&HID_LED_MASK)) ? 1 : 0;\n}\n\nint toggle_kbdled(int mask)\n{\n\tint state = !get_kbdled(mask);\n\tset_kbdled(mask, state);\n\treturn state;\n}\n\nstatic int sysled_is_enabled = 1;\nvoid sysled_enable(int en)\n{\n\tsysled_is_enabled = en;\n}\n\n#define JOYMAP_DIR  \"inputs/\"\nstatic int load_map(const char *name, void *pBuffer, int size)\n{\n\tchar path[256] = { JOYMAP_DIR };\n\tstrcat(path, name);\n\tint ret = FileLoadConfig(path, pBuffer, size);\n\tif (!ret) return FileLoadConfig(name, pBuffer, size);\n\treturn ret;\n}\n\nstatic void delete_map(const char *name)\n{\n\tchar path[256] = { JOYMAP_DIR };\n\tstrcat(path, name);\n\tFileDeleteConfig(name);\n\tFileDeleteConfig(path);\n}\n\nstatic int save_map(const char *name, void *pBuffer, int size)\n{\n\tchar path[256] = { JOYMAP_DIR };\n\tstrcat(path, name);\n\tFileDeleteConfig(name);\n\treturn FileSaveConfig(path, pBuffer, size);\n}\n\nstatic int mapping = 0;\nstatic int mapping_button;\nstatic int mapping_dev = -1;\nstatic int mapping_type;\nstatic int mapping_count;\nstatic int mapping_clear;\nstatic int mapping_finish;\nstatic int mapping_set;\n\nstatic int mapping_current_key = 0;\nstatic int mapping_current_dev = -1;\n\nstatic uint32_t tmp_axis[4];\nstatic int tmp_axis_n = 0;\n\nstatic int grabbed = 1;\n\nvoid start_map_setting(int cnt, int set)\n{\n\tmapping_current_key = 0;\n\tmapping_current_dev = -1;\n\n\tmapping_button = 0;\n\tmapping = 1;\n\tmapping_set = set;\n\tif (!mapping_set)\n\t{\n\t\tmapping_dev = -1;\n\t\tmapping_type = (cnt < 0) ? 3 : cnt ? 1 : 2;\n\t}\n\tmapping_count = cnt;\n\tmapping_clear = 0;\n\tmapping_finish = 0;\n\ttmp_axis_n = 0;\n\n\tif (mapping_type <= 1 && is_menu()) mapping_button = -6;\n\tmemset(tmp_axis, 0, sizeof(tmp_axis));\n\n\t//un-stick the enter key\n\tuser_io_kbd(KEY_ENTER, 0);\n}\n\nint get_map_set()\n{\n\treturn mapping_set;\n}\n\nint get_map_button()\n{\n\treturn mapping_button;\n}\n\nint get_map_type()\n{\n\treturn mapping_type;\n}\n\nint get_map_clear()\n{\n\treturn mapping_clear;\n}\n\nint get_map_finish()\n{\n\treturn mapping_finish;\n}\n\nstatic uint32_t osd_timer = 0;\nint get_map_cancel()\n{\n\treturn (mapping && !is_menu() && osd_timer && CheckTimer(osd_timer));\n}\n\nstatic char *get_unique_mapping(int dev, int force_unique = 0)\n{\n\tuint32_t vidpid = (input[dev].vid << 16) | input[dev].pid;\n\tstatic char str[128];\n\n\tfor (uint i = 0; i < cfg.controller_unique_mapping[0]; i++)\n\t{\n\t\tif (!cfg.controller_unique_mapping[i + 1]) break;\n\t\tif (force_unique || cfg.controller_unique_mapping[i + 1] == 1 || cfg.controller_unique_mapping[i + 1] == vidpid)\n\t\t{\n\t\t\tsprintfz(str, \"%s_%08x\", input[dev].idstr, input[dev].unique_hash);\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tsprintfz(str, \"%s\", input[dev].idstr);\n\treturn str;\n}\n\nstatic char *get_map_name(int dev, int def)\n{\n\tstatic char name[1024];\n\tchar *id = get_unique_mapping(dev);\n\n\tif (def || is_menu()) sprintfz(name, \"input_%s%s_v3.map\", id, input[dev].mod ? \"_m\" : \"\");\n\telse sprintfz(name, \"%s_input_%s%s_v3.map\", user_io_get_core_name(), id, input[dev].mod ? \"_m\" : \"\");\n\treturn name;\n}\n\nstatic char *get_jkmap_name(int dev)\n{\n\tstatic char name[1024];\n\tchar *id = get_unique_mapping(dev);\n\tsprintfz(name, \"%s_input_%s_jk.map\", user_io_get_core_name(), id);\n\treturn name;\n}\n\nstatic char *get_kbdmap_name(int dev)\n{\n\tstatic char name[128];\n\tchar *id = get_unique_mapping(dev);\n\n\tsprintfz(name, \"kbd_%s.map\", id);\n\treturn name;\n}\n\nvoid finish_map_setting(int dismiss)\n{\n\tmapping = 0;\n\tif (mapping_dev<0) return;\n\n\tif (mapping_type == 2)\n\t{\n\t\tinput[mapping_dev].has_kbdmap = 0;\n\t\tif (dismiss) FileDeleteConfig(get_kbdmap_name(mapping_dev));\n\t\telse FileSaveConfig(get_kbdmap_name(mapping_dev), &input[mapping_dev].kbdmap, sizeof(input[mapping_dev].kbdmap));\n\t}\n\telse if (mapping_type == 3)\n\t{\n\t\tif (dismiss) memset(input[mapping_dev].jkmap, 0, sizeof(input[mapping_dev].jkmap));\n\t\tsave_map(get_jkmap_name(mapping_dev), &input[mapping_dev].jkmap, sizeof(input[mapping_dev].jkmap));\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t{\n\t\t\tinput[i].has_map = 0;\n\t\t\tinput[i].has_mmap = 0;\n\t\t}\n\n\t\tif (!dismiss) save_map(get_map_name(mapping_dev, 0), &input[mapping_dev].map, sizeof(input[mapping_dev].map));\n\t\tif (dismiss == 2) delete_map(get_map_name(mapping_dev, 0));\n\t}\n}\n\nvoid input_lightgun_save(int idx, int32_t *cal)\n{\n\tstatic char name[128];\n\tsprintf(name, \"%s_gun_cal_%04x_%04x_v2.cfg\", user_io_get_core_name(), input[idx].vid, input[idx].pid);\n\tFileSaveConfig(name, cal, 4 * sizeof(int32_t));\n\tmemcpy(input[idx].guncal, cal, sizeof(input[idx].guncal));\n}\n\nstatic void input_lightgun_load(int idx)\n{\n\tstatic char name[128];\n\tsprintf(name, \"%s_gun_cal_%04x_%04x_v2.cfg\", user_io_get_core_name(), input[idx].vid, input[idx].pid);\n\tFileLoadConfig(name, input[idx].guncal, 4 * sizeof(int32_t));\n}\n\nint input_has_lightgun()\n{\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tif (input[i].quirk == QUIRK_WIIMOTE)  return 1;\n\t\tif (input[i].quirk == QUIRK_TOUCHGUN) return 1;\n\t\tif (input[i].quirk == QUIRK_LIGHTGUN) return 1;\n\t\tif (input[i].quirk == QUIRK_LIGHTGUN_CRT) return 1;\n\t}\n\treturn 0;\n}\n\nuint16_t get_map_vid()\n{\n\treturn (mapping && mapping_dev >= 0) ? input[mapping_dev].vid : 0;\n}\n\nuint16_t get_map_pid()\n{\n\treturn (mapping && mapping_dev >= 0) ? input[mapping_dev].pid : 0;\n}\n\nint has_default_map()\n{\n\treturn (mapping_dev >= 0) ? (input[mapping_dev].has_mmap == 1) : 0;\n}\n\nstatic char kr_fn_table[] =\n{\n\tKEY_KPSLASH,    KEY_PAUSE,\n\tKEY_KPASTERISK, KEY_PRINT,\n\tKEY_LEFT,       KEY_HOME,\n\tKEY_RIGHT,      KEY_END,\n\tKEY_UP,         KEY_PAGEUP,\n\tKEY_DOWN,       KEY_PAGEDOWN,\n\tKEY_F1,         KEY_F11,\n\tKEY_F2,         KEY_F12,\n\n\tKEY_F3,         KEY_F17, // EMU_MOUSE\n\tKEY_F4,         KEY_F18, // EMU_JOY0\n\tKEY_F5,         KEY_F19, // EMU_JOY1\n\tKEY_F6,         KEY_F20, // EMU_NONE\n\n    //Emulate keypad for A600\n\tKEY_1,          KEY_KP1,\n\tKEY_2,          KEY_KP2,\n\tKEY_3,          KEY_KP3,\n\tKEY_4,          KEY_KP4,\n\tKEY_5,          KEY_KP5,\n\tKEY_6,          KEY_KP6,\n\tKEY_7,          KEY_KP7,\n\tKEY_8,          KEY_KP8,\n\tKEY_9,          KEY_KP9,\n\tKEY_0,          KEY_KP0,\n\tKEY_MINUS,      KEY_KPMINUS,\n\tKEY_EQUAL,      KEY_KPPLUS,\n\tKEY_BACKSLASH,  KEY_KPASTERISK,\n\tKEY_LEFTBRACE,  KEY_F13,    //KP(\n\tKEY_RIGHTBRACE, KEY_F14,    //KP)\n\tKEY_DOT,        KEY_KPDOT,\n\tKEY_ENTER,      KEY_KPENTER\n};\n\nstatic int keyrah_trans(int key, int press)\n{\n\tstatic int fn = 0;\n\n\tif (key == KEY_NUMLOCK)    return KEY_F13; // numlock -> f13\n\tif (key == KEY_SCROLLLOCK) return KEY_F14; // scrlock -> f14\n\tif (key == KEY_INSERT)     return KEY_F16; // insert -> f16. workaround!\n\n\tif (key == KEY_102ND)\n\t{\n\t\tif (!press && fn == 1) menu_key_set(KEY_MENU);\n\t\tfn = press ? 1 : 0;\n\t\treturn 0;\n\t}\n\telse if (fn)\n\t{\n\t\tfn |= 2;\n\t\tfor (uint32_t n = 0; n<(sizeof(kr_fn_table) / (2 * sizeof(kr_fn_table[0]))); n++)\n\t\t{\n\t\t\tif ((key&255) == kr_fn_table[n * 2]) return kr_fn_table[(n * 2) + 1];\n\t\t}\n\t}\n\n\treturn key;\n}\n\nstatic void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int dev);\n\nstatic int kbd_toggle = 0;\nstatic uint64_t joy[NUMPLAYERS] = {};\t\t// 0-31 primary mappings, 32-64 alternate\nstatic uint64_t autofire[NUMPLAYERS] = {};\t// 0-31 primary mappings, 32-64 alternate\nstatic uint32_t autofirecodes[NUMPLAYERS][BTN_NUM] = {};\nstatic int af_delay[NUMPLAYERS] = {};\n\nstatic uint32_t crtgun_timeout[NUMDEV] = {};\n\nstatic unsigned char mouse_btn = 0; //emulated mouse\nstatic unsigned char mice_btn = 0;\nstatic int mouse_req = 0;\nstatic int mouse_x = 0;\nstatic int mouse_y = 0;\nstatic int mouse_w = 0;\nstatic int mouse_emu = 0;\nstatic int kbd_mouse_emu = 0;\nstatic int mouse_sniper = 0;\nstatic int mouse_emu_x = 0;\nstatic int mouse_emu_y = 0;\n\nstatic uint32_t mouse_timer = 0;\n\n#define BTN_TGL 100\n#define BTN_OSD 101\n\n#define AF_MIN  16\n#define AF_MAX  512\n#define AF_STEP 8\n\nstatic int uinp_fd = -1;\nstatic int input_uinp_setup()\n{\n\tif (uinp_fd <= 0)\n\t{\n\t\tstruct uinput_user_dev uinp;\n\n\t\tif (!(uinp_fd = open(\"/dev/uinput\", O_WRONLY | O_NDELAY | O_CLOEXEC)))\n\t\t{\n\t\t\tprintf(\"Unable to open /dev/uinput\\n\");\n\t\t\tuinp_fd = -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemset(&uinp, 0, sizeof(uinp));\n\t\tstrncpy(uinp.name, UINPUT_NAME, UINPUT_MAX_NAME_SIZE);\n\t\tuinp.id.version = 4;\n\t\tuinp.id.bustype = BUS_USB;\n\n\t\tioctl(uinp_fd, UI_SET_EVBIT, EV_KEY);\n\t\tfor (int i = 0; i < 256; i++) ioctl(uinp_fd, UI_SET_KEYBIT, i);\n\n\t\twrite(uinp_fd, &uinp, sizeof(uinp));\n\t\tif (ioctl(uinp_fd, UI_DEV_CREATE))\n\t\t{\n\t\t\tprintf(\"Unable to create UINPUT device.\");\n\t\t\tclose(uinp_fd);\n\t\t\tuinp_fd = -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid input_uinp_destroy()\n{\n\tif (uinp_fd > 0)\n\t{\n\t\tioctl(uinp_fd, UI_DEV_DESTROY);\n\t\tclose(uinp_fd);\n\t\tuinp_fd = -1;\n\t}\n}\n\nstatic unsigned long uinp_repeat = 0;\nstatic struct input_event uinp_ev;\nstatic void uinp_send_key(uint16_t key, int press)\n{\n\tif (uinp_fd > 0)\n\t{\n\t\tif (!uinp_ev.value && press)\n\t\t{\n\t\t\tuinp_repeat = GetTimer(REPEATDELAY);\n\t\t}\n\n\t\tmemset(&uinp_ev, 0, sizeof(uinp_ev));\n\t\tgettimeofday(&uinp_ev.time, NULL);\n\t\tuinp_ev.type = EV_KEY;\n\t\tuinp_ev.code = key;\n\t\tuinp_ev.value = press;\n\t\twrite(uinp_fd, &uinp_ev, sizeof(uinp_ev));\n\n\t\tstatic struct input_event ev;\n\t\tev.time = uinp_ev.time;\n\t\tev.type = EV_SYN;\n\t\tev.code = SYN_REPORT;\n\t\tev.value = 0;\n\t\twrite(uinp_fd, &ev, sizeof(ev));\n\t}\n}\n\nstatic void uinp_check_key()\n{\n\tif (uinp_fd > 0)\n\t{\n\t\tif (!grabbed)\n\t\t{\n\t\t\tif (uinp_ev.value && CheckTimer(uinp_repeat))\n\t\t\t{\n\t\t\t\tuinp_repeat = GetTimer(REPEATRATE);\n\t\t\t\tuinp_send_key(uinp_ev.code, 2);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (uinp_ev.value)\n\t\t\t{\n\t\t\t\tuinp_send_key(uinp_ev.code, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void mouse_cb(int16_t x = 0, int16_t y = 0, int16_t w = 0)\n{\n\tif (grabbed)\n\t{\n\t\tmouse_x += x;\n\t\tmouse_y += y;\n\t\tmouse_w += w;\n\t\tmouse_req |= 1;\n\t}\n}\n\nstatic void mouse_btn_req()\n{\n\tif (grabbed) mouse_req |= 2;\n}\n\nstatic inline void joy_clamp(int* value, const int min, const int max)\n{\n\tif (*value < min) {\n\t\t*value = min;\n\t}\n\telse if (*value > max) {\n\t\t*value = max;\n\t}\n}\n\nstatic inline float boxradf(const float angle)\n{\n\treturn 1.0f / fmaxf(fabsf(sinf(angle)), fabsf(cosf(angle)));\n}\n\nstatic void joy_apply_deadzone(int* x, int* y, const devInput* dev, const int stick) {\n\t// Don't be fancy with such a small deadzone.\n\tif (dev->deadzone <= 2) \n\t{\n\t\tif (dev->deadzone && (abs((*x > *y) == (*x > -*y) ? *x : *y) <= dev->deadzone))\n\t\t\t*x = *y = 0;\n\t\treturn;\n\t}\n\n\tconst float radius = hypotf(*x, *y);\n\tif (radius <= (float)dev->deadzone)\n\t{\n\t\t*x = *y = 0;\n\t\treturn;\n\t}\n\n\tconst float angle = atan2f(*y, *x);\n\tconst float box_radius = boxradf(angle);\n\n\t/* A measure of how \"cardinal\" the angle is,\n\t   i.e closeness to [0, 90, 180, 270] degrees (0.0 - 1.0). */\n\tconst float cardinality = (1.4142136f - box_radius) * 2.4142136f;\n\n\t// Expected range for the given angle.\n\tconst float max_cardinal = dev->max_cardinal[stick] > (2.0f * dev->deadzone) ? dev->max_cardinal[stick] : 127.0f;\n\tconst float max_diagonal = dev->max_range[stick] > (2.0f * dev->deadzone) ? dev->max_range[stick] : 127.0f;\n\tconst float range = cardinality * max_cardinal + (1.0f - cardinality) * max_diagonal;\n\n\tconst float weight = 1.0f - fmaxf(range - radius, .0f) / (range - dev->deadzone);\n\tconst float adjusted_radius = fminf(weight * range, max_cardinal * box_radius);\n\n\t/* Don't ever return a larger magnitude than that was given.\n\t   The whole point of this function is to subtract some magnitude, not add. */\n\tif (adjusted_radius > radius) return;\n\n\t*x = nearbyintf(adjusted_radius * cosf(angle));\n\t*y = nearbyintf(adjusted_radius * sinf(angle));\n\n\t// Just to be sure.\n\tconst int min_range = is_psx() ? -128 : -127;\n\tjoy_clamp(x, min_range, INT8_MAX);\n\tjoy_clamp(y, min_range, INT8_MAX);\n}\n\nstatic uint32_t osdbtn = 0;\nstatic void joy_digital(int jnum, uint64_t mask, uint32_t code, char press, int bnum, int dont_save = 0)\n{\n\tstatic char str[128];\n\tstatic uint32_t lastcode[NUMPLAYERS];\n\tstatic uint64_t lastmask[NUMPLAYERS];\n\tint num = jnum - 1;\n\tif (num < NUMPLAYERS)\n\t{\n\t\tif (jnum)\n\t\t{\n\t\t\tif (bnum != BTN_OSD && bnum != BTN_TGL)\n\t\t\t{\n\t\t\t\tif (!dont_save)\n\t\t\t\t{\n\t\t\t\t\tif (press)\n\t\t\t\t\t{\n\t\t\t\t\t\tlastcode[num] = code;\n\t\t\t\t\t\tlastmask[num] = mask;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlastcode[num] = 0;\n\t\t\t\t\t\tlastmask[num] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!user_io_osd_is_visible() && press && !cfg.disable_autofire)\n\t\t\t\t{\n\t\t\t\t\tif (lastcode[num] && lastmask[num])\n\t\t\t\t\t{\n\t\t\t\t\t\tint found = 0;\n\t\t\t\t\t\tint zero = -1;\n\t\t\t\t\t\tfor (uint i = 0; i < BTN_NUM; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!autofirecodes[num][i]) zero = i;\n\t\t\t\t\t\t\tif (autofirecodes[num][i] == lastcode[num])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\t\tautofirecodes[num][i] = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!found && zero >= 0) autofirecodes[num][zero] = lastcode[num];\n\t\t\t\t\t\t\n\t\t\t\t\t\tautofire[num] = !found ? autofire[num] | lastmask[num] : autofire[num] & ~lastmask[num];\n\n\t\t\t\t\t\tif (hasAPI1_5())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!found) sprintf(str, \"Auto fire: %dms (%uhz)\", af_delay[num] * 2, 1000 / (af_delay[num] * 2));\n\t\t\t\t\t\t\telse sprintf(str, \"Auto fire: OFF\");\n\t\t\t\t\t\t\tInfo(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse InfoMessage((!found) ? \"\\n\\n          Auto fire\\n             ON\" :\n\t\t\t\t\t\t\t\"\\n\\n          Auto fire\\n             OFF\");\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse if (lastmask[num] & 0xF)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (lastmask[num] & 9)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taf_delay[num] += AF_STEP << ((lastmask[num] & 1) ? 1 : 0);\n\t\t\t\t\t\t\tif (af_delay[num] > AF_MAX) af_delay[num] = AF_MAX;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taf_delay[num] -= AF_STEP << ((lastmask[num] & 2) ? 1 : 0);\n\t\t\t\t\t\t\tif (af_delay[num] < AF_MIN) af_delay[num] = AF_MIN;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstatic char str[256];\n\n\t\t\t\t\t\tif (hasAPI1_5())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(str, \"Auto fire period: %dms (%uhz)\", af_delay[num] * 2, 1000 / (af_delay[num] * 2));\n\t\t\t\t\t\t\tInfo(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(str, \"\\n\\n       Auto fire period\\n            %dms(%uhz)\", af_delay[num] * 2, 1000 / (af_delay[num] * 2));\n\t\t\t\t\t\t\tInfoMessage(str);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bnum == BTN_TGL)\n\t\t{\n\t\t\tif(press) kbd_toggle = !kbd_toggle;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!user_io_osd_is_visible() && (bnum == BTN_OSD) && (mouse_emu & 1))\n\t\t{\n\t\t\tif (press)\n\t\t\t{\n\t\t\t\tmouse_sniper = 0;\n\t\t\t\tmouse_timer = 0;\n\t\t\t\tmouse_btn = 0;\n\t\t\t\tmouse_emu_x = 0;\n\t\t\t\tmouse_emu_y = 0;\n\t\t\t\tmouse_cb();\n\t\t\t\tmouse_btn_req();\n\n\t\t\t\tmouse_emu ^= 2;\n\t\t\t\tif (hasAPI1_5()) Info((mouse_emu & 2) ? \"Mouse mode ON\" : \"Mouse mode OFF\");\n\t\t\t\telse InfoMessage((mouse_emu & 2) ? \"\\n\\n       Mouse mode lock\\n             ON\" :\n\t\t\t\t\t\"\\n\\n       Mouse mode lock\\n             OFF\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// clear OSD button state if not in the OSD.  this avoids problems where buttons are still held\n\t\t// on OSD exit and causes combinations to match when partial buttons are pressed.\n\t\tif (!user_io_osd_is_visible()) osdbtn = 0;\n\n\t\tif (user_io_osd_is_visible() || (bnum == BTN_OSD))\n\t\t{\n\t\t\tmask &= ~JOY_BTN3;\n\t\t\tif (press)\n\t\t\t{\n\t\t\t\tosdbtn |= mask;\n\t\t\t\tif (mask & (JOY_BTN1 | JOY_BTN2)) {\n\t\t\t\t\tif ((osdbtn & (JOY_BTN1 | JOY_BTN2)) == (JOY_BTN1 | JOY_BTN2))\n\t\t\t\t\t{\n\t\t\t\t\t\tosdbtn |= JOY_BTN3;\n\t\t\t\t\t\tmask = JOY_BTN3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint old_osdbtn = osdbtn;\n\t\t\t\tosdbtn &= ~mask;\n\n\t\t\t\tif (mask & (JOY_BTN1 | JOY_BTN2)) {\n\t\t\t\t\tif ((old_osdbtn & (JOY_BTN1 | JOY_BTN2 | JOY_BTN3)) == (JOY_BTN1 | JOY_BTN2 | JOY_BTN3))\n\t\t\t\t\t{\n\t\t\t\t\t\tmask = JOY_BTN3;\n\t\t\t\t\t}\n\t\t\t\t\telse if (old_osdbtn & JOY_BTN3)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!(osdbtn & (JOY_BTN1 | JOY_BTN2))) osdbtn &= ~JOY_BTN3;\n\t\t\t\t\t\tmask = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif((mask & JOY_BTN2) && !(old_osdbtn & JOY_BTN2)) mask = 0;\n\t\t\t}\n\n\t\t\tmemset(joy, 0, sizeof(joy));\n\t\t\tstruct input_event ev;\n\t\t\tev.type = EV_KEY;\n\t\t\tev.value = press;\n\n\t\t\tint cfg_switch = menu_allow_cfg_switch() && (osdbtn & JOY_BTN2) && press;\n\n\t\t\tswitch (mask)\n\t\t\t{\n\t\t\tcase JOY_RIGHT:\n\t\t\t\tif (cfg_switch)\n\t\t\t\t{\n\t\t\t\t\tuser_io_set_ini(0);\n\t\t\t\t\tosdbtn = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tev.code = KEY_RIGHT;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_LEFT:\n\t\t\t\tif (cfg_switch)\n\t\t\t\t{\n\t\t\t\t\tuser_io_set_ini(1);\n\t\t\t\t\tosdbtn = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tev.code = KEY_LEFT;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_UP:\n\t\t\t\tif (cfg_switch)\n\t\t\t\t{\n\t\t\t\t\tuser_io_set_ini(2);\n\t\t\t\t\tosdbtn = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tev.code = KEY_UP;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_DOWN:\n\t\t\t\tif (cfg_switch)\n\t\t\t\t{\n\t\t\t\t\tuser_io_set_ini(3);\n\t\t\t\t\tosdbtn = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tev.code = KEY_DOWN;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN1:\n\t\t\t\tev.code = KEY_ENTER;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN2:\n\t\t\t\tev.code = KEY_BACK;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN3:\n\t\t\t\tev.code = KEY_BACKSPACE;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN4:\n\t\t\t\tev.code = KEY_TAB;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_L:\n\t\t\t\tev.code = KEY_MINUS;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_R:\n\t\t\t\tev.code = KEY_EQUAL;\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_R2:\n\t\t\t\tev.code = KEY_GRAVE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tev.code = (bnum == BTN_OSD) ? KEY_MENU : 0;\n\t\t\t}\n\n\t\t\tinput_cb(&ev, 0, 0);\n\t\t}\n\t\telse if (video_fb_state())\n\t\t{\n\t\t\tswitch (mask)\n\t\t\t{\n\t\t\tcase JOY_RIGHT:\n\t\t\t\tuinp_send_key(KEY_RIGHT, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_LEFT:\n\t\t\t\tuinp_send_key(KEY_LEFT, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_UP:\n\t\t\t\tuinp_send_key(KEY_UP, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_DOWN:\n\t\t\t\tuinp_send_key(KEY_DOWN, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN1:\n\t\t\t\tuinp_send_key(KEY_ENTER, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN2:\n\t\t\t\tuinp_send_key(KEY_ESC, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN3:\n\t\t\t\tuinp_send_key(KEY_SPACE, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_BTN4:\n\t\t\t\tuinp_send_key(KEY_TAB, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_L:\n\t\t\t\tuinp_send_key(KEY_PAGEUP, press);\n\t\t\t\tbreak;\n\n\t\t\tcase JOY_R:\n\t\t\t\tuinp_send_key(KEY_PAGEDOWN, press);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(jnum)\n\t\t{\n\t\t\tif (press) joy[num] |= mask;\n\t\t\telse joy[num] &= ~mask;\n\t\t\t\n\t\t\t//user_io_digital_joystick(num, joy[num]);\n\n\t\t\tif (code)\n\t\t\t{\n\t\t\t\tint found = 0;\n\t\t\t\tfor (uint i = 0; i < BTN_NUM; i++) if (autofirecodes[num][i] == code) found = 1;\n\t\t\t\tif (found) autofire[num] = press ? autofire[num] | mask : autofire[num] & ~mask;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool joy_dir_is_diagonal(const int x, const int y)\n{\n\tstatic const float JOY_DIAG_THRESHOLD = .85f;\n\t\n\treturn\n\t\t((x == 0) || (y == 0)) ? false :\n\t\t((x == y) || (x == -y)) ? true :\n\t\tabs((x > y) == (x > -y) ? (float)y / x : (float)x / y) >= JOY_DIAG_THRESHOLD;\n}\n\nstatic void joy_analog(int dev, int axis, int offset, int stick = 0)\n{\n\tint num = input[dev].num;\n\tstatic int pos[2][NUMPLAYERS][2] = {};\n\n\tif (grabbed && num > 0 && --num < NUMPLAYERS)\n\t{\n\t\tpos[stick][num][axis] = offset;\n\t\tint x = pos[stick][num][0], y = pos[stick][num][1];\n\n\t\tif (joy_dir_is_diagonal(x, y))\n\t\t{\n\t\t\t// Update maximum observed diag\n\t\t\t// Use sum of squares and only calc sqrt() when necessary\n\t\t\tconst int ss_range_curr = x * x + y * y;\n\t\t\tif ((ss_range_curr > input[dev].ss_range[stick]))\n\t\t\t{\n\t\t\t\tinput[dev].ss_range[stick] = ss_range_curr;\n\t\t\t\tinput[dev].max_range[stick] = sqrtf(ss_range_curr);\n\t\t\t}\n\t\t}\n\n\t\t// Update maximum observed cardinal distance\n\t\tconst int c_dist = abs((x > y) == (x > -y) ? x : y);\n\t\tif (c_dist > input[dev].max_cardinal[stick])\n\t\t{\n\t\t\tinput[dev].max_cardinal[stick] = c_dist;\n\t\t}\n\n\t\tjoy_apply_deadzone(&x, &y, &input[dev], stick);\n\n\t\tif (is_n64())\n\t\t{\n\t\t\t// Emulate N64 joystick range and shape for regular -127-+127 controllers\n\t\t\tn64_joy_emu(x, y, &x, &y, input[dev].max_cardinal[stick], input[dev].max_range[stick]);\n\t\t\tstick_swap(num, stick, &num, &stick);\n\t\t}\n\n\t\tif (stick)\n\t\t{\n\t\t\tuser_io_r_analog_joystick(num, (char)x, (char)y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuser_io_l_analog_joystick(num, (char)x, (char)y);\n\t\t}\n\t}\n}\n\nstatic char* get_led_path(int dev, int add_id = 1)\n{\n\tstatic char path[1024];\n\tif (!input[dev].sysfs[0]) return NULL;\n\n\tsprintf(path, \"/sys%s\", input[dev].sysfs);\n\tchar *p = strstr(path, \"/input/\");\n\tif (p)\n\t{\n\t\t*p = 0;\n\t\tchar *id = strrchr(path, '/');\n\t\tstrcpy(p, \"/leds\");\n\t\tif (add_id && id) strncat(p, id, p - id);\n\t\treturn path;\n\t}\n\n\treturn NULL;\n}\n\nstatic int set_led(char *base, const char *led, int brightness)\n{\n\tstatic char path[1024];\n\tsnprintf(path, sizeof(path), \"%s%s/brightness\", base, led);\n\tFILE* f = fopen(path, \"w\");\n\tif (f)\n\t{\n\t\tfprintf(f, \"%d\", brightness);\n\t\tfclose(f);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_led(char *base, const char *led)\n{\n\tstatic char path[1024];\n\tsnprintf(path, sizeof(path), \"%s%s/brightness\", base, led);\n\tFILE* f = fopen(path, \"r\");\n\tif (f)\n\t{\n\t\tint res = 0;\n\t\tfscanf(f, \"%d\", &res);\n\t\tfclose(f);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic void update_num_hw(int dev, int num)\n{\n\tchar *led_path;\n\tif (num > 7) num = 7;\n\n\tif (input[dev].quirk == QUIRK_DS4 || input[dev].quirk == QUIRK_DS4TOUCH)\n\t{\n\t\tled_path = get_led_path(dev);\n\t\tif (led_path)\n\t\t{\n\t\t\tif (set_led(led_path, \":player_id\", (num > 5) ? 0 : num))\n\t\t\t{\n\t\t\t\t//duslsense\n\t\t\t\tset_led(led_path, \":blue\", (num == 0) ? 128 : 64);\n\t\t\t\tset_led(led_path, \":green\", (num == 0) ? 128 : 64);\n\t\t\t\tset_led(led_path, \":red\", (num == 0) ? 128 : 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//dualshock4\n\t\t\t\tstatic const uint8_t color_code[8][3] =\n\t\t\t\t{\n\t\t\t\t\t{ 0x30, 0x30, 0x30 }, // White\n\t\t\t\t\t{ 0x00, 0x00, 0x40 }, // Blue\n\t\t\t\t\t{ 0x40, 0x00, 0x00 }, // Red\n\t\t\t\t\t{ 0x00, 0x40, 0x00 }, // Green\n\t\t\t\t\t{ 0x20, 0x00, 0x20 }, // Pink\n\t\t\t\t\t{ 0x40, 0x10, 0x00 }, // Orange\n\t\t\t\t\t{ 0x00, 0x20, 0x20 }, // Teal\n\t\t\t\t\t{ 0x00, 0x00, 0x00 }  // none\n\t\t\t\t};\n\n\t\t\t\tset_led(led_path, \":blue\", color_code[num][2]);\n\t\t\t\tset_led(led_path, \":green\", color_code[num][1]);\n\t\t\t\tset_led(led_path, \":red\", color_code[num][0]);\n\t\t\t}\n\t\t}\n\t}\n\telse if (input[dev].quirk == QUIRK_DS3)\n\t{\n\t\tled_path = get_led_path(dev);\n\t\tif (led_path)\n\t\t{\n\t\t\tset_led(led_path, \"::sony1\", (num == 0 || num == 1 || num == 5));\n\t\t\tset_led(led_path, \"::sony2\", (num == 0 || num == 2 || num == 6));\n\t\t\tset_led(led_path, \"::sony3\", (num == 0 || num == 3));\n\t\t\tset_led(led_path, \"::sony4\", (num == 0 || num == 4 || num == 5 || num == 6));\n\t\t}\n\t}\n\telse if (input[dev].quirk == QUIRK_WIIMOTE)\n\t{\n\t\tled_path = get_led_path(dev);\n\t\tif (led_path)\n\t\t{\n\t\t\tset_led(led_path, \":blue:p0\", (num == 0 || num == 1 || num == 5));\n\t\t\tset_led(led_path, \":blue:p1\", (num == 0 || num == 2 || num == 6));\n\t\t\tset_led(led_path, \":blue:p2\", (num == 0 || num == 3));\n\t\t\tset_led(led_path, \":blue:p3\", (num == 0 || num == 4 || num == 5 || num == 6));\n\t\t}\n\t}\n\telse if (input[dev].vid == 0x057e && ((input[dev].pid & 0xFF00) == 0x2000))\n\t{\n\t\t// nintendo switch controllers\n\t\tint repeat = 1;\n\t\twhile (1)\n\t\t{\n\t\t\tled_path = get_led_path(dev);\n\t\t\tif (led_path)\n\t\t\t{\n\t\t\t\tset_led(led_path, \":home\", num ? 1 : 15);\n\t\t\t\tset_led(led_path, \":player1\", (num == 0 || num == 1 || num == 5));\n\t\t\t\tset_led(led_path, \":player2\", (num == 0 || num == 2 || num == 6));\n\t\t\t\tset_led(led_path, \":player3\", (num == 0 || num == 3));\n\t\t\t\tset_led(led_path, \":player4\", (num == 0 || num == 4 || num == 5 || num == 6));\n\t\t\t}\n\n\t\t\tif (repeat && JOYCON_COMBINED(dev)) dev = input[dev].bind; else break;\n\t\t\trepeat = 0;\n\t\t}\n\t}\n}\n\nvoid reset_players()\n{\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tinput[i].num = 0;\n\t\tinput[i].map_shown = 0;\n\t\tupdate_num_hw(i, 0);\n\t}\n\tmemset(player_pad, 0, sizeof(player_pad));\n\tmemset(player_pdsp, 0, sizeof(player_pdsp));\n}\n\nstatic void store_player(int num, int dev)\n{\n\tdevInput *player = (input[dev].quirk == QUIRK_PDSP || input[dev].quirk == QUIRK_MSSP) ? player_pdsp : player_pad;\n\n\t// remove possible old assignment\n\tfor (int i = 1; i < NUMPLAYERS; i++) if (!strcmp(player[i].id, input[dev].id)) player[i].id[0] = 0;\n\n\tif(num && num < NUMPLAYERS) memcpy(&player[num], &input[dev], sizeof(devInput));\n\tupdate_num_hw(dev, num);\n}\n\nstatic void restore_player(int dev)\n{\n\t// do not restore bound devices\n\tif (dev != input[dev].bind && !(JOYCON_COMBINED(dev) && JOYCON_LEFT(dev))) return;\n\n\tdevInput *player = (input[dev].quirk == QUIRK_PDSP || input[dev].quirk == QUIRK_MSSP) ? player_pdsp : player_pad;\n\tfor (int k = 1; k < NUMPLAYERS; k++)\n\t{\n\t\tif (strlen(player[k].id) && !strcmp(player[k].id, input[dev].id))\n\t\t{\n\t\t\tprintf(\"restore player %d to %s (%s)\\n\", k, input[dev].devname, input[dev].id);\n\n\t\t\tinput[dev].num = k;\n\t\t\tinput[dev].map_shown = player[k].map_shown;\n\t\t\tif (JOYCON_COMBINED(dev))\n\t\t\t{\n\t\t\t\tinput[input[dev].bind].num = k;\n\t\t\t\tinput[input[dev].bind].map_shown = player[k].map_shown;\n\t\t\t}\n\n\t\t\tmemcpy(input[dev].jkmap, player[k].jkmap, sizeof(input[dev].jkmap));\n\t\t\tinput[dev].lightgun = player[k].lightgun;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tupdate_num_hw(dev, input[dev].num);\n}\n\n// Analog joystick dead zone\nstatic void setup_deadzone(struct input_event* ev, int dev)\n{\n\t// Lightgun/wheel has no dead zone\n\tif (ev->type != EV_ABS || (ev->code <= 1 && (input[dev].lightgun || input[dev].quirk == QUIRK_WHEEL)))\n\t{\n\t\tinput[dev].deadzone = 0U;\n\t}\n\t// Dual Shock 3/4\n\telse if (input[dev].quirk == QUIRK_DS3 || input[dev].quirk == QUIRK_DS4)\n\t{\n\t\tinput[dev].deadzone = 10U;\n\t}\n\t// Default dead zone\n\telse\n\t{\n\t\tinput[dev].deadzone = 2U;\n\t}\n\n\tchar cfg_format[32];\n\tchar cfg_uid[sizeof(*cfg.controller_deadzone)];\n\n\tsnprintf(cfg_format, sizeof(cfg_format), \"%%%u[^ \\t,]%%*[ \\t,]%%u%%n\", (size_t)(sizeof(cfg_uid) - 1));\n\n\tconst char* dev_uid = get_unique_mapping(dev, 1);\n\n\tfor (size_t i = 0; i < sizeof(cfg.controller_deadzone) / sizeof(*cfg.controller_deadzone); i++)\n\t{\n\t\tconst char* cfg_line = cfg.controller_deadzone[i];\n\t\tif (!cfg_line || !strlen(cfg_line)) break;\n\n\t\tuint32_t cfg_vidpid, cfg_deadzone;\n\t\tsize_t scan_pos;\n\t\tchar vp;\n\n\t\tif ((sscanf(cfg_line, cfg_format, cfg_uid, &cfg_deadzone, &scan_pos) < 2) ||\n\t\t\t(scan_pos != strlen(cfg_line))) continue;\n\n\t\tif ((\n\t\t\tsscanf(cfg_uid, \"0%*[Xx]%08x%n\", &cfg_vidpid, &scan_pos) ||\n\t\t\tsscanf(cfg_uid, \"%08x%n\", &cfg_vidpid, &scan_pos)) &&\n\t\t\t(scan_pos == strlen(cfg_uid)))\n\t\t{\n\t\t\tconst uint32_t vidpid = (input[dev].vid << 16) | input[dev].pid;\n\t\t\tif (vidpid != cfg_vidpid) continue;\n\t\t}\n\t\telse if ((\n\t\t\t(sscanf(cfg_uid, \"%[VvPp]%*[Ii]%*[Dd]:0%*[Xx]%04x%n\", &vp, &cfg_vidpid, &scan_pos) == 2) ||\n\t\t\t(sscanf(cfg_uid, \"%[VvPp]%*[Ii]%*[Dd]:%04x%n\", &vp, &cfg_vidpid, &scan_pos) == 2)) &&\n\t\t\t(scan_pos == strlen(cfg_uid)))\n\t\t{\n\t\t\tif (vp == 'V' || vp == 'v')\n\t\t\t{\n\t\t\t\tif (input[dev].vid != cfg_vidpid) continue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (input[dev].pid != cfg_vidpid) continue;\n\t\t\t}\n\t\t}\n\t\telse if (\n\t\t\t!strcasestr(input[dev].id, cfg_uid) &&\n\t\t\t!strcasestr(input[dev].sysfs, cfg_uid) &&\n\t\t\t!strcasestr(dev_uid, cfg_uid))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cfg_deadzone > 64) cfg_deadzone = 64;\n\n\t\tprintf(\"Analog device %s was given a dead zone of %u\\n\", input[dev].id, cfg_deadzone);\n\t\tinput[dev].deadzone = cfg_deadzone;\n\t\tbreak;\n\t}\n}\n\nvoid unflag_players()\n{\n\tfor (int k = 1; k < NUMPLAYERS; k++)\n\t{\n\t\tint found = 0;\n\t\tfor (int i = 0; i < NUMDEV; i++) if (strlen(player_pad[k].id) && !strcmp(player_pad[k].id, input[i].id)) found = 1;\n\t\tif (!found) player_pad[k].map_shown = 0;\n\t}\n\n\tfor (int k = 1; k < NUMPLAYERS; k++)\n\t{\n\t\tint found = 0;\n\t\tfor (int i = 0; i < NUMDEV; i++) if (strlen(player_pdsp[k].id) && !strcmp(player_pdsp[k].id, input[i].id)) found = 1;\n\t\tif (!found) player_pdsp[k].map_shown = 0;\n\t}\n}\n\nstatic uint16_t def_mmap[] = {\n\t0x0321, 0x0000, 0x0320, 0x0000, 0x0323, 0x0000, 0x0322, 0x0000,\n\t0x0131, 0x0000, 0x0130, 0x0000, 0x0133, 0x0000, 0x0134, 0x0000,\n\t0x0136, 0x0000, 0x0137, 0x0000, 0x013A, 0x0000, 0x013B, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x013C, 0x0000, 0x013C, 0x0000, 0x0131, 0x0130,\n\t0x0000, 0x0002, 0x0001, 0x0002, 0x0003, 0x0002, 0x0004, 0x0002,\n\t0x0000, 0x0002, 0x0001, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000\n};\n\nstatic void assign_player(int dev, int num, int force = 0)\n{\n\tinput[dev].num = num;\n\tif (JOYCON_COMBINED(dev)) input[input[dev].bind].num = num;\n\tstore_player(num, dev);\n\tprintf(\"Device %s %sassigned to player %d\\n\", input[dev].id, force ? \"forcebly \" : \"\", input[dev].num);\n}\n\nstatic void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int dev)\n{\n\tif (ev->type != EV_KEY && ev->type != EV_ABS && ev->type != EV_REL) return;\n\tif (ev->type == EV_KEY && (!ev->code || ev->code == KEY_UNKNOWN)) return;\n\n\tstatic uint16_t last_axis = 0;\n\n\tint sub_dev = dev;\n\n\t//check if device is a part of multifunctional device\n\tif (!JOYCON_COMBINED(dev) && input[dev].bind >= 0) dev = input[dev].bind;\n\n\tif (ev->type == EV_KEY)\n\t{\n\t\tif (input[dev].timeout > 0) input[dev].timeout = cfg.bt_auto_disconnect * 10;\n\n\t\t//mouse\n\t\tif (ev->code >= BTN_MOUSE && ev->code < BTN_JOYSTICK)\n\t\t{\n\t\t\tif (ev->value <= 1)\n\t\t\t{\n\t\t\t\tint mask = 1 << (ev->code - BTN_MOUSE);\n\t\t\t\tif (input[dev].ds_mouse_emu && mask == 1) mask = 2;\n\t\t\t\tmice_btn = (ev->value) ? (mice_btn | mask) : (mice_btn & ~mask);\n\t\t\t\tmouse_btn_req();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ev->type == EV_KEY && ev->code < 256 && !(mapping && mapping_type == 2))\n\t{\n\t\tif (!input[dev].has_kbdmap)\n\t\t{\n\t\t\tif (!FileLoadConfig(get_kbdmap_name(dev), &input[dev].kbdmap, sizeof(input[dev].kbdmap)))\n\t\t\t{\n\t\t\t\tmemset(input[dev].kbdmap, 0, sizeof(input[dev].kbdmap));\n\t\t\t}\n\t\t\tinput[dev].has_kbdmap = 1;\n\t\t}\n\n\t\tif (input[dev].kbdmap[ev->code]) ev->code = input[dev].kbdmap[ev->code];\n\t}\n\n\tstatic int key_mapped = 0;\n\n\tint map_skip = (ev->type == EV_KEY && mapping && ((ev->code == KEY_SPACE && mapping_type == 1) || ev->code == KEY_ALTERASE) && (mapping_dev >= 0 || mapping_button<0));\n\tint cancel   = (ev->type == EV_KEY && ev->code == KEY_ESC && !(mapping && mapping_type == 3 && mapping_button));\n\tint enter    = (ev->type == EV_KEY && ev->code == KEY_ENTER && !(mapping && mapping_type == 3 && mapping_button));\n\tint origcode = ev->code;\n\n\tif (!input[dev].has_mmap)\n\t{\n\t\tif (input[dev].quirk == QUIRK_TOUCHGUN)\n\t\t{\n\t\t\tmemset(input[dev].mmap, 0, sizeof(input[dev].mmap));\n\t\t\tinput[dev].mmap[SYS_AXIS_MX] = -1;\n\t\t\tinput[dev].mmap[SYS_AXIS_MY] = -1;\n\t\t\tinput[dev].mmap[SYS_AXIS_X] = -1;\n\t\t\tinput[dev].mmap[SYS_AXIS_Y] = -1;\n\t\t}\n\t\telse if (input[dev].quirk != QUIRK_PDSP && input[dev].quirk != QUIRK_MSSP)\n\t\t{\n\t\t\tif (!load_map(get_map_name(dev, 1), &input[dev].mmap, sizeof(input[dev].mmap)))\n\t\t\t{\n\t\t\t\tif (!gcdb_map_for_controller(input[sub_dev].bustype, input[sub_dev].vid, input[sub_dev].pid, input[sub_dev].version, pool[sub_dev].fd, input[dev].mmap))\n\t\t\t\t{\n\t\t\t\t\tmemset(input[dev].mmap, 0, sizeof(input[dev].mmap));\n\t\t\t\t\tmemcpy(input[dev].mmap, def_mmap, sizeof(def_mmap));\n\t\t\t\t\t//input[dev].has_mmap++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgcdb_show_string_for_ctrl_map(input[sub_dev].bustype, input[sub_dev].vid, input[sub_dev].pid, input[sub_dev].version, pool[sub_dev].fd, input[sub_dev].name, input[dev].mmap);\n\t\t\t}\n\t\t\tif (!input[dev].mmap[SYS_BTN_OSD_KTGL + 2]) input[dev].mmap[SYS_BTN_OSD_KTGL + 2] = input[dev].mmap[SYS_BTN_OSD_KTGL + 1];\n\n\t\t\tif (input[dev].quirk == QUIRK_WHEEL)\n\t\t\t{\n\t\t\t\tinput[dev].mmap[SYS_AXIS_MX] = -1;\n\t\t\t\tinput[dev].mmap[SYS_AXIS_MY] = -1;\n\t\t\t\tinput[dev].mmap[SYS_AXIS_X] = -1;\n\t\t\t\tinput[dev].mmap[SYS_AXIS_Y] = -1;\n\t\t\t\tinput[dev].mmap[SYS_AXIS1_X] = -1;\n\t\t\t\tinput[dev].mmap[SYS_AXIS1_Y] = -1;\n\t\t\t\tinput[dev].mmap[SYS_AXIS2_X] = -1;\n\t\t\t\tinput[dev].mmap[SYS_AXIS2_Y] = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (input[dev].mmap[SYS_AXIS_X] == input[dev].mmap[SYS_AXIS1_X])\n\t\t\t\t{\n\t\t\t\t\tinput[dev].stick_l[0] = SYS_AXIS1_X;\n\t\t\t\t\tif ((input[dev].mmap[SYS_AXIS2_X] >> 16) == 2) input[dev].stick_r[0] = SYS_AXIS2_X;\n\t\t\t\t}\n\t\t\t\tif (input[dev].mmap[SYS_AXIS_Y] == input[dev].mmap[SYS_AXIS1_Y])\n\t\t\t\t{\n\t\t\t\t\tinput[dev].stick_l[1] = SYS_AXIS1_Y;\n\t\t\t\t\tif ((input[dev].mmap[SYS_AXIS2_Y] >> 16) == 2) input[dev].stick_r[1] = SYS_AXIS2_Y;\n\t\t\t\t}\n\t\t\t\tif (input[dev].mmap[SYS_AXIS_X] == input[dev].mmap[SYS_AXIS2_X])\n\t\t\t\t{\n\t\t\t\t\tinput[dev].stick_l[0] = SYS_AXIS2_X;\n\t\t\t\t\tif ((input[dev].mmap[SYS_AXIS1_X] >> 16) == 2) input[dev].stick_r[0] = SYS_AXIS1_X;\n\t\t\t\t}\n\t\t\t\tif (input[dev].mmap[SYS_AXIS_Y] == input[dev].mmap[SYS_AXIS2_Y])\n\t\t\t\t{\n\t\t\t\t\tinput[dev].stick_l[1] = SYS_AXIS2_Y;\n\t\t\t\t\tif ((input[dev].mmap[SYS_AXIS1_Y] >> 16) == 2) input[dev].stick_r[1] = SYS_AXIS1_Y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinput[dev].has_mmap++;\n\t}\n\n\tif (!input[dev].has_map)\n\t{\n\t\tif (input[dev].quirk == QUIRK_PDSP || input[dev].quirk == QUIRK_MSSP)\n\t\t{\n\t\t\tmemset(input[dev].map, 0, sizeof(input[dev].map));\n\t\t\tinput[dev].map[map_paddle_btn()] = 0x120;\n\t\t}\n\t\telse if (!load_map(get_map_name(dev, 0), &input[dev].map, sizeof(input[dev].map)))\n\t\t{\n\t\t\tmemset(input[dev].map, 0, sizeof(input[dev].map));\n\t\t\tif (!is_menu())\n\t\t\t{\n\t\t\t\tif (input[dev].has_mmap == 1)\n\t\t\t\t{\n\t\t\t\t\t// not defined try to guess the mapping\n\t\t\t\t\tmap_joystick(input[dev].map, input[dev].mmap);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinput[dev].has_map++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinput[dev].has_map++;\n\t\t}\n\t\tinput[dev].has_map++;\n\t}\n\n\tif (!input[dev].has_jkmap)\n\t{\n\t\tif (!load_map(get_jkmap_name(dev), &input[dev].jkmap, sizeof(input[dev].jkmap)))\n\t\t{\n\t\t\tmemset(input[dev].jkmap, 0, sizeof(input[dev].jkmap));\n\t\t}\n\t\tinput[dev].has_jkmap = 1;\n\t}\n\n\tif (!input[dev].num)\n\t{\n\t\tint assign_btn = ((input[dev].quirk == QUIRK_PDSP || input[dev].quirk == QUIRK_MSSP) && (ev->type == EV_REL || ev->type == EV_KEY));\n\t\tif (!assign_btn && ev->type == EV_KEY && ev->value >= 1 && ev->code >= 256)\n\t\t{\n\t\t\tfor (int i = SYS_BTN_RIGHT; i <= SYS_BTN_START; i++)\n\t\t\t{\n\t\t\t\tif (ev->code == input[dev].mmap[i]) assign_btn = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (assign_btn)\n\t\t{\n\t\t\tfor (uint8_t i = 0; i < (sizeof(cfg.player_controller) / sizeof(cfg.player_controller[0])); i++)\n\t\t\t{\n\t\t\t\tfor (int n = 0; n < 8; n++)\n\t\t\t\t{\n\t\t\t\t\tif (!cfg.player_controller[i][n][0]) break;\n\n\t\t\t\t\tif (strcasestr(input[dev].id, cfg.player_controller[i][n]))\n\t\t\t\t\t{\n\t\t\t\t\t\tassign_player(dev, i + 1, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (strcasestr(input[dev].sysfs, cfg.player_controller[i][n]))\n\t\t\t\t\t{\n\t\t\t\t\t\tassign_player(dev, i + 1, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (strcasestr(get_unique_mapping(dev, 1), cfg.player_controller[i][n]))\n\t\t\t\t\t{\n\t\t\t\t\t\tassign_player(dev, i + 1, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!input[dev].num)\n\t\t\t{\n\t\t\t\tfor (uint8_t num = 1; num < NUMDEV + 1; num++)\n\t\t\t\t{\n\t\t\t\t\tint found = 0;\n\t\t\t\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (input[i].quirk != QUIRK_TOUCHGUN)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// paddles/spinners overlay on top of other gamepad\n\t\t\t\t\t\t\tif (!((input[dev].quirk == QUIRK_PDSP || input[dev].quirk == QUIRK_MSSP) ^ (input[i].quirk == QUIRK_PDSP || input[i].quirk == QUIRK_MSSP)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = (input[i].num == num);\n\t\t\t\t\t\t\t\tif (found) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!found)\n\t\t\t\t\t{\n\t\t\t\t\t\tassign_player(dev, num);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!input[dev].map_shown && input[dev].num)\n\t{\n\t\tinput[dev].map_shown = 1;\n\t\tif (JOYCON_COMBINED(dev)) input[input[dev].bind].map_shown = 1;\n\t\tstore_player(input[dev].num, dev);\n\n\t\tif (cfg.controller_info)\n\t\t{\n\t\t\tif (input[dev].quirk == QUIRK_PDSP || input[dev].quirk == QUIRK_MSSP)\n\t\t\t{\n\t\t\t\tchar str[32];\n\t\t\t\tsprintf(str, \"P%d paddle/spinner\", input[dev].num);\n\t\t\t\tInfo(str, cfg.controller_info * 1000);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmap_joystick_show(input[dev].map, input[dev].mmap, input[dev].num);\n\t\t\t}\n\t\t}\n\t}\n\n\tint old_combo = input[dev].osd_combo;\n\n\tif (ev->type == EV_KEY)\n\t{\n\t\tif (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 2])\n\t\t{\n\t\t\tif (ev->value) input[dev].osd_combo |= 2;\n\t\t\telse input[dev].osd_combo &= ~2;\n\t\t}\n\n\t\tif (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 1])\n\t\t{\n\t\t\tif (ev->value) input[dev].osd_combo |= 1;\n\t\t\telse input[dev].osd_combo &= ~1;\n\t\t}\n\t}\n\n\tint osd_event = 0;\n\tif (old_combo != 3 && input[dev].osd_combo == 3)\n\t{\n\t\tosd_event = 1;\n\t\tif (mapping && !is_menu()) osd_timer = GetTimer(1000);\n\t}\n\telse if (old_combo == 3 && input[dev].osd_combo != 3)\n\t{\n\t\tosd_event = 2;\n\t\tif (mapping && !is_menu())\n\t\t{\n\t\t\tif (CheckTimer(osd_timer))\n\t\t\t{\n\t\t\t\tcancel = 1;\n\t\t\t\tev->code = KEY_ESC;\n\t\t\t\tev->value = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmap_skip = 1;\n\t\t\t\tev->value = 1;\n\t\t\t}\n\t\t}\n\t\tosd_timer = 0;\n\t}\n\n\tif (mapping && mapping_type == 3)\n\t{\n\t\tif (map_skip)\n\t\t{\n\t\t\tmapping_finish = 1;\n\t\t\tev->value = 0;\n\t\t}\n\t\tosd_event = 0;\n\t}\n\n\t//mapping\n\tif (mapping && (mapping_dev >= 0 || ev->value)\n\t\t&& !((mapping_type < 2 || !mapping_button) && (cancel || enter))\n\t\t&& input[dev].quirk != QUIRK_PDSP\n\t\t&& input[dev].quirk != QUIRK_MSSP)\n\t{\n\t\tint idx = 0;\n\t\tosdbtn = 0;\n\n\t\tif (is_menu())\n\t\t{\n\t\t\tspi_uio_cmd(UIO_KEYBOARD); //ping the Menu core to wakeup\n\t\t\tosd_event = 0;\n\t\t}\n\n\t\t// paddle axis - skip from mapping\n\t\tif ((ev->type == EV_ABS || ev->type == EV_REL) && (ev->code == 7 || ev->code == 8) && input[dev].quirk != QUIRK_WHEEL) return;\n\n\t\t// protection against joysticks generating 2 codes per button\n\t\tif (ev->type == EV_KEY && !(is_menu() && mapping < 2 && mapping_button == SYS_BTN_OSD_KTGL) && !map_skip)\n\t\t{\n\t\t\tif (!mapping_current_key)\n\t\t\t{\n\t\t\t\tif (ev->value == 1)\n\t\t\t\t{\n\t\t\t\t\tmapping_current_key = ev->code;\n\t\t\t\t\tmapping_current_dev = dev;\n\t\t\t\t}\n\t\t\t\telse return;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (ev->value == 0 && mapping_current_key == ev->code && mapping_current_dev == dev)\n\t\t\t\t{\n\t\t\t\t\tmapping_current_key = 0;\n\t\t\t\t}\n\t\t\t\telse return;\n\t\t\t}\n\t\t}\n\n\t\tif (map_skip) mapping_current_key = 0;\n\n\t\tif (ev->type == EV_KEY && mapping_button>=0 && !osd_event)\n\t\t{\n\t\t\tif (mapping_type == 2) // keyboard remap\n\t\t\t{\n\t\t\t\tif (ev->code < 256)\n\t\t\t\t{\n\t\t\t\t\tif (!mapping_button)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ev->value == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (mapping_dev < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmapping_dev = dev;\n\t\t\t\t\t\t\t\tmapping_button = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!mapping_button) mapping_button = ev->code;\n\t\t\t\t\t\t\tmapping_current_dev = mapping_dev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ev->value == 0 && mapping_dev >= 0 && mapping_button != ev->code)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[mapping_dev].kbdmap[mapping_button] = ev->code;\n\t\t\t\t\t\t\tmapping_button = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (mapping_type == 3) // button remap\n\t\t\t{\n\t\t\t\tif (input[dev].mmap[SYS_BTN_OSD_KTGL] == ev->code ||\n\t\t\t\t\tinput[dev].mmap[SYS_BTN_OSD_KTGL + 1] == ev->code ||\n\t\t\t\t\tinput[dev].mmap[SYS_BTN_OSD_KTGL + 2] == ev->code) return;\n\n\t\t\t\tif (ev->value == 1 && !mapping_button)\n\t\t\t\t{\n\t\t\t\t\tif (mapping_dev < 0) mapping_dev = dev;\n\t\t\t\t\tif (mapping_dev == dev && ev->code < 1024) mapping_button = ev->code;\n\t\t\t\t\tmapping_current_dev = mapping_dev;\n\t\t\t\t}\n\n\t\t\t\tif (mapping_dev >= 0 && (ev->code < 256 || mapping_dev == dev) && mapping_button && mapping_button != ev->code)\n\t\t\t\t{\n\t\t\t\t\tif (ev->value == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Technically it's hard to map the key to button as keyboards\n\t\t\t\t\t\t// are all the same while joysticks are personalized and numbered.\n\t\t\t\t\t\tinput[mapping_dev].jkmap[mapping_button] = ev->code;\n\t\t\t\t\t\tmapping_current_dev = dev;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ev->value == 0) mapping_button = 0;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint clear = (ev->code == KEY_F12 || ev->code == KEY_MENU || ev->code == KEY_HOMEPAGE) && !is_menu();\n\t\t\t\tif (ev->value == 1 && mapping_dev < 0 && !clear)\n\t\t\t\t{\n\t\t\t\t\tmapping_dev = dev;\n\t\t\t\t\tmapping_type = (ev->code >= 256) ? 1 : 0;\n\t\t\t\t\tkey_mapped = 0;\n\t\t\t\t\tmemset(input[mapping_dev].map, 0, sizeof(input[mapping_dev].map));\n\t\t\t\t}\n\n\t\t\t\tmapping_clear = 0;\n\t\t\t\tif (mapping_dev >= 0 && !map_skip && (mapping_dev == dev || clear) && mapping_button < (is_menu() ? (mapping_type ? SYS_BTN_CNT_ESC + 1 : SYS_BTN_OSD_KTGL + 1) : mapping_count))\n\t\t\t\t{\n\t\t\t\t\tif (ev->value == 1 && !key_mapped)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (is_menu())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (mapping_dev == dev && !(!mapping_button && last_axis && ((ev->code == last_axis) || (ev->code == last_axis + 1))))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!mapping_button) memset(input[dev].map, 0, sizeof(input[dev].map));\n\t\t\t\t\t\t\t\tinput[dev].osd_combo = 0;\n\n\t\t\t\t\t\t\t\tint found = 0;\n\t\t\t\t\t\t\t\tif (mapping_button < SYS_BTN_CNT_OK)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (int i = (mapping_button >= BUTTON_DPAD_COUNT) ? BUTTON_DPAD_COUNT : 0; i < mapping_button; i++) if (input[dev].map[i] == ev->code) found = 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!found || (mapping_button == SYS_BTN_OSD_KTGL && mapping_type))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (mapping_button == SYS_BTN_CNT_OK) input[dev].map[SYS_BTN_MENU_FUNC] = ev->code & 0xFFFF;\n\t\t\t\t\t\t\t\t\telse if (mapping_button == SYS_BTN_CNT_ESC) input[dev].map[SYS_BTN_MENU_FUNC] = (ev->code << 16) | input[dev].map[SYS_BTN_MENU_FUNC];\n\t\t\t\t\t\t\t\t\telse if (mapping_button == SYS_BTN_OSD_KTGL)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinput[dev].map[SYS_BTN_OSD_KTGL + mapping_type] = ev->code;\n\t\t\t\t\t\t\t\t\t\tinput[dev].map[SYS_BTN_OSD_KTGL + 2] = input[dev].map[SYS_BTN_OSD_KTGL + 1];\n\t\t\t\t\t\t\t\t\t\tmapping_current_key = 0; // allow 2 buttons to be pressed\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse input[dev].map[mapping_button] = ev->code;\n\n\t\t\t\t\t\t\t\t\tkey_mapped = ev->code;\n\n\t\t\t\t\t\t\t\t\t//check if analog stick has been used for mouse\n\t\t\t\t\t\t\t\t\tif (mapping_button == BUTTON_DPAD_COUNT + 1 || mapping_button == BUTTON_DPAD_COUNT + 3)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (input[dev].map[mapping_button] >= KEY_EMU &&\n\t\t\t\t\t\t\t\t\t\t\tinput[dev].map[mapping_button - 1] >= KEY_EMU &&\n\t\t\t\t\t\t\t\t\t\t\t(input[dev].map[mapping_button - 1] - input[dev].map[mapping_button] == 1) && // same axis\n\t\t\t\t\t\t\t\t\t\t\tabsinfo)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tinput[dev].map[SYS_AXIS_MX + (mapping_button - (BUTTON_DPAD_COUNT + 1)) / 2] = ((input[dev].map[mapping_button] - KEY_EMU) / 2) | 0x20000;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (clear)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemset(input[mapping_dev].map, 0, sizeof(input[mapping_dev].map));\n\t\t\t\t\t\t\t\tmapping_button = 0;\n\t\t\t\t\t\t\t\tmapping_clear = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!mapping_button)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (uint i = 0; i < sizeof(input[0].map) / sizeof(input[0].map[0]); i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinput[dev].map[i] &= mapping_set ? 0x0000FFFF : 0xFFFF0000;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tint found = 0;\n\t\t\t\t\t\t\t\tfor (int i = 0; i < mapping_button; i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (mapping_set && (input[dev].map[i] >> 16) == ev->code) found = 1;\n\t\t\t\t\t\t\t\t\tif (!mapping_set && (input[dev].map[i] & 0xFFFF) == ev->code) found = 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!found)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (mapping_set) input[dev].map[mapping_button] = (input[dev].map[mapping_button] & 0xFFFF) | (ev->code << 16);\n\t\t\t\t\t\t\t\t\telse input[dev].map[mapping_button] = (input[dev].map[mapping_button] & 0xFFFF0000) | ev->code;\n\t\t\t\t\t\t\t\t\tkey_mapped = ev->code;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//combo for osd button\n\t\t\t\t\tif (ev->value == 1 && key_mapped && key_mapped != ev->code && is_menu() && mapping_button == SYS_BTN_OSD_KTGL && mapping_type)\n\t\t\t\t\t{\n\t\t\t\t\t\tinput[dev].map[SYS_BTN_OSD_KTGL + 2] = ev->code;\n\t\t\t\t\t\tprintf(\"Set combo: %x + %x\\n\", input[dev].map[SYS_BTN_OSD_KTGL + 1], input[dev].map[SYS_BTN_OSD_KTGL + 2]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(mapping_dev == dev && ev->value == 0 && key_mapped == ev->code)\n\t\t\t\t\t{\n\t\t\t\t\t\tmapping_button++;\n\t\t\t\t\t\tkey_mapped = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!ev->value && mapping_dev == dev && ((ev->code == last_axis) || (ev->code == last_axis+1)))\n\t\t\t\t\t{\n\t\t\t\t\t\tlast_axis = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (is_menu())\n\t\t{\n\t\t\t//Define min-0-max analogs\n\t\t\tswitch (mapping_button)\n\t\t\t{\n\t\t\t\tcase 23: idx = SYS_AXIS_X;  break;\n\t\t\t\tcase 24: idx = SYS_AXIS_Y;  break;\n\t\t\t\tcase -4: idx = SYS_AXIS1_X; break;\n\t\t\t\tcase -3: idx = SYS_AXIS1_Y; break;\n\t\t\t\tcase -2: idx = SYS_AXIS2_X; break;\n\t\t\t\tcase -1: idx = SYS_AXIS2_Y; break;\n\t\t\t}\n\n\t\t\tif (mapping_dev == dev || (mapping_dev < 0 && mapping_button < 0))\n\t\t\t{\n\t\t\t\tint max = 0; // , min = 0;\n\n\t\t\t\tif (ev->type == EV_ABS)\n\t\t\t\t{\n\t\t\t\t\tint threshold = (absinfo->maximum - absinfo->minimum) / 5;\n\n\t\t\t\t\tmax = (ev->value >= (absinfo->maximum - threshold));\n\t\t\t\t\t//min = (ev->value <= (absinfo->minimum + threshold));\n\t\t\t\t\t//printf(\"threshold=%d, min=%d, max=%d\\n\", threshold, min, max);\n\t\t\t\t}\n\n\t\t\t\t//check DPAD horz\n\t\t\t\tif (mapping_button == -6)\n\t\t\t\t{\n\t\t\t\t\tlast_axis = 0;\n\t\t\t\t\tif (ev->type == EV_ABS && max)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mapping_dev < 0) mapping_dev = dev;\n\t\t\t\t\t\tmapping_type = 1;\n\n\t\t\t\t\t\tif (absinfo->maximum > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp_axis[tmp_axis_n++] = ev->code | 0x20000;\n\t\t\t\t\t\t\tmapping_button++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//Standard DPAD event\n\t\t\t\t\t\t\tmapping_button += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (ev->type == EV_KEY && ev->value == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t//DPAD uses simple button events\n\t\t\t\t\t\tif (!map_skip)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmapping_button += 2;\n\t\t\t\t\t\t\tif (mapping_dev < 0) mapping_dev = dev;\n\t\t\t\t\t\t\tif (ev->code < 256)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// keyboard, skip stick 1/2\n\t\t\t\t\t\t\t\tmapping_button += 4;\n\t\t\t\t\t\t\t\tmapping_type = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//check DPAD vert\n\t\t\t\telse if (mapping_button == -5)\n\t\t\t\t{\n\t\t\t\t\tif (ev->type == EV_ABS && max && absinfo->maximum > 1 && ev->code != (tmp_axis[0] & 0xFFFF))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp_axis[tmp_axis_n++] = ev->code | 0x20000;\n\t\t\t\t\t\tmapping_button++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//Sticks\n\t\t\t\telse if (ev->type == EV_ABS && idx)\n\t\t\t\t{\n\t\t\t\t\tif (mapping_dev < 0) mapping_dev = dev;\n\n\t\t\t\t\tif (idx && max && absinfo->maximum > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mapping_button < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint found = 0;\n\t\t\t\t\t\t\tfor (int i = 0; i < tmp_axis_n; i++) if (ev->code == (tmp_axis[i] & 0xFFFF)) found = 1;\n\t\t\t\t\t\t\tif (!found)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmapping_type = 1;\n\t\t\t\t\t\t\t\ttmp_axis[tmp_axis_n++] = ev->code | 0x20000;\n\t\t\t\t\t\t\t\t//if (min) tmp_axis[idx - AXIS1_X] |= 0x10000;\n\t\t\t\t\t\t\t\tmapping_button++;\n\t\t\t\t\t\t\t\tif (tmp_axis_n >= 4) mapping_button = 0;\n\t\t\t\t\t\t\t\tlast_axis = KEY_EMU + (ev->code << 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (idx == SYS_AXIS_X || ev->code != (input[dev].map[idx - 1] & 0xFFFF))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinput[dev].map[idx] = ev->code | 0x20000;\n\t\t\t\t\t\t\t\t//if (min) input[dev].map[idx] |= 0x10000;\n\t\t\t\t\t\t\t\tmapping_button++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (mapping_type <= 1 && mapping_button < mapping_count)\n\t\t{\n\t\t\tif (map_skip)\n\t\t\t{\n\t\t\t\tif (map_skip == 2 || ev->value == 1)\n\t\t\t\t{\n\t\t\t\t\tif (mapping_dev >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (idx) input[mapping_dev].map[idx] = 0;\n\t\t\t\t\t\telse if (mapping_button > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!is_menu()) input[mapping_dev].map[mapping_button] &= mapping_set ? 0x0000FFFF : 0xFFFF0000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlast_axis = 0;\n\t\t\t\t\tmapping_button++;\n\t\t\t\t\tif (mapping_button < 0 && (mapping_button & 1)) mapping_button++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmap_skip = 0;\n\t\t\tif (mapping_button >= 4 && !is_menu() && !strcmp(joy_bnames[mapping_button - 4], \"-\")) map_skip = 2;\n\t\t\tif (!map_skip) break;\n\t\t}\n\n\t\tif (is_menu() && mapping_type <= 1 && mapping_dev >= 0)\n\t\t{\n\t\t\tmemcpy(&input[mapping_dev].mmap[SYS_AXIS1_X], tmp_axis, sizeof(tmp_axis));\n\t\t\tmemcpy(&input[mapping_dev].map[SYS_AXIS1_X], tmp_axis, sizeof(tmp_axis));\n\t\t}\n\t}\n\telse\n\t{\n\t\tkey_mapped = 0;\n\t\tswitch (ev->type)\n\t\t{\n\t\tcase EV_KEY:\n\t\t\tif (ev->code < 1024 && input[dev].jkmap[ev->code] && !user_io_osd_is_visible()) ev->code = input[dev].jkmap[ev->code];\n\n\t\t\t//joystick buttons, digital directions\n\t\t\tif (ev->code >= 256)\n\t\t\t{\n\t\t\t\tif (input[dev].lightgun_req && !user_io_osd_is_visible())\n\t\t\t\t{\n\t\t\t\t\tif (osd_event == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tinput[dev].lightgun = !input[dev].lightgun;\n\t\t\t\t\t\tInfo(input[dev].lightgun ? \"Light Gun mode is ON\" : \"Light Gun mode is OFF\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (osd_event == 1) joy_digital(input[dev].num, 0, 0, 1, BTN_OSD);\n\t\t\t\t\tif (osd_event == 2) joy_digital(input[dev].num, 0, 0, 0, BTN_OSD);\n\t\t\t\t}\n\n\t\t\t\tif (user_io_osd_is_visible() || video_fb_state())\n\t\t\t\t{\n\t\t\t\t\tif (ev->value <= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((input[dev].mmap[SYS_BTN_MENU_FUNC] & 0xFFFF) ?\n\t\t\t\t\t\t\t(ev->code == (input[dev].mmap[SYS_BTN_MENU_FUNC] & 0xFFFF)) :\n\t\t\t\t\t\t\t(ev->code == input[dev].mmap[SYS_BTN_A]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_BTN1, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((input[dev].mmap[SYS_BTN_MENU_FUNC] >> 16) ?\n\t\t\t\t\t\t\t(ev->code == (input[dev].mmap[SYS_BTN_MENU_FUNC] >> 16)) :\n\t\t\t\t\t\t\t(ev->code == input[dev].mmap[SYS_BTN_B]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_BTN2, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_X])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_BTN4, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_Y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_BTN3, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_L])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_L, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_R])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_R, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_START])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_L2, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_SELECT])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_digital(0, JOY_R2, 0, ev->value, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 0; i < SYS_BTN_A; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ev->code == input[dev].mmap[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tjoy_digital(0, 1 << i, 0, ev->value, i);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = SYS_MS_RIGHT; i <= SYS_MS_UP; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ev->code == input[dev].mmap[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint n = i - SYS_MS_RIGHT;\n\t\t\t\t\t\t\t\tjoy_digital(0, 1 << n, 0, ev->value, n);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[dev].quirk != QUIRK_WHEEL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (input[dev].mmap[SYS_AXIS_X])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuint16_t key = KEY_EMU + ((uint16_t)input[dev].mmap[SYS_AXIS_X] * 2);\n\t\t\t\t\t\t\t\tif (ev->code == (key + 1)) joy_digital(0, 1 << 0, 0, ev->value, 0);\n\t\t\t\t\t\t\t\tif (ev->code == key) joy_digital(0, 1 << 1, 0, ev->value, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (input[dev].mmap[SYS_AXIS_Y])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuint16_t key = KEY_EMU + ((uint16_t)input[dev].mmap[SYS_AXIS_Y] * 2);\n\t\t\t\t\t\t\t\tif (ev->code == (key + 1)) joy_digital(0, 1 << 2, 0, ev->value, 2);\n\t\t\t\t\t\t\t\tif (ev->code == key) joy_digital(0, 1 << 3, 0, ev->value, 3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mouse_emu)\n\t\t\t\t\t{\n\t\t\t\t\t\tint use_analog = (input[dev].mmap[SYS_AXIS_MX] || input[dev].mmap[SYS_AXIS_MY]);\n\n\t\t\t\t\t\tfor (int i = (use_analog ? SYS_MS_BTN_L : SYS_MS_RIGHT); i <= SYS_MS_BTN_M; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ev->code == input[dev].mmap[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tswitch (i)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase SYS_MS_RIGHT:\n\t\t\t\t\t\t\t\t\tmouse_emu_x = ev->value ? 10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase SYS_MS_LEFT:\n\t\t\t\t\t\t\t\t\tmouse_emu_x = ev->value ? -10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase SYS_MS_DOWN:\n\t\t\t\t\t\t\t\t\tmouse_emu_y = ev->value ? 10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase SYS_MS_UP:\n\t\t\t\t\t\t\t\t\tmouse_emu_y = ev->value ? -10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tmouse_btn = ev->value ? mouse_btn | 1 << (i - SYS_MS_BTN_L) : mouse_btn & ~(1 << (i - SYS_MS_BTN_L));\n\t\t\t\t\t\t\t\t\tmouse_btn_req();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (input[dev].has_map >= 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (input[dev].has_map == 3) Info(\"This joystick is not defined\");\n\t\t\t\t\t\tinput[dev].has_map = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (uint i = 0; i < BTN_NUM; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64_t mask = 0;\n\t\t\t\t\t\tif (ev->code == (input[dev].map[i] & 0xFFFF)) mask = (uint64_t)1 << i;\n\t\t\t\t\t\telse if (ev->code == (input[dev].map[i] >> 16)) mask = (uint64_t)1 << (i + 32); // 1 is uint32_t. i spent hours realizing this.\n\t\t\t\t\t\tif (mask) {\n\t\t\t\t\t\t\tif (i <= 3 && origcode == ev->code) origcode = 0; // prevent autofire for original dpad\n\t\t\t\t\t\t\tif (ev->value <=1) joy_digital(input[dev].num, mask, origcode, ev->value, i, (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 1] || ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 2]));\n\t\t\t\t\t\t\t// support 2 simultaneous functions for 1 button if defined in 2 sets. No return.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_MS_BTN_EMU] && (ev->value <= 1) && ((!(mouse_emu & 1)) ^ (!ev->value)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmouse_emu = ev->value ? mouse_emu | 1 : mouse_emu & ~1;\n\t\t\t\t\t\tif (input[sub_dev].quirk == QUIRK_DS4) input[dev].ds_mouse_emu = mouse_emu & 1;\n\t\t\t\t\t\tif (mouse_emu & 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmouse_sniper = ev->value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmouse_timer = 0;\n\t\t\t\t\t\t\tmouse_btn = 0;\n\t\t\t\t\t\t\tmouse_emu_x = 0;\n\t\t\t\t\t\t\tmouse_emu_y = 0;\n\t\t\t\t\t\t\tmouse_cb();\n\t\t\t\t\t\t\tmouse_btn_req();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// keyboard\n\t\t\telse\n\t\t\t{\n\t\t\t\t//  replace MENU key by RGUI to allow using Right Amiga on reduced keyboards\n\t\t\t\t// (it also disables the use of Menu for OSD)\n\t\t\t\tif (cfg.key_menu_as_rgui && ev->code == KEY_COMPOSE) ev->code = KEY_RIGHTMETA;\n\n\t\t\t\t//Keyrah v2: USB\\VID_18D8&PID_0002\\A600/A1200_MULTIMEDIA_EXTENSION_VERSION\n\t\t\t\tint keyrah = (cfg.keyrah_mode && (((((uint32_t)input[dev].vid) << 16) | input[dev].pid) == cfg.keyrah_mode));\n\t\t\t\tif (keyrah) ev->code = keyrah_trans(ev->code, ev->value);\n\n\t\t\t\tuint32_t ps2code = get_ps2_code(ev->code);\n\t\t\t\tif (ev->value) modifier |= ps2code;\n\t\t\t\telse modifier &= ~ps2code;\n\n\t\t\t\tuint16_t reset_m = (modifier & MODMASK) >> 8;\n\t\t\t\tif (ev->code == 111) reset_m |= 0x100;\n\t\t\t\tuser_io_check_reset(reset_m, (keyrah && !cfg.reset_combo) ? 1 : cfg.reset_combo);\n\n\t\t\t\tif(!user_io_osd_is_visible() && ((user_io_get_kbdemu() == EMU_JOY0) || (user_io_get_kbdemu() == EMU_JOY1)) && !video_fb_state())\n\t\t\t\t{\n\t\t\t\t\tif (!kbd_toggle)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (uint i = 0; i < BTN_NUM; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ev->code == (uint16_t)input[dev].map[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (i <= 3 && origcode == ev->code) origcode = 0; // prevent autofire for original dpad\n\t\t\t\t\t\t\t\tif (ev->value <= 1) joy_digital((user_io_get_kbdemu() == EMU_JOY0) ? 1 : 2, 1 << i, origcode, ev->value, i);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ev->value <= 1) joy_digital((user_io_get_kbdemu() == EMU_JOY0) ? 1 : 2, 0, 0, ev->value, BTN_TGL);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tkbd_toggle = 0;\n\t\t\t\t}\n\n\t\t\t\tif (!user_io_osd_is_visible() && (user_io_get_kbdemu() == EMU_MOUSE))\n\t\t\t\t{\n\t\t\t\t\tif (kbd_mouse_emu)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = SYS_MS_RIGHT; i <= SYS_MS_BTN_M; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ev->code == input[dev].mmap[i])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tswitch (i)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase SYS_MS_RIGHT:\n\t\t\t\t\t\t\t\t\tmouse_emu_x = ev->value ? 10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase SYS_MS_LEFT:\n\t\t\t\t\t\t\t\t\tmouse_emu_x = ev->value ? -10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase SYS_MS_DOWN:\n\t\t\t\t\t\t\t\t\tmouse_emu_y = ev->value ? 10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase SYS_MS_UP:\n\t\t\t\t\t\t\t\t\tmouse_emu_y = ev->value ? -10 : 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tmouse_btn = ev->value ? mouse_btn | 1 << (i - SYS_MS_BTN_L) : mouse_btn & ~(1 << (i - SYS_MS_BTN_L));\n\t\t\t\t\t\t\t\t\tmouse_btn_req();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_MS_BTN_EMU])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ev->value <= 1) mouse_sniper = ev->value;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ev->value == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkbd_mouse_emu = !kbd_mouse_emu;\n\t\t\t\t\t\t\tprintf(\"kbd_mouse_emu = %d\\n\", kbd_mouse_emu);\n\n\t\t\t\t\t\t\tmouse_timer = 0;\n\t\t\t\t\t\t\tmouse_btn = 0;\n\t\t\t\t\t\t\tmouse_emu_x = 0;\n\t\t\t\t\t\t\tmouse_emu_y = 0;\n\t\t\t\t\t\t\tmouse_cb();\n\t\t\t\t\t\t\tmouse_btn_req();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ev->code == KEY_HOMEPAGE) ev->code = KEY_MENU;\n\t\t\t\tuser_io_kbd(ev->code, ev->value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t//analog joystick\n\t\tcase EV_ABS:\n\t\t\tif (!user_io_osd_is_visible())\n\t\t\t{\n\t\t\t\tint value = ev->value;\n\t\t\t\tif (ev->value < absinfo->minimum) value = absinfo->minimum;\n\t\t\t\telse if (ev->value > absinfo->maximum) value = absinfo->maximum;\n\n\t\t\t\tif (ev->code == 8 && input[dev].quirk != QUIRK_WHEEL)\n\t\t\t\t{\n\t\t\t\t\tif (input[dev].num && input[dev].num <= NUMPLAYERS)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue -= absinfo->minimum;\n\t\t\t\t\t\tvalue = (value * 255) / (absinfo->maximum - absinfo->minimum);\n\t\t\t\t\t\tuser_io_l_analog_joystick(((input[dev].num - 1) << 4) | 0xF, value, 0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint hrange = (absinfo->maximum - absinfo->minimum) / 2;\n\n\t\t\t\t// normalize to -range/2...+range/2\n\t\t\t\tvalue -= (absinfo->minimum + absinfo->maximum) / 2;\n\n\t\t\t\tint range = is_psx() ? 128 : 127;\n\t\t\t\tvalue = (value * range) / hrange;\n\n\t\t\t\t// final check to eliminate additive error\n\t\t\t\tif (value < -range) value = -range;\n\t\t\t\telse if (value > 127) value = 127;\n\n\t\t\t\tif (input[sub_dev].axis_pos[ev->code & 0xFF] == (int8_t)value) break;\n\t\t\t\tinput[sub_dev].axis_pos[ev->code & 0xFF] = (int8_t)value;\n\n\t\t\t\tif (ev->code == (input[dev].mmap[SYS_AXIS_MX] & 0xFFFF) && mouse_emu)\n\t\t\t\t{\n\t\t\t\t\tmouse_emu_x = 0;\n\t\t\t\t\tif (value < -1 || value > 1) mouse_emu_x = value;\n\t\t\t\t\tmouse_emu_x /= 12;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if (ev->code == (input[dev].mmap[SYS_AXIS_MY] & 0xFFFF) && mouse_emu)\n\t\t\t\t{\n\t\t\t\t\tmouse_emu_y = 0;\n\t\t\t\t\tif (value < -1 || value > 1) mouse_emu_y = value;\n\t\t\t\t\tmouse_emu_y /= 12;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// skip if joystick is undefined.\n\t\t\t\t\tif (!input[dev].num) break;\n\n\t\t\t\t\tif (input[dev].quirk == QUIRK_WHEEL)\n\t\t\t\t\t{\n\t\t\t\t\t\tint wh_value = ((127 * (ev->value - absinfo->minimum)) / (absinfo->maximum - absinfo->minimum)) - 127;\n\t\t\t\t\t\tif (input[dev].wh_pedal_invert > 0) {\n\t\t\t\t\t\t\t// invert pedal values range for wheel setups that require it\n\t\t\t\t\t\t\twh_value = ~(wh_value + 127);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// steering wheel passes full range, pedals are standardised in +127 to 0 to -127 range\n\t\t\t\t\t\tif (ev->code == input[dev].wh_steer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 0, value, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ev->code == input[dev].wh_accel)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 1, wh_value, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ev->code == input[dev].wh_brake)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 1, wh_value, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ev->code == input[dev].wh_clutch)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 0, wh_value, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ev->code == input[dev].wh_combo)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// if accel and brake pedal use a shared axis then map negative to accel and positive to brake\n\t\t\t\t\t\t\tif (value < -1) joy_analog(dev, 1, value, 0);\n\t\t\t\t\t\t\telse if (value > 1) joy_analog(dev, 1, -value, 1);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tjoy_analog(dev, 1, 0, 0);\n\t\t\t\t\t\t\t\tjoy_analog(dev, 1, 0, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (ev->code == 0 && input[dev].lightgun)\n\t\t\t\t\t{\n\t\t\t\t\t\tjoy_analog(dev, 0, value);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ev->code == 1 && input[dev].lightgun)\n\t\t\t\t\t{\n\t\t\t\t\t\tjoy_analog(dev, 1, value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint offset = (value < -1 || value > 1) ? value : 0;\n\t\t\t\t\t\tif (input[dev].stick_l[0] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_l[0]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 0, offset, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (input[dev].stick_l[1] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_l[1]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 1, offset, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (input[dev].stick_r[0] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_r[0]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 0, offset, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (input[dev].stick_r[1] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_r[1]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tjoy_analog(dev, 1, offset, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// spinner\n\t\tcase EV_REL:\n\t\t\tif (!user_io_osd_is_visible() && ev->code == 7)\n\t\t\t{\n\t\t\t\tif (input[dev].num && input[dev].num <= NUMPLAYERS)\n\t\t\t\t{\n\t\t\t\t\tint value = ev->value;\n\t\t\t\t\tif (ev->value < -128) value = -128;\n\t\t\t\t\telse if (ev->value > 127) value = 127;\n\n\t\t\t\t\tuser_io_l_analog_joystick(((input[dev].num - 1) << 4) | 0x8F, value, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid send_map_cmd(int key)\n{\n\tif (mapping && mapping_dev >= 0)\n\t{\n\t\tinput_event ev;\n\t\tev.type = EV_KEY;\n\t\tev.code = key;\n\t\tev.value = 1;\n\t\tinput_cb(&ev, 0, mapping_dev);\n\t}\n}\n\n#define CMD_FIFO \"/dev/MiSTer_cmd\"\n#define LED_MONITOR \"/sys/class/leds/hps_led0/brightness_hw_changed\"\n\n// add sequential suffixes for non-merged devices\nvoid make_unique(uint16_t vid, uint16_t pid, int type)\n{\n\tint cnt = 0;\n\tint lastmin = -1;\n\tint min;\n\n\tprintf(\"make_unique(%04X,%04X,%d)\\n\", vid, pid, type);\n\n\twhile(1)\n\t{\n\t\tint idx = -1;\n\t\tmin = INT32_MAX;\n\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t{\n\t\t\tif ((!type && (input[i].vid == vid)) ||\n\t\t\t\t(type > 0 && (input[i].vid == vid) && (input[i].pid == pid)) ||\n\t\t\t\t(type < 0 && (input[i].vid == vid) && (input[i].pid != pid)))\n\t\t\t{\n\t\t\t\tint num = -1;\n\t\t\t\tconst char *n = strstr(input[i].devname, \"/event\");\n\t\t\t\tif (n) num = strtoul(n + 6, NULL, 10);\n\t\t\t\tif (num >= 0 && num < min && num > lastmin)\n\t\t\t\t{\n\t\t\t\t\tmin = num;\n\t\t\t\t\tidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (idx < 0) break;\n\n\t\tlastmin = min;\n\t\tsprintf(input[idx].id + strlen(input[idx].id), \"/%d\", cnt++);\n\t}\n}\n\nvoid mergedevs()\n{\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tmemset(input[i].id, 0, sizeof(input[i].id));\n\t}\n\n\tFILE *f = fopen(\"/proc/bus/input/devices\", \"r\");\n\tif (!f)\n\t{\n\t\tprintf(\"Failed to open /proc/bus/input/devices\\n\");\n\t\treturn;\n\t}\n\n\tstatic char str[1024];\n\tchar phys[64] = {};\n\tchar uniq[64] = {};\n\tchar id[64] = {};\n\tstatic char sysfs[512] = {};\n\n\twhile (fgets(str, sizeof(str), f))\n\t{\n\t\tint len = strlen(str);\n\t\twhile (len && str[len - 1] == '\\n') str[--len] = 0;\n\n\t\tif (!len)\n\t\t{\n\t\t\tphys[0] = 0;\n\t\t\tuniq[0] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!strncmp(\"P: Phys\", str, 7)) snprintf(phys, sizeof(phys), \"%s\", strchr(str, '=') + 1);\n\t\t\tif (!strncmp(\"U: Uniq\", str, 7)) snprintf(uniq, sizeof(uniq), \"%s\", strchr(str, '=') + 1);\n\t\t\tif (!strncmp(\"S: Sysfs\", str, 8)) snprintf(sysfs, sizeof(sysfs), \"%s\", strchr(str, '=') + 1);\n\n\t\t\tif (!strncmp(\"H: \", str, 3))\n\t\t\t{\n\t\t\t\tif (strlen(phys) && strlen(uniq)) snprintf(id, sizeof(id), \"%s/%s\", phys, uniq);\n\t\t\t\telse if (strlen(phys)) strcpy(id, phys);\n\t\t\t\telse strcpy(id, uniq);\n\n\t\t\t\tchar *handlers = strchr(str, '=');\n\t\t\t\tif (handlers && id[0])\n\t\t\t\t{\n\t\t\t\t\thandlers++;\n\t\t\t\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pool[i].fd >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *dev = strrchr(input[i].devname, '/');\n\t\t\t\t\t\t\tif (dev)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchar idsp[32];\n\t\t\t\t\t\t\t\tstrcpy(idsp, dev + 1);\n\t\t\t\t\t\t\t\tstrcat(idsp, \" \");\n\t\t\t\t\t\t\t\tif (strstr(handlers, idsp))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstrcpy(input[i].id, id);\n\t\t\t\t\t\t\t\t\tstrcpy(input[i].sysfs, sysfs);\n\t\t\t\t\t\t\t\t\tstrcpy(input[i].mac, uniq);\n\n\t\t\t\t\t\t\t\t\tinput[i].unique_hash = str_hash(input[i].id);\n\t\t\t\t\t\t\t\t\tinput[i].unique_hash = str_hash(input[i].mac, input[i].unique_hash);\n\n\t\t\t\t\t\t\t\t\tinput[i].timeout = (strlen(uniq) && strstr(sysfs, \"bluetooth\")) ? (cfg.bt_auto_disconnect * 10) : 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(f);\n\n\t//Bypass merging of specified 2 port/player controllers\n\tmake_unique(0x289B, 0x0057, -1); // Raphnet\n\tmake_unique(0x0E8F, 0x3013, 1);  // Mayflash SNES controller 2 port adapter\n\tmake_unique(0x16C0, 0x05E1, 1);  // XinMo XM-10 2 player USB Encoder\n\tmake_unique(0x045E, 0x02A1, 1);  // Xbox 360 wireless receiver\n\tmake_unique(0x8282, 0x3201, 1);  // Irken Labs JAMMA Expander / Mojo Retro Adapter\n\tmake_unique(0x1209, 0xFACA, 1);  // ControllaBLE\n\tmake_unique(0x16D0, 0x127E, 1);  // Reflex Adapt to USB\n\tmake_unique(0x1209, 0x595A, 1);  // RetroZord adapter\n\n\tif (cfg.no_merge_vid)\n\t{\n\t\tmake_unique(cfg.no_merge_vid, cfg.no_merge_pid, (cfg.no_merge_pid ? 1 : 0));\n\t}\n\n\tfor (int i = 0; i < (int)cfg.no_merge_vidpid[0]; i++) make_unique(cfg.no_merge_vidpid[i + 1] >> 16, (uint16_t)(cfg.no_merge_vidpid[i + 1]), 1);\n\n\t// merge multifunctional devices by id\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tinput[i].bind = i;\n\t\tif (input[i].id[0] && !input[i].mouse)\n\t\t{\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (!strcmp(input[i].id, input[j].id))\n\t\t\t\t{\n\t\t\t\t\tinput[i].bind = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//copy missing fields to mouseX\n\tfor (int i = 0; i < NUMDEV; i++) if (input[i].mouse)\n\t{\n\t\tfor (int j = 0; j < NUMDEV; j++) if (!input[j].mouse)\n\t\t{\n\t\t\tif (!strcmp(input[i].id, input[j].id))\n\t\t\t{\n\t\t\t\tinput[i].bind = j;\n\t\t\t\tinput[i].vid = input[j].vid;\n\t\t\t\tinput[i].pid = input[j].pid;\n\t\t\t\tinput[i].version = input[j].version;\n\t\t\t\tinput[i].bustype = input[j].bustype;\n\t\t\t\tinput[i].quirk = input[j].quirk;\n\t\t\t\tmemcpy(input[i].name, input[j].name, sizeof(input[i].name));\n\t\t\t\tmemcpy(input[i].idstr, input[j].idstr, sizeof(input[i].idstr));\n\n\t\t\t\tif (!input[i].quirk)\n\t\t\t\t{\n\t\t\t\t\t//All mice as spinners\n\t\t\t\t\tif ((cfg.spinner_vid == 0xFFFF && cfg.spinner_pid == 0xFFFF)\n\t\t\t\t\t\t//Mouse as spinner\n\t\t\t\t\t\t|| (cfg.spinner_vid && cfg.spinner_pid && input[i].vid == cfg.spinner_vid && input[i].pid == cfg.spinner_pid))\n\t\t\t\t\t{\n\t\t\t\t\t\tinput[i].quirk = QUIRK_MSSP;\n\t\t\t\t\t\tinput[i].bind = i;\n\t\t\t\t\t\tinput[i].spinner_prediv = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Arcade Spinner TS-BSP01 (X axis) and Atari (Y axis)\n\t\t\t\t\tif (input[i].vid == 0x32be && input[i].pid == 0x1420)\n\t\t\t\t\t{\n\t\t\t\t\t\tinput[i].quirk = QUIRK_MSSP;\n\t\t\t\t\t\tinput[i].bind = i;\n\t\t\t\t\t\tinput[i].spinner_prediv = 3;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (input[i].quirk == QUIRK_MSSP) strcat(input[i].id, \"_sp\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Jammasd/J-PAC/I-PAC have shifted keys: when 1P start is kept pressed, it acts as a shift key,\n// outputting other key signals. Example: 1P start + 2P start = KEY_ESC\n// Shifted keys are passed as normal keyboard keys.\nstatic struct\n{\n\tuint16_t key;\n\tuint16_t player;\n\tuint16_t btn;\n} jamma2joy[] =\n{\n\t{KEY_5,         1, 0x120}, // 1P coin\n\t{KEY_1,         1, 0x121}, // 1P start (shift key)\n\t{KEY_UP,        1, 0x122}, // 1P up\n\t{KEY_DOWN,      1, 0x123}, // 1P down\n\t{KEY_LEFT,      1, 0x124}, // 1P left\n\t{KEY_RIGHT,     1, 0x125}, // 1P right\n\t{KEY_LEFTCTRL,  1, 0x126}, // 1P 1\n\t{KEY_LEFTALT,   1, 0x127}, // 1P 2\n\t{KEY_SPACE,     1, 0x128}, // 1P 3\n\t{KEY_LEFTSHIFT, 1, 0x129}, // 1P 4\n\t{KEY_Z,         1, 0x12A}, // 1P 5\n\t{KEY_X,         1, 0x12B}, // 1P 6\n\t{KEY_C,         1, 0x12C}, // 1P 7\n\t{KEY_V,         1, 0x12D}, // 1P 8\n\n\t{KEY_9,         1, 0x12E}, // Test\n\t{KEY_TAB,       1, 0x12F}, // Tab (shift + 1P right)\n\t{KEY_ENTER,     1, 0x130}, // Enter (shift + 1P left)\n\t// ~ Tidle supportted?\n\t{KEY_P,         1, 0x131}, // P (pause) (shift + 1P down)\n\t{KEY_F1,        1, 0x132}, // Service\n\t{KEY_F2,        1, 0x133}, // Test\n\t{KEY_F3,        1, 0x134}, // Tilt\n\n\t{KEY_6,         2, 0x120}, // 2P coin\n\t{KEY_2,         2, 0x121}, // 2P start\n\t{KEY_R,         2, 0x122}, // 2P up\n\t{KEY_F,         2, 0x123}, // 2P down\n\t{KEY_D,         2, 0x124}, // 2P left\n\t{KEY_G,         2, 0x125}, // 2P right\n\t{KEY_A,         2, 0x126}, // 2P 1\n\t{KEY_S,         2, 0x127}, // 2P 2\n\t{KEY_Q,         2, 0x128}, // 2P 3\n\t{KEY_W,         2, 0x129}, // 2P 4\n\t{KEY_I,         2, 0x12A}, // 2P 5\n\t{KEY_K,         2, 0x12B}, // 2P 6\n\t{KEY_J,         2, 0x12C}, // 2P 7\n\t{KEY_L,         2, 0x12D}, // 2P 8\n\n/*\n\tsome key codes overlap with 1P/2P buttons.\n\n\t{KEY_7,         3, 0x120}, // 3P coin\n\t{KEY_3,         3, 0x121}, // 3P start\n\t{KEY_I,         3, 0x122}, // 3P up\n\t{KEY_K,         3, 0x123}, // 3P down\n\t{KEY_J,         3, 0x124}, // 3P left\n\t{KEY_L,         3, 0x125}, // 3P right\n\t{KEY_RIGHTCTRL, 3, 0x126}, // 3P 1\n\t{KEY_RIGHTSHIFT,3, 0x127}, // 3P 2\n\t{KEY_ENTER,     3, 0x128}, // 3P 3\n\t{KEY_O,         3, 0x129}, // 3P 4\n\n\t{KEY_8,         4, 0x120}, // 4P coin\n\t{KEY_4,         4, 0x121}, // 4P start\n\t{KEY_Y,         4, 0x122}, // 4P up\n\t{KEY_N,         4, 0x123}, // 4P down\n\t{KEY_V,         4, 0x124}, // 4P left\n\t{KEY_U,         4, 0x125}, // 4P right\n\t{KEY_B,         4, 0x126}, // 4P 1\n\t{KEY_E,         4, 0x127}, // 4P 2\n\t{KEY_H,         4, 0x128}, // 4P 3\n\t{KEY_M,         4, 0x129}, // 4P 4\n*/\n};\n\n// Second Jammasd/J-PAC/I-PAC quirk. It's equivalent to jamma2joy but assigned to players 3 and 4\n// to give support to JAMMA-VERSUS with two JAMMA USB control interfaces.\n// i.e. JammaSD for Players1-2 (on a first cabinet), and J-PAC for Payers 3-4 (on a second cabinet)\nstatic struct\n{\n    uint16_t key;\n    uint16_t player;\n    uint16_t btn;\n} jamma22joy[] =\n        {\n                {KEY_5,         3, 0x120}, // 3P coin\n                {KEY_1,         3, 0x121}, // 3P start\n                {KEY_UP,        3, 0x122}, // 3P up\n                {KEY_DOWN,      3, 0x123}, // 3P down\n                {KEY_LEFT,      3, 0x124}, // 3P left\n                {KEY_RIGHT,     3, 0x125}, // 3P right\n                {KEY_LEFTCTRL,  3, 0x126}, // 3P 1\n                {KEY_LEFTALT,   3, 0x127}, // 3P 2\n                {KEY_SPACE,     3, 0x128}, // 3P 3\n                {KEY_LEFTSHIFT, 3, 0x129}, // 3P 4\n                {KEY_Z,         3, 0x12A}, // 3P 5\n                {KEY_X,         3, 0x12B}, // 3P 6\n                {KEY_C,         3, 0x12C}, // 3P 7\n                {KEY_V,         3, 0x12D}, // 3P 8\n\n                {KEY_6,         4, 0x120}, // 4P coin\n                {KEY_2,         4, 0x121}, // 4P start\n                {KEY_R,         4, 0x122}, // 4P up\n                {KEY_F,         4, 0x123}, // 4P down\n                {KEY_D,         4, 0x124}, // 4P left\n                {KEY_G,         4, 0x125}, // 4P right\n                {KEY_A,         4, 0x126}, // 4P 1\n                {KEY_S,         4, 0x127}, // 4P 2\n                {KEY_Q,         4, 0x128}, // 4P 3\n                {KEY_W,         4, 0x129}, // 4P 4\n                {KEY_I,         4, 0x12A}, // 4P 5\n                {KEY_K,         4, 0x12B}, // 4P 6\n                {KEY_J,         4, 0x12C}, // 4P 7\n                {KEY_L,         4, 0x12D}, // 4P 8\n        };\n\nstatic void send_mouse_with_throttle(int dev, int xval, int yval, int8_t wval)\n{\n\tint i = dev;\n\tif (input[dev].bind >= 0) dev = input[dev].bind;\n\n\tif (is_menu() && !video_fb_state()) printf(\"%s: dx=%d, dy=%d, scroll=%d\\n\", input[i].devname, xval, yval, wval);\n\n\tint throttle = cfg.mouse_throttle ? cfg.mouse_throttle : 1;\n\tif (input[dev].ds_mouse_emu) throttle *= 4;\n\tif (input[dev].quirk == QUIRK_TOUCHGUN) throttle *= 12;\n\n\tinput[i].accx += xval;\n\txval = input[i].accx / throttle;\n\tinput[i].accx -= xval * throttle;\n\n\tinput[i].accy -= yval;\n\tyval = input[i].accy / throttle;\n\tinput[i].accy -= yval * throttle;\n\n\tmouse_cb(xval, yval, wval);\n}\n\nstatic uint32_t touch_rel = 0;\nstatic void touchscreen_proc(int dev, input_event *ev)\n{\n\tstruct input_absinfo absinfo;\n\tint i = dev;\n\tif (input[dev].bind >= 0) dev = input[dev].bind;\n\n\tif (ev->type == EV_KEY)\n\t{\n\t\tif (ev->value == 1)\n\t\t{\n\t\t\tinput[i].misc_flags = 0xC0;\n\t\t\ttouch_rel = 0;\n\n\t\t\tioctl(pool[i].fd, EVIOCGABS(ABS_X), &absinfo);\n\t\t\tinput[i].lastx = absinfo.value;\n\t\t\tinput[i].startx = absinfo.value;\n\n\t\t\tioctl(pool[i].fd, EVIOCGABS(ABS_Y), &absinfo);\n\t\t\tinput[i].lasty = absinfo.value;\n\t\t\tinput[i].starty = absinfo.value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinput[i].misc_flags = 0;\n\t\t\tmice_btn = 0;\n\n\t\t\tif (input[dev].lightgun)\n\t\t\t{\n\t\t\t\tmenu_lightgun_cb(i, EV_KEY, 0x131, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (abs(input[i].lastx - input[i].startx) < 8 && abs(input[i].lasty - input[i].starty) < 8)\n\t\t\t\t{\n\t\t\t\t\tmice_btn |= 1;\n\t\t\t\t\ttouch_rel = GetTimer(100);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmouse_btn_req();\n\t\t}\n\t}\n\telse if (ev->type == EV_ABS && ev->code == ABS_MT_SLOT && ev->value == 3 && (input[i].misc_flags & 0x80))\n\t{\n\t\tinput[i].misc_flags = 0;\n\t\tmice_btn = 0;\n\t\tmouse_btn_req();\n\t\tinput[dev].lightgun = !input[dev].lightgun;\n\t\tInfo(input[dev].lightgun ? \"Light Gun mode is ON\" : \"Light Gun mode is OFF\");\n\t}\n\n\tif (input[dev].lightgun)\n\t{\n\t\tif (ev->type == EV_KEY && ev->value == 1)\n\t\t{\n\t\t\tmice_btn |= 1;\n\t\t\tmouse_btn_req();\n\t\t\tmenu_lightgun_cb(i, EV_KEY, 0x131, 1);\n\t\t}\n\t\telse if (ev->type == EV_ABS)\n\t\t{\n\t\t\tif (ev->code == ABS_MT_POSITION_X)\n\t\t\t{\n\t\t\t\tev->code = ABS_X;\n\t\t\t\tabsinfo.minimum = input[i].guncal[2];\n\t\t\t\tabsinfo.maximum = input[i].guncal[3];\n\t\t\t\tmenu_lightgun_cb(i, ev->type, ev->code, ev->value);\n\t\t\t\tinput_cb(ev, &absinfo, i);\n\t\t\t}\n\t\t\telse if (ev->code == ABS_MT_POSITION_Y)\n\t\t\t{\n\t\t\t\tev->code = ABS_Y;\n\t\t\t\tabsinfo.minimum = input[i].guncal[0];\n\t\t\t\tabsinfo.maximum = input[i].guncal[1];\n\t\t\t\tmenu_lightgun_cb(i, ev->type, ev->code, ev->value);\n\t\t\t\tinput_cb(ev, &absinfo, i);\n\t\t\t}\n\t\t\telse if (ev->code == ABS_MT_SLOT && (input[i].misc_flags & 0x80))\n\t\t\t{\n\t\t\t\tif (ev->value == 1) input[i].misc_flags |= 1;\n\t\t\t\tif (ev->value == 2) input[i].misc_flags |= 2;\n\n\t\t\t\tif (input[i].misc_flags & 2) mice_btn = 4;\n\t\t\t\telse if (input[i].misc_flags & 1) mice_btn = 2;\n\t\t\t\telse mice_btn = 1;\n\n\t\t\t\tmouse_btn_req();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (ev->type == EV_ABS)\n\t\t{\n\t\t\tif (input[i].misc_flags & 0x80)\n\t\t\t{\n\t\t\t\tif (ev->code == ABS_MT_SLOT)\n\t\t\t\t{\n\t\t\t\t\tif (ev->value) input[i].misc_flags &= ~0x40;\n\t\t\t\t\telse input[i].misc_flags |= 0x40;\n\n\t\t\t\t\tif (ev->value == 1) input[i].misc_flags |= 1;\n\t\t\t\t\tif (ev->value == 2) input[i].misc_flags |= 2;\n\n\t\t\t\t\tif (input[i].misc_flags & 2) mice_btn = 4;\n\t\t\t\t\telse if (input[i].misc_flags & 1) mice_btn = 2;\n\n\t\t\t\t\tmouse_btn_req();\n\t\t\t\t}\n\t\t\t\telse if (input[i].misc_flags & 0x40)\n\t\t\t\t{\n\t\t\t\t\tif (ev->code == ABS_MT_POSITION_X)\n\t\t\t\t\t{\n\t\t\t\t\t\tint dx = ev->value - input[i].lastx;\n\t\t\t\t\t\tif (dx > 255) dx = 255;\n\t\t\t\t\t\tif (dx < -256) dx = -256;\n\t\t\t\t\t\tinput[i].lastx = ev->value;\n\t\t\t\t\t\tsend_mouse_with_throttle(i, dx, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ev->code == ABS_MT_POSITION_Y)\n\t\t\t\t\t{\n\t\t\t\t\t\tint dy = ev->value - input[i].lasty;\n\t\t\t\t\t\tif (dy > 255) dy = 255;\n\t\t\t\t\t\tif (dy < -256) dy = -256;\n\t\t\t\t\t\tinput[i].lasty = ev->value;\n\t\t\t\t\t\tsend_mouse_with_throttle(i, 0, -dy, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nstatic int vcs_proc(int dev, input_event *ev)\n{\n\tdevInput *inp = &input[dev];\n\n\tif (ev->type == EV_KEY)\n\t{\n\t\tint flg = 0;\n\t\tint alt = inp->mod && (inp->misc_flags & 2);\n\t\tswitch (ev->code)\n\t\t{\n\t\tcase 0x130: // red top\n\t\t\tif (!ev->value)\n\t\t\t{\n\t\t\t\tev->code = !alt ? 0x135 : 0x130;\n\t\t\t\tinput_cb(ev, 0, dev);\n\t\t\t}\n\t\t\tev->code = alt ? 0x135 : 0x130;\n\t\t\tflg = 1;\n\t\t\tbreak;\n\n\t\tcase 0x131: // red bottom\n\t\t\tflg = 2;\n\t\t\tbreak;\n\n\t\tcase 0x0AC: // atari\n\t\t\tif (!ev->value)\n\t\t\t{\n\t\t\t\tev->code = !alt ? 0x136 : 0x132;\n\t\t\t\tinput_cb(ev, 0, dev);\n\t\t\t}\n\t\t\tev->code = alt ? 0x136 : 0x132;\n\t\t\tflg = 4;\n\t\t\tbreak;\n\n\t\tcase 0x09E: // back\n\t\t\tif (!ev->value)\n\t\t\t{\n\t\t\t\tev->code = !alt ? 0x137 : 0x133;\n\t\t\t\tinput_cb(ev, 0, dev);\n\t\t\t}\n\t\t\tev->code = alt ? 0x137 : 0x133;\n\t\t\tflg = 8;\n\t\t\tbreak;\n\n\t\tcase 0x08B: // menu\n\t\t\tif (!ev->value)\n\t\t\t{\n\t\t\t\tev->code = !alt ? 0x138 : 0x134;\n\t\t\t\tinput_cb(ev, 0, dev);\n\t\t\t}\n\t\t\tev->code = alt ? 0x138 : 0x134;\n\t\t\tflg = 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (flg)\n\t\t{\n\t\t\tif (ev->value) inp->misc_flags |= flg;\n\t\t\telse inp->misc_flags &= ~flg;\n\n\t\t\tif ((inp->misc_flags & 0x1F) == 0x1B)\n\t\t\t{\n\t\t\t\tinp->mod = !inp->mod;\n\t\t\t\tinp->has_map = 0;\n\t\t\t\tinp->has_mmap = 0;\n\t\t\t\tInfo(inp->mod ? \"8-button mode\" : \"5-button mode\");\n\t\t\t}\n\t\t}\n\t\tif (ev->code == 0x131 && inp->mod) return 0;\n\t}\n\telse if (ev->code == 7)\n\t{\n\t\tif (inp->spinner_prev < 0) inp->spinner_prev = ev->value;\n\t\tint acc = inp->spinner_prev;\n\n\t\tint diff =\n\t\t\t(acc > 700 && ev->value < 300) ? (ev->value + 1024 - acc) :\n\t\t\t(acc < 300 && ev->value > 700) ? (ev->value - 1024 - acc) : (ev->value - acc);\n\n\t\tif (inp->spinner_accept)\n\t\t{\n\t\t\tinp->spinner_accept = (inp->spinner_dir && diff >= 0) || (!inp->spinner_dir && diff <= 0);\n\t\t}\n\t\telse if (diff <= -6 || diff >= 6)\n\t\t{\n\t\t\tinp->spinner_accept = 1;\n\t\t\tinp->spinner_dir = (diff > 0) ? 1 : 0;\n\t\t\tdiff = inp->spinner_dir ? 1 : -1;\n\t\t}\n\n\t\tif (inp->spinner_accept && diff)\n\t\t{\n\t\t\tinp->spinner_prev = ev->value;\n\n\t\t\tif ((inp->misc_flags & 0x1F) == 0xB && ((inp->misc_flags & 0x20) ? (diff < -30) : (diff > 30)))\n\t\t\t{\n\t\t\t\tinp->misc_flags ^= 0x20;\n\t\t\t\tInfo((inp->misc_flags & 0x20) ? \"Spinner: Enabled\" : \"Spinner: Disabled\");\n\t\t\t}\n\n\t\t\tif (inp->misc_flags & 0x20)\n\t\t\t{\n\t\t\t\tinp->paddle_val += diff;\n\t\t\t\tif (inp->paddle_val < 0) inp->paddle_val = 0;\n\t\t\t\tif (inp->paddle_val > 511) inp->paddle_val = 511;\n\n\t\t\t\tif (is_menu()) printf(\"vcs: diff = %d, paddle=%d, ev.value = %d\\n\", diff, inp->paddle_val, ev->value);\n\n\t\t\t\tinput_absinfo absinfo;\n\t\t\t\tabsinfo.minimum = 0;\n\t\t\t\tabsinfo.maximum = 511;\n\t\t\t\tev->type = EV_ABS;\n\t\t\t\tev->code = 8;\n\t\t\t\tev->value = inp->paddle_val;\n\t\t\t\tinput_cb(ev, &absinfo, dev);\n\n\t\t\t\tinp->spinner_acc += diff;\n\t\t\t\tev->type = EV_REL;\n\t\t\t\tev->code = 7;\n\t\t\t\tev->value = inp->spinner_acc / 2;\n\t\t\t\tinp->spinner_acc -= ev->value * 2;\n\t\t\t\tinput_cb(ev, 0, dev);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid check_joycon()\n{\n\twhile (1)\n\t{\n\t\tint l = -1, r = -1;\n\t\tint id_combo = 0;\n\n\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t{\n\t\t\tif (input[i].quirk == QUIRK_JOYCON && !JOYCON_COMBO(i))\n\t\t\t{\n\t\t\t\tif (JOYCON_LEFT(i))\n\t\t\t\t{\n\t\t\t\t\tint id = 0;\n\t\t\t\t\tchar *led_path = get_led_path(i);\n\t\t\t\t\tif (led_path) id = get_led(led_path, \":combo\");\n\t\t\t\t\tif (id && (!id_combo || id_combo == id))\n\t\t\t\t\t{\n\t\t\t\t\t\tid_combo = id;\n\t\t\t\t\t\tl = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (JOYCON_RIGHT(i))\n\t\t\t\t{\n\t\t\t\t\tint id = 0;\n\t\t\t\t\tchar *led_path = get_led_path(i);\n\t\t\t\t\tif (led_path) id = get_led(led_path, \":combo\");\n\t\t\t\t\tif (id && (!id_combo || id_combo == id))\n\t\t\t\t\t{\n\t\t\t\t\t\tid_combo = id;\n\t\t\t\t\t\tr = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (l >= 0 && r >= 0)\n\t\t{\n\t\t\tprintf(\"** joycon_l = %d, joycon_r = %d, id = %d\\n\", l, r, id_combo);\n\n\t\t\tinput[l].bind = r;\n\t\t\tinput[r].bind = l;\n\t\t\tinput[l].misc_flags |= 1 << 31;\n\t\t\tinput[r].misc_flags |= 1 << 31;\n\t\t\tstrcpy(input[l].idstr, \"057e_2009\");\n\t\t\tstrcpy(input[r].idstr, \"057e_2009\");\n\t\t}\n\t\telse break;\n\t}\n}\n\nint process_joycon(int dev, input_event *ev, input_absinfo *absinfo)\n{\n\tif (ev->type == EV_ABS)\n\t{\n\t\tif (JOYCON_COMBO(dev)) return 0;\n\t\tif (ev->code == 4 && JOYCON_RIGHT(dev)) ev->value = -ev->value;\n\t\tif (ev->code == 0 && JOYCON_LEFT(dev)) ev->value = -ev->value;\n\t\treturn 0;\n\t}\n\n\tint mask = 0;\n\n\t// simulate DPAD on left joycon\n\tif (JOYCON_COMBO(dev) && (ev->code & ~3) == 0x220)\n\t{\n\t\tmask = 0x100 << (ev->code & 3);\n\t\tinput[dev].misc_flags = ev->value ? (input[dev].misc_flags | mask) : (input[dev].misc_flags & ~mask);\n\t\tif (ev->value)\n\t\t{\n\t\t\tev->value = (ev->code & 1) ? 1 : -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmask = (ev->code & 2) ? 0x400 : 0x100;\n\t\t\tev->value = (input[dev].misc_flags & mask) ? -1 : (input[dev].misc_flags & (mask << 1)) ? 1 : 0;\n\t\t}\n\n\t\tev->code = (ev->code & 2) ? 16 : 17;\n\t\tev->type = EV_ABS;\n\t\tabsinfo->minimum = -1;\n\t\tabsinfo->maximum = 1;\n\t\treturn 0;\n\t}\n\n\t//check for request to combine/split joycons\n\tswitch (ev->code)\n\t{\n\t\tcase 0x136: case 0x137: mask = 1; break;\n\t\tcase 0x138: case 0x139: mask = 2; break;\n\t\tcase 0x13D: case 0x13E: mask = 4; break;\n\t\tdefault: return 0;\n\t}\n\n\tinput[dev].misc_flags = ev->value ? (input[dev].misc_flags | mask) : (input[dev].misc_flags & ~mask);\n\n\tif (JOYCON_REQ(dev))\n\t{\n\t\tint uncombo = 0;\n\t\tint l = -1, r = -1;\n\t\tfor (int n = 0; n < NUMDEV; n++)\n\t\t{\n\t\t\tif (input[n].quirk == QUIRK_JOYCON)\n\t\t\t{\n\t\t\t\tif (JOYCON_COMBO(n))\n\t\t\t\t{\n\t\t\t\t\tif (JOYCON_REQ(n) && JOYCON_REQ(input[n].bind))\n\t\t\t\t\t{\n\t\t\t\t\t\tr = n;\n\t\t\t\t\t\tl = input[n].bind;\n\t\t\t\t\t\tuncombo = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (JOYCON_RIGHT(n) && JOYCON_REQ(n)) r = n;\n\t\t\t\telse if (JOYCON_LEFT(n) && JOYCON_REQ(n)) l = n;\n\t\t\t}\n\t\t}\n\n\t\tif (l >= 0 && r >= 0)\n\t\t{\n\t\t\tuint8_t id = 0;\n\t\t\tchar *led_path;\n\n\t\t\tprintf(uncombo ? \"Joycons request split\\n\" : \"Joycons request combo\\n\");\n\n\t\t\tif (!uncombo)\n\t\t\t{\n\t\t\t\tFileLoad(\"/tmp/combo_id\", &id, sizeof(id));\n\t\t\t\tif (!(++id)) ++id;\n\t\t\t\tFileSave(\"/tmp/combo_id\", &id, sizeof(id));\n\t\t\t}\n\n\t\t\tled_path = get_led_path(l); if (led_path) set_led(led_path, \":combo\", id);\n\t\t\tled_path = get_led_path(r); if (led_path) set_led(led_path, \":combo\", id);\n\n\t\t\tprintf(\"Close all devices.\\n\");\n\t\t\tfor (int i = 0; i < NUMDEV; i++) if (pool[i].fd >= 0)\n\t\t\t{\n\t\t\t\tioctl(pool[i].fd, EVIOCGRAB, 0);\n\t\t\t\tclose(pool[i].fd);\n\t\t\t}\n\t\t\tupdate_num_hw(l, 7);\n\t\t\tupdate_num_hw(r, 7);\n\t\t\tusleep(500000);\n\t\t\tupdate_num_hw(l, 0);\n\t\t\tupdate_num_hw(r, 0);\n\t\t\tusleep(500000);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int get_rumble_device(int player)\n{\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tint dev = i;\n\t\tif (input[i].bind >= 0) dev = input[i].bind;\n\n\t\tif (input[dev].num == player && input[i].has_rumble)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic int rumble_input_device(int devnum, uint16_t strong_mag, uint16_t weak_mag, uint16_t duration = 500, uint16_t delay = 0)\n{\n\tint ioret = 0;\n\tif (!input[devnum].has_rumble) return 0;\n\tint fd = pool[devnum].fd;\n\tif (!(fd >= 0)) return 0;\n\n\tif (!strong_mag && !weak_mag) //Stop rumble\n\t{\n\t\tif (input[devnum].rumble_effect.id == -1) return 1; //No uploaded effect\n\n\t\tioret = ioctl(fd, EVIOCRMFF, input[devnum].rumble_effect.id);\n\t\tinput[devnum].rumble_effect.id = -1; //always set to -1 even if we fail to remove it?\n\t\treturn ioret != -1;\n\t}\n\telse {\n\t\t//Upload effect and then immediately play it\n\t\t//If the effect id in the input struct is -1, it will be filled with the newly uploaded effect\n\t\t//If it is filled with an already uploaded effect, the effect is modified in place\n\t\tstruct ff_effect *fef;\n\t\tfef = &input[devnum].rumble_effect;\n\t\tfef->type = FF_RUMBLE;\n\n\t\tfef->direction = input[devnum].quirk == QUIRK_WHEEL ? 0x4000 : 0x0000;\n\t\tfef->u.rumble.strong_magnitude = strong_mag;\n\t\tfef->u.rumble.weak_magnitude = weak_mag;\n\t\tfef->replay.length = duration;\n\t\tfef->replay.delay = delay;\n\t\tioret = ioctl(fd, EVIOCSFF, fef);\n\n\t\tif (ioret == -1)\n\t\t{\n\t\t\tprintf(\"RUMBLE UPLOAD FAILED %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\n\t\t//Play effect\n\t\tstruct input_event play_ev;\n\t\tplay_ev.type = EV_FF;\n\t\tplay_ev.code = input[devnum].rumble_effect.id;\n\t\tplay_ev.value = 1;\n\t\tioret = write(fd, (const void *)&play_ev, sizeof(play_ev));\n\t\treturn ioret != -1;\n\t}\n\treturn 0;\n}\n\nstatic void set_rumble(int dev, uint16_t rumble_val)\n{\n\tif (input[dev].last_rumble != rumble_val)\n\t{\n\t\tuint16_t strong_m, weak_m;\n\n\t\tstrong_m = (rumble_val & 0xFF00) + (rumble_val >> 8);\n\t\tweak_m = (rumble_val << 8) + (rumble_val & 0x00FF);\n\n\t\trumble_input_device(dev, strong_m, weak_m, 0x7FFF);\n\t\tinput[dev].last_rumble = rumble_val;\n\t}\n}\n\nstatic void set_wheel_range(int dev, int range)\n{\n\tstatic char path[1024];\n\tif (range && input[dev].sysfs[0])\n\t{\n\t\tsprintf(path, \"/sys%s/device/range\", input[dev].sysfs);\n\n\t\tFILE* f = fopen(path, \"w\");\n\t\tif (f)\n\t\t{\n\t\t\tfprintf(f, \"%d\", range);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}\n\nstatic void setup_wheels()\n{\n\tif (cfg.wheel_force > 100) cfg.wheel_force = 100;\n\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tif (pool[i].fd != -1)\n\t\t{\n\t\t\t// steering wheel axis\n\t\t\tinput[i].wh_steer = 0;\n\t\t\t// accelerator pedal axis\n\t\t\tinput[i].wh_accel = -1;\n\t\t\t// brake pedal axis\n\t\t\tinput[i].wh_brake = -1;\n\t\t\t// clutch pedal axis\n\t\t\tinput[i].wh_clutch = -1;\n\t\t\t// shared accel and brake pedal axis\n\t\t\tinput[i].wh_combo = -1;\n\t\t\t// invert pedal values range (if >0)\n\t\t\tinput[i].wh_pedal_invert = -1;\n\n\t\t\t// Logitech Wheels\n\t\t\tif (input[i].vid == 0x046d)\n\t\t\t{\n\t\t\t\tswitch (input[i].pid)\n\t\t\t\t{\n\t\t\t\tcase 0xc299: // LOGITECH_G25_WHEEL\n\t\t\t\tcase 0xc29b: // LOGITECH_G27_WHEEL\n\t\t\t\tcase 0xc24f: // LOGITECH_G29_WHEEL\n\t\t\t\t\tinput[i].wh_accel = 2;\n\t\t\t\t\tinput[i].wh_brake = 5;\n\t\t\t\t\tinput[i].wh_clutch = 1;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xc294: // LOGITECH_WHEEL\n\t\t\t\t\tinput[i].wh_combo = 1;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xc298: // LOGITECH_DFP_WHEEL\n\t\t\t\t\tinput[i].wh_accel = 1;\n\t\t\t\t\tinput[i].wh_brake = 5;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xc29a: // LOGITECH_DFGT_WHEEL\n\t\t\t\t\tinput[i].wh_accel = 1;\n\t\t\t\t\tinput[i].wh_brake = 2;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\n\t\t\t\t//case 0xc262: // LOGITECH_G920_WHEEL\n\t\t\t\t//case 0xc295: // LOGITECH_MOMO_WHEEL\n\t\t\t\t}\n\n\t\t\t\tif (input[i].quirk == QUIRK_WHEEL)\n\t\t\t\t{\n\t\t\t\t\tstruct input_event ie = {};\n\t\t\t\t\tie.type = EV_FF;\n\t\t\t\t\tie.code = FF_AUTOCENTER;\n\t\t\t\t\tie.value = 0xFFFFUL * cfg.wheel_force / 100;\n\t\t\t\t\twrite(pool[i].fd, &ie, sizeof(ie));\n\n\t\t\t\t\tset_wheel_range(i, cfg.wheel_range);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fanatec Wheels\n\t\t\telse if (input[i].vid == 0x0eb7)\n\t\t\t{\n\t\t\t\tswitch (input[i].pid)\n\t\t\t\t{\n\t\t\t\tcase 0x0004:   // CLUBSPORT_V25_WHEELBASE_DEVICE_ID\n\t\t\t\tcase 0x0006:   // PODIUM_WHEELBASE_DD1_DEVICE_ID\n\t\t\t\tcase 0x0007:   // PODIUM_WHEELBASE_DD2_DEVICE_ID\n\t\t\t\t\tinput[i].wh_accel = 2;\n\t\t\t\t\tinput[i].wh_brake = 5;\n\t\t\t\t\tinput[i].wh_clutch = 1;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\n\t\t\t\t//case 0x0001: // CLUBSPORT_V2_WHEELBASE_DEVICE_ID\n\t\t\t\t//case 0x0005: // CSL_ELITE_PS4_WHEELBASE_DEVICE_ID\n\t\t\t\t//case 0x0011: // CSR_ELITE_WHEELBASE_DEVICE_ID\n\t\t\t\t//case 0x0020: // CSL_DD_WHEELBASE_DEVICE_ID\n\t\t\t\t//case 0x0E03: // CSL_ELITE_WHEELBASE_DEVICE_ID\n\t\t\t\t}\n\n\t\t\t\tif (input[i].quirk == QUIRK_WHEEL)\n\t\t\t\t{\n\t\t\t\t\tstruct ff_effect fef;\n\t\t\t\t\tfef.type = FF_SPRING;\n\t\t\t\t\tfef.id = -1;\n\t\t\t\t\tfef.u.condition[0].right_saturation = 0xFFFFUL * cfg.wheel_force / 100;\n\t\t\t\t\tfef.u.condition[0].left_saturation = 0xFFFFUL * cfg.wheel_force / 100;\n\t\t\t\t\tfef.u.condition[0].right_coeff = 0x7FFF;\n\t\t\t\t\tfef.u.condition[0].left_coeff = 0x7FFF;\n\t\t\t\t\tfef.u.condition[0].deadband = 0x0;\n\t\t\t\t\tfef.u.condition[0].center = 0x0;\n\t\t\t\t\tfef.u.condition[1] = fef.u.condition[0];\n\t\t\t\t\tfef.replay.delay = 0;\n\n\t\t\t\t\tif (ioctl(pool[i].fd, EVIOCSFF, &fef) >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstruct input_event play_ev;\n\t\t\t\t\t\tplay_ev.type = EV_FF;\n\t\t\t\t\t\tplay_ev.code = fef.id;\n\t\t\t\t\t\tplay_ev.value = 1;\n\t\t\t\t\t\twrite(pool[i].fd, (const void *)&play_ev, sizeof(play_ev));\n\t\t\t\t\t}\n\n\t\t\t\t\tset_wheel_range(i, cfg.wheel_range);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thrustmaster Guillemot Wheels\n\t\t\telse if (input[i].vid == 0x06f8)\n\t\t\t{\n\t\t\t\tswitch (input[i].pid)\n\t\t\t\t{\n\t\t\t\tcase 0x0004: // Force Feedback Racing Wheel\n\t\t\t\t\tinput[i].wh_steer = 8;\n\t\t\t\t\tinput[i].wh_accel = 9;\n\t\t\t\t\tinput[i].wh_brake = 10;\n\t\t\t\t\tinput[i].wh_pedal_invert = 1;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (input[i].quirk == QUIRK_WHEEL)\n\t\t\t\t{\n\t\t\t\t\tstruct input_event ie = {};\n\t\t\t\t\tie.type = EV_FF;\n\t\t\t\t\tie.code = FF_AUTOCENTER;\n\t\t\t\t\tie.value = 0xFFFFUL * cfg.wheel_force / 100;\n\t\t\t\t\twrite(pool[i].fd, &ie, sizeof(ie));\n\n\t\t\t\t\tset_wheel_range(i, cfg.wheel_range);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thrustmaster Wheels\n\t\t\telse if (input[i].vid == 0x044f)\n\t\t\t{\n\t\t\t\tswitch (input[i].pid)\n\t\t\t\t{\n\t\t\t\tcase 0xb655: // FGT Rumble 3-in-1 (PC)\n\t\t\t\tcase 0xb65b: // F430 Cockpit Wireless (PC)\n\t\t\t\t\tinput[i].wh_steer = 0;\n\t\t\t\t\tinput[i].wh_accel = 5;\n\t\t\t\t\tinput[i].wh_brake = 1;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb66e: // T300RS Racing Wheel (PC/PS3)\n\t\t\t\t\tinput[i].wh_steer = 0;\n\t\t\t\t\tinput[i].wh_accel = 5;\n\t\t\t\t\tinput[i].wh_brake = 1;\n\t\t\t\t\tinput[i].wh_clutch = 6;\n\t\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Namco NeGcon via Arduino, RetroZord or Reflex Adapt\n\t\t\telse if (((input[i].vid == 0x2341 || (input[i].vid == 0x1209 && input[i].pid == 0x595A)) && strstr(input[i].name, \"RZordPsWheel\")) ||\n\t\t\t\t\t (input[i].vid == 0x16D0 && input[i].pid == 0x127E && strstr(input[i].name, \"ReflexPSWheel\")))\n\t\t\t{\n\t\t\t\tinput[i].wh_accel = 6;\n\t\t\t\tinput[i].wh_brake = 10;\n\t\t\t\tinput[i].wh_clutch = 2;\n\t\t\t\tinput[i].quirk = QUIRK_WHEEL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint input_test(int getchar)\n{\n\tstatic char cur_leds = 0;\n\tstatic int state = 0;\n\tstruct input_absinfo absinfo;\n\tstruct input_event ev;\n\tstatic uint32_t timeout = 0;\n\n\tif (touch_rel && CheckTimer(touch_rel))\n\t{\n\t\ttouch_rel = 0;\n\t\tmice_btn = 0;\n\t\tmouse_btn_req();\n\t}\n\n\tif (state == 0)\n\t{\n\t\tinput_uinp_setup();\n\t\tmemset(pool, -1, sizeof(pool));\n\n\t\tsignal(SIGINT, INThandler);\n\t\tpool[NUMDEV].fd = set_watch();\n\t\tpool[NUMDEV].events = POLLIN;\n\n\t\tunlink(CMD_FIFO);\n\t\tmkfifo(CMD_FIFO, 0666);\n\n\t\tpool[NUMDEV+1].fd = open(CMD_FIFO, O_RDWR | O_NONBLOCK | O_CLOEXEC);\n\t\tpool[NUMDEV+1].events = POLLIN;\n\n\t\tpool[NUMDEV + 2].fd = open(LED_MONITOR, O_RDONLY | O_CLOEXEC);\n\t\tpool[NUMDEV + 2].events = POLLPRI;\n\n\t\tstate++;\n\t}\n\n\tif (state == 1)\n\t{\n\t\ttimeout = 0;\n\t\tprintf(\"Open up to %d input devices.\\n\", NUMDEV);\n\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t{\n\t\t\tpool[i].fd = -1;\n\t\t\tpool[i].events = 0;\n\t\t}\n\n\t\tmemset(input, 0, sizeof(input));\n\n\t\tint n = 0;\n\t\tDIR *d = opendir(\"/dev/input\");\n\t\tif (d)\n\t\t{\n\t\t\tstruct dirent *de;\n\t\t\twhile ((de = readdir(d)))\n\t\t\t{\n\t\t\t\tif (!strncmp(de->d_name, \"event\", 5) || !strncmp(de->d_name, \"mouse\", 5))\n\t\t\t\t{\n\t\t\t\t\tmemset(&input[n], 0, sizeof(input[n]));\n\t\t\t\t\tsprintf(input[n].devname, \"/dev/input/%s\", de->d_name);\n\t\t\t\t\tint fd = open(input[n].devname, O_RDWR | O_CLOEXEC);\n\t\t\t\t\t//printf(\"open(%s): %d\\n\", input[n].devname, fd);\n\n\t\t\t\t\tif (fd > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpool[n].fd = fd;\n\t\t\t\t\t\tpool[n].events = POLLIN;\n\t\t\t\t\t\tinput[n].mouse = !strncmp(de->d_name, \"mouse\", 5);\n\n\t\t\t\t\t\tchar uniq[32] = {};\n\t\t\t\t\t\tif (!input[n].mouse)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct input_id id;\n\t\t\t\t\t\t\tmemset(&id, 0, sizeof(id));\n\t\t\t\t\t\t\tioctl(pool[n].fd, EVIOCGID, &id);\n\t\t\t\t\t\t\tinput[n].vid = id.vendor;\n\t\t\t\t\t\t\tinput[n].pid = id.product;\n\t\t\t\t\t\t\tinput[n].version = id.version;\n\t\t\t\t\t\t\tinput[n].bustype = id.bustype;\n\n\t\t\t\t\t\t\tioctl(pool[n].fd, EVIOCGUNIQ(sizeof(uniq)), uniq);\n\t\t\t\t\t\t\tioctl(pool[n].fd, EVIOCGNAME(sizeof(input[n].name)), input[n].name);\n\t\t\t\t\t\t\tinput[n].led = has_led(pool[n].fd);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//skip our virtual device\n\t\t\t\t\t\tif (!strcmp(input[n].name, UINPUT_NAME))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclose(pool[n].fd);\n\n\t\t\t\t\t\t\tpool[n].fd = -1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinput[n].bind = -1;\n\n\t\t\t\t\t\tint effects;\n\t\t\t\t\t\tinput[n].has_rumble = false;\n\t\t\t\t\t\tif (cfg.rumble)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ioctl(fd, EVIOCGEFFECTS, &effects) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tunsigned char ff_features[(FF_MAX + 7) / 8] = {};\n\n\t\t\t\t\t\t\t\tif (ioctl(fd, EVIOCGBIT(EV_FF, sizeof(ff_features)), ff_features) != -1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (test_bit(FF_RUMBLE, ff_features)) {\n\t\t\t\t\t\t\t\t\t\tinput[n].rumble_effect.id = -1;\n\t\t\t\t\t\t\t\t\t\tinput[n].has_rumble = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// enable scroll wheel reading\n\t\t\t\t\t\tif (input[n].mouse)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunsigned char buffer[4];\n\t\t\t\t\t\t\tstatic const unsigned char mousedev_imps_seq[] = { 0xf3, 200, 0xf3, 100, 0xf3, 80 };\n\t\t\t\t\t\t\tif (write(pool[n].fd, mousedev_imps_seq, sizeof(mousedev_imps_seq)) != sizeof(mousedev_imps_seq))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"Cannot switch %s to ImPS/2 protocol(1)\\n\", input[n].devname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (read(pool[n].fd, buffer, sizeof buffer) != 1 || buffer[0] != 0xFA)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"Failed to switch %s to ImPS/2 protocol(2)\\n\", input[n].devname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// RasPad3 touchscreen\n\t\t\t\t\t\tif (input[n].vid == 0x222a && input[n].pid == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_TOUCHGUN;\n\t\t\t\t\t\t\tinput[n].num = 1;\n\t\t\t\t\t\t\tinput[n].map_shown = 1;\n\n\t\t\t\t\t\t\tinput[n].lightgun = 0;\n\t\t\t\t\t\t\tinput[n].guncal[0] = 0;\n\t\t\t\t\t\t\tinput[n].guncal[1] = 16383;\n\t\t\t\t\t\t\tinput[n].guncal[2] = 2047;\n\t\t\t\t\t\t\tinput[n].guncal[3] = 14337;\n\t\t\t\t\t\t\tinput_lightgun_load(n);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[n].vid == 0x054c)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (strcasestr(input[n].name, \"Motion\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// don't use Accelerometer\n\t\t\t\t\t\t\t\tclose(pool[n].fd);\n\t\t\t\t\t\t\t\tpool[n].fd = -1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (input[n].pid == 0x0268)  input[n].quirk = QUIRK_DS3;\n\t\t\t\t\t\t\telse if (input[n].pid == 0x05c4 || input[n].pid == 0x09cc || input[n].pid == 0x0ba0 || input[n].pid == 0x0ce6)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinput[n].quirk = QUIRK_DS4;\n\t\t\t\t\t\t\t\tif (strcasestr(input[n].name, \"Touchpad\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinput[n].quirk = QUIRK_DS4TOUCH;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[n].vid == 0x0079 && input[n].pid == 0x1802)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].lightgun = 1;\n\t\t\t\t\t\t\tinput[n].num = 2; // force mayflash mode 1/2 as second joystick.\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[n].vid == 0x057e && (input[n].pid == 0x0306 || input[n].pid == 0x0330))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (strcasestr(input[n].name, \"Accelerometer\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// don't use Accelerometer\n\t\t\t\t\t\t\t\tclose(pool[n].fd);\n\t\t\t\t\t\t\t\tpool[n].fd = -1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (strcasestr(input[n].name, \"Motion Plus\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// don't use Accelerometer\n\t\t\t\t\t\t\t\tclose(pool[n].fd);\n\t\t\t\t\t\t\t\tpool[n].fd = -1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinput[n].quirk = QUIRK_WIIMOTE;\n\t\t\t\t\t\t\t\tinput[n].guncal[0] = 0;\n\t\t\t\t\t\t\t\tinput[n].guncal[1] = 767;\n\t\t\t\t\t\t\t\tinput[n].guncal[2] = 1;\n\t\t\t\t\t\t\t\tinput[n].guncal[3] = 1023;\n\t\t\t\t\t\t\t\tinput_lightgun_load(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[n].vid == 0x057e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (strstr(input[n].name, \" IMU\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// don't use Accelerometer\n\t\t\t\t\t\t\t\tclose(pool[n].fd);\n\t\t\t\t\t\t\t\tpool[n].fd = -1;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[n].vid == 0x057e && input[n].pid == 0x2006)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].misc_flags = 1 << 30;\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_JOYCON;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (input[n].vid == 0x057e && input[n].pid == 0x2007)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].misc_flags = 1 << 29;\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_JOYCON;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Ultimarc lightgun\n\t\t\t\t\t\tif (input[n].vid == 0xd209 && input[n].pid == 0x1601)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].lightgun = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Namco Guncon via Arduino, RetroZord or Reflex Adapt\n\t\t\t\t\t\tif (((input[n].vid == 0x2341 || (input[n].vid == 0x1209 && input[n].pid == 0x595A)) && (strstr(uniq, \"RZordPsGun\") || strstr(input[n].name, \"RZordPsGun\"))) ||\n\t\t\t\t\t\t\t(input[n].vid == 0x16D0 && input[n].pid == 0x127E && (strstr(uniq, \"ReflexPSGun\") || strstr(input[n].name, \"ReflexPSGun\"))))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_LIGHTGUN;\n\t\t\t\t\t\t\tinput[n].lightgun = 1;\n\t\t\t\t\t\t\tinput[n].guncal[0] = 0;\n\t\t\t\t\t\t\tinput[n].guncal[1] = 32767;\n\t\t\t\t\t\t\tinput[n].guncal[2] = 0;\n\t\t\t\t\t\t\tinput[n].guncal[3] = 32767;\n\t\t\t\t\t\t\tinput_lightgun_load(n);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Namco GunCon 2\n\t\t\t\t\t\tif (input[n].vid == 0x0b9a && input[n].pid == 0x016a)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_LIGHTGUN_CRT;\n\t\t\t\t\t\t\tinput[n].lightgun = 1;\n\t\t\t\t\t\t\tinput[n].guncal[0] = 25;\n\t\t\t\t\t\t\tinput[n].guncal[1] = 245;\n\t\t\t\t\t\t\tinput[n].guncal[2] = 145;\n\t\t\t\t\t\t\tinput[n].guncal[3] = 700;\n\t\t\t\t\t\t\tinput_lightgun_load(n);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Namco GunCon 3\n\t\t\t\t\t\tif (input[n].vid == 0x0b9a && input[n].pid == 0x0800)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_LIGHTGUN;\n\t\t\t\t\t\t\tinput[n].lightgun = 1;\n\t\t\t\t\t\t\tinput[n].guncal[0] = -32768;\n\t\t\t\t\t\t\tinput[n].guncal[1] = 32767;\n\t\t\t\t\t\t\tinput[n].guncal[2] = -32768;\n\t\t\t\t\t\t\tinput[n].guncal[3] = 32767;\n\t\t\t\t\t\t\tinput_lightgun_load(n);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//GUN4IR Lightgun\n\t\t\t\t\t\tif (input[n].vid == 0x2341 && input[n].pid >= 0x8042 && input[n].pid <= 0x8049)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_LIGHTGUN;\n\t\t\t\t\t\t\tinput[n].lightgun = 1;\n\t\t\t\t\t\t\tinput[n].guncal[0] = 0;\n\t\t\t\t\t\t\tinput[n].guncal[1] = 32767;\n\t\t\t\t\t\t\tinput[n].guncal[2] = 0;\n\t\t\t\t\t\t\tinput[n].guncal[3] = 32767;\n\t\t\t\t\t\t\tinput_lightgun_load(n);\n\t\t\t\t\t\t}\n\n                                                //Blamcon Lightgun\n                                                if (input[n].vid == 0x3673 && ((input[n].pid >= 0x0100 && input[n].pid <= 0x0103) || (input[n].pid >= 0x0200 && input[n].pid <= 0x0203)))\n                                                {\n                                                        input[n].quirk = QUIRK_LIGHTGUN;\n                                                        input[n].lightgun = 1;\n                                                        input[n].guncal[0] = 0;\n                                                        input[n].guncal[1] = 32767;\n                                                        input[n].guncal[2] = 0;\n                                                        input[n].guncal[3] = 32767;\n                                                        input_lightgun_load(n);\n                                                }\n\n\t\t\t\t\t\t//Madcatz Arcade Stick 360\n\t\t\t\t\t\tif (input[n].vid == 0x0738 && input[n].pid == 0x4758) input[n].quirk = QUIRK_MADCATZ360;\n\n\t\t\t\t\t\t// mr.Spinner\n\t\t\t\t\t\t// 0x120  - Button\n\t\t\t\t\t\t// Axis 7 - EV_REL is spinner\n\t\t\t\t\t\t// Axis 8 - EV_ABS is Paddle\n\t\t\t\t\t\t// Overlays on other existing gamepads\n\t\t\t\t\t\tif (strstr(uniq, \"MiSTer-S1\")) input[n].quirk = QUIRK_PDSP;\n\t\t\t\t\t\tif (strstr(input[n].name, \"MiSTer-S1\")) input[n].quirk = QUIRK_PDSP;\n\n\t\t\t\t\t\t// Arcade with spinner and/or paddle:\n\t\t\t\t\t\t// Axis 7 - EV_REL is spinner\n\t\t\t\t\t\t// Axis 8 - EV_ABS is Paddle\n\t\t\t\t\t\t// Includes other buttons and axes, works as a full featured gamepad.\n\t\t\t\t\t\tif (strstr(uniq, \"MiSTer-A1\")) input[n].quirk = QUIRK_PDSP_ARCADE;\n\t\t\t\t\t\tif (strstr(input[n].name, \"MiSTer-A1\")) input[n].quirk = QUIRK_PDSP_ARCADE;\n\n\t\t\t\t\t\t//Jamma\n\t\t\t\t\t\tif (cfg.jamma_vid && cfg.jamma_pid && input[n].vid == cfg.jamma_vid && input[n].pid == cfg.jamma_pid)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_JAMMA;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Jamma2\n\t\t\t\t\t\tif (cfg.jamma2_vid && cfg.jamma2_pid && input[n].vid == cfg.jamma2_vid && input[n].pid == cfg.jamma2_pid)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_JAMMA2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Atari VCS wireless joystick with spinner\n\t\t\t\t\t\tif (input[n].vid == 0x3250 && input[n].pid == 0x1001)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[n].quirk = QUIRK_VCS;\n\t\t\t\t\t\t\tinput[n].spinner_acc = -1;\n\t\t\t\t\t\t\tinput[n].misc_flags = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Arduino and Teensy devices may share the same VID:PID, so additional field UNIQ is used to differentiate them\n\t\t\t\t\t\t//Reflex Adapt also uses the UNIQ field to differentiate between device modes\n\t\t\t\t\t\t//RetroZord Adapter also uses the UNIQ field to differentiate between device modes\n\t\t\t\t\t\tif ((input[n].vid == 0x2341 || (input[n].vid == 0x16C0 && (input[n].pid>>8) == 0x4) || (input[n].vid == 0x16D0 && input[n].pid == 0x127E) || (input[n].vid == 0x1209 && input[n].pid == 0x595A)) && strlen(uniq))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnprintf(input[n].idstr, sizeof(input[n].idstr), \"%04x_%04x_%s\", input[n].vid, input[n].pid, uniq);\n\t\t\t\t\t\t\tchar *p;\n\t\t\t\t\t\t\twhile ((p = strchr(input[n].idstr, '/'))) *p = '_';\n\t\t\t\t\t\t\twhile ((p = strchr(input[n].idstr, ' '))) *p = '_';\n\t\t\t\t\t\t\twhile ((p = strchr(input[n].idstr, '*'))) *p = '_';\n\t\t\t\t\t\t\twhile ((p = strchr(input[n].idstr, ':'))) *p = '_';\n\t\t\t\t\t\t\tstrcpy(input[n].name, uniq);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (input[n].vid == 0x1209 && (input[n].pid == 0xFACE || input[n].pid == 0xFACA))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint sum = 0;\n\t\t\t\t\t\t\tfor (uint32_t i = 0; i < sizeof(input[n].name); i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!input[n].name[i]) break;\n\t\t\t\t\t\t\t\tsum += (uint8_t)input[n].name[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsnprintf(input[n].idstr, sizeof(input[n].idstr), \"%04x_%04x_%d\", input[n].vid, input[n].pid, sum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnprintf(input[n].idstr, sizeof(input[n].idstr), \"%04x_%04x\", input[n].vid, input[n].pid);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tioctl(pool[n].fd, EVIOCGRAB, (grabbed | user_io_osd_is_visible()) ? 1 : 0);\n\n\t\t\t\t\t\tn++;\n\t\t\t\t\t\tif (n >= NUMDEV) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(d);\n\n\t\t\tmergedevs();\n\t\t\tcheck_joycon();\n\t\t\tsetup_wheels();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"opened %d(%2d): %s (%04x:%04x:%08x) %d \\\"%s\\\" \\\"%s\\\"\\n\", i, input[i].bind, input[i].devname, input[i].vid, input[i].pid, input[i].unique_hash, input[i].quirk, input[i].id, input[i].name);\n\t\t\t\trestore_player(i);\n\t\t\t\tsetup_deadzone(&ev, i);\n\t\t\t}\n\t\t\tunflag_players();\n\t\t}\n\t\tcur_leds |= 0x80;\n\t\tstate++;\n\t}\n\n\tif (cfg.bt_auto_disconnect)\n\t{\n\t\tif (!timeout) timeout = GetTimer(6000);\n\t\telse if (CheckTimer(timeout))\n\t\t{\n\t\t\ttimeout = GetTimer(6000);\n\t\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t\t{\n\t\t\t\tif (pool[i].fd >= 0 && input[i].timeout > 0)\n\t\t\t\t{\n\t\t\t\t\tif (!(JOYCON_COMBINED(i) && JOYCON_LEFT(i)) && input[i].bind != i) continue;\n\t\t\t\t\tinput[i].timeout--;\n\t\t\t\t\tif (!input[i].timeout)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatic char cmd[128];\n\t\t\t\t\t\tsprintf(cmd, \"btctl disconnect %s\", input[i].mac);\n\t\t\t\t\t\tsystem(cmd);\n\t\t\t\t\t\tif (JOYCON_COMBINED(i))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(cmd, \"btctl disconnect %s\", input[input[i].bind].mac);\n\t\t\t\t\t\t\tsystem(cmd);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (state == 2)\n\t{\n\t\tint timeout = 0;\n\t\tif (is_menu() && video_fb_state()) timeout = 25;\n\n\t\twhile (1)\n\t\t{\n\t\t\tif (cfg.rumble && !is_menu())\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t\t\t{\n\t\t\t\t\tif (!input[i].has_rumble) continue;\n\n\t\t\t\t\tint dev = i;\n\t\t\t\t\tif (input[i].bind >= 0) dev = input[i].bind;\n\t\t\t\t\tif (!input[dev].num) continue;\n\n\t\t\t\t\tset_rumble(i, spi_uio_cmd(UIO_GET_RUMBLE | ((input[dev].num - 1) << 8)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint return_value = poll(pool, NUMDEV + 3, timeout);\n\t\t\tif (!return_value) break;\n\n\t\t\tif (return_value < 0)\n\t\t\t{\n\t\t\t\tprintf(\"ERR: poll\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((pool[NUMDEV].revents & POLLIN) && check_devs())\n\t\t\t{\n\t\t\t\tprintf(\"Close all devices.\\n\");\n\t\t\t\tfor (int i = 0; i < NUMDEV; i++) if (pool[i].fd >= 0)\n\t\t\t\t{\n\t\t\t\t\tioctl(pool[i].fd, EVIOCGRAB, 0);\n\t\t\t\t\tclose(pool[i].fd);\n\t\t\t\t}\n\t\t\t\tstate = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfor (int pos = 0; pos < NUMDEV; pos++)\n\t\t\t{\n\t\t\t\tint i = pos;\n\n\n\t\t\t\tif ((pool[i].fd >= 0) && (pool[i].revents & POLLIN))\n\t\t\t\t{\n\t\t\t\t\tif (!input[i].mouse)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tmemset(&ev, 0, sizeof(ev));\n\t\t\t\t\t\tif (read(pool[i].fd, &ev, sizeof(ev)) == sizeof(ev))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (getchar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (ev.type == EV_KEY && ev.value >= 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn ev.code;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (ev.type)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint dev = i;\n\t\t\t\t\t\t\t\tif (!JOYCON_COMBINED(i) && input[dev].bind >= 0) dev = input[dev].bind;\n\n\t\t\t\t\t\t\t\tint noabs = 0;\n\n\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_DS4TOUCH && ev.type == EV_KEY)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (ev.code == BTN_TOOL_FINGER || ev.code == BTN_TOUCH || ev.code == BTN_TOOL_DOUBLETAP) continue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_MADCATZ360 && ev.type == EV_KEY)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (ev.code == BTN_THUMBR) input[i].misc_flags = ev.value ? (input[i].misc_flags | 1) : (input[i].misc_flags & ~1);\n\t\t\t\t\t\t\t\t\telse if (ev.code == BTN_MODE && !user_io_osd_is_visible())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (input[i].misc_flags & 1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (ev.value)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif ((input[i].misc_flags & 0x6) == 0) input[i].misc_flags = 0x3; // X\n\t\t\t\t\t\t\t\t\t\t\t\telse if ((input[i].misc_flags & 0x6) == 2) input[i].misc_flags = 0x5; // Y\n\t\t\t\t\t\t\t\t\t\t\t\telse input[i].misc_flags = 0x1; // None\n\n\t\t\t\t\t\t\t\t\t\t\t\tInfo(((input[i].misc_flags & 0x6) == 2) ? \"Paddle mode\" :\n\t\t\t\t\t\t\t\t\t\t\t\t\t((input[i].misc_flags & 0x6) == 4) ? \"Spinner mode\" :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Normal mode\");\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_TOUCHGUN)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttouchscreen_proc(i, &ev);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ev.type == EV_ABS)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_WIIMOTE)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//nunchuck accel events\n\t\t\t\t\t\t\t\t\t\tif (ev.code >= 3 && ev.code <= 5) continue;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//Dualshock: drop accelerator and raw touchpad events\n\t\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_DS4TOUCH && ev.code == 57)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinput[dev].lightgun_req = (ev.value >= 0);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ((input[i].quirk == QUIRK_DS4TOUCH || input[i].quirk == QUIRK_DS4 || input[i].quirk == QUIRK_DS3) && ev.code > 40)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (ioctl(pool[i].fd, EVIOCGABS(ev.code), &absinfo) < 0) memset(&absinfo, 0, sizeof(absinfo));\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//DS4 specific: touchpad as lightgun\n\t\t\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_DS4TOUCH && ev.code <= 1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (!input[dev].lightgun || user_io_osd_is_visible()) continue;\n\n\t\t\t\t\t\t\t\t\t\t\tif (ev.code == 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = 300;\n\t\t\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = 850;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (ev.code == 0)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = 200;\n\t\t\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = 1720;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_DS4 && ev.code <= 1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (input[dev].lightgun) noabs = 1;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_WIIMOTE)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tinput[dev].lightgun = 0;\n\t\t\t\t\t\t\t\t\t\t\tif (absinfo.maximum == 1023 || absinfo.maximum == 767)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (ev.code == 16)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tev.value = absinfo.maximum - ev.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\tev.code = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinput[dev].lightgun = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse if (ev.code == 17)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tev.code = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tinput[dev].lightgun = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// other 3 IR tracking aren't used\n\t\t\t\t\t\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (absinfo.maximum == 62)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t//LT/RT analog\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (ev.code & 1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t//Y axes on wiimote and accessories are inverted\n\t\t\t\t\t\t\t\t\t\t\t\tev.value = -ev.value;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_MADCATZ360 && (input[i].misc_flags & 0x6) && (ev.code == 16) && !user_io_osd_is_visible())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (ev.value)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif ((input[i].misc_flags & 0x6) == 2)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (ev.value > 0) input[i].paddle_val += 4;\n\t\t\t\t\t\t\t\t\t\t\t\tif (ev.value < 0) input[i].paddle_val -= 4;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (input[i].paddle_val > 256) input[i].paddle_val = 256;\n\t\t\t\t\t\t\t\t\t\t\t\tif (input[i].paddle_val < 0)   input[i].paddle_val = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = 255;\n\t\t\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tev.code = 8;\n\t\t\t\t\t\t\t\t\t\t\t\tev.value = input[i].paddle_val;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tev.type = EV_REL;\n\t\t\t\t\t\t\t\t\t\t\t\tev.code = 7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (input[dev].quirk == QUIRK_VCS && !vcs_proc(i, &ev)) continue;\n\n\t\t\t\t\t\t\t\tif (input[dev].quirk == QUIRK_JAMMA && ev.type == EV_KEY)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinput[dev].num = 0;\n\t\t\t\t\t\t\t\t\tfor (uint32_t i = 0; i < sizeof(jamma2joy) / sizeof(jamma2joy[0]); i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (jamma2joy[i].key == ev.code)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tev.code = jamma2joy[i].btn;\n\t\t\t\t\t\t\t\t\t\t\tinput[dev].num = jamma2joy[i].player;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n                                }\n\n\t\t\t\t\t\t\t\tif (input[dev].quirk == QUIRK_JAMMA2 && ev.type == EV_KEY)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinput[dev].num = 0;\n\t\t\t\t\t\t\t\t\tfor (uint32_t i = 0; i < sizeof(jamma22joy) / sizeof(jamma22joy[0]); i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (jamma22joy[i].key == ev.code)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tev.code = jamma22joy[i].btn;\n\t\t\t\t\t\t\t\t\t\t\tinput[dev].num = jamma22joy[i].player;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_JOYCON)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (process_joycon(i, &ev, &absinfo))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t//Menu combo on 8BitDo receiver in PSC mode\n\t\t\t\t\t\t\t\tif (input[dev].vid == 0x054c && input[dev].pid == 0x0cda && ev.type == EV_KEY)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//in PSC mode these keys coming from separate virtual keyboard device\n\t\t\t\t\t\t\t\t\t//so it's impossible to use joystick codes as keyboards aren't personalized\n\t\t\t\t\t\t\t\t\tif (ev.code == 164 || ev.code == 1) ev.code = KEY_MENU;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// various controllers in X-Input mode generate keyboard key codes, remap them.\n\t\t\t\t\t\t\t\tif (input[dev].vid == 0x45E && ev.type == EV_KEY)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tswitch (ev.code)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase KEY_BACK:   ev.code = BTN_SELECT; break;\n\t\t\t\t\t\t\t\t\tcase KEY_MENU:   ev.code = BTN_MODE;   break;\n\t\t\t\t\t\t\t\t\tcase KEY_RECORD: ev.code = BTN_Z;      break;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (is_menu() && !video_fb_state())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\tif (mapping && mapping_type <= 1 && !(ev.type==EV_KEY && ev.value>1))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tstatic char str[64], str2[64];\n\t\t\t\t\t\t\t\t\t\tOsdWrite(12, \"\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\");\n\t\t\t\t\t\t\t\t\t\tsprintf(str, \"     VID=%04X PID=%04X\", input[i].vid, input[i].pid);\n\t\t\t\t\t\t\t\t\t\tOsdWrite(13, str);\n\n\t\t\t\t\t\t\t\t\t\tsprintf(str, \"Type=%d Code=%d Value=%d\", ev.type, ev.code, ev.value);\n\t\t\t\t\t\t\t\t\t\tstr2[0] = 0;\n\t\t\t\t\t\t\t\t\t\tint len = (29 - (strlen(str))) / 2;\n\t\t\t\t\t\t\t\t\t\twhile (len-- > 0) strcat(str2, \" \");\n\t\t\t\t\t\t\t\t\t\tstrcat(str2, str);\n\t\t\t\t\t\t\t\t\t\tOsdWrite(14, str2);\n\n\t\t\t\t\t\t\t\t\t\tstr2[0] = 0;\n\t\t\t\t\t\t\t\t\t\tif (ev.type == EV_ABS)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tsprintf(str, \"Min=%d Max=%d\", absinfo.minimum, absinfo.maximum);\n\t\t\t\t\t\t\t\t\t\t\tint len = (29 - (strlen(str))) / 2;\n\t\t\t\t\t\t\t\t\t\t\twhile (len-- > 0) strcat(str2, \" \");\n\t\t\t\t\t\t\t\t\t\t\tstrcat(str2, str);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tOsdWrite(15, str2);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\t\t\tswitch (ev.type)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//keyboard, buttons\n\t\t\t\t\t\t\t\t\tcase EV_KEY:\n\t\t\t\t\t\t\t\t\t\tprintf(\"%04x:%04x:%02d P%d Input event: type=EV_KEY, code=%d(0x%x), value=%d\\n\", input[dev].vid, input[dev].pid, i, input[dev].num, ev.code, ev.code, ev.value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase EV_REL:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//limit the amount of EV_REL messages, so Menu core won't be laggy\n\t\t\t\t\t\t\t\t\t\tstatic unsigned long timeout = 0;\n\t\t\t\t\t\t\t\t\t\tif (!timeout || CheckTimer(timeout))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttimeout = GetTimer(20);\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%04x:%04x:%02d P%d Input event: type=EV_REL, Axis=%d, Offset=%d\\n\", input[dev].vid, input[dev].pid, i, input[dev].num, ev.code, ev.value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase EV_SYN:\n\t\t\t\t\t\t\t\t\tcase EV_MSC:\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t//analog joystick\n\t\t\t\t\t\t\t\t\tcase EV_ABS:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//limit the amount of EV_ABS messages, so Menu core won't be laggy\n\t\t\t\t\t\t\t\t\t\tstatic unsigned long timeout = 0;\n\t\t\t\t\t\t\t\t\t\tif (!timeout || CheckTimer(timeout))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttimeout = GetTimer(20);\n\n\t\t\t\t\t\t\t\t\t\t\t//reduce flood from DUALSHOCK 3/4\n\t\t\t\t\t\t\t\t\t\t\tif ((input[i].quirk == QUIRK_DS4 || input[i].quirk == QUIRK_DS3) && ev.code <= 5 && ev.value > 118 && ev.value < 138)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t//aliexpress USB encoder floods messages\n\t\t\t\t\t\t\t\t\t\t\tif (input[dev].vid == 0x0079 && input[dev].pid == 0x0006)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (ev.code == 2) break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"%04x:%04x:%02d P%d Input event: type=EV_ABS, Axis=%d [%d...%d], Offset=%d\", input[dev].vid, input[dev].pid, i, input[dev].num, ev.code, absinfo.minimum, absinfo.maximum, ev.value);\n\t\t\t\t\t\t\t\t\t\t\t//if (absinfo.fuzz) printf(\", fuzz = %d\", absinfo.fuzz);\n\t\t\t\t\t\t\t\t\t\t\tif (absinfo.resolution) printf(\", res = %d\", absinfo.resolution);\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tprintf(\"%04x:%04x:%02d P%d Input event: type=%d, code=%d(0x%x), value=%d(0x%x)\\n\", input[dev].vid, input[dev].pid, i, input[dev].num, ev.type, ev.code, ev.code, ev.value, ev.value);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (ev.type == EV_KEY && input[dev].num)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (ev.code == (input[dev].mmap[SYS_BTN_L] & 0xFFFF)) input[dev].rumble_en = ev.value;\n\n\t\t\t\t\t\t\t\t\t\tint n = get_rumble_device(input[dev].num);\n\t\t\t\t\t\t\t\t\t\tif (n >= 0 && (input[dev].rumble_en || !ev.value))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint16_t rumble_val = input[n].last_rumble;\n\t\t\t\t\t\t\t\t\t\t\tif (ev.code == (input[dev].mmap[SYS_BTN_X] & 0xFFFF)) set_rumble(n, (rumble_val & 0xFF00) | ((ev.value) ? 0xFF : 0x00));\n\t\t\t\t\t\t\t\t\t\t\tif (ev.code == (input[dev].mmap[SYS_BTN_Y] & 0xFFFF)) set_rumble(n, (rumble_val & 0xFF) | ((ev.value) ? 0xFF00 : 0x00));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ev.type == EV_ABS && input[i].quirk == QUIRK_WIIMOTE && input[dev].lightgun)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmenu_lightgun_cb(i, ev.type, ev.code, ev.value);\n\n\t\t\t\t\t\t\t\t\t// don't pass IR tracking to OSD\n\t\t\t\t\t\t\t\t\tif (user_io_osd_is_visible()) continue;\n\n\t\t\t\t\t\t\t\t\tif (!ev.code)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = input[i].guncal[2];\n\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = input[i].guncal[3];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = input[i].guncal[0];\n\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = input[i].guncal[1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ev.type == EV_ABS && input[i].quirk == QUIRK_LIGHTGUN)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmenu_lightgun_cb(i, ev.type, ev.code, ev.value);\n\n\t\t\t\t\t\t\t\t\tif (ev.code == ABS_X)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = input[i].guncal[2];\n\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = input[i].guncal[3];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (ev.code == ABS_Y)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = input[i].guncal[0];\n\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = input[i].guncal[1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ev.type == EV_ABS && input[i].quirk == QUIRK_LIGHTGUN_CRT)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmenu_lightgun_cb(i, ev.type, ev.code, ev.value);\n\n\t\t\t\t\t\t\t\t\tif (ev.code == ABS_X)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = input[i].guncal[2];\n\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = input[i].guncal[3];\n\n\t\t\t\t\t\t\t\t\t\t// When the gun loses tracking, give it a short grace period\n\t\t\t\t\t\t\t\t\t\t// before passing through the off-screen coordinates.\n\t\t\t\t\t\t\t\t\t\t// The GunCon 1 and 2 both report out-of-screen x values\n\t\t\t\t\t\t\t\t\t\t// more reliably than Y values, so X is used here.\n\t\t\t\t\t\t\t\t\t\tif (ev.value < absinfo.minimum || ev.value > absinfo.maximum)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t// Grace period of 50 ms. Longer times here make guns a bit\n\t\t\t\t\t\t\t\t\t\t\t// more reliable on dark screens, but introduce lag to any mechanics\n\t\t\t\t\t\t\t\t\t\t\t// where you want to shoot offscreen (e.g., to reload.)\n\t\t\t\t\t\t\t\t\t\t\tif (!crtgun_timeout[i]) crtgun_timeout[i] = GetTimer(50);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tcrtgun_timeout[i] = 0;\n\t\t\t\t\t\t\t\t\t\t\tinput[i].lastx = ev.value;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// For the window between losing the gun signal and the timer\n\t\t\t\t\t\t\t\t\t\t// running out, report the last on-screen coordinate\n\t\t\t\t\t\t\t\t\t\tif (crtgun_timeout[i] && !CheckTimer(crtgun_timeout[i]))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tev.value = input[i].lastx;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (ev.code == ABS_Y)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tabsinfo.minimum = input[i].guncal[0];\n\t\t\t\t\t\t\t\t\t\tabsinfo.maximum = input[i].guncal[1];\n\n\t\t\t\t\t\t\t\t\t\t// Handle gun going off-screen\n\t\t\t\t\t\t\t\t\t\tif (crtgun_timeout[i])\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t// For the window between losing the gun signal and the timer\n\t\t\t\t\t\t\t\t\t\t\t// running out, report the last on-screen coordinate\n\t\t\t\t\t\t\t\t\t\t\tif (!CheckTimer(crtgun_timeout[i]))\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tev.value = input[i].lasty;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tinput[i].lasty = ev.value;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (ev.type == EV_KEY && user_io_osd_is_visible())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_WIIMOTE || input[i].quirk == QUIRK_LIGHTGUN_CRT || input[i].quirk == QUIRK_LIGHTGUN)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (menu_lightgun_cb(i, ev.type, ev.code, ev.value)) continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// redirect further actions to left joycon in combined mode\n\t\t\t\t\t\t\t\tif (JOYCON_COMBINED(i))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (JOYCON_RIGHT(i)) i = input[i].bind;\n\t\t\t\t\t\t\t\t\tdev = i;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!noabs) input_cb(&ev, &absinfo, i);\n\n\t\t\t\t\t\t\t\t// simulate digital directions from analog\n\t\t\t\t\t\t\t\tif (ev.type == EV_ABS && !(mapping && mapping_type <= 1 && mapping_button < -4) && !(ev.code <= 1 && input[dev].lightgun) && input[dev].quirk != QUIRK_PDSP && input[dev].quirk != QUIRK_MSSP)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinput_absinfo *pai = 0;\n\t\t\t\t\t\t\t\t\tuint8_t axis_edge = 0;\n\t\t\t\t\t\t\t\t\tif ((absinfo.maximum == 1 && absinfo.minimum == -1) || (absinfo.maximum == 2 && absinfo.minimum == 0))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (ev.value == absinfo.minimum) axis_edge = 1;\n\t\t\t\t\t\t\t\t\t\tif (ev.value == absinfo.maximum) axis_edge = 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tpai = &absinfo;\n\t\t\t\t\t\t\t\t\t\tint range = absinfo.maximum - absinfo.minimum + 1;\n\t\t\t\t\t\t\t\t\t\tint center = absinfo.minimum + (range / 2);\n\t\t\t\t\t\t\t\t\t\tint treshold = range / 4;\n\n\t\t\t\t\t\t\t\t\t\tint only_max = 1;\n\t\t\t\t\t\t\t\t\t\tfor (int n = 0; n < 4; n++) if (input[dev].mmap[SYS_AXIS1_X + n] && ((input[dev].mmap[SYS_AXIS1_X + n] & 0xFFFF) == ev.code)) only_max = 0;\n\n\t\t\t\t\t\t\t\t\t\tif (ev.value < center - treshold && !only_max) axis_edge = 1;\n\t\t\t\t\t\t\t\t\t\tif (ev.value > center + treshold) axis_edge = 2;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tuint8_t last_state = input[dev].axis_edge[ev.code & 255];\n\t\t\t\t\t\t\t\t\tinput[dev].axis_edge[ev.code & 255] = axis_edge;\n\n\t\t\t\t\t\t\t\t\t//printf(\"last_state=%d, axis_edge=%d\\n\", last_state, axis_edge);\n\t\t\t\t\t\t\t\t\tif (last_state != axis_edge)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint16_t ecode = KEY_EMU + (ev.code << 1) - 1;\n\t\t\t\t\t\t\t\t\t\tev.type = EV_KEY;\n\t\t\t\t\t\t\t\t\t\tif (last_state)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tev.value = 0;\n\t\t\t\t\t\t\t\t\t\t\tev.code = ecode + last_state;\n\t\t\t\t\t\t\t\t\t\t\tinput_cb(&ev, pai, i);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (axis_edge)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tev.value = 1;\n\t\t\t\t\t\t\t\t\t\t\tev.code = ecode + axis_edge;\n\t\t\t\t\t\t\t\t\t\t\tinput_cb(&ev, pai, i);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Menu button on 8BitDo Receiver in D-Input mode\n\t\t\t\t\t\t\t\t\tif (ev.code == 9 && input[dev].vid == 0x2dc8 && (input[dev].pid == 0x3100 || input[dev].pid == 0x3104))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tev.type = EV_KEY;\n\t\t\t\t\t\t\t\t\t\tev.code = KEY_EMU + (ev.code << 1);\n\t\t\t\t\t\t\t\t\t\tinput_cb(&ev, pai, i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t data[4] = {};\n\t\t\t\t\t\tif (read(pool[i].fd, data, sizeof(data)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint edev = i;\n\t\t\t\t\t\t\tint dev = i;\n\t\t\t\t\t\t\tif (input[i].bind >= 0) edev = input[i].bind; // mouse to event\n\t\t\t\t\t\t\tif (input[edev].bind >= 0) dev = input[edev].bind; // event to base device\n\n\t\t\t\t\t\t\tif ((input[i].quirk == QUIRK_DS4TOUCH || input[i].quirk == QUIRK_DS4))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//disable DS4 mouse in lightgun mode\n\t\t\t\t\t\t\t\tif (input[dev].lightgun) continue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (input[i].quirk == QUIRK_TOUCHGUN)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//don't use original raspad3 emulated mouse\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint xval, yval, zval;\n\t\t\t\t\t\t\txval = ((data[0] & 0x10) ? -256 : 0) | data[1];\n\t\t\t\t\t\t\tyval = ((data[0] & 0x20) ? -256 : 0) | data[2];\n\t\t\t\t\t\t\tzval = ((data[3] & 0x80) ? -256 : 0) | data[3];\n\n\t\t\t\t\t\t\tinput_absinfo absinfo = {};\n\t\t\t\t\t\t\tabsinfo.maximum = 255;\n\t\t\t\t\t\t\tabsinfo.minimum = 0;\n\n\t\t\t\t\t\t\tif (input[dev].quirk == QUIRK_MSSP)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint val;\n\t\t\t\t\t\t\t\tif(cfg.spinner_axis == 0)\n\t\t\t\t\t\t\t\t\tval = xval;\n\t\t\t\t\t\t\t\telse if(cfg.spinner_axis == 1)\n\t\t\t\t\t\t\t\t\tval = yval;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tval = zval;\n\n\t\t\t\t\t\t\t\tint btn = (data[0] & 7) ? 1 : 0;\n\t\t\t\t\t\t\t\tif (input[i].misc_flags != btn)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinput[i].misc_flags = btn;\n\t\t\t\t\t\t\t\t\tev.value = btn;\n\t\t\t\t\t\t\t\t\tev.type = EV_KEY;\n\t\t\t\t\t\t\t\t\tev.code = 0x120;\n\t\t\t\t\t\t\t\t\tinput_cb(&ev, &absinfo, i);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tint throttle = (cfg.spinner_throttle ? abs(cfg.spinner_throttle) : 100) * input[i].spinner_prediv;\n\t\t\t\t\t\t\t\tint inv = cfg.spinner_throttle < 0;\n\n\t\t\t\t\t\t\t\tinput[i].spinner_acc += (val * 100);\n\t\t\t\t\t\t\t\tint spinner = (input[i].spinner_acc <= -throttle || input[i].spinner_acc >= throttle) ? (input[i].spinner_acc / throttle) : 0;\n\t\t\t\t\t\t\t\tinput[i].spinner_acc -= spinner * throttle;\n\n\t\t\t\t\t\t\t\tif (spinner)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tev.value = inv ? -spinner : spinner;\n\t\t\t\t\t\t\t\t\tev.type = EV_REL;\n\t\t\t\t\t\t\t\t\tev.code = 7;\n\t\t\t\t\t\t\t\t\tinput_cb(&ev, &absinfo, i);\n\n\t\t\t\t\t\t\t\t\tinput[i].paddle_val += ev.value;\n\t\t\t\t\t\t\t\t\tif (input[i].paddle_val < 0) input[i].paddle_val = 0;\n\t\t\t\t\t\t\t\t\tif (input[i].paddle_val > 255) input[i].paddle_val = 255;\n\n\t\t\t\t\t\t\t\t\tev.value = input[i].paddle_val;\n\t\t\t\t\t\t\t\t\tev.type = EV_ABS;\n\t\t\t\t\t\t\t\t\tev.code = 8;\n\t\t\t\t\t\t\t\t\tinput_cb(&ev, &absinfo, i);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (is_menu() && !video_fb_state()) printf(\"%s: xval=%d, btn=%d, spinner=%d, paddle=%d\\n\", input[i].devname, val, btn, spinner, input[i].paddle_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsend_mouse_with_throttle(i, xval, yval, data[3]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pool[NUMDEV + 1].fd >= 0) && (pool[NUMDEV + 1].revents & POLLIN))\n\t\t\t{\n\t\t\t\tstatic char cmd[1024];\n\t\t\t\tint len = read(pool[NUMDEV + 1].fd, cmd, sizeof(cmd) - 1);\n\t\t\t\tif (len)\n\t\t\t\t{\n\t\t\t\t\tif (cmd[len - 1] == '\\n') cmd[len - 1] = 0;\n\t\t\t\t\tcmd[len] = 0;\n\t\t\t\t\tprintf(\"MiSTer_cmd: %s\\n\", cmd);\n\t\t\t\t\tif (!strncmp(cmd, \"fb_cmd\", 6)) video_cmd(cmd);\n\t\t\t\t\telse if (!strncmp(cmd, \"load_core \", 10))\n\t\t\t\t\t{\n\t\t\t\t\t\tif(isXmlName(cmd)) xml_load(cmd + 10);\n\t\t\t\t\t\telse fpga_load_rbf(cmd + 10);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(cmd, \"screenshot\", 10))\n\t\t\t\t\t{\n\t\t\t\t\t\tuser_io_screenshot_cmd(cmd);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(cmd, \"volume \", 7))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!strcmp(cmd + 7, \"mute\")) set_volume(0x81);\n\t\t\t\t\t\telse if (!strcmp(cmd + 7, \"unmute\")) set_volume(0x80);\n\t\t\t\t\t\telse if (cmd[7] >= '0' && cmd[7] <= '7') set_volume(0x40 - 0x30 + cmd[7]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pool[NUMDEV + 2].fd >= 0) && (pool[NUMDEV + 2].revents & POLLPRI))\n\t\t\t{\n\t\t\t\tstatic char status[16];\n\t\t\t\tif (read(pool[NUMDEV + 2].fd, status, sizeof(status) - 1) && status[0] != '0')\n\t\t\t\t{\n\t\t\t\t\tif (sysled_is_enabled || video_fb_state()) DISKLED_ON;\n\t\t\t\t}\n\t\t\t\tlseek(pool[NUMDEV + 2].fd, 0, SEEK_SET);\n\t\t\t}\n\t\t}\n\n\t\tif (cur_leds != leds_state)\n\t\t{\n\t\t\tcur_leds = leds_state;\n\t\t\tfor (int i = 0; i < NUMDEV; i++)\n\t\t\t{\n\t\t\t\tif (input[i].led)\n\t\t\t\t{\n\t\t\t\t\tev.type = EV_LED;\n\n\t\t\t\t\tev.code = LED_SCROLLL;\n\t\t\t\t\tev.value = (cur_leds&HID_LED_SCROLL_LOCK) ? 1 : 0;\n\t\t\t\t\twrite(pool[i].fd, &ev, sizeof(struct input_event));\n\n\t\t\t\t\tev.code = LED_NUML;\n\t\t\t\t\tev.value = (cur_leds&HID_LED_NUM_LOCK) ? 1 : 0;\n\t\t\t\t\twrite(pool[i].fd, &ev, sizeof(struct input_event));\n\n\t\t\t\t\tev.code = LED_CAPSL;\n\t\t\t\t\tev.value = (cur_leds&HID_LED_CAPS_LOCK) ? 1 : 0;\n\t\t\t\t\twrite(pool[i].fd, &ev, sizeof(struct input_event));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint input_poll(int getchar)\n{\n\tPROFILE_FUNCTION();\n\n\tstatic int af[NUMPLAYERS] = {};\n\tstatic uint32_t time[NUMPLAYERS] = {};\n\tstatic uint64_t joy_prev[NUMPLAYERS] = {};\n\n\tint ret = input_test(getchar);\n\tif (getchar) return ret;\n\n\tuinp_check_key();\n\n\tstatic int prev_dx = 0;\n\tstatic int prev_dy = 0;\n\n\tif (mouse_emu || ((user_io_get_kbdemu() == EMU_MOUSE) && kbd_mouse_emu))\n\t{\n\t\tif((prev_dx || mouse_emu_x || prev_dy || mouse_emu_y) && (!mouse_timer || CheckTimer(mouse_timer)))\n\t\t{\n\t\t\tmouse_timer = GetTimer(20);\n\n\t\t\tint dx = mouse_emu_x;\n\t\t\tint dy = mouse_emu_y;\n\t\t\tif (mouse_sniper ^ cfg.sniper_mode)\n\t\t\t{\n\t\t\t\tif (dx > 2) dx = 2;\n\t\t\t\tif (dx < -2) dx = -2;\n\t\t\t\tif (dy > 2) dy = 2;\n\t\t\t\tif (dy < -2) dy = -2;\n\t\t\t}\n\n\t\t\tmouse_cb(dx, dy);\n\t\t\tprev_dx = mouse_emu_x;\n\t\t\tprev_dy = mouse_emu_y;\n\t\t}\n\t}\n\n\tif (!mouse_emu_x && !mouse_emu_y) mouse_timer = 0;\n\n\tif (grabbed)\n\t{\n\t\tfor (int i = 0; i < NUMPLAYERS; i++)\n\t\t{\n\t\t\tif (af_delay[i] < AF_MIN) af_delay[i] = AF_MIN;\n\n\t\t\tif (!time[i]) time[i] = GetTimer(af_delay[i]);\n\t\t\tint send = 0;\n\t\t\tint newdir = ((((uint32_t)(joy[i]) | (uint32_t)(joy[i] >> 32)) & 0xF) != (((uint32_t)(joy_prev[i]) | (uint32_t)(joy_prev[i] >> 32)) & 0xF));\n\t\t\t\n\t\t\tif (joy[i] != joy_prev[i])\n\t\t\t{\n\t\t\t\tif ((joy[i] ^ joy_prev[i]) & autofire[i])\n\t\t\t\t{\n\t\t\t\t\ttime[i] = GetTimer(af_delay[i]);\n\t\t\t\t\taf[i] = 0;\n\t\t\t\t}\n\n\t\t\t\tsend = 1;\n\t\t\t\tjoy_prev[i] = joy[i];\n\t\t\t}\n\n\t\t\tif (CheckTimer(time[i]))\n\t\t\t{\n\t\t\t\ttime[i] = GetTimer(af_delay[i]);\n\t\t\t\taf[i] = !af[i];\n\t\t\t\tif (joy[i] & autofire[i]) send = 1;\n\t\t\t}\n\n\t\t\tif (send)\n\t\t\t{\n\t\t\t\tuser_io_digital_joystick(i, af[i] ? joy[i] & ~autofire[i] : joy[i], newdir);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!grabbed || user_io_osd_is_visible())\n\t{\n\t\tfor (int i = 0; i < NUMPLAYERS; i++)\n\t\t{\n\t\t\tif(joy[i]) user_io_digital_joystick(i, 0, 1);\n\n\t\t\tjoy[i] = 0;\n\t\t\taf[i] = 0;\n\t\t\tautofire[i] = 0;\n\t\t}\n\t}\n\n\tif (mouse_req)\n\t{\n\t\tstatic uint32_t old_time = 0;\n\t\tuint32_t time = GetTimer(0);\n\t\tif ((time - old_time > 15) || (mouse_req & 2))\n\t\t{\n\t\t\told_time = time;\n\t\t\tuser_io_mouse(mouse_btn | mice_btn, mouse_x, mouse_y, mouse_w);\n\t\t\tmouse_req = 0;\n\t\t\tmouse_x = 0;\n\t\t\tmouse_y = 0;\n\t\t\tmouse_w = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint is_key_pressed(int key)\n{\n\tunsigned char bits[(KEY_MAX + 7) / 8];\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tif (pool[i].fd > 0)\n\t\t{\n\t\t\tunsigned long evbit = 0;\n\t\t\tif (ioctl(pool[i].fd, EVIOCGBIT(0, sizeof(evbit)), &evbit) >= 0)\n\t\t\t{\n\t\t\t\tif (evbit & (1 << EV_KEY))\n\t\t\t\t{\n\t\t\t\t\tmemset(bits, 0, sizeof(bits));\n\t\t\t\t\tif (ioctl(pool[i].fd, EVIOCGKEY(sizeof(bits)), &bits) >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (bits[key / 8] & (1 << (key % 8)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid input_notify_mode()\n{\n\t//reset mouse parameters on any mode switch\n\tkbd_mouse_emu = 1;\n\tmouse_sniper = 0;\n\tmouse_timer = 0;\n\tmouse_btn = 0;\n\tmouse_emu_x = 0;\n\tmouse_emu_y = 0;\n\tmouse_cb();\n\tmouse_btn_req();\n}\n\nvoid input_switch(int grab)\n{\n\tif (grab >= 0) grabbed = grab;\n\t//printf(\"input_switch(%d), grabbed = %d\\n\", grab, grabbed);\n\n\tfor (int i = 0; i < NUMDEV; i++)\n\t{\n\t\tif (pool[i].fd >= 0) ioctl(pool[i].fd, EVIOCGRAB, (grabbed | user_io_osd_is_visible()) ? 1 : 0);\n\t}\n}\n\nint input_state()\n{\n\treturn grabbed;\n}\n\nstatic char ovr_buttons[1024] = {};\nstatic char ovr_nmap[1024] = {};\nstatic char ovr_pmap[1024] = {};\n\nstatic char *get_btn(int type)\n{\n\tint i = 2;\n\twhile (1)\n\t{\n\t\tchar *p = user_io_get_confstr(i);\n\t\tif (!p) break;\n\n\t\tif ((p[0] == 'J' && !type) || (p[0] == 'j' && ((p[1] == 'n' && type == 1) || (p[1] == 'p' && type == 2))))\n\t\t{\n\t\t\tp = strchr(p, ',');\n\t\t\tif (!p) break;\n\n\t\t\tp++;\n\t\t\tif (!strlen(p)) break;\n\t\t\treturn p;\n\t\t}\n\n\t\ti++;\n\t}\n\treturn NULL;\n}\n\nchar *get_buttons(int type)\n{\n\tif (type == 0 && ovr_buttons[0]) return ovr_buttons;\n\tif (type == 1 && ovr_nmap[0]) return ovr_nmap;\n\tif (type == 2 && ovr_pmap[0]) return ovr_pmap;\n\n\treturn get_btn(type);\n}\n\nvoid set_ovr_buttons(char *s, int type)\n{\n\tswitch (type)\n\t{\n\tcase 0:\n\t\tsnprintf(ovr_buttons, sizeof(ovr_buttons), \"%s\", s);\n\t\tbreak;\n\n\tcase 1:\n\t\tsnprintf(ovr_nmap, sizeof(ovr_nmap), \"%s\", s);\n\t\tbreak;\n\n\tcase 2:\n\t\tsnprintf(ovr_pmap, sizeof(ovr_pmap), \"%s\", s);\n\t\tbreak;\n\t}\n}\n\nvoid parse_buttons()\n{\n\tjoy_bcount = 0;\n\n\tchar *str = get_buttons();\n\tif (!str) return;\n\n\tfor (int n = 0; n < 28; n++)\n\t{\n\t\tsubstrcpy(joy_bnames[n], str, n);\n\t\tif (!joy_bnames[n][0]) break;\n\t\tjoy_bcount++;\n\t}\n}\n"
        },
        {
          "name": "input.h",
          "type": "blob",
          "size": 2.9677734375,
          "content": "\n#ifndef EVINPUT_H\n#define EVINPUT_H\n\n#include <linux/input.h>\n\n#define HID_LED_NUM_LOCK    1\n#define HID_LED_CAPS_LOCK   2\n#define HID_LED_SCROLL_LOCK 4\n#define HID_LED_MASK        7\n\n#define NONE         0xFF\n#define LCTRL        0x000100\n#define LSHIFT       0x000200\n#define LALT         0x000400\n#define LGUI         0x000800\n#define RCTRL        0x001000\n#define RSHIFT       0x002000\n#define RALT         0x004000\n#define RGUI         0x008000\n#define MODMASK      0x00FF00\n\n#define OSD          0x010000  // to be used by OSD, not the core itself\n#define OSD_OPEN     0x020000  // OSD key not forwarded to core, but queued in arm controller\n#define CAPS_TOGGLE  0x040000  // caps lock toggle behaviour\n#define EXT          0x080000\n#define EMU_SWITCH_1 0x100000\n#define EMU_SWITCH_2 0x200000\n\n#define UPSTROKE     0x400000\n\n#define NUMBUTTONS         32\n#define BUTTON_DPAD_COUNT  12 // dpad + 8 buttons\n\n#define SYS_BTN_RIGHT       0\n#define SYS_BTN_LEFT        1\n#define SYS_BTN_DOWN        2\n#define SYS_BTN_UP          3\n#define SYS_BTN_A           4\n#define SYS_BTN_B           5\n#define SYS_BTN_X           6\n#define SYS_BTN_Y           7\n#define SYS_BTN_L           8\n#define SYS_BTN_R           9\n#define SYS_BTN_SELECT     10\n#define SYS_BTN_START      11\n#define SYS_MS_RIGHT       12\n#define SYS_MS_LEFT        13\n#define SYS_MS_DOWN        14\n#define SYS_MS_UP          15\n#define SYS_MS_BTN_L       16\n#define SYS_MS_BTN_R       17\n#define SYS_MS_BTN_M       18\n#define SYS_MS_BTN_EMU     19\n#define SYS_BTN_OSD_KTGL   20 // 20 for keyboard, 21+22 for gamepad\n#define SYS_BTN_MENU_FUNC  23\n#define SYS_AXIS1_X        24\n#define SYS_AXIS1_Y        25\n#define SYS_AXIS2_X        26\n#define SYS_AXIS2_Y        27\n#define SYS_AXIS_X         28\n#define SYS_AXIS_Y         29\n#define SYS_AXIS_MX        30\n#define SYS_AXIS_MY        31\n\n#define SYS_BTN_CNT_OK     21\n#define SYS_BTN_CNT_ESC    22\n\n#define SPIN_LEFT          30\n#define SPIN_RIGHT         31\n\n#define KEY_EMU (KEY_MAX+1)\n\nvoid set_kbdled(int mask, int state);\nint  get_kbdled(int mask);\nint  toggle_kbdled(int mask);\nvoid sysled_enable(int en);\n\nvoid input_notify_mode();\nint input_poll(int getchar);\nint is_key_pressed(int key);\n\nvoid start_map_setting(int cnt, int set = 0);\nint get_map_set();\nint get_map_button();\nint get_map_type();\nint get_map_clear();\nint get_map_cancel();\nint get_map_finish();\nvoid finish_map_setting(int dismiss);\nuint16_t get_map_vid();\nuint16_t get_map_pid();\nint has_default_map();\nvoid send_map_cmd(int key);\nvoid reset_players();\n\nuint32_t get_key_mod();\nuint32_t get_ps2_code(uint16_t key);\nuint32_t get_amiga_code(uint16_t key);\nuint32_t get_archie_code(uint16_t key);\n\nint input_has_lightgun();\nvoid input_lightgun_save(int idx, int32_t *cal);\n\nvoid input_switch(int grab);\nint input_state();\nvoid input_uinp_destroy();\n\nextern char joy_bnames[NUMBUTTONS][32];\nextern int  joy_bcount;\nextern uint8_t ps2_kbd_scan_set;\n\nvoid parse_buttons();\nchar *get_buttons(int type = 0);\nvoid set_ovr_buttons(char *s, int type);\n\n#endif\n"
        },
        {
          "name": "joymapping.cpp",
          "type": "blob",
          "size": 6.2783203125,
          "content": "/*\nThis file contains lookup information on known controllers\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <string.h>\n\n#include \"joymapping.h\"\n#include \"menu.h\"\n#include \"input.h\"\n#include \"user_io.h\"\n#include \"cfg.h\"\n\n#define DPAD_COUNT 4\n\n/*****************************************************************************/\nstatic void trim(char * s)\n{\n\tchar *p = s;\n\tint l = strlen(p);\n\tif (!l) return;\n\n\twhile (p[l - 1] == ' ') p[--l] = 0;\n\twhile (*p && (*p == ' ')) ++p, --l;\n\n\tmemmove(s, p, l + 1);\n}\n\nstatic char joy_names[NUMBUTTONS][32];\nstatic int joy_count = 0;\n\nstatic char joy_nnames[NUMBUTTONS][32];\nstatic char joy_pnames[NUMBUTTONS][32];\nstatic int defaults = 0;\n\nstatic void read_buttons()\n{\n\tchar *p;\n\n\tmemset(joy_names, 0, sizeof(joy_names));\n\tmemset(joy_nnames, 0, sizeof(joy_nnames));\n\tmemset(joy_pnames, 0, sizeof(joy_pnames));\n\tjoy_count = 0;\n\tdefaults = 0;\n\n\tuser_io_read_confstr();\n\n\t// this option used as default name map (unless jn/jp is supplied)\n\tp = get_buttons(0);\n\tif (p)\n\t{\n\t\tfor (int n = 0; n < NUMBUTTONS - DPAD_COUNT; n++)\n\t\t{\n\t\t\tsubstrcpy(joy_names[n], p, n);\n\t\t\tif (!joy_names[n][0]) break;\n\n\t\t\tprintf(\"joy_name[%d] = %s\\n\", n, joy_names[n]);\n\n\t\t\tmemcpy(joy_nnames[n], joy_names[n], sizeof(joy_nnames[0]));\n\t\t\tchar *sstr = strchr(joy_nnames[n], '(');\n\t\t\tif (sstr) *sstr = 0;\n\t\t\ttrim(joy_nnames[n]);\n\n\t\t\tif (!joy_nnames[n][0]) break;\n\t\t\tjoy_count++;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t// - supports empty name to skip the button from default map\n\t// - only base button names must be used (ABXYLR Start Select)\n\n\t// name default map\n\tp = get_buttons(1);\n\tif (p)\n\t{\n\t\tmemset(joy_nnames, 0, sizeof(joy_nnames));\n\t\tfor (int n = 0; n < joy_count; n++)\n\t\t{\n\t\t\tsubstrcpy(joy_nnames[n], p, n);\n\t\t\ttrim(joy_nnames[n]);\n\t\t\tif (joy_nnames[n][0]) printf(\"joy_nname[%d] = %s\\n\", n, joy_nnames[n]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t// positional default map\n\tp = get_buttons(2);\n\tif (p)\n\t{\n\t\tdefaults = cfg.gamepad_defaults;\n\t\tfor (int n = 0; n < joy_count; n++)\n\t\t{\n\t\t\tsubstrcpy(joy_pnames[n], p, n);\n\t\t\ttrim(joy_pnames[n]);\n\t\t\tif (joy_pnames[n][0]) printf(\"joy_pname[%d] = %s\\n\", n, joy_pnames[n]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nstatic int is_fire(char* name)\n{\n\tif (!strncasecmp(name, \"fire\", 4) || !strncasecmp(name, \"button\", 6))\n\t{\n\t\tif (!strcasecmp(name, \"fire\") || strchr(name, '1')) return 1;\n\t\tif (strchr(name, '2')) return 2;\n\t\tif (strchr(name, '3')) return 3;\n\t\tif (strchr(name, '4')) return 4;\n\t}\n\n\treturn 0;\n}\n\nvoid map_joystick(uint32_t *map, uint32_t *mmap)\n{\n\t/*\n\tattemps to centrally defined core joy mapping to the joystick declaredy by a core config string\n\twe use the names declared by core with some special handling for specific edge cases\n\n\tInput button order is \"virtual SNES\" i.e.:\n\t\tA, B, X, Y, L, R, Select, Start\n\t*/\n\tread_buttons();\n\n\tmap[SYS_BTN_RIGHT] = mmap[SYS_BTN_RIGHT] & 0xFFFF;\n\tmap[SYS_BTN_LEFT]  = mmap[SYS_BTN_LEFT]  & 0xFFFF;\n\tmap[SYS_BTN_DOWN]  = mmap[SYS_BTN_DOWN]  & 0xFFFF;\n\tmap[SYS_BTN_UP]    = mmap[SYS_BTN_UP]    & 0xFFFF;\n\n\tif (mmap[SYS_AXIS_X] && !is_psx())\n\t{\n\t\tuint32_t key = KEY_EMU + (((uint16_t)mmap[SYS_AXIS_X]) << 1);\n\t\tmap[SYS_BTN_LEFT] = (key << 16) | map[SYS_BTN_LEFT];\n\t\tmap[SYS_BTN_RIGHT] = ((key+1) << 16) | map[SYS_BTN_RIGHT];\n\t}\n\n\tif (mmap[SYS_AXIS_Y] && !is_psx())\n\t{\n\t\tuint32_t key = KEY_EMU + (((uint16_t)mmap[SYS_AXIS_Y]) << 1);\n\t\tmap[SYS_BTN_UP] = (key << 16) | map[SYS_BTN_UP];\n\t\tmap[SYS_BTN_DOWN] = ((key + 1) << 16) | map[SYS_BTN_DOWN];\n\t}\n\n\t// loop through core requested buttons and construct result map\n\tfor (int i=0, n=0; i<joy_count; i++)\n\t{\n\t\tif (!strcmp(joy_names[i], \"-\")) continue;\n\n\t\tint idx = i+DPAD_COUNT;\n\t\tchar btn_name[32];\n\t\tstrcpy(btn_name, defaults ? joy_pnames[n] : joy_nnames[n]);\n\n\t\tchar *p = strchr(btn_name, '|');\n\t\tif (p) *p = 0;\n\n\t\tif(!strcasecmp(btn_name, \"A\")\n\t\t|| !strcasecmp(btn_name, \"Jump\")\n\t\t|| is_fire(btn_name) == 1)\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_A];\n\t\t}\n\n\t\telse if(!strcasecmp(btn_name, \"B\")\n\t\t|| is_fire(btn_name) == 2)\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_B];\n\t\t}\n\n\t\telse if(!strcasecmp(btn_name, \"X\")\n\t\t|| !strcasecmp(btn_name, \"C\")\n\t\t|| is_fire(btn_name) == 3)\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_X];\n\t\t}\n\n\t\telse if(!strcasecmp(btn_name, \"Y\")\n\t\t|| !strcasecmp(btn_name, \"D\")\n\t\t|| is_fire(btn_name) == 4)\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_Y];\n\t\t}\n\n\t\t// Genesis C and Z  and TG16 V and VI\n\t\telse if(!strcasecmp(btn_name, \"R\")\n\t\t|| !strcasecmp(btn_name, \"RT\")\n\t\t|| !strcasecmp(btn_name, \"Coin\"))\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_R];\n\t\t}\n\n\t\telse if(!strcasecmp(btn_name, \"L\")\n\t\t|| !strcasecmp(btn_name, \"LT\"))\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_L];\n\t\t}\n\n\t\telse if(!strcasecmp(btn_name, \"Select\")\n\t\t|| !strcasecmp(btn_name, \"Mode\")\n\t\t|| !strcasecmp(btn_name, \"Game Select\")\n\t\t|| !strcasecmp(btn_name, \"Start 2P\"))\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_SELECT];\n\t\t}\n\n\t\telse if(!strcasecmp(btn_name, \"Start\")\n\t\t|| !strcasecmp(btn_name, \"Run\")\n\t\t|| !strcasecmp(btn_name, \"Pause\")\n\t\t|| !strcasecmp(btn_name, \"Start 1P\"))\n\t\t{\n\t\t\tmap[idx] = mmap[SYS_BTN_START];\n\t\t}\n\n\t\tn++;\n\t}\n}\n\nint map_paddle_btn()\n{\n\tread_buttons();\n\tfor (int i = 0, n = 0; i < joy_count; i++)\n\t{\n\t\tif (!strcmp(joy_names[i], \"-\")) continue;\n\t\tchar *p = strchr(defaults ? joy_pnames[n] : joy_nnames[n], '|');\n\t\tif (p && !strcasecmp(p, \"|P\")) return i + SYS_BTN_A;\n\t\tn++;\n\t}\n\treturn SYS_BTN_A;\n}\n\nstatic const char* get_std_name(uint16_t code, uint32_t *mmap)\n{\n\tif (code)\n\t{\n\t\tif (code == mmap[SYS_BTN_A]) return \"[A]\";\n\t\tif (code == mmap[SYS_BTN_B]) return \"[B]\";\n\t\tif (code == mmap[SYS_BTN_X]) return \"[X]\";\n\t\tif (code == mmap[SYS_BTN_Y]) return \"[Y]\";\n\t\tif (code == mmap[SYS_BTN_L]) return \"[L]\";\n\t\tif (code == mmap[SYS_BTN_R]) return \"[R]\";\n\t\tif (code == mmap[SYS_BTN_SELECT]) return \"[\\x96]\";\n\t\tif (code == mmap[SYS_BTN_START]) return \"[\\x16]\";\n\t\treturn \"[ ]\";\n\t}\n\treturn NULL;\n}\n\nvoid map_joystick_show(uint32_t *map, uint32_t *mmap, int num)\n{\n\tstatic char mapinfo[1024];\n\tread_buttons();\n\n\tsprintf(mapinfo, \"Map (P%d):\", num);\n\tif (!num) sprintf(mapinfo, \" Map:\");\n\tchar *list = mapinfo + strlen(mapinfo);\n\n\t// loop through core requested buttons and construct result map\n\tfor (int i = 0; i < joy_count; i++)\n\t{\n\t\tif (!strcmp(joy_names[i], \"-\")) continue;\n\n\t\tconst char *btn = get_std_name((uint16_t)(map[i + DPAD_COUNT]), mmap);\n\t\tif (btn)\n\t\t{\n\t\t\tstrcat(mapinfo, \"\\n\");\n\t\t\tstrcat(mapinfo, btn);\n\t\t\tstrcat(mapinfo, \": \");\n\t\t\tstrcat(mapinfo, joy_names[i]);\n\t\t}\n\t}\n\n\tif(strlen(list) && cfg.controller_info) Info(mapinfo, cfg.controller_info * 1000);\n}\n"
        },
        {
          "name": "joymapping.h",
          "type": "blob",
          "size": 0.4267578125,
          "content": "/*****************************************************************************/\n// Handle mapping of various joystick controllers\n/*****************************************************************************/\n\n#ifndef JOYMAPPING_H\n#define JOYMAPPING_H\n\n#include <inttypes.h>\n\nvoid map_joystick(uint32_t *map, uint32_t *mmap);\nvoid map_joystick_show(uint32_t *map, uint32_t *mmap, int num);\nint map_paddle_btn();\n\n#endif // JOYMAPPING_H\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "logo.h",
          "type": "blob",
          "size": 13.60546875,
          "content": "#ifndef LOGO_H\n#define LOGO_H\nconst unsigned char logodata[10][227] = {\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,\n\t0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0x80, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0,\n\t0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0x00, 0x00,\n\t0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF0, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xF0,\n\t0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0,\n\t0x00, 0x00, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,\n\t0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,\n\t0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,\n\t0x00, 0x80, 0x87, 0x8F, 0x8F, 0x9F, 0x9F, 0x9F, 0x9F, 0x1F, 0x1F, 0x1F, 0x0F, 0x0F, 0x07, 0x03,\n\t0xC0, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x1F,\n\t0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F, 0x0F, 0x03, 0x01,\n\t0x10, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,\n\t0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x9F, 0x8F, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,\n\t0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,\n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80,\n\t0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0x3F, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,\n\t0x00, 0x00, 0x80, 0xC0, 0xF8, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x07, 0xE1,\n\t0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x03, 0x00, 0xF0,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00,\n\t0x03, 0x1F, 0x3F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,\n\t0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x03, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF8, 0xFC,\n\t0xFC, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x1F, 0x0F, 0x0F, 0x8F, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x80, 0xF8, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFC, 0xFE, 0x7F, 0x7F, 0x7F,\n\t0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x80, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0x3F, 0x03, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x03, 0x00, 0x00, 0xE0, 0xFE, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x01, 0x80, 0xF8, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0xC0, 0xC0,\n\t0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x07, 0x0F, 0x9F, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x03, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3F, 0x3F, 0x3F, 0x3F,\n\t0x3F, 0x3F, 0x1F, 0x1F, 0x1F, 0x0F, 0x0F, 0x07, 0x03, 0x01, 0xC0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0F, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x03,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0x3F, 0x0F, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x3F, 0x7F,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x01, 0x00, 0x00, 0x1F, 0x3F, 0x7F, 0x7F,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x30, 0x3F, 0x7F, 0x7F,\n\t0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x3F, 0x7F,\n\t0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,\n\t0xFE, 0x7E, 0x7E, 0x7E, 0x3F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0,\n\t0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70,\n\t0xB0, 0xB0, 0x70, 0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0, 0xF0, 0xF0,\n\t0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0,\n\t0x70, 0x30, 0x30, 0x70, 0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70,\n\t0x30, 0x30, 0x70, 0xF0, 0x70, 0xB0, 0xB1, 0x71, 0xF1, 0xF1, 0xF1, 0xF1, 0x71, 0xB1, 0xB0, 0x70,\n\t0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70, 0xB0, 0xB0, 0x70, 0xF0,\n\t0x70, 0xB0, 0xB0, 0x70, 0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0, 0x70, 0x30, 0x30, 0x70, 0xF0, 0x70,\n\t0x30, 0x30, 0x70, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x90, 0x90, 0x90, 0x90, 0x90,\n\t0x90, 0x90, 0x90, 0x00, 0x00, 0x01, 0xF1, 0x91, 0x91, 0x91, 0x91, 0x90, 0x90, 0x90, 0x90, 0x60,\n\t0x00, 0x00, 0xE0, 0x10, 0x10, 0x10, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x00, 0x00, 0xE0, 0x90,\n\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07,\n\t0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07,\n\t0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,\n\t0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07,\n\t0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07,\n\t0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07,\n\t0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07,\n\t0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x07,\n\t0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x07, 0x00, 0x00, 0x07, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n\n\t{\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,  },\n};\n\n#endif\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 44.7919921875,
          "content": null
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 2.11328125,
          "content": "/*\nCopyright 2005, 2006, 2007 Dennis van Weeren\nCopyright 2008, 2009 Jakub Bednarski\nCopyright 2012 Till Harbaum\n\nThis file is part of Minimig\n\nMinimig is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\nMinimig is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <sched.h>\n#include <inttypes.h>\n#include <ctype.h>\n#include <string.h>\n#include \"menu.h\"\n#include \"user_io.h\"\n#include \"input.h\"\n#include \"fpga_io.h\"\n#include \"scheduler.h\"\n#include \"osd.h\"\n#include \"offload.h\"\n\nconst char *version = \"$VER:\" VDATE;\n\nint main(int argc, char *argv[])\n{\n\t// Always pin main worker process to core #1 as core #0 is the\n\t// hardware interrupt handler in Linux.  This reduces idle latency\n\t// in the main loop by about 6-7x.\n\tcpu_set_t set;\n\tCPU_ZERO(&set);\n\tCPU_SET(1, &set);\n\tsched_setaffinity(0, sizeof(set), &set);\n\n\toffload_start();\n\n\tfpga_io_init();\n\n\tDISKLED_OFF;\n\n\tprintf(\"\\nMinimig by Dennis van Weeren\");\n\tprintf(\"\\nARM Controller by Jakub Bednarski\");\n\tprintf(\"\\nMiSTer code by Sorgelig\\n\\n\");\n\n\tprintf(\"Version %s\\n\\n\", version + 5);\n\n\tif (argc > 1) printf(\"Core path: %s\\n\", argv[1]);\n\tif (argc > 2) printf(\"XML path: %s\\n\", argv[2]);\n\n\tif (!is_fpga_ready(1))\n\t{\n\t\tprintf(\"\\nGPI[31]==1. FPGA is uninitialized or incompatible core loaded.\\n\");\n\t\tprintf(\"Quitting. Bye bye...\\n\");\n\t\texit(0);\n\t}\n\n\tFindStorage();\n\tuser_io_init((argc > 1) ? argv[1] : \"\",(argc > 2) ? argv[2] : NULL);\n\n#ifdef USE_SCHEDULER\n\tscheduler_init();\n\tscheduler_run();\n#else\n\twhile (1)\n\t{\n\t\tif (!is_fpga_ready(1))\n\t\t{\n\t\t\tfpga_wait_to_reset();\n\t\t}\n\n\t\tuser_io_poll();\n\t\tinput_poll(0);\n\t\tHandleUI();\n\t\tOsdUpdate();\n\t}\n#endif\n\treturn 0;\n}\n"
        },
        {
          "name": "mat4x4.h",
          "type": "blob",
          "size": 1.4541015625,
          "content": "#ifndef MAT4x4_H\r\n#define MAT4x4_H\r\n\r\n#include <inttypes.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\nstruct mat4x4\r\n{\r\n\tunion\r\n\t{\r\n\t\tstruct\r\n\t\t{\r\n\t\t\tfloat\r\n\t\t\tm11, m12, m13, m14,\r\n\t\t\tm21, m22, m23, m24,\r\n\t\t\tm31, m32, m33, m34,\r\n\t\t\tm41, m42, m43, m44;\r\n\t\t};\r\n\r\n\t\tfloat comp[16];\r\n\t\tfloat comp_2d[4][4];\r\n\t};\r\n\r\n\tmat4x4(void)\r\n\t{\r\n\t\tmemset(comp, 0, 16*sizeof(float));\r\n\t}\r\n\r\n\tmat4x4(const float mat[16])\r\n\t: mat4x4()\r\n\t{\r\n\t\tfor ( size_t i = 0; i < 16; i++ )\r\n\t\t{\r\n\t\t\tcomp[i] = mat[i];\r\n\t\t}\r\n\t}\r\n\r\n\tvoid setIdentity()\r\n\t{\r\n\t\tm11 = m22 = m33 = m44 = 1.0f;\r\n\t}\r\n\r\n\tmat4x4 operator* (const mat4x4 b)\r\n\t{\r\n\t\tmat4x4 a = *this;\r\n\t\tfor( size_t r = 0; r < 4; r++ )\r\n\t\t{\r\n\t\t\tfor( size_t c = 0; c < 4; c++ )\r\n\t\t\t{\r\n\t\t\t\tcomp_2d[r][c] =\r\n\t\t\t\tb.comp_2d[r][0] * a.comp_2d[0][c] +\r\n\t\t\t\tb.comp_2d[r][1] * a.comp_2d[1][c] +\r\n\t\t\t\tb.comp_2d[r][2] * a.comp_2d[2][c] +\r\n\t\t\t\tb.comp_2d[r][3] * a.comp_2d[3][c];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t// if the matrix has values over x, compress the rest down to make sure it fits\r\n\tvoid compress(float x)\r\n\t{\r\n\t\tfloat maximum = 0.0;\r\n\t\tbool max_found = false;\r\n\r\n\t\t// find maximum\r\n\t\tfor ( size_t i = 0; i < 16; i++)\r\n\t\t{\r\n\t\t\tfloat& y = comp[i];\r\n\r\n\t\t\tif (y > x)\r\n\t\t\t{\r\n\t\t\t\tmaximum = abs(y) > maximum ? abs(y) : maximum;\r\n\t\t\t\tmax_found = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// apply maximum, range will be [-x .. x]\r\n\t\tif (max_found)\r\n\t\t{\r\n\t\t\tfor ( size_t i = 0; i < 16; i++)\r\n\t\t\t{\r\n\t\t\t\tcomp[i] /= maximum;\r\n\t\t\t\tcomp[i] *= x;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n#endif\r\n"
        },
        {
          "name": "menu.cpp",
          "type": "blob",
          "size": 176.271484375,
          "content": "/*\nCopyright 2005, 2006, 2007 Dennis van Weeren\nCopyright 2008, 2009 Jakub Bednarski\n\nThis file is part of Minimig\n\nMinimig is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\nMinimig is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// 2009-11-14   - OSD labels changed\n// 2009-12-15   - added display of directory name extensions\n// 2010-01-09   - support for variable number of tracks\n// 2016-06-01   - improvements to 8-bit menu\n\n#include <stdlib.h>\n#include <inttypes.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <ifaddrs.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <sched.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <libgen.h>\n#include <bluetooth.h>\n#include <hci.h>\n#include <hci_lib.h>\n\n#include \"file_io.h\"\n#include \"osd.h\"\n#include \"hardware.h\"\n#include \"menu.h\"\n#include \"user_io.h\"\n#include \"debug.h\"\n#include \"fpga_io.h\"\n#include \"cfg.h\"\n#include \"input.h\"\n#include \"battery.h\"\n#include \"cheats.h\"\n#include \"video.h\"\n#include \"audio.h\"\n#include \"joymapping.h\"\n#include \"recent.h\"\n#include \"support.h\"\n#include \"bootcore.h\"\n#include \"ide.h\"\n#include \"profiling.h\"\n\n/*menu states*/\nenum MENU\n{\n\tMENU_NONE1,\n\tMENU_NONE2,\n\tMENU_INFO,\n\n\tMENU_SYSTEM1,\n\tMENU_SYSTEM2,\n\tMENU_COMMON1,\n\tMENU_COMMON2,\n\tMENU_MISC1,\n\tMENU_MISC2,\n\n\tMENU_SELECT_INI1,\n\tMENU_SELECT_INI2,\n\n\tMENU_FILE_SELECT1,\n\tMENU_FILE_SELECT2,\n\tMENU_CORE_FILE_SELECTED1,\n\tMENU_CORE_FILE_SELECTED2,\n\tMENU_CORE_FILE_CANCELED,\n\tMENU_RECENT1,\n\tMENU_RECENT2,\n\tMENU_RECENT3,\n\tMENU_RECENT4,\n\tMENU_ABOUT1,\n\tMENU_ABOUT2,\n\tMENU_RESET1,\n\tMENU_RESET2,\n\tMENU_UNLOCK1,\n\tMENU_UNLOCK2,\n\tMENU_UNLOCK3,\n\n\tMENU_JOYSYSMAP,\n\tMENU_JOYDIGMAP,\n\tMENU_JOYDIGMAP1,\n\tMENU_JOYDIGMAP2,\n\tMENU_JOYDIGMAP3,\n\tMENU_JOYDIGMAP4,\n\tMENU_JOYRESET,\n\tMENU_JOYRESET1,\n\tMENU_JOYKBDMAP,\n\tMENU_JOYKBDMAP1,\n\tMENU_JOYKBDMAP2,\n\tMENU_KBDMAP,\n\tMENU_KBDMAP1,\n\tMENU_KBDMAP2,\n\tMENU_BTPAIR,\n\tMENU_BTPAIR2,\n\tMENU_LGCAL,\n\tMENU_LGCAL1,\n\tMENU_LGCAL2,\n\n\tMENU_SCRIPTS_PRE,\n\tMENU_SCRIPTS_PRE1,\n\tMENU_SCRIPTS,\n\tMENU_SCRIPTS1,\n\tMENU_SCRIPTS_FB,\n\tMENU_SCRIPTS_FB2,\n\n\tMENU_DOC_FILE_SELECTED,\n\tMENU_DOC_FILE_SELECTED_2,\n\n\tMENU_CHEATS1,\n\tMENU_CHEATS2,\n\n\tMENU_UART1,\n\tMENU_UART2,\n\tMENU_UART3,\n\tMENU_UART4,\n\tMENU_BAUD1,\n\tMENU_BAUD2,\n\n\tMENU_SFONT_FILE_SELECTED,\n\n\tMENU_VIDEOPROC1,\n\tMENU_VIDEOPROC2,\n\tMENU_COEFF_FILE_SELECTED,\n\tMENU_GAMMA_FILE_SELECTED,\n\tMENU_SMASK_FILE_SELECTED,\n\tMENU_PRESET_FILE_SELECTED,\n\n\tMENU_AFILTER_FILE_SELECTED,\n\n\t// Generic\n\tMENU_GENERIC_MAIN1,\n\tMENU_GENERIC_MAIN2,\n\tMENU_GENERIC_FILE_SELECTED,\n\tMENU_GENERIC_IMAGE_SELECTED,\n\tMENU_GENERIC_SAVE_WAIT,\n\n\t// Arcade\n\tMENU_ARCADE_DIP1,\n\tMENU_ARCADE_DIP2,\n\n\t// Minimig\n\tMENU_MINIMIG_MAIN1,\n\tMENU_MINIMIG_MAIN2,\n\tMENU_MINIMIG_VIDEO1,\n\tMENU_MINIMIG_VIDEO2,\n\tMENU_MINIMIG_CHIPSET1,\n\tMENU_MINIMIG_CHIPSET2,\n\tMENU_MINIMIG_DISK1,\n\tMENU_MINIMIG_DISK2,\n\tMENU_MINIMIG_HDFFILE_SELECTED,\n\tMENU_MINIMIG_ADFFILE_SELECTED,\n\tMENU_MINIMIG_ROMFILE_SELECTED,\n\tMENU_MINIMIG_LOADCONFIG1,\n\tMENU_MINIMIG_LOADCONFIG2,\n\tMENU_MINIMIG_SAVECONFIG1,\n\tMENU_MINIMIG_SAVECONFIG2,\n\n\t// Atari ST\n\tMENU_ST_MAIN1,\n\tMENU_ST_MAIN2,\n\tMENU_ST_SYSTEM1,\n\tMENU_ST_SYSTEM2,\n\tMENU_ST_FDD_FILE_SELECTED,\n\tMENU_ST_HDD_FILE_SELECTED,\n\tMENU_ST_SYSTEM_FILE_SELECTED,\n\tMENU_ST_LOAD_CONFIG1,\n\tMENU_ST_LOAD_CONFIG2,\n\tMENU_ST_SAVE_CONFIG1,\n\tMENU_ST_SAVE_CONFIG2,\n\n\t// Archie\n\tMENU_ARCHIE_MAIN1,\n\tMENU_ARCHIE_MAIN2,\n\tMENU_ARCHIE_MAIN_FILE_SELECTED,\n\n\t// MT32-pi\n\tMENU_MT32PI_MAIN1,\n\tMENU_MT32PI_MAIN2,\n};\n\nstatic uint32_t menustate = MENU_NONE1;\nstatic uint32_t parentstate;\nstatic uint32_t menusub = 0;\nstatic uint32_t menusub_last = 0; //for when we allocate it dynamically and need to know last row\nstatic uint64_t menumask = 0; // Used to determine which rows are selectable...\nstatic uint32_t menu_timer = 0;\nstatic uint32_t menu_save_timer = 0;\nstatic uint32_t load_addr = 0;\nstatic int32_t  bt_timer = 0;\n\nstatic bool osd_unlocked = 1;\nstatic char osd_code_entry[32];\nstatic uint32_t osd_lock_timer = 0;\n\n\nextern const char *version;\n\nconst char *config_tos_wrprot[] = { \"None\", \"A:\", \"B:\", \"A: and B:\" };\n\nconst char *config_scanlines_msg[] = { \"Off\", \"HQ2x\", \"CRT 25%\" , \"CRT 50%\" , \"CRT 75%\" };\nconst char *config_blank_msg[] = { \"Blank\", \"Blank+\" };\nconst char *config_dither_msg[] = { \"off\", \"SPT\", \"RND\", \"S+R\" };\nconst char *config_autofire_msg[] = { \"        AUTOFIRE OFF\", \"        AUTOFIRE FAST\", \"        AUTOFIRE MEDIUM\", \"        AUTOFIRE SLOW\" };\nconst char *config_joystick_mode[] = { \"Digital\", \"Analog\", \"CD32\", \"Analog\" };\nconst char *config_button_turbo_msg[] = { \"OFF\", \"FAST\", \"MEDIUM\", \"SLOW\" };\nconst char *config_button_turbo_choice_msg[] = { \"A only\", \"B only\", \"A & B\" };\nconst char *joy_button_map[] = { \"RIGHT\", \"LEFT\", \"DOWN\", \"UP\", \"BUTTON A\", \"BUTTON B\", \"BUTTON X\", \"BUTTON Y\", \"BUTTON L\", \"BUTTON R\", \"SELECT\", \"START\", \"KBD TOGGLE\", \"MENU\", \"    Stick 1: Tilt RIGHT\", \"    Stick 1: Tilt DOWN\", \"   Mouse emu X: Tilt RIGHT\", \"   Mouse emu Y: Tilt DOWN\" };\nconst char *joy_ana_map[] = { \"    DPAD test: Press RIGHT\", \"    DPAD test: Press DOWN\", \"   Stick 1 Test: Tilt RIGHT\", \"   Stick 1 Test: Tilt DOWN\", \"   Stick 2 Test: Tilt RIGHT\", \"   Stick 2 Test: Tilt DOWN\" };\nconst char *config_stereo_msg[] = { \"0%\", \"25%\", \"50%\", \"100%\" };\nconst char *config_uart_msg[] = { \"      None\", \"       PPP\", \"   Console\", \"      MIDI\", \"     Modem\"};\nconst char *config_midilink_mode[] = {\"Local\", \"Local\", \"  USB\", \"  UDP\", \"-----\", \"-----\", \"  USB\" };\nconst char *config_afilter_msg[] = { \"Internal\",\"Custom\" };\nconst char *config_smask_msg[] = { \"None\", \"1x\", \"2x\", \"1x Rotated\", \"2x Rotated\" };\nconst char *config_scale[] = { \"Normal\", \"V-Integer\", \"HV-Integer-\", \"HV-Integer+\", \"HV-Integer\", \"???\", \"???\", \"???\" };\n\n#define DPAD_NAMES 4\n#define DPAD_BUTTON_NAMES 12  //DPAD_NAMES + 6 buttons + start/select\n\n#define script_line_length 1024\n#define script_lines 50\nstatic FILE *script_pipe;\nstatic int script_file;\nstatic char script_command[script_line_length];\nstatic int script_line;\nstatic char script_output[script_lines][script_line_length];\nstatic char script_line_output[script_line_length];\nstatic bool script_finished;\n\n// one screen width\nstatic const char* HELPTEXT_SPACER = \"                                \";\nstatic char helptext_custom[1024];\n\nenum HelpText_Message\n{\n\tHELPTEXT_NONE, HELPTEXT_CUSTOM, HELPTEXT_MAIN, HELPTEXT_HARDFILE, HELPTEXT_CHIPSET, HELPTEXT_MEMORY, HELPTEXT_EJECT, HELPTEXT_CLEAR\n};\n\nstatic const char *helptexts[] =\n{\n\t0,\n\thelptext_custom,\n\t\"                                Welcome to MiSTer! Use the cursor keys to navigate the menus. Use space bar or enter to select an item. Press Esc or F12 to exit the menus. Joystick emulation on the numeric keypad can be toggled with the numlock or scrlock key, while pressing Ctrl-Alt-0 (numeric keypad) toggles autofire mode.\",\n\t\"                                Minimig can emulate an A600/A1200 IDE harddisk interface. The emulation can make use of Minimig-style hardfiles (complete disk images) or UAE-style hardfiles (filesystem images with no partition table).\",\n\t\"                                Minimig's processor core can emulate a 68000 (cycle accuracy as A500/A600) or 68020 (maximum performance) processor with transparent cache.\",\n\t\"                                Minimig can make use of up to 2 megabytes of Chip RAM, up to 1.5 megabytes of Slow RAM (A500 Trapdoor RAM), and up to 384 megabytes of Fast RAM (8MB max for 68000 mode). To use the HRTmon feature you will need a file on the SD card named hrtmon.rom.\",\n\t\"                                Backspace key (or B-hold + A on gamepad) to unmount\",\n\t\"                                Backspace key (or B-hold + A on gamepad) to clear stored option. You have to reload the core to be able to use default value.\",\n};\n\nstatic const uint32_t helptext_timeouts[] =\n{\n\t10000,\n\t10000,\n\t10000,\n\t10000,\n\t10000,\n\t10000,\n\t10000,\n\t10000\n};\n\nstatic const char *info_top = \"\\x80\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x82\";\nstatic const char *info_bottom = \"\\x85\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x84\";\n\n// file selection menu variables\nstatic char fs_pFileExt[13] = \"xxx\";\nstatic uint32_t fs_ExtLen = 0;\nstatic uint32_t fs_Options;\nstatic uint32_t fs_MenuSelect;\nstatic uint32_t fs_MenuCancel;\n\nstatic char* GetExt(char *ext)\n{\n\tstatic char extlist[32];\n\tchar *p = extlist;\n\n\twhile (*ext) {\n\t\tstrcpy(p, \",\");\n\t\tstrncat(p, ext, 3);\n\t\twhile (*(p + strlen(p) - 1) == ' ') *(p + strlen(p) - 1) = 0;\n\t\tif (strlen(ext) <= 3) break;\n\t\text += 3;\n\t\tp += strlen(p);\n\t}\n\n\treturn extlist + 1;\n}\n\nstatic char SelectedDir[1024] = {};\nstatic char SelectedLabel[1024] = {};\n\nstatic char Selected_F[16][1024] = {};\nstatic char Selected_S[16][1024] = {};\nstatic char Selected_tmp[1024] = {};\n\nvoid StoreIdx_F(int idx, const char *path)\n{\n\tstrcpy(Selected_F[idx], path);\n}\n\nvoid StoreIdx_S(int idx, const char *path)\n{\n\tstrcpy(Selected_S[idx], path);\n}\n\nstatic char selPath[1024] = {};\n\nstatic int changeDir(char *dir)\n{\n\tchar curdir[128];\n\tmemset(curdir, 0, sizeof(curdir));\n\tif(!dir || !strcmp(dir, \"..\"))\n\t{\n\t\tif (!strlen(selPath))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tchar *p = strrchr(selPath, '/');\n\t\tif (p)\n\t\t{\n\t\t\t*p = 0;\n\t\t\tstrncpy(curdir, p + 1, sizeof(curdir) - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrncpy(curdir, selPath, sizeof(curdir) - 1);\n\t\t\tselPath[0] = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (strlen(selPath) + strlen(dir) > sizeof(selPath) - 100)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strlen(selPath)) strcat(selPath, \"/\");\n\t\tstrcat(selPath, dir);\n\t}\n\n\tScanDirectory(selPath, SCANF_INIT, fs_pFileExt, fs_Options);\n\tif(curdir[0])\n\t{\n\t\tScanDirectory(selPath, SCANF_SET_ITEM, curdir, fs_Options);\n\t}\n\treturn 1;\n}\n\nstatic const char *home_dir = NULL;\nstatic char filter[256] = {};\nstatic unsigned long filter_typing_timer = 0;\n\n// this function displays file selection menu\nvoid SelectFile(const char* path, const char* pFileExt, int Options, unsigned char MenuSelect, unsigned char MenuCancel)\n{\n\tstatic char tmp[1024];\n\tprintf(\"pFileExt = %s\\n\", pFileExt);\n\tfilter_typing_timer = 0;\n\tfilter[0] = 0;\n\n\tstrncpy(selPath, path, sizeof(selPath) - 1);\n\tselPath[sizeof(selPath) - 1] = 0;\n\n\tif (Options & SCANO_CORES)\n\t{\n\t\tstrcpy(selPath, get_rbf_dir());\n\t\tif (strlen(get_rbf_name()))\n\t\t{\n\t\t\tif(strlen(selPath)) strcat(selPath, \"/\");\n\t\t\tstrcat(selPath, get_rbf_name());\n\t\t}\n\t\tpFileExt = \"RBFMRAMGL\";\n\t\thome_dir = NULL;\n\t}\n\telse if (Options & SCANO_TXT)\n\t{\n\t\tif(pFileExt == 0) pFileExt = \"TXT\";\n\t\thome_dir = NULL;\n\t}\n\telse\n\t{\n\t\tconst char *home = is_menu() ? \"Scripts\" : user_io_get_core_path(\n\t\t\t(is_pce() && !strncasecmp(pFileExt, \"CUE\", 3)) ? PCECD_DIR :\n\t\t\t(is_neogeo() && !strncasecmp(pFileExt, \"CUE\", 3)) ? NEOCD_DIR :\n\t\t\tNULL, 1);\n\t\thome_dir = strrchr(home, '/');\n\t\tif (home_dir) home_dir++;\n\t\telse home_dir = home;\n\n\t\tif (Options & SCANO_SAVES)\n\t\t{\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%s/%s\", SAVE_DIR, CoreName2);\n\t\t\thome = tmp;\n\t\t}\n\n\t\tif (strncasecmp(home, selPath, strlen(home)) || !strcasecmp(home, selPath) || (!FileExists(selPath) && !PathIsDir(selPath)))\n\t\t{\n\t\t\tOptions &= ~SCANO_NOENTER;\n\t\t\tstrcpy(selPath, home);\n\t\t}\n\t}\n\n\tScanDirectory(selPath, SCANF_INIT, pFileExt, Options);\n\tAdjustDirectory(selPath);\n\n\tstrcpy(fs_pFileExt, pFileExt);\n\tfs_ExtLen = strlen(fs_pFileExt);\n\tfs_Options = Options & ~SCANO_NOENTER;\n\tfs_MenuSelect = MenuSelect;\n\tfs_MenuCancel = MenuCancel;\n\n\tmenustate = MENU_FILE_SELECT1;\n}\n\n#define STD_EXIT       \"            exit\"\n#define STD_BACK       \"            back\"\n#define STD_SPACE_EXIT \"        SPACE to exit\"\n#define STD_COMBO_EXIT \"      Ctrl+ESC to exit\"\n\n// conversion table of Amiga keyboard scan codes to ASCII codes\nstatic const uint8_t keycode_table[128] =\n{\n\t0,'1','2','3','4','5','6','7','8','9','0',  0,  0,  0,  0,  0,\n\t'Q','W','E','R','T','Y','U','I','O','P',  0,  0,  0,  0,  0,  0,\n\t'A','S','D','F','G','H','J','K','L',  0,  0,  0,  0,  0,  0,  0,\n\t0,'Z','X','C','V','B','N','M',  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n};\n\nstatic uint8_t GetASCIIKey(uint32_t keycode)\n{\n\tif (keycode & UPSTROKE)\n\t\treturn 0;\n\n\treturn keycode_table[get_amiga_code(keycode & 0xFFFF) & 0x7F];\n}\n\nstatic int select_ini = 0;\nvoid SelectINI()\n{\n\tselect_ini = 1;\n}\n\n/* the Atari core handles OSD keys competely inside the core */\nstatic uint32_t menu_key = 0;\n\nvoid menu_key_set(unsigned int c)\n{\n\t//printf(\"OSD enqueue: %x\\n\", c);\n\tmenu_key = c;\n}\n\n// get key status\nstatic int hold_cnt = 0;\nstatic uint32_t menu_key_get(void)\n{\n\tstatic uint32_t prev_key = 0;\n\tstatic unsigned long db_time = 0;\n\tif (prev_key != menu_key || !db_time)\n\t{\n\t\tprev_key = menu_key;\n\t\tdb_time = GetTimer(20);\n\t}\n\n\tuint32_t c = 0;\n\tif (CheckTimer(db_time))\n\t{\n\t\tstatic uint32_t c2;\n\t\tstatic unsigned long repeat;\n\t\tuint32_t c1;\n\n\t\tc1 = menu_key;\n\t\tc = 0;\n\t\tif (c1 != c2)\n\t\t{\n\t\t\tc = c1;\n\t\t\thold_cnt = 1;\n\t\t}\n\t\tc2 = c1;\n\n\t\t// generate repeat \"key-pressed\" events\n\t\tif ((c1 & UPSTROKE) || (!c1))\n\t\t{\n\t\t\thold_cnt = 0;\n\t\t\trepeat = GetTimer(REPEATDELAY);\n\t\t}\n\t\telse if (CheckTimer(repeat))\n\t\t{\n\t\t\trepeat = GetTimer(REPEATRATE);\n\t\t\tif (GetASCIIKey(c1) || ((menustate == MENU_COMMON2) && (menusub == 17)) || ((menustate == MENU_SYSTEM2) && (menusub == 5)))\n\t\t\t{\n\t\t\t\tc = c1;\n\t\t\t\thold_cnt++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// currently no key pressed\n\tif (!c && !select_ini)\n\t{\n\t\tstatic unsigned long longpress = 0, longpress_consumed = 0;\n\t\tstatic unsigned char last_but = 0;\n\t\tunsigned char but = user_io_menu_button();\n\n\t\tif (but && !last_but) longpress = GetTimer(3000);\n\t\tif (but && CheckTimer(longpress) && !longpress_consumed)\n\t\t{\n\t\t\tlongpress_consumed = 1;\n\t\t\tif (menustate == MENU_SCRIPTS1) c = KEY_BACKSPACE;\n\t\t\telse menustate = MENU_BTPAIR;\n\t\t}\n\n\t\tif (!but && last_but && !longpress_consumed) c = KEY_F12;\n\n\t\tif (!but) longpress_consumed = 0;\n\t\tlast_but = but;\n\t}\n\n\tif (!c)\n\t{\n\t\tstatic unsigned long longpress = 0, longpress_consumed = 0;\n\t\tstatic unsigned char last_but = 0;\n\t\tunsigned char but = user_io_user_button();\n\n\t\tif (user_io_osd_is_visible())\n\t\t{\n\t\t\tif (but && !last_but) longpress = GetTimer(1500);\n\t\t\tif (but && CheckTimer(longpress) && !longpress_consumed)\n\t\t\t{\n\t\t\t\tlongpress_consumed = 1;\n\t\t\t\tif (is_menu())\n\t\t\t\t{\n\t\t\t\t\tif (menustate == MENU_SYSTEM2 || menustate == MENU_FILE_SELECT2) menustate = MENU_JOYSYSMAP;\n\t\t\t\t}\n\t\t\t\telse if (get_map_vid() || get_map_pid())\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_JOYRESET;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!but && last_but && !longpress_consumed)\n\t\t\t{\n\t\t\t\tif (select_ini)\n\t\t\t\t{\n\t\t\t\t\tc = KEY_ESC | UPSTROKE;\n\t\t\t\t}\n\t\t\t\telse if (get_map_vid() || get_map_pid())\n\t\t\t\t{\n\t\t\t\t\tsend_map_cmd(KEY_ALTERASE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!but) longpress_consumed = 0;\n\t\tlast_but = but;\n\t}\n\n\treturn(c);\n}\n\nstatic char* getNet(int spec)\n{\n\tint netType = 0;\n\tstruct ifaddrs *ifaddr, *ifa, *ifae = 0, *ifaw = 0;\n\tstatic char host[NI_MAXHOST];\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t{\n\t\tprintf(\"getifaddrs: error\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next)\n\t{\n\t\tif (ifa->ifa_addr == NULL) continue;\n\t\tif (!memcmp(ifa->ifa_addr->sa_data, \"\\x00\\x00\\xa9\\xfe\", 4)) continue; // 169.254.x.x\n\n\t\tif ((strcmp(ifa->ifa_name, \"eth0\") == 0)     && (ifa->ifa_addr->sa_family == AF_INET)) ifae = ifa;\n\t\tif ((strncmp(ifa->ifa_name, \"wlan\", 4) == 0) && (ifa->ifa_addr->sa_family == AF_INET)) ifaw = ifa;\n\t}\n\n\tifa = 0;\n\tnetType = 0;\n\tif (ifae && (!spec || spec == 1))\n\t{\n\t\tifa = ifae;\n\t\tnetType = 1;\n\t}\n\n\tif (ifaw && (!spec || spec == 2))\n\t{\n\t\tifa = ifaw;\n\t\tnetType = 2;\n\t}\n\n\tif (spec && ifa)\n\t{\n\t\tstrcpy(host, \"IP: \");\n\t\tgetnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in), host + strlen(host), NI_MAXHOST - strlen(host), NULL, 0, NI_NUMERICHOST);\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn spec ? (ifa ? host : 0) : (char*)netType;\n}\n\nstatic long sysinfo_timer;\nstatic void infowrite(int pos, const char* txt)\n{\n\tchar str[40];\n\tmemset(str, 0x20, 29);\n\tint len = strlen(txt);\n\tif (len > 27) len = 27;\n\tif(len) strncpy(str + 1+ ((27-len)/2), txt, len);\n\tstr[0] = 0x83;\n\tstr[28] = 0x83;\n\tstr[29] = 0;\n\tOsdWrite(pos, str, 0, 0);\n}\n\nstatic void printSysInfo()\n{\n\tif (!sysinfo_timer || CheckTimer(sysinfo_timer))\n\t{\n\t\tsysinfo_timer = GetTimer(2000);\n\t\tstruct battery_data_t bat;\n\t\tint hasbat = getBattery(0, &bat);\n\t\tint n = 2;\n\t\tstatic int flip = 0;\n\n\t\tchar str[40];\n\t\tOsdWrite(n++, info_top, 0, 0);\n\n\t\tint j = 0;\n\t\tchar *net;\n\t\tnet = getNet(1);\n\t\tif (net)\n\t\t{\n\t\t\tsprintf(str, \"\\x1c %s\", net);\n\t\t\tinfowrite(n++, str);\n\t\t\tj++;\n\t\t}\n\t\tnet = getNet(2);\n\t\tif (net)\n\t\t{\n\t\t\tsprintf(str, \"\\x1d %s\", net);\n\t\t\tinfowrite(n++, str);\n\t\t\tj++;\n\t\t}\n\t\tif (!j) infowrite(n++, \"No network\");\n\t\tif (j<2) infowrite(n++, \"\");\n\n\t\tflip = (flip + 1) & 3;\n\t\tif (hasbat && (flip & 2))\n\t\t{\n\t\t\tinfowrite(n++, \"\");\n\n\t\t\tsprintf(str, \"\\x1F \");\n\t\t\tif (bat.capacity == -1) strcat(str, \"n/a\");\n\t\t\telse sprintf(str + strlen(str), \"%d%%\", bat.capacity);\n\t\t\tif (bat.current != -1) sprintf(str + strlen(str), \" %dmAh\", bat.current);\n\t\t\tif (bat.voltage != -1) sprintf(str + strlen(str), \" %d.%dV\", bat.voltage / 1000, (bat.voltage / 100) % 10);\n\n\t\t\tinfowrite(n++, str);\n\n\t\t\tstr[0] = 0;\n\t\t\tif (bat.load_current > 0)\n\t\t\t{\n\t\t\t\tsprintf(str + strlen(str), \" \\x12 %dmA\", bat.load_current);\n\t\t\t\tif (bat.time != -1)\n\t\t\t\t{\n\t\t\t\t\tif (bat.time < 90) sprintf(str + strlen(str), \", ETA: %dm\", bat.time);\n\t\t\t\t\telse sprintf(str + strlen(str), \", ETA: %dh%02dm\", bat.time / 60, bat.time % 60);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (bat.load_current < -1)\n\t\t\t{\n\t\t\t\tsprintf(str + strlen(str), \" \\x13 %dmA\", -bat.load_current);\n\t\t\t\tif (bat.time != -1)\n\t\t\t\t{\n\t\t\t\t\tif (bat.time < 90) sprintf(str + strlen(str), \", ETA: %dm\", bat.time);\n\t\t\t\t\telse sprintf(str + strlen(str), \", ETA: %dh%02dm\", bat.time / 60, bat.time % 60);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcat(str, \"Not charging\");\n\t\t\t}\n\t\t\tinfowrite(n++, str);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinfowrite(n++, \"\");\n\t\t\tvideo_core_description(str, 40);\n\t\t\tinfowrite(n++, str);\n\t\t\tvideo_scaler_description(str, 40);\n\t\t\tinfowrite(n++, str);\n\t\t}\n\t\tOsdWrite(n++, info_bottom, 0, 0);\n\t}\n}\n\nstatic int  firstmenu = 0;\nstatic int  adjvisible;\n\nstatic void MenuWrite(unsigned char n, const char *s = \"\", unsigned char invert = 0, unsigned char stipple = 0, int arrow = 0)\n{\n\tint row = n - firstmenu;\n\n\tif (row < 0)\n\t{\n\t\tif (invert) adjvisible = row;\n\t\treturn;\n\t}\n\n\tif (row >= OsdGetSize())\n\t{\n\t\tif (invert) adjvisible = row - OsdGetSize() + 1;\n\t\treturn;\n\t}\n\n\tOsdSetArrow(arrow);\n\tOsdWriteOffset(row, s, invert, stipple, 0, (row == 0 && firstmenu) ? 17 : (row == (OsdGetSize()-1) && !arrow) ? 16 : 0, 0);\n}\n\nconst char* get_rbf_name_bootcore(char *str)\n{\n\tif (!strlen(cfg.bootcore)) return \"\";\n\tchar *p = strrchr(str, '/');\n\tif (!p) return str;\n\n\tchar *spl = strrchr(p + 1, '.');\n\tif (spl && (!strcmp(spl, \".rbf\") || !strcmp(spl, \".mra\") || !strcmp(spl, \".mgl\")))\n\t{\n\t\t*spl = 0;\n\t}\n\telse\n\t{\n\t\treturn NULL;\n\t}\n\treturn p + 1;\n}\n\nstatic void vga_nag()\n{\n\tif (video_fb_state())\n\t{\n\t\tEnableOsd_on(OSD_VGA);\n\t\tOsdSetSize(16);\n\t\tOsdSetTitle(\"Information\");\n\t\tint n = 0;\n\t\tOsdWrite(n++);\n\t\tOsdWrite(n++);\n\t\tOsdWrite(n++);\n\t\tOsdWrite(n++);\n\t\tOsdWrite(n++, \"  If you see this, then you\");\n\t\tOsdWrite(n++, \"  need to modify MiSTer.ini\");\n\t\tOsdWrite(n++);\n\t\tOsdWrite(n++, \" Either disable framebuffer:\");\n\t\tOsdWrite(n++, \"       fb_terminal=0\");\n\t\tOsdWrite(n++);\n\t\tOsdWrite(n++, \"  or enable scaler on VGA:\");\n\t\tOsdWrite(n++, \"       vga_scaler=1\");\n\t\tfor (; n < OsdGetSize(); n++) OsdWrite(n);\n\t\tOsdUpdate();\n\t\tOsdEnable(OSD_MSG);\n\t\tEnableOsd_on(OSD_HDMI);\n\t}\n\n\tOsdDisable();\n\tEnableOsd_on(OSD_ALL);\n}\n\nvoid process_addon(char *ext, uint8_t idx)\n{\n\tstatic char name[1024];\n\n\twhile (*ext && *ext != ',') ext++;\n\tif (*ext) ext++;\n\tif (!*ext) return;\n\n\tprintf(\"addons: %s\\n\", ext);\n\n\tint i = 0;\n\twhile (1)\n\t{\n\t\tchar *fname = name;\n\t\tstrcpy(name, selPath);\n\t\tchar *p = strrchr(name, '.');\n\t\tif (!p) p = name + strlen(name);\n\t\t*p++ = '.';\n\n\t\tsubstrcpy(p, ext, i);\n\t\tif (!strlen(p)) return;\n\t\tif (*p == '!')\n\t\t{\n\t\t\t*p = 0;\n\t\t\tchar *bs = strrchr(name, '/');\n\t\t\tif (!bs)\n\t\t\t{\n\t\t\t\tfname = p + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcpy(bs + 1, p + 1);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"Trying: %s\\n\", fname);\n\t\tuser_io_file_tx_a(fname, ((i+1) << 8) | idx);\n\t\ti++;\n\t}\n}\n\nstatic int get_arc(const char *str)\n{\n\tint arc = 0;\n\tif (!strcmp(str, \"[ARC1]\")) arc = 1;\n\telse if(!strcmp(str, \"[ARC2]\")) arc = 2;\n\telse return 0;\n\n\tuint32_t x = 0, y = 0;\n\tif (sscanf(cfg.custom_aspect_ratio[arc - 1], \"%u:%u\", &x, &y) != 2 || x < 1 || x > 4095 || y < 1 || y > 4095) arc = -1;\n\n\treturn arc;\n}\n\nstatic int get_ar_name(int ar, char *str)\n{\n\tswitch (ar)\n\t{\n\tcase 0:\n\t\tstrcat(str, \"Original\");\n\t\tbreak;\n\n\tcase 1:\n\t\tstrcat(str, \"Full Screen\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (get_arc(\"[ARC1]\") <= 0)\n\t\t{\n\t\t\tstrcat(str, \"Original\");\n\t\t\tar = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrcat(str, cfg.custom_aspect_ratio[0]);\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (get_arc(\"[ARC2]\") <= 0)\n\t\t{\n\t\t\tstrcat(str, \"Original\");\n\t\t\tar = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrcat(str, cfg.custom_aspect_ratio[1]);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn ar;\n}\n\nstatic int next_ar(int ar, int minus)\n{\n\tif (minus)\n\t{\n\t\tar = (ar - 1) & 3;\n\t\twhile (1)\n\t\t{\n\t\t\tif (ar == 3 && get_arc(\"[ARC2]\") > 0 && get_arc(\"[ARC1]\") > 0) break;\n\t\t\tif (ar == 2 && get_arc(\"[ARC1]\") > 0) break;\n\t\t\tif (ar < 2) break;\n\t\t\tar--;\n\t\t}\n\t}\n\telse\n\t{\n\t\tar = (ar + 1) & 3;\n\t\tif (ar == 3 && get_arc(\"[ARC2]\") <= 0) ar = 0;\n\t\tif (ar == 2 && get_arc(\"[ARC1]\") <= 0) ar = 0;\n\t}\n\n\treturn ar;\n}\n\nstatic int joymap_first = 0;\n\nstatic int gun_x = 0;\nstatic int gun_y = 0;\nstatic int gun_ok = 0;\nstatic int gun_side = 0;\nstatic int gun_idx = 0;\nstatic int32_t gun_pos[4] = {};\nstatic int page = 0;\n\nvoid HandleUI(void)\n{\n\tPROFILE_FUNCTION();\n\n\tif (bt_timer >= 0)\n\t{\n\t\tif (!bt_timer) bt_timer = (int32_t)GetTimer(6000);\n\t\telse if (CheckTimer((uint32_t)bt_timer))\n\t\t{\n\t\t\tbt_timer = -1;\n\t\t\tif (hci_get_route(0) < 0)\n\t\t\t{\n\t\t\t\t// Some BT dongles get stuck after boot.\n\t\t\t\t// Kicking of USB port usually make it work.\n\t\t\t\tprintf(\"*** reset bt ***\\n\");\n\t\t\t\tsystem(\"/bin/bluetoothd hcireset &\");\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (user_io_core_type())\n\t{\n\tcase CORE_TYPE_8BIT:\n\tcase CORE_TYPE_SHARPMZ:\n\t\tbreak;\n\n\tdefault:\n\t\t// No UI in unknown cores.\n\t\treturn;\n\t}\n\n\tstatic char opensave;\n\tstatic char ioctl_index;\n\tchar *p;\n\tstatic char s[256];\n\tunsigned char m = 0, up, down, select, menu, back, right, left, plus, minus, recent;\n\tchar enable;\n\tstatic int reboot_req = 0;\n\tstatic uint32_t helptext_timer;\n\tstatic int helptext_idx = 0;\n\tstatic int helptext_idx_old = 0;\n\tstatic char helpstate = 0;\n\tstatic char flag;\n\tstatic int cr = 0;\n\tstatic uint32_t cheatsub = 0;\n\tstatic uint8_t card_cid[32];\n\tstatic uint32_t hdmask = 0;\n\tstatic pid_t ttypid = 0;\n\tstatic int has_fb_terminal = 0;\n\tstatic unsigned long flash_timer = 0;\n\tstatic int flash_state = 0;\n\tstatic uint32_t dip_submenu, dip2_submenu, dipv;\n\tstatic int need_reset = 0;\n\tstatic int flat = 0;\n\tstatic int menusub_parent = 0;\n\tstatic char title[32] = {};\n\tstatic uint32_t saved_menustate = 0;\n\tstatic char addon[1024];\n\tstatic int store_name;\n\tstatic int vfilter_type;\n\tstatic int old_volume = 0;\n\tstatic uint32_t lock_pass_timeout = 0;\n\tstatic uint32_t menu_timeout = 0;\n\n\tstatic char\tcp_MenuCancel;\n\n\tuint32_t c = 0;\n\n\tmgl_struct *mgl = mgl_get();\n\n\t/*\n\tstatic int old_state = -1;\n\tstatic int old_current = -1;\n\tstatic int old_done = -1;\n\tstatic uint32_t old_menustate = -1;\n\n\tif ((old_state != mgl->state) || (old_current != mgl->current) || (old_done != mgl->done) || (old_menustate != menustate))\n\t{\n\t\tprintf(\"*** MGL menustate=%d, count=%d current=%d state=%d action=%d done=%d\\n\", menustate, mgl->count, mgl->current, mgl->state, mgl->item[mgl->current].action, mgl->done);\n\t\told_state = mgl->state;\n\t\told_current = mgl->current;\n\t\told_done = mgl->done;\n\t\told_menustate = menustate;\n\t}\n\t*/\n\n\tif (!mgl->done)\n\t{\n\t\tswitch (mgl->state)\n\t\t{\n\t\tcase 0:\n\t\t\tif (CheckTimer(mgl->timer))\n\t\t\t{\n\t\t\t\tmgl->state = (mgl->item[mgl->current].action == MGL_ACTION_LOAD) ? 1 : 4;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tmgl->state = 0;\n\t\t\tmgl->current++;\n\t\t\tif (mgl->current < mgl->count) mgl->timer = GetTimer(mgl->item[mgl->current].delay * 1000);\n\t\t\telse mgl->done = 1;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tuser_io_set_kbd_reset(1);\n\t\t\tuser_io_send_buttons(1);\n\t\t\tmgl->timer = GetTimer(mgl->item[mgl->current].hold ? (mgl->item[mgl->current].hold * 1000) : 100);\n\t\t\tmgl->state = 5;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tif (CheckTimer(mgl->timer))\n\t\t\t{\n\t\t\t\tuser_io_set_kbd_reset(0);\n\t\t\t\tuser_io_send_buttons(1);\n\t\t\t\tmgl->state = 3;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// get user control codes\n\t\tc = menu_key_get();\n\t}\n\n\tint release = 0;\n\tif (c & UPSTROKE) release = 1;\n\n\t// decode and set events\n\tmenu = false;\n\tback = false;\n\tselect = false;\n\tup = false;\n\tdown = false;\n\tleft = false;\n\tright = false;\n\tplus = false;\n\tminus = false;\n\trecent = false;\n\n\tif (c && cfg.bootcore[0] != '\\0') cfg.bootcore[0] = '\\0';\n\n\tif (!select_ini && is_menu() && cfg.osd_timeout >= 5)\n\t{\n\t\tstatic int menu_visible = 1;\n\t\tstatic unsigned long timeout = 0;\n\t\tstatic unsigned long off_timeout = 0;\n\t\tif (!video_fb_state() && cfg.fb_terminal)\n\t\t{\n\t\t\tif (timeout && CheckTimer(timeout))\n\t\t\t{\n\t\t\t\ttimeout = 0;\n\t\t\t\tif (menu_visible > 0)\n\t\t\t\t{\n\t\t\t\t\tmenu_visible = 0;\n\t\t\t\t\tvideo_menu_bg(user_io_status_get(\"[3:1]\"), 1);\n\t\t\t\t\tOsdMenuCtl(0);\n\t\t\t\t}\n\t\t\t\telse if (!menu_visible)\n\t\t\t\t{\n\t\t\t\t\tmenu_visible--;\n\t\t\t\t\tvideo_menu_bg(user_io_status_get(\"[3:1]\"), 2);\n\t\t\t\t\toff_timeout = cfg.video_off ? GetTimer(cfg.video_off * 1000) : 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (off_timeout && CheckTimer(off_timeout) && menu_visible < 0)\n\t\t\t{\n\t\t\t\toff_timeout = 0;\n\t\t\t\tvideo_menu_bg(user_io_status_get(\"[3:1]\"), 3);\n\t\t\t}\n\n\t\t\tif (c || menustate != MENU_FILE_SELECT2)\n\t\t\t{\n\t\t\t\ttimeout = 0;\n\t\t\t\tif (menu_visible <= 0)\n\t\t\t\t{\n\t\t\t\t\tc = 0;\n\t\t\t\t\tmenu_visible = 1;\n\t\t\t\t\tvideo_menu_bg(user_io_status_get(\"[3:1]\"));\n\t\t\t\t\tOsdMenuCtl(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!timeout)\n\t\t\t{\n\t\t\t\ttimeout = GetTimer(cfg.osd_timeout * 1000);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttimeout = 0;\n\t\t\tmenu_visible = 1;\n\t\t}\n\t}\n\n\t//prevent OSD control while script is executing on framebuffer\n\tif ((!video_fb_state() || video_chvt(0) != 2) && !select_ini)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\tcase KEY_F12:\n\t\t\tmenu = true;\n\t\t\tmenu_key_set(KEY_F12 | UPSTROKE);\n\t\t\tif(video_fb_state()) video_menu_bg(user_io_status_get(\"[3:1]\"));\n\t\t\tvideo_fb_enable(0);\n\t\t\tbreak;\n\n\t\tcase KEY_F1:\n\t\t\tif (is_menu() && cfg.fb_terminal)\n\t\t\t{\n\t\t\t\tuser_io_status_set(\"[3:1]\", user_io_status_get(\"[3:1]\") + 1);\n\t\t\t\tuser_io_status_save(user_io_create_config_name());\n\t\t\t\tvideo_menu_bg(user_io_status_get(\"[3:1]\"));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KEY_F11:\n\t\t\tif (user_io_osd_is_visible() && (menustate != MENU_SCRIPTS1 || script_finished))\n\t\t\t{\n\t\t\t\tmenustate = MENU_BTPAIR;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KEY_F10:\n\t\t\tif (input_has_lightgun())\n\t\t\t{\n\t\t\t\tmenustate = MENU_LGCAL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KEY_F9:\n\t\t\tif ((is_menu() || ((get_key_mod() & (LALT | RALT)) && (get_key_mod() & (LCTRL | RCTRL))) || has_fb_terminal) && cfg.fb_terminal)\n\t\t\t{\n\t\t\t\tvideo_chvt(1);\n\t\t\t\tvideo_fb_enable(!video_fb_state());\n\t\t\t\tif (video_fb_state())\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t\thas_fb_terminal = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t// Within the menu the esc key acts as the menu key. problem:\n\t\t\t// if the menu is left with a press of ESC, then the follwing\n\t\t\t// break code for the ESC key when the key is released will\n\t\t\t// reach the core which never saw the make code. Simple solution:\n\t\t\t// react on break code instead of make code\n\t\tcase KEY_ESC | UPSTROKE:\n\t\t\tif (menustate != MENU_NONE2) menu = true;\n\t\t\tbreak;\n\t\tcase KEY_BACK | UPSTROKE:\n\t\t\tif (saved_menustate || !osd_unlocked) back = true;\n\t\t\telse menu = true;\n\t\t\tbreak;\n\t\tcase KEY_BACKSPACE | UPSTROKE:\n\t\t\tif (saved_menustate || !osd_unlocked) back = true;\n\t\t\tbreak;\n\t\tcase KEY_ENTER:\n\t\tcase KEY_SPACE:\n\t\tcase KEY_KPENTER:\n\t\t\tselect = true;\n\t\t\tbreak;\n\t\tcase KEY_UP:\n\t\t\tup = true;\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\t\tdown = true;\n\t\t\tbreak;\n\t\tcase KEY_LEFT:\n\t\t\tleft = true;\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\t\tright = true;\n\t\t\tbreak;\n\t\tcase KEY_KPPLUS:\n\t\tcase KEY_EQUAL: // =/+\n\t\t\tplus = true;\n\t\t\tbreak;\n\t\tcase KEY_KPMINUS:\n\t\tcase KEY_MINUS: // -/_\n\t\t\tminus = true;\n\t\t\tbreak;\n\t\tcase KEY_GRAVE:\n\t\t\trecent = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (select_ini)\n\t{\n\t\tDISKLED_ON;\n\n\t\tswitch (c)\n\t\t{\n\t\tcase KEY_ESC | UPSTROKE:\n\t\t\tmenu = true;\n\t\t\tbreak;\n\t\tcase KEY_UP:\n\t\t\tup = true;\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\t\tdown = true;\n\t\t\tbreak;\n\t\tcase KEY_LEFT:\n\t\t\tleft = true;\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\t\tright = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (menu || select || up || down || left || right || (helptext_idx_old != helptext_idx))\n\t{\n\t\thelptext_idx_old = helptext_idx;\n\t\tif (helpstate) OsdWrite(OsdGetSize()-1, STD_EXIT, (menumask - ((1 << (menusub + 1)) - 1)) <= 0, 0); // Redraw the Exit line...\n\t\thelpstate = 0;\n\t\thelptext_timer = GetTimer(helptext_timeouts[helptext_idx]);\n\t}\n\n\tif (helptext_idx)\n\t{\n\t\tif (helpstate<9)\n\t\t{\n\t\t\tif (CheckTimer(helptext_timer))\n\t\t\t{\n\t\t\t\thelptext_timer = GetTimer(32);\n\t\t\t\tOsdShiftDown(OsdGetSize() - 1);\n\t\t\t\t++helpstate;\n\t\t\t}\n\t\t}\n\t\telse if (helpstate == 9)\n\t\t{\n\t\t\tScrollReset(1);\n\t\t\t++helpstate;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tScrollText(OsdGetSize() - 1, helptexts[helptext_idx], 0, 0, 0, 0, 1);\n\t\t}\n\t}\n\n\t// Standardised menu up/down.\n\t// The screen should set menumask, bit 0 to make the top line selectable, bit 1 for the 2nd line, etc.\n\t// (Lines in this context don't have to correspond to rows on the OSD.)\n\t// Also set parentstate to the appropriate menustate.\n\tif (menumask)\n\t{\n\t\tif (down)\n\t\t{\n\t\t\tif((menumask >= ((uint64_t)1 << (menusub + 1))))\t// Any active entries left?\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tmenusub++;\n\t\t\t\t} while ((menumask & ((uint64_t)1 << menusub)) == 0);\n\t\t\t} else {\n\t\t\t\tmenusub = 0; // jump to first item\n\t\t\t\twhile ((menumask & ((uint64_t)1 << menusub )) == 0) menusub++;\n\t\t\t}\n\n\t\t\tmenustate = parentstate;\n\t\t}\n\n\t\tif (up)\n\t\t{\n\t\t\tif (menusub > 0)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\t--menusub;\n\t\t\t\t} while (menusub != 0 && (menumask & ((uint64_t)1 << menusub)) == 0);\n\t\t\t\tif (menusub == 0 && (menumask & 1) == 0) { //If the first menu entry is disabled...\n\t\t\t\t\twhile ((menumask & ((uint64_t)(~0) << (menusub + 1))) != 0) menusub++;\n\t\t\t\t\t//Go to to last item\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tmenusub++;\n\t\t\t\t} while ((menumask & ((uint64_t)(~0) << (menusub + 1))) != 0); // jump to last item\n\t\t\t}\n\t\t\tmenustate = parentstate;\n\t\t}\n\t}\n\n    // SHARPMZ Series Menu - This has been located within the sharpmz.cpp code base in order to keep updates to common code\n    // base to a minimum and shrink its size. The UI is called with the basic state data and it handles everything internally,\n    // only updating values in this function as necessary.\n    //\n\tif (user_io_core_type() == CORE_TYPE_SHARPMZ)\n        sharpmz_ui(MENU_NONE1, MENU_NONE2, MENU_COMMON1, MENU_FILE_SELECT1,\n\t\t\t       &parentstate, &menustate, &menusub, &menusub_last,\n\t\t\t       &menumask, /*Selected_F[0]*/ selPath, &helptext_idx, helptext_custom,\n\t\t\t       &fs_ExtLen, &fs_Options, &fs_MenuSelect, &fs_MenuCancel,\n\t\t\t       fs_pFileExt,\n\t\t\t       menu, select, up, down,\n\t\t\t       left, right, plus, minus);\n\n\t// Ensure we clear out the file-selector-visible file on select or cancel\n\tif (cfg.log_file_entry)\n\t{\n\t\tif (menustate == fs_MenuSelect)\n\t\t\tMakeFile(\"/tmp/FILESELECT\", \"selected\");\n\t\telse if (menustate == fs_MenuCancel)\n\t\t\tMakeFile(\"/tmp/FILESELECT\", \"cancelled\");\n\t}\n\n\tswitch (menustate)\n\t{\n\tcase MENU_NONE1:\n\tcase MENU_NONE2:\n\tcase MENU_INFO:\n\t\tbreak;\n\n\tdefault:\n\t\tsaved_menustate = 0;\n\t\tbreak;\n\t}\n\n\tif (osd_lock_timer == 0) osd_lock_timer = GetTimer(10 * 1000);\n\n\tswitch (menustate)\n\t{\n\tcase MENU_NONE1:\n\tcase MENU_NONE2:\n\tcase MENU_INFO:\n\t\tif (!cfg.osd_lock[0] || is_menu() || !mgl->done) osd_unlocked = 1;\n\t\telse if (cfg.osd_lock_time && CheckTimer(osd_lock_timer)) osd_unlocked = 0;\n\t\tbreak;\n\n\tcase MENU_UNLOCK1:\n\tcase MENU_UNLOCK2:\n\tcase MENU_UNLOCK3:\n\t\tbreak;\n\n\tdefault:\n\t\tosd_unlocked = 1;\n\t\tosd_lock_timer = GetTimer(cfg.osd_lock_time * 1000);\n\t\tbreak;\n\t}\n\n\t// Switch to current menu screen\n\tswitch (menustate)\n\t{\n\t\t/******************************************************************/\n\t\t/* no menu selected                                               */\n\t\t/******************************************************************/\n\tcase MENU_NONE1:\n\t\thelptext_idx = 0;\n\t\tmenumask = 0;\n\t\tmenustate = MENU_NONE2;\n\t\tfirstmenu = 0;\n\t\tvga_nag();\n\t\tOsdSetSize(8);\n\t\tbreak;\n\n\tcase MENU_INFO:\n\t\tif (CheckTimer(menu_timer)) menustate = MENU_NONE1;\n\t\t// fall through\n\n\tcase MENU_NONE2:\n\t\tif (menu && !osd_unlocked)\n\t\t{\n\t\t\tmenustate = MENU_UNLOCK1;\n\t\t\tosd_code_entry[0] = 0;\n\t\t}\n\t\telse if (menu || (is_menu() && !video_fb_state()) || (menustate == MENU_NONE2 && !mgl->done && mgl->state == 1))\n\t\t{\n\t\t\tOsdSetSize(16);\n\t\t\tmenusub = 0;\n\t\t\tif(!is_menu() && (get_key_mod() & (LALT | RALT))) //Alt+Menu\n\t\t\t{\n\t\t\t\tSelectFile(\"\", 0, SCANO_CORES, MENU_CORE_FILE_SELECTED1, MENU_NONE1);\n\t\t\t}\n\t\t\telse if (saved_menustate)\n\t\t\t{\n\t\t\t\tmenustate = saved_menustate;\n\t\t\t}\n\t\t\telse if (is_st()) menustate = MENU_ST_MAIN1;\n\t\t\telse if (is_archie()) menustate = MENU_ARCHIE_MAIN1;\n\t\t\telse {\n\t\t\t\tif (select_ini)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_SELECT_INI1;\n\t\t\t\t}\n\t\t\t\telse if (is_menu())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 6;\n\t\t\t\t\tSelectFile(\"\", 0, SCANO_CORES, MENU_CORE_FILE_SELECTED1, MENU_SYSTEM1);\n\t\t\t\t}\n\t\t\t\telse if (is_minimig())\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ((get_key_mod() & (LGUI | RGUI)) && !is_x86() && !is_pcxt() && has_menu()) //Win+Menu\n\t\t\t\t\t{\n\t\t\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparentstate = MENU_NONE1;\n\t\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tOsdClear();\n\t\t\tif (!mgl->done) OsdDisable();\n\t\t\telse OsdEnable(DISABLE_KEYBOARD);\n\t\t\tif (mgl->state == 1) mgl->state = 2;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_SELECT_INI1:\n\t\t{\n\t\t\tOsdSetTitle(\"Select INI\");\n\t\t\tint flag = 1;\n\t\t\tfor (int i = 1; i < 4; i++) if (FileExists(cfg_get_name(i))) flag |= 1 << i;\n\t\t\tfor(int i = 0; i<16; i++) OsdWrite(m++);\n\t\t\tm = 4;\n\t\t\tOsdWrite(m++, \"  Use dpad/cursor to select\");\n\t\t\tm += 2;\n\t\t\tsprintf(s, \"            %s\", cfg_get_label(0));\n\t\t\tOsdWrite(m++, s);\n\t\t\tm++;\n\t\t\tstrcpy(s, \"      \");\n\t\t\tif (!(flag & 2)) strcat(s, \"\\xb\");\n\t\t\tstrcat(s, cfg_get_label(1));\n\t\t\tif (!(flag & 2)) strcat(s, \"\\xb\");\n\t\t\tstrcat(s, \"        \");\n\t\t\tif (!(flag & 8)) strcat(s, \"\\xb\");\n\t\t\tstrcat(s, cfg_get_label(3));\n\t\t\tif (!(flag & 8)) strcat(s, \"\\xb\");\n\t\t\tOsdWrite(m++, s);\n\t\t\tm++;\n\t\t\tstrcpy(s, \"            \");\n\t\t\tif (!(flag & 4)) strcat(s, \"\\xb\");\n\t\t\tstrcat(s, cfg_get_label(2));\n\t\t\tif (!(flag & 4)) strcat(s, \"\\xb\");\n\t\t\tOsdWrite(m++, s);\n\t\t\tm++;\n\t\t\tparentstate = MENU_SELECT_INI1;\n\t\t\tmenustate = MENU_SELECT_INI2;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_SELECT_INI2:\n\t\tif (menu || up)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t\tselect_ini = 0;\n\t\t}\n\t\telse if (left && FileExists(cfg_get_name(1)))\n\t\t{\n\t\t\tuser_io_set_ini(1);\n\t\t}\n\t\telse if (down && FileExists(cfg_get_name(2)))\n\t\t{\n\t\t\tuser_io_set_ini(2);\n\t\t}\n\t\telse if (right && FileExists(cfg_get_name(3)))\n\t\t{\n\t\t\tuser_io_set_ini(3);\n\t\t}\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* archimedes main menu                                           */\n\t\t/******************************************************************/\n\n\tcase MENU_ARCHIE_MAIN1:\n\t\tOsdSetTitle(CoreName, OSD_ARROW_RIGHT | OSD_ARROW_LEFT);\n\n\t\tm = 0;\n\t\tmenumask = 0x1fff;\n\n\t\tstrcpy(s, \" Floppy 0: \");\n\t\tstrncat(s, get_image_name(0) ? get_image_name(0) : \"* no disk *\",27);\n\t\tOsdWrite(m++, s, menusub == 0);\n\n\t\tstrcpy(s, \" Floppy 1: \");\n\t\tstrncat(s, get_image_name(1) ? get_image_name(1) : \"* no disk *\", 27);\n\t\tOsdWrite(m++, s, menusub == 1);\n\n\t\tOsdWrite(m++);\n\n\t\tstrcpy(s, \" HDD 0: \");\n\t\tstrncat(s, archie_get_hdd_name(0) ? archie_get_hdd_name(0) : \"* no disk *\", 27);\n\t\tOsdWrite(m++, s, menusub == 2);\n\n\t\tstrcpy(s, \" HDD 1: \");\n\t\tstrncat(s, archie_get_hdd_name(1) ? archie_get_hdd_name(1) : \"* no disk *\", 27);\n\t\tOsdWrite(m++, s, menusub == 3);\n\n\t\tOsdWrite(m++);\n\n\t\tstrcpy(s, \" OS ROM: \");\n\t\tstrcat(s, archie_get_rom_name());\n\t\tOsdWrite(m++, s, menusub == 4);\n\n\t\tOsdWrite(m++);\n\n\t\tstrcpy(s, \" Aspect Ratio:    \");\n\t\tarchie_set_ar(get_ar_name(archie_get_ar(), s));\n\t\tOsdWrite(m++, s, menusub == 5);\n\n\t\tstrcpy(s, \" Scale:           \");\n\t\tstrcat(s, config_scale[archie_get_scale()]);\n\t\tOsdWrite(m++, s, menusub == 6);\n\n\t\tstrcpy(s, \" Refresh Rate:    \");\n\t\tstrcat(s, archie_get_60() ? \"Variable\" : \"60Hz\");\n\t\tOsdWrite(m++, s, menusub == 7);\n\n\t\tsprintf(s, \" Stereo Mix:      %s\", config_stereo_msg[archie_get_amix()]);\n\t\tOsdWrite(m++, s, menusub == 8);\n\n\t\tstrcpy(s, \" 25MHz Audio Fix: \");\n\t\tstrcat(s, archie_get_afix() ? \"Enable\" : \"Disable\");\n\t\tOsdWrite(m++, s, menusub == 9);\n\n\t\tsprintf(s, \" Swap Joysticks:  %s\", user_io_get_joyswap() ? \"Yes\" : \"No\");\n\t\tOsdWrite(m++, s, menusub == 10);\n\t\tsprintf(s, \" Swap Btn 2/3:    %s\", archie_get_mswap() ? \"Yes\" : \"No\");\n\t\tOsdWrite(m++, s, menusub == 11);\n\n\t\twhile(m<15) OsdWrite(m++);\n\n\t\tOsdWrite(15, STD_EXIT, menusub == 12, 0);\n\t\tmenustate = MENU_ARCHIE_MAIN2;\n\t\tparentstate = MENU_ARCHIE_MAIN1;\n\n\t\t// set helptext with core display on top of basic info\n\t\tsprintf(helptext_custom, HELPTEXT_SPACER);\n\t\tstrcat(helptext_custom, OsdCoreNameGet());\n\t\tstrcat(helptext_custom, helptexts[HELPTEXT_MAIN]);\n\t\thelptext_idx = HELPTEXT_CUSTOM;\n\t\tbreak;\n\n\tcase MENU_ARCHIE_MAIN2:\n\t\t// menu key closes menu\n\t\tif (menu) menustate = MENU_NONE1;\n\t\tif (recent && (menusub <= 3))\n\t\t{\n\t\t\tfs_Options = SCANO_DIR | SCANO_UMOUNT;\n\t\t\tfs_MenuSelect = MENU_ARCHIE_MAIN_FILE_SELECTED;\n\t\t\tfs_MenuCancel = MENU_ARCHIE_MAIN1;\n\t\t\tstrcpy(fs_pFileExt, (menusub <= 1) ? \"ADF\" : \"HDF\");\n\t\t\tif (recent_init((menusub <= 1) ? 500 : 501)) menustate = MENU_RECENT1;\n\t\t}\n\n\t\tif (select || plus || minus)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 0:  // Floppy 0\n\t\t\tcase 1:  // Floppy 1\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tioctl_index = 0;\n\t\t\t\t\tSelectFile(Selected_S[menusub], \"ADF\", SCANO_DIR | SCANO_UMOUNT, MENU_ARCHIE_MAIN_FILE_SELECTED, MENU_ARCHIE_MAIN1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 2:  // HDD 0\n\t\t\tcase 3:  // HDD 1\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tioctl_index = 1;\n\t\t\t\t\tSelectFile(Selected_S[menusub], \"HDF\", SCANO_DIR | SCANO_UMOUNT, MENU_ARCHIE_MAIN_FILE_SELECTED, MENU_ARCHIE_MAIN1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4:  // Load ROM\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tSelectFile(Selected_F[menusub], \"ROM\", 0, MENU_ARCHIE_MAIN_FILE_SELECTED, MENU_ARCHIE_MAIN1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\tarchie_set_ar(next_ar(archie_get_ar(), minus));\n\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tarchie_set_scale(archie_get_scale() + (minus ? -1 : 1));\n\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tarchie_set_60(!archie_get_60());\n\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\tarchie_set_amix(archie_get_amix() + (minus ? -1 : 1));\n\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\t\tarchie_set_afix(!archie_get_afix());\n\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tuser_io_set_joyswap(!user_io_get_joyswap());\n\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 11:\n\t\t\t\tarchie_set_mswap(!archie_get_mswap());\n\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 12:  // Exit\n\t\t\t\tif (select) menustate = MENU_NONE1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (right)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 0;\n\t\t}\n\t\telse if (left)\n\t\t{\n\t\t\tmenustate = MENU_MISC1;\n\t\t\tmenusub = 3;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ARCHIE_MAIN_FILE_SELECTED:\n\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\tif (menusub <= 1)\n\t\t{\n\t\t\tmemcpy(Selected_F[menusub], selPath, sizeof(Selected_F[menusub]));\n\t\t\trecent_update(SelectedDir, Selected_F[menusub], SelectedLabel, 500);\n\t\t\tuser_io_file_mount(selPath, menusub);\n\t\t}\n\t\telse if (menusub <= 3)\n\t\t{\n\t\t\tmemcpy(Selected_F[menusub], selPath, sizeof(Selected_F[menusub]));\n\t\t\trecent_update(SelectedDir, Selected_F[menusub], SelectedLabel, 501);\n\t\t\tarchie_hdd_mount(selPath, menusub - 2);\n\t\t}\n\t\telse if (menusub == 4)\n\t\t{\n\t\t\tmemcpy(Selected_F[menusub], selPath, sizeof(Selected_F[menusub]));\n\t\t\tarchie_set_rom(selPath);\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_GENERIC_MAIN1: {\n\t\thdmask = spi_uio_cmd16(UIO_GET_OSDMASK, 0);\n\t\tuser_io_read_confstr();\n\t\tuint32_t s_entry = 0;\n\t\tint entry = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tif (!menusub) firstmenu = 0;\n\n\t\t\tadjvisible = 0;\n\t\t\tentry = 0;\n\t\t\tuint32_t selentry = 0;\n\t\t\tmenumask = 0;\n\n\t\t\tOsdSetTitle(page ? title : user_io_get_core_name());\n\n\t\t\tdip_submenu = -1;\n\t\t\tdip2_submenu = -1;\n\n\t\t\tint last_space = 0;\n\n\t\t\t// add options as requested by core\n\t\t\tint i = 2;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tchar* pos;\n\n\t\t\t\tp = user_io_get_confstr(i++);\n\t\t\t\t//printf(\"Option %d: %s\\n\", i-1, p);\n\n\t\t\t\tif (p)\n\t\t\t\t{\n\t\t\t\t\tint h = 0, d = 0, inpage = !page;\n\n\t\t\t\t\tif (!strncmp(p, \"DEFMRA,\", 7))\n\t\t\t\t\t{\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(p, \"DIP\"))\n\t\t\t\t\t{\n\t\t\t\t\t\th = page;\n\t\t\t\t\t\tif (!h && arcade_sw(0)->dip_num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdip_submenu = selentry;\n\t\t\t\t\t\t\tMenuWrite(entry, \" DIP Switches              \\x16\", menusub == selentry, 0);\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\tselentry++;\n\t\t\t\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(p, \"CHEAT\"))\n\t\t\t\t\t{\n\t\t\t\t\t\th = page;\n\t\t\t\t\t\tif (!h && arcade_sw(1)->dip_num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdip2_submenu = selentry;\n\t\t\t\t\t\t\tMenuWrite(entry, \" Cheats                    \\x16\", menusub == selentry, 0);\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\tselentry++;\n\t\t\t\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//Hide or Disable flag (small letter - opposite action)\n\t\t\t\t\t\twhile ((p[0] == 'H' || p[0] == 'D' || p[0] == 'h' || p[0] == 'd') && strlen(p) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint flg = (hdmask & (1 << user_io_hd_mask(p + 1))) ? 1 : 0;\n\t\t\t\t\t\t\tif (p[0] == 'H') h |= flg;\n\t\t\t\t\t\t\tif (p[0] == 'h') h |= (flg ^ 1);\n\t\t\t\t\t\t\tif (p[0] == 'D') d |= flg;\n\t\t\t\t\t\t\tif (p[0] == 'd') d |= (flg ^ 1);\n\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (p[0] == 'P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = p[1] - '0';\n\t\t\t\t\t\t\tif (p[2] != ',')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (page && page == n) inpage = 1;\n\t\t\t\t\t\t\t\tif (!page && n && !flat) inpage = 0;\n\t\t\t\t\t\t\t\tp += 2;\n\n\t\t\t\t\t\t\t\tif (flat && !page && p[0] == '-') inpage = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (flat && !page && !last_space)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMenuWrite(entry, \"\", 0, d);\n\t\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlast_space = 0;\n\n\t\t\t\t\tif (!h && inpage)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (p[0] == 'P')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (flat)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(s, \" \\x16 \");\n\t\t\t\t\t\t\t\tsubstrcpy(s + 3, p, 1);\n\n\t\t\t\t\t\t\t\tint len = strlen(s);\n\t\t\t\t\t\t\t\twhile (len < 28) s[len++] = ' ';\n\t\t\t\t\t\t\t\ts[28] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(s, \" \");\n\t\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 1);\n\n\t\t\t\t\t\t\t\tint len = strlen(s);\n\t\t\t\t\t\t\t\twhile (len < 27) s[len++] = ' ';\n\t\t\t\t\t\t\t\ts[27] = 0x16;\n\t\t\t\t\t\t\t\ts[28] = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tMenuWrite(entry, s, menusub == selentry, d);\n\n\t\t\t\t\t\t\t// add bit in menu mask\n\t\t\t\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\tselentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// check for 'F'ile or 'S'D image strings\n\t\t\t\t\t\tif ((p[0] == 'F') || (p[0] == 'S'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (p[0] == 'S') s_entry = selentry;\n\t\t\t\t\t\t\tsubstrcpy(s, p, 2);\n\t\t\t\t\t\t\tint idx = 1;\n\n\t\t\t\t\t\t\tif (p[idx] == 'S') idx++;\n\t\t\t\t\t\t\tif (p[idx] == 'C') idx++;\n\n\t\t\t\t\t\t\tint num = (p[idx] >= '0' && p[idx] <= '9') ? p[idx] - '0' : 0;\n\t\t\t\t\t\t\tif (!mgl->done && num == mgl->item[mgl->current].index && (p[0] == mgl->item[mgl->current].type)) mgl->item[mgl->current].submenu = selentry;\n\n\t\t\t\t\t\t\tif (is_x86() && x86_get_image_name(num))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(s, \" \");\n\t\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 2);\n\t\t\t\t\t\t\t\tstrcat(s, \" \");\n\t\t\t\t\t\t\t\tstrcat(s, x86_get_image_name(num));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (is_pcxt() && (p[0] == 'S') && x86_get_image_name(num))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(s, \" \");\n\t\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 2);\n\t\t\t\t\t\t\t\tstrcat(s, \" \");\n\t\t\t\t\t\t\t\tstrcat(s, x86_get_image_name(num));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (is_pcxt() && (p[0] == 'F'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(s, \" \");\n\t\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 2);\n\t\t\t\t\t\t\t\tstatic char str[1024];\n\t\t\t\t\t\t\t\tsprintf(str, \"%s.f%c\", user_io_get_core_name(), p[idx]);\n\t\t\t\t\t\t\t\tif (FileLoadConfig(str, str, sizeof(str)) && str[0])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstrcat(s, \" \");\n\t\t\t\t\t\t\t\t\tstrcat(s, GetNameFromPath(str));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstrcat(s, \" *.\");\n\t\t\t\t\t\t\t\t\tpos = s + strlen(s);\n\t\t\t\t\t\t\t\t\tsubstrcpy(pos, p, 1);\n\t\t\t\t\t\t\t\t\tstrcpy(pos, GetExt(pos));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (strlen(s))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstrcpy(s, \" \");\n\t\t\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 2);\n\t\t\t\t\t\t\t\t\tstrcat(s, \" *.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (p[0] == 'F') strcpy(s, \" Load *.\");\n\t\t\t\t\t\t\t\t\telse             strcpy(s, \" Mount *.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpos = s + strlen(s);\n\t\t\t\t\t\t\t\tsubstrcpy(pos, p, 1);\n\t\t\t\t\t\t\t\tstrcpy(pos, GetExt(pos));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tMenuWrite(entry, s, menusub == selentry, d);\n\n\t\t\t\t\t\t\t// add bit in menu mask\n\t\t\t\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\tselentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// check for 'C'heats\n\t\t\t\t\t\tif (p[0] == 'C')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsubstrcpy(s, p, 1);\n\t\t\t\t\t\t\tif (strlen(s))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(s, \" \");\n\t\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(s, \" Cheats\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tMenuWrite(entry, s, menusub == selentry, !cheats_available() || d);\n\n\t\t\t\t\t\t\t// add bit in menu mask\n\t\t\t\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\tselentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// check for 'T'oggle and 'R'eset (toggle and then close menu) strings\n\t\t\t\t\t\tif ((p[0] == 'T') || (p[0] == 'R') || (p[0] == 't') || (p[0] == 'r'))\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\ts[0] = ' ';\n\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 1);\n\t\t\t\t\t\t\tMenuWrite(entry, s, menusub == selentry, d);\n\n\t\t\t\t\t\t\t// add bit in menu mask\n\t\t\t\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\tselentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// check for 'O'ption strings\n\t\t\t\t\t\tif ((p[0] == 'O') || (p[0] == 'o'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//option handled by HPS\n\t\t\t\t\t\t\tif (p[1] == 'X') p++;\n\t\t\t\t\t\t\tuint32_t x = user_io_status_get(p + 1, p[0] == 'o');\n\n\t\t\t\t\t\t\t// get currently active option\n\t\t\t\t\t\t\tsubstrcpy(s, p, 2 + x);\n\t\t\t\t\t\t\tint l = strlen(s);\n\t\t\t\t\t\t\tint arc = get_arc(s);\n\t\t\t\t\t\t\tif (!l || arc < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// option's index is outside of available values.\n\t\t\t\t\t\t\t\t// reset to 0.\n\t\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\t\t//user_io_status(setStatus(p, status, x), 0xffffffff);\n\t\t\t\t\t\t\t\tsubstrcpy(s, p, 2 + x);\n\t\t\t\t\t\t\t\tl = strlen(s);\n\t\t\t\t\t\t\t\tarc = get_arc(s);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (arc > 0) l = strlen(cfg.custom_aspect_ratio[arc - 1]);\n\n\t\t\t\t\t\t\ts[0] = ' ';\n\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 1);\n\n\t\t\t\t\t\t\tchar *end = s + strlen(s) - 1;\n\t\t\t\t\t\t\twhile ((end > s + 1) && (*end == ' ')) end--;\n\t\t\t\t\t\t\t*(end + 1) = 0;\n\n\t\t\t\t\t\t\tint len = strlen(s);\n\t\t\t\t\t\t\tif (len+l > 27) len = 27-l;\n\t\t\t\t\t\t\ts[len++] = ':';\n\t\t\t\t\t\t\ts[len] = 0;\n\n\t\t\t\t\t\t\tl = 28 - l - strlen(s);\n\t\t\t\t\t\t\twhile (l--) strcat(s, \" \");\n\n\t\t\t\t\t\t\tif (arc > 0) strcpy(s + strlen(s), cfg.custom_aspect_ratio[arc - 1]);\n\t\t\t\t\t\t\telse substrcpy(s + strlen(s), p, 2 + x);\n\n\t\t\t\t\t\t\tMenuWrite(entry, s, menusub == selentry, d);\n\n\t\t\t\t\t\t\t// add bit in menu mask\n\t\t\t\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t\tselentry++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// delimiter, text\n\t\t\t\t\t\tif (p[0] == '-')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts[0] = ' ';\n\t\t\t\t\t\t\ts[1] = 0;\n\t\t\t\t\t\t\tsubstrcpy(s + 1, p, 1);\n\t\t\t\t\t\t\tlast_space = (strlen(s) == 1);\n\t\t\t\t\t\t\tMenuWrite(entry, s, 0, d);\n\t\t\t\t\t\t\tentry++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (p);\n\n\t\t\tif (!entry) break;\n\n\t\t\tfor (; entry < OsdGetSize() - 1; entry++) MenuWrite(entry, \"\", 0, 0);\n\n\t\t\t// exit row\n\t\t\tif (!page)\n\t\t\t{\n\t\t\t\tMenuWrite(entry, STD_EXIT, menusub == selentry, 0, OSD_ARROW_RIGHT | OSD_ARROW_LEFT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMenuWrite(entry, STD_BACK, menusub == selentry, 0, 0);\n\t\t\t}\n\t\t\tmenusub_last = selentry;\n\t\t\tmenumask = (menumask << 1) | 1;\n\n\t\t\tif (parentstate == MENU_NONE1 && is_pce() && pcecd_using_cd() && menusub != s_entry)\n\t\t\t{\n\t\t\t\tmenusub = s_entry;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!adjvisible) break;\n\t\t\tfirstmenu += adjvisible;\n\t\t}\n\n\t\tif (!entry)\n\t\t{\n\t\t\tif (page) page = 0;\n\t\t\telse menustate = MENU_COMMON1;\n\t\t\tmenusub = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tparentstate = menustate;\n\t\tmenustate = MENU_GENERIC_MAIN2;\n\n\t\t// set helptext with core display on top of basic info\n\t\tsprintf(helptext_custom, HELPTEXT_SPACER);\n\t\tstrcat(helptext_custom, OsdCoreNameGet());\n\t\tif (is_arcade())\n\t\t{\n\t\t\tstrcat(helptext_custom, \" (\");\n\t\t\tstrcat(helptext_custom, user_io_get_core_name(1));\n\t\t\tstrcat(helptext_custom, \")\");\n\t\t}\n\t\tstrcat(helptext_custom, helptexts[HELPTEXT_MAIN]);\n\t\thelptext_idx = HELPTEXT_CUSTOM;\n\n\t} break;\n\n\tcase MENU_GENERIC_SAVE_WAIT:\n\t\tmenumask = 0;\n\t\tparentstate = menustate;\n\t\tif (menu)\n\t\t{\n\t\t\tmenu_save_timer = 0;\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\telse if (menu_save_timer && CheckTimer(menu_save_timer))\n\t\t{\n\t\t\tmenu_save_timer = 0;\n\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_GENERIC_MAIN2:\n\t\tsaved_menustate = MENU_GENERIC_MAIN1;\n\n\t\t// F/S option not found -> deactivate mgl.\n\t\tif (!mgl->done && mgl->item[mgl->current].submenu < 0)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t\tmgl->state = 3;\n\t\t}\n\n\t\tif (menu_save_timer && !CheckTimer(menu_save_timer))\n\t\t{\n\t\t\tfor (int i = 0; i < 16; i++) OsdWrite(m++);\n\t\t\tOsdWrite(8, \"          Saving...\");\n\t\t\tmenustate = MENU_GENERIC_SAVE_WAIT;\n\t\t}\n\t\telse if (is_arcade() && spi_uio_cmd(UIO_CHK_UPLOAD))\n\t\t{\n\t\t\tmenu_save_timer = GetTimer(1000);\n\t\t\tarcade_nvm_save();\n\t\t}\n\t\telse if (menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\telse if(back || (left && page) || (menusub == menusub_last && select))\n\t\t{\n\t\t\tif(!page) menustate = MENU_NONE1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfirstmenu = 0;\n\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\tmenusub = menusub_parent;\n\t\t\t\tpage = 0;\n\t\t\t}\n\t\t}\n\t\telse if (select || recent || minus || plus || !mgl->done)\n\t\t{\n\t\t\tif (!mgl->done)\n\t\t\t{\n\t\t\t\tmenusub = mgl->item[mgl->current].submenu;\n\t\t\t\tselect = 1;\n\t\t\t}\n\n\t\t\tif ((dip_submenu == menusub || dip2_submenu == menusub) && select)\n\t\t\t{\n\t\t\t\tdipv = (dip_submenu == menusub) ? 0 : 1;\n\t\t\t\tmenustate = MENU_ARCADE_DIP1;\n\t\t\t\tmenusub = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstatic char ext[256];\n\t\t\t\tint h = 0, d = 0, inpage = !page;\n\t\t\t\tuint32_t entry = 0;\n\t\t\t\tint i = 2;\n\n\t\t\t\tp = 0;\n\t\t\t\taddon[0] = 0;\n\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tp = user_io_get_confstr(i++);\n\t\t\t\t\tif (!p) break;\n\n\t\t\t\t\th = 0;\n\t\t\t\t\td = 0;\n\t\t\t\t\tinpage = !page;\n\n\t\t\t\t\tif (!strcmp(p, \"DIP\")) h = page || !arcade_sw(0)->dip_num;\n\t\t\t\t\telse if (!strcmp(p, \"CHEAT\")) h = page || !arcade_sw(1)->dip_num;\n\t\t\t\t\telse if (strncmp(p, \"DEFMRA,\", 7))\n\t\t\t\t\t{\n\t\t\t\t\t\t//Hide or Disable flag\n\t\t\t\t\t\twhile ((p[0] == 'H' || p[0] == 'D' || p[0] == 'h' || p[0] == 'd') && strlen(p) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint flg = (hdmask & (1 << user_io_hd_mask(p + 1))) ? 1 : 0;\n\t\t\t\t\t\t\tif (p[0] == 'H') h |= flg;\n\t\t\t\t\t\t\tif (p[0] == 'h') h |= (flg ^ 1);\n\t\t\t\t\t\t\tif (p[0] == 'D') d |= flg;\n\t\t\t\t\t\t\tif (p[0] == 'd') d |= (flg ^ 1);\n\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p[0] == 'P')\n\t\t\t\t\t{\n\t\t\t\t\t\tint n = p[1] - '0';\n\t\t\t\t\t\tif (p[2] != ',')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (page && page == n) inpage = 1;\n\t\t\t\t\t\t\tif (!page && n && !flat) inpage = 0;\n\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!inpage || h || p[0] < 'A') continue;\n\n\t\t\t\t\t// supplement files\n\t\t\t\t\tif (p[0] == 'f')\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(addon, p);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (entry == menusub) break;\n\t\t\t\t\tentry++;\n\n\t\t\t\t\tif (p[0] == 'F' || p[0] == 'S') addon[0] = 0;\n\t\t\t\t}\n\n\t\t\t\tif (p && !d)\n\t\t\t\t{\n\t\t\t\t\tif (p[0] == 'F' && (select || recent))\n\t\t\t\t\t{\n\t\t\t\t\t\tstore_name = 0;\n\t\t\t\t\t\topensave = 0;\n\t\t\t\t\t\tioctl_index = menusub + 1;\n\t\t\t\t\t\tint idx = 1;\n\n\t\t\t\t\t\tif (p[idx] == 'S')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\topensave = 1;\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (p[idx] == 'C')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstore_name = 1;\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (p[idx] >= '0' && p[idx] <= '9') ioctl_index = p[idx] - '0';\n\t\t\t\t\t\tsubstrcpy(ext, p, 1);\n\t\t\t\t\t\tif (is_gba() && FileExists(user_io_make_filepath(HomeDir(), \"goomba.rom\"))) strcat(ext, \"GB GBC\");\n\t\t\t\t\t\twhile (strlen(ext) % 3) strcat(ext, \" \");\n\n\t\t\t\t\t\tfs_Options = SCANO_DIR | (is_neogeo() ? SCANO_NEOGEO | SCANO_NOENTER : 0) | (store_name ? SCANO_CLEAR : 0);\n\t\t\t\t\t\tfs_MenuSelect = MENU_GENERIC_FILE_SELECTED;\n\t\t\t\t\t\tfs_MenuCancel = MENU_GENERIC_MAIN1;\n\t\t\t\t\t\tstrcpy(fs_pFileExt, ext);\n\n\t\t\t\t\t\tload_addr = 0;\n\t\t\t\t\t\tif (substrcpy(s, p, 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tload_addr = strtoul(s, NULL, 16);\n\t\t\t\t\t\t\tif (load_addr < 0x20000000 || load_addr >= 0x40000000)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"Loading address 0x%X is outside the supported range! Using normal load.\\n\", load_addr);\n\t\t\t\t\t\t\t\tload_addr = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!mgl->done) menustate = MENU_GENERIC_FILE_SELECTED;\n\t\t\t\t\t\telse if (select) SelectFile(Selected_F[ioctl_index & 15], ext, fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\t\t\t\telse if (recent_init(ioctl_index)) menustate = MENU_RECENT1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (p[0] == 'S' && (select || recent))\n\t\t\t\t\t{\n\t\t\t\t\t\tstore_name = 0;\n\t\t\t\t\t\tint idx = 1;\n\n\t\t\t\t\t\tif (p[idx] == 'C')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstore_name = 1;\n\t\t\t\t\t\t\tidx++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tioctl_index = 0;\n\t\t\t\t\t\tif ((p[idx] >= '0' && p[idx] <= '9') || is_x86() || is_pcxt()) ioctl_index = p[idx] - '0';\n\t\t\t\t\t\tsubstrcpy(ext, p, 1);\n\t\t\t\t\t\twhile (strlen(ext) % 3) strcat(ext, \" \");\n\n\t\t\t\t\t\tfs_Options = SCANO_DIR | SCANO_UMOUNT;\n\t\t\t\t\t\tfs_MenuSelect = MENU_GENERIC_IMAGE_SELECTED;\n\t\t\t\t\t\tfs_MenuCancel = MENU_GENERIC_MAIN1;\n\t\t\t\t\t\tstrcpy(fs_pFileExt, ext);\n\n\t\t\t\t\t\tmemcpy(Selected_tmp, Selected_S[(int)ioctl_index], sizeof(Selected_tmp));\n\t\t\t\t\t\tif (is_x86() || is_pcxt()) strcpy(Selected_tmp, x86_get_image_path(ioctl_index));\n\t\t\t\t\t\tif (is_psx() && (ioctl_index == 2 || ioctl_index == 3)) fs_Options |= SCANO_SAVES;\n\n\t\t\t\t\t\tif (is_saturn() || is_pce() || is_megacd() || is_x86() || is_cdi() || (is_psx() && !(fs_Options & SCANO_SAVES)) || is_neogeo())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//look for CHD too\n\t\t\t\t\t\t\tif (!strcasestr(ext, \"CHD\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcat(fs_pFileExt, \"CHD\");\n\t\t\t\t\t\t\t\tstrcat(ext, \"CHD\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint num = ScanDirectory(Selected_tmp, SCANF_INIT, fs_pFileExt, 0);\n\t\t\t\t\t\t\tmemcpy(Selected_tmp, Selected_S[(int)ioctl_index], sizeof(Selected_tmp));\n\n\t\t\t\t\t\t\tif (num == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfs_Options |= SCANO_NOENTER;\n\t\t\t\t\t\t\t\tchar *p = strrchr(Selected_tmp, '/');\n\t\t\t\t\t\t\t\tif (p) *p = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfs_Options |= SCANO_NOZIP;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (is_psx()) fs_Options |= SCANO_NOZIP;\n\n\t\t\t\t\t\tif (!mgl->done) menustate = MENU_GENERIC_IMAGE_SELECTED;\n\t\t\t\t\t\telse if (select) SelectFile(Selected_tmp, ext, fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\t\t\t\telse if (recent_init(ioctl_index + 500)) menustate = MENU_RECENT1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (select || minus || plus)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (p[0] == 'P' && select)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpage = p[1] - '0';\n\t\t\t\t\t\t\tif (page < 1 || page > 9) page = 0;\n\t\t\t\t\t\t\tmenusub_parent = menusub;\n\t\t\t\t\t\t\tsubstrcpy(title, p, 1);\n\t\t\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t\t\t\tmenusub = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (p[0] == 'C' && cheats_available() && select)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmenustate = MENU_CHEATS1;\n\t\t\t\t\t\t\tcheatsub = menusub;\n\t\t\t\t\t\t\tmenusub = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((p[0] == 'O') || (p[0] == 'o'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint ex = (p[0] == 'o');\n\n\t\t\t\t\t\t\tint byarm = 0;\n\t\t\t\t\t\t\tif (p[1] == 'X')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbyarm = 1;\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tuint32_t x = user_io_status_get(p + 1, ex);\n\t\t\t\t\t\t\tx = minus ? (x - 1) : (x + 1);\n\t\t\t\t\t\t\tuint32_t mask = user_io_status_mask(p + 1);\n\t\t\t\t\t\t\tx &= mask;\n\n\t\t\t\t\t\t\tif (byarm && is_x86() && p[1] == '2') x86_set_fdd_boot(!(x & 1));\n\n\t\t\t\t\t\t\t// check if next value available\n\t\t\t\t\t\t\tif (minus)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile(1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsubstrcpy(s, p, 2 + x);\n\t\t\t\t\t\t\t\t\tif (strlen(s) && get_arc(s) >= 0) break;\n\t\t\t\t\t\t\t\t\tx = (x - 1) & mask;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsubstrcpy(s, p, 2 + x);\n\t\t\t\t\t\t\t\tif (!strlen(s) || get_arc(s) < 0) x = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tuser_io_status_set(p + 1, x, ex);\n\n\t\t\t\t\t\t\tif (is_x86() && p[1] == 'A')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint mode = GetUARTMode();\n\t\t\t\t\t\t\t\tif (mode != 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSetUARTMode(0);\n\t\t\t\t\t\t\t\t\tSetUARTMode(mode);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (((p[0] == 'T') || (p[0] == 'R') || (p[0] == 't') || (p[0] == 'r')) && select)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint bit;\n\t\t\t\t\t\t\tint ex = (p[0] == 't') || (p[0] == 'r');\n\t\t\t\t\t\t\tif (user_io_status_bits(p + 1, &bit, 0, ex) == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconst char *opt = p + 1;\n\t\t\t\t\t\t\t\tif (!bit && (is_x86() || is_pcxt()))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx86_init();\n\t\t\t\t\t\t\t\t\tResetUART();\n\t\t\t\t\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (!bit && is_uneon())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tx86_ide_set();\n\t\t\t\t\t\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (is_megacd())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (!bit) mcd_set_image(0, \"\");\n\t\t\t\t\t\t\t\t\t\tif (bit == 1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tmcd_reset();\n\t\t\t\t\t\t\t\t\t\t\topt = \"[0]\";\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (is_pce() && !bit) pcecd_reset();\n\t\t\t\t\t\t\t\t\tif (is_saturn() && !bit) saturn_reset();\n\t\t\t\t\t\t\t\t\tif (is_n64() && !bit) n64_reset();\n\n\t\t\t\t\t\t\t\t\tuser_io_status_set(opt, 1, ex);\n\t\t\t\t\t\t\t\t\tuser_io_status_set(opt, 0, ex);\n\n\t\t\t\t\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t\t\t\t\t\tif (p[0] == 'R' || p[0] == 'r') menustate = MENU_NONE1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (recent)\n\t\t\t\t\t{\n\t\t\t\t\t\tflat = !flat;\n\t\t\t\t\t\tpage = 0;\n\t\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t\t\tmenusub = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (right && !page)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 0;\n\t\t}\n\t\telse if (left)\n\t\t{\n\t\t\tmenustate = MENU_MISC1;\n\t\t\tmenusub = 3;\n\t\t}\n\t\telse if(spi_uio_cmd16(UIO_GET_OSDMASK, 0) != hdmask)\n\t\t{\n\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t}\n\n\t\tbreak;\n\n\tcase MENU_GENERIC_FILE_SELECTED:\n\t\t{\n\t\t\tif (!mgl->done)\n\t\t\t{\n\t\t\t\tif(mgl->item[mgl->current].path[0] == '/') snprintf(selPath, sizeof(selPath), \"%s\", mgl->item[mgl->current].path);\n\t\t\t\telse snprintf(selPath, sizeof(selPath), \"%s/%s\", HomeDir(), mgl->item[mgl->current].path);\n\t\t\t}\n\n\t\t\tMenuHide();\n\t\t\tprintf(\"File selected: %s\\n\", selPath);\n\t\t\tmemcpy(Selected_F[ioctl_index & 15], selPath, sizeof(Selected_F[ioctl_index & 15]));\n\n\t\t\tif (mgl->done && selPath[0]) recent_update(SelectedDir, Selected_F[ioctl_index & 15], SelectedLabel, ioctl_index);\n\n\t\t\tif (store_name)\n\t\t\t{\n\t\t\t\tchar str[64];\n\t\t\t\tsprintf(str, \"%s.f%d\", user_io_get_core_name(), ioctl_index);\n\t\t\t\tFileSaveConfig(str, selPath, sizeof(selPath));\n\t\t\t}\n\n\t\t\tif (selPath[0])\n\t\t\t{\n\n\t\t\t\tchar idx = user_io_ext_idx(selPath, fs_pFileExt) << 6 | ioctl_index;\n\t\t\t\tif (addon[0] == 'f' && addon[1] != '1') process_addon(addon, idx);\n\n\t\t\t\tif (fs_Options & SCANO_NEOGEO)\n\t\t\t\t{\n\t\t\t\t\tneocd_set_en(0);\n\t\t\t\t\tneogeo_romset_tx(selPath, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (is_pce())\n\t\t\t\t\t{\n\t\t\t\t\t\tpcecd_set_image(0, \"\");\n\t\t\t\t\t\tpcecd_reset();\n\t\t\t\t\t}\n\t\t\t\t\tif (!store_name) user_io_store_filename(selPath);\n\t\t\t\t\tif (is_n64())\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t n64_crc;\n\t\t\t\t\t\tif (!n64_rom_tx(selPath, idx, load_addr, n64_crc)) Info(\"failed to load ROM\");\n\t\t\t\t\t\telse if (user_io_use_cheats() && !store_name) cheats_init(selPath, n64_crc);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tuser_io_file_tx(selPath, idx, opensave, 0, 0, load_addr);\n\t\t\t\t\t\tif (user_io_use_cheats() && !store_name) cheats_init(selPath, user_io_get_file_crc());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (addon[0] == 'f' && addon[1] == '1') process_addon(addon, idx);\n\t\t\t}\n\n\t\t\tmgl->state = 3;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_GENERIC_IMAGE_SELECTED:\n\t\t{\n\t\t\tif (!mgl->done)\n\t\t\t{\n\t\t\t\tif (mgl->item[mgl->current].path[0] == '/') snprintf(selPath, sizeof(selPath), \"%s\", mgl->item[mgl->current].path);\n\t\t\t\telse snprintf(selPath, sizeof(selPath), \"%s/%s\", HomeDir(((is_pce() && !strncasecmp(fs_pFileExt, \"CUE\", 3)) ? PCECD_DIR : NULL)), mgl->item[mgl->current].path);\n\t\t\t}\n\n\t\t\tif (store_name)\n\t\t\t{\n\t\t\t\tchar str[64];\n\t\t\t\tsprintf(str, \"%s.s%d\", user_io_get_core_name(), ioctl_index);\n\t\t\t\tFileSaveConfig(str, selPath, sizeof(selPath));\n\t\t\t}\n\n\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\tif (selPath[0] && !is_x86() && !is_pcxt()) MenuHide();\n\n\t\t\tprintf(\"Image selected: %s\\n\", selPath);\n\t\t\tmemcpy(Selected_S[(int)ioctl_index], selPath, sizeof(Selected_S[(int)ioctl_index]));\n\t\t\tif (mgl->done) recent_update(SelectedDir, Selected_S[(int)ioctl_index], SelectedLabel, ioctl_index + 500);\n\n\t\t\tchar idx = user_io_ext_idx(selPath, fs_pFileExt) << 6 | ioctl_index;\n\t\t\tif (addon[0] == 'f' && addon[1] != '1') process_addon(addon, idx);\n\n\t\t\telse if (is_x86() || is_pcxt() || (is_uneon() && idx >= 2))\n\t\t\t{\n\t\t\t\tx86_set_image(ioctl_index, selPath);\n\t\t\t}\n\t\t\telse if (is_megacd())\n\t\t\t{\n\t\t\t\tmcd_set_image(ioctl_index, selPath);\n\t\t\t}\n\t\t\telse if (is_pce())\n\t\t\t{\n\t\t\t\tpcecd_set_image(ioctl_index, selPath);\n\t\t\t\tcheats_init(selPath, 0);\n\t\t\t}\n\t\t\telse if (is_psx() && ioctl_index == 1)\n\t\t\t{\n\t\t\t\tpsx_mount_cd(user_io_ext_idx(selPath, fs_pFileExt) << 6 | (menusub + 1), ioctl_index, selPath);\n\t\t\t\tcheats_init(selPath, 0);\n\t\t\t}\n\t\t\telse if (is_cdi())\n\t\t\t{\n\t\t\t\tcdi_mount_cd(ioctl_index, selPath);\n\t\t\t}\n\t\t\telse if (is_saturn())\n\t\t\t{\n\t\t\t\tsaturn_set_image(ioctl_index, selPath);\n\t\t\t}\n\t\t\telse if (is_neogeo())\n\t\t\t{\n\t\t\t\tneocd_set_en(1);\n\t\t\t\tneocd_set_image(selPath);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuser_io_set_index(user_io_ext_idx(selPath, fs_pFileExt) << 6 | (menusub + 1));\n\t\t\t\tuser_io_file_mount(selPath, ioctl_index);\n\t\t\t}\n\n\t\t\tif (addon[0] == 'f' && addon[1] == '1') process_addon(addon, idx);\n\n\t\t\tmgl->state = 3;\n\t\t\tif (!mgl->done) MenuHide();\n\t\t}\n\t\tbreak;\n\n\tcase MENU_COMMON1:\n\t\t{\n\t\t\tOsdSetSize(16);\n\t\t\thelptext_idx = 0;\n\t\t\treboot_req = 0;\n\n\t\t\tOsdSetTitle(\"System\", 0);\n\t\t\tmenustate = MENU_COMMON2;\n\t\t\tparentstate = MENU_COMMON1;\n\t\t\tint n;\n\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tn = 0;\n\t\t\t\tmenumask = 0x7805d;\n\n\t\t\t\tif (!menusub) firstmenu = 0;\n\t\t\t\tadjvisible = 0;\n\n\t\t\t\tMenuWrite(n++, \" Core                      \\x16\", menusub == 0, 0);\n\t\t\t\tMenuWrite(n++);\n\n\t\t\t\tif (cfg.osd_lock[0] && !cfg.osd_lock_time)\n\t\t\t\t{\n\t\t\t\t\tMenuWrite(n++, \" Lock OSD\", menusub == 1, 0);\n\t\t\t\t\tMenuWrite(n++);\n\t\t\t\t\tmenumask |= 2;\n\t\t\t\t}\n\n\t\t\t\tsprintf(s, \" Define %s buttons         \", is_menu() ? \"System\" : user_io_get_core_name());\n\t\t\t\ts[27] = '\\x16';\n\t\t\t\ts[28] = 0;\n\t\t\t\tMenuWrite(n++, s, menusub == 2, 0);\n\t\t\t\tMenuWrite(n++, \" Button/Key remap          \\x16\", menusub == 3, 0);\n\t\t\t\tMenuWrite(n++, \" Reset player assignment\", menusub == 4, 0);\n\n\t\t\t\tif (user_io_get_uart_mode())\n\t\t\t\t{\n\t\t\t\t\tmenumask |= 0x20;\n\t\t\t\t\tMenuWrite(n++);\n\t\t\t\t\tint mode = GetUARTMode();\n\t\t\t\t\tconst char *p = config_uart_msg[mode];\n\t\t\t\t\twhile (*p == ' ') p++;\n\t\t\t\t\tsprintf(s, \" UART mode (%s)            \",p);\n\t\t\t\t\ts[27] = '\\x16';\n\t\t\t\t\ts[28] = 0;\n\t\t\t\t\tMenuWrite(n++, s, menusub == 5);\n\t\t\t\t}\n\n\t\t\t\tMenuWrite(n++);\n\t\t\t\tMenuWrite(n++, \" Video processing          \\x16\", menusub==6);\n\n\t\t\t\tif (audio_filter_en() >= 0)\n\t\t\t\t{\n\t\t\t\t\tMenuWrite(n++);\n\t\t\t\t\tmenumask |= 0x600;\n\t\t\t\t\tsprintf(s, \" Audio filter - %s\", config_afilter_msg[audio_filter_en() ? 1 : 0]);\n\t\t\t\t\tMenuWrite(n++, s, menusub == 9);\n\n\t\t\t\t\tmemset(s, 0, sizeof(s));\n\t\t\t\t\ts[0] = ' ';\n\t\t\t\t\tif (strlen(audio_get_filter(1))) strncpy(s + 1, audio_get_filter(1), 25);\n\t\t\t\t\telse strcpy(s, \" < none >\");\n\n\t\t\t\t\twhile (strlen(s) < 26) strcat(s, \" \");\n\t\t\t\t\tstrcat(s, \" \\x16 \");\n\n\t\t\t\t\tMenuWrite(n++, s, menusub == 10, !audio_filter_en() || !S_ISDIR(getFileType(AFILTER_DIR)));\n\t\t\t\t}\n\n\t\t\t\tif (!is_minimig() && !is_st())\n\t\t\t\t{\n\t\t\t\t\tmenumask |= 0x6000;\n\t\t\t\t\tMenuWrite(n++);\n\t\t\t\t\tMenuWrite(n++, \" Reset settings\", menusub == 13, is_archie());\n\t\t\t\t\tMenuWrite(n++, \" Save settings\", menusub == 14, 0);\n\t\t\t\t}\n\n\t\t\t\tMenuWrite(n++);\n\t\t\t\tMenuWrite(n++, \" Help                      \\x16\", menusub == 15);\n\t\t\t\tMenuWrite(n++, \" About\",                          menusub == 16);\n\n\t\t\t\tMenuWrite(n++);\n\t\t\t\tcr = n;\n\t\t\t\tMenuWrite(n++, \" Reboot (hold \\x16 cold reboot)\", menusub == 17);\n\n\t\t\t\twhile(n < OsdGetSize() - 1) MenuWrite(n++);\n\t\t\t\tMenuWrite(n++, STD_EXIT, menusub == 18, 0, OSD_ARROW_LEFT);\n\t\t\t\tsysinfo_timer = 0;\n\n\t\t\t\tif (!adjvisible) break;\n\t\t\t\tfirstmenu += adjvisible;\n\t\t\t}\n\n\t\t}\n\t\tbreak;\n\n\tcase MENU_COMMON2:\n\t\tif (menu)\n        {\n\t\t\tswitch (user_io_core_type())\n\t\t\t{\n\t\t\t    case CORE_TYPE_SHARPMZ:\n\t\t\t\t    menusub   = menusub_last;\n\t\t\t\t    menustate = sharpmz_default_ui_state();\n                    break;\n                default:\n                    menustate = MENU_NONE1;\n                    break;\n            };\n        }\n\n\t\tif (recent && menusub == 0)\n\t\t{\n\t\t\tfs_Options = SCANO_CORES;\n\t\t\tfs_MenuSelect = MENU_CORE_FILE_SELECTED1;\n\t\t\tfs_MenuCancel = MENU_COMMON1;\n\n\t\t\tif (recent_init(-1)) menustate = MENU_RECENT1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (select)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tSelectFile(\"\", 0, SCANO_CORES, MENU_CORE_FILE_SELECTED1, MENU_COMMON1);\n\t\t\t\tmenusub = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tosd_unlocked = 0;\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tif (is_minimig())\n\t\t\t\t{\n\t\t\t\t\tjoy_bcount = 7;\n\t\t\t\t\tstrcpy(joy_bnames[0], \"A(Red/Fire)\");\n\t\t\t\t\tstrcpy(joy_bnames[1], \"B(Blue)\");\n\t\t\t\t\tstrcpy(joy_bnames[2], \"C(Yellow)\");\n\t\t\t\t\tstrcpy(joy_bnames[3], \"D(Green)\");\n\t\t\t\t\tstrcpy(joy_bnames[4], \"RT\");\n\t\t\t\t\tstrcpy(joy_bnames[5], \"LT\");\n\t\t\t\t\tstrcpy(joy_bnames[6], \"Pause\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparse_buttons();\n\t\t\t\t}\n\t\t\t\tstart_map_setting(joy_bcount ? joy_bcount+4 : 8);\n\t\t\t\tmenustate = MENU_JOYDIGMAP;\n\t\t\t\tmenusub = 0;\n\t\t\t\tjoymap_first = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tstart_map_setting(-1);\n\t\t\t\tmenustate = MENU_JOYKBDMAP;\n\t\t\t\tmenusub = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\treset_players();\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_UART1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_VIDEOPROC1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\t\taudio_set_filter_en(audio_filter_en() ? 0 : 1);\n\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tif (audio_filter_en())\n\t\t\t\t{\n\t\t\t\t\tsnprintf(Selected_tmp, sizeof(Selected_tmp), AFILTER_DIR\"/%s\", audio_get_filter(0));\n\t\t\t\t\tif (!FileExists(Selected_tmp)) snprintf(Selected_tmp, sizeof(Selected_tmp), AFILTER_DIR);\n\t\t\t\t\tSelectFile(Selected_tmp, 0, SCANO_DIR | SCANO_TXT, MENU_AFILTER_FILE_SELECTED, MENU_COMMON1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 13:\n\t\t\t\tif (!is_archie())\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_RESET1;\n\t\t\t\t\tmenusub = 1;\n\t\t\t\t}\n\t\t\t\telse if (user_io_core_type() == CORE_TYPE_SHARPMZ)\n\t\t\t\t{\n\t\t\t\t\tmenustate = sharpmz_reset_config(1);\n                    menusub   = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 14:\n\t\t\t\t// Save settings\n\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\tmenusub = 0;\n\n\t\t\t\tif (is_archie())\n\t\t\t\t{\n\t\t\t\t\tarchie_save_config();\n\t\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\t}\n\t\t\t\telse if (user_io_core_type() == CORE_TYPE_SHARPMZ)\n\t\t\t\t{\n\t\t\t\t\tmenustate = sharpmz_save_config();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar *filename = user_io_create_config_name(1);\n\t\t\t\t\tprintf(\"Saving config to %s\\n\", filename);\n\t\t\t\t\tuser_io_status_save(filename);\n\t\t\t\t\tif (is_x86() || is_pcxt()) x86_config_save();\n\t\t\t\t\tif (is_arcade()) arcade_nvm_save();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 15:\n\t\t\t\tFileCreatePath(DOCS_DIR);\n\t\t\t\tsnprintf(Selected_tmp, sizeof(Selected_tmp), DOCS_DIR \"/%s\",user_io_get_core_name());\n\t\t\t\tFileCreatePath(Selected_tmp);\n\t\t\t\tSelectFile(Selected_tmp, \"PDFTXTMD \",  SCANO_DIR | SCANO_TXT  , MENU_DOC_FILE_SELECTED, MENU_COMMON1);\n\t\t\t\tbreak;\n\n\t\t\tcase 16:\n\t\t\t\tmenustate = MENU_ABOUT1;\n\t\t\t\tmenusub = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 17:\n\t\t\t\t{\n\t\t\t\t\treboot_req = 1;\n\n\t\t\t\t\tint off = hold_cnt / 3;\n\t\t\t\t\tif (off > 5) reboot(1);\n\n\t\t\t\t\tsprintf(s, \" Cold Reboot\");\n\t\t\t\t\tp = s + 5 - off;\n\t\t\t\t\tMenuWrite(cr, p, 1, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (left)\n\t\t{\n\t\t\t// go back to core requesting this menu\n\t\t\tswitch (user_io_core_type())\n\t\t\t{\n\t\t\tcase CORE_TYPE_8BIT:\n\t\t\t\tif (is_minimig())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\t}\n\t\t\t\telse if (is_archie())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\t}\n\t\t\t\telse if (is_st())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CORE_TYPE_SHARPMZ:\n\t\t\t\tmenusub   = menusub_last;\n\t\t\t\tmenustate = sharpmz_default_ui_state();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (minus || plus)\n\t\t{\n\t\t\tif (menusub == 10 && audio_filter_en())\n\t\t\t{\n\t\t\t\tconst char *newfile = flist_GetPrevNext(AFILTER_DIR, audio_get_filter(0), \"TXT\", plus);\n\t\t\t\taudio_set_filter(newfile ? newfile : \"\");\n\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t}\n\t\t}\n\n\t\tif(!hold_cnt && reboot_req) fpga_load_rbf(\"menu.rbf\");\n\t\tbreak;\n\n\tcase MENU_VIDEOPROC1:\n\t\thelptext_idx = 0;\n\t\tmenumask = 0x1FFF;\n\t\tOsdSetTitle(\"Video Processing\");\n\t\tmenustate = MENU_VIDEOPROC2;\n\t\tparentstate = MENU_VIDEOPROC1;\n\n\t\twhile (1)\n\t\t{\n\t\t\tint n = 0;\n\t\t\tif (!menusub) firstmenu = 0;\n\t\t\tadjvisible = 0;\n\n\t\t\tMenuWrite(n++, \" Load preset\", menusub == 0);\n\t\t\tMenuWrite(n++);\n\n\t\t\tsprintf(s, video_get_scaler_flt(VFILTER_HORZ) ?  \" Horz filter: From file\" : \" Video filter: NearNeighbour\");\n\t\t\tMenuWrite(n++, s, menusub == 1, cfg.direct_video);\n\t\t\tstrcpy(s, \" \");\n\t\t\tif (strlen(video_get_scaler_coeff(VFILTER_HORZ))) strncat(s, video_get_scaler_coeff(VFILTER_HORZ), 25);\n\t\t\telse strcpy(s, \" < none >\");\n\t\t\twhile (strlen(s) < 26) strcat(s, \" \");\n\t\t\tstrcat(s, \" \\x16 \");\n\t\t\tMenuWrite(n++, s, menusub == 2, !video_get_scaler_flt(VFILTER_HORZ) || !S_ISDIR(getFileType(COEFF_DIR)));\n\n\t\t\tMenuWrite(n++);\n\t\t\tsprintf(s, \" Vert filter: %s\", video_get_scaler_flt(VFILTER_VERT) ? \"From file\" : \"Same as Horz\");\n\t\t\tMenuWrite(n++, s, menusub == 3, cfg.direct_video || !video_get_scaler_flt(VFILTER_HORZ));\n\t\t\tstrcpy(s, \" \");\n\t\t\tif (strlen(video_get_scaler_coeff(VFILTER_VERT))) strncat(s, video_get_scaler_coeff(VFILTER_VERT), 25);\n\t\t\telse strcpy(s, \" < none >\");\n\t\t\twhile (strlen(s) < 26) strcat(s, \" \");\n\t\t\tstrcat(s, \" \\x16 \");\n\t\t\tMenuWrite(n++, s, menusub == 4, !video_get_scaler_flt(VFILTER_VERT) || !video_get_scaler_flt(VFILTER_HORZ) || !S_ISDIR(getFileType(COEFF_DIR)) || cfg.direct_video);\n\n\t\t\tMenuWrite(n++);\n\t\t\tsprintf(s, \" Scan filter: %s\", video_get_scaler_flt(VFILTER_SCAN) ? \"From file\" : \"Same as Vert\");\n\t\t\tMenuWrite(n++, s, menusub == 5, cfg.direct_video || !video_get_scaler_flt(VFILTER_HORZ));\n\t\t\tstrcpy(s, \" \");\n\t\t\tif (strlen(video_get_scaler_coeff(VFILTER_SCAN))) strncat(s, video_get_scaler_coeff(VFILTER_SCAN), 25);\n\t\t\telse strcpy(s, \" < none >\");\n\t\t\twhile (strlen(s) < 26) strcat(s, \" \");\n\t\t\tstrcat(s, \" \\x16 \");\n\t\t\tMenuWrite(n++, s, menusub == 6, !video_get_scaler_flt(VFILTER_SCAN) || !video_get_scaler_flt(VFILTER_HORZ) || !S_ISDIR(getFileType(COEFF_DIR)) || cfg.direct_video);\n\n\t\t\tMenuWrite(n++);\n\t\t\tsprintf(s, \" Gamma correction - %s\", (video_get_gamma_en() > 0) ? \"On\" : \"Off\");\n\t\t\tMenuWrite(n++, s, menusub == 7, video_get_gamma_en() < 0);\n\t\t\tstrcpy(s, \" \");\n\t\t\tif (strlen(video_get_gamma_curve())) strncat(s, video_get_gamma_curve(), 25);\n\t\t\telse strcpy(s, \" < none >\");\n\t\t\twhile (strlen(s) < 26) strcat(s, \" \");\n\t\t\tstrcat(s, \" \\x16 \");\n\t\t\tMenuWrite(n++, s, menusub == 8, (video_get_gamma_en() <= 0) || !S_ISDIR(getFileType(GAMMA_DIR)));\n\n\t\t\tMenuWrite(n++);\n\t\t\tsprintf(s, \" Shadow Mask - %s\", (video_get_shadow_mask_mode() < 0) ? config_smask_msg[0] : config_smask_msg[video_get_shadow_mask_mode()]);\n\t\t\tMenuWrite(n++, s, menusub == 9, video_get_shadow_mask_mode() < 0);\n\t\t\tstrcpy(s, \" \");\n\t\t\tif (strlen(video_get_shadow_mask())) strncat(s, video_get_shadow_mask(), 25);\n\t\t\telse strcpy(s, \" < none >\");\n\t\t\twhile (strlen(s) < 26) strcat(s, \" \");\n\t\t\tstrcat(s, \" \\x16 \");\n\t\t\tMenuWrite(n++, s, menusub == 10, (video_get_shadow_mask_mode() <= 0) || !S_ISDIR(getFileType(SMASK_DIR)));\n\n\t\t\tMenuWrite(n++);\n\t\t\tMenuWrite(n++, \" Reset to Defaults\", menusub == 11);\n\n\t\t\tMenuWrite(n++);\n\t\t\tMenuWrite(n++, STD_BACK, menusub == 12);\n\n\t\t\tif (!adjvisible) break;\n\t\t\tfirstmenu += adjvisible;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_VIDEOPROC2:\n\t\tif (menu || left)\n\t\t{\n\t\t\tmenusub = 6;\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((select || recent) && menusub == 0)\n\t\t{\n\t\t\tfs_Options = SCANO_DIR | SCANO_TXT;\n\t\t\tfs_MenuSelect = MENU_PRESET_FILE_SELECTED;\n\t\t\tfs_MenuCancel = parentstate;\n\t\t\tstrcpy(fs_pFileExt, \"INI\");\n\t\t\tif (!FileExists(Selected_F[15])) snprintf(Selected_F[15], sizeof(Selected_F[15]), PRESET_DIR);\n\t\t\tif (select) SelectFile(Selected_F[15], fs_pFileExt, fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\telse if (recent_init(15)) menustate = MENU_RECENT1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (plus || minus)\n\t\t{\n\t\t\tif (menusub == 9)\n\t\t\t{\n\t\t\t\tvideo_set_shadow_mask_mode(video_get_shadow_mask_mode() + (plus ? 1 : -1));\n\t\t\t}\n\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 2:\n\t\t\tcase 4:\n\t\t\tcase 6:\n\t\t\t\tvfilter_type = (menusub == 2) ? VFILTER_HORZ : (menusub == 4) ? VFILTER_VERT : VFILTER_SCAN;\n\t\t\t\tif(video_get_scaler_flt(VFILTER_HORZ) && video_get_scaler_flt(vfilter_type))\n\t\t\t\t{\n\t\t\t\t\tconst char *newfile = flist_GetPrevNext(COEFF_DIR, video_get_scaler_coeff(vfilter_type, 0), \"TXT\", plus);\n\t\t\t\t\tvideo_set_scaler_coeff(vfilter_type, newfile ? newfile : \"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\tif(video_get_gamma_en() > 0)\n\t\t\t\t{\n\t\t\t\t\tconst char *newfile = flist_GetPrevNext(GAMMA_DIR, video_get_gamma_curve(0), \"TXT\", plus);\n\t\t\t\t\tvideo_set_gamma_curve(newfile ? newfile : \"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tif (video_get_shadow_mask_mode() > 0)\n\t\t\t\t{\n\t\t\t\t\tconst char *newfile = flist_GetPrevNext(SMASK_DIR, video_get_shadow_mask(0), \"TXT\", plus);\n\t\t\t\t\tvideo_set_shadow_mask(newfile ? newfile : \"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmenustate = parentstate;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (select)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif (!cfg.direct_video)\n\t\t\t\t{\n\t\t\t\t\tvideo_set_scaler_flt(VFILTER_HORZ, video_get_scaler_flt(VFILTER_HORZ) ? 0 : 1);\n\t\t\t\t\tmenustate = parentstate;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\tcase 4:\n\t\t\tcase 6:\n\t\t\t\tvfilter_type = (menusub == 2) ? VFILTER_HORZ : (menusub == 4) ? VFILTER_VERT : VFILTER_SCAN;\n\t\t\t\tif (video_get_scaler_flt(VFILTER_HORZ))\n\t\t\t\t{\n\t\t\t\t\tsnprintf(Selected_tmp, sizeof(Selected_tmp), COEFF_DIR\"/%s\", video_get_scaler_coeff(vfilter_type, 0));\n\t\t\t\t\tif (!FileExists(Selected_tmp)) snprintf(Selected_tmp, sizeof(Selected_tmp), COEFF_DIR);\n\t\t\t\t\tSelectFile(Selected_tmp, 0, SCANO_DIR | SCANO_TXT, MENU_COEFF_FILE_SELECTED, parentstate);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tif (!cfg.direct_video && video_get_scaler_flt(VFILTER_HORZ))\n\t\t\t\t{\n\t\t\t\t\tvideo_set_scaler_flt(VFILTER_VERT, video_get_scaler_flt(VFILTER_VERT) ? 0 : 1);\n\t\t\t\t\tmenustate = parentstate;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\tif (!cfg.direct_video && video_get_scaler_flt(VFILTER_HORZ))\n\t\t\t\t{\n\t\t\t\t\tvideo_set_scaler_flt(VFILTER_SCAN, video_get_scaler_flt(VFILTER_SCAN) ? 0 : 1);\n\t\t\t\t\tmenustate = parentstate;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tif (video_get_gamma_en() >= 0) video_set_gamma_en(video_get_gamma_en() ? 0 : 1);\n\t\t\t\tmenustate = parentstate;\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\tif (video_get_gamma_en() > 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(Selected_tmp, sizeof(Selected_tmp), GAMMA_DIR\"/%s\", video_get_gamma_curve(0));\n\t\t\t\t\tif (!FileExists(Selected_tmp)) snprintf(Selected_tmp, sizeof(Selected_tmp), GAMMA_DIR);\n\t\t\t\t\tSelectFile(Selected_tmp, 0, SCANO_DIR | SCANO_TXT, MENU_GAMMA_FILE_SELECTED, parentstate);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\t\tif (video_get_shadow_mask_mode() >= 0) video_set_shadow_mask_mode(video_get_shadow_mask_mode() + 1);\n\t\t\t\tmenustate = parentstate;\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tif (video_get_shadow_mask_mode() > 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(Selected_tmp, sizeof(Selected_tmp), SMASK_DIR\"/%s\", video_get_shadow_mask(0));\n\t\t\t\t\tif (!FileExists(Selected_tmp)) snprintf(Selected_tmp, sizeof(Selected_tmp), SMASK_DIR);\n\t\t\t\t\tSelectFile(Selected_tmp, 0, SCANO_DIR | SCANO_TXT, MENU_SMASK_FILE_SELECTED, parentstate);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 11:\n\t\t\t\tvideo_cfg_reset();\n\t\t\t\tmenustate = parentstate;\n\t\t\t\tbreak;\n\n\t\t\tcase 12:\n\t\t\t\tmenusub = 6;\n\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_DOC_FILE_SELECTED:\n\t\tif (cfg.fb_terminal)\n\t\t{\n\t\t\tmemcpy(Selected_tmp, selPath, sizeof(Selected_tmp));\n\t\t\tstatic char cmd[1024 * 2];\n\t\t\tconst char *path = getFullPath(selPath);\n\t\t\tmenustate = MENU_DOC_FILE_SELECTED_2;\n\t\t\tvideo_chvt(2);\n\t\t\tvideo_fb_enable(1);\n\t\t\tvga_nag();\n\t\t\t// check file type\n\t\t\tconst char *ext = \"\";\n                        if (strlen(path) > 4) ext = path + strlen(path) - 4;\n\t\t\tstatic char binary[1024*2];\n\t\t\tprintf(\"extension: [%s]\\n\",ext);\n\t\t\tstrcpy(binary,\"/media/fat/linux/pdfviewer\");\n\t\t\tif (!strcasecmp(ext,\".pdf\")) {\n\t\t\t\tsprintf(binary,\"/media/fat/linux/pdfviewer --zoom_to_fit \\\"%s\\\"\",path);\n\t\t\t} else if (!strcasecmp(ext,\".txt\")) {\n\t\t\t\tsprintf(binary,\"less \\\"%s\\\"\",path);\n\t\t\t} else if (!strcasecmp(ext+1,\".md\")) {\n\t\t\t\tsprintf(binary,\"/media/fat/linux/glow --style dark  \\\"%s\\\" | less -R\",path);\n\t\t\t}\n\n\t\t\tsprintf(cmd, \"#!/bin/bash\\nexport LC_ALL=en_US.UTF-8\\nexport HOME=/root\\nexport LESSKEY=/media/fat/linux/lesskey\\ncd $(dirname \\\"%s\\\")\\n%s \\necho \\\"Press any key to continue\\\"\\n\", path, binary  );\n\t\t\tprintf(\"CMD [%s]\\n\",cmd);\n\t\t\tunlink(\"/tmp/script\");\n\t\t\tFileSave(\"/tmp/script\", cmd, strlen(cmd));\n\t\t\tttypid = fork();\n\t\t\tif (!ttypid)\n\t\t\t{\n\t\t\t\texecl(\"/sbin/agetty\", \"/sbin/agetty\", \"-a\", \"root\", \"-l\", \"/tmp/script\", \"--nohostname\", \"-L\", \"tty2\", \"linux\", NULL);\n\t\t\t\texit(0); //should never be reached\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_DOC_FILE_SELECTED_2:\n\t\tif (ttypid)\n\t\t{\n\t\t\tif (waitpid(ttypid, 0, WNOHANG) > 0)\n\t\t\t{\n\t\t\t\tttypid = 0;\n\t\t\t\tuser_io_osd_key_enable(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (c & UPSTROKE)\n\t\t\t{\n\t\t\t\tvideo_menu_bg(user_io_status_get(\"[3:1]\"));\n\t\t\t\tvideo_fb_enable(0);\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tmenusub = 3;\n\t\t\t\tOsdClear();\n\t\t\t\tOsdEnable(DISABLE_KEYBOARD);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ARCADE_DIP1:\n\t\thelptext_idx = 0;\n\t\tmenumask = 0;\n\t\tOsdSetTitle(dipv ? \"Cheats\" : \"DIP Switches\");\n\t\tmenustate = MENU_ARCADE_DIP2;\n\t\tparentstate = MENU_ARCADE_DIP1;\n\n\t\twhile (1)\n\t\t{\n\t\t\tint entry = 0;\n\t\t\tif (!menusub) firstmenu = 0;\n\n\t\t\tadjvisible = 0;\n\t\t\tuint32_t selentry = 0;\n\t\t\tmenumask = 0;\n\n\t\t\tsw_struct *sw = arcade_sw(dipv);\n\n\t\t\tint n = (sw->dip_num < OsdGetSize() - 1) ? (OsdGetSize() - 1 - sw->dip_num) / 2 : 0;\n\t\t\tfor (; entry < n; entry++) MenuWrite(entry);\n\n\t\t\tfor (int i = 0; i < sw->dip_num; i++)\n\t\t\t{\n\t\t\t\tuint64_t status = sw->dip_cur & sw->dip[i].mask;\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int n = 0; n < sw->dip[i].num; n++)\n\t\t\t\t{\n\t\t\t\t\tif (status == sw->dip[i].val[n])\n\t\t\t\t\t{\n\t\t\t\t\t\tm = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchar l = strlen(sw->dip[i].id[m]);\n\t\t\t\ts[0] = ' ';\n\t\t\t\tstrcpy(s + 1, sw->dip[i].name);\n\n\t\t\t\tchar *end = s + strlen(s) - 1;\n\t\t\t\twhile ((end > s + 1) && (*end == ' ')) end--;\n\t\t\t\t*(end + 1) = 0;\n\n\t\t\t\tstrcat(s, \":\");\n\t\t\t\tl = 28 - l - strlen(s);\n\t\t\t\twhile (l--) strcat(s, \" \");\n\n\t\t\t\tstrcat(s, sw->dip[i].id[m]);\n\n\t\t\t\tMenuWrite(entry, s, menusub == selentry);\n\n\t\t\t\tmenumask = (menumask << 1) | 1;\n\t\t\t\tentry++;\n\t\t\t\tselentry++;\n\t\t\t};\n\n\t\t\tfor (; entry < OsdGetSize() - 1; entry++) MenuWrite(entry, \"\", 0, 0);\n\n\t\t\tMenuWrite(entry, dipv ? STD_BACK : \"       Reset to apply\", menusub == selentry);\n\t\t\tmenusub_last = selentry;\n\t\t\tmenumask = (menumask << 1) | 1;\n\n\t\t\tif (!adjvisible) break;\n\t\t\tfirstmenu += adjvisible;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ARCADE_DIP2:\n\t\tif (menu || left)\n\t\t{\n\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\tmenusub = dipv ? dip2_submenu : dip_submenu;\n\t\t\tarcade_sw_save(0);\n\t\t}\n\n\t\tif (select)\n\t\t{\n\t\t\tif (menusub == menusub_last)\n\t\t\t{\n\t\t\t\tif (!dipv)\n\t\t\t\t{\n\t\t\t\t\tarcade_sw_save(dipv);\n\t\t\t\t\tuser_io_status_set(\"[0]\", 1);\n\t\t\t\t\tuser_io_status_set(\"[0]\", 0);\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmenusub = dip2_submenu;\n\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsw_struct *sw = arcade_sw(dipv);\n\t\t\t\tuint64_t status = sw->dip_cur & sw->dip[menusub].mask;\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int n = 0; n < sw->dip[menusub].num; n++)\n\t\t\t\t{\n\t\t\t\t\tif (status == sw->dip[menusub].val[n])\n\t\t\t\t\t{\n\t\t\t\t\t\tm = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tm = (m + 1) % sw->dip[menusub].num;\n\t\t\t\tsw->dip_cur = (sw->dip_cur & ~sw->dip[menusub].mask) | sw->dip[menusub].val[m];\n\t\t\t\tmenustate = MENU_ARCADE_DIP1;\n\t\t\t\tarcade_sw_send(dipv);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_UART1:\n\t\t{\n\t\t\thelptext_idx = 0;\n\t\t\tmenumask = 0x181;\n\n\t\t\tOsdSetTitle(\"UART Mode\");\n\t\t\tmenustate = MENU_UART2;\n\t\t\tparentstate = MENU_UART1;\n\n\t\t\tint mode = GetUARTMode();\n\t\t\tint midilink = GetMidiLinkMode();\n\n\t\t\tm = 0;\n\t\t\tOsdWrite(m++);\n\t\t\tsprintf(s, \" Connection:      %s\", config_uart_msg[mode]);\n\t\t\tOsdWrite(m++, s, menusub == 0, 0);\n\n\t\t\tOsdWrite(m++);\n\t\t\tif (mode == 4)\n\t\t\t{\n\t\t\t\tsprintf(s, \" Link:            %s\", (midilink == 6) ? \"USB Serial\" : (midilink == 5) ? \"       UDP\" : \"       TCP\");\n\t\t\t\tOsdWrite(m++, s, menusub == 1);\n\t\t\t\tmenumask |= 2;\n\t\t\t}\n\n\t\t\tif (mode == 3)\n\t\t\t{\n\t\t\t\tsprintf(s, \" MidiLink:             %s\", config_midilink_mode[midilink]);\n\t\t\t\tOsdWrite(m++, s, menusub == 2);\n\n\t\t\t\tif (midilink < 2)\n\t\t\t\t{\n\t\t\t\t\tsprintf(s, \" Type:                %s\", midilink ? \"  MUNT\" : \"FSYNTH\");\n\t\t\t\t\tOsdWrite(m++, s, menusub == 3);\n\n\t\t\t\t\tOsdWrite(m++);\n\t\t\t\t\tOsdWrite(m++, \" Change Soundfont          \\x16\", menusub == 4, midilink);\n\t\t\t\t\tmenumask |= 0x18;\n\t\t\t\t}\n\t\t\t\tOsdWrite(m++);\n\n\t\t\t\tmenumask |= 0x4;\n\t\t\t}\n\n\t\t\tif (mode)\n\t\t\t{\n\t\t\t\tstrcpy(s, \" Baud                      \\x16\");\n\t\t\t\tsprintf(s + 6, \"(%s)\", GetUARTbaud_label(GetUARTMode()));\n\t\t\t\ts[strlen(s)] = ' ';\n\t\t\t\tOsdWrite(m++, s, menusub == 5, !mode);\n\n\t\t\t\tOsdWrite(m++);\n\t\t\t\tOsdWrite(m++, \" Reset UART connection\", menusub == 6, mode ? 0 : 1);\n\n\t\t\t\tmenumask |= 0x60;\n\t\t\t}\n\n\t\t\tOsdWrite(m++, \" Save\", menusub == 7);\n\n\t\t\tfor (; m < 15; m++) OsdWrite(m);\n\t\t\tOsdWrite(15, STD_EXIT, menusub == 8);\n\t\t}\n\t\tbreak;\n\n\tcase MENU_UART2:\n\t\tif (menu || left)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 5;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (select || minus || plus)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tmenusub = GetUARTMode();\n\t\t\t\tmenustate = MENU_UART3;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t{\n\t\t\t\t\tint mode = GetUARTMode();\n\t\t\t\t\tint midilink = GetMidiLinkMode();\n\t\t\t\t\tSetUARTMode(0);\n\t\t\t\t\tif (minus)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (midilink <= 4) midilink = 6;\n\t\t\t\t\t\telse midilink--;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (midilink >= 6) midilink = 4;\n\t\t\t\t\t\telse midilink++;\n\t\t\t\t\t}\n\t\t\t\t\tSetMidiLinkMode(midilink);\n\t\t\t\t\tSetUARTMode(mode);\n\t\t\t\t\tmenustate = MENU_UART1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tint mode = GetUARTMode();\n\t\t\t\t\tint midilink = GetMidiLinkMode();\n\t\t\t\t\tSetUARTMode(0);\n\n\t\t\t\t\tif (minus)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (midilink < 2 || midilink > 3) midilink = 3;\n\t\t\t\t\t\telse if (midilink == 3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct stat filestat;\n\t\t\t\t\t\t\tmidilink = (!stat(\"/dev/midi1\", &filestat) || !stat(\"/dev/ttyUSB0\", &filestat)) ? 2 : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse midilink = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (midilink < 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct stat filestat;\n\t\t\t\t\t\t\tmidilink = (!stat(\"/dev/midi1\", &filestat) || !stat(\"/dev/ttyUSB0\", &filestat)) ? 2 : 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (midilink == 2) midilink = 3;\n\t\t\t\t\t\telse midilink = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tSetMidiLinkMode(midilink);\n\t\t\t\t\tSetUARTMode(mode);\n\t\t\t\t\tmenustate = MENU_UART1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t{\n\t\t\t\t\tint mode = GetUARTMode();\n\t\t\t\t\tint midilink = GetMidiLinkMode();\n\t\t\t\t\tSetUARTMode(0);\n\t\t\t\t\tSetMidiLinkMode(midilink ? 0 : 1);\n\t\t\t\t\tSetUARTMode(mode);\n\t\t\t\t\tmenustate = MENU_UART1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tif(select && GetMidiLinkMode() == 0)\n\t\t\t\t{\n\t\t\t\t\tsprintf(Selected_tmp, GetMidiLinkSoundfont());\n\t\t\t\t\tSelectFile(Selected_tmp, \"SF2\", SCANO_DIR | SCANO_TXT, MENU_SFONT_FILE_SELECTED, MENU_UART1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_BAUD1;\n\t\t\t\t\tmenusub = GetUARTbaud_idx(GetUARTMode());\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tResetUART();\n\t\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t\t\tmenusub = 5;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tint mode = GetUARTMode() | (GetMidiLinkMode() << 8);\n\t\t\t\t\tsprintf(s, \"uartmode.%s\", user_io_get_core_name());\n\t\t\t\t\tFileSaveConfig(s, &mode, 4);\n\t\t\t\t\tuint32_t speeds[3];\n\t\t\t\t\tspeeds[0] = GetUARTbaud(1);\n\t\t\t\t\tspeeds[1] = GetUARTbaud(3);\n\t\t\t\t\tspeeds[2] = GetUARTbaud(4);\n\t\t\t\t\tsprintf(s, \"uartspeed.%s\", user_io_get_core_name());\n\t\t\t\t\tFileSaveConfig(s, speeds, sizeof(speeds));\n\t\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t\t\tmenusub = 5;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_UART3:\n        {\n            helptext_idx = 0;\n            menumask = 0x00;\n            OsdSetTitle(\"UART MODE\");\n            menustate = MENU_UART4;\n            parentstate = MENU_UART3;\n\n            uint32_t max = (sizeof(config_uart_msg) / sizeof(config_uart_msg[0]));\n\t\t\tm = 0;\n\n            for (uint32_t i = 0; i < 15; i++)\n            {\n\t\t\t\tif((i >= (14-max)/2) && (m < max))\n                {\n                    menumask |= 1 << m;\n                    const char * uart_msg = config_uart_msg[m];\n                    while (*uart_msg == ' ') {uart_msg++;}//skip spaces\n                    sprintf(s, \"         %s\", uart_msg);\n                    OsdWrite(i, s, menusub == m, 0);\n\t\t\t\t\tm++;\n                }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tOsdWrite(i);\n\t\t\t\t}\n            }\n            menumask |= 0x10000;\n            OsdWrite(15, STD_EXIT, menusub == 16);\n        }\n        break;\n\n    case MENU_UART4:\n        {\n\t\t\tif (menu)\n\t\t\t{\n\t\t\t\tmenustate = MENU_UART1;\n\t\t\t\tmenusub = 0;\n\t\t\t}\n\t\t\telse if (select)\n\t\t\t{\n\t\t\t\tif (menusub != 16)\n\t\t\t\t{\n\t\t\t\t\tuint32_t max = (sizeof(config_uart_msg) / sizeof(config_uart_msg[0]));\n\t\t\t\t\tif (menusub < max)\n\t\t\t\t\t{\n\t\t\t\t\t\tint midilink = GetMidiLinkMode();\n\t\t\t\t\t\tif (menusub == 4) midilink = (midilink == 2) ? 6 : 4;\n\t\t\t\t\t\tif (menusub == 3) midilink = (midilink == 6) ? 2 : (midilink > 3) ? 0 : midilink;\n\t\t\t\t\t\tSetMidiLinkMode(midilink);\n\t\t\t\t\t\tSetUARTMode(menusub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmenustate = MENU_UART1;\n\t\t\t\tmenusub = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_SFONT_FILE_SELECTED:\n\t\t{\n\t\t\tprintf(\"MENU_SFONT_FILE_SELECTED --> '%s'\\n\", selPath);\n\t\t\tsnprintf(Selected_tmp, sizeof(Selected_tmp), \"/sbin/mlinkutil FSSFONT /media/fat/\\\"%s\\\"\", selPath);\n\t\t\tsystem(Selected_tmp);\n\t\t\tAdjustDirectory(selPath);\n\t\t\t// MENU_FILE_SELECT1 to file select OSD\n\t\t\tmenustate = MENU_UART1; //MENU_FILE_SELECT1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_BAUD1:\n\t\t{\n\t\t\thelptext_idx = 0;\n\t\t\tOsdSetTitle(\"UART Baud Rate\");\n\t\t\tmenustate = MENU_BAUD2;\n\t\t\tparentstate = MENU_BAUD1;\n\n\t\t\tm = 0;\n\t\t\tmenumask = 0;\n\t\t\tint mode = GetUARTMode();\n\t\t\tconst uint32_t *bauds = GetUARTbauds(mode);\n\t\t\tfor (uint32_t i = 0; i < 13; i++)\n\t\t\t{\n\t\t\t\tif (!bauds[i]) break;\n\t\t\t\tmenumask |= 1 << i;\n\t\t\t\tm = i;\n\t\t\t}\n\n\t\t\tuint32_t start = (16 - m)/2;\n\t\t\tuint32_t k = 0;\n\t\t\twhile (k < start) OsdWrite(k++);\n\n\t\t\tfor (uint32_t i = 0; i < 13; i++)\n\t\t\t{\n\t\t\t\tif (!bauds[i]) break;\n\n\t\t\t\tsprintf(s, \" %s\", GetUARTbaud_label(mode, i));\n\t\t\t\tOsdWrite(k++, s, menusub == i, 0);\n\t\t\t}\n\n\t\t\twhile (k < 15) OsdWrite(k++);\n\t\t\tm++;\n\t\t\tmenumask |= 1 << m;\n\t\t\tOsdWrite(15, STD_EXIT, menusub == m);\n\t\t}\n\t\tbreak;\n\n\tcase MENU_BAUD2:\n\t\t{\n\t\t\tif (menu)\n\t\t\t{\n\t\t\t\tmenustate = MENU_UART1;\n\t\t\t\tmenusub = 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (select)\n\t\t\t{\n\t\t\t\tconst uint32_t *bauds = GetUARTbauds(GetUARTMode());\n\t\t\t\tfor (uint32_t i = 0; i < 13; i++)\n\t\t\t\t{\n\t\t\t\t\tif (!bauds[i]) break;\n\t\t\t\t\tif (menusub == i)\n\t\t\t\t\t{\n\t\t\t\t\t\tValidateUARTbaud(GetUARTMode(), bauds[i]);\n\t\t\t\t\t\tif (GetUARTMode() >= 3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(s, \"/sbin/mlinkutil BAUD %d\", GetUARTbaud(GetUARTMode()));\n\t\t\t\t\t\t\tsystem(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint mode = GetUARTMode();\n\t\t\t\t\t\t\tSetUARTMode(0);\n\t\t\t\t\t\t\tSetUARTMode(mode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmenusub = 5;\n\t\t\t\tmenustate = MENU_UART1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_AFILTER_FILE_SELECTED:\n\t\t{\n\t\t\tchar *p = strcasestr(selPath, AFILTER_DIR\"/\");\n\t\t\tif (!p) audio_set_filter(selPath);\n\t\t\telse\n\t\t\t{\n\t\t\t\tp += strlen(AFILTER_DIR);\n\t\t\t\twhile (*p == '/') p++;\n\t\t\t\taudio_set_filter(p);\n\t\t\t}\n\t\t\tmenustate = MENU_COMMON1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_COEFF_FILE_SELECTED:\n\t\t{\n\t\t\tchar *p = strcasestr(selPath, COEFF_DIR\"/\");\n\t\t\tif (!p) video_set_scaler_coeff(vfilter_type, selPath);\n\t\t\telse\n\t\t\t{\n\t\t\t\tp += strlen(COEFF_DIR);\n\t\t\t\twhile (*p == '/') p++;\n\t\t\t\tvideo_set_scaler_coeff(vfilter_type, p);\n\t\t\t}\n\t\t\tmenustate = MENU_VIDEOPROC1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_GAMMA_FILE_SELECTED:\n\t\t{\n\t\t\tchar *p = strcasestr(selPath, GAMMA_DIR\"/\");\n\t\t\tif (!p) video_set_gamma_curve(selPath);\n\t\t\telse\n\t\t\t{\n\t\t\t\tp += strlen(GAMMA_DIR);\n\t\t\t\twhile (*p == '/') p++;\n\t\t\t\tvideo_set_gamma_curve(p);\n\t\t\t}\n\t\t\tmenustate = MENU_VIDEOPROC1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_SMASK_FILE_SELECTED:\n\t\t{\n\t\t\tchar *p = strcasestr(selPath, SMASK_DIR\"/\");\n\t\t\tif (!p) video_set_shadow_mask(selPath);\n\t\t\telse\n\t\t\t{\n\t\t\t\tp += strlen(SMASK_DIR);\n\t\t\t\twhile (*p == '/') p++;\n\t\t\t\tvideo_set_shadow_mask(p);\n\t\t\t}\n\t\t\tmenustate = MENU_VIDEOPROC1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_PRESET_FILE_SELECTED:\n\t\tmemcpy(Selected_F[15], selPath, sizeof(Selected_F[15]));\n\t\trecent_update(SelectedDir, selPath, SelectedLabel, 15);\n\t\tvideo_loadPreset(selPath, true);\n\t\tmenustate = MENU_VIDEOPROC1;\n\t\tbreak;\n\n\tcase MENU_MISC1:\n\t\tOsdSetSize(16);\n\t\thelptext_idx = 0;\n\t\tmenumask = 0xF;\n\t\tmenustate = MENU_MISC2;\n\t\tsysinfo_timer = 0; // force refresh\n\t\tOsdSetTitle(\"Misc. Options\", OSD_ARROW_RIGHT);\n\n\t\tif (parentstate != MENU_MISC1)\n\t\t{\n\t\t\tfor (int i = 0; i < OsdGetSize() - 1; i++) OsdWrite(i, \"\", 0, 0);\n\t\t\tflag = 1;\n\t\t\tfor (int i = 1; i < 4; i++) if (FileExists(cfg_get_name(i))) flag |= 1 << i;\n\t\t\tflag |= altcfg() << 4;\n\t\t\tmenusub = 3;\n\t\t}\n\t\tparentstate = MENU_MISC1;\n\n\t\tOsdWrite(1, \"         Information\");\n\n\t\tif (menusub != 0) flag = (flag & 0xF) | (altcfg() << 4);\n\t\tstrcpy(s, \" Config:\");\n\t\tm = 0;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint en = flag & (1 << i);\n\t\t\tif (i == (flag >> 4) && en) strcat(s, \"\\xc\");\n\t\t\tstrcat(s, \" \");\n\t\t\tif (m) strcat(s, \"\\xc \");\n\t\t\tm = (i == (flag >> 4) && en);\n\t\t\tif (!en) strcat(s, \"\\xb\");\n\t\t\tstrcat(s, cfg_get_label(i));\n\t\t\tif (!en) strcat(s, \"\\xb\");\n\t\t}\n\t\tstrcat(s, \" \");\n\t\tif (m) strcat(s, \"\\xc\");\n\t\tOsdWrite(10, s, menusub == 0);\n\n\t\tm = get_core_volume();\n\t\t{\n\t\t\tstrcpy(s, \"     Core Volume: \");\n\t\t\tif (audio_filter_en() >= 0) s[4] = 0x1b;\n\t\t\tmemset(s + strlen(s), 0, 10);\n\t\t\tchar *bar = s + strlen(s);\n\t\t\tmemset(bar, 0x8C, 8);\n\t\t\tmemset(bar, 0x7f, 8 - m);\n\t\t}\n\t\tOsdWrite(12, s, menusub == 1);\n\n\t\told_volume = get_volume();\n\t\tstrcpy(s, \"   Global Volume: \");\n\t\tif (old_volume & 0x10)\n\t\t{\n\t\t\tstrcat(s, \"< Mute >\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(s+strlen(s), 0, 10);\n\t\t\tchar *bar = s + strlen(s);\n\t\t\tint vol = (audio_filter_en() < 0) ? get_core_volume() : 0;\n\t\t\tmemset(bar, 0x8C, 8 - vol);\n\t\t\tmemset(bar, 0x7f, 8 - vol - old_volume);\n\t\t}\n\t\tOsdWrite(13, s, menusub == 2);\n\n\t\tOsdWrite(15, STD_EXIT, menusub == 3, 0, OSD_ARROW_RIGHT);\n\t\tbreak;\n\n\tcase MENU_MISC2:\n\t\tprintSysInfo();\n\t\tif ((select && menusub == 3) || menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (menusub == 0 && (right || left || minus || plus || select))\n\t\t{\n\t\t\tuint8_t i = flag >> 4;\n\t\t\tif (select)\n\t\t\t{\n\t\t\t\tuser_io_set_ini(i);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (right || plus) i = (i + 1) & 3;\n\t\t\t\t\telse i = (i - 1) & 3;\n\t\t\t\t} while (!(flag & (1 << i)));\n\n\t\t\t\tflag = (flag & 0xF) | (i << 4);\n\t\t\t}\n\t\t\tmenustate = MENU_MISC1;\n\t\t}\n\t\telse if(menusub == 1 && (right || left || minus || plus))\n\t\t{\n\t\t\tset_core_volume((right || plus) ? 1 : -1);\n\t\t\tmenustate = MENU_MISC1;\n\t\t}\n\t\telse if (menusub == 2 && (right || left || minus || plus || select))\n\t\t{\n\t\t\tset_volume((right || plus) ? 1 : (left || minus) ? -1 : 0);\n\t\t\tmenustate = MENU_MISC1;\n\t\t}\n\t\telse if (right)\n\t\t{\n\t\t\t// go back to core requesting this menu\n\t\t\tswitch (user_io_core_type())\n\t\t\t{\n\t\t\tcase CORE_TYPE_8BIT:\n\t\t\t\tif (is_menu())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 4;\n\t\t\t\t\tmenustate = MENU_SYSTEM1;\n\t\t\t\t}\n\t\t\t\telse if (is_minimig())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\t}\n\t\t\t\telse if (is_archie())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_ARCHIE_MAIN1;\n\t\t\t\t}\n\t\t\t\telse if (is_st())\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CORE_TYPE_SHARPMZ:\n\t\t\t\tmenusub = menusub_last;\n\t\t\t\tmenustate = sharpmz_default_ui_state();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tm = get_volume();\n\t\tif (old_volume != m)\n\t\t{\n\t\t\told_volume = m;\n\t\t\tmenustate = MENU_MISC1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_JOYRESET:\n\t\tOsdWrite(3);\n\t\tOsdWrite(4, \"       Reset to default\");\n\t\tOsdWrite(5);\n\t\tmenustate = MENU_JOYRESET1;\n\t\tbreak;\n\n\tcase MENU_JOYRESET1:\n\t\tif (!user_io_user_button())\n\t\t{\n\t\t\tfinish_map_setting(2);\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_JOYDIGMAP:\n\t\thelptext_idx = 0;\n\t\tmenumask = 1;\n\t\tOsdSetTitle(\"Define buttons\", 0);\n\t\tmenustate = MENU_JOYDIGMAP1;\n\t\tparentstate = MENU_JOYDIGMAP;\n\t\tflash_timer = 0;\n\t\tflash_state = 0;\n\t\tfor (int i = 0; i < OsdGetSize(); i++) OsdWrite(i);\n\t\tif (is_menu())\n\t\t{\n\t\t\tOsdWrite(8, \"          Esc \\x16 Cancel\");\n\t\t\tOsdWrite(9, \"        Enter \\x16 Finish\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOsdWrite(8, \"    Menu-hold \\x16 Cancel\");\n\t\t\tOsdWrite(9, \"        Enter \\x16 Finish\");\n\t\t}\n\t\tbreak;\n\n\tcase MENU_JOYDIGMAP1:\n\t\t{\n\t\t\tint line_info = 0;\n\t\t\tif (get_map_clear())\n\t\t\t{\n\t\t\t\tOsdWrite(3);\n\t\t\t\tOsdWrite(4, \"          Clearing\");\n\t\t\t\tOsdWrite(5);\n\t\t\t\tjoymap_first = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (get_map_cancel())\n\t\t\t{\n\t\t\t\tOsdWrite(3);\n\t\t\t\tOsdWrite(4, \"          Canceling\");\n\t\t\t\tOsdWrite(5);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (is_menu() && !get_map_button()) OsdWrite(7);\n\n\t\t\tconst char* p = 0;\n\t\t\tif (get_map_button() < 0)\n\t\t\t{\n\t\t\t\tstrcpy(s, joy_ana_map[get_map_button() + 6]);\n\t\t\t\tOsdWrite(7, \"   Space/User \\x16 Skip\");\n\t\t\t}\n\t\t\telse if (get_map_button() < DPAD_NAMES)\n\t\t\t{\n\t\t\t\tp = joy_button_map[get_map_button()];\n\t\t\t}\n\t\t\telse if (joy_bcount)\n\t\t\t{\n\t\t\t\tp = joy_bnames[get_map_button() - DPAD_NAMES];\n\t\t\t\tif (is_menu())\n\t\t\t\t{\n\t\t\t\t\tif (!get_map_type()) joy_bcount = 17;\n\t\t\t\t\tif (get_map_button() == SYS_BTN_OSD_KTGL)\n\t\t\t\t\t{\n\t\t\t\t\t\tp = joy_button_map[DPAD_BUTTON_NAMES + get_map_type()];\n\t\t\t\t\t\tif (get_map_type())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOsdWrite(12, \"   (can use 2-button combo)\");\n\t\t\t\t\t\t\tline_info = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp = (get_map_button() < DPAD_BUTTON_NAMES) ? joy_button_map[get_map_button()] : joy_button_map[DPAD_BUTTON_NAMES + get_map_type()];\n\t\t\t}\n\n\t\t\tif (get_map_button() >= 0)\n\t\t\t{\n\t\t\t\tif (is_menu() && get_map_button() > SYS_BTN_CNT_ESC)\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, joy_button_map[(get_map_button() - SYS_BTN_CNT_ESC - 1) + DPAD_BUTTON_NAMES + 2]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts[0] = 0;\n\t\t\t\t\tint len = (30 - (strlen(p) + 7)) / 2;\n\t\t\t\t\twhile (len > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcat(s, \" \");\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\n\t\t\t\t\tstrcat(s, \"Press: \");\n\t\t\t\t\tstrcat(s, p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOsdWrite(3, s, 0, 0);\n\t\t\tOsdWrite(4);\n\n\t\t\tif(is_menu() && joy_bcount && get_map_button() >= SYS_BTN_RIGHT && get_map_button() <= SYS_BTN_START)\n\t\t\t{\n\t\t\t\t// draw an on-screen gamepad to help with central button mapping\n\t\t\t\tif (!flash_timer || CheckTimer(flash_timer))\n\t\t\t\t{\n\t\t\t\t\tflash_timer = GetTimer(100);\n\t\t\t\t\tif (flash_state)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (get_map_button())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase SYS_BTN_L:      OsdWrite(10, \"  \\x86   \\x88               \\x86 R \\x88  \"); break;\n\t\t\t\t\t\t\tcase SYS_BTN_R:      OsdWrite(10, \"  \\x86 L \\x88               \\x86   \\x88  \"); break;\n\t\t\t\t\t\t\tcase SYS_BTN_UP:     OsdWrite(12, \" \\x83                     X   \\x83\");        break;\n\t\t\t\t\t\t\tcase SYS_BTN_X:      OsdWrite(12, \" \\x83   U                     \\x83\");        break;\n\t\t\t\t\t\t\tcase SYS_BTN_A:      OsdWrite(13, \" \\x83 L \\x1b R  Sel Start  Y     \\x83\");     break;\n\t\t\t\t\t\t\tcase SYS_BTN_Y:      OsdWrite(13, \" \\x83 L \\x1b R  Sel Start      A \\x83\");     break;\n\t\t\t\t\t\t\tcase SYS_BTN_LEFT:   OsdWrite(13, \" \\x83   \\x1b R  Sel Start  Y   A \\x83\");     break;\n\t\t\t\t\t\t\tcase SYS_BTN_RIGHT:  OsdWrite(13, \" \\x83 L \\x1b    Sel Start  Y   A \\x83\");     break;\n\t\t\t\t\t\t\tcase SYS_BTN_SELECT: OsdWrite(13, \" \\x83 L \\x1b R      Start  Y   A \\x83\");     break;\n\t\t\t\t\t\t\tcase SYS_BTN_START:  OsdWrite(13, \" \\x83 L \\x1b R  Sel        Y   A \\x83\");     break;\n\t\t\t\t\t\t\tcase SYS_BTN_DOWN:   OsdWrite(14, \" \\x83       \\x86\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x88   B   \\x83\"); break;\n\t\t\t\t\t\t\tcase SYS_BTN_B:      OsdWrite(14, \" \\x83   D   \\x86\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x88       \\x83\"); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOsdWrite(10, \"  \\x86 L \\x88               \\x86 R \\x88  \");\n\t\t\t\t\t\tOsdWrite(11, \" \\x86\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x88\");\n\t\t\t\t\t\tOsdWrite(12, \" \\x83   U                 X   \\x83\");\n\t\t\t\t\t\tOsdWrite(13, \" \\x83 L \\x1b R  Sel Start  Y   A \\x83\");\n\t\t\t\t\t\tOsdWrite(14, \" \\x83   D   \\x86\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x88   B   \\x83\");\n\t\t\t\t\t\tOsdWrite(15, \" \\x8b\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x8a         \\x8b\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x8a\");\n\t\t\t\t\t}\n\t\t\t\t\tflash_state = !flash_state;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(flash_timer)\n\t\t\t\t{\n\t\t\t\t\t//clear all gamepad gfx\n\t\t\t\t\tOsdWrite(10);\n\t\t\t\t\tOsdWrite(11);\n\t\t\t\t\tOsdWrite(12);\n\t\t\t\t\tOsdWrite(13);\n\t\t\t\t\tOsdWrite(14);\n\t\t\t\t\tOsdWrite(15);\n\t\t\t\t\tflash_timer = 0;\n\t\t\t\t}\n\n\t\t\t\tif (!line_info) OsdWrite(12);\n\t\t\t}\n\n\t\t\tif (get_map_vid() || get_map_pid())\n\t\t\t{\n\t\t\t\tif (!is_menu() && get_map_type() && !has_default_map() && !get_map_set())\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < OsdGetSize(); i++) OsdWrite(i);\n\t\t\t\t\tOsdWrite(6, \"   You need to define this\");\n\t\t\t\t\tOsdWrite(7, \" joystick in Menu core first\");\n\t\t\t\t\tOsdWrite(9, \"      Press ESC/Enter\");\n\t\t\t\t\tfinish_map_setting(1);\n\t\t\t\t\tmenustate = MENU_JOYDIGMAP2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(s, \"   %s ID: %04x:%04x\", get_map_type() ? \"Joystick\" : \"Keyboard\", get_map_vid(), get_map_pid());\n\t\t\t\t\tif (get_map_button() > 0 || !joymap_first)\n\t\t\t\t\t{\n\t\t\t\t\t\tOsdWrite(7, (!get_map_type()) ? \"         User \\x16 Undefine\" :\n\t\t\t\t\t\t\tis_menu() ? \"   User/Space \\x16 Undefine\" : \"    User/Menu \\x16 Undefine\");\n\n\t\t\t\t\t\tif (!get_map_type()) OsdWrite(9);\n\t\t\t\t\t}\n\t\t\t\t\tOsdWrite(5, s);\n\t\t\t\t\tif (!is_menu()) OsdWrite(10, \"          F12 \\x16 Clear all\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!is_menu() && (get_map_button() >= (joy_bcount ? joy_bcount + 4 : 8) || (select & get_map_vid() & get_map_pid())) && joymap_first && get_map_type())\n\t\t\t{\n\t\t\t\tfinish_map_setting(0);\n\t\t\t\tmenustate = MENU_JOYDIGMAP3;\n\t\t\t\tmenusub = 0;\n\t\t\t}\n\t\t\telse if (select || menu || get_map_button() >= (joy_bcount ? joy_bcount + 4 : 8))\n\t\t\t{\n\t\t\t\tfinish_map_setting(menu);\n\t\t\t\tif (is_menu())\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_SYSTEM1;\n\t\t\t\t\tmenusub = 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t\t\tmenusub = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_JOYDIGMAP2:\n\t\tif (select || menu)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 2;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_JOYDIGMAP3:\n\t\tfor (int i = 0; i < OsdGetSize(); i++) OsdWrite(i);\n\t\tm = 6;\n\t\tmenumask = 3;\n\t\tOsdWrite(m++, \"    Do you want to setup\");\n\t\tOsdWrite(m++, \"    alternative buttons?\");\n\t\tOsdWrite(m++, \"           No\", menusub == 0);\n\t\tOsdWrite(m++, \"           Yes\", menusub == 1);\n\t\tparentstate = menustate;\n\t\tmenustate = MENU_JOYDIGMAP4;\n\t\tbreak;\n\n\tcase MENU_JOYDIGMAP4:\n\t\tif (menu)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 2;\n\t\t\tbreak;\n\t\t}\n\t\telse if (select)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tmenustate = MENU_COMMON1;\n\t\t\t\tmenusub = 2;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tstart_map_setting(joy_bcount ? joy_bcount + 4 : 8, 1);\n\t\t\t\tmenustate = MENU_JOYDIGMAP;\n\t\t\t\tmenusub = 0;\n\t\t\t\tjoymap_first = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_JOYKBDMAP:\n\t\thelptext_idx = 0;\n\t\tmenumask = 1;\n\t\tmenustate = MENU_JOYKBDMAP1;\n\t\tparentstate = MENU_JOYKBDMAP;\n\n\t\tOsdSetTitle(\"Button/Key remap\", 0);\n\t\tfor (int i = 0; i < 5; i++) OsdWrite(i, \"\", 0, 0);\n\t\tOsdWrite(5, info_top, 0, 0);\n\t\tinfowrite(6, \"Supported mapping:\");\n\t\tinfowrite( 7, \"\");\n\t\tinfowrite( 8, \"Button -> Key\");\n\t\tinfowrite( 9, \"Button -> Button same pad\");\n\t\tinfowrite(10, \"Key -> Key\");\n\t\tinfowrite(11, \"\");\n\t\tinfowrite(12, \"     Menu \\x16 Finish \");\n\t\tinfowrite(13, \"Menu-hold \\x16 Clear  \");\n\t\tOsdWrite(14, info_bottom, 0, 0);\n\t\tOsdWrite(OsdGetSize() - 1, \"           Cancel\", menusub == 0, 0);\n\t\tbreak;\n\n\tcase MENU_JOYKBDMAP1:\n\t\tif (!get_map_button())\n\t\t{\n\t\t\tOsdWrite(1, \" Press button/key to change\", 0, 0);\n\t\t\tif (get_map_vid())\n\t\t\t{\n\t\t\t\tOsdWrite(2, \"\", 0, 0);\n\t\t\t\tsprintf(s, \"    on device %04x:%04x\", get_map_vid(), get_map_pid());\n\t\t\t\tOsdWrite(3, s, 0, 0);\n\t\t\t}\n\t\t\tOsdWrite(OsdGetSize() - 1, \" Enter \\x16 Finish, Esc \\x16 Clear\", menusub == 0, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (get_map_button() <= 256)\n\t\t\t{\n\t\t\t\tOsdWrite(1, \"     Press key to map to\", 0, 0);\n\t\t\t\tOsdWrite(2, \"\", 0, 0);\n\t\t\t\tOsdWrite(3, \"        on a keyboard\", 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOsdWrite(1, \"   Press button to map to\", 0, 0);\n\t\t\t\tOsdWrite(2, \"      on the same pad\", 0, 0);\n\t\t\t\tOsdWrite(3, \"    or key on a keyboard\", 0, 0);\n\t\t\t}\n\t\t\tOsdWrite(OsdGetSize() - 1);\n\t\t}\n\n\t\tif (select || menu || get_map_finish() || get_map_cancel())\n\t\t{\n\t\t\tint clear = get_map_vid() && (menu || get_map_cancel());\n\t\t\tfinish_map_setting(clear);\n\t\t\tmenu_timeout = GetTimer(1000);\n\t\t\tOsdWrite(1);\n\t\t\tOsdWrite(2, clear ? \"          Clearing\" : \"          Finishing\");\n\t\t\tOsdWrite(3);\n\t\t\tOsdWrite(OsdGetSize() - 1);\n\t\t\tmenustate = MENU_JOYKBDMAP2;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_JOYKBDMAP2:\n\t\tif (CheckTimer(menu_timeout))\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 3;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ABOUT1:\n\t\tOsdSetSize(16);\n\t\tmenumask = 0;\n\t\thelptext_idx = 0;\n\t\tOsdSetTitle(\"About\", 0);\n\t\tmenustate = MENU_ABOUT2;\n\t\tparentstate = MENU_ABOUT1;\n\t\tStarsInit();\n\t\tScrollReset();\n\t\tfor (int i = 5; i < OsdGetSize(); i++) OsdWrite(i, \"\", 0, 0);\n\t\tbreak;\n\n\tcase MENU_ABOUT2:\n\t\tStarsUpdate();\n\t\tm = 0;\n\t\twhile (m < 10) OsdDrawLogo(m++);\n\t\tOsdWrite(m++, \"     www.MiSTerFPGA.org\", 0, 0, 1);\n\t\tOsdWrite(m++, \"\", 0, 0, 1);\n\t\tsprintf(s, \"       MiSTer v%s\", version + 5);\n\t\tOsdWrite(m++, s, 0, 0, 1);\n\n\t\ts[0] = 0;\n\t\t{\n\t\t\tint len = strlen(OsdCoreNameGet());\n\t\t\tif (len > 30) len = 30;\n\t\t\tint sp = (30 - len) / 2;\n\t\t\tfor (int i = 0; i < sp; i++) strcat(s, \" \");\n\t\t\tchar *s2 = s + strlen(s);\n\t\t\tchar *s3 = OsdCoreNameGet();\n\t\t\tfor (int i = 0; i < len; i++) *s2++ = *s3++;\n\t\t\t*s2++ = 0;\n\t\t}\n\t\tOsdWrite(m++, s, 0, 0, 1);\n\t\tOsdWrite(m++, \"\", 0, 0, 1);\n\t\tScrollText(m++, \"                                 MiSTer by Alexey Melnikov, based on MiST by Till Harbaum, Minimig by Dennis van Weeren and other projects. MiSTer hardware and software is distributed under the terms of the GNU General Public License version 3. MiSTer FPGA cores are the work of their respective authors under individual licensing. Go to www.MiSTerFPGA.org for more details.\", 0, 0, 0, 0);\n\n\t\tif (menu | select | left)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 16;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_UNLOCK1:\n\t\tOsdSetSize(8);\n\t\tmenumask = 0;\n\t\thelptext_idx = 0;\n\t\tmenustate = MENU_UNLOCK2;\n\t\tparentstate = MENU_UNLOCK1;\n\t\tOsdEnable(DISABLE_KEYBOARD);\n\t\tOsdSetTitle(\"Locked\", 0);\n\t\tfor (int r = 0; r < OsdGetSize(); r++) OsdWrite(r);\n\t\t{\n\t\t\tif (strlen(osd_code_entry) >= strlen(cfg.osd_lock))\n\t\t\t{\n\t\t\t\tlock_pass_timeout = GetTimer(200);\n\t\t\t\tmenustate = MENU_UNLOCK3;\n\t\t\t}\n\n\t\t\tint maxlen = strlen(cfg.osd_lock);\n\t\t\tint count = strlen(osd_code_entry);\n\n\t\t\tm = 2;\n\t\t\tOsdWrite(m++, \"      Enter unlock code\", 0, 0, 1);\n\t\t\tOsdWrite(m++, \"\", 0, 0, 1);\n\t\t\tOsdWrite(m++, \"\", 0, 0, 1);\n\n\t\t\tint i;\n\t\t\tfor (i = 0; i < (29 - maxlen) / 2; i++) s[i] = ' ';\n\t\t\tfor (int j = 0; j < maxlen; j++, i++) s[i] = j < count ? 0x7F : 0x8C;\n\n\t\t\ts[i] = '\\0';\n\t\t\tOsdWrite(m++, s, 0, 0, 1);\n\t\t\tOsdUpdate();\n\t\t}\n\t\tbreak;\n\n\tcase MENU_UNLOCK2:\n\t\t{\n\t\t\tconst char *append = \"\";\n\t\t\tif (up) append = \"U\";\n\t\t\telse if (down) append = \"D\";\n\t\t\telse if (left) append = \"L\";\n\t\t\telse if (right) append = \"R\";\n\t\t\telse if (select) append = \"A\";\n\t\t\telse if (back) append = \"B\";\n\t\t\telse if (menu) menustate = MENU_NONE1;\n\n\t\t\tif (append[0])\n\t\t\t{\n\t\t\t\tstrcat(osd_code_entry, append);\n\t\t\t\tmenustate = MENU_UNLOCK1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_UNLOCK3:\n\t\tif (CheckTimer(lock_pass_timeout))\n\t\t{\n\t\t\tif (!strcmp(osd_code_entry, cfg.osd_lock))\n\t\t\t{\n\t\t\t\tosd_unlocked = 1;\n\t\t\t\tosd_lock_timer = GetTimer(cfg.osd_lock_time * 1000);\n\t\t\t\tmenustate = MENU_NONE2;\n\t\t\t\tmenu_key_set(KEY_F12);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmenustate = MENU_UNLOCK1;\n\t\t\t\tosd_code_entry[0] = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* st main menu                                                 */\n\t\t/******************************************************************/\n\n\tcase MENU_ST_MAIN1:\n\t\tOsdSetSize(16);\n\t\tmenumask = 0xeff;\n\t\tOsdSetTitle(\"AtariST\", 0);\n\t\tfirstmenu = 0;\n\t\tm = 0;\n\n\t\tfor (uint32_t i = 0; i < 2; i++)\n\t\t{\n\t\t\tsnprintf(s, 29, \" %c: %s%s\", 'A' + i, (tos_system_ctrl() & (TOS_CONTROL_FDC_WR_PROT_A << i)) ? \"\\x17\" : \"\", tos_get_disk_name(i));\n\t\t\tOsdWrite(m++, s, menusub == i, 0);\n\t\t}\n\t\tstrcpy(s, \" Write protect:  \");\n\t\tstrcat(s, config_tos_wrprot[(tos_system_ctrl() >> 6) & 3]);\n\t\tOsdWrite(m++, s, menusub == 2, 0);\n\t\tOsdWrite(m++);\n\n\t\tsnprintf(s, 29, \" Cart: %s\", tos_get_cartridge_name());\n\t\tMenuWrite(m++, s, menusub == 3, !!(tos_system_ctrl() & TOS_CONTROL_DONGLE));\n\t\tMenuWrite(m++);\n\n\t\tsnprintf(s, 29, \" Joysticks swap: %s\", user_io_get_joyswap() ? \"Yes\" : \"No\");\n\t\tOsdWrite(m++, s, menusub == 4);\n\t\tOsdWrite(m++);\n\n\t\tOsdWrite(m++, \" Modify config             \\x16\", menusub == 5);\n\t\tOsdWrite(m++, \" Load config               \\x16\", menusub == 6);\n\t\tOsdWrite(m++, \" Save config               \\x16\", menusub == 7);\n\n\t\tif (spi_uio_cmd16(UIO_GET_OSDMASK, 0) & 1)\n\t\t{\n\t\t\tmenumask |= 0x100;\n\t\t\tOsdWrite(m++, \" MT32-pi                   \\x16\", menusub == 8);\n\t\t}\n\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \" Reset\", menusub == 9);\n\t\tOsdWrite(m++, \" Cold Boot\", menusub == 10);\n\n\t\tfor (; m < OsdGetSize()-1; m++) OsdWrite(m);\n\t\tOsdWrite(15, STD_EXIT, menusub == 11, 0, OSD_ARROW_RIGHT | OSD_ARROW_LEFT);\n\n\t\tmenustate = MENU_ST_MAIN2;\n\t\tparentstate = MENU_ST_MAIN1;\n\t\tbreak;\n\n\tcase MENU_ST_MAIN2:\n\t\t// menu key closes menu\n\t\tif (menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\telse if (right)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 0;\n\t\t}\n\t\telse if (left)\n\t\t{\n\t\t\tmenustate = MENU_MISC1;\n\t\t\tmenusub = 3;\n\t\t}\n\t\telse if (menusub <= 1 && (select || recent))\n\t\t{\n\t\t\tif (tos_disk_is_inserted(menusub))\n\t\t\t{\n\t\t\t\ttos_insert_disk(menusub, \"\");\n\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfs_Options = SCANO_DIR;\n\t\t\t\tfs_MenuSelect = MENU_ST_FDD_FILE_SELECTED;\n\t\t\t\tfs_MenuCancel = MENU_ST_MAIN1;\n\t\t\t\tstrcpy(fs_pFileExt, \"ST\");\n\t\t\t\tif (select) SelectFile(Selected_F[menusub], \"ST\", fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\t\telse if (recent_init(menusub)) menustate = MENU_RECENT1;\n\t\t\t}\n\t\t}\n\t\telse if (select || minus || plus)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 2:\n\t\t\t\t// remove current write protect bits and increase by one\n\t\t\t\ttos_update_sysctrl((tos_system_ctrl() & ~(TOS_CONTROL_FDC_WR_PROT_A | TOS_CONTROL_FDC_WR_PROT_B))\n\t\t\t\t\t| (((((tos_system_ctrl() >> 6) & 3) + (minus ? -1 : 1)) & 3) << 6));\n\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tif (!(tos_system_ctrl() & TOS_CONTROL_DONGLE))\n\t\t\t\t{\n\t\t\t\t\tif (tos_cartridge_is_inserted())\n\t\t\t\t\t{\n\t\t\t\t\t\ttos_load_cartridge(\"\");\n\t\t\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfs_Options = SCANO_DIR;\n\t\t\t\t\t\tfs_MenuSelect = MENU_ST_SYSTEM_FILE_SELECTED;\n\t\t\t\t\t\tfs_MenuCancel = MENU_ST_MAIN1;\n\t\t\t\t\t\tstrcpy(fs_pFileExt, \"STC\");\n\t\t\t\t\t\tif (select) SelectFile(Selected_F[menusub], fs_pFileExt, fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\t\t\t\telse if (recent_init(menusub)) menustate = MENU_RECENT1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tuser_io_set_joyswap(!user_io_get_joyswap());\n\t\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 5:  // System submenu\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\t\tneed_reset = 0;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 6:  // Load config\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_ST_LOAD_CONFIG1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 7:  // Save config\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_ST_SAVE_CONFIG1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 9:  // Reset\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\ttos_reset(0);\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 10:  // Cold Boot\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\ttos_insert_disk(0, \"\");\n\t\t\t\t\ttos_insert_disk(1, \"\");\n\t\t\t\t\ttos_reset(1);\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 11:  // Exit\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ST_FDD_FILE_SELECTED:\n\t\tmemcpy(Selected_F[menusub], selPath, sizeof(Selected_F[menusub]));\n\t\trecent_update(SelectedDir, selPath, SelectedLabel, menusub);\n\t\ttos_insert_disk(menusub, selPath);\n\t\tmenustate = MENU_ST_MAIN1;\n\t\tbreak;\n\n\tcase MENU_ST_SYSTEM1:\n\t\tmenumask = 0x1fffb;\n\t\tOsdSetTitle(\"Config\", 0);\n\t\thelptext_idx = 0;\n\n\t\twhile (1)\n\t\t{\n\t\t\tif (!menusub) firstmenu = 0;\n\t\t\tadjvisible = 0;\n\t\t\tm = 0;\n\n\t\t\tfor (uint32_t i = 0; i < 2; i++)\n\t\t\t{\n\t\t\t\tsnprintf(s, 29, \" HDD%d: %s\", i, tos_get_disk_name(2 + i));\n\t\t\t\tMenuWrite(m++, s, menusub == i);\n\t\t\t}\n\t\t\tMenuWrite(m++);\n\n\t\t\tstrcpy(s, \" Memory:     \");\n\t\t\tstrcat(s, tos_mem[(tos_system_ctrl() >> 1) & 7]);\n\t\t\tMenuWrite(m++, s, menusub == 3);\n\n\t\t\tsnprintf(s, 29, \" TOS:        %s\", tos_get_image_name());\n\t\t\tMenuWrite(m++, s, menusub == 4);\n\n\t\t\tstrcpy(s, \" Chipset:    \");\n\t\t\t// extract  TOS_CONTROL_STE and  TOS_CONTROL_MSTE bits\n\t\t\tstrcat(s, tos_chipset[(tos_system_ctrl() >> 23) & 3]);\n\t\t\tMenuWrite(m++, s, menusub == 5);\n\t\t\tMenuWrite(m++);\n\n\t\t\t// Blitter is always present in >= STE\n\t\t\tenable = (tos_system_ctrl() & (TOS_CONTROL_STE | TOS_CONTROL_MSTE)) ? 1 : 0;\n\t\t\tstrcpy(s, \" Blitter:    \");\n\t\t\tstrcat(s, ((tos_system_ctrl() & TOS_CONTROL_BLITTER) || enable) ? \"On\" : \"Off\");\n\t\t\tMenuWrite(m++, s, menusub == 6, enable);\n\n\t\t\t// Viking card can only be enabled with max 8MB RAM\n\t\t\tenable = (tos_system_ctrl() & 0xe) <= TOS_MEMCONFIG_8M;\n\t\t\tstrcpy(s, \" Viking:     \");\n\t\t\tstrcat(s, ((tos_system_ctrl() & TOS_CONTROL_VIKING) && enable) ? \"On\" : \"Off\");\n\t\t\tMenuWrite(m++, s, menusub == 7, enable ? 0 : 1);\n\n\t\t\tstrcpy(s, \" Aspect:     \");\n\t\t\ttos_set_ar(get_ar_name(tos_get_ar(), s));\n\t\t\tMenuWrite(m++, s, menusub == 8);\n\n\t\t\tstrcpy(s, \" Screen:     \");\n\t\t\tif (tos_system_ctrl() & TOS_CONTROL_VIDEO_COLOR) strcat(s, \"Color\");\n\t\t\telse                                             strcat(s, \"Mono\");\n\t\t\tMenuWrite(m++, s, menusub == 9);\n\n\t\t\tstrcpy(s, \" Mono 60Hz:  \");\n\t\t\tif (tos_system_ctrl() & TOS_CONTROL_MDE60) strcat(s, \"On\");\n\t\t\telse                                       strcat(s, \"Off\");\n\t\t\tMenuWrite(m++, s, menusub == 10);\n\n\t\t\tstrcpy(s, \" Video Crop: \");\n\t\t\tif (tos_system_ctrl() & TOS_CONTROL_BORDER) strcat(s, (tos_get_extctrl() & 0x400) ? \"Visible 216p(5x)\" : \"Visible\");\n\t\t\telse                                        strcat(s, \"Full\");\n\t\t\tMenuWrite(m++, s, menusub == 11);\n\n\t\t\tstrcpy(s, \" Scale:      \");\n\t\t\tstrcat(s, config_scale[(tos_get_extctrl() >> 11) & 3]);\n\t\t\tMenuWrite(m++, s, menusub == 12);\n\n\t\t\tstrcpy(s, \" Scanlines:  \");\n\t\t\tstrcat(s, tos_scanlines[(tos_system_ctrl() >> 20) & 3]);\n\t\t\tMenuWrite(m++, s, menusub == 13);\n\t\t\tMenuWrite(m++);\n\n\t\t\tstrcpy(s, \" Dongle:     \");\n\t\t\tif (tos_system_ctrl() & TOS_CONTROL_DONGLE) strcat(s, \"Cubase\");\n\t\t\telse                                        strcat(s, \"None\");\n\t\t\tMenuWrite(m++, s, menusub == 14);\n\t\t\tMenuWrite(m++);\n\n\t\t\tstrcpy(s, \" YM-Audio:   \");\n\t\t\tstrcat(s, tos_stereo[(tos_system_ctrl() & TOS_CONTROL_STEREO) ? 1 : 0]);\n\t\t\tMenuWrite(m++, s, menusub == 15);\n\t\t\tMenuWrite(m++);\n\n\t\t\tMenuWrite(m++, STD_BACK, menusub == 16);\n\n\t\t\tif (!adjvisible) break;\n\t\t\tfirstmenu += adjvisible;\n\t\t}\n\n\t\tparentstate = menustate;\n\t\tmenustate = MENU_ST_SYSTEM2;\n\t\tbreak;\n\n\tcase MENU_ST_SYSTEM2:\n\t\tsaved_menustate = MENU_ST_SYSTEM1;\n\n\t\tif (menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\telse if (back || left)\n\t\t{\n\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\tmenusub = 5;\n\t\t\tif (need_reset)\n\t\t\t{\n\t\t\t\ttos_reset(1);\n\t\t\t\tsaved_menustate = 0;\n\t\t\t}\n\t\t}\n\t\telse if (menusub <= 2 && (select || recent))\n\t\t{\n\t\t\tif (menusub <= 1)\n\t\t\t{\n\t\t\t\tfs_Options = SCANO_DIR | SCANO_UMOUNT;\n\t\t\t\tfs_MenuSelect = MENU_ST_HDD_FILE_SELECTED;\n\t\t\t\tfs_MenuCancel = MENU_ST_SYSTEM1;\n\t\t\t\tstrcpy(fs_pFileExt, \"VHD\");\n\t\t\t\tif (select) SelectFile(Selected_S[menusub], \"VHD\", fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\t\telse if (recent_init(menusub + 500)) menustate = MENU_RECENT1;\n\t\t\t}\n\t\t}\n\t\telse if (select || plus || minus)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 3:\n\t\t\t\t{\n\t\t\t\t\t// RAM\n\t\t\t\t\tint mem = (tos_system_ctrl() >> 1) & 7;   // current memory config\n\t\t\t\t\tif (minus)\n\t\t\t\t\t{\n\t\t\t\t\t\tmem--;\n\t\t\t\t\t\tif (mem < 0) mem = 5;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmem++;\n\t\t\t\t\t\tif (mem > 5) mem = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttos_update_sysctrl((tos_system_ctrl() & ~0x0e) | (mem << 1));\n\t\t\t\t\tneed_reset = 1;\n\t\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4:  // TOS\n\t\t\t\tif (select) SelectFile(Selected_F[menusub], \"IMG\", SCANO_DIR, MENU_ST_SYSTEM_FILE_SELECTED, MENU_ST_SYSTEM1);\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\t{\n\t\t\t\t\tint chipset = (((tos_system_ctrl() >> 23) + (minus ? -1 : 1)) & 3);\n\t\t\t\t\ttos_update_sysctrl((tos_system_ctrl() & ~(TOS_CONTROL_STE | TOS_CONTROL_MSTE)) | (chipset << 23));\n\t\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tif (!(tos_system_ctrl() & TOS_CONTROL_STE))\n\t\t\t\t{\n\t\t\t\t\ttos_update_sysctrl(tos_system_ctrl() ^ TOS_CONTROL_BLITTER);\n\t\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\t// viking/sm194\n\t\t\t\ttos_update_sysctrl(tos_system_ctrl() ^ TOS_CONTROL_VIKING);\n\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\ttos_set_ar(next_ar(tos_get_ar(), minus));\n\t\t\t\ttos_update_sysctrl(tos_system_ctrl());\n\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\t\ttos_update_sysctrl(tos_system_ctrl() ^ TOS_CONTROL_VIDEO_COLOR);\n\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\ttos_update_sysctrl(tos_system_ctrl() ^ TOS_CONTROL_MDE60);\n\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\tbreak;\n\n\t\t\tcase 11:\n\t\t\t\t{\n\t\t\t\t\tint mode = ((tos_system_ctrl() & TOS_CONTROL_BORDER) ? 1 : 0) | ((tos_get_extctrl() & 0x400) ? 2 : 0);\n\t\t\t\t\tif (minus)\n\t\t\t\t\t{\n\t\t\t\t\t\tmode = (mode == 0) ? 3 : (mode == 3) ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmode = (mode == 0) ? 1 : (mode == 1) ? 3 : 0;\n\t\t\t\t\t}\n\n\t\t\t\t\ttos_update_sysctrl((mode & 1) ? (tos_system_ctrl() | TOS_CONTROL_BORDER) : (tos_system_ctrl() & ~TOS_CONTROL_BORDER));\n\t\t\t\t\ttos_set_extctrl((mode & 2) ? (tos_get_extctrl() | 0x400) : (tos_get_extctrl() & ~0x400));\n\t\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 12:\n\t\t\t\t{\n\t\t\t\t\tint mode = ((tos_get_extctrl() >> 11) + (minus ? -1 : 1)) & 3;\n\t\t\t\t\ttos_set_extctrl((tos_get_extctrl() & ~0x1800) | (mode << 11));\n\t\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 13:\n\t\t\t\t{\n\t\t\t\t\t// next scanline state\n\t\t\t\t\tint scan = ((tos_system_ctrl() >> 20) + (minus ? -1 : 1)) & 3;\n\t\t\t\t\ttos_update_sysctrl((tos_system_ctrl() & ~TOS_CONTROL_SCANLINES) | (scan << 20));\n\t\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 14:\n\t\t\t\ttos_update_sysctrl(tos_system_ctrl() ^ TOS_CONTROL_DONGLE);\n\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\tbreak;\n\n\t\t\tcase 15:\n\t\t\t\ttos_update_sysctrl(tos_system_ctrl() ^ TOS_CONTROL_STEREO);\n\t\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t\t\tbreak;\n\n\n\t\t\tcase 16:\n\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\tmenusub = 5;\n\t\t\t\tif (need_reset)\n\t\t\t\t{\n\t\t\t\t\ttos_reset(1);\n\t\t\t\t\tsaved_menustate = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ST_HDD_FILE_SELECTED:\n\t\tprintf(\"Insert image for disk %d\\n\", menusub);\n\t\tmemcpy(Selected_S[menusub], selPath, sizeof(Selected_S[menusub]));\n\t\trecent_update(SelectedDir, selPath, SelectedLabel, menusub + 500);\n\t\ttos_insert_disk(menusub+2, selPath);\n\t\tmenustate = MENU_ST_SYSTEM1;\n\t\tbreak;\n\n\tcase MENU_ST_SYSTEM_FILE_SELECTED: // file successfully selected\n\t\tif (menusub == 4)\n\t\t{\n\t\t\tmemcpy(Selected_F[menusub], selPath, sizeof(Selected_F[menusub]));\n\t\t\ttos_upload(selPath);\n\t\t\tmenustate = MENU_ST_SYSTEM1;\n\t\t}\n\n\t\tif (menusub == 3)\n\t\t{\n\t\t\tmemcpy(Selected_F[menusub], selPath, sizeof(Selected_F[menusub]));\n\t\t\trecent_update(SelectedDir, selPath, SelectedLabel, menusub);\n\t\t\ttos_load_cartridge(selPath);\n\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ST_LOAD_CONFIG1:\n\t\thelptext_idx = 0;\n\t\tOsdSetTitle(\"Load Config\", 0);\n\n\t\tif (parentstate != menustate)\t// First run?\n\t\t{\n\t\t\tparentstate = menustate;\n\t\t\tmenumask = 0x201;\n\t\t\tfor (uint32_t i = 1; i < 9; i++) if (tos_config_exists(i)) menumask |= 1<<i;\n\t\t}\n\n\t\tm = 0;\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \" Startup config:\");\n\t\tfor (uint32_t i = 0; i < 9; i++)\n\t\t{\n\t\t\tsnprintf(s, 29, \"  %s\", (menumask & (1 << i)) ? tos_get_cfg_string(i) : \"\");\n\t\t\tOsdWrite(m++, s, menusub == i, !(menumask & (1<<i)));\n\t\t\tif (!i)\n\t\t\t{\n\t\t\t\tOsdWrite(m++);\n\t\t\t\tOsdWrite(m++, \" Other configs:\");\n\t\t\t}\n\t\t}\n\n\t\tfor (; m < OsdGetSize() - 1; m++) OsdWrite(m);\n\t\tOsdWrite(15, STD_BACK, menusub == 9, 0);\n\n\t\tmenustate = MENU_ST_LOAD_CONFIG2;\n\t\tbreak;\n\n\tcase MENU_ST_LOAD_CONFIG2:\n\t\tif (menu || left)\n\t\t{\n\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\tmenusub = 6;\n\t\t}\n\n\t\tif (select)\n\t\t{\n\t\t\tif (menusub < 9)\n\t\t\t{\n\t\t\t\ttos_config_load(menusub);\n\t\t\t\ttos_upload(NULL);\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\tmenusub = 6;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_ST_SAVE_CONFIG1:\n\t\thelptext_idx = 0;\n\t\tOsdSetTitle(\"Save Config\", 0);\n\n\t\tparentstate = menustate;\n\t\tmenumask = 0x3FF;\n\n\t\tm = 0;\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \" Startup config:\");\n\t\tfor (uint32_t i = 0; i < 9; i++)\n\t\t{\n\t\t\tsnprintf(s, 29, \"  %s\", tos_get_cfg_string(i));\n\t\t\tOsdWrite(m++, s, menusub == i, !(menumask & (1 << i)));\n\t\t\tif (!i)\n\t\t\t{\n\t\t\t\tOsdWrite(m++);\n\t\t\t\tOsdWrite(m++, \" Other configs:\");\n\t\t\t}\n\t\t}\n\n\t\tfor (; m < OsdGetSize() - 1; m++) OsdWrite(m);\n\t\tOsdWrite(15, STD_BACK, menusub == 9, 0);\n\n\t\tmenustate = MENU_ST_SAVE_CONFIG2;\n\t\tbreak;\n\n\tcase MENU_ST_SAVE_CONFIG2:\n\t\tif (menu || left)\n\t\t{\n\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\tmenusub = 7;\n\t\t}\n\n\t\tif (select)\n\t\t{\n\t\t\tif (menusub < 9)\n\t\t\t{\n\t\t\t\ttos_config_save(menusub);\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\tmenusub = 7;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\n\tcase MENU_MT32PI_MAIN1:\n\t\t{\n\t\t\tparentstate = menustate;\n\t\t\tOsdSetTitle(\"MT32-pi\");\n\t\t\tmenumask = 0x7F;\n\t\t\tuint32_t mt32_cfg = is_minimig() ? minimig_get_extcfg() : tos_get_extctrl();\n\n\t\t\tm = 0;\n\t\t\tOsdWrite(m++);\n\t\t\tstrcpy(s, \" Use MT32-pi:            \");\n\t\t\tstrcat(s, (mt32_cfg & 0x2) ? \" No\" : \"Yes\");\n\t\t\tOsdWrite(m++, s, menusub == 0);\n\n\t\t\tstrcpy(s, \" Show Info: \");\n\t\t\tswitch ((mt32_cfg >> 8) & 3)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tstrcat(s, \"              No\");\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tstrcat(s, \"             Yes\");\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tstrcat(s, \"  LCD-On(non-FB)\");\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tstrcat(s, \"LCD-Auto(non-FB)\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tOsdWrite(m++, s, menusub == 1);\n\n\t\t\tOsdWrite(m++);\n\t\t\tOsdWrite(m++, \" Default Config:\");\n\n\t\t\tstrcpy(s, \" Synth:           \");\n\t\t\tstrcat(s, (mt32_cfg & 0x4) ? \"FluidSynth\" : \"      Munt\");\n\t\t\tOsdWrite(m++, s, menusub == 2);\n\n\t\t\tstrcpy(s, \" Munt ROM:          \");\n\t\t\tswitch ((mt32_cfg >> 3) & 3)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tstrcat(s, \"MT-32 v1\");\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tstrcat(s, \"MT-32 v2\");\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tstrcat(s, \"  CM-32L\");\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tstrcat(s, \" Unknown\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tOsdWrite(m++, s, menusub == 3);\n\n\t\t\tsprintf(s, \" SoundFont:                %d\", (mt32_cfg >> 5) & 7);\n\t\t\tOsdWrite(m++, s, menusub == 4);\n\n\t\t\tOsdWrite(m++);\n\t\t\tstrcpy(s, \" Current Config: \");\n\t\t\thdmask = spi_uio_cmd16(UIO_GET_OSDMASK, 0);\n\t\t\tif (((hdmask >> 1) & 3) == 1)\n\t\t\t{\n\t\t\t\tswitch ((hdmask >> 3) & 3)\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tstrcat(s, \"   MT-32 v1\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tstrcat(s, \"   MT-32 v2\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tstrcat(s, \"     CM-32L\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tstrcat(s, \"    Unknown\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (((hdmask >> 1) & 3) == 2)\n\t\t\t{\n\t\t\t\tsprintf(s + strlen(s), \"SoundFont %d\", (hdmask >> 3) & 7);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcat(s, \"    Unknown\");\n\t\t\t}\n\t\t\tOsdWrite(m++, s);\n\n\t\t\tOsdWrite(m++);\n\t\t\tOsdWrite(m++, \" Reset Hanging Notes\", menusub == 5);\n\n\t\t\twhile (m < 15) OsdWrite(m++);\n\t\t\tOsdWrite(15, STD_BACK, menusub == 6, 0);\n\n\t\t\tmenustate = MENU_MT32PI_MAIN2;\n\t\t}\n\t\tbreak;\n\n\n\tcase MENU_MT32PI_MAIN2:\n\t\tif (menu || back || left || (select && menusub == 6))\n\t\t{\n\t\t\tif (is_minimig())\n\t\t\t{\n\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\tmenusub = 8;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmenustate = MENU_ST_MAIN1;\n\t\t\t\tmenusub = 8;\n\t\t\t}\n\t\t}\n\t\telse if (select || plus || minus)\n\t\t{\n\t\t\tuint32_t mt32_cfg = is_minimig() ? minimig_get_extcfg() : tos_get_extctrl();\n\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tmt32_cfg ^= 0x2;\n\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tm = (mt32_cfg >> 8) & 3;\n\t\t\t\tm = (m + (minus ? -1 : 1)) & 3;\n\t\t\t\tmt32_cfg = (mt32_cfg & ~0x300) | (m<<8);\n\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tmt32_cfg ^= 0x4;\n\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tm = (mt32_cfg >> 3) & 3;\n\t\t\t\tif (minus)\n\t\t\t\t{\n\t\t\t\t\tm = (m - 1) & 3;\n\t\t\t\t\tif (m == 3) m = 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm = (m + 1) & 3;\n\t\t\t\t\tif (m == 3) m = 0;\n\t\t\t\t}\n\t\t\t\tmt32_cfg = (mt32_cfg & ~0x18) | (m << 3);\n\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tm = (mt32_cfg >> 5) & 7;\n\t\t\t\tm = (m + (minus ? -1 : 1)) & 7;\n\t\t\t\tmt32_cfg = (mt32_cfg & ~0xE0) | (m << 5);\n\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tif (is_minimig()) minimig_set_extcfg(mt32_cfg | 1);\n\t\t\t\t\telse tos_set_extctrl(mt32_cfg | 1);\n\t\t\t\t\tmt32_cfg &= ~1;\n\t\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (is_minimig()) minimig_set_extcfg(mt32_cfg);\n\t\t\telse tos_set_extctrl(mt32_cfg);\n\t\t}\n\t\telse if (spi_uio_cmd16(UIO_GET_OSDMASK, 0) != hdmask)\n\t\t{\n\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t}\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* file selection menu                                            */\n\t\t/******************************************************************/\n\tcase MENU_FILE_SELECT1:\n\t\thelptext_idx = (fs_Options & SCANO_UMOUNT) ? HELPTEXT_EJECT : (fs_Options & SCANO_CLEAR) ? HELPTEXT_CLEAR : 0;\n\t\tOsdSetTitle((fs_Options & SCANO_CORES) ? \"Cores\" : \"Select\", 0);\n\t\tPrintDirectory(hold_cnt<2);\n\t\tmenustate = MENU_FILE_SELECT2;\n\t\tif (cfg.log_file_entry && flist_nDirEntries())\n\t\t{\n\t\t\t//Write out paths infos for external integration\n\t\t\tMakeFile(\"/tmp/CURRENTPATH\", flist_SelectedItem()->altname);\n\t\t\tMakeFile(\"/tmp/FULLPATH\", selPath);\n\t\t\tMakeFile(\"/tmp/FILESELECT\", \"active\");\n\t\t}\n\t\tbreak;\n\n\tcase MENU_FILE_SELECT2:\n\t\tmenumask = 0;\n\n\t\tif (c == KEY_BACKSPACE && (fs_Options & (SCANO_UMOUNT | SCANO_CLEAR)) && !strlen(filter))\n\t\t{\n\t\t\tfor (int i = 0; i < OsdGetSize(); i++) OsdWrite(i, \"\", 0, 0);\n\t\t\tif (fs_Options & SCANO_CLEAR)\n\t\t\t{\n\t\t\t\tint i = (OsdGetSize() / 2) - 2;\n\t\t\t\tOsdWrite(i++, \"     Clearing the option\");\n\t\t\t\tOsdWrite(i++);\n\t\t\t\tOsdWrite(i++, \" You have to reload the core\");\n\t\t\t\tOsdWrite(i++, \"    to use default value.\");\n\t\t\t\tOsdUpdate();\n\t\t\t\tsleep(2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOsdWrite(OsdGetSize() / 2, \"    Unmounting the image\", 0, 0);\n\t\t\t\tOsdUpdate();\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\tinput_poll(0);\n\t\t\tmenu_key_set(0);\n\t\t\tselPath[0] = 0;\n\t\t\tmenustate = fs_MenuSelect;\n\t\t\thelptext_idx = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (menu)\n\t\t{\n\t\t\tif (flist_nDirEntries() && flist_SelectedItem()->de.d_type != DT_DIR)\n\t\t\t{\n\t\t\t\tSelectedDir[0] = 0;\n\t\t\t\tif (strlen(selPath))\n\t\t\t\t{\n\t\t\t\t\tstrcpy(SelectedDir, selPath);\n\t\t\t\t\tstrcat(selPath, \"/\");\n\t\t\t\t}\n\t\t\t\tstrcat(selPath, flist_SelectedItem()->de.d_name);\n\t\t\t}\n\n\t\t\tif (!strcasecmp(fs_pFileExt, \"RBF\")) selPath[0] = 0;\n\t\t\tmenustate = fs_MenuCancel;\n\t\t\thelptext_idx = 0;\n\t\t}\n\n\t\tif (recent && recent_init((fs_Options & SCANO_CORES) ? -1 : (fs_Options & SCANO_UMOUNT) ? ioctl_index + 500 : ioctl_index))\n\t\t{\n\t\t\tmenustate = MENU_RECENT1;\n\t\t}\n\n\t\tif (c == KEY_BACKSPACE)\n\t\t{\n\t\t\tfilter[0] = 0;\n\t\t\tfilter_typing_timer = 0;\n\t\t\tScanDirectory(selPath, SCANF_INIT, fs_pFileExt, fs_Options);\n\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t}\n\n\t\tif (flist_nDirEntries())\n\t\t{\n\t\t\tif (!helpstate || ((flist_iSelectedEntry() - flist_iFirstEntry() + 1) < OsdGetSize())) ScrollLongName(); // scrolls file name if longer than display line\n\n\t\t\tif (c == KEY_HOME || c == KEY_TAB)\n\t\t\t{\n\t\t\t\tfilter_typing_timer = 0;\n\t\t\t\tScanDirectory(selPath, SCANF_INIT, fs_pFileExt, fs_Options);\n\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t\tselect = (c == KEY_TAB && flist_SelectedItem()->de.d_type == DT_DIR && !strcmp(flist_SelectedItem()->de.d_name, \"..\"));\n\t\t\t}\n\n\t\t\tif (c == KEY_END)\n\t\t\t{\n\t\t\t\tfilter_typing_timer = 0;\n\t\t\t\tScanDirectory(selPath, SCANF_END, fs_pFileExt, fs_Options);\n\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t}\n\n\t\t\tif ((c == KEY_PAGEUP) || (c == KEY_LEFT))\n\t\t\t{\n\t\t\t\tfilter_typing_timer = 0;\n\t\t\t\tScanDirectory(selPath, SCANF_PREV_PAGE, fs_pFileExt, fs_Options);\n\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t}\n\n\t\t\tif ((c == KEY_PAGEDOWN) || (c == KEY_RIGHT))\n\t\t\t{\n\t\t\t\tfilter_typing_timer = 0;\n\t\t\t\tScanDirectory(selPath, SCANF_NEXT_PAGE, fs_pFileExt, fs_Options);\n\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t}\n\n\t\t\tif (down) // scroll down one entry\n\t\t\t{\n\t\t\t\tfilter_typing_timer = 0;\n\t\t\t\tScanDirectory(selPath, SCANF_NEXT, fs_pFileExt, fs_Options);\n\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t}\n\n\t\t\tif (up) // scroll up one entry\n\t\t\t{\n\t\t\t\tfilter_typing_timer = 0;\n\t\t\t\tScanDirectory(selPath, SCANF_PREV, fs_pFileExt, fs_Options);\n\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tchar i;\n\t\t\t\tif ((i = GetASCIIKey(c)) > 1)\n\t\t\t\t{\n\t\t\t\t\tint filter_len = strlen(filter);\n\t\t\t\t\tif (CheckTimer(filter_typing_timer))\n\t\t\t\t\t{\n\t\t\t\t\t\tfilter[0] = i;\n\t\t\t\t\t\tfilter[1] = 0;\n\n\t\t\t\t\t\t// You need both ScanDirectory calls here: the first\n\t\t\t\t\t\t// call \"clears\" the filter, the second one scrolls to\n\t\t\t\t\t\t// the right place in the list\n\t\t\t\t\t\tScanDirectory(selPath, SCANF_INIT, fs_pFileExt, fs_Options);\n\t\t\t\t\t\tScanDirectory(selPath, i, fs_pFileExt, fs_Options);\n\t\t\t\t\t}\n\t\t\t\t\telse if (filter_len < 255)\n\t\t\t\t\t{\n\t\t\t\t\t\tfilter[filter_len++] = i;\n\t\t\t\t\t\tfilter[filter_len] = 0;\n\t\t\t\t\t\tScanDirectory(selPath, SCANF_INIT, fs_pFileExt, fs_Options, NULL, filter);\n\t\t\t\t\t}\n\n\t\t\t\t\tfilter_typing_timer = GetTimer(2000);\n\t\t\t\t\tprintf(\"filter is: %s\\n\", filter);\n\n\t\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (select)\n\t\t\t{\n\t\t\t\tstatic char name[256];\n\t\t\t\tchar type = flist_SelectedItem()->de.d_type;\n\t\t\t\tmemcpy(name, flist_SelectedItem()->de.d_name, sizeof(name));\n\n\t\t\t\tif ((fs_Options & SCANO_UMOUNT) && (is_megacd() || is_pce() || is_neogeo() || (is_psx() && !(fs_Options & SCANO_SAVES)) || is_saturn()) && type == DT_DIR && strcmp(flist_SelectedItem()->de.d_name, \"..\"))\n\t\t\t\t{\n\t\t\t\t\tint len = strlen(selPath);\n\t\t\t\t\tstrcat(selPath, \"/\");\n\t\t\t\t\tstrcat(selPath, name);\n\t\t\t\t\tint num = ScanDirectory(selPath, SCANF_INIT, fs_pFileExt, 0);\n\t\t\t\t\tif (num != 1) selPath[len] = 0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttype = flist_SelectedItem()->de.d_type;\n\t\t\t\t\t\tmemcpy(name, flist_SelectedItem()->de.d_name, sizeof(name));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (type == DT_DIR)\n\t\t\t\t{\n\t\t\t\t\tchangeDir(name);\n\t\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (flist_nDirEntries())\n\t\t\t\t\t{\n\t\t\t\t\t\tSelectedDir[0] = 0;\n\t\t\t\t\t\tif (strlen(selPath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrcpy(SelectedDir, selPath);\n\t\t\t\t\t\t\tstrcat(selPath, \"/\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcpy(SelectedLabel, flist_SelectedItem()->altname);\n\t\t\t\t\t\tif (fs_Options & SCANO_CORES)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint len = strlen(SelectedLabel);\n\t\t\t\t\t\t\tif (SelectedLabel[len - 4] == '.') SelectedLabel[len - 4] = 0;\n\t\t\t\t\t\t\tchar *p = strstr(SelectedLabel, \"_20\");\n\t\t\t\t\t\t\tif (p) *p = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcat(selPath, name);\n\t\t\t\t\t\tmenustate = fs_MenuSelect;\n\t\t\t\t\t\thelptext_idx = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (release) PrintDirectory(1);\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* cheats menu                                                    */\n\t\t/******************************************************************/\n\tcase MENU_CHEATS1:\n\t\thelptext_idx = 0;\n\t\tsprintf(s, \"Cheats (%d)\", cheats_loaded());\n\t\tOsdSetTitle(s);\n\t\tcheats_print();\n\t\tmenustate = MENU_CHEATS2;\n\t\tparentstate = menustate;\n\t\tbreak;\n\n\tcase MENU_CHEATS2:\n\t\tmenumask = 0;\n\n\t\tif (menu)\n\t\t{\n\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\tmenusub = cheatsub;\n\t\t\tbreak;\n\t\t}\n\n\t\tcheats_scroll_name();\n\n\t\tif (c == KEY_HOME)\n\t\t{\n\t\t\tcheats_scan(SCANF_INIT);\n\t\t\tmenustate = MENU_CHEATS1;\n\t\t}\n\n\t\tif (c == KEY_END)\n\t\t{\n\t\t\tcheats_scan(SCANF_END);\n\t\t\tmenustate = MENU_CHEATS1;\n\t\t}\n\n\t\tif ((c == KEY_PAGEUP) || (c == KEY_LEFT))\n\t\t{\n\t\t\tcheats_scan(SCANF_PREV_PAGE);\n\t\t\tmenustate = MENU_CHEATS1;\n\t\t}\n\n\t\tif ((c == KEY_PAGEDOWN) || (c == KEY_RIGHT))\n\t\t{\n\t\t\tcheats_scan(SCANF_NEXT_PAGE);\n\t\t\tmenustate = MENU_CHEATS1;\n\t\t}\n\n\t\tif (down) // scroll down one entry\n\t\t{\n\t\t\tcheats_scan(SCANF_NEXT);\n\t\t\tmenustate = MENU_CHEATS1;\n\t\t}\n\n\t\tif (up) // scroll up one entry\n\t\t{\n\t\t\tcheats_scan(SCANF_PREV);\n\t\t\tmenustate = MENU_CHEATS1;\n\t\t}\n\n\t\tif (select)\n\t\t{\n\t\t\tcheats_toggle();\n\t\t\tmenustate = MENU_CHEATS1;\n\t\t}\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* last rom menu                                                    */\n\t\t/******************************************************************/\n\tcase MENU_RECENT1:\n\t\thelptext_idx = 0;\n\t\tOsdSetTitle((fs_Options & SCANO_CORES) ? \"Recent Cores\" : \"Recent Files\");\n\t\trecent_print();\n\t\tmenustate = MENU_RECENT2;\n\t\tparentstate = menustate;\n\t\tbreak;\n\n\tcase MENU_RECENT2:\n\t\tmenumask = 0;\n\n\t\tif (menu || recent)\n\t\t{\n\t\t\tmenustate = fs_MenuCancel;\n\t\t\tif (is_menu()) menustate = MENU_FILE_SELECT1;\n\t\t\tbreak;\n\t\t}\n\n\t\trecent_scroll_name();\n\n\t\tif (c == KEY_HOME)\n\t\t{\n\t\t\trecent_scan(SCANF_INIT);\n\t\t\tmenustate = MENU_RECENT1;\n\t\t}\n\n\t\tif (c == KEY_END)\n\t\t{\n\t\t\trecent_scan(SCANF_END);\n\t\t\tmenustate = MENU_RECENT1;\n\t\t}\n\n\t\tif ((c == KEY_PAGEUP) || (c == KEY_LEFT))\n\t\t{\n\t\t\trecent_scan(SCANF_PREV_PAGE);\n\t\t\tmenustate = MENU_RECENT1;\n\t\t}\n\n\t\tif ((c == KEY_PAGEDOWN) || (c == KEY_RIGHT))\n\t\t{\n\t\t\trecent_scan(SCANF_NEXT_PAGE);\n\t\t\tmenustate = MENU_RECENT1;\n\t\t}\n\n\t\tif (c == KEY_BACKSPACE)\n\t\t{\n\t\t\tmenusub_last = menusub;\n\t\t\tmenusub = 0;\n\t\t\tmenustate = MENU_RECENT3;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (down) // scroll down one entry\n\t\t{\n\t\t\trecent_scan(SCANF_NEXT);\n\t\t\tmenustate = MENU_RECENT1;\n\t\t}\n\n\t\tif (up) // scroll up one entry\n\t\t{\n\t\t\trecent_scan(SCANF_PREV);\n\t\t\tmenustate = MENU_RECENT1;\n\t\t}\n\n\t\tif (select)\n\t\t{\n\t\t\tmenustate = recent_select(SelectedDir, selPath, SelectedLabel) ? (enum MENU)fs_MenuSelect : MENU_RECENT1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_RECENT3:\n\t\tmenumask = 0x03;\n\t\tparentstate = menustate;\n\t\tm = 0;\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \"        Clear the List?\");\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \"             No\", menusub == 0);\n\t\tOsdWrite(m++, \"             Yes\", menusub == 1);\n\t\twhile(m < OsdGetSize()) OsdWrite(m++);\n\t\tmenustate = MENU_RECENT4;\n\t\tbreak;\n\n\tcase MENU_RECENT4:\n\t\tif (select && menusub == 1)\n\t\t{\n\t\t\tfor (int i = 0; i < OsdGetSize(); i++) OsdWrite(i, \"\", 0, 0);\n\t\t\tOsdWrite(OsdGetSize() / 2, \"    Clearing the recents\", 0, 0);\n\t\t\tOsdUpdate();\n\t\t\tsleep(1);\n\t\t\trecent_clear((fs_Options & SCANO_CORES) ? -1 : (fs_Options & SCANO_UMOUNT) ? ioctl_index + 500 : ioctl_index);\n\t\t\tmenustate = fs_MenuCancel;\n\t\t\tmenusub = menusub_last;\n\t\t\tif (is_menu()) menustate = MENU_FILE_SELECT1;\n\n\t\t}\n\t\telse if (select || menu || back)\n\t\t{\n\t\t\tmenustate = fs_MenuCancel;\n\t\t\tmenusub = menusub_last;\n\t\t\tif (is_menu()) menustate = MENU_FILE_SELECT1;\n\t\t}\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* reset menu                                                     */\n\t\t/******************************************************************/\n\tcase MENU_RESET1:\n\t\tm = 0;\n\t\tif (is_minimig()) m = 1;\n\t\thelptext_idx = 0;\n\t\tOsdSetTitle(\"Reset\", 0);\n\t\tmenumask = 0x03;\t// Yes / No\n\t\tparentstate = menustate;\n\n\t\tOsdWrite(0, \"\", 0, 0);\n\t\tOsdWrite(1, m ? \"       Reset Minimig?\" : \"       Reset settings?\", 0, 0);\n\t\tOsdWrite(2, \"\", 0, 0);\n\t\tOsdWrite(3, \"             yes\", menusub == 0, 0);\n\t\tOsdWrite(4, \"             no\", menusub == 1, 0);\n\t\tOsdWrite(5, \"\", 0, 0);\n\t\tOsdWrite(6, \"\", 0, 0);\n\t\tfor (int i = 7; i < OsdGetSize(); i++) OsdWrite(i, \"\", 0, 0);\n\n\t\tmenustate = MENU_RESET2;\n\t\tbreak;\n\n\tcase MENU_RESET2:\n\t\tm = 0;\n\t\tif (is_minimig()) m = 1;\n\t\tif (user_io_core_type() == CORE_TYPE_SHARPMZ)  m = 2;\n\n\t\tif (select && menusub == 0)\n\t\t{\n\t\t\tif (m)\n\t\t\t{\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tminimig_reset();\n\t\t\t}\n            else if(m == 2)\n            {\n\t\t\t\tmenustate = MENU_COMMON1;\n                sharpmz_reset_config(1);\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\tuser_io_status_reset();\n\t\t\t\tchar *filename = user_io_create_config_name(1);\n\t\t\t\tprintf(\"Saving config to %s\\n\", filename);\n\t\t\t\tuser_io_status_save(filename);\n\t\t\t\tmenustate = MENU_GENERIC_MAIN1;\n\t\t\t\tfor (int n = 0; n < 2; n++)\n\t\t\t\t{\n\t\t\t\t\tif (arcade_sw(n)->dip_num)\n\t\t\t\t\t{\n\t\t\t\t\t\tarcade_sw(n)->dip_cur = arcade_sw(n)->dip_def;\n\t\t\t\t\t\tarcade_sw_send(n);\n\t\t\t\t\t\tuser_io_status_set(\"[0]\", 1);\n\t\t\t\t\t\tuser_io_status_set(\"[0]\", 0);\n\t\t\t\t\t\tarcade_sw_save(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tmenusub = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (menu || (select && (menusub == 1))) // exit menu\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 11;\n\t\t}\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* minimig main menu                                              */\n\t\t/******************************************************************/\n\tcase MENU_MINIMIG_MAIN1:\n\t\tmenumask = 0x1EF0;\n\t\tOsdSetTitle(\"Minimig\", OSD_ARROW_RIGHT | OSD_ARROW_LEFT);\n\t\thelptext_idx = HELPTEXT_MAIN;\n\n\t\twhile (1)\n\t\t{\n\t\t\tif (!menusub) firstmenu = 0;\n\t\t\tadjvisible = 0;\n\t\t\t// floppy drive info\n\t\t\t// We display a line for each drive that's active\n\t\t\t// in the config file, but grey out any that the FPGA doesn't think are active.\n\t\t\t// We also print a help text in place of the last drive if it's inactive.\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (i == minimig_config.floppy.drives + 1) MenuWrite(i, \" KP +/- to add/remove drives\", 0, 1);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, \" dfx: \");\n\t\t\t\t\ts[3] = i + '0';\n\t\t\t\t\tif (i <= drives)\n\t\t\t\t\t{\n\t\t\t\t\t\tmenumask |= (1 << i);\t// Make enabled drives selectable\n\n\t\t\t\t\t\tif (df[i].status & DSK_INSERTED) // floppy disk is inserted\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *p;\n\t\t\t\t\t\t\tif ((p = strrchr(df[i].name, '/')))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp = df[i].name;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint len = strlen(p);\n\t\t\t\t\t\t\tif (len > 22) len = 21;\n\t\t\t\t\t\t\tstrncpy(&s[6], p, len);\n\t\t\t\t\t\t\ts[6 + len] = ' ';\n\t\t\t\t\t\t\ts[6 + len + 1] = 0;\n\t\t\t\t\t\t\ts[6 + len + 2] = 0;\n\t\t\t\t\t\t\tif (!(df[i].status & DSK_WRITABLE)) s[6 + len + 1] = '\\x17'; // padlock icon for write-protected disks\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse // no floppy disk\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrcat(s, \"* no disk *\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (i <= minimig_config.floppy.drives)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcat(s, \"* active after reset *\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcpy(s, \"\");\n\t\t\t\t\tMenuWrite(i, s, menusub == (uint32_t)i, (i > drives) || (i > minimig_config.floppy.drives));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm = 4;\n\t\t\tstrcpy(s,      \" Joystick Swap:          \");\n\t\t\tstrcat(s, (minimig_config.autofire & 0x8) ? \" ON\" : \"OFF\");\n\t\t\tMenuWrite(m++, s, menusub == 4, 0);\n\t\t\tMenuWrite(m++),\n\n\t\t\tMenuWrite(m++, \" Drives                    \\x16\", menusub == 5, 0);\n\t\t\tMenuWrite(m++, \" System                    \\x16\", menusub == 6, 0);\n\t\t\tMenuWrite(m++, \" Audio & Video             \\x16\", menusub == 7, 0);\n\t\t\tif (spi_uio_cmd16(UIO_GET_OSDMASK, 0) & 1)\n\t\t\t{\n\t\t\t\tmenumask |= 0x100;\n\t\t\t\tMenuWrite(m++, \" MT32-pi                   \\x16\", menusub == 8);\n\t\t\t}\n\n\t\t\tMenuWrite(m++);\n\t\t\tMenuWrite(m++, \" Save configuration        \\x16\", menusub == 9, 0);\n\t\t\tMenuWrite(m++, \" Load configuration        \\x16\", menusub == 10, 0);\n\n\t\t\twhile (m < 14) MenuWrite(m++);\n\t\t\tMenuWrite(m++, \" Reset\", menusub == 11, 0);\n\t\t\tMenuWrite(m, STD_EXIT, menusub == 12, 0);\n\n\t\t\tif (!adjvisible) break;\n\t\t\tfirstmenu += adjvisible;\n\t\t}\n\n\t\tmenustate = MENU_MINIMIG_MAIN2;\n\t\tparentstate = MENU_MINIMIG_MAIN1;\n\n\t\tif (!mgl->done)\n\t\t{\n\t\t\tif (mgl->item[mgl->current].index < 4)\n\t\t\t{\n\t\t\t\tmenusub = mgl->item[mgl->current].index;\n\t\t\t\tmenustate = MENU_MINIMIG_ADFFILE_SELECTED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_MAIN2:\n\t\tif (menu) menustate = MENU_NONE1;\n\t\telse if (plus && (minimig_config.floppy.drives < 3) && menusub < 4)\n\t\t{\n\t\t\tminimig_config.floppy.drives++;\n\t\t\tminimig_ConfigFloppy(minimig_config.floppy.drives, minimig_config.floppy.speed);\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t}\n\t\telse if (minus && (minimig_config.floppy.drives > 0) && menusub < 4)\n\t\t{\n\t\t\tminimig_config.floppy.drives--;\n\t\t\tminimig_ConfigFloppy(minimig_config.floppy.drives, minimig_config.floppy.speed);\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t}\n\t\telse if (select || recent || minus || plus)\n\t\t{\n\t\t\tif (menusub < 4)\n\t\t\t{\n\t\t\t\tioctl_index = 0;\n\t\t\t\tif (df[menusub].status & DSK_INSERTED) // eject selected floppy\n\t\t\t\t{\n\t\t\t\t\tdf[menusub].status = 0;\n\t\t\t\t\tFileClose(&df[menusub].file);\n\t\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdf[menusub].status = 0;\n\t\t\t\t\tfs_Options = SCANO_DIR;\n\t\t\t\t\tfs_MenuSelect = MENU_MINIMIG_ADFFILE_SELECTED;\n\t\t\t\t\tfs_MenuCancel = MENU_MINIMIG_MAIN1;\n\t\t\t\t\tstrcpy(fs_pFileExt, \"ADF\");\n\t\t\t\t\tif (select) SelectFile(Selected_F[menusub], \"ADF\", fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\t\t\telse if (recent_init(0)) menustate = MENU_RECENT1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (menusub == 4)\n\t\t\t{\n\t\t\t\tminimig_config.autofire ^= 0x8;\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t\tminimig_ConfigAutofire(minimig_config.autofire, 0x8);\n\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t}\n\t\t\telse if (select)\n\t\t\t{\n\t\t\t\tif (menusub == 5)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_MINIMIG_DISK1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\telse if (menusub == 6)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\telse if (menusub == 7)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_MINIMIG_VIDEO1;\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t}\n\t\t\t\telse if (menusub == 8)\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_MT32PI_MAIN1;\n\t\t\t\t}\n\t\t\t\telse if (menusub == 9)\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_MINIMIG_SAVECONFIG1;\n\t\t\t\t}\n\t\t\t\telse if (menusub == 10)\n\t\t\t\t{\n\t\t\t\t\tmenusub = 0;\n\t\t\t\t\tmenustate = MENU_MINIMIG_LOADCONFIG1;\n\t\t\t\t}\n\t\t\t\telse if (menusub == 11)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t\tminimig_reset();\n\t\t\t\t}\n\t\t\t\telse if (menusub == 12)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (c == KEY_BACKSPACE) // eject all floppies\n\t\t{\n\t\t\tfor (int i = 0; i <= drives; i++) df[i].status = 0;\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t}\n\t\telse if (right)\n\t\t{\n\t\t\tmenustate = MENU_COMMON1;\n\t\t\tmenusub = 0;\n\t\t}\n\t\telse if (left)\n\t\t{\n\t\t\tmenustate = MENU_MISC1;\n\t\t\tmenusub = 3;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_ADFFILE_SELECTED:\n\t\tif (!mgl->done) snprintf(selPath, sizeof(selPath), \"%s/%s\", HomeDir(), mgl->item[mgl->current].path);\n\t\tmemcpy(Selected_F[menusub], selPath, sizeof(Selected_F[menusub]));\n\t\tif (mgl->done) recent_update(SelectedDir, selPath, SelectedLabel, 0);\n\t\tInsertFloppy(&df[menusub], selPath);\n\t\tif (menusub < drives) menusub++;\n\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\tif (!mgl->done)\n\t\t{\n\t\t\tmgl->state = 3;\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_LOADCONFIG1:\n\t\thelptext_idx = 0;\n\t\tif (parentstate != menustate) menumask = 0x400;\n\n\t\tparentstate = menustate;\n\t\tOsdSetTitle(\"Load config\", 0);\n\n\t\tm = 0;\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tOsdWrite(m++, \" Startup config:\");\n\t\tfor (uint i = 0; i < 10; i++)\n\t\t{\n\t\t\tconst char *info = minimig_get_cfg_info(i, menusub != i);\n\t\t\tstatic char name[128];\n\n\t\t\tif (info)\n\t\t\t{\n\t\t\t\tmenumask |= 1 << i;\n\t\t\t\tsprintf(name, \"  %s\", strlen(info) ? info : \"NO INFO\");\n\t\t\t\tchar *p = strchr(name, '\\n');\n\t\t\t\tif (p) *p = 0;\n\t\t\t\tOsdWrite(m++, name, menusub == i);\n\n\t\t\t\tif (menusub == i && p)\n\t\t\t\t{\n\t\t\t\t\tsprintf(name, \"  %s\", strchr(info, '\\n') + 1);\n\t\t\t\t\tOsdWrite(m++, name, 1, !(menumask & (1 << i)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!i)\n\t\t\t{\n\t\t\t\tOsdWrite(m++, \"\", 0, 0);\n\t\t\t\tm = 4;\n\t\t\t\tOsdWrite(m++, \" Other configs:\");\n\t\t\t}\n\t\t}\n\n\t\twhile (m < OsdGetSize() - 1) OsdWrite(m++);\n\t\tOsdWrite(OsdGetSize() - 1, STD_BACK, menusub == 10, 0);\n\n\t\tmenustate = MENU_MINIMIG_LOADCONFIG2;\n\t\tbreak;\n\n\tcase MENU_MINIMIG_LOADCONFIG2:\n\t\tif (down)\n\t\t{\n\t\t\tif (menusub < 9) menusub++;\n\t\t\tmenustate = MENU_MINIMIG_LOADCONFIG1;\n\t\t}\n\t\telse if (select)\n\t\t{\n\t\t\tif (menusub < 10)\n\t\t\t{\n\t\t\t\tOsdDisable();\n\t\t\t\tminimig_cfg_load(menusub);\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\tmenusub = 10;\n\t\t\t}\n\t\t}\n\t\tif (menu || left)\n\t\t{\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\tmenusub = 10;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_SAVECONFIG1:\n\t\thelptext_idx = 0;\n\t\tmenumask = 0x7ff;\n\t\tparentstate = menustate;\n\t\tOsdSetTitle(\"Save config\", 0);\n\n\t\tm = 0;\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tOsdWrite(m++, \" Startup config:\");\n\t\tfor (uint i = 0; i < 10; i++)\n\t\t{\n\t\t\tconst char *info = minimig_get_cfg_info(i, menusub != i);\n\t\t\tstatic char name[128];\n\n\t\t\tif (info)\n\t\t\t{\n\t\t\t\tsprintf(name, \"  %s\", strlen(info) ? info : \"NO INFO\");\n\t\t\t\tchar *p = strchr(name, '\\n');\n\t\t\t\tif (p) *p = 0;\n\t\t\t\tOsdWrite(m++, name, menusub == i);\n\t\t\t\tif (menusub == i && p)\n\t\t\t\t{\n\t\t\t\t\tsprintf(name, \"  %s\", strchr(info, '\\n') + 1);\n\t\t\t\t\tOsdWrite(m++, name, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOsdWrite(m++, \"  < EMPTY >\", menusub == i);\n\t\t\t}\n\n\t\t\tif (!i)\n\t\t\t{\n\t\t\t\tOsdWrite(m++, \"\", 0, 0);\n\t\t\t\tm = 4;\n\t\t\t\tOsdWrite(m++, \" Other configs:\");\n\t\t\t}\n\t\t}\n\n\t\twhile (m < OsdGetSize() - 1) OsdWrite(m++);\n\t\tOsdWrite(OsdGetSize() - 1, STD_BACK, menusub == 10, 0);\n\n\t\tmenustate = MENU_MINIMIG_SAVECONFIG2;\n\t\tbreak;\n\n\tcase MENU_MINIMIG_SAVECONFIG2:\n\t\tif (select)\n\t\t{\n\t\t\tint fastcfg = ((minimig_config.memory >> 4) & 0x03) | ((minimig_config.memory & 0x80) >> 5);\n\t\t\tsprintf(minimig_config.info, \"%s/%s/%s%s %s%s%s%s%s%s\\n\",\n\t\t\t\tconfig_cpu_msg[minimig_config.cpu & 0x03] + 2,\n\t\t\t\tconfig_chipset_msg[(minimig_config.chipset >> 2) & 7],\n\t\t\t\tminimig_config.chipset & CONFIG_NTSC ? \"N\" : \"P\",\n\t\t\t\t((minimig_config.ide_cfg & 1) && (minimig_config.hardfile[0].cfg ||\n\t\t\t\t\tminimig_config.hardfile[1].cfg ||\n\t\t\t\t\tminimig_config.hardfile[2].cfg ||\n\t\t\t\t\tminimig_config.hardfile[3].cfg)) ? \"/HD\" : \"\",\n\t\t\t\tconfig_memory_chip_msg[minimig_config.memory & 0x03],\n\t\t\t\tfastcfg ? \"+\" : \"\",\n\t\t\t\tfastcfg ? config_memory_fast_msg[(minimig_config.cpu>>1) & 1][fastcfg] : \"\",\n\t\t\t\t((minimig_config.memory >> 2) & 0x03) ? \"+\" : \"\",\n\t\t\t\t((minimig_config.memory >> 2) & 0x03) ? config_memory_slow_msg[(minimig_config.memory >> 2) & 0x03] : \"\",\n\t\t\t\t(minimig_config.memory & 0x40) ? \" HRT\" : \"\"\n\t\t\t);\n\n\t\t\tchar *p = strrchr(minimig_config.kickstart, '/');\n\t\t\tif (!p) p = minimig_config.kickstart;\n\t\t\telse p++;\n\n\t\t\tstrncat(minimig_config.info, p, sizeof(minimig_config.info) - strlen(minimig_config.info) - 1);\n\t\t\tminimig_config.info[sizeof(minimig_config.info) - 1] = 0;\n\n\t\t\tif (menusub<10) minimig_cfg_save(menusub);\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\tmenusub = 9;\n\t\t}\n\t\telse\n\t\tif (menu || left) // exit menu\n\t\t{\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\tmenusub = 9;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_CHIPSET1:\n\t\thelptext_idx = HELPTEXT_CHIPSET;\n\t\tmenumask = 0x3FF;\n\t\tOsdSetTitle(\"System\");\n\t\tparentstate = menustate;\n\n\t\tm = 0;\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tstrcpy(s, \" CPU      : \");\n\t\tstrcat(s, config_cpu_msg[minimig_config.cpu & 0x03]);\n\t\tOsdWrite(m++, s, menusub == 0, 0);\n\t\tstrcpy(s, \" D-Cache  : \");\n\t\tstrcat(s, (minimig_config.cpu & 16) ? \"ON\" : \"OFF\");\n\t\tOsdWrite(m++, s, menusub == 1, !(minimig_config.cpu & 0x2));\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tstrcpy(s, \" Chipset  : \");\n\t\tstrcat(s, config_chipset_msg[(minimig_config.chipset >> 2) & 7]);\n\t\tOsdWrite(m++, s, menusub == 2, 0);\n\t\tstrcpy(s, \" ChipRAM  : \");\n\t\tstrcat(s, config_memory_chip_msg[minimig_config.memory & 0x03]);\n\t\tOsdWrite(m++, s, menusub == 3, 0);\n\t\tstrcpy(s, \" FastRAM  : \");\n\t\tstrcat(s, config_memory_fast_msg[(minimig_config.cpu >> 1) & 1][((minimig_config.memory >> 4) & 0x03) | ((minimig_config.memory & 0x80) >> 5)]);\n\t\tOsdWrite(m++, s, menusub == 4, 0);\n\t\tstrcpy(s, \" SlowRAM  : \");\n\t\tstrcat(s, config_memory_slow_msg[(minimig_config.memory >> 2) & 0x03]);\n\t\tOsdWrite(m++, s, menusub == 5, 0);\n\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tstrcpy(s, \" Joystick : \");\n\t\tstrcat(s, config_joystick_mode[(minimig_config.autofire & 6) >> 1]);\n\t\tOsdWrite(m++, s, menusub == 6, 0);\n\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tstrcpy(s, \" ROM    : \");\n\t\t{\n\t\t\tchar *path = HomeDir();\n\t\t\tint len = strlen(path);\n\t\t\tchar *name = minimig_config.kickstart;\n\t\t\tif (!strncasecmp(name, path, len))  name += len + 1;\n\t\t\tstrncat(&s[3], name, 24);\n\t\t}\n\n\t\tOsdWrite(m++, s, menusub == 7, 0);\n\t\tstrcpy(s, \" HRTmon : \");\n\t\tstrcat(s, (minimig_config.memory & 0x40) ? \"enabled \" : \"disabled\");\n\t\tOsdWrite(m++, s, menusub == 8, 0);\n\n\t\tfor (int i = m; i < OsdGetSize() - 1; i++) OsdWrite(i, \"\", 0, 0);\n\t\tOsdWrite(OsdGetSize() - 1, STD_BACK, menusub == 9, 0);\n\n\t\tmenustate = MENU_MINIMIG_CHIPSET2;\n\t\tbreak;\n\n\tcase MENU_MINIMIG_CHIPSET2:\n\t\tsaved_menustate = MENU_MINIMIG_CHIPSET1;\n\n\t\tif (select || minus || plus)\n\t\t{\n\t\t\tif (menusub == 0)\n\t\t\t{\n\t\t\t\tint cpu = minimig_config.cpu & 3;\n\t\t\t\tif (minus)\n\t\t\t\t{\n\t\t\t\t\tcpu = (cpu == 0) ? 3 : (cpu == 3) ? 1 : 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcpu = (cpu == 0) ? 1 : (cpu == 1) ? 3 : 0;\n\t\t\t\t}\n\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t\tminimig_config.cpu = (minimig_config.cpu & 0xfc) | cpu;\n\t\t\t\tminimig_ConfigCPU(minimig_config.cpu);\n\t\t\t}\n\t\t\telse if (menusub == 1 && (minimig_config.cpu & 0x2))\n\t\t\t{\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t\tminimig_config.cpu ^= 16;\n\t\t\t\tminimig_ConfigCPU(minimig_config.cpu);\n\t\t\t}\n\t\t\telse if (menusub == 2)\n\t\t\t{\n\t\t\t\tif (minus)\n\t\t\t\t{\n\t\t\t\t\tswitch (minimig_config.chipset & 0x1c)\n\t\t\t\t\t{\n\t\t\t\t\tcase (CONFIG_AGA | CONFIG_ECS):\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | CONFIG_ECS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CONFIG_ECS:\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | CONFIG_A1000;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CONFIG_A1000:\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | CONFIG_AGA | CONFIG_ECS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tswitch (minimig_config.chipset & 0x1c)\n\t\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | CONFIG_A1000;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CONFIG_A1000:\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | CONFIG_ECS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CONFIG_ECS:\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | CONFIG_AGA | CONFIG_ECS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase (CONFIG_AGA | CONFIG_ECS):\n\t\t\t\t\t\tminimig_config.chipset = (minimig_config.chipset & 3) | 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t\tminimig_ConfigChipset(minimig_config.chipset);\n\t\t\t}\n\t\t\telse if (menusub == 3)\n\t\t\t{\n\t\t\t\tminimig_config.memory = ((minimig_config.memory + (minus ? -1 : 1)) & 0x03) | (minimig_config.memory & ~0x03);\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t}\n\t\t\telse if (menusub == 4)\n\t\t\t{\n\t\t\t\tint c = (((minimig_config.memory >> 4) & 0x03) | ((minimig_config.memory & 0x80) >> 5));\n\t\t\t\tif (minus)\n\t\t\t\t{\n\t\t\t\t\tc--;\n\t\t\t\t\tif (c < 0) c = 5;\n\t\t\t\t\tif (!(minimig_config.cpu & 2) && c > 3) c = 3;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tc++;\n\t\t\t\t\tif (c > 5) c = 0;\n\t\t\t\t\tif (!(minimig_config.cpu & 2) && c > 3) c = 0;\n\t\t\t\t}\n\t\t\t\tminimig_config.memory = ((c << 4) & 0x30) | ((c << 5) & 0x80) | (minimig_config.memory & ~0xB0);\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t}\n\t\t\telse if (menusub == 5)\n\t\t\t{\n\t\t\t\tminimig_config.memory = ((minimig_config.memory + (minus ? -4 : 4)) & 0x0C) | (minimig_config.memory & ~0x0C);\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t}\n\t\t\telse if (menusub == 6)\n\t\t\t{\n\t\t\t\tuint8_t x = (minimig_config.autofire & 6) >> 1;\n\t\t\t\tif (minus)\n\t\t\t\t{\n\t\t\t\t\tx = (x - 1) & 3;\n\t\t\t\t\tif (x == 3) x = 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tx = (x + 1) & 3;\n\t\t\t\t\tif (x == 3) x = 0;\n\t\t\t\t}\n\n\t\t\t\tminimig_config.autofire = (minimig_config.autofire & ~6) | (x << 1);\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t\tminimig_ConfigAutofire(minimig_config.autofire, 6);\n\t\t\t}\n\t\t\telse if (menusub == 7 && select)\n\t\t\t{\n\t\t\t\tioctl_index = 1;\n\t\t\t\tSelectFile(Selected_F[4], \"ROM\", SCANO_DIR, MENU_MINIMIG_ROMFILE_SELECTED, MENU_MINIMIG_CHIPSET1);\n\t\t\t}\n\t\t\telse if (menusub == 8)\n\t\t\t{\n\t\t\t\tminimig_config.memory ^= 0x40;\n\t\t\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\t\t}\n\t\t\telse if (menusub == 9)\n\t\t\t{\n\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\tmenusub = 6;\n\t\t\t}\n\t\t}\n\n\t\tif (menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\telse if (back || left)\n\t\t{\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\tmenusub = 6;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_ROMFILE_SELECTED:\n\t\tmemcpy(Selected_F[4], selPath, sizeof(Selected_F[4]));\n\t\tminimig_set_kickstart(selPath);\n\t\tmenustate = MENU_MINIMIG_CHIPSET1;\n\t\tbreak;\n\n\tcase MENU_MINIMIG_DISK1:\n\t\thelptext_idx = HELPTEXT_HARDFILE;\n\t\tOsdSetTitle(\"Drives\");\n\n\t\tm = 0;\n\t\tparentstate = menustate;\n\t\tmenumask = 0xC01;\n\t\tif (minimig_config.ide_cfg & 1) menumask |= 0x156;\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tstrcpy(s, \" IDE A600/A1200    : \");\n\t\tstrcat(s, (minimig_config.ide_cfg & 1) ? \"On \" : \"Off\");\n\t\tOsdWrite(m++, s, menusub == 0, 0);\n\t\tstrcpy(s, \" Fast-IDE (68020)  : \");\n\t\tstrcat(s, (minimig_config.ide_cfg & 0x20) ? \"Off\" : \"On\");\n\t\tOsdWrite(m++, s, menusub == 1,  !(minimig_config.ide_cfg & 1) || !(minimig_config.cpu & 2));\n\t\tif (!(minimig_config.cpu & 2)) menumask &= ~2;\n\t\tOsdWrite(m++);\n\n\t\t{\n\t\t\tuint n = 2, t = 8;\n\t\t\tfor (uint i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tstrcpy(s, (i & 2) ? \" Sec. \" : \" Pri. \");\n\t\t\t\tstrcat(s, (i & 1) ? \" Slave: \" : \"Master: \");\n\t\t\t\tstrcat(s, (minimig_config.hardfile[i].cfg == 2) ? \"Removable/CD\" : minimig_config.hardfile[i].cfg ? \"Fixed/HDD\" : \"Disabled\");\n\t\t\t\tOsdWrite(m++, s, (minimig_config.ide_cfg & 1) ? (menusub == n++) : 0, !(minimig_config.ide_cfg & 1));\n\t\t\t\tif (minimig_config.hardfile[i].filename[0])\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, \"                                \");\n\t\t\t\t\tchar *path = HomeDir();\n\t\t\t\t\tint len = strlen(path);\n\t\t\t\t\tchar *name = minimig_config.hardfile[i].filename;\n\t\t\t\t\tif (!strncasecmp(name, path, len))  name += len + 1;\n\t\t\t\t\tstrncpy(&s[3], name, 25);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstrcpy(s, \"   ** not selected **\");\n\t\t\t\t}\n\t\t\t\tenable = (minimig_config.ide_cfg & 1) && minimig_config.hardfile[i].cfg;\n\t\t\t\tif (enable) menumask |= t;\t// Make hardfile selectable\n\t\t\t\tOsdWrite(m++, s, menusub == n++, enable == 0);\n\t\t\t\tt <<= 2;\n\t\t\t\tif(i == 1) OsdWrite(m++);\n\t\t\t}\n\t\t}\n\n\t\tOsdWrite(m++);\n\t\tsprintf(s, \" Floppy Disk Turbo : %s\", minimig_config.floppy.speed ? \"On\" : \"Off\");\n\t\tOsdWrite(m++, s, menusub == 10, 0);\n\t\tOsdWrite(m++);\n\n\t\tOsdWrite(OsdGetSize() - 1, STD_BACK, menusub == 11, 0);\n\t\tmenustate = MENU_MINIMIG_DISK2;\n\t\tbreak;\n\n\tcase MENU_MINIMIG_DISK2:\n\t\tsaved_menustate = MENU_MINIMIG_DISK1;\n\n\t\tif (select || recent || minus || plus)\n\t\t{\n\t\t\tif (menusub == 0)\n\t\t\t{\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tminimig_config.ide_cfg ^= 1;\n\t\t\t\t\tmenustate = MENU_MINIMIG_DISK1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (menusub == 1)\n\t\t\t{\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tminimig_config.ide_cfg ^= 0x20;\n\t\t\t\t\tmenustate = MENU_MINIMIG_DISK1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (menusub < 10)\n\t\t\t{\n\t\t\t\tif (!(menusub & 1))\n\t\t\t\t{\n\t\t\t\t\tif (select || minus || plus)\n\t\t\t\t\t{\n\t\t\t\t\t\tint idx = (menusub - 2) / 2;\n\t\t\t\t\t\tif (minus)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!minimig_config.hardfile[idx].cfg) minimig_config.hardfile[idx].cfg = 2;\n\t\t\t\t\t\t\telse minimig_config.hardfile[idx].cfg--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tminimig_config.hardfile[idx].cfg++;\n\t\t\t\t\t\t\tif (minimig_config.hardfile[idx].cfg > 2) minimig_config.hardfile[idx].cfg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmenustate = MENU_MINIMIG_DISK1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(select || recent)\n\t\t\t\t{\n\t\t\t\t\tfs_Options = SCANO_DIR | SCANO_UMOUNT;\n\t\t\t\t\tfs_MenuSelect = MENU_MINIMIG_HDFFILE_SELECTED;\n\t\t\t\t\tfs_MenuCancel = MENU_MINIMIG_DISK1;\n\t\t\t\t\tint idx = (menusub - 3) / 2;\n\t\t\t\t\tstrcpy(fs_pFileExt, (minimig_config.hardfile[idx].cfg == 2) ? \"ISOCUECHDIMG\" : \"HDFVHDIMGDSK\");\n\t\t\t\t\tif (select)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Selected_S[idx][0]) memcpy(Selected_S[idx], minimig_config.hardfile[idx].filename, sizeof(Selected_S[idx]));\n\t\t\t\t\t\tSelectFile(Selected_S[idx], fs_pFileExt, fs_Options, fs_MenuSelect, fs_MenuCancel);\n\t\t\t\t\t}\n\t\t\t\t\telse if (recent_init(500)) menustate = MENU_RECENT1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (menusub == 10 && select) // return to previous menu\n\t\t\t{\n\t\t\t\tminimig_config.floppy.speed ^= 1;\n\t\t\t\tminimig_ConfigFloppy(minimig_config.floppy.drives, minimig_config.floppy.speed);\n\t\t\t\tmenustate = MENU_MINIMIG_DISK1;\n\t\t\t}\n\t\t\telse if (menusub == 11 && select) // return to previous menu\n\t\t\t{\n\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\tmenusub = 5;\n\t\t\t}\n\t\t}\n\n\t\tif (menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\telse if (back || left)\n\t\t{\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\tmenusub = 5;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_HDFFILE_SELECTED:\n\t\t{\n\t\t\tmemcpy(Selected_S[(menusub - 2) / 2], selPath, sizeof(Selected_S[(menusub - 2) / 2]));\n\t\t\trecent_update(SelectedDir, selPath, SelectedLabel, 500);\n\t\t\tint num = (menusub - 2) / 2;\n\t\t\tuint len = strlen(selPath);\n\t\t\tif (len > sizeof(minimig_config.hardfile[num].filename) - 1) len = sizeof(minimig_config.hardfile[num].filename) - 1;\n\t\t\tif(len) memcpy(minimig_config.hardfile[num].filename, selPath, len);\n\t\t\tminimig_config.hardfile[num].filename[len] = 0;\n\n\t\t\tif (ide_is_placeholder(num))\n\t\t\t{\n\t\t\t\tide_open(num, minimig_config.hardfile[num].filename);\n\t\t\t}\n\n\t\t\tmenustate = MENU_MINIMIG_DISK1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_MINIMIG_VIDEO1:\n\t\tmenumask = 0x1fff;\n\t\tparentstate = menustate;\n\t\thelptext_idx = 0; // helptexts[HELPTEXT_VIDEO];\n\n\t\tm = 0;\n\t\tOsdSetTitle(\"Audio & Video\");\n\n\t\tstrcpy(s, \" TV Standard   : \");\n\t\tstrcat(s, minimig_config.chipset & CONFIG_NTSC ? \"NTSC\" : \"PAL\");\n\t\tOsdWrite(m++, s, menusub == 0, 0);\n\t\tOsdWrite(m++, \"\", 0, 0);\n\t\tstrcpy(s, \" Scandoubler FX: \");\n\t\tstrcat(s, config_scanlines_msg[minimig_config.scanlines & 7]);\n\t\tOsdWrite(m++, s, menusub == 1, 0);\n\t\tstrcpy(s, \" Video area by : \");\n\t\tstrcat(s, config_blank_msg[(minimig_config.scanlines >> 6) & 3]);\n\t\tOsdWrite(m++, s, menusub == 2, 0);\n\t\tstrcpy(s, \" Aspect Ratio  : \");\n\t\tminimig_config.scanlines = (get_ar_name((minimig_config.scanlines >> 4) & 3, s) << 4) | (minimig_config.scanlines & ~0x30);\n\t\tOsdWrite(m++, s, menusub == 3, 0);\n\t\tstrcpy(s, \" Pixel Clock   : \");\n\t\tstrcat(s, (minimig_get_extcfg() & 0x400) ? \"Adaptive\" : \"28MHz\");\n\t\tOsdWrite(m++, s, menusub == 4, 0);\n\t\tstrcpy(s, \" Scaling       : \");\n\t\tstrcat(s,config_scale[(minimig_get_extcfg() >> 11) & 7]);\n\t\tOsdWrite(m++, s, menusub == 5, 0);\n\t\tstrcpy(s, \" RTG Upscaling : \");\n\t\tstrcat(s, (minimig_get_extcfg() & 0x4000) ? \"HV-Integer\" : \"Normal\");\n\t\tOsdWrite(m++, s, menusub == 6, 0);\n\n\t\tOsdWrite(m++);\n\t\tstrcpy(s, \" Stereo mix    : \");\n\t\tstrcat(s, config_stereo_msg[minimig_config.audio & 3]);\n\t\tOsdWrite(m++, s, menusub == 7, 0);\n\t\tstrcpy(s, \" Audio Filter  : \");\n\t\tstrcat(s, (~minimig_get_extcfg() & 0x10000) ? \"Auto(LED)\" : (minimig_get_extcfg() & 0x8000) ? \"On\" : \"Off\");\n\t\tOsdWrite(m++, s, menusub == 8, 0);\n\t\tstrcpy(s, \" Model         : \");\n\t\tstrcat(s, (minimig_get_extcfg() & 0x20000) ? \"A1200\" : \"A500\");\n\t\tOsdWrite(m++, s, menusub == 9, 0);\n\t\tstrcpy(s, \" Paula Output  : \");\n\t\tstrcat(s, (minimig_get_extcfg() & 0x40000) ? \"PWM\" : \"Normal\");\n\t\tOsdWrite(m++, s, menusub == 10, 0);\n\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, minimig_get_adjust() ? \" Finish screen adjustment\" : \" Adjust screen position\", menusub == 11, 0);\n\t\tfor (; m < OsdGetSize() - 1; m++) OsdWrite(m);\n\t\tOsdWrite(OsdGetSize() - 1, STD_BACK, menusub == 12, 0);\n\n\t\tmenustate = MENU_MINIMIG_VIDEO2;\n\t\tbreak;\n\n\tcase MENU_MINIMIG_VIDEO2:\n\t\tsaved_menustate = MENU_MINIMIG_VIDEO1;\n\t\tif (select || minus || plus)\n\t\t{\n\t\t\tmenustate = MENU_MINIMIG_VIDEO1;\n\t\t\tswitch(menusub)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tminimig_config.chipset ^= CONFIG_NTSC;\n\t\t\t\tminimig_ConfigChipset(minimig_config.chipset);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t{\n\t\t\t\t\tint scanlines = minimig_config.scanlines & 7;\n\t\t\t\t\tif (minus)\n\t\t\t\t\t{\n\t\t\t\t\t\tscanlines--;\n\t\t\t\t\t\tif (scanlines < 0) scanlines = 4;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tscanlines++;\n\t\t\t\t\t\tif (scanlines > 4) scanlines = 0;\n\t\t\t\t\t}\n\t\t\t\t\tminimig_config.scanlines = scanlines | (minimig_config.scanlines & 0xf8);\n\t\t\t\t\tminimig_ConfigVideo(minimig_config.scanlines);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tminimig_config.scanlines &= ~0x80;\n\t\t\t\tminimig_config.scanlines ^= 0x40;\n\t\t\t\tminimig_ConfigVideo(minimig_config.scanlines);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tminimig_config.scanlines = (next_ar((minimig_config.scanlines >> 4) & 3, minus) << 4) | (minimig_config.scanlines & ~0x30);\n\t\t\t\tminimig_ConfigVideo(minimig_config.scanlines);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tminimig_set_extcfg(minimig_get_extcfg() ^ 0x400);\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\t{\n\t\t\t\t\tint mode = (minimig_get_extcfg() >> 11) & 7;\n\t\t\t\t\tif (minus) mode = (mode <= 0) ? 4 : (mode - 1);\n\t\t\t\t\telse mode = (mode >= 4) ? 0 : (mode + 1);\n\t\t\t\t\tminimig_set_extcfg((minimig_get_extcfg() & ~0x3800) | (mode << 11));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tminimig_set_extcfg(minimig_get_extcfg() ^ 0x4000);\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tminimig_config.audio = (minimig_config.audio + (minus ? -1 : 1)) & 3;\n\t\t\t\tminimig_ConfigAudio(minimig_config.audio);\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\t{\n\t\t\t\t\tint mode = (minimig_get_extcfg() >> 15) & 3;\n\t\t\t\t\tif (minus) mode = (mode == 2) ? 0 : (mode - 1);\n\t\t\t\t\telse mode = (mode == 0) ? 2 : (mode + 1);\n\t\t\t\t\tminimig_set_extcfg((minimig_get_extcfg() & ~0x18000) | ((mode & 3) << 15));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\t\tminimig_set_extcfg(minimig_get_extcfg() ^ 0x20000);\n\t\t\t\tbreak;\n\n\t\t\tcase 10:\n\t\t\t\tminimig_set_extcfg(minimig_get_extcfg() ^ 0x40000);\n\t\t\t\tbreak;\n\n\t\t\tcase 11:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t\tminimig_set_adjust(minimig_get_adjust() ? 0 : 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 12:\n\t\t\t\tif (select)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\t\t\tmenusub = 7;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\telse if (back || left)\n\t\t{\n\t\t\tmenustate = MENU_MINIMIG_MAIN1;\n\t\t\tmenusub = 7;\n\t\t}\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* system menu */\n\t\t/******************************************************************/\n\tcase MENU_SYSTEM1:\n\t\tif (video_fb_state())\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t\tbreak;\n\t\t}\n\n\t\tOsdSetSize(16);\n\t\thelptext_idx = 0;\n\t\tparentstate = menustate;\n\n\t\tm = 0;\n\t\tOsdSetTitle(\"System Settings\", OSD_ARROW_LEFT);\n\t\tmenumask = 0x7F;\n\n\t\tOsdWrite(m++);\n\t\tsprintf(s, \"       MiSTer v%s\", version + 5);\n\t\t{\n\t\t\tchar str[8] = {};\n\t\t\tFILE *f = fopen(\"/MiSTer.version\", \"r\");\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tif (fread(str, 6, 1, f)) sprintf(s, \" MiSTer v%s,  OS v%s\", version + 5, str);\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t}\n\n\t\tOsdWrite(m++, s);\n\n\t\t{\n\t\t\tuint64_t avail = 0;\n\t\t\tstruct statvfs buf;\n\t\t\tmemset(&buf, 0, sizeof(buf));\n\t\t\tif (!statvfs(getRootDir(), &buf)) avail = buf.f_bsize * buf.f_bavail;\n\t\t\tif(avail < (10ull*1024*1024*1024)) sprintf(s, \"   Available space: %llumb\", avail / (1024 * 1024));\n\t\t\telse sprintf(s, \"   Available space: %llugb\", avail / (1024 * 1024 * 1024));\n\t\t\tOsdWrite(m+2, s, 0, 0);\n\t\t}\n\n\t\tOsdWrite(m++, \"\");\n\t\tif (getStorage(0))\n\t\t{\n\t\t\tOsdWrite(m++, \"        Storage: USB\");\n\t\t\tm++;\n\t\t\tOsdWrite(m++, \"      Switch to SD card\", menusub == 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (getStorage(1))\n\t\t\t{\n\t\t\t\tOsdWrite(m++, \" No USB found, using SD card\");\n\t\t\t\tm++;\n\t\t\t\tOsdWrite(m++, \"      Switch to SD card\", menusub == 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOsdWrite(m++, \"      Storage: SD card\");\n\t\t\t\tm++;\n\t\t\t\tOsdWrite(m++, \"        Switch to USB\", menusub == 0, !isUSBMounted());\n\t\t\t}\n\t\t}\n\t\tOsdWrite(m++, \"\");\n\t\tOsdWrite(m++, \" Remap keyboard            \\x16\", menusub == 1);\n\t\tOsdWrite(m++, \" Define joystick buttons   \\x16\", menusub == 2);\n\t\tOsdWrite(m++, \" Scripts                   \\x16\", menusub == 3);\n\t\tOsdWrite(m++, \" Help                      \\x16\", menusub == 4);\n\t\tOsdWrite(m++, \"\");\n\t\tcr = m;\n\t\tOsdWrite(m++, \" Reboot (hold \\x16 cold reboot)\", menusub == 5);\n\t\tsysinfo_timer = 0;\n\n\t\treboot_req = 0;\n\n\t\twhile(m < OsdGetSize()-1) OsdWrite(m++, \"\");\n\t\tOsdWrite(15, STD_EXIT, menusub == 6);\n\t\tmenustate = MENU_SYSTEM2;\n\t\tbreak;\n\n\tcase MENU_SYSTEM2:\n\t\tif (menu)\n\t\t{\n\t\t\tSelectFile(\"\", 0, SCANO_CORES, MENU_CORE_FILE_SELECTED1, MENU_SYSTEM1);\n\t\t\tbreak;\n\t\t}\n\t\telse if (select)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tif (getStorage(1) || isUSBMounted()) setStorage(!getStorage(1));\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tstart_map_setting(0);\n\t\t\t\tmenustate = MENU_KBDMAP;\n\t\t\t\tmenusub = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tmenustate = MENU_JOYSYSMAP;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t{\n\t\t\t\t\tuint8_t confirm[32] = {};\n\t\t\t\t\tint match = 0;\n\t\t\t\t\tint fd = open(\"/sys/block/mmcblk0/device/cid\", O_RDONLY);\n\t\t\t\t\tif (fd >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ret = read(fd, card_cid, 32);\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\tif (ret == 32)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (FileLoadConfig(\"script_confirm\", confirm, 32))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmatch = !memcmp(card_cid, confirm, 32);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match) SelectFile(Selected_F[0], \"SH\", SCANO_DIR, MENU_SCRIPTS_FB, MENU_SYSTEM1);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmenustate = MENU_SCRIPTS_PRE;\n\t\t\t\t\t\tmenusub = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tstrcpy(Selected_tmp, DOCS_DIR);\n\t\t\t\tFileCreatePath(Selected_tmp);\n\t\t\t\tSelectFile(Selected_tmp, \"PDFTXTMD \", SCANO_DIR | SCANO_TXT, MENU_DOC_FILE_SELECTED, MENU_NONE1);\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\t\t{\n\t\t\t\t\treboot_req = 1;\n\n\t\t\t\t\tint off = hold_cnt / 3;\n\t\t\t\t\tif (off > 5) reboot(1);\n\n\t\t\t\t\tsprintf(s, \" Cold Reboot\");\n\t\t\t\t\tp = s + 5 - off;\n\t\t\t\t\tMenuWrite(cr, p, 1, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (left)\n\t\t{\n\t\t\tmenustate = MENU_MISC1;\n\t\t}\n\n\t\tif (!hold_cnt && reboot_req) fpga_load_rbf(\"menu.rbf\");\n\t\tbreak;\n\n\tcase MENU_JOYSYSMAP:\n\t\tstrcpy(joy_bnames[SYS_BTN_A - DPAD_NAMES], \"A\");\n\t\tstrcpy(joy_bnames[SYS_BTN_B - DPAD_NAMES], \"B\");\n\t\tstrcpy(joy_bnames[SYS_BTN_X - DPAD_NAMES], \"X\");\n\t\tstrcpy(joy_bnames[SYS_BTN_Y - DPAD_NAMES], \"Y\");\n\t\tstrcpy(joy_bnames[SYS_BTN_L - DPAD_NAMES], \"L\");\n\t\tstrcpy(joy_bnames[SYS_BTN_R - DPAD_NAMES], \"R\");\n\t\tstrcpy(joy_bnames[SYS_BTN_SELECT - DPAD_NAMES], \"Select\");\n\t\tstrcpy(joy_bnames[SYS_BTN_START - DPAD_NAMES], \"Start\");\n\t\tstrcpy(joy_bnames[SYS_MS_RIGHT - DPAD_NAMES], \"Mouse Move RIGHT\");\n\t\tstrcpy(joy_bnames[SYS_MS_LEFT - DPAD_NAMES], \"Mouse Move LEFT\");\n\t\tstrcpy(joy_bnames[SYS_MS_DOWN - DPAD_NAMES], \"Mouse Move DOWN\");\n\t\tstrcpy(joy_bnames[SYS_MS_UP - DPAD_NAMES], \"Mouse Move UP\");\n\t\tstrcpy(joy_bnames[SYS_MS_BTN_L - DPAD_NAMES], \"Mouse Btn Left\");\n\t\tstrcpy(joy_bnames[SYS_MS_BTN_R - DPAD_NAMES], \"Mouse Btn Right\");\n\t\tstrcpy(joy_bnames[SYS_MS_BTN_M - DPAD_NAMES], \"Mouse Btn Middle\");\n\t\tstrcpy(joy_bnames[SYS_MS_BTN_EMU - DPAD_NAMES], \"Mouse Emu/Sniper\");\n\t\tstrcpy(joy_bnames[SYS_BTN_OSD_KTGL - DPAD_NAMES], \"Menu\");\n\t\tstrcpy(joy_bnames[SYS_BTN_CNT_OK - DPAD_NAMES], \"Menu: OK\");\n\t\tstrcpy(joy_bnames[SYS_BTN_CNT_ESC - DPAD_NAMES], \"Menu: Back\");\n\t\tjoy_bcount = 20 + 1; //buttons + OSD/KTGL button\n\t\tstart_map_setting(joy_bcount + 6); // + dpad + Analog X/Y\n\t\tmenustate = MENU_JOYDIGMAP;\n\t\tmenusub = 0;\n\t\tbreak;\n\n\tcase MENU_LGCAL:\n\t\thelptext_idx = 0;\n\t\tOsdSetTitle(\"Lightgun Calibration\", 0);\n\t\tfor (int i = 0; i < OsdGetSize(); i++) OsdWrite(i);\n\t\tOsdWrite(9,  \"     Point to the edge of\");\n\t\tOsdWrite(10, \"   screen and press trigger\");\n\t\tOsdWrite(11, \"         to confirm\");\n\t\tOsdWrite(OsdGetSize() - 1, \"           Cancel\", menusub == 0, 0);\n\t\tgun_ok = 0;\n\t\tgun_side = 0;\n\t\tgun_y = 0;\n\t\tgun_x = 0;\n\t\tmemset(gun_pos, 0, sizeof(gun_pos));\n\t\tmenustate = MENU_LGCAL1;\n\t\tmenusub = 0;\n\t\tbreak;\n\n\tcase MENU_LGCAL1:\n\t\t{\n\t\t\tstatic int state = 0;\n\t\t\tstatic uint32_t blink = 0;\n\t\t\tif (!blink || CheckTimer(blink))\n\t\t\t{\n\t\t\t\tblink = GetTimer(300);\n\t\t\t\tstate = !state;\n\t\t\t}\n\n\t\t\tm = !state;\n\t\t}\n\n\t\tif (gun_side < 4) gun_pos[gun_side] = (gun_side < 2) ? gun_y : gun_x;\n\t\tsprintf(s, \"           %c%04d%c\", (gun_side == 0 && m) ? 17 : 32, (gun_side == 0) ? gun_y : gun_pos[0], (gun_side == 0 && m) ? 16 : 32);\n\t\tOsdWrite(0, s);\n\t\tsprintf(s, \"%c%04d%c                 %c%04d%c\", (gun_side == 2 && m) ? 17 : 32, (gun_side == 2) ? gun_x : gun_pos[2], (gun_side == 2 && m) ? 16 : 32,\n\t\t                                                (gun_side == 3 && m) ? 17 : 32, (gun_side == 3) ? gun_x : gun_pos[3], (gun_side == 3 && m) ? 16 : 32);\n\t\tOsdWrite(7, s);\n\t\tsprintf(s, \"           %c%04d%c\", (gun_side == 1 && m) ? 17 : 32, (gun_side == 1) ? gun_y : gun_pos[1], (gun_side == 1 && m) ? 16 : 32);\n\t\tOsdWrite(13, s);\n\t\tif (menu || select) menustate = MENU_NONE1;\n\n\t\tif (gun_ok == 1)\n\t\t{\n\t\t\tgun_ok = 0;\n\t\t\tgun_side++;\n\t\t}\n\n\t\tif (gun_ok == 2)\n\t\t{\n\t\t\tgun_ok = 0;\n\t\t\tif (gun_side == 4)\n\t\t\t{\n\t\t\t\tinput_lightgun_save(gun_idx, gun_pos);\n\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_SCRIPTS_PRE:\n\t\tOsdSetTitle(\"Warning!!!\", 0);\n\t\thelptext_idx = 0;\n\t\tmenumask = 7;\n\t\tm = 0;\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \"         Attention:\");\n\t\tOsdWrite(m++, \" This is dangerous operation!\");\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \" Script has control over the\");\n\t\tOsdWrite(m++, \" whole system and may damage\");\n\t\tOsdWrite(m++, \" the files or settings, then\");\n\t\tOsdWrite(m++, \" MiSTer won't boot, so you\");\n\t\tOsdWrite(m++, \" will have to re-format the\");\n\t\tOsdWrite(m++, \" SD card and fill with files\");\n\t\tOsdWrite(m++, \" in order to use it again.\");\n\t\tOsdWrite(m++);\n\t\tOsdWrite(m++, \"  Do you want to continue?\");\n\t\tOsdWrite(m++, \"            No\", menusub == 0);\n\t\tOsdWrite(m++, \"            Yes\", menusub == 1);\n\t\tOsdWrite(m++, \"  Yes, and don't ask again\", menusub == 2);\n\t\tmenustate = MENU_SCRIPTS_PRE1;\n\t\tparentstate = MENU_SCRIPTS_PRE;\n\t\tbreak;\n\n\tcase MENU_SCRIPTS_PRE1:\n\t\tif (menu) menustate = MENU_SYSTEM1;\n\t\telse if (select)\n\t\t{\n\t\t\tswitch (menusub)\n\t\t\t{\n\t\t\tcase 0:\n\t\t\t\tmenustate = MENU_SYSTEM1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tFileSaveConfig(\"script_confirm\", card_cid, 32);\n\t\t\t\t// fall through\n\n\t\t\tcase 1:\n\t\t\t\tSelectFile(Selected_F[0], \"SH\", SCANO_DIR, MENU_SCRIPTS_FB, MENU_SYSTEM1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_SCRIPTS_FB:\n\t\tif (cfg.fb_terminal)\n\t\t{\n\t\t\tmemcpy(Selected_F[0], selPath, sizeof(Selected_F[0]));\n\t\t\tstatic char cmd[1024 * 2];\n\t\t\tconst char *path = getFullPath(selPath);\n\t\t\tmenustate = MENU_SCRIPTS_FB2;\n\t\t\tvideo_chvt(2);\n\t\t\tvideo_fb_enable(1);\n\t\t\tvga_nag();\n\t\t\tsprintf(cmd, \"#!/bin/bash\\nexport LC_ALL=en_US.UTF-8\\nexport HOME=/root\\ncd $(dirname %s)\\n%s\\necho \\\"Press any key to continue\\\"\\n\", path, path);\n\n\t\t\tunlink(\"/tmp/script\");\n\t\t\tFileSave(\"/tmp/script\", cmd, strlen(cmd));\n\t\t\tttypid = fork();\n\t\t\tif (!ttypid)\n\t\t\t{\n\t\t\t\texecl(\"/sbin/agetty\", \"/sbin/agetty\", \"-a\", \"root\", \"-l\", \"/tmp/script\", \"--nohostname\", \"-L\", \"tty2\", \"linux\", NULL);\n\t\t\t\texit(0); //should never be reached\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmenustate = MENU_SCRIPTS;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_SCRIPTS_FB2:\n\t\tif (ttypid)\n\t\t{\n\t\t\tif (waitpid(ttypid, 0, WNOHANG) > 0)\n\t\t\t{\n\t\t\t\tttypid = 0;\n\t\t\t\tuser_io_osd_key_enable(1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (c & UPSTROKE)\n\t\t\t{\n\t\t\t\tvideo_menu_bg(user_io_status_get(\"[3:1]\"));\n\t\t\t\tvideo_fb_enable(0);\n\t\t\t\tmenustate = MENU_SYSTEM1;\n\t\t\t\tmenusub = 3;\n\t\t\t\tOsdClear();\n\t\t\t\tOsdEnable(DISABLE_KEYBOARD);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_BTPAIR2:\n\t\tif (select || menu)\n\t\t{\n\t\t\tmenustate = MENU_NONE1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_BTPAIR:\n\t\tOsdSetSize(16);\n\t\tOsdEnable(DISABLE_KEYBOARD);\n\t\tparentstate = MENU_BTPAIR;\n\t\tOsdSetTitle(\"BT Pairing\");\n\t\tif (hci_get_route(0) < 0)\n\t\t{\n\t\t\thelptext_idx = 0;\n\t\t\tmenumask = 1;\n\t\t\tmenusub = 0;\n\t\t\tfor (int i = 0; i < OsdGetSize() - 1; i++) OsdWrite(i);\n\t\t\tOsdWrite(7, \"    No Bluetooth available\");\n\t\t\tOsdWrite(OsdGetSize() - 1, STD_EXIT, menusub == 0);\n\t\t\tmenustate = MENU_BTPAIR2;\n\t\t\tbreak;\n\t\t}\n\t\t//fall through\n\n\tcase MENU_SCRIPTS:\n\t\thelptext_idx = 0;\n\t\tmenumask = 0;\n\t\tmenusub = 0;\n\t\tif(parentstate != MENU_BTPAIR) OsdSetTitle(flist_SelectedItem()->de.d_name);\n\t\tmenustate = MENU_SCRIPTS1;\n\t\tif (parentstate != MENU_BTPAIR) parentstate = MENU_SCRIPTS;\n\t\tfor (int i = 0; i < OsdGetSize() - 1; i++) OsdWrite(i);\n\t\tOsdWrite(OsdGetSize() - 1, (parentstate == MENU_BTPAIR) ? \"           Finish\" : \"           Cancel\", menusub == 0, 0);\n\t\tfor (int i = 0; i < script_lines; i++) strcpy(script_output[i], \"\");\n\t\tscript_line=0;\n\t\tscript_finished = false;\n\t\tcpu_set_t set;\n\t\tCPU_ZERO(&set);\n\t\tCPU_SET(0, &set);\n\t\tCPU_SET(1, &set);\n\t\tsched_setaffinity(0, sizeof(set), &set);\n\t\tif (parentstate == MENU_BTPAIR)\n\t\t{\n\t\t\tOsdUpdate();\n\t\t\tif(cfg.bt_reset_before_pair) system(\"hciconfig hci0 reset\");\n\t\t\tscript_pipe = popen(\"/usr/sbin/btpair\", \"r\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscript_pipe = popen(getFullPath(selPath), \"r\");\n\t\t}\n\t\tscript_file = fileno(script_pipe);\n\t\tfcntl(script_file, F_SETFL, O_NONBLOCK);\n\t\tbreak;\n\n\tcase MENU_SCRIPTS1:\n\t\tif (!script_finished)\n\t\t{\n\t\t\tif (!feof(script_pipe)) {\n\t\t\t\tif (fgets(script_line_output, script_line_length, script_pipe) != NULL)\n\t\t\t\t{\n\t\t\t\t\tscript_line_output[strcspn(script_line_output, \"\\n\")] = 0;\n\t\t\t\t\tif (script_line < OsdGetSize() - 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(script_output[script_line++], script_line_output);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstrcpy(script_output[script_line], script_line_output);\n\t\t\t\t\t\tfor (int i = 0; i < script_line; i++) strcpy(script_output[i], script_output[i+1]);\n\t\t\t\t\t};\n\t\t\t\t\tfor (int i = 0; i < OsdGetSize() - 2; i++) OsdWrite(i, script_output[i], 0, 0);\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpclose(script_pipe);\n\t\t\t\tcpu_set_t set;\n\t\t\t\tCPU_ZERO(&set);\n\t\t\t\tCPU_SET(1, &set);\n\t\t\t\tsched_setaffinity(0, sizeof(set), &set);\n\t\t\t\tscript_finished=true;\n\t\t\t\tOsdWrite(OsdGetSize() - 1, \"             OK\", menusub == 0, 0);\n\t\t\t};\n\t\t};\n\n\t\tif (select || menu || script_finished || c == KEY_BACKSPACE)\n\t\t{\n\t\t\tif (!script_finished)\n\t\t\t{\n\t\t\t\tstrcpy(script_command, \"killall \");\n\t\t\t\tstrcat(script_command, (parentstate == MENU_BTPAIR) ? \"-SIGINT btctl\" : flist_SelectedItem()->de.d_name);\n\t\t\t\tsystem(script_command);\n\t\t\t\tpclose(script_pipe);\n\t\t\t\tcpu_set_t set;\n\t\t\t\tCPU_ZERO(&set);\n\t\t\t\tCPU_SET(1, &set);\n\t\t\t\tsched_setaffinity(0, sizeof(set), &set);\n\t\t\t\tscript_finished = true;\n\t\t\t};\n\n\t\t\tif (c == KEY_BACKSPACE && (parentstate == MENU_BTPAIR))\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < OsdGetSize() - 1; i++) OsdWrite(i);\n\t\t\t\tOsdWrite(7, \"   Delete all pairings...\");\n\t\t\t\tOsdUpdate();\n\t\t\t\tsystem(\"/bin/bluetoothd renew\");\n\t\t\t\tmenustate = MENU_BTPAIR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (parentstate == MENU_BTPAIR)\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_NONE1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmenustate = MENU_SYSTEM1;\n\t\t\t\t\tmenusub = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MENU_KBDMAP:\n\t\thelptext_idx = 0;\n\t\tmenumask = 1;\n\t\tOsdSetTitle(\"Keyboard\", 0);\n\t\tmenustate = MENU_KBDMAP1;\n\t\tparentstate = MENU_KBDMAP;\n\t\tfor (int i = 0; i < OsdGetSize() - 1; i++) OsdWrite(i, \"\", 0, 0);\n\t\tm = 8;\n\t\tOsdWrite(m++, info_top, 0, 0);\n\t\tinfowrite(m++, \"\");\n\t\tinfowrite(m++, \"Enter \\x16 Finish\");\n\t\tinfowrite(m++, \" ESC \\x16 Clear\");\n\t\tinfowrite(m++, \"\");\n\t\tOsdWrite(m++, info_bottom, 0, 0);\n\t\tbreak;\n\n\tcase MENU_KBDMAP1:\n\t\tif(!get_map_button())\n\t\t{\n\t\t\tOsdWrite(3, \"     Press key to change\", 0, 0);\n\t\t\ts[0] = 0;\n\t\t\tif(get_map_vid())\n\t\t\t{\n\t\t\t\tsprintf(s, \"    on keyboard %04x:%04x\", get_map_vid(), get_map_pid());\n\t\t\t}\n\t\t\tOsdWrite(5, s, 0, 0);\n\t\t\tOsdWrite(OsdGetSize() - 1, \"           finish\", menusub == 0, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsprintf(s, \"  Press key to map 0x%02X to\", get_map_button() & 0xFF);\n\t\t\tOsdWrite(3, s, 0, 0);\n\t\t\tOsdWrite(5, \"      on any keyboard\", 0, 0);\n\t\t\tOsdWrite(OsdGetSize() - 1);\n\t\t}\n\n\t\tif (select || menu)\n\t\t{\n\t\t\tif (!get_map_vid()) menu = 0;\n\n\t\t\tOsdWrite(3);\n\t\t\tOsdWrite(4, menu ? \"          Clearing\" : \"          Finishing\");\n\t\t\tOsdWrite(5);\n\t\t\tfinish_map_setting(menu);\n\t\t\tmenu_timeout = GetTimer(1000);\n\t\t\tmenustate = MENU_KBDMAP2;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_KBDMAP2:\n\t\tif (CheckTimer(menu_timeout))\n\t\t{\n\t\t\tmenustate = MENU_SYSTEM1;\n\t\t\tmenusub = 1;\n\t\t}\n\t\tbreak;\n\n\tcase MENU_CORE_FILE_SELECTED1:\n\t\trecent_update(SelectedDir, selPath, SelectedLabel, -1);\n\t\tmenustate = MENU_NONE1;\n\t\tmemcpy(Selected_tmp, selPath, sizeof(Selected_tmp));\n\t\tif (!getStorage(0)) // multiboot is only on SD card.\n\t\t{\n\t\t\tselPath[strlen(selPath) - 4] = 0;\n\t\t\tint off = strlen(SelectedDir);\n\t\t\tif (off) off++;\n\t\t\tint fnum = ScanDirectory(SelectedDir, SCANF_INIT, \"TXT\", 0, selPath + off);\n\t\t\tif (fnum)\n\t\t\t{\n\t\t\t\tif (fnum == 1)\n\t\t\t\t{\n\t\t\t\t\t//Check if the only choice is <core>.txt\n\t\t\t\t\tstrcat(selPath, \".txt\");\n\t\t\t\t\tif (FileLoad(selPath, 0, 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tmenustate = MENU_CORE_FILE_SELECTED2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstrcpy(selPath, Selected_tmp);\n\t\t\t\tAdjustDirectory(selPath);\n\t\t\t\tcp_MenuCancel = fs_MenuCancel;\n\t\t\t\tstrcpy(fs_pFileExt, \"TXT\");\n\t\t\t\tfs_ExtLen = 3;\n\t\t\t\tfs_Options = SCANO_CORES;\n\t\t\t\tfs_MenuSelect = MENU_CORE_FILE_SELECTED2;\n\t\t\t\tfs_MenuCancel = MENU_CORE_FILE_CANCELED;\n\t\t\t\tmenustate = MENU_FILE_SELECT1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (isXmlName(Selected_tmp))\n\t\t{\n\t\t\t// find the RBF file from the XML\n\t\t\txml_load(getFullPath(Selected_tmp));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfpga_load_rbf(Selected_tmp);\n\t\t}\n\t\tbreak;\n\n\tcase MENU_CORE_FILE_SELECTED2:\n\t\tfpga_load_rbf(Selected_tmp, selPath);\n\t\tmenustate = MENU_NONE1;\n\t\tbreak;\n\n\tcase MENU_CORE_FILE_CANCELED:\n\t\tSelectFile(\"\", 0, SCANO_CORES, MENU_CORE_FILE_SELECTED1, cp_MenuCancel);\n\t\tbreak;\n\n\t\t/******************************************************************/\n\t\t/* we should never come here                                      */\n\t\t/******************************************************************/\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (is_menu())\n\t{\n\t\tstatic unsigned long rtc_timer = 0;\n\t\tstatic int init_wait = 0;\n\n\t\tif (!rtc_timer || CheckTimer(rtc_timer))\n\t\t{\n\t\t\trtc_timer = GetTimer(cfg.bootcore[0] != '\\0' ? 100 : 1000);\n\t\t\tchar str[64] = { 0 };\n\t\t\tchar straux[64];\n\n\t\t\tif (cfg.bootcore[0] != '\\0')\n\t\t\t{\n\t\t\t\tif (btimeout > 0)\n\t\t\t\t{\n\t\t\t\t\tOsdWrite(12, \"\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\");\n\t\t\t\t\tsnprintf(str, sizeof(str), \" Bootcore -> %s\", bootcoretype);\n\t\t\t\t\tOsdWrite(13, str, 0, 0);\n\t\t\t\t\tstrcpy(straux, cfg.bootcore);\n\t\t\t\t\tsprintf(str, \" %s\", get_rbf_name_bootcore(straux));\n\n\t\t\t\t\tchar s[40];\n\t\t\t\t\tmemset(s, ' ', 32); // clear line buffer\n\t\t\t\t\ts[32] = 0; // set temporary string length to OSD line length\n\n\t\t\t\t\tint len = strlen(str);\n\t\t\t\t\tif (len > 28)\n\t\t\t\t\t{\n\t\t\t\t\t\tlen = 27; // trim display length if longer than 30 characters\n\t\t\t\t\t\ts[28] = 22;\n\t\t\t\t\t}\n\n\t\t\t\t\tstrncpy(s + 1, str, len); // display only name\n\t\t\t\t\tOsdWrite(14, s, 1, 0, 0, (32 * btimeout) / cfg.bootcore_timeout);\n\n\t\t\t\t\tsprintf(str, \"   Press any key to cancel\");\n\t\t\t\t\tOsdWrite(15, str, 0, 0);\n\t\t\t\t\tbtimeout--;\n\t\t\t\t\tif (!btimeout)\n\t\t\t\t\t{\n\t\t\t\t\t\tOsdWrite(13, \"\", 0, 0);\n\t\t\t\t\t\tOsdWrite(14, s, 1, 0, 0, 0);\n\t\t\t\t\t\tsprintf(str, \"           Loading...\");\n\t\t\t\t\t\tOsdWrite(15, str, 1, 0);\n\t\t\t\t\t\tisXmlName(cfg.bootcore) ? xml_load(getFullPath(cfg.bootcore)) : fpga_load_rbf(cfg.bootcore);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (init_wait < 1)\n\t\t\t{\n\t\t\t\tsprintf(str, \"       www.MiSTerFPGA.org       \");\n\t\t\t\tinit_wait++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsprintf(str, \" MiSTer      \");\n\n\t\t\t\ttime_t t = time(NULL);\n\t\t\t\tstruct tm tm = *localtime(&t);\n\t\t\t\tif (tm.tm_year >= 117)\n\t\t\t\t{\n\t\t\t\t\tstrftime(str + strlen(str), sizeof(str) - 1 - strlen(str), \"%b %d %a%H:%M:%S\", &tm);\n\t\t\t\t}\n\n\t\t\t\tint n = 8;\n\t\t\t\tif (getNet(2)) str[n++] = 0x1d;\n\t\t\t\tif (getNet(1)) str[n++] = 0x1c;\n\t\t\t\tif (hci_get_route(0) >= 0) str[n++] = 4;\n\t\t\t\tif (user_io_get_sdram_cfg() & 0x8000)\n\t\t\t\t{\n\t\t\t\t\tswitch (user_io_get_sdram_cfg() & 7)\n\t\t\t\t\t{\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tstr[n] = 0x95;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstr[n] = 0x94;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstr[n] = 0x93;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstr[n] = 0x92;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstr[22] = ' ';\n\t\t\t}\n\n\t\t\tOsdWrite(16, \"\", 1, 0);\n\t\t\tOsdWrite(17, str, 1, 0);\n\t\t\tOsdWrite(18, \"\", 1, 0);\n\t\t}\n\t}\n}\n\nvoid open_joystick_setup()\n{\n\tOsdSetSize(16);\n\tmenusub = 0;\n\tOsdClear();\n\tOsdEnable(DISABLE_KEYBOARD);\n\tstart_map_setting(joy_bcount ? joy_bcount + 4 : 8);\n\tmenustate = MENU_JOYDIGMAP;\n\tjoymap_first = 1;\n}\n\nvoid ScrollLongName(void)\n{\n\t// this function is called periodically when file selection window is displayed\n\t// it checks if predefined period of time has elapsed and scrolls the name if necessary\n\n\tint off = 0;\n\tint max_len;\n\n\tint len = strlen(flist_SelectedItem()->altname); // get name length\n\n\tmax_len = 30; // number of file name characters to display (one more required for scrolling)\n\tif (flist_SelectedItem()->de.d_type == DT_DIR)\n\t{\n\t\tmax_len = 23; // number of directory name characters to display\n\t\tif ((fs_Options & SCANO_CORES) && (flist_SelectedItem()->altname[0] == '_'))\n\t\t{\n\t\t\toff = 1;\n\t\t\tlen--;\n\t\t}\n\t}\n\n\tif (flist_SelectedItem()->de.d_type != DT_DIR) // if a file\n\t{\n\t\tif (!cfg.rbf_hide_datecode && flist_SelectedItem()->datecode[0])\n\t\t{\n\t\t\tmax_len = 20; // __.__.__ remove that from the end\n\t\t}\n\t\telse if (cfg.browse_expand && len < 55)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tScrollText(flist_iSelectedEntry() - flist_iFirstEntry(), flist_SelectedItem()->altname + off, 0, len, max_len, 1);\n}\n\n// print directory contents\nvoid PrintDirectory(int expand)\n{\n\tchar s[40];\n\tScrollReset();\n\n\tif (!cfg.browse_expand) expand = 0;\n\n\tif (expand)\n\t{\n\t\tint k = flist_iFirstEntry() + OsdGetSize() - 1;\n\t\tif (flist_nDirEntries() && k == flist_iSelectedEntry() && k <= flist_nDirEntries()\n\t\t\t&& strlen(flist_DirItem(k)->altname) > 28 && !(!cfg.rbf_hide_datecode && flist_DirItem(k)->datecode[0])\n\t\t\t&& flist_DirItem(k)->de.d_type != DT_DIR)\n\t\t{\n\t\t\t//make room for last expanded line\n\t\t\tflist_iFirstEntryInc();\n\t\t}\n\t}\n\n\tint i = 0;\n\tint k = flist_iFirstEntry();\n\twhile(i < OsdGetSize())\n\t{\n\t\tchar leftchar = 0;\n\t\tmemset(s, ' ', 32); // clear line buffer\n\t\ts[32] = 0;\n\t\tint len2 = 0;\n\t\tleftchar = 0;\n\t\tint len = 0;\n\n\t\tif (k < flist_nDirEntries())\n\t\t{\n\t\t\tlen = strlen(flist_DirItem(k)->altname); // get name length\n\t\t\tif (len > 28)\n\t\t\t{\n\t\t\t\tlen2 = len - 27;\n\t\t\t\tif (len2 > 27) len2 = 27;\n\t\t\t\tif (!expand) len2 = 0;\n\n\t\t\t\tlen = 27; // trim display length if longer than 30 characters\n\t\t\t\ts[28] = 22;\n\t\t\t}\n\n\t\t\tif((flist_DirItem(k)->de.d_type == DT_DIR) && (fs_Options & SCANO_CORES) && (flist_DirItem(k)->altname[0] == '_'))\n\t\t\t{\n\t\t\t\tstrncpy(s + 1, flist_DirItem(k)->altname+1, len-1);\n\t\t\t}\n\t\t\telse if (flist_DirItem(k)->flags & DT_EXT_ZIP)\n\t\t\t{\n\t\t\t\tstrncpy(s + 1, flist_DirItem(k)->altname, len-4); // strip .zip extension, see below\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrncpy(s + 1, flist_DirItem(k)->altname, len); // display only name\n\t\t\t}\n\n\t\t\tchar *datecode = flist_DirItem(k)->datecode;\n\t\t\tif (flist_DirItem(k)->de.d_type == DT_DIR) // mark directory with suffix\n\t\t\t{\n\t\t\t\tif (!strcmp(flist_DirItem(k)->altname, \"..\"))\n\t\t\t\t{\n\t\t\t\t\tstrcpy(&s[19], \" <UP-DIR>\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (flist_DirItem(k)->flags & DT_EXT_ZIP) // mark ZIP archive with different suffix\n\t\t\t\t\t\tstrcpy(&s[22], \" <ZIP>\");\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcpy(&s[22], \" <DIR>\");\n\t\t\t\t}\n\t\t\t\tlen2 = 0;\n\t\t\t}\n\t\t\telse if (!cfg.rbf_hide_datecode && datecode[0])\n\t\t\t{\n\t\t\t\tint n = 19;\n\t\t\t\ts[n++] = ' ';\n\t\t\t\ts[n++] = datecode[0];\n\t\t\t\ts[n++] = datecode[1];\n\t\t\t\ts[n++] = '.';\n\t\t\t\ts[n++] = datecode[2];\n\t\t\t\ts[n++] = datecode[3];\n\t\t\t\ts[n++] = '.';\n\t\t\t\ts[n++] = datecode[4];\n\t\t\t\ts[n++] = datecode[5];\n\n\t\t\t\tif (len >= 19)\n\t\t\t\t{\n\t\t\t\t\ts[19] = 22;\n\t\t\t\t\ts[28] = ' ';\n\t\t\t\t}\n\t\t\t\tlen2 = 0;\n\t\t\t}\n\n\t\t\tif (!i && k) leftchar = 17;\n\t\t\tif (i && k < flist_nDirEntries() - 1) leftchar = 16;\n\t\t}\n\t\telse if(!flist_nDirEntries()) // selected directory is empty\n\t\t{\n\t\t\tif (!i) strcpy(s, \"          No files!\");\n\t\t\tif (home_dir && !filter[0])\n\t\t\t{\n\t\t\t\tif (i == 6) strcpy(s, \"      Missing directory:\");\n\t\t\t\tif (i == 8)\n\t\t\t\t{\n\t\t\t\t\tlen = strlen(home_dir);\n\t\t\t\t\tif (len > 27) len = 27;\n\t\t\t\t\tstrncpy(s + 1 + ((27 - len) / 2), home_dir, len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint sel = (i == (flist_iSelectedEntry() - flist_iFirstEntry()));\n\t\tOsdWriteOffset(i, s, sel, 0, 0, leftchar);\n\t\ti++;\n\n\t\tif (sel && len2)\n\t\t{\n\t\t\tlen = strlen(flist_DirItem(k)->altname);\n\t\t\tstrcpy(s+1, flist_DirItem(k)->altname + len - len2);\n\t\t\tOsdWriteOffset(i, s, sel, 0, 0, leftchar);\n\t\t\ti++;\n\t\t}\n\n\t\tk++;\n\t}\n}\n\nstatic void set_text(const char *message, unsigned char code)\n{\n\tchar s[40];\n\tint i = 0, l = 1;\n\n\tOsdWrite(0, \"\", 0, 0);\n\n\tdo\n\t{\n\t\ts[i++] = *message;\n\n\t\t// line full or line break\n\t\tif ((i == 29) || (*message == '\\n') || !*message)\n\t\t{\n\t\t\ts[--i] = 0;\n\t\t\tOsdWrite(l++, s, 0, 0);\n\t\t\ti = 0;  // start next line\n\t\t}\n\t} while (*message++);\n\n\tif (code && (l <= 7))\n\t{\n\t\tsprintf(s, \" Code: #%d\", code);\n\t\tOsdWrite(l++, s, 0, 0);\n\t}\n\n\twhile (l <= 7) OsdWrite(l++, \"\", 0, 0);\n}\n\nvoid InfoMessage(const char *message, int timeout, const char *title)\n{\n\tif (menustate <= MENU_INFO)\n\t{\n\t\tif (menustate != MENU_INFO)\n\t\t{\n\t\t\tOsdSetTitle(title, 0);\n\t\t\tOsdEnable(OSD_MSG); // do not disable keyboard\n\t\t}\n\n\t\tset_text(message, 0);\n\n\t\tmenu_timer = GetTimer(timeout);\n\t\tmenustate = MENU_INFO;\n\t\tHandleUI();\n\t\tOsdUpdate();\n\t}\n}\n\nvoid MenuHide()\n{\n\tmenustate = MENU_NONE1;\n\tHandleUI();\n}\n\nint menu_present()\n{\n\treturn (menustate != MENU_NONE1) && (menustate != MENU_NONE2);\n}\n\nvoid Info(const char *message, int timeout, int width, int height, int frame)\n{\n\tif (menustate <= MENU_INFO)\n\t{\n\t\tOSD_PrintInfo(message, &width, &height, frame);\n\t\tInfoEnable(20, (cfg.direct_video && get_vga_fb()) ? 30 : 10, width, height);\n\t\tOsdSetSize(16);\n\n\t\tmenu_timer = GetTimer(timeout);\n\t\tmenustate = MENU_INFO;\n\t\tOsdUpdate();\n\t}\n}\n\nint menu_lightgun_cb(int idx, uint16_t type, uint16_t code, int value)\n{\n\tif (type == EV_ABS)\n\t{\n\t\tif (code == 0 && value) gun_x = value;\n\t\tif (code == 1 && value != 1023) gun_y = value;\n\t}\n\n\tif (type == EV_KEY)\n\t{\n\t\tif ((code == 0x130 || code == 0x131 || code == 0x120) && menustate == MENU_LGCAL1)\n\t\t{\n\t\t\tgun_idx = idx;\n\t\t\tif (value == 1) gun_ok = 1;\n\t\t\tif (value == 0) gun_ok = 2;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint menu_allow_cfg_switch()\n{\n\tif (user_io_osd_is_visible())\n\t{\n\t\tswitch (menustate)\n\t\t{\n\t\tcase MENU_ST_MAIN2:\n\t\tcase MENU_ARCHIE_MAIN2:\n\t\tcase MENU_MINIMIG_MAIN2:\n\t\tcase MENU_COMMON2:\n\t\tcase MENU_SYSTEM2:\n\t\t\treturn 1;\n\n\t\tcase MENU_FILE_SELECT2:\n\t\t\tif (is_menu() && (fs_Options & SCANO_CORES)) return 1;\n\t\t\tbreak;\n\n\t\tcase MENU_GENERIC_MAIN2:\n\t\t\tif (!page) return 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid menu_process_save()\n{\n\tmenu_save_timer = GetTimer(500);\n}\n\nstatic char pchar[] = { 0x8C, 0x8E, 0x8F, 0x90, 0x91, 0x7F };\n\n#define PROGRESS_CNT    28\n#define PROGRESS_CHARS  (int)(sizeof(pchar)/sizeof(pchar[0]))\n#define PROGRESS_MAX    ((PROGRESS_CHARS*PROGRESS_CNT)-1)\n\nvoid ProgressMessage(const char* title, const char* text, int current, int max)\n{\n\tstatic int progress;\n\tif (!current && !max)\n\t{\n\t\tprogress = -1;\n\t\tMenuHide();\n\t\treturn;\n\t}\n\n\tint new_progress = (((uint64_t)current)*PROGRESS_MAX) / max;\n\tif (progress != new_progress)\n\t{\n\t\tprogress = new_progress;\n\t\tstatic char progress_buf[128];\n\t\tmemset(progress_buf, 0, sizeof(progress_buf));\n\n\t\tif (new_progress > PROGRESS_MAX) new_progress = PROGRESS_MAX;\n\t\tchar c = pchar[new_progress % PROGRESS_CHARS];\n\t\tnew_progress /= PROGRESS_CHARS;\n\n\t\tchar *buf = progress_buf;\n\t\tsprintf(buf, \"\\n\\n %.27s\\n \", text);\n\t\tbuf += strlen(buf);\n\n\t\tfor (int i = 0; i <= new_progress; i++) buf[i] = (i < new_progress) ? 0x7F : c;\n\t\tbuf[PROGRESS_CNT] = 0;\n\n\t\tInfoMessage(progress_buf, 2000, title);\n\t}\n}\n"
        },
        {
          "name": "menu.h",
          "type": "blob",
          "size": 0.87109375,
          "content": "#ifndef MENU_H\n#define MENU_H\n\n#include <inttypes.h>\n\nvoid SelectFile(const char* path, const char* pFileExt, int Options, unsigned char MenuSelect, unsigned char MenuCancel);\n\nvoid HandleUI(void);\nvoid menu_key_set(unsigned int c);\nvoid menu_process_save();\nvoid PrintDirectory(int expand = 0);\nvoid ScrollLongName(void);\n\nvoid ProgressMessage(const char* title = 0, const char* text = 0, int current = 0, int max = 0);\nvoid InfoMessage(const char *message, int timeout = 2000, const char *title = \"Message\");\nvoid Info(const char *message, int timeout = 2000, int width = 0, int height = 0, int frame = 0);\nvoid MenuHide();\nvoid SelectINI();\n\nvoid open_joystick_setup();\nint menu_lightgun_cb(int idx, uint16_t type, uint16_t code, int value);\n\nint menu_allow_cfg_switch();\nvoid StoreIdx_F(int idx, const char *path);\nvoid StoreIdx_S(int idx, const char *path);\n\nint menu_present();\n\n#endif\n"
        },
        {
          "name": "names.txt",
          "type": "blob",
          "size": 2.4580078125,
          "content": "# Place this file in the root of your micro SD card.\r\n# This changes how the non-arcade cores are displayed in your menu.\r\n# It does NOT make changes to your existing files or folders.\r\n\r\n# Names on the left need to match the name of the RBF (without the date).\r\n# Names on the right can be modified as desired.\r\n# Cores will be displayed alphabetically based on the modified names.\r\n\r\n# This example list is North America-centric for several systems.\r\n# Change the system names as desired to match your preferred region.\r\n\r\n# [RBF name]: [name that will be shown in the menu]\r\n\r\n# Computer Cores\r\n\r\nAltair8800: Altair 8800\r\nAmstrad: Amstrad CPC 6128\r\nao486: IBM 486-Compatible\r\nApogee: Apogee BK-01\r\nApple-I: Apple I\r\nApple-II: Apple II+\r\nAquarius: Mattel Aquarius\r\nArchie: Acorn Archimedes\r\nAtari800: Atari 800XL/65XE/130XE\r\nAtariST: Atari ST/STe\r\nAtom: Acorn Atom\r\nBBCMicro: BBC Micro B\r\nBK0011M: Electronika BK-0011M\r\nC16: Commodore Plus/4\r\nC64: Commodore 64\r\nColecoAdam: Coleco Adam\r\nElectron: Acorn Electron\r\nGalaksija: Galaksija\r\nht1080z: TRS-80 Model I\r\nJupiter: Jupiter Ace\r\nMacPlus: Apple Macintosh Plus\r\nMinimig: Commodore Amiga\r\nMSX: MSX/MSX2/MSX2+/TurboR\r\nMultiComp: MultiComp (Z80/6502/6809)\r\nORAO: Velebit Informatika Orao\r\nOric: Oric-1/Atmos\r\nPCXT: IBM PC/XT Compatible\r\nPDP1: DEC PDP-1\r\nPET2001: Commodore PET 2001\r\nPSX: Sony PlayStation\r\nQL: Sinclair QL\r\nRX78: Bandai RX-78\r\nSAMCoupe: SAM Coupe\r\nSharpMZ: Sharp MZ Series\r\nSordM5: Sord M5\r\nSpecialist: Specialist/MX\r\nTi994a: TI-99/4A\r\nVector-06C: Vector-06C\r\nTomyTutor: Tomy Tutor/Pyuta/Pyuta Jr\r\nTSConf: TS-Conf (ZX-Evolution)\r\nVIC20: Commodore VIC-20\r\nX68000: Sharp X68000\r\nZX81: Sinclair ZX81\r\nZX-Spectrum: Sinclair ZX Spectrum\r\n\r\n# Console Cores\r\n\r\nAstrocade: Bally Astrocade\r\nAtari2600: Atari 2600 (Old)\r\nAtari5200: Atari 5200\r\nAtari7800: Atari 2600/7800\r\nAY-3-8500: GI Pong\r\nC2650: Arcadia 2001\r\nColecoVision: ColecoVision/SG-1000\r\nGameboy: Nintendo Game Boy/Color\r\nGBA: Nintendo Game Boy Advance\r\nGenesis: Sega Genesis\r\nJaguar: Atari Jaguar\r\nMegaCD: Sega CD\r\nMegaDrive: Sega Mega Drive/Genesis\r\nNeoGeo: SNK Neo Geo MVS/AES/CD\r\nNES: Nintendo NES\r\nOdyssey2: Magnavox Odyssey2\r\nS32X: Sega 32X\r\nSaturn: Sega Saturn\r\nSGB: Nintendo Super Game Boy\r\nSMS: Sega Master System/Game Gear\r\nSNES: Nintendo Super NES\r\nTurboGrafx16: NEC TurboGrafx-16/CD\r\nVectrex: GCE Vectrex\r\nWonderSwan: Bandai WonderSwan/Color\r\n\r\n# Other Cores\r\n\r\nArduboy: Arduboy\r\nChip8: CHIP-8\r\nGameOfLife: Game of Life\r\nFlappyBird: Flappy Bird\r\n\r\n# Service Cores\r\n\r\nmemtest: SDRAM Test\r\n"
        },
        {
          "name": "offload.cpp",
          "type": "blob",
          "size": 2.47265625,
          "content": "#include \"offload.h\"\n#include \"profiling.h\"\n#include <pthread.h>\n#include <inttypes.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic constexpr uint32_t QUEUE_SIZE = 8;\n\nstatic pthread_t s_thread_handle;\nstatic pthread_cond_t s_cond_work, s_cond_available;\nstatic pthread_mutex_t s_queue_lock;\n\nstruct Work\n{\n\tstd::function<void()> handler;\n};\n\nstatic Work s_queue[QUEUE_SIZE];\nstatic uint32_t s_queue_head, s_queue_tail;\nstatic bool s_quit;\n\nstatic void *worker_thread(void *)\n{\n\twhile (true)\n\t{\n\t\tWork *current_work = nullptr;\n\t\t// Wait for work\n\t\tpthread_mutex_lock(&s_queue_lock);\n\t\tif (s_queue_head == s_queue_tail)\n\t\t{\n\t\t\t// queue empty and quit flag set, exit\n\t\t\tif (s_quit)\n\t\t\t{\n\t\t\t\tpthread_mutex_unlock(&s_queue_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// wait for work signal\n\t\t\tpthread_cond_wait(&s_cond_work, &s_queue_lock);\n\t\t\t\n\t\t\t// quit flag was set and queue still empty, quit\n\t\t\tif (s_quit && (s_queue_head == s_queue_tail))\n\t\t\t{\n\t\t\t\tpthread_mutex_unlock(&s_queue_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// get work\n\t\tcurrent_work = &s_queue[s_queue_tail % QUEUE_SIZE];\n\t\tpthread_mutex_unlock(&s_queue_lock);\n\n\t\t// execute\n\t\tcurrent_work->handler();\n\t\tcurrent_work->handler = nullptr;\n\n\t\t// lock and move tail forward\n\t\tpthread_mutex_lock(&s_queue_lock);\n\t\ts_queue_tail++;\n\t\tpthread_cond_signal(&s_cond_available);\n\t\tpthread_mutex_unlock(&s_queue_lock);\n\t}\n\treturn (void *)0;\n}\n\nvoid offload_start()\n{\n\tpthread_cond_init(&s_cond_available, nullptr);\n\tpthread_cond_init(&s_cond_work, nullptr);\n\tpthread_mutex_init(&s_queue_lock, nullptr);\n\n\ts_queue_head = s_queue_tail = 0;\n\ts_quit = false;\n\n\tpthread_attr_t attr;\n\n\tpthread_attr_init(&attr);\n\n\t// Set affinity to core #0 since main runs on core #1\n\tcpu_set_t set;\n\tCPU_ZERO(&set);\n\tCPU_SET(0, &set);\n\tpthread_attr_setaffinity_np(&attr, sizeof(set), &set);\n\n\tpthread_create(&s_thread_handle, &attr, worker_thread, nullptr);\n}\n\nvoid offload_stop()\n{\n\tpthread_mutex_lock(&s_queue_lock);\n\n\ts_quit = true;\n\tpthread_cond_signal(&s_cond_work);\n\n\tpthread_mutex_unlock(&s_queue_lock);\n\n\tprintf(\"Waiting for offloaded work to finish...\");\n\tpthread_join(s_thread_handle, nullptr);\n\tprintf(\"Done\\n\");\n}\n\nvoid offload_add_work(std::function<void()> handler)\n{\n\tPROFILE_FUNCTION();\n\n\tpthread_mutex_lock(&s_queue_lock);\n\n\tif ((s_queue_head - s_queue_tail) == QUEUE_SIZE)\n\t{\n\t\tpthread_cond_wait(&s_cond_available, &s_queue_lock);\n\t}\n\n\tWork *work = &s_queue[s_queue_head % QUEUE_SIZE];\n\twork->handler = handler;\n\n\ts_queue_head++;\n\n\tpthread_cond_signal(&s_cond_work);\n\n\tpthread_mutex_unlock(&s_queue_lock);\n}"
        },
        {
          "name": "offload.h",
          "type": "blob",
          "size": 0.177734375,
          "content": "#ifndef OFFLOAD_H\n#define OFFLOAD_H\n\n#include <stddef.h>\n#include <functional>\n\nvoid offload_start();\nvoid offload_stop();\n\nvoid offload_add_work(std::function<void()> work);\n\n#endif"
        },
        {
          "name": "osd.cpp",
          "type": "blob",
          "size": 14.845703125,
          "content": "/*\nCopyright 2005, 2006, 2007 Dennis van Weeren\nCopyright 2008, 2009 Jakub Bednarski\n\nThis file is part of Minimig\n\nMinimig is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\nMinimig is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nThis is the Minimig OSD (on-screen-display) handler.\n\n2012-02-09 - Split character rom out to separate header file, with upper 128 entries\nas rotated copies of the first 128 entries.  -- AMR\n\n29-12-2006 - created\n30-12-2006 - improved and simplified\n-- JB --\n2008-10-04 - ARM version\n2008-10-26 - added cpu and floppy configuration functions\n2008-12-31 - added enable HDD command\n2009-02-03 - full keyboard support\n2009-06-23 - hires OSD display\n2009-08-23 - adapted ConfigIDE() - support for 2 hardfiles\n*/\n\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"osd.h\"\n#include \"spi.h\"\n\n#include \"charrom.h\"\n#include \"logo.h\"\n#include \"user_io.h\"\n#include \"hardware.h\"\n#include \"profiling.h\"\n\n#include \"support.h\"\n\n#define OSDLINELEN       256       // single line length in bytes\n#define OSD_CMD_WRITE    0x20      // OSD write video data command\n#define OSD_CMD_ENABLE   0x41      // OSD enable command\n#define OSD_CMD_DISABLE  0x40      // OSD disable command\n\nstatic int osd_size = 8;\n\nvoid OsdSetSize(int n)\n{\n\tosd_size = n;\n}\n\nint OsdGetSize()\n{\n\treturn osd_size;\n}\n\nstruct star\n{\n\tint x, y;\n\tint dx, dy;\n};\n\nstruct star stars[64];\nstatic uint8_t osdbuf[256 * 32];\nstatic int  osdbufpos = 0;\nstatic int  osdset = 0;\n\nchar framebuffer[16][256];\nstatic void framebuffer_clear()\n{\n\tmemset(framebuffer, 0, sizeof(framebuffer));\n}\n\nstatic void framebuffer_plot(int x, int y)\n{\n\tframebuffer[y / 8][x] |= (1 << (y & 7));\n}\n\nvoid StarsInit()\n{\n\tsrand(time(NULL));\n\tfor (int i = 0; i<64; ++i)\n\t{\n\t\tstars[i].x = (rand() % 228) << 4;\t// X centre\n\t\tstars[i].y = (rand() % 128) << 4;\t// Y centre\n\t\tstars[i].dx = -(rand() & 7) - 3;\n\t\tstars[i].dy = 0;\n\t}\n}\n\nvoid StarsUpdate()\n{\n\tframebuffer_clear();\n\tfor (int i = 0; i<64; ++i)\n\t{\n\t\tstars[i].x += stars[i].dx;\n\t\tstars[i].y += stars[i].dy;\n\t\tif ((stars[i].x<0) || (stars[i].x>(228 << 4)) ||\n\t\t\t(stars[i].y<0) || (stars[i].y>(128 << 4)))\n\t\t{\n\t\t\tstars[i].x = 228 << 4;\n\t\t\tstars[i].y = (rand() % 128) << 4;\n\t\t\tstars[i].dx = -(rand() & 7) - 3;\n\t\t\tstars[i].dy = 0;\n\t\t}\n\t\tframebuffer_plot(stars[i].x >> 4, stars[i].y >> 4);\n\t}\n\tosdset = -1;\n}\n\n\n// time delay after which file/dir name starts to scroll\n#define SCROLL_DELAY 1000\n#define SCROLL_DELAY2 10\n#define SCROLL_DELAY3 50\n\nstatic unsigned long scroll_offset[2] = {}; // file/dir name scrolling position\nstatic unsigned long scroll_timer[2] = {};  // file/dir name scrolling timer\n\nstatic int arrow;\nstatic unsigned char titlebuffer[256];\n\nstatic void rotatechar(unsigned char *in, unsigned char *out)\n{\n\tint a;\n\tint b;\n\tint c;\n\tfor (b = 0; b<8; ++b)\n\t{\n\t\ta = 0;\n\t\tfor (c = 0; c<8; ++c)\n\t\t{\n\t\t\ta <<= 1;\n\t\t\ta |= (in[c] >> b) & 1;\n\t\t}\n\t\tout[b] = a;\n\t}\n}\n\n#define OSDHEIGHT (uint)(osd_size*8)\n\nvoid OsdSetTitle(const char *s, int a)\n{\n\t// Compose the title, condensing character gaps\n\tarrow = a;\n\tint zeros = 0;\n\tuint i = 0, j = 0;\n\tuint outp = 0;\n\twhile (1)\n\t{\n\t\tint c = s[i++];\n\t\tif (c && (outp<OSDHEIGHT-8))\n\t\t{\n\t\t\tunsigned char *p = &charfont[c][0];\n\t\t\tfor (j = 0; j<8; ++j)\n\t\t\t{\n\t\t\t\tunsigned char nc = *p++;\n\t\t\t\tif (nc)\n\t\t\t\t{\n\t\t\t\t\tzeros = 0;\n\t\t\t\t\ttitlebuffer[outp++] = nc;\n\t\t\t\t}\n\t\t\t\telse if (zeros == 0 || (c == ' ' && zeros < 5))\n\t\t\t\t{\n\t\t\t\t\ttitlebuffer[outp++] = 0;\n\t\t\t\t\tzeros++;\n\t\t\t\t}\n\t\t\t\tif (outp>sizeof(titlebuffer)) break;\n\t\t\t}\n\t\t}\n\t\telse break;\n\t}\n\tfor (i = outp; i<OSDHEIGHT; i++)\n\t{\n\t\ttitlebuffer[i] = 0;\n\t}\n\n\t// Now centre it:\n\tuint c = (OSDHEIGHT - 1 - outp) / 2;\n\tmemmove(titlebuffer + c, titlebuffer, outp);\n\n\tfor (i = 0; i<c; ++i) titlebuffer[i] = 0;\n\n\t// Finally rotate it.\n\tfor (i = 0; i<OSDHEIGHT; i += 8)\n\t{\n\t\tunsigned char tmp[8];\n\t\trotatechar(&titlebuffer[i], tmp);\n\t\tfor (c = 0; c<8; ++c)\n\t\t{\n\t\t\ttitlebuffer[i + c] = tmp[c];\n\t\t}\n\t}\n}\n\nvoid OsdSetArrow(int a)\n{\n\tarrow = a;\n}\n\nvoid OsdWrite(unsigned char n, const char *s, unsigned char invert, unsigned char stipple, char usebg, int maxinv, int mininv)\n{\n\tOsdWriteOffset(n, s, invert, stipple, 0, 0, usebg, maxinv, mininv);\n}\n\nstatic void osd_start(int line)\n{\n\tline = line & 0x1F;\n\tosdset |= 1 << line;\n\tosdbufpos = line * 256;\n}\n\nstatic void draw_title(const unsigned char *p)\n{\n\t// left white border\n\tosdbuf[osdbufpos++] = 0xff;\n\tosdbuf[osdbufpos++] = 0xff;\n\tosdbuf[osdbufpos++] = 0xff;\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tosdbuf[osdbufpos++] = 255 ^ *p;\n\t\tosdbuf[osdbufpos++] = 255 ^ *p++;\n\t}\n\n\t// right white border\n\tosdbuf[osdbufpos++] = 0xff;\n\n\t// blue gap\n\tosdbuf[osdbufpos++] = 0;\n\tosdbuf[osdbufpos++] = 0;\n}\n\n// write a null-terminated string <s> to the OSD buffer starting at line <n>\nvoid OsdWriteOffset(unsigned char n, const char *s, unsigned char invert, unsigned char stipple, char offset, char leftchar, char usebg, int maxinv, int mininv)\n{\n\t//printf(\"OsdWriteOffset(%d)\\n\", n);\n\tunsigned short i;\n\tunsigned char b;\n\tconst unsigned char *p;\n\tunsigned char stipplemask = 0xff;\n\tint linelimit = OSDLINELEN;\n\tint arrowmask = arrow;\n\tif (n == (osd_size-1) && (arrow & OSD_ARROW_RIGHT))\n\t\tlinelimit -= 22;\n\n\tif (n && n < OsdGetSize() - 1) leftchar = 0;\n\n\tif (stipple) {\n\t\tstipplemask = 0x55;\n\t\tstipple = 0xff;\n\t}\n\telse\n\t\tstipple = 0;\n\n\tosd_start(n);\n\n\tunsigned char xormask = 0;\n\tunsigned char xorchar = 0;\n\n\ti = 0;\n\t// send all characters in string to OSD\n\twhile (1)\n\t{\n\t\tif (invert && i / 8 >= mininv) xormask = 255;\n\t\tif (invert && i / 8 >= maxinv) xormask = 0;\n\n\t\tif (i == 0 && (n < osd_size))\n\t\t{\t// Render sidestripe\n\t\t\tunsigned char tmp[8];\n\n\t\t\tif (leftchar)\n\t\t\t{\n\t\t\t\tunsigned char tmp2[8];\n\t\t\t\tmemcpy(tmp2, charfont[(uint)leftchar], 8);\n\t\t\t\trotatechar(tmp2, tmp);\n\t\t\t\tp = tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp = &titlebuffer[(osd_size - 1 - n) * 8];\n\t\t\t}\n\n\t\t\tdraw_title(p);\n\t\t\ti += 22;\n\t\t}\n\t\telse if (n == (osd_size-1) && (arrowmask & OSD_ARROW_LEFT))\n\t\t{\t// Draw initial arrow\n\t\t\tunsigned char b;\n\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\t\t\tp = &charfont[0x10][0];\n\t\t\tfor (b = 0; b<8; b++) osdbuf[osdbufpos++] = (*p++ << offset) ^ xormask;\n\t\t\tp = &charfont[0x14][0];\n\t\t\tfor (b = 0; b<8; b++) osdbuf[osdbufpos++] = (*p++ << offset) ^ xormask;\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\t\t\tosdbuf[osdbufpos++] = xormask;\n\n\t\t\ti += 24;\n\t\t\tarrowmask &= ~OSD_ARROW_LEFT;\n\t\t\tif (*s++ == 0) break;\t// Skip 3 characters, to keep alignent the same.\n\t\t\tif (*s++ == 0) break;\n\t\t\tif (*s++ == 0) break;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb = *s++;\n\t\t\tif (!b) break;\n\n\t\t\tif (b == 0xb)\n\t\t\t{\n\t\t\t\tstipplemask ^= 0xAA;\n\t\t\t\tstipple ^= 0xff;\n\t\t\t}\n\t\t\telse if (b == 0xc)\n\t\t\t{\n\t\t\t\txorchar ^= 0xff;\n\t\t\t}\n\t\t\telse if (b == 0x0d || b == 0x0a)\n\t\t\t{  // cariage return / linefeed, go to next line\n\t\t\t   // increment line counter\n\t\t\t\tif (++n >= linelimit)\n\t\t\t\t\tn = 0;\n\n\t\t\t\t// send new line number to OSD\n\t\t\t\tosd_start(n);\n\t\t\t}\n\t\t\telse if (i<(linelimit - 8))\n\t\t\t{  // normal character\n\t\t\t\tunsigned char c;\n\t\t\t\tp = &charfont[b][0];\n\t\t\t\tfor (c = 0; c<8; c++) {\n\t\t\t\t\tchar bg = usebg ? framebuffer[n][i+c-22] : 0;\n\t\t\t\t\tosdbuf[osdbufpos++] = (((*p++ << offset)&stipplemask) ^ xormask ^ xorchar) | bg;\n\t\t\t\t\tstipplemask ^= stipple;\n\t\t\t\t}\n\t\t\t\ti += 8;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (; i < linelimit; i++) // clear end of line\n\t{\n\t\tchar bg = usebg ? framebuffer[n][i-22] : 0;\n\t\tosdbuf[osdbufpos++] = xormask | bg;\n\t}\n\n\tif (n == (osd_size-1) && (arrowmask & OSD_ARROW_RIGHT))\n\t{\t// Draw final arrow if needed\n\t\tunsigned char c;\n\t\tosdbuf[osdbufpos++] = xormask;\n\t\tosdbuf[osdbufpos++] = xormask;\n\t\tosdbuf[osdbufpos++] = xormask;\n\t\tp = &charfont[0x15][0];\n\t\tfor (c = 0; c<8; c++) osdbuf[osdbufpos++] = (*p++ << offset) ^ xormask;\n\t\tp = &charfont[0x11][0];\n\t\tfor (c = 0; c<8; c++) osdbuf[osdbufpos++] = (*p++ << offset) ^ xormask;\n\t\tosdbuf[osdbufpos++] = xormask;\n\t\tosdbuf[osdbufpos++] = xormask;\n\t\tosdbuf[osdbufpos++] = xormask;\n\t\ti += 22;\n\t}\n}\n\nvoid OsdShiftDown(unsigned char n)\n{\n\tosd_start(n);\n\n\tosdbufpos += 22;\n\tfor (int i = 22; i < 256; i++) osdbuf[osdbufpos++] <<= 1;\n}\n\n\nvoid OsdDrawLogo(int row)\n{\n\tosd_start(row);\n\n\tunsigned char bt = 0;\n\tconst unsigned char *lp = logodata[row];\n\tint bytes = sizeof(logodata[0]);\n\tif ((uint)row >= (sizeof(logodata) / sizeof(logodata[0]))) lp = 0;\n\n\tchar *bg = framebuffer[row];\n\n\tint i = 0;\n\twhile(i < OSDLINELEN)\n\t{\n\t\tif (i == 0)\n\t\t{\n\t\t\tdraw_title(&titlebuffer[(osd_size - 1 - row) * 8]);\n\t\t\ti += 22;\n\t\t}\n\n\t\tif(lp && bytes)\n\t\t{\n\t\t\tbt = *lp++;\n\t\t\tbytes--;\n\t\t}\n\n\t\tosdbuf[osdbufpos++] = bt | *bg++;\n\t\t++i;\n\t}\n}\n\n#define INFO_MAXW 32\n#define INFO_MAXH 16\n\nvoid OSD_PrintInfo(const char *message, int *width, int *height, int frame)\n{\n\tstatic char str[INFO_MAXW * INFO_MAXH];\n\tmemset(str, ' ', sizeof(str));\n\n\t// calc height/width if none provided. Add frame to calculated size.\n\t// no frame will be added if width and height are provided.\n\tint calc = !*width || !*height || frame;\n\n\tint maxw = 0;\n\tint x = calc ? 1 : 0;\n\tint y = calc ? 1 : 0;\n\twhile (*message)\n\t{\n\t\tchar c = *message++;\n\t\tif (c == 0xD) continue;\n\t\tif (c == 0xA)\n\t\t{\n\t\t\tx = calc ? 1 : 0;\n\t\t\ty++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (x < INFO_MAXW && y < INFO_MAXH) str[(y*INFO_MAXW) + x] = c;\n\n\t\tx++;\n\t\tif (x > maxw) maxw = x;\n\t}\n\n\tint w = !calc ? *width + 2 : maxw+1;\n\tif (w > INFO_MAXW) w = INFO_MAXW;\n\t*width = w;\n\n\tint h = !calc ? *height + 2 : y+2;\n\tif (h > INFO_MAXH) h = INFO_MAXH;\n\t*height = h;\n\n\tif (frame)\n\t{\n\t\tframe = (frame - 1) * 6;\n\t\tfor (x = 1; x < w - 1; x++)\n\t\t{\n\t\t\tstr[(0 * INFO_MAXW) + x] = 0x81+frame;\n\t\t\tstr[((h - 1)*INFO_MAXW) + x] = 0x81 + frame;\n\t\t}\n\t\tfor (y = 1; y < h - 1; y++)\n\t\t{\n\t\t\tstr[(y * INFO_MAXW)] = 0x83 + frame;\n\t\t\tstr[(y * INFO_MAXW) + w - 1] = 0x83 + frame;\n\t\t}\n\t\tstr[0] = 0x80 + frame;\n\t\tstr[w - 1] = 0x82 + frame;\n\t\tstr[(h - 1)*INFO_MAXW] = 0x85 + frame;\n\t\tstr[((h - 1)*INFO_MAXW) + w - 1] = 0x84 + frame;\n\t}\n\n\tfor (y = 0; y < h; y++)\n\t{\n\t\tosd_start(y);\n\n\t\tfor (x = 0; x < w; x++)\n\t\t{\n\t\t\tconst unsigned char *p = charfont[(uint)str[(y*INFO_MAXW) + x]];\n\t\t\tfor (int i = 0; i < 8; i++) osdbuf[osdbufpos++] = *p++;\n\t\t}\n\t}\n}\n\n// clear OSD frame buffer\nvoid OsdClear(void)\n{\n\tosdset = -1;\n\tmemset(osdbuf, 0, 16 * 256);\n}\n\n// enable displaying of OSD\nvoid OsdEnable(unsigned char mode)\n{\n\tuser_io_osd_key_enable(mode & DISABLE_KEYBOARD);\n\tmode &= (DISABLE_KEYBOARD | OSD_MSG);\n\tspi_osd_cmd(OSD_CMD_ENABLE | mode);\n}\n\nvoid InfoEnable(int x, int y, int width, int height)\n{\n\tuser_io_osd_key_enable(0);\n\tspi_osd_cmd_cont(OSD_CMD_ENABLE | OSD_INFO);\n\tspi_w(x);\n\tspi_w(y);\n\tspi_w(width);\n\tspi_w(height);\n\tDisableOsd();\n}\n\nvoid OsdRotation(uint8_t rotate)\n{\n\tspi_osd_cmd_cont(OSD_CMD_DISABLE);\n\tspi_w(0);\n\tspi_w(0);\n\tspi_w(0);\n\tspi_w(0);\n\tspi_w(rotate);\n\tDisableOsd();\n}\n\n// disable displaying of OSD\nvoid OsdDisable()\n{\n\tuser_io_osd_key_enable(0);\n\tspi_osd_cmd(OSD_CMD_DISABLE);\n}\n\nvoid OsdMenuCtl(int en)\n{\n\tif (en)\n\t{\n\t\tspi_osd_cmd(OSD_CMD_WRITE | 8);\n\t\tspi_osd_cmd(OSD_CMD_ENABLE);\n\t}\n\telse\n\t{\n\t\tspi_osd_cmd(OSD_CMD_DISABLE);\n\t}\n}\n\n// write a null-terminated string <s> to the OSD buffer starting at line <n>\nstatic void print_line(unsigned char line, const char *hdr, const char *text, unsigned long width, unsigned long offset, unsigned char invert)\n{\n\t// line : OSD line number (0-7)\n\t// text : pointer to null-terminated string\n\t// start : start position (in pixels)\n\t// width : printed text length in pixels\n\t// offset : scroll offset in pixels counting from the start of the string (0-7)\n\t// invert : invertion flag\n\n\tconst unsigned char *p;\n\n\tif (invert) invert = 0xff;\n\n\t// select buffer and line to write to\n\tosd_start(line);\n\tdraw_title(&titlebuffer[(osd_size - 1 - line) * 8]);\n\n\twhile (*hdr)\n\t{\n\t\twidth -= 8;\n\t\tp = charfont[(uint)(*hdr++)];\n\t\tfor (int i = 0; i < 8; i++) osdbuf[osdbufpos++] = *p++ ^ invert;\n\t}\n\n\tif (offset)\n\t{\n\t\twidth -= 8 - offset;\n\t\tp = &charfont[(uint)(*text++)][offset];\n\t\tfor (; offset < 8; offset++) osdbuf[osdbufpos++] = *p++ ^ invert;\n\t}\n\n\twhile (width > 8)\n\t{\n\t\tunsigned char b;\n\t\tp = &charfont[(uint)(*text++)][0];\n\t\tfor (b = 0; b < 8; b++) osdbuf[osdbufpos++] = *p++ ^ invert;\n\t\twidth -= 8;\n\t}\n\n\tif (width)\n\t{\n\t\tp = &charfont[(uint)(*text++)][0];\n\t\twhile (width--) osdbuf[osdbufpos++] = *p++ ^ invert;\n\t}\n}\n\nvoid ScrollText(char n, const char *str, int off, int len, int max_len, unsigned char invert, int idx)\n{\n\t// this function is called periodically when a string longer than the window is displayed.\n\n#define BLANKSPACE 10 // number of spaces between the end and start of repeated name\n\n\tchar s[40], hdr[40];\n\tlong offset;\n\tif (!max_len) max_len = 30;\n\n\tif (str && str[0] && CheckTimer(scroll_timer[idx])) // scroll if long name and timer delay elapsed\n\t{\n\t\thdr[0] = 0;\n\t\tif (off)\n\t\t{\n\t\t\tstrncpy(hdr, str, off);\n\t\t\thdr[off] = 0;\n\t\t\tstr += off;\n\t\t\tif (len > off) len -= off;\n\t\t}\n\n\t\tscroll_timer[idx] = GetTimer(SCROLL_DELAY2); // reset scroll timer to repeat delay\n\n\t\tscroll_offset[idx]++; // increase scroll position (1 pixel unit)\n\t\tmemset(s, ' ', 32); // clear buffer\n\n\t\tif (!len) len = strlen(str); // get name length\n\n\t\tif (off+2+len > max_len) // scroll name if longer than display size\n\t\t{\n\t\t\t// reset scroll position if it exceeds predefined maximum\n\t\t\tif (scroll_offset[idx] >= (uint)(len + BLANKSPACE) << 3) scroll_offset[idx] = 0;\n\n\t\t\toffset = scroll_offset[idx] >> 3; // get new starting character of the name (scroll_offset is no longer in 2 pixel unit)\n\t\t\tlen -= offset; // remaining number of characters in the name\n\t\t\tif (len>max_len) len = max_len;\n\t\t\tif (len > 0) strncpy(s, &str[offset], len); // copy name substring\n\n\t\t\tif (len < max_len - BLANKSPACE) // file name substring and blank space is shorter than display line size\n\t\t\t{\n\t\t\t\tstrncpy(s + len + BLANKSPACE, str, max_len - len - BLANKSPACE); // repeat the name after its end and predefined number of blank space\n\t\t\t}\n\n\t\t\tprint_line(n, hdr, s, (max_len - 1) << 3, (scroll_offset[idx] & 0x7), invert); // OSD print function with pixel precision\n\t\t}\n\t}\n}\n\nvoid ScrollReset(int idx)\n{\n\tscroll_timer[idx] = GetTimer(SCROLL_DELAY); // set timer to start name scrolling after predefined time delay\n\tscroll_offset[idx] = 0; // start scrolling from the start\n}\n\n/* core currently loaded */\nstatic char lastcorename[261 + 10] = \"CORE\";\nvoid OsdCoreNameSet(const char* str)\n{\n\tsprintf(lastcorename, \"%s\", str);\n}\n\nchar* OsdCoreNameGet()\n{\n\treturn lastcorename;\n}\n\nvoid OsdUpdate()\n{\n\tPROFILE_FUNCTION();\n\tint n = is_menu() ? 19 : osd_size;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (osdset & (1 << i))\n\t\t{\n\t\t\tspi_osd_cmd_cont(OSD_CMD_WRITE | i);\n\t\t\tspi_write(osdbuf + i * 256, 256, 0);\n\t\t\tDisableOsd();\n\t\t\tif (is_megacd()) mcd_poll();\n\t\t\tif (is_pce()) pcecd_poll();\n\t\t\tif (is_saturn()) saturn_poll();\n\t\t\tif (is_neogeo_cd()) neocd_poll();\n\t\t}\n\t}\n\n\tosdset = 0;\n}\n"
        },
        {
          "name": "osd.h",
          "type": "blob",
          "size": 1.6708984375,
          "content": "#ifndef OSD_H_INCLUDED\n#define OSD_H_INCLUDED\n\n#include <inttypes.h>\n\n// some constants\n#define DISABLE_KEYBOARD 0x02        // disable keyboard while OSD is active\n#define OSD_INFO         0x04        // display info\n#define OSD_MSG          0x08        // display message window\n\n#define REPEATDELAY      500         // repeat delay in 1ms units\n#define REPEATRATE       50          // repeat rate in 1ms units\n\n#define OSD_ARROW_LEFT   1\n#define OSD_ARROW_RIGHT  2\n\n/*functions*/\nvoid OsdSetTitle(const char *s, int arrow = 0);\t// arrow > 0 = display right arrow in bottom right, < 0 = display left arrow\nvoid OsdSetArrow(int arrow);\nvoid OsdWrite(unsigned char n, const char *s=\"\", unsigned char inver=0, unsigned char stipple=0, char usebg = 0, int maxinv = 32, int mininv = 0);\nvoid OsdWriteOffset(unsigned char n, const char *s, unsigned char inver, unsigned char stipple, char offset, char leftchar, char usebg = 0, int maxinv = 32, int mininv = 0); // Used for scrolling \"Exit\" text downwards...\nvoid OsdClear();\nvoid OsdEnable(unsigned char mode);\nvoid InfoEnable(int x, int y, int width, int height);\nvoid OsdRotation(uint8_t rotate);\nvoid OsdDisable();\nvoid OsdMenuCtl(int en);\nvoid OsdUpdate();\nvoid OSD_PrintInfo(const char *message, int *width, int *height, int frame = 0);\nvoid OsdDrawLogo(int row);\nvoid ScrollText(char n, const char *str, int off, int len, int max_len, unsigned char invert, int idx = 0);\nvoid ScrollReset(int idx = 0);\nvoid StarsInit();\nvoid StarsUpdate();\nvoid OsdShiftDown(unsigned char n);\n\n// get/set core currently loaded\nvoid OsdCoreNameSet(const char* str);\nchar* OsdCoreNameGet();\nvoid OsdSetSize(int n);\nint OsdGetSize();\n\n#define OsdIsBig (OsdGetSize()>8)\n\n#endif\n\n"
        },
        {
          "name": "profiling.cpp",
          "type": "blob",
          "size": 3.1611328125,
          "content": "#ifdef PROFILING\n\n#include \"profiling.h\"\n\n#include \"str_util.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\nstruct Event\n{\n\tconst char *name;\n\tuint32_t begin_idx;\n\tstruct timespec ts;\n};\n\nstatic constexpr int MAX_EVENTS = 512; // must be pow2\nstatic Event s_events[MAX_EVENTS]; // circular buffer\nstatic uint32_t s_event_tail = 0;\n\nstatic constexpr Event *get_event(uint32_t idx)\n{\n\treturn &s_events[idx % MAX_EVENTS];\n}\n\nuint32_t profiling_event_begin(const char *name)\n{\n\tEvent *newEvent = get_event(s_event_tail);\n\tnewEvent->begin_idx = s_event_tail;\n\tnewEvent->name = name;\n\tclock_gettime(CLOCK_MONOTONIC, &newEvent->ts);\n\n\tuint32_t r = s_event_tail;\n\ts_event_tail++;\n\treturn r;\n}\n\nvoid profiling_event_end(uint32_t begin_idx, const char *name)\n{\n\tEvent *newEvent = get_event(s_event_tail);\n\tnewEvent->begin_idx = begin_idx;\n\tnewEvent->name = name;\n\tclock_gettime(CLOCK_MONOTONIC, &newEvent->ts);\n\ts_event_tail++;\n}\n\n// result_ns = a - b\nstatic uint64_t delta_ns(const struct timespec *a, const struct timespec *b)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = a->tv_sec - b->tv_sec;\n\tts.tv_nsec = a->tv_nsec - b->tv_nsec;\n\tif (ts.tv_nsec < 0)\n\t{\n\t\tts.tv_nsec += 1000000000;\n\t\tts.tv_sec -= 1;\n\t}\n\n\tuint64_t delta = ts.tv_sec * 1000000000ULL;\n\tdelta += ts.tv_nsec;\n\treturn delta;\n}\n\n\n// Bookkeeping data for spike report\nstatic uint64_t inclusive_times[MAX_EVENTS];\nstatic uint64_t other_times[MAX_EVENTS];\nstatic uint32_t pair_stack[MAX_EVENTS / 2];\n\nvoid profiling_spike_report(uint32_t begin_idx, uint32_t spike_us)\n{\n\tint stack_pos = 0;\n\n\tif ((s_event_tail - begin_idx) < 2) return; // not enough events\n\tif ((s_event_tail - begin_idx) > MAX_EVENTS) return; // too many events\n\n\tconst uint64_t total_ns = delta_ns(&get_event(s_event_tail - 1)->ts, &get_event(begin_idx)->ts);\n\n\tif (total_ns < (spike_us * 1000ULL)) return; // below threshold\n\n\tfor (uint32_t idx = begin_idx; idx != s_event_tail; idx++)\n\t{\n\t\tconst uint32_t cyc_idx = idx % MAX_EVENTS;\n\t\tEvent *event = get_event(idx);\n\n\t\tif (event->begin_idx == idx)\n\t\t{\n\t\t\tpair_stack[stack_pos] = cyc_idx;\n\t\t\tinclusive_times[cyc_idx] = 0;\n\t\t\tother_times[cyc_idx] = 0;\n\t\t\tstack_pos++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstack_pos--;\n\t\t\tuint32_t span_idx = pair_stack[stack_pos];\n\t\t\tconst uint64_t inclusive_ns = delta_ns(&event->ts, &get_event(span_idx)->ts);\n\t\t\tinclusive_times[span_idx] = inclusive_ns;\n\t\t\tif (stack_pos > 0) other_times[pair_stack[stack_pos-1]] += inclusive_ns;\n\t\t}\n\t}\n\n\tchar label[256];\n\tint indent = 0;\n\tprintf(\"\\n%lluus spike over %uus limit.\\n\", total_ns / 1000ULL, spike_us);\n\tprintf(\"+----- Name -----------------------------------------+ Inc(us) + Exc(us) +\\n\");\n\tfor (uint32_t idx = begin_idx; idx != s_event_tail; idx++)\n\t{\n\t\tconst uint32_t cyc_idx = idx % MAX_EVENTS;\n\t\tEvent *event = get_event(idx);\n\n\t\tif (event->begin_idx == idx)\n\t\t{\n\t\t\tmemset(label, ' ', indent);\n\t\t\tstrcpyz(label + indent, sizeof(label) - indent, event->name);\n\t\t\tprintf(\"| %-50s | %7llu | %7llu |\\n\", label, inclusive_times[cyc_idx] / 1000ULL, (inclusive_times[cyc_idx] - other_times[cyc_idx]) / 1000ULL);\n\t\t\tindent += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tindent -= 2;\n\t\t}\n\t}\n\tprintf(\"+----------------------------------------------------+---------+---------+\\n\\n\");\n\tfflush(stdout);\n}\n\n#endif // PROFILING"
        },
        {
          "name": "profiling.h",
          "type": "blob",
          "size": 1.21484375,
          "content": "#ifndef PROFILING_H\n#define PROFILING_H 1\n\n#include <inttypes.h>\n\n#ifdef PROFILING\n\nuint32_t profiling_event_begin(const char *name);\nvoid profiling_event_end(uint32_t begin_idx, const char *name);\nvoid profiling_spike_report(uint32_t begin_idx, uint32_t spike_us);\n\nstruct ProfilingScopedEvent\n{\n\tconst char *name;\n\tuint32_t spike_us;\n\tuint32_t begin_idx;\n\n\tProfilingScopedEvent(const char *name)\n\t\t: name(name)\n\t\t, spike_us(0)\n\t{\n\t\tbegin_idx = profiling_event_begin(name);\n\t}\n\n\tProfilingScopedEvent(const char *name, uint32_t spike_us)\n\t\t: name(name)\n\t\t, spike_us(spike_us)\n\t{\n\t\tbegin_idx = profiling_event_begin(name);\n\t}\n\n\t~ProfilingScopedEvent()\n\t{\n\t\tprofiling_event_end(begin_idx, name);\n\t\tif (spike_us > 0) profiling_spike_report(begin_idx, spike_us);\n\t}\n};\n\n#define PROFILE_SCOPE(name) ProfilingScopedEvent __scope_timer(name)\n#define PROFILE_FUNCTION() ProfilingScopedEvent __scope_timer(__FUNCTION__)\n#define SPIKE_SCOPE(name, us) ProfilingScopedEvent __scope_timer(name, us)\n#define SPIKE_FUNCTION(us) ProfilingScopedEvent __scope_timer(__FUNCTION__, us)\n\n#else // PROFILING\n\n#define PROFILE_SCOPE(name) \n#define PROFILE_FUNCTION()\n#define SPIKE_SCOPE(name, us)\n#define SPIKE_FUNCTION(us)\n\n#endif // PROFILING\n\n#endif // PROFILING_H\n"
        },
        {
          "name": "recent.cpp",
          "type": "blob",
          "size": 6.29296875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <ctype.h>\n\n#include \"file_io.h\"\n#include \"user_io.h\"\n#include \"osd.h\"\n#include \"cfg.h\"\n#include \"recent.h\"\n\n#define RECENT_MAX 16\n\nstruct recent_rec_t\n{\n\tchar dir[1024];\n\tchar name[256];\n\tchar label[256];\n};\n\nstatic recent_rec_t recents[RECENT_MAX];\nstatic char ena[RECENT_MAX];\n\nstatic int numlast = 0;\n\nstatic int iSelectedEntry = 0;\nstatic int iFirstEntry = 0;\n\nstatic int recent_available()\n{\n\treturn numlast;\n}\n\nstatic char* recent_create_config_name(int idx)\n{\n\tstatic char str[256];\n\tsprintf(str, \"cores_recent.cfg\");\n\tif (idx >= 0) sprintf(str, \"%s_recent_%d.cfg\", user_io_get_core_name(), idx);\n\treturn str;\n}\n\nstatic const char* recent_path(char* dir, char* name)\n{\n\tstatic char path[1024];\n\tif(strlen(dir)) snprintf(path, sizeof(path), \"%s/%s\", dir, name);\n\telse snprintf(path, sizeof(path), \"%s\", name);\n\treturn path;\n}\n\nstatic void recent_load(int idx)\n{\n\t// initialize recent to empty strings\n\tmemset(recents, 0, sizeof(recents));\n\n\t// load the config file into memory\n\tFileLoadConfig(recent_create_config_name(idx), recents, sizeof(recents));\n\n\tfor (numlast = 0; numlast < (int)(sizeof(recents)/sizeof(recents[0])) && strlen(recents[numlast].name); numlast++) {}\n\n\t// check the items\n\tfor (int i = 0; i < recent_available(); i++)\n\t{\n\t\tena[i] = FileExists(recent_path(recents[i].dir, recents[i].name));\n\t\tif (idx >= 0 && is_neogeo() && !ena[i]) ena[i] = PathIsDir(recent_path(recents[i].dir, recents[i].name));\n\t}\n}\n\nint recent_init(int idx)\n{\n\tif (!cfg.recents) return 0;\n\n\trecent_load(idx);\n\trecent_scan(SCANF_INIT);\n\treturn recent_available();\n}\n\nvoid recent_scan(int mode)\n{\n\tif (mode == SCANF_INIT)\n\t{\n\t\tiFirstEntry = 0;\n\t\tiSelectedEntry = 0;\n\t}\n\telse\n\t{\n\t\tif (!recent_available()) return;\n\n\t\tif (mode == SCANF_END || (mode == SCANF_PREV && iSelectedEntry <= 0))\n\t\t{\n\t\t\tiSelectedEntry = recent_available() - 1;\n\t\t\tiFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t}\n\t\telse if (mode == SCANF_NEXT)\n\t\t{\n\t\t\tif (iSelectedEntry + 1 < recent_available()) // scroll within visible items\n\t\t\t{\n\t\t\t\tiSelectedEntry++;\n\t\t\t\tif (iSelectedEntry > iFirstEntry + OsdGetSize() - 1) iFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// jump to first visible item\n\t\t\t\tiFirstEntry = 0;\n\t\t\t\tiSelectedEntry = 0;\n\t\t\t}\n\t\t}\n\t\telse if (mode == SCANF_PREV)\n\t\t{\n\t\t\tif (iSelectedEntry > 0) // scroll within visible items\n\t\t\t{\n\t\t\t\tiSelectedEntry--;\n\t\t\t\tif (iSelectedEntry < iFirstEntry) iFirstEntry = iSelectedEntry;\n\t\t\t}\n\t\t}\n\t\telse if (mode == SCANF_NEXT_PAGE)\n\t\t{\n\t\t\tif (iSelectedEntry < iFirstEntry + OsdGetSize() - 1)\n\t\t\t{\n\t\t\t\tiSelectedEntry = iFirstEntry + OsdGetSize() - 1;\n\t\t\t\tif (iSelectedEntry >= recent_available()) iSelectedEntry = recent_available() - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiSelectedEntry += OsdGetSize();\n\t\t\t\tiFirstEntry += OsdGetSize();\n\t\t\t\tif (iSelectedEntry >= recent_available())\n\t\t\t\t{\n\t\t\t\t\tiSelectedEntry = recent_available() - 1;\n\t\t\t\t\tiFirstEntry = iSelectedEntry - OsdGetSize() + 1;\n\t\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t\t}\n\t\t\t\telse if (iFirstEntry + OsdGetSize() > recent_available())\n\t\t\t\t{\n\t\t\t\t\tiFirstEntry = recent_available() - OsdGetSize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (mode == SCANF_PREV_PAGE)\n\t\t{\n\t\t\tif (iSelectedEntry != iFirstEntry)\n\t\t\t{\n\t\t\t\tiSelectedEntry = iFirstEntry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tiFirstEntry -= OsdGetSize();\n\t\t\t\tif (iFirstEntry < 0) iFirstEntry = 0;\n\t\t\t\tiSelectedEntry = iFirstEntry;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid recent_scroll_name()\n{\n\t// this function is called periodically when file selection window is displayed\n\t// it checks if predefined period of time has elapsed and scrolls the name if necessary\n\tint len;\n\tint max_len;\n\tstatic char name[256 + 4];\n\n\t// don't scroll if the file doesn't exist\n\tif (!ena[iSelectedEntry]) return;\n\n\tname[0] = 32;\n\tstrcpy(name + 1, recents[iSelectedEntry].label);\n\n\tlen = strlen(name); // get name length\n\n\tmax_len = 30;\n\tScrollText(iSelectedEntry - iFirstEntry, name, 1, len, max_len, 1);\n}\n\nvoid recent_print()\n{\n\tint k;\n\tint len;\n\n\tstatic char s[256+4];\n\n\tScrollReset();\n\n\tfor (int i = 0; i < OsdGetSize(); i++)\n\t{\n\t\tchar leftchar = 0;\n\t\tunsigned char d = 1;\n\t\tif (i < recent_available())\n\t\t{\n\t\t\tk = iFirstEntry + i;\n\n\t\t\ts[0] = 32;\n\t\t\tchar* name = recents[k].label;\n\t\t\tstrcpy(s + 1, name);\n\n\t\t\tlen = strlen(s); // get name length\n\n\t\t\ts[len] = 0;\n\n\t\t\tif (len > 28)\n\t\t\t{\n\t\t\t\tlen = 27; // trim display length if longer than 30 characters\n\t\t\t\ts[28] = 22;\n\t\t\t}\n\n\t\t\ts[29] = 0;\n\n\t\t\tif (!i && k) leftchar = 17;\n\t\t\tif ((i == OsdGetSize() - 1) && (k < recent_available() - 1)) leftchar = 16;\n\n\t\t\td = ena[k] ? 0 : 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemset(s, ' ', 32);\n\t\t}\n\n\t\tOsdWriteOffset(i, s, i == (iSelectedEntry - iFirstEntry) && recent_available(), d, 0, leftchar);\n\t}\n}\n\nint recent_select(char *dir, char *path, char *label)\n{\n\t// copy directory and file name over\n\tdir[0] = 0;\n\tpath[0] = 0;\n\n\tif (!recent_available()) return 0;\n\n\tif (strlen(recents[iSelectedEntry].name))\n\t{\n\t\tstrcpy(dir, recents[iSelectedEntry].dir);\n\t\tstrcpy(path, recent_path(recents[iSelectedEntry].dir, recents[iSelectedEntry].name));\n\t\tstrcpy(label, recents[iSelectedEntry].label);\n\t}\n\n\treturn ena[iSelectedEntry];\n}\n\nvoid recent_update(char* dir, char* path, char* label, int idx)\n{\n\tif (!cfg.recents || !strlen(path)) return;\n\n\t// separate the path into directory and filename\n\tchar* name = strrchr(path, '/');\n\tif (name) name++; else name = path;\n\n\t// load the current state.  this is necessary because we may have started a ROM from multiple sources\n\trecent_load(idx);\n\n\t// update the selection\n\tint indexToErase = RECENT_MAX - 1;\n\trecent_rec_t rec = {};\n\tstrncpy(rec.dir, dir, sizeof(rec.dir)-1);\n\tstrncpy(rec.name, name, sizeof(rec.name)-1);\n\tstrncpy(rec.label, label ? label : name, sizeof(rec.label)-1);\n\n\tfor (unsigned i = 0; i < sizeof(recents)/sizeof(recents[0]); i++)\n\t{\n\t\tif (!strcmp(recents[i].dir, dir) && !strcmp(recents[i].name, name))\n\t\t{\n\t\t\tindexToErase = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(indexToErase) memmove(recents + 1, recents, sizeof(recents[0])*indexToErase);\n\tmemcpy(recents, &rec, sizeof(recents[0]));\n\n\t// store the config file to storage\n\tFileSaveConfig(recent_create_config_name(idx), recents, sizeof(recents));\n}\n\nvoid recent_clear(int idx)\n{\n\tmemset(recents, 0, sizeof(recents));\n\n\t// store the config file to storage\n\tFileSaveConfig(recent_create_config_name(idx), recents, sizeof(recents));\n}\n"
        },
        {
          "name": "recent.h",
          "type": "blob",
          "size": 0.2880859375,
          "content": "#ifndef RECENT_H\n#define RECENT_H\n\nint  recent_init(int idx);\nvoid recent_scan(int mode);\nvoid recent_scroll_name();\nvoid recent_print();\nint  recent_select(char *dir, char *path, char *label);\nvoid recent_update(char* dir, char* path, char* label, int idx);\nvoid recent_clear(int idx);\n\n#endif\n"
        },
        {
          "name": "releases",
          "type": "tree",
          "content": null
        },
        {
          "name": "scaler.cpp",
          "type": "blob",
          "size": 4.396484375,
          "content": "/*\nCopyright 2019 alanswx\nwith help from the MiSTer contributors including Grabulosaure\n*/\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <sched.h>\n#include <inttypes.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\n#include <sys/types.h>\n#include <err.h>\n\n#include \"scaler.h\"\n#include \"shmem.h\"\n\n\nmister_scaler * mister_scaler_init()\n{\n    mister_scaler *ms =(mister_scaler *) calloc(sizeof(mister_scaler),1);\n    int\t pagesize = sysconf(_SC_PAGE_SIZE);\n    if (pagesize==0) pagesize=4096;\n    int offset = MISTER_SCALER_BASEADDR;\n    int\tmap_start = offset & ~(pagesize - 1);\n    ms->map_off = offset - map_start;\n    ms->num_bytes=MISTER_SCALER_BUFFERSIZE;\n    //printf(\"map_start = %d map_off=%d offset=%d\\n\",map_start,ms->map_off,offset);\n\n    unsigned char *buffer;\n    ms->map=(char *)shmem_map(map_start, ms->num_bytes+ms->map_off);\n    if (!ms->map)\n    {\n        mister_scaler_free(ms);\n        return NULL;\n    }\n    buffer = (unsigned char *)(ms->map+ms->map_off);\n    printf (\" 1: %02X %02X %02X %02X   %02X %02X %02X %02X   %02X %02X %02X %02X   %02X %02X %02X %02X\\n\",\n            buffer[0],buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6],buffer[7],\n            buffer[8],buffer[9],buffer[10],buffer[11],buffer[12],buffer[13],buffer[14],buffer[15]);\n    if (buffer[0]!=1 || buffer[1]!=1) {\n        printf(\"problem\\n\");\n        mister_scaler_free(ms);\n        return NULL;\n    }\n\n    ms->header=buffer[2]<<8 | buffer[3];\n    ms->width =buffer[6]<<8 | buffer[7];\n    ms->height=buffer[8]<<8 | buffer[9];\n    ms->line  =buffer[10]<<8 | buffer[11];\n    ms->output_width =buffer[12]<<8 | buffer[13];\n    ms->output_height=buffer[14]<<8 | buffer[15];\n\n    printf (\"Image: Width=%i Height=%i  Line=%i  Header=%i output_width=%i output_height=%i \\n\",ms->width,ms->height,ms->line,ms->header,ms->output_width,ms->output_height);\n   /*\n    printf (\" 1: %02X %02X %02X %02X   %02X %02X %02X %02X   %02X %02X %02X %02X   %02X %02X %02X %02X\\n\",\n            buffer[0],buffer[1],buffer[2],buffer[3],buffer[4],buffer[5],buffer[6],buffer[7],\n            buffer[8],buffer[9],buffer[10],buffer[11],buffer[12],buffer[13],buffer[14],buffer[15]);\n    */\n\n   return ms;\n\n}\n\nvoid mister_scaler_free(mister_scaler *ms)\n{\n   shmem_unmap(ms->map,ms->num_bytes+ms->map_off);\n   free(ms);\n}\n\nint mister_scaler_read_yuv(mister_scaler *ms,int lineY,unsigned char *bufY, int lineU, unsigned char *bufU, int lineV, unsigned char *bufV)\n{\n    unsigned char *buffer;\n    buffer = (unsigned char *)(ms->map+ms->map_off);\n\n    // do this slow way for now..\n    unsigned char *pixbuf;\n    unsigned char *outbufy;\n    unsigned char *outbufU;\n    unsigned char *outbufV;\n    for (int  y=0; y< ms->height ; y++)\n\t{\n        pixbuf=&buffer[ms->header + y*ms->line];\n        outbufy=&bufY[y*(lineY)];\n        outbufU=&bufU[y*(lineU)];\n        outbufV=&bufV[y*(lineV)];\n        for (int x = 0; x < ms->width ; x++)\n\t\t{\n\t\t\tint R,G,B;\n\t\t\tR = *pixbuf++;\n\t\t\tG = *pixbuf++;\n\t\t\tB = *pixbuf++;\n\t\t\tint Y =  (0.257 * R) + (0.504 * G) + (0.098 * B) + 16;\n\t\t\tint U = -(0.148 * R) - (0.291 * G) + (0.439 * B) + 128;\n\t\t\tint V =  (0.439 * R) - (0.368 * G) - (0.071 * B) + 128;\n\n\t\t\t*outbufy++ = Y;\n\t\t\t*outbufU++ = U;\n\t\t\t*outbufV++ = V;\n        }\n    }\n\n    return 0;\n}\n\nint mister_scaler_read(mister_scaler *ms,unsigned char *gbuf)\n{\n    unsigned char *buffer;\n    buffer = (unsigned char *)(ms->map+ms->map_off);\n\n    // do this slow way for now..  - could use a memcpy?\n    unsigned char *pixbuf;\n    unsigned char *outbuf;\n    for (int  y=0; y< ms->height ; y++) {\n          pixbuf=&buffer[ms->header + y*ms->line];\n          outbuf=&gbuf[y*(ms->width*3)];\n          for (int x = 0; x < ms->width ; x++) {\n            *outbuf++ = *pixbuf++;\n            *outbuf++ = *pixbuf++;\n            *outbuf++ = *pixbuf++;\n          }\n    }\n\n    return 0;\n}\n\nint mister_scaler_read_32(mister_scaler *ms, unsigned char *gbuf) {\n    unsigned char *buffer;\n    buffer = (unsigned char *)(ms->map+ms->map_off);\n\n    // do this slow way for now..  - could use a memcpy?\n    unsigned char *pixbuf;\n    unsigned char *outbuf;\n    for (int  y=0; y< ms->height ; y++) {\n          pixbuf=&buffer[ms->header + y*ms->line];\n          outbuf=&gbuf[y*(ms->width*4)];\n          for (int x = 0; x < ms->width ; x++) {\n            outbuf[2] = *pixbuf++;\n            outbuf[1] = *pixbuf++;\n            outbuf[0] = *pixbuf++;\n            outbuf[3] = 0xFF;\n\t    outbuf+=4;\n          }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "scaler.h",
          "type": "blob",
          "size": 0.71875,
          "content": "/*\nCopyright 2019 alanswx\nwith help from the MiSTer contributors including Grabulosaure\n*/\n\n#ifndef SCALER_H\n#define SCALER_H\n\ntypedef struct {\n   int header;\n   int width;\n   int height;\n   int line;\n   int output_width;\n   int output_height;\n\n   char *map;\n   int num_bytes;\n   int map_off;\n} mister_scaler;\n\n#define MISTER_SCALER_BASEADDR     0x20000000\n#define MISTER_SCALER_BUFFERSIZE   2048*3*1024\n\nmister_scaler *mister_scaler_init();\nint mister_scaler_read(mister_scaler *,unsigned char *buffer);\nint mister_scaler_read_32(mister_scaler *ms, unsigned char *buffer);\nint mister_scaler_read_yuv(mister_scaler *ms,int,unsigned char *y,int, unsigned char *U,int, unsigned char *V);\nvoid mister_scaler_free(mister_scaler *);\n\n#endif\n"
        },
        {
          "name": "scheduler.cpp",
          "type": "blob",
          "size": 1.333984375,
          "content": "#include \"scheduler.h\"\n#include <stdio.h>\n#include \"libco.h\"\n#include \"menu.h\"\n#include \"user_io.h\"\n#include \"input.h\"\n#include \"fpga_io.h\"\n#include \"osd.h\"\n#include \"profiling.h\"\n\nstatic cothread_t co_scheduler = nullptr;\nstatic cothread_t co_poll = nullptr;\nstatic cothread_t co_ui = nullptr;\nstatic cothread_t co_last = nullptr;\n\nstatic void scheduler_wait_fpga_ready(void)\n{\n\twhile (!is_fpga_ready(1))\n\t{\n\t\tfpga_wait_to_reset();\n\t}\n}\n\nstatic void scheduler_co_poll(void)\n{\n\tfor (;;)\n\t{\n\t\tscheduler_wait_fpga_ready();\n\n\t\t{\n\t\t\tSPIKE_SCOPE(\"co_poll\", 1000);\n\t\t\tuser_io_poll();\n\t\t\tinput_poll(0);\n\t\t}\n\n\t\tscheduler_yield();\n\t}\n}\n\nstatic void scheduler_co_ui(void)\n{\n\tfor (;;)\n\t{\n\t\t{\n\t\t\tSPIKE_SCOPE(\"co_ui\", 1000);\n\t\t\tHandleUI();\n\t\t\tOsdUpdate();\n\t\t}\n\n\t\tscheduler_yield();\n\t}\n}\n\nstatic void scheduler_schedule(void)\n{\n\tif (co_last == co_poll)\n\t{\n\t\tco_last = co_ui;\n\t\tco_switch(co_ui);\n\t}\n\telse\n\t{\n\t\tco_last = co_poll;\n\t\tco_switch(co_poll);\n\t}\n}\n\nvoid scheduler_init(void)\n{\n\tconst unsigned int co_stack_size = 262144 * sizeof(void*);\n\n\tco_poll = co_create(co_stack_size, scheduler_co_poll);\n\tco_ui = co_create(co_stack_size, scheduler_co_ui);\n}\n\nvoid scheduler_run(void)\n{\n\tco_scheduler = co_active();\n\n\tfor (;;)\n\t{\n\t\tscheduler_schedule();\n\t}\n\n\tco_delete(co_ui);\n\tco_delete(co_poll);\n\tco_delete(co_scheduler);\n}\n\nvoid scheduler_yield(void)\n{\n\tco_switch(co_scheduler);\n}\n"
        },
        {
          "name": "scheduler.h",
          "type": "blob",
          "size": 0.1494140625,
          "content": "#ifndef SCHEDULER_H\n#define SCHEDULER_H\n\n#define USE_SCHEDULER\n\nvoid scheduler_init(void);\nvoid scheduler_run(void);\nvoid scheduler_yield(void);\n\n#endif\n"
        },
        {
          "name": "setup_default_toolchain.sh",
          "type": "blob",
          "size": 0.96875,
          "content": "#!/bin/bash\n\nif [ \"${BASH_SOURCE[0]}\" -ef \"$0\" ]\nthen\n    echo \"This script should be sourced, not executed.\"\n    exit 1\nfi\n\necho \"Setting up default toolchain...\"\n\nif [ -z \"${MISTER_GCC_INSTALL_DIR}\" ]; then\n\tMISTER_GCC_INSTALL_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\nfi\nif [ -z \"${MISTER_GCC_VER}\" ]; then\n\tMISTER_GCC_VER=10.2-2020.11\nfi\nif [ -z \"${MISTER_GCC_HOST_ARCH}\" ]; then\n\tMISTER_GCC_HOST_ARCH=x86_64\nfi\nGCC_PACKAGE_NAME=gcc-arm-$MISTER_GCC_VER-$MISTER_GCC_HOST_ARCH-arm-none-linux-gnueabihf\nGCC_DIR=$MISTER_GCC_INSTALL_DIR/$GCC_PACKAGE_NAME\n\nif [ ! -d $GCC_DIR ]; then\n\techo \"Downloading $GCC_PACKAGE_NAME...\"\n\tGCC_TARBALL=$GCC_PACKAGE_NAME.tar.xz\n\twget --no-check-certificate -c https://developer.arm.com/-/media/Files/downloads/gnu-a/$MISTER_GCC_VER/binrel/$GCC_TARBALL\n\ttar xvf $GCC_TARBALL\n\trm $GCC_TARBALL\nfi\n\necho \"Setting environment variables...\"\nexport CC=$GCC_DIR/bin/arm-none-gnueabihf-gcc\nexport PATH=\"$GCC_DIR/bin:$PATH\"\n\necho \"Done!\"\n"
        },
        {
          "name": "shmem.cpp",
          "type": "blob",
          "size": 1.2529296875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <ctype.h>\n#include <termios.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include \"shmem.h\"\n\nstatic int memfd = -1;\n\nvoid *shmem_map(uint32_t address, uint32_t size)\n{\n\tif (memfd < 0)\n\t{\n\t\tmemfd = open(\"/dev/mem\", O_RDWR | O_SYNC | O_CLOEXEC);\n\t\tif (memfd == -1)\n\t\t{\n\t\t\tprintf(\"Error: Unable to open /dev/mem!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid *res = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, memfd, address);\n\tif (res == (void *)-1)\n\t{\n\t\tprintf(\"Error: Unable to mmap (0x%X, %d)!\\n\", address, size);\n\t\treturn 0;\n\t}\n\n\treturn res;\n}\n\nint shmem_unmap(void* map, uint32_t size)\n{\n\tif (munmap(map, size) < 0)\n\t{\n\t\tprintf(\"Error: Unable to unmap(0x%X, %d)!\\n\", (uint32_t)map, size);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint shmem_put(uint32_t address, uint32_t size, void *buf)\n{\n\tvoid *shmem = shmem_map(address, size);\n\tif (shmem)\n\t{\n\t\tmemcpy(shmem, buf, size);\n\t\tshmem_unmap(shmem, size);\n\t}\n\n\treturn shmem != 0;\n}\n\nint shmem_get(uint32_t address, uint32_t size, void *buf)\n{\n\tvoid *shmem = shmem_map(address, size);\n\tif (shmem)\n\t{\n\t\tmemcpy(buf, shmem, size);\n\t\tshmem_unmap(shmem, size);\n\t}\n\n\treturn shmem != 0;\n}\n"
        },
        {
          "name": "shmem.h",
          "type": "blob",
          "size": 0.3203125,
          "content": "\n#include <stdint.h>\n\n#ifndef SHMEM_H\n#define SHMEM_H\n\nvoid *shmem_map(uint32_t address, uint32_t size);\nint shmem_unmap(void* map, uint32_t size);\nint shmem_put(uint32_t address, uint32_t size, void *buf);\nint shmem_get(uint32_t address, uint32_t size, void *buf);\n\n#define fpga_mem(x) (0x20000000 | ((x) & 0x1FFFFFFF))\n#endif\n"
        },
        {
          "name": "smbus.cpp",
          "type": "blob",
          "size": 6.787109375,
          "content": "/*\n    smbus.c - SMBus level access helper functions\n\n    Copyright (C) 1995-1997  Simon G. Vogl\n    Copyright (C) 1998-1999  Frodo Looijaard <frodol@dds.nl>\n    Copyright (C) 2012-2013  Jean Delvare <jdelvare@suse.de>\n\n    This library is free software; you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation; either version 2.1 of the License, or\n    (at your option) any later version.\n*/\n\n#include <errno.h>\n#include <stddef.h>\n#include <unistd.h>\n#include <linux/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n\n#include \"smbus.h\"\n\n#define I2C_SLAVE                   0x0703\n#define I2C_SMBUS                   0x0720\t/* SMBus-level access */\n\n#define I2C_SMBUS_READ              1\n#define I2C_SMBUS_WRITE\t            0\n\n// SMBus transaction types\n#define I2C_SMBUS_QUICK\t\t        0\n#define I2C_SMBUS_BYTE\t\t        1\n#define I2C_SMBUS_BYTE_DATA\t        2\n#define I2C_SMBUS_WORD_DATA\t        3\n#define I2C_SMBUS_PROC_CALL\t        4\n#define I2C_SMBUS_BLOCK_DATA        5\n#define I2C_SMBUS_I2C_BLOCK_BROKEN  6\n#define I2C_SMBUS_BLOCK_PROC_CALL   7   /* SMBus 2.0 */\n#define I2C_SMBUS_I2C_BLOCK_DATA    8\n\n// SMBus messages\n#define I2C_SMBUS_BLOCK_MAX\t        32  /* As specified in SMBus standard */\n\nunion i2c_smbus_data\n{\n\tuint8_t  byte;\n\tuint16_t word;\n\tuint8_t  block[I2C_SMBUS_BLOCK_MAX + 2];\t// block [0] is used for length + one more for PEC\n};\n\nstruct i2c_smbus_ioctl_data\n{\n\tuint8_t read_write;\n\tuint8_t command;\n\tuint32_t size;\n\tunion i2c_smbus_data *data;\n};\n\nstatic int i2c_smbus_access(int file, char read_write, uint8_t command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tstruct i2c_smbus_ioctl_data args;\n\tint err;\n\n\targs.read_write = read_write;\n\targs.command = command;\n\targs.size = size;\n\targs.data = data;\n\n\terr = ioctl(file, I2C_SMBUS, &args);\n\tif (err == -1) err = -errno;\n\treturn err;\n}\n\nint i2c_smbus_write_quick(int file, uint8_t value)\n{\n\treturn i2c_smbus_access(file, value, 0, I2C_SMBUS_QUICK, NULL);\n}\n\nint i2c_smbus_read_byte(int file)\n{\n\tunion i2c_smbus_data data;\n\tint err;\n\n\terr = i2c_smbus_access(file, I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &data);\n\tif (err < 0) return err;\n\n\treturn 0x0FF & data.byte;\n}\n\nint i2c_smbus_write_byte(int file, uint8_t value)\n{\n\treturn i2c_smbus_access(file, I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);\n}\n\nint i2c_smbus_read_byte_data(int file, uint8_t command)\n{\n\tunion i2c_smbus_data data;\n\tint err;\n\n\terr = i2c_smbus_access(file, I2C_SMBUS_READ, command, I2C_SMBUS_BYTE_DATA, &data);\n\tif (err < 0) return err;\n\n\treturn 0x0FF & data.byte;\n}\n\nint i2c_smbus_write_byte_data(int file, uint8_t command, uint8_t value)\n{\n\t//printf(\"i2c: %02X %02X\\n\", command, value);\n\tunion i2c_smbus_data data;\n\tdata.byte = value;\n\treturn i2c_smbus_access(file, I2C_SMBUS_WRITE, command, I2C_SMBUS_BYTE_DATA, &data);\n}\n\nint i2c_smbus_read_word_data(int file, uint8_t command)\n{\n\tunion i2c_smbus_data data;\n\tint err;\n\n\terr = i2c_smbus_access(file, I2C_SMBUS_READ, command, I2C_SMBUS_WORD_DATA, &data);\n\tif (err < 0) return err;\n\n\treturn 0x0FFFF & data.word;\n}\n\nint i2c_smbus_write_word_data(int file, uint8_t command, uint16_t value)\n{\n\tunion i2c_smbus_data data;\n\tdata.word = value;\n\treturn i2c_smbus_access(file, I2C_SMBUS_WRITE, command, I2C_SMBUS_WORD_DATA, &data);\n}\n\nint i2c_smbus_process_call(int file, uint8_t command, uint16_t value)\n{\n\tunion i2c_smbus_data data;\n\tdata.word = value;\n\tif (i2c_smbus_access(file, I2C_SMBUS_WRITE, command, I2C_SMBUS_PROC_CALL, &data)) return -1;\n\telse return 0x0FFFF & data.word;\n}\n\n/* Returns the number of read bytes */\nint i2c_smbus_read_block_data(int file, uint8_t command, uint8_t *values)\n{\n\tunion i2c_smbus_data data;\n\tint i, err;\n\n\terr = i2c_smbus_access(file, I2C_SMBUS_READ, command, I2C_SMBUS_BLOCK_DATA, &data);\n\tif (err < 0) return err;\n\n\tfor (i = 1; i <= data.block[0]; i++) values[i-1] = data.block[i];\n\treturn data.block[0];\n}\n\nint i2c_smbus_write_block_data(int file, uint8_t command, uint8_t length, const uint8_t *values)\n{\n\tunion i2c_smbus_data data;\n\tint i;\n\tif (length > I2C_SMBUS_BLOCK_MAX) length = I2C_SMBUS_BLOCK_MAX;\n\tfor (i = 1; i <= length; i++) data.block[i] = values[i-1];\n\tdata.block[0] = length;\n\treturn i2c_smbus_access(file, I2C_SMBUS_WRITE, command, I2C_SMBUS_BLOCK_DATA, &data);\n}\n\n/* Returns the number of read bytes */\n/* Until kernel 2.6.22, the length is hardcoded to 32 bytes. If you\n   ask for less than 32 bytes, your code will only work with kernels\n   2.6.23 and later. */\nint i2c_smbus_read_i2c_block_data(int file, uint8_t command, uint8_t length, uint8_t *values)\n{\n\tunion i2c_smbus_data data;\n\tint i, err;\n\n\tif (length > I2C_SMBUS_BLOCK_MAX) length = I2C_SMBUS_BLOCK_MAX;\n\tdata.block[0] = length;\n\n\terr = i2c_smbus_access(file, I2C_SMBUS_READ, command, length == 32 ? I2C_SMBUS_I2C_BLOCK_BROKEN : I2C_SMBUS_I2C_BLOCK_DATA, &data);\n\tif (err < 0) return err;\n\n\tfor (i = 1; i <= data.block[0]; i++) values[i-1] = data.block[i];\n\treturn data.block[0];\n}\n\nint i2c_smbus_write_i2c_block_data(int file, uint8_t command, uint8_t length, const uint8_t *values)\n{\n\tunion i2c_smbus_data data;\n\tint i;\n\tif (length > I2C_SMBUS_BLOCK_MAX) length = I2C_SMBUS_BLOCK_MAX;\n\tfor (i = 1; i <= length; i++) data.block[i] = values[i-1];\n\tdata.block[0] = length;\n\treturn i2c_smbus_access(file, I2C_SMBUS_WRITE, command, I2C_SMBUS_I2C_BLOCK_BROKEN, &data);\n}\n\n/* Returns the number of read bytes */\nint i2c_smbus_block_process_call(int file, uint8_t command, uint8_t length, uint8_t *values)\n{\n\tunion i2c_smbus_data data;\n\tint i, err;\n\n\tif (length > I2C_SMBUS_BLOCK_MAX) length = I2C_SMBUS_BLOCK_MAX;\n\tfor (i = 1; i <= length; i++) data.block[i] = values[i-1];\n\tdata.block[0] = length;\n\n\terr = i2c_smbus_access(file, I2C_SMBUS_WRITE, command, I2C_SMBUS_BLOCK_PROC_CALL, &data);\n\tif (err < 0) return err;\n\n\tfor (i = 1; i <= data.block[0]; i++) values[i-1] = data.block[i];\n\treturn data.block[0];\n}\n\nint i2c_open(int dev_address, int is_smbus)\n{\n\tchar str[16];\n\tfor (int bus = 0; bus < 3; bus++)\n\t{\n\t\tint fd;\n\t\tsprintf(str, \"/dev/i2c-%d\", bus);\n\n\t\tif ((fd = open(str, O_RDWR | O_CLOEXEC)) < 0)\n\t\t{\n\t\t\t//printf(\"Unable to open I2C bus %s: %s\\n\", str, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ioctl(fd, I2C_SLAVE, dev_address) < 0)\n\t\t{\n\t\t\t//printf(\"Unable to select I2C device 0x%X on bus %s: %s\\n\", dev_address, str, strerror(errno));\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_smbus)\n\t\t{\n\t\t\tif (i2c_smbus_write_quick(fd, 0) < 0)\n\t\t\t{\n\t\t\t\t//printf(\"Unable to detect SMBUS device on bus %s: %s\\n\", str, strerror(errno));\n\t\t\t\tclose(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (i2c_smbus_read_byte(fd) < 0)\n\t\t\t{\n\t\t\t\t//printf(\"Unable to detect I2C device on bus %s: %s\\n\", str, strerror(errno));\n\t\t\t\tclose(fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"Opened %s for device 0x%X\\n\", str, dev_address);\n\t\treturn fd;\n\t}\n\n\treturn -1;\n}\n\nvoid i2c_close(int fd)\n{\n\tif (fd >= 0) close(fd);\n}\n"
        },
        {
          "name": "smbus.h",
          "type": "blob",
          "size": 1.041015625,
          "content": "#include <stdint.h>\n\n#ifndef SMBUS_H\n#define SMBUS_H\n\nint i2c_open(int dev_address, int is_smbus);\nvoid i2c_close(int fd);\n\nint i2c_smbus_write_quick(int file, uint8_t value);\nint i2c_smbus_read_byte(int file);\nint i2c_smbus_write_byte(int file, uint8_t value);\nint i2c_smbus_read_byte_data(int file, uint8_t command);\nint i2c_smbus_write_byte_data(int file, uint8_t command, uint8_t value);\nint i2c_smbus_read_word_data(int file, uint8_t command);\nint i2c_smbus_write_word_data(int file, uint8_t command, uint16_t value);\nint i2c_smbus_process_call(int file, uint8_t command, uint16_t value);\nint i2c_smbus_read_block_data(int file, uint8_t command, uint8_t *values);\nint i2c_smbus_write_block_data(int file, uint8_t command, uint8_t length, const uint8_t *values);\nint i2c_smbus_read_i2c_block_data(int file, uint8_t command, uint8_t length, uint8_t *values);\nint i2c_smbus_write_i2c_block_data(int file, uint8_t command, uint8_t length, const uint8_t *values);\nint i2c_smbus_block_process_call(int file, uint8_t command, uint8_t length, uint8_t *values);\n\n#endif\n"
        },
        {
          "name": "spi.cpp",
          "type": "blob",
          "size": 3.3203125,
          "content": "#include \"spi.h\"\n#include \"hardware.h\"\n#include \"fpga_io.h\"\n\n#define SSPI_FPGA_EN (1<<18)\n#define SSPI_OSD_EN  (1<<19)\n#define SSPI_IO_EN   (1<<20)\n\n#define SWAPW(a) ((((a)<<8)&0xff00)|(((a)>>8)&0x00ff))\n\nvoid EnableFpga()\n{\n\tfpga_spi_en(SSPI_FPGA_EN, 1);\n}\n\nvoid DisableFpga()\n{\n\tfpga_spi_en(SSPI_FPGA_EN, 0);\n}\n\nstatic int osd_target = OSD_ALL;\n\nvoid EnableOsd_on(int target)\n{\n\tif (!(target & OSD_ALL)) target = OSD_ALL;\n\tosd_target = target;\n}\n\nvoid EnableOsd()\n{\n\tif (!(osd_target & OSD_ALL)) osd_target = OSD_ALL;\n\n\tuint32_t mask = SSPI_OSD_EN | SSPI_IO_EN | SSPI_FPGA_EN;\n\tif (osd_target & OSD_HDMI) mask &= ~SSPI_FPGA_EN;\n\tif (osd_target & OSD_VGA) mask &= ~SSPI_IO_EN;\n\n\tfpga_spi_en(mask, 1);\n}\n\nvoid DisableOsd()\n{\n\tfpga_spi_en(SSPI_OSD_EN | SSPI_IO_EN | SSPI_FPGA_EN, 0);\n}\n\nvoid EnableIO()\n{\n\tfpga_spi_en(SSPI_IO_EN, 1);\n}\n\nvoid DisableIO()\n{\n\tfpga_spi_en(SSPI_IO_EN, 0);\n}\n\nuint32_t spi32_w(uint32_t parm)\n{\n\tuint32_t res;\n\tres = spi_w(parm);\n\tres |= (spi_w(parm>>16))<<16;\n\treturn res;\n}\n\n// little endian: lsb first\nvoid spi32_b(uint32_t parm)\n{\n\tspi_b(parm >> 0);\n\tspi_b(parm >> 8);\n\tspi_b(parm >> 16);\n\tspi_b(parm >> 24);\n}\n\n/* OSD related SPI functions */\nvoid spi_osd_cmd_cont(uint8_t cmd)\n{\n\tEnableOsd();\n\tspi_b(cmd);\n}\n\nvoid spi_osd_cmd(uint8_t cmd)\n{\n\tspi_osd_cmd_cont(cmd);\n\tDisableOsd();\n}\n\nvoid spi_osd_cmd8_cont(uint8_t cmd, uint8_t parm)\n{\n\tEnableOsd();\n\tspi_b(cmd);\n\tspi_b(parm);\n}\n\nvoid spi_osd_cmd8(uint8_t cmd, uint8_t parm)\n{\n\tspi_osd_cmd8_cont(cmd, parm);\n\tDisableOsd();\n}\n\nvoid spi_uio_cmd32_cont(uint8_t cmd, uint32_t parm)\n{\n\tEnableIO();\n\tspi_b(cmd);\n\tspi32_b(parm);\n}\n\n/* User_io related SPI functions */\nuint16_t spi_uio_cmd_cont(uint16_t cmd)\n{\n\tEnableIO();\n\treturn spi_w(cmd);\n}\n\nuint16_t spi_uio_cmd(uint16_t cmd)\n{\n\tuint16_t res = spi_uio_cmd_cont(cmd);\n\tDisableIO();\n\treturn res;\n}\n\nuint8_t spi_uio_cmd8_cont(uint8_t cmd, uint8_t parm)\n{\n\tEnableIO();\n\tspi_b(cmd);\n\treturn spi_b(parm);\n}\n\nuint8_t spi_uio_cmd8(uint8_t cmd, uint8_t parm)\n{\n\tuint8_t res = spi_uio_cmd8_cont(cmd, parm);\n\tDisableIO();\n\treturn res;\n}\n\nuint16_t spi_uio_cmd16(uint8_t cmd, uint16_t parm)\n{\n\tspi_uio_cmd_cont(cmd);\n\tuint16_t res = spi_w(parm);\n\tDisableIO();\n\treturn res;\n}\n\nvoid spi_uio_cmd32(uint8_t cmd, uint32_t parm, int wide)\n{\n\tEnableIO();\n\tspi_b(cmd);\n\tif (wide)\n\t{\n\t\tspi_w((uint16_t)parm);\n\t\tspi_w((uint16_t)(parm >> 16));\n\t}\n\telse\n\t{\n\t\tspi_b(parm);\n\t\tspi_b(parm >> 8);\n\t\tspi_b(parm >> 16);\n\t\tspi_b(parm >> 24);\n\t}\n\tDisableIO();\n}\n\nvoid spi_n(uint8_t value, uint16_t cnt)\n{\n\twhile (cnt--) spi_b(value);\n}\n\nvoid spi_read(uint8_t *addr, uint32_t len, int wide)\n{\n\tif (wide)\n\t{\n\t\tuint32_t len16 = len >> 1;\n\t\tuint16_t *a16 = (uint16_t*)addr;\n\t\twhile (len16--) *a16++ = spi_w(0);\n\t\tif (len & 1) *((uint8_t*)a16) = spi_w(0);\n\t}\n\telse\n\t{\n\t\twhile (len--) *addr++ = spi_b(0);\n\t}\n}\n\nvoid spi_write(const uint8_t *addr, uint32_t len, int wide)\n{\n\tif (wide)\n\t{\n\t\tuint32_t len16 = len >> 1;\n\t\tuint16_t *a16 = (uint16_t*)addr;\n\t\twhile (len16--) spi_w(*a16++);\n\t\tif(len & 1) spi_w(*((uint8_t*)a16));\n\t}\n\telse\n\t{\n\t\twhile (len--) spi_b(*addr++);\n\t}\n}\n\nvoid spi_block_read(uint8_t *addr, int wide, int sz)\n{\n\tif (wide) fpga_spi_fast_block_read((uint16_t*)addr, sz/2);\n\telse fpga_spi_fast_block_read_8(addr, sz);\n}\n\nvoid spi_block_write(const uint8_t *addr, int wide, int sz)\n{\n\tif (wide) fpga_spi_fast_block_write((const uint16_t*)addr, sz/2);\n\telse fpga_spi_fast_block_write_8(addr, sz);\n}\n"
        },
        {
          "name": "spi.h",
          "type": "blob",
          "size": 1.4775390625,
          "content": "#ifndef SPI_H\n#define SPI_H\n\n#include <inttypes.h>\n#include \"fpga_io.h\"\n\n#define OSD_HDMI 1\n#define OSD_VGA  2\n#define OSD_ALL  (OSD_VGA|OSD_HDMI)\n\n/* chip select functions */\nvoid EnableFpga();\nvoid DisableFpga();\nvoid EnableOsd();\nvoid DisableOsd();\nvoid EnableIO();\nvoid DisableIO();\n\n// base functions\nuint8_t  inline spi_b(uint8_t parm)\n{\n\treturn (uint8_t)fpga_spi(parm);\n}\n\nuint16_t inline spi_w(uint16_t word)\n{\n\treturn fpga_spi(word);\n}\n\n// input only helper\nuint8_t inline spi_in()\n{\n\treturn (uint8_t)fpga_spi(0);\n}\n\n#define spi8(x) spi_b(x)\n\nvoid spi32_b(uint32_t parm);\nuint32_t spi32_w(uint32_t parm);\n\n/* block transfer functions */\nvoid spi_read(uint8_t *addr, uint32_t len, int wide);\nvoid spi_write(const uint8_t *addr, uint32_t len, int wide);\nvoid spi_block_read(uint8_t *addr, int wide, int sz = 512);\nvoid spi_block_write(const uint8_t *addr, int wide, int sz = 512);\n\n/* OSD related SPI functions */\nvoid EnableOsd_on(int target);\nvoid spi_osd_cmd_cont(uint8_t cmd);\nvoid spi_osd_cmd(uint8_t cmd);\nvoid spi_osd_cmd8_cont(uint8_t cmd, uint8_t parm);\nvoid spi_osd_cmd8(uint8_t cmd, uint8_t parm);\n\n/* User_io related SPI functions */\nuint16_t spi_uio_cmd_cont(uint16_t cmd);\nuint16_t spi_uio_cmd(uint16_t cmd);\nuint8_t spi_uio_cmd8_cont(uint8_t cmd, uint8_t parm);\nuint8_t spi_uio_cmd8(uint8_t cmd, uint8_t parm);\nuint16_t spi_uio_cmd16(uint8_t cmd, uint16_t parm);\nvoid spi_uio_cmd32(uint8_t cmd, uint32_t parm, int wide);\nvoid spi_uio_cmd32_cont(uint8_t cmd, uint32_t parm);\n\n#endif // SPI_H\n"
        },
        {
          "name": "str_util.cpp",
          "type": "blob",
          "size": 0.822265625,
          "content": "#include \"str_util.h\"\n\n#include <string.h>\n\nint str_tokenize(char *s, const char *delim, char **tokens, int max_tokens)\n{\n\tchar *save_ptr = nullptr;\n\tint count = 0;\n\n\tchar *token = strtok_r(s, delim, &save_ptr);\n\n\twhile (token && count < max_tokens)\n\t{\n\t\ttokens[count] = token;\n\t\tcount++;\n\t\ttoken = strtok_r(nullptr, delim, &save_ptr);\n\t}\n\n\treturn count;\n}\n\nchar *strncpyz(char *dest, size_t dest_size, const char *src, size_t num)\n{\n\tsize_t n = num >= dest_size ? dest_size - 1 : num;\n\tstrncpy(dest, src, n);\n\tdest[n] = '\\0';\n\n\treturn dest;\n}\n\nchar *strcpyz(char *dest, size_t dest_size, const char *src)\n{\n\treturn strncpyz(dest, dest_size, src, dest_size - 1);\n}\n\nunsigned int str_hash(const char *s, unsigned int initial)\n{\n\tunsigned int hash = initial;\n\tint c;\n\n\twhile((c = *s++))\n\t{\n\t\thash = ((hash << 5) + hash) + c;\n\t}\n\n\treturn hash;\n}"
        },
        {
          "name": "str_util.h",
          "type": "blob",
          "size": 0.8623046875,
          "content": "/*\n* str_util.h\n*\n*/\n\n#ifndef STR_UTIL_H\n#define STR_UTIL_H\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdio.h>\n\nint str_tokenize(char *s, const char *delim, char **tokens, int max_tokens);\n\n// String copy with guaranteed null termination\nchar *strncpyz(char *dest, size_t dest_size, const char *src, size_t num);\nchar *strcpyz(char *dest, size_t dest_size, const char *src);\n\ntemplate<size_t N>\nchar *strncpyz(char (&dest)[N], const char *src, size_t num)\n{\n\treturn strncpyz(dest, N, src, num);\n}\n\ntemplate<size_t N>\nchar *strcpyz(char (&dest)[N], const char *src)\n{\n\treturn strcpyz(dest, N, src);\n}\n\ntemplate<size_t N>\nsize_t sprintfz(char (&dest)[N], const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tsize_t r = vsnprintf(dest, N, fmt, args);\n\tva_end(args);\n\treturn r;\n}\n\nunsigned int str_hash(const char *s, unsigned int initial = 5381);\n\n#endif // STR_UTIL_H"
        },
        {
          "name": "support.h",
          "type": "blob",
          "size": 1.095703125,
          "content": "// Minimig support\n#include \"support/minimig/minimig_config.h\"\n#include \"support/minimig/minimig_boot.h\"\n#include \"support/minimig/minimig_fdd.h\"\n#include \"support/minimig/minimig_share.h\"\n\n// SharpMz support\n#include \"support/sharpmz/sharpmz.h\"\n\n// Archie support\n#include \"support/archie/archie.h\"\n\n// ST (Atari) support\n#include \"support/st/st_tos.h\"\n\n// X86  support\n#include \"support/x86/x86.h\"\n\n// SNES  support\n#include \"support/snes/snes.h\"\n\n// N64  support\n#include \"support/n64/n64.h\"\n#include \"support/n64/n64_joy_emu.h\"\n\n// NeoGeo  support\n#include \"support/neogeo/neogeo_loader.h\"\n#include \"support/neogeo/neogeocd.h\"\n\n\n// Arcade support\n#include \"support/arcade/mra_loader.h\"\n\n// MEGACD  support\n#include \"support/megacd/megacd.h\"\n\n// C64 support\n#include \"support/c64/c64.h\"\n\n// PCECD  support\n#include \"support/pcecd/pcecd.h\"\n\n// PSX support\n#include \"support/psx/psx.h\"\n\n// CD-i support\n#include \"support/cdi/cdi.h\"\n\n// UEF support\n#include \"support/uef/uef_reader.h\"\n\n// Saturn  support\n#include \"support/saturn/saturn.h\"\n\n// N64 support\n#include \"support/n64/n64.h\"\n#include \"support/n64/n64_joy_emu.h\"\n"
        },
        {
          "name": "support",
          "type": "tree",
          "content": null
        },
        {
          "name": "sxmlc.c",
          "type": "blob",
          "size": 62.619140625,
          "content": "/*\n\tCopyright (c) 2010, Matthieu Labas\n\tAll rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification,\n\tare permitted provided that the following conditions are met:\n\n\t1. Redistributions of source code must retain the above copyright notice,\n\t   this list of conditions and the following disclaimer.\n\n\t2. Redistributions in binary form must reproduce the above copyright notice,\n\t   this list of conditions and the following disclaimer in the documentation\n\t   and/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n\tANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\tWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n\tIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n\tINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n\tNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\tPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\tWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\tARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n\tOF SUCH DAMAGE.\n\n\tThe views and conclusions contained in the software and documentation are those of the\n\tauthors and should not be interpreted as representing official policies, either expressed\n\tor implied, of the FreeBSD Project.\n*/\n#if defined(WIN32) || defined(WIN64)\n#pragma warning(disable : 4996)\n#else\n#ifndef strdup\n#define _GNU_SOURCE\n#endif\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"sxmlc.h\"\n\n/*\n Struct defining \"special\" tags such as \"<? ?>\" or \"<![CDATA[ ]]/>\".\n These tags are considered having a start and an end with some data in between that will\n be stored in the 'tag' member of an XMLNode.\n The 'tag_type' member is a constant that is associated to such tag.\n All 'len_*' members are basically the \"sx_strlen()\" of 'start' and 'end' members.\n */\ntypedef struct _Tag {\n\tTagType tag_type;\n\tSXML_CHAR* start;\n\tint len_start;\n\tSXML_CHAR* end;\n\tint len_end;\n} _TAG;\n\ntypedef struct _SpecialTag {\n\t_TAG *tags;\n\tint n_tags;\n} SPECIAL_TAG;\n\n/*\n List of \"special\" tags handled by sxmlc.\n NB the \"<!DOCTYPE\" tag has a special handling because its 'end' changes according\n to its content ('>' or ']>').\n */\nstatic _TAG _spec[] = {\n\t\t{ TAG_INSTR, C2SX(\"<?\"), 2, C2SX(\"?>\"), 2 },\n\t\t{ TAG_COMMENT, C2SX(\"<!--\"), 4, C2SX(\"-->\"), 3 },\n\t\t{ TAG_CDATA, C2SX(\"<![CDATA[\"), 9, C2SX(\"]]>\"), 3 }\n};\nstatic int NB_SPECIAL_TAGS = (int)(sizeof(_spec) / sizeof(_TAG)); /* Auto computation of number of special tags */\n\n/*\n User-registered tags.\n */\nstatic SPECIAL_TAG _user_tags = { NULL, 0 };\n\nint XML_register_user_tag(TagType tag_type, SXML_CHAR* start, SXML_CHAR* end)\n{\n\t_TAG* p;\n\tint i, n, le;\n\n\tif (tag_type < TAG_USER)\n\t\treturn -1;\n\n\tif (start == NULL || end == NULL || *start != C2SX('<'))\n\t\treturn -1;\n\n\tle = sx_strlen(end);\n\tif (end[le-1] != C2SX('>'))\n\t\treturn -1;\n\n\ti = _user_tags.n_tags;\n\tn = i + 1;\n\tp = (_TAG*)__realloc(_user_tags.tags, n * sizeof(_TAG));\n\tif (p == NULL)\n\t\treturn -1;\n\n\tp[i].tag_type = tag_type;\n\tp[i].start = start;\n\tp[i].end = end;\n\tp[i].len_start = sx_strlen(start);\n\tp[i].len_end = le;\n\t_user_tags.tags = p;\n\t_user_tags.n_tags = n;\n\n\treturn i;\n}\n\nint XML_unregister_user_tag(int i_tag)\n{\n\t_TAG* pt;\n\n\tif (i_tag < 0 || i_tag >= _user_tags.n_tags)\n \t\treturn -1;\n\n\tif (_user_tags.n_tags == 1)\n\t\tpt = NULL;\n\telse {\n\t\tpt = (_TAG*)__malloc((_user_tags.n_tags - 1) * sizeof(_TAG));\n\t\tif (pt == NULL)\n\t\t\treturn -1;\n\t}\n\n\tif (pt != NULL) {\n\t\tmemcpy(pt, _user_tags.tags, i_tag * sizeof(_TAG));\n\t\tmemcpy(&pt[i_tag], &_user_tags.tags[i_tag + 1], (_user_tags.n_tags - i_tag - 1) * sizeof(_TAG));\n\t}\n\tif (_user_tags.tags != NULL)\n\t\t__free(_user_tags.tags);\n\t_user_tags.tags = pt;\n\t_user_tags.n_tags--;\n\n\treturn _user_tags.n_tags;\n}\n\nint XML_get_nb_registered_user_tags(void)\n{\n\treturn _user_tags.n_tags;\n}\n\nint XML_get_registered_user_tag(TagType tag_type)\n{\n\tint i;\n\n\tfor (i = 0; i < _user_tags.n_tags; i++)\n\t\tif (_user_tags.tags[i].tag_type == tag_type)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\n/* --- XMLNode methods --- */\n\n/*\n Add 'node' to given '*children_array' of '*len_array' elements.\n '*len_array' is overwritten with the number of elements in '*children_array' after its reallocation.\n Return the index of the newly added 'node' in '*children_array', or '-1' for memory error.\n */\nstatic int _add_node(XMLNode*** children_array, int* len_array, XMLNode* node)\n{\n\tXMLNode** pt = (XMLNode**)__realloc(*children_array, (*len_array+1) * sizeof(XMLNode*));\n\n\tif (pt == NULL)\n\t\treturn -1;\n\n\tpt[*len_array] = node;\n\t*children_array = pt;\n\n\treturn (*len_array)++;\n}\n\nint XMLNode_init(XMLNode* node)\n{\n\tif (node == NULL)\n\t\treturn false;\n\n\tif (node->init_value == XML_INIT_DONE)\n\t\treturn true; /*(void)XMLNode_free(node);*/\n\n\tnode->tag = NULL;\n\tnode->text = NULL;\n\n\tnode->attributes = NULL;\n\tnode->n_attributes = 0;\n\n\tnode->father = NULL;\n\tnode->children = NULL;\n\tnode->n_children = 0;\n\n\tnode->tag_type = TAG_NONE;\n\tnode->active = true;\n\n\tnode->init_value = XML_INIT_DONE;\n\n\treturn true;\n}\n\nXMLNode* XMLNode_allocN(int n)\n{\n\tint i;\n\tXMLNode* p;\n\n\tif (n <= 0)\n\t\treturn NULL;\n\n\tp = (XMLNode*)__calloc(n, sizeof(XMLNode));\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n; i++)\n\t\t(void)XMLNode_init(&p[i]);\n\n\treturn p;\n}\n\nXMLNode* XMLNode_dup(const XMLNode* node, int copy_children)\n{\n\tXMLNode* n;\n\n\tif (node == NULL)\n\t\treturn NULL;\n\n\tn = (XMLNode*)__calloc(1, sizeof(XMLNode));\n\tif (n == NULL)\n\t\treturn NULL;\n\n\tXMLNode_init(n);\n\tif (!XMLNode_copy(n, node, copy_children)) {\n\t\tXMLNode_free(n);\n\n\t\treturn NULL;\n\t}\n\n\treturn n;\n}\n\nint XMLNode_free(XMLNode* node)\n{\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tif (node->tag != NULL) {\n\t\t__free(node->tag);\n\t\tnode->tag = NULL;\n\t}\n\n\tXMLNode_remove_text(node);\n\tXMLNode_remove_all_attributes(node);\n\tXMLNode_remove_children(node);\n\n\tnode->tag_type = TAG_NONE;\n\n\treturn true;\n}\n\nint XMLNode_copy(XMLNode* dst, const XMLNode* src, int copy_children)\n{\n\tint i;\n\n\tif (dst == NULL || (src != NULL && src->init_value != XML_INIT_DONE))\n\t\treturn false;\n\n\t(void)XMLNode_free(dst); /* 'dst' is freed first */\n\n\t/* NULL 'src' resets 'dst' */\n\tif (src == NULL)\n\t\treturn true;\n\n\t/* Tag */\n\tif (src->tag != NULL) {\n\t\tdst->tag = sx_strdup(src->tag);\n\t\tif (dst->tag == NULL) goto copy_err;\n\t}\n\n\t/* Text */\n\tif (dst->text != NULL) {\n\t\tdst->text = sx_strdup(src->text);\n\t\tif (dst->text == NULL) goto copy_err;\n\t}\n\n\t/* Attributes */\n\tif (src->n_attributes > 0) {\n\t\tdst->attributes = (XMLAttribute*)__calloc(src->n_attributes, sizeof(XMLAttribute));\n\t\tif (dst->attributes== NULL) goto copy_err;\n\t\tdst->n_attributes = src->n_attributes;\n\t\tfor (i = 0; i < src->n_attributes; i++) {\n\t\t\tdst->attributes[i].name = sx_strdup(src->attributes[i].name);\n\t\t\tdst->attributes[i].value = sx_strdup(src->attributes[i].value);\n\t\t\tif (dst->attributes[i].name == NULL || dst->attributes[i].value == NULL) goto copy_err;\n\t\t\tdst->attributes[i].active = src->attributes[i].active;\n\t\t}\n\t}\n\n\tdst->tag_type = src->tag_type;\n\tdst->father = src->father;\n\tdst->user = src->user;\n\tdst->active = src->active;\n\n\t/* Copy children if required (and there are any) */\n\tif (copy_children && src->n_children > 0) {\n\t\tdst->children = (XMLNode**)__calloc(src->n_children, sizeof(XMLNode*));\n\t\tif (dst->children == NULL) goto copy_err;\n\t\tdst->n_children = src->n_children;\n\t\tfor (i = 0; i < src->n_children; i++) {\n\t\t\tif (!XMLNode_copy(dst->children[i], src->children[i], true)) goto copy_err;\n\t\t}\n\t}\n\n\treturn true;\n\ncopy_err:\n\t(void)XMLNode_free(dst);\n\n\treturn false;\n}\n\nint XMLNode_set_active(XMLNode* node, int active)\n{\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tnode->active = active;\n\n\treturn true;\n}\n\nint XMLNode_set_tag(XMLNode* node, const SXML_CHAR* tag)\n{\n\tSXML_CHAR* newtag;\n\tif (node == NULL || tag == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tnewtag = sx_strdup(tag);\n\tif (newtag == NULL)\n\t\treturn false;\n\tif (node->tag != NULL) __free(node->tag);\n\tnode->tag = newtag;\n\n\treturn true;\n}\n\nint XMLNode_set_type(XMLNode* node, const TagType tag_type)\n{\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tswitch (tag_type) {\n\t\tcase TAG_ERROR:\n\t\tcase TAG_END:\n\t\tcase TAG_PARTIAL:\n\t\tcase TAG_NONE:\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\tnode->tag_type = tag_type;\n\t\t\treturn true;\n\t}\n}\n\nint XMLNode_set_attribute(XMLNode* node, const SXML_CHAR* attr_name, const SXML_CHAR* attr_value)\n{\n\tXMLAttribute* pt;\n\tint i;\n\n\tif (node == NULL || attr_name == NULL || attr_name[0] == NULC || node->init_value != XML_INIT_DONE)\n\t\treturn -1;\n\n\ti = XMLNode_search_attribute(node, attr_name, 0);\n\tif (i >= 0) { /* Attribute found: update it */\n\t\tSXML_CHAR* value = NULL;\n\t\tif (attr_value != NULL && (value = sx_strdup(attr_value)) == NULL)\n\t\t\treturn -1;\n\t\tpt = node->attributes;\n\t\tif (pt[i].value != NULL)\n\t\t\t__free(pt[i].value);\n\t\tpt[i].value = value;\n\t} else { /* Attribute not found: add it */\n\t\tSXML_CHAR* name = sx_strdup(attr_name);\n\t\tSXML_CHAR* value = (attr_value == NULL ? NULL : sx_strdup(attr_value));\n\t\tif (name == NULL || (value == NULL && attr_value != NULL)) {\n\t\t\tif (value != NULL)\n\t\t\t\t__free(value);\n\t\t\tif (name != NULL)\n\t\t\t\t__free(name);\n \t\t\treturn -1;\n\t\t}\n\t\ti = node->n_attributes;\n\t\tpt = (XMLAttribute*)__realloc(node->attributes, (i+1) * sizeof(XMLAttribute));\n\t\tif (pt == NULL) {\n\t\t\tif (value != NULL)\n\t\t\t\t__free(value);\n\t\t\t__free(name);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpt[i].name = name;\n\t\tpt[i].value = value;\n\t\tpt[i].active = true;\n\t\tnode->attributes = pt;\n\t\tnode->n_attributes = i + 1;\n\t}\n\n\treturn node->n_attributes;\n}\n\nint XMLNode_get_attribute_with_default(XMLNode* node, const SXML_CHAR* attr_name, const SXML_CHAR** attr_value, const SXML_CHAR* default_attr_value)\n{\n\tXMLAttribute* pt;\n\tint i;\n\n\tif (node == NULL || attr_name == NULL || attr_name[0] == NULC || attr_value == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\ti = XMLNode_search_attribute(node, attr_name, 0);\n\tif (i >= 0) {\n\t\tpt = node->attributes;\n\t\tif (pt[i].value != NULL) {\n\t\t\t*attr_value = sx_strdup(pt[i].value);\n\t\t\tif (*attr_value == NULL)\n\t\t\t\treturn false;\n\t\t} else\n\t\t\t*attr_value = NULL; /* NULL but returns 'true' as 'NULL' is the actual attribute value */\n\t} else if (default_attr_value != NULL) {\n\t\t*attr_value = sx_strdup(default_attr_value);\n\t\tif (*attr_value == NULL)\n\t\t\treturn false;\n\t} else\n\t\t*attr_value = NULL;\n\n\treturn true;\n}\n\nint XMLNode_get_attribute_count(const XMLNode* node)\n{\n\tint i, n;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn -1;\n\n\tfor (i = n = 0; i < node->n_attributes; i++)\n\t\tif (node->attributes[i].active) n++;\n\n\treturn n;\n}\n\nint XMLNode_search_attribute(const XMLNode* node, const SXML_CHAR* attr_name, int i_search)\n{\n\tint i;\n\n\tif (node == NULL || attr_name == NULL || attr_name[0] == NULC || i_search < 0 || i_search >= node->n_attributes)\n\t\treturn -1;\n\n\tfor (i = i_search; i < node->n_attributes; i++)\n\t\tif (node->attributes[i].active && !sx_strcmp(node->attributes[i].name, attr_name))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nint XMLNode_remove_attribute(XMLNode* node, int i_attr)\n{\n\tXMLAttribute* pt;\n\tif (node == NULL || node->init_value != XML_INIT_DONE || i_attr < 0 || i_attr >= node->n_attributes)\n\t\treturn -1;\n\n\t/* Before modifying first see if we run out of memory */\n\tif (node->n_attributes == 1)\n\t\tpt = NULL;\n\telse {\n\t\tpt = (XMLAttribute*)__malloc((node->n_attributes - 1) * sizeof(XMLAttribute));\n\t\tif (pt == NULL)\n\t\t\treturn -1;\n\t}\n\n\t/* Can't fail anymore, free item */\n\tif (node->attributes[i_attr].name != NULL) __free(node->attributes[i_attr].name);\n\tif (node->attributes[i_attr].value != NULL) __free(node->attributes[i_attr].value);\n\n\tif (pt != NULL) {\n\t\tmemcpy(pt, node->attributes, i_attr * sizeof(XMLAttribute));\n\t\tmemcpy(&pt[i_attr], &node->attributes[i_attr + 1], (node->n_attributes - i_attr - 1) * sizeof(XMLAttribute));\n\t}\n\tif (node->attributes != NULL)\n\t\t__free(node->attributes);\n\tnode->attributes = pt;\n\tnode->n_attributes--;\n\n\treturn node->n_attributes;\n}\n\nint XMLNode_remove_all_attributes(XMLNode* node)\n{\n\tint i;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tif (node->attributes != NULL) {\n\t\tfor (i = 0; i < node->n_attributes; i++) {\n\t\t\tif (node->attributes[i].name != NULL)\n\t\t\t\t__free(node->attributes[i].name);\n\t\t\tif (node->attributes[i].value != NULL)\n\t\t\t\t__free(node->attributes[i].value);\n\t\t}\n\t\t__free(node->attributes);\n\t\tnode->attributes = NULL;\n\t}\n\tnode->n_attributes = 0;\n\n\treturn true;\n}\n\nint XMLNode_set_text(XMLNode* node, const SXML_CHAR* text)\n{\n\tSXML_CHAR* p;\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tif (text == NULL) { /* We want to remove it => free node text */\n\t\tif (node->text != NULL) {\n\t\t\t__free(node->text);\n\t\t\tnode->text = NULL;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tp = (SXML_CHAR*)__realloc(node->text, (sx_strlen(text) + 1)*sizeof(SXML_CHAR)); /* +1 for '\\0' */\n\tif (p == NULL)\n\t\treturn false;\n\tnode->text = p;\n\n\tsx_strcpy(node->text, text);\n\n\treturn true;\n}\n\nint XMLNode_add_child(XMLNode* node, XMLNode* child)\n{\n\tif (node == NULL || child == NULL || node->init_value != XML_INIT_DONE || child->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tif (_add_node(&node->children, &node->n_children, child) >= 0) {\n\t\tnode->tag_type = TAG_FATHER;\n\t\tchild->father = node;\n\t\treturn true;\n\t} else\n\t\treturn false;\n}\n\nint XMLNode_get_children_count(const XMLNode* node)\n{\n\tint i, n;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn -1;\n\n\tfor (i = n = 0; i < node->n_children; i++)\n\t\tif (node->children[i]->active) n++;\n\n\treturn n;\n}\n\nXMLNode* XMLNode_get_child(const XMLNode* node, int i_child)\n{\n\tint i;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_children)\n\t\treturn NULL;\n\n\tfor (i = 0; i < node->n_children; i++) {\n\t\tif (!node->children[i]->active)\n\t\t\ti_child++;\n\t\telse if (i == i_child)\n\t\t\treturn node->children[i];\n\t}\n\n\treturn NULL;\n}\n\nint XMLNode_remove_child(XMLNode* node, int i_child, int free_child)\n{\n\tint i;\n\tXMLNode** pt;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_children)\n\t\treturn -1;\n\n\t/* Lookup 'i_child'th active child */\n\tfor (i = 0; i < node->n_children; i++) {\n\t\tif (!node->children[i]->active)\n\t\t\ti_child++;\n\t\telse if (i == i_child)\n\t\t\tbreak;\n\t}\n\tif (i >= node->n_children)\n\t\treturn -1; /* Children is not found */\n\n\t/* Before modifying first see if we run out of memory */\n\tif (node->n_children == 1)\n\t\tpt = NULL;\n\telse {\n\t\tpt = (XMLNode**)__malloc((node->n_children - 1) * sizeof(XMLNode*));\n\t\tif (pt == NULL)\n\t\t\treturn -1;\n\t}\n\n\t/* Can't fail anymore, free item */\n\t(void)XMLNode_free(node->children[i_child]);\n\tif (free_child)\n\t\t__free(node->children[i_child]);\n\n\tif (pt != NULL) {\n\t\tmemcpy(pt, node->children, i_child * sizeof(XMLNode*));\n\t\tmemcpy(&pt[i_child], &node->children[i_child + 1], (node->n_children - i_child - 1) * sizeof(XMLNode*));\n\t}\n\tif (node->children != NULL)\n\t\t__free(node->children);\n\tnode->children = pt;\n\tnode->n_children--;\n\tif (node->n_children == 0)\n\t\tnode->tag_type = TAG_SELF;\n\n\treturn node->n_children;\n}\n\nint XMLNode_remove_children(XMLNode* node)\n{\n\tint i;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tif (node->children != NULL) {\n\t\tfor (i = 0; i < node->n_children; i++)\n\t\t\tif (node->children[i] != NULL) {\n\t\t\t\t(void)XMLNode_free(node->children[i]);\n\t\t\t\t__free(node->children[i]);\n\t\t\t}\n\t\t__free(node->children);\n\t\tnode->children = NULL;\n\t}\n\tnode->n_children = 0;\n\n\treturn true;\n}\n\nint XMLNode_equal(const XMLNode* node1, const XMLNode* node2)\n{\n\tint i, j;\n\n\tif (node1 == node2)\n\t\treturn true;\n\n\tif (node1 == NULL || node2 == NULL || node1->init_value != XML_INIT_DONE || node2->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tif (sx_strcmp(node1->tag, node2->tag))\n\t\treturn false;\n\n\t/* Test all attributes from 'node1' */\n\tfor (i = 0; i < node1->n_attributes; i++) {\n\t\tif (!node1->attributes[i].active)\n\t\t\tcontinue;\n\t\tj = XMLNode_search_attribute(node2, node1->attributes[i].name, 0);\n\t\tif (j < 0)\n\t\t\treturn false;\n\t\tif (sx_strcmp(node1->attributes[i].value, node2->attributes[j].value))\n\t\t\treturn false;\n\t}\n\n\t/* Test other attributes from 'node2' that might not be in 'node1' */\n\tfor (i = 0; i < node2->n_attributes; i++) {\n\t\tif (!node2->attributes[i].active)\n\t\t\tcontinue;\n\t\tj = XMLNode_search_attribute(node1, node2->attributes[i].name, 0);\n\t\tif (j < 0)\n\t\t\treturn false;\n\t\tif (sx_strcmp(node2->attributes[i].name, node1->attributes[j].name))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nXMLNode* XMLNode_next_sibling(const XMLNode* node)\n{\n\tint i;\n\tXMLNode* father;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE || node->father == NULL)\n\t\treturn NULL;\n\n\tfather = node->father;\n\tfor (i = 0; i < father->n_children && father->children[i] != node; i++) ;\n\ti++; /* father->children[i] is now 'node' next sibling */\n\n\treturn i < father->n_children ? father->children[i] : NULL;\n}\n\nstatic XMLNode* _XMLNode_next(const XMLNode* node, int in_children)\n{\n\tXMLNode* node2;\n\n\tif (node == NULL || node->init_value != XML_INIT_DONE)\n\t\treturn NULL;\n\n\t/* Check first child */\n\tif (in_children && node->n_children > 0)\n\t\treturn node->children[0];\n\n\t/* Check next sibling */\n\tif ((node2 = XMLNode_next_sibling(node)) != NULL)\n\t\treturn node2;\n\n\t/* Check next uncle */\n\treturn _XMLNode_next(node->father, false);\n}\n\nXMLNode* XMLNode_next(const XMLNode* node)\n{\n\treturn _XMLNode_next(node, true);\n}\n\n/* --- XMLDoc methods --- */\n\nint XMLDoc_init(XMLDoc* doc)\n{\n\tif (doc == NULL)\n\t\treturn false;\n\n\tdoc->filename[0] = NULC;\n#ifdef SXMLC_UNICODE\n\tmemset(&doc->bom, 0, sizeof(doc->bom));\n#endif\n\tdoc->nodes = NULL;\n\tdoc->n_nodes = 0;\n\tdoc->i_root = -1;\n\tdoc->init_value = XML_INIT_DONE;\n\n\treturn true;\n}\n\nint XMLDoc_free(XMLDoc* doc)\n{\n\tint i;\n\n\tif (doc == NULL || doc->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tfor (i = 0; i < doc->n_nodes; i++) {\n\t\t(void)XMLNode_free(doc->nodes[i]);\n\t\t__free(doc->nodes[i]);\n\t}\n\t__free(doc->nodes);\n\tdoc->nodes = NULL;\n\tdoc->n_nodes = 0;\n\tdoc->i_root = -1;\n\n\treturn true;\n}\n\nint XMLDoc_set_root(XMLDoc* doc, int i_root)\n{\n\tif (doc == NULL || doc->init_value != XML_INIT_DONE || i_root < 0 || i_root >= doc->n_nodes)\n\t\treturn false;\n\n\tdoc->i_root = i_root;\n\n\treturn true;\n}\n\nint XMLDoc_add_node(XMLDoc* doc, XMLNode* node)\n{\n\tif (doc == NULL || node == NULL || doc->init_value != XML_INIT_DONE)\n\t\treturn -1;\n\n\tif (_add_node(&doc->nodes, &doc->n_nodes, node) < 0)\n\t\treturn -1;\n\n\tif (node->tag_type == TAG_FATHER)\n\t\tdoc->i_root = doc->n_nodes - 1; /* Main root node is the last father node */\n\n\treturn doc->n_nodes;\n}\n\nint XMLDoc_remove_node(XMLDoc* doc, int i_node, int free_node)\n{\n\tXMLNode** pt;\n\tif (doc == NULL || doc->init_value != XML_INIT_DONE || i_node < 0 || i_node > doc->n_nodes)\n\t\treturn false;\n\n\t/* Before modifying first see if we run out of memory */\n\tif (doc->n_nodes == 1)\n\t\tpt = NULL;\n\telse {\n\t\tpt = (XMLNode**)__malloc((doc->n_nodes - 1) * sizeof(XMLNode*));\n\t\tif (pt == NULL)\n\t\t\treturn false;\n\t}\n\n\t/* Can't fail anymore, free item */\n\t(void)XMLNode_free(doc->nodes[i_node]);\n\tif (free_node) __free(doc->nodes[i_node]);\n\n\tif (pt != NULL) {\n\t\tmemcpy(pt, &doc->nodes[i_node], i_node * sizeof(XMLNode*));\n\t\tmemcpy(&pt[i_node], &doc->nodes[i_node + 1], (doc->n_nodes - i_node - 1) * sizeof(XMLNode*));\n\t}\n\n\tif (doc->nodes != NULL)\n\t\t__free(doc->nodes);\n\tdoc->nodes = pt;\n\tdoc->n_nodes--;\n\n\treturn true;\n}\n\n/*\n Helper functions to print formatting before a new tag.\n Returns the new number of characters in the line.\n */\nstatic int _count_new_char_line(const SXML_CHAR* str, int nb_char_tab, int cur_sz_line)\n{\n\tfor (; *str; str++) {\n\t\tif (*str == C2SX('\\n'))\n\t\t\tcur_sz_line = 0;\n\t\telse if (*str == C2SX('\\t'))\n\t\t\tcur_sz_line += nb_char_tab;\n\t\telse\n\t\t\tcur_sz_line++;\n\t}\n\n\treturn cur_sz_line;\n}\nstatic int _print_formatting(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* child_sep, int nb_char_tab, int cur_sz_line)\n{\n\tif (tag_sep != NULL) {\n\t\tsx_fprintf(f, tag_sep);\n\t\tcur_sz_line = _count_new_char_line(tag_sep, nb_char_tab, cur_sz_line);\n\t}\n\tif (child_sep != NULL) {\n\t\tfor (node = node->father; node != NULL; node = node->father) {\n\t\t\tsx_fprintf(f, child_sep);\n\t\t\tcur_sz_line = _count_new_char_line(child_sep, nb_char_tab, cur_sz_line);\n\t\t}\n\t}\n\n\treturn cur_sz_line;\n}\n\nstatic int _XMLNode_print_header(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* child_sep, const SXML_CHAR* attr_sep, int sz_line, int cur_sz_line, int nb_char_tab)\n{\n\tint i;\n\tSXML_CHAR* p;\n\n\tif (node == NULL || f == NULL || !node->active || node->tag == NULL || node->tag[0] == NULC)\n\t\treturn -1;\n\n\t/* Special handling of DOCTYPE */\n\tif (node->tag_type == TAG_DOCTYPE) {\n\t\t/* Search for an unescaped '[' in the DOCTYPE definition, in which case the end delimiter should be ']>' instead of '>' */\n\t\tfor (p = sx_strchr(node->tag, C2SX('[')); p != NULL && *(p-1) == C2SX('\\\\'); p = sx_strchr(p+1, C2SX('['))) ;\n\t\tcur_sz_line += sx_fprintf(f, C2SX(\"<!DOCTYPE%s%s>\"), node->tag, p != NULL ? C2SX(\"]\") : C2SX(\"\"));\n\t\treturn cur_sz_line;\n\t}\n\n\t/* Check for special tags first */\n\tfor (i = 0; i < NB_SPECIAL_TAGS; i++) {\n\t\tif (node->tag_type == _spec[i].tag_type) {\n\t\t\tsx_fprintf(f, C2SX(\"%s%s%s\"), _spec[i].start, node->tag, _spec[i].end);\n\t\t\tcur_sz_line += sx_strlen(_spec[i].start) + sx_strlen(node->tag) + sx_strlen(_spec[i].end);\n\t\t\treturn cur_sz_line;\n\t\t}\n\t}\n\n\t/* Check for user tags */\n\tfor (i = 0; i < _user_tags.n_tags; i++) {\n\t\tif (node->tag_type == _user_tags.tags[i].tag_type) {\n\t\t\tsx_fprintf(f, C2SX(\"%s%s%s\"), _user_tags.tags[i].start, node->tag, _user_tags.tags[i].end);\n\t\t\tcur_sz_line += sx_strlen(_user_tags.tags[i].start) + sx_strlen(node->tag) + sx_strlen(_user_tags.tags[i].end);\n\t\t\treturn cur_sz_line;\n\t\t}\n\t}\n\n\t/* Print tag name */\n\tcur_sz_line += sx_fprintf(f, C2SX(\"<%s\"), node->tag);\n\n\t/* Print attributes */\n\tfor (i = 0; i < node->n_attributes; i++) {\n\t\tif (!node->attributes[i].active)\n\t\t\tcontinue;\n\t\tcur_sz_line += sx_strlen(node->attributes[i].name) + sx_strlen(node->attributes[i].value) + 3;\n\t\tif (sz_line > 0 && cur_sz_line > sz_line) {\n\t\t\tcur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);\n\t\t\t/* Add extra separator, as if new line was a child of the previous one */\n\t\t\tif (child_sep != NULL) {\n\t\t\t\tsx_fprintf(f, child_sep);\n\t\t\t\tcur_sz_line = _count_new_char_line(child_sep, nb_char_tab, cur_sz_line);\n\t\t\t}\n\t\t}\n\t\t/* Attribute name */\n\t\tif (attr_sep != NULL) {\n\t\t\tsx_fprintf(f, attr_sep);\n\t\t\tcur_sz_line = _count_new_char_line(attr_sep, nb_char_tab, cur_sz_line);\n\t\t\tsx_fprintf(f, C2SX(\"%s=\"), node->attributes[i].name);\n\t\t} else\n\t\t\tsx_fprintf(f, C2SX(\" %s=\"), node->attributes[i].name);\n\n\t\t/* Attribute value */\n\t\t(void)sx_fputc(XML_DEFAULT_QUOTE, f);\n\t\tcur_sz_line += fprintHTML(f, node->attributes[i].value) + 2;\n\t\t(void)sx_fputc(XML_DEFAULT_QUOTE, f);\n\t}\n\n\t/* End the tag if there are no children and no text */\n\tif (node->n_children == 0 && (node->text == NULL || node->text[0] == NULC)) {\n\t\tcur_sz_line += sx_fprintf(f, C2SX(\"/>\"));\n\t} else {\n\t\t(void)sx_fputc(C2SX('>'), f);\n\t\tcur_sz_line++;\n\t}\n\n\treturn cur_sz_line;\n}\n\nint XMLNode_print_header(const XMLNode* node, FILE* f, int sz_line, int nb_char_tab)\n{\n\treturn _XMLNode_print_header(node, f, NULL, NULL, NULL, sz_line, 0, nb_char_tab) < 0 ? false : true;\n}\n\nstatic int _XMLNode_print(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* child_sep, const SXML_CHAR* attr_sep, int keep_text_spaces, int sz_line, int cur_sz_line, int nb_char_tab, int depth)\n{\n\tint i;\n\tSXML_CHAR* p;\n\n\tif (node != NULL && node->tag_type==TAG_TEXT) { /* Text has to be printed: check if it is only spaces */\n\t\tif (!keep_text_spaces) {\n\t\t\tfor (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space character, or to '\\0' if only spaces */\n\t\t} else\n\t\t\tp = node->text; /* '*p' won't be '\\0' */\n\t\tif (*p != NULC)\n\t\t\tcur_sz_line += fprintHTML(f, node->text);\n\t\treturn cur_sz_line;\n\t}\n\n\tif (node == NULL || f == NULL || !node->active || node->tag == NULL || node->tag[0] == NULC)\n\t\treturn -1;\n\n\tif (nb_char_tab <= 0)\n\t\tnb_char_tab = 1;\n\n\t/* Print formatting */\n\tif (depth < 0) /* UGLY HACK: 'depth' forced negative on very first line so we don't print an extra 'tag_sep' (usually \"\\n\" when pretty-printing) */\n\t\tdepth = 0;\n\telse\n\t\tcur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);\n\n\t_XMLNode_print_header(node, f, tag_sep, child_sep, attr_sep, sz_line, cur_sz_line, nb_char_tab);\n\n\tif (node->text != NULL && node->text[0] != NULC) {\n\t\t/* Text has to be printed: check if it is only spaces */\n\t\tif (!keep_text_spaces) {\n\t\t\tfor (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space character, or to '\\0' if only spaces */\n\t\t} else\n\t\t\tp = node->text; /* '*p' won't be '\\0' */\n\t\tif (*p != NULC) cur_sz_line += fprintHTML(f, node->text);\n\t} else if (node->n_children <= 0) /* Everything has already been printed */\n\t\treturn cur_sz_line;\n\n\t/* Recursively print children */\n\tfor (i = 0; i < node->n_children; i++)\n\t\t(void)_XMLNode_print(node->children[i], f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz_line, cur_sz_line, nb_char_tab, depth+1);\n\n\t/* Print tag end after children */\n\t\t/* Print formatting */\n\tif (node->n_children > 0)\n\t\tcur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);\n\tcur_sz_line += sx_fprintf(f, C2SX(\"</%s>\"), node->tag);\n\n\treturn cur_sz_line;\n}\n\nint XMLNode_print_attr_sep(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* child_sep, const SXML_CHAR* attr_sep, int keep_text_spaces, int sz_line, int nb_char_tab)\n{\n\treturn _XMLNode_print(node, f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz_line, 0, nb_char_tab, 0);\n}\n\nint XMLDoc_print_attr_sep(const XMLDoc* doc, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* child_sep, const SXML_CHAR* attr_sep, int keep_text_spaces, int sz_line, int nb_char_tab)\n{\n\tint i, depth, cur_sz_line;\n\n\tif (doc == NULL || f == NULL || doc->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n#ifdef SXMLC_UNICODE\n\t/* Write BOM if it exist */\n\tif (doc->sz_bom > 0) fwrite(doc->bom, sizeof(unsigned char), doc->sz_bom, f);\n#endif\n\n\tdepth = -1; /* UGLY HACK: 'depth' forced negative on very first line so we don't print an extra 'tag_sep' (usually \"\\n\") */\n\tfor (i = 0, cur_sz_line = 0; i < doc->n_nodes; i++) {\n\t\tcur_sz_line = _XMLNode_print(doc->nodes[i], f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz_line, cur_sz_line, nb_char_tab, depth);\n\t\tdepth = 0;\n\t}\n\t/* TODO: Find something more graceful than 'depth=-1', even though everyone knows I probably never will ;) */\n\n\treturn true;\n}\n\n/* --- */\n\nint XML_parse_attribute_to(const SXML_CHAR* str, int to, XMLAttribute* xmlattr)\n{\n\tconst SXML_CHAR *p;\n\tint i, n0, n1, remQ = 0;\n\tint ret = 1;\n\tSXML_CHAR quote = '\\0';\n\n\tif (str == NULL || xmlattr == NULL)\n\t\treturn 0;\n\n\tif (to < 0)\n\t\tto = sx_strlen(str) - 1;\n\n\t/* Search for the '=' */\n\t/* 'n0' is where the attribute name stops, 'n1' is where the attribute value starts */\n\tfor (n0 = 0; n0 != to && str[n0] != C2SX('=') && !sx_isspace(str[n0]); n0++) ; /* Search for '=' or a space */\n\tfor (n1 = n0; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */\n\tif (str[n1] != C2SX('='))\n\t\treturn 0; /* '=' not found: malformed string */\n\tfor (n1++; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */\n\tif (isquote(str[n1])) { /* Remove quotes */\n\t\tquote = str[n1];\n\t\tremQ = 1;\n\t}\n\n\txmlattr->name = (SXML_CHAR*)__malloc((n0+1)*sizeof(SXML_CHAR));\n\txmlattr->value = (SXML_CHAR*)__malloc((to+1 - n1 - remQ + 1) * sizeof(SXML_CHAR));\n\txmlattr->active = true;\n\tif (xmlattr->name != NULL && xmlattr->value != NULL) {\n\t\t/* Copy name */\n\t\tsx_strncpy(xmlattr->name, str, n0);\n\t\txmlattr->name[n0] = NULC;\n\t\t/* (void)str_unescape(xmlattr->name); do not unescape the name */\n\t\t/* Copy value (p starts after the quote (if any) and stops at the end of 'str'\n\t\t  (skipping the quote if any, hence the '*(p+remQ)') */\n\t\tfor (i = 0, p = str + n1 + remQ; i + n1 + remQ < to && *(p+remQ) != NULC; i++, p++)\n\t\t\txmlattr->value[i] = *p;\n\t\txmlattr->value[i] = NULC;\n\t\t(void)html2str(xmlattr->value, NULL); /* Convert HTML escape sequences, do not str_unescape(xmlattr->value) */\n\t\tif (remQ && *p != quote)\n\t\t\tret = 2; /* Quote at the beginning but not at the end: probable presence of '>' inside attribute value, so we need to read more data! */\n\t} else\n\t\tret = 0;\n\n\tif (ret == 0) {\n\t\tif (xmlattr->name != NULL) {\n\t\t\t__free(xmlattr->name);\n\t\t\txmlattr->name = NULL;\n\t\t}\n\t\tif (xmlattr->value != NULL) {\n\t\t\t__free(xmlattr->value);\n\t\t\txmlattr->value = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic TagType _parse_special_tag(const SXML_CHAR* str, int len, _TAG* tag, XMLNode* node)\n{\n\tif (sx_strncmp(str, tag->start, tag->len_start))\n\t\treturn TAG_NONE;\n\n\tif (sx_strncmp(str + len - tag->len_end, tag->end, tag->len_end)) /* There probably is a '>' inside the tag */\n\t\treturn TAG_PARTIAL;\n\n\tnode->tag = (SXML_CHAR*)__malloc((len - tag->len_start - tag->len_end + 1)*sizeof(SXML_CHAR));\n\tif (node->tag == NULL)\n\t\treturn TAG_NONE;\n\tsx_strncpy(node->tag, str + tag->len_start, len - tag->len_start - tag->len_end);\n\tnode->tag[len - tag->len_start - tag->len_end] = NULC;\n\tnode->tag_type = tag->tag_type;\n\n\treturn node->tag_type;\n}\n\n/*\n Reads a string that is supposed to be an xml tag like '<tag (attribName=\"attribValue\")* [/]>' or '</tag>'.\n Fills the 'xmlnode' structure with the tag name and its attributes.\n Returns 'TAG_ERROR' if an error occurred (malformed 'str' or memory). 'TAG_*' when string is recognized.\n */\nTagType XML_parse_1string(const SXML_CHAR* str, XMLNode* xmlnode)\n{\n\tSXML_CHAR *p;\n\tXMLAttribute* pt;\n\tint n, nn, len, rc, tag_end = 0;\n\n\tif (str == NULL || xmlnode == NULL)\n\t\treturn TAG_ERROR;\n\tlen = sx_strlen(str);\n\n\t/* Check for malformed string */\n\tif (str[0] != C2SX('<') || str[len-1] != C2SX('>'))\n\t\treturn TAG_ERROR;\n\n\tfor (nn = 0; nn < NB_SPECIAL_TAGS; nn++) {\n\t\tn = (int)_parse_special_tag(str, len, &_spec[nn], xmlnode);\n\t\tswitch (n) {\n\t\t\tcase TAG_NONE:\tbreak;\t\t\t\t/* Nothing found => do nothing */\n\t\t\tdefault:\t\treturn (TagType)n;\t/* Tag found => return it */\n\t\t}\n\t}\n\n\t/* \"<!DOCTYPE\" requires a special handling because it can end with \"]>\" instead of \">\" if a '[' is found inside */\n\tif (str[1] == C2SX('!')) {\n\t\t/* DOCTYPE */\n\t\tif (!sx_strncmp(str, C2SX(\"<!DOCTYPE\"), 9)) { /* 9 = sizeof(\"<!DOCTYPE\") */\n\t\t\tfor (n = 9; str[n] && str[n] != C2SX('['); n++) ; /* Look for a '[' inside the DOCTYPE, which would mean that we should be looking for a \"]>\" tag end */\n\t\t\tnn = 0;\n\t\t\tif (str[n]) { /* '[' was found */\n\t\t\t\tif (sx_strncmp(str+len-2, C2SX(\"]>\"), 2)) /* There probably is a '>' inside the DOCTYPE */\n\t\t\t\t\treturn TAG_PARTIAL;\n\t\t\t\tnn = 1;\n\t\t\t}\n\t\t\txmlnode->tag = (SXML_CHAR*)__malloc((len - 9 - nn)*sizeof(SXML_CHAR)); /* 'len' - \"<!DOCTYPE\" and \">\" + '\\0' */\n\t\t\tif (xmlnode->tag == NULL)\n\t\t\t\treturn TAG_ERROR;\n\t\t\tsx_strncpy(xmlnode->tag, &str[9], len - 10 - nn);\n\t\t\txmlnode->tag[len - 10 - nn] = NULC;\n\t\t\txmlnode->tag_type = TAG_DOCTYPE;\n\n\t\t\treturn TAG_DOCTYPE;\n\t\t}\n\t}\n\n\t/* Test user tags */\n\tfor (nn = 0; nn < _user_tags.n_tags; nn++) {\n\t\tn = _parse_special_tag(str, len, &_user_tags.tags[nn], xmlnode);\n\t\tswitch (n) {\n\t\t\tcase TAG_ERROR:\treturn TAG_NONE;\t/* Error => exit */\n\t\t\tcase TAG_NONE:\tbreak;\t\t\t\t/* Nothing found => do nothing */\n\t\t\tdefault:\t\treturn (TagType)n;\t/* Tag found => return it */\n\t\t}\n\t}\n\n\tif (str[1] == C2SX('/'))\n\t\ttag_end = 1;\n\n\t/* tag starts at index 1 (or 2 if tag end) and ends at the first space or '/>' */\n\tfor (n = 1 + tag_end; str[n] != NULC && str[n] != C2SX('>') && str[n] != C2SX('/') && !sx_isspace(str[n]); n++) ;\n\txmlnode->tag = (SXML_CHAR*)__malloc((n - tag_end)*sizeof(SXML_CHAR));\n\tif (xmlnode->tag == NULL)\n\t\treturn TAG_ERROR;\n\tsx_strncpy(xmlnode->tag, &str[1 + tag_end], n - 1 - tag_end);\n\txmlnode->tag[n - 1 - tag_end] = NULC;\n\tif (tag_end) {\n\t\txmlnode->tag_type = TAG_END;\n\t\treturn TAG_END;\n\t}\n\n\t/* Here, 'n' is the position of the first space after tag name */\n\twhile (n < len) {\n\t\t/* Skips spaces */\n\t\twhile (sx_isspace(str[n])) n++;\n\n\t\t/* Check for XML end ('>' or '/>') */\n\t\tif (str[n] == C2SX('>')) { /* Tag with children */\n\t\t\tint type = (str[n-1] == '/' ? TAG_SELF : TAG_FATHER); // TODO: Find something better to cope with <tag attr=v/>\n\t\t\txmlnode->tag_type = type;\n\t\t\treturn type;\n\t\t}\n\t\tif (!sx_strcmp(str+n, C2SX(\"/>\"))) { /* Tag without children */\n\t\t\txmlnode->tag_type = TAG_SELF;\n\t\t\treturn TAG_SELF;\n\t\t}\n\n\t\t/* New attribute found */\n\t\tp = sx_strchr(str+n, C2SX('='));\n\t\tif (p == NULL) goto parse_err;\n\t\tpt = (XMLAttribute*)__realloc(xmlnode->attributes, (xmlnode->n_attributes + 1) * sizeof(XMLAttribute));\n\t\tif (pt == NULL) goto parse_err;\n\n\t\tpt[xmlnode->n_attributes].name = NULL;\n\t\tpt[xmlnode->n_attributes].value = NULL;\n\t\tpt[xmlnode->n_attributes].active = false;\n\t\txmlnode->n_attributes++;\n\t\txmlnode->attributes = pt;\n\t\twhile (*p != NULC && sx_isspace(*++p)) ; /* Skip spaces */\n\t\tif (isquote(*p)) { /* Attribute value starts with a quote, look for next one, ignoring protected ones with '\\' */\n\t\t\tfor (nn = p-str+1; str[nn] && str[nn] != *p; nn++) { // CHECK UNICODE \"nn = p-str+1\"\n\t\t\t\t/* if (str[nn] == C2SX('\\\\')) nn++; [bugs:#7]: '\\' is valid in values */\n\t\t\t}\n\t\t} else { /* Attribute value stops at first space or end of XML string */\n\t\t\tfor (nn = p-str+1; str[nn] != NULC && !sx_isspace(str[nn]) && str[nn] != C2SX('/') && str[nn] != C2SX('>'); nn++) ; /* Go to the end of the attribute value */ // CHECK UNICODE\n\t\t}\n\n\t\t/* Here 'str[nn]' is the character after value */\n\t\t/* the attribute definition ('attrName=\"attrVal\"') is between 'str[n]' and 'str[nn]' */\n\t\trc = XML_parse_attribute_to(&str[n], nn - n, &xmlnode->attributes[xmlnode->n_attributes - 1]);\n\t\tif (!rc) goto parse_err;\n\t\tif (rc == 2) { /* Probable presence of '>' inside attribute value, which is legal XML. Remove attribute to re-parse it later */\n\t\t\tXMLNode_remove_attribute(xmlnode, xmlnode->n_attributes - 1);\n\t\t\treturn TAG_PARTIAL;\n\t\t}\n\n\t\tn = nn + 1;\n\t}\n\n\tsx_fprintf(stderr, C2SX(\"\\nWE SHOULD NOT BE HERE!\\n[%s]\\n\\n\"), str);\n\nparse_err:\n\t(void)XMLNode_free(xmlnode);\n\n\treturn TAG_ERROR;\n}\n\nstatic int _parse_data_SAX(void* in, const DataSourceType in_type, const SAX_Callbacks* sax, SAX_Data* sd)\n{\n\tSXML_CHAR *line = NULL, *txt_end, *p;\n\tXMLNode node;\n\tint ret, exit, sz, n0, ncr;\n\tTagType tag_type;\n\tint (*meos)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_beob : (int(*)(void*))sx_feof);\n\n\tif (sax->start_doc != NULL && !sax->start_doc(sd))\n\t\treturn true;\n\tif (sax->all_event != NULL && !sax->all_event(XML_EVENT_START_DOC, NULL, (SXML_CHAR*)sd->name, 0, sd))\n\t\treturn true;\n\n\tret = true;\n\texit = false;\n\tsd->line_num = 1; /* Line counter, starts at 1 */\n\tsz = 0; /* 'line' buffer size */\n\tnode.init_value = 0;\n\t(void)XMLNode_init(&node);\n\twhile ((n0 = read_line_alloc(in, in_type, &line, &sz, 0, NULC, C2SX('>'), true, C2SX('\\n'), &ncr)) != 0) {\n\t\t(void)XMLNode_free(&node);\n\t\tfor (p = line; *p != NULC && sx_isspace(*p); p++) ; /* Checks if text is only spaces */\n\t\tif (*p == NULC)\n\t\t\tbreak;\n\t\tsd->line_num += ncr;\n\n\t\t/* Get text for 'father' (i.e. what is before '<') */\n\t\twhile ((txt_end = sx_strchr(line, C2SX('<'))) == NULL) { /* '<' was not found, indicating a probable '>' inside text (should have been escaped with '&gt;' but we'll handle that ;) */\n\t\t\tint n1 = read_line_alloc(in, in_type, &line, &sz, n0, 0, C2SX('>'), true, C2SX('\\n'), &ncr); /* Go on reading the file from current position until next '>' */\n\t\t\tsd->line_num += ncr;\n\t\t\tif (n1 <= n0) {\n\t\t\t\tret = false;\n\t\t\t\tif (sax->on_error == NULL && sax->all_event == NULL)\n\t\t\t\t\tsx_fprintf(stderr, C2SX(\"%s:%d: MEMORY ERROR.\\n\"), sd->name, sd->line_num);\n\t\t\t\telse {\n\t\t\t\t\tif (sax->on_error != NULL && !sax->on_error(PARSE_ERR_MEMORY, sd->line_num, sd))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PARSE_ERR_MEMORY, sd))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak; /* 'txt_end' is still NULL here so we'll display the syntax error below */\n\t\t\t}\n\t\t\tn0 = n1;\n\t\t}\n\t\tif (txt_end == NULL) { /* Missing tag start */\n\t\t\tret = false;\n\t\t\tif (sax->on_error == NULL && sax->all_event == NULL)\n\t\t\t\tsx_fprintf(stderr, C2SX(\"%s:%d: ERROR: Unexpected end character '>', without matching '<'!\\n\"), sd->name, sd->line_num);\n\t\t\telse {\n\t\t\t\tif (sax->on_error != NULL && !sax->on_error(PARSE_ERR_UNEXPECTED_TAG_END, sd->line_num, sd))\n\t\t\t\t\tbreak;\n\t\t\t\tif (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PARSE_ERR_UNEXPECTED_TAG_END, sd))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/* First part of 'line' (before '<') is to be added to 'father->text' */\n\t\t*txt_end = NULC; /* Have 'line' be the text for 'father' */\n\t\tif (*line != NULC && (sax->new_text != NULL || sax->all_event != NULL)) {\n\t\t\tif (sax->new_text != NULL && (exit = !sax->new_text(line, sd))) /* no str_unescape(line) */\n\t\t\t\tbreak;\n\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_TEXT, NULL, line, sd->line_num, sd)))\n\t\t\t\tbreak;\n\t\t}\n\t\t*txt_end = '<'; /* Restores tag start */\n\n\t\tswitch (tag_type = XML_parse_1string(txt_end, &node)) {\n\t\t\tcase TAG_ERROR: /* Memory error */\n\t\t\t\tret = false;\n\t\t\t\tif (sax->on_error == NULL && sax->all_event == NULL)\n\t\t\t\t\tsx_fprintf(stderr, C2SX(\"%s:%d: MEMORY ERROR.\\n\"), sd->name, sd->line_num);\n\t\t\t\telse {\n\t\t\t\t\tif (sax->on_error != NULL && (exit = !sax->on_error(PARSE_ERR_MEMORY, sd->line_num, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PARSE_ERR_MEMORY, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_NONE: /* Syntax error */\n\t\t\t\tret = false;\n\t\t\t\tp = sx_strchr(txt_end, C2SX('\\n'));\n\t\t\t\tif (p != NULL)\n\t\t\t\t\t*p = NULC;\n\t\t\t\tif (sax->on_error == NULL && sax->all_event == NULL) {\n\t\t\t\t\tsx_fprintf(stderr, C2SX(\"%s:%d: SYNTAX ERROR (%s%s).\\n\"), sd->name, sd->line_num, txt_end, p == NULL ? C2SX(\"\") : C2SX(\"...\"));\n\t\t\t\t\tif (p != NULL)\n\t\t\t\t\t\t*p = C2SX('\\n');\n\t\t\t\t} else {\n\t\t\t\t\tif (sax->on_error != NULL && (exit = !sax->on_error(PARSE_ERR_SYNTAX, sd->line_num, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PARSE_ERR_SYNTAX, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_END:\n\t\t\t\tif (sax->end_node != NULL || sax->all_event != NULL) {\n\t\t\t\t\tif (sax->end_node != NULL && (exit = !sax->end_node(&node, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_END_NODE, &node, NULL, sd->line_num, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Add 'node' to 'father' children */\n\t\t\t\t/* If the line looks like a comment (or CDATA) but is not properly finished, loop until we find the end. */\n\t\t\t\twhile (tag_type == TAG_PARTIAL) {\n\t\t\t\t\tint n1 = read_line_alloc(in, in_type, &line, &sz, n0, NULC, C2SX('>'), true, C2SX('\\n'), &ncr); /* Go on reading the file from current position until next '>' */\n\t\t\t\t\tsd->line_num += ncr;\n\t\t\t\t\tif (n1 <= n0) {\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t\tif (sax->on_error == NULL && sax->all_event == NULL)\n\t\t\t\t\t\t\tsx_fprintf(stderr, C2SX(\"%s:%d: SYNTAX ERROR.\\n\"), sd->name, sd->line_num);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (sax->on_error != NULL && (exit = !sax->on_error(meos(in) ? PARSE_ERR_EOF : PARSE_ERR_MEMORY, sd->line_num, sd)))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, meos(in) ? PARSE_ERR_EOF : PARSE_ERR_MEMORY, sd)))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tn0 = n1;\n\t\t\t\t\ttxt_end = sx_strchr(line, C2SX('<')); /* In case 'line' has been moved by the '__realloc' in 'read_line_alloc' */\n\t\t\t\t\ttag_type = XML_parse_1string(txt_end, &node);\n\t\t\t\t\tif (tag_type == TAG_ERROR) {\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t\tif (sax->on_error == NULL && sax->all_event == NULL)\n\t\t\t\t\t\t\tsx_fprintf(stderr, C2SX(\"%s:%d: PARSE ERROR.\\n\"), sd->name, sd->line_num);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (sax->on_error != NULL && (exit = !sax->on_error(meos(in) ? PARSE_ERR_EOF : PARSE_ERR_SYNTAX, sd->line_num, sd)))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, meos(in) ? PARSE_ERR_EOF : PARSE_ERR_SYNTAX, sd)))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ret == false)\n\t\t\t\t\tbreak;\n\t\t\t\tif (sax->start_node != NULL && (exit = !sax->start_node(&node, sd)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_START_NODE, &node, NULL, sd->line_num, sd)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (node.tag_type != TAG_FATHER && (sax->end_node != NULL || sax->all_event != NULL)) {\n\t\t\t\t\tif (sax->end_node != NULL && (exit = !sax->end_node(&node, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_END_NODE, &node, NULL, sd->line_num, sd)))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (exit == true || ret == false || meos(in))\n\t\t\tbreak;\n\t}\n\t__free(line);\n\t(void)XMLNode_free(&node);\n\n\tif (sax->end_doc != NULL && !sax->end_doc(sd))\n\t\treturn ret;\n\tif (sax->all_event != NULL)\n\t\t(void)sax->all_event(XML_EVENT_END_DOC, NULL, (SXML_CHAR*)sd->name, sd->line_num, sd);\n\n\treturn ret;\n}\n\nint SAX_Callbacks_init(SAX_Callbacks* sax)\n{\n\tif (sax == NULL)\n\t\treturn false;\n\n\tsax->start_doc = NULL;\n\tsax->start_node = NULL;\n\tsax->end_node = NULL;\n\tsax->new_text = NULL;\n\tsax->on_error = NULL;\n\tsax->end_doc = NULL;\n\tsax->all_event = NULL;\n\n\treturn true;\n}\n\nint DOMXMLDoc_doc_start(SAX_Data* sd)\n{\n\tDOM_through_SAX* dom = (DOM_through_SAX*)sd->user;\n\n\tdom->current = NULL;\n\tdom->error = PARSE_ERR_NONE;\n\tdom->line_error = 0;\n\n\treturn true;\n}\n\nint DOMXMLDoc_node_start(const XMLNode* node, SAX_Data* sd)\n{\n\tDOM_through_SAX* dom = (DOM_through_SAX*)sd->user;\n\tXMLNode* new_node;\n\tint i;\n\n\tif ((new_node = XMLNode_dup(node, true)) == NULL) goto node_start_err; /* No real need to put 'true' for 'XMLNode_dup', but cleaner */\n\n\tif (dom->current == NULL) {\n\t\tif ((i = _add_node(&dom->doc->nodes, &dom->doc->n_nodes, new_node)) < 0) goto node_start_err;\n\n\t\tif (dom->doc->i_root < 0 && (node->tag_type == TAG_FATHER || node->tag_type == TAG_SELF))\n\t\t\tdom->doc->i_root = i;\n\t} else {\n\t\tif (_add_node(&dom->current->children, &dom->current->n_children, new_node) < 0) goto node_start_err;\n\t}\n\n\tnew_node->father = dom->current;\n\tdom->current = new_node;\n\n\treturn true;\n\nnode_start_err:\n\tdom->error = PARSE_ERR_MEMORY;\n\tdom->line_error = sd->line_num;\n\t(void)XMLNode_free(new_node);\n\t__free(new_node);\n\n\treturn false;\n}\n\nint DOMXMLDoc_node_end(const XMLNode* node, SAX_Data* sd)\n{\n\tDOM_through_SAX* dom = (DOM_through_SAX*)sd->user;\n\n\tif (dom->current == NULL || sx_strcmp(dom->current->tag, node->tag)) {\n\t\tsx_fprintf(stderr, C2SX(\"%s:%d: ERROR - End tag </%s> was unexpected\"), sd->name, sd->line_num, node->tag);\n\t\tif (dom->current != NULL)\n\t\t\tsx_fprintf(stderr, C2SX(\" (</%s> was expected)\\n\"), dom->current->tag);\n\t\telse\n\t\t\tsx_fprintf(stderr, C2SX(\" (no node to end)\\n\"));\n\n\t\tdom->error = PARSE_ERR_UNEXPECTED_NODE_END;\n\t\tdom->line_error = sd->line_num;\n\n\t\treturn false;\n\t}\n\n\tdom->current = dom->current->father;\n\n\treturn true;\n}\n\nint DOMXMLDoc_node_text(SXML_CHAR* text, SAX_Data* sd)\n{\n\tSXML_CHAR* p = text;\n\tDOM_through_SAX* dom = (DOM_through_SAX*)sd->user;\n\n\t/* Keep text, even if it is only spaces */\n#if 0\n\twhile(*p != NULC && sx_isspace(*p++)) ;\n\tif (*p == NULC) return true; /* Only spaces */\n#endif\n\n\t/* If there is no current node to add text to, raise an error, except if text is only spaces, in which case it is probably just formatting */\n\tif (dom->current == NULL) {\n\t\twhile(*p != NULC && sx_isspace(*p++)) ;\n\t\tif (*p == NULC) /* Only spaces => probably pretty-printing */\n\t\t\treturn true;\n\t\tdom->error = PARSE_ERR_TEXT_OUTSIDE_NODE;\n\t\tdom->line_error = sd->line_num;\n\t\treturn false; /* There is some \"real\" text => raise an error */\n\t}\n\n\tif (dom->text_as_nodes) {\n\t\tXMLNode* new_node = XMLNode_allocN(1);\n\t\tif (new_node == NULL || (new_node->text = sx_strdup(text)) == NULL\n\t\t\t|| _add_node(&dom->current->children, &dom->current->n_children, new_node) < 0) {\n\t\t\tdom->error = PARSE_ERR_MEMORY;\n\t\t\tdom->line_error = sd->line_num;\n\t\t\t(void)XMLNode_free(new_node);\n\t\t\t__free(new_node);\n\t\t\treturn false;\n\t\t}\n\t\tnew_node->tag_type = TAG_TEXT;\n\t\tnew_node->father = dom->current;\n\t\t//dom->current->tag_type = TAG_FATHER; // OS: should parent field be forced to be TAG_FATHER? now it has at least one TAG_TEXT child. I decided not to enforce this to enforce backward-compatibility related to tag_types\n\t\treturn true;\n\t} else { /* Old behaviour: concatenate text to the previous one */\n\t\t/* 'p' will point at the new text */\n\t\tif (dom->current->text == NULL) {\n\t\t\tp = sx_strdup(text);\n\t\t} else {\n\t\t\tp = (SXML_CHAR*)__realloc(dom->current->text, (sx_strlen(dom->current->text) + sx_strlen(text) + 1)*sizeof(SXML_CHAR));\n\t\t\tif (p != NULL)\n\t\t\t\tsx_strcat(p, text);\n\t\t}\n\t\tif (p == NULL) {\n\t\t\tdom->error = PARSE_ERR_MEMORY;\n\t\t\tdom->line_error = sd->line_num;\n\t\t\treturn false;\n\t\t}\n\n\t\tdom->current->text = p;\n\t}\n\n\treturn true;\n}\n\nint DOMXMLDoc_parse_error(ParseError error_num, int line_number, SAX_Data* sd)\n{\n\tDOM_through_SAX* dom = (DOM_through_SAX*)sd->user;\n\n\tdom->error = error_num;\n\tdom->line_error = line_number;\n\n\t/* Complete error message will be displayed in 'DOMXMLDoc_doc_end' callback */\n\n\treturn false; /* Stop on error */\n}\n\nint DOMXMLDoc_doc_end(SAX_Data* sd)\n{\n\tDOM_through_SAX* dom = (DOM_through_SAX*)sd->user;\n\n\tif (dom->error != PARSE_ERR_NONE) {\n\t\tSXML_CHAR* msg;\n\n\t\tswitch (dom->error) {\n\t\t\tcase PARSE_ERR_MEMORY:\t\t\t\tmsg = C2SX(\"MEMORY\"); break;\n\t\t\tcase PARSE_ERR_UNEXPECTED_TAG_END:\tmsg = C2SX(\"UNEXPECTED_TAG_END\"); break;\n\t\t\tcase PARSE_ERR_SYNTAX:\t\t\t\tmsg = C2SX(\"SYNTAX\"); break;\n\t\t\tcase PARSE_ERR_EOF:\t\t\t\t\tmsg = C2SX(\"UNEXPECTED_END_OF_FILE\"); break;\n\t\t\tcase PARSE_ERR_TEXT_OUTSIDE_NODE:\tmsg = C2SX(\"TEXT_OUTSIDE_NODE\"); break;\n\t\t\tcase PARSE_ERR_UNEXPECTED_NODE_END:\tmsg = C2SX(\"UNEXPECTED_NODE_END\"); break;\n\t\t\tdefault:\t\t\t\t\t\t\tmsg = C2SX(\"UNKNOWN\"); break;\n\t\t}\n\t\tsx_fprintf(stderr, C2SX(\"%s:%d: An error was found (%s), loading aborted...\\n\"), sd->name, dom->line_error, msg);\n\t\tdom->current = NULL;\n\t\t(void)XMLDoc_free(dom->doc);\n\t\tdom->doc = NULL;\n\t}\n\n\treturn true;\n}\n\nint SAX_Callbacks_init_DOM(SAX_Callbacks* sax)\n{\n\tif (sax == NULL)\n\t\treturn false;\n\n\tsax->start_doc = DOMXMLDoc_doc_start;\n\tsax->start_node = DOMXMLDoc_node_start;\n\tsax->end_node = DOMXMLDoc_node_end;\n\tsax->new_text = DOMXMLDoc_node_text;\n\tsax->on_error = DOMXMLDoc_parse_error;\n\tsax->end_doc = DOMXMLDoc_doc_end;\n\tsax->all_event = NULL;\n\n\treturn true;\n}\n\nint XMLDoc_parse_file_SAX(const SXML_CHAR* filename, const SAX_Callbacks* sax, void* user)\n{\n\tFILE* f;\n\tint ret;\n\tSAX_Data sd;\n\tSXML_CHAR* fmode =\n#ifndef SXMLC_UNICODE\n\tC2SX(\"rt\");\n#else\n\tC2SX(\"rb\"); /* In Unicode, open the file as binary so that further 'fgetwc' read all bytes */\n\tBOM_TYPE bom;\n#endif\n\n\n\tif (sax == NULL || filename == NULL || filename[0] == NULC)\n\t\treturn false;\n\n\tf = sx_fopen(filename, fmode);\n\tif (f == NULL)\n\t\treturn false;\n\t/* Microsoft' 'ftell' returns invalid position for Unicode text files\n\t   (see http://connect.microsoft.com/VisualStudio/feedback/details/369265/ftell-ftell-nolock-incorrectly-handling-unicode-text-translation)\n\t   However, we're opening the file as binary in Unicode so we don't fall into that case...\n\t*/\n\t#if defined(SXMLC_UNICODE) && (defined(WIN32) || defined(WIN64))\n\t//setvbuf(f, NULL, _IONBF, 0);\n\t#endif\n\n\tsd.name = (SXML_CHAR*)filename;\n\tsd.user = user;\n\tsd.file = f;\n#ifdef SXMLC_UNICODE\n\tbom = freadBOM(f, NULL, NULL); /* Skip BOM, if any */\n\t/* In Unicode, re-open the file in text-mode if there is no BOM (or UTF-8) as we assume that\n\t   the file is \"plain\" text (i.e. 1 byte = 1 character). If opened in binary mode, 'fgetwc'\n\t   would read 2 bytes for 1 character, which would not work on \"plain\" files. */\n\tif (bom == BOM_NONE || bom == BOM_UTF_8) {\n\t\tsx_fclose(f);\n\t\tf = sx_fopen(filename, C2SX(\"rt\"));\n\t\tif (f == NULL)\n\t\t\treturn false;\n\t\tif (bom == BOM_UTF_8)\n\t\t\tfreadBOM(f, NULL, NULL); /* Skip the UTF-8 BOM that was found */\n\t}\n#endif\n\tret = _parse_data_SAX((void*)f, DATA_SOURCE_FILE, sax, &sd);\n\t(void)sx_fclose(f);\n\n\treturn ret;\n}\n\nint XMLDoc_parse_buffer_SAX(const SXML_CHAR* buffer, const SXML_CHAR* name, const SAX_Callbacks* sax, void* user)\n{\n\tDataSourceBuffer dsb = { buffer, 0 };\n\tSAX_Data sd;\n\n\tif (sax == NULL || buffer == NULL)\n\t\treturn false;\n\n\tsd.name = name;\n\tsd.user = user;\n\treturn _parse_data_SAX((void*)&dsb, DATA_SOURCE_BUFFER, sax, &sd);\n}\n\nint XMLDoc_parse_file_DOM_text_as_nodes(const SXML_CHAR* filename, XMLDoc* doc, int text_as_nodes)\n{\n\tDOM_through_SAX dom;\n\tSAX_Callbacks sax;\n\n\tif (doc == NULL || filename == NULL || filename[0] == NULC || doc->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tsx_strncpy(doc->filename, filename, SXMLC_MAX_PATH - 1);\n\tdoc->filename[SXMLC_MAX_PATH - 1] = NULC;\n\n\t/* Read potential BOM on file, only when unicode is defined */\n#ifdef SXMLC_UNICODE\n\t{\n\t\t/* In Unicode, open the file as binary so that further 'fgetwc' read all bytes */\n\t\tFILE* f = sx_fopen(filename, C2SX(\"rb\"));\n\t\tif (f != NULL) {\n\t\t\t#if defined(SXMLC_UNICODE) && (defined(WIN32) || defined(WIN64))\n\t\t\t//setvbuf(f, NULL, _IONBF, 0);\n\t\t\t#endif\n\t\t\tdoc->bom_type = freadBOM(f, doc->bom, &doc->sz_bom);\n\t\t\tsx_fclose(f);\n\t\t}\n\t}\n#endif\n\n\tdom.doc = doc;\n\tdom.current = NULL;\n\tdom.text_as_nodes = text_as_nodes;\n\tSAX_Callbacks_init_DOM(&sax);\n\n\tif (!XMLDoc_parse_file_SAX(filename, &sax, &dom)) {\n\t\t(void)XMLDoc_free(doc);\n\t\tdom.doc = NULL;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint XMLDoc_parse_buffer_DOM_text_as_nodes(const SXML_CHAR* buffer, const SXML_CHAR* name, XMLDoc* doc, int text_as_nodes)\n{\n\tDOM_through_SAX dom;\n\tSAX_Callbacks sax;\n\n\tif (doc == NULL || buffer == NULL || doc->init_value != XML_INIT_DONE)\n\t\treturn false;\n\n\tdom.doc = doc;\n\tdom.current = NULL;\n\tdom.text_as_nodes = text_as_nodes;\n\tSAX_Callbacks_init_DOM(&sax);\n\n\treturn XMLDoc_parse_buffer_SAX(buffer, name, &sax, &dom) ? true : XMLDoc_free(doc);\n}\n\n\n\n/* --- Utility functions (ex sxmlutils.c) --- */\n\n#ifdef DBG_MEM\nstatic int nb_alloc = 0, nb_free = 0;\n\nvoid* __malloc(size_t sz)\n{\n\tvoid* p = malloc(sz);\n\tif (p != NULL)\n\t\tnb_alloc++;\n\tprintf(\"0x%x: MALLOC (%d) - NA %d - NF %d = %d\\n\", p, sz, nb_alloc, nb_free, nb_alloc - nb_free);\n\treturn p;\n}\n\nvoid* __calloc(size_t count, size_t sz)\n{\n\tvoid* p = calloc(count, sz);\n\tif (p != NULL)\n\t\tnb_alloc++;\n\tprintf(\"0x%x: CALLOC (%d, %d) - NA %d - NF %d = %d\\n\", p, count, sz, nb_alloc, nb_free, nb_alloc - nb_free);\n\treturn p;\n}\n\nvoid* __realloc(void* mem, size_t sz)\n{\n\tvoid* p = realloc(mem, sz);\n\tif (mem == NULL && p != NULL)\n\t\tnb_alloc++;\n\telse if (mem != NULL && sz == 0)\n\t\tnb_free++;\n\tprintf(\"0x%x: REALLOC 0x%x (%d)\", p, mem, sz);\n\tif (mem == NULL)\n\t\tprintf(\" - NA %d - NF %d = %d\", nb_alloc, nb_free, nb_alloc - nb_free);\n\tprintf(\"\\n\");\n\treturn p;\n}\n\nvoid __free(void* mem)\n{\n\tnb_free++;\n\tprintf(\"0x%x: FREE - NA %d - NF %d = %d\\n\", mem, nb_alloc, nb_free, nb_alloc - nb_free);\n\tfree(mem);\n}\n\nchar* __sx_strdup(const char* s)\n{\n/* Mimic the behavior of sx_strdup(), as we can't use it directly here: DBG_MEM is defined\n   and sx_strdup is this function! (bug #5) */\n#ifdef SXMLC_UNICODE\n\tchar* p = wcsdup(s);\n#else\n\tchar* p = strdup(s);\n#endif\n\tif (p != NULL)\n\t\tnb_alloc++;\n\tprintf(\"0x%x: STRDUP (%d) - NA %d - NF %d = %d\\n\", p, sx_strlen(s), nb_alloc, nb_free, nb_alloc - nb_free);\n\treturn p;\n}\n#endif\n\n/* Dictionary of special characters and their HTML equivalent */\nstatic struct _html_special_dict {\n\tSXML_CHAR chr;\t\t/* Original character */\n\tSXML_CHAR* html;\t/* Equivalent HTML string */\n\tint html_len;\t/* 'sx_strlen(html)' */\n} HTML_SPECIAL_DICT[] = {\n\t{ C2SX('<'), C2SX(\"&lt;\"), 4 },\n\t{ C2SX('>'), C2SX(\"&gt;\"), 4 },\n\t{ C2SX('\"'), C2SX(\"&quot;\"), 6 },\n\t{ C2SX('\\''), C2SX(\"&apos;\"), 6 },\n\t{ C2SX('&'), C2SX(\"&amp;\"), 5 },\n\t{ NULC, NULL, 0 }, /* Terminator */\n};\n\nint _bgetc(DataSourceBuffer* ds)\n{\n\tif (ds == NULL || ds->buf[ds->cur_pos] == NULC)\n\t\treturn EOF;\n\n\treturn (int)(ds->buf[ds->cur_pos++]);\n}\n\nint _beob(DataSourceBuffer* ds)\n{\n\n\tif (ds == NULL || ds->buf[ds->cur_pos] == NULC)\n\t\treturn true;\n\n\treturn false;\n}\n\nint read_line_alloc(void* in, DataSourceType in_type, SXML_CHAR** line, int* sz_line, int i0, SXML_CHAR from, SXML_CHAR to, int keep_fromto, SXML_CHAR interest, int* interest_count)\n{\n\tint init_sz = 0;\n\tSXML_CHAR ch, *pt;\n\tint c;\n\tint n, ret;\n\tint (*mgetc)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_bgetc : (int(*)(void*))sx_fgetc);\n\tint (*meos)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_beob : (int(*)(void*))sx_feof);\n\n\tif (in == NULL || line == NULL)\n\t\treturn 0;\n\n\tif (to == NULC)\n\t\tto = C2SX('\\n');\n\t/* Search for character 'from' */\n\tif (interest_count != NULL)\n\t\t*interest_count = 0;\n\twhile (true) {\n\t\t/* Reaching EOF before 'to' char is not an error but should trigger 'line' alloc and init to '' */\n\t\tc = mgetc(in);\n\t\tch = (SXML_CHAR)c;\n\t\tif (c == EOF)\n\t\t\tbreak;\n\t\tif (interest_count != NULL && ch == interest)\n\t\t\t(*interest_count)++;\n\t\t/* If 'from' is '\\0', we stop here */\n\t\tif (ch == from || from == NULC)\n\t\t\tbreak;\n\t}\n\n\tif (sz_line == NULL)\n\t\tsz_line = &init_sz;\n\n\tif (*line == NULL || *sz_line == 0) {\n\t\tif (*sz_line == 0) *sz_line = MEM_INCR_RLA;\n\t\t*line = (SXML_CHAR*)__malloc(*sz_line*sizeof(SXML_CHAR));\n\t\tif (*line == NULL)\n\t\t\treturn 0;\n\t}\n\tif (i0 < 0)\n\t\ti0 = 0;\n\tif (i0 > *sz_line)\n\t\treturn 0;\n\n\tn = i0;\n\tif (c == CSXEOF) { /* EOF reached before 'to' char => return the empty string */\n\t\t(*line)[n] = NULC;\n\t\treturn meos(in) ? n : 0; /* Error if not EOF */\n\t}\n\tif (ch != from || keep_fromto)\n\t\t(*line)[n++] = ch;\n\t(*line)[n] = NULC;\n\tret = 0;\n\twhile (true) {\n\t\tif ((c = mgetc(in)) == CSXEOF) { /* EOF or error */\n\t\t\t(*line)[n] = NULC;\n\t\t\tret = meos(in) ? n : 0;\n\t\t\tbreak;\n\t\t}\n\t\tch = (SXML_CHAR)c;\n\t\tif (interest_count != NULL && ch == interest)\n\t\t\t(*interest_count)++;\n\t\t(*line)[n] = ch;\n\t\tif (ch != to || (keep_fromto && to != NULC && ch == to)) /* If we reached the 'to' character and we keep it, we still need to add the extra '\\0' */\n\t\t\tn++;\n\t\tif (n >= *sz_line) { /* Too many characters for our line => realloc some more */\n\t\t\t*sz_line += MEM_INCR_RLA;\n\t\t\tpt = (SXML_CHAR*)__realloc(*line, *sz_line*sizeof(SXML_CHAR));\n\t\t\tif (pt == NULL) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\t*line = pt;\n\t\t}\n\t\t(*line)[n] = NULC; /* If we reached the 'to' character and we want to strip it, 'n' hasn't changed and 'line[n]' (which is 'to') will be replaced by '\\0' */\n\t\tif (ch == to) {\n\t\t\tret = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if 0 /* Automatic buffer resize is deactivated */\n\t/* Resize line to the exact size */\n\tpt = (SXML_CHAR*)__realloc(*line, (n+1)*sizeof(SXML_CHAR));\n\tif (pt != NULL)\n\t\t*line = pt;\n#endif\n\n\treturn ret;\n}\n\n/* --- */\n\nSXML_CHAR* strcat_alloc(SXML_CHAR** src1, const SXML_CHAR* src2)\n{\n\tSXML_CHAR* cat;\n\tint n;\n\n\t/* Do not concatenate '*src1' with itself */\n\tif (src1 == NULL || *src1 == src2)\n\t\treturn NULL;\n\n\t/* Concatenate a NULL or empty string */\n\tif (src2 == NULL || *src2 == NULC)\n\t\treturn *src1;\n\n\tn = (*src1 == NULL ? 0 : sx_strlen(*src1)) + sx_strlen(src2) + 1;\n\tcat = (SXML_CHAR*)__realloc(*src1, n*sizeof(SXML_CHAR));\n\tif (cat == NULL)\n\t\treturn NULL;\n\tif (*src1 == NULL)\n\t\t*cat = NULC;\n\t*src1 = cat;\n\tsx_strcat(*src1, src2);\n\n\treturn *src1;\n}\n\nSXML_CHAR* strip_spaces(SXML_CHAR* str, SXML_CHAR repl_sq)\n{\n\tSXML_CHAR* p;\n\tint i, len;\n\n\t/* 'p' to the first non-space */\n\tfor (p = str; *p != NULC && sx_isspace(*p); p++) ; /* No need to search for 'protect' as it is not a space */\n\tlen = sx_strlen(str);\n\tfor (i = len-1; sx_isspace(str[i]); i--) ;\n\tif (str[i] == C2SX('\\\\')) /* If last non-space is the protection, keep the last space */\n\t\ti++;\n\tstr[i+1] = NULC; /* New end of string to last non-space */\n\n\tif (repl_sq == NULC) {\n\t\tif (p == str && i == len)\n\t\t\treturn str; /* Nothing to do */\n\t\tfor (i = 0; (str[i] = *p) != NULC; i++, p++) ; /* Copy 'p' to 'str' */\n\t\treturn str;\n\t}\n\n\t/* Squeeze all spaces with 'repl_sq' */\n\ti = 0;\n\twhile (*p != NULC) {\n\t\tif (sx_isspace(*p)) {\n\t\t\tstr[i++] = repl_sq;\n\t\t\twhile (sx_isspace(*++p)) ; /* Skips all next spaces */\n\t\t} else {\n\t\t\tif (*p == C2SX('\\\\'))\n\t\t\t\tp++;\n\t\t\tstr[i++] = *p++;\n\t\t}\n\t}\n\tstr[i] = NULC;\n\n\treturn str;\n}\n\nSXML_CHAR* str_unescape(SXML_CHAR* str)\n{\n\tint i, j;\n\n\tif (str == NULL)\n\t\treturn NULL;\n\n\tfor (i = j = 0; str[j]; j++) {\n\t\tif (str[j] == C2SX('\\\\'))\n\t\t\tj++;\n\t\tstr[i++] = str[j];\n\t}\n\n\treturn str;\n}\n\nint split_left_right(SXML_CHAR* str, SXML_CHAR sep, int* l0, int* l1, int* i_sep, int* r0, int* r1, int ignore_spaces, int ignore_quotes)\n{\n\tint n0, n1, is;\n\tSXML_CHAR quote = '\\0';\n\n\tif (str == NULL)\n\t\treturn false;\n\n\tif (i_sep != NULL)\n\t\t*i_sep = -1;\n\n\tif (!ignore_spaces) /* No sense of ignore quotes if spaces are to be kept */\n\t\tignore_quotes = false;\n\n\t/* Parse left part */\n\n\tif (ignore_spaces) {\n\t\tfor (n0 = 0; str[n0] != NULC && sx_isspace(str[n0]); n0++) ; /* Skip head spaces, n0 points to first non-space */\n\t\tif (ignore_quotes && isquote(str[n0])) { /* If quote is found, look for next one */\n\t\t\tquote = str[n0++]; /* Quote can be '\\'' or '\"' */\n\t\t\tfor (n1 = n0; str[n1] != NULC && str[n1] != quote; n1++) {\n\t\t\t\tif (str[n1] == C2SX('\\\\') && str[++n1] == NULC)\n\t\t\t\t\tbreak; /* Escape character (can be the last) */\n\t\t\t}\n\t\t\tfor (is = n1 + 1; str[is] != NULC && sx_isspace(str[is]); is++) ; /* '--' not to take quote into account */\n\t\t} else {\n\t\t\tfor (n1 = n0; str[n1] != NULC && str[n1] != sep && !sx_isspace(str[n1]); n1++) ; /* Search for separator or a space */\n\t\t\tfor (is = n1; str[is] != NULC && sx_isspace(str[is]); is++) ;\n\t\t}\n\t} else {\n\t\tn0 = 0;\n\t\tfor (n1 = 0; str[n1] != NULC && str[n1] != sep; n1++) ; /* Search for separator only */\n\t\tif (str[n1] != sep) /* Separator not found: malformed string */\n\t\t\treturn false;\n\t\tis = n1;\n\t}\n\n\t/* Here 'n0' is the start of left member, 'n1' is the character after the end of left member */\n\n\tif (l0 != NULL)\n\t\t*l0 = n0;\n\tif (l1 != NULL)\n\t\t*l1 = n1 - 1;\n\tif (i_sep != NULL)\n\t\t*i_sep = is;\n\tif (str[is] == NULC || str[is+1] == NULC) { /* No separator => empty right member */\n\t\tif (r0 != NULL)\n\t\t\t*r0 = is;\n\t\tif (r1 != NULL)\n\t\t\t*r1 = is-1;\n\t\tif (i_sep != NULL)\n\t\t\t*i_sep = (str[is] == NULC ? -1 : is);\n\t\treturn true;\n\t}\n\n\t/* Parse right part */\n\n\tn0 = is + 1;\n\tif (ignore_spaces) {\n\t\tfor (; str[n0] != NULC && sx_isspace(str[n0]); n0++) ;\n\t\tif (ignore_quotes && isquote(str[n0]))\n\t\t\tquote = str[n0];\n\t}\n\n\tfor (n1 = ++n0; str[n1]; n1++) {\n\t\tif (ignore_quotes && str[n1] == quote) /* Quote was reached */\n\t\t\tbreak;\n\t\tif (str[n1] == C2SX('\\\\') && str[++n1] == NULC) /* Escape character (can be the last) */\n\t\t\tbreak;\n\t}\n\tif (ignore_quotes && str[n1--] != quote) /* Quote is not the same than earlier, '--' is not to take it into account */\n\t\treturn false;\n\tif (!ignore_spaces)\n\t\twhile (str[++n1]) ; /* Jump down the end of the string */\n\n\tif (r0 != NULL)\n\t\t*r0 = n0;\n\tif (r1 != NULL)\n\t\t*r1 = n1;\n\n\treturn true;\n}\n\nBOM_TYPE freadBOM(FILE* f, unsigned char* bom, int* sz_bom)\n{\n\tunsigned char c1, c2;\n\tlong pos;\n\n\tif (f == NULL)\n\t\treturn BOM_NONE;\n\n\t/* Save position and try to read and skip BOM if found. If not, go back to save position. */\n\tpos = ftell(f);\n\tif (pos < 0)\n\t\treturn BOM_NONE;\n\tif (fread(&c1, sizeof(char), 1, f) != 1 || fread(&c2, sizeof(char), 1, f) != 1) {\n\t\tfseek(f, pos, SEEK_SET);\n\t\treturn BOM_NONE;\n\t}\n\tif (bom != NULL) {\n\t\tbom[0] = c1;\n\t\tbom[1] = c2;\n\t\tbom[2] = '\\0';\n\t\tif (sz_bom != NULL)\n\t\t\t*sz_bom = 2;\n\t}\n\tswitch ((unsigned short)(c1 << 8) | c2) {\n\t\tcase (unsigned short)0xfeff:\n\t\t\treturn BOM_UTF_16BE;\n\n\t\tcase (unsigned short)0xfffe:\n\t\t\tpos = ftell(f); /* Save current position to get it back if BOM is not UTF-32LE */\n\t\t\tif (pos < 0)\n\t\t\t\treturn BOM_UTF_16LE;\n\t\t\tif (fread(&c1, sizeof(char), 1, f) != 1 || fread(&c2, sizeof(char), 1, f) != 1) {\n\t\t\t\tfseek(f, pos, SEEK_SET);\n\t\t\t\treturn BOM_UTF_16LE;\n\t\t\t}\n\t\t\tif (c1 == 0x00 && c2 == 0x00) {\n\t\t\t\tif (bom != NULL)\n\t\t\t\t\tbom[2] = bom[3] = bom[4] = '\\0';\n\t\t\t\tif (sz_bom != NULL)\n\t\t\t\t\t*sz_bom = 4;\n\t\t\t\treturn BOM_UTF_32LE;\n\t\t\t}\n\t\t\tfseek(f, pos, SEEK_SET); /* fseek(f, -2, SEEK_CUR) is not garanteed on Windows (and actually fail in Unicode...) */\n\t\t\treturn BOM_UTF_16LE;\n\n\t\tcase (unsigned short)0x0000:\n\t\t\tif (fread(&c1, sizeof(char), 1, f) == 1 && fread(&c2, sizeof(char), 1, f) == 1\n\t\t\t\t\t&& c1 == 0xfe && c2 == 0xff) {\n\t\t\t\tbom[2] = c1;\n\t\t\t\tbom[3] = c2;\n\t\t\t\tbom[4] = '\\0';\n\t\t\t\tif (sz_bom != NULL)\n\t\t\t\t\t*sz_bom = 4;\n\t\t\t\treturn BOM_UTF_32BE;\n\t\t\t}\n\t\t\tfseek(f, pos, SEEK_SET);\n\t\t\treturn BOM_NONE;\n\n\t\tcase (unsigned short)0xefbb: /* UTF-8? */\n\t\t\tif (fread(&c1, sizeof(char), 1, f) != 1 || c1 != 0xbf) { /* Not UTF-8 */\n\t\t\t\tfseek(f, pos, SEEK_SET);\n\t\t\t\tif (bom != NULL)\n\t\t\t\t\tbom[0] = '\\0';\n\t\t\t\tif (sz_bom != NULL)\n\t\t\t\t\t*sz_bom = 0;\n\t\t\t\treturn BOM_NONE;\n\t\t\t}\n\t\t\tif (bom != NULL) {\n\t\t\t\tbom[2] = c1;\n\t\t\t\tbom[3] = '\\0';\n\t\t\t}\n\t\t\tif (sz_bom != NULL)\n\t\t\t\t*sz_bom = 3;\n\t\t\treturn BOM_UTF_8;\n\n\t\tdefault: /* No BOM, go back */\n\t\t\tfseek(f, pos, SEEK_SET);\n\t\t\tif (bom != NULL)\n\t\t\t\tbom[0] = '\\0';\n\t\t\tif (sz_bom != NULL)\n\t\t\t\t*sz_bom = 0;\n\t\t\treturn BOM_NONE;\n\t}\n}\n\n/* --- */\n\nSXML_CHAR* html2str(SXML_CHAR* html, SXML_CHAR* str)\n{\n\tSXML_CHAR *ps, *pd;\n\tint i;\n\n\tif (html == NULL) return NULL;\n\n\tif (str == NULL) str = html;\n\n\t/* Look for '&' and matches it to any of the recognized HTML pattern. */\n\t/* If found, replaces the '&' by the corresponding char. */\n\t/* 'p2' is the char to analyze, 'p1' is where to insert it */\n\tfor (pd = str, ps = html; *ps; ps++, pd++) {\n\t\tif (*ps != C2SX('&')) {\n\t\t\tif (pd != ps)\n\t\t\t\t*pd = *ps;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {\n\t\t\tif (sx_strncmp(ps, HTML_SPECIAL_DICT[i].html, HTML_SPECIAL_DICT[i].html_len))\n\t\t\t\tcontinue;\n\n\t\t\t*pd = HTML_SPECIAL_DICT[i].chr;\n\t\t\tps += HTML_SPECIAL_DICT[i].html_len-1;\n\t\t\tbreak;\n\t\t}\n\t\t/* If no string was found, simply copy the character */\n\t\tif (HTML_SPECIAL_DICT[i].chr == NULC && pd != ps)\n\t\t\t*pd = *ps;\n\t}\n\t*pd = NULC;\n\n\treturn str;\n}\n\n/* TODO: Allocate 'html'? */\nSXML_CHAR* str2html(SXML_CHAR* str, SXML_CHAR* html)\n{\n\tSXML_CHAR *ps, *pd;\n\tint i;\n\n\tif (str == NULL)\n\t\treturn NULL;\n\n\tif (html == str) /* Not handled (yet) */\n\t\treturn NULL;\n\n\tif (html == NULL) { /* Allocate 'html' to the correct size */\n\t\thtml = __malloc(strlen_html(str) * sizeof(SXML_CHAR));\n\t\tif (html == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tfor (ps = str, pd = html; *ps; ps++, pd++) {\n\t\tfor (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {\n\t\t\tif (*ps == HTML_SPECIAL_DICT[i].chr) {\n\t\t\t\tsx_strcpy(pd, HTML_SPECIAL_DICT[i].html);\n\t\t\t\tpd += HTML_SPECIAL_DICT[i].html_len - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (HTML_SPECIAL_DICT[i].chr == NULC && pd != ps)\n\t\t\t*pd = *ps;\n\t}\n\t*pd = NULC;\n\n\treturn html;\n}\n\nint strlen_html(SXML_CHAR* str)\n{\n\tint i, j, n;\n\n\tif (str == NULL)\n\t\treturn 0;\n\n\tn = 0;\n\tfor (i = 0; str[i] != NULC; i++) {\n\t\tfor (j = 0; HTML_SPECIAL_DICT[j].chr; j++) {\n\t\t\tif (str[i] == HTML_SPECIAL_DICT[j].chr) {\n\t\t\t\tn += HTML_SPECIAL_DICT[j].html_len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (HTML_SPECIAL_DICT[j].chr == NULC)\n\t\t\tn++;\n\t}\n\n\treturn n;\n}\n\nint fprintHTML(FILE* f, SXML_CHAR* str)\n{\n\tSXML_CHAR* p;\n\tint i, n;\n\n\tfor (p = str, n = 0; *p != NULC; p++) {\n\t\tfor (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {\n\t\t\tif (*p != HTML_SPECIAL_DICT[i].chr)\n\t\t\t\tcontinue;\n\t\t\tsx_fprintf(f, HTML_SPECIAL_DICT[i].html);\n\t\t\tn += HTML_SPECIAL_DICT[i].html_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (HTML_SPECIAL_DICT[i].chr == NULC) {\n\t\t\t(void)sx_fputc(*p, f);\n\t\t\tn++;\n\t\t}\n\t}\n\n\treturn n;\n}\n\nint regstrcmp(SXML_CHAR* str, SXML_CHAR* pattern)\n{\n\tSXML_CHAR *p, *s;\n\n\tif (str == NULL && pattern == NULL)\n\t\treturn true;\n\n\tif (str == NULL || pattern == NULL)\n\t\treturn false;\n\n\tp = pattern;\n\ts = str;\n\twhile (true) {\n\t\tswitch (*p) {\n\t\t\t/* Any character matches, go to next one */\n\t\t\tcase C2SX('?'):\n\t\t\t\tp++;\n\t\t\t\ts++;\n\t\t\t\tbreak;\n\n\t\t\t/* Go to next character in pattern and wait until it is found in 'str' */\n\t\t\tcase C2SX('*'):\n\t\t\t\tfor (; *p != NULC; p++) { /* Squeeze '**?*??**' to '*' */\n\t\t\t\t\tif (*p != C2SX('*') && *p != C2SX('?'))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (; *s != NULC; s++) {\n\t\t\t\t\tif (*s == *p)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* NULL character on pattern has to be matched by 'str' */\n\t\t\tcase 0:\n\t\t\t\treturn *s ? false : true;\n\n\t\t\tdefault:\n\t\t\t\tif (*p == C2SX('\\\\')) /* Escape character */\n\t\t\t\t\tp++;\n\t\t\t\tif (*p++ != *s++) /* Characters do not match */\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n"
        },
        {
          "name": "sxmlc.h",
          "type": "blob",
          "size": 29.2744140625,
          "content": "/*\n\tCopyright (c) 2010, Matthieu Labas\n\tAll rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification,\n\tare permitted provided that the following conditions are met:\n\n\t1. Redistributions of source code must retain the above copyright notice,\n\t   this list of conditions and the following disclaimer.\n\n\t2. Redistributions in binary form must reproduce the above copyright notice,\n\t   this list of conditions and the following disclaimer in the documentation\n\t   and/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n\tANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\tWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n\tIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n\tINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n\tNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\tPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\tWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n\tARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n\tOF SUCH DAMAGE.\n\n\tThe views and conclusions contained in the software and documentation are those of the\n\tauthors and should not be interpreted as representing official policies, either expressed\n\tor implied, of the FreeBSD Project.\n*/\n#ifndef _SXML_H_\n#define _SXML_H_\n\n#define SXMLC_VERSION \"4.2.7\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdio.h>\n\n#ifdef SXMLC_UNICODE\n\ttypedef wchar_t SXML_CHAR;\n\t#define C2SX(c) L ## c\n\t#define CSXEOF WEOF\n\t#define sx_strcmp wcscmp\n\t#define sx_strncmp wcsncmp\n\t#define sx_strlen wcslen\n\t#define sx_strdup wcsdup\n\t#define sx_strchr wcschr\n\t#define sx_strrchr wcsrchr\n\t#define sx_strcpy wcscpy\n\t#define sx_strncpy wcsncpy\n\t#define sx_strcat wcscat\n\t#define sx_printf wprintf\n\t#define sx_fprintf fwprintf\n\t#define sx_sprintf swprintf\n\t#define sx_fgetc fgetwc\n\t#define sx_fputc fputwc\n\t#define sx_isspace iswspace\n\t#if defined(WIN32) || defined(WIN64)\n\t\t#define sx_fopen _wfopen\n\t#else\n\t\t#define sx_fopen fopen\n\t#endif\n\t#define sx_fclose fclose\n\t#define sx_feof feof\n#else\n\ttypedef char SXML_CHAR;\n\t#define C2SX(c) c\n\t#define CSXEOF EOF\n\t#define sx_strcmp strcmp\n\t#define sx_strncmp strncmp\n\t#define sx_strlen strlen\n\t#define sx_strdup __sx_strdup\n\t#define sx_strchr strchr\n\t#define sx_strrchr strrchr\n\t#define sx_strcpy strcpy\n\t#define sx_strncpy strncpy\n\t#define sx_strcat strcat\n\t#define sx_printf printf\n\t#define sx_fprintf fprintf\n\t#define sx_sprintf sprintf\n\t#define sx_fgetc fgetc\n\t#define sx_fputc fputc\n\t#define sx_isspace(ch) isspace((int)ch)\n\t#define sx_fopen fopen\n\t#define sx_fclose fclose\n\t#define sx_feof feof\n#endif\n\n#ifdef DBG_MEM\n\tvoid* __malloc(size_t sz);\n\tvoid* __calloc(size_t count, size_t sz);\n\tvoid* __realloc(void* mem, size_t sz);\n\tvoid __free(void* mem);\n\tchar* __sx_strdup(const char* s);\n#else\n\t#define __malloc malloc\n\t#define __calloc calloc\n\t#define __realloc realloc\n\t#define __free free\n\t#define __sx_strdup strdup\n#endif\n\n#ifndef MEM_INCR_RLA\n#define MEM_INCR_RLA (256*sizeof(SXML_CHAR)) /* Initial buffer size and increment for memory reallocations */\n#endif\n\n#ifndef false\n#define false 0\n#endif\n\n#ifndef true\n#define true 1\n#endif\n\n#define NULC ((SXML_CHAR)C2SX('\\0'))\n#define isquote(c) (((c) == C2SX('\"')) || ((c) == C2SX('\\'')))\n\n/*\n Buffer data source used by 'read_line_alloc' when required.\n 'buf' should be 0-terminated.\n */\ntypedef struct _DataSourceBuffer {\n\tconst SXML_CHAR* buf;\n\tint cur_pos;\n} DataSourceBuffer;\n\ntypedef FILE* DataSourceFile;\n\ntypedef enum _DataSourceType {\n\tDATA_SOURCE_FILE = 0,\n\tDATA_SOURCE_BUFFER,\n\tDATA_SOURCE_MAX\n} DataSourceType;\n\n#ifndef false\n#define false 0\n#endif\n\n#ifndef true\n#define true 1\n#endif\n\n/* Node types */\ntypedef enum _TagType {\n\tTAG_ERROR = -1,\n\tTAG_NONE = 0,\n\tTAG_PARTIAL,\t/* Node containing a legal '>' that stopped file reading */\n\tTAG_FATHER,\t\t/* <tag> - Next nodes will be children of this one. */\n\tTAG_SELF,\t\t/* <tag/> - Standalone node. */\n\tTAG_INSTR,\t\t/* <?prolog?> - Processing instructions, or prolog node. */\n\tTAG_COMMENT,\t/* <!--comment--> */\n\tTAG_CDATA,\t\t/* <![CDATA[ ]]> - CDATA node */\n\tTAG_DOCTYPE,\t/* <!DOCTYPE [ ]> - DOCTYPE node */\n\tTAG_END,\t\t/* </tag> - End of father node. */\n\tTAG_TEXT,\t\t/* text node*/\n\n\tTAG_USER = 100\t/* User-defined tag start */\n} TagType;\n\n/* TODO: Performance improvement with some fixed-sized strings ??? (e.g. XMLAttribute.name[64], XMLNode.tag[64]) */\n\ntypedef struct _XMLAttribute {\n\tSXML_CHAR* name;\n\tSXML_CHAR* value;\n\tint active;\n} XMLAttribute;\n\n/* Constant to know whether a struct has been initialized (XMLNode or XMLDoc) */\n#define XML_INIT_DONE 0x19770522 /* Happy Birthday ;) */\n\n/*\n An XML node.\n */\ntypedef struct _XMLNode {\n\tSXML_CHAR* tag;\t\t\t\t/* Tag name */\n\tSXML_CHAR* text;\t\t\t/* Text inside the node */\n\tXMLAttribute* attributes;\n\tint n_attributes;\n\n\tstruct _XMLNode* father;\t/* NULL if root */\n\tstruct _XMLNode** children;\n\tint n_children;\n\n\tTagType tag_type;\t/* Node type ('TAG_FATHER', 'TAG_SELF' or 'TAG_END') */\n\tint active;\t\t/* 'true' to tell that node is active and should be displayed by 'XMLDoc_print' */\n\n\tvoid* user;\t/* Pointer for user data associated to the node */\n\n\t/* Keep 'init_value' as the last member */\n\tint init_value;\t/* Initialized to 'XML_INIT_DONE' to indicate that node has been initialized properly */\n} XMLNode;\n\n/*\n An XML document.\n */\n#ifndef SXMLC_MAX_PATH\n#define SXMLC_MAX_PATH 256\n#endif\ntypedef struct _XMLDoc {\n\tSXML_CHAR filename[SXMLC_MAX_PATH];\n#ifdef SXMLC_UNICODE\n\tBOM_TYPE bom_type;\n\tunsigned char bom[5];\t/* First characters read that might be a BOM when unicode is used */\n\tint sz_bom;\t\t\t\t/* Number of bytes in BOM */\n#endif\n\tXMLNode** nodes;\t\t/* Nodes of the document, including prolog, comments and root nodes */\n\tint n_nodes;\t\t\t/* Number of nodes in 'nodes' */\n\tint i_root;\t\t\t\t/* Index of first root node in 'nodes', -1 if document is empty */\n\n\t/* Keep 'init_value' as the last member */\n\tint init_value;\t/* Initialized to 'XML_INIT_DONE' to indicate that document has been initialized properly */\n} XMLDoc;\n\n/*\n Register an XML tag, giving its 'start' and 'end' string, which should include '<' and '>'.\n The 'tag_type' is user-given and has to be less than or equal to 'TAG_USER'. It will be\n returned as the 'tag_type' member of the XMLNode struct. Note that no test is performed\n to check for an already-existing tag_type.\n Return tag index in user tags table when successful, or '-1' if the 'tag_type' is invalid or\n the new tag could not be registered (e.g. when 'start' does not start with '<' or 'end' does not end with '>').\n */\nint XML_register_user_tag(TagType tag_type, SXML_CHAR* start, SXML_CHAR* end);\n\n/*\n Remove a registered user tag.\n Return the new number of registered user tags or '-1' if 'i_tag' is invalid.\n */\nint XML_unregister_user_tag(int i_tag);\n\n/*\n Return the number of registered tags.\n */\nint XML_get_nb_registered_user_tags(void);\n\n/*\n Return the index of first occurrence of 'tag_type' in registered user tags, or '-1' if not found.\n */\nint XML_get_registered_user_tag(TagType tag_type);\n\n\ntypedef enum _ParseError {\n\tPARSE_ERR_NONE = 0,\n\tPARSE_ERR_MEMORY = -1,\n\tPARSE_ERR_UNEXPECTED_TAG_END = -2,\n\tPARSE_ERR_SYNTAX = -3,\n\tPARSE_ERR_EOF = -4,\n\tPARSE_ERR_TEXT_OUTSIDE_NODE = -5, /* During DOM loading */\n\tPARSE_ERR_UNEXPECTED_NODE_END = -6 /* During DOM loading */\n} ParseError;\n\n/*\n Events that can happen when loading an XML document.\n These will be passed to the 'all_event' callback of the SAX parser.\n */\ntypedef enum _XMLEvent {\n\tXML_EVENT_START_DOC,\n\tXML_EVENT_START_NODE,\n\tXML_EVENT_END_NODE,\n\tXML_EVENT_TEXT,\n\tXML_EVENT_ERROR,\n\tXML_EVENT_END_DOC\n} XMLEvent;\n\n/*\n Structure given as an argument for SAX callbacks to retrieve information about\n parsing status\n */\ntypedef struct _SAX_Data {\n\tconst SXML_CHAR* name;\n\tFILE *file;\n\tint line_num;\n\tvoid* user;\n} SAX_Data;\n\n/*\n User callbacks used for SAX parsing. Return values of these callbacks should be 0 to stop parsing.\n Members can be set to NULL to disable handling of some events.\n All parameters are pointers to structures that will no longer be available after callback returns.\n It is recommended that the callback uses the information and stores it in its own data structure.\n WARNING! SAX PARSING DOES NOT CHECK FOR XML INTEGRITY! e.g. a tag end without a matching tag start\n will not be detected by the parser and should be detected by the callbacks instead.\n */\ntypedef struct _SAX_Callbacks {\n\t/*\n\t Callback called when parsing starts, before parsing the first node.\n\t */\n\tint (*start_doc)(SAX_Data* sd);\n\n\t/*\n\t Callback called when a new node starts (e.g. '<tag>' or '<tag/>').\n\t If any, attributes can be read from 'node->attributes'.\n\t N.B. '<tag/>' will trigger an immediate call to the 'end_node' callback\n\t after the 'start_node' callback.\n\t */\n\tint (*start_node)(const XMLNode* node, SAX_Data* sd);\n\n\t/*\n\t Callback called when a node ends (e.g. '</tag>' or '<tag/>').\n\t */\n\tint (*end_node)(const XMLNode* node, SAX_Data* sd);\n\n\t/*\n\t Callback called when text has been found in the last node.\n\t */\n\tint (*new_text)(SXML_CHAR* text, SAX_Data* sd);\n\n\t/*\n\t Callback called when parsing is finished.\n\t No other callbacks will be called after it.\n\t */\n\tint (*end_doc)(SAX_Data* sd);\n\n\t/*\n\t Callback called when an error occurs during parsing.\n\t 'error_num' is the error number and 'line_number' is the line number in the stream\n\t being read (file or buffer).\n\t */\n\tint (*on_error)(ParseError error_num, int line_number, SAX_Data* sd);\n\n\t/*\n\t Callback called when text has been found in the last node.\n\t 'event' is the type of event for which the callback was called:\n\t \t XML_EVENT_START_DOC:\n\t \t \t 'node' is NULL.\n\t \t \t 'text' is the file name if a file is being parsed, NULL if a buffer is being parsed.\n\t \t \t 'n' is 0.\n\t \t XML_EVENT_START_NODE:\n\t \t \t 'node' is the node starting, with tag and all attributes initialized.\n\t \t \t 'text' is NULL.\n\t \t \t 'n' is the number of lines parsed.\n\t \t XML_EVENT_END_NODE:\n\t \t \t 'node' is the node ending, with tag, attributes and text initialized.\n\t \t \t 'text' is NULL.\n\t \t \t 'n' is the number of lines parsed.\n\t \t XML_EVENT_TEXT:\n\t \t \t 'node' is NULL.\n\t \t \t 'text' is the text to be added to last node started and not finished.\n\t \t \t 'n' is the number of lines parsed.\n\t \t XML_EVENT_ERROR:\n\t \t \t Everything is NULL.\n\t \t \t 'n' is one of the 'PARSE_ERR_*'.\n\t \t XML_EVENT_END_DOC:\n\t \t \t 'node' is NULL.\n\t \t \t 'text' is the file name if a file is being parsed, NULL if a buffer is being parsed.\n\t \t \t 'n' is the number of lines parsed.\n\t */\n\tint (*all_event)(XMLEvent event, const XMLNode* node, SXML_CHAR* text, const int n, SAX_Data* sd);\n} SAX_Callbacks;\n\n/*\n Helper function to initialize all 'sax' members to NULL.\n Return 'false' is 'sax' is NULL.\n */\nint SAX_Callbacks_init(SAX_Callbacks* sax);\n\n/*\n Set of SAX callbacks used by 'XMLDoc_parse_file_DOM'.\n These are made available to be able to load an XML document using DOM implementation\n with user-defined code at some point (e.g. counting nodes, running search, ...).\n In this case, the 'XMLDoc_parse_file_SAX' has to be called instead of the 'XMLDoc_parse_file_DOM',\n providing either these callbacks directly, or a functions calling these callbacks.\n To do that, you should initialize the 'doc' member of the 'DOM_through_SAX' struct and call the\n 'XMLDoc_parse_file_SAX' giving this struct as a the 'user' data pointer.\n */\n\ntypedef struct _DOM_through_SAX {\n\tXMLDoc* doc;\t\t/* Document to fill up */\n\tXMLNode* current;\t/* For internal use (current father node) */\n\tParseError error;\t/* For internal use (parse status) */\n\tint line_error;\t\t/* For internal use (line number when error occurred) */\n\tint text_as_nodes;\t/* For internal use (store text inside nodes as sequential TAG_TEXT nodes) */\n} DOM_through_SAX;\n\nint DOMXMLDoc_doc_start(SAX_Data* dom);\nint DOMXMLDoc_node_start(const XMLNode* node, SAX_Data* dom);\nint DOMXMLDoc_node_text(SXML_CHAR* text, SAX_Data* dom);\nint DOMXMLDoc_node_end(const XMLNode* node, SAX_Data* dom);\nint DOMXMLDoc_parse_error(ParseError error_num, int line_number, SAX_Data* sd);\nint DOMXMLDoc_doc_end(SAX_Data* dom);\n\n/*\n Initialize 'sax' with the \"official\" DOM callbacks.\n */\nint SAX_Callbacks_init_DOM(SAX_Callbacks* sax);\n\n/* --- XMLNode methods --- */\n\n/*\n Fills 'xmlattr' with 'xmlattr->name' to 'attrName' and 'xmlattr->value' to 'attr Value'.\n 'str' is supposed to be like 'attrName[ ]=[ ][\"]attr Value[\"]'.\n Return 0 if not enough memory or bad parameters (NULL 'str' or 'xmlattr').\n        2 if last quote is missing in the attribute value.\n        1 if 'xmlattr' was filled correctly.\n */\nint XML_parse_attribute_to(const SXML_CHAR* str, int to, XMLAttribute* xmlattr);\n\n#define XML_parse_attribute(str, xmlattr) XML_parse_attribute_to(str, -1, xmlattr)\n\n/*\n Reads a string that is supposed to be an xml tag like '<tag (attribName=\"attribValue\")* [/]>' or '</tag>'.\n Fills the 'xmlnode' structure with the tag name and its attributes.\n Returns 0 if an error occurred (malformed 'str' or memory). 'TAG_*' when string is recognized.\n */\nTagType XML_parse_1string(const SXML_CHAR* str, XMLNode* xmlnode);\n\n/*\n Allocate and initialize XML nodes.\n 'n' is the number of contiguous elements to allocate (to create and array).\n Return 'NULL' if not enough memory, or the pointer to the elements otherwise.\n */\nXMLNode* XMLNode_allocN(int n);\n\n/*\n Shortcut to allocate one node only.\n */\n#define XMLNode_alloc() XMLNode_allocN(1)\n\n/*\n Initialize an already-allocated XMLNode.\n */\nint XMLNode_init(XMLNode* node);\n\n/*\n Free a node and all its children.\n */\nint XMLNode_free(XMLNode* node);\n\n/*\n Free XMLNode 'dst' and copy 'src' to 'dst', along with its children if specified.\n If 'src' is NULL, 'dst' is freed and initialized.\n */\nint XMLNode_copy(XMLNode* dst, const XMLNode* src, int copy_children);\n\n/*\n Allocate a node and copy 'node' into it.\n If 'copy_children' is 'true', all children of 'node' will be copied to the new node.\n Return 'NULL' if not enough memory, or a pointer to the new node otherwise.\n */\nXMLNode* XMLNode_dup(const XMLNode* node, int copy_children);\n\n/*\n Set the active/inactive state of 'node'.\n Set 'active' to 'true' to activate 'node' and all its children, and enable its use\n in other functions (e.g. 'XMLDoc_print', 'XMLNode_search_child').\n */\nint XMLNode_set_active(XMLNode* node, int active);\n\n/*\n Set 'node' tag.\n Return 'false' for memory error, 'true' otherwise.\n */\nint XMLNode_set_tag(XMLNode* node, const SXML_CHAR* tag);\n\n/*\n Set the node type among one of the valid ones (TAG_FATHER, TAG_SELF, TAG_INSTR,\n TAG_COMMENT, TAG_CDATA, TAG_DOCTYPE) or any user-registered tag.\n Return 'false' when the node or the 'tag_type' is invalid.\n */\nint XMLNode_set_type(XMLNode* node, const TagType tag_type);\n\n/*\n Add an attribute to 'node' or update an existing one.\n The attribute has a 'name' and a 'value'.\n Return the new number of attributes, or -1 for memory problem.\n */\nint XMLNode_set_attribute(XMLNode* node, const SXML_CHAR* attr_name, const SXML_CHAR* attr_value);\n\n/*\n Retrieve an attribute value, based on its name, allocating 'attr_value'.\n If the attribute name does not exist, set 'attr_value' to the given default value.\n Return 'false' when the node is invalid, 'attr_name' is NULL or empty, or 'attr_value' is NULL.\n */\nint XMLNode_get_attribute_with_default(XMLNode* node, const SXML_CHAR* attr_name, const SXML_CHAR** attr_value, const SXML_CHAR* default_attr_value);\n\n/*\n Helper macro that retrieve an attribute value, or an empty string if the attribute does\n not exist.\n */\n#define XMLNode_get_attribute(node, attr_name, attr_value) XMLNode_get_attribute_with_default(node, attr_name, attr_value, C2SX(\"\"))\n\n/*\n Return the number of active attributes of 'node', or '-1' if 'node' is invalid.\n*/\nint XMLNode_get_attribute_count(const XMLNode* node);\n\n/*\n Search for the active attribute 'attr_name' in 'node', starting from index 'isearch'\n and returns its index, or -1 if not found or error.\n */\nint XMLNode_search_attribute(const XMLNode* node, const SXML_CHAR* attr_name, int isearch);\n\n/*\n Remove attribute index 'i_attr'.\n Return the new number of attributes or -1 on invalid arguments.\n */\nint XMLNode_remove_attribute(XMLNode* node, int i_attr);\n\n/*\n Remove all attributes from 'node'.\n */\nint XMLNode_remove_all_attributes(XMLNode* node);\n\n/*\n Set node text.\n Return 'true' when successful, 'false' on error.\n */\nint XMLNode_set_text(XMLNode* node, const SXML_CHAR* text);\n\n/*\n Helper macro to remove text from 'node'.\n */\n#define XMLNode_remove_text(node) XMLNode_set_text(node, NULL);\n\n/*\n Add a child to a node.\n Return 'false' for memory problem, 'true' otherwise.\n */\nint XMLNode_add_child(XMLNode* node, XMLNode* child);\n\n/*\n Return the number of active children nodes of 'node', or '-1' if 'node' is invalid.\n */\nint XMLNode_get_children_count(const XMLNode* node);\n\n/*\n Return a reference to the 'i_child'th active node.\n */\nXMLNode* XMLNode_get_child(const XMLNode* node, int i_child);\n\n/*\n Remove the 'i_child'th active child of 'node'.\n If 'free_child' is 'true', free the child node itself. This parameter is usually 'true'\n but should be 'false' when child nodes are pointers to local or global variables instead of\n user-allocated memory.\n Return the new number of children or -1 on invalid arguments.\n */\nint XMLNode_remove_child(XMLNode* node, int i_child, int free_child);\n\n/*\n Remove all children from 'node'.\n */\nint XMLNode_remove_children(XMLNode* node);\n\n/*\n Return 'true' if 'node1' is the same as 'node2' (i.e. same tag, same active attributes).\n */\nint XMLNode_equal(const XMLNode* node1, const XMLNode* node2);\n\n/*\n Return the next sibling of node 'node', or NULL if 'node' is invalid or the last child\n or if its father could not be determined (i.e. 'node' is a root node).\n */\nXMLNode* XMLNode_next_sibling(const XMLNode* node);\n\n/*\n Return the next node in XML order i.e. first child or next sibling, or NULL\n if 'node' is invalid or the end of its root node is reached.\n */\nXMLNode* XMLNode_next(const XMLNode* node);\n\n\n/* --- XMLDoc methods --- */\n\n\n/*\n Initializes an already-allocated XML document.\n */\nint XMLDoc_init(XMLDoc* doc);\n\n/*\n Free an XML document.\n Return 'false' if 'doc' was not initialized.\n */\nint XMLDoc_free(XMLDoc* doc);\n\n/*\n Set the new 'doc' root node among all existing nodes in 'doc'.\n Return 'false' if bad arguments, 'true' otherwise.\n */\nint XMLDoc_set_root(XMLDoc* doc, int i_root);\n\n/*\n Add a node to the document, specifying the type.\n If its type is TAG_FATHER, it also sets the document root node if previously undefined.\n Return the node index, or -1 if bad arguments or memory error.\n */\nint XMLDoc_add_node(XMLDoc* doc, XMLNode* node);\n\n/*\n Remove a node from 'doc' root nodes, base on its index.\n If 'free_node' is 'true', free the node itself. This parameter is usually 'true'\n but should be 'false' when the node is a pointer to local or global variable instead of\n user-allocated memory.\n Return 'true' if node was removed or 'false' if 'doc' or 'i_node' is invalid.\n */\nint XMLDoc_remove_node(XMLDoc* doc, int i_node, int free_node);\n\n/*\n Shortcut macro to retrieve root node from a document.\n Equivalent to\n doc->nodes[doc->i_root]\n */\n#define XMLDoc_root(doc) ((doc)->nodes[(doc)->i_root])\n\n/*\n Shortcut macro to add a node to 'doc' root node.\n Equivalent to\n XMLDoc_add_child_root(XMLDoc* doc, XMLNode* child);\n */\n#define XMLDoc_add_child_root(doc, child) XMLNode_add_child((doc)->nodes[(doc)->i_root], (child))\n\n/*\n Default quote to use to print attribute value.\n User can redefine it with its own character by adding a #define XML_DEFAULT_QUOTE before including\n this file.\n */\n#ifndef XML_DEFAULT_QUOTE\n#define XML_DEFAULT_QUOTE C2SX('\"')\n#endif\n\n/*\n Print the node and its children to a file (that can be stdout).\n - 'tag_sep' is the string to use to separate nodes from each other (usually \"\\n\").\n - 'child_sep' is the additional string to put for each child level (usually \"\\t\").\n - 'keep_text_spaces' indicates that text should not be printed if it is composed of\n   spaces, tabs or new lines only (e.g. when XML document spans on several lines due to\n   pretty-printing).\n - 'sz_line' is the maximum number of characters that can be put on a single line. The\n   node remainder will be output to extra lines.\n - 'nb_char_tab' is how many characters should be counted for a tab when counting characters\n   in the line. It usually is 8 or 4, but at least 1.\n - 'depth' is an internal parameter that is used to determine recursively how deep we are in\n   the tree. It should be initialized to 0 at first call.\n Return 'false' on invalid arguments (NULL 'node' or 'f'), 'true' otherwise.\n */\nint XMLNode_print_attr_sep(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* child_sep, const SXML_CHAR* attr_sep, int keep_text_spaces, int sz_line, int nb_char_tab);\n\n/* For backward compatibility */\n#define XMLNode_print(node, f, tag_sep, child_sep, keep_text_spaces, sz_line, nb_char_tab) XMLNode_print_attr_sep(node, f, tag_sep, child_sep, C2SX(\" \"), keep_text_spaces, sz_line, nb_char_tab)\n\n/*\n Print the node \"header\": <tagname attribname=\"attibval\" ...[/]>, spanning it on several lines if needed.\n Return 'false' on invalid arguments (NULL 'node' or 'f'), 'true' otherwise.\n */\nint XMLNode_print_header(const XMLNode* node, FILE* f, int sz_line, int nb_char_tab);\n\n/*\n Prints the XML document using 'XMLNode_print' on all document root nodes.\n */\nint XMLDoc_print_attr_sep(const XMLDoc* doc, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* child_sep, const SXML_CHAR* attr_sep, int keep_text_spaces, int sz_line, int nb_char_tab);\n\n/* For backward compatibility */\n#define XMLDoc_print(doc, f, tag_sep, child_sep, keep_text_spaces, sz_line, nb_char_tab) XMLDoc_print_attr_sep(doc, f, tag_sep, child_sep, C2SX(\" \"), keep_text_spaces, sz_line, nb_char_tab)\n\n/*\n Create a new XML document from a given 'filename' and load it to 'doc'.\n 'text_as_nodes' should be non-zero to put text into separate TAG_TEXT nodes.\n Return 'false' in case of error (memory or unavailable filename, malformed document), 'true' otherwise.\n */\nint XMLDoc_parse_file_DOM_text_as_nodes(const SXML_CHAR* filename, XMLDoc* doc, int text_as_nodes);\n\n/* For backward compatibility */\n#define XMLDoc_parse_file_DOM(filename, doc) XMLDoc_parse_file_DOM_text_as_nodes(filename, doc, 0)\n\n/*\n Create a new XML document from a memory buffer 'buffer' that can be given a name 'name', and load\n it into 'doc'.\n 'text_as_nodes' should be non-zero to put text into separate TAG_TEXT nodes.\n Return 'false' in case of error (memory or unavailable filename, malformed document), 'true' otherwise.\n */\nint XMLDoc_parse_buffer_DOM_text_as_nodes(const SXML_CHAR* buffer, const SXML_CHAR* name, XMLDoc* doc, int text_as_nodes);\n\n/* For backward compatibility */\n#define XMLDoc_parse_buffer_DOM(buffer, name, doc) XMLDoc_parse_buffer_DOM_text_as_nodes(buffer, name, doc, 0)\n\n/*\n Parse an XML document from a given 'filename', calling SAX callbacks given in the 'sax' structure.\n 'user' is a user-given pointer that will be given back to all callbacks.\n Return 'false' in case of error (memory or unavailable filename, malformed document), 'true' otherwise.\n */\nint XMLDoc_parse_file_SAX(const SXML_CHAR* filename, const SAX_Callbacks* sax, void* user);\n\n/*\n Parse an XML document from a memory buffer 'buffer' that can be given a name 'name',\n calling SAX callbacks given in the 'sax' structure.\n 'user' is a user-given pointer that will be given back to all callbacks.\n Return 'false' in case of error (memory or unavailable filename, malformed document), 'true' otherwise.\n */\nint XMLDoc_parse_buffer_SAX(const SXML_CHAR* buffer, const SXML_CHAR* name, const SAX_Callbacks* sax, void* user);\n\n/*\n Parse an XML file using the DOM implementation.\n */\n#define XMLDoc_parse_file XMLDOC_parse_file_DOM\n\n\n\n/* --- Utility functions --- */\n\n/*\n Functions to get next byte from buffer data source and know if the end has been reached.\n Return as 'fgetc' and 'feof' would for 'FILE*'.\n */\nint _bgetc(DataSourceBuffer* ds);\nint _beob(DataSourceBuffer* ds);\n/*\n Reads a line from data source 'in', eventually (re-)allocating a given buffer 'line'.\n Characters read will be stored in 'line' starting at 'i0' (this allows multiple calls to\n 'read_line_alloc' on the same 'line' buffer without overwriting it at each call).\n 'in_type' specifies the type of data source to be read: 'in' is 'FILE*' if 'in_type'\n 'sz_line' is the size of the buffer 'line' if previously allocated. 'line' can point\n to NULL, in which case it will be allocated '*sz_line' bytes. After the function returns,\n '*sz_line' is the actual buffer size. This allows multiple calls to this function using the\n same buffer (without re-allocating/freeing).\n If 'sz_line' is non NULL and non 0, it means that '*line' is a VALID pointer to a location\n of '*sz_line' SXML_CHAR (not bytes! Multiply by sizeof(SXML_CHAR) to get number of bytes).\n Searches for character 'from' until character 'to'. If 'from' is 0, starts from\n current position. If 'to' is 0, it is replaced by '\\n'.\n If 'keep_fromto' is 0, removes characters 'from' and 'to' from the line.\n If 'interest_count' is not NULL, will receive the count of 'interest' characters while searching\n for 'to' (e.g. use 'interest'='\\n' to count lines in file).\n Returns the number of characters in the line or 0 if an error occurred.\n 'read_line_alloc' uses constant 'MEM_INCR_RLA' to reallocate memory when needed. It is possible\n to override this definition to use another value.\n */\nint read_line_alloc(void* in, DataSourceType in_type, SXML_CHAR** line, int* sz_line, int i0, SXML_CHAR from, SXML_CHAR to, int keep_fromto, SXML_CHAR interest, int* interest_count);\n\n/*\n Concatenates the string pointed at by 'src1' with 'src2' into '*src1' and\n return it ('*src1').\n Return NULL when out of memory.\n */\nSXML_CHAR* strcat_alloc(SXML_CHAR** src1, const SXML_CHAR* src2);\n\n/*\n Strip spaces at the beginning and end of 'str', modifying 'str'.\n If 'repl_sq' is not '\\0', squeezes spaces to an single character ('repl_sq').\n If not '\\0', 'protect' is used to protect spaces from being deleted (usually a backslash).\n Returns the string or NULL if 'protect' is a space (which would not make sense).\n */\nSXML_CHAR* strip_spaces(SXML_CHAR* str, SXML_CHAR repl_sq);\n\n/*\n Remove '\\' characters from 'str', modifying it.\n Return 'str'.\n */\nSXML_CHAR* str_unescape(SXML_CHAR* str);\n\n/*\n Split 'str' into a left and right part around a separator 'sep'.\n The left part is located between indexes 'l0' and 'l1' while the right part is\n between 'r0' and 'r1' and the separator position is at 'i_sep' (whenever these are\n not NULL).\n If 'ignore_spaces' is 'true', computed indexes will not take into account potential\n spaces around the separator as well as before left part and after right part.\n if 'ignore_quotes' is 'true', \" or ' will not be taken into account when parsing left\n and right members.\n Whenever the right member is empty (e.g. \"attrib\" or \"attrib=\"), '*r0' is initialized\n to 'str' size and '*r1' to '*r0-1' (crossed).\n If the separator was not found (i.e. left member only), '*i_sep' is '-1'.\n Return 'false' when 'str' is malformed, 'true' when splitting was successful.\n */\nint split_left_right(SXML_CHAR* str, SXML_CHAR sep, int* l0, int* l1, int* i_sep, int* r0, int* r1, int ignore_spaces, int ignore_quotes);\n\ntypedef enum _BOM_TYPE {\n\tBOM_NONE = 0x00,\n\tBOM_UTF_8 = 0xefbbbf,\n\tBOM_UTF_16BE = 0xfeff,\n\tBOM_UTF_16LE = 0xfffe,\n\tBOM_UTF_32BE = 0x0000feff,\n\tBOM_UTF_32LE = 0xfffe0000\n} BOM_TYPE;\n/*\n Detect a potential BOM at the current file position and read it into 'bom' (if not NULL,\n 'bom' should be at least 5 bytes). It also moves the 'f' beyond the BOM so it's possible to\n skip it by calling 'freadBOM(f, NULL, NULL)'. If no BOM is found, it leaves 'f' file pointer\n is reset to its original location.\n If not null, 'sz_bom' is filled with how many bytes are stored in 'bom'.\n Return the BOM type or BOM_NONE if none found (empty 'bom' in this case).\n */\nBOM_TYPE freadBOM(FILE* f, unsigned char* bom, int* sz_bom);\n\n/*\n Replace occurrences of special HTML characters escape sequences (e.g. '&amp;') found in 'html'\n by its character equivalent (e.g. '&') into 'str'.\n If 'html' and 'str' are the same pointer replacement is made in 'str' itself, overwriting it.\n If 'str' is NULL, replacement is made into 'html', overwriting it.\n Returns 'str' (or 'html' if 'str' was NULL).\n */\nSXML_CHAR* html2str(SXML_CHAR* html, SXML_CHAR* str);\n\n/*\n Replace occurrences of special characters (e.g. '&') found in 'str' into their XML escaped\n equivalent (e.g. '&amp;') into 'xml'.\n 'xml' is supposed allocated to the correct size (e.g. using 'malloc(strlen_html(str)+30)') and\n different from 'str' (unlike 'html2str'), as string will expand. If it is NULL, 'str' will be\n analyzed and a string will be allocated to the exact size, before being returned. In that case,\n it is the responsibility of the caller to free() the result!\n Return 'xml' or NULL if 'str' or 'xml' are NULL, or when 'xml' is 'str'.\n*/\nSXML_CHAR* str2html(SXML_CHAR* str, SXML_CHAR* xml);\n\n/*\n Return the length of 'str' as if all its special character were replaced by their HTML\n equivalent.\n Return 0 if 'str' is NULL.\n */\nint strlen_html(SXML_CHAR* str);\n\n/*\n Print 'str' to 'f', transforming special characters into their HTML equivalent.\n Returns the number of output characters.\n */\nint fprintHTML(FILE* f, SXML_CHAR* str);\n\n/*\n Checks whether 'str' corresponds to 'pattern'.\n 'pattern' can use wildcads such as '*' (any potentially empty string) or\n '?' (any character) and use '\\' as an escape character.\n Returns 'true' when 'str' matches 'pattern', 'false' otherwise.\n */\nint regstrcmp(SXML_CHAR* str, SXML_CHAR* pattern);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "user_io.cpp",
          "type": "blob",
          "size": 93.84375,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <time.h>\n#include <limits.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/statvfs.h>\n\n#include \"lib/imlib2/Imlib2.h\"\n\n#include \"hardware.h\"\n#include \"osd.h\"\n#include \"user_io.h\"\n#include \"debug.h\"\n#include \"spi.h\"\n#include \"cfg.h\"\n#include \"input.h\"\n#include \"fpga_io.h\"\n#include \"file_io.h\"\n#include \"menu.h\"\n#include \"DiskImage.h\"\n#include \"brightness.h\"\n#include \"sxmlc.h\"\n#include \"bootcore.h\"\n#include \"charrom.h\"\n#include \"scaler.h\"\n#include \"miniz.h\"\n#include \"cheats.h\"\n#include \"video.h\"\n#include \"audio.h\"\n#include \"shmem.h\"\n#include \"ide.h\"\n#include \"ide_cdrom.h\"\n#include \"profiling.h\"\n\n#include \"support.h\"\n\nstatic char core_path[1024] = {};\nstatic char rbf_path[1024] = {};\n\nstatic fileTYPE sd_image[16] = {};\nstatic int      sd_type[16] = {};\nstatic int      sd_image_cangrow[16] = {};\nstatic uint64_t buffer_lba[16] = { ULLONG_MAX,ULLONG_MAX,ULLONG_MAX,ULLONG_MAX,\n\t\t\t\t\t\t\t\t   ULLONG_MAX,ULLONG_MAX,ULLONG_MAX,ULLONG_MAX,\n\t\t\t\t\t\t\t\t   ULLONG_MAX,ULLONG_MAX,ULLONG_MAX,ULLONG_MAX,\n\t\t\t\t\t\t\t\t   ULLONG_MAX,ULLONG_MAX,ULLONG_MAX,ULLONG_MAX };\n\nstatic int use_save = 0;\n\n// mouse and keyboard emulation state\nstatic int emu_mode = EMU_NONE;\n\n// keep state over core type and its capabilities\nstatic unsigned char core_type = CORE_TYPE_UNKNOWN;\nstatic unsigned char dual_sdr = 0;\n\nstatic int fio_size = 0;\nstatic int io_ver = 0;\n\n// keep state of caps lock\nstatic char caps_lock_toggle = 0;\n\n#define LED_FREQ 100   // 100 ms\nstatic unsigned long led_timer;\nstatic char keyboard_leds = 0;\nstatic bool caps_status = 0;\nstatic bool num_status = 0;\nstatic bool scrl_status = 0;\nstatic bool winkey_pressed = 0;\n\nstatic uint16_t sdram_cfg = 0;\n\nstatic char last_filename[1024] = {};\nvoid user_io_store_filename(char *filename)\n{\n\tchar *p = strrchr(filename, '/');\n\tif (p) strcpy(last_filename, p + 1);\n\telse strcpy(last_filename, filename);\n\n\tp = strrchr(last_filename, '.');\n\tif (p) *p = 0;\n}\n\nconst char *get_image_name(int i)\n{\n\tif (!sd_image[i].size)  return NULL;\n\n\tchar *p = strrchr(sd_image[i].name, '/');\n\tif (!p) p = sd_image[i].name; else p++;\n\n\treturn p;\n}\n\nfileTYPE *get_image(int i)\n{\n\treturn &sd_image[i];\n}\n\nstatic uint32_t uart_mode;\nuint32_t user_io_get_uart_mode()\n{\n\treturn uart_mode;\n}\n\n// set by OSD code to suppress forwarding of those keys to the core which\n// may be in use by an active OSD\nstatic char osd_is_visible = 0;\n\nchar user_io_osd_is_visible()\n{\n\treturn osd_is_visible;\n}\n\nunsigned char user_io_core_type()\n{\n\treturn core_type;\n}\n\nstatic char config_ver[10] = {};\n\nchar* user_io_create_config_name(int with_ver)\n{\n\tstatic char str[40];\n\tstr[0] = 0;\n\tchar *p = user_io_get_core_name();\n\tif (p[0])\n\t{\n\t\tstrcpy(str, p);\n\t\tif (with_ver) strcat(str, config_ver);\n\t\tstrcat(str, \".CFG\");\n\t}\n\treturn str;\n}\n\nstatic char core_name[32] = {};\nstatic char ovr_name[32] = {};\nstatic char orig_name[32] = {};\nstatic int  ovr_samedir = 0;\n\nchar *user_io_make_filepath(const char *path, const char *filename)\n{\n\tstatic char filepath_store[1024];\n\tsnprintf(filepath_store, 1024, \"%s/%s\", path, filename);\n\treturn filepath_store;\n}\n\nvoid user_io_name_override(const char* name, int samedir)\n{\n\tsnprintf(ovr_name, sizeof(ovr_name), \"%s\", name);\n\tovr_samedir = samedir;\n}\n\nvoid user_io_set_core_name(const char *name)\n{\n\tsnprintf(core_name, sizeof(core_name), name);\n\tprintf(\"Core name set to \\\"%s\\\"\\n\", core_name);\n}\n\nchar *user_io_get_core_name(int orig)\n{\n\treturn orig ? orig_name : core_name;\n}\n\nchar *user_io_get_core_name2()\n{\n\treturn (ovr_name[0] && ovr_samedir) ? orig_name : core_name;\n}\n\nchar *user_io_get_core_path(const char *suffix, int recheck)\n{\n\tstatic char old_name[256] = {};\n\tstatic char tmp[1024] = {};\n\tchar *name = (ovr_name[0] && ovr_samedir) ? orig_name : core_name;\n\n\tif (!suffix) suffix = (!strcasecmp(name, \"minimig\")) ? \"Amiga\" : name;\n\tif (recheck || strcmp(old_name, suffix) || !tmp[0])\n\t{\n\t\tstrcpy(old_name, suffix);\n\t\tstrcpy(tmp, suffix);\n\t\tprefixGameDir(tmp, sizeof(tmp));\n\t}\n\n\treturn tmp;\n}\n\nstatic char is_arcade_type = 0;\nchar is_arcade()\n{\n\treturn is_arcade_type;\n}\n\nstatic int is_menu_type = 0;\nchar is_menu()\n{\n\tif (!is_menu_type) is_menu_type = strcasecmp(orig_name, \"MENU\") ? 2 : 1;\n\treturn (is_menu_type == 1);\n}\n\nstatic int is_x86_type = 0;\nchar is_x86()\n{\n\tif (!is_x86_type) is_x86_type = strcasecmp(orig_name, \"AO486\") ? 2 : 1;\n\treturn (is_x86_type == 1);\n}\n\nstatic int is_snes_type = 0;\nchar is_snes()\n{\n\tif (!is_snes_type) is_snes_type = strcasecmp(orig_name, \"SNES\") ? 2 : 1;\n\treturn (is_snes_type == 1);\n}\n\nstatic int is_sgb_type = 0;\nchar is_sgb()\n{\n\tif (!is_sgb_type) is_sgb_type = strcasecmp(orig_name, \"SGB\") ? 2 : 1;\n\treturn (is_sgb_type == 1);\n}\n\nstatic int is_cpc_type = 0;\nchar is_cpc()\n{\n\tif (!is_cpc_type) is_cpc_type = strcasecmp(orig_name, \"amstrad\") ? 2 : 1;\n\treturn (is_cpc_type == 1);\n}\n\nstatic int is_zx81_type = 0;\nchar is_zx81()\n{\n\tif (!is_zx81_type) is_zx81_type = strcasecmp(orig_name, \"zx81\") ? 2 : 1;\n\treturn (is_zx81_type == 1);\n}\n\nstatic int is_neogeo_type = 0;\nchar is_neogeo()\n{\n\tif (!is_neogeo_type) is_neogeo_type = strcasecmp(orig_name, \"neogeo\") ? 2 : 1;\n\treturn (is_neogeo_type == 1);\n}\n\nchar is_neogeo_cd() {\n    return is_neogeo() && neocd_is_en();\n}\n\nstatic int is_minimig_type = 0;\nchar is_minimig()\n{\n\tif (!is_minimig_type) is_minimig_type = strcasecmp(orig_name, \"minimig\") ? 2 : 1;\n\treturn (is_minimig_type == 1);\n}\n\nstatic int is_megacd_type = 0;\nchar is_megacd()\n{\n\tif (!is_megacd_type) is_megacd_type = strcasecmp(orig_name, \"MEGACD\") ? 2 : 1;\n\treturn (is_megacd_type == 1);\n}\n\nstatic int is_pce_type = 0;\nchar is_pce()\n{\n\tif (!is_pce_type) is_pce_type = strcasecmp(orig_name, \"TGFX16\") ? 2 : 1;\n\treturn (is_pce_type == 1);\n}\n\nstatic int is_archie_type = 0;\nchar is_archie()\n{\n\tif (!is_archie_type) is_archie_type = strcasecmp(orig_name, \"ARCHIE\") ? 2 : 1;\n\treturn (is_archie_type == 1);\n}\n\nstatic int is_pcxt_type = 0;\nchar is_pcxt()\n{\n\tif (!is_pcxt_type) is_pcxt_type = strcasecmp(orig_name, \"PCXT\") ? 2 : 1;\n\treturn (is_pcxt_type == 1);\n}\n\nstatic int is_gba_type = 0;\nchar is_gba()\n{\n\tif (!is_gba_type) is_gba_type = strcasecmp(orig_name, \"GBA\") ? 2 : 1;\n\treturn (is_gba_type == 1);\n}\n\nstatic int is_c64_type = 0;\nchar is_c64()\n{\n\tif (!is_c64_type) is_c64_type = strcasecmp(orig_name, \"C64\") ? 2 : 1;\n\treturn (is_c64_type == 1);\n}\n\nstatic int is_c128_type = 0;\nchar is_c128()\n{\n\tif (!is_c128_type) is_c128_type = strcasecmp(orig_name, \"C128\") ? 2 : 1;\n\treturn (is_c128_type == 1);\n}\n\nstatic int is_psx_type = 0;\nchar is_psx()\n{\n\tif (!is_psx_type) is_psx_type = strcasecmp(orig_name, \"PSX\") ? 2 : 1;\n\treturn (is_psx_type == 1);\n}\n\nstatic int is_cdi_type = 0;\nchar is_cdi()\n{\n\tif (!is_cdi_type) is_cdi_type = strcasecmp(orig_name, \"CD-i\") ? 2 : 1;\n\treturn (is_cdi_type == 1);\n}\n\nstatic int is_st_type = 0;\nchar is_st()\n{\n\tif (!is_st_type) is_st_type = strcasecmp(orig_name, \"AtariST\") ? 2 : 1;\n\treturn (is_st_type == 1);\n}\n\nchar is_sharpmz()\n{\n\treturn(core_type == CORE_TYPE_SHARPMZ);\n}\n\nstatic int is_electron_type = 0;\nchar is_electron()\n{\n\tif (!is_electron_type) is_electron_type = strcasecmp(orig_name, \"AcornElectron\") ? 2 : 1;\n\treturn (is_electron_type == 1);\n}\n\nstatic int is_saturn_type = 0;\nchar is_saturn()\n{\n\tif (!is_saturn_type) is_saturn_type = strcasecmp(orig_name, \"Saturn\") ? 2 : 1;\n\treturn (is_saturn_type == 1);\n}\n\nstatic int is_n64_type = 0;\nchar is_n64()\n{\n\tif (!is_n64_type) is_n64_type = strcasecmp(orig_name, \"N64\") ? 2 : 1;\n\treturn (is_n64_type == 1);\n}\n\nstatic int is_uneon_type = 0;\nchar is_uneon()\n{\n\tif (!is_uneon_type) is_uneon_type = strcasecmp(orig_name, \"Uneon\") ? 2 : 1;\n\treturn (is_uneon_type == 1);\n}\n\nstatic int is_no_type = 0;\nstatic int disable_osd = 0;\nchar has_menu()\n{\n\tif (disable_osd) return 0;\n\n\tif (!is_no_type) is_no_type = user_io_get_core_name()[0] ? 1 : 2;\n\treturn (is_no_type == 1);\n}\n\nvoid user_io_read_core_name()\n{\n\tis_menu_type = 0;\n\tis_x86_type  = 0;\n\tis_no_type   = 0;\n\tis_snes_type = 0;\n\tis_sgb_type = 0;\n\tis_cpc_type = 0;\n\tis_zx81_type = 0;\n\tis_neogeo_type = 0;\n\tis_minimig_type = 0;\n\tis_megacd_type = 0;\n\tis_pce_type = 0;\n\tis_archie_type = 0;\n\tis_gba_type = 0;\n\tis_c64_type = 0;\n\tis_c128_type = 0;\n\tis_st_type = 0;\n\tis_pcxt_type = 0;\n\tis_uneon_type = 0;\n\tcore_name[0] = 0;\n\n\tchar *p = user_io_get_confstr(0);\n\tif (p && p[0]) snprintf(orig_name, sizeof(orig_name), \"%s\", p);\n\n\t// get core name\n\tif (ovr_name[0]) strcpy(core_name, ovr_name);\n\telse if (orig_name[0]) strcpy(core_name, p);\n\n\tprintf(\"Core name is \\\"%s\\\"\\n\", core_name);\n}\n\nint substrcpy(char *d, const char *s, char idx)\n{\n\tchar p = 0;\n\tchar *b = d;\n\n\twhile (*s)\n\t{\n\t\tif ((p == idx) && *s && (*s != ',')) *d++ = *s;\n\n\t\tif (*s == ',')\n\t\t{\n\t\t\tif (p == idx) break;\n\t\t\tp++;\n\t\t}\n\n\t\ts++;\n\t}\n\n\t*d = 0;\n\treturn (int)(d - b);\n}\n\nstatic char cur_status[16] = {};\n\nint user_io_status_bits(const char *opt, int *s, int *e, int ex, int single)\n{\n\tuint32_t start = 0, end = 0;\n\tif (opt[0] == '[')\n\t{\n\t\tif (!single && sscanf(opt, \"[%u:%u]\", &end, &start) == 2)\n\t\t{\n\t\t\tif (start > 127 || end > 127 || end <= start) return 0;\n\t\t}\n\t\telse if (sscanf(opt, \"[%u]\", &start) == 1)\n\t\t{\n\t\t\tif (start > 127) return 0;\n\t\t\tend = start;\n\t\t}\n\t\telse return 0;\n\t}\n\telse\n\t{\n\t\tif ((opt[0] >= '0') && (opt[0] <= '9')) start = opt[0] - '0';\n\t\telse if ((opt[0] >= 'A') && (opt[0] <= 'V')) start = opt[0] - 'A' + 10;\n\t\telse return 0;\n\n\t\tif (!single && (opt[1] >= '0') && (opt[1] <= '9')) end = opt[1] - '0';\n\t\telse if (!single && (opt[1] >= 'A') && (opt[1] <= 'V')) end = opt[1] - 'A' + 10;\n\t\telse\n\t\t{\n\t\t\tsingle = 1;\n\t\t\tend = start;\n\t\t}\n\n\t\tif (ex)\n\t\t{\n\t\t\tstart += 32;\n\t\t\tend += 32;\n\t\t}\n\n\t\tif (start > 127 || end > 127 || (!single && end <= start)) return 0;\n\t}\n\n\t//max 8 bits per option\n\tif (end - start > 8) return 0;\n\n\tif (s) *s = (int)start;\n\tif (e) *e = (int)end;\n\treturn 1 + end - start;\n}\n\nuint32_t user_io_status_get(const char *opt, int ex)\n{\n\tint start, end;\n\tint size = user_io_status_bits(opt, &start, &end, ex);\n\tif (!size) return 0;\n\n\tuint32_t x = (cur_status[end / 8] << 8) | cur_status[start / 8];\n\tx >>= start % 8;\n\treturn x & ~(0xffffffff << size);\n}\n\nuint32_t user_io_status_mask(const char *opt)\n{\n\treturn ~(0xffffffff << user_io_status_bits(opt, 0, 0, 0));\n}\n\nuint32_t user_io_hd_mask(const char *opt)\n{\n\tint start;\n\tint size = user_io_status_bits(opt, &start, 0, 0, 1);\n\tif (!size) return 0;\n\treturn start;\n}\n\nvoid user_io_status_set(const char *opt, uint32_t value, int ex)\n{\n\tint start, end;\n\tint size = user_io_status_bits(opt, &start, &end, ex);\n\tif (!size) return;\n\n\tint s = start / 8;\n\tint e = end / 8;\n\n\tuint32_t mask = ~(0xffffffff << size);\n\tmask <<= start % 8;\n\tuint32_t x = (cur_status[e] << 8) | cur_status[s];\n\tx = (x & ~mask) | ((value << (start % 8)) & mask);\n\n\tcur_status[s] = (char)x;\n\tif (e != s) cur_status[e] = (char)(x >> 8);\n\n\tif (!is_st())\n\t{\n\t\tspi_uio_cmd_cont(UIO_SET_STATUS2);\n\t\tfor (uint32_t i = 0; i < sizeof(cur_status); i += 2) spi_w((cur_status[i + 1] << 8) | cur_status[i]);\n\t\tDisableIO();\n\t}\n}\n\nint user_io_status_save(const char *filename)\n{\n\treturn FileSaveConfig(filename, cur_status, sizeof(cur_status));\n}\n\nvoid user_io_status_reset()\n{\n\tmemset(cur_status, 0, sizeof(cur_status));\n\tuser_io_status_set(\"[0]\", 0);\n}\n\nstatic void set_kbd_led(int led, int state)\n{\n\tif (led & HID_LED_CAPS_LOCK)\n\t{\n\t\tcaps_status = state&HID_LED_CAPS_LOCK;\n\t\tif (!(keyboard_leds & KBD_LED_CAPS_CONTROL)) set_kbdled(led&HID_LED_CAPS_LOCK, caps_status);\n\t}\n\n\tif (led & HID_LED_NUM_LOCK)\n\t{\n\t\tnum_status = state&HID_LED_NUM_LOCK;\n\t\tif (!(keyboard_leds & KBD_LED_NUM_CONTROL)) set_kbdled(led&HID_LED_NUM_LOCK, num_status);\n\t}\n\n\tif (led & HID_LED_SCROLL_LOCK)\n\t{\n\t\tscrl_status = state&HID_LED_SCROLL_LOCK;\n\t\tif (!(keyboard_leds & KBD_LED_SCRL_CONTROL)) set_kbdled(led&HID_LED_SCROLL_LOCK, scrl_status);\n\t}\n}\n\nstatic void set_emu_mode(int mode)\n{\n\tuint8_t emu_led;\n\temu_mode = mode;\n\n\tswitch (emu_mode)\n\t{\n\tcase EMU_JOY0:\n\t\temu_led = 0x20;\n\t\tset_kbd_led(HID_LED_NUM_LOCK | HID_LED_SCROLL_LOCK, HID_LED_NUM_LOCK);\n\t\tInfo(\"Kbd mode: Joystick 1\", 1000);\n\t\tbreak;\n\n\tcase EMU_JOY1:\n\t\temu_led = 0x40;\n\t\tset_kbd_led(HID_LED_NUM_LOCK | HID_LED_SCROLL_LOCK, HID_LED_SCROLL_LOCK);\n\t\tInfo(\"Kbd mode: Joystick 2\", 1000);\n\t\tbreak;\n\n\tcase EMU_MOUSE:\n\t\temu_led = 0x60;\n\t\tset_kbd_led(HID_LED_NUM_LOCK | HID_LED_SCROLL_LOCK, HID_LED_NUM_LOCK | HID_LED_SCROLL_LOCK);\n\t\tInfo(\"Kbd mode: Mouse\", 1000);\n\t\tbreak;\n\n\tdefault:\n\t\temu_led = 0;\n\t\tset_kbd_led(HID_LED_NUM_LOCK | HID_LED_SCROLL_LOCK, 0);\n\t\tInfo(\"Kbd mode: Normal\", 1000);\n\t}\n\n\tspi_uio_cmd16(UIO_LEDS, 0x6000 | emu_led);\n\tinput_notify_mode();\n}\n\nint user_io_get_kbdemu()\n{\n\treturn emu_mode;\n}\n\nstatic int joy_force = 0;\n\n// Analog/Digital Joystick translation\n// 0 - translate Analog to Digital (default)\n// 1 - translate Digital to Analog\n// 2 - do not translate\nstatic int joy_transl = 0;\n\nint user_io_get_joy_transl()\n{\n\treturn joy_transl;\n}\n\nstatic int use_cheats = 0;\nstatic uint32_t ss_base = 0;\nstatic uint32_t ss_size = 0;\nstatic uint32_t uart_speeds[13] = {};\nstatic char uart_speed_labels[13][32] = {};\nstatic uint32_t midi_speeds[13] = {};\nstatic char midi_speed_labels[13][32] = {};\nstatic const uint32_t mlink_speeds[13] = { 110, 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 31250, 38400, 57600, 115200 };\nstatic const char mlink_speed_labels[13][32] = { \"110\", \"300\", \"600\", \"1200\", \"2400\", \"4800\", \"9600\", \"14400\", \"19200\", \"31250/MIDI\", \"38400\", \"57600\", \"115200\" };\nstatic char defmra[1024] = {};\nstatic int boot0_loaded = 0;\nstatic int boot0_mounted = 0;\n\nstatic void parse_config()\n{\n\tstatic char str[1024];\n\tstatic char ext[256];\n\n\tchar mask[sizeof(cur_status) * 8] = {};\n\tchar overlap[sizeof(cur_status) * 8] = {};\n\tint start, end, sz;\n\n\tint i = 0;\n\tchar *p;\n\n\tjoy_force = 0;\n\tjoy_bcount = 0;\n\n\tdo {\n\t\tp = user_io_get_confstr(i);\n\t\tprintf(\"get cfgstring %d = %s\\n\", i, p ? p : \"NULL\");\n\t\tif (!i)\n\t\t{\n\t\t\tOsdCoreNameSet((p && p[0]) ? p : \"CORE\");\n\t\t}\n\n\t\tif (i == 1 && p)\n\t\t{\n\t\t\twhile (p && *p)\n\t\t\t{\n\t\t\t\tif (!strncasecmp(p, \"SS\", 2))\n\t\t\t\t{\n\t\t\t\t\tchar *end = 0;\n\t\t\t\t\tss_base = strtoul(p+2, &end, 16);\n\t\t\t\t\tp = end;\n\t\t\t\t\tif (p && *p == ':')\n\t\t\t\t\t{\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tss_size = strtoul(p, &end, 16);\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"Got save state parameters: base=0x%X, size=0x%X\\n\", ss_base, ss_size);\n\n\t\t\t\t\tif (!ss_size || ss_size > (128 * 1024 * 1024))\n\t\t\t\t\t{\n\t\t\t\t\t\tss_size = 0;\n\t\t\t\t\t\tss_base = 0;\n\t\t\t\t\t\tprintf(\"Invalid size!\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (ss_base < 0x20000000 || ss_base >= 0x40000000 || (ss_base + ss_size) >= 0x40000000)\n\t\t\t\t\t{\n\t\t\t\t\t\tss_size = 0;\n\t\t\t\t\t\tss_base = 0;\n\t\t\t\t\t\tprintf(\"Invalid base!\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!strncasecmp(p, \"UART\", 4))\n\t\t\t\t{\n\t\t\t\t\tp += 4;\n\t\t\t\t\tfor (int i = 0; i < 10 && p && *p; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *end = 0;\n\t\t\t\t\t\tuart_speeds[i] = strtoul(p, &end, 10);\n\t\t\t\t\t\tp = end;\n\t\t\t\t\t\tif (p && *p == '(')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\tint n = 0;\n\t\t\t\t\t\t\twhile (*p != ';' && *p != ':' && *p != ')' && *p != ',')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (n < 16) uart_speed_labels[i][n] = *p;\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*p == ')') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(uart_speed_labels[i], \"%d\", uart_speeds[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p && *p == ':') p++;\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"Got UART speeds:\");\n\t\t\t\t\tfor(int i=0; i<10; i++) printf(\" %d\", uart_speeds[i]);\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\tif (!strncasecmp(p, \"MIDI\", 4))\n\t\t\t\t{\n\t\t\t\t\tp += 4;\n\t\t\t\t\tfor (int i = 0; i < 10 && p && *p; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *end = 0;\n\t\t\t\t\t\tmidi_speeds[i] = strtoul(p, &end, 10);\n\t\t\t\t\t\tp = end;\n\t\t\t\t\t\tif (p && *p == '(')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\tint n = 0;\n\t\t\t\t\t\t\twhile (*p != ';' && *p != ':' && *p != ')' && *p != ',')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (n < 16) midi_speed_labels[i][n] = *p;\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*p == ')') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(midi_speed_labels[i], \"%d\", midi_speeds[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p && *p == ':') p++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!midi_speeds[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tmidi_speeds[0] = 31250;\n\t\t\t\t\t\tstrcpy(midi_speed_labels[0], \"31250\");\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"Got MIDI speeds:\");\n\t\t\t\t\tfor (int i = 0; i < 10; i++) printf(\" %d\", midi_speeds[i]);\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\tp = strchr(p, ',');\n\t\t\t\tif (p) p++;\n\t\t\t}\n\t\t}\n\n\t\tif (i >= 2 && p && p[0])\n\t\t{\n\t\t\tif (!strncmp(p, \"DEFMRA,\", 7))\n\t\t\t{\n\t\t\t\tsnprintf(defmra, sizeof(defmra), (p[7] == '/') ? \"%s%s\" : \"%s/_Arcades/%s\", getRootDir(), p + 7);\n\t\t\t}\n\t\t\telse if (!strncmp(p, \"DIP\", 3))\n\t\t\t{\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//skip Disable/Hide masks\n\t\t\t\twhile ((p[0] == 'H' || p[0] == 'D' || p[0] == 'h' || p[0] == 'd') && strlen(p) >= 2) p += 2;\n\t\t\t}\n\t\t\tif (p[0] == 'P') p += 2;\n\n\t\t\tif (p[0] == 'R' || p[0] == 'T' || p[0] == 'r' || p[0] == 't')\n\t\t\t{\n\t\t\t\tsz = user_io_status_bits(p + 1, &start, &end, p[0] == 'r' || p[0] == 't');\n\t\t\t\tif (sz == 1)\n\t\t\t\t{\n\t\t\t\t\toverlap[start] |= mask[start];\n\t\t\t\t\tmask[start] |= 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Invalid OSD option: %s\\n\", p);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[0] == 'O' || p[0] == 'o')\n\t\t\t{\n\t\t\t\tchar *opt = (p[1] == 'X') ? (p + 2) : (p + 1);\n\t\t\t\tsz = user_io_status_bits(opt, &start, &end, p[0] == 'o');\n\t\t\t\tif (sz)\n\t\t\t\t{\n\t\t\t\t\twhile (sz)\n\t\t\t\t\t{\n\t\t\t\t\t\toverlap[start] |= mask[start];\n\t\t\t\t\t\tmask[start] |= 1;\n\t\t\t\t\t\tsz--;\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Invalid OSD option: %s\\n\", p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p[0] == 'J')\n\t\t\t{\n\t\t\t\tint n = 1;\n\t\t\t\tif (p[1] == 'D') { joy_transl = 0; n++; }\n\t\t\t\tif (p[1] == 'A') { joy_transl = 1; n++; }\n\t\t\t\tif (p[1] == 'N') { joy_transl = 2; n++; }\n\n\t\t\t\tif (p[n] == '1')\n\t\t\t\t{\n\t\t\t\t\tjoy_force = 1;\n\t\t\t\t\tset_emu_mode(EMU_JOY0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p[0] == 'O' && p[1] == 'X')\n\t\t\t{\n\t\t\t\tint x = user_io_status_get(p + 2);\n\t\t\t\tprintf(\"found OX option: %s: %d\\n\", p, x);\n\n\t\t\t\tif (is_x86())\n\t\t\t\t{\n\t\t\t\t\tif (p[2] == '2') x86_set_fdd_boot(!(x & 1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p[0] == 'X')\n\t\t\t{\n\t\t\t\tdisable_osd = 1;\n\t\t\t}\n\n\t\t\tif (p[0] == 'V')\n\t\t\t{\n\t\t\t\t// get version string\n\t\t\t\tchar s[128];\n\t\t\t\tstrcpy(s, OsdCoreNameGet());\n\t\t\t\tstrcat(s, \" \");\n\t\t\t\tsubstrcpy(s + strlen(s), p, 1);\n\t\t\t\tOsdCoreNameSet(s);\n\t\t\t}\n\n\t\t\tif (p[0] == 'v')\n\t\t\t{\n\t\t\t\tstatic char str[256];\n\t\t\t\tsubstrcpy(str, p, 1);\n\t\t\t\tstr[2] = 0;\n\t\t\t\tint v = strtoul(str, 0, 10);\n\t\t\t\tif(v) snprintf(config_ver, sizeof(config_ver), \"_v%d\", v);\n\t\t\t}\n\n\t\t\tif (p[0] == 'C')\n\t\t\t{\n\t\t\t\tuse_cheats = 1;\n\t\t\t}\n\n\t\t\tif (p[0] == 'F')\n\t\t\t{\n\t\t\t\tint opensave = 0;\n\t\t\t\tint idx = 1;\n\t\t\t\tif (p[idx] == 'S')\n\t\t\t\t{\n\t\t\t\t\topensave = 1;\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\n\t\t\t\tif (p[idx] == 'C')\n\t\t\t\t{\n\t\t\t\t\tidx++;\n\t\t\t\t\tuint32_t load_addr = 0;\n\t\t\t\t\tif (substrcpy(str, p, 3))\n\t\t\t\t\t{\n\t\t\t\t\t\tload_addr = strtoul(str, NULL, 16);\n\t\t\t\t\t\tif (load_addr < 0x20000000 || load_addr >= 0x40000000)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"Loading address 0x%X is outside the supported range! Using normal load.\\n\", load_addr);\n\t\t\t\t\t\t\tload_addr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsprintf(str, \"%s.f%c\", user_io_get_core_name(), p[idx]);\n\t\t\t\t\tsubstrcpy(ext, p, 1);\n\t\t\t\t\twhile (strlen(ext) % 3) strcat(ext, \" \");\n\n\t\t\t\t\tif (FileLoadConfig(str, str, sizeof(str)) && str[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tidx = p[idx] - '0';\n\t\t\t\t\t\tStoreIdx_F(idx, str);\n\t\t\t\t\t\tuser_io_file_tx(str, (user_io_ext_idx(str, ext) << 6) | idx, opensave, 0, 0, load_addr);\n\t\t\t\t\t\tif (!idx) boot0_loaded = 1;\n\n\t\t\t\t\t\tif (is_cpc())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *p = strrchr(str, '.');\n\t\t\t\t\t\t\tif (p && (!strcasecmp(p, \".eZZ\") || !strcasecmp(p, \".eZ0\"))) boot0_loaded = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p[0] == 'S' && p[1] == 'C')\n\t\t\t{\n\t\t\t\tsprintf(str, \"%s.s%c\", user_io_get_core_name(), p[2]);\n\n\t\t\t\tsubstrcpy(ext, p, 1);\n\t\t\t\twhile (strlen(ext) % 3) strcat(ext, \" \");\n\n\t\t\t\tif (FileLoadConfig(str, str, sizeof(str)) && str[0])\n\t\t\t\t{\n\t\t\t\t\tint idx = p[2] - '0';\n\t\t\t\t\tStoreIdx_S(idx, str);\n\t\t\t\t\tif (is_x86() || is_pcxt() || (is_uneon() && idx >= 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tx86_set_image(idx, str);\n\t\t\t\t\t}\n\t\t\t\t\telse if (is_megacd())\n\t\t\t\t\t{\n\t\t\t\t\t\tmcd_set_image(idx, str);\n\t\t\t\t\t}\n\t\t\t\t\telse if (is_pce())\n\t\t\t\t\t{\n\t\t\t\t\t\tpcecd_set_image(idx, str);\n\t\t\t\t\t\tcheats_init(str, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!is_c128()) user_io_set_index((user_io_ext_idx(str, ext) << 6) | idx);\n\t\t\t\t\t\tuser_io_file_mount(str, idx);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!idx) boot0_mounted = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++;\n\t} while (p || i<3);\n\n\tmask[0] = 1; // reset is always on bit 0\n\tprintf(\"\\n// Status Bit Map:\\n\");\n\tprintf(\"//              Upper                          Lower\\n\");\n\tprintf(\"// 0         1         2         3          4         5         6   \\n\");\n\tprintf(\"// 01234567890123456789012345678901 23456789012345678901234567890123\\n\");\n\tprintf(\"// 0123456789ABCDEFGHIJKLMNOPQRSTUV 0123456789ABCDEFGHIJKLMNOPQRSTUV\\n\");\n\tstrcpy(str, \"// \");\n\tfor (int i = 0; i < 32; i++) strcat(str, mask[i] ? \"X\" : \" \");\n\tstrcat(str, \" \");\n\tfor (int i = 32; i < 64; i++) strcat(str, mask[i] ? \"X\" : \" \");\n\tstrcat(str, \"\\n\");\n\tprintf(str);\n\n\tint ovr = 0;\n\tfor (int i = 0; i < 64; i++) ovr |= overlap[i];\n\n\tif (ovr)\n\t{\n\t\tstrcpy(str, \"// \");\n\t\tfor (int i = 0; i < 32; i++) strcat(str, overlap[i] ? \"^\" : \" \");\n\t\tstrcat(str, \" \");\n\t\tfor (int i = 32; i < 64; i++) strcat(str, overlap[i] ? \"^\" : \" \");\n\t\tstrcat(str, \"\\n\");\n\t\tprintf(str);\n\t\tprintf(\"// *Overlapped bits!* (can be intentional)\\n\");\n\t}\n\tprintf(\"\\n\");\n\n\tovr = 0;\n\tfor (int i = 64; i < 128; i++) ovr |= mask[i];\n\n\tif (ovr)\n\t{\n\t\tprintf(\"// 0     0         0         0          1         1         1       \\n\");\n\t\tprintf(\"// 6     7         8         9          0         1         2       \\n\");\n\t\tprintf(\"// 45678901234567890123456789012345 67890123456789012345678901234567\\n\");\n\t\tstrcpy(str, \"// \");\n\t\tfor (int i = 64; i < 96; i++) strcat(str, mask[i] ? \"X\" : \" \");\n\t\tstrcat(str, \" \");\n\t\tfor (int i = 96; i < 128; i++) strcat(str, mask[i] ? \"X\" : \" \");\n\t\tstrcat(str, \"\\n\");\n\t\tprintf(str);\n\n\t\tovr = 0;\n\t\tfor (int i = 64; i < 128; i++) ovr |= overlap[i];\n\n\t\tif (ovr)\n\t\t{\n\t\t\tstrcpy(str, \"// \");\n\t\t\tfor (int i = 64; i < 96; i++) strcat(str, overlap[i] ? \"^\" : \" \");\n\t\t\tstrcat(str, \" \");\n\t\t\tfor (int i = 96; i < 128; i++) strcat(str, overlap[i] ? \"^\" : \" \");\n\t\t\tstrcat(str, \"\\n\");\n\t\t\tprintf(str);\n\t\t\tprintf(\"// *Overlapped bits!* (can be intentional)\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\t// legacy GBA versions\n\tif (is_gba() && !ss_base)\n\t{\n\t\tss_base = 0x3E000000;\n\t\tss_size = 0x100000;\n\t}\n}\n\n//MSM6242B layout\nstatic void send_rtc(int type)\n{\n\t//printf(\"Update RTC\\n\");\n\n\ttime_t t = time(NULL);\n\n\tif (type & 1)\n\t{\n\t\tstruct tm tm = *localtime(&t);\n\n\t\tuint8_t rtc[8];\n\t\trtc[0] = (tm.tm_sec % 10) | ((tm.tm_sec / 10) << 4);\n\t\trtc[1] = (tm.tm_min % 10) | ((tm.tm_min / 10) << 4);\n\t\trtc[2] = (tm.tm_hour % 10) | ((tm.tm_hour / 10) << 4);\n\t\trtc[3] = (tm.tm_mday % 10) | ((tm.tm_mday / 10) << 4);\n\n\t\trtc[4] = ((tm.tm_mon + 1) % 10) | (((tm.tm_mon + 1) / 10) << 4);\n\t\trtc[5] = (tm.tm_year % 10) | (((tm.tm_year / 10) % 10) << 4);\n\t\trtc[6] = tm.tm_wday;\n\t\trtc[7] = 0x40;\n\n\t\tspi_uio_cmd_cont(UIO_RTC);\n\t\tspi_w((rtc[1] << 8) | rtc[0]);\n\t\tspi_w((rtc[3] << 8) | rtc[2]);\n\t\tspi_w((rtc[5] << 8) | rtc[4]);\n\t\tspi_w((rtc[7] << 8) | rtc[6]);\n\t\tDisableIO();\n\t}\n\n\tif (type & 2)\n\t{\n\t\tt += t - mktime(gmtime(&t));\n\n\t\tspi_uio_cmd_cont(UIO_TIMESTAMP);\n\t\tspi_w(t);\n\t\tspi_w(t >> 16);\n\t\tDisableIO();\n\t}\n}\n\nconst char* get_rbf_dir()\n{\n\tstatic char str[1024];\n\n\tconst char *root = getRootDir();\n\tint len = strlen(root);\n\tif (!strlen(core_path) || strncmp(root, core_path, len)) return \"\";\n\n\tstrcpy(str, core_path + len + 1);\n\tchar *p = strrchr(str, '/');\n\tif (!p) return \"\";\n\t*p = 0;\n\treturn str;\n}\n\nconst char* get_rbf_name()\n{\n\tif (!strlen(core_path)) return \"\";\n\tchar *p = strrchr(core_path, '/');\n\tif (!p) return core_path;\n\treturn p+1;\n}\n\nconst char* get_rbf_path()\n{\n\treturn core_path;\n}\n\nvoid MakeFile(const char *filename, const char *data)\n{\n\tFILE * file;\n\tfile = fopen(filename, \"w\");\n\tfwrite(data, strlen(data), 1, file);\n\tfclose(file);\n}\n\nint GetUARTMode()\n{\n\tstruct stat filestat;\n\tif (!stat(\"/tmp/uartmode1\", &filestat)) return 1;\n\tif (!stat(\"/tmp/uartmode2\", &filestat)) return 2;\n\tif (!stat(\"/tmp/uartmode3\", &filestat)) return 3;\n\tif (!stat(\"/tmp/uartmode4\", &filestat)) return 4;\n\tif (!stat(\"/tmp/uartmode5\", &filestat)) return 5;\n\treturn 0;\n}\n\nvoid SetUARTMode(int mode)\n{\n\tmode &= 0xF;\n\tuint32_t baud = GetUARTbaud(mode);\n\n\tspi_uio_cmd_cont(UIO_SET_UART);\n\tspi_w((mode == 4 || mode == 5) ? 1 : mode);\n\tspi_w(baud);\n\tspi_w(baud >> 16);\n\tDisableIO();\n\n\tMakeFile(\"/tmp/CORENAME\", user_io_get_core_name());\n    MakeFile(\"/tmp/RBFNAME\", user_io_get_core_name(1));\n\n\tchar data[20];\n\tsprintf(data, \"%d\", baud);\n\tMakeFile(\"/tmp/UART_SPEED\", data);\n\n\tchar cmd[32];\n\tsprintf(cmd, \"uartmode %d\", mode);\n\tsystem(cmd);\n}\n\nstatic int uart_speed_idx = 0;\nstatic int midi_speed_idx = 0;\nstatic int mlink_speed_idx = 0;\n\nconst uint32_t* GetUARTbauds(int mode)\n{\n\treturn (mode == 3) ? midi_speeds : (mode > 3) ? mlink_speeds : uart_speeds;\n}\n\nuint32_t GetUARTbaud(int mode)\n{\n\treturn (mode == 3) ? midi_speeds[midi_speed_idx] : (mode > 3) ? mlink_speeds[mlink_speed_idx] : uart_speeds[uart_speed_idx];\n}\n\nconst char* GetUARTbaud_label(int mode)\n{\n\treturn (mode == 3) ? midi_speed_labels[midi_speed_idx] : (mode > 3) ? mlink_speed_labels[mlink_speed_idx] : uart_speed_labels[uart_speed_idx];\n}\n\nconst char* GetUARTbaud_label(int mode, int idx)\n{\n\treturn (mode == 3) ? midi_speed_labels[idx] : (mode > 3) ? mlink_speed_labels[idx] : uart_speed_labels[idx];\n}\n\nint GetUARTbaud_idx(int mode)\n{\n\treturn (mode == 3) ? midi_speed_idx : (mode > 3) ? mlink_speed_idx : uart_speed_idx;\n}\n\nchar * GetMidiLinkSoundfont()\n{\n    FILE * file;\n    static char mLinkSoundfont[255];\n    char fileName[] = \"/tmp/ML_SOUNDFONT\";\n    char strip[] = \"/media/fat/\";\n    file = fopen(fileName, \"r\");\n    if (file)\n    {\n        fgets((char *) &mLinkSoundfont, sizeof(mLinkSoundfont), file);\n        fclose(file);\n        if(0 == strncmp(strip, mLinkSoundfont, sizeof(strip)-1))\n\t\treturn &mLinkSoundfont[sizeof(strip)-1];\n    }\n    else\n    {\n        printf(\"ERROR: GetMidiLinkSoundfont : Unable to open --> '%s'\\n\", fileName);\n        sprintf(mLinkSoundfont, \"linux/soundfonts\");\n    }\n    return mLinkSoundfont;\n}\n\nuint32_t ValidateUARTbaud(int mode, uint32_t baud)\n{\n\tconst uint32_t *bauds = GetUARTbauds(mode);\n\tint idx = 0;\n\tfor (int i = 0; i < 13; i++)\n\t{\n\t\tif (!bauds[i]) break;\n\t\tif (bauds[i] == baud)\n\t\t{\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mode == 3) midi_speed_idx = idx;\n\telse if (mode > 3) mlink_speed_idx = idx;\n\telse uart_speed_idx = idx;\n\n\treturn bauds[idx];\n}\n\nint GetMidiLinkMode()\n{\n\tstruct stat filestat;\n\tif (!stat(\"/tmp/ML_FSYNTH\", &filestat))  return 0;\n\tif (!stat(\"/tmp/ML_MUNT\", &filestat))    return 1;\n\tif (!stat(\"/tmp/ML_USBMIDI\", &filestat)) return 2;\n\tif (!stat(\"/tmp/ML_UDP\", &filestat))     return 3;\n\tif (!stat(\"/tmp/ML_TCP\", &filestat))     return 4;\n\tif (!stat(\"/tmp/ML_UDP_ALT\", &filestat)) return 5;\n\tif (!stat(\"/tmp/ML_USBSER\", &filestat))  return 6;\n\treturn 0;\n}\n\nvoid SetMidiLinkMode(int mode)\n{\n\tremove(\"/tmp/ML_FSYNTH\");\n\tremove(\"/tmp/ML_MUNT\");\n\tremove(\"/tmp/ML_UDP\");\n\tremove(\"/tmp/ML_USBMIDI\");\n\tremove(\"/tmp/ML_UDP_ALT\");\n\tremove(\"/tmp/ML_TCP_ALT\");\n\tremove(\"/tmp/ML_SERMIDI\");\n\tremove(\"/tmp/ML_USBSER\");\n\tremove(\"/tmp/ML_TCP\");\n\n\tstruct stat filestat;\n\tif (mode == 6 && stat(\"/dev/ttyUSB0\", &filestat)) mode = 4;\n\n\tswitch (mode)\n\t{\n\t\tcase 0: MakeFile(\"/tmp/ML_FSYNTH\", \"\");  break;\n\t\tcase 1: MakeFile(\"/tmp/ML_MUNT\", \"\");    break;\n\t\tcase 2: MakeFile(\"/tmp/ML_USBMIDI\", \"\"); break;\n\t\tcase 3: MakeFile(\"/tmp/ML_UDP\", \"\");     break;\n\t\tcase 4: MakeFile(\"/tmp/ML_TCP\", \"\");     break;\n\t\tcase 5: MakeFile(\"/tmp/ML_UDP_ALT\", \"\"); break;\n\t\tcase 6: MakeFile(\"/tmp/ML_USBSER\", \"\");  break;\n\t}\n}\n\nvoid ResetUART()\n{\n\tif (uart_mode)\n\t{\n\t\tint mode = GetUARTMode();\n\t\tif (mode != 0)\n\t\t{\n\t\t\tSetUARTMode(0);\n\t\t\tSetUARTMode(mode);\n\t\t}\n\t}\n}\n\nuint16_t sdram_sz(int sz)\n{\n\tint res = 0;\n\n\tvoid* buf = shmem_map(0x1FFFF000, 0x1000);\n\tif (!buf) return 0;\n\n\tvolatile uint8_t* par = (volatile uint8_t*)buf;\n\tpar += 0xF00;\n\tif (sz >= 0)\n\t{\n\t\t*par++ = 0x12;\n\t\t*par++ = 0x57;\n\t\t*par++ = (uint8_t)(sz >> 8);\n\t\t*par++ = (uint8_t)sz;\n\t}\n\telse\n\t{\n\t\tif ((par[0] == 0x12) && (par[1] == 0x57))\n\t\t{\n\t\t\tres = 0x8000 | (par[2] << 8) | par[3];\n\t\t\tif(res & 0x4000) printf(\"*** Debug phase: %d\\n\", (res & 0x100) ? (res & 0xFF) : -(res & 0xFF));\n\t\t\telse printf(\"*** Found SDRAM config: %d\\n\", res & 7);\n\t\t}\n\t\telse if(!is_menu())\n\t\t{\n\t\t\tprintf(\"*** SDRAM config not found\\n\");\n\t\t}\n\t}\n\n\tshmem_unmap(buf, 0x1000);\n\treturn res;\n}\n\nuint16_t altcfg(int alt)\n{\n\tint res = 0;\n\n\tvoid* buf = shmem_map(0x1FFFF000, 0x1000);\n\tif (!buf) return 0;\n\n\tvolatile uint8_t* par = (volatile uint8_t*)buf;\n\tpar += 0xF04;\n\tif (alt >= 0)\n\t{\n\t\t*par++ = 0x34;\n\t\t*par++ = 0x99;\n\t\t*par++ = 0xBA;\n\t\t*par++ = (uint8_t)alt;\n\t\tprintf(\"** altcfg(%d)\\n\", alt);\n\t}\n\telse\n\t{\n\t\tif ((par[0] == 0x34) && (par[1] == 0x99) && (par[2] == 0xBA))\n\t\t{\n\t\t\tres = par[3];\n\t\t\tprintf(\"** altcfg: got cfg %d\\n\", res);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"** altcfg: no cfg\\n\");\n\t\t}\n\t}\n\n\tshmem_unmap(buf, 0x1000);\n\treturn res;\n}\n\nint user_io_is_dualsdr()\n{\n\treturn dual_sdr;\n}\n\nint user_io_get_width()\n{\n\treturn fio_size;\n}\n\nvoid user_io_init(const char *path, const char *xml)\n{\n\tchar *name;\n\tstatic char mainpath[512];\n\tcore_name[0] = 0;\n\tdisable_osd = 0;\n\n\t// we need to set the directory to where the XML file (MRA) is\n\t// not the RBF. The RBF will be in arcade, which the user shouldn't\n\t// browse\n\tstrcpy(core_path, xml ? xml : path);\n\tstrcpy(rbf_path, path);\n\n\tmemset(sd_image, 0, sizeof(sd_image));\n\n\tcore_type = (fpga_core_id() & 0xFF);\n\tfio_size = fpga_get_fio_size();\n\tio_ver = fpga_get_io_version();\n\tprintf(\"I/O Board type: %s\\n\", fpga_get_io_type() ? \"digital\" : \"analogue\");\n\n\tif (core_type == CORE_TYPE_8BIT2)\n\t{\n\t\tdual_sdr = 1;\n\t\tcore_type = CORE_TYPE_8BIT;\n\t}\n\n\tif ((core_type != CORE_TYPE_8BIT) &&\n\t\t(core_type != CORE_TYPE_SHARPMZ))\n\t{\n\t\tcore_type = CORE_TYPE_UNKNOWN;\n\t\tfio_size = 0;\n\t\tio_ver = 0;\n\t}\n\n\tOsdSetSize(8);\n\n\tif (xml)\n\t{\n\t\tif (isXmlName(xml) == 1) is_arcade_type = 1;\n\t\tarcade_pre_parse(xml);\n\t}\n\n\tif (core_type == CORE_TYPE_8BIT)\n\t{\n\t\tprintf(\"Identified 8BIT core\");\n\t\tspi_uio_cmd16(UIO_SET_MEMSZ, sdram_sz(-1));\n\n\t\t// send a reset\n\t\tuser_io_status_set(\"[0]\", 1);\n\t}\n\telse if (core_type == CORE_TYPE_SHARPMZ)\n\t{\n\t\tuser_io_set_core_name(\"sharpmz\");\n\t}\n\n\tuser_io_read_confstr();\n\tuser_io_read_core_name();\n\n\tif ((fpga_get_buttons() & BUTTON_OSD) && is_menu())\n\t{\n\t\taltcfg(0);\n\t\tSelectINI();\n\t}\n\n\tcfg_parse();\n\tcfg_print();\n\twhile (cfg.waitmount[0] && !is_menu())\n\t{\n\t\tprintf(\"> > > wait for %s mount < < <\\n\", cfg.waitmount);\n\t\tstatic char str[256];\n\t\tsnprintf(str, sizeof(str), \"exit $(mount | grep \\\"%s\\\" | wc -c)\", cfg.waitmount);\n\t\tint ret = system(str);\n\t\tif (!(ret & 0xFF) && ret) break;\n\t\tsleep(1);\n\t}\n\n\tconst char *main = getFullPath(cfg.main);\n\tif (strcasecmp(main, getappname()) && FileExists(main))\n\t{\n\t\tprintf(\"Current exec is %s, core requires exec %s\\n\", getappname(), main);\n\t\tapp_restart(path, xml, main);\n\t}\n\n\tuint8_t hotswap[4] = {};\n\tide_reset(hotswap);\n\n\tparse_config();\n\tif (!xml && defmra[0] && FileExists(defmra))\n\t{\n\t\t// attn: FC option won't use name from defmra!\n\t\t// attn: cfg is parsed before defmra, no defmra-name specifics possible in INI!\n\t\txml = (const char*)defmra;\n\t\tstrcpy(core_path, xml);\n\t\tis_arcade_type = 1;\n\t\tarcade_pre_parse(xml);\n\t\tuser_io_read_core_name();\n\t\tprintf(\"Using default MRA: %s\\n\", xml);\n\t}\n\n\tif (cfg.log_file_entry) MakeFile(\"/tmp/STARTPATH\", core_path);\n\n\tif (cfg.bootcore[0] != '\\0')\n\t{\n\t\tbootcore_init(xml ? xml : path);\n\t}\n\n\tvideo_init();\n\tif (strlen(cfg.font)) LoadFont(cfg.font);\n\tload_volume();\n\n\tuser_io_send_buttons(1);\n\tif (xml && isXmlName(xml) == 2) mgl_parse(xml);\n\n\tswitch (core_type)\n\t{\n\tcase CORE_TYPE_UNKNOWN:\n\t\tprintf(\"Unable to identify core (%x)!\\n\", core_type);\n\t\tbreak;\n\n\tcase CORE_TYPE_SHARPMZ:\n\t\tprintf(\"Identified Sharp MZ Series core\");\n\t\tuser_io_set_core_name(\"sharpmz\");\n\t\tsharpmz_init();\n\t\tparse_buttons();\n\t\tbreak;\n\n\tcase CORE_TYPE_8BIT:\n\t\t// try to load config\n\t\tname = user_io_create_config_name(1);\n\t\tif (strlen(name) > 0)\n\t\t{\n\t\t\tif (!is_st() && !is_minimig())\n\t\t\t{\n\t\t\t\tprintf(\"Loading config %s\\n\", name);\n\t\t\t\tmemset(cur_status, 0, sizeof(cur_status));\n\t\t\t\tif (FileLoadConfig(name, cur_status, sizeof(cur_status)))\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Found config:\\n\");\n\t\t\t\t\thexdump(cur_status, sizeof(cur_status));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmemset(cur_status, 0, sizeof(cur_status));\n\t\t\t\t}\n\n\t\t\t\tuser_io_status_set(\"[0]\", 1);\n\t\t\t}\n\n\t\t\tname = user_io_create_config_name();\n\t\t\tif (is_st())\n\t\t\t{\n\t\t\t\ttos_config_load(0);\n\t\t\t\ttos_upload(NULL);\n\t\t\t}\n\t\t\telse if (is_menu())\n\t\t\t{\n\t\t\t\tuser_io_status_set(\"[4]\", (cfg.menu_pal) ? 1 : 0);\n\t\t\t\tif (cfg.fb_terminal) video_menu_bg(user_io_status_get(\"[3:1]\"));\n\t\t\t\telse user_io_status_set(\"[3:1]\", 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (xml && isXmlName(xml) == 1)\n\t\t\t\t{\n\t\t\t\t\tarcade_send_rom(xml);\n\t\t\t\t}\n\t\t\t\telse if (is_minimig())\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Identified Minimig V2 core\");\n\t\t\t\t\tBootInit();\n\t\t\t\t}\n\t\t\t\telse if (is_x86() || is_pcxt())\n\t\t\t\t{\n\t\t\t\t\tx86_config_load();\n\t\t\t\t\tx86_init();\n\t\t\t\t}\n\t\t\t\telse if (is_archie())\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Identified Archimedes core\");\n\t\t\t\t\tarchie_init();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst char *home = HomeDir();\n\n\t\t\t\t\tif (is_uneon()) x86_ide_set();\n\n\t\t\t\t\tif (!strlen(path) || !user_io_file_tx(path, 0, 0, 0, 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!is_cpc())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// check for multipart rom\n\t\t\t\t\t\t\tfor (char i = (boot0_loaded ? 1 : 0); i < 4; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsprintf(mainpath, \"%s/boot%d.rom\", home, i);\n\t\t\t\t\t\t\t\tuser_io_file_tx(mainpath, i << 6);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// legacy style of rom\n\t\t\t\t\t\tif (!boot0_loaded)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(mainpath, \"%s/boot.rom\", home);\n\t\t\t\t\t\t\tif (!user_io_file_tx(mainpath))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstrcpy(name + strlen(name) - 3, \"ROM\");\n\t\t\t\t\t\t\t\tsprintf(mainpath, \"%s/%s\", get_rbf_dir(), name);\n\t\t\t\t\t\t\t\tif (!get_rbf_dir()[0] || !user_io_file_tx(mainpath))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (!user_io_file_tx(name))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tsprintf(mainpath, \"bootrom/%s\", name);\n\t\t\t\t\t\t\t\t\t\tuser_io_file_tx(mainpath);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// cheats for boot file\n\t\t\t\t\t\tif (user_io_use_cheats()) cheats_init(\"\", user_io_get_file_crc());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_cpc())\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int m = 0; m < 3; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst char *model = !m ? \"\" : (m == 1) ? \"0\" : \"1\";\n\t\t\t\t\t\t\tsprintf(mainpath, \"%s/boot%s.eZZ\", home, model);\n\t\t\t\t\t\t\tuser_io_file_tx(mainpath, 0x40 * (m + 1), 0, 1);\n\t\t\t\t\t\t\tsprintf(mainpath, \"%s/boot%s.eZ0\", home, model);\n\t\t\t\t\t\t\tuser_io_file_tx(mainpath, 0x40 * (m + 1), 0, 1);\n\t\t\t\t\t\t\tfor (int i = 0; i < 256; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsprintf(mainpath, \"%s/boot%s.e%02X\", home, model, i);\n\t\t\t\t\t\t\t\tuser_io_file_tx(mainpath, 0x40 * (m + 1), 0, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if vhd present\n\t\t\t\t\tfor (char i = (boot0_mounted ? 1 : 0); i < 4; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(mainpath, \"%s/boot%d.vhd\", home, i);\n\t\t\t\t\t\tif (FileExists(mainpath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser_io_set_index(i << 6);\n\t\t\t\t\t\t\tuser_io_file_mount(mainpath, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!boot0_mounted)\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(mainpath, \"%s/boot.vhd\", home);\n\t\t\t\t\t\tif (FileExists(mainpath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser_io_set_index(0);\n\t\t\t\t\t\t\tuser_io_file_mount(mainpath, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrcpy(name + strlen(name) - 3, \"VHD\");\n\t\t\t\t\t\t\tsprintf(mainpath, \"%s/%s\", get_rbf_dir(), name);\n\t\t\t\t\t\t\tif (FileExists(mainpath))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuser_io_set_index(0);\n\t\t\t\t\t\t\t\tuser_io_file_mount(mainpath, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (FileExists(name))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuser_io_set_index(0);\n\t\t\t\t\t\t\t\tuser_io_file_mount(name, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparse_buttons();\n\t\t}\n\n\t\tsend_rtc(3);\n\n\t\t// release reset\n\t\tif (!is_minimig() && !is_st()) user_io_status_set(\"[0]\", 0);\n\t\tif (xml && isXmlName(xml) == 1) arcade_check_error();\n\n\t\tchar cfg_errs[512];\n\t\tif (cfg_check_errors(cfg_errs, sizeof(cfg_errs)))\n\t\t{\n\t\t\tInfo(cfg_errs, 5000);\n\t\t\tsleep(5);\n\t\t}\n\t\tbreak;\n\t}\n\n\tOsdRotation((cfg.osd_rotate == 1) ? 3 : (cfg.osd_rotate == 2) ? 1 : 0);\n\n\tuart_mode = spi_uio_cmd16(UIO_GETUARTFLG, 0) || uart_speeds[0];\n\tuint32_t mode = 0;\n\tif (uart_mode)\n\t{\n\t\tif (!uart_speeds[0])\n\t\t{\n\t\t\tuart_speeds[0] = is_st() ? 19200 : 115200;\n\t\t\tsprintf(uart_speed_labels[0], \"%d\", uart_speeds[0]);\n\n\t\t\tif (!midi_speeds[0])\n\t\t\t{\n\t\t\t\tmidi_speeds[0] = 31250;\n\t\t\t\tsprintf(midi_speed_labels[0], \"%d\", midi_speeds[0]);\n\t\t\t}\n\t\t}\n\n\t\tsprintf(mainpath, \"uartmode.%s\", user_io_get_core_name());\n\t\tFileLoadConfig(mainpath, &mode, 4);\n\n\t\tuint32_t speeds[3] = {};\n\t\tsprintf(mainpath, \"uartspeed.%s\", user_io_get_core_name());\n\t\tFileLoadConfig(mainpath, speeds, sizeof(speeds));\n\n\t\tValidateUARTbaud(1, speeds[0]);\n\t\tValidateUARTbaud(3, speeds[1]);\n\t\tValidateUARTbaud(4, speeds[2] ? speeds[2] : uart_speeds[0]);\n\n\t\tprintf(\"UART bauds: %d/%d/%d\\n\", GetUARTbaud(1), GetUARTbaud(3), GetUARTbaud(4));\n\t}\n\n\tSetUARTMode(0);\n\tint midilink = (mode >> 8) & 0xFF;\n\tint uartmode = mode & 0xFF;\n\tif (uartmode == 4 && (midilink < 4 || midilink>6)) midilink = 4;\n\tif (uartmode == 3 && midilink > 3) midilink = 0;\n\tif (uartmode < 3 || uartmode > 4) midilink = 0;\n\tSetMidiLinkMode(midilink);\n\tSetUARTMode(uartmode);\n\n\tif (!mgl_get()->count || is_menu() || is_st() || is_archie() || user_io_core_type() == CORE_TYPE_SHARPMZ)\n\t{\n\t\tmgl_get()->done = 1;\n\t}\n\telse\n\t{\n\t\tmgl_get()->timer = GetTimer(mgl_get()->item[0].delay * 1000);\n\t}\n}\n\nstatic int joyswap = 0;\nvoid user_io_set_joyswap(int swap)\n{\n\tjoyswap = swap;\n}\n\nint user_io_get_joyswap()\n{\n\treturn joyswap;\n}\n\nvoid user_io_l_analog_joystick(unsigned char joystick, char valueX, char valueY)\n{\n\tuint8_t joy = (joystick > 1 || !joyswap) ? joystick : (joystick >= 15) ? (joystick ^ 16) : (joystick ^ 1);\n\n\tif (core_type == CORE_TYPE_8BIT)\n\t{\n\t\tspi_uio_cmd8_cont(UIO_ASTICK, joy);\n\t\tif(io_ver) spi_w((valueY << 8) | (uint8_t)(valueX));\n\t\telse\n\t\t{\n\t\t\tspi8(valueX);\n\t\t\tspi8(valueY);\n\t\t}\n\t\tDisableIO();\n\t}\n}\n\nvoid user_io_r_analog_joystick(unsigned char joystick, char valueX, char valueY)\n{\n\tuint8_t joy = (joystick > 1 || !joyswap) ? joystick : (joystick ^ 1);\n\n\tif (core_type == CORE_TYPE_8BIT)\n\t{\n\t\tspi_uio_cmd8_cont(UIO_ASTICK_2, joy);\n\t\tif (io_ver) spi_w((valueY << 8) | (uint8_t)(valueX));\n\t\telse\n\t\t{\n\t\t\tspi8(valueX);\n\t\t\tspi8(valueY);\n\t\t}\n\t\tDisableIO();\n\t}\n}\n\nvoid user_io_digital_joystick(unsigned char joystick, uint64_t map, int newdir)\n{\n\tuint8_t joy = (joystick>1 || !joyswap) ? joystick : joystick ^ 1;\n\tstatic int use32 = 0;\n\t// primary button mappings are in 31:0, alternate mappings are in 64:32.\n\t// take the logical OR to ensure a held button isn't overriden\n\t// by other mapping being pressed\n\tuint32_t bitmask = (uint32_t)(map) | (uint32_t)(map >> 32);\n\tuse32 |= bitmask >> 16;\n\tspi_uio_cmd_cont((joy < 2) ? (UIO_JOYSTICK0 + joy) : (UIO_JOYSTICK2 + joy - 2));\n\tspi_w(bitmask);\n\tif(use32) spi_w(bitmask >> 16);\n\tDisableIO();\n\n\tif (!is_minimig() && joy_transl == 1 && newdir)\n\t{\n\t\tuser_io_l_analog_joystick(joystick, (bitmask & 2) ? 128 : (bitmask & 1) ? 127 : 0, (bitmask & 8) ? 128 : (bitmask & 4) ? 127 : 0);\n\t}\n}\n\nstatic uint8_t CSD[16] = { 0xf1, 0x40, 0x40, 0x0a, 0x80, 0x7f, 0xe5, 0xe9, 0x00, 0x00, 0x59, 0x5b, 0x32, 0x00, 0x0e, 0x40 };\nstatic uint8_t CID[16] = { 0x3e, 0x00, 0x00, 0x34, 0x38, 0x32, 0x44, 0x00, 0x00, 0x73, 0x2f, 0x6f, 0x93, 0x00, 0xc7, 0xcd };\n\n// set SD card info in FPGA (CSD, CID)\nvoid user_io_sd_set_config(void)\n{\n\tCSD[6] = (uint8_t)(sd_image[0].size >> 9);\n\tCSD[7] = (uint8_t)(sd_image[0].size >> 17);\n\tCSD[8] = (uint8_t)(sd_image[0].size >> 25);\n\n\t// forward it to the FPGA\n\tspi_uio_cmd_cont(UIO_SET_SDCONF);\n\tspi_write(CID, sizeof(CID), fio_size);\n\tspi_write(CSD, sizeof(CSD), fio_size);\n\tspi8(1); //SDHC permanently\n\n\tDisableIO();\n/*\n\tprintf(\"SD CID\\n\");\n\thexdump(CID, sizeof(CID), 0);\n\tprintf(\"SD CSD\\n\");\n\thexdump(CSD, sizeof(CSD), 0);\n*/\n}\n\n// read 8 bit keyboard LEDs status from FPGA\nuint16_t user_io_kbdled_get_status(void)\n{\n\tuint16_t c;\n\n\tspi_uio_cmd_cont(UIO_GET_KBD_LED);\n\tc = spi_w(0);\n\tDisableIO();\n\n\treturn c;\n}\n\nuint8_t user_io_ps2_ctl(uint8_t *kbd_ctl, uint8_t *mouse_ctl)\n{\n\tuint16_t c;\n\tuint8_t res = 0;\n\n\tspi_uio_cmd_cont(UIO_PS2_CTL);\n\n\tc = spi_w(0);\n\tif (kbd_ctl) *kbd_ctl = (uint8_t)c;\n\tres |= ((c >> 8) & 1);\n\n\tc = spi_w(0);\n\tif (mouse_ctl) *mouse_ctl = (uint8_t)c;\n\tres |= ((c >> 7) & 2);\n\n\tDisableIO();\n\treturn res;\n}\n\n// 16 byte fifo for amiga key codes to limit max key rate sent into the core\n#define KBD_FIFO_SIZE  16   // must be power of 2\nstatic unsigned short kbd_fifo[KBD_FIFO_SIZE];\nstatic unsigned char kbd_fifo_r = 0, kbd_fifo_w = 0;\nstatic long kbd_timer = 0;\n\nstatic void kbd_fifo_minimig_send(uint32_t code)\n{\n\tspi_uio_cmd8((code&OSD) ? UIO_KBD_OSD : UIO_KEYBOARD, code & 0xff);\n\tkbd_timer = GetTimer(10);  // next key after 10ms earliest\n}\n\nstatic void kbd_fifo_enqueue(unsigned short code)\n{\n\t// if fifo full just drop the value. This should never happen\n\tif (((kbd_fifo_w + 1)&(KBD_FIFO_SIZE - 1)) == kbd_fifo_r)\n\t\treturn;\n\n\t// store in queue\n\tkbd_fifo[kbd_fifo_w] = code;\n\tkbd_fifo_w = (kbd_fifo_w + 1)&(KBD_FIFO_SIZE - 1);\n}\n\n// send pending bytes if timer has run up\nstatic void kbd_fifo_poll()\n{\n\t// timer enabled and runnig?\n\tif (kbd_timer && !CheckTimer(kbd_timer))\n\t\treturn;\n\n\tkbd_timer = 0;  // timer == 0 means timer is not running anymore\n\n\tif (kbd_fifo_w == kbd_fifo_r)\n\t\treturn;\n\n\tkbd_fifo_minimig_send(kbd_fifo[kbd_fifo_r]);\n\tkbd_fifo_r = (kbd_fifo_r + 1)&(KBD_FIFO_SIZE - 1);\n}\n\nint process_ss(const char *rom_name, int enable)\n{\n\tstatic char ss_name[1024] = {};\n\tstatic char *ss_sufx = 0;\n\tstatic uint32_t ss_cnt[4] = {};\n\tstatic void *base[4] = {};\n\tstatic int enabled = 0;\n\n\tif (!ss_base) return 0;\n\n\tif (rom_name)\n\t{\n\t\tenabled = enable;\n\t\tif (!enabled) return 0;\n\n\t\tuint32_t len = ss_size;\n\t\tuint32_t map_addr = ss_base;\n\t\tfileTYPE f = {};\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tif (!base[i]) base[i] = shmem_map(map_addr, len);\n\t\t\tif (!base[i])\n\t\t\t{\n\t\t\t\tprintf(\"Unable to mmap (0x%X, %d)!\\n\", map_addr, len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tss_cnt[i] = 0xFFFFFFFF;\n\t\t\t\tmemset(base[i], 0, len);\n\n\t\t\t\tif (!i)\n\t\t\t\t{\n\t\t\t\t\tFileGenerateSavestatePath(rom_name, ss_name, 1);\n\t\t\t\t\tprintf(\"Base SavestatePath=%s\\n\", ss_name);\n\t\t\t\t\tif (!FileExists(ss_name)) FileGenerateSavestatePath(rom_name, ss_name, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFileGenerateSavestatePath(rom_name, ss_name, i + 1);\n\t\t\t\t}\n\n\t\t\t\tif (FileExists(ss_name))\n\t\t\t\t{\n\t\t\t\t\tif (!FileOpen(&f, ss_name))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"Unable to open file: %s\\n\", ss_name);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint ret = FileReadAdv(&f, base[i], len);\n\t\t\t\t\t\tFileClose(&f);\n\t\t\t\t\t\tprintf(\"process_ss: read %d bytes from file: %s\\n\", ret, ss_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*(uint32_t*)(base[i]) = 0xFFFFFFFF;\n\t\t\t}\n\n\t\t\tmap_addr += len;\n\t\t}\n\n\t\tFileGenerateSavestatePath(rom_name, ss_name, 1);\n\t\tss_sufx = ss_name + strlen(ss_name) - 4;\n\t\treturn 1;\n\t}\n\n\tif (!enabled) return 0;\n\n\tstatic unsigned long ss_timer = 0;\n\tif (ss_timer && !CheckTimer(ss_timer)) return 0;\n\tss_timer = GetTimer(1000);\n\n\tfileTYPE f = {};\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (base[i])\n\t\t{\n\t\t\tuint32_t curcnt = ((uint32_t*)(base[i]))[0];\n\t\t\tuint32_t size = ((uint32_t*)(base[i]))[1];\n\n\t\t\tif (curcnt != ss_cnt[i])\n\t\t\t{\n\t\t\t\tss_cnt[i] = curcnt;\n\t\t\t\tif (size) size = (size + 2) * 4;\n\t\t\t\tif (size > 0 && size <= ss_size)\n\t\t\t\t{\n\t\t\t\t\tMenuHide();\n\t\t\t\t\tInfo(\"Saving the state\", 500);\n\n\t\t\t\t\t*ss_sufx = i + '1';\n\t\t\t\t\tif (FileOpenEx(&f, ss_name, O_CREAT | O_TRUNC | O_RDWR | O_SYNC))\n\t\t\t\t\t{\n\t\t\t\t\t\tint ret = FileWriteAdv(&f, base[i], size);\n\t\t\t\t\t\tFileClose(&f);\n\t\t\t\t\t\tprintf(\"Wrote %d bytes to file: %s\\n\", ret, ss_name);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"Unable to create file: %s\\n\", ss_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nvoid user_io_set_index(unsigned char index)\n{\n\tEnableFpga();\n\tspi8(FIO_FILE_INDEX);\n\tspi8(index);\n\tDisableFpga();\n}\n\nvoid user_io_set_aindex(uint16_t index)\n{\n\tEnableFpga();\n\tspi8(FIO_FILE_INDEX);\n\tspi_w(index);\n\tDisableFpga();\n}\n\nvoid user_io_set_download(unsigned char enable, int addr)\n{\n\tEnableFpga();\n\tspi8(FIO_FILE_TX);\n\tspi8(enable ? 0xff : 0);\n\tif (enable && addr)\n\t{\n\t\tspi_w(addr);\n\t\tspi_w(addr >> 16);\n\t}\n\tDisableFpga();\n}\n\nvoid user_io_file_tx_data(const uint8_t *addr, uint32_t len)\n{\n\tEnableFpga();\n\tspi8(FIO_FILE_TX_DAT);\n\tspi_write(addr, len, fio_size);\n\tDisableFpga();\n}\n\nvoid user_io_set_upload(unsigned char enable, int addr)\n{\n\tEnableFpga();\n\tspi8(FIO_FILE_TX);\n\tspi8(enable ? 0xaa : 0);\n\tif (enable && addr)\n\t{\n\t\tspi_w(addr);\n\t\tspi_w(addr >> 16);\n\t}\n\tDisableFpga();\n}\n\nvoid user_io_file_rx_data(uint8_t *addr, uint32_t len)\n{\n\tEnableFpga();\n\tspi8(FIO_FILE_TX_DAT);\n\tspi_read(addr, len, fio_size);\n\tDisableFpga();\n}\n\nvoid user_io_file_info(const char *ext)\n{\n\tEnableFpga();\n\tspi8(FIO_FILE_INFO);\n\tchar c1 = *ext ? toupper(*ext++) : 0;\n\tchar c2 = *ext ? toupper(*ext++) : 0;\n\tchar c3 = *ext ? toupper(*ext++) : 0;\n\tchar c4 = *ext ? toupper(*ext++) : 0;\n\tspi_w(c1 << 8 | c2);\n\tspi_w(c3 << 8 | c4);\n\tDisableFpga();\n}\n\nint user_io_file_mount(const char *name, unsigned char index, char pre, int pre_size)\n{\n\tint writable = 0;\n\tint ret = 0;\n\tint len = strlen(name);\n\tint img_type = 0; // disk image type (for C128 core): bit 0=dual sided, 1=raw GCR supported, 2=raw MFM supported, 3=high density\n\n\tsd_image_cangrow[index] = (pre != 0);\n\tsd_type[index] = 0;\n\n\tif (len)\n\t{\n\t\tif (!strcasecmp(user_io_get_core_name(), \"apple-ii\"))\n\t\t{\n\t\t\tret = dsk2nib(name, sd_image + index);\n\t\t}\n\n\t\tif (!ret)\n\t\t{\n\t\t\tif (x2trd_ext_supp(name))\n\t\t\t{\n\t\t\t\tret = x2trd(name, sd_image + index);\n\t\t\t}\n\t\t\telse if (len > 4 && !strcasecmp(name + len - 4, \".t64\"))\n\t\t\t{\n\t\t\t\twritable = 0;\n\t\t\t\tret = c64_openT64(name, sd_image + index);\n\t\t\t\tif (ret)\n\t\t\t\t{\n\t\t\t\t\timg_type = c64_openGCR(name, sd_image + index, index);\n\t\t\t\t\tret = img_type < 0 ? 0 : 1;\n\t\t\t\t\tsd_type[index] = 1;\n\t\t\t\t\tif (!ret) FileClose(&sd_image[index]);\n\n\t\t\t\t\tif (ret && is_c128())\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"Disk image type: %d\\n\", img_type);\n\t\t\t\t\t\tuser_io_set_aindex(img_type << 6 | index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twritable = FileCanWrite(name);\n\t\t\t\tret = FileOpenEx(&sd_image[index], name, writable ? (O_RDWR | O_SYNC) : O_RDONLY);\n\t\t\t\tif (ret && len > 4) {\n\t\t\t\t\tif (!strcasecmp(name + len - 4, \".d64\")\n\t\t\t\t\t\t|| !strcasecmp(name + len - 4, \".g64\")\n\t\t\t\t\t\t|| !strcasecmp(name + len - 4, \".d71\")\n\t\t\t\t\t\t|| !strcasecmp(name + len - 4, \".g71\"))\n\t\t\t\t\t{\n\t\t\t\t\t\timg_type = c64_openGCR(name, sd_image + index, index);\n\t\t\t\t\t\tret = img_type < 0 ? 0 : 1;\n\t\t\t\t\t\tsd_type[index] = 1;\n\t\t\t\t\t\tif(!ret) FileClose(&sd_image[index]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcasecmp(name + len - 4, \".d81\"))\n\t\t\t\t\t{\n\t\t\t\t\t\timg_type = G64_SUPPORT_HD | G64_SUPPORT_DS;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ret && is_c128())\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Disk image type: %d\\n\", img_type);\n\t\t\t\t\tuser_io_set_aindex(img_type << 6 | index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ret)\n\t\t{\n\t\t\tprintf(\"Failed to open file %s\\n\", name);\n\t\t}\n\t}\n\telse\n\t{\n\t\tFileClose(&sd_image[index]);\n\t\tc64_closeGCR(index);\n\t}\n\n\tbuffer_lba[index] = -1;\n\tif (!index || is_cdi()) use_save = pre;\n\n\tif (!ret)\n\t{\n\t\tsd_image[index].size = 0;\n\t\tif (pre)\n\t\t{\n\t\t\twritable = 1;\n\t\t\tprintf(\"Will be created upon write\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\twritable = 0;\n\t\t\tprintf(\"Eject image from %d slot\\n\", index);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"Mount %s as %s on %d slot\\n\", name, writable ? \"read-write\" : \"read-only\", index);\n\t}\n\n\tuser_io_sd_set_config();\n\n\t// send mounted image size first then notify about mounting\n\tEnableIO();\n\tspi8(UIO_SET_SDINFO);\n\n\t__off64_t size = sd_image[index].size;\n\tif (!ret && pre)\n\t{\n\t\tsd_image[index].type = 2;\n\t\tstrcpy(sd_image[index].path, name);\n\t\tsize = pre_size;\n\t}\n\n\tif (io_ver)\n\t{\n\t\tspi32_w(size);\n\t\tspi32_w(size >> 32);\n\t}\n\telse\n\t{\n\t\tspi32_b(size);\n\t\tspi32_b(size >> 32);\n\t}\n\tDisableIO();\n\n\t// notify core of possible sd image change\n\tspi_uio_cmd8(UIO_SET_SDSTAT, (1 << index) | (writable ? 0 : 0x80));\n\treturn ret ? 1 : 0;\n}\n\nvoid user_io_bufferinvalidate(unsigned char index)\n{\n\tbuffer_lba[index] = -1;\n}\n\nstatic unsigned char col_attr[1025];\nstatic int col_parse(XMLEvent evt, const XMLNode* node, SXML_CHAR* text, const int n, SAX_Data* sd)\n{\n\t(void)sd;\n\n\tstatic int in_border = 0;\n\tstatic int in_color = 0;\n\tstatic int in_bright = 0;\n\tstatic int in_entry = 0;\n\tstatic int in_line = 0;\n\tstatic int in_paper = 0;\n\tstatic int in_ink = 0;\n\tstatic int end = 0;\n\tstatic int start = 0;\n\tstatic int line = 0;\n\n\tstatic char tmp[8];\n\n\tswitch (evt)\n\t{\n\tcase XML_EVENT_START_NODE:\n\t\tif (!strcasecmp(node->tag, \"colourisation\"))\n\t\t{\n\t\t\tin_border = 0;\n\t\t\tin_color = 0;\n\t\t\tin_bright = 0;\n\t\t\tin_entry = 0;\n\t\t\tin_line = 0;\n\t\t\tin_paper = 0;\n\t\t\tin_ink = 0;\n\t\t}\n\n\t\tif (!strcasecmp(node->tag, \"border\")) in_border = 1;\n\t\tif (!strcasecmp(node->tag, \"colour\")) in_color = 1;\n\t\tif (!strcasecmp(node->tag, \"bright\")) in_bright = 1;\n\n\t\tif (!strcasecmp(node->tag, \"entry\"))\n\t\t{\n\t\t\tint ncode = -1;\n\t\t\tint ncnt = -1;\n\t\t\tfor (int i = 0; i < node->n_attributes; i++)\n\t\t\t{\n\t\t\t\tif (!strcasecmp(node->attributes[i].name, \"code\")) ncode = atoi(node->attributes[i].value);\n\t\t\t\tif (!strcasecmp(node->attributes[i].name, \"quantity\")) ncnt = atoi(node->attributes[i].value);\n\t\t\t}\n\n\t\t\tin_entry = 0;\n\t\t\tif (ncode >= 0 && ncode <= 127)\n\t\t\t{\n\t\t\t\tstart = ncode;\n\t\t\t\tif (ncnt < 1) ncnt = 1;\n\t\t\t\tend = start + ncnt;\n\t\t\t\tif (end > 128) end = 128;\n\t\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\t\tin_entry = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcasecmp(node->tag, \"line\"))\n\t\t{\n\t\t\tint nline = -1;\n\t\t\tfor (int i = 0; i < node->n_attributes; i++)\n\t\t\t{\n\t\t\t\tif (!strcasecmp(node->attributes[i].name, \"index\")) nline = atoi(node->attributes[i].value);\n\t\t\t}\n\n\t\t\tin_line = 0;\n\t\t\tif (nline >= 0 && nline <= 7)\n\t\t\t{\n\t\t\t\tline = nline;\n\t\t\t\tif (in_entry) tmp[line] = 0;\n\t\t\t\tin_line = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcasecmp(node->tag, \"paper\")) in_paper = 1;\n\t\tif (!strcasecmp(node->tag, \"ink\"))   in_ink = 1;\n\t\tbreak;\n\n\tcase XML_EVENT_END_NODE:\n\t\tif (!strcasecmp(node->tag, \"border\")) in_border = 0;\n\t\tif (!strcasecmp(node->tag, \"colour\")) in_color = 0;\n\t\tif (!strcasecmp(node->tag, \"bright\")) in_bright = 0;\n\t\tif (!strcasecmp(node->tag, \"line\"))   in_line = 0;\n\t\tif (!strcasecmp(node->tag, \"paper\"))  in_paper = 0;\n\t\tif (!strcasecmp(node->tag, \"ink\"))    in_ink = 0;\n\t\tif (!strcasecmp(node->tag, \"entry\"))\n\t\t{\n\t\t\tif (in_entry)\n\t\t\t{\n\t\t\t\tfor (int i = start; i < end; i++) memcpy(&col_attr[i * 8], tmp, 8);\n\t\t\t}\n\t\t\tin_entry = 0;\n\t\t}\n\t\tbreak;\n\n\tcase XML_EVENT_TEXT:\n\t\tif (in_border && in_color)  col_attr[1024] = (char)((col_attr[1024] & 8) | (atoi(text) & 7));\n\t\tif (in_border && in_bright) col_attr[1024] = (char)((col_attr[1024] & 7) | ((atoi(text) & 1) << 3));\n\n\t\tif (in_entry && in_line && in_ink   && in_color)  tmp[line] = (char)((tmp[line] & 0xF8) | (atoi(text) & 7));\n\t\tif (in_entry && in_line && in_ink   && in_bright) tmp[line] = (char)((tmp[line] & 0xF7) | ((atoi(text) & 1) << 3));\n\t\tif (in_entry && in_line && in_paper && in_color)  tmp[line] = (char)((tmp[line] & 0x8F) | ((atoi(text) & 7) << 4));\n\t\tif (in_entry && in_line && in_paper && in_bright) tmp[line] = (char)((tmp[line] & 0x7F) | ((atoi(text) & 1) << 7));\n\t\tbreak;\n\n\tcase XML_EVENT_ERROR:\n\t\tprintf(\"XML parse: %s: ERROR %d\\n\", text, n);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic const unsigned char defchars[512] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00,\n\t0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,\n\t0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0,\n\t0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x55, 0xAA, 0x55,\n\t0xAA, 0x55, 0xAA, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x1C, 0x22, 0x78, 0x20, 0x20, 0x7E, 0x00, 0x00, 0x08, 0x3E, 0x28, 0x3E, 0x0A, 0x3E, 0x08,\n\t0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,\n\t0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00, 0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,\n\t0x00, 0x00, 0x10, 0x08, 0x04, 0x08, 0x10, 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x08, 0x04, 0x00,\n\t0x00, 0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,\n\t0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x10, 0x20,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,\n\t0x00, 0x3C, 0x46, 0x4A, 0x52, 0x62, 0x3C, 0x00, 0x00, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3E, 0x00,\n\t0x00, 0x3C, 0x42, 0x02, 0x3C, 0x40, 0x7E, 0x00, 0x00, 0x3C, 0x42, 0x0C, 0x02, 0x42, 0x3C, 0x00,\n\t0x00, 0x08, 0x18, 0x28, 0x48, 0x7E, 0x08, 0x00, 0x00, 0x7E, 0x40, 0x7C, 0x02, 0x42, 0x3C, 0x00,\n\t0x00, 0x3C, 0x40, 0x7C, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00,\n\t0x00, 0x3C, 0x42, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x3E, 0x02, 0x3C, 0x00,\n\t0x00, 0x3C, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x00, 0x00, 0x7C, 0x42, 0x7C, 0x42, 0x42, 0x7C, 0x00,\n\t0x00, 0x3C, 0x42, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00,\n\t0x00, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x00,\n\t0x00, 0x3C, 0x42, 0x40, 0x4E, 0x42, 0x3C, 0x00, 0x00, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00,\n\t0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x02, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00,\n\t0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00,\n\t0x00, 0x42, 0x66, 0x5A, 0x42, 0x42, 0x42, 0x00, 0x00, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00,\n\t0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x00,\n\t0x00, 0x3C, 0x42, 0x42, 0x52, 0x4A, 0x3C, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x7C, 0x44, 0x42, 0x00,\n\t0x00, 0x3C, 0x40, 0x3C, 0x02, 0x42, 0x3C, 0x00, 0x00, 0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,\n\t0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00,\n\t0x00, 0x42, 0x42, 0x42, 0x42, 0x5A, 0x24, 0x00, 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00,\n\t0x00, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x00, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00\n};\n\n\nstatic int chr_parse(XMLEvent evt, const XMLNode* node, SXML_CHAR* text, const int n, SAX_Data* sd)\n{\n\t(void)sd;\n\n\tstatic int in_entry = 0;\n\tstatic int in_line = 0;\n\tstatic int code = 0;\n\tstatic int line = 0;\n\n\tswitch (evt)\n\t{\n\tcase XML_EVENT_START_NODE:\n\t\tif (!strcasecmp(node->tag, \"definition\"))\n\t\t{\n\t\t\tin_entry = 0;\n\t\t\tin_line = 0;\n\t\t\tcode = 0;\n\t\t\tline = 0;\n\t\t}\n\n\t\tif (!strcasecmp(node->tag, \"entry\"))\n\t\t{\n\t\t\tint ncode = -1;\n\t\t\tfor (int i = 0; i < node->n_attributes; i++)\n\t\t\t{\n\t\t\t\tif (!strcasecmp(node->attributes[i].name, \"code\")) ncode = atoi(node->attributes[i].value);\n\t\t\t}\n\n\t\t\tin_entry = 0;\n\t\t\tif (ncode >= 0 && ncode <= 63)\n\t\t\t{\n\t\t\t\tcode = ncode;\n\t\t\t\tin_entry = 1;\n\t\t\t}\n\n\t\t\tif (ncode >= 128 && ncode <= 191)\n\t\t\t{\n\t\t\t\tcode = ncode - 64;\n\t\t\t\tin_entry = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcasecmp(node->tag, \"line\"))\n\t\t{\n\t\t\tint nline = -1;\n\t\t\tfor (int i = 0; i < node->n_attributes; i++)\n\t\t\t{\n\t\t\t\tif (!strcasecmp(node->attributes[i].name, \"index\")) nline = atoi(node->attributes[i].value);\n\t\t\t}\n\n\t\t\tin_line = 0;\n\t\t\tif (nline >= 0 && nline <= 7)\n\t\t\t{\n\t\t\t\tline = nline;\n\t\t\t\tin_line = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase XML_EVENT_END_NODE:\n\t\tif (!strcasecmp(node->tag, \"line\"))  in_line = 0;\n\t\tif (!strcasecmp(node->tag, \"entry\")) in_entry = 0;\n\t\tbreak;\n\n\tcase XML_EVENT_TEXT:\n\t\tif (in_entry && in_line)\n\t\t{\n\t\t\tunsigned char tmp = 0;\n\t\t\tif (strlen(text) >= 8)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < 8; i++) tmp = (tmp << 1) | ((text[i] == '1') ? 1 : 0);\n\t\t\t\tif (code >= 64) tmp = ~tmp;\n\t\t\t}\n\t\t\tcol_attr[code * 8 + line] = tmp;\n\t\t\tin_line = 0;\n\t\t}\n\t\tbreak;\n\n\tcase XML_EVENT_ERROR:\n\t\tprintf(\"XML parse: %s: ERROR %d\\n\", text, n);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic void send_pcolchr(const char* name, unsigned char index, int type)\n{\n\tstatic char full_path[1024];\n\n\tsprintf(full_path, \"%s/%s\", getRootDir(), name);\n\n\tchar *p = strrchr(full_path, '.');\n\tif (!p) p = full_path + strlen(full_path);\n\tstrcpy(p, type ? \".chr\" : \".col\");\n\n\tif (type)\n\t{\n\t\tmemcpy(col_attr, defchars, sizeof(defchars));\n\t\tmemcpy(col_attr+sizeof(defchars), defchars, sizeof(defchars));\n\t}\n\telse memset(col_attr, 0, sizeof(col_attr));\n\n\tSAX_Callbacks sax;\n\tSAX_Callbacks_init(&sax);\n\tsax.all_event = type ? chr_parse : col_parse;\n\tif (XMLDoc_parse_file_SAX(full_path, &sax, 0))\n\t{\n\t\tprintf(\"Send additional file %s\\n\", full_path);\n\n\t\t//hexdump(col_attr, sizeof(col_attr));\n\n\t\tuser_io_set_index(index);\n\n\t\tuser_io_set_download(1);\n\t\tuser_io_file_tx_data(col_attr, type ? 1024 : 1025);\n\t\tuser_io_set_download(0);\n\t}\n}\n\nstatic uint32_t file_crc;\nuint32_t user_io_get_file_crc()\n{\n\treturn file_crc;\n}\n\nint user_io_use_cheats()\n{\n\treturn use_cheats;\n}\n\nstatic void check_status_change()\n{\n\tstatic u_int8_t last_status_change = 0;\n\tchar stchg = spi_uio_cmd_cont(UIO_GET_STATUS);\n\tif ((stchg & 0xF0) == 0xA0 && last_status_change != (stchg & 0xF))\n\t{\n\t\tlast_status_change = (stchg & 0xF);\n\t\tfor (uint i = 0; i < sizeof(cur_status); i += 2)\n\t\t{\n\t\t\tuint16_t x = spi_w(0);\n\t\t\tcur_status[i] = (char)x;\n\t\t\tcur_status[i + 1] = (char)(x >> 8);\n\t\t}\n\t\tDisableIO();\n\t\tuser_io_status_set(\"[0]\", 0);\n\t}\n\telse\n\t{\n\t\tDisableIO();\n\t}\n}\n\nstatic void show_core_info(int info_n)\n{\n\tint i = 2;\n\tuser_io_read_confstr();\n\n\twhile (1)\n\t{\n\t\tchar *p = user_io_get_confstr(i++);\n\t\tif (!p) break;\n\n\t\tif (p[0] == 'I')\n\t\t{\n\t\t\tstatic char str[256];\n\t\t\tsubstrcpy(str, p, info_n);\n\t\t\tif (strlen(str)) Info(str);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint user_io_file_tx_a(const char* name, uint16_t index)\n{\n\tfileTYPE f = {};\n\tstatic uint8_t buf[4096];\n\n\tif (!FileOpen(&f, name, 1)) return 0;\n\n\tunsigned long bytes2send = f.size;\n\n\t/* transmit the entire file using one transfer */\n\tprintf(\"Addon file %s with %lu bytes to send for index %04X\\n\", name, bytes2send, index);\n\n\t// set index byte (0=bios rom, 1-n=OSD entry index)\n\tuser_io_set_aindex(index);\n\n\t// prepare transmission of new file\n\tuser_io_set_download(1);\n\n\tint use_progress = 1;\n\tint size = bytes2send;\n\tif (use_progress) ProgressMessage(0, 0, 0, 0);\n\twhile (bytes2send)\n\t{\n\t\tuint32_t chunk = (bytes2send > sizeof(buf)) ? sizeof(buf) : bytes2send;\n\n\t\tFileReadAdv(&f, buf, chunk);\n\t\tuser_io_file_tx_data(buf, chunk);\n\n\t\tif (use_progress) ProgressMessage(\"Loading\", f.name, size - bytes2send, size);\n\t\tbytes2send -= chunk;\n\t}\n\n\t// check if core requests some change while downloading\n\tcheck_status_change();\n\n\tprintf(\"Done.\\n\");\n\tFileClose(&f);\n\n\t// signal end of transmission\n\tuser_io_set_download(0);\n\tProgressMessage(0, 0, 0, 0);\n\treturn 1;\n}\n\nint user_io_file_tx(const char* name, unsigned char index, char opensave, char mute, char composite, uint32_t load_addr)\n{\n\tfileTYPE f = {};\n\tstatic uint8_t buf[4096];\n\n\tif (!FileOpen(&f, name, mute)) return 0;\n\n\tuint32_t bytes2send = f.size;\n\n\tif (composite)\n\t{\n\t\tif (!FileReadSec(&f, buf)) return 0;\n\t\tif (memcmp(buf, \"MiSTer\", 6)) return 0;\n\n\t\tuint32_t off = 16 + *(uint32_t*)(((uint8_t*)buf) + 12);\n\t\tbytes2send -= off;\n\n\t\tFileSeek(&f, off, SEEK_SET);\n\t}\n\n\t/* transmit the entire file using one transfer */\n\tprintf(\"Selected file %s with %u bytes to send for index %d.%d\\n\", name, bytes2send, index & 0x3F, index >> 6);\n\tif(load_addr) printf(\"Load to address 0x%X\\n\", load_addr);\n\n\t// set index byte (0=bios rom, 1-n=OSD entry index)\n\tuser_io_set_index(index);\n\n\tint len = strlen(f.name);\n\tchar *p = strrchr(f.name, '.');\n\tif (p == 0) {\n            // In case a '.' is not found, send all `NUL` characters.\n\t    p = f.name + len;\n\t}\n\tuser_io_file_info(p);\n\n\t// prepare transmission of new file\n\tuser_io_set_download(1, load_addr ? bytes2send : 0);\n\n\tint dosend = 1;\n\n\tint snes_file = SNES_FILE_RAW;\n\tif (is_snes() && bytes2send && !load_addr)\n\t{\n\t\tconst char *ext = strrchr(f.name, '.');\n\t\tif (ext) {\n\t\t\tif (index == 0 || !strcasecmp(ext, \".SMC\") || !strcasecmp(ext, \".SFC\") || !strcasecmp(ext, \".BIN\")) {\n\t\t\t\tsnes_file = SNES_FILE_ROM;\n\t\t\t} else if (!strcasecmp(ext, \".BS\")) {\n\t\t\t\tsnes_file = SNES_FILE_BS;\n\t\t\t} else if (!strcasecmp(ext, \".SPC\")) {\n\t\t\t\tsnes_file = SNES_FILE_SPC;\n\t\t\t}\n\t\t}\n\n\t\tif (snes_file == SNES_FILE_BS) {\n\t\t\tchar *rom_path = (char*)buf;\n\t\t\tstrcpy(rom_path, name);\n\t\t\tchar *offs = strrchr(rom_path, '/');\n\t\t\tif (offs) *offs = 0;\n\t\t\telse *rom_path = 0;\n\n\t\t\tfileTYPE fb = {};\n\t\t\tif (FileOpen(&fb, user_io_make_filepath(rom_path, \"bsx_bios.rom\")) ||\n\t\t\t\tFileOpen(&fb, user_io_make_filepath(HomeDir(), \"bsx_bios.rom\")))\n\t\t\t{\n\t\t\t\tprintf(\"Load BSX bios ROM.\\n\");\n\t\t\t\tuint8_t* buf = snes_get_header(&fb);\n\t\t\t\thexdump(buf, 16, 0);\n\t\t\t\tuser_io_file_tx_data(buf, 512);\n\n\t\t\t\t//strip original SNES ROM header if present (not used)\n\t\t\t\tif ((bytes2send % 1024) == 512)\n\t\t\t\t{\n\t\t\t\t\tbytes2send -= 512;\n\t\t\t\t\tFileReadSec(&f, buf);\n\t\t\t\t}\n\n\t\t\t\tuint32_t sz = fb.size;\n\t\t\t\twhile (sz)\n\t\t\t\t{\n\t\t\t\t\tuint32_t chunk = (sz > sizeof(buf)) ? sizeof(buf) : sz;\n\t\t\t\t\tFileReadAdv(&fb, buf, chunk);\n\t\t\t\t\tuser_io_file_tx_data(buf, chunk);\n\t\t\t\t\tsz -= chunk;\n\t\t\t\t}\n\t\t\t\tFileClose(&fb);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdosend = 0;\n\t\t\t\tInfo(\"Cannot open bsx_bios.rom!\");\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\telse if (snes_file == SNES_FILE_SPC) {\n\t\t\tprintf(\"Load SPC ROM.\\n\");\n\t\t\tFileReadSec(&f, buf);\n\t\t\tuser_io_file_tx_data(buf, 256);\n\n\t\t\tFileSeek(&f, (64*1024)+256, SEEK_SET);\n\t\t\tFileReadSec(&f, buf);\n\t\t\tuser_io_file_tx_data(buf, 256);\n\n\t\t\tFileSeek(&f, 256, SEEK_SET);\n\t\t\tbytes2send = 64 * 1024;\n\t\t}\n\t\telse if (snes_file == SNES_FILE_ROM) {\n\t\t\tprintf(\"Load SNES ROM.\\n\");\n\t\t\tuint8_t* buf = snes_get_header(&f);\n\t\t\thexdump(buf, 16, 0);\n\t\t\tuser_io_file_tx_data(buf, 512);\n\n\t\t\t//strip original SNES ROM header if present (not used)\n\t\t\tif ((bytes2send % 1024) == 512)\n\t\t\t{\n\t\t\t\tbytes2send -= 512;\n\t\t\t\tFileReadSec(&f, buf);\n\t\t\t}\n\t\t}\n\t}\n\n\tfile_crc = 0;\n\tuint32_t skip = bytes2send & 0x3FF; // skip possible header up to 1023 bytes\n\n\tint use_progress = 1; // (bytes2send > (1024 * 1024)) ? 1 : 0;\n\tint size = bytes2send;\n\tif (use_progress) ProgressMessage(0, 0, 0, 0);\n\n\tif(ss_base && opensave) process_ss(name);\n\n\tif (is_gba())\n\t{\n\t\tif ((index >> 6) == 1 || (index >> 6) == 2)\n\t\t{\n\t\t\tfileTYPE fg = {};\n\t\t\tif (!FileOpen(&fg, user_io_make_filepath(HomeDir(), \"goomba.rom\")))\n\t\t\t{\n\t\t\t\tdosend = 0;\n\t\t\t\tInfo(\"Cannot open goomba.rom!\");\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32_t sz = fg.size;\n\t\t\t\twhile (sz)\n\t\t\t\t{\n\t\t\t\t\tuint32_t chunk = (sz > sizeof(buf)) ? sizeof(buf) : sz;\n\t\t\t\t\tFileReadAdv(&fg, buf, chunk);\n\t\t\t\t\tuser_io_file_tx_data(buf, chunk);\n\t\t\t\t\tsz -= chunk;\n\t\t\t\t}\n\t\t\t\tFileClose(&fg);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_electron() && bytes2send)\n\t{\n\t\tconst char *ext = strrchr(f.name, '.');\n\t\tif (ext && !strcasecmp(ext, \".UEF\")) {\n\t\t\tUEF_FileSend(&f,use_progress);\n\t\t\tdosend=0;\n\t\t}\n\t}\n\n\tif (dosend && load_addr >= 0x20000000 && (load_addr + bytes2send) <= 0x40000000)\n\t{\n\t\tuint32_t map_size = bytes2send + ((is_snes() && load_addr < 0x22000000) ? 0x800000 : 0);\n\t\tuint8_t *mem = (uint8_t *)shmem_map(fpga_mem(load_addr), map_size);\n\t\tif (mem)\n\t\t{\n\t\t\twhile (bytes2send)\n\t\t\t{\n\t\t\t\tuint32_t gap = (is_snes() && (load_addr < 0x22000000) && (load_addr + size - bytes2send) >= 0x22000000) ? 0x800000 : 0;\n\n\t\t\t\tuint32_t chunk = (bytes2send > (256 * 1024)) ? (256 * 1024) : bytes2send;\n\t\t\t\tFileReadAdv(&f, mem + size - bytes2send + gap, chunk);\n\n\t\t\t\tif(!is_snes() && use_cheats) file_crc = crc32(file_crc, mem + skip + size - bytes2send, chunk - skip);\n\t\t\t\tskip = 0;\n\n\t\t\t\tif (use_progress) ProgressMessage(\"Loading\", f.name, size - bytes2send, size);\n\t\t\t\tbytes2send -= chunk;\n\t\t\t}\n\n\t\t\tshmem_unmap(mem, map_size);\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (dosend && bytes2send)\n\t\t{\n\t\t\tuint32_t chunk = (bytes2send > sizeof(buf)) ? sizeof(buf) : bytes2send;\n\n\t\t\tFileReadAdv(&f, buf, chunk);\n\t\t\tif (is_snes() && (snes_file == SNES_FILE_BS)) snes_patch_bs_header(&f, buf);\n\t\t\tuser_io_file_tx_data(buf, chunk);\n\n\t\t\tif (use_progress) ProgressMessage(\"Loading\", f.name, size - bytes2send, size);\n\t\t\tbytes2send -= chunk;\n\n\t\t\tif (skip >= chunk) skip -= chunk;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfile_crc = crc32(file_crc, buf + skip, chunk - skip);\n\t\t\t\tskip = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// check if core requests some change while downloading\n\tcheck_status_change();\n\n\tprintf(\"Done.\\n\");\n\tprintf(\"CRC32: %08X\\n\", file_crc);\n\n\tFileClose(&f);\n\n\tif (opensave)\n\t{\n\t\tFileGenerateSavePath(name, (char*)buf);\n\t\tuser_io_file_mount((char*)buf, 0, 1);\n\t}\n\n\t// signal end of transmission\n\tuser_io_set_download(0);\n\tprintf(\"\\n\");\n\n\tif (is_zx81() && index)\n\t{\n\t\tsend_pcolchr(name, (index & 0x1F) | 0x20, 0);\n\t\tsend_pcolchr(name, (index & 0x1F) | 0x60, 1);\n\t}\n\n\tProgressMessage(0, 0, 0, 0);\n\n\tif ((is_snes() || is_sgb()) && !load_addr)\n\t{\n\t\t// Setup MSU\n\t\tsnes_msu_init(name);\n\t}\n\n\treturn 1;\n}\n\nstatic char cfgstr[1024 * 10] = {};\nvoid user_io_read_confstr()\n{\n\tspi_uio_cmd_cont(UIO_GET_STRING);\n\n\tuint32_t j = 0;\n\twhile (j < sizeof(cfgstr) - 1)\n\t{\n\t\tchar i = spi_in();\n\t\tif (!i) break;\n\t\tcfgstr[j++] = i;\n\t}\n\n\tcfgstr[j++] = 0;\n\tDisableIO();\n}\n\nchar *user_io_get_confstr(int index)\n{\n\tint lidx = 0;\n\tstatic char buffer[(1024*2) + 1];  // max bytes per config item\n\n\tchar *start = cfgstr;\n\twhile (lidx < index)\n\t{\n\t\tstart = strchr(start, ';');\n\t\tif (!start) return NULL;\n\t\tstart++;\n\t\tlidx++;\n\t}\n\n\tchar *end = strchr(start, ';');\n\tint len = end ? end - start : strlen(start);\n\tif (!len) return NULL;\n\n\tif ((uint32_t)len > sizeof(buffer) - 1) len = sizeof(buffer) - 1;\n\tmemcpy(buffer, start, len);\n\tbuffer[len] = 0;\n\treturn buffer;\n}\n\nstatic char cur_btn = 0;\nchar user_io_menu_button()\n{\n\treturn (cur_btn & BUTTON_OSD) ? 1 : 0;\n}\n\nchar user_io_user_button()\n{\n\treturn (cur_btn & BUTTON_USR) ? 1 : 0;\n}\n\nstatic int vga_fb = 0;\nvoid set_vga_fb(int enable)\n{\n\tvga_fb = enable;\n\tuser_io_send_buttons(1);\n}\n\nint get_vga_fb()\n{\n\treturn vga_fb;\n}\n\nstatic char kbd_reset = 0;\nstatic char kbd_reset_ovr = 0;\n\nvoid user_io_send_buttons(char force)\n{\n\tstatic unsigned short key_map = 0;\n\tunsigned short map = 0;\n\n\tcur_btn = fpga_get_buttons();\n\n\tif (user_io_menu_button()) map |= BUTTON1;\n\tif (user_io_user_button()) map |= BUTTON2;\n\tif (kbd_reset || kbd_reset_ovr) map |= BUTTON2;\n\n\tif (cfg.vga_scaler) map |= CONF_VGA_SCALER;\n\tif (cfg.vga_sog) map |= CONF_VGA_SOG;\n\tif (cfg.csync) map |= CONF_CSYNC;\n\tif (cfg.vga_mode_int == 1) map |= CONF_YPBPR;\n\tif (cfg.forced_scandoubler) map |= CONF_FORCED_SCANDOUBLER;\n\tif (cfg.hdmi_audio_96k) map |= CONF_AUDIO_96K;\n\tif (cfg.dvi_mode == 1) map |= CONF_DVI;\n\tif (cfg.hdmi_limited & 1) map |= CONF_HDMI_LIMITED1;\n\tif (cfg.hdmi_limited & 2) map |= CONF_HDMI_LIMITED2;\n\tif (cfg.direct_video) map |= CONF_DIRECT_VIDEO;\n\tif (cfg.direct_video == 2) map |= CONF_DIRECT_VIDEO2;\n\tif (vga_fb) map |= CONF_VGA_FB;\n\n\tif ((map != key_map) || force)\n\t{\n\t\tconst char *name = get_rbf_path();\n\t\tif (name[0] && (get_key_mod() & (LGUI | LSHIFT)) == (LGUI | LSHIFT) && (key_map & BUTTON2) && !(map & BUTTON2))\n\t\t{\n\t\t\tuint16_t sz = sdram_sz(-1);\n\t\t\tif (sz & 0x4000) sz++;\n\t\t\telse sz = 0x4000;\n\t\t\tsdram_sz(sz);\n\t\t\tfpga_load_rbf(name);\n\t\t}\n\n\t\t//special reset for some cores\n\t\tif (!user_io_osd_is_visible() && (key_map & BUTTON2) && !(map & BUTTON2))\n\t\t{\n\t\t\tif (is_minimig()) minimig_reset();\n\t\t\tif (is_megacd()) mcd_reset();\n\t\t\tif (is_neogeo_cd()) neocd_reset();\n\t\t\tif (is_pce()) pcecd_reset();\n\t\t\tif (is_saturn()) saturn_reset();\n\t\t\tif (is_x86() || is_pcxt()) x86_init();\n\t\t\tif (is_uneon()) x86_ide_set();\n\t\t\tif (is_st()) tos_reset(0);\n\t\t\tResetUART();\n\t\t}\n\n\t\tkey_map = map;\n\t\tif (user_io_osd_is_visible()) map &= ~BUTTON2;\n\t\tspi_uio_cmd16(UIO_BUT_SW, map);\n\t\tprintf(\"sending keymap: %X\\n\", map);\n\t}\n}\n\nint user_io_get_kbd_reset()\n{\n\treturn kbd_reset || kbd_reset_ovr;\n}\n\nvoid user_io_set_kbd_reset(int reset)\n{\n\tkbd_reset_ovr = reset;\n}\n\nvoid user_io_set_ini(int ini_num)\n{\n\tconst char *name = rbf_path;\n\tconst char *xml = strcasecmp(rbf_path, core_path) ? core_path : NULL;\n\n\tif (!name[0])\n\t{\n\t\tname = \"menu.rbf\";\n\t\txml = NULL;\n\t}\n\n\tif (FileExists(cfg_get_name(ini_num)))\n\t{\n\t\taltcfg(ini_num);\n\t\tfpga_load_rbf(name, NULL, xml);\n\t}\n}\n\n\nstatic uint32_t diskled_timer = 0;\nstatic uint32_t diskled_is_on = 0;\nvoid diskled_on()\n{\n\tfpga_set_led(1);\n\tdiskled_timer = GetTimer(50);\n\tdiskled_is_on = 1;\n}\n\nstatic void kbd_reply(char code)\n{\n\tprintf(\"kbd_reply = 0x%02X\\n\", code);\n\tspi_uio_cmd16(UIO_KEYBOARD, 0xFF00 | code);\n}\n\nstatic void mouse_reply(char code)\n{\n\tprintf(\"mouse_reply = 0x%02X\\n\", code);\n\tspi_uio_cmd16(UIO_MOUSE, 0xFF00 | code);\n}\n\nstatic uint8_t use_ps2ctl = 0;\nstatic unsigned long rtc_timer = 0;\n\nvoid user_io_rtc_reset()\n{\n\trtc_timer = 0;\n}\n\nstatic int coldreset_req = 0;\n\nstatic uint32_t res_timer = 0;\n\nvoid user_io_poll()\n{\n\tPROFILE_FUNCTION();\n\n\tif ((core_type != CORE_TYPE_SHARPMZ) &&\n\t\t(core_type != CORE_TYPE_8BIT))\n\t{\n\t\treturn;  // no user io for the installed core\n\t}\n\n\tuser_io_send_buttons(0);\n\n\tif (is_minimig())\n\t{\n\t\t//HDD & FDD query\n\t\tunsigned char  c1, c2;\n\t\tEnableFpga();\n\t\tuint16_t tmp = spi_w(0);\n\t\tc1 = (uint8_t)(tmp >> 8); // cmd request and drive number\n\t\tc2 = (uint8_t)tmp;      // track number\n\t\tspi_w(0);\n\t\tspi_w(0);\n\t\tDisableFpga();\n\t\tsysled_enable(0);\n\t\tHandleFDD(c1, c2);\n\t\tsysled_enable(1);\n\n\t\tuint16_t sd_req = ide_check();\n\t\tide_io(0, sd_req & 7);\n\t\tide_io(1, (sd_req >> 3) & 7);\n\t\tif (sd_req & 0x0100) ide_cdda_send_sector();\n\t\tUpdateDriveStatus();\n\n\t\tkbd_fifo_poll();\n\n\t\tif (!rtc_timer || CheckTimer(rtc_timer))\n\t\t{\n\t\t\t// Update once per minute should be enough\n\t\t\trtc_timer = GetTimer(60000);\n\t\t\tsend_rtc(1);\n\t\t}\n\n\t\tminimig_share_poll();\n\t}\n\n\tif (core_type == CORE_TYPE_8BIT && !is_menu())\n\t{\n\t\tcheck_status_change();\n\t}\n\n\t// sd card emulation\n\tif (is_x86() || is_pcxt())\n\t{\n\t\tx86_poll(0);\n\t}\n\telse if ((core_type == CORE_TYPE_8BIT) && !is_menu() && !is_minimig())\n\t{\n\t\tif (is_st()) tos_poll();\n\t\tif (is_snes() || is_sgb()) snes_poll();\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint disk = -1;\n\t\t\tint ack = 0;\n\t\t\tint op = 0;\n\t\t\tstatic uint8_t buffer[16][16384];\n\t\t\tuint64_t lba;\n\t\t\tuint32_t blksz, blks, sz;\n\n\t\t\tif (is_uneon() && i == 3)\n\t\t\t{\n\t\t\t\tx86_poll(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuint16_t c = spi_uio_cmd_cont(UIO_GET_SDSTAT);\n\t\t\tif (c & 0x8000)\n\t\t\t{\n\t\t\t\tdisk = (c >> 2) & 0xF;\n\t\t\t\top = c & 3;\n\t\t\t\tack = disk << 8;\n\t\t\t\tspi_w(0);\n\t\t\t\tlba = spi_w(0);\n\t\t\t\tlba = (lba & 0xFFFF) | (((uint32_t)spi_w(0)) << 16);\n\t\t\t\tblks = ((c >> 9) & 0x3F) + 1;\n\t\t\t\tif ((disk == 0 && is_cdi()) || (disk == 1 && is_psx()))\n\t\t\t\t\tblksz = 2352;\n\t\t\t\telse\n\t\t\t\t\tblksz = 128 << ((c >> 6) & 7);\n\n\t\t\t\tsz = blksz * blks;\n\t\t\t\tif (sz > sizeof(buffer[0]))\n\t\t\t\t{\n\t\t\t\t\tblks = sizeof(buffer[0]) / blksz;\n\t\t\t\t\tsz = blksz * blks;\n\t\t\t\t}\n\n\t\t\t\t//if (op) printf(\"c=%X, op=%d, blkpow=%d, sz=%d, lba=%llu, disk=%d\\n\", c, op, blkpow, sz, lba, disk);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc = spi_w(0);\n\t\t\t\tif ((c & 0xf0) == 0x50 && (c & 0x3F03))\n\t\t\t\t{\n\t\t\t\t\tlba = spi_w(0);\n\t\t\t\t\tlba = (lba & 0xFFFF) | (((uint32_t)spi_w(0)) << 16);\n\n\t\t\t\t\t// check if core requests configuration\n\t\t\t\t\tif ((c & 0xC) == 0xC)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"core requests SD config\\n\");\n\t\t\t\t\t\tuser_io_sd_set_config();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c & 0x0003)\n\t\t\t\t\t{\n\t\t\t\t\t\tdisk = 0;\n\t\t\t\t\t\top = (c & 1) ? 1 : 2;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c & 0x0900)\n\t\t\t\t\t{\n\t\t\t\t\t\tdisk = 1;\n\t\t\t\t\t\top = (c & 0x100) ? 1 : 2;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c & 0x1200)\n\t\t\t\t\t{\n\t\t\t\t\t\tdisk = 2;\n\t\t\t\t\t\top = (c & 0x200) ? 1 : 2;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c & 0x2400)\n\t\t\t\t\t{\n\t\t\t\t\t\tdisk = 3;\n\t\t\t\t\t\top = (c & 0x400) ? 1 : 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tack = ((c & 4) ? 0 : ((disk + 1) << 8));\n\t\t\t\t}\n\n\t\t\t\tsz = 512;\n\t\t\t\tblksz = 512;\n\t\t\t\tblks = 1;\n\t\t\t}\n\t\t\tDisableIO();\n\n\t\t\tif ((blks == G64_BLOCK_COUNT_1541+1 || blks == G64_BLOCK_COUNT_1571+1) && sd_type[disk])\n\t\t\t{\n\t\t\t\tif (op == 2) c64_writeGCR(disk, lba, blks-1);\n\t\t\t\telse if (op & 1) c64_readGCR(disk, lba, blks-1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t\telse if ((op == 2) && is_n64() && use_save)\n\t\t\t{\n\t\t\t\tn64_save_savedata(lba, ack, buffer_lba[disk], buffer[disk], blksz, sz);\n\t\t\t}\n\t\t\telse if (op == 2)\n\t\t\t{\n\t\t\t\t//printf(\"SD WR %llu on %d\\n\", lba, disk);\n\n\t\t\t\tif (use_save) menu_process_save();\n\n\t\t\t\tbuffer_lba[disk] = -1;\n\n\t\t\t\t// Fetch sector data from FPGA ...\n\t\t\t\tEnableIO();\n\t\t\t\tspi_w(UIO_SECTOR_WR | ack);\n\t\t\t\tspi_block_read(buffer[disk], fio_size, sz);\n\t\t\t\tDisableIO();\n\n\t\t\t\tif (sd_image[disk].type == 2 && !lba)\n\t\t\t\t{\n\t\t\t\t\t//Create the file\n\t\t\t\t\tif (FileOpenEx(&sd_image[disk], sd_image[disk].path, O_CREAT | O_RDWR | O_SYNC))\n\t\t\t\t\t{\n\t\t\t\t\t\tdiskled_on();\n\t\t\t\t\t\tif (FileWriteAdv(&sd_image[disk], buffer[disk], sz))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsd_image[disk].size = sz;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"Error in creating file: %s\\n\", sd_image[disk].path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// ... and write it to disk\n\t\t\t\t\tuint64_t size = sd_image[disk].size / blksz;\n\t\t\t\t\tif (sz && lba <= size)\n\t\t\t\t\t{\n\t\t\t\t\t\tdiskled_on();\n\t\t\t\t\t\tif (FileSeek(&sd_image[disk], lba * blksz, SEEK_SET))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!sd_image_cangrow[disk])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t__off64_t rem = sd_image[disk].size - sd_image[disk].offset;\n\t\t\t\t\t\t\t\tsz = (rem >= sz) ? sz : (int)rem;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (sz) FileWriteAdv(&sd_image[disk], buffer[disk], sz);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((op & 1) && is_n64() && use_save)\n\t\t\t{\n\t\t\t\tn64_load_savedata(lba, ack, buffer_lba[disk], buffer[disk], sizeof(*buffer), blksz, sz);\n\t\t\t}\n\t\t\telse if (op & 1)\n\t\t\t{\n\t\t\t\tuint32_t buf_n = sizeof(buffer[0]) / blksz;\n\t\t\t\tif (is_psx() && blksz == 2352)\n\t\t\t\t{\n\t\t\t\t\t//returns 0 if the mounted disk is not a chd, otherwise returns the chd hunksize in bytes\n\t\t\t\t\tunsigned int psx_blksz = psx_chd_hunksize();\n\t\t\t\t\tif (psx_blksz && psx_blksz <= sizeof(buffer[0])) buf_n = psx_blksz / blksz;\n\t\t\t\t}\n\t\t\t\telse if (is_cdi() && blksz == 2352)\n\t\t\t\t{\n\t\t\t\t\t//returns 0 if the mounted disk is not a chd, otherwise returns the chd hunksize in bytes\n\t\t\t\t\tunsigned int psx_blksz = cdi_chd_hunksize();\n\t\t\t\t\tif (psx_blksz && psx_blksz <= sizeof(buffer[0])) buf_n = psx_blksz / blksz;\n\t\t\t\t}\n\t\t\t\t//printf(\"SD RD (%llu,%d) on %d, WIDE=%d\\n\", lba, blksz, disk, fio_size);\n\n\t\t\t\tint done = 0;\n\t\t\t\tuint32_t offset;\n\n\t\t\t\tif ((buffer_lba[disk] == -1LLU) || lba < buffer_lba[disk] || (lba + blks - buffer_lba[disk]) > buf_n)\n\t\t\t\t{\n\t\t\t\t\tbuffer_lba[disk] = -1;\n\t\t\t\t\tif (blksz == 2352 && is_psx())\n\t\t\t\t\t{\n\t\t\t\t\t\tdiskled_on();\n\t\t\t\t\t\tpsx_read_cd(buffer[disk], lba, buf_n);\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t\tbuffer_lba[disk] = lba;\n\t\t\t\t\t}\n\t\t\t\t\telse if (blksz == 2352 && is_cdi())\n\t\t\t\t\t{\n\t\t\t\t\t\tdiskled_on();\n\t\t\t\t\t\tcdi_read_cd(buffer[disk], lba, buf_n);\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t\tbuffer_lba[disk] = lba;\n\t\t\t\t\t}\n\t\t\t\t\telse if (sd_image[disk].size)\n\t\t\t\t\t{\n\t\t\t\t\t\tdiskled_on();\n\t\t\t\t\t\tif (FileSeek(&sd_image[disk], lba * blksz, SEEK_SET))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (FileReadAdv(&sd_image[disk], buffer[disk], sizeof(buffer[disk])))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t\t\t\tbuffer_lba[disk] = lba;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Even after error we have to provide the block to the core\n\t\t\t\t\t//Give an empty block.\n\t\t\t\t\tif (!done)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sd_image[disk].type == 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (is_megacd())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmcd_fill_blanksave(buffer[disk], lba);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (is_pce())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemset(buffer[disk], 0, sizeof(buffer[disk]));\n\t\t\t\t\t\t\t\tif (!lba)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmemcpy(buffer[disk], \"HUBM\\x00\\x88\\x10\\x80\", 8);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (is_psx())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpsx_fill_blanksave(buffer[disk], lba, blks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (is_saturn())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsaturn_fill_blanksave(buffer[disk], lba);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemset(buffer[disk], -1, sizeof(buffer[disk]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemset(buffer[disk], 0, sizeof(buffer[disk]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toffset = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toffset = (lba - buffer_lba[disk]) * blksz;\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\n\t\t\t\t// data is now stored in buffer. send it to fpga\n\t\t\t\tEnableIO();\n\t\t\t\tspi_w(UIO_SECTOR_RD | ack);\n\t\t\t\tspi_block_write(buffer[disk] + offset, fio_size, sz);\n\t\t\t\tDisableIO();\n\n\t\t\t\tif (sd_image[disk].type == 2)\n\t\t\t\t{\n\t\t\t\t\tbuffer_lba[disk] = -1;\n\t\t\t\t}\n\t\t\t\telse if (done && (lba + blks - buffer_lba[disk]) == buf_n)\n\t\t\t\t{\n\t\t\t\t\tdiskled_on();\n\t\t\t\t\tlba += blks;\n\t\t\t\t\tif (blksz == 2352 && is_psx())\n\t\t\t\t\t{\n\t\t\t\t\t\tpsx_read_cd(buffer[disk], lba, buf_n);\n\t\t\t\t\t\tbuffer_lba[disk] = lba;\n\t\t\t\t\t}\n\t\t\t\t\telse if (blksz == 2352 && is_cdi())\n\t\t\t\t\t{\n\t\t\t\t\t\tcdi_read_cd(buffer[disk], lba, buf_n);\n\t\t\t\t\t\tbuffer_lba[disk] = lba;\n\t\t\t\t\t}\n\t\t\t\t\telse if (FileSeek(&sd_image[disk], lba * blksz, SEEK_SET) &&\n\t\t\t\t\t\tFileReadAdv(&sd_image[disk], buffer[disk], sizeof(buffer[disk])))\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer_lba[disk] = lba;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmemset(buffer[disk], 0, sizeof(buffer[disk]));\n\t\t\t\t\t\tbuffer_lba[disk] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\n\tif (is_neogeo() && (!rtc_timer || CheckTimer(rtc_timer)))\n\t{\n\t\t// Update once per minute should be enough\n\t\trtc_timer = GetTimer(60000);\n\t\tsend_rtc(1);\n\t}\n\n\tif (is_archie()) archie_poll();\n\tif (core_type == CORE_TYPE_SHARPMZ) sharpmz_poll();\n\n\tstatic uint8_t leds = 0;\n\n\tif (use_ps2ctl && !is_minimig() && !is_archie())\n\t{\n\t\tleds |= (KBD_LED_FLAG_STATUS | KBD_LED_CAPS_CONTROL);\n\n\t\tuint8_t kbd_ctl, mouse_ctl;\n\t\tuint8_t ps2ctl = user_io_ps2_ctl(&kbd_ctl, &mouse_ctl);\n\n\t\tif (ps2ctl & 1)\n\t\t{\n\t\t\tstatic uint8_t cmd = 0;\n\t\t\tstatic uint8_t byte = 0;\n\n\t\t\tprintf(\"kbd_ctl = 0x%02X\\n\", kbd_ctl);\n\t\t\tif (!byte)\n\t\t\t{\n\t\t\t\tcmd = kbd_ctl;\n\n\t\t\t\tswitch (cmd)\n\t\t\t\t{\n\t\t\t\tcase 0xff:\n\t\t\t\t\tps2_kbd_scan_set = 2;\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tkbd_reply(0xAA);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf2:\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tkbd_reply(0xAB);\n\t\t\t\t\tkbd_reply(0x83);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf0: // scan get/set\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tbyte++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf6: // set default parameters\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tps2_kbd_scan_set = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf3: // set type rate\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tbyte++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf4:\n\t\t\t\tcase 0xf5:\n\t\t\t\tcase 0xfa:\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xed:\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tbyte++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xee:\n\t\t\t\t\tkbd_reply(0xEE);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tkbd_reply(0xFE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (cmd)\n\t\t\t\t{\n\t\t\t\tcase 0xed:\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tbyte = 0;\n\t\t\t\t\tif (kbd_ctl & 4) leds |= KBD_LED_CAPS_STATUS;\n\t\t\t\t\telse leds &= ~KBD_LED_CAPS_STATUS;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf0:\n\t\t\t\t\tbyte = 0;\n\t\t\t\t\tif (kbd_ctl <= 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\t\tif (!kbd_ctl) kbd_reply(ps2_kbd_scan_set); // get\n\t\t\t\t\t\telse ps2_kbd_scan_set = kbd_ctl; // set\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tkbd_reply(0xFE); // RESEND\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf3: // set type rate\n\t\t\t\t\tkbd_reply(0xFA);\n\t\t\t\t\tbyte = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbyte = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ps2ctl & 2)\n\t\t{\n\t\t\tstatic uint8_t cmd = 0;\n\t\t\tstatic uint8_t byte = 0;\n\n\t\t\tprintf(\"mouse_ctl = 0x%02X\\n\", mouse_ctl);\n\t\t\tif (!byte)\n\t\t\t{\n\t\t\t\tcmd = mouse_ctl;\n\t\t\t\tswitch (cmd)\n\t\t\t\t{\n\t\t\t\tcase 0xe8:\n\t\t\t\tcase 0xf3:\n\t\t\t\t\tmouse_reply(0xFA);\n\t\t\t\t\tbyte++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xf2:\n\t\t\t\t\tmouse_reply(0xFA);\n\t\t\t\t\tmouse_reply(0x00);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xe6:\n\t\t\t\tcase 0xea:\n\t\t\t\tcase 0xf0:\n\t\t\t\tcase 0xf4:\n\t\t\t\tcase 0xf5:\n\t\t\t\tcase 0xf6:\n\t\t\t\t\tmouse_reply(0xFA);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xe9:\n\t\t\t\t\tmouse_reply(0xFA);\n\t\t\t\t\tmouse_reply(0x00);\n\t\t\t\t\tmouse_reply(0x00);\n\t\t\t\t\tmouse_reply(0x00);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xff:\n\t\t\t\t\tmouse_reply(0xFA);\n\t\t\t\t\tmouse_reply(0xAA);\n\t\t\t\t\tmouse_reply(0x00);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmouse_reply(0xFE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (cmd)\n\t\t\t\t{\n\t\t\t\tcase 0xf3:\n\t\t\t\tcase 0xe8:\n\t\t\t\t\tmouse_reply(0xFA);\n\t\t\t\t\tbyte = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbyte = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (CheckTimer(led_timer) && !is_menu())\n\t{\n\t\tled_timer = GetTimer(LED_FREQ);\n\t\tif (!use_ps2ctl)\n\t\t{\n\t\t\tuint16_t s = user_io_kbdled_get_status();\n\t\t\tif (s & 0x100) use_ps2ctl = 1;\n\t\t\tif (!use_ps2ctl) leds = (uint8_t)s;\n\t\t}\n\n\t\tif ((leds & KBD_LED_FLAG_MASK) != KBD_LED_FLAG_STATUS) leds = 0;\n\n\t\tif ((keyboard_leds & KBD_LED_CAPS_MASK) != (leds & KBD_LED_CAPS_MASK))\n\t\t\tset_kbdled(HID_LED_CAPS_LOCK, (leds & KBD_LED_CAPS_CONTROL) ? leds & KBD_LED_CAPS_STATUS : caps_status);\n\n\t\tif ((keyboard_leds & KBD_LED_NUM_MASK) != (leds & KBD_LED_NUM_MASK))\n\t\t\tset_kbdled(HID_LED_NUM_LOCK, (leds & KBD_LED_NUM_CONTROL) ? leds & KBD_LED_NUM_STATUS : num_status);\n\n\t\tif ((keyboard_leds & KBD_LED_SCRL_MASK) != (leds & KBD_LED_SCRL_MASK))\n\t\t\tset_kbdled(HID_LED_SCROLL_LOCK, (leds & KBD_LED_SCRL_CONTROL) ? leds & KBD_LED_SCRL_STATUS : scrl_status);\n\n\t\tkeyboard_leds = leds;\n\n\t\tuint8_t info_n = spi_uio_cmd(UIO_INFO_GET);\n\t\tif (info_n) show_core_info(info_n);\n\t}\n\n\tif (!res_timer)\n\t{\n\t\tres_timer = GetTimer(1000);\n\t}\n\telse if (CheckTimer(res_timer))\n\t{\n\t\tif (is_menu())\n\t\t{\n\t\t\tstatic int got_cfg = 0;\n\t\t\tif (!got_cfg)\n\t\t\t{\n\t\t\t\tspi_uio_cmd_cont(UIO_GET_OSDMASK);\n\t\t\t\tsdram_cfg = spi_w(0);\n\t\t\t\tDisableIO();\n\n\t\t\t\tif (sdram_cfg & 0x8000)\n\t\t\t\t{\n\t\t\t\t\tgot_cfg = 1;\n\t\t\t\t\tprintf(\"*** Got SDRAM module type: %d\\n\", sdram_cfg & 7);\n\t\t\t\t\tswitch (user_io_get_sdram_cfg() & 7)\n\t\t\t\t\t{\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tsdram_sz(3);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tsdram_sz(2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tsdram_sz(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsdram_sz(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres_timer = GetTimer(500);\n\t\tif (!minimig_get_adjust())\n\t\t{\n\t\t\tif (is_minimig()) minimig_adjust_vsize(0);\n\t\t\tvideo_mode_adjust();\n\t\t}\n\t}\n\n\tstatic int prev_coldreset_req = 0;\n\tstatic uint32_t reset_timer = 0;\n\tif (!prev_coldreset_req && coldreset_req)\n\t{\n\t\treset_timer = GetTimer(1000);\n\t}\n\n\tif (!coldreset_req && prev_coldreset_req)\n\t{\n\t\tfpga_load_rbf(\"menu.rbf\");\n\t}\n\n\tprev_coldreset_req = coldreset_req;\n\tif (reset_timer && CheckTimer(reset_timer))\n\t{\n\t\treboot(1);\n\t}\n\n\tsave_volume();\n\n\tif (diskled_is_on && CheckTimer(diskled_timer))\n\t{\n\t\tfpga_set_led(0);\n\t\tdiskled_is_on = 0;\n\t}\n\n\tif (is_megacd()) mcd_poll();\n\tif (is_pce()) pcecd_poll();\n\tif (is_saturn()) saturn_poll();\n\tif (is_cdi()) cdi_poll();\n\tif (is_psx()) psx_poll();\n\tif (is_neogeo_cd()) neocd_poll();\n\tif (is_n64()) n64_poll();\n\tprocess_ss(0);\n}\n\nstatic void send_keycode(unsigned short key, int press)\n{\n\tif (is_pcxt())\n\t{\n\t\t//WIN+... we override this hotkey in the core.\n\t\tif (key == 125 || key == 126)\n\t\t{\n\t\t\twinkey_pressed = press;\n\t\t\treturn;\n\t\t}\n\t\tif (winkey_pressed)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\tif (is_minimig())\n\t{\n\t\tif (press > 1) return;\n\n\t\tuint32_t code = get_amiga_code(key);\n\t\tif (code == NONE) return;\n\n\t\tif (code & CAPS_TOGGLE)\n\t\t{\n\t\t\tif (press)\n\t\t\t{\n\t\t\t\t// send alternating make and break codes for caps lock\n\t\t\t\tif(caps_lock_toggle) code |= 0x80;\n\t\t\t\tcaps_lock_toggle ^= HID_LED_CAPS_LOCK;\n\t\t\t\tset_kbd_led(HID_LED_CAPS_LOCK, caps_lock_toggle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// amiga has \"break\" marker in msb\n\t\t\tif (!press) code |= 0x80;\n\t\t}\n\n\t\tcode &= 0xff;\n\t\tif (minimig_get_adjust())\n\t\t{\n\t\t\tif (code == 0x44)\n\t\t\t{\n\t\t\t\tminimig_set_adjust(0);\n\t\t\t\tres_timer = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (code == 0x45)\n\t\t\t{\n\t\t\t\tInfo(\"Canceled\");\n\t\t\t\tres_timer = 0;\n\t\t\t\tminimig_set_adjust(2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcode |= OSD;\n\t\t}\n\n\t\t// send immediately if possible\n\t\tif (CheckTimer(kbd_timer) && (kbd_fifo_w == kbd_fifo_r))\n\t\t{\n\t\t\tkbd_fifo_minimig_send(code);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tkbd_fifo_enqueue(code);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (is_archie())\n\t{\n\t\tif (press > 1) return;\n\n\t\tuint32_t code = get_archie_code(key);\n\t\tif (code == NONE) return;\n\n\t\t//WIN+...\n\t\tif (get_key_mod() & (RGUI | LGUI))\n\t\t{\n\t\t\tswitch (code)\n\t\t\t{\n\t\t\tcase 0x00: code = 0xf;  //ESC = BRAKE\n\t\t\t\tbreak;\n\n\t\t\tcase 0x11: code = 0x73; // 1 = Mouse extra 1\n\t\t\t\tbreak;\n\n\t\t\tcase 0x12: code = 0x74; // 2 = Mouse extra 2\n\t\t\t\tbreak;\n\n\t\t\tcase 0x13: code = 0x25; // 3 = KP#\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (code == 0 && (get_key_mod() & (RGUI | LGUI)))\n\t\t{\n\t\t\tcode = 0xF;\n\t\t}\n\t\tif (!press) code |= 0x8000;\n\t\tarchie_kbd(code);\n\t\treturn;\n\t}\n\n\tif (core_type == CORE_TYPE_8BIT)\n\t{\n\t\tuint32_t code = get_ps2_code(key);\n\t\tif (code == NONE) return;\n\n\t\t//pause\n\t\tif ((code & 0xff) == 0xE1)\n\t\t{\n\t\t\t// pause does not have a break code\n\t\t\tif (press != 1)\n\t\t\t{\n\t\t\t\t// Pause key sends E11477E1F014E077\n\t\t\t\tstatic const unsigned char c[] = { 0xe1, 0x14, 0x77, 0xe1, 0xf0, 0x14, 0xf0, 0x77, 0x00 };\n\t\t\t\tstatic const unsigned char c_set1[] = { 0xe1, 0x1d, 0x45, 0xe1, 0x9d, 0xc5, 0x00 };\n\t\t\t\tconst unsigned char *p = (ps2_kbd_scan_set == 1) ? c_set1 : c;\n\n\t\t\t\tspi_uio_cmd_cont(UIO_KEYBOARD);\n\n\t\t\t\tprintf(\"PS2 PAUSE CODE: \");\n\t\t\t\twhile (*p)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%x \", *p);\n\t\t\t\t\tspi8(*p++);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tDisableIO();\n\t\t\t}\n\t\t}\n\t\t// print screen\n\t\telse if ((code & 0xff) == 0xE2)\n\t\t{\n\t\t\tif (press <= 1)\n\t\t\t{\n\t\t\t\tstatic const unsigned char c[2][8] = {\n\t\t\t\t\t{ 0xE0, 0xF0, 0x7C, 0xE0, 0xF0, 0x12, 0x00, 0x00 },\n\t\t\t\t\t{ 0xE0, 0x12, 0xE0, 0x7C, 0x00, 0x00, 0x00, 0x00 }\n\t\t\t\t};\n\t\t\t\tstatic const unsigned char c_set1[2][8] = {\n\t\t\t\t\t{ 0xE0, 0xB7, 0xE0, 0xAA, 0x00, 0x00, 0x00, 0x00 },\n\t\t\t\t\t{ 0xE0, 0x2A, 0xE0, 0x37, 0x00, 0x00, 0x00, 0x00 }\n\t\t\t\t};\n\n\t\t\t\tconst unsigned char *p = (ps2_kbd_scan_set == 1) ? c_set1[press] : c[press];\n\n\t\t\t\tspi_uio_cmd_cont(UIO_KEYBOARD);\n\n\t\t\t\tprintf(\"PS2 PRINT CODE: \");\n\t\t\t\twhile (*p)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%x \", *p);\n\t\t\t\t\tspi8(*p++);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tDisableIO();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (press > 1 && !use_ps2ctl) return;\n\n\t\t\tspi_uio_cmd_cont(UIO_KEYBOARD);\n\n\t\t\t// prepend extended code flag if required\n\t\t\tif (code & EXT) spi8(0xe0);\n\n\t\t\t// prepend break code if required\n            if (!press)\n            {\n                if (ps2_kbd_scan_set == 1)\n                        code |= 0x80;\n                    else\n                        spi8(0xf0);\n            }\n\t\t\t// send code itself\n\t\t\tspi8(code & 0xff);\n\n\t\t\tDisableIO();\n\t\t}\n\t}\n\n\tif (core_type == CORE_TYPE_SHARPMZ)\n\t{\n\t\tuint32_t code = get_ps2_code(key);\n\t\tif (code == NONE) return;\n\n\t\t{\n\t\t\tif (press > 1 && !use_ps2ctl) return;\n\n\t\t\tspi_uio_cmd_cont(UIO_KEYBOARD);\n\n\t\t\t// prepend extended code flag if required\n\t\t\tif (code & EXT) spi8(0xe0);\n\n\t\t\t// prepend break code if required\n\t\t\tif (!press) spi8(0xf0);\n\n\t\t\t// send code itself\n\t\t\tspi8(code & 0xff);\n\n\t\t\tDisableIO();\n\t\t}\n\t}\n}\n\nvoid user_io_mouse(unsigned char b, int16_t x, int16_t y, int16_t w)\n{\n\tif (osd_is_visible && !is_menu()) return;\n\n\tswitch (core_type)\n\t{\n\tcase CORE_TYPE_8BIT:\n\t\tif (is_minimig())\n\t\t{\n\t\t\tspi_uio_cmd_cont(UIO_MOUSE);\n\t\t\tspi8((x < -127) ? -127 : (x > 127) ? 127 : x);\n\t\t\tspi8((y < -127) ? -127 : (y > 127) ? 127 : y);\n\t\t\tspi8(b & 0x07);\n\t\t\tspi8((w < -127) ? -127 : (w > 127) ? 127 : w);\n\t\t\tDisableIO();\n\t\t}\n\t\telse if (is_archie())\n\t\t{\n\t\t\tarchie_mouse(b, x, y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunsigned char ps2_mouse[3];\n\n\t\t\t// PS2 format:\n\t\t\t// YOvfl, XOvfl, dy8, dx8, 1, mbtn, rbtn, lbtn\n\t\t\t// dx[7:0]\n\t\t\t// dy[7:0]\n\t\t\tps2_mouse[0] = (b & 7) | 8;\n\n\t\t\t// ------ X axis -----------\n\t\t\t// store sign bit in first byte\n\t\t\tps2_mouse[0] |= (x < 0) ? 0x10 : 0x00;\n\t\t\tif (x < -255)\n\t\t\t{\n\t\t\t\t// min possible value + overflow flag\n\t\t\t\tps2_mouse[0] |= 0x40;\n\t\t\t\tps2_mouse[1] = 1; // -255\n\t\t\t}\n\t\t\telse if (x > 255)\n\t\t\t{\n\t\t\t\t// max possible value + overflow flag\n\t\t\t\tps2_mouse[0] |= 0x40;\n\t\t\t\tps2_mouse[1] = 255;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tps2_mouse[1] = (char)x;\n\t\t\t}\n\n\t\t\t// ------ Y axis -----------\n\t\t\t// store sign bit in first byte\n\t\t\ty = -y;\n\t\t\tps2_mouse[0] |= (y < 0) ? 0x20 : 0x00;\n\t\t\tif (y < -255)\n\t\t\t{\n\t\t\t\t// min possible value + overflow flag\n\t\t\t\tps2_mouse[0] |= 0x80;\n\t\t\t\tps2_mouse[2] = 1; // -255;\n\t\t\t}\n\t\t\telse if (y > 255)\n\t\t\t{\n\t\t\t\t// max possible value + overflow flag\n\t\t\t\tps2_mouse[0] |= 0x80;\n\t\t\t\tps2_mouse[2] = 255;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tps2_mouse[2] = (char)y;\n\t\t\t}\n\n\t\t\tif (w > 63) w = 63;\n\t\t\telse if (w < -63) w = -63;\n\n\t\t\t// collect movement info and send at predefined rate\n\t\t\tif (is_menu() && !video_fb_state()) printf(\"PS2 MOUSE: %x %d %d %d\\n\", ps2_mouse[0], ps2_mouse[1], ps2_mouse[2], w);\n\n\t\t\tif (!osd_is_visible)\n\t\t\t{\n\t\t\t\tspi_uio_cmd_cont(UIO_MOUSE);\n\t\t\t\tspi_w(ps2_mouse[0] | ((w & 0x7f) << 8));\n\t\t\t\tspi_w(ps2_mouse[1] | ((((uint16_t)b) << 5) & 0xF00));\n\t\t\t\tspi_w(ps2_mouse[2] | ((((uint16_t)b) << 1) & 0x100));\n\t\t\t\tDisableIO();\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}\n\n/* usb modifer bits:\n0     1     2    3    4     5     6    7\nLCTRL LSHIFT LALT LGUI RCTRL RSHIFT RALT RGUI\n*/\n#define EMU_BTN1  (0+(keyrah*4))  // left control\n#define EMU_BTN2  (1+(keyrah*4))  // left shift\n#define EMU_BTN3  (2+(keyrah*4))  // left alt\n#define EMU_BTN4  (3+(keyrah*4))  // left gui (usually windows key)\n\nvoid user_io_check_reset(unsigned short modifiers, char useKeys)\n{\n\tunsigned short combo[] =\n\t{\n\t\t0x45,  // lctrl+lalt+ralt\n\t\t0x89,  // lctrl+lgui+rgui\n\t\t0x105, // lctrl+lalt+del\n\t};\n\n\tif (useKeys >= (sizeof(combo) / sizeof(combo[0]))) useKeys = 0;\n\n\tif ((modifiers & ~2) == combo[(uint)useKeys])\n\t{\n\t\tif (modifiers & 2) // with lshift - cold reset\n\t\t{\n\t\t\tcoldreset_req = 1;\n\t\t}\n\t\telse\n\t\tswitch (core_type)\n\t\t{\n\t\tcase CORE_TYPE_8BIT:\n\t\t\tif(is_minimig()) minimig_reset();\n\t\t\telse kbd_reset = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tcoldreset_req = 0;\n\t\tkbd_reset = 0;\n\t}\n}\n\nvoid user_io_osd_key_enable(char on)\n{\n\t//printf(\"OSD is now %s\\n\", on ? \"visible\" : \"invisible\");\n\tosd_is_visible = on;\n\tinput_switch(-1);\n}\n\nvoid user_io_kbd(uint16_t key, int press)\n{\n\tstatic int block_F12 = 0;\n\n\tif(is_menu()) spi_uio_cmd(UIO_KEYBOARD); //ping the Menu core to wakeup\n\n\t// Win+PrnScr or Alt/Win+ScrLk - screen shot\n\tbool key_WinPrnScr = (key == KEY_SYSRQ && (get_key_mod() & (RGUI | LGUI)));\n\t// Excluding scroll lock for PS/2 so Win+ScrLk can be used to change the emu mode.\n\tbool key_AltWinScrLk = (key == KEY_SCROLLLOCK && (get_key_mod() & (LALT | RALT | RGUI | LGUI))) && !use_ps2ctl;\n\tif (key_WinPrnScr || key_AltWinScrLk)\n\t{\n\t\tint shift = (get_key_mod() & LSHIFT);\n\t\tif (press == 1)\n\t\t{\n\t\t\tprintf(\"print key pressed - do screen shot\\n\");\n\t\t\tuser_io_screenshot(nullptr,!shift);\n\t\t}\n\t}\n\telse\n\tif (key == KEY_MUTE)\n\t{\n\t\tif (press == 1 && hasAPI1_5()) set_volume(0);\n\t}\n\telse\n\tif (key == KEY_VOLUMEDOWN)\n\t{\n\t\tif (press && hasAPI1_5()) set_volume(-1);\n\t}\n\telse\n\tif (key == KEY_VOLUMEUP)\n\t{\n\t\tif (press && hasAPI1_5()) set_volume(1);\n\t}\n\telse\n\tif (key == 0xBE)\n\t{\n\t\tif (press) setBrightness(BRIGHTNESS_DOWN, 0);\n\t}\n\telse\n\tif (key == 0xBF)\n\t{\n\t\tif (press) setBrightness(BRIGHTNESS_UP, 0);\n\t}\n\telse\n\tif (key == KEY_F2 && osd_is_visible)\n\t{\n\t\tif (press == 1) cfg.rbf_hide_datecode = !cfg.rbf_hide_datecode;\n\t\tPrintDirectory();\n\t}\n\telse\n\t{\n\t\tif (key)\n\t\t{\n\t\t\tuint32_t code = get_ps2_code(key);\n\t\t\tif (!press)\n\t\t\t{\n\t\t\t\tif (is_menu() && !video_fb_state()) printf(\"PS2 code(break)%s for core: %d(0x%X)\\n\", (code & EXT) ? \"(ext)\" : \"\", code & 255, code & 255);\n\n\t\t\t\tif (key == KEY_MENU) key = KEY_F12;\n\t\t\t\tif (key != KEY_F12 || !block_F12)\n\t\t\t\t{\n\t\t\t\t\tif (osd_is_visible) menu_key_set(UPSTROKE | key);\n\n\t\t\t\t\t// these modifiers should be passed to core even if OSD is open or they will get stuck!\n\t\t\t\t\tif (!osd_is_visible || key == KEY_LEFTALT || key == KEY_RIGHTALT || key == KEY_LEFTMETA || key == KEY_RIGHTMETA) send_keycode(key, press);\n\t\t\t\t}\n\t\t\t\tif (key == KEY_F12) block_F12 = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (is_menu() && !video_fb_state()) printf(\"PS2 code(make)%s for core: %d(0x%X)\\n\", (code & EXT) ? \"(ext)\" : \"\", code & 255, code & 255);\n\t\t\t\tif (!osd_is_visible && !is_menu() && key == KEY_MENU && press == 3) open_joystick_setup();\n\t\t\t\telse if ((has_menu() || osd_is_visible || (get_key_mod() & (LALT | RALT | RGUI | LGUI))) && (((key == KEY_F12) && ((!is_x86() && !is_pcxt() && !is_archie()) || (get_key_mod() & (RGUI | LGUI)))) || key == KEY_MENU))\n\t\t\t\t{\n\t\t\t\t\tblock_F12 = 1;\n\t\t\t\t\tif (press == 1) menu_key_set(KEY_F12);\n\t\t\t\t}\n\t\t\t\telse if (osd_is_visible)\n\t\t\t\t{\n\t\t\t\t\tif (key == KEY_MENU) key = KEY_F12;\n\t\t\t\t\tif (key == KEY_F12) block_F12 = 1;\n\t\t\t\t\tif (press == 1) menu_key_set(key);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// When ps2ctl is set then the RGUI or LGUI key must be held in addition\n\t\t\t\t\t// to the EMU_SWITCH_1 or EMU_SWITCH_2. This allows for cores such as AO486\n\t\t\t\t\t// to pass through the Scroll Lock and Num Lock keys.\n\t\t\t\t\tbool ps2ctl_modifier = (get_key_mod() & (RGUI | LGUI)) || !use_ps2ctl;\n\t\t\t\t\tbool key_EMU_SWITCH_1 = (code & EMU_SWITCH_1) && ps2ctl_modifier;\n\t\t\t\t\tbool key_EMU_SWITCH_2 = (code & EMU_SWITCH_2) && ps2ctl_modifier && !is_archie();\n\n\t\t\t\t\tif (( key_EMU_SWITCH_1 || key_EMU_SWITCH_2 ) && !is_menu())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (press == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint mode = emu_mode;\n\n\t\t\t\t\t\t\t// all off: normal\n\t\t\t\t\t\t\t// num lock on, scroll lock on: mouse emu\n\t\t\t\t\t\t\t// num lock on, scroll lock off: joy0 emu\n\t\t\t\t\t\t\t// num lock off, scroll lock on: joy1 emu\n\n\t\t\t\t\t\t\tswitch (code & 0xff)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tif (!joy_force) mode = EMU_MOUSE;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tmode = EMU_JOY0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tmode = EMU_JOY1;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tif (!joy_force) mode = EMU_NONE;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (joy_force) mode = (mode == EMU_JOY0) ? EMU_JOY1 : EMU_JOY0;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmode = (mode + 1) & 3;\n\t\t\t\t\t\t\t\t\tif(cfg.kbd_nomouse && mode == EMU_MOUSE) mode = (mode + 1) & 3;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tset_emu_mode(mode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(key == KEY_MENU) key = KEY_F12;\n\t\t\t\t\t\tif(input_state()) send_keycode(key, press);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nunsigned char user_io_ext_idx(char *name, char* ext)\n{\n\tunsigned char idx = 0;\n\tprintf(\"Subindex of \\\"%s\\\" in \\\"%s\\\": \", name, ext);\n\n\tchar *p = strrchr(name, '.');\n\tif (p)\n\t{\n\t\tp++;\n\t\tchar e[4] = \"   \";\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif (!*p) break;\n\t\t\te[i] = *p++;\n\t\t}\n\n\t\twhile (*ext)\n\t\t{\n\t\t\tint found = 1;\n\t\t\tfor (int i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tif (ext[i] == '*') break;\n\t\t\t\tif (ext[i] != '?' && (toupper(ext[i]) != toupper(e[i]))) found = 0;\n\t\t\t}\n\n\t\t\tif (found)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", idx);\n\t\t\t\treturn idx;\n\t\t\t}\n\n\t\t\tif (strlen(ext) <= 3) break;\n\t\t\tidx++;\n\t\t\text += 3;\n\t\t}\n\t}\n\n\tprintf(\"not found! use 0\\n\");\n\treturn 0;\n}\n\nuint16_t user_io_get_sdram_cfg()\n{\n\treturn sdram_cfg;\n}\n\nstatic struct { const char *fmtstr; Imlib_Load_Error errno; } err_strings[] = {\n  {\"file '%s' does not exist\", IMLIB_LOAD_ERROR_FILE_DOES_NOT_EXIST},\n  {\"file '%s' is a directory\", IMLIB_LOAD_ERROR_FILE_IS_DIRECTORY},\n  {\"permission denied to read file '%s'\", IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_READ},\n  {\"no loader for the file format used in file '%s'\", IMLIB_LOAD_ERROR_NO_LOADER_FOR_FILE_FORMAT},\n  {\"path for file '%s' is too long\", IMLIB_LOAD_ERROR_PATH_TOO_LONG},\n  {\"a component of path '%s' does not exist\", IMLIB_LOAD_ERROR_PATH_COMPONENT_NON_EXISTANT},\n  {\"a component of path '%s' is not a directory\", IMLIB_LOAD_ERROR_PATH_COMPONENT_NOT_DIRECTORY},\n  {\"path '%s' has too many symbolic links\", IMLIB_LOAD_ERROR_TOO_MANY_SYMBOLIC_LINKS},\n  {\"ran out of file descriptors trying to access file '%s'\", IMLIB_LOAD_ERROR_OUT_OF_FILE_DESCRIPTORS},\n  {\"denied write permission for file '%s'\", IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_WRITE},\n  {\"out of disk space writing to file '%s'\", IMLIB_LOAD_ERROR_OUT_OF_DISK_SPACE},\n  {(const char *)NULL, (Imlib_Load_Error) 0}\n};\n\nstatic void print_imlib_load_error (Imlib_Load_Error err, const char *filepath) {\n  int i;\n  for (i = 0; err_strings[i].fmtstr != NULL; i++) {\n    if (err == err_strings[i].errno) {\n\tprintf(\"Screenshot Error (%d): \",err);\n\tprintf(err_strings[i].fmtstr,filepath);\n\tprintf(\"\\n\");\n      return ;\n    }\n  }\n  /* Unrecognised error */\n    printf(\"Screenshot Error (%d): unrecognized error accessing file '%s'\\n\",err,filepath);\n  return ;\n}\n\nbool user_io_screenshot(const char *pngname, int rescale)\n{\n\tmister_scaler *ms = mister_scaler_init();\n\tif (ms == NULL)\n\t{\n\t\tprintf(\"problem with scaler, maybe not a new enough version\\n\");\n\t\tInfo(\"Scaler not compatible\");\n\t\treturn false;\n\t}\n\telse\n\t{\n    int scwidth = ms->output_width;\n    int scheight = ms->output_height;\n\n    if (video_get_rotated())\n    {\n\n      //If the video is rotated, the scaled output resolution results in a squished image.\n      //Calculate the scaled output res using the original AR\n      scwidth = scheight * ((float)ms->width/ms->height);\n    }\n\n\t\tconst char *basename = last_filename;\n\t\tif( pngname && *pngname )\n\t\t\tbasename = pngname;\n\t\tunsigned char *outputbuf = (unsigned char *)calloc(ms->width*ms->height * 4, 1);\n\t\t// read the image into the outpubuf - RGBA format\n\t\tmister_scaler_read_32(ms,outputbuf);\n\t\t// using_data will keep a pointer and dispose of the outbuf\n\t\tImlib_Image im = imlib_create_image_using_data(ms->width,ms->height,(unsigned int *)outputbuf);\n\t\timlib_context_set_image(im);\n\n\t\tstatic char filename[1024];\n\t\tFileGenerateScreenshotName(basename, filename, 1024);\n\n\t\t/* do we want to save a rescaled image? */\n\t\tif (rescale)\n\t\t{\n\t\t\tImlib_Image im_scaled=imlib_create_cropped_scaled_image(0,0,ms->width,ms->height,scwidth,scheight);\n\t\t\timlib_free_image_and_decache();\n\t\t\timlib_context_set_image(im_scaled);\n\t\t}\n\t\tImlib_Load_Error error;\n\t\timlib_save_image_with_error_return(getFullPath(filename),&error);\n\t\tif (error != IMLIB_LOAD_ERROR_NONE)\n\t\t{\n\t\t\tprint_imlib_load_error (error, filename);\n\t\t\tInfo(\"error in saving png\");\n\t\t\treturn false;\n\t\t}\n\t\timlib_free_image_and_decache();\n\t\tmister_scaler_free(ms);\n\t\tfree(outputbuf);\n\t\tchar msg[1024];\n\t\tsnprintf(msg, 1024, \"Screen saved to\\n%s\", filename + strlen(SCREENSHOT_DIR\"/\"));\n\t\tInfo(msg);\n\t}\n\treturn true;\n}\n\nvoid user_io_screenshot_cmd(const char *cmd)\n{\n\tif( strncmp( cmd, \"screenshot\", 10 ))\n\t{\n\t\treturn;\n\t}\n\n\tcmd += 10;\n\twhile( *cmd != '\\0' && ( *cmd == '\\t' || *cmd == ' ' || *cmd == '\\n' ) )\n\t\tcmd++;\n\n\tuser_io_screenshot(cmd,0);\n}\n"
        },
        {
          "name": "user_io.h",
          "type": "blob",
          "size": 9.787109375,
          "content": "/*\n* user_io.h\n*\n*/\n\n#ifndef USER_IO_H\n#define USER_IO_H\n\n#include <inttypes.h>\n#include \"file_io.h\"\n\n#define UIO_STATUS      0x00\n#define UIO_BUT_SW      0x01\n\n// codes as used by minimig (amiga)\n#define UIO_JOYSTICK0   0x02  // also used by 8 bit\n#define UIO_JOYSTICK1   0x03  // -\"-\n#define UIO_MOUSE       0x04  // -\"-\n#define UIO_KEYBOARD    0x05  // -\"-\n#define UIO_KBD_OSD     0x06  // keycodes used by OSD only\n\n// 0x08 - 0x0F - core specific\n\n#define UIO_JOYSTICK2   0x10  // also used by minimig and 8 bit\n#define UIO_JOYSTICK3   0x11  // -\"-\n#define UIO_JOYSTICK4   0x12  // -\"-\n#define UIO_JOYSTICK5   0x13  // -\"-\n\n// codes as currently used by 8bit only\n#define UIO_GET_STRING  0x14\n#define UIO_SET_STATUS  0x15\n#define UIO_GET_SDSTAT  0x16  // read status of sd card emulation\n#define UIO_SECTOR_RD   0x17  // SD card sector read\n#define UIO_SECTOR_WR   0x18  // SD card sector write\n#define UIO_SET_SDCONF  0x19  // send SD card configuration (CSD, CID)\n#define UIO_ASTICK      0x1a\n#define UIO_SIO_IN      0x1b  // serial in\n#define UIO_SET_SDSTAT  0x1c  // set sd card status\n#define UIO_SET_SDINFO  0x1d  // send info about mounted image\n#define UIO_SET_STATUS2 0x1e  // 32bit status\n#define UIO_GET_KBD_LED 0x1f  // keyboard LEDs control\n#define UIO_SET_VIDEO   0x20\n#define UIO_PS2_CTL     0x21  // get PS2 control from supported cores\n#define UIO_RTC         0x22  // transmit RTC data to core\n#define UIO_GET_VRES    0x23  // get video resolution\n#define UIO_TIMESTAMP   0x24  // transmit seconds since Unix epoch\n#define UIO_LEDS        0x25  // control on-board LEDs\n#define UIO_AUDVOL      0x26  // Digital volume as a number of bits to shift to the right\n#define UIO_SETHEIGHT   0x27  // Set max scaled vertical resolution\n#define UIO_GETUARTFLG  0x28  // Get UART_FLG_*\n#define UIO_GET_STATUS  0x29  // Update status from the core\n#define UIO_SET_FLTCOEF 0x2A  // Set Scaler polyphase coefficients\n#define UIO_SET_FLTNUM  0x2B  // Set Scaler predefined filter\n#define UIO_GET_VMODE   0x2C  // Get video mode parameters\n#define UIO_SET_VPOS    0x2D  // Set video positions\n#define UIO_GET_OSDMASK 0x2E  // Get mask\n#define UIO_SET_FBUF    0x2F  // Set frame buffer for HPS output\n#define UIO_WAIT_VSYNC  0x30  // Wait for VSync\n#define UIO_SET_MEMSZ   0x31  // Send memory size to the core\n#define UIO_SET_GAMMA   0x32  // Enable/disable Gamma correction\n#define UIO_SET_GAMCURV 0x33  // Set Gamma curve\n#define UIO_CD_GET      0x34\n#define UIO_CD_SET      0x35\n#define UIO_INFO_GET    0x36\n#define UIO_SETWIDTH    0x37  // Set max scaled horizontal resolution\n#define UIO_SETSYNC     0x38\n#define UIO_SET_AFILTER 0x39\n#define UIO_SET_AR_CUST 0x3A\n#define UIO_SET_UART    0x3B\n#define UIO_CHK_UPLOAD  0x3C\n#define UIO_ASTICK_2    0x3D\n#define UIO_SHADOWMASK  0x3E\n#define UIO_GET_RUMBLE  0x3F\n#define UIO_GET_FB_PAR  0x40\n#define UIO_SET_YC_PAR  0x41\n\n// codes as used by 8bit for file loading from OSD\n#define FIO_FILE_TX     0x53\n#define FIO_FILE_TX_DAT 0x54\n#define FIO_FILE_INDEX  0x55\n#define FIO_FILE_INFO   0x56\n\n// ao486 direct memory access\n#define UIO_DMA_WRITE   0x61\n#define UIO_DMA_READ    0x62\n#define UIO_DMA_SDIO    0x63\n\n// ---- Minimig v2 constants -------\n#define UIO_MM2_WR      0xF0 //0x1c\n#define UIO_MM2_RST     0xF1 //0x08\n#define UIO_MM2_AUD     0xF2 //0x74\n#define UIO_MM2_CHIP    0xF3 //0x04\n#define UIO_MM2_CPU     0xF4 //0x14\n#define UIO_MM2_MEM     0xF5 //0x24\n#define UIO_MM2_VID     0xF6 //0x34\n#define UIO_MM2_FLP     0xF7 //0x44\n#define UIO_MM2_HDD     0xF8 //0x54\n#define UIO_MM2_JOY     0xF9 //0x64\n\n#define JOY_RIGHT       0x01\n#define JOY_LEFT        0x02\n#define JOY_DOWN        0x04\n#define JOY_UP          0x08\n#define JOY_BTN_SHIFT   4\n#define JOY_BTN1        0x10\n#define JOY_BTN2        0x20\n#define JOY_BTN3        0x40\n#define JOY_BTN4        0x80\n#define JOY_MOVE        (JOY_RIGHT|JOY_LEFT|JOY_UP|JOY_DOWN)\n\n// virtual gamepad buttons\n#define JOY_A      JOY_BTN1\n#define JOY_B      JOY_BTN2\n#define JOY_SELECT JOY_BTN3\n#define JOY_START  JOY_BTN4\n#define JOY_X      0x100\n#define JOY_Y      0x200\n#define JOY_L      0x400\n#define JOY_R      0x800\n#define JOY_L2     0x1000\n#define JOY_R2     0x2000\n#define JOY_L3     0x4000\n#define JOY_R3     0x8000\n\n// keyboard LEDs control\n#define KBD_LED_CAPS_CONTROL  0x01\n#define KBD_LED_CAPS_STATUS   0x02\n#define KBD_LED_CAPS_MASK     (KBD_LED_CAPS_CONTROL | KBD_LED_CAPS_STATUS)\n#define KBD_LED_NUM_CONTROL   0x04\n#define KBD_LED_NUM_STATUS    0x08\n#define KBD_LED_NUM_MASK      (KBD_LED_NUM_CONTROL | KBD_LED_NUM_STATUS)\n#define KBD_LED_SCRL_CONTROL  0x10\n#define KBD_LED_SCRL_STATUS   0x20\n#define KBD_LED_SCRL_MASK     (KBD_LED_SCRL_CONTROL | KBD_LED_SCRL_STATUS)\n#define KBD_LED_FLAG_MASK     0xC0\n#define KBD_LED_FLAG_STATUS   0x40\n\n#define BUTTON1                 0b0000000000000001\n#define BUTTON2                 0b0000000000000010\n#define CONF_VGA_SCALER         0b0000000000000100\n#define CONF_CSYNC              0b0000000000001000\n#define CONF_FORCED_SCANDOUBLER 0b0000000000010000\n#define CONF_YPBPR              0b0000000000100000\n#define CONF_AUDIO_96K          0b0000000001000000\n#define CONF_DVI                0b0000000010000000\n#define CONF_HDMI_LIMITED1      0b0000000100000000\n#define CONF_VGA_SOG            0b0000001000000000\n#define CONF_DIRECT_VIDEO       0b0000010000000000\n#define CONF_HDMI_LIMITED2      0b0000100000000000\n#define CONF_VGA_FB             0b0001000000000000\n#define CONF_DIRECT_VIDEO2      0b0010000000000000\n\n// core type value should be unlikely to be returned by broken cores\n#define CORE_TYPE_UNKNOWN   0x55\n#define CORE_TYPE_8BIT      0xa4   // generic core\n#define CORE_TYPE_SHARPMZ   0xa7   // Sharp MZ Series\n#define CORE_TYPE_8BIT2     0xa8   // generic core using dual SDRAM\n\n#define EMU_NONE  0\n#define EMU_MOUSE 1\n#define EMU_JOY0  2\n#define EMU_JOY1  3\n\nvoid user_io_init(const char *path, const char *xml);\nunsigned char user_io_core_type();\nvoid user_io_read_core_name();\nvoid user_io_poll();\nchar user_io_menu_button();\nchar user_io_user_button();\nvoid user_io_osd_key_enable(char);\nint user_io_get_kbd_reset();\nvoid user_io_set_kbd_reset(int reset);\n\nint substrcpy(char *d, const char *s, char idx);\n\nvoid user_io_read_confstr();\nchar *user_io_get_confstr(int index);\nint user_io_status_bits(const char *opt, int *s, int *e, int ex = 0, int single = 0);\nuint32_t user_io_status_mask(const char *opt);\nuint32_t user_io_hd_mask(const char *opt);\nuint32_t user_io_status_get(const char *opt, int ex = 0);\nvoid user_io_status_set(const char *opt, uint32_t value, int ex = 0);\nint user_io_status_save(const char *filename);\nvoid user_io_status_reset();\n\nuint32_t user_io_get_file_crc();\nint  user_io_file_mount(const char *name, unsigned char index = 0, char pre = 0, int pre_size = 0);\nvoid user_io_bufferinvalidate(unsigned char index);\nchar *user_io_make_filepath(const char *path, const char *filename);\nchar *user_io_get_core_name(int orig = 0);\nchar *user_io_get_core_name2();\nchar *user_io_get_core_path(const char *suffix = NULL, int recheck = 0);\nvoid user_io_name_override(const char* name, int samedir);\nchar has_menu();\n\nconst char *get_image_name(int i);\nfileTYPE *get_image(int i);\n\nint user_io_get_kbdemu();\nuint32_t user_io_get_uart_mode();\n\nvoid user_io_mouse(unsigned char b, int16_t x, int16_t y, int16_t w);\nvoid user_io_kbd(uint16_t key, int press);\nchar* user_io_create_config_name(int with_ver = 0);\nint user_io_get_joy_transl();\nvoid user_io_digital_joystick(unsigned char, uint64_t, int);\nvoid user_io_l_analog_joystick(unsigned char, char, char);\nvoid user_io_r_analog_joystick(unsigned char, char, char);\nvoid user_io_set_joyswap(int swap);\nint user_io_get_joyswap();\nchar user_io_osd_is_visible();\nvoid set_vga_fb(int enable);\nint get_vga_fb();\nvoid user_io_set_ini(int ini_num);\nvoid user_io_send_buttons(char);\nuint16_t user_io_get_sdram_cfg();\n\nint user_io_file_tx(const char* name, unsigned char index = 0, char opensave = 0, char mute = 0, char composite = 0, uint32_t load_addr = 0);\nint user_io_file_tx_a(const char* name, uint16_t index);\nunsigned char user_io_ext_idx(char *, char*);\nvoid user_io_set_index(unsigned char index);\nvoid user_io_set_aindex(uint16_t index);\nvoid user_io_set_download(unsigned char enable, int addr = 0);\nvoid user_io_file_tx_data(const uint8_t *addr, uint32_t len);\nvoid user_io_set_upload(unsigned char enable, int addr = 0);\nvoid user_io_file_rx_data(uint8_t *addr, uint32_t len);\nvoid user_io_file_info(const char *ext);\nint user_io_get_width();\n\nvoid user_io_check_reset(unsigned short modifiers, char useKeys);\n\nvoid user_io_rtc_reset();\n\nvoid user_io_screenshot_cmd(const char *cmd);\nbool user_io_screenshot(const char *pngname, int rescale);\n\nconst char* get_rbf_dir();\nconst char* get_rbf_name();\nconst char* get_rbf_path();\n\nuint16_t sdram_sz(int sz = -1);\nint user_io_is_dualsdr();\nuint16_t altcfg(int alt = -1);\n\nvoid MakeFile(const char * filename, const char * data);\nint GetUARTMode();\nvoid SetUARTMode(int mode);\nint GetMidiLinkMode();\nvoid SetMidiLinkMode(int mode);\nvoid ResetUART();\nconst uint32_t* GetUARTbauds(int mode);\nuint32_t GetUARTbaud(int mode);\nconst char* GetUARTbaud_label(int mode);\nconst char* GetUARTbaud_label(int mode, int idx);\nint GetUARTbaud_idx(int mode);\nuint32_t ValidateUARTbaud(int mode, uint32_t baud);\nchar * GetMidiLinkSoundfont();\nvoid user_io_store_filename(char *filename);\nint user_io_use_cheats();\n\nint process_ss(const char *rom_name, int enable = 1);\n\nvoid diskled_on();\n#define DISKLED_ON  diskled_on()\n#define DISKLED_OFF void()\n\nchar is_minimig();\nchar is_sharpmz();\nchar is_menu();\nchar is_x86();\nchar is_snes();\nchar is_sgb();\nchar is_neogeo();\nchar is_neogeo_cd();\nchar is_megacd();\nchar is_pce();\nchar is_archie();\nchar is_gba();\nchar is_c64();\nchar is_st();\nchar is_psx();\nchar is_cdi();\nchar is_arcade();\nchar is_saturn();\nchar is_pcxt();\nchar is_n64();\nchar is_uneon();\n\n#define HomeDir(x) user_io_get_core_path(x)\n#define CoreName user_io_get_core_name()\n#define CoreName2 user_io_get_core_name2()\n\n#endif // USER_IO_H\n"
        },
        {
          "name": "video.cpp",
          "type": "blob",
          "size": 93.0830078125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <linux/fb.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <linux/vt.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <math.h>\n\n#include \"hardware.h\"\n#include \"user_io.h\"\n#include \"spi.h\"\n#include \"cfg.h\"\n#include \"file_io.h\"\n#include \"mat4x4.h\"\n#include \"menu.h\"\n#include \"video.h\"\n#include \"input.h\"\n#include \"shmem.h\"\n#include \"smbus.h\"\n#include \"str_util.h\"\n#include \"profiling.h\"\n#include \"offload.h\"\n\n#include \"support.h\"\n#include \"lib/imlib2/Imlib2.h\"\n#include \"lib/md5/md5.h\"\n\n#define FB_SIZE  (1920*1080)\n#define FB_ADDR  (0x20000000 + (32*1024*1024)) // 512mb + 32mb(Core's fb)\n\n/*\n--  [2:0] : 011=8bpp(palette) 100=16bpp 101=24bpp 110=32bpp\n--  [3]   : 0=16bits 565 1=16bits 1555\n--  [4]   : 0=RGB  1=BGR (for 16/24/32 modes)\n--  [5]   : TBD\n*/\n\n#define FB_FMT_565  0b00100\n#define FB_FMT_1555 0b01100\n#define FB_FMT_888  0b00101\n#define FB_FMT_8888 0b00110\n#define FB_FMT_PAL8 0b00011\n#define FB_FMT_RxB  0b10000\n#define FB_EN       0x8000\n\n#define FB_DV_LBRD  3\n#define FB_DV_RBRD  6\n#define FB_DV_UBRD  2\n#define FB_DV_BBRD  2\n\n#define VRR_NONE     0x00\n#define VRR_FREESYNC 0x01\n#define VRR_VESA     0x02\n\nstatic int     use_vrr = 0;\nstatic uint8_t vrr_min_fr = 0;\nstatic uint8_t vrr_max_fr = 0;\n\nstatic volatile uint32_t *fb_base = 0;\nstatic int fb_enabled = 0;\nstatic int fb_width = 0;\nstatic int fb_height = 0;\nstatic int fb_num = 0;\nstatic int brd_x = 0;\nstatic int brd_y = 0;\n\nstatic int menu_bg = 0;\nstatic int menu_bgn = 0;\n\nstatic VideoInfo current_video_info;\n\nstatic int support_FHD = 0;\n\nyc_mode yc_modes[20];\n\nstruct vrr_cap_t\n{\n\tuint8_t active;\n\tuint8_t available;\n\tuint8_t min_fr;\n\tuint8_t max_fr;\n\tchar description[128];\n};\n\nstatic vrr_cap_t vrr_modes[3] = {\n\t{0, 0, 0, 0, \"None\"},\n\t{0, 0, 0, 0, \"AMD Freesync\"},\n\t{0, 0, 0, 0, \"Vesa Forum VRR\"},\n};\n\nstatic uint8_t last_vrr_mode = 0xFF;\nstatic float last_vrr_rate = 0.0f;\nstatic uint32_t last_vrr_vfp = 0;\nstatic uint8_t edid[256] = {};\n\nstruct vmode_t\n{\n\tuint32_t vpar[8];\n\tdouble Fpix;\n\tuint8_t vic_mode;\n\tuint8_t pr;\n};\n\nvmode_t vmodes[] =\n{\n\t{ { 1280, 110,  40, 220,  720,  5,  5, 20 },  74.25,  4, 0 }, //0  1280x720@60\n\t{ { 1024,  24, 136, 160,  768,  3,  6, 29 },  65,     0, 0 }, //1  1024x768@60\n\t{ {  720,  16,  62,  60,  480,  9,  6, 30 },  27,     3, 0 }, //2  720x480@60\n\t{ {  720,  12,  64,  68,  576,  5,  5, 39 },  27,    18, 0 }, //3  720x576@50\n\t{ { 1280,  48, 112, 248, 1024,  1,  3, 38 }, 108,     0, 0 }, //4  1280x1024@60\n\t{ {  800,  40, 128,  88,  600,  1,  4, 23 },  40,     0, 0 }, //5  800x600@60\n\t{ {  640,  16,  96,  48,  480, 10,  2, 33 },  25.175, 1, 0 }, //6  640x480@60\n\t{ { 1280, 440,  40, 220,  720,  5,  5, 20 },  74.25, 19, 0 }, //7  1280x720@50\n\t{ { 1920,  88,  44, 148, 1080,  4,  5, 36 }, 148.5,  16, 0 }, //8  1920x1080@60\n\t{ { 1920, 528,  44, 148, 1080,  4,  5, 36 }, 148.5,  31, 0 }, //9  1920x1080@50\n\t{ { 1366,  70, 143, 213,  768,  3,  3, 24 },  85.5,   0, 0 }, //10 1366x768@60\n\t{ { 1024,  40, 104, 144,  600,  1,  3, 18 },  48.96,  0, 0 }, //11 1024x600@60\n\t{ { 1920,  48,  32,  80, 1440,  2,  4, 38 }, 185.203, 0, 0 }, //12 1920x1440@60\n\t{ { 2048,  48,  32,  80, 1536,  2,  4, 38 }, 209.318, 0, 0 }, //13 2048x1536@60\n\t{ { 1280,  24,  16,  40, 1440,  3,  5, 33 }, 120.75,  0, 1 }, //14 2560x1440@60 (pr)\n};\n#define VMODES_NUM (sizeof(vmodes) / sizeof(vmodes[0]))\n\nvmode_t tvmodes[] =\n{\n\t{{ 640, 30, 60, 70, 240,  4, 4, 14 }, 12.587, 0, 0 }, //NTSC 15K\n\t{{ 640, 16, 96, 48, 480,  8, 4, 33 }, 25.175, 0, 0 }, //NTSC 31K\n\t{{ 640, 30, 60, 70, 288,  6, 4, 14 }, 12.587, 0, 0 }, //PAL 15K\n\t{{ 640, 16, 96, 48, 576,  2, 4, 42 }, 25.175, 0, 0 }, //PAL 31K\n};\n\n// named aliases for vmode_custom_t items\nstruct vmode_custom_param_t\n{\n\tuint32_t mode;\n\n\t// [1]\n\tuint32_t hact;\n\tuint32_t hfp;\n\tuint32_t hs;\n\tuint32_t hbp;\n\n\t// [5]\n\tuint32_t vact;\n\tuint32_t vfp;\n\tuint32_t vs;\n\tuint32_t vbp;\n\n\t// [9]\n\tuint32_t pll[12];\n\n\t// [21]\n\tuint32_t hpol;\n\tuint32_t vpol;\n\tuint32_t vic;\n\tuint32_t rb;\n\tuint32_t pr;\n\n\t// [26]\n\tuint32_t unused[6];\n};\n\nstruct vmode_custom_t\n{\n\tunion // anonymous\n\t{\n\t\tvmode_custom_param_t param;\n\t\tuint32_t item[32];\n\t};\n\n\tdouble Fpix;\n};\n\nstatic_assert(sizeof(vmode_custom_param_t) == sizeof(vmode_custom_t::item));\n\n// Static fwd decl\nstatic void video_fb_config();\nstatic void video_calculate_cvt(int horiz_pixels, int vert_pixels, float refresh_rate, int reduced_blanking, vmode_custom_t *vmode);\n\nstatic vmode_custom_t v_cur = {}, v_def = {}, v_pal = {}, v_ntsc = {};\nstatic int vmode_def = 0, vmode_pal = 0, vmode_ntsc = 0;\n\nstatic bool supports_pr()\n{\n\tstatic uint16_t video_version = 0xffff;\n\tif (video_version == 0xffff) video_version = spi_uio_cmd(UIO_SET_VIDEO) & 1;\n\treturn video_version != 0;\n}\n\nstatic bool supports_vrr()\n{\n\tstatic uint16_t video_version = 0xffff;\n\tif (video_version == 0xffff) video_version = spi_uio_cmd(UIO_SET_VIDEO) & 2;\n\treturn video_version != 0;\n}\n\nstatic uint32_t getPLLdiv(uint32_t div)\n{\n\tif (div & 1) return 0x20000 | (((div / 2) + 1) << 8) | (div / 2);\n\treturn ((div / 2) << 8) | (div / 2);\n}\n\nstatic int findPLLpar(double Fout, uint32_t *pc, uint32_t *pm, double *pko)\n{\n\tuint32_t c = 1;\n\twhile ((Fout*c) < 400) c++;\n\n\twhile (1)\n\t{\n\t\tdouble fvco = Fout*c;\n\t\tuint32_t m = (uint32_t)(fvco / 50);\n\t\tdouble ko = ((fvco / 50) - m);\n\n\t\tfvco = ko + m;\n\t\tfvco *= 50.f;\n\n\t\tif (ko && (ko <= 0.05f || ko >= 0.95f))\n\t\t{\n\t\t\tprintf(\"Fvco=%f, C=%d, M=%d, K=%f \", fvco, c, m, ko);\n\t\t\tif (fvco > 1500.f)\n\t\t\t{\n\t\t\t\tprintf(\"-> No exact parameters found\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tprintf(\"-> K is outside allowed range\\n\");\n\t\t\tc++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*pc = c;\n\t\t\t*pm = m;\n\t\t\t*pko = ko;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t//will never reach here\n\treturn 0;\n}\n\nstatic void setPLL(double Fout, vmode_custom_t *v)\n{\n\tPROFILE_FUNCTION();\n\n\tdouble Fpix;\n\tdouble fvco, ko;\n\tuint32_t m, c;\n\n\tprintf(\"Calculate PLL for %.4f MHz:\\n\", Fout);\n\n\tif (!findPLLpar(Fout, &c, &m, &ko))\n\t{\n\t\tc = 1;\n\t\twhile ((Fout*c) < 400) c++;\n\n\t\tfvco = Fout*c;\n\t\tm = (uint32_t)(fvco / 50);\n\t\tko = ((fvco / 50) - m);\n\n\t\t//Make sure K is in allowed range.\n\t\tif (ko <= 0.05f)\n\t\t{\n\t\t\tko = 0;\n\t\t}\n\t\telse if (ko >= 0.95f)\n\t\t{\n\t\t\tm++;\n\t\t\tko = 0;\n\t\t}\n\t}\n\n\tuint32_t k = ko ? (uint32_t)(ko * 4294967296) : 1;\n\n\tfvco = ko + m;\n\tfvco *= 50.f;\n\tFpix = fvco / c;\n\n\tprintf(\"Fvco=%f, C=%d, M=%d, K=%f(%u) -> Fpix=%f\\n\", fvco, c, m, ko, k, Fpix);\n\n\tv->item[9]  = 4;\n\tv->item[10] = getPLLdiv(m);\n\tv->item[11] = 3;\n\tv->item[12] = 0x10000;\n\tv->item[13] = 5;\n\tv->item[14] = getPLLdiv(c);\n\tv->item[15] = 9;\n\tv->item[16] = 2;\n\tv->item[17] = 8;\n\tv->item[18] = 7;\n\tv->item[19] = 7;\n\tv->item[20] = k;\n\n\tv->Fpix = Fpix;\n}\n\nstruct ScalerFilter\n{\n\tchar mode;\n\tchar filename[1023];\n};\n\nstatic ScalerFilter scaler_flt[3];\n\nstruct FilterPhase\n{\n\tshort t[4];\n};\n\nstatic constexpr int N_PHASES = 256;\n\nstruct VideoFilterDigest\n{\n\tVideoFilterDigest() { memset(md5, 0, sizeof(md5)); }\n\tbool operator!=(const VideoFilterDigest& other) { return memcmp(md5, other.md5, sizeof(md5)) != 0; }\n\tbool operator==(const VideoFilterDigest& other) { return memcmp(md5, other.md5, sizeof(md5)) == 0; }\n\n\tunsigned char md5[16];\n};\n\nstruct VideoFilter\n{\n\tbool is_adaptive;\n\tFilterPhase phases[N_PHASES];\n\tFilterPhase adaptive_phases[N_PHASES];\n\tVideoFilterDigest digest;\n};\n\nstatic VideoFilter scaler_flt_data[3];\n\nstatic bool scale_phases(FilterPhase out_phases[N_PHASES], FilterPhase *in_phases, int in_count)\n{\n\tif (!in_count)\n\t{\n\t\treturn false;\n\t}\n\n\tint dup = N_PHASES / in_count;\n\n\tif ((in_count * dup) != N_PHASES)\n\t{\n\t\treturn false;\n\t}\n\n\tfor (int i = 0; i < in_count; i++)\n\t{\n\t\tfor (int j = 0; j < dup; j++)\n\t\t{\n\t\t\tout_phases[(i * dup) + j] = in_phases[i];\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool read_video_filter(int type, VideoFilter *out)\n{\n\tPROFILE_FUNCTION();\n\n\tfileTextReader reader = {};\n\tFilterPhase phases[512];\n\tint count = 0;\n\tbool is_adaptive = false;\n\tint scale = 2;\n\n\tmemset(out, 0, sizeof(VideoFilter));\n\n\tstatic char filename[1024];\n\tsnprintf(filename, sizeof(filename), COEFF_DIR\"/%s\", scaler_flt[type].filename);\n\n\tif (FileOpenTextReader(&reader, filename))\n\t{\n\t\tconst char *line;\n\t\twhile ((line = FileReadLine(&reader)))\n\t\t{\n\t\t\tif (count == 0 && !strcasecmp(line, \"adaptive\"))\n\t\t\t{\n\t\t\t\tis_adaptive = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (count == 0 && !strcasecmp(line, \"10bit\"))\n\t\t\t{\n\t\t\t\tscale = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint phase[4];\n\t\t\tint n = sscanf(line, \"%d,%d,%d,%d\", &phase[0], &phase[1], &phase[2], &phase[3]);\n\t\t\tif (n == 4)\n\t\t\t{\n\t\t\t\tif (count >= (is_adaptive ? N_PHASES * 2 : N_PHASES)) return false; //too many\n\t\t\t\tphases[count].t[0] = phase[0] * scale;\n\t\t\t\tphases[count].t[1] = phase[1] * scale;\n\t\t\t\tphases[count].t[2] = phase[2] * scale;\n\t\t\t\tphases[count].t[3] = phase[3] * scale;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"Filter \\'%s\\', phases: %d adaptive: %s\\n\",\n\t\t\tscaler_flt[type].filename,\n\t\t\tis_adaptive ? count / 2 : count,\n\t\t\tis_adaptive ? \"true\" : \"false\" );\n\n\tbool valid = false;\n\tif (is_adaptive)\n\t{\n\t\tout->is_adaptive = true;\n\t\tvalid = scale_phases(out->phases, phases, count / 2);\n\t\tvalid = valid && scale_phases(out->adaptive_phases, phases + (count / 2), count / 2);\n\t}\n\telse if (count == 32 && !is_adaptive) // legacy\n\t{\n\t\tout->is_adaptive = false;\n\t\tvalid = scale_phases(out->phases, phases, 16);\n\t}\n\telse if (!is_adaptive)\n\t{\n\t\tout->is_adaptive = false;\n\t\tvalid = scale_phases(out->phases, phases, count);\n\t}\n\n\tif (!valid)\n\t{\n\t\t// Make a default NN filter in case of error\n\t\tout->is_adaptive = false;\n\t\tFilterPhase nn_phases[2] =\n\t\t{\n\t\t\t{ .t = { 0, 256, 0, 0 } },\n\t\t\t{ .t = { 0, 0, 256, 0 } }\n\t\t};\n\t\tscale_phases(out->phases, nn_phases, 2);\n\t}\n\n\tMD5Context ctx;\n\tMD5Init(&ctx);\n\tMD5Update(&ctx, (unsigned char *)&out->is_adaptive, sizeof(VideoFilter::is_adaptive));\n\tMD5Update(&ctx, (unsigned char *)out->phases, sizeof(VideoFilter::phases));\n\tMD5Update(&ctx, (unsigned char *)out->adaptive_phases, sizeof(VideoFilter::adaptive_phases));\n\tMD5Final(out->digest.md5, &ctx);\n\n\treturn valid;\n}\n\nstatic void send_phases_legacy(int addr, const FilterPhase phases[N_PHASES])\n{\n\tPROFILE_FUNCTION();\n\n\tfor (int idx = 0; idx < N_PHASES; idx += 16)\n\t{\n\t\tconst FilterPhase *p = &phases[idx];\n\t\tspi_w(((p->t[0] >> 1) & 0x1FF) | ((addr + 0) << 9));\n\t\tspi_w(((p->t[1] >> 1) & 0x1FF) | ((addr + 1) << 9));\n\t\tspi_w(((p->t[2] >> 1) & 0x1FF) | ((addr + 2) << 9));\n\t\tspi_w(((p->t[3] >> 1) & 0x1FF) | ((addr + 3) << 9));\n\t\taddr += 4;\n\t}\n}\n\nstatic void send_phases(int addr, const FilterPhase phases[N_PHASES], bool full_precision)\n{\n\tPROFILE_FUNCTION();\n\n\tconst int skip = full_precision ? 1 : 4;\n\tconst int shift = full_precision ? 0 : 1;\n\n\taddr *= full_precision ? (N_PHASES * 4) : (64 * 4);\n\n\tfor (int idx = 0; idx < N_PHASES; idx += skip)\n\t{\n\t\tconst FilterPhase *p = &phases[idx];\n\t\tspi_w(addr + 0); spi_w((p->t[0] >> shift) & 0x3FF);\n\t\tspi_w(addr + 1); spi_w((p->t[1] >> shift) & 0x3FF);\n\t\tspi_w(addr + 2); spi_w((p->t[2] >> shift) & 0x3FF);\n\t\tspi_w(addr + 3); spi_w((p->t[3] >> shift) & 0x3FF);\n\t\taddr += 4;\n\t}\n}\n\nstatic VideoFilterDigest horiz_filter_digest, vert_filter_digest;\n\nstatic void send_video_filters(const VideoFilter *horiz, const VideoFilter *vert, int ver)\n{\n\tPROFILE_FUNCTION();\n\n\tspi_uio_cmd_cont(UIO_SET_FLTCOEF);\n\n\tconst bool full_precision = (ver & 0x4) != 0;\n\n\tconst bool send_horiz = horiz_filter_digest != horiz->digest;\n\tconst bool send_vert = vert_filter_digest != vert->digest;\n\n\tswitch( ver & 0x3 )\n\t{\n\t\tcase 1:\n\t\t\tif (send_horiz) send_phases_legacy(0, horiz->phases);\n\t\t\tif (send_vert) send_phases_legacy(64, vert->phases);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (send_horiz) send_phases(0, horiz->phases, full_precision);\n\t\t\tif (send_vert) send_phases(1, vert->phases, full_precision);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (send_horiz) send_phases(0, horiz->phases, full_precision);\n\t\t\tif (send_vert) send_phases(1, vert->phases, full_precision);\n\n\t\t\tif (horiz->is_adaptive && send_horiz)\n\t\t\t{\n\t\t\t\tsend_phases(2, horiz->adaptive_phases, full_precision);\n\t\t\t}\n\t\t\telse if (vert->is_adaptive && send_vert)\n\t\t\t{\n\t\t\t\tsend_phases(3, vert->adaptive_phases, full_precision);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\thoriz_filter_digest = horiz->digest;\n\tvert_filter_digest = vert->digest;\n\n\tDisableIO();\n}\n\nstatic void set_vfilter(int force)\n{\n\tPROFILE_FUNCTION();\n\n\tstatic int last_flags = 0;\n\n\tint flt_flags = spi_uio_cmd_cont(UIO_SET_FLTNUM);\n\tif (!flt_flags || (!force && last_flags == flt_flags))\n\t{\n\t\tDisableIO();\n\t\treturn;\n\t}\n\n\tlast_flags = flt_flags;\n\tprintf(\"video_set_filter: flt_flags=%d\\n\", flt_flags);\n\n\tspi8(scaler_flt[0].mode);\n\tDisableIO();\n\n\tint vert_flt;\n\tif (current_video_info.interlaced) vert_flt = VFILTER_HORZ;\n\telse if ((flt_flags & 0x30) && scaler_flt[VFILTER_SCAN].mode) vert_flt = VFILTER_SCAN;\n\telse if (scaler_flt[VFILTER_VERT].mode) vert_flt = VFILTER_VERT;\n\telse vert_flt = VFILTER_HORZ;\n\n\tsend_video_filters(&scaler_flt_data[VFILTER_HORZ], &scaler_flt_data[vert_flt], flt_flags & 0xF);\n}\n\nstatic void setScaler()\n{\n\tPROFILE_FUNCTION();\n\n\tuint32_t arc[4] = {};\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tif (cfg.custom_aspect_ratio[i][0])\n\t\t{\n\t\t\tif (sscanf(cfg.custom_aspect_ratio[i], \"%u:%u\", &arc[i * 2], &arc[(i * 2) + 1]) != 2 || arc[i * 2] < 1 || arc[i * 2] > 4095 || arc[(i * 2) + 1] < 1 || arc[(i * 2) + 1] > 4095)\n\t\t\t{\n\t\t\t\tarc[(i * 2) + 0] = 0;\n\t\t\t\tarc[(i * 2) + 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tspi_uio_cmd_cont(UIO_SET_AR_CUST);\n\tfor (int i = 0; i < 4; i++) spi_w(arc[i]);\n\tDisableIO();\n\tset_vfilter(1);\n}\n\nint video_get_scaler_flt(int type)\n{\n\treturn scaler_flt[type].mode;\n}\n\nchar* video_get_scaler_coeff(int type, int only_name)\n{\n\tchar *path = scaler_flt[type].filename;\n\tif (only_name)\n\t{\n\t\tchar *p = strrchr(path, '/');\n\t\tif (p) return p + 1;\n\t}\n\treturn path;\n}\n\nstatic char scaler_cfg_path[128] = { 0 };\n\nstatic void video_save_scaler_cfg()\n{\n\tFileSaveConfig(scaler_cfg_path, &scaler_flt, sizeof(scaler_flt));\n}\n\nstatic void video_apply_scaler_flt(int type, int n)\n{\n\tscaler_flt[type].mode = (char)n;\n\tspi_uio_cmd8(UIO_SET_FLTNUM, scaler_flt[0].mode);\n\tset_vfilter(1);\n}\n\nvoid video_set_scaler_flt(int type, int n)\n{\n\tvideo_apply_scaler_flt(type, n);\n\tvideo_save_scaler_cfg();\n}\n\nvoid video_apply_scaler_coeff(int type, const char *name)\n{\n\tstrcpy(scaler_flt[type].filename, name);\n\tread_video_filter(type, &scaler_flt_data[type]);\n\tsetScaler();\n\tuser_io_send_buttons(1);\n}\n\nvoid video_set_scaler_coeff(int type, const char *name)\n{\n\tvideo_apply_scaler_coeff(type, name);\n\tvideo_save_scaler_cfg();\n}\n\nstatic void loadScalerCfg()\n{\n\tPROFILE_FUNCTION();\n\n\tif (FileLoadConfig(scaler_cfg_path, &scaler_flt, sizeof(scaler_flt)))\n\t{\n\t\tif (scaler_flt[0].mode > 1)\n\t\t{\n\t\t\tmemset(scaler_flt, 0, sizeof(scaler_flt));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (cfg.vfilter_default[0])\n\t\t{\n\t\t\tstrcpy(scaler_flt[VFILTER_HORZ].filename, cfg.vfilter_default);\n\t\t\tscaler_flt[VFILTER_HORZ].mode = 1;\n\t\t}\n\n\t\tif (cfg.vfilter_vertical_default[0])\n\t\t{\n\t\t\tstrcpy(scaler_flt[VFILTER_VERT].filename, cfg.vfilter_vertical_default);\n\t\t\tscaler_flt[VFILTER_VERT].mode = 1;\n\t\t}\n\n\t\tif (cfg.vfilter_scanlines_default[0])\n\t\t{\n\t\t\tstrcpy(scaler_flt[VFILTER_SCAN].filename, cfg.vfilter_scanlines_default);\n\t\t\tscaler_flt[VFILTER_SCAN].mode = 1;\n\t\t}\n\t}\n\n\tif (!read_video_filter(VFILTER_HORZ, &scaler_flt_data[VFILTER_HORZ])) memset(&scaler_flt[VFILTER_HORZ], 0, sizeof(scaler_flt[VFILTER_HORZ]));\n\tif (!read_video_filter(VFILTER_VERT, &scaler_flt_data[VFILTER_VERT])) memset(&scaler_flt[VFILTER_VERT], 0, sizeof(scaler_flt[VFILTER_VERT]));\n\tif (!read_video_filter(VFILTER_SCAN, &scaler_flt_data[VFILTER_SCAN])) memset(&scaler_flt[VFILTER_SCAN], 0, sizeof(scaler_flt[VFILTER_SCAN]));\n}\n\nstatic char active_gamma_cfg[1024] = { 0 };\nstatic char gamma_cfg[1024] = { 0 };\nstatic char has_gamma = 0; // set in video_init\n\nstatic void setGamma()\n{\n\tPROFILE_FUNCTION();\n\n\tif (!memcmp(active_gamma_cfg, gamma_cfg, sizeof(gamma_cfg))) return;\n\n\tfileTextReader reader = {};\n\tstatic char filename[1024];\n\n\tif (!has_gamma) return;\n\n\tsnprintf(filename, sizeof(filename), GAMMA_DIR\"/%s\", gamma_cfg + 1);\n\n\tif (FileOpenTextReader(&reader, filename))\n\t{\n\t\tspi_uio_cmd_cont(UIO_SET_GAMCURV);\n\n\t\tconst char *line;\n\t\tint index = 0;\n\t\twhile ((line = FileReadLine(&reader)))\n\t\t{\n\t\t\tint c0, c1, c2;\n\t\t\tint n = sscanf(line, \"%d,%d,%d\", &c0, &c1, &c2);\n\t\t\tif (n == 1)\n\t\t\t{\n\t\t\t\tc1 = c0;\n\t\t\t\tc2 = c0;\n\t\t\t\tn = 3;\n\t\t\t}\n\n\t\t\tif (n == 3)\n\t\t\t{\n\t\t\t\tspi_w((index << 8) | (c0 & 0xFF));\n\t\t\t\tspi_w((index << 8) | (c1 & 0xFF));\n\t\t\t\tspi_w((index << 8) | (c2 & 0xFF));\n\n\t\t\t\tindex++;\n\t\t\t\tif (index >= 256) break;\n\t\t\t}\n\t\t}\n\t\tDisableIO();\n\t\tspi_uio_cmd8(UIO_SET_GAMMA, gamma_cfg[0]);\n\t}\n\tmemcpy(active_gamma_cfg, gamma_cfg, sizeof(gamma_cfg));\n}\n\nint video_get_gamma_en()\n{\n\treturn has_gamma ? gamma_cfg[0] : -1;\n}\n\nchar* video_get_gamma_curve(int only_name)\n{\n\tchar *path = gamma_cfg + 1;\n\tif (only_name)\n\t{\n\t\tchar *p = strrchr(path, '/');\n\t\tif (p) return p + 1;\n\t}\n\treturn path;\n}\n\nstatic char gamma_cfg_path[1024] = { 0 };\nstatic void video_save_gamma_cfg()\n{\n\tFileSaveConfig(gamma_cfg_path, &gamma_cfg, sizeof(gamma_cfg));\n}\n\nstatic void video_apply_gamma_en(int n)\n{\n\tgamma_cfg[0] = (char)n;\n\tsetGamma();\n}\n\nvoid video_set_gamma_en(int n)\n{\n\tvideo_apply_gamma_en(n);\n\tvideo_save_gamma_cfg();\n}\n\nstatic void video_apply_gamma_curve(const char *name)\n{\n\tstrcpy(gamma_cfg + 1, name);\n\tsetGamma();\n\tuser_io_send_buttons(1);\n}\n\nvoid video_set_gamma_curve(const char *name)\n{\n\tvideo_apply_gamma_curve(name);\n\tvideo_save_gamma_cfg();\n}\n\n\nstatic void loadGammaCfg()\n{\n\tPROFILE_FUNCTION();\n\tif (FileLoadConfig(gamma_cfg_path, &gamma_cfg, sizeof(gamma_cfg) - 1))\n\t{\n\t\tif (gamma_cfg[0] > 1)\n\t\t{\n\t\t\tmemset(gamma_cfg, 0, sizeof(gamma_cfg));\n\t\t}\n\t}\n}\n\nstatic char shadow_mask_cfg[1024] = { 0 };\nstatic bool has_shadow_mask = false;\n\n#define SM_FLAG_2X      ( 1 << 1 )\n#define SM_FLAG_ROTATED ( 1 << 2 )\n#define SM_FLAG_ENABLED ( 1 << 3 )\n\n#define SM_FLAG(v) ( ( 0x0 << 13 ) | (v) )\n#define SM_VMAX(v) ( ( 0x1 << 13 ) | (v) )\n#define SM_HMAX(v) ( ( 0x2 << 13 ) | (v) )\n#define SM_LUT(v)  ( ( 0x3 << 13 ) | (v) )\n\nenum\n{\n\tSM_MODE_NONE = 0,\n\tSM_MODE_1X,\n\tSM_MODE_2X,\n\tSM_MODE_1X_ROTATED,\n\tSM_MODE_2X_ROTATED,\n\tSM_MODE_COUNT\n};\n\nstatic void setShadowMask()\n{\n\tPROFILE_FUNCTION();\n\n\tstatic char filename[1024];\n\thas_shadow_mask = 0;\n\n\tif (!spi_uio_cmd_cont(UIO_SHADOWMASK))\n\t{\n\t\tDisableIO();\n\t\treturn;\n\t}\n\n\thas_shadow_mask = 1;\n\tswitch (video_get_shadow_mask_mode())\n\t{\n\t\tdefault: spi_w(SM_FLAG(0)); break;\n\t\tcase SM_MODE_1X: spi_w(SM_FLAG(SM_FLAG_ENABLED)); break;\n\t\tcase SM_MODE_2X: spi_w(SM_FLAG(SM_FLAG_ENABLED | SM_FLAG_2X)); break;\n\t\tcase SM_MODE_1X_ROTATED: spi_w(SM_FLAG(SM_FLAG_ENABLED | SM_FLAG_ROTATED)); break;\n\t\tcase SM_MODE_2X_ROTATED: spi_w(SM_FLAG(SM_FLAG_ENABLED | SM_FLAG_ROTATED | SM_FLAG_2X)); break;\n\t}\n\n\tint loaded = 0;\n\tsnprintf(filename, sizeof(filename), SMASK_DIR\"/%s\", shadow_mask_cfg + 1);\n\n\tfileTextReader reader;\n\tif (FileOpenTextReader(&reader, filename))\n\t{\n\t\tchar *start_pos = reader.pos;\n\t\tconst char *line;\n\t\tuint32_t res = 0;\n\t\twhile ((line = FileReadLine(&reader)))\n\t\t{\n\t\t\tif (!strncasecmp(line, \"resolution=\", 11))\n\t\t\t{\n\t\t\t\tif (sscanf(line + 11, \"%u\", &res))\n\t\t\t\t{\n\t\t\t\t\tif (v_cur.item[5] >= res)\n\t\t\t\t\t{\n\t\t\t\t\t\tstart_pos = reader.pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint w = -1, h = -1;\n\t\tint y = 0;\n\t\tint v2 = 0;\n\n\t\treader.pos = start_pos;\n\t\twhile ((line = FileReadLine(&reader)))\n\t\t{\n\t\t\tif (w == -1)\n\t\t\t{\n\t\t\t\tif (!strcasecmp(line, \"v2\"))\n\t\t\t\t{\n\t\t\t\t\tv2 = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!strncasecmp(line, \"resolution=\", 11))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint n = sscanf(line, \"%d,%d\", &w, &h);\n\t\t\t\tif ((n != 2) || (w <= 0) || (h <= 0) || (w > 16) || (h > 16))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tunsigned int p[16];\n\t\t\t\tint n = sscanf(line, \"%X,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\", p + 0, p + 1, p + 2, p + 3, p + 4, p + 5, p + 6, p + 7, p + 8, p + 9, p + 10, p + 11, p + 12, p + 13, p + 14, p + 15);\n\t\t\t\tif (n != w)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (int x = 0; x < 16; x++) spi_w(SM_LUT(v2 ? (p[x] & 0x7FF) : (((p[x] & 7) << 8) | 0x2A)));\n\t\t\t\ty += 1;\n\n\t\t\t\tif (y == h)\n\t\t\t\t{\n\t\t\t\t\tloaded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (y == h)\n\t\t{\n\t\t\tspi_w(SM_HMAX(w - 1));\n\t\t\tspi_w(SM_VMAX(h - 1));\n\t\t}\n\t}\n\n\tif (!loaded) spi_w(SM_FLAG(0));\n\tDisableIO();\n}\n\nint video_get_shadow_mask_mode()\n{\n\treturn has_shadow_mask ? shadow_mask_cfg[0] : -1;\n}\n\nchar* video_get_shadow_mask(int only_name)\n{\n\tchar *path = shadow_mask_cfg + 1;\n\tif (only_name)\n\t{\n\t\tchar *p = strrchr(path, '/');\n\t\tif (p) return p + 1;\n\t}\n\treturn path;\n}\n\nstatic char shadow_mask_cfg_path[1024] = { 0 };\n\nstatic void video_save_shadow_mask_cfg()\n{\n\tFileSaveConfig(shadow_mask_cfg_path, &shadow_mask_cfg, sizeof(shadow_mask_cfg));\n}\n\nstatic void video_apply_shadow_mask_mode(int n)\n{\n\tif( n >= SM_MODE_COUNT )\n\t{\n\t\tn = 0;\n\t}\n\telse if (n < 0)\n\t{\n\t\tn = SM_MODE_COUNT - 1;\n\t}\n\n\tshadow_mask_cfg[0] = (char)n;\n\tsetShadowMask();\n}\n\nvoid video_set_shadow_mask_mode(int n)\n{\n\tvideo_apply_shadow_mask_mode(n);\n\tvideo_save_shadow_mask_cfg();\n}\n\nstatic void video_apply_shadow_mask(const char *name)\n{\n\tstrcpy(shadow_mask_cfg + 1, name);\n\tsetShadowMask();\n\tuser_io_send_buttons(1);\n}\n\nvoid video_set_shadow_mask(const char *name)\n{\n\tvideo_apply_shadow_mask(name);\n\tvideo_save_shadow_mask_cfg();\n}\n\nstatic void loadShadowMaskCfg()\n{\n\tPROFILE_FUNCTION();\n\n\tif (!FileLoadConfig(shadow_mask_cfg_path, &shadow_mask_cfg, sizeof(shadow_mask_cfg) - 1))\n\t{\n\t\tif (cfg.shmask_default[0])\n\t\t{\n\t\t\tstrcpy(shadow_mask_cfg + 1, cfg.shmask_default);\n\t\t\tshadow_mask_cfg[0] = cfg.shmask_mode_default;\n\t\t}\n\t}\n\n\tif( shadow_mask_cfg[0] >= SM_MODE_COUNT )\n\t{\n\t\tshadow_mask_cfg[0] = 0;\n\t}\n}\n\n\n#define IS_NEWLINE(c) (((c) == '\\r') || ((c) == '\\n'))\n#define IS_WHITESPACE(c) (IS_NEWLINE(c) || ((c) == ' ') || ((c) == '\\t'))\n\nstatic char* get_preset_arg(const char *str)\n{\n\tstatic char par[1024];\n\tsnprintf(par, sizeof(par), \"%s\", str);\n\tchar *pos = par;\n\n\twhile (*pos && !IS_NEWLINE(*pos)) pos++;\n\t*pos-- = 0;\n\n\twhile (pos >= par)\n\t{\n\t\tif (!IS_WHITESPACE(*pos)) break;\n\t\t*pos-- = 0;\n\t}\n\n\treturn par;\n}\n\nstatic void load_flt_pres(const char *str, int type)\n{\n\tchar *arg = get_preset_arg(str);\n\tif (arg[0])\n\t{\n\t\tif (!strcasecmp(arg, \"same\") || !strcasecmp(arg, \"off\"))\n\t\t{\n\t\t\tvideo_apply_scaler_flt(type, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvideo_apply_scaler_coeff(type, arg);\n\t\t\tvideo_apply_scaler_flt(type, 1);\n\t\t}\n\t}\n}\n\nvoid video_loadPreset(char *name, bool save)\n{\n\tchar *arg;\n\tfileTextReader reader;\n\n\tbool scaler_dirty = false;\n\tbool mask_dirty = false;\n\tbool gamma_dirty = false;\n\n\tif (FileOpenTextReader(&reader, name))\n\t{\n\t\tconst char *line;\n\t\twhile ((line = FileReadLine(&reader)))\n\t\t{\n\t\t\tif (!strncasecmp(line, \"hfilter=\", 8))\n\t\t\t{\n\t\t\t\tload_flt_pres(line + 8, VFILTER_HORZ);\n\t\t\t\tscaler_dirty = true;\n\t\t\t}\n\t\t\telse if (!strncasecmp(line, \"vfilter=\", 8))\n\t\t\t{\n\t\t\t\tload_flt_pres(line + 8, VFILTER_VERT);\n\t\t\t\tscaler_dirty = true;\n\t\t\t}\n\t\t\telse if (!strncasecmp(line, \"sfilter=\", 8))\n\t\t\t{\n\t\t\t\tload_flt_pres(line + 8, VFILTER_SCAN);\n\t\t\t\tscaler_dirty = true;\n\t\t\t}\n\t\t\telse if (!strncasecmp(line, \"mask=\", 5))\n\t\t\t{\n\t\t\t\tmask_dirty = true;\n\t\t\t\targ = get_preset_arg(line + 5);\n\t\t\t\tif (arg[0])\n\t\t\t\t{\n\t\t\t\t\tif (!strcasecmp(arg, \"off\") || !strcasecmp(arg, \"none\")) video_apply_shadow_mask_mode(0);\n\t\t\t\t\telse video_apply_shadow_mask(arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strncasecmp(line, \"maskmode=\", 9))\n\t\t\t{\n\t\t\t\tmask_dirty = true;\n\t\t\t\targ = get_preset_arg(line + 9);\n\t\t\t\tif (arg[0])\n\t\t\t\t{\n\t\t\t\t\tif (!strcasecmp(arg, \"off\") || !strcasecmp(arg, \"none\")) video_apply_shadow_mask_mode(0);\n\t\t\t\t\telse if (!strcasecmp(arg, \"1x\")) video_apply_shadow_mask_mode(SM_MODE_1X);\n\t\t\t\t\telse if (!strcasecmp(arg, \"2x\")) video_apply_shadow_mask_mode(SM_MODE_2X);\n\t\t\t\t\telse if (!strcasecmp(arg, \"1x rotated\")) video_apply_shadow_mask_mode(SM_MODE_1X_ROTATED);\n\t\t\t\t\telse if (!strcasecmp(arg, \"2x rotated\")) video_apply_shadow_mask_mode(SM_MODE_2X_ROTATED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strncasecmp(line, \"gamma=\", 6))\n\t\t\t{\n\t\t\t\tgamma_dirty = true;\n\t\t\t\targ = get_preset_arg(line + 6);\n\t\t\t\tif (arg[0])\n\t\t\t\t{\n\t\t\t\t\tif (!strcasecmp(arg, \"off\") || !strcasecmp(arg, \"none\")) video_apply_gamma_en(0);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvideo_apply_gamma_curve(arg);\n\t\t\t\t\t\tvideo_apply_gamma_en(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (save)\n\t{\n\t\tif (scaler_dirty) video_save_scaler_cfg();\n\t\tif (mask_dirty) video_save_shadow_mask_cfg();\n\t\tif (gamma_dirty) video_save_gamma_cfg();\n\t}\n}\n\nstatic void hdmi_config_set_spd(bool val)\n{\n\tint fd = i2c_open(0x39, 0);\n\tif (fd >= 0)\n\t{\n\t\tuint8_t packet_val = i2c_smbus_read_byte_data(fd, 0x40);\n\t\tif (val)\n\t\t\tpacket_val |= 0x40;\n\t\telse\n\t\t\tpacket_val &= ~0x40;\n\t\tint res = i2c_smbus_write_byte_data(fd, 0x40, packet_val);\n\t\tif (res < 0) printf(\"i2c: write error (%02X %02X): %d\\n\", 0x40, packet_val, res);\n\t\ti2c_close(fd);\n\t}\n}\n\nstatic void hdmi_config_set_spare(int packet, bool enabled)\n{\n\tint fd = i2c_open(0x39, 0);\n\tuint8_t mask = packet == 0 ? 0x01 : 0x02;\n\tif (fd >= 0)\n\t{\n\t\tuint8_t packet_val = i2c_smbus_read_byte_data(fd, 0x40);\n\t\tif (enabled)\n\t\t\tpacket_val |= mask;\n\t\telse\n\t\t\tpacket_val &= ~mask;\n\t\tint res = i2c_smbus_write_byte_data(fd, 0x40, packet_val);\n\t\tif (res < 0) printf(\"i2c: write error (%02X %02X): %d\\n\", 0x40, packet_val, res);\n\t\ti2c_close(fd);\n\t}\n}\n\nstatic void hdmi_config_set_csc()\n{\n\t// default color conversion matrices\n\t// for the original hexadecimal versions please refer\n\t// to the ADV7513 programming guide section 4.3.7\n\n\t// no transformation, so use identity matrix\n\tfloat hdmi_full_coeffs[] = {\n\t\t1.0f, 0.0f, 0.0f, 0.0f,\n\t\t0.0f, 1.0f, 0.0f, 0.0f,\n\t\t0.0f, 0.0f, 1.0f, 0.0f,\n\t\t0.0f, 0.0f, 0.0f, 1.0f\n\t};\n\n\tfloat hdmi_limited_1_coeffs[] = {\n\t\t0.8583984375f, 0.0f, 0.0f, 0.06250f,\n\t\t0.0f, 0.8583984375f, 0.0f, 0.06250f,\n\t\t0.0f, 0.0f, 0.8583984375f, 0.06250f,\n\t\t0.0f, 0.0f, 0.0f, 1.0f\n\t};\n\n\tfloat hdmi_limited_2_coeffs[] = {\n\t\t0.93701171875f, 0.0f, 0.0f, 0.06250f,\n\t\t0.0f, 0.93701171875f, 0.0f, 0.06250f,\n\t\t0.0f, 0.0f, 0.93701171875f, 0.06250f,\n\t\t0.0f, 0.0f, 0.0f, 1.0f\n\t};\n\n\tfloat hdr_dcip3_coeffs[] = {\n\t\t0.8225f, 0.1774f, 0.0000f, 0.0f,\n\t\t0.0332f, 0.9669f, 0.0000f, 0.0f,\n\t\t0.0171f, 0.0724f, 0.9108f, 0.0f,\n\t\t0.0f, 0.0f, 0.0f, 1.0f\n\t};\n\n\tconst float pi = float(M_PI);\n\n\tint ypbpr = (cfg.vga_mode_int == 1) && cfg.direct_video;\n\n\t// out-of-scope defines, not used with ypbpr\n\tint16_t csc_int16[12];\n\tint hdmi_limited_1 = cfg.hdmi_limited & 1;\n\tint hdmi_limited_2 = cfg.hdmi_limited & 2;\n\n\tif (!ypbpr)\n\t{\n\t\t// select the base CSC\n\t\tint hdr = cfg.hdr;\n\n\t\tmat4x4 coeffs = hdr == 2 ? hdr_dcip3_coeffs : hdmi_full_coeffs;\n\t\tmat4x4 csc(coeffs);\n\n\t\t// apply color controls\n\t\tfloat brightness = (((cfg.video_brightness / 100.0f) - 0.5f)); // [-0.5 .. 0.5]\n\t\tfloat contrast = ((cfg.video_contrast / 100.0f) - 0.5f) * 2.0f + 1.0f; // [0 .. 2]\n\t\tfloat saturation = ((cfg.video_saturation / 100.0f)); // [0 .. 1]\n\t\tfloat hue = (cfg.video_hue * pi / 180.0f);\n\n\t\tchar* gain_offset = cfg.video_gain_offset;\n\n\t\t// we have to parse these\n\t\tfloat gain_red = 1;\n\t\tfloat gain_green = 1;\n\t\tfloat gain_blue = 1;\n\t\tfloat off_red = 0;\n\t\tfloat off_green = 0;\n\t\tfloat off_blue = 0;\n\n\t\tsize_t target = 0;\n\t\tfloat* targets[6] = { &gain_red, &off_red, &gain_green, &off_green, &gain_blue, &off_blue };\n\n\t\tfor (size_t i = 0; i < strlen(gain_offset) && target < 6; i++)\n\t\t{\n\t\t\t// skip whitespace\n\t\t\tif (gain_offset[i] == ' ' || gain_offset[i] == ',')\n\t\t\t\tcontinue;\n\n\t\t\tint numRead = 0;\n\t\t\tint match = sscanf(gain_offset + i, \"%f%n\", targets[target], &numRead);\n\n\t\t\ti += numRead > 0 ? numRead - 1 : 0;\n\n\t\t\tif (match == 1)\n\t\t\t\ttarget++;\n\t\t}\n\n\t\t// first apply hue matrix, because it does not touch luminance\n\t\tfloat cos_hue = cos(hue);\n\t\tfloat sin_hue = sin(hue);\n\t\tfloat lr = 0.213f;\n\t\tfloat lg = 0.715f;\n\t\tfloat lb = 0.072f;\n\t\tfloat ca = 0.143f;\n\t\tfloat cb = 0.140f;\n\t\tfloat cc = 0.283f;\n\n\t\tmat4x4 mat_hue;\n\t\tmat_hue.setIdentity();\n\n\t\tmat_hue.m11 = lr + cos_hue * (1 - lr) + sin_hue * (-lr);\n\t\tmat_hue.m12 = lg + cos_hue * (-lg) + sin_hue * (-lg);\n\t\tmat_hue.m13 = lb + cos_hue * (-lb) + sin_hue * (1 - lb);\n\n\t\tmat_hue.m21 = lr + cos_hue * (-lr) + sin_hue * (ca);\n\t\tmat_hue.m22 = lg + cos_hue * (1 - lg) + sin_hue * (cb);\n\t\tmat_hue.m23 = lb + cos_hue * (-lb) + sin_hue * (cc);\n\n\t\tmat_hue.m31 = lr + cos_hue * (-lr) + sin_hue * (-(1 - lr));\n\t\tmat_hue.m32 = lg + cos_hue * (-lg) + sin_hue * (lg);\n\t\tmat_hue.m33 = lb + cos_hue * (1 - lb) + sin_hue * (lb);\n\n\t\tcsc = csc * mat_hue;\n\n\t\t// now saturation\n\t\tfloat s = saturation;\n\t\tfloat sr = (1.0f - s) * .3086f;\n\t\tfloat sg = (1.0f - s) * .6094f;\n\t\tfloat sb = (1.0f - s) * .0920f;\n\n\t\tfloat mat_saturation[] = {\n\t\t\tsr + s, sg, sb, 0,\n\t\t\tsr, sg + s, sb, 0,\n\t\t\tsr, sg, sb + s, 0,\n\t\t\t0, 0, 0, 1.0f\n\t\t};\n\n\t\tcsc = csc * mat4x4(mat_saturation);\n\n\t\t// now brightness and contrast\n\t\tfloat b = brightness;\n\t\tfloat c = contrast;\n\t\tfloat t = (1.0f - c) / 2.0f;\n\n\t\tfloat mat_brightness_contrast[] = {\n\t\t\tc, 0, 0, (t + b),\n\t\t\t0, c, 0, (t + b),\n\t\t\t0, 0, c, (t + b),\n\t\t\t0, 0, 0, 1.0f\n\t\t};\n\n\t\tcsc = csc * mat4x4(mat_brightness_contrast);\n\n\t\t// gain and offset\n\t\tfloat rg = gain_red;\n\t\tfloat ro = off_red;\n\t\tfloat gg = gain_green;\n\t\tfloat go = off_green;\n\t\tfloat bg = gain_blue;\n\t\tfloat bo = off_blue;\n\n\t\tfloat mat_gain_off[] = {\n\t\t\trg, 0, 0, ro,\n\t\t\t0, gg, 0, go,\n\t\t\t0, 0, bg, bo,\n\t\t\t0, 0, 0, 1.0f\n\t\t};\n\n\t\tcsc = csc * mat4x4(mat_gain_off);\n\n\t\t// final compression\n\t\tcsc.compress(2.0f);\n\n\t\t// make sure to retain hdmi limited range\n\t\tif (hdmi_limited_1)\n\t\t\tcsc = csc * mat4x4(hdmi_limited_1_coeffs);\n\t\telse if (hdmi_limited_2)\n\t\t\tcsc = csc * mat4x4(hdmi_limited_2_coeffs);\n\n\t\t// finally, apply a fixed multiplier to get it in\n\t\t// correct range for ADV7513 chip\n\t\tfor (size_t i = 0; i < 12; i++)\n\t\t{\n\t\t\tcsc_int16[i] = int16_t(csc.comp[i] * 2048.0f);\n\t\t}\n\t}\n\t// Clamps to reinforce limited if necessary\n\t// 0x100 = 16/256 * 4096 (12-bit mul)\n\t// 0xEB0 = 235/256 * 4096\n\t// 0xFFF = 4095 (12-bit max)\n\tuint16_t clipMin = (!ypbpr && (hdmi_limited_1 || hdmi_limited_2)) ? 0x100 : 0x000;\n\tuint16_t clipMax = (!ypbpr && hdmi_limited_1) ? 0xEB0 : 0xFFF;\n\n\t// pass to HDMI, use 0xA0 to set a mode of [-2 .. 2] per ADV7513 programming guide\n\tuint8_t csc_data[] = {\n\t\t0x18, (uint8_t)(ypbpr ? 0x86 : (0b10100000 | (((csc_int16[0] >> 8) & 0b00011111)))),  // csc Coefficients, Channel A\n\t\t0x19, (uint8_t)(ypbpr ? 0xDF : (csc_int16[0] & 0xff)),\n\t\t0x1A, (uint8_t)(ypbpr ? 0x1A : (csc_int16[1] >> 8)),\n\t\t0x1B, (uint8_t)(ypbpr ? 0x3F : (csc_int16[1] & 0xff)),\n\t\t0x1C, (uint8_t)(ypbpr ? 0x1E : (csc_int16[2] >> 8)),\n\t\t0x1D, (uint8_t)(ypbpr ? 0xE2 : (csc_int16[2] & 0xff)),\n\t\t0x1E, (uint8_t)(ypbpr ? 0x07 : (csc_int16[3] >> 8)),\n\t\t0x1F, (uint8_t)(ypbpr ? 0xE7 : (csc_int16[3] & 0xff)),\n\n\t\t0x20, (uint8_t)(ypbpr ? 0x04 : (csc_int16[4] >> 8)),  // csc Coefficients, Channel B\n\t\t0x21, (uint8_t)(ypbpr ? 0x1C : (csc_int16[4] & 0xff)),\n\t\t0x22, (uint8_t)(ypbpr ? 0x08 : (csc_int16[5] >> 8)),\n\t\t0x23, (uint8_t)(ypbpr ? 0x11 : (csc_int16[5] & 0xff)),\n\t\t0x24, (uint8_t)(ypbpr ? 0x01 : (csc_int16[6] >> 8)),\n\t\t0x25, (uint8_t)(ypbpr ? 0x91 : (csc_int16[6] & 0xff)),\n\t\t0x26, (uint8_t)(ypbpr ? 0x01 : (csc_int16[7] >> 8)),\n\t\t0x27, (uint8_t)(ypbpr ? 0x00 : (csc_int16[7] & 0xff)),\n\n\t\t0x28, (uint8_t)(ypbpr ? 0x1D : (csc_int16[8] >> 8)),  // csc Coefficients, Channel C\n\t\t0x29, (uint8_t)(ypbpr ? 0xAE : (csc_int16[8] & 0xff)),\n\t\t0x2A, (uint8_t)(ypbpr ? 0x1B : (csc_int16[9] >> 8)),\n\t\t0x2B, (uint8_t)(ypbpr ? 0x73 : (csc_int16[9] & 0xff)),\n\t\t0x2C, (uint8_t)(ypbpr ? 0x06 : (csc_int16[10] >> 8)),\n\t\t0x2D, (uint8_t)(ypbpr ? 0xDF : (csc_int16[10] & 0xff)),\n\t\t0x2E, (uint8_t)(ypbpr ? 0x07 : (csc_int16[11] >> 8)),\n\t\t0x2F, (uint8_t)(ypbpr ? 0xE7 : (csc_int16[11] & 0xff)),\n\n\t\t0xC0, (uint8_t)(clipMin >> 8), // HDMI limited clamps\n\t\t0xC1, (uint8_t)(clipMin & 0xff),\n\t\t0xC2, (uint8_t)(clipMax >> 8),\n\t\t0xC3, (uint8_t)(clipMax & 0xff)\n\t};\n\n\tint fd = i2c_open(0x39, 0);\n\tif (fd >= 0)\n\t{\n\t\tfor (uint i = 0; i < sizeof(csc_data); i += 2)\n\t\t{\n\t\t\tint res = i2c_smbus_write_byte_data(fd, csc_data[i], csc_data[i + 1]);\n\t\t\tif (res < 0) printf(\"i2c: write error (%02X %02X): %d\\n\", csc_data[i], csc_data[i + 1], res);\n\t\t}\n\n\t\ti2c_close(fd);\n\t}\n\telse\n\t{\n\t\tprintf(\"*** ADV7513 not found on i2c bus! HDMI won't be available!\\n\");\n\t}\n}\n\nstatic void hdmi_config_init()\n{\n\tint ypbpr = (cfg.vga_mode_int == 1) && cfg.direct_video;\n\n\t// address, value\n\tuint8_t init_data[] = {\n\t\t0x98, 03,\t\t\t\t// ADI required Write.\n\n\t\t0xD6, 0b11000000,\t\t// [7:6] HPD Control...\n\t\t\t\t\t\t\t\t// 00 = HPD is from both HPD pin or CDC HPD\n\t\t\t\t\t\t\t\t// 01 = HPD is from CDC HPD\n\t\t\t\t\t\t\t\t// 10 = HPD is from HPD pin\n\t\t\t\t\t\t\t\t// 11 = HPD is always high\n\n\t\t0x41, 0x10,\t\t\t\t// Power Down control\n\t\t0x9A, 0x70,\t\t\t\t// ADI required Write.\n\t\t0x9C, 0x30,\t\t\t\t// ADI required Write.\n\t\t0x9D, 0b01100001,\t\t// [7:4] must be b0110!.\n\t\t\t\t\t\t\t\t// [3:2] b00 = Input clock not divided. b01 = Clk divided by 2. b10 = Clk divided by 4. b11 = invalid!\n\t\t\t\t\t\t\t\t// [1:0] must be b01!\n\t\t0xA2, 0xA4,\t\t\t\t// ADI required Write.\n\t\t0xA3, 0xA4,\t\t\t\t// ADI required Write.\n\t\t0xE0, 0xD0,\t\t\t\t// ADI required Write.\n\n\n\t\t0x35, 0x40,\n\t\t0x36, 0xD9,\n\t\t0x37, 0x0A,\n\t\t0x38, 0x00,\n\t\t0x39, 0x2D,\n\t\t0x3A, 0x00,\n\n\t\t0x16, 0b00111000,\t\t// Output Format 444 [7]=0.\n\t\t\t\t\t\t\t\t// [6] must be 0!\n\t\t\t\t\t\t\t\t// Colour Depth for Input Video data [5:4] b11 = 8-bit.\n\t\t\t\t\t\t\t\t// Input Style [3:2] b10 = Style 1 (ignored when using 444 input).\n\t\t\t\t\t\t\t\t// DDR Input Edge falling [1]=0 (not using DDR atm).\n\t\t\t\t\t\t\t\t// Output Colour Space RGB [0]=0.\n\n\t\t0x17, 0b01100010,\t\t// Aspect ratio 16:9 [1]=1, 4:3 [1]=0, invert sync polarity\n\n\t\t0x3B, 0x80,             // Automatic pixel repetition and VIC detection\n\t\t0x3C, 0x00,\n\n\t\t0x48, 0b00001000,       // [6]=0 Normal bus order!\n\t\t\t\t\t\t\t\t// [5] DDR Alignment.\n\t\t\t\t\t\t\t\t// [4:3] b01 Data right justified (for YCbCr 422 input modes).\n\n\t\t0x49, 0xA8,\t\t\t\t// ADI required Write.\n\t\t0x40, 0x00,\n\t\t0x4A, 0b10000000,\t\t//Auto-Calculate SPD checksum\n\t\t0x4C, 0x00,\t\t\t\t// ADI required Write.\n\n\t\t0x55, (uint8_t)(cfg.hdmi_game_mode ? 0b00010010 : 0b00010000),\n\t\t\t\t\t\t\t\t// [7] must be 0!. Set RGB444 in AVinfo Frame [6:5], Set active format [4].\n\t\t\t\t\t\t\t\t// AVI InfoFrame Valid [4].\n\t\t\t\t\t\t\t\t// Bar Info [3:2] b00 Bars invalid. b01 Bars vertical. b10 Bars horizontal. b11 Bars both.\n\t\t\t\t\t\t\t\t// Scan Info [1:0] b00 (No data). b01 TV. b10 PC. b11 None.\n\n\t\t0x56, (uint8_t)( 0b00001000 | (cfg.hdr ? 0xb11000000 : 0)),\t\t// [5:4] Picture Aspect Ratio\n\t\t\t\t\t\t\t\t// [3:0] Active Portion Aspect Ratio b1000 = Same as Picture Aspect Ratio\n\n\t\t0x57, (uint8_t)((cfg.hdmi_game_mode ? 0x80 : 0x00)\t\t// [7] IT Content. 0 - No. 1 - Yes (type set in register 0x59).\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [6:4] Color space (ignored for RGB)\n\t\t\t| ((ypbpr || cfg.hdmi_limited) ? 0b0100 : cfg.hdr ? 0b1101000 : 0b0001000)),\t// [3:2] RGB Quantization range\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [1:0] Non-Uniform Scaled: 00 - None. 01 - Horiz. 10 - Vert. 11 - Both.\n\n\t\t0x59, (uint8_t)(cfg.hdmi_game_mode ? 0x30 : 0x00),\t\t// [7:6] [YQ1 YQ0] YCC Quantization Range: b00 = Limited Range, b01 = Full Range\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [5:4] IT Content Type b11 = Game, b00 = Graphics/None\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [3:0] Pixel Repetition Fields b0000 = No Repetition\n\n\t\t0x73, 0x01,\n\n\t\t0x94, 0b10000000,       // [7]=1 HPD Interrupt ENabled.\n\n\t\t0x99, 0x02,\t\t\t\t// ADI required Write.\n\t\t0x9B, 0x18,\t\t\t\t// ADI required Write.\n\n\t\t0x9F, 0x00,\t\t\t\t// ADI required Write.\n\n\t\t0xA1, 0b00000000,\t    // [6]=1 Monitor Sense Power Down DISabled.\n\n\t\t0xA4, 0x08,\t\t\t\t// ADI required Write.\n\t\t0xA5, 0x04,\t\t\t\t// ADI required Write.\n\t\t0xA6, 0x00,\t\t\t\t// ADI required Write.\n\t\t0xA7, 0x00,\t\t\t\t// ADI required Write.\n\t\t0xA8, 0x00,\t\t\t\t// ADI required Write.\n\t\t0xA9, 0x00,\t\t\t\t// ADI required Write.\n\t\t0xAA, 0x00,\t\t\t\t// ADI required Write.\n\t\t0xAB, 0x40,\t\t\t\t// ADI required Write.\n\n\t\t0xAF, (uint8_t)(0b00000100\t// [7]=0 HDCP Disabled.\n\t\t\t\t\t\t\t\t// [6:5] must be b00!\n\t\t\t\t\t\t\t\t// [4]=0 Current frame is unencrypted\n\t\t\t\t\t\t\t\t// [3:2] must be b01!\n\t\t\t| ((cfg.dvi_mode == 1) ? 0b00 : 0b10)),\t //\t[1]=1 HDMI Mode.\n\t\t\t\t\t\t\t\t// [0] must be b0!\n\n\t\t0xB9, 0x00,\t\t\t\t// ADI required Write.\n\n\t\t0xBA, 0b01100000,\t\t// [7:5] Input Clock delay...\n\t\t\t\t\t\t\t\t// b000 = -1.2ns.\n\t\t\t\t\t\t\t\t// b001 = -0.8ns.\n\t\t\t\t\t\t\t\t// b010 = -0.4ns.\n\t\t\t\t\t\t\t\t// b011 = No delay.\n\t\t\t\t\t\t\t\t// b100 = 0.4ns.\n\t\t\t\t\t\t\t\t// b101 = 0.8ns.\n\t\t\t\t\t\t\t\t// b110 = 1.2ns.\n\t\t\t\t\t\t\t\t// b111 = 1.6ns.\n\n\t\t0xBB, 0x00,\t\t\t\t// ADI required Write.\n\t\t0xDE, 0x9C,\t\t\t\t// ADI required Write.\n\t\t0xE4, 0x60,\t\t\t\t// ADI required Write.\n\t\t0xFA, 0x7D,\t\t\t\t// Nbr of times to search for good phase\n\n\t\t// (Audio stuff on Programming Guide, Page 66)...\n\t\t0x0A, 0b00000000,\t\t// [6:4] Audio Select. b000 = I2S.\n\t\t\t\t\t\t\t\t// [3:2] Audio Mode. (HBR stuff, leave at 00!).\n\n\t\t0x0B, 0b00001110,\t\t//\n\n\t\t0x0C, 0b00000100,\t\t// [7] 0 = Use sampling rate from I2S stream.   1 = Use samp rate from I2C Register.\n\t\t\t\t\t\t\t\t// [6] 0 = Use Channel Status bits from stream. 1 = Use Channel Status bits from I2C register.\n\t\t\t\t\t\t\t\t// [2] 1 = I2S0 Enable.\n\t\t\t\t\t\t\t\t// [1:0] I2S Format: 00 = Standard. 01 = Right Justified. 10 = Left Justified. 11 = AES.\n\n\t\t0x0D, 0b00010000,\t\t// [4:0] I2S Bit (Word) Width for Right-Justified.\n\t\t0x14, 0b00000010,\t\t// [3:0] Audio Word Length. b0010 = 16 bits.\n\t\t0x15, (uint8_t)((cfg.hdmi_audio_96k ? 0x80 : 0x00) | 0b0100000),\t// I2S Sampling Rate [7:4]. b0000 = (44.1KHz). b0010 = 48KHz.\n\t\t\t\t\t\t\t\t// Input ID [3:1] b000 (0) = 24-bit RGB 444 or YCrCb 444 with Separate Syncs.\n\n\t\t// Audio Clock Config\n\t\t0x01, 0x00,\t\t\t\t//\n\t\t0x02, (uint8_t)(cfg.hdmi_audio_96k ? 0x30 : 0x18),\t// Set N Value 12288/6144\n\t\t0x03, 0x00,\t\t\t\t//\n\n\t\t0x07, 0x01,\t\t\t\t//\n\t\t0x08, 0x22,\t\t\t\t// Set CTS Value 74250\n\t\t0x09, 0x0A,\t\t\t\t//\n\t};\n\n\tint fd = i2c_open(0x39, 0);\n\tif (fd >= 0)\n\t{\n\t\tfor (uint i = 0; i < sizeof(init_data); i += 2)\n\t\t{\n\t\t\tint res = i2c_smbus_write_byte_data(fd, init_data[i], init_data[i + 1]);\n\t\t\tif (res < 0) printf(\"i2c: write error (%02X %02X): %d\\n\", init_data[i], init_data[i + 1], res);\n\t\t}\n\n\t\ti2c_close(fd);\n\t}\n\telse\n\t{\n\t\tprintf(\"*** ADV7513 not found on i2c bus! HDMI won't be available!\\n\");\n\t}\n\n\thdmi_config_set_csc();\n}\n\nstatic void spd_config(uint8_t *data)\n{\n\tint fd = i2c_open(0x38, 0);\n\tif (fd >= 0)\n\t{\n\t\tint res;\n\t\thdmi_config_set_spd(1);\n\n\t\tres = i2c_smbus_write_byte_data(fd, 0x1F, 0x80);\n\t\tif (res < 0)\n\t\t{\n\t\t\tprintf(\"i2c: Couldn't update SPD change register (0x1F, 0x80) %d\\n\", res);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 0; i < 31; i++)\n\t\t\t{\n\t\t\t\tres = i2c_smbus_write_byte_data(fd, i, data[i]);\n\t\t\t\tif (res < 0) printf(\"i2c: SPD register write error (%02X %02x): %d\\n\", i, data[i], res);\n\t\t\t}\n\n\t\t\tres = i2c_smbus_write_byte_data(fd, 0x1F, 0x00);\n\t\t\tif (res < 0) printf(\"i2c: Couldn't update SPD change register (0x1F, 0x00), %d\\n\", res);\n\t\t}\n\t\ti2c_close(fd);\n\t}\n\telse\n\t{\n\t\thdmi_config_set_spd(0);\n\t}\n}\n\nstatic void spd_config_dv()\n{\n\tVideoInfo *vi = &current_video_info;\n\n\tuint8_t data[32] = {\n\t\t0x83, 0x01, 25, 0,\n\t\t'D', 'V', '1' /* version */,\n\t\t(uint8_t)((vi->interlaced ? 1 : 0) | (menu_present() ? 4 : 0)),\n\t\t(uint8_t)(vi->pixrep ? vi->pixrep : (vi->ctime / vi->width)),\n\t\t(uint8_t)vi->de_h,\n\t\t(uint8_t)(vi->de_h >> 8),\n\t\t(uint8_t)vi->de_v,\n\t\t(uint8_t)(vi->de_v >> 8),\n\t\t(uint8_t)vi->width,\n\t\t(uint8_t)(vi->width >> 8),\n\t\t(uint8_t)vi->height,\n\t\t(uint8_t)(vi->height >> 8)\n\t};\n\n\tchar *name = user_io_get_core_name2();\n\tfor (int i = 17; i < 32; i++)\n\t{\n\t\tif (!*name) break;\n\t\tdata[i] = (uint8_t)(*name);\n\t\tname++;\n\t}\n\n\tspd_config(data);\n}\n\n/*\nstatic void spd_config_hdmi()\n{\n\tuint8_t data[32] = {\n\t\t0x83, 0x01, 25, 0,\n\t\t'M', 'i', 'S', 'T', 'e', 'r', 0, 0,\n\t};\n\n\tchar *name = user_io_get_core_name();\n\tfor (int i = 12; i < 27; i++)\n\t{\n\t\tif (!*name) break;\n\t\tdata[i] = (uint8_t)(*name);\n\t\tname++;\n\t}\n\n\tdata[27] = 8; // GAME\n\n\tspd_config(data);\n}\n*/\n\nstatic void hdmi_config_set_hdr()\n{\n\t// Grab desired nits values\n\tuint8_t maxNitsLSB = cfg.hdr_max_nits & 0xFF;\n\tuint8_t maxNitsMSB = (cfg.hdr_max_nits >> 8) & 0xFF;\n\n\tuint8_t avgNitsLSB = cfg.hdr_avg_nits & 0xFF;\n\tuint8_t avgNitsMSB = (cfg.hdr_avg_nits >> 8) & 0xFF;\n\n\t// CTA-861-G: 6.9 Dynamic Range and Mastering InfoFrame\n\t// Uses BT2020 RGB primaries and white point chromacity\n\t// Max Lum: 1000cd/m2, Min Lum: 0cd/m2, MaxCLL: 1000cd/m2\n\t// MaxFALL: 250cd/m2 (this value does not matter much -\n\t// in essence it means that the display should expect -\n\t// 25% of the image to be 1000cd/m2)\n\t// If HDR == 1, use HLG\n\tuint8_t hdr_data[] = {\n\t\t0x87,\n\t\t0x01,\n\t\t0x1a,\n\t\t0x00, // Checksum, calculate later\n\t\t(cfg.hdr == 1 ? uint8_t(0x03) : uint8_t(0x02)),\n\t\t0x48,\n\t\t0x8a,\n\t\t0x08,\n\t\t0x39,\n\t\t0x34,\n\t\t0x21,\n\t\t0xaa,\n\t\t0x9b,\n\t\t0x96,\n\t\t0x19,\n\t\t0xfc,\n\t\t0x08,\n\t\t0x13,\n\t\t0x3d,\n\t\t0x42,\n\t\t0x40,\n\t\t0x00,\n\t\tmaxNitsLSB,\n\t\tmaxNitsMSB,\n\t\t0x01,\n\t\t0x00,\n\t\tmaxNitsLSB,\n\t\tmaxNitsMSB,\n\t\tavgNitsLSB,\n\t\tavgNitsMSB\n\t};\n\n\t// now we calculate the checksum for this packet (2s complement sum)\n\tuint16_t checksum = 0;\n\tfor (uint i = 0; i < sizeof(hdr_data); i++)\n\t\tchecksum += hdr_data[i];\n\n\tchecksum = checksum & 0xFF;\n\tchecksum = ~checksum + 1;\n\n\thdr_data[3] = checksum;\n\n\tif (cfg.hdr == 0)\n\t{\n\t\thdmi_config_set_spare(1, false);\n\t}\n\telse\n\t{\n\t\thdmi_config_set_spare(1, true);\n\t\tint fd = i2c_open(0x38, 0);\n\t\tint res = i2c_smbus_write_byte_data(fd, 0xFF, 0b10000000);\n\t\tif (res < 0)\n\t\t{\n\t\t\tprintf(\"i2c: hdr: Couldn't update Spare Packet change register (0xDF, 0x80) %d\\n\", res);\n\t\t}\n\n\t\tuint8_t addr = 0xe0;\n\t\tfor (uint i = 0; i < sizeof(hdr_data); i++)\n\t\t{\n\t\t\tres = i2c_smbus_write_byte_data(fd, addr, hdr_data[i]);\n\t\t\tif (res < 0) printf(\"i2c: hdr register write error (%02X %02x): %d\\n\", addr, hdr_data[i], res);\n\t\t\taddr += 1;\n\t\t}\n\t\tres = i2c_smbus_write_byte_data(fd, 0xfF, 0x00);\n\t\tif (res < 0) printf(\"i2c: hdr: Couldn't update Spare Packet change register (0xDF, 0x00), %d\\n\", res);\n\t}\n}\n\nstatic uint8_t last_sync_invert = 0xff;\nstatic uint8_t last_pr_flags = 0xff;\nstatic uint8_t last_vic_mode = 0xff;\n\nstatic void hdmi_config_set_mode(vmode_custom_t *vm)\n{\n\tPROFILE_FUNCTION();\n\n\tconst uint8_t vic_mode = (uint8_t)vm->param.vic;\n\tuint8_t pr_flags;\n\n\tif (cfg.direct_video && is_menu()) pr_flags = 0; // automatic pixel repetition\n\telse if (vm->param.pr != 0) pr_flags = 0b01001000; // manual pixel repetition with 2x clock\n\telse pr_flags = 0b01000000; // manual pixel repetition\n\n\tuint8_t sync_invert = 0;\n\tif (vm->param.hpol == 0) sync_invert |= 1 << 5;\n\tif (vm->param.vpol == 0) sync_invert |= 1 << 6;\n\n\tif (last_sync_invert == sync_invert && last_pr_flags == pr_flags && last_vic_mode == vic_mode) return;\n\n\t// address, value\n\tuint8_t init_data[] = {\n\t\t0x17, (uint8_t)(0b00000010 | sync_invert),\t\t// Aspect ratio 16:9 [1]=1, 4:3 [1]=0\n\t\t0x3B, pr_flags,\n\t\t0x3C, vic_mode,\t\t\t// VIC\n\t};\n\n\tint fd = i2c_open(0x39, 0);\n\tif (fd >= 0)\n\t{\n\t\tfor (uint i = 0; i < sizeof(init_data); i += 2)\n\t\t{\n\t\t\tint res = i2c_smbus_write_byte_data(fd, init_data[i], init_data[i + 1]);\n\t\t\tif (res < 0) printf(\"i2c: write error (%02X %02X): %d\\n\", init_data[i], init_data[i + 1], res);\n\t\t}\n\n\t\ti2c_close(fd);\n\t}\n\telse\n\t{\n\t\tprintf(\"*** ADV7513 not found on i2c bus! HDMI won't be available!\\n\");\n\t}\n\n\tlast_pr_flags = pr_flags;\n\tlast_sync_invert = sync_invert;\n\tlast_vic_mode = vic_mode;\n}\n\nstatic void edid_parse_cea_ext(uint8_t *cea)\n{\n\tuint8_t *data_block_end = cea + cea[2];\n\tuint8_t *cur_blk_start = cea + 4;\n\tuint8_t *cur_blk_data = cur_blk_start;\n\twhile (cur_blk_start != data_block_end)\n\t{\n\t\tcur_blk_data = cur_blk_start;\n\t\tuint8_t blk_tag = (*cur_blk_data & 0xe0) >> 5;\n\t\tuint8_t blk_size = *cur_blk_data & 0x1f;\n\t\tuint8_t blk_data_size = blk_size; //size of actual data in the block, it might be adjusted if the first byte is extended tag\n\t\tcur_blk_data++;\n\t\t//vendor specific block might be the only one?\n\n\t\tuint8_t is_vendor_specific = 0;\n\t\tif (blk_tag == 0x03) is_vendor_specific = 1;\n\t\tif (blk_tag == 0x07)\n\t\t{\n\t\t\tif (*cur_blk_data == 0x01) is_vendor_specific = 1;\n\t\t\tcur_blk_data++; //The extended tag uses the next byte for the type. We may not need it?\n\t\t\tblk_data_size--;\n\t\t}\n\n\t\tif (is_vendor_specific && blk_data_size >= 3)\n\t\t{\n\t\t\tint oui = cur_blk_data[0] | cur_blk_data[1] << 8 | cur_blk_data[2] << 16;\n\t\t\tcur_blk_data += 3;\n\t\t\tblk_data_size -= 3;\n\t\t\tif (oui == 0x00001a) //AMD block\n\t\t\t{\n\t\t\t\tuint8_t min_fr = cur_blk_data[2];\n\n\t\t\t\tuint8_t max_fr = cur_blk_data[3];\n\t\t\t\tif (max_fr > 62) max_fr = 62;\n\t\t\t\tif (min_fr && max_fr)\n\t\t\t\t{\n\t\t\t\t\tvrr_modes[VRR_FREESYNC].available = 1;\n\t\t\t\t\tvrr_modes[VRR_FREESYNC].min_fr = min_fr;\n\t\t\t\t\tvrr_modes[VRR_FREESYNC].max_fr = max_fr;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (oui == 0xc45dd8)\n\t\t\t{\n\t\t\t\tif (blk_data_size > 5) //VRR lies beyond here\n\t\t\t\t{\n\t\t\t\t\tuint8_t min_fr = cur_blk_data[5] & 0x3f;\n\t\t\t\t\tuint8_t max_fr = (cur_blk_data[5] & 0xc0) << 2 | cur_blk_data[6];\n\t\t\t\t\tif (max_fr > 62) max_fr = 62;\n\t\t\t\t\tif (min_fr && max_fr)\n\t\t\t\t\t{\n\t\t\t\t\t\tvrr_modes[VRR_VESA].available = 1;\n\t\t\t\t\t\tvrr_modes[VRR_VESA].min_fr = min_fr;\n\t\t\t\t\t\tvrr_modes[VRR_VESA].max_fr = max_fr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur_blk_start += blk_size + 1;\n\t}\n}\n\nstatic int find_edid_vrr_capability()\n{\n\tuint8_t *cur_ext = NULL;\n\tuint8_t ext_cnt = edid[126];\n\n\t//Probably only one extension, but just in case...\n\tfor (int i = 0; i < ext_cnt; i++)\n\t{\n\t\tcur_ext = edid + 128 + i * 128; //edid extension blocks are 128 bytes\n\t\tuint8_t ext_tag = *cur_ext;\n\t\tif (ext_tag == 0x02) //CEA EDID extension\n\t\t{\n\t\t\tedid_parse_cea_ext(cur_ext);\n\t\t}\n\t}\n\n\tfor (size_t i = 1; i < sizeof(vrr_modes) / sizeof(vrr_cap_t); i++)\n\t{\n\t\tif (vrr_modes[i].available) printf(\"VRR: %s available\\n\", vrr_modes[i].description);\n\t}\n\treturn 0;\n\n}\n\nstatic int is_edid_valid()\n{\n\tstatic const uint8_t magic[] = { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00 };\n\tif (sizeof(edid) < sizeof(magic)) return 0;\n\treturn !memcmp(edid, magic, sizeof(magic));\n}\n\nstatic int get_active_edid()\n{\n\tint fd = i2c_open(0x39, 0);\n\tif (fd < 0)\n\t{\n\t\tprintf(\"EDID: cannot find main i2c device\\n\");\n\t\treturn 0;\n\t}\n\n\t//Test if adv7513 senses hdmi clock. If not, don't bother with the edid query\n\tint hpd_state = i2c_smbus_read_byte_data(fd, 0x42);\n\tif (hpd_state < 0 || !(hpd_state & 0x20))\n\t{\n\t\ti2c_close(fd);\n\t\treturn 0;\n\t}\n\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\ti2c_smbus_write_byte_data(fd, 0xC9, 0x03);\n\t\ti2c_smbus_write_byte_data(fd, 0xC9, 0x13);\n\t}\n\ti2c_close(fd);\n\tfd = i2c_open(0x3f, 0);\n\tif (fd < 0)\n\t{\n\t\tprintf(\"EDID: cannot find i2c device.\\n\");\n\t\treturn 0;\n\t}\n\n\t// waiting for valid EDID\n\tfor (int k = 0; k < 20; k++)\n\t{\n\t\tfor (uint i = 0; i < sizeof(edid); i++) edid[i] = (uint8_t)i2c_smbus_read_byte_data(fd, i);\n\t\tif (is_edid_valid()) break;\n\t\tusleep(100000);\n\t}\n\n\ti2c_close(fd);\n\tprintf(\"EDID:\\n\"); hexdump(edid, sizeof(edid), 0);\n\n\tif (!is_edid_valid())\n\t{\n\t\tprintf(\"Invalid EDID: incorrect header.\\n\");\n\t\tbzero(edid, sizeof(edid));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int get_edid_vmode(vmode_custom_t *v)\n{\n\tif (!is_edid_valid())\n\t{\n\t\tget_active_edid();\n\t}\n\n\tif (!is_edid_valid()) return 0;\n\n\tint hact, vact, pixclk_khz, hfp, hsync, hbp, vfp, vsync, vbp, hbl, vbl;\n\tuint8_t *x = edid + 0x36;\n\n\tpixclk_khz = (x[0] + (x[1] << 8)) * 10;\n\tif (pixclk_khz < 10000)\n\t{\n\t\tif (!pixclk_khz) printf(\"Invalid EDID: First two bytes are 0, invalid data.\\n\");\n\t\telse printf(\"Invalid EDID: Pixelclock < 10 MHz, assuming invalid data 0x%02x 0x%02x.\\n\", x[0], x[1]);\n\t\treturn 0;\n\t}\n\n\tif (cfg.dvi_mode == 2)\n\t{\n\t\tcfg.dvi_mode = (edid[0x80] == 2 && edid[0x81] == 3 && (edid[0x83] & 0x40)) ? 0 : 1;\n\t\tif (cfg.dvi_mode == 1) printf(\"EDID: using DVI mode.\\n\");\n\t}\n\n\tunsigned char flags = x[17];\n\tif (flags & 0x80)\n\t{\n\t\tprintf(\"EDID: preferred mode is interlaced. Fall back to default video mode.\\n\");\n\t\treturn 0;\n\t}\n\n\thact = (x[2] + ((x[4] & 0xf0) << 4));\n\thbl = (x[3] + ((x[4] & 0x0f) << 8));\n\thfp = (x[8] + ((x[11] & 0xc0) << 2));\n\thsync = (x[9] + ((x[11] & 0x30) << 4));\n\thbp = hbl - hsync - hfp;\n\tvact = (x[5] + ((x[7] & 0xf0) << 4));\n\tvbl = (x[6] + ((x[7] & 0x0f) << 8));\n\tvfp = ((x[10] >> 4) + ((x[11] & 0x0c) << 2));\n\tvsync = ((x[10] & 0x0f) + ((x[11] & 0x03) << 4));\n\tvbp = vbl - vsync - vfp;\n\n\t/*\n\tint pos_pol_hsync = 0;\n\tint pos_pol_vsync = 0;\n\tint no_pol_vsync = 0; // digital composite signals have no vsync polarity\n\n\tswitch ((flags & 0x18) >> 3)\n\t{\n\tcase 0x02:\n\t\tif (flags & (1 << 1)) pos_pol_hsync = 1;\n\t\tno_pol_vsync = 1;\n\t\tbreak;\n\tcase 0x03:\n\t\tif (flags & (1 << 1)) pos_pol_hsync = 1;\n\t\tif (flags & (1 << 2)) pos_pol_vsync = 1;\n\t\tbreak;\n\t}\n\t*/\n\n\tdouble Fpix = pixclk_khz / 1000.f;\n\tdouble frame_rate = Fpix * 1000000.f / ((hact + hfp + hbp + hsync)*(vact + vfp + vbp + vsync));\n\tprintf(\"EDID: preferred mode: %dx%d@%.1f, pixel clock: %.3fMHz\\n\", hact, vact, frame_rate, Fpix);\n\n\tif (hact >= 1920) support_FHD = 1;\n\n\tif (hact > 2048)\n\t{\n\t\tprintf(\"EDID: Preferred resolution is too high (%dx%d).\\n\", hact, vact);\n\t\tprintf(\"EDID: Falling back to default video mode.\\n\");\n\t\treturn 0;\n\t}\n\n\tmemset(v, 0, sizeof(vmode_custom_t));\n\tv->item[1] = hact;\n\tv->item[2] = hfp;\n\tv->item[3] = hsync;\n\tv->item[4] = hbp;\n\tv->item[5] = vact;\n\tv->item[6] = vfp;\n\tv->item[7] = vsync;\n\tv->item[8] = vbp;\n\tv->Fpix = Fpix;\n\n\tif (Fpix > 210.f)\n\t{\n\t\tprintf(\"EDID: Preferred mode has too high pixel clock (%.3fMHz).\\n\", Fpix);\n\t\tif (hact == 2048 && vact == 1536)\n\t\t{\n\t\t\tint n = 13;\n\t\t\tprintf(\"EDID: Using safe vmode %d.\\n\", n);\n\t\t\tfor (int i = 0; i < 8; i++) v->item[i + 1] = vmodes[n].vpar[i];\n\t\t\tv->param.vic = vmodes[n].vic_mode;\n\t\t\tv->Fpix = vmodes[n].Fpix;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint fail = 1;\n\t\t\tif (frame_rate > 60.f)\n\t\t\t{\n\t\t\t\tFpix = 60.f * (hact + hfp + hbp + hsync)*(vact + vfp + vbp + vsync) / 1000000.f;\n\t\t\t\tif (Fpix <= 210.f)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"EDID: Reducing frame rate to 60Hz with new pixel clock %.3fMHz.\\n\", Fpix);\n\t\t\t\t\tv->Fpix = Fpix;\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fail)\n\t\t\t{\n\t\t\t\tprintf(\"EDID: Falling back to default video mode.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tv->param.rb = 2;\n\tsetPLL(v->Fpix, v);\n\treturn 1;\n}\n\nstatic void set_vrr_mode()\n{\n\tPROFILE_FUNCTION();\n\n\tuse_vrr = 0;\n\tfloat vrateh = 100000000;\n\n\tif (cfg.vrr_mode == 0)\n\t{\n\t\tif (last_vrr_mode != 0)\n\t\t{\n\t\t\thdmi_config_set_spd(false);\n\t\t\thdmi_config_set_spare(0, false);\n\t\t}\n\t\tlast_vrr_mode = 0;\n\t\treturn;\n\t}\n\n\tif (current_video_info.vtimeh) vrateh /= current_video_info.vtimeh; else vrateh = 0;\n\tif (cfg.vrr_vesa_framerate) vrateh = cfg.vrr_vesa_framerate;\n\n\tif ((last_vrr_mode == cfg.vrr_mode) &&\n\t\t(last_vrr_rate == vrateh) &&\n\t\t(last_vrr_vfp == v_cur.param.vfp || cfg.vrr_mode != VRR_VESA)) return;\n\n\tif (!is_edid_valid())\n\t{\n\t\tget_active_edid();\n\t}\n\n\tif (!is_edid_valid())\n\t{\n\t\tprintf(\"Set VRR: No valid edid, cannot set\\n\");\n\t\treturn;\n\t}\n\n\tfind_edid_vrr_capability();\n\n\tif (cfg.vrr_mode == 1) //autodetect\n\t{\n\t\tfor (uint8_t i = 1; i < sizeof(vrr_modes) / sizeof(vrr_cap_t); i++)\n\t\t{\n\t\t\tif (vrr_modes[i].available)\n\t\t\t{\n\t\t\t\tuse_vrr = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (cfg.vrr_mode == 2)\n\t{ //force AMD Freesync\n\t\tuse_vrr = VRR_FREESYNC;\n\t}\n\telse if (cfg.vrr_mode == 3)\n\t{ //force Vesa Forum VRR\n\t\tuse_vrr = VRR_VESA;\n\t}\n\telse\n\t{\n\t\tuse_vrr = 0;\n\t}\n\n\tvrr_min_fr = 0;\n\tvrr_max_fr = 0;\n\n\tif (use_vrr == VRR_VESA && !vrateh) return;\n\tif (use_vrr)\n\t{\n\t\tvrr_min_fr = cfg.vrr_min_framerate;\n\t\tvrr_max_fr = cfg.vrr_max_framerate;\n\n\t\tif (!vrr_min_fr) vrr_min_fr = vrr_modes[use_vrr].min_fr;\n\t\tif (!vrr_max_fr) vrr_max_fr = vrr_modes[use_vrr].max_fr;\n\n\t\tif (!vrr_min_fr) vrr_min_fr = 47;\n\t\tif (!vrr_max_fr) vrr_max_fr = 62;\n\n\t\tvrr_modes[use_vrr].active = 1;\n\t\tprintf(\"VRR: Set %s active\\n\", vrr_modes[use_vrr].description);\n\t\tif (use_vrr == VRR_VESA)\n\t\t{\n\t\t\tprintf(\"VESA Frame Rate %d Front Porch %d\\n\", (int)vrateh, v_cur.param.vfp);\n\t\t}\n\t}\n\n\tint16_t vrateh_i = (int16_t)vrateh;\n\n\t//These are only sent in the case that freesync or vesa vrr is enabled\n\tuint8_t freesync_data[] = {\n\t\t//header\n\t\t0x00, 0x83,\n\t\t0x01, 0x01,\n\t\t0x02, 0x08,\n\t\t//data\n\t\t0x04, 0x1A,\n\t\t0x05, 0x00,\n\t\t0x06, 0x00,\n\t\t//0x07\n\t\t//0x08\n\t\t0x09, 0x07,\n\t\t0x0A, vrr_min_fr,\n\t\t0x0B, vrr_max_fr,\n\t};\n\n\tuint8_t vesa_data[] = {\n\t\t0xC0, 0x7F,\n\t\t0xC1, 0xC0,\n\t\t0xC2, 0x00,\n\n\t\t0xC3, 0x40,\n\t\t0xC5, 0x01,\n\t\t0xC6, 0x00,\n\t\t0xC7, 0x01,\n\t\t0xC8, 0x00,\n\t\t0xC9, 0x04,\n\n\t\t0xCA, 0x01,\n\t\t0xCB, (uint8_t)v_cur.param.vfp,\n\t\t0xCC, (uint8_t)((vrateh_i >> 8) & 0x03),\n\t\t0xCD, (uint8_t)(vrateh_i & 0xFF),\n\t};\n\n\tint res = 0;\n\tint fd = i2c_open(0x38, 0);\n\tif (fd >= 0)\n\t{\n\t\tif (use_vrr == VRR_FREESYNC)\n\t\t{\n\t\t\thdmi_config_set_spd(1);\n\t\t\tres = i2c_smbus_write_byte_data(fd, 0x1F, 0b10000000);\n\t\t\tif (res < 0)\n\t\t\t{\n\t\t\t\tprintf(\"i2c: Vrr: Couldn't update SPD change register (0x1F, 0x80) %d\\n\", res);\n\t\t\t}\n\t\t\tfor (uint i = 0; i < sizeof(freesync_data); i += 2)\n\t\t\t{\n\t\t\t\tres = i2c_smbus_write_byte_data(fd, freesync_data[i], freesync_data[i + 1]);\n\t\t\t\tif (res < 0) printf(\"i2c: Vrr register write error (%02X %02x): %d\\n\", freesync_data[i], freesync_data[i + 1], res);\n\t\t\t}\n\t\t\tres = i2c_smbus_write_byte_data(fd, 0x1F, 0x00);\n\t\t\tif (res < 0) printf(\"i2c: Vrr: Couldn't update SPD change register (0x1F, 0x00), %d\\n\", res);\n\t\t}\n\t\telse\n\t\t{\n\t\t\thdmi_config_set_spd(0);\n\t\t}\n\n\t\tif (use_vrr == VRR_VESA)\n\t\t{\n\t\t\thdmi_config_set_spare(0, true);\n\t\t\tres = i2c_smbus_write_byte_data(fd, 0xDF, 0b10000000);\n\t\t\tif (res < 0)\n\t\t\t{\n\t\t\t\tprintf(\"i2c: Vrr: Couldn't update Spare Packet change register (0xDF, 0x80) %d\\n\", res);\n\t\t\t}\n\n\t\t\tfor (uint i = 0; i < sizeof(vesa_data); i += 2)\n\t\t\t{\n\t\t\t\tres = i2c_smbus_write_byte_data(fd, vesa_data[i], vesa_data[i + 1]);\n\t\t\t\tif (res < 0) printf(\"i2c: Vrr register write error (%02X %02x): %d\\n\", vesa_data[i], vesa_data[i + 1], res);\n\t\t\t}\n\t\t\tres = i2c_smbus_write_byte_data(fd, 0xDF, 0x00);\n\t\t\tif (res < 0) printf(\"i2c: Vrr: Couldn't update Spare Packet change register (0xDF, 0x00), %d\\n\", res);\n\t\t}\n\t\telse\n\t\t{\n\t\t\thdmi_config_set_spare(0, false);\n\t\t}\n\t\ti2c_close(fd);\n\t}\n\tlast_vrr_mode = cfg.vrr_mode;\n\tlast_vrr_rate = vrateh;\n\tlast_vrr_vfp = v_cur.param.vfp;\n\n\tif (!supports_vrr() || cfg.vsync_adjust) use_vrr = 0;\n}\n\nstatic void video_set_mode(vmode_custom_t *v, double Fpix)\n{\n\tPROFILE_FUNCTION();\n\n\tsetGamma();\n\tsetScaler();\n\n\tv_cur = *v;\n\tvmode_custom_t v_fix = v_cur;\n\tif (cfg.direct_video)\n\t{\n\t\tv_fix.item[2] = FB_DV_RBRD;\n\t\tv_fix.item[4] = FB_DV_LBRD;\n\t\tv_fix.item[1] += v_cur.item[2] - v_fix.item[2];\n\t\tv_fix.item[1] += v_cur.item[4] - v_fix.item[4];\n\n\t\tv_fix.item[6] = FB_DV_BBRD;\n\t\tv_fix.item[8] = FB_DV_UBRD;;\n\t\tv_fix.item[5] += v_cur.item[6] - v_fix.item[6];\n\t\tv_fix.item[5] += v_cur.item[8] - v_fix.item[8];\n\t}\n\telse\n\t{\n\t\tset_vrr_mode();\n\t}\n\n\tif (Fpix) setPLL(Fpix, &v_cur);\n\tif (use_vrr)\n\t{\n\t\tprintf(\"Requested variable refresh rate: min=%dHz, max=%dHz\\n\", vrr_min_fr, vrr_max_fr);\n\t\tint horz = v_fix.param.hact + v_fix.param.hbp + v_fix.param.hfp + v_fix.param.hs;\n\n#if 0\n\t\t// variant 1: try to reduce vblank to reach max refresh rate but keep original pixel clock.\n\t\t// try to adjust VBlank to match max refresh\n\t\tint vbl_fmax = ((v_cur.Fpix * 1000000.f) / (vrr_max_fr * horz)) - v_fix.param.vact - v_fix.param.vs - 1;\n\t\tif (vbl_fmax < 2) vbl_fmax = 2;\n\t\tint vfp = vbl_fmax - v_fix.param.vbp;\n\t\tv_fix.param.vfp = vfp;\n\t\tif (vfp < 1)\n\t\t{\n\t\t\tv_fix.param.vfp = 1;\n\t\t\tv_fix.param.vbp = vbl_fmax - 1;\n\t\t}\n\t\tint vert = v_fix.param.vact + v_fix.param.vbp + v_fix.param.vfp + v_fix.param.vs;\n#else\n\t\t// variant 2: keep original vblank and adjust pixel clock to max refresh rate\n\t\tint vert = v_fix.param.vact + v_fix.param.vbp + v_fix.param.vfp + v_fix.param.vs;\n\t\tFpix = horz * vert * vrr_max_fr;\n\t\tFpix /= 1000000.f;\n\t\tsetPLL(Fpix, &v_cur);\n#endif\n\n\t\tdouble freq_max = (v_cur.Fpix * 1000000.f) / (horz * vert);\n\t\tdouble freq_min = vrr_min_fr;\n\t\tint vfp_vrr = 0;\n\t\tif (freq_min && freq_min < freq_max)\n\t\t{\n\t\t\tvfp_vrr = ((v_cur.Fpix * 1000000.f) / (vrr_min_fr * horz)) - vert + 1;\n\t\t\tv_fix.param.vfp += vfp_vrr;\n\t\t\tif (v_fix.param.vfp > 4095) v_fix.param.vfp = 4095;\n\t\t}\n\n\t\tvert = v_fix.param.vact + v_fix.param.vbp + v_fix.param.vfp + v_fix.param.vs;\n\t\tfreq_min = (v_cur.Fpix * 1000000.f) / (horz * vert);\n\t\tprintf(\"Using variable refresh rate: min=%2.1fHz, max=%2.1fHz. Additional VFP lines: %d\\n\", freq_min, freq_max, vfp_vrr);\n\t}\n\n\tprintf(\"Send HDMI parameters:\\n\");\n\tspi_uio_cmd_cont(UIO_SET_VIDEO);\n\tprintf(\"video: \");\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tif (i == 1) spi_w((v_cur.param.pr << 15) | ((use_vrr ? 1 : 0) << 14) | v_fix.item[i]);\n\t\t//hsync polarity\n\t\telse if (i == 3) spi_w((!!v_cur.param.hpol << 15) | v_fix.item[i]);\n\t\t//vsync polarity\n\t\telse if (i == 7) spi_w((!!v_cur.param.vpol << 15) | v_fix.item[i]);\n\t\telse spi_w(v_fix.item[i]);\n\t\tprintf(\"%d(%d), \", v_cur.item[i], v_fix.item[i]);\n\t}\n\n\tprintf(\"%chsync, %cvsync\\n\", !!v_cur.param.hpol ? '+' : '-', !!v_cur.param.vpol ? '+' : '-');\n\n\tprintf(\"PLL: \");\n\tfor (int i = 9; i < 21; i++)\n\t{\n\t\tprintf(\"0x%X, \", v_cur.item[i]);\n\t\tif (i & 1) spi_w(v_cur.item[i] | ((i == 9 && Fpix && cfg.vsync_adjust == 2 && !is_menu()) ? 0x8000 : 0) | 0x4000);\n\t\telse\n\t\t{\n\t\t\tspi_w(v_cur.item[i]);\n\t\t\tspi_w(v_cur.item[i] >> 16);\n\t\t}\n\t}\n\n\tprintf(\"Fpix=%f\\n\", v_cur.Fpix);\n\tDisableIO();\n\n\thdmi_config_set_mode(&v_cur);\n\n\tvideo_fb_config();\n\n\tsetShadowMask();\n}\n\nstatic int parse_custom_video_mode(char* vcfg, vmode_custom_t *v)\n{\n\tchar *tokens[32];\n\tuint32_t val[32];\n\tdouble valf = 0;\n\n\tchar work[1024];\n\tchar *next;\n\n\tif (!vcfg[0]) return -1;\n\n\tmemset(v, 0, sizeof(vmode_custom_t));\n\tv->param.rb = 1; // default reduced blanking to true\n\n\tint token_cnt = str_tokenize(strcpyz(work, vcfg), \",\", tokens, 32);\n\n\tint cnt;\n\tfor (cnt = 0; cnt < token_cnt; cnt++)\n\t{\n\t\tval[cnt] = strtoul(tokens[cnt], &next, 0);\n\t\tif (*next)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cnt == 2 && token_cnt > 2)\n\t{\n\t\tvalf = strtod(tokens[cnt], &next);\n\t\tif (!*next) cnt++;\n\t}\n\n\tfor (int i = cnt; i < token_cnt; i++)\n\t{\n\t\tconst char *flag = tokens[i];\n\t\tif (!strcasecmp(flag, \"+vsync\")) v->param.vpol = 1;\n\t\telse if (!strcasecmp(flag, \"-vsync\")) v->param.vpol = 0;\n\t\telse if (!strcasecmp(flag, \"+hsync\")) v->param.hpol = 1;\n\t\telse if (!strcasecmp(flag, \"-hsync\")) v->param.hpol = 0;\n\t\telse if (!strcasecmp(flag, \"cvt\")) v->param.rb = 0;\n\t\telse if (!strcasecmp(flag, \"cvtrb\")) v->param.rb = 1;\n\t\telse if (!strcasecmp(flag, \"pr\")) v->param.pr = 1;\n\t\telse\n\t\t{\n\t\t\tprintf(\"Error parsing video_mode parameter %d \\\"%s\\\": \\\"%s\\\"\\n\", i, flag, vcfg);\n\t\t\tcfg_error(\"Invalid video_mode\\n> %s\", vcfg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (cnt == 1)\n\t{\n\t\tv->item[0] = val[0];\n\t\tprintf(\"Set predefined video_mode to %d\\n\", v->item[0]);\n\t\treturn v->item[0];\n\t}\n\telse if (cnt == 3)\n\t{\n\t\tvideo_calculate_cvt(val[0], val[1], valf ? valf : val[2], v->param.rb, v);\n\t}\n\telse if (cnt >= 21)\n\t{\n\t\tfor (int i = 0; i < cnt; i++)\n\t\t\tv->item[i] = val[i];\n\t}\n\telse if (cnt == 9 || cnt == 11)\n\t{\n\t\tv->item[0] = 1;\n\t\tfor (int i = 0; i < 8; i++)\n\t\t\tv->item[i + 1] = val[i];\n\n\t\tv->Fpix = val[8] / 1000.0;\n\n\t\tif (cnt == 11)\n\t\t{\n\t\t\tv->param.hpol = val[9];\n\t\t\tv->param.vpol = val[10];\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"Error parsing video_mode parameter: \"\"%s\"\"\\n\", vcfg);\n\t\tcfg_error(\"Invalid video_mode\\n> %s\", vcfg);\n\t\treturn -1;\n\t}\n\n\tsetPLL(v->Fpix, v);\n\treturn -2;\n}\n\nstatic int store_custom_video_mode(char* vcfg, vmode_custom_t *v)\n{\n\tint ret = parse_custom_video_mode(vcfg, v);\n\tif (ret == -2) return 1;\n\n\tuint mode = (ret >= 0) ? ret : (support_FHD) ? 8 : 0;\n\tif (mode >= VMODES_NUM) mode = 0;\n\tif (vmodes[mode].pr == 1 && !supports_pr()) mode = 8;\n\tfor (int i = 0; i < 8; i++) v->item[i + 1] = vmodes[mode].vpar[i];\n\tv->param.vic = vmodes[mode].vic_mode;\n\tv->param.pr = vmodes[mode].pr;\n\tv->param.rb = 1;\n\tsetPLL(vmodes[mode].Fpix, v);\n\n\treturn ret >= 0;\n}\n\nstatic void fb_init()\n{\n\tif (!fb_base)\n\t{\n\t\tfb_base = (volatile uint32_t*)shmem_map(FB_ADDR, FB_SIZE * 4 * 3);\n\t\tif (!fb_base)\n\t\t{\n\t\t\tprintf(\"Unable to mmap FB!\\n\");\n\t\t}\n\t}\n\tspi_uio_cmd16(UIO_SET_FBUF, 0);\n}\n\nstatic void video_mode_load()\n{\n\tif (cfg.direct_video && cfg.vsync_adjust)\n\t{\n\t\tprintf(\"Disabling vsync_adjust because of enabled direct video.\\n\");\n\t\tcfg.vsync_adjust = 0;\n\t}\n\n\tif (cfg.direct_video)\n\t{\n\t\tint mode = cfg.menu_pal ? 2 : 0;\n\t\tif (cfg.forced_scandoubler) mode++;\n\n\t\tmemset(&v_def, 0, sizeof(v_def));\n\n\t\tv_def.item[0] = mode;\n\t\tfor (int i = 0; i < 8; i++) v_def.item[i + 1] = tvmodes[mode].vpar[i];\n\t\tsetPLL(tvmodes[mode].Fpix, &v_def);\n\n\t\tvmode_def = 1;\n\t\tvmode_pal = 0;\n\t\tvmode_ntsc = 0;\n\t}\n\telse\n\t{\n\t\tvmode_def = 0;\n\t\tif (!strlen(cfg.video_conf) && !strlen(cfg.video_conf_pal) && !strlen(cfg.video_conf_ntsc))\n\t\t{\n\t\t\tvmode_def = get_edid_vmode(&v_def);\n\t\t}\n\n\t\tif (!vmode_def)\n\t\t{\n\t\t\tvmode_def = store_custom_video_mode(cfg.video_conf, &v_def);\n\t\t\tvmode_pal = store_custom_video_mode(cfg.video_conf_pal, &v_pal);\n\t\t\tvmode_ntsc = store_custom_video_mode(cfg.video_conf_ntsc, &v_ntsc);\n\t\t}\n\t}\n}\n\nstatic void video_cfg_init()\n{\n\tsprintf(gamma_cfg_path, \"%s_gamma.cfg\", user_io_get_core_name());\n\tsprintf(scaler_cfg_path, \"%s_scaler.cfg\", user_io_get_core_name());\n\tsprintf(shadow_mask_cfg_path, \"%s_shmask.cfg\", user_io_get_core_name());\n\n\tmemset(gamma_cfg, 0, sizeof(gamma_cfg));\n\tmemset(scaler_flt, 0, sizeof(scaler_flt));\n\tmemset(shadow_mask_cfg, 0, sizeof(shadow_mask_cfg));\n\n\tif (cfg.preset_default[0])\n\t{\n\t\tchar preset_path[1024];\n\t\tint len = sprintfz(preset_path, \"%s/%s\", PRESET_DIR, cfg.preset_default);\n\t\tif (len < 4 || strcasecmp(&preset_path[len - 4], \".ini\"))\n\t\t\tstrcat(preset_path, \".ini\");\n\t\tvideo_loadPreset(preset_path, false);\n\t}\n\n\tloadGammaCfg();\n\tloadScalerCfg();\n\tloadShadowMaskCfg();\n}\n\nvoid video_cfg_reset()\n{\n\tFileDeleteConfig(gamma_cfg_path);\n\tFileDeleteConfig(scaler_cfg_path);\n\tFileDeleteConfig(shadow_mask_cfg_path);\n\n\tvideo_cfg_init();\n\n\tsetGamma();\n\tsetScaler();\n\tsetShadowMask();\n}\n\nvoid video_init()\n{\n\tyc_parse(yc_modes, sizeof(yc_modes) / sizeof(yc_modes[0]));\n\n\tfb_init();\n\thdmi_config_init();\n\thdmi_config_set_hdr();\n\tvideo_mode_load();\n\n\thas_gamma = spi_uio_cmd(UIO_SET_GAMMA);\n\n\tvideo_cfg_init();\n\n\tvideo_set_mode(&v_def, 0);\n}\n\n\nstatic int api1_5 = 0;\nint hasAPI1_5()\n{\n\treturn api1_5 || is_menu();\n}\n\nstatic bool get_video_info(bool force, VideoInfo *video_info)\n{\n\tstatic uint16_t nres = 0;\n\tbool res_changed = false;\n\tbool fb_changed = false;\n\n\tspi_uio_cmd_cont(UIO_GET_VRES);\n\tuint16_t res = spi_w(0);\n\tif ((nres != res) || force)\n\t{\n\t\tres_changed = (nres != res);\n\t\tnres = res;\n\t\tvideo_info->width = spi_w(0) | (spi_w(0) << 16);\n\t\tvideo_info->height = spi_w(0) | (spi_w(0) << 16);\n\t\tvideo_info->htime = spi_w(0) | (spi_w(0) << 16);\n\t\tvideo_info->vtime = spi_w(0) | (spi_w(0) << 16);\n\t\tvideo_info->ptime = spi_w(0) | (spi_w(0) << 16);\n\t\tvideo_info->vtimeh = spi_w(0) | (spi_w(0) << 16);\n\t\tvideo_info->ctime = spi_w(0) | (spi_w(0) << 16);\n\t\tvideo_info->pixrep = spi_w(0);\n\t\tvideo_info->de_h = spi_w(0);\n\t\tvideo_info->de_v = spi_w(0);\n\t\tvideo_info->interlaced = ( res & 0x100 ) != 0;\n\t\tvideo_info->rotated = ( res & 0x200 ) != 0;\n\t}\n\telse\n\t{\n\t\t*video_info = current_video_info;\n\t}\n\tDisableIO();\n\n\tstatic uint8_t fb_crc = 0;\n\tuint8_t crc = spi_uio_cmd_cont(UIO_GET_FB_PAR);\n\tif (fb_crc != crc || force || res_changed)\n\t{\n\t\tfb_changed |= (fb_crc != crc);\n\t\tfb_crc = crc;\n\t\tvideo_info->arx = spi_w(0);\n\t\tvideo_info->arxy = !!(video_info->arx & 0x1000);\n\t\tvideo_info->arx &= 0xFFF;\n\t\tvideo_info->ary = spi_w(0) & 0xFFF;\n\t\tvideo_info->fb_fmt = spi_w(0);\n\t\tvideo_info->fb_width = spi_w(0);\n\t\tvideo_info->fb_height = spi_w(0);\n\t\tvideo_info->fb_en = !!(video_info->fb_fmt & 0x40);\n\t}\n\tDisableIO();\n\n\treturn res_changed || fb_changed;\n}\n\nstatic void video_core_description(const VideoInfo *vi, const vmode_custom_t */*vm*/, char *str, size_t len)\n{\n\tfloat vrate = 100000000;\n\tif (vi->vtime) vrate /= vi->vtime; else vrate = 0;\n\tfloat hrate = 100000;\n\tif (vi->htime) hrate /= vi->htime; else hrate = 0;\n\n\tfloat prate = vi->width * 100;\n\tprate /= vi->ptime;\n\n\tchar res[16];\n\tsnprintf(res, 16, \"%dx%d%s\", vi->fb_en ? vi->fb_width : vi->width, vi->fb_en ? vi->fb_height : vi->height, vi->interlaced ? \"i\" : \"\");\n\tsnprintf(str, len, \"%9s %6.2fKHz %5.1fHz\", res, hrate, vrate);\n}\n\nstatic void video_scaler_description(const VideoInfo *vi, const vmode_custom_t *vm, char *str, size_t len)\n{\n\tchar res[16];\n\tfloat vrateh = 100000000;\n\tif (vi->vtimeh) vrateh /= vi->vtimeh; else vrateh = 0;\n\tsnprintf(res, 16, \"%dx%d\", vm->item[1] * (vm->param.pr ? 2 : 1), vm->item[5]);\n\tsnprintf(str, len, \"%9s %6.2fMHz %5.1fHz\", res, vm->Fpix, vrateh);\n}\n\nvoid video_core_description(char *str, size_t len)\n{\n\tvideo_core_description(&current_video_info, &v_cur, str, len);\n}\n\nvoid video_scaler_description(char *str, size_t len)\n{\n\tvideo_scaler_description(&current_video_info, &v_cur, str, len);\n}\n\nchar* video_get_core_mode_name(int with_vrefresh)\n{\n\tstatic char tmp[256] = {};\n\n\tif (with_vrefresh)\n\t{\n\t\tfloat vrate = 100000000;\n\t\tif (current_video_info.vtime) vrate /= current_video_info.vtime; else vrate = 0;\n\n\t\tsnprintf(tmp, sizeof(tmp), \"%dx%d@%.1f\", current_video_info.width, current_video_info.height, vrate);\n\t}\n\telse\n\t{\n\t\tsnprintf(tmp, sizeof(tmp), \"%dx%d\", current_video_info.width, current_video_info.height);\n\t}\n\n\treturn tmp;\n}\n\nstatic void show_video_info(const VideoInfo *vi, const vmode_custom_t *vm)\n{\n\tfloat vrate = 100000000;\n\tif (vi->vtime) vrate /= vi->vtime; else vrate = 0;\n\tfloat hrate = 100000;\n\tif (vi->htime) hrate /= vi->htime; else hrate = 0;\n\n\tfloat prate = vi->width * 100;\n\tprate /= vi->ptime;\n\n\tfloat crate = vi->ctime * 100;\n\tcrate /= vi->ptime;\n\n\tprintf(\"\\033[1;33mINFO: Video resolution: %u x %u%s, fHorz = %.1fKHz, fVert = %.1fHz, fPix = %.2fMHz, fVid = %.2fMHz\\033[0m\\n\",\n\t\tvi->width, vi->height, vi->interlaced ? \"i\" : \"\", hrate, vrate, prate, crate);\n\tprintf(\"\\033[1;33mINFO: pr = %d, de_h = %d, de_v = %d\\033[0m\\n\", vi->pixrep, vi->de_h, vi->de_v);\n\tprintf(\"\\033[1;33mINFO: Frame time (100MHz counter): VGA = %d, HDMI = %d\\033[0m\\n\", vi->vtime, vi->vtimeh);\n\tprintf(\"\\033[1;33mINFO: AR = %d:%d, fb_en = %d, fb_width = %d, fb_height = %d\\033[0m\\n\", vi->arx, vi->ary, vi->fb_en, vi->fb_width, vi->fb_height);\n\tif (vi->vtimeh) api1_5 = 1;\n\tif (hasAPI1_5() && cfg.video_info)\n\t{\n\t\tchar str[128], res1[64], res2[64];\n\t\tvideo_core_description(vi, vm, res1, 64);\n\t\tvideo_scaler_description(vi, vm, res2, 64);\n\t\tsnprintf(str, 128, \"%s\\n\" \\\n\t\t\t\"\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\x81\\n\" \\\n\t\t\t\"%s\", res1, res2);\n\t\tInfo(str, cfg.video_info * 1000);\n\t}\n}\n\nstatic void video_resolution_adjust(const VideoInfo *vi, vmode_custom_t *vm)\n{\n\tif (cfg.vscale_mode < 4) return;\n\n\tint w = vm->param.pr ? vm->param.hact * 2 : vm->param.hact;\n\tint h = vm->param.vact;\n\tconst uint32_t core_height = vi->fb_en ? vi->fb_height : vi->rotated ? vi->width : vi->height;\n\tconst uint32_t core_width = vi->fb_en ? vi->fb_width : vi->rotated ? vi->height : vi->width;\n\n\tif (w == 0 || h == 0 || core_height == 0 || core_width == 0)\n\t{\n\t\tprintf(\"video_resolution_adjust: invalid core or display sizes. Not adjusting resolution.\\n\");\n\t\treturn;\n\t}\n\n\tint scale_h = h / core_height;\n\tif (!scale_h)\n\t{\n\t\tprintf(\"video_resolution_adjust: display height less than core height. Not adjusting resolution.\\n\");\n\t\treturn;\n\t}\n\n\tint ary = vi->ary;\n\tint arx = vi->arx;\n\tif (!ary || !arx)\n\t{\n\t\tary = h;\n\t\tarx = w;\n\t}\n\n\tint scale_w = (w * ary) / (core_height * arx);\n\tif (!scale_w)\n\t{\n\t\tprintf(\"video_resolution_adjust: display width less than core width. Not adjusting resolution.\\n\");\n\t\treturn;\n\t}\n\n\tint scale = scale_h > scale_w ? scale_w : scale_h;\n\n\tint disp_h = core_height * scale;\n\tint core_ar_width = (disp_h * arx) / ary;\n\tint disp_ar_width = (disp_h * w) / h;\n\tint disp_w;\n\n\tif (cfg.vscale_mode == 5)\n\t{\n\t\tif (disp_ar_width < core_ar_width)\n\t\t{\n\t\t\tprintf(\"video_resolution_adjust: ideal width %d wider than aspect restricted width %dx%d. Not adjusting resolution.\\n\", core_ar_width, disp_ar_width, disp_h);\n\t\t\treturn;\n\t\t}\n\t\tdisp_w = disp_ar_width;\n\t\tprintf(\"video_resolution_adjust: using display aspect ratio - \");\n\t}\n\telse\n\t{\n\t\tdisp_w = core_ar_width;\n\t\tprintf(\"video_resolution_adjust: using core aspect ratio - \");\n\t}\n\n\tdisp_w = (disp_w + 7) & ~0x7; // round up to 8\n\n\tprintf(\"scale x%d, %dx%d.\\n\", scale, disp_w, disp_h);\n\n\tfloat refresh = 1000000.0 / ((vm->item[1] + vm->item[2] + vm->item[3] + vm->item[4])*(vm->item[5] + vm->item[6] + vm->item[7] + vm->item[8]) / vm->Fpix);\n\tvideo_calculate_cvt(disp_w, disp_h, refresh, vm->param.rb, vm);\n\tsetPLL(vm->Fpix, vm);\n}\n\nstatic void video_scaling_adjust(const VideoInfo *vi, const vmode_custom_t *vm)\n{\n\tif (cfg.vscale_mode >= 4)\n\t{\n\t\tspi_uio_cmd16(UIO_SETHEIGHT, 0);\n\t\tspi_uio_cmd16(UIO_SETWIDTH, 0);\n\t\treturn;\n\t}\n\n\tconst uint32_t height = vi->rotated ? vi->width : vi->height;\n\n\tuint32_t scrh = vm->item[5];\n\tif (scrh)\n\t{\n\t\tif (cfg.vscale_mode && height)\n\t\t{\n\t\t\tuint32_t div = 1 << (cfg.vscale_mode - 1);\n\t\t\tuint32_t mag = (scrh*div) / height;\n\t\t\tscrh = (height * mag) / div;\n\t\t\tprintf(\"Set vertical scaling to : %d\\n\", scrh);\n\t\t\tspi_uio_cmd16(UIO_SETHEIGHT, scrh);\n\t\t}\n\t\telse if (cfg.vscale_border)\n\t\t{\n\t\t\tuint32_t border = cfg.vscale_border * 2;\n\t\t\tif ((border + 100) > scrh) border = scrh - 100;\n\t\t\tscrh -= border;\n\t\t\tprintf(\"Set max vertical resolution to : %d\\n\", scrh);\n\t\t\tspi_uio_cmd16(UIO_SETHEIGHT, scrh);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tspi_uio_cmd16(UIO_SETHEIGHT, 0);\n\t\t}\n\t}\n\n\tuint32_t scrw = vm->item[1];\n\tif (scrw)\n\t{\n\t\tif (cfg.vscale_border && !(cfg.vscale_mode && height))\n\t\t{\n\t\t\tuint32_t border = cfg.vscale_border * 2;\n\t\t\tif ((border + 100) > scrw) border = scrw - 100;\n\t\t\tscrw -= border;\n\t\t\tprintf(\"Set max horizontal resolution to : %d\\n\", scrw);\n\t\t\tspi_uio_cmd16(UIO_SETWIDTH, scrw);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tspi_uio_cmd16(UIO_SETWIDTH, 0);\n\t\t}\n\t}\n\n\tminimig_set_adjust(2);\n}\n\nbool video_mode_select(uint32_t vtime, vmode_custom_t* out_mode)\n{\n\tvmode_custom_t *v = &v_def;\n\tbool adjustable = true;\n\n\tprintf(\"\\033[1;33mvideo_mode_select(%u): \", vtime);\n\n\tif (vtime == 0 || !cfg.vsync_adjust)\n\t{\n\t\tprintf(\", using default mode\");\n\t\tadjustable = false;\n\t}\n\telse if (vmode_pal || vmode_ntsc)\n\t{\n\t\tif (vtime > 1800000)\n\t\t{\n\t\t\tif (vmode_pal)\n\t\t\t{\n\t\t\t\tprintf(\", using PAL mode\");\n\t\t\t\tv = &v_pal;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\", PAL mode cannot be used. Using predefined NTSC mode\");\n\t\t\t\tv = &v_ntsc;\n\t\t\t\tadjustable = false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (vmode_ntsc)\n\t\t\t{\n\t\t\t\tprintf(\", using NTSC mode\");\n\t\t\t\tv = &v_ntsc;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\", NTSC mode cannot be used. Using predefined PAL mode\");\n\t\t\t\tv = &v_pal;\n\t\t\t\tadjustable = false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\", using default mode\");\n\t}\n\tprintf(\".\\033[0m\\n\");\n\tmemcpy(out_mode, v, sizeof(vmode_custom_t));\n\treturn adjustable;\n}\n\nstatic void set_yc_mode()\n{\n\tif (cfg.vga_mode_int >= 2)\n\t{\n\t\tfloat fps = current_video_info.vtime ? (100000000.f / current_video_info.vtime) : 0.f;\n\t\tint pal = fps < 55.f;\n\t\tdouble CLK_REF = (pal || (cfg.ntsc_mode == 1)) ? 4.43361875f : (cfg.ntsc_mode == 2) ? 3.575611f : 3.579545f;\n\t\tdouble CLK_VIDEO = current_video_info.ctime * 100.f / current_video_info.ptime;\n\n\t\tfloat prate = current_video_info.width * 100.f;\n\t\tprate /= current_video_info.ptime;\n\n\t\tint64_t PHASE_INC = ((int64_t)((CLK_REF / CLK_VIDEO) * 1099511627776LL)) & 0xFFFFFFFFFFLL;\n\n\t\tint COLORBURST_START = (int)(3.7f * (CLK_VIDEO / CLK_REF));\n\t\tint COLORBURST_END = (int)(9.0f * (CLK_VIDEO / CLK_REF)) + COLORBURST_START;\n\t\tint COLORBURST_RANGE = (COLORBURST_START << 10) | COLORBURST_END;\n\n\t\tchar yc_key[64];\n\t\tchar yc_key_expand[64];\n\t\tsprintf(yc_key, \"%s_%.1f%s%s\", user_io_get_core_name(1), fps, current_video_info.interlaced ? \"i\" : \"\", (pal || !cfg.ntsc_mode) ? \"\" : (cfg.ntsc_mode == 1) ? \"s\" : \"m\");\n\t\tsnprintf(yc_key_expand, sizeof(yc_key_expand), \"%s_%.2f\", yc_key, prate);\n\t\tprintf(\"Calculated YC parameters for '%s': %s PHASE_INC=%lld, COLORBURST_START=%d, COLORBURST_END=%d\\n\", yc_key, pal ? \"PAL\" : (cfg.ntsc_mode == 1) ? \"PAL60\" : (cfg.ntsc_mode == 2) ? \"PAL-M\" : \"NTSC\", PHASE_INC, COLORBURST_START, COLORBURST_END);\n\n\t\tfor (uint i = 0; i < sizeof(yc_modes) / sizeof(yc_modes[0]); i++)\n\t\t{\n\t\tif (!strcasecmp(yc_modes[i].key, yc_key) || !strcasecmp(yc_modes[i].key, yc_key_expand))\n\t\t\t{\n\t\t\t\tprintf(\"Override YC PHASE_INC with value: %lld\\n\", yc_modes[i].phase_inc);\n\t\t\t\tPHASE_INC = yc_modes[i].phase_inc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspi_uio_cmd_cont(UIO_SET_YC_PAR);\n\t\tspi_w(((pal || cfg.ntsc_mode) ? 4 : 0) | ((cfg.vga_mode_int == 3) ? 3 : 1));\n\t\tspi_w(PHASE_INC);\n\t\tspi_w(PHASE_INC >> 16);\n\t\tspi_w(PHASE_INC >> 32);\n\t\tspi_w(COLORBURST_RANGE);\n\t\tspi_w(COLORBURST_RANGE >> 16);\n\t\tDisableIO();\n\t}\n\telse\n\t{\n\t\tspi_uio_cmd8(UIO_SET_YC_PAR, 0);\n\t}\n}\n\nvoid video_mode_adjust()\n{\n\tstatic bool force = false;\n\n\tVideoInfo video_info;\n\n\tconst bool vid_changed = get_video_info(force, &video_info);\n\n\tif (vid_changed || force)\n\t{\n\t\tcurrent_video_info = video_info;\n\t\tshow_video_info(&video_info, &v_cur);\n\t\tset_yc_mode();\n\t\tif (cfg.direct_video) spd_config_dv();\n\t\t//else if(use_vrr != VRR_FREESYNC) spd_config_hdmi();\n\t}\n\tforce = false;\n\n\tif (cfg.direct_video)\n\t{\n\t\tstatic int menu = 0;\n\t\tint menu_now = menu_present();\n\t\tif(menu != menu_now) spd_config_dv();\n\t\tmenu = menu_now;\n\t}\n\n\tif (vid_changed && !is_menu())\n\t{\n\t\tif (cfg_has_video_sections())\n\t\t{\n\t\t\tcfg_parse();\n\t\t\tvideo_mode_load();\n\t\t\tuser_io_send_buttons(1);\n\t\t}\n\n\t\tif ((cfg.vsync_adjust || cfg.vscale_mode >= 4))\n\t\t{\n\t\t\tconst uint32_t vtime = video_info.vtime;\n\n\t\t\tprintf(\"\\033[1;33madjust_video_mode(%u): vsync_adjust=%d vscale_mode=%d.\\033[0m\\n\", vtime, cfg.vsync_adjust, cfg.vscale_mode);\n\n\t\t\tvmode_custom_t new_mode;\n\t\t\tbool adjust = video_mode_select(vtime, &new_mode);\n\n\t\t\tvideo_resolution_adjust(&video_info, &new_mode);\n\n\t\t\tvmode_custom_t *v = &new_mode;\n\t\t\tdouble Fpix = 0;\n\t\t\tif (adjust)\n\t\t\t{\n\t\t\t\tFpix = 100 * (v->item[1] + v->item[2] + v->item[3] + v->item[4]) * (v->item[5] + v->item[6] + v->item[7] + v->item[8]);\n\t\t\t\tFpix /= vtime;\n\t\t\t\tif (Fpix < 2.f || Fpix > 300.f)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Estimated Fpix(%.4f MHz) is outside supported range. Canceling auto-adjust.\\n\", Fpix);\n\t\t\t\t\tFpix = 0;\n\t\t\t\t}\n\n\t\t\t\tfloat hz = 100000000.0f / vtime;\n\t\t\t\tif (cfg.refresh_min && hz < cfg.refresh_min)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Estimated frame rate (%f Hz) is less than REFRESH_MIN(%f Hz). Canceling auto-adjust.\\n\", hz, cfg.refresh_min);\n\t\t\t\t\tFpix = 0;\n\t\t\t\t}\n\n\t\t\t\tif (cfg.refresh_max && hz > cfg.refresh_max)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Estimated frame rate (%f Hz) is more than REFRESH_MAX(%f Hz). Canceling auto-adjust.\\n\", hz, cfg.refresh_max);\n\t\t\t\t\tFpix = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvideo_set_mode(v, Fpix);\n\t\t\tuser_io_send_buttons(1);\n\t\t\tforce = true;\n\t\t}\n\t\telse if (cfg_has_video_sections()) // if we have video sections but aren't updating the resolution for other reasons, then do it here\n\t\t{\n\t\t\tvideo_set_mode(&v_def, 0);\n\t\t\tuser_io_send_buttons(1);\n\t\t\tforce = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tset_vfilter(1); // force update filters in case interlacing changed\n\t\t}\n\n\t\tvideo_scaling_adjust(&video_info, &v_cur);\n\t}\n\telse\n\t{\n\t\tset_vfilter(0); // update filters if flags have changed\n\t}\n}\n\nstatic void fb_write_module_params()\n{\n\tint width = fb_width;\n\tint height = fb_height;\n\toffload_add_work([=]\n\t{\n\t\tFILE *fp = fopen(\"/sys/module/MiSTer_fb/parameters/mode\", \"wt\");\n\t\tif (fp)\n\t\t{\n\t\t\tfprintf(fp, \"%d %d %d %d %d\\n\", 8888, 1, width, height, width * 4);\n\t\t\tfclose(fp);\n\t\t}\n\t});\n}\n\nvoid video_fb_enable(int enable, int n)\n{\n\tPROFILE_FUNCTION();\n\n\tif (fb_base)\n\t{\n\t\tint res = spi_uio_cmd_cont(UIO_SET_FBUF);\n\t\tif (res)\n\t\t{\n\t\t\tif (is_menu() && !enable && menu_bg)\n\t\t\t{\n\t\t\t\tenable = 1;\n\t\t\t\tn = menu_bgn;\n\t\t\t}\n\n\t\t\tif (enable)\n\t\t\t{\n\t\t\t\tuint32_t fb_addr = FB_ADDR + (FB_SIZE * 4 * n) + (n ? 0 : 4096);\n\t\t\t\tfb_num = n;\n\n\t\t\t\tint xoff = 0, yoff = 0;\n\t\t\t\tif (cfg.direct_video)\n\t\t\t\t{\n\t\t\t\t\txoff = v_cur.item[4] - FB_DV_LBRD;\n\t\t\t\t\tyoff = v_cur.item[8] - FB_DV_UBRD;\n\t\t\t\t}\n\n\t\t\t\t//printf(\"Switch to Linux frame buffer\\n\");\n\t\t\t\tspi_w((uint16_t)(FB_EN | FB_FMT_RxB | FB_FMT_8888)); // format, enable flag\n\t\t\t\tspi_w((uint16_t)fb_addr); // base address low word\n\t\t\t\tspi_w(fb_addr >> 16);     // base address high word\n\t\t\t\tspi_w(fb_width);          // frame width\n\t\t\t\tspi_w(fb_height);         // frame height\n\t\t\t\tspi_w(xoff);                 // scaled left\n\t\t\t\tspi_w(xoff + v_cur.item[1] - 1); // scaled right\n\t\t\t\tspi_w(yoff);                 // scaled top\n\t\t\t\tspi_w(yoff + v_cur.item[5] - 1); // scaled bottom\n\t\t\t\tspi_w(fb_width * 4);      // stride\n\n\t\t\t\t//printf(\"Linux frame buffer: %dx%d, stride = %d bytes\\n\", fb_width, fb_height, fb_width * 4);\n\t\t\t\tif (!fb_num)\n\t\t\t\t{\n\t\t\t\t\tfb_write_module_params();\n\t\t\t\t\tinput_switch(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinput_switch(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"Switch to core frame buffer\\n\");\n\t\t\t\tspi_w(0); // enable flag\n\t\t\t\tinput_switch(1);\n\t\t\t}\n\n\t\t\tfb_enabled = enable;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Core doesn't support HPS frame buffer\\n\");\n\t\t\tinput_switch(1);\n\t\t}\n\n\t\tDisableIO();\n\t\tif (cfg.direct_video) set_vga_fb(enable);\n\t\tif (is_menu()) user_io_status_set(\"[8:5]\", (fb_enabled && !fb_num) ? 0x160 : 0);\n\t}\n}\n\nint video_fb_state()\n{\n\tif (is_menu())\n\t{\n\t\treturn fb_enabled && !fb_num;\n\t}\n\n\treturn fb_enabled;\n}\n\n\nstatic void video_fb_config()\n{\n\tPROFILE_FUNCTION();\n\n\tint fb_scale = cfg.fb_size;\n\n\tif (fb_scale <= 1)\n\t{\n\t\tif (((v_cur.item[1] * v_cur.item[5]) > FB_SIZE))\n\t\t\tfb_scale = 2;\n\t\telse\n\t\t\tfb_scale = 1;\n\t}\n\telse if (fb_scale == 3) fb_scale = 2;\n\telse if (fb_scale > 4) fb_scale = 4;\n\n\tconst int fb_scale_x = fb_scale;\n\tconst int fb_scale_y = v_cur.param.pr == 0 ? fb_scale : fb_scale * 2;\n\n\tfb_width = v_cur.item[1] / fb_scale_x;\n\tfb_height = v_cur.item[5] / fb_scale_y;\n\n\tbrd_x = cfg.vscale_border / fb_scale_x;\n\tbrd_y = cfg.vscale_border / fb_scale_y;\n\n\tif (fb_enabled) video_fb_enable(1, fb_num);\n\n\tfb_write_module_params();\n}\n\nstatic void draw_checkers()\n{\n\tvolatile uint32_t* buf = fb_base + (FB_SIZE*menu_bgn);\n\n\tuint32_t col1 = 0x888888;\n\tuint32_t col2 = 0x666666;\n\tint sz = fb_width / 128;\n\n\tfor (int y = brd_y; y < fb_height - brd_y; y++)\n\t{\n\t\tint c1 = (y / sz) & 1;\n\t\tint pos = y * fb_width;\n\t\tfor (int x = brd_x; x < fb_width - brd_x; x++)\n\t\t{\n\t\t\tint c2 = c1 ^ ((x / sz) & 1);\n\t\t\tbuf[pos + x] = c2 ? col2 : col1;\n\t\t}\n\t}\n}\n\nstatic void draw_hbars1()\n{\n\tvolatile uint32_t* buf = fb_base + (FB_SIZE*menu_bgn);\n\tint height = fb_height - 2 * brd_y;\n\n\tint old_base = 0;\n\tint gray = 255;\n\tint sz = height / 7;\n\tint stp = 0;\n\n\tfor (int y = brd_y; y < fb_height - brd_y; y++)\n\t{\n\t\tint pos = y * fb_width;\n\t\tint base_color = ((7 * (y-brd_y)) / height) + 1;\n\t\tif (old_base != base_color)\n\t\t{\n\t\t\tstp = sz;\n\t\t\told_base = base_color;\n\t\t}\n\n\t\tgray = 255 * stp / sz;\n\n\t\tfor (int x = brd_x; x < fb_width - brd_x; x++)\n\t\t{\n\t\t\tuint32_t color = 0;\n\t\t\tif (base_color & 4) color |= gray;\n\t\t\tif (base_color & 2) color |= gray << 8;\n\t\t\tif (base_color & 1) color |= gray << 16;\n\t\t\tbuf[pos + x] = color;\n\t\t}\n\n\t\tstp--;\n\t\tif (stp < 0) stp = 0;\n\t}\n}\n\nstatic void draw_hbars2()\n{\n\tvolatile uint32_t* buf = fb_base + (FB_SIZE*menu_bgn);\n\tint height = fb_height - 2 * brd_y;\n\tint width = fb_width - 2 * brd_x;\n\n\tfor (int y = brd_y; y < fb_height - brd_y; y++)\n\t{\n\t\tint pos = y * fb_width;\n\t\tint base_color = ((14 * (y - brd_y)) / height);\n\t\tint inv = base_color & 1;\n\t\tbase_color >>= 1;\n\t\tbase_color = (inv ? base_color : 6 - base_color) + 1;\n\t\tfor (int x = brd_x; x < fb_width - brd_x; x++)\n\t\t{\n\t\t\tint gray = (256 * (x - brd_x)) / width;\n\t\t\tif (inv) gray = 255 - gray;\n\t\t\tuint32_t color = 0;\n\t\t\tif (base_color & 4) color |= gray;\n\t\t\tif (base_color & 2) color |= gray << 8;\n\t\t\tif (base_color & 1) color |= gray << 16;\n\t\t\tbuf[pos + x] = color;\n\t\t}\n\t}\n}\n\nstatic void draw_vbars1()\n{\n\tvolatile uint32_t* buf = fb_base + (FB_SIZE*menu_bgn);\n\tint width = fb_width - 2 * brd_x;\n\n\tint sz = width / 7;\n\tint stp = 0;\n\n\tfor (int y = brd_y; y < fb_height - brd_y; y++)\n\t{\n\t\tint pos = y * fb_width;\n\t\tint old_base = 0;\n\t\tint gray = 255;\n\t\tfor (int x = brd_x; x < fb_width - brd_x; x++)\n\t\t{\n\t\t\tint base_color = ((7 * (x - brd_x)) / width) + 1;\n\t\t\tif (old_base != base_color)\n\t\t\t{\n\t\t\t\tstp = sz;\n\t\t\t\told_base = base_color;\n\t\t\t}\n\n\t\t\tgray = 255 * stp / sz;\n\n\t\t\tuint32_t color = 0;\n\t\t\tif (base_color & 4) color |= gray;\n\t\t\tif (base_color & 2) color |= gray << 8;\n\t\t\tif (base_color & 1) color |= gray << 16;\n\t\t\tbuf[pos + x] = color;\n\n\t\t\tstp--;\n\t\t\tif (stp < 0) stp = 0;\n\t\t}\n\t}\n}\n\nstatic void draw_vbars2()\n{\n\tvolatile uint32_t* buf = fb_base + (FB_SIZE*menu_bgn);\n\tint height = fb_height - 2 * brd_y;\n\tint width = fb_width - 2 * brd_x;\n\n\tfor (int y = brd_y; y < fb_height - brd_y; y++)\n\t{\n\t\tint pos = y * fb_width;\n\t\tfor (int x = brd_x; x < fb_width - brd_x; x++)\n\t\t{\n\t\t\tint gray = ((256 * (y - brd_y)) / height);\n\t\t\tint base_color = ((14 * (x - brd_x)) / width);\n\t\t\tint inv = base_color & 1;\n\t\t\tbase_color >>= 1;\n\t\t\tbase_color = (inv ? base_color : 6 - base_color) + 1;\n\n\t\t\tif (inv) gray = 255 - gray;\n\t\t\tuint32_t color = 0;\n\t\t\tif (base_color & 4) color |= gray;\n\t\t\tif (base_color & 2) color |= gray << 8;\n\t\t\tif (base_color & 1) color |= gray << 16;\n\t\t\tbuf[pos + x] = color;\n\t\t}\n\t}\n}\n\nstatic void draw_spectrum()\n{\n\tvolatile uint32_t* buf = fb_base + (FB_SIZE*menu_bgn);\n\tint height = fb_height - 2 * brd_y;\n\tint width = fb_width - 2 * brd_x;\n\n\tfor (int y = brd_y; y < fb_height - brd_y; y++)\n\t{\n\t\tint pos = y * fb_width;\n\t\tint blue = ((256 * (y - brd_y)) / height);\n\t\tfor (int x = brd_x; x < fb_width - brd_x; x++)\n\t\t{\n\t\t\tint green = ((256 * (x - brd_x)) / width) - blue / 2;\n\t\t\tint red = 255 - green - blue / 2;\n\t\t\tif (red < 0) red = 0;\n\t\t\tif (green < 0) green = 0;\n\n\t\t\tbuf[pos + x] = (red << 16) | (green << 8) | blue;\n\t\t}\n\t}\n}\n\nstatic void draw_black()\n{\n\tvolatile uint32_t* buf = fb_base + (FB_SIZE*menu_bgn);\n\n\tfor (int y = 0; y < fb_height; y++)\n\t{\n\t\tint pos = y * fb_width;\n\t\tfor (int x = 0; x < fb_width; x++) buf[pos++] = 0;\n\t}\n}\n\nstatic uint64_t getus()\n{\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn (tv.tv_sec * 10000000) + tv.tv_usec;\n}\n\nstatic void vs_wait()\n{\n\tint fb = open(\"/dev/fb0\", O_RDWR | O_CLOEXEC);\n\tint zero = 0;\n\tuint64_t t1, t2;\n\tif (ioctl(fb, FBIO_WAITFORVSYNC, &zero) == -1)\n\t{\n\t\tprintf(\"fb ioctl failed: %s\\n\", strerror(errno));\n\t\tclose(fb);\n\t\treturn;\n\t}\n\n\tt1 = getus();\n\tioctl(fb, FBIO_WAITFORVSYNC, &zero);\n\tt2 = getus();\n\tclose(fb);\n\n\tprintf(\"vs_wait(us): %llu\\n\", t2 - t1);\n}\n\nstatic char *get_file_fromdir(const char* dir, int num, int *count)\n{\n\tstatic char name[256+32];\n\tname[0] = 0;\n\tif(count) *count = 0;\n\tDIR *d = opendir(getFullPath(dir));\n\tif (d)\n\t{\n\t\tint cnt = 0;\n\t\tstruct dirent *de = readdir(d);\n\t\twhile (de)\n\t\t{\n\t\t\tint len = strlen(de->d_name);\n\t\t\tif (len > 4 && (de->d_name[0] != '.') && (!strcasecmp(de->d_name + len - 4, \".png\") || !strcasecmp(de->d_name + len - 4, \".jpg\")))\n\t\t\t{\n\t\t\t\tif (num == cnt) break;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tde = readdir(d);\n\t\t}\n\n\t\tif (de)\n\t\t{\n\t\t\tsnprintf(name, sizeof(name), \"%s/%s\", dir, de->d_name);\n\t\t}\n\t\tclosedir(d);\n\t\tif(count) *count = cnt;\n\t}\n\n\treturn name;\n}\n\nstatic Imlib_Image load_bg()\n{\n\tconst char* fname = \"menu.png\";\n\tif (!FileExists(fname))\n\t{\n\t\tfname = \"menu.jpg\";\n\t\tif (!FileExists(fname)) fname = 0;\n\t}\n\n\tif (!fname)\n\t{\n\t\tstatic char bgdir[128];\n\t\tstatic char label[64];\n\t\tint alt = altcfg();\n\n\t\tconst char* cfg_name = cfg_get_name(alt);\n\t\tsnprintf(label, sizeof(label), \"%s\", cfg_name + 6);\n\t\tchar *p = strrchr(label, '.');\n\t\tif (p) *p = 0;\n\n\t\tsprintf(bgdir, \"wallpapers%s\", label);\n\t\tif (alt <= 0 || !cfg_name[0] || !PathIsDir(bgdir)) strcpy(bgdir, \"wallpapers\");\n\n\t\tif (PathIsDir(bgdir))\n\t\t{\n\t\t\tint rndfd = open(\"/dev/urandom\", O_RDONLY | O_CLOEXEC);\n\t\t\tif (rndfd >= 0)\n\t\t\t{\n\t\t\t\tuint32_t rnd;\n\t\t\t\tread(rndfd, &rnd, sizeof(rnd));\n\t\t\t\tclose(rndfd);\n\n\t\t\t\tint count = 0;\n\t\t\t\tget_file_fromdir(bgdir, -1, &count);\n\t\t\t\tif (count > 0) fname = get_file_fromdir(bgdir, rnd % count, &count);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fname)\n\t{\n\t\tImlib_Load_Error error = IMLIB_LOAD_ERROR_NONE;\n\t\tImlib_Image img = imlib_load_image_with_error_return(getFullPath(fname), &error);\n\t\tif (img) return img;\n\t\tprintf(\"Image %s loading error %d\\n\", fname, error);\n\t}\n\n\treturn NULL;\n}\n\nstatic int bg_has_picture = 0;\nextern uint8_t  _binary_logo_png_start[], _binary_logo_png_end[];\nvoid video_menu_bg(int n, int idle)\n{\n\tbg_has_picture = 0;\n\tmenu_bg = n;\n\tif (n)\n\t{\n\t\t//printf(\"**** BG DEBUG START ****\\n\");\n\t\t//printf(\"n = %d\\n\", n);\n\n\t\tImlib_Load_Error error;\n\t\tstatic Imlib_Image logo = 0;\n\t\tif (!logo)\n\t\t{\n\t\t\tunlink(\"/tmp/logo.png\");\n\t\t\tif (FileSave(\"/tmp/logo.png\", _binary_logo_png_start, _binary_logo_png_end - _binary_logo_png_start))\n\t\t\t{\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\terror = IMLIB_LOAD_ERROR_NONE;\n\t\t\t\t\tif ((logo = imlib_load_image_with_error_return(\"/tmp/logo.png\", &error))) break;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (error != IMLIB_LOAD_ERROR_NO_LOADER_FOR_FILE_FORMAT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"logo.png error = %d\\n\", error);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvs_wait();\n\t\t\t\t};\n\n\t\t\t\tif (cfg.osd_rotate)\n\t\t\t\t{\n\t\t\t\t\timlib_context_set_image(logo);\n\t\t\t\t\timlib_image_orientate(cfg.osd_rotate == 1 ? 3 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"Fail to save to /tmp/logo.png\\n\");\n\t\t\t}\n\t\t\tunlink(\"/tmp/logo.png\");\n\t\t\tprintf(\"Logo = %p\\n\", logo);\n\t\t}\n\n\t\tmenu_bgn = (menu_bgn == 1) ? 2 : 1;\n\n\t\tstatic Imlib_Image menubg = 0;\n\t\tstatic Imlib_Image bg1 = 0, bg2 = 0;\n\t\tif (!bg1) bg1 = imlib_create_image_using_data(fb_width, fb_height, (uint32_t*)(fb_base + (FB_SIZE * 1)));\n\t\tif (!bg1) printf(\"Warning: bg1 is 0\\n\");\n\t\tif (!bg2) bg2 = imlib_create_image_using_data(fb_width, fb_height, (uint32_t*)(fb_base + (FB_SIZE * 2)));\n\t\tif (!bg2) printf(\"Warning: bg2 is 0\\n\");\n\n\t\tImlib_Image *bg = (menu_bgn == 1) ? &bg1 : &bg2;\n\t\t//printf(\"*bg = %p\\n\", *bg);\n\n\t\tstatic Imlib_Image curtain = 0;\n\t\tif (!curtain)\n\t\t{\n\t\t\tcurtain = imlib_create_image(fb_width, fb_height);\n\t\t\timlib_context_set_image(curtain);\n\t\t\timlib_image_set_has_alpha(1);\n\n\t\t\tuint32_t *data = imlib_image_get_data();\n\t\t\tint sz = fb_width * fb_height;\n\t\t\tfor (int i = 0; i < sz; i++)\n\t\t\t{\n\t\t\t\t*data++ = 0x9F000000;\n\t\t\t}\n\t\t}\n\n\t\tdraw_black();\n\n\t\tif (idle < 3)\n\t\t{\n\t\t\tswitch (n)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif (!menubg) menubg = load_bg();\n\t\t\t\tif (menubg)\n\t\t\t\t{\n\t\t\t\t\timlib_context_set_image(menubg);\n\t\t\t\t\tint src_w = imlib_image_get_width();\n\t\t\t\t\tint src_h = imlib_image_get_height();\n\t\t\t\t\t//printf(\"menubg: src_w=%d, src_h=%d\\n\", src_w, src_h);\n\n\t\t\t\t\tif (*bg)\n\t\t\t\t\t{\n\t\t\t\t\t\timlib_context_set_image(*bg);\n\t\t\t\t\t\timlib_blend_image_onto_image(menubg, 0,\n\t\t\t\t\t\t\t0, 0,                           //int source_x, int source_y,\n\t\t\t\t\t\t\tsrc_w, src_h,                   //int source_width, int source_height,\n\t\t\t\t\t\t\tbrd_x, brd_y,                   //int destination_x, int destination_y,\n\t\t\t\t\t\t\tfb_width - (brd_x * 2), fb_height - (brd_y * 2) //int destination_width, int destination_height\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbg_has_picture = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"*bg = 0!\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdraw_checkers();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdraw_hbars1();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdraw_hbars2();\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tdraw_vbars1();\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdraw_vbars2();\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdraw_spectrum();\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tdraw_black();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.logo && logo && !idle)\n\t\t{\n\t\t\timlib_context_set_image(logo);\n\n\t\t\tint src_w = imlib_image_get_width();\n\t\t\tint src_h = imlib_image_get_height();\n\n\t\t\tprintf(\"logo: src_w=%d, src_h=%d\\n\", src_w, src_h);\n\n\t\t\tint width = fb_width - (brd_x * 2);\n\t\t\tint height = fb_height - (brd_y * 2);\n\n\t\t\tint dst_w, dst_h;\n\t\t\tint dst_x, dst_y;\n\t\t\tif (cfg.osd_rotate)\n\t\t\t{\n\t\t\t\tdst_h = height / 2;\n\t\t\t\tdst_w = src_w * dst_h / src_h;\n\t\t\t\tif (cfg.osd_rotate == 1)\n\t\t\t\t{\n\t\t\t\t\tdst_x = brd_x;\n\t\t\t\t\tdst_y = height - dst_h;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdst_x = width - dst_w;\n\t\t\t\t\tdst_y = brd_y;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdst_x = brd_x;\n\t\t\t\tdst_y = brd_y;\n\t\t\t\tdst_w = width * 2 / 7;\n\t\t\t\tdst_h = src_h * dst_w / src_w;\n\t\t\t}\n\n\t\t\tif (*bg)\n\t\t\t{\n\t\t\t\tif (cfg.direct_video && (v_cur.item[5] < 300)) dst_h /= 2;\n\n\t\t\t\timlib_context_set_image(*bg);\n\t\t\t\timlib_blend_image_onto_image(logo, 1,\n\t\t\t\t\t0, 0,         //int source_x, int source_y,\n\t\t\t\t\tsrc_w, src_h, //int source_width, int source_height,\n\t\t\t\t\tdst_x, dst_y, //int destination_x, int destination_y,\n\t\t\t\t\tdst_w, dst_h  //int destination_width, int destination_height\n\t\t\t\t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"*bg = 0!\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (curtain)\n\t\t{\n\t\t\tif (idle > 1 && *bg)\n\t\t\t{\n\t\t\t\timlib_context_set_image(*bg);\n\t\t\t\timlib_blend_image_onto_image(curtain, 1,\n\t\t\t\t\t0, 0,                //int source_x, int source_y,\n\t\t\t\t\tfb_width, fb_height, //int source_width, int source_height,\n\t\t\t\t\t0, 0,                //int destination_x, int destination_y,\n\t\t\t\t\tfb_width, fb_height  //int destination_width, int destination_height\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"curtain = 0!\\n\");\n\t\t}\n\n\t\t//test the fb driver\n\t\t//vs_wait();\n\t\t//printf(\"**** BG DEBUG END ****\\n\");\n\t}\n\n\tvideo_fb_enable(0);\n}\n\nint video_bg_has_picture()\n{\n\treturn bg_has_picture;\n}\n\nint video_chvt(int num)\n{\n\tstatic int cur_vt = 0;\n\tif (num)\n\t{\n\t\tcur_vt = num;\n\t\tint fd;\n\t\tif ((fd = open(\"/dev/tty0\", O_RDONLY | O_CLOEXEC)) >= 0)\n\t\t{\n\t\t\tif (ioctl(fd, VT_ACTIVATE, cur_vt)) printf(\"ioctl VT_ACTIVATE fails\\n\");\n\t\t\tif (ioctl(fd, VT_WAITACTIVE, cur_vt)) printf(\"ioctl VT_WAITACTIVE fails\\n\");\n\t\t\tclose(fd);\n\t\t}\n\t}\n\n\treturn cur_vt ? cur_vt : 1;\n}\n\nvoid video_cmd(char *cmd)\n{\n\tif (video_fb_state())\n\t{\n\t\tint accept = 0;\n\t\tint fmt = 0, rb = 0, div = -1, width = -1, height = -1;\n\t\tuint16_t hmin, hmax, vmin, vmax;\n\t\tif (sscanf(cmd, \"fb_cmd0 %d %d %d\", &fmt, &rb, &div) == 3)\n\t\t{\n\t\t\tif (div >= 1 && div <= 4)\n\t\t\t{\n\t\t\t\twidth = v_cur.item[1] / div;\n\t\t\t\theight = v_cur.item[5] / div;\n\t\t\t\thmin = vmin = 0;\n\t\t\t\thmax = v_cur.item[1] - 1;\n\t\t\t\tvmax = v_cur.item[5] - 1;\n\t\t\t\taccept = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (sscanf(cmd, \"fb_cmd2 %d %d %d\", &fmt, &rb, &div) == 3)\n\t\t{\n\t\t\tif (div >= 1 && div <= 4)\n\t\t\t{\n\t\t\t\twidth = v_cur.item[1] / div;\n\t\t\t\theight = v_cur.item[5] / div;\n\t\t\t\thmin = vmin = 0;\n\t\t\t\thmax = v_cur.item[1] - 1;\n\t\t\t\tvmax = v_cur.item[5] - 1;\n\t\t\t\taccept = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (sscanf(cmd, \"fb_cmd1 %d %d %d %d\", &fmt, &rb, &width, &height) == 4)\n\t\t{\n\t\t\tif (width < 120 || width > (int)v_cur.item[1]) width = v_cur.item[1];\n\t\t\tif (height < 120 || height > (int)v_cur.item[5]) height = v_cur.item[5];\n\n\t\t\tint divx = 1;\n\t\t\tint divy = 1;\n\t\t\tif (cfg.direct_video && (v_cur.item[5] < 300))\n\t\t\t{\n\t\t\t\t// TV 240P/288P\n\t\t\t\twhile ((width*(divx + 1)) <= (int)v_cur.item[1]) divx++;\n\t\t\t\twhile ((height*(divy + 1)) <= (int)v_cur.item[5]) divy++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile ((width*(divx + 1)) <= (int)v_cur.item[1] && (height*(divx + 1)) <= (int)v_cur.item[5]) divx++;\n\t\t\t\tdivy = divx;\n\t\t\t}\n\n\t\t\thmin = (uint16_t)((v_cur.item[1] - (width * divx)) / 2);\n\t\t\tvmin = (uint16_t)((v_cur.item[5] - (height * divy)) / 2);\n\t\t\thmax = hmin + (width * divx) - 1;\n\t\t\tvmax = vmin + (height * divy) - 1;\n\t\t\taccept = 1;\n\t\t}\n\n\t\tint bpp = 0;\n\t\tint sc_fmt = 0;\n\n\t\tif (accept)\n\t\t{\n\t\t\tswitch (fmt)\n\t\t\t{\n\t\t\tcase 8888:\n\t\t\t\tbpp = 4;\n\t\t\t\tsc_fmt = FB_FMT_8888;\n\t\t\t\tbreak;\n\n\t\t\tcase 1555:\n\t\t\t\tbpp = 2;\n\t\t\t\tsc_fmt = FB_FMT_1555;\n\t\t\t\tbreak;\n\n\t\t\tcase 565:\n\t\t\t\tbpp = 2;\n\t\t\t\tsc_fmt = FB_FMT_565;\n\t\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\t\tbpp = 1;\n\t\t\t\tsc_fmt = FB_FMT_PAL8;\n\t\t\t\trb = 0;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\taccept = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (rb)\n\t\t{\n\t\t\tsc_fmt |= FB_FMT_RxB;\n\t\t\trb = 1;\n\t\t}\n\n\t\tif(accept)\n\t\t{\n\t\t\tint stride = ((width * bpp) + 15) & ~15;\n\t\t\tprintf(\"fb_cmd: new mode: %dx%d => %dx%d color=%d stride=%d\\n\", width, height, hmax - hmin + 1, vmax - vmin + 1, fmt, stride);\n\n\t\t\tuint32_t addr = FB_ADDR + 4096;\n\n\t\t\tint xoff = 0, yoff = 0;\n\t\t\tif (cfg.direct_video)\n\t\t\t{\n\t\t\t\txoff = v_cur.item[4] - FB_DV_LBRD;\n\t\t\t\tyoff = v_cur.item[8] - FB_DV_UBRD;\n\t\t\t}\n\n\t\t\tspi_uio_cmd_cont(UIO_SET_FBUF);\n\t\t\tspi_w(FB_EN | sc_fmt); // format, enable flag\n\t\t\tspi_w((uint16_t)addr); // base address low word\n\t\t\tspi_w(addr >> 16);     // base address high word\n\t\t\tspi_w(width);          // frame width\n\t\t\tspi_w(height);         // frame height\n\t\t\tspi_w(xoff + hmin);    // scaled left\n\t\t\tspi_w(xoff + hmax);    // scaled right\n\t\t\tspi_w(yoff + vmin);    // scaled top\n\t\t\tspi_w(yoff + vmax);    // scaled bottom\n\t\t\tspi_w(stride);         // stride\n\t\t\tDisableIO();\n\n\t\t\tif (cmd[6] != '2')\n\t\t\t{\n\t\t\t\tstatic char cmd[256];\n\t\t\t\tsprintf(cmd, \"echo %d %d %d %d %d >/sys/module/MiSTer_fb/parameters/mode\", fmt, rb, width, height, stride);\n\t\t\t\tsystem(cmd);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"video_cmd: unknown command or format.\\n\");\n\t\t}\n\t}\n}\n\nstatic constexpr int CELL_GRAN_RND = 4;\n\nstatic int determine_vsync(int w, int h)\n{\n    const int arx[] =   {4, 16, 16, 5, 15};\n    const int ary[] =   {3,  9, 10, 4, 9 };\n\tconst int vsync[] = {4,  5,  6, 7, 7 };\n\n    for (int ar = 0; ar < 5; ar++)\n    {\n        int w_calc = ((h * arx[ar]) / (ary[ar] * CELL_GRAN_RND)) * CELL_GRAN_RND;\n        if (w_calc == w)\n        {\n            return vsync[ar];\n        }\n    }\n\n    return 10;\n}\n\nstatic void video_calculate_cvt_int(int h_pixels, int v_lines, float refresh_rate, bool reduced_blanking, vmode_custom_t *vmode)\n{\n\t// Based on xfree86 cvt.c and https://tomverbeure.github.io/video_timings_calculator\n\n\tconst float CLOCK_STEP = 0.25f;\n\tconst int MIN_V_BPORCH = 6;\n\tconst int V_FRONT_PORCH = 3;\n\n\tconst int h_pixels_rnd = (h_pixels / CELL_GRAN_RND) * CELL_GRAN_RND;\n\tconst int v_sync = determine_vsync(h_pixels_rnd, v_lines);\n\n\tint v_back_porch;\n\tint h_blank, h_sync, h_back_porch, h_front_porch;\n\tint total_pixels;\n\tfloat pixel_freq;\n\n\tif (reduced_blanking)\n\t{\n\t\tconst int RB_V_FPORCH = 3;\n\t\tconst float RB_MIN_V_BLANK = 460.0f;\n\n\t\tfloat h_period_est = ((1000000.0f / refresh_rate) - RB_MIN_V_BLANK) / (float)v_lines;\n\t\th_blank = 160;\n\n\t\tint vbi_lines = (int)(RB_MIN_V_BLANK / h_period_est) + 1;\n\n\t\tint rb_min_vbi = RB_V_FPORCH + v_sync + MIN_V_BPORCH;\n\t\tint act_vbi_lines = (vbi_lines < rb_min_vbi) ? rb_min_vbi : vbi_lines;\n\n\t\tint total_v_lines = act_vbi_lines + v_lines;\n\n\t\ttotal_pixels = h_blank + h_pixels_rnd;\n\n\t\tpixel_freq = CLOCK_STEP * floorf((refresh_rate * (float)(total_v_lines * total_pixels) / 1000000.0f) / CLOCK_STEP);\n\n\t\tv_back_porch = act_vbi_lines - V_FRONT_PORCH - v_sync;\n\n\t\th_sync = 32;\n\t\th_back_porch = 80;\n\t\th_front_porch = h_blank - h_sync - h_back_porch;\n\t}\n\telse\n\t{\n\t\tconst float MIN_VSYNC_BP = 550.0f;\n\t\tconst float C_PRIME = 30.0f;\n\t\tconst float M_PRIME = 300.0f;\n\t\tconst float H_SYNC_PER = 0.08f;\n\n\t\tconst float h_period_est = ((1.0f / refresh_rate) - MIN_VSYNC_BP / 1000000.0f) / (float)(v_lines + V_FRONT_PORCH) * 1000000.0f;\n\n\t\tint v_sync_bp = (int)(MIN_VSYNC_BP / h_period_est) + 1;\n\t\tif (v_sync_bp < (v_sync + MIN_V_BPORCH))\n\t\t{\n\t\t\tv_sync_bp = v_sync + MIN_V_BPORCH;\n\t\t}\n\n\t\tv_back_porch = v_sync_bp - v_sync;\n\n\t\tfloat ideal_duty_cycle = C_PRIME - (M_PRIME * h_period_est / 1000.0f);\n\n\t\tif (ideal_duty_cycle < 20)\n\t\t{\n\t\t\th_blank = (h_pixels_rnd / 4 / (2 * CELL_GRAN_RND)) * (2 * CELL_GRAN_RND);\n\t\t}\n\t\telse\n\t\t{\n\t\t\th_blank = (int)((float)h_pixels_rnd * ideal_duty_cycle / (100.0f - ideal_duty_cycle) / (2 * CELL_GRAN_RND)) * (2 * CELL_GRAN_RND);\n\t\t}\n\n\t\ttotal_pixels = h_pixels_rnd + h_blank;\n\n\t\th_sync = (int)(H_SYNC_PER * (float)total_pixels / CELL_GRAN_RND) * CELL_GRAN_RND;\n\t\th_back_porch = h_blank / 2;\n\t\th_front_porch = h_blank - h_sync - h_back_porch;\n\n\t\tpixel_freq = CLOCK_STEP * floorf((float)total_pixels / h_period_est / CLOCK_STEP);\n\t}\n\n\tvmode->item[0] = 1;\n\tvmode->param.hact = h_pixels_rnd;\n\tvmode->param.hfp = h_front_porch;\n\tvmode->param.hs = h_sync;\n\tvmode->param.hbp = h_back_porch;\n\tvmode->param.vact = v_lines;\n\tvmode->param.vfp = V_FRONT_PORCH - 1;\n\tvmode->param.vs = v_sync;\n\tvmode->param.vbp = v_back_porch + 1;\n\tvmode->param.rb = reduced_blanking ? 1 : 0;\n\tvmode->Fpix = pixel_freq;\n\n\tif (h_pixels_rnd > 2048)\n\t{\n\t\tvmode->param.pr = 1;\n\t\tvmode->param.hact /= 2;\n\t\tvmode->param.hbp /= 2;\n\t\tvmode->param.hfp /= 2;\n\t\tvmode->param.hs /= 2;\n\t\tvmode->Fpix /= 2.0;\n\t}\n\telse\n\t{\n\t\tvmode->param.pr = 0;\n\t}\n\n\n\tprintf(\"Calculated %dx%d@%0.1fhz %s timings: %d,%d,%d,%d,%d,%d,%d,%d,%d,%s%s\\n\",\n\t\th_pixels, v_lines, refresh_rate, reduced_blanking ? \"CVT-RB\" : \"CVT\",\n\t\tvmode->item[1], vmode->item[2], vmode->item[3], vmode->item[4],\n\t\tvmode->item[5], vmode->item[6], vmode->item[7], vmode->item[8],\n\t\t(int)(pixel_freq * 1000.0f),\n\t\treduced_blanking ? \"cvtrb\" : \"cvt\",\n\t\tvmode->param.pr ? \",pr\" : \"\");\n}\n\nstatic void video_calculate_cvt(int h_pixels, int v_lines, float refresh_rate, int reduced_blanking, vmode_custom_t *vmode)\n{\n\t// If the resolution it too wide and the core doesn't support pixel repetition then just do 1080p\n\tif (h_pixels > 2048 && !supports_pr())\n\t{\n\t\tprintf(\"Pixel repetition not supported by core for %dx%d resolution, defaulting 1080p.\\n\", h_pixels, v_lines);\n\t\tvideo_calculate_cvt(1920, 1080, refresh_rate, reduced_blanking, vmode);\n\t\treturn;\n\t}\n\n\tvideo_calculate_cvt_int(h_pixels, v_lines, refresh_rate, reduced_blanking == 1, vmode);\n\tif (vmode->Fpix > 210.f && reduced_blanking == 2)\n\t{\n\t\tprintf(\"Calculated pixel clock is too high. Trying CVT-RB timings.\\n\");\n\t\tvideo_calculate_cvt_int(h_pixels, v_lines, refresh_rate, 1, vmode);\n\t}\n}\n\n\n\nint video_get_rotated()\n{\n  return current_video_info.rotated;\n}\n\n\n"
        },
        {
          "name": "video.h",
          "type": "blob",
          "size": 1.4951171875,
          "content": "#ifndef VIDEO_H\n#define VIDEO_H\n\n#define VFILTER_HORZ 0\n#define VFILTER_VERT 1\n#define VFILTER_SCAN 2\n\nstruct VideoInfo\n{\n    uint32_t width;\n\tuint32_t height;\n\tuint32_t htime;\n\tuint32_t vtime;\n\tuint32_t ptime;\n\tuint32_t ctime;\n\tuint32_t vtimeh;\n\tuint32_t arx;\n\tuint32_t ary;\n\tuint32_t arxy;\n\tuint32_t fb_en;\n\tuint32_t fb_fmt;\n\tuint32_t fb_width;\n\tuint32_t fb_height;\n\tuint32_t pixrep;\n\tuint32_t de_h;\n\tuint32_t de_v;\n\n    bool interlaced;\n    bool rotated;\n};\n\nvoid  video_init();\n\nint   video_get_scaler_flt(int type);\nvoid  video_set_scaler_flt(int type, int n);\nchar* video_get_scaler_coeff(int type, int only_name = 1);\nvoid  video_set_scaler_coeff(int type, const char *name);\n\nint   video_get_gamma_en();\nvoid  video_set_gamma_en(int n);\nchar* video_get_gamma_curve(int only_name = 1);\nvoid  video_set_gamma_curve(const char *name);\n\nint   video_get_shadow_mask_mode();\nvoid  video_set_shadow_mask_mode(int n);\nchar* video_get_shadow_mask(int only_name = 1);\nvoid  video_set_shadow_mask(const char *name);\nvoid  video_loadPreset(char *name, bool save);\n\nint   video_get_rotated();\n\nvoid video_cfg_reset();\n\nvoid  video_mode_adjust();\n\nint   hasAPI1_5();\n\nvoid video_fb_enable(int enable, int n = 0);\nint video_fb_state();\nvoid video_menu_bg(int n, int idle = 0);\nint video_bg_has_picture();\nint video_chvt(int num);\nvoid video_cmd(char *cmd);\n\nvoid video_core_description(char *str, size_t len);\nvoid video_scaler_description(char *str, size_t len);\nchar* video_get_core_mode_name(int with_vrefresh = 1);\n\n#endif // VIDEO_H\n"
        },
        {
          "name": "yc.txt",
          "type": "blob",
          "size": 9.1455078125,
          "content": ";\r\n; PHASE_INC override per <core_fps> mode.\r\n; This eliminates dot crawl on CVBS and also Y/C (S-Video)\r\n;\r\n; NTSC / PAL Section\r\nNES_60.1=91625968981 ;Alternative reduced Dot Crawl from real system:NES_60.1=91626225369\r\nNES_50.0=114532461227\r\nNES_50.5=113487769041 \r\nSNES_60.1=91625968981\r\nSNES_60.0i=91625968981\r\nSNES_50.0=114532461227\r\nSNES_49.9i=114532461227\r\nSMS_59.9=73300775185\r\nSMS_49.7=91625968981\r\nGENESIS_59.9=36650387593\r\nGENESIS_59.8i=36650387593\r\nGENESIS_60.0i=36650387593\r\nGENESIS_49.7=45812984490\r\nGENESIS_49.6i=45812984490\r\nGENESIS_49.8i=45812984490\r\nMEGACD_59.9=36650387593\r\nMEGACD_49.7=45812984490\r\nS32X_59.9=36650387593\r\nS32X_49.7=45812984490\r\nATARI5200_59.9=68719476736\r\nATARI7800_60.0=68719476736\r\nATARI7800_50.4=85115683970\r\nTGFX16_59.8=45812984491\r\nTGFX16_60.1=45812984491\r\nNEOGEO_59.2=81994830080\r\nNEOGEO_50.1=101558653516\r\nNEOGEO_59.6=81425421603\r\nNEOGEO_50.4=100853152548\r\nPSX_59.8=73301061001\r\nPSX_49.7=91626311637\r\nPSX_59.9i=73300775000\r\nPSX_50.0i=91625866829\r\nPSX_59.3=91626480000\r\nPSX_59.4i=91626737000\r\nCOLECOVISION_59.7=92245708315\r\nINTELLIVISION_59.9=91625968981\r\nINTELLIVISION_49.9=101558366540\r\nGAMEBOY_59.7=58647000448\r\nGAMEBOY2P_59.7=58647000448\r\nGBA_59.7=78199914915\r\nGBA2P_59.7=78199914915\r\nWONDERSWAN_59.4=106764120005\r\nODYSSEY2_59.5=91625968978\r\nODYSSEY2_49.7=68719476736\r\nASTROCADE_60.0=68719476736\r\nC64_59.8=60129542165\r\nC64_50.1=77309411302\r\nAPPLE-II_60.2=68719476736\r\nAPPLE-II_59.9=68719476736\r\nATARI800_59.9=68719476736\r\nMSX_59.9=45812984491\r\nMSX1_59.9=91625969068\r\nMSX1_50.2=113487987583\r\nVIC20_60.3=60129542165\r\nVIC20_50.0=68719477111\r\nC16_59.9=68719476736\r\nC16_49.9=85899345254\r\nADAM_49.7=92245708315\r\nPCXT_59.8=68875929271\r\nAMSTRAD_50.1=76169420985\r\nEG2000_50.0=137442831021\r\nATARIST_60.0=40888921898\r\nATARIST_=50644822720\r\nMINIMIG_59.4=34676280039\r\nMINIMIG_49.9=42949793920\r\nTSCONF_48.8=87049782922\r\nZX81_50.6=93746345975\r\nCOCO3_59.7=68719476017\r\nSPMX_50.1=50779613734\r\nQL_60.4=46854362958\r\nQL_50.1=58033843975\r\nSAMCOUPE_50.1=50779614502\r\nCASIO_PV-2000_60.2=91625969068\r\nORIC_49.9=101558939980\r\nONDRA_SPO186_50.1=101559227980\r\nAQUARIUS_59.7=68719476273\r\nSORD M5_50.0=114252956558\r\nLYNX48_49.8=101558653516\r\nLASER_58.6=91625969004\r\nJUPITER_50.1=93746979831\r\nINTERACT_59.9=68719476529\r\nACORNELECTRON_50.1=76169420881\r\nTATUNGEINSTEIN_59.7=92244938627\r\nPET2001_59.6=70281495261\r\nBBCMICRO_50.1=50779613990\r\nAPOGEE_50.0=50779785510\r\nTI-99_60.2=113487861530\r\nSPECTRUM_50.1=87049782922\r\nZXNEXT_50.1=87049782922\r\nA.GALAXN_59.2=81994830148\r\nA.ARKANOID_59.2=81994830148\r\nA.ARKANOID_59.9=80982096300\r\nA.SEGASYS1_60.1=81317297222\r\nA.JOUST2_60.1=81994642597\r\nA.MYSTICMARATHON_60.1=81994642597\r\nA.CENTIPED_59.9=162687536733\r\nTERRA CRESTA_59.4=40997477092\r\nARMED F_59.0=40997477092\r\nA.DKONGJ_60.6=160144797068\r\nA.DKONG_60.6=80079855233\r\nA.DIGDUG_60.8=160160364222\r\nA.PACMAN_60.0=80902786030\r\nA.BERZERK_=98394094109\r\nA.BTIME_57.4=81995189032\r\nCAVE_57.4=140562053354\r\nCAVE_60.0=140562833100\r\nA.COSMIC_60.1=90970254800\r\nA.DFNDR_60.1=81995330760\r\nA.FOODFIGHT_60.8=80072697300\r\nGALAGA_59.2=81994830536\r\nA.MARIO_59.2=81994830024\r\nA. MR DO!_59.9=80322025171\r\nA.POPEYE_59.4=98393944317\r\nQBERT_61.4=98393412541\r\nA.RPATROL_59.2=81994830024\r\nSNK_TRIPLEZ80_61.8=73427991000\r\nSNK_TRIPLEZ80_61.5=73428052000\r\nA.TECMO_59.2=40997415076\r\nA.CANYON_59.9=81338324927\r\nA.DOMINOS_59.9=81338324927\r\nA.FINALIZR_61.1=80072998740\r\nA.FINALIZR_60.0=81513534047\r\nA.GAUNTLET_59.7=68719476736\r\nA.IRONHORSE_61.1=80072998740\r\nA.IRONHORSE_60.0=81513534047\r\nA.JACKAL_61.1=80072998740\r\nA.JACKAL_60.0=81513534047\r\nA.JACKAL_61.8=81995537608\r\nA.MOONPT_55.4=81994819784\r\nA.MOONPT_50.1=101558648832\r\nA.TIMEPLT_60.6=80073076340\r\nA.TIMEPLT_60.0=80869570271\r\nA.TP84_60.6=80073076340\r\nA.TP84_60.0=80869570271\r\nA.TURKEYSHOOT_60.1=81995330888\r\nXEVIOUS_59.2=81994830024\r\nA.ASTROCADE_60.0=68719476736\r\nA.BAGMAN_59.2=81994830148\r\nA.BLOCKADE_60.1=189309997932\r\nA.BMBJCK_59.2=81994830148\r\nA.BREAKOUT_63.4=68720085481\r\nA.BRUBBR_59.9=81995204296\r\nA.COMSPC_60.0=168428997867\r\nA.CRBALLOON_59.1=98521506322\r\nA.CCLIMB_59.2=81994830148\r\nA.CKONG_59.2=81994830148\r\nA.DRUAGA_60.8=80079502017\r\nA.FRENZY_59.6=98393274845\r\nA.GAPLUS_60.8=80072697556\r\nA.GYRUSS_60.0=80869570271\r\nA.GYRUSS_60.6=80073076340\r\nA.IREMM62_55.4=81994657346\r\nA.JAILBREAK_60.6=80073076340\r\nA.JAILBREAK_60.0=80869570271\r\nA.LADYBG_61.2=98394178365\r\nA.MCR1_59.7=49196898139\r\nA.MCR2_59.7=49196898139\r\nA.MCR3_59.7=49196898139\r\nA.MCR3MONO_59.7=49196898139\r\nA.MCR3SCROLL_59.7=49196898139\r\nA.NINJAKUN_59.4=81994953928\r\nA.PENGO_59.2=81994830148\r\nA.PHNX_59.6=89448431462\r\nA.PLEIADS_59.6=89448431462\r\nA.POOYAN_59.4=81994954056\r\nA.NRALLYX_60.8=160145395111\r\nA.ROBTRN_60.1=81994642552\r\nA.RSHNATK_60.6=80079855105\r\nA.SSHOOTER_60.6=80073076340\r\nA.SSHOOTER_60.0=80869570271\r\nA.SCRMBL_60.6=80073076312\r\nA.SILVLAND_59.2=81994830148\r\nA.SOLMNSKEY_60.0=81994721356\r\nA.SPACERACE_60.1=68720053161\r\nA.SPRINT1_59.9=81343768238\r\nA.SPRINT2_59.9=81343768238\r\nA.SUBS_59.9=81343768238\r\nA.SBRKOUT_59.9=81338324927\r\nA.ULTRATNK_59.9=162687536733\r\nA.ZIGZAG_59.2=163989660169\r\nBAKRAID_59.4=41648230652\r\nGAREGGA_59.4=41648230652\r\nBATRIDER_59.4=41648230652\r\nM72_55.2=122992763180\r\nPREHISLE1930_54.1=54662994786\r\nPREHISLE1930_59.2=67706006731\r\nCHAMELEON_57.2=93708649884\r\nA.MISSLE_61.0=196786677370\r\nA.TROPICALANGEL_56.7=80073725512\r\nCONGOBONGO_59.2=81994830280\r\nA.EXERION_61.3=98552954757\r\nBOSCONIAN_59.2=81994829512\r\nA.PERFORMAN_55.9=122992725292\r\nTOAPLAN V1_59.8=56225080500\r\nJTKICKER_60.6=81994830210\r\nJTPINPON_60.6=80073076188\r\nJTROADF_60.6=80073076188\r\nJTROC_60.6=80073076188\r\nJTSBASK_60.6=81994830210\r\nJTSBASKT_60.6=81994830210\r\nJTTRACK_60.6=80073076188\r\nJTYIEAR_60.6=80073076188\r\nJTMIKIE_60.6=80073076188\r\nJTCPS1_59.6=40997539300\r\nJTCPS15_59.6=40997539300\r\nJTCPS2_59.6=40997539300\r\nJTGNG_59.6=81995078596\r\nJT1942_59.6=81995078596\r\nJTBIOCOM_59.6=81995078596\r\nJTBTIGER_59.6=81995078596\r\nJTBUBL_59.2=81994819784\r\nJTCASTLE_59.2=81994830210\r\nJTCOMMND_59.6=81995078596\r\nJTCOMSC_59.2=81994830210\r\nJTCONTRA_59.2=81994830210\r\nJTCOP_57.4=81995189032\r\nJTDD_57.4=81995189032\r\nJTDD2_57.4=81995189032\r\nJTF1DRM_59.6=81995078596\r\nJTEXED_59.6=81995078596\r\nJTFLANE_59.2=81994830210\r\nJTGUNSMK_59.6=81995078596\r\nJTHIGE_59.6=81995078596\r\nJTKARNOV_57.4=81995189032\r\nJTKCHAMP_59.2=81994830210\r\nJTKIWI_59.2=81994819784\r\nJTNINIO_57.4=81995189032\r\nJTLABRUN_59.2=81994830210\r\nJTMIDRES_57.4=81995189032\r\nJTMX5K_59.2=81994830210\r\nJTNINJA_57.4=81995189032\r\nJTOUTRUN_60.1=78171027928\r\nJTPANG_57.4=81995189032\r\nJTRASTAN_59.8=73750556844\r\nJTRUMBLE_57.4=81995189032\r\nJTS16_60.1=78171027928\r\nJTS16B_60.1=78171027928\r\nJTSARMS_61.0=81995846596\r\nJTSECTNZ_55.4=81995291716\r\nJTSF_61.0=81995846596\r\nJTSHANON_60.1=78171027928\r\nJTSLYSPY_57.4=81995189032\r\nJTTORA_59.6=81995078596\r\nJTTROJAN_56.0=81995646588\r\nJTVIGIL_56.3=80073162204\r\nJTVULGUS_59.6=81995078596\r\nMENU_59.8=196786767482\r\nMENU_50.2=243746729900\r\nVECTOR06_50.1=50779326758\r\nCOCO2_58.7=91625969068\r\nRX78_60.1=70281324000\r\nSONSON_55.4=54663528500\r\nSONSON_59.7=54666409000\r\nWONDERSWAN_59.4=106764120005\r\nWONDERSWAN_60.0=106764885650\r\nATARILYNX_59.4=61496033000\r\nATARILYNX_59.2=61496287000\r\nBBCBRIDGECOMPANION_50.0=114255530000\r\nACORNATOM_58.6=91625969000\r\nBK0011M_48.8=101559199308\r\nSVI328_50.0=114255530000\r\nTRS-80_59.9=92436659589\r\nA.DKONG3_59.2=163989661000\r\nJT1943_59.6=81995078596\r\nZAXXON_59.2=81994830148\r\nA.INVADERS_59.6=98394094700\r\nC128_59.8=60129542165\r\nC128_50.1=77309411302\r\nA.CRYSTALCASTLES_61.0=196786679769\r\nBANKPANIC_60.9=109326440000\r\nA.ATETRIS_59.7=68719476738\r\nGALIVAN_59.4=81994953400\r\nEXPRESSRAIDER_59.4=81994953400\r\nCASIO_PV-1000_59.5=54975764270\r\nA.SLAPFIGHT_56.9=81994808000\r\nATHENA_61.5=73428052000\r\nIREMM92_60.0=98393500000\r\nIREMM107_60.0=98393500000\r\nA.BATTLEZONE_59.9=78715034323\r\nAZNABLE_60.1=163978930000\r\nTMNT_59.2=40997415000\r\nA.COSMICG_60.1=90971018000\r\nVBALL_59.6=81995078596\r\nVBALL_60.3=81995390000\r\nMYVISION_60.2=91625969068\r\nA.SEGASYS1+2_60.1=98394396200\r\nJTALIENS_59.2=81994830210\r\nKICKANDRUN_59.2=54663220000\r\nA.TAITO SYSTEM SJ_59.2=81994830148\r\nJTSIMSON_59.2=81993474800\r\nJTTMNT_59.2=81993474800\r\nMEGADRIVE_59.9=36650387593\r\nMEGADRIVE_59.8i=36650387593\r\nMEGADRIVE_60.0i=36650387593\r\nMEGADRIVE_49.7=45812984490\r\nMEGADRIVE_49.6i=45812984490\r\nMEGADRIVE_49.8i=45812984490\r\nSATURN_59.8_6.71=73311341000\r\nSATURN_59.8_7.16=68719476736\r\nSATURN_59.8i_7.16=68719476736\r\nSATURN_59.8i_13.42=73311341000\r\nSATURN_59.8i_14.32=68719476736\r\nSATURN_49.9_6.67=91326550000\r\nSATURN_49.9_7.11=85707419670\r\nSATURN_49.9i_7.11=85707419670\r\nSATURN_49.9i_13.34=91326550000\r\nSATURN_49.9i_14.22=85707419670\r\nA.EXERION_61.4=73799491000\r\nN64_59.8=80849821200\r\nN64_59.9i=80849489000\r\nN64_49.9=98183669100\r\nN64_50.0i=98183552400\r\nJTSHOUSE_60.6=80080535500\r\nPOLY-PLAY_49.8=464268577000\r\nMRJONG_59.4=81994953928\r\nA.PENGUINKUNWARS_60.1=81994642597\r\nA.ATARISYS1_59.7=68719476736\r\nA.VICZ80_59.8=127218872500\r\nJTKUNIO_57.4=81995189032\r\nA.TANKBATTALION_59.2=245984491700\r\nJTFROUND_60.6=80073066196\r\nJTTOKI_59.6=40997430500\r\nFREEZE_59.2=81994830148\r\nXSLEENA_57.4=81995189032\r\nA.INFERNO_60.1=81995330888\r\nGROOVY_59.9=47559786000\r\nGROOVY_60.0_4.91=50149565000\r\nGROOVY_60.0_6.70=48952231800\r\nGROOVY_60.0i_12.34=53174227400\r\nGROOVY_59.9i_12.34=53174227400\r\n;\r\n; PAL-60 / PAL-M Section (CORE_FPSs=PHASEINC for PAL-60, CORE_FPSm=PHASEINC for PAL-M)\r\n;\r\nNES_60.1s=113492149000\r\nSNES_60.1s=113492149000\r\nSNES_60.0is=113492149000\r\nMEGADRIVE_59.9s=45396698000\r\nMEGADRIVE_59.8is=45396714858\r\nMEGADRIVE_60.0is=45396714858\r\nTGFX16_59.8s=56745900000\r\n"
        }
      ]
    }
  ]
}