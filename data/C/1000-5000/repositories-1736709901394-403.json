{
  "metadata": {
    "timestamp": 1736709901394,
    "page": 403,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pipelinedb/pipelinedb",
      "stars": 2638,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 1.677734375,
          "content": "*\t\twhitespace=space-before-tab,trailing-space\n*.[chly]\twhitespace=space-before-tab,trailing-space,indent-with-non-tab,tabwidth=4\n*.dsl\t\twhitespace=space-before-tab,trailing-space,tab-in-indent\n*.patch\t\t-whitespace\n*.pl\t\twhitespace=space-before-tab,trailing-space,tabwidth=4\n*.po\t\twhitespace=space-before-tab,trailing-space,tab-in-indent,-blank-at-eof\n*.sgml\t\twhitespace=space-before-tab,trailing-space,tab-in-indent,-blank-at-eol\n*.x[ms]l\twhitespace=space-before-tab,trailing-space,tab-in-indent\n\n# Avoid confusing ASCII underlines with leftover merge conflict markers\nREADME\t\tconflict-marker-size=32\nREADME.*\tconflict-marker-size=32\n\n# Certain data files that contain special whitespace, and other special cases\n*.data\t\t\t\t\t\t-whitespace\ncontrib/tsearch2/sql/tsearch2.sql\t\twhitespace=space-before-tab,blank-at-eof,-blank-at-eol\ndoc/bug.template\t\t\t\twhitespace=space-before-tab,-blank-at-eof,blank-at-eol\nsrc/backend/catalog/sql_features.txt\t\twhitespace=space-before-tab,blank-at-eof,-blank-at-eol\nsrc/backend/tsearch/hunspell_sample.affix\twhitespace=-blank-at-eof\n\n# Test output files that contain extra whitespace\n*.out\t\t\t\t\t-whitespace\ncontrib/*/output/*.source\t\t-whitespace\nsrc/test/regress/output/*.source\t-whitespace\nsrc/interfaces/ecpg/test/expected/*\t-whitespace\nsrc/interfaces/libpq/test/expected.out\twhitespace=-blank-at-eof\n\n# These files are maintained or generated elsewhere.  We take them as is.\nconfigure\t\t\t\t-whitespace\nppport.h\t\t\t\t-whitespace\nsrc/backend/regex/COPYRIGHT\t\t-whitespace\nsrc/backend/regex/re_syntax.n\t\t-whitespace\nsrc/backend/snowball/libstemmer/*.c\t-whitespace\nsrc/backend/utils/mb/Unicode/*-std.txt\t-whitespace\nsrc/include/snowball/libstemmer/*\t-whitespace\nsrc/timezone/data/*\t\t\t-whitespace\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6357421875,
          "content": "# Global excludes across all subdirectories\n*.o\n*.so\n*.so.[0-9]\n*.so.[0-9].[0-9]\n*.sl\n*.sl.[0-9]\n*.sl.[0-9].[0-9]\n*.dylib\n*.dll\n*.a\n*.mo\n*.pot\n*.pc\nobjfiles.txt\n.deps/\n*.gcno\n*.gcda\n*.gcov\n*.gcov.out\nlcov.info\ncoverage/\n*.vcproj\n*.vcxproj\nwin32ver.rc\n*.exe\nlib*dll.def\nlib*.pc\n*.deb\n*.rpm\n\n# Local excludes in root directory\n/GNUmakefile\n/config.log\n/config.status\n/configure.lineno\n/pgsql.sln\n/pgsql.sln.cache\n/Debug/\n/Release/\n/tmp_install\n/tmp_check\n\nsrc/test/regress/regression.diffs\nsrc/test/regress/regression.out\n\n# Temp Emacs files\n*.*~\n\n# Eclipse project files\n/.cproject\n/.project\n/.pydevproject\n/.settings/\n\n# VSCode project files\n/.vscode\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.697265625,
          "content": "MODULE_big = pipelinedb\nSOURCES = $(shell find src -type f -name '*.c' -not -path 'src/test/*')\nOBJS = $(patsubst %.c,%.o,$(SOURCES))\n\nPG_CONFIG := pg_config\n\nEXTENSION = pipelinedb\nREGRESS = $(EXTENSION)\n\nDATA = $(shell find . -type f -name 'pipelinedb--*.sql')\nEXTRA_CLEAN = src/test/regress/expected/$(REGRESS).out src/test/regress/sql/$(REGRESS).sql\nSHLIB_LINK += /usr/lib/libzmq.a -lstdc++\n\nifdef USE_PGXS\nPG_CPPFLAGS += -I./include -I$(shell $(PG_CONFIG) --includedir)\n\nifdef PIPELINE_VERSION_STR\nPG_CPPFLAGS += -DPIPELINE_VERSION_STR=\\\"$(PIPELINE_VERSION_STR)\\\"\nendif\nifdef PIPELINE_REVISION_STR\nPG_CPPFLAGS += -DPIPELINE_REVISION_STR=\\\"$(PIPELINE_REVISION_STR)\\\"\nendif\n\nPGXS := $(shell $(PG_CONFIG) --pgxs)\ninclude $(PGXS)\nelse\n\n$(shell touch src/test/regress/sql/$(REGRESS).sql)\n$(shell touch src/test/regress/expected/$(REGRESS).out)\n\nbindir = $(shell $(PG_CONFIG) --bindir)\nREGRESS_OPTS = --schedule=./src/test/regress/parallel_schedule \\\n  --host=localhost \\\n  --inputdir=./src/test/regress \\\n  --outputdir=./src/test/regress \\\n  --load-extension=pipelinedb \\\n  --temp-config=./src/test/regress/pipelinedb.conf \\\n  --bindir=$(bindir)\n\nNO_GENERATED_HEADERS = 1\nNO_PGXS = 1\nNO_TEMP_INSTALL = 1\ntop_builddir = $(shell $(PG_CONFIG) --pkglibdir)/pgxs\n\ninclude $(shell $(PG_CONFIG) --pkglibdir)/pgxs/src/Makefile.global\ninclude $(shell $(PG_CONFIG) --pgxs)\n\nendif\n\nbin_dir = ./bin\n\nheaders_dir = $(shell $(PG_CONFIG) --includedir-server)/../pipelinedb\n\n# Headers for other extensions to build against\ninstall-headers:\n\t$(MKDIR_P) $(headers_dir)\n\t$(INSTALL_DATA) $(CURDIR)/include/*.h '$(headers_dir)'\n\ninstall: install-headers\n\nbootstrap:\n\t$(bin_dir)/bootstrap\n\nrun:\n\t$(bin_dir)/run-dev\n\ntest:\n\tmake check\n\tmake -C src/test/py test\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.740234375,
          "content": "Copyright 2018, PipelineDB, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\t http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nThis distribution has a static binary dependency on the ZeroMQ library,\nwhich is available under the GNU Lesser General Public License (version 3)\nwith a static linking exception (http://zeromq.org/).\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.1708984375,
          "content": "PipelineDB [has joined Confluent](https://www.confluent.io/blog/pipelinedb-team-joins-confluent), read the blog post [here](https://www.pipelinedb.com/blog/pipelinedb-is-joining-confluent).\r\n\r\nPipelineDB will not have new releases beyond `1.0.0`, although critical bugs will still be fixed.\r\n\r\n# PipelineDB\r\n\r\n[![Gitter chat](https://img.shields.io/badge/gitter-join%20chat-brightgreen.svg?style=flat-square)](https://gitter.im/pipelinedb/pipelinedb)\r\n[![Twitter](https://img.shields.io/badge/twitter-@pipelinedb-55acee.svg?style=flat-square)](https://twitter.com/pipelinedb)\r\n\r\n## Overview\r\n\r\nPipelineDB is a PostgreSQL extension for high-performance time-series aggregation, designed to power realtime reporting and analytics applications.\r\n\r\nPipelineDB allows you to define [continuous SQL queries](http://docs.pipelinedb.com/continuous-views.html) that perpetually aggregate time-series data and store **only the aggregate output** in regular, queryable tables. You can think of this concept as extremely high-throughput, incrementally updated materialized views that never need to be manually refreshed.\r\n\r\nRaw time-series data is never written to disk, making PipelineDB extremely efficient for aggregation workloads.\r\n\r\nContinuous queries produce their own [output streams](http://docs.pipelinedb.com/streams.html#output-streams), and thus can be [chained together](http://docs.pipelinedb.com/continuous-transforms.html) into arbitrary networks of continuous SQL.\r\n\r\n## PostgreSQL compatibility\r\n\r\nPipelineDB runs on 64-bit architectures and currently supports the following PostgreSQL versions:\r\n\r\n* **PostgreSQL 10**: 10.1, 10.2, 10.3, 10.4, 10.5\r\n* **PostgreSQL 11**: 11.0\r\n\r\n## Getting started\r\n\r\nIf you just want to start using PipelineDB right away, head over to the [installation docs](http://docs.pipelinedb.com/installation.html) to get going.\r\n\r\nIf you'd like to build PipelineDB from source, keep reading!\r\n\r\n## Building from source\r\n\r\nSince PipelineDB is a PostgreSQL extension, you'll need to have the [PostgreSQL development packages](https://www.postgresql.org/download/) installed to build PipelineDB.\r\n\r\nNext you'll have to install [ZeroMQ](http://zeromq.org/) which PipelineDB uses for inter-process communication. [Here's](https://gist.github.com/derekjn/14f95b7ceb8029cd95f5488fb04c500a) a gist with instructions to build and install ZeroMQ from source.\r\nYou'll also need to install some Python dependencies if you'd like to run PipelineDB's Python test suite:\r\n\r\n```\r\npip install -r src/test/py/requirements.txt\r\n```\r\n\r\n#### Build PipelineDB:\r\n\r\nOnce PostgreSQL is installed, you can build PipelineDB against it:\r\n\r\n```\r\nmake USE_PGXS=1\r\nmake install\r\n```\r\n\r\n#### Test PipelineDB *(optional)*\r\nRun the following command:\r\n\r\n```\r\nmake test\r\n```\r\n\r\n#### Bootstrap the PipelineDB environment\r\nCreate PipelineDB's physical data directories, configuration files, etc:\r\n\r\n```\r\nmake bootstrap\r\n```\r\n\r\n**`make bootstrap` only needs to be run the first time you install PipelineDB**. The resources that `make bootstrap` creates may continue to be used as you change and rebuild PipeineDB.\r\n\r\n\r\n#### Run PipelineDB\r\nRun all of the daemons necessary for PipelineDB to operate:\r\n\r\n```\r\nmake run\r\n```\r\n\r\nEnter `Ctrl+C` to shut down PipelineDB.\r\n\r\n`make run` uses the binaries in the PipelineDB source root compiled by `make`, so you don't need to `make install` before running `make run` after code changes--only `make` needs to be run.\r\n\r\nThe basic development flow is:\r\n\r\n```\r\nmake\r\nmake run\r\n^C\r\n\r\n# Make some code changes...\r\nmake\r\nmake run\r\n```\r\n\r\n#### Send PipelineDB some data\r\n\r\nNow let's generate some test data and stream it into a simple continuous view. First, create the stream and the continuous view that reads from it:\r\n\r\n    $ psql\r\n    =# CREATE FOREIGN TABLE test_stream (key integer, value integer) SERVER pipelinedb;\r\n    CREATE FOREIGN TABLE\r\n    =# CREATE VIEW test_view WITH (action=materialize) AS SELECT key, COUNT(*) FROM test_stream GROUP BY key;\r\n    CREATE VIEW\r\n\r\nEvents can be emitted to PipelineDB streams using regular SQL `INSERTS`. Any `INSERT` target that isn't a table is considered a stream by PipelineDB, meaning streams don't need to have a schema created in advance. Let's emit a single event into the `test_stream` stream since our continuous view is reading from it:\r\n\r\n    $ psql\r\n    =# INSERT INTO test_stream (key, value) VALUES (0, 42);\r\n    INSERT 0 1\r\n\r\nThe 1 in the `INSERT 0 1` response means that 1 event was emitted into a stream that is actually being read by a continuous query. Now let's insert some random data:\r\n\r\n    =# INSERT INTO test_stream (key, value) SELECT random() * 10, random() * 10 FROM generate_series(1, 100000);\r\n    INSERT 0 100000\r\n\r\nQuery the continuous view to verify that the continuous view was properly updated. Were there actually 100,001 events counted?\r\n\r\n    $ psql -c \"SELECT sum(count) FROM test_view\"\r\n      sum\r\n    -------\r\n    100001\r\n    (1 row)\r\n\r\nWhat were the 10 most common randomly generated keys?\r\n\r\n    $ psql -c \"SELECT * FROM test_view ORDER BY count DESC limit 10\"\r\n\tkey  | count \r\n\t-----+-------\r\n\t 2   | 10124\r\n\t 8   | 10100\r\n\t 1   | 10042\r\n\t 7   |  9996\r\n\t 4   |  9991\r\n\t 5   |  9977\r\n\t 3   |  9963\r\n\t 6   |  9927\r\n\t 9   |  9915\r\n\t10   |  4997\r\n\t 0   |  4969\r\n\r\n\t(11 rows)\r\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "pipelinedb--1.0.0--1.1.0.sql",
          "type": "blob",
          "size": 0.1025390625,
          "content": "\n-- OIDs are finicky and PG is moving away from them\nALTER TABLE pipelinedb.cont_query SET WITHOUT OIDS;\n"
        },
        {
          "name": "pipelinedb--1.0.0.sql",
          "type": "blob",
          "size": 76.6845703125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION pipelinedb\" to load this file. \\quit\n\nCREATE SCHEMA pipelinedb;\n\nCREATE TABLE pipelinedb._exec_lock ();\n\nCREATE FUNCTION stream_fdw_handler()\nRETURNS fdw_handler\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;\n\nCREATE FOREIGN DATA WRAPPER stream_fdw HANDLER stream_fdw_handler;\nCREATE SERVER pipelinedb FOREIGN DATA WRAPPER stream_fdw;\n\nCREATE TABLE pipelinedb.cont_query (\n  id int4 NOT NULL,\n  type \"char\",\n  relid oid NOT NULL,\n  defrelid oid NOT NULL,\n  active bool,\n  osrelid oid,\n  streamrelid oid,\n\n  -- Valid for views only\n  matrelid oid NOT NULL,\n  seqrelid oid,\n  pkidxid oid,\n  lookupidxid oid,\n  step_factor int2,\n  ttl int4,\n  ttl_attno int2,\n\n  -- Valid for transforms only\n  tgnargs int2,\n  tgargs bytea\n) WITH OIDS;\n\nCREATE UNIQUE INDEX pipeline_cont_query_relid_index ON pipelinedb.cont_query (relid);\nCREATE UNIQUE INDEX pipeline_cont_query_defrelid_index ON pipelinedb.cont_query (defrelid);\nCREATE UNIQUE INDEX pipeline_cont_query_id_index ON pipelinedb.cont_query (id);\nCREATE UNIQUE INDEX pipeline_cont_query_oid_index ON pipelinedb.cont_query (oid);\nCREATE UNIQUE INDEX pipeline_cont_query_matrelid_index ON pipelinedb.cont_query (matrelid);\nCREATE UNIQUE INDEX pipeline_cont_query_osrelid_index ON pipelinedb.cont_query (osrelid);\n\n-- These aren't UNIQUE because they can be 0 for transforms\nCREATE INDEX pipeline_cont_query_seqrelid_index ON pipelinedb.cont_query (seqrelid);\nCREATE INDEX pipeline_cont_query_pkidxid_index ON pipelinedb.cont_query (pkidxid);\nCREATE INDEX pipeline_cont_query_lookupidxid_index ON pipelinedb.cont_query (lookupidxid);\n\nCREATE TABLE pipelinedb.stream (\n  relid oid NOT NULL,\n  queries bytea\n) WITH OIDS;\n\nCREATE UNIQUE INDEX pipeline_stream_relid_index ON pipelinedb.stream (relid);\nCREATE UNIQUE INDEX pipeline_stream_oid_index ON pipelinedb.stream (oid);\n\nCREATE TABLE pipelinedb.combine (\n  aggfn oid,\n  combineaggfn oid\n);\n\nCREATE UNIQUE INDEX pipeline_combine_aggfn_index ON pipelinedb.combine (aggfn);\n\nCREATE OR REPLACE FUNCTION pipelinedb.get_streams(OUT schema text, OUT name text, OUT queries text[])\nRETURNS SETOF record\nAS 'MODULE_PATHNAME', 'pipeline_get_streams'\nLANGUAGE C IMMUTABLE;\n\nCREATE OR REPLACE FUNCTION pipelinedb.get_views(\n  OUT id oid, OUT schema text, OUT name text, OUT active bool, OUT query text)\nRETURNS SETOF record\nAS 'MODULE_PATHNAME', 'pipeline_get_views'\nLANGUAGE C IMMUTABLE;\n\nCREATE VIEW pipelinedb.views AS\n SELECT * FROM pipelinedb.get_views();\n\nCREATE OR REPLACE FUNCTION pipelinedb.get_transforms(\n  OUT id oid, OUT schema text, OUT name text, OUT active bool, OUT tgfunc text, OUT tgargs text[], OUT query text)\nRETURNS SETOF record\nAS 'MODULE_PATHNAME', 'pipeline_get_transforms'\nLANGUAGE C IMMUTABLE;\n\nCREATE VIEW pipelinedb.transforms AS\n SELECT * FROM pipelinedb.get_transforms();\n\n\nCREATE OR REPLACE FUNCTION pipelinedb.hash_group(VARIADIC \"any\")\nRETURNS integer\nAS 'MODULE_PATHNAME', 'hash_group'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE OR REPLACE FUNCTION pipelinedb.ls_hash_group(VARIADIC \"any\")\nRETURNS bigint\nAS 'MODULE_PATHNAME', 'ls_hash_group'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE OR REPLACE FUNCTION pipelinedb.insert_into_stream()\nRETURNS trigger\nAS 'MODULE_PATHNAME', 'insert_into_stream'\nLANGUAGE C IMMUTABLE;\n\nCREATE OR REPLACE FUNCTION date_round(timestamp with time zone, interval)\nRETURNS timestamp with time zone\nAS 'MODULE_PATHNAME', 'timestamptz_round'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combine_trans_dummy(anyelement, anyelement)\nRETURNS anyelement\nAS 'MODULE_PATHNAME', 'combine_trans_dummy'\nLANGUAGE C IMMUTABLE;\n\n/*\n * Dummy combine aggregate for user combines\n *\n * User combines will always take a finalized aggregate value as input\n * and return a combined aggregate of the same type, so this dummy aggregate\n * ensures we make it through the analyzer with correct types everywhere.\n */\nCREATE AGGREGATE combine(anyelement) (\n  sfunc = combine_trans_dummy,\n  stype = anyelement,\n  initcond = 'combine_dummy',\n  parallel = safe\n);\n\n/*\n * Dummy combine aggregate used in SW overlay queries\n *\n * It's convenient to differentiate between these and user combines in the planner,\n * so we indicate SW overlay combines using this aggregate\n */\nCREATE AGGREGATE sw_combine(anyelement) (\n  sfunc = combine_trans_dummy,\n  stype = anyelement,\n  initcond = 'sw_combine_dummy',\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_numeric_avg(internal) (\n  sfunc = numeric_avg_combine,\n  stype = internal,\n  finalfunc = numeric_avg,\n  combinefunc = numeric_avg_combine,\n  serialfunc = numeric_avg_serialize,\n  deserialfunc = numeric_avg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_avg(internal) (\n  sfunc = numeric_avg_combine,\n  stype = internal,\n  finalfunc = numeric_avg_serialize,\n  combinefunc = numeric_avg_combine,\n  serialfunc = numeric_avg_serialize,\n  deserialfunc = numeric_avg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_int8_avg(internal) (\n  sfunc = int8_avg_combine,\n  stype = internal,\n  finalfunc = numeric_poly_avg,\n  combinefunc = int8_avg_combine,\n  serialfunc = int8_avg_serialize,\n  deserialfunc = int8_avg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_int8_avg(internal) (\n  sfunc = int8_avg_combine,\n  stype = internal,\n  finalfunc = int8_avg_serialize,\n  combinefunc = int8_avg_combine,\n  serialfunc = int8_avg_serialize,\n  deserialfunc = int8_avg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_int4_avg(bigint[]) (\n  sfunc = int4_avg_combine,\n  stype = bigint[],\n  finalfunc = int8_avg,\n  combinefunc = int4_avg_combine,\n  parallel = safe\n);\nCREATE AGGREGATE partial_combine_int4_avg(bigint[]) (\n  sfunc = int4_avg_combine,\n  stype = bigint[],\n  combinefunc = int4_avg_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_float8_avg(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  finalfunc = float8_avg,\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_float8_avg(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_interval_avg(interval[]) (\n  sfunc = interval_combine,\n  stype = interval[],\n  finalfunc = interval_avg,\n  combinefunc = interval_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_interval_avg(interval[]) (\n  sfunc = interval_combine,\n  stype = interval[],\n  combinefunc = interval_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_int8_sum(internal) (\n  sfunc = int8_avg_combine,\n  stype = internal,\n  finalfunc = numeric_poly_sum,\n  combinefunc = int8_avg_combine,\n  deserialfunc = int8_avg_deserialize,\n  serialfunc = int8_avg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_int8_sum(internal) (\n  sfunc = int8_avg_combine,\n  stype = internal,\n  finalfunc = int8_avg_serialize,\n  combinefunc = int8_avg_combine,\n  deserialfunc = int8_avg_deserialize,\n  serialfunc = int8_avg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_numeric_sum(internal) (\n  sfunc = numeric_avg_combine,\n  stype = internal,\n  finalfunc = numeric_sum,\n  combinefunc = numeric_avg_combine,\n  deserialfunc = numeric_avg_deserialize,\n  serialfunc = numeric_avg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_sum(internal) (\n  sfunc = numeric_avg_combine,\n  stype = internal,\n  finalfunc = numeric_avg_serialize,\n  combinefunc = numeric_avg_combine,\n  deserialfunc = numeric_avg_deserialize,\n  serialfunc = numeric_avg_serialize,\n  parallel = safe\n);\n\n-- corr\nCREATE AGGREGATE combine_corr(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_corr,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_corr(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- covar_pop\nCREATE AGGREGATE combine_covar_pop(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_covar_pop,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_covar_pop(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- covar_samp\nCREATE AGGREGATE combine_covar_samp(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_covar_samp,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_covar_samp(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_avgx\nCREATE AGGREGATE combine_regr_avgx(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_avgx,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_avgx(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_avgy\nCREATE AGGREGATE combine_regr_avgy(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_avgy,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_avgy(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_count\nCREATE AGGREGATE combine_regr_count(int8) (\n  sfunc = int8pl,\n  stype = int8,\n  combinefunc = int8pl,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_count(int8) (\n  sfunc = int8pl,\n  stype = int8,\n  combinefunc = int8pl,\n  parallel = safe\n);\n\n-- regr_intercept\nCREATE AGGREGATE combine_regr_intercept(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_intercept,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_intercept(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_r2\nCREATE AGGREGATE combine_regr_r2(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_r2,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_r2(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_slope\nCREATE AGGREGATE combine_regr_slope(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_slope,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_slope(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_sxx\nCREATE AGGREGATE combine_regr_sxx(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_sxx,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_sxx(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_sxy\nCREATE AGGREGATE combine_regr_sxy(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_sxy,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_sxy(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- regr_syy\nCREATE AGGREGATE combine_regr_syy(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  finalfunc = float8_regr_syy,\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_regr_syy(float8[]) (\n  sfunc = float8_regr_combine,\n  stype = float8[],\n  combinefunc = float8_regr_combine,\n  parallel = safe\n);\n\n-- stddev (float8_combine -> _float8)\nCREATE AGGREGATE combine_float8_stddev(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  finalfunc = float8_stddev_samp,\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_float8_stddev(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\n-- stddev (numeric_poly_combine -> internal)\nCREATE AGGREGATE combine_numeric_poly_stddev(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_stddev_samp,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_poly_stddev(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_serialize,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\n-- stddev (numeric_combine -> internal)\nCREATE AGGREGATE combine_numeric_stddev(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_stddev_samp,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_stddev(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_serialize,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\n-- stddev_pop (float8_combine -> _float8)\nCREATE AGGREGATE combine_float8_stddev_pop(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  finalfunc = float8_stddev_pop,\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_float8_stddev_pop(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\n-- stddev_pop (numeric_poly_combine -> internal)\nCREATE AGGREGATE combine_numeric_poly_stddev_pop(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_stddev_pop,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_poly_stddev_pop(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_serialize,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\n-- stddev_pop  (numeric_combine -> internal)\nCREATE AGGREGATE combine_numeric_stddev_pop(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_stddev_pop,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_stddev_pop(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_serialize,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\n-- var_pop (float8_combine -> _float8)\nCREATE AGGREGATE combine_float8_var_pop(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  finalfunc = float8_var_pop,\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_float8_var_pop(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\n-- var_pop (numeric_poly_combine -> internal)\nCREATE AGGREGATE combine_numeric_poly_var_pop(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_var_pop,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_poly_var_pop(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_serialize,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\n-- var_pop (numeric_combine -> internal)\nCREATE AGGREGATE combine_numeric_var_pop(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_var_pop,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_var_pop(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_serialize,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\n-- var_samp (float8_combine -> _float8)\nCREATE AGGREGATE combine_float8_var_samp(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  finalfunc = float8_var_samp,\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_float8_var_samp(float8[]) (\n  sfunc = float8_combine,\n  stype = float8[],\n  combinefunc = float8_combine,\n  parallel = safe\n);\n\n-- var_samp (numeric_poly_combine -> internal)\nCREATE AGGREGATE combine_numeric_poly_var_samp(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_var_samp,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_poly_var_samp(internal) (\n  sfunc = numeric_poly_combine,\n  stype = internal,\n  finalfunc = numeric_poly_serialize,\n  combinefunc = numeric_poly_combine,\n  serialfunc = numeric_poly_serialize,\n  deserialfunc = numeric_poly_deserialize,\n  parallel = safe\n);\n\n-- var_samp (numeric_combine -> internal)\nCREATE AGGREGATE combine_numeric_var_samp(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_var_samp,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_numeric_var_samp(internal) (\n  sfunc = numeric_combine,\n  stype = internal,\n  finalfunc = numeric_serialize,\n  combinefunc = numeric_combine,\n  serialfunc = numeric_serialize,\n  deserialfunc = numeric_deserialize,\n  parallel = safe\n);\n\n-- combinable_json_agg_transfn\nCREATE FUNCTION combinable_json_agg_transfn(internal, anyelement)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'combinable_json_agg_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- combinable_json_agg_finalfn\nCREATE FUNCTION combinable_json_agg_finalfn(internal)\nRETURNS json\nAS 'MODULE_PATHNAME', 'combinable_json_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- json_agg_serialize\nCREATE FUNCTION json_agg_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'json_agg_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- json_agg_deserialize\nCREATE FUNCTION json_agg_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'json_agg_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- json_agg_combine\nCREATE FUNCTION json_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'json_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- Cobineable json_object_agg aggregate\nCREATE AGGREGATE combinable_json_agg(anyelement) (\n  sfunc = combinable_json_agg_transfn,\n  stype = internal,\n  finalfunc = combinable_json_agg_finalfn,\n  combinefunc = json_agg_combine,\n  deserialfunc = json_agg_deserialize,\n  serialfunc = json_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_json_agg(internal) (\n  sfunc = json_agg_combine,\n  stype = internal,\n  finalfunc = combinable_json_agg_finalfn,\n  combinefunc = json_agg_combine,\n  deserialfunc = json_agg_deserialize,\n  serialfunc = json_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_json_agg(internal) (\n  sfunc = json_agg_combine,\n  stype = internal,\n  finalfunc = json_agg_serialize,\n  combinefunc = json_agg_combine,\n  deserialfunc = json_agg_deserialize,\n  serialfunc = json_agg_serialize,\n  parallel = safe\n);\n\n-- json_object_agg support functions\nCREATE FUNCTION combinable_json_object_agg_transfn(internal, \"any\", \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'combinable_json_object_agg_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_json_object_agg_finalfn(internal)\nRETURNS json\nAS 'MODULE_PATHNAME', 'combinable_json_object_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION json_object_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'json_object_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- combinable json_object_agg aggregate\nCREATE AGGREGATE combinable_json_object_agg(\"any\", \"any\") (\n  sfunc = combinable_json_object_agg_transfn,\n  stype = internal,\n  finalfunc = combinable_json_object_agg_finalfn,\n  combinefunc = json_object_agg_combine,\n  deserialfunc = json_agg_deserialize,\n  serialfunc = json_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_json_object_agg(internal) (\n  sfunc = json_object_agg_combine,\n  stype = internal,\n  finalfunc = combinable_json_object_agg_finalfn,\n  combinefunc = json_object_agg_combine,\n  deserialfunc = json_agg_deserialize,\n  serialfunc = json_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_json_object_agg(internal) (\n  sfunc = json_object_agg_combine,\n  stype = internal,\n  finalfunc = json_agg_serialize,\n  combinefunc = json_object_agg_combine,\n  deserialfunc = json_agg_deserialize,\n  serialfunc = json_agg_serialize,\n  parallel = safe\n);\n\n-- jsonb_agg support functions\n-- combinable_jsonb_agg_transfn\nCREATE FUNCTION combinable_jsonb_agg_transfn(internal, anyelement)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'combinable_jsonb_agg_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- combinable_jsonb_agg_finalfn\nCREATE FUNCTION combinable_jsonb_agg_finalfn(internal)\nRETURNS jsonb\nAS 'MODULE_PATHNAME', 'combinable_jsonb_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- jsonb_agg_serialize\nCREATE FUNCTION jsonb_agg_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'jsonb_agg_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- jsonb_agg_deserialize\nCREATE FUNCTION jsonb_agg_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'jsonb_agg_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- jsonb_agg_combine\nCREATE FUNCTION jsonb_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'jsonb_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- Cobineable json_object_agg aggregate\nCREATE AGGREGATE combinable_jsonb_agg(anyelement) (\n  sfunc = combinable_jsonb_agg_transfn,\n  stype = internal,\n  finalfunc = combinable_jsonb_agg_finalfn,\n  combinefunc = jsonb_agg_combine,\n  deserialfunc = jsonb_agg_deserialize,\n  serialfunc = jsonb_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_jsonb_agg(internal) (\n  sfunc = jsonb_agg_combine,\n  stype = internal,\n  finalfunc = combinable_jsonb_agg_finalfn,\n  combinefunc = jsonb_agg_combine,\n  deserialfunc = jsonb_agg_deserialize,\n  serialfunc = jsonb_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_jsonb_agg(internal) (\n  sfunc = jsonb_agg_combine,\n  stype = internal,\n  finalfunc = jsonb_agg_serialize,\n  combinefunc = jsonb_agg_combine,\n  deserialfunc = jsonb_agg_deserialize,\n  serialfunc = jsonb_agg_serialize,\n  parallel = safe\n);\n\n-- jsonb_object_agg support functions\nCREATE FUNCTION combinable_jsonb_object_agg_transfn(internal, \"any\", \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'combinable_jsonb_object_agg_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_jsonb_object_agg_finalfn(internal)\nRETURNS jsonb\nAS 'MODULE_PATHNAME', 'combinable_jsonb_object_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION jsonb_object_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'jsonb_object_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- combinable json_object_agg aggregate\nCREATE AGGREGATE combinable_jsonb_object_agg(\"any\", \"any\") (\n  sfunc = combinable_jsonb_object_agg_transfn,\n  stype = internal,\n  finalfunc = combinable_jsonb_object_agg_finalfn,\n  combinefunc = jsonb_object_agg_combine,\n  deserialfunc = jsonb_agg_deserialize,\n  serialfunc = jsonb_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_jsonb_object_agg(internal) (\n  sfunc = jsonb_object_agg_combine,\n  stype = internal,\n  finalfunc = combinable_jsonb_object_agg_finalfn,\n  combinefunc = jsonb_object_agg_combine,\n  deserialfunc = jsonb_agg_deserialize,\n  serialfunc = jsonb_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_jsonb_object_agg(internal) (\n  sfunc = jsonb_object_agg_combine,\n  stype = internal,\n  finalfunc = jsonb_agg_serialize,\n  combinefunc = jsonb_object_agg_combine,\n  deserialfunc = jsonb_agg_deserialize,\n  serialfunc = jsonb_agg_serialize,\n  parallel = safe\n);\n\n-- combinable array_agg\nCREATE FUNCTION array_agg_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'array_agg_serialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION array_agg_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'array_agg_deserialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION array_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'array_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_array_agg_finalfn(internal, anynonarray)\nRETURNS anyarray\nAS 'MODULE_PATHNAME', 'combinable_array_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_array_agg(anynonarray) (\n  sfunc = array_agg_transfn,\n  stype = internal,\n  finalfunc = combinable_array_agg_finalfn,\n  finalfunc_extra,\n  combinefunc = array_agg_combine,\n  deserialfunc = array_agg_deserialize,\n  serialfunc = array_agg_serialize,\n  parallel = safe\n);\n\n-- combinable array_agg_array\nCREATE FUNCTION array_agg_array_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'array_agg_array_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION array_agg_array_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'array_agg_array_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION array_agg_array_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'array_agg_array_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_array_agg_array_finalfn(internal, anyarray)\nRETURNS anyarray\nAS 'MODULE_PATHNAME', 'combinable_array_agg_array_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_array_agg(anyarray) (\n  sfunc = array_agg_array_transfn,\n  stype = internal,\n  finalfunc = combinable_array_agg_array_finalfn,\n  finalfunc_extra,\n  combinefunc = array_agg_array_combine,\n  deserialfunc = array_agg_array_deserialize,\n  serialfunc = array_agg_array_serialize,\n  parallel = safe\n);\n\n-- set_agg supporting functions\nCREATE FUNCTION set_agg_trans(internal, anynonarray)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'set_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION set_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'set_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION set_cardinality(internal, anynonarray)\nRETURNS integer\nAS 'MODULE_PATHNAME', 'set_cardinality'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- set_agg aggregate\nCREATE AGGREGATE set_agg(anynonarray) (\n  sfunc = set_agg_trans,\n  stype = internal,\n  finalfunc_extra,\n  finalfunc = combinable_array_agg_finalfn,\n  combinefunc = set_agg_combine,\n  deserialfunc = array_agg_deserialize,\n  serialfunc = array_agg_serialize,\n  parallel = safe\n);\n\nCREATE FUNCTION combinable_array_agg_finalfn2(internal, \"any\")\nRETURNS \"any\"\nAS 'MODULE_PATHNAME', 'combinable_array_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combine_set_agg(internal) (\n  sfunc = set_agg_combine,\n  stype = internal,\n  finalfunc_extra,\n  finalfunc = combinable_array_agg_finalfn2,\n  combinefunc = set_agg_combine,\n  deserialfunc = array_agg_deserialize,\n  serialfunc = array_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_set_agg(internal) (\n  sfunc = set_agg_combine,\n  stype = internal,\n  finalfunc = array_agg_serialize,\n  combinefunc = set_agg_combine,\n  deserialfunc = array_agg_deserialize,\n  serialfunc = array_agg_serialize,\n  parallel = safe\n);\n\n-- exact_count_distinct aggregate\nCREATE AGGREGATE exact_count_distinct(anynonarray) (\n  sfunc = set_agg_trans,\n  stype = internal,\n  finalfunc_extra,\n  finalfunc = set_cardinality,\n  combinefunc = set_agg_combine,\n  deserialfunc = array_agg_deserialize,\n  serialfunc = array_agg_serialize,\n  parallel = safe\n);\n\n-- exact_count_distinct aggregate\nCREATE AGGREGATE combine_exact_count_distinct(internal) (\n  sfunc = set_agg_combine,\n  stype = internal,\n  finalfunc_extra,\n  finalfunc = set_cardinality,\n  combinefunc = set_agg_combine,\n  deserialfunc = array_agg_deserialize,\n  serialfunc = array_agg_serialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_exact_count_distinct(internal) (\n  sfunc = set_agg_combine,\n  stype = internal,\n  finalfunc = array_agg_serialize,\n  combinefunc = set_agg_combine,\n  deserialfunc = array_agg_deserialize,\n  serialfunc = array_agg_serialize,\n  parallel = safe\n);\n\n/*\n * HyperLogLog aggregates and supporting functionality\n */\n\n-- We need to create the shell type first so that we can use hyperloglog in the support function signatures\nCREATE TYPE hyperloglog;\n\nCREATE FUNCTION hll_in(cstring)\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_in'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_out(hyperloglog)\nRETURNS cstring\nAS 'MODULE_PATHNAME', 'hll_out'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_send(hyperloglog)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'hll_send'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_recv(internal)\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_recv'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\n-- Now we can fill in the shell type created above\nCREATE TYPE hyperloglog (\n  input = hll_in,\n  output = hll_out,\n  receive = hll_recv,\n  send = hll_send,\n  alignment = int4,\n  storage = extended\n);\n\nCREATE FUNCTION hll_print(hyperloglog)\nRETURNS text\nAS 'MODULE_PATHNAME', 'hll_print'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_agg_trans(internal, anyelement)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_agg_transp(internal, anyelement, int4)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_agg_transp'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_union_agg_trans(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_union_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_union_agg_trans_hll(internal, hyperloglog)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_union_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_cardinality(hyperloglog)\nRETURNS int8\nAS 'MODULE_PATHNAME', 'hll_cardinality'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_cache_cardinality(hyperloglog)\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_cache_cardinality'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_cache_cardinality_internal(internal)\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_cache_cardinality'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_empty()\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_empty'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_empty(int4)\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_emptyp'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_add(hyperloglog, anyelement)\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_add'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_add(hyperloglog, text)\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_add'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_count_distinct_transition(internal, \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_count_distinct_transition'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_count_distinct_final(internal)\nRETURNS int8\nAS 'MODULE_PATHNAME', 'hll_count_distinct_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'hll_serialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_deserialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_union(variadic \"any\")\nRETURNS hyperloglog\nAS 'MODULE_PATHNAME', 'hll_union'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE hll_count_distinct(\"any\") (\n  sfunc = hll_count_distinct_transition,\n  stype = internal,\n  finalfunc = hll_count_distinct_final,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_hll_count_distinct(internal) (\n  sfunc = hll_union_agg_trans,\n  stype = internal,\n  finalfunc = hll_count_distinct_final,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_hll_count_distinct(internal) (\n  sfunc = hll_union_agg_trans,\n  stype = internal,\n  finalfunc = hll_serialize,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE hll_agg(anyelement) (\n  sfunc = hll_agg_trans,\n  stype = internal,\n  finalfunc = hll_cache_cardinality_internal,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE hll_agg(anyelement, int4) (\n  sfunc = hll_agg_transp,\n  stype = internal,\n  finalfunc = hll_cache_cardinality_internal,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE hll_union_agg(hyperloglog) (\n  sfunc = hll_union_agg_trans_hll,\n  stype = internal,\n  finalfunc = hll_cache_cardinality_internal,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_hll_agg(internal) (\n  sfunc = hll_union_agg_trans,\n  stype = internal,\n  finalfunc = hll_cache_cardinality_internal,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_hll_agg(internal) (\n  sfunc = hll_union_agg_trans,\n  stype = internal,\n  finalfunc = hll_serialize,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\n/*\n * Streamining ordered and hypothetical set aggregates\n *\n * OS/HS aggregates are not combinable, so we create our own standard aggregates\n * for use within CQs. Since we can't use WITHIN GROUP (ORDER BY ...)\n * \n * The interface is of the form:\n * \n *   hll_dense_rank(1, 2, x, y)\n *\n * We then use the initial constant expressions as if they were direct arguments \n * in an OS/HS aggregate, with the remaining variable expressions as the ORDER BY clause.\n * When PG supports combinable OS aggs, we can update these to use the WITHIN GROUP clause.\n */\nCREATE FUNCTION hll_hypothetical_set_transition_multi1(internal, \"any\", \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_hypothetical_set_transition_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hll_dense_rank_final(internal)\nRETURNS int8\nAS 'MODULE_PATHNAME', 'hll_hypothetical_dense_rank_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_dense_rank(\"any\", \"any\") (\n  sfunc = hll_hypothetical_set_transition_multi1,\n  stype = internal,\n  finalfunc = hll_dense_rank_final,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_dense_rank(internal) (\n  sfunc = hll_union_agg_trans,\n  stype = internal,\n  finalfunc = hll_dense_rank_final,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_dense_rank(internal) (\n  sfunc = hll_union_agg_trans,\n  stype = internal,\n  finalfunc = hll_serialize,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\n-- Combine functions and serialization/deserialization functions don't work well\n-- with variadic args, so we have to add explicit signatures for the number of arguments\n-- we want to support :/\nCREATE FUNCTION hll_hypothetical_set_transition_multi2(internal, \"any\", \"any\", \"any\", \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_hypothetical_set_transition_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_dense_rank(\"any\", \"any\", \"any\", \"any\") (\n  sfunc = hll_hypothetical_set_transition_multi2,\n  stype = internal,\n  finalfunc = hll_dense_rank_final,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\nCREATE FUNCTION hll_hypothetical_set_transition_multi3(internal, \"any\", \"any\", \"any\", \"any\", \"any\", \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hll_hypothetical_set_transition_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_dense_rank(\"any\", \"any\", \"any\", \"any\", \"any\", \"any\") (\n  sfunc = hll_hypothetical_set_transition_multi3,\n  stype = internal,\n  finalfunc = hll_dense_rank_final,\n  serialfunc = hll_serialize,\n  deserialfunc = hll_deserialize,\n  combinefunc = hll_union_agg_trans,\n  parallel = safe\n);\n\n-- pipelinedb.rank\nCREATE FUNCTION cq_rank_final(int8[])\nRETURNS int8\nAS 'MODULE_PATHNAME', 'cq_hypothetical_rank_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_hypothetical_set_transition_multi1(int8[], \"any\", \"any\")\nRETURNS int8[]\nAS 'MODULE_PATHNAME', 'cq_hypothetical_set_transition_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_hypothetical_set_transition_multi2(int8[], \"any\", \"any\", \"any\", \"any\")\nRETURNS int8[]\nAS 'MODULE_PATHNAME', 'cq_hypothetical_set_transition_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_hypothetical_set_transition_multi3(int8[], \"any\", \"any\", \"any\", \"any\", \"any\", \"any\")\nRETURNS int8[]\nAS 'MODULE_PATHNAME', 'cq_hypothetical_set_transition_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_hypothetical_set_combine_multi(int8[], int8[])\nRETURNS int8[]\nAS 'MODULE_PATHNAME', 'cq_hypothetical_set_combine_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_rank(\"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi1,\n  stype = int8[],\n  finalfunc = cq_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combinable_rank(\"any\", \"any\", \"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi2,\n  stype = int8[],\n  finalfunc = cq_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combinable_rank(\"any\", \"any\", \"any\", \"any\", \"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi3,\n  stype = int8[],\n  finalfunc = cq_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_rank(int8[]) (\n  sfunc = cq_hypothetical_set_combine_multi,\n  stype = int8[],\n  finalfunc = cq_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_rank(int8[]) (\n  sfunc = cq_hypothetical_set_combine_multi,\n  stype = int8[],\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\n-- percent_rank\nCREATE FUNCTION cq_hypothetical_percent_rank_final(int8[])\nRETURNS float8\nAS 'MODULE_PATHNAME', 'cq_hypothetical_percent_rank_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_percent_rank(\"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi1,\n  stype = int8[],\n  finalfunc = cq_hypothetical_percent_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combinable_percent_rank(\"any\", \"any\", \"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi2,\n  stype = int8[],\n  finalfunc = cq_hypothetical_percent_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combinable_percent_rank(\"any\", \"any\", \"any\", \"any\", \"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi3,\n  stype = int8[],\n  finalfunc = cq_hypothetical_percent_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_percent_rank(int8[]) (\n  sfunc = cq_hypothetical_set_combine_multi,\n  stype = int8[],\n  finalfunc = cq_hypothetical_percent_rank_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_percent_rank(int8[]) (\n  sfunc = cq_hypothetical_set_combine_multi,\n  stype = int8[],\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\n-- cume_dist\nCREATE FUNCTION cq_hypothetical_cume_dist_final(int8[])\nRETURNS float8\nAS 'MODULE_PATHNAME', 'cq_hypothetical_cume_dist_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_cume_dist(\"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi1,\n  stype = int8[],\n  finalfunc = cq_hypothetical_cume_dist_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combinable_cume_dist(\"any\", \"any\", \"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi2,\n  stype = int8[],\n  finalfunc = cq_hypothetical_cume_dist_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combinable_cume_dist(\"any\", \"any\", \"any\", \"any\", \"any\", \"any\") (\n  sfunc = cq_hypothetical_set_transition_multi3,\n  stype = int8[],\n  finalfunc = cq_hypothetical_cume_dist_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_cume_dist(int8[]) (\n  sfunc = cq_hypothetical_set_combine_multi,\n  stype = int8[],\n  finalfunc = cq_hypothetical_cume_dist_final,\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_cume_dist(int8[]) (\n  sfunc = cq_hypothetical_set_combine_multi,\n  stype = int8[],\n  combinefunc = cq_hypothetical_set_combine_multi,\n  parallel = safe\n);\n\n-- percentile_cont\nCREATE FUNCTION cq_percentile_cont_float8_final(internal)\nRETURNS float8\nAS 'MODULE_PATHNAME', 'cq_percentile_cont_float8_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_percentile_cont_float8_final_multi(internal)\nRETURNS float8[]\nAS 'MODULE_PATHNAME', 'cq_percentile_cont_float8_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_percentile_cont_float8_transition(internal, float8, float8)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'cq_percentile_cont_float8_transition'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_percentile_cont_float8_transition_multi(internal, float8[], float8)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'cq_percentile_cont_float8_transition_multi'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_percentile_cont_float8_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'cq_percentile_cont_float8_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_os_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'cq_os_serialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cq_os_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'cq_os_deserialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_percentile_cont(float8, float8) (\n  sfunc = cq_percentile_cont_float8_transition,\n  stype = internal,\n  finalfunc = cq_percentile_cont_float8_final,\n  combinefunc = cq_percentile_cont_float8_combine,\n  serialfunc = cq_os_serialize,\n  deserialfunc = cq_os_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_percentile_cont(internal) (\n  sfunc = cq_percentile_cont_float8_combine,\n  stype = internal,\n  finalfunc = cq_percentile_cont_float8_final,\n  combinefunc = cq_percentile_cont_float8_combine,\n  serialfunc = cq_os_serialize,\n  deserialfunc = cq_os_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_percentile_cont(internal) (\n  sfunc = cq_percentile_cont_float8_combine,\n  stype = internal,\n  finalfunc = cq_os_serialize,\n  combinefunc = cq_percentile_cont_float8_combine,\n  serialfunc = cq_os_serialize,\n  deserialfunc = cq_os_deserialize,\n  parallel = safe\n);\n\n-- percentile_cont\nCREATE AGGREGATE combinable_percentile_cont(float8[], float8) (\n  sfunc = cq_percentile_cont_float8_transition_multi,\n  stype = internal,\n  finalfunc = cq_percentile_cont_float8_final_multi,\n  combinefunc = cq_percentile_cont_float8_combine,\n  serialfunc = cq_os_serialize,\n  deserialfunc = cq_os_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_percentile_cont_multi(internal) (\n  sfunc = cq_percentile_cont_float8_combine,\n  stype = internal,\n  finalfunc = cq_percentile_cont_float8_final_multi,\n  combinefunc = cq_percentile_cont_float8_combine,\n  serialfunc = cq_os_serialize,\n  deserialfunc = cq_os_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_percentile_cont_multi(internal) (\n  sfunc = cq_percentile_cont_float8_combine,\n  stype = internal,\n  finalfunc = cq_os_serialize,\n  combinefunc = cq_percentile_cont_float8_combine,\n  serialfunc = cq_os_serialize,\n  deserialfunc = cq_os_deserialize,\n  parallel = safe\n);\n\n/*\n * Bloom filter aggregates and supporting functionality\n */\n\n-- We need to create the shell type first so that we can use bloom in the support function signatures\nCREATE TYPE bloom;\n\nCREATE FUNCTION bloom_in(cstring)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_in'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_out(bloom)\nRETURNS cstring\nAS 'MODULE_PATHNAME', 'bloom_out'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_send(bloom)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'bloom_send'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_recv(internal)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_recv'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\n-- Now we can fill in the shell type created above\nCREATE TYPE bloom (\n  input = bloom_in,\n  output = bloom_out,\n  receive = bloom_recv,\n  send = bloom_send,\n  alignment = int4,\n  storage = extended\n);\n\nCREATE FUNCTION bloom_empty()\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_empty'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_empty(float8, int8)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_emptyp'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_add(bloom, anyelement)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_add'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_add(bloom, text)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_add'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_cardinality(bloom)\nRETURNS int8\nAS 'MODULE_PATHNAME', 'bloom_cardinality'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_contains(bloom, anyelement)\nRETURNS bool\nAS 'MODULE_PATHNAME', 'bloom_contains'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_print(bloom)\nRETURNS text\nAS 'MODULE_PATHNAME', 'bloom_print'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_agg_trans(bloom, anyelement)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_agg_trans(bloom, anyelement, float8, int8)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_agg_transp'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_union_agg_trans(bloom, bloom)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_union_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE bloom_agg(anyelement) (\n  sfunc = bloom_agg_trans,\n  stype = bloom,\n  combinefunc = bloom_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE bloom_agg(anyelement, float8, int8) (\n  sfunc = bloom_agg_trans,\n  stype = bloom,\n  combinefunc = bloom_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_bloom_agg(bloom) (\n  sfunc = bloom_union_agg_trans,\n  stype = bloom,\n  combinefunc = bloom_union_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_bloom_agg(bloom) (\n  sfunc = bloom_union_agg_trans,\n  stype = bloom,\n  combinefunc = bloom_union_agg_trans,\n  parallel = safe\n);\n\nCREATE FUNCTION bloom_union(variadic \"any\")\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_union'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE bloom_union_agg(bloom) (\n  sfunc = bloom_union_agg_trans,\n  stype = bloom,\n  combinefunc = bloom_union_agg_trans,\n  parallel = safe\n);\n\nCREATE FUNCTION bloom_intersection(variadic \"any\")\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_intersection'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bloom_intersection_agg_trans(bloom, bloom)\nRETURNS bloom\nAS 'MODULE_PATHNAME', 'bloom_intersection_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE bloom_intersection_agg(bloom) (\n  sfunc = bloom_intersection_agg_trans,\n  stype = bloom,\n  combinefunc = bloom_intersection_agg_trans,\n  parallel = safe\n);\n\n/*\n * Filtered space-saving top K aggregates and associated functionality\n */\n\n-- We need to create the shell type first so that we can use topk in the support function signatures\nCREATE TYPE topk;\n\nCREATE FUNCTION topk_in(cstring)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_in'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_out(topk)\nRETURNS cstring\nAS 'MODULE_PATHNAME', 'topk_out'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_send(topk)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'topk_send'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_recv(internal)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_recv'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\n-- Now we can fill in the shell type created above\nCREATE TYPE topk (\n  input = topk_in,\n  output = topk_out,\n  receive = topk_recv,\n  send = topk_send,\n  alignment = int4,\n  storage = extended\n);\n\nCREATE FUNCTION topk_empty(regtype, integer)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_empty'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_empty(regtype, integer, integer, integer)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_emptyp'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_print(topk)\nRETURNS text\nAS 'MODULE_PATHNAME', 'topk_print'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_agg_trans(topk, anyelement, integer)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_agg_trans(topk, anyelement, integer, integer, integer)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_agg_transp'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_merge_agg_trans(topk, topk)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_merge_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_increment(topk, anyelement)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_increment'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE topk_agg(anyelement, integer) (\n  sfunc = topk_agg_trans,\n  stype = topk,\n  combinefunc = topk_merge_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE topk_agg(anyelement, integer, integer, integer) (\n  sfunc = topk_agg_trans,\n  stype = topk,\n  combinefunc = topk_merge_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_topk_agg(topk) (\n  sfunc = topk_merge_agg_trans,\n  stype = topk,\n  combinefunc = topk_merge_agg_trans,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_topk_agg(topk) (\n  sfunc = topk_merge_agg_trans,\n  stype = topk,\n  combinefunc = topk_merge_agg_trans,\n  parallel = safe\n);\n\nCREATE FUNCTION topk_increment(topk, anyelement, int8)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_increment_weighted'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_agg_weighted_trans(topk, anyelement, integer, int8)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'topk_agg_weighted_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE topk_agg(anyelement, integer, int8) (\n  sfunc = topk_agg_weighted_trans,\n  stype = topk,\n  combinefunc = topk_merge_agg_trans,\n  parallel = safe\n);\n\nCREATE FUNCTION hashed_topk_final(internal)\nRETURNS topk\nAS 'MODULE_PATHNAME', 'hashed_topk_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hashed_topk_merge_agg_trans(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hashed_topk_merge_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hashed_topk_agg_weighted_trans(internal, anyelement, integer, int8)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hashed_topk_agg_weighted_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hashed_topk_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'hashed_topk_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hashed_topk_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'hashed_topk_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk(topk)\nRETURNS setof record\nAS 'MODULE_PATHNAME', 'topk'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_values(topk, anyarray default null)\nRETURNS anyarray\nAS 'MODULE_PATHNAME', 'topk_values'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION topk_freqs(topk)\nRETURNS int8[]\nAS 'MODULE_PATHNAME', 'topk_freqs'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n/*\n * T-Digest aggregates and associated functionality\n */\n\n-- We need to create the shell type first so that we can use tdigest in the support function signatures\nCREATE TYPE tdigest;\n\n-- do we need to make this strict?\nCREATE FUNCTION tdigest_in(cstring)\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'tdigest_in'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION tdigest_out(tdigest)\nRETURNS cstring\nAS 'MODULE_PATHNAME', 'tdigest_out'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION tdigest_send(tdigest)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'tdigest_send'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION tdigest_recv(internal)\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'tdigest_recv'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\n-- Now we can fill in the shell type created above\nCREATE TYPE tdigest (\n  input = tdigest_in,\n  output = tdigest_out,\n  receive = tdigest_recv,\n  send = tdigest_send,\n  alignment = int4,\n  storage = extended\n);\n\nCREATE FUNCTION tdigest_empty()\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'tdigest_empty'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION tdigest_empty(integer)\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'tdigest_emptyp'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION tdigest_compress(tdigest)\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'tdigest_compress'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_add(tdigest, float8)\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'dist_add'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_add(tdigest, float8, integer)\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'dist_addn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_cdf(tdigest, float8)\nRETURNS float8\nAS 'MODULE_PATHNAME', 'dist_cdf'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_quantile(tdigest, float8)\nRETURNS float8\nAS 'MODULE_PATHNAME', 'dist_quantile'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_agg_trans(internal, float8)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'dist_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_agg_trans(internal, float8, integer)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'dist_agg_transp'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'dist_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION dist_agg_final(internal)\nRETURNS tdigest\nAS 'MODULE_PATHNAME', 'dist_agg_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION tdigest_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'tdigest_serialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION tdigest_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'tdigest_deserialize'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE dist_agg(float8) (\n  sfunc = dist_agg_trans,\n  stype = internal,\n  finalfunc = dist_agg_final,\n  serialfunc = tdigest_serialize,\n  deserialfunc = tdigest_deserialize,\n  combinefunc = dist_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE dist_agg(float8, integer) (\n  sfunc = dist_agg_trans,\n  stype = internal,\n  finalfunc = dist_agg_final,\n  serialfunc = tdigest_serialize,\n  deserialfunc = tdigest_deserialize,\n  combinefunc = dist_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_dist_agg(internal) (\n  sfunc = dist_combine,\n  stype = internal,\n  finalfunc = dist_agg_final,\n  serialfunc = tdigest_serialize,\n  deserialfunc = tdigest_deserialize,\n  combinefunc = dist_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_dist_agg(internal) (\n  sfunc = dist_combine,\n  stype = internal,\n  finalfunc = tdigest_serialize,\n  serialfunc = tdigest_serialize,\n  deserialfunc = tdigest_deserialize,\n  combinefunc = dist_combine,\n  parallel = safe\n);\n\n/*\n * Count-min sketch aggregates and associated functionality\n */\n\n-- We need to create the shell type first so that we can use tdigest in the support function signatures\nCREATE TYPE cmsketch;\n\nCREATE FUNCTION cmsketch_in(cstring)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'cmsketch_in'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cmsketch_out(cmsketch)\nRETURNS cstring\nAS 'MODULE_PATHNAME', 'cmsketch_out'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cmsketch_send(cmsketch)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'cmsketch_send'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cmsketch_recv(internal)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'cmsketch_recv'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\n-- Now we can fill in the shell type created above\nCREATE TYPE cmsketch (\n  input = cmsketch_in,\n  output = cmsketch_out,\n  receive = cmsketch_recv,\n  send = cmsketch_send,\n  alignment = int4,\n  storage = extended\n);\n\n-- cmsketch_print\nCREATE FUNCTION cmsketch_print(cmsketch)\nRETURNS text\nAS 'MODULE_PATHNAME', 'cmsketch_print'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cmsketch_empty()\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'cmsketch_empty'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cmsketch_empty(float8, float8)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'cmsketch_emptyp'\nLANGUAGE C STRICT IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq_agg_trans(cmsketch, anyelement)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'freq_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq_agg_trans(cmsketch, anyelement, float8, float8)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'freq_agg_transp'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION cmsketch_combine(cmsketch, cmsketch)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'cmsketch_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq(cmsketch, anyelement)\nRETURNS integer\nAS 'MODULE_PATHNAME', 'cmsketch_frequency'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq(cmsketch, text)\nRETURNS integer\nAS 'MODULE_PATHNAME', 'cmsketch_frequency'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq_total(cmsketch)\nRETURNS int8\nAS 'MODULE_PATHNAME', 'cmsketch_total'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq_norm(cmsketch, anyelement)\nRETURNS float8\nAS 'MODULE_PATHNAME', 'cmsketch_norm_frequency'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq_add(cmsketch, anyelement)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'cmsketch_add'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq_add(cmsketch, text)\nRETURNS cmsketch\nAS 'MODULE_PATHNAME', 'cmsketch_add'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION freq_add(cmsketch, anyelement, integer)\nRETURNS float8\nAS 'MODULE_PATHNAME', 'cmsketch_addn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE freq_agg(anyelement) (\n  sfunc = freq_agg_trans,\n  stype = cmsketch,\n  combinefunc = cmsketch_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE freq_merge_agg(cmsketch) (\n  sfunc = cmsketch_combine,\n  stype = cmsketch,\n  combinefunc = cmsketch_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_freq_agg(cmsketch) (\n  sfunc = cmsketch_combine,\n  stype = cmsketch,\n  combinefunc = cmsketch_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_freq_agg(cmsketch) (\n  sfunc = cmsketch_combine,\n  stype = cmsketch,\n  combinefunc = cmsketch_combine,\n  parallel = safe\n);\n\n/*\n * Keyed min/max aggregates and supporting functions\n */\nCREATE FUNCTION keyed_min_trans(bytea, \"any\", \"any\")\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'keyed_min_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION keyed_max_trans(bytea, \"any\", \"any\")\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'keyed_max_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION keyed_min_combine(bytea, bytea)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'keyed_min_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION keyed_max_combine(bytea, bytea)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'keyed_max_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION keyed_min_max_finalize(bytea, \"any\", anyelement)\nRETURNS anyelement\nAS 'MODULE_PATHNAME', 'keyed_min_max_finalize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE keyed_min(\"any\", anyelement) (\n  sfunc = keyed_min_trans,\n  finalfunc = keyed_min_max_finalize,\n  finalfunc_extra,\n  stype = bytea,\n  combinefunc = keyed_min_combine,\n  parallel = safe\n);\n\nCREATE FUNCTION combine_keyed_min_max_finalize(bytea, anyelement default null)\nRETURNS anyelement\nAS 'MODULE_PATHNAME', 'keyed_min_max_finalize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combine_keyed_min(bytea) (\n  sfunc = keyed_min_combine,\n  finalfunc = combine_keyed_min_max_finalize,\n  finalfunc_extra,\n  stype = bytea,\n  combinefunc = keyed_min_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_keyed_min(bytea) (\n  sfunc = keyed_min_combine,\n  stype = bytea,\n  combinefunc = keyed_min_combine,\n  parallel = safe\n);\n\nINSERT INTO pipelinedb.combine (aggfn, combineaggfn) VALUES\n  ((SELECT oid FROM pg_proc WHERE proname = 'keyed_min'), (SELECT oid FROM pg_proc WHERE proname = 'combine_keyed_min'));\n\nCREATE AGGREGATE keyed_max(\"any\", anyelement) (\n  sfunc = keyed_max_trans,\n  finalfunc = keyed_min_max_finalize,\n  finalfunc_extra,\n  stype = bytea,\n  combinefunc = keyed_max_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_keyed_max(bytea) (\n  sfunc = keyed_max_combine,\n  finalfunc = combine_keyed_min_max_finalize,\n  finalfunc_extra,\n  stype = bytea,\n  combinefunc = keyed_max_combine,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_keyed_max(bytea) (\n  sfunc = keyed_max_combine,\n  stype = bytea,\n  combinefunc = keyed_max_combine,\n  parallel = safe\n);\n\nINSERT INTO pipelinedb.combine (aggfn, combineaggfn) VALUES\n  ((SELECT oid FROM pg_proc WHERE proname = 'keyed_max'), (SELECT oid FROM pg_proc WHERE proname = 'combine_keyed_max'));\n\n/*\n * first_values aggregate and supporting functions\n * Combine functions and serialization/deserialization functions don't work well\n * with variadic args, so we have to add explicit signatures for the number of arguments\n * we want to support :/\n */\nCREATE FUNCTION first_values_trans1(internal, integer, anyelement)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'first_values_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_trans2(internal, integer, anyelement, \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'first_values_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_trans3(internal, integer, anyelement, \"any\", \"any\")\nRETURNS internal\nAS 'MODULE_PATHNAME', 'first_values_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_final1(internal, integer, anyelement)\nRETURNS anyarray\nAS 'MODULE_PATHNAME', 'first_values_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_final2(internal, integer, anyelement, \"any\")\nRETURNS anyarray\nAS 'MODULE_PATHNAME', 'first_values_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_final3(internal, integer, anyelement, \"any\", \"any\")\nRETURNS anyarray\nAS 'MODULE_PATHNAME', 'first_values_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'first_values_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'first_values_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION first_values_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'first_values_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE first_values(integer, anyelement) (\n  sfunc = first_values_trans1,\n  finalfunc = first_values_final1,\n  finalfunc_extra,\n  stype = internal,\n  combinefunc = first_values_combine,\n  serialfunc = first_values_serialize,\n  deserialfunc = first_values_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE first_values(integer, anyelement, \"any\") (\n  sfunc = first_values_trans2,\n  finalfunc = first_values_final2,\n  finalfunc_extra,\n  stype = internal,\n  combinefunc = first_values_combine,\n  serialfunc = first_values_serialize,\n  deserialfunc = first_values_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE first_values(integer, anyelement, \"any\", \"any\") (\n  sfunc = first_values_trans3,\n  finalfunc = first_values_final3,\n  finalfunc_extra,\n  stype = internal,\n  combinefunc = first_values_combine,\n  serialfunc = first_values_serialize,\n  deserialfunc = first_values_deserialize,\n  parallel = safe\n);\n\n/*\n * bucket_agg aggregate and supporting functions\n */\nCREATE FUNCTION bucket_agg_trans(internal, anyelement, int2)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'bucket_agg_trans'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bucket_agg_trans_ts(internal, anyelement, int2, timestamptz)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'bucket_agg_trans_ts'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bucket_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'bucket_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bucket_agg_final(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'bucket_agg_final'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n-- bucket_cardinalities\nCREATE FUNCTION bucket_cardinalities(bytea)\nRETURNS integer[]\nAS 'MODULE_PATHNAME', 'bucket_cardinalities'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bucket_cardinality(bytea)\nRETURNS bigint\nAS 'MODULE_PATHNAME', 'bucket_cardinality'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bucket_agg_state_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'bucket_agg_state_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bucket_agg_state_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'bucket_agg_state_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION bucket_ids(bytea)\nRETURNS int2[]\nAS 'MODULE_PATHNAME', 'bucket_ids'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE bucket_agg(anyelement, int2) (\n  sfunc = bucket_agg_trans,\n  finalfunc = bucket_agg_final,\n  stype = internal,\n  combinefunc = bucket_agg_combine,\n  serialfunc = bucket_agg_state_serialize,\n  deserialfunc = bucket_agg_state_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE bucket_agg(anyelement, int2, timestamptz) (\n  sfunc = bucket_agg_trans_ts,\n  finalfunc = bucket_agg_final,\n  stype = internal,\n  combinefunc = bucket_agg_combine,\n  serialfunc = bucket_agg_state_serialize,\n  deserialfunc = bucket_agg_state_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_bucket_agg(internal) (\n  sfunc = bucket_agg_combine,\n  finalfunc = bucket_agg_final,\n  stype = internal,\n  combinefunc = bucket_agg_combine,\n  serialfunc = bucket_agg_state_serialize,\n  deserialfunc = bucket_agg_state_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_bucket_agg(internal) (\n  sfunc = bucket_agg_combine,\n  finalfunc = bucket_agg_state_serialize,\n  stype = internal,\n  combinefunc = bucket_agg_combine,\n  serialfunc = bucket_agg_state_serialize,\n  deserialfunc = bucket_agg_state_deserialize,\n  parallel = safe\n);\n\n/*\n * Combinable string_agg and bytea_string_agg\n */\nCREATE FUNCTION combinable_string_agg_finalfn(internal)\nRETURNS text\nAS 'MODULE_PATHNAME', 'combinable_string_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_string_agg_transfn(internal, text, text)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'combinable_string_agg_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_bytea_string_agg_finalfn(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'combinable_bytea_string_agg_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_bytea_string_agg_transfn(internal, bytea, bytea)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'combinable_bytea_string_agg_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION combinable_string_agg_combine(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'combinable_string_agg_combine'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION string_agg_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'string_agg_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION string_agg_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'string_agg_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE combinable_string_agg(text, text) (\n  sfunc = combinable_string_agg_transfn,\n  finalfunc = combinable_string_agg_finalfn,\n  stype = internal,\n  combinefunc = combinable_string_agg_combine,\n  serialfunc = string_agg_serialize,\n  deserialfunc = string_agg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_string_agg(internal) (\n  sfunc = combinable_string_agg_combine,\n  finalfunc = combinable_string_agg_finalfn,\n  stype = internal,\n  combinefunc = combinable_string_agg_combine,\n  serialfunc = string_agg_serialize,\n  deserialfunc = string_agg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_string_agg(internal) (\n  sfunc = combinable_string_agg_combine,\n  finalfunc = string_agg_serialize,\n  stype = internal,\n  combinefunc = combinable_string_agg_combine,\n  serialfunc = string_agg_serialize,\n  deserialfunc = string_agg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combinable_string_agg(bytea, bytea) (\n  sfunc = combinable_bytea_string_agg_transfn,\n  finalfunc = combinable_bytea_string_agg_finalfn,\n  stype = internal,\n  combinefunc = combinable_string_agg_combine,\n  serialfunc = string_agg_serialize,\n  deserialfunc = string_agg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE combine_bytea_string_agg(internal) (\n  sfunc = combinable_string_agg_combine,\n  finalfunc = combinable_bytea_string_agg_finalfn,\n  stype = internal,\n  combinefunc = combinable_string_agg_combine,\n  serialfunc = string_agg_serialize,\n  deserialfunc = string_agg_deserialize,\n  parallel = safe\n);\n\nCREATE AGGREGATE partial_combine_bytea_string_agg(internal) (\n  sfunc = combinable_string_agg_combine,\n  finalfunc = string_agg_serialize,\n  stype = internal,\n  combinefunc = combinable_string_agg_combine,\n  serialfunc = string_agg_serialize,\n  deserialfunc = string_agg_deserialize,\n  parallel = safe\n);\n\n/*\n * json_object_int_sum\n */\nCREATE FUNCTION json_object_int_sum_serialize(internal)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'json_object_int_sum_serialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION json_object_int_sum_deserialize(bytea, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'json_object_int_sum_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION json_object_int_sum_transfn(internal, text)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'json_object_int_sum_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION json_object_int_sum_transfn(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME', 'json_object_int_sum_transfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION json_object_int_sum_finalfn(internal)\nRETURNS text\nAS 'MODULE_PATHNAME', 'json_object_int_sum_finalfn'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE AGGREGATE json_object_int_sum(text) (\n  sfunc = json_object_int_sum_transfn,\n  finalfunc = json_object_int_sum_finalfn,\n  stype = internal,\n  combinefunc = json_object_int_sum_transfn,\n  serialfunc = json_object_int_sum_serialize,\n  deserialfunc = json_object_int_sum_deserialize,\n  parallel = safe\n);\n\n/*\n * Function that allows us to call aggregate deserialization functions from overlay views.\n * Many of them expect to be called in an aggregate context, so we create the expected\n * context and then use it to call the target deserialization function.\n */\nCREATE FUNCTION pipelinedb.finalize(text, text[], bytea, anyelement)\nRETURNS anyelement\nAS 'MODULE_PATHNAME', 'pipeline_finalize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION pipelinedb.deserialize(regproc, bytea)\nRETURNS bytea\nAS 'MODULE_PATHNAME', 'pipeline_deserialize'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\n/*\n * miscellaneous utility functions\n */\nCREATE FUNCTION year(timestamptz)\nRETURNS timestamptz\nAS 'MODULE_PATHNAME', 'timestamptz_year'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION month(timestamptz)\nRETURNS timestamptz\nAS 'MODULE_PATHNAME', 'timestamptz_month'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION day(timestamptz)\nRETURNS timestamptz\nAS 'MODULE_PATHNAME', 'timestamptz_day'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION hour(timestamptz)\nRETURNS timestamptz\nAS 'MODULE_PATHNAME', 'timestamptz_hour'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION minute(timestamptz)\nRETURNS timestamptz\nAS 'MODULE_PATHNAME', 'timestamptz_minute'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION second(timestamptz)\nRETURNS timestamptz\nAS 'MODULE_PATHNAME', 'timestamptz_second'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION pipelinedb.version()\nRETURNS text\nAS 'MODULE_PATHNAME', 'pipeline_version'\nLANGUAGE C IMMUTABLE PARALLEL SAFE;\n\nCREATE FUNCTION pipelinedb.truncate_continuous_view(text)\nRETURNS void\nAS 'MODULE_PATHNAME', 'pipeline_truncate_continuous_view'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.ttl_expire(text)\nRETURNS int8\nAS 'MODULE_PATHNAME', 'pipeline_ttl_expire'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.set_ttl(text, interval, text)\nRETURNS setof record\nAS 'MODULE_PATHNAME', 'pipeline_set_ttl'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.activate(text)\nRETURNS bool\nAS 'MODULE_PATHNAME', 'pipeline_activate'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.deactivate(text)\nRETURNS bool\nAS 'MODULE_PATHNAME', 'pipeline_deactivate'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.flush()\nRETURNS bool\nAS 'MODULE_PATHNAME', 'pipeline_flush'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.combine_table(text, text)\nRETURNS bool\nAS 'MODULE_PATHNAME', 'combine_table'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.get_worker_querydef(text)\nRETURNS text\nAS 'MODULE_PATHNAME', 'pipeline_get_worker_querydef'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.get_combiner_querydef(text)\nRETURNS text\nAS 'MODULE_PATHNAME', 'pipeline_get_combiner_querydef'\nLANGUAGE C IMMUTABLE;\n\nCREATE FUNCTION pipelinedb.get_stream_readers()\nRETURNS table (\n  stream text,\n  continuous_queries text[]\n)\nAS 'MODULE_PATHNAME', 'pipeline_get_stream_readers'\nLANGUAGE C IMMUTABLE;\n\n/*\n * Human-readable stream readers\n */\nCREATE VIEW pipelinedb.stream_readers AS\n SELECT stream, continuous_queries FROM pipelinedb.get_stream_readers();\n\n/*\n * stats retrieval functions and VIEWs\n */\nCREATE FUNCTION pipelinedb.get_proc_query_stats()\nRETURNS table (\n  type text,\n  pid int4,\n  start_time timestamptz,\n  query_id int4,\n  input_rows int8,\n  output_rows int8,\n  updated_rows int8,\n  input_bytes int8,\n  output_bytes int8,\n  updated_bytes int8,\n  executions int8,\n  errors int8,\n  exec_ms int8\n)\nAS 'MODULE_PATHNAME', 'pipeline_get_proc_query_stats'\nLANGUAGE C IMMUTABLE;\n\n-- Raw stats, most granular form\nCREATE VIEW pipelinedb.proc_query_stats AS\n SELECT\n   type,\n   pid,\n   start_time,\n   query_id,\n   input_rows,\n   output_rows,\n   updated_rows,\n   output_bytes,\n   updated_bytes,\n   input_bytes,\n   executions,\n   errors,\n   exec_ms\n FROM pipelinedb.get_proc_query_stats();\n\n-- Stats by process type, pid\nCREATE VIEW pipelinedb.proc_stats AS\n SELECT\n   type,\n   pid,\n   min(start_time) AS start_time,\n   sum(input_rows) AS input_rows,\n   sum(output_rows) AS output_rows,\n   sum(updated_rows) AS updated_rows,\n   sum(output_bytes) AS output_bytes,\n   sum(updated_bytes) AS updated_bytes,\n   sum(input_bytes) AS input_bytes,\n   sum(executions) AS executions,\n   sum(errors) AS errors,\n   sum(exec_ms) AS exec_ms\n FROM pipelinedb.proc_query_stats\nGROUP BY type, pid\nORDER BY type, pid;\n\n-- Stats by process type, query\nCREATE VIEW pipelinedb.query_stats AS\n SELECT\n   s.type,\n   n.nspname AS namespace,\n   c.relname AS continuous_query,\n   sum(input_rows) AS input_rows,\n   sum(output_rows) AS output_rows,\n   sum(updated_rows) AS updated_rows,\n   sum(output_bytes) AS output_bytes,\n   sum(updated_bytes) AS updated_bytes,\n   sum(input_bytes) AS input_bytes,\n   sum(executions) AS executions,\n   sum(errors) AS errors,\n   sum(exec_ms) AS exec_ms\n FROM pipelinedb.proc_query_stats s\n JOIN pipelinedb.cont_query pq ON pq.id = s.query_id\n JOIN pg_class c ON pq.relid = c.oid\n JOIN pg_namespace n ON c.relnamespace = n.oid\nGROUP BY s.type, namespace, continuous_query \nORDER BY s.type, namespace, continuous_query;\n\n-- Stats by process type\nCREATE VIEW pipelinedb.db_stats AS\n SELECT\n   type,\n   sum(input_rows) AS input_rows,\n   sum(output_rows) AS output_rows,\n   sum(updated_rows) AS updated_rows,\n   sum(output_bytes) AS output_bytes,\n   sum(updated_bytes) AS updated_bytes,\n   sum(input_bytes) AS input_bytes,\n   sum(executions) AS executions,\n   sum(errors) AS errors,\n   sum(exec_ms) AS exec_ms\n FROM pipelinedb.proc_query_stats\nGROUP BY type\nORDER BY type;\n\nCREATE FUNCTION pipelinedb.get_stream_stats()\nRETURNS table (\n  relid oid,\n  input_rows int8,\n  input_batches int8,\n  input_bytes int8\n)\nAS 'MODULE_PATHNAME', 'pipeline_get_stream_stats'\nLANGUAGE C IMMUTABLE;\n\nCREATE VIEW pipelinedb.stream_stats AS\n SELECT\n  n.nspname AS namespace,\n  c.relname AS stream,\n  input_rows,\n  input_batches,\n  input_bytes\n FROM pipelinedb.get_stream_stats() s\n JOIN pg_class c ON s.relid = c.oid\n JOIN pg_namespace n ON c.relnamespace = n.oid;\n"
        },
        {
          "name": "pipelinedb.control",
          "type": "blob",
          "size": 0.126953125,
          "content": "# PipelineDB extension\ncomment = 'PipelineDB'\ndefault_version = '1.1.0'\nmodule_pathname = '$libdir/pipelinedb'\nrelocatable = true\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}