{
  "metadata": {
    "timestamp": 1736710120569,
    "page": 757,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hoytech/vmtouch",
      "stars": 1829,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.017578125,
          "content": "vmtouch\nvmtouch.8\n"
        },
        {
          "name": ".logp.conf",
          "type": "blob",
          "size": 0.0263671875,
          "content": "run:\n  env:\n    - TRAVIS_*\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.078125,
          "content": "language: c\nsudo: false\ndist: trusty\n\ncompiler:\n  - clang\n  - gcc\n\nscript: make\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 3.6689453125,
          "content": "1.3.1    2018-11-16\n  * New switch: \"-P <pidfile>\". When combined with -l or -L, the\n    PID of the daemon process will be written to this file.\n    (Thanks Jon Lin)\n  * In Makefile, support staged installs using DESTDIR\n    (Thanks Earnestly)\n  * Create snapcraft.yaml to enable snap creation\n    (Thanks Alan Pope)\n  * Fix compilation for pre-C99 compilers\n    (Thanks Rushikesh Jadhav)\n  * Documentation improvements\n\n1.3.0    2017-03-16\n  * New switch: \"-b <file>\". This enables \"batch mode\" where the\n    list of files to crawl is read from the specified file\n    (Thanks Tw)\n  * New switch: \"-0\". When this is enabled, the files in\n    \"batch mode\" are separated by NUL bytes instead of newlines\n  * New switch: \"-F\". Prevents vmtouch from traversing separate\n    filesystems (requested by mailinglists35)\n  * Lots of updates to the debian packaging (Thanks anarcat)\n  * Use standard path for manpages (Thanks anarcat)\n  * On linux, if an open fails due to EPERM then try again\n    without O_NOATIME\n\n1.2.0    2016-12-01\n  * -i feature which lets you ignore entire files and directories\n    (Thanks Etienne Bruines)\n  * -I feature which lets you only process filenames matching\n    certain patterns.\n  * Both -i and -I support wildcards\n  * Specify C99 standard during compile (Thanks ecebuzz)\n\n1.1.0    2016-08-08\n  * Better error checking for extremely large values to command\n    line parameters (Thanks Matthew Fernandez)\n  * Fix some boundary conditions in the range support added\n    in 1.0.1 (Thanks Justas Lavišius)\n  * On Linux, support touching/evicting/displaying block devices\n    directly. This displays the underlying buffer cache, not the\n    filesystem cache (Thanks to maq123 for the suggestion)\n  * On Linux, open files with O_NOATIME so that we don't cause\n    unnecessary disk activity recording access times\n    (Thanks Mat R.)\n  * Replaces a stat() call with an fstat() call which is slightly\n    more efficient.\n  * Skipped symlinks are no longer included in total file count\n  * Closes file descriptors after locking memory since there is\n    no need to keep them open. This makes it less likely you will\n    hit the RLIMIT_NOFILE when using -l or -L.\n  * TUNING.md file (Thanks to Artem Sheremet for the idea and\n    to Vladimir Kotal for Solaris tuning info)\n\n1.0.2    2015-12-04\n  * Clean-up Makefile and improve its portability.\n  * Documentation updates.\n\n1.0.1    2015-10-16\n  * Change default max file size (specified with -m) to\n    SIZE_MAX instead of 500m. This is 4G on 32-bit systems\n    and effectively unlimited on 64-bit systems.\n    (Thanks Erik Garrison)\n  * -p mode which lets you view/touch/evict/lock ranges of\n    files instead of just whole files. (Thanks Justas Lavišius)\n  * Update debian packaging files. (Thanks Luka Blaskovic)\n  * Fix bug that prevented you from trying to crawl your\n    entire filesystem from the root.\n  * Fix to work with glibc 2.20. (Thanks Jim Garrison)\n  * Fix format string warning when compiling with clang.\n    (Thanks Mikolaj Golub)\n  * Cleaner and better Makefile. (Thanks Emmanuel Kasper and\n    Mikolaj Golub)\n  * Don't double-count the same file that just happens to have\n    multiple hard-links to it. (Thanks Carsten Otto)\n  * Add option to wait for daemon mode to finish mlocking.\n    (Thanks Kristofer Karlsson)\n\n0.8.0    2012-12-04\n  * Patch from Marc Brooker: avoid overflowing stack when\n    allocating array for mincore() output\n  * Patch from Federico Lucifredi: Avoid ugly NaNs in output\n  * Full OS X support: msync(2) evicts pages on this system\n  * HP-UX support from Shane Seymour (thanks!)\n  * Patch from soarpenguin: detect invalid size formats\n\n0.7.3\n  * Solaris support for page eviction\n\n0.7.2\n  * Portability fixes\n\n0.7.1\n  * First public release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4462890625,
          "content": "Copyright 2009-2023 Doug Hoyte and contributors\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.6455078125,
          "content": "PREFIX?=\t/usr/local\nBINDIR?=\t$(PREFIX)/bin\nMANDIR?=\t$(PREFIX)/share/man/man8\n\nCC?=\t\tcc\nCFLAGS+=\t-Wall -O2 -g -std=c99\n\nall: vmtouch vmtouch.8\n\n.PHONY: all install clean uninstall\n\nvmtouch: vmtouch.c\n\t${CC} ${CFLAGS} ${LDFLAGS} -o vmtouch vmtouch.c\n\nvmtouch.8: vmtouch.pod\n\tpod2man --section 8 --center \"System Manager's Manual\" --release \" \" vmtouch.pod > vmtouch.8\n\ninstall: vmtouch vmtouch.8\n\tmkdir -p $(DESTDIR)$(BINDIR) $(DESTDIR)$(MANDIR)\n\tinstall -m 0755 vmtouch $(DESTDIR)$(BINDIR)/vmtouch\n\tinstall -m 0644 vmtouch.8 $(DESTDIR)$(MANDIR)/vmtouch.8\n\nclean:\n\trm -f vmtouch vmtouch.8\n\nuninstall:\n\trm $(DESTDIR)$(BINDIR)/vmtouch $(DESTDIR)$(MANDIR)/vmtouch.8\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.0986328125,
          "content": "# vmtouch - the Virtual Memory Toucher\n\n[![Build Status](https://travis-ci.org/hoytech/vmtouch.svg?branch=master)](https://travis-ci.org/hoytech/vmtouch)\n\n\n## Portable file system cache diagnostics and control\n\n\nvmtouch is a tool for learning about and controlling the file system cache of unix and unix-like systems. It is BSD licensed so you can basically do whatever you want with it.\n\n\n### Quick install guide:\n\n    $ git clone https://github.com/hoytech/vmtouch.git\n    $ cd vmtouch\n    $ make\n    $ sudo make install\n\n\n### More information\n\n* [Official Website](https://hoytech.com/vmtouch/)\n* [Online manual](https://github.com/hoytech/vmtouch/blob/master/vmtouch.pod)\n* [System tuning parameters](https://github.com/hoytech/vmtouch/blob/master/TUNING.md)\n\n\n### Support\n\nTo complement the open source community, Hoytech offers services related to vmtouch:\n\n* Advanced feature development\n* Support contracts\n* Training sessions\n\nPlease <a href=\"mailto:doug@hoytech.com?subject=vmtouch support\">contact Doug Hoyte</a> for more information.\n\n\n### Authors\n\nvmtouch is copyright (c) 2009-2017 Doug Hoyte and contributors.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.85546875,
          "content": "* Machine readable input/output (JSON?)\n\n* Continually call mincore() every time a residency chart is drawn\n\n* Deprecate -w (it should be the default when combined with -d)\n\n* -a switch where you can specify flags to madvise() that should be applied to your mappings\n  * Examples:\n    -a sequential -a willneed\n    -a noreserve\n\n* switch where you can specify flags to mmap() (would be nice to use -m but it's taken)\n  * Examples:\n    -m noreserve\n    -m populate\n\n  * Use cases:\n    * Try opening large mappings with MAP_HUGETLB on linux 2.6.32+\n    * From Dennis (Apr 2012):\n      \"Additionally you might want to use MAP_NORESERVE for the mmap, this seems to speed things a bit up for multiple huge files.\"\n\n* Windows support some day?\n  * https://msdn.microsoft.com/en-us/library/hh780543(v=vs.85).aspx\n  * https://blogs.msdn.microsoft.com/oldnewthing/20170113-00/?p=95185\n"
        },
        {
          "name": "TUNING.md",
          "type": "blob",
          "size": 3.05078125,
          "content": "# System tuning parameters for vmtouch\n\n## Limits on memory locking\n\nSee your operating system's `mlock(2)` manual page since it probably describes the limitations on this system call which vmtouch uses.\n\n### Linux\n\n* **locked memory rlimit**: Processes typically have a limit on the number of memory that is locked. This can be raised with `ulimit -l` (see `RLIMIT_MEMLOCK` in [setrlimit(2)](http://linux.die.net/man/2/setrlimit)) if you are the super-user. Processes with the `CAP_IPC_LOCK` are not affected by this limit, and it can be raised for unprivileged processes by editing [limits.conf](http://linux.die.net/man/5/limits.conf).\n* **vm.max_map_count**: This is a [sysctl](http://linux.die.net/man/8/sysctl) that controls the maximum number of VMAs (virtual memory areas) that a process can map. Since vmtouch needs a VMA for every file, this limits the number of files that can be locked by an individual vmtouch process.\n* Since Linux 2.6.9 (?) there is no system-wide limit on the amount of locked memory.\n\n### FreeBSD\n\n* See [mlock(2)](https://www.freebsd.org/cgi/man.cgi?query=mlock&sektion=2&manpath=freebsd-release-ports)\n* **sysctls**: see `vm.max_wired` and `vm.stats.vm.v_wire_count`\n* **security.bsd.unprivileged_mlock**: Whether unprivileged users can lock memory\n\n### OpenBSD\n\n* Has both a per-process resource limit and a system-wide limit on locked memory, see [mlock(2)](http://man.openbsd.org/mlock.2)\n\n### Solaris\n\nOn Solaris, the memory locked page limit can be set on per-project or per-zone basis, see resource-controls(5) man page for details. The limits can be manipulated and observed using prctl or zonecfg command, e.g.:\n\n    $ prctl -n project.max-locked-memory -i process $$\n    process: 4690: bash\n    NAME    PRIVILEGE       VALUE    FLAG   ACTION                       RECIPIENT\n    project.max-locked-memory\n            usage               0B\n            system          16.0EB    max   deny                                 -\n\nAlso, there is the PRIV_PROC_LOCK_MEMORY privilege which controls whether given process can lock memory.\n\n\n\n## Network filesystems\n\n### NFS\n\nNFS appears to function as a normal filesystem from `vmtouch`'s perspective. The only issue is that crawls of large directories can take a long time.\n\n### S3FS\n\nOn linux, S3FS is a FUSE-based filesystem driver that mounts your Amazon S3 buckets. When caching files it doesn't use the normal page cache for these files, but instead maintains a cache directory where the cached files and portions of files reside. `vmtouch` can be meaningfully used on these files in the cache directory, but not in the mount itself.\n\nBy default the cache directory is `$HOME/.fuse-s3fs-cache/` but this can be changed with the `cachedir` mount option is used. Also see the `preserve_cache` option if you wish the cache to persist between mountings.\n\n### 9P\n\nThe 9P filesystem driver 9P2000 on linux doesn't by default use the filesystem cache. However, there is a mount option `fscache` which enables this. See github issue [#56](https://github.com/hoytech/vmtouch/issues/56). After this is enabled, `vmtouch` should work as normal.\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "snap",
          "type": "tree",
          "content": null
        },
        {
          "name": "vmtouch.c",
          "type": "blob",
          "size": 27.7978515625,
          "content": "/***********************************************************************\nvmtouch - the Virtual Memory Toucher\n\nPortable file system cache diagnostics and control\n\nby Doug Hoyte (doug@hcsw.org)\n\nCompilation:\n  gcc -Wall -O3 -o vmtouch vmtouch.c\n\n************************************************************************\n\nCopyright 2009-2023 Doug Hoyte and contributors\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n***********************************************************************/\n\n\n#define VMTOUCH_VERSION \"1.3.1\"\n#define RESIDENCY_CHART_WIDTH 60\n#define CHART_UPDATE_INTERVAL 0.1\n#define MAX_CRAWL_DEPTH 1024\n#define MAX_NUMBER_OF_IGNORES 1024\n#define MAX_NUMBER_OF_FILENAME_FILTERS 1024\n#define MAX_FILENAME_LENGTH 1024\n\n#if defined(__linux__) || (defined(__hpux) && !defined(__LP64__))\n// Make sure off_t is 64 bits on linux and when creating 32bit programs\n// on HP-UX.\n#define _FILE_OFFSET_BITS 64\n#endif\n\n#ifdef __linux__\n// Required for posix_fadvise() on some linux systems\n#define _XOPEN_SOURCE 600\n// Required for mincore() on some linux systems\n#define _DEFAULT_SOURCE\n#define _BSD_SOURCE\n// for O_NOATIME\n#define _GNU_SOURCE\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <math.h>\n#include <search.h>\n#include <libgen.h>\n#include <fnmatch.h>\n\n#if defined(__linux__)\n// Used to find size of block devices\n#include <sys/ioctl.h>\n#include <sys/mount.h>\n// Used to check kernal version to know if mincore reports correctly\n#include <sys/utsname.h>\n#endif\n\n/*\n * To find out if the stat results from a single file correspond to a file we\n * have already seen, we need to compare both the device and the inode\n */\nstruct dev_and_inode\n{\n    dev_t dev;\n    ino_t ino;\n};\n\nlong pagesize;\n\nint64_t total_pages=0;\nint64_t total_pages_in_core=0;\nint64_t total_files=0;\nint64_t total_dirs=0;\n\nint64_t offset=0;\nint64_t max_len=0;\n\nunsigned int junk_counter; // just to prevent any compiler optimizations\n\nint curr_crawl_depth=0;\nino_t crawl_inodes[MAX_CRAWL_DEPTH];\n\n// remember all inodes (for files with inode count > 1) to find duplicates\nvoid *seen_inodes = NULL;\ndev_t orig_device = 0;\nint orig_device_inited = 0;\n\n\nint o_touch=0;\nint o_evict=0;\nint o_quiet=0;\nint o_verbose=0;\nint o_lock=0;\nint o_lockall=0;\nint o_daemon=0;\nint o_followsymlinks=0;\nint o_singlefilesystem=0;\nint o_ignorehardlinkeduplictes=0;\nsize_t o_max_file_size=SIZE_MAX;\nint o_wait=0;\nstatic char *o_batch = NULL;\nstatic char *o_pidfile = NULL;\nstatic char *o_output = NULL;\nint o_0_delim = 0;\n\n\nchar *ignore_list[MAX_NUMBER_OF_IGNORES];\nchar *filename_filter_list[MAX_NUMBER_OF_FILENAME_FILTERS];\nint number_of_ignores=0;\nint number_of_filename_filters=0;\n\n\nint exit_pipe[2];\n\nint daemon_pid;\n\n\nvoid send_exit_signal(char code) {\n  if (daemon_pid == 0 && o_wait) {\n    if (write(exit_pipe[1], &code, 1) < 0)\n      fprintf(stderr, \"vmtouch: FATAL: write: %s\", strerror(errno));\n  }\n}\n\nvoid usage() {\n  printf(\"\\n\");\n  printf(\"vmtouch v%s - the Virtual Memory Toucher by Doug Hoyte\\n\", VMTOUCH_VERSION);\n  printf(\"Portable file system cache diagnostics and control\\n\\n\");\n  printf(\"Usage: vmtouch [OPTIONS] ... FILES OR DIRECTORIES ...\\n\\nOptions:\\n\");\n  printf(\"  -t touch pages into memory\\n\");\n  printf(\"  -e evict pages from memory\\n\");\n  printf(\"  -l lock pages in physical memory with mlock(2)\\n\");\n  printf(\"  -L lock pages in physical memory with mlockall(2)\\n\");\n  printf(\"  -d daemon mode\\n\");\n  printf(\"  -m <size> max file size to touch\\n\");\n  printf(\"  -p <range> use the specified portion instead of the entire file\\n\");\n  printf(\"  -f follow symbolic links\\n\");\n  printf(\"  -F don't crawl different filesystems\\n\");\n  printf(\"  -h also count hardlinked copies\\n\");\n  printf(\"  -i <pattern> ignores files and directories that match this pattern\\n\");\n  printf(\"  -I <pattern> only process files that match this pattern\\n\");\n  printf(\"  -b <list file> get files or directories from the list file\\n\");\n  printf(\"  -0 in batch mode (-b) separate paths with NUL byte instead of newline\\n\");\n  printf(\"  -w wait until all pages are locked (only useful together with -d)\\n\");\n  printf(\"  -P <pidfile> write a pidfile (only useful together with -l or -L)\\n\");\n  printf(\"  -o <type> output in machine friendly format.  'kv' for key=value pairs.\\n\");\n  printf(\"  -v verbose\\n\");\n  printf(\"  -q quiet\\n\");\n  exit(1);\n}\n\nstatic void fatal(const char *fmt, ...) {\n  va_list ap;\n  char buf[4096];\n\n  va_start(ap, fmt);\n  vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n\n  fprintf(stderr, \"vmtouch: FATAL: %s\\n\", buf);\n  send_exit_signal(1);\n  exit(1);\n}\n\nstatic void warning(const char *fmt, ...) {\n  va_list ap;\n  char buf[4096];\n\n  va_start(ap, fmt);\n  vsnprintf(buf, sizeof(buf), fmt, ap);\n  va_end(ap);\n\n  if (!o_quiet) fprintf(stderr, \"vmtouch: WARNING: %s\\n\", buf);\n}\n\nstatic void reopen_all() {\n  if (freopen(\"/dev/null\", \"r\", stdin) == NULL ||\n      freopen(\"/dev/null\", \"w\", stdout) == NULL ||\n      freopen(\"/dev/null\", \"w\", stdout) == NULL)\n    fatal(\"freopen: %s\", strerror(errno));\n}\n\nstatic int wait_for_child() {\n  int exit_read = 0;\n  char exit_value = 0;\n  int wait_status;\n\n  while (1) {\n    struct timeval tv;\n    fd_set rfds;\n    FD_ZERO(&rfds);\n    tv.tv_sec = 1;\n    tv.tv_usec = 0;\n    FD_SET(exit_pipe[0], &rfds);\n    if (select(exit_pipe[0] + 1, &rfds, NULL, NULL, &tv) < 0)\n      fatal(\"select: %s\", strerror(errno));\n\n    if (waitpid(daemon_pid, &wait_status, WNOHANG) > 0)\n      fatal(\"daemon shut down unexpectedly\");\n\n    if (FD_ISSET(exit_pipe[0], &rfds))\n      break;\n  }\n  exit_read = read(exit_pipe[0], &exit_value, 1);\n  if (exit_read < 0)\n    fatal(\"read: %s\", strerror(errno));\n  return exit_value;\n}\n\nvoid go_daemon() {\n  daemon_pid = fork();\n  if (daemon_pid == -1)\n    fatal(\"fork: %s\", strerror(errno));\n  if (daemon_pid) {\n    if (o_wait)\n      exit(wait_for_child());\n    exit(0);\n  }\n\n  if (setsid() == -1)\n    fatal(\"setsid: %s\", strerror(errno));\n\n  if (!o_wait) reopen_all();\n}\n\n\nchar *pretty_print_size(int64_t inp) {\n  static char output[100];\n\n  if (inp<1024) {\n    snprintf(output, sizeof(output), \"%\" PRId64, inp);\n    return output;\n  }\n  inp /= 1024;\n  if (inp<1024) {\n    snprintf(output, sizeof(output), \"%\" PRId64 \"K\", inp);\n    return output;\n  }\n  inp /= 1024;\n  if (inp<1024) {\n    snprintf(output, sizeof(output), \"%\" PRId64 \"M\", inp);\n    return output;\n  }\n  inp /= 1024;\n  snprintf(output, sizeof(output), \"%\" PRId64 \"G\", inp);\n  return output;\n}\n\n/*\n *  Convert ASCII string to int64_t number\n *  Note: The inp parameter can't be a character constant\n *        because it will be overwritten.\n */\nint64_t parse_size(char *inp) {\n  char *tp;\n  int len=strlen(inp);\n  char *errstr = \"bad size. examples: 4096, 4k, 100M, 1.5G\";\n  char mult_char;\n  int mult=1;\n  double val;\n\n  if (len < 1) fatal(errstr);\n\n  mult_char = tolower(inp[len-1]);\n\n  if (isalpha(mult_char)) {\n    switch(mult_char) {\n      case 'k': mult = 1024; break;\n      case 'm': mult = 1024*1024; break;\n      case 'g': mult = 1024*1024*1024; break;\n      default: fatal(\"unknown size multiplier: %c\", mult_char);\n    }\n    inp[len-1] = '\\0';\n  }\n\n  val = strtod(inp, &tp);\n\n  if (val < 0 || val == HUGE_VAL || *tp != '\\0') fatal(errstr);\n\n  val *= mult;\n\n  if (val > INT64_MAX) fatal(errstr);\n\n  return (int64_t) val;\n}\n\nint64_t bytes2pages(int64_t bytes) {\n  return (bytes+pagesize-1) / pagesize;\n}\n\nvoid parse_range(char *inp) {\n  char *token;\n  int64_t upper_range=0;\n  int64_t lower_range=0;\n\n  token = strsep(&inp,\"-\");\n\n  if (inp == NULL)\n    upper_range = parse_size(token); // single value provided\n  else {\n    if (*token != '\\0')\n      lower_range = parse_size(token); // value before hyphen\n\n    token = strsep(&inp,\"-\");\n    if (*token != '\\0')\n      upper_range = parse_size(token); // value after hyphen\n\n    if ((token = strsep(&inp,\"-\")) != NULL) fatal(\"malformed range: multiple hyphens\");\n  }\n\n  // offset must be multiple of pagesize\n  offset = (lower_range / pagesize) * pagesize;\n\n  if (upper_range) {\n    if (upper_range <= offset) fatal(\"range limits out of order\");\n\n    max_len = upper_range - offset;\n  }\n}\n\n\nvoid parse_ignore_item(char *inp) {\n  if (inp == NULL) {\n    return;\n  }\n\n  if (strlen(inp) > MAX_FILENAME_LENGTH) {\n    fatal(\"too long pattern provided to -i: %s\", inp);\n    return;\n  }\n\n  if (number_of_ignores >= MAX_NUMBER_OF_IGNORES) {\n    fatal(\"too many patterns passed to -i. Max is %d\", MAX_NUMBER_OF_IGNORES);\n    return;\n  }\n\n  ignore_list[number_of_ignores] = strdup(inp);\n  number_of_ignores++;\n}\n\nvoid parse_filename_filter_item(char *inp) {\n  if (inp == NULL) {\n    return;\n  }\n\n  if (strlen(inp) > MAX_FILENAME_LENGTH) {\n    fatal(\"too long pattern provided to -I: %s\", inp);\n    return;\n  }\n\n  if (number_of_filename_filters >= MAX_NUMBER_OF_FILENAME_FILTERS) {\n    fatal(\"too many patterns passed to -I. Max is %d\", MAX_NUMBER_OF_FILENAME_FILTERS);\n    return;\n  }\n\n  filename_filter_list[number_of_filename_filters] = strdup(inp);\n  number_of_filename_filters++;\n}\n\n\nint aligned_p(void *p) {\n  return 0 == ((long)p & (pagesize-1));\n}\n\nint is_mincore_page_resident(char p) {\n  return p & 0x1;\n}\n\n\nvoid increment_nofile_rlimit() {\n  struct rlimit r;\n\n  if (getrlimit(RLIMIT_NOFILE, &r))\n    fatal(\"increment_nofile_rlimit: getrlimit (%s)\", strerror(errno));\n\n  r.rlim_cur = r.rlim_max + 1;\n  r.rlim_max = r.rlim_max + 1;\n\n  if (setrlimit(RLIMIT_NOFILE, &r)) {\n    if (errno == EPERM) {\n      if (getuid() == 0 || geteuid() == 0) fatal(\"system open file limit reached\");\n      fatal(\"open file limit reached and unable to increase limit. retry as root\");\n    }\n    fatal(\"increment_nofile_rlimit: setrlimit (%s)\", strerror(errno));\n  }\n}\n\n\n\ndouble gettimeofday_as_double() {\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n\n  return tv.tv_sec + (tv.tv_usec/1000000.0);\n}\n\n\n\nvoid print_page_residency_chart(FILE *out, char *mincore_array, int64_t pages_in_file) {\n  int64_t pages_in_core=0;\n  int64_t pages_per_char;\n  int64_t i,j=0,curr=0;\n\n  if (pages_in_file <= RESIDENCY_CHART_WIDTH) pages_per_char = 1;\n  else pages_per_char = (pages_in_file / RESIDENCY_CHART_WIDTH) + 1;\n\n  fprintf(out, \"\\r[\");\n\n  for (i=0; i<pages_in_file; i++) {\n    if (is_mincore_page_resident(mincore_array[i])) {\n      curr++;\n      pages_in_core++;\n    }\n    j++;\n    if (j == pages_per_char) {\n      if (curr == pages_per_char) fprintf(out, \"O\");\n      else if (curr == 0) fprintf(out, \" \");\n      else fprintf(out, \"o\");\n\n      j = curr = 0;\n    }\n  }\n\n  if (j) {\n    if (curr == j) fprintf(out, \"O\");\n    else if (curr == 0) fprintf(out, \" \");\n    else fprintf(out, \"o\");\n  }\n\n  fprintf(out, \"] %\" PRId64 \"/%\" PRId64, pages_in_core, pages_in_file);\n\n  fflush(out);\n}\n\n\n#ifdef __linux__\n// check if mincore will report correctly, due side-channel vulnerabilities\n// from 5.2+ it only reports if process has write permission to the file\n// https://lwn.net/Articles/778437/\nstatic int can_do_mincore(struct stat *st) {\n\n  struct utsname utsinfo;\n  if (uname(&utsinfo) == 0) {\n    unsigned long ver[16];\n    int i=0;\n    char *p = utsinfo.release;\n    while (*p) {\n      if (isdigit(*p)) {\n          ver[i] = strtol(p, &p, 10);\n          i++;\n      } else {\n          p++;\n      }\n    }\n    // kernal < 5.2\n    if (ver[0]<5||ver[1]<2)\n      return 1;\n  }\n\n  uid_t uid = getuid();\n  return st->st_uid == uid ||\n         (st->st_gid == getgid() && (st->st_mode&S_IWGRP)) ||\n         (st->st_mode&S_IWOTH) ||\n         uid == 0;\n}\n#endif\n\n\nvoid vmtouch_file(char *path) {\n  int fd = -1;\n  void *mem = NULL;\n  struct stat sb;\n  int64_t len_of_file=0;\n  int64_t len_of_range=0;\n  int64_t pages_in_range;\n  int i;\n  int res;\n  int open_flags;\n\n  retry_open:\n\n  open_flags = O_RDONLY;\n\n#if defined(O_NOATIME)\n  open_flags |= O_NOATIME;\n#endif\n\n  fd = open(path, open_flags, 0);\n\n#if defined(O_NOATIME)\n  if (fd == -1 && errno == EPERM) {\n    open_flags &= ~O_NOATIME;\n    fd = open(path, open_flags, 0);\n  }\n#endif\n\n  if (fd == -1) {\n    if (errno == ENFILE || errno == EMFILE) {\n      increment_nofile_rlimit();\n      goto retry_open;\n    }\n\n    warning(\"unable to open %s (%s), skipping\", path, strerror(errno));\n    goto bail;\n  }\n\n  res = fstat(fd, &sb);\n\n  if (res) {\n    warning(\"unable to fstat %s (%s), skipping\", path, strerror(errno));\n    goto bail;\n  }\n\n  if (S_ISBLK(sb.st_mode)) {\n#if defined(__linux__)\n    if (ioctl(fd, BLKGETSIZE64, &len_of_file)) {\n      warning(\"unable to ioctl %s (%s), skipping\", path, strerror(errno));\n      goto bail;\n    }\n#else\n    fatal(\"discovering size of block devices not (yet?) supported on this platform\");\n#endif\n  } else {\n    len_of_file = sb.st_size;\n  }\n\n\n  if (len_of_file == 0) {\n    goto bail;\n  }\n\n  if (len_of_file > o_max_file_size) {\n    warning(\"file %s too large, skipping\", path);\n    goto bail;\n  }\n\n\n  if (max_len > 0 && (offset + max_len) < len_of_file) {\n    len_of_range = max_len;\n  } else if (offset >= len_of_file) {\n    warning(\"file %s smaller than offset, skipping\", path);\n    goto bail;\n  } else {\n    len_of_range = len_of_file - offset;\n  }\n\n  mem = mmap(NULL, len_of_range, PROT_READ, MAP_SHARED, fd, offset);\n\n  if (mem == MAP_FAILED) {\n    warning(\"unable to mmap file %s (%s), skipping\", path, strerror(errno));\n    goto bail;\n  }\n\n  if (!aligned_p(mem)) fatal(\"mmap(%s) wasn't page aligned\", path);\n\n  pages_in_range = bytes2pages(len_of_range);\n\n  total_pages += pages_in_range;\n\n  if (o_evict) {\n    if (o_verbose) printf(\"Evicting %s\\n\", path);\n\n#if defined(__linux__) || defined(__hpux)\n    if (posix_fadvise(fd, offset, len_of_range, POSIX_FADV_DONTNEED))\n      warning(\"unable to posix_fadvise file %s (%s)\", path, strerror(errno));\n#elif defined(__FreeBSD__) || defined(__sun__) || defined(__APPLE__)\n    if (msync(mem, len_of_range, MS_INVALIDATE))\n      warning(\"unable to msync invalidate file %s (%s)\", path, strerror(errno));\n#else\n    fatal(\"cache eviction not (yet?) supported on this platform\");\n#endif\n  } else {\n    double last_chart_print_time=0.0, temp_time;\n    char *mincore_array = malloc(pages_in_range);\n    if (mincore_array == NULL) fatal(\"Failed to allocate memory for mincore array (%s)\", strerror(errno));\n\n    // 3rd arg to mincore is char* on BSD and unsigned char* on linux\n    if (mincore(mem, len_of_range, (void*)mincore_array)) fatal(\"mincore %s (%s)\", path, strerror(errno));\n    for (i=0; i<pages_in_range; i++) {\n      if (is_mincore_page_resident(mincore_array[i])) {\n        total_pages_in_core++;\n      }\n    }\n\n    if (o_verbose) {\n      printf(\"%s\\n\", path);\n#ifdef __linux__\n      if (!can_do_mincore(&sb)) {\n        warning(\"Process does not have write permission, residency chart will not be accurate\");\n      }\n#endif\n      last_chart_print_time = gettimeofday_as_double();\n      print_page_residency_chart(stdout, mincore_array, pages_in_range);\n    }\n\n    if (o_touch) {\n      for (i=0; i<pages_in_range; i++) {\n        junk_counter += ((char*)mem)[i*pagesize];\n        mincore_array[i] = 1;\n\n        if (o_verbose) {\n          temp_time = gettimeofday_as_double();\n\n          if (temp_time > (last_chart_print_time+CHART_UPDATE_INTERVAL)) {\n            last_chart_print_time = temp_time;\n            print_page_residency_chart(stdout, mincore_array, pages_in_range);\n          }\n        }\n      }\n    }\n\n    if (o_verbose) {\n      print_page_residency_chart(stdout, mincore_array, pages_in_range);\n      printf(\"\\n\");\n    }\n\n    free(mincore_array);\n  }\n\n  if (o_lock) {\n    if (mlock(mem, len_of_range))\n      fatal(\"mlock: %s (%s)\", path, strerror(errno));\n  }\n\n  bail:\n\n  if (!o_lock && !o_lockall && mem) {\n    if (munmap(mem, len_of_range)) warning(\"unable to munmap file %s (%s)\", path, strerror(errno));\n  }\n\n  if (fd != -1) {\n    close(fd);\n  }\n}\n\n\n// compare device and inode information\nint compare_func(const void *p1, const void *p2)\n{\n  const struct dev_and_inode *kp1 = p1, *kp2 = p2;\n  int cmp1;\n  cmp1 = (kp1->ino > kp2->ino) - (kp1->ino < kp2->ino);\n  if (cmp1 != 0)\n    return cmp1;\n  return (kp1->dev > kp2->dev) - (kp1->dev < kp2->dev);\n}\n\n// add device and inode information to the tree of known inodes\nstatic inline void add_object (struct stat *st)\n{\n  struct dev_and_inode *newp = malloc (sizeof (struct dev_and_inode));\n  if (newp == NULL) {\n    fatal(\"malloc: out of memory\");\n  }\n  newp->dev = st->st_dev;\n  newp->ino = st->st_ino;\n  if (tsearch(newp, &seen_inodes, compare_func) == NULL) {\n    fatal(\"tsearch: out of memory\");\n  }\n}\n\n\nint is_ignored(const char* path) {\n  char *path_copy;\n  int match, i;\n\n  if (!number_of_ignores) return 0;\n\n  path_copy = strdup(path);\n  match = 0;\n\n  char *filename = basename(path_copy);\n\n  for (i = 0; i < number_of_ignores; i++) {\n    if (fnmatch(ignore_list[i], filename, 0) == 0) {\n      match = 1;\n      break;\n    }\n  }\n\n  free(path_copy);\n  return match;\n}\n\n\nint is_filename_filtered(const char* path) {\n  char *path_copy;\n  int match, i;\n\n  if (!number_of_filename_filters) return 1;\n\n  path_copy = strdup(path);\n  match = 0;\n\n  char *filename = basename(path_copy);\n\n  for (i = 0; i < number_of_filename_filters; i++) {\n    if (fnmatch(filename_filter_list[i], filename, 0) == 0) {\n      match = 1;\n      break;\n    }\n  }\n\n  free(path_copy);\n  return match;\n}\n\n\n\n// return true only if the device and inode information has not been added before\nstatic inline int find_object(struct stat *st)\n{\n  struct dev_and_inode obj;\n  void *res;\n  obj.dev = st->st_dev;\n  obj.ino = st->st_ino;\n  res = (void *) tfind(&obj, &seen_inodes, compare_func);\n  return res != (void *) NULL;\n}\n\nvoid vmtouch_crawl(char *path) {\n  struct stat sb;\n  DIR *dirp;\n  struct dirent *de;\n  char npath[PATH_MAX];\n  int res;\n  int tp_path_len = strlen(path);\n  int i;\n\n  if (path[tp_path_len-1] == '/' && tp_path_len > 1) path[tp_path_len-1] = '\\0'; // prevent ugly double slashes when printing path names\n\n  if (is_ignored(path)) {\n    return;\n  }\n\n  res = o_followsymlinks ? stat(path, &sb) : lstat(path, &sb);\n\n  if (res) {\n    warning(\"unable to stat %s (%s)\", path, strerror(errno));\n    return;\n  } else {\n    if (S_ISLNK(sb.st_mode)) {\n      warning(\"not following symbolic link %s\", path);\n      return;\n    }\n\n    if (o_singlefilesystem) {\n      if (!orig_device_inited) {\n        orig_device = sb.st_dev;\n        orig_device_inited = 1;\n      } else {\n        if (sb.st_dev != orig_device) {\n          warning(\"not recursing into separate filesystem %s\", path);\n          return;\n        }\n      }\n    }\n\n    if (!o_ignorehardlinkeduplictes && sb.st_nlink > 1) {\n      /*\n       * For files with more than one link to it, ignore it if we already know\n       * inode.  Without this check files copied as hardlinks (cp -al) are\n       * counted twice (which may lead to a cache usage of more than 100% of\n       * RAM).\n       */\n      if (find_object(&sb)) {\n        // we already saw the device and inode referenced by this file\n        return;\n      } else {\n        add_object(&sb);\n      }\n    }\n\n    if (S_ISDIR(sb.st_mode)) {\n      for (i=0; i<curr_crawl_depth; i++) {\n        if (crawl_inodes[i] == sb.st_ino) {\n          warning(\"symbolic link loop detected: %s\", path);\n          return;\n        }\n      }\n\n      if (curr_crawl_depth == MAX_CRAWL_DEPTH)\n        fatal(\"maximum directory crawl depth reached: %s\", path);\n\n      total_dirs++;\n\n      crawl_inodes[curr_crawl_depth] = sb.st_ino;\n\n      retry_opendir:\n\n      dirp = opendir(path);\n\n      if (dirp == NULL) {\n        if (errno == ENFILE || errno == EMFILE) {\n          increment_nofile_rlimit();\n          goto retry_opendir;\n        }\n\n        warning(\"unable to opendir %s (%s), skipping\", path, strerror(errno));\n        return;\n      }\n\n      while((de = readdir(dirp)) != NULL) {\n        if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0) continue;\n\n        if (snprintf(npath, sizeof(npath), \"%s/%s\", path, de->d_name) >= sizeof(npath)) {\n          warning(\"path too long %s\", path);\n          goto bail;\n        }\n\n        curr_crawl_depth++;\n        vmtouch_crawl(npath);\n        curr_crawl_depth--;\n      }\n\n      bail:\n\n      if (closedir(dirp)) {\n        warning(\"unable to closedir %s (%s)\", path, strerror(errno));\n        return;\n      }\n    } else if (S_ISLNK(sb.st_mode)) {\n      warning(\"not following symbolic link %s\", path);\n      return;\n    } else if (S_ISREG(sb.st_mode) || S_ISBLK(sb.st_mode)) {\n      if (is_filename_filtered(path)) {\n        total_files++;\n        vmtouch_file(path);\n      }\n    } else {\n      warning(\"skipping non-regular file: %s\", path);\n    }\n  }\n}\n\nstatic void vmtouch_batch_crawl(const char *path) {\n  FILE *f;\n  char *line = NULL;\n  size_t len = 0;\n  ssize_t read;\n  int delim = o_0_delim ? '\\0' : '\\n';\n\n  if (!strcmp(path, \"-\")) {\n    f = stdin;\n  } else {\n    f = fopen(path, \"r\");\n    if (!f) {\n      warning(\"unable to open %s (%s), skipping\", path, strerror(errno));\n      return;\n    }\n  }\n\n  while ((read = getdelim(&line, &len, delim, f)) != -1) {\n    // strip the newline character\n    line[read-1] = '\\0';\n    vmtouch_crawl(line);\n  }\n\n  free(line);\n  fclose(f);\n}\n\nstatic void remove_pidfile() {\n  int res = 0;\n\n  res = unlink(o_pidfile);\n  if (res < 0 && errno != ENOENT) {\n    warning(\"unable to remove pidfile %s (%s)\", o_pidfile, strerror(errno));\n  }\n}\n\nstatic void write_pidfile() {\n  FILE *f = NULL;\n  size_t wrote = 0;\n\n  f = fopen(o_pidfile, \"w\");\n  if (!f) {\n    warning(\"unable to open pidfile %s (%s), skipping\", o_pidfile, strerror(errno));\n    return;\n  }\n\n  wrote = fprintf(f, \"%d\\n\", getpid());\n\n  fclose(f);\n\n  if (wrote < 0) {\n    warning(\"unable to write to pidfile %s (%s), deleting it\", o_pidfile, strerror(errno));\n    remove_pidfile();\n  }\n}\n\nstatic void signal_handler_clear_pidfile(int signal_num) {\n  remove_pidfile();\n}\n\nstatic void register_signals_for_pidfile() {\n  struct sigaction sa = {0};\n  sa.sa_handler = signal_handler_clear_pidfile;\n  if (sigaction(SIGINT, &sa, NULL) < 0 ||\n      sigaction(SIGTERM, &sa, NULL) < 0 ||\n      sigaction(SIGQUIT, &sa, NULL) < 0) {\n    warning(\"unable to register signals for pidfile (%s), skipping\", strerror(errno));\n  }\n}\n\n\n\n\n\n\nint main(int argc, char **argv) {\n  int ch, i;\n  char *prog = argv[0];\n  struct timeval start_time;\n  struct timeval end_time;\n\n  if (pipe(exit_pipe))\n    fatal(\"pipe: %s\", strerror(errno));\n\n  pagesize = sysconf(_SC_PAGESIZE);\n\n  while((ch = getopt(argc, argv, \"tevqlLdfFh0i:I:p:b:m:P:wo:\")) != -1) {\n    switch(ch) {\n      case '?': usage(); break;\n      case 't': o_touch = 1; break;\n      case 'e': o_evict = 1; break;\n      case 'q': o_quiet = 1; break;\n      case 'v': o_verbose++; break;\n      case 'l': o_lock = 1;\n                o_touch = 1; break;\n      case 'L': o_lockall = 1;\n                o_touch = 1; break;\n      case 'd': o_daemon = 1; break;\n      case 'f': o_followsymlinks = 1; break;\n      case 'F': o_singlefilesystem = 1; break;\n      case 'h': o_ignorehardlinkeduplictes = 1; break;\n      case 'p': parse_range(optarg); break;\n      case 'i': parse_ignore_item(optarg); break;\n      case 'I': parse_filename_filter_item(optarg); break;\n      case 'm': {\n        int64_t val = parse_size(optarg);\n        o_max_file_size = (size_t) val;\n        if (val != (int64_t) o_max_file_size) fatal(\"value for -m too big to fit in a size_t\");\n        break;\n      }\n      case 'w': o_wait = 1; break;\n      case 'b': o_batch = optarg; break;\n      case '0': o_0_delim = 1; break;\n      case 'P': o_pidfile = optarg; break;\n      case 'o': o_output = optarg; break;\n    }\n  }\n\n  argc -= optind;\n  argv += optind;\n\n  if (o_touch) {\n    if (o_evict) fatal(\"invalid option combination: -t and -e\");\n  }\n\n  if (o_evict) {\n    if (o_lock) fatal(\"invalid option combination: -e and -l\");\n  }\n\n  if (o_lock && o_lockall) fatal(\"invalid option combination: -l and -L\");\n\n  if (o_daemon) {\n    if (!(o_lock || o_lockall)) fatal(\"daemon mode must be combined with -l or -L\");\n    if (!o_wait) {\n      o_quiet = 1;\n      o_verbose = 0;\n   }\n  }\n\n  if (o_wait && !o_daemon) fatal(\"wait mode must be combined with -d\");\n\n  if (o_quiet && o_verbose) fatal(\"invalid option combination: -q and -v\");\n\n  if (o_pidfile && (!o_lock && !o_lockall)) fatal(\"pidfile can only be created when -l or -L is specified\");\n\n  if (!argc && !o_batch) {\n    printf(\"%s: no files or directories specified\\n\", prog);\n    usage();\n  }\n\n  // Must be done now because mlock() not inherited across fork()\n  if (o_daemon) go_daemon();\n\n  gettimeofday(&start_time, NULL);\n\n  if (o_batch) {\n      vmtouch_batch_crawl(o_batch);\n  }\n\n  for (i=0; i<argc; i++) vmtouch_crawl(argv[i]);\n\n  gettimeofday(&end_time, NULL);\n\n  int64_t total_pages_in_core_size = total_pages_in_core * pagesize;\n  int64_t total_pages_size         = total_pages * pagesize;\n  double  total_pages_in_core_perc = 100.0*total_pages_in_core/total_pages;\n  double  elapsed                  = (end_time.tv_sec - start_time.tv_sec) + (double)(end_time.tv_usec - start_time.tv_usec)/1000000.0;\n\n  if (o_lock || o_lockall) {\n    if (o_lockall) {\n      if (mlockall(MCL_CURRENT))\n        fatal(\"unable to mlockall (%s)\", strerror(errno));\n    }\n\n    if (o_pidfile) {\n      register_signals_for_pidfile();\n      write_pidfile();\n    }\n\n    if (!o_quiet) printf(\"LOCKED %\" PRId64 \" pages (%s)\\n\", total_pages, pretty_print_size(total_pages_size));\n\n    if (o_wait) reopen_all();\n\n    send_exit_signal(0);\n    select(0, NULL, NULL, NULL, NULL);\n    exit(0);\n  }\n\n  if (!o_quiet) {\n    if (o_output == NULL) {\n      if (o_verbose) printf(\"\\n\");\n      printf(\"           Files: %\" PRId64 \"\\n\", total_files);\n      printf(\"     Directories: %\" PRId64 \"\\n\", total_dirs);\n      if (o_touch)\n        printf(\"   Touched Pages: %\" PRId64 \" (%s)\\n\", total_pages, pretty_print_size(total_pages_size));\n      else if (o_evict)\n        printf(\"   Evicted Pages: %\" PRId64 \" (%s)\\n\", total_pages, pretty_print_size(total_pages_size));\n      else {\n        printf(\"  Resident Pages: %\" PRId64 \"/%\" PRId64 \"  \", total_pages_in_core, total_pages);\n        printf(\"%s/\", pretty_print_size(total_pages_in_core_size));\n        printf(\"%s  \", pretty_print_size(total_pages_size));\n        if (total_pages)\n          printf(\"%.3g%%\", total_pages_in_core_perc);\n        printf(\"\\n\");\n      }\n      printf(\"         Elapsed: %.5g seconds\\n\", elapsed);\n    } else if (strncmp(o_output, \"kv\", 2) == 0) {\n      char *desc = o_touch ? \"Touched\" :\n                   o_evict ? \"Evicted\" :\n                             \"Resident\";\n      printf(\"Files=%\" PRId64 \" Directories=%\" PRId64 \" %sPages=%\" PRId64 \" TotalPages=%\" PRId64 \" %sSize=%\" PRId64 \" TotalSize=%\" PRId64 \" %sPercent=%.3g Elapsed=%.5g\\n\", \n        total_files, total_dirs, desc, total_pages_in_core, total_pages, desc, total_pages_in_core_size, total_pages_size, desc, total_pages_in_core_perc, elapsed);\n    }\n  }\n\n  return 0;\n}\n"
        },
        {
          "name": "vmtouch.pod",
          "type": "blob",
          "size": 7.9306640625,
          "content": "=pod\n\n=head1 NAME\n\nvmtouch - the Virtual Memory Toucher\n\n=head1 SYNOPSIS\n\n    vmtouch [OPTIONS] ... FILES OR DIRECTORIES ...\n\n=head1 DESCRIPTION\n\nPortable file system cache diagnostics and control.\n\nvmtouch opens every file provided on the command line and maps it into virtual memory with C<mmap(2)>. The mappings are opened read-only. It recursively crawls any directories and does the same to all files it finds within them.\n\nWith no options, vmtouch will not read from (touch) any memory pages.  It will only use C<mincore(2)> to determine how many pages of each file are actually resident in memory. Before exiting, it will print a summary of the total pages encountered and how many were resident.\n\n=over\n\n=item -t\n\nTouch virtual memory pages. Reads a byte from each page of the file. If the page is not resident in memory, a page fault will be generated and the page will be read from disk into the file system's memory cache.\n\nNote: Although each page is guaranteed to have been brought into memory, the page might be evicted from memory by the time the vmtouch command completes.\n\n=item -e\n\nEvict the mapped pages from the file system cache. They will need to be read in from disk the next time they are accessed. This is the inverse of C<-t>.\n\nNote: Even if the eviction is successful, pages may be paged back into memory by the time the vmtouch command completes.\n\nNote: This option is not portable to all systems. See L<PORTABILITY> below.\n\n=item -l\n\nLock pages into physical memory. This option works the same as C<-t> except it calls C<mlock(2)> on all the memory mappings and doesn't close the descriptors when finished. At the end of the crawl, if successful, vmtouch will block indefinitely. The files will be locked in physical memory until the vmtouch process is killed.\n\nNote: While the vmtouch process is holding memory locks, any processes that access the locked pages will not cause non-resident page faults or address-translation faults although they may still cause TLB misses.\n\nNote: Because vmtouch holds file descriptors open it may reach the C<RLIMIT_NOFILE> process file descriptor limit. In this case it will try to increase the descriptor limit which will only work if the process is run with root privileges. Similarly, root privileges are required to exceed the C<RLIMIT_MEMLOCK> limit. Even with root privileges, C<-l> is limited by both the system file descriptor limit and the system limit on \"wired memory\".\n\n=item -L\n\nThis option is the same as C<-l> except that it uses C<mlockall(2)> at the end of the crawl rather than individually C<mlock(2)>ing each file. Because of this, other unrelated pages belonging to the vmtouch process will also be locked in memory.\n\n=item -d\n\nDaemon mode. After performing the crawl, disassociate from the terminal and run in the background as a daemon. This option can only be used with the C<-l> or C<-L> locking modes.\n\n=item -m <max file size>\n\nMaximum file size to map into virtual memory. Files that are larger than this will be skipped. Examples: 4096, 4k, 100M, 1.5G. The default is 500M.\n\n=item -p <size range> or <size>\n\nPage mode. Maps the portion of the file specified by a range instead of the entire file. Size format same as for C<-m>. Omitted range start (end) value means start (end) of file. Single <size> value is equivalent to -<size>, i.e. map the first <size> bytes. Examples: 4k-50k, 100M-2G, -5M, -.\n\n=item -f\n\nFollow symbolic links. With this option, vmtouch will descend into symbolic links that point to directories and will touch regular files pointed to by symbolic links. Symbolic link loops are detected and issue warnings.\n\n=item -F\n\nDuring the crawl, don't recurse into directories that have separate filesystems mounted on them. This is handy to avoid accidentally touching other filesystems that have been mounted underneath your target directory.\n\n=item -i <pattern>\n\nCan be specified multiple times. Ignores files and directories that match any of the provided patterns. The pattern may include wildcards (remember to escape them from your shell). This option stops the crawl, so can be used to ignore directories and all their contents. Example: vmtouch -i .git -i '*.bak' .\n\n=item -I <pattern>\n\nCan be specified multiple times. Only processes filenames matching one or more of the provided patterns. The pattern may include wildcards (remember to escape them from your shell). Example: vmtouch -I '*.c' -I '*.h' .\n\n=item -b <list file>\n\nThe list of files/directories to crawl is read from the specified list file, which by default should be a newline-separated list, for example the output from the find command. If the list file is \"-\" then this list is read from standard input. Example: find /usr/lib -type f | vmtouch -b -\n\n=item -0\n\nIf -b (\"batch mode\") is in effect, assume the list file is delimited with NUL bytes instead of newlines, for example the output from find -print0. This is useful in case your filenames contain newline characters themselves.\n\n=item -P <pidfile>\n\nCreate a PID file. This option can only be provided in combination with -l or -L. The PID file will be automatically deleted when vmtouch gets a termination signal (SIGINT, SIGTERM, SIGQUIT).\n\n=item -v\n\nVerbose mode. While crawling, print out every file being processed along with its total number of pages and the number of its pages that are currently resident in memory to standard output.\n\n=item -q\n\nQuiet mode. Suppress the end of crawl summary and all warnings that are normally printed to standard error. On success print nothing. Fatal errors print a single error message line to standard error.\n\n=item -h\n\nNormally, if multiple files both point to the same inode then vmtouch will ignore all but the first it finds so as to avoid double-counting their pages. This option overrides this behaviour and double-counts anyways.\n\n=back\n\n\n=head1 PORTABILITY\n\nThe page residency summaries depend on C<mincore(2)> which first appeared in 4.4BSD but is not present on all unix systems.\n\nThe C<-l> and C<-L> locking options depends on C<mlock(2)> or C<mlockall(2)>, both of which are specified by POSIX.1b-1993, Real-Time Extensions.\n\nThe C<-e> page eviction option is the least portable. On Linux it uses C<posix_fadvise(2)> with C<POSIX_FADV_DONTNEED> advice to inform the kernel that the file should be evicted from the file system cache. C<posix_fadvise(2)> is specified by POSIX.1-2003 TC1. On FreeBSD, the pages are invalidated with C<msync(2)>'s C<MS_INVALIDATE> flag. C<msync(2)> is specified by POSIX.1b-1993, Real-Time Extensions, although this call is not required to remove pages from the file system cache. Some systems like OpenBSD 4.3 don't have C<posix_fadvise(2)>, don't evict the pages on an C<msync(2)>/C<MS_INVALIDATE>, and don't evict the pages with C<madvise(2)>/C<MADV_DONTNEED> so C<-e> isn't supported on those systems yet. Using C<-e> on systems that don't yet support it is a fatal error.\n\n=head1 SUPPORTED SYSTEMS\n\nAll vmtouch features have been confirmed to work on the following systems:\n\n=over\n\n=item Linux 2.6+\n\n=item FreeBSD 4.X\n\n=item FreeBSD 7.X\n\n=item Solaris 10\n\n=item OS X 10.x\n\n=item HP-UX 11.31+patches (see below)\n\n=back\n\nSystems that support everything except eviction:\n\n=over\n\n=item OpenBSD 4.3\n\n=back\n\nCPUs that have been tested:\n\n=over\n\n=item x86\n\n=item amd64 (x86-64)\n\n=item SPARC\n\n=item ARMv7\n\n=back\n\nWe would like to support as many systems as possible so please send us any success reports, failure reports or patches. Thanks!\n\n=head1 SYSTEM NOTES\n\nShane Seymour did the HP-UX port and says that either 32-bit or 64-bit binaries can be compiled (just use C<+DD64> for 64-bit). However, C<mincore(2)> was added to HP-UX 11.31 via patches and at least the following patches need to be installed: PHKL_38651, PHKL_38708, PHKL_38686, PHKL_38688, and PHCO_38658 (or patches that supersede those ones).\n\n=head1 SEE ALSO\n\nNot all the following manual pages may exist in every unix dialect to which vmtouch has been ported.\n\nvmstat(8), touch(1), mmap(2), mincore(2), mlock(2), mlockall(2), msync(2), madvise(2), posix_fadvise(2)\n\n=head1 AUTHOR\n\nWritten by Doug Hoyte <doug@hcsw.org>\n\n=cut\n"
        }
      ]
    }
  ]
}