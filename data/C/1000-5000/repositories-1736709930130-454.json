{
  "metadata": {
    "timestamp": 1736709930130,
    "page": 454,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "linux-can/can-utils",
      "stars": 2465,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.2353515625,
          "content": "# SPDX-License-Identifier: GPL-2.0\n#\n# clang-format configuration file. Intended for clang-format >= 11.\n#\n# For more information, see:\n#\n#   Documentation/process/clang-format.rst\n#   https://clang.llvm.org/docs/ClangFormat.html\n#   https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n#\n---\nAccessModifierOffset: -4\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Left\nAlignOperands: true\nAlignTrailingComments: false\nAllowAllParametersOfDeclarationOnNextLine: false\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: None\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: false\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:\n  AfterClass: false\n  AfterControlStatement: false\n  AfterEnum: false\n  AfterFunction: true\n  AfterNamespace: true\n  AfterObjCDeclaration: false\n  AfterStruct: false\n  AfterUnion: false\n  AfterExternBlock: false\n  BeforeCatch: false\n  BeforeElse: false\n  IndentBraces: false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Custom\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: false\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeComma\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: false\nColumnLimit: 200\nCommentPragmas: \"^ IWYU pragma:\"\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 8\nContinuationIndentWidth: 8\nCpp11BracedListStyle: false\nDerivePointerAlignment: false\nDisableFormat: false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: false\n\nIncludeBlocks: Preserve\nIncludeCategories:\n  - Regex: \".*\"\n    Priority: 1\nIncludeIsMainRegex: \"(Test)?$\"\nIndentCaseLabels: false\nIndentGotoLabels: false\nIndentPPDirectives: None\nIndentWidth: 8\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nMacroBlockBegin: \"\"\nMacroBlockEnd: \"\"\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBinPackProtocolList: Auto\nObjCBlockIndentWidth: 8\nObjCSpaceAfterProperty: true\nObjCSpaceBeforeProtocolList: true\n\n# Taken from git's rules\nPenaltyBreakAssignment: 10\nPenaltyBreakBeforeFirstCallParameter: 30\nPenaltyBreakComment: 10\nPenaltyBreakFirstLessLess: 0\nPenaltyBreakString: 10\nPenaltyExcessCharacter: 100\nPenaltyReturnTypeOnItsOwnLine: 60\n\nPointerAlignment: Right\nReflowComments: false\nSortIncludes: false\nSortUsingDeclarations: false\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatementsExceptForEachMacros\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles: false\nSpacesInContainerLiterals: false\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard: Cpp03\nTabWidth: 8\nUseTab: Always\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2294921875,
          "content": "root = true\n\n[*]\nend_of_line = lf\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[{CMakeLists.txt,*.cmake}]\nindent_style = space\nindent_size = 2\ntab_width = 2\n\n[{*.c,*.h}]\nindent_style = tab\nindent_size = 8\ntab_width = 8\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4560546875,
          "content": "*~\n*.o\n.ccls-cache\ncompile_commands.json\ntags\n/build\n\n/asc2log\n/bcmserver\n/can-calc-bit-timing\n/canbusload\n/candump\n/canfdtest\n/cangen\n/cangw\n/canlogserver\n/canplayer\n/cansend\n/cansequence\n/cansniffer\n/isobusfs-cli\n/isobusfs-srv\n/isotpdump\n/isotpperf\n/isotprecv\n/isotpsend\n/isotpserver\n/isotpsniffer\n/isotptun\n/j1939acd\n/j1939cat\n/j1939spy\n/j1939sr\n/j1939-timedate-cli\n/j1939-timedate-srv\n/log2asc\n/log2long\n/mcp251xfd-dump\n/slcan_attach\n/slcand\n/slcanpty\n/testj1939\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 4.388671875,
          "content": "cmake_minimum_required(VERSION 3.5)\n\nproject(can-utils LANGUAGES C)\n\nmessage(STATUS \"CMake version: ${CMAKE_VERSION}\")\n\ninclude (CheckFunctionExists)\ninclude (CheckSymbolExists)\ninclude (GNUInstallDirs)\n\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE Release)\nendif()\n\n# Add an option to enable treating warnings as errors\noption(ENABLE_WERROR \"Treat all compiler warnings as errors\" OFF)\n\nif(ENABLE_WERROR)\n  add_compile_options(-Werror)\nendif()\n\nadd_definitions(-D_GNU_SOURCE)\n\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wall -Wno-parentheses -Wsign-compare\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fno-strict-aliasing\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DSO_RXQ_OVFL=40\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DPF_CAN=29\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DAF_CAN=PF_CAN\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DN_SLCAN=17\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DSCM_TIMESTAMPING_OPT_STATS=54\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DCLOCK_TAI=11\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DSO_TXTIME=61\")\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DSCM_TXTIME=SO_TXTIME\")\n\ninclude_directories (.)\ninclude_directories (./include)\n\ncheck_function_exists(fork HAVE_FORK)\n\nset(PROGRAMS_CANLIB\n  asc2log\n  canbusload\n  candump\n  cangen\n  canplayer\n  cansend\n  cansequence\n  log2asc\n  log2long\n  slcanpty\n)\n\nif(HAVE_FORK)\n  list(APPEND PROGRAMS_CANLIB canlogserver)\nendif()\n\nset(PROGRAMS_J1939\n  j1939acd\n  j1939cat\n  j1939spy\n  j1939sr\n  testj1939\n)\n\nset(PROGRAMS_J1939_TIMEDATE\n  j1939-timedate-srv\n  j1939-timedate-cli\n)\n\nset(PROGRAMS_ISOBUSFS\n  isobusfs-srv\n  isobusfs-cli\n)\n\nset(PROGRAMS\n  ${PROGRAMS_CANLIB}\n  canfdtest\n  cangw\n  cansniffer\n  isotpdump\n  isotpperf\n  isotprecv\n  isotpsend\n  isotpsniffer\n  isotptun\n  slcan_attach\n  slcand\n)\n\nif(HAVE_FORK)\n  list(APPEND PROGRAMS bcmserver)\n  list(APPEND PROGRAMS isotpserver)\nendif()\n\nadd_executable(can-calc-bit-timing\n  calc-bit-timing/can-calc-bit-timing.c\n)\n\nadd_executable(mcp251xfd-dump\n  mcp251xfd/mcp251xfd-dev-coredump.c\n  mcp251xfd/mcp251xfd-dump.c\n  mcp251xfd/mcp251xfd-main.c\n  mcp251xfd/mcp251xfd-regmap.c\n)\n\nif(NOT ANDROID)\n  list(APPEND PROGRAMS ${PROGRAMS_J1939})\n\n  add_library(j1939 STATIC\n    libj1939.c\n  )\n\n  target_link_libraries(j1939\n    PRIVATE can\n  )\n\n  add_library(isobusfs SHARED\n    isobusfs/isobusfs_cmn.c\n    isobusfs/isobusfs_cmn_dh.c\n  )\n\n  set(PUBLIC_HEADER_ISOBUSFS\n    isobusfs/isobusfs_cmn.h\n    isobusfs/isobusfs_cmn_cm.h\n  )\n\n  set_target_properties(isobusfs PROPERTIES\n    PUBLIC_HEADER \"${PUBLIC_HEADER_ISOBUSFS}\"\n  )\n\n  install(TARGETS isobusfs\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n  )\n\n  add_executable(isobusfs-cli\n    isobusfs/isobusfs_cli.c\n    isobusfs/isobusfs_cli_cm.c\n    isobusfs/isobusfs_cli_dh.c\n    isobusfs/isobusfs_cli_fa.c\n    isobusfs/isobusfs_cli_selftests.c\n    isobusfs/isobusfs_cli_int.c\n  )\n\n  target_link_libraries(isobusfs-cli\n    PRIVATE isobusfs can j1939\n  )\n\n  add_executable(isobusfs-srv\n    isobusfs/isobusfs_srv.c\n    isobusfs/isobusfs_srv_cm.c\n    isobusfs/isobusfs_srv_cm_fss.c\n    isobusfs/isobusfs_srv_dh.c\n    isobusfs/isobusfs_srv_fa.c\n    isobusfs/isobusfs_srv_fh.c\n    isobusfs/isobusfs_srv_vh.c\n  )\n\n  target_link_libraries(isobusfs-srv\n    PRIVATE isobusfs can j1939\n  )\n\n  install(TARGETS\n    isobusfs-cli\n    isobusfs-srv\n    DESTINATION ${CMAKE_INSTALL_BINDIR})\n\n  set(PUBLIC_HEADER_j1939_TIMEDATE\n    j1939_timedate/j1939_timedate_cmn.h\n  )\n\n  add_executable(j1939-timedate-cli\n    j1939_timedate/j1939_timedate_cli.c\n  )\n\n  target_link_libraries(j1939-timedate-cli\n    PRIVATE can j1939\n  )\n\n  add_executable(j1939-timedate-srv\n    j1939_timedate/j1939_timedate_srv.c\n  )\n\n  target_link_libraries(j1939-timedate-srv\n    PRIVATE can j1939\n  )\n\n  install(TARGETS\n    j1939-timedate-cli\n    j1939-timedate-srv\n    DESTINATION ${CMAKE_INSTALL_BINDIR})\n\nendif()\n\nadd_library(can STATIC\n  lib.c\n  canframelen.c\n)\n\nforeach(name ${PROGRAMS})\n  add_executable(${name} ${name}.c)\n\n  if(\"${name}\" IN_LIST PROGRAMS_J1939)\n    target_link_libraries(${name}\n      PRIVATE j1939 can\n    )\n  elseif(\"${name}\" IN_LIST PROGRAMS_CANLIB)\n    target_link_libraries(${name}\n      PRIVATE can\n    )\n  endif()\n\n  install(TARGETS ${name} DESTINATION ${CMAKE_INSTALL_BINDIR})\nendforeach()\n\ninstall(TARGETS\n  can-calc-bit-timing\n  mcp251xfd-dump\n  DESTINATION ${CMAKE_INSTALL_BINDIR}\n)\n\nadd_custom_target(uninstall\n  \"${CMAKE_COMMAND}\" -P \"${CMAKE_SOURCE_DIR}/cmake/make_uninstall.cmake\"\n  COMMENT \"Add uninstall target\"\n)\n"
        },
        {
          "name": "LICENSES",
          "type": "tree",
          "content": null
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 5.5673828125,
          "content": "#\n#  Copyright (c) 2002-2005 Volkswagen Group Electronic Research\n#  All rights reserved.\n#\n#  Redistribution and use in source and binary forms, with or without\n#  modification, are permitted provided that the following conditions\n#  are met:\n#  1. Redistributions of source code must retain the above copyright\n#     notice, this list of conditions, the following disclaimer and\n#     the referenced file 'COPYING'.\n#  2. Redistributions in binary form must reproduce the above copyright\n#     notice, this list of conditions and the following disclaimer in the\n#     documentation and/or other materials provided with the distribution.\n#  3. Neither the name of Volkswagen nor the names of its contributors\n#     may be used to endorse or promote products derived from this software\n#     without specific prior written permission.\n#\n#  Alternatively, provided that this notice is retained in full, this\n#  software may be distributed under the terms of the GNU General\n#  Public License (\"GPL\") version 2 as distributed in the 'COPYING'\n#  file from the main directory of the linux kernel source.\n#\n#  The provided data structures and external interfaces from this code\n#  are not restricted to be used by modules with a GPL compatible license.\n#\n#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n#  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n#  DAMAGE.\n#\n#  Send feedback to <linux-can@vger.kernel.org>\n\nDESTDIR ?=\nPREFIX ?= /usr/local\n\nMAKEFLAGS := -k\n\nCFLAGS := -O2 -Wall -Wno-parentheses -Wsign-compare\n\nHAVE_FORK := $(shell ./check_cc.sh \"$(CC)\" fork_test.c)\n\nCPPFLAGS += \\\n\t-I. \\\n\t-Iinclude \\\n\t-DAF_CAN=PF_CAN \\\n\t-DPF_CAN=29 \\\n\t-DSO_RXQ_OVFL=40 \\\n\t-DSCM_TIMESTAMPING_OPT_STATS=54 \\\n\t-DCLOCK_TAI=11 \\\n\t-DSO_TXTIME=61 \\\n\t-DSCM_TXTIME=SO_TXTIME \\\n\t-D_FILE_OFFSET_BITS=64 \\\n\t-D_GNU_SOURCE\n\nPROGRAMS_CANGW := \\\n\tcangw\n\nPROGRAMS_J1939_TIMEDATE := \\\n\tj1939-timedate-srv \\\n\tj1939-timedate-cli\n\nPROGRAMS_ISOBUSFS := \\\n\tisobusfs-srv \\\n\tisobusfs-cli\n\nPROGRAMS_ISOTP := \\\n\tisotpdump \\\n\tisotpperf \\\n\tisotprecv \\\n\tisotpsend \\\n\tisotpsniffer \\\n\tisotptun\n\nifeq ($(HAVE_FORK),1)\nPROGRAMS_ISOTP += \\\n\tisotpserver\nendif\n\nPROGRAMS_J1939 := \\\n\tj1939acd \\\n\tj1939cat \\\n\tj1939spy \\\n\tj1939sr \\\n\ttestj1939\n\nPROGRAMS_SLCAN := \\\n\tslcan_attach \\\n\tslcand\n\nPROGRAMS := \\\n\t$(PROGRAMS_CANGW) \\\n\t$(PROGRAMS_J1939_TIMEDATE) \\\n\t$(PROGRAMS_ISOBUSFS) \\\n\t$(PROGRAMS_ISOTP) \\\n\t$(PROGRAMS_J1939) \\\n\t$(PROGRAMS_SLCAN) \\\n\tasc2log \\\n\tcan-calc-bit-timing \\\n\tcanbusload \\\n\tcandump \\\n\tcanfdtest \\\n\tcangen \\\n\tcansequence \\\n\tcanplayer \\\n\tcansend \\\n\tcansniffer \\\n\tlog2asc \\\n\tlog2long \\\n\tmcp251xfd-dump \\\n\tslcanpty\n\nifeq ($(HAVE_FORK),1)\nPROGRAMS += \\\n\tcanlogserver \\\n\tbcmserver\nendif\n\nall: $(PROGRAMS)\n\nclean:\n\trm -f $(PROGRAMS) *.o mcp251xfd/*.o isobusfs/*.o j1939_timedate/*.o\n\ninstall:\n\tmkdir -p $(DESTDIR)$(PREFIX)/bin\n\tcp -f $(PROGRAMS) $(DESTDIR)$(PREFIX)/bin\n\ndistclean: clean\n\trm -f $(PROGRAMS) $(LIBRARIES) *~\n\nasc2log.o:\tlib.h\ncandump.o:\tlib.h\ncangen.o:\tlib.h\ncanlogserver.o:\tlib.h\ncanplayer.o:\tlib.h\ncansend.o:\tlib.h\nlog2asc.o:\tlib.h\nlog2long.o:\tlib.h\nslcanpty.o:\tlib.h\nj1939acd.o:\tlib.h libj1939.h\nj1939cat.o:\tlib.h libj1939.h\nj1939spy.o:\tlib.h libj1939.h\nj1939sr.o:\tlib.h libj1939.h\ntestj1939.o:\tlib.h libj1939.h\nisobusfs_srv.o:\tlib.h libj1939.h\nisobusfs_c.o:\tlib.h libj1939.h\nj1939_timedate_srv.o: lib.h libj1939.h\nj1939_timedate_cli.o: lib.h libj1939.h\ncanframelen.o:  canframelen.h\n\nasc2log:\tasc2log.o\tlib.o\ncanbusload:\tcanbusload.o\tcanframelen.o\ncandump:\tcandump.o\tlib.o\ncangen:\t\tcangen.o\tlib.o\ncanlogserver:\tcanlogserver.o\tlib.o\ncanplayer:\tcanplayer.o\tlib.o\ncansend:\tcansend.o\tlib.o\ncansequence:\tcansequence.o\tlib.o\nlog2asc:\tlog2asc.o\tlib.o\nlog2long:\tlog2long.o\tlib.o\nslcanpty:\tslcanpty.o\tlib.o\nj1939acd:\tj1939acd.o\tlib.o libj1939.o\nj1939cat:\tj1939cat.o\tlib.o libj1939.o\nj1939spy:\tj1939spy.o\tlib.o libj1939.o\nj1939sr:\tj1939sr.o\tlib.o libj1939.o\ntestj1939:\ttestj1939.o\tlib.o libj1939.o\n\nj1939-timedate-srv:\tlib.o \\\n\t\t\tlibj1939.o \\\n\t\t\tj1939_timedate/j1939_timedate_srv.o\n\t\t$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n\nj1939-timedate-cli:\tlib.o \\\n\t\t\tlibj1939.o \\\n\t\t\tj1939_timedate/j1939_timedate_cli.o\n\t\t$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n\nisobusfs-srv:\tlib.o \\\n\t\tlibj1939.o \\\n\t\tisobusfs/isobusfs_cmn.o \\\n\t\tisobusfs/isobusfs_srv.o \\\n\t\tisobusfs/isobusfs_srv_cm.o \\\n\t\tisobusfs/isobusfs_srv_cm_fss.o \\\n\t\tisobusfs/isobusfs_srv_dh.o \\\n\t\tisobusfs/isobusfs_srv_fa.o \\\n\t\tisobusfs/isobusfs_srv_fh.o \\\n\t\tisobusfs/isobusfs_srv_vh.o \\\n\t\tisobusfs/isobusfs_cmn_dh.o\n\t$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n\nisobusfs-cli:\tlib.o \\\n\t\tlibj1939.o \\\n\t\tisobusfs/isobusfs_cmn.o \\\n\t\tisobusfs/isobusfs_cli.o \\\n\t\tisobusfs/isobusfs_cli_cm.o \\\n\t\tisobusfs/isobusfs_cli_dh.o \\\n\t\tisobusfs/isobusfs_cli_fa.o \\\n\t\tisobusfs/isobusfs_cli_selftests.o \\\n\t\tisobusfs/isobusfs_cli_int.o\n\t$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n\ncan-calc-bit-timing: calc-bit-timing/can-calc-bit-timing.o\n\t$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n\nmcp251xfd-dump: mcp251xfd/mcp251xfd-dev-coredump.o mcp251xfd/mcp251xfd-dump.o mcp251xfd/mcp251xfd-main.o mcp251xfd/mcp251xfd-regmap.o\n\t$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.958984375,
          "content": "<p align=\"center\">\n<img src=\"https://github.com/linux-can/can-logos/raw/master/png/SocketCAN-logo-60dpi.png\" alt=\"SocketCAN logo\"/>\n</p>\n\n### SocketCAN userspace utilities and tools\n\nThis repository contains some userspace utilities for Linux CAN\nsubsystem (aka SocketCAN):\n\n#### Basic tools to display, record, generate and replay CAN traffic\n\n* candump : display, filter and log CAN data to files\n* canplayer : replay CAN logfiles\n* cansend : send a single frame\n* cangen : generate (random) CAN traffic\n* cansequence : send and check sequence of CAN frames with incrementing payload\n* cansniffer : display CAN data content differences\n\n#### CAN access via IP sockets\n* canlogserver : log CAN frames and serves them\n* bcmserver : interactive BCM configuration (remote/local)\n* [socketcand](https://github.com/linux-can/socketcand) : use RAW/BCM/ISO-TP sockets via TCP/IP sockets\n* [cannelloni](https://github.com/mguentner/cannelloni) : UDP/SCTP based SocketCAN tunnel\n\n#### CAN in-kernel gateway configuration\n* cangw : CAN gateway userspace tool for netlink configuration\n\n#### CAN bus measurement and testing\n* canbusload : calculate and display the CAN busload\n* can-calc-bit-timing : userspace version of in-kernel bitrate calculation\n* canfdtest : Full-duplex test program (DUT and host part)\n\n#### ISO-TP tools [ISO15765-2:2016 for Linux](https://github.com/hartkopp/can-isotp)\n* isotpsend : send a single ISO-TP PDU\n* isotprecv : receive ISO-TP PDU(s)\n* isotpsniffer : 'wiretap' ISO-TP PDU(s)\n* isotpdump : 'wiretap' and interpret CAN messages (CAN_RAW)\n* isotpserver : IP server for simple TCP/IP <-> ISO 15765-2 bridging (ASCII HEX)\n* isotpperf : ISO15765-2 protocol performance visualisation\n* isotptun : create a bi-directional IP tunnel on CAN via ISO-TP\n\n#### J1939/ISOBus tools\n* j1939acd : address claim daemon\n* j1939cat : take a file and send and receive it over CAN\n* j1939spy : spy on J1939 messages using SOC_J1939\n* j1939sr : send/recv from stdin or to stdout\n* testj1939 : send/receive test packet\n\nFollow the link to see examples on how this tools can be used:\n[Kickstart guide to can-j1939 on linux](https://github.com/linux-can/can-utils/blob/master/can-j1939-kickstart.md)\n\n#### Log file converters\n* asc2log : convert ASC logfile to compact CAN frame logfile\n* log2asc : convert compact CAN frame logfile to ASC logfile\n* log2long : convert compact CAN frame representation into user readable\n\n#### Serial Line Discipline configuration (for slcan driver)\n* slcan_attach : userspace tool for serial line CAN interface configuration\n* slcand : daemon for serial line CAN interface configuration\n* slcanpty : creates a pty for applications using the slcan ASCII protocol\n\n#### CMake Project Generator\n* Place your build folder anywhere, passing CMake the path.  Relative or absolute.\n* Some examples using a build folder under the source tree root:\n* Android : ``cmake -DCMAKE_TOOLCHAIN_FILE=~/Android/Sdk/ndk-bundle/build/cmake/android.toolchain.cmake -DANDROID_PLATFORM=android-21 -DANDROID_ABI=armeabi-v7a .. && make``\n* Android Studio : Copy repo under your project's ``app`` folder, add ``add_subdirectory(can-utils)`` to your ``CMakeLists.txt`` file after ``cmake_minimum_required()``.  Generating project will build Debug/Release for all supported EABI types.  ie. arm64-v8a, armeabi-v7a, x86, x86_64.\n* Raspberry Pi : ``cmake -DCMAKE_TOOLCHAIN_FILE=~/rpi/tools/build/cmake/rpi.toolchain.cmake .. && make``\n* Linux : ``cmake -GNinja .. && ninja``\n* Linux Eclipse Photon (Debug) : ``CC=clang cmake -G\"Eclipse CDT4 - Unix Makefiles\" ../can-utils/ -DCMAKE_BUILD_TYPE=Debug -DCMAKE_ECLIPSE_VERSION=4.8.0``\n* To override the base installation directory use: ``CMAKE_INSTALL_PREFIX``\n  ie. ``CC=clang cmake -DCMAKE_INSTALL_PREFIX=./out .. && make install``\n\n### Additional Information:\n\n*   [SocketCAN Documentation (Linux Kernel)](https://www.kernel.org/doc/html/latest/networking/can.html)\n*   [Elinux.org CAN Bus Page](http://elinux.org/CAN_Bus)\n*   [Debian Package Description](https://packages.debian.org/sid/can-utils)\n\n"
        },
        {
          "name": "asc2log.c",
          "type": "blob",
          "size": 15.400390625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * asc2log.c - convert ASC logfile to compact CAN frame logfile\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <libgen.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include <linux/can.h>\n#include <linux/can/error.h>\n#include <net/if.h>\n\n#include \"lib.h\"\n\n#define BUFLEN 400 /* CAN FD mode lines can be pretty long */\n\nextern int optind, opterr, optopt;\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - convert ASC logfile to compact CAN frame logfile.\\n\", prg);\n\tfprintf(stderr, \"Usage: %s\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"\\t-I <infile>\\t(default stdin)\\n\");\n\tfprintf(stderr, \"\\t-O <outfile>\\t(default stdout)\\n\");\n}\n\nstatic void prframe(FILE *file, struct timeval *tv, int dev,\n\t\t    struct canfd_frame *cf, char *extra_info)\n{\n\tstatic char abuf[BUFLEN];\n\n\tfprintf(file, \"(%llu.%06llu) \", (unsigned long long)tv->tv_sec, (unsigned long long)tv->tv_usec);\n\n\tif (dev > 0)\n\t\tfprintf(file, \"can%d \", dev-1);\n\telse\n\t\tfprintf(file, \"canX \");\n\n\tsnprintf_canframe(abuf, sizeof(abuf), (cu_t *)cf, 0);\n\tfprintf(file, \"%s%s\", abuf, extra_info);\n}\n\nstatic void get_can_id(struct canfd_frame *cf, char *idstring, int base)\n{\n\tif (idstring[strlen(idstring)-1] == 'x') {\n\t\tcf->can_id = CAN_EFF_FLAG;\n\t\tidstring[strlen(idstring)-1] = 0;\n\t} else\n\t\tcf->can_id = 0;\n    \n\tcf->can_id |= strtoul(idstring, NULL, base);\n}\n\nstatic void calc_tv(struct timeval *tv, struct timeval *read_tv,\n\t\t    struct timeval *date_tv, char timestamps, int dplace)\n{\n\tif (dplace == 4) /* shift values having only 4 decimal places */\n\t\tread_tv->tv_usec *= 100;                /* and need for 6 */\n\n\tif (dplace == 5) /* shift values having only 5 decimal places */\n\t\tread_tv->tv_usec *= 10;                /* and need for 6 */\n\n\tif (timestamps == 'a') { /* absolute */\n\n\t\ttv->tv_sec  = date_tv->tv_sec  + read_tv->tv_sec;\n\t\ttv->tv_usec = date_tv->tv_usec + read_tv->tv_usec;\n\n\t} else { /* relative */\n\n\t\tif (((!tv->tv_sec) && (!tv->tv_usec)) && \n\t\t    (date_tv->tv_sec || date_tv->tv_usec)) {\n\t\t\ttv->tv_sec  = date_tv->tv_sec; /* initial date/time */\n\t\t\ttv->tv_usec = date_tv->tv_usec;\n\t\t}\n\n\t\ttv->tv_sec  += read_tv->tv_sec;\n\t\ttv->tv_usec += read_tv->tv_usec;\n\t}\n\n\tif (tv->tv_usec >= 1000000) {\n\t\ttv->tv_usec -= 1000000;\n\t\ttv->tv_sec++;\n\t}\n}\n\nstatic void eval_can(char* buf, struct timeval *date_tvp, char timestamps,\n\t\t     char base, int dplace, FILE *outfile)\n{\n\tint interface;\n\tstatic struct timeval tv; /* current frame timestamp */\n\tstatic struct timeval read_tv; /* frame timestamp from ASC file */\n\tstruct canfd_frame cf = { 0 };\n\tstruct can_frame *ccf = (struct can_frame *)&cf; /* for len8_dlc */\n\tchar rtr;\n\tint dlc = 0;\n\tint len = 0;\n\tint data[8];\n\tchar tmp1[BUFLEN];\n\tchar dir[3]; /* 'Rx' or 'Tx' plus terminating zero */\n\tchar *extra_info;\n\tint i, items;\n\tunsigned long long sec, usec;\n\n\t/* check for ErrorFrames */\n\tif (sscanf(buf, \"%llu.%llu %d %s\",\n\t\t   &sec, &usec,\n\t\t   &interface, tmp1) == 4) {\n\t\tread_tv.tv_sec = sec;\n\t\tread_tv.tv_usec = usec;\n\n\t\tif (!strncmp(tmp1, \"ErrorFrame\", strlen(\"ErrorFrame\"))) {\n\n\t\t\t/* do not know more than 'Error' */\n\t\t\tcf.can_id = (CAN_ERR_FLAG | CAN_ERR_BUSERROR);\n\t\t\tcf.len = CAN_ERR_DLC;\n\n\t\t\tcalc_tv(&tv, &read_tv, date_tvp, timestamps, dplace);\n\t\t\tprframe(outfile, &tv, interface, &cf, \"\\n\");\n\t\t\tfflush(outfile);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00 */\n\n\t/* check for CAN frames with (hexa)decimal values */\n\tif (base == 'h')\n\t\titems = sscanf(buf, \"%llu.%llu %d %s %2s %c %x %x %x %x %x %x %x %x %x\",\n\t\t\t       &sec, &usec, &interface,\n\t\t\t       tmp1, dir, &rtr, &dlc,\n\t\t\t       &data[0], &data[1], &data[2], &data[3],\n\t\t\t       &data[4], &data[5], &data[6], &data[7]);\n\telse\n\t\titems = sscanf(buf, \"%llu.%llu %d %s %2s %c %x %d %d %d %d %d %d %d %d\",\n\t\t\t       &sec, &usec, &interface,\n\t\t\t       tmp1, dir, &rtr, &dlc,\n\t\t\t       &data[0], &data[1], &data[2], &data[3],\n\t\t\t       &data[4], &data[5], &data[6], &data[7]);\n\n\tread_tv.tv_sec = sec;\n\tread_tv.tv_usec = usec;\n\tif (items < 7 ) /* make sure we've read the dlc */\n\t\treturn;\n\n\t/* dlc is one character hex value 0..F */\n\tif (dlc > CAN_MAX_RAW_DLC)\n\t\treturn;\n\n\t/* retrieve real data length */\n\tif (dlc > CAN_MAX_DLC)\n\t\tlen = CAN_MAX_DLEN;\n\telse\n\t\tlen = dlc;\n\n\tif ((items == len + 7 ) || /* data frame */\n\t    ((items == 6) && (rtr == 'r')) || /* RTR without DLC */\n\t    ((items == 7) && (rtr == 'r'))) { /* RTR with DLC */\n\n\t\t/* check for CAN ID with (hexa)decimal value */\n\t\tif (base == 'h')\n\t\t\tget_can_id(&cf, tmp1, 16);\n\t\telse\n\t\t\tget_can_id(&cf, tmp1, 10);\n\n\t\t/* dlc > 8 => len == CAN_MAX_DLEN => fill len8_dlc value */\n\t\tif (dlc > CAN_MAX_DLC)\n\t\t\tccf->len8_dlc = dlc;\n\n\t\tif (strlen(dir) != 2) /* \"Rx\" or \"Tx\" */\n\t\t\treturn;\n\n\t\t/* check for signed integer overflow */\n\t\tif (dplace == 4 && read_tv.tv_usec >= INT_MAX / 100)\n\t\t\treturn;\n\n\t\tif (dplace == 5 && read_tv.tv_usec >= INT_MAX / 10)\n\t\t\treturn;\n\n\t\tif (dir[0] == 'R')\n\t\t\textra_info = \" R\\n\";\n\t\telse\n\t\t\textra_info = \" T\\n\";\n\n\t\tcf.len = len;\n\t\tif (rtr == 'r')\n\t\t\tcf.can_id |= CAN_RTR_FLAG;\n\t\telse\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tcf.data[i] = data[i] & 0xFFU;\n\n\t\tcalc_tv(&tv, &read_tv, date_tvp, timestamps, dplace);\n\t\tprframe(outfile, &tv, interface, &cf, extra_info);\n\t\tfflush(outfile);\n\t}\n}\n\nstatic void eval_canfd(char* buf, struct timeval *date_tvp, char timestamps,\n\t\t       int dplace, FILE *outfile)\n{\n\tint interface;\n\tstatic struct timeval tv; /* current frame timestamp */\n\tstatic struct timeval read_tv; /* frame timestamp from ASC file */\n\tstruct canfd_frame cf = { 0 };\n\tunsigned char brs, esi, ctmp;\n\tunsigned int flags;\n\tint dlc, dlen = 0;\n\tchar tmp1[BUFLEN];\n\tchar dir[3]; /* 'Rx' or 'Tx' plus terminating zero */\n\tchar *extra_info;\n\tchar *ptr;\n\tint i;\n\tunsigned long long sec, usec;\n\n\t/* The CANFD format is mainly in hex representation but <DataLength>\n\t   and probably some content we skip anyway. Don't trust the docs! */\n\n\t/* 21.671796 CANFD   1 Tx         11  msgCanFdFr1                      1 0 a 16 \\\n\t   00 00 00 00 00 00 00 00 00 00 00 00 00 00 59 c0\t\t\\\n\t   100000  214   223040 80000000 46500250 460a0250 20011736 20010205 */\n\n\t/* check for valid line without symbolic name */\n\tif (sscanf(buf, \"%llu.%llu %*s %d %2s %s %hhx %hhx %x %d \",\n\t\t   &sec, &usec, &interface,\n\t\t   dir, tmp1, &brs, &esi, &dlc, &dlen) != 9) {\n\n\t\t/* check for valid line with a symbolic name */\n\t\tif (sscanf(buf, \"%llu.%llu %*s %d %2s %s %*s %hhx %hhx %x %d \",\n\t\t\t   &sec, &usec, &interface,\n\t\t\t   dir, tmp1, &brs, &esi, &dlc, &dlen) != 9) {\n\n\t\t\t/* no valid CANFD format pattern */\n\t\t\treturn;\n\t\t}\n\t}\n\tread_tv.tv_sec = sec;\n\tread_tv.tv_usec = usec;\n\n\t/* check for allowed (unsigned) value ranges */\n\tif ((dlen > CANFD_MAX_DLEN) || (dlc > CANFD_MAX_DLC) ||\n\t    (brs > 1) || (esi > 1))\n\t\treturn;\n\n\tif (strlen(dir) != 2) /* \"Rx\" or \"Tx\" */\n\t\treturn;\n\n\t/* check for signed integer overflow */\n\tif (dplace == 4 && read_tv.tv_usec >= INT_MAX / 100)\n\t\treturn;\n\n\t/* check for signed integer overflow */\n\tif (dplace == 5 && read_tv.tv_usec >= INT_MAX / 10)\n\t\treturn;\n\n\tif (dir[0] == 'R')\n\t\textra_info = \" R\\n\";\n\telse\n\t\textra_info = \" T\\n\";\n\n\t/* don't trust ASCII content - sanitize data length */\n\tif (dlen != can_fd_dlc2len(can_fd_len2dlc(dlen)))\n\t\treturn;\n\n\tget_can_id(&cf, tmp1, 16);\n\n\t/* now search for the beginning of the data[] content */\n\tsprintf(tmp1, \" %x %x %x %2d \", brs, esi, dlc, dlen);\n\n\t/* search for the pattern generated by real data */\n\tptr = strcasestr(buf, tmp1);\n\tif (ptr == NULL)\n\t\treturn;\n\n\tptr += strlen(tmp1); /* start of ASCII hex frame data */\n\n\tcf.len = dlen;\n\n\tfor (i = 0; i < dlen; i++) {\n\t\tctmp = asc2nibble(ptr[0]);\n\t\tif (ctmp > 0x0F)\n\t\t\treturn;\n\n\t\tcf.data[i] = (ctmp << 4);\n\n\t\tctmp = asc2nibble(ptr[1]);\n\t\tif (ctmp > 0x0F)\n\t\t\treturn;\n\n\t\tcf.data[i] |= ctmp;\n\n\t\tptr += 3; /* start of next ASCII hex byte */\n\t}\n\n\t/* skip MessageDuration and MessageLength to get Flags value */\n\tif (sscanf(ptr, \"   %*x %*x %x \", &flags) != 1)\n\t\treturn;\n\n\t/* relevant flags in Flags field */\n#define ASC_F_RTR 0x00000010\n#define ASC_F_FDF 0x00001000\n#define ASC_F_BRS 0x00002000\n#define ASC_F_ESI 0x00004000\n\n\tif (flags & ASC_F_FDF) {\n\t\tcf.flags = CANFD_FDF;\n\t\tif (flags & ASC_F_BRS)\n\t\t\tcf.flags |= CANFD_BRS;\n\t\tif (flags & ASC_F_ESI)\n\t\t\tcf.flags |= CANFD_ESI;\n\t} else {\n\t\t/* yes. The 'CANFD' format supports classic CAN content! */\n\t\tif (flags & ASC_F_RTR) {\n\t\t\tcf.can_id |= CAN_RTR_FLAG;\n\t\t\t/* dlen is always 0 for classic CAN RTR frames\n\t\t\t   but the DLC value is valid in RTR cases */\n\t\t\tcf.len = dlc;\n\t\t\t/* sanitize payload length value */\n\t\t\tif (dlc > CAN_MAX_DLEN)\n\t\t\t\tcf.len = CAN_MAX_DLEN;\n\t\t}\n\t\t/* check for extra DLC when having a Classic CAN with 8 bytes payload */\n\t\tif ((cf.len == CAN_MAX_DLEN) && (dlc > CAN_MAX_DLEN) && (dlc <= CAN_MAX_RAW_DLC)) {\n\t\t\tstruct can_frame *ccf = (struct can_frame *)&cf;\n\n\t\t\tccf->len8_dlc = dlc;\n\t\t}\n\t}\n\n\tcalc_tv(&tv, &read_tv, date_tvp, timestamps, dplace);\n\tprframe(outfile, &tv, interface, &cf, extra_info);\n\tfflush(outfile);\n\n\t/* No support for really strange CANFD ErrorFrames format m( */\n}\n\nstatic int get_date(struct timeval *tv, char *date)\n{\n\tstruct tm tms;\n\tunsigned int msecs = 0;\n\n\tif ((strcasestr(date, \" am \") != NULL) || (strcasestr(date, \" pm \") != NULL)) {\n\t\t/* assume EN/US date due to existing am/pm field */\n\n\t\tif (!setlocale(LC_TIME, \"en_US\")) {\n\t\t\tfprintf(stderr, \"Setting locale to 'en_US' failed!\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!strptime(date, \"%B %d %I:%M:%S %p %Y\", &tms)) {\n\t\t\t/* The string might contain a milliseconds value which strptime()\n\t\t\t   does not support. So we read the ms value into the year variable\n\t\t\t   before parsing the real year value (hack) */\n\t\t\tif (!strptime(date, \"%B %d %I:%M:%S.%Y %p %Y\", &tms))\n\t\t\t\treturn 1;\n\t\t\tsscanf(date, \"%*s %*d %*d:%*d:%*d.%3u \", &msecs);\n\t\t}\n\n\t} else {\n\t\t/* assume DE date due to non existing am/pm field */\n\n\t\tif (!setlocale(LC_TIME, \"de_DE\")) {\n\t\t\tfprintf(stderr, \"Setting locale to 'de_DE' failed!\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!strptime(date, \"%B %d %H:%M:%S %Y\", &tms)) {\n\t\t\t/* The string might contain a milliseconds value which strptime()\n\t\t\t   does not support. So we read the ms value into the year variable\n\t\t\t   before parsing the real year value (hack) */\n\t\t\tif (!strptime(date, \"%B %d %H:%M:%S.%Y %Y\", &tms))\n\t\t\t\treturn 1;\n\t\t\tsscanf(date, \"%*s %*d %*d:%*d:%*d.%3u \", &msecs);\n\t\t}\n\t}\n\n\t//printf(\"h %d m %d s %d ms %03d d %d m %d y %d\\n\",\n\t//tms.tm_hour, tms.tm_min, tms.tm_sec, msecs,\n\t//tms.tm_mday, tms.tm_mon+1, tms.tm_year+1900);\n\n\ttv->tv_sec = mktime(&tms);\n\ttv->tv_usec = msecs * 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tchar buf[BUFLEN], tmp1[BUFLEN], tmp2[BUFLEN];\n\n\tFILE *infile = stdin;\n\tFILE *outfile = stdout;\n\tstatic int verbose;\n\tstatic struct timeval date_tv; /* date of the ASC file */\n\tstatic int dplace; /* decimal place 4, 5 or 6 or uninitialized */\n\tstatic char base; /* 'd'ec or 'h'ex */\n\tstatic char timestamps; /* 'a'bsolute or 'r'elative */\n\tint opt;\n\tunsigned long long sec, usec;\n\n\twhile ((opt = getopt(argc, argv, \"I:O:v?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'I':\n\t\t\tinfile = fopen(optarg, \"r\");\n\t\t\tif (!infile) {\n\t\t\t\tperror(\"infile\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\toutfile = fopen(optarg, \"w\");\n\t\t\tif (!outfile) {\n\t\t\t\tperror(\"outfile\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\twhile (fgets(buf, BUFLEN-1, infile)) {\n\n\t\tif (!dplace) { /* the representation of a valid CAN frame not known */\n\n\t\t\t/* check for base and timestamp entries in the header */\n\t\t\tif ((!base) &&\n\t\t\t    (sscanf(buf, \"base %s timestamps %s\", tmp1, tmp2) == 2)) {\n\t\t\t\tbase = tmp1[0];\n\t\t\t\ttimestamps = tmp2[0];\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"base %c timestamps %c\\n\", base, timestamps);\n\t\t\t\tif ((base != 'h') && (base != 'd')) {\n\t\t\t\t\tprintf(\"invalid base %s (must be 'hex' or 'dez')!\\n\",\n\t\t\t\t\t       tmp1);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif ((timestamps != 'a') && (timestamps != 'r')) {\n\t\t\t\t\tprintf(\"invalid timestamps %s (must be 'absolute'\"\n\t\t\t\t\t       \" or 'relative')!\\n\", tmp2);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check for the original logging date in the header */ \n\t\t\tif ((!date_tv.tv_sec) &&\n\t\t\t    (!strncmp(buf, \"date\", 4))) {\n\n\t\t\t\tif (get_date(&date_tv, &buf[9])) { /* skip 'date day ' */\n\t\t\t\t\tfprintf(stderr, \"Not able to determine original log \"\n\t\t\t\t\t\t\"file date. Using current time.\\n\");\n\t\t\t\t\t/* use current date as default */\n\t\t\t\t\tgettimeofday(&date_tv, NULL);\n\t\t\t\t}\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(\"date %llu => %s\", (unsigned long long)date_tv.tv_sec, ctime(&date_tv.tv_sec));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check for decimal places length in valid CAN frames */\n\t\t\tif (sscanf(buf, \"%llu.%s %s \", &sec, tmp2,\n\t\t\t\t   tmp1) != 3)\n\t\t\t\tcontinue; /* dplace remains zero until first found CAN frame */\n\n\t\t\tdplace = strlen(tmp2);\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"decimal place %d, e.g. '%s'\\n\", dplace,\n\t\t\t\t       tmp2);\n\t\t\tif (dplace < 4 || dplace > 6) {\n\t\t\t\tprintf(\"invalid dplace %d (must be 4, 5 or 6)!\\n\",\n\t\t\t\t       dplace);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t/* the representation of a valid CAN frame is known here */\n\t\t/* so try to get CAN frames and ErrorFrames and convert them */\n\n\t\t/* check classic CAN format or the CANFD tag which can take both types */\n\t\tif (sscanf(buf, \"%llu.%llu %s \", &sec,  &usec, tmp1) == 3){\n\t\t\tif (!strncmp(tmp1, \"CANFD\", 5))\n\t\t\t\teval_canfd(buf, &date_tv, timestamps, dplace, outfile);\n\t\t\telse\n\t\t\t\teval_can(buf, &date_tv, timestamps, base, dplace, outfile);\n\t\t}\n\t}\n\tfclose(outfile);\n\tfclose(infile);\n\treturn 0;\n}\n"
        },
        {
          "name": "bcmserver.c",
          "type": "blob",
          "size": 9.1669921875,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * tst-bcm-server.c\n *\n * Test program that implements a socket server which understands ASCII\n * messages for simple broadcast manager frame send commands.\n *\n * < interface command ival_s ival_us can_id can_dlc [data]* >\n *\n * Only the items 'can_id' and 'data' are given in (ASCII) hexadecimal values.\n *\n * ## TX path:\n *\n * The commands are 'A'dd, 'U'pdate, 'D'elete and 'S'end.\n * e.g.\n *\n * Send the CAN frame 123#1122334455667788 every second on vcan1\n * < vcan1 A 1 0 123 8 11 22 33 44 55 66 77 88 >\n *\n * Send the CAN frame 123#1122334455667788 every 10 usecs on vcan1\n * < vcan1 A 0 10 123 8 11 22 33 44 55 66 77 88 >\n *\n * Send the CAN frame 123#42424242 every 20 msecs on vcan1\n * < vcan1 A 0 20000 123 4 42 42 42 42 >\n *\n * Update the CAN frame 123#42424242 with 123#112233 - no change of timers\n * < vcan1 U 0 0 123 3 11 22 33 >\n *\n * Delete the cyclic send job from above\n * < vcan1 D 0 0 123 0 >\n *\n * Send a single CAN frame without cyclic transmission\n * < can0 S 0 0 123 0 >\n *\n * When the socket is closed the cyclic transmissions are terminated.\n *\n * ## RX path:\n *\n * The commands are 'R'eceive setup, 'F'ilter ID Setup and 'X' for delete.\n * e.g.\n *\n * Receive CAN ID 0x123 from vcan1 and check for changes in the first byte\n * < vcan1 R 0 0 123 1 FF >\n *\n * Receive CAN ID 0x123 from vcan1 and check for changes in given mask\n * < vcan1 R 0 0 123 8 FF 00 F8 00 00 00 00 00 >\n *\n * As above but throttle receive update rate down to 1.5 seconds\n * < vcan1 R 1 500000 123 8 FF 00 F8 00 00 00 00 00 >\n *\n * Filter for CAN ID 0x123 from vcan1 without content filtering\n * < vcan1 F 0 0 123 0 >\n *\n * Delete receive filter ('R' or 'F') for CAN ID 0x123\n * < vcan1 X 0 0 123 0 >\n *\n * CAN messages received by the given filters are send in the format:\n * < interface can_id can_dlc [data]* >\n *\n * e.g. when receiving a CAN message from vcan1 with\n * can_id 0x123 , data length 4 and data 0x11, 0x22, 0x33 and 0x44\n *\n * < vcan1 123 4 11 22 33 44 >\n *\n * ##\n *\n * Authors:\n * Andre Naujoks (the socket server stuff)\n * Oliver Hartkopp (the rest)\n *\n * Copyright (c) 2002-2009 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n\n#include <linux/can.h>\n#include <linux/can/bcm.h>\n\n#define MAXLEN 100\n#define FORMATSZ 80\n#define PORT 28600\n\nvoid childdied(int i)\n{\n\twait(NULL);\n}\n\nint main(void)\n{\n\n\tint sl, sa, sc;\n\tint i;\n\tint idx = 0;\n\tstruct sockaddr_in  saddr, clientaddr;\n\tstruct sockaddr_can caddr;\n\tsocklen_t caddrlen = sizeof(caddr);\n\tstruct ifreq ifr;\n\tfd_set readfds;\n\tsocklen_t sin_size = sizeof(clientaddr);\n\tstruct sigaction signalaction;\n\tsigset_t sigset;\n\n\tchar buf[MAXLEN];\n\tchar format[FORMATSZ];\n\tchar rxmsg[50];\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpragmas\"\n#pragma GCC diagnostic ignored \"-Wgnu-variable-sized-type-not-at-end\"\n\tstruct {\n\t\tstruct bcm_msg_head msg_head;\n\t\tstruct can_frame frame;\n\t} msg;\n#pragma GCC diagnostic pop\n\n\tif (snprintf(format, FORMATSZ, \"< %%%ds %%c %%lu %%lu %%x %%hhu \"\n\t\t     \"%%hhx %%hhx %%hhx %%hhx %%hhx %%hhx \"\n\t\t     \"%%hhx %%hhx >\", IFNAMSIZ-1) >= FORMATSZ-1)\n\t\texit(1);\n\n\tsigemptyset(&sigset);\n\tsignalaction.sa_handler = &childdied;\n\tsignalaction.sa_mask = sigset;\n\tsignalaction.sa_flags = 0;\n\tsigaction(SIGCHLD, &signalaction, NULL);  /* signal for dying child */\n\n\tif((sl = socket(PF_INET, SOCK_STREAM, 0)) < 0) {\n\t\tperror(\"inetsocket\");\n\t\texit(1);\n\t}\n\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(PORT);\n\n\twhile(bind(sl,(struct sockaddr*)&saddr, sizeof(saddr)) < 0) {\n\t\tstruct timespec f = {\n\t\t\t.tv_nsec = 100 * 1000 * 1000,\n\t\t};\n\n\t\tprintf(\".\");fflush(NULL);\n\t\tnanosleep(&f, NULL);\n\t}\n\n\tif (listen(sl,3) != 0) {\n\t\tperror(\"listen\");\n\t\texit(1);\n\t}\n\n\twhile (1) {\n\t\tsa = accept(sl,(struct sockaddr *)&clientaddr, &sin_size);\n\t\tif (sa > 0 ){\n\t\t\tif (!fork())\n\t\t\t\tbreak;\n\t\t\tclose(sa);\n\t\t}\n\t\telse {\n\t\t\tif (errno != EINTR) {\n\t\t\t\t/*\n\t\t\t\t * If the cause for the error was NOT the\n\t\t\t\t * signal from a dying child => give an error\n\t\t\t\t */\n\t\t\t\tperror(\"accept\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* open BCM socket */\n\n\tif ((sc = socket(PF_CAN, SOCK_DGRAM, CAN_BCM)) < 0) {\n\t\tperror(\"bcmsocket\");\n\t\treturn 1;\n\t}\n\n\tmemset(&caddr, 0, sizeof(caddr));\n\tcaddr.can_family = PF_CAN;\n\t/* can_ifindex is set to 0 (any device) => need for sendto() */\n\n\tif (connect(sc, (struct sockaddr *)&caddr, sizeof(caddr)) < 0) {\n\t\tperror(\"connect\");\n\t\treturn 1;\n\t}\n\n\twhile (1) {\n\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(sc, &readfds);\n\t\tFD_SET(sa, &readfds);\n\n\t\tselect((sc > sa)?sc+1:sa+1, &readfds, NULL, NULL, NULL);\n\n\t\tif (FD_ISSET(sc, &readfds)) {\n\n\t\t\trecvfrom(sc, &msg, sizeof(msg), 0,\n\t\t\t\t (struct sockaddr*)&caddr, &caddrlen);\n\n\t\t\tifr.ifr_ifindex = caddr.can_ifindex;\n\t\t\tioctl(sc, SIOCGIFNAME, &ifr);\n\n\t\t\tsprintf(rxmsg, \"< %s %03X %d \", ifr.ifr_name,\n\t\t\t\tmsg.msg_head.can_id, msg.frame.can_dlc);\n\n\t\t\tfor ( i = 0; i < msg.frame.can_dlc; i++)\n\t\t\t\tsprintf(rxmsg + strlen(rxmsg), \"%02X \",\n\t\t\t\t\tmsg.frame.data[i]);\n\n\t\t\t/* delimiter '\\0' for Adobe(TM) Flash(TM) XML sockets */\n\t\t\tstrcat(rxmsg, \">\\0\");\n\n\t\t\tsend(sa, rxmsg, strlen(rxmsg) + 1, 0);\n\t\t}\n\n\n\t\tif (FD_ISSET(sa, &readfds)) {\n\n\t\t\tchar cmd;\n\t\t\tint items;\n\n\t\t\tif (read(sa, buf+idx, 1) < 1)\n\t\t\t\texit(1);\n\n\t\t\tif (!idx) {\n\t\t\t\tif (buf[0] == '<')\n\t\t\t\t\tidx = 1;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (idx > MAXLEN-2) {\n\t\t\t\tidx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buf[idx] != '>') {\n\t\t\t\tidx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbuf[idx+1] = 0;\n\t\t\tidx = 0;\n\n\t\t\t//printf(\"read '%s'\\n\", buf);\n\n\t\t\t/* prepare bcm message settings */\n\t\t\tmemset(&msg, 0, sizeof(msg));\n\t\t\tmsg.msg_head.nframes = 1;\n\n\t\t\titems = sscanf(buf, format,\n\t\t\t\t       ifr.ifr_name,\n\t\t\t\t       &cmd,\n\t\t\t\t       &msg.msg_head.ival2.tv_sec,\n\t\t\t\t       &msg.msg_head.ival2.tv_usec,\n\t\t\t\t       &msg.msg_head.can_id,\n\t\t\t\t       &msg.frame.can_dlc,\n\t\t\t\t       &msg.frame.data[0],\n\t\t\t\t       &msg.frame.data[1],\n\t\t\t\t       &msg.frame.data[2],\n\t\t\t\t       &msg.frame.data[3],\n\t\t\t\t       &msg.frame.data[4],\n\t\t\t\t       &msg.frame.data[5],\n\t\t\t\t       &msg.frame.data[6],\n\t\t\t\t       &msg.frame.data[7]);\n\n\t\t\tif (items < 6)\n\t\t\t\tbreak;\n\t\t\tif (msg.frame.can_dlc > 8)\n\t\t\t\tbreak;\n\t\t\tif (items != 6 + msg.frame.can_dlc)\n\t\t\t\tbreak;\n\n\t\t\tmsg.frame.can_id = msg.msg_head.can_id;\n\n\t\t\tswitch (cmd) {\n\t\t\tcase 'S':\n\t\t\t\tmsg.msg_head.opcode = TX_SEND;\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\tmsg.msg_head.opcode = TX_SETUP;\n\t\t\t\tmsg.msg_head.flags |= SETTIMER | STARTTIMER;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tmsg.msg_head.opcode = TX_SETUP;\n\t\t\t\tmsg.msg_head.flags  = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tmsg.msg_head.opcode = TX_DELETE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\tmsg.msg_head.opcode = RX_SETUP;\n\t\t\t\tmsg.msg_head.flags  = SETTIMER;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tmsg.msg_head.opcode = RX_SETUP;\n\t\t\t\tmsg.msg_head.flags  = RX_FILTER_ID | SETTIMER;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tmsg.msg_head.opcode = RX_DELETE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"unknown command '%c'.\\n\", cmd);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (!ioctl(sc, SIOCGIFINDEX, &ifr)) {\n\t\t\t\tcaddr.can_ifindex = ifr.ifr_ifindex;\n\t\t\t\tsendto(sc, &msg, sizeof(msg), 0,\n\t\t\t\t       (struct sockaddr*)&caddr, sizeof(caddr));\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(sc);\n\tclose(sa);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "calc-bit-timing",
          "type": "tree",
          "content": null
        },
        {
          "name": "can-j1939-install-kernel-module.md",
          "type": "blob",
          "size": 5.3544921875,
          "content": "# can-j1939 kernel module installation #\n\n\n\n### Problem\n\nYou already have **can0** or **vcan0** up and working, **can-utils** downloaded and compiled to **~/can/can-utils** and you can send and receive frames without problems. However, when you want to bring up **can-j1939** you get error like this:\n\n```bash\navra@vm-debian:~/can/can-utils$ sudo modprobe can-j1939\nmodprobe: FATAL: Module can-j1939 not found in directory /lib/modules/5.7.0.0.bpo.2-amd64\n```\n\nand also this:\n\n```bash\navra@vm-debian:~/can/can-utils$ testj1939\ntestj1939: socket(j1939): Protocol not supported\n```\n\n\n\n### Solution\n\nAbove errors mean that **can-j1939** was not enabled in your kernel and you need to compile it manually. There are several ways to do it. Any Linux kernel since 5.4 has **can-j1939** module, but you will probably want to install fresher version, which leads to downloading kernel sources, enabling **can-j1939** module, recompiling kernel and installing it. I will be using Debian 10.5 x64 (buster testing) virtual machine.\n\n\n\n#### 1. Download kernel source ####\n\nWe will download Debian patched kernel 5.8. First update your sources\n\n```\navra@vm-debian:~$ sudo apt update\n```\n\nand then look at available Debian patched kernel source packages\n\n```\navra@vm-debian:~$ apt-cache search linux-source\nlinux-source-4.19 - Linux kernel source for version 4.19 with Debian patches\nlinux-source - Linux kernel source (meta-package)\nlinux-source-5.4 - Linux kernel source for version 5.4 with Debian patches\nlinux-source-5.5 - Linux kernel source for version 5.5 with Debian patches\nlinux-source-5.6 - Linux kernel source for version 5.6 with Debian patches\nlinux-source-5.7 - Linux kernel source for version 5.7 with Debian patches\nlinux-source-5.8 - Linux kernel source for version 5.8 with Debian patches\n```\n\nIf kernel 5.8 does not show in your linux-sources list (it shows above in mine since I have already upgraded stock 4.19 kernel to backported 5.7), then you will need to add backports to your sources list. It is best to do it like this\n\n```\necho 'deb http://deb.debian.org/debian buster-backports main contrib' | sudo tee -a /etc/apt/sources.list.d/debian-backports.list\n```\n\nAlternatively, or in case you have problems with installation of some packages, or you just want to have everything in a single list, here is what my **/etc/apt/sources.list** looks like (you will need to append at least last line to yours)\n\n```\ndeb http://security.debian.org/debian-security buster/updates main contrib\ndeb-src http://security.debian.org/debian-security buster/updates main contrib\n\ndeb http://deb.debian.org/debian/ buster main contrib non-free\ndeb-src http://deb.debian.org/debian/ buster main contrib non-free\n\ndeb http://deb.debian.org/debian buster-backports main contrib\n```\n\nAfter adding backports in one way or another, try **sudo apt update** again, and after that **apt-cache search linux-source** should show kernel 5.8 in the list, so you can install it's source package\n\n```\nsudo apt install linux-source-5.8\n```\n\nand unpack it\n```\navra@vm-debian:~$ cd /usr/src\navra@vm-debian:/usr/src$ sudo tar -xaf linux-source-5.8.tar.xz\navra@vm-debian:/usr/src$ cd linux-source-5.8\n```\n\n\n\n#### 2. Add can-j1939 module to kernel ####\n\nFirst we need some packages for **menuconfig**\n\n```\nsudo apt-get install libncurses5 libncurses5-dev\n```\n\ncopy and use our old configuration to run **menuconfig**\n\n```\navra@vm-debian:/usr/src/linux-source-5.8$ sudo cp /boot/config-$(uname -r) .config\navra@vm-debian:/usr/src/linux-source-5.8$ sudo make menuconfig\n```\n\nwhere we enable SAE  J1939 kernel module as shown\n\n```\n\t- Networking Support\n\t\t- Can bus subsystem support\n\t\t\t- <M> SAE J1939\n```\n\nNow edit **/usr/src/linux-source-5.8/.config**, find CONFIG_SYSTEM_TRUSTED_KEYS, change it as following\n```\nCONFIG_SYSTEM_TRUSTED_KEYS=\"\"\n```\n\nand save the file.\n\n\n\n#### 3. Compile and install kernel and modules\n\nWe will have to download necessary packages\n\n```\nsudo apt install build-essential libssl-dev libelf-dev bison flex\n```\n\ncompile kernel (using threads to make it faster)\n\n```\navra@vm-debian:/usr/src/linux-source-5.8$ sudo make -j $(nproc)\n```\n\ninstall\n\n```\navra@vm-debian:/usr/src/linux-source-5.8$ sudo make modules_install\navra@vm-debian:/usr/src/linux-source-5.8$ sudo make install\n```\n\nand update grub\n\n```\navra@vm-debian:/usr/src/linux-source-5.8$ sudo update-grub\navra@vm-debian:/usr/src/linux-source-5.8$ sudo reboot\n```\n\nCheck if installation is correct with\n\n```\nsudo modprobe can-j1939\n```\n\nand if you get no error then you can enjoy **can-j1939**. If you get some error then you might check if this alternative command works:\n\n```\nsudo insmod /lib/modules/5.8.10/kernel/net/can/j1939/can-j1939.ko\n```\n\nIf it does then all you need to do is\n\n```\nsudo depmod -av\n```\n\nreboot once, and **modprobe** command from the above should finally work.\n\n\n\n#### 4. Install headers if needed\n\nYou might have a problem with headers not being updated. To check that open file **/usr/include/linux/can.h** with\n\n```\nnano /usr/include/linux/can.h\n```\n\nIf in the struct **sockaddr_can** you don’t see **j1939**, then header files did not upgrade and you need to do it manually\n\n```\nsudo cp /usr/src/linux-source-5.8/include/uapi/linux/can.h /usr/include/linux/can.h\nsudo cp /usr/src/linux-source-5.8/include/uapi/linux/can/j1939.h /usr/include/linux/can/\n```\n\nThat is the minimum for compiling some **J1939** C code, but you might want to upgrade other header files as well. That's up to you. Enjoy!\n"
        },
        {
          "name": "can-j1939-kickstart.md",
          "type": "blob",
          "size": 4.224609375,
          "content": "# Kickstart guide to can-j1939 on linux\n\n## Prepare using VCAN\n\nYou may skip this step entirely if you have a functional\n**can0** bus on your system.\n\nLoad module, when *vcan* is not in-kernel\n\n\tmodprobe vcan\n\nCreate a virtual can0 device and start the device\n\n\tip link add can0 type vcan\n\tip link set can0 up\n\n## First steps with j1939\n\nUse [testj1939](testj1939.c)\n\nWhen *can-j1939* is compiled as module, opening a socket will load it,\n__or__ you can load it manually\n\n\tmodprobe can-j1939\n\nMost of the subsequent examples will use 2 sockets programs (in 2 terminals).\nOne will use CAN_J1939 sockets using *testj1939*,\nand the other will use CAN_RAW sockets using cansend+candump.\n\ntestj1939 can be told to print the used API calls by adding **-v** program argument.\n\n### receive without source address\n\nDo in terminal 1\n\n\ttestj1939 -B -r can0\n\nSend raw CAN in terminal 2\n\n\tcansend can0 1823ff40#0123\n\nYou should have this output in terminal 1\n\n\t40 02300: 01 23\n\nThis means, from NAME 0, SA 40, PGN 02300 was received,\nwith 2 databytes, *01* & *23*.\n\nnow emit this CAN message:\n\n\tcansend can0 18234140#0123\n\nIn J1939, this means that ECU 0x40 sends directly to ECU 0x41\nSince we did not bind to address 0x41, this traffic\nis not meant for us and *testj1939* does not receive it.\n\n### receive with source address\n\nTerminal 1:\n\n\ttestj1939 -r can0:0x80\n\nTerminal 2:\n\n\tcansend can0 18238040#0123\n\nWill emit this output\n\n\t40 02300: 01 23\n\nThis is because the traffic had destination address __0x80__ .\n\n### send\n\nOpen in terminal 1:\n\n\tcandump -L can0\n\nAnd to these test in another terminal\n\n\ttestj1939 -B -s can0:0x80 can0:,0x3ffff\n\nThis produces **1BFFFF80#0123456789ABCDEF** on CAN.\n\nNote: To be able to send a broadcast we need to use, we need to use \"-B\" flag.\n\n### Multiple source addresses on 1 CAN device\n\n\ttestj1939 -B -s can0:0x90 can0:,0x3ffff\n\nproduces **1BFFFF90#0123456789ABCDEF** ,\n\n### Use PDU1 PGN\n\n\ttestj1939 -B -s can0:0x80 can0:,0x12300\n\nemits **1923FF80#0123456789ABCDEF** .\n\nNote that the PGN is **0x12300**, and destination address is **0xff**.\n\n### Use destination address info\n\nSince in this example we use unicast source and destination addresses, we do\nnot need to use \"-B\" (broadcast) flag.\n\nThe destination field may be set during sendto().\n*testj1939* implements that like this\n\n\ttestj1939 -s can0:0x80 can0:0x40,0x12300\n\nemits **19234080#0123456789ABCDEF** .\n\nThe destination CAN iface __must__ always match the source CAN iface.\nSpecifying one during bind is therefore sufficient.\n\n\ttestj1939 -s can0:0x80 :0x40,0x12300\n\nemits the very same.\n\n### Emit different PGNs using the same socket\n\nThe PGN is provided in both __bind( *sockname* )__ and\n__sendto( *peername* )__ , and only one is used.\n*peername* PGN has highest precedence.\n\nFor broadcasted transmissions\n\n\ttestj1939 -B -s can0:0x80 :,0x32100\n\nemits **1B21FF80#0123456789ABCDEF**\n\nDestination specific transmissions\n\n\ttestj1939 -s can0:0x80,0x12300 :0x40,0x32100\n\nemits **1B214080#0123456789ABCDEF** .\n\nIt makes sometimes sense to omit the PGN in __bind( *sockname* )__ .\n\n### Larger packets\n\nJ1939 transparently switches to *Transport Protocol* when packets\ndo not fit into single CAN packets.\n\n\ttestj1939 -B -s20 can0:0x80 :,0x12300\n\nemits:\n\n\t18ECFF80#20140003FF002301\n\t18EBFF80#010123456789ABCD\n\t18EBFF80#02EF0123456789AB\n\t18EBFF80#03CDEF01234567FF\n\nThe fragments for broadcasted *Transport Protocol* are separated\n__50ms__ from each other.\nDestination specific *Transport Protocol* applies flow control\nand may emit CAN packets much faster.\n\nFirst assign 0x90 to the local system.\nThis becomes important because the kernel must interact in the\ntransport protocol sessions before the complete packet is delivered.\n\n\ttestj1939 can0:0x90 -r &\n\nNow test:\n\n\ttestj1939 -s20 can0:0x80 :0x90,0x12300\n\nemits:\n\n\t18EC9080#1014000303002301\n\t18EC8090#110301FFFF002301\n\t18EB9080#010123456789ABCD\n\t18EB9080#02EF0123456789AB\n\t18EB9080#03CDEF01234567FF\n\t18EC8090#13140003FF002301\n\nThe flow control causes a bit overhead.\nThis overhead scales very good for larger J1939 packets.\n\n## Advanced topics with j1939\n\n### Change priority of J1939 packets\n\n\ttestj1939 -B -s can0:0x80 :,0x0100\n\ttestj1939 -B -s -p3 can0:0x80 :,0x0200\n\nemits\n\n\t1801FF80#0123456789ABCDEF\n\t0C02FF80#0123456789ABCDEF\n\n### using connect\n\n### advanced filtering\n\n## dynamic addressing\n"
        },
        {
          "name": "can-j1939.md",
          "type": "blob",
          "size": 2.2900390625,
          "content": "# CAN-J1939 on linux\n\nThe [Kickstart guide is here](can-j1939-kickstart.md)\n\n## CAN on linux\n\nSee [Wikipedia:socketcan](http://en.wikipedia.org/wiki/Socketcan)\n\n## J1939 networking in short\n\n* Add addressing on top of CAN (destination address & broadcast)\n\n* Any (max 1780) length packets.\n  Packets of 9 or more use **Transport Protocol** (fragmentation)\n  Such packets use different CANid for the same PGN.\n\n* only **29**bit, non-**RTR** CAN frames\n\n* CAN id is composed of\n  * 0..8: SA (source address)\n  * 9..26:\n    * PDU1: PGN+DA (destination address)\n    * PDU2: PGN\n  * 27..29: PRIO\n\n* SA / DA may be dynamically assigned via j1939-81\n  Fixed rules of precedence in Specification, no master necessary\n\n## J1939 on SocketCAN\n\nJ1939 is *just another protocol* that fits\nin the Berkely sockets.\n\n\tsocket(AF_CAN, SOCK_DGRAM, CAN_J1939)\n\n## differences from CAN_RAW\n### addressing\n\nSA, DA & PGN are used, not CAN id.\n\nBerkeley socket API is used to communicate these to userspace:\n\n  * SA+PGN is put in sockname ([getsockname](http://man7.org/linux/man-pages/man2/getsockname.2.html))\n  * DA+PGN is put in peername ([getpeername](http://man7.org/linux/man-pages/man2/getpeername.2.html))\n    PGN is put in both structs\n\nPRIO is a datalink property, and irrelevant for interpretation\nTherefore, PRIO is not in *sockname* or *peername*.\n\nThe *data* that is [recv][recvfrom] or [send][sendto] is the real payload.\nUnlike CAN_RAW, where addressing info is data.\n\n### Packet size\n\nJ1939 handles packets of 8+ bytes with **Transport Protocol** fragmentation transparently.\nNo fixed data size is necessary.\n\n\tsend(sock, data, 8, 0);\n\nwill emit a single CAN frame.\n\n\tsend(sock, data, 9, 0);\n\nwill use fragmentation, emitting 1+ CAN frames.\n\n# Using J1939\n\n## BSD socket implementation\n* socket\n* bind / connect\n* recvfrom / sendto\n* getsockname / getpeername\n\n## Modified *struct sockaddr_can*\n\n\tstruct sockaddr_can {\n\t\tsa_family_t can_family;\n\t\tint         can_ifindex;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\t__u64 name;\n\t\t\t\t__u32 pgn;\n\t\t\t\t__u8 addr;\n\t\t\t} j1939;\n\t\t} can_addr;\n\t}\n\n* *can_addr.j1939.pgn* is PGN\n\n* *can_addr.j1939.addr* & *can_addr.j1939.name*\n  determine the ECU\n\n  * receiving address information,\n    *addr* is always set,\n    *name* is set when available.\n\n  * When providing address information,\n    *name* != 0 indicates dynamic addressing\n"
        },
        {
          "name": "can-tc-init-etf.sh",
          "type": "blob",
          "size": 1.0009765625,
          "content": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0-only\n# Copyright (C) 2022 Pengutronix, Marc Kleine-Budde <kernel@pengutronix.de>\n#\n# This script requires a kernel compiled with the following options:\n#\n# CONFIG_NET_SCH_PRIO\n# CONFIG_NET_SCH_ETF\n# CONFIG_NET_CLS_BASIC\n# CONFIG_NET_CLS_FW\n# CONFIG_NET_EMATCH\n# CONFIG_NET_EMATCH_CANID\n#\n\nset -e\n\nIFACE=${1:-can0}\nMARK=${2:-1}\n\nclear() {\n    tc -batch - <<EOF\n\nqdisc replace dev ${IFACE} root pfifo_fast\n\nEOF\n}\n\nshow() {\n    tc -batch - <<EOF\n\nqdisc show dev ${IFACE}\nfilter show dev ${IFACE}\n\nEOF\n}\n\nprio_etf_mark() {\n    tc -batch - <<EOF\n\nqdisc replace dev ${IFACE} parent root handle 100 prio \\\n\tbands 3\n\nqdisc replace dev ${IFACE} handle 1001 parent 100:1 etf clockid CLOCK_TAI \\\n\tdelta 200000\n\nqdisc replace dev ${IFACE} handle 1002 parent 100:3 pfifo_fast\n\nfilter add dev ${IFACE} parent 100: prio 1 \\\n\thandle ${MARK} fw flowid 100:1\n\nfilter add dev ${IFACE} parent 100: prio 2 \\\n\tbasic match canid (sff 0x0:0x0 eff 0x0:0x0) flowid 100:2\n\nEOF\n}\n\nclear\nprio_etf_mark\nshow\n"
        },
        {
          "name": "canbusload.c",
          "type": "blob",
          "size": 14.1337890625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * canbusload.c - monitor CAN bus load\n *\n * Copyright (c) 2002-2008 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <ctype.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n\n#include \"lib.h\"\n#include \"terminal.h\"\n#include \"canframelen.h\"\n\n#define ANYDEV \"any\" /* name of interface to receive from any CAN interface */\n#define MAXDEVS 20   /* max. number of CAN interfaces given on the cmdline */\n\n#define PERCENTRES 5 /* resolution in percent for bargraph */\n#define NUMBAR (100 / PERCENTRES) /* number of bargraph elements */\n#define BRSTRLEN 20\n\nextern int optind, opterr, optopt;\n\nstatic struct {\n\tchar devname[IFNAMSIZ + 1];\n\tchar bitratestr[BRSTRLEN]; /* 100000/2000000 => 100k/2M */\n\tchar recv_direction;\n\tint ifindex;\n\tunsigned int bitrate;\n\tunsigned int dbitrate;\n\tunsigned int recv_frames;\n\tunsigned int recv_bits_total;\n\tunsigned int recv_bits_payload;\n\tunsigned int recv_bits_dbitrate;\n} stat[MAXDEVS + 1];\n\nstatic volatile int running = 1;\nstatic volatile sig_atomic_t signal_num;\nstatic int max_devname_len; /* to prevent frazzled device name output */\nstatic int max_bitratestr_len;\nstatic int currmax;\nstatic unsigned char redraw;\nstatic unsigned char timestamp;\nstatic unsigned char color;\nstatic unsigned char bargraph;\nstatic enum cfl_mode mode = CFL_WORSTCASE;\nstatic char *prg;\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - monitor CAN bus load.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>+\\n\", prg);\n\tfprintf(stderr, \"  (use CTRL-C to terminate %s)\\n\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -t  (show current time on the first line)\\n\");\n\tfprintf(stderr, \"         -c  (colorize lines)\\n\");\n\tfprintf(stderr, \"         -b  (show bargraph in %d%% resolution)\\n\", PERCENTRES);\n\tfprintf(stderr, \"         -r  (redraw the terminal - similar to top)\\n\");\n\tfprintf(stderr, \"         -i  (ignore bitstuffing in bandwidth calculation)\\n\");\n\tfprintf(stderr, \"         -e  (exact calculation of stuffed bits)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Up to %d CAN interfaces with mandatory bitrate can be specified on the \\n\", MAXDEVS);\n\tfprintf(stderr, \"commandline in the form: <ifname>@<bitrate>[,<dbitrate>]\\n\");\n\tfprintf(stderr, \"The interface name 'any' enables an auto detection with the given bitrate[s]\\n\\n\");\n\tfprintf(stderr, \"The bitrate is mandatory as it is needed to know the CAN bus bitrate to\\n\");\n\tfprintf(stderr, \"calculate the bus load percentage based on the received CAN frames.\\n\");\n\tfprintf(stderr, \"Due to the bitstuffing estimation the calculated busload may exceed 100%%.\\n\");\n\tfprintf(stderr, \"For each given interface the data is presented in one line which contains:\\n\\n\");\n\tfprintf(stderr, \"(interface) (received CAN frames) (bits total) (bits payload) (bits payload brs)\\n\");\n\tfprintf(stderr, \"\\nExamples:\\n\");\n\tfprintf(stderr, \"\\nuser$> canbusload can0@100000 can1@500000,2000000 can2@500000 -r -t -b -c\\n\\n\");\n\tfprintf(stderr, \"%s 2024-08-08 16:30:05 (worst case bitstuffing)\\n\", prg);\n\tfprintf(stderr, \" can0@100k      192   21980    9136       0  21%% |TTTT................|\\n\");\n\tfprintf(stderr, \" can1@500k/2M  2651  475500  234448  131825  74%% |XXXXXXXXXXXXXX......|\\n\");\n\tfprintf(stderr, \" can2@500k      855  136777   62968   35219  27%% |RRRRR...............|\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic void sigterm(int signo)\n{\n\trunning = 0;\n\tsignal_num = signo;\n}\n\nstatic int add_bitrate(char *brstr, unsigned int bitrate)\n{\n\tif (bitrate % 1000000 == 0)\n\t\treturn sprintf(brstr, \"%dM\", bitrate / 1000000);\n\n\tif (bitrate % 1000 == 0)\n\t\treturn sprintf(brstr, \"%dk\", bitrate / 1000);\n\n\treturn sprintf(brstr, \"%d\", bitrate);\n}\n\nstatic void create_bitrate_string(int stat_idx, int *max_bitratestr_len)\n{\n\tint ptr;\n\n\tptr = add_bitrate(&stat[stat_idx].bitratestr[0], stat[stat_idx].bitrate);\n\n\tif (stat[stat_idx].bitrate != stat[stat_idx].dbitrate) {\n\t\tptr += sprintf(&stat[stat_idx].bitratestr[ptr], \"/\");\n\t\tptr += add_bitrate(&stat[stat_idx].bitratestr[ptr], stat[stat_idx].dbitrate);\n\t}\n\n\tif (ptr > *max_bitratestr_len)\n\t\t*max_bitratestr_len = ptr;\n}\n\nstatic void printstats(int signo)\n{\n\tint i, j, percent;\n\n\tif (redraw)\n\t\tprintf(\"%s\", CSR_HOME);\n\n\tif (timestamp) {\n\t\ttime_t currtime;\n\t\tstruct tm now;\n\n\t\tif (time(&currtime) == (time_t)-1) {\n\t\t\tperror(\"time\");\n\t\t\texit(1);\n\t\t}\n\n\t\tlocaltime_r(&currtime, &now);\n\n\t\tprintf(\"%s %04d-%02d-%02d %02d:%02d:%02d \",\n\t\t       prg,\n\t\t       now.tm_year + 1900,\n\t\t       now.tm_mon + 1,\n\t\t       now.tm_mday,\n\t\t       now.tm_hour,\n\t\t       now.tm_min,\n\t\t       now.tm_sec);\n\n\t\tswitch (mode) {\n\n\t\tcase CFL_NO_BITSTUFFING:\n\t\t\t/* plain bit calculation without bitstuffing */\n\t\t\tprintf(\"(ignore bitstuffing)\\n\");\n\t\t\tbreak;\n\n\t\tcase CFL_WORSTCASE:\n\t\t\t/* worst case estimation - see above */\n\t\t\tprintf(\"(worst case bitstuffing)\\n\");\n\t\t\tbreak;\n\n\t\tcase CFL_EXACT:\n\t\t\t/* exact calculation of stuffed bits based on frame content and CRC */\n\t\t\tprintf(\"(exact bitstuffing)\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"(unknown bitstuffing)\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < currmax; i++) {\n\t\tif (color) {\n\t\t\tif (i % 2)\n\t\t\t\tprintf(\"%s\", FGRED);\n\t\t\telse\n\t\t\t\tprintf(\"%s\", FGBLUE);\n\t\t}\n\n\t\tif (stat[i].bitrate)\n\t\t\tpercent = ((stat[i].recv_bits_total - stat[i].recv_bits_dbitrate) * 100) / stat[i].bitrate +\n\t\t\t\t(stat[i].recv_bits_dbitrate * 100) / stat[i].dbitrate;\n\t\telse\n\t\t\tpercent = 0;\n\n\t\tprintf(\" %*s@%-*s %5d %7d %7d %7d %3d%%\",\n\t\t       max_devname_len, stat[i].devname,\n\t\t       max_bitratestr_len, stat[i].bitratestr,\n\t\t       stat[i].recv_frames,\n\t\t       stat[i].recv_bits_total,\n\t\t       stat[i].recv_bits_payload,\n\t\t       stat[i].recv_bits_dbitrate,\n\t\t       percent);\n\n\t\tif (bargraph) {\n\n\t\t\tprintf(\" |\");\n\n\t\t\tif (percent > 100)\n\t\t\t\tpercent = 100;\n\n\t\t\tfor (j = 0; j < NUMBAR; j++) {\n\t\t\t\tif (j < percent / PERCENTRES)\n\t\t\t\t\tprintf(\"%c\", stat[i].recv_direction);\n\t\t\t\telse\n\t\t\t\t\tprintf(\".\");\n\t\t\t}\n\n\t\t\tprintf(\"|\");\n\t\t}\n\n\t\tif (color)\n\t\t\tprintf(\"%s\", ATTRESET);\n\n\t\tif (!redraw || (i < currmax - 1))\n\t\t\tprintf(\"\\n\");\n\n\t\tstat[i].recv_frames = 0;\n\t\tstat[i].recv_bits_total = 0;\n\t\tstat[i].recv_bits_dbitrate = 0;\n\t\tstat[i].recv_bits_payload = 0;\n\t\tstat[i].recv_direction = '.';\n\t}\n\n\tif (!redraw)\n\t\tprintf(\"\\n\");\n\n\tfflush(stdout);\n\n\talarm(1);\n}\n\nint main(int argc, char **argv)\n{\n\tfd_set rdfs;\n\tint s;\n\tint opt;\n\tchar *ptr, *nptr;\n\tstruct sockaddr_can addr;\n\tstruct canfd_frame frame;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tint nbytes, i;\n\n\tint have_anydev = 0;\n\tunsigned int anydev_bitrate = 0;\n\tunsigned int anydev_dbitrate = 0;\n\tchar anydev_bitratestr[BRSTRLEN]; /* 100000/2000000 => 100k/2M */\n\n\tsignal(SIGTERM, sigterm);\n\tsignal(SIGHUP, sigterm);\n\tsignal(SIGINT, sigterm);\n\n\tsignal(SIGALRM, printstats);\n\n\tprg = basename(argv[0]);\n\n\twhile ((opt = getopt(argc, argv, \"rtbcieh?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'r':\n\t\t\tredraw = 1;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\ttimestamp = 1;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tbargraph = 1;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tcolor = 1;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tmode = CFL_NO_BITSTUFFING;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tmode = CFL_EXACT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprint_usage(prg);\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind == argc) {\n\t\tprint_usage(prg);\n\t\texit(0);\n\t}\n\n\tcurrmax = argc - optind; /* find real number of CAN devices */\n\n\tif (currmax > MAXDEVS) {\n\t\tprintf(\"More than %d CAN devices given on commandline!\\n\", MAXDEVS);\n\t\treturn 1;\n\t}\n\n\t/* prefill stat[] array with given interface assignments */\n\tfor (i = 0; i < currmax; i++) {\n\t\tptr = argv[optind + i + have_anydev];\n\n\t\tnbytes = strlen(ptr);\n\t\tif (nbytes >= (int)(IFNAMSIZ + sizeof(\"@1000000,2000000\") + 1)) {\n\t\t\tprintf(\"name of CAN device '%s' is too long!\\n\", ptr);\n\t\t\treturn 1;\n\t\t}\n\n\t\tpr_debug(\"handle %d '%s'.\\n\", i, ptr);\n\n\t\tnptr = strchr(ptr, '@');\n\n\t\tif (!nptr) {\n\t\t\tfprintf(stderr, \"Specify CAN interfaces in the form <CAN interface>@<bitrate>, e.g. can0@500000\\n\");\n\t\t\tprint_usage(prg);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* interface name length */\n\t\tnbytes = nptr - ptr;  /* interface name is up the first '@' */\n\t\tif (nbytes >= (int)IFNAMSIZ) {\n\t\t\tprintf(\"name of CAN device '%s' is too long!\\n\", ptr);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* copy interface name to stat[] entry */\n\t\tstrncpy(stat[i].devname, ptr, nbytes);\n\n\t\tif (nbytes > max_devname_len)\n\t\t\tmax_devname_len = nbytes; /* for nice printing */\n\n\t\tchar *endp;\n\t\t /* bitrate is placed behind the '@' */\n\t\tstat[i].bitrate = strtol(nptr + 1, &endp, 0);\n\n\t\t/* check for CAN FD additional data bitrate */\n\t\tif (*endp == ',')\n\t\t\t/* data bitrate is placed behind the ',' */\n\t\t\tstat[i].dbitrate = strtol(endp + 1, &endp, 0);\n\t\telse\n\t\t\tstat[i].dbitrate = stat[i].bitrate;\n\n\t\tif (!stat[i].bitrate || stat[i].bitrate > 1000000 ||\n\t\t    !stat[i].dbitrate || stat[i].dbitrate > 8000000) {\n\t\t\tprintf(\"invalid bitrate for CAN device '%s'!\\n\", ptr);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* prepare bitrate string for hot path */\n\t\tcreate_bitrate_string(i, &max_bitratestr_len);\n\n\t\tstat[i].recv_direction = '.';\n\n\t\t/* handling for 'any' device */\n\t\tif (have_anydev == 0 && strcmp(ANYDEV, stat[i].devname) == 0) {\n\t\t\tanydev_bitrate = stat[i].bitrate;\n\t\t\tanydev_dbitrate = stat[i].dbitrate;\n\t\t\tmemcpy(anydev_bitratestr, stat[i].bitratestr, BRSTRLEN);\n\t\t\t/* no real interface: remove this command line entry */\n\t\t\thave_anydev = 1;\n\t\t\tcurrmax--;\n\t\t\ti--;\n\t\t} else {\n\t\t\tstat[i].ifindex = if_nametoindex(stat[i].devname);\n\t\t\tif (!stat[i].ifindex) {\n\t\t\t\tprintf(\"invalid CAN device '%s'!\\n\", stat[i].devname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tpr_debug(\"using interface name '%s'.\\n\", stat[i].devname);\n\t\t}\n\t}\n\n\ts = socket(PF_CAN, SOCK_RAW, CAN_RAW);\n\tif (s < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\t/* try to switch the socket into CAN FD mode */\n\tconst int canfd_on = 1;\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = 0; /* any CAN device */\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\treturn 1;\n\t}\n\n\talarm(1);\n\n\tif (redraw)\n\t\tprintf(\"%s\", CLR_SCREEN);\n\n\t/* these settings are static and can be held out of the hot path */\n\tiov.iov_base = &frame;\n\tmsg.msg_name = &addr;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = NULL;\n\n\twhile (running) {\n\t\tFD_ZERO(&rdfs);\n\t\tFD_SET(s, &rdfs);\n\n\t\tif (select(s + 1, &rdfs, NULL, NULL, NULL) < 0) {\n\t\t\t//perror(\"pselect\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* these settings may be modified by recvmsg() */\n\t\tiov.iov_len = sizeof(frame);\n\t\tmsg.msg_namelen = sizeof(addr);\n\t\tmsg.msg_controllen = 0;\n\t\tmsg.msg_flags = 0;\n\n\t\tnbytes = recvmsg(s, &msg, 0);\n\n\t\tif (nbytes < 0) {\n\t\t\tperror(\"read\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (nbytes != (int)sizeof(struct can_frame) &&\n\t\t    nbytes != (int)sizeof(struct canfd_frame)) {\n\t\t\tfprintf(stderr, \"read: incomplete CAN frame\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* find received ifindex in stat[] array */\n\t\tfor (i = 0; i < currmax; i++) {\n\t\t\tif (stat[i].ifindex == addr.can_ifindex)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* not found? check for unknown interface */\n\t\tif (i >= currmax) {\n\t\t\t/* drop unwanted traffic */\n\t\t\tif (have_anydev == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* can we add another interface? */\n\t\t\tif (currmax >= MAXDEVS)\n\t\t\t\tcontinue;\n\n\t\t\t/* add an new entry */\n\t\t\tstat[i].ifindex = addr.can_ifindex;\n\t\t\tstat[i].bitrate = anydev_bitrate;\n\t\t\tstat[i].dbitrate = anydev_dbitrate;\n\t\t\tmemcpy(stat[i].bitratestr, anydev_bitratestr, BRSTRLEN);\n\t\t\tstat[i].recv_direction = '.';\n\t\t\tif_indextoname(addr.can_ifindex, stat[i].devname);\n\t\t\tnbytes = strlen(stat[i].devname);\n\t\t\tif (nbytes > max_devname_len)\n\t\t\t\tmax_devname_len = nbytes; /* for nice printing */\n\t\t\tcurrmax++;\n\t\t}\n\n\t\tif (msg.msg_flags & MSG_DONTROUTE) {\n\t\t\t/* TX direction */\n\t\t\tif (stat[i].recv_direction == '.')\n\t\t\t\tstat[i].recv_direction = 'T';\n\t\t\telse if (stat[i].recv_direction == 'R')\n\t\t\t\tstat[i].recv_direction = 'X';\n\t\t} else {\n\t\t\t/* RX direction */\n\t\t\tif (stat[i].recv_direction == '.')\n\t\t\t\tstat[i].recv_direction = 'R';\n\t\t\telse if (stat[i].recv_direction == 'T')\n\t\t\t\tstat[i].recv_direction = 'X';\n\t\t}\n\n\t\tstat[i].recv_frames++;\n\t\tstat[i].recv_bits_payload += frame.len * 8;\n\t\tstat[i].recv_bits_dbitrate += can_frame_dbitrate_length(\n\t\t\t&frame, mode, sizeof(frame));\n\t\tstat[i].recv_bits_total += can_frame_length(&frame,\n\t\t\t\t\t\t\t    mode, nbytes);\n\t}\n\n\tclose(s);\n\n\tif (signal_num)\n\t\treturn 128 + signal_num;\n\n\treturn 0;\n}\n"
        },
        {
          "name": "candump.c",
          "type": "blob",
          "size": 25.86328125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * candump.c\n *\n * Copyright (c) 2002-2009 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/epoll.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <linux/net_tstamp.h>\n\n#include \"terminal.h\"\n#include \"lib.h\"\n\n/* for hardware timestamps - since Linux 2.6.30 */\n#ifndef SO_TIMESTAMPING\n#define SO_TIMESTAMPING 37\n#endif\n\n#define TIMESTAMPSZ 50 /* string 'absolute with date' requires max 49 bytes */\n\n#define MAXSOCK 16 /* max. number of CAN interfaces given on the cmdline */\n#define MAXIFNAMES 30 /* size of receive name index to omit ioctls */\n#define MAXCOL 6 /* number of different colors for colorized output */\n#define ANYDEV \"any\" /* name of interface to receive from any CAN interface */\n#define ANL \"\\r\\n\" /* newline in ASC mode */\n\n#define SILENT_INI 42 /* detect user setting on commandline */\n#define SILENT_OFF 0 /* no silent mode */\n#define SILENT_ANI 1 /* silent mode with animation */\n#define SILENT_ON 2 /* silent mode (completely silent) */\n\n#define BOLD ATTBOLD\n#define RED (ATTBOLD FGRED)\n#define GREEN (ATTBOLD FGGREEN)\n#define YELLOW (ATTBOLD FGYELLOW)\n#define BLUE (ATTBOLD FGBLUE)\n#define MAGENTA (ATTBOLD FGMAGENTA)\n#define CYAN (ATTBOLD FGCYAN)\n\nstatic const char col_on[MAXCOL][19] = { BLUE, RED, GREEN, BOLD, MAGENTA, CYAN };\nstatic const char col_off[] = ATTRESET;\n\nstruct if_info { /* bundled information per open socket */\n\tint s; /* socket */\n\tchar *cmdlinename;\n\t__u32 dropcnt;\n\t__u32 last_dropcnt;\n};\nstatic struct if_info sock_info[MAXSOCK];\n\nstatic char *progname;\nstatic char devname[MAXIFNAMES][IFNAMSIZ + 1];\nstatic int dindex[MAXIFNAMES];\nstatic int max_devname_len; /* to prevent frazzled device name output */\nstatic const int canfx_on = 1;\n\n#define MAXANI 4\nstatic const char anichar[MAXANI] = { '|', '/', '-', '\\\\' };\nstatic const char extra_m_info[4][4] = { \"- -\", \"B -\", \"- E\", \"B E\" };\n\nextern int optind, opterr, optopt;\n\nstatic volatile int running = 1;\nstatic volatile sig_atomic_t signal_num;\n\nstatic void print_usage(void)\n{\n\tfprintf(stderr, \"%s - dump CAN bus traffic.\\n\", progname);\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>+\\n\", progname);\n\tfprintf(stderr, \"  (use CTRL-C to terminate %s)\\n\\n\", progname);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -t <type>   (timestamp: (a)bsolute/(d)elta/(z)ero/(A)bsolute w date)\\n\");\n\tfprintf(stderr, \"         -H          (read hardware timestamps instead of system timestamps)\\n\");\n\tfprintf(stderr, \"         -c          (increment color mode level)\\n\");\n\tfprintf(stderr, \"         -i          (binary output - may exceed 80 chars/line)\\n\");\n\tfprintf(stderr, \"         -a          (enable additional ASCII output)\\n\");\n\tfprintf(stderr, \"         -S          (swap byte order in printed CAN data[] - marked with '%c' )\\n\", SWAP_DELIMITER);\n\tfprintf(stderr, \"         -s <level>  (silent mode - %d: off (default) %d: animation %d: silent)\\n\", SILENT_OFF, SILENT_ANI, SILENT_ON);\n\tfprintf(stderr, \"         -l          (log CAN-frames into file. Sets '-s %d' by default)\\n\", SILENT_ON);\n\tfprintf(stderr, \"         -f <fname>  (log CAN-frames into file <fname>. Sets '-s %d' by default)\\n\", SILENT_ON);\n\tfprintf(stderr, \"         -L          (use log file format on stdout)\\n\");\n\tfprintf(stderr, \"         -n <count>  (terminate after reception of <count> CAN frames)\\n\");\n\tfprintf(stderr, \"         -r <size>   (set socket receive buffer to <size>)\\n\");\n\tfprintf(stderr, \"         -D          (Don't exit if a \\\"detected\\\" can device goes down)\\n\");\n\tfprintf(stderr, \"         -d          (monitor dropped CAN frames)\\n\");\n\tfprintf(stderr, \"         -e          (dump CAN error frames in human-readable format)\\n\");\n\tfprintf(stderr, \"         -8          (display raw DLC values in {} for Classical CAN)\\n\");\n\tfprintf(stderr, \"         -x          (print extra message infos, rx/tx brs esi)\\n\");\n\tfprintf(stderr, \"         -T <msecs>  (terminate after <msecs> if no frames were received)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Up to %d CAN interfaces with optional filter sets can be specified\\n\", MAXSOCK);\n\tfprintf(stderr, \"on the commandline in the form: <ifname>[,filter]*\\n\");\n\tfprintf(stderr, \"\\nFilters:\\n\");\n\tfprintf(stderr, \"  Comma separated filters can be specified for each given CAN interface:\\n\");\n\tfprintf(stderr, \"    <can_id>:<can_mask>\\n         (matches when <received_can_id> & mask == can_id & mask)\\n\");\n\tfprintf(stderr, \"    <can_id>~<can_mask>\\n         (matches when <received_can_id> & mask != can_id & mask)\\n\");\n\tfprintf(stderr, \"    #<error_mask>\\n         (set error frame filter, see include/linux/can/error.h)\\n\");\n\tfprintf(stderr, \"    [j|J]\\n         (join the given CAN filters - logical AND semantic)\\n\");\n\tfprintf(stderr, \"\\nCAN IDs, masks and data content are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"When the can_id is 8 digits long the CAN_EFF_FLAG is set for 29 bit EFF format.\\n\");\n\tfprintf(stderr, \"Without any given filter all data frames are received ('0:0' default filter).\\n\");\n\tfprintf(stderr, \"\\nUse interface name '%s' to receive from all CAN interfaces.\\n\", ANYDEV);\n\tfprintf(stderr, \"\\nExamples:\\n\");\n\tfprintf(stderr, \"%s -c -c -ta can0,123:7FF,400:700,#000000FF can2,400~7F0 can3 can8\\n\\n\", progname);\n\tfprintf(stderr, \"%s -l any,0~0,#FFFFFFFF\\n         (log only error frames but no(!) data frames)\\n\", progname);\n\tfprintf(stderr, \"%s -l any,0:0,#FFFFFFFF\\n         (log error frames and also all data frames)\\n\", progname);\n\tfprintf(stderr, \"%s vcan2,12345678:DFFFFFFF\\n         (match only for extended CAN ID 12345678)\\n\", progname);\n\tfprintf(stderr, \"%s vcan2,123:7FF\\n         (matches CAN ID 123 - including EFF and RTR frames)\\n\", progname);\n\tfprintf(stderr, \"%s vcan2,123:C00007FF\\n         (matches CAN ID 123 - only SFF and non-RTR frames)\\n\", progname);\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic void sigterm(int signo)\n{\n\trunning = 0;\n\tsignal_num = signo;\n}\n\nstatic int idx2dindex(int ifidx, int socket)\n{\n\tint i;\n\tstruct ifreq ifr;\n\n\tfor (i = 0; i < MAXIFNAMES; i++) {\n\t\tif (dindex[i] == ifidx)\n\t\t\treturn i;\n\t}\n\n\t/* create new interface index cache entry */\n\n\t/* remove index cache zombies first */\n\tfor (i = 0; i < MAXIFNAMES; i++) {\n\t\tif (dindex[i]) {\n\t\t\tifr.ifr_ifindex = dindex[i];\n\t\t\tif (ioctl(socket, SIOCGIFNAME, &ifr) < 0)\n\t\t\t\tdindex[i] = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAXIFNAMES; i++)\n\t\tif (!dindex[i]) /* free entry */\n\t\t\tbreak;\n\n\tif (i == MAXIFNAMES) {\n\t\tfprintf(stderr, \"Interface index cache only supports %d interfaces.\\n\",\n\t\t\tMAXIFNAMES);\n\t\texit(1);\n\t}\n\n\tdindex[i] = ifidx;\n\n\tifr.ifr_ifindex = ifidx;\n\tif (ioctl(socket, SIOCGIFNAME, &ifr) < 0)\n\t\tperror(\"SIOCGIFNAME\");\n\n\tif (max_devname_len < (int)strlen(ifr.ifr_name))\n\t\tmax_devname_len = strlen(ifr.ifr_name);\n\n\tstrcpy(devname[i], ifr.ifr_name);\n\n\tpr_debug(\"new index %d (%s)\\n\", i, devname[i]);\n\n\treturn i;\n}\n\nstatic int sprint_timestamp(char *ts_buffer, const char timestamp,\n\t\t\t    const struct timeval *tv, struct timeval *const last_tv)\n{\n\tint numchars = 0;\n\n\tswitch (timestamp) {\n\tcase 'a': /* absolute with timestamp */\n\t\tnumchars = sprintf(ts_buffer, \"(%010llu.%06llu) \",\n\t\t\t\t   (unsigned long long)tv->tv_sec,\n\t\t\t\t   (unsigned long long)tv->tv_usec);\n\t\tbreak;\n\n\tcase 'A': /* absolute with date */\n\t{\n\t\tstruct tm tm;\n\t\tchar timestring[25];\n\n\t\ttm = *localtime(&tv->tv_sec);\n\t\tstrftime(timestring, 24, \"%Y-%m-%d %H:%M:%S\", &tm);\n\t\tnumchars = sprintf(ts_buffer, \"(%s.%06llu) \", timestring,\n\t\t\t\t   (unsigned long long)tv->tv_usec);\n\t}\n\tbreak;\n\n\tcase 'd': /* delta */\n\tcase 'z': /* starting with zero */\n\t{\n\t\tstruct timeval diff;\n\n\t\tif (last_tv->tv_sec == 0) /* first init */\n\t\t\t*last_tv = *tv;\n\t\tdiff.tv_sec = tv->tv_sec - last_tv->tv_sec;\n\t\tdiff.tv_usec = tv->tv_usec - last_tv->tv_usec;\n\t\tif (diff.tv_usec < 0)\n\t\t\tdiff.tv_sec--, diff.tv_usec += 1000000;\n\t\tif (diff.tv_sec < 0)\n\t\t\tdiff.tv_sec = diff.tv_usec = 0;\n\t\tnumchars = sprintf(ts_buffer, \"(%03llu.%06llu) \",\n\t\t\t\t   (unsigned long long)diff.tv_sec,\n\t\t\t\t   (unsigned long long)diff.tv_usec);\n\n\t\tif (timestamp == 'd')\n\t\t\t*last_tv = *tv; /* update for delta calculation */\n\t}\n\tbreak;\n\n\tdefault: /* no timestamp output */\n\t\tbreak;\n\t}\n\n\tif (numchars <= 0) {\n\t\tts_buffer[0] = 0; /* empty terminated string */\n\t\tnumchars = 0;\n\t}\n\n\treturn numchars;\n}\n\nint main(int argc, char **argv)\n{\n\tint fd_epoll;\n\tstruct epoll_event events_pending[MAXSOCK];\n\tstruct epoll_event event_setup = {\n\t\t.events = EPOLLIN, /* prepare the common part */\n\t};\n\tunsigned char timestamp = 0;\n\tunsigned char logtimestamp = 'a';\n\tunsigned char hwtimestamp = 0;\n\tunsigned char down_causes_exit = 1;\n\tunsigned char dropmonitor = 0;\n\tunsigned char extra_msg_info = 0;\n\tunsigned char silent = SILENT_INI;\n\tunsigned char silentani = 0;\n\tunsigned char color = 0;\n\tunsigned char view = 0;\n\tunsigned char log = 0;\n\tunsigned char logfrmt = 0;\n\tint count = 0;\n\tint rcvbuf_size = 0;\n\tint opt, num_events;\n\tint currmax, numfilter;\n\tint join_filter;\n\tchar *ptr, *nptr;\n\tstruct sockaddr_can addr = {\n\t\t.can_family = AF_CAN,\n\t};\n\tstruct can_raw_vcid_options vcid_opts = {\n\t\t.flags = CAN_RAW_XL_VCID_RX_FILTER,\n\t\t.rx_vcid = 0,\n\t\t.rx_vcid_mask = 0,\n\t};\n\tchar ctrlmsg[CMSG_SPACE(sizeof(struct timeval)) +\n\t\t     CMSG_SPACE(3 * sizeof(struct timespec)) +\n\t\t     CMSG_SPACE(sizeof(__u32))];\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct cmsghdr *cmsg;\n\tstruct can_filter *rfilter;\n\tcan_err_mask_t err_mask;\n\tstatic cu_t cu; /* union for CAN CC/FD/XL frames */\n\tint nbytes, i;\n\tstruct ifreq ifr;\n\tstruct timeval tv, last_tv;\n\tint timeout_ms = -1; /* default to no timeout */\n\tFILE *logfile = NULL;\n\tchar fname[83]; /* suggested by -Wformat-overflow= */\n\tconst char *logname = NULL;\n\tstatic char afrbuf[AFRSZ]; /* ASCII CAN frame buffer size */\n\tstatic int alen;\n\n\tsignal(SIGTERM, sigterm);\n\tsignal(SIGHUP, sigterm);\n\tsignal(SIGINT, sigterm);\n\n\tlast_tv.tv_sec = 0;\n\tlast_tv.tv_usec = 0;\n\n\tprogname = basename(argv[0]);\n\n\twhile ((opt = getopt(argc, argv, \"t:HciaSs:lf:Ln:r:Dde8xT:h?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 't':\n\t\t\ttimestamp = optarg[0];\n\t\t\tlogtimestamp = optarg[0];\n\t\t\tif ((timestamp != 'a') && (timestamp != 'A') &&\n\t\t\t    (timestamp != 'd') && (timestamp != 'z')) {\n\t\t\t\tfprintf(stderr, \"%s: unknown timestamp mode '%c' - ignored\\n\",\n\t\t\t\t\tprogname, optarg[0]);\n\t\t\t\ttimestamp = 0;\n\t\t\t}\n\t\t\tif ((logtimestamp != 'a') && (logtimestamp != 'z')) {\n\t\t\t\tlogtimestamp = 'a';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'H':\n\t\t\thwtimestamp = 1;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tcolor++;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tview |= CANLIB_VIEW_BINARY;\n\t\t\tbreak;\n\n\t\tcase 'a':\n\t\t\tview |= CANLIB_VIEW_ASCII;\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tview |= CANLIB_VIEW_SWAP;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tview |= CANLIB_VIEW_ERROR;\n\t\t\tbreak;\n\n\t\tcase '8':\n\t\t\tview |= CANLIB_VIEW_LEN8_DLC;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tsilent = atoi(optarg);\n\t\t\tif (silent > SILENT_ON) {\n\t\t\t\tprint_usage();\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tlog = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tdown_causes_exit = 0;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdropmonitor = 1;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\textra_msg_info = 1;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tlogfrmt = 1;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tlogname = optarg;\n\t\t\tlog = 1;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tcount = atoi(optarg);\n\t\t\tif (count < 1) {\n\t\t\t\tprint_usage();\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\trcvbuf_size = atoi(optarg);\n\t\t\tif (rcvbuf_size < 1) {\n\t\t\t\tprint_usage();\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'T':\n\t\t\terrno = 0;\n\t\t\ttimeout_ms = strtol(optarg, NULL, 0);\n\t\t\tif (errno != 0) {\n\t\t\t\tprint_usage();\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage();\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind == argc) {\n\t\tprint_usage();\n\t\texit(0);\n\t}\n\n\tif (logfrmt && view) {\n\t\tfprintf(stderr, \"Log file format selected: Please disable ASCII/BINARY/SWAP/RAWDLC options!\\n\");\n\t\texit(0);\n\t}\n\n\t/* \"-f -\"  is equal to \"-L\" (print logfile format on stdout) */\n\tif (log && logname && strcmp(\"-\", logname) == 0) {\n\t\tlog = 0; /* no logging into a file */\n\t\tlogfrmt = 1; /* print logformat output to stdout */\n\t}\n\n\tif (silent == SILENT_INI) {\n\t\tif (log) {\n\t\t\tfprintf(stderr, \"Disabled standard output while logging.\\n\");\n\t\t\tsilent = SILENT_ON; /* disable output on stdout */\n\t\t} else\n\t\t\tsilent = SILENT_OFF; /* default output */\n\t}\n\n\tcurrmax = argc - optind; /* find real number of CAN devices */\n\n\tif (currmax > MAXSOCK) {\n\t\tfprintf(stderr, \"More than %d CAN devices given on commandline!\\n\", MAXSOCK);\n\t\treturn 1;\n\t}\n\n\tfd_epoll = epoll_create(1);\n\tif (fd_epoll < 0) {\n\t\tperror(\"epoll_create\");\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < currmax; i++) {\n\t\tstruct if_info *obj = &sock_info[i];\n\t\tptr = argv[optind + i];\n\t\tnptr = strchr(ptr, ',');\n\n\t\tpr_debug(\"open %d '%s'.\\n\", i, ptr);\n\n\t\tobj->s = socket(PF_CAN, SOCK_RAW, CAN_RAW);\n\t\tif (obj->s < 0) {\n\t\t\tperror(\"socket\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tevent_setup.data.ptr = obj; /* remember the instance as private data */\n\t\tif (epoll_ctl(fd_epoll, EPOLL_CTL_ADD, obj->s, &event_setup)) {\n\t\t\tperror(\"failed to add socket to epoll\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tobj->cmdlinename = ptr; /* save pointer to cmdline name of this socket */\n\n\t\tif (nptr)\n\t\t\tnbytes = nptr - ptr; /* interface name is up the first ',' */\n\t\telse\n\t\t\tnbytes = strlen(ptr); /* no ',' found => no filter definitions */\n\n\t\tif (nbytes >= IFNAMSIZ) {\n\t\t\tfprintf(stderr, \"name of CAN device '%s' is too long!\\n\", ptr);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (nbytes > max_devname_len)\n\t\t\tmax_devname_len = nbytes; /* for nice printing */\n\n\t\tmemset(&ifr.ifr_name, 0, sizeof(ifr.ifr_name));\n\t\tstrncpy(ifr.ifr_name, ptr, nbytes);\n\n\t\tpr_debug(\"using interface name '%s'.\\n\", ifr.ifr_name);\n\n\t\tif (strcmp(ANYDEV, ifr.ifr_name) != 0) {\n\t\t\tif (ioctl(obj->s, SIOCGIFINDEX, &ifr) < 0) {\n\t\t\t\tperror(\"SIOCGIFINDEX\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\taddr.can_ifindex = ifr.ifr_ifindex;\n\t\t} else\n\t\t\taddr.can_ifindex = 0; /* any can interface */\n\n\t\tif (nptr) {\n\t\t\t/* found a ',' after the interface name => check for filters */\n\n\t\t\t/* determine number of filters to alloc the filter space */\n\t\t\tnumfilter = 0;\n\t\t\tptr = nptr;\n\t\t\twhile (ptr) {\n\t\t\t\tnumfilter++;\n\t\t\t\tptr++; /* hop behind the ',' */\n\t\t\t\tptr = strchr(ptr, ','); /* exit condition */\n\t\t\t}\n\n\t\t\trfilter = malloc(sizeof(struct can_filter) * numfilter);\n\t\t\tif (!rfilter) {\n\t\t\t\tfprintf(stderr, \"Failed to create filter space!\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tnumfilter = 0;\n\t\t\terr_mask = 0;\n\t\t\tjoin_filter = 0;\n\n\t\t\twhile (nptr) {\n\n\t\t\t\tptr = nptr + 1; /* hop behind the ',' */\n\t\t\t\tnptr = strchr(ptr, ','); /* update exit condition */\n\n\t\t\t\tif (sscanf(ptr, \"%x:%x\",\n\t\t\t\t\t   &rfilter[numfilter].can_id,\n\t\t\t\t\t   &rfilter[numfilter].can_mask) == 2) {\n\t\t\t\t\trfilter[numfilter].can_mask &= ~CAN_ERR_FLAG;\n\t\t\t\t\tif (*(ptr + 8) == ':')\n\t\t\t\t\t\trfilter[numfilter].can_id |= CAN_EFF_FLAG;\n\t\t\t\t\tnumfilter++;\n\t\t\t\t} else if (sscanf(ptr, \"%x~%x\",\n\t\t\t\t\t\t  &rfilter[numfilter].can_id,\n\t\t\t\t\t\t  &rfilter[numfilter].can_mask) == 2) {\n\t\t\t\t\trfilter[numfilter].can_id |= CAN_INV_FILTER;\n\t\t\t\t\trfilter[numfilter].can_mask &= ~CAN_ERR_FLAG;\n\t\t\t\t\tif (*(ptr + 8) == '~')\n\t\t\t\t\t\trfilter[numfilter].can_id |= CAN_EFF_FLAG;\n\t\t\t\t\tnumfilter++;\n\t\t\t\t} else if (*ptr == 'j' || *ptr == 'J') {\n\t\t\t\t\tjoin_filter = 1;\n\t\t\t\t} else if (sscanf(ptr, \"#%x\", &err_mask) != 1) {\n\t\t\t\t\tfprintf(stderr, \"Error in filter option parsing: '%s'\\n\", ptr);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (err_mask)\n\t\t\t\tsetsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_ERR_FILTER,\n\t\t\t\t\t   &err_mask, sizeof(err_mask));\n\n\t\t\tif (join_filter && setsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_JOIN_FILTERS,\n\t\t\t\t\t\t      &join_filter, sizeof(join_filter)) < 0) {\n\t\t\t\tperror(\"setsockopt CAN_RAW_JOIN_FILTERS not supported by your Linux Kernel\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (numfilter)\n\t\t\t\tsetsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_FILTER,\n\t\t\t\t\t   rfilter, numfilter * sizeof(struct can_filter));\n\n\t\t\tfree(rfilter);\n\n\t\t} /* if (nptr) */\n\n\t\t/* try to switch the socket into CAN FD mode */\n\t\tsetsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfx_on, sizeof(canfx_on));\n\n\t\t/* try to switch the socket into CAN XL mode */\n\t\tsetsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_XL_FRAMES, &canfx_on, sizeof(canfx_on));\n\n\t\t/* try to enable the CAN XL VCID pass through mode */\n\t\tsetsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_XL_VCID_OPTS, &vcid_opts, sizeof(vcid_opts));\n\n\t\tif (rcvbuf_size) {\n\t\t\tint curr_rcvbuf_size;\n\t\t\tsocklen_t curr_rcvbuf_size_len = sizeof(curr_rcvbuf_size);\n\n\t\t\t/* try SO_RCVBUFFORCE first, if we run with CAP_NET_ADMIN */\n\t\t\tif (setsockopt(obj->s, SOL_SOCKET, SO_RCVBUFFORCE,\n\t\t\t\t       &rcvbuf_size, sizeof(rcvbuf_size)) < 0) {\n\t\t\t\tpr_debug(\"SO_RCVBUFFORCE failed so try SO_RCVBUF ...\\n\");\n\t\t\t\tif (setsockopt(obj->s, SOL_SOCKET, SO_RCVBUF,\n\t\t\t\t\t       &rcvbuf_size, sizeof(rcvbuf_size)) < 0) {\n\t\t\t\t\tperror(\"setsockopt SO_RCVBUF\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (getsockopt(obj->s, SOL_SOCKET, SO_RCVBUF,\n\t\t\t\t\t       &curr_rcvbuf_size, &curr_rcvbuf_size_len) < 0) {\n\t\t\t\t\tperror(\"getsockopt SO_RCVBUF\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t/* Only print a warning the first time we detect the adjustment */\n\t\t\t\t/* n.b.: The wanted size is doubled in Linux in net/sore/sock.c */\n\t\t\t\tif (!i && curr_rcvbuf_size < rcvbuf_size * 2)\n\t\t\t\t\tfprintf(stderr, \"The socket receive buffer size was \"\n\t\t\t\t\t\t\"adjusted due to /proc/sys/net/core/rmem_max.\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (timestamp || log || logfrmt) {\n\t\t\tif (hwtimestamp) {\n\t\t\t\tconst int timestamping_flags = (SOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\t\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE);\n\n\t\t\t\tif (setsockopt(obj->s, SOL_SOCKET, SO_TIMESTAMPING,\n\t\t\t\t\t       &timestamping_flags, sizeof(timestamping_flags)) < 0) {\n\t\t\t\t\tperror(\"setsockopt SO_TIMESTAMPING is not supported by your Linux kernel\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst int timestamp_on = 1;\n\n\t\t\t\tif (setsockopt(obj->s, SOL_SOCKET, SO_TIMESTAMP,\n\t\t\t\t\t       &timestamp_on, sizeof(timestamp_on)) < 0) {\n\t\t\t\t\tperror(\"setsockopt SO_TIMESTAMP\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dropmonitor) {\n\t\t\tconst int dropmonitor_on = 1;\n\n\t\t\tif (setsockopt(obj->s, SOL_SOCKET, SO_RXQ_OVFL,\n\t\t\t\t       &dropmonitor_on, sizeof(dropmonitor_on)) < 0) {\n\t\t\t\tperror(\"setsockopt SO_RXQ_OVFL not supported by your Linux Kernel\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (bind(obj->s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\t\tperror(\"bind\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (log) {\n\t\tif (!logname) {\n\t\t\ttime_t currtime;\n\t\t\tstruct tm now;\n\n\t\t\tif (time(&currtime) == (time_t)-1) {\n\t\t\t\tperror(\"time\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tlocaltime_r(&currtime, &now);\n\n\t\t\tsnprintf(fname, sizeof(fname), \"candump-%04d-%02d-%02d_%02d%02d%02d.log\",\n\t\t\t\tnow.tm_year + 1900,\n\t\t\t\tnow.tm_mon + 1,\n\t\t\t\tnow.tm_mday,\n\t\t\t\tnow.tm_hour,\n\t\t\t\tnow.tm_min,\n\t\t\t\tnow.tm_sec);\n\n\t\t\tlogname = fname;\n\t\t}\n\n\t\tif (silent != SILENT_ON)\n\t\t\tfprintf(stderr, \"Warning: Console output active while logging!\\n\");\n\n\t\tfprintf(stderr, \"Enabling Logfile '%s'\\n\", logname);\n\n\t\tlogfile = fopen(logname, \"w\");\n\t\tif (!logfile) {\n\t\t\tperror(\"logfile\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* these settings are static and can be held out of the hot path */\n\tiov.iov_base = &cu;\n\tmsg.msg_name = &addr;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = &ctrlmsg;\n\n\twhile (running) {\n\t\tnum_events = epoll_wait(fd_epoll, events_pending, currmax, timeout_ms);\n\t\tif (num_events == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* handle timeout */\n\t\tif (!num_events && timeout_ms >= 0) {\n\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < num_events; i++) { /* check waiting CAN RAW sockets */\n\t\t\tstruct if_info *obj = events_pending[i].data.ptr;\n\t\t\tint idx;\n\t\t\tchar *extra_info = \"\";\n\n\t\t\t/* these settings may be modified by recvmsg() */\n\t\t\tiov.iov_len = sizeof(cu);\n\t\t\tmsg.msg_namelen = sizeof(addr);\n\t\t\tmsg.msg_controllen = sizeof(ctrlmsg);\n\t\t\tmsg.msg_flags = 0;\n\n\t\t\tnbytes = recvmsg(obj->s, &msg, 0);\n\t\t\tidx = idx2dindex(addr.can_ifindex, obj->s);\n\n\t\t\tif (nbytes < 0) {\n\t\t\t\tif ((errno == ENETDOWN) && !down_causes_exit) {\n\t\t\t\t\tfprintf(stderr, \"%s: interface down\\n\", devname[idx]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tperror(\"read\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* mark dual-use struct canfd_frame */\n\t\t\tif (nbytes < (int)CANXL_HDR_SIZE + CANXL_MIN_DLEN) {\n\t\t\t\tfprintf(stderr, \"read: no CAN frame\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (cu.xl.flags & CANXL_XLF) {\n\t\t\t\tif (nbytes != (int)CANXL_HDR_SIZE + cu.xl.len) {\n\t\t\t\t\tprintf(\"nbytes = %d\\n\", nbytes);\n\t\t\t\t\tfprintf(stderr, \"read: no CAN XL frame\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nbytes == CAN_MTU)\n\t\t\t\t\tcu.fd.flags = 0;\n\t\t\t\telse if (nbytes == CANFD_MTU)\n\t\t\t\t\tcu.fd.flags |= CANFD_FDF;\n\t\t\t\telse {\n\t\t\t\t\tfprintf(stderr, \"read: incomplete CAN CC/FD frame\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (count && (--count == 0))\n\t\t\t\trunning = 0;\n\n\t\t\tfor (cmsg = CMSG_FIRSTHDR(&msg);\n\t\t\t     cmsg && (cmsg->cmsg_level == SOL_SOCKET);\n\t\t\t     cmsg = CMSG_NXTHDR(&msg,cmsg)) {\n\t\t\t\tif (cmsg->cmsg_type == SO_TIMESTAMP) {\n\t\t\t\t\tmemcpy(&tv, CMSG_DATA(cmsg), sizeof(tv));\n\t\t\t\t} else if (cmsg->cmsg_type == SO_TIMESTAMPING) {\n\t\t\t\t\tstruct timespec *stamp = (struct timespec *)CMSG_DATA(cmsg);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * stamp[0] is the software timestamp\n\t\t\t\t\t * stamp[1] is deprecated\n\t\t\t\t\t * stamp[2] is the raw hardware timestamp\n\t\t\t\t\t * See chapter 2.1.2 Receive timestamps in\n\t\t\t\t\t * linux/Documentation/networking/timestamping.txt\n\t\t\t\t\t */\n\t\t\t\t\ttv.tv_sec = stamp[2].tv_sec;\n\t\t\t\t\ttv.tv_usec = stamp[2].tv_nsec / 1000;\n\t\t\t\t} else if (cmsg->cmsg_type == SO_RXQ_OVFL) {\n\t\t\t\t\tmemcpy(&obj->dropcnt, CMSG_DATA(cmsg), sizeof(__u32));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* check for (unlikely) dropped frames on this specific socket */\n\t\t\tif (obj->dropcnt != obj->last_dropcnt) {\n\t\t\t\t__u32 frames = obj->dropcnt - obj->last_dropcnt;\n\n\t\t\t\tif (silent != SILENT_ON)\n\t\t\t\t\tprintf(\"DROPCOUNT: dropped %u CAN frame%s on '%s' socket (total drops %u)\\n\",\n\t\t\t\t\t       frames, (frames > 1)?\"s\":\"\", devname[idx], obj->dropcnt);\n\n\t\t\t\tif (log)\n\t\t\t\t\tfprintf(logfile, \"DROPCOUNT: dropped %u CAN frame%s on '%s' socket (total drops %u)\\n\",\n\t\t\t\t\t\tframes, (frames > 1)?\"s\":\"\", devname[idx], obj->dropcnt);\n\n\t\t\t\tobj->last_dropcnt = obj->dropcnt;\n\t\t\t}\n\n\t\t\t/* once we detected a EFF frame indent SFF frames accordingly */\n\t\t\tif (cu.fd.can_id & CAN_EFF_FLAG)\n\t\t\t\tview |= CANLIB_VIEW_INDENT_SFF;\n\n\t\t\tif (extra_msg_info) {\n\t\t\t\tif (msg.msg_flags & MSG_DONTROUTE)\n\t\t\t\t\textra_info = \" T\";\n\t\t\t\telse\n\t\t\t\t\textra_info = \" R\";\n\t\t\t}\n\n\t\t\t/* build common log format output */\n\t\t\tif ((log) || ((logfrmt) && (silent == SILENT_OFF))) {\n\n\t\t\t\talen = sprint_timestamp(afrbuf, logtimestamp,\n\t\t\t\t\t\t\t  &tv, &last_tv);\n\n\t\t\t\talen += sprintf(afrbuf + alen, \"%*s \",\n\t\t\t\t\t\t  max_devname_len, devname[idx]);\n\n\t\t\t\talen += snprintf_canframe(afrbuf + alen, sizeof(afrbuf) - alen, &cu, 0);\n\t\t\t}\n\n\t\t\t/* write CAN frame in log file style to logfile */\n\t\t\tif (log)\n\t\t\t\tfprintf(logfile, \"%s%s\\n\", afrbuf, extra_info);\n\n\t\t\t/* print CAN frame in log file style to stdout */\n\t\t\tif ((logfrmt) && (silent == SILENT_OFF)) {\n\t\t\t\tprintf(\"%s%s\\n\", afrbuf, extra_info);\n\t\t\t\tgoto out_fflush; /* no other output to stdout */\n\t\t\t}\n\n\t\t\t/* print only animation */\n\t\t\tif (silent != SILENT_OFF) {\n\t\t\t\tif (silent == SILENT_ANI) {\n\t\t\t\t\tprintf(\"%c\\b\", anichar[silentani %= MAXANI]);\n\t\t\t\t\tsilentani++;\n\t\t\t\t}\n\t\t\t\tgoto out_fflush; /* no other output to stdout */\n\t\t\t}\n\n\t\t\t/* print (colored) long CAN frame style to stdout */\n\t\t\talen = sprintf(afrbuf, \" %s\", (color > 2) ? col_on[idx % MAXCOL] : \"\");\n\t\t\talen += sprint_timestamp(afrbuf + alen, timestamp, &tv, &last_tv);\n\t\t\talen += sprintf(afrbuf + alen, \" %s%*s\",\n\t\t\t\t\t  (color && (color < 3)) ? col_on[idx % MAXCOL] : \"\",\n\t\t\t\t\t  max_devname_len, devname[idx]);\n\n\t\t\tif (extra_msg_info) {\n\t\t\t\tif (msg.msg_flags & MSG_DONTROUTE)\n\t\t\t\t\talen += sprintf(afrbuf + alen, \"  TX %s\",\n\t\t\t\t\t\t\t  extra_m_info[cu.fd.flags & 3]);\n\t\t\t\telse\n\t\t\t\t\talen += sprintf(afrbuf + alen, \"  RX %s\",\n\t\t\t\t\t\t\t  extra_m_info[cu.fd.flags & 3]);\n\t\t\t}\n\n\t\t\talen += sprintf(afrbuf + alen, \"%s  \", (color == 1) ? col_off : \"\");\n\t\t\talen += snprintf_long_canframe(afrbuf + alen, sizeof(afrbuf) - alen, &cu, view);\n\n\t\t\tif ((view & CANLIB_VIEW_ERROR) && (cu.fd.can_id & CAN_ERR_FLAG)) {\n\t\t\t\talen += sprintf(afrbuf + alen, \"\\n\\t\");\n\t\t\t\talen += snprintf_can_error_frame(afrbuf + alen,\n\t\t\t\t\t\t\t\t sizeof(afrbuf) - alen,\n\t\t\t\t\t\t\t\t &cu.fd, \"\\n\\t\");\n\t\t\t}\n\n\t\t\tprintf(\"%s%s\\n\", afrbuf, (color > 1) ? col_off : \"\");\nout_fflush:\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n\n\tfor (i = 0; i < currmax; i++)\n\t\tclose(sock_info[i].s);\n\n\tclose(fd_epoll);\n\n\tif (log)\n\t\tfclose(logfile);\n\n\tif (signal_num)\n\t\treturn 128 + signal_num;\n\n\treturn 0;\n}\n"
        },
        {
          "name": "canfdtest.c",
          "type": "blob",
          "size": 13.5068359375,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * canfdtest.c - Full-duplex test program (DUT and host part)\n *\n * (C) 2009 by Vladislav Gribov, IXXAT Automation GmbH, <gribov@ixxat.de>\n * (C) 2009 Wolfgang Grandegger <wg@grandegger.com>\n * (C) 2021 Jean Gressmann, IAV GmbH, <jean.steven.gressmann@iav.de>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n */\n\n#include <errno.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <limits.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n\n#define CAN_MSG_ID_PING 0x77\n#define CAN_MSG_ID_PONG 0x78\n#define CAN_MSG_LEN 8\n#define CAN_MSG_COUNT 50\n#define CAN_MSG_WAIT 27\n\nstatic int running = 1;\nstatic int verbose;\nstatic int sockfd;\nstatic int test_loops;\nstatic int exit_sig;\nstatic int inflight_count = CAN_MSG_COUNT;\nstatic int filter;\nstatic canid_t can_id_ping = CAN_MSG_ID_PING;\nstatic canid_t can_id_pong = CAN_MSG_ID_PONG;\nstatic bool has_pong_id;\nstatic bool is_can_fd;\nstatic bool bit_rate_switch;\nstatic int msg_len = CAN_MSG_LEN;\nstatic bool is_extended_frame_format;\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr,\n\t\t\"%s - Full-duplex test program (DUT and host part).\\n\"\n\t\t\"Usage: %s [options] [<can-interface>]\\n\"\n\t\t\"\\n\"\n\t\t\"Options:\\n\"\n\t\t\"         -b       (enable CAN FD Bit Rate Switch)\\n\"\n\t\t\"         -d       (use CAN FD frames instead of classic CAN)\\n\"\n\t\t\"         -e       (use 29-bit extended frame format instead of classic 11-bit one)\\n\"\n\t\t\"         -f COUNT (number of frames in flight, default: %d)\\n\"\n\t\t\"         -g       (generate messages)\\n\"\n\t\t\"         -i ID    (CAN ID to use for frames to DUT (ping), default %x)\\n\"\n\t\t\"         -l COUNT (test loop count)\\n\"\n\t\t\"         -o ID    (CAN ID to use for frames to host (pong), default %x)\\n\"\n\t\t\"         -s SIZE  (frame payload size in bytes)\\n\"\n\t\t\"         -v       (low verbosity)\\n\"\n\t\t\"         -vv      (high verbosity)\\n\"\n\t\t\"         -x       (ignore other frames on bus)\\n\"\n\t\t\"         -xx      (ignore locally generated and other frames on bus -- use for loopback testing)\\n\"\n\t\t\"\\n\"\n\t\t\"With the option '-g' CAN messages are generated and checked\\n\"\n\t\t\"on <can-interface>, otherwise all messages received on the\\n\"\n\t\t\"<can-interface> are sent back incrementing the CAN id and\\n\"\n\t\t\"all data bytes. The program can be aborted with ^C.\\n\"\n\t\t\"\\n\"\n\t\t\"Using 'can0' as default CAN-interface.\\n\"\n\t\t\"\\n\"\n\t\t\"Examples:\\n\"\n\t\t\"\\ton DUT:\\n\"\n\t\t\"%s -v can0\\n\"\n\t\t\"\\ton Host:\\n\"\n\t\t\"%s -g -v can2\\n\",\n\t\tprg, prg, CAN_MSG_COUNT, CAN_MSG_ID_PING, CAN_MSG_ID_PONG, prg, prg);\n\n\texit(1);\n}\n\nstatic void print_frame(canid_t id, const uint8_t *data, int dlc, int inc_data)\n{\n\tint i;\n\n\tprintf(\"%04x: \", id);\n\tif (id & CAN_RTR_FLAG) {\n\t\tprintf(\"remote request\");\n\t} else {\n\t\tprintf(\"[%d]\", dlc);\n\t\tfor (i = 0; i < dlc; i++)\n\t\t\tprintf(\" %02x\", (uint8_t)(data[i] + inc_data));\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void print_compare(canid_t exp_id, const uint8_t *exp_data, uint8_t exp_dlc,\n\t\t\t  canid_t rec_id, const uint8_t *rec_data, uint8_t rec_dlc,\n\t\t\t  int inc)\n{\n\tprintf(\"expected: \");\n\tprint_frame(exp_id, exp_data, exp_dlc, inc);\n\tprintf(\"received: \");\n\tprint_frame(rec_id, rec_data, rec_dlc, 0);\n}\n\nstatic canid_t normalize_canid(canid_t id)\n{\n\tif (is_extended_frame_format) {\n\t\tid &= CAN_EFF_MASK;\n\t\tid |= CAN_EFF_FLAG;\n\t} else {\n\t\tid &= CAN_SFF_MASK;\n\t}\n\n\treturn id;\n}\n\nstatic int compare_frame(const struct canfd_frame *exp, const struct canfd_frame *rec, int inc)\n{\n\tint i, err = 0;\n\tconst canid_t expected_can_id = inc ? can_id_pong : can_id_ping;\n\n\tif (rec->can_id != expected_can_id) {\n\t\tprintf(\"Message ID mismatch!\\n\");\n\t\tprint_compare(expected_can_id, exp->data, exp->len,\n\t\t              rec->can_id, rec->data, rec->len, inc);\n\t\trunning = 0;\n\t\terr = -1;\n\t} else if (rec->len != exp->len) {\n\t\tprintf(\"Message length mismatch!\\n\");\n\t\tprint_compare(expected_can_id, exp->data, exp->len,\n\t\t              rec->can_id, rec->data, rec->len, inc);\n\t\trunning = 0;\n\t\terr = -1;\n\t} else {\n\t\tfor (i = 0; i < rec->len; i++) {\n\t\t\tif (rec->data[i] != (uint8_t)(exp->data[i] + inc)) {\n\t\t\t\tprintf(\"Databyte 0x%x mismatch!\\n\", i);\n\t\t\t\tprint_compare(expected_can_id, exp->data, exp->len,\n\t\t\t\t              rec->can_id, rec->data, rec->len, inc);\n\t\t\t\trunning = 0;\n\t\t\t\terr = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void millisleep(int msecs)\n{\n\tstruct timespec rqtp, rmtp;\n\tint err;\n\n\t/* sleep in ms */\n\trqtp.tv_sec = msecs / 1000;\n\trqtp.tv_nsec = msecs % 1000 * 1000000;\n\n\tdo {\n\t\terr = clock_nanosleep(CLOCK_MONOTONIC, 0, &rqtp, &rmtp);\n\t\tif (err != 0 && err != EINTR) {\n\t\t\tprintf(\"t\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trqtp = rmtp;\n\t} while (err != 0);\n}\n\nstatic void echo_progress(unsigned char data)\n{\n\tif (data == 0xff) {\n\t\tprintf(\".\");\n\t\tfflush(stdout);\n\t}\n}\n\nstatic void signal_handler(int signo)\n{\n\tclose(sockfd);\n\trunning = 0;\n\texit_sig = signo;\n}\n\nstatic int recv_frame(struct canfd_frame *frame, int *flags)\n{\n\tstruct iovec iov = {\n\t\t.iov_base = frame,\n\t\t.iov_len = is_can_fd ? sizeof(struct canfd_frame) : sizeof(struct can_frame),\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tssize_t ret;\n\n\tret = recvmsg(sockfd, &msg, 0);\n\tif (ret < 0) {\n\t\tperror(\"recvmsg() failed\");\n\t\treturn -1;\n\t}\n\tif ((size_t)ret != iov.iov_len) {\n\t\tfprintf(stderr, \"recvmsg() returned %zd\", ret);\n\t\treturn -1;\n\t}\n\n\tif (flags)\n\t\t*flags = msg.msg_flags;\n\n\treturn 0;\n}\n\nstatic int send_frame(struct canfd_frame *frame)\n{\n\tssize_t ret, len;\n\n\tif (is_can_fd)\n\t\tlen = sizeof(struct canfd_frame);\n\telse\n\t\tlen = sizeof(struct can_frame);\n\n\tif (bit_rate_switch)\n\t\tframe->flags |= CANFD_BRS;\n\n\twhile ((ret = send(sockfd, frame, len, 0)) != len) {\n\t\tif (ret >= 0) {\n\t\t\tfprintf(stderr, \"send returned %zd\", ret);\n\t\t\treturn -1;\n\t\t}\n\t\tif (errno != ENOBUFS) {\n\t\t\tperror(\"send failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (verbose) {\n\t\t\tprintf(\"N\");\n\t\t\tfflush(stdout);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_frame(const struct canfd_frame *frame)\n{\n\tint err = 0;\n\tint i;\n\n\tif (frame->can_id != can_id_ping) {\n\t\tprintf(\"Unexpected Message ID 0x%04x!\\n\", frame->can_id);\n\t\terr = -1;\n\t}\n\n\tif (frame->len != msg_len) {\n\t\tprintf(\"Unexpected Message length %d!\\n\", frame->len);\n\t\terr = -1;\n\t}\n\n\tfor (i = 1; i < frame->len; i++) {\n\t\tif (frame->data[i] != (uint8_t)(frame->data[i - 1] + 1)) {\n\t\t\tprintf(\"Frame inconsistent!\\n\");\n\t\t\tprint_frame(frame->can_id, frame->data, frame->len, 0);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn err;\n}\n\nstatic void inc_frame(struct canfd_frame *frame)\n{\n\tint i;\n\n\tif (has_pong_id)\n\t\tframe->can_id = can_id_pong;\n\telse\n\t\tframe->can_id = normalize_canid(frame->can_id + 1);\n\n\tfor (i = 0; i < frame->len; i++)\n\t\tframe->data[i]++;\n}\n\nstatic int can_echo_dut(void)\n{\n\tunsigned int frame_count = 0;\n\tstruct canfd_frame frame;\n\tint err = 0;\n\n\twhile (running) {\n\t\tint flags;\n\n\t\tif (recv_frame(&frame, &flags))\n\t\t\treturn -1;\n\n\t\tif (filter > 1 && flags & MSG_DONTROUTE)\n\t\t\tcontinue;\n\n\t\tframe_count++;\n\t\tif (verbose == 1) {\n\t\t\techo_progress(frame.data[0]);\n\t\t} else if (verbose > 1) {\n\t\t\tif (verbose > 2)\n\t\t\t\tprintf(\"%s %s: \",\n\t\t\t\t       flags & MSG_DONTROUTE ? \"DR\" : \"  \",\n\t\t\t\t       flags & MSG_CONFIRM ? \"CF\" : \"  \");\n\t\t\tprint_frame(frame.can_id, frame.data, frame.len, 0);\n\t\t}\n\n\t\terr = check_frame(&frame);\n\t\tinc_frame(&frame);\n\t\tif (send_frame(&frame))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * to force a interlacing of the frames send by DUT and PC\n\t\t * test tool a waiting time is injected\n\t\t */\n\t\tif (frame_count == CAN_MSG_WAIT) {\n\t\t\tframe_count = 0;\n\t\t\tmillisleep(3);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int can_echo_gen(void)\n{\n\tstruct canfd_frame *tx_frames;\n\tbool *recv_tx;\n\tunsigned char counter = 0;\n\tint send_pos = 0, recv_rx_pos = 0, recv_tx_pos = 0, unprocessed = 0, loops = 0;\n\tint err = 0;\n\tint i;\n\n\ttx_frames = calloc(inflight_count, sizeof(*tx_frames));\n\tif (!tx_frames)\n\t\treturn -1;\n\n\trecv_tx = calloc(inflight_count, sizeof(*recv_tx));\n\tif (!recv_tx) {\n\t\terr = -1;\n\t\tgoto out_free_tx_frames;\n\t}\n\n\twhile (running) {\n\t\tif (unprocessed < inflight_count) {\n\t\t\t/* still send messages */\n\t\t\tstruct canfd_frame *tx_frame = &tx_frames[send_pos];\n\n\t\t\ttx_frame->len = msg_len;\n\t\t\ttx_frame->can_id = can_id_ping;\n\t\t\trecv_tx[send_pos] = false;\n\n\t\t\tfor (i = 0; i < msg_len; i++)\n\t\t\t\ttx_frame->data[i] = counter + i;\n\t\t\tif (send_frame(tx_frame)) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tsend_pos++;\n\t\t\tsend_pos %= inflight_count;\n\n\t\t\tunprocessed++;\n\t\t\tif (verbose == 1)\n\t\t\t\techo_progress(counter);\n\t\t\tcounter++;\n\n\t\t\tif ((counter % 33) == 0)\n\t\t\t\tmillisleep(3);\n\t\t\telse\n\t\t\t\tmillisleep(1);\n\t\t} else {\n\t\t\tstruct canfd_frame rx_frame;\n\t\t\tint flags;\n\n\t\t\tif (recv_frame(&rx_frame, &flags)) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (filter > 1 &&\n\t\t\t    ((rx_frame.can_id == can_id_ping && !(flags & MSG_CONFIRM)) ||\n\t\t\t     (rx_frame.can_id == can_id_pong && (flags & MSG_DONTROUTE))))\n\t\t\t\tcontinue;\n\n\t\t\tif (verbose > 1) {\n\t\t\t\tif (verbose > 2)\n\t\t\t\t\tprintf(\"%s %s: \",\n\t\t\t\t\t       flags & MSG_DONTROUTE ? \"DR\" : \"  \",\n\t\t\t\t\t       flags & MSG_CONFIRM ? \"CF\" : \"  \");\n\t\t\t\tprint_frame(rx_frame.can_id, rx_frame.data, rx_frame.len, 0);\n\t\t\t}\n\n\t\t\t/* own frame */\n\t\t\tif (flags & MSG_CONFIRM) {\n\t\t\t\terr = compare_frame(&tx_frames[recv_tx_pos], &rx_frame, 0);\n\t\t\t\trecv_tx[recv_tx_pos] = true;\n\t\t\t\trecv_tx_pos++;\n\t\t\t\trecv_tx_pos %= inflight_count;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!recv_tx[recv_rx_pos]) {\n\t\t\t\tprintf(\"RX before TX!\\n\");\n\t\t\t\tprint_frame(rx_frame.can_id, rx_frame.data, rx_frame.len, 0);\n\t\t\t\trunning = 0;\n\t\t\t}\n\t\t\t/* compare with expected */\n\t\t\terr = compare_frame(&tx_frames[recv_rx_pos], &rx_frame, 1);\n\t\t\trecv_rx_pos++;\n\t\t\trecv_rx_pos %= inflight_count;\n\n\t\t\tloops++;\n\t\t\tif (test_loops && loops >= test_loops)\n\t\t\t\tbreak;\n\n\t\t\tunprocessed--;\n\t\t}\n\t}\n\n\tprintf(\"\\nTest messages sent and received: %d\\n\", loops);\n\nout_free:\n\tfree(recv_tx);\nout_free_tx_frames:\n\tfree(tx_frames);\n\n\treturn err;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct sockaddr_can addr;\n\tchar *intf_name = \"can0\";\n\tint family = PF_CAN, type = SOCK_RAW, proto = CAN_RAW;\n\tint echo_gen = 0;\n\tint opt, err;\n\tint enable_socket_option = 1;\n\n\tsignal(SIGTERM, signal_handler);\n\tsignal(SIGHUP, signal_handler);\n\tsignal(SIGINT, signal_handler);\n\n\twhile ((opt = getopt(argc, argv, \"bdef:gi:l:o:s:vx?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\tbit_rate_switch = true;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tis_can_fd = true;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tis_extended_frame_format = true;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tinflight_count = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\techo_gen = 1;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tcan_id_ping = strtoul(optarg, NULL, 16);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\ttest_loops = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\t\tcan_id_pong = strtoul(optarg, NULL, 16);\n\t\t\thas_pong_id = true;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tmsg_len = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tfilter++;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\tdefault:\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* BRS can be enabled only if CAN FD is enabled */\n\tif (bit_rate_switch && !is_can_fd) {\n\t\tprintf(\"Bit rate switch (-b) needs CAN FD (-d) to be enabled\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Make sure the message length is valid */\n\tif (msg_len <= 0) {\n\t\tprintf(\"Message length must > 0\\n\");\n\t\treturn 1;\n\t}\n\tif (is_can_fd) {\n\t\tif (msg_len > CANFD_MAX_DLEN) {\n\t\t\tprintf(\"Message length must be <= %d bytes for CAN FD\\n\", CANFD_MAX_DLEN);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (msg_len > CAN_MAX_DLEN) {\n\t\t\tprintf(\"Message length must be <= %d bytes for CAN 2.0B\\n\", CAN_MAX_DLEN);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tcan_id_ping = normalize_canid(can_id_ping);\n\tcan_id_pong = normalize_canid(can_id_pong);\n\n\tif ((argc - optind) == 1)\n\t\tintf_name = argv[optind];\n\telse if ((argc - optind))\n\t\tprint_usage(basename(argv[0]));\n\n\tprintf(\"interface = %s, family = %d, type = %d, proto = %d\\n\",\n\t       intf_name, family, type, proto);\n\n\tif ((sockfd = socket(family, type, proto)) < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tif (echo_gen) {\n\t\tif (setsockopt(sockfd, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS,\n\t\t\t       &enable_socket_option, sizeof(enable_socket_option)) == -1) {\n\t\t\tperror(\"setsockopt CAN_RAW_RECV_OWN_MSGS\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (is_can_fd) {\n\t\tif (setsockopt(sockfd, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,\n\t\t\t       &enable_socket_option, sizeof(enable_socket_option)) == -1) {\n\t\t\tperror(\"setsockopt CAN_RAW_FD_FRAMES\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\taddr.can_family = family;\n\taddr.can_ifindex = if_nametoindex(intf_name);\n\tif (!addr.can_ifindex) {\n\t\tperror(\"if_nametoindex\");\n\t\tclose(sockfd);\n\t\treturn 1;\n\t}\n\n\tif (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\tclose(sockfd);\n\t\treturn 1;\n\t}\n\n\tif (!has_pong_id)\n\t\tcan_id_pong = can_id_ping + 1;\n\n\tif (filter) {\n\t\tconst struct can_filter filters[] = {\n\t\t\t{\n\t\t\t\t.can_id = can_id_ping,\n\t\t\t\t.can_mask = CAN_EFF_FLAG | CAN_RTR_FLAG | CAN_EFF_MASK,\n\t\t\t},\n\t\t\t{\n\t\t\t\t.can_id = can_id_pong,\n\t\t\t\t.can_mask = CAN_EFF_FLAG | CAN_RTR_FLAG | CAN_EFF_MASK,\n\t\t\t},\n\t\t};\n\n\t\tif (setsockopt(sockfd, SOL_CAN_RAW, CAN_RAW_FILTER, filters,\n\t\t\t       sizeof(struct can_filter) * (1 + echo_gen))) {\n\t\t\tperror(\"setsockopt()\");\n\t\t\tclose(sockfd);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (echo_gen)\n\t\terr = can_echo_gen();\n\telse\n\t\terr = can_echo_dut();\n\n\tif (verbose)\n\t\tprintf(\"Exiting...\\n\");\n\n\tclose(sockfd);\n\n\tif (exit_sig)\n\t\treturn 128 + exit_sig;\n\n\treturn err;\n}\n"
        },
        {
          "name": "canframelen.c",
          "type": "blob",
          "size": 10.7080078125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * canframelen.c\n *\n * Copyright (c) 2013, 2014 Czech Technical University in Prague\n *\n * Author: Michal Sojka <sojkam1@fel.cvut.cz>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Czech Technical University in Prague nor the\n *    names of its contributors may be used to endorse or promote\n *    products derived from this software without specific prior\n *    written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <arpa/inet.h>\n#include <assert.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"canframelen.h\"\n\n/**\n * Functions and types for CRC checks.\n *\n * Generated on Wed Jan  8 15:14:20 2014,\n * by pycrc v0.8.1, http://www.tty1.net/pycrc/\n * using the configuration:\n *    Width        = 15\n *    Poly         = 0x4599\n *    XorIn        = 0x0000\n *    ReflectIn    = False\n *    XorOut       = 0x0000\n *    ReflectOut   = False\n *    Algorithm    = table-driven\n *****************************************************************************/\n\ntypedef uint16_t crc_t;\n\n/**\n * Static table used for the table_driven implementation.\n *****************************************************************************/\nstatic const crc_t crc_table[256] = {\n\t0x0000, 0x4599, 0x4eab, 0x0b32, 0x58cf, 0x1d56, 0x1664, 0x53fd, 0x7407, 0x319e, 0x3aac, 0x7f35, 0x2cc8, 0x6951, 0x6263, 0x27fa,\n\t0x2d97, 0x680e, 0x633c, 0x26a5, 0x7558, 0x30c1, 0x3bf3, 0x7e6a, 0x5990, 0x1c09, 0x173b, 0x52a2, 0x015f, 0x44c6, 0x4ff4, 0x0a6d,\n\t0x5b2e, 0x1eb7, 0x1585, 0x501c, 0x03e1, 0x4678, 0x4d4a, 0x08d3, 0x2f29, 0x6ab0, 0x6182, 0x241b, 0x77e6, 0x327f, 0x394d, 0x7cd4,\n\t0x76b9, 0x3320, 0x3812, 0x7d8b, 0x2e76, 0x6bef, 0x60dd, 0x2544, 0x02be, 0x4727, 0x4c15, 0x098c, 0x5a71, 0x1fe8, 0x14da, 0x5143,\n\t0x73c5, 0x365c, 0x3d6e, 0x78f7, 0x2b0a, 0x6e93, 0x65a1, 0x2038, 0x07c2, 0x425b, 0x4969, 0x0cf0, 0x5f0d, 0x1a94, 0x11a6, 0x543f,\n\t0x5e52, 0x1bcb, 0x10f9, 0x5560, 0x069d, 0x4304, 0x4836, 0x0daf, 0x2a55, 0x6fcc, 0x64fe, 0x2167, 0x729a, 0x3703, 0x3c31, 0x79a8,\n\t0x28eb, 0x6d72, 0x6640, 0x23d9, 0x7024, 0x35bd, 0x3e8f, 0x7b16, 0x5cec, 0x1975, 0x1247, 0x57de, 0x0423, 0x41ba, 0x4a88, 0x0f11,\n\t0x057c, 0x40e5, 0x4bd7, 0x0e4e, 0x5db3, 0x182a, 0x1318, 0x5681, 0x717b, 0x34e2, 0x3fd0, 0x7a49, 0x29b4, 0x6c2d, 0x671f, 0x2286,\n\t0x2213, 0x678a, 0x6cb8, 0x2921, 0x7adc, 0x3f45, 0x3477, 0x71ee, 0x5614, 0x138d, 0x18bf, 0x5d26, 0x0edb, 0x4b42, 0x4070, 0x05e9,\n\t0x0f84, 0x4a1d, 0x412f, 0x04b6, 0x574b, 0x12d2, 0x19e0, 0x5c79, 0x7b83, 0x3e1a, 0x3528, 0x70b1, 0x234c, 0x66d5, 0x6de7, 0x287e,\n\t0x793d, 0x3ca4, 0x3796, 0x720f, 0x21f2, 0x646b, 0x6f59, 0x2ac0, 0x0d3a, 0x48a3, 0x4391, 0x0608, 0x55f5, 0x106c, 0x1b5e, 0x5ec7,\n\t0x54aa, 0x1133, 0x1a01, 0x5f98, 0x0c65, 0x49fc, 0x42ce, 0x0757, 0x20ad, 0x6534, 0x6e06, 0x2b9f, 0x7862, 0x3dfb, 0x36c9, 0x7350,\n\t0x51d6, 0x144f, 0x1f7d, 0x5ae4, 0x0919, 0x4c80, 0x47b2, 0x022b, 0x25d1, 0x6048, 0x6b7a, 0x2ee3, 0x7d1e, 0x3887, 0x33b5, 0x762c,\n\t0x7c41, 0x39d8, 0x32ea, 0x7773, 0x248e, 0x6117, 0x6a25, 0x2fbc, 0x0846, 0x4ddf, 0x46ed, 0x0374, 0x5089, 0x1510, 0x1e22, 0x5bbb,\n\t0x0af8, 0x4f61, 0x4453, 0x01ca, 0x5237, 0x17ae, 0x1c9c, 0x5905, 0x7eff, 0x3b66, 0x3054, 0x75cd, 0x2630, 0x63a9, 0x689b, 0x2d02,\n\t0x276f, 0x62f6, 0x69c4, 0x2c5d, 0x7fa0, 0x3a39, 0x310b, 0x7492, 0x5368, 0x16f1, 0x1dc3, 0x585a, 0x0ba7, 0x4e3e, 0x450c, 0x0095\n};\n\n/**\n * Update the crc value with new data.\n *\n * \\param crc      The current crc value.\n * \\param data     Pointer to a buffer of \\a data_len bytes.\n * \\param data_len Number of bytes in the \\a data buffer.\n * \\return         The updated crc value.\n *****************************************************************************/\nstatic crc_t crc_update_bytewise(crc_t crc, const unsigned char *data, size_t data_len)\n{\n\tunsigned int tbl_idx;\n\n\twhile (data_len--) {\n\t\ttbl_idx = ((crc >> 7) ^ *data) & 0xff;\n\t\tcrc = (crc_table[tbl_idx] ^ (crc << 8)) & 0x7fff;\n\n\t\tdata++;\n\t}\n\treturn crc & 0x7fff;\n}\n\n/**\n * Update the crc value with new data.\n *\n * \\param crc      The current crc value.\n * \\param data     Data value\n * \\param bits\t   The number of most significant bits in data used for CRC calculation\n * \\return         The updated crc value.\n *****************************************************************************/\nstatic crc_t crc_update_bitwise(crc_t crc, uint8_t data, size_t bits)\n{\n\tuint8_t i;\n\tbool bit;\n\n\tfor (i = 0x80; bits--; i >>= 1) {\n\t\tbit = crc & 0x4000;\n\t\tif (data & i) {\n\t\t\tbit = !bit;\n\t\t}\n\t\tcrc <<= 1;\n\t\tif (bit) {\n\t\t\tcrc ^= 0x4599;\n\t\t}\n\t}\n\treturn crc & 0x7fff;\n}\n\nstatic crc_t calc_bitmap_crc(uint8_t *bitmap, unsigned start, unsigned end)\n{\n\tcrc_t crc = 0;\n\n\tif (start % 8) {\n\t\tcrc = crc_update_bitwise(crc, bitmap[start / 8] << (start % 8), 8 - start % 8);\n\t\tstart += 8 - start % 8;\n\t}\n\tcrc = crc_update_bytewise(crc, &bitmap[start / 8], (end - start) / 8);\n\tcrc = crc_update_bitwise(crc, bitmap[end / 8], end % 8);\n\treturn crc;\n}\n\nstatic unsigned cfl_exact(struct can_frame *frame)\n{\n\tuint8_t bitmap[16];\n\tunsigned start = 0, end;\n\tcrc_t crc;\n\tuint16_t crc_be;\n\tuint8_t mask, lookfor;\n\tunsigned i, stuffed;\n\tconst int8_t clz[32] = /* count of leading zeros in 5 bit numbers */\n\t\t{ 5, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\t/* Prepare bitmap */\n\tmemset(bitmap, 0, sizeof(bitmap));\n\tif (frame->can_id & CAN_EFF_FLAG) {\n\t\t/* bit            7      0 7      0 7      0 7      0\n\t\t * bitmap[0-3]   |.sBBBBBB BBBBBSIE EEEEEEEE EEEEEEEE| s = SOF, B = Base ID (11 bits), S = SRR, I = IDE, E = Extended ID (18 bits)\n\t\t * bitmap[4-7]   |ER10DLC4 00000000 11111111 22222222| R = RTR, 0 = r0, 1 = r1, DLC4 = DLC, Data bytes\n\t\t * bitmap[8-11]  |33333333 44444444 55555555 66666666| Data bytes\n\t\t * bitmap[12-15] |77777777 ........ ........ ........| Data bytes\n\t\t */\n\t\tbitmap[0] = (frame->can_id & CAN_EFF_MASK) >> 23;\n\t\tbitmap[1] = ((frame->can_id >> 18) & 0x3f) << 3 |\n\t\t\t    3 << 1\t       \t     \t      \t| /* SRR, IDE */\n\t\t\t    ((frame->can_id >> 17) & 0x01);\n\t\tbitmap[2] = (frame->can_id >> 9) & 0xff;\n\t\tbitmap[3] = (frame->can_id >> 1) & 0xff;\n\t\tbitmap[4] = (frame->can_id & 0x1) << 7              |\n\t\t\t    (!!(frame->can_id & CAN_RTR_FLAG)) << 6 |\n\t\t\t    0 << 4\t      \t\t       \t    | /* r1, r0 */\n\t\t\t    (frame->can_dlc & 0xf);\n\t\tmemcpy(&bitmap[5], &frame->data, frame->can_dlc);\n\t\tstart = 1;\n\t\tend = 40 + 8*frame->can_dlc;\n\t} else {\n\t\t/* bit           7      0 7      0 7      0 7      0\n\t\t * bitmap[0-3]  |.....sII IIIIIIII IRE0DLC4 00000000| s = SOF, I = ID (11 bits), R = RTR, E = IDE, DLC4 = DLC\n\t\t * bitmap[4-7]  |11111111 22222222 33333333 44444444| Data bytes\n\t\t * bitmap[8-11] |55555555 66666666 77777777 ........| Data bytes\n\t\t */\n\t\tbitmap[0] = (frame->can_id & CAN_SFF_MASK) >> 9;\n\t\tbitmap[1] = (frame->can_id >> 1) & 0xff;\n\t\tbitmap[2] = ((frame->can_id << 7) & 0xff) |\n\t\t\t    (!!(frame->can_id & CAN_RTR_FLAG)) << 6 |\n\t\t\t    0 << 4 | /* IDE, r0 */\n\t\t\t    (frame->can_dlc & 0xf);\n\t\tmemcpy(&bitmap[3], &frame->data, frame->can_dlc);\n\t\tstart = 5;\n\t\tend = 24 + 8 * frame->can_dlc;\n\t}\n\n\t/* Calc and append CRC */\n\tcrc = calc_bitmap_crc(bitmap, start, end);\n\tcrc_be = htons(crc << 1);\n\tassert(end % 8 == 0);\n\tmemcpy(bitmap + end / 8, &crc_be, 2);\n\tend += 15;\n\n\t/* Count stuffed bits */\n\tmask \t= 0x1f;\n\tlookfor = 0;\n\ti \t= start;\n\tstuffed = 0;\n\twhile (i < end) {\n\t\tunsigned change;\n\t\tunsigned bits = (bitmap[i / 8] << 8 | bitmap[i / 8 + 1]) >> (16 - 5 - i % 8);\n\t\tlookfor = lookfor ? 0 : mask; /* We alternate between looking for a series of zeros or ones */\n\t\tchange = (bits & mask) ^ lookfor; /* 1 indicates a change */\n\t\tif (change) { /* No bit was stuffed here */\n\t\t\ti += clz[change];\n\t\t\tmask = 0x1f; /* Next look for 5 same bits */\n\t\t} else {\n\t\t\ti += (mask == 0x1f) ? 5 : 4;\n\t\t\tif (i <= end) {\n\t\t\t\tstuffed++;\n\t\t\t\tmask = 0x1e; /* Next look for 4 bits (5th bit is the stuffed one) */\n\t\t\t}\n\t\t}\n\t}\n\treturn end - start + stuffed +\n\t\t3 + \t\t/* CRC del, ACK, ACK del */\n\t\t7 +\t\t/* EOF */\n\t\t3;\t\t/* IFS */\n}\n\nunsigned can_frame_dbitrate_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu)\n{\n\tif (mtu != CANFD_MTU || !(frame->flags & CANFD_BRS))\n\t\treturn 0;\n\tswitch (mode) {\n\tcase CFL_NO_BITSTUFFING:\n\t\treturn 1 /* brs/crcdel */ + 1 /* esi */ + 4 /* dlc */ +\n\t\t\t((frame->len >= 16) ? 21 : 17) +\n\t\t\tframe->len * 8;\n\tcase CFL_WORSTCASE:\n\t\treturn can_frame_dbitrate_length(frame, CFL_NO_BITSTUFFING, mtu) * 5 / 4;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nunsigned can_frame_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu)\n{\n\tint eff = (frame->can_id & CAN_EFF_FLAG);\n\n\tif (mtu == CANFD_MTU)\n\t\t/* not correct, but close ? */\n\t\tswitch (mode) {\n\t\tcase CFL_NO_BITSTUFFING:\n\t\t\treturn 1 + (eff ? 29 : 11) + ((frame->len >= 16) ? 21 : 17) +\n\t\t\t\t5 /* r1, ide, edl, r0, brs/crcdel, */ + 12 /* trail */ +\n\t\t\t\tframe->len * 8;\n\t\tcase CFL_WORSTCASE:\n\t\t\treturn can_frame_length(frame, CFL_NO_BITSTUFFING, mtu) * 5 / 4;\n\t\tcase CFL_EXACT:\n\t\t\treturn 0; /* exact bittiming for CANFD not supported yet */\n\t\t}\n\telse if (mtu != CAN_MTU)\n\t\treturn 0; /* Only CAN2.0 and CANFD supported now */\n\n\tswitch (mode) {\n\tcase CFL_NO_BITSTUFFING:\n\t\treturn (eff ? 67 : 47) + frame->len * 8;\n\tcase CFL_WORSTCASE:\n\t\treturn (eff ? 80 : 55) + frame->len * 10;\n\tcase CFL_EXACT:\n\t\treturn cfl_exact((struct can_frame*)frame);\n\t}\n\treturn 0; /* Unknown mode */\n}\n"
        },
        {
          "name": "canframelen.h",
          "type": "blob",
          "size": 3.341796875,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * canframelen.h\n *\n * Copyright (c) 2013, 2014 Czech Technical University in Prague\n *\n * Author: Michal Sojka <sojkam1@fel.cvut.cz>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Czech Technical University in Prague nor the\n *    names of its contributors may be used to endorse or promote\n *    products derived from this software without specific prior\n *    written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#ifndef CANFRAMELEN_H\n#define CANFRAMELEN_H\n\n#include <linux/can.h>\n\n/**\n * Frame length calculation modes.\n *\n * CFL_WORSTCASE corresponds to *worst* case calculation for\n * stuff-bits - see (1)-(3) in [1]. The worst case number of bits on\n * the wire can be calculated as:\n *\n * (34 + 8n - 1)/4 + 34 + 8n + 13 for SFF frames (11 bit CAN-ID) => 55 + 10n\n * (54 + 8n - 1)/4 + 54 + 8n + 13 for EFF frames (29 bit CAN-ID) => 80 + 10n\n *\n * while 'n' is the data length code (number of payload bytes)\n *\n * [1] \"Controller Area Network (CAN) schedulability analysis:\n *     Refuted, revisited and revised\", Real-Time Syst (2007)\n *     35:239-272.\n *\n */\nenum cfl_mode {\n\tCFL_NO_BITSTUFFING, /* plain bit calculation without bitstuffing */\n\tCFL_WORSTCASE, /* worst case estimation - see above */\n\tCFL_EXACT, /* exact calculation of stuffed bits based on frame\n\t\t    * content and CRC */\n};\n\n/**\n * Calculates the number of bits a frame needs on the wire (including\n * inter frame space).\n *\n * Mode determines how to deal with stuffed bits.\n */\nunsigned can_frame_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu);\nunsigned can_frame_dbitrate_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu);\n\n#endif\n"
        },
        {
          "name": "cangen.c",
          "type": "blob",
          "size": 27.50390625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * cangen.c - CAN frames generator\n *\n * Copyright (c) 2022 Pengutronix,\n *\t\t Marc Kleine-Budde <kernel@pengutronix.de>\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <limits.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <linux/net_tstamp.h>\n\n#include \"lib.h\"\n\n#define DEFAULT_GAP 200 /* ms */\n#define DEFAULT_BURST_COUNT 1\n#define DEFAULT_SO_MARK_VAL 1\n\n#define MODE_RANDOM 0\n#define MODE_INCREMENT 1\n#define MODE_FIX 2\n#define MODE_RANDOM_EVEN 3\n#define MODE_RANDOM_ODD 4\n#define MODE_RANDOM_FIX 5\n\n#define NIBBLE_H 1\n#define NIBBLE_L 2\n\n#define CHAR_RANDOM 'x'\n\nextern int optind, opterr, optopt;\n\nstatic volatile int running = 1;\nstatic volatile sig_atomic_t signal_num;\nstatic unsigned long long enobufs_count;\nstatic bool ignore_enobufs;\nstatic bool use_so_txtime;\n\nstatic int clockid = CLOCK_TAI;\nstatic int clock_nanosleep_flags;\nstatic struct timespec ts, ts_gap;\nstatic int so_mark_val = DEFAULT_SO_MARK_VAL;\n\n#define NSEC_PER_SEC 1000000000LL\n\nstatic struct timespec timespec_normalise(struct timespec ts)\n{\n\twhile (ts.tv_nsec >= NSEC_PER_SEC) {\n\t\t++(ts.tv_sec);\n\t\tts.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\twhile (ts.tv_nsec <= -NSEC_PER_SEC) {\n\t\t--(ts.tv_sec);\n\t\tts.tv_nsec += NSEC_PER_SEC;\n\t}\n\n\tif (ts.tv_nsec < 0) {\n\t\t/*\n\t\t * Negative nanoseconds isn't valid according to\n\t\t * POSIX. Decrement tv_sec and roll tv_nsec over.\n\t\t */\n\n\t\t--(ts.tv_sec);\n\t\tts.tv_nsec = (NSEC_PER_SEC + ts.tv_nsec);\n\t}\n\n\treturn ts;\n}\n\nstatic struct timespec timespec_add(struct timespec ts1, struct timespec ts2)\n{\n\t/*\n\t * Normalize inputs to prevent tv_nsec rollover if\n\t * whole-second values are packed in it.\n\t */\n\tts1 = timespec_normalise(ts1);\n\tts2 = timespec_normalise(ts2);\n\n\tts1.tv_sec += ts2.tv_sec;\n\tts1.tv_nsec += ts2.tv_nsec;\n\n\treturn timespec_normalise(ts1);\n}\n\nstruct timespec double_to_timespec(double s)\n{\n\tstruct timespec ts = {\n\t\t.tv_sec = s,\n\t\t.tv_nsec = (s - (long)(s)) * NSEC_PER_SEC,\n\t};\n\n\treturn timespec_normalise(ts);\n}\n\nstatic struct timespec ns_to_timespec(int64_t ns)\n{\n\tstruct timespec ts = {\n\t\t.tv_sec = ns / NSEC_PER_SEC,\n\t\t.tv_nsec = ns % NSEC_PER_SEC,\n\t};\n\n\treturn timespec_normalise(ts);\n}\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - CAN frames generator.\\n\\n\", prg);\n\tfprintf(stderr, \"Usage: %s [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -g <ms>       (gap in milli seconds - default: %d ms)\\n\", DEFAULT_GAP);\n\tfprintf(stderr, \"         -a            (use absolute time for gap)\\n\");\n\tfprintf(stderr, \"         -t            (use SO_TXTIME)\\n\");\n\tfprintf(stderr, \"         --start <ns>  (start time (UTC nanoseconds))\\n\");\n\tfprintf(stderr, \"         --mark <id>   (set SO_MARK to <id>, default %u)\\n\", DEFAULT_SO_MARK_VAL);\n\tfprintf(stderr, \"         -e            (generate extended frame mode (EFF) CAN frames)\\n\");\n\tfprintf(stderr, \"         -f            (generate CAN FD CAN frames)\\n\");\n\tfprintf(stderr, \"         -b            (generate CAN FD CAN frames with bitrate switch (BRS))\\n\");\n\tfprintf(stderr, \"         -E            (generate CAN FD CAN frames with error state (ESI))\\n\");\n\tfprintf(stderr, \"         -X            (generate CAN XL CAN frames)\\n\");\n\tfprintf(stderr, \"         -R            (generate RTR frames)\\n\");\n\tfprintf(stderr, \"         -8            (allow DLC values greater then 8 for Classic CAN frames)\\n\");\n\tfprintf(stderr, \"         -m            (mix -e -f -b -E -R -X frames)\\n\");\n\tfprintf(stderr, \"         -I <mode>     (CAN ID generation mode - see below)\\n\");\n\tfprintf(stderr, \"         -L <mode>     (CAN data length code (dlc) generation mode - see below)\\n\");\n\tfprintf(stderr, \"         -D <mode>     (CAN data (payload) generation mode - see below)\\n\");\n\tfprintf(stderr, \"         -F <mode>     (CAN XL Flags generation mode - see below, no e/o mode)\\n\");\n\tfprintf(stderr, \"         -S <mode>     (CAN XL SDT generation mode - see below, no e/o mode)\\n\");\n\tfprintf(stderr, \"         -A <mode>     (CAN XL AF generation mode - see below, no e/o mode)\\n\");\n\tfprintf(stderr, \"         -V <mode>     (CAN XL VCID generation mode - see below, no e/o mode)\\n\");\n\tfprintf(stderr, \"         -p <timeout>  (poll on -ENOBUFS to write frames with <timeout> ms)\\n\");\n\tfprintf(stderr, \"         -n <count>    (terminate after <count> CAN frames - default infinite)\\n\");\n\tfprintf(stderr, \"         -i            (ignore -ENOBUFS return values on write() syscalls)\\n\");\n\tfprintf(stderr, \"         -x            (disable local loopback of generated CAN frames)\\n\");\n\tfprintf(stderr, \"         -c <count>    (number of messages to send in burst, default %u)\\n\", DEFAULT_BURST_COUNT);\n\tfprintf(stderr, \"         -v            (increment verbose level for printing sent CAN frames)\\n\\n\");\n\tfprintf(stderr, \"Generation modes:\\n\");\n\tfprintf(stderr, \" 'r'     => random values (default)\\n\");\n\tfprintf(stderr, \" 'e'     => random values, even ID\\n\");\n\tfprintf(stderr, \" 'o'     => random values, odd ID\\n\");\n\tfprintf(stderr, \" 'i'     => increment values\\n\");\n\tfprintf(stderr, \" <value> => fixed value (in hexadecimal for -I and -D)\\n\");\n\tfprintf(stderr, \"         => nibbles written as '%c' are randomized (only -D)\\n\\n\", CHAR_RANDOM);\n\tfprintf(stderr, \"The gap value (in milliseconds) may have decimal places, e.g. '-g 4.73'\\n\");\n\tfprintf(stderr, \"When incrementing the CAN data the data length code minimum is set to 1.\\n\");\n\tfprintf(stderr, \"CAN IDs and data content are given and expected in hexadecimal values.\\n\\n\");\n\tfprintf(stderr, \"Examples:\\n\");\n\tfprintf(stderr, \"%s vcan0 -g 4 -I 42A -L 1 -D i -v -v\\n\", prg);\n\tfprintf(stderr, \"\\t(fixed CAN ID and length, inc. data)\\n\");\n\tfprintf(stderr, \"%s vcan0 -e -L i -v -v -v\\n\", prg);\n\tfprintf(stderr, \"\\t(generate EFF frames, incr. length)\\n\");\n\tfprintf(stderr, \"%s vcan0 -D 11223344DEADBEEF -L 8\\n\", prg);\n\tfprintf(stderr, \"\\t(fixed CAN data payload and length)\\n\");\n\tfprintf(stderr, \"%s vcan0 -D 11%c%c3344DEADBEEF -L 8\\n\", prg, CHAR_RANDOM, CHAR_RANDOM);\n\tfprintf(stderr, \"\\t(fixed CAN data payload where 2. byte is randomized, fixed length)\\n\");\n\tfprintf(stderr, \"%s vcan0 -I 555 -D CCCCCCCCCCCCCCCC -L 8 -g 3.75\\n\", prg);\n\tfprintf(stderr, \"\\t(generate a fix busload without bit-stuffing effects)\\n\");\n\tfprintf(stderr, \"%s vcan0 -g 0 -i -x\\n\", prg);\n\tfprintf(stderr, \"\\t(full load test ignoring -ENOBUFS)\\n\");\n\tfprintf(stderr, \"%s vcan0 -g 0 -p 10 -x\\n\", prg);\n\tfprintf(stderr, \"\\t(full load test with polling, 10ms timeout)\\n\");\n\tfprintf(stderr, \"%s vcan0\\n\", prg);\n\tfprintf(stderr, \"\\t(my favourite default :)\\n\\n\");\n}\n\nstatic void sigterm(int signo)\n{\n\trunning = 0;\n\tsignal_num = signo;\n}\n\nstatic int setsockopt_txtime(int fd)\n{\n\tconst struct sock_txtime so_txtime_val = {\n\t\t.clockid = clockid,\n\t\t.flags = SOF_TXTIME_REPORT_ERRORS,\n\t};\n\tstruct sock_txtime so_txtime_val_read;\n\tint so_mark_val_read;\n\tsocklen_t vallen;\n\tint ret;\n\n\t/* SO_TXTIME */\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_TXTIME,\n\t\t\t &so_txtime_val, sizeof(so_txtime_val));\n\tif (ret) {\n\t\tint err = errno;\n\n\t\tperror(\"setsockopt() SO_TXTIME\");\n\t\tif (err == EPERM)\n\t\t\tfprintf(stderr, \"Run with CAP_NET_ADMIN or as root.\\n\");\n\n\t\treturn -err;\n\t};\n\n\tvallen = sizeof(so_txtime_val_read);\n\tret = getsockopt(fd, SOL_SOCKET, SO_TXTIME,\n\t\t\t &so_txtime_val_read, &vallen);\n\tif (ret) {\n\t\tperror(\"getsockopt() SO_TXTIME\");\n\t\treturn -errno;\n\t};\n\n\tif (vallen != sizeof(so_txtime_val) ||\n\t    memcmp(&so_txtime_val, &so_txtime_val_read, vallen)) {\n\t\tperror(\"getsockopt() SO_TXTIME: mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* SO_MARK */\n\n\tret = setsockopt(fd, SOL_SOCKET, SO_MARK, &so_mark_val, sizeof(so_mark_val));\n\tif (ret) {\n\t\tint err = errno;\n\n\t\tperror(\"setsockopt() SO_MARK\");\n\t\tif (err == EPERM)\n\t\t\tfprintf(stderr, \"Run with CAP_NET_ADMIN or as root.\\n\");\n\n\t\treturn -err;\n\t};\n\n\tvallen = sizeof(so_mark_val_read);\n\tret = getsockopt(fd, SOL_SOCKET, SO_MARK,\n\t\t\t &so_mark_val_read, &vallen);\n\tif (ret) {\n\t\tperror(\"getsockopt() SO_MARK\");\n\t\treturn -errno;\n\t};\n\n\tif (vallen != sizeof(so_mark_val) ||\n\t    memcmp(&so_mark_val, &so_mark_val_read, vallen)) {\n\t\tperror(\"getsockopt() SO_MARK: mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_send_one(int fd, cu_t *cu, size_t len, int timeout)\n{\n\tuint8_t control[CMSG_SPACE(sizeof(uint64_t))] = { 0 };\n\tstruct iovec iov = {\n\t\t.iov_base = cu,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tssize_t nbytes;\n\tint ret;\n\n\t/* CAN XL frames need real frame length for sending */\n\tif (len == CANXL_MTU)\n\t\tlen = CANXL_HDR_SIZE + cu->xl.len;\n\n\tiov.iov_len = len;\n\n\tif (use_so_txtime) {\n\t\tstruct cmsghdr *cm;\n\t\tuint64_t tdeliver;\n\n\t\tmsg.msg_control = control;\n\t\tmsg.msg_controllen = sizeof(control);\n\n\t\ttdeliver = ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;\n\t\tts = timespec_add(ts, ts_gap);\n\n\t\tcm = CMSG_FIRSTHDR(&msg);\n\t\tcm->cmsg_level = SOL_SOCKET;\n\t\tcm->cmsg_type = SCM_TXTIME;\n\t\tcm->cmsg_len = CMSG_LEN(sizeof(tdeliver));\n\t\tmemcpy(CMSG_DATA(cm), &tdeliver, sizeof(tdeliver));\n\t}\n\nresend:\n\tnbytes = sendmsg(fd, &msg, 0);\n\tif (nbytes < 0) {\n\t\tret = -errno;\n\t\tif (ret != -ENOBUFS) {\n\t\t\tperror(\"write\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (!ignore_enobufs && !timeout) {\n\t\t\tperror(\"write\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (timeout) {\n\t\t\tstruct pollfd fds = {\n\t\t\t\t.fd = fd,\n\t\t\t\t.events = POLLOUT,\n\t\t\t};\n\n\t\t\t/* wait for the write socket (with timeout) */\n\t\t\tret = poll(&fds, 1, timeout);\n\t\t\tif (ret == 0 || (ret == -1 && errno != EINTR)) {\n\t\t\t\tret = -errno;\n\t\t\t\tperror(\"poll\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tgoto resend;\n\t\t} else {\n\t\t\tenobufs_count++;\n\t\t}\n\n\t} else if (nbytes < (ssize_t)len) {\n\t\tfprintf(stderr, \"write: incomplete CAN frame\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_time(void)\n{\n\tint ret;\n\n\tif (use_so_txtime) {\n\t\t/* start time is defined */\n\t\tif (ts.tv_sec || ts.tv_nsec)\n\t\t\treturn 0;\n\n\t\t/* start time is now .... */\n\t\tret = clock_gettime(clockid, &ts);\n\t\tif (ret) {\n\t\t\tperror(\"clock_gettime\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* ... + gap */\n\t\tts = timespec_add(ts, ts_gap);\n\n\t\treturn 0;\n\t}\n\n\tif (ts.tv_sec || ts.tv_nsec) {\n\t\tret = clock_nanosleep(clockid, TIMER_ABSTIME, &ts, NULL);\n\t\tif (ret != 0 && ret != EINTR) {\n\t\t\tperror(\"clock_nanosleep\");\n\t\t\treturn ret;\n\t\t}\n\t} else if (clock_nanosleep_flags == TIMER_ABSTIME) {\n\t\tret = clock_gettime(clockid, &ts);\n\t\tif (ret)\n\t\t\tperror(\"clock_gettime\");\n\n\t\treturn ret;\n\t}\n\n\tif (clock_nanosleep_flags != TIMER_ABSTIME)\n\t\tts = ts_gap;\n\n\treturn 0;\n}\n\nenum {\n\tOPT_MARK = UCHAR_MAX + 1,\n\tOPT_START = UCHAR_MAX + 2,\n};\n\n/*\n * Search for CHAR_RANDOM in dataoptarg, save its position, replace it with 0.\n * Return 1 if at least one CHAR_RANDOM found.\n */\nstatic int parse_dataoptarg(char *dataoptarg, unsigned char *rand_position)\n{\n\tint mode_format_selected = MODE_FIX;\n\tint arglen = strlen(dataoptarg);\n\tint i;\n\n\t/* Mark nibbles with * as fuzzable */\n\tfor (i = 0; i < CANFD_MAX_DLEN && i < arglen / 2; i++) {\n\t\tif (optarg[2 * i] == CHAR_RANDOM) {\n\t\t\toptarg[2 * i] = '0';\n\t\t\trand_position[i] += NIBBLE_H;\n\t\t\tmode_format_selected = MODE_RANDOM_FIX;\n\t\t}\n\t\tif (optarg[2 * i + 1] == CHAR_RANDOM) {\n\t\t\toptarg[2 * i + 1] = '0';\n\t\t\trand_position[i] += NIBBLE_L;\n\t\t\tmode_format_selected = MODE_RANDOM_FIX;\n\t\t}\n\t}\n\n\treturn mode_format_selected;\n}\n\nint main(int argc, char **argv)\n{\n\tdouble gap = DEFAULT_GAP;\n\tunsigned long burst_count = DEFAULT_BURST_COUNT;\n\tunsigned long polltimeout = 0;\n\tunsigned char extended = 0;\n\tunsigned char canfd = 0;\n\tunsigned char canxl = 0;\n\tunsigned char brs = 0;\n\tunsigned char esi = 0;\n\tunsigned char mix = 0;\n\tunsigned char id_mode = MODE_RANDOM;\n\tunsigned char data_mode = MODE_RANDOM;\n\tunsigned char dlc_mode = MODE_RANDOM;\n\t__u8 xl_flags = 0;\n\t__u8 xl_sdt = 0;\n\t__u32 xl_af = 0;\n\t__u8 xl_vcid = 0;\n\tunsigned char xl_flags_mode = MODE_RANDOM;\n\tunsigned char xl_sdt_mode = MODE_RANDOM;\n\tunsigned char xl_af_mode = MODE_RANDOM;\n\tunsigned char xl_vcid_mode = MODE_RANDOM;\n\tunsigned char loopback_disable = 0;\n\tunsigned char verbose = 0;\n\tunsigned char rtr_frame = 0;\n\tunsigned char len8_dlc = 0;\n\tunsigned char view = 0;\n\tint count = 0;\n\tunsigned long burst_sent_count = 0;\n\tint mtu, maxdlen;\n\tuint64_t incdata = 0;\n\t__u8 *data; /* base pointer for CC/FD or XL data */\n\tint incdlc = 0;\n\tunsigned long rnd;\n\tunsigned char fixdata[CANFD_MAX_DLEN];\n\tunsigned char rand_position[CANFD_MAX_DLEN] = { 0 };\n\n\tint opt;\n\tint s; /* socket */\n\n\tstruct sockaddr_can addr = { 0 };\n\tstruct can_raw_vcid_options vcid_opts = {\n\t\t.flags = CAN_RAW_XL_VCID_TX_PASS,\n\t};\n\tstatic cu_t cu;\n\tint i;\n\tstruct ifreq ifr = { 0 };\n\tconst int enable_canfx = 1;\n\n\tstruct timeval now;\n\tint ret;\n\n\t/* set seed value for pseudo random numbers */\n\tgettimeofday(&now, NULL);\n\tsrandom(now.tv_usec);\n\n\tsignal(SIGTERM, sigterm);\n\tsignal(SIGHUP, sigterm);\n\tsignal(SIGINT, sigterm);\n\n\tconst struct option long_options[] = {\n\t\t{ \"mark\",\trequired_argument,\t0, OPT_MARK, },\n\t\t{ \"start\",\trequired_argument,\t0, OPT_START, },\n\t\t{ 0,\t\t0,\t\t\t0, 0 },\n\t};\n\n\twhile ((opt = getopt_long(argc, argv, \"g:atefbEXR8mI:L:D:F:S:A:V:p:n:ixc:vh?\", long_options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'g':\n\t\t\tgap = strtod(optarg, NULL);\n\t\t\tbreak;\n\n\t\tcase 'a':\n\t\t\tclock_nanosleep_flags = TIMER_ABSTIME;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tclock_nanosleep_flags = TIMER_ABSTIME;\n\t\t\tuse_so_txtime = true;\n\t\t\tbreak;\n\n\t\tcase OPT_START: {\n\t\t\tint64_t start_time_ns;\n\n\t\t\tstart_time_ns = strtoll(optarg, NULL, 0);\n\t\t\tts = ns_to_timespec(start_time_ns);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase OPT_MARK:\n\t\t\tso_mark_val = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\textended = 1;\n\t\t\tview |= CANLIB_VIEW_INDENT_SFF;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tcanfd = 1;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tbrs = 1; /* bitrate switch implies CAN FD */\n\t\t\tcanfd = 1;\n\t\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tesi = 1; /* error state indicator implies CAN FD */\n\t\t\tcanfd = 1;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\tcanxl = 1;\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\trtr_frame = 1;\n\t\t\tbreak;\n\n\t\tcase '8':\n\t\t\tlen8_dlc = 1;\n\t\t\tview |= CANLIB_VIEW_LEN8_DLC;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tmix = 1;\n\t\t\tcanfd = 1; /* to switch the socket into CAN FD mode */\n\t\t\tview |= CANLIB_VIEW_INDENT_SFF;\n\t\t\tbreak;\n\n\t\tcase 'I':\n\t\t\tif (optarg[0] == 'r') {\n\t\t\t\tid_mode = MODE_RANDOM;\n\t\t\t} else if (optarg[0] == 'i') {\n\t\t\t\tid_mode = MODE_INCREMENT;\n\t\t\t} else if (optarg[0] == 'e') {\n\t\t\t\tid_mode = MODE_RANDOM_EVEN;\n\t\t\t} else if (optarg[0] == 'o') {\n\t\t\t\tid_mode = MODE_RANDOM_ODD;\n\t\t\t} else {\n\t\t\t\tid_mode = MODE_FIX;\n\t\t\t\tcu.fd.can_id = strtoul(optarg, NULL, 16);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tif (optarg[0] == 'r') {\n\t\t\t\tdlc_mode = MODE_RANDOM;\n\t\t\t} else if (optarg[0] == 'i') {\n\t\t\t\tdlc_mode = MODE_INCREMENT;\n\t\t\t} else {\n\t\t\t\tdlc_mode = MODE_FIX;\n\t\t\t\tcu.fd.len = atoi(optarg) & 0xFF; /* is cut to 8 / 64 later */\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (optarg[0] == 'r') {\n\t\t\t\tdata_mode = MODE_RANDOM;\n\t\t\t} else if (optarg[0] == 'i') {\n\t\t\t\tdata_mode = MODE_INCREMENT;\n\t\t\t} else {\n\t\t\t\tdata_mode = parse_dataoptarg(optarg, rand_position);\n\n\t\t\t\tif (hexstring2data(optarg, fixdata, CANFD_MAX_DLEN)) {\n\t\t\t\t\tprintf(\"wrong fix data definition\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tif (optarg[0] == 'r') {\n\t\t\t\txl_flags_mode = MODE_RANDOM;\n\t\t\t} else if (optarg[0] == 'i') {\n\t\t\t\txl_flags_mode = MODE_INCREMENT;\n\t\t\t} else {\n\t\t\t\txl_flags_mode = MODE_FIX;\n\t\t\t\tif (sscanf(optarg, \"%hhx\", &xl_flags) != 1) {\n\t\t\t\t\tprintf(\"Bad xl_flags definition '%s'.\\n\", optarg);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tif (optarg[0] == 'r') {\n\t\t\t\txl_sdt_mode = MODE_RANDOM;\n\t\t\t} else if (optarg[0] == 'i') {\n\t\t\t\txl_sdt_mode = MODE_INCREMENT;\n\t\t\t} else {\n\t\t\t\txl_sdt_mode = MODE_FIX;\n\t\t\t\tif (sscanf(optarg, \"%hhx\", &xl_sdt) != 1) {\n\t\t\t\t\tprintf(\"Bad xl_sdt definition '%s'.\\n\", optarg);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'A':\n\t\t\tif (optarg[0] == 'r') {\n\t\t\t\txl_af_mode = MODE_RANDOM;\n\t\t\t} else if (optarg[0] == 'i') {\n\t\t\t\txl_af_mode = MODE_INCREMENT;\n\t\t\t} else {\n\t\t\t\txl_af_mode = MODE_FIX;\n\t\t\t\txl_af = strtoul(optarg, NULL, 16);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tif (optarg[0] == 'r') {\n\t\t\t\txl_vcid_mode = MODE_RANDOM;\n\t\t\t} else if (optarg[0] == 'i') {\n\t\t\t\txl_vcid_mode = MODE_INCREMENT;\n\t\t\t} else {\n\t\t\t\txl_vcid_mode = MODE_FIX;\n\t\t\t\tif (sscanf(optarg, \"%hhx\", &xl_vcid) != 1) {\n\t\t\t\t\tprintf(\"Bad xl_vcid definition '%s'.\\n\", optarg);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tpolltimeout = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tcount = atoi(optarg);\n\t\t\tif (count < 1) {\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tignore_enobufs = true;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tloopback_disable = 1;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tburst_count = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (optind == argc) {\n\t\tprint_usage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\n\tif (verbose > 2)\n\t\tview |= CANLIB_VIEW_ASCII;\n\n\tts_gap = double_to_timespec(gap / 1000);\n\n\t/* recognize obviously missing commandline option */\n\tif (id_mode == MODE_FIX && cu.fd.can_id > 0x7FF && !extended) {\n\t\tprintf(\"The given CAN-ID is greater than 0x7FF and the '-e' option is not set.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (strlen(argv[optind]) >= IFNAMSIZ) {\n\t\tprintf(\"Name of CAN device '%s' is too long!\\n\\n\", argv[optind]);\n\t\treturn 1;\n\t}\n\n\ts = socket(PF_CAN, SOCK_RAW, CAN_RAW);\n\tif (s < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\taddr.can_family = AF_CAN;\n\n\tstrcpy(ifr.ifr_name, argv[optind]);\n\tif (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\taddr.can_ifindex = ifr.ifr_ifindex;\n\n\t/*\n\t * disable default receive filter on this RAW socket\n\t * This is obsolete as we do not read from the socket at all, but for\n\t * this reason we can remove the receive list in the Kernel to save a\n\t * little (really a very little!) CPU usage.\n\t */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);\n\n\tif (loopback_disable) {\n\t\tconst int loopback = 0;\n\n\t\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK,\n\t\t\t   &loopback, sizeof(loopback));\n\t}\n\n\tif (canfd || canxl) {\n\n\t\t/* check if the frame fits into the CAN netdevice */\n\t\tif (ioctl(s, SIOCGIFMTU, &ifr) < 0) {\n\t\t\tperror(\"SIOCGIFMTU\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (canfd) {\n\t\t\t/* ensure discrete CAN FD length values 0..8, 12, 16, 20, 24, 32, 64 */\n\t\t\tcu.fd.len = can_fd_dlc2len(can_fd_len2dlc(cu.fd.len));\n\t\t} else {\n\t\t\t/* limit fixed CAN XL data length to 64 */\n\t\t\tif (cu.fd.len > CANFD_MAX_DLEN)\n\t\t\t\tcu.fd.len = CANFD_MAX_DLEN;\n\t\t}\n\n\t\tif (canxl && (ifr.ifr_mtu < (int)CANXL_MIN_MTU)) {\n\t\t\tprintf(\"CAN interface not CAN XL capable - sorry.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (canfd && (ifr.ifr_mtu < (int)CANFD_MTU)) {\n\t\t\tprintf(\"CAN interface not CAN FD capable - sorry.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ifr.ifr_mtu == (int)CANFD_MTU) {\n\t\t\t/* interface is ok - try to switch the socket into CAN FD mode */\n\t\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,\n\t\t\t\t       &enable_canfx, sizeof(enable_canfx))){\n\t\t\t\tprintf(\"error when enabling CAN FD support\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ifr.ifr_mtu >= (int)CANXL_MIN_MTU) {\n\t\t\t/* interface is ok - try to switch the socket into CAN XL mode */\n\t\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_XL_FRAMES,\n\t\t\t\t       &enable_canfx, sizeof(enable_canfx))){\n\t\t\t\tprintf(\"error when enabling CAN XL support\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t/* try to enable the CAN XL VCID pass through mode */\n\t\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_XL_VCID_OPTS,\n\t\t\t\t       &vcid_opts, sizeof(vcid_opts))) {\n\t\t\t\tprintf(\"error when enabling CAN XL VCID pass through\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t/* sanitize Classical CAN 2.0 frame length */\n\t\tif (len8_dlc) {\n\t\t\tif (cu.cc.len > CAN_MAX_RAW_DLC)\n\t\t\t\tcu.cc.len = CAN_MAX_RAW_DLC;\n\n\t\t\tif (cu.cc.len > CAN_MAX_DLEN)\n\t\t\t\tcu.cc.len8_dlc = cu.cc.len;\n\t\t}\n\n\t\tif (cu.cc.len > CAN_MAX_DLEN)\n\t\t\tcu.cc.len = CAN_MAX_DLEN;\n\t}\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\treturn 1;\n\t}\n\n\tif (use_so_txtime) {\n\t\tret = setsockopt_txtime(s);\n\t\tif (ret)\n\t\t\treturn 1;\n\t}\n\n\tret = setup_time();\n\tif (ret)\n\t\treturn 1;\n\n\twhile (running) {\n\t\t/* clear values but preserve cu.fd.len */\n\t\tcu.fd.flags = 0;\n\t\tcu.fd.__res0 = 0;\n\t\tcu.fd.__res1 = 0;\n\n\t\tif (count && (--count == 0))\n\t\t\trunning = 0;\n\n\t\tif (canxl) {\n\t\t\tmtu = CANXL_MTU;\n\t\t\tmaxdlen = CANFD_MAX_DLEN; /* generate up to 64 byte */\n\t\t\textended = 0; /* prio has only 11 bit ID content */\n\t\t\tdata = cu.xl.data; /* fill CAN XL data */\n\t\t} else if (canfd) {\n\t\t\tmtu = CANFD_MTU;\n\t\t\tmaxdlen = CANFD_MAX_DLEN;\n\t\t\tdata = cu.fd.data; /* fill CAN CC/FD data */\n\t\t\tcu.fd.flags = CANFD_FDF;\n\t\t\tif (brs)\n\t\t\t\tcu.fd.flags |= CANFD_BRS;\n\t\t\tif (esi)\n\t\t\t\tcu.fd.flags |= CANFD_ESI;\n\t\t} else {\n\t\t\tmtu = CAN_MTU;\n\t\t\tmaxdlen = CAN_MAX_DLEN;\n\t\t\tdata = cu.cc.data; /* fill CAN CC/FD data */\n\t\t}\n\n\t\tif (id_mode == MODE_RANDOM)\n\t\t\tcu.fd.can_id = random();\n\t\telse if (id_mode == MODE_RANDOM_EVEN)\n\t\t\tcu.fd.can_id = random() & ~0x1;\n\t\telse if (id_mode == MODE_RANDOM_ODD)\n\t\t\tcu.fd.can_id = random() | 0x1;\n\n\t\tif (extended) {\n\t\t\tcu.fd.can_id &= CAN_EFF_MASK;\n\t\t\tcu.fd.can_id |= CAN_EFF_FLAG;\n\t\t} else {\n\t\t\tcu.fd.can_id &= CAN_SFF_MASK;\n\t\t}\n\n\t\tif (rtr_frame && !canfd && !canxl)\n\t\t\tcu.fd.can_id |= CAN_RTR_FLAG;\n\n\t\tif (dlc_mode == MODE_RANDOM) {\n\t\t\tif (canxl)\n\t\t\t\tcu.fd.len = CANXL_MIN_DLEN + (random() & 0x3F);\n\t\t\telse if (canfd)\n\t\t\t\tcu.fd.len = can_fd_dlc2len(random() & 0xF);\n\t\t\telse {\n\t\t\t\tcu.cc.len = random() & 0xF;\n\n\t\t\t\tif (cu.cc.len > CAN_MAX_DLEN) {\n\t\t\t\t\t/* generate Classic CAN len8 DLCs? */\n\t\t\t\t\tif (len8_dlc)\n\t\t\t\t\t\tcu.cc.len8_dlc = cu.cc.len;\n\n\t\t\t\t\tcu.cc.len = 8; /* for about 50% of the frames */\n\t\t\t\t} else {\n\t\t\t\t\tcu.cc.len8_dlc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data_mode == MODE_INCREMENT && !cu.cc.len)\n\t\t\tcu.cc.len = 1; /* min dlc value for incr. data */\n\n\t\tif (data_mode == MODE_RANDOM) {\n\t\t\trnd = random();\n\t\t\tmemcpy(&data[0], &rnd, 4);\n\t\t\trnd = random();\n\t\t\tmemcpy(&data[4], &rnd, 4);\n\n\t\t\t/* omit extra random number generation for CAN FD */\n\t\t\tif ((canfd || canxl) && cu.fd.len > 8) {\n\t\t\t\tmemcpy(&data[8], &data[0], 8);\n\t\t\t\tmemcpy(&data[16], &data[0], 16);\n\t\t\t\tmemcpy(&data[32], &data[0], 32);\n\t\t\t}\n\t\t}\n\n\t\tif (data_mode == MODE_RANDOM_FIX) {\n\t\t\tint i;\n\n\t\t\tmemcpy(data, fixdata, CANFD_MAX_DLEN);\n\n\t\t\tfor (i = 0; i < cu.fd.len; i++) {\n\t\t\t\tif (rand_position[i] == (NIBBLE_H | NIBBLE_L)) {\n\t\t\t\t\tdata[i] = random();\n\t\t\t\t} else if (rand_position[i] == NIBBLE_H) {\n\t\t\t\t\tdata[i] = (data[i] & 0x0f) | (random() & 0xf0);\n\t\t\t\t} else if (rand_position[i] == NIBBLE_L) {\n\t\t\t\t\tdata[i] = (data[i] & 0xf0) | (random() & 0x0f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data_mode == MODE_FIX)\n\t\t\tmemcpy(data, fixdata, CANFD_MAX_DLEN);\n\n\t\t/* set unused payload data to zero like the CAN driver does it on rx */\n\t\tif (cu.fd.len < maxdlen)\n\t\t\tmemset(&data[cu.fd.len], 0, maxdlen - cu.fd.len);\n\n\t\tif (!use_so_txtime &&\n\t\t    (ts.tv_sec || ts.tv_nsec) &&\n\t\t    burst_sent_count >= burst_count) {\n\t\t\tif (clock_nanosleep_flags == TIMER_ABSTIME)\n\t\t\t\tts = timespec_add(ts, ts_gap);\n\n\t\t\tret = clock_nanosleep(clockid, clock_nanosleep_flags, &ts, NULL);\n\t\t\tif (ret != 0 && ret != EINTR) {\n\t\t\t\tperror(\"clock_nanosleep\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (canxl) {\n\t\t\t/* convert some CAN FD frame content into a CAN XL frame */\n\t\t\tif (cu.fd.len < CANXL_MIN_DLEN) {\n\t\t\t\tcu.fd.len = CANXL_MIN_DLEN;\n\t\t\t\tdata[0] = 0xCC; /* default filler */\n\t\t\t}\n\t\t\tcu.xl.len = cu.fd.len;\n\n\t\t\trnd = random();\n\n\t\t\tif (xl_flags_mode == MODE_RANDOM) {\n\t\t\t\tcu.xl.flags = rnd & CANXL_SEC;\n\t\t\t} else if (xl_flags_mode == MODE_FIX) {\n\t\t\t\tcu.xl.flags = xl_flags;\n\t\t\t} else if (xl_flags_mode == MODE_INCREMENT) {\n\t\t\t\txl_flags ^= CANXL_SEC;\n\t\t\t\tcu.xl.flags = (xl_flags & CANXL_SEC);\n\t\t\t}\n\n\t\t\t/* mark CAN XL frame */\n\t\t\tcu.xl.flags |= CANXL_XLF;\n\n\t\t\tif (xl_sdt_mode == MODE_RANDOM) {\n\t\t\t\tcu.xl.sdt = rnd & 0xFF;\n\t\t\t} else if (xl_sdt_mode == MODE_FIX) {\n\t\t\t\tcu.xl.sdt = xl_sdt;\n\t\t\t} else if (xl_sdt_mode == MODE_INCREMENT) {\n\t\t\t\txl_sdt++;\n\t\t\t\tcu.xl.sdt = xl_sdt;\n\t\t\t}\n\n\t\t\tif (xl_af_mode == MODE_RANDOM) {\n\t\t\t\tcu.xl.af = rnd;\n\t\t\t} else if (xl_af_mode == MODE_FIX) {\n\t\t\t\tcu.xl.af = xl_af;\n\t\t\t} else if (xl_af_mode == MODE_INCREMENT) {\n\t\t\t\txl_af++;\n\t\t\t\tcu.xl.af = xl_af;\n\t\t\t}\n\n\t\t\tif (xl_vcid_mode == MODE_RANDOM) {\n\t\t\t\tcu.xl.prio |= rnd & CANXL_VCID_MASK;\n\t\t\t} else if (xl_vcid_mode == MODE_FIX) {\n\t\t\t\tcu.xl.prio |= xl_vcid << CANXL_VCID_OFFSET;\n\t\t\t} else if (xl_vcid_mode == MODE_INCREMENT) {\n\t\t\t\txl_vcid++;\n\t\t\t\tcu.xl.prio |= xl_vcid << CANXL_VCID_OFFSET;\n\t\t\t}\n\t\t}\n\n\t\tif (verbose) {\n\t\t\tstatic char afrbuf[AFRSZ]; /* ASCII CAN frame buffer size */\n\n\t\t\tprintf(\"  %s  \", argv[optind]);\n\n\t\t\tif (verbose > 1)\n\t\t\t\tsnprintf_long_canframe(afrbuf, sizeof(afrbuf), &cu, view);\n\t\t\telse\n\t\t\t\tsnprintf_canframe(afrbuf, sizeof(afrbuf), &cu, 1);\n\n\t\t\tprintf(\"%s\\n\", afrbuf);\n\t\t}\n\n\t\tret = do_send_one(s, &cu, mtu, polltimeout);\n\t\tif (ret)\n\t\t\treturn 1;\n\n\t\tif (burst_sent_count >= burst_count)\n\t\t\tburst_sent_count = 0;\n\t\tburst_sent_count++;\n\n\t\t/* restore some CAN FD frame content from CAN XL frame */\n\t\tif (canxl)\n\t\t\tcu.fd.len = cu.xl.len;\n\n\t\tif (id_mode == MODE_INCREMENT)\n\t\t\tcu.cc.can_id++;\n\n\t\tif (dlc_mode == MODE_INCREMENT) {\n\t\t\tincdlc++;\n\t\t\tincdlc %= CAN_MAX_RAW_DLC + 1;\n\n\t\t\tif ((canfd || canxl) && !mix)\n\t\t\t\tcu.fd.len = can_fd_dlc2len(incdlc);\n\t\t\telse if (len8_dlc) {\n\t\t\t\tif (incdlc > CAN_MAX_DLEN) {\n\t\t\t\t\tcu.cc.len = CAN_MAX_DLEN;\n\t\t\t\t\tcu.cc.len8_dlc = incdlc;\n\t\t\t\t} else {\n\t\t\t\t\tcu.cc.len = incdlc;\n\t\t\t\t\tcu.cc.len8_dlc = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tincdlc %= CAN_MAX_DLEN + 1;\n\t\t\t\tcu.fd.len = incdlc;\n\t\t\t}\n\t\t}\n\n\t\tif (data_mode == MODE_INCREMENT) {\n\t\t\tincdata++;\n\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tdata[i] = incdata >> i * 8;\n\t\t}\n\n\t\tif (mix) {\n\t\t\ti = random();\n\t\t\textended = i & 1;\n\t\t\tcanfd = i & 2;\n\t\t\tif (canfd) {\n\t\t\t\tbrs = i & 4;\n\t\t\t\tesi = i & 8;\n\t\t\t}\n\t\t\t/* generate CAN XL traffic if the interface is capable */\n\t\t\tif (ifr.ifr_mtu >= (int)CANXL_MIN_MTU)\n\t\t\t\tcanxl = ((i & 96) == 96);\n\n\t\t\trtr_frame = ((i & 24) == 24); /* reduce RTR frames to 1/4 */\n\t\t}\n\t}\n\n\tif (enobufs_count)\n\t\tprintf(\"\\nCounted %llu ENOBUFS return values on write().\\n\\n\",\n\t\t       enobufs_count);\n\n\tclose(s);\n\n\tif (signal_num)\n\t\treturn 128 + signal_num;\n\n\treturn 0;\n}\n"
        },
        {
          "name": "cangw.c",
          "type": "blob",
          "size": 24.6923828125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * cangw.c - manage PF_CAN netlink gateway\n *\n * Copyright (c) 2010 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <errno.h>\n#include <libgen.h>\n#include <linux/can/gw.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <net/if.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nenum {\n\tUNSPEC,\n\tADD,\n\tDEL,\n\tFLUSH,\n\tLIST\n};\n\nstruct modattr {\n\tstruct can_frame cf;\n\t__u8 modtype;\n\t__u8 instruction;\n} __attribute__((packed));\n\nstruct fdmodattr {\n\tstruct canfd_frame cf;\n\t__u8 modtype;\n\t__u8 instruction;\n} __attribute__((packed));\n\n\n#define RTCAN_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtcanmsg))))\n#define RTCAN_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtcanmsg))\n\n/* some netlink helpers stolen from iproute2 package */\n#define NLMSG_TAIL(nmsg) \\\n        ((struct rtattr *)(((char *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))\n\nstatic int addattr_l(struct nlmsghdr *n, int maxlen, int type,\n\t\t     const void *data, int alen)\n{\n\tint len = RTA_LENGTH(alen);\n\tstruct rtattr *rta;\n\n\tif ((int)(NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len)) > maxlen) {\n\t\tfprintf(stderr, \"addattr_l: message exceeded bound of %d\\n\",\n\t\t\tmaxlen);\n\t\treturn -1;\n\t}\n\trta = NLMSG_TAIL(n);\n\trta->rta_type = type;\n\trta->rta_len = len;\n\tmemcpy(RTA_DATA(rta), data, alen);\n\tn->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);\n\treturn 0;\n}\n\nstatic void printfilter(const void *data)\n{\n\tstruct can_filter *filter = (struct can_filter *)data;\n\n\tif (filter->can_id & CAN_INV_FILTER)\n\t\tprintf(\"-f %03X~%X \", (filter->can_id & ~CAN_INV_FILTER), filter->can_mask);\n\telse\n\t\tprintf(\"-f %03X:%X \", filter->can_id, filter->can_mask);\n}\n\nstatic void printmod(const char *type, const void *data)\n{\n\tstruct modattr mod;\n\tint i;\n\n\tmemcpy (&mod, data, CGW_MODATTR_LEN);\n\n\tprintf(\"-m %s:\", type);\n\n\tif (mod.modtype & CGW_MOD_ID)\n\t\tprintf(\"I\");\n\n\tif (mod.modtype & CGW_MOD_DLC)\n\t\tprintf(\"L\");\n\n\tif (mod.modtype & CGW_MOD_DATA)\n\t\tprintf(\"D\");\n\n\tprintf(\":%03X.%X.\", mod.cf.can_id, mod.cf.can_dlc);\n\n\tfor (i = 0; i < CAN_MAX_DLEN; i++)\n\t\tprintf(\"%02X\", mod.cf.data[i]);\n\n\tprintf(\" \");\n}\n\nstatic void printfdmod(const char *type, const void *data)\n{\n\tstruct fdmodattr mod;\n\tint i;\n\n\tmemcpy (&mod, data, CGW_FDMODATTR_LEN);\n\n\tprintf(\"-M %s:\", type);\n\n\tif (mod.modtype & CGW_MOD_ID)\n\t\tprintf(\"I\");\n\n\tif (mod.modtype & CGW_MOD_FLAGS)\n\t\tprintf(\"F\");\n\n\tif (mod.modtype & CGW_MOD_LEN)\n\t\tprintf(\"L\");\n\n\tif (mod.modtype & CGW_MOD_DATA)\n\t\tprintf(\"D\");\n\n\tprintf(\":%03X.%X.%X.\", mod.cf.can_id, mod.cf.flags, mod.cf.len);\n\n\tfor (i = 0; i < CANFD_MAX_DLEN; i++)\n\t\tprintf(\"%02X\", mod.cf.data[i]);\n\n\tprintf(\" \");\n}\n\nstatic void print_cs_xor(struct cgw_csum_xor *cs_xor)\n{\n\tprintf(\"-x %d:%d:%d:%02X \",\n\t       cs_xor->from_idx, cs_xor->to_idx,\n\t       cs_xor->result_idx, cs_xor->init_xor_val);\n}\n\nstatic void print_cs_crc8_profile(struct cgw_csum_crc8 *cs_crc8)\n{\n\tint i;\n\n\tprintf(\"-p %d:\", cs_crc8->profile);\n\n\tswitch (cs_crc8->profile) {\n\n\tcase  CGW_CRC8PRF_1U8:\n\n\t\tprintf(\"%02X\", cs_crc8->profile_data[0]);\n\t\tbreak;\n\n\tcase  CGW_CRC8PRF_16U8:\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tprintf(\"%02X\", cs_crc8->profile_data[i]);\n\t\tbreak;\n\n\tcase  CGW_CRC8PRF_SFFID_XOR:\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"<unknown profile #%d>\", cs_crc8->profile);\n\t}\n\n\tprintf(\" \");\n}\n\nstatic void print_cs_crc8(struct cgw_csum_crc8 *cs_crc8)\n{\n\tint i;\n\n\tprintf(\"-c %d:%d:%d:%02X:%02X:\",\n\t       cs_crc8->from_idx, cs_crc8->to_idx,\n\t       cs_crc8->result_idx, cs_crc8->init_crc_val,\n\t       cs_crc8->final_xor_val);\n\n\tfor (i = 0; i < 256; i++)\n\t\tprintf(\"%02X\", cs_crc8->crctab[i]);\n\n\tprintf(\" \");\n\n\tif (cs_crc8->profile != CGW_CRC8PRF_UNSPEC)\n\t\tprint_cs_crc8_profile(cs_crc8);\n}\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - manage PF_CAN netlink gateway.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options]\\n\\n\", prg);\n\tfprintf(stderr, \"Commands:\\n\");\n\tfprintf(stderr, \"          -A  (add a new rule)\\n\");\n\tfprintf(stderr, \"          -D  (delete a rule)\\n\");\n\tfprintf(stderr, \"          -F  (flush / delete all rules)\\n\");\n\tfprintf(stderr, \"          -L  (list all rules)\\n\");\n\tfprintf(stderr, \"Mandatory:\\n\");\n\tfprintf(stderr, \"          -s <src_dev>  (source netdevice)\\n\");\n\tfprintf(stderr, \"          -d <dst_dev>  (destination netdevice)\\n\");\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"          -X  (this is a CAN FD rule)\\n\");\n\tfprintf(stderr, \"          -t  (preserve src_dev rx timestamp)\\n\");\n\tfprintf(stderr, \"          -e  (echo sent frames - recommended on vcanx)\\n\");\n\tfprintf(stderr, \"          -i  (allow to route to incoming interface)\\n\");\n\tfprintf(stderr, \"          -u <uid>  (user defined modification identifier)\\n\");\n\tfprintf(stderr, \"          -l <hops>  (limit the number of frame hops / routings)\\n\");\n\tfprintf(stderr, \"          -f <filter>  (set CAN filter)\\n\");\n\tfprintf(stderr, \"          -m <mod>  (set Classical CAN frame modifications)\\n\");\n\tfprintf(stderr, \"          -M <MOD>  (set CAN FD frame modifications)\\n\");\n\tfprintf(stderr, \"          -x <from_idx>:<to_idx>:<result_idx>:<init_xor_val>  (XOR checksum)\\n\");\n\tfprintf(stderr, \"          -c <from>:<to>:<result>:<init_val>:<xor_val>:<crctab[256]>  (CRC8 cs)\\n\");\n\tfprintf(stderr, \"          -p <profile>:[<profile_data>]  (CRC8 checksum profile & parameters)\\n\");\n\tfprintf(stderr, \"\\nValues are given and expected in hexadecimal values. Leading 0s can be omitted.\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"<filter> is a <value><mask> CAN identifier filter:\\n\");\n\tfprintf(stderr, \"  <can_id>:<can_mask>  (matches when <received_can_id> & mask == can_id & mask)\\n\");\n\tfprintf(stderr, \"  <can_id>~<can_mask>  (matches when <received_can_id> & mask != can_id & mask)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"<mod> is a Classical CAN frame modification instruction consisting of\\n\");\n\tfprintf(stderr, \"<instruction>:<can_frame-elements>:<can_id>.<can_dlc>.<can_data>\\n\");\n\tfprintf(stderr, \"  <instruction>  is one of 'AND' 'OR' 'XOR' 'SET'\\n\");\n\tfprintf(stderr, \"  <can_frame-elements>  is _one_ or _more_ of 'I'dentifier 'L'ength 'D'ata\\n\");\n\tfprintf(stderr, \"  <can_id>  is an u32 value containing the CAN Identifier\\n\");\n\tfprintf(stderr, \"  <can_dlc>  is an u8 value containing the data length code in hex (0 .. F)\\n\");\n\tfprintf(stderr, \"  <can_data>  is always eight(!) u8 values containing the CAN frames data\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"<MOD> is a CAN FD frame modification instruction consisting of\\n\");\n\tfprintf(stderr, \"<instruction>:<canfd_frame-elements>:<can_id>.<flags>.<len>.<can_data>\\n\");\n\tfprintf(stderr, \"  <instruction>  is one of 'AND' 'OR' 'XOR' 'SET'\\n\");\n\tfprintf(stderr, \"  <canfd_frame-elements>  is _one_ or _more_ of 'I'd 'F'lags 'L'ength 'D'ata\\n\");\n\tfprintf(stderr, \"  <can_id>  is an u32 value containing the CAN FD Identifier\\n\");\n\tfprintf(stderr, \"  <flags>  is an u8 value containing CAN FD flags (CANFD_BRS, CANFD_ESI)\\n\");\n\tfprintf(stderr, \"  <len>  is an u8 value containing the data length in hex (0 .. 40)\\n\");\n\tfprintf(stderr, \"  <can_data>  is always 64(!) u8 values containing the CAN FD frames data\\n\");\n\tfprintf(stderr, \"The max. four modifications are performed in the order AND -> OR -> XOR -> SET\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Supported CRC 8 profiles:\\n\");\n\tfprintf(stderr, \" Profile '%d' (1U8)        add one additional u8 value\\n\", CGW_CRC8PRF_1U8);\n\tfprintf(stderr, \" Profile '%d' (16U8)       add u8 value from table[16] indexed by (data[1] & 0xF)\\n\", CGW_CRC8PRF_16U8);\n\tfprintf(stderr, \" Profile '%d' (SFFID_XOR)  add u8 value (can_id & 0xFF) ^ (can_id >> 8 & 0xFF)\\n\", CGW_CRC8PRF_SFFID_XOR);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Examples:\\n\");\n\tfprintf(stderr, \"%s -A -s can0 -d vcan3 -e -f 123:C00007FF -m SET:IL:333.4.1122334455667788\\n\", prg);\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic int b64hex(char *asc, unsigned char *bin, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!sscanf(asc+(i*2), \"%2hhx\", bin+i))\n\t\t\treturn 1;\t\n\t}\n\treturn 0;\n}\n\nstatic int parse_crc8_profile(char *optarg, struct cgw_csum_crc8 *crc8)\n{\n\tint ret = 1;\n\tchar *ptr;\n\n\tif (sscanf(optarg, \"%hhu:\", &crc8->profile) != 1)\n\t\treturn ret;\n\n\tswitch (crc8->profile) {\n\n\tcase  CGW_CRC8PRF_1U8:\n\n\t\tif (sscanf(optarg, \"%hhu:%2hhx\", &crc8->profile, &crc8->profile_data[0]) == 2)\n\t\t\tret = 0;\n\n\t\tbreak;\n\n\tcase  CGW_CRC8PRF_16U8:\n\n\t\tptr = strchr(optarg, ':');\n\n\t\t/* check if length contains 16 base64 hex values */\n\t\tif (ptr != NULL &&\n\t\t    strlen(ptr) == strlen(\":00112233445566778899AABBCCDDEEFF\") &&\n\t\t    b64hex(ptr+1, (unsigned char *)&crc8->profile_data[0], 16) == 0)\n\t\t\tret = 0;\n\n\t\tbreak;\n\n\tcase  CGW_CRC8PRF_SFFID_XOR:\n\n\t\t/* no additional parameters needed */\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int parse_mod(char *optarg, struct modattr *modmsg)\n{\n\tchar *ptr, *nptr;\n\tchar hexdata[(CAN_MAX_DLEN * 2) + 1] = {0};\n\tcanid_t can_id;\n\n\tptr = optarg;\n\tnptr = strchr(ptr, ':');\n\n\tif ((nptr - ptr > 3) || (nptr - ptr == 0))\n\t\treturn 1;\n\n\tif (!strncmp(ptr, \"AND\", 3))\n\t\tmodmsg->instruction = CGW_MOD_AND;\n\telse if (!strncmp(ptr, \"OR\", 2))\n\t\tmodmsg->instruction = CGW_MOD_OR;\n\telse if (!strncmp(ptr, \"XOR\", 3))\n\t\tmodmsg->instruction = CGW_MOD_XOR;\n\telse if (!strncmp(ptr, \"SET\", 3))\n\t\tmodmsg->instruction = CGW_MOD_SET;\n\telse\n\t\treturn 2;\n\n\tptr = nptr+1;\n\tnptr = strchr(ptr, ':');\n\n\tif ((nptr - ptr > 3) || (nptr - ptr == 0))\n\t\treturn 3;\n\n\tmodmsg->modtype = 0;\n\n\twhile (*ptr != ':') {\n\n\t\tswitch (*ptr) {\n\n\t\tcase 'I':\n\t\t\tmodmsg->modtype |= CGW_MOD_ID;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tmodmsg->modtype |= CGW_MOD_DLC;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tmodmsg->modtype |= CGW_MOD_DATA;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 4;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (sscanf(++ptr, \"%x.%hhx.%16s\", &can_id,\n\t\t   (unsigned char *)&modmsg->cf.can_dlc, hexdata) != 3)\n\t\treturn 5;\n\n\tmodmsg->cf.can_id = can_id;\n\n\tif (strlen(hexdata) != (CAN_MAX_DLEN * 2))\n\t\treturn 6;\n\n\tif (b64hex(hexdata, &modmsg->cf.data[0], CAN_MAX_DLEN))\n\t\treturn 7;\n\n\treturn 0; /* ok */\n}\n\nstatic int parse_fdmod(char *optarg, struct fdmodattr *modmsg)\n{\n\tchar *ptr, *nptr;\n\tchar hexdata[(CANFD_MAX_DLEN * 2) + 1] = {0};\n\tcanid_t can_id;\n\n\tptr = optarg;\n\tnptr = strchr(ptr, ':');\n\n\tif ((nptr - ptr > 3) || (nptr - ptr == 0))\n\t\treturn 1;\n\n\tif (!strncmp(ptr, \"AND\", 3))\n\t\tmodmsg->instruction = CGW_FDMOD_AND;\n\telse if (!strncmp(ptr, \"OR\", 2))\n\t\tmodmsg->instruction = CGW_FDMOD_OR;\n\telse if (!strncmp(ptr, \"XOR\", 3))\n\t\tmodmsg->instruction = CGW_FDMOD_XOR;\n\telse if (!strncmp(ptr, \"SET\", 3))\n\t\tmodmsg->instruction = CGW_FDMOD_SET;\n\telse\n\t\treturn 2;\n\n\tptr = nptr+1;\n\tnptr = strchr(ptr, ':');\n\n\tif ((nptr - ptr > 4) || (nptr - ptr == 0))\n\t\treturn 3;\n\n\tmodmsg->modtype = 0;\n\n\twhile (*ptr != ':') {\n\n\t\tswitch (*ptr) {\n\n\t\tcase 'I':\n\t\t\tmodmsg->modtype |= CGW_MOD_ID;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tmodmsg->modtype |= CGW_MOD_FLAGS;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tmodmsg->modtype |= CGW_MOD_LEN;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tmodmsg->modtype |= CGW_MOD_DATA;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 4;\n\t\t}\n\t\tptr++;\n\t}\n\n\tif (sscanf(++ptr, \"%x.%hhx.%hhx.%128s\", &can_id,\n\t\t   (unsigned char *)&modmsg->cf.flags,\n\t\t   (unsigned char *)&modmsg->cf.len, hexdata) != 4)\n\t\treturn 5;\n\n\tmodmsg->cf.can_id = can_id;\n\n\tif (strlen(hexdata) != (CANFD_MAX_DLEN * 2))\n\t\treturn 6;\n\n\tif (b64hex(hexdata, &modmsg->cf.data[0], CANFD_MAX_DLEN))\n\t\treturn 7;\n\n\treturn 0; /* ok */\n}\n\nstatic int parse_rtlist(char *prgname, unsigned char *rxbuf, int len)\n{\n\tchar ifname[IF_NAMESIZE]; /* interface name for if_indextoname() */\n\tstruct rtcanmsg *rtc;\n\tstruct rtattr *rta;\n\tstruct nlmsghdr *nlh;\n\tunsigned int src_ifindex = 0;\n\tunsigned int dst_ifindex = 0;\n\t__u32 handled, dropped, deleted;\n\tint rtlen;\n\n\n\tnlh = (struct nlmsghdr *)rxbuf;\n\n\twhile (1) {\n\t\tif (!NLMSG_OK(nlh, len))\n\t\t\treturn 0;\n\n\t\tif (nlh->nlmsg_type == NLMSG_ERROR) {\n\t\t\tprintf(\"NLMSG_ERROR\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (nlh->nlmsg_type == NLMSG_DONE) {\n\t\t\t//printf(\"NLMSG_DONE\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\trtc = (struct rtcanmsg *)NLMSG_DATA(nlh);\n\t\tif (rtc->can_family != AF_CAN) {\n\t\t\tprintf(\"received msg from unknown family %d\\n\", rtc->can_family);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rtc->gwtype != CGW_TYPE_CAN_CAN) {\n\t\t\tprintf(\"received msg with unknown gwtype %d\\n\", rtc->gwtype);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * print list in a representation that\n\t\t * can be used directly for start scripts.\n\t\t *\n\t\t * To order the mandatory and optional parameters in the\n\t\t * output string, the NLMSG is parsed twice.\n\t\t */\n\n\t\thandled = 0;\n\t\tdropped = 0;\n\t\tdeleted = 0;\n\t\tsrc_ifindex = 0;\n\t\tdst_ifindex = 0;\n\n\t\tprintf(\"%s -A \", basename(prgname));\n\n\t\t/* first parse for mandatory options */\n\t\trta = (struct rtattr *) RTCAN_RTA(rtc);\n\t\trtlen = RTCAN_PAYLOAD(nlh);\n\t\tfor(;RTA_OK(rta, rtlen);rta=RTA_NEXT(rta,rtlen))\n\t\t{\n\t\t\t//printf(\"(A-%d)\", rta->rta_type);\n\t\t\tswitch(rta->rta_type) {\n\n\t\t\tcase CGW_FILTER:\n\t\t\tcase CGW_MOD_AND:\n\t\t\tcase CGW_MOD_OR:\n\t\t\tcase CGW_MOD_XOR:\n\t\t\tcase CGW_MOD_SET:\n\t\t\tcase CGW_FDMOD_AND:\n\t\t\tcase CGW_FDMOD_OR:\n\t\t\tcase CGW_FDMOD_XOR:\n\t\t\tcase CGW_FDMOD_SET:\n\t\t\tcase CGW_MOD_UID:\n\t\t\tcase CGW_LIM_HOPS:\n\t\t\tcase CGW_CS_XOR:\n\t\t\tcase CGW_CS_CRC8:\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_SRC_IF:\n\t\t\t\tsrc_ifindex = *(__u32 *)RTA_DATA(rta);\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_DST_IF:\n\t\t\t\tdst_ifindex = *(__u32 *)RTA_DATA(rta);\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_HANDLED:\n\t\t\t\thandled = *(__u32 *)RTA_DATA(rta);\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_DROPPED:\n\t\t\t\tdropped = *(__u32 *)RTA_DATA(rta);\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_DELETED:\n\t\t\t\tdeleted = *(__u32 *)RTA_DATA(rta);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"Unknown attribute %d!\", rta->rta_type);\n\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tprintf(\"-s %s \", if_indextoname(src_ifindex, ifname));\n\t\tprintf(\"-d %s \", if_indextoname(dst_ifindex, ifname));\n\n\t\tif (rtc->flags & CGW_FLAGS_CAN_FD)\n\t\t\tprintf(\"-X \");\n\n\t\tif (rtc->flags & CGW_FLAGS_CAN_ECHO)\n\t\t\tprintf(\"-e \");\n\n\t\tif (rtc->flags & CGW_FLAGS_CAN_SRC_TSTAMP)\n\t\t\tprintf(\"-t \");\n\n\t\tif (rtc->flags & CGW_FLAGS_CAN_IIF_TX_OK)\n\t\t\tprintf(\"-i \");\n\n\t\t/* second parse for mod attributes */\n\t\trta = (struct rtattr *) RTCAN_RTA(rtc);\n\t\trtlen = RTCAN_PAYLOAD(nlh);\n\t\tfor(;RTA_OK(rta, rtlen);rta=RTA_NEXT(rta,rtlen))\n\t\t{\n\t\t\t//printf(\"(B-%d)\", rta->rta_type);\n\t\t\tswitch(rta->rta_type) {\n\n\t\t\tcase CGW_FILTER:\n\t\t\t\tprintfilter(RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_MOD_AND:\n\t\t\t\tprintmod(\"AND\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_MOD_OR:\n\t\t\t\tprintmod(\"OR\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_MOD_XOR:\n\t\t\t\tprintmod(\"XOR\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_MOD_SET:\n\t\t\t\tprintmod(\"SET\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_FDMOD_AND:\n\t\t\t\tprintfdmod(\"AND\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_FDMOD_OR:\n\t\t\t\tprintfdmod(\"OR\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_FDMOD_XOR:\n\t\t\t\tprintfdmod(\"XOR\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_FDMOD_SET:\n\t\t\t\tprintfdmod(\"SET\", RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_MOD_UID:\n\t\t\t\tprintf(\"-u %X \", *(__u32 *)RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_LIM_HOPS:\n\t\t\t\tprintf(\"-l %d \", *(__u8 *)RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_CS_XOR:\n\t\t\t\tprint_cs_xor((struct cgw_csum_xor *)RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_CS_CRC8:\n\t\t\t\tprint_cs_crc8((struct cgw_csum_crc8 *)RTA_DATA(rta));\n\t\t\t\tbreak;\n\n\t\t\tcase CGW_SRC_IF:\n\t\t\tcase CGW_DST_IF:\n\t\t\tcase CGW_HANDLED:\n\t\t\tcase CGW_DROPPED:\n\t\t\tcase CGW_DELETED:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"Unknown attribute %d!\", rta->rta_type);\n\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* end of entry */\n\t\tprintf(\"# %d handled %d dropped %d deleted\\n\",\n\t\t       handled, dropped, deleted);\n\n\t\t/* jump to next NLMSG in the given buffer */\n\t\tnlh = NLMSG_NEXT(nlh, len);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tint s;\n\tint err = 0;\n\n\tint opt;\n\textern int optind, opterr, optopt;\n\n\tint cmd = UNSPEC;\n\tint have_filter = 0;\n\tint have_cs_xor = 0;\n\tint have_cs_crc8 = 0;\n\n\tstruct {\n\t\tstruct nlmsghdr nh;\n\t\tstruct rtcanmsg rtcan;\n\t\tchar buf[1500];\n\t} req;\n\n\tunsigned char rxbuf[8192]; /* netlink receive buffer */\n\tstruct nlmsghdr *nlh;\n\tstruct nlmsgerr *rte;\n\tunsigned int src_ifindex = 0;\n\tunsigned int dst_ifindex = 0;\n\t__u32 uid = 0;\n\t__u8 limit_hops = 0;\n\t__u16 flags = 0;\n\tint len;\n\n\tstruct can_filter filter;\n\tstruct sockaddr_nl nladdr;\n\n\tstruct cgw_csum_xor cs_xor = { 0 };\n\tstruct cgw_csum_crc8 cs_crc8 = { 0 };\n\tchar crc8tab[513] = {0};\n\n\tstruct modattr modmsg[CGW_MOD_FUNCS];\n\tstruct fdmodattr fdmodmsg[CGW_MOD_FUNCS];\n\tint modidx = 0;\n\tint fdmodidx = 0;\n\tint i;\n\n\tmemset(&req, 0, sizeof(req));\n\n\twhile ((opt = getopt(argc, argv, \"ADFLs:d:Xteiu:l:f:c:p:x:m:M:?\")) != -1) {\n\t\tswitch (opt) {\n\n\t\tcase 'A':\n\t\t\tif (cmd == UNSPEC)\n\t\t\t\tcmd = ADD;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (cmd == UNSPEC)\n\t\t\t\tcmd = DEL;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tif (cmd == UNSPEC)\n\t\t\t\tcmd = FLUSH;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tif (cmd == UNSPEC)\n\t\t\t\tcmd = LIST;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tsrc_ifindex = if_nametoindex(optarg);\n\t\t\tif (!src_ifindex) {\n\t\t\t\tperror(\"src if_nametoindex\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdst_ifindex = if_nametoindex(optarg);\n\t\t\tif (!dst_ifindex) {\n\t\t\t\tperror(\"dst if_nametoindex\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\tflags |= CGW_FLAGS_CAN_FD;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tflags |= CGW_FLAGS_CAN_SRC_TSTAMP;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tflags |= CGW_FLAGS_CAN_ECHO;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tflags |= CGW_FLAGS_CAN_IIF_TX_OK;\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t\tuid = strtoul(optarg, NULL, 16);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tif (sscanf(optarg, \"%hhu\", &limit_hops) != 1 || !(limit_hops)) {\n\t\t\t\tprintf(\"Bad hop limit definition '%s'.\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tif (sscanf(optarg, \"%x:%x\", &filter.can_id,\n\t\t\t\t   &filter.can_mask) == 2) {\n\t\t\t\thave_filter = 1;\n\t\t\t} else if (sscanf(optarg, \"%x~%x\", &filter.can_id,\n\t\t\t\t\t  &filter.can_mask) == 2) {\n\t\t\t\tfilter.can_id |= CAN_INV_FILTER;\n\t\t\t\thave_filter = 1;\n\t\t\t} else {\n\t\t\t\tprintf(\"Bad filter definition '%s'.\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tif (sscanf(optarg, \"%hhd:%hhd:%hhd:%hhx\",\n\t\t\t\t   &cs_xor.from_idx, &cs_xor.to_idx,\n\t\t\t\t   &cs_xor.result_idx, &cs_xor.init_xor_val) == 4) {\n\t\t\t\thave_cs_xor = 1;\n\t\t\t} else {\n\t\t\t\tprintf(\"Bad XOR checksum definition '%s'.\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tif ((sscanf(optarg, \"%hhd:%hhd:%hhd:%hhx:%hhx:%512s\",\n\t\t\t\t    &cs_crc8.from_idx, &cs_crc8.to_idx,\n\t\t\t\t    &cs_crc8.result_idx, &cs_crc8.init_crc_val,\n\t\t\t\t    &cs_crc8.final_xor_val, crc8tab) == 6) &&\n\t\t\t    (strlen(crc8tab) == 512) &&\n\t\t\t    (b64hex(crc8tab, (unsigned char *)&cs_crc8.crctab, 256) == 0)) {\n\t\t\t\thave_cs_crc8 = 1;\n\t\t\t} else {\n\t\t\t\tprintf(\"Bad CRC8 checksum definition '%s'.\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (parse_crc8_profile(optarg, &cs_crc8)) {\n\t\t\t\tprintf(\"Bad CRC8 profile definition '%s'.\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\t/* may be triggered by each of the CGW_MOD_FUNCS functions */\n\t\t\tif ((modidx < CGW_MOD_FUNCS) && (err = parse_mod(optarg, &modmsg[modidx++]))) {\n\t\t\t\tprintf(\"Problem %d with modification definition '%s'.\\n\", err, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'M':\n\t\t\t/* may be triggered by each of the CGW_FDMOD_FUNCS functions */\n\t\t\tif ((fdmodidx < CGW_MOD_FUNCS) && (err = parse_fdmod(optarg, &fdmodmsg[fdmodidx++]))) {\n\t\t\t\tprintf(\"Problem %d with modification definition '%s'.\\n\", err, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((argc - optind != 0) || (cmd == UNSPEC)) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(1);\n\t}\n\n\tif ((cmd == ADD || cmd == DEL) &&\n\t    ((!src_ifindex) || (!dst_ifindex))) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(1);\n\t}\n\n\tif (flags & CGW_FLAGS_CAN_FD) {\n\t\tif (modidx) {\n\t\t\tprintf(\"No -m modifications allowed in CAN FD mode!\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tif (fdmodidx) {\n\t\t\tprintf(\"No -M modifications allowed in Classic CAN mode!\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((!modidx && !fdmodidx) && (have_cs_crc8 || have_cs_xor)) {\n\t\tprintf(\"-c or -x can only be used in conjunction with -m/-M\\n\");\n\t\texit(1);\n\t}\n\n\ts = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\n\tswitch (cmd) {\n\n\tcase ADD:\n\t\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\n\t\treq.nh.nlmsg_type  = RTM_NEWROUTE;\n\t\tbreak;\n\n\tcase DEL:\n\t\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\n\t\treq.nh.nlmsg_type  = RTM_DELROUTE;\n\t\tbreak;\n\n\tcase FLUSH:\n\t\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\n\t\treq.nh.nlmsg_type  = RTM_DELROUTE;\n\t\t/* if_index set to 0 => remove all entries */\n\t\tsrc_ifindex  = 0;\n\t\tdst_ifindex  = 0;\n\t\tbreak;\n\n\tcase LIST:\n\t\treq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;\n\t\treq.nh.nlmsg_type  = RTM_GETROUTE;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"This function is not yet implemented.\\n\");\n\t\texit(1);\n\t\tbreak;\n\t}\n\n\treq.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct rtcanmsg));\n\treq.nh.nlmsg_seq   = 0;\n\n\treq.rtcan.can_family  = AF_CAN;\n\treq.rtcan.gwtype = CGW_TYPE_CAN_CAN;\n\treq.rtcan.flags = flags;\n\n\taddattr_l(&req.nh, sizeof(req), CGW_SRC_IF, &src_ifindex, sizeof(src_ifindex));\n\taddattr_l(&req.nh, sizeof(req), CGW_DST_IF, &dst_ifindex, sizeof(dst_ifindex));\n\n\t/* add new attributes here */\n\n\tif (have_filter)\n\t\taddattr_l(&req.nh, sizeof(req), CGW_FILTER, &filter, sizeof(filter));\n\n\tif (have_cs_crc8)\n\t\taddattr_l(&req.nh, sizeof(req), CGW_CS_CRC8, &cs_crc8, sizeof(cs_crc8));\n\n\tif (have_cs_xor)\n\t\taddattr_l(&req.nh, sizeof(req), CGW_CS_XOR, &cs_xor, sizeof(cs_xor));\n\n\tif (uid)\n\t\taddattr_l(&req.nh, sizeof(req), CGW_MOD_UID, &uid, sizeof(__u32));\n\n\tif (limit_hops)\n\t\taddattr_l(&req.nh, sizeof(req), CGW_LIM_HOPS, &limit_hops, sizeof(__u8));\n\n\t/*\n\t * a better example code\n\t * modmsg.modtype = CGW_MOD_ID;\n\t * addattr_l(&req.n, sizeof(req), CGW_MOD_SET, &modmsg, CGW_MODATTR_LEN);\n\t */\n\n\t/* add up to CGW_MOD_FUNCS modification definitions */\n\tfor (i = 0; i < modidx; i++)\n\t\taddattr_l(&req.nh, sizeof(req), modmsg[i].instruction, &modmsg[i], CGW_MODATTR_LEN);\n\n\t/* add up to CGW_FDMOD_FUNCS modification definitions */\n\tfor (i = 0; i < fdmodidx; i++)\n\t\taddattr_l(&req.nh, sizeof(req), fdmodmsg[i].instruction, &fdmodmsg[i], CGW_FDMODATTR_LEN);\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\tnladdr.nl_pid    = 0;\n\tnladdr.nl_groups = 0;\n\n\terr = sendto(s, &req, req.nh.nlmsg_len, 0,\n\t\t     (struct sockaddr*)&nladdr, sizeof(nladdr));\n\tif (err < 0) {\n\t\tperror(\"netlink sendto\");\n\t\treturn err;\n\t}\n\n\t/* clean netlink receive buffer */\n\tmemset(rxbuf, 0x0, sizeof(rxbuf));\n\n\tif (cmd != LIST) {\n\n\t\t/*\n\t\t * cmd == ADD || cmd == DEL || cmd == FLUSH\n\t\t *\n\t\t * Parse the requested netlink acknowledge return values.\n\t\t */\n\n\t\terr = recv(s, &rxbuf, sizeof(rxbuf), 0);\n\t\tif (err < 0) {\n\t\t\tperror(\"netlink recv\");\n\t\t\treturn err;\n\t\t}\n\t\tnlh = (struct nlmsghdr *)rxbuf;\n\t\tif (nlh->nlmsg_type != NLMSG_ERROR) {\n\t\t\tfprintf(stderr, \"unexpected netlink answer of type %d\\n\", nlh->nlmsg_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trte = (struct nlmsgerr *)NLMSG_DATA(nlh);\n\t\terr = rte->error;\n\t\tif (err < 0)\n\t\t\tfprintf(stderr, \"netlink error %d (%s)\\n\", err, strerror(abs(err)));\n\n\t} else {\n\n\t\t/* cmd == LIST */\n\n\t\twhile (1) {\n\t\t\tlen = recv(s, &rxbuf, sizeof(rxbuf), 0);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"netlink recv\");\n\t\t\t\treturn len;\n\t\t\t}\n#if 0\n\t\t\tprintf(\"received msg len %d\\n\", len);\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tprintf(\"%02X \", rxbuf[i]);\n\n\t\t\tprintf(\"\\n\");\n#endif\n\t\t\t/* leave on errors or NLMSG_DONE */\n\t\t\tif (parse_rtlist(argv[0], rxbuf, len))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tclose(s);\n\n\treturn err;\n}\n\n"
        },
        {
          "name": "canlogserver.c",
          "type": "blob",
          "size": 12.16796875,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * canlogserver.c\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <ctype.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <linux/sockios.h>\n#include <signal.h>\n\n#include \"lib.h\"\n\n#define MAXDEV 6 /* change sscanf()'s manually if changed here */\n#define ANYDEV \"any\"\n#define ANL \"\\r\\n\" /* newline in ASC mode */\n\n#define DEFPORT 28700\n\nstatic char devname[MAXDEV][IFNAMSIZ+1];\nstatic int  dindex[MAXDEV];\nstatic int  max_devname_len;\n\nextern int optind, opterr, optopt;\n\nstatic volatile int running = 1;\nstatic volatile sig_atomic_t signal_num;\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - log CAN frames and serves them.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>+\\n\", prg);\n\tfprintf(stderr, \"  (use CTRL-C to terminate %s)\\n\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -m <mask>   (ID filter mask.  Default 0x00000000) *\\n\");\n\tfprintf(stderr, \"         -v <value>  (ID filter value. Default 0x00000000) *\\n\");\n\tfprintf(stderr, \"         -i <0|1>    (invert the specified ID filter) *\\n\");\n\tfprintf(stderr, \"         -e <emask>  (mask for error frames)\\n\");\n\tfprintf(stderr, \"         -p <port>   (listen on port <port>. Default: %d)\\n\", DEFPORT);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"* The CAN ID filter matches, when ...\\n\");\n\tfprintf(stderr, \"       <received_can_id> & mask == value & mask\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"When using more than one CAN interface the options\\n\");\n\tfprintf(stderr, \"m/v/i/e have comma separated values e.g. '-m 0,7FF,0'\\n\");\n\tfprintf(stderr, \"\\nUse interface name '%s' to receive from all CAN interfaces.\\n\", ANYDEV);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"After running canlogserver, connect to it via TCP to get logged data.\\n\");\n\tfprintf(stderr, \"e.g. with 'nc localhost %d'\\n\", DEFPORT);\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic int idx2dindex(int ifidx, int socket)\n{\n\tint i;\n\tstruct ifreq ifr;\n\n\tfor (i=0; i<MAXDEV; i++) {\n\t\tif (dindex[i] == ifidx)\n\t\t\treturn i;\n\t}\n\n\t/* create new interface index cache entry */\n\n\t/* remove index cache zombies first */\n\tfor (i=0; i < MAXDEV; i++) {\n\t\tif (dindex[i]) {\n\t\t\tifr.ifr_ifindex = dindex[i];\n\t\t\tif (ioctl(socket, SIOCGIFNAME, &ifr) < 0)\n\t\t\t\tdindex[i] = 0;\n\t\t}\n\t}\n\n\tfor (i=0; i < MAXDEV; i++)\n\t\tif (!dindex[i]) /* free entry */\n\t\t\tbreak;\n\n\tif (i == MAXDEV) {\n\t\tprintf(\"Interface index cache only supports %d interfaces.\\n\", MAXDEV);\n\t\texit(1);\n\t}\n\n\tdindex[i] = ifidx;\n\n\tifr.ifr_ifindex = ifidx;\n\tif (ioctl(socket, SIOCGIFNAME, &ifr) < 0)\n\t\tperror(\"SIOCGIFNAME\");\n\n\tif (max_devname_len < (int)strlen(ifr.ifr_name))\n\t\tmax_devname_len = strlen(ifr.ifr_name);\n\n\tstrcpy(devname[i], ifr.ifr_name);\n\n\tpr_debug(\"new index %d (%s)\\n\", i, devname[i]);\n\n\treturn i;\n}\n\n/* \n * This is a Signalhandler. When we get a signal, that a child\n * terminated, we wait for it, so the zombie will disappear.\n */\nstatic void childdied(int i)\n{\n\twait(NULL);\n}\n\n/*\n * This is a Signalhandler for a caught SIGTERM\n */\nstatic void shutdown_gra(int i)\n{\n\trunning = 0;\n\tsignal_num = i;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct sigaction signalaction;\n\tsigset_t sigset;\n\tfd_set rdfs;\n\tint s[MAXDEV];\n\tint socki, accsocket;\n\tcanid_t mask[MAXDEV] = {0};\n\tcanid_t value[MAXDEV] = {0};\n\tint inv_filter[MAXDEV] = {0};\n\tcan_err_mask_t err_mask[MAXDEV] = {0};\n\tint opt, ret;\n\tint currmax = 1; /* we assume at least one can bus ;-) */\n\tstruct sockaddr_can addr;\n\tstruct can_raw_vcid_options vcid_opts = {\n\t\t.flags = CAN_RAW_XL_VCID_RX_FILTER,\n\t\t.rx_vcid = 0,\n\t\t.rx_vcid_mask = 0,\n\t};\n\tstruct can_filter rfilter;\n\tstatic cu_t cu; /* union for CAN CC/FD/XL frames */\n\tconst int canfx_on = 1;\n\tint nbytes, i, j;\n\tstruct ifreq ifr;\n\tstruct timeval tv;\n\tint port = DEFPORT;\n\tstruct sockaddr_in inaddr;\n\tstruct sockaddr_in clientaddr;\n\tsocklen_t sin_size = sizeof(clientaddr);\n\tstatic char afrbuf[AFRSZ];\n\n\tsigemptyset(&sigset);\n\tsignalaction.sa_handler = &childdied;\n\tsignalaction.sa_mask = sigset;\n\tsignalaction.sa_flags = 0;\n\tsigaction(SIGCHLD, &signalaction, NULL);  /* install signal for dying child */\n\tsignalaction.sa_handler = &shutdown_gra;\n\tsignalaction.sa_mask = sigset;\n\tsignalaction.sa_flags = 0;\n\tsigaction(SIGTERM, &signalaction, NULL); /* install Signal for termination */\n\tsigaction(SIGINT, &signalaction, NULL); /* install Signal for termination */\n\n\twhile ((opt = getopt(argc, argv, \"m:v:i:e:p:?\")) != -1) {\n\n\t\tswitch (opt) {\n\t\tcase 'm':\n\t\t\ti = sscanf(optarg, \"%x,%x,%x,%x,%x,%x\",\n\t\t\t\t   &mask[0], &mask[1], &mask[2],\n\t\t\t\t   &mask[3], &mask[4], &mask[5]);\n\t\t\tif (i > currmax)\n\t\t\t\tcurrmax = i;\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\ti = sscanf(optarg, \"%x,%x,%x,%x,%x,%x\",\n\t\t\t\t   &value[0], &value[1], &value[2],\n\t\t\t\t   &value[3], &value[4], &value[5]);\n\t\t\tif (i > currmax)\n\t\t\t\tcurrmax = i;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\ti = sscanf(optarg, \"%d,%d,%d,%d,%d,%d\",\n\t\t\t\t   &inv_filter[0], &inv_filter[1], &inv_filter[2],\n\t\t\t\t   &inv_filter[3], &inv_filter[4], &inv_filter[5]);\n\t\t\tif (i > currmax)\n\t\t\t\tcurrmax = i;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\ti = sscanf(optarg, \"%x,%x,%x,%x,%x,%x\",\n\t\t\t\t   &err_mask[0], &err_mask[1], &err_mask[2],\n\t\t\t\t   &err_mask[3], &err_mask[4], &err_mask[5]);\n\t\t\tif (i > currmax)\n\t\t\t\tcurrmax = i;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tport = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind == argc) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(0);\n\t}\n\n\t/* count in options higher than device count ? */\n\tif (optind + currmax > argc) {\n\t\tprintf(\"low count of CAN devices!\\n\");\n\t\treturn 1;\n\t}\n\n\tcurrmax = argc - optind; /* find real number of CAN devices */\n\n\tif (currmax > MAXDEV) {\n\t\tprintf(\"More than %d CAN devices!\\n\", MAXDEV);\n\t\treturn 1;\n\t}\n\n\n\tsocki = socket(PF_INET, SOCK_STREAM, 0);\n\tif (socki < 0) {\n\t\tperror(\"socket\");\n\t\texit(1);\n\t}\n\n\tinaddr.sin_family = AF_INET;\n\tinaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tinaddr.sin_port = htons(port);\n\n\twhile(bind(socki, (struct sockaddr*)&inaddr, sizeof(inaddr)) < 0) {\n\t\tstruct timespec f = {\n\t\t\t.tv_nsec = 100 * 1000 * 1000,\n\t\t};\n\n\t\tprintf(\".\");fflush(NULL);\n\t\tnanosleep(&f, NULL);\n\t}\n\n\tif (listen(socki, 3) != 0) {\n\t\tperror(\"listen\");\n\t\texit(1);\n\t}\n\n\twhile(1) {\n\t\taccsocket = accept(socki, (struct sockaddr*)&clientaddr, &sin_size);\n\t\tif (accsocket > 0) {\n\t\t\t//printf(\"accepted\\n\");\n\t\t\tif (!fork())\n\t\t\t\tbreak;\n\t\t\tclose(accsocket);\n\t\t}\n\t\telse if (errno != EINTR) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfor (i=0; i<currmax; i++) {\n\n\t\tpr_debug(\"open %d '%s' m%08X v%08X i%d e%d.\\n\",\n\t\t      i, argv[optind+i], mask[i], value[i],\n\t\t      inv_filter[i], err_mask[i]);\n\n\t\tif ((s[i] = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {\n\t\t\tperror(\"socket\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (mask[i] || value[i]) {\n\n\t\t\tprintf(\"CAN ID filter[%d] for %s set to \"\n\t\t\t       \"mask = %08X, value = %08X %s\\n\",\n\t\t\t       i, argv[optind+i], mask[i], value[i],\n\t\t\t       (inv_filter[i]) ? \"(inv_filter)\" : \"\");\n\n\t\t\trfilter.can_id   = value[i];\n\t\t\trfilter.can_mask = mask[i];\n\t\t\tif (inv_filter[i])\n\t\t\t\trfilter.can_id |= CAN_INV_FILTER;\n\n\t\t\tsetsockopt(s[i], SOL_CAN_RAW, CAN_RAW_FILTER,\n\t\t\t\t   &rfilter, sizeof(rfilter));\n\t\t}\n\n\t\tif (err_mask[i])\n\t\t\tsetsockopt(s[i], SOL_CAN_RAW, CAN_RAW_ERR_FILTER,\n\t\t\t\t   &err_mask[i], sizeof(err_mask[i]));\n\n\t\t/* try to switch the socket into CAN FD mode */\n\t\tsetsockopt(s[i], SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfx_on, sizeof(canfx_on));\n\n\t\t/* try to switch the socket into CAN XL mode */\n\t\tsetsockopt(s[i], SOL_CAN_RAW, CAN_RAW_XL_FRAMES, &canfx_on, sizeof(canfx_on));\n\n\t\t/* try to enable the CAN XL VCID pass through mode */\n\t\tsetsockopt(s[i], SOL_CAN_RAW, CAN_RAW_XL_VCID_OPTS, &vcid_opts, sizeof(vcid_opts));\n\n\t\tj = strlen(argv[optind+i]);\n\n\t\tif (!(j < IFNAMSIZ)) {\n\t\t\tprintf(\"name of CAN device '%s' is too long!\\n\", argv[optind+i]);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (j > max_devname_len)\n\t\t\tmax_devname_len = j; /* for nice printing */\n\n\t\taddr.can_family = AF_CAN;\n\n\t\tif (strcmp(ANYDEV, argv[optind + i]) != 0) {\n\t\t\tstrcpy(ifr.ifr_name, argv[optind+i]);\n\t\t\tif (ioctl(s[i], SIOCGIFINDEX, &ifr) < 0) {\n\t\t\t\tperror(\"SIOCGIFINDEX\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\taddr.can_ifindex = ifr.ifr_ifindex;\n\t\t} else\n\t\t\taddr.can_ifindex = 0; /* any can interface */\n\n\t\tif (bind(s[i], (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\t\tperror(\"bindcan\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\twhile (running) {\n\n\t\tFD_ZERO(&rdfs);\n\t\tfor (i=0; i<currmax; i++)\n\t\t\tFD_SET(s[i], &rdfs);\n\n\t\tif ((ret = select(s[currmax-1]+1, &rdfs, NULL, NULL, NULL)) < 0) {\n\t\t\t//perror(\"select\");\n\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i=0; i<currmax; i++) {  /* check all CAN RAW sockets */\n\n\t\t\tif (FD_ISSET(s[i], &rdfs)) {\n\n\t\t\t\tsocklen_t len = sizeof(addr);\n\t\t\t\tint idx;\n\n\t\t\t\tif ((nbytes = recvfrom(s[i], &cu, sizeof(cu), 0,\n\t\t\t\t\t\t       (struct sockaddr*)&addr, &len)) < 0) {\n\t\t\t\t\tperror(\"read\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (nbytes < (int)CANXL_HDR_SIZE + CANXL_MIN_DLEN) {\n\t\t\t\t\tfprintf(stderr, \"read: no CAN frame\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (cu.xl.flags & CANXL_XLF) {\n\t\t\t\t\tif (nbytes != (int)CANXL_HDR_SIZE + cu.xl.len) {\n\t\t\t\t\t\tprintf(\"nbytes = %d\\n\", nbytes);\n\t\t\t\t\t\tfprintf(stderr, \"read: no CAN XL frame\\n\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* mark dual-use struct canfd_frame */\n\t\t\t\t\tif (nbytes == CAN_MTU) {\n\t\t\t\t\t\tcu.fd.flags = 0;\n\t\t\t\t\t} else if (nbytes == CANFD_MTU) {\n\t\t\t\t\t\tcu.fd.flags |= CANFD_FDF;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"read: incomplete CAN CC/FD frame\\n\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ioctl(s[i], SIOCGSTAMP, &tv) < 0)\n\t\t\t\t\tperror(\"SIOCGSTAMP\");\n\n\n\t\t\t\tidx = idx2dindex(addr.can_ifindex, s[i]);\n\n\t\t\t\tsprintf(afrbuf, \"(%llu.%06llu) %*s \",\n\t\t\t\t\t(unsigned long long)tv.tv_sec, (unsigned long long)tv.tv_usec, max_devname_len, devname[idx]);\n\t\t\t\tsnprintf_canframe(afrbuf + strlen(afrbuf), sizeof(afrbuf) - strlen(afrbuf), &cu, 0);\n\t\t\t\tstrcat(afrbuf, \"\\n\");\n\n\t\t\t\tif (write(accsocket, afrbuf, strlen(afrbuf)) < 0) {\n\t\t\t\t\tperror(\"writeaccsock\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t    \n#if 0\n\t\t\t\t/* print CAN frame in log file style to stdout */\n\t\t\t\tprintf(\"%s\", afrbuf);\n#endif\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfor (i=0; i<currmax; i++)\n\t\tclose(s[i]);\n\n\tclose(accsocket);\n\n\tif (signal_num)\n\t\treturn 128 + signal_num;\n\n\treturn 0;\n}\n"
        },
        {
          "name": "canplayer.c",
          "type": "blob",
          "size": 16.28125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * canplayer.c - replay a compact CAN frame logfile to CAN devices\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n\n#include \"lib.h\"\n\n#define DEFAULT_GAP 1 /* ms */\n#define DEFAULT_LOOPS 1 /* only one replay */\n#define CHANNELS 20 /* anyone using more than 20 CAN interfaces at a time? */\n#define STDOUTIDX 65536 /* interface index for printing on stdout - bigger than max uint16 */\n\n#if (IFNAMSIZ != 16)\n#error \"IFNAMSIZ value does not to DEVSZ calculation!\"\n#endif\n\n#define DEVSZ 22 /* IFNAMSZ + 6 */\n#define TIMESZ sizeof(\"(1345212884.318850)   \")\n#define BUFSZ (TIMESZ + DEVSZ + AFRSZ)\n\n/* adapt sscanf() functions below on error */\n#if (AFRSZ != 6300)\n#error \"AFRSZ value does not fit sscanf restrictions!\"\n#endif\n#if (DEVSZ != 22)\n#error \"DEVSZ value does not fit sscanf restrictions!\"\n#endif\n\nstruct assignment {\n\tchar txif[IFNAMSIZ];\n\tint txifidx;\n\tchar rxif[IFNAMSIZ];\n};\nstatic struct assignment asgn[CHANNELS];\nconst int canfx_on = 1;\n\nextern int optind, opterr, optopt;\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - replay a compact CAN frame logfile to CAN devices.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s <options> [interface assignment]*\\n\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -I <infile>  (default stdin)\\n\");\n\tfprintf(stderr,\n\t\t\"         -l <num>     \"\n\t\t\"(process input file <num> times)\\n\"\n\t\t\"                      \"\n\t\t\"(Use 'i' for infinite loop - default: %d)\\n\",\n\t\tDEFAULT_LOOPS);\n\tfprintf(stderr, \"         -t           (ignore timestamps: \"\n\t\t\t\"send frames immediately)\\n\");\n\tfprintf(stderr, \"         -i           (interactive - wait \"\n\t\t\t\"for ENTER key to process next frame)\\n\");\n\tfprintf(stderr, \"         -n <count>   (terminate after \"\n\t\t\t\"processing <count> CAN frames)\\n\");\n\tfprintf(stderr,\n\t\t\"         -g <ms>      (gap in milli \"\n\t\t\"seconds - default: %d ms)\\n\",\n\t\tDEFAULT_GAP);\n\tfprintf(stderr, \"         -s <s>       (skip gaps in \"\n\t\t\t\"timestamps > 's' seconds)\\n\");\n\tfprintf(stderr, \"         -x           (disable local \"\n\t\t\t\"loopback of sent CAN frames)\\n\");\n\tfprintf(stderr, \"         -v           (verbose: print \"\n\t\t\t\"sent CAN frames)\\n\");\n\tfprintf(stderr, \"         -h           (show \"\n\t\t\t\"this help message)\\n\\n\");\n\tfprintf(stderr, \"Interface assignment:\\n\");\n\tfprintf(stderr, \" 0..n assignments like <write-if>=<log-if>\\n\\n\");\n\tfprintf(stderr, \" e.g. vcan2=can0  (send frames received from can0 on \"\n\t\t\t\"vcan2)\\n\");\n\tfprintf(stderr, \" extra hook: stdout=can0  (print logfile line marked with can0 on \"\n\t\t\t\"stdout)\\n\");\n\tfprintf(stderr, \" No assignments  => send frames to the interface(s) they \"\n\t\t\t\"had been received from\\n\\n\");\n\tfprintf(stderr, \"Lines in the logfile not beginning with '(' (start of \"\n\t\t\t\"timestamp) are ignored.\\n\\n\");\n}\n\n/* copied from /usr/src/linux/include/linux/time.h ...\n * lhs < rhs:  return <0\n * lhs == rhs: return 0\n * lhs > rhs:  return >0\n */\nstatic inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)\n{\n\tif (lhs->tv_sec < rhs->tv_sec)\n\t\treturn -1;\n\tif (lhs->tv_sec > rhs->tv_sec)\n\t\treturn 1;\n\treturn lhs->tv_usec - rhs->tv_usec;\n}\n\nstatic inline void create_diff_tv(struct timeval *today, struct timeval *diff, struct timeval *log)\n{\n\t/* create diff_tv so that log_tv + diff_tv = today_tv */\n\tdiff->tv_sec = today->tv_sec - log->tv_sec;\n\tdiff->tv_usec = today->tv_usec - log->tv_usec;\n}\n\nstatic inline int frames_to_send(struct timeval *today, struct timeval *diff, struct timeval *log)\n{\n\t/* return value <0 when log + diff < today */\n\n\tstruct timeval cmp;\n\n\tcmp.tv_sec = log->tv_sec + diff->tv_sec;\n\tcmp.tv_usec = log->tv_usec + diff->tv_usec;\n\n\tif (cmp.tv_usec >= 1000000) {\n\t\tcmp.tv_usec -= 1000000;\n\t\tcmp.tv_sec++;\n\t}\n\n\tif (cmp.tv_usec < 0) {\n\t\tcmp.tv_usec += 1000000;\n\t\tcmp.tv_sec--;\n\t}\n\n\treturn timeval_compare(&cmp, today);\n}\n\nstatic int get_txidx(char *logif_name)\n{\n\tint i;\n\n\tfor (i = 0; i < CHANNELS; i++) {\n\t\tif (asgn[i].rxif[0] == 0) /* end of table content */\n\t\t\tbreak;\n\t\tif (strcmp(asgn[i].rxif, logif_name) == 0) /* found device name */\n\t\t\tbreak;\n\t}\n\n\tif ((i == CHANNELS) || (asgn[i].rxif[0] == 0))\n\t\treturn 0; /* not found */\n\n\treturn asgn[i].txifidx; /* return interface index */\n}\n\nstatic char *get_txname(char *logif_name)\n{\n\tint i;\n\n\tfor (i = 0; i < CHANNELS; i++) {\n\t\tif (asgn[i].rxif[0] == 0) /* end of table content */\n\t\t\tbreak;\n\t\tif (strcmp(asgn[i].rxif, logif_name) == 0) /* found device name */\n\t\t\tbreak;\n\t}\n\n\tif ((i == CHANNELS) || (asgn[i].rxif[0] == 0))\n\t\treturn 0; /* not found */\n\n\treturn asgn[i].txif; /* return interface name */\n}\n\nstatic int add_assignment(char *mode, int socket, char *txname,\n\t\t\t  char *rxname, int verbose)\n{\n\tstruct ifreq ifr;\n\tint i;\n\n\t/* find free entry */\n\tfor (i = 0; i < CHANNELS; i++) {\n\t\tif (asgn[i].txif[0] == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == CHANNELS) {\n\t\tfprintf(stderr, \"Assignment table exceeded!\\n\");\n\t\treturn 1;\n\t}\n\n\tif (strlen(txname) >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"write-if interface name '%s' too long!\", txname);\n\t\treturn 1;\n\t}\n\tstrcpy(asgn[i].txif, txname);\n\n\tif (strlen(rxname) >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"log-if interface name '%s' too long!\", rxname);\n\t\treturn 1;\n\t}\n\tstrcpy(asgn[i].rxif, rxname);\n\n\tif (strcmp(txname, \"stdout\") != 0) {\n\t\tstrcpy(ifr.ifr_name, txname);\n\t\tif (ioctl(socket, SIOCGIFINDEX, &ifr) < 0) {\n\t\t\tperror(\"SIOCGIFINDEX\");\n\t\t\tfprintf(stderr, \"write-if interface name '%s' is wrong!\\n\", txname);\n\t\t\treturn 1;\n\t\t}\n\t\tasgn[i].txifidx = ifr.ifr_ifindex;\n\t} else\n\t\tasgn[i].txifidx = STDOUTIDX;\n\n\tif (verbose > 1) /* use -v -v to see this */\n\t\tprintf(\"added %s assignment: log-if=%s write-if=%s write-if-idx=%d\\n\", mode, asgn[i].rxif, asgn[i].txif, asgn[i].txifidx);\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tstatic char buf[BUFSZ], device[DEVSZ], afrbuf[AFRSZ];\n\tstruct sockaddr_can addr;\n\tstruct can_raw_vcid_options vcid_opts = {\n\t\t.flags = CAN_RAW_XL_VCID_TX_PASS,\n\t};\n\tstatic cu_t cu;\n\tstatic struct timeval today_tv, log_tv, last_log_tv, diff_tv;\n\tstruct timespec sleep_ts;\n\tint s; /* CAN_RAW socket */\n\tFILE *infile = stdin;\n\tunsigned long gap = DEFAULT_GAP;\n\tint use_timestamps = 1;\n\tint interactive = 0; /* wait for ENTER keypress to process next frame */\n\tint count = 0; /* end replay after sending count frames. 0 = disabled */\n\tstatic int verbose, opt, delay_loops;\n\tstatic unsigned long skipgap;\n\tstatic int loopback_disable = 0;\n\tstatic int infinite_loops = 0;\n\tstatic int loops = DEFAULT_LOOPS;\n\tint assignments; /* assignments defined on the commandline */\n\tint txidx; /* sendto() interface index */\n\tint eof, txmtu, i, j;\n\tchar *fret;\n\tunsigned long long sec, usec;\n\n\twhile ((opt = getopt(argc, argv, \"I:l:tin:g:s:xvh\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'I':\n\t\t\tinfile = fopen(optarg, \"r\");\n\t\t\tif (!infile) {\n\t\t\t\tperror(\"infile\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tif (optarg[0] == 'i')\n\t\t\t\tinfinite_loops = 1;\n\t\t\telse if (!(loops = atoi(optarg))) {\n\t\t\t\tfprintf(stderr, \"Invalid argument for option -l !\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tuse_timestamps = 0;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tinteractive = 1;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tcount = atoi(optarg);\n\t\t\tif (count < 1) {\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\tgap = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tskipgap = strtoul(optarg, NULL, 10);\n\t\t\tif (skipgap < 1) {\n\t\t\t\tfprintf(stderr, \"Invalid argument for option -s !\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tloopback_disable = 1;\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tassignments = argc - optind; /* find real number of user assignments */\n\n\tif (infile == stdin) { /* no jokes with stdin */\n\t\tinfinite_loops = 0;\n\t\tloops = 1;\n\t}\n\n\tif (verbose > 1) { /* use -v -v to see this */\n\t\tif (infinite_loops)\n\t\t\tprintf(\"infinite_loops\\n\");\n\t\telse\n\t\t\tprintf(\"%d loops\\n\", loops);\n\t}\n\n\t/* ignore timestamps from logfile when in single step keypress mode */\n\tif (interactive) {\n\t\tuse_timestamps = 0;\n\t\tprintf(\"interactive mode: press ENTER to process next CAN frame ...\\n\");\n\t}\n\n\tsleep_ts.tv_sec = gap / 1000;\n\tsleep_ts.tv_nsec = (gap % 1000) * 1000000;\n\n\t/* open socket */\n\tif ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = 0;\n\n\t/* disable unneeded default receive filter on this RAW socket */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);\n\n\t/* try to switch the socket into CAN FD mode */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfx_on, sizeof(canfx_on));\n\n\t/* try to switch the socket into CAN XL mode */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_XL_FRAMES, &canfx_on, sizeof(canfx_on));\n\n\t/* try to enable the CAN XL VCID pass through mode */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_XL_VCID_OPTS, &vcid_opts, sizeof(vcid_opts));\n\n\tif (loopback_disable) {\n\t\tint loopback = 0;\n\n\t\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK, &loopback, sizeof(loopback));\n\t}\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\treturn 1;\n\t}\n\n\tif (assignments) {\n\t\t/* add & check user assignments from commandline */\n\t\tfor (i = 0; i < assignments; i++) {\n\t\t\tif (strlen(argv[optind + i]) >= BUFSZ) {\n\t\t\t\tfprintf(stderr, \"Assignment too long!\\n\");\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tstrcpy(buf, argv[optind + i]);\n\t\t\tfor (j = 0; j < (int)BUFSZ; j++) { /* find '=' in assignment */\n\t\t\t\tif (buf[j] == '=')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((j == BUFSZ) || (buf[j] != '=')) {\n\t\t\t\tfprintf(stderr, \"'=' missing in assignment!\\n\");\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbuf[j] = 0; /* cut string in two pieces */\n\t\t\tif (add_assignment(\"user\", s, &buf[0], &buf[j + 1], verbose))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\twhile (infinite_loops || loops--) {\n\t\tif (infile != stdin)\n\t\t\trewind(infile); /* for each loop */\n\n\t\tif (verbose > 1) /* use -v -v to see this */\n\t\t\tprintf(\">>>>>>>>> start reading file. remaining loops = %d\\n\", loops);\n\n\t\t/* read first non-comment frame from logfile */\n\t\twhile ((fret = fgets(buf, BUFSZ - 1, infile)) != NULL && buf[0] != '(') {\n\t\t\tif (strlen(buf) >= BUFSZ - 2) {\n\t\t\t\tfprintf(stderr, \"comment line too long for input buffer\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!fret)\n\t\t\tgoto out; /* nothing to read */\n\n\t\teof = 0;\n\n\t\tif (sscanf(buf, \"(%llu.%llu) %21s %6299s\", &sec, &usec, device, afrbuf) != 4) {\n\t\t\tfprintf(stderr, \"incorrect line format in logfile\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tlog_tv.tv_sec = sec;\n\t\tlog_tv.tv_usec = usec;\n\n\t\t/*\n\t\t * ensure the fractions of seconds are 6 decimal places long to catch\n\t\t * 3rd party or handcrafted logfiles that treat the timestamp as float\n\t\t */\n\t\tif (strchr(buf, ')') - strchr(buf, '.') != 7) {\n\t\t\tfprintf(stderr, \"timestamp format in logfile requires 6 decimal places\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (use_timestamps) { /* throttle sending due to logfile timestamps */\n\n\t\t\tgettimeofday(&today_tv, NULL);\n\t\t\tcreate_diff_tv(&today_tv, &diff_tv, &log_tv);\n\t\t\tlast_log_tv = log_tv;\n\t\t}\n\n\t\twhile (!eof) {\n\t\t\twhile ((!use_timestamps) || (frames_to_send(&today_tv, &diff_tv, &log_tv) < 0)) {\n\t\t\t\t/* wait for keypress to process next frame */\n\t\t\t\tif (interactive)\n\t\t\t\t\tgetchar();\n\n\t\t\t\t/* log_tv/device/afrbuf are valid here */\n\n\t\t\t\tif (strlen(device) >= IFNAMSIZ) {\n\t\t\t\t\tfprintf(stderr, \"log interface name '%s' too long!\", device);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\ttxidx = get_txidx(device); /* get ifindex for sending the frame */\n\n\t\t\t\tif ((!txidx) && (!assignments)) {\n\t\t\t\t\t/* ifindex not found and no user assignments */\n\t\t\t\t\t/* => assign this device automatically       */\n\t\t\t\t\tif (add_assignment(\"auto\", s, device, device, verbose))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\ttxidx = get_txidx(device);\n\t\t\t\t}\n\n\t\t\t\tif (txidx == STDOUTIDX) { /* hook to print logfile lines on stdout */\n\n\t\t\t\t\tprintf(\"%s\", buf); /* print the line AS-IS without extra \\n */\n\t\t\t\t\tfflush(stdout);\n\n\t\t\t\t} else if (txidx > 0) { /* only send to valid CAN devices */\n\n\t\t\t\t\ttxmtu = parse_canframe(afrbuf, &cu); /* dual-use frame */\n\t\t\t\t\tif (!txmtu) {\n\t\t\t\t\t\tfprintf(stderr, \"wrong CAN frame format: '%s'!\", afrbuf);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* CAN XL frames need real frame length for sending */\n\t\t\t\t\tif (txmtu == CANXL_MTU)\n\t\t\t\t\t\ttxmtu = CANXL_HDR_SIZE + cu.xl.len;\n\n\t\t\t\t\taddr.can_family = AF_CAN;\n\t\t\t\t\taddr.can_ifindex = txidx; /* send via this interface */\n\n\t\t\t\t\tif (sendto(s, &cu, txmtu, 0, (struct sockaddr *)&addr, sizeof(addr)) != txmtu) {\n\t\t\t\t\t\tperror(\"sendto\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tprintf(\"%s (%s) \", get_txname(device), device);\n\t\t\t\t\t\tsnprintf_long_canframe(afrbuf, sizeof(afrbuf), &cu, CANLIB_VIEW_INDENT_SFF);\n\t\t\t\t\t\tprintf(\"%s\\n\", afrbuf);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (count && (--count == 0))\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t/* read next non-comment frame from logfile */\n\t\t\t\twhile ((fret = fgets(buf, BUFSZ - 1, infile)) != NULL && buf[0] != '(') {\n\t\t\t\t\tif (strlen(buf) >= BUFSZ - 2) {\n\t\t\t\t\t\tfprintf(stderr, \"comment line too long for input buffer\\n\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!fret) {\n\t\t\t\t\teof = 1; /* this file is completely processed */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (sscanf(buf, \"(%llu.%llu) %s %s\", &sec, &usec, device, afrbuf) != 4) {\n\t\t\t\t\tfprintf(stderr, \"incorrect line format in logfile\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tlog_tv.tv_sec = sec;\n\t\t\t\tlog_tv.tv_usec = usec;\n\n\t\t\t\t/*\n\t\t\t\t * ensure the fractions of seconds are 6 decimal places long to catch\n\t\t\t\t * 3rd party or handcrafted logfiles that treat the timestamp as float\n\t\t\t\t */\n\t\t\t\tif (strchr(buf, ')') - strchr(buf, '.') != 7) {\n\t\t\t\t\tfprintf(stderr, \"timestamp format in logfile requires 6 decimal places\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (use_timestamps) {\n\t\t\t\t\tgettimeofday(&today_tv, NULL);\n\n\t\t\t\t\t/* test for logfile timestamps jumping backwards OR      */\n\t\t\t\t\t/* if the user likes to skip long gaps in the timestamps */\n\t\t\t\t\tif ((last_log_tv.tv_sec > log_tv.tv_sec) || (skipgap && labs(last_log_tv.tv_sec - log_tv.tv_sec) > (long)skipgap))\n\t\t\t\t\t\tcreate_diff_tv(&today_tv, &diff_tv, &log_tv);\n\n\t\t\t\t\tlast_log_tv = log_tv;\n\t\t\t\t}\n\n\t\t\t} /* while frames_to_send ... */\n\n\t\t\tif (nanosleep(&sleep_ts, NULL))\n\t\t\t\treturn 1;\n\n\t\t\tdelay_loops++; /* private statistics */\n\t\t\tgettimeofday(&today_tv, NULL);\n\n\t\t} /* while (!eof) */\n\n\t} /* while (infinite_loops || loops--) */\n\nout:\n\n\tclose(s);\n\tfclose(infile);\n\n\tif (verbose > 1) /* use -v -v to see this */\n\t\tprintf(\"%d delay_loops\\n\", delay_loops);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "cansend.c",
          "type": "blob",
          "size": 6.7392578125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * cansend.c - send CAN-frames via CAN_RAW sockets\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n\n#include \"lib.h\"\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr,\n\t\t\"%s - send CAN-frames via CAN_RAW sockets.\\n\"\n\t\t\"\\n\"\n\t\t\"Usage: %s <device> <can_frame>.\\n\"\n\t\t\"\\n\"\n\t\t\"<can_frame>:\\n\"\n\t\t\" <can_id>#{data}          for CAN CC (Classical CAN 2.0B) data frames\\n\"\n\t\t\" <can_id>#R{len}          for CAN CC (Classical CAN 2.0B) data frames\\n\"\n\t\t\" <can_id>#{data}_{dlc}    for CAN CC (Classical CAN 2.0B) data frames\\n\"\n\t\t\" <can_id>#R{len}_{dlc}    for CAN CC (Classical CAN 2.0B) data frames\\n\"\n\t\t\" <can_id>##<flags>{data}  for CAN FD frames\\n\"\n\t\t\" <vcid><prio>#<flags>:<sdt>:<af>#<data> for CAN XL frames\\n\"\n\t\t\"\\n\"\n\t\t\"<can_id>:\\n\"\n\t\t\" 3 (SFF) or 8 (EFF) hex chars\\n\"\n\t\t\"{data}:\\n\"\n\t\t\" 0..8 (0..64 CAN FD) ASCII hex-values (optionally separated by '.')\\n\"\n\t\t\"{len}:\\n\"\n\t\t\" an optional 0..8 value as RTR frames can contain a valid dlc field\\n\"\n\t\t\"_{dlc}:\\n\"\n\t\t\" an optional 9..F data length code value when payload length is 8\\n\"\n\t\t\"<flags>:\\n\"\n\t\t\" a single ASCII Hex value (0 .. F) which defines canfd_frame.flags\\n\"\n\t\t\"\\n\"\n\t\t\"<vcid>:\\n\"\n\t\t\" 2 hex chars - virtual CAN network identifier (00 .. FF)\\n\"\n\t\t\"<prio>:\\n\"\n\t\t\" 3 hex chars - 11 bit priority value (000 .. 7FF)\\n\"\n\t\t\"<flags>:\\n\"\n\t\t\" 2 hex chars values (00 .. FF) which defines canxl_frame.flags\\n\"\n\t\t\"<sdt>:\\n\"\n\t\t\" 2 hex chars values (00 .. FF) which defines canxl_frame.sdt\\n\"\n\t\t\"<af>:\\n\"\n\t\t\" 8 hex chars - 32 bit acceptance field (canxl_frame.af)\\n\"\n\t\t\"<data>:\\n\"\n\t\t\" 1..2048 ASCII hex-values (optionally separated by '.')\\n\"\n\t\t\"\\n\"\n\t\t\"Examples:\\n\"\n\t\t\"  5A1#11.2233.44556677.88 / 123#DEADBEEF / 5AA# / 123##1 / 213##311223344 /\\n\"\n\t\t\"  1F334455#1122334455667788_B / 123#R / 00000123#R3 / 333#R8_E /\\n\"\n\t\t\"  45123#81:00:12345678#11223344.556677 / 00242#81:07:40000123#112233\\n\"\n\t\t\"\\n\",\n\t\tprg, prg);\n}\n\nint main(int argc, char **argv)\n{\n\tint s; /* can raw socket */\n\tint required_mtu;\n\tint mtu;\n\tint enable_canfx = 1;\n\tstruct sockaddr_can addr;\n\tstruct can_raw_vcid_options vcid_opts = {\n\t\t.flags = CAN_RAW_XL_VCID_TX_PASS,\n\t};\n\tstatic cu_t cu;\n\tstruct ifreq ifr;\n\n\t/* check command line options */\n\tif (argc != 3) {\n\t\tprint_usage(argv[0]);\n\t\treturn 1;\n\t}\n\n\t/* parse CAN frame */\n\trequired_mtu = parse_canframe(argv[2], &cu);\n\tif (!required_mtu) {\n\t\tfprintf(stderr, \"\\nWrong CAN-frame format!\\n\\n\");\n\t\tprint_usage(argv[0]);\n\t\treturn 1;\n\t}\n\n\t/* open socket */\n\tif ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstrncpy(ifr.ifr_name, argv[1], IFNAMSIZ - 1);\n\tifr.ifr_name[IFNAMSIZ - 1] = '\\0';\n\tifr.ifr_ifindex = if_nametoindex(ifr.ifr_name);\n\tif (!ifr.ifr_ifindex) {\n\t\tperror(\"if_nametoindex\");\n\t\treturn 1;\n\t}\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = ifr.ifr_ifindex;\n\n\tif (required_mtu > (int)CAN_MTU) {\n\t\t/* check if the frame fits into the CAN netdevice */\n\t\tif (ioctl(s, SIOCGIFMTU, &ifr) < 0) {\n\t\t\tperror(\"SIOCGIFMTU\");\n\t\t\treturn 1;\n\t\t}\n\t\tmtu = ifr.ifr_mtu;\n\n\t\tif (mtu == (int)CANFD_MTU) {\n\t\t\t/* interface is ok - try to switch the socket into CAN FD mode */\n\t\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,\n\t\t\t\t       &enable_canfx, sizeof(enable_canfx))){\n\t\t\t\tprintf(\"error when enabling CAN FD support\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (mtu >= (int)CANXL_MIN_MTU) {\n\t\t\t/* interface is ok - try to switch the socket into CAN XL mode */\n\t\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_XL_FRAMES,\n\t\t\t\t       &enable_canfx, sizeof(enable_canfx))){\n\t\t\t\tprintf(\"error when enabling CAN XL support\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t/* try to enable the CAN XL VCID pass through mode */\n\t\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_XL_VCID_OPTS,\n\t\t\t\t       &vcid_opts, sizeof(vcid_opts))) {\n\t\t\t\tprintf(\"error when enabling CAN XL VCID pass through\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ensure discrete CAN FD length values 0..8, 12, 16, 20, 24, 32, 64 */\n\tif (required_mtu == CANFD_MTU)\n\t\tcu.fd.len = can_fd_dlc2len(can_fd_len2dlc(cu.fd.len));\n\n\t/* CAN XL frames need real frame length for sending */\n\tif (required_mtu == CANXL_MTU)\n\t\trequired_mtu = CANXL_HDR_SIZE + cu.xl.len;\n\n\t/*\n\t * disable default receive filter on this RAW socket This is\n\t * obsolete as we do not read from the socket at all, but for\n\t * this reason we can remove the receive list in the Kernel to\n\t * save a little (really a very little!) CPU usage.\n\t */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\treturn 1;\n\t}\n\n\t/* send frame */\n\tif (write(s, &cu, required_mtu) != required_mtu) {\n\t\tperror(\"write\");\n\t\treturn 1;\n\t}\n\n\tclose(s);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "cansequence.c",
          "type": "blob",
          "size": 10.173828125,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n// Copyright (c) 2007, 2008, 2009, 2010, 2014, 2015, 2019, 2023 Pengutronix,\n//\t\t Marc Kleine-Budde <kernel@pengutronix.de>\n// Copyright (c) 2005 Pengutronix,\n//\t\t Sascha Hauer <kernel@pengutronix.de>\n\n#include <errno.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <limits.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <net/if.h>\n\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n\n#define CAN_ID_DEFAULT (2)\n#define ANYDEV \"any\" /* name of interface to receive from any CAN interface */\n\nextern int optind, opterr, optopt;\n\nstatic int s = -1;\nstatic bool running = true;\nstatic volatile sig_atomic_t signal_num;\nstatic bool infinite = true;\nstatic bool canfd = false;\nstatic bool canfd_strict = false;\nstatic unsigned int drop_until_quit;\nstatic unsigned int drop_count;\nstatic bool use_poll = false;\n\nstatic unsigned int loopcount = 1;\nstatic int verbose;\n\nstatic struct canfd_frame frame = {\n\t.len = 1,\n};\nstatic struct can_filter filter[] = {\n\t{\n\t\t.can_id = CAN_ID_DEFAULT,\n\t},\n};\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr,\n\t\t\"Usage: %s [<can-interface>] [Options]\\n\"\n\t\t\"\\n\"\n\t\t\"cansequence sends CAN messages with a rising sequence number as payload.\\n\"\n\t\t\"When the -r option is given, cansequence expects to receive these messages\\n\"\n\t\t\"and prints an error message if a wrong sequence number is encountered.\\n\"\n\t\t\"The main purpose of this program is to test the reliability of CAN links.\\n\"\n\t\t\"\\n\"\n\t\t\"Options:\\n\"\n\t\t\" -e, --extended       send/receive extended frames\\n\"\n\t\t\" -f, --canfd          send/receive CAN-FD CAN frames\\n\"\n\t\t\" -s, --strict         refuse classical CAN frames in CAN-FD mode\\n\"\n\t\t\" -b, --brs            send CAN-FD CAN frames with bitrate switch (BRS)\\n\"\n\t\t\" -i, --identifier=ID  CAN Identifier (default = %u)\\n\"\n\t\t\"     --loop=COUNT     send message COUNT times\\n\"\n\t\t\" -p, --poll           use poll(2) to wait for buffer space while sending\\n\"\n\t\t\" -q, --quit <num>     quit if <num> wrong sequences are encountered\\n\"\n\t\t\" -r, --receive        work as receiver\\n\"\n\t\t\" -v, --verbose        be verbose (twice to be even more verbose\\n\"\n\t\t\" -h, --help           this help\\n\",\n\t\tprg, CAN_ID_DEFAULT);\n}\n\nstatic void sig_handler(int signo)\n{\n\trunning = false;\n\tsignal_num = signo;\n}\n\nstatic void do_receive()\n{\n\tuint8_t ctrlmsg[CMSG_SPACE(sizeof(struct timeval)) + CMSG_SPACE(sizeof(__u32))];\n\tstruct iovec iov = {\n\t\t.iov_base = &frame,\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t\t.msg_control = &ctrlmsg,\n\t};\n\tconst int dropmonitor_on = 1;\n\tbool sequence_init = true;\n\tunsigned int sequence_wrap = 0;\n\tuint32_t sequence_mask = 0xff;\n\tuint32_t sequence_rx = 0;\n\tuint8_t sequence_delta = 0;\n\tuint32_t sequence = 0;\n\tunsigned int overflow_old = 0;\n\tcan_err_mask_t err_mask = CAN_ERR_MASK;\n\tsize_t mtu;\n\n\tif (canfd)\n\t\tmtu = CANFD_MTU;\n\telse\n\t\tmtu = CAN_MTU;\n\n\tif (setsockopt(s, SOL_SOCKET, SO_RXQ_OVFL,\n\t\t       &dropmonitor_on, sizeof(dropmonitor_on)) < 0) {\n\t\tperror(\"setsockopt() SO_RXQ_OVFL not supported by your Linux Kernel\");\n\t}\n\n\t/* enable recv. of error messages */\n\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_ERR_FILTER, &err_mask, sizeof(err_mask))) {\n\t\tperror(\"setsockopt()\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* enable recv. now */\n\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, filter, sizeof(filter))) {\n\t\tperror(\"setsockopt()\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\twhile ((infinite || loopcount--) && running) {\n\t\tssize_t nbytes;\n\n\t\tmsg.msg_iov[0].iov_len = mtu;\n\t\tmsg.msg_controllen = sizeof(ctrlmsg);\n\t\tmsg.msg_flags = 0;\n\n\t\tnbytes = recvmsg(s, &msg, 0);\n\t\tif (nbytes < 0) {\n\t\t\tperror(\"recvmsg()\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (frame.can_id & CAN_ERR_FLAG) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"sequence CNT: %6u, ERRORFRAME %7x   %02x %02x %02x %02x %02x %02x %02x %02x\\n\",\n\t\t\t\tsequence, frame.can_id,\n\t\t\t\tframe.data[0], frame.data[1], frame.data[2], frame.data[3],\n\t\t\t\tframe.data[4], frame.data[5], frame.data[6], frame.data[7]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsequence_rx = frame.data[0];\n\n\t\tif (canfd_strict && nbytes == CAN_MTU) {\n\t\t\tif (verbose > 1)\n\t\t\t\tprintf(\"sequence CNT: 0x%07x  RX: 0x%02x (ignoring classical CAN frame)\\n\", sequence, sequence_rx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sequence_init) {\n\t\t\tsequence_init = false;\n\t\t\tsequence = sequence_rx;\n\t\t}\n\n\t\tsequence_delta = sequence_rx - (uint8_t)sequence;\n\t\tif (sequence_delta) {\n\t\t\tstruct cmsghdr *cmsg;\n\t\t\tuint32_t overflow = 0;\n\t\t\tuint32_t overflow_delta;\n\n\t\t\tdrop_count++;\n\n\t\t\tfor (cmsg = CMSG_FIRSTHDR(&msg);\n\t\t\t     cmsg && (cmsg->cmsg_level == SOL_SOCKET);\n\t\t\t     cmsg = CMSG_NXTHDR(&msg,cmsg)) {\n\t\t\t\tif (cmsg->cmsg_type == SO_RXQ_OVFL) {\n\t\t\t\t\tmemcpy(&overflow, CMSG_DATA(cmsg), sizeof(overflow));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toverflow_delta = overflow - overflow_old;\n\n\t\t\tfprintf(stderr,\n\t\t\t\t\"sequence CNT: 0x%07x  RX: 0x%02x  expected: 0x%02x  missing: %4u   skt overflow delta: %4u  absolute: %4u   hw - skt: %5d   incident: %4u %s%s\\n\",\n\t\t\t\tsequence, sequence_rx,\t\t\t\t/* CNT, RX */\n\t\t\t\tsequence & sequence_mask, sequence_delta,\t/* expected, missing */\n\t\t\t\toverflow_delta, overflow,\t\t\t/* skb overflow delta, absolute */\n\t\t\t\tsequence_delta - overflow_delta,\t\t/* hw - skb */\n\t\t\t\tdrop_count,\t\t\t\t\t/* incident */\n\t\t\t\toverflow_delta ? \"[SOCKET]\" : \"\",\n\t\t\t\toverflow_delta != sequence_delta ?\n\t\t\t\t((overflow_delta - sequence_delta > 0 && (overflow_delta - sequence_delta) & 0xff) ?\n\t\t\t\t \"[HARDWARE]\" : \"[HARDWARE?]\") : \"\");\n\n\t\t\tif (drop_count == drop_until_quit)\n\t\t\t\texit(EXIT_FAILURE);\n\n\t\t\tsequence = sequence_rx;\n\t\t\toverflow_old = overflow;\n\t\t} else if (verbose > 1) {\n\t\t\tprintf(\"sequence CNT: 0x%07x  RX: 0x%02x\\n\", sequence, sequence_rx);\n\t\t}\n\n\t\tsequence++;\n\t\tif (verbose && !(sequence & sequence_mask))\n\t\t\tprintf(\"sequence wrap around (%d)\\n\", sequence_wrap++);\n\t}\n}\n\nstatic void do_send()\n{\n\tunsigned int seq_wrap = 0;\n\tuint8_t sequence = 0;\n\tsize_t mtu;\n\n\tif (canfd)\n\t\tmtu = CANFD_MTU;\n\telse\n\t\tmtu = CAN_MTU;\n\n\twhile ((infinite || loopcount--) && running) {\n\t\tssize_t len;\n\n\t\tif (verbose > 1)\n\t\t\tprintf(\"sending frame. sequence number: %d\\n\", sequence);\n\nagain:\n\t\tlen = write(s, &frame, mtu);\n\t\tif (len == -1) {\n\t\t\tswitch (errno) {\n\t\t\tcase ENOBUFS: {\n\t\t\t\tint err;\n\t\t\t\tstruct pollfd fds[] = {\n\t\t\t\t\t{\n\t\t\t\t\t\t.fd = s,\n\t\t\t\t\t\t.events = POLLOUT,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tif (!use_poll) {\n\t\t\t\t\tperror(\"write\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\t\terr = poll(fds, 1, 1000);\n\t\t\t\tif (err == 0 || (err == -1 && errno != EINTR)) {\n\t\t\t\t\tperror(\"poll()\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase EINTR: /* fallthrough */\n\t\t\t\tgoto again;\n\t\t\tdefault:\n\t\t\t\tperror(\"write\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\n\t\tframe.data[0]++;\n\t\tsequence++;\n\n\t\tif (verbose && !sequence)\n\t\t\tprintf(\"sequence wrap around (%d)\\n\", seq_wrap++);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tstruct sigaction act = {\n\t\t.sa_handler = sig_handler,\n\t};\n\tstruct sockaddr_can addr = {\n\t\t.can_family = AF_CAN,\n\t};\n\tchar *interface = \"can0\";\n\tbool extended = false;\n\tbool brs = false;\n\tbool receive = false;\n\tint opt;\n\n\tsigaction(SIGINT, &act, NULL);\n\tsigaction(SIGTERM, &act, NULL);\n\tsigaction(SIGHUP, &act, NULL);\n\n\tstruct option long_options[] = {\n\t\t{ \"extended\", no_argument, 0, 'e' },\n\t\t{ \"canfd\", no_argument, 0, 'f' },\n\t\t{ \"strict\", no_argument, 0, 's' },\n\t\t{ \"brs\", no_argument, 0, 'b' },\n\t\t{ \"identifier\", required_argument, 0, 'i' },\n\t\t{ \"loop\", required_argument, 0, 'l' },\n\t\t{ \"poll\", no_argument, 0, 'p' },\n\t\t{ \"quit\", optional_argument, 0, 'q' },\n\t\t{ \"receive\", no_argument, 0, 'r' },\n\t\t{ \"verbose\", no_argument, 0, 'v' },\n\t\t{ \"help\", no_argument, 0, 'h' },\n\t\t{ 0, 0, 0, 0 },\n\t};\n\n\twhile ((opt = getopt_long(argc, argv, \"efsbi:pq::rvh?\", long_options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'e':\n\t\t\textended = true;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tcanfd = true;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tcanfd_strict = true;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tbrs = true; /* bitrate switch implies CAN-FD */\n\t\t\tcanfd = true;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tfilter->can_id = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\treceive = true;\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tif (optarg) {\n\t\t\t\tloopcount = strtoul(optarg, NULL, 0);\n\t\t\t\tinfinite = false;\n\t\t\t} else {\n\t\t\t\tinfinite = true;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tuse_poll = true;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\tif (optarg)\n\t\t\t\tdrop_until_quit = strtoul(optarg, NULL, 0);\n\t\t\telse\n\t\t\t\tdrop_until_quit = 1;\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (argv[optind] != NULL)\n\t\tinterface = argv[optind];\n\n\tif (extended) {\n\t\tfilter->can_mask = CAN_EFF_MASK;\n\t\tfilter->can_id &= CAN_EFF_MASK;\n\t\tfilter->can_id |= CAN_EFF_FLAG;\n\t} else {\n\t\tfilter->can_mask = CAN_SFF_MASK;\n\t\tfilter->can_id &= CAN_SFF_MASK;\n\t}\n\tframe.can_id = filter->can_id;\n\tfilter->can_mask |= CAN_EFF_FLAG;\n\n\tprintf(\"interface = %s\\n\", interface);\n\n\ts = socket(AF_CAN, SOCK_RAW, CAN_RAW);\n\tif (s < 0) {\n\t\tperror(\"socket()\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (strcmp(ANYDEV, interface)) {\n\t\taddr.can_ifindex = if_nametoindex(interface);\n\t\tif (!addr.can_ifindex) {\n\t\t\tperror(\"if_nametoindex()\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t/* first don't recv. any msgs */\n\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0)) {\n\t\tperror(\"setsockopt()\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (canfd) {\n\t\tconst int enable_canfd = 1;\n\t\tstruct ifreq ifr;\n\n\t\tstrncpy(ifr.ifr_name, interface, sizeof(ifr.ifr_name));\n\n\t\t/* check if the frame fits into the CAN netdevice */\n\t\tif (ioctl(s, SIOCGIFMTU, &ifr) < 0) {\n\t\t\tperror(\"SIOCGIFMTU\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (ifr.ifr_mtu != CANFD_MTU && ifr.ifr_mtu != CANXL_MTU) {\n\t\t\tprintf(\"CAN interface is only Classical CAN capable - sorry.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t/* interface is ok - try to switch the socket into CAN FD mode */\n\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &enable_canfd, sizeof(enable_canfd))) {\n\t\t\tprintf(\"error when enabling CAN FD support\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\tcanfd_strict = false;\n\t}\n\n\tif (brs)\n\t\tframe.flags |= CANFD_BRS;\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind()\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (receive)\n\t\tdo_receive();\n\telse\n\t\tdo_send();\n\n\tif (signal_num)\n\t\treturn 128 + signal_num;\n\n\texit(EXIT_SUCCESS);\n}\n"
        },
        {
          "name": "cansniffer.c",
          "type": "blob",
          "size": 23.765625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * cansniffer.c - volatile CAN content visualizer\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <linux/sockios.h>\n\n#include \"terminal.h\"\n\n#define SETFNAME \"sniffset.\"\n#define SETFDFNAME \"sniffset_fd.\"\n#define FNAME_MAX_LEN 40\n\n#define ANYDEV   \"any\"\n#define MAX_SLOTS 2048\n\n#define CANFD_OFF  0 /* set to OFF */\n#define CANFD_ON   1 /* set to ON */\n#define CANFD_AUTO 2 /* unspecified => check for first received frame */\n\n/* flags */\n\n#define ENABLE  1 /* by filter or user */\n#define DISPLAY 2 /* is on the screen */\n#define UPDATE  4 /* needs to be printed on the screen */\n#define CLRSCR  8 /* clear screen in next loop */\n\n/* flags testing & setting */\n\n#define is_set(id, flag) (sniftab[id].flags & flag)\n#define is_clr(id, flag) (!(sniftab[id].flags & flag))\n\n#define do_set(id, flag) (sniftab[id].flags |= flag)\n#define do_clr(id, flag) (sniftab[id].flags &= ~flag)\n\n/* time defaults */\n\n#define TIMEOUT 500 /* in 10ms */\n#define HOLD    100 /* in 10ms */\n#define LOOP     20 /* in 10ms */\n\n#define ATTCOLOR ATTBOLD FGRED\n\n#define LDL \" | \"\t/* long delimiter */\n#define SDL \"|\"\t\t/* short delimiter for binary on 80 chars terminal */\n\n#define CC_SEP '#' /* interface name separator for Classical CAN */\n#define FD_SEP '*' /* interface name separator for CAN FD */\n\nstatic struct snif {\n\tint flags;\n\tlong hold;\n\tlong timeout;\n\tstruct timeval laststamp;\n\tstruct timeval currstamp;\n\tstruct canfd_frame last;\n\tstruct canfd_frame current;\n\tstruct canfd_frame marker;\n\tstruct canfd_frame notch;\n} sniftab[MAX_SLOTS];\n\nextern int optind, opterr, optopt;\n\nstatic int idx;\nstatic int running = 1;\nstatic volatile sig_atomic_t signal_num;\nstatic int clearscreen = 1;\nstatic int print_eff;\nstatic int print_ascii = 1;\nstatic int notch;\nstatic int max_dlen = CAN_MAX_DLEN;\nstatic long timeout = TIMEOUT;\nstatic long hold = HOLD;\nstatic long loop = LOOP;\nstatic long canfd_mode = CANFD_AUTO;\nstatic unsigned char binary;\nstatic unsigned char binary8;\nstatic unsigned char binary_gap;\nstatic unsigned char color;\nstatic unsigned char name_sep = CC_SEP;\nstatic char *interface;\nstatic char *vdl = LDL; /* variable delimiter */\nstatic char *ldl = LDL; /* long delimiter */\n\nvoid print_snifline(int slot);\nint handle_keyb(void);\nint handle_frame(int fd, long currcms);\nint handle_timeo(long currcms);\nint writesettings(char* name);\nint readsettings(char* name);\nint sniftab_index(canid_t id);\n\nvoid switchvdl(char *delim)\n{\n\t/* reduce delimiter size for EFF IDs in binary display of up\n\t   to 8 data bytes payload to fit into 80 chars per line */\n\tif (binary8)\n\t\tvdl = delim;\n}\n\nint comp(const void *elem1, const void *elem2)\n{\n    unsigned long f = ((struct snif*)elem1)->current.can_id;\n    unsigned long s = ((struct snif*)elem2)->current.can_id;\n\n    if (f > s)\n\t    return  1;\n    if (f < s)\n\t    return -1;\n\n    return 0;\n}\n\nvoid print_usage(char *prg)\n{\n\tconst char manual [] = {\n\t\t\"commands that can be entered at runtime:\\n\"\n\t\t\" q<ENTER>        - quit\\n\"\n\t\t\" b<ENTER>        - toggle binary / HEX-ASCII output\\n\"\n\t\t\" 8<ENTER>        - toggle binary / HEX-ASCII output (small for EFF on 80 chars)\\n\"\n\t\t\" B<ENTER>        - toggle binary with gap / HEX-ASCII output (exceeds 80 chars!)\\n\"\n\t\t\" c<ENTER>        - toggle color mode\\n\"\n\t\t\" @<ENTER>        - toggle ASCII output (disabled for CAN FD by default)\\n\"\n\t\t\" <SPACE><ENTER>  - force a clear screen\\n\"\n\t\t\" #<ENTER>        - notch currently marked/changed bits (can be used repeatedly)\\n\"\n\t\t\" *<ENTER>        - clear notched marked\\n\"\n\t\t\" rMYNAME<ENTER>  - read settings file (filter/notch)\\n\"\n\t\t\" wMYNAME<ENTER>  - write settings file (filter/notch)\\n\"\n\t\t\" a<ENTER>        - enable 'a'll SFF CAN-IDs to sniff\\n\"\n\t\t\" n<ENTER>        - enable 'n'one SFF CAN-IDs to sniff\\n\"\n\t\t\" A<ENTER>        - enable 'A'll EFF CAN-IDs to sniff\\n\"\n\t\t\" N<ENTER>        - enable 'N'one EFF CAN-IDs to sniff\\n\"\n\t\t\" +FILTER<ENTER>  - add CAN-IDs to sniff\\n\"\n\t\t\" -FILTER<ENTER>  - remove CAN-IDs to sniff\\n\"\n\t\t\"\\n\"\n\t\t\"FILTER can be a single CAN-ID or a CAN-ID/Bitmask:\\n\"\n\t\t\"\\n\"\n\t\t\" single SFF 11 bit IDs:\\n\"\n\t\t\"  +1F5<ENTER>               - add SFF CAN-ID 0x1F5\\n\"\n\t\t\"  -42E<ENTER>               - remove SFF CAN-ID 0x42E\\n\"\n\t\t\"\\n\"\n\t\t\" single EFF 29 bit IDs:\\n\"\n\t\t\"  +18FEDF55<ENTER>          - add EFF CAN-ID 0x18FEDF55\\n\"\n\t\t\"  -00000090<ENTER>          - remove EFF CAN-ID 0x00000090\\n\"\n\t\t\"\\n\"\n\t\t\" CAN-ID/Bitmask SFF:\\n\"\n\t\t\"  -42E7FF<ENTER>            - remove SFF CAN-ID 0x42E (using Bitmask)\\n\"\n\t\t\"  -500700<ENTER>            - remove SFF CAN-IDs 0x500 - 0x5FF\\n\"\n\t\t\"  +400600<ENTER>            - add SFF CAN-IDs 0x400 - 0x5FF\\n\"\n\t\t\"  +000000<ENTER>            - add all SFF CAN-IDs\\n\"\n\t\t\"  -000000<ENTER>            - remove all SFF CAN-IDs\\n\"\n\t\t\"\\n\"\n\t\t\" CAN-ID/Bitmask EFF:\\n\"\n\t\t\"  -0000000000000000<ENTER>  - remove all EFF CAN-IDs\\n\"\n\t\t\"  +12345678000000FF<ENTER>  - add EFF CAN IDs xxxxxx78\\n\"\n\t\t\"  +0000000000000000<ENTER>  - add all EFF CAN-IDs\\n\"\n\t\t\"\\n\"\n\t\t\"if (id & filter) == (sniff-id & filter) the action (+/-) is performed,\\n\"\n\t\t\"which is quite easy when the filter is 000 resp. 00000000 for EFF.\\n\"\n\t\t\"\\n\"\n\t};\n\n\tfprintf(stderr, \"%s - volatile CAN content visualizer.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [can-interface]\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -q          (quiet - all IDs deactivated)\\n\");\n\tfprintf(stderr, \"         -r <name>   (read %sname from file)\\n\", SETFNAME);\n\tfprintf(stderr, \"         -e          (fix extended frame format output - no auto detect)\\n\");\n\tfprintf(stderr, \"         -b          (start with binary mode)\\n\");\n\tfprintf(stderr, \"         -8          (start with binary mode - for EFF on 80 chars)\\n\");\n\tfprintf(stderr, \"         -B          (start with binary mode with gap - exceeds 80 chars!)\\n\");\n\tfprintf(stderr, \"         -c          (color changes)\\n\");\n\tfprintf(stderr, \"         -f <mode>   (CAN FD mode: 0 = OFF, 1 = ON, 2 = auto detect, default: %d)\\n\", CANFD_AUTO);\n\tfprintf(stderr, \"         -t <time>   (timeout for ID display [x10ms] default: %d, 0 = OFF)\\n\", TIMEOUT);\n\tfprintf(stderr, \"         -h <time>   (hold marker on changes [x10ms] default: %d)\\n\", HOLD);\n\tfprintf(stderr, \"         -l <time>   (loop time (display) [x10ms] default: %d)\\n\", LOOP);\n\tfprintf(stderr, \"         -?          (print this help text)\\n\");\n\tfprintf(stderr, \"Use interface name '%s' to receive from all can-interfaces.\\n\", ANYDEV);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"%s\", manual);\n}\n\nvoid sigterm(int signo)\n{\n\trunning = 0;\n\tsignal_num = signo;\n}\n\nint main(int argc, char **argv)\n{\n\tfd_set rdfs;\n\tint s;\n\tlong currcms = 0;\n\tlong lastcms = 0;\n\tunsigned char quiet = 0;\n\tint opt, ret = 0;\n\tstruct timeval timeo, start_tv, tv;\n\tstruct sockaddr_can addr;\n\tint i;\n\n\tsignal(SIGTERM, sigterm);\n\tsignal(SIGHUP, sigterm);\n\tsignal(SIGINT, sigterm);\n\n\tfor (i = 0; i < MAX_SLOTS ;i++) /* default: enable all slots */\n\t\tdo_set(i, ENABLE);\n\n\twhile ((opt = getopt(argc, argv, \"r:t:h:l:f:qeb8Bc?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'r':\n\t\t\tif (readsettings(optarg) < 0) {\n\t\t\t\tfprintf(stderr, \"Unable to read setting file '%s%s'!\\n\", SETFNAME, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tsscanf(optarg, \"%ld\", &timeout);\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tsscanf(optarg, \"%ld\", &hold);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tsscanf(optarg, \"%ld\", &loop);\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tsscanf(optarg, \"%ld\", &canfd_mode);\n\t\t\tif ((canfd_mode != CANFD_ON) && (canfd_mode != CANFD_OFF))\n\t\t\t\tcanfd_mode = CANFD_AUTO;\n\t\t\tbreak;\n\n\t\tcase 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tprint_eff = 1;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tbinary = 1;\n\t\t\tbinary_gap = 0;\n\t\t\tbreak;\n\n\t\tcase '8':\n\t\t\tbinary = 1;\n\t\t\tbinary8 = 1; /* enable variable delimiter for EFF */\n\t\t\tswitchvdl(SDL); /* switch directly to short delimiter */\n\t\t\tbinary_gap = 0;\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\tbinary = 1;\n\t\t\tbinary_gap = 1;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tcolor = 1;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (optind == argc) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(0);\n\t}\n\n\tif (quiet)\n\t\tfor (i = 0; i < MAX_SLOTS; i++)\n\t\t\tdo_clr(i, ENABLE);\n\n\tif (strlen(argv[optind]) >= IFNAMSIZ) {\n\t\tprintf(\"name of CAN device '%s' is too long!\\n\", argv[optind]);\n\t\treturn 1;\n\t}\n\n\tinterface = argv[optind];\n\n\ts = socket(PF_CAN, SOCK_RAW, CAN_RAW);\n\tif (s < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = 0; /* 'any' CAN interface */\n\n\t/* check for specific CAN interface */\n\tif (strcmp(ANYDEV, argv[optind]) != 0) {\n\t\taddr.can_ifindex = if_nametoindex(argv[optind]);\n\t\tif (!addr.can_ifindex) {\n\t\t\tperror(\"if_nametoindex\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* enable CAN FD if not disabled by command line option */\n\tif (canfd_mode != CANFD_OFF) {\n\t\tconst int enable_canfd = 1;\n\n\t\tif (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,\n\t\t\t       &enable_canfd, sizeof(enable_canfd))){\n\t\t\tprintf(\"error when enabling CAN FD support\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* might be changed in CANFD_AUTO mode */\n\t\tmax_dlen = CANFD_MAX_DLEN;\n\t\tname_sep = FD_SEP;\n\t\tprint_ascii = 0; /* don't print ASCII for CAN FD by default */\n\t}\n\n\tret = bind(s, (struct sockaddr *)&addr, sizeof(addr));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(s);\n\t\treturn ret;\n\t}\n\n\tgettimeofday(&start_tv, NULL);\n\ttv.tv_sec = tv.tv_usec = 0;\n\n\tprintf(\"%s\", CSR_HIDE); /* hide cursor */\n\n\twhile (running) {\n\n\t\tFD_ZERO(&rdfs);\n\t\tFD_SET(0, &rdfs);\n\t\tFD_SET(s, &rdfs);\n\n\t\ttimeo.tv_sec  = 0;\n\t\ttimeo.tv_usec = 10000 * loop;\n\n\t\tret = select(s+1, &rdfs, NULL, NULL, &timeo);\n\t\tif (ret < 0) {\n\t\t\t//perror(\"select\");\n\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t} else\n\t\t\tret = 0;\n\n\t\tgettimeofday(&tv, NULL);\n\t\tcurrcms = (tv.tv_sec - start_tv.tv_sec) * 100 + (tv.tv_usec / 10000);\n\n\t\tif (FD_ISSET(0, &rdfs))\n\t\t\trunning &= handle_keyb();\n\n\t\tif (FD_ISSET(s, &rdfs))\n\t\t\trunning &= handle_frame(s, currcms);\n\n\t\tif (currcms - lastcms >= loop) {\n\t\t\trunning &= handle_timeo(currcms);\n\t\t\tlastcms = currcms;\n\t\t}\n\t}\n\n\tprintf(\"%s\", CSR_SHOW); /* show cursor */\n\n\tclose(s);\n\n\tif (signal_num)\n\t\treturn 128 + signal_num;\n\n\treturn ret;\n}\n\nvoid do_modify_sniftab(unsigned int value, unsigned int mask, char cmd)\n{\n\tint i;\n\n\tfor (i = 0; i < idx ;i++) {\n\t\tif ((sniftab[i].current.can_id & mask) == (value & mask)) {\n\t\t\tif (cmd == '+')\n\t\t\t\tdo_set(i, ENABLE);\n\t\t\telse\n\t\t\t\tdo_clr(i, ENABLE);\n\t\t}\n\t}\n}\n\nint handle_keyb(void)\n{\n\tchar cmd [25] = {0};\n\tint i, clen;\n\tunsigned int mask;\n\tunsigned int value;\n\n\tif (read(0, cmd, 24) > (long)strlen(\"+1234567812345678\\n\"))\n\t\treturn 1; /* ignore */\n\n\tif (strlen(cmd) > 0)\n\t\tcmd[strlen(cmd)-1] = 0; /* chop off trailing newline */\n\n\tclen = strlen(&cmd[1]); /* content length behind command */\n\n\tswitch (cmd[0]) {\n\n\tcase '+':\n\tcase '-':\n\t\tif (clen == 6) {\n\t\t\t/* masking strict SFF ID content vvvmmm */\n\t\t\tsscanf(&cmd[1], \"%x\", &value);\n\t\t\tmask = value | 0xFFFF800; /* cleared flags! */\n\t\t\tvalue >>= 12;\n\t\t\tvalue &= 0x7FF;\n\t\t\tdo_modify_sniftab(value, mask, cmd[0]);\n\t\t\tbreak;\n\t\t} else if (clen == 16) {\n\t\t\tsscanf(&cmd[9], \"%x\", &mask);\n\t\t\tcmd[9] = 0; /* terminate 'value' */\n\t\t\tsscanf(&cmd[1], \"%x\", &value);\n\t\t\tmask |= CAN_EFF_FLAG;\n\t\t\tvalue |= CAN_EFF_FLAG;\n\t\t\tdo_modify_sniftab(value, mask, cmd[0]);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check for single SFF/EFF CAN ID length */\n\t\tif (clen != 3 && clen != 8)\n\t\t\tbreak;\n\n\t\t/* enable/disable single SFF/EFF CAN ID */\n\t\tsscanf(&cmd[1], \"%x\", &value);\n\t\tif (clen == 8)\n\t\t\tvalue |= CAN_EFF_FLAG;\n\n\t\ti = sniftab_index(value);\n\t\tif (i < 0)\n\t\t\tbreak; /* No Match */\n\n\t\tif (cmd[0] == '+')\n\t\t\tdo_set(i, ENABLE);\n\t\telse\n\t\t\tdo_clr(i, ENABLE);\n\n\t\tbreak;\n\n\tcase 'a' : /* all SFF CAN IDs */\n\t\tvalue = 0;\n\t\tmask = 0xFFFF800; /* cleared flags! */\n\t\tdo_modify_sniftab(value, mask, '+');\n\t\tbreak;\n\n\tcase 'n' : /* none SFF CAN IDs */\n\t\tvalue = 0;\n\t\tmask = 0xFFFF800; /* cleared flags! */\n\t\tdo_modify_sniftab(value, mask, '-');\n\t\tbreak;\n\n\tcase 'A' : /* all EFF CAN IDs */\n\t\tvalue = CAN_EFF_FLAG;\n\t\tmask = CAN_EFF_FLAG;\n\t\tdo_modify_sniftab(value, mask, '+');\n\t\tbreak;\n\n\tcase 'N' : /* none EFF CAN IDs */\n\t\tvalue = CAN_EFF_FLAG;\n\t\tmask = CAN_EFF_FLAG;\n\t\tdo_modify_sniftab(value, mask, '-');\n\t\tbreak;\n\n\tcase 'w' :\n\t\tif (writesettings(&cmd[1]))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 'r' :\n\t\tif (readsettings(&cmd[1]) < 0)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 'q' :\n\t\trunning = 0;\n\t\tbreak;\n\n\tcase '@' :\n\t\t/* toggle ASCII output */\n\t\tprint_ascii ^= 1;\n\t\tbreak;\n\n\tcase 'B' :\n\t\tbinary_gap = 1;\n\t\tswitchvdl(LDL);\n\t\tif (binary)\n\t\t\tbinary = 0;\n\t\telse\n\t\t\tbinary = 1;\n\n\t\tbreak;\n\n\tcase '8' :\n\t\tbinary8 = 1;\n\t\t/* fallthrough */\n\n\tcase 'b' :\n\t\tbinary_gap = 0;\n\t\tif (binary) {\n\t\t\tbinary = 0;\n\t\t\tswitchvdl(LDL);\n\t\t} else {\n\t\t\tbinary = 1;\n\t\t\tswitchvdl(SDL);\n\t\t}\n\t\tbreak;\n\n\tcase 'c' :\n\t\tif (color)\n\t\t\tcolor = 0;\n\t\telse\n\t\t\tcolor = 1;\n\n\t\tbreak;\n\n\tcase ' ' :\n\t\tclearscreen = 1;\n\t\tbreak;\n\n\tcase '#' :\n\t\tnotch = 1;\n\t\tbreak;\n\n\tcase '*' :\n\t\tfor (i = 0; i < idx; i++)\n\t\t\tmemset(&sniftab[i].notch.data, 0, max_dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclearscreen = 1;\n\n\treturn 1; /* ok */\n}\n\nint handle_frame(int fd, long currcms)\n{\n\tbool rx_changed = false;\n\tbool run_qsort = false;\n\tint nbytes, i, pos;\n\tstruct canfd_frame cf;\n\n\tnbytes = read(fd, &cf, sizeof(cf));\n\tif (nbytes < 0) {\n\t\tperror(\"raw read\");\n\t\treturn 0; /* quit */\n\t}\n\n\tif ((nbytes != CAN_MTU) && (nbytes != CANFD_MTU)) {\n\t\tprintf(\"received strange frame data length %d!\\n\", nbytes);\n\t\treturn 0; /* quit */\n\t}\n\n\t/* CAN FD auto mode: switch based on first reception */\n\tif (canfd_mode == CANFD_AUTO) {\n\t\tif (nbytes == CAN_MTU) {\n\t\t\tcanfd_mode = CANFD_OFF;\n\t\t\t/* change back auto defaults for Classical CAN */\n\t\t\tmax_dlen = CAN_MAX_DLEN;\n\t\t\tname_sep = CC_SEP;\n\t\t\tprint_ascii = 1;\n\t\t} else {\n\t\t\tcanfd_mode = CANFD_ON;\n\t\t}\n\t}\n\n\t/* filter for Classical CAN */\n\tif ((canfd_mode == CANFD_OFF) && (nbytes == CANFD_MTU))\n\t\treturn 1; /* skip handling */\n\n\t/* filter for CAN FD */\n\tif ((canfd_mode == CANFD_ON) && (nbytes == CAN_MTU))\n\t\treturn 1; /* skip handling */\n\n\tif (!print_eff && (cf.can_id & CAN_EFF_FLAG)) {\n\t\tprint_eff = 1;\n\t\tclearscreen = 1;\n\t}\n\n\tpos = sniftab_index(cf.can_id);\n\tif (pos < 0) {\n\t\t/* CAN ID not existing */\n\t\tif (idx >= MAX_SLOTS) {\n\t\t\t/* informative exit */\n\t\t\tperror(\"number of different CAN IDs exceeded MAX_SLOTS\");\n\t\t\treturn 0; /* quit */\n\t\t}\n\t\t/* assign new slot */\n\t\tpos = idx++;\n\t\trx_changed = true;\n\t\trun_qsort = true;\n\t}\n\telse {\n\t\tif (cf.len == sniftab[pos].current.len)\n\t\t\tfor (i = 0; i < cf.len; i++) {\n\t\t\t\tif (cf.data[i] != sniftab[pos].current.data[i] ) {\n\t\t\t\t\trx_changed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\trx_changed = true;\n\t}\n\n\t/* print received frame even if the data didn't change to get a gap time */\n\tif ((sniftab[pos].laststamp.tv_sec == 0) && (sniftab[pos].laststamp.tv_usec == 0))\n\t\trx_changed = true;\n\n\tif (rx_changed == true) {\n\t\tsniftab[pos].laststamp = sniftab[pos].currstamp;\n\t\tioctl(fd, SIOCGSTAMP, &sniftab[pos].currstamp);\n\n\t\tsniftab[pos].current = cf;\n\t\tfor (i = 0; i < max_dlen; i++)\n\t\t\tsniftab[pos].marker.data[i] |= sniftab[pos].current.data[i] ^ sniftab[pos].last.data[i];\n\n\t\tsniftab[pos].timeout = (timeout)?(currcms + timeout):0;\n\n\t\tif (is_clr(pos, DISPLAY))\n\t\t\tclearscreen = 1; /* new entry -> new drawing */\n\n\t\tdo_set(pos, DISPLAY);\n\t\tdo_set(pos, UPDATE);\n\t}\n\n\tif (run_qsort == true)\n\t\tqsort(sniftab, idx, sizeof(sniftab[0]), comp);\n\n\treturn 1; /* ok */\n}\n\nint handle_timeo(long currcms)\n{\n\tint i, j;\n\tint force_redraw = 0;\n\tstatic unsigned int frame_count;\n\n\tif (clearscreen) {\n\t\tif (print_eff)\n\t\t\tprintf(\"%s%sXX|ms%s-- ID --%sdata ...     < %s %c l=%ld h=%ld t=%ld slots=%d >\",\n\t\t\t       CLR_SCREEN, CSR_HOME, vdl, vdl, interface, name_sep, loop, hold, timeout, idx);\n\t\telse\n\t\t\tprintf(\"%s%sXX|ms%sID %sdata ...     < %s %c l=%ld h=%ld t=%ld slots=%d >\",\n\t\t\t       CLR_SCREEN, CSR_HOME, ldl, ldl, interface, name_sep, loop, hold, timeout, idx);\n\n\t\tforce_redraw = 1;\n\t\tclearscreen = 0;\n\t}\n\n\tif (notch) {\n\t\tfor (i = 0; i < idx; i++) {\n\t\t\tfor (j = 0; j < max_dlen; j++)\n\t\t\t\tsniftab[i].notch.data[j] |= sniftab[i].marker.data[j];\n\t\t}\n\t\tnotch = 0;\n\t}\n\n\tprintf(\"%s\", CSR_HOME);\n\tprintf(\"%02d\\n\", frame_count++); /* rolling display update counter */\n\tframe_count %= 100;\n\n\tfor (i = 0; i < idx; i++) {\n\t\tif is_set(i, ENABLE) {\n\t\t\t\tif is_set(i, DISPLAY) {\n\t\t\t\t\t\tif (is_set(i, UPDATE) || (force_redraw)) {\n\t\t\t\t\t\t\tprint_snifline(i);\n\t\t\t\t\t\t\tsniftab[i].hold = currcms + hold;\n\t\t\t\t\t\t\tdo_clr(i, UPDATE);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse  if ((sniftab[i].hold) && (sniftab[i].hold < currcms)) {\n\t\t\t\t\t\t\t\tmemset(&sniftab[i].marker.data, 0, max_dlen);\n\t\t\t\t\t\t\t\tprint_snifline(i);\n\t\t\t\t\t\t\t\tsniftab[i].hold = 0; /* disable update by hold */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"%s\", CSR_DOWN); /* skip my line */\n\n\t\t\t\t\t\tif (sniftab[i].timeout && sniftab[i].timeout < currcms) {\n\t\t\t\t\t\t\tdo_clr(i, DISPLAY);\n\t\t\t\t\t\t\tdo_clr(i, UPDATE);\n\t\t\t\t\t\t\tclearscreen = 1; /* removed entry -> new drawing next time */\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tsniftab[i].last      = sniftab[i].current;\n\t\t\t}\n\t}\n\n\treturn 1; /* ok */\n}\n\nvoid print_snifline(int slot)\n{\n\tlong diffsec  = sniftab[slot].currstamp.tv_sec  - sniftab[slot].laststamp.tv_sec;\n\tlong diffusec = sniftab[slot].currstamp.tv_usec - sniftab[slot].laststamp.tv_usec;\n\tint dlc_diff  = sniftab[slot].last.len - sniftab[slot].current.len;\n\tcanid_t cid = sniftab[slot].current.can_id;\n\tint i,j;\n\n\tif (diffusec < 0)\n\t\tdiffsec--, diffusec += 1000000;\n\n\tif (diffsec < 0)\n\t\tdiffsec = diffusec = 0;\n\n\tif (diffsec >= 100)\n\t\tdiffsec = 99, diffusec = 999999;\n\n\tif (cid & CAN_EFF_FLAG)\n\t\tprintf(\"%02ld%03ld%s%08X%s\", diffsec, diffusec/1000, vdl, cid & CAN_EFF_MASK, vdl);\n\telse if (print_eff)\n\t\tprintf(\"%02ld%03ld%s---- %03X%s\", diffsec, diffusec/1000, vdl, cid & CAN_SFF_MASK, vdl);\n\telse\n\t\tprintf(\"%02ld%03ld%s%03X%s\", diffsec, diffusec/1000, ldl, cid & CAN_SFF_MASK, ldl);\n\n\tif (binary) {\n\t\tfor (i = 0; i < sniftab[slot].current.len; i++) {\n\t\t\tfor (j=7; j >= 0; j--) {\n\t\t\t\tif ((color) && (sniftab[slot].marker.data[i] & 1<<j) &&\n\t\t\t\t    (!(sniftab[slot].notch.data[i] & 1<<j)))\n\t\t\t\t\tif (sniftab[slot].current.data[i] & 1<<j)\n\t\t\t\t\t\tprintf(\"%s1%s\", ATTCOLOR, ATTRESET);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"%s0%s\", ATTCOLOR, ATTRESET);\n\t\t\t\telse\n\t\t\t\t\tif (sniftab[slot].current.data[i] & 1<<j)\n\t\t\t\t\t\tputchar('1');\n\t\t\t\t\telse\n\t\t\t\t\t\tputchar('0');\n\t\t\t}\n\t\t\tif (binary_gap)\n\t\t\t\tputchar(' ');\n\t\t}\n\n\t\t/*\n\t\t * when the len decreased (dlc_diff > 0),\n\t\t * we need to blank the former data printout\n\t\t */\n\t\tfor (i = 0; i < dlc_diff; i++) {\n\t\t\tprintf(\"        \");\n\t\t\tif (binary_gap)\n\t\t\t\tputchar(' ');\n\t\t}\n\n\t} else { /* not binary -> hex data and ASCII output */\n\n\t\tfor (i = 0; i < sniftab[slot].current.len; i++)\n\t\t\tif ((color) && (sniftab[slot].marker.data[i] & ~sniftab[slot].notch.data[i]))\n\t\t\t\tprintf(\"%s%02X%s \", ATTCOLOR, sniftab[slot].current.data[i], ATTRESET);\n\t\t\telse\n\t\t\t\tprintf(\"%02X \", sniftab[slot].current.data[i]);\n\n\t\tif (print_ascii) {\n\t\t\t/* jump to common start for ASCII output */\n\t\t\tif (sniftab[slot].current.len < max_dlen)\n\t\t\t\tprintf(\"%*s\", (max_dlen - sniftab[slot].current.len) * 3, \"\");\n\n\t\t\tfor (i = 0; i < sniftab[slot].current.len; i++)\n\t\t\t\tif ((sniftab[slot].current.data[i] > 0x1F) &&\n\t\t\t\t    (sniftab[slot].current.data[i] < 0x7F))\n\t\t\t\t\tif ((color) && (sniftab[slot].marker.data[i] & ~sniftab[slot].notch.data[i]))\n\t\t\t\t\t\tprintf(\"%s%c%s\", ATTCOLOR, sniftab[slot].current.data[i], ATTRESET);\n\t\t\t\t\telse\n\t\t\t\t\t\tputchar(sniftab[slot].current.data[i]);\n\t\t\t\telse\n\t\t\t\t\tputchar('.');\n\n\t\t\t/*\n\t\t\t * when the len decreased (dlc_diff > 0),\n\t\t\t * we need to blank the former data printout\n\t\t\t */\n\t\t\tfor (i = 0; i < dlc_diff; i++)\n\t\t\t\tputchar(' ');\n\t\t} else {\n\t\t\t/*\n\t\t\t * when the len decreased (dlc_diff > 0),\n\t\t\t * we need to blank the former data printout\n\t\t\t */\n\t\t\tfor (i = 0; i < dlc_diff; i++)\n\t\t\t\tprintf(\"   \");\n\t\t}\n\t}\n\n\tputchar('\\n');\n\n\tmemset(&sniftab[slot].marker.data, 0, max_dlen);\n}\n\nint writesettings(char* name)\n{\n\tint fd;\n\tchar fname[FNAME_MAX_LEN + 1];\n\tint i,j;\n\tchar buf[13]= {0};\n\n\tif (canfd_mode == CANFD_OFF)\n\t\tstrcpy(fname, SETFNAME);\n\telse if (canfd_mode == CANFD_ON)\n\t\tstrcpy(fname, SETFDFNAME);\n\telse {\n\t\tprintf(\"writesettings failed due to unspecified CAN FD mode\\n\");\n\t\treturn 1;\n\t}\n\n\tstrncat(fname, name, FNAME_MAX_LEN - strlen(fname));\n\tfd = open(fname, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\tif (fd <= 0) {\n\t\tprintf(\"unable to write setting file '%s'!\\n\", fname);\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < idx ;i++) {\n\t\tsprintf(buf, \"<%08X>%c.\", sniftab[i].current.can_id, (is_set(i, ENABLE))?'1':'0');\n\t\tif (write(fd, buf, 12) < 0) {\n\t\t\tperror(\"write\");\n\t\t\treturn 1;\n\t\t}\n\t\tfor (j = 0; j < max_dlen ; j++) {\n\t\t\tsprintf(buf, \"%02X\", sniftab[i].notch.data[j]);\n\t\t\tif (write(fd, buf, 2) < 0) {\n\t\t\t\tperror(\"write\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (write(fd, \"\\n\", 1) < 0) {\n\t\t\tperror(\"write\");\n\t\t\treturn 1;\n\t\t}\n\t\t/* Classical CAN: 12 + 16  + 1 = 29  bytes per entry */\n\t\t/* CAN FD:        12 + 128 + 1 = 141 bytes per entry */\n\t}\n\tclose(fd);\n\treturn 0;\n}\n\nint readsettings(char* name)\n{\n\tint fd;\n\tchar fname[FNAME_MAX_LEN + 1];\n\tchar buf[142] = {0};\n\tint entrylen;\n\tint j;\n\tbool done = false;\n\n\tif (canfd_mode == CANFD_OFF) {\n\t\tentrylen = 29;\n\t\tstrcpy(fname, SETFNAME);\n\t} else if (canfd_mode == CANFD_ON) {\n\t\tentrylen = 141;\n\t\tstrcpy(fname, SETFDFNAME);\n\t} else {\n\t\tprintf(\"readsettings failed due to unspecified CAN FD mode\\n\");\n\t\treturn -1;\n\t}\n\n\tstrncat(fname, name, FNAME_MAX_LEN - strlen(fname));\n\tfd = open(fname, O_RDONLY);\n\n\tif (fd <= 0) {\n\t\treturn -1;\n\t}\n\tidx = 0;\n\twhile (!done) {\n\t\tif (read(fd, &buf, entrylen) != entrylen) {\n\t\t\tdone = true;\n\t\t\tcontinue;\n\t\t}\n\t\tunsigned long id = strtoul(&buf[1], NULL, 16);\n\n\t\tsniftab[idx].current.can_id = id;\n\n\t\tif (buf[10] & 1)\n\t\t\tdo_set(idx, ENABLE);\n\t\telse\n\t\t\tdo_clr(idx, ENABLE);\n\n\t\tfor (j = max_dlen - 1; j >= 0 ; j--) {\n\t\t\tsniftab[idx].notch.data[j] =\n\t\t\t\t(__u8) strtoul(&buf[2*j+12], NULL, 16) & 0xFF;\n\t\t\tbuf[2*j+12] = 0; /* cut off each time */\n\t\t}\n\n\t\tif (++idx >= MAX_SLOTS)\n\t\t\tbreak;\n\n\t}\n\tclose(fd);\n\treturn idx;\n}\n\nint sniftab_index(canid_t id)\n{\n\tint i;\n\n\tfor (i = 0; i < idx; i++)\n\t\tif (id == sniftab[i].current.can_id)\n\t\t\treturn i;\n\n\treturn -1; /* No match */\n}\n"
        },
        {
          "name": "check_cc.sh",
          "type": "blob",
          "size": 0.2763671875,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n# check_cc.sh - Helper to test userspace compilation support\n# Copyright (c) 2015 Andrew Lutomirski\n\nCC=\"$1\"\nTESTPROG=\"$2\"\nshift 2\n\nif [ -n \"$CC\" ] && $CC -o /dev/null \"$TESTPROG\" -O0 \"$@\"; then\n    echo 1\nelse\n    echo 0\nfi\n\nexit 0\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "fork_test.c",
          "type": "blob",
          "size": 0.8154296875,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (C) 2023 Dario Binacchi <dario.binacchi@amarulasolutions.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main(int argc, char **argv)\n{\n\tfork();\n\n\treturn 0;\n}\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "isobusfs",
          "type": "tree",
          "content": null
        },
        {
          "name": "isotpdump.c",
          "type": "blob",
          "size": 16.3818359375,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * isotpdump.c - dump and explain ISO15765-2 protocol CAN frames\n *\n * Copyright (c) 2008 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <linux/sockios.h>\n\n#include \"terminal.h\"\n\n#define NO_CAN_ID 0xFFFFFFFFU\n\nconst char fc_info [4][9] = { \"CTS\", \"WT\", \"OVFLW\", \"reserved\" };\nconst int canfd_on = 1;\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -b <can_id>  (broadcast can_id, Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -x <addr>    (extended addressing mode. Use 'any' for all addresses)\\n\");\n\tfprintf(stderr, \"         -X <addr>    (extended addressing mode (rx addr). Use 'any' for all)\\n\");\n\tfprintf(stderr, \"         -c           (color mode)\\n\");\n\tfprintf(stderr, \"         -a           (print data also in ASCII-chars)\\n\");\n\tfprintf(stderr, \"         -t <type>    (timestamp: (a)bsolute/(d)elta/(z)ero/(A)bsolute w date)\\n\");\n\tfprintf(stderr, \"         -u           (print uds messages)\\n\");\n\tfprintf(stderr, \"\\nCAN IDs and addresses are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"\\nUDS output contains a flag which provides information about the type of the \\n\");\n\tfprintf(stderr, \"message.\\n\\n\");\n\tfprintf(stderr, \"Flags:\\n\");\n\tfprintf(stderr, \"       [SRQ]  = Service Request\\n\");\n\tfprintf(stderr, \"       [PSR]  = Positive Service Response\\n\");\n\tfprintf(stderr, \"       [NRC]  = Negative Response Code\\n\");\n\tfprintf(stderr, \"       [???]  = Unknown (not specified)\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid print_uds_message(int service, int nrc)\n{\n\tchar *service_name;\n\tchar *flag = \"[???]\";\n\n\tif ((service >= 0x50 && service <= 0x7E) || (service >= 0xC3 && service <= 0xC8)) {\n\t\tflag = \"[PSR]\";\n\t\tservice = service - 0x40;\n\t} else if ((service >= 0x10 && service <= 0x3E) ||\n\t\t   (service >= 0x83 && service <= 0x88) ||\n\t\t   (service >= 0xBA && service <= 0xBE))\n\t\tflag = \"[SRQ]\";\n\t\n\tswitch(service) {\n\tcase 0x10: service_name = \"DiagnosticSessionControl\"; break;\n\tcase 0x11: service_name = \"ECUReset\"; break;\n\tcase 0x14: service_name = \"ClearDiagnosticInformation\"; break;\n\tcase 0x19: service_name = \"ReadDTCInformation\"; break;\n\tcase 0x22: service_name = \"ReadDataByIdentifier\"; break;\n\tcase 0x23: service_name = \"ReadMemoryByAddress\"; break;\n\tcase 0x24: service_name = \"ReadScalingDataByIdentifier\"; break;\n\tcase 0x27: service_name = \"SecurityAccess\"; break;\n\tcase 0x28: service_name = \"CommunicationControl\"; break;\n\tcase 0x2A: service_name = \"ReadDataByPeriodicIdentifier\"; break;\n\tcase 0x2C: service_name = \"DynamicallyDefineDataIdentifier\"; break;\n\tcase 0x2E: service_name = \"WriteDataByIdentifier\"; break;\n\tcase 0x2F: service_name = \"InputOutputControlByIdentifier\"; break;\n\tcase 0x31: service_name = \"RoutineControl\"; break;\n\tcase 0x34: service_name = \"RequestDownload\"; break;\n\tcase 0x35: service_name = \"RequestUpload\"; break;\n\tcase 0x36: service_name = \"TransferData\"; break;\n\tcase 0x37: service_name = \"RequestTransferExit\"; break;\n\tcase 0x38: service_name = \"RequestFileTransfer\"; break;\n\tcase 0x3D: service_name = \"WriteMemoryByAddress\"; break;\n\tcase 0x3E: service_name = \"TesterPresent\"; break;\n\tcase 0x83: service_name = \"AccessTimingParameter\"; break;\n\tcase 0x84: service_name = \"SecuredDataTransmission\"; break;\n\tcase 0x85: service_name = \"ControlDTCSetting\"; break;\n\tcase 0x86: service_name = \"ResponseOnEvent\"; break;\n\tcase 0x87: service_name = \"LinkControl\"; break;\n\tcase 0x7F: flag = \"[NRC]\";\n\t\tswitch (nrc) {\n\t\tcase 0x00: service_name = \"positiveResponse\"; break;\n\t\tcase 0x10: service_name = \"generalReject\"; break;\n\t\tcase 0x11: service_name = \"serviceNotSupported\"; break;\n\t\tcase 0x12: service_name = \"sub-functionNotSupported\"; break;\n\t\tcase 0x13: service_name = \"incorrectMessageLengthOrInvalidFormat\"; break;\n\t\tcase 0x14: service_name = \"responseTooLong\"; break;\n\t\tcase 0x21: service_name = \"busyRepeatRequest\"; break;\n\t\tcase 0x22: service_name = \"conditionsNotCorrect\"; break;\n\t\tcase 0x24: service_name = \"requestSequenceError\"; break;\n\t\tcase 0x25: service_name = \"noResponseFromSubnetComponent\"; break;\n\t\tcase 0x26: service_name = \"FailurePreventsExecutionOfRequestedAction\"; break;\n\t\tcase 0x31: service_name = \"requestOutOfRange\"; break;\n\t\tcase 0x33: service_name = \"securityAccessDenied\"; break;\n\t\tcase 0x35: service_name = \"invalidKey\"; break;\n\t\tcase 0x36: service_name = \"exceedNumberOfAttempts\"; break;\n\t\tcase 0x37: service_name = \"requiredTimeDelayNotExpired\"; break;\n\t\tcase 0x70: service_name = \"uploadDownloadNotAccepted\"; break;\n\t\tcase 0x71: service_name = \"transferDataSuspended\"; break;\n\t\tcase 0x72: service_name = \"generalProgrammingFailure\"; break;\n\t\tcase 0x73: service_name = \"wrongBlockSequenceCounter\"; break;\n\t\tcase 0x78: service_name = \"requestCorrectlyReceived-ResponsePending\"; break;\n\t\tcase 0x7E: service_name = \"sub-functionNotSupportedInActiveSession\"; break;\n\t\tcase 0x7F: service_name = \"serviceNotSupportedInActiveSession\"; break;\n\t\tcase 0x81: service_name = \"rpmTooHigh\"; break;\n\t\tcase 0x82: service_name = \"rpmTooLow\"; break;\n\t\tcase 0x83: service_name = \"engineIsRunning\"; break;\n\t\tcase 0x84: service_name = \"engineIsNotRunning\"; break;\n\t\tcase 0x85: service_name = \"engineRunTimeTooLow\"; break;\n\t\tcase 0x86: service_name = \"temperatureTooHigh\"; break;\n\t\tcase 0x87: service_name = \"temperatureTooLow\"; break;\n\t\tcase 0x88: service_name = \"vehicleSpeedTooHigh\"; break;\n\t\tcase 0x89: service_name = \"vehicleSpeedTooLow\"; break;\n\t\tcase 0x8A: service_name = \"throttle/PedalTooHigh\"; break;\n\t\tcase 0x8B: service_name = \"throttle/PedalTooLow\"; break;\n\t\tcase 0x8C: service_name = \"transmissionRangeNotInNeutral\"; break;\n\t\tcase 0x8D: service_name = \"transmissionRangeNotInGear\"; break;\n\t\tcase 0x8F: service_name = \"brakeSwitch(es)NotClosed (Brake Pedal not pressed or not applied)\"; break;\n\t\tcase 0x90: service_name = \"shifterLeverNotInPark\"; break;\n\t\tcase 0x91: service_name = \"torqueConverterClutchLocked\"; break;\n\t\tcase 0x92: service_name = \"voltageTooHigh\"; break;\n\t\tcase 0x93: service_name = \"voltageTooLow\"; break;\n\n\t\tdefault:\n\t\t\tif (nrc > 0x37 && nrc < 0x50) {\n\t\t\t\tservice_name = \"reservedByExtendedDataLinkSecurityDocument\"; break;\n\t\t\t}\n\t\t\telse if (nrc > 0x93 && nrc < 0xF0) {\n\t\t\t\tservice_name = \"reservedForSpecificConditionsNotCorrect\"; break;\n\t\t\t}\n\t\t\telse if (nrc > 0xEF && nrc < 0xFE) {\n\t\t\t\tservice_name = \"vehicleManufacturerSpecificConditionsNotCorrect\"; break;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tservice_name = \"ISOSAEReserved\"; break;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault: service_name = \"Unknown\";\n\t}\n\tprintf(\"%s %s\", flag, service_name);\n}\n\nint main(int argc, char **argv)\n{\n\tint s;\n\tstruct sockaddr_can addr;\n\tstruct can_filter rfilter[3];\n\tstruct canfd_frame frame;\n\tint nbytes, i;\n\tcanid_t src = NO_CAN_ID;\n\tcanid_t dst = NO_CAN_ID;\n\tcanid_t bst = NO_CAN_ID;\n\tint ext = 0;\n\tint extaddr = 0;\n\tint extany = 0;\n\tint rx_ext = 0;\n\tint rx_extaddr = 0;\n\tint rx_extany = 0;\n\tint asc = 0;\n\tint color = 0;\n\tint uds_output = 0;\n\tint is_ff = 0;\n\tint timestamp = 0;\n\tint datidx = 0;\n\tunsigned long fflen = 0;\n\tstruct timeval tv, last_tv;\n\tunsigned int n_pci;\n\tint opt;\n\n\tlast_tv.tv_sec  = 0;\n\tlast_tv.tv_usec = 0;\n\n\twhile ((opt = getopt(argc, argv, \"s:d:b:ax:X:ct:u?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tsrc = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tsrc |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdst = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tdst |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tbst = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tbst |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tcolor = 1;\n\t\t\tbreak;\n\n\t\tcase 'a':\n\t\t\tasc = 1;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\text = 1;\n\t\t\tif (!strncmp(optarg, \"any\", 3))\n\t\t\t\textany = 1;\n\t\t\telse\n\t\t\t\textaddr = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\trx_ext = 1;\n\t\t\tif (!strncmp(optarg, \"any\", 3))\n\t\t\t\trx_extany = 1;\n\t\t\telse\n\t\t\t\trx_extaddr = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\ttimestamp = optarg[0];\n\t\t\tif ((timestamp != 'a') && (timestamp != 'A') &&\n\t\t\t    (timestamp != 'd') && (timestamp != 'z')) {\n\t\t\t\tprintf(\"%s: unknown timestamp mode '%c' - ignored\\n\",\n\t\t\t\t       basename(argv[0]), optarg[0]);\n\t\t\t\ttimestamp = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t        uds_output = 1;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rx_ext && !ext) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(0);\n\t}\n\n\tif ((argc - optind) != 1 || src == NO_CAN_ID || dst == NO_CAN_ID) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(0);\n\t}\n\n\tif ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\t/* try to switch the socket into CAN FD mode */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));\n\n\tif (src & CAN_EFF_FLAG) {\n\t\trfilter[0].can_id   = src & (CAN_EFF_MASK | CAN_EFF_FLAG);\n\t\trfilter[0].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t} else {\n\t\trfilter[0].can_id   = src & CAN_SFF_MASK;\n\t\trfilter[0].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t}\n\n\tif (dst & CAN_EFF_FLAG) {\n\t\trfilter[1].can_id   = dst & (CAN_EFF_MASK | CAN_EFF_FLAG);\n\t\trfilter[1].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t} else {\n\t\trfilter[1].can_id   = dst & CAN_SFF_MASK;\n\t\trfilter[1].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t}\n\n\tif (bst & CAN_EFF_FLAG) {\n\t\trfilter[2].can_id   = bst & (CAN_EFF_MASK | CAN_EFF_FLAG);\n\t\trfilter[2].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t} else {\n\t\trfilter[2].can_id   = bst & CAN_SFF_MASK;\n\t\trfilter[2].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t}\n\n\tif (bst != NO_CAN_ID)\n\t\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));\n\telse\n\t\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter) - sizeof(rfilter[0]));\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = if_nametoindex(argv[optind]);\n\tif (!addr.can_ifindex) {\n\t\tperror(\"if_nametoindex\");\n\t\treturn 1;\n\t}\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\treturn 1;\n\t}\n\n\twhile (1) {\n\t\tnbytes = read(s, &frame, sizeof(frame));\n\t\tif (nbytes < 0) {\n\t\t\tperror(\"read\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (nbytes != CAN_MTU && nbytes != CANFD_MTU) {\n\t\t\tfprintf(stderr, \"read: incomplete CAN frame %zu %d\\n\", sizeof(frame), nbytes);\n\t\t\treturn 1;\n\t\t}\n\t\tif (frame.can_id == src && ext && !extany &&\n\t\t    extaddr != frame.data[0])\n\t\t\tcontinue;\n\n\t\tif (frame.can_id == dst && rx_ext && !rx_extany &&\n\t\t    rx_extaddr != frame.data[0])\n\t\t\tcontinue;\n\n\t\tif (color) {\n\t\t\tif (frame.can_id == src)\n\t\t\t\tprintf(\"%s\", FGRED);\n\t\t\telse if (frame.can_id == dst)\n\t\t\t\tprintf(\"%s\", FGBLUE);\n\t\t\telse if (frame.can_id == bst)\n\t\t\t\tprintf(\"%s\", FGGREEN);\n\t\t}\n\n\t\tif (timestamp) {\n\t\t\tioctl(s, SIOCGSTAMP, &tv);\n\n\t\t\tswitch (timestamp) {\n\t\t\tcase 'a': /* absolute with timestamp */\n\t\t\t\tprintf(\"(%llu.%06llu) \", (unsigned long long)tv.tv_sec, (unsigned long long)tv.tv_usec);\n\t\t\t\tbreak;\n\n\t\t\tcase 'A': /* absolute with date */\n\t\t\t{\n\t\t\t\tstruct tm tm;\n\t\t\t\tchar timestring[25];\n\n\t\t\t\ttm = *localtime(&tv.tv_sec);\n\t\t\t\tstrftime(timestring, 24, \"%Y-%m-%d %H:%M:%S\",\n\t\t\t\t\t &tm);\n\t\t\t\tprintf(\"(%s.%06llu) \", timestring, (unsigned long long)tv.tv_usec);\n\t\t\t} break;\n\n\t\t\tcase 'd': /* delta */\n\t\t\tcase 'z': /* starting with zero */\n\t\t\t{\n\t\t\t\tstruct timeval diff;\n\n\t\t\t\tif (last_tv.tv_sec == 0) /* first init */\n\t\t\t\t\tlast_tv = tv;\n\t\t\t\tdiff.tv_sec = tv.tv_sec - last_tv.tv_sec;\n\t\t\t\tdiff.tv_usec = tv.tv_usec - last_tv.tv_usec;\n\t\t\t\tif (diff.tv_usec < 0)\n\t\t\t\t\tdiff.tv_sec--, diff.tv_usec += 1000000;\n\t\t\t\tif (diff.tv_sec < 0)\n\t\t\t\t\tdiff.tv_sec = diff.tv_usec = 0;\n\t\t\t\tprintf(\"(%llu.%06llu) \", (unsigned long long)diff.tv_sec,\n\t\t\t\t       (unsigned long long)diff.tv_usec);\n\n\t\t\t\tif (timestamp == 'd')\n\t\t\t\t\tlast_tv =\n\t\t\t\t\t\ttv; /* update for delta calculation */\n\t\t\t} break;\n\n\t\t\tdefault: /* no timestamp output */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\tif (frame.can_id & CAN_EFF_FLAG)\n\t\t\t\tprintf(\" %s  %8X\", argv[optind], frame.can_id & CAN_EFF_MASK);\n\t\t\telse\n\t\t\t\tprintf(\" %s  %3X\", argv[optind], frame.can_id & CAN_SFF_MASK);\n\n\t\t\tif (ext)\n\t\t\t\tprintf(\"{%02X}\", frame.data[0]);\n\n\t\t\tif (nbytes == CAN_MTU)\n\t\t\t\tprintf(\"  [%d]  \", frame.len);\n\t\t\telse\n\t\t\t\tprintf(\" [%02d]  \", frame.len);\n\n\t\t\tdatidx = 0;\n\t\t\tn_pci = frame.data[ext];\n\n\t\t\tswitch (n_pci & 0xF0) {\n\t\t\tcase 0x00:\n\t\t\t        is_ff = 1;\n\t\t\t\tif (n_pci & 0xF) {\n\t\t\t\t\tprintf(\"[SF] ln: %-4d data:\", n_pci & 0xF);\n\t\t\t\t\tdatidx = ext+1;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"[SF] ln: %-4d data:\", frame.data[ext + 1]);\n\t\t\t\t\tdatidx = ext+2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 0x10:\n\t\t\t        is_ff = 1;\n\t\t\t\tfflen = ((n_pci & 0x0F)<<8) + frame.data[ext+1];\n\t\t\t\tif (fflen)\n\t\t\t\t\tdatidx = ext+2;\n\t\t\t\telse {\n\t\t\t\t\tfflen = (frame.data[ext+2]<<24) +\n\t\t\t\t\t\t(frame.data[ext+3]<<16) +\n\t\t\t\t\t\t(frame.data[ext+4]<<8) +\n\t\t\t\t\t\tframe.data[ext+5];\n\t\t\t\t\tdatidx = ext+6;\n\t\t\t\t}\n\t\t\t\tprintf(\"[FF] ln: %-4lu data:\", fflen);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x20:\n\t\t\t\tprintf(\"[CF] sn: %X    data:\", n_pci & 0x0F);\n\t\t\t\tdatidx = ext+1;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x30:\n\t\t\t\tn_pci &= 0x0F;\n\t\t\t\tprintf(\"[FC] FC: %d \", n_pci);\n\n\t\t\t\tif (n_pci > 3)\n\t\t\t\t\tn_pci = 3;\n\n\t\t\t\tprintf(\"= %s # \", fc_info[n_pci]);\n\n\t\t\t\tprintf(\"BS: %d %s# \", frame.data[ext+1],\n\t\t\t\t       (frame.data[ext+1])? \"\":\"= off \");\n\n\t\t\t\ti = frame.data[ext+2];\n\t\t\t\tprintf(\"STmin: 0x%02X = \", i);\n\n\t\t\t\tif (i < 0x80)\n\t\t\t\t\tprintf(\"%d ms\", i);\n\t\t\t\telse if (i > 0xF0 && i < 0xFA)\n\t\t\t\t\tprintf(\"%d us\", (i & 0x0F) * 100);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"reserved\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"[??]\");\n\t\t\t}\n\n\t\t\tif (datidx && frame.len > datidx) {\n\t\t\t\tprintf(\" \");\n\t\t\t\tfor (i = datidx; i < frame.len; i++) {\n\t\t\t\t\tprintf(\"%02X \", frame.data[i]);\n\t\t\t\t}\n\n\t\t\t\tif (asc) {\n\t\t\t\t\tprintf(\"%*s\", ((7-ext) - (frame.len-datidx))*3 + 5 ,\n\t\t\t\t\t       \"-  '\");\n\t\t\t\t\tfor (i = datidx; i < frame.len; i++) {\n\t\t\t\t\t\tprintf(\"%c\",((frame.data[i] > 0x1F) &&\n\t\t\t\t\t\t\t     (frame.data[i] < 0x7F))?\n\t\t\t\t\t\t       frame.data[i] : '.');\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"'\");\n\t\t\t\t}\n\t\t\t\tif (uds_output && is_ff) {\n\t\t\t\t\tint offset = 3;\n\t\t\t\t\tif (asc)\n\t\t\t\t\t\toffset = 1;\n\t\t\t\t\tprintf(\"%*s\", ((7-ext) - (frame.len-datidx))*offset + 3,\n\t\t\t\t\t       \" - \");\n\t\t\t\t\tprint_uds_message(frame.data[datidx], frame.data[datidx+2]);\n\t\t\t\t\tis_ff = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (color)\n\t\t\t\tprintf(\"%s\", ATTRESET);\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdout);\n\t}\n\n\tclose(s);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "isotpperf.c",
          "type": "blob",
          "size": 10.921875,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * isotpperf.c - ISO15765-2 protocol performance visualisation\n *\n * Copyright (c) 2014 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <libgen.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <linux/sockios.h>\n\n#define NO_CAN_ID 0xFFFFFFFFU\n#define PERCENTRES 2 /* resolution in percent for bargraph */\n#define NUMBAR (100/PERCENTRES) /* number of bargraph elements */\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - ISO15765-2 protocol performance visualisation.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -x <addr>    (extended addressing mode)\\n\");\n\tfprintf(stderr, \"         -X <addr>    (extended addressing mode (rx addr))\\n\");\n\tfprintf(stderr, \"\\nCAN IDs and addresses are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\n/* substitute math.h function log10(value)+1 */\nunsigned int getdigits(unsigned int value)\n{\n\tint  digits = 1;\n\n\twhile (value > 9) {\n\t\tdigits++;\n\t\tvalue /= 10;\n\t}\n\treturn digits;\n}\n\nint main(int argc, char **argv)\n{\n\tfd_set rdfs;\n\tint s;\n\tint running = 1;\n\tstruct sockaddr_can addr;\n\tstruct can_filter rfilter[2];\n\tstruct canfd_frame frame;\n\tint canfd_on = 1;\n\tint nbytes, i, ret;\n\tcanid_t src = NO_CAN_ID;\n\tcanid_t dst = NO_CAN_ID;\n\tint ext = 0;\n\tint extaddr = 0;\n\tint rx_ext = 0;\n\tint rx_extaddr = 0;\n\tint datidx = 0;\n\tunsigned char bs = 0;\n\tunsigned char stmin = 0;\n\tunsigned char brs = 0;\n\tunsigned char ll_dl = 0;\n\tunsigned long fflen = 0;\n\tunsigned fflen_digits = 0;\n\tunsigned long rcvlen = 0;\n\tunsigned long percent = 0;\n\tstruct timeval start_tv, end_tv, diff_tv, timeo;\n\tunsigned int n_pci;\n\tunsigned int sn, last_sn = 0;\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"s:d:x:X:?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tsrc = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tsrc |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdst = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tdst |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\text = 1;\n\t\t\textaddr = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\trx_ext = 1;\n\t\t\trx_extaddr = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((argc - optind) != 1 || src == NO_CAN_ID || dst == NO_CAN_ID) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(0);\n\t}\n\n\tif ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\t/* try to switch the socket into CAN FD mode */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));\n\n\t/* set single CAN ID raw filters for src and dst frames */\n\tif (src & CAN_EFF_FLAG) {\n\t\trfilter[0].can_id   = src & (CAN_EFF_MASK | CAN_EFF_FLAG);\n\t\trfilter[0].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t} else {\n\t\trfilter[0].can_id   = src & CAN_SFF_MASK;\n\t\trfilter[0].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t}\n\n\tif (dst & CAN_EFF_FLAG) {\n\t\trfilter[1].can_id   = dst & (CAN_EFF_MASK | CAN_EFF_FLAG);\n\t\trfilter[1].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t} else {\n\t\trfilter[1].can_id   = dst & CAN_SFF_MASK;\n\t\trfilter[1].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);\n\t}\n\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = if_nametoindex(argv[optind]);\n\tif (!addr.can_ifindex) {\n\t\tperror(\"if_nametoindex\");\n\t\treturn 1;\n\t}\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\treturn 1;\n\t}\n\n\twhile (running) {\n\n\t\tFD_ZERO(&rdfs);\n\t\tFD_SET(s, &rdfs);\n\n\t\t/* timeout for ISO TP transmissions */\n\t\ttimeo.tv_sec  = 1;\n\t\ttimeo.tv_usec = 0;\n\n\t\tif ((ret = select(s+1, &rdfs, NULL, NULL, &timeo)) < 0) {\n\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* detected timeout of already started transmission */\n\t\tif (rcvlen && !(FD_ISSET(s, &rdfs))) {\n\t\t\tprintf(\"\\r%-*s\",78, \" (transmission timed out)\");\n\t\t\tfflush(stdout);\n\t\t\tfflen = rcvlen = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnbytes = read(s, &frame, sizeof(frame));\n\t\tif (nbytes < 0) {\n\t\t\tperror(\"read\");\n\t\t\tret = nbytes;\n\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nbytes != CAN_MTU && nbytes != CANFD_MTU) {\n\t\t\tfprintf(stderr, \"read: incomplete CAN frame %zu %d\\n\", sizeof(frame), nbytes);\n\t\t\tret = nbytes;\n\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rcvlen) {\n\t\t\t/* make sure to process only the detected PDU CAN frame type */\n\t\t\tif (canfd_on && (nbytes != CANFD_MTU))\n\t\t\t\tcontinue;\n\t\t\tif (!canfd_on && (nbytes != CAN_MTU))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t\t/* check extended address if provided */\n\t\t\tif (ext && extaddr != frame.data[0])\n\t\t\t\tcontinue;\n\n\t\t\t/* only get flow control information from dst CAN ID */\n\t\t\tif (frame.can_id == dst) {\n\t\t\t\t/* check extended address if provided */\n\t\t\t\tif (rx_ext && frame.data[0] != rx_extaddr)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tn_pci = frame.data[rx_ext];\n\t\t\t\t/* check flow control PCI only */\n\t\t\t\tif ((n_pci & 0xF0) != 0x30)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbs = frame.data[rx_ext + 1];\n\t\t\t\tstmin = frame.data[rx_ext + 2];\n\t\t\t}\n\n\t\t\t/* data content starts and index datidx */\n\t\t\tdatidx = 0;\n\n\t\t\tn_pci = frame.data[ext];\n\t\t\tswitch (n_pci & 0xF0) {\n\n\t\t\tcase 0x00:\n\t\t\t\t/* SF */\n\t\t\t\tif (n_pci & 0xF) {\n\t\t\t\t\tfflen = rcvlen = n_pci & 0xF;\n\t\t\t\t\tdatidx = ext+1;\n\t\t\t\t} else {\n\t\t\t\t\tfflen = rcvlen = frame.data[ext + 1];\n\t\t\t\t\tdatidx = ext+2;\n\t\t\t\t}\n\n\t\t\t\t/* ignore incorrect SF PDUs */\n\t\t\t\tif (frame.len < rcvlen + datidx)\n\t\t\t\t\tfflen = rcvlen = 0;\n\n\t\t\t\t/* get number of digits for printing */\n\t\t\t\tfflen_digits = getdigits(fflen);\n\n\t\t\t\t/* get CAN FD bitrate & LL_DL setting information */\n\t\t\t\tbrs = frame.flags & CANFD_BRS;\n\t\t\t\tll_dl = frame.len;\n\t\t\t\tif (ll_dl < 8)\n\t\t\t\t\tll_dl = 8;\n\n\t\t\t\tioctl(s, SIOCGSTAMP, &start_tv);\n\n\t\t\t\t/* determine CAN frame mode for this PDU */\n\t\t\t\tif (nbytes == CAN_MTU)\n\t\t\t\t\tcanfd_on = 0;\n\t\t\t\telse\n\t\t\t\t\tcanfd_on = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x10:\n\t\t\t\t/* FF */\n\t\t\t\tfflen = ((n_pci & 0x0F)<<8) + frame.data[ext+1];\n\t\t\t\tif (fflen)\n\t\t\t\t\tdatidx = ext+2;\n\t\t\t\telse {\n\t\t\t\t\tfflen = (frame.data[ext+2]<<24) +\n\t\t\t\t\t\t(frame.data[ext+3]<<16) +\n\t\t\t\t\t\t(frame.data[ext+4]<<8) +\n\t\t\t\t\t\tframe.data[ext+5];\n\t\t\t\t\tdatidx = ext+6;\n\t\t\t\t}\n\n\t\t\t\t/* to increase the time resolution we multiply fflen with 1000 later */\n\t\t\t\tif (fflen >= (UINT32_MAX / 1000)) {\n\t\t\t\t\tprintf(\"fflen %lu is more than ~4.2 MB - ignoring PDU\\n\", fflen);\n\t\t\t\t\tfflush(stdout);\n\t\t\t\t\tfflen = rcvlen = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trcvlen = frame.len - datidx;\n\t\t\t\tlast_sn = 0;\n\n\t\t\t\t/* get number of digits for printing */\n\t\t\t\tfflen_digits = getdigits(fflen);\n\n\t\t\t\t/* get CAN FD bitrate & LL_DL setting information */\n\t\t\t\tbrs = frame.flags & CANFD_BRS;\n\t\t\t\tll_dl = frame.len;\n\n\t\t\t\tioctl(s, SIOCGSTAMP, &start_tv);\n\n\t\t\t\t/* determine CAN frame mode for this PDU */\n\t\t\t\tif (nbytes == CAN_MTU)\n\t\t\t\t\tcanfd_on = 0;\n\t\t\t\telse\n\t\t\t\t\tcanfd_on = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x20:\n\t\t\t\t/* CF */\n\t\t\t\tif (rcvlen) {\n\t\t\t\t\tsn = n_pci & 0x0F;\n\t\t\t\t\tif (sn == ((last_sn + 1) & 0xF)) {\n\t\t\t\t\t\tlast_sn = sn;\n\t\t\t\t\t\tdatidx = ext+1;\n\t\t\t\t\t\trcvlen += frame.len - datidx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* PDU reception in process */\n\t\t\tif (rcvlen) {\n\t\t\t\tif (rcvlen > fflen)\n\t\t\t\t\trcvlen = fflen;\n\n\t\t\t\tpercent = (rcvlen * 100 / fflen);\n\t\t\t\tprintf(\"\\r %3lu%% \", percent);\n\n\t\t\t\tprintf(\"|\");\n\n\t\t\t\tif (percent > 100)\n\t\t\t\t\tpercent = 100;\n\n\t\t\t\tfor (i=0; i < NUMBAR; i++){\n\t\t\t\t\tif (i < (int)(percent/PERCENTRES))\n\t\t\t\t\t\tprintf(\"X\");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\".\");\n\t\t\t\t}\n\t\t\t\tprintf(\"| %*lu/%lu \", fflen_digits, rcvlen, fflen);\n\t\t\t}\n\n\t\t\t/* PDU complete */\n\t\t\tif (rcvlen && rcvlen >= fflen) {\n\n\t\t\t\tprintf(\"\\r%s %02d%c (BS:%2hhu # \", canfd_on?\"CAN-FD\":\"CAN2.0\", ll_dl, brs?'*':' ', bs);\n\t\t\t\tif (stmin < 0x80)\n\t\t\t\t\tprintf(\"STmin:%3hhu msec)\", stmin);\n\t\t\t\telse if (stmin > 0xF0 && stmin < 0xFA)\n\t\t\t\t\tprintf(\"STmin:%3u usec)\", (stmin & 0xF) * 100);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"STmin: invalid   )\");\n\n\t\t\t\tprintf(\" : %lu byte in \", fflen);\n\n\t\t\t\t/* calculate time */\n\t\t\t\tioctl(s, SIOCGSTAMP, &end_tv);\n\t\t\t\tdiff_tv.tv_sec  = end_tv.tv_sec  - start_tv.tv_sec;\n\t\t\t\tdiff_tv.tv_usec = end_tv.tv_usec - start_tv.tv_usec;\n\t\t\t\tif (diff_tv.tv_usec < 0)\n\t\t\t\t\tdiff_tv.tv_sec--, diff_tv.tv_usec += 1000000;\n\t\t\t\tif (diff_tv.tv_sec < 0)\n\t\t\t\t\tdiff_tv.tv_sec = diff_tv.tv_usec = 0;\n\n\t\t\t\t/* check devisor to be not zero */\n\t\t\t\tif (diff_tv.tv_sec * 1000 + diff_tv.tv_usec / 1000){\n\t\t\t\t\tprintf(\"%llu.%06llus \", (unsigned long long)diff_tv.tv_sec, (unsigned long long)diff_tv.tv_usec);\n\t\t\t\t\tprintf(\"=> %lu byte/s\", (fflen * 1000) /\n\t\t\t\t\t       (unsigned long)(diff_tv.tv_sec * 1000 + diff_tv.tv_usec / 1000));\n\t\t\t\t} else\n\t\t\t\t\tprintf(\"(no time available)     \");\n\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\t/* wait for next PDU */\n\t\t\t\tfflen = rcvlen = 0;\n\t\t\t}\n\t\t\tfflush(stdout);\n\t}\n\n\tclose(s);\n\n\treturn ret;\n}\n"
        },
        {
          "name": "isotprecv.c",
          "type": "blob",
          "size": 8.1787109375,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * isotprecv.c\n *\n * Copyright (c) 2008 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <linux/can.h>\n#include <linux/can/isotp.h>\n\n#define NO_CAN_ID 0xFFFFFFFFU\n#define BUFSIZE 67000 /* size > 66000 to check socket API internal checks */\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -s <can_id>   (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>   (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\\n\");\n\tfprintf(stderr, \"         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\\n\");\n\tfprintf(stderr, \"         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\\n\");\n\tfprintf(stderr, \"         -b <bs>       (blocksize. 0 = off)\\n\");\n\tfprintf(stderr, \"         -m <val>      (STmin in ms/ns. See spec.)\\n\");\n\tfprintf(stderr, \"         -f <time ns>  (force rx stmin value in nanosecs)\\n\");\n\tfprintf(stderr, \"         -w <num>      (max. wait frame transmissions.)\\n\");\n\tfprintf(stderr, \"         -l            (loop: do not exit after pdu reception.)\\n\");\n\tfprintf(stderr, \"         -F            (enable dynamic flow control parameters)\\n\");\n\tfprintf(stderr, \"         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\\n\");\n\tfprintf(stderr, \"\\nCAN IDs and addresses are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"The pdu data is written on STDOUT in space separated ASCII hex values.\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\nint main(int argc, char **argv)\n{\n    int s;\n    struct sockaddr_can addr;\n    static struct can_isotp_options opts;\n    static struct can_isotp_fc_options fcopts;\n    static struct can_isotp_ll_options llopts;\n    int opt, i;\n    extern int optind, opterr, optopt;\n    __u32 force_rx_stmin = 0;\n    int loop = 0;\n\n    unsigned char msg[BUFSIZE];\n    int nbytes;\n\n    addr.can_addr.tp.tx_id = addr.can_addr.tp.rx_id = NO_CAN_ID;\n\n    while ((opt = getopt(argc, argv, \"s:d:x:p:P:b:m:w:f:lFL:?\")) != -1) {\n\t    switch (opt) {\n\t    case 's':\n\t\t    addr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);\n\t\t    if (strlen(optarg) > 7)\n\t\t\t    addr.can_addr.tp.tx_id |= CAN_EFF_FLAG;\n\t\t    break;\n\n\t    case 'd':\n\t\t    addr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);\n\t\t    if (strlen(optarg) > 7)\n\t\t\t    addr.can_addr.tp.rx_id |= CAN_EFF_FLAG;\n\t\t    break;\n\n\t    case 'x':\n\t    {\n\t\t    int elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t  &opts.ext_address,\n\t\t\t\t\t  &opts.rx_ext_address);\n\n\t\t    if (elements == 1)\n\t\t\t    opts.flags |= CAN_ISOTP_EXTEND_ADDR;\n\t\t    else if (elements == 2)\n\t\t\t    opts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);\n\t\t    else {\n\t\t\t    printf(\"incorrect extended addr values '%s'.\\n\", optarg);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\t    }\n\n\t    case 'p':\n\t    {\n\t\t    int elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t  &opts.txpad_content,\n\t\t\t\t\t  &opts.rxpad_content);\n\n\t\t    if (elements == 1)\n\t\t\t    opts.flags |= CAN_ISOTP_TX_PADDING;\n\t\t    else if (elements == 2)\n\t\t\t    opts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);\n\t\t    else if (sscanf(optarg, \":%hhx\", &opts.rxpad_content) == 1)\n\t\t\t    opts.flags |= CAN_ISOTP_RX_PADDING;\n\t\t    else {\n\t\t\t    printf(\"incorrect padding values '%s'.\\n\", optarg);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\t    }\n\n\t    case 'P':\n\t\t    if (optarg[0] == 'l')\n\t\t\t    opts.flags |= CAN_ISOTP_CHK_PAD_LEN;\n\t\t    else if (optarg[0] == 'c')\n\t\t\t    opts.flags |= CAN_ISOTP_CHK_PAD_DATA;\n\t\t    else if (optarg[0] == 'a')\n\t\t\t    opts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);\n\t\t    else {\n\t\t\t    printf(\"unknown padding check option '%c'.\\n\", optarg[0]);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\n\t    case 'b':\n\t\t    fcopts.bs = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t    break;\n\n\t    case 'm':\n\t\t    fcopts.stmin = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t    break;\n\n\t    case 'w':\n\t\t    fcopts.wftmax = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t    break;\n\n\t    case 'f':\n\t\t    opts.flags |= CAN_ISOTP_FORCE_RXSTMIN;\n\t\t    force_rx_stmin = strtoul(optarg, NULL, 10);\n\t\t    break;\n\n\t    case 'l':\n\t\t    loop = 1;\n\t\t    break;\n\n\t    case 'F':\n\t\t    opts.flags |= CAN_ISOTP_DYN_FC_PARMS;\n\t\t    break;\n\n\t    case 'L':\n\t\t    if (sscanf(optarg, \"%hhu:%hhu:%hhu\",\n\t\t\t       &llopts.mtu,\n\t\t\t       &llopts.tx_dl,\n\t\t\t       &llopts.tx_flags) != 3) {\n\t\t\t    printf(\"unknown link layer options '%s'.\\n\", optarg);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\n\t    case '?':\n\t\t    print_usage(basename(argv[0]));\n\t\t    exit(0);\n\t\t    break;\n\n\t    default:\n\t\t    fprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t    print_usage(basename(argv[0]));\n\t\t    exit(1);\n\t\t    break;\n\t    }\n    }\n\n    if ((argc - optind != 1) ||\n\t(addr.can_addr.tp.tx_id == NO_CAN_ID) ||\n\t(addr.can_addr.tp.rx_id == NO_CAN_ID)) {\n\t    print_usage(basename(argv[0]));\n\t    exit(1);\n    }\n  \n    if ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {\n\tperror(\"socket\");\n\texit(1);\n    }\n\n    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));\n    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RECV_FC, &fcopts, sizeof(fcopts));\n\n    if (llopts.tx_dl) {\n\tif (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {\n\t    perror(\"link layer sockopt\");\n\t    exit(1);\n\t}\n    }\n\n    if (opts.flags & CAN_ISOTP_FORCE_RXSTMIN)\n\t    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RX_STMIN, &force_rx_stmin, sizeof(force_rx_stmin));\n\n    addr.can_family = AF_CAN;\n    addr.can_ifindex = if_nametoindex(argv[optind]);\n    if (!addr.can_ifindex) {\n\tperror(\"if_nametoindex\");\n\texit(1);\n    }\n\n    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\tperror(\"bind\");\n\tclose(s);\n\texit(1);\n    }\n\n    do {\n\t    nbytes = read(s, msg, BUFSIZE);\n\t    if (nbytes > 0 && nbytes < BUFSIZE)\n\t\t    for (i=0; i < nbytes; i++)\n\t\t\t    printf(\"%02X \", msg[i]);\n\t    printf(\"\\n\");\n    } while (loop);\n\n    close(s);\n\n    return 0;\n}\n"
        },
        {
          "name": "isotpsend.c",
          "type": "blob",
          "size": 9.8203125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * isotpsend.c\n *\n * Copyright (c) 2008 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <linux/can.h>\n#include <linux/can/isotp.h>\n\n#define NO_CAN_ID 0xFFFFFFFFU\n#define BUFSIZE 67000 /* size > 66000 kernel buf to test socket API internal checks */\n#define ZERO_STRING \"ZERO\"\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\\n\");\n\tfprintf(stderr, \"         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\\n\");\n\tfprintf(stderr, \"         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\\n\");\n\tfprintf(stderr, \"         -t <time ns>  (frame transmit time (N_As) in nanosecs) (*)\\n\");\n\tfprintf(stderr, \"         -f <time ns>  (ignore FC and force local tx stmin value in nanosecs)\\n\");\n\tfprintf(stderr, \"         -D <len>      (send a fixed PDU with len bytes - no STDIN data)\\n\");\n\tfprintf(stderr, \"         -l <num>      (send num PDUs - use 'i' for infinite loop)\\n\");\n\tfprintf(stderr, \"         -g <usecs>    (wait given usecs before sending a PDU)\\n\");\n\tfprintf(stderr, \"         -b            (block until the PDU transmission is completed)\\n\");\n\tfprintf(stderr, \"         -S            (SF broadcast mode - for functional addressing)\\n\");\n\tfprintf(stderr, \"         -C            (CF broadcast mode - no wait for flow controls)\\n\");\n\tfprintf(stderr, \"         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\\n\");\n\tfprintf(stderr, \"\\nCAN IDs and addresses are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"The pdu data is expected on STDIN in space separated ASCII hex values.\\n\");\n\tfprintf(stderr, \"(*) = Use '-t %s' to set N_As to zero for Linux version 5.18+\\n\", ZERO_STRING);\n\tfprintf(stderr, \"\\n\");\n}\n\nint main(int argc, char **argv)\n{\n    int s;\n    struct sockaddr_can addr;\n    static struct can_isotp_options opts;\n    static struct can_isotp_ll_options llopts;\n    int opt;\n    extern int optind, opterr, optopt;\n    unsigned int loops = 1; /* one (== no) loop by default */\n    useconds_t usecs = 0; /* wait before sending the PDU */\n    __u32 force_tx_stmin = 0;\n    unsigned char buf[BUFSIZE];\n    int buflen = 0;\n    int datalen = 0;\n    int retval = 0;\n\n    addr.can_addr.tp.tx_id = addr.can_addr.tp.rx_id = NO_CAN_ID;\n\n    while ((opt = getopt(argc, argv, \"s:d:x:p:P:t:f:D:l:g:bSCL:?\")) != -1) {\n\t    switch (opt) {\n\t    case 's':\n\t\t    addr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);\n\t\t    if (strlen(optarg) > 7)\n\t\t\t    addr.can_addr.tp.tx_id |= CAN_EFF_FLAG;\n\t\t    break;\n\n\t    case 'd':\n\t\t    addr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);\n\t\t    if (strlen(optarg) > 7)\n\t\t\t    addr.can_addr.tp.rx_id |= CAN_EFF_FLAG;\n\t\t    break;\n\n\t    case 'x':\n\t    {\n\t\t    int elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t  &opts.ext_address,\n\t\t\t\t\t  &opts.rx_ext_address);\n\n\t\t    if (elements == 1)\n\t\t\t    opts.flags |= CAN_ISOTP_EXTEND_ADDR;\n\t\t    else if (elements == 2)\n\t\t\t    opts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);\n\t\t    else {\n\t\t\t    printf(\"incorrect extended addr values '%s'.\\n\", optarg);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\t    }\n\n\t    case 'p':\n\t    {\n\t\t    int elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t  &opts.txpad_content,\n\t\t\t\t\t  &opts.rxpad_content);\n\n\t\t    if (elements == 1)\n\t\t\t    opts.flags |= CAN_ISOTP_TX_PADDING;\n\t\t    else if (elements == 2)\n\t\t\t    opts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);\n\t\t    else if (sscanf(optarg, \":%hhx\", &opts.rxpad_content) == 1)\n\t\t\t    opts.flags |= CAN_ISOTP_RX_PADDING;\n\t\t    else {\n\t\t\t    printf(\"incorrect padding values '%s'.\\n\", optarg);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\t    }\n\n\t    case 'P':\n\t\t    if (optarg[0] == 'l')\n\t\t\t    opts.flags |= CAN_ISOTP_CHK_PAD_LEN;\n\t\t    else if (optarg[0] == 'c')\n\t\t\t    opts.flags |= CAN_ISOTP_CHK_PAD_DATA;\n\t\t    else if (optarg[0] == 'a')\n\t\t\t    opts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);\n\t\t    else {\n\t\t\t    printf(\"unknown padding check option '%c'.\\n\", optarg[0]);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\n\t    case 't':\n\t\t    if (!strncmp(optarg, ZERO_STRING, strlen(ZERO_STRING)))\n\t\t\t    opts.frame_txtime = CAN_ISOTP_FRAME_TXTIME_ZERO;\n\t\t    else\n\t\t\t    opts.frame_txtime = strtoul(optarg, NULL, 10);\n\t\t    break;\n\n\t    case 'f':\n\t\t    opts.flags |= CAN_ISOTP_FORCE_TXSTMIN;\n\t\t    force_tx_stmin = strtoul(optarg, NULL, 10);\n\t\t    break;\n\n\t    case 'D':\n\t\t    datalen = strtoul(optarg, NULL, 10);\n\t\t    if (!datalen || datalen >= BUFSIZE) {\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\n\t    case 'l':\n\t\t    if (optarg[0] == 'i') {\n\t\t\t    loops = 0; /* infinite loop */\n\t\t    } else {\n\t\t\t    loops = strtoul(optarg, NULL, 10);\n\t\t\t    if (!loops) {\n\t\t\t\t    fprintf(stderr, \"Invalid argument for option -l!\\n\");\n\t\t\t\t    return 1;\n\t\t\t    }\n\t\t    }\n\t\t    break;\n\n\t    case 'g':\n\t\t    usecs = strtoul(optarg, NULL, 10);\n\t\t    break;\n\n\t    case 'b':\n\t\t    opts.flags |= CAN_ISOTP_WAIT_TX_DONE;\n\t\t    break;\n\n\t    case 'S':\n\t\t    opts.flags |= CAN_ISOTP_SF_BROADCAST;\n\t\t    break;\n\n\t    case 'C':\n\t\t    opts.flags |= CAN_ISOTP_CF_BROADCAST;\n\t\t    break;\n\n\t    case 'L':\n\t\t    if (sscanf(optarg, \"%hhu:%hhu:%hhu\",\n\t\t\t       &llopts.mtu,\n\t\t\t       &llopts.tx_dl,\n\t\t\t       &llopts.tx_flags) != 3) {\n\t\t\t    printf(\"unknown link layer options '%s'.\\n\", optarg);\n\t\t\t    print_usage(basename(argv[0]));\n\t\t\t    exit(0);\n\t\t    }\n\t\t    break;\n\n\t    case '?':\n\t\t    print_usage(basename(argv[0]));\n\t\t    exit(0);\n\t\t    break;\n\n\t    default:\n\t\t    fprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t    print_usage(basename(argv[0]));\n\t\t    exit(1);\n\t\t    break;\n\t    }\n    }\n\n#define BC_FLAGS (CAN_ISOTP_SF_BROADCAST | CAN_ISOTP_CF_BROADCAST)\n\n    if ((argc - optind != 1) ||\n\t(addr.can_addr.tp.tx_id == NO_CAN_ID) ||\n\t((opts.flags & BC_FLAGS) == BC_FLAGS) ||\n\t((addr.can_addr.tp.rx_id == NO_CAN_ID) &&\n\t (!(opts.flags & BC_FLAGS)))) {\n\t    print_usage(basename(argv[0]));\n\t    exit(1);\n    }\n\n    if ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {\n\tperror(\"socket\");\n\texit(1);\n    }\n\n    if (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts)) < 0) {\n\tperror(\"sockopt\");\n\texit(1);\n    }\n\n\n    if (llopts.tx_dl) {\n\tif (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {\n\t    perror(\"link layer sockopt\");\n\t    exit(1);\n\t}\n    }\n\n    if (opts.flags & CAN_ISOTP_FORCE_TXSTMIN)\n\t    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_TX_STMIN, &force_tx_stmin, sizeof(force_tx_stmin));\n\n    addr.can_family = AF_CAN;\n    addr.can_ifindex = if_nametoindex(argv[optind]);\n    if (!addr.can_ifindex) {\n\tperror(\"if_nametoindex\");\n\texit(1);\n    }\n\n    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\tperror(\"bind\");\n\tclose(s);\n\texit(1);\n    }\n\n    if (!datalen) {\n\t    while (buflen < BUFSIZE && scanf(\"%hhx\", &buf[buflen]) == 1)\n\t\t    buflen++;\n    } else {\n\t    for (buflen = 0; buflen < datalen; buflen++)\n\t\t    buf[buflen] = ((buflen % 0xFF) + 1) & 0xFF;\n    }\n\nloop:\n    if (usecs)\n\t    usleep(usecs);\n\n    retval = write(s, buf, buflen);\n    if (retval < 0) {\n\t    perror(\"write\");\n\t    return retval;\n    }\n\n    if (retval != buflen)\n\t    fprintf(stderr, \"wrote only %d from %d byte\\n\", retval, buflen);\n\n    if (loops) {\n\t    if (--loops)\n\t\t    goto loop;\n    } else {\n\t    goto loop;\n    }\n\n    /* \n     * due to a Kernel internal wait queue the PDU is sent completely\n     * before close() returns.\n     */\n    close(s);\n\n    return 0;\n}\n"
        },
        {
          "name": "isotpserver.c",
          "type": "blob",
          "size": 11.3583984375,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * isotpserver.c\n *\n * Implements a socket server which understands ASCII HEX\n * messages for simple TCP/IP <-> ISO 15765-2 bridging.\n *\n * General message format: <[data]+>\n *\n * e.g. for an eight bytes PDU\n *\n * <1122334455667788>\n *\n * Valid ISO 15625-2 PDUs have a length from 1-4095 bytes.\n *\n * Authors:\n * Andre Naujoks (the socket server stuff)\n * Oliver Hartkopp (the rest)\n *\n * Copyright (c) 2002-2010 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <errno.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <sys/wait.h>\n\n#include <linux/can.h>\n#include <linux/can/isotp.h>\n\n#define NO_CAN_ID 0xFFFFFFFFU\n\n/* allow PDUs greater 4095 bytes according ISO 15765-2:2015 */\n#define MAX_PDU_LENGTH 6000\n\nint b64hex(char *asc, unsigned char *bin, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!sscanf(asc+(i*2), \"%2hhx\", bin+i))\n\t\t\treturn 1;\t\n\t}\n\treturn 0;\n}\n\nvoid childdied(int i)\n{\n\twait(NULL);\n}\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"\\nUsage: %s -l <port> -s <can_id> -d <can_id> [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"ip addressing:\\n\");\n\tfprintf(stderr, \"         -l <port>    * (local port for the server)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"isotp addressing:\\n\");\n\tfprintf(stderr, \"         -s <can_id>  * (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>  * (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\\n\");\n\tfprintf(stderr, \"         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"padding:\\n\");\n\tfprintf(stderr, \"         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\\n\");\n\tfprintf(stderr, \"         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"rx path:\\n (config, which is sent to the sender / data source)\\n\");\n\tfprintf(stderr, \"         -b <bs>       (blocksize. 0 = off)\\n\");\n\tfprintf(stderr, \"         -m <val>      (STmin in ms/ns. See spec.)\\n\");\n\tfprintf(stderr, \"         -w <num>      (max. wait frame transmissions)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"tx path:\\n (config, which changes local tx settings)\\n\");\n\tfprintf(stderr, \"         -t <time ns>  (transmit time in nanosecs)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"(* = mandatory option)\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"All values except for '-l' and '-t' are expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\nint main(int argc, char **argv)\n{\n\textern int optind, opterr, optopt;\n\tint opt;\n\n\tint sl, sa, sc; /* (L)isten, (A)ccept, (C)AN sockets */ \n\tstruct sockaddr_in  saddr, clientaddr;\n\tstruct sockaddr_can caddr;\n\tstatic struct can_isotp_options opts;\n\tstatic struct can_isotp_fc_options fcopts;\n\tstatic struct can_isotp_ll_options llopts;\n\tsocklen_t sin_size = sizeof(clientaddr);\n\tsocklen_t caddrlen = sizeof(caddr);\n\n\tstruct sigaction signalaction;\n\tsigset_t sigset;\n\n\tfd_set readfds;\n\n\tint i;\n\tint nbytes;\n\n\tint local_port = 0;\n\tint verbose = 0;\n\n\tint idx = 0; /* index in txmsg[] */\n\n\tunsigned char msg[MAX_PDU_LENGTH + 1];   /* isotp socket message buffer (4095 + test_for_too_long_byte)*/\n\tchar rxmsg[MAX_PDU_LENGTH * 2 + 4]; /* isotp->tcp ASCII message buffer (4095*2 + < > \\n null) */\n\tchar txmsg[MAX_PDU_LENGTH * 2 + 3]; /* tcp->isotp ASCII message buffer (4095*2 + < > null) */\n\n\t/* mark missing mandatory commandline options as missing */\n\tcaddr.can_addr.tp.tx_id = caddr.can_addr.tp.rx_id = NO_CAN_ID;\n\n\twhile ((opt = getopt(argc, argv, \"l:s:d:x:p:P:b:m:w:t:L:v?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'l':\n\t\t\tlocal_port = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tcaddr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tcaddr.can_addr.tp.tx_id |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tcaddr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tcaddr.can_addr.tp.rx_id |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t{\n\t\t\tint elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t      &opts.ext_address,\n\t\t\t\t\t      &opts.rx_ext_address);\n\n\t\t\tif (elements == 1)\n\t\t\t\topts.flags |= CAN_ISOTP_EXTEND_ADDR;\n\t\t\telse if (elements == 2)\n\t\t\t\topts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);\n\t\t\telse {\n\t\t\t\tprintf(\"incorrect extended addr values '%s'.\\n\", optarg);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'p':\n\t\t{\n\t\t\tint elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t      &opts.txpad_content,\n\t\t\t\t\t      &opts.rxpad_content);\n\n\t\t\tif (elements == 1)\n\t\t\t\topts.flags |= CAN_ISOTP_TX_PADDING;\n\t\t\telse if (elements == 2)\n\t\t\t\topts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);\n\t\t\telse if (sscanf(optarg, \":%hhx\", &opts.rxpad_content) == 1)\n\t\t\t\topts.flags |= CAN_ISOTP_RX_PADDING;\n\t\t\telse {\n\t\t\t\tprintf(\"incorrect padding values '%s'.\\n\", optarg);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'P':\n\t\t\tif (optarg[0] == 'l')\n\t\t\t\topts.flags |= CAN_ISOTP_CHK_PAD_LEN;\n\t\t\telse if (optarg[0] == 'c')\n\t\t\t\topts.flags |= CAN_ISOTP_CHK_PAD_DATA;\n\t\t\telse if (optarg[0] == 'a')\n\t\t\t\topts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);\n\t\t\telse {\n\t\t\t\tprintf(\"unknown padding check option '%c'.\\n\", optarg[0]);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tfcopts.bs = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tfcopts.stmin = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tfcopts.wftmax = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\topts.frame_txtime = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tif (sscanf(optarg, \"%hhu:%hhu:%hhu\",\n\t\t\t\t   &llopts.mtu,\n\t\t\t\t   &llopts.tx_dl,\n\t\t\t\t   &llopts.tx_flags) != 3) {\n\t\t\t\tprintf(\"unknown link layer options '%s'.\\n\", optarg);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((argc - optind != 1) || (local_port == 0) ||\n\t    (caddr.can_addr.tp.tx_id == NO_CAN_ID) ||\n\t    (caddr.can_addr.tp.rx_id == NO_CAN_ID)) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(1);\n\t}\n  \n\tsigemptyset(&sigset);\n\tsignalaction.sa_handler = &childdied;\n\tsignalaction.sa_mask = sigset;\n\tsignalaction.sa_flags = 0;\n\tsigaction(SIGCHLD, &signalaction, NULL);  /* signal for dying child */\n\n\tif((sl = socket(PF_INET, SOCK_STREAM, 0)) < 0) {\n\t\tperror(\"inetsocket\");\n\t\texit(1);\n\t}\n\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(local_port);\n\n\twhile(bind(sl,(struct sockaddr*)&saddr, sizeof(saddr)) < 0) {\n\t\tstruct timespec f = {\n\t\t\t.tv_nsec = 100 * 1000 * 1000,\n\t\t};\n\n\t\tprintf(\".\");\n\t\tfflush(NULL);\n\t\tnanosleep(&f, NULL);\n\t}\n\n\tif (listen(sl, 3) != 0) {\n\t\tperror(\"listen\");\n\t\texit(1);\n\t}\n\n\twhile (1) { \n\t\tsa = accept(sl,(struct sockaddr *)&clientaddr, &sin_size);\n\t\tif (sa > 0 ){\n\t\t\tif (!fork())\n\t\t\t\tbreak;\n\t\t\tclose(sa);\n\t\t}\n\t\telse {\n\t\t\tif (errno != EINTR) {\n\t\t\t\t/*\n\t\t\t\t * If the cause for the error was NOT the\n\t\t\t\t * signal from a dying child => give an error\n\t\t\t\t */\n\t\t\t\tperror(\"accept\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((sc = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {\n\t\tperror(\"socket\");\n\t\texit(1);\n\t}\n\n\tsetsockopt(sc, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));\n\tsetsockopt(sc, SOL_CAN_ISOTP, CAN_ISOTP_RECV_FC, &fcopts, sizeof(fcopts));\n\n\tif (llopts.tx_dl) {\n\t\tif (setsockopt(sc, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {\n\t\t\tperror(\"link layer sockopt\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tcaddr.can_family = AF_CAN;\n\tcaddr.can_ifindex = if_nametoindex(argv[optind]);\n\tif (!caddr.can_ifindex) {\n\t\tperror(\"if_nametoindex\");\n\t\texit(1);\n\t}\n\n\tif (bind(sc, (struct sockaddr *)&caddr, caddrlen) < 0) {\n\t\tperror(\"bind\");\n\t\texit(1);\n\t}\n\n\twhile (1) {\n\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(sc, &readfds);\n\t\tFD_SET(sa, &readfds);\n\n\t\tselect((sc > sa)?sc+1:sa+1, &readfds, NULL, NULL, NULL);\n\n\t\tif (FD_ISSET(sc, &readfds)) {\n\n\n\t\t\tnbytes = read(sc, &msg, MAX_PDU_LENGTH + 1);\n\n\t\t\tif (nbytes < 1 || nbytes > MAX_PDU_LENGTH) {\n\t\t\t\tperror(\"read from isotp socket\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\trxmsg[0] = '<';\n\n\t\t\tfor ( i = 0; i < nbytes; i++)\n\t\t\t\tsprintf(rxmsg + 1 + 2*i, \"%02X\", msg[i]);\n\n\t\t\t/* finalize string for sending */\n\t\t\tstrcat(rxmsg, \">\\n\");\n\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"CAN>TCP %s\", rxmsg);\n\n\t\t\tsend(sa, rxmsg, strlen(rxmsg), 0);\n\t\t}\n\n\n\t\tif (FD_ISSET(sa, &readfds)) {\n\n\t\t\tif (read(sa, txmsg+idx, 1) < 1) {\n\t\t\t\tperror(\"read from tcp/ip socket\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (!idx) {\n\t\t\t\tif (txmsg[0] == '<')\n\t\t\t\t\tidx = 1;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* max len is 4095*2 + '<' + '>' = 8192. The buffer index starts with 0 */\n\t\t\tif (idx > MAX_PDU_LENGTH * 2 + 1) {\n\t\t\t\tidx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (txmsg[idx] != '>') {\n\t\t\t\tidx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttxmsg[idx+1] = 0;\n\t\t\tidx = 0;\n\n\t\t\t/* must be an even number of bytes and at least one data byte <XX> */\n\t\t\tif (strlen(txmsg) < 4 || strlen(txmsg) % 2)\n\t\t\t\tcontinue;\n\n\t\t\tif (verbose)\n\t\t\t\tprintf(\"TCP>CAN %s\\n\", txmsg);\n\n\t\t\tnbytes = (strlen(txmsg)-2)/2;\n\t\t\tif (b64hex(txmsg+1, msg, nbytes) == 0)\n\t\t\t\tsend(sc, msg, nbytes, 0);\n\t\t}\n\t}\n\n\tclose(sc);\n\tclose(sa);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "isotpsniffer.c",
          "type": "blob",
          "size": 10.126953125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * isotpsniffer.c - dump ISO15765-2 datagrams using PF_CAN isotp protocol \n *\n * Copyright (c) 2008 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <ctype.h>\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include \"terminal.h\"\n#include <linux/can.h>\n#include <linux/can/isotp.h>\n#include <linux/sockios.h>\n\n#define NO_CAN_ID 0xFFFFFFFFU\n\n#define FORMAT_HEX 1\n#define FORMAT_ASCII 2\n#define FORMAT_DEFAULT (FORMAT_ASCII | FORMAT_HEX)\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -x <addr>    (extended addressing mode)\\n\");\n\tfprintf(stderr, \"         -X <addr>    (extended addressing mode - rx addr)\\n\");\n\tfprintf(stderr, \"         -c           (color mode)\\n\");\n\tfprintf(stderr, \"         -t <type>    (timestamp: (a)bsolute/(d)elta/(z)ero/(A)bsolute w date)\\n\");\n\tfprintf(stderr, \"         -f <format>  (1 = HEX, 2 = ASCII, 3 = HEX & ASCII - default: %d)\\n\", FORMAT_DEFAULT);\n\tfprintf(stderr, \"         -L           (set link layer options for CAN FD)\\n\");\n\tfprintf(stderr, \"         -h <len>     (head: print only first <len> bytes)\\n\");\n\tfprintf(stderr, \"\\nCAN IDs and addresses are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid printbuf(unsigned char *buffer, int nbytes, int color, int timestamp,\n\t      int format, struct timeval *tv, struct timeval *last_tv,\n\t      canid_t src, int socket, char *candevice, int head)\n{\n\tint i;\n\n\tif (color == 1)\n\t\tprintf(\"%s\", FGRED);\n\n\tif (color == 2)\n\t\tprintf(\"%s\", FGBLUE);\n\n\tif (timestamp) {\n\t\tioctl(socket, SIOCGSTAMP, tv);\n\n\t\tswitch (timestamp) {\n\n\t\tcase 'a': /* absolute with timestamp */\n\t\t\tprintf(\"(%llu.%06llu) \", (unsigned long long)tv->tv_sec, (unsigned long long)tv->tv_usec);\n\t\t\tbreak;\n\n\t\tcase 'A': /* absolute with date */\n\t\t{\n\t\t\tstruct tm tm;\n\t\t\tchar timestring[25];\n\n\t\t\ttm = *localtime(&tv->tv_sec);\n\t\t\tstrftime(timestring, 24, \"%Y-%m-%d %H:%M:%S\", &tm);\n\t\t\tprintf(\"(%s.%06llu) \", timestring, (unsigned long long)tv->tv_usec);\n\t\t}\n\t\tbreak;\n\n\t\tcase 'd': /* delta */\n\t\tcase 'z': /* starting with zero */\n\t\t{\n\t\t\tstruct timeval diff;\n\n\t\t\tif (last_tv->tv_sec == 0)   /* first init */\n\t\t\t\t*last_tv = *tv;\n\t\t\tdiff.tv_sec  = tv->tv_sec  - last_tv->tv_sec;\n\t\t\tdiff.tv_usec = tv->tv_usec - last_tv->tv_usec;\n\t\t\tif (diff.tv_usec < 0)\n\t\t\t\tdiff.tv_sec--, diff.tv_usec += 1000000;\n\t\t\tif (diff.tv_sec < 0)\n\t\t\t\tdiff.tv_sec = diff.tv_usec = 0;\n\t\t\tprintf(\"(%llu.%06llu) \", (unsigned long long)diff.tv_sec, (unsigned long long)diff.tv_usec);\n\n\t\t\tif (timestamp == 'd')\n\t\t\t\t*last_tv = *tv; /* update for delta calculation */\n\t\t}\n\t\tbreak;\n\n\t\tdefault: /* no timestamp output */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* the source socket gets pdu data from the destination id */\n\tprintf(\" %s  %03X  [%d]  \", candevice, src & CAN_EFF_MASK, nbytes);\n\tif (format & FORMAT_HEX) {\n\t\tfor (i=0; i<nbytes; i++) {\n\t\t\tprintf(\"%02X \", buffer[i]);\n\t\t\tif (head && i+1 >= head) {\n\t\t\t\tprintf(\"... \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (format & FORMAT_ASCII)\n\t\t\tprintf(\" - \");\n\t}\n\tif (format & FORMAT_ASCII) {\n\t\tprintf(\"'\");\n\t\tfor (i=0; i<nbytes; i++) {\n\t\t\tif (isprint(buffer[i]))\n\t\t\t\tprintf(\"%c\", buffer[i]);\n\t\t\telse\n\t\t\t\tprintf(\".\");\n\t\t\tif (head && i+1 >= head)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"'\");\n\t\tif (head && i+1 >= head)\n\t\t\tprintf(\" ... \");\n\t}\n\n\tif (color)\n\t\tprintf(\"%s\", ATTRESET);\n\n\tprintf(\"\\n\");\n\tfflush(stdout);\n}\n\nint main(int argc, char **argv)\n{\n\tfd_set rdfs;\n\tint s = -1, t = -1;\n\tstruct sockaddr_can addr;\n\tchar if_name[IFNAMSIZ];\n\tstatic struct can_isotp_options opts;\n\tstatic struct can_isotp_ll_options llopts;\n\tint r = 0;\n\tint opt, quit = 0;\n\tint color = 0;\n\tint head = 0;\n\tint timestamp = 0;\n\tint format = FORMAT_DEFAULT;\n\tcanid_t src = NO_CAN_ID;\n\tcanid_t dst = NO_CAN_ID;\n\textern int optind, opterr, optopt;\n\tstatic struct timeval tv, last_tv;\n\n\tunsigned char buffer[4096];\n\tint nbytes;\n\n\twhile ((opt = getopt(argc, argv, \"s:d:x:X:h:ct:f:L?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tsrc = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tsrc |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdst = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\tdst |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\topts.flags |= CAN_ISOTP_EXTEND_ADDR;\n\t\t\topts.ext_address = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'X':\n\t\t\topts.flags |= CAN_ISOTP_RX_EXT_ADDR;\n\t\t\topts.rx_ext_address = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tformat = (atoi(optarg) & (FORMAT_ASCII | FORMAT_HEX));\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tllopts.mtu = CANFD_MTU;\n\t\t\tllopts.tx_dl = CANFD_MAX_DLEN;\n\t\t\tllopts.tx_flags = CANFD_BRS;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\thead = atoi(optarg);\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tcolor = 1;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\ttimestamp = optarg[0];\n\t\t\tif ((timestamp != 'a') && (timestamp != 'A') &&\n\t\t\t    (timestamp != 'd') && (timestamp != 'z')) {\n\t\t\t\tprintf(\"%s: unknown timestamp mode '%c' - ignored\\n\",\n\t\t\t\t       basename(argv[0]), optarg[0]);\n\t\t\t\ttimestamp = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\tgoto out;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((argc - optind) != 1 || src == NO_CAN_ID || dst == NO_CAN_ID) {\n\t\tprint_usage(basename(argv[0]));\n\t\tr = 1;\n\t\tgoto out;\n\t}\n  \n\tif ((opts.flags & CAN_ISOTP_RX_EXT_ADDR) && (!(opts.flags & CAN_ISOTP_EXTEND_ADDR))) {\n\t\tprint_usage(basename(argv[0]));\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\tif ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {\n\t\tperror(\"socket\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\tif ((t = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {\n\t\tperror(\"socket\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\topts.flags |= CAN_ISOTP_LISTEN_MODE;\n\n\tstrncpy(if_name, argv[optind], IFNAMSIZ - 1);\n\tif_name[IFNAMSIZ - 1] = '\\0';\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = if_nametoindex(if_name);\n\tif (!addr.can_ifindex) {\n\t\tperror(\"if_nametoindex\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\tif (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts)) < 0) {\n\t\tperror(\"setsockopt\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\tif ((llopts.mtu) && (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts))) < 0) {\n\t\tperror(\"setsockopt\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\taddr.can_addr.tp.tx_id = src;\n\taddr.can_addr.tp.rx_id = dst;\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\tif (opts.flags & CAN_ISOTP_RX_EXT_ADDR) {\n\t\t/* flip extended address info due to separate rx ext addr */\n\t\t__u8 tmpext;\n\n\t\ttmpext = opts.ext_address;\n\t\topts.ext_address = opts.rx_ext_address;\n\t\topts.rx_ext_address = tmpext;\n\t}\n\n\tif (setsockopt(t, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts)) < 0) {\n\t\tperror(\"setsockopt\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\tif ((llopts.mtu) && (setsockopt(t, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts))) < 0) {\n\t\tperror(\"setsockopt\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\taddr.can_addr.tp.tx_id = dst;\n\taddr.can_addr.tp.rx_id = src;\n\n\tif (bind(t, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\tr = 1;\n\t\tgoto out;\n\t}\n\n\twhile (!quit) {\n\n\t\tFD_ZERO(&rdfs);\n\t\tFD_SET(s, &rdfs);\n\t\tFD_SET(t, &rdfs);\n\t\tFD_SET(0, &rdfs);\n\n\t\tif ((nbytes = select(t+1, &rdfs, NULL, NULL, NULL)) < 0) {\n\t\t\tperror(\"select\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FD_ISSET(0, &rdfs)) {\n\t\t\tgetchar();\n\t\t\tquit = 1;\n\t\t\tprintf(\"quit due to keyboard input.\\n\");\n\t\t}\n\n\t\tif (FD_ISSET(s, &rdfs)) {\n\t\t\tnbytes = read(s, buffer, 4096);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tperror(\"read socket s\");\n\t\t\t\tr = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (nbytes > 4095) {\n\t\t\t\tr = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tprintbuf(buffer, nbytes, color?2:0, timestamp, format,\n\t\t\t\t &tv, &last_tv, dst, s, if_name, head);\n\t\t}\n\n\t\tif (FD_ISSET(t, &rdfs)) {\n\t\t\tnbytes = read(t, buffer, 4096);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tperror(\"read socket t\");\n\t\t\t\tr = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (nbytes > 4095) {\n\t\t\t\tr = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tprintbuf(buffer, nbytes, color?1:0, timestamp, format,\n\t\t\t\t &tv, &last_tv, src, t, if_name, head);\n\t\t}\n\t}\n\nout:\n\tif (s != -1)\n\t\tclose(s);\n\tif (t != -1)\n\t\tclose(t);\n\n\treturn r;\n}\n"
        },
        {
          "name": "isotptun.c",
          "type": "blob",
          "size": 11.6025390625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * isotptun.c - IP over CAN ISO-TP (ISO15765-2) tunnel / proof-of-concept\n *\n * This program creates a Linux tunnel netdevice 'ctunX' and transfers the\n * ethernet frames inside ISO15765-2 (unreliable) datagrams on CAN.\n *\n * Use e.g. \"ifconfig ctun0 123.123.123.1 pointopoint 123.123.123.2 up\"\n * to create a point-to-point IP connection on CAN.\n *\n * Copyright (c) 2008 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <linux/can.h>\n#include <linux/can/isotp.h>\n#include <linux/if_tun.h>\n\n/* Change this to whatever your daemon is called */\n#define DAEMON_NAME \"isotptun\"\n\n#define NO_CAN_ID 0xFFFFFFFFU\n#define DEFAULT_NAME \"ctun%d\"\n\n/* stay on 4095 bytes for the max. PDU length which is still much more than the standard ethernet MTU */\n#define MAX_PDU_LENGTH 4095\n#define BUF_LEN (MAX_PDU_LENGTH + 1)\n\nstatic volatile int running = 1;\nstatic volatile sig_atomic_t signal_num;\n\nstatic void fake_syslog(int priority, const char *format, ...)\n{\n\tva_list ap;\n\n\tfprintf(stderr, \"[%d] \", priority);\n\tva_start(ap, format);\n\tvfprintf(stderr, format, ap);\n\tva_end(ap);\n\tfprintf(stderr, \"\\n\");\n}\n\ntypedef void (*syslog_t)(int priority, const char *format, ...);\nstatic syslog_t syslogger = syslog;\n\nvoid perror_syslog(const char *s)\n{\n\tconst char *colon = s ? \": \" : \"\";\n\tsyslogger(LOG_ERR, \"%s%s%s\", s, colon, strerror(errno));\n}\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - IP over CAN ISO-TP (ISO15765-2) tunnel / proof-of-concept.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options] <CAN interface>\\n\\n\", prg);\n\tfprintf(stderr, \"This program creates a Linux tunnel netdevice 'ctunX' and transfers the\\n\");\n\tfprintf(stderr, \"ethernet frames inside ISO15765-2 (unreliable) datagrams on CAN.\\n\\n\");\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -s <can_id>   (source can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -d <can_id>   (destination can_id. Use 8 digits for extended IDs)\\n\");\n\tfprintf(stderr, \"         -n <name>     (name of created IP netdevice. Default: '%s')\\n\", DEFAULT_NAME);\n\tfprintf(stderr, \"         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\\n\");\n\tfprintf(stderr, \"         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\\n\");\n\tfprintf(stderr, \"         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\\n\");\n\tfprintf(stderr, \"         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\\n\");\n\tfprintf(stderr, \"         -t <time ns>  (transmit time in nanosecs)\\n\");\n\tfprintf(stderr, \"         -b <bs>       (blocksize. 0 = off)\\n\");\n\tfprintf(stderr, \"         -m <val>      (STmin in ms/ns. See spec.)\\n\");\n\tfprintf(stderr, \"         -w <num>      (max. wait frame transmissions.)\\n\");\n\tfprintf(stderr, \"         -D            (daemonize to background when tun device created)\\n\");\n\tfprintf(stderr, \"         -h            (half duplex mode.)\\n\");\n\tfprintf(stderr, \"         -v            (verbose mode. Print symbols for tunneled msgs.)\\n\");\n\tfprintf(stderr, \"\\nCAN IDs and addresses are given and expected in hexadecimal values.\\n\");\n\tfprintf(stderr, \"Use e.g. 'ifconfig ctun0 123.123.123.1 pointopoint 123.123.123.2 up'\\n\");\n\tfprintf(stderr, \"to create a point-to-point IP connection on CAN.\\n\");\n\tfprintf(stderr, \"\\n\");\n}\n\nvoid sigterm(int signo)\n{\n\trunning = 0;\n\tsignal_num = signo;\n}\n\nint main(int argc, char **argv)\n{\n\tfd_set rdfs;\n\tint s, t;\n\tstruct sockaddr_can addr;\n\tstruct ifreq ifr;\n\tstatic struct can_isotp_options opts;\n\tstatic struct can_isotp_fc_options fcopts;\n\tstatic struct can_isotp_ll_options llopts;\n\tint opt, ret;\n\textern int optind, opterr, optopt;\n\tstatic int verbose;\n\tunsigned char buffer[BUF_LEN];\n\tstatic char name[sizeof(ifr.ifr_name)] = DEFAULT_NAME;\n\tint nbytes;\n\tint run_as_daemon = 0;\n\n\taddr.can_addr.tp.tx_id = addr.can_addr.tp.rx_id = NO_CAN_ID;\n\n\twhile ((opt = getopt(argc, argv, \"s:d:n:x:p:P:t:b:m:whL:vD?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\taddr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\taddr.can_addr.tp.tx_id |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\taddr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);\n\t\t\tif (strlen(optarg) > 7)\n\t\t\t\taddr.can_addr.tp.rx_id |= CAN_EFF_FLAG;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tif (strlen(optarg) > sizeof(name) - 1) {\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\t/* ensure string termination */\n\t\t\tmemset(name, 0, sizeof(name));\n\t\t\tstrncpy(name, optarg, sizeof(name) - 1);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t{\n\t\t\tint elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t      &opts.ext_address,\n\t\t\t\t\t      &opts.rx_ext_address);\n\n\t\t\tif (elements == 1)\n\t\t\t\topts.flags |= CAN_ISOTP_EXTEND_ADDR;\n\t\t\telse if (elements == 2)\n\t\t\t\topts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"incorrect extended addr values '%s'.\\n\", optarg);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'p':\n\t\t{\n\t\t\tint elements = sscanf(optarg, \"%hhx:%hhx\",\n\t\t\t\t\t      &opts.txpad_content,\n\t\t\t\t\t      &opts.rxpad_content);\n\n\t\t\tif (elements == 1)\n\t\t\t\topts.flags |= CAN_ISOTP_TX_PADDING;\n\t\t\telse if (elements == 2)\n\t\t\t\topts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);\n\t\t\telse if (sscanf(optarg, \":%hhx\", &opts.rxpad_content) == 1)\n\t\t\t\topts.flags |= CAN_ISOTP_RX_PADDING;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"incorrect padding values '%s'.\\n\", optarg);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'P':\n\t\t\tif (optarg[0] == 'l')\n\t\t\t\topts.flags |= CAN_ISOTP_CHK_PAD_LEN;\n\t\t\telse if (optarg[0] == 'c')\n\t\t\t\topts.flags |= CAN_ISOTP_CHK_PAD_DATA;\n\t\t\telse if (optarg[0] == 'a')\n\t\t\t\topts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"unknown padding check option '%c'.\\n\", optarg[0]);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\topts.frame_txtime = strtoul(optarg, NULL, 10);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tfcopts.bs = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\tfcopts.stmin = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\tfcopts.wftmax = strtoul(optarg, NULL, 16) & 0xFF;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\topts.flags |= CAN_ISOTP_HALF_DUPLEX;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tif (sscanf(optarg, \"%hhu:%hhu:%hhu\",\n\t\t\t\t   &llopts.mtu,\n\t\t\t\t   &llopts.tx_dl,\n\t\t\t\t   &llopts.tx_flags) != 3) {\n\t\t\t\tfprintf(stderr, \"unknown link layer options '%s'.\\n\", optarg);\n\t\t\t\tprint_usage(basename(argv[0]));\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\trun_as_daemon = 1;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((argc - optind != 1) ||\n\t    (addr.can_addr.tp.tx_id == NO_CAN_ID) ||\n\t    (addr.can_addr.tp.rx_id == NO_CAN_ID)) {\n\t\tprint_usage(basename(argv[0]));\n\t\texit(EXIT_FAILURE);\n\t}\n  \n\tif (!run_as_daemon)\n\t\tsyslogger = fake_syslog;\n\n\t/* Initialize the logging interface */\n\topenlog(DAEMON_NAME, LOG_PID, LOG_LOCAL5);\n\n\tif ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {\n\t\tperror_syslog(\"socket\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsetsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));\n\tsetsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RECV_FC, &fcopts, sizeof(fcopts));\n\n\tif (llopts.tx_dl) {\n\t\tif (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {\n\t\t\tperror_syslog(\"link layer sockopt\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = if_nametoindex(argv[optind]);\n\tif (!addr.can_ifindex) {\n\t\tperror_syslog(\"if_nametoindex\");\n\t\tclose(s);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror_syslog(\"bind\");\n\t\tclose(s);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif ((t = open(\"/dev/net/tun\", O_RDWR)) < 0) {\n\t\tperror_syslog(\"open tunfd\");\n\t\tclose(s);\n\t\tclose(t);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_flags = IFF_TUN | IFF_NO_PI;\n\t/* string termination is ensured at commandline option handling */\n\tstrncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\n\n\tif (ioctl(t, TUNSETIFF, (void *) &ifr) < 0) {\n\t\tperror_syslog(\"ioctl tunfd\");\n\t\tclose(s);\n\t\tclose(t);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* Now the tun device exists. We can daemonize to let the\n\t * parent continue and use the network interface. */\n\tif (run_as_daemon) {\n\t\tif (daemon(0, 0)) {\n\t\t\tsyslogger(LOG_ERR, \"failed to daemonize\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tsignal(SIGTERM, sigterm);\n\tsignal(SIGHUP, sigterm);\n\tsignal(SIGINT, sigterm);\n\n\twhile (running) {\n\n\t\tFD_ZERO(&rdfs);\n\t\tFD_SET(s, &rdfs);\n\t\tFD_SET(t, &rdfs);\n\n\t\tif ((ret = select(t+1, &rdfs, NULL, NULL, NULL)) < 0) {\n\t\t\tperror_syslog(\"select\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FD_ISSET(s, &rdfs)) {\n\t\t\tnbytes = read(s, buffer, BUF_LEN);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tperror_syslog(\"read isotp socket\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (nbytes > MAX_PDU_LENGTH)\n\t\t\t\treturn -1;\n\t\t\tret = write(t, buffer, nbytes);\n\t\t\tif (verbose) {\n\t\t\t\tif (ret < 0 && errno == EAGAIN)\n\t\t\t\t\tprintf(\";\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\",\");\n\t\t\t\tfflush(stdout);\n\t\t\t}\n\t\t}\n\n\t\tif (FD_ISSET(t, &rdfs)) {\n\t\t\tnbytes = read(t, buffer, BUF_LEN);\n\t\t\tif (nbytes < 0) {\n\t\t\t\tperror_syslog(\"read tunfd\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (nbytes > MAX_PDU_LENGTH)\n\t\t\t\treturn -1;\n\t\t\tret = write(s, buffer, nbytes);\n\t\t\tif (verbose) {\n\t\t\t\tif (ret < 0 && errno == EAGAIN)\n\t\t\t\t\tprintf(\":\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\".\");\n\t\t\t\tfflush(stdout);\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(s);\n\tclose(t);\n\n\tif (signal_num)\n\t\treturn 128 + signal_num;\n\n\treturn EXIT_SUCCESS;\n}\n"
        },
        {
          "name": "j1939_timedate",
          "type": "tree",
          "content": null
        },
        {
          "name": "j1939acd.c",
          "type": "blob",
          "size": 13.9921875,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (c) 2011 EIA Electronics\n *\n * Authors:\n * Kurt Van Dijck <kurt.van.dijck@eia.be>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n */\n\n#include <errno.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <err.h>\n#include <getopt.h>\n#include <linux/can.h>\n#include <linux/can/j1939.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#include \"libj1939.h\"\n\nstatic const char help_msg[] =\n\t\"j1939acd: An SAE J1939 address claiming daemon\" \"\\n\"\n\t\"Usage: j1939acd [options] NAME [INTF]\" \"\\n\"\n\t\"Options:\\n\"\n\t\"  -v, --verbose\t\tIncrease verbosity\" \"\\n\"\n\t\"  -r, --range=RANGE\tRanges of source addresses\" \"\\n\"\n\t\"\t\t\te.g. 80,50-100,200-210 (defaults to 0-253)\" \"\\n\"\n\t\"  -c, --cache=FILE\tCache file to save/restore the source address\" \"\\n\"\n\t\"  -a, --address=ADDRESS\tStart with Source Address ADDRESS\" \"\\n\"\n\t\"\\n\"\n\t\"NAME is the 64bit nodename\" \"\\n\"\n\t\"\\n\"\n\t\"Examples:\" \"\\n\"\n\t\"j1939acd -r 100,80-120 -c /tmp/1122334455667788.jacd 1122334455667788\" \"\\n\"\n\t\"j1939acd -r 100,80-120 -c /tmp/1122334455667788.jacd 1122334455667788 vcan0\" \"\\n\"\n\t;\n\n#ifdef _GNU_SOURCE\nstatic struct option long_opts[] = {\n\t{ \"help\", no_argument, NULL, '?', },\n\t{ \"verbose\", no_argument, NULL, 'v', },\n\t{ \"range\", required_argument, NULL, 'r', },\n\t{ \"cache\", required_argument, NULL, 'c', },\n\t{ \"address\", required_argument, NULL, 'a', },\n\t{ },\n};\n#else\n#define getopt_long(argc, argv, optstring, longopts, longindex) \\\n\tgetopt((argc), (argv), (optstring))\n#endif\nstatic const char optstring[] = \"vr:c:a:?\";\n\n/* byte swap functions */\nstatic inline int host_is_little_endian(void)\n{\n\tstatic const uint16_t endian_test = 1;\n\treturn *(const uint8_t *)&endian_test;\n}\n\nstatic __attribute__((unused)) void bswap(void *vptr, int size)\n{\n\tuint8_t *p0, *pe;\n\tuint8_t tmp;\n\n\tp0 = vptr;\n\tpe = &p0[size-1];\n\tfor (; p0 < pe; ++p0, --pe) {\n\t\ttmp = *p0;\n\t\t*p0 = *pe;\n\t\t*pe = tmp;\n\t}\n}\n\n/* rate-limiting for errors */\nstatic inline int must_warn(int ret)\n{\n\tif (ret >= 0)\n\t\treturn 0;\n\tswitch (errno) {\n\tcase EINTR:\n\tcase ENOBUFS:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* global variables */\nstatic char default_range[] = \"0x80-0xfd\";\nstatic const char default_intf[] = \"can0\";\n\nstatic struct {\n\tint verbose;\n\tconst char *cachefile;\n\n\tconst char *intf;\n\tchar *ranges;\n\tuint64_t name;\n\tuint8_t current_sa;\n\tuint8_t last_sa;\n\tvolatile sig_atomic_t signal_num;\n\tint sig_alrm;\n\tint sig_usr1;\n\tint state;\n\t\t#define STATE_INITIAL 0\n\t\t#define STATE_REQ_SENT 1\n\t\t#define STATE_REQ_PENDING 2 /* wait 1250 msec for first claim */\n\t\t#define STATE_OPERATIONAL 3\n} s = {\n\t.intf = default_intf,\n\t.ranges = default_range,\n\t.current_sa = J1939_IDLE_ADDR,\n\t.last_sa = J1939_NO_ADDR,\n};\n\nstruct {\n\tuint64_t name;\n\tint flags;\n\t\t#define F_USE\t0x01\n\t\t#define F_SEEN\t0x02\n} addr[J1939_IDLE_ADDR /* =254 */];\n\n/* lookup by name */\nstatic int lookup_name(uint64_t name)\n{\n\tint j;\n\n\tfor (j = 0; j < J1939_IDLE_ADDR; ++j) {\n\t\tif (addr[j].name == name)\n\t\t\treturn j;\n\t}\n\treturn J1939_IDLE_ADDR;\n\n}\n\n/* parse address range */\nstatic int parse_range(char *str)\n{\n\tchar *tok, *endp;\n\tint a0, ae;\n\tint j, cnt;\n\n\tcnt = 0;\n\tfor (tok = strtok(str, \",;\"); tok; tok = strtok(NULL, \",;\")) {\n\t\ta0 = ae = strtoul(tok, &endp, 0);\n\t\tif (endp <= tok)\n\t\t\terr(1, \"parsing range '%s'\", tok);\n\t\tif (*endp == '-') {\n\t\t\ttok = endp+1;\n\t\t\tae = strtoul(tok, &endp, 0);\n\t\t\tif (endp <= tok)\n\t\t\t\terr(1, \"parsing addr '%s'\", tok);\n\t\t\tif (ae < a0)\n\t\t\t\tae = a0;\n\t\t}\n\t\tfor (j = a0; j <= ae; ++j, ++cnt) {\n\t\t\tif (j == J1939_IDLE_ADDR)\n\t\t\t\tbreak;\n\t\t\taddr[j].flags |= F_USE;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n/* j1939 socket */\nstatic const struct j1939_filter filt[] = {\n\t{\n\t\t.pgn = J1939_PGN_ADDRESS_CLAIMED,\n\t\t.pgn_mask = J1939_PGN_PDU1_MAX,\n\t}, {\n\t\t.pgn = J1939_PGN_REQUEST,\n\t\t.pgn_mask = J1939_PGN_PDU1_MAX,\n\t}, {\n\t\t.pgn = J1939_PGN_ADDRESS_COMMANDED,\n\t\t.pgn_mask = J1939_PGN_MAX,\n\t},\n};\n\nstatic int open_socket(const char *device, uint64_t name)\n{\n\tint ret, sock;\n\tint value;\n\tstruct sockaddr_can saddr = {\n\t\t.can_family = AF_CAN,\n\t\t.can_addr.j1939 = {\n\t\t\t.name = name,\n\t\t\t.addr = J1939_IDLE_ADDR,\n\t\t\t.pgn = J1939_NO_PGN,\n\t\t},\n\t\t.can_ifindex = if_nametoindex(device),\n\t};\n\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\\n\");\n\tsock = ret = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n\tif (ret < 0)\n\t\terr(1, \"socket(j1939)\");\n\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- setsockopt(, SOL_CAN_J1939, SO_J1939_FILTER, <filter>, %zd);\\n\", sizeof(filt));\n\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_FILTER,\n\t\t\t&filt, sizeof(filt));\n\tif (ret < 0)\n\t\terr(1, \"setsockopt filter\");\n\n\tvalue = 1;\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- setsockopt(, SOL_SOCKET, SO_BROADCAST, %d, %zd);\\n\", value, sizeof(value));\n\tret = setsockopt(sock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t&value, sizeof(value));\n\tif (ret < 0)\n\t\terr(1, \"setsockopt set broadcast\");\n\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- bind(, %s, %zi);\\n\", libj1939_addr2str(&saddr), sizeof(saddr));\n\tret = bind(sock, (void *)&saddr, sizeof(saddr));\n\tif (ret < 0)\n\t\terr(1, \"bind()\");\n\treturn sock;\n}\n\n/* real IO function */\nstatic int repeat_address(int sock, uint64_t name)\n{\n\tint ret;\n\tuint8_t dat[8];\n\tstatic const struct sockaddr_can saddr = {\n\t\t.can_family = AF_CAN,\n\t\t.can_addr.j1939 = {\n\t\t\t.pgn = J1939_PGN_ADDRESS_CLAIMED,\n\t\t\t.addr = J1939_NO_ADDR,\n\t\t},\n\t};\n\n\tmemcpy(dat, &name, 8);\n\tif (!host_is_little_endian())\n\t\tbswap(dat, 8);\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- send(, %\" PRId64 \", 8, 0);\\n\", name);\n\tret = sendto(sock, dat, sizeof(dat), 0, (const struct sockaddr *)&saddr,\n\t\t     sizeof(saddr));\n\tif (must_warn(ret))\n\t\tfprintf(stderr, \"send address claim for 0x%02x\\n\", s.last_sa);\n\treturn ret;\n}\nstatic int claim_address(int sock, uint64_t name, int sa)\n{\n\tint ret;\n\tstruct sockaddr_can saddr = {\n\t\t.can_family = AF_CAN,\n\t\t.can_addr.j1939 = {\n\t\t\t.name = name,\n\t\t\t.addr = sa,\n\t\t\t.pgn = J1939_NO_PGN,\n\t\t},\n\t\t.can_ifindex = if_nametoindex(s.intf),\n\t};\n\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- bind(, %s, %zi);\\n\", libj1939_addr2str(&saddr), sizeof(saddr));\n\tret = bind(sock, (void *)&saddr, sizeof(saddr));\n\tif (ret < 0)\n\t\terr(1, \"rebind with sa 0x%02x\", sa);\n\ts.last_sa = sa;\n\treturn repeat_address(sock, name);\n}\n\nstatic int request_addresses(int sock)\n{\n\tstatic const uint8_t dat[3] = { 0, 0xee, 0, };\n\tint ret;\n\tstatic const struct sockaddr_can saddr = {\n\t\t.can_family = AF_CAN,\n\t\t.can_addr.j1939.pgn = J1939_PGN_REQUEST,\n\t\t.can_addr.j1939.addr = J1939_NO_ADDR,\n\t};\n\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- sendto(, { 0, 0xee, 0, }, %zi, 0, %s, %zi);\\n\", sizeof(dat), libj1939_addr2str(&saddr), sizeof(saddr));\n\tret = sendto(sock, dat, sizeof(dat), 0, (void *)&saddr, sizeof(saddr));\n\tif (must_warn(ret))\n\t\tfprintf(stdout, \"send request for address claims\");\n\treturn ret;\n}\n\n/* real policy */\nstatic int choose_new_sa(uint64_t name, int sa)\n{\n\tint j, cnt;\n\n\t/* test current entry */\n\tif ((sa < J1939_IDLE_ADDR) && (addr[sa].flags & F_USE)) {\n\t\tj = sa;\n\t\tif (!addr[j].name || (addr[j].name == name) || (addr[j].name > name))\n\t\t\treturn j;\n\t}\n\t/* take first empty spot */\n\tfor (j = 0; j < J1939_IDLE_ADDR; ++j) {\n\t\tif (!(addr[j].flags & F_USE))\n\t\t\tcontinue;\n\t\tif (!addr[j].name || (addr[j].name == name))\n\t\t\treturn j;\n\t}\n\n\t/*\n\t * no empty spot found\n\t * take next (relative to @sa) spot that we can\n\t * successfully contest\n\t */\n\tj = sa + 1;\n\tfor (cnt = 0; cnt < J1939_IDLE_ADDR; ++j, ++cnt) {\n\t\tif (j >= J1939_IDLE_ADDR)\n\t\t\tj = 0;\n\t\tif (!(addr[j].flags & F_USE))\n\t\t\tcontinue;\n\t\tif (name < addr[j].name)\n\t\t\treturn j;\n\t}\n\treturn J1939_IDLE_ADDR;\n}\n\n/* signa handling */\nstatic void sighandler(int sig, siginfo_t *info, void *vp)\n{\n\tswitch (sig) {\n\tcase SIGINT:\n\tcase SIGTERM:\n\t\ts.signal_num = sig;\n\t\tbreak;\n\tcase SIGALRM:\n\t\ts.sig_alrm = 1;\n\t\tbreak;\n\tcase SIGUSR1:\n\t\ts.sig_usr1 = 1;\n\t\tbreak;\n\t}\n}\n\nstatic void install_signal(int sig)\n{\n\tint ret;\n\tstruct sigaction sigact = {\n\t\t.sa_sigaction = sighandler,\n\t\t.sa_flags = SA_SIGINFO,\n\t};\n\n\tsigfillset(&sigact.sa_mask);\n\tret = sigaction(sig, &sigact, NULL);\n\tif (ret < 0)\n\t\terr(1, \"sigaction for signal %i\", sig);\n}\n\nstatic void schedule_itimer(int msec)\n{\n\tint ret;\n\tstruct itimerval val = { 0 };\n\n\tval.it_value.tv_sec = msec / 1000;\n\tval.it_value.tv_usec = (msec % 1000) * 1000;\n\n\ts.sig_alrm = 0;\n\tdo {\n\t\tret = setitimer(ITIMER_REAL, &val, NULL);\n\t} while ((ret < 0) && (errno == EINTR));\n\tif (ret < 0)\n\t\terr(1, \"setitimer %i msec\", msec);\n}\n\n/* dump status */\nstatic inline int addr_status_mine(int sa)\n{\n\tif (sa == s.current_sa)\n\t\treturn '*';\n\tif (addr[sa].flags & F_USE)\n\t\treturn '+';\n\treturn '-';\n}\n\nstatic void dump_status(void)\n{\n\tint j;\n\n\tfor (j = 0; j < J1939_IDLE_ADDR; ++j) {\n\t\tif (!addr[j].flags && !addr[j].name)\n\t\t\tcontinue;\n\t\tfprintf(stdout, \"%02x: %c\", j, addr_status_mine(j));\n\t\tif (addr[j].name)\n\t\t\tfprintf(stdout, \" %016llx\", (long long)addr[j].name);\n\t\telse\n\t\t\tfprintf(stdout, \" -\");\n\t\tfprintf(stdout, \"\\n\");\n\t}\n\tfflush(stdout);\n}\n\n/* cache file */\nstatic void save_cache(void)\n{\n\tFILE *fp;\n\ttime_t t;\n\n\tif (!s.cachefile)\n\t\treturn;\n\tfp = fopen(s.cachefile, \"w\");\n\tif (!fp)\n\t\terr(1, \"fopen %s, w\", s.cachefile);\n\n\ttime(&t);\n\tfprintf(fp, \"# saved on %s\\n\", ctime(&t));\n\tfprintf(fp, \"\\n\");\n\tfprintf(fp, \"0x%02x\\n\", s.current_sa);\n\tfclose(fp);\n}\n\nstatic void restore_cache(void)\n{\n\tFILE *fp;\n\tint ret;\n\tchar *endp;\n\tchar *line = 0;\n\tsize_t sz = 0;\n\n\tif (!s.cachefile)\n\t\treturn;\n\tfp = fopen(s.cachefile, \"r\");\n\tif (!fp) {\n\t\tif (ENOENT == errno)\n\t\t\treturn;\n\t\terr(1, \"fopen %s, r\", s.cachefile);\n\t}\n\twhile (!feof(fp)) {\n\t\tret = getline(&line, &sz, fp);\n\t\tif (ret <= 0)\n\t\t\tcontinue;\n\t\tif (line[0] == '#')\n\t\t\tcontinue;\n\t\tret = strtoul(line, &endp, 0);\n\t\tif ((endp > line) && (ret >= 0) && (ret <= J1939_IDLE_ADDR)) {\n\t\t\ts.current_sa = ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\tif (line)\n\t\tfree(line);\n}\n\n/* main */\nint main(int argc, char *argv[])\n{\n\tint ret, sock, sock_rx, pgn, sa, opt;\n\tsocklen_t slen;\n\tuint8_t dat[9];\n\tstruct sockaddr_can saddr;\n\tuint64_t cmd_name;\n\n\t/* argument parsing */\n\twhile ((opt = getopt_long(argc, argv, optstring, long_opts, NULL)) != -1)\n\t\tswitch (opt) {\n\t\tcase 'v':\n\t\t\t++s.verbose;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\ts.cachefile = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\ts.ranges = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\ts.current_sa = strtoul(optarg, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfputs(help_msg, stderr);\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\n\tif (argv[optind])\n\t\ts.name = strtoull(argv[optind++], 0, 16);\n\tif (argv[optind])\n\t\ts.intf = argv[optind++];\n\n\t/* args done */\n\n\trestore_cache();\n\n\tret = parse_range(s.ranges);\n\tif (!ret)\n\t\terr(1, \"no addresses in range\");\n\n\tif ((s.current_sa < J1939_IDLE_ADDR) && !(addr[s.current_sa].flags & F_USE)) {\n\t\tif (s.verbose)\n\t\t\tfprintf(stderr, \"- forget saved address 0x%02x\\n\", s.current_sa);\n\t\ts.current_sa = J1939_IDLE_ADDR;\n\t}\n\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- ready for %s:%016llx\\n\", s.intf, (long long)s.name);\n\tif (!s.intf || !s.name)\n\t\terr(1, \"bad arguments\");\n\tret = sock = open_socket(s.intf, s.name);\n\tsock_rx = open_socket(s.intf, s.name);\n\n\tinstall_signal(SIGTERM);\n\tinstall_signal(SIGINT);\n\tinstall_signal(SIGALRM);\n\tinstall_signal(SIGUSR1);\n\tinstall_signal(SIGUSR2);\n\n\twhile (!s.signal_num) {\n\t\tif (s.sig_usr1) {\n\t\t\ts.sig_usr1 = 0;\n\t\t\tdump_status();\n\t\t}\n\t\tswitch (s.state) {\n\t\tcase STATE_INITIAL:\n\t\t\tret = request_addresses(sock);\n\t\t\tif (ret < 0)\n\t\t\t\terr(1, \"could not sent initial request\");\n\t\t\ts.state = STATE_REQ_SENT;\n\t\t\tbreak;\n\t\tcase STATE_REQ_PENDING:\n\t\t\tif (!s.sig_alrm)\n\t\t\t\tbreak;\n\t\t\ts.sig_alrm = 0;\n\t\t\t/* claim addr */\n\t\t\tsa = choose_new_sa(s.name, s.current_sa);\n\t\t\tif (sa == J1939_IDLE_ADDR)\n\t\t\t\terr(1, \"no free address to use\");\n\t\t\tret = claim_address(sock, s.name, sa);\n\t\t\tif (ret < 0)\n\t\t\t\tschedule_itimer(50);\n\t\t\ts.state = STATE_OPERATIONAL;\n\t\t\tbreak;\n\t\tcase STATE_OPERATIONAL:\n\t\t\tif (s.sig_alrm) {\n\t\t\t\ts.sig_alrm = 0;\n\t\t\t\tret = repeat_address(sock, s.name);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tschedule_itimer(50);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tslen = sizeof(saddr);\n\t\tret = recvfrom(sock_rx, dat, sizeof(dat), 0, (void *)&saddr, &slen);\n\t\tif (ret < 0) {\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue;\n\t\t\terr(1, \"recvfrom()\");\n\t\t}\n\t\tswitch (saddr.can_addr.j1939.pgn) {\n\t\tcase J1939_PGN_REQUEST:\n\t\t\tif (ret < 3)\n\t\t\t\tbreak;\n\t\t\tpgn = dat[0] + (dat[1] << 8) + ((dat[2] & 0x03) << 16);\n\t\t\tif (pgn != J1939_PGN_ADDRESS_CLAIMED)\n\t\t\t\t/* not interested */\n\t\t\t\tbreak;\n\t\t\tif (s.state == STATE_REQ_SENT) {\n\t\t\t\tif (s.verbose)\n\t\t\t\t\tfprintf(stderr, \"- request sent, pending for 1250 ms\\n\");\n\t\t\t\tschedule_itimer(1250);\n\t\t\t\ts.state = STATE_REQ_PENDING;\n\t\t\t} else if (s.state == STATE_OPERATIONAL) {\n\t\t\t\tret = claim_address(sock, s.name, s.current_sa);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tschedule_itimer(50);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase J1939_PGN_ADDRESS_CLAIMED:\n\t\t\tif (saddr.can_addr.j1939.addr >= J1939_IDLE_ADDR) {\n\t\t\t\tsa = lookup_name(saddr.can_addr.j1939.name);\n\t\t\t\tif (sa < J1939_IDLE_ADDR)\n\t\t\t\t\taddr[sa].name = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsa = lookup_name(saddr.can_addr.j1939.name);\n\t\t\tif ((sa != saddr.can_addr.j1939.addr) && (sa < J1939_IDLE_ADDR))\n\t\t\t\t/* update cache */\n\t\t\t\taddr[sa].name = 0;\n\n\t\t\t/* shortcut */\n\t\t\tsa = saddr.can_addr.j1939.addr;\n\t\t\taddr[sa].name = saddr.can_addr.j1939.name;\n\t\t\taddr[sa].flags |= F_SEEN;\n\n\t\t\tif (s.name == saddr.can_addr.j1939.name) {\n\t\t\t\t/* ourselves, disable itimer */\n\t\t\t\ts.current_sa = sa;\n\t\t\t\tif (s.verbose)\n\t\t\t\t\tfprintf(stderr, \"- claimed 0x%02x\\n\", sa);\n\t\t\t} else if (sa == s.current_sa) {\n\t\t\t\tif (s.verbose)\n\t\t\t\t\tfprintf(stderr, \"- address collision for 0x%02x\\n\", sa);\n\t\t\t\tif (s.name > saddr.can_addr.j1939.name) {\n\t\t\t\t\tsa = choose_new_sa(s.name, sa);\n\t\t\t\t\tif (sa == J1939_IDLE_ADDR) {\n\t\t\t\t\t\tfprintf(stdout, \"no address left\");\n\t\t\t\t\t\t/* put J1939_IDLE_ADDR in cache file */\n\t\t\t\t\t\ts.current_sa = sa;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret = claim_address(sock, s.name, sa);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tschedule_itimer(50);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase J1939_PGN_ADDRESS_COMMANDED:\n\t\t\tif (!host_is_little_endian())\n\t\t\t\tbswap(dat, 8);\n\t\t\tmemcpy(&cmd_name, dat, 8);\n\t\t\tif (cmd_name == s.name) {\n\t\t\t\tret = claim_address(sock, s.name, dat[8]);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tschedule_itimer(50);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tif (s.verbose)\n\t\tfprintf(stderr, \"- shutdown\\n\");\n\tclaim_address(sock, s.name, J1939_IDLE_ADDR);\n\tsave_cache();\n\n\tif (s.signal_num)\n\t\treturn 128 + s.signal_num;\n\n\treturn 0;\n}\n"
        },
        {
          "name": "j1939cat.c",
          "type": "blob",
          "size": 17.6904296875,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (c) 2018 Pengutronix, Oleksij Rempel <o.rempel@pengutronix.de>\n */\n\n#include <err.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <net/if.h>\n#include <poll.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <linux/errqueue.h>\n#include <linux/net_tstamp.h>\n#include <linux/netlink.h>\n#include <linux/socket.h>\n\n#include \"libj1939.h\"\n\n#define J1939_MAX_ETP_PACKET_SIZE (7 * 0x00ffffff)\n#define JCAT_BUF_SIZE (1000 * 1024)\n\n/*\n * min()/max()/clamp() macros that also do\n * strict type-checking.. See the\n * \"unnecessary\" pointer comparison.\n */\n#define min(x, y) ({\t\t\t\t\\\n\ttypeof(x) _min1 = (x);\t\t\t\\\n\ttypeof(y) _min2 = (y);\t\t\t\\\n\t(void) (&_min1 == &_min2);\t\t\\\n\t_min1 < _min2 ? _min1 : _min2; })\n\n\nstruct j1939cat_stats {\n\tint err;\n\tuint32_t tskey;\n\tuint32_t send;\n\tuint32_t total;\n\tuint32_t pgn;\n\tuint8_t sa;\n\tuint8_t da;\n\tuint64_t src_name;\n\tuint64_t dst_name;\n};\n\nstruct j1939cat_priv {\n\tint sock;\n\tint infile;\n\tint outfile;\n\tsize_t max_transfer;\n\tunsigned long repeat;\n\tunsigned long round;\n\tint todo_prio;\n\n\tbool valid_peername;\n\tbool todo_recv;\n\tbool todo_filesize;\n\tbool todo_connect;\n\tint todo_broadcast;\n\n\tunsigned long polltimeout;\n\n\tstruct sockaddr_can sockname;\n\tstruct sockaddr_can peername;\n\n\tstruct sock_extended_err *serr;\n\tstruct scm_timestamping *tss;\n\tstruct j1939cat_stats stats;\n\tint32_t last_dpo;\n};\n\nstatic const char help_msg[] =\n\t\"j1939cat: netcat-like tool for j1939\\n\"\n\t\"Usage: j1939cat [options] FROM TO\\n\"\n\t\" FROM / TO\t- or [IFACE][:[SA][,[PGN][,NAME]]]\\n\"\n\t\"Options:\\n\"\n\t\" -i <infile>\t(default stdin)\\n\"\n\t\" -s <size>\tSet maximal transfer size. Default: 117440505 byte\\n\"\n\t\" -r\t\tReceive data\\n\"\n\t\" -P <timeout>  poll timeout in milliseconds before sending data.\\n\"\n\t\"\t\tWith this option send() will be used with MSG_DONTWAIT flag.\\n\"\n\t\" -R <count>\tSet send repeat count. Default: 1\\n\"\n\t\" -B\t\tAllow to send and receive broadcast packets.\\n\"\n\t\"\\n\"\n\t\"Example:\\n\"\n\t\"j1939cat -i some_file_to_send  can0:0x80 :0x90,0x12300\\n\"\n\t\"j1939cat can0:0x90 -r > /tmp/some_file_to_receive\\n\"\n\t\"\\n\"\n\t;\n\nstatic const char optstring[] = \"?hi:vs:rp:P:R:B\";\n\nstatic ssize_t j1939cat_send_one(struct j1939cat_priv *priv, int out_fd,\n\t\t\t     const void *buf, size_t buf_size)\n{\n\tssize_t num_sent;\n\tint flags = 0;\n\n\tif (priv->polltimeout)\n\t\tflags |= MSG_DONTWAIT;\n\n\tif (priv->valid_peername && !priv->todo_connect)\n\t\tnum_sent = sendto(out_fd, buf, buf_size, flags,\n\t\t\t\t  (struct sockaddr *)&priv->peername,\n\t\t\t\t  sizeof(priv->peername));\n\telse\n\t\tnum_sent = send(out_fd, buf, buf_size, flags);\n\n\tif (num_sent == -1) {\n\t\twarn(\"%s: transfer error: %i\", __func__, -errno);\n\t\treturn -errno;\n\t}\n\n\tif (num_sent == 0) /* Should never happen */ {\n\t\twarn(\"%s: transferred 0 bytes\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_sent > (ssize_t)buf_size) /* Should never happen */ {\n\t\twarn(\"%s: send more then read\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn num_sent;\n}\n\nstatic void j1939cat_print_timestamp(struct j1939cat_priv *priv, const char *name,\n\t\t\t      struct timespec *cur)\n{\n\tstruct j1939cat_stats *stats = &priv->stats;\n\n\tif (!(cur->tv_sec | cur->tv_nsec))\n\t\treturn;\n\n\tfprintf(stderr, \"  %s: %llu s %llu us (seq=%03u, send=%07u)\",\n\t\t\tname, (unsigned long long)cur->tv_sec, (unsigned long long)cur->tv_nsec / 1000,\n\t\t\tstats->tskey, stats->send);\n\n\tfprintf(stderr, \"\\n\");\n}\n\nstatic const char *j1939cat_tstype_to_str(int tstype)\n{\n\tswitch (tstype) {\n\tcase SCM_TSTAMP_SCHED:\n\t\treturn \"TX ENQ\";\n\tcase SCM_TSTAMP_SND:\n\t\treturn \"TX SND\";\n\tcase SCM_TSTAMP_ACK:\n\t\treturn \"TX ACK\";\n\tdefault:\n\t\treturn \"   unk\";\n\t}\n}\n\n/* Check the stats of SCM_TIMESTAMPING_OPT_STATS */\nstatic void j1939cat_scm_opt_stats(struct j1939cat_priv *priv, void *buf, int len)\n{\n\tstruct j1939cat_stats *stats = &priv->stats;\n\tint offset = 0;\n\n\twhile (offset < len) {\n\t\tstruct nlattr *nla = (struct nlattr *) ((char *)buf + offset);\n\n\t\tswitch (nla->nla_type) {\n\t\tcase J1939_NLA_BYTES_ACKED:\n\t\t\tstats->send = *(uint32_t *)((char *)nla + NLA_HDRLEN);\n\t\t\tbreak;\n\t\tcase J1939_NLA_TOTAL_SIZE:\n\t\t\tstats->total = *(uint32_t *)((char *)nla + NLA_HDRLEN);\n\t\t\tbreak;\n\t\tcase J1939_NLA_PGN:\n\t\t\tstats->pgn = *(uint32_t *)((char *)nla + NLA_HDRLEN);\n\t\t\tbreak;\n\t\tcase J1939_NLA_DEST_ADDR:\n\t\t\tstats->da = *(uint8_t *)((char *)nla + NLA_HDRLEN);\n\t\t\tbreak;\n\t\tcase J1939_NLA_SRC_ADDR:\n\t\t\tstats->sa = *(uint8_t *)((char *)nla + NLA_HDRLEN);\n\t\t\tbreak;\n\t\tcase J1939_NLA_DEST_NAME:\n\t\t\tstats->dst_name = *(uint64_t *)((char *)nla + NLA_HDRLEN);\n\t\t\tbreak;\n\t\tcase J1939_NLA_SRC_NAME:\n\t\t\tstats->src_name = *(uint64_t *)((char *)nla + NLA_HDRLEN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twarnx(\"not supported J1939_NLA field\\n\");\n\t\t}\n\n\t\toffset += NLA_ALIGN(nla->nla_len);\n\t}\n}\n\nstatic int j1939cat_extract_serr(struct j1939cat_priv *priv)\n{\n\tstruct j1939cat_stats *stats = &priv->stats;\n\tstruct sock_extended_err *serr = priv->serr;\n\tstruct scm_timestamping *tss = priv->tss;\n\n\tswitch (serr->ee_origin) {\n\tcase SO_EE_ORIGIN_TIMESTAMPING:\n\t\t/*\n\t\t * We expect here following patterns:\n\t\t *   serr->ee_info == SCM_TSTAMP_ACK\n\t\t *     Activated with SOF_TIMESTAMPING_TX_ACK\n\t\t * or\n\t\t *   serr->ee_info == SCM_TSTAMP_SCHED\n\t\t *     Activated with SOF_TIMESTAMPING_SCHED\n\t\t * and\n\t\t *   serr->ee_data == tskey\n\t\t *     session message counter which is activate\n\t\t *     with SOF_TIMESTAMPING_OPT_ID\n\t\t * the serr->ee_errno should be ENOMSG\n\t\t */\n\t\tif (serr->ee_errno != ENOMSG)\n\t\t\twarnx(\"serr: expected ENOMSG, got: %i\",\n\t\t\t      serr->ee_errno);\n\t\tstats->tskey = serr->ee_data;\n\n\t\tj1939cat_print_timestamp(priv, j1939cat_tstype_to_str(serr->ee_info),\n\t\t\t\t     &tss->ts[0]);\n\n\t\tif (serr->ee_info == SCM_TSTAMP_SCHED)\n\t\t\treturn -EINTR;\n\t\treturn 0;\n\tcase SO_EE_ORIGIN_LOCAL:\n\t\t/*\n\t\t * The serr->ee_origin == SO_EE_ORIGIN_LOCAL is\n\t\t * currently used to notify about locally\n\t\t * detected protocol/stack errors.\n\t\t * Following patterns are expected:\n\t\t *   serr->ee_info == J1939_EE_INFO_TX_ABORT\n\t\t *     is used to notify about session TX\n\t\t *     abort.\n\t\t *   serr->ee_data == tskey\n\t\t *     session message counter which is activate\n\t\t *     with SOF_TIMESTAMPING_OPT_ID\n\t\t *   serr->ee_errno == actual error reason\n\t\t *     error reason is converted from J1939\n\t\t *     abort to linux error name space.\n\t\t */\n\t\tswitch (serr->ee_info) {\n\t\tcase J1939_EE_INFO_TX_ABORT:\n\t\t\tj1939cat_print_timestamp(priv, \"TX ABT\", &tss->ts[0]);\n\t\t\twarnx(\"serr: tx error: %i, %s\", serr->ee_errno,\n\t\t\t      strerror(serr->ee_errno));\n\t\t\treturn serr->ee_errno;\n\t\tcase J1939_EE_INFO_RX_RTS:\n\t\t\tstats->tskey = serr->ee_data;\n\t\t\tj1939cat_print_timestamp(priv, \"RX RTS\", &tss->ts[0]);\n\t\t\tfprintf(stderr, \"  total size: %u, pgn=0x%05x, sa=0x%02x, da=0x%02x src_name=0x%08\" PRIx64 \", dst_name=0x%08\" PRIx64 \")\\n\",\n\t\t\t\tstats->total, stats->pgn,  stats->sa, stats->da,\n\t\t\t\tstats->src_name, stats->dst_name);\n\t\t\tpriv->last_dpo = -1;\n\t\t\treturn 0;\n\t\tcase J1939_EE_INFO_RX_DPO:\n\t\t\tstats->tskey = serr->ee_data;\n\t\t\tj1939cat_print_timestamp(priv, \"RX DPO\", &tss->ts[0]);\n\t\t\tif (stats->send <= (uint32_t)priv->last_dpo && priv->last_dpo != -1)\n\t\t\t\twarnx(\"same dpo? current: %i, last: %i\",\n\t\t\t\t      stats->send, priv->last_dpo);\n\t\t\tpriv->last_dpo = stats->send;\n\t\t\treturn 0;\n\t\tcase J1939_EE_INFO_RX_ABORT:\n\t\t\tj1939cat_print_timestamp(priv, \"RX ABT\", &tss->ts[0]);\n\t\t\twarnx(\"serr: rx error: %i, %s\", serr->ee_errno,\n\t\t\t      strerror(serr->ee_errno));\n\t\t\treturn serr->ee_errno;\n\t\tdefault:\n\t\t\twarnx(\"serr: unknown ee_info: %i\", serr->ee_info);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\twarnx(\"serr: wrong origin: %u\", serr->ee_origin);\n\t}\n\n\treturn 0;\n}\n\nstatic int j1939cat_parse_cm(struct j1939cat_priv *priv, struct cmsghdr *cm)\n{\n\tconst size_t hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));\n\n\tif (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_TIMESTAMPING) {\n\t\tpriv->tss = (void *)CMSG_DATA(cm);\n\t} else if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_TIMESTAMPING_OPT_STATS) {\n\t\tvoid *jstats = (void *)CMSG_DATA(cm);\n\n\t\t/* Activated with SOF_TIMESTAMPING_OPT_STATS */\n\t\tj1939cat_scm_opt_stats(priv, jstats, cm->cmsg_len - hdr_len);\n\t} else if (cm->cmsg_level == SOL_CAN_J1939 &&\n\t\t   cm->cmsg_type == SCM_J1939_ERRQUEUE) {\n\t\tpriv->serr = (void *)CMSG_DATA(cm);\n\t} else\n\t\twarnx(\"serr: not supported type: %d.%d\",\n\t\t      cm->cmsg_level, cm->cmsg_type);\n\n\treturn 0;\n}\n\nstatic int j1939cat_recv_err(struct j1939cat_priv *priv)\n{\n\tchar control[200];\n\tstruct cmsghdr *cm;\n\tint ret;\n\tstruct msghdr msg = {\n\t\t.msg_control = control,\n\t\t.msg_controllen = sizeof(control),\n\t};\n\n\tret = recvmsg(priv->sock, &msg, MSG_ERRQUEUE);\n\tif (ret == -1)\n\t\terr(EXIT_FAILURE, \"recvmsg error notification: %i\", errno);\n\tif (msg.msg_flags & MSG_CTRUNC)\n\t\terr(EXIT_FAILURE, \"recvmsg error notification: truncated\");\n\n\tpriv->serr = NULL;\n\tpriv->tss = NULL;\n\n\tfor (cm = CMSG_FIRSTHDR(&msg); cm && cm->cmsg_len;\n\t     cm = CMSG_NXTHDR(&msg, cm)) {\n\t\tj1939cat_parse_cm(priv, cm);\n\t\tif (priv->serr && priv->tss)\n\t\t\treturn j1939cat_extract_serr(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int j1939cat_send_loop(struct j1939cat_priv *priv, int out_fd, char *buf,\n\t\t\t  size_t buf_size)\n{\n\tstruct j1939cat_stats *stats = &priv->stats;\n\tssize_t count;\n\tchar *tmp_buf = buf;\n\tunsigned int events = POLLOUT | POLLERR;\n\tbool tx_done = false;\n\n\tcount = buf_size;\n\n\twhile (!tx_done) {\n\t\tssize_t num_sent = 0;\n\n\t\tif (priv->polltimeout) {\n\t\t\tstruct pollfd fds = {\n\t\t\t\t.fd = priv->sock,\n\t\t\t\t.events = events,\n\t\t\t};\n\t\t\tint ret;\n\n\t\t\tret = poll(&fds, 1, priv->polltimeout);\n\t\t\tif (ret == -1) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\treturn -errno;\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\treturn -ETIME;\n\t\t\tif (!(fds.revents & events)) {\n\t\t\t\twarn(\"%s: something else is wrong %x %x\", __func__, fds.revents, events);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tif (fds.revents & POLLERR) {\n\t\t\t\tret = j1939cat_recv_err(priv);\n\t\t\t\tif (ret == -EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tif ((priv->repeat - 1) == stats->tskey)\n\t\t\t\t\ttx_done = true;\n\t\t\t}\n\n\t\t\tif (fds.revents & POLLOUT) {\n\t\t\t\tnum_sent = j1939cat_send_one(priv, out_fd, tmp_buf, count);\n\t\t\t\tif (num_sent < 0)\n\t\t\t\t\treturn num_sent;\n\t\t\t}\n\t\t} else {\n\t\t\tnum_sent = j1939cat_send_one(priv, out_fd, tmp_buf, count);\n\t\t\tif (num_sent < 0)\n\t\t\t\treturn num_sent;\n\t\t}\n\n\t\tcount -= num_sent;\n\t\ttmp_buf += num_sent;\n\t\tif (buf + buf_size < tmp_buf + count) {\n\t\t\twarn(\"%s: send buffer is bigger than the read buffer\",\n\t\t\t     __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!count) {\n\t\t\tif (priv->repeat == priv->round)\n\t\t\t\tevents = POLLERR;\n\t\t\telse\n\t\t\t\ttx_done = true;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int j1939cat_sendfile(struct j1939cat_priv *priv, int out_fd, int in_fd,\n\t\t\t off_t *offset, size_t count)\n{\n\tint ret = EXIT_SUCCESS;\n\toff_t orig = 0;\n\tchar *buf;\n\tssize_t num_read;\n\tsize_t to_read, buf_size;\n\n\tbuf_size = min(priv->max_transfer, count);\n\tbuf = malloc(buf_size);\n\tif (!buf) {\n\t\twarn(\"can't allocate buf\");\n\t\tret = EXIT_FAILURE;\n\t\tgoto do_nofree;\n\t}\n\n\tif (offset) {\n\n\t\t/* Save current file offset and set offset to value in '*offset' */\n\n\t\torig = lseek(in_fd, 0, SEEK_CUR);\n\t\tif (orig == -1) {\n\t\t\tret = EXIT_FAILURE;\n\t\t\tgoto do_free;\n\t\t}\n\t\tif (lseek(in_fd, *offset, SEEK_SET) == -1) {\n\t\t\tret = EXIT_FAILURE;\n\t\t\tgoto do_free;\n\t\t}\n\t}\n\n\twhile (count > 0) {\n\t\tto_read = min(buf_size, count);\n\n\t\tnum_read = read(in_fd, buf, to_read);\n\t\tif (num_read == -1) {\n\t\t\tret = EXIT_FAILURE;\n\t\t\tgoto do_free;\n\t\t}\n\t\tif (num_read == 0)\n\t\t\tbreak; /* EOF */\n\n\t\tret = j1939cat_send_loop(priv, out_fd, buf, num_read);\n\t\tif (ret)\n\t\t\tgoto do_free;\n\n\t\tcount -= num_read;\n\t}\n\n\tif (offset) {\n\t\t/* Return updated file offset in '*offset', and reset the file offset\n\t\t   to the value it had when we were called. */\n\n\t\t*offset = lseek(in_fd, 0, SEEK_CUR);\n\t\tif (*offset == -1) {\n\t\t\tret = EXIT_FAILURE;\n\t\t\tgoto do_free;\n\t\t}\n\n\t\tif (lseek(in_fd, orig, SEEK_SET) == -1) {\n\t\t\tret = EXIT_FAILURE;\n\t\t\tgoto do_free;\n\t\t}\n\t}\n\ndo_free:\n\tfree(buf);\ndo_nofree:\n\treturn ret;\n}\n\nstatic size_t j1939cat_get_file_size(int fd)\n{\n\toff_t offset;\n\n\toffset = lseek(fd, 0, SEEK_END);\n\tif (offset == -1)\n\t\terr(1, \"%s lseek()\\n\", __func__);\n\n\tif (lseek(fd, 0, SEEK_SET) == -1)\n\t\terr(1, \"%s lseek() start\\n\", __func__);\n\n\treturn offset;\n}\n\nstatic int j1939cat_send(struct j1939cat_priv *priv)\n{\n\tunsigned int size = 0;\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (priv->todo_filesize)\n\t\tsize = j1939cat_get_file_size(priv->infile);\n\n\tif (!size)\n\t\treturn EXIT_FAILURE;\n\n\tfor (i = 0; i < priv->repeat; i++) {\n\t\tpriv->round++;\n\t\tret = j1939cat_sendfile(priv, priv->sock, priv->infile, NULL, size);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (lseek(priv->infile, 0, SEEK_SET) == -1)\n\t\t\terr(1, \"%s lseek() start\\n\", __func__);\n\t}\n\n\treturn ret;\n}\n\nstatic int j1939cat_recv_one(struct j1939cat_priv *priv, uint8_t *buf, size_t buf_size)\n{\n\tint ret;\n\n\tret = recv(priv->sock, buf, buf_size, 0);\n\tif (ret < 0) {\n\t\twarn(\"recvf()\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tret = write(priv->outfile, buf, ret);\n\tif (ret < 0) {\n\t\twarn(\"write stdout()\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic int j1939cat_recv(struct j1939cat_priv *priv)\n{\n\tunsigned int events = POLLIN | POLLERR;\n\tint ret = EXIT_SUCCESS;\n\tsize_t buf_size;\n\tuint8_t *buf;\n\n\tbuf_size = priv->max_transfer;\n\tbuf = malloc(buf_size);\n\tif (!buf) {\n\t\twarn(\"can't allocate rx buf\");\n\t\treturn EXIT_FAILURE;;\n\t}\n\n\tpriv->last_dpo = -1;\n\n\twhile (priv->todo_recv) {\n\t\tif (priv->polltimeout) {\n\t\t\tstruct pollfd fds = {\n\t\t\t\t.fd = priv->sock,\n\t\t\t\t.events = events,\n\t\t\t};\n\t\t\tint ret;\n\n\t\t\tret = poll(&fds, 1, priv->polltimeout);\n\t\t\tif (ret == -1) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\treturn -errno;\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t\tif (!(fds.revents & events)) {\n\t\t\t\twarn(\"%s: something else is wrong %x %x\", __func__, fds.revents, events);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tif (fds.revents & POLLERR) {\n\t\t\t\tret = j1939cat_recv_err(priv);\n\t\t\t\tif (ret == -EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (fds.revents & POLLIN) {\n\t\t\t\tret = j1939cat_recv_one(priv, buf, buf_size);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = j1939cat_recv_one(priv, buf, buf_size);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(buf);\n\treturn ret;\n}\n\nstatic int j1939cat_sock_prepare(struct j1939cat_priv *priv)\n{\n\tunsigned int sock_opt;\n\tint value;\n\tint ret;\n\n\t/* open socket */\n\tpriv->sock = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n\tif (priv->sock < 0) {\n\t\twarn(\"socket(j1939)\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (priv->todo_prio >= 0) {\n\t\tret = setsockopt(priv->sock, SOL_CAN_J1939, SO_J1939_SEND_PRIO,\n\t\t\t\t&priv->todo_prio, sizeof(priv->todo_prio));\n\t\tif (ret < 0) {\n\t\t\twarn(\"set priority %i\", priv->todo_prio);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\n\tvalue = 1;\n\tret = setsockopt(priv->sock, SOL_CAN_J1939, SO_J1939_ERRQUEUE, &value,\n\t\t\t sizeof(value));\n\tif (ret < 0) {\n\t\twarn(\"set recverr\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tsock_opt = SOF_TIMESTAMPING_SOFTWARE |\n\t\t   SOF_TIMESTAMPING_OPT_CMSG |\n\t\t   SOF_TIMESTAMPING_TX_ACK |\n\t\t   SOF_TIMESTAMPING_TX_SCHED |\n\t\t   SOF_TIMESTAMPING_OPT_STATS | SOF_TIMESTAMPING_OPT_TSONLY |\n\t\t   SOF_TIMESTAMPING_OPT_ID | SOF_TIMESTAMPING_RX_SOFTWARE;\n\n\tif (setsockopt(priv->sock, SOL_SOCKET, SO_TIMESTAMPING,\n\t\t       (char *) &sock_opt, sizeof(sock_opt)))\n\t\terr(1, \"setsockopt timestamping\");\n\n\tif (priv->todo_broadcast) {\n\t\tret = setsockopt(priv->sock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t\t &priv->todo_broadcast,\n\t\t\t\t sizeof(priv->todo_broadcast));\n\t\tif (ret < 0) {\n\t\t\twarn(\"setsockopt: filed to set broadcast\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\n\tret = bind(priv->sock, (void *)&priv->sockname, sizeof(priv->sockname));\n\tif (ret < 0) {\n\t\twarn(\"bind()\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (!priv->todo_connect)\n\t\treturn EXIT_SUCCESS;\n\n\tif (!priv->valid_peername) {\n\t\twarn(\"no peername supplied\");\n\t\treturn EXIT_FAILURE;\n\t}\n\tret = connect(priv->sock, (void *)&priv->peername,\n\t\t      sizeof(priv->peername));\n\tif (ret < 0) {\n\t\twarn(\"connect()\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\nstatic int j1939cat_parse_args(struct j1939cat_priv *priv, int argc, char *argv[])\n{\n\tint opt;\n\n\t/* argument parsing */\n\twhile ((opt = getopt(argc, argv, optstring)) != -1)\n\t\tswitch (opt) {\n\t\tcase 'i':\n\t\t\tpriv->infile = open(optarg, O_RDONLY);\n\t\t\tif (priv->infile == -1)\n\t\t\t\terr(EXIT_FAILURE, \"can't open input file\");\n\t\t\tpriv->todo_filesize = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tpriv->max_transfer = strtoul(optarg, NULL, 0);\n\t\t\tif (priv->max_transfer > J1939_MAX_ETP_PACKET_SIZE)\n\t\t\t\terr(EXIT_FAILURE,\n\t\t\t\t    \"used value (%zu) is bigger then allowed maximal size: %u.\\n\",\n\t\t\t\t    priv->max_transfer,\n\t\t\t\t    J1939_MAX_ETP_PACKET_SIZE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tpriv->todo_recv = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpriv->todo_prio = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tpriv->polltimeout = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tpriv->todo_connect = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tpriv->repeat = strtoul(optarg, NULL, 0);\n\t\t\tif (priv->repeat < 1)\n\t\t\t\terr(EXIT_FAILURE,\n\t\t\t\t    \"send/repeat count can't be less then 1\\n\");\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tpriv->todo_broadcast = 1;\n\t\t\tbreak;\n\t\tcase 'h': /*fallthrough*/\n\t\tdefault:\n\t\t\tfputs(help_msg, stderr);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\tif (argv[optind]) {\n\t\tif (strcmp(\"-\", argv[optind]) != 0)\n\t\t\tlibj1939_parse_canaddr(argv[optind], &priv->sockname);\n\t\toptind++;\n\t}\n\n\tif (argv[optind]) {\n\t\tif (strcmp(\"-\", argv[optind]) != 0) {\n\t\t\tlibj1939_parse_canaddr(argv[optind], &priv->peername);\n\t\t\tpriv->valid_peername = 1;\n\t\t}\n\t\toptind++;\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct j1939cat_priv *priv;\n\tint ret = 0;\n\n\tpriv = calloc(1, sizeof(*priv));\n\tif (!priv)\n\t\terr(EXIT_FAILURE, \"can't allocate priv\");\n\n\tpriv->todo_prio = -1;\n\tpriv->infile = STDIN_FILENO;\n\tpriv->outfile = STDOUT_FILENO;\n\tpriv->max_transfer = J1939_MAX_ETP_PACKET_SIZE;\n\tpriv->polltimeout = 100000;\n\tpriv->repeat = 1;\n\n\tlibj1939_init_sockaddr_can(&priv->sockname, J1939_NO_PGN);\n\tlibj1939_init_sockaddr_can(&priv->peername, J1939_NO_PGN);\n\n\tret = j1939cat_parse_args(priv, argc, argv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = j1939cat_sock_prepare(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->todo_recv)\n\t\tret = j1939cat_recv(priv);\n\telse\n\t\tret = j1939cat_send(priv);\n\n\tclose(priv->infile);\n\tclose(priv->outfile);\n\tclose(priv->sock);\n\n\treturn ret;\n}\n"
        },
        {
          "name": "j1939spy.c",
          "type": "blob",
          "size": 7.0361328125,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (c) 2011 EIA Electronics\n *\n * Authors:\n * Kurt Van Dijck <kurt.van.dijck@eia.be>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n */\n\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <err.h>\n#include <getopt.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#include \"libj1939.h\"\n\n/*\n * getopt\n */\nstatic const char help_msg[] =\n\t\"j1939spy: An SAE J1939 spy utility\" \"\\n\"\n\t\"Usage: j1939spy [OPTION...] [[IFACE:][NAME|SA][,PGN]]\" \"\\n\"\n\t\"Options:\\n\"\n\t\"  -P, --promisc\t\tRun in promiscuous mode\" \"\\n\"\n\t\"\t\t\t(= receive traffic not for this ECU)\" \"\\n\"\n\t\"  -b, --block=SIZE\tUse a receive buffer of SIZE (default 1024)\" \"\\n\"\n\t\"  -t, --time[=a|d|z|A]\tShow time: (a)bsolute, (d)elta, (z)ero, (A)bsolute w date\" \"\\n\"\n\t;\n\n#ifdef _GNU_SOURCE\nstatic struct option long_opts[] = {\n\t{ \"help\", no_argument, NULL, '?', },\n\t{ \"promisc\", no_argument, NULL, 'P', },\n\t{ \"block\", required_argument, NULL, 'b', },\n\t{ \"time\", optional_argument, NULL, 't', },\n\t{ },\n};\n#else\n#define getopt_long(argc, argv, optstring, longopts, longindex) \\\n\tgetopt((argc), (argv), (optstring))\n#endif\nstatic const char optstring[] = \"vPb:t::?\";\n\n/*\n * static variables\n */\nstatic struct {\n\tstruct sockaddr_can addr;\n\tint promisc;\n\tint time;\n\tint pkt_len;\n} s = {\n\t.pkt_len = 1024,\n\t.addr.can_addr.j1939 = {\n\t\t.name = J1939_NO_NAME,\n\t\t.addr = J1939_NO_ADDR,\n\t\t.pgn = J1939_NO_PGN,\n\t},\n};\n\n/*\n * useful buffers\n */\nstatic const int ival_1 = 1;\n\nstatic char ctrlmsg[\n\t  CMSG_SPACE(sizeof(struct timeval))\n\t+ CMSG_SPACE(sizeof(uint8_t)) /* dest addr */\n\t+ CMSG_SPACE(sizeof(uint64_t)) /* dest name */\n\t+ CMSG_SPACE(sizeof(uint8_t)) /* priority */\n\t];\nstatic struct iovec iov;\nstatic struct msghdr msg;\nstatic struct cmsghdr *cmsg;\nstatic uint8_t *buf;\n\n/*\n * program\n */\nint main(int argc, char **argv)\n{\n\tint ret, sock, opt;\n\tunsigned int j, len;\n\tstruct timeval tref, tdut, ttmp;\n\tstruct sockaddr_can src;\n\tstruct j1939_filter filt;\n\tint filter = 0;\n\tuint8_t priority, dst_addr;\n\tuint64_t dst_name;\n\tuint64_t recvflags;\n\n\t/* argument parsing */\n\twhile ((opt = getopt_long(argc, argv, optstring, long_opts, NULL)) != -1)\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ts.pkt_len = strtoul(optarg, 0, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t++s.promisc;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (optarg) {\n\t\t\t\tif (!strchr(\"adzA\", optarg[0]))\n\t\t\t\t\terr(1, \"unknown time option '%c'\",\n\t\t\t\t\t    optarg[0]);\n\t\t\t\ts.time = optarg[0];\n\t\t\t} else {\n\t\t\t\ts.time = 'z';\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfputs(help_msg, stderr);\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\n\tif (argv[optind]) {\n\t\toptarg = argv[optind];\n\t\tret = libj1939_str2addr(optarg, 0, &s.addr);\n\t\tif (ret < 0) {\n\t\t\terr(0, \"bad URI %s\", optarg);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tbuf = malloc(s.pkt_len);\n\tif (!buf)\n\t\terr(1, \"malloc %u\", s.pkt_len);\n\n\t/* setup socket */\n\tsock = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n\tif (sock < 0)\n\t\terr(1, \"socket(can, dgram, j1939)\");\n\n\tmemset(&filt, 0, sizeof(filt));\n\tif (s.addr.can_addr.j1939.name) {\n\t\tfilt.name = s.addr.can_addr.j1939.name;\n\t\tfilt.name_mask = ~0ULL;\n\t\t++filter;\n\t}\n\tif (s.addr.can_addr.j1939.addr < 0xff) {\n\t\tfilt.addr = s.addr.can_addr.j1939.addr;\n\t\tfilt.addr_mask = ~0;\n\t\t++filter;\n\t}\n\tif (s.addr.can_addr.j1939.pgn <= J1939_PGN_MAX) {\n\t\tfilt.pgn = s.addr.can_addr.j1939.pgn;\n\t\tfilt.pgn_mask = ~0;\n\t\t++filter;\n\t}\n\tif (filter) {\n\t\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_FILTER, &filt, sizeof(filt));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt filter\");\n\t}\n\n\tif (s.promisc) {\n\t\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_PROMISC, &ival_1, sizeof(ival_1));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt promisc\");\n\t}\n\n\tif (s.time) {\n\t\tret = setsockopt(sock, SOL_SOCKET, SO_TIMESTAMP, &ival_1, sizeof(ival_1));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt timestamp\");\n\t}\n\tret = setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &s.pkt_len, sizeof(s.pkt_len));\n\tif (ret < 0)\n\t\terr(1, \"setsockopt rcvbuf %u\", s.pkt_len);\n\n\t/* bind(): to default, only ifindex is used. */\n\tmemset(&src, 0, sizeof(src));\n\tsrc.can_ifindex = s.addr.can_ifindex;\n\tsrc.can_family = AF_CAN;\n\tsrc.can_addr.j1939.name = J1939_NO_NAME;\n\tsrc.can_addr.j1939.addr = J1939_NO_ADDR;\n\tsrc.can_addr.j1939.pgn = J1939_NO_PGN;\n\tret = bind(sock, (void *)&src, sizeof(src));\n\tif (ret < 0)\n\t\terr(1, \"bind(%s)\", argv[1]);\n\n\t/* these settings are static and can be held out of the hot path */\n\tiov.iov_base = &buf[0];\n\tmsg.msg_name = &src;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = &ctrlmsg;\n\n\tmemset(&tref, 0, sizeof(tref));\n\twhile (1) {\n\t\t/* these settings may be modified by recvmsg() */\n\t\tiov.iov_len = s.pkt_len;\n\t\tmsg.msg_namelen = sizeof(src);\n\t\tmsg.msg_controllen = sizeof(ctrlmsg);\n\t\tmsg.msg_flags = 0;\n\n\t\tret = recvmsg(sock, &msg, 0);\n\t\t//ret = recvfrom(buf, s.pkt_len, 0, (void *)&addr, &len);\n\t\tif (ret < 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase ENETDOWN:\n\t\t\t\terr(0, \"ifindex %i\", s.addr.can_ifindex);\n\t\t\t\tcontinue;\n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\terr(1, \"recvmsg(ifindex %i)\", s.addr.can_ifindex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlen = ret;\n\t\trecvflags = 0;\n\t\tdst_addr = 0;\n\t\tpriority = 0;\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tswitch (cmsg->cmsg_level) {\n\t\t\tcase SOL_SOCKET:\n\t\t\t\tif (cmsg->cmsg_type == SCM_TIMESTAMP) {\n\t\t\t\t\tmemcpy(&tdut, CMSG_DATA(cmsg), sizeof(tdut));\n\t\t\t\t\trecvflags |= 1ULL << cmsg->cmsg_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SOL_CAN_J1939:\n\t\t\t\trecvflags |= 1ULL << cmsg->cmsg_type;\n\t\t\t\tif (cmsg->cmsg_type == SCM_J1939_DEST_ADDR)\n\t\t\t\t\tdst_addr = *CMSG_DATA(cmsg);\n\t\t\t\telse if (cmsg->cmsg_type == SCM_J1939_DEST_NAME)\n\t\t\t\t\tmemcpy(&dst_name, CMSG_DATA(cmsg), cmsg->cmsg_len - CMSG_LEN(0));\n\t\t\t\telse if (cmsg->cmsg_type == SCM_J1939_PRIO)\n\t\t\t\t\tpriority = *CMSG_DATA(cmsg);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif (recvflags & (1ULL << SCM_TIMESTAMP)) {\n\t\t\tif ('z' == s.time) {\n\t\t\t\tif (!tref.tv_sec)\n\t\t\t\t\ttref = tdut;\n\t\t\t\ttimersub(&tdut, &tref, &ttmp);\n\t\t\t\ttdut = ttmp;\n\t\t\t\tgoto abs_time;\n\t\t\t} else if ('d' == s.time) {\n\t\t\t\ttimersub(&tdut, &tref, &ttmp);\n\t\t\t\ttref = tdut;\n\t\t\t\ttdut = ttmp;\n\t\t\t\tgoto abs_time;\n\t\t\t} else if ('a' == s.time) {\nabs_time:\n\t\t\t\tprintf(\"(%llu.%04llu)\", (unsigned long long)tdut.tv_sec, (unsigned long long)tdut.tv_usec / 100);\n\t\t\t} else if ('A' == s.time) {\n\t\t\t\tstruct tm tm;\n\t\t\t\ttm = *localtime(&tdut.tv_sec);\n\t\t\t\tprintf(\"(%04u%02u%02uT%02u%02u%02u.%04llu)\",\n\t\t\t\t\ttm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n\t\t\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\t\t\t\t(unsigned long long)tdut.tv_usec/100);\n\t\t\t}\n\t\t}\n\t\tprintf(\" %s \", libj1939_addr2str(&src));\n\t\tif (recvflags & (1ULL << SCM_J1939_DEST_NAME))\n\t\t\tprintf(\"%016llx \", (unsigned long long)dst_name);\n\t\telse if (recvflags & (1ULL << SCM_J1939_DEST_ADDR))\n\t\t\tprintf(\"%02x \", dst_addr);\n\t\telse\n\t\t\tprintf(\"- \");\n\t\tprintf(\"!%u \", priority);\n\n\t\tprintf(\"[%i%s]\", len, (msg.msg_flags & MSG_TRUNC) ? \"...\" : \"\");\n\t\tfor (j = 0; j < len;) {\n\t\t\tunsigned int end = j + 4;\n\t\t\tif (end > len)\n\t\t\t\tend = len;\n\t\t\tprintf(\" \");\n\t\t\tfor (; j < end; ++j)\n\t\t\t\tprintf(\"%02x\", buf[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfree(buf);\n\treturn 0;\n}\n"
        },
        {
          "name": "j1939sr.c",
          "type": "blob",
          "size": 4.705078125,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (c) 2011 EIA Electronics\n *\n * Authors:\n * Kurt Van Dijck <kurt.van.dijck@eia.be>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n */\n\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <err.h>\n#include <getopt.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"libj1939.h\"\n\n/*\n * getopt\n */\nstatic const char help_msg[] =\n\t\"j1939sr: An SAE J1939 send/recv utility\" \"\\n\"\n\t\"Usage: j1939sr [OPTION...] SOURCE [DEST]\" \"\\n\"\n\t\"Options:\\n\"\n\t\"  -v, --verbose\t\tIncrease verbosity\" \"\\n\"\n\t\"  -p, --priority=VAL\tJ1939 priority (0..7, default 6)\" \"\\n\"\n\t\"  -S, --serialize\tStrictly serialize outgoing packets\" \"\\n\"\n\t\"  -s, --size\t\tPacket size, default autodetected\" \"\\n\"\n\t\"\\n\"\n\t\"  SOURCE\t[IFACE:][NAME|SA][,PGN]\" \"\\n\"\n\t\"  DEST\t\t\t[NAME|SA]\" \"\\n\"\n\t;\n\n#ifdef _GNU_SOURCE\nstatic struct option long_opts[] = {\n\t{ \"help\", no_argument, NULL, '?', },\n\t{ \"verbose\", no_argument, NULL, 'v', },\n\n\t{ \"priority\", required_argument, NULL, 'p', },\n\t{ \"size\", required_argument, NULL, 's', },\n\t{ \"serialize\", no_argument, NULL, 'S', },\n\t{ },\n};\n#else\n#define getopt_long(argc, argv, optstring, longopts, longindex) \\\n\tgetopt((argc), (argv), (optstring))\n#endif\nstatic const char optstring[] = \"vp:s:S?\";\n\n/*\n * static variables: configurations\n */\nstatic struct {\n\tint verbose;\n\tint sendflags; /* flags for sendto() */\n\tint pkt_len;\n\tint priority;\n\tint defined;\n\t#define DEF_SRC\t\t1\n\t#define DEF_DST\t\t2\n\t#define DEF_PRIO\t4\n\tstruct sockaddr_can src, dst;\n} s = {\n\t.priority = 6,\n\t.src.can_addr.j1939 = {\n\t\t.name = J1939_NO_NAME,\n\t\t.addr = J1939_NO_ADDR,\n\t\t.pgn = J1939_NO_PGN,\n\t},\n\t.dst.can_addr.j1939 = {\n\t\t.name = J1939_NO_NAME,\n\t\t.addr = J1939_NO_ADDR,\n\t\t.pgn = J1939_NO_PGN,\n\t},\n};\n\nint main(int argc, char **argv)\n{\n\n\tint ret, sock, opt;\n\tunsigned int len;\n\tstruct pollfd pfd[2];\n\tuint8_t *buf;\n\n\t/* argument parsing */\n\twhile ((opt = getopt_long(argc, argv, optstring, long_opts, NULL)) != -1)\n\t\tswitch (opt) {\n\t\tcase 'v':\n\t\t\t++s.verbose;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\ts.pkt_len = strtoul(optarg, 0, 0);\n\t\t\tif (!s.pkt_len)\n\t\t\t\terr(1, \"packet size of %s\", optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ts.priority = strtoul(optarg, 0, 0);\n\t\t\ts.defined |= DEF_PRIO;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\ts.sendflags |= MSG_SYN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfputs(help_msg, stderr);\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\n\tif (argv[optind]) {\n\t\toptarg = argv[optind++];\n\t\tret = libj1939_str2addr(optarg, 0, &s.src);\n\t\tif (ret < 0)\n\t\t\terr(1, \"bad address spec [%s]\", optarg);\n\t\ts.defined |= DEF_SRC;\n\t}\n\tif (argv[optind]) {\n\t\toptarg = argv[optind++];\n\t\tret = libj1939_str2addr(optarg, 0, &s.dst);\n\t\tif (ret < 0)\n\t\t\terr(1, \"bad address spec [%s]\", optarg);\n\t\ts.defined |= DEF_DST;\n\t}\n\n\tif (!s.pkt_len) {\n\t\tstruct stat st;\n\n\t\tif (fstat(STDIN_FILENO, &st) < 0)\n\t\t\terr(1, \"stat stdin, could not determine buffer size\");\n\t\ts.pkt_len = st.st_size ?: 1024;\n\t}\n\n\t/* prepare */\n\tbuf = malloc(s.pkt_len);\n\tif (!buf)\n\t\terr(1, \"malloc %u\", s.pkt_len);\n\n\tsock = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n\tif (sock < 0)\n\t\terr(1, \"socket(can, dgram, j1939)\");\n\n\tif (s.defined & DEF_PRIO) {\n\t\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_SEND_PRIO, &s.priority, sizeof(s.priority));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt priority\");\n\t}\n\tif (s.defined & DEF_SRC) {\n\t\ts.src.can_family = AF_CAN;\n\t\tret = bind(sock, (void *)&s.src, sizeof(s.src));\n\t\tif (ret < 0)\n\t\t\terr(1, \"bind(%s), %i\", libj1939_addr2str(&s.src), -errno);\n\t}\n\n\tif (s.defined & DEF_DST) {\n\t\ts.dst.can_family = AF_CAN;\n\t\tret = connect(sock, (void *)&s.dst, sizeof(s.dst));\n\t\tif (ret < 0)\n\t\t\terr(1, \"connect(%s), %i\", libj1939_addr2str(&s.dst), -errno);\n\t}\n\n\tpfd[0].fd = STDIN_FILENO;\n\tpfd[0].events = POLLIN;\n\tpfd[1].fd = sock;\n\tpfd[1].events = POLLIN;\n\n\t/* run */\n\twhile (1) {\n\t\tret = poll(pfd, sizeof(pfd)/sizeof(pfd[0]), -1);\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terr(1, \"poll()\");\n\t\t}\n\t\tif (pfd[0].revents) {\n\t\t\tret = read(pfd[0].fd, buf, s.pkt_len);\n\t\t\tif (ret < 0)\n\t\t\t\terr(1, \"read(stdin)\");\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tlen = ret;\n\t\t\tdo {\n\t\t\t\tret = send(pfd[1].fd, buf, len, s.sendflags);\n\t\t\t\tif (ret < 0 && errno != ENOBUFS)\n\t\t\t\t\terr(1, \"write(%s)\", libj1939_addr2str(&s.src));\n\t\t\t} while (ret < 0);\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\tret = read(pfd[1].fd, buf, s.pkt_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tret = errno;\n\t\t\t\terr(0, \"read(%s)\", libj1939_addr2str(&s.dst));\n\t\t\t\tswitch (ret) {\n\t\t\t\tcase EHOSTDOWN:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (write(STDOUT_FILENO, buf, ret) < 0)\n\t\t\t\t\terr(1, \"write(stdout)\");\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(buf);\n\treturn 0;\n}\n\n"
        },
        {
          "name": "lib.c",
          "type": "blob",
          "size": 22.1025390625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * lib.c - library for command line tools\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\n#include <linux/can.h>\n#include <linux/can/error.h>\n#include <sys/socket.h> /* for sa_family_t */\n\n#include \"lib.h\"\n\n#define CANID_DELIM '#'\n#define CC_DLC_DELIM '_'\n#define XL_HDR_DELIM ':'\n#define DATA_SEPERATOR '.'\n\nconst char hex_asc_upper[] = \"0123456789ABCDEF\";\n\n#define hex_asc_upper_lo(x) hex_asc_upper[((x)&0x0F)]\n#define hex_asc_upper_hi(x) hex_asc_upper[((x)&0xF0) >> 4]\n\nstatic inline void put_hex_byte(char *buf, __u8 byte)\n{\n\tbuf[0] = hex_asc_upper_hi(byte);\n\tbuf[1] = hex_asc_upper_lo(byte);\n}\n\nstatic inline void _put_id(char *buf, int end_offset, canid_t id)\n{\n\t/* build 3 (SFF) or 8 (EFF) digit CAN identifier */\n\twhile (end_offset >= 0) {\n\t\tbuf[end_offset--] = hex_asc_upper_lo(id);\n\t\tid >>= 4;\n\t}\n}\n\n#define put_sff_id(buf, id) _put_id(buf, 2, id)\n#define put_eff_id(buf, id) _put_id(buf, 7, id)\n\n/* CAN DLC to real data length conversion helpers */\n\nstatic const unsigned char dlc2len[] = {0, 1, 2, 3, 4, 5, 6, 7,\n\t\t\t\t\t8, 12, 16, 20, 24, 32, 48, 64};\n\n/* get data length from raw data length code (DLC) */\nunsigned char can_fd_dlc2len(unsigned char dlc)\n{\n\treturn dlc2len[dlc & 0x0F];\n}\n\nstatic const unsigned char len2dlc[] = {0, 1, 2, 3, 4, 5, 6, 7, 8,\t\t/* 0 - 8 */\n\t\t\t\t\t9, 9, 9, 9,\t\t\t\t/* 9 - 12 */\n\t\t\t\t\t10, 10, 10, 10,\t\t\t\t/* 13 - 16 */\n\t\t\t\t\t11, 11, 11, 11,\t\t\t\t/* 17 - 20 */\n\t\t\t\t\t12, 12, 12, 12,\t\t\t\t/* 21 - 24 */\n\t\t\t\t\t13, 13, 13, 13, 13, 13, 13, 13,\t\t/* 25 - 32 */\n\t\t\t\t\t14, 14, 14, 14, 14, 14, 14, 14,\t\t/* 33 - 40 */\n\t\t\t\t\t14, 14, 14, 14, 14, 14, 14, 14,\t\t/* 41 - 48 */\n\t\t\t\t\t15, 15, 15, 15, 15, 15, 15, 15,\t\t/* 49 - 56 */\n\t\t\t\t\t15, 15, 15, 15, 15, 15, 15, 15};\t/* 57 - 64 */\n\n/* map the sanitized data length to an appropriate data length code */\nunsigned char can_fd_len2dlc(unsigned char len)\n{\n\tif (len > 64)\n\t\treturn 0xF;\n\n\treturn len2dlc[len];\n}\n\nunsigned char asc2nibble(char c)\n{\n\tif ((c >= '0') && (c <= '9'))\n\t\treturn c - '0';\n\n\tif ((c >= 'A') && (c <= 'F'))\n\t\treturn c - 'A' + 10;\n\n\tif ((c >= 'a') && (c <= 'f'))\n\t\treturn c - 'a' + 10;\n\n\treturn 16; /* error */\n}\n\nint hexstring2data(char *arg, unsigned char *data, int maxdlen)\n{\n\tint len = strlen(arg);\n\tint i;\n\tunsigned char tmp;\n\n\tif (!len || len % 2 || len > maxdlen * 2)\n\t\treturn 1;\n\n\tmemset(data, 0, maxdlen);\n\n\tfor (i = 0; i < len / 2; i++) {\n\t\ttmp = asc2nibble(*(arg + (2 * i)));\n\t\tif (tmp > 0x0F)\n\t\t\treturn 1;\n\n\t\tdata[i] = (tmp << 4);\n\n\t\ttmp = asc2nibble(*(arg + (2 * i) + 1));\n\t\tif (tmp > 0x0F)\n\t\t\treturn 1;\n\n\t\tdata[i] |= tmp;\n\t}\n\n\treturn 0;\n}\n\nint parse_canframe(char *cs, cu_t *cu)\n{\n\t/* documentation see lib.h */\n\n\tint i, idx, dlen, len;\n\tint maxdlen = CAN_MAX_DLEN;\n\tint mtu = CAN_MTU;\n\t__u8 *data = cu->fd.data; /* fill CAN CC/FD data by default */\n\tcanid_t tmp;\n\n\tlen = strlen(cs);\n\t//printf(\"'%s' len %d\\n\", cs, len);\n\n\tmemset(cu, 0, sizeof(*cu)); /* init CAN CC/FD/XL frame, e.g. LEN = 0 */\n\n\tif (len < 4)\n\t\treturn 0;\n\n\tif (cs[3] == CANID_DELIM) { /* 3 digits SFF */\n\n\t\tidx = 4;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((tmp = asc2nibble(cs[i])) > 0x0F)\n\t\t\t\treturn 0;\n\t\t\tcu->cc.can_id |= tmp << (2 - i) * 4;\n\t\t}\n\n\t} else if (cs[5] == CANID_DELIM) { /* 5 digits CAN XL VCID/PRIO*/\n\n\t\tidx = 6;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tif ((tmp = asc2nibble(cs[i])) > 0x0F)\n\t\t\t\treturn 0;\n\t\t\tcu->xl.prio |= tmp << (4 - i) * 4;\n\t\t}\n\n\t\t/* the VCID starts at bit position 16 */\n\t\ttmp = (cu->xl.prio << 4) & CANXL_VCID_MASK;\n\t\tcu->xl.prio &= CANXL_PRIO_MASK;\n\t\tcu->xl.prio |= tmp;\n\n\t} else if (cs[8] == CANID_DELIM) { /* 8 digits EFF */\n\n\t\tidx = 9;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif ((tmp = asc2nibble(cs[i])) > 0x0F)\n\t\t\t\treturn 0;\n\t\t\tcu->cc.can_id |= tmp << (7 - i) * 4;\n\t\t}\n\t\tif (!(cu->cc.can_id & CAN_ERR_FLAG)) /* 8 digits but no errorframe?  */\n\t\t\tcu->cc.can_id |= CAN_EFF_FLAG;   /* then it is an extended frame */\n\n\t} else\n\t\treturn 0;\n\n\tif ((cs[idx] == 'R') || (cs[idx] == 'r')) { /* RTR frame */\n\t\tcu->cc.can_id |= CAN_RTR_FLAG;\n\n\t\t/* check for optional DLC value for CAN 2.0B frames */\n\t\tif (cs[++idx] && (tmp = asc2nibble(cs[idx++])) <= CAN_MAX_DLEN) {\n\t\t\tcu->cc.len = tmp;\n\n\t\t\t/* check for optional raw DLC value for CAN 2.0B frames */\n\t\t\tif ((tmp == CAN_MAX_DLEN) && (cs[idx++] == CC_DLC_DELIM)) {\n\t\t\t\ttmp = asc2nibble(cs[idx]);\n\t\t\t\tif ((tmp > CAN_MAX_DLEN) && (tmp <= CAN_MAX_RAW_DLC))\n\t\t\t\t\tcu->cc.len8_dlc = tmp;\n\t\t\t}\n\t\t}\n\t\treturn mtu;\n\t}\n\n\tif (cs[idx] == CANID_DELIM) { /* CAN FD frame escape char '##' */\n\t\tmaxdlen = CANFD_MAX_DLEN;\n\t\tmtu = CANFD_MTU;\n\n\t\t/* CAN FD frame <canid>##<flags><data>* */\n\t\tif ((tmp = asc2nibble(cs[idx + 1])) > 0x0F)\n\t\t\treturn 0;\n\n\t\tcu->fd.flags = tmp;\n\t\tcu->fd.flags |= CANFD_FDF; /* dual-use */\n\t\tidx += 2;\n\n\t} else if (cs[idx + 14] == CANID_DELIM) { /* CAN XL frame '#80:00:11223344#' */\n\t\tmaxdlen = CANXL_MAX_DLEN;\n\t\tmtu = CANXL_MTU;\n\t\tdata = cu->xl.data; /* fill CAN XL data */\n\n\t\tif ((cs[idx + 2] != XL_HDR_DELIM) || (cs[idx + 5] != XL_HDR_DELIM))\n\t\t\treturn 0;\n\n\t\tif ((tmp = asc2nibble(cs[idx++])) > 0x0F)\n\t\t\treturn 0;\n\t\tcu->xl.flags = tmp << 4;\n\t\tif ((tmp = asc2nibble(cs[idx++])) > 0x0F)\n\t\t\treturn 0;\n\t\tcu->xl.flags |= tmp;\n\n\t\t/* force CAN XL flag if it was missing in the ASCII string */\n\t\tcu->xl.flags |= CANXL_XLF;\n\n\t\tidx++; /* skip XL_HDR_DELIM */\n\n\t\tif ((tmp = asc2nibble(cs[idx++])) > 0x0F)\n\t\t\treturn 0;\n\t\tcu->xl.sdt = tmp << 4;\n\t\tif ((tmp = asc2nibble(cs[idx++])) > 0x0F)\n\t\t\treturn 0;\n\t\tcu->xl.sdt |= tmp;\n\n\t\tidx++; /* skip XL_HDR_DELIM */\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif ((tmp = asc2nibble(cs[idx++])) > 0x0F)\n\t\t\t\treturn 0;\n\t\t\tcu->xl.af |= tmp << (7 - i) * 4;\n\t\t}\n\n\t\tidx++; /* skip CANID_DELIM */\n\t}\n\n\tfor (i = 0, dlen = 0; i < maxdlen; i++) {\n\t\tif (cs[idx] == DATA_SEPERATOR) /* skip (optional) separator */\n\t\t\tidx++;\n\n\t\tif (idx >= len) /* end of string => end of data */\n\t\t\tbreak;\n\n\t\tif ((tmp = asc2nibble(cs[idx++])) > 0x0F)\n\t\t\treturn 0;\n\t\tdata[i] = tmp << 4;\n\t\tif ((tmp = asc2nibble(cs[idx++])) > 0x0F)\n\t\t\treturn 0;\n\t\tdata[i] |= tmp;\n\t\tdlen++;\n\t}\n\n\tif (mtu == CANXL_MTU)\n\t\tcu->xl.len = dlen;\n\telse\n\t\tcu->fd.len = dlen;\n\n\t/* check for extra DLC when having a Classic CAN with 8 bytes payload */\n\tif ((maxdlen == CAN_MAX_DLEN) && (dlen == CAN_MAX_DLEN) && (cs[idx++] == CC_DLC_DELIM)) {\n\t\tunsigned char dlc = asc2nibble(cs[idx]);\n\n\t\tif ((dlc > CAN_MAX_DLEN) && (dlc <= CAN_MAX_RAW_DLC))\n\t\t\tcu->cc.len8_dlc = dlc;\n\t}\n\n\treturn mtu;\n}\n\nint snprintf_canframe(char *buf, size_t size, cu_t *cu, int sep)\n{\n\t/* documentation see lib.h */\n\n\tunsigned char is_canfd = cu->fd.flags;\n\tint i, offset;\n\tint len;\n\n\t/* ensure space for string termination */\n\tif (size < 1)\n\t\treturn size;\n\n\t/* handle CAN XL frames */\n\tif (cu->xl.flags & CANXL_XLF) {\n\t\tlen = cu->xl.len;\n\n\t\t/* check if the CAN frame fits into the provided buffer */\n\t\tif (sizeof(\"00123#11:22:12345678#\") + 2 * len + (sep ? len : 0) > size - 1) {\n\t\t\t/* mark buffer overflow in output */\n\t\t\tmemset(buf, '-', size - 1);\n\t\t\tbuf[size - 1] = 0;\n\t\t\treturn size;\n\t\t}\n\n\t\t/* print prio and CAN XL header content */\n\t\toffset = sprintf(buf, \"%02X%03X#%02X:%02X:%08X#\",\n\t\t\t\t (canid_t)(cu->xl.prio & CANXL_VCID_MASK) >> CANXL_VCID_OFFSET,\n\t\t\t\t (canid_t)(cu->xl.prio & CANXL_PRIO_MASK),\n\t\t\t\t cu->xl.flags, cu->xl.sdt, cu->xl.af);\n\n\t\t/* data */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tput_hex_byte(buf + offset, cu->xl.data[i]);\n\t\t\toffset += 2;\n\t\t\tif (sep && (i + 1 < len))\n\t\t\t\tbuf[offset++] = '.';\n\t\t}\n\n\t\tbuf[offset] = 0;\n\n\t\treturn offset;\n\t}\n\n\t/* handle CAN CC/FD frames - ensure max length values */\n\tif (is_canfd)\n\t\tlen = (cu->fd.len > CANFD_MAX_DLEN) ? CANFD_MAX_DLEN : cu->fd.len;\n\telse\n\t\tlen = (cu->fd.len > CAN_MAX_DLEN) ? CAN_MAX_DLEN : cu->fd.len;\n\n\t/* check if the CAN frame fits into the provided buffer */\n\tif (sizeof(\"12345678#_F\") + 2 * len + (sep ? len : 0) +\t\\\n\t    (cu->fd.can_id & CAN_RTR_FLAG ? 2 : 0) > size - 1) {\n\t\t/* mark buffer overflow in output */\n\t\tmemset(buf, '-', size - 1);\n\t\tbuf[size - 1] = 0;\n\t\treturn size;\n\t}\n\n\tif (cu->fd.can_id & CAN_ERR_FLAG) {\n\t\tput_eff_id(buf, cu->fd.can_id & (CAN_ERR_MASK | CAN_ERR_FLAG));\n\t\tbuf[8] = '#';\n\t\toffset = 9;\n\t} else if (cu->fd.can_id & CAN_EFF_FLAG) {\n\t\tput_eff_id(buf, cu->fd.can_id & CAN_EFF_MASK);\n\t\tbuf[8] = '#';\n\t\toffset = 9;\n\t} else {\n\t\tput_sff_id(buf, cu->fd.can_id & CAN_SFF_MASK);\n\t\tbuf[3] = '#';\n\t\toffset = 4;\n\t}\n\n\t/* CAN CC frames may have RTR enabled. There are no ERR frames with RTR */\n\tif (!is_canfd && cu->fd.can_id & CAN_RTR_FLAG) {\n\t\tbuf[offset++] = 'R';\n\t\t/* print a given CAN 2.0B DLC if it's not zero */\n\t\tif (len && len <= CAN_MAX_DLEN) {\n\t\t\tbuf[offset++] = hex_asc_upper_lo(cu->fd.len);\n\n\t\t\t/* check for optional raw DLC value for CAN 2.0B frames */\n\t\t\tif (len == CAN_MAX_DLEN) {\n\t\t\t\tif ((cu->cc.len8_dlc > CAN_MAX_DLEN) && (cu->cc.len8_dlc <= CAN_MAX_RAW_DLC)) {\n\t\t\t\t\tbuf[offset++] = CC_DLC_DELIM;\n\t\t\t\t\tbuf[offset++] = hex_asc_upper_lo(cu->cc.len8_dlc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbuf[offset] = 0;\n\t\treturn offset;\n\t}\n\n\t/* any CAN FD flags */\n\tif (is_canfd) {\n\t\t/* add CAN FD specific escape char and flags */\n\t\tbuf[offset++] = '#';\n\t\tbuf[offset++] = hex_asc_upper_lo(cu->fd.flags);\n\t\tif (sep && len)\n\t\t\tbuf[offset++] = '.';\n\t}\n\n\t/* data */\n\tfor (i = 0; i < len; i++) {\n\t\tput_hex_byte(buf + offset, cu->fd.data[i]);\n\t\toffset += 2;\n\t\tif (sep && (i + 1 < len))\n\t\t\tbuf[offset++] = '.';\n\t}\n\n\t/* check for extra DLC when having a Classic CAN with 8 bytes payload */\n\tif (!is_canfd && (len == CAN_MAX_DLEN)) {\n\t\tunsigned char dlc = cu->cc.len8_dlc;\n\n\t\tif ((dlc > CAN_MAX_DLEN) && (dlc <= CAN_MAX_RAW_DLC)) {\n\t\t\tbuf[offset++] = CC_DLC_DELIM;\n\t\t\tbuf[offset++] = hex_asc_upper_lo(dlc);\n\t\t}\n\t}\n\n\tbuf[offset] = 0;\n\n\treturn offset;\n}\n\nint snprintf_long_canframe(char *buf, size_t size, cu_t *cu, int view)\n{\n\t/* documentation see lib.h */\n\n\tunsigned char is_canfd = cu->fd.flags;\n\tint i, j, dlen, offset;\n\tsize_t maxsize;\n\tint len;\n\n\t/* ensure space for string termination */\n\tif (size < 1)\n\t\treturn size;\n\n\t/* handle CAN XL frames */\n\tif (cu->xl.flags & CANXL_XLF) {\n\t\tlen = cu->xl.len;\n\n\t\t/* crop to CANFD_MAX_DLEN */\n\t\tif (len > CANFD_MAX_DLEN)\n\t\t\tdlen = CANFD_MAX_DLEN;\n\t\telse\n\t\t\tdlen = len;\n\n\t\t/* check if the CAN frame fits into the provided buffer */\n\t\tif (sizeof(\".....123 [2048] (00|11:22:12345678)  ...\") + 3 * dlen > size - 1) {\n\t\t\t/* mark buffer overflow in output */\n\t\t\tmemset(buf, '-', size - 1);\n\t\t\tbuf[size - 1] = 0;\n\t\t\treturn size;\n\t\t}\n\n\t\tif (view & CANLIB_VIEW_INDENT_SFF) {\n\t\t\tmemset(buf, ' ', 5);\n\t\t\tput_sff_id(buf + 5, cu->xl.prio & CANXL_PRIO_MASK);\n\t\t\toffset = 8;\n\t\t} else {\n\t\t\tput_sff_id(buf, cu->xl.prio & CANXL_PRIO_MASK);\n\t\t\toffset = 3;\n\t\t}\n\n\t\t/* print prio and CAN XL header content */\n\t\toffset += sprintf(buf + offset, \" [%04d] (%02X|%02X:%02X:%08X) \",\n\t\t\t\t  len,\n\t\t\t\t  (canid_t)(cu->xl.prio & CANXL_VCID_MASK) >> CANXL_VCID_OFFSET,\n\t\t\t\t  cu->xl.flags, cu->xl.sdt, cu->xl.af);\n\n\t\tfor (i = 0; i < dlen; i++) {\n\t\t\tput_hex_byte(buf + offset, cu->xl.data[i]);\n\t\t\toffset += 2;\n\t\t\tif (i + 1 < dlen)\n\t\t\t\tbuf[offset++] = ' ';\n\t\t}\n\n\t\t/* indicate cropped output */\n\t\tif (cu->xl.len > dlen)\n\t\t\toffset += sprintf(buf + offset, \" ...\");\n\n\t\tbuf[offset] = 0;\n\n\t\treturn offset;\n\t}\n\n\t/* ensure max length values */\n\tif (is_canfd)\n\t\tlen = (cu->fd.len > CANFD_MAX_DLEN) ? CANFD_MAX_DLEN : cu->fd.len;\n\telse\n\t\tlen = (cu->fd.len > CAN_MAX_DLEN) ? CAN_MAX_DLEN : cu->fd.len;\n\n\t/* check if the CAN frame fits into the provided buffer */\n\tmaxsize = sizeof(\"12345678  [12]  \");\n\tif (view & CANLIB_VIEW_BINARY)\n\t\tdlen = 9; /* _10101010 */\n\telse\n\t\tdlen = 3; /* _AA */\n\n\tif (cu->fd.can_id & CAN_RTR_FLAG) {\n\t\tmaxsize += sizeof(\"    remote request\");\n\t} else {\n\t\tmaxsize += len * dlen;\n\n\t\tif (len <= CAN_MAX_DLEN) {\n\t\t\tif (cu->fd.can_id & CAN_ERR_FLAG) {\n\t\t\t\tmaxsize += sizeof(\"    ERRORFRAME\");\n\t\t\t\tmaxsize += (8 - len) * dlen;\n\t\t\t} else if (view & CANLIB_VIEW_ASCII) {\n\t\t\t\tmaxsize += sizeof(\"    'a.b.CDEF'\");\n\t\t\t\tmaxsize += (8 - len) * dlen;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (maxsize > size - 1) {\n\t\t/* mark buffer overflow in output */\n\t\tmemset(buf, '-', size - 1);\n\t\tbuf[size - 1] = 0;\n\t\treturn size;\n\t}\n\n\t/* initialize space for CAN-ID and length information */\n\tmemset(buf, ' ', 15);\n\n\tif (cu->cc.can_id & CAN_ERR_FLAG) {\n\t\tput_eff_id(buf, cu->cc.can_id & (CAN_ERR_MASK | CAN_ERR_FLAG));\n\t\toffset = 10;\n\t} else if (cu->fd.can_id & CAN_EFF_FLAG) {\n\t\tput_eff_id(buf, cu->fd.can_id & CAN_EFF_MASK);\n\t\toffset = 10;\n\t} else {\n\t\tif (view & CANLIB_VIEW_INDENT_SFF) {\n\t\t\tput_sff_id(buf + 5, cu->fd.can_id & CAN_SFF_MASK);\n\t\t\toffset = 10;\n\t\t} else {\n\t\t\tput_sff_id(buf, cu->fd.can_id & CAN_SFF_MASK);\n\t\t\toffset = 5;\n\t\t}\n\t}\n\n\t/* The len value is sanitized (see above) */\n\tif (!is_canfd) {\n\t\tif (view & CANLIB_VIEW_LEN8_DLC) {\n\t\t\tunsigned char dlc = cu->cc.len8_dlc;\n\n\t\t\t/* fall back to len if we don't have a valid DLC > 8 */\n\t\t\tif (!((len == CAN_MAX_DLEN) && (dlc > CAN_MAX_DLEN) &&\n\t\t\t      (dlc <= CAN_MAX_RAW_DLC)))\n\t\t\t\tdlc = len;\n\n\t\t\tbuf[offset + 1] = '{';\n\t\t\tbuf[offset + 2] = hex_asc_upper[dlc];\n\t\t\tbuf[offset + 3] = '}';\n\t\t} else {\n\t\t\tbuf[offset + 1] = '[';\n\t\t\tbuf[offset + 2] = len + '0';\n\t\t\tbuf[offset + 3] = ']';\n\t\t}\n\n\t\t/* standard CAN frames may have RTR enabled */\n\t\tif (cu->fd.can_id & CAN_RTR_FLAG) {\n\t\t\toffset += sprintf(buf + offset + 5, \" remote request\");\n\t\t\treturn offset + 5;\n\t\t}\n\t} else {\n\t\tbuf[offset] = '[';\n\t\tbuf[offset + 1] = (len / 10) + '0';\n\t\tbuf[offset + 2] = (len % 10) + '0';\n\t\tbuf[offset + 3] = ']';\n\t}\n\toffset += 5;\n\n\tif (view & CANLIB_VIEW_BINARY) {\n\t\t/* _10101010 - dlen = 9, see above */\n\t\tif (view & CANLIB_VIEW_SWAP) {\n\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\tbuf[offset++] = (i == len - 1) ? ' ' : SWAP_DELIMITER;\n\t\t\t\tfor (j = 7; j >= 0; j--)\n\t\t\t\t\tbuf[offset++] = (1 << j & cu->fd.data[i]) ? '1' : '0';\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tbuf[offset++] = ' ';\n\t\t\t\tfor (j = 7; j >= 0; j--)\n\t\t\t\t\tbuf[offset++] = (1 << j & cu->fd.data[i]) ? '1' : '0';\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* _AA - dlen = 3, see above */\n\t\tif (view & CANLIB_VIEW_SWAP) {\n\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\tif (i == len - 1)\n\t\t\t\t\tbuf[offset++] = ' ';\n\t\t\t\telse\n\t\t\t\t\tbuf[offset++] = SWAP_DELIMITER;\n\n\t\t\t\tput_hex_byte(buf + offset, cu->fd.data[i]);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tbuf[offset++] = ' ';\n\t\t\t\tput_hex_byte(buf + offset, cu->fd.data[i]);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuf[offset] = 0; /* terminate string */\n\n\t/*\n\t * The ASCII & ERRORFRAME output is put at a fixed len behind the data.\n\t * For now we support ASCII output only for payload length up to 8 bytes.\n\t * Does it make sense to write 64 ASCII byte behind 64 ASCII HEX data on the console?\n\t */\n\tif (len > CAN_MAX_DLEN)\n\t\treturn offset;\n\n\tif (cu->fd.can_id & CAN_ERR_FLAG)\n\t\toffset += sprintf(buf + offset, \"%*s\", dlen * (8 - len) + 13, \"ERRORFRAME\");\n\telse if (view & CANLIB_VIEW_ASCII) {\n\t\tj = dlen * (8 - len) + 4;\n\t\tif (view & CANLIB_VIEW_SWAP) {\n\t\t\tsprintf(buf + offset, \"%*s\", j, \"`\");\n\t\t\toffset += j;\n\t\t\tfor (i = len - 1; i >= 0; i--)\n\t\t\t\tif ((cu->fd.data[i] > 0x1F) && (cu->fd.data[i] < 0x7F))\n\t\t\t\t\tbuf[offset++] = cu->fd.data[i];\n\t\t\t\telse\n\t\t\t\t\tbuf[offset++] = '.';\n\n\t\t\toffset += sprintf(buf + offset, \"`\");\n\t\t} else {\n\t\t\tsprintf(buf + offset, \"%*s\", j, \"'\");\n\t\t\toffset += j;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tif ((cu->fd.data[i] > 0x1F) && (cu->fd.data[i] < 0x7F))\n\t\t\t\t\tbuf[offset++] = cu->fd.data[i];\n\t\t\t\telse\n\t\t\t\t\tbuf[offset++] = '.';\n\n\t\t\toffset += sprintf(buf + offset, \"'\");\n\t\t}\n\t}\n\n\treturn offset;\n}\n\nstatic const char *error_classes[] = {\n\t\"tx-timeout\",\n\t\"lost-arbitration\",\n\t\"controller-problem\",\n\t\"protocol-violation\",\n\t\"transceiver-status\",\n\t\"no-acknowledgement-on-tx\",\n\t\"bus-off\",\n\t\"bus-error\",\n\t\"restarted-after-bus-off\",\n\t\"error-counter-tx-rx\",\n};\n\nstatic const char *controller_problems[] = {\n\t\"rx-overflow\",\n\t\"tx-overflow\",\n\t\"rx-error-warning\",\n\t\"tx-error-warning\",\n\t\"rx-error-passive\",\n\t\"tx-error-passive\",\n\t\"back-to-error-active\",\n};\n\nstatic const char *protocol_violation_types[] = {\n\t\"single-bit-error\",\n\t\"frame-format-error\",\n\t\"bit-stuffing-error\",\n\t\"tx-dominant-bit-error\",\n\t\"tx-recessive-bit-error\",\n\t\"bus-overload\",\n\t\"active-error\",\n\t\"error-on-tx\",\n};\n\nstatic const char *protocol_violation_locations[] = {\n\t\"unspecified\",\n\t\"unspecified\",\n\t\"id.28-to-id.21\",\n\t\"start-of-frame\",\n\t\"bit-srtr\",\n\t\"bit-ide\",\n\t\"id.20-to-id.18\",\n\t\"id.17-to-id.13\",\n\t\"crc-sequence\",\n\t\"reserved-bit-0\",\n\t\"data-field\",\n\t\"data-length-code\",\n\t\"bit-rtr\",\n\t\"reserved-bit-1\",\n\t\"id.4-to-id.0\",\n\t\"id.12-to-id.5\",\n\t\"unspecified\",\n\t\"active-error-flag\",\n\t\"intermission\",\n\t\"tolerate-dominant-bits\",\n\t\"unspecified\",\n\t\"unspecified\",\n\t\"passive-error-flag\",\n\t\"error-delimiter\",\n\t\"crc-delimiter\",\n\t\"acknowledge-slot\",\n\t\"end-of-frame\",\n\t\"acknowledge-delimiter\",\n\t\"overload-flag\",\n\t\"unspecified\",\n\t\"unspecified\",\n\t\"unspecified\",\n};\n\n#ifndef ARRAY_SIZE\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n#endif\n\nstatic int snprintf_error_data(char *buf, size_t len, uint8_t err,\n\t\t\t       const char **arr, int arr_len)\n{\n\tint i, n = 0, count = 0;\n\n\tif (!err || len <= 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < arr_len; i++) {\n\t\tif (err & (1 << i)) {\n\t\t\tint tmp_n = 0;\n\t\t\tif (count) {\n\t\t\t\t/* Fix for potential buffer overflow https://lgtm.com/rules/1505913226124/ */\n\t\t\t\ttmp_n = snprintf(buf + n, len - n, \",\");\n\t\t\t\tif (tmp_n < 0 || (size_t)tmp_n >= len - n) {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t\tn += tmp_n;\n\t\t\t}\n\t\t\ttmp_n = snprintf(buf + n, len - n, \"%s\", arr[i]);\n\t\t\tif (tmp_n < 0 || (size_t)tmp_n >= len - n) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tn += tmp_n;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn n;\n}\n\nstatic int snprintf_error_lostarb(char *buf, size_t len, const struct canfd_frame *cf)\n{\n\tif (len <= 0)\n\t\treturn 0;\n\treturn snprintf(buf, len, \"{at bit %d}\", cf->data[0]);\n}\n\nstatic int snprintf_error_ctrl(char *buf, size_t len, const struct canfd_frame *cf)\n{\n\tint n = 0;\n\n\tif (len <= 0)\n\t\treturn 0;\n\n\tn += snprintf(buf + n, len - n, \"{\");\n\tn += snprintf_error_data(buf + n, len - n, cf->data[1],\n\t\t\t\tcontroller_problems,\n\t\t\t\tARRAY_SIZE(controller_problems));\n\tn += snprintf(buf + n, len - n, \"}\");\n\n\treturn n;\n}\n\nstatic int snprintf_error_prot(char *buf, size_t len, const struct canfd_frame *cf)\n{\n\tint n = 0;\n\n\tif (len <= 0)\n\t\treturn 0;\n\n\tn += snprintf(buf + n, len - n, \"{{\");\n\tn += snprintf_error_data(buf + n, len - n, cf->data[2],\n\t\t\t\tprotocol_violation_types,\n\t\t\t\tARRAY_SIZE(protocol_violation_types));\n\tn += snprintf(buf + n, len - n, \"}{\");\n\tif (cf->data[3] > 0 &&\n\t    cf->data[3] < ARRAY_SIZE(protocol_violation_locations))\n\t\tn += snprintf(buf + n, len - n, \"%s\",\n\t\t\t      protocol_violation_locations[cf->data[3]]);\n\tn += snprintf(buf + n, len - n, \"}}\");\n\n\treturn n;\n}\n\nstatic int snprintf_error_cnt(char *buf, size_t len, const struct canfd_frame *cf)\n{\n\tint n = 0;\n\n\tif (len <= 0)\n\t\treturn 0;\n\n\tn += snprintf(buf + n, len - n, \"{{%d}{%d}}\",\n\t\t      cf->data[6], cf->data[7]);\n\n\treturn n;\n}\n\nint snprintf_can_error_frame(char *buf, size_t len, const struct canfd_frame *cf,\n                  const char* sep)\n{\n\tcanid_t class, mask;\n\tint i, n = 0, classes = 0;\n\tchar *defsep = \",\";\n\n\tif (!(cf->can_id & CAN_ERR_FLAG))\n\t\treturn 0;\n\n\tclass = cf->can_id & CAN_EFF_MASK;\n\tif (class > (1 << ARRAY_SIZE(error_classes))) {\n\t\tfprintf(stderr, \"Error class %#x is invalid\\n\", class);\n\t\treturn 0;\n\t}\n\n\tif (!sep)\n\t\tsep = defsep;\n\n\tfor (i = 0; i < (int)ARRAY_SIZE(error_classes); i++) {\n\t\tmask = 1 << i;\n\t\tif (class & mask) {\n\t\t\tint tmp_n = 0;\n\t\t\tif (classes) {\n\t\t\t\t/* Fix for potential buffer overflow https://lgtm.com/rules/1505913226124/ */\n\t\t\t\ttmp_n = snprintf(buf + n, len - n, \"%s\", sep);\n\t\t\t\tif (tmp_n < 0 || (size_t)tmp_n >= len - n) {\n\t\t\t\t\tbuf[0] = 0; /* empty terminated string */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tn += tmp_n;\n\t\t\t}\n\t\t\ttmp_n = snprintf(buf + n, len - n, \"%s\", error_classes[i]);\n\t\t\tif (tmp_n < 0 || (size_t)tmp_n >= len - n) {\n\t\t\t\tbuf[0] = 0; /* empty terminated string */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tn += tmp_n;\n\t\t\tif (mask == CAN_ERR_LOSTARB)\n\t\t\t\tn += snprintf_error_lostarb(buf + n, len - n,\n\t\t\t\t\t\t\t   cf);\n\t\t\tif (mask == CAN_ERR_CRTL)\n\t\t\t\tn += snprintf_error_ctrl(buf + n, len - n, cf);\n\t\t\tif (mask == CAN_ERR_PROT)\n\t\t\t\tn += snprintf_error_prot(buf + n, len - n, cf);\n\t\t\tif (mask == CAN_ERR_CNT)\n\t\t\t\tn += snprintf_error_cnt(buf + n, len - n, cf);\n\t\t\tclasses++;\n\t\t}\n\t}\n\n\tif (!(cf->can_id & CAN_ERR_CNT) && (cf->data[6] || cf->data[7])) {\n\t\tn += snprintf(buf + n, len - n, \"%serror-counter-tx-rx\", sep);\n\t\tn += snprintf_error_cnt(buf + n, len - n, cf);\n\t}\n\n\treturn n;\n}\n\nint64_t timespec_diff_ms(struct timespec *ts1,\n\t\t\t\t\t  struct timespec *ts2)\n{\n\tint64_t diff = (ts1->tv_sec - ts2->tv_sec) * 1000;\n\n\tdiff += (ts1->tv_nsec - ts2->tv_nsec) / 1000000;\n\n\treturn diff;\n}\n\nvoid timespec_add_ms(struct timespec *ts, uint64_t milliseconds)\n{\n\tuint64_t total_ns = ts->tv_nsec + (milliseconds * 1000000);\n\n\tts->tv_sec += total_ns / 1000000000;\n\tts->tv_nsec = total_ns % 1000000000;\n}\n"
        },
        {
          "name": "lib.h",
          "type": "blob",
          "size": 10.443359375,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * lib.h - library include for command line tools\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#ifndef CAN_UTILS_LIB_H\n#define CAN_UTILS_LIB_H\n\n#include <stdint.h>\n#include <stddef.h>\n#include <stdio.h>\n\n#ifdef DEBUG\n#define pr_debug(fmt, args...) printf(fmt, ##args)\n#else\n__attribute__((format (printf, 1, 2)))\nstatic inline int pr_debug(const char* fmt, ...) {return 0;}\n#endif\n\n/* CAN CC/FD/XL frame union */\ntypedef union {\n\tstruct can_frame cc;\n\tstruct canfd_frame fd;\n\tstruct canxl_frame xl;\n} cu_t;\n\n/*\n * The buffer size for ASCII CAN frame string representations\n * covers also the 'long' CAN frame output from sprint_long_canframe()\n * including (swapped) binary represetations, timestamps, netdevice names,\n * lengths and error message details as the CAN XL data is cropped to 64\n * byte (the 'long' CAN frame output is only for display on terminals).\n */\n#define AFRSZ 6300 /* 3*2048 (data) + 22 (timestamp) + 18 (netdev) + ID/HDR */\n\n/* CAN DLC to real data length conversion helpers especially for CAN FD */\n\n/* get data length from raw data length code (DLC) */\nunsigned char can_fd_dlc2len(unsigned char dlc);\n\n/* map the sanitized data length to an appropriate data length code */\nunsigned char can_fd_len2dlc(unsigned char len);\n\nunsigned char asc2nibble(char c);\n/*\n * Returns the decimal value of a given ASCII hex character.\n *\n * While 0..9, a..f, A..F are valid ASCII hex characters.\n * On invalid characters the value 16 is returned for error handling.\n */\n\nint hexstring2data(char *arg, unsigned char *data, int maxdlen);\n/*\n * Converts a given ASCII hex string to a (binary) byte string.\n *\n * A valid ASCII hex string consists of an even number of up to 16 chars.\n * Leading zeros '00' in the ASCII hex string are interpreted.\n *\n * Examples:\n *\n * \"1234\"   => data[0] = 0x12, data[1] = 0x34\n * \"001234\" => data[0] = 0x00, data[1] = 0x12, data[2] = 0x34\n *\n * Return values:\n * 0 = success\n * 1 = error (in length or the given characters are no ASCII hex characters)\n *\n * Remark: The not written data[] elements are initialized with zero.\n *\n */\n\nint parse_canframe(char *cs, cu_t *cu);\n/*\n * Transfers a valid ASCII string describing a CAN frame into the CAN union\n * containing CAN CC/FD/XL structs.\n *\n * CAN CC frames (aka Classical CAN, CAN 2.0B)\n * - string layout <can_id>#{R{len}|data}{_len8_dlc}\n * - {data} has 0 to 8 hex-values that can (optionally) be separated by '.'\n * - {len} can take values from 0 to 8 and can be omitted if zero\n * - {_len8_dlc} can take hex values from '_9' to '_F' when len is CAN_MAX_DLEN\n * - return value on successful parsing: CAN_MTU\n *\n * CAN FD frames\n * - string layout <can_id>##<flags>{data}\n * - <flags> a single ASCII Hex value (0 .. F) which defines canfd_frame.flags\n * - {data} has 0 to 64 hex-values that can (optionally) be separated by '.'\n * - return value on successful parsing: CANFD_MTU\n *\n * CAN XL frames\n * - string layout <vcid><prio>#<flags>:<sdt>:<af>#{data}\n * - <vcid> a two ASCII Hex value (00 .. FF) which defines the VCID\n * - <prio> a three ASCII Hex value (000 .. 7FF) which defines the 11 bit PRIO\n * - <flags> a two ASCII Hex value (00 .. FF) which defines canxl_frame.flags\n * - <sdt> a two ASCII Hex value (00 .. FF) which defines canxl_frame.sdt\n * - <af> a 8 digit ASCII Hex value which defines the 32 bit canxl_frame.af\n * - {data} has 1 to 2048 hex-values that can (optionally) be separated by '.'\n * - return value on successful parsing: CANXL_MTU\n *\n * Return value on detected problems: 0\n *\n * <can_id> can have 3 (standard frame format) or 8 (extended frame format)\n * hexadecimal chars\n *\n *\n * Examples:\n *\n * 123# -> standard CAN-Id = 0x123, len = 0\n * 12345678# -> extended CAN-Id = 0x12345678, len = 0\n * 123#R -> standard CAN-Id = 0x123, len = 0, RTR-frame\n * 123#R0 -> standard CAN-Id = 0x123, len = 0, RTR-frame\n * 123#R7 -> standard CAN-Id = 0x123, len = 7, RTR-frame\n * 123#R8_9 -> standard CAN-Id = 0x123, len = 8, dlc = 9, RTR-frame\n * 7A1#r -> standard CAN-Id = 0x7A1, len = 0, RTR-frame\n *\n * 123#00 -> standard CAN-Id = 0x123, len = 1, data[0] = 0x00\n * 123#1122334455667788 -> standard CAN-Id = 0x123, len = 8\n * 123#1122334455667788_E -> standard CAN-Id = 0x123, len = 8, dlc = 14\n * 123#11.22.33.44.55.66.77.88 -> standard CAN-Id = 0x123, len = 8\n * 123#11.2233.44556677.88 -> standard CAN-Id = 0x123, len = 8\n * 32345678#112233 -> error frame with CAN_ERR_FLAG (0x2000000) set\n *\n * 123##0112233 -> CAN FD frame standard CAN-Id = 0x123, flags = 0, len = 3\n * 123##1112233 -> CAN FD frame, flags = CANFD_BRS, len = 3\n * 123##2112233 -> CAN FD frame, flags = CANFD_ESI, len = 3\n * 123##3 -> CAN FD frame, flags = (CANFD_ESI | CANFD_BRS), len = 0\n *     ^^\n *     CAN FD extension to handle the canfd_frame.flags content\n *\n * 45123#81:00:12345678#11223344.556677 -> CAN XL frame with len = 7,\n *   VCID = 0x45, PRIO = 0x123, flags = 0x81, sdt = 0x00, af = 0x12345678\n *\n * Simple facts on this compact ASCII CAN frame representation:\n *\n * - 3 digits: standard frame format\n * - 8 digits: extendend frame format OR error frame\n * - 8 digits with CAN_ERR_FLAG (0x2000000) set: error frame\n * - an error frame is never a RTR frame\n * - CAN FD frames do not have a RTR bit\n */\n\nint snprintf_canframe(char *buf, size_t size, cu_t *cu, int sep);\n/*\n * Creates a CAN frame hexadecimal output in compact format.\n * The CAN data[] is separated by '.' when sep != 0.\n *\n * A CAN XL frame is detected when CANXL_XLF is set in the struct\n * cu.canxl_frame.flags. Otherwise the type of the CAN frame (CAN CC/FD)\n * is specified by the dual-use struct cu.canfd_frame.flags element:\n * w/o  CAN FD flags (== 0) -> CAN CC frame (aka Classical CAN, CAN2.0B)\n * with CAN FD flags (!= 0) -> CAN FD frame (with CANFD_[FDF/BRS/ESI])\n *\n * 12345678#112233 -> extended CAN-Id = 0x12345678, len = 3, data, sep = 0\n * 123#1122334455667788_E -> standard CAN-Id = 0x123, len = 8, dlc = 14, data, sep = 0\n * 12345678#R -> extended CAN-Id = 0x12345678, RTR, len = 0\n * 12345678#R5 -> extended CAN-Id = 0x12345678, RTR, len = 5\n * 123#11.22.33.44.55.66.77.88 -> standard CAN-Id = 0x123, dlc = 8, sep = 1\n * 32345678#112233 -> error frame with CAN_ERR_FLAG (0x2000000) set\n * 123##0112233 -> CAN FD frame standard CAN-Id = 0x123, flags = 0, len = 3\n * 123##2112233 -> CAN FD frame, flags = CANFD_ESI, len = 3\n * 45123#81:00:12345678#11223344.556677 -> CAN XL frame with len = 7,\n *   VCID = 0x45, PRIO = 0x123, flags = 0x81, sdt = 0x00, af = 0x12345678\n *\n */\n\n#define CANLIB_VIEW_ASCII\t0x1\n#define CANLIB_VIEW_BINARY\t0x2\n#define CANLIB_VIEW_SWAP\t0x4\n#define CANLIB_VIEW_ERROR\t0x8\n#define CANLIB_VIEW_INDENT_SFF\t0x10\n#define CANLIB_VIEW_LEN8_DLC\t0x20\n\n#define SWAP_DELIMITER '`'\n\nint snprintf_long_canframe(char *buf, size_t size, cu_t *cu, int view);\n/*\n * Creates a CAN frame hexadecimal output in user readable format.\n *\n * A CAN XL frame is detected when CANXL_XLF is set in the struct\n * cu.canxl_frame.flags. Otherwise the type of the CAN frame (CAN CC/FD)\n * is specified by the dual-use struct cu.canfd_frame.flags element:\n * w/o  CAN FD flags (== 0) -> CAN CC frame (aka Classical CAN, CAN2.0B)\n * with CAN FD flags (!= 0) -> CAN FD frame (with CANFD_[FDF/BRS/ESI])\n *\n * 12345678   [3]  11 22 33 -> extended CAN-Id = 0x12345678, len = 3, data\n * 12345678   [0]  remote request -> extended CAN-Id = 0x12345678, RTR\n * 14B0DC51   [8]  4A 94 E8 2A EC 58 55 62   'J..*.XUb' -> (with ASCII output)\n * 321   {B}  11 22 33 44 55 66 77 88 -> Classical CAN with raw '{DLC}' value B\n * 20001111   [7]  C6 23 7B 32 69 98 3C      ERRORFRAME -> (CAN_ERR_FLAG set)\n * 12345678  [03]  11 22 33 -> CAN FD with extended CAN-Id = 0x12345678, len = 3\n *      123 [0003] (45|81:00:12345678) 11 22 33 -> CAN XL frame with VCID 0x45\n *\n * 123   [3]  11 22 33         -> CANLIB_VIEW_INDENT_SFF == 0\n *      123   [3]  11 22 33    -> CANLIB_VIEW_INDENT_SFF == set\n *\n * There are no binary or ASCII view modes for CAN XL and the number of displayed\n * data bytes is limited to 64 to fit terminal output use-cases.\n */\n\nint snprintf_can_error_frame(char *buf, size_t len, const struct canfd_frame *cf,\n\t\t\t     const char *sep);\n/*\n * Creates a CAN error frame output in user readable format.\n */\n\n/**\n * timespec_diff_ms - calculate timespec difference in milliseconds\n * @ts1: first timespec\n * @ts2: second timespec\n *\n * Return negative difference if in the past.\n */\nint64_t timespec_diff_ms(struct timespec *ts1, struct timespec *ts2);\n\n/**\n * timespec_add_ms - add milliseconds to timespec\n * @ts: timespec\n * @milliseconds: milliseconds to add\n */\nvoid timespec_add_ms(struct timespec *ts, uint64_t milliseconds);\n\n#endif\n"
        },
        {
          "name": "libj1939.c",
          "type": "blob",
          "size": 9.4404296875,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (c) 2011 EIA Electronics\n *\n * Authors:\n * Kurt Van Dijck <kurt.van.dijck@eia.be>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n */\n\n#include <err.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <linux/kernel.h>\n#include <net/if.h>\n#include <net/if.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"libj1939.h\"\n#include \"lib.h\"\n\n/* static data */\nstatic struct if_nameindex *saved;\n\n__attribute__((destructor))\nstatic void libj1939_cleanup(void)\n{\n\tif (saved)\n\t\tif_freenameindex(saved);\n\tsaved = 0;\n}\n\nstatic inline void fetch_names(void)\n{\n\tif (!saved) {\n\t\tsaved = if_nameindex();\n\t\tif (!saved)\n\t\t\terr(1, \"if_nameindex()\");\n\t}\n}\n\n/* retrieve name */\nstatic const char *libj1939_ifnam(int ifindex)\n{\n\tconst struct if_nameindex *lp, *cached = saved;\n\n\tfetch_names();\n\n\tfor (lp = saved; lp->if_index; ++lp) {\n\t\tif (lp->if_index == (unsigned int)ifindex)\n\t\t\treturn lp->if_name;\n\t}\n\tif (cached) {\n\t\t/*\n\t\t * the list was not recent\n\t\t * iterate twice, but force a refresh now\n\t\t * recursion stops since the 'saved' pointer is cleaned\n\t\t */\n\t\tlibj1939_cleanup();\n\t\treturn libj1939_ifnam(ifindex);\n\t}\n\treturn NULL;\n}\n\n/* retrieve index */\nstatic int libj1939_ifindex(const char *str)\n{\n\tconst struct if_nameindex *lp, *cached = saved;\n\tchar *endp;\n\tint ret;\n\n\tret = strtol(str, &endp, 0);\n\tif (!*endp)\n\t\t/* did some good parse */\n\t\treturn ret;\n\n\tfetch_names();\n\tfor (lp = saved; lp->if_index; ++lp) {\n\t\tif (!strcmp(lp->if_name, str))\n\t\t\treturn lp->if_index;\n\t}\n\tif (cached) {\n\t\tlibj1939_cleanup();\n\t\treturn libj1939_ifindex(str);\n\t}\n\treturn 0;\n}\n\nvoid libj1939_parse_canaddr(char *spec, struct sockaddr_can *paddr)\n{\n\tchar *str;\n\n\tstr = strsep(&spec, \":\");\n\tif (strlen(str))\n\t\tpaddr->can_ifindex = if_nametoindex(str);\n\n\tstr = strsep(&spec, \",\");\n\tif (str && strlen(str))\n\t\tpaddr->can_addr.j1939.addr = strtoul(str, NULL, 0);\n\n\tstr = strsep(&spec, \",\");\n\tif (str && strlen(str))\n\t\tpaddr->can_addr.j1939.pgn = strtoul(str, NULL, 0);\n\n\tstr = strsep(&spec, \",\");\n\tif (str && strlen(str))\n\t\tpaddr->can_addr.j1939.name = strtoull(str, NULL, 0);\n}\n\nint libj1939_str2addr(const char *str, char **endp, struct sockaddr_can *can)\n{\n\tchar *p;\n\tconst char *pstr;\n\tuint64_t tmp64;\n\tunsigned long tmp;\n\n\tif (!endp)\n\t\tendp = &p;\n\tmemset(can, 0, sizeof(*can));\n\tcan->can_family = AF_CAN;\n\tcan->can_addr.j1939.name = J1939_NO_NAME;\n\tcan->can_addr.j1939.addr = J1939_NO_ADDR;\n\tcan->can_addr.j1939.pgn = J1939_NO_PGN;\n\n\tpstr = strchr(str, ':');\n\tif (pstr) {\n\t\tchar tmp[IFNAMSIZ];\n\t\tif ((pstr - str) >= IFNAMSIZ)\n\t\t\treturn -1;\n\t\tstrncpy(tmp, str, pstr - str);\n\t\ttmp[pstr - str] = 0;\n\t\tcan->can_ifindex = libj1939_ifindex(tmp);\n\t} else {\n\t\tcan->can_ifindex = libj1939_ifindex(str);\n\t\tif (can->can_ifindex) {\n\t\t\tif (endp)\n\t\t\t\t*endp = (char *)&str[strlen(str)];\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (pstr)\n\t\t++pstr;\n\telse\n\t\tpstr = str;\n\n\n\ttmp64 = strtoull(pstr, endp, 16);\n\tif (*endp <= pstr)\n\t\treturn 0;\n\tif ((*endp - pstr) == 2)\n\t\tcan->can_addr.j1939.addr = tmp64;\n\telse\n\t\tcan->can_addr.j1939.name = tmp64;\n\tif (!**endp)\n\t\treturn 0;\n\n\tstr = *endp + 1;\n\ttmp = strtoul(str, endp, 16);\n\tif (*endp > str)\n\t\tcan->can_addr.j1939.pgn = tmp;\n\treturn 0;\n}\n\nconst char *libj1939_addr2str(const struct sockaddr_can *can)\n{\n\tchar *str;\n\tstatic char buf[128];\n\n\tstr = buf;\n\tif (can->can_ifindex) {\n\t\tconst char *ifname;\n\t\tifname = libj1939_ifnam(can->can_ifindex);\n\t\tif (!ifname)\n\t\t\tstr += sprintf(str, \"#%i:\", can->can_ifindex);\n\t\telse\n\t\t\tstr += sprintf(str, \"%s:\", ifname);\n\t}\n\tif (can->can_addr.j1939.name) {\n\t\tstr += sprintf(str, \"%016llx\", (unsigned long long)can->can_addr.j1939.name);\n\t\tif (can->can_addr.j1939.pgn == J1939_PGN_ADDRESS_CLAIMED)\n\t\t\tstr += sprintf(str, \".%02x\", can->can_addr.j1939.addr);\n\t} else if (can->can_addr.j1939.addr <= 0xfe)\n\t\tstr += sprintf(str, \"%02x\", can->can_addr.j1939.addr);\n\telse\n\t\tstr += sprintf(str, \"-\");\n\tif (can->can_addr.j1939.pgn <= J1939_PGN_MAX)\n\t\tstr += sprintf(str, \",%05x\", can->can_addr.j1939.pgn);\n\n\treturn buf;\n}\n\nvoid libj1939_init_sockaddr_can(struct sockaddr_can *sac, uint32_t pgn)\n{\n\tsac->can_family = AF_CAN;\n\tsac->can_addr.j1939.addr = J1939_NO_ADDR;\n\tsac->can_addr.j1939.name = J1939_NO_NAME;\n\tsac->can_addr.j1939.pgn = pgn;\n}\n\n/**\n * libj1939_open_socket - Open a new J1939 socket\n *\n * This function opens a new J1939 socket.\n *\n * Return: The file descriptor of the new socket, or a negative error code.\n */\nint libj1939_open_socket(void)\n{\n\tint ret;\n\n\t/* Create a new CAN J1939 socket */\n\tret = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n\tif (ret < 0) {\n\t\t/* Get the error code and print an error message */\n\t\tret = -errno;\n\t\tpr_err(\"socket(j1939): %d (%s)\", ret, strerror(ret));\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n/**\n * libj1939_bind_socket - Bind a J1939 socket to a specific address\n * @sock: The file descriptor of the socket\n * @addr: The address to bind to\n *\n * This function binds a J1939 socket to a specific address.\n *\n * Return: 0 on success, or a negative error code.\n */\nint libj1939_bind_socket(int sock, struct sockaddr_can *addr)\n{\n\tint ret;\n\n\tret = bind(sock, (void *)addr, sizeof(*addr));\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"failed to bind: %d (%s)\", ret, strerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * libj1939_socket_prio - Set the priority of a J1939 socket\n * @sock: The file descriptor of the socket\n * @prio: The priority to set\n *\n * This function sets the priority of a J1939 socket.\n *\n * Return: 0 on success, or a negative error code.\n */\nint libj1939_socket_prio(int sock, int prio)\n{\n\tint ret;\n\n\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_SEND_PRIO,\n\t\t\t &prio, sizeof(prio));\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tpr_warn(\"Failed to set priority %i. Error %i (%s)\", prio, ret,\n\t\t\tstrerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * libj1939_set_broadcast - Enable broadcast on a J1939 socket\n * @sock: The file descriptor of the socket\n *\n * This function enables broadcast on a J1939 socket.\n *\n * Return: 0 on success, or a negative error code.\n */\nint libj1939_set_broadcast(int sock)\n{\n\tint broadcast = true;\n\tint ret;\n\n\tret = setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &broadcast,\n\t\t\t sizeof(broadcast));\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"setsockopt(SO_BROADCAST): %d (%s)\", ret, strerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * libj1939_add_socket_to_epoll - Add a socket to an epoll instance\n * @epoll_fd: The file descriptor of the epoll instance\n * @sock: The file descriptor of the socket\n * @events: The events to monitor\n *\n * This function adds a socket to an epoll instance.\n *\n * Return: 0 on success, or a negative error code.\n */\nint libj1939_add_socket_to_epoll(int epoll_fd, int sock, uint32_t events)\n{\n\tstruct epoll_event ev = {0};\n\tint ret;\n\n\tev.events = events;\n\tev.data.fd = sock;\n\n\tret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sock, &ev);\n\tif (ret < 0) {\n\t\tret = errno;\n\t\tpr_err(\"epoll_ctl(EPOLL_CTL_ADD): %d (%s)\", ret, strerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * libj1939_create_epoll - Create a new epoll instance\n *\n * This function creates a new epoll instance.\n *\n * Return: The file descriptor of the new epoll instance, or a negative error\n * code.\n */\nint libj1939_create_epoll(void)\n{\n\tint ret, epoll_fd;\n\n\tepoll_fd = epoll_create1(0);\n\tif (epoll_fd < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"epoll_create1: %d (%s)\", ret, strerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn epoll_fd;\n}\n\n/**\n * libj1939_get_timeout_ms - Get the timeout in milliseconds until a specific\n *\t\t\t     time\n * @ts: The time to wait for\n * @return: The timeout in milliseconds until the specified time\n *\n * This function calculates the timeout in milliseconds until a specific time.\n *\n * Return: The timeout in milliseconds until the specified time.\n */\nstatic int libj1939_get_timeout_ms(struct timespec *ts)\n{\n\tstruct timespec curr_time;\n\tint64_t time_diff;\n\tint timeout_ms;\n\n\tclock_gettime(CLOCK_MONOTONIC, &curr_time);\n\ttime_diff = timespec_diff_ms(ts, &curr_time);\n\tif (time_diff < 0) {\n\t\t/* Too late to send next message. Send it now */\n\t\ttimeout_ms = 0;\n\t} else {\n\t\tif (time_diff > INT_MAX) {\n\t\t\tpr_warn(\"timeout too long: %\" PRId64 \" ms\", time_diff);\n\t\t\ttime_diff = INT_MAX;\n\t\t}\n\n\t\ttimeout_ms = time_diff;\n\t}\n\n\treturn timeout_ms;\n}\n\n/**\n * libj1939_prepare_for_events - Prepare and wait for events on an epoll\n * @cmn: The common J1939 instance data\n * @nfds: The number of file descriptors that are ready\n * @dont_wait: Don't wait for events, just check if there are any\n *\n * This function calculates the timeout until the next message should be sent\n * or any other event should be handled, prepares the epoll instance for events\n * by waiting for the specified timeout or until an event occurs, and waits for\n * events on the epoll instance.\n *\n * Return: 0 on success, or a negative error code.\n */\nint libj1939_prepare_for_events(struct libj1939_cmn *cmn, int *nfds,\n\t\t\t\tbool dont_wait)\n{\n\tint ret, timeout_ms;\n\n\tif (dont_wait)\n\t\ttimeout_ms = 0;\n\telse\n\t\ttimeout_ms = libj1939_get_timeout_ms(&cmn->next_send_time);\n\n\tret = epoll_wait(cmn->epoll_fd, cmn->epoll_events,\n\t\t\t cmn->epoll_events_size, timeout_ms);\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tif (ret != -EINTR) {\n\t\t\t*nfds = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*nfds = ret;\n\n\tret = clock_gettime(CLOCK_MONOTONIC, &cmn->last_time);\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tpr_err(\"failed to get time: %i (%s)\", ret, strerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n"
        },
        {
          "name": "libj1939.h",
          "type": "blob",
          "size": 1.48828125,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (c) 2011 EIA Electronics\n *\n * Authors:\n * Kurt Van Dijck <kurt.van.dijck@eia.be>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n */\n\n/* needed on some 64 bit platforms to get consistent 64-bit types */\n#define __SANE_USERSPACE_TYPES__\n\n#include <linux/can.h>\n#include <linux/can/j1939.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/socket.h>\n\n#ifndef J1939_LIB_H\n#define J1939_LIB_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct libj1939_cmn {\n\tint epoll_fd;\n\tstruct epoll_event *epoll_events;\n\tsize_t epoll_events_size;\n\tstruct timespec next_send_time;\n\tstruct timespec last_time;\n};\n\nvoid libj1939_parse_canaddr(char *spec, struct sockaddr_can *paddr);\nextern int libj1939_str2addr(const char *str, char **endp, struct sockaddr_can *can);\nextern const char *libj1939_addr2str(const struct sockaddr_can *can);\n\nvoid libj1939_init_sockaddr_can(struct sockaddr_can *sac, uint32_t pgn);\n\nint libj1939_open_socket(void);\nint libj1939_bind_socket(int sock, struct sockaddr_can *addr);\nint libj1939_socket_prio(int sock, int prio);\nint libj1939_set_broadcast(int sock);\nint libj1939_add_socket_to_epoll(int epoll_fd, int sock, uint32_t events);\nint libj1939_create_epoll(void);\n\nint libj1939_prepare_for_events(struct libj1939_cmn *cmn, int *nfds,\n\t\t\t\tbool dont_wait);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "log2asc.c",
          "type": "blob",
          "size": 9.4775390625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * log2asc.c - convert compact CAN frame logfile to ASC logfile\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <libgen.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <linux/can.h>\n#include <net/if.h>\n#include <sys/time.h>\n\n#include \"lib.h\"\n\nextern int optind, opterr, optopt;\n\nstatic void print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - convert compact CAN frame logfile to ASC logfile.\\n\", prg);\n\tfprintf(stderr, \"Usage: %s <options> [can-interfaces]\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -I <infile>   (default stdin)\\n\");\n\tfprintf(stderr, \"         -O <outfile>  (default stdout)\\n\");\n\tfprintf(stderr, \"         -4  (reduce decimal place to 4 digits)\\n\");\n\tfprintf(stderr, \"         -n  (set newline to cr/lf - default lf)\\n\");\n\tfprintf(stderr, \"         -f  (use CANFD format also for Classic CAN)\\n\");\n\tfprintf(stderr, \"         -r  (suppress dlc for RTR frames - pre v8.5 tools)\\n\");\n}\n\nstatic void can_asc(struct canfd_frame *cfd, int devno, int nortrdlc,\n\t\t    char *extra_info, FILE *outfile)\n{\n\tint i;\n\tchar id[10];\n\tchar *dir = \"Rx\";\n\tint dlc;\n\tstruct can_frame *cf = (struct can_frame *)cfd; /* for len8_dlc */\n\n\tfprintf(outfile, \"%-2d \", devno); /* channel number left aligned */\n\n\tif (cf->can_id & CAN_ERR_FLAG)\n\t\tfprintf(outfile, \"ErrorFrame\");\n\telse {\n\t\tsprintf(id, \"%X%c\", cf->can_id & CAN_EFF_MASK,\n\t\t\t(cf->can_id & CAN_EFF_FLAG)?'x':' ');\n\n\t\t/* check for extra info */\n\t\tif (strlen(extra_info) > 0) {\n\t\t\t/* only the first char is defined so far */\n\t\t\tif (extra_info[0] == 'T')\n\t\t\t\tdir = \"Tx\";\n\t\t}\n\n\t\tfprintf(outfile, \"%-15s %s   \", id, dir);\n\n\t\tif (cf->len == CAN_MAX_DLC &&\n\t\t    cf->len8_dlc > CAN_MAX_DLC &&\n\t\t    cf->len8_dlc <= CAN_MAX_RAW_DLC)\n\t\t\tdlc = cf->len8_dlc;\n\t\telse\n\t\t\tdlc = cf->len;\n\n\t\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\t\tif (nortrdlc)\n\t\t\t\tfprintf(outfile, \"r\"); /* RTR frame */\n\t\t\telse\n\t\t\t\tfprintf(outfile, \"r %X\", dlc); /* RTR frame */\n\t\t} else {\n\t\t\tfprintf(outfile, \"d %X\", dlc); /* data frame */\n\n\t\t\tfor (i = 0; i < cf->len; i++) {\n\t\t\t\tfprintf(outfile, \" %02X\", cf->data[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void canfd_asc(struct canfd_frame *cf, int devno, int mtu,\n\t\t      char *extra_info, FILE *outfile)\n{\n\tint i;\n\tchar id[10];\n\tchar *dir = \"Rx\";\n\tunsigned int flags = 0;\n\tunsigned int dlen = cf->len;\n\tunsigned int dlc = can_fd_len2dlc(dlen);\n\n\t/* relevant flags in Flags field */\n#define ASC_F_RTR 0x00000010\n#define ASC_F_FDF 0x00001000\n#define ASC_F_BRS 0x00002000\n#define ASC_F_ESI 0x00004000\n\n\t/* check for extra info */\n\tif (strlen(extra_info) > 0) {\n\t\t/* only the first char is defined so far */\n\t\tif (extra_info[0] == 'T')\n\t\t\tdir = \"Tx\";\n\t}\n\n\tfprintf(outfile, \"CANFD %3d %s \", devno, dir); /* 3 column channel number right aligned */\n\n\tsprintf(id, \"%X%c\", cf->can_id & CAN_EFF_MASK,\n\t\t(cf->can_id & CAN_EFF_FLAG)?'x':' ');\n\tfprintf(outfile, \"%11s                                  \", id);\n\tfprintf(outfile, \"%c \", (cf->flags & CANFD_BRS)?'1':'0');\n\tfprintf(outfile, \"%c \", (cf->flags & CANFD_ESI)?'1':'0');\n\n\t/* check for extra DLC when having a Classic CAN with 8 bytes payload */\n\tif ((mtu == CAN_MTU) && (dlen == CAN_MAX_DLEN)) {\n\t\tstruct can_frame *ccf = (struct can_frame *)cf;\n\n\t\tif ((ccf->len8_dlc > CAN_MAX_DLEN) && (ccf->len8_dlc <= CAN_MAX_RAW_DLC))\n\t\t\tdlc = ccf->len8_dlc;\n\t}\n\n\tfprintf(outfile, \"%x \", dlc);\n\n\tif (mtu == CAN_MTU) {\n\t\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\t\t/* no data length but dlc for RTR frames */\n\t\t\tdlen = 0;\n\t\t\tflags = ASC_F_RTR;\n\t\t}\n\t} else {\n\t\tflags = ASC_F_FDF;\n\t\tif (cf->flags & CANFD_BRS)\n\t\t\tflags |= ASC_F_BRS;\n\t\tif (cf->flags & CANFD_ESI)\n\t\t\tflags |= ASC_F_ESI;\n\t}\n\n\tfprintf(outfile, \"%2d\", dlen);\n\n\tfor (i = 0; i < (int)dlen; i++) {\n\t\tfprintf(outfile, \" %02X\", cf->data[i]);\n\t}\n\n\tfprintf(outfile, \" %8d %4d %8X 0 0 0 0 0\", 130000, 130, flags);\n}\n\n#define DEVSZ 22\n#define EXTRASZ 20\n#define TIMESZ sizeof(\"(1345212884.318850)   \")\n#define BUFSZ (DEVSZ + AFRSZ + EXTRASZ + TIMESZ)\n\n/* adapt sscanf() functions below on error */\n#if (AFRSZ != 6300)\n#error \"AFRSZ value does not fit sscanf restrictions!\"\n#endif\n#if (DEVSZ != 22)\n#error \"DEVSZ value does not fit sscanf restrictions!\"\n#endif\n#if (EXTRASZ != 20)\n#error \"EXTRASZ value does not fit sscanf restrictions!\"\n#endif\n\nint main(int argc, char **argv)\n{\n\tstatic char buf[BUFSZ], device[DEVSZ], afrbuf[AFRSZ], extra_info[EXTRASZ];\n\n\tstatic cu_t cu;\n\tstatic struct timeval tv, start_tv;\n\tFILE *infile = stdin;\n\tFILE *outfile = stdout;\n\tstatic int maxdev, devno, i, crlf, fdfmt, nortrdlc, d4, opt, mtu;\n\tint print_banner = 1;\n\tunsigned long long sec, usec;\n\n\twhile ((opt = getopt(argc, argv, \"I:O:4nfr?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'I':\n\t\t\tinfile = fopen(optarg, \"r\");\n\t\t\tif (!infile) {\n\t\t\t\tperror(\"infile\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\toutfile = fopen(optarg, \"w\");\n\t\t\tif (!outfile) {\n\t\t\t\tperror(\"outfile\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tcrlf = 1;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tfdfmt = 1;\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\tnortrdlc = 1;\n\t\t\tbreak;\n\n\t\tcase '4':\n\t\t\td4 = 1;\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown option %c\\n\", opt);\n\t\t\tprint_usage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmaxdev = argc - optind; /* find real number of CAN devices */\n\n\tif (!maxdev) {\n\t\tfprintf(stderr, \"no CAN interfaces defined!\\n\");\n\t\tprint_usage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\t\n\t//printf(\"Found %d CAN devices!\\n\", maxdev);\n\n\twhile (fgets(buf, BUFSZ-1, infile)) {\n\n\t\tif (strlen(buf) >= BUFSZ-2) {\n\t\t\tfprintf(stderr, \"line too long for input buffer\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* check for a comment line */\n\t\tif (buf[0] != '(')\n\t\t\tcontinue;\n\n\t\tif (sscanf(buf, \"(%llu.%llu) %21s %6299s %19s\", &sec, &usec,\n\t\t\t   device, afrbuf, extra_info) != 5) {\n\n\t\t\t/* do not evaluate the extra info */\n\t\t\textra_info[0] = 0;\n\n\t\t\tif (sscanf(buf, \"(%llu.%llu) %21s %6299s\", &sec, &usec,\n\t\t\t\t   device, afrbuf) != 4) {\n\t\t\t\tfprintf(stderr, \"incorrect line format in logfile\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\n\t\tif (print_banner) { /* print banner */\n\t\t\tprint_banner = 0;\n\t\t\tstart_tv = tv;\n\t\t\tfprintf(outfile, \"date %s\", ctime(&start_tv.tv_sec));\n\t\t\tfprintf(outfile, \"base hex  timestamps absolute%s\",\n\t\t\t\t(crlf)?\"\\r\\n\":\"\\n\");\n\t\t\tfprintf(outfile, \"no internal events logged%s\",\n\t\t\t\t(crlf)?\"\\r\\n\":\"\\n\");\n\t\t}\n\n\t\tfor (i = 0, devno = 0; i < maxdev; i++) {\n\t\t\tif (!strcmp(device, argv[optind+i])) {\n\t\t\t\tdevno = i + 1; /* start with channel '1' */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (devno) { /* only convert for selected CAN devices */\n\n\t\t\tmtu = parse_canframe(afrbuf, &cu);\n\n\t\t\t/* convert only CAN CC and CAN FD frames */\n\t\t\tif ((mtu != CAN_MTU) && (mtu != CANFD_MTU)) {\n\t\t\t\tprintf(\"no valid CAN CC/FD frame\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t/* we don't support error message frames in CAN FD */\n\t\t\tif ((mtu == CANFD_MTU) && (cu.cc.can_id & CAN_ERR_FLAG))\n\t\t\t\tcontinue;\n\n\t\t\ttv.tv_sec  = tv.tv_sec - start_tv.tv_sec;\n\t\t\ttv.tv_usec = tv.tv_usec - start_tv.tv_usec;\n\t\t\tif (tv.tv_usec < 0)\n\t\t\t\ttv.tv_sec--, tv.tv_usec += 1000000;\n\t\t\tif (tv.tv_sec < 0)\n\t\t\t\ttv.tv_sec = tv.tv_usec = 0;\n\n\t\t\tif (d4)\n\t\t\t\tfprintf(outfile, \"%4llu.%04llu \", (unsigned long long)tv.tv_sec, (unsigned long long)tv.tv_usec/100);\n\t\t\telse\n\t\t\t\tfprintf(outfile, \"%4llu.%06llu \", (unsigned long long)tv.tv_sec, (unsigned long long)tv.tv_usec);\n\n\t\t\tif ((mtu == CAN_MTU) && (fdfmt == 0))\n\t\t\t\tcan_asc(&cu.fd, devno, nortrdlc, extra_info, outfile);\n\t\t\telse\n\t\t\t\tcanfd_asc(&cu.fd, devno, mtu, extra_info, outfile);\n\n\t\t\tif (crlf)\n\t\t\t\tfprintf(outfile, \"\\r\");\n\t\t\tfprintf(outfile, \"\\n\");\n\t\t}\n\t}\n\tfflush(outfile);\n\tfclose(outfile);\n\tfclose(infile);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "log2long.c",
          "type": "blob",
          "size": 3.4619140625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * log2long.c - convert compact CAN frame representation into user readable\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <linux/can.h>\n#include <net/if.h>\n\n#include \"lib.h\"\n\n#define DEVSZ 22\n#define TIMESZ 22 /* sizeof(\"(1345212884.318850)   \") */\n#define BUFSZ (DEVSZ + AFRSZ + TIMESZ)\n\n/* adapt sscanf() functions below on error */\n#if (AFRSZ != 6300)\n#error \"AFRSZ value does not fit sscanf restrictions!\"\n#endif\n#if (DEVSZ != 22)\n#error \"DEVSZ value does not fit sscanf restrictions!\"\n#endif\n#if (TIMESZ != 22)\n#error \"TIMESZ value does not fit sscanf restrictions!\"\n#endif\n\nint main(void)\n{\n\tstatic char buf[BUFSZ], timestamp[TIMESZ], device[DEVSZ], afrbuf[AFRSZ];\n\tstatic cu_t cu;\n\tint mtu;\n\n\twhile (fgets(buf, BUFSZ-1, stdin)) {\n\n\t\tif (strlen(buf) >= BUFSZ-2) {\n\t\t\tfprintf(stderr, \"line too long for input buffer\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (sscanf(buf, \"%21s %21s %6299s\", timestamp, device, afrbuf) != 3)\n\t\t\treturn 1;\n\n\t\tmtu = parse_canframe(afrbuf, &cu);\n\n\t\t/* mark dual-use struct canfd_frame - no CAN_XL support */\n\t\tif (mtu == CAN_MTU)\n\t\t\tcu.fd.flags = 0;\n\t\telse if (mtu == CANFD_MTU)\n\t\t\tcu.fd.flags |= CANFD_FDF;\n\t\telse {\n\t\t\tfprintf(stderr, \"read: no valid CAN CC/FD frame\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* with ASCII output */\n\t\tsnprintf_long_canframe(afrbuf, sizeof(afrbuf), &cu,\n\t\t\t\t       (CANLIB_VIEW_INDENT_SFF | CANLIB_VIEW_ASCII));\n\n\t\tprintf(\"%s  %s  %s\\n\", timestamp, device, afrbuf);\n\t}\n\n\treturn 0;\n}\n"
        },
        {
          "name": "mcp251xfd",
          "type": "tree",
          "content": null
        },
        {
          "name": "page.theme",
          "type": "blob",
          "size": 0.2646484375,
          "content": "<!DOCTYPE html>\n<html>\n<head>\n\t<title>page: <?theme title?></title>\n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n\t<style>\n\ndiv#toc li {\n\tlist-style\t: none;\n}\n\t</style>\n</head>\n<body>\n<div id='toc'>\n<?theme toc?>\n</div>\n<?theme body?>\n</div>\n</body>\n</html>\n\n"
        },
        {
          "name": "slcan_attach.c",
          "type": "blob",
          "size": 7.1181640625,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * slcan_attach.c - userspace tool for serial line CAN interface driver SLCAN\n *\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <fcntl.h>\n#include <getopt.h>\n#include <linux/sockios.h>\n#include <linux/tty.h>\n#include <net/if.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <termios.h>\n#include <unistd.h>\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - userspace tool for serial line CAN interface driver SLCAN.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options] tty\\n\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -o          (send open command 'O\\\\r')\\n\");\n\tfprintf(stderr, \"         -l          (send listen only command 'L\\\\r', overrides -o)\\n\");\n\tfprintf(stderr, \"         -c          (send close command 'C\\\\r')\\n\");\n\tfprintf(stderr, \"         -f          (read status flags with 'F\\\\r' to reset error states)\\n\");\n\tfprintf(stderr, \"         -s <speed>  (set CAN speed 0..8)\\n\");\n\tfprintf(stderr, \"         -b <btr>    (set bit time register value)\\n\");\n\tfprintf(stderr, \"         -d          (only detach line discipline)\\n\");\n\tfprintf(stderr, \"         -w          (attach - wait for keypress - detach)\\n\");\n\tfprintf(stderr, \"         -n <name>   (assign created netdevice name)\\n\");\n\tfprintf(stderr, \"\\n\"\n\t\t\t\"    <speed>          Bitrate\\n\"\n\t\t\t\"          0            10 Kbit/s\\n\"\n\t\t\t\"          1            20 Kbit/s\\n\"\n\t\t\t\"          2            50 Kbit/s\\n\"\n\t\t\t\"          3           100 Kbit/s\\n\"\n\t\t\t\"          4           125 Kbit/s\\n\"\n\t\t\t\"          5           250 Kbit/s\\n\"\n\t\t\t\"          6           500 Kbit/s\\n\"\n\t\t\t\"          7           800 Kbit/s\\n\"\n\t\t\t\"          8          1000 Kbit/s\\n\"\n\t\t\t\"\\n\");\n\tfprintf(stderr, \"\\nExamples:\\n\");\n\tfprintf(stderr, \"slcan_attach -w -o -f -s6 -c /dev/ttyS1\\n\\n\");\n\tfprintf(stderr, \"slcan_attach /dev/ttyS1\\n\\n\");\n\tfprintf(stderr, \"slcan_attach -d /dev/ttyS1\\n\\n\");\n\tfprintf(stderr, \"slcan_attach -w -n can15 /dev/ttyS1\\n\\n\");\n\texit(1);\n}\n\nint main(int argc, char **argv)\n{\n\tint fd;\n\tint ldisc = N_SLCAN;\n\tint detach = 0;\n\tint waitkey = 0;\n\tint send_open = 0;\n\tint send_listen = 0;\n\tint send_close = 0;\n\tint send_read_status_flags = 0;\n\tchar *speed = NULL;\n\tchar *btr = NULL;\n\tchar buf[20];\n\tstatic struct ifreq ifr;\n\tchar *tty;\n\tchar *name = NULL;\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"ldwocfs:b:n:?\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'd':\n\t\t\tdetach = 1;\n\t\t\tbreak;\n\n\t\tcase 'w':\n\t\t\twaitkey = 1;\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\t\tsend_open = 1;\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\tsend_listen = 1;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tsend_close = 1;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\tsend_read_status_flags = 1;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tspeed = optarg;\n\t\t\tif (strlen(speed) > 1)\n\t\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tbtr = optarg;\n\t\t\tif (strlen(btr) > 8)\n\t\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tname = optarg;\n\t\t\tif (strlen(name) > sizeof(ifr.ifr_newname) - 1)\n\t\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\tdefault:\n\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (argc - optind != 1)\n\t\tprint_usage(argv[0]);\n\n\ttty = argv[optind];\n\n\tif ((fd = open (tty, O_WRONLY | O_NOCTTY)) < 0) {\n\t\tperror(tty);\n\t\texit(1);\n\t}\n\n\tif (waitkey || !detach) {\n\n\t\tif (speed) {\n\t\t\tsprintf(buf, \"C\\rS%s\\r\", speed);\n\t\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\t\tperror(\"write\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\n\t\tif (btr) {\n\t\t\tsprintf(buf, \"C\\rs%s\\r\", btr);\n\t\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\t\tperror(\"write\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\n\t\tif (send_read_status_flags) {\n\t\t\tsprintf(buf, \"F\\r\");\n\t\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\t\tperror(\"write\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\n\t\tif (send_listen) {\n\t\t\tsprintf(buf, \"L\\r\");\n\t\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\t\tperror(\"write\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t} else if (send_open) {\n\t\t\tsprintf(buf, \"O\\r\");\n\t\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\t\tperror(\"write\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\n\t\t/* set slcan line discipline on given tty */\n\t\tif (ioctl (fd, TIOCSETD, &ldisc) < 0) {\n\t\t\tperror(\"ioctl TIOCSETD\");\n\t\t\texit(1);\n\t\t}\n\n\t\t/* retrieve the name of the created CAN netdevice */\n\t\tif (ioctl (fd, SIOCGIFNAME, ifr.ifr_name) < 0) {\n\t\t\tperror(\"ioctl SIOCGIFNAME\");\n\t\t\texit(1);\n\t\t}\n\n\t\tprintf(\"attached tty %s to netdevice %s\\n\", tty, ifr.ifr_name);\n\n\t\t/* try to rename the created device if requested */\n\t\tif (name) {\n\t\t\tint s = socket(PF_INET, SOCK_DGRAM, 0);\n\n\t\t\tprintf(\"rename netdevice %s to %s ... \", buf, name);\n\n\t\t\tif (s < 0)\n\t\t\t\tperror(\"socket for interface rename\");\n\t\t\telse {\n\t\t\t\t/* current slcan%d name is still in ifr.ifr_name */\n\t\t\t\tmemset (ifr.ifr_newname, 0, sizeof(ifr.ifr_newname));\n\t\t\t\tstrncpy (ifr.ifr_newname, name, sizeof(ifr.ifr_newname) - 1);\n\n\t\t\t\tif (ioctl(s, SIOCSIFNAME, &ifr) < 0)\n\t\t\t\t\tprintf(\"failed!\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"ok.\\n\");\n\n\t\t\t\tclose(s);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (waitkey) {\n\t\tprintf(\"Press any key to detach %s ...\\n\", tty);\n\t\tgetchar();\n\t}\n\n\tif (waitkey || detach) {\n\t\tldisc = N_TTY;\n\t\tif (ioctl (fd, TIOCSETD, &ldisc) < 0) {\n\t\t\tperror(\"ioctl\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (send_close) {\n\t\t\tsprintf(buf, \"C\\r\");\n\t\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\t\tperror(\"write\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(fd);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "slcand.c",
          "type": "blob",
          "size": 10.525390625,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * slcand.c - userspace daemon for serial line CAN interface driver SLCAN\n *\n * Copyright (c) 2009 Robert Haddon <robert.haddon@verari.com>\n * Copyright (c) 2009 Verari Systems Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/serial.h>\n#include <linux/sockios.h>\n#include <linux/tty.h>\n#include <net/if.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <syslog.h>\n#include <termios.h>\n#include <unistd.h>\n\n/* Change this to whatever your daemon is called */\n#define DAEMON_NAME \"slcand\"\n\n/* Change this to the user under which to run */\n#define RUN_AS_USER \"root\"\n\n/* The length of ttypath buffer */\n#define TTYPATH_LENGTH\t256\n\n/* UART flow control types */\n#define FLOW_NONE 0\n#define FLOW_HW 1\n#define FLOW_SW 2\n\nstatic void fake_syslog(int priority, const char *format, ...)\n{\n\tva_list ap;\n\n\tprintf(\"[%d] \", priority);\n\tva_start(ap, format);\n\tvprintf(format, ap);\n\tva_end(ap);\n\tprintf(\"\\n\");\n}\n\ntypedef void (*syslog_t)(int priority, const char *format, ...);\nstatic syslog_t syslogger = syslog;\n\nvoid print_usage(char *prg)\n{\n\tfprintf(stderr, \"%s - userspace daemon for serial line CAN interface driver SLCAN.\\n\", prg);\n\tfprintf(stderr, \"\\nUsage: %s [options] <tty> [canif-name]\\n\\n\", prg);\n\tfprintf(stderr, \"Options:\\n\");\n\tfprintf(stderr, \"         -o          (send open command 'O\\\\r')\\n\");\n\tfprintf(stderr, \"         -c          (send close command 'C\\\\r')\\n\");\n\tfprintf(stderr, \"         -f          (read status flags with 'F\\\\r' to reset error states)\\n\");\n\tfprintf(stderr, \"         -l          (send listen only command 'L\\\\r', overrides -o)\\n\");\n\tfprintf(stderr, \"         -s <speed>  (set CAN speed 0..8)\\n\");\n\tfprintf(stderr, \"         -S <speed>  (set UART speed in baud)\\n\");\n\tfprintf(stderr, \"         -t <type>   (set UART flow control type 'hw' or 'sw')\\n\");\n\tfprintf(stderr, \"         -b <btr>    (set bit time register value)\\n\");\n\tfprintf(stderr, \"         -F          (stay in foreground; no daemonize)\\n\");\n\tfprintf(stderr, \"         -h          (show this help page)\\n\");\n\tfprintf(stderr, \"\\nExamples:\\n\");\n\tfprintf(stderr, \"slcand -o -c -f -s6 ttyUSB0\\n\\n\");\n\tfprintf(stderr, \"slcand -o -c -f -s6 ttyUSB0 can0\\n\\n\");\n\tfprintf(stderr, \"slcand -o -c -f -s6 /dev/ttyUSB0\\n\\n\");\n\texit(EXIT_FAILURE);\n}\n\nstatic int slcand_running;\nstatic volatile sig_atomic_t exit_code;\nstatic char ttypath[TTYPATH_LENGTH];\n\nstatic void child_handler(int signum)\n{\n\tswitch (signum) {\n\n\tcase SIGUSR1:\n\t\t/* exit parent */\n\t\texit(EXIT_SUCCESS);\n\t\tbreak;\n\tcase SIGINT:\n\tcase SIGTERM:\n\tcase SIGALRM:\n\tcase SIGCHLD:\n\t\tsyslogger(LOG_NOTICE, \"received signal %i on %s\", signum, ttypath);\n\t\texit_code = 128 + signum;\n\t\tslcand_running = 0;\n\t\tbreak;\n\t}\n}\n\nstatic int look_up_uart_speed(long int s)\n{\n\tswitch (s) {\n\n\tcase 9600:\n\t\treturn B9600;\n\tcase 19200:\n\t\treturn B19200;\n\tcase 38400:\n\t\treturn B38400;\n\tcase 57600:\n\t\treturn B57600;\n\tcase 115200:\n\t\treturn B115200;\n\tcase 230400:\n\t\treturn B230400;\n\tcase 460800:\n\t\treturn B460800;\n\tcase 500000:\n\t\treturn B500000;\n\tcase 576000:\n\t\treturn B576000;\n\tcase 921600:\n\t\treturn B921600;\n\tcase 1000000:\n\t\treturn B1000000;\n\tcase 1152000:\n\t\treturn B1152000;\n\tcase 1500000:\n\t\treturn B1500000;\n\tcase 2000000:\n\t\treturn B2000000;\n#ifdef B2500000\n\tcase 2500000:\n\t\treturn B2500000;\n#endif\n#ifdef B3000000\n\tcase 3000000:\n\t\treturn B3000000;\n#endif\n#ifdef B3500000\n\tcase 3500000:\n\t\treturn B3500000;\n#endif\n#ifdef B3710000\n\tcase 3710000\n\t\treturn B3710000;\n#endif\n#ifdef B4000000\n\tcase 4000000:\n\t\treturn B4000000;\n#endif\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tchar *tty = NULL;\n\tchar const *devprefix = \"/dev/\";\n\tchar *name = NULL;\n\tchar buf[20];\n\tstatic struct ifreq ifr;\n\tstruct termios tios;\n\tspeed_t old_ispeed;\n\tspeed_t old_ospeed;\n\n\tint opt;\n\tint send_open = 0;\n\tint send_close = 0;\n\tint send_listen = 0;\n\tint send_read_status_flags = 0;\n\tchar *speed = NULL;\n\tchar *uart_speed_str = NULL;\n\tlong int uart_speed = 0;\n\tint flow_type = FLOW_NONE;\n\tchar *btr = NULL;\n\tint run_as_daemon = 1;\n\tchar *pch;\n\tint ldisc = N_SLCAN;\n\tint fd;\n\n\tttypath[0] = '\\0';\n\n\twhile ((opt = getopt(argc, argv, \"ocfls:S:t:b:?hF\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'o':\n\t\t\tsend_open = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tsend_close = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tsend_read_status_flags = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tsend_listen = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tspeed = optarg;\n\t\t\tif (strlen(speed) > 1)\n\t\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tuart_speed_str = optarg;\n\t\t\terrno = 0;\n\t\t\tuart_speed = strtol(uart_speed_str, NULL, 10);\n\t\t\tif (errno)\n\t\t\t\tprint_usage(argv[0]);\n\t\t\tif (look_up_uart_speed(uart_speed) == -1) {\n\t\t\t\tfprintf(stderr, \"Unsupported UART speed (%lu)\\n\", uart_speed);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (!strcmp(optarg, \"hw\")) {\n\t\t\t\tflow_type = FLOW_HW;\n\t\t\t} else if (!strcmp(optarg, \"sw\")) {\n\t\t\t\tflow_type = FLOW_SW;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unsupported flow type (%s)\\n\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbtr = optarg;\n\t\t\tif (strlen(btr) > 8)\n\t\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\trun_as_daemon = 0;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\tdefault:\n\t\t\tprint_usage(argv[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!run_as_daemon)\n\t\tsyslogger = fake_syslog;\n\n\t/* Initialize the logging interface */\n\topenlog(DAEMON_NAME, LOG_PID, LOG_LOCAL5);\n\n\t/* Parse serial device name and optional can interface name */\n\ttty = argv[optind];\n\tif (NULL == tty)\n\t\tprint_usage(argv[0]);\n\n\tname = argv[optind + 1];\n\tif (name && (strlen(name) > sizeof(ifr.ifr_newname) - 1))\n\t\tprint_usage(argv[0]);\n\n\t/* Prepare the tty device name string */\n\tpch = strstr(tty, devprefix);\n\tif (pch != tty)\n\t\tsnprintf(ttypath, TTYPATH_LENGTH, \"%s%s\", devprefix, tty);\n\telse\n\t\tsnprintf(ttypath, TTYPATH_LENGTH, \"%s\", tty);\n\n\tsyslogger(LOG_INFO, \"starting on TTY device %s\", ttypath);\n\n\tfd = open(ttypath, O_RDWR | O_NONBLOCK | O_NOCTTY);\n\tif (fd < 0) {\n\t\tsyslogger(LOG_NOTICE, \"failed to open TTY device %s\\n\", ttypath);\n\t\tperror(ttypath);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* Configure baud rate */\n\tmemset(&tios, 0, sizeof(tios));\n\tif (tcgetattr(fd, &tios) < 0) {\n\t\tsyslogger(LOG_NOTICE, \"failed to get attributes for TTY device %s: %s\\n\", ttypath, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Because of a recent change in linux - https://patchwork.kernel.org/patch/9589541/\n\t// we need to set low latency flag to get proper receive latency\n\tstruct serial_struct snew;\n\tioctl (fd, TIOCGSERIAL, &snew);\n\tsnew.flags |= ASYNC_LOW_LATENCY;\n\tioctl (fd, TIOCSSERIAL, &snew);\n\n\t/* Get old values for later restore */\n\told_ispeed = cfgetispeed(&tios);\n\told_ospeed = cfgetospeed(&tios);\n\n\t/* Reset UART settings */\n\tcfmakeraw(&tios);\n\ttios.c_iflag &= ~IXOFF;\n\ttios.c_cflag &= ~CRTSCTS;\n\n\t/* Baud Rate */\n\tcfsetispeed(&tios, look_up_uart_speed(uart_speed));\n\tcfsetospeed(&tios, look_up_uart_speed(uart_speed));\n\n\t/* Flow control */\n\tif (flow_type == FLOW_HW)\n\t\ttios.c_cflag |= CRTSCTS;\n\telse if (flow_type == FLOW_SW)\n\t\ttios.c_iflag |= (IXON | IXOFF);\n\n\t/* apply changes */\n\tif (tcsetattr(fd, TCSADRAIN, &tios) < 0)\n\t\tsyslogger(LOG_NOTICE, \"Cannot set attributes for device \\\"%s\\\": %s!\\n\", ttypath, strerror(errno));\n\n\tif (speed) {\n\t\tsprintf(buf, \"C\\rS%s\\r\", speed);\n\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\tperror(\"write\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (btr) {\n\t\tsprintf(buf, \"C\\rs%s\\r\", btr);\n\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\tperror(\"write\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (send_read_status_flags) {\n\t\tsprintf(buf, \"F\\r\");\n\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\tperror(\"write\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (send_listen) {\n\t\tsprintf(buf, \"L\\r\");\n\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\tperror(\"write\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else if (send_open) {\n\t\tsprintf(buf, \"O\\r\");\n\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\tperror(\"write\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t/* set slcan like discipline on given tty */\n\tif (ioctl(fd, TIOCSETD, &ldisc) < 0) {\n\t\tperror(\"ioctl TIOCSETD\");\n\t\texit(EXIT_FAILURE);\n\t}\n\t\n\t/* retrieve the name of the created CAN netdevice */\n\tif (ioctl(fd, SIOCGIFNAME, ifr.ifr_name) < 0) {\n\t\tperror(\"ioctl SIOCGIFNAME\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsyslogger(LOG_NOTICE, \"attached TTY %s to netdevice %s\\n\", ttypath, ifr.ifr_name);\n\t\n\t/* try to rename the created netdevice */\n\tif (name) {\n\t\tint s = socket(PF_INET, SOCK_DGRAM, 0);\n\n\t\tif (s < 0)\n\t\t\tperror(\"socket for interface rename\");\n\t\telse {\n\t\t\t/* current slcan%d name is still in ifr.ifr_name */\n\t\t\tmemset (ifr.ifr_newname, 0, sizeof(ifr.ifr_newname));\n\t\t\tstrncpy (ifr.ifr_newname, name, sizeof(ifr.ifr_newname) - 1);\n\n\t\t\tif (ioctl(s, SIOCSIFNAME, &ifr) < 0) {\n\t\t\t\tsyslogger(LOG_NOTICE, \"netdevice %s rename to %s failed\\n\", buf, name);\n\t\t\t\tperror(\"ioctl SIOCSIFNAME rename\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t} else\n\t\t\t\tsyslogger(LOG_NOTICE, \"netdevice %s renamed to %s\\n\", buf, name);\n\n\t\t\tclose(s);\n\t\t}\t\n\t}\n\n\t/* Daemonize */\n\tif (run_as_daemon) {\n\t\tif (daemon(0, 0)) {\n\t\t\tsyslogger(LOG_ERR, \"failed to daemonize\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\telse {\n\t\t/* Trap signals that we expect to receive */\n\t\tsignal(SIGINT, child_handler);\n\t\tsignal(SIGTERM, child_handler);\n\t}\n\n\tslcand_running = 1;\n\n\t/* The Big Loop */\n\twhile (slcand_running)\n\t\tsleep(1); /* wait 1 second */\n\n\t/* Reset line discipline */\n\tsyslogger(LOG_INFO, \"stopping on TTY device %s\", ttypath);\n\tldisc = N_TTY;\n\tif (ioctl(fd, TIOCSETD, &ldisc) < 0) {\n\t\tperror(\"ioctl TIOCSETD\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (send_close) {\n\t\tsprintf(buf, \"C\\r\");\n\t\tif (write(fd, buf, strlen(buf)) <= 0) {\n\t\t\tperror(\"write\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t/* Reset old rates */\n\tcfsetispeed(&tios, old_ispeed);\n\tcfsetospeed(&tios, old_ospeed);\n\n\t/* apply changes */\n\tif (tcsetattr(fd, TCSADRAIN, &tios) < 0)\n\t\tsyslogger(LOG_NOTICE, \"Cannot set attributes for device \\\"%s\\\": %s!\\n\", ttypath, strerror(errno));\n\n\t/* Finish up */\n\tsyslogger(LOG_NOTICE, \"terminated on %s\", ttypath);\n\tcloselog();\n\treturn exit_code;\n}\n"
        },
        {
          "name": "slcanpty.c",
          "type": "blob",
          "size": 11.38671875,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * slcanpty: adapter for applications using the slcan ASCII protocol\n *\n * slcanpty.c - creates a pty for applications using the slcan ASCII protocol\n * and converts the ASCII data to a CAN network interface (and vice versa)\n *\n * Copyright (c)2009 Oliver Hartkopp\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#include <fcntl.h>\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <linux/can.h>\n#include <linux/can/raw.h>\n#include <linux/sockios.h>\n\n#include \"lib.h\"\n\n/* maximum rx buffer len: extended CAN frame with timestamp */\n#define SLC_MTU (sizeof(\"T1111222281122334455667788EA5F\\r\") + 1)\n#define DEVICE_NAME_PTMX \"/dev/ptmx\"\n\n/* read data from pty, send CAN frames to CAN socket and answer commands */\nstatic int pty2can(int pty, int socket, struct can_filter *fi,\n\t\t   int *is_open, int *tstamp)\n{\n\tunsigned int nbytes, tmp;\n\tchar cmd;\n\tstatic char buf[200];\n\tchar replybuf[10]; /* for answers to received commands */\n\tunsigned int ptr;\n\tstruct can_frame frame;\n\tint ret, i;\n\tstatic unsigned int rxoffset = 0; /* points to the end of an received incomplete SLCAN message */\n\n\tret = read(pty, &buf[rxoffset], sizeof(buf) - rxoffset - 1);\n\tif (ret <= 0) {\n\t\t/* ret == 0 : no error but pty descriptor has been closed */\n\t\tif (ret < 0)\n\t\t\tperror(\"read pty\");\n\n\t\treturn 1;\n\t}\n\n\tnbytes = ret;\n\t/* reset incomplete message offset */\n\tnbytes += rxoffset;\n\trxoffset = 0;\n\nrx_restart:\n\t/* remove trailing '\\r' characters to be robust against some apps */\n\twhile (buf[0] == '\\r' && nbytes > 0) {\n\t\tfor (tmp = 0; tmp < nbytes; tmp++)\n\t\t\tbuf[tmp] = buf[tmp + 1];\n\t\tnbytes--;\n\t}\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t/* check if we can detect a complete SLCAN message including '\\r' */\n\tfor (tmp = 0; tmp < nbytes; tmp++) {\n\t\tif (buf[tmp] == '\\r')\n\t\t\tbreak;\n\t}\n\n\t/* no '\\r' found in the message buffer? */\n\tif (tmp == nbytes) {\n\t\t/* save incomplete message */\n\t\trxoffset = nbytes;\n\n\t\t/* leave here and read from pty again */\n\t\treturn 0;\n\t}\n\n\tcmd = buf[0];\n\tbuf[nbytes] = 0;\n\n\tfor (tmp = 0; tmp < nbytes; tmp++)\n\t\tif (buf[tmp] == '\\r')\n\t\t\tpr_debug(\"@\");\n\t\telse\n\t\t\tpr_debug(\"%c\", buf[tmp]);\n\tpr_debug(\"\\n\");\n\n\t/* check for filter configuration commands */\n\tif (cmd == 'm' || cmd == 'M') {\n\t\tbuf[9] = 0; /* terminate filter string */\n\t\tptr = 9;\n#if 0\n\t\t/* the filter is no SocketCAN filter :-( */\n\n\t\t/* TODO: behave like a SJA1000 controller specific filter */\n\n\t\tif (cmd == 'm') {\n\t\t\tfi->can_id = strtoul(buf+1,NULL,16);\n\t\t\tfi->can_id &= CAN_EFF_MASK;\n\t\t} else {\n\t\t\tfi->can_mask = strtoul(buf+1,NULL,16);\n\t\t\tfi->can_mask &= CAN_EFF_MASK;\n\t\t}\n\n\t\tif (*is_open)\n\t\t\tsetsockopt(socket, SOL_CAN_RAW,\n\t\t\t\t   CAN_RAW_FILTER, fi,\n\t\t\t\t   sizeof(struct can_filter));\n#endif\n\t\tgoto rx_out_ack;\n\t}\n\n\t/* check for timestamp on/off command */\n\tif (cmd == 'Z') {\n\t\t*tstamp = buf[1] & 0x01;\n\t\tptr = 2;\n\t\tgoto rx_out_ack;\n\t}\n\n\t/* check for 'O'pen command */\n\tif (cmd == 'O') {\n\t\tsetsockopt(socket, SOL_CAN_RAW, CAN_RAW_FILTER, fi, sizeof(struct can_filter));\n\t\tptr = 1;\n\t\t*is_open = 1;\n\t\tgoto rx_out_ack;\n\t}\n\n\t/* check for 'C'lose command */\n\tif (cmd == 'C') {\n\t\tsetsockopt(socket, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);\n\t\tptr = 1;\n\t\t*is_open = 0;\n\t\tgoto rx_out_ack;\n\t}\n\n\t/* check for 'V'ersion command */\n\tif (cmd == 'V') {\n\t\tsprintf(replybuf, \"V1013\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\t/* check for 'v'ersion command */\n\tif (cmd == 'v') {\n\t\tsprintf(replybuf, \"v1014\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\n\t/* check for serial 'N'umber command */\n\tif (cmd == 'N') {\n\t\tsprintf(replybuf, \"N4242\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\n\t/* check for read status 'F'lags */\n\tif (cmd == 'F') {\n\t\tsprintf(replybuf, \"F00\\r\");\n\t\ttmp = strlen(replybuf);\n\t\tptr = 1;\n\t\tgoto rx_out;\n\t}\n\n\t/* correctly answer unsupported commands */\n\tif (cmd == 'U') {\n\t\tptr = 2;\n\t\tgoto rx_out_ack;\n\t}\n\tif (cmd == 'S') {\n\t\tptr = 2;\n\t\tgoto rx_out_ack;\n\t}\n\tif (cmd == 's') {\n\t\tptr = 5;\n\t\tgoto rx_out_ack;\n\t}\n\tif (cmd == 'P' || cmd == 'A') {\n\t\tptr = 1;\n\t\tgoto rx_out_nack;\n\t}\n\tif (cmd == 'X') {\n\t\tptr = 2;\n\t\tif (buf[1] & 0x01)\n\t\t\tgoto rx_out_ack;\n\t\telse\n\t\t\tgoto rx_out_nack;\n\t}\n\n\t/* catch unknown commands */\n\tif ((cmd != 't') && (cmd != 'T') && (cmd != 'r') && (cmd != 'R')) {\n\t\tptr = nbytes - 1;\n\t\tgoto rx_out_nack;\n\t}\n\n\tif (cmd & 0x20) /* tiny chars 'r' 't' => SFF */\n\t\tptr = 4; /* dlc position tiiid */\n\telse\n\t\tptr = 9; /* dlc position Tiiiiiiiid */\n\n\tmemset(&frame.data, 0, 8); /* clear data[] */\n\n\tif ((cmd | 0x20) == 'r' && buf[ptr] != '0') {\n\t\t/*\n\t\t * RTR frame without dlc information!\n\t\t * This is against the SLCAN spec but sent\n\t\t * by a commercial CAN tool ... so we are\n\t\t * robust against this protocol violation.\n\t\t */\n\n\t\tframe.can_dlc = buf[ptr]; /* save following byte */\n\n\t\tbuf[ptr] = 0; /* terminate can_id string */\n\n\t\tframe.can_id = strtoul(buf + 1, NULL, 16);\n\t\tframe.can_id |= CAN_RTR_FLAG;\n\n\t\tif (!(cmd & 0x20)) /* NO tiny chars => EFF */\n\t\t\tframe.can_id |= CAN_EFF_FLAG;\n\n\t\tbuf[ptr] = frame.can_dlc; /* restore following byte */\n\t\tframe.can_dlc = 0;\n\t\tptr--; /* we have no dlc component in the violation case */\n\n\t} else {\n\t\tif (!(buf[ptr] >= '0' && buf[ptr] < '9'))\n\t\t\tgoto rx_out_nack;\n\n\t\tframe.can_dlc = buf[ptr] - '0'; /* get dlc from ASCII val */\n\n\t\tbuf[ptr] = 0; /* terminate can_id string */\n\n\t\tframe.can_id = strtoul(buf + 1, NULL, 16);\n\n\t\tif (!(cmd & 0x20)) /* NO tiny chars => EFF */\n\t\t\tframe.can_id |= CAN_EFF_FLAG;\n\n\t\tif ((cmd | 0x20) == 'r') /* RTR frame */\n\t\t\tframe.can_id |= CAN_RTR_FLAG;\n\n\t\tfor (i = 0, ptr++; i < frame.can_dlc; i++) {\n\t\t\ttmp = asc2nibble(buf[ptr++]);\n\t\t\tif (tmp > 0x0F)\n\t\t\t\tgoto rx_out_nack;\n\t\t\tframe.data[i] = (tmp << 4);\n\t\t\ttmp = asc2nibble(buf[ptr++]);\n\t\t\tif (tmp > 0x0F)\n\t\t\t\tgoto rx_out_nack;\n\t\t\tframe.data[i] |= tmp;\n\t\t}\n\t\t/* point to last real data */\n\t\tif (frame.can_dlc)\n\t\t\tptr--;\n\t}\n\n\tret = write(socket, &frame, sizeof(frame));\n\tif (ret != sizeof(frame)) {\n\t\tperror(\"write socket\");\n\t\treturn 1;\n\t}\n\nrx_out_ack:\n\treplybuf[0] = '\\r';\n\ttmp = 1;\n\tgoto rx_out;\nrx_out_nack:\n\treplybuf[0] = '\\a';\n\ttmp = 1;\nrx_out:\n\tret = write(pty, replybuf, tmp);\n\tif (ret < 0) {\n\t\tperror(\"write pty replybuf\");\n\t\treturn 1;\n\t}\n\n\t/* check if there is another command in this buffer */\n\tif (nbytes > ptr + 1) {\n\t\tfor (tmp = 0, ptr++; ptr + tmp < nbytes; tmp++)\n\t\t\tbuf[tmp] = buf[ptr + tmp];\n\t\tnbytes = tmp;\n\t\tgoto rx_restart;\n\t}\n\n\treturn 0;\n}\n\n/* read CAN frames from CAN interface and write it to the pty */\nstatic int can2pty(int pty, int socket, int *tstamp)\n{\n\tint nbytes;\n\tchar cmd;\n\tchar buf[SLC_MTU];\n\tint ptr;\n\tstruct can_frame frame;\n\tint i;\n\n\tnbytes = read(socket, &frame, sizeof(frame));\n\tif (nbytes != sizeof(frame)) {\n\t\tperror(\"read socket\");\n\t\treturn 1;\n\t}\n\n\t/* convert to slcan ASCII frame */\n\tif (frame.can_id & CAN_RTR_FLAG)\n\t\tcmd = 'R'; /* becomes 'r' in SFF format */\n\telse\n\t\tcmd = 'T'; /* becomes 't' in SFF format */\n\n\tif (frame.can_id & CAN_EFF_FLAG)\n\t\tsprintf(buf, \"%c%08X%d\", cmd, frame.can_id & CAN_EFF_MASK, frame.can_dlc);\n\telse\n\t\tsprintf(buf, \"%c%03X%d\", cmd | 0x20, frame.can_id & CAN_SFF_MASK, frame.can_dlc);\n\n\tptr = strlen(buf);\n\n\tfor (i = 0; i < frame.can_dlc; i++)\n\t\tsprintf(&buf[ptr + 2 * i], \"%02X\", frame.data[i]);\n\n\tif (*tstamp) {\n\t\tstruct timeval tv;\n\n\t\tif (ioctl(socket, SIOCGSTAMP, &tv) < 0)\n\t\t\tperror(\"SIOCGSTAMP\");\n\n\t\tsprintf(&buf[ptr + 2*frame.can_dlc], \"%04llX\",\n\t\t\t(unsigned long long)(tv.tv_sec%60)*1000 + tv.tv_usec/1000);\n\t}\n\n\tstrcat(buf, \"\\r\"); /* add terminating character */\n\tnbytes = write(pty, buf, strlen(buf));\n\tif (nbytes < 0) {\n\t\tperror(\"write pty\");\n\t\treturn 1;\n\t}\n\tfflush(NULL);\n\n\treturn 0;\n}\n\nstatic int check_select_stdin(void)\n{\n\tfd_set rdfs;\n\tstruct timeval timeout;\n\tint ret;\n\n\tFD_ZERO(&rdfs);\n\tFD_SET(0, &rdfs);\n\ttimeout.tv_sec = 0;\n\ttimeout.tv_usec = 0;\n\n\tret = select(1, &rdfs, NULL, NULL, &timeout);\n\n\tif (ret < 0)\n\t\treturn 0; /* not selectable */\n\n\tif (ret > 0 && getchar() == EOF)\n\t\treturn 0; /* EOF, eg. /dev/null */\n\n\treturn 1;\n}\n\nstatic void print_usage(const char *prg)\n{\n\tfprintf(stderr,\n\t\t\"%s: adapter for applications using the slcan ASCII protocol.\\n\"\n\t\t\"\\n\"\n\t\t\"%s creates a pty for applications using the slcan ASCII protocol and\\n\"\n\t\t\"converts the ASCII data to a CAN network interface (and vice versa)\\n\"\n\t\t\"\\n\"\n\t\t\"Usage: %s <pty> <can interface>\\n\"\n\t\t\"\\n\"\n\t\t\"Examples:\\n\"\n\t\t\"%s /dev/ptyc0 can0  - creates /dev/ttyc0 for the slcan application\\n\"\n\t\t\"\\n\"\n\t\t\"e.g. for pseudo-terminal '%s %s can0' creates /dev/pts/N\\n\"\n\t\t\"\\n\",\n\t\tprg, prg, prg, prg, prg, DEVICE_NAME_PTMX);\n}\n\nint main(int argc, char **argv)\n{\n\tfd_set rdfs;\n\tint p; /* pty master file */\n\tint s; /* can raw socket */\n\tstruct sockaddr_can addr;\n\tstruct termios topts;\n\tint select_stdin = 0;\n\tint running = 1;\n\tint tstamp = 0;\n\tint is_open = 0;\n\tstruct can_filter fi;\n\n\t/* check command line options */\n\tif (argc != 3) {\n\t\tprint_usage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\n\tselect_stdin = check_select_stdin();\n\n\t/* open pty */\n\tp = open(argv[1], O_RDWR);\n\tif (p < 0) {\n\t\tperror(\"open pty\");\n\t\treturn 1;\n\t}\n\n\tif (tcgetattr(p, &topts)) {\n\t\tperror(\"tcgetattr\");\n\t\treturn 1;\n\t}\n\n\t/* disable local echo which would cause double frames */\n\ttopts.c_lflag &= ~(ICANON | ECHO | ECHOE | ECHOK | ECHONL | ECHOPRT | ECHOKE);\n\ttopts.c_iflag &= ~(ICRNL);\n\ttopts.c_iflag |= INLCR;\n\ttcsetattr(p, TCSANOW, &topts);\n\n\t/* Support for the Unix 98 pseudo-terminal interface /dev/ptmx /dev/pts/N */\n\tif (strcmp(argv[1], DEVICE_NAME_PTMX) == 0) {\n\t\tchar *name_pts = NULL; /* slave pseudo-terminal device name */\n\n\t\tif (grantpt(p) < 0) {\n\t\t\tperror(\"grantpt\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (unlockpt(p) < 0) {\n\t\t\tperror(\"unlockpt\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tname_pts = ptsname(p);\n\t\tif (name_pts == NULL) {\n\t\t\tperror(\"ptsname\");\n\t\t\treturn 1;\n\t\t}\n\t\tprintf(\"open: %s: slave pseudo-terminal is %s\\n\", argv[1], name_pts);\n\t}\n\n\t/* open socket */\n\ts = socket(PF_CAN, SOCK_RAW, CAN_RAW);\n\tif (s < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\taddr.can_family = AF_CAN;\n\taddr.can_ifindex = if_nametoindex(argv[2]);\n\tif (!addr.can_ifindex) {\n\t\tperror(\"if_nametoindex\");\n\t\treturn 1;\n\t}\n\n\t/* disable reception of CAN frames until we are opened by 'O' */\n\tsetsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);\n\n\tif (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tperror(\"bind\");\n\t\treturn 1;\n\t}\n\n\t/* open filter by default */\n\tfi.can_id = 0;\n\tfi.can_mask = 0;\n\n\twhile (running) {\n\t\tFD_ZERO(&rdfs);\n\n\t\tif (select_stdin)\n\t\t\tFD_SET(0, &rdfs);\n\n\t\tFD_SET(p, &rdfs);\n\t\tFD_SET(s, &rdfs);\n\n\t\tif (select(s + 1, &rdfs, NULL, NULL, NULL) < 0) {\n\t\t\tperror(\"select\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (FD_ISSET(0, &rdfs)) {\n\t\t\trunning = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (FD_ISSET(p, &rdfs))\n\t\t\tif (pty2can(p, s, &fi, &is_open, &tstamp)) {\n\t\t\t\trunning = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tif (FD_ISSET(s, &rdfs))\n\t\t\tif (can2pty(p, s, &tstamp)) {\n\t\t\t\trunning = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t}\n\n\tclose(p);\n\tclose(s);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "style.css",
          "type": "blob",
          "size": 0.9306640625,
          "content": "* {\n    font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\n}\nbody {\n    max-width: 60em;\n    margin: 0 auto;\n    color: #111;\n}\n\npre, code {\n    font-family: Monaco, Courier New, monospace;\n    font-size: 11px;\n}\n\nh1 {\n    color: rgb(43,105,145);\n    font-weight: bold;\n    font-size: 40px;\n    letter-spacing: -1px;\n    margin-bottom: -5px;\n    margin: 0;\n}\nh1 code {\n    font-size: 32px;\n}\n\nh2 {\n    color: rgb(43,105,145);\n    font-weight: bold;\n    margin-bottom: -5px;\n}\nh2 code {\n    font-size: 22px;\n}\n\nh3 {\n    margin-bottom: -5px;\n}\nh3 code {\n    font-size: 16px;\n}\n\na {\n    color: blue;\n    text-decoration: none;\n}\na:visited {\n    color: navy;\n}\na:hover {\n    text-decoration: underline;\n}\n\npre {\n    border-width: 1px;\n    border-color: #777;\n    border-style: solid;\n    padding: 0.5em;\n    background-color: #ccc;\n    overflow: auto;\n    color: #000;\n    font-weight: bold;\n}\n\np, li {\n    font-size: 13px;\n    line-height: 18px;\n}\n"
        },
        {
          "name": "terminal.h",
          "type": "blob",
          "size": 3.08203125,
          "content": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */\n/*\n * Copyright (c) 2002-2007 Volkswagen Group Electronic Research\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Volkswagen nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * Alternatively, provided that this notice is retained in full, this\n * software may be distributed under the terms of the GNU General\n * Public License (\"GPL\") version 2, in which case the provisions of the\n * GPL apply INSTEAD OF those given above.\n *\n * The provided data structures and external interfaces from this code\n * are not restricted to be used by modules with a GPL compatible license.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * Send feedback to <linux-can@vger.kernel.org>\n *\n */\n\n#ifndef TERMINAL_H\n#define TERMINAL_H\n\n/* reset to default */\n\n#define ATTRESET \"\\33[0m\"\n\n/* attributes */\n\n#define ATTBOLD      \"\\33[1m\"\n#define ATTUNDERLINE \"\\33[4m\"\n#define ATTBLINK     \"\\33[5m\"\n#define ATTINVERSE   \"\\33[7m\"\n#define ATTINVISIBLE \"\\33[8m\"\n\n/* foreground colors */\n\n#define FGBLACK   \"\\33[30m\"\n#define FGRED     \"\\33[31m\"\n#define FGGREEN   \"\\33[32m\"\n#define FGYELLOW  \"\\33[33m\"\n#define FGBLUE    \"\\33[34m\"\n#define FGMAGENTA \"\\33[35m\"\n#define FGCYAN    \"\\33[36m\"\n#define FGWHITE   \"\\33[37m\"\n\n/* background colors */\n\n#define BGBLACK   \"\\33[40m\"\n#define BGRED     \"\\33[41m\"\n#define BGGREEN   \"\\33[42m\"\n#define BGYELLOW  \"\\33[43m\"\n#define BGBLUE    \"\\33[44m\"\n#define BGMAGENTA \"\\33[45m\"\n#define BGCYAN    \"\\33[46m\"\n#define BGWHITE   \"\\33[47m\"\n\n/* cursor */\n\n#define CSR_HOME  \"\\33[H\"\n#define CSR_UP    \"\\33[A\"\n#define CSR_DOWN  \"\\33[B\"\n#define CSR_RIGHT \"\\33[C\"\n#define CSR_LEFT  \"\\33[D\"\n\n#define CSR_HIDE  \"\\33[?25l\"\n#define CSR_SHOW  \"\\33[?25h\"\n\n/* clear screen */\n\n#define CLR_SCREEN  \"\\33[2J\"\n\n#endif /* TERMINAL_H */\n"
        },
        {
          "name": "testj1939.c",
          "type": "blob",
          "size": 7.6015625,
          "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (c) 2013 EIA Electronics\n *\n * Authors:\n * Kurt Van Dijck <kurt.van.dijck@eia.be>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the version 2 of the GNU General Public License\n * as published by the Free Software Foundation\n */\n\n#include <errno.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <err.h>\n#include <getopt.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#include \"libj1939.h\"\n\nstatic const char help_msg[] =\n\t\"testj1939: demonstrate j1939 use\\n\"\n\t\"Usage: testj1939 [OPTIONS] FROM TO\\n\"\n\t\" FROM / TO\t- or [IFACE][:[SA][,[PGN][,NAME]]]\\n\"\n\t\"Options:\\n\"\n\t\" -v\t\tPrint relevant API calls\\n\"\n\t\" -s[=LEN]\tInitial send of LEN bytes dummy data\\n\"\n\t\" -r\t\tReceive (and print) data\\n\"\n\t\" -e\t\tEcho incoming packets back\\n\"\n\t\"\t\tThis actually receives packets\\n\"\n\t\" -c\t\tIssue connect()\\n\"\n\t\" -p=PRIO\tSet priority to PRIO\\n\"\n\t\" -P\t\tPromiscuous mode. Allow to receive all packets\\n\"\n\t\" -b\t\tDo normal bind with SA+1 and rebind with actual SA\\n\"\n\t\" -B\t\tAllow to send and receive broadcast packets.\\n\"\n\t\" -o\t\tOmit bind\\n\"\n\t\" -n\t\tEmit 64bit NAMEs in output\\n\"\n\t\" -w[TIME]\tReturn after TIME (default 1) seconds\\n\"\n\t\"\\n\"\n\t\"Examples:\\n\"\n\t\"testj1939 can1 20\\n\"\n\t\"\\n\"\n\t;\n\nstatic const char optstring[] = \"?vbBPos::rep:cnw::\";\n\nstatic void onsigalrm(int sig)\n{\n\terr(0, \"exit as requested\");\n\texit(0);\n}\n\nstatic void schedule_oneshot_itimer(double delay)\n{\n\tstruct itimerval it = { 0 };\n\n\tit.it_value.tv_sec = delay;\n\tit.it_value.tv_usec = (long)(delay * 1e6) % 1000000;\n\tif (setitimer(ITIMER_REAL, &it, NULL) < 0)\n\t\terr(1, \"schedule itimer %.3lfs\", delay);\n}\n\n/* main */\nint main(int argc, char *argv[])\n{\n\tint ret, sock, opt;\n\tunsigned int j;\n\tint verbose = 0;\n\tsocklen_t peernamelen;\n\tstruct sockaddr_can sockname = {\n\t\t.can_family = AF_CAN,\n\t\t.can_addr.j1939 = {\n\t\t\t.addr = J1939_NO_ADDR,\n\t\t\t.name = J1939_NO_NAME,\n\t\t\t.pgn = J1939_NO_PGN,\n\t\t},\n\t}, peername = {\n\t\t.can_family = AF_CAN,\n\t\t.can_addr.j1939 = {\n\t\t\t.addr = J1939_NO_ADDR,\n\t\t\t.name = J1939_NO_NAME,\n\t\t\t.pgn = J1939_NO_PGN,\n\t\t},\n\t};\n\tuint8_t dat[128];\n\tint valid_peername = 0;\n\tunsigned int todo_send = 0;\n\tint todo_recv = 0, todo_echo = 0, todo_prio = -1;\n\tint todo_connect = 0, todo_names = 0, todo_wait = 0, todo_rebind = 0;\n\tint todo_broadcast = 0, todo_promisc = 0;\n\tint no_bind = 0;\n\n\t/* argument parsing */\n\twhile ((opt = getopt(argc, argv, optstring)) != -1)\n\t\tswitch (opt) {\n\t\tcase 'v':\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\ttodo_send = strtoul(optarg ?: \"8\", NULL, 0);\n\t\t\tif (todo_send > sizeof(dat))\n\t\t\t\terr(1, \"Unsupported size. max: %zu\",\n\t\t\t\t    sizeof(dat));\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\ttodo_recv = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttodo_echo = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttodo_prio = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\ttodo_promisc = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\ttodo_connect = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\ttodo_names = 1;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\ttodo_rebind = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\ttodo_broadcast = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tno_bind = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tschedule_oneshot_itimer(strtod(optarg ?: \"1\", NULL));\n\t\t\tsignal(SIGALRM, onsigalrm);\n\t\t\ttodo_wait = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfputs(help_msg, stderr);\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\n\tif (argv[optind]) {\n\t\tif (strcmp(\"-\", argv[optind]) != 0)\n\t\t\tlibj1939_parse_canaddr(argv[optind], &sockname);\n\t\t++optind;\n\t}\n\n\tif (todo_rebind)\n\t\tsockname.can_addr.j1939.addr++;\n\n\tif (argv[optind]) {\n\t\tif (strcmp(\"-\", argv[optind]) != 0) {\n\t\t\tlibj1939_parse_canaddr(argv[optind], &peername);\n\t\t\tvalid_peername = 1;\n\t\t}\n\t\t++optind;\n\t}\n\n\t/* open socket */\n\tif (verbose)\n\t\tfprintf(stderr, \"- socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\\n\");\n\tsock = ret = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n\tif (ret < 0)\n\t\terr(1, \"socket(j1939)\");\n\n\tif (todo_promisc) {\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"- setsockopt(, SOL_CAN_J1939, SO_J1939_PROMISC, %d, %zd);\\n\",\n\t\t\t\ttodo_promisc, sizeof(todo_promisc));\n\t\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_PROMISC,\n\t\t\t\t &todo_promisc, sizeof(todo_promisc));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt: filed to set promiscuous mode\");\n\t}\n\n\tif (todo_broadcast) {\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"- setsockopt(, SOL_SOCKET, SO_BROADCAST, %d, %zd);\\n\",\n\t\t\t\ttodo_broadcast, sizeof(todo_broadcast));\n\t\tret = setsockopt(sock, SOL_SOCKET, SO_BROADCAST,\n\t\t\t\t &todo_broadcast, sizeof(todo_broadcast));\n\t\tif (ret < 0)\n\t\t\terr(1, \"setsockopt: filed to set broadcast\");\n\t}\n\n\tif (todo_prio >= 0) {\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"- setsockopt(, SOL_CAN_J1939, SO_J1939_SEND_PRIO, &%i);\\n\", todo_prio);\n\t\tret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_SEND_PRIO,\n\t\t\t\t&todo_prio, sizeof(todo_prio));\n\t\tif (ret < 0)\n\t\t\terr(1, \"set priority %i\", todo_prio);\n\t}\n\n\tif (!no_bind) {\n\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"- bind(, %s, %zi);\\n\", libj1939_addr2str(&sockname), sizeof(sockname));\n\t\tret = bind(sock, (void *)&sockname, sizeof(sockname));\n\t\tif (ret < 0)\n\t\t\terr(1, \"bind()\");\n\n\t\tif (todo_rebind) {\n\t\t\t/* rebind with actual SA */\n\t\t\tsockname.can_addr.j1939.addr--;\n\n\t\t\tif (verbose)\n\t\t\t\tfprintf(stderr, \"- bind(, %s, %zi);\\n\", libj1939_addr2str(&sockname), sizeof(sockname));\n\t\t\tret = bind(sock, (void *)&sockname, sizeof(sockname));\n\t\t\tif (ret < 0)\n\t\t\t\terr(1, \"re-bind()\");\n\t\t}\n\t}\n\n\tif (todo_connect) {\n\t\tif (!valid_peername)\n\t\t\terr(1, \"no peername supplied\");\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"- connect(, %s, %zi);\\n\", libj1939_addr2str(&peername), sizeof(peername));\n\t\tret = connect(sock, (void *)&peername, sizeof(peername));\n\t\tif (ret < 0)\n\t\t\terr(1, \"connect()\");\n\t}\n\n\tif (todo_send) {\n\t\t/* initialize test vector */\n\t\tfor (j = 0; j < sizeof(dat); ++j)\n\t\t\tdat[j] = ((2*j) << 4) + ((2*j+1) & 0xf);\n\n\t\t/* send data */\n\t\t/*\n\t\t * when using connect, do not provide additional\n\t\t * destination information and use send()\n\t\t */\n\t\tif (valid_peername && !todo_connect) {\n\t\t\tif (verbose)\n\t\t\t\tfprintf(stderr, \"- sendto(, <dat>, %i, 0, %s, %zi);\\n\", todo_send, libj1939_addr2str(&peername), sizeof(peername));\n\t\t\tret = sendto(sock, dat, todo_send, 0,\n\t\t\t\t\t(void *)&peername, sizeof(peername));\n\t\t} else {\n\t\t\t/*\n\t\t\t * we may do sendto(sock, dat, todo_send, 0, NULL, 0)\n\t\t\t * as well, but using send() demonstrates the API better\n\t\t\t */\n\t\t\tif (verbose)\n\t\t\t\tfprintf(stderr, \"- send(, <dat>, %i, 0);\\n\", todo_send);\n\t\t\tret = send(sock, dat, todo_send, 0);\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\terr(1, \"sendto\");\n\t}\n\n\t/* main loop */\n\tif ((todo_echo || todo_recv) && verbose)\n\t\tfprintf(stderr, \"- while (1)\\n\");\n\twhile (todo_echo || todo_recv) {\n\t\t/*\n\t\t * re-use peername for storing the sender's peername of\n\t\t * received packets\n\t\t */\n\t\tif (verbose)\n\t\t\tfprintf(stderr, \"- recvfrom(, <dat>, %zi, 0, &<peername>, %zi);\\n\", sizeof(peername), sizeof(peername));\n\t\tpeernamelen = sizeof(peername);\n\t\tret = recvfrom(sock, dat, sizeof(dat), 0,\n\t\t\t\t(void *)&peername, &peernamelen);\n\t\tif (ret < 0) {\n\t\t\tif (EINTR == errno) {\n\t\t\t\tif (verbose)\n\t\t\t\t\tfprintf(stderr, \"-\\t<interrupted>\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(1, \"recvfrom()\");\n\t\t}\n\n\t\tif (todo_echo) {\n\t\t\tif (verbose)\n\t\t\t\tfprintf(stderr, \"- sendto(, <dat>, %i, 0, %s, %i);\\n\", ret, libj1939_addr2str(&peername), peernamelen);\n\t\t\tret = sendto(sock, dat, ret, 0,\n\t\t\t\t\t(void *)&peername, peernamelen);\n\t\t\tif (ret < 0)\n\t\t\t\terr(1, \"sendto\");\n\t\t}\n\t\tif (todo_recv) {\n\t\t\tint i;\n\n\t\t\tif (todo_names && peername.can_addr.j1939.name)\n\t\t\t\tprintf(\"%016llx \", peername.can_addr.j1939.name);\n\t\t\tprintf(\"%02x %05x:\", peername.can_addr.j1939.addr,\n\t\t\t\t\tpeername.can_addr.j1939.pgn);\n\t\t\tfor (i = 0, j = 0; i < ret; ++i, j++) {\n\t\t\t\tif (j == 8) {\n\t\t\t\t\tprintf(\"\\n%05x    \", i);\n\t\t\t\t\tj = 0;\n\t\t\t\t}\n\t\t\t\tprintf(\" %02x\", dat[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\tif (todo_wait)\n\t\tfor (;;)\n\t\t\tsleep(1);\n\treturn 0;\n}\n\n"
        }
      ]
    }
  ]
}