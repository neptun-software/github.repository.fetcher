{
  "metadata": {
    "timestamp": 1736709693077,
    "page": 63,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kokke/tiny-AES-c",
      "stars": 4357,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.04296875,
          "content": "/*.o\n/test.elf\n/test.map\ntest_package/build\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.357421875,
          "content": "cmake_minimum_required(VERSION 3.12)\n\nproject(tiny-aes C)\n\nadd_library(${PROJECT_NAME} \"\")\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n        ${CMAKE_CURRENT_LIST_DIR}/aes.c\n    INTERFACE\n        ${CMAKE_CURRENT_LIST_DIR}/aes.h\n        ${CMAKE_CURRENT_LIST_DIR}/aes.hpp\n)\n\ntarget_include_directories(${PROJECT_NAME}\n    INTERFACE\n        ${CMAKE_CURRENT_LIST_DIR}\n)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.1826171875,
          "content": "#CC           = avr-gcc\n#CFLAGS       = -Wall -mmcu=atmega16 -Os -Wl,-Map,test.map\n#OBJCOPY      = avr-objcopy\nCC           = gcc\nLD           = gcc\nAR           = ar\nARFLAGS      = rcs\nCFLAGS       = -Wall -Os -c\nLDFLAGS      = -Wall -Os -Wl,-Map,test.map\nifdef AES192\nCFLAGS += -DAES192=1\nendif\nifdef AES256\nCFLAGS += -DAES256=1\nendif\n\nOBJCOPYFLAGS = -j .text -O ihex\nOBJCOPY      = objcopy\n\n# include path to AVR library\nINCLUDE_PATH = /usr/lib/avr/include\n# splint static check\nSPLINT       = splint test.c aes.c -I$(INCLUDE_PATH) +charindex -unrecog\n\ndefault: test.elf\n\n.SILENT:\n.PHONY:  lint clean\n\ntest.hex : test.elf\n\techo copy object-code to new image and format in hex\n\t$(OBJCOPY) ${OBJCOPYFLAGS} $< $@\n\ntest.o : test.c aes.h aes.o\n\techo [CC] $@ $(CFLAGS)\n\t$(CC) $(CFLAGS) -o  $@ $<\n\naes.o : aes.c aes.h\n\techo [CC] $@ $(CFLAGS)\n\t$(CC) $(CFLAGS) -o $@ $<\n\ntest.elf : aes.o test.o\n\techo [LD] $@\n\t$(LD) $(LDFLAGS) -o $@ $^\n\naes.a : aes.o\n\techo [AR] $@\n\t$(AR) $(ARFLAGS) $@ $^\n\nlib : aes.a\n\nclean:\n\trm -f *.OBJ *.LST *.o *.gch *.out *.hex *.map *.elf *.a\n\ntest:\n\tmake clean && make && ./test.elf\n\tmake clean && make AES192=1 && ./test.elf\n\tmake clean && make AES256=1 && ./test.elf\n\nlint:\n\t$(call SPLINT)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.685546875,
          "content": "![CI](https://github.com/kokke/tiny-AES-c/actions/workflows/c-cpp.yml/badge.svg)\n### Tiny AES in C\n\nThis is a small and portable implementation of the AES [ECB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29), [CTR](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_.28CTR.29) and [CBC](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29) encryption algorithms written in C.\n\nYou can override the default key-size of 128 bit with 192 or 256 bit by defining the symbols AES192 or AES256 in [`aes.h`](https://github.com/kokke/tiny-AES-c/blob/master/aes.h).\n\nThe API is very simple and looks like this (I am using C99 `<stdint.h>`-style annotated types):\n\n```C\n/* Initialize context calling one of: */\nvoid AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key);\nvoid AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv);\n\n/* ... or reset IV at random point: */\nvoid AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv);\n\n/* Then start encrypting and decrypting with the functions below: */\nvoid AES_ECB_encrypt(const struct AES_ctx* ctx, uint8_t* buf);\nvoid AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf);\n\nvoid AES_CBC_encrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);\nvoid AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);\n\n/* Same function for encrypting as for decrypting in CTR mode */\nvoid AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);\n```\n\nImportant notes: \n * No padding is provided so for CBC and ECB all buffers should be multiples of 16 bytes. For padding [PKCS7](https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7) is recommendable.\n * ECB mode is considered unsafe for most uses and is not implemented in streaming mode. If you need this mode, call the function for every block of 16 bytes you need encrypted. See [wikipedia's article on ECB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB)) for more details.\n * This library is designed for small code size and simplicity, intended for cases where small binary size, low memory footprint and portability is more important than high performance. If speed is a concern, you can try more complex libraries, e.g. [Mbed TLS](https://tls.mbed.org/), [OpenSSL](https://www.openssl.org/) etc.\n\nYou can choose to use any or all of the modes-of-operations, by defining the symbols CBC, CTR or ECB in [`aes.h`](https://github.com/kokke/tiny-AES-c/blob/master/aes.h) (read the comments for clarification).\n\nC++ users should `#include` [aes.hpp](https://github.com/kokke/tiny-AES-c/blob/master/aes.hpp) instead of [aes.h](https://github.com/kokke/tiny-AES-c/blob/master/aes.h)\n\nThere is no built-in error checking or protection from out-of-bounds memory access errors as a result of malicious input.\n\nThe module uses less than 200 bytes of RAM and 1-2K ROM when compiled for ARM, but YMMV depending on which modes are enabled.\n\nIt is one of the smallest implementations in C I've seen yet, but do contact me if you know of something smaller (or have improvements to the code here). \n\nI've successfully used the code on 64bit x86, 32bit ARM and 8 bit AVR platforms.\n\n\nGCC size output when only CTR mode is compiled for ARM:\n\n    $ arm-none-eabi-gcc -Os -DCBC=0 -DECB=0 -DCTR=1 -c aes.c\n    $ size aes.o\n       text    data     bss     dec     hex filename\n       1171       0       0    1171     493 aes.o\n\n.. and when compiling for the THUMB instruction set, we end up well below 1K in code size.\n\n    $ arm-none-eabi-gcc -Os -mthumb -DCBC=0 -DECB=0 -DCTR=1 -c aes.c\n    $ size aes.o\n       text    data     bss     dec     hex filename\n        903       0       0     903     387 aes.o\n\n\nI am using the Free Software Foundation, ARM GCC compiler:\n\n    $ arm-none-eabi-gcc --version\n    arm-none-eabi-gcc (4.8.4-1+11-1) 4.8.4 20141219 (release)\n    Copyright (C) 2013 Free Software Foundation, Inc.\n    This is free software; see the source for copying conditions.  There is NO\n    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n\n\n\nThis implementation is verified against the data in:\n\n[National Institute of Standards and Technology Special Publication 800-38A 2001 ED](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf) Appendix F: Example Vectors for Modes of Operation of the AES.\n\nThe other appendices in the document are valuable for implementation details on e.g. padding, generation of IVs and nonces in CTR-mode etc.\n\n\nA heartfelt thank-you to [all the nice people](https://github.com/kokke/tiny-AES-c/graphs/contributors) out there who have contributed to this project.\n\n\nAll material in this repository is in the public domain.\n"
        },
        {
          "name": "aes.c",
          "type": "blob",
          "size": 18.5712890625,
          "content": "/*\n\nThis is an implementation of the AES algorithm, specifically ECB, CTR and CBC mode.\nBlock size can be chosen in aes.h - available choices are AES128, AES192, AES256.\n\nThe implementation is verified against the test vectors in:\n  National Institute of Standards and Technology Special Publication 800-38A 2001 ED\n\nECB-AES128\n----------\n\n  plain-text:\n    6bc1bee22e409f96e93d7e117393172a\n    ae2d8a571e03ac9c9eb76fac45af8e51\n    30c81c46a35ce411e5fbc1191a0a52ef\n    f69f2445df4f9b17ad2b417be66c3710\n\n  key:\n    2b7e151628aed2a6abf7158809cf4f3c\n\n  resulting cipher\n    3ad77bb40d7a3660a89ecaf32466ef97 \n    f5d3d58503b9699de785895a96fdbaaf \n    43b1cd7f598ece23881b00e3ed030688 \n    7b0c785e27e8ad3f8223207104725dd4 \n\n\nNOTE:   String length must be evenly divisible by 16byte (str_len % 16 == 0)\n        You should pad the end of the string with zeros if this is not the case.\n        For AES192/256 the key size is proportionally larger.\n\n*/\n\n\n/*****************************************************************************/\n/* Includes:                                                                 */\n/*****************************************************************************/\n#include <string.h> // CBC mode, for memset\n#include \"aes.h\"\n\n/*****************************************************************************/\n/* Defines:                                                                  */\n/*****************************************************************************/\n// The number of columns comprising a state in AES. This is a constant in AES. Value=4\n#define Nb 4\n\n#if defined(AES256) && (AES256 == 1)\n    #define Nk 8\n    #define Nr 14\n#elif defined(AES192) && (AES192 == 1)\n    #define Nk 6\n    #define Nr 12\n#else\n    #define Nk 4        // The number of 32 bit words in a key.\n    #define Nr 10       // The number of rounds in AES Cipher.\n#endif\n\n// jcallan@github points out that declaring Multiply as a function \n// reduces code size considerably with the Keil ARM compiler.\n// See this link for more information: https://github.com/kokke/tiny-AES-C/pull/3\n#ifndef MULTIPLY_AS_A_FUNCTION\n  #define MULTIPLY_AS_A_FUNCTION 0\n#endif\n\n\n\n\n/*****************************************************************************/\n/* Private variables:                                                        */\n/*****************************************************************************/\n// state - array holding the intermediate results during decryption.\ntypedef uint8_t state_t[4][4];\n\n\n\n// The lookup-tables are marked const so they can be placed in read-only storage instead of RAM\n// The numbers below can be computed dynamically trading ROM for RAM - \n// This can be useful in (embedded) bootloader applications, where ROM is often limited.\nstatic const uint8_t sbox[256] = {\n  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F\n  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };\n\n#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)\nstatic const uint8_t rsbox[256] = {\n  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };\n#endif\n\n// The round constant word array, Rcon[i], contains the values given by \n// x to the power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)\nstatic const uint8_t Rcon[11] = {\n  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };\n\n/*\n * Jordan Goulder points out in PR #12 (https://github.com/kokke/tiny-AES-C/pull/12),\n * that you can remove most of the elements in the Rcon array, because they are unused.\n *\n * From Wikipedia's article on the Rijndael key schedule @ https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon\n * \n * \"Only the first some of these constants are actually used – up to rcon[10] for AES-128 (as 11 round keys are needed), \n *  up to rcon[8] for AES-192, up to rcon[7] for AES-256. rcon[0] is not used in AES algorithm.\"\n */\n\n\n/*****************************************************************************/\n/* Private functions:                                                        */\n/*****************************************************************************/\n/*\nstatic uint8_t getSBoxValue(uint8_t num)\n{\n  return sbox[num];\n}\n*/\n#define getSBoxValue(num) (sbox[(num)])\n\n// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. \nstatic void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)\n{\n  unsigned i, j, k;\n  uint8_t tempa[4]; // Used for the column/row operations\n  \n  // The first round key is the key itself.\n  for (i = 0; i < Nk; ++i)\n  {\n    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];\n    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];\n    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];\n    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];\n  }\n\n  // All other round keys are found from the previous round keys.\n  for (i = Nk; i < Nb * (Nr + 1); ++i)\n  {\n    {\n      k = (i - 1) * 4;\n      tempa[0]=RoundKey[k + 0];\n      tempa[1]=RoundKey[k + 1];\n      tempa[2]=RoundKey[k + 2];\n      tempa[3]=RoundKey[k + 3];\n\n    }\n\n    if (i % Nk == 0)\n    {\n      // This function shifts the 4 bytes in a word to the left once.\n      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]\n\n      // Function RotWord()\n      {\n        const uint8_t u8tmp = tempa[0];\n        tempa[0] = tempa[1];\n        tempa[1] = tempa[2];\n        tempa[2] = tempa[3];\n        tempa[3] = u8tmp;\n      }\n\n      // SubWord() is a function that takes a four-byte input word and \n      // applies the S-box to each of the four bytes to produce an output word.\n\n      // Function Subword()\n      {\n        tempa[0] = getSBoxValue(tempa[0]);\n        tempa[1] = getSBoxValue(tempa[1]);\n        tempa[2] = getSBoxValue(tempa[2]);\n        tempa[3] = getSBoxValue(tempa[3]);\n      }\n\n      tempa[0] = tempa[0] ^ Rcon[i/Nk];\n    }\n#if defined(AES256) && (AES256 == 1)\n    if (i % Nk == 4)\n    {\n      // Function Subword()\n      {\n        tempa[0] = getSBoxValue(tempa[0]);\n        tempa[1] = getSBoxValue(tempa[1]);\n        tempa[2] = getSBoxValue(tempa[2]);\n        tempa[3] = getSBoxValue(tempa[3]);\n      }\n    }\n#endif\n    j = i * 4; k=(i - Nk) * 4;\n    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];\n    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];\n    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];\n    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];\n  }\n}\n\nvoid AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key)\n{\n  KeyExpansion(ctx->RoundKey, key);\n}\n#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))\nvoid AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv)\n{\n  KeyExpansion(ctx->RoundKey, key);\n  memcpy (ctx->Iv, iv, AES_BLOCKLEN);\n}\nvoid AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv)\n{\n  memcpy (ctx->Iv, iv, AES_BLOCKLEN);\n}\n#endif\n\n// This function adds the round key to state.\n// The round key is added to the state by an XOR function.\nstatic void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)\n{\n  uint8_t i,j;\n  for (i = 0; i < 4; ++i)\n  {\n    for (j = 0; j < 4; ++j)\n    {\n      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];\n    }\n  }\n}\n\n// The SubBytes Function Substitutes the values in the\n// state matrix with values in an S-box.\nstatic void SubBytes(state_t* state)\n{\n  uint8_t i, j;\n  for (i = 0; i < 4; ++i)\n  {\n    for (j = 0; j < 4; ++j)\n    {\n      (*state)[j][i] = getSBoxValue((*state)[j][i]);\n    }\n  }\n}\n\n// The ShiftRows() function shifts the rows in the state to the left.\n// Each row is shifted with different offset.\n// Offset = Row number. So the first row is not shifted.\nstatic void ShiftRows(state_t* state)\n{\n  uint8_t temp;\n\n  // Rotate first row 1 columns to left  \n  temp           = (*state)[0][1];\n  (*state)[0][1] = (*state)[1][1];\n  (*state)[1][1] = (*state)[2][1];\n  (*state)[2][1] = (*state)[3][1];\n  (*state)[3][1] = temp;\n\n  // Rotate second row 2 columns to left  \n  temp           = (*state)[0][2];\n  (*state)[0][2] = (*state)[2][2];\n  (*state)[2][2] = temp;\n\n  temp           = (*state)[1][2];\n  (*state)[1][2] = (*state)[3][2];\n  (*state)[3][2] = temp;\n\n  // Rotate third row 3 columns to left\n  temp           = (*state)[0][3];\n  (*state)[0][3] = (*state)[3][3];\n  (*state)[3][3] = (*state)[2][3];\n  (*state)[2][3] = (*state)[1][3];\n  (*state)[1][3] = temp;\n}\n\nstatic uint8_t xtime(uint8_t x)\n{\n  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));\n}\n\n// MixColumns function mixes the columns of the state matrix\nstatic void MixColumns(state_t* state)\n{\n  uint8_t i;\n  uint8_t Tmp, Tm, t;\n  for (i = 0; i < 4; ++i)\n  {  \n    t   = (*state)[i][0];\n    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;\n    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;\n    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;\n    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;\n    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;\n  }\n}\n\n// Multiply is used to multiply numbers in the field GF(2^8)\n// Note: The last call to xtime() is unneeded, but often ends up generating a smaller binary\n//       The compiler seems to be able to vectorize the operation better this way.\n//       See https://github.com/kokke/tiny-AES-c/pull/34\n#if MULTIPLY_AS_A_FUNCTION\nstatic uint8_t Multiply(uint8_t x, uint8_t y)\n{\n  return (((y & 1) * x) ^\n       ((y>>1 & 1) * xtime(x)) ^\n       ((y>>2 & 1) * xtime(xtime(x))) ^\n       ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^\n       ((y>>4 & 1) * xtime(xtime(xtime(xtime(x)))))); /* this last call to xtime() can be omitted */\n  }\n#else\n#define Multiply(x, y)                                \\\n      (  ((y & 1) * x) ^                              \\\n      ((y>>1 & 1) * xtime(x)) ^                       \\\n      ((y>>2 & 1) * xtime(xtime(x))) ^                \\\n      ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \\\n      ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))   \\\n\n#endif\n\n#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)\n/*\nstatic uint8_t getSBoxInvert(uint8_t num)\n{\n  return rsbox[num];\n}\n*/\n#define getSBoxInvert(num) (rsbox[(num)])\n\n// MixColumns function mixes the columns of the state matrix.\n// The method used to multiply may be difficult to understand for the inexperienced.\n// Please use the references to gain more information.\nstatic void InvMixColumns(state_t* state)\n{\n  int i;\n  uint8_t a, b, c, d;\n  for (i = 0; i < 4; ++i)\n  { \n    a = (*state)[i][0];\n    b = (*state)[i][1];\n    c = (*state)[i][2];\n    d = (*state)[i][3];\n\n    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);\n    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);\n    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);\n    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);\n  }\n}\n\n\n// The SubBytes Function Substitutes the values in the\n// state matrix with values in an S-box.\nstatic void InvSubBytes(state_t* state)\n{\n  uint8_t i, j;\n  for (i = 0; i < 4; ++i)\n  {\n    for (j = 0; j < 4; ++j)\n    {\n      (*state)[j][i] = getSBoxInvert((*state)[j][i]);\n    }\n  }\n}\n\nstatic void InvShiftRows(state_t* state)\n{\n  uint8_t temp;\n\n  // Rotate first row 1 columns to right  \n  temp = (*state)[3][1];\n  (*state)[3][1] = (*state)[2][1];\n  (*state)[2][1] = (*state)[1][1];\n  (*state)[1][1] = (*state)[0][1];\n  (*state)[0][1] = temp;\n\n  // Rotate second row 2 columns to right \n  temp = (*state)[0][2];\n  (*state)[0][2] = (*state)[2][2];\n  (*state)[2][2] = temp;\n\n  temp = (*state)[1][2];\n  (*state)[1][2] = (*state)[3][2];\n  (*state)[3][2] = temp;\n\n  // Rotate third row 3 columns to right\n  temp = (*state)[0][3];\n  (*state)[0][3] = (*state)[1][3];\n  (*state)[1][3] = (*state)[2][3];\n  (*state)[2][3] = (*state)[3][3];\n  (*state)[3][3] = temp;\n}\n#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)\n\n// Cipher is the main function that encrypts the PlainText.\nstatic void Cipher(state_t* state, const uint8_t* RoundKey)\n{\n  uint8_t round = 0;\n\n  // Add the First round key to the state before starting the rounds.\n  AddRoundKey(0, state, RoundKey);\n\n  // There will be Nr rounds.\n  // The first Nr-1 rounds are identical.\n  // These Nr rounds are executed in the loop below.\n  // Last one without MixColumns()\n  for (round = 1; ; ++round)\n  {\n    SubBytes(state);\n    ShiftRows(state);\n    if (round == Nr) {\n      break;\n    }\n    MixColumns(state);\n    AddRoundKey(round, state, RoundKey);\n  }\n  // Add round key to last round\n  AddRoundKey(Nr, state, RoundKey);\n}\n\n#if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)\nstatic void InvCipher(state_t* state, const uint8_t* RoundKey)\n{\n  uint8_t round = 0;\n\n  // Add the First round key to the state before starting the rounds.\n  AddRoundKey(Nr, state, RoundKey);\n\n  // There will be Nr rounds.\n  // The first Nr-1 rounds are identical.\n  // These Nr rounds are executed in the loop below.\n  // Last one without InvMixColumn()\n  for (round = (Nr - 1); ; --round)\n  {\n    InvShiftRows(state);\n    InvSubBytes(state);\n    AddRoundKey(round, state, RoundKey);\n    if (round == 0) {\n      break;\n    }\n    InvMixColumns(state);\n  }\n\n}\n#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)\n\n/*****************************************************************************/\n/* Public functions:                                                         */\n/*****************************************************************************/\n#if defined(ECB) && (ECB == 1)\n\n\nvoid AES_ECB_encrypt(const struct AES_ctx* ctx, uint8_t* buf)\n{\n  // The next function call encrypts the PlainText with the Key using AES algorithm.\n  Cipher((state_t*)buf, ctx->RoundKey);\n}\n\nvoid AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf)\n{\n  // The next function call decrypts the PlainText with the Key using AES algorithm.\n  InvCipher((state_t*)buf, ctx->RoundKey);\n}\n\n\n#endif // #if defined(ECB) && (ECB == 1)\n\n\n\n\n\n#if defined(CBC) && (CBC == 1)\n\n\nstatic void XorWithIv(uint8_t* buf, const uint8_t* Iv)\n{\n  uint8_t i;\n  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size\n  {\n    buf[i] ^= Iv[i];\n  }\n}\n\nvoid AES_CBC_encrypt_buffer(struct AES_ctx *ctx, uint8_t* buf, size_t length)\n{\n  size_t i;\n  uint8_t *Iv = ctx->Iv;\n  for (i = 0; i < length; i += AES_BLOCKLEN)\n  {\n    XorWithIv(buf, Iv);\n    Cipher((state_t*)buf, ctx->RoundKey);\n    Iv = buf;\n    buf += AES_BLOCKLEN;\n  }\n  /* store Iv in ctx for next call */\n  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);\n}\n\nvoid AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)\n{\n  size_t i;\n  uint8_t storeNextIv[AES_BLOCKLEN];\n  for (i = 0; i < length; i += AES_BLOCKLEN)\n  {\n    memcpy(storeNextIv, buf, AES_BLOCKLEN);\n    InvCipher((state_t*)buf, ctx->RoundKey);\n    XorWithIv(buf, ctx->Iv);\n    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);\n    buf += AES_BLOCKLEN;\n  }\n\n}\n\n#endif // #if defined(CBC) && (CBC == 1)\n\n\n\n#if defined(CTR) && (CTR == 1)\n\n/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */\nvoid AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)\n{\n  uint8_t buffer[AES_BLOCKLEN];\n  \n  size_t i;\n  int bi;\n  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)\n  {\n    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */\n    {\n      \n      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);\n      Cipher((state_t*)buffer,ctx->RoundKey);\n\n      /* Increment Iv and handle overflow */\n      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)\n      {\n\t/* inc will overflow */\n        if (ctx->Iv[bi] == 255)\n\t{\n          ctx->Iv[bi] = 0;\n          continue;\n        } \n        ctx->Iv[bi] += 1;\n        break;   \n      }\n      bi = 0;\n    }\n\n    buf[i] = (buf[i] ^ buffer[bi]);\n  }\n}\n\n#endif // #if defined(CTR) && (CTR == 1)\n\n"
        },
        {
          "name": "aes.h",
          "type": "blob",
          "size": 2.724609375,
          "content": "#ifndef _AES_H_\n#define _AES_H_\n\n#include <stdint.h>\n#include <stddef.h>\n\n// #define the macros below to 1/0 to enable/disable the mode of operation.\n//\n// CBC enables AES encryption in CBC-mode of operation.\n// CTR enables encryption in counter-mode.\n// ECB enables the basic ECB 16-byte block algorithm. All can be enabled simultaneously.\n\n// The #ifndef-guard allows it to be configured before #include'ing or at compile time.\n#ifndef CBC\n  #define CBC 1\n#endif\n\n#ifndef ECB\n  #define ECB 1\n#endif\n\n#ifndef CTR\n  #define CTR 1\n#endif\n\n\n#define AES128 1\n//#define AES192 1\n//#define AES256 1\n\n#define AES_BLOCKLEN 16 // Block length in bytes - AES is 128b block only\n\n#if defined(AES256) && (AES256 == 1)\n    #define AES_KEYLEN 32\n    #define AES_keyExpSize 240\n#elif defined(AES192) && (AES192 == 1)\n    #define AES_KEYLEN 24\n    #define AES_keyExpSize 208\n#else\n    #define AES_KEYLEN 16   // Key length in bytes\n    #define AES_keyExpSize 176\n#endif\n\nstruct AES_ctx\n{\n  uint8_t RoundKey[AES_keyExpSize];\n#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))\n  uint8_t Iv[AES_BLOCKLEN];\n#endif\n};\n\nvoid AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key);\n#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))\nvoid AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv);\nvoid AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv);\n#endif\n\n#if defined(ECB) && (ECB == 1)\n// buffer size is exactly AES_BLOCKLEN bytes; \n// you need only AES_init_ctx as IV is not used in ECB \n// NB: ECB is considered insecure for most uses\nvoid AES_ECB_encrypt(const struct AES_ctx* ctx, uint8_t* buf);\nvoid AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf);\n\n#endif // #if defined(ECB) && (ECB == !)\n\n\n#if defined(CBC) && (CBC == 1)\n// buffer size MUST be mutile of AES_BLOCKLEN;\n// Suggest https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme\n// NOTES: you need to set IV in ctx via AES_init_ctx_iv() or AES_ctx_set_iv()\n//        no IV should ever be reused with the same key \nvoid AES_CBC_encrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);\nvoid AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);\n\n#endif // #if defined(CBC) && (CBC == 1)\n\n\n#if defined(CTR) && (CTR == 1)\n\n// Same function for encrypting as for decrypting. \n// IV is incremented for every block, and used after encryption as XOR-compliment for output\n// Suggesting https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme\n// NOTES: you need to set IV in ctx with AES_init_ctx_iv() or AES_ctx_set_iv()\n//        no IV should ever be reused with the same key \nvoid AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length);\n\n#endif // #if defined(CTR) && (CTR == 1)\n\n\n#endif // _AES_H_\n"
        },
        {
          "name": "aes.hpp",
          "type": "blob",
          "size": 0.1796875,
          "content": "#ifndef _AES_HPP_\n#define _AES_HPP_\n\n#ifndef __cplusplus\n#error Do not include the hpp header in a c project!\n#endif //__cplusplus\n\nextern \"C\" {\n#include \"aes.h\"\n}\n\n#endif //_AES_HPP_\n"
        },
        {
          "name": "conanfile.py",
          "type": "blob",
          "size": 2.001953125,
          "content": "from conans import ConanFile, CMake\nfrom conans.errors import ConanException\n\n\nclass TinyAesCConan(ConanFile):\n    name = \"tiny-AES-c\"\n    version = \"1.0.0\"\n    license = \"The Unlicense\"\n    url = \"https://github.com/kokke/tiny-AES-c\"\n    description = \"Small portable AES128/192/256 in C\"\n    topics = (\"encryption\", \"crypto\", \"AES\")\n    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n\n    generators = \"cmake\"\n    exports_sources = [\"CMakeLists.txt\", \"*.c\", '*.h', '*.hpp']\n    exports = [\"unlicense.txt\"]\n\n    _options_dict = {\n        # enable AES128\n        \"AES128\": [True, False],\n\n        # enable AES192\n        \"AES192\": [True, False],\n\n        # enable AES256\n        \"AES256\": [True, False],\n\n        # enable AES encryption in CBC-mode of operation\n        \"CBC\": [True, False],\n\n        # enable the basic ECB 16-byte block algorithm\n        \"ECB\": [True, False],\n\n        # enable encryption in counter-mode\n        \"CTR\": [True, False],\n    }\n\n    options = _options_dict\n\n    default_options = {\n        \"AES128\": True,\n        \"AES192\": False,\n        \"AES256\": False,\n        \"CBC\": True,\n        \"ECB\": True,\n        \"CTR\": True\n    }\n\n    def configure(self):\n        if not self.options.CBC and not self.options.ECB and not self.options.CTR:\n            raise ConanException(\"Need to at least specify one of CBC, ECB or CTR modes\")\n\n        if not self.options.AES128 and not self.options.AES192 and not self.options.AES256:\n            raise ConanException(\"Need to at least specify one of AES{128, 192, 256} modes\")\n\n    def build(self):\n        cmake = CMake(self)\n\n        for key in self._options_dict.keys():\n            if self.options[key]:\n                cmake.definitions[\"CMAKE_CFLAGS\"].append(key)\n\n        cmake.configure()\n        cmake.build()\n\n    def package(self):\n        self.copy(\"*.h\", dst=\"include\")\n        self.copy(\"*.hpp\", dst=\"include\")\n        self.copy(\"*.a\", dst=\"lib\", keep_path=False)\n        self.copy(\"unlicense.txt\")\n\n    def package_info(self):\n        self.cpp_info.libs = [\"tiny-aes\"]\n"
        },
        {
          "name": "library.json",
          "type": "blob",
          "size": 0.4365234375,
          "content": "{\n    \"version\": \"1.0.0\",\n    \"name\": \"tiny-AES-c\",\n    \"keywords\": \"cryptography, aes\",\n    \"description\": \"Small portable AES128/192/256 in C\",\n    \"repository\":\n    {\n        \"type\": \"git\",\n        \"branch\": \"master\",\n        \"url\": \"https://github.com/kokke/tiny-AES-c.git\"\n    },\n    \"frameworks\": \"*\",\n    \"platforms\": \"*\",\n    \"examples\": \"test.c\",\n    \"build\":\n\t{\n\t\t\"srcFilter\": \"+<*> -<.git/> -<test.c> -<test.cpp> -<test_package/>\"\n\t}\n}\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.5439453125,
          "content": "name=tiny-AES-c\nversion=1.0.0\nauthor=kokke\nmaintainer=kokke\nsentence=A small and portable implementation of the AES ECB, CTR and CBC encryption algorithms written in C.\nparagraph=You can override the default key-size of 128 bit with 192 or 256 bit by defining the symbols AES192 or AES256 in aes.h. The API is very simple. No padding is provided so for CBC and ECB all buffers should be multiples of 16 bytes.\ncategory=Data Processing\nurl=https://github.com/kokke/tiny-AES-c\nrepository=https://github.com/kokke/tiny-AES-c.git\narchitectures=*\nincludes=aes.h\n"
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 15.1748046875,
          "content": "#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n// Enable ECB, CTR and CBC mode. Note this can be done before including aes.h or at compile-time.\n// E.g. with GCC by using the -D flag: gcc -c aes.c -DCBC=0 -DCTR=1 -DECB=1\n#define CBC 1\n#define CTR 1\n#define ECB 1\n\n#include \"aes.h\"\n\n\nstatic void phex(uint8_t* str);\nstatic int test_encrypt_cbc(void);\nstatic int test_decrypt_cbc(void);\nstatic int test_encrypt_ctr(void);\nstatic int test_decrypt_ctr(void);\nstatic int test_encrypt_ecb(void);\nstatic int test_decrypt_ecb(void);\nstatic void test_encrypt_ecb_verbose(void);\n\n\nint main(void)\n{\n    int exit;\n\n#if defined(AES256)\n    printf(\"\\nTesting AES256\\n\\n\");\n#elif defined(AES192)\n    printf(\"\\nTesting AES192\\n\\n\");\n#elif defined(AES128)\n    printf(\"\\nTesting AES128\\n\\n\");\n#else\n    printf(\"You need to specify a symbol between AES128, AES192 or AES256. Exiting\");\n    return 0;\n#endif\n\n    exit = test_encrypt_cbc() + test_decrypt_cbc() +\n\ttest_encrypt_ctr() + test_decrypt_ctr() +\n\ttest_decrypt_ecb() + test_encrypt_ecb();\n    test_encrypt_ecb_verbose();\n\n    return exit;\n}\n\n\n// prints string as hex\nstatic void phex(uint8_t* str)\n{\n\n#if defined(AES256)\n    uint8_t len = 32;\n#elif defined(AES192)\n    uint8_t len = 24;\n#elif defined(AES128)\n    uint8_t len = 16;\n#endif\n\n    unsigned char i;\n    for (i = 0; i < len; ++i)\n        printf(\"%.2x\", str[i]);\n    printf(\"\\n\");\n}\n\nstatic void test_encrypt_ecb_verbose(void)\n{\n    // Example of more verbose verification\n\n    uint8_t i;\n\n    // 128bit key\n    uint8_t key[16] =        { (uint8_t) 0x2b, (uint8_t) 0x7e, (uint8_t) 0x15, (uint8_t) 0x16, (uint8_t) 0x28, (uint8_t) 0xae, (uint8_t) 0xd2, (uint8_t) 0xa6, (uint8_t) 0xab, (uint8_t) 0xf7, (uint8_t) 0x15, (uint8_t) 0x88, (uint8_t) 0x09, (uint8_t) 0xcf, (uint8_t) 0x4f, (uint8_t) 0x3c };\n    // 512bit text\n    uint8_t plain_text[64] = { (uint8_t) 0x6b, (uint8_t) 0xc1, (uint8_t) 0xbe, (uint8_t) 0xe2, (uint8_t) 0x2e, (uint8_t) 0x40, (uint8_t) 0x9f, (uint8_t) 0x96, (uint8_t) 0xe9, (uint8_t) 0x3d, (uint8_t) 0x7e, (uint8_t) 0x11, (uint8_t) 0x73, (uint8_t) 0x93, (uint8_t) 0x17, (uint8_t) 0x2a,\n                               (uint8_t) 0xae, (uint8_t) 0x2d, (uint8_t) 0x8a, (uint8_t) 0x57, (uint8_t) 0x1e, (uint8_t) 0x03, (uint8_t) 0xac, (uint8_t) 0x9c, (uint8_t) 0x9e, (uint8_t) 0xb7, (uint8_t) 0x6f, (uint8_t) 0xac, (uint8_t) 0x45, (uint8_t) 0xaf, (uint8_t) 0x8e, (uint8_t) 0x51,\n                               (uint8_t) 0x30, (uint8_t) 0xc8, (uint8_t) 0x1c, (uint8_t) 0x46, (uint8_t) 0xa3, (uint8_t) 0x5c, (uint8_t) 0xe4, (uint8_t) 0x11, (uint8_t) 0xe5, (uint8_t) 0xfb, (uint8_t) 0xc1, (uint8_t) 0x19, (uint8_t) 0x1a, (uint8_t) 0x0a, (uint8_t) 0x52, (uint8_t) 0xef,\n                               (uint8_t) 0xf6, (uint8_t) 0x9f, (uint8_t) 0x24, (uint8_t) 0x45, (uint8_t) 0xdf, (uint8_t) 0x4f, (uint8_t) 0x9b, (uint8_t) 0x17, (uint8_t) 0xad, (uint8_t) 0x2b, (uint8_t) 0x41, (uint8_t) 0x7b, (uint8_t) 0xe6, (uint8_t) 0x6c, (uint8_t) 0x37, (uint8_t) 0x10 };\n\n    // print text to encrypt, key and IV\n    printf(\"ECB encrypt verbose:\\n\\n\");\n    printf(\"plain text:\\n\");\n    for (i = (uint8_t) 0; i < (uint8_t) 4; ++i)\n    {\n        phex(plain_text + i * (uint8_t) 16);\n    }\n    printf(\"\\n\");\n\n    printf(\"key:\\n\");\n    phex(key);\n    printf(\"\\n\");\n\n    // print the resulting cipher as 4 x 16 byte strings\n    printf(\"ciphertext:\\n\");\n    \n    struct AES_ctx ctx;\n    AES_init_ctx(&ctx, key);\n\n    for (i = 0; i < 4; ++i)\n    {\n      AES_ECB_encrypt(&ctx, plain_text + (i * 16));\n      phex(plain_text + (i * 16));\n    }\n    printf(\"\\n\");\n}\n\n\nstatic int test_encrypt_ecb(void)\n{\n#if defined(AES256)\n    uint8_t key[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,\n                      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };\n    uint8_t out[] = { 0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c, 0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8 };\n#elif defined(AES192)\n    uint8_t key[] = { 0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,\n                      0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b };\n    uint8_t out[] = { 0xbd, 0x33, 0x4f, 0x1d, 0x6e, 0x45, 0xf2, 0x5f, 0xf7, 0x12, 0xa2, 0x14, 0x57, 0x1f, 0xa5, 0xcc };\n#elif defined(AES128)\n    uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };\n    uint8_t out[] = { 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97 };\n#endif\n\n    uint8_t in[]  = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a };\n    struct AES_ctx ctx;\n\n    AES_init_ctx(&ctx, key);\n    AES_ECB_encrypt(&ctx, in);\n\n    printf(\"ECB encrypt: \");\n\n    if (0 == memcmp((char*) out, (char*) in, 16)) {\n        printf(\"SUCCESS!\\n\");\n\treturn(0);\n    } else {\n        printf(\"FAILURE!\\n\");\n\treturn(1);\n    }\n}\n\nstatic int test_decrypt_cbc(void)\n{\n\n#if defined(AES256)\n    uint8_t key[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,\n                      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };\n    uint8_t in[]  = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,\n                      0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,\n                      0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,\n                      0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };\n#elif defined(AES192)\n    uint8_t key[] = { 0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5, 0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b };\n    uint8_t in[]  = { 0x4f, 0x02, 0x1d, 0xb2, 0x43, 0xbc, 0x63, 0x3d, 0x71, 0x78, 0x18, 0x3a, 0x9f, 0xa0, 0x71, 0xe8,\n                      0xb4, 0xd9, 0xad, 0xa9, 0xad, 0x7d, 0xed, 0xf4, 0xe5, 0xe7, 0x38, 0x76, 0x3f, 0x69, 0x14, 0x5a,\n                      0x57, 0x1b, 0x24, 0x20, 0x12, 0xfb, 0x7a, 0xe0, 0x7f, 0xa9, 0xba, 0xac, 0x3d, 0xf1, 0x02, 0xe0,\n                      0x08, 0xb0, 0xe2, 0x79, 0x88, 0x59, 0x88, 0x81, 0xd9, 0x20, 0xa9, 0xe6, 0x4f, 0x56, 0x15, 0xcd };\n#elif defined(AES128)\n    uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };\n    uint8_t in[]  = { 0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46, 0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,\n                      0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee, 0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,\n                      0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b, 0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,\n                      0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09, 0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7 };\n#endif\n    uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };\n    uint8_t out[] = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n                      0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n                      0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n                      0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };\n//  uint8_t buffer[64];\n    struct AES_ctx ctx;\n\n    AES_init_ctx_iv(&ctx, key, iv);\n    AES_CBC_decrypt_buffer(&ctx, in, 64);\n\n    printf(\"CBC decrypt: \");\n\n    if (0 == memcmp((char*) out, (char*) in, 64)) {\n        printf(\"SUCCESS!\\n\");\n\treturn(0);\n    } else {\n        printf(\"FAILURE!\\n\");\n\treturn(1);\n    }\n}\n\nstatic int test_encrypt_cbc(void)\n{\n#if defined(AES256)\n    uint8_t key[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,\n                      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };\n    uint8_t out[] = { 0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba, 0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,\n                      0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d, 0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,\n                      0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf, 0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,\n                      0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc, 0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b };\n#elif defined(AES192)\n    uint8_t key[] = { 0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5, 0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b };\n    uint8_t out[] = { 0x4f, 0x02, 0x1d, 0xb2, 0x43, 0xbc, 0x63, 0x3d, 0x71, 0x78, 0x18, 0x3a, 0x9f, 0xa0, 0x71, 0xe8,\n                      0xb4, 0xd9, 0xad, 0xa9, 0xad, 0x7d, 0xed, 0xf4, 0xe5, 0xe7, 0x38, 0x76, 0x3f, 0x69, 0x14, 0x5a,\n                      0x57, 0x1b, 0x24, 0x20, 0x12, 0xfb, 0x7a, 0xe0, 0x7f, 0xa9, 0xba, 0xac, 0x3d, 0xf1, 0x02, 0xe0,\n                      0x08, 0xb0, 0xe2, 0x79, 0x88, 0x59, 0x88, 0x81, 0xd9, 0x20, 0xa9, 0xe6, 0x4f, 0x56, 0x15, 0xcd };\n#elif defined(AES128)\n    uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };\n    uint8_t out[] = { 0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46, 0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,\n                      0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee, 0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,\n                      0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b, 0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,\n                      0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09, 0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7 };\n#endif\n    uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };\n    uint8_t in[]  = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n                      0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n                      0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n                      0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };\n    struct AES_ctx ctx;\n\n    AES_init_ctx_iv(&ctx, key, iv);\n    AES_CBC_encrypt_buffer(&ctx, in, 64);\n\n    printf(\"CBC encrypt: \");\n\n    if (0 == memcmp((char*) out, (char*) in, 64)) {\n        printf(\"SUCCESS!\\n\");\n\treturn(0);\n    } else {\n        printf(\"FAILURE!\\n\");\n\treturn(1);\n    }\n}\n\nstatic int test_xcrypt_ctr(const char* xcrypt);\nstatic int test_encrypt_ctr(void)\n{\n    return test_xcrypt_ctr(\"encrypt\");\n}\n\nstatic int test_decrypt_ctr(void)\n{\n    return test_xcrypt_ctr(\"decrypt\");\n}\n\nstatic int test_xcrypt_ctr(const char* xcrypt)\n{\n#if defined(AES256)\n    uint8_t key[32] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,\n                        0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };\n    uint8_t in[64]  = { 0x60, 0x1e, 0xc3, 0x13, 0x77, 0x57, 0x89, 0xa5, 0xb7, 0xa7, 0xf5, 0x04, 0xbb, 0xf3, 0xd2, 0x28, \n                        0xf4, 0x43, 0xe3, 0xca, 0x4d, 0x62, 0xb5, 0x9a, 0xca, 0x84, 0xe9, 0x90, 0xca, 0xca, 0xf5, 0xc5, \n                        0x2b, 0x09, 0x30, 0xda, 0xa2, 0x3d, 0xe9, 0x4c, 0xe8, 0x70, 0x17, 0xba, 0x2d, 0x84, 0x98, 0x8d, \n                        0xdf, 0xc9, 0xc5, 0x8d, 0xb6, 0x7a, 0xad, 0xa6, 0x13, 0xc2, 0xdd, 0x08, 0x45, 0x79, 0x41, 0xa6 };\n#elif defined(AES192)\n    uint8_t key[24] = { 0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5, \n                        0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b };\n    uint8_t in[64]  = { 0x1a, 0xbc, 0x93, 0x24, 0x17, 0x52, 0x1c, 0xa2, 0x4f, 0x2b, 0x04, 0x59, 0xfe, 0x7e, 0x6e, 0x0b, \n                        0x09, 0x03, 0x39, 0xec, 0x0a, 0xa6, 0xfa, 0xef, 0xd5, 0xcc, 0xc2, 0xc6, 0xf4, 0xce, 0x8e, 0x94, \n                        0x1e, 0x36, 0xb2, 0x6b, 0xd1, 0xeb, 0xc6, 0x70, 0xd1, 0xbd, 0x1d, 0x66, 0x56, 0x20, 0xab, 0xf7, \n                        0x4f, 0x78, 0xa7, 0xf6, 0xd2, 0x98, 0x09, 0x58, 0x5a, 0x97, 0xda, 0xec, 0x58, 0xc6, 0xb0, 0x50 };\n#elif defined(AES128)\n    uint8_t key[16] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };\n    uint8_t in[64]  = { 0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26, 0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,\n                        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff, 0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,\n                        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e, 0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,\n                        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1, 0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee };\n#endif\n    uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };\n    uint8_t out[64] = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n                        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n                        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n                        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };\n    struct AES_ctx ctx;\n    \n    AES_init_ctx_iv(&ctx, key, iv);\n    AES_CTR_xcrypt_buffer(&ctx, in, 64);\n  \n    printf(\"CTR %s: \", xcrypt);\n  \n    if (0 == memcmp((char *) out, (char *) in, 64)) {\n        printf(\"SUCCESS!\\n\");\n\treturn(0);\n    } else {\n        printf(\"FAILURE!\\n\");\n\treturn(1);\n    }\n}\n\n\nstatic int test_decrypt_ecb(void)\n{\n#if defined(AES256)\n    uint8_t key[] = { 0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,\n                      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4 };\n    uint8_t in[]  = { 0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c, 0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8 };\n#elif defined(AES192)\n    uint8_t key[] = { 0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,\n                      0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b };\n    uint8_t in[]  = { 0xbd, 0x33, 0x4f, 0x1d, 0x6e, 0x45, 0xf2, 0x5f, 0xf7, 0x12, 0xa2, 0x14, 0x57, 0x1f, 0xa5, 0xcc };\n#elif defined(AES128)\n    uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };\n    uint8_t in[]  = { 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97 };\n#endif\n\n    uint8_t out[]   = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a };\n    struct AES_ctx ctx;\n    \n    AES_init_ctx(&ctx, key);\n    AES_ECB_decrypt(&ctx, in);\n\n    printf(\"ECB decrypt: \");\n\n    if (0 == memcmp((char*) out, (char*) in, 16)) {\n        printf(\"SUCCESS!\\n\");\n\treturn(0);\n    } else {\n        printf(\"FAILURE!\\n\");\n\treturn(1);\n    }\n}\n\n\n"
        },
        {
          "name": "test.cpp",
          "type": "blob",
          "size": 0.0361328125,
          "content": "#include \"aes.hpp\"\n#include \"test.c\"\n"
        },
        {
          "name": "test_package",
          "type": "tree",
          "content": null
        },
        {
          "name": "unlicense.txt",
          "type": "blob",
          "size": 1.1826171875,
          "content": "This is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n"
        }
      ]
    }
  ]
}