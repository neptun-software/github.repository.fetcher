{
  "metadata": {
    "timestamp": 1736709859649,
    "page": 333,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Ewenwan/ShiYanLou",
      "stars": 2876,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".vimrc",
          "type": "blob",
          "size": 2.53125,
          "content": "// 例子1\nset nocompatible\nset encoding=utf-8\nset fileencodings=utf-8,chinese\nset tabstop=4\nset cindent shiftwidth=4\nset backspace=indent,eol,start\nautocmd Filetype c set omnifunc=ccomplete#Complete\nautocmd Filetype cpp set omnifunc=cppcomplete#Complete\nset incsearch\nset number\nset display=lastline\nset ignorecase\nsyntax on\nset nobackup\nset ruler\nset showcmd\nset smartindent\nset hlsearch\nset cmdheight=1\nset laststatus=2\nset shortmess=atI\nset formatoptions=tcrqn\nset autoindent \nset tags=tags＃sudo apt-get install exuberant-ctags\n\n\n// 例子2  注释\n// Ubuntu 中 Vim 配置文件 ~/.vimrc，位于用户目录中.\n\nsyntax enable # 语法高亮\nsyntax on\ncolorscheme darkblue  # 设定配色方案\n\nset encoding=utf-8 # 编码方式\nset fileencodings=ucs-bom,utf-8,cp936\nset fileencoding=utf-8\n# set fenc=utf-8\n# set fencs=utf-8,usc-bom,euc-jp,gbk,gb2312\n# set enc=utf-8\n\nset autoindent # 创建新行保持与上一行相同的缩进\nset smartindent # 智能缩进\n\nset tabstop=4 # 设置制表符(TAB)的宽度(以空格数量来表示)\nset shiftwidth=4 # 设置移位操作 >> 或 << 的缩进长度\nset expandtab # 使用空格代替制表符,可能会导致 Python 等依赖于制表符的编程语言出现问题.\n\nset noexpandtab # 不要用空格代替制表符\n\nset number # 显示行号\nset autowrite # 自动保存\nset ruler # 显示打开状态栏标尺\nset cursorline # 突出显示当前行\n\nset showmatch # 匹配光标所经过的括号等.\nset showcmd # 命令行显示输入的命令\nset showmode # 命令行显示vim当前模式\n\nset hlsearch # 高亮搜索内容的所有匹配位置\nset incsearch # 搜索过程中动态显示匹配内容\nset ignorecase # 搜索时忽略大小写\nset smartcase # 搜索对大小写敏感\n\nset clipboard+=unnamed # 共享剪贴板  \nset nocompatible # 不要使用vi的键盘模式，而是vim自己的\n\nset laststatus=2 # vim 窗口底部显示永久状态栏，显示文件名，行号，列号等.\nset spell spelllang=en_us # 英语拼写检查\n\nset langmenu=zh_CN.UTF-8 # 语言设置\nset helplang=cn\n\nset nobackup # 禁止创建备份\nset noswapfile # 禁止创建交换文件. 交换文件用于编辑器崩溃或冲突时，恢复文件.\nset history=1000\n\nset autochdir # 同一 vim 窗口编辑多个文件时，自动切换到正在编辑的文件.\n\nset undofile # 文件关闭后也可以维护撤销历史记录,.un~扩展名保存的隐藏文件.\nset errorbells # 错误信息响铃，只对错误信息有效.\nset visualbell # 错误视觉提示\n\nfiletype plugin indent on # 允许插件\nfiletype on\nfiletype indent on\n\n"
        },
        {
          "name": "12-1file_open_putc_close.c",
          "type": "blob",
          "size": 0.8896484375,
          "content": "#include<stdio.h>\r\n#include<stdlib.h>   // stdlib 头文件即 standard library 标准库头文件 使用 exit(0) \r\nint main()\r\n{\r\n   FILE * fp;//文件类型的指针 \r\n   char ch,filename[10];//字符 和字符数组 \r\n   printf(\"Please enter the file name:\");\r\n\r\n   scanf(\"%s\",filename);//文件名 \r\n   if((fp=fopen(filename,\"w\"))==NULL)    // 以write写入方式 打开输出文件并使 fp 指向此文件\r\n   {\r\n      printf(\"Unable to open this file\\n\");     // 如果打开出错，就输出“打不开”的信息\r\n      exit(0);     // 终止程序   #include<stdlib.h> \r\n   }\r\n   ch=getchar();     // 用来接收输入文件名时 最后输入的回车符\r\n   \r\n   printf(\"Please enter a string  in the disk（Ends with a #）：\");\r\n   ch=getchar();     // 接收从键盘输入的第一个字符\r\n   while(ch!='#')     // 当输入 # 时结束循环\r\n   {\r\n      fputc(ch,fp);//写入一个字符 \r\n      putchar(ch);\r\n      ch=getchar();\r\n   }\r\n\r\n   fclose(fp);//关闭文件 \r\n  // putchar(10);\r\n   return 0;\r\n}\r\n"
        },
        {
          "name": "12-2_file_copy.c",
          "type": "blob",
          "size": 0.392578125,
          "content": "\n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[]) \n{\n FILE *fp_src,*fp_tar;\n\n if(((fp_src=fopen(argv[1],\"rb\"))==NULL)) \n   {\n      printf(\"error\\n\");    \n      exit(0);\n   }\n//printf(\"%s\\n\",argv[1]);\n//printf(\"%s\\n\",argv[2]);\nfp_tar=fopen(argv[2],\"wb\");\nint ch;\nwhile((ch=fgetc(fp_src))!=EOF)\n    fputc(ch,fp_tar);\n\nfcloseall();\n//fclose(fp_src);\n//fclose(fp_tar);\nreturn 0;\n\n}\n"
        },
        {
          "name": "Algorithm",
          "type": "tree",
          "content": null
        },
        {
          "name": "CCF-ranking.pdf",
          "type": "blob",
          "size": 1027.3515625,
          "content": null
        },
        {
          "name": "CMake_Practice",
          "type": "tree",
          "content": null
        },
        {
          "name": "CUDA",
          "type": "tree",
          "content": null
        },
        {
          "name": "Compiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "C或C++语言中的头文件大全.md",
          "type": "blob",
          "size": 3.1240234375,
          "content": "      stdio.h就是指“standard input&output\"\n      意思就是说标准输入输出头文件！\n      所以了，用到标准输入输出函数时，就要调用这个头文件\n\n      C 头文件\n      include <assert.h>   //设定插入点\n      include <ctype.h>    //字符处理\n      include <errno.h>    //定义错误码\n      include <float.h>    //浮点数处理\n      include <fstream.h>  //文件输入／输出\n      include <iomanip.h>  //参数化输入／输出\n      include <iostream.h> //数据流输入／输出\n      include <limits.h>   //定义各种数据类型最值常量\n      include <locale.h>   //定义本地化函数\n      include <math.h>     //定义数学函数\n      include <stdio.h>    //定义输入／输出函数\n      include <stdlib.h>   //定义杂项函数及内存分配函数\n      #include <string.h>  //字符串处理\n      include <strstrea.h> //基于数组的输入／输出\n      include <time.h>     //定义关于时间的函数\n      #include <wchar.h>   //宽字符处理及输入／输出\n      include <wctype.h>   //宽字符分类//////\n\n\n      标准 C++  \n      //////////////////////////////////////////\n      include <algorithm>  //STL 通用算法\n      include <bitset>     //STL 位集容器\n      include <cctype>     //定义错误码\n      #include <cerrno>    //定义错误码\n      include <clocale>    //定义本地化函数\n      include <cmath>      //定义数学函数\n      include <complex>    //复数类\n      #include <cstdio>    /定义输入／输出函数\n      #include <cstdlib>   //定义杂项函数及内存分配函数\n      include <cstring>    //字符串处理\n      #include <ctime>     //定义关于时间的函数\n\n      include <deque>      //STL 双端队列容器\n\n      include <exception>  //异常处理类\n      include <fstream>    //文件输入／输出\n\n      include <functional> //STL 定义运算函数（代替运算符）\n\n      include <limits>     //定义各种数据类型最值常量\n\n      #include <list>      //STL 线性列表容器\n      #include <map>       //STL 映射容器\n      include <iomanip>\n      #include <ios>       //基本输入／输出支持\n      #include <iosfwd>    //输入／输出系统使用的前置声明\n      include <iostream>   \n      include <istream>    //基本输入流\n      include <ostream>    //基本输出流\n      include <queue>      //STL 队列容器\n      include <set>        //STL 集合容器\n      #include <sstream>   //基于字符串的流\n      include <stack>      //STL 堆栈容器\n      include <stdexcept>  //标准异常类\n      include <streambuf>  //底层输入／输出支持\n      include <string>     //字符串类\n      include <utility>    //STL 通用模板类\n      include <vector>     //STL 动态数组容器\n      include <cwchar>\n      include <cwctype>\n\n      using namespace std;\n      ///////////////////////C99 增加\n      include <complex.h>  //复数处理\n      include <fenv.h>     //浮点环境\n      include <inttypes.h> //整数格式转换\n      include <stdbool.h>  //布尔环境\n      include <stdint.h>   //整型环境\n      include <tgmath.h>   //通用类型数学宏\n\n"
        },
        {
          "name": "DataBase",
          "type": "tree",
          "content": null
        },
        {
          "name": "Effective_STL中文版.pdf",
          "type": "blob",
          "size": 1850.44921875,
          "content": null
        },
        {
          "name": "GO",
          "type": "tree",
          "content": null
        },
        {
          "name": "Halide",
          "type": "tree",
          "content": null
        },
        {
          "name": "MCU",
          "type": "tree",
          "content": null
        },
        {
          "name": "OS",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 58.470703125,
          "content": "# 参考资料\n[gdb 调试入门，大牛写的高质量指南](https://blog.csdn.net/wu_cai_/article/details/79669842)\n\n[Computer Architecture A Quantitative Approach pdf 翻译](https://github.com/Ewenwan/Computer-Architecture-A-Quantitative-Approach)\n\n[自动编程体系设想 ](https://blog.csdn.net/jxt1234and2010/article/details/45201421)\n\n[程序猿成长计划](https://github.com/mylxsw/growing-up)\n\n[数据结构和算法动态可视化](https://visualgo.net/zh)\n\n[基础数据结构和算法的纯C语言实现](https://github.com/Ewenwan/Data-Structures-and-Algorithms-in-C)\n\n[计算机科学 面试笔记](https://github.com/PLester/Interview-Notebook/tree/master/notes)\n\n[计算机科学 面试笔记2 ](https://github.com/CyC2018/CS-Notes/tree/master/docs/notes)\n\n[可视化代码过程](http://pythontutor.com/)\n\n[各种工程实践代码参考 ](https://github.com/Ewenwan/practice)\n\n[c++ 多线程 并发 指南 实战](https://github.com/Ewenwan/Cplusplus-Concurrency-In-Practice)\n\n[c/c++教程](https://www.cprogramming.com/)\n\n[学习C++，应该循序渐进的看哪些书？](https://www.zhihu.com/question/20410487)\n\n[数据结构与算法系列 目录](http://www.cnblogs.com/skywang12345/p/3603935.html)\n\n[刷完这65道题，面试通过率翻翻没问题 ](https://www.nowcoder.com/discuss/19305?type=0&amp;order=1&amp;pos=14&amp;page=1)\n\n[c++代码实验](https://github.com/Ewenwan/Messy_Test)\n\n[源代码查找 热度 书籍 ](https://www.ctolib.com/)\n\n[源代码查找 英文](https://searchcode.com/)\n\n[免费的编程中文书籍索引](https://github.com/Ewenwan/free-programming-books-zh_CN)\n\n[代码面试较好 强烈推荐！！！！！](https://github.com/Ewenwan/code_interview)\n\n[nowcoder刷题笔记](https://blog.csdn.net/fk1174/article/details/52825826)\n\n[LeetCode刷题笔记](https://blog.csdn.net/fk1174/article/details/52744844)\n\n[跟我一起复习C++](https://blog.csdn.net/fk1174/article/details/51841025)\n\n[Leetcode常用五大算法思想](https://blog.csdn.net/x_r_su/article/details/52461557)\n\n[数据结构 博客参考 树 图 队列](https://blog.csdn.net/neu_chenguangq/article/list/3)\n\n[GitHub Pages+Jekyll搭建个人博客](http://www.weixinyu.info/2017/08/Use_GitHubPages_and_Jekyll_build_my_blog/)\n\n[Markdown工具集](http://baixin.io/2016/11/markdownTool/)\n\n[清华操作系统 github](http://github.com/oscourse-tsinghua)\n\n[博客专栏 Linux环境编程](https://blog.csdn.net/column/details/tennysonsky-linux.html)\n\n[博客专栏 Linux网络编程](https://blog.csdn.net/tennysonsky/article/category/2835083)\n\n[博客专栏 一步步学习C++](https://blog.csdn.net/column/details/tennysonsky.html)\n\n[博客专栏 C语言](https://blog.csdn.net/column/details/15161.html)\n\n[鱼C工作室 C/C++/Python/Wed/数据结构和算法](http://fishc.com/)\n\n[图形界面编程](https://blog.csdn.net/tennysonsky/article/category/1438449)\n\n[面试算法博客笔记](https://blog.csdn.net/cheese_pop?t=1)\n\n[ 刘国平基础算法 ](https://blog.csdn.net/cyningsun/article/category/720182)\n\n[CPP11新特新 代码实战](https://github.com/Ewenwan/cpp11)\n\n[新特征 C++11/14/17  concepts and code snippets](https://github.com/Ewenwan/modern-cpp-concepts)\n\n[A Detailed Cplusplus Concurrency Tutorial 《C++ 并发编程指南》](https://github.com/Ewenwan/Cplusplus-Concurrency-In-Practice)\n\n[基于C++11新标准的并发和多线程编程深度指南 C++ Concurrency In Action](https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action)\n\n[《C++17 STL cookbook》英文版的中文翻译 ](https://github.com/Ewenwan/CPP-17-STL-cookbook)\n\n[哈希学习](https://blog.csdn.net/LeeWei4939/article/details/78806230)\n\n[甲骨文公司编辑器Oracle Solaris Studio 12.4 Information Library (简体中文) c/cpp用户指南 数值计算指南 代码分析器 性能分析器 线程分析器](https://docs.oracle.com/cd/E57201_01/)\n\n[哈工大 编译原理 ](http://www.icourse163.org/course/HIT-1002123007)\n\n[编译原理——词法分析器实现](https://www.cnblogs.com/zyrblog/p/6885922.html)\n\n[编译技术 西电](http://www.xuetangx.com/courses/course-v1:XIYOU+20180208+sp/about)\n\n[在线书籍编写模板 gitbook](https://github.com/Ewenwan/gitbook)\n\n[循序渐进学习书目](https://github.com/codefollower/My-Blog/blob/master/md-files/issues-001.md)\n\n[svn新建trunk 和 分支](https://blog.csdn.net/chaozi2008/article/details/45073949)\n\n# 感谢支持\n\n![](https://github.com/Ewenwan/EwenWan/blob/master/zf.jpg)\n\n# Git\n\ngit clone --recurse-submodules https://github.com/xxxxx.git\n\n注意 clone 的时候一定要带 --recurse-submodules 这个参数，否则会下载不完整。\n\n# 包含内容：\n\t\t1. c\n\n\t\t2. c++\n\n\t\t3. python\n\n\t\t4. 汇编语言\n\n\t\t5. 数据机构和算法 面试\n\n\t\t6. 操作系统os\n\n\t\t7. 单片机stm32 arduino Ti-msp430 树莓派 px4 arm\n\n\t\t8. 数据挖掘\n\n\t\t9. 人机工程学\n\n\t\t10. 计算机科学\n\n# 学习C++，应该循序渐进的看哪些书？\n\n## 阶段  1\n\t《Essential  C++》\n\t这是一本内容不多但很实用的C++入门书籍，强调快速上手与理解C++编程。\n\t本书主要围绕一系列逐渐复杂的程序问题，以及用以解决这些问题的语言特性展开讲解。\n\t你不只学到C++的函数和结构，也会学习到它们的设计目的和基本原理。\n\t\n\t《C++ Primer》\n\t本书对C++基本概念、技术、以及现代C++编程风格进行了全面而且权威的阐述，是C++初学者的最佳指南；\n\t本书可以帮助你编写实用的程序，而无需首先精通每个语言细节。\n\t对于中高级程序员，本书也是不可或缺的参考书。\n\n## 阶段  2\n\t《Effective C++》和《More effective C++》作者是Scott  Meyers。\n\t你应该熟读它们，并清楚地理解每个项目。\n\t该书围绕55条准则，每一条都介绍了一个可让你写出更好的C++程序代码的方法，并以特别设计过的例子详加讨论。\n\t\n\t《Exceptional  C++（C++编程剖析）》和《More exceptional  C++》\n\t这两本书中都包含了40个C++编程问题，这些问题会让你磨练自己的技能，最终成为优秀的C++程序员。\n\t这些问题是Herb  Sutter精心挑选，与ISO/ANSI C++官方标准相一致，\n\t帮助程序员在设计、架构和编码过程中保持良好的风格，从而使编写的C++软件更健壮、更高效。\n\n## 阶段  3\n\t《Inside  the C++ object model（深度探索C++对象模型）》\n\t本书专注于C++面向对象程序设计的底层机制，\n\t包括结构式语意、临时性对象的生成、封装、继承，以及虚拟——虚拟函数和虚拟继承，\n\t帮助你理解程序的底层实现，以便写出更高效的代码。\n\t\n\t《The  design and evolution of C++（C++语言的设计与演化）》\n\t本书作者也是C++语言的设计者Bjarne  Stroustrup，作者在书中综合性地介绍了C++的发展历史，\n\tC++中各种重要机制的本质意义和设计背景，这些机制的基本用途和使用方法，\n\t讨论了C++所适合的应用领域及其未来的发展前景，既没有忽略关键性的详情，又没有过多地陷入技术细节。\n\n## 阶段  4\n\t《The  C++ standard library（C++标准程序库）》\n\t这是标准模板库字典，你可以在本书中找到STL相关的一切知识。\n\t本书焦点放在标准模板库、检查容器、迭代器、函数对象和STL算法上。\n\t每一个元素都有深刻的呈现，包括其介绍、设计、运用实例、\n\t细节解说、陷阱、意想不到的危险，以及相关类别和函数等。\n\t\n\t《Effective  STL》\n\t这是Scott  Meyers的第三本C++专著，也是学习STL最权威的书籍。\n\t作者对书中的50个指导方针都作了详尽的分析，并配以示例。\n\t通过这些规则，C++开发者可以最大限度地使用STL。\n\t\n\t《Generic  programming and the STL（泛型编程与STL）》\n\t本书阐述了泛型程序设计的核心理念：concepts（概念）、modeling（模型）和refinement（改善），\n\t并为你展示这些观念如何导出STL的基础概念：iterators（迭代器）、\n\tcontainers（容器）和function  objects（函数对象）。\n\t按照本书所述，你可以把STL想象成一个由concepts组成的library，你将学习到STL正式结构并理解其强大的优势。\n\n## 阶段  5\n\t《Exceptional C++ style》\n\t作者为Herb  Sutter。本书同样提出了40个C++风格相关的问题\n\t，对一些至关重要的C++细节和相互关系提出了新的见解，\n\t为当今的关键C++编程技术（如泛型编程、STL、异常安全等）提供了新的策略，\n\t帮助开发者在开销与功能之间、优雅与可维护性之间、灵活性与过分灵活之间寻找完美的平衡点。\n\t\n\t《C++  template》\n\t这是一本关于C++模板的完整的参考手册和教程，它强调模板的使用实践，包含了现实世界中的例子。\n\t每个C++程序员都应该好好读一读这本书。\n\t\n\t《Modern  C++ design（现代C++设计）》\n\t作者Andrei  Alexandrescu为C++程序员打开了一个新的局面。\n\t本书提供了一些针对软件设计的前沿方法，如联合设计模式、泛型编程，\n\t使程序员可以编写有表现力的、灵活的、高度可重用的代码。\n\t\n\t《Thinking  in C++（C++编程思想）》\n\tC++  领域权威著作，介绍了C++实用的编程技术和最佳的实践方法。\n\n\n# 值得学习的开源代码\n## 1.Webbench\n\tWebbench是一个在Linux下使用的非常简单的网站压测工具。\n\t它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，\n\t最多可以模拟3万个并发连接去测试网站的负载能力。\n\tWebbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。\n项目主页: http://home.tiscali.cz/~cz210552/webbench.html\n\n## 2. Tinyhttpd\n\ttinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，\n\t附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。\n项目主页: http://sourceforge.net/projects/tinyhttpd/\n\n\n## 3. cJSON\n\tcJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。\n\tcJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。\n\t其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。\n\n项目主页: http://sourceforge.net/projects/cjson/\n\n## 4. CMockery\n\n\tcmockery是google发布的用于C单元测试的一个轻量级的框架。\n\t它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。\n\tcmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。\n\n\t主要特点：\n\t    免费且开源，google提供技术支持；\n\t    轻量级的框架，使测试更加快速简单；\n\t    避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;\n\t    并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用\n\n项目主页: http://code.google.com/p/cmockery/downloads/list\n\n## 5. Libev\n\tlibev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。\n\t其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。\n\t基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。\n\n项目主页: http://software.schmorp.de/pkg/libev.html\n\n## 6. Memcached\n\tMemcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。\n\t它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。\n\tMemcached 基于一个存储键/值对的 hashmap。\n\tMemcached-1.4.7的代码量还是可以接受的，只有10K行左右。\n\n项目主页: http://memcached.org/\n\n\n## 7.  Lua\n\n\tLua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。\n\t让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。\n\t在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。\n\tLua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。\n\n项目主页: http://www.lua.org/\n\n## 8. SQLite\n\tSQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 \n\t其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。\n\n项目主页: http://www.sqlite.org/ 。\n\n## 9. UNIX v6\n\tUNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。\n\t有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。\n\t看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？\n\t\n\t另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。\n\t就算不是初学者，想完全理解全部代码基本上也是不可能的。\n\n项目主页: http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6\n\n## 10. NETBSD\n\tNetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，\n\t是现行可移植平台最多的操作系统，可以在许多平台上执行，\n\t从 64bit alpha 服务器到手持设备和嵌入式设备。\n\tNetBSD计划的口号是：”Of course it runs NetBSD”。\n\t它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。\n\t由于简洁的设计和先进的特征，使得它在生产和研究方面，\n\t都有卓越的表现，而且它也有受使用者支持的完整的源代码。\n\t许多程序都可以很容易地通过NetBSD Packages Collection获得。\n\n项目主页: http://www.netbsd.org/\n\n\n\t\t\n# 0 个类型结构大小 sizeof\n## 3. 语法：\n\tsizeof有三种语法形式，如下：\n\t1) sizeof( object );    // sizeof( 对象 );\n\t2) sizeof( type_name ); // sizeof( 类型 );\n\t3) sizeof object;       // sizeof 对象; \n## 2. 指针变量的sizeof   4/8\n\t 与计算机类型有关，32为计算机，地址长度为4字节\n\t 64位的计算机，地长度为 8字节\n\t 这里的指针包括所有类型的指针:\n\t    字符指针、整形指针、字符串指针、指针的指针、函数指针、数组指针等。\n## 3.数组的sizeof\n\t数组的sizeof值等于数组所占用的内存字节数，如：\n\tchar a1[] = \"abc\";\n\tint a2[3];\n\tsizeof( a1 ); // 结果为4，字符串末尾还存在一个NULL终止符\n\tsizeof( a2 ); // 结果为3*4=12（依赖于int,这里int为4字节） \n\t// 这里注意 &a2和a2的值是相等的,都是a2[0]的地址\n\t// 但是 &a2 的类型为 int *[10]\n\t// 而a2的类型为 int* p\n\t\n\t//数组元素数量求取\n\tint c1 = sizeof( a1 ) / sizeof( char ); // 总长度/单个元素的长度(知道元素类型)\n\tint c2 = sizeof( a1 ) / sizeof( a1[0] ); // 总长度/第一个元素的长度(不知道元素类型)\n## 4. sizeof进行结构体大小的判断\n        需要看编译器是几个字节对齐 的，一般为4字节对齐\n\ttypedef struct\n\t{\n\t    int a;  // 占据第一个4字节\n\t    char b; // 占据第二个4字节\n\t}A_t;\n\ttypedef struct\n\t{\n\t    int a; // 占据第一个4字节\n\t    char b;// 占据第二个4字节中的第一个字节\n\t    char c;// 占据第二个4字节中的第二个字节\n\t}B_t;\n\ttypedef struct\n\t{\n\t    char a;// 占据第一个4字节的第一个字节\n\t    int b; // 占据第二个4字节\n\t    char c;// 占据第三个4字节的第一个字节\n\t}C_t;\n\n\n# 1. 编程技巧 来自  effective stl \n[effective stl 博客参考](https://blog.csdn.net/u014110320/article/category/6411316)\n## a)浮点数判等\n\t判断两个浮点数a和b是否相等时，不要使用 a==b ,\n\t应该判断两者的绝对值之差fabs(a-b)是否小于一个阈值 ，如1e-9\n\tif(fabs(a-b) < 1e-9)\n## b) char类型用作数组下标需要注意的问题\n\t应该先将char 强制转换为 unsigned char后在用作下标。\n\tchar index_;\n\tunsigned char index = (unsigned char)index_;\n## c) 向量vector 和 字符串string 优先于 动态分配的数组new[] delete[]\n\tvector 和 string 定义的对象 会自动 构造和析构，不用担心内存泄漏的问题\n\t使用new[]分配的动态数组，需要配合 delete[]类释放会造成内存，否者会造成内存泄漏的问题\n\n\t例如 定义一个二维数组，指针的指针\n\t自己用new实现：\n```c\n\tint** arr_pp new int* [row_num];// 定义一个存储指针的数组的指针 行数\n\tfor(i = 0; i < row_num; ++i)\n\t    arr_pp[i] = new int[col_num];// 一个一个new 指针每一行是一个行向量的指针\n```\n\t用 vector实现，一行代码搞定，还不到担心内存泄漏的问题\n```c\n\tvector<vector<int>> v_i2(row_num,vector<int>(col_num,0));//初始化为一个0矩阵\n\tvector<int> m;  \n        m.reserve(1000);//提前保留1000的内存\n\t//使用 reserve 避免不必要的重新分配 \n```\n\n# C++ primer5 语言学习记录\n\n# 复合类型\n## 引用 &   左值引用lvalue reference  别名; int val; &refval = val; 右值引用 rvalue reference \n```c\nint val = 1024;//整形变量\nint &refVal = val;// 整形引用 refVal 指向 val ，是val的另一个名字，\n                 // 引用必须被初始化，引用不是对象，只是为所存在的对象起的一个别名。\nrefVal = 2;       // 把2 赋值给refVal 也就是 赋值给了 val\nint i = refVal;   // 相当于 i = val; \nint &refVal2 = 10;// 错误，非常量引用只能绑定(bind)在对象向,\n                  // 不能与字面值或某个表达式的计算结果绑定在一起, 且引用的类型 必须和 对象的类型一致\nconst int &rci = 10;// 常量引用可以绑定到 字面值 非常量 一般表达式\ndouble dval = 3.14;// 浮点数\nint &refVal3 = dval; // 错误，引用的类型 和 对象 必须一致\n```\n## 指针 pointer * 指向 point to 另外一个对象（其存储地址）\n```c\nint ival = 42;  // 整数\nint *p = &ival; // 指针定义 p存放 ival对象存放的地址，也即是 p 指向 变量 ival的指针   &ival 为取的 ival变量的 存储地址\ndouble dval = 3.14; // 浮点数\ndouble *pd = &dval; // double 类型 指针\ndouble *pd2 = pd;   // pd存放 的是 dval存放的地址\n\nint *pi = pd;     // 错误， 指针pi 的类型 和 右边指针对象 类型 不匹配\npi = &dval;   // 错误， 视图把 double 类型对象的地址 给 int类型的指针 错误  左右两边类型 必须匹配\n```\n> 利用指针访问对象 取地址内存储的值 解引用符 来访问向\n```c\nint ival = 42; //整形 变量\nint *p = &ival;//指针变量定义初始化， p 存放着 变量ival 在内存中的地址\nstd::cout << *p;// 表达式里 *p 为 解引用 取的p存放的地址 指向的值\nint &ref_i = ival; // 引用声明定义， ref_i 是一个引用\nint *p; //指针声明定义，p是一个指针\np = &ival;// 表达式 p为指针（地址），&val 为取的 val 地址\n*p = ival;   //表达式  *p 相当于 ival *是一个解引用\nint &ref_i2 = *p;// &ref_i2 为引用定义 *p 相当于 ival， *是一个解引用\n ```   \n    \n> 空指针\n```c\nint *p1 = nullptr;// 等价于 int *p1 = 0; 空指针  p1 不指向 任何 对象\nint *p2 = 0; // 空指针     等价于 int *p1 = 0;\nint *p3 = NULL;// 空指针   等价于 int *p1 = 0;\nint zero = 0;\nint *p4 = zero;// 错误，不能把 int 变量直接赋值 给指针\n\nint i = 42;\nint *pi1 = 0; // pi1 被初始化为空指针，但没有指向 任何对象\nint *pi2 = &i;// pi2 被初始化，存有 i 的地址\nint *pi3;// 定义 未初始化\npi3 = pi2;// pi3 和 pi2指向同一个 对象 i\npi2 = 0; // 现在 pi2 被赋值为 空指针 不指向任何对象  指针被改变， 指向的对象不变\npi2 = &i;// 现在 pi2 又指向 i\n*pi2 = 0;// 指针pi2 没变 , *pi2 被改变 即pi2指向的对象 i 发生了变化\n ```   \n\n> 使用指针作为条件 为空指针时，逻辑值为 False，其他指向一个对象的指针(非0指针) 逻辑值 均为 true\n\n> 相等 == 操作符  不等 != 操作符 \n\n> void* 类型的指针  可一指向 任意类型 的 地址 ， 可一存放任意类型的 地址，\n\n> 用作函数参数，函数体内使用时需要，转化成实际传入类型的指针\n```c\ndouble obj = 3.14, *pd = &obj; // double 类型 的变量 double类型的指针\nvoid *pv = &obj; // obj 可以是任意类型的对象\npv = pd; // pv 可一存放任意类型的指针（地址）\ndouble *pd = (double*)(pv);// void* 类型的指针 强制转化成  double* 类型的指针\n```    \n\n> 定义多个变量\n```c\nint i = 1024， *p = &i, &r = i;//i是整形变量 p是一个整形指针 r是一个整形引用\nint* p1, p2;// * 仅仅修饰 p1 ，即p1是 指向整形的指针 p2是整形变量\nint *p1, *p2;// p1 和 p2 都是指向 整形的指针\n```    \n\n> 指向指针的指针\n```c\nint ival = 1024;\nint *pi = &ival; //指向整形变量的指针\nint **ppi = &pi; //指向整形指针的指针  ppi ---> pi ------> ival\nstd::cout << ival << \"\\n\"// 直接输出 变量值\n      << *pi  << \"\\n\"// 1次解引用 得到变量值\n      << **ppi<< \"\\n\";//2次解引用 的到变量值\n```\n\n> 指向指针的 引用 指针对象的别名  引用不是对象 不存在 指向引用的指针\n```c\nint i = 42;//整形对象\nint *p;//指向整形类型的指针\nint *&r_p = p;//引用r_p的类型为 整形的指针引用int*&，r_p 是指针p的一个别名 \n           //从右向左 离变量最近的符号为 & 即为 引用，* 引用的为 指针类型\nr_p = &i;// 相当于 p = &i p 指向 i\n*r_p = 0;// 相当于 *p = 0 即 i =0 改变了指针指向对象的值  \n         // 这里 *p *解引用指针的类型其实相当于 原变量的别名 引用\n```\n\n## const 限定符\n> 修饰变量后，可以防止变量被修改\n```c\nconst int bufSize = 512;//初始化常量 一旦创建后就不能被修改\nbufSize = 1024;// 错误，常量不能被赋值\nconst int i = get_size();// 一个函数赋值 运行时初始化\nconst int j = 42;//编译时初始化\nconst int k;//错误，常量定义式必须初始化\ndouble dvel = 3.14;//  也可以由其他类型变量 强制转换成 常量\nconst int ci = dvel;// 由double类型变量 强制转换成 整形常量 3\nextern const int bufSize = 1024;//定义了一个变量，想在其他文件也使用 bufSize 必须在定义之前 加extern\nextern const int bufSize;// 另一个文件中 声明 bufSize 后 就可以使用了\n```        \n> 绑定到常量的引用 const 的引用 即对常量的引用 reference to const 常量 的 别名 不能修改 不存在常量引用 &const 引用不是对象\n```c\n        const int c_i = 1024;   // 常整数\n        const int &r_c_i = c_i; // 常整数 c_i 的 引用（别名）\n        r_c_i = 42;// 错误r_c_i 是常量引用 不能被修改\n        int &r_c_i2 = c_i;//错误 常整数 不能赋值给 int变量 左右两边类型必须一样\n```\n> 允许将一个常量引用绑定到 非常量对象、字面值，甚至是个 一般表达式\n```\n        int i = 52;\n        const int &r1 = i; // 允许将 常量引用 const int & 绑定到 int变量上\n        const int &r2 = 42;// 绑定到 字面值上\n        const int &r3 = r1 * 2;// 绑定到一个 表达式上\n        int &r4 = r1 * 2;// 错误，r4是非常量 引用，只能绑定到 其对应类型的对象上\n\n        double dval = 3.14;//浮点数\n        const int &ri = dval;//常量引用 绑定到 非常量上 \n        //相当于 先把 非常量转化成常量 强制类型转换 常量引用实际上绑定了一个临时变量\n        const int temp = dval;//\n\n        int i = 42;// int 变量\n        int &r1 = i;// 整数变量引用 r1为 i 的别名\n        const int &r2 = i;//常量 引用 r2 绑定到 变量 i上\n        r1 = 0;// 相当于 i =0\n        r2 = 0;// 错误 r2 时常量引用 不允许改变\n```\n> 指向常量的指针  const int *   指针指向的值不能变  也就是 *p 不能被赋值 不能改变\n```c\nconst double pi = 3.14;//双精度 浮点型 常量\ndouble *ptr_d = &pi;// 错误，浮点型变量指针 不能绑定一个 常量的存储地址\nconst double *ptr_d_c = &pi;// 双精度常量 针 ptr_d_c  指向一个 双精度常量\n*ptr_d_c = 42;// 不能给 pi 赋值 指向常量的指针的解引用相当于 绑定的常量 ，因此不能赋值\ndoubel dvel = 3.14;//双精度变量\nptr_d_c = &dvel;//允许 常量指针ptr_d_c 指向一个变量dvel 但是不能通过 常量指针ptr_d_c 修改变量dvel\n```\n\n> 常量指针 *const 指针本身不能改变 也就是指向不能改变  p不能改变 但是其指向的对象 无影响\n```c\nint errNumber = 0;//\nint *const conpErr = &errNumber;// * 可变指针  *const 常量指针不可变 \n                               // 指向整形的 常量指针，conpErr 一直指向 errNumber\n*conpErr = 3;//相当于 errNumber = 3\nconst double pi = 3.14;//\nconst double *const cd_cp = &pi;//指向 常量的常量指针，\n                               // 即 指针本身cd_cp不能变， 其指向的值 *cd_cp也不能变\n```\n> 常量表达式 编译时就能确定的量/式子 constexpr int ce = 20;\n```c\nconst int *p = nullptr;// 指向整形常量 的指针\nconstexpr int *p = nullptr;// 指向整形变量的 常量指针 \n                           // constexpr 声明中出现 指针 仅仅说明 指针为常量指针\nint *const p =nullptr;//指向 整形变量的 常量指针\nconst int *const p = nullptr;// 指向 整形常量 的常量指针\nconstexpr const int *p = nullptr;// 指向 整形常量 的常量指针\n\nconstexpr int ci = 42; // ci 是整形常量\nint j = 0;\nconstexpr int *pci = &j; // 指向整形的 常量指针\n```\n## 处理类型\n\n### 类型别名  type alias\n```c\ntypedef double wages;   // wages 是double类型的 同义词\ntypedef wages base, *p; // base 也是double类型的 同义词。 p是double * 的同义词\nwages d_money = 1.00;//等有价于 double d_money = 1.00\np p_dmoney =   &d_money;//等价于 double *p_dmoney =   &d_money;\ncout << p_dmoney << endl; \n // 别名声明 alias declaration\nusing SI = Sales_Item; // SI 是 Sales_Item 的 同义词\nSI item;//等价于 Sales_Item item;\n // 指针、常量const 类别别名\ntypedef char *pstring;// pstring等价于 char *  指向char 的指针（是指针）\nconst pstring cstr = 0;// cstr是指向 char 的 常量指针 \n                       // ！！！！不是指向常量字符的 指针 不能直接替换 const修饰的主语是指针\nconst pstring *ps;     // ps是一个指针 它指向的对象 是 指向char的常量指针\n```\n### auto 类型说明符  让 编译器根据右式 类型 自动推算左式的类型  且用表达式的值 初始化变量\n```c\nauto item = val1 +val2;//item 初始化为 val1 和 val2相加的结果 类型 相同\n// 一条语句定义多个变量时，各变量类型必须一致\nauto i=0, *p = &i;//正确 i是整数， p是指向整形的指针\nauto sz = 0, pi = 3.4;// 错误 sz 和 pi 类型不一致\n\n// 引用 指针 常量 与 auto\nint i = 0, &r = i;//r是i的别名 int类型\nauto a = r;// a 是一个整形数\n\n// auto 会忽略掉 顶层const\nconst int ci = i, &cir = ci;// 常整数\nauto b = ci;  // b是一个整数，ci的顶层 const(最外层修饰 为顶层)特性被忽略\nauto c = cir; // c是一个整数，ci的顶层 const特性被忽略\nauto d = &i;  // d是一个指向整形的指针\nauto e = &ci; // e是一个指向整形常量的指针 const \n              // 外又被 取地址符号修饰，所以这里的 const是 底层const 不被忽略\n\n// 如果希望 auto 推断出的类型是 一个顶层 const，需要在其前面 明确指出\nconst auto f = ci; // ci的推演类型是 int ，f是 const int\n\n// 将引用设置为 auto 还按之前的初始化规则  保留 顶层 const\nauto &g = ci; // g 是一个 整形常量的 引用 （别名）\nauto &h = 42; // 错误，非常量 引用 不能绑定 到 字面值\nconst auto &j = 42; // 正确， 常量引用可以绑定到 字面值\n\n// 将 指针设置为 auto， 也按之前的初始化规则 保留顶层 const\nauto *k = &ci; // k为指向 整形常量的 指针\nauto *l = 0;   // l为空指针\nconst auto *m = &ci; // m 为 指向整形常量的 常量指针\n\nint i = 1024;\nconst int c_i = i;\nauto b = c_i; // b是一个 整数 ,c_i的 顶层 const被忽略\nauto e = &c_i;// e 是一个 指向 整形常量的引用  这里的const是底层const 不被忽略\nauto k = c_i, &ll = i;// k 是整数， ll 是一个整数引用\nauto k = c_i, &o = c_i;// 错误，k 是整数变量 o是一个整数常量引用 类型不一致\nauto &m =c_i, *p = &c_i;//正确 m是整数常量引用，p是指向整数常量的指针\nauto n = &c_i, *p = &c_i;// 正确 n是整数常量 引用(底层const，不被忽略) p是指向整数常量的指针\n ```       \n  \n  ### decltype 类型指示符  用表达式推断类型 但是不用表达式的值初始化变量   \n  ```c\ndecltype(f()) sum = x; // sum 的类型为 函数 f() 的返回值类型 初始化为 x 就像 int sum = x; 一样\nconst int ci = 0, &cj = ci;// ci 整形常量  cj 整形常量的引用\ndecltype(ci) x = 0; // x的类型 同ci 是 整形常量 const int 不忽略 顶层 const\ndecltype(cj) y = x; // y的类型 同cj 是 整形常量的引用 const int &  y绑定到x上\ndecltype(cj) z;     // 错误 z是一个 引用 ，必须初始化\n\n// decltype和引用 指针\nint i =42, j=12, *p = &i, &r = i;\ndecltype(r) a = j;// a的类型和r的类型一致，为整数的引用 int& a绑定到j上\ndecltype(r + 0) b;//正确 加法的结果为 整形 int 因此 b为整形， 这里只定义 没有初始化\ndecltype(*p) c; // 错误 其实*p 解引用指针 相当于i的别名 也就是引用 \n                //  所有这里 c的类型为 整数引用 int &，是个引用，必须初始化\n\n// decltype 的表达式如果 加上括号，得到的结果将是引用\ndecltype(i) e; // e 是一个未初始化的 整形变量\ndecltype((i)) d = e; // d是一个 整数的引用 绑定到 整形变量 e上  双层引用括号 的结果 永远都是 \n\n// 赋值表达式 也会产生 引用 引用的类型就是 等式左边变量的类型 如果 i是int i = x的类型是 int&\n``` \n # 标准库 std\n ## 字符串类 string 类  #include <string> 存储一个可变长度的 字符串          使用内置数组类型实现\n \n ### 范围for  访问所有元素\n```c \nstring str(\"some string\");\nfor (auto c : str)// auto自动推断类型\ncout << c << endl; \n// 范围for 引用 改变 内容\nstring s(\"Hello World!!!\");\nfor (auto &c : s)// c是 字符串中每个元素的一个别名\nc = toupper(c);//变成大写\ncout << s << endl;\n ```    \n ### 下标运算符(索引)[] 和 迭代器 访问单个元素\n > string的下标 类型为 string::size_type 无符号数 可用 decltype(s.size())获取 s[0] 是第一个字符 s[s.size()-1]是最后一个字符\n```c \n// 第一个字符改为大写\nstring s(\"some string\");\nif(!s.empty())\n\ts[0] = toupper(s[0]);//第一个字符改为大写  在 cctype头文件中\n// 第一个单词改为大写\nfor(decltype(s.size()) index = 0;\n    index != s.size() && !isspace(s[index]; ++index))\n\ts[index] = toupper(s[index]);\n```\t \n## 向量 模板  容器container  vector 模板  #include <vector> 存储一个可变长度的 对象 集合 使用内置数组类型实现\n> 因为 vector 可以存放任意类型 所以事先需要知道 存放的对象是什么类型  vector<int> ivec; vector<string>; vector<vector<string> >;\n```c    \n// 初始化方式\nvector<int> ivec(10,-1);// 直接初始化 10个元素 全为 -1\nvector<int> ivec2 = ivec;//拷贝初始化\nvector<int> ivec3{10};//一个元素 10 \nvector<int> ivec3{10，1};//两个元素 10  和 1\nvector<string> svec{\"a\",\"an\",\"the\"};//列表初始化 直接方式\nvector<string> svec2 = {\"a\",\"an\",\"the\"};//列表初始化 拷贝方式\n\n// 默认初始化 \nvector<int> ivec(10);    // 10个元素，每个值都是0 \nvector<string> svec(10); // 10个元素，每个值都是空 string 对象\nvector<string> svec2{10};// 10个元素，每个值都是空 string 对象\nvector<string> svec3{10, \"hi\"};// 10个 \"hi\"元素\nvector<string> svec3(10, \"hi\");// 10个 \"hi\"元素\n\n// 使用 .push_back() 添加元素\nvector<int> ivec2; //空vec对象\nfor(int i = 0; i != 100; ++i)\nivec2.push_back(i);// 一次把整数值 放到 ivec2尾部 结束后 ivec2有100个元素 0~99\n\n// 实时添加 string 元素\nstring word;\nvector<string> text;//空对象\nwhile (cin >> word) \ntext.push_back(word);// 把word添加到 text 后面\n\n//使用范围for  + 引用 访问 并改变vector元素\nvector<int> iv{1,2,3,4,5,6,7,8,9};// 列表直接初始化\nfor (auto &i : v)// 对于v中每个 元素的 引用 需要改变其值\ni *= i;      // 变成原来值 的 平方\nfor (auto i : v) // 仅读取其中的变量\ncout << i << \" \";\ncout << endl;\n\n// vector 对象大小 类型为size_type\nvector<int>::size_type se = iv.size();\n\n// 使用索引[] 访问 计算vector对象元素索引   统计各个分数段上 出现的 成绩个数\n// 索引不能添加元素\nvector<unsigned> scores(11,0);//11个分数段， 0~9，10~19，...,90~99，100 计数值全部初始化为0\nunsigned grade;\nwhile (cin >> grade){\nif(grade <= 100) ++scores[grade/10];\n}    \n\n// cin 读入一组词 改成大写 存入 vector中  #include <cctype> 使用toupper()\nvector<string> sv;\nstring word1 = \"qwe\";\ncout << word1 << endl; \nwhile(cin >> word1){\n\tfor (auto &c : word1) c = toupper(c);\n\tsv.push_back(word1); \t\n\tcout << word1 << endl; vector  \n}\n```\n## 迭代器 访问容器中的 元素 auto b = v.begin(), e = v.end(); b表示v的第一个元素 e表示v尾元素 的下一个位置  类似 指针\n```c\n// 修改 字符串 第一个元素为大小字符\nstring s(\"some string\");\nif (s.begin() != s.end()){//确保 s非空\n  auto it = s.begin();// it 指向 s的第一个字符 类似指针 的作用\n  *it = toupper(*it);// 将当前字符改写成大写形式  *it 解引用迭代器 得到其所指向的 对象  是其指向对象的别名 引用\n}\n\n// 字符串的第一个单词 改写成大写\nfor (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)\n\t*it = toupper(*it);\n\n// 迭代器类型  iterator (具有读写功能)  const_iterator 具有 读功能  不具有写功能\n// 对象为常量 只具有常量类型的迭代器 const_iterator  对象为变量具有 iterator 和 const_iterator\nvector<int>::iterator it;// 迭代器 it 可以读写 vector<int> 类型容器 的元素\n string::iterator it2;   // it2 可以读写  string对象 中的字符\n vector<int>::const_iterator it3;//it3只能读元素，不能写元素\n string::const_iterator it4;     //it4只能读字符，不能写字符\n\n // cbegin()   cend() 返回 常量 迭代器 仅能读取 容器元素 不能修改\n vector<int> iv;        // 变量\n const vector<int> civ; // 常量\n auto it1 = iv.begin(); //  it1的类型为 vector<int>::iterator  能读写iv的元素\n auto it2 = iv.cbegin(); // it2的类型为 vector<int>::const_iterator  能读iv的元素 不能修改 iv的元素\n auto it3 = civ.begin(); // it3的类型为 vector<int>::const_iterator  能读civ的元素 不能修改 civ的元素\n\n  // 访问 容器元素对象的 成员函数   (*it).empty  等同于 it->empty()  解引用 和成员访问\n  vector<string> text;\n  for (auto it = text.cbegin(); it !=text.cend() && !it->empty(); ++it)\n\tcout << *it << endl;\n\n  // 迭代器 运算\n  auto mid = iv.begin() + iv.size()/2; //指向容器的中间位置\n  if (it < mid) // 处理前半部分元素\n\n// 两个迭代器相减 得到的类型为 带符号整数  difference_type\n\n// 常规二分查找算法\n// 升序数组 查找的元素  范围开始  结束 \nint BinarySearch(int *array, int key, int low, int high)\n{\n    int mid;\n    while (low <= high)//  缩小范围 \n    {\n\tmid = (low + high) / 2;//更新中间元素的 下标 \n\tif (key == array[mid])//中间元素是否 等于所查找的元素 \n\t    return mid+1;//相等 返回元素下标  \n\telse if (key < array[mid])//所查元素 比 中间元素小  则在 前区间查找 \n\t    high = mid - 1;//将区间 右侧 退后 到 中间元素下标前一个元素  搜索 范围为  low，mid-1\n\telse//所查元素 比 中间元素大 则 在后区间查找 \n\t    low = mid + 1;//将区间  左测 提至  中间元素下标后一个元素    搜索 范围 mid+1，high\n    }\n    return 0;\n}\n\n// 使用迭代器完成二分查找\n vector<int> text// 升序容器\n auto b = text.begin(), e = text.end();//起始 结束位置\n auto mid = b + (e - b)/2;//中间位置\n while(low <= end && *mid != key){\n\tif(key < *mid) e = mid - 1;//所查元素 比 中间元素小  则在 前区间查找\n\telse b = mid + 1;// 所查元素 比 中间元素大 则 在后区间查找\n\tmid =  b + (e - b)/2;//更新 中间位置\n }\n\n// 使用索引[] 访问 计算vector对象元素索引   统计各个分数段上 出现的 成绩个数\n// 索引不能添加元素\nvector<unsigned> scores(11,0);//11个分数段， 0~9，10~19，...,90~99，100 计数值全部初始化为0\nunsigned grade;\nwhile (cin >> grade){\nif(grade <= 100) ++scores[grade/10];\n} \n// 使用迭代器 访问 计算vector对象元素索引   统计各个分数段上 出现的 成绩个数\nvector<unsigned> scores(11,0);//11个分数段， 0~9，10~19，...,90~99，100 计数值全部初始化为0\nunsigned grade;\nauto it0 = scores.begin();\nwhile (cin >> grade){\n\tauto it = it0 +  grade/10;\n\tif(grade <= 100) ++*it;\n} \n```\t\n\t\t\n# 数组 \n>  数组与标准库 类型 vector 类似，都存放类型相同对象的容器。\n>  需要通过其所在的位置访问对象。\n>  与vector不同的是，数组大小确定不变，不能随意向数组中增加元素, 数组不允许拷贝，vector允许拷贝。\n>  注意数组名 相当于数组首元素的地址   ia[10]  ia === &ia[0]\n\n## 【1】定义\n```c\nconstexpr unsigned sz = 42;//constexpr修饰，常量表达式\nint arr[10];  //字面值常量初始化  含有10个整数的数组\nint arr2[sz]; //常量表达式初始化 含有42个个整数的数组\nint *parr[sz];//常量表达式初始化 含有42个指向整数的指针的数组\n\n定义时必须指定数组类型，不能由auto来推断\n不存在引用的数组，引用不是对象！！！\nstring nums[] = {\"one\", \"two\", \"three\"};// 数组元素是string对象\nstring *sp = &nums[0];// p指向nums的第一个元素\nstring *sp2 = nums;   // 等价于 string *sp2 = &nums[0]\n\nauto sp3(nums); //sp3 是一个string指针，指向nums的第一个元素\n// 而decltype关键字 声明的 不发生上述转换\n decltype(nums) sa = {\"two\", \"three\", \"four\"};//sa 是一个 含有3个string对象的 数组\n```\n\n##【2】显式初始化数组元素\n```c\nconst unsigned sz = 3;//\nint ia1[sz] = {0, 1, 2};//列表初始化 含有3个元素\nint ia2[] = {0, 1, 2};//维度为3\nint ia3[5] = {0, 1, 2};//等价于 {0, 1, 2, 0, 0}\n\n// 字符数组\nchar ca1[] = {'C', 'P', 'P'};//列表初始化\nchar ca2[] = {'C', 'P', 'P', '\\0'};//含有显式的 空字符\nchar ca3[] = \"CPP\";//字符串字面值初始化 自动添加表示字符串结束的空字符\n\n// string 对象初始化 字符数组\nstring s(\"Hello World\");\nconst char *str = s.c_str();// 用string对象初始化 字符数组 需要使用 c_str() 方法 最好再重新拷贝一份\n\n// 数组  初始化 vector 对象\nint i_arr[] = {1, 2, 3, 4, 5, 6};\nvector<int> ivec(begin(i_arr), end(i_arr));//全部副本\nvector<int> sub_ivec(i_arr + 1, i_arr + 4);// 包含 {2, 3, 4, 5}四个元素\n\n// 不允许拷贝和赋值\nchar ca4 = ca3;// 错误\n\n// 复杂的数组声明定义\nint *parr[10];// 是数组，包含10个整形指针的数组\nint &rarr[10]=?;//错误，不存在 引用数组，引用不是对象\nint (*Parray)[10] = &arr;//是指针，指向一个含有10个整数的数组\nint (&Rarray)[10] = arr;//是引用，引用一个含有10个整数的数组\t\n```\n## 【3】访问数组元素\n### 与标准库类型vector 和 string 一样，数组元素也可以使用 范围for语句\n### 或下标运算符 访问，元素下标从0开始，下标通常定义为 size_t类型,unsigned类型。\n### 标准库类型vector 和 string 下标运算符索引必须为正值 unsigned类型，数组下标运算符索引 为signed类型，内置类型，可以为负值\n```c\n//下标访问修改元素\nunsigned score[11];//11个分数段\nunsigned grade;\nwhile(cin >> grade){\n    if(grade <= 100) ++score[grade/10];//对应段 计数+1\n}\n// 范围for 访问修改所有元素\nfor( auto i:score)//可以设置为 引用就可以修改元素了\n    cout << i << \" \";\ncout << endl;\n\n// 指针访问数组\nint iarr[] = {0,1,2,3,4};//含有5个元素\nint *pi = iarr;//指向第一个元素的指针 iarr[0]\nint *pi2 = iarr + 2;//指向第三个元素的指针 iarr[2]\nauto num = end(iarr) - begin(iarr); // num的值是5 就是iarr包含元素的数量 \n                               // ptrdiff_t 类型 是signde类型 结果可能为负\n++pi;//指向第二个元素 iarr[1]\nj = pi[1];   // 等价于 *(p+1),就是 iarr[2], 就是 2\nk = pi[-1];  // 等价于 *(p-1),就是 iarr[0], 就是 0\npi + 3;//指向最后一个元素\n*pi;//第二个元素 4\nint last =  *(iarr + 4);// 等价于 last = iarr[4];\nint *end = &iarr[6];//指向尾后的位置 到达不了    不能执行解引用运算！！！！！\n// 使用 for \nfot(int *begin = arr; begin != end; ++begin)\n\tcout << *begin  << endl;//输出每一个元素\n// 使用 while\nwhile(begin<end){//指针指向相关的对象 可以比较大小（单位（间隔）一样大）\n\tcout << *begin  << endl;//输出每一个元素\n\t++begin;\n}\n\n//标准库函数 begin() end() 函数得到指针\nint iarr = {0,1,2,3,4};//函数5个元素\nint *beg = begin(iarr);//首元素指针\nint *end = end(iarr);//尾后指针                 不能执行解引用运算！！！！！\nwhile(beg != end && *beg >=0) ++beg;//找第一个负值元素\n```\n## 多维数组 数组的数组\n\n### 初始化\n```c\nconstexpr size_t row =3, col = 4;\nint iarr[row][col];//定义未初始化\n\n//下标运算符（size_t 类型） for 循环初始化\nfor(size_t i = 0; i != row; ++i){\n\tfor(size_t j = 0; j != col; ++j){\n\t\tiarr[i][j] = i * col + j;//元素索引为其 值\n\t\tcout << iarr[i][j] << ' '; // 访问输出  数组元素\n\t\t}\n\t cout << endl;\t\n}\n\n// 范围for 初始化\nsize_t cnt = 0;\nfor (auto &row1 : iarr)//每一行 引用  int (&row1)[4] 是引用 引用一个含有4个整数的数组\n {\t\n\tfor (auto &col1 : row1){// int &col1 每一行的每一个元素 引用  可以读写 除去最内层外 其它必须使用 引用\n\tcol1 = cnt;//赋值\n\tcout << col1 << ' ';// 访问 输出数组元素\n\t++cnt;\n\t}\n\tcout << endl;\n }\t\n```\n\n### 访问 \n```c\n// 指针访问\nint (*p)[4] = iarr;//p 指向一个含有4个整数的数组 iarr的 第一行   圆括号必不可少\np = &iarr[2]; // iarr的 第3行\n// for 循环访问\nfor( auto p = ia; p != ia + row; ++p){// 相当于定义 int (*p)[4] = iarr; p 指向 含有4个整数的数组\n\t for( auto q = *p; q != *p + col; ++q) \n\t     // *p 为含有4个元素的数组 q指向数组的首元素，即指向一个整数 int *q = *p\n\t\tcout << *q << ' ';\n\t cout << endl;\n}\n// 使用 标准库函数 begin() 和 end()\nfor( auto p = begin(ia); p != end(ia); ++p){\n               // 相当于定义 int (*p)[4] = iarr; p 指向 含有4个整数的数组\n\t for( auto q = begin(*p); q != end(*p); ++q) \n\t       // *p 为含有4个元素的数组 q指向数组的首元素，即指向一个整数 int *q = *p\n\t\tcout << *q << ' ';\n\t cout << endl;\n}\t\n// 使用类型别名\nusing int_arr_tpye = int[4];// int_arr_tpye为包含4个元素的整形数组\ntypedef int int_arr_tpye[4];// 效果同上\nfor( int_arr_tpye *p = ia; p != ia + row; ++p){// 相当于定义 int (*p)[4] = iarr; p 指向 含有4个整数的数组\n\t for( int *q = *p; q != *p + col; ++q) // *p 为含有4个元素的数组 q指向数组的首元素，即指向一个整数\n\t\tcout << *q << ' ';\n\t cout << endl;\n}\n```\n\n# 函数 \n包括：返回类型 函数名字（形参列表） 函数体，函数的返回类型不能是数组或函数类型，但可以是 数组或函数类型的指针\n\n## 函数定义  阶乘函数\n```c\nint fact(int val){\n\tint ret = 1;\n\twhile(val >1) ret *= val--;\n\treturn ret;// 返回主调函数 结束函数调用\n}\n```\n\n## 函数调用 分两步 1 实参初始化形参（形参为引用时，直接使用实参）  2控制权转移给被调用函数（inline 内联函数 之间在原处展开函数）\n\n```c \nint main(){\nint j = fact(5);// 实参5 初始化 形参（int val）\ncout << \"5! = \" << j << endl;\nreturn 0;\n}\n```\n## 局部对象\n> 形参和函数体内定义的变量统称为 局部变量，仅在函数的作用域内可见， 局部自动对象，只存在于函数体执行期间，而局部静态对象，可在函数调用后一直存在\n```c\n// 定义\nint count_call(void){\n int c =0;        //局部自动对象 每一次调用都初始化为 0  \n static int sc =0;//局部静态变量 第一次调用初始化为0 以后每次调用在前一次值上 +1 \n cout << ++sc << \"   \" << ++c << endl; \n}\n// 调用\nint main(){\n for(int i =0; i<10; ++i)  count_call(); //sc 输出 1 2,...10，c 输出一直是1\n return 0;\n}\n```\n## 分离式编译 函数声明 与函数定义类似但是 不包括函数体，以;代替函数体 int fact(int val); 函数可以多次声明\n```c\n// 源文件 fact.cc\n#include \"fact.h\"\nint fact(int val){\n\tint ret = 1;\n\twhile(val >1) ret *= val--;\n\treturn ret;// 返回主调函数 结束函数调用\n}\n// 函数声明头文件 fact.h\n#ifndef FACT_H\n#define FACT_H\nint fact(int val);// 函数声明 \n#endif\n// 主函数调用 fact_main.c\n#include <iostream>\n#include \"fact.h\"\nusing namespace std;\nint main(){\nint j = fact(5);// 实参5 初始化 形参（int val）\ncout << \"5! = \" << j << endl;\nreturn 0;\n}\n// 编译\ngcc fact_main.c fact.cc -o main\n```\n## 参数传递\n> 当形参是引用类型时，为引用传递，实际传递的是实参的别名，没有进行拷贝，当实参的值被拷贝给形参时，形参和实参是两个独立的对象\n\n### 值传递    函数对形参做的所有操作 都不会影响实参\n```c\nint n=0;\nint i = n;// n拷贝给i\ni = 42;//i的值改变， n的值不变    函数对形参做的所有操作 都不会影响实参 例如 fact(i) 不会改变i的值\n```\n### 引用传递  函数对形参做的所有操作 都会影响实参\n```c\nint n = 0;\nint &r_i = n;//r_i 是 n 的引用 即别名 同一个变量\nr_i = 42;//r_i 和 n 都变成 42    \n```\n### 指针形参\n```c\nint n=0, i =42;\nint *p_n = &n, *p_i = &i;// 指针\n*p_n = 100;// n 的值 变为100 指针p_n（变量你存储的地址） 不变\np_n = p_i;// 现在 p_n  和  p_i 都指向了 i\n\n// 指针形参 函数\nvoid reset(int *pi){\n *ip = 0;//改变了指针 pi 所指向的对象的值\n ip = 0;// 值改变了 形参ip的值 实参未被改变\n}\n\n// 调用\nint i = 42;\ncout << \"address of i =\" << &i <<endl;\nreset(&i);// i 的值改变为0\ncout << \"i = \" << i << endl;// i 的值改变为0\ncout << \"address of i =\" << &i <<endl;// i 的存储地址未改变\n\n// C 程序中 通常使用 指针类型的形参 来访问和改变 函数外部的对象\n// C++ 程序中，建议使用引用类型的形参代替 指针形参，这样会更安全，也省时间（引用 无拷贝操作）\n\n// 使用 引用避免拷贝 拷贝大的类对象或容器 都比较低效 费时\n```\n### 引用形参\n```c\n void reset(int &i){\n  i = 0;// 改变了i所引用的对象\n }\n // 调用\n int j = 42;\n reset(j);// 采样传 引用方式，它的值被改变 调用时 形参i 只是 实参j的一个别名，在函数reset内部对i的操作，即对j的使用\n cout << \"j = \" << j << endl;\n```\n### 常量引用形参 当函数无须 改变引用参数的值时，最好将其声明为 常量引用\n```c\n// 比较两个字符串的长度\nbool isShorter(const string &rs1, const string &rs2){\n\treturn rs1.size() < rs2.size();\n}\n```\n### 使用引用形参 返回额外信息\n```c\n// 函数返回多个值 返回字符在某个字符串中第一次出现的位置，并返回出现的 总次数\nstring::size_type find_char(const string &crs, char c, string::size_type &occurs){\n\t\t\t\t// 字符串        查找的字符      出现的次数\n\tauto ret = crs.size();//初始化 第一次出现的位置\n\toccurs = 0;//初始化 出现的次数\n\tfor(decltype(ret) i = 0; i != crs.size(); ++i){\n\t  if(crs[i] == c){// 出现字符 c\n\t    if (ret == crs.size())//位置 还未改变 为  第一次出现 \n\t    ret  = i;//记录第一次出现的位置\n\t    ++occurs;//出现次数 +1  通过形参引用间接返回 出现的次数\n\t  }\n\t}  \n\treturn ret;//返回第一次出现的位置\n}\n\n// 调用\nstring s(\"some string\");\nstring::size_type count = 0;\nauto index = find_char(s, 'o', count);\n\n// 判断 string对象是否是 一个句子\n bool is_sentence(const string &crs){\n\t  // 如果 find_char() 的string参数 必须为 string & 那么不能直接把 const string & 带入\n\t  // 需要再定义一个 string对象， 另其为 crs 的副本，再带入\n\t string::size_type count = 0;\n\t return (find_char(crs, '.', count) == (crs.size() - 1)) &&  count == 1;\n }\n```\n### 数组形参 必须确保使用数组时不会越界  通常需要给一个结束标志\n\t1 不允许拷贝数组 \n\t2 在使用数组时会将其转换成指针（指向数组首元素的指针）\n```c\n// 三个函数等价 形参 都是 const int * 类型\nvoid print(const int*);\nvoid print(const int[]);\nvoid print(const int[10]);// 这里的维度表示期望数组含有多少元素，实际不一定\n//调用\nint i = 0;\nj[2] = {0, 1};\nprint(&i); //&i 是int *类型 可以赋值给 const int *类型\nprint(j);  //j 为 &j[0] 是 int * 类型\n```\n#### 使用标记指定数组长度   要求数组本身包含 一个结束标志  典型 C风格字符串 带有一个空字符\n```c\n// C风格字符串 带有一个空字符\nvoid print(const char *cp){\n  if(cp)// 确定 cp 不是一个空指针\n    while(*cp) // 只要 指针所指的字符不是 空字符\n       cout << *cp++;// 打印 字符\n}\n```\n#### 使用标准库规范 传递 数组元素的 首末地址\n```c\nvoid print(const int *beg, const int *end){\n  while(beg != end) \n    cout << *beg++ << endl;//输出当前元素 并将指针向前移动一个位置\n}\n// 调用\nint j[2] =  {0, 1};\nprint(begin(j), end(j));// 使用标准库 begin() 和 end() 函数\n```\n#### 显示传递 一个数组大小的形参\n```c\nvoid print(const int ia[], size_t size){\n  for (size_t i = 0; i != size; ++i) \n     cout << ia[i] << endl;// 等价于 cout << *(ia+i) << endl;\n}\n// 调用\nint j[2] =  {0, 1};\nprint( j, end(j) - begin(j) );// 使用标准库 begin() 和 end() 函数 做差来得到数组的大小\n```\n#### 数组引用形参 int (&r_arr)[10] 是一个含有10个元素数组的 引用  直接包含了 数组大小的信息\n```c\nvoid print(int (&r_arr)[10]){ // 注意形式 int (&r_arr)[10]   而 int &arr[10] 成了 包含引用的数组（还不存在，引用不是对象）\n  for (auto elem : r_arr)// 变量数组每个元素  范围for\n    cout << elem << endl;\n}\n// 调用 调用时 必须是 大小为10的整形 数组作为实参才可以\nint k[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\nprint(k);// 大小必须为10 多一点 少一点 都不行\n```\n#### 多维数组形参 数组指针 形参\n```c\nvoid print(int (*p_arr)[10], int rowSize){}// 形参是 指向 一个含有10个整数的指针\n```\n### main函数 主函数参数列表\n```c\n// argc：argument counter 参数计数,argv：argument vector 参数 字符串 容器\nint main(int argc, char *argv[]){}\nint main(int argc, char **argv){}//第二个参数为 字符串数组 即数组的数组 指针的指针   argv 指向 char*\n//程序执行 program -d -o outfile data0\n则 argc = 5\nargv[0] = \"program\"; // 程序名\nargv[1] = \"-d\";      // 第一个参数 开始\nargv[2] = \"-o\";      // 第二个参数\nargv[3] = \"outfile\"; // 第三个参数\nargv[4] = \"data0\";   // 第四个参数  最后一个指针\nargv[5] = 0;   // 最后一个指针之后 的元素为0\n```\n### 含有可变形参的函数  1 传递一个 initializer_list 标准库类型，2 特殊参数类型 省略号 ...\n\n#### initializer_list 形参  实参数量未知  但是全部实参类型 都 相同\n```c\n// initializer_list 提供的操作\ninitializer_list<T> lst;// 默认初始化 T类型元素的空列表 模实际需要指定模板T的 具体类型\ninitializer_list<T> lst{a, b, c...};// 列表中的元素是 const 常量\nlst2(lst); // 拷贝一个initializer_list对象，不会新建，原始列表 和 副本 共享元素\nlst2 = lst;// 同上\nlst.size();// 列表 中的元素\nlst.begin();//返回指向lst中首元素的指针\nlst.end();  //返回指向lst中尾元素下一个位置的指针\n// 因为有 begin() 和 end()对象可以使用 范围for 遍历参数\n\n// 具体\ninitializer_list<string> ls ;//initializer_list 的元素类型是 string\ninitializer_list<int> li ;   //initializer_list 的元素类型是 int\n// 和vector不同的是 initializer_list中的元素是常量 不能被修改\n\n// 定义函数\nvoid error_msg(initializer_list<string> ls){\n\t for(auto beg = ls.begin(); beg != ls.end(); ++beg)\n\t   cout << *beg << \" \";\n\t cout << endl;\n}\n//调用函数\n//expected 和 actual 是string 对象\nif (expected != actual)\n\terror_msg({\"function\", expected, actual});\nelse\n\terror_msg({\"function\", \"okey\"});\n// 传递了一个含有不同数量元素的 initializer_list\n\n// 定义函数 包含 ErrCode\nvoid error_msg(ErrCode e, initializer_list<string> ls){\n\t cout << e.msg() << \": \"\n\t for(const auto &elem : ls )//范围for 遍历\n\t  cout << elem << \" \";\n\t cout << endl;\n} \n```\n#### 省略符 ... 形参\n```c\nvoid foo(param_list, ...)//\nvoid foo(param_list...)//\nvoid foo(...)//\n```\n## 函数 返回类型 和 return语句\n### 无返回值函数 void函数 无需显示的 return 语句   return 后无值\n```c\n// 交换两个值的函数\nvoid swap(int &r_i1, int &r_i2){\n   if (r_i1 == r_i2)// 两个值相等 无需交换\n      return;\n   // 若 执行 到这里，说明还需要继续完成下面的功能 \n   int temp = r_i1;//\n   r_i1 = r_i2;\n   r_i2 = temp;\n   // 此处 无需 显示的 return 语句   会隐式指向 return\n}\n```\n### 有返回值函数  return 后有值 且返回的对象类型 与 函数定义的 返回类型相同\n```c\n// 两个 string 对象是否 最短的部分 是相同的\nbool str_subrange(const string &str1, const string &str2){\n if (str1.size() == str.size())\n     return str1 == str2; // 之间判断 相同长度间的部分是否相同\n auto size = (str1.size() < str2.size()) ? str1.size() : str2.size(); //得到最短 字符串的 长度\n for(decltype(size) i = 0; i != size; ++i){\n   if ( str1[i] != str2[i])// 如果 有 不相等的 字符 返回 false\n    return false;// 有 不相等的 字符 返回 false\n  }\n return true; // 否者 相等 返回 true\n}\n```\n### 返回类型为 引用时 不会对结果进行拷贝 节省时间  但是 不要 返回 函数内部 临时变量的 引用， 临时变量离开函数后就不存在了\n### 建议 返回 引用对象 是一个 调用函数 之前就纯在的一个变量\n### 同时 返回 非常量的引用 可以作为 左值 被赋值\n```c\n// 不要 返回 函数内部 临时变量的 引用\nstring temp(\"glo\");\nconst string &mainip() {\n\t string ret(\"Empty\"); // 函数内部临时变量\n\t return ret; // 错误 ，不能返回 临时变量 作为 函数返回值的 引用\n\t // return temp;// 返回 一个调用函数之前就出现的 变量 的引用     或者  参数 为引用类型的参数也可以\n}\n\n// 返回 两个字符串中 短的那个\nconst string &shortString(const string &s1, const string &s2){// 返回 s1 或者 s2的引用\n\treturn s1.size() < s2.size() ? s1 : s2;//返回 两个字符串中 短的那个\n}\n\n// 函数返回类型 为 标准库 类类型 可以直接调用 其成员函数\nauto sz = shortString(s1, s2).size()// 得到最短字符串 的长度\n\n// 返回 非常量的引用 可以作为 左值 被赋值  \nchar &get_char(string &str, string::size_type id){\n\treturn str[id];// 获取指定位置的 字符\n}\n// 调用\nstring s(\"a value\");\ncout << s << endl;// a value\nget_char(s, 0) = 'A';// 将s第一个位置上的字符 替换为 大写的 A\ncout << s << endl;// A value\n// 而返回为 常量引用 的不能被赋值\nshortString(\"hi\", \"bye\") = \"X\"; // 错误 函数返回值是个 常量引用 不能被赋值\n```\n\n### 函数返回类型为 列表 以花括号 {} 包围\n```c\nvector<string> process(){\n\tif(expected.empty())\n\t  return {};// 返回一个 空vector对象\n\telse if (expected == actual)\n\t  return {\"function\", \"okey\"};\n\telse \n\t  return {\"function\", expected, actual};\n}\n```\n### 函数递归  返回值为自身函数 的一个 式子   main 函数不能调用自己\n```c\n// 计算阶乘的函数\nint factorial( int val){\n\tif(val > 1)\n\t   return val * factorial(val-1);\n\telse \n\t    return 1;\n}\n// 递归 返回一个vector的元素函数\nvoid print_vec(vector<int> vi){\n\tauto it = vi.begin();\n\tif(vi.size() > 1)\n\t {\n\t   cout << *it <<endl;\n\t   vi.erase(it);\n\t   print_vec(vi);\n\t}\n\telse \n\t   cout << *it <<endl;\n}\n```\n### 返回 数组 指针 数组不能被 拷贝 所以函数不能返回数组 但可以返回 数组的指针 或引用\n```c\n// 使用类别别名\ntypedef int arrT[10];// arrT是一个类别别名 表示一个 含有 10个整数 的 数组\nusing arrT = int[10];// 同上\narrT* func(int i);   // 函数func 返回一个 指向 10个整数的数组的 指针\n\n//直接声明\nint arr[10]; //arr 是一个 含有 10个整数的数组\nint *arr_p[10]; //arr_p 是一个数组   含有 10个指整形针 的 数组\nint (*p2)[10] = &arr; // p2 是一个指针， 指向一个含有 10个整数的 数组 arr\n// 函数声明 类似\nType (*function_name(parameter_list))[dimension]\nint ( *func(int i) )[10];// 声明一个函数 其形参为 int i ,返回类型 为 指针 ，指向 一个 含有 10个整数的 数组\n\n// 函数指针数组\n多个函数可以像数组一样被调用\nint (*fun_p_a[])(char *tmp); //函数指针数组\n\n// 使用 auto 和 尾置返回类型\nauto func(int i) -> int(*)[10];// 声明一个函数 其形参为 int i ,返回类型 为 指针 ，指向 一个 含有 10个整数的 数组\n\n// 使用 decltype 知道返回数组  类似类别别名 声明 定义\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\ndecltype(odd) *arrPtr(int i){ //使用decltype(odd) 表面类型与 odd类似\n return (i%2) ? &odd : &even;// 返回一个指向数组的指针\n}\n\n// 声明一个 返回 引用 一个 含有10个string对象的数组 的函数\nstring ( &func_r(string str) )[10];// 直接声明\n  // 使用类别别名\ntypedef string arrS[10];// 类别别 含有10个string对象的数组\nusing arrS = string[10];// 同上\narrS &func(string str);   // 函数func 返回一个 指向 10个整数的数组的 指针\n  // 使用 auto 和 尾置返回类型\nauto func(string str) -> string(&)[10];\n  // 使用 decltype 知道返回数组  类似类别别名 声明 定义\nstring str_arr[] = {\"a string\", \"two\"};\ndecltype(str_arr) &arrPtr(string str);\n```\n## 函数 重载  同一个作用域内 的几个函数名字相同，但形参列表不同，成为 重载 (overloaded)\n```c\n// 打印 数组元素的 几个 同名函数\nvoid print(const char *cp);//出入参数为 带有结束符的 \n"
        },
        {
          "name": "STL标准模板库.md",
          "type": "blob",
          "size": 6.984375,
          "content": "# Standard  Library 标准库\n# Standard Template Library 标准模板库\n## 1. 容器   containers\n## 2. 迭代器 iterators\n## 3. 算法   algorithms  \n## 4. 函数器 functional\n\n\n\n# 0.1 函数模板、类模板 与 * 乘法运算符 重载\n```c\n#include<iostream>\n// 函数模板\ntemplate<typename T>\nT square(T x){\n  return x*x;\n}\n// 类模板\ntemplate<typename T>\nclass BoVector{\n// class 默认为 provide 私有 类型\n  T arry[1000];// 初始数组容量\n  int size;    // 实际存储数据数量\npublic:\n  BoVector(): size(0) {}; // 类默认构造函数 初始化 size=0\n  void push(T x){ arry[size] = x; size++; } // 插入数据\n  T get(int i) const {return arry[i]; }// 需要是否越界检查\n  int getsize() const {return size;}\n  void print() const { for(int i=0; i<size; i++){std::cout << arry[i] << std::endl;} }\n};\n\n// 类的BoVector  * 运算符 重载\ntemplate<typename T>\nBoVector<T> operator*(const BoVector<T>& bv1, BoVector<T>& bv2){\n  BoVector<T> ret;\n  for(int i=0; i<bv1.getsize(); i++){\n    ret.push(bv1.get(i) * bv2.get(i));\n  }\n  return ret;\n}\n\n\nint main(){\n  std::cout << square(5) << std::endl;   // square<int>(5) 函数模板 模板类型可省略, 会自己的推断\n  std::cout << square(5.5) << std::endl; // square<double>(5.5)\n\n  BoVector<int> bv;// 类模板的模板类型不可省略\n  bv.push(1);\n  bv.push(2);\n  bv.push(3);\n  bv.push(4);\n  bv.print();// bv = {1,2,3,4}\n\n  bv = square(bv); // 模板函数 --> 乘法运算符重载\n  bv.print();      // bv = {1,4,9,16}\n}\n\n```\n\n# 0.2容器 迭代器 算法 示例\n```c\n#include<iostream>// std::cout & std::endl \n#include<vector>  // std::vector\n#include<algorithm>// std::sort\nusing namespace std;\n\nint main(){\n// 容器========\n\tvector<int> vec_i;\n\tvec_i.push_back(5);\n\tvec_i.push_back(2);\n\tvec_i.push_back(0); // vec_i = (5, 2, 0);\n// 迭代器======\n\tvector<int>::iterator iter_beg = vec_i.begin(); // [begin, end) 左闭右开区间\n\tvector<int>::iterator iter_end = vec_i.end();\n\n    for(vector<int>::iterator it = iter_beg; it!=iter_end; ++it){\n\t\tcout << *it << endl;// vec_i = (5, 2, 0);\n\t}\n// 算法========\n        // 算法 通过 迭代器 对 容器元素 进行操作 !!!!!!!!!!!!!!!\n\tsort(iter_beg+1, iter_end);//vec_i = (5, 0, 2);\n\t\n    for(vector<int>::iterator it = iter_beg; it!=iter_end; ++it){\n\t\tcout << *it << endl;\n\t}\n\t\n\tsort(iter_beg, iter_end);//vec_i = (0, 2, 5);\n\tfor(vector<int>::iterator it = iter_beg; it!=iter_end; ++it){\n\t\tcout << *it << endl;\n\t}\n\t\n\treturn 0;\n}\n```\n# 1. 容器\n## 1.1 序列容器\n\tvector向量 deque双向队列 双向链表list 单向链表forward_list array数组\n\t#include <vector> \n\t#include <deque>\n\t#include <list>\n\t#include <forward_list>\n\t#include <array>\n### a. vector向量  动态数组\n        |||  ........... -----> \n```c\n\n/*\n1. 在向量尾部 插入/删除元素 特别快 O(1)\n2. 在向量头部 或者 中间插入元素 特别慢 O(n)\n3. 在向量中查找一个元素特别慢 O(n)\n|||  ........... ----->\n头            尾\n*/\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n\n\tvector<int> vec_i;  // vec_i.size() == 0\n\tvec_i.push_back(5);\n\tvec_i.push_back(2);\n\tvec_i.push_back(0); // vec_i = {5, 2, 0}, vec_i.size() == 3\n\n// 访问数据 随机访问\n    cout << vec_i[2] << endl;    // 0, []访问，无范围检查\n    cout << vec_i.at(1) << endl; // 2, .at()访问，会进行范围检查，访问速度稍慢，但是安全\n    \n// 通过 索引 遍历元素\n    for(int i = 0; i < vec_i.size(); ++i){\n    \tcout << vec_i[i] << \" \"; //确定索引不会超范围，就用索引访问  vec_i.at(i)\n    }\n    cout << endl;\n    \n// 通过迭代器 遍历元素\n    for(vector<int>::iterator iter = vec_i.begin(); iter != vec_i.end(); ++iter){\n    \tcout << *iter << \" \"; // 对迭代器进行解引用得到\n    }\n    cout << endl;\n    \n//范围for c++ 11 遍历元素\n//    for(item:vec_i){\n//   \tcout << item << \" \";\n//    }\n//    cout << endl;\n\n// 指针访问\n\tint* p = &vec_i[0];\n\tfor(int i = 0; i < vec_i.size(); ++i){\n\t\tcout << p[i]<< \" \";\n\t}\n    cout << endl;\n    \n// 部分容器的成员函数\n\tif(vec_i.empty()) cout << \"vec_i has no num\" << endl; // 是否包含元素\n\t\n\tcout << vec_i.size() << endl; // 存储的元素数量\n\t\n\tvector<int> vec_i2(vec_i); // 拷贝初始化， vec_i2 = {5, 2, 0}\n\t\n\tvec_i.clear(); // 清空元素 vec_i.size() == 0\n\t\n\tvec_i2.swap(vec_i); // 两向量交换元素，vec_i2.size() == 0, vec_i = {5, 2, 0}\n    \n    \n\treturn 0;\n}\n\n```\n### b. deque 双向队列 \n\t<-----|..................|----->\n\t     队首               队尾 \n```c\n/*\n1. 在队列 头部和尾部插入元素，特别快 O(1)\n2. 在队列中间插入元素，特别慢 O(n)\n3. 在队列中查找元素，特别慢 O(n)\n<-----|..................|----->\n     队首               队尾 \n*/\n\n#include<deque>\nusing namespace std;\ndeque<int> deq = {5, 2, 0};\ndeq.push_back(5);  // 队尾  插入 {5, 2, 0, 5}\ndeq.push_front(0); // 队首  插入 {0, 5, 2, 0, 5}\n\n// 其他接口和 vector 的类似\ncout << deq[1] ; // 5\ncout << deq.at(2) ;// 2\ndeque<int>::iterator iter = deq.begin() + 3;\ncout << *iter ; // 0\n// size() empty()  clear() swap()\n\n\n```\n### c.双向链表list \n\t 双向链表，包含前后指针，和数据域，数据不连续，浪费访存，多包含两个指针变量，浪费内存\n```c\n/*\n1. 在链表中任意位置插入/删除 元素 特别快 O(1)\n2. 在链表中查找元素 特别慢， O(n)， 实际上因为内存不连续，浪费访存case，比vector慢了很多\n3. 无随机访问 [] 以及 .at()\n4. splice() 实现list拼接的功能。将源list的内容部分或全部元素删除，拼插入到目的list。 O(1)\n*/\n#include<list>\n#include<algorithm> // std::find\n#include<iostream>\nusing namespace std;\nint main(){\n\nlist<int> mylist = {5, 2, 0};\nmylist.push_back(1);\nmylist.push_back(3);\nmylist.push_back(1);\nmylist.push_back(4);// {5, 2, 0, 1, 3, 1, 4};\n\nmylist.push_front(5);// {5, 5, 2, 0, 1, 3, 1, 4};\n\n// 查找元素2\nlist<int>::iterator itr = find(mylist.begin(), mylist.end(), 2);// itr --->2\n\ncout << *itr << endl;\n// 插入元素6   链表插入速度特别快\nmylist.insert(itr,6);// {5, 5, 6, 2, 0, 1, 3, 1, 4};// 在2的前面一个位置插入6\ncout << *itr << endl;\n\nitr++; // 指向 0\ncout << *itr << endl;\n\n// 删除 itr指向的元素   速度特别快 O(1)\nmylist.erase(itr);// {5, 5, 6, 2, 1, 3, 1, 4};\ncout << *itr << endl; // 但是内存还存在 0元素\n\nfor(list<int>::iterator itr1 = mylist.begin(); itr1 != mylist.end();++itr1){\n\tcout << *itr1 << endl;\n}\n\n\treturn 0;\n}\n```\n### d. 单向链表forward_list \n\n\n### e. array数组\n\n\n## 1.2 有序关联容器（红黑二叉树） \n\tset, multiset 单值树集合  multi 关键字可以重复出现\n\tmap, multimap 配对双值树集合\n\t\n\t#inlcude<set>\n\t#inlcude<multiset>\n\t#inlcude<map>\n\t#inlcude<multimap>\n\t\n## 1.3  无序关联容器（哈希表）\n\tunordered set/multiset  单值桶集合\n\tunordered map/multimap  配对双值桶集合 \n\t\n\t#inlcude<unordered_set>\n\t#inlcude<unordered_multiset>\n\t#inlcude<unordered_map>\n\t#inlcude<unordered_multimap>\n\t\n\t// 和另一个库里的类似\n\thash_map\n\thash_set\n\thash_multimap\n\thash_multiset\n\t\n\n\n"
        },
        {
          "name": "Socket",
          "type": "tree",
          "content": null
        },
        {
          "name": "cnki-pdf-special.user.js",
          "type": "blob",
          "size": 2.21484375,
          "content": "// ==UserScript==\r\n// @id             CNKI-PDF-Special\r\n// @name           CNKI 中国知网 PDF 全文下载(特制版)\r\n// @version        1.25\r\n// @namespace      http://yuelong.info\r\n// @author         YUE Long\r\n// @updateURL      https://userscripts.org/scripts/source/164338.meta.js\r\n// @description    ① 点击 CNKI 检索结果界面中的下载按钮可以直接下载 PDF 格式文献；② 在硕士/博士学位论文详细信息界面添加“PDF下载”按钮。 ※特制版功能：在检索页面中的硕士/博士论文默认下载 CAJ 文件。\r\n// @include        http://*.cnki.net/*\r\n// @include        http://*.cnki.net.*/*\r\n// @run-at         document-idle\r\n// ==/UserScript==\r\n\r\nvar allLis, thisLi, newLi, aPDF, allLinks, thisLink, pageType;\r\npageType = true;\r\n\r\nallLinks = document.evaluate(\r\n\t'//a[@href]',\r\n\tdocument,\r\n\tnull,\r\n\tXPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\r\n\tnull);\r\n\r\nallLis = document.evaluate(\r\n    \"//li[@class]\",\r\n\tdocument,\r\n\tnull,\r\n\tXPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\r\n\tnull);\r\n\r\nif (allLis) {\r\n\tfor (var i = 0; i < allLis.snapshotLength; i++) {\r\n\t\tthisLi = allLis.snapshotItem(i);\r\n\t\tif (thisLi.getAttribute(\"class\").indexOf(\"readol\") !== -1) {\r\n\t\t\tpageType = false;\r\n\t\t\tnewLi = document.createElement('li');\r\n\t\t\tnewLi.setAttribute(\"class\",\"pdf\");\r\n\t\t\taPDF='<a target=\"_blank\" href=\"' + thisLi.firstChild.href.replace(\"&dflag=readonline\",\"&dflag=pdfdown\") +'\">PDF下载</a>';\r\n\t\t\tnewLi.innerHTML=aPDF;\r\n\t\t\tthisLi.parentNode.insertBefore(newLi, thisLi.nextSibling);\r\n\t\t}\r\n\t\tif (thisLi.getAttribute(\"class\").indexOf(\"cajNew\") !== -1) {\r\n\t\t\tpageType = false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nif (pageType) {\r\n\tfor (var i = 0; i < allLinks.snapshotLength; i++) {\r\n\t\tthisLink = allLinks.snapshotItem(i);\r\n\t\tif (thisLink.href && thisLink.href.indexOf(\"download.aspx?filename=\") != -1 && thisLink.href.indexOf(\"&dflag\") == -1 && thisLink.href.indexOf(\"=CMFD\") == -1 && thisLink.href.indexOf(\"=CDFD\") == -1 ) {\r\n\t\tthisLink.href = thisLink.href + \"&dflag=pdfdown\";};\r\n\t\tif (thisLink.href && thisLink.href.indexOf(\"download.aspx?filename=\") != -1 && thisLink.href.indexOf(\"&dflag\") == -1 && (thisLink.href.indexOf(\"=CMFD\") !== -1 || thisLink.href.indexOf(\"=CDFD\") !== -1 )) {\r\n\t\tthisLink.href = thisLink.href + \"&dflag=nhdown\";};\r\n\t}\r\n};"
        },
        {
          "name": "datastructure_code",
          "type": "tree",
          "content": null
        },
        {
          "name": "debn.txt",
          "type": "blob",
          "size": 8.69140625,
          "content": "#-*- coding:utf-8 -*-\n#!/usr/bin/env python  \n# export PYTHONPATH=/home/wanyouwen/ewenwan/software/caffe_yolo/caffe/python\n# sudo python2 examples/ristretto/resNet/caffe_no_batchnorm.py /data4/quantization/models/ResNet/ResNet-152-train-val.prototxt |\n# /data4/quantization/models/ResNet/ResNet-152-model.caffemodel --output_model ResNet-152-train-val-remove-bn.prototxt --output_weight ResNet-152-model-remove-bn.caffemodel\n#import _init_paths  \nimport numpy as np  \nimport sys  \nimport os  \n# caffe python 接口\nsys.path.insert(0,\"/home/wanyouwen/ewenwan/software/caffe_yolo/caffe/python\")\nimport os.path as osp  \nimport google.protobuf as pb  \nfrom argparse import ArgumentParser  \nimport sys  \nimport caffe  \n  \n# 载入原始模型 \ndef load_and_fill_biases(src_model, src_weights, dst_model, dst_weights):  \n    with open(src_model) as f:  \n        model = caffe.proto.caffe_pb2.NetParameter()  \n        pb.text_format.Merge(f.read(), model)  \n  \n    for i, layer in enumerate(model.layer):  \n    # 卷积层 后面会有 BN层\n        if layer.type == 'Convolution': # or layer.type == 'Scale':  \n            # Add bias layer if needed  \n            if layer.convolution_param.bias_term == False:  \n                layer.convolution_param.bias_term = True  \n                layer.convolution_param.bias_filler.type = 'constant'  \n                layer.convolution_param.bias_filler.value = 0.0  \n  \n    with open(dst_model, 'w') as f:  \n        f.write(pb.text_format.MessageToString(model))  \n  \n    caffe.set_mode_gpu()  \n    net_src = caffe.Net(src_model, src_weights, caffe.TEST)  \n    net_dst = caffe.Net(dst_model, caffe.TEST)  \n    for key in net_src.params.keys():  \n        for i in range(len(net_src.params[key])):  \n            net_dst.params[key][i].data[:] = net_src.params[key][i].data[:]  \n  \n    if dst_weights is not None:  \n        # Store params  \n        pass  \n  \n    return net_dst  \n  \n  \ndef merge_conv_and_bn(net, i_conv, i_bn, i_scale):  \n    # This is based on Kyeheyon's work  \n    assert(i_conv != None)  \n    assert(i_bn != None)  \n  \n    def copy_double(data):  \n        return np.array(data, copy=True, dtype=np.double)  \n  \n    key_conv = net._layer_names[i_conv]  \n    key_bn = net._layer_names[i_bn]  \n    key_scale = net._layer_names[i_scale] if i_scale else None  \n  \n    # Copy  \n    bn_mean = copy_double(net.params[key_bn][0].data)  \n    bn_variance = copy_double(net.params[key_bn][1].data)  \n    num_bn_samples = copy_double(net.params[key_bn][2].data)  \n  \n    # and Invalidate the BN layer  \n    net.params[key_bn][0].data[:] = 0  \n    net.params[key_bn][1].data[:] = 1  \n    net.params[key_bn][2].data[:] = 1  \n    if num_bn_samples[0] == 0:  \n        num_bn_samples[0] = 1  \n  \n    if net.params.has_key(key_scale):  \n        print 'Combine {:s} + {:s} + {:s}'.format(key_conv, key_bn, key_scale)  \n        scale_weight = copy_double(net.params[key_scale][0].data)  \n        scale_bias = copy_double(net.params[key_scale][1].data)  \n        net.params[key_scale][0].data[:] = 1  \n        net.params[key_scale][1].data[:] = 0  \n    else:  \n        print 'Combine {:s} + {:s}'.format(key_conv, key_bn)  \n        scale_weight = 1  \n        scale_bias = 0  \n  \n    weight = copy_double(net.params[key_conv][0].data)  \n    bias = copy_double(net.params[key_conv][1].data)  \n    alpha = scale_weight / np.sqrt(bn_variance / num_bn_samples[0] + np.finfo(np.double).eps)  \n    net.params[key_conv][1].data[:] = bias * alpha + (scale_bias - (bn_mean / num_bn_samples[0]) * alpha)  \n    for i in range(len(alpha)):  \n        net.params[key_conv][0].data[i] = weight[i] * alpha[i]  \n  \ndef merge_batchnorms_in_net(net):  \n    # for each BN  \n    for i, layer in enumerate(net.layers):  \n        if layer.type != 'BatchNorm':  \n            continue  \n  \n        l_name = net._layer_names[i]  \n  \n        l_bottom = net.bottom_names[l_name]  \n        assert(len(l_bottom) == 1)  \n        l_bottom = l_bottom[0]  \n        l_top = net.top_names[l_name]  \n        assert(len(l_top) == 1)  \n        l_top = l_top[0]  \n  \n        can_be_absorbed = True  \n  \n        # Search all (bottom) layers  \n        for j in xrange(i - 1, -1, -1):  \n            tops_of_j = net.top_names[net._layer_names[j]]  \n            if l_bottom in tops_of_j:  \n                if net.layers[j].type not in ['Convolution', 'InnerProduct']:  \n                    can_be_absorbed = False  \n                else:  \n                    # There must be only one layer  \n                    conv_ind = j  \n                    break  \n  \n        if not can_be_absorbed:  \n            continue  \n  \n        # find the following Scale  \n        scale_ind = None  \n        for j in xrange(i + 1, len(net.layers)):  \n            bottoms_of_j = net.bottom_names[net._layer_names[j]]  \n            if l_top in bottoms_of_j:  \n                if scale_ind:  \n                    # Followed by two or more layers  \n                    scale_ind = None  \n                    break  \n  \n                if net.layers[j].type in ['Scale']:  \n                    scale_ind = j  \n  \n                    top_of_j = net.top_names[net._layer_names[j]][0]  \n                    if top_of_j == bottoms_of_j[0]:  \n                        # On-the-fly => Can be merged  \n                        break  \n  \n                else:  \n                    # Followed by a layer which is not 'Scale'  \n                    scale_ind = None  \n                    break  \n  \n  \n        merge_conv_and_bn(net, conv_ind, i, scale_ind)  \n  \n    return net  \n  \n  \ndef process_model(net, src_model, dst_model, func_loop, func_finally):  \n    with open(src_model) as f:  \n        model = caffe.proto.caffe_pb2.NetParameter()  \n        pb.text_format.Merge(f.read(), model)  \n  \n  \n    for i, layer in enumerate(model.layer):  \n        map(lambda x: x(layer, net, model, i), func_loop)  \n  \n    map(lambda x: x(net, model), func_finally)  \n  \n    with open(dst_model, 'w') as f:  \n        f.write(pb.text_format.MessageToString(model))  \n  \n  \n# Functions to remove (redundant) BN and Scale layers  \nto_delete_empty = []  \ndef pick_empty_layers(layer, net, model, i):  \n    if layer.type not in ['BatchNorm', 'Scale']:  \n        return  \n  \n    bottom = layer.bottom[0]  \n    top = layer.top[0]  \n  \n    if (bottom != top):  \n        # Not supperted yet  \n        return  \n  \n    if layer.type == 'BatchNorm':  \n        zero_mean = np.all(net.params[layer.name][0].data == 0)  \n        one_var = np.all(net.params[layer.name][1].data == 1)  \n        #length_is_1 = (net.params['conv1_1/bn'][2].data == 1) or (net.params[layer.name][2].data == 0)  \n        length_is_1 =  (net.params[layer.name][2].data == 1)  \n  \n        if zero_mean and one_var and length_is_1:  \n            print 'Delete layer: {}'.format(layer.name)  \n            to_delete_empty.append(layer)  \n  \n    if layer.type == 'Scale':  \n        no_scaling = np.all(net.params[layer.name][0].data == 1)  \n        zero_bias = np.all(net.params[layer.name][1].data == 0)  \n  \n        if no_scaling and zero_bias:  \n            print 'Delete layer: {}'.format(layer.name)  \n            to_delete_empty.append(layer)  \n  \ndef remove_empty_layers(net, model):  \n    map(model.layer.remove, to_delete_empty)  \n  \n  \n# A function to add 'engine: CAFFE' param into 1x1 convolutions  \ndef set_engine_caffe(layer, net, model, i):  \n    if layer.type == 'Convolution':  \n        if layer.convolution_param.kernel_size == 1\\\n            or (layer.convolution_param.kernel_h == layer.convolution_param.kernel_w == 1):  \n            layer.convolution_param.engine = dict(layer.convolution_param.Engine.items())['CAFFE']  \n  \n  \ndef main(args):  \n    # Set default output file names  \n    if args.output_model is None:  \n        file_name = osp.splitext(args.model)[0]  \n        args.output_model = file_name + '_inference.prototxt'  \n    if args.output_weights is None:  \n        file_name = osp.splitext(args.weights)[0]  \n        args.output_weights = file_name + '_inference.caffemodel'  \n  \n    net = load_and_fill_biases(args.model, args.weights, args.model + '.temp.pt', None)  \n  \n    net = merge_batchnorms_in_net(net)  \n  \n    process_model(net, args.model + '.temp.pt', args.output_model,  \n                  [pick_empty_layers, set_engine_caffe],  \n                  [remove_empty_layers])  \n  \n    # Store params  \n    net.save(args.output_weights)  \n  \n  \nif __name__ == '__main__':  \n    parser = ArgumentParser(  \n            description=\"Generate Batch Normalized model for inference\")  \n    parser.add_argument('model', help=\"The net definition prototxt\")# 原模型文件  \n    parser.add_argument('weights', help=\"The weights caffemodel\")   # 原权重文件 \n    parser.add_argument('--output_model')  # 去除BN层的模型文件\n    parser.add_argument('--output_weights')# 去除BN层后的权重文件   \n    args = parser.parse_args()  \n    main(args) \n"
        },
        {
          "name": "debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "doxygen",
          "type": "tree",
          "content": null
        },
        {
          "name": "flutter",
          "type": "tree",
          "content": null
        },
        {
          "name": "js",
          "type": "tree",
          "content": null
        },
        {
          "name": "julia",
          "type": "tree",
          "content": null
        },
        {
          "name": "learn_CAD",
          "type": "blob",
          "size": 0.91796875,
          "content": "三维模型\n\n\n1】C语言格式 的 三维模型编辑器 openscad\n 安装：\nsudo apt-get install openscad\n 运行：\n openscad\n \n 编辑：\n 在openSCAD的编辑器，输入一下命令：  长宽高分别为 2 3 4的长方体方体\n \n规则形状：\n cube([2,3,4]);\n cube(30, center=true); //立方体  坐标中心为几何中心\n sphere(20);            //半径 20 的球体\n cylinder(h=40, r=10);  //圆柱体  底面半径10  高 40\n \n  函数运算\n  1） 差运算 \ndifference() {\ncube(30, center=true);  // 立方体 内中心 抠掉 球体 \nsphere(20);\n}\n\n2）平移运算\n\ntranslate([0, 0, 30]) {//沿 z轴平移 30\ncylinder(h=40, r=10);\n}\n\n3)颜色函数\ncolor([1,0,0]) cube([2,3,4]);  // 红色 长方体\ntranslate([3,0,0])// x轴 平移 3\ncolor([0,1,0]) cube([2,3,4]);  // 绿色\ntranslate([6,0,0])\ncolor([0,0,1]) cube([2,3,4]);  // 蓝色\n\n4) 联合使用改变颜色\ntranslate([0,0,0])\n{\ncolor([0,0,1])\ncube([2,3,4]);\n}\n\n\n"
        },
        {
          "name": "learn_Delphi",
          "type": "blob",
          "size": 0.19921875,
          "content": "# 学习 Delphi 可视化软件开发环境  类似 C#\n\n[鱼C 零基础入门学习](http://blog.fishc.com/category/delphi/page/6)\n\n[Delphi经典案例讲解](http://blog.fishc.com/category/delphi7_anli)\n"
        },
        {
          "name": "learn_boost",
          "type": "tree",
          "content": null
        },
        {
          "name": "learn_c",
          "type": "tree",
          "content": null
        },
        {
          "name": "learn_cpp",
          "type": "tree",
          "content": null
        },
        {
          "name": "learn_python",
          "type": "tree",
          "content": null
        },
        {
          "name": "learn_web",
          "type": "tree",
          "content": null
        },
        {
          "name": "linux_cmd.md",
          "type": "blob",
          "size": 11.974609375,
          "content": "## Linux常用命令手册\t\t\n```\nNO\t分类\tPS1\t命令名   用法及参数\t 功能注解\t\t\t\t\t\n1\t文件管理\t#\tls\tls -a\t     列出当前目录下的所有文件，包括以.头的隐含文件\t\t\t\t\n\t文件管理\t#\tls\tls -l或ll列   出当前目录下文件的详细信息\t\t\t\t\t\t\n\t文件管理\t#\tpwd\t\t\tpwd\t 查看当前所在目录的绝对路经\t\t\t\t\t\n\t文件管理\t#\tcd\t\t\tcd ..\t回当前目录的上一级目录\t\t\t\t\t\n\t文件管理\t#\tcd\t\t\tcd -\t回上一次所在的目录\t\t\t\t\t\n\t文件管理\t#\tcd\t\t\tcd ~ 或 cd 回当前用户的宿主目录\t\t\t\t\t\n\t文件管理\t#\tcd\t\t\tcd ~用户名\t回指定用户的宿主目录\t\t\t\n2\t文件管理\t#\tmkdir\tmkdir 目录名     创建一个目录\t\t\t\t\t\t\t\n\t文件管理\t#\tmkdir\t\tmkdir –p  递归式去创建一些嵌套目录\t\t\t\n\t文件管理\t#\trmdir\t\tRmdir 空目录名 删除一个空目录\t\n3\t文件管理\t#\trm\t\trm 文件名 文件名删除一个文件或多个文件\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t文件管理\t#\trm\t\t\trm -rf 非空目录名\t 递归删除一个非空目录下的一切，不让提式-f\t\t\t\t\t\t\t\t\t\t\t\t\t\n4\t文件管理\t#\tcat\t\t\tcat文件名\t\t\t\t\t 一屏查看文件内容\t\t\t\t\t\t\t\t\t\t\t\t\t\n5\t文件管理\t#\tmore\t\t\tmore文件名\t\t\t\t分页查看文件内容\t\t\t\t\t\t\t\t\t\t\t\t\t\n6\t文件管理\t#\tless\t\t\tless 文件名\t\t\t可控分页查看文件内容\t\t\t\t\t\t\t\t\t\t\t\t\t\n7\t文件管理\t#\tgrep\t\t\tgrep字符 文件名\t\t根据字符匹配来查看文件部分内容\t\t\t\t\t\t\t\t\t\t\t\t\t\n8\t文件管理\t#\tmv\t\t\tmv 路经/文件  /经/文件\t\t\t移动相对路经下的文件到绝对路经下\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t文件管理\t#\tmv\t\t\tmv 文件名 新名称\t\t\t\t\t 在当前目录下改名\t\t\t\t\t\t\t\t\t\t\t\t\t\n9\t文件管理\t#\tcp\t\t\tcp /路经/文件  ./\t\t\t\t\t 移动绝对路经下的文件到当前目录下\t\t\t\t\t\t\t\t\t\t\t\t\t\n10\t文件管理\t#\tfind\t\t\tfind 路经 -name “字符串”\t\t查找路经所在范围内满足字符串匹配的文件和目录\t\t\t\t\t\t\t\t\t\t\t\t\t\n11\t文件管理\t#\tln\t\t\tln 源文件 链接名\t\t\t\t\t\t 创建当前目录源文件的硬链接\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t  示例   ln /home/test /usr/test1\t\t\t\t   \t     在/usr下建立/home/test的硬链接\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n12\t文件管理\t#\tln\t\t\tln -s a b\t\t\t\t\t\t\t     创建当前目录下a的符号链接b\t\t\t\t\t\t\t\t\t\t\t\t\t\n13\t文件管理\t#\ttouch\t\t\ttouch file1 file2\t\t\t\t 创建两个空文件\t\t\t\t\t\t\t\t\t\t\t\t\t\n14\t磁盘管理\t#\tdf\t\t\tdf\t\t\t\t\t\t           \t 用于报告文件系统的总容量，使用量，剩余容量。\t\t\t\t\t\t\t\t\t\t\t\t\t\n15\t磁盘管理\t#\tdu\t\t\tdu -b /home\t\t\t\t\t\t\t   查看目前/HOME目录的容量(k)及子目录的容量(k)。\t\t\t\t\t\t\t\t\t\t\t\t\t\n16\t磁盘管理\t#\tfdisk\t\t\tfdisk -l\t\t\t\t\t\t\t   查看系统分区信息\t\t\t\t\t\t\t\t\t\t\t\t\t\n17\t磁盘管理\t#\tfdisk\t\t\tfdisk /dev/sdb\t\t\t\t\t 为一块新的SCSI硬盘进行分区\t\t\t\t\t\t\t\t\t\t\t\t\t\n18\t磁盘管理\t#\tmkfs.ext3\t\t\tMkfs.ext3 /dev/sdb1\t 为第一块SCSI硬盘的第一主分区格式化成ext3的文件系统\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t         # mkfs.ext2\t\t\tMkfs.ext2/dev/sdb2 \t格式化成ext2文件系统\t\t\t\t\t\t\t\t\t\t\t\t\t\n19\t磁盘管理\t#\tmount\t\t\tmount -t 文件系统类型 设备路经  访问路经\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t  磁盘管理\t#\t\t\t\t文件系统类型\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t        \t Iso9660\t\t\t\t\t\t\t光驱文件系统\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t          vfat\t\t\t\t\t\t\tFat文件系统(windows)\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t 挂载光驱\t#\tmount –t iso9660 /dev/cdrom /mnt/cdrom  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t 挂载FAT\t#\tmount –t vfat /dev/hda5 /mnt/cdrom \t\t\t挂第一个ide的第五个逻辑分区\t\t\t\t\t\t\t\t\t\t\n17\t磁盘管理\t#\tUmount /mnt/cdrom  \t\t\t\t\t\t\t\t\t\t卸载/mnt/cdrom为空\t\t\t\t\t\t\t\t\t\t\t\t\t\n18\t文件权限\t#\tchmod\t\t\t\n               chmod u+s file\t\t\t\t\t\t\t为file的属主加上特殊权限\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t   chmod g+r file\t\t\t\t\t\t\t为file的属组加上读权限\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t   chmod o+w file\t\t\t\t\t\t\t为file的其它用户加上写权限\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t   chmod a-x file\t\t\t\t\t\t\t为file的所有用户减去执行权限\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t             chmod 765 file  为file的属主设为完全权限，属组设成读写权，其它用户具有读和执心权限\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n19\t文件权限\t#\tchown\t\t\t\t\tchown root /home\t\t\t\t\t\t\t把/home的属主改成root用户\t\t\t\t\t\t\t\t\t\t\t\n20\t文件权限\t#\tchgrp\t\t\t\t\tchgrp root /home\t\t\t\t\t\t\t把/home的属组改成root组\t\t\t\t\t\t\t\t\t\t\t\n21\t打印管理\t#\tredhat-config-printer-tui\t\t\t\t\t\t\t\t\t\t进入安装打印机界面\t\t\t\t\t\t\t\t\t\t\t\n22\t打印管理\t#\tlp\t\t\t\t\t  lp –d hptr file\t\t\t\t\t\t\t  打印file到hptr的打印机上\t\t\t\t\t\t\t\t\t\t\t\n23\t打印管理\t#\tlpq\t\t\t\t\t  Lpq –P 打印机名\t\t\t\t\t\t\t   查看打印机的状态\t\t\t\t\t\t\t\t\t\t\t\n24\t打印管理\t#\tlprm\t\t\t\t  Lprm –P 打印机名 a\t\t\t\t\t\t 删除打印机内的打印作业\t\t\t\t\t\t\t\t\t\t\t\n25\t打印管理\t#\tdisable\t\t\t\tDisable –r “changing paper” HPtr \t\t禁用打印机并提示原因\t\t\t\t\t\t\n26\t打印管理\t#\tenable\t\t\t  Enable HPtr\t\t\t\t\t      \t重新启用被禁用的\t\t\t\t\t\t\t\t\t\t\t\t\n27\t用户管理\t#\tuseradd\t\t\t\tUseradd\t\t\t\t\t\t          创建一个新的用户\t\t\t\t\t\t\t\t\t\t\t\t\n28\t用户管理\t#\tgroupadd\t\t  Groupadd 组名\t\t\t\t\t\t   创建一个新的组\t\t\t\t\t\t\t\t\t\t\t\t\n29\t用户管理\t#\tpasswd\t\t\t\tPasswd 用户名\t\t\t\t\t\t    为用户创建密码\t\t\t\t\t\t\t\t\t\t\t\t\n30\t用户管理\t#\tPasswd -d\t\t  Passwd -d用户名\t\t\t\t\t\t删除用户密码也能登陆\t\t\t\t\t\t\t\t\t\t\t\t\n31\t用户管理\t#\tPasswd -l\t\t\tPasswd -l用户名\t\t\t\t\t\t锁定账号密码\t\t\t\t\t\t\t\t\t\t\t\t\n32\t用户管理\t#\tPasswd -u\t\t\tPasswd -u用户名\t\t\t\t\t\t解锁账号密码\t\t\t\t\t\t\t\t\t\t\t\t\n33\t用户管理\t#\tPasswd -S\t\t\tPasswd -S用户名\t\t\t\t\t\t查询账号密码\t\t\t\t\t\t\t\t\t\t\t\t\n34\t用户管理\t#\tUsermod -l\t\tUsermod -l 新用户名 老用户名\t\t\t为用户改名\t\t\t\t\t\t\t\t\n35\t用户管理\t#\tUsermod -L\t\tUsermod -L 要锁定用户名\t\t\t\t\t\t锁定用户登陆\t\t\t\t\t\t\t\t\n36\t用户管理\t#\tUsermod -U\t\tUsermod –U解锁用户名\t\t\t\t\t\t\t解锁用户登陆\t\t\t\t\t\t\t\t\n37\t用户管理\t#\tUsermod -u\t\tUsermod –u 501用户名\t\t\t\t\t\t\t改变用户UID\t\t\t\t\t\t\t\t\n38\t用户管理\t#\tUserdel\t\t\t\tUserdel–r 用户名\t\t\t\t\t\t\t\t\t删除用户一切\t\t\t\t\t\t\t\t\n39\t用户管理\t#\tGroupmod -n\t\tGroupmod –n新用户名 老用户名\t  \t为组改名\t\t\t\t\t\t\t\t\n40\t用户管理\t#\tGroupmod -g\t\tGroupmod –g 501 组名\t\t\t\t\t\t改变组GID\t\t\t\t\t\t\t\t\n41\t用户管理\t#\tgroupdel\t\t\tGroupdel组名    先应删它的用户\t\t删除组\t\t\t\t\t\t\t\t\n42\t用户管理\t#\tgpasswd -a\t\tgpasswd -a 用户名 组名\t\t\t\t\t\t增加用户到组\t\t\t\t\t\t\t\t\n43\t用户管理\t#\tId \t\t\t\t   id   用户名\t\t\t\t\t\t\t\t    \t\t查用户信息\t\t\t\t\t\t\t\t\n44\t软件管理\t#\trpm -qa\t\t  rpm –qa | less\t\t\t\t\t\t\t\t    查询已安装RPM\t\t\t\t\t\t\t\t\n45\t软件管理\t#\trpm –qa | grep ftp\t\t\t\t\t\t\t\t           查询指定RPM\t\t\t\t\t\t\t\t\n46\t软件管理\t#\trpm -q\t\t rpm -q 已安装的RPM包\t\t\t\t\t\t查是否安装\t\t\t\t\t\t\t\t\n47\t软件管理\t#\t\t rpm -q telnet-server\t\t\t\t\t\t\t\t 查看telnet服务器包\t\t\t\t\t\t\t\t\n48\t软件管理\t#\trpm -qi\t\t\t\t\trpm –qi 软件包名称\t\t\t\t\t 查看软件的描述信息\t\t\t\t\t\t\t\t\n49\t软件管理\t#\trpm -ql\t\t\t\t\trpm –ql软件包名称\t\t\t\t\t 查询软件包的文件列表\t\t\t\t\t\t\t\t\n50\t软件管理\t#\trpm -qf\t\t\t\t\trpm –qf软件包名称\t\t\t\t\t查询某个文件所属的软件包\t\t\t\t\t\t\t\t\n51\t软件管理\t#\trpm -qp\t\t\t\t\trpm –qp软件包全名\t\t\t\t\t查询未安装的软件包信息\t\t\t\t\t\t\t\t\n52\t软件管理\t#\trpm -e\t\t\t\t\trpm –e 软件包名称\t\t\t\t\t删除具体的软件包\t\t\t\t\t\t\t\t\n53\t软件管理\t#\trpm -U\t\t\t\t\trpm –Uvh软件包全名\t\t\t\t\t升级软件包并显示过程\t\t\t\t\t\t\t\t\n54\t软件管理\t#\trpm -ivh\t\t\t\t\trpm –ivh 软件包全名\t\t\t安装软件包并显示过程\t\t\t\t\t\t\t\t\n55\t软件管理\t#\trpm -V\t\t\t\t\trpm –V软件包名称\t\t\t\t\t\t验证软件包的大小，类型等\t\t\t\t\t\t\t\t\n56\t软件管理\t#\ttar \t\t\t\t\t-c 创建包 –x 释放包  -v 显示命令过程 –z 代表压缩包\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n57\t软件管理\t#\ttar -cf\t\t\t\t\ttar –cvf benet.tar /home/benet\t\t\t把/home/benet目录打包\t\t\t\t\t\t\t\t\n58\t软件管理\t#\ttar -czf\t\t\t\ttar –zcvf benet.tar.gz /mnt\t\t\t\t\t把目录打包并压缩\t\t\t\t\t\t\t\t\n59\t软件管理\t#\ttar –tf\t\t\t\t\ttar –tf benet.tar\t\t\t\t\t\t\t\t\t\t看非压缩包的文件列表\t\t\t\t\t\t\t\t\n60\t软件管理\t#\ttar –tzf\t\t\t\ttar –tf benet.tar.gz\t\t\t\t\t\t\t\t看压缩包的文件列表\t\t\t\t\t\t\t\t\n61\t软件管理\t#\ttar –xf\t\t\t\t\ttar –xf benet.tar\t\t\t\t\t\t\t\t\t\t非压缩包的文件恢复\t\t\t\t\t\t\t\t\n62\t软件管理\t#\ttar –zxvf\t\t\t\ttar –zxvf benet.tar.gz\t\t\t\t\t\t\t压缩包的文件解压恢复\t\t\t\t\t\t\t\t\n63\t软件管理\t#\ttar -jxvf\t\t\t\ttar –jxvf benet.tar.bz2\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n64\t软件管理\t#\tdiff\t\t\t\t\t  diff file1 file2 > 补丁名.patch\t\t\t为新旧文件生成补丁文件\t\t\t\t\t\t\t\t\n65\t软件管理\t#\tdiff\t\t\t\t  \tdiff file1 file2\t\t\t\t\t\t\t\t\t\t比较两个文件的区别\t\t\t\t\t\t\t\t\n66\t软件管理\t#\tPatch \t\t\t\t\tPatch \t\t\t\t\t\t\t\t\t\t          打补丁\t\t\t\t\t\t\t\t\n67\t软件管理\t#\t./configure  必须在已解压目录下\t\t\t\t\t\t\t\t\t\t\t编译前配置\t\t\t\t\t\t\t\t\n68\t软件管理\t#\tmake\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                  编译\t\t\t\t\t\t\t\t\n69\t软件管理\t#\tmake install\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t         安装编译好的源码包\t\t\t\t\t\t\t\t\n70\t启动管理\t#\treboot\t\t\t\t\t\t\tInit 6\t\t\t\t\t\t\t         \t重启LINUX系统\t\t\t\t\t\t\t\t\n71\t启动管理\t#\tHalt\t\tInit 0\t\t\t\t\t\tShutdown –h now\t\t\t\t\t关闭LINUX系统\t\t\t\t\t\t\t\t\n72\t启动管理\t#\trunlevel\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t           显示系统运行级\t\t\t\t\t\t\t\t\n73\t启动管理\t#\tInit [0123456] \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     改变系统运行级,7种\t\t\t\t\t\t\t\t\n74\t启动管理\t#\tChkconfig –-list [服务名称]\t\t\t\t\t\t\t\t\t\t\t\t查看服务的状态\t\t\t\t\t\t\t\t\n75\t启动管理\t#\tChkconfig –-level <运行级> <服务名> on|off|set \t\t设置服务的启动状态\t\t\t\t\t\t\n76\t启动管理\t#\tChkconfig <服务名> on|off|set\t\t\t\t\t\t\t\t\t\t设置非独立服务启状态\t\t\t\t\t\t\n77\t进程管理\t#\tTop动态\t\t\tPs-aux静态\t\t\t\t\t\t进程树pstree\t\t 查看系统进程\t\t\t\t\t\t\t\n78\t进程管理\t#\t程序名 &\t\t\t\t后台运行程序\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n79\t进程管理\t#\tfg\t\t\t\t\t\t把后台运行的进程调回前台\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n80\t进程管理\t#\tbg\t\t\t\t\t\t把前台运行进程调到后台\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n81\t进程管理\t#\trenice\t\t\t\t\t\tRenice +1 180 \t\t\t\t\t\t\t\t把180号进程的优先级加1\t\t\t\t\t\t\t\t\t\n82\t进程管理\t#\tkill\t\t\t\t\t\tKill PID \t\t\t\t\t\t\t\t        终止某个PID进程\t\t\t\t\t\t\t\t\t\n83\t进程管理\t#\tat\t\t\t\t\t\tat 5pm + 3 days\t\t\t\t\t\t\t\t   指定三天后下午5:00执行/bin/ls\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t/bin/ls\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n84\t进程管理\t#\tcrontab\t\t\t\t\t\tCrontab -e\t\t\t\t\t\t\t\t   用VI的形式来编辑自动周期性任务\t\t\t\t\t\t\t\t\t\n85\t进程管理\t#\tcrontab\t\t\t\t\t\tCrontab -l\t\t\t\t\t\t\t    \t查看自动周期性任务\t\t\t\t\t\t\t\t\t\n86\t进程管理\t#\tcrontab\t\t\t\t\t\tCrontab -r\t\t\t\t\t\t\t\t   删除自动周期性任务\t\t\t\t\t\t\t\t\t\n87\t进程管理\t#\tcrond\t\t\t\t\t\tService crond <start|stop|restart|status>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t马上启动自动周期性服务\t\t\t\t\t\tService crond <启动|停止|重启|状态>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t(下载源码就到源码网:www.codepub.com）\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t实现磁盘配额\t\t\t(注安装LINUX时建立/home分区） \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t目标：对用户zhao在/home目录上实现soft limit为5k,hard limit 为10k的磁盘配额 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t实现步骤： \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1. 修改包含/home的行，  #vi /etc/fstab， 改为：defaults,usrquota。也就是增加usrquota项。然后保存退出。 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t2、卸载/home目录                           #umount /home \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t3. 挂接/home目录                           #mount /home \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t4、增加用户zhao                            #useradd zhao  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t5、修改密码                                #passwd zhao  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t6、生成关于/home目录的quota信息             # quotacheck -cmug /home\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t                                          #quotacheck -vu /home  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t7、查看所有用户的信息                       #repquota -au \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t8、设置配额                                #edquota -u zhao \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t将soft 和hard 分别改为5和10 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t9、保存并退出                               #wq!  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t10、修改时间                                #edquota -t  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t11、                                       #wq! \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t12.开启/home上的磁盘配额功能                 #quotaon /home \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t13.查询配额                                 #quota -u zhao\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t14.验证配额                                 #su - zhao\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t                                           $touch myfile\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n```\n"
        },
        {
          "name": "linuxtool.md",
          "type": "blob",
          "size": 10.5,
          "content": "[ Linux基础知识 总结](https://blog.csdn.net/cyningsun/article/category/1269142)\n\n#  1、Clion的简单介绍\n    CLion是以IntelliJ为基础，专为开发C及C++所设计的跨平台IDE，可以在Windows、Linux及MacOS使用，这里我是在ubuntu 16.0.4基础上安装。\n## 2、下载 Linux版Clion的.tar.gz的压缩包 \n    wget https://download.jetbrains.8686c.com/cpp/CLion-2016.2.2.tar.gz\n## 3、解压CLion-2016.2.2.tar.gz到当前文件夹\n    tar -zxvf CLion-2016.2.2.tar.gz  \n## 4、运行clion.sh 安装脚本\n    cd clion-2016.2.2/bin/  \n    ./clion.sh  \n## 5、打开workspace\n    第一次打开点击ok\n    然后同意就行\n    CLion是收费的，可以选择试用30天，搭建了一个破解的服务器，\n    地址是：\n    http://bash.pub:1017 可能连接不上\n    选择自己喜欢的主题。\n    然后一直往下走，插件先不安装。\n    然后新建一个C项目\n## 6、激活码激活\n    获取  激活码  http://idea.lanyus.com/\n\n## Kdevelop 安装\n在终端输入下面指令安装Kdevelop(要连接网络)\n\n先安装cmake\n\n    sudo apt-get install cmake\n\n安装kdevelop\n    \n    sudo apt-get install kdevelop\n\n\n\n# 二、nfs服务器搭建\n    多台电脑之间创建共享文件夹\n## nfs服务器端配置\n### 1、安装nfs服务\n    1.1-安装Ubuntu nfs服务器端：\n        sudo apt-get install nfs-kernel-server\n        (在安装nsf-kernel-server的时候，也会安装nfs-commom。如果没有安装这个软件包，则要执行1.2中的命令了)\n    1.2-安装nfs的客户端：\n    sudo apt-get install nfs-common\n### 2、修改配置文件   \n    sudo vim /etc/exports\n\n    修改添加内容如下：\n    /home *(rw,sync,no_root_squash)\n    \n    更长 ：\n    /home/ewenwan/nfs *(insecure,rw,sync,nohide,no_root_squash,no_subtree_check)\n\n    /home   ：共享的目录\n    *       ：指定哪些用户可以访问\n                *  所有可以ping通该主机的用户\n                192.168.1.*  指定网段，在该网段中的用户可以挂载\n                192.168.1.12 只有该用户能挂载\n    (ro,sync,no_root_squash)：  权限\n            ro : 只读\n            rw : 读写\n            sync :  同步\n            no_root_squash: 不降低root用户的权限\n        其他选项man 5 exports 查看\n    前面那个目录是与nfs服务客户端共享的目录，\n    *代表允许所有的网段访问（也可以使用具体的IP）\n    rw：挂接此目录的客户端对该共享目录具有读写权限\n    sync：资料同步写入内存和硬盘\n    no_root_squash：客户机用root访问该共享文件夹时，不映射root用户。\n    root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户\n    no_subtree_check：不检查父目录的权限。\n\n    2.2-nfs是一个RPC程序，使用它前，需要映射好端口，通过rpcbind 设定：\n        sudo service rpcbind restart restart\n    2.3-重启nfs服务：\n        sudo service restartnfs-kernel-server restart\n\n        sudo /etc/init.d/nfs-kernel-server restart\n    2.4-测试运行以下命令来显示一下共享出来的目录：\n        showmount -e\n\n    !!!需要修改 远程挂载目录 /home/ewenwan/nfs的权限   chmod 777  /home/ewenwan/nfs   !!!!!!!\n    \n    ## 客户端访问配置\n\n\n### window  安装 nfs 客户端\n    win10 控制面板 程序和功能 启用或关闭Windows功能 勾选NFS服务 确定后系统进行自动安装\n    打开 cmd \n    \n    mount \\\\\\10.65.223.171\\目录 x:\n    \n    挂载远程主机的 目录 到 本机上 的x盘\n\n    挂载 umount x:\n### 客户端 无权 限访问问题\n[参考解决](https://jingyan.baidu.com/article/c910274bfd6800cd361d2df3.html)\n\n    mount查看 客户端设置的访问权限\n    打开注册表编辑器 regedit \n    HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ClientForNFS\\CurrentVersion\\Default\n    下新增两项 DWORD(32位)值D \n    AnonymousUid = 0\n    AnonymousGid = 0\n\n## linux 系统之间挂载共享目录\n\n在工作主机下:\n  \n  mount -t nfs 目标机ip:目标机目标目录 工作机目录 -o nolock\n  \n  例如:\n  \n     mount -t nfs 10.1.110.123:/home/ws /home/wanyouwen -o nolock\n     \n     就可以在 当前主机的 /home/wanyouwen 目录访问 远程主机10.1.110.123  下的目录 /home/ws\n    \n\n\n\n### winscp 访问 远程服务器文件 ftp协议\n[百度参考](https://jingyan.baidu.com/article/d621e8da79ee562865913fce.html)\n\n### 远程 命令行登陆服务器 shell\n[Xmanager 服务器远程控制程序 ](https://www.netsarang.com/products/xme_overview.html)\n\n[putty ssh远程登录 命令行shell](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)\n \n# 三、 linux配置\n[ubuntu大法-快速翻墙装驱动配置开发环境](https://github.com/DragonFive/myblog/blob/master/source/_posts/nvidiaDriverInstall.md)\n\n\nUbuntu14.04升级CMake：\n\n    Ubuntu14.04 默认CMake版本是2.8.X 当我们需要更高级版本的时候就需要升级CMake。具体步骤如下： \n        通过PPA安装：\n\n    sudo add-apt-repository ppa:george-edison55/cmake-3.x\n    sudo apt-get update\n    sudo apt-get upgrade \n    cmake --version1234\n\n    编译安装步骤如下：\n\n\n\n    sudo apt-get install build-essential //如果系统已安装build-essential则不需要执行此步骤\n    wget http://www.cmake.org/files/v3.2/cmake-3.2.2.tar.gz\n    tar xf cmake-3.2.2.tar.gz\n    cd cmake-3.2.2\n    ./configure\n    make\n\n\n# 四、Linux环境编程\n[博客专栏](https://blog.csdn.net/column/details/tennysonsky-linux.html)\n## ubuntu下添加新用户、解决远程登录问题\n###  添加新用户\n    添加新用户\n\n    sudo useradd ewenwan -d /home/ewenwan -m\n    # 第一个ewenwan，指用户名\n    # -d /home/ewenwan 指定用户登录系统时的主目录，宿主目录\n    # -m 如果/home/ewenwan 路径不存在，自动创建\n    \n    查看新建的用户\n    cat /etc/passwd | grep ewenwan\n    \n    给用户设置密码\n    sudo passwd ewenwan\n    \n    新用户增加sudo权限\n    修改/etc/sudoers权限\n    sudo chmod u+w /etc/sudoers\n    #增加写权限\n    \n    通过编辑/etc/sudoers文件 也可以实现\n    sudo vi /etc/sudoers\n![](https://img-blog.csdn.net/20180104160715584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGVubnlzb25za3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n    \n    root ALL=(ALL:ALL) ALL\n    ewenwan ALL=(ALL:ALL) ALL\n    \n    \n    恢复原来/etc/sudoers权限\n    sudo chmod u-w /etc/sudoers\n    \n### 解决远程登录问题\n    \n    修改/etc/passwd文件\n    sudo vim /etc/passwd\n    找到新增的用户ewenwan，添加如下内容： \n    \n    ewenwan:x:1001:1001::/home/ewenwan:/bin/bash\n    \n# 命令行 翻译工具\n    安装 sudo pip install dict-cli\n    使用 dict test \n\n# linux下 插件按caj\n    \n    安装 火狐扩展插件 Greasemonkey https://addons.mozilla.org/zh-CN/firefox/addon/greasemonkey/\n     Greasemonkey 安装脚本 cnki-pdf-special.user.js\n    \n    http://kns.cnki.net/KCMS/****  >>>  http://www.cnki.net/KCMS/****  就会出现pdf版本\n\n\n# linux下图像工具\n    1. 截图工具 gnome-screenshot  \n       PrintScreen键：整个界面  \n       Alt+PrintScreen键:当前窗口 \n       Shift+PrintScreen键：区域截图\n       打开软件：下拉菜单截图，延时截图\n       \n    2. Linux系统下的Photoshop 位图处理软件GIMP\n       sudo add-apt-repository ppa:otto-kesselgulasch/gimp\n       sudo apt-get update\n       sudo apt-get install gimp\n       \n       卸载： \n       sudoapt-get install ppa-purge\n       sudo ppa-purge ppa:otto-kesselgulasch/gimp\n     \n     3. 矢量图绘制软件Inkscape  与Illustrator、Freehand、CorelDraw、Xara X 等其他软件相似\n       在矢量图绘制软件中，画框就是画框，画完框后可以改变这个框的边线颜色及样式，\n       可以改变它的填充颜色及样式，可以拖动它的位置，可以改变它的大小，但是在位图处理软件中，\n       就得换一种思考模式，在位图处理软件中，要画框只能先建立一个矩形的选区，然后对这个选区进行描边和填充，\n       还可以对选取进行羽化，这样可以得到一个模模糊糊的框框，一旦描边和填充结束，则这个框框就再不能更改。\n       所以Inkscape适合做添加框框、文字这样的工作，\n       而GIMP适合做对选区羽化、非规则区域切图、添加阴影和发光这样的工作。\n       \n       sudo add-apt-repository ppa:inkscape.dev/stable\n       sudo apt update\n       sudo apt-get install inkscape\n     \n     4. 示意图绘制软件Dia\n        wget wget http://sourceforge.net/projects/dia-installer/files/dia/0.97.2/dia-0.97.2.tar.xz/download\n\n        tar xvf dia-0.97.2.tar.xz\n        cd dia-0.97.2\n        ./configure --enable-gnome\n\n        Configuration:\n            Source code location:    .\n            Compiler:        gcc\n            Gnome support:                yes\n            Python support:                no\n            Libart support (PNG export):        yes\n            Cairo support (PNG, PDF, print):    yes\n            Dia Python bindings with SWIG        no\n            WMF plug-in with libEMF:                no\n            html doc:                               no\n            pdf and ps doc:                         no\n\n        Now type make to build dia...\n        # make && make install\n        直接在命令行输入\n        #dia\n        打开画图软件dia\n        \n      5. 建模工具Umbrello\n        mkdir -p $HOME/src\n        cd $HOME/src\n        git clone git://anongit.kde.org/umbrello  \n        cd umbrello\n        mkdir build\n        cd build\n\n\n# linux 命令行查看 十六进制\n    https://github.com/sharkdp/hexyl\n    \n    安装: \n    wget \"https://github.com/sharkdp/hexyl/releases/download/v0.4.0/hexyl_0.4.0_amd64.deb\"\n    sudo dpkg -i hexyl_0.4.0_amd64.deb\n\n# linux 命令行 shell 命令 解析 json文件 jq工具\n\njq 是一个轻量级的json处理命令。可以对json数据进行分片、过滤、映射和转换\n\n\ncat ./json.txt\n```json\n[{\"name\": \"zhangsan\",\"age\": 21,\"courses\": [\"语文\", \"数学\", \"英语\"]},{\"name\": \"lisi\",\"age\": 22,\"courses\": [\"物理\", \"化学\", \"生物\"]}]\n\n```\n\ncat ./json.txt | jq .\n```json\n[\n  {\n    \"name\": \"zhangsan\",\n    \"age\": 21,\n    \"courses\": [\n      \"语文\",\n      \"数学\",\n      \"英语\"\n    ]\n  },\n  {\n    \"name\": \"lisi\",\n    \"age\": 22,\n    \"courses\": [\n      \"物理\",\n      \"化学\",\n      \"生物\"\n    ]\n  }\n]\n```\n\n取json中的某个字段\n```json\n# 取json中第一个分片 中的name\n\ncat ./json.txt | jq '.[0].name'\n\"zhangsan\"\n# 取courses 中第一个下标的课程\ncat ./json.txt | jq '.[].courses[0]'\n\"语文\"\n\"物理\"\n```\n\n"
        },
        {
          "name": "linux小命令.md",
          "type": "blob",
          "size": 17.0283203125,
          "content": "# 0、查询文件夹大小\r\n    du -h 所有子文件大小\r\n    du -h -d 1  当前1级目录大小\r\n    df -h 查看各个盘使用比例情况\r\n\r\n# 0.1 cpu使用信息 \r\n\r\n> a. top 命令\r\n     \r\n        Cpu(s): 0.3% us    用户空间占用CPU百分比\r\n        1.0% sy            内核空间占用CPU百分比\r\n        0.0% ni            用户进程空间内改变过优先级的进程占用CPU百分比\r\n        98.7% id    空闲CPU百分比\r\n        0.0% wa            等待输入输出的CPU时间百分比\r\n        0.0% hi    \r\n        0.0% si \r\n        \r\n        最后两行为内存信息。内容如下：\r\n        Mem: 191272k total    物理内存总量\r\n        173656k used          使用的物理内存总量\r\n        17616k free           空闲内存总量\r\n        22052k buffers        用作内核缓存的内存量\r\n        Swap: 192772k total   交换区总量\r\n        0k used               使用的交换区总量\r\n        192772k free          空闲交换区总量\r\n        123988k cached        缓冲的交换区总量。\r\n        \r\n        进程的详细信息，各列的含义。\r\n        列名    含义\r\n        PID     进程id\r\n        PPID    父进程id\r\n        RUSER   Real user name\r\n        UID     进程所有者的用户id\r\n        USER    进程所有者的用户名\r\n        GROUP   进程所有者的组名\r\n        TTY     启动进程的终端名。不是从终端启动的进程则显示为 ?\r\n        PR      优先级\r\n        NI      nice值。负值表示高优先级，正值表示低优先级\r\n        P       最后使用的CPU，仅在多CPU环境下有意义\r\n        %CPU    上次更新到现在的CPU时间占用百分比\r\n        TIME    进程使用的CPU时间总计，单位秒\r\n        TIME+   进程使用的CPU时间总计，单位1/100秒\r\n        %MEM    进程使用的物理内存百分比\r\n        VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\r\n        SWAP    进程使用的虚拟内存中，被换出的大小，单位kb。\r\n        RES     进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\r\n        CODE    可执行代码占用的物理内存大小，单位kb\r\n        DATA    可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb\r\n        SHR     共享内存大小，单位kb\r\n        nFLT    页面错误次数\r\n        nDRT    最后一次写入到现在，被修改过的页面数。\r\n        S       进程状态。\r\n                    D=不可中断的睡眠状态\r\n                    R=运行\r\n                    S=睡眠\r\n                    T=跟踪/停止\r\n                    Z=僵尸进程\r\n        COMMAND  命令名/命令行\r\n        WCHAN    若该进程在睡眠，则显示睡眠中的系统函数名\r\n        Flags    任务标志，参考 sched.h\r\n\r\n        top命令中load average显示的是最近1分钟、5分钟和15分钟的系统平均负载。\r\n        1核，标准负载1，超过1，表示CPU超负荷，需要优化；\r\n        实际中 系统负载均值应不高于 cpu 核心数\r\n        \r\n> b.vmstat 查看系统负载\r\n\r\n        b.1 procs\r\n            r 列表示运行和等待cpu时间片的进程数，如果长期大于1，说明cpu不足，需要增加cpu。\r\n            b 列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等。 \r\n        b.2 cpu 表示cpu的使用状态\r\n            us 列显示了用户方式下所花费 CPU 时间的百分比。us的值比较高时，\r\n               说明用户进程消耗的cpu时间多，但是如果长期大于50%，需要考虑优化用户的程序。\r\n            sy 列显示了内核进程所花费的cpu时间的百分比。这里us + sy的参考值为80%，\r\n               如果us+sy 大于 80%说明可能存在CPU不足。\r\n            wa 列显示了IO等待所占用的CPU时间的百分比。这里wa的参考值为30%，\r\n               如果wa超过30%，说明IO等待严重，这可能是磁盘大量随机访问造成的，\r\n               也可能磁盘或者磁盘访问控制器的带宽瓶颈造成的(主要是块操作)。\r\n            id 列显示了cpu处在空闲状态的时间百分比\r\n     \r\n        b.3 system 显示采集间隔内发生的中断数\r\n            in 列表示在某一时间间隔中观测到的每秒设备中断数。\r\n            cs 列表示每秒产生的上下文切换次数，\r\n               如当 cs 比磁盘 I/O 和网络信息包速率高得多，都应进行进一步调查。\r\n\r\n        b.4 memory\r\n            swpd 切换到内存交换区的内存数量(k表示)。如果swpd的值不为0，\r\n                 或者比较大，比如超过了100m，只要si、so的值长期为0，系统性能还是正常\r\n            free 当前的空闲页面列表中内存数量(k表示)\r\n            buff 作为buffer cache的内存数量，一般对块设备的读写才需要缓冲。\r\n            cache: 作为page cache的内存数量，一般作为文件系统的cache，\r\n                   如果cache较大，说明用到cache的文件较多，如果此时IO中bi比较小，说明文件系统效率比较好。\r\n\r\n        b.5 swap\r\n            si 由内存进入内存交换区数量。\r\n            so由内存交换区进入内存数量。\r\n            \r\n> c. iostat 查看磁盘负载\r\n\r\n        iostat -x 1 10\r\n        每隔2秒统计一次磁盘IO信息，\r\n        直到按Ctrl+C终止程序，\r\n        -d 选项表示统计磁盘信息，\r\n        -k 表示以每秒KB的形式显示，\r\n        -t 要求打印出时间信息，\r\n        2 表示每隔 2 秒输出一次。\r\n        第一次输出的磁盘IO负载状况提供了关于自从系统启动以来的统计信息。\r\n        随后的每一次输出则是每个间隔之间的平均IO负载状况。\r\n        \r\n        rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s\r\n        wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s\r\n        r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s\r\n        w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s\r\n        rsec/s: 每秒读扇区数。即 delta(rsect)/s\r\n        wsec/s: 每秒写扇区数。即 delta(wsect)/s\r\n        rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)\r\n        wkB/s: 每秒写K字节数。是 wsect/s 的一半。(需要计算)\r\n        avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)\r\n        avgqu-sz: 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。\r\n        await: 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)\r\n        svctm: 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)\r\n        %util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)\r\n\r\n        如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。\r\n        \r\n        idle小于70% IO压力就较大了,一般读取速度有较多的wait.\r\n\r\n        同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)\r\n\r\n> d. 获取核心的处理器\r\n\r\n        在 Linux 下，可以使用\r\n\r\n          cat /proc/cpuinfo\r\n\r\n        获取你系统上的每个处理器的信息。如果你只想得到数字，那么就使用下面的命令：\r\n\r\n          grep 'model name' /proc/cpuinfo | wc -l\r\n\r\n# 1、输出字符 banner   全#号\r\n    sudo apt-get install sysvbanner\r\n\r\n    banner linux\r\n    printerbanner -w 50 AB\r\n    类似的命令 toilet    #号 \"号 字母m\r\n    sudo apt-get install toilet\r\n\r\n    figlet     -号\r\n    sudo apt-get install figlet\r\n\r\n\r\n# 2、一双眼睛\r\n    xeyes\r\n    sudo apt-get install x11-apps\r\n\r\n\r\n\r\n# 3、文字雨\r\n    cmatrix\r\n    sudo apt-get install cmatrix\r\n\r\n\r\n# 4、文字火炉\r\n    aafire\r\n    sudo ape-get install libaa-bin\r\n\r\n\r\n\r\n# 5、压缩解压\r\n    zip：\r\n    打包 ：zip something.zip something （目录请加 -r 参数）\r\n    压缩 oRB_SLAM2文件夹 到 orb_slam.zip\r\n    zip -q -r orb_slam.zip oRB_SLAM2/\r\n\r\n    解包：unzip something.zip\r\n    指定路径：-d 参数\r\n\r\n\r\n    tar：\r\n    打包：tar -zcvf something.tar something\r\n    解包：tar -zxvf something.tar\r\n\r\n    指定路径：-C \r\n\r\n    rar:\r\n    # rar a all *.jpg\r\n    这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar 扩展名将自动附加到包名后。\r\n    # sudo unrar e all.rar all_file -y\r\n    这条命令是将all.rar中的所有文件 解压出来到all_file下  \r\n    # sudo unrar x all.rar all_file -y\r\n    按原文件夹文件层级 关系解压文件到 all_file下 \r\n\r\n    unrar分卷解压 ： 假设第一个分卷的文件名CTOHome.r00，所有分卷都在同一个目录。\r\n    那么就直接 unrar  x -o- -y CTOHome.r00      /home/www.CTOHome.com / \r\n\r\n    各种压缩包的压缩和解压方法\r\n## .tar.gz和.tgz\r\n\r\n    解压：tar zxvf FileName.tar.gz\r\n\r\n    压缩：tar zcvf FileName.tar.gz DirName\r\n\r\n    PS:tar命令对于长选项和短选项的顺序有要求，例如，不覆盖已有文件的选项--skip-old-files:\r\n\r\n    tar --skip-old-files -zxvf FileName.tar.gz #正确\r\n\r\n    tar -zxvf --skip-old-files FileName.tar.gz #错误\r\n## .tar\r\n\r\n    解包：tar xvf FileName.tar\r\n\r\n    打包：tar cvf FileName.tar DirName\r\n\r\n    （注：tar是打包，不是压缩！）\r\n## .gz\r\n\r\n    解压1：gunzip FileName.gz\r\n\r\n    解压2：gzip -d FileName.gz\r\n\r\n    压缩：gzip FileName\r\n## .bz2\r\n\r\n    解压1：bzip2 -d FileName.bz2\r\n\r\n    解压2：bunzip2 FileName.bz2\r\n\r\n    压缩： bzip2 -z FileName\r\n## .tar.bz2\r\n\r\n    解压：tar jxvf FileName.tar.bz2\r\n\r\n    压缩：tar jcvf FileName.tar.bz2 DirName\r\n## .bz\r\n\r\n    解压1：bzip2 -d FileName.bz\r\n\r\n    解压2：bunzip2 FileName.bz\r\n## .tar.bz\r\n\r\n    解压：tar jxvf FileName.tar.bz\r\n    .Z\r\n\r\n    解压：uncompress FileName.Z\r\n\r\n    压缩：compress FileName\r\n## .tar.z\r\n\r\n    解压：tar Zxvf FileName.tar.z\r\n\r\n    压缩：tar Zcvf FileName.tar.z DirName\r\n## .zip\r\n\r\n    解压：unzip FileName.zip\r\n\r\n    压缩：zip FileName.zip DirName\r\n## .rar\r\n\r\n    解压：rar x FileName.rar\r\n\r\n    压缩：rar a FileName.rar DirName\r\n##  .lha\r\n\r\n    解压：lha -e FileName.lha\r\n\r\n    压缩：lha -a FileName.lha FileName\r\n##  .rpm\r\n\r\n    解包：rpm2cpio FileName.rpm | cpio -div\r\n##  .deb\r\n\r\n    解包：ar p FileName.deb data.Tar.gz | Tar zxf -\r\n## 万能脚本\r\n\r\n    解压：sEx x FileName.*\r\n\r\n    压缩：sEx a FileName.* FileName\r\n\r\n    sEx只是调用相关程序，本身并无压缩、解压功能，请注意！\r\n\r\n    sEx请到： http://sourceforge.net/projects/sex下载！\r\n\r\n# 6、动物文字\r\n    cowsay\r\n\r\n    sudo apt-get install cowsay\r\n\r\n    cowsay hello shiyanlou   默认牛\r\n    cowsay -l 打印支持的所有动物\r\n    cowsay -f elephant hello shiyanlou\r\n\r\n# 7、搜狗拼音输入法无法输入中文\r\n    cd ~/.config\r\n    rm -rf SogouPY SogouPY.users sogou-qimpanel\r\n    killall fcitx\r\n    fcitx\r\n    install\r\n    sudo add-apt-repository ppa:fcitx-team/nightly\r\n    sudo apt-get install fcitx sogoupinyin \r\n    sudo apt-get remove fcitx sogoupinyin\r\n\r\n# 7.2 fcitx框架下谷歌输入法的安装\r\n    sudo apt-get install fcitx fcitx-googlepinyin im-config\r\n    im-config\r\n    点击OK按钮，再点击Yes按钮，将fcitx设为默认的输入法框架，最后点击OK。\r\n    然后重启系统。\r\n    点击fcitx的键盘图标，选择text entry  settings\r\n    在打开的窗口中点击+号\r\n    然后在文本框中输入pinyin查找谷歌拼音输入法，将其添加到输入法列表中。\r\n    如果查找不到，重启系统后再试一次。\r\n    接下来你就能使用谷歌拼音输入法了。\r\n    \r\n# 8、linux 设置默认声卡\r\n    终端里打alsamixer 按 f6 会出现声卡列表 \r\n    一般来说，usb 声卡总是第二位的，声卡编号是1(默认声卡是0) \r\n    在 $HOME 下建立 .asoundrc 里面输入 \r\n    defaults.ctl.card 1 defaults.pcm.card 1 \r\n    最后的1是声卡编号 然后重启一下alsa就把1号声卡(usb声卡)设置成默认声卡了。 \r\n\r\n\r\n    //////////　　可能不行\r\n    pcm.!default {\r\n        type asym\r\n        playback.pcm {\r\n            type plug\r\n            slave.pcm \"hw:0,0\"\r\n        }\r\n        capture.pcm {\r\n            type plug\r\n            slave.pcm \"hw:1,0\"\r\n        }\r\n    }\r\n\r\n# Ubuntu14.04使用su切换到root时提示:Authentication failure\r\n    这是因为Ubuntu系统默认没有激活root用户，因此需手动激活,操作如下:\r\n    sudo passwd\r\n    \r\n    输入密码\r\n    确认密码\r\n    之后就可以了\r\n# linux 连接不到源的问题\r\n[参考解决](http://www.linuxdiyf.com/linux/23934.html)\r\n\r\n    在是还用atp-get的时候出现了apt-get: Could not resolve 'archive.ubuntu.com'的错误，\r\n    一开始按照网上的说法，修改apt-get的源网址，\r\n    添加了国内的一些网址资源以后还是不行，比如添加了以下的一些资源网址：\r\n\r\n    deb http://mirrors.ustc.edu.cn/ubuntu/ precise-updates main restricted\r\n    deb-src http://mirrors.ustc.edu.cn/ubuntu/ precise-updates main restricted\r\n    deb http://mirrors.ustc.edu.cn/ubuntu/ precise universe\r\n    deb-src http://mirrors.ustc.edu.cn/ubuntu/ precise universe\r\n\r\n    至于怎么修改该文件，可以通过通过SSH Secure File Transfer\r\n    软件打开目录/etc/apt下面的source.list文件通过记事本进行编辑，\r\n    也就是将上面的内容添加到文件的后面。\r\n\r\n    但是添加完以上网址后，还是出现Could not resolve 'archive.ubuntu.com'的错误，\r\n    这种原因其实是因为还缺少一个步骤，就是讲添加的这几个网址的网址和IP进行映射，\r\n    修改/etc/目录下的host文件，用记事本打开\r\n\r\n    添加链接不上的地址 直接的ip地址\r\n    10.1.14.235     mirrors.hikvision.com.cn\r\n    \r\n#  vmware虚拟机设置共享文件夹\r\n    在VMware 工具栏选择 虚拟机（M），下拉菜单中有安装VMware Tools 选项，\r\n    我刚开始选的时候一直出现下述问题\r\n    “客户机操作系统已将 CD-ROM 门锁定，并且可能正在使用 CD-ROM，\r\n    这可能会导致客户机无法识别介质的更改。\r\n    如果可能，请在断开连接之前从客户机内部弹出 CD-ROM。”\r\n\r\n    主要是 CD-ROM 在之前安装时选择的是 ununtu的安装文件\r\n    发现是因为客户机（即虚拟机）的驱动是指向安装Ubuntu的iso的\r\n\r\n    现在安装好了，可以更改回来了\r\n    先关闭虚拟机，在虚拟机 设置 硬件 中CD/DVD选择自动检测\r\n\r\n    重新打开虚拟机，此时装载即可成功\r\n    创建 挂载点\r\n    mkdir /mnt/cdrom  \r\n    挂载 CD/DVD\r\n    mount /dev/cdrom /mnt/cdrom  \r\n    此时可以在 /mnt/cdrom 找到 VMwareTools 的安装文件\r\n\r\n    解压\r\n    tar -zxvf /mnt/cdrom/VMwareTools-x.x.x-yyyy.tar.gz \r\n    生成 vmware-tools-distrib  \r\n    进入安装\r\n    cd /mnt/vmware-tools-distrib  \r\n    sudo ./vmware-install.pl -y\r\n\r\n    设置共享文件夹地址\r\n    虚拟机 -> 设置-> 选项 -> 共享文件夹 -> 总是启用 添加主机共享文件夹路径\r\n\r\n    在虚拟机文件夹下 /mnt/hgfs  可以查看到 共享文件夹\r\n\r\n\r\n# apt-get无法安装 \r\n    解决方法：强制解锁\r\n    sudo rm /var/cache/apt/archives/lock3\r\n    sudo rm /var/cache/apt/archives/lock \r\n    sudo rm /var/lib/dpkg/lock\r\n    \r\n    \r\n# 怎么防止远程Linux自动断开SSH连接\r\n    下面的操作是在本地ssh客户端上，不是远程主机。\r\n\r\n    编辑SSH配置文件：\r\n    $ vim ~/.ssh/config    # 当前登陆用户生效\r\n\r\n    添加：\r\n    Host *\r\n     ServerAliveInterval 30\r\n\r\n    *号代表所有主机，你可以指定某个主机，如：\r\n    Host server1\r\n     ServerAliveInterval 30\r\n\r\n    ServerAliveInterval 30\r\n    表示ssh客户端每隔30秒给远程主机发送一个no-op包，\r\n    no-op是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。\r\n\r\n    为了使所有用户生效，你可以在/etc/ssh/ssh_config全局配置文件添加如下一行：\r\n    ServerAliveInterval 30\r\n\r\n    还可以在连接时使用选项：\r\n    $ ssh -o ServerAliveInterval=30 user@remote-ssh-server-ip\r\n\r\n\r\n# thefuck: 自动纠正前一个命令的拼写错误\r\n\r\n    https://github.com/nvbn/thefuck\r\n    \r\n    thefuck是一个使用Python编写的开源小工具，它可以自动纠正前一个命令的拼写错误。\r\n    这个工具非常酷，尤其对于常常使用命令行的童鞋。\r\n    \r\n    安装\r\n        $ sudo apt install python3-dev python3-pip\r\n        $ sudo -H pip3 install thefuck\r\n\r\n    创建一个别名alias，首先编辑bashrc配置文件：\r\n    $ vim ~/.bashrc\r\n    \r\n    在文件尾加入一行：\r\n    eval \"$(thefuck --alias fuck)\"\r\n    \r\n    使生效：\r\n    $ source ~/.bashrc\r\n    \r\n    sdo vim /etc/passwd\r\n    >>> sdo comand not found\r\n    >>> fuck\r\n    sudo vim /etc/passwd[enter or ctrl c]\r\n    直接回车执行纠正过的命令。\r\n    \r\nhttps://github.com/nvbn/thefuck/blob/master/README.md\r\n\r\n\r\n\r\n\r\n"
        },
        {
          "name": "makdown文法.md",
          "type": "blob",
          "size": 7.1357421875,
          "content": "@[TOC](这里写自定义目录标题)\n\n# 欢迎使用Markdown编辑器\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n## 新的改变\n\n我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：\n 1. **全新的界面设计** ，将会带来全新的写作体验；\n 2. 在创作中心设置你喜爱的代码高亮样式，Markdown **将代码片显示选择的高亮样式** 进行展示；\n 3. 增加了 **图片拖拽** 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；\n 4. 全新的 **KaTeX数学公式** 语法；\n 5. 增加了支持**甘特图的mermaid语法[^1]** 功能；\n 6. 增加了 **多屏幕编辑** Markdown文章功能；\n 7. 增加了 **焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置** 等功能，功能按钮位于编辑区域与预览区域中间；\n 8. 增加了 **检查列表** 功能。\n [^1]: [mermaid语法说明](https://mermaidjs.github.io/)\n\n## 功能快捷键\n\n撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd>\n重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd>\n加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd>\n斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd>\n标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd>\n无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd>\n有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd>\n检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>\n插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd>\n插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>\n插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd>\n查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd>\n替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd>\n\n## 合理的创建标题，有助于目录的生成\n\n直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。\n输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。\n以此类推，我们支持6级标题。有助于使用`TOC`语法后生成一个完美的目录。\n\n## 如何改变文本的样式\n\n*强调文本* _强调文本_\n\n**加粗文本** __加粗文本__\n\n==标记文本==\n\n~~删除文本~~\n\n> 引用文本\n\nH~2~O is是液体。\n\n2^10^ 运算结果是 1024.\n\n## 插入链接与图片\n\n链接: [link](https://www.csdn.net/).\n\n图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw)\n\n带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30)\n\n居中的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center)\n\n居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30)\n\n当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。\n\n## 如何插入一段漂亮的代码片\n\n去[博客设置](https://mp.csdn.net/console/configBlog)页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 `代码片`.\n```javascript\n// An highlighted block\nvar foo = 'bar';\n```\n\n## 生成一个适合你的列表\n\n- 项目\n  - 项目\n    - 项目\n\n1. 项目1\n2. 项目2\n3. 项目3\n\n- [ ] 计划任务\n- [x] 完成任务\n\n## 创建一个表格\n一个简单的表格是这么创建的：\n项目     | Value\n-------- | -----\n电脑  | $1600\n手机  | $12\n导管  | $1\n\n### 设定内容居中、居左、居右\n使用`:---------:`居中\n使用`:----------`居左\n使用`----------:`居右\n| 第一列       | 第二列         | 第三列        |\n|:-----------:| -------------:|:-------------|\n| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |\n\n### SmartyPants\nSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\n|    TYPE   |ASCII                          |HTML\n|----------------|-------------------------------|-----------------------------|\n|Single backticks|`'Isn't this fun?'`            |'Isn't this fun?'            |\n|Quotes          |`\"Isn't this fun?\"`            |\"Isn't this fun?\"            |\n|Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\n\n## 创建一个自定义列表\nMarkdown\n:  Text-to-HTML conversion tool\n\nAuthors\n:  John\n:  Luke\n\n## 如何创建一个注脚\n\n一个具有注脚的文本。[^2]\n\n[^2]: 注脚的解释\n\n##  注释也是必不可少的\n\nMarkdown将文本转换为 HTML。\n\n*[HTML]:   超文本标记语言\n\n## KaTeX数学公式\n\n您可以使用渲染LaTeX数学表达式 [KaTeX](https://khan.github.io/KaTeX/):\n\nGamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall\nn\\in\\mathbb N$ 是通过欧拉积分\n\n$$\n\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\n$$\n\n> 你可以找到更多关于的信息 **LaTeX** 数学表达式[here][1].\n\n## 新的甘特图功能，丰富你的文章\n\n```mermaid\ngantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n```\n- 关于 **甘特图** 语法，参考 [这儿][2],\n\n## UML 图表\n\n可以使用UML图表进行渲染。 [Mermaid](https://mermaidjs.github.io/). 例如下面产生的一个序列图：\n\n```mermaid\nsequenceDiagram\n张三 ->> 李四: 你好！李四, 最近怎么样?\n李四-->>王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了<br/>不适合放在一行.\n\n李四-->>张三: 打量着王五...\n张三->>王五: 很好... 王五, 你怎么样?\n```\n\n这将产生一个流程图。:\n\n```mermaid\ngraph LR\nA[长方形] -- 链接 --> B((圆))\nA --> C(圆角长方形)\nB --> D{菱形}\nC --> D\n```\n\n- 关于 **Mermaid** 语法，参考 [这儿][3],\n\n## FLowchart流程图\n\n我们依旧会支持flowchart的流程图：\n```mermaid\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n- 关于 **Flowchart流程图** 语法，参考 [这儿][4].\n\n## 导出与导入\n\n###  导出\n如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 **文章导出** ，生成一个.md文件或者.html文件进行本地保存。\n\n### 导入\n如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，\n继续你的创作。\n\n [1]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n [2]: https://mermaidjs.github.io/\n [3]: https://mermaidjs.github.io/\n [4]: http://adrai.github.io/flowchart.js/\n \n"
        },
        {
          "name": "makefile.md",
          "type": "blob",
          "size": 0.0966796875,
          "content": "# Makefile 使用总结 \n\n[Makefile 使用总结 ](https://www.cnblogs.com/wang_yb/p/3990952.html)\n"
        },
        {
          "name": "makefile",
          "type": "tree",
          "content": null
        },
        {
          "name": "nc",
          "type": "tree",
          "content": null
        },
        {
          "name": "openGL",
          "type": "tree",
          "content": null
        },
        {
          "name": "opencl",
          "type": "tree",
          "content": null
        },
        {
          "name": "openmp",
          "type": "tree",
          "content": null
        },
        {
          "name": "other",
          "type": "tree",
          "content": null
        },
        {
          "name": "pdf",
          "type": "tree",
          "content": null
        },
        {
          "name": "person",
          "type": "tree",
          "content": null
        },
        {
          "name": "quantum_computing",
          "type": "tree",
          "content": null
        },
        {
          "name": "shell",
          "type": "tree",
          "content": null
        },
        {
          "name": "software",
          "type": "tree",
          "content": null
        },
        {
          "name": "tree_math_func.c",
          "type": "blob",
          "size": 3.0458984375,
          "content": "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define TRUE 1\r\n#define FALSE 0\r\n#define OVERFLOW -2\r\n#define OK 1\r\n#define ERROR 0\r\n/*\r\n常用的树结构--二叉树，它的特点是一个结点的直接子节点最多只能有两个，\r\n并且有左右之分。在二叉树中有种常见的称为完全二叉树的结构，\r\n它的特点是除最后一层外每一层的结点数为2^i-1，\r\n最后一层的结点数若不满足2^i-1，那么最后一层的结点是自左向右排列的\r\n\r\n*/\r\n/** \r\n * 假设输入的中缀表达式为：  \r\n * （a+b)*((c+d)*e+f*h*g)  \r\n *\r\n * 1）以二叉链表的存储结构创建一棵。\r\n * 2）先根遍历为：此中缀表达式的前缀表达式  \r\n * 3）后根遍历为：此中缀表达式的后缀表达式   \r\n *\r\n          *\r\n       +            +  \r\n    a   b      *        * \r\n            +     e    f   * \r\n          c  d            h   g \r\n  */ \r\n   \r\ntypedef int Status;\r\ntypedef int TElemType;\r\n\r\n/*\r\n * 存储结构\r\n */\r\ntypedef struct BiTNode\r\n{\r\n    union{  \r\n        int opnd; // 数 \r\n        char optr; //操作符 \r\n    }val;    //数据\r\n    \r\n    struct BiTNode *lchild, *rchild;//左孩子  右孩子 结构体指针\r\n}BiTNode, *BiTree;//结构体变量  结构体指针\r\n\r\n/*\r\n * 创建二叉树,输入0表示创建空树\r\n */\r\nStatus CreateBiTree(BiTree *T)\r\n{\r\n    TElemType e;\r\n    scanf(\"%d\", &e);//输入一个整形树\r\n    if (e == 0)\r\n    {\r\n        *T = NULL;//0为空树\r\n    }\r\n    else\r\n    {\r\n        *T = (BiTree) malloc(sizeof(BiTNode));//初始化一个结构体的内存空间\r\n        if (!T)//创建失败\r\n        {\r\n            exit(OVERFLOW);\r\n        }\r\n        (*T)->data = e;//初始数据  根数据\r\n        CreateBiTree(&(*T)->lchild);    //创建左子树  迭代  0的话 左子树为空\r\n        CreateBiTree(&(*T)->rchild);    //创建右子树        1的话又会迭代 创建左子树 又子树  0 左子树为空  1 右子树\r\n\t\t//又会创建左子树 右子树 0 左子树为空 0 右子树为空 结束 \r\n    }\r\n    return OK;\r\n}\r\n\r\n/*\r\n * 访问元素\r\n */\r\nvoid visit(TElemType e)\r\n{\r\n    printf(\"%d \", e);\r\n}\r\n\r\n/*\r\n * 先序遍历二叉树：指先访问根，然后访问孩子的遍历方式\r\n */\r\nStatus PreOrderTraverse(BiTree T, void (*visit)(TElemType))\r\n{\r\n    if (T)\r\n    {\r\n        visit(T->data);//先访问父 元素\r\n        PreOrderTraverse(T->lchild, visit);//访问左子树 元素\r\n        PreOrderTraverse(T->rchild, visit);//访问右子树元素\r\n    }\r\n}\r\n\r\n/*\r\n * 中序遍历二叉树：指先访问左（右）孩子，然后访问根，最后访问右（左）孩子的遍历方式\r\n */\r\nStatus InOrderTraverse(BiTree T, void (*visit)(TElemType))\r\n{\r\n    if (T)\r\n    {\r\n        InOrderTraverse(T->lchild, visit);//访问左子树 元素\r\n        visit(T->data);//访问父 元素\r\n        InOrderTraverse(T->rchild, visit);//访问右子树元素\r\n    }\r\n}\r\n\r\n/*\r\n * 后序遍历二叉树：指先访问孩子，然后访问根的遍历方式\r\n */\r\nStatus PostOrderTraverse(BiTree T, void (*visit)(TElemType))\r\n{\r\n    if (T)\r\n    {\r\n        PostOrderTraverse(T->lchild, visit);//先访问左子树 元素\r\n        PostOrderTraverse(T->rchild, visit);//访问右子树元素\r\n        visit(T->data);//访问父 根 元素\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    BiTree T;\r\n    printf(\"创建树，输入0为空树：\\n\");\r\n    CreateBiTree(&T);\r\n    printf(\"先序遍历：\");\r\n    PreOrderTraverse(T, *visit);\r\n    printf(\"\\n中序遍历：\");\r\n    InOrderTraverse(T, *visit);\r\n    printf(\"\\n后序遍历：\");\r\n    PostOrderTraverse(T, *visit);\r\n    printf(\"\\n\");\r\n\r\n    return 0;\r\n}\r\n\r\n"
        },
        {
          "name": "tree_math_func.cpp",
          "type": "blob",
          "size": 2.2861328125,
          "content": "#include <iostream>  \r\n#include <cstdio>  \r\n#include <cstring>  \r\n#include <string>  \r\n  \r\nusing namespace std;  \r\n  \r\nchar str[1000];  \r\nchar op[1000];  \r\nint lch[1000], rch[1000];  \r\nint no = 0;  \r\n  \r\nint build_tree(char *st, int beg, int end){  \r\n    int i, j, k, p;  \r\n    int u;  \r\n    int sum = 0;  \r\n    int flag = 1;  \r\n    //printf(\"%d %d\\n\",beg,end);  \r\n    for(i = beg; i < end; i ++){  \r\n        if(!(st[i] <= '9' && st[i] >= '0')){  \r\n            flag = 0;  \r\n            break;  \r\n        }  \r\n    }  \r\n    if(flag){  \r\n        //printf(\"*%d***%d**\",beg,end);  \r\n        j = 1;  \r\n        for(i = end - 1; i >= beg; i --){  \r\n            sum += ((int)st[i] - '0') * j;  \r\n            j *= 10;  \r\n        }  \r\n        u= ++no;  \r\n        lch[u] = 0;  \r\n        rch[u] = 0;  \r\n        op[u] = sum;  \r\n        //printf(\"#%d#\",sum);  \r\n        return u;  \r\n    }  \r\n    int c1 = -1;  \r\n    int c2 = -1;  \r\n    p = 0;  \r\n    for(i = beg; i < end; i ++){  \r\n        switch(st[i]){  \r\n            case '(': p ++; break;  \r\n            case ')': p --; break;  \r\n            case '+': case '-': if(!p) c1 = i; break;  \r\n            case '*': case '/': if(!p) c2 = i; break;  \r\n        }  \r\n    }  \r\n    //cout << c1 <<endl;  \r\n    if(c1 < 0) c1 = c2;  \r\n    if(c1 < 0) return build_tree(str, beg + 1, end - 1 );  \r\n    u = ++no;  \r\n    lch[u] = build_tree(st, beg, c1);  \r\n    rch[u] = build_tree(st, c1+1, end);  \r\n    op[u] = st[c1];  \r\n    return u;  \r\n}  \r\n  \r\nfloat calculate(char *st, int beg){  \r\n    if(lch[beg] == 0 && rch[beg] == 0)  \r\n        return (float)st[beg];  \r\n    else switch (st[beg]){  \r\n        case '+': return calculate(op, lch[beg]) + calculate(op, rch[beg]); break;  \r\n        case '-': return calculate(op, lch[beg]) - calculate(op, rch[beg]); break;  \r\n        case '*': return calculate(op, lch[beg]) * calculate(op, rch[beg]); break;  \r\n        case '/': return calculate(op, lch[beg]) / calculate(op, rch[beg]); break;  \r\n    }  \r\n    return 0;  \r\n}  \r\n  \r\nint main(){  \r\n    int i;  \r\n    while(scanf(\"%[^\\n]\", str) != EOF ){  \r\n        getchar();  \r\n        memset(op, 0, sizeof(op));  \r\n        //cout << str <<endl;  \r\n        no = 0;  \r\n        build_tree(str, 0, strlen(str));  \r\n        printf(\"%.2f\\n\", calculate(op, 1));  \r\n        memset(str, 0, sizeof(str));  \r\n    }  \r\n    return 0;  \r\n} \r\n"
        },
        {
          "name": "tree_math_func_tree.cpp",
          "type": "blob",
          "size": 7.384765625,
          "content": "/** \r\n * 假设输入的中缀表达式为：  \r\n * （a+b)*((c+d)*e+f*h*g)  \r\n *\r\n * 1）以二叉链表的存储结构创建一棵。\r\n * 2）先根遍历为：此中缀表达式的前缀表达式  \r\n * 3）后根遍历为：此中缀表达式的后缀表达式   \r\n *\r\n * 2005/04/28\r\n */\r\n#include<stack>  \r\n#include<iostream>  \r\n#include<stdio.h> \r\n#include<stdlib.h> \r\n#include<ctype.h>  \r\n#include<string.h> \r\n \r\nusing   namespace   std;  \r\n\r\n//////////////////////////////////////////////////////////////////////////  \r\n//   数据类型定义区  \r\n//  \r\ntypedef   struct nodeTag{ /*   表达式二叉树结点类型   */  \r\n    union{  \r\n        int opnd;  \r\n        char optr;  \r\n    }val;  \r\n    struct   nodeTag *left;  \r\n    struct   nodeTag *right;  \r\n}treeNode;  \r\n\r\ntypedef   struct pTag{ /*   优先表结点类型   */  \r\n    char op;  \r\n    int f;  \r\n    int g;  \r\n}Prior;  \r\n\r\n//////////////////////////////////////////////////////////////////////////  \r\n//   全局变量定义区  \r\n//  \r\nPrior pList[]   =   { /*   优先表   */  \r\n    '+',   2,   1,  \r\n    '-',   2,   1,  \r\n    '*',   4,   3,  \r\n    '/',   4,   3,  \r\n    '^',   4,   5,  \r\n    '(',   0,   5,  \r\n    ')',   6,   0,  \r\n    '$',   0,   0  \r\n};  \r\nstack<char> OptrStack; /*   操作符栈   */  \r\nstack<treeNode*> ExprStack; /*   表达式栈   */  \r\nconst   int   NUM =   256;  \r\nconst   int   OPTR =   257;  \r\nint tokenval; /*   下一输入值   */  \r\n\r\n/**************************************************************************  \r\n*   descr     :比较栈顶运算符与下一输入运算符优先关系  \r\n*   param     :opf   栈顶运算符  \r\n*   param     :opg   下一输入运算符  \r\n*   return   :关系'>',   '=',   '<'  \r\n**************************************************************************/  \r\nchar   Precede(char   opf,   char   opg)  \r\n{  \r\n    int   op1=-1,op2=-1;  \r\n    for   (int   i=0;   i   <   8;   i++)  \r\n    {  \r\n        if   (pList[i].op   ==   opf)  \r\n            op1 =   pList[i].f;  \r\n        if   (pList[i].op   ==   opg)  \r\n            op2   =   pList[i].g;  \r\n    }  \r\n    if   (op1   ==   -1   ||   op2   ==   -1)  \r\n    {  \r\n        cout<<\"operator   error!\"<<endl;  \r\n        exit(1);  \r\n    }  \r\n    if   (op1   >   op2)  \r\n        return   '>';  \r\n    else   if   (op1   ==   op2)  \r\n        return   '=';  \r\n    else  \r\n        return   '<';  \r\n}  \r\n\r\n/**************************************************************************  \r\n*   descr     :  \r\n*   return   :  \r\n**************************************************************************/  \r\nint   lexan()  \r\n{  \r\n    int   t;  \r\n    while(1)  \r\n    {  \r\n        t   =   getchar();  \r\n        if   ( (t ==' ')||(t=='\\t')||(t=='\\n')); //去掉空白字符  \r\n        else   if   (isdigit(t))  \r\n        {  \r\n            ungetc(t,   stdin);  \r\n            cin>>tokenval;  \r\n            return   NUM;  \r\n        }  \r\n        else  \r\n        {  \r\n            return   t;  \r\n        }    \r\n    }  \r\n}  \r\n/**************************************************************************  \r\n*   descr     :   建立二叉树数结点(叶结点)  \r\n*   param     :   num   操作数  \r\n*   return   :   二叉树叶结点指针   treeNode*  \r\n**************************************************************************/  \r\ntreeNode*   mkleaf(int   num)  \r\n{  \r\n    treeNode   *tmpTreeNode   =   new   treeNode;  \r\n    if   (tmpTreeNode   ==   NULL)  \r\n    {  \r\n        cout<<\"Memory   allot   failed!\"<<endl;  \r\n        exit(1);  \r\n    }  \r\n    tmpTreeNode->left =   NULL;  \r\n    tmpTreeNode->right =   NULL;  \r\n    tmpTreeNode->val.opnd   =   num;  \r\n    return   tmpTreeNode;  \r\n}  \r\n\r\n/**************************************************************************  \r\n*   descr     :   建立二叉树运算符结点(内结点)  \r\n*   param     :   op运算符  \r\n*   param     :   left左子树指针  \r\n*   param     :   right右子树指针  \r\n*   return   :   二叉树内结点指针   treeNode*  \r\n**************************************************************************/  \r\ntreeNode*   mknode(char   op,   treeNode*   left,treeNode*   right)  \r\n{  \r\n    treeNode   *tmpTreeNode   =   new   treeNode;  \r\n    if   (tmpTreeNode   ==   NULL)  \r\n    {  \r\n        cout<<\"Memory   allot   failed!\"<<endl;  \r\n        exit(1);  \r\n    }  \r\n    if   (left   ==   NULL   ||   right   ==   NULL)  \r\n    {  \r\n        cout<<\"Lossing   operand!\"<<endl;  \r\n        exit(1);  \r\n    }  \r\n    tmpTreeNode->left =   left;  \r\n    tmpTreeNode->right =   right;  \r\n    tmpTreeNode->val.optr   =   op;  \r\n    return   tmpTreeNode;  \r\n}  \r\n\r\n/**************************************************************************  \r\n*   descr     :   建立表达式二叉树(参考严蔚敏，吴伟民的《数据结构》P/53)  \r\n*   return   :   二叉树跟结点指针  \r\n**************************************************************************/  \r\ntreeNode*   CreateBinaryTree()  \r\n{  \r\n    int     lookahead;  \r\n    char   op;  \r\n    treeNode   *opnd1,   *opnd2;  \r\n    OptrStack.push('$');  \r\n    lookahead   =   lexan();  \r\n    while   (   lookahead   !=   '$'   ||   OptrStack.top()   !=   '$')  \r\n    {  \r\n        if   (lookahead   ==   NUM   )  \r\n        {  \r\n            ExprStack.push(   mkleaf(tokenval));  \r\n            lookahead   =   lexan();  \r\n        }  \r\n        else  \r\n        {  \r\n            switch   (Precede(OptrStack.top(),   lookahead))  \r\n            {  \r\n            case   '<':  \r\n                OptrStack.push(lookahead);  \r\n                lookahead   =   lexan();  \r\n                break;  \r\n            case   '=':  \r\n                OptrStack.pop();  \r\n                lookahead   =   lexan();  \r\n                break;  \r\n            case   '>':  \r\n                opnd2 =   ExprStack.top();ExprStack.pop();  \r\n                opnd1 =   ExprStack.top();ExprStack.pop();  \r\n                op =   OptrStack.top();OptrStack.pop();  \r\n                ExprStack.push(   mknode(op,   opnd1,   opnd2));  \r\n                break;  \r\n            }  \r\n        }  \r\n    }  \r\n    return   ExprStack.top();  \r\n}  \r\n\r\n/**************************************************************************  \r\n*   descr     :   输出前缀表达式  \r\n*   param     :  \r\n*   return   :  \r\n**************************************************************************/  \r\nint   PreOrderTraverse(treeNode*   T)  \r\n{  \r\n    if   (   T   ==   NULL)  \r\n        return   1;  \r\n    if(T->left   !=   NULL)  \r\n    {  \r\n        cout<<T->val.optr<<\"   \";  \r\n        if   (PreOrderTraverse(T->left))  \r\n            if   (PreOrderTraverse(T->right))  \r\n                return   1;  \r\n        return   0;  \r\n    }  \r\n    else  \r\n    {  \r\n        cout<<T->val.opnd<<\"   \";  \r\n        return   1;  \r\n    }  \r\n}  \r\n\r\n/**************************************************************************  \r\n*   descr     :   输出后缀表达式  \r\n*   param     :  \r\n*   return   :  \r\n**************************************************************************/  \r\nint   FollowOrderTraverse(treeNode*   T)  \r\n{  \r\n    if   (   T   ==   NULL)  \r\n        return   1;  \r\n    if   (   T->left   !=NULL)  \r\n    {  \r\n        if   (FollowOrderTraverse(T->left))  \r\n            if   (FollowOrderTraverse(T->right))  \r\n            {  \r\n                cout<<T->val.optr<<\"   \";  \r\n                return   1;  \r\n            }  \r\n            return   0;  \r\n\r\n    }  \r\n    else  \r\n    {  \r\n        cout<<T->val.opnd<<\"   \";  \r\n        return   1;  \r\n    }  \r\n}  \r\n\r\n//////////////////////////////////////////////////////////////////////////  \r\n//   主程序  \r\n//  \r\nint   main()  \r\n{  \r\n    treeNode   *ExprTree;  \r\n    ExprTree   =   CreateBinaryTree();  \r\n    PreOrderTraverse(ExprTree);  \r\n    cout<<endl;  \r\n    FollowOrderTraverse(ExprTree);  \r\n    cout<<endl;  \r\n    return 0; \r\n}   \r\n"
        },
        {
          "name": "vector向量类使用.md",
          "type": "blob",
          "size": 6.349609375,
          "content": " # 向量是最简单的 STL 容器，其数据结构与数组相似，占据着一个连续的内存块。\n       由于内存位置是连续的，所以向量中的元素可以随机访问，访问向量中任何一个元素的时间也是固定的。\n       存储空间的管理是自动的，当要将一个元素插入到已满的向量中时，会为向量分配一个更大的内存块，将\n       向量中的元素复制进新的内存块中，然后释放旧的内存块。所以，向量是一个灵活的数组，是能够\n       动态改变自身大小的数组。\n      #include <iostream>\n      #include <vector>// 为了使用向量类\n      #include <algorithm>\n      #include <functional> // greater<T>\n\n      using namespace std;\n\n      // 通用打印 向量类vector的 元素 \n      template<class T>\n      void printVector(char *s, const vector<T>& v) {\n        cout << s << \" = (\";\n        if (v.size() == 0) {\n          cout << \")\\n\";//输出 换行 \n          return;\n          }\n          // 类型别名  常量迭代器  不能修改指向的对象 \n      typename vector<T>::const_iterator i = v.begin();\n        for( ; i != v.end()–1; i++)// for( ; i < v.end()-1; ++i)\n          cout << *i << ' ';//打印元素 \n\n        cout << *i << \")\\n\";//输出最后一个元素 并 换行 \n      }\n\n      bool f1(int n) {\n        return n < 4;\n      }\n\n      int main() {\n      int a[] = {1,2,3,4,5};\n      vector<int> v1; // 向量v1 为空, size = 0, capacity = 0\n      printVector(\"v1\",v1);\n\n      for (int j = 1; j <= 5; j++)\n        v1.push_back(j); // v1 = (1 2 3 4 5), 大小size = 5, 当前最大存储能力 capacity = 8\n      // 注意，向量没有 push_front()成员函数。\n\n\n      vector<int> v2(3,7); // v2 = (7 7 7)\n\n      vector<int> ::iterator i1 = v1.begin()+1;\n\n      vector<int> v3(i1,i1+2); // 截取赋值 v3 = (2 3), size = 2, capacity = 2\n\n      vector<int> v4(v1); // 拷贝赋值 v4 = (1 2 3 4 5), size = 5, capacity = 5\n\n      vector<int> v5(5); // v5 = (0 0 0 0 0)\n\n      v5[1] = v5.at(3) = 9; // 指定位置赋值 v5 = (0 9 0 9 0)\n\n      // 向量的容量 可以通过函数 reserve()来改变(尽力改变)。\n      v3.reserve(6); // v3 = (2 3), size = 2, capacity = 6\n\n      v4.resize(7); // v4 = (1 2 3 4 5 0 0), size = 7, capacity = 10\n      v4.resize(3); // v4 = (1 2 3), size = 3, capacity = 10\n      v4.clear(); //清空 数据但是 分配的内存为减少 v4 is empty, size = 0, capacity = 10 ！！！！ \n      // 向量的插入 \n      v4.insert(v4.end(),v3[1]); // v4 = (3)\n      v4.insert(v4.end(),v3.at(1)); // v4 = (3 3)\n      v4.insert(v4.end(),2,4); // v4 = (3 3 4 4)\n      v4.insert(v4.end(),v1.begin()+1,v1.end()-1); // v4 = (3 3 4 4 2 3 4)\n      // 删除指定元素 \n      v4.erase(v4.end()-2); // v4 = (3 3 4 4 2 4)\n      v4.erase(v4.begin(), v4.begin()+4); // v4 = (2 4)\n\n      // assign替换 先删除原有元素，在插入元素 \n      v4.assign(3,8); // v4 = (8 8 8)\n      v4.assign(a,a+3); // v4 = (1 2 3)\n\n      // 逆 迭代器 从尾部向前 迭代 \n      vector<int>::reverse_iterator i3 = v4.rbegin();\n      for ( ; i3 != v4.rend(); i3++)\n      cout << *i3 << ' '; // print: 3 2 1\n      cout << endl;\n\n      // 算法 algorithms\n      v5[0] = 3; // v5 = (3 9 0 9 0)\n      // 条件替换   <4 的都被替换成 7 \n      replace_if(v5.begin(),v5.end(),f1,7); // v5 = (7 9 7 9 7)\n      //  replace_if(v5.begin(),v5.end(), bind2nd(less<int>(),4) ,7);\n      //  bind2nd(op, a)是一个通用函数\n\n\n      //直接替换 \n      v5[0] = 3; v5[2] = v5[4] = 0; // v5 = (3 9 0 9 0)\n      // 指定元素替换 0 -> 7 \n      replace(v5.begin(),v5.end(),0,7); // v5 = (3 9 7 9 7)\n      // sort 排序  快排 堆排 \n      sort(v5.begin(),v5.end()); // v5 = (3 7 7 9 9)  升序排序 \n      sort(v5.begin(),v5.end(),greater<int> ()); // v5 = (9 9 7 7 3)  降序排序呢\n      // 前方插入 \n      // 例如对于整型向量，成员函数 front()的原 型为：int& front() ; 可以 放在 左边 也可以放在右边  \n      v5.front() = 2; // v5 = (2 9 7 7 3)\n      return 0;\n      }\n## 使用自定义的类  作为 容器的元素  来使用 容器的一些算法\n### 定义自己的类  \n     class Person {\n     public:\n        // 默认构造函数 \n        Person(char *n = \"\", int a = 0) {\n          name = strdup(n);// 复制字符串\n          age = a;//复制年龄\n        }\n        // 默认析构函数\n        ~Person(){\n         free(name);//释放 字符串指向的空间\n       }\n       // 重载 等号判断 运算符  返回布尔量  输入为常量 的引用 避免拷贝 同时 常量 避免修改\n       bool operator==(const Person& p) const {\n         return strcmp(name,p.name) == 0 && age == p.age;// 名字 和年龄都必须相等\n       }\n       // 重载 小于号  运算符  返回布尔量\n       bool operator<(const Person& p) const {\n         return strcmp(name,p.name) < 0;//这里 使用 名字字符串 来比较\n       }\n       // 重载 大于号  运算符  返回布尔量\n       bool operator>(const Person& p) const {\n         return !(*this == p) && !(*this < p);// 使用了 ==  和 小于号\n        }\n\n     private:// 私有变量\n       char *name;\n       int age;\n       friend bool lesserAge(const Person&, const Person&);//有元函数  使用年龄来比较两个对象的大小\n     };\n\n### 使用向量 容器来 存储 自定义的 Person类\n     vector<Person> vp(1, Person(\"Golg\",26));//Person(\"Golg\",26)使用 默认构造函数创建一类对象存放在向量容器内\n     // 增加两个对象\n      vp.push_back(Person(\"Any\",20));\n      vp.push_back(Person(\"Bil\",30));\n\n     // 使用向量容器的 排序算法  默认需要类对象 提供 小于运算符的重载(比较函数)\n     sort(vp.begin(), vp.end());\n     //  vp=((\"Golg\",26)(\"Any\",20))(\"Bil\",30)) --> ((\"Any\",20))(\"Bil\",30)(\"Golg\",26))\n     // 逆序排列\n     sort(vp.begin(), vp.end(), greater<Person>());\n     // vp= ((\"Any\",20))(\"Bil\",30)(\"Golg\",26)) --> ((\"Golg\",26)(\"Bil\",30)(\"Any\",20)))\n\n     // 那么如何 使用 年龄来排序呢 1提供比较函数(要是有元函数)  2直接修改 小于运算符的重载 函数 方法\n     // 1提供比较函数(要是有元函数)\n     bool lesserAge(const Person& p1, const Person& p2){\n       return  p1.age < p2.age;//小于时为真\n     }\n     // 传递比较函数\n     sort(vp.begin(), vp.end(), lesserAge);\n     // vp=  ((\"Golg\",26)(\"Bil\",30)(\"Any\",20))) ---> ((\"Any\",20)(\"Bil\",30)(\"Golg\",26)))\n\n\n\n"
        },
        {
          "name": "中国计算机学会推荐际术议和期刊目录.m",
          "type": "blob",
          "size": 63.380859375,
          "content": "一、 A类\n\n序号 刊物简称 刊物全称 出版社  网址\n\n[1 TOCS ACM Transactions on Computer Systems ACM  ](http://dblp.uni-trier.de/db/journals/tocs/)\n[2 TOS  ACM Transactions on Storage ACM ](http://dblp.uni-trier.de/db/journals/tos/)\n[3 TCAD IEEE Transactions on Computer-Aided Design of Integrated Circuits And System IEEE ](http://dblp.uni-trier.de/db/journals/tcad/)\n[4 TC IEEE Transactions on Computers IEEE](http://dblp.uni-trier.de/db/journals/tc/index.html)\n[5 TPDS IEEE Transactions on Parallel and Distributed Systems IEEE](http://dblp.uni-trier.de/db/journals/tpds/)\n\n\n二、 B类\n序号\n刊物简称 刊物简称\n刊物全称 刊物全称\n出版社\n网址\n1\nTACO\nACM Transactions on Architecture and Code Optimization\nACM\nhttp://dblp.uni-trier.de/db/journals/taco/\n\n2\nTAAS\nACM Transactions on Autonomous and Adaptive Systems\nACM\nhttp://dblp.uni-trier.de/db/journals/taas/\n\n3\nTODAES\nACM Transactions on Design Automation of Electronic Systems\nACM\nhttp://dblp.uni-trier.de/db/journals/todaes/\n\n4\nTECS\nACM Transactions on Embedded Computing Systems\nACM\nhttp://dblp.uni-trier.de/db/journals/tecs/\n\n5\nTRETS\nACM Transactions on Reconfigurable Technology and Systems\nACM\nhttp://dblp.uni-trier.de/db/journals/trets/\n\n6\nTVLSI\nIEEE Transactions on Very Large Scale Integration (VLSI) Systems\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tvlsi/\n\n7\nJPDC\nJournal of Parallel and Distributed Computing\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jpdc/\n\n8\nJSA\nJournal of Systems Architecture: Embedded Software Design\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jsa/\n\n9\nPARCO\nParallel Computing\nElsevier\nhttp://dblp.uni-trier.de/db/conf/parco/\n\n10\nPerformance Evaluation: An International Journal\nElsevier\nhttp://www.journals.elsevier.com/performance-evaluation/\n\n\n15\nSIGMETRICS\nInternational Conference on Measurement and Modeling of Computer Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/sigmetrics/\n\n16\nPACT\nInternational Conference on Parallel Architectures and Compilation Techniques\nIEEE/ACM\nhttp://dblp.uni-trier.de/db/conf/IEEEpact/\n\n17\nICPP\nInternational Conference on Parallel Processing\nhttp://dblp.uni-trier.de/db/conf/icpp/\n\n18\nICS\nInternational Conference on Supercomputing\nACM\nhttp://dblp.uni-trier.de/db/conf/ics/\n\n19\nVEE\nInternational Conference on Virtual Execution Environments\nACM\nhttp://dblp.uni-trier.de/db/conf/vee/\n\n20\nIPDPS\nInternational Parallel & Distributed Processing Symposium\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ipps/\n\n21\nPerformance\nInternational Symposium on Computer Performance Modeling, Measurements and Evaluation\nACM\nhttp://dblp.uni-trier.de/db/conf/performance/\n\n22\nHPDC\nInternational Symposium on High Performance Distributed Computing\nIEEE\nhttp://dblp.uni-trier.de/db/conf/hpdc/\n\n23\nITC\nInternational Test Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/itc/\n\n24\nLISA\nLarge Installation System Administration Conference\nUSENIX\nhttp://dblp.uni-trier.de/db/conf/lisa/\n\n25\nMSST\nMass Storage Systems and Technologies\nIEEE\nhttp://dblp.uni-trier.de/db/conf/mss/\n\n26\nRTAS\nReal-Time and Embedded Technology and Applications Symposium\nIEEE\nhttp://dblp.uni-trier.de/db/conf/rtas/\n\n\n\n三、 C类\n\n序号 会议简称  会议全称  出版社  网址\n\n1\nCF\nACM International Conference on Computing Frontiers\nACM\nhttp://dblp.uni-trier.de/db/conf/cf\n\n2\nSYSTOR\nACM International Systems and Storage Conference\nACM\nhttp://dblp.uni-trier.de/db/conf/systor/index.html\n\n3\nNOCS\nACM/IEEE International Symposium on Networks-on-Chip\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/nocs\n\n4\nASAP\nApplication-Specific Systems, Architectures, and Processors\nIEEE\nhttp://dblp.uni-trier.de/db/conf/asap\n\n5\nASP-DAC\nAsia and South Pacific Design Automation Conference\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/aspdac\n\n6\nEuro-Par\nEuropean Conference on Parallel and Distributed Computing\nSpringer\nhttp://dblp.uni-trier.de/db/conf/europar/\n\n7\nETS\nEuropean Test Symposium\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ets/\n\n8\nFPL\nField Programmable Logic and Applications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/fpl/\n\n9\nFCCM\nField-Programmable Custom Computing Machines\nIEEE\nhttp://dblp.uni-trier.de/db/conf/fccm/\n\n10\nGLSVLSI\nGreat Lakes Symposium on VLSI\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/glvlsi/\n\n11\nATS\nIEEE Asian Test Symposium\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ats/\n\n12\nHPCC\nIEEE International Conference on High Performance Computing and Communications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/hpcc/\n\n13\nHiPC\nIEEE International Conference on High Performance Computing, Data and Analytics\nIEEE/ ACM\nhttp://dblp.uni-trier.de/db/conf/hipc/index.html\n\n14\nMASCOTS\nIEEE International Symposium on Modeling, Analysis, and Simulation of Computer and Telecommunication Systems\nIEEE\nhttp://dblp.uni-trier.de/db/conf/mascots/\n\n\n15\nISPA\nIEEE International Symposium on Parallel and Distributed Processing with Applications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ispa/\n\n16\nCCGRID\nIEEE/ACM International Symposium on Cluster, Cloud and Grid Computing\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/ccgrid/\n\n17\nNPC\nIFIP International Conference on Network and Parallel Computing\nSpringer\nhttp://dblp.uni-trier.de/db/conf/npc/\n\n18\nICA3PP\nInternational Conference on Algorithms and Architectures for Parallel Processing\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ica3pp/\n\n19\nCASES\nInternational Conference on Compilers, Architectures, and Synthesis for Embedded Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/cases/index.html\n\n20\nFPT\nInternational Conference on Field-Programmable Technology\nIEEE\nhttp://dblp.uni-trier.de/db/conf/fpt/\n\n21\nICPADS\nInternational Conference on Parallel and Distributed Systems\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icpads/\n\n22\nISCAS\nInternational Symposium on Circuits and Systems\nIEEE\nhttp://dblp.uni-trier.de/db/conf/iscas/\n\n23\nISLPED\nInternational Symposium on Low Power Electronics and Design\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/islped/\n\n24\nISPD\nInternational Symposium on Physical Design\nACM\nhttp://dblp.uni-trier.de/db/conf/ispd/\n\n25\nHotI\nSymposium on High-Performance Interconnects\nIEEE\nhttp://dblp.uni-trier.de/db/conf/hoti/\n\n26\nVTS\nVLSI Test Symposium\nIEEE\nhttp://dblp.uni-trier.de/db/conf/vts/\n\n中国计算机学会推荐际术\n\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nJSAC\nIEEE Journal of Selected Areas in Communications\nIEEE\nhttp://dblp.uni-trier.de/db/journals/jsac/\n2\nTMC\nIEEE Transactions on Mobile Computing\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tmc/\n3\nTON\nIEEE/ACM Transactions on Networking\nIEEE/ACM\nhttp://dblp.uni-trier.de/db/journals/ton/\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTOIT\nACM Transactions on Internet Technology\nACM\nhttp://dblp.uni-trier.de/db/journals/toit/\n2\nTOMCCAP\nACM Transactions on Multimedia Computing, Communications and Applications\nACM\nhttp://dblp.uni-trier.de/db/journals/tomccap/\n3\nTOSN\nACM Transactions on Sensor Networks\nACM\nhttp://dblp.uni-trier.de/db/journals/tosn/\n4\nCN\nComputer Networks\nElsevier\nhttp://dblp.uni-trier.de/db/journals/cn/\n5\nTCOM\nIEEE Transactions on Communications\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tcom/\n6\nTWC\nIEEE Transactions on Wireless Communications\nIEEE\nhttp://dblp.uni-trier.de/db/journals/twc/\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nAd Hoc Networks\nElsevier\nhttp://dblp.uni-trier.de/db/journals/adhoc/\n2\nCC\nComputer Communications\nElsevier\nhttp://dblp.uni-trier.de/db/journals/comcom/\n3\nTNSM\nIEEE Transactions on Network and Service Management\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tnsm/\n4\nIET Communications\nIET\nhttp://dblp.uni-trier.de/db/journals/iet-com/\n5\nJNCA\nJournal of Network and Computer Applications\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jnca/\n6\nMONET\nMobile Networks & Applications\nSpringer\nhttp://dblp.uni-trier.de/db/journals/monet/\n7\nNetworks\nWiley\nhttp://dblp.uni-trier.de/db/journals/networks/\n8\nPPNA\nPeer-to-Peer Networking and Applications\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ppna/\n9\nWCMC\nWireless Communications & Mobile Computing\nWiley.\nhttp://dblp.uni-trier.de/db/journals/wicomm/\n10\nWireless Networks\nSpringer\nhttp://dblp.uni-trier.de/db/journals/winet/\n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nSIGCOMM\nACM International Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication\nACM\nhttp://dblp.uni-trier.de/db/conf/sigcomm/index.html\n2\nMobiCom\nACM International Conference on Mobile Computing and Networking\nACM\nhttp://dblp.uni-trier.de/db/conf/mobicom/\n3\nINFOCOM\nIEEE International Conference on Computer Communications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/infocom/\n4\nNSDI\nSymposium on Network System Design and Implementation\nUSENIX\nhttp://dblp.uni-trier.de/db/conf/nsdi/\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nSenSys\nACM Conference on Embedded Networked Sensor Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/sensys/\n2\nCoNEXT\nACM International Conference on Emerging Networking Experiments and Technologies\nACM\nhttp://dblp.uni-trier.de/db/conf/conext/\n3\nSECON\nIEEE Communications Society Conference on Sensor and Ad Hoc Communications and Networks\nIEEE\nhttp://dblp.uni-trier.de/db/conf/secon/\n4\nIPSN\nInternational Conference on Information Processing in Sensor Networks\nIEEE/ACM\nhttp://dblp.uni-trier.de/db/conf/ipsn/\n5\nMobiSys\nInternational Conference on Mobile Systems, Applications, and Services\nACM\nhttp://dblp.uni-trier.de/db/conf/mobisys/\n6\nICNP\nInternational Conference on Network Protocols\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icnp/\n7\nMobiHoc\nInternational Symposium on Mobile Ad Hoc Networking and Computing\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/mobihoc/\n8\nNOSSDAV\nInternational Workshop on Network and Operating System Support for Digital Audio and Video\nACM\nhttp://dblp.uni-trier.de/db/conf/nossdav/\n9\nIWQoS\nInternational Workshop on Quality of Service\nIEEE\nhttp://dblp.uni-trier.de/db/conf/iwqos/\n10\nIMC\nInternet Measurement Conference\nACM/USENIX\nhttp://dblp.uni-trier.de/db/conf/imc/\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nANCS\nArchitectures for Networking and Communications Systems\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/ancs/\n2\nAPNOMS\nAsia-Pacific Network Operations and Management Symposium\nIFIP/IEEE\nhttp://dblp.uni-trier.de/db/conf/apnoms/\n3\nFORTE\nFormal Techniques for Networked and Distributed Systems\nSpringer\nhttp://dblp.uni-trier.de/db/conf/forte/\n4\nLCN\nIEEE Conference on Local Computer Networks\nIEEE\nhttp://dblp.uni-trier.de/db/conf/lcn/\n5\nGLOBECOM\nIEEE Global Communications Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/globecom/\n6\nICC\nIEEE International Conference on Communications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icc/\n7\nICCCN\nIEEE International Conference on Computer Communications and Networks\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icccn/\n8\nMASS\nIEEE International Conference on Mobile Ad-hoc and Sensor Systems\nIEEE\nhttp://dblp.uni-trier.de/db/conf/mass/index.html\n9\nP2P\nIEEE International Conference on Peer-to-Peer Computing\nIEEE\nhttp://dblp.uni-trier.de/db/conf/p2p/\n10\nIPCCC\nIEEE International Performance Computing and Communications Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ipccc/\n11\nWoWMoM\nIEEE International Symposium on a World of Wireless, Mobile and Multimedia Networks\nIEEE\nhttp://dblp.uni-trier.de/db/conf/wowmom/\n12\nISCC\nIEEE Symposium on Computers and Communications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/iscc/\n13\nWCNC\nIEEE Wireless Communications & Networking Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/wcnc/\n14\nNetworking\nIFIP International Conferences on Networking\nIFIP\nhttp://dblp.uni-trier.de/db/conf/networking/index.html\n15\nIM\nIFIP/IEEE International Symposium on Integrated Network Management\nIFIP/IEEE\nhttp://dblp.uni-trier.de/db/conf/im/index.html\n16\nMSN\nInternational Conference on Mobile Ad-hoc and Sensor Networks\nIEEE\nhttps://dblp.uni-trier.de/db/conf/msn/\n17\nMSWiM\nInternational Conference on Modeling, Analysis and Simulation of Wireless and Mobile Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/mswim/\n18\nWASA\nInternational Conference on Wireless Algorithms, Systems, and Applications\nSpringer\nhttp://dblp.uni-trier.de/db/conf/wasa/\n19\nHotNets\nThe Workshop on Hot Topics in Networks\nACM\nhttp://dblp.uni-trier.de/db/conf/hotnets/\n\n（网络与信息安全）\n\n\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTDSC\nIEEE Transactions on Dependable and Secure Computing\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tdsc/\n2\nTIFS\nIEEE Transactions on Information Forensics and Security\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tifs/\n3\nJournal of Cryptology\nSpringer\nhttp://dblp.uni-trier.de/db/journals/joc/\n\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTOPS\nACM Transactions on Privacy and Security\nACM\nhttps://tops.acm.org/\n2\nComputers & Security\nElsevier\nhttp://dblp.uni-trier.de/db/journals/compsec/\n3\nDesigns, Codes and Cryptography\nSpringer\nhttp://dblp.uni-trier.de/db/journals/dcc/\n4\nJCS\nJournal of Computer Security\nIOS Press\nhttp://dblp.uni-trier.de/db/journals/jcs/\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nCLSR\nComputer Law and Security Review\nElsevier\nhttp://www.journals.elsevier.com/computer-law-and-security-review/\n2\nEURASIP Journal on Information Security\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ejisec/\n3\nIET Information Security\nIET\nhttp://dblp.uni-trier.de/db/journals/iet-ifs/\n4\nIMCS\nInformation Management & Computer Security\nEmerald\nhttp://dblp.uni-trier.de/db/journals/imcs/\n5\nIJICS\nInternational Journal of Information and Computer Security\nInderscience\nhttp://dblp.uni-trier.de/db/journals/ijics/\n6\nIJISP\nInternational Journal of Information Security and Privacy\nIdea Group Inc\nhttp://dblp.uni-trier.de/db/journals/ijisp/\n7\nJISA\nJournal of Information Security and Application\nElsevier\nhttps://dblp.uni-trier.de/db/journals/istr/\n8\nSCN\nSecurity and Communication Networks\nWiley\nhttp://dblp.uni-trier.de/db/journals/scn/\n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nCCS\nACM Conference on Computer and Communications Security\nACM\nhttp://dblp.uni-trier.de/db/conf/ccs/\n2\nEUROCRYPT\nEuropean Cryptology Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/eurocrypt/\n3\nS&P\nIEEE Symposium on Security and Privacy\nIEEE\nhttp://dblp.uni-trier.de/db/conf/sp/\n4\nCRYPTO\nInternational Cryptology Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/crypto/\n5\nUSENIX Security\nUsenix Security Symposium\nUSENIX Association\nhttp://dblp.uni-trier.de/db/conf/uss/\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nACSAC\nAnnual Computer Security Applications Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/acsac/\n2\nASIACRYPT\nAnnual International Conference on the Theory and Application of Cryptology and Information Security\nSpringer\nhttp://dblp.uni-trier.de/db/conf/asiacrypt/\n3\nESORICS\nEuropean Symposium on Research in Computer Security\nSpringer\nhttp://dblp.uni-trier.de/db/conf/esorics/\n4\nFSE\nFast Software Encryption\nSpringer\nhttp://dblp.uni-trier.de/db/conf/fse/\n5\nCSFW\nIEEE Computer Security Foundations Workshop\nIEEE\nhttp://dblp.uni-trier.de/db/conf/csfw/\n6\nSRDS\nIEEE International Symposium on Reliable Distributed Systems\nIEEE\nhttp://dblp.uni-trier.de/db/conf/srds/\n7\nCHES\nInternational Conference on Cryptographic Hardware and Embedded Systems\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ches/\n8\nDSN\nInternational Conference on Dependable Systems and Networks\nIEEE/IFIP\nhttp://dblp.uni-trier.de/db/conf/dsn/\n9\nRAID\nInternational Symposium on Recent Advances in Intrusion Detection\nSpringer\nhttp://dblp.uni-trier.de/db/conf/raid/\n10\nPKC\nInternational Workshop on Practice and Theory in Public Key Cryptography\nSpringer\nhttp://dblp.uni-trier.de/db/conf/pkc/\n11\nNDSS\nISOC Network and Distributed System Security Symposium\nISOC\nhttp://dblp.uni-trier.de/db/conf/ndss/\n12\nTCC\nTheory of Cryptography Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/tcc/\n\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nWiSec\nACM Conference on Security and Privacy in Wireless and Mobile Networks\nACM\nhttp://dblp.uni-trier.de/db/conf/wisec/\n2\nSACMAT\nACM Symposium on Access Control Models and Technologies\nACM\nhttp://dblp.uni-trier.de/db/conf/sacmat/\n3\nDRM\nACM Workshop on Digital Rights Management\nACM\nhttp://dblp.uni-trier.de/db/conf/drm/\n4\nIH&MMSec\nACM Workshop on Information Hiding and Multimedia Security\nACM\nhttp://dblp.uni-trier.de/db/conf/ih/\n5\nACNS\nApplied Cryptography and Network Security\nSpringer\nhttp://dblp.uni-trier.de/db/conf/acns/\n6\nAsiaCCS\nAsia Conference on Computer and Communications Security\nACM\nhttp://dblp.uni-trier.de/db/conf/ccs/\n7\nACISP\nAustralasia Conference on Information Security and Privacy\nSpringer\nhttp://dblp.uni-trier.de/db/conf/acisp/\n8\nCT-RSA\nCryptographer's Track at RSA Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ctrsa/\n9\nDIMVA\nDetection of Intrusions and Malware & Vulnerability Assessment\nhttp://dblp.uni-trier.de/db/conf/dimva/\n10\nDFRWS\nDigital Forensic Research Workshop\nElsevier\nhttp://dblp.uni-trier.de/db/conf/dfrws/\n11\nFC\nFinancial Cryptography and Data Security\nSpringer\nhttp://dblp.uni-trier.de/db/conf/fc/\n12\nTrustCom\nIEEE International Conference on Trust, Security and Privacy in Computing and Communications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/trustcom/\n13\nSEC\nIFIP International Information Security Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/sec/\n14\nIFIP WG 11.9\nIFIP WG 11.9 International Conference on Digital Forensics\nSpringer\n*http://www.ifip119.org/Conferences/\n15\nISC\nInformation Security Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/isw/\n16\nICDF2C\nInternational Conference on Digital Forensics & Cyber Crime\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icdf2c/\n17\nICICS\nInternational Conference on Information and Communications Security\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icics/\n18\nSecureComm\nInternational Conference on Security and Privacy in Communication Networks\nACM\nhttp://dblp.uni-trier.de/db/conf/securecomm/\n19\nNSPW\nNew Security Paradigms Workshop\nACM\nhttp://dblp.uni-trier.de/db/conf/nspw/\n20\nPAM\nPassive and Active Measurement Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/pam/\n21\nPETS\nPrivacy Enhancing Technologies Symposium\nSpringer\nhttp://dblp.uni-trier.de/db/conf/pet/\n22\nSAC\nSelected Areas in Cryptography\nSpringer\nhttp://dblp.uni-trier.de/db/conf/sacrypt/\n23\nSOUPS\nSymposium On Usable Privacy and Security\nUSENIX\nhttp://dblp.uni-trier.de/db/conf/soups/\n24\nHotSec\nUSENIX Workshop on Hot Topics in Security\nUSENIX\nhttp://www.usenix.org/events/\n\n\n## （软件工程 系统软件  程序设计语言）\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTOPLAS\nACM Transactions on Programming Languages & Systems\nACM\nhttp://dblp.uni-trier.de/db/journals/toplas/\n2\nTOSEM\nACM Transactions on Software Engineering and Methodology\nACM\nhttp://dblp.uni-trier.de/db/journals/tosem/\n3\nTSE\nIEEE Transactions on Software Engineering\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tse/\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nASE\nAutomated Software Engineering\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ase/\n2\nESE\nEmpirical Software Engineering\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ese/\n3\nTSC\nIEEE Transactions on Service Computing\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tsc/\n4\nIETS\nIET Software\nIET\nhttps://dblp.uni-trier.de/db/journals/iet-sen/\n5\nIST\nInformation and Software Technology\nElsevier\nhttp://dblp.uni-trier.de/db/journals/infsof/index.html\n6\nJFP\nJournal of Functional Programming\nCambridge University Press\nhttp://dblp.uni-trier.de/db/journals/jfp/\n7\nJournal of Software: Evolution and Process\nWiley\nhttp://dblp.uni-trier.de/db/journals/smr/\n8\nJSS\nJournal of Systems and Software\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jss/\n9\nRE\nRequirements Engineering\nSpringer\nhttp://dblp.uni-trier.de/db/journals/re/\n10\nSCP\nScience of Computer Programming\nElsevier\nhttp://dblp.uni-trier.de/db/journals/scp/\n11\nSoSyM\nSoftware and System Modeling\nSpringer\nhttp://dblp.uni-trier.de/db/journals/sosym/\n12\nSTVR\nSoftware Testing, Verification and Reliability\nWiley\nhttp://dblp.uni-trier.de/db/journals/stvr/index.html\n13\nSPE\nSoftware: Practice and Experience\nWiley\nhttp://dblp.uni-trier.de/db/journals/spe/\n\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nCL\nComputer Languages, Systems and Structures\nElsevier\nhttp://dblp.uni-trier.de/db/journals/cl/index.html\n2\nIJSEKE\nInternational Journal on Software Engineering and Knowledge Engineering\nWorld Scientific\nhttp://dblp.uni-trier.de/db/journals/ijseke/index.html\n3\nSTTT\nInternational Journal on Software Tools for Technology Transfer\nSpringer\nhttp://dblp.uni-trier.de/db/journals/sttt/\n4\nJLAP\nJournal of Logic and Algebraic Programming\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jlp/jlap.html\n5\nJWE\nJournal of Web Engineering\nRinton Press\nhttp://dblp.uni-trier.de/db/journals/jwe/\n6\nSOCA\nService Oriented Computing and Applications\nSpringer\nhttp://dblp.uni-trier.de/db/journals/soca/\n7\nSQJ\nSoftware Quality Journal\nSpringer\nhttp://dblp.uni-trier.de/db/journals/sqj/\n8\nTPLP\nTheory and Practice of Logic Programming\nCambridge University Press\nhttp://dblp.uni-trier.de/db/journals/tplp/\n\n中国计算机学会推荐际术议  \n\n（软件工程 系统软件 /程序设计语言） \n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nPLDI\nACM SIGPLAN Conference on Programming Language Design & Implementation\nACM\nhttp://dblp.uni-trier.de/db/conf/pldi/\n2\nPOPL\nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages\nACM\nhttp://dblp.uni-trier.de/db/conf/popl/\n3\nFSE/ESEC\nACM SIGSOFT Symposium on the Foundation of Software Engineering/ European Software Engineering Conference\nACM\nhttp://dblp.uni-trier.de/db/conf/sigsoft/\n4\nSOSP\nACM Symposium on Operating Systems Principles\nACM\nhttp://dblp.uni-trier.de/db/conf/sosp/\n5\nOOPSLA\nConference on Object-Oriented Programming Systems, Languages, and Applications\nACM\nhttp://dblp.uni-trier.de/db/conf/oopsla/\n6\nASE\nInternational Conference on Automated Software Engineering\nIEEE/ACM\nhttp://dblp.uni-trier.de/db/conf/kbse/\n7\nICSE\nInternational Conference on Software Engineering\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/icse/\n8\nISSTA\nInternational Symposium on Software Testing and Analysis\nACM\nhttp://dblp.uni-trier.de/db/conf/issta/\n9\nOSDI\nUSENIX Symposium on Operating Systems Design and Implementations\nUSEN\n\nIX\nhttp://dblp.uni-trier.de/db/conf/osdi/\n\n\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nECOOP\nEuropean Conference on Object-Oriented Programming\nAITO\nhttp://dblp.uni-trier.de/db/conf/ecoop/\n2\nETAPS\nEuropean Joint Conferences on Theory and Practice of Software\nSpringer\nhttp://dblp.uni-trier.de/db/conf/etaps/\n3\nICPC\nIEEE International Conference on Program Comprehension\nIEEE\nhttp://dblp.uni-trier.de/db/conf/iwpc/\n4\nRE\nIEEE International Requirement Engineering Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/re/\n5\nCAiSE\nInternational Conference on Advanced Information Systems Engineering\nSpringer\nhttp://dblp.uni-trier.de/db/conf/caise/\n6\nICFP\nInternational Conference on Function Programming\nACM\nhttp://dblp.uni-trier.de/db/conf/icfp/\n7\nLCTES\nInternational Conference on Languages, Compilers and Tools for Embedded Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/lctrts/\n8\nMoDELS\nInternational Conference on Model Driven Engineering Languages and Systems\nACM, IEEE\nhttp://dblp.uni-trier.de/db/conf/models/\n9\nCP\nInternational Conference on Principles and Practice of Constraint Programming\nSpringer\nhttp://dblp.uni-trier.de/db/conf/cp/\n10\nICSOC\nInternational Conference on Service Oriented Computing\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icsoc/\n\n11\nSANER\nInternational Conference on Software Analysis, Evolution, and Reengineering\nIEEE\nhttp://dblp.uni-trier.de/db/conf/wcre/\n12\nICSME\nInternational Conference on Software Maintenance and Evolution\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icsm/\n13\nVMCAI\nInternational Conference on Verification, Model Checking, and Abstract Interpretation\nSpringer\nhttp://dblp.uni-trier.de/db/conf/vmcai/\n14\nICWS\nInternational Conference on Web Services （Research Track）\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icws/\n15\nMiddleware\nInternational Middleware Conference\nACM/IFIP/ USENIX\nhttp://dblp.uni-trier.de/db/conf/middleware/\n16\nSAS\nInternational Static Analysis Symposium\nSpringer\nhttp://dblp.uni-trier.de/db/conf/sas/\n17\nESEM\nInternational Symposium on Empirical Software Engineering and Measurement\nACM/IEEE\nhttp://dblp.uni-trier.de/db/conf/esem/\n18\nFM\nInternational Symposium on Formal Methods\nFME\nhttp://dblp.uni-trier.de/db/conf/fm/\n19\nISSRE\nInternational Symposium on Software Reliability Engineering\nIEEE\nhttp://dblp.uni-trier.de/db/conf/issre/\n20\nHotOS\nUSENIX Workshop on Hot Topics in Operating Systems\nUSENIX\nhttp://dblp.uni-trier.de/db/conf/hotos/\n\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nPEPM\nACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation\nACM\nhttp://dblp.uni-trier.de/db/conf/pepm/\n2\nPASTE\nACMSIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering\nACM\nhttp://dblp.uni-trier.de/db/conf/paste/\n3\nAPLAS\nAsian Symposium on Programming Languages and Systems\nSpringer\nhttp://dblp.uni-trier.de/db/conf/aplas/\n4\nAPSEC\nAsia-Pacific Software Engineering Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/apsec/\n5\nEASE\nEvaluation and Assessment in Software Engineering\nACM\nhttp://dblp.uni-trier.de/db/conf/ease/\n6\nICECCS\nIEEE International Conference on Engineering of Complex Computer Systems\nIEEE\nhttp://dblp.uni-trier.de/db/conf/iceccs/\n7\nICST\nIEEE International Conference on Software Testing, Verification and Validation\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icst/\n8\nISPASS\nIEEE International Symposium on Performance Analysis of Systems and Software\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ispass/\n9\nSCAM\nIEEE International Working Conference on Source Code Analysis and Manipulation\nIEEE\nhttp://dblp.uni-trier.de/db/conf/scam/\n10\nCOMPSAC\nInternational Computer Software and Applications Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/compsac/\n\n11\nICFEM\nInternational Conference on Formal Engineering Methods\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icfem/\n12\nTOOLS\nInternational Conference on Objects, Models, Components, Patterns\nSpringer\nhttp://dblp.uni-trier.de/db/conf/tools/index.html\n13\nSCC\nInternational Conference on Service Computing\nIEEE\nhttp://dblp.uni-trier.de/db/conf/IEEEscc/\n14\nICSSP\nInternational Conference on Software and System Process\nACM\nhttp://dblp.uni-trier.de/db/conf/ispw/\n15\nSEKE\nInternational Conference on Software Engineering and Knowledge Engineering\nKSI\nhttp://dblp.uni-trier.de/db/conf/seke/\n16\nQRS\nInternational Conference on Software Quality, Reliability and Security\nIEEE\nhttps://dblp.uni-trier.de/db/conf/qrs/\n17\nICSR\nInternational Conference on Software Reuse\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icsr/\n18\nICWE\nInternational Conference on Web Engineering\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icwe/\n19\nSPIN\nInternational SPIN Workshop on Model Checking Software\nSpringer\nhttp://dblp.uni-trier.de/db/conf/spin/index.html\n20\nATVA\nInternational Symposium on Automated Technology for Verification and Analysis\nSpringer\nhttp://dblp.uni-trier.de/db/conf/atva/\n21\nLOPSTR\nInternational Symposium on Logic-based Program Synthesis and Transformation\nSpringer\nhttp://dblp.uni-trier.de/db/conf/lopstr/\n22\nTASE\nInternational Symposium on Theoretical Aspects of Software Engineering\nIEEE\nhttp://dblp.uni-trier.de/db/conf/tase/\n23\nMSR\nMining Software Repositories\nIEEE/ACM\nhttp://dblp.uni-trier.de/db/conf/msr/\n24\nREFSQ\nRequirements Engineering: Foundation for Software Quality\nSpringer\nhttp://dblp.uni-trier.de/db/conf/refsq/\n25\nWICSA\nWorking IEEE/IFIP Conference on Software Architecture\nIEEE\nhttp://dblp.uni-trier.de/db/conf/wicsa/\n\n\n(数据库 /数据挖掘 /内容检索 )\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTODS\nACM Transactions on Database Systems\nACM\nhttp://dblp.uni-trier.de/db/journals/tods/\n2\nTOIS\nACM Transactions on Information Systems\nACM\nhttp://dblp.uni-trier.de/db/journals/tois/\n3\nTKDE\nIEEE Transactions on Knowledge and Data Engineering\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tkde/\n4\nVLDBJ\nThe VLDB Journal\nSpringer\nhttp://dblp.uni-trier.de/db/journals/vldb/\n\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTKDD\nACM Transactions on Knowledge Discovery from Data\nACM\nhttp://dblp.uni-trier.de/db/journals/tkdd/\n2\nTWEB\nACM Transactions on the Web\nACM\nhttp://dblp.uni-trier.de/db/journals/tweb/\n3\nAEI\nAdvanced Engineering Informatics\nElsevier\nhttp://dblp.uni-trier.de/db/journals/aei/\n4\nDKE\nData and Knowledge Engineering\nElsevier\nhttp://dblp.uni-trier.de/db/journals/dke/\n5\nDMKD\nData Mining and Knowledge Discovery\nSpringer\nhttp://dblp.uni-trier.de/db/journals/datamine/\n6\nEJIS\nEuropean Journal of Information Systems\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ejis/\n7\nGeoInformatica\nSpringer\nhttp://dblp.uni-trier.de/db/journals/geoinformatica/\n8\nIPM\nInformation Processing and Management\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ipm/\n9\nInformation Sciences\nElsevier\nhttp://dblp.uni-trier.de/db/journals/isci/\n10\nIS\nInformation Systems\nElsevier\nhttp://dblp.uni-trier.de/db/journals/is/\n11\nJASIST\nJournal of the American Society for Information Science and Technology\nAmerican Society for Information Science and Technology\nhttp://dblp.uni-trier.de/db/journals/jasis/\n12\nJWS\nJournal of Web Semantics\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ws/\n13\nKAIS\nKnowledge and Information Systems\nSpringer\nhttp://dblp.uni-trier.de/db/journals/kais/\n\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nDPD\nDistributed and Parallel Databases\nSpringer\nhttp://dblp.uni-trier.de/db/journals/dpd/\n2\nI&M\nInformation and Management\nElsevier\nhttp://dblp.uni-trier.de/db/journals/iam/\n3\nIPL\nInformation Processing Letters\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ipl/\n4\nIR\nInformation Retrieval Journal\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ir/\n5\nIJCIS\nInternational Journal of Cooperative Information Systems\nWorld Scientific\nhttp://dblp.uni-trier.de/db/journals/ijcis/\n6\nIJGIS\nInternational Journal of Geographical Information Science\nTaylor & Francis\nhttp://dblp.uni-trier.de/db/journals/gis/\n7\nIJIS\nInternational Journal of Intelligent Systems\nWiley\nhttp://dblp.uni-trier.de/db/journals/ijis/\n8\nIJKM\nInternational Journal of Knowledge Management\nIGI\nhttp://dblp.uni-trier.de/db/journals/ijkm/\n9\nIJSWIS\nInternational Journal on Semantic Web and Information Systems\nIGI\nhttp://dblp.uni-trier.de/db/journals/ijswis/\n10\nJCIS\nJournal of Computer Information Systems\nIACIS\nhttp://dblp.uni-trier.de/db/journals/jcis/\n11\nJDM\nJournal of Database Management\nIGI-Global\nhttp://dblp.uni-trier.de/db/journals/jdm/\n12\nJGITM\nJournal of Global Information Technology Management\nIvy League Publishing\nhttp://www.tandfonline.com/loi/ugit20#.Vnv35pN97rI\n13\nJIIS\nJournal of Intelligent Information Systems\nSpringer\nhttp://dblp.uni-trier.de/db/journals/jiis/\n14\nJSIS\nJournal of Strategic Information Systems\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jsis/\n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nSIGMOD\nACM Conference on Management of Data\nACM\nhttp://dblp.uni-trier.de/db/conf/sigmod/\n2\nSIGKDD\nACM Knowledge Discovery and Data Mining\nACM\nhttp://dblp.uni-trier.de/db/conf/kdd/\n3\nICDE\nIEEE International Conference on Data Engineering\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icde/\n4\nSIGIR\nInternational Conference on Research on Development in Information Retrieval\nACM\nhttp://dblp.uni-trier.de/db/conf/sigir/\n5\nVLDB\nInternational Conference on Very Large Data Bases\nMorgan Kaufmann/ACM\nhttp://dblp.uni-trier.de/db/conf/vldb/\n\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nCIKM\nACM International Conference on Information and Knowledge Management\nACM\nhttp://dblp.uni-trier.de/db/conf/cikm/\n2\nWSDM\nACM International Conference on Web Search and Data Mining\nACM\nhttp://dblp.uni-trier.de/db/conf/wsdm/\n3\nPODS\nACM Symposium on Principles of Database Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/pods/\n4\nDASFAA\nDatabase Systems for Advanced Applications\nSpringer\nhttp://dblp.uni-trier.de/db/conf/dasfaa/\n5\nECML-PKDD\nEuropean Conference on Machine Learning and Principles and Practice of Knowledge Discovery in Databases\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ecml/ http://dblp.uni-trier.de/db/conf/pkdd/\n6\nISWC\nIEEE International Semantic Web Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/semweb/\n7\nICDM\nInternational Conference on Data Mining\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icdm/\n8\nICDT\nInternational Conference on Database Theory\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icdt/\n9\nEDBT\nInternational Conference on Extending DB Technology\nSpringer\nhttp://dblp.uni-trier.de/db/conf/edbt/\n10\nCIDR\nInternational Conference on Innovative Data Systems Research\nOnline Proceeding\nhttp://dblp.uni-trier.de/db/conf/cidr/\n11\nSDM\nSIAM International Conference on Data Mining\nSIAM\nhttp://dblp.uni-trier.de/db/conf/sdm/\n\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nAPWeb\nAsia Pacific Web Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/apweb/\n2\nDEXA\nDatabase and Expert System Applications\nSpringer\nhttp://dblp.uni-trier.de/db/conf/dexa/\n3\nECIR\nEuropean Conference on IR Research\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ecir/\n4\nESWC\nExtended Semantic Web Conference\nSpringer\nhttp://dblp.uni-trier.de/db/conf/esws/\n5\nWebDB\nInternational ACM Workshop on Web and Databases\nACM\nhttp://dblp.uni-trier.de/db/conf/webdb/\n6\nER\nInternational Conference on Conceptual Modeling\nSpringer\nhttp://dblp.uni-trier.de/db/conf/er/\n7\nMDM\nInternational Conference on Mobile Data Management\nIEEE\nhttp://dblp.uni-trier.de/db/conf/mdm/\n8\nSSDBM\nInternational Conference on Scientific and Statistical DB Management\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ssdbm/\n9\nWAIM\nInternational Conference on Web Age Information Management\nSpringer\nhttp://dblp.uni-trier.de/db/conf/waim/\n10\nSSTD\nInternational Symposium on Spatial and Temporal Databases\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ssd/\n11\nPAKDD\nPacific-Asia Conference on Knowledge Discovery and Data Mining\nSpringer\nhttp://dblp.uni-trier.de/db/conf/pakdd/\n12\nWISE\nWeb Information Systems Engineering\nSpringer\nhttp://dblp.uni-trier.de/db/conf/wise/\n\n（计算机科学理论） \n\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTIT\nIEEE Transactions on Information Theory\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tit/\n2\nIANDC\nInformation and Computation\nElsevier\nhttp://dblp.uni-trier.de/db/journals/iandc/\n3\nSICOMP\nSIAM Journal on Computing\nSIAM\nhttp://dblp.uni-trier.de/db/journals/siamcomp/\n\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTALG\nACM Transactions on Algorithms\nACM\nhttp://dblp.uni-trier.de/db/journals/talg/\n2\nTOCL\nACM Transactions on Computational Logic\nACM\nhttp://dblp.uni-trier.de/db/journals/tocl/\n3\nTOMS\nACM Transactions on Mathematical Software\nACM\nhttp://dblp.uni-trier.de/db/journals/toms/\n4\nAlgorithmica\nAlgorithmica\nSpringer\nhttp://dblp.uni-trier.de/db/journals/algorithmica/\n5\nCC\nComputational Complexity\nSpringer\nhttp://dblp.uni-trier.de/db/journals/cc/\n6\nFAC\nFormal Aspects of Computing\nSpringer\nhttp://dblp.uni-trier.de/db/journals/fac/\n7\nFMSD\nFormal Methods in System Design\nSpringer\nhttp://dblp.uni-trier.de/db/journals/fmsd/\n8\nINFORMS\nINFORMS Journal on Computing\nINFORMS\nhttp://dblp.uni-trier.de/db/journals/informs/\n9\nJCSS\nJournal of Computer and System Sciences\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jcss/\n10\nJGO\nJournal of Global Optimization\nSpringer\nhttp://dblp.uni-trier.de/db/journals/jgo/\n11\nJSC\nJournal of Symbolic Computation\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jsc/\n12\nMSCS\nMathematical Structures in Computer Science\nCambridge University Press\nhttp://dblp.uni-trier.de/db/journals/mscs/\n13\nTCS\nTheoretical Computer Science\nElsevier\nhttp://dblp.uni-trier.de/db/journals/tcs/\n\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nACTA\nActa Informatica\nSpringer\nhttp://dblp.uni-trier.de/db/journals/acta/\n2\nAPAL\nAnnals of Pure and Applied Logic\nElsevier\nhttp://dblp.uni-trier.de/db/journals/apal/\n3\nDAM\nDiscrete Applied Mathematics\nElsevier\nhttp://dblp.uni-trier.de/db/journals/dam/\n4\nFUIN\nFundamenta Informaticae\nIOS Press\nhttp://dblp.uni-trier.de/db/journals/fuin/\n5\nLISP\nHigher-Order and Symbolic Computation\nSpringer\nhttp://dblp.uni-trier.de/db/journals/lisp/\n6\nIPL\nInformation Processing Letters\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ipl/\n7\nJCOMPLEXITY\nJournal of Complexity\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jc/\n8\nLOGCOM\nJournal of Logic and Computation\nOxford University Press\nhttp://dblp.uni-trier.de/db/journals/logcom/\n9\nJSL\nJournal of Symbolic Logic\nAssociation for Symbolic Logic\nhttp://dblp.uni-trier.de/db/journals/jsyml/\n10\nLMCS\nLogical Methods in Computer Science\nLMCS\nhttp://dblp.uni-trier.de/db/journals/lmcs/\n11\nSIDMA\nSIAM Journal on Discrete Mathematics\nSIAM\nhttp://dblp.uni-trier.de/db/journals/siamdm/\n12\nTheory of Computing Systems\nSpringer\nhttp://dblp.uni-trier.de/db/journals/mst/\n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nSTOC\nACM Symposium on the Theory of Computing\nACM\nhttp://dblp.uni-trier.de/db/conf/stoc/\n2\nSODA\nACM-SIAM Symposium on Discrete Algorithms\nSIAM\nhttp://dblp.uni-trier.de/db/conf/soda/\n3\nCAV\nComputer Aided Verification\nSpringer\nhttp://dblp.uni-trier.de/db/conf/cav/\n4\nFOCS\nIEEE Annual Symposium on Foundations of Computer Science\nIEEE\nhttp://dblp.uni-trier.de/db/conf/focs/\n5\nLICS\nIEEE Symposium on Logic in Computer Science\nIEEE\nhttp://dblp.uni-trier.de/db/conf/lics/\n\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nSoCG\nACM Symposium on Computational Geometry\nACM\nhttp://dblp.uni-trier.de/db/conf/compgeom/\n2\nESA\nEuropean Symposium on Algorithms\nSpringer\nhttp://dblp.uni-trier.de/db/conf/esa/\n3\nCCC\nIEEE Conference on Computational Complexity\nIEEE\nhttp://dblp.uni-trier.de/db/conf/coco/\n4\nICALP\nInternational Colloquium on Automata, Languages and Programming\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icalp/\n5\nCADE/IJCAR\nInternational Conference on Automated Deduction/International Joint Conference on Automated Reasoning\nSpringer\nhttp://dblp.uni-trier.de/db/conf/cade/\n6\nCONCUR\nInternational Conference on Concurrency Theory\nSpringer\nhttp://dblp.uni-trier.de/db/conf/concur/\n7\nHSCC\nInternational Conference on Hybrid Systems: Computation and Control\nSpringer and ACM\nhttp://dblp.uni-trier.de/db/conf/hybrid/\n8\nSAT\nTheory and Applications of Satisfiability Testing\nSpringer\nhttp://dblp.uni-trier.de/db/conf/sat/\n\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nCSL\nComputer Science Logic\nSpringer\nhttp://dblp.uni-trier.de/db/conf/csl/\n2\nFMCAD\nFormal Methods in Computer-Aided Design\nACM\nhttp://dblp.uni-trier.de/db/conf/fmcad/\n3\nFSTTCS\nFoundations of Software Technology and Theoretical Computer Science\nIndian Association for Research in Computing Science\nhttp://dblp.uni-trier.de/db/conf/fsttcs/\n4\nDSAA\nIEEE International Conference on Data Science and Advanced Analytics\nIEEE\nhttps://dblp.uni-trier.de/db/conf/dsaa/\n5\nICTAC\nInternational Colloquium on Theoretical Aspects of Computing\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ictac/\n6\nIPCO\nInternational Conference on Integer Programming and Combinatorial Optimization\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ipco/\n7\nRTA\nInternational Conference on Rewriting Techniques and Applications\nSpringer\nhttp://dblp.uni-trier.de/db/conf/rta/\n8\nISAAC\nInternational Symposium on Algorithms and Computation\nSpringer\nhttp://dblp.uni-trier.de/db/conf/isaac/\n9\nMFCS\nMathematical Foundations of Computer Science\nSpringer\nhttp://dblp.uni-trier.de/db/conf/mfcs/\n10\nSTACS\nSymposium on Theoretical Aspects of Computer Science\nSpringer\nhttp://dblp.uni-trier.de/db/conf/stacs/\n\n（计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体） （计算机图形学与多媒体）\n一、 A类\n序号\n刊物简称\n刊物名称\n出版社\n网址\n1\nTOG\nACM Transactions on Graphics\nACM\nhttp://dblp.uni-trier.de/db/journals/tog/\n2\nTIP\nIEEE Transactions on Image Processing\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tip/\n3\nTVCG\nIEEE Transactions on Visualization and Computer Graphics\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tvcg/\n\n\n二、 B类\n序号\n刊物简称\n刊物名称\n出版社\n网址\n1\nTOMCCAP\nACM Transactions on Multimedia Computing, Communications and Application\nACM\nhttp://dblp.uni-trier.de/db/journals/tomccap/\n2\nCAGD\nComputer Aided Geometric Design\nElsevier\nhttp://dblp.uni-trier.de/db/journals/cagd/\n3\nCGF\nComputer Graphics Forum\nWiley\nhttp://dblp.uni-trier.de/db/journals/cgf/\n4\nCAD\nComputer-Aided Design\nElsevier\nhttp://dblp.uni-trier.de/db/journals/cad/\n5\nGM\nGraphical Models\nElsevier\nhttp://dblp.uni-trier.de/db/journals/cvgip/\n6\nTCSVT\nIEEE Transactions on Circuits and Systems for Video Technology\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tcsv/\n7\nTMM\nIEEE Transactions on Multimedia\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tmm/\n8\nJASA\nJournal of The Acoustical Society of America\nAIP\nhttp://scitation.aip.org/content/asa/journal/jasa\n9\nSIIMS\nSIAM Journal on Imaging Sciences\nSIAM\nhttp://dblp.uni-trier.de/db/journals/siamis/\n10\nSpeech Com\nSpeech Communication\nElsevier\nhttp://dblp.uni-trier.de/db/journals/speech/\n\n三、 C类\n序号\n刊物简称\n刊物名称\n出版社\n网址\n1\nCGTA\nComputational Geometry: Theory and Applications\nElsevier\nhttp://dblp.uni-trier.de/db/journals/comgeo/\n2\nCAVW\nComputer Animation and Virtual Worlds\nWiley\nhttp://onlinelibrary.wiley.com/journal/10.1002/(ISSN)1546-427X\n3\nC&G\nComputers & Graphics\nElsevier\nhttp://dblp.uni-trier.de/db/journals/cg/\n4\nDCG\nDiscrete & Computational Geometry\nSpringer\nhttp://dblp.uni-trier.de/db/journals/dcg/\n5\nSPL\nIEEE Signal Processing Letters\nIEEE\nhttp://dblp.uni-trier.de/db/journals/spl/\n6\nIET-IPR\nIET Image Processing\nIET\nhttp://dblp.uni-trier.de/db/journals/iet-ipr/\n7\nJVCIR\nJournal of Visual Communication and Image Representation\nElsevier\nhttp://dblp.uni-trier.de/db/journals/jvcir/\n8\nMS\nMultimedia Systems\nSpringer\nhttp://dblp.uni-trier.de/db/journals/mms/\n9\nMTA\nMultimedia Tools and Applications\nSpringer\nhttp://dblp.uni-trier.de/db/journals/mta/\n10\nSignal Processing\nElsevier\nhttp://dblp.uni-trier.de/db/journals/sigpro/\n11\nSPIC\nSignal Processing: Image Communication\nElsevier\nhttp://dblp.uni-trier.de/db/journals/spic/\n12\nTVC\nThe Visual Computer\nSpringer\nhttp://dblp.uni-trier.de/db/journals/vc/\n\n一、 A类\n序号\n会议简称\n会议名称\n出版社\n网址\n1\nACM MM\nACM International Conference on Multimedia\nACM\nhttp://dblp.uni-trier.de/db/conf/mm/\n2\nSIGGRAPH\nACM SIGGRAPH Annual Conference\nACM\nhttp://dblp.uni-trier.de/db/conf/siggraph/index.html\n3\nVR\nIEEE Virtual Reality\nIEEE\nhttp://dblp.uni-trier.de/db/conf/vr/\n4\nIEEE VIS\nIEEE Visualization Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/visualization/index.html\n\n\n二、 B类\n序号\n会议简称\n会议名称\n出版社\n网址\n1\nICMR\nACM SIGMM International Conference on Multimedia Retrieval\nACM\nhttp://dblp.uni-trier.de/db/conf/mir/\n2\nSI3D\nACM Symposium on Interactive 3D Graphics\nACM\nhttp://dblp.uni-trier.de/db/conf/si3d/\n3\nSCA\nACM/Eurographics Symposium on Computer Animation\nACM\nhttp://dblp.uni-trier.de/db/conf/sca/index.html\n4\nDCC\nData Compression Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/dcc/\n5\nEG\nEurographics\nWiley/ Blackwell\nhttp://dblp.uni-trier.de/db/conf/eurographics/\n6\nEuroVis\nEurographics Conference on Visualization\nACM\nhttp://dblp.uni-trier.de/db/conf/vissym/\n7\nSGP\nEurographics Symposium on Geometry Processing\nWiley/Blackwell\nhttp://dblp.uni-trier.de/db/conf/sgp/\n8\nEGSR\nEurographics Symposium on Rendering\nWiley/Blackwell\nhttp://dblp.uni-trier.de/db/conf/rt/\n9\nICASSP\nIEEE International Conference on Acoustics, Speech and SP\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icassp/\n10\nICME\nIEEE International Conference on Multimedia & Expo\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icmcs/\n11\nISMAR\nInternational Symposium on Mixed and Augmented Reality\nIEEE/ACM\nhttp://dblp.uni-trier.de/db/conf/ismar/\n12\nPG\nPacific Graphics: The Pacific Conference on Computer Graphics and Applications\nWiley/Blackwell\nhttp://dblp.uni-trier.de/db/conf/pg/index.html\n\n\n13\nSPM\nSymposium on Solid and Physical Modeling\nSMA/Elsevier\nhttp://dblp.uni-trier.de/db/conf/sma/\n\n三、 C类\n序号\n会议简称\n会议名称\n出版社\n网址\n1\nACM Symposium on Virtual Reality Software and Technology\nACM\nhttp://dblp2.uni-trier.de/db/conf/vrst/\n2\nCASA\nComputer Animation and Social Agents\nWiley\nhttp://dblp.uni-trier.de/db/conf/ca/\n3\nCGI\nComputer Graphics International\nSpringer\nhttp://dblp.uni-trier.de/db/conf/cgi/\n4\nINTERSPEECH\nConference of the International Speech Communication Association\nhttp://dblp.uni-trier.de/db/conf/interspeech/index.html\n5\nGMP\nGeometric Modeling and Processing\nElsevier\nhttp://dblp.uni-trier.de/db/conf/gmp/\n6\nPacificVis\nIEEE Pacific Visualization Symposium\nIEEE\nhttp://dblp.uni-trier.de/db/conf/apvis/\n7\n3DV\nInternational Conference on 3D Vision\nIEEE\nhttps://dblp.uni-trier.de/db/conf/3dim/\n8\nCAD/Graphics\nInternational Conference on Computer-Aided Design and Computer Graphics\nIEEE\nhttps://dblp.uni-trier.de/db/conf/cadgraphics/\n9\nICIP\nInternational Conference on Image Processing\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icip/\n10\nMMM\nInternational Conference on Multimedia Modeling\nSpringer\nhttp://dblp.uni-trier.de/db/conf/mmm/index.html\n11\nPCM\nPacific-Rim Conference on Multimedia\nSpringer\nhttp://dblp.uni-trier.de/db/conf/pcm/\n12\nSMI\nShape Modeling International\nIEEE\nhttp://dblp.uni-trier.de/db/conf/smi/\n\n\n（人工智能）\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nAI\nArtificial Intelligence\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ai/\n2\nTPAMI\nIEEE Trans on Pattern Analysis and Machine Intelligence\nIEEE\nhttp://dblp.uni-trier.de/db/journals/pami/\n3\nIJCV\nInternational Journal of Computer Vision\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ijcv/\n4\nJMLR\nJournal of Machine Learning Research\nMIT Press\nhttp://dblp.uni-trier.de/db/journals/jmlr/\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTAP\nACM Transactions on Applied Perception\nACM\nhttp://dblp.uni-trier.de/db/journals/tap/\n2\nTSLP\nACM Transactions on Speech and Language Processing\nACM\nhttp://dblp.uni-trier.de/db/journals/tslp/\n3\nAAMAS\nAutonomous Agents and Multi-Agent Systems\nSpringer\nhttp://dblp.uni-trier.de/db/journals/aamas/\n4\nComputational Linguistics\nMIT Press\nhttp://dblp.uni-trier.de/db/journals/coling/\n5\nCVIU\nComputer Vision and Image Understanding\nElsevier\nhttp://dblp.uni-trier.de/db/journals/cviu/\n6\nDKE\nData and Knowledge Engineering\nElsevier\nhttp://dblp.uni-trier.de/db/journals/dke/index.html\n7\nEvolutionary Computation\nMIT Press\nhttp://dblp.uni-trier.de/db/journals/ec/\n8\nTAC\nIEEE Transactions on Affective Computing\nIEEE\nhttp://dblp.uni-trier.de/db/journals/taffco/\n9\nTASLP\nIEEE Transactions on Audio, Speech, and Language Processing\nIEEE\nhttp://dblp.uni-trier.de/db/journals/taslp/\n10\nIEEE Transactions on Cybernetics\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tcyb/\n11\nTEC\nIEEE Transactions on Evolutionary Computation\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tec/\n12\nTFS\nIEEE Transactions on Fuzzy Systems\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tfs/\n13\nTNNLS\nIEEE Transactions on Neural Networks and learning systems\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tnn/\n14\nIJAR\nInternational Journal of Approximate Reasoning\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ijar/\n\n\n\n15\nJAIR\nJournal of Artificial Intelligence Research\nAAAI\nhttp://dblp.uni-trier.de/db/journals/jair/index.html\n16\nJournal of Automated Reasoning\nSpringer\nhttp://dblp.uni-trier.de/db/journals/jar/\n17\nJSLHR\nJournal of Speech, Language, and Hearing Research\nAmerican Speech-Language Hearing Association\nhttp://jslhr.pubs.asha.org/\n18\nMachine Learning\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ml/\n19\nNeural Computation\nMIT Press\nhttp://dblp.uni-trier.de/db/journals/neco/\n20\nNeural Networks\nElsevier\nhttp://dblp.uni-trier.de/db/journals/nn/\n21\nPR\nPattern Recognition\nElsevier\nhttp://dblp.uni-trier.de/db/conf/par/\n\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTALLIP\nACM Transactions on Asian and Low-Resource Language Information Processing\nACM\nhttp://dblp.uni-trier.de/db/journals/talip/\n2\nApplied Intelligence\nSpringer\nhttp://dblp.uni-trier.de/db/journals/apin/\n3\nAIM\nArtificial Intelligence in Medicine\nElsevier\nhttp://dblp.uni-trier.de/db/journals/artmed/\n4\nArtificial Life\nMIT Press\nhttp://dblp.uni-trier.de/db/journals/alife/\n5\nComputational Intelligence\nWiley\nhttp://dblp.uni-trier.de/db/journals/ci/\n6\nComputer Speech and Language\nElsevier\nhttp://dblp.uni-trier.de/db/journals/csl/\n7\nConnection Science\nTaylor & Francis\nhttp://dblp.uni-trier.de/db/journals/connection/\n8\nDSS\nDecision Support Systems\nElsevier\nhttp://dblp.uni-trier.de/db/journals/dss/\n9\nEAAI\nEngineering Applications of Artificial Intelligence\nElsevier\nhttp://dblp.uni-trier.de/db/journals/eaai/\n10\nExpert Systems\nBlackwell/Wiley\nhttp://dblp.uni-trier.de/db/journals/es/\n11\nESWA\nExpert Systems with Applications\nElsevier\nhttp://dblp.uni-trier.de/db/journals/eswa/\n12\nFuzzy Sets and Systems\nElsevier\nhttp://dblp.uni-trier.de/db/journals/fss/\n13\nTG\nIEEE Transactions on Games\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tciaig/\n14\nIET-CVI\nIET Computer Vision\nIET\nhttp://digital-library.theiet.org/content/journals/iet-cvi\n15\nIET Signal Processing\nIET\n* http://digital-library.theiet.org/content/journals/iet-spr\n16\nIVC\nImage and Vision Computing\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ivc/\n\n17\nIDA\nIntelligent Data Analysis\nIOS Press\nhttp://dblp.uni-trier.de/db/journals/ida/\n18\nIJCIA\nInternational Journal of Computational Intelligence and Applications\nWorld Scientific\nhttp://dblp.uni-trier.de/db/journals/ijcia/\n19\nIJIS\nInternational Journal of Intelligent Systems\nWiley\nhttp://dblp.uni-trier.de/db/journals/ijis/\n20\nIJNS\nInternational Journal of Neural Systems\nWorld Scientific\nhttp://dblp.uni-trier.de/db/journals/ijns/\n21\nIJPRAI\nInternational Journal of Pattern Recognition and Artificial Intelligence\nWorld Scientific\nhttp://dblp.uni-trier.de/db/journals/ijprai/\n22\nIJUFKS\nInternational Journal of Uncertainty, Fuzziness and Knowledge-Based System\nWorld Scientific\nhttps://dblp.uni-trier.de/db/journals/ijufks/\n23\nIJDAR\nInternational Journal on Document Analysis and Recognition\nSpringer\nhttp://dblp.uni-trier.de/db/journals/ijdar/\n24\nJETAI\nJournal of Experimental and Theoretical Artificial Intelligence\nTaylor & Francis\nhttp://dblp.uni-trier.de/db/journals/jetai/\n25\nKBS\nKnowledge-Based Systems\nElsevier\nhttp://dblp.uni-trier.de/db/journals/kbs/\n26\nMachine Translation\nSpringer\nhttp://dblp.uni-trier.de/db/journals/mt/\n27\nMachine Vision and Applications\nSpringer\nhttp://dblp.uni-trier.de/db/journals/mva/\n28\nNatural Computing\nSpringer\nhttp://dblp.uni-trier.de/db/journals/nc/\n29\nNLE\nNatural Language Engineering\nCambridge University Press\nhttp://dblp.uni-trier.de/db/journals/nle/\n30\nNCA\nNeural Computing & Applications\nSpringer\nhttp://dblp.uni-trier.de/db/journals/nca/\n31\nNPL\nNeural Processing Letters\nSpringer\nhttp://dblp.uni-trier.de/db/journals/npl/\n32\nNeurocomputing\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ijon/\n\n33\nPAA\nPattern Analysis and Applications\nSpringer\nhttp://dblp.uni-trier.de/db/journals/paa/\n34\nPRL\nPattern Recognition Letters\nElsevier\nhttp://dblp.uni-trier.de/db/journals/prl/\n35\nSoft Computing\nSpringer\nhttp://dblp.uni-trier.de/db/journals/soco/\n36\nWI\nWeb Intelligence\nIOS Press\nhttp://dblp.uni-trier.de/db/journals/wias/\n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nAAAI\nAAAI Conference on Artificial Intelligence\nAAAI\nhttp://dblp.uni-trier.de/db/conf/aaai/\n2\nNeurIPS\nAnnual Conference on Neural Information Processing Systems\nMIT Press\nhttp://dblp.uni-trier.de/db/conf/nips/\n3\nACL\nAnnual Meeting of the Association for Computational Linguistics\nACL\nhttp://dblp.uni-trier.de/db/conf/acl/\n4\nCVPR\nIEEE Conference on Computer Vision and Pattern Recognition\nIEEE\nhttp://dblp.uni-trier.de/db/conf/cvpr/\n5\nICCV\nInternational Conference on Computer Vision\nIEEE\nhttp://dblp.uni-trier.de/db/conf/iccv/\n6\nICML\nInternational Conference on Machine Learning\nACM\nhttp://dblp.uni-trier.de/db/conf/icml/\n7\nIJCAI\nInternational Joint Conference on Artificial Intelligence\nMorgan Kaufmann\nhttp://dblp.uni-trier.de/db/conf/ijcai/\n\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nCOLT\nAnnual Conference on Computational Learning Theory\nSpringer\nhttp://dblp.uni-trier.de/db/conf/colt/\n2\nEMNLP\nConference on Empirical Methods in Natural Language Processing\nACL\nhttp://dblp.uni-trier.de/db/conf/emnlp/\n3\nECAI\nEuropean Conference on Artificial Intelligence\nIOS Press\nhttp://dblp.uni-trier.de/db/conf/ecai/\n4\nECCV\nEuropean Conference on Computer Vision\nSpringer\nhttp://dblp.uni-trier.de/db/conf/eccv/\n5\nICRA\nIEEE International Conference on Robotics and Automation\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icra/\n6\nICAPS\nInternational Conference on Automated Planning and Scheduling\nAAAI\nhttp://dblp.uni-trier.de/db/conf/aips/\n7\nICCBR\nInternational Conference on Case-Based Reasoning and Development\nSpringer\nhttp://dblp.uni-trier.de/db/conf/iccbr/\n8\nCOLING\nInternational Conference on Computational Linguistics\nACM\nhttp://dblp.uni-trier.de/db/conf/coling/\n\n9\nKR\nInternational Conference on Principles of Knowledge Representation and Reasoning\nMorgan Kaufmann\nhttp://dblp.uni-trier.de/db/conf/kr/\n10\nUAI\nInternational Conference on Uncertainty in Artificial Intelligence\nAUAI\nhttp://dblp.uni-trier.de/db/conf/uai/\n11\nAAMAS\nInternational Joint Conference on Autonomous Agents and Multi-agent Systems\nSpringer\nhttp://dblp.uni-trier.de/db/conf/atal/index.html\n12\nPPSN\nParallel Problem Solving from Nature\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ppsn/\n\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nAISTATS\nArtificial Intelligence and Statistics\nJMLR\nhttp://dblp.uni-trier.de/db/conf/aistats/\n2\nACCV\nAsian Conference on Computer Vision\nSpringer\nhttp://dblp.uni-trier.de/db/conf/accv/\n3\nACML\nAsian Conference on Machine Learning\nJMLR\nhttp://dblp.uni-trier.de/db/conf/acml/\n4\nBMVC\nBritish Machine Vision Conference\nBritish Machine Vision Association\nhttp://dblp.uni-trier.de/db/conf/bmvc/\n5\nNLPCC\nCCF International Conference on Natural Language Processing and Chinese Computing\nSpringer\nhttps://dblp.uni-trier.de/db/conf/nlpcc/\n6\nCoNLL\nConference on Computational Natural Language Learning\nAssociation for Computational Linguistics\nhttp://dblp.uni-trier.de/db/conf/conll\n7\nGECCO\nGenetic and Evolutionary Computation Conference\nACM\nhttp://dblp.uni-trier.de/db/conf/gecco/\n8\nICTAI\nIEEE International Conference on Tools with Artificial Intelligence\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ictai/\n9\nIROS\nIEEE\\RSJ International Conference on Intelligent Robots and Systems\nIEEE\nhttp://dblp.uni-trier.de/db/conf/iros/\n10\nALT\nInternational Conference on Algorithmic Learning Theory\nSpringer\nhttp://dblp.uni-trier.de/db/conf/alt/\n11\nICANN\nInternational Conference on Artificial Neural Networks\nSpringer\nhttp://dblp.uni-trier.de/db/conf/icann/\n12\nFG\nInternational Conference on Automatic Face and Gesture Recognition\nIEEE\nhttp://dblp.uni-trier.de/db/conf/fgr/\n\n13\nICDAR\nInternational Conference on Document Analysis and Recognition\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icdar/\n14\nILP\nInternational Conference on Inductive Logic Programming\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ilp/\n15\nKSEM\nInternational conference on Knowledge Science, Engineering and Management\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ksem/\n16\nICONIP\nInternational Conference on Neural Information Processing\nSpringer\nhttp://dblp.uni-trier.de/db/conf/iconip/\n17\nICPR\nInternational Conference on Pattern Recognition\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icpr/\n18\nICB\nInternational Joint Conference on Biometrics\nIEEE\nhttp://dblp.uni-trier.de/db/conf/icb/\n19\nIJCNN\nInternational Joint Conference on Neural Networks\nIEEE\nhttp://dblp.uni-trier.de/db/conf/ijcnn/\n20\nPRICAI\nPacific Rim International Conference on Artificial Intelligence\nSpringer\nhttp://dblp.uni-trier.de/db/conf/pricai/\n21\nNAACL\nThe Annual Conference of the North American Chapter of the Association for Computational Linguistics\nNAACL\nhttp://dblp.uni-trier.de/db/conf/naacl/\n\n（人机交互与普适计算） \n\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nTOCHI\nACM Transactions on Computer-Human Interaction\nACM\nhttp://dblp.uni-trier.de/db/journals/tochi/\n2\nIJHCS\nInternational Journal of Human Computer Studies\nElsevier\nhttp://dblp.uni-trier.de/db/journals/ijmms/\n\n\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nCSCW\nComputer Supported Cooperative Work\nSpringer\nhttp://dblp.uni-trier.de/db/journals/cscw/\n2\nHCI\nHuman Computer Interaction\nTaylor & Francis\nhttp://dblp.uni-trier.de/db/journals/hhci/\n3\nIEEE Transactions on Human-Machine Systems\nIEEE\nhttp://dblp.uni-trier.de/db/journals/thms/\n4\nIWC\nInteracting with Computers\nOxford University Press\nhttp://dblp.uni-trier.de/db/journals/iwc/\n5\nIJHCI\nInternational Journal of Human-Computer Interaction\nTaylor & Francis\nhttp://dblp.uni-trier.de/db/journals/ijhci/\n6\nUMUAI\nUser Modeling and User-Adapted Interaction\nSpringer\nhttp://dblp.uni-trier.de/db/journals/umuai/\n\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nBIT\nBehaviour & Information Technology\nTaylor & Francis\nhttp://dblp.uni-trier.de/db/journals/behaviourIT/\n2\nPUC\nPersonal and Ubiquitous Computing\nSpringer\nhttp://dblp.uni-trier.de/db/journals/puc/\n3\nPMC\nPervasive and Mobile Computing\nElsevier\nhttp://dblp.uni-trier.de/db/journals/percom/\n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nCSCW\nACM Conference on Computer Supported Cooperative Work and Social Computing\nACM\nhttp://dblp.uni-trier.de/db/conf/cscw\n2\nCHI\nACM Conference on Human Factors in Computing Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/chi\n3\nUbiComp\nACM International Conference on Ubiquitous Computing\nACM\nhttp://dblp.uni-trier.de/db/conf/huc/\n\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nGROUP\nACM Conference on Supporting Group Work\nACM\nhttp://dblp.uni-trier.de/db/conf/group/\n2\nIUI\nACM International Conference on Intelligent User Interfaces\nACM\nhttp://dblp.uni-trier.de/db/conf/iui/\n3\nITS\nACM International Conference on Interactive Tabletops and Surfaces\nACM\nhttp://dblp.uni-trier.de/db/conf/tabletop/\n4\nUIST\nACM Symposium on User Interface Software and Technology\nACM\nhttp://dblp.uni-trier.de/db/conf/uist/\n5\nECSCW\nEuropean Conference on Computer Supported Cooperative Work\nSpringer\nhttp://dblp.uni-trier.de/db/conf/ecscw/\n6\nPERCOM\nIEEE International Conference on Pervasive Computing and Communications\nIEEE\nhttp://dblp.uni-trier.de/db/conf/percom/\n7\nMobileHCI\nInternational Conference on Human Computer Interaction with Mobile Devices and Services\nACM\nhttp://dblp.uni-trier.de/db/conf/mhci/\n\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nDIS\nACM Conference on Designing Interactive Systems\nACM\nhttp://dblp.uni-trier.de/db/conf/ACMdis\n2\nICMI\nACM International Conference on Multimodal Interaction\nACM\nhttp://dblp.uni-trier.de/db/conf/icmi/\n3\nASSETS\nACM SIGACCESS Conference on Computers and Accessibility\nACM\nhttp://dblp.uni-trier.de/db/conf/assets\n4\nGI\nGraphics Interface conference\nACM\nhttp://dblp.uni-trier.de/db/conf/graphicsinterface/\n5\nUIC\nIEEE International Conference on Ubiquitous Intelligence and Computing\nIEEE\nhttp://dblp.uni-trier.de/db/conf/uic/\n6\nIEEE World Haptics Conference\nIEEE\nhttp://dblp.uni-trier.de/db/conf/haptics/\n7\nINTERACT\nIFIP TC13 Conference on Human-Computer Interaction\nIFIP\nhttp://dblp.uni-trier.de/db/conf/interact/\n8\nIDC\nInteraction Design and Children\nACM\nhttp://dblp.uni-trier.de/db/conf/acmidc/\n9\nCollaborateCom\nInternational Conference on Collaborative Computing: Networking, Applications and Worksharing\nSpringer\nhttp://collaboratecom.org\n10\nCSCWD\nInternational Conference on Computer Supported Cooperative Work in Design\nSpringer\nhttp://dblp.uni-trier.de/db/conf/cscwd/\n11\nCoopIS\nInternational Conference on Cooperative Information Systems\nSpringer\nhttp://dblp.uni-trier.de/db/conf/coopis/\n12\nMobiQuitous\nInternational Conference on Mobile and Ubiquitous Systems: Computing, Networking and Services\nSpringer\nhttp://dblp.uni-trier.de/db/conf/mobiquitous/\n13\nAVI\nInternational Working Conference on Advanced Visual Interfaces\nACM\nhttp://dblp.uni-trier.de/db/conf/avi/\n\n（交叉 /综合 /新兴）\n\n一、 A类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nJACM\nJournal of the ACM\nACM\nhttp://dblp.uni-trier.de/db/journals/jacm/\n2\nProc. IEEE\nProceedings of the IEEE\nIEEE\nhttp://dblp.uni-trier.de/db/journals/pieee/\n\n\n二、 B类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nBioinformatics\nOxford University Press\nhttp://dblp.uni-trier.de/db/journals/bioinformatics/\n2\nBriefings in Bioinformatics\nOxford University Press\nhttp://dblp.uni-trier.de/db/journals/bib/\n3\nCognition\nCognition：International Journal of Cognitive Science\nElsevier\nhttp://www.journals.elsevier.com/cognition/\n4\nTASAE\nIEEE Transactions on Automation Science and Engineering\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tase/\n5\nTGARS\nIEEE Transactions on Geoscience and Remote Sensing\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tgrs/\n6\nTITS\nIEEE Transactions on Intelligent Transportation Systems\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tits/\n7\nTMI\nIEEE Transactions on Medical Imaging\nIEEE\nhttp://dblp.uni-trier.de/db/journals/tmi/\n8\nTR\nIEEE Transactions on Robotics\nIEEE\nhttp://dblp.uni-trier.de/db/journals/trob/\n9\nTCBB\nIEEE-ACM Transactions on Computational Biology and Bioinformatics\nIEEE/ACM\nhttp://dblp.uni-trier.de/db/journals/tcbb/\n10\nJCST\nJournal of Computer Science and Technology\nSCIENCE PRESS/Springer\nhttp://dblp.uni-trier.de/db/journals/jcst/\n11\nJAMIA\nJournal of the American Medical Informatics Association\nBMJ Journals\nhttp://dblp.uni-trier.de/db/journals/jamia/\n12\nPLOS Computational Biology\nPublic Library of Science\nhttp://dblp.uni-trier.de/db/journals/ploscb/\n13\nScience China Information Sciences\nScience in China Press/Springer\nhttp://dblp.uni-trier.de/db/journals/chinaf/\n14\nThe Computer Journal\nOxford University Press\nhttp://dblp.uni-trier.de/db/journals/cj/\n\n15\nWorld Wide Web Journal\nSpringer\nhttp://dblp.uni-trier.de/db/journals/wwwj/\n\n\n三、 C类\n序号\n刊物简称\n刊物全称\n出版社\n网址\n1\nBMC Bioinformatics\nBioMed Central\nhttp://dblp.uni-trier.de/db/journals/bmcbi/\n2\nCybernetics and Systems\nTaylor & Francis\nhttp://dblp.uni-trier.de/db/journals/cas/\n3\nFCS\nFrontiers of Computer Science\nHigher Education Press\nhttp://dblp.uni-trier.de/db/journals/fcsc/\n4\nIEEE Geoscience and Remote Sensing Letters\nIEEE\nhttp://dblp.uni-trier.de/db/journals/lgrs/\n5\nJBHI\nIEEE Journal of Biomedical and Health Informatics\nIEEE\nhttp://dblp.uni-trier.de/db/journals/titb/\n6\nTBD\nIEEE Transactions on Big Data\nIEEE\nhttps://dblp.uni-trier.de/db/journals/tbd/\n7\nIET Intelligent Transport Systems\nIET\nhttp://digital-library.theiet.org/content/journals/iet-its\n8\nJBI\nJournal of Biomedical Informatics\nElsevier\nhttps://dblp.uni-trier.de/db/journals/jbi/\n9\nMedical Image Analysis\nElsevier\nhttp://dblp.uni-trier.de/db/journals/mia/\n\n一、 A类\n序号\n会议简称\n会议全称\n出版社\n网站\n1\nWWW\nInternational World Wide Web Conferences\nACM\nhttp://dblp.uni-trier.de/db/conf/www/\n2\nRTSS\nReal-Time Systems Symposium\nIEEE\nhttp://dblp.uni-trier.de/db/conf/rtss/\n\n二、 B类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nCogSci\nCognitive Science Society Annual Conference\nPsychology Press\nhttps://dblp.uni-trier.de/db/conf/cogsci/\n2\nBIBM\nIEEE International Conference on Bioinformatics and Biomedicine\nIEEE\nhttp://dblp.uni-trier.de/db/conf/bibm/\n3\nEMSOFT\nInternational Conference on Embedded Software\nACM/IEEE/IFIP\nhttp://dblp.uni-trier.de/db/conf/emsoft/\n4\nISMB\nInternational conference on Intelligent Systems for Molecular Biology\nOxford Journals\nhttp://www.iscb.org/about-ismb\n5\nRECOMB\nInternational Conference on Research in Computational Molecular Biology\nSpringer\nhttp://dblp.uni-trier.de/db/conf/recomb/\n\n\n三、 C类\n序号\n会议简称\n会议全称\n出版社\n网址\n1\nAMIA\nAmerican Medical Informatics Association Annual Symposium\nAMIA\nhttp://dblp.uni-trier.de/db/conf/amia/\n2\nAPBC\nAsia Pacific Bioinformatics Conference\nBioMed Central\nhttp://dblp.uni-trier.de/db/conf/apbc/\n3\nIEEE International Conference on Big Data\nIEEE\nhttps://dblp.uni-trier.de/db/conf/bigdataconf/\n4\nIEEE International Conference on Cloud Computing\nIEEE\nhttp://dblp.uni-trier.de/db/conf/IEEEcloud/\n5\nSMC\nIEEE International Conference on Systems, Man, and Cybernetics\nIEEE\nhttps://dblp.uni-trier.de/db/conf/smc/\n6\nCOSIT\nInternational Conference on Spatial Information Theory\nACM\nhttp://dblp.uni-trier.de/db/conf/cosit/\n7\nISBRA\nInternational Symposium on Bioinformatics Research and Applications\nSpringer\nhttps://dblp.uni-trier.de/db/conf/isbra/\n\n\n\n"
        },
        {
          "name": "乒乓缓存和消息分发C代码实现.pdf",
          "type": "blob",
          "size": 175.4765625,
          "content": null
        },
        {
          "name": "内存分配.md",
          "type": "blob",
          "size": 5.2734375,
          "content": "# (1)C语言跟内存分配方式\n\n## <1>从静态存储区域分配.\n       内存在程序编译的时候就已经分配好，\n       这块内存在程序的整个运行期间都存在.例如全局变量、static变量.\n       \n## <2>在栈上创建\n       在执行函数时，函数内局部变量的存储单元都可以在栈上创建，\n       函数执行结束时这些存储单元 自动被释放.\n       栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限.\n\n## <3>从堆上分配，亦称动态内存分配.\n       程序在运行的时候用malloc或new申请任意多少的内存，\n       程序员自己负责在何时用free或delete释放内存.\n       动态内存的生存期由用户决定，使用非常灵活，但问题也最多.\n\n\n# (2) C语言跟内存申请相关的函数主要有 alloca、calloc、malloc、free、realloc等.\n    <1> alloca 是向栈申请内存, 因此无需释放.\n    <2> malloc 分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.\n    <3> calloc 则将初始化这部分的内存,设置为0.\n    <4> realloc 则对malloc申请的内存进行大小的调整.\n    <5> 申请的内存最终需要通过函数free来释放.\n    \n    当程序运行过程中 malloc 了, 但是没有 free 的话, 会造成内存泄漏.\n    一部分的内存没有被使用, 但是由于没有free, 因此系统认为这部分内存还在使用,\n    造成不断的向系统申请内存,使得系统可用内存不断减少。\n    \n    但是内存泄漏仅仅指程序在运行时, 程序退出时,OS将回收所有的资源.\n    \n    因此, 适当的重起一下程序, 有时候还是有点作用.\n\n# 【注意 attention】\n    三个函数的申明分别是:\n    \n        void* malloc(unsigned size); // int* int_p_arr = (int*) malloc( 4*sizeof(int) );\n        \n        void* realloc(void* ptr, unsigned newsize);  \n        \n        void* calloc(size_t numElements, size_t sizeOfElement); // int* int_p_arr = (int*)calloc(4, sizeof(int));\n        \n    都在stdlib.h函数库内，它们的返回值都是请求系统分配的地址, 如果请求失败就返回NULL.\n    \n    (1)函数malloc()\n        在内存的动态存储区中分配一块长度为 size 字节 的连续区域，\n        参数size为需要内存空间的长度，返回该区域的首地址.\n        \n    (2)函数calloc()\n        与malloc相似,参数 sizeOfElement 为申请地址的单位元素长度, numElements为元素个数，\n        即在内存中申请 numElements*sizeOfElement 字节大小的连续地址空间.\n    \n    (3)函数realloc()\n        给一个 已经分配了地址的指针 重新分配空间, 参数ptr为原有的空间地址, newsize是重新申请的地址长度.\n        \n    区别:\n    \n    (1)函数 malloc() 不能 初始化 所分配的内存空间, 而函数calloc能.\n       如果由malloc()函数分配的内存空间原来没有被使用过，\n       则其中的每一位可能都是0; \n       反之, 如果这部分内存曾经被分配过, 则其中可能遗留有各种各样的数据.\n       也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,\n       但经过一段时间(内存空间还已经被重新分配)可能会出现问题.\n       malloc之后可以使用 memset()来初始化内存\n       extern void *memset(void *buffer, int c, int count)\n              buffer：为指针或是数组,\n              c：是赋给buffer的值,\n              count：是buffer的长度().\n       int* int_p_arr = (int*) malloc( 4*sizeof(int) );\n       memset( int_p_arr, 0, 4*sizeof(int) )\n       \n    (2)函数 calloc() 会将所分配的内存空间中的每一位都初始化为零,\n       也就是说, 如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;\n       如果你是为指针类型的元素分配内存, 那么这些元素通常会被初始化为空指针;\n       如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零.\n       \n    (3)函数 malloc() 向系统申请分配指定size个字节的内存空间.\n       返回类型是 void*类型.\n       void* 表示未确定类型的指针.\n       C,C++规定，void* 类型可以 强制转换为 任何其它类型的指针.\n       \n    (4)函数 realloc() 可以对给定的指针所指的空间进行扩大或者缩小，\n       无论是扩张或是缩小，原有内存的中内容将保持不变.\n       当然，对于缩小，则被缩小的那一部分的内容会丢失.\n       realloc 并不保证调整后的内存空间和原来的内存空间保持同一内存地址.\n       相反，realloc 返回的指针很可能指向一个新的地址.\n       \n    (5)realloc是从堆上分配内存的.当扩大一块内存空间时，\n       realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；\n       如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，\n       现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.\n       这句话传递的一个重要的信息就是数据可能被移动.\n       \n       \n"
        },
        {
          "name": "容器.md",
          "type": "blob",
          "size": 25.54296875,
          "content": "# 1. 顺序容器 内的元素按其位置存储和访问 (sequential container) vector deque  list forward_list  array  string\n      容器（container），顾名思义表示对象的集合，这些对象的类型都相同，\n      每个对象都有一个自己的索引，用这个索引我们就可以方便的访问该对象了。\n      只有顺序容器的构造函数才接受大小参数，关联容器并不支持。\n      vector   可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。\n               vector<int> vi(10, -1); // 10个-1\n\n      deque    双端队列。支持快速快速访问。在头尾位置插入/删除速度很快。\n               deque<double> deqd(10); // 10个元素 0\n\n      list     双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。\n               list<int> li(5,1); // 5个1\n\n      forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 \n               forward_list<string> fls(10); // 10个元素 0\n\n      array    固定大小数组。支持快速随机访问，不能添加或删除元素。\n               array<int, 42> ia;  // 42个int的数组, 支持拷贝构造\n\t       array<int, 42> ia2 = ia;\n               而内置数组不支持拷贝构造.\n\t       std::array也提供了 at() 函数。\n\n      string   与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入/删除都很快。\n\n## 以下是一些选择容器的基本原则（具体视情况而定，这里只是一般情况）：\n      1、通常vector是最好的选择，除非你有很好的理由选择其他容器；\n      2、如果程序有很多小的元素，且空间额外开销很重要，则不要使用 list 或 forward_list 容器；\n      3、如果程序要求随机访问，应使用 vector 或 deque 容器；\n      4、如果程序要在头尾位置插入/删除，且不会在中间位置进行插入/删除操作，则应使用deque容器。\n      \n##  a. vector 连续存储结构，每个元素在内存上是连续的  尾部插入 push_back() 与 尾部插删除 pop_back()     \n      vector<vector<int>> vvi;//相当于二维数组\n      STL中的vector容器就是动态大小数组。\n      vector<int> v;\n      v.push_back(k); 在后面插入 k 这个元素\n      v.size()\t返回容器中实际元素的个数\n      v.resize()\t重新设定容器的大小\n      v.at(index)\t返回索引位置的元素\n      v.begin()\t返回第一个元素的迭代器 vector<T>::iterator \n      v.end()\t返回最后一个元素后面位置的迭代器\n      v.front()\t返回第一个元素\n      v.back()\t返回最后一个元素\n      v.empty()\t返回1为空，0为非空\n      v.swap()\t交换两容器\n      rbegin()\t返回逆向容器中的第一个元素的迭代器\n      rend()\t返回逆向容器中的最后一个元素后面位置的迭代器\n      clear()\t清除容器中所有元素\n      insert()\t插入\n      max_size()\t返回最大数据量\n      v.erase()\t擦除元素\n\n      #include <vector>       //头文件包含  \n      using namespace std;  //或者using std::vector;  \n      //vector定义并初始化  \n      vector<int> v1;  \n      for (int i=0;i<10;i++)  \n        v1.push_back(i+1);  // 从后面一次插入元素\n      //使用迭代器遍历vector  \n      vector<int>::iterator iter = v1.begin();  \n      for (;iter!=v1.end();iter++)  \n       {  \n        cout<<*iter<<\" \";  \n       } \n      vector容器中存储的元素在内存中是连续存储的。\n      假如容器中没有空间容纳新元素，此时由于元素必须连续存储以便索引访问，\n      所以不能在内存中随便找个地方存储这个新的元素，于是vector必须重新分配空间 v.resize(10)，\n      用于存放原来的元素和新添加的元素：\n      存放在旧容器中的元素被复制到新的容器中，接着插入新的元素，最后撤销旧的存储空间。\n      为了使vector容器实现快速的内存分配，\n      其实际分配的容量要比当前所需的空间多一些，vector容器预留这些空间，用于存放新的元素。\n\n      v.push_back(val)\n      先将容器c中的元素拷贝到新的内存空间中，\n      然后在将val值拷贝到新空间的末尾，\n      最后析构掉原始空间。\n      当push_back检测到空间不足时，将自动以 2倍 的方式扩展空间。\n      对于大量数据来说，这是一个弊端，可以使用可以使用 vector::reserve 方法来改善。\n      push_back()使用 vector::insert 方法实现，在容器尾部insert来实现的。\n      void push_back(_Elem _Ch)  \n      {   // insert element at end  \n       insert(end(), _Ch);  // 算法\n      } \n      pop_back() 使用vector::earse，擦除最后一个位置元素来实现的。\n      删除容器尾部元素，同时c.size()会减少。\n      void pop_back()  \n      {   // erase element at end  \n       erase(this->_Mysize - 1);    // throws if _Mysize == 0  \n      } \n      \n      v.shrink_to_fit();\n      //  为了不让vector浪费太多的内存，我们在最后调用了shrink_to_fit。\n      // 该函数会为元素分配足够的空间，将剩余的元素移到该空间内，并且删除之前那个比较大的内存空间。\n      // 会将多余的空间归还给系统\n      \n      \n### vector 优点：\n\t随机存取，即 vi[i] 操作 和 vi.at(i)。\n\t\n\tat() 函数会检查给定的索引值是否越界，如果越界则返回一个异常。\n\t因为检查越界要花费一些时间，所以at函数会让程序慢一些。\n\t当需要非常快的索引成员时，并能保证索引不越界，我们会使用[]快速访问vector实例。\n\t很多情况下，at() 函数在牺牲一点性能的基础上，有助于发现程序内在的bug。\n\t默认使用 at() 函数时一个好习惯。\n\t当代码的性能很差，但有没有bug存在时，可以使用性能更高的操作符[]来替代at函数。\n\t\n\t动态操作, 尾部插入 vi.push_back() 与 尾部插删除 vi.pop_back()\n\t自动调整内存，节省空间\n\ntry{} catch(){} 捕获 vector访问越界 异常\n```c\ntry{\n   temp = v.at(k);\n}\ncatch(std::out_of_range &e){\n   std::cout << e.what() << std::endl;\n}\n```\n\n\n### vector缺点：\n      实现插入与删除操作效率低\n      只能在尾部插入与删除，在头部插入与删除消耗时间规模与容器大小成正比,它会将后面的元素依次前移。\n      当动态添加的数据超过默认内存大小时，要进行整体的重新分配，拷贝与释放。\n      \n### 快速删除未排序的vector中的元素，最后一个元素替换到需要删除的地方，再 pop_back() 删除最后一个元素\n      注意此操作会改变数组顺序，对于未排序的数组没什么问题，对于已排序的数组不可用，或者删除之后再排序\n```c\n// 输入 vector，和要删除的 元素的索引 idx\ntemplate <typename T>\nvoid quick_remove_at(std::vector<T> &v, std::size_t idx)\n{\n    if (idx < v.size()) // 索引为出界\n    {\n        v[idx] = std::move(v.back());// 最后的元素移动到要删除的位置\n\t// std::move(v.back()); // 避免拷贝，相当于只是拷贝了指针\n\t// *it = v.back();      // 会进行拷贝\n        v.pop_back();           // 删除最后的元素\n    }\n}\n\n// 输入 vector，和要删除的 元素的迭代器 it\ntemplate <typename T>\nvoid quick_remove_at(std::vector<T> &v,\n\t\t\ttypename std::vector<T>::iterator it)\n{\n  if (it != std::end(v))// 迭代器未出界 \n  {\n        *it = std::move(v.back());// 最后的元素移动到要删除的位置\n        v.pop_back();             // 删除最后的元素\n  }\n}\n```\n![](https://github.com/Ewenwan/CPP-17-STL-cookbook/blob/master/images/chapter2/2-2-1.png)\n\n## b. list 双端链表 非连续存储结构，具有双链表结构，支持排序 sort排序\n[list参考](http://blog.csdn.net/qq_22186119/article/details/77937179)\n\n      list容器中添加元素时，只需要创建一个新的元素，\n      然后将该元素连接到已经存在的链表中，\n      不需要重新分配存储空间，也不用复制任何已存在的元素。\n\n      非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。\n      支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。\n      每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。\n      可以不分配必须的内存大小方便的进行添加和删除操作。\n      使用的是非连续的内存空间进行存储。   \n      list<char> lit;   \n      //-----------链表可以从两端插入-------------------        \n      lit.push_back('b');  \n      lit.push_front('d');\n      //-----------链表打印------------------- \n      list<char>::iterator it;    \n      for(it=lit.begin();it!=lit.end();it++)  \n      {  \n        cout<<*it<<\"  \";  \n      }  \n      cout<<endl;  \n      //-----------链表可以从两端删除-------------------   \n      lit.pop_back();    \n      lit.pop_front();  \n      //-------------删除所有的a---------------------------------  \n      //lit.remove('a');  //删除所有的a;  \n      //-----------将list里的数据倒序排列---------------  \n      lit.reverse();  \n      //-------------移除连续且相同的a，只剩下一个;--------------------------------  \n      lit.unique();  //移除连续且相同的a，只剩下一个;  \n      list<char> lit1; \n      list<char>::iterator it1; \n      //-------------将一个链表插入到另一个链表---------------------------------  \n      it1=find(lit.begin(),lit.end(),'f');  //先的找到要插入的位置，在该位置的前一个插入；  \n      ////lit.splice(it1,lit1); //将第二个链lit1表插入到第一个链表lit中；合并后的链表就没了，因为传的是&\n      // 打印函数\n      void printList(const list<int>& a)\n      {\n      // 注意形参中是const list，所以下面也需要用const_iterator\n      // 否则distance无法使用\n      list<int>::const_iterator iter;\n      for (iter = a.begin(); iter != a.end(); ++iter)\n      {// 计算数组下标，distance包含在algorithm中 #include<algorithm>\n        size_t index = distance(a.begin(), iter);\n        cout << \"a[\" << index << \"] = \" << *iter << endl;\n      }\n      cout << endl;\n      }\n\n          list<int> a;\n      // push_front、push_back插入数据\n      a.push_front(4);\n      a.push_front(3);\n      a.push_front(2);\n      a.push_front(1);\n      a.push_back(50);\n      printList(a);\n\n      // insert插入数据\n      list<int>::iterator iter;\n      iter = a.begin();\n      a.insert(iter, 0);\n      a.insert(++iter, 10);\n      a.insert(++iter, 4, 20); // 插入4个20\n      printList(a);\n\n\n      // sort排序\n      cout << \"sort排序\" << endl;\n      a.sort();\n      printList(a);\n\n      // reverse逆序\n      cout << \"reverse逆序\" << endl;\n      a.reverse();\n      printList(a);\n\n      // erase删除指定元素\n      cout << \"erase删除指定元素\" << endl;\n      a.erase(iter);\n      printList(a);\n\n      // erase删除指定区间的元素\n      cout << \"erase删除指定区间元素\" << endl;\n      a.erase(++a.begin(), --a.end());\n      printList(a);\n      \n### list 优点：\n      1）不使用连续内存完成动态操作。\n      2）在内部方便的进行插入和删除操作 动态操作，插入与删除效率高\n      3）可在两端进行push、pop \n      \n### list缺点：\n      1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()\n      2) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()\n\n## c. deque 双端队列 连续存储结构\n      deque连续存储结构，即其每个元素在内存上也是连续的，类似于vector，\n      不同之处在于，deque提供了两级数组结构， 第一级完全类似于vector，代表实际容器；\n      另一级维护容器的首位地址。\n      这样，deque除了具有vector的所有功能外，还支持高效的首/尾端插入/删除操作。\n      deque   双端队列 double-end queue\n      deque是在功能上合并了vector和list。\n      //\n      deque<int> a;\n      // 在末尾插入数据\n      a.push_back(3);\n      a.push_back(4);\n      a.push_back(5);\n      // 在开头插入数据\n      a.push_front(2);\n      a.push_front(1);\n      a.push_front(0);\n      // 以数组方式输出\n      for (size_t n = 0; n < a.size(); ++n)\n        cout << \"a[\" << n << \"] = \" << a[n] << endl;\n      cout << endl;\n      //删除末尾的数据\n      a.pop_back();\n      //删除开头的数据\n      a.pop_front();\n      // 以迭代器方式输出\n      deque<int>::iterator iter;\n      for (iter = a.begin(); iter < a.end(); ++iter)\n      {\n        // 计算数组下标，distance包含在algorithm中 #include<algorithm>\n        int index = distance(a.begin(), iter);\n        cout << \"a[\" << index << \"] = \" << *iter << endl;\n      }\n\n### deque 优点：\n      1）随机访问，即[]操作和deque.at()\n      2) 在内部方便的进行插入和删除操作\n      3）可在双端进行pop，push\n\n### deque 缺点：\n      占用内存多。\n\n\n### vector、deque、list三种容器的特点\n      vector：支持快速随机访问、可高效的在vector容器 尾部    添加删除数据\n      deque：支持快速随机访问、可高效的在deque容器 头部和尾部 添加删除数据\n      list：支持顺序访问，但是在任何位置插入删除元素都很快。\n      相同点：三者都能实现resize（）来重新调整容器的大小。 \n      不同点：\n            1）vector能实现随即存取，即[]操作，而list不能，deque是二者的结合体，也能够实现索引操作[]，但效率没有vector高。\n            2）vector适合在文件的末尾实现删除元素的操作pop_back（）与插入操作push_back（），在中间时效率非常低下。\n               而list可以在容器的任何位置实现插入与删除操作。\n            原因：vector的元素地址连续，如果在中间插入与删除操作，可能会导致原来的内存地址不足以存储当前的元素，\n                  需要重新分配内存地址，这就需要将原来的所有元素拷贝到新内存，释放旧的内存地址等操作，操作代价高昂。\n                  而list元素内存地址不连续，用指针操作，其本身是一个双向链表，它的高效率体现在插入，删除以及排序等移动大量元素的操作。\n\n           a. vector与deque的迭代器支持算术运算，list的迭代器只能进行++/--操作，不支持普通的算术运算。\n           b. 向量中的iterator在使用后就释放了，但是链表list不同，它的迭代器在使用后还可以继续用；链表特有的；\n           \n           \n### 选择容器类型的准则：\n      1）如果需要随机访问一个容器，vector 比 list好\n      2）如果经常 需要 插入或删除 容器元素，list比vector好\n      3）如果既要随机存取，又要关心两端数据的插入与删除，则选择 deque\n      a、若需要随机访问操作，则选择vector；\n      b、若已经知道需要存储元素的数目，则选择vector；\n      c、若需要随机插入/删除（不仅仅在两端），则选择list\n      d、只有需要在首端进行插入/删除操作的时候，还要 兼顾 随机访问效率，才 选择deque， 否则都选择vector。\n      e、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中-deque。\n      f、当要存储的是大型负责类对象时，list要优于vector；\n         当然这时候也可以用vector来存储指向对象的指针，\n         同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。\n      \n\n# 2. 关联容器 按关键字保存和访问  map (key-value键值对，类似字典的概念) set(只包含一个关键字(关键字即值)) \n      map<名字，电话号码>    利用名字来查询电话号码类似电话簿\n      set<bad_checks_name>  定义一个曾经开过空头支票的客户的名字，在接收一张支票前查询其名字是否在其中。\n      只有顺序容器的构造函数才接受大小参数，关联容器并不支持。\n      #include <map>  \n      #include <ext/hash_map>  \n      #include <tr1/unordered_map>  \n      using namespace std;  \n      using namespace std::tr1;  \n      //typedef map<int,int> MapKey;          //采用map  \n      //typedef hash_map<int,int> MapKey;     //采用hash_map  \n      typedef unordered_map<int,int> MapKey;  //采用unordered_map  \n\n## 有序集合 RB树实现 红黑树\n      map      关联数组：保存关键字-值对\n      set      关键字即值,只保存关键字的容器\n      multimap 关键字可重复出现的 map\n      multiset 关键字可重复出现的 set \n      \n## 无序集合  哈希函数实现\n      unordered_map 哈希函数组织的map\n      unordered_set 哈希函数组织的set\n      unordered_multimap 哈希函数组织的multimap, 关键字可以重复出现\n      unordered_multiset 哈希函数组织的multiset， 关键字可以重复出现\n      \n## 无序集合 基于hash table（哈希表）\n      hash_map\n      hash_set\n      hash_multimap\n      hash_multiset\n      \n## 结果分析\n      运行效率方面：unordered_map最高，hash_map其次，而map效率最低\n      占用内存方面：hash_map内存占用最低，unordered_map其次，而map占用最高\n\n## 使用map \n### 使用map统计每个单词在输入中出现的次数  单词按字典序列 排序\n\n      map<string, size_t> word_count;//string 到 size_t 的空map\n      string word;\n      while(cin >> word) ++word_count[word];//提取word的计数器并将其加1\n      for(const auto &w : word_count)       //对map中的每一个元素  pair类型 first成员保存关键字 second成员保存对应的值\n            cout << w.first << \" occurs \" << w.second\n                 << ((w.second > 1)? \"times\" : \"time\") << endl;// 报告每个单词出现的次数 单词按 字典排序\n### \n[map 创建一张百万富翁的列表](https://github.com/Ewenwan/CPP-17-STL-cookbook/blob/master/content/chapter2/chapter2-5-chinese.md)\n\n\n\n## 使用 set\n### 使用set保存需要忽略统计的单词\n\n      map<string, size_t> word_count;//string 到 size_t 的空map\n      set<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                             \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};//需要剔除的单词\n      string word;\n      while(cin >> word)\n            if(exclude.find(word) == exclude.end()) ++word_count[word];// 统计合理的词的出现次数\n\t    // exclude.find(word) word没有在exclude中出现时，返回 exclude.end()\n\n      \n## 初始化关联容器\n      //map初始化为空\n      map<string, size_t> word_count;//string 到 size_t 的空map\n      //set的列表初始化\n      set<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                             \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};//需要剔除的单词\n      //map的列表初始化 三个元素 将姓 映射为 名字\n      map<string, string> authers = {{\"Jyly\", \"Jeam\"}，\n                                     {\"Aust\", \"Amy\"},\n                                     {\"Dickens\", \"Charles\"} };\n      // multimap multisetde初始化,一个单词对应多个相互关联的词义,就是说 关键字可以重复出现\n      vector<int> ivec;\n      for(vector<int>::size_type i = 0; i != 10; ++i){\n            ivec.push_back(i);\n            ivec.push_back(i);// 每个数重复保存一次\n            }\n      // iset包含来自ivec的不重复的元素 含有10个元素\n      set<int> iset(ivec.cbegin(), ivec.cend());\n      // multiset 包含ivec的所有20个元素\n      multiset<int> miset(ivec.cbegin(), ivec.cend());\n\n## pair类型 是用来生成 特点类型 的模板 first 和 second 来访问  map的元素是 pair类型   make_pair(v1, v2)\n      pair<string, string> anon;//\n      pair<string, size_t> word_count;//\n      pair<string, vector<int>> line;//保存 string 和 vector<int> \n      pair<string, string> author{\"James\", \"Joyce\"};//列表初始化\n      // pair类型的返回值类型函数\n      pair<string, int> process(vector<string> &v){\n            if(!v.empty())//back()\t返回最后一个元素\n                  return {v.back(), v.back().size()};//列表初始化\n                  // return pair<string, int>(v.back(), v.back().size());\n                  // return make_pair(v.back(), v.back().size()):\n            else \n                  return pair<string, int>();//隐式构造返回值\n            }\n\n### 关联容器类型 key_type value_type 对于set是一样的 而对于map不一样 还有一个 mapped_type\n      set<string>::value_type va;//va 是一个string\n      set<string>::key_type   vb;//vb 也是一个string\n      map<string, int>::key_type vc;//vc 是一个string\n      map<string, int>::mapped_type vd;//vd 是一个int\n      mep<string, int>::value_type ve;//ve map元素的类型 是pair类型  pair<const string, int>\n### 关联容器迭代器\n      map<string, size_t> word_count;//string 到 size_t 的空map\n      auto map_it = word_count.begin();//迭代器指针\n      // *map_it 是一个指向 pair<const string, size_t>类型对象的 引用\n      cout << map_it->first;//打印关键字\n      cout << \" \" << map_it->second;//\n      map_it->first = \"new key\";//错误 map的关键字类型 是 const的 不能改变 可以读取\n      ++map_it->second;//正确 值类型不是const 可以改变\n      //set的关键字也是只读的即const，不能被改变的\n      set<int> iset = {0,1,2,3,4,5,6,7,8,9};//列表初始化\n      set<int>::iterator set_it = iset.begin();\n      if( set_it != iset.end()){\n            *set_it = 42;// 错误 不能修改set的关键字\n            cout << *set_it << endl;//可以读取set的关键字\n            }\n### 遍历关联容器\n\n      map<string, size_t> word_count;//string 到 size_t 的空map\n      string word;\n      while(cin >> word) ++word_count[word];//提取word的计数器并将其加1\n      // 范围for访问\n      for(const auto &w : word_count)       //对map中的每一个元素  pair类型 first成员保存关键字 second成员保存对应的值\n            cout << w.first << \" occurs \" << w.second\n                 << ((w.second > 1)? \"times\" : \"time\") << endl;// 报告每个单词出现的次数\n       //迭代器访问\n       auto map_it = word_count.cbegin();//迭代器指针\n       // *map_it 是一个指向 pair<const string, size_t>类型对象的 引用\n       while(mep_it != word_count.cend()){\n       cout << map_it->first << \" occurs \"\n            << map_it->second \n            << ((w.second > 1)? \"times\" : \"time\") << endl;// 报告每个单词出现的次数\n            ++map_it;//递增迭代器，移动到下一个元素\n       }\n### 向map中添加元素\n      word_count.insert({word, 1});// c++11标准最方便\n      word_count.insert(make_pair(word, 1));\n      word_count.insert(pair<string, size_t>(word, 1));\n      word_count.insert(map<string, size_t>::value_type(word, 1));\n      \n### 向multimap中添加元素\n      multimap<string, string> authors;\n      authors.insert({\"Breath, John\", \"Sot-Weed Factor\"});//插入第一个元素，关键字为 Breath, John\n      authors.insert({\"Breath, John\", \"Lost in the funhouse\"});//插入第二个元素，关键字也为 Breath, John\n### multimap的访问\n      string search_item(\"Breath, John\");\n      auto cnt = authors.count(search_item);//关键字出现的次数\n      auto iter = authors.find(search_item);//关键字指向的 值序列\n      while(cnt){\n            cout << iter->second << endl;//打印作者的每一个书名\n            ++iter;//前进到下一步书\n            --cnt;//记录剩余未打印的书本数量\n      }\n      // 迭代器lower_bound  范围for 访问\n      for(auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item);\n                                    beg != end; ++beg)\n            cout << beg->second <<endl;//打印作者的每一个书名\n      // 范围for equal _range() 访问\n      for(auto pose = authors.equal _range(search_item); pose.first != pose.second; ++pose.first)\n            cout << pose.first->second << endl;//打印作者的每一个书名\n## 无序容器   无序 存储\n      unordered_map<string, size_t> word_count;//string 到 size_t 的空unordered_map 无序map\n      string word;\n      while(cin >> word) ++word_count[word];//提取word的计数器并将其加1\n      for(const auto &w : word_count)       //对map中的每一个元素  pair类型 first成员保存关键字 second成员保存对应的值\n            cout << w.first << \" occurs \" << w.second\n                 << ((w.second > 1)? \"times\" : \"time\") << endl;// 报告每个单词出现的次数 单词 无序\n\t\t \n### 无序容器的存储方式\n#### 管理桶\n> 无序容器在存储组织上为一组桶(bucket)，每个桶保存零个或多个元素，使用一个hash function(哈希函数)将元素映射到桶，\n\n> 为了访问元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶，容器将具有固定哈希值的所有元素都保存在相应的桶中。\n\n#### 对于存储自定义类型的 无序容器   需要自己定义哈希函数 和比较函数(==) 来实现存储\n      //哈希函数\n      size_t hasher(const Sales_data &sd){\n            return hash<string>()(sd.isbn());//h哈希类型\n      }\n      //比较函数\n      bool eqOp(const Sales_data &lhs, const Sales_data &rhs){\n        return   lhs.isbn() == rhs.isbn();// 比较函数 \n      }\n      // 定义特定类的 unordered_multiset\n      using = sd_unordered_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>// 两个函数指针\n\n\n\n"
        },
        {
          "name": "小技巧.md",
          "type": "blob",
          "size": 11.49609375,
          "content": "# 1 字符串转换成　整形　浮点型\n```c\n// 使用输入输出流\n    #include <iostream> //标准输入输出头文件\n    #include <sstream> \n      float x_trans = 0.7;\n      if(argc>=2) {\n       std::istringstream xss(argv[1]);\n       xss >> x_trans;\n      }\n// 使用库函数  整数等转string\nint j=100;\nstring j_str = boost::chrono::to_string(j)\n\n```\n  \n# 2 vector 结构体 以结构体中的成员查找\n```c\n在vector中查找最先想到的自然是find函数\n\nstruct student{\n    string name;\n    int grade;\n};\n\nvector<student> stu;//就当数据已经存好了...\n\n假设以name为查找对象\n\nstring str=\"john\";\nvector<student>::iterator it=find(stu.begin(),stu.end(),str);\n\n此时迭代器it指示的就是我们查找的字符串所在的结构体在容器中的位置，但是这显然是会出错的。\n\nfind的本质是将find的第三个参数与容器中的元素进行==操作，string和student不管怎么样都不会相等的。\n\n所以我们需要将student的==操作重写\n\nbool student::operator ==(const string &x){\n    return(this->name==x);\n}    \n\n```\n\n# 3 查找多个符合条件的值\n```c\n// 在结构体vector中查找符合条件的所有元素\n// g++ test.cpp -o t\n// ./t\n#include<iostream>\n#include<vector>\n#include<iterator>\n#include<algorithm>\n#include<string>\nusing namespace std;\ntypedef struct StudentInfo {\n int id;\n string name;\n} STUINFO;\n\n// 奇数\nbool IsOddId (STUINFO info) {\n  return ((info.id%2)==1);\n}\n\n// 偶数\nbool IsEvenId (STUINFO info) {\n  return ((info.id%2)==0);\n}\n\nint main(int argc, char** argv)\n{\n\t vector<STUINFO> v;\n\t vector<STUINFO>::iterator iter, it_end;\n\t  \n\t STUINFO temp;\n\t temp.id = 100;\n\t temp.name = \"Jack\";\n\t v.push_back(temp);\n\t temp.id = 101;\n\t temp.name = \"Sam\";\n\t v.push_back(temp);\n\t temp.id = 102;\n\t temp.name = \"John\";\n\t v.push_back(temp);\n\t temp.id = 103;\n\t temp.name = \"Tom\";\n\t v.push_back(temp);\n\t \n         std::vector<vector<STUINFO>::iterator> candidate; // 符合条件的\n\t iter = v.begin()-1;\n\t it_end = v.end(); \n\t while(true) \n         {\n\t  // iter = find_if(++iter, v.end(), IsEvenId);// 偶数\n          iter = find_if(++iter, v.end(), IsOddId);   // 奇数\n\t  if (iter != it_end )\n\t   // cout << \"ID: \" << (*iter).id << \", Name: \" << (*iter).name <<endl;\n           candidate.push_back(iter);\n\t  else\n\t   break;  \n\t }\n         for(int i=0; i<candidate.size(); i++)\n             cout << \"ID: \" << (*candidate[i]).id << \", Name: \" << (*candidate[i]).name <<endl;\n \n         return 0;\n}\n\n```\n\n# 4 linux无锁化编程\n## 原子类型  不加锁下不担心内存反问冲突\n[linux无锁化编程--__sync_fetch_and_add系列原子操作函数](https://blog.csdn.net/hzhsan/article/details/25124901)\n\n[无锁编程实战演练](https://blog.csdn.net/hzhsan/article/details/25837189)\n\n```c\n// 以count = 4为例，调用__sync_fetch_and_add(&count,1),之后，返回值是4，然后，count变成了5.\n// 有 __sync_fetch_and_add , 自然也就有 __sync_add_and_fetch，呵呵这个的意思就很清楚了，先自加，再返回。\n// 他们哥俩的关系与i++和++i的关系是一样的。\n// 有了这个宝贝函数，我们就有新的解决办法了。对于多线程对全局变量进行自加，我们就再也不用理线程锁了。\n在用gcc编译的时候要加上选项 -march=i686\n// sam:在我的服务器上，发现不加都可以。\ntype __sync_fetch_and_add (type *ptr, type value);\ntype __sync_fetch_and_sub (type *ptr, type value);\ntype __sync_fetch_and_or (type *ptr, type value);\ntype __sync_fetch_and_and (type *ptr, type value);\ntype __sync_fetch_and_xor (type *ptr, type value);\ntype __sync_fetch_and_nand (type *ptr, type value);\ntype __sync_add_and_fetch (type *ptr, type value);\ntype __sync_sub_and_fetch (type *ptr, type value);\ntype __sync_or_and_fetch (type *ptr, type value);\ntype __sync_and_and_fetch (type *ptr, type value);\ntype __sync_xor_and_fetch (type *ptr, type value);\ntype __sync_nand_and_fetch (type *ptr, type value);\n\n\n```\n\n# 5 产生N个不重复的随机数的快速算法\n```c\n//http://blog.csdn.net/devfun/article/details/6534476\n//https://blog.csdn.net/devfun/article/details/6534476\nint* RandPerm(int N)\n{\n    int i;\n    int[] TempArray = new int[N];\n    int[] Value = new resultArray[N];\n    \n    for (i = 0; i < N; i++) \n       TempArray[i] = i;// 0~n-1数组\n       \n    for (i = 0; i < N; i++)\n    {\n        int seed = random(0, N - i);//从剩下的随机数里生成  \n        resultArray[i] = TempArray[seed];//赋值给结果数组  \n        TempArray[seed] = TempArray[N - i - 1];//把随机数产生过的位置替换为未被选中的值。  \t \n    }\n    return resultArray;\n}\n\n\n```\n\n# 6 在main函数之前执行代码-C语言__attribute__((constructor))\n\n    我们都知道main函数是C语言的入口函数，代码都是从main函数开始执行的。\n\n    那么问题来了，有没有办法让代码在main函数之前执行哪？\n\n    GCC语法支持的__attribute__属性\n    __attribute__((constructor))：在main函数之前执行某个函数；类似类的构造函数。\n    __attribute__((destructor))：在main函数之后执行某个函数；类似类的析构函数。\n\n    constructor和destructor会在ELF文件中添加两个段-.ctors和.dtors。\n\n    当动态库或程序在加载时，会检查是否存在这两个段，如果存在执行对应的代码。\n    \n```c\n\n#include <stdio.h>\n \nvoid __attribute__((constructor)) before_main();\nvoid __attribute__((destructor)) after_main();\n \nint main()\n{\n\tprintf(\"Hello World!\\n\");\n\treturn 0;\n}\n \nvoid before_main()\n{\n\tprintf(\"Before main\\n\");\n}\n \nvoid after_main()\n{\n\tprintf(\"After main\\n\");\n}\n\n/*\nBefore main\nHello World!\nAfter main\n*/\n\n```\n\n# 7 浮点数判等\\等于零等...\n```c\n// 浮点数判等\nbool is_equal (double a, double b, double epsilon = 1.0e-7)\n{\n    return std::abs(a - b) < epsilon;\n}\n// 等于零\nbool NearZero(const double val, double epsilon = 1.0e-6){\n    return (std::abs(val) < epsilon);\n}\n\n```\n\n# 8. 字符串（C风格）转换成整型 atoi()实现  重要溢出判断思路\n```c\nint atoi_my(const char* const cs) {\n    // 内置 atoi 不会处理 NULL 指针\n    if (cs == nullptr) return 0;\n\n    int ret = 0;\n    auto *p = cs;  // cs 为常指针\n\n    // 跳过前面的空格\n    while (isspace(*p)) p++;\n\n    // 判断正负\n    int sign = 1;   // 默认正数\n    if (*p == '-') sign = -1;\n    if (*p == '-' || *p == '+') p++;\n\n    // 核心代码：循环转换整数（加入溢出判断）=============================\n    int tmp;  // 保存临时结果，用于溢出判断\n    while (*p >= '0' && *p <= '9') {\n        tmp = ret * 10 + (*p - '0');\n        if (tmp / 10 != ret) {  // 溢出判断======== tmp/10的商 应该等于 ret====\n            return sign > 0 ? INT_MAX : INT_MIN; // 溢出时，直接返回最大值 或最小值\n        }\n        ret = tmp;\n        p++;\n    }\n    // 核心代码（无溢出判断）\n    //while (*p >= '0' && *p <= '9') {\n    //    ret = ret * 10 + (*p - '0');\n    //    p++;\n    //}\n\n    return sign * ret;\n}\n\n\n```\n# 9. 友元函数、友元类\n\t友元函数\n\t不是类的成员函数，却能访问该类所有成员（包括私有成员）的函数\n\t类授予它的友元函数特别的访问权，这样该友元函数就能访问到类中的所有成员。\n```c\nclass A {\npublic:\n    friend void set_data(int x, A &a);      // 类A的友元函数 的声明\n    int get_data() { return data; }\nprivate:\n    int data;\n};\n\nvoid set_data(int x, A &a) {                // 友元函数的定义\n    a.data = x; \n    cout << a.data << endl;                 // 该友元函数 可以 无障碍 读写 A类 的私有成员\n}\n\nint main(void) {\n    class A a;\n    set_data(1, a);\n    // cout << a.data;  // err\n    cout << a.get_data() << endl; \n    return 0;\n}\n```\n\t友元类\n\n\t一个类的 友元类 可以访问 该类的所有成员（包括私有成员）\n\t注意点\n\t友元关系不能被继承\n\t友元关系不能传递\n\t友元关系是单向的\n```c\nclass A {\npublic:\n    friend class C;    // A类的 友元类 C 的声明：C 是 A 的友元类\nprivate:\n    int data;\n};\n\nclass C {              // 友元类C 的定义，可以访问 类A 中的成员\npublic:\n    void set_A_data(int x, A &a) { \n        a.data = x; \n    }\n\n    int get_A_data(A& a) {\n      return a.data;\n    }\n};\n\nint main(void) {\n    class A a;\n    class C c;\n\n    c.set_A_data(1, a);\n    cout << c.get_A_data(a) << endl;  // 1\n\n    return 0;\n}\n```\n\n# 10.Eigen 矩阵相关\n```c\n// 矩阵归一化,归一化矩阵\nEigen::MatrixXd Normalize(Eigen::MatrixXd V){\n    V.normalize();\n    return V;\n}\n\n// 向量转李代数，叉乘矩阵，反对称矩阵\nEigen::Matrix3d VecToso3(const Eigen::Vector3d& omg) {\n    Eigen::Matrix3d m_ret;\n    m_ret << 0, -omg(2), omg(1),\n            omg(2), 0, -omg(0),\n            -omg(1), omg(0), 0;\n    return m_ret;\n}\n\n// 李代数矩阵(反对称矩阵) 转 向量\nEigen::Vector3d so3ToVec(const Eigen::MatrixXd& so3mat) {\n    Eigen::Vector3d v_ret;\n    v_ret << so3mat(2,1), so3mat(0,2), so3mat(1,0);\n    return v_ret;\n}\n\n// 归一化向量+模\nEigen::Vector4d AxisAng3(const Eigen::Vector3d& expc3){\n    Eigen::Vector4d v_ret;\n    v_ret << Normalize(expc3), expc3.norm();\n    return v_ret;\n}\n\n// 机器人相关库\nhttps://github.com/Le0nX/ModernRoboticsCpp/blob/master/src/modern_robotics.cpp\n\n```\n\n# 11. 数组元素筛选，更新\n```c\n//去除无法追踪的特征 输入特征点的状态标识数组\nvoid reduceVector(vector<cv::Point2f> &v, vector<uchar> status)\n{\n    int j = 0;// j为剩余 状态良好的 特征点数量\n    for (int i = 0; i < int(v.size()); i++)\n        if (status[i]) // 特征点状态良好\n            v[j++] = v[i];//j++表示先取出j的值，再加1\n            // j为剩余 状态良好的 特征点数量\n    v.resize(j);\n}\n\n//去除无法追踪到的特征点 特征点id数组 ；特征点的状态标识数组\nvoid reduceVector(vector<int> &v, vector<uchar> status)\n{\n    int j = 0;// j为剩余 状态良好的 特征点数量\n    for (int i = 0; i < int(v.size()); i++)\n        if (status[i])    // 特征点状态良好\n            v[j++] = v[i];//j++表示先取出j的值，再加1\n            // j为剩余 状态良好的 特征点数量\n    v.resize(j);\n}\n\n```\n\n# lambda匿名函数写法，方便排序\n\n```c\n\n    //（cnt, pts, id）序列 追踪的次数:2d特征点:特征点id\n    vector<pair<int, pair<cv::Point2f, int>>> cnt_pts_id;\n    for (unsigned int i = 0; i < forw_pts.size(); i++)\n        cnt_pts_id.push_back(make_pair(track_cnt[i], make_pair(forw_pts[i], ids[i])));\n\n    //对光流跟踪到的特征点forw_pts，按照被跟踪到的次数从大到小排序\n    sort(cnt_pts_id.begin(), cnt_pts_id.end(), \n         // 匿名函数 实现 两元素比较大小\n         [](const pair<int, pair<cv::Point2f, int>> &a, const pair<int, pair<cv::Point2f, int>> &b)\n         {\n            return a.first > b.first;\n         }\n        );\n\t\n// 结构体数据中 某项数据的范围\nauto cmp_x = [](PointXYZPixel const& l, PointXYZPixel const& r) { return l.x < r.x; };\nauto minmax_x = std::minmax_element(seg->begin(), seg->end(), cmp_x);// 点云x最大\n\n\t\n// 结构体数据中某一项的均值\nauto sum_x = [](double sum_x, PointXYZPixel const& l){return sum_x + l.x;};// 对某一项累计求和\nauto sumx = std::accumulate(seg->begin(), seg->end(), 0.0, sum_x);// 求和\ndouble mean_x =  sumx / seg->size(); // 均值\n\n\n// 使用 外部数据(类内私有数据)\n// 判断点云团是否足够大===\nauto func = [this](pcl::PointIndices indices) { return indices.indices.size() < this->mObject_minimum_points; };\n// 删除过小的点云团\ncluster_indices.erase(std::remove_if(cluster_indices.begin(), cluster_indices.end(), func), cluster_indices.end());\n\n```\n\n\n\n\n"
        },
        {
          "name": "常用网站.md",
          "type": "blob",
          "size": 0.361328125,
          "content": "# github https://github.com\n\n# Gist  https://gist.github.com\n      Gist作为一个粘贴数据的工具，就像 Pastie 网站[1]一样，可以很容易地将数据粘贴在Gist网站中，\n      并在其他网页中引用Gist中粘贴的数据。\n      作为GitHub的一个子网站，很自然地，Gist使用Git版本库对粘贴数据进行维护，这非常酷\n"
        },
        {
          "name": "新特点.md",
          "type": "blob",
          "size": 0.943359375,
          "content": "# 新特征\n## 1. goto 转移表 一些编译器会把switch语句、多线程转换成goto 转移表作为汇编格式\n```c\nint i = 0;\nstatic void * ptr[3]={&&label1, &&label2, &&label3};\ngoto *ptr[i];\n\nlabel1:\nprintf(\"label1\\n\");\nreturn 0;\n\nlabel2:\nprintf(\"label2\\n\");\nreturn 0;\n\nlabel3:\nprintf(\"label3\\n\");\nreturn 0;\n```\n## 2. 单标签case 升级 为 范围case/case范围 (多标签)\n```c\nenum kind { alpha, number, white, other };\nenum kind char_class(char c)\n{\n  enum kind result;\n  switch(c) {\n      case 'a' ... 'z':// case low ... high : // （包含边界值）\n      case 'A' ... 'Z':\n          result = alpha;// 字母\n          break;\n      case '0' ... '9':\n          result = number;// 数字\n          break;\n      case ' ':\n      case '\\n':\n      case '\\t':\n      case '\\r':\n      case '\\v':\n          result = white;// 空白符\n          break;\n      default:\n          result = other;// 其他字符\n          break;\n  }\n  return result; \n}\n```\n"
        },
        {
          "name": "格式化输入输出.md",
          "type": "blob",
          "size": 1.4287109375,
          "content": "# cout 格式化输出\n## 布尔格式输出  boolalpha\n      cout << \"默认值 \" << true  << \" \"<< false <<endl;// 1  0\n      cout << \"bool格式\" << boolalpha <<  true  << \" \"<< false <<endl;// true   false \n      cout << noboolalpha; //恢复为默认格式\n      \n## 指定整形进制 hex 十六进制  oct 八进制   dec 十进制   浮点数 表示不受影响\n\n      cout << \"默认      \" << 20  << \" \" << 1024 << endl;// 默认十进制 20    1024\n      cout << \"八进制    \" << oct << 20 << \" \" << 1024 << endl;// 24  2000\n      cout << \"十六进制  \" << hex << 20 << \" \" << 1024 << endl;// 14  400\n      cout << showbase;//指定打印显示进制  八进制 024  02000  十六进制  0x14  0x400\n      cout << noshowbase;//恢复不再显示 进制\n      cout << uppercase; //十六进制 按大写字符显示\n\n## 小数控制显示精度  四去五入  在iomanip头文件中  #include <iomanip>\n      cout << \"精度 \" << cout.precision() << sqrt(2.0) << endl;// 打印当前精度 sqrt 在  #include <cmath>\n      cout.precision(12);//设置当前精度为 12位数字\n      cout << \"精度 \" << cout.precision() << sqrt(2.0) << endl;// 打印当前精度\n\n      cout << setprecision(10);// 另一种方法 设置当前精度为 10位数字\n      // showpoint  对浮点数总是显示 小数点   noshowpoint  浮点数才显示小数点\n      // showpos    对非负数显示+   noshowpos 对非负数 不显示+\n\n"
        },
        {
          "name": "类.md",
          "type": "blob",
          "size": 22.330078125,
          "content": "# 类的拷贝控制\n## 构造函数、拷贝函数 、 赋值函数、析构函数\n      class Sales_data{\n      public:\n        Sales_data() = default;// 默认合成 默认构造函数\n        Sales_data(const Sales_data& ) =  default;// 默认合成 拷贝构造函数\n        Sales_data& operator=(const Sales_data&);//  拷贝赋值运算符\n        ~Sales_data() = default;// 默认合成 默认析构函数\n      };\n       Sales_data&  Sales_data::operator=(const Sales_data&) = default;//  拷贝赋值运算符 类外定义\n ## 使用 delete 删除函数 避免拷贝\n       struct NoCopy(){// struct 默认为 public\n       NoCopy() = default;//  默认合成 默认构造函数    不能是删除函数\n       NoCopy(const NoCopy&) = delete;// 阻止拷贝\n       NoCopy&  operator=(const NoCopy&);//  阻止赋值\n       ~NoCopy() = default;// 默认合成 默认析构函数   不能是删除函数\n       };\n\n## private 拷贝控制  用户可定义和删除该对象 但不能拷贝它们   不过该类的成员函数 和其 有元函数和有元类 可以 拷贝\n      class privateCopy{// class 默认为 private  普通用户无法访问\n        privateCopy(const privateCopy&);// 私有拷贝构造函数\n        privateCopy& operator=(const privateCopy&);// 私有拷贝赋值运算符\n      public:\n        privateCopy() = default; // 默认合成  默认构造函数\n        ~privateCopy() = default;// 默认合成 默认析构函数   不能是删除函数\n      };\n      \n##  指针 与 拷贝构造函数 和 拷贝赋值运算符\n      struct Node{\n      char* name;//名字 字符指针\n      int age;// 年龄\n      Node(char* n = \" \", int a = 0 ){//默认构造函数\n       name = strdup(n);// strdup()字符串拷贝库函数\n       age = a;\n       }\n       // 拷贝构造函数未定义     编译器自动生成一个(自动生成的 只是逐个对成员复制,遇到指针就会出问题)\n       // 拷贝赋值运算符也未定义 编译器自动生成一个(自动生成的 只是逐个对成员复制,遇到指针就会出问题) \n      };\n\n      // 执行拷贝时 指针对象会指向同一个对象\n      Node node1(\"Role\", 20), node2(node1);//使用node1 初始化 node2 \n      strcpy(node2.name, \"Wendy\");// 指向了同一个对象\n      node2.age = 30;// 非指针正常赋值\n      cout << node1.name << \" \" << node1.age << \" \" << node2.name << \" \" << node2.age << endl;\n      // Wendy  20  Wendy  30  // \n\n\n###  定义 拷贝构造函数 \n      struct Node{\n      char* name;//名字 字符指针\n      int age;// 年龄\n      Node(char* n = \" \", int a = 0 ){//默认构造函数\n       name = strdup(n);// strdup()字符串拷贝库函数\n       age = a;\n       }\n       // 拷贝构造函数\n       Node(const Node& n){\n       name = strdup(n.name);\n       age = n.age;\n       }\n       // 拷贝赋值运算符也未定义 编译器自动生成一个  (自动生成的 只是逐个对成员复制,遇到指针就会出问题)\n      };\n\n      Node node1(\"Role\", 20), node2(node1);//使用node1 初始化 node2  使用拷贝构造函数\n      strcpy(node2.name, \"Wendy\");\n      node2.age = 30;// 正常赋值\n      cout << node1.name << \" \" << node1.age << \" \" << node2.name << \" \" << node2.age << endl;\n      // Role  20  Wendy  30  // \n      \n### 定义拷贝赋值运算符  重载 赋值运算符\n      struct Node{\n      char* name;//名字 字符指针\n      int age;// 年龄\n      Node(char* n = \" \", int a = 0 ){//默认构造函数\n       name = strdup(n);// strdup()字符串拷贝库函数\n       age = a;\n       }\n       \n       // 拷贝构造函数\n       Node(const Node& n){\n       name = strdup(n.name);\n       age = n.age;\n       }\n       \n       // 拷贝赋值运算符\n      Node& operate=(const Node& n){\n          if(this != &n){// 确保赋值运算符的两边不是同一个类的同一个对象，避免重复 定义自己\n             if(name != 0) free(name);//先释放之前的内存（如果之前已经指向了内存，避免内存泄漏）\n             name = strdup(n.name);// 再用 等号 左边的对象初始化 对象\n             age = n.age;\n            }\n          return  *this;// this 起始就是 类对象的地址\n          }\n      };\n\n### 指针与析构函数  默认的析构函数 只会释放 指针所占据的内存 而不会释放指针指向的内存空间  会造成 内存泄漏\n      struct Node{\n      char* name;//名字 字符指针\n      int age;// 年龄\n      Node(char* n = \" \", int a = 0 ){//默认构造函数\n       name = strdup(n);// strdup()字符串拷贝库函数\n       age = a;\n       }\n       \n       // 拷贝构造函数\n       Node(const Node& n){\n       name = strdup(n.name);\n       age = n.age;\n       }\n       \n       // 拷贝赋值运算符\n      Node& operate=(const Node& n){\n          if(this != &n){// 确保赋值运算符的两边不是同一个类的同一个对象，避免重复 定义自己\n             if(name != 0) free(name);//先释放之前的内存（如果之前已经指向了内存，避免内存泄漏）\n             name = strdup(n.name);// 再用 等号 左边的对象初始化 对象\n             age = n.age;\n            }\n          return  *this;// this 起始就是 类对象的地址\n          }\n        // 定义析构函数\n       ~Node(){\n       if(name != 0) free(name);//指针不为空，就已经使用了指向的内存，需要free手动释放掉\n       }\n      \n      };\n\n## 通过函数返回引用类型  可以改变类内变量的访问方式   破坏了 隐藏域\n      class refTest{\n            public:\n            int& getRefN(){\n                  return n;//n为类内私有变量 返回该私有变量引用后 类外就可以访问它\n            }\n            int getN(){\n                  return n;//n为类内私有变量\n            }\n            private:\n                  int n;\n      } c;\n      //c.n = 6;// 错误  外部直接访问不了 类内私有变量\n      int& k = c.getRefN();//通过返回引用 可以间接访问修改  类内私有变量\n      k = 7;//  类内私有变量 n 被修改为 7\n      cout << c.getN();// 可以看到 n 被修改为 7\n      c.getRefN() = 10;//直接通过 c.getRefN() 来给 类内私有变量 n 赋值\n\n\n\n\n# 重载\n## 重载输出运算符 <<  为特定类对象 重载输出运算符 返回的是 ostream& 输出流对象的引用\n    // 一般定义成 非成员函数 在{};外面\n     ostream& operator<<(ostream& os, const Sales_data& item ){\n       os << item.isbn() << \" \" << item.units_sold << \" \" << item.revenue << \" \" << item.avg_price();\n       // 使用了 字符串的、int、double的 输出运算符 类构成类的 输出运算符\n       return os;\n     }\n## 重载 输入 运算符 >>  返回的是  istream& 输入流对象的引用\n      istream& operator>>(istream& is, const Sales_data& item ){\n      double price;// 单价\n      is >> item.bookNo >> item.units_sold >> price;\n      if(is)//检测输入是否成功\n        item.revenue = item.units_sold * price\n      else\n        item = Sales_data();//输入失败，对象呗赋予默认的状态\n        return is;\n      }\n## 重载 关系运算符  ==  不等于也类似 !=\n    // 关系运算符  返回类型为 bool  输入两个类对象的 常量 引用 避免拷贝 节省时间 常量限制 避免修改 \n    bool \n    operator==(const Sales_item &lhs, const Sales_item &rhs)\n    {\n        // 在类中被是定义为 friend 有元函数 \n        // friend bool operator==(const Sales_item&, const Sales_item&);// 重定向 等于符号 == \n        return lhs.units_sold == rhs.units_sold &&\n               lhs.revenue == rhs.revenue &&\n               lhs.isbn() == rhs.isbn();\n    }\n## 整体 浏览\n\n        #ifndef SALESITEM_H\n        // we're here only if SALESITEM_H has not yet been defined \n        #define SALESITEM_H\n\n        // Definition of Sales_item class and related functions goes here\n        #include <iostream>\n        #include <string>\n\n        class Sales_item {\n        // these declarations are explained section 7.2.1, p. 270 \n        // and in chapter 14, pages 557, 558, 561\n        // 操作符 定义\n        friend std::istream& operator>>(std::istream&, Sales_item&);// 重定向输入 >> 符号\n        friend std::ostream& operator<<(std::ostream&, const Sales_item&);// 重定向输出 << 符号\n        friend bool operator<(const Sales_item&, const Sales_item&);// 重定向 小于符号 < \n        friend bool operator==(const Sales_item&, const Sales_item&);// 重定向 等于符号 ==  \n        public:\n            // constructors are explained in section 7.1.4, pages 262 - 265\n            // default constructor needed to initialize members of built-in type\n            Sales_item() = default;\n            Sales_item(const std::string &book): bookNo(book) { }\n            Sales_item(std::istream &is) { is >> *this; }\n        public:\n            // operations on Sales_item objects\n            // member binary operator: left-hand operand bound to implicit this pointer\n            Sales_item& operator+=(const Sales_item&);\n\n            // operations on Sales_item objects\n            std::string isbn() const { return bookNo; }\n            double avg_price() const;\n        // private members as before\n        private:\n            std::string bookNo;      // implicitly initialized to the empty string\n            unsigned units_sold = 0; // explicitly initialized\n            double revenue = 0.0;\n        };\n\n        // used in chapter 10\n        inline\n        bool compareIsbn(const Sales_item &lhs, const Sales_item &rhs) \n        { return lhs.isbn() == rhs.isbn(); }\n\n        // nonmember binary operator: must declare a parameter for each operand\n        Sales_item operator+(const Sales_item&, const Sales_item&);\n\n        inline bool \n        operator==(const Sales_item &lhs, const Sales_item &rhs)\n        {\n            // must be made a friend of Sales_item\n            return lhs.units_sold == rhs.units_sold &&\n                   lhs.revenue == rhs.revenue &&\n                   lhs.isbn() == rhs.isbn();\n        }\n\n        inline bool \n        operator!=(const Sales_item &lhs, const Sales_item &rhs)\n        {\n            return !(lhs == rhs); // != defined in terms of operator==\n        }\n\n        // assumes that both objects refer to the same ISBN\n        Sales_item& Sales_item::operator+=(const Sales_item& rhs) \n        {\n            units_sold += rhs.units_sold; \n            revenue += rhs.revenue; \n            return *this;\n        }\n\n        // assumes that both objects refer to the same ISBN\n        Sales_item \n        operator+(const Sales_item& lhs, const Sales_item& rhs) \n        {\n            Sales_item ret(lhs);  // copy (|lhs|) into a local object that we'll return\n            ret += rhs;           // add in the contents of (|rhs|) \n            return ret;           // return (|ret|) by value\n        }\n\n        std::istream& \n        operator>>(std::istream& in, Sales_item& s)\n        {\n            double price;\n            in >> s.bookNo >> s.units_sold >> price;\n            // check that the inputs succeeded\n            if (in)\n                s.revenue = s.units_sold * price;\n            else \n                s = Sales_item();  // input failed: reset object to default state\n            return in;\n        }\n\n        std::ostream& \n        operator<<(std::ostream& out, const Sales_item& s)\n        {\n            out << s.isbn() << \" \" << s.units_sold << \" \"\n                << s.revenue << \" \" << s.avg_price();\n            return out;\n        }\n\n        double Sales_item::avg_price() const\n        {\n            if (units_sold) \n                return revenue/units_sold; \n            else \n                return 0;\n        }\n        #endif\n        \n# 模板类\n      template<class genType>//声明模板类型\n      class genClass{\n            genType storage[50];//模板类型 数组\n            };\n      // 定义\n      genClass<int>    intObject;   // int 类型数组\n      genClass<double> doubleObject;// double 类型数组\n\n      // 其二也可以将 数组大小推迟定义\n      template<class genType, int size = 50>// 声明模板类型 书序大小默认为50\n      class genClass{\n            genType storage[size];//模板类型 数组\n            };\n      // 定义\n      genClass<int>    intObject1;         // int 类型数组 默认   大小\n      genClass<int, 100>    intObject2;    // int 类型数组 数组大小为 100 \n      genClass<double, 123> doubleObject;  // double 类型数组  数组大小为 123\n\n# 模板函数\n      // 交换两个变量的值\n      template<class genType>//声明模板类型\n      void my_swap(genType& num1, genType& num2){   // 注意为 引用 需要对实参修改\n            genType temp = num1;\n            num1 = num2;\n            num2 = temp;\n          }\n      \n# 类的 继承\n\n      #include <iostream> \n      using namespace std;\n\n      // 基类 \n      class BaseClass {\n      public://共有类型 哪里都可以访问 \n      BaseClass() { }//默认构造函数 \n            void f(char *s = \"unknown\") {\n                  cout << \"Function f() in BaseClass called from \" << s << endl;\n                h();//类内可以访问 类的私有函数 \n          }\n\n      protected:// 保护类型  子类 和 友元函数/有元类 可以访问 \n            void g(char *s = \"unknown\") {\n                  cout << \"Function g() in BaseClass called from \" << s << endl;\n            }\n\n      private:// 类内 和 元函数/有元类 可以访问 \n            void h() {\n                  cout << \"Function h() in BaseClass\\n\";\n            }\n      };\n\n      // 子类 Derived1Level1 共有继承自 基类   BaseClass \n      class Derived1Level1 : public virtual BaseClass {\n      public:\n            void f(char *s = \"unknown\") {\n                  cout << \"Function f() in Derived1Level1 called from \" << s << endl;\n                  g(\"Derived1Level1\");// 本子类没有重写g() 因此调用的是 父类的g() 保护类型可以继承 子类内可以访问 \n                  // 函数时调用的基类的 但是参数 还是按子类传入的  \n                  h(\"Derived1Level1\");// 本子类重写了h()(本身父类的为私有，子类也调用不了), 因此调用的是 自己的 h() \n            }\n\n            void h(char *s = \"unknown\") {\n                  cout << \"Function h() in Derived1Level1 called from \" << s << endl;\n            }\n      };\n\n\n      class Derived2Level1 : public virtual BaseClass {\n      public:\n            void f(char *s = \"unknown\") {\n            cout << \"Function f() in Derived2Level1 called from \" << s << endl;\n            g(\"Derived2Level1\");// 调用基类的g() 保护类型的函数  但是参数按 子类传入的参数  \n            // h(); // 错误 : h()为基类的 私有函数 ，子类访问不了 BaseClass::h() is not accessible\n            }\n      };\n\n      //二级继承 \n      class DerivedLevel2 : public Derived1Level1, public Derived2Level1 {\n      public:\n            void f(char *s = \"unknown\") {\n            cout << \"Function f() in DerivedLevel2 called from \" << s << endl;\n            g(\"DerivedLevel2\");// g()函数只有基类有 实现 调用的是基类的 保护继承g() 但是参数是 子类 最新传递的 \n            Derived1Level1::h(\"DerivedLevel2\");// 父亲Derived1Level1有h()  爷爷 也有h() 需要指定调用的哪一个  参数都是最新的 \n            BaseClass::f(\"DerivedLevel2\");// f()函数  两个父亲 和 一个爷爷都有实现，需要指明调用哪一个  参数都是最新的 \n            }\n      };\n\n\n      int main() {\n      BaseClass bc;//基类 \n      Derived1Level1 d1l1;//子类1 \n      Derived2Level1 d2l1;//子类2 \n      DerivedLevel2 dl2;//子类的子类 \n\n      bc.f(\"main(1)\");// \n      // bc.g(); // 错误: 保护类型 类外访问不了 BaseClass::g() is not accessible\n      // bc.h(); // 错误: 私有类型 类外访问不了 BaseClass::h() is not accessible\n      cout << \"---------------\"<< endl; \n\n      d1l1.f(\"main(2)\");//首先调用子类重写的 f() \n      // 内部调用了 基类的g()(函数时调用的基类的 但是参数 还是按子类传入的 ) 和 自身重写的 h() \n      // d1l1.g(); // 错误: 在子类内 可以访问父类的保护类型函数g(), 外面访问不了 BaseClass::g() is not accessible\n\n\n      d1l1.h(\"main(3)\");// 调用子类自己重写的函数 参数按最新传入的 \n\n      d2l1.f(\"main(4)\");// 调用子类的函数f(),内部调用了父类的b保护类型函数g() 但是参数按子类传入的参数 \n      // d2l1.g(); // 父类的保护函数g() 在子类内可以访问 ，外部访问不了 错误 BaseClass::g() is not accessible\n      // d2l1.h(); // 父类的私有函数 子类内，外部都访问不了 错误: BaseClass::h() is not accessible\n\n\n      dl2.f(\"main(5)\");//类自身f() 内部 爷爷的 g() 父亲1的 h() 爷爷的  f()  参数都是最新传入的 \n      // dl2.g(); // error: BaseClass::g() is not accessible\n\n      dl2.h();//外部能访问 父亲  Derived1Level1的 共有类型函数 h() \n      return 0;\n      }\n      /*\n      Function f() in BaseClass called from main(1)\n      Function h() in BaseClass\n      Function f() in Derived1Level1 called from main(2)\n      Function g() in BaseClass called from Derived1Level1\n      Function h() in Derived1Level1 called from Derived1Level1\n      Function h() in Derived1Level1 called from main(3)\n      Function f() in Derived2Level1 called from main(4)\n      Function g() in BaseClass called from Derived2Level1\n      Function f() in DerivedLevel2 called from main(5)\n      Function g() in BaseClass called from DerivedLevel2\n      Function h() in Derived1Level1 called from DerivedLevel2\n      Function f() in BaseClass called from DerivedLevel2\n      Function h() in BaseClass\n      Function h() in Derived1Level1 called from unknown\n\n      --------------------------------\n      Process exited with return value 0\n      Press any key to continue . . .\n\n      */ \n\n\n# 类的多态性  基类定义的虚函数，子类(其他类)可以重写，根据指针当前指向的对象类型动态调用属于哪一确定类的该虚函数\n      多态性指的是获得多种形态的能力。\n      在 OOP 中，多态性指的是用同样的函数名称表示多个函数，而这些函数是不同对象的成员。\n\n      对于所谓的静态绑定来说，调用哪个函数是在编译阶段确定的。\n      而对于动态绑定，则要推迟到运行阶段才能确定。\n      在 C++中，动态绑定是通过将成员函数声明为 virtual 来实现的。在这种方式中，\n      如果对虚函数成员进行调用，那么选择执行哪个函数\n\n      并不依赖于声明的指针类型，而是依赖于指针当前指向的类型。\n\n      #include <iostream>\n      using namespace std;\n\n      //类1 \n      class Class1 {\n      public:\n      virtual void f() {//虚函数   支持动态绑定 运行时确定 \n            cout << \"Function f() in Class1\\n\";\n      }\n      void g() {// 静态绑定 在编译阶段确定 \n            cout << \"Function g() in Class1\\n\";\n      }\n      };\n\n      // 类2 \n      class Class2 {\n      public:\n      virtual void f() {//虚函数   支持动态绑定 运行时确定 \n            cout << \"Function f() in Class2\\n\";\n      }\n      void g() {\n            cout << \"Function g() in Class2\\n\";\n      }\n      };\n\n      //类3 \n      class Class3 {\n      public:\n      virtual void h() {//虚函数   支持动态绑定 运行时确定 \n            cout << \"Function h() in Class3\\n\";\n      }\n      };\n\n      int main() {\n      Class1 object1, *p;// 类1 对象 object1  指针 p 声明为 Class1*类型\n      Class2 object2;// 类2 对象 object2\n      Class3 object3;// 类3 对象 object3\n      p = &object1;//当前p 指向  Class1类的  object1对象  \n      p->f();// 动态绑定 到 Class1类的 f()虚函数     Function f() in Class1\n      p->g();// 静态绑定 在编译阶段确定              Function g() in Class1\n      p = (Class1*) &object2;// 当前p 指向  Class2类的  object2对象 \n      p->f();// 动态绑定 到 Class2类的 f()虚函数     Function f() in Class2\n      p->g();// 静态绑定 在编译阶段确定              Function g() in Class1\n      p = (Class1*) &object3;// 当前p 指向  Class3类的  object3对象 \n      p->f(); // 程序会结束 报错  Class3类 无虚函数  f()   devc测试 竟然输出了  Function h() in Class3\n      p->g(); // 静态绑定 在编译阶段确定             Function g() in Class1\n      //p->h(); // h() is not a member of Class1;\n      return 0;\n      }\n\n      /* \n      该程序的输出如下所示：\n      Function f() in Class1\n      Function g() in Class1\n      Function f() in Class2\n      Function g() in Class1\n      // 程序会结束    Class3类 无虚函数  f()   devc测试 竟然输出了  Function h() in Class3\n      Function g() in Class1\n      */\n## 多态性  优点   \n      多态性是 OOP 的一项强大功能。可以利用这个特性将一个标准消息发送给许多不同的对象，\n      而不需要指定如何处理消息，也不需要知道对象是什么类型。接收者负责解释和处理消息。发送者\n      不需要根据接收者的类型来修改消息，也不需要使用 switch 或 if-else 语句。此外还可以在复杂的程\n      序中加入新的单元而不需要重新编译整个程序。\n\n## 有元函数 有元类 拓展了C++隐藏特性\n      class C {\n      int n;//class 默认 属性为 provide 私有\n      friend class B;//有元类\n      friend int f();//有元函数\n      } obc;\n\n      int f(){\n      return 10 * obc.n; // 函数f() 可以访问 类C的对象 obc 的所有类型的变量和方法\n      }\n\n      class B {// 函数B 可以访问 类C的对象 obc 的所有类型的变量和方法\n      int m;\n      int function(){\n            return  obc.n;\n       }\n      }\n\n\n# 函数运算符的重载 类   函数运算符 () operator()\n      class classfuc{\n      public:\n            classfuc() {// 默认构造函数\n            }\n            double operator() (double x){// 重载函数运算符 ()\n                  return 2*x;\n            }\n            double dou(double x){//定义功能函数\n                  return 2*x\n            }\n      };\n\n      //定义使用 重载了函数运算符的类 定义的函数\n      double sum2(classfuc f, int n, int m){\n            double res = 0.0;\n            for (int i = n; i < = m; ++i){\n                  res += f(i); \n                  // res += f.dou(i);//使用 功能函数\n            }\n            return res;\n      }\n      // 使用函数\n      classfuc fc;\n      cout << sum2(cf, 2, 10) << endl;\n\n\n\n\n\n\n\n\n"
        },
        {
          "name": "编程面试_动态规划.md",
          "type": "blob",
          "size": 19.1328125,
          "content": "# 题目1 最大连续乘积子串\n          题目描述\n          给一个浮点数序列，取最大乘积连续子串的值，\n          例如 -2.5，4，0，3，0.5，8，-1，则取出的最大乘积连续子串为3，0.5，8。\n          也就是说，上述数组中，3 0.5 8这3个数的乘积30.58=12是最大的，而且是连续的。\n\n          考虑到乘积子序列中有正有负也还可能有0，我们可以把问题简化成这样：\n          数组中找一个子序列，使得它的乘积最大；\n          同时找一个子序列，使得它的乘积最小（负数的情况）。\n          因为虽然我们只要一个最大积，但由于负数的存在，我们同时找这两个乘积做起来反而方便。\n          也就是说，不但记录最大乘积，也要记录最小乘积。\n          假设数组为a[]，直接利用动态规划来求解，考虑到可能存在负数的情况，\n          我们用maxend来表示以a[i]结尾的最大连续子串的乘积值，\n          用minend表示以a[i]结尾的最小的子串的乘积值，那么状态转移方程为：\n\n            maxend = max(max(maxend * a[i], minend * a[i]), a[i]);\n            minend = min(min(maxend * a[i], minend * a[i]), a[i]);\n            \n          初始状态为maxend = minend = a[0]。\n\n> 参考代码如下：\n\n          double MaxProductSubString(double *a, int num){\n          double MaxEnd = a[0];\n          double MinEnd = a[0];\n          double MaxResult = a[0];\n          for(int i = 0; i < num; ++i){\n                    double end1 = MaxEnd * a[i], end2 = MinEnd * a[i];\n                    MaxEnd = max(max(end1, end2), a[i]);\n                    MinEnd = min(min(end1, end2), a[i]);\n                    MaxResult = max(MaxResult, MaxEnd);\n           }\n           return MaxResult;\n\n          }\n          // 动态规划求解的方法一个for循环搞定，所以时间复杂度为O(n)。\n\n\n\n\n\n\n# 搜索算法中的老祖宗，深度和广度优先搜索算法。\n# 广度优先（BFS Breadth-First Search）搜索\n          这个用形象的比喻，就像是地震波，从起点向外辐射，直到找到目标点。我们在实现的时候，一般采用队列来实现。\n          广搜是一层一层往外遍历，寻找最短路径，其策略是采取队列的方法。\n          这个算法的优点：\n          1、简单。代码也就几十行；\n          2、路径能找到最优解；\n          不足：\n          1、算法消耗的时间比较大，遍历的点会很多。\n\n          广度优先搜索之所以能找到最优的路径，原因就是：\n            每一次扩展的点，都是距离出发点最近、步骤最少的。\n            如此这样递推，当扩展到目标点的时候，也是距离出发点最近的。\n            这样的路径自然形成了最短的路线。\n            \n\n\n# 深度优先（DFS Depth-First Search）搜索\n          用俗话说就是不见棺材不回头。算法会朝一个方向(目标位置)进发，直到遇到边界或者障碍物，才改变方向。\n          一般在实现的时候，我们采用递归的方式来进行，也可以采用模拟压栈的方式来实现。\n          这个算法的好处就是实现简单，可能就十几行代码。\n          不过问题也很明显，就是：\n          1、路径可能不是最优解；\n          2、寻路时间比较长。\n\n[数据结构----BFS和DFS详解 c++代码 ](http://blog.csdn.net/qq_35644234/article/details/52518585)\n\n\n# A*算法  广度优先 + 启发式搜索  考虑距出发点距离 + 距目标点距离\n          正是由于广度优先搜索一层层的扩展，虽然让他找到了最优的路线，\n          但是，他却很傻的走完了绝大多数格子，才找到我们的目标点。\n          也就是，他只关注了当前扩展点和出发点的关系，而忽略了当前点和目标点的距离。\n          如果，如果，如果……我们每扩展一个点，就踮起脚尖，看看诗和远方，找找我们要寻找的那个目标，\n          是不是就有可能指引我们快速的去往正确的方向，而不用傻乎乎的一层层的发展了呢？答案是肯定的。\n\n          A*算法相对广度优先搜索算法，除了考虑中间某个点同出发点的距离以外，\n          还考虑了这个点同目标点的距离。\n          这就是A*算法比广度优先算法智能的地方。也就是所谓的启发式搜索。\n \n> 如果用f(M)表示：从起点S到终点E（经过M点）的距离，那他就可以表示成为两段距离之和,M为中间策略点\n\n          即：S→M的距离 + M→E的距离。如果我们用符号表示的话，就可以写成：f(M) = g(M) + h(M)。 \n\n          我们扩展到M点的时候，S→M的距离就已经知道，所以g(M)是已知的。\n          但是M到E的距离我们还不知道。如果我们能用某种公式，能大概预测一下这个距离，\n          而这个预测的值又比较精确，我们是不是就能很精确的知道每一个即将扩展的点是否是最优的解路径上的点呢？ \n         \n> 估算函数h(M)如何计算？\n\n          常见的距离计算公式有这么几种：\n          1、曼哈顿距离：这个名字听起来好高端，说白了，就是上面我们讲的横向格子数+纵向格子数(折线段距离)；\n          2、欧式距离：这个名字听起来也很高端，说白了，就是两点间的直线距离sqrt((x1-x2)^2 + (y1-y2)^2)\n          3、欧式距离平方： (x1-x2)^2 + (y1-y2)^2\n\n          除了上述的距离计算公式以外，还有一些变种的距离计算公式，\n          如：\n          对角线距离等等。这个就在具体的问题中做具体的优化了。      \n\n > 不同估算函数对于结果的影响  \n\n          1、当估算的距离h完全等于实际距离h'时，也就是每次扩展的那个点我们都准确的知道，\n              如果选他以后，我们的路径距离是多少，这样我们就不用乱选了，每次都选最小的那个，\n              一路下去，肯定就是最优的解，而且基本不用扩展其他的点。\n\n          2、如果估算距离h小于实际距离h'时，我们到最后一定能找到一条最短路径(如果存在另外一条更短的评估路径，就会选择更小的那个)，\n             但是有可能会经过很多无效的点。\n             曼哈顿距离\\欧式距离\n             极端情况，当h==0的时候，最终的距离函数就变成：\n             f(M)=g(M)+h(M)\n             => f(M)=g(M)+0\n             => f(M)=g(M)\n\n          这不就是我们的广度优先搜索算法嘛？！ 他只考虑和起始点的距离关系，毫无启发而言。 \n\n           3、如果估算距离h大于实际距离h'时，有可能就很快找到一条通往目的地的路径，但是却不一定是最优的解。\n           这种情况就是h值大于等于实际距离的，明显他扩展的点很少，不过找到的路径却不是最短路径。\n           欧式距离平方\n           \n           \n           \n  # Dijkstra(迪杰斯特拉)算法    \n## 算法特点：\n\n          迪科斯彻算法使用了 广度优先搜索 BFS \n          解决 赋权的有向图 或者 无向图的 单源最短路径问题，算法最终得到一个最短路径树。\n          该算法常用于路由算法或者作为其他图算法的一个子模块。\n\n## 算法的思路\n          Dijkstra算法采用的是一种贪心的策略，\n          声明一个数组dis来保存源点s 到各个顶点m 的最短距离 和\n          一个保存已经找到了最短路径的顶点的集合：T，\n          初始时：\n                    原点s 的路径权重被赋为 0 （dis[s] = 0）。\n                    若对于顶点 s 存在能直接到达的边(s,m) 另一个顶点为m\n                    则把dis[m]设为w(s, m)，即单个路径边上的权重值,\n                    同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。\n                    初始时，短路集合T 只有 顶点s。 \n          然后，从dis数组选择最小值，\n                    则该值就是 源点s 到该值对应的顶点 m 的最短路径，\n                    并且把该点加入到 短路集合T中，OK，此时完成一个顶点， \n          然后，我们需要看看新加入的顶点是否可以到达其他顶点，\n                    并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 \n          然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。\n         \n> 示例:\n\n          顶点数   边数\n          6        8\n          起点   终点   权重值\n          1       3      10\n          1       5      30\n          1       6      100\n          2       3      5\n          3       4      50\n          4       6      10\n          5       4      20\n          5       6      60\n          图的邻接矩阵为：\n          ∞  ∞  10  ∞  30  100     v1节点直接到达其他节点的距离\n          ∞  ∞  5   ∞  ∞   ∞\n          ∞  ∞  ∞   50 ∞   ∞\n          ∞  ∞  ∞   ∞  ∞   10      ...\n          ∞  ∞  ∞   20 ∞   60\n          ∞  ∞  ∞   ∞  ∞   ∞       v6节点直接到达其他节点的距离\n\n          新建dis 向量(从v1到达各个点 经过的最短距离)\n          dis = {0, ∞, 10, ∞, 30, 100}\n          解法：\n          步骤1：v1 到 v3 路径最短 dis[2] = 10, 下标从0开始    除去dis[0]外最小的 为dis[2]  到第三个顶点 v3\n\n                 v3可以到达v4，v1->v3->v4 距离为 10 + 50 = 60\n                 而从v1直接到v4，v1->v4，距离为无穷大，dis[3] = 60\n                 dis = {0, ∞, 10, 60, 30, 100}\n                 因此 dis[3]要更新为 60。这个过程有个专业术语叫做“松弛”。\n                 即 v1顶点到 v4顶点的路程即 dis[3]，通过 <v3,v4> 这条边松弛成功。\n                 这便是 Dijkstra 算法的主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。\n\n          步骤2：我们从除去 dis[0] 、 dis[2]中选择最小的  为 dis[4] = 30              到第五个顶点 v5\n\n                 v5 可以到达 v4, v1->v5->v4 距离为 30 + 20 = 50，\n                 而，从v1->v4为 60 > 50 ,则 dis[3] 被更新为 50\n\n                 另外 v5 也可以到达 v6,而v1 -> v5 -> v6 = 30 + 60 = 90\n                 而，从v1 -> v6 为 100则，dis[5] 被更为 90\n                 dis = {0, ∞, 10, 50, 30, 90}\n\n          步骤3：我们再从 除去  dis[0] 、 dis[2]、 dis[4] 中选择最小的为 dis[3] = 50  到第四个顶点 v4\n                而v4 可以到达 v6，v1 -> v4 -> v6 距离为 50 + 10 = 60\n                而v1 -> v6 = 90 > 60 ，则dis[5] 被更新为 60\n                dis = {0, ∞, 10, 50, 30, 60}\n\n          步骤4：然后，从除去   dis[0] 、 dis[2]、 dis[4]、dis[3] 中选取最小的为 dis[5] = 60 到第六个顶点 v4\n                而 v6 到达不了其他地方，更新不了\n          \n ## Dijkstra算法的代码实现（c++）      \n > Dijkstra.h 头文件的代码\n\n          // Dijkstra.h\n          #pragma once\n          //#pragma once是一个比较常用的C/C++杂注，\n          //只要在头文件的最开始加入这条杂注，\n          //就能够保证头文件只被编译一次。\n\n          #include<iostream>\n          #include<string>\n          using namespace std;\n\n          /*\n          本程序是使用Dijkstra算法实现求解最短路径的问题\n          采用的邻接矩阵来存储图\n          */\n\n          //记录起点到每个顶点的最短路径的信息\n          struct Dis {\n              string path;//字符串路径 \n              int value;  //最短路径值\n              bool visit; //已经找到最短路径的标记 \n              Dis() {     //结构体初始化函数\n                  visit = false;\n                  value = 0;\n                  path = \"\";\n              }\n          };\n          // 自定义类的声明\n          class Graph_DG {\n          private:// 私有变量\n              int vexnum;   //图的顶点个数 v1，v2，...，v6\n              int edge;     //图的边数\n              int **arc;    //邻接矩阵 二维数组 指针的指针\n              Dis * dis;    //记录各个顶点最短路径的信息\n\n          public://共有函数方法  \n              Graph_DG(int vexnum, int edge); // 默认构造函数 与类同名\n              ~Graph_DG();                    // 销毁时自动执行的析构函数 构造函数前 + ~\n\n              //顶点从1开始编号  而权重必须大于0 \n              bool check_edge_value(int start, int end, int weight); // 判断我们每次输入的的边的权重信息是否合法\n              void createGraph();          //创建图\n              void print();                //打印邻接矩阵\n              void Dijkstra(int begin);    //求最短路径\n              void print_path(int);        //打印最短路径\n          };\n\n> Dijkstra.cpp 源文件的代码\n          // Dijkstra.cpp 源文件的代码\n          #include\"Dijkstra.h\"// 包含声明 头文件\n\n          //默认构造函数\n          Graph_DG::Graph_DG(int vexnum, int edge) {\n              //初始化顶点数和边数\n              this->vexnum = vexnum;\n              this->edge = edge;\n              //为邻接矩阵开辟空间和赋初值\n              arc = new int*[this->vexnum];// 指针数组  顶点数 * 顶点数的 二维数组\n              dis = new Dis[this->vexnum]; // 最短路径 向量\n              for (int i = 0; i < this->vexnum; i++) {\n                  arc[i] = new int[this->vexnum];// 行数组\n                  for (int k = 0; k < this->vexnum; k++) {\n                          arc[i][k] = INT_MAX;             //邻接矩阵初始化为无穷大\n                  }\n              }\n          }\n\n          //析构函数\n          Graph_DG::~Graph_DG() {\n              delete[] dis;// delete[] 删除 最短路径 变量 数组\n              for (int i = 0; i < this->vexnum; i++) {\n                  delete this->arc[i];// 删除邻接矩阵 每一行的数组\n              }\n              delete arc;            // 删除邻接矩阵 数组\n          }\n\n          // 判断我们每次输入的的边的信息是否合法  权重必须大于0 \n          //顶点从1开始编号\n          bool Graph_DG::check_edge_value(int start, int end, int weight) {\n              if (start<1 || end<1 || start>vexnum || end>vexnum || weight < 0) {\n                  return false;\n              }\n              return true;\n          }\n\n          //创建初始邻接图 根据输入信息\n          void Graph_DG::createGraph() {\n              cout << \"请输入每条边的起点和终点（顶点编号从1开始）以及其权重\" << endl;\n              int start;\n              int end;\n              int weight;\n              int count = 0;// 输入边数记录\n              while (count != this->edge) {// 0~edge-1\n                  cin >> start >> end >> weight;// 得到 起点终点 对应权重\n                  //首先判断边的信息是否合法\n                  while (!this->check_edge_value(start, end, weight)) {\n                      cout << \"输入的边的信息不合法，请重新输入\" << endl;\n                      cin >> start >> end >> weight;\n                  }\n                  //对邻接矩阵对应上的点赋值\n                  arc[start - 1][end - 1] = weight;\n                  //无向图添加上这行代码\n                  //arc[end - 1][start - 1] = weight;\n                  ++count;\n              }\n          }\n          // 打印邻接矩阵\n          void Graph_DG::print() {\n              cout << \"图的邻接矩阵为：\" << endl;\n              int count_row = 0; //打印行的标签\n              int count_col = 0; //打印列的标签\n              //开始打印\n              while (count_row != this->vexnum) {\n                  count_col = 0;\n                  while (count_col != this->vexnum) {\n                      if (arc[count_row][count_col] == INT_MAX)\n                          cout << \"∞\" << \" \";\n                      else\n                      cout << arc[count_row][count_col] << \" \";\n                      ++count_col;// 列 下标\n                  }\n                  cout << endl;\n                  ++count_row;// 行 下标\n              }\n          }\n          // Dijkstra 求最短路径\n          void Graph_DG::Dijkstra(int begin){\n              //【1】首先初始化我们的dis数组\n              int i;\n              for (i = 0; i < this->vexnum; ++i) {\n                  //设置当前的路径\n                  dis[i].path = \"v\" + to_string(begin) + \"-->v\" + to_string(i + 1);\n                  dis[i].value = arc[begin - 1][i];// v11 v12 v13 v14 v15 v16的值\n              }\n              //设置起点到起点的路径为0\n              dis[begin - 1].value = 0;\n              dis[begin - 1].visit = true;\n\n              int count = 1;\n              //计算剩余的顶点的最短路径（ 剩余this->vexnum-1个顶点）\n              while (count != this->vexnum) {\n\n                  // 【2】找到 dis数组内的最小路径值\n                  // temp用于保存当前dis数组中最小的那个下标\n                  // min记录的当前的最小值\n                  int temp=0;// \n                  int min = INT_MAX;\n                  for (i = 0; i < this->vexnum; i++) {\n                      if (!dis[i].visit && dis[i].value < min) {\n                          min = dis[i].value;// 最小值\n                          temp = i;// 最小下标\n                      }\n                  }\n\n                  //cout << temp + 1 << \"  \"<<min << endl;\n                  //把temp对应的顶点加入到已经找到的最短路径的集合中\n                  dis[temp].visit = true;// 找到标志\n                  ++count;\n                  // 遍历该节点\n                  for (i = 0; i < this->vexnum; i++) {\n                      //注意这里的条件arc[temp][i]!=INT_MAX必须加，不然会出现溢出，从而造成程序异常\n                      if (!dis[i].visit && arc[temp][i] !=INT_MAX && (dis[temp].value + arc[temp][i]) < dis[i].value) {\n                          //如果新得到的边可以影响其他为访问的顶点，那就就更新它的最短路径和长度 v1->v4->v5 < v1->v5 更新\n                          dis[i].value = dis[temp].value + arc[temp][i];\n                          dis[i].path = dis[temp].path + \"-->v\" + to_string(i + 1);//  记录路径\n                     }\n                  }\n              }\n          }\n\n          //打印最短路径\n          void Graph_DG::print_path(int begin) {\n              string str;\n              str = \"v\" + to_string(begin);\n              cout << \"以\"<< str <<\"为起点的图的最短路径为：\" << endl;\n              for (int i = 0; i != this->vexnum; i++) {\n                  if(dis[i].value != INT_MAX)\n                  cout << dis[i].path << \"=\" << dis[i].value << endl;\n                  else {\n                      cout << dis[i].path << \" 是无最短路径的. \" << endl;\n                  }\n              }\n          } \n\n \n \n"
        },
        {
          "name": "编程面试_字符串.md",
          "type": "blob",
          "size": 25.1181640625,
          "content": "\n# 数据结构\n\n## 字符串\n\n### 1 旋转字符串\n      给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，\n      如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。\n      请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。\n      \n#### 解法1.1 暴力移位法          将字符一个一个的移动到尾部 或头部\n      // 左边的第一个字符移动到最右边\n      void LeftShiftOne(char* s, int n)\n      {\n        char tep = s[0];    // 保存左边的第一个字符 tep\n        for (int i = 1; i < n; ++i)\n         {\n            s[i - 1] = s[i];// 从前向后 靠右的字符 依次向左移动1位\n         }\n        s[n - 1] = tep;     // tep 放入最右边的位置\n      }\n      // 右边的第一个字符移动到 最左边\n      void RightShiftOne(char* s, int n)\n      {\n         char tep = s[n - 1];// 保存右边的最后一个字符 tep\n         for(int  i = n-1; i > 0; --i)\n         {\n            s[i] = s[i - 1]; // 从后向前 靠左的字符 依次向右 移动1位\n         }\n         s[0] = tep;         // tep 放入最左边的位置\n      }\n\n> 因此，若要把字符串开头的m个字符移动到字符串的尾部，则可以如下操作：\n\n    void LeftRotateSring(char *s, int n, int m)\n    {\n        while(m--)\n        {\n             LeftShiftOne(s, n);// 每次移动一个字符 一共 移动 m次\n        }\n    }\n> 而，若要把字符串尾部的m个字符移动到字符串的头部，则可以如下操作：\n\n    void ReftRotateSring(char *s, int n, int m)\n    {\n        while(m--)\n        {\n             ReftShiftOne(s, n);// 每次移动一个字符 一共 移动 m次\n        }\n    }\n> 针对长度为n的字符串来说，假设需要移动m个字符到字符串的尾部，对每个字符需要进行移动n次，那么总共需要 mn 次操作，同时设立一个变量保存第一个字符，如此，时间复杂度为O(m n)，空间复杂度为O(1)，空间复杂度符合题目要求，但时间复杂度不符合，所以，我们得需要寻找其他更好的办法来降低时间复杂度。\n#### 解法1.2：三步反转法\n      对于这个问题，换一个角度思考一下。\n      将一个字符串XY分成X(m个字符)和Y(n-m个字符)两个部分，在每部分字符串上定义反转操作，\n      如X^T，即把X的所有字符反转（如，X=\"abc\"，那么X^T=\"cba\"），那么就得到下面的结论：\n      (X^TY^T)^T=YX，显然就解决了字符串的反转问题。\n      例如，字符串 abcdef ，若要让def翻转到abc的前头，只要按照下述3个步骤操作即可：\n      1.首先将原字符串分为两个部分，即X:abc，Y:def；\n      2.将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。\n      3.反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。\n\n> 三个步骤中后两个步骤都用到了 反转一个字符串\n\n      void ReverseString(char *s, int form, int to)\n      {\n            while(from < to)// 从首尾开始交换首位位置的值，直到相遇\n            {\n                  char tep  = s[from];// 保存左边\n                  s[from++] = s[to];  //右边 交换给左边 同时左边向右移动一个位置\n                  s[to--]   = tep;    // 前右边保存的值 交换给左边 同时 右边向左移动一个位置\n            }\n      }\n\n      // 前 m 后 放在尾部\n      // 反转[0..m - 1] 反转[m..n - 1] 反转[0..n - 1]\n      void LeftRotateString(char* s, int n, int m)\n      {\n      m  %= n;// 避免左移数量大于n的情况\n      ReverseString(s, 0, m - 1);// 反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba\n      ReverseString(s, m, n - 1);// 反转[m..n - 1]，例如Y->Y^T，即 def->fed\n      ReverseString(s, 0, n - 1);// 反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。\n      }\n      // 后m个 放在 头部 \n      // 反转[0..n - m - 1] 反转[n - m..n - 1] 反转[0..n - 1]\n      void LeftRotateString(char* s, int n, int m)\n      {\n      m  %= n;// 避免左移数量大于n的情况\n      ReverseString(s, 0, n - m - 1);// 反转[0..m - 1]，套用到上面举的例子中，就是X->X^T，即 abc->cba\n      ReverseString(s, n - m, n - 1);// 反转[n - m..n - 1]，例如Y->Y^T，即 def->fed\n      ReverseString(s, 0, n - 1);// 反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed->defabc。\n      }\n\n#### 1.3 序列反转 举一反三\n      1、链表翻转。给出一个链表和一个数k，比如，链表为1→2→3→4→5→6，\n      k=2，则翻转后2→1→6→5→4→3，\n      若k=3，翻转后3→2→1→6→5→4，\n      若k=4，翻转后4→3→2→1→6→5，用程序实现。\n      注解：原序列 XY 则反转后的序列为 X^T Y^T\n\n      2、单词翻转。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变，句子中单词以空格符隔开。\n      为简单起见，标点符号和普通字母一样处理。例如，输入“I am a student.”，则输出“student. a am I”。\n      注解：先将整个字符串反转，在将其中每个单词反转回来\n\n      void Reverse_word(char *str)      \n      {      \n          if(str == NULL)// 空指针 返回 \n              return;      \n          int len = strlen(str);// 字符串长度\n          // 反转整个字符串\n          ReverseString(str, 0, len - 1);    \n          int s = 0;//每个单词的 起始 index\n          int e = 0;// 每个单词的 后 index\n          for(int i = 0; i < len; i++) // 遍历字符串 查找每一个单词\n          {       \n              e = i;      \n              if(str[e] == ' ')// 此处 遇到空格 \n              {      \n                  ReverseString(str, s, e-1); // 反转这个单词 \n                  s = e+1;// 更新 单词的起始指针 \n              }      \n          }    \n          ReverseString(str, s, len - 1);  // 反转最后一个单词 因为最后一个单词后面无空格\n      }  \n\n\n### 2 字符串包含\n\n      给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\n      为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &A, string &B)\n      比如，如果是下面两个字符串：\n      String 1：ABCD\n      String 2：BAD\n      答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集，当 String 2：BAE 时答案为false\n\n#### 解法2.1 暴力匹配法\n      判断string2中的字符是否在string1中?最直观也是最简单的思路是，\n      针对string2中每一个字符，逐个与string1中每个字符比较，看它是否在String1中。\n> 代码可如下编写：     \n\n      bool StringContain(string &a, string &b)\n      {\n            for(int i = 0; i < b.size(); ++i)\n            {\n                  int j;\n                  //b中的每一个字符，从a的开头一直向后找，直到出现相同字符/已经到达末尾\n                  for(j = 0; (j <  a.size()) && (a[j] != b[i]); ++j) ;\n                  if(j >= a.size()) return false;//如果到达末尾 b中的这个字符 都还没有 在a中找到一样的字符 ，则返回错误\n            }\n            return true;//b中每个字符都在 a中找到了 返回 true\n      }\n> 假设n是字符串String1的长度，m是字符串String2的长度，那么此算法，需要O(n*m)次操作。显然，时间开销太大，应该找到一种更好的办法。\n\n#### 解法2.2 排序后匹配法 如果允许排序的话，我们可以考虑下排序 \n      比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。\n      两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。\n> 代码可如下编写： \n\n      //注意A B中可能包含重复字符，所以注意A下标不要轻易移动。这种方法改变了字符串。如不想改变请自己复制\n      bool StringContain(string &a,string &b)\n      {\n          sort(a.begin(),a.end());// 采用最常用的快速排序\n          sort(b.begin(),b.end());\n          for (int pa = 0, pb = 0; pb < b.length();)// b中的每一个字符\n          {\n              while ((pa < a.length()) && (a[pa] < b[pb]))// 在a中找 \n              {\n                  ++pa;\n              }\n              if ((pa >= a.length()) || (a[pa] > b[pb]))//找到最后 或 a中的字符已经大于b对应的字符了 就已经无相等的了\n              {\n                  return false;\n              }\n              //到这里就是 有相同的字符 a[pa] == b[pb]\n              ++pb;//遍历 b中 下一个字符\n          }\n          return true;\n      }\n\n#### 解法2.3 素数乘积取余法\n      按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。\n      遍历长字符串，求得每个字符对应素数的乘积f。\n      遍历短字符串，判断乘积f 能否被短字符串中的字符对应的素数整除，如果整除则包含该字符，如果不能整除则这个字符不包含。\n      输出结果。\n> 代码可如下编写： \n\n      //此方法只有理论意义，因为整数乘积很大，有溢出风险\n      // 此种素数相乘的方法看似完美，但缺点是素数相乘的结果容易导致整数溢出。\n      // 算法的时间复杂度为O(m+n)的最好的情况为O(n)\n      //（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便退出，返回false）n为长字串的长度，空间复杂度为O(1)\n      bool StringContain(string &a,string &b)\n      {\n          const int p[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,61, 67, 71, 73, 79, 83, 89, 97, 101};\n          int f = 1;\n          for (int i = 0; i < a.length(); ++i)\n          {\n              int x = p[a[i] - 'A'];// 字符对应的素数\n              if (f % x)// 对于长字符串中出现相同的字符 可不用再次 相乘\n              {\n                  f *= x;// a中所有不相同字符 对应的素数 的乘积\n             }\n          }\n          for (int i = 0; i < b.length(); ++i)\n          {\n              int x = p[b[i] - 'A'];// 字符对应的素数\n              if (f % x)// 能够被整除 则说明出现相同的字符\n              {\n                  return false;// 否者出现 了一个不相同的字符 则退出\n              }\n          }\n          return true;\n      }\n\n#### 解法2.4 Hash 签名查找\n      事实上，可以先把长字符串a中的所有字符都放入一个Hashtable里，\n      然后轮询短字符串b，看短字符串b的每个字符是否都在Hashtable里，\n      如果都存在，说明长字符串a包含短字符串b，否则，说明不包含。\n      再进一步，我们可以对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。\n> 代码可如下编写： \n\n      // “最好的方法”，时间复杂度O(n + m)，空间复杂度O(1)\n      // 这个方法的实质是用一个整数代替了hashtable，空间复杂度为O(1)，时间复杂度还是O(n + m)。\n      bool StringContain(string &a,string &b)\n      {\n          int hash = 0;\n          for (int i = 0; i < a.length(); ++i)\n          {\n              hash |= (1 << (a[i] - 'A'));// (a[i] - 'A')为0~25 右移动一位 位或上签名hash 得到 长串a的最后签名\n              // 相当于把 a的每一个不同的 字符 放入 每一个而进行位上\n          }\n          for (int i = 0; i < b.length(); ++i)\n          {\n              if ((hash & (1 << (b[i] - 'A'))) == 0)// 位与 上(1 << (b[i] - 'A')) 的0的话就说明对应的位上（字符）与a中午匹配\n              {\n                  return false;// 对应位上 a中未出现相应的字符  则查找失败\n              }\n          }\n          return true;\n      }\n#### 2.5 字符串包含 举一反三 变位词\n      如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串。\n      比如bad和adb即为兄弟字符串，现提供一个字符串，如何在字典中迅速找到它的兄弟字符串，请描述数据结构和查询过程。\n      解答: a包含b b也包含a\n      数据结构为：\n      设置一个64bit的变量long long hash1，将字符串A中的字符通过移位在hash1中表示；设置另外一个64bit的变量long long hash2, 将字符串B中的字符通过移位在hash2中表示。\n      查询过程：\n      比较hash1与hash2的大小，若相等，则为兄弟字符串；若不等，则不为兄弟字符串。    \n> 代码可如下编写：    \n\n      bool anagramJudge(string &a, string &b){\n          long long hash1=0;\n          long long hash2=0;\n          for(int i=0; i<a.length(); i++){\n              hash1 |= (1<<(a[i] - 'A'));// a字符串的 hash 签名\n          }\n          for(int j=0; j<b.length(); j++){\n              hash2 |= (1<<(b[j] - 'A'));// b字符串的 hash 签名\n          }\n          if(hash1 == hash2)// 若相等，则为兄弟字符串\n              return true;\n          else\n              return false;// 若不等，则不为兄弟字符串\n      }\n\n### 3字符串转换成整数\n      输入一个由数字组成的字符串，把它转换成整数并输出。\n      例如：输入字符串\"123\"，输出整数123。\n      给定函数原型int StrToInt(const char *str) ，\n      实现字符串转换成整数的功能，不能使用库函数atoi。\n#### 3.1不考虑溢出 正负号\n      以\"123\"作为例子：\n         当我们扫描到字符串的第一个字符'1'时，由于我们知道这是第一位，所以得到数字1。\n         当扫描到第二个数字'2'时，而之前我们知道前面有一个1，\n      所以便在后面加上一个数字2，那前面的1相当于10，因此得到数字：1*10+2=12。\n         继续扫描到字符'3'，'3'的前面已经有了12，由于前面的12相当于120，\n      加上后面扫描到的3，最终得到的数是：12*10+3=123。\n      因此，此题的基本思路便是：\n      从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字。\n> 代码可如下编写：     \n\n      int StrToInt(const char *str)\n      {\n          if(str == NULL)   // 空指针返回\n             return -1;\n          int n = 0;\n          int isNeg = 0;    // 负数标志\n          if(str[0] == '-') isNeg = 1;\n          while (*str != 0) // 遍历到字符串末尾\n          {\n              if(*str > '9' || *str < '0') {continue; ++str;}// 跳过非数字字符 或者 直接 退出 return -1;\n              int c = *str - '0';\n              n = n * 10 + c;// 累加和\n              ++str;         // 移动指针\n          }\n          if(isNeg) return -n;\n          else      return n;\n      }\n#### 3.2 完整的考虑溢出等情况\n\n      int StrToInt(const char* str)\n      {\n          static const int MAX_INT = (int)((unsigned)~0 >> 1);\n          static const int MIN_INT = -(int)((unsigned)~0 >> 1) - 1;\n          unsigned int n = 0;\n\n          //判断是否输入为空\n          if (str == 0)\n          {\n              return 0;\n          }\n\n          //处理空格 跳过第一个空格\n          while (isspace(*str))\n              ++str;\n\n          //处理正负\n          int sign = 1;\n          if (*str == '+' || *str == '-')\n          {\n              if (*str == '-')\n                  sign = -1;\n              ++str;// 如果有正负号 确定标志后 从符号后一位开始处理\n          }\n\n          //确定是数字后才执行循环\n          while ( *str > '0' && *str < '9' )\n          {\n              //处理溢出\n              int c = *str - '0';// 字符转换成 数字\n              if (sign > 0 && (n > MAX_INT / 10 || (n == MAX_INT / 10 && c > MAX_INT % 10)))\n              {\n                  n = MAX_INT;\n                  break;\n              }\n              else if (sign < 0 && (n >(unsigned)MIN_INT / 10 || (n == (unsigned)MIN_INT / 10 && c > (unsigned)MIN_INT % 10)))\n              {\n                  n = MIN_INT;\n                  break;\n              }\n\n              //把之前得到的数字乘以10，再加上当前字符表示的数字。\n              n = n * 10 + c;\n              ++str;\n          }\n          return sign > 0 ? n : -n;\n      }\n\n#### 3.3 举一反三\n      实现string到double的转换\n> 代码可如下编写：   \n\n      double StrToDou(const char *str)\n      {\n          if(str == NULL)   // 空指针返回\n             return -1;\n          double result = 0.0;// 最后的值\n          double dec = 10.0;// 小数位比值\n          int isNeg = 0;   // 负数标志\n          int isDec = 0;\n          if(str[0] == '-') isNeg = 1;\n          while (*str != 0) // 遍历到字符串末尾\n          {\n              if(*str == '.') {isDec = 1; ++str;}//是小数\n              else if(*str > '9' || *str < '0') {continue; ++str;}// 跳过非数字字符 或者 直接 退出 return -1;\n              if(!isDec) // 整数部分\n                  result = result * 10 + *str - '0';// 整数部分 累加和\n              else //识别小数点之后进入 这个分支\n                  { \n                   result = result + (*str - '0')/dec;// 小数部分 算法\n                   dec *= 10;// 小数位比值递增\n                  }\n              ++str;         // 移动指针\n          }\n          if(isNeg) return -result;\n          else      return result;\n      }\n\n\n### 4 字符串 回文 判断\n#### 4.1 首尾并进判断法\n      同时从字符串头尾开始向中间扫描字串，如果所有相对的字符都一样，那么这个字串就是一个回文。\n      采用这种方法的话，我们只需要维护头部和尾部两个扫描指针即可。 Palindrome  英 ['pælɪndrəʊm]  pai lin drow mu\n> 代码可如下编写：\n\n      // 输入字符指针 s 和 字符串大小 num\n      bool IsPalindrome(const char* s, int num)\n      {\n            if(s == NULL || num < 2)  return false;//指针为空 / 字符串长度小于2\n            // 定义并初始化 首尾指针\n            const char* low, *high;// 首尾指针\n            low = s;// 首指针\n            high = s + num - 1;// 尾指针\n            while(low < high){\n                  if(*low ! *high) return false;// 出现一次相对应位置的字符不相同 就返回错误\n                  ++low;\n                  --high;\n            }\n            return true; // 到这里的话 就证明 相对应位置上的 字符相同 为 回文\n      }\n> 这是一个直白且效率不错的实现，时间复杂度：O(n)，空间复杂度：O(1)。\n上述解法一从两头向中间扫描，那么是否还有其它办法呢？我们可以先从中间开始、然后向两边扩展查看字符是否相等。\n\n#### 判断一条单向链表是不是“回文\n      对于单链表结构，可以用两个指针从两端或者中间遍历并判断对应字符是否相等。\n      但这里的关键就是如何朝两个方向遍历。由于单链表是单向的，所以要向两个方向遍历的话，可以采取经典的快慢指针的方法，\n      即先位到链表的中间位置，再将链表的后半逆置，最后用两个指针同时从链表头部和中间开始同时遍历并比较即可。\n\n#### 判断一个栈是不是“回文”\n      对于栈的话，\n      只需要将字符串全部压入栈，然后依次将各字符出栈，\n      这样得到的就是原字符串的逆置串，\n      将逆置串和原字符串各个字符比较，就可以判断了。\n      \n### 5 最长回文子串 \n      如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，\n      例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。\n      那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？\n#### 5.1 遍历子串中心位置，找最大回文子串(分为子串长度为 奇数和偶数的情况)\n> 参考代码如下：\n\n      int LongestPalindrom(const char* s, int num){\n      if(s == NULL || num < 2)  return false;//指针为空 / 字符串长度小于2\n      int i,j,max,cnt;// ij 为循环变量 cnt 记录每一个回文子串的长度\n      max = 0;//最大字回文字符串长度 初始化为0\n\n      // 遍历每一个子串 的 中心点\n      for(i = 0; i < n; ++i){ \n         // 对于子串长度为奇数的情况\n           for(j = 0; (i - j >= 0)&&(i + j < n); ++j){// j为以i字符点为中心 向两边扩展的间隔 区别首尾区间 [0, n-1]\n                  if(s[i - j] != s[i + j]) break; // 间隔相同的位置 字符不同 结束回文\n                  cnt = j*2 + 1;// 已此中心点i 的回文子串长度为 间隔j *2 + 1(中间一个字符)\n            }\n            if(cnt > max) max = cnt;// 保存最长的 回文子串的 长度\n\n        // 对于子串 长度为 偶数的情况\n            for(j = 0; (i - j >= 0)&&(i + j + 1 < n); ++j){\n                  if(s[i - j] != s[i + j +1]) break; // 间隔相同的位置 字符不同 结束回文\n                  cnt = j*2 + 2;\n            }\n            if(cnt > max) max = cnt;// 保存最长的 回文子串的 长度   \n       }\n      return max;\n      }\n\n### 6 字符串的全排列\n      输入一个字符串，打印出该字符串中字符的所有排列。\n      例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\n      abc、acb、bac、bca、cab 和 cba。\n#### 6.1 递归实现   \n      从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，\n      如此递归处理，从而得到所有元素的全排列。     Permutation  英 [pɜːmjʊ'teɪʃ(ə)n]  Peer mu tai xing\n      以对字符串abc进行全排列为例，我们可以这么做：以abc为例 \n      abc a和a交换后 abc 对a后的 bc进行全排列\n      abc a和b交换后 bac 对b后的 ac进行全排列\n      abc a和c交换后 cba 对c后的 ba进行全排列\n      \n> 参考代码如下： \n\n      void CalcAllPermutation(char* s, int from, int to)\n      {\n      if (s == NULL || to < 2)  return;\n\n      // 打印排列后的字符串\n      if (from == to)/\n      {\n        for (int i = 0; i <= to; i++)\n            cout << perm[i];\n        cout << endl;\n      }\n      else\n      {\n        for (int j = from; j <= to; j++)// 从当前位置from开始 依次向后和j位置交换元素后 对from后的元素进行全排列\n        {\n            swap(perm[j], perm[from]);// 从当前位置from开始 依次向后和j位置交换元素\n            CalcAllPermutation(perm, from + 1, to);// 对from后的元素 [from + 1, to]进行全排列\n            swap(perm[j], perm[from]);// 再还原字符串\n        }\n      }\n      }\n\n## 习题集 \n### 1 第一个只出现一次的字符\n      在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。\n> 遍历法\n\n      //O(n^2)的时间复杂度\n      char FirstNotRepeatingChar(char *pS, int num)\n      {\n          //如果是空指针，返回\\0\n          if(pS == NULL) return '\\0';\n          int i,j,flag=0;\n          bool* bap;\n          bap = (bool*)maoolc(sizeof(bool)*num);\n          for(i =0; i < n; ++i) *bap[i] = false;\n          for(i=0; i<num-1; ++i)// 遍历 前置 字符\n          { \n              if(*bap[i]) continue;// 当前 字符串 之前出现过 跳过本次循环   有问题 后面再出现相同的呢？？？\n              for(j=i+1; j<len; ++j)// 和其后面的字符 依次作比较\n              {\n                  if(pS[i] == pS[j]) {*bap[j] = true; break;}// i位置上的字符 后面有出现 跳过 这个字符\n              }\n              return pS[i];// 打印这个出现一次的字符\n          }\n          return '\\0';\n      }\n\n> 哈希表法 强烈推荐\n\n      //O(n)的时间复杂度\n      char FirstNotRepeatingChar(char *pS)\n      {\n          //如果是空指针，返回\\0\n          if(pS == NULL)  return '\\0';\n          //字符（char）是一个长度为8bit的数据类型，因此总共最多能够表示256种字符。 \n          //定义hash表长度256，并创建哈希表\n          const int len=256;\n          int hashtable[len];\n          for(int i=0;i<len;i++)  hashtable[i]=0;\n\n          char *pHashkey=pS;\n          // 第一遍遍历字符串，求出每个字符出现的次数\n          // 字符根据其ASCII值作为数组的下标对应数组的一个数字，而数组中存储的是每个字符出现的次数\n          while((*pHashkey)!='\\0') hashtable[*(pHashkey++)]++;\n          pHashkey=pS;\n          //第二遍遍历字符串，求出第一个只出现一次的字符，每次都是按照字符串的顺序遍历\n          while((*pHashkey)!='\\0')\n          {\n              if(hashtable[*pHashkey]==1)// 记录只出现一次\n                  return *pHashkey;\n              pHashkey++;\n          }\n          return '\\0';\n      }\n\n\n"
        },
        {
          "name": "编程面试_数组.md",
          "type": "blob",
          "size": 23.7001953125,
          "content": "\n# 数组面试题\n\n        笔试和面试中，除了字符串，另一类出现频率极高的问题便是与数组相关的问题。\n        解题思路：\n        先一般考虑“万能的”暴力穷举（递归、回溯），如求n个数的全排列或八皇后（N皇后问题）。\n        但因为穷举时间复杂度通常过高，所以需要考虑更好的方法。\n\n如   分治法（通过分而治之，然后归并）；   \n\n以及 空间换时间（如活用哈希表）。    \n\n此外，选择合适的 数据结构 可以显著提升效率，如寻找最小的k个数中，用 堆 代替 数组，也可借鉴快排思想，中枢分区方法。    \n\n再有，如果题目允许排序，则可以考虑  排序。   \n\n寻找和为定值的两个数中，先排序，然后用 前后两个指针 往中间扫描。   \n\n        而如果如果已经排好序了（如杨氏矩阵查找中），则想想有无必要二分，二分法。\n\n        但是，如果题目不允许排序呢？这个时候，\n\n        我们可以考虑 不改变数列顺序的 贪心算法（如 最小生成树Prim、Kruskal 及 最短路dijkstra）\n\n        或 动态规划（如 01背包问题，每一步都在决策）。\n\n        最后，注意细节处理，不要忽略边界条件，如字符串转换成整数。\n        \n# 基础\n```c\nint (*p)[10];// 首先(*p)，p是一个指针，int [10],是一个包含10个int的数组，该指针p指向，这个数组\n             // 是数组指针\nint *p[10];  // 写成 int* p[10];比较合适，首先 [10]是一个包含 10个元素的数组，该元素类型为int*,即指向整形的指针\n             // 是指针数组\n\nint a[10];// 整数数组\nprintf(\"%x\\n\",&a);// &a 是取一个数组的地址，是一个指针指向一个包含10个元素的数组，类型为 int (*p)[10];\nprintf(\"%x\\n\",a); // a 数组名，默认为数组首元素 a[0]的地址 和数组a的地址是同一个地址，该类型为指向一个整数的指针，即 int *p；\n// 以上 &a 和 a 的值是一样的，是a[0]元素的存储地址，\n// 但是含义不一样， &a指向了10个连续存储的整数, 而 a指向了一个 整数，即 a[0]\n\n// 类似的\n\nint (*p[])(int); // 函数指针数组。\n// 首先(*p[]) 是一个指针数组，指向的类型为 int (int)是一个函数类型，输入一个int类型参数，输出一个int类型参数\n\nint (*p())[];    // 返回数组指针的函数。\n// 首先 (*p()) 是一个返回指针类型的函数，该指针类型指向 int [] 即整形数组，即,p是一个返回整形数组指针的函数\n\nint *p()[]       // 字面上可以解释为返回指针数组的函数，不过函数是不能返回数组的。\n// () 是一个函数， 返回类型为 int* []，是一个指针数组\n\nint *(*a())()    // 这是一个函数，它没有参数，它的返回值是一个函数指针，这个指针指向的函数，也没有参数，且返回值是int型的指针。\n\n```        \n        \n## 第一题 寻找集合中的最小的K个数\n        输入n个整数，输出其中最小的k个。\n### 解法1 先排序再选择\n        要求一个序列中最小的k个数，按照惯有的思维方式，\n        则是先对这个序列从小到大排序，\n        然后输出前面的最小的k个数。\n        至于选取什么的排序方法，我想你可能会第一时间想到快速排序\n        我们知道，快速排序平均所费时间为n*logn，\n        然后再遍历序列中前k个元素输出即可。\n        因此，总的时间复杂度：O（n * log n)+O(k)=O（n * log n）。\n### 解法2 选择排序思想\n        解法二\n\n        咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。\n        既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：\n        \n        1、遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；\n        \n        2、对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））；\n        \n        3、继续遍历剩余n-k个数。\n           假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果x < kmax ，用x替换kmax，\n           并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组，直到，k个数是此时最小的\n           \n        每次遍历，更新或不更新数组的所用的时间为O（k）或O（0）。故整趟下来，时间复杂度为n*O（k）=O（n*k）。  \n### 解法3 利用最大堆 作为容器\n\n        更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：\n        \n        1、用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；\n        \n        2、堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）\n        \n        3、遍历剩余n-k个数。\n          假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：\n          如果x < kmax，用x替换kmax，然后更新堆（用时logk）；\n          否则不更新堆。\n        这样下来，总的时间复杂度:O（k+（n-k）*logk）=O（n*logk）。\n        此方法得益于堆中进行查找和更新的时间复杂度均为：O(logk)\n        （若使用解法二：在数组中找出最大元素，时间复杂度：O（k））。  \n        \n### 解法4 利用快排思想 得到大小数的 分区中枢\n        int Cut(int a[], int low, int high){\n          int temp = a[low];// 区间第一个元素 可以随机选择 在替换到low的位置\n          while(low < high){\n            while((low < higt)&&(a[high] > temp)) --high;// 从右边向左寻找比 temp小的元素 a[higt]\n            a[low] = a[high];// 把比temp小的元素 放在 原来temp的位置(左边小的区域)\n            while((low < high)&&(a[low] < temp))  ++low;// 从左边寻找比 temp大的元素a[low] 放在右边 high的位置\n            a[high] = a[low];\n           }\n          a[low] = temp; // 临时变量 放在 中枢位置\n          return low;    // 返回中枢位置\n        }\n\n        // 在数组a中选择k个最小的元素  块选  非递归调用\n        void QuickSelest(int a[], int low, int high, int k){\n          int index =  Cut(a, 0, n-1);// 首先得到一个中枢\n          while(index != k-1){// 非递归调用\n          if(index > k - 1) index = Cut(a, low, index -1);// 左半部分小的元素个数大于k 在左半部分找 中枢\n          else              index = Cut(a, index+1, high);// 左半部分小的元素个数小于k 右半部分还有，在右半部分找 中枢\n          }\n         // 打印\n         for(int i = 0; i<k; ++i) cout<<a[i];\n         cout << endl;\n        }\n\n        // 而快排为   是递归调用\n        void QuickSort(int a[], int low, int high){\n          int index;\n          if(low < high){\n            index = Cut(a, low, high);//选取中枢位置\n            QuickSort(a, low, index-1);//对左边快排\n            QuickSort(a, index+1, high);//对右边快排\n          }\n        }\n\n        // 二分查找   非递归版本\n        int BinarySearch(int a[], int low, int high, int key){\n        int mid;//中间元素\n        while(low < high){\n        int mid = low + ((high - low)>>1);//中间元素的 下标 在循环体内 不停的被改变\n        if( key < a[mid] )     high = mid - 1;// 查找的元素小于中值  高区间移至 mid-1\n        elae if(key > a[mid] ) low  = mid + 1;// 查找元素大于中值， 将低区间移至 mid+1\n        else return mid;\n        }\n        return -1;//未找打 返回-1\n        }\n\n        // 二分查找   递归版本\n        int BinarySearch(int a[], int low, int higt, int key){\n        int mid = low + ((high - low)>>1);//中间元素的 下标\n        if(low < high){\n          if(key < a[mid])      return BinarySearch(a, low, mid-1, key);\n          else if(key > a[mid]) return BinarySearch(a, mid+1, high, key);\n          else return mid;\n        }\n        return -1;\n        }\n        \n## 第二题 寻找和为定值的两个数\n        输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。\n        要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，输出任意一对即可。\n        例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。\n        思路：暴力搜索 时间复杂度 n^2\n        其二，二分法（相当于用两个指针），从前后向中间搜索，看情况移动左右指针\n        \n> 代码如下\n\n        // 二分（若无序，先排序后二分），时间复杂度总为O(N log N)，空间复杂度为O（1）；\n        void findTwo2(int a[], int low, int high, int sum){\n         //sort(a, a+high+1);   如果数组非有序的，那就事先排好序O(N log N)\n                 while(low < high){\n                        if(a[low] + a[high] > sum)      --high;//太大 right减少\n                        else if(a[low] + a[high] < sum) ++low; //太小 low增加\n                        else cout << a[low] << a[high] < endl;\n                 }\n                cout << \"Can't found\" < endl;\n        }\n> 总结 \n\n        不论原序列是有序还是无序，解决这类题有以下三种办法：\n        1、二分（若无序，先排序后二分），时间复杂度总为O(N log N)，空间复杂度为O（1）；\n        2、扫描一遍X-S[i] 映射到一个数组或构造hash表，时间复杂度为O(N)，空间复杂度为O(N)；\n        3、两个指针两端扫描（若无序，先排序后扫描），时间复杂度最后为：\n           有序O(N)，无序O(N log N + N)=O(N log N)，空间复杂度都为O(1)。\n        所以，要想达到时间O(N)，空间O(1)的目标，除非原数组是有序的（指针扫描法），\n        不然，当数组无序的话，就只能先排序，后指针扫描法或二分（时间 O(Nlog N)，空间O(1)），\n        或映射或hash（时间O(N)，空间O(N)）。时间或空间，必须牺牲一个，达到平衡。\n        综上，若是数组有序的情况下，优先考虑两个指针两端扫描法，以达到最佳的时O(N)，空O(1)效应。\n        否则，如果要排序的话，时间复杂度最快当然是只能达到O(N log N)，空间O(1)则不在话下。\n### 举一反三：\n        输入：int[]nums int target \n        输出：符合要求的所有情况 \n        给定一个int类型的数组，sum2、sum3、sum4分别输出2、3、4个元素的和为target的所有结果，不能重复，并且结果从小到大排序。\n        【解法】： \n        三个题目均可以使用双指针的做法。首先对原始数组进行排序，排序的意义为：\n        （1）保证最后结果的有序性；\n        （2）从小到大的查找是否满足target，\n        若小于他，则start指针往前走 ++start，\n        若大于他，这end指针往回走 --end； \n        接着第一个指针从最小的元素开始，\n        第二个指针从最大的元素开始，通过对和与target进行比较，判断start和end的走向。 \n        sum2可以不用循环，只需要两个指针。\n        同时sum2还可以有另一种解法，从左到右判断，采用一个集合保存判断过的结果，从集合中查找target-nums[i]是否存在；（n） \n        sum3采用一层循环，start从循环处的下一个元素开始（n`2）\n        sum4采用两层循环，第二层循环从第一层循环的i值开始，最内部start从第二层循环的下一个元素开始。(n`3) \n        \n### 第三题 寻找和为定值的多个数\n        题目描述\n        输入两个整数n和sum，从数列1，2，3.......n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。\n> 01背包问题求解\n\n        解法一\n        注意到取n，和不取n个区别即可，考虑是否取第n个数的策略，可以转化为一个只和前n-1个数相关的问题。\n        如果取第n个数，那么问题就转化为“取前n-1个数使得它们的和为sum-n”，对应的代码语句就是sumOfkNumber(sum - n, n - 1)；\n        如果不取第n个数，那么问题就转化为“取前n-1个数使得他们的和为sum”，对应的代码语句为sumOfkNumber(sum, n - 1)。\n\n        0-1背包问题\n        0-1背包问题是最基础的背包问题，其具体描述为：\n        有N件物品和一个容量为V的背包。放入第i件物品耗费的费用是Ci，得到的价值是Wi。\n        求解将哪些物品装入背包可使价值总和最大。\n        简单分析下：这是最基础的背包问题，特点是每种物品仅有一件，可以选择放或不放。\n        用子问题定义状态：即F[i, v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：\n        F[i, v] = max{F[i-1, v], F[i-1, v-Ci ] + Wi}\n        根据前面的分析，我们不难理解这个方程的意义：\n        “将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），\n        那么就可以转化为一个只和前 i-1 件物品相关的问题。\n        即：\n        如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为 F[i-1, v ]；\n        如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-Ci的背包中”，\n        此时能获得的最大价值就是F[i-1, v-Ci]再加上通过放入第i件物品获得的价值Wi。\n\n        list<int>list1;\n        void SumOfkNumber(int sum, int n)\n        {\n            // 递归出口\n            if (n <= 0 || sum <= 0)\n                return;\n            // 输出找到的结果\n            if (sum == n)\n            {\n                // 反转list\n                list1.reverse();\n                for (list<int>::iterator iter = list1.begin(); iter != list1.end(); iter++)\n                    cout << *iter << \" + \";\n                cout << n << endl;\n                list1.reverse()//此处还需反转回来\n            }\n            list1.push_front(n); //放置进背包 当前占了n 前面剩余sum-n空间  典型的01背包问题\n            SumOfkNumber(sum - n, n - 1);//“放”n，前n-1个数“填满”sum-n\n\n            list1.pop_front();// 取出来 不放进去 前面还剩余sum的空间\n            SumOfkNumber(sum, n - 1); //不“放”n，n-1个数“填满”sum\n        }\n\n## 第四题  最大连续子数组和\n        事实上，当我们令currSum为当前最大子数组的和，maxSum为最后要返回的最大子数组的和，当我们往后扫描时，\n\n        对第j+1个元素有两种选择：要么放入前面找到的子数组，要么做为新子数组的第一个元素；\n        \n        如果currSum加上当前元素a[j]后不小于a[j]，则令currSum加上a[j]，\n        否则currSum重新赋值，置为下一个元素，即currSum = a[j]。\n        \n        同时，当currSum > maxSum，则更新maxSum = currSum，否则保持原值，不更新。\n        即：\n        currSum = max(a[j], currSum + a[j])\n        maxSum = max(maxSum, currSum)\n        举个例子，当输入数组是1, -2, 3, 10, -4, 7, 2, -5，那么，currSum和maxSum相应的变化为：\n        currSum： 0 1 -1 3 13 9 16 18 13\n        maxSum ： 0 1 1 3 13 13 16 18 18\n 参考代码如下：\n         int MaxSubArr(int* a, int num){\n         int currSum = 0;//初始化 当前和 为0\n         int maxSum = a[0];//初始化 第一个元素为 最大和\n         for(int j = 0; j < n; ++j ){\n                 currSum = (currSum + a[j] > a[j] ) ? (currSum + a[j]) : a[j];\n                 maxSum = maxSum > currSum ? maxSum : currSum;\n         }\n         return maxSum;\n         }\n \n## 第五题 跳台阶问题\n        一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。\n        求总共有多少总跳法，并分析算法的时间复杂度。\n\n#### 解法一：首先考虑最简单的情况，函数递归调用求解。\n        如果只有1级台阶，那显然只有一种跳法。\n        如果有2级台阶，那就有两种跳的方法了：\n                一种是分两次跳，每次跳1级；\n                另外一种就是一次跳2级。\n        现在我们再来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。\n        当n>2时，第一次跳的时候就有两种不同的选择：\n        一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；\n        另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。\n        因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)。\n        我们把上面的分析用一个公式总结如下：\n                /  1                             n = 1\n        f(n)=      2                             n = 2\n                \\  f(n-1) + f(n-2)               n > 2\n        原来上述问题就是我们平常所熟知的Fibonacci数列问题。\n\n> 可编写代码，如下：\n\n        longn long Fibonacci(unsigned int n){\n        int result[] = [0, 1, 2];\n        if (n <= 2)  \n                return result[n];\n        else \n                return Fibonacci(n-1) + Fibonacci(n-2);\n        }\n        \n####  那么，如果一个人上台阶可以一次上1个，2个，或者3个呢？这个时候，公式是这样写的：\n                / 1                                      n = 1\n        f(n)=     2                                      n = 2\n                  4                                      n = 3       //111, 12, 21, 3\n                \\ f(n-1) + f(n-2) + f(n-3)               n > 3\n\n> 可编写代码，如下：\n\n        longn long F(unsigned int n){\n        int result[] = [0, 1, 2, 4];\n        if (n <= 3)  \n                return result[n];\n        else \n                return F(n-1) + F(n-2) + F(n-3);\n        }\n        \n#### 解法二，循环递推公式求解\n解法一用的递归的方法有许多重复计算的工作，事实上，我们可以从后往前推，一步步利用之前计算的结果递推。+\n初始化时，dp[0]=dp[1]=1，\n然后循环递推计算即可：dp[n] = dp[n-1] + dp[n-2]，当前解 等于前两次的和\n\n> 参考代码如下：\n\n        // 1,1,2,3,5,8,13,21..\n        int ClimbStairs(int n){// n级台阶，可以一次调1个台阶和2个台阶两种选择，有多少种跳发\n                int dp[3] = {1, 1};// 保存当前值 上一次值 上上次值的数组\n                if(n <=1) return 1;\n                else {\n                        for(int i = 2; i <= n; ++i){\n                                d[2] = d[1] + d[0];\n                                d[0] = d[1];\n                                d[1] = d[2];// 更新数组的值\n                        }\n                    }\n        }\n\n#### 换硬币问题  \n        // 想兑换100元钱，有1,2,5,10四种钱，问总共有多少兑换方法。 递推公式 arr[j] += arr[j - dimes[i]];\n        const int N = 100;\n        int dimes[] = { 1, 2, 5, 10 };\n        int arr[N + 1] = { 1 };//存放每一个总钱数可以的兑换次数\n        int coinExchange(int n)   //非递归实现       \n        {\n                for (int i = 0; i < sizeof(dimes) / sizeof(int); ++i)//对于每一个面值\n                {\n                    for (int j = dimes[i]; j <= n; ++j)// 遍历总钱数j ~ n\n                    {\n                        arr[j] = arr[j] + arr[j - dimes[i]];\n                        //分为两种情况，\n                        //总钱数j，如果没有换当前硬币i，那么是多少？arr[j]\n                        //加上，如果换了当前硬币dimes[i]，总值减少为 j-dimes[i]，此时又是多少种兑换方法？arr[j-dimes[i]]\n                    }\n                }\n                return arr[n];\n        }\n\n## 奇偶调序\n        输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。要求时间复杂度为O(n)。\n### 方法1 利用快排思想 奇偶数分类下标 头指针，向右移动  尾指针，向左移动\n        借鉴partition 分治 的实现一，我们可以考虑维护两个指针，\n        一个指针指向数组的第一个数字，我们称之为头指针，向右移动；\n        一个指针指向最后一个数字，称之为尾指针，向左移动。\n\n        这样，两个指针分别从数组的头部和尾部向数组的中间移动，\n        如果第一个指针指向的数字是偶数而\n        第二个指针指向的数字是奇数，我们就交换这两个数字。\n        因为按照题目要求，最终是为了让奇数排在数组的前面，偶数排在数组的后面，\n        所以头指针理应指向的就是奇数，尾指针理应指向的就是偶数，\n        \n        故当头指针指向的是偶数且尾指针指向的是奇数时，我们就当立即交换它们所指向的数字。\n> 代码实现：\n\n        // 判断是否为奇数\n        bool isOddNumber(int n){\n        return n & 1 == 1; // 奇数 的最后一个二进制位为1\n        }\n        \n        // void OddEvenChange(int *a, int num){\n                if(a == NULL|| num == 0) return;// 空指针 以及长度为0 直接返回\n                int* low  = a;           // 头指针\n                int* high = a + num - 1; // 尾指针\n                while(low < high){\n                        if(!isOddNumber(*high) --high;//如果 high指针指向的是偶数，正常，向前移 减小\n                        else if(isOddNumber(*low) ++low;//如果 low指针指向的是奇数，正常，向后移 加大\n                        else //否则都不正常，交换\n                        //swap是STL库函数，声明为void swap(int& a, int& b);\n                        swap(*pBegin, *pEnd);\n                }\n        }\n> 本方法通过头尾两个指针往中间扫描，一次遍历完成所有奇数偶数的重新排列，时间复杂度为O(n)。\n\n### 荷兰旗 三色球 问题  三类的分配问题\n\n        现有n个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，\n        使得从左至右，依次是一些红球(类1)、一些白球(类2)、一些蓝球(类3)。\n\n        通过前面的分析得知，这个问题类似快排中partition过程，只是需要用到三个指针：\n        一个前指针begin(指向类1)，一个中指针current(指向类2)，一个后指针end(指向类3)，\n        current指针遍历整个数组序列，当:\n        current指针所指元素为 类1 时，与begin指针所指的元素交换，而后current++，begin++ ；\n        current指针所指元素为 类2 时，不做任何交换（即球不动）， 而后current++ ；\n        current指针所指元素为 类3 时，与end指针所指的元素交换，  而后，current指针不动(end指向的元素可能为类1 )，end-- 。\n        \n> 参考代码如下：\n\n        while( current<=end )        \n        {             \n          if( array[current] ==0 )             \n           {                 \n              swap(array[current],array[begin]);                  \n              current++;                  \n              begin++;            \n           }             \n           else if( array[current] == 1 )            \n           {                 \n              current++;            \n           }   \n\n           else //When array[current] =2   \n           {               \n              swap(array[current],array[end]);                \n              end--;            \n           }      \n        }\n\n\n\n\n\n"
        },
        {
          "name": "递归.md",
          "type": "blob",
          "size": 0.6357421875,
          "content": "# 函数递归\n      递归只是被调用的函数的 名称 正好和 调用者相同，\n      因此，递归调用不是表面上的函数调用自身，\n      而是一个函数的实例调用同一个函数函数的另一个实例\n## 实例 \n### 求 x^n次方\n      double power(double x, unsigned int n){\n            if(n == 0) \n                  return 1;\n            else \n                  return x * power(x, n-1);\n       }\n      // 非递归版本\n      double power_(double x, unsigned int n){\n            double result  = 1;\n            for(result  = x; n>1; --n)\n                  result *= x;\n            return result;\n       }\n"
        },
        {
          "name": "链表.md",
          "type": "blob",
          "size": 10.1162109375,
          "content": "# 单向链表  link list\n     t数组的局限：编译期就需要知道大小； 内存连续，插入困难\n     \n        // 链表节点类 包含一个信息 和指向下一个 节点的指针\n        clas IntLLNode{\n        public:\n            IntLLNode(){// 默认构造函数   没有info信息\n                nextPtr_ = 0;// 空指针\n            }\n            IntLLNode(int data, IntLLNode* in = 0){// 第二个构造函数\n                info_    = data;\n                nextPtr_ = in;\n            }\n        public:\n            int info_;          // 包含一个信息          对用户很重要\n            IntLLNode* nextPtr_;// 指向下一个 节点的指针  用于将节点连接起来组成链表\n        }\n\n        // 定义一个 节点指针\n        IntLLNode* pt = new IntLLNode(10);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt\n        //\n        //   [pt]  ----> |  10 | 也就是 pt->info_   也就是 (*pt).info_\n        //               |  \\  | 也就是 pt->nextPtr_ 也就是 (*pt).nextPtr_ \n\n        // 再定义一个节点\n        pt->nextPtr  = new IntLLNode(30);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt->nextPtr_\n        //\n        //   [pt]  ----> |  10 |  \n        //               |     |  -----> | 30 | 也就是 pt->nextPtr_->info_\n        //                               | \\  | 也就是 pt->nextPtr_->nextPtr_\n\n        // 再定义一个节点\n        pt->nextPtr_->nextPtr_  = new IntLLNode(50);\n        //新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt->nextPtr_->nextPtr_\n        //\n        //   [pt]  ----> |  10 |  \n        //               |     |  -----> | 30 |  \n        //                               |    | ------> | 50 | 也就是  pt->nextPtr_->nextPtr_->info_\n        //                                              |  \\ | 也就是  pt->nextPtr_->nextPtr_->nextPtr_\n\n\n## 使用 头结点和尾节点来存储链表结构\n     //************************  intSLList.h  **************************\n     // 单链表 实现类 \n\n     #ifndef INT_LINKED_LIST\n     #define INT_LINKED_LIST\n\n     // 单个节点\n     // 定义一个 节点指针\n     // IntLLNode* pt = new IntLLNode(10);//新建一个节点 其地址 赋给一个指向 IntLLNode 的指针 pt\n     //\n     //   [pt]  ----> |  10 | 也就是 pt->info_   也就是 (*pt).info_\n     //               |  \\  | 也就是 pt->nextPtr_ 也就是 (*pt).nextPtr_  \n     class IntSLLNode {\n     public:\n         IntSLLNode() {// 默认构造函数   没有info信息\n             next = 0;// 空指针\n         }\n         IntSLLNode(int data, IntSLLNode *ptr = 0) {// 第二个构造函数\n             info = data; \n       next = ptr;\n         }\n     public:    \n         int info;         // 包含一个信息          对用户很重要\n         IntSLLNode *next; // 指向下一个 节点的指针  用于将节点连接起来组成链表\n     };\n\n     // 链表 类  保存了一个 头节点 和 一个尾节点 \n     class IntSLList {\n     public:\n         IntSLList() {// 默认构造函数  这里定义和实现 \n             head = tail = 0;// 节点 和 一个尾节点 指针赋值为 空 \n         }\n         ~IntSLList();// 默认析构函数  只有定义 实现在 cpp文件中 \n         int isEmpty() {//为空链表是否 \n             return head == 0;\n         }\n         void addToHead(int);   // 从头部添加 节点 \n         void addToTail(int);   // 从尾部添加 节点 \n         int  deleteFromHead(); // 从头部删除 节点 并返回该节点的信息 \n         int  deleteFromTail(); // 从尾部删除 节点 并返回该节点的信息 \n         void deleteNode(int);//删除 \n         bool isInList(int) const;\n         void printAll() const;//打印所有的节点的信息   \n     private:\n         IntSLLNode *head, *tail;// 保存了一个 头节点 和 一个尾节点\n     };\n     #endif\n     \n[实现类cpp intSLList.cpp](datastructure_code/cpp_version/intSLList.cpp)\n\n### 头部插入节点   head 和 tail  仅仅是保存了 一个(节点)存储的地址\n       head ---> | 5 |  \n                 |   | ---> | 7 |\n                            |   | --->  |  4 | <-------- tail\n                                        |    |\n       新建一个节点                                 \n       | 9 |  head ---> | 5 |  \n       |   |            |   | ---> | 7 |\n                                   |   | --->  |  4 | <-------- tail\n                                               |    |   \n       新节点指向 head 指向的地址   new IntSLLNode9, head);\n       | 9 |  head ---> | 5 |  \n       |   | ------->   |   | ---> | 7 |\n                                   |   | --->  |  4 | <-------- tail\n\n        原头结点指向新节点  head = new IntSLLNode(9,head);\n        head --->  |   | \n                   | 9 |  \n                   |   | -------> | 5 |  \n                                  |   | ---> | 7 |\n                                             |   | --->  |  4 | <-------- tail\n                                                         |    |       \n                                                         \n### 尾部插入一个节点\n     head ---> | 5 |  \n               |   | ---> | 7 |\n                          |   | --->  |  4 | <-------- tail\n                                      |    |\n     尾部新建一个节点     new IntSLLNode(9);                             \n      head ---> | 5 |  \n                |   | ---> | 7 |\n                                 |   | --->  |  4 | <-------- tail\n                                             |    |                 | 9 |   \n                                                                    | \\ |                                 tail指向的节点 指向这个新节点   tail->next = new IntSLLNode(9)\n      head ---> | 5 |  \n                |   | ---> | 7 |\n                                 |   | --->  |  4 | <-------- tail\n                                             |    | -------->   | 9 |   \n                                                                | \\ | \n\n     尾节点tail 指向新的 尾节点   tail = tail->next;\n      head ---> | 5 |  \n                |   | ---> | 7 |\n                                 |   | --->  |  4 | \n                                             |    | -------->  | 9 |   <-------- tail\n                                                               | \\ |                                 \n# 双向向链表  link list  节点同时包含 指向前驱节点的指针 也包含 指向后继节点的指针\n[双向向链表](datastructure_code/cpp_version/genDLList.h)\n\n\n# 跳跃链表\n[ 跳跃链表](datastructure_code/cpp_version/genSkipL.h)\n\n# 标准库中的链表 list #include<list>\n \n     //一些成员函数\n     assign(iterator first, iterator last) 删除所有节点，在first到last插入元素\n     assign(size_type n, el) 删除所有节点，向其中插入n个el\n     back()  尾节点元素\n     front() 第一个节点元素\n     clear() 删除所有节点\n     empty() 判断是否为空\n     erase() 删除一个节点\n     insert() 插入一个元素\n     pop_back() 删除最后一个节点\n     pop_front() 删除第一个节点\n     push_back() 在表尾插入\n     push_front() 在表头插入\n     sort()       排序\n     swap()      与另一个链表互换\n     unique()   从有序链表中删除重复的元素\n \n## 测试代码 \n    #include <iostream>\n    #include <list>//链表 \n    #include <algorithm>// 算法 \n    #include <deque>//队列 \n    #include <functional>\n\n    using namespace std;\n\n    // 打印链表每一个元素 \n    template<class T>\n    void printList(const list<T>& lst, char *s) {\n        cout << s << \":  \";\n        for (typename list<T>::const_iterator i = lst.begin(); i != lst.end(); ++i)\n           cout << *i << ' ';\n        cout << endl;\n    }\n\n    int main() {\n        list<int> lst1;// 创建空链表                     \n        printList(lst1,\"lst1\");     // lst1 is empty\n        list<int> lst2(3,7);            \n        printList(lst2,\"lst2\");     // lst2 = (7 7 7)\n\n        for (int j = 1; j <= 5; j++)// lst1 = (1 2 3 4 5)\n            lst1.push_back(j);//尾后插入元素 \n\n        list<int>::iterator i1 = lst1.begin(), i2 = i1, i3;\n        i2++; i2++; i2++;\n\n        list<int> lst3(++i1,i2);        \n        printList(lst3,\"lst3\");     // lst3 = (2 3)\n\n        list<int> lst4(lst1);\n        printList(lst4,\"lst4\");     // lst4 = (1 2 3 4 5)\n\n        i1 = lst4.begin();\n        lst4.splice(++i1,lst2);         \n        printList(lst2,\"lst2\");     // lst2 is empty\n        printList(lst4,\"lst4\");     // lst4 = (1 7 7 7 2 3 4 5)\n        lst2 = lst1;\n        printList(lst2,\"lst2\");     // lst2 = (1 2 3 4 5)\n        i2 = lst2.begin();\n        lst4.splice(i1,lst2,++i2);      \n        printList(lst2,\"lst2\");     // lst2 = (1 3 4 5)\n        printList(lst4,\"lst4\");     // lst4 = (1 7 7 7 2 2 3 4 5)\n        i2 = lst2.begin();\n        i3 = i2;\n        lst4.splice(i1,lst2,i2,++i3);\n        printList(lst2,\"lst2\");     // lst2 = (3 4 5)\n        printList(lst4,\"lst4\");     // lst4 = (1 7 7 7 2 1 2 3 4 5)\n        lst4.remove(1);         \n        printList(lst4,\"lst4\");     // lst4 = (7 7 7 2 2 3 4 5)\n        lst4.sort();                            \n        printList(lst4,\"lst4\");     // lst4 = (2 2 3 4 5 7 7 7)\n        lst4.unique();                          \n        printList(lst4,\"lst4\");     // lst4 = (2 3 4 5 7)\n        lst1.merge(lst2);                        \n        printList(lst1,\"lst1\");     // lst1 = (1 2 3 3 4 4 5 5),\n        printList(lst2,\"lst2\");     // lst2 is empty\n        lst3.reverse();                         \n        printList(lst3,\"lst3\");     // lst3 = (3 2)     \n        lst4.reverse();\n        printList(lst4,\"lst4\");     // lst4 = (7 5 4 3 2)\n        lst3.merge(lst4,greater<int>());  \n        printList(lst3,\"lst3\");     // lst3 = (7 5 4 3 3 2 2)\n        printList(lst4,\"lst4\");     // lst4 is empty\n        lst3.remove_if(bind2nd(not_equal_to<int>(),3));\n        printList(lst3,\"lst3\");     // lst3 = (3 3)\n        lst3.unique(not_equal_to<int>());\n        printList(lst3,\"lst3\");     // lst3 = (3 3)\n        return 0;\n    }\n\n"
        },
        {
          "name": "面试题.pdf",
          "type": "blob",
          "size": 1024.4296875,
          "content": null
        }
      ]
    }
  ]
}