{
  "metadata": {
    "timestamp": 1736709683024,
    "page": 48,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "session-replay-tools/tcpcopy",
      "stars": 4544,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.029296875,
          "content": "Makefile\ncscope.*\ntags\nobjs/*\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.1962890625,
          "content": "Bin Wang <wangbin579[at]gmail[dot]com>\nBo Wang  <wbo65[at]163[dot]com>\nYingying Jiang <jyy.ios[at]gmail[dot]com>\nXiaowei Wu (yixiao.wxw [at] taobao [dot] com)\nJoshua Zhu (shudu [at] taobao [dot] com)\n\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.388671875,
          "content": "/*\n * Copyright (C) 2011-2014 NetEase, Inc.\n * Copyright (C) 2012-2014 Alibaba Group Holding Limited\n * Copyright (C) 2011-2014 ChangYou.com Limited\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 0.0439453125,
          "content": "2014.09  v1.0   TCPCopy 1.0 series released\r\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.388671875,
          "content": "/*\n * Copyright (C) 2011-2014 NetEase, Inc.\n * Copyright (C) 2012-2014 Alibaba Group Holding Limited\n * Copyright (C) 2011-2014 ChangYou.com Limited\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "README",
          "type": "blob",
          "size": 10.0693359375,
          "content": "#[TCPCopy](https://github.com/session-replay-tools/tcpcopy) - A TCP Stream Replay Tool\r\n\r\nTCPCopy is a TCP stream replay tool to support real testing of Internet server applications. \r\n\r\n\r\n##Description\r\nAlthough the real live flow is important for the test of Internet server applications, it is hard to simulate it as online environments are too complex. To support more realistic testing of Internet server applications, we propose a live flow reproduction tool – TCPCopy, which could generate the test workload that is similar to the production workload. Currently, TCPCopy has been widely used by companies in China.   \r\n\r\nTCPCopy has little influence on the production system except occupying additional CPU, memory and bandwidth. Moreover, the reproduced workload is similar to the production workload in request diversity, network latency and resource occupation.\r\n\r\n\r\n##Scenarios\r\n* Distributed stress testing\r\n  - Use to copy real-world data to stress test your server software. Bugs that only can be produced in high-stress situations can be found\r\n* Live testing\r\n  - Prove the new system is stable and find bugs that only occur in the real world\r\n* Regression testing\r\n* Performance comparison\r\n\r\n\r\n##Architecture \r\n\r\n![tcpcopy](https://raw.github.com/wangbin579/auxiliary/master/images/tcpcopy.GIF)\r\n\r\nAs shown in Figure 1, TCPCopy consists of two parts:  *tcpcopy* and *intercept*. While *tcpcopy* runs on the online server and captures the online requests, *intercept* runs on the assistant server and does some assistant work, such as passing response info to *tcpcopy*.\r\n\r\n*tcpcopy* utilizes raw socket input technique by default to capture the online packets at the network layer and does the necessary processing (including TCP interaction simulation, network latency control, and common upper-layer interaction simulation), and uses raw socket output technique by default to send packets to the target server(pink arrows).\r\n\r\nThe only operation needed on the target server for TCPCopy is setting appropriate route commands to route response packets(green arrows) to the assistant server. \r\n\r\n*intercept* is responsible for passing the response header(by default) to *tcpcopy*. By capturing the reponse packets, *intercept* will extract response header information and send the response header to *tcpcopy* using a special channel(purple arrows). When *tcpcopy* receives the response header, it utilizes the header information to modify the attributes of online packets and continues to send another packet. It should be noticed that the responses from the target server are routed to the assistant server which should act as a black hole.\r\n\r\n\r\n##Quick start\r\n\r\nTwo quick start options are available for *intercept*:\r\n\r\n* [Download the latest intercept release](https://github.com/session-replay-tools/intercept/releases).\r\n* Clone the repo: `git clone git://github.com/session-replay-tools/intercept.git`.\r\n\r\nTwo quick start options are available for *tcpcopy*:\r\n\r\n* [Download the latest tcpcopy release](https://github.com/session-replay-tools/tcpcopy/releases).\r\n* Clone the repo: `git clone git://github.com/session-replay-tools/tcpcopy.git`.\r\n\r\n\r\n##Getting intercept installed on the assistant server\r\n1. cd intercept\r\n2. ./configure \r\n  - choose appropriate configure options if needed\r\n3. make\r\n4. make install\r\n\r\n\r\n###Configure Options for intercept\r\n    --single            run intercept at non-distributed mode\r\n    --with-debug        compile intercept with debug support (saved in a log file)\r\n\r\n\r\n##Getting tcpcopy installed on the online server\r\n1. cd tcpcopy\r\n2. ./configure \r\n  - choose appropriate configure options if needed\r\n3. make\r\n4. make install\r\n\r\n\r\n###Configure Options for tcpcopy\r\n    --offline                   replay TCP streams from the pcap file\r\n    --pcap-capture              capture packets at the data link\r\n    --pcap-send                 send packets at the data link layer instead of the IP layer\r\n    --set-protocol-module=PATH  set tcpcopy to work for an external protocol module\r\n    --single                    if intercept is configured with \"--single\" option, \r\n                                so does tcpcopy\r\n    --with-debug                compile tcpcopy with debug support (saved in a log file)\r\n\r\n\r\n   \r\n##Running TCPCopy\r\nAssume *tcpcopy* with \"./configure\" is configured and *intercept* with \"configure\" is configured.\r\n \r\n###1) On the target server which runs server applications:\r\n      Set route commands appropriately to route response packets to the assistant server\r\n\r\n      For example:\r\n\r\n         Assume 61.135.233.161 is the IP address of the assistant server. We set the \r\n         following route command to route all responses to the 62.135.200.x's clients \r\n         to the assistant server.\r\n\r\n           route add -net 62.135.200.0 netmask 255.255.255.0 gw 65.135.233.161\r\n\r\n###2) On the assistant server which runs intercept(root privilege is required):\r\n\r\n       ./intercept -F <filter> -i <device,>\r\n       \r\n       Note that the filter format is the same as the pcap filter.\r\n       For example:\r\n       \r\n          ./intercept -i eth0 -F 'tcp and src port 8080' -d\r\n          \r\n          intercept will capture response packets of the TCP based application which listens\r\n          on port 8080 from device eth0 \r\n    \r\n\t\r\n###3) On the online source server (root privilege is required):\r\n      \r\n      ./tcpcopy -x localServerPort-targetServerIP:targetServerPort -s <intercept server,> \r\n      [-c <ip range,>]\r\n      \r\n      For example(assume 61.135.233.160 is the IP address of the target server):\r\n\r\n        ./tcpcopy -x 80-61.135.233.160:8080 -s 61.135.233.161 -c 62.135.200.x\r\n        \r\n        tcpcopy would capture port '80' packets on current server, change client IP address \r\n        to one of 62.135.200.x series, send these packets to the target port '8080' of the \r\n        target server '61.135.233.160', and connect 61.135.233.161 for asking intercept to \r\n        pass response packets to it.\r\n        \r\n        Although \"-c\" parameter is optional, it is set here in order to simplifying route \r\n        commands.\r\n\r\n##Note\r\n1. It is tested on Linux only (kernal 2.6 or above)\r\n2. TCPCopy may lose packets hence lose requests\r\n3. Root privilege is required\r\n4. TCPCopy does only support client-initiated connections now\r\n5. TCPCopy does not support replay for server applications which use SSL/TLS\r\n6. Please execute \"./tcpcopy -h\" or \"./intercept -h\" for more details.\r\n\r\n##Influential Factors\r\nThere are several factors that could influence TCPCopy, which will be introduced in detail in the following sections.\r\n\r\n###1. Capture Interface\r\n*tcpcopy* utilizes raw socket input interface by default to capture packets at the network layer on the online server. The system kernel may lose some packets when the system is busy. \r\n\r\nIf you configure *tcpcopy* with \"--pcap-capture\", then *tcpcopy* could capture packets at the data link layer and could also filter packets in the kernel. With PF_RING, *tcpcopy* would lose less packets when pcap capturing.\r\n\r\nMaybe the best way to capturing requests is using switch to mirror ingress packets to divide the huge traffic to several machines.\r\n\r\n###2. Sending Interface\r\n*tcpcopy* utilizes raw socket output interface by default to send packets at the network layer to a target server. \r\nIf you want to avoid ip_conntrack problems or get better performance, configure *tcpcopy* with \"--pcap-send\", then with appropriate parameters *tcpcopy* could send packets at the data link layer to a target server.\r\n\r\n###3.On the Way to the Target Server \r\nWhen a packet is sent by *tcpcopy*, it may encounter many challenges before reaching the target server. As the source IP address in the packet is still the end-user’s IP address(by default) other than the online server’s, some security devices may take it for an invalid or forged packet and drop it. In this case, when you use tcpdump to capture packets on the target server, no packets from the expected end-users will be captured. To know whether you are under such circumstances, you can choose a target server in the same network segment to do a test. If packets could be sent to the target server successfully in the same network segment but unsuccessfully across network segments, your packets may be dropped halfway. \r\n\r\nTo solve this problem, we suggest deploying *tcpcopy*, *target applications* and *intercept* on servers in the same network segment. There’s also another solution with the help of a proxy in the same network segment. *tcpcopy* could send packets to the proxy and then the proxy would send the corresponding requests to the target server in another network segment.\r\n\r\nNote that deploying the target server's application on one virtual machine in the same segment may face the above problems.\r\n\r\n####4. OS of the Target Server\r\nThe target server may set rpfilter, which would check whether the source IP address in the packet is forged. If yes, the packet will be dropped at the network layer.\r\n\r\nIf the target server could not receive any requests although packets can be captured by tcpdump on the target server, you should check if you have any corresponding rpfilter settings. If set, you have to remove the related settings to let the packets pass through the network layer.\r\n\r\nThere are also other reasons that cause *tcpcopy* not working, such as iptables setting problems.\r\n\r\n###5. Applications on the Target Server\r\nIt is likely that the application on the target server could not process all the requests in time. On the one hand, bugs in the application may make the request not be responded for a long time. On the other hand, some protocols above TCP layer may only process the first request in the socket buffer and leave the remaining requests in the socket buffer unprocessed. \r\n\r\n###6. OS of the assistant Server\r\nYou should not set ip_forward true or the assistant server can't act as a black hole.\r\n\r\n##Release History\r\n+ 2014.09  v1.0    TCPCopy released\r\n\r\n\r\n##Bugs and feature requests\r\nHave a bug or a feature request? [Please open a new issue](https://github.com/session-replay-tools/tcpcopy/issues). Before opening any issue, please search for existing issues.\r\n\r\n\r\n## Copyright and license\r\n\r\nCopyright 2014 under [the BSD license](LICENSE).\r\n\r\n\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.3037109375,
          "content": "# [TCPCopy](https://github.com/session-replay-tools/tcpcopy) - A TCP Stream Replay Tool\r\n\r\nTCPCopy is a TCP stream replay tool for realistic testing of Internet server applications. \r\n\r\n## Getting to Know TCPCopy\r\n\r\n[An Overview of TCPCopy for Beginners](doc/Beginners.md)\r\n\r\n[A General Overview of TCPCopy Architecture](doc/Architecture.md)\r\n\r\n[TCPCopy Testing Use Cases](doc/Usage.md)\r\n\r\n[TCPCopy Pre-Warming Examples](doc/Pre-Warming.md)\r\n\r\n## Description\r\n\r\nAlthough real live traffic is crucial for testing Internet server applications, accurately simulating it is challenging due to the complexity of online environments. To enable more realistic testing, TCPCopy was developed as a live flow reproduction tool that generates test workloads closely resembling production workloads. TCPCopy is widely used by companies in China.\r\n\r\nTCPCopy minimally impacts the production system, consuming only additional CPU, memory, and bandwidth. The reproduced workload mirrors the production environment in terms of request diversity, network latency, and resource usage.\r\n\r\n## Use Cases\r\n\r\n* Distributed Stress Testing\r\n  - Use TCPCopy to replicate real-world traffic for stress testing your server software, uncovering bugs that only appear under high-stress conditions.\r\n* Live Testing\r\n  - Validate the stability of new systems and identify bugs that only manifest in real-world scenarios\r\n* Regression testing\r\n  - Ensure that recent changes have not introduced new issues.\r\n* Performance comparison\r\n  - Compare system performance across different versions or configurations.\r\n\r\n## Architecture\r\n\r\n![tcpcopy](images/tcpcopy.png)\r\n\r\nFigure 1. Overview of the TCPCopy Architecture.\r\n\r\nAs shown in Figure 1, TCPCopy is composed of two components: `tcpcopy` and `intercept`. The `tcpcopy` component runs on the online server, capturing live requests, while `intercept` operates on the assistant server, performing tasks such as passing response information to `tcpcopy`. The test application itself runs on the target server.\r\n\r\nBy default, `tcpcopy` uses raw sockets to capture packets at the network layer (depicted by the orange arrows in the figure). It handles processes such as TCP interaction simulation, network latency control, and upper-layer interaction simulation. It then sends packets to the target server using raw sockets for output (shown by the light red arrows in the figure).\r\n\r\nThe only required task on the target server is configuring route rules to direct response packets (shown by light green arrows in the figure) to the assistant server.\r\n\r\nThe `intercept` component's role is to forward the response header (by default) to `tcpcopy`. It captures the response packets, extracts the response header information, and sends this information to `tcpcopy` via a dedicated channel (represented by light blue arrows in the figure). Upon receiving the response header, `tcpcopy` uses the information to modify the attributes of online packets and proceeds to send subsequent packets.\r\n\r\nIt is important to note that responses from the target server are routed to the assistant server, which functions as a black hole.\r\n\r\n## Quick Start\r\n\r\nFor `intercept`, you have two options:\r\n\r\n* [Download the latest intercept release](https://github.com/session-replay-tools/intercept/releases).\r\n* Clone the repository:\r\n  `git clone git://github.com/session-replay-tools/intercept.git`.\r\n\r\nFor `tcpcopy`, you also have two options\r\n\r\n* [Download the latest tcpcopy release](https://github.com/session-replay-tools/tcpcopy/releases).\r\n* Clone the repository:\r\n  `git clone git://github.com/session-replay-tools/tcpcopy.git`.\r\n\r\n## Installing intercept on the Assistant Server\r\n\r\n1. Navigate to the `intercept` directory:<br>\r\n   `cd intercept`\r\n2. Run the configuration script:<br>\r\n   `./configure` <br>\r\n   Optionally, specify any necessary configuration options.\r\n3. Compile the source code:<br>\r\n   `make`\r\n4. Install the `intercept` tool:<br>\r\n   `make install`\r\n\r\n### Configure Options for `intercept`\r\n\r\n- `--single`  \r\n  Run `intercept` in non-distributed mode.\r\n\r\n- `--with-pfring=PATH`  \r\n  Specify the path to the PF_RING library sources.\r\n\r\n- `--with-debug`  \r\n  Compile `intercept` with debug support, with logs saved to a file.\r\n\r\n## Installing `tcpcopy` on the Online Server\r\n\r\n1. Navigate to the `tcpcopy` directory: <br>\r\n   `cd tcpcopy`\r\n2. Run the configuration script: <br>\r\n   `./configure` <br>\r\n    Include any necessary configuration options as needed.\r\n3. Compile the source code: <br>\r\n   `make`\r\n4. Install the `tcpcopy` tool: <br>\r\n   `make install`\r\n\r\n### Configure Options for `tcpcopy`\r\n\r\n- `--offline`  \r\n  Replay TCP streams from a pcap file.\r\n\r\n- `--pcap-capture`  \r\n  Capture packets at the data link layer.\r\n\r\n- `--pcap-send`  \r\n  Send packets at the data link layer instead of the IP layer.\r\n\r\n- `--with-pfring=PATH`  \r\n  Specify the path to the PF_RING library sources.\r\n\r\n- `--set-protocol-module=PATH`  \r\n  Set `tcpcopy` to work with an external protocol module.\r\n\r\n- `--single`  \r\n  If both `intercept` and `tcpcopy` are configured with the `--single` option, only one `tcpcopy` instance will work with `intercept`, leading to better performance.\r\n\r\n- `--with-tcmalloc`  \r\n  Use tcmalloc instead of malloc.\r\n\r\n- `--with-debug`  \r\n  Compile `tcpcopy` with debug support, with logs saved to a file.\r\n\r\n## Running TCPCopy\r\n\r\nAssume that both `tcpcopy` and `intercept` are configured using `./configure`.\r\n\r\n1. **On the Target Server Running Server Applications:**\r\n   \r\n   Configure the route rules to direct response packets to the assistant server. For example, if `61.135.233.161` is the IP address of the assistant server, use the following route command to direct all responses from clients in the `62.135.200.x` range to the assistant server:\r\n   \r\n   `route add -net 62.135.200.0 netmask 255.255.255.0 gw 61.135.233.161`\r\n\r\n2. **On the Assistant Server Running `intercept` (Root Privilege or CAP_NET_RAW Capability Required):**\r\n   \r\n    `./intercept -F <filter> -i <device>`\r\n   \r\n   Note that the filter format is the same as the pcap filter. For example:\r\n   \r\n   `./intercept -i eth0 -F 'tcp and src port 8080' -d`\r\n   \r\n   In this example, `intercept` will capture response packets from a TCP-based application listening on port 8080, using the eth0 network device.\r\n   \r\n   Please note that `ip_forward` is not enabled on the assistant server.\r\n\r\n3. **On the Online Source Server (Root Privilege or CAP_NET_RAW Capability Required):**\r\n   \r\n   `./tcpcopy -x localServerPort-targetServerIP:targetServerPort -s <intercept server> [-c <ip range>]`\r\n   \r\n   For example (assuming 61.135.233.160 is the IP address of the target server):\r\n   \r\n   `./tcpcopy -x 80-61.135.233.160:8080 -s 61.135.233.161 -c 62.135.200.x`\r\n   \r\n   In this example, `tcpcopy` captures packets on port 80 from the current server, changes the client IP address to one from the 62.135.200.x range, and sends these packets to port 8080 on the target server (61.135.233.160). It also connects to 61.135.233.161 to request `intercept` to forward response packets. While the `-c parameter` is optional, it is used here to simplify route rules.\r\n\r\n## Note\r\n\r\n1. Platform: Tested only on Linux (kernel 2.6 or above).\r\n2. Packet Loss: TCPCopy may lose packets, which could result in lost requests.\r\n3. Permissions: Requires root privilege or the `CAP_NET_RAW` capability (e.g., setcap CAP_NET_RAW=ep tcpcopy).\r\n4. Connection Type: Currently supports only client-initiated connections.\r\n5. SSL/TLS: Does not support replay for applications using SSL/TLS.\r\n6. Due to the additional layer of forwarding in tcpcopy, the throughput of a single application connection cannot be too high; otherwise, it won't match the native connection throughput, especially in performance tests like sysbench or ab.\r\n7. If the volume of replicated requests is too large, tcpcopy may become unstable, with the single thread overwhelmed by packet capture, significantly reducing replication effectiveness. In such cases, other auxiliary methods can be used, such as leveraging switch mirroring with a divide-and-conquer packet capture strategy or using offline replay.\r\n8. MySQL Session Replay: For details, visit [mysql-replay-module](https://github.com/session-replay-tools/mysql-replay-module) or [mysql-sgt-replay-module](https://github.com/session-replay-tools/mysql-sgt-replay-module).\r\n9. The `./configure --with-resp-payload` option for `intercept` cannot be used together with the `./configure` option for `tcpcopy`.\r\n10. IP Forwarding: Ensure `ip_forward` is not enabled on the assistant server.\r\n11. Help: For more information, run `./tcpcopy -h` or `./intercept -h`.\r\n\r\n## Influential Factors\r\n\r\nSeveral factors can impact TCPCopy, as detailed in the following sections.\r\n\r\n### 1. Capture Interface\r\n\r\nBy default, `tcpcopy` uses a raw socket input interface to capture packets at the network layer on the online server. Under high load, the system kernel may drop some packets.\r\nIf configured with `--pcap-capture`, `tcpcopy` captures packets at the data link layer and can filter packets in the kernel. Using `PF_RING` with pcap capturing can reduce packet loss.\r\nFor optimal capture, consider mirroring ingress packets via a switch and distributing the traffic across multiple machines with a load balancer.\r\n\r\n### 2. Sending Interface\r\n\r\n`tcpcopy` defaults to using a raw socket output interface to send packets at the network layer to the target server. To avoid `ip_conntrack` issues or improve performance, use `--pcap-send` to send packets at the data link layer instead.\r\n\r\n### 3. On the Way to the Target Server\r\n\r\nPackets sent by `tcpcopy` may face challenges before reaching the target server. If the source IP address is the end-user's IP (by default), security devices may drop the packet as invalid or forged. To test this, use `tcpdump` on the target server. If packets are successfully sent within the same network segment but not across segments, packets may be dropped midway.\r\n\r\nTo address this, deploy `tcpcopy`, target applications, and `intercept` within the same network segment. Alternatively, use a proxy in the same segment to forward packets to the target server in another segment.\r\n\r\nDeploying the target server’s application on a virtual machine within the same segment may still encounter these issues.\r\n\r\n### 4. OS of the Target Server\r\n\r\nThe target server might use `rpfilter` to verify the legitimacy of source IP addresses, dropping packets deemed forged. If packets are captured by `tcpdump` but not processed, check `rpfilter` settings and adjust or remove them as needed. Other issues like `iptables` settings may also affect `tcpcopy`.\r\n\r\n### 5. Applications on the Target Server\r\n\r\nApplications on the target server may not process all requests promptly. Bugs or limitations in the application can lead to delayed responses or unprocessed requests in the socket buffer.\r\n\r\n### 6. OS of the Assistant Server\r\n\r\nEnsure that `ip_forward` is set to false on the assistant server to prevent it from routing packets and ensure it functions as a black hole.\r\n\r\n## Logical Analysis of the Issue Where the Test Server Fails to Receive Data\r\n\r\nFirst, use `telnet` on the online server to connect to the test server's port. This will check if the network path is accessible. If the connection fails, resolve this issue before proceeding with the following diagnostics.\r\n\r\nAssume that during the `tcpcopy` test, the application on the test server does not receive any requests. Determine if the initial handshake packet (i.e., the SYN packet) reaches the test server.\r\n\r\n### 1. **If the SYN packet reaches the test server, the following scenarios are possible:**\r\n\r\n   **1.1 Only SYN Packets Captured:**\r\n   If you use `tcpdump` on the test server and see that the replicated SYN packets are arriving, it indicates that they have reached the data link layer of the test server. If `netstat` shows no connections for the application, it means the packets were dropped at the IP layer. Check if `rpfilter` is configured—if so, remove this setting, and the issue should generally be resolved. If `rpfilter` is not set, confirm that there are no conflicts in the `iptables` settings and adjust the relevant rules if necessary.\r\n\r\n   **1.2 SYN Followed by RST Packet:**\r\n   If the SYN packet is immediately followed by a reset (RST) packet (with less than 1 second between them in the same session), it indicates a routing issue or conflict, causing the response packet to be sent directly back to the real client.\r\n\r\n  **1.3 Test Server Responds with the Second Handshake Packet:**\r\n   Capture packets on the assistant server to check if the second handshake packet has reached it.\r\n\r\n- **If the packet hasn't reached the assistant server,** it suggests that the routing setup is not effective, and therefore `intercept` cannot capture the second handshake packet, preventing further replay. A potential solution is to run `intercept` directly on the test server (note: keep the routing setup unchanged, and ensure that the `-c` parameter in `tcpcopy` is not set to the IP address used by `tcpcopy` to connect to `intercept`, or else `tcpcopy` won’t connect to `intercept`).\r\n\r\n- **If the second handshake packet is captured,** check if `ip_forward` is enabled. If it is, disable this setting, as it may cause the response packets to be sent directly back to the client, interfering with the test.\r\n\r\n### 2. **If the SYN packet does not reach the test server, there are two possible scenarios:**\r\n\r\n   **2.1 `tcpcopy` Packets Captured on the Online Server:**\r\n   If you capture `tcpcopy`'s forwarded packets using `tcpdump` on the online server, but the packets do not reach the test server, it indicates that they were dropped along the way. You can try using the `-c` parameter in `tcpcopy` to modify the client IP address to a valid one. In extreme cases, set the client IP to the IP address of the machine running `tcpcopy` (note: NAT issues may arise, and if `intercept` is running on the test server, ensure the `-c` parameter in `tcpcopy` is not set to the IP address used by `tcpcopy` to connect to `intercept`, or else `tcpcopy` won’t connect to `intercept`).\r\n\r\n   **2.2 `tcpcopy` Packets Not Captured on the Online Server:**\r\n\r\n- **If no `all clt:xx` information is found in `tcpcopy`'s log,** it indicates that `tcpcopy` is unable to capture packets at the IP layer. In this case, use the `--pcap-capture` option to capture packets at the data link layer. Set the `-F` parameter (e.g., 'tcp and dst port 80 and dst host 10.100.1.2') and the `-i` parameter (network interface) to bypass IP layer capturing.\r\n\r\n- **If `all clt:xx`, where `xx > 0`, is seen in `tcpcopy`'s log,** it means `tcpcopy` successfully captured the packet, but it was filtered out by the IP layer on the online server. Check `iptables` restrictions on the output chain, among other settings. If `iptables` is the problem and cannot be modified on the online server, use the `--pcap-send` option to send packets from the data link layer.\r\n\r\n## Release History\r\n\r\n+ 2014.09  v1.0    TCPCopy released\r\n+ 2024.09  v1.0    Open source fully uses English\r\n\r\n## Bugs and Feature Requests\r\n\r\nHave a bug or a feature request? [Please open a new issue](https://github.com/session-replay-tools/tcpcopy/issues). Before opening any issue, please search for existing issues.\r\n\r\n## Copyright and License\r\n\r\nCopyright 2024 under [the BSD license](LICENSE).\r\n\r\n## Acknowledgments\r\n\r\nSeveral individuals have been crucial in the writing of this document by reviewing drafts and offering feedback. I am especially grateful for the contributions of Hongshen Wang. \r\n"
        },
        {
          "name": "auto",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 2.9169921875,
          "content": "#!/bin/sh\n\nLC_ALL=C\nexport LC_ALL\n\n. auto/options\n. auto/init\n. auto/sources\n\ntest -d $TC_OBJS || mkdir $TC_OBJS\n\necho > $TC_AUTO_HEADERS_H\necho > $TC_AUTOCONF_ERR\n\necho \"#define TC_CONFIGURE \\\"$TC_CONFIGURE\\\"\" > $TC_AUTO_CONFIG_H\n\nif test -z \"$TC_PLATFORM\"; then\n    echo \"checking for OS\"\n\n    TC_SYSTEM=`uname -s 2>/dev/null`\n    TC_RELEASE=`uname -r 2>/dev/null`\n    TC_MACHINE=`uname -m 2>/dev/null`\n\n    echo \" + $TC_SYSTEM $TC_RELEASE $TC_MACHINE\"\n\n    TC_PLATFORM=\"$TC_SYSTEM:$TC_RELEASE:$TC_MACHINE\";\n\nelse\n    echo \"building for $TC_PLATFORM\"\n    TC_SYSTEM=$TC_PLATFORM\nfi\n\n\ncase \"$TC_PLATFORM\" in\n\n    Linux:*)\n    . auto/os/linux\n    ;;  \n\n    *) \n    echo \"error: Linux only!\"\n    exit 1\nesac\n\n\nif [ $TC_DEBUG = YES ]; then\n    have=TC_DEBUG . auto/have\n    have=TC_DETECT_MEMORY . auto/have\nelse \n    if [ $TC_DETECT_MEMORY = YES ]; then\n        have=TC_DETECT_MEMORY . auto/have\n    fi\nfi\n\nif [ $TC_SINGLE = YES ]; then\n    have=TC_SINGLE . auto/have\nfi\n\nif [ $TC_OFFLINE = YES ]; then\n    TC_PCAP_NEEDED=YES\n    have=TC_OFFLINE . auto/have\nfi\n\nif [ $TC_PCAP_CAPTURE = YES ]; then\n    TC_PCAP_NEEDED=YES\n    have=TC_PCAP . auto/have\nfi\n\nif [ $TC_PCAP_SEND = YES ]; then\n    TC_PCAP_NEEDED=YES\n    have=TC_PCAP_SND . auto/have\nfi\n\nif [ $TC_PCAP_NEEDED = YES ]; then\n    if [ $TC_PF_RING_DIR != NONE ]; then\n        have=TC_HAVE_PF_RING . auto/have\n        CORE_LIBS=\"$CORE_LIBS $TC_PF_RING_DIR/userland/libpcap/libpcap.a\"\n        CORE_LIBS=\"$CORE_LIBS $TC_PF_RING_DIR/userland/lib/libpfring.a\"\n        CORE_LIBS=\"$CORE_LIBS -lrt -lpthread -lnuma\"\n    else\n        CORE_LIBS=\"$CORE_LIBS -lpcap\" \n    fi\nfi\n\nif [ $TC_TCMALLOC = YES ]; then\n    CORE_LIBS=\"$CORE_LIBS -ltcmalloc\"\nfi\n\nif [ $TC_MILLION_SUPPORT = YES ]; then\n    have=TC_MILLION_SUPPORT . auto/have\nfi\n\nif test -n \"$TC_ADDONS\"; then\n    have=TC_PLUGIN . auto/have\nfi\n\nif [ $TC_COMBINED = YES ]; then\n    have=TC_COMBINED . auto/have\nfi\n\nif [ $TC_UDP = YES ]; then\n    have=TC_UDP . auto/have\nfi\n\nif [ $TC_DNAT = YES ]; then\n    have=TC_DNAT . auto/have\nfi\n\n. auto/cc/conf\n. auto/headers\n. auto/os/conf\n. auto/linux\n. auto/modules\n\n\nif [ $TC_PAYLOAD = YES ]; then\n    have=TC_PAYLOAD . auto/have\nfi\n\nif [ $TC_DIGEST = YES ]; then\n    tc_include=\"openssl/evp.h\";    . auto/include\n    have=TC_DIGEST . auto/have\n    CORE_LIBS=\"$CORE_LIBS -lcrypto -lm\" \nfi\n\ncase \".$TC_PREFIX\" in\n    .)\n        TC_PREFIX=${TC_PREFIX:-/usr/local/tcpcopy}\n        have=TC_PREFIX value=\"\\\"$TC_PREFIX/\\\"\" . auto/define\n    ;;\n\n    .!)\n        TC_PREFIX=\n    ;;\n\n    *)\n        have=TC_PREFIX value=\"\\\"$TC_PREFIX/\\\"\" . auto/define\n    ;;\nesac\n\nif [ \".$TC_CONF_PREFIX\" != \".\" ]; then\n    have=TC_CONF_PREFIX value=\"\\\"$TC_CONF_PREFIX/\\\"\" . auto/define\nfi\n\nhave=TC_SBIN_PATH value=\"\\\"$TC_SBIN_PATH\\\"\" . auto/define\nhave=TC_CONF_PATH value=\"\\\"$TC_CONF_PATH\\\"\" . auto/define\nhave=TC_PID_PATH value=\"\\\"$TC_PID_PATH\\\"\" . auto/define\nhave=TC_ERROR_LOG_PATH value=\"\\\"$TC_ERROR_LOG_PATH\\\"\" . auto/define\n\n. auto/make\n. auto/install\n. auto/summary\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}