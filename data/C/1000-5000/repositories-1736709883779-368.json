{
  "metadata": {
    "timestamp": 1736709883779,
    "page": 368,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gdbinit/MachOView",
      "stars": 2749,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.5537109375,
          "content": ".svn/*\nbuild/*\nEnglish.lproj/.svn/all-wcprops\nEnglish.lproj/.svn/entries\nEnglish.lproj/.svn/text-base/InfoPlist.strings.svn-base\nEnglish.lproj/.svn/text-base/Layout.xib.svn-base\nEnglish.lproj/.svn/text-base/MainMenu.xib.svn-base\nEnglish.lproj/.svn/text-base/Preferences.xib.svn-base\nmach-o/.svn/all-wcprops\nmach-o/.svn/entries\nmach-o/.svn/text-base/arch.h.svn-base\nmach-o/.svn/text-base/compact_unwind_encoding.h.svn-base\nmach-o/.svn/text-base/fat.h.svn-base\nmach-o/.svn/text-base/loader.h.svn-base\nmach-o/.svn/text-base/nlist.h.svn-base\nmach-o/.svn/text-base/ranlib.h.svn-base\nmach-o/.svn/text-base/reloc.h.svn-base\nmach-o/.svn/text-base/swap.h.svn-base\nmach-o/arm/.svn/all-wcprops\nmach-o/arm/.svn/entries\nmach-o/arm/.svn/text-base/reloc.h.svn-base\nmach-o/x86_64/.svn/all-wcprops\nmach-o/x86_64/.svn/entries\nmach-o/x86_64/.svn/text-base/reloc.h.svn-base\nmachoview.xcodeproj/.svn/all-wcprops\nmachoview.xcodeproj/.svn/entries\nmachoview.xcodeproj/.svn/text-base/project.pbxproj.svn-base\notool_disasm/.svn/all-wcprops\notool_disasm/.svn/entries\notool_disasm/.svn/text-base/arm_disasm.c.svn-base\notool_disasm/.svn/text-base/arm_disasm.h.svn-base\notool_disasm/.svn/text-base/bytesex.c.svn-base\notool_disasm/.svn/text-base/i386_disasm.c.svn-base\notool_disasm/.svn/text-base/i386_disasm.h.svn-base\notool_disasm/.svn/text-base/ofile_print.h.svn-base\notool_disasm/.svn/text-base/otool.h.svn-base\notool_disasm/.svn/text-base/symbol.c.svn-base\notool_disasm/disasm.xcodeproj/.svn/all-wcprops\notool_disasm/disasm.xcodeproj/.svn/entries\notool_disasm/disasm.xcodeproj/.svn/text-base/project.pbxproj.svn-base\n"
        },
        {
          "name": "AppController.h",
          "type": "blob",
          "size": 0.361328125,
          "content": "/*\n *  AppController.h\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#import <Cocoa/Cocoa.h>\n\n@class MVPreferenceController;\n\n@interface MVAppController : NSObject <NSApplicationDelegate,NSOpenSavePanelDelegate>\n{\n  MVPreferenceController * preferenceController;\n}\n\n- (IBAction)showPreferencePanel:(id)sender;\n- (IBAction)attach:(id)sender;\n\n@end\n\n\n\n\n"
        },
        {
          "name": "AppController.mm",
          "type": "blob",
          "size": 11.056640625,
          "content": " /*\n *  AppController.mm\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#import \"Common.h\"\n#import \"AppController.h\"\n#import \"DataController.h\"\n#import \"Document.h\"\n#import \"PreferenceController.h\"\n#import \"Attach.h\"\n#import <mach-o/fat.h>\n#import <mach-o/loader.h>\n\n// counters for statistics\nint64_t nrow_total;  // number of rows (loaded and empty)\nint64_t nrow_loaded; // number of loaded rows\n\n//============================================================================\n@implementation MVAppController\n\n//----------------------------------------------------------------------------\n- (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender\n{\n  return NO;\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender\n{\n  return NO;\n}\n\n//----------------------------------------------------------------------------\n- (IBAction)newDocument:(id)sender\n{\n  NSLog(@\"Not yet possible\");\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)isOnlyRunningMachOView\n{\n  NSProcessInfo * procInfo = [NSProcessInfo processInfo];\n  NSBundle * mainBundle = [NSBundle mainBundle];\n  NSString * versionString = [mainBundle objectForInfoDictionaryKey:@\"CFBundleShortVersionString\"];\n  \n  NSUInteger numberOfInstance = 0;\n  \n  NSWorkspace * workspace = [NSWorkspace sharedWorkspace];\n  for (NSRunningApplication * runningApplication in [workspace runningApplications])\n  {\n    // check if process name matches\n    NSString * fileName = [[runningApplication executableURL] lastPathComponent];\n    if ([fileName isEqualToString: [procInfo processName]] == NO)\n    {\n      continue;\n    }\n\n    // check if version string matches\n    NSBundle * bundle = [NSBundle bundleWithURL:[runningApplication bundleURL]];\n    if ([versionString isEqualToString:[bundle objectForInfoDictionaryKey:@\"CFBundleShortVersionString\"]] == YES && ++numberOfInstance > 1)\n    {\n      return NO;\n    }\n  }\n  \n  return YES;\n}\n\n//----------------------------------------------------------------------------\n/* \n * menu item action to attach to a process and read its mach-o header\n */\n- (IBAction)attach:(id)sender\n{\n  NSAlert *alert = [[NSAlert alloc] init];\n  alert.messageText = @\"Insert PID to attach to:\";\n  [alert addButtonWithTitle:@\"Attach\"];\n  [alert addButtonWithTitle:@\"Cancel\"];\n\n  NSTextField *input = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 200, 24)];\n  [input setStringValue:@\"\"];\n  [alert setAccessoryView:input];\n  NSInteger button = [alert runModal];\n  if (button == NSAlertFirstButtonReturn)\n  {\n    [input validateEditing];\n    pid_t targetPid = [input intValue];\n    NSLog(@\"Trying to attach to process %d\", targetPid);\n    mach_vm_address_t mainAddress = 0;\n    if (find_main_binary(targetPid, &mainAddress))\n    {\n      NSLog(@\"Failed to find main binary address!\");\n      NSAlert *attachfail = [[NSAlert alloc] init];\n      attachfail.messageText = @\"Failed to attach to process\";\n      [attachfail addButtonWithTitle:@\"Ok\"];\n      [attachfail runModal];\n      return;\n    }\n    uint64_t aslr_slide = 0;\n    uint64_t imagesize = 0;\n    if ( (imagesize = get_image_size(mainAddress, targetPid, &aslr_slide)) == 0 )\n    {\n      NSLog(@\"[ERROR] Got image file size equal to 0!\");\n      return;\n    }\n    /* allocate the buffer to contain the memory dump */\n    uint8_t *readbuffer = (uint8_t*)malloc(imagesize);\n    if (readbuffer == NULL)\n    {\n      NSLog(@\"Can't allocate mem for dumping target!\");\n      return;\n    }\n    /* and finally read the sections and dump their contents to the buffer */\n    if (dump_binary(mainAddress, targetPid, readbuffer, aslr_slide))\n    {\n      NSLog(@\"Main binary memory dump failed!\");\n      free(readbuffer);\n      return;\n    }\n    /* dump buffer contents to temporary file to use the NSDocument model */\n    const char *tmp = [[MVDocument temporaryDirectory] UTF8String];\n    char *dumpFilePath = (char*)malloc(strlen(tmp)+1);\n    if (dumpFilePath == NULL)\n    {\n      NSLog(@\"Can't allocate mem for temp filename path!\");\n      free(readbuffer);\n      return;\n    }\n    strcpy(dumpFilePath, tmp);\n    int outputFile = 0;\n    if ( (outputFile = mkstemp(dumpFilePath)) == -1 )\n    {\n      NSLog(@\"mkstemp failed!\");\n      free(dumpFilePath);\n      free(readbuffer);\n      return;\n    }\n    \n    if (write(outputFile, readbuffer, imagesize) == -1)\n    {\n      NSLog(@\"[ERROR] Write error at %s occurred!\\n\", dumpFilePath);\n      free(dumpFilePath);\n      free(readbuffer);\n      return;\n    }\n    NSLog(@\"\\n[OK] Full binary dumped to %s!\\n\\n\", dumpFilePath);\n    close(outputFile);\n    \n    [self application:NSApp openFile:[NSString stringWithCString:dumpFilePath encoding:NSUTF8StringEncoding]];\n    /* remove temporary dump file, not required anymore */\n    NSFileManager * fileManager = [NSFileManager defaultManager];\n    [fileManager removeItemAtPath:[NSString stringWithCString:dumpFilePath encoding:NSUTF8StringEncoding] error:NULL];\n    free(dumpFilePath);\n    free(readbuffer);\n  }\n  else if (button == NSAlertSecondButtonReturn)\n  {\n    /* nothing to do here */\n  }\n  else\n  {\n    NSAssert1(NO, @\"Invalid input dialog button %ld\", button);\n  }\n}\n\n//----------------------------------------------------------------------------\n- (IBAction)openDocument:(id)sender\n{\n  NSOpenPanel *openPanel = [NSOpenPanel openPanel];\n  [openPanel setTreatsFilePackagesAsDirectories:YES];\n  [openPanel setAllowsMultipleSelection:YES];\n  [openPanel setCanChooseDirectories:NO];\n  [openPanel setCanChooseFiles:YES];\n  [openPanel setDelegate:self]; // for filtering files in open panel with shouldShowFilename\n  [openPanel beginSheetModalForWindow:NSApp.modalWindow\n   completionHandler:^(NSInteger result) \n   {\n     if (result != NSModalResponseOK)\n     {\n       return;\n     }\n     [openPanel orderOut:self]; // close panel before we might present an error\n     for (NSURL * url in [openPanel URLs])\n     {\n       [self application:NSApp openFile:[url path]];\n     }\n   }];\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)panel:(id)sender shouldEnableURL:(NSURL *)url\n{\n  // can enter directories\n  NSNumber * isDirectory = nil;\n  [url getResourceValue:&isDirectory forKey:NSURLIsDirectoryKey error:NULL];\n  if ([isDirectory boolValue] == YES) \n  {\n    return YES;\n  }\n\n  // skip symbolic links, etc.\n  NSNumber * isRegularFile = nil;\n  [url getResourceValue:&isRegularFile forKey:NSURLIsRegularFileKey error:NULL];\n  if ([isRegularFile boolValue] == NO) \n  {\n    return NO;\n  }\n  \n  // check for magic values at front\n  NSFileHandle * fileHandle = [NSFileHandle fileHandleForReadingFromURL:url error:NULL];\n  NSData * magicData = [fileHandle readDataOfLength:8];\n  [fileHandle closeFile];\n  \n  if ([magicData length] < sizeof(uint32_t))\n  {\n    return NO;\n  }\n  \n  uint32_t magic = *(uint32_t*)[magicData bytes];\n  if (magic == MH_MAGIC || magic == MH_MAGIC_64 || \n      magic == FAT_CIGAM || magic == FAT_MAGIC)\n  {\n    return YES;\n  }\n  \n  if ([magicData length] < sizeof(uint64_t))\n  {\n    return NO;\n  }\n  \n  if (*(uint64_t*)[magicData bytes] == *(uint64_t*)\"!<arch>\\n\")\n  {\n    return YES;\n  }\n  \n  return NO;\n}\n\n//----------------------------------------------------------------------------\n- (void)applicationWillFinishLaunching:(NSNotification *)aNotification\n{\n  BOOL isFirstMachOView = [self isOnlyRunningMachOView];\n  \n  // disable the state resume feature, it's not very useful with MachOView\n  if([[NSUserDefaults standardUserDefaults] objectForKey: @\"ApplePersistenceIgnoreState\"] == nil)\n      [[NSUserDefaults standardUserDefaults] setBool: YES forKey:@\"ApplePersistenceIgnoreState\"];\n\n  // load user's defaults for preferences\n//  if([[NSUserDefaults standardUserDefaults] objectForKey: @\"UseLLVMDisassembler\"] != nil)\n//    qflag = [[NSUserDefaults standardUserDefaults] boolForKey:@\"UseLLVMDisassembler\"];\n\n  \n  NSFileManager * fileManager = [NSFileManager defaultManager];\n  NSString * tempDir = [MVDocument temporaryDirectory];\n  \n  __autoreleasing NSError * error;\n  \n  // remove previously forgotten temporary files\n  if (isFirstMachOView && [fileManager fileExistsAtPath:tempDir isDirectory:NULL] == YES)\n  {\n    if ([fileManager removeItemAtPath:tempDir error:&error] == NO)\n    {\n      [NSApp presentError:error];\n    }\n  }\n  \n  // create placeholder for temporary files\n  if ([fileManager fileExistsAtPath:tempDir isDirectory:NULL] == NO)\n  {\n    if ([fileManager createDirectoryAtPath:tempDir\n               withIntermediateDirectories:NO\n                                attributes:nil\n                                     error:&error] == NO)\n    {\n      [NSApp presentError:error];\n    }\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)applicationDidFinishLaunching:(NSNotification *)aNotification \n{\n#ifdef MV_STATISTICS\n  nrow_total = nrow_loaded = 0;\n  [NSThread detachNewThreadSelector:@selector(printStat) toTarget:self withObject:nil];\n#endif \n\n  /* default is to not open a file dialogue */\n  if ([[NSUserDefaults standardUserDefaults] objectForKey:@\"OpenAtLaunch\"] != nil)\n  {\n    if ([[NSUserDefaults standardUserDefaults] boolForKey:@\"OpenAtLaunch\"] == YES)\n    {\n      // if there is no document yet, then pop up an open file dialogue\n      if ([[[NSDocumentController sharedDocumentController] documents] count] == 0)\n      {\n        [self openDocument:nil];\n      }\n    }\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)applicationWillTerminate:(NSNotification *)aNotification\n{\n  BOOL isLastMachOView = [self isOnlyRunningMachOView];\n  \n  if (isLastMachOView == YES)\n  {\n    // remove temporary files\n    NSFileManager * fileManager = [NSFileManager defaultManager];\n    NSString * tempDir = [MVDocument temporaryDirectory];\n    [fileManager removeItemAtPath:tempDir error:NULL];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename\n{\n    NSLog (@\"open file: %@\", filename);\n\n    NSDocumentController * documentController = [NSDocumentController sharedDocumentController];\n    [documentController openDocumentWithContentsOfURL:[NSURL fileURLWithPath:filename]\n                                              display:YES\n                                    completionHandler:^(NSDocument * _Nullable document, BOOL alreadyOpen, NSError * _Nullable error) {\n         // If we can't open the document, present error to the user\n         if (!document) {\n            [NSApp presentError:error];\n         }\n         if (alreadyOpen) {\n             NSLog(@\"document was already open!\");\n         }\n    }];\n    return YES;\n}\n\n//----------------------------------------------------------------------------\n-(void) printStat\n{\n  for (;;)\n  {\n    NSLog(@\"stat: %lld/%lld rows in memory\\n\",nrow_loaded,nrow_total);\n    [NSThread sleepForTimeInterval:1];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (IBAction)showPreferencePanel:(id)sender\n{\n    if (!preferenceController)\n    {\n        preferenceController = [[MVPreferenceController alloc] init];\n    }\n    [preferenceController showWindow:self];\n}\n\n@end\n\n\n"
        },
        {
          "name": "ArchiveLayout.h",
          "type": "blob",
          "size": 0.609375,
          "content": "/*\n *  ArchiveLayout.h\n *  MachOView\n *\n *  Created by psaghelyi on 18/03/2011.\n *\n */\n\n#import \"Layout.h\"\n\n@interface MVObjectInfo : NSObject\n{\n  NSString *    name;\n  uint64_t      length;\n  MVLayout *    __weak layout;\n}\n\n@property (nonatomic)                   NSString *  name;\n@property (nonatomic)                   uint64_t    length;\n@property (nonatomic,weak)  MVLayout *  layout;\n\n@end\n\n@interface ArchiveLayout : MVLayout \n{\n  NSMutableDictionary * objectInfoMap; // <(NSNumber)object offset,MVObjectInfo>\n}\n\n+ (ArchiveLayout *)     layoutWithDataController:(MVDataController *)dc rootNode:(MVNode *)node;\n\n@end\n"
        },
        {
          "name": "ArchiveLayout.mm",
          "type": "blob",
          "size": 12.046875,
          "content": "/*\n *  ArchiveLayout.mm\n *  MachOView\n *\n *  Created by psaghelyi on 18/03/2011.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cxxabi.h>\n\n#import \"Common.h\"\n#import \"ArchiveLayout.h\"\n#import \"DataController.h\"\n#import \"MachOLayout.h\"\n#import \"ReadWrite.h\"\n#import <mach-o/ranlib.h>\n\n//============================================================================\n@implementation MVObjectInfo\n\n@synthesize name, length, layout;\n\n//-----------------------------------------------------------------------------\n- (instancetype)initWithName:(NSString *)_name Length:(uint32_t)_length\n{\n  if (self = [super init])\n  {\n    name = _name;\n    length = _length;\n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n+(MVObjectInfo *)objectInfoWithName:(NSString *)name Length:(uint32_t)length\n{\n  return [[MVObjectInfo alloc] initWithName:name Length:length];\n}\n\n@end\n\n//============================================================================\n@implementation ArchiveLayout\n\n- (instancetype)initWithDataController:(MVDataController *)dc rootNode:(MVNode *)node\n{\n  if (self = [super initWithDataController:dc rootNode:node])\n  {\n    objectInfoMap = [[NSMutableDictionary alloc] init];\n  }\n  return self;\n}\n//-----------------------------------------------------------------------------\n\n+ (ArchiveLayout *)layoutWithDataController:(MVDataController *)dc rootNode:(MVNode *)node\n{\n  return [[ArchiveLayout alloc] initWithDataController:dc rootNode:node];\n}\n//-----------------------------------------------------------------------------\n\n- (MVNode *)createSignatureNode:(MVNode *)parent\n                        caption:(NSString *)caption\n                       location:(uint64_t)location\n                         length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  NSString * signature = [dataController read_string:range fixlen:8 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Signature\"\n                         :signature];\n  return node;\n}\n//----------------------------------------------------------------------------\n\n- (MVNode *)createHeaderNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  NSString * name = [dataController read_string:range fixlen:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :name];\n  \n  NSString * time_str = [dataController read_string:range fixlen:12 lastReadHex:&lastReadHex];\n  time_t time = (time_t)[time_str longLongValue];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Time Stamp\"\n                         :[NSString stringWithFormat:@\"%s\", ctime(&time)]];\n\n  NSString * user_id_str = [dataController read_string:range fixlen:6 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"UserID\"\n                         :[NSString stringWithFormat:@\"%u\",[user_id_str intValue]]];\n\n  NSString * group_id_str = [dataController read_string:range fixlen:6 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"GroupID\"\n                         :[NSString stringWithFormat:@\"%u\",[group_id_str intValue]]];\n\n  NSString * mode_str = [dataController read_string:range fixlen:8 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Mode\"\n                         :[NSString stringWithFormat:@\"%u\",[mode_str intValue]]];\n\n  NSString * size_str = [dataController read_string:range fixlen:8 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Size\"\n                         :[NSString stringWithFormat:@\"%u\",[size_str intValue]]];\n  \n  // read spaces until end-of-header (0x60 0x0A)\n  NSMutableString * mutableLastReadHex = [[NSMutableString alloc] initWithCapacity:2];\n  NSMutableString * padding = [[NSMutableString alloc] initWithCapacity:2];\n  for(;;) \n  {\n    [padding appendString:[dataController read_string:range fixlen:1 lastReadHex:&lastReadHex]];\n    [mutableLastReadHex appendString:lastReadHex];\n    if (*(CSTRING(padding) + [padding length] - 1) != ' ')\n    {\n      [padding appendString:[dataController read_string:range fixlen:1 lastReadHex:&lastReadHex]];\n      [mutableLastReadHex appendString:lastReadHex];\n      break;\n    }\n  }\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location - [padding length] + 2]\n                         :mutableLastReadHex\n                         :@\"End Header\"\n                         :padding];\n  \n  MVObjectInfo * objectInfo;\n  if (NSEqualRanges([name rangeOfString:@\"#1/\"], NSMakeRange(0,3)))\n  {\n    uint32_t len = [[name substringFromIndex:3] intValue];\n    NSString * long_name = [dataController read_string:range fixlen:len lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Long Name\"\n                           :long_name];\n    \n    objectInfo = [MVObjectInfo objectInfoWithName:long_name Length:[size_str intValue] - len];\n  }\n  else \n  {\n    objectInfo = [MVObjectInfo objectInfoWithName:name Length:[size_str intValue]];\n  }\n  [objectInfoMap setObject:objectInfo forKey:[NSNumber numberWithUnsignedLong:location]];\n  \n  node.dataRange = NSMakeRange(location, NSMaxRange(range) - location);\n  \n  return node;\n}\n//----------------------------------------------------------------------------\n\n- (MVNode *)createMemberNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n                      strtab:(char const *)strtab\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  uint32_t size = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Size\"\n                         :[NSString stringWithFormat:@\"%u\",size]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  node.dataRange = NSMakeRange(location, size);\n  \n  while (size > 0)\n  {\n    uint32_t strx = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = [NSString stringWithFormat:@\"%s\",strtab + strx];\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Symbol\"\n                           :symbolName];\n\n    uint32_t off = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    \n    MVObjectInfo * objectInfo = [objectInfoMap objectForKey:[NSNumber numberWithUnsignedLong:off + imageOffset]];\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Object\"\n                           :objectInfo.name];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n    size -= sizeof(struct ranlib);\n  }\n  \n  return node;\n}\n\n\n//----------------------------------------------------------------------------\n\n\n- (void)doMainTasks\n{\n  NSString * lastReadHex;\n  \n  // archive start signature\n  [self createSignatureNode:rootNode \n                    caption:@\"Start\" \n                   location:imageOffset \n                     length:8];\n  \n\n  // read symbol table (ranlibs)\n  MVNode * symtabHeaderNode = [self createHeaderNode:rootNode \n                                             caption:@\"Symtab Header\"\n                                            location:imageOffset + 8 \n                                              length:0]; // length will be determined in function\n  \n  // skip symbol and string table for now\n  uint64_t symtabOffset = NSMaxRange(symtabHeaderNode.dataRange);\n  NSRange range = NSMakeRange(symtabOffset,0);\n  uint32_t symtabSize = [dataController read_uint32:range lastReadHex:&lastReadHex] + sizeof(uint32_t);\n  uint64_t strtabOffset = symtabOffset + symtabSize;\n  range = NSMakeRange(strtabOffset,0);  \n  uint32_t strtabSize = [dataController read_uint32:range lastReadHex:&lastReadHex] + sizeof(uint32_t);\n  \n  // read headers\n\n  for (uint64_t location = strtabOffset + strtabSize; location < NSMaxRange(rootNode.dataRange); )\n  {\n    MVNode * headerNode = [self createHeaderNode:rootNode \n                                         caption:@\"Object Header\"\n                                        location:location \n                                          length:0]; // length will be determined in function\n    \n    MVObjectInfo * objectInfo = [objectInfoMap objectForKey:[NSNumber numberWithUnsignedLong:location]];\n    \n    uint64_t objectOffset = NSMaxRange(headerNode.dataRange); // starts right after the header\n    uint64_t objectSize = objectInfo.length;\n    \n    // create Mach-O object layout\n    MVNode * objectNode = [self createDataNode:rootNode \n                                       caption:objectInfo.name\n                                      location:objectOffset \n                                        length:objectSize];\n    \n    objectInfo.layout = [MachOLayout layoutWithDataController:dataController rootNode:objectNode];\n    \n    [objectNode.userInfo setObject:objectInfo.layout forKey:MVLayoutUserInfoKey];\n    [objectInfo.layout doMainTasks];\n    \n    // move to the next header\n    location = objectOffset + objectSize;\n  }\n\n  // finish symbol table based on the information about processed objects\n  [self createMemberNode:rootNode \n                 caption:@\"Symbol Table\"\n                location:symtabOffset\n                  length:symtabSize\n                  strtab:(char *)((uint8_t *)[dataController.fileData bytes] + strtabOffset + sizeof(uint32_t))]; \n  \n  [self createDataNode:rootNode caption:@\"String Table\" \n              location:strtabOffset \n                length:strtabSize];\n  \n\n  [super doMainTasks];\n}\n//----------------------------------------------------------------------------\n\n- (void)doBackgroundTasks\n{\n  [dataController updateStatus:MVStatusTaskStarted];\n  \n  for (MVObjectInfo * objectInfo in [objectInfoMap allValues])\n  {\n    MVLayout * layout = objectInfo.layout;\n    \n    // if the thread is cancelled, then the MVLayout::doBackgroundTasks will not been called\n    // so, here is the only chance to stop the saver thread for the particular layout\n    if ([backgroundThread isCancelled])\n    {\n      [layout.archiver halt];\n      continue;\n    }\n\n    // the MVLayout::doBackgroundTasks is called before this returns\n    [layout doBackgroundTasks];\n  }\n  \n  [super doBackgroundTasks];\n  \n  [dataController updateStatus:MVStatusTaskTerminated];\n}\n//----------------------------------------------------------------------------\n\n@end\n"
        },
        {
          "name": "Attach.h",
          "type": "blob",
          "size": 0.5107421875,
          "content": "/*\n *  Attach.h\n *  MachOView\n *\n *  Created by fG! on 08/09/13.\n *  reverser@put.as\n *\n */\n\n#ifndef machoview_Attach_h\n#define machoview_Attach_h\n\n#include <mach/mach.h>\n#include <mach/mach_vm.h>\n#include <mach/vm_map.h>\n#include <mach-o/loader.h>\n\nint64_t get_image_size(mach_vm_address_t address, pid_t pid, uint64_t *vmaddr_slide);\nkern_return_t find_main_binary(pid_t pid, mach_vm_address_t *main_address);\nkern_return_t dump_binary(mach_vm_address_t address, pid_t pid, uint8_t *buffer, uint64_t aslr_slide);\n\n#endif\n"
        },
        {
          "name": "Attach.mm",
          "type": "blob",
          "size": 8.609375,
          "content": "/*\n *  Attach.mm\n *  MachOView\n *\n *  Created by fG! on 08/09/13.\n *  reverser@put.as\n *\n *  Contains functions for the attach to process feature.\n *\n */\n\n#include \"Attach.h\"\n\n#include <stdio.h>\n\n/* local functions */\nstatic kern_return_t readmem(mach_vm_offset_t *buffer, mach_vm_address_t address, mach_vm_size_t size, pid_t pid, vm_region_basic_info_data_64_t *info);\n\n#pragma mark Public functions\n\n/*\n * find main binary by iterating memory region\n * assumes there's only one binary with filetype == MH_EXECUTE\n */\nkern_return_t\nfind_main_binary(pid_t pid, mach_vm_address_t *main_address)\n{\n  vm_map_t targetTask = 0;\n  kern_return_t kr = 0;\n  if (task_for_pid(mach_task_self(), pid, &targetTask))\n  {\n    NSLog(@\"[ERROR] Can't execute task_for_pid! Do you have the right permissions/entitlements?\\n\");\n    return KERN_FAILURE;\n  }\n  \n  vm_address_t iter = 0;\n  while (1)\n  {\n    struct mach_header mh = {0};\n    vm_address_t addr = iter;\n    vm_size_t lsize = 0;\n    uint32_t depth;\n    mach_vm_size_t bytes_read = 0;\n    struct vm_region_submap_info_64 info;\n    mach_msg_type_number_t count = VM_REGION_SUBMAP_INFO_COUNT_64;\n    if (vm_region_recurse_64(targetTask, &addr, &lsize, &depth, (vm_region_info_t)&info, &count))\n    {\n      break;\n    }\n    kr = mach_vm_read_overwrite(targetTask, (mach_vm_address_t)addr, (mach_vm_size_t)sizeof(struct mach_header), (mach_vm_address_t)&mh, &bytes_read);\n    if (kr == KERN_SUCCESS && bytes_read == sizeof(struct mach_header))\n    {\n      /* only one image with MH_EXECUTE filetype */\n      if ( (mh.magic == MH_MAGIC || mh.magic == MH_MAGIC_64) && mh.filetype == MH_EXECUTE)\n      {\n#if DEBUG\n        NSLog(@\"Found main binary mach-o image @ %p!\\n\", (void*)addr);\n#endif\n        *main_address = addr;\n        break;\n      }\n    }\n    iter = addr + lsize;\n  }\n  return KERN_SUCCESS;\n}\n\n/*\n * we need to find the binary file size\n * which is taken from the filesize field of each segment command\n * and not the vmsize (because of alignment)\n * if we dump using vmaddresses, we will get the alignment space into the dumped\n * binary and get into problems :-)\n */\nint64_t\nget_image_size(mach_vm_address_t address, pid_t pid, uint64_t *vmaddr_slide)\n{\n  vm_region_basic_info_data_64_t region_info = {0};\n  // allocate a buffer to read the header info\n  // NOTE: this is not exactly correct since the 64bit version has an extra 4 bytes\n  // but this will work for this purpose so no need for more complexity!\n  struct mach_header header = {0};\n  if (readmem((mach_vm_offset_t*)&header, address, sizeof(struct mach_header), pid, &region_info))\n  {\n    NSLog(@\"Can't read header!\");\n    return -1;\n  }\n  \n  if (header.magic != MH_MAGIC && header.magic != MH_MAGIC_64)\n  {\n\t\tprintf(\"[ERROR] Target is not a mach-o binary!\\n\");\n    return -1;\n  }\n  \n  int64_t imagefilesize = -1;\n  /* read the load commands */\n  uint8_t *loadcmds = (uint8_t*)malloc(header.sizeofcmds);\n  uint16_t mach_header_size = sizeof(struct mach_header);\n  if (header.magic == MH_MAGIC_64)\n  {\n    mach_header_size = sizeof(struct mach_header_64);\n  }\n  if (readmem((mach_vm_offset_t*)loadcmds, address+mach_header_size, header.sizeofcmds, pid, &region_info))\n  {\n    NSLog(@\"Can't read load commands\");\n    free(loadcmds);\n    return -1;\n  }\n  \n  /* process and retrieve address and size of linkedit */\n  uint8_t *loadCmdAddress = 0;\n  loadCmdAddress = (uint8_t*)loadcmds;\n  struct load_command *loadCommand    = NULL;\n  struct segment_command *segCmd      = NULL;\n  struct segment_command_64 *segCmd64 = NULL;\n  for (uint32_t i = 0; i < header.ncmds; i++)\n  {\n    loadCommand = (struct load_command*)loadCmdAddress;\n    if (loadCommand->cmd == LC_SEGMENT)\n    {\n      segCmd = (struct segment_command*)loadCmdAddress;\n      if (strncmp(segCmd->segname, \"__PAGEZERO\", 16) != 0)\n      {\n        if (strncmp(segCmd->segname, \"__TEXT\", 16) == 0)\n        {\n          *vmaddr_slide = address - segCmd->vmaddr;\n        }\n        imagefilesize += segCmd->filesize;\n      }\n    }\n    else if (loadCommand->cmd == LC_SEGMENT_64)\n    {\n      segCmd64 = (struct segment_command_64*)loadCmdAddress;\n      if (strncmp(segCmd64->segname, \"__PAGEZERO\", 16) != 0)\n      {\n        if (strncmp(segCmd64->segname, \"__TEXT\", 16) == 0)\n        {\n          *vmaddr_slide = address - segCmd64->vmaddr;\n        }\n        imagefilesize += segCmd64->filesize;\n      }\n    }\n    // advance to next command\n    loadCmdAddress += loadCommand->cmdsize;\n  }\n  free(loadcmds);\n  return imagefilesize;\n}\n\n/*\n * dump the binary into the allocated buffer\n * we dump each segment and advance the buffer\n */\nkern_return_t\ndump_binary(mach_vm_address_t address, pid_t pid, uint8_t *buffer, uint64_t aslr_slide)\n{\n  vm_region_basic_info_data_64_t region_info = {0};\n  // allocate a buffer to read the header info\n  // NOTE: this is not exactly correct since the 64bit version has an extra 4 bytes\n  // but this will work for this purpose so no need for more complexity!\n  struct mach_header header = {0};\n  if (readmem((mach_vm_offset_t*)&header, address, sizeof(struct mach_header), pid, &region_info))\n  {\n    NSLog(@\"Can't read header!\");\n    return KERN_FAILURE;\n  }\n  \n  if (header.magic != MH_MAGIC && header.magic != MH_MAGIC_64)\n  {\n    printf(\"[ERROR] Target is not a mach-o binary!\\n\");\n    exit(1);\n  }\n  \n  // read the header info to find the LINKEDIT\n  uint8_t *loadcmds = (uint8_t*)malloc(header.sizeofcmds);\n  \n  uint16_t mach_header_size = sizeof(struct mach_header);\n  if (header.magic == MH_MAGIC_64)\n  {\n    mach_header_size = sizeof(struct mach_header_64);\n  }\n  // retrieve the load commands\n  if (readmem((mach_vm_offset_t*)loadcmds, address+mach_header_size, header.sizeofcmds, pid, &region_info))\n  {\n    NSLog(@\"Can't read load commands\");\n    free(loadcmds);\n    loadcmds = NULL;\n    return KERN_FAILURE;\n  }\n  \n  // process and retrieve address and size of linkedit\n  uint8_t *loadCmdAddress = 0;\n  loadCmdAddress = (uint8_t*)loadcmds;\n  struct load_command *loadCommand    = NULL;\n  struct segment_command *segCmd      = NULL;\n  struct segment_command_64 *segCmd64 = NULL;\n  for (uint32_t i = 0; i < header.ncmds; i++)\n  {\n    loadCommand = (struct load_command*)loadCmdAddress;\n    if (loadCommand->cmd == LC_SEGMENT)\n    {\n      segCmd = (struct segment_command*)loadCmdAddress;\n      if (strncmp(segCmd->segname, \"__PAGEZERO\", 16) != 0)\n      {\n#if DEBUG\n        printf(\"[DEBUG] Dumping %s at %llx with size %x (buffer:%x)\\n\", segCmd->segname, segCmd->vmaddr+aslr_slide, segCmd->filesize, (uint32_t)*buffer);\n#endif\n        readmem((mach_vm_offset_t*)buffer, segCmd->vmaddr+aslr_slide, segCmd->filesize, pid, &region_info);\n      }\n      buffer += segCmd->filesize;\n    }\n    else if (loadCommand->cmd == LC_SEGMENT_64)\n    {\n      segCmd64 = (struct segment_command_64*)loadCmdAddress;\n      if (strncmp(segCmd64->segname, \"__PAGEZERO\", 16) != 0)\n      {\n#if DEBUG\n        printf(\"[DEBUG] Dumping %s at %llx with size %llx (buffer:%x)\\n\", segCmd64->segname, segCmd64->vmaddr+aslr_slide, segCmd64->filesize, (uint32_t)*buffer);\n#endif\n        readmem((mach_vm_offset_t*)buffer, segCmd64->vmaddr+aslr_slide, segCmd64->filesize, pid, &region_info);\n      }\n      buffer += segCmd64->filesize;\n    }\n    // advance to next command\n    loadCmdAddress += loadCommand->cmdsize;\n  }\n  free(loadcmds);\n  loadcmds = NULL;\n  return KERN_SUCCESS;\n}\n\n#pragma mark Local functions\n\nstatic kern_return_t\nreadmem(mach_vm_offset_t *buffer, mach_vm_address_t address, mach_vm_size_t size, pid_t pid, vm_region_basic_info_data_64_t *info)\n{\n  // get task for pid\n  vm_map_t port;\n  \n  kern_return_t kr;\n  //#if DEBUG\n  //    printf(\"[DEBUG] Readmem of address %llx to buffer %llx with size %llx\\n\", address, buffer, size);\n  //#endif\n  if (task_for_pid(mach_task_self(), pid, &port))\n  {\n    fprintf(stderr, \"[ERROR] Can't execute task_for_pid! Do you have the right permissions/entitlements?\\n\");\n    return KERN_FAILURE;\n  }\n  \n  mach_msg_type_number_t info_cnt = sizeof (vm_region_basic_info_data_64_t);\n  mach_port_t object_name;\n  mach_vm_size_t size_info;\n  mach_vm_address_t address_info = address;\n  kr = mach_vm_region(port, &address_info, &size_info, VM_REGION_BASIC_INFO_64, (vm_region_info_t)info, &info_cnt, &object_name);\n  if (kr)\n  {\n    fprintf(stderr, \"[ERROR] mach_vm_region failed with error %d\\n\", (int)kr);\n    return KERN_FAILURE;\n  }\n  \n  /* read memory - vm_read_overwrite because we supply the buffer */\n  mach_vm_size_t nread;\n  kr = mach_vm_read_overwrite(port, address, size, (mach_vm_address_t)buffer, &nread);\n  if (kr)\n  {\n    fprintf(stderr, \"[ERROR] vm_read failed! %d\\n\", kr);\n    return KERN_FAILURE;\n  }\n  else if (nread != size)\n  {\n    fprintf(stderr, \"[ERROR] vm_read failed! requested size: 0x%llx read: 0x%llx\\n\", size, nread);\n    return KERN_FAILURE;\n  }\n  return KERN_SUCCESS;\n}\n"
        },
        {
          "name": "Base.lproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "CRTFootPrints.h",
          "type": "blob",
          "size": 0.537109375,
          "content": "/*\n *  CRTFootPrints.h\n *  MachOView\n *\n *  Created by psaghelyi on 25/11/2010.\n *\n */\n\n\n#import \"MachOLayout.h\"\n\n#define FOOTPRINT_STRIDE 16\n#define GAP(x)  {00, x}  // fake entry with zero length, second element is the size of bytes to skip\n\ntypedef uint8_t AsmFootPrint[][FOOTPRINT_STRIDE];\n\n@interface MachOLayout (CRTFootPrints)\n\n- (bool) matchAsmAtOffset:(uint64_t)offset \n             asmFootPrint:(const AsmFootPrint)footprint \n                lineCount:(NSUInteger)lineCount;\n                \n- (void) determineRuntimeVersion;\n\n@end\n\n    \n\n\n"
        },
        {
          "name": "CRTFootPrints.mm",
          "type": "blob",
          "size": 77.6708984375,
          "content": "/*\n *  CRTFootPrints.mm\n *  MachOView\n *\n *  Created by psaghelyi on 25/11/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#import \"CRTFootPrints.h\"\n#import \"DataController.h\"\n#import <mach-o/loader.h>\n\n#define MATCHASM(_pattern) \\\n  (offset + sizeof(_pattern) < dataLength && \\\n  [self matchAsmAtOffset:offset asmFootPrint:_pattern lineCount:sizeof(_pattern)/FOOTPRINT_STRIDE])\n\n\nusing namespace std;\n\n//**********************************************************************\n//                             crt1 footprints\n//**********************************************************************\n\n//==================================\n// SDK:10.4 DeployTarget:10.4\n// MacOSX10.4u.sdk/usr/lib/crt1.o\n//==================================\nstatic AsmFootPrint const SDK104Target104X86v1 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4 ,0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC ,0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D ,0x04},                    // mov     ebx, [ebp+4]\n  {4, 0x89, 0x5C ,0x24 ,0x00},              // mov     [esp+14h+var_14], ebx\n  {3, 0x8D, 0x4D ,0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C ,0x24 ,0x04},              // mov     [esp+14h+var_10], ecx\n  {3, 0x83, 0xC3 ,0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3 ,0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C ,0x24 ,0x08},              // mov     [esp+14h+var_C], ebx\n  {5, 0xE8, 0x01 ,0x00 ,0x00 ,0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n\n  //__start:\n  {1, 0x55},                                // push    ebp\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {1, 0x57},                                // push    edi\n  {1, 0x56},                                // push    esi\n  {1, 0x53},                                // push    ebx\n  {3, 0x83, 0xEC, 0x2C},                    // sub     esp, 2Ch\n  {1, 0xE8}, GAP(4),                        // call    sub_120AD8\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {2, 0x89, 0x83}, GAP(4),                  // mov     ds:(_NXArgc - 2C28h)[ebx], eax\n  {3, 0x8B, 0x45, 0x0C},                    // mov     eax, [ebp+arg_4]\n  {2, 0x89, 0x83}, GAP(4),                  // mov     ds:(_NXArgv - 2C28h)[ebx], eax\n  {3, 0x8B, 0x45, 0x10},                    // mov     eax, [ebp+arg_8]\n  {2, 0x89, 0x83}, GAP(4),                  // mov     ds:(_environ - 2C28h)[ebx], eax\n  {2, 0x8B, 0x83}, GAP(4),                  // mov     eax, ds:(_mach_init_routine_ptr - 2C28h)[ebx]\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_2C51\n  {2, 0xFF, 0xD0},                          // call    eax\n\n  //loc_2C51: \n  {2, 0x8B, 0x83}, GAP(4),                  // mov     eax, ds:(__cthread_init_routine_ptr - 2C28h)[ebx]\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_2C5F\n  {2, 0xFF, 0xD0},                          // call    eax\n\n  //loc_2C5F:\n  {1, 0xE8}, GAP(4),                        // call    ___keymgr_dwarf2_register_sections\n  {5, 0xE8, 0xB0, 0x00, 0x00, 0x00},        // call    sub_2D19\n  {3, 0x8D, 0x45, 0xE4},                    // lea     eax, [ebp+var_1C]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {2, 0x8D, 0x83}, GAP(4),                  // lea     eax, (a__dyld_mod_ter - 2C28h)[ebx] ; \"__dyld_mod_term_funcs\"\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {5, 0xE8, 0xD2, 0x00, 0x00, 0x00},        // call    sub_2D50\n  {3, 0x8B, 0x45, 0xE4},                    // mov     eax, [ebp+var_1C]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x08},                          // jz      short loc_2C8D\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; void (*)(void)\n  {1, 0xE8}, GAP(4),                        // call    _atexit\n\n  //loc_2C8D:\n  {2, 0x8B, 0x83}, GAP(4),                  // mov     eax, ds:(_errno_ptr - 2C28h)[ebx]\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [eax], 0\n  {3, 0x8B, 0x45, 0x0C},                    // mov     eax, [ebp+arg_4]\n  {2, 0x8B, 0x38},                          // mov     edi, [eax]\n  {2, 0x85, 0xFF},                          // test    edi, edi\n  {2, 0x75, 0x64},                          // jnz     short loc_2D06\n  {2, 0xEB, 0x27},                          // jmp     short loc_2CCB\n  // ---------------------------------------------------------------------------\n\n  //loc_2CA4:\n  {3, 0x80, 0xF9, 0x2F},                    // cmp     cl, 2Fh\n  {3, 0x0F, 0x44, 0xC2},                    // cmovz   eax, edx\n  {2, 0x89, 0xF2},                          // mov     edx, esi\n  {3, 0x0F, 0xB6, 0x0E},                    // movzx   ecx, byte ptr [esi]\n  {3, 0x8D, 0x76, 0x01},                    // lea     esi, [esi+1]\n  {2, 0x84, 0xC9},                          // test    cl, cl\n  {2, 0x75, 0xEE},                          // jnz     short loc_2CA4\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x0B},                          // jz      short loc_2CC5\n  {3, 0x83, 0xC0, 0x01},                    // add     eax, 1\n  {2, 0x89, 0x83}, GAP(4),                  // mov     ds:(___progname - 2C28h)[ebx], eax\n  {2, 0xEB, 0x06},                          // jmp     short loc_2CCB\n  // ---------------------------------------------------------------------------\n\n  //loc_2CC5:\n  {2, 0x89, 0xBB}, GAP(4),                  // mov     ds:(___progname - 2C28h)[ebx], edi\n\n  //loc_2CCB:\n  {3, 0x8B, 0x45, 0x10},                    // mov     eax, [ebp+arg_8]\n  {3, 0x83, 0x38, 0x00},                    // cmp     dword ptr [eax], 0\n  {2, 0x74, 0x0B},                          // jz      short loc_2CDE\n  {3, 0x8B, 0x45, 0x10},                    // mov     eax, [ebp+arg_8]\n\n  //loc_2CD6:\n  {3, 0x83, 0xC0, 0x04},                    // add     eax, 4\n  {3, 0x83, 0x38, 0x00},                    // cmp     dword ptr [eax], 0\n  {2, 0x75, 0xF8},                          // jnz     short loc_2CD6\n\n  //loc_2CDE:\n  {3, 0x83, 0xC0, 0x04},                    // add     eax, 4\n  {4, 0x89, 0x44, 0x24, 0x0C},              // mov     [esp+0Ch], eax\n  {3, 0x8B, 0x45, 0x10},                    // mov     eax, [ebp+arg_8]\n  {4, 0x89, 0x44, 0x24, 0x08},              // mov     [esp+8], eax\n  {3, 0x8B, 0x45, 0x0C},                    // mov     eax, [ebp+arg_4]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {1, 0xE8}, GAP(4),                        // call    _main\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; int\n  {1, 0xE8}, GAP(4),                        // call    _exit\n  // ---------------------------------------------------------------------------\n  \n  //loc_2D06:\n  {3, 0x0F, 0xB6, 0x0F},                    // movzx   ecx, byte ptr [edi]\n  {2, 0x84, 0xC9},                          // test    cl, cl\n  {2, 0x74, 0xB8},                          // jz      short loc_2CC5\n  {3, 0x8D, 0x77, 0x01},                    // lea     esi, [edi+1]\n  {2, 0x89, 0xFA},                          // mov     edx, edi\n  {5, 0xB8, 0x00, 0x00, 0x00, 0x00},        // mov     eax, 0\n  {2, 0xEB, 0x8B},                          // jmp     short loc_2CA4\n  \n  //sub_2D19:\n  {1, 0x55},                                // push    ebp\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {1, 0x53},                                // push    ebx\n  {3, 0x83, 0xEC, 0x24},                    // sub     esp, 24h\n  {1, 0xE8}, GAP(4),                        // call    sub_120AD8\n  {3, 0x8D, 0x45, 0xF4},                    // lea     eax, [ebp+var_C]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {2, 0x8D, 0x83}, GAP(4),                  // lea     eax, (a__dyld_make_de - 2D25h)[ebx] ; \"__dyld_make_delayed_module_initializer_\"...\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {5, 0xE8, 0x16, 0x00, 0x00, 0x00},        // call    sub_2D50\n  {3, 0xFF, 0x55, 0xF4},                    // call    [ebp+var_C]\n  {3, 0x83, 0xC4, 0x24},                    // add     esp, 24h\n  {1, 0x5B},                                // pop     ebx\n  {1, 0x5D},                                // pop     ebp\n  {1, 0xC3},                                // retn\n  // ---------------------------------------------------------------------------\n  {1, 0x90},                                // nop\n  {5, 0x68, 0x00, 0x10, 0x00, 0x00},        // push    1000h\n  {2, 0xFF, 0x25}, GAP(4),                  // jmp     ds:dword_150010\n  // ---------------------------------------------------------------------------\n  {1, 0x90},                                // nop\n \n  //sub_2D50:\n  {2, 0xFF, 0x25}, GAP(4),                  // jmp     ds:dword_150014\n};  \n\n\nstatic AsmFootPrint const SDK104Target104X86v2 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4, 0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC, 0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D, 0x04},                    // mov     ebx, [ebp+4]\n  {4, 0x89, 0x5C, 0x24, 0x00},              // mov     [esp+14h+var_14], ebx\n  {3, 0x8D, 0x4D, 0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C, 0x24, 0x04},              // mov     [esp+14h+var_10], ecx\n  {3, 0x83, 0xC3, 0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3, 0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+14h+var_C], ebx\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n  \n  //__start:\n  {1, 0x55},                                // push    ebp\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {1, 0x57},                                // push    edi\n  {1, 0x56},                                // push    esi\n  {1, 0x53},                                // push    ebx\n  {3, 0x83, 0xEC, 0x2C},                    // sub     esp, 2Ch\n  {3, 0x8B, 0x7D, 0x0C},                    // mov     edi, [ebp+arg_4]\n  {3, 0x8B, 0x5D, 0x10},                    // mov     ebx, [ebp+arg_8]\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {1, 0xA3}, GAP(4),                        // mov     ds:_NXArgc, eax\n  {2, 0x89, 0x3D}, GAP(4),                  // mov     ds:_NXArgv, edi\n  {2, 0x89, 0x1D}, GAP(4),                  // mov     ds:_environ, ebx\n  {2, 0x8B, 0x0F},                          // mov     ecx, [edi]\n  {2, 0x85, 0xC9},                          // test    ecx, ecx\n  {2, 0x75, 0x07},                          // jnz     short loc_5A\n  {1, 0xB9}, GAP(4),                        // mov     ecx, offset byte_120\n  {2, 0xEB, 0x19},                          // jmp     short loc_73\n  // ---------------------------------------------------------------------------\n  \n  //loc_5A:\n  {2, 0x89, 0xCA},                          // mov     edx, ecx\n  {2, 0xEB, 0x0E},                          // jmp     short loc_6C\n  // ---------------------------------------------------------------------------\n  \n  //loc_5E:\n  {2, 0x3C, 0x2F},                          // cmp     al, 2Fh ; '/'\n  {2, 0x74, 0x05},                          // jz      short loc_67\n  {3, 0x83, 0xC2, 0x01},                    // add     edx, 1\n  {2, 0xEB, 0x05},                          // jmp     short loc_6C\n  // ---------------------------------------------------------------------------\n  \n  //loc_67:\n  {3, 0x83, 0xC2, 0x01},                    // add     edx, 1\n  {2, 0x89, 0xD1},                          // mov     ecx, edx\n  \n  //loc_6C:\n  {3, 0x0F, 0xB6, 0x02},                    // movzx   eax, byte ptr [edx]\n  {2, 0x84, 0xC0},                          // test    al, al\n  {2, 0x75, 0xEB},                          // jnz     short loc_5E\n  \n  //loc_73:\n  {2, 0x89, 0x0D}, GAP(4),                  // mov     ds:___progname, ecx\n  {2, 0x89, 0xD8},                          // mov     eax, ebx\n  {2, 0xEB, 0x03},                          // jmp     short loc_80\n  // ---------------------------------------------------------------------------\n  \n  //loc_7D:\n  {3, 0x83, 0xC0, 0x04},                    // add     eax, 4\n  \n  //loc_80:\n  {2, 0x8B, 0x10},                          // mov     edx, [eax]\n  {2, 0x85, 0xD2},                          // test    edx, edx\n  {2, 0x75, 0xF7},                          // jnz     short loc_7D\n  {3, 0x8D, 0x70, 0x04},                    // lea     esi, [eax+4]\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_mach_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_96\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_96:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:__cthread_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_A3\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_A3:\n  {1, 0xE8}, GAP(4),                        // call    ___keymgr_dwarf2_register_sections\n  {3, 0x8D, 0x45, 0xE0},                    // lea     eax, [ebp+var_20]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_make_de ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xE0},                    // call    [ebp+var_20]\n  {3, 0x8D, 0x45, 0xE4},                    // lea     eax, [ebp+var_1C]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_mod_ter ; \"__dyld_mod_term_funcs\"\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0x8B, 0x45, 0xE4},                    // mov     eax, [ebp+var_1C]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x08},                          // jz      short loc_E0\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; void (*)(void)\n  {1, 0xE8}, GAP(4),                        // call    _atexit\n  \n  //loc_E0:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_errno_ptr\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [eax], 0\n  {4, 0x89, 0x74, 0x24, 0x0C},              // mov     [esp+0Ch], esi\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+8], ebx\n  {4, 0x89, 0x7C, 0x24, 0x04},              // mov     [esp+4], edi\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {1, 0xE8}, GAP(4),                        // call    _main\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; int\n  {1, 0xE8}, GAP(4),                        // call    _exit\n};\n\nstatic AsmFootPrint const SDK104Target104X86v3 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4, 0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC, 0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D, 0x04},                    // mov     ebx, [ebp+4]\n  {4, 0x89, 0x5C, 0x24, 0x00},              // mov     [esp+0], ebx\n  {3, 0x8D, 0x4D, 0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C, 0x24, 0x04},              // mov     [esp+4], ecx\n  {3, 0x83, 0xC3, 0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3, 0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+8], ebx\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n  \n  \n  //__start:\n  {1, 0x55},                                // push    ebp\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {1, 0x57},                                // push    edi\n  {1, 0x56},                                // push    esi\n  {1, 0x53},                                // push    ebx\n  {3, 0x83, 0xEC, 0x2C},                    // sub     esp, 2Ch\n  {3, 0x8B, 0x75, 0x0C},                    // mov     esi, [ebp+0Ch]\n  {3, 0x8B, 0x5D, 0x10},                    // mov     ebx, [ebp+10h]\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+8]\n  {2, 0x89, 0x35}, GAP(4),                  // mov     ds:_NXArgv, esi\n  {2, 0x89, 0x1D}, GAP(4),                  // mov     ds:_environ, ebx\n  {1, 0xA3}, GAP(4),                        // mov     ds:_NXArgc, eax\n  {2, 0x8B, 0x0E},                          // mov     ecx, [esi]\n  {2, 0x85, 0xC9},                          // test    ecx, ecx\n  {2, 0x89, 0xCA},                          // mov     edx, ecx\n  {2, 0x75, 0x11},                          // jnz     short loc_26BA\n  {1, 0xB9}, GAP(4),                        // mov     ecx, offset unk_13C874\n  {2, 0xEB, 0x11},                          // jmp     short loc_26C1\n  // ---------------------------------------------------------------------------\n  \n  //loc_26B0:\n  {2, 0x3C, 0x2F},                          // cmp     al, 2Fh\n  {2, 0x74, 0x03},                          // jz      short loc_26B7\n  {1, 0x42},                                // inc     edx\n  {2, 0xEB, 0x03},                          // jmp     short loc_26BA\n  // ---------------------------------------------------------------------------\n  \n  //loc_26B7:\n  {1, 0x42},                                // inc     edx\n  {2, 0x89, 0xD1},                          // mov     ecx, edx\n  \n  //loc_26BA:\n  {3, 0x0F, 0xB6, 0x02},                    // movzx   eax, byte ptr [edx]\n  {2, 0x84, 0xC0},                          // test    al, al\n  {2, 0x75, 0xEF},                          // jnz     short loc_26B0\n  \n  //loc_26C1:\n  {2, 0x89, 0xD8},                          // mov     eax, ebx\n  {2, 0x89, 0x0D}, GAP(4),                  // mov     ds:___progname, ecx\n  {2, 0xEB, 0x03},                          // jmp     short loc_26CE\n  // ---------------------------------------------------------------------------\n  \n  //loc_26CB:\n  {3, 0x83, 0xC0, 0x04},                    // add     eax, 4\n  \n  //loc_26CE:\n  {2, 0x8B, 0x10},                          // mov     edx, [eax]\n  {2, 0x85, 0xD2},                          // test    edx, edx\n  {2, 0x75, 0xF7},                          // jnz     short loc_26CB\n  {3, 0x8D, 0x78, 0x04},                    // lea     edi, [eax+4]\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_mach_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_26E4\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_26E4:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:__cthread_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_26F1\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_26F1:\n  {1, 0xE8}, GAP(4),                        // call    ___keymgr_dwarf2_register_sections\n  {3, 0x8D, 0x45, 0xE0},                    // lea     eax, [ebp-20h]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_make_de ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xE0},                    // call    dword ptr [ebp-20h]\n  {3, 0x8D, 0x45, 0xE4},                    // lea     eax, [ebp-1Ch]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_mod_ter ; \"__dyld_mod_term_funcs\"\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0x8B, 0x45, 0xE4},                    // mov     eax, [ebp-1Ch]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x08},                          // jz      short loc_272E\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {1, 0xE8}, GAP(4),                        // call    _atexit\n  \n  //loc_272E:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_errno_ptr\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [eax], 0\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+8]\n  {4, 0x89, 0x7C, 0x24, 0x0C},              // mov     [esp+0Ch], edi\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+8], ebx\n  {4, 0x89, 0x74, 0x24, 0x04},              // mov     [esp+4], esi\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {1, 0xE8}, GAP(4),                        // call    _main\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {1, 0xE8}, GAP(4),                        // call    _exit\n};\n\nstatic AsmFootPrint const SDK104Target104X86v4 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4, 0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC, 0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D, 0x04},                    // mov     ebx, [ebp+4]\n  {3, 0x89, 0x1C, 0x24},                    // mov     [esp+14h+var_14], ebx\n  {3, 0x8D, 0x4D, 0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C, 0x24, 0x04},              // mov     [esp+14h+var_10], ecx\n  {3, 0x83, 0xC3, 0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3, 0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+14h+var_C], ebx\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n  \n  //__start:\n  {1, 0x55},                                // push    ebp\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {1, 0x53},                                // push    ebx\n  {1, 0x57},                                // push    edi\n  {1, 0x56},                                // push    esi\n  {3, 0x83, 0xEC, 0x1C},                    // sub     esp, 1Ch\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {1, 0xA3}, GAP(4),                        // mov     ds:_NXArgc, eax\n  {3, 0x8B, 0x75, 0x0C},                    // mov     esi, [ebp+arg_4]\n  {2, 0x89, 0x35}, GAP(4),                  // mov     ds:_NXArgv, esi\n  {3, 0x8B, 0x7D, 0x10},                    // mov     edi, [ebp+arg_8]\n  {2, 0x89, 0x3D}, GAP(4),                  // mov     ds:_environ, edi\n  {2, 0x8B, 0x06},                          // mov     eax, [esi]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x75, 0x07},                          // jnz     short loc_20D9\n  {1, 0xB8}, GAP(4),                        // mov     eax, 3BF300h\n  {2, 0xEB, 0x28},                          // jmp     short loc_2101\n  // ---------------------------------------------------------------------------\n  \n  // loc_20D9:\n  {2, 0x8A, 0x08},                          // mov     cl, [eax]\n  {2, 0x84, 0xC9},                          // test    cl, cl\n  {2, 0x74, 0x22},                          // jz      short loc_2101\n  {3, 0x8A, 0x50, 0x01},                    // mov     dl, [eax+1]\n  {3, 0x8D, 0x58, 0x01},                    // lea     ebx, [eax+1]\n  {3, 0x80, 0xF9, 0x2F},                    // cmp     cl, 2Fh\n  {3, 0x0F, 0x45, 0xD8},                    // cmovnz  ebx, eax\n  {2, 0x84, 0xD2},                          // test    dl, dl\n  {2, 0x74, 0x10},                          // jz      short loc_20FF\n  {3, 0x83, 0xC0, 0x02},                    // add     eax, 2\n  \n  // loc_20F2:\n  {3, 0x80, 0xFA, 0x2F},                    // cmp     dl, 2Fh\n  {3, 0x0F, 0x44, 0xD8},                    // cmovz   ebx, eax\n  {2, 0x8A, 0x10},                          // mov     dl, [eax]\n  {1, 0x40},                                // inc     eax\n  {2, 0x84, 0xD2},                          // test    dl, dl\n  {2, 0x75, 0xF3},                          // jnz     short loc_20F2\n  \n  // loc_20FF:\n  {2, 0x89, 0xD8},                          // mov     eax, ebx\n  \n  // loc_2101:\n  \n  {1, 0xA3}, GAP(4),                        // mov     ds:___progname, eax\n  {2, 0x89, 0xFB},                          // mov     ebx, edi\n  \n  // loc_2108:\n  {3, 0x83, 0x3B, 0x00},                    // cmp     dword ptr [ebx], 0\n  {3, 0x8D, 0x5B, 0x04},                    // lea     ebx, [ebx+4]\n  {2, 0x75, 0xF8},                          // jnz     short loc_2108\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_mach_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_211D\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  // loc_211D:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:__cthread_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_212A\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  // loc_212A:\n  {1, 0xE8}, GAP(4),                        // call    ___keymgr_dwarf2_register_sections\n  {3, 0x8D, 0x45, 0xEC},                    // lea     eax, [ebp+var_14]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_make_de ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xEC},                    // call    [ebp+var_14]\n  {3, 0x8D, 0x45, 0xF0},                    // lea     eax, [ebp+var_10]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_mod_ter ; \"__dyld_mod_term_funcs\"\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0x8B, 0x45, 0xF0},                    // mov     eax, [ebp+var_10]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x08},                          // jz      short loc_2167\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; void (*)(void)\n  {1, 0xE8}, GAP(4),                        // call    _atexit\n  \n  // loc_2167:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_errno_ptr\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [eax], 0\n  {4, 0x89, 0x5C, 0x24, 0x0C},              // mov     [esp+0Ch], ebx\n  {4, 0x89, 0x7C, 0x24, 0x08},              // mov     [esp+8], edi\n  {4, 0x89, 0x74, 0x24, 0x04},              // mov     [esp+4], esi\n  {3, 0x8B, 0x4D, 0x08},                    // mov     ecx, [ebp+arg_0]\n  {3, 0x89, 0x0C, 0x24},                    // mov     [esp], ecx\n  {1, 0xE8}, GAP(4),                        // call    _main\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; int\n  {1, 0xE8}, GAP(4),                        // call    _exit\n};\n\nstatic AsmFootPrint const SDK104Target104X86_64 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {3, 0x48, 0x89, 0xE5},                    // mov     rbp, rsp\n  {4, 0x48, 0x83, 0xE4, 0xF0},              // and     rsp, 0FFFFFFFFFFFFFFF0h\n  {4, 0x48, 0x8B, 0x7D, 0x08},              // mov     rdi, [rbp+8]\n  {4, 0x48, 0x8D, 0x75, 0x10},              // lea     rsi, [rbp+10h]\n  {2, 0x89, 0xFA,},                         // mov     edx, edi\n  {3, 0x83, 0xC2, 0x01},                    // add     edx, 1\n  {3, 0xC1, 0xE2, 0x03},                    // shl     edx, 3\n  {3, 0x48, 0x01, 0xF2},                    // add     rdx, rsi\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n\n  //__start\n  {1, 0x55},                                // push    rbp\n  {3, 0x48, 0x89, 0xE5},                    // mov     rbp, rsp\n  {2, 0x41, 0x56},                          // push    r14\n  {2, 0x41, 0x55},                          // push    r13\n  {2, 0x41, 0x54},                          // push    r12\n  {1, 0x53},                                // push    rbx\n  {4, 0x48, 0x83, 0xEC, 0x10},              // sub     rsp, 10h\n  {3, 0x41, 0x89, 0xFE},                    // mov     r14d, edi\n  {3, 0x49, 0x89, 0xF4},                    // mov     r12, rsi\n  {3, 0x48, 0x89, 0xD3},                    // mov     rbx, rdx\n  {2, 0x89, 0x3D}, GAP(4),                  // mov     cs:_NXArgc, edi\n  {3, 0x48, 0x89, 0x35}, GAP(4),            // mov     cs:_NXArgv, rsi\n  {3, 0x48, 0x89, 0x15}, GAP(4),            // mov     cs:_environ, rdx\n  {3, 0x48, 0x8B, 0x0E},                    // mov     rcx, [rsi]\n  {3, 0x48, 0x85, 0xC9},                    // test    rcx, rcx\n  {2, 0x75, 0x09},                          // jnz     short loc_5F\n  {3, 0x48, 0x8D, 0x0D}, GAP(4),            // lea     rcx, byte_180\n  {2, 0xEB, 0x1D},                          // jmp     short loc_7C\n  // ---------------------------------------------------------------------------\n\n  // loc_5F\n  {3, 0x48, 0x89, 0xCA},                    // mov     rdx, rcx\n  {2, 0xEB, 0x11},                          // jmp     short loc_75\n  // ---------------------------------------------------------------------------\n\n  // loc_64\n  {2, 0x3C, 0x2F},                          // cmp     al, 2Fh ; '/'\n  {2, 0x74, 0x06},                          // jz      short loc_6E\n  {4, 0x48, 0x83, 0xC2, 0x01},              // add     rdx, 1\n  {2, 0xEB, 0x07},                          // jmp     short loc_75\n  // ---------------------------------------------------------------------------\n\n  // loc_6E\n  {4, 0x48, 0x83, 0xC2, 0x01},              // add     rdx, 1\n  {3, 0x48, 0x89, 0xD1},                    // mov     rcx, rdx\n\n  // loc_75\n  {3, 0x0F, 0xB6, 0x02},                    // movzx   eax, byte ptr [rdx]\n  {2, 0x84, 0xC0},                          // test    al, al\n  {2, 0x75, 0xE8},                          // jnz     short loc_64\n\n  // loc_7C\n  {3, 0x48, 0x89, 0x0D}, GAP(4),            // mov     cs:___progname, rcx\n  {3, 0x48, 0x89, 0xD8},                    // mov     rax, rbx\n  {2, 0xEB, 0x04},                          // jmp     short loc_8C\n  // ---------------------------------------------------------------------------\n\n  // loc_88\n  {4, 0x48, 0x83, 0xC0, 0x08},              // add     rax, 8\n\n  // loc_8C\n  {4, 0x48, 0x83, 0x38, 0x00},              // cmp     qword ptr [rax], 0\n  {2, 0x75, 0xF6},                          // jnz     short loc_88\n  {4, 0x4C, 0x8D, 0x68, 0x08},              // lea     r13, [rax+8]\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:_mach_init_routine\n  {3, 0x48, 0x8B, 0x00},                    // mov     rax, [rax]\n  {3, 0x48, 0x85, 0xC0},                    // test    rax, rax\n  {2, 0x74, 0x02},                          // jz      short loc_A7\n  {2, 0xFF, 0xD0},                          // call    rax\n\n  // loc_A7\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:__cthread_init_routine\n  {3, 0x48, 0x8B, 0x00},                    // mov     rax, [rax]\n  {3, 0x48, 0x85, 0xC0},                    // test    rax, rax\n  {2, 0x74, 0x02},                          // jz      short loc_B8\n  {2, 0xFF, 0xD0},                          // call    rax\n\n  // loc_B8\n  {1, 0xE8}, GAP(4),                        // call    near ptr ___keymgr_dwarf2_register_sections\n  {4, 0x48, 0x8D, 0x75, 0xD0},              // lea     rsi, [rbp+var_30]\n  {3, 0x48, 0x8D, 0x3D}, GAP(4),            // lea     rdi, a__dyld_make_de ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xD0},                    // call    [rbp+var_30]\n  {4, 0x48, 0x8D, 0x75, 0xD8},              // lea     rsi, [rbp+var_28]\n  {3, 0x48, 0x8D, 0x3D}, GAP(4),            // lea     rdi, a__dyld_mod_ter ; \"__dyld_mod_term_funcs\"\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {4, 0x48, 0x8B, 0x7D, 0xD8},              // mov     rdi, [rbp+var_28]\n  {3, 0x48, 0x85, 0xFF},                    // test    rdi, rdi\n  {2, 0x74, 0x05},                          // jz      short loc_EE\n  {1, 0xE8}, GAP(4),                        // call    near ptr _atexit\n\n  // loc_EE\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:_errno\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [rax], 0\n  {3, 0x4C, 0x89, 0xE9},                    // mov     rcx, r13\n  {3, 0x48, 0x89, 0xDA},                    // mov     rdx, rbx\n  {3, 0x4C, 0x89, 0xE6},                    // mov     rsi, r12\n  {3, 0x44, 0x89, 0xF7},                    // mov     edi, r14d\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {2, 0x89, 0xC7},                          // mov     edi, eax\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit\n};\n\n\n//==================================\n// SDK:10.5 DeployTarget:10.4\n// MacOSX10.5.sdk/usr/lib/crt1.o\n//==================================\nstatic AsmFootPrint const SDK105Target104X86 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4, 0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC, 0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D, 0x04},                    // mov     ebx, [ebp+4]\n  {4, 0x89, 0x5C, 0x24, 0x00},              // mov     [esp+14h+var_14], ebx\n  {3, 0x8D, 0x4D, 0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C, 0x24, 0x04},              // mov     [esp+14h+var_10], ecx\n  {3, 0x83, 0xC3, 0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3, 0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+14h+var_C], ebx\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n  \n  //__start:\n  {1, 0x55},                                // push    ebp\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {1, 0x57},                                // push    edi\n  {1, 0x56},                                // push    esi\n  {1, 0x53},                                // push    ebx\n  {3, 0x83, 0xEC, 0x2C},                    // sub     esp, 2Ch\n  {3, 0x8B, 0x75, 0x0C},                    // mov     esi, [ebp+arg_4]\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {3, 0x8B, 0x5D, 0x10},                    // mov     ebx, [ebp+arg_8]\n  {2, 0x89, 0x35}, GAP(4),                  // mov     ds:_NXArgv, esi\n  {1, 0xA3}, GAP(4),                        // mov     ds:_NXArgc, eax\n  {2, 0x89, 0x1D}, GAP(4),                  // mov     ds:_environ, ebx\n  {2, 0x8B, 0x0E},                          // mov     ecx, [esi]\n  {2, 0x85, 0xC9},                          // test    ecx, ecx\n  {3, 0x8D, 0x41, 0x01},                    // lea     eax, [ecx+1]\n  {2, 0x75, 0x0E},                          // jnz     short loc_64\n  {1, 0xB9}, GAP(4),                        // mov     ecx, offset byte_118\n  {2, 0xEB, 0x0F},                          // jmp     short loc_6C\n  // ---------------------------------------------------------------------------\n  \n  //loc_5D:\n  {3, 0x80, 0xFA, 0x2F},                    // cmp     dl, 2Fh ; '/'\n  {3, 0x0F, 0x44, 0xC8},                    // cmovz   ecx, eax\n  {1, 0x40},                                // inc     eax\n  \n  //loc_64:\n  {4, 0x0F, 0xB6, 0x50, 0xFF},              // movzx   edx, byte ptr [eax-1]\n  {2, 0x84, 0xD2},                          // test    dl, dl\n  {2, 0x75, 0xF1},                          // jnz     short loc_5D\n  \n  //loc_6C:\n  {2, 0x89, 0xD8},                          // mov     eax, ebx\n  {2, 0x89, 0x0D}, GAP(4),                  // mov     ds:___progname, ecx\n  {2, 0xEB, 0x03},                          // jmp     short loc_79\n  // ---------------------------------------------------------------------------\n  \n  //loc_76:\n  {3, 0x83, 0xC0, 0x04},                    // add     eax, 4\n  \n  //loc_79:\n  {2, 0x8B, 0x10},                          // mov     edx, [eax]\n  {2, 0x85, 0xD2},                          // test    edx, edx\n  {2, 0x75, 0xF7},                          // jnz     short loc_76\n  {3, 0x8D, 0x78, 0x04},                    // lea     edi, [eax+4]\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_mach_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_8F\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_8F:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:__cthread_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_9C\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_9C:\n  {1, 0xE8}, GAP(4),                        // call    near ptr ___keymgr_dwarf2_register_sections\n  {3, 0x8D, 0x45, 0xE0},                    // lea     eax, [ebp+var_20]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_make_de ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xE0},                    // call    [ebp+var_20]\n  {3, 0x8D, 0x45, 0xE4},                    // lea     eax, [ebp+var_1C]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_mod_ter ; \"__dyld_mod_term_funcs\"\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0x8B, 0x45, 0xE4},                    // mov     eax, [ebp+var_1C]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x08},                          // jz      short loc_D9\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; void (*)(void)\n  {1, 0xE8}, GAP(4),                        // call    near ptr _atexit\n  \n  //loc_D9:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_errno_ptr\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [eax], 0\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {4, 0x89, 0x7C, 0x24, 0x0C},              // mov     [esp+0Ch], edi\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+8], ebx\n  {4, 0x89, 0x74, 0x24, 0x04},              // mov     [esp+4], esi\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; int\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit\n};\n\nstatic AsmFootPrint const SDK105Target104X86_64 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {3, 0x48, 0x89, 0xE5},                    // mov     rbp, rsp\n  {4, 0x48, 0x83, 0xE4, 0xF0},              // and     rsp, 0FFFFFFFFFFFFFFF0h\n  {4, 0x48, 0x8B, 0x7D, 0x08},              // mov     rdi, [rbp+8]\n  {4, 0x48, 0x8D, 0x75, 0x10},              // lea     rsi, [rbp+10h]\n  {2, 0x89, 0xFA},                          // mov     edx, edi\n  {3, 0x83, 0xC2, 0x01},                    // add     edx, 1\n  {3, 0xC1, 0xE2, 0x03},                    // shl     edx, 3\n  {3, 0x48, 0x01, 0xF2},                    // add     rdx, rsi\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n\n  // __start\n  {1, 0x55},                                // push    rbp\n  {3, 0x48, 0x89, 0xE5},                    // mov     rbp, rsp\n  {2, 0x41, 0x56},                          // push    r14\n  {3, 0x41, 0x89, 0xFE},                    // mov     r14d, edi\n  {2, 0x41, 0x55},                          // push    r13\n  {2, 0x41, 0x54},                          // push    r12\n  {3, 0x49, 0x89, 0xF4},                    // mov     r12, rsi\n  {1, 0x53},                                // push    rbx\n  {3, 0x48, 0x89, 0xD3},                    // mov     rbx, rdx\n  {4, 0x48, 0x83, 0xEC, 0x10},              // sub     rsp, 10h\n  {2, 0x89, 0x3D}, GAP(4),                  // mov     cs:_NXArgc, edi\n  {3, 0x48, 0x89, 0x35}, GAP(4),            // mov     cs:_NXArgv, rsi\n  {3, 0x48, 0x89, 0x15}, GAP(4),            // mov     cs:_environ, rdx\n  {3, 0x48, 0x8B, 0x0E},                    // mov     rcx, [rsi]\n  {3, 0x48, 0x85, 0xC9},                    // test    rcx, rcx\n  {4, 0x48, 0x8D, 0x41, 0x01},              // lea     rax, [rcx+1]\n  {2, 0x75, 0x13},                          // jnz     short loc_6D\n  {3, 0x48, 0x8D, 0x0D}, GAP(4),            // lea     rcx, LC0\n  {2, 0xEB, 0x12},                          // jmp     short loc_75\n  // ---------------------------------------------------------------------------\n\n  // loc_63\n  {3, 0x80, 0xFA, 0x2F},                    // cmp     dl, 2Fh ; '/'\n  {4, 0x48, 0x0F, 0x44, 0xC8},              // cmovz   rcx, rax\n  {3, 0x48, 0xFF, 0xC0},                    // inc     rax\n\n  // loc_6D\n  {4, 0x0F, 0xB6, 0x50, 0xFF},              // movzx   edx, byte ptr [rax-1]\n  {2, 0x84, 0xD2},                          // test    dl, dl\n  {2, 0x75, 0xEE},                          // jnz     short loc_63\n\n  // loc_75\n  {3, 0x48, 0x89, 0xD8},                    // mov     rax, rbx\n  {3, 0x48, 0x89, 0x0D}, GAP(4),            // mov     cs:___progname, rcx\n  {2, 0xEB, 0x04},                          // jmp     short loc_85\n  // ---------------------------------------------------------------------------\n\n  // loc_81\n  {4, 0x48, 0x83, 0xC0, 0x08},              // add     rax, 8\n\n  // loc_85\n  {4, 0x48, 0x83, 0x38, 0x00},              // cmp     qword ptr [rax], 0\n  {2, 0x75, 0xF6},                          // jnz     short loc_81\n  {4, 0x4C, 0x8D, 0x68, 0x08},              // lea     r13, [rax+8]\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:_mach_init_routine\n  {3, 0x48, 0x8B, 0x00},                    // mov     rax, [rax]\n  {3, 0x48, 0x85, 0xC0},                    // test    rax, rax\n  {2, 0x74, 0x02},                          // jz      short loc_A0\n  {2, 0xFF, 0xD0},                          // call    rax\n\n  // loc_A0\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:__cthread_init_routine\n  {3, 0x48, 0x8B, 0x00},                    // mov     rax, [rax]\n  {3, 0x48, 0x85, 0xC0},                    // test    rax, rax\n  {2, 0x74, 0x02},                          // jz      short loc_B1\n  {2, 0xFF, 0xD0},                          // call    rax\n\n  // loc_B1\n  {1, 0xE8}, GAP(4),                        // call    near ptr ___keymgr_dwarf2_register_sections\n  {4, 0x48, 0x8D, 0x75, 0xD0},              // lea     rsi, [rbp+var_30]\n  {3, 0x48, 0x8D, 0x3D}, GAP(4),            // lea     rdi, LC1        ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xD0},                    // call    [rbp+var_30]\n  {3, 0x48, 0x8D, 0x3D}, GAP(4),            // lea     rdi, LC2        ; \"__dyld_mod_term_funcs\"\n  {4, 0x48, 0x8D, 0x75, 0xD8},              // lea     rsi, [rbp+var_28]\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {4, 0x48, 0x8B, 0x7D, 0xD8},              // mov     rdi, [rbp+var_28]\n  {3, 0x48, 0x85, 0xFF},                    // test    rdi, rdi\n  {2, 0x74, 0x05},                          // jz      short loc_E7\n  {1, 0xE8}, GAP(4),                        // call    near ptr _atexit\n\n  // loc_E7\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:_errno\n  {3, 0x44, 0x89, 0xF7},                    // mov     edi, r14d\n  {3, 0x4C, 0x89, 0xE9},                    // mov     rcx, r13\n  {3, 0x48, 0x89, 0xDA},                    // mov     rdx, rbx\n  {3, 0x4C, 0x89, 0xE6},                    // mov     rsi, r12\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [rax], 0\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {2, 0x89, 0xC7},                          // mov     edi, eax\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit\n};\n\n\n\n//==================================\n// SDK:10.6 DeployTarget:10.4\n// MacOSX10.6.sdk/usr/lib/crt1.o\n//==================================\nstatic AsmFootPrint const SDK106Target104X86 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4, 0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC, 0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D, 0x04},                    // mov     ebx, [ebp+4]\n  {3, 0x89, 0x1C, 0x24},                    // mov     [esp+14h+var_14], ebx\n  {3, 0x8D, 0x4D, 0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C, 0x24, 0x04},              // mov     [esp+14h+var_10], ecx\n  {3, 0x83, 0xC3, 0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3, 0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+14h+var_C], ebx\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n  \n  //__start:\n  {1, 0x55},                                // push    ebp\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {1, 0x57},                                // push    edi\n  {1, 0x56},                                // push    esi\n  {1, 0x53},                                // push    ebx\n  {3, 0x83, 0xEC, 0x2C},                    // sub     esp, 2Ch\n  {3, 0x8B, 0x7D, 0x0C},                    // mov     edi, [ebp+arg_4]\n  {3, 0x8B, 0x75, 0x10},                    // mov     esi, [ebp+arg_8]\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {1, 0xA3}, GAP(4),                        // mov     ds:_NXArgc, eax\n  {2, 0x89, 0x3D}, GAP(4),                  // mov     ds:_NXArgv, edi\n  {2, 0x89, 0x35}, GAP(4),                  // mov     ds:_environ, esi\n  {2, 0x8B, 0x0F},                          // mov     ecx, [edi]\n  {3, 0x8D, 0x51, 0x01},                    // lea     edx, [ecx+1]\n  {2, 0x85, 0xC9},                          // test    ecx, ecx\n  {2, 0x75, 0x0D},                          // jnz     short loc_62\n  {1, 0xB9}, GAP(4),                        // mov     ecx, offset byte_118\n  {2, 0xEB, 0x0E},                          // jmp     short loc_6A\n  // ---------------------------------------------------------------------------\n  \n  //loc_5C:\n  {2, 0x3C, 0x2F},                          // cmp     al, 2Fh ; '/'\n  {3, 0x0F, 0x44, 0xCA},                    // cmovz   ecx, edx\n  {1, 0x42},                                // inc     edx\n  \n  //loc_62:\n  {4, 0x0F, 0xB6, 0x42, 0xFF},              // movzx   eax, byte ptr [edx-1]\n  {2, 0x84, 0xC0},                          // test    al, al\n  {2, 0x75, 0xF2},                          // jnz     short loc_5C\n  \n  //loc_6A:\n  {2, 0x89, 0x0D}, GAP(4),                  // mov     ds:___progname, ecx\n  {2, 0x89, 0xF3},                          // mov     ebx, esi\n  {2, 0xEB, 0x03},                          // jmp     short loc_77\n  // ---------------------------------------------------------------------------\n  \n  //loc_74:\n  {3, 0x83, 0xC3, 0x04},                    // add     ebx, 4\n  \n  //loc_77:\n  {2, 0x8B, 0x03},                          // mov     eax, [ebx]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x75, 0xF7},                          // jnz     short loc_74\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_mach_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_8A\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_8A:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:__cthread_init_routine_ptr\n  {2, 0x8B, 0x00},                          // mov     eax, [eax]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x02},                          // jz      short loc_97\n  {2, 0xFF, 0xD0},                          // call    eax\n  \n  //loc_97:\n  {1, 0xE8}, GAP(4),                        // call    near ptr ___keymgr_dwarf2_register_sections\n  {3, 0x8D, 0x45, 0xE0},                    // lea     eax, [ebp+var_20]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_make_de ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xE0},                    // call    [ebp+var_20]\n  {3, 0x8D, 0x45, 0xE4},                    // lea     eax, [ebp+var_1C]\n  {4, 0x89, 0x44, 0x24, 0x04},              // mov     [esp+4], eax\n  {3, 0xC7, 0x04, 0x24}, GAP(4),            // mov     dword ptr [esp], offset a__dyld_mod_ter ; \"__dyld_mod_term_funcs\"\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0x8B, 0x45, 0xE4},                    // mov     eax, [ebp+var_1C]\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x74, 0x08},                          // jz      short loc_D4\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; void (*)(void)\n  {1, 0xE8}, GAP(4),                        // call    near ptr _atexit\n  \n  //loc_D4:\n  {1, 0xA1}, GAP(4),                        // mov     eax, ds:_errno_ptr\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [eax], 0\n  {3, 0x8D, 0x43, 0x04},                    // lea     eax, [ebx+4]\n  {4, 0x89, 0x44, 0x24, 0x0C},              // mov     [esp+0Ch], eax\n  {4, 0x89, 0x74, 0x24, 0x08},              // mov     [esp+8], esi\n  {4, 0x89, 0x7C, 0x24, 0x04},              // mov     [esp+4], edi\n  {3, 0x8B, 0x45, 0x08},                    // mov     eax, [ebp+arg_0]\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp], eax      ; int\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit\n};\n\nstatic AsmFootPrint const SDK106Target104X86_64 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {3, 0x48, 0x89, 0xE5},                    // mov     rbp, rsp\n  {4, 0x48, 0x83, 0xE4, 0xF0},              // and     rsp, 0FFFFFFFFFFFFFFF0h\n  {4, 0x48, 0x8B, 0x7D, 0x08},              // mov     rdi, [rbp+8]\n  {4, 0x48, 0x8D, 0x75, 0x10},              // lea     rsi, [rbp+10h]\n  {2, 0x89, 0xFA},                          // mov     edx, edi\n  {3, 0x83, 0xC2, 0x01},                    // add     edx, 1\n  {3, 0xC1, 0xE2, 0x03},                    // shl     edx, 3\n  {3, 0x48, 0x01, 0xF2},                    // add     rdx, rsi\n  {5, 0xE8, 0x01, 0x00, 0x00, 0x00},        // call    __start\n  {1, 0xF4},                                // hlt\n\n  // __start\n  {1, 0x55},                                // push    rbp\n  {3, 0x48, 0x89, 0xE5},                    // mov     rbp, rsp\n  {2, 0x41, 0x56},                          // push    r14\n  {2, 0x41, 0x55},                          // push    r13\n  {2, 0x41, 0x54},                          // push    r12\n  {1, 0x53},                                // push    rbx\n  {4, 0x48, 0x83, 0xEC, 0x10},              // sub     rsp, 10h\n  {3, 0x41, 0x89, 0xFE},                    // mov     r14d, edi\n  {3, 0x49, 0x89, 0xF5},                    // mov     r13, rsi\n  {3, 0x49, 0x89, 0xD4},                    // mov     r12, rdx\n  {2, 0x89, 0x3D}, GAP(4),                  // mov     cs:_NXArgc, edi\n  {3, 0x48, 0x89, 0x35}, GAP(4),            // mov     cs:_NXArgv, rsi\n  {3, 0x48, 0x89, 0x15}, GAP(4),            // mov     cs:_environ, rdx\n  {3, 0x48, 0x8B, 0x0E},                    // mov     rcx, [rsi]\n  {4, 0x48, 0x8D, 0x41, 0x01},              // lea     rax, [rcx+1]\n  {3, 0x48, 0x85, 0xC9},                    // test    rcx, rcx\n  {2, 0x75, 0x13},                          // jnz     short loc_6D\n  {3, 0x48, 0x8D, 0x0D}, GAP(4),            // lea     rcx, LC0\n  {2, 0xEB, 0x12},                          // jmp     short loc_75\n  // ---------------------------------------------------------------------------\n\n  // loc_63\n  {3, 0x80, 0xFA, 0x2F},                    // cmp     dl, 2Fh ; '/'\n  {4, 0x48, 0x0F, 0x44, 0xC8},              // cmovz   rcx, rax\n  {3, 0x48, 0xFF, 0xC0},                    // inc     rax\n\n  // loc_6D\n  {4, 0x0F, 0xB6, 0x50, 0xFF},              // movzx   edx, byte ptr [rax-1]\n  {2, 0x84, 0xD2},                          // test    dl, dl\n  {2, 0x75, 0xEE},                          // jnz     short loc_63\n\n  // loc_75\n  {3, 0x48, 0x89, 0x0D}, GAP(4),            // mov     cs:___progname, rcx\n  {3, 0x4C, 0x89, 0xE3},                    // mov     rbx, r12\n  {2, 0xEB, 0x04},                          // jmp     short loc_85\n  // ---------------------------------------------------------------------------\n\n  // loc_81\n  {4, 0x48, 0x83, 0xC3, 0x08},              // add     rbx, 8\n\n  // loc_85\n  {4, 0x48, 0x83, 0x3B, 0x00},              // cmp     qword ptr [rbx], 0\n  {2, 0x75, 0xF6},                          // jnz     short loc_81\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:_mach_init_routine\n  {3, 0x48, 0x8B, 0x00},                    // mov     rax, [rax]\n  {3, 0x48, 0x85, 0xC0},                    // test    rax, rax\n  {2, 0x74, 0x02},                          // jz      short loc_9C\n  {2, 0xFF, 0xD0},                          // call    rax\n\n  // loc_9C\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:__cthread_init_routine\n  {3, 0x48, 0x8B, 0x00},                    // mov     rax, [rax]\n  {3, 0x48, 0x85, 0xC0},                    // test    rax, rax\n  {2, 0x74, 0x02},                          // jz      short loc_AD\n  {2, 0xFF, 0xD0},                          // call    rax\n\n  // loc_AD\n  {1, 0xE8}, GAP(4),                        // call    near ptr ___keymgr_dwarf2_register_sections\n  {4, 0x48, 0x8D, 0x75, 0xD0},              // lea     rsi, [rbp+var_30]\n  {3, 0x48, 0x8D, 0x3D}, GAP(4),            // lea     rdi, LC1        ; \"__dyld_make_delayed_module_initializer_\"...\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {3, 0xFF, 0x55, 0xD0},                    // call    [rbp+var_30]\n  {4, 0x48, 0x8D, 0x75, 0xD8},              // lea     rsi, [rbp+var_28]\n  {3, 0x48, 0x8D, 0x3D}, GAP(4),            // lea     rdi, LC2        ; \"__dyld_mod_term_funcs\"\n  {1, 0xE8}, GAP(4),                        // call    __dyld_func_lookup\n  {4, 0x48, 0x8B, 0x7D, 0xD8},              // mov     rdi, [rbp+var_28]\n  {3, 0x48, 0x85, 0xFF},                    // test    rdi, rdi\n  {2, 0x74, 0x05},                          // jz      short loc_E3\n  {1, 0xE8}, GAP(4),                        // call    near ptr _atexit\n\n  // loc_E3\n  {3, 0x48, 0x8B, 0x05}, GAP(4),            // mov     rax, cs:_errno\n  {6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00},  // mov     dword ptr [rax], 0\n  {4, 0x48, 0x8D, 0x4B, 0x08},              // lea     rcx, [rbx+8]\n  {3, 0x4C, 0x89, 0xE2},                    // mov     rdx, r12\n  {3, 0x4C, 0x89, 0xEE},                    // mov     rsi, r13\n  {3, 0x44, 0x89, 0xF7},                    // mov     edi, r14d\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {2, 0x89, 0xC7},                          // mov     edi, eax\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit\n};\n\n//==================================\n// SDK:10.5 DeployTarget:10.5\n// MacOSX10.5.sdk/usr/lib/crt1.10.5.o\n//==================================\nstatic AsmFootPrint const SDK105Target105X86 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4, 0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC, 0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D, 0x04},                    // mov     ebx, [ebp+4]\n  {4, 0x89, 0x5C, 0x24, 0x00},              // mov     [esp+14h+var_14], ebx\n  {3, 0x8D, 0x4D, 0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C, 0x24, 0x04},              // mov     [esp+14h+var_10], ecx\n  {3, 0x83, 0xC3, 0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3, 0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+14h+var_C], ebx\n  \n  //loc_24:\n  {2, 0x8B, 0x03},                          // mov     eax, [ebx]\n  {3, 0x83, 0xC3, 0x04},                    // add     ebx, 4\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x75, 0xF7},                          // jnz     short loc_24\n  {4, 0x89, 0x5C, 0x24, 0x0C},              // mov     [esp+14h+var_8], ebx\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {4, 0x89, 0x44, 0x24, 0x00},              // mov     [esp+14h+var_14], eax ; int\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit\n};\n\nstatic AsmFootPrint const SDK105Target105X86_64 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {3, 0x48, 0x89, 0xE5},                    // mov     rbp, rsp\n  {4, 0x48, 0x83, 0xE4, 0xF0},              // and     rsp, 0FFFFFFFFFFFFFFF0h\n  {4, 0x48, 0x8B, 0x7D, 0x08},              // mov     rdi, [rbp+8]\n  {4, 0x48, 0x8D, 0x75, 0x10},              // lea     rsi, [rbp+10h]\n  {2, 0x89, 0xFA},                          // mov     edx, edi\n  {3, 0x83, 0xC2, 0x01},                    // add     edx, 1\n  {3, 0xC1, 0xE2, 0x03},                    // shl     edx, 3\n  {3, 0x48, 0x01, 0xF2},                    // add     rdx, rsi\n  {3, 0x48, 0x89, 0xD1},                    // mov     rcx, rdx\n  {2, 0xEB, 0x04},                          // jmp     short loc_25\n  // ---------------------------------------------------------------------------\n\n  // loc_21\n  {4, 0x48, 0x83, 0xC1, 0x08},              // add     rcx, 8\n\n  // loc_25\n  {4, 0x48, 0x83, 0x39, 0x00},              // cmp     qword ptr [rcx], 0\n  {2, 0x75, 0xF6},                          // jnz     short loc_21\n  {4, 0x48, 0x83, 0xC1, 0x08},              // add     rcx, 8\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {2, 0x89, 0xC7},                          // mov     edi, eax\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit  \n};\n  \n//==================================\n// SDK:10.6 DeployTarget:10.5\n// MacOSX10.6.sdk/usr/lib/crt1.10.5.o\n//==================================\nstatic AsmFootPrint const SDK106Target105X86 =\n{\n  //start:\n  {2, 0x6A, 0x00},                          // push    0\n  {2, 0x89, 0xE5},                          // mov     ebp, esp\n  {3, 0x83, 0xE4, 0xF0},                    // and     esp, 0FFFFFFF0h\n  {3, 0x83, 0xEC, 0x10},                    // sub     esp, 10h\n  {3, 0x8B, 0x5D, 0x04},                    // mov     ebx, [ebp+4]\n  {3, 0x89, 0x1C, 0x24},                    // mov     [esp+14h+var_14], ebx\n  {3, 0x8D, 0x4D, 0x08},                    // lea     ecx, [ebp+8]\n  {4, 0x89, 0x4C, 0x24, 0x04},              // mov     [esp+14h+var_10], ecx\n  {3, 0x83, 0xC3, 0x01},                    // add     ebx, 1\n  {3, 0xC1, 0xE3, 0x02},                    // shl     ebx, 2\n  {2, 0x01, 0xCB},                          // add     ebx, ecx\n  {4, 0x89, 0x5C, 0x24, 0x08},              // mov     [esp+14h+var_C], ebx\n  \n  //loc_23:\n  {2, 0x8B, 0x03},                          // mov     eax, [ebx]\n  {3, 0x83, 0xC3,0x04},                     // add     ebx, 4\n  {2, 0x85, 0xC0},                          // test    eax, eax\n  {2, 0x75, 0xF7},                          // jnz     short loc_23\n  {4, 0x89, 0x5C, 0x24, 0x0C},              // mov     [esp+14h+var_8], ebx\n  {1, 0xE8}, GAP(4),                        // call    near ptr _main\n  {3, 0x89, 0x04, 0x24},                    // mov     [esp+14h+var_14], eax ; int\n  {1, 0xE8}, GAP(4),                        // call    near ptr _exit\n};\n\nstatic AsmFootPrint const SDK106Target104X86v2 =\n{\n  //start:\n  {2,  0x6A, 0x00},                         // push    0\n  {2,  0x89, 0xE5},                         // mov     ebp, esp\n  {3,  0x83, 0xE4, 0xF0},                   // and     esp, 0FFFFFFF0h\n  {3,  0x83, 0xEC, 0x10},                   // sub     esp, 10h\n  {3,  0x8B, 0x5D, 0x04},                   // mov     ebx, [ebp+4]\n  {3,  0x89, 0x1C, 0x24},                   // mov     [esp+14h+var_14], ebx\n  {3,  0x8D, 0x4D, 0x08},                   // lea     ecx, [ebp+8]\n  {4,  0x89, 0x4C, 0x24, 0x04},             // mov     [esp+14h+var_10], ecx\n  {3,  0x83, 0xC3, 0x01},                   // add     ebx, 1\n  {3,  0xC1, 0xE3, 0x02},                   // shl     ebx, 2\n  {2,  0x01, 0xCB},                         // add     ebx, ecx\n  {4,  0x89, 0x5C, 0x24, 0x08},             // mov     [esp+14h+var_C], ebx\n  {5,  0xE8, 0x01, 0x00, 0x00, 0x00},       // call    __start\n  {1,  0xF4},                               // hlt\n  \n  //__start:\n  {1,  0x55},                               // push    ebp\n  {2,  0x89, 0xE5},                         // mov     ebp, esp\n  {1,  0x53},                               // push    ebx\n  {1,  0x57},                               // push    edi\n  {1,  0x56},                               // push    esi\n  {3,  0x83, 0xEC, 0x1C},                   // sub     esp, 1Ch\n  {3,  0x8B, 0x45, 0x08},                   // mov     eax, [ebp+arg_0]\n  {1,  0xA3}, GAP(4),                       // mov     ds:_NXArgc, eax\n  {3,  0x8B, 0x7D, 0x0C},                   // mov     edi, [ebp+arg_4]\n  {2,  0x89, 0x3D}, GAP(4),                 // mov     ds:_NXArgv, edi\n  {3,  0x8B, 0x75, 0x10},                   // mov     esi, [ebp+arg_8]\n  {2,  0x89, 0x35}, GAP(4),                 // mov     ds:_environ, esi\n  {2,  0x8B, 0x07},                         // mov     eax, [edi]\n  {1,  0xB9}, GAP(4),                       // mov     ecx, offset byte_199DAE\n  {2,  0x85, 0xC0},                         // test    eax, eax\n  {2,  0x74, 0x18},                         // jz      short loc_2B8F\n  {2,  0xEB, 0x02},                         // jmp     short loc_2B7B\n  \n  // loc_2B79\n  {2,  0x89, 0xC8},                         // mov     eax, ecx\n  \n  // loc_2B7B:\n  {3,  0x8D, 0x48, 0x01},                   // lea     ecx, [eax+1]\n  {2,  0xEB, 0x06},                         // jmp     short loc_2B86\n  \n  // loc_2BB0:\n  {3,  0x80, 0xFA, 0x2F},                   // cmp     dl, 2Fh\n  {2,  0x74, 0xF4},                         // jz      short loc_2B79\n  {1,  0x41},                               // inc     ecx\n  \n  // loc_2B86:\n  {3,  0x8A, 0x51, 0xFF},                   // mov     dl, [ecx-1]\n  {2,  0x84, 0xD2},                         // test    dl, dl\n  {2,  0x75, 0xF3},                         // jnz     short loc_2B80\n  {2,  0x89, 0xC1},                         // mov     ecx, eax\n  \n  // loc_2B8F:\n  {2,  0x89, 0x0D}, GAP(4),                 // mov     ds:___progname, ecx\n  {2,  0x89, 0xF3},                         // mov     ebx, esi\n  \n  // loc_2B97:\n  {3,  0x83, 0x3B, 0x00},                   // cmp     dword ptr [ebx], 0\n  {3,  0x8D, 0x5B, 0x04},                   // lea     ebx, [ebx+4]\n  {2,  0x75, 0xF8},                         // jnz     short loc_2B97\n  {1,  0xA1}, GAP(4),                       // mov     eax, ds:_mach_init_routine_ptr\n  {2,  0x8B, 0x00},                         // mov     eax, [eax]\n  {2,  0x85, 0xC0},                         // test    eax, eax\n  {2,  0x74, 0x02},                         // jz      short loc_2BAC\n  {2,  0xFF, 0xD0},                         // call    eax\n  \n  // loc_2BAC:\n  {1,  0xA1}, GAP(4),                       // mov     eax, ds:__cthread_init_routine_ptr\n  {2,  0x8B, 0x00},                         // mov     eax, [eax]\n  {2,  0x85, 0xC0},                         // test    eax, eax\n  {2,  0x74, 0x02},                         // jz      short loc_2BB9\n  {2,  0xFF, 0xD0},                         // call    eax\n  \n  // loc_2BB9:\n  {1,  0xE8}, GAP(4),                       // call    ___keymgr_dwarf2_register_sections\n  {3,  0x8D, 0x45, 0xEC},                   // lea     eax, [ebp+var_14]\n  {4,  0x89, 0x44, 0x24, 0x04},             // mov     [esp+4], eax\n  {3,  0xC7, 0x04, 0x24}, GAP(4),           // mov     dword ptr [esp], offset a__dyld_make_de ; \"__dyld_make_delayed_module_initializer_\"...\n  {1,  0xE8}, GAP(4),                       // call    __dyld_func_lookup\n  {3,  0xFF, 0x55, 0xEC},                   // call    [ebp+var_14]\n  {3,  0x8D, 0x45, 0xF0},                   // lea     eax, [ebp+var_10]\n  {4,  0x89, 0x44, 0x24, 0x04},             // mov     [esp+4], eax\n  {3,  0xC7, 0x04, 0x24}, GAP(4),           // mov     dword ptr [esp], offset a__dyld_mod_ter ; \"__dyld_mod_term_funcs\"\n  {1,  0xE8}, GAP(4),                       // call    __dyld_func_lookup\n  {3,  0x8B, 0x45, 0xF0},                   // mov     eax, [ebp+var_10]\n  {2,  0x85, 0xC0},                         // test    eax, eax\n  {2,  0x74, 0x08},                         // jz      short loc_2BF6\n  {3,  0x89, 0x04, 0x24},                   // mov     [esp], eax      ; void (*)(void)\n  {1,  0xE8}, GAP(4),                       // call    _atexit\n  \n  // loc_2BF6:\n  {1,  0xA1}, GAP(4),                       // mov     eax, ds:_errno_ptr\n  {6,  0xC7, 0x00, 0x00, 0x00, 0x00, 0x00}, // mov     dword ptr [eax], 0\n  {4,  0x89, 0x5C, 0x24, 0x0C},             // mov     [esp+0Ch], ebx\n  {4,  0x89, 0x74, 0x24, 0x08},             // mov     [esp+8], esi\n  {4,  0x89, 0x7C, 0x24, 0x04},             // mov     [esp+4], edi\n  {3,  0x8B, 0x45, 0x08},                   // mov     eax, [ebp+arg_0]\n  {3,  0x89, 0x04, 0x24},                   // mov     [esp], eax\n  {1,  0xE8}, GAP(4),                       // call    _main\n  {3,  0x89, 0x04, 0x24},                   // mov     [esp], eax      ; int\n  {1,  0xE8}, GAP(4),                       // call    _exit\n};\n\nstatic AsmFootPrint const SDK109Target104X86 = {\n  // start\n  { 2, 0x6A, 0x00 },                          // push    0\n  { 2, 0x89, 0xE5 },                          // mov     ebp, esp\n  { 3, 0x83, 0xE4, 0xF0 },                    // and     esp, 0FFFFFFF0h\n  { 3, 0x83, 0xEC, 0x10 },                    // sub     esp, 10h\n  { 3, 0x8B, 0x5D, 0x04 },                    // mov     ebx, [ebp+4]\n  { 3, 0x89, 0x1C, 0x24 },                    // mov     [esp+14h+var_14], ebx\n  { 3, 0x8D, 0x4D, 0x08 },                    // lea     ecx, [ebp+8]\n  { 4, 0x89, 0x4C, 0x24, 0x04 },              // mov     [esp+14h+var_10], ecx\n  { 3, 0x83, 0xC3, 0x01 },                    // add     ebx, 1\n  { 3, 0xC1, 0xE3, 0x02 },                    // shl     ebx, 2\n  { 2, 0x01, 0xCB },                          // add     ebx, ecx\n  { 4, 0x89, 0x5C, 0x24, 0x08 },              // mov     [esp+14h+var_C], ebx\n  { 5, 0xE8, 0x01, 0x00, 0x00, 0x00 },        // call    __start\n  { 1, 0xF4 },                                // hlt\n  \n  // __start\n  { 1, 0x55 },                                // push    ebp\n  { 2, 0x89, 0xE5 },                          // mov     ebp, esp\n  { 1, 0x53 },                                // push    ebx\n  { 1, 0x57 },                                // push    edi\n  { 1, 0x56 },                                // push    esi\n  { 3, 0x83, 0xEC, 0x1C },                    // sub     esp, 1Ch\n  { 3, 0x8B, 0x45, 0x08 },                    // mov     eax, [ebp+arg_\n  { 1, 0xA3 }, GAP(4),                        // mov     ds:_NXArgc, eax\n  { 3, 0x8B, 0x7D, 0x0C },                    // mov     edi, [ebp+arg_4]\n  { 2, 0x89, 0x3D }, GAP(4),                  // mov     ds:_NXArgv, edi\n  { 3, 0x8B, 0x75, 0x10 },                    // mov     esi, [ebp+arg_8]\n  { 2, 0x89, 0x35 }, GAP(4),                  // mov     ds:_environ, esi\n  { 2, 0x8B, 0x07 },                          // mov     eax, [edi]\n  { 1, 0xB9 }, GAP(4),                        // mov     ecx, 12EB30h\n  { 2, 0x85, 0xC0 },                          // test    eax, eax\n  { 2, 0x74, 0x1A },                          // jz      short loc_2551\n  { 2, 0xEB, 0x02 },                          // jmp     short loc_253B\n\n  //  loc_2539: \n  { 2, 0x89, 0xC8 },                          // mov     eax, ecx\n\n  // loc_253B:\n  { 3, 0x8D, 0x48, 0x01 },                    // lea     ecx, [eax+1]\n  { 2, 0xEB, 0x01 },                          // jmp     short loc_2541\n\n  // loc_2540:\n  { 1, 0x41 },                                // inc     ecx\n\n  // loc_2541:\n  { 3, 0x8A, 0x51, 0xFF },                    // mov     dl, [ecx-1]\n  { 2, 0x84, 0xD2 },                          // test    dl, dl\n  { 2, 0x74, 0x07 },                          // jz      short loc_254F\n  { 3, 0x80, 0xFA, 0x2F },                    // cmp     dl, 2Fh\n  { 2, 0x75, 0xF3 },                          // jnz     short loc_2540\n  { 2, 0xEB, 0xEA },                          // jmp     short loc_2539\n\n  // loc_254F:\n  { 3, 0x89, 0xC1, 0x89 },                    // mov     ecx, eax\n\n  // loc_2551:\n  { 1, 0x0D }, GAP(4),                        // mov     ds:___progname, ecx\n  { 2, 0x89, 0xF3 },                          // mov     ebx, esi\n\n  // loc_2559:\n  { 3, 0x83, 0x3B, 0x00 },                    // cmp     dword ptr [ebx], 0\n  { 3, 0x8D, 0x5B, 0x04 },                    // lea     ebx, [ebx+4]\n  { 2, 0x75, 0xF8 },                          // jnz     short loc_2559\n  { 1, 0xA1 }, GAP(4),                        // mov     eax, ds:_mach_init_routine_ptr\n  { 2, 0x8B, 0x00 },                          // mov     eax, [eax]\n  { 2, 0x85, 0xC0 },                          // test    eax, eax\n  { 2, 0x74, 0x02 },                          // jz      short loc_256E\n  { 2, 0xFF, 0xD0 },                          // call    eax\n\n\n  // loc_256E:\n  { 1, 0xA1 }, GAP(4),                        // mov     eax, ds:__cthread_init_routine_ptr                                          \n  { 2, 0x8B, 0x00 },                          // mov     eax, [eax]                                         \n  { 2, 0x85, 0xC0 },                          // test    eax, eax                                         \n  { 2, 0x74, 0x02 },                          // jz      short loc_257B                                         \n  { 2, 0xFF, 0xD0 },                          // call    eax\n\n  // loc_257B:\n  { 1, 0xE8 }, GAP(4),                        // call    ___keymgr_dwarf2_register_sections\n  { 3, 0x8D, 0x45, 0xEC },                    // lea     eax, [ebp+var_14]\n  { 4, 0x89, 0x44, 0x24, 0x04 },              // mov     [esp+4], eax\n  { 3, 0xC7, 0x04, 0x24 }, GAP(4),            // mov     dword ptr [esp], offset a__dyld_make_de ; \n  { 1, 0xE8 }, GAP(4),                        // call    __dyld_func_lookup\n  { 3, 0xFF, 0x55, 0xEC },                    // call    [ebp+var_14]\n  { 3, 0x8D, 0x45, 0xF0 },                    // lea     eax, [ebp+var_10]\n  { 4, 0x89, 0x44, 0x24, 0x04 },              // mov     [esp+4], eax\n  { 3, 0xC7, 0x04, 0x24 }, GAP(4),            // mov     dword ptr [esp], offset a__dyld_mod_ter ; \n  { 1, 0xE8 }, GAP(4),                        // call    __dyld_func_lookup\n  { 3, 0x8B, 0x45, 0xF0 },                    // mov     eax, [ebp+var_10]\n  { 2, 0x85, 0xC0 },                          // test    eax, eax\n  { 2, 0x74, 0x08 },                          // jz      short loc_25B8\n  { 3, 0x89, 0x04, 0x24 },                    // mov     [esp], eax      ; void (*)(void)\n  { 1, 0xE8 }, GAP(4),                        // call    _atexit\n\n  // loc_25B8:\n  { 1, 0xA1 }, GAP(4),                        // mov     eax, ds:_errno_ptr\n  { 6, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00 },  // mov     dword ptr [eax], 0\n  { 4, 0x89, 0x5C, 0x24, 0x0C },              // mov     [esp+0Ch], ebx\n  { 4, 0x89, 0x74, 0x24, 0x08 },              // mov     [esp+8], esi\n  { 4, 0x89, 0x7C, 0x24, 0x04 },              // mov     [esp+4], edi\n  { 3, 0x8B, 0x45, 0x08 },                    // mov     eax, [ebp+arg_0]\n  { 3, 0x89, 0x04, 0x24 },                    // mov     [esp], eax\n  { 1, 0xE8 }, GAP(4),                        // call    _main\n  { 3, 0x89, 0x04, 0x24 },                    // mov     [esp], eax\n  { 1, 0xE8 }, GAP(4)                         // call    _exit\n};\n\n\n// SDK106Target105X86_64 == SDK105Target105X86_64;\n\n//==================================\n// SDK:10.6 DeployTarget:10.6\n// MacOSX10.6.sdk/usr/lib/crt1.10.6.o\n//==================================\n\n//SDK106Target106X86 == SDK106Target105X86;\n//SDK106Target106X86_64 == SDK106Target105X86_64;\n\n//==============================================================================\n@implementation MachOLayout (CRTFootPrints)\n\n//------------------------------------------------------------------------------\n- (bool) matchAsmAtOffset:(uint64_t)offset \n             asmFootPrint:(const AsmFootPrint)footprint \n                lineCount:(NSUInteger)lineCount\n{\n  if (!dataController) // dataController is weak\n    return false;\n  \n  uint8_t const * data = ((uint8_t *)[dataController.fileData bytes]) + offset;\n  \n  for (NSUInteger i = 0; i < lineCount; ++i)\n  {\n    uint8_t const * asmEntry = footprint[i];\n    int size = asmEntry[0];\n    \n    // is it a gap to skip ?\n    if (size == 0)\n    {\n      size = asmEntry[1];\n    }\n    else if (memcmp(data, asmEntry + 1, size))\n    {\n      return false;\n    }\n    data += size;\n  }\n  \n  return true;\n}\n\n//------------------------------------------------------------------------------\n- (void) determineRuntimeVersion\n{\n    if (!dataController) { // dataController is weak\n        return;\n    }\n\n    if (entryPoint == 0) {\n        return; // not an executable, no entry point, or cannot detect\n    }\n\n    // find file offset of the entry point\n    uint64_t offset = [self RVAToFileOffset:entryPoint];\n    NSLog(@\"%@: file offset of OEP: 0x%llX\", self, offset);\n  \n    uint64_t dataLength = [dataController.fileData length];\n  \n    if (offset >= dataLength) {\n        return;\n    }\n  \n  // test against footprints\n  if ([self is64bit] == NO) {\n    if (MATCHASM(SDK104Target104X86v1)) {\n      NSLog(@\"SDK104Target104X86v1 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.4 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK104Target104X86v2)) {\n      NSLog(@\"SDK104Target104X86v2 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.4 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK104Target104X86v3)) {\n      NSLog(@\"SDK104Target104X86v3 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.4 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK104Target104X86v4)) {\n      NSLog(@\"SDK104Target104X86v4 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.4 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK105Target104X86)) {\n      NSLog(@\"SDK105Target104X86 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.5 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK105Target105X86)) {\n      NSLog(@\"SDK105Target105X86 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.5 Target10.5]\"];\n      return;\n    }\n    else if (MATCHASM(SDK106Target104X86) || MATCHASM(SDK106Target104X86v2)) {\n      NSLog(@\"SDK106Target104X86 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.6 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK106Target105X86)) {\n      NSLog(@\"SDK106Target105X86 matched\");\n      \n      for (CommandVector::const_iterator cmdIter = commands.begin(); cmdIter != commands.end(); ++cmdIter) {\n        struct load_command const * load_command = *cmdIter;\n        if (load_command->cmd == LC_DYLD_INFO_ONLY) {\n          rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.6 Target10.6]\"]; \n          NSLog(@\"LC_DYLD_INFO_ONLY  ==> target10.6\");\n          return;\n        }\n      }\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.6 Target10.5]\"];\n      return;\n    }\n    else if (MATCHASM (SDK109Target104X86)) {\n      NSLog(@\"SDK109Target104X86 matched\");\n\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.9 Target10.4]\"];\n      return;\n    }\n  }\n  else {\n    if (MATCHASM(SDK104Target104X86_64)) {\n      NSLog(@\"SDK104Target104X86_64 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.4 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK105Target104X86_64)) {\n      NSLog(@\"SDK105Target104X86_64 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.5 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK106Target104X86_64)) {\n      NSLog(@\"SDK106Target104X86_64 matched\");\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.6 Target10.4]\"];\n      return;\n    }\n    else if (MATCHASM(SDK105Target105X86_64)) {\n      NSLog(@\"SDK105Target105X86_64 matched\");\n      \n      for (CommandVector::const_iterator cmdIter = commands.begin(); cmdIter != commands.end(); ++cmdIter) {\n        struct load_command const * load_command = *cmdIter;\n        if (load_command->cmd == LC_DYLD_INFO_ONLY) {\n          NSLog(@\"LC_DYLD_INFO_ONLY  ==> target10.6\");\n          rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.6]\"]; \n          return;\n        }\n      }\n      rootNode.caption = [rootNode.caption stringByAppendingString:@\" [SDK10.5]\"];\n      return;\n    }\n  }\n}\n//------------------------------------------------------------------------------\n\n@end\n\n"
        },
        {
          "name": "Common.h",
          "type": "blob",
          "size": 0.68359375,
          "content": "/*\n *  Common.h\n *  MachOView\n *\n *  Created by Peter Saghelyi on 10/09/2011.\n *\n */\n\n\n//#define MV_NO_MULTITHREAD\n//#define MV_NO_ARCHIVER\n//#define MV_STATISTICS\n\nextern NSCondition * pipeCondition;\nextern int32_t numIOThread;\nextern int64_t nrow_total;  // number of rows (loaded and empty)\nextern int64_t nrow_loaded; // number of loaded rows\n\n#define NSSTRING(C_STR) [NSString stringWithCString: (char *)(C_STR) encoding: [NSString defaultCStringEncoding]]\n#define CSTRING(NS_STR) [(NS_STR) cStringUsingEncoding: [NSString defaultCStringEncoding]]\n\n#define N_ELEMENTS(ARR)   (sizeof(ARR)/sizeof(*(ARR)))\n#define FIRST_ELEM(ARR)   (&(ARR)[0])\n#define LAST_ELEM(ARR)    (&(ARR)[N_ELEMENTS(ARR)-1])"
        },
        {
          "name": "DataController.h",
          "type": "blob",
          "size": 7.435546875,
          "content": "/*\n *  DataController.h\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#define OFFSET_COLUMN       0\n#define DATA_COLUMN         1   // use this with details\n#define DESCRIPTION_COLUMN  2   // use this with details\n#define VALUE_COLUMN        3\n\n#define DATA_LO_COLUMN      1   // use this with no details\n#define DATA_HI_COLUMN      2   // use this with no details\n\nextern NSString * const MVUnderlineAttributeName;\nextern NSString * const MVCellColorAttributeName;\nextern NSString * const MVTextColorAttributeName;\nextern NSString * const MVMetaDataAttributeName;\n\nextern NSString * const MVLayoutUserInfoKey;\nextern NSString * const MVNodeUserInfoKey;\nextern NSString * const MVStatusUserInfoKey;\n\nextern NSString * const MVDataTreeWillChangeNotification;\nextern NSString * const MVDataTreeDidChangeNotification;\nextern NSString * const MVDataTreeChangedNotification;\nextern NSString * const MVDataTableChangedNotification;\nextern NSString * const MVThreadStateChangedNotification;\n\nextern NSString * const MVStatusTaskStarted;\nextern NSString * const MVStatusTaskTerminated;\n\nstruct MVNodeSaver;\n\n@protocol MVSerializing <NSObject>\n- (void)loadFromFile:(FILE *)pFile;\n- (void)saveToFile:(FILE *)pFile;\n- (void)clear;\n@end\n\n//----------------------------------------------------------------------------\n@interface MVColumns : NSObject\n{\n  NSString *            offsetStr;\n  NSString *            dataStr;\n  NSString *            descriptionStr;\n  NSString *            valueStr;\n}\n\n@property (nonatomic)   NSString * offsetStr;\n@property (nonatomic)   NSString * dataStr;\n@property (nonatomic)   NSString * descriptionStr;\n@property (nonatomic)   NSString * valueStr;\n\n+(MVColumns *) columnsWithData:(NSString *)col0 :(NSString *)col1 :(NSString *)col2 :(NSString *)col3;\n\n@end\n\n//----------------------------------------------------------------------------\n@interface MVRow : NSObject <MVSerializing>\n{\n  MVColumns *          columns;\n  NSDictionary *        attributes;\n  uint64_t              offset;             // for sorting if necessary\n  off_t                 columnsOffset;      // offset of columns\n  off_t                 attributesOffset;   // offset of attribues\n  BOOL                  deleted;\n  BOOL                  dirty;              // eg. attributes has changed\n}\n\n@property (nonatomic)   NSDictionary * attributes;\n@property (nonatomic)   MVColumns * columns;\n@property (nonatomic)   uint64_t offset;\n@property (nonatomic)   BOOL deleted;\n@property (nonatomic)   BOOL dirty;\n\n-(NSString *)columnAtIndex:(NSUInteger)index;\n\n@end\n\n@class MVArchiver;\n\n//----------------------------------------------------------------------------\n@interface MVTable : NSObject\n{\n  NSMutableArray *      rows;         // array of MVRow * (host of all the rows)\n  NSMutableArray *      displayRows;  // array of MVRow * (rows filtered by search criteria)\n  MVArchiver *          __weak archiver;\n  FILE *                swapFile;\n  NSLock *              tableLock;\n}\n\n@property (nonatomic)   FILE * swapFile;\n\n- (NSUInteger)          rowCountToDisplay;\n- (MVRow *)             getRowToDisplay:(NSUInteger)rowIndex;\n\n- (void)                popRow;\n- (void)                appendRow:(id)col0 :(id)col1 :(id)col2 :(id)col3;\n- (void)                insertRowWithOffset:(uint64_t)offset :(id)col0 :(id)col1 :(id)col2 :(id)col3;\n- (void)                updateCellContentTo:(id)object atRow:(NSUInteger)rowIndex andCol:(NSUInteger)colIndex;\n\n- (NSUInteger)          rowCount;\n- (void)                setAttributes:(NSString *)firstArg, ... NS_REQUIRES_NIL_TERMINATION;\n- (void)                setAttributesForRowIndex:(NSUInteger)index :(NSString *)firstArg, ... NS_REQUIRES_NIL_TERMINATION;\n- (void)                setAttributesFromRowIndex:(NSUInteger)index :(NSString *)firstArg, ... NS_REQUIRES_NIL_TERMINATION;\n\n@end\n\n//----------------------------------------------------------------------------\n@interface MVNode : NSObject <MVSerializing>\n{\n  NSString *            caption;\n  MVNode *              __weak parent;\n  NSMutableArray *      children;\n  NSRange               dataRange;\n  MVTable *             details;\n  NSMutableDictionary * userInfo;\n  off_t                 detailsOffset;\n}\n\n@property (nonatomic)                   NSString *            caption;\n@property (nonatomic,weak)      MVNode *              parent;\n@property (nonatomic)                   NSRange               dataRange;\n@property (nonatomic)                   MVTable *             details;\n@property (nonatomic)                   NSMutableDictionary * userInfo;\n@property (nonatomic)                   off_t              detailsOffset;\n\n- (NSUInteger)          numberOfChildren;\n- (MVNode *)            childAtIndex:(NSUInteger)n;\n- (MVNode *)            insertChild:(NSString *)_caption location:(uint64_t)location length:(uint64_t)length;\n- (MVNode *)            insertChildWithDetails:(NSString *)_caption location:(uint64_t)location length:(uint64_t)length saver:(MVNodeSaver &)saver;\n- (MVNode *)            findNodeByUserInfo:(NSDictionary *)uinfo;\n- (void)                openDetails;  // open swap file for reading details on demand\n- (void)                closeDetails; // close swap file\n- (void)                sortDetails;\n- (void)                filterDetails:(NSString *)filter;\n- (void)                loadFromFile:(FILE *)pFile;\n- (void)                saveToFile:(FILE *)pFile;\n\n@end\n\n//----------------------------------------------------------------------------\n@interface MVDataController : NSObject\n{\n  NSString *            fileName;         // path to the binary handled by this data controller\n  NSMutableData *       fileData;         // content of the binary \n  NSMutableData *       realData;         // patched content by relocs and bindings\n  NSMutableArray *      layouts;\n  MVNode *              rootNode;\n  MVNode *              __weak selectedNode;\n  NSLock *              treeLock;         // semaphore for the node tree\n}\n\n@property (nonatomic)                   NSString *      fileName;\n@property (nonatomic)                   NSMutableData * fileData;\n@property (nonatomic)                   NSMutableData * realData;\n@property (nonatomic,readonly)          NSArray *       layouts;\n@property (nonatomic,readonly)          MVNode *        rootNode;\n@property (nonatomic,weak)              MVNode *        selectedNode;\n@property (nonatomic,readonly)          NSLock *        treeLock;\n\n-(NSString *)           getMachine:(cpu_type_t)cputype;\n-(NSString *)           getARMCpu:(cpu_subtype_t)cpusubtype;\n\n- (void)                createLayouts:(MVNode *)parent location:(uint64_t)location length:(uint64_t)length;\n- (void)                updateTreeView: (MVNode *)node;\n- (void)                updateTableView;\n- (void)                updateStatus: (NSString *)status;\n\n@end\n\n//----------------------------------------------------------------------------\n@interface MVArchiver : NSObject\n{\n  NSString *            swapPath;\n  NSMutableArray *      objectsToSave; // conforms MVSerializing\n  NSThread *            saverThread;\n  NSLock *              saverLock;\n}\n\n@property (nonatomic,readonly)  NSString * swapPath;\n\n+(MVArchiver *) archiverWithPath:(NSString *)path;\n-(void) addObjectToSave:(id)object;\n-(void) suspend;\n-(void) resume;\n-(void) halt;\n\n@end\n\n//----------------------------------------------------------------------------\nstruct MVNodeSaver\n{\n  MVNodeSaver();\n  ~MVNodeSaver();\n  \n  void setNode(MVNode * node) { m_node = node; }\n  \nprivate:\n  MVNodeSaver(MVNodeSaver const &);\n  MVNodeSaver & operator=(MVNodeSaver const &);\n  \n  MVNode * __weak m_node;\n};\n\n\n"
        },
        {
          "name": "DataController.mm",
          "type": "blob",
          "size": 42.10546875,
          "content": "/*\n *  DataController.mm\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#import \"Common.h\"\n#import \"DataController.h\"\n#import \"MachOLayout.h\"\n#import \"FatLayout.h\"\n#import \"ArchiveLayout.h\"\n#import <mach-o/loader.h>\n#import <mach-o/fat.h>\n#import <mach-o/swap.h>\n\nenum {\n  MVUnderlineAttributeOrdinal = 1,\n  MVCellColorAttributeOrdinal,\n  MVTextColorAttributeOrdinal,\n  MVMetaDataAttributeOrdinal\n};\n\nenum {\n  MVBlackColorOrdinal = 1,\n  MVDarkGrayColorOrdinal,\n  MVLightGrayColorOrdinal,\n  MVWhiteColorOrdinal,\n  MVGrayColorOrdinal,\n  MVRedColorOrdinal,\n  MVGreenColorOrdinal,\n  MVBlueColorOrdinal,\n  MVCyanColorOrdinal,\n  MVYellowColorOrdinal,\n  MVMagentaColorOrdinal,\n  MVOrangeColorOrdinal,\n  MVPurpleColorOrdinal,\n  MVBrownColorOrdinal\n};\n\nNSString * const MVUnderlineAttributeName         = @\"MVUnderlineAttribute\";\nNSString * const MVCellColorAttributeName         = @\"MVCellColorAttribute\";\nNSString * const MVTextColorAttributeName         = @\"MVTextColorAttribute\";\nNSString * const MVMetaDataAttributeName          = @\"MVMetaDataAttribute\";\n\nNSString * const MVLayoutUserInfoKey              = @\"MVLayoutUserInfoKey\";\nNSString * const MVNodeUserInfoKey                = @\"MVNodeUserInfoKey\";\nNSString * const MVStatusUserInfoKey              = @\"MVStatusUserInfoKey\";\n\nNSString * const MVDataTreeWillChangeNotification = @\"MVDataTreeWillChangeNotification\";\nNSString * const MVDataTreeDidChangeNotification  = @\"MVDataTreeDidChangeNotification\";\nNSString * const MVDataTreeChangedNotification    = @\"MVDataTreeChanged\";\nNSString * const MVDataTableChangedNotification   = @\"MVDataTableChanged\";\nNSString * const MVThreadStateChangedNotification = @\"MVThreadStateChanged\";\n\nNSString * const MVStatusTaskStarted              = @\"MVStatusTaskStarted\";\nNSString * const MVStatusTaskTerminated           = @\"MVStatusTaskTerminated\";\n\n//============================================================================\n@implementation MVColumns\n\n@synthesize offsetStr, dataStr, descriptionStr, valueStr; \n\n//-----------------------------------------------------------------------------\n- (instancetype)init\n{\n  self = [super init];\n  if (self)\n  {\n#ifdef MV_STATISTICS\n    OSAtomicIncrement64(&nrow_loaded);\n#endif\n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n-(id)initWithData:(NSString *)col0 :(NSString *)col1 :(NSString *)col2 :(NSString *)col3\n{\n  if (self = [super init])\n  {\n    offsetStr = col0;\n    dataStr = col1;\n    descriptionStr = col2;\n    valueStr = col3;\n    \n#ifdef MV_STATISTICS\n    OSAtomicIncrement64(&nrow_loaded);\n#endif\n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n+(MVColumns *) columnsWithData:(NSString *)col0 :(NSString *)col1 :(NSString *)col2 :(NSString *)col3\n{\n  return [[MVColumns alloc] initWithData:col0:col1:col2:col3];\n}\n\n//-----------------------------------------------------------------------------\n-(void)dealloc\n{\n#ifdef MV_STATISTICS\n  OSAtomicDecrement64(&nrow_loaded);\n#endif\n}\n\n@end\n\n\n//============================================================================\n@implementation MVRow\n\n@synthesize columns, attributes, offset, deleted, dirty;\n\n//-----------------------------------------------------------------------------\n- (instancetype)init\n{\n  self = [super init];\n  if (self)\n  {\n#ifdef MV_STATISTICS\n    OSAtomicIncrement64(&nrow_total);\n#endif\n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n-(void)dealloc\n{\n#ifdef MV_STATISTICS  \n  OSAtomicDecrement64(&nrow_total);\n#endif\n}\n\n//-----------------------------------------------------------------------------\n-(NSString *)columnAtIndex:(NSUInteger)index\n{\n  switch (index)\n  {\n    case OFFSET_COLUMN:       return columns.offsetStr;\n    case DATA_COLUMN:         return columns.dataStr;\n    case DESCRIPTION_COLUMN:  return columns.descriptionStr;\n    case VALUE_COLUMN:        return columns.valueStr;\n  }\n  return nil;\n}\n\n//-----------------------------------------------------------------------------\n-(void)replaceColumnAtIndex:(NSUInteger)index withString:(NSString *)str\n{\n    columnsOffset = 0;\n    switch (index)\n    {\n        case OFFSET_COLUMN:       columns.offsetStr = str; break;\n        case DATA_COLUMN:         columns.dataStr = str;  break;\n        case DESCRIPTION_COLUMN:  columns.descriptionStr = str; break;\n        case VALUE_COLUMN:        columns.valueStr = str; break;\n    }\n}\n\n//-----------------------------------------------------------------------------\n- (void)writeString:(NSString *)str toFile:(FILE *)pFile\n{\n    if (str) {\n        fwrite(CSTRING(str), [str length] + 1, 1, pFile);\n    } else {\n        fputc('\\0', pFile);\n    }\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)readStringFromFile:(FILE *)pFile\n{\n  std::string s;\n  for(;;) \n  {\n    char c = fgetc(pFile);\n    if (!feof(pFile) && c)\n      s += c;\n    else\n      break;\n  }\n  return NSSTRING(s.c_str()); \n}\n\n//-----------------------------------------------------------------------------\n- (void)writeColor:(NSColor *)color toFile:(FILE *)pFile\n{\n  int colorOrdinal = [color isEqualTo:[NSColor blackColor]]     ? MVBlackColorOrdinal\n                   : [color isEqualTo:[NSColor darkGrayColor]]  ? MVDarkGrayColorOrdinal\n                   : [color isEqualTo:[NSColor lightGrayColor]] ? MVLightGrayColorOrdinal\n                   : [color isEqualTo:[NSColor whiteColor]]     ? MVWhiteColorOrdinal\n                   : [color isEqualTo:[NSColor grayColor]]      ? MVGrayColorOrdinal\n                   : [color isEqualTo:[NSColor redColor]]       ? MVRedColorOrdinal\n                   : [color isEqualTo:[NSColor greenColor]]     ? MVGreenColorOrdinal\n                   : [color isEqualTo:[NSColor blueColor]]      ? MVBlueColorOrdinal\n                   : [color isEqualTo:[NSColor cyanColor]]      ? MVCyanColorOrdinal\n                   : [color isEqualTo:[NSColor yellowColor]]    ? MVYellowColorOrdinal\n                   : [color isEqualTo:[NSColor magentaColor]]   ? MVMagentaColorOrdinal\n                   : [color isEqualTo:[NSColor orangeColor]]    ? MVOrangeColorOrdinal\n                   : [color isEqualTo:[NSColor purpleColor]]    ? MVPurpleColorOrdinal\n                   : [color isEqualTo:[NSColor brownColor]]     ? MVBrownColorOrdinal\n                   : 0;\n  \n  putc(colorOrdinal, pFile);\n  if (colorOrdinal == 0) {\n    CGFloat red, green, blue, alpha;\n    [color getRed:&red green:&green blue:&blue alpha:&alpha];\n    float fred = red, fgreen = green, fblue = blue, falpha = alpha;\n    fwrite(&fred, sizeof(float), 1, pFile);\n    fwrite(&fgreen, sizeof(float), 1, pFile);\n    fwrite(&fblue, sizeof(float), 1, pFile);\n    fwrite(&falpha, sizeof(float), 1, pFile);\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (NSColor *)readColorFromFile:(FILE *)pFile\n{\n  int colorOrdinal = getc(pFile);\n  switch (colorOrdinal)\n  {\n    case MVBlackColorOrdinal:     return [NSColor blackColor];\n    case MVDarkGrayColorOrdinal:  return [NSColor darkGrayColor];\n    case MVLightGrayColorOrdinal: return [NSColor lightGrayColor];\n    case MVWhiteColorOrdinal:     return [NSColor whiteColor];\n    case MVGrayColorOrdinal:      return [NSColor grayColor];\n    case MVRedColorOrdinal:       return [NSColor redColor];\n    case MVGreenColorOrdinal:     return [NSColor greenColor];\n    case MVBlueColorOrdinal:      return [NSColor blueColor];\n    case MVCyanColorOrdinal:      return [NSColor cyanColor];\n    case MVYellowColorOrdinal:    return [NSColor yellowColor];\n    case MVMagentaColorOrdinal:   return [NSColor magentaColor];\n    case MVOrangeColorOrdinal:    return [NSColor orangeColor];\n    case MVPurpleColorOrdinal:    return [NSColor purpleColor];\n    case MVBrownColorOrdinal:     return [NSColor brownColor];\n  }\n\n  float fred, fgreen, fblue, falpha;\n  fread(&fred, sizeof(float), 1, pFile);\n  fread(&fgreen, sizeof(float), 1, pFile);\n  fread(&fblue, sizeof(float), 1, pFile);\n  fread(&falpha, sizeof(float), 1, pFile);\n  return [NSColor colorWithDeviceRed:fred green:fgreen blue:fblue alpha:falpha];\n}\n\n//----------------------------------------------------------------------------\n- (void)saveAttributestoFile:(FILE *)pFile\n{\n    uint64_t numAttributes = [attributes count];\n    if (fwrite (&numAttributes, sizeof(uint64_t), 1, pFile) < 1) {\n        NSLog(@\"fwrite failed in saveAttributestoFile:\");\n        return;\n    }\n  \n  for (NSString * key in [attributes allKeys]) {\n    id value = [attributes objectForKey:key];\n    if (value == nil) {\n      continue;\n    }\n    \n    int keyOrdinal = [key isEqualToString:MVUnderlineAttributeName] ? MVUnderlineAttributeOrdinal \n                   : [key isEqualToString:MVCellColorAttributeName] ? MVCellColorAttributeOrdinal\n                   : [key isEqualToString:MVTextColorAttributeName] ? MVTextColorAttributeOrdinal\n                   : [key isEqualToString:MVMetaDataAttributeName] ? MVMetaDataAttributeOrdinal\n                   : 0;\n\n    putc(keyOrdinal, pFile);\n    switch (keyOrdinal)\n    {\n      case MVUnderlineAttributeOrdinal: [self writeString:value toFile:pFile]; break;\n      case MVCellColorAttributeOrdinal: [self writeColor:value toFile:pFile]; break;\n      case MVTextColorAttributeOrdinal: [self writeColor:value toFile:pFile]; break;\n      case MVMetaDataAttributeOrdinal:  [self writeString:value toFile:pFile]; break;\n      default: NSLog(@\"warning: unknown attribute key\");\n    }\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)loadAttributesFromFile:(FILE *)pFile\n{\n  uint64_t numAttributes;\n  fread(&numAttributes, sizeof(uint64_t), 1, pFile);\n  \n  NSMutableDictionary * _attributes = [[NSMutableDictionary alloc] initWithCapacity:numAttributes];\n  while (numAttributes-- > 0)\n  {\n    int keyOrdinal = getc(pFile);\n    switch (keyOrdinal)\n    {\n      case MVUnderlineAttributeOrdinal: [_attributes setObject:[self readStringFromFile:pFile] forKey:MVUnderlineAttributeName]; break;\n      case MVCellColorAttributeOrdinal: [_attributes setObject:[self readColorFromFile:pFile] forKey:MVCellColorAttributeName]; break;\n      case MVTextColorAttributeOrdinal: [_attributes setObject:[self readColorFromFile:pFile] forKey:MVTextColorAttributeName]; break;\n      case MVMetaDataAttributeOrdinal:  [_attributes setObject:[self readStringFromFile:pFile] forKey:MVMetaDataAttributeName]; break;\n      default: NSLog(@\"warning: unknown attribute key\");\n    }\n  }\n  \n  attributes = _attributes;\n}\n\n//----------------------------------------------------------------------------\n- (void)saveToFile:(FILE *)pFile\n{\n    // dont need to seek, we always append new items\n    if (columnsOffset == 0) { // isSaved == NO\n        off_t filePos = ftello(pFile);\n        if (filePos == -1) {\n            NSLog(@\"MVRow saveToFile: ftello failed: %s\", strerror(errno));\n        }\n        [self writeString:columns.offsetStr toFile:(FILE *)pFile];\n        [self writeString:columns.dataStr toFile:(FILE *)pFile];\n        [self writeString:columns.descriptionStr toFile:(FILE *)pFile];\n        [self writeString:columns.valueStr toFile:(FILE *)pFile];\n        columnsOffset = filePos;\n    }\n  \n    if (dirty) {\n        // reload the attributes if they are out of cache\n        if (attributesOffset > 0) {\n            // import new items\n            NSMutableDictionary * _attributes = [NSMutableDictionary dictionaryWithDictionary:attributes];\n            // load old attributes\n            if (fseeko(pFile, attributesOffset, SEEK_SET) == -1) {\n                NSLog(@\"MVRow saveToFile: fseeko SEEK_SET failed: %s\", strerror(errno));\n            }\n            [self loadAttributesFromFile:pFile];\n            if (fseeko(pFile, 0, SEEK_END) == -1) {\n                NSLog(@\"MVRow saveToFile: fseeko SEEK_END failed: %s\", strerror(errno));\n            }\n            // extend stored attributes with loaded items\n            [_attributes addEntriesFromDictionary:attributes];\n            // store extended attributes\n            attributes = _attributes;\n        }\n    \n        off_t filePos = ftello(pFile);\n        if (filePos == -1) {\n            NSLog(@\"MVRow saveToFile: ftello failed: %s\", strerror(errno));\n        }\n        [self saveAttributestoFile:(FILE *)pFile];\n        dirty = NO;\n        attributesOffset = filePos;\n    }\n}\n\n//----------------------------------------------------------------------------\n- (void)loadFromFile:(FILE *)pFile\n{\n    if (columns == nil) {\n        NSParameterAssert(columnsOffset != 0);\n    \n        if (fseeko(pFile, columnsOffset, SEEK_SET) == 0) {\n            columns = [[MVColumns alloc] init];\n            columns.offsetStr = [self readStringFromFile:pFile];\n            columns.dataStr = [self readStringFromFile:pFile];\n            columns.descriptionStr = [self readStringFromFile:pFile];\n            columns.valueStr = [self readStringFromFile:pFile];\n        } else {\n            NSLog(@\"*** reading error (columns) '%s'\",strerror(errno));\n            NSParameterAssert(0);\n            return;\n        }\n    }\n  \n    if (attributes == nil && attributesOffset > 0) {\n        if (fseeko(pFile, attributesOffset, SEEK_SET) == 0) {\n            [self loadAttributesFromFile:pFile];\n        } else {\n            NSLog(@\"*** reading error (attributes) '%s'\",strerror(errno));\n            NSParameterAssert(0);\n        }\n    }\n}\n\n//----------------------------------------------------------------------------\n- (void)saveIndexToFile:(FILE *)pFile\n{\n  fwrite(&offset, sizeof(uint32_t), 1, pFile);\n  fwrite(&columnsOffset, sizeof(uint32_t), 1, pFile);\n  fwrite(&attributesOffset, sizeof(uint32_t), 1, pFile);\n  fwrite(&deleted, sizeof(BOOL), 1, pFile);\n}\n\n//----------------------------------------------------------------------------\n- (void)loadIndexFromFile:(FILE *)pFile\n{\n  fread(&offset, sizeof(uint32_t), 1, pFile);\n  fread(&columnsOffset, sizeof(uint32_t), 1, pFile);\n  fread(&attributesOffset, sizeof(uint32_t), 1, pFile);\n  fread(&deleted, sizeof(BOOL), 1, pFile);\n}\n\n//----------------------------------------------------------------------------\n-(BOOL) isSaved\n{\n  return (columnsOffset > 0);\n}\n\n//----------------------------------------------------------------------------\n-(void) clear\n{\n  if (columnsOffset > 0) // isSaved == YES\n  {\n    columns = nil;\n\n    if (dirty == NO)\n    {\n      attributes = nil;\n    }\n  }\n}\n\n@end\n\n//============================================================================\n@implementation MVTable\n\n@synthesize swapFile;\n\n//-----------------------------------------------------------------------------\n- (instancetype)init\n{\n  NSAssert(NO, @\"plain init is not allowed\");\n  return nil;\n}\n\n//-----------------------------------------------------------------------------\n- (instancetype)initWithArchiver:(MVArchiver *)_archiver\n{\n  if (self = [super init])\n  {\n    rows = [[NSMutableArray alloc] init];\n    archiver = _archiver;\n    tableLock = [[NSLock alloc] init];\n  }\n  return self;\n}\n\n//----------------------------------------------------------------------------\n+(MVTable *) tableWithArchiver:(MVArchiver *)_archiver\n{\n  return [[MVTable alloc] initWithArchiver:_archiver];\n}\n\n//----------------------------------------------------------------------------\n- (NSUInteger)rowCountToDisplay\n{\n  return [displayRows count];\n}\n\n//----------------------------------------------------------------------------\n- (MVRow *)getRowToDisplay: (NSUInteger)rowIndex\n{\n  MVRow * row = nil;\n\n  if (rowIndex < [displayRows count])\n  {\n    row = [displayRows objectAtIndex:rowIndex];\n  }\n\n  if (row != nil)\n  {\n    if (row.deleted)\n    {\n      row = nil;\n    }\n    else if (row.columns == nil)\n    {\n      [row loadFromFile:swapFile];\n    }\n  }\n\n  return row;\n}\n\n//----------------------------------------------------------------------------\n- (void)insertRowWithOffset:(uint64_t)offset :(id)col0 :(id)col1 :(id)col2 :(id)col3\n{\n  MVRow * row = [[MVRow alloc] init];\n  row.columns = [MVColumns columnsWithData:col0:col1:col2:col3];\n  row.offset = offset;\n  \n  [tableLock lock];\n  [rows addObject:row];\n  [tableLock unlock];\n  \n  [archiver addObjectToSave:row];\n}\n\n//----------------------------------------------------------------------------\n- (void)appendRow:(id)col0 :(id)col1 :(id)col2 :(id)col3\n{\n  [self insertRowWithOffset:0 :col0:col1:col2:col3];\n}\n\n//----------------------------------------------------------------------------\n- (void)updateCellContentTo:(id)object atRow:(NSUInteger)rowIndex andCol:(NSUInteger)colIndex\n{\n  MVRow * row = [rows objectAtIndex:rowIndex];\n  [row replaceColumnAtIndex:colIndex withString:object];\n  [rows replaceObjectAtIndex:rowIndex withObject:row];\n\n  [archiver addObjectToSave:row];\n}\n\n//----------------------------------------------------------------------------\n- (void)popRow\n{\n  MVRow * row = [rows lastObject];\n  row.deleted = YES;\n}\n\n//----------------------------------------------------------------------------\n- (NSUInteger)rowCount\n{\n  return [rows count];\n}\n\n//----------------------------------------------------------------------------\n//  input are name-value pairs\n//----------------------------------------------------------------------------\n-(NSMutableDictionary *)attributesWithPairs:(id)firstArg :(va_list)args\n{\n  NSMutableDictionary * attributes = [[NSMutableDictionary alloc] init];\n  \n  NSString * name = nil;\n  for (id arg = firstArg; arg != nil; arg = va_arg(args, id))\n  {\n    if (name == nil)\n    {\n      name = arg;\n      continue;\n    }\n    \n    [attributes setObject:arg forKey:name];\n    name = nil;\n  }\n  \n  return attributes;\n}\n\n//----------------------------------------------------------------------------\n- (void)setAttributes:(NSMutableDictionary *)attributes forRow:(MVRow *)row\n{\n  NSParameterAssert(row != nil);\n  \n  if (row.dirty)\n  {\n    [attributes addEntriesFromDictionary:row.attributes];\n  }\n  \n  row.attributes = attributes;\n  row.dirty = YES;\n}\n\n//----------------------------------------------------------------------------\n- (void)setAttributes:(id)firstArg, ... \n{\n  va_list args;\n  va_start(args, firstArg);\n  NSMutableDictionary * attributes = [self attributesWithPairs:firstArg:args];\n  va_end(args);\n\n  MVRow * row = [rows lastObject];\n  [self setAttributes:attributes forRow:row];\n\n  // update saved\n  [archiver addObjectToSave:row];\n}\n\n//----------------------------------------------------------------------------\n- (void)setAttributesForRowIndex:(NSUInteger)index :(id)firstArg, ...\n{\n  va_list args;\n  va_start(args, firstArg);\n  NSMutableDictionary * attributes = [self attributesWithPairs:firstArg:args];\n  va_end(args);\n  \n  MVRow * row = [rows objectAtIndex:index];\n  [self setAttributes:attributes forRow:row];\n\n  // update saved\n  [archiver addObjectToSave:row];\n}\n\n//----------------------------------------------------------------------------\n- (void)setAttributesFromRowIndex:(NSUInteger)index :(id)firstArg, ...\n{\n  va_list args;\n  va_start(args, firstArg);\n  NSDictionary * attributes = [self attributesWithPairs:firstArg:args];\n  va_end(args);\n\n  for (NSUInteger numRows = [rows count]; index < numRows; ++index)\n  {\n    MVRow * row = [rows objectAtIndex:index];\n    [self setAttributes:[NSMutableDictionary dictionaryWithDictionary:attributes] forRow:row];\n\n    // update saved\n    [archiver addObjectToSave:row];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void) applyFilter: (NSString *)filter\n{\n  [tableLock lock];\n  if (filter == nil || [filter length] == 0)\n  {\n    // copy everything (copy by elems because want to exclude later added rows)\n    displayRows = [NSMutableArray arrayWithArray:rows];\n    \n    /*\n    displayRows = [[NSMutableArray alloc] init];\n    for (MVRow * row in rows)\n    {\n      if (row.isSaved)\n      {\n        [displayRows addObject:row];\n      }\n    }\n     */\n    \n  }\n  else\n  {\n    NSPredicate *predicate = [NSPredicate\n                              predicateWithFormat:@\"self contains[cd] %@\", filter];\n\n    displayRows = [[NSMutableArray alloc] init];\n    for (MVRow * row in rows)\n    {\n      if (row.columns == nil)\n      {\n        [row loadFromFile:swapFile];\n      }\n    \n      NSString * metadata = [row.attributes objectForKey:MVMetaDataAttributeName];\n      if (metadata == nil || [predicate evaluateWithObject:metadata] == YES)\n      {\n        [displayRows addObject:row];\n      }\n    }\n  }\n  [tableLock unlock];\n}\n\n//----------------------------------------------------------------------------\n- (void)sortByOffset\n{\n  [tableLock lock];\n  [rows sortWithOptions:NSSortStable usingComparator:^(id obj1, id obj2)   \n   {\n     MVRow * row1 = obj1;\n     MVRow * row2 = obj2;\n     if (row1.offset < row2.offset) return (NSComparisonResult)NSOrderedAscending;\n     if (row1.offset > row2.offset) return (NSComparisonResult)NSOrderedDescending;\n     return (NSComparisonResult)NSOrderedSame;\n   }];\n  [tableLock unlock]; \n}\n\n//----------------------------------------------------------------------------\n- (void)saveIndexes\n{\n    uint64_t rowCount = [rows count];\n    if (fwrite(&rowCount, sizeof(uint64_t), 1, swapFile) < 1) {\n        NSLog(@\"saveIndexes write error\");\n        return;\n    }\n\n    for (MVRow * row in rows) {\n        [row saveIndexToFile:swapFile];\n    }\n}\n\n//----------------------------------------------------------------------------\n- (void)loadIndexes\n{\n  uint64_t rowCount;\n  fread(&rowCount, sizeof(uint64_t), 1, swapFile);\n  \n  while (rowCount-- > 0) {\n    MVRow * row = [[MVRow alloc] init];\n    [row loadIndexFromFile:swapFile];\n    [rows addObject:row];\n  }\n}\n\n@end\n\n\n//============================================================================\n@implementation MVNode\n\n@synthesize caption, parent, dataRange, details, userInfo, detailsOffset;\n\n//-----------------------------------------------------------------------------\n- (instancetype)init\n{\n  if (self = [super init]) \n  {\n    children = [[NSMutableArray alloc] init];\n    userInfo = [[NSMutableDictionary alloc] init];\n  }\n  return self;\n}\n\n//----------------------------------------------------------------------------\n-(NSString *)description\n{\n  return [[super description] stringByAppendingFormat:@\" [%@]\", caption];\n}\n\n//----------------------------------------------------------------------------\n- (MVNode *)childAtIndex:(NSUInteger)n \n{\n  return [children objectAtIndex:n];\n}\n\n//----------------------------------------------------------------------------\n- (NSUInteger)numberOfChildren \n{\n  return [children count];\n}\n\n//----------------------------------------------------------------------------\n- (void)insertNode:(MVNode *)node\n{\n  MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n  \n  [layout.dataController.treeLock lock];\n  \n  NSUInteger index = [children indexOfObjectPassingTest:\n                      ^(id obj, NSUInteger idx, BOOL *stop)\n                      {\n                        if (node.dataRange.location < [obj dataRange].location)\n                        {\n                          *stop = YES;\n                          return YES;\n                        }\n                        return NO;\n                      }];\n  \n  NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n  [nc postNotificationName:MVDataTreeWillChangeNotification \n                    object:layout.dataController];\n\n  if (index == NSNotFound)\n  {\n    [children addObject:node];\n  }\n  else\n  {\n    [children insertObject:node atIndex:index];\n  }\n\n  [nc postNotificationName:MVDataTreeDidChangeNotification \n                    object:layout.dataController];\n\n  [layout.dataController updateTreeView:self];\n  \n  [layout.dataController.treeLock unlock];\n}\n\n//----------------------------------------------------------------------------\n- (MVNode *)insertChild:(NSString *)_caption\n            location:(uint64_t)location\n              length:(uint64_t)length\n{\n  MVNode * node = [[MVNode alloc] init];\n  node.caption = _caption;\n  node.dataRange = NSMakeRange(location,length);\n  node.parent = self;\n  [node.userInfo addEntriesFromDictionary:userInfo];\n  [self insertNode:node]; \n  return node;\n}\n\n//----------------------------------------------------------------------------\n- (MVNode *)insertChildWithDetails:(NSString *)_caption \n                       location:(uint64_t)location\n                         length:(uint64_t)length\n                          saver:(MVNodeSaver &)saver\n{\n  MVNode * node = [self insertChild:_caption location:location length:length];\n  MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n  node.details = [MVTable tableWithArchiver:layout.archiver];\n  saver.setNode(node);\n  return node;\n}\n\n//----------------------------------------------------------------------------\n- (MVNode *)findNodeByUserInfo:(NSDictionary *)uinfo\n{\n  // act node\n  if ([userInfo isEqualToDictionary:uinfo] == YES)\n  {\n    return self;\n  }\n\n  // recursively on childrens\n  for (MVNode * node in children)\n  {\n    MVNode * found = [node findNodeByUserInfo:uinfo];\n    if (found != nil)\n    {\n      return found;\n    }\n  }\n  \n  // give up\n  return nil;\n}\n\n//-----------------------------------------------------------------------------\n- (void)openDetails\n{\n  MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n  FILE * pFile = fopen(CSTRING(layout.archiver.swapPath), \"r\");\n  if (pFile != NULL)\n  {\n    if (details != nil) // saving in progress\n    {\n      details.swapFile = pFile;\n    }\n    else if (detailsOffset != 0) // saved and has content\n    {\n      [self loadFromFile:pFile];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (void)closeDetails\n{\n  if (details.swapFile != NULL)\n  {\n    fclose(details.swapFile);\n    details.swapFile = NULL;\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (void)sortDetails\n{\n  MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n  [layout.dataController updateStatus:MVStatusTaskStarted];\n  [details sortByOffset];\n  [layout.dataController updateStatus:MVStatusTaskTerminated];\n}\n\n//----------------------------------------------------------------------------\n- (void)filterDetails: (NSString *)filter\n{\n  MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n  [layout.dataController updateStatus:MVStatusTaskStarted];\n  [layout.archiver suspend];\n  [details applyFilter:filter];\n  [layout.archiver resume];\n  [layout.dataController updateStatus:MVStatusTaskTerminated];\n}\n\n//-----------------------------------------------------------------------------\n- (void)saveToFile:(FILE *)pFile\n{\n    MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n    [layout.dataController updateStatus:MVStatusTaskStarted];\n  \n    off_t filePos = ftello(pFile);\n    // XXX: error check\n    if (filePos == -1) {\n        NSLog(@\"MVNode saveToFile: ftello failed: %s\", strerror(errno));\n    }\n    details.swapFile = pFile;\n    [details saveIndexes];\n    detailsOffset = filePos;\n    // clear the * prefix\n    [layout.dataController updateTreeView:self];\n    // update the details table\n    if (self == layout.dataController.selectedNode) {\n        [self openDetails];\n        [details applyFilter:nil];\n    }\n  \n    [layout.dataController updateStatus:MVStatusTaskTerminated];\n}\n\n//-----------------------------------------------------------------------------\n- (void)loadFromFile:(FILE *)pFile\n{\n  MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n  [layout.dataController updateStatus:MVStatusTaskStarted];\n  details = [MVTable tableWithArchiver:layout.archiver];\n  details.swapFile = pFile;\n  NSParameterAssert(detailsOffset != 0);\n  fseek (pFile, detailsOffset, SEEK_SET);\n  [details loadIndexes];\n  [layout.dataController updateStatus:MVStatusTaskTerminated];\n}\n\n//-----------------------------------------------------------------------------\n-(void)clear\n{\n  MVLayout * layout = [userInfo objectForKey:MVLayoutUserInfoKey];\n  if (layout.dataController.selectedNode != self)\n  {\n    details = nil;\n  }\n}\n\n@end\n\n\n//============================================================================\n@implementation MVDataController\n\n@synthesize fileName, fileData, realData, layouts, rootNode, selectedNode, treeLock;\n\n//-----------------------------------------------------------------------------\n/*\n- (void)dealloc\n{\n  NSLog(@\"********MVDataController deallocated: %@\", self);\n  for (MVLayout * layout in layouts)\n  {\n    NSLog(@\"%@ Retain count is %ld\", layout, CFGetRetainCount((__bridge CFTypeRef)layout));\n  }\n}\n*/\n\n//-----------------------------------------------------------------------------\n- (instancetype)init\n{\n  if (self = [super init]) \n  {\n    layouts = [[NSMutableArray alloc] init];\n    rootNode = [[MVNode alloc] init];\n    treeLock = [[NSLock alloc] init];\n  }\n  return self;\n}\n\n//----------------------------------------------------------------------------\n-(NSString *)getMachine:(cpu_type_t)cputype\n{\n    switch (cputype)\n    {\n        default:                  return @\"???\";\n        case CPU_TYPE_I386:       return @\"X86\";\n        case CPU_TYPE_POWERPC:    return @\"PPC\";\n        case CPU_TYPE_X86_64:     return @\"X86_64\";\n        case CPU_TYPE_POWERPC64:  return @\"PPC64\";\n        case CPU_TYPE_ARM:        return @\"ARM\";\n        case CPU_TYPE_ARM64:      return @\"ARM64\";\n        case CPU_TYPE_ARM64_32:   return @\"ARM64_32\";\n    }\n}\n\n//----------------------------------------------------------------------------\n-(NSString *)getARMCpu:(cpu_subtype_t)cpusubtype\n{\n    switch (cpusubtype & ~CPU_SUBTYPE_MASK)\n    {\n        default:                      return @\"???\";\n        case CPU_SUBTYPE_ARM_ALL:     return @\"ARM_ALL\";\n        case CPU_SUBTYPE_ARM_V4T:     return @\"ARM_V4T\";\n        case CPU_SUBTYPE_ARM_V6:      return @\"ARM_V6\";\n        case CPU_SUBTYPE_ARM_V5TEJ:   return @\"ARM_V5TEJ\";\n        case CPU_SUBTYPE_ARM_XSCALE:  return @\"ARM_XSCALE\";\n        case CPU_SUBTYPE_ARM_V7:      return @\"ARM_V7\";\n        case CPU_SUBTYPE_ARM_V7F:     return @\"ARM_V7F\";\n        case CPU_SUBTYPE_ARM_V7S:     return @\"ARM_V7S\";\n        case CPU_SUBTYPE_ARM_V7K:     return @\"ARM_V7K\";\n        case CPU_SUBTYPE_ARM_V8:      return @\"ARM_V8\";\n        case CPU_SUBTYPE_ARM_V6M:     return @\"ARM_V6M\";\n        case CPU_SUBTYPE_ARM_V7M:     return @\"ARM_V7M\";\n        case CPU_SUBTYPE_ARM_V7EM:    return @\"ARM_V7EM\";\n        case CPU_SUBTYPE_ARM_V8M:     return @\"ARM_V8M\";\n    }\n}\n\n//----------------------------------------------------------------------------\n-(NSString *)getARM64Cpu:(cpu_subtype_t)cpusubtype\n{\n    switch (cpusubtype & ~CPU_SUBTYPE_MASK)\n    {\n        default:                      return @\"???\";\n        case CPU_SUBTYPE_ARM64_ALL:   return @\"ARM64_ALL\";\n        case CPU_SUBTYPE_ARM64_V8:    return @\"ARM64_V8\";\n        case CPU_SUBTYPE_ARM64E:      return @\"ARM64E\";\n    }\n}\n\n//----------------------------------------------------------------------------\n-(BOOL)isSupportedMachine:(NSString *)machine\n{\n    return ([machine isEqualToString:@\"X86\"] == YES ||\n            [machine isEqualToString:@\"X86_64\"] == YES ||\n            [machine isEqualToString:@\"ARM\"] == YES ||\n            [machine isEqualToString:@\"ARM64\"] == YES ||\n            [machine isEqualToString:@\"ARM64_32\"] == YES);\n}\n\n//----------------------------------------------------------------------------\n-(NSString *)getFileType:(uint32_t)filetype\n{\n    switch (filetype) {\n        case MH_OBJECT:\n            return @\"Object \";\n        case MH_EXECUTE:\n            return @\"Executable \";\n        case MH_FVMLIB:\n            return @\"Fixed VM Shared Library\";\n        case MH_CORE:\n            return @\"Core\";\n        case MH_PRELOAD:\n            return @\"Preloaded Executable\";\n        case MH_DYLIB:\n            return @\"Shared Library \";\n        case MH_DYLINKER:\n            return @\"Dynamic Link Editor\";\n        case MH_BUNDLE:\n            return @\"Bundle\";\n        case MH_DYLIB_STUB:\n            return @\"Shared Library Stub\";\n        case MH_DSYM:\n            return @\"Debug Symbols\";\n        case MH_KEXT_BUNDLE:\n            return @\"Kernel Extension\";\n        case MH_FILESET:\n            return @\"File Set\";\n#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 130000\n        case MH_GPU_EXECUTE:\n            return @\"GPU Program\";\n        case MH_GPU_DYLIB:\n            return @\"GPU Support Functions\";\n#endif\n        default:\n            return @\"?????\";\n    }\n}\n\n//----------------------------------------------------------------------------\n-(void)createMachOLayout:(MVNode *)node\n             mach_header:(struct mach_header const *)mach_header\n{\n    NSString * machine = [self getMachine:mach_header->cputype];\n  \n    node.caption = [NSString stringWithFormat:@\"%@ (%@)\",\n                    [self getFileType:mach_header->filetype],\n                    [machine isEqualToString:@\"ARM\"] == YES ? [self getARMCpu:mach_header->cpusubtype] : machine];\n  \n    MachOLayout * layout = [MachOLayout layoutWithDataController:self rootNode:node];\n                          \n    [node.userInfo setObject:layout forKey:MVLayoutUserInfoKey];\n  \n    if ([self isSupportedMachine:machine]) {\n        [layouts addObject:layout];\n    }\n    else {\n        // there is no detail to extract\n        [layout.archiver halt];\n    }\n}\n\n//----------------------------------------------------------------------------\n-(void)createMachO64Layout:(MVNode *)node\n            mach_header_64:(struct mach_header_64 const *)mach_header_64\n{\n    NSString * machine = [self getMachine:mach_header_64->cputype];\n        \n    node.caption = [NSString stringWithFormat:@\"%@ (%@)\",\n                    [self getFileType:mach_header_64->filetype],\n                    [machine isEqualToString:@\"ARM64\"] == YES ? [self getARM64Cpu:mach_header_64->cpusubtype] : machine];\n  \n    MachOLayout * layout = [MachOLayout layoutWithDataController:self rootNode:node];\n\n    [node.userInfo setObject:layout forKey:MVLayoutUserInfoKey];\n\n    if ([self isSupportedMachine:machine]) {\n        [layouts addObject:layout];\n    }\n    else {\n        // there is no detail to extract\n        [layout.archiver halt];\n    }\n}\n\n//----------------------------------------------------------------------------\n-(void)createArchiveLayout:(MVNode *)node machine:(NSString *)machine\n{\n  node.caption = machine ? [NSString stringWithFormat:@\"Static Library (%@)\", machine] : @\"Static Library\";\n  \n  ArchiveLayout * layout = [ArchiveLayout layoutWithDataController:self rootNode:node];\n  \n  [node.userInfo setObject:layout forKey:MVLayoutUserInfoKey];\n    \n  if (machine == nil || [self isSupportedMachine:machine])\n    {\n    [layouts addObject:layout];\n    }\n    else\n    {\n    // there is no detail to extract\n    [layout.archiver halt];\n  }\n}\n\n//----------------------------------------------------------------------------\n// create Mach-O layouts based on file headers\n- (void)createLayouts:(MVNode *)parent\n             location:(uint64_t)location\n               length:(uint64_t)length\n{\n  uint32_t magic = *(uint32_t*)((uint8_t *)[fileData bytes] + location);\n  \n  switch (magic)\n  {\n    case FAT_MAGIC:\n    case FAT_CIGAM:\n    {\n      struct fat_header fat_header;\n      [fileData getBytes:&fat_header range:NSMakeRange(location, sizeof(struct fat_header))];\n      if (magic == FAT_CIGAM)\n        swap_fat_header(&fat_header, NX_LittleEndian);\n      [self createFatLayout:parent fat_header:&fat_header];\n    } break;\n      \n    case MH_MAGIC:\n    case MH_CIGAM:\n    {\n      struct mach_header mach_header;\n      [fileData getBytes:&mach_header range:NSMakeRange(location, sizeof(struct mach_header))];\n      if (magic == MH_CIGAM)\n        swap_mach_header(&mach_header, NX_LittleEndian);\n      [self createMachOLayout:parent mach_header:&mach_header];\n    } break;\n      \n    case MH_MAGIC_64:\n    case MH_CIGAM_64:\n    {\n      struct mach_header_64 mach_header_64;\n      [fileData getBytes:&mach_header_64 range:NSMakeRange(location, sizeof(struct mach_header_64))];\n      if (magic == MH_CIGAM_64)\n        swap_mach_header_64(&mach_header_64, NX_LittleEndian);\n      [self createMachO64Layout:parent mach_header_64:&mach_header_64];\n    } break;\n    \n    default:\n      [self createArchiveLayout:parent machine:nil];\n  }\n  \n  parent.dataRange = NSMakeRange(location, length);\n}\n\n//----------------------------------------------------------------------------\n-(void)createFatLayout:(MVNode *)node\n            fat_header:(struct fat_header const *)fat_header\n{\n  node.caption = @\"Fat Binary\";\n  FatLayout * layout = [FatLayout layoutWithDataController:self rootNode:node];\n  \n  [node.userInfo setObject:layout forKey:MVLayoutUserInfoKey];\n  \n  [layouts addObject:layout];\n  for (uint32_t nimg = 0; nimg < fat_header->nfat_arch; ++nimg)\n  {      \n    // need to make copy for byte swapping\n    struct fat_arch fat_arch;\n    [fileData getBytes:&fat_arch range:NSMakeRange(sizeof(struct fat_header) + nimg * sizeof(struct fat_arch), sizeof(struct fat_arch))];\n    swap_fat_arch(&fat_arch, 1, NX_LittleEndian);\n    \n    MVNode * archNode = [node insertChild:nil location:fat_arch.offset length:fat_arch.size];\n\n    if (*(uint64_t*)((uint8_t *)[fileData bytes] + fat_arch.offset) == *(uint64_t*)\"!<arch>\\n\")\n    {\n      [self createArchiveLayout:archNode machine:[self getMachine:fat_arch.cputype]];\n    }\n    else\n    {\n      [self createLayouts:archNode location:fat_arch.offset length:fat_arch.size];\n    }\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)treeViewWillChange\n{\n  NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n  [nc postNotificationName:MVDataTreeWillChangeNotification \n                    object:self];\n}\n\n//----------------------------------------------------------------------------\n- (void)treeViewDidChange\n{\n  NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n  [nc postNotificationName:MVDataTreeDidChangeNotification \n                    object:self];\n}\n\n//----------------------------------------------------------------------------\n- (void)updateTreeView: (MVNode *)node\n{\n  NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n  [nc postNotificationName:MVDataTreeChangedNotification \n                    object:self\n                  userInfo:node ? [NSDictionary dictionaryWithObject:node forKey:MVNodeUserInfoKey] : nil];\n}\n\n//-----------------------------------------------------------------------------\n- (void)updateTableView\n{\n  NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n  [nc postNotificationName:MVDataTableChangedNotification \n                    object:self];\n}\n\n//-----------------------------------------------------------------------------\n- (void)updateStatus: (NSString *)status\n{\n  NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n  [nc postNotificationName:MVThreadStateChangedNotification \n                    object:self\n                  userInfo:[NSDictionary dictionaryWithObject:status forKey:MVStatusUserInfoKey]];\n}\n\n@end\n\n#pragma mark -\n\n//============================================================================\n@implementation MVArchiver\n\n@synthesize swapPath;\n\n//-----------------------------------------------------------------------------\n- (instancetype)init\n{\n  NSAssert(NO, @\"plain init is not allowed\");\n  return nil;\n}\n\n//-----------------------------------------------------------------------------\n- (instancetype)initWithPath:(NSString *)path\n{  \n  if (self = [super init]) \n  {\n    objectsToSave = [[NSMutableArray alloc] init];\n    \n    swapPath = path;\n    \n    NSLog(@\"%@: swap file is being created:%@\", self, swapPath);\n    FILE * pFile = fopen(CSTRING(swapPath), \"w\");\n    if (pFile == NULL)\n    {\n      NSLog(@\"*** file cannot be created: %@ '%s'\", swapPath,strerror(errno));\n      return nil;\n    }    \n    fputs(\"!<MachoViewSwapFile 1.0>\\n\", pFile); // header for versioning\n    fclose(pFile);\n    \n    saverLock = [[NSLock alloc] init];\n\n#ifndef MV_NO_ARCHIVER\n    saverThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSave) object:nil];\n    [saverThread start];\n    NSLog(@\"********MVArchiver started: %@\", self);\n#endif    \n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n+(MVArchiver *) archiverWithPath:(NSString *)path\n{\n  return [[MVArchiver alloc] initWithPath:path];\n}\n\n//-----------------------------------------------------------------------------\n-(void) suspend\n{\n  [saverLock lock];\n}\n\n//-----------------------------------------------------------------------------\n-(void) resume\n{\n  [saverLock unlock];\n}\n\n//-----------------------------------------------------------------------------\n-(void) halt\n{\n  [saverThread cancel];\n  NSLog(@\"********MVArchiver halted: %@\", self);\n}\n\n//-----------------------------------------------------------------------------\n-(void) addObjectToSave:(id)object;\n{\n  NSParameterAssert([object conformsToProtocol:@protocol(MVSerializing)] == YES);\n  \n  [saverLock lock];\n  [objectsToSave addObject:object];\n  [saverLock unlock];\n  \n  // if the background saver thread has been cancelled, then do do one cycle manually\n  if ([saverThread isCancelled])\n  {\n    [self doSave];\n  }\n}\n\n//-----------------------------------------------------------------------------\n-(void) doSave\n{\n  for (;;)\n  {\n    if ([objectsToSave count] > 0)\n    {\n      [pipeCondition lock];\n      ++numIOThread;\n      [pipeCondition unlock];\n        \n      FILE * pFile = fopen(CSTRING(swapPath), \"a+\");\n      if (pFile != NULL)\n      { \n        [saverLock lock];\n\n#if DEBUG\n        NSLog(@\"%@: saving %lu rows\",[NSThread currentThread],(unsigned long)[objectsToSave count]);\n#endif\n        for (id <MVSerializing> serializable in objectsToSave)\n        {\n          [serializable saveToFile:pFile];\n        }\n        fclose(pFile);\n\n        for (id <MVSerializing> serializable in objectsToSave)\n        {\n          [serializable clear];\n        }\n        \n        // reset buffer\n        objectsToSave = [[NSMutableArray alloc] init];\n\n        [saverLock unlock];\n      }\n\n      [pipeCondition lock];\n      --numIOThread;\n      [pipeCondition signal];\n      [pipeCondition unlock];\n    }\n    \n    if ([saverThread isCancelled])\n    {\n    // only exit if buffer is surely empty\n      if ([objectsToSave count] == 0)\n    {\n      break; // the nicest way\n      //return;\n      //[NSThread exit];\n    }\n      // do not wait for new rows if the saver has been cancelled\n      // just flush out the existing ones\n      continue;\n    }\n    \n    // let's wait for some objects to collect for saving\n    double rnd = 1. + rand()/((double)RAND_MAX+1); // between 1 and 2\n    [NSThread sleepForTimeInterval:rnd];\n  }\n}\n\n@end\n\n//-----------------------------------------------------------------------------\nMVNodeSaver::MVNodeSaver() \n  : m_node(nil) \n{\n}\n\n//-----------------------------------------------------------------------------\nMVNodeSaver::~MVNodeSaver() \n{\n  MVLayout * layout = [m_node.userInfo objectForKey:MVLayoutUserInfoKey];\n  [layout.archiver addObjectToSave:m_node];\n}\n"
        },
        {
          "name": "DataSources.h",
          "type": "blob",
          "size": 0.224609375,
          "content": "/*\n *  DataSources.h\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\nextern NSString * const MVScannerErrorMessage;\n\n@interface MVDataSourceTree : NSObject;\n@end\n\n\n@interface MVDataSourceDetails : NSObject;\n@end\n\n"
        },
        {
          "name": "DataSources.mm",
          "type": "blob",
          "size": 9.26171875,
          "content": "/*\n *  DataSources.mm\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#import \"Common.h\"\n#import \"DataSources.h\"\n#import \"DataController.h\"\n#import \"Document.h\"\n#import \"Layout.h\"\n\nNSString * const MVScannerErrorMessage  = @\"NSScanner error\";\n\n//============================================================================\n@implementation MVDataSourceTree\n\n#pragma mark NSOutlineView must-have delegates\n\n- (NSInteger)outlineView:(NSOutlineView *)outlineView numberOfChildrenOfItem:(id)item \n{\n  if (item == nil)\n  {\n    return 1;\n  }\n  \n  MVNode * node = item;\n  return node.numberOfChildren;\n}\n//----------------------------------------------------------------------------\n\n- (BOOL)outlineView:(NSOutlineView *)outlineView isItemExpandable:(id)item \n{\n  if (item == nil)\n  {\n    return YES;\n  }\n  \n  MVNode * node = item;\n  return (node.numberOfChildren > 0);\n}\n//----------------------------------------------------------------------------\n\n- (id)outlineView:(NSOutlineView *)outlineView child:(NSInteger)index ofItem:(id)item \n{\n  MVDocument * document = [[[outlineView window] windowController] document];\n  if (item == nil)\n  {\n    return document.dataController.rootNode;\n  }\n  \n  MVNode * node = item;\n  return [node childAtIndex:index];\n}\n//----------------------------------------------------------------------------\n\n- (id)outlineView:(NSOutlineView *)outlineView objectValueForTableColumn:(NSTableColumn *)tableColumn byItem:(id)item \n{\n  if (item == nil)\n  {\n    return @\"-\";\n  }\n  \n  MVNode * node = item;\n  \n  if (node.details != nil && node.detailsOffset == 0)\n  {\n    return [@\"*\" stringByAppendingString:node.caption];\n  }\n  \n  return node.caption;\n}\n//----------------------------------------------------------------------------\n\n@end\n\n\n//============================================================================\n@implementation MVDataSourceDetails\n\n#pragma mark NSTableView must-have delegates\n\n- (NSInteger)numberOfRowsInTableView:(NSTableView *)aTableView\n{\n  MVDocument * document = [[[aTableView window] windowController] document];\n  MVNode * selectedNode = document.dataController.selectedNode;\n  \n  // if there is no details, then provide binary dump\n  if (selectedNode.details == nil)\n  {\n    NSInteger numRows = selectedNode.dataRange.length / 16;\n    if (selectedNode.dataRange.length % 16 != 0)\n    {\n      ++numRows;\n    }\n    return numRows;\n  }\n\n  return selectedNode.details.rowCountToDisplay;\n}\n//----------------------------------------------------------------------------\n\n- (id)tableView:(NSTableView *)aTableView objectValueForTableColumn:(NSTableColumn *)aTableColumn row:(NSInteger)rowIndex\n{\n  MVDocument * document = [[[aTableView window] windowController] document];\n  MVNode * selectedNode = document.dataController.selectedNode;\n  \n  // if it is closing...\n  if (document == nil)\n  {\n    return nil;\n  }\n  \n  NSUInteger colIndex = [[aTableView tableColumns] indexOfObject:aTableColumn];\n  \n  //NSLog (@\"queried (%d, %d)\", rowIndex, colIndex);\n  \n  // if it has no details then show binary data at given range\n  if (selectedNode.details == nil)\n  {\n    NSUInteger offset = selectedNode.dataRange.location + rowIndex * 16;\n    \n    // file offset\n    if (colIndex == OFFSET_COLUMN)\n    {\n      NSString * cellContent = [NSString stringWithFormat:@\"%.8lX\", offset];\n      if ([document isRVA] == YES)\n      {\n        MVLayout *layout = [selectedNode.userInfo objectForKey:MVLayoutUserInfoKey];\n        return [layout convertToRVA:cellContent];\n      }\n      return cellContent;\n    }\n\n    // binary data\n    uint8_t buffer[17] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n    \n    NSUInteger len = MIN(selectedNode.dataRange.length - rowIndex * 16, (NSUInteger)16);\n    \n    memcpy(buffer, (uint8_t *)[document.dataController.fileData bytes] + offset, len);\n    \n    if (colIndex == DATA_LO_COLUMN)\n    {\n      NSUInteger index = (len > 8 ? 8 : len); \n            \n      return [[NSString stringWithFormat:@\"%.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X \", \n              buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7]]\n              substringToIndex:index*3];\n    }\n    \n    if (colIndex == DATA_HI_COLUMN)\n    {\n      NSUInteger index = (len > 8 ? len - 8 : 0);\n      \n      return [[NSString stringWithFormat:@\"%.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X \", \n              buffer[8], buffer[9], buffer[10], buffer[11], buffer[12], buffer[13], buffer[14], buffer[15]]\n              substringToIndex:index*3];\n    }\n    \n    // textual data (where possible)\n    for (NSUInteger i = 0; i < len; ++i)\n    {\n      // keep the output in ASCII\n      if (buffer[i] < 32 || buffer[i] > 126)\n      {\n        buffer[i] = '.';\n      }\n    }\n    \n    return NSSTRING(buffer);\n  }\n  \n  // if it has descripion then show it\n  MVRow * row = [selectedNode.details getRowToDisplay:rowIndex];\n  if (row != nil)\n  { \n    NSString * cellContent = [row columnAtIndex:colIndex];\n      \n    // special column is the offset column:\n    // if RVA is selected then subtitute the content on the fly\n    if (colIndex == OFFSET_COLUMN && [cellContent length] > 0) \n    {\n      if ([document isRVA] == YES)\n      {\n        MVLayout *layout = [selectedNode.userInfo objectForKey:MVLayoutUserInfoKey];\n        cellContent = [layout convertToRVA:cellContent];\n      }\n    }\n      \n    // put formatting on display text\n    NSColor * color = [row.attributes objectForKey:MVTextColorAttributeName];\n    if (color != nil)\n    {\n      NSDictionary * attributes = [NSDictionary dictionaryWithObject:color forKey:NSForegroundColorAttributeName];\n      return [[NSAttributedString alloc] initWithString:cellContent\n                                             attributes:attributes];\n    }\n    return cellContent;\n  }\n  \n  return nil;\n}\n//----------------------------------------------------------------------------\n\n- (void)tableView:(NSTableView *)aTableView setObjectValue:(id)anObject forTableColumn:(NSTableColumn *)aTableColumn row:(NSInteger)rowIndex\n{\n  BOOL scanResult;\n  uint64_t fileOffset;\n\n  NSUInteger colIndex = [[aTableView tableColumns] indexOfObject:aTableColumn];\n  MVDocument * document = [[[aTableView window] windowController] document];\n  NSString * cellContent = ([anObject isKindOfClass:[NSAttributedString class]] ? [anObject string] : anObject);\n  NSScanner * scanner = [NSScanner scannerWithString:cellContent];\n  MVNode * selectedNode = document.dataController.selectedNode;\n  \n  if (selectedNode.details != nil)\n  // option1: plain hex value\n  {\n    MVRow * row = [selectedNode.details getRowToDisplay:rowIndex];\n    if (row == nil)\n    {\n      return;\n    }\n    \n    // find out file offset from the offset column\n    scanResult = [[NSScanner scannerWithString:row.columns.offsetStr] scanHexLongLong:&fileOffset];\n    if (scanResult == NO)\n    {\n      NSAssert(NO, MVScannerErrorMessage);\n      return;\n    }\n    \n    NSRange dataRange = NSMakeRange(fileOffset, [cellContent length] / 2);\n    \n    if (dataRange.length <= sizeof(uint64_t))\n    {\n      uint64_t value;\n      scanResult = [scanner scanHexLongLong:&value];\n      if (scanResult == NO)\n      {\n        NSAssert(NO, MVScannerErrorMessage);\n        return;\n      }\n      [document.dataController.fileData replaceBytesInRange:dataRange withBytes:&value];\n    }\n    else \n    {\n      // create a place holder for new value\n      NSAssert ([cellContent length] % 2 == 0, @\"cell content length must be even\");\n      \n      NSMutableData * mdata = [NSMutableData dataWithCapacity:dataRange.length];\n      \n      static char buf[3];\n      char const * orgstr = CSTRING(cellContent);\n      for (NSUInteger s = 0; s < [cellContent length]; s += 2)\n      {\n        buf[0] = orgstr[s];\n        buf[1] = orgstr[s+1];\n        unsigned long value = strtoul (buf, NULL, 16);\n        [mdata appendBytes:&value length:sizeof(uint8_t)];\n      }\n      \n      // replace data with the new value\n      [document.dataController.fileData replaceBytesInRange:dataRange withBytes:[mdata bytes]];\n    }\n\n    // update the cell content to indicate changes\n    //================================================\n    selectedNode.detailsOffset = 0;\n    [selectedNode.details updateCellContentTo:cellContent atRow:rowIndex andCol:colIndex];\n    [selectedNode.details setAttributesForRowIndex:rowIndex:MVTextColorAttributeName,[NSColor redColor],nil];\n  }\n  else\n  // option2: group of bytes\n  {\n    // find out file offset from the row index\n    fileOffset = selectedNode.dataRange.location + 16 * rowIndex + 8 * (colIndex == DATA_HI_COLUMN);\n\n    // create a place holder for new value\n    NSMutableData * mdata = [NSMutableData dataWithCapacity:[cellContent length] / 3]; // each element = one byte plus space\n    \n    // fill in placeholder\n    while ([scanner isAtEnd] == NO)\n    {\n      unsigned value;\n      \n      scanResult = [scanner scanHexInt:&value];\n      if (scanResult == NO)\n      {\n        NSAssert(NO, MVScannerErrorMessage);\n        return;\n      }\n      \n      [mdata appendBytes:&value length:sizeof(uint8_t)];\n    }\n    \n    // replace data with the new value\n    [document.dataController.fileData replaceBytesInRange:NSMakeRange(fileOffset, [mdata length]) \n                                                withBytes:[mdata bytes]];\n    \n    // do not need to update cell content...\n  }\n\n  // set document to dirty\n  [document updateChangeCount:NSChangeDone];\n}\n//----------------------------------------------------------------------------\n\n\n\n@end\n"
        },
        {
          "name": "Document.h",
          "type": "blob",
          "size": 1.1845703125,
          "content": "/*\n *  Document.h\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#include <atomic>\n\n@class MVDataController;\n\n@interface MVOutlineView : NSOutlineView\n{\n}\n@end\n\n@interface MVTableView : NSTableView\n{\n}\n@end\n\n@interface MVRightFormatter : NSFormatter\n{\n  BOOL        compound;   // NO: plain hex;     YES: groups of bytes (11 22 33 44 55)\n  NSUInteger  length;     // size of hex value; number of bytes \n  BOOL        alignLeft;  // NO: 12 --> 0012    YES: 12 --> 1200\n}\n@end\n\n@interface MVDocument : NSDocument\n{\n  IBOutlet MVOutlineView *        leftView;\n  IBOutlet MVTableView *          rightView;\n  IBOutlet NSSearchField *        searchField;\n  IBOutlet NSTextField *          statusText;\n  IBOutlet NSProgressIndicator *  progressIndicator;\n  IBOutlet NSSegmentedControl *   offsetModeSwitch;\n  IBOutlet NSButton *             stopButton;\n  MVDataController *              dataController;\n  std::atomic<std::int32_t>       threadCount;\n}\n@property (nonatomic,readonly) MVDataController * dataController;\n\n- (IBAction)updateSearchFilter:(id)sender;\n- (IBAction)updateAddressingMode:(id)sender;\n- (IBAction)stopProcessing:(id)sender;\n- (BOOL)isRVA;\n\n+ (NSString *)temporaryDirectory;\n\n@end\n"
        },
        {
          "name": "Document.mm",
          "type": "blob",
          "size": 25.54296875,
          "content": "/*\n *  MVDocument.mm\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cxxabi.h>\n\n#import \"Common.h\"\n#import \"Document.h\"\n#import \"DataController.h\"\n#import \"Layout.h\"\n#include <unistd.h>\n\n//============================================================================\n@implementation MVOutlineView\n\n/*\n//----------------------------------------------------------------------------\n- (void)mouseDown:(NSEvent *)theEvent\n{\n  // Control+Click invokes that the selected node will not be swapped out\n  if ([theEvent modifierFlags] & NSControlKeyMask)\n  {\n    NSPoint event_location = [theEvent locationInWindow];\n    NSPoint local_point = [self convertPoint:event_location fromView:nil];\n    MVNode * node = [self itemAtRow:[self rowAtPoint:local_point]];\n    \n    // note: offset should not be zero for explicit change of dirty indicator\n    if (node.details != nil)\n    {\n      node.dirty = !node.dirty;\n      [self reloadItem:node];\n      NSLog(@\"%@: node: %@ becomes %@\", self, node, node.dirty ? @\"dirty\" : @\"clean\");\n    }\n  }\n\n  [super mouseDown:theEvent];\n}\n*/\n\n@end\n\n\n//============================================================================\n@implementation MVTableView\n\n//----------------------------------------------------------------------------\n- (void)drawGridInClipRect:(NSRect)clipRect\n{\n  MVDocument * document = [[[self window] windowController] document];\n  \n  NSRange rowRange = [self rowsInRect:clipRect];\n  \n  // Adjust column range, always go from zero, so we can gather columns even to \n  // the left of what we are supposed to draw.\n  [[NSColor grayColor] set];\n  for (NSUInteger rowIndex = rowRange.location ;\n       rowIndex < NSMaxRange(rowRange) ;\n       rowIndex++ )\n  {\n    MVRow * row = [document.dataController.selectedNode.details getRowToDisplay:rowIndex];\n    if (row == nil)\n    {\n      continue;\n    }\n    \n    if ([[row.attributes objectForKey:MVUnderlineAttributeName] isEqualToString:@\"YES\"])\n    {\n      NSRect rowRect = [self rectOfRow:rowIndex];\n      \n      [NSBezierPath strokeLineFromPoint:NSMakePoint(rowRect.origin.x,\n                                                    -0.5+rowRect.origin.y+rowRect.size.height)\n                                toPoint:NSMakePoint(rowRect.origin.x + rowRect.size.width,\n                                                    -0.5+rowRect.origin.y+rowRect.size.height)];\n    }\n  }\n  //[super drawGridInClipRect:clipRect];\n}\n\n//----------------------------------------------------------------------------\n- (void)highlightSelectionInClipRect:(NSRect)clipRect\n{\n  MVDocument * document = [[[self window] windowController] document];\n  \n  NSRange rowRange = [self rowsInRect:clipRect];\n  \n  for (NSUInteger rowIndex = rowRange.location ;\n       rowIndex < NSMaxRange(rowRange) ;\n       rowIndex++ )\n  {\n    MVRow * row = [document.dataController.selectedNode.details getRowToDisplay:rowIndex];\n    if (row == nil)\n    {\n      continue;\n    }\n    \n    NSColor * color = [row.attributes objectForKey:MVCellColorAttributeName];\n    if (color != nil)\n    {      \n      NSColor * bgcolor = [[NSColor controlAlternatingRowBackgroundColors] objectAtIndex:rowIndex % 2];\n      \n      [[color blendedColorWithFraction:0.85f ofColor:bgcolor] setFill];\n      \n      NSRect rowRect = [self rectOfRow:rowIndex];\n      NSRectFill (rowRect);\n    }\n  }\n  [super highlightSelectionInClipRect: clipRect];\n}\n\n//----------------------------------------------------------------------------\n- (void)cancelOperation:(id)sender\n{\n  // I have no idea why NSTableView (or one of its parents) does not implement\n  // 'cancel editing' functionality by default....\n  // so, let's do it for ourselves\n  \n  if ([self currentEditor] != nil)\n  {\n    [self abortEditing];\n    \n    // We lose focus so re-establish\n    [[self window] makeFirstResponder:self];\n  }\n}\n\n@end\n\n//============================================================================\n@implementation MVRightFormatter\n\n//----------------------------------------------------------------------------\n- (instancetype)init\n{\n  NSAssert(NO, @\"plain init is not allowed\");\n  return nil;\n}\n\n//-----------------------------------------------------------------------------\n- (instancetype)initPlainWithLength:(NSUInteger)len\n{\n  if (self = [super init])\n  {\n    compound = NO;\n    length = len;\n    alignLeft = NO;\n  }\n  return self;\n}\n\n//----------------------------------------------------------------------------\n- (instancetype)initLeftAlignedWithLength:(NSUInteger)len\n{\n  if (self = [super init])\n  {\n    compound = NO;\n    length = len;\n    alignLeft = YES;\n  }\n  return self;\n}\n\n//----------------------------------------------------------------------------\n- (instancetype)initCompoundWithLength:(NSUInteger)len\n{\n  if (self = [super init])\n  {\n    compound = YES;\n    length = len;\n    alignLeft = NO;\n  }\n  return self;\n}\n\n//----------------------------------------------------------------------------\n+ (MVRightFormatter *)plainFormatterWithLength:(NSUInteger)len\n{\n  return [[MVRightFormatter alloc] initPlainWithLength:len];\n}\n\n//----------------------------------------------------------------------------\n+ (MVRightFormatter *)leftAlignedFormatterWithLength:(NSUInteger)len\n{\n  return [[MVRightFormatter alloc] initLeftAlignedWithLength:len];\n}\n\n//----------------------------------------------------------------------------\n+ (MVRightFormatter *)compoundFormatterWithLength:(NSUInteger)len\n{\n  return [[MVRightFormatter alloc] initCompoundWithLength:len];\n}\n\n//----------------------------------------------------------------------------\n- (NSString *)stringForObjectValue:(id)anObject\n{\n  if ([anObject isKindOfClass:[NSAttributedString class]])\n  {\n    return [anObject string]; \n  }\n  return anObject;\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)getObjectValue:(id *)anObject \n             forString:(NSString *)string \n      errorDescription:(NSString **)error\n{\n  if (compound)\n  {\n    (*anObject) = string;\n  } \n  else\n  {\n    // put leading zeroes in order to preserve the original length\n    NSUInteger numZeroes = length - [string length];\n    NSMutableString * zeroes = [[NSMutableString alloc] initWithCapacity:numZeroes];\n    while (numZeroes-- > 0)\n    {\n      [zeroes appendString:@\"0\"];\n    }\n    (*anObject) = [NSString  stringWithFormat:@\"%@%@\", \n                   alignLeft ? string : zeroes, \n                   alignLeft ? zeroes : string];\n  }\n\n  return YES;\n}\n\n//----------------------------------------------------------------------------\n- (NSAttributedString *)attributedStringForObjectValue:(id)anObject \n                                 withDefaultAttributes:(NSDictionary *)attributes\n{\n  if ([anObject isKindOfClass:[NSAttributedString class]])\n  {\n    return anObject;\n  }\n  return nil;\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)isPartialStringValid:(NSString **)partialStringPtr \n       proposedSelectedRange:(NSRangePointer)proposedSelRangePtr \n              originalString:(NSString *)origString \n       originalSelectedRange:(NSRange)origSelRange \n            errorDescription:(NSString **)error\n{\n  NSScanner * scanner = [NSScanner scannerWithString:*partialStringPtr];\n\n  if (compound)\n  // option 1: formatted hex value (11 22 33 44 55 66 77 88 )\n  {\n    [scanner setCharactersToBeSkipped:[NSCharacterSet whitespaceCharacterSet]];\n    \n    NSUInteger numBytes = length;\n    while ([scanner isAtEnd] == NO)\n    {\n      unsigned value;\n      \n      // value needs to be hex and number of bytes is determined\n      if ([scanner scanHexInt:&value] == NO || value > 0xff || numBytes == 0)\n      {\n        return NO;\n      }\n\n      --numBytes;\n    }\n    \n  }\n  else\n  // option 2: plain hex value\n  {\n    [scanner setCharactersToBeSkipped:nil];\n    \n    NSCharacterSet * characterSet = [NSCharacterSet characterSetWithCharactersInString:@\"0123456789ABCDEFabcdef\"];\n    while ([scanner isAtEnd] == NO)\n    {\n      // must be a valid hex value\n      if ([scanner scanCharactersFromSet:characterSet intoString:NULL] == NO)\n      {\n        return NO;\n      }\n      \n      // apply upper limit on length\n      if ([*partialStringPtr length] > length)\n      {\n        return NO;\n      }\n    }\n  }\n  \n  return YES;\n}\n\n\n@end\n\n//============================================================================\n@implementation MVDocument\n\n@synthesize dataController;\n\nenum ViewType\n{    \n  e_details,\n  e_details64,\n  e_hex,\n  e_hex64,\n};\n\n//----------------------------------------------------------------------------\n+ (NSString *)temporaryDirectory\n{\n  NSProcessInfo * procInfo = [NSProcessInfo processInfo];\n  NSBundle * mainBundle = [NSBundle mainBundle];\n  \n  NSString * swapDir = [NSString stringWithFormat:@\"%@%@_%@.XXXXXXXXXXX\",\n                        NSTemporaryDirectory(),\n                        [procInfo processName],\n                        [mainBundle objectForInfoDictionaryKey:@\"CFBundleShortVersionString\"]];\n  \n  return swapDir;\n}\n\n//-----------------------------------------------------------------------------\n- (instancetype)init\n{\n  self = [super init];\n  if (self) \n  {\n    dataController = [[MVDataController alloc] init];\n    threadCount = 0;\n    \n    NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n    typeof(self) __weak weakSelf = self;\n    \n    /*\n    [nc addObserver:weakSelf\n           selector:@selector(handleDataTreeWillChange:) \n               name:MVDataTreeWillChangeNotification\n             object:nil]; \n    \n    [nc addObserver:weakSelf\n           selector:@selector(handleDataTreeDidChange:) \n               name:MVDataTreeDidChangeNotification\n             object:nil]; \n    */\n    [nc addObserver:weakSelf\n           selector:@selector(handleDataTreeChanged:) \n               name:MVDataTreeChangedNotification\n             object:nil]; \n    \n    [nc addObserver:weakSelf\n           selector:@selector(handleDataTableChanged:) \n               name:MVDataTableChangedNotification\n             object:nil]; \n\n    [nc addObserver:weakSelf \n           selector:@selector(handleThreadStateChanged:) \n               name:MVThreadStateChangedNotification\n             object:nil];\n  }\n  return self;\n}\n\n//----------------------------------------------------------------------------\n- (NSString *)windowNibName \n{\n  // Implement this to return a nib to load OR implement -makeWindowControllers to manually create your controllers.\n  return @\"Layout\";\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)isRVA\n{\n  return ([offsetModeSwitch selectedSegment] == 1 ? YES : NO);\n}\n\n//----------------------------------------------------------------------------\n- (void)handleDataTreeWillChange:(NSNotification *)notification\n{\n  if ([notification object] == dataController)\n  {\n    // lock treeView\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)handleDataTreeDidChange:(NSNotification *)notification\n{\n  if ([notification object] == dataController)\n  {\n    // unlock treeView\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)handleDataTreeChanged:(NSNotification *)notification\n{\n  if ([notification object] == dataController) {\n    dispatch_async(dispatch_get_main_queue(), ^\n    {\n      // Update UI here, on the main queue\n      NSDictionary * userInfo = [notification userInfo];\n      if (userInfo) {\n        //refresh the modified node only\n        MVNode * node = [userInfo objectForKey:MVNodeUserInfoKey];\n      \n        // check if the window still exists which contains the leftView to update\n        if ([[self windowControllers] count] == 0) {\n          return;\n        }\n        \n          [self->leftView reloadItem:node.parent];\n     \n          if ([self->leftView isItemExpanded:node.parent]) {\n            [self->leftView reloadItem:node];\n          }\n      } else {\n          [self->leftView reloadItem:self->dataController.rootNode reloadChildren:YES];\n      }\n    });\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)handleDataTableChanged:(NSNotification *)notification\n{\n  if ([notification object] == dataController)\n  {\n    [rightView noteNumberOfRowsChanged];\n    [rightView reloadData];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)handleThreadStateChanged:(NSNotification *)notification\n{\n    if ([notification object] == dataController) {\n        NSString * threadState = [[notification userInfo] objectForKey:MVStatusUserInfoKey];\n        if ([threadState isEqualToString:MVStatusTaskStarted] == YES) {\n            if (++threadCount == 1) {\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    [self->progressIndicator setUsesThreadedAnimation:YES];\n                    [self->progressIndicator startAnimation:nil];\n                    [self->stopButton setHidden:NO];\n                });\n            }\n        }\n        else if ([threadState isEqualToString:MVStatusTaskTerminated] == YES) {\n            if (--threadCount == 0) {\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    [self->progressIndicator stopAnimation:nil];\n                    [self->statusText setStringValue:@\"\"];\n                    [self->stopButton setHidden:YES];\n                });\n            }\n        }\n    }\n}\n\n//----------------------------------------------------------------------------\n- (void)windowControllerDidLoadNib:(NSWindowController *)aController\n{\n  [super windowControllerDidLoadNib:aController];\n  \n  // fill in initial data sources\n  [statusText setStringValue:@\"Loading...\"];\n  for (MVLayout * layout in dataController.layouts)\n  {\n    [layout doMainTasks];\n  }\n  \n  // refresh initial view\n  [leftView reloadData];\n  [leftView expandItem:dataController.rootNode];\n  \n  // finish processing in background\n  [statusText setStringValue:@\"Processing in background...\"];\n  for (MVLayout * layout in dataController.layouts)\n  {\n#ifdef MV_NO_MULTITHREAD\n    [layout doBackgroundTasks];\n#else\n    [layout.backgroundThread start];\n#endif\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)awakeFromNib\n{\n  [rightView setDoubleAction:@selector(rightViewDoubleAction:)];\n  [rightView setTarget:self];\n}\n\n//----------------------------------------------------------------------------\n- (NSData *)dataOfType:(NSString *)typeName error:(NSError **)outError\n{\n  return dataController.fileData;\n}\n\n//----------------------------------------------------------------------------\n- (BOOL)readFromURL:(NSURL *)absoluteURL ofType:(NSString *)typeName error:(NSError **)outError\n{\n    // create a temporary copy for patching\n    const char *tmp = [[MVDocument temporaryDirectory] UTF8String];\n    char *tmpFilePath = strdup(tmp);\n    int fd = mkstemp(tmpFilePath);\n    if (fd < 0) {\n        NSLog(@\"mktemp failed!\");\n        free(tmpFilePath);\n        return NO;\n    }\n    \n    NSURL * tmpURL = [NSURL fileURLWithPath:[NSString stringWithUTF8String:tmpFilePath]];\n    free(tmpFilePath);\n    \n    // open the original binary for viewing/editing\n    dataController.fileName = [absoluteURL path];\n    dataController.fileData = [NSMutableData dataWithContentsOfURL:absoluteURL\n                                                           options:NSDataReadingMappedIfSafe\n                                                             error:outError];\n    if (*outError) return NO;\n    \n    // copy the file - the original code used NSFileManager but that doesn't work with mkstemp()\n    // [NSFileHandle writeData] is 10.15+ only\n    // https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html\n    if (write(fd, [dataController.fileData bytes], [dataController.fileData length]) != (ssize_t)[dataController.fileData length]) {\n        NSLog(@\"Write failed: %s\", strerror(errno));\n        return NO;\n    }\n    close(fd);\n\n    // open the copied binary for patching\n    dataController.realData = [NSMutableData dataWithContentsOfURL:tmpURL\n                                                           options:NSDataReadingMappedAlways\n                                                             error:outError];\n    if (*outError) return NO;\n  \n    @try\n    {\n        [dataController createLayouts:dataController.rootNode location:0 length:[dataController.fileData length]];\n    }\n    @catch (NSException * exception)\n    {\n        *outError = [NSError errorWithDomain:NSCocoaErrorDomain\n                                        code:NSFileReadUnknownError\n                                    userInfo:[NSDictionary dictionaryWithObjectsAndKeys:\n                                              [[self fileURL] path], NSFilePathErrorKey,\n                                              [exception reason], NSLocalizedDescriptionKey,\n                                              nil]];\n        return NO;\n    }\n                             \n    return YES;                             \n}\n\n//----------------------------------------------------------------------------\n- (void)saveDocumentWithDelegate:(id)delegate didSaveSelector:(SEL)didSaveSelector contextInfo:(void *)contextInfo\n{\n  if (delegate != nil)\n  {\n    [self runModalSavePanelForSaveOperation:NSSaveAsOperation\n                                   delegate:delegate \n                            didSaveSelector:didSaveSelector \n                                contextInfo:contextInfo];\n  }\n  else\n  {\n    [super saveDocumentWithDelegate:delegate \n                    didSaveSelector:didSaveSelector\n                        contextInfo:contextInfo];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (IBAction)updateSearchFilter:(id)sender\n{\n  NSString * filter = [searchField stringValue];\n  if (dataController.selectedNode.details != nil)\n  {\n    [dataController.selectedNode filterDetails:filter];\n    [rightView reloadData];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (IBAction)updateAddressingMode:(id)sender\n{\n  // send notification as if the tree has changed\n  NSNotificationCenter * nc = [NSNotificationCenter defaultCenter];\n  [nc postNotificationName:NSOutlineViewSelectionDidChangeNotification\n                    object:leftView];\n}\n\n//----------------------------------------------------------------------------\n- (IBAction)stopProcessing:(id)sender\n{\n  // stopping threads takes time so disable the stop button to give a feedback\n  // and preserve from further clicks\n  [stopButton setEnabled:NO];\n  \n  // stop every background task\n  for (MVLayout * layout in dataController.layouts)\n  {\n    [layout.backgroundThread cancel];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (IBAction)rightViewDoubleAction:(id)sender \n{\n  NSParameterAssert(sender == rightView);\n           \n  NSInteger colIndex = [sender clickedColumn];\n  NSInteger rowIndex = [sender clickedRow];\n  \n  if ([[[rightView tableColumns] objectAtIndex:colIndex] isEditable])\n  {\n    if (dataController.selectedNode.details != nil)\n    {\n      MVRow * row = [dataController.selectedNode.details getRowToDisplay:rowIndex];\n      if (row == nil)\n      {\n        return;\n      }\n      \n      NSString * cellContent = [row columnAtIndex:colIndex];\n      if ([cellContent length] == 0)\n      {\n        return;\n      }\n    }\n    [rightView editColumn:colIndex row:rowIndex withEvent:nil select:YES];\n    return;\n  }\n  \n  \n  // jump to symbol definition\n  if (colIndex == VALUE_COLUMN)\n  {\n    // determine symbol type (local, public, external)\n  \n    //NSIndexSet * indexes;\n    //[leftView selectRowIndexes:indexes byExtendingSelection:NO];\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)changeView:(ViewType)viewType\n{\n  //get current values\n  NSTableColumn * column0 = [[rightView tableColumns] objectAtIndex:0];\n  NSTableColumn * column1 = [[rightView tableColumns] objectAtIndex:1];\n  NSTableColumn * column2 = [[rightView tableColumns] objectAtIndex:2];\n  NSTableColumn * column3 = [[rightView tableColumns] objectAtIndex:3];\n  \n  switch (viewType)\n  {\n    case e_details:       \n    case e_details64:\n      [[column0 headerCell] setStringValue:[self isRVA] == NO ? @\"Offset\" : @\"Address\"];\n      [[column1 headerCell] setStringValue:@\"Data\"];\n      [[column2 headerCell] setStringValue:@\"Description\"];\n      [[column3 headerCell] setStringValue:@\"Value\"]; \n      \n      [column0 setEditable:NO];\n      [column1 setEditable:YES];\n      [column2 setEditable:NO];\n      [column3 setEditable:NO];\n      break;\n      \n    case e_hex:\n    case e_hex64:\n      [[column0 headerCell] setStringValue:[self isRVA] == NO ? @\"pFile\" : @\"Address\"];\n      [[column1 headerCell] setStringValue:@\"Data LO\"];\n      [[column2 headerCell] setStringValue:@\"Data HI\"];\n      [[column3 headerCell] setStringValue:@\"Value\"];\n      \n      [column0 setEditable:NO];\n      [column1 setEditable:YES];\n      [column2 setEditable:YES];\n      [column3 setEditable:NO];      \n      break;\n      \n    default:; // do not change current view\n  }\n}\n\n//----------------------------------------------------------------------------\n- (void)canCloseDocumentWithDelegate:(id)delegate shouldCloseSelector:(SEL)shouldCloseSelector contextInfo:(void *)contextInfo\n{\n  [[NSNotificationCenter defaultCenter] removeObserver:self];\n\n  for (MVLayout * layout in dataController.layouts)\n  {\n    [layout.backgroundThread cancel];\n  }\n   \n  [super canCloseDocumentWithDelegate:delegate shouldCloseSelector:shouldCloseSelector contextInfo:contextInfo];\n}\n\n\n#pragma mark responders for UI events\n\n//----------------------------------------------------------------------------\n- (void)outlineViewSelectionDidChange:(NSNotification *)notification\n{\n  if ([notification object] == leftView)\n  {\n    NSInteger rowIndex = [leftView selectedRow];\n    MVNode * nodeToSelect = [leftView itemAtRow:rowIndex];\n    \n    if (dataController.selectedNode != nodeToSelect)\n    {\n      // close old details\n      if (dataController.selectedNode.detailsOffset != 0)\n      {\n        // release swap file\n        [dataController.selectedNode closeDetails];\n        \n        // kick out from memory\n        dataController.selectedNode.details = nil;\n      }\n      \n      // open new details\n      [nodeToSelect openDetails];\n      \n      // reset filter on node change\n      [nodeToSelect filterDetails:nil];\n      \n      // swap nodes\n      dataController.selectedNode = nodeToSelect;\n    }\n  \n    MVLayout * layout = [nodeToSelect.userInfo objectForKey:MVLayoutUserInfoKey];\n    BOOL is64bit = [layout is64bit];\n  \n    if (nodeToSelect.details != nil)\n    {\n      [self changeView:is64bit == NO ? e_details : e_details64];\n    }\n    else \n    {\n      [self changeView:is64bit == NO ? e_hex : e_hex64];\n    }\n    \n    [rightView reloadData];\n  }\n}\n\n//----------------------------------------------------------------------------\n// set up the formatter for editable cells\n//----------------------------------------------------------------------------\n- (void)tableView:(NSTableView *)aTableView \n  willDisplayCell:(id)aCell \n   forTableColumn:(NSTableColumn *)aTableColumn \n              row:(NSInteger)rowIndex\n{\n  if (aTableView == rightView)\n  {\n    if (dataController.selectedNode.details != nil)\n    {\n      MVRow * row = [dataController.selectedNode.details getRowToDisplay:rowIndex];\n      if (row == nil)\n      {\n        return;\n      }\n      \n      NSUInteger len = [row.columns.dataStr length];\n      \n      [aCell setFormatter:len > 16\n       ? [MVRightFormatter leftAlignedFormatterWithLength:len] \n       : [MVRightFormatter plainFormatterWithLength:len]];\n    }\n    else\n    {\n      NSUInteger colIndex = [[aTableView tableColumns] indexOfObject:aTableColumn];\n      NSUInteger len = MIN(dataController.selectedNode.dataRange.length - rowIndex * 16, (NSUInteger)16);\n      \n      if (colIndex == DATA_LO_COLUMN)\n      {\n        [aCell setFormatter:[MVRightFormatter compoundFormatterWithLength:len > 8 ? 8 : len]];\n      }\n      else if (colIndex == DATA_HI_COLUMN)\n      {\n        [aCell setFormatter:[MVRightFormatter compoundFormatterWithLength:len > 8 ? len - 8 : 0]];\n      }\n    }\n  }\n}\n\n//----------------------------------------------------------------------------\n// TODO: show different tooltips for each if the cell contains more then one symbol\n//----------------------------------------------------------------------------\n- (NSString *)tableView:(NSTableView *)aTableView \n         toolTipForCell:(NSCell *)aCell \n                   rect:(NSRectPointer)rect \n            tableColumn:(NSTableColumn *)aTableColumn \n                    row:(NSInteger)rowIndex \n          mouseLocation:(NSPoint)mouseLocation\n{\n  if (aTableView == rightView)\n  {\n    MVRow * row = [dataController.selectedNode.details getRowToDisplay:rowIndex];\n    if (row == nil)\n    {\n      return nil;\n    }\n      \n    NSUInteger colIndex = [[aTableView tableColumns] indexOfObject:aTableColumn];\n    NSString * cellContent = [row columnAtIndex:colIndex];\n    \n    // try to find C,C++ symbol prologue\n    NSUInteger start = [cellContent rangeOfString:@\"_Z\"].location;\n\n    if (start == NSNotFound)\n    {\n      return nil;\n    }\n\n    NSUInteger stop = [cellContent rangeOfCharacterFromSet:[NSCharacterSet characterSetWithCharactersInString:@\")]\"]\n                                                   options:NSLiteralSearch\n                                                     range:NSMakeRange(start, [cellContent length] - start)].location;\n    if (stop == NSNotFound)\n    {\n      stop = [cellContent length];\n    }\n    \n    char const * cell_str = CSTRING([cellContent substringWithRange:NSMakeRange(start, stop - start)]);\n\n    int status;\n    char * sym_str = abi::__cxa_demangle (cell_str, NULL, NULL, &status);\n    if (status == 0)\n    {\n      NSString * toolTip= NSSTRING(sym_str);\n      free(sym_str);\n      return toolTip;\n    }\n  }\n  \n  return nil;\n}\n\n\n@end\n"
        },
        {
          "name": "DyldInfo.h",
          "type": "blob",
          "size": 1.2568359375,
          "content": "/*\n *  DyldInfo.h\n *  MachOView\n *\n *  Created by psaghelyi on 21/09/2010.\n *\n */\n\n#import \"MachOLayout.h\"\n\n\n@interface DyldHelper : NSObject\n{\n  NSMutableDictionary * externalMap; // external symbol name --> symbols index (negative number)\n}\n\n+(DyldHelper *) dyldHelperWithSymbols:(NSDictionary *)symbolNames is64Bit:(bool)is64Bit;\n\n@end\n\n\n@interface MachOLayout (DyldInfo)\n\nenum BindNodeType {NodeTypeBind, NodeTypeWeakBind, NodeTypeLazyBind};\n\n- (MVNode *)createRebaseNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n                 baseAddress:(uint64_t)baseAddress;\n\n- (MVNode *)createBindingNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n                       length:(uint64_t)length\n                  baseAddress:(uint64_t)baseAddress\n                     nodeType:(BindNodeType)nodeType\n                   dyldHelper:(DyldHelper *)helper;\n\n- (MVNode *)createExportNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n                 baseAddress:(uint64_t)baseAddress;\n\n@end\n"
        },
        {
          "name": "DyldInfo.mm",
          "type": "blob",
          "size": 35.6142578125,
          "content": "/*\n *  DyldInfo.mm\n *  MachOView\n *\n *  Created by psaghelyi on 21/09/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#import \"Common.h\"\n#import \"DyldInfo.h\"\n#import \"ReadWrite.h\"\n#import \"DataController.h\"\n#import <mach-o/loader.h>\n\nusing namespace std;\n\n\n//============================================================================\n@implementation DyldHelper\n\n//-----------------------------------------------------------------------------\n- (instancetype) initWithSymbols:(NSDictionary *)symbolNames is64Bit:(bool)is64Bit\n{\n  if (self = [super init])\n  {\n    externalMap = [[NSMutableDictionary alloc] initWithCapacity:[symbolNames count]];\n    \n    NSEnumerator * enumerator = [symbolNames keyEnumerator];\n    id key;\n    while ((key = [enumerator nextObject]) != nil) \n    {\n      NSNumber * symbolIndex = (NSNumber *)key;\n      // negative index indicates that it is external\n      if ((is64Bit == NO && (int32_t)[symbolIndex unsignedLongValue] < 0) ||\n          (int64_t)[symbolIndex unsignedLongLongValue] < 0)\n      {\n        [externalMap setObject:key forKey:[symbolNames objectForKey:key]];\n      }\n    }\n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n+(DyldHelper *) dyldHelperWithSymbols:(NSDictionary *)symbolNames is64Bit:(bool)is64Bit\n{\n  return [[DyldHelper alloc] initWithSymbols:symbolNames is64Bit:is64Bit];\n}\n\n//-----------------------------------------------------------------------------\n-(NSNumber *) indexForSymbol:(NSString *)symbolName\n{\n  return [externalMap objectForKey:symbolName];\n}\n\n@end\n\n\n//============================================================================\n@implementation MachOLayout (DyldInfo)\n\n\n//-----------------------------------------------------------------------------\n- (void)rebaseAddress:(uint64_t)address \n                 type:(uint32_t)type \n                 node:(MVNode *)node\n             location:(uint64_t)location\n{\n  NSString * descStr = [NSString stringWithFormat:@\"%@ 0x%qX %@\",\n                        [self findSectionContainsRVA:address],\n                        address,\n                        type == REBASE_TYPE_POINTER ? @\"Pointer\" :\n                        type == REBASE_TYPE_TEXT_ABSOLUTE32 ? @\"Abs32  \" :\n                        type == REBASE_TYPE_TEXT_PCREL32 ? @\"PCrel32\" : @\"???\"];\n  \n  [node.details appendRow:[NSString stringWithFormat:@\"%.8qX\", location]\n                         :@\"\"\n                         :descStr\n                         :@\"\"];\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createRebaseNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n                 baseAddress:(uint64_t)baseAddress\n{\n  MVNode * dataNode = [self createDataNode:parent \n                                   caption:caption \n                                  location:location \n                                    length:length];\n\n  MVNodeSaver nodeSaver;\n  MVNode * node = [dataNode insertChildWithDetails:@\"Opcodes\" location:location length:length saver:nodeSaver];\n  \n  MVNodeSaver actionNodeSaver;\n  MVNode * actionNode = [dataNode insertChildWithDetails:@\"Actions\" location:location length:length saver:actionNodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;  \n\n  BOOL isDone = NO;\n  \n  uint64_t ptrSize = ([self is64bit] == NO ? sizeof(uint32_t) : sizeof(uint64_t));\n  uint64_t address = baseAddress;\n  uint32_t type = 0;\n  \n  uint64_t doRebaseLocation = location;\n  \n  while (NSMaxRange(range) < location + length && isDone == NO)\n  {\n    uint8_t byte = [dataController read_int8:range lastReadHex:&lastReadHex];\n    uint8_t opcode = byte & REBASE_OPCODE_MASK;\n    uint8_t immediate = byte & REBASE_IMMEDIATE_MASK;\n    \n    switch (opcode) \n    {\n      case REBASE_OPCODE_DONE:\n        isDone = YES;\n\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_DONE\"\n                               :@\"\"];\n        break;\n        \n      case REBASE_OPCODE_SET_TYPE_IMM:\n        {\n            type = immediate;\n            NSString *typeString = [NSString alloc];\n            switch (type)\n            {\n                case REBASE_TYPE_POINTER:\n                    typeString = [typeString initWithString:@\"REBASE_TYPE_POINTER\"];\n                    break;\n                case REBASE_TYPE_TEXT_ABSOLUTE32:\n                    typeString  = [typeString initWithString:@\"REBASE_TYPE_TEXT_ABSOLUTE32\"];\n                    break;\n                case REBASE_TYPE_TEXT_PCREL32:\n                    typeString = [typeString initWithString:@\"REBASE_TYPE_TEXT_PCREL32\"];\n                    break;\n                default:\n                    typeString = [typeString initWithString:@\"Unknown\"];\n            }\n            \n            [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                   :lastReadHex\n                                   :@\"REBASE_OPCODE_SET_TYPE_IMM\"\n                                   :[NSString stringWithFormat:@\"type (%i, %@)\", type, typeString]];\n            break;\n        }\n      case REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: \n      {\n        uint32_t segmentIndex = immediate;\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n                               :[NSString stringWithFormat:@\"segment (%u)\", segmentIndex]];\n         \n        uint64_t offset = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"offset (%qi)\",offset]];\n        \n        if (([self is64bit] == NO && segmentIndex >= segments.size()) || \n            ([self is64bit] == YES && segmentIndex >= segments_64.size())) \n        {\n          [NSException raise:@\"Segment\"\n                      format:@\"index is out of range %u\", segmentIndex];\n        }\n        \n        address = ([self is64bit] == NO ? segments.at(segmentIndex)->vmaddr \n                                        : segments_64.at(segmentIndex)->vmaddr) + offset;\n      } break;\n        \n      case REBASE_OPCODE_ADD_ADDR_ULEB: \n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_ADD_ADDR_ULEB\"\n                               :@\"\"];\n         \n        uint64_t offset = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"offset (%qi)\",offset]];\n        \n        address += offset;\n      } break;\n        \n      case REBASE_OPCODE_ADD_ADDR_IMM_SCALED:\n      {\n        uint32_t scale = immediate;\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_ADD_ADDR_IMM_SCALED\"\n                               :[NSString stringWithFormat:@\"scale (%u)\",scale]];\n        \n        address += scale * ptrSize;\n      } break;\n        \n      case REBASE_OPCODE_DO_REBASE_IMM_TIMES: \n      {\n        uint32_t count = immediate;\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_DO_REBASE_IMM_TIMES\"\n                               :[NSString stringWithFormat:@\"count (%u)\",count]];\n\n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        for (uint32_t index = 0; index < count; index++) \n        {\n          [self rebaseAddress:address type:type node:actionNode location:doRebaseLocation];\n          address += ptrSize;\n        }\n        \n        doRebaseLocation = NSMaxRange(range);\n        \n      } break;\n        \n      case REBASE_OPCODE_DO_REBASE_ULEB_TIMES: \n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_DO_REBASE_ULEB_TIMES\"\n                               :@\"\"];\n        \n        uint64_t startNextRebase = NSMaxRange(range);\n        \n        uint64_t count = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"count (%qu)\",count]];\n        \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        for (uint64_t index = 0; index < count; index++) \n        {\n          [self rebaseAddress:address type:type node:actionNode location:doRebaseLocation];\n          address += ptrSize;\n        }\n        \n        doRebaseLocation = startNextRebase;\n        \n      } break;\n        \n      case REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB: \n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB\"\n                               :@\"\"];\n        \n        uint64_t startNextRebase = NSMaxRange(range);\n        \n        uint64_t offset = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"offset (%qi)\",offset]];\n        \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        [self rebaseAddress:address type:type node:actionNode location:doRebaseLocation];\n        address += ptrSize + offset;\n        \n        doRebaseLocation = startNextRebase;\n        \n      } break;\n        \n      case REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB: \n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB\"\n                               :@\"\"];\n        \n        uint64_t startNextRebase = NSMaxRange(range);\n        \n        uint64_t count = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"count (%qu)\",count]];\n\n        uint64_t skip = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"skip (%qu)\",skip]];\n\n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        for (uint64_t index = 0; index < count; index++) \n        {\n          [self rebaseAddress:address type:type node:actionNode location:doRebaseLocation];\n          address += ptrSize + skip;\n        }\n        \n        doRebaseLocation = startNextRebase;\n        \n      } break;\n        \n      default:\n        [NSException raise:@\"Rebase info\" format:@\"Unknown opcode (%u %u)\", \n         ((uint32_t)-1 & opcode), ((uint32_t)-1 & immediate)];\n    }\n  }\n  \n  return node;\n}\n\n\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n\n\n\n//-----------------------------------------------------------------------------\n- (void)bindAddress:(uint64_t)address \n               type:(uint32_t)type \n         symbolName:(NSString *)symbolName \n              flags:(uint32_t)flags\n             addend:(int64_t)addend \n     libraryOrdinal:(int32_t)libOrdinal\n               node:(MVNode *)node\n           nodeType:(BindNodeType)nodeType\n           location:(uint64_t)location\n         dyldHelper:(DyldHelper *)helper\n            ptrSize:(size_t)ptrSize\n{\n  NSString * descStr = [NSString stringWithFormat:@\"%@ 0x%qX\", \n                        [self findSectionContainsRVA:address],\n                        address];\n  \n  if (nodeType != NodeTypeLazyBind)\n  {\n    descStr = [descStr stringByAppendingFormat:@\" %@ addend:%qi\",\n               type == BIND_TYPE_POINTER ? @\"Pointer\" :\n               type == BIND_TYPE_TEXT_ABSOLUTE32 ? @\"Abs32  \" :\n               type == BIND_TYPE_TEXT_PCREL32 ? @\"PCrel32\" : @\"type:???\",\n               addend];\n  }\n  \n  if ((flags & BIND_SYMBOL_FLAGS_WEAK_IMPORT) != 0)\n  {\n    descStr = [descStr stringByAppendingString:@\"[weak-ref]\"];\n  }\n  if ((flags & BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION) != 0)\n  {\n    descStr = [descStr stringByAppendingString:@\"[strong-def]\"];\n  }\n   \n  if (nodeType != NodeTypeWeakBind)\n  {\n    struct dylib const * dylib = [self getDylibByIndex:libOrdinal];\n    \n    descStr = [descStr stringByAppendingFormat:@\" (%@)\", \n               libOrdinal == BIND_SPECIAL_DYLIB_SELF ? @\"BIND_SPECIAL_DYLIB_SELF\" :\n               libOrdinal == BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE ? @\"BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE\" :\n               libOrdinal == BIND_SPECIAL_DYLIB_FLAT_LOOKUP ? @\"BIND_SPECIAL_DYLIB_FLAT_LOOKUP\" :\n               (uint32_t)libOrdinal >= dylibs.size() ? @\"???\" :\n                 [NSSTRING((uint8_t *)dylib + dylib->name.offset - sizeof(struct load_command)) lastPathComponent]];\n  }\n  \n  [node.details appendRow:[NSString stringWithFormat:@\"%.8qX\", location]\n                         :@\"\"\n                         :descStr\n                         :symbolName];\n\n  [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n  \n  // preserve binding info for reloc pathcing\n  if ([self isDylibStub] == NO && nodeType == NodeTypeBind) // weak and lazy does not count\n  {\n    NSParameterAssert(type == BIND_TYPE_POINTER); // only this one is supported so far\n    NSNumber * symbolIndex = [helper indexForSymbol:symbolName];\n    if (symbolIndex != nil)\n    {\n      uint64_t relocLocation;\n      uint64_t relocValue;\n      relocLocation = [self RVAToFileOffset:address];\n      if ([self is64bit] == NO) {\n        relocValue = [symbolIndex longValue];\n      }\n      else {\n        relocValue = [symbolIndex longLongValue];\n      }\n      \n      // update real data\n      relocValue += addend;\n      [dataController.realData replaceBytesInRange:NSMakeRange(relocLocation, ptrSize) withBytes:&relocValue];\n      \n      /*\n        NSLog(@\"%0xqX --> %0xqX\", \n              ([self is64bit] == NO ? [self fileOffsetToRVA:relocLocation] : [self fileOffsetToRVA64:relocLocation]),\n              relocValue);\n       */\n    }\n  }\n}\n//-----------------------------------------------------------------------------\n      \n- (MVNode *)createBindingNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n                       length:(uint64_t)length\n                  baseAddress:(uint64_t)baseAddress\n                     nodeType:(BindNodeType)nodeType\n                   dyldHelper:(DyldHelper *)helper\n{\n  MVNode * dataNode = [self createDataNode:parent \n                                   caption:caption \n                                  location:location \n                                    length:length];\n  \n  MVNodeSaver nodeSaver;\n  MVNode * node = [dataNode insertChildWithDetails:@\"Opcodes\" location:location length:length saver:nodeSaver];\n  \n  MVNodeSaver actionNodeSaver;\n  MVNode * actionNode = [dataNode insertChildWithDetails:@\"Actions\" location:location length:length saver:actionNodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  //----------------------------\n  \n  BOOL isDone = NO;\n  \n  int32_t libOrdinal = 0;\n  uint32_t type = 0;\n  int64_t addend = 0;\n  NSString * symbolName = nil;\n  uint32_t symbolFlags = 0;\n  \n  uint64_t doBindLocation = location;\n  \n  size_t ptrSize = ([self is64bit] == NO ? sizeof(uint32_t) : sizeof(uint64_t));\n  uint64_t address = baseAddress;\n  \n  while (NSMaxRange(range) < location + length && isDone == NO)\n  {\n    uint8_t byte = [dataController read_int8:range lastReadHex:&lastReadHex];\n    uint8_t opcode = byte & BIND_OPCODE_MASK;\n    uint8_t immediate = byte & BIND_IMMEDIATE_MASK;\n    \n    switch (opcode) \n    {\n      case BIND_OPCODE_DONE:\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_DONE\"\n                               :@\"\"];\n        \n        // The lazy bindings have one of these at the end of each bind.\n        if (nodeType != NodeTypeLazyBind)\n        {\n          isDone = YES;\n        }\n        \n        doBindLocation = NSMaxRange(range);\n        \n        break;\n        \n      case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n        libOrdinal = immediate;\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_SET_DYLIB_ORDINAL_IMM\"\n                               :[NSString stringWithFormat:@\"dylib (%d)\",libOrdinal]];\n        break;\n        \n      case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB\"\n                               :@\"\"];\n        // XXX: is this correct?\n        libOrdinal = (int32_t)[dataController read_uleb128:range lastReadHex:&lastReadHex];\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"dylib (%d)\",libOrdinal]];\n        break;\n        \n      case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM: \n      {\n        // Special means negative\n        if (immediate == 0)\n        {\n          libOrdinal = 0;\n        }\n        else \n        {\n          int8_t signExtended = immediate | BIND_OPCODE_MASK; // This sign extends the value\n          \n          libOrdinal = signExtended;\n        }\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_SET_DYLIB_SPECIAL_IMM\"\n                               :[NSString stringWithFormat:@\"dylib (%d)\",libOrdinal]];\n      } break;\n        \n      case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n        symbolFlags = immediate;\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM\"\n                               :[NSString stringWithFormat:@\"flags (%u)\",((uint32_t)-1 & symbolFlags)]];\n        \n        symbolName = [dataController read_string:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"string\"\n                               :[NSString stringWithFormat:@\"name (%@)\",symbolName]];\n        break;\n        \n      case BIND_OPCODE_SET_TYPE_IMM:\n        type = immediate;\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_SET_TYPE_IMM\"\n                               :[NSString stringWithFormat:@\"type (%@)\",\n                                 type == BIND_TYPE_POINTER ? @\"BIND_TYPE_POINTER\" :\n                                 type == BIND_TYPE_TEXT_ABSOLUTE32 ? @\"BIND_TYPE_TEXT_ABSOLUTE32\" :\n                                 type == BIND_TYPE_TEXT_PCREL32 ? @\"BIND_TYPE_TEXT_PCREL32\" : @\"???\"]];\n        break;\n        \n      case BIND_OPCODE_SET_ADDEND_SLEB:\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_SET_ADDEND_SLEB\"\n                               :@\"\"];\n        \n        addend = [dataController read_sleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"sleb128\"\n                               :[NSString stringWithFormat:@\"addend (%qi)\",addend]];\n        break;\n        \n      case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: \n      {\n        uint32_t segmentIndex = immediate;\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n                               :[NSString stringWithFormat:@\"segment (%u)\",segmentIndex]];\n        \n        uint64_t val = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"offset (%qi)\",val]];\n        \n        if (([self is64bit] == NO && segmentIndex >= segments.size()) || \n            ([self is64bit] == YES && segmentIndex >= segments_64.size())) \n        {\n          [NSException raise:@\"Segment\"\n                      format:@\"index is out of range %u\", segmentIndex];\n        }\n        \n        address = ([self is64bit] == NO ? segments.at(segmentIndex)->vmaddr \n                                        : segments_64.at(segmentIndex)->vmaddr) + val;\n      } break;\n        \n      case BIND_OPCODE_ADD_ADDR_ULEB: \n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_ADD_ADDR_ULEB\"\n                               :@\"\"];\n        \n        uint64_t val = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"offset (%qi)\",val]];\n\n        address += val;\n      } break;\n        \n      case BIND_OPCODE_DO_BIND:\n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_DO_BIND\"\n                               :@\"\"];\n        \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        [self bindAddress:address \n                     type:type \n               symbolName:symbolName \n                    flags:symbolFlags \n                   addend:addend \n           libraryOrdinal:libOrdinal \n                     node:actionNode\n                 nodeType:nodeType\n                 location:doBindLocation\n               dyldHelper:helper\n                  ptrSize:ptrSize];\n        \n        doBindLocation = NSMaxRange(range);\n        \n        address += ptrSize;\n      } break;\n        \n      case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB: \n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB\"\n                               :@\"\"];\n\n        uint64_t startNextBind = NSMaxRange(range);\n        \n        uint64_t val = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"offset (%qi)\",val]];\n        \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        [self bindAddress:address \n                     type:type \n               symbolName:symbolName \n                    flags:symbolFlags \n                   addend:addend \n           libraryOrdinal:libOrdinal \n                     node:actionNode\n                 nodeType:nodeType\n                 location:doBindLocation\n               dyldHelper:helper\n                  ptrSize:ptrSize];\n        \n        doBindLocation = startNextBind;\n        \n        address += ptrSize + val;\n      } break;\n        \n      case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n      {\n        uint32_t scale = immediate;\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED\"\n                               :[NSString stringWithFormat:@\"scale (%u)\",scale]];\n        \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        [self bindAddress:address \n                     type:type \n               symbolName:symbolName \n                    flags:symbolFlags \n                   addend:addend \n           libraryOrdinal:libOrdinal \n                     node:actionNode\n                 nodeType:nodeType\n                 location:doBindLocation\n               dyldHelper:helper\n                  ptrSize:ptrSize];\n        \n        doBindLocation = NSMaxRange(range);\n        \n        address += ptrSize + scale * ptrSize;\n      } break;\n        \n      case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB: \n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB\"\n                               :@\"\"];\n        \n        uint64_t startNextBind = NSMaxRange(range);\n        \n        uint64_t count = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"count (%qu)\",count]];\n        \n        uint64_t skip = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"uleb128\"\n                               :[NSString stringWithFormat:@\"skip (%qu)\",skip]];\n        \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        for (uint64_t index = 0; index < count; index++) \n        {\n          [self bindAddress:address \n                       type:type \n                 symbolName:symbolName \n                      flags:symbolFlags \n                     addend:addend \n             libraryOrdinal:libOrdinal \n                       node:actionNode\n                   nodeType:nodeType\n                   location:doBindLocation\n                 dyldHelper:helper\n                    ptrSize:ptrSize];\n          \n          doBindLocation = startNextBind;\n          \n          address += ptrSize + skip;\n        }\n      } break;\n        \n      default:\n        [NSException raise:@\"Bind info\" format:@\"Unknown opcode (%u %u)\", \n         ((uint32_t)-1 & opcode), ((uint32_t)-1 & immediate)];\n    }\n  }\n\n  return node;\n}\n//-----------------------------------------------------------------------------\n\n- (void)exportSymbol:(uint64_t)address \n          symbolName:(NSString *)symbolName\n               flags:(uint64_t)flags \n                node:(MVNode *)node\n            location:(uint64_t)location\n{\n  //uint64_t address = [self is64bit] == NO ? [self fileOffsetToRVA:offset] : [self fileOffsetToRVA64:offset];\n  \n  NSString * descStr = [NSString stringWithFormat:@\"%@ 0x%qX\",\n                        [self findSectionContainsRVA:address],\n                        address];\n  \n  if ((flags & EXPORT_SYMBOL_FLAGS_KIND_MASK) == EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL)\n  {\n    descStr = [descStr stringByAppendingString:@\" [thread-local]\"];\n  }\n\n  if (flags & EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION)\n  {\n    descStr = [descStr stringByAppendingString:@\" [weak-def]\"];\n  }\n\n  if (flags & EXPORT_SYMBOL_FLAGS_REEXPORT)\n  {\n    descStr = [descStr stringByAppendingString:@\" [reexport]\"];\n  }\n\n  if (flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER)\n  {\n    descStr = [descStr stringByAppendingString:@\" [stub & resolver]\"];\n  }\n  \n  [node.details insertRowWithOffset:location\n                                   :[NSString stringWithFormat:@\"%.8qX\", location]\n                                   :@\"\"\n                                   :descStr\n                                   :symbolName];\n  \n  [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n}\n//-----------------------------------------------------------------------------\n\n- (void)printSymbols:(NSString *)prefix                    \n            location:(uint64_t)location\n           skipBytes:(uint64_t)skip\n                node:(MVNode *)node\n          actionNode:(MVNode *)actionNode\n         baseAddress:(uint64_t)baseAddress\n      exportLocation:(uint64_t &)exportLocation\n{\n  NSRange range = NSMakeRange(location + skip,0);\n  NSString * lastReadHex;\n\n  uint8_t terminalSize = [dataController read_uint8:range lastReadHex:&lastReadHex];\n  [node.details insertRowWithOffset:range.location\n                                   :[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                   :lastReadHex\n                                   :@\"Terminal Size\"\n                                   :[NSString stringWithFormat:@\"%u\",((uint32_t)-1 & terminalSize)]];\n  \n  if (terminalSize != 0) \n  {\n    uint64_t terminalLocation = NSMaxRange(range);\n    \n    uint64_t flags = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n    [node.details insertRowWithOffset:range.location\n                                     :[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                     :lastReadHex\n                                     :@\"Flags\"\n                                     :@\"\"];\n\n    if ((flags & EXPORT_SYMBOL_FLAGS_KIND_MASK) == EXPORT_SYMBOL_FLAGS_KIND_REGULAR)      [node.details insertRowWithOffset:range.location:@\"\":@\"\":@\"00\":@\"EXPORT_SYMBOL_FLAGS_KIND_REGULAR\"];\n    if ((flags & EXPORT_SYMBOL_FLAGS_KIND_MASK) == EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL) [node.details insertRowWithOffset:range.location:@\"\":@\"\":@\"01\":@\"EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL\"];\n    if (flags & EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION)                                      [node.details insertRowWithOffset:range.location:@\"\":@\"\":@\"04\":@\"EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION\"];\n    if (flags & EXPORT_SYMBOL_FLAGS_REEXPORT)                                             [node.details insertRowWithOffset:range.location:@\"\":@\"\":@\"08\":@\"EXPORT_SYMBOL_FLAGS_REEXPORT\"];\n    if (flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER)                                    [node.details insertRowWithOffset:range.location:@\"\":@\"\":@\"10\":@\"EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER\"];\n    \n    uint64_t offset = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n    [node.details insertRowWithOffset:range.location\n                                     :[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                     :lastReadHex\n                                     :@\"Symbol Offset\"\n                                     :[NSString stringWithFormat:@\"0x%qX\",offset]];\n    \n    //=================================================================\n    [self exportSymbol:baseAddress + offset\n            symbolName:prefix\n                 flags:flags \n                  node:actionNode\n              location:exportLocation];\n    //=================================================================\n    \n    range = NSMakeRange(terminalLocation, terminalSize);\n  }\n  \n  uint8_t childCount = [dataController read_uint8:range lastReadHex:&lastReadHex];\n  [node.details insertRowWithOffset:range.location\n                                   :[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                   :lastReadHex\n                                   :@\"Child Count\"\n                                   :[NSString stringWithFormat:@\"%u\",((uint32_t)-1 & childCount)]];\n  \n  if (childCount == 0)\n  {\n    // separate export nodes\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  while (childCount-- > 0)\n  {\n    exportLocation = NSMaxRange(range);\n    \n    NSString * label = [dataController read_string:range lastReadHex:&lastReadHex];\n    [node.details insertRowWithOffset:range.location\n                                     :[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                     :lastReadHex\n                                     :@\"Node Label\"\n                                     :[NSString stringWithFormat:@\"\\\"%@\\\"\",label]];\n     \n    uint64_t skip = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n    [node.details insertRowWithOffset:range.location\n                                     :[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                     :lastReadHex\n                                     :@\"Next Node\"\n                                     :[NSString stringWithFormat:@\"0x%qX\",[self fileOffsetToRVA:location + skip]]];\n    \n    if (childCount == 0)\n    {\n      // separate export nodes\n      [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    }\n    \n    [self printSymbols:[NSString stringWithFormat:@\"%@%@\", prefix, label]\n              location:location\n             skipBytes:skip\n                  node:node \n            actionNode:actionNode\n           baseAddress:baseAddress\n        exportLocation:exportLocation];\n  }\n}\n//-----------------------------------------------------------------------------\n\n- (MVNode *)createExportNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n                 baseAddress:(uint64_t)baseAddress\n{\n  MVNode * dataNode = [self createDataNode:parent \n                                   caption:caption \n                                  location:location \n                                    length:length];\n  \n  MVNodeSaver nodeSaver;\n  MVNode * node = [dataNode insertChildWithDetails:@\"Opcodes\" location:location length:length saver:nodeSaver];\n  \n  MVNodeSaver actionNodeSaver;\n  MVNode * actionNode = [dataNode insertChildWithDetails:@\"Actions\" location:location length:length saver:actionNodeSaver];\n  \n  uint64_t exportLocation = location;\n  \n  // start to traverse with initial values\n  [self printSymbols:@\"\" \n            location:location \n           skipBytes:0 \n                node:node\n          actionNode:actionNode\n         baseAddress:baseAddress\n      exportLocation:exportLocation];\n  \n  // line up the details of traversal\n  [node sortDetails];\n  [actionNode sortDetails];\n  \n  return node;\n}\n//-----------------------------------------------------------------------------\n\n@end\n"
        },
        {
          "name": "Exceptions.h",
          "type": "blob",
          "size": 0.82421875,
          "content": "/*\n *  Exceptions.h\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#import \"MachOLayout.h\"\n\n@interface MachOLayout (Exceptions)\n\n- (MVNode *)createCFINode:(MVNode *)parent\n                  caption:(NSString *)caption\n                 location:(uint64_t)location\n                   length:(uint64_t)length;\n\n\n- (MVNode *)createLSDANode:(MVNode *)parent\n                 caption:(NSString *)caption\n                location:(uint64_t)location\n                  length:(uint64_t)length\n          eh_frame_begin:(uint64_t)eh_frame_begin;\n\n- (MVNode *)createUnwindInfoHeaderNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                                header:(struct unwind_info_section_header const *)unwind_info_section_header;\n\n\n@end\n"
        },
        {
          "name": "Exceptions.mm",
          "type": "blob",
          "size": 38.8701171875,
          "content": "/*\n *  Exceptions.mm\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#import \"Exceptions.h\"\n#import \"ReadWrite.h\"\n#import \"DataController.h\"\n#import <mach-o/compact_unwind_encoding.h>\n\nusing namespace std;\n\n#define DW_EH_PE_absptr\t\t0x00\n#define DW_EH_PE_omit     0xff\n\n#define DW_EH_PE_uleb128\t0x01\n#define DW_EH_PE_udata2\t\t0x02\n#define DW_EH_PE_udata4\t\t0x03\n#define DW_EH_PE_udata8\t\t0x04\n#define DW_EH_PE_sleb128\t0x09\n#define DW_EH_PE_sdata2\t\t0x0A\n#define DW_EH_PE_sdata4\t\t0x0B\n#define DW_EH_PE_sdata8\t\t0x0C\n#define DW_EH_PE_signed\t\t0x08\n\n#define DW_EH_PE_pcrel\t\t0x10\n#define DW_EH_PE_textrel\t0x20\n#define DW_EH_PE_datarel\t0x30\n#define DW_EH_PE_funcrel\t0x40\n#define DW_EH_PE_aligned\t0x50\n\n#define DW_EH_PE_indirect\t0x80\n\n//============================================================================\n@implementation MachOLayout (Exceptions)\n\n//-----------------------------------------------------------------------------\n- (NSString *)getNameForEncoding:(uint8_t)format\n{\n  switch (format)\n  {\n    case DW_EH_PE_absptr: return @\"absolute\";\n    case DW_EH_PE_omit: return @\"omit\";\n    case DW_EH_PE_aligned: return @\"aligned absolute\";\n      \n    case DW_EH_PE_uleb128: return @\"uleb128\";\n    case DW_EH_PE_udata2: return @\"udata2\";\n    case DW_EH_PE_udata4: return @\"udata4\";\n    case DW_EH_PE_udata8: return @\"udata8\";\n    case DW_EH_PE_sleb128: return @\"sleb128\";\n    case DW_EH_PE_sdata2: return @\"sdata2\";\n    case DW_EH_PE_sdata4: return @\"sdata4\";\n    case DW_EH_PE_sdata8: return @\"sdata8\";\n      \n    case DW_EH_PE_absptr | DW_EH_PE_pcrel: return @\"pcrel\";\n    case DW_EH_PE_uleb128 | DW_EH_PE_pcrel: return @\"pcrel uleb128\";\n    case DW_EH_PE_udata2 | DW_EH_PE_pcrel: return @\"pcrel udata2\";\n    case DW_EH_PE_udata4 | DW_EH_PE_pcrel: return @\"pcrel udata4\";\n    case DW_EH_PE_udata8 | DW_EH_PE_pcrel: return @\"pcrel udata8\";\n    case DW_EH_PE_sleb128 | DW_EH_PE_pcrel: return @\"pcrel sleb128\";\n    case DW_EH_PE_sdata2 | DW_EH_PE_pcrel: return @\"pcrel sdata2\";\n    case DW_EH_PE_sdata4 | DW_EH_PE_pcrel: return @\"pcrel sdata4\";\n    case DW_EH_PE_sdata8 | DW_EH_PE_pcrel: return @\"pcrel sdata8\";\n      \n    case DW_EH_PE_absptr | DW_EH_PE_textrel: return @\"textrel\";\n    case DW_EH_PE_uleb128 | DW_EH_PE_textrel: return @\"textrel uleb128\";\n    case DW_EH_PE_udata2 | DW_EH_PE_textrel: return @\"textrel udata2\";\n    case DW_EH_PE_udata4 | DW_EH_PE_textrel: return @\"textrel udata4\";\n    case DW_EH_PE_udata8 | DW_EH_PE_textrel: return @\"textrel udata8\";\n    case DW_EH_PE_sleb128 | DW_EH_PE_textrel: return @\"textrel sleb128\";\n    case DW_EH_PE_sdata2 | DW_EH_PE_textrel: return @\"textrel sdata2\";\n    case DW_EH_PE_sdata4 | DW_EH_PE_textrel: return @\"textrel sdata4\";\n    case DW_EH_PE_sdata8 | DW_EH_PE_textrel: return @\"textrel sdata8\";\n      \n    case DW_EH_PE_absptr | DW_EH_PE_datarel: return @\"datarel\";\n    case DW_EH_PE_uleb128 | DW_EH_PE_datarel: return @\"datarel uleb128\";\n    case DW_EH_PE_udata2 | DW_EH_PE_datarel: return @\"datarel udata2\";\n    case DW_EH_PE_udata4 | DW_EH_PE_datarel: return @\"datarel udata4\";\n    case DW_EH_PE_udata8 | DW_EH_PE_datarel: return @\"datarel udata8\";\n    case DW_EH_PE_sleb128 | DW_EH_PE_datarel: return @\"datarel sleb128\";\n    case DW_EH_PE_sdata2 | DW_EH_PE_datarel: return @\"datarel sdata2\";\n    case DW_EH_PE_sdata4 | DW_EH_PE_datarel: return @\"datarel sdata4\";\n    case DW_EH_PE_sdata8 | DW_EH_PE_datarel: return @\"datarel sdata8\";\n      \n    case DW_EH_PE_absptr | DW_EH_PE_funcrel: return @\"funcrel\";\n    case DW_EH_PE_uleb128 | DW_EH_PE_funcrel: return @\"funcrel uleb128\";\n    case DW_EH_PE_udata2 | DW_EH_PE_funcrel: return @\"funcrel udata2\";\n    case DW_EH_PE_udata4 | DW_EH_PE_funcrel: return @\"funcrel udata4\";\n    case DW_EH_PE_udata8 | DW_EH_PE_funcrel: return @\"funcrel udata8\";\n    case DW_EH_PE_sleb128 | DW_EH_PE_funcrel: return @\"funcrel sleb128\";\n    case DW_EH_PE_sdata2 | DW_EH_PE_funcrel: return @\"funcrel sdata2\";\n    case DW_EH_PE_sdata4 | DW_EH_PE_funcrel: return @\"funcrel sdata4\";\n    case DW_EH_PE_sdata8 | DW_EH_PE_funcrel: return @\"funcrel sdata8\";\n      \n    case DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_pcrel: return @\"indirect pcrel\";\n    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_pcrel: return @\"indirect pcrel uleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_pcrel: return @\"indirect pcrel udata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_pcrel: return @\"indirect pcrel udata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_pcrel: return @\"indirect pcrel udata8\";\n    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_pcrel: return @\"indirect pcrel sleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_pcrel: return @\"indirect pcrel sdata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_pcrel: return @\"indirect pcrel sdata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_pcrel: return @\"indirect pcrel sdata8\";\n      \n    case DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_textrel: return @\"indirect textrel\";\n    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_textrel: return @\"indirect textrel uleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_textrel: return @\"indirect textrel udata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_textrel: return @\"indirect textrel udata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_textrel: return @\"indirect textrel udata8\";\n    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_textrel: return @\"indirect textrel sleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_textrel: return @\"indirect textrel sdata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_textrel: return @\"indirect textrel sdata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_textrel: return @\"indirect textrel sdata8\";\n      \n    case DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_datarel: return @\"indirect datarel\";\n    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_datarel: return @\"indirect datarel uleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_datarel: return @\"indirect datarel udata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_datarel: return @\"indirect datarel udata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_datarel: return @\"indirect datarel udata8\";\n    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_datarel: return @\"indirect datarel sleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_datarel: return @\"indirect datarel sdata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_datarel: return @\"indirect datarel sdata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_datarel: return @\"indirect datarel sdata8\";\n      \n    case DW_EH_PE_indirect | DW_EH_PE_absptr | DW_EH_PE_funcrel: return @\"indirect funcrel\";\n    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_funcrel: return @\"indirect funcrel uleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_funcrel: return @\"indirect funcrel udata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_funcrel: return @\"indirect funcrel udata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_funcrel: return @\"indirect funcrel udata8\";\n    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_funcrel: return @\"indirect funcrel sleb128\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_funcrel: return @\"indirect funcrel sdata2\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_funcrel: return @\"indirect funcrel sdata4\";\n    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_funcrel: return @\"indirect funcrel sdata8\";\n  }\n  return @\"???\";\n}\n\n#define ENCODING_FIXSIZE(format) \\\n((format & 0xf) == DW_EH_PE_udata2 || (format & 0xf) == DW_EH_PE_sdata2) ? sizeof(uint16_t) : \\\n((format & 0xf) == DW_EH_PE_udata4 || (format & 0xf) == DW_EH_PE_sdata4) ? sizeof(uint32_t) : \\\n((format & 0xf) == DW_EH_PE_udata8 || (format & 0xf) == DW_EH_PE_sdata8) ? sizeof(uint64_t) : \\\n((format & 0xf) == DW_EH_PE_uleb128 || (format & 0xf) == DW_EH_PE_sleb128) ? 0 : \\\n([self is64bit] == NO) ? sizeof(uint32_t) : sizeof(uint64_t)\n\n//-----------------------------------------------------------------------------\n#define READ_USE_ENCODING(format,range,hexstr) \\\n  ((format & 0xf) == DW_EH_PE_udata2 || (format & 0xf) == DW_EH_PE_sdata2) ? [dataController read_uint16:range lastReadHex:&hexstr] : \\\n  ((format & 0xf) == DW_EH_PE_udata4 || (format & 0xf) == DW_EH_PE_sdata4) ? [dataController read_uint32:range lastReadHex:&hexstr] : \\\n  ((format & 0xf) == DW_EH_PE_udata8 || (format & 0xf) == DW_EH_PE_sdata8) ? [dataController read_uint64:range lastReadHex:&hexstr] : \\\n  (format & 0xf) == DW_EH_PE_uleb128 ? [dataController read_uleb128:range lastReadHex:&hexstr] : \\\n  (format & 0xf) == DW_EH_PE_sleb128 ? [dataController read_sleb128:range lastReadHex:&hexstr] : \\\n  ([self is64bit] == NO) ? [dataController read_uint32:range lastReadHex:&hexstr] : [dataController read_uint64:range lastReadHex:&hexstr]\n\n//-----------------------------------------------------------------------------\n- (NSString *)guessSymbolUsingEncoding:(uint8_t)format atOffset:(uint64_t)offset withValue:(uint32_t &)value\n{\n  NSParameterAssert([self is64bit] == NO);\n                    \n  if (value == 0)\n  {\n    return @\"0x0\";\n  }\n\n  if (format & DW_EH_PE_pcrel)\n  {\n    value += [self fileOffsetToRVA:offset];\n  }\n  \n  NSString * symbolName = [self findSymbolAtRVA:value];\n\n  //NSLog(@\"guessed at %X [%X]: %@\", [self fileOffsetToRVA:offset], value, symbolName);\n  \n  return symbolName;\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)guessSymbol64UsingEncoding:(uint8_t)format atOffset:(uint64_t)offset withValue:(uint64_t &)value\n{\n  NSParameterAssert([self is64bit] == YES);\n  \n  if (value == 0)\n  {\n    return @\"0x0\";\n  }\n  \n  // extend external symbols represented in 32bit to 64bit\n  if ((int32_t)value < 0)\n  {\n    value |= 0xffffffff00000000LL;\n  }\n\n  if (format & DW_EH_PE_pcrel)\n  {\n    value += [self fileOffsetToRVA:offset];\n  }\n   \n  NSString * symbolName = [self findSymbolAtRVA:value];\n  \n  //NSLog(@\"guessed at %qX [%qX]: %@\", [self fileOffsetToRVA64:offset], value, symbolName);\n  \n  return symbolName;\n}\n\n//-----------------------------------------------------------------------------\n// Call Frame Information\n//-----------------------------------------------------------------------------\n- (MVNode *)createCFINode:(MVNode *)parent\n                caption:(NSString *)caption\n               location:(uint64_t)location\n                 length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  /////////////////////////////////////////////////////////\n  //            Common Information Entry\n  \n  uint8_t Pointer_encoding = DW_EH_PE_omit;\n  uint8_t LSDA_encoding = DW_EH_PE_omit;\n  \n  //Length (Required)\n  // A 4 byte unsigned value indicating the length in bytes of the CIE structure, not including the Length field itself. \n  // If Length contains the value 0xffffffff, then the length is contained in the Extended Length field. \n  // If Length contains the value 0, then this CIE shall be considered a terminator and processing shall end.\n  uint32_t CIE_length = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CIE Length\"\n                         :[NSString stringWithFormat:@\"%u\", CIE_length]];\n  \n  //Extended Length (Optional)\n  // A 8 byte unsigned value indicating the length in bytes of the CIE structure, not including the Length and Extended Length fields.\n  NSAssert (CIE_length != 0xffffffff, @\"CIE Extended length present\");\n  \n  //CIE ID (Required)\n  // A 4 byte unsigned value that is used to distinguish CIE records from FDE records. \n  // This value shall always be 0, which indicates this record is a CIE.\n  uint32_t CIE_ID = [dataController read_uint32:range lastReadHex:&lastReadHex]; CIE_length -= range.length;\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CIE ID\"\n                         :[NSString stringWithFormat:@\"%u\", CIE_ID]];\n  \n  //Version (Required)\n  // Version assigned to the call frame information structure. This value shall be 1.\n  uint8_t CIE_version = [dataController read_uint8:range lastReadHex:&lastReadHex]; CIE_length -= range.length;\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CIE Version\"\n                         :[NSString stringWithFormat:@\"%u\", CIE_version]];\n  \n  //Augmentation String (Required)\n  // This value is a NUL terminated string that identifies the augmentation to the CIE or to the FDEs associated with this CIE. \n  // A zero length string indicates that no augmentation data is present. \n  NSString * CIE_augmentationStr = [dataController read_string:range lastReadHex:&lastReadHex]; CIE_length -= range.length;\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Augmentation String\"\n                         :CIE_augmentationStr];\n  \n  //EH Data present (Optional)\n  // On 32 bit architectures, this is a 4 byte value that... On 64 bit architectures, this is a 8 byte value that... \n  NSAssert ([CIE_augmentationStr rangeOfString:@\"eh\"].location == NSNotFound, @\"EH Data field is present\");\n  \n  //Code Alignment Factor (Required)\n  // An unsigned LEB128 encoded value that is factored out of all advance location instructions that are associated with this CIE or its FDEs.\n  // This value shall be multiplied by the delta argument of an adavance location instruction to obtain the new location value.\n  uint64_t CIE_codeAlignFactor = [dataController read_uleb128:range lastReadHex:&lastReadHex]; CIE_length -= range.length;\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Code Alignment Factor\"\n                         :[NSString stringWithFormat:@\"%qu\", CIE_codeAlignFactor]];\n  \n  //Data Alignment Factor (Required)\n  // A signed LEB128 encoded value that is factored out of all offset instructions that are associated with this CIE or its FDEs. \n  // This value shall be multiplied by the register offset argument of an offset instruction to obtain the new offset value.\n  int64_t CIE_dataAlignFactor = [dataController read_sleb128:range lastReadHex:&lastReadHex]; CIE_length -= range.length;\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Data Alignment Factor\"\n                         :[NSString stringWithFormat:@\"%qd\", CIE_dataAlignFactor]];\n  \n  //Return Address Register\t(Required)\n  uint8_t CIE_returnAddressRegister = [dataController read_uint8:range lastReadHex:&lastReadHex]; CIE_length -= range.length;\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Return Address Register\"\n                         :[NSString stringWithFormat:@\"0x%X\", CIE_returnAddressRegister]];\n  \n  // A 'z' may be present as the first character of the string. If present, the Augmentation Data field shall be present. \n  // The contents of the Augmentation Data shall be intepreted according to other characters in the Augmentation String.\n  if ([CIE_augmentationStr rangeOfString:@\"z\"].location != NSNotFound)\n  {\n    //Augmentation Data Length (Optional)\n    // An unsigned LEB128 encoded value indicating the length in bytes of the Augmentation Data. \n    // This field is only present if the Augmentation String contains the character 'z'.\n    uint64_t CIE_augmentationLength = [dataController read_uleb128:range lastReadHex:&lastReadHex]; CIE_length -= range.length;\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Augmentation Length\"\n                           :[NSString stringWithFormat:@\"%qu\", CIE_augmentationLength]];\n    \n    //Augmentation Data\t(Optional)\n    // A block of data whose contents are defined by the contents of the Augmentation String as described below. \n    // This field is only present if the Augmentation String contains the character 'z'.\n    for (NSUInteger strIndex = 1; strIndex < [CIE_augmentationStr length]; ++strIndex)\n    {\n      switch ([CIE_augmentationStr characterAtIndex:strIndex])\n      {\n        case 'L':\n          // A 'L' may be present at any position after the first character of the string. \n          // This character may only be present if 'z' is the first character of the string. \n          // If present, it indicates the presence of one argument in the Augmentation Data of the CIE, and a corresponding argument in the Augmentation Data of the FDE. \n          // The argument in the Augmentation Data of the CIE is 1-byte and represents the pointer encoding used for the argument in the Augmentation Data of the FDE, which is the address of a language-specific data area (LSDA). \n          // The size of the LSDA pointer is specified by the pointer encoding used.\n        {\n          LSDA_encoding = [dataController read_uint8:range lastReadHex:&lastReadHex];\n          [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                 :lastReadHex\n                                 :@\"LSDA Encoding in FDE\"\n                                 :[self getNameForEncoding:LSDA_encoding]];\n        } break;\n      \n        case 'P':\n          // A 'P' may be present at any position after the first character of the string. \n          // This character may only be present if 'z' is the first character of the string.\n          // If present, it indicates the presence of two arguments in the Augmentation Data of the CIE. \n          // The first argument is 1-byte and represents the pointer encoding used for the second argument, which is the address of a personality routine handler. \n          // The size of the personality routine pointer is specified by the pointer encoding used.\n        {\n          // personality routine encoding\n          uint8_t PR_encoding = [dataController read_uint8:range lastReadHex:&lastReadHex];\n          [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                 :lastReadHex\n                                 :@\"Personality Encoding\"\n                                 :[self getNameForEncoding:PR_encoding]];\n          \n          uint64_t PR_offset = READ_USE_ENCODING(PR_encoding,range,lastReadHex);\n          [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                 :lastReadHex\n                                 :@\"Personality Routine\"\n                                 :[self is64bit] == NO\n                                    ? [self guessSymbolUsingEncoding:PR_encoding atOffset:range.location withValue:(uint32_t &)PR_offset]\n                                    : [self guessSymbol64UsingEncoding:PR_encoding atOffset:range.location withValue:PR_offset]];\n        } break;\n      \n        case 'R':\n          // A 'R' may be present at any position after the first character of the string. \n          // This character may only be present if 'z' is the first character of the string. \n          // If present, The Augmentation Data shall include a 1 byte argument that represents the pointer encoding for the address pointers used in the FDE.\n        {\n          Pointer_encoding = [dataController read_uint8:range lastReadHex:&lastReadHex];\n          [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                 :lastReadHex\n                                 :@\"Pointer Encoding in FDE\"\n                                 :[self getNameForEncoding:Pointer_encoding]];\n        } break;\n          \n      } // switch\n    } // loop\n    \n    CIE_length -= CIE_augmentationLength;\n    \n  } // read augmentation data\n  \n  //Initial Instructions (Required)\n  // Initial set of Call Frame Instructions.\n  [dataController read_bytes:range length:CIE_length lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Initial Instructions\"\n                         :@\"\"];\n\n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  \n  /////////////////////////////////////////////////////////\n  //        Frame Description Entry (FDE) Records\n  \n  if (Pointer_encoding != DW_EH_PE_omit)\n  while (NSMaxRange(range) - location < length)\n  {\n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    //Length\t(Required)\n    // A 4 byte unsigned value indicating the length in bytes of the CIE structure, not including the Length field itself. \n    // If Length contains the value 0xffffffff, then the length is contained the Extended Length field. \n    // If Length contains the value 0, then this CIE shall be considered a terminator and processing shall end.\n    uint32_t FDE_length = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"FDE Length\"\n                           :[NSString stringWithFormat:@\"%u\", FDE_length]];\n    \n    //Extended Length\t(Optional)\n    // A 8 byte unsigned value indicating the length in bytes of the CIE structure, not including the Length field itself.\n    NSAssert (FDE_length != 0xffffffff, @\"FDE Extended length present\");\n    \n    //CIE Pointer\t(Required)\n    // A 4 byte unsigned value that when subtracted from the offset of the current FDE yields the offset of the start of the associated CIE. \n    // This value shall never be 0.\n    uint32_t FDE_CIEvalue = [dataController read_uint32:range lastReadHex:&lastReadHex]; FDE_length -= range.length;\n    \n    // we ran out of FDE records and started to process the forthcoming CIE !! \n    // rollback until the begining of the CIE\n    if (FDE_CIEvalue == 0)\n    {\n      [node.details popRow];\n      break;\n    }\n    \n      uint64_t FDE_CIEpointer = [self fileOffsetToRVA:range.location] - FDE_CIEvalue;\n\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"CIE Pointer\"\n                           :[self findSymbolAtRVA:FDE_CIEpointer]];\n    \n    //PC Begin\t(Required)\n    // An encoded constant that indicates the address of the initial location associated with this FDE.\n    uint64_t PCBegin_addr = READ_USE_ENCODING(Pointer_encoding,range,lastReadHex); FDE_length -= range.length;\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"PC Begin\"\n                           :[self is64bit] == NO\n                              ? (symbolName = [self guessSymbolUsingEncoding:Pointer_encoding atOffset:range.location withValue:(uint32_t &)PCBegin_addr])\n                              : (symbolName = [self guessSymbol64UsingEncoding:Pointer_encoding atOffset:range.location withValue:PCBegin_addr])];\n\n    //PC Range\t(Required)\n    // An encoded constant that indicates the number of bytes of instructions associated with this FDE.\n    uint64_t FDE_PCRange = READ_USE_ENCODING(Pointer_encoding,range,lastReadHex); FDE_length -= range.length;\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"PC Range\"\n                           :[NSString stringWithFormat:@\"%qu\", FDE_PCRange]];\n    \n    if ([CIE_augmentationStr rangeOfString:@\"z\"].location != NSNotFound)\n    {\n      //Augmentation Data Length\t(Optional)\n      // An unsigned LEB128 encoded value indicating the length in bytes of the Augmentation Data. \n      // This field is only present if the Augmentation String in the associated CIE contains the character 'z'.\n      uint64_t FDE_augmentationLength = [dataController read_uleb128:range lastReadHex:&lastReadHex]; FDE_length -= range.length;\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Augmentation Length\"\n                             :[NSString stringWithFormat:@\"%qu\", FDE_augmentationLength]];\n      \n      if (FDE_augmentationLength > 0) // LSDA is present\n      {\n        //Augmentation Data\t(Optional)\n        // A block of data whose contents are defined by the contents of the Augmentation String in the associated CIE as described above. \n        // This field is only present if the Augmentation String in the associated CIE contains the character 'z'.\n        uint64_t LSDA_addr = READ_USE_ENCODING(LSDA_encoding,range,lastReadHex); FDE_length -= range.length;\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"LSDA\"\n                               :[self is64bit] == NO \n                                  ? [self guessSymbolUsingEncoding:LSDA_encoding atOffset:range.location withValue:(uint32_t &)LSDA_addr]\n                                  : [self guessSymbol64UsingEncoding:LSDA_encoding atOffset:range.location withValue:LSDA_addr]];\n        \n        if (LSDA_addr != 0)\n        {\n          lsdaInfo[LSDA_addr] = PCBegin_addr;\n        }\n      }\n    }\n    \n    //Call Frame Instructions\t(Required)\n    // A set of Call Frame Instructions.\n    [dataController read_bytes:range length:FDE_length lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Call Frame Instructions\"\n                           :@\"\"];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n//                     Language Specific Data Area\n//-----------------------------------------------------------------------------\n/*  #header\n *  .byte       @LPStart format     (usually <omit>)\n *  .byte       @TType format       (usually <omit>, <absolute> or <indirect pcrel sdata4>) \n *  .uleb128    @TType base offset  (optional depending on TType format)\n *  .byte       Call-site format\n *  .uleb128    Call-site table length\n *\n *  #call-site table\n *  .long       region 0 start\n *  .long       length\n *  .long       landing pad\n *    ...\n *\n *  #Action record table\n *  .sleb128    typeFilter 1\n *  .sleb128    nextAction\n *  .sleb128    typeFilter 2\n *  .sleb128    nextAction\n *    ...\n *\n *  #Types table\n *  .align 2\n *  .long       typeInfo 3\n *  .long       typeInfo 2\n *  .long       typeInfo 1\n * ------------------------------- TTableBase\n *  .sleb128    typeIndex 1\n *  .sleb128    typeIndex 2\n *  .sleb128    0\n *  .sleb128    typeIndex 3\n *  .sleb128    0\n */\n//===========================================================\n\n- (MVNode *)createLSDANode:(MVNode *)parent\n                 caption:(NSString *)caption\n                location:(uint64_t)location\n                  length:(uint64_t)length\n          eh_frame_begin:(uint64_t)eh_frame_begin\n              \n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  //===================== LSDA Header =======================\n  uint8_t LPStartFormat = [dataController read_uint8:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"@LPStart format\"\n                         :[self getNameForEncoding:LPStartFormat]];\n  \n  uint8_t typeTableFormat = [dataController read_uint8:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"@TType format\"\n                         :[self getNameForEncoding:typeTableFormat]];\n  \n  uint64_t typeTableBaseLocation = 0;\n  if (typeTableFormat != DW_EH_PE_omit)\n  {\n    uint64_t typeTableBaseOffset = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n    typeTableBaseLocation = NSMaxRange(range) + typeTableBaseOffset;\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Type Table Base\"\n                           :[NSString stringWithFormat:@\"0x%qX\",[self fileOffsetToRVA:typeTableBaseLocation]]];                                                   \n  }\n    \n  uint8_t callSiteFormat = [dataController read_uint8:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"call-site format\"\n                         :[self getNameForEncoding:callSiteFormat]];\n  \n  uint64_t callSiteTableLength = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"call-site table length\"\n                         :[NSString stringWithFormat:@\"%qu\", callSiteTableLength]];\n \n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  \n  //==================== Call Sites Table ====================\n  NSAssert (callSiteFormat == DW_EH_PE_udata4, @\"Not yet implemeted encoding for call-site format\");\n\n  set<uint64_t> actions;\n\n  do \n  {\n    uint64_t regionStart = READ_USE_ENCODING(callSiteFormat,range,lastReadHex);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"region start\"\n                           :[NSString stringWithFormat:@\"0x%qX\", eh_frame_begin + regionStart]];\n    \n    uint64_t regionLength = READ_USE_ENCODING(callSiteFormat,range,lastReadHex);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"length\"\n                           :[NSString stringWithFormat:@\"%qu\", regionLength]];\n    \n    uint64_t landingPad = READ_USE_ENCODING(callSiteFormat,range,lastReadHex);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"landing pad\"\n                           :landingPad == 0 ? @\"0x0\" : [NSString stringWithFormat:@\"0x%qX\", eh_frame_begin + landingPad]];\n    \n    uint64_t action = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"action\"\n                           :[NSString stringWithFormat:@\"%qu\", action]];\n   \n    if (action > 0)\n    {\n      actions.insert(action);\n    }\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n\n  } while (NSMaxRange(range) - location < callSiteTableLength);\n  \n  //================== Action record table ================\n  if (typeTableFormat != DW_EH_PE_omit)\n  {\n    typedef set<int64_t> IndexSet;\n    IndexSet typeIndexes;\n    IndexSet exceptionSpecs;\n\n    // traverse the action table and collect type table records\n    int64_t currentAction = 1;    \n    while (actions.empty() == false)\n    {\n      actions.erase (currentAction);\n      \n      int64_t index = [dataController read_sleb128:range lastReadHex:&lastReadHex]; currentAction += range.length;\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Type Filter\"\n                             :[NSString stringWithFormat:@\"%qd\", index]];\n      \n      if (index > 0)\n      {\n        typeIndexes.insert(index);\n      }\n      else if (index < 0)\n      {\n        exceptionSpecs.insert(index);\n      }\n    \n      int64_t nextAction = [dataController read_sleb128:range lastReadHex:&lastReadHex]; currentAction += range.length;\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Next Action\"\n                             :[NSString stringWithFormat:@\"%qd\", nextAction]];\n      \n      if (nextAction >= currentAction)\n      {\n        actions.insert (nextAction);\n      }\n    } \n\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n    \n    //================== Types table ================\n    \n    // collect additional type indexes from exception specifications\n    for (IndexSet::iterator iter = exceptionSpecs.begin(); iter != exceptionSpecs.end(); ++iter)\n    {\n      int64_t index = *iter;\n\n      NSRange range = NSMakeRange(typeTableBaseLocation - index - 1, 0);\n      \n      // Negative value, starting at -1, which is the byte offset in the types table of a null-terminated list of type indexes. \n      // The list will be at TTBase+1 for -1, at TTBase+2 for -2, and so on.\n      // Used by the runtime to match the type of the thrown exception with the types specified in the “throw” list.\n      // note: they are SLEB128 entries\n      for (;;)\n      {\n        index = [dataController read_sleb128:range lastReadHex:&lastReadHex];\n        if (index == 0)\n        {\n          break;\n        }\n        typeIndexes.insert(index);\n      }\n    }\n    \n    // traverse type filters in reverse order (starting with the catch clauses)\n    for (IndexSet::reverse_iterator iter = typeIndexes.rbegin(); iter != typeIndexes.rend(); ++iter)\n    {\n      int64_t index = *iter;\n      NSParameterAssert (index > 0);\n      \n      // Positive value, starting at 1. Index in the types table of the __typeinfo for the catch-clause type. \n      // 1 is the first word preceding TTBase, 2 is the second word, and so on. \n      // Used by the runtime to check if the thrown exception type matches the catch-clause type.\n        \n      uint32_t size = ENCODING_FIXSIZE(typeTableFormat);\n      range = NSMakeRange(typeTableBaseLocation - index * size,0);\n        \n      uint64_t typeInfo = READ_USE_ENCODING(typeTableFormat,range,lastReadHex);\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                              :lastReadHex\n                              :@\"Type Info\"\n                              :[self is64bit] == NO\n                                ? [self guessSymbolUsingEncoding:typeTableFormat atOffset:range.location withValue:(uint32_t &)typeInfo]\n                                : [self guessSymbol64UsingEncoding:typeTableFormat atOffset:range.location withValue:typeInfo]];\n    }\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n    // Exception Specifications\n    range = NSMakeRange (typeTableBaseLocation, 0);\n    while (NSMaxRange(range) < location + length)\n    {\n      int64_t index = [dataController read_sleb128:range lastReadHex:&lastReadHex];\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Exception Spec\"\n                             :[NSString stringWithFormat:@\"%lld\", index]];\n    }\n    \n  } // end of Action Record Table\n\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n//    !!!!!! DISCONTINUED !!!!! (not mandatory, can be ommited)\n//-----------------------------------------------------------------------------\n- (MVNode *)createUnwindInfoHeaderNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                                header:(struct unwind_info_section_header const *)unwind_info_section_header\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sizeof(struct unwind_info_section_header) saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  uint32_t version = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Unwind Section Version\"\n                         :version == UNWIND_SECTION_VERSION ? @\"UNWIND_SECTION_VERSION\" : [NSString stringWithFormat:@\"%u\", version]];\n  \n  NSAssert1(version == UNWIND_SECTION_VERSION, @\"unsupported unwind section version (%u)\", version);\n  \n  uint32_t commonEncodingsArraySectionOffset = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Common Enc Array Sect Offset\"\n                         :[self findSymbolAtRVA:[self fileOffsetToRVA:range.location] + commonEncodingsArraySectionOffset]];\n  \n  uint32_t commonEncodingsArrayCount = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Common Enc Array Count\"\n                         :[NSString stringWithFormat:@\"%u\", commonEncodingsArrayCount]];\n\n  uint32_t personalityArraySectionOffset = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Personality Array Sect Offset\"\n                         :[self findSymbolAtRVA:[self fileOffsetToRVA:range.location] + personalityArraySectionOffset]];\n\n  uint32_t personalityArrayCount = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Personality Array Count\"\n                         :[NSString stringWithFormat:@\"%u\", personalityArrayCount]];\n\n  uint32_t indexSectionOffset = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Index Section Offset\"\n                         :[self findSymbolAtRVA:[self fileOffsetToRVA:range.location] + indexSectionOffset]];\n\n  uint32_t indexCount = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Index Count\"\n                         :[NSString stringWithFormat:@\"%u\", indexCount]];\n  \n  return node;\n}\n  \n@end\n"
        },
        {
          "name": "FatLayout.h",
          "type": "blob",
          "size": 0.232421875,
          "content": "/*\n *  FatLayout.h\n *  MachOView\n *\n *  Created by psaghelyi on 02/12/2011.\n *\n */\n\n#import \"Layout.h\"\n\n@interface FatLayout : MVLayout;\n\n+ (FatLayout *)     layoutWithDataController:(MVDataController *)dc rootNode:(MVNode *)node;\n\n@end\n\n"
        },
        {
          "name": "FatLayout.mm",
          "type": "blob",
          "size": 10.1826171875,
          "content": "/*\n *  FatLayout.mm\n *  MachOView\n *\n *  Created by psaghelyi on 02/12/2011.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cxxabi.h>\n\n#import \"Common.h\"\n#import \"FatLayout.h\"\n#import \"DataController.h\"\n#import \"MachOLayout.h\"\n#import \"ReadWrite.h\"\n#import <mach-o/fat.h>\n#import <mach-o/swap.h>\n\nusing namespace std;\n\n//============================================================================\n@implementation FatLayout\n\n//-----------------------------------------------------------------------------\n- (instancetype)initWithDataController:(MVDataController *)dc rootNode:(MVNode *)node\n{\n  if (self = [super initWithDataController:dc rootNode:node])\n  {\n    //further initialisations \n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n+ (FatLayout *)layoutWithDataController:(MVDataController *)dc rootNode:(MVNode *)node\n{\n  return [[FatLayout alloc] initWithDataController:dc rootNode:node];\n}\n\n//----------------------------------------------------------------------------\n- (MVNode *)createHeaderNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                  fat_header:(struct fat_header const *)fat_header\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption \n                                        location:location \n                                          length:sizeof(struct fat_header) + fat_header->nfat_arch * sizeof(struct fat_arch)\n                                           saver:nodeSaver]; \n\n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  uint32_t magic = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Magic Number\"\n                         :magic == FAT_MAGIC ? @\"FAT_MAGIC\" :\n                          magic == FAT_CIGAM ? @\"FAT_CIGAM\" : @\"???\"];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Architecture\"\n                         :[NSString stringWithFormat:@\"%u\",fat_header->nfat_arch]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nimg = 0; nimg < fat_header->nfat_arch; ++nimg)\n  {      \n    // need to make copy for byte swapping\n    struct fat_arch fat_arch;\n    [dataController.fileData getBytes:&fat_arch range:NSMakeRange(NSMaxRange(range), sizeof(struct fat_arch))];\n    swap_fat_arch(&fat_arch, 1, NX_LittleEndian);\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"CPU Type\"\n                           :fat_arch.cputype == CPU_TYPE_ANY ? @\"CPU_TYPE_ANY\" :\n                            fat_arch.cputype == CPU_TYPE_I386 ? @\"CPU_TYPE_I386\" :\n                            fat_arch.cputype == CPU_TYPE_X86_64 ? @\"CPU_TYPE_X86_64\" :\n                            fat_arch.cputype == CPU_TYPE_ARM ? @\"CPU_TYPE_ARM\" :\n                            fat_arch.cputype == CPU_TYPE_ARM64 ? @\"CPU_TYPE_ARM64\" :\n                            fat_arch.cputype == CPU_TYPE_ARM64_32 ? @\"CPU_TYPE_ARM64_32\" :\n                            fat_arch.cputype == CPU_TYPE_POWERPC ? @\"CPU_TYPE_POWERPC\" : \n                            fat_arch.cputype == CPU_TYPE_POWERPC64 ? @\"CPU_TYPE_POWERPC64\" : \n                            @\"???\"];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"CPU SubType\"\n                           :fat_arch.cputype == CPU_TYPE_POWERPC ?\n                            ((fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_ALL ? @\"CPU_SUBTYPE_POWERPC_ALL\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_601 ? @\"CPU_SUBTYPE_POWERPC_601\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_602 ? @\"CPU_SUBTYPE_POWERPC_602\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_603 ? @\"CPU_SUBTYPE_POWERPC_603\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_603e ? @\"CPU_SUBTYPE_POWERPC_603e\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_603ev ? @\"CPU_SUBTYPE_POWERPC_603ev\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_604 ? @\"CPU_SUBTYPE_POWERPC_604\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_604e ? @\"CPU_SUBTYPE_POWERPC_604e\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_620 ? @\"CPU_SUBTYPE_POWERPC_620\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_750 ? @\"CPU_SUBTYPE_POWERPC_750\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_7400 ? @\"CPU_SUBTYPE_POWERPC_7400\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_7450 ? @\"CPU_SUBTYPE_POWERPC_7450\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_POWERPC_970 ? @\"CPU_SUBTYPE_POWERPC_970\" : @\"???\") :\n                            fat_arch.cputype == CPU_TYPE_ARM ?\n                            ((fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_ALL ? @\"CPU_SUBTYPE_ARM_ALL\" : \n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V4T ? @\"CPU_SUBTYPE_ARM_V4T\" : \n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V6 ? @\"CPU_SUBTYPE_ARM_V6\" : \n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V5TEJ ? @\"CPU_SUBTYPE_ARM_V5TEJ\" : \n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_XSCALE ? @\"CPU_SUBTYPE_ARM_XSCALE\" : \n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7 ? @\"CPU_SUBTYPE_ARM_V7\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7F ? @\"CPU_SUBTYPE_ARM_V7F\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7S ? @\"CPU_SUBTYPE_ARM_V7S\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7K ? @\"CPU_SUBTYPE_ARM_V7K\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V6M ? @\"CPU_SUBTYPE_ARM_V6M\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7M ? @\"CPU_SUBTYPE_ARM_V7M\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7EM ? @\"CPU_SUBTYPE_ARM_V7EM\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V8 ? @\"CPU_SUBTYPE_ARM_V8\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V8M ? @\"CPU_SUBTYPE_ARM_V8M\" : @\"???\") :\n                            fat_arch.cputype == CPU_TYPE_ARM64 ?\n                            ((fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64_ALL ? @\"CPU_SUBTYPE_ARM64_ALL\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64_V8 ? @\"CPU_SUBTYPE_ARM64_V8\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E ? @\"CPU_SUBTYPE_ARM64E\" : @\"???\") :\n                            fat_arch.cputype == CPU_TYPE_ARM64_32 ?\n                             ((fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64_32_ALL ? @\"CPU_SUBTYPE_ARM64_32_ALL\" :\n                             (fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64_32_V8 ? @\"CPU_SUBTYPE_ARM64_32_V8\" : @\"???\") :\n                            fat_arch.cputype == CPU_TYPE_I386 ?\n                            ((fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_I386_ALL ? @\"CPU_SUBTYPE_I386_ALL\" : @\"???\") :\n                            fat_arch.cputype == CPU_TYPE_X86_64 ?\n                            ((fat_arch.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_X86_64_ALL ? @\"CPU_SUBTYPE_X86_64_ALL\" : @\"???\") : \n                             @\"???\"];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Offset\"\n                           :[NSString stringWithFormat:@\"%u\",fat_arch.offset]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%u\",fat_arch.size]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Align\"\n                           :[NSString stringWithFormat:@\"%u\",(1 << fat_arch.align)]];\n                           \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//----------------------------------------------------------------------------\n- (void)doMainTasks\n{\n  struct fat_header fat_header;\n  [dataController.fileData getBytes:&fat_header length:sizeof(struct fat_header)];\n  \n  if (fat_header.magic == FAT_CIGAM)\n  {\n    swap_fat_header(&fat_header, NX_LittleEndian);\n  }\n  \n  [self createHeaderNode:rootNode \n                 caption:@\"Fat Header\"\n                location:imageOffset \n              fat_header:&fat_header];\n  \n  [super doMainTasks];\n}\n\n@end\n\n"
        },
        {
          "name": "Info.plist",
          "type": "blob",
          "size": 1.7353515625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>CFBuildDate</key>\n\t<string>Thu May 18 11:30:16 WEST 2023</string>\n\t<key>CFBuildNumber</key>\n\t<string>9446</string>\n\t<key>CFBundleDevelopmentRegion</key>\n\t<string>English</string>\n\t<key>CFBundleDocumentTypes</key>\n\t<array>\n\t\t<dict>\n\t\t\t<key>CFBundleTypeExtensions</key>\n\t\t\t<array>\n\t\t\t\t<string>*</string>\n\t\t\t</array>\n\t\t\t<key>CFBundleTypeName</key>\n\t\t\t<string>Mach-O Binaries</string>\n\t\t\t<key>CFBundleTypeRole</key>\n\t\t\t<string>Editor</string>\n\t\t\t<key>LSHandlerRank</key>\n\t\t\t<string>Alternate</string>\n\t\t\t<key>NSDocumentClass</key>\n\t\t\t<string>MVDocument</string>\n\t\t\t<key>NSPersistentStoreTypeKey</key>\n\t\t\t<string>Binary</string>\n\t\t</dict>\n\t</array>\n\t<key>CFBundleExecutable</key>\n\t<string>${EXECUTABLE_NAME}</string>\n\t<key>CFBundleIconFile</key>\n\t<string>redApple.icns</string>\n\t<key>CFBundleIdentifier</key>\n\t<string>${PRODUCT_NAME:rfc1034identifier}</string>\n\t<key>CFBundleInfoDictionaryVersion</key>\n\t<string>6.0</string>\n\t<key>CFBundleName</key>\n\t<string>${PRODUCT_NAME}</string>\n\t<key>CFBundlePackageType</key>\n\t<string>APPL</string>\n\t<key>CFBundleShortVersionString</key>\n\t<string>3.0</string>\n\t<key>CFBundleSignature</key>\n\t<string>????</string>\n\t<key>CFBundleVersion</key>\n\t<string>9446</string>\n\t<key>LSApplicationCategoryType</key>\n\t<string>public.app-category.developer-tools</string>\n\t<key>LSMinimumSystemVersion</key>\n\t<string>${MACOSX_DEPLOYMENT_TARGET}</string>\n\t<key>NSMainNibFile</key>\n\t<string>MainMenu</string>\n\t<key>NSPrincipalClass</key>\n\t<string>NSApplication</string>\n\t<key>SecTaskAccess</key>\n\t<array>\n\t\t<string>allowed</string>\n\t\t<string>debug</string>\n\t</array>\n</dict>\n</plist>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0888671875,
          "content": "MIT License\n\nCopyright (c) 2010-2019 Peter Saghelyi\nCopyright (c) 2012-2023 Pedro Vilaça\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "Layout.h",
          "type": "blob",
          "size": 1.662109375,
          "content": "/*\n *  Layout.h\n *  MachOView\n *\n *  Created by psaghelyi on 18/03/2011.\n *\n */\n\n\n#define MATCH_STRUCT(obj,location) \\\n  struct obj const * obj = (struct obj *)[self imageAt:(location)]; \\\n  if (!obj) [NSException raise:@\"null exception\" format:@#obj \" is null\"];\n\n@class MVDataController;\n@class MVArchiver;\n@class MVNode;\n\n\n@interface MVLayout : NSObject \n{\n  MVNode *              __weak rootNode;\n  MVDataController *    __weak dataController;\n  uint64_t              imageOffset;  // absolute physical offset of the image in binary\n  uint64_t              imageSize;    // size of the image corresponds to this layout\n  NSThread *            backgroundThread;\n  MVArchiver *          archiver;\n}\n\n@property(nonatomic,weak,readonly)  MVDataController * dataController;\n@property(nonatomic,readonly) NSThread * backgroundThread;\n@property(nonatomic,readonly) MVArchiver * archiver;\n\n- (instancetype)        init NS_UNAVAILABLE;\n- (instancetype)        initWithDataController:(MVDataController *)dc rootNode:(MVNode *)node NS_DESIGNATED_INITIALIZER;\n- (void const *)        imageAt:(uint64_t)location NS_RETURNS_INNER_POINTER;\n- (void)                printException:(NSException *)exception caption:(NSString *)caption;\n- (BOOL)                is64bit;\n- (void)                doMainTasks;\n- (void)                doBackgroundTasks;\n- (NSString *)          convertToRVA: (NSString *)offsetStr;\n- (MVNode *)            findNodeByUserInfo:(NSDictionary *)userInfo;\n\n- (MVNode *)            createDataNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                                length:(uint64_t)length;\n\n@end\n"
        },
        {
          "name": "Layout.mm",
          "type": "blob",
          "size": 3.5537109375,
          "content": "/*\n *  Layout.mm\n *  MachOView\n *\n *  Created by psaghelyi on 18/03/2011.\n *\n */\n\n#import \"Common.h\"\n#import \"Document.h\"\n#import \"DataController.h\"\n#import \"Layout.h\"\n\n//============================================================================\n@implementation MVLayout\n\n@synthesize dataController, backgroundThread, archiver;\n\n/*\n- (void)dealloc\n{\n  NSLog(@\"********MVLayout deallocated: %@\", self);\n}\n*/\n\n//-----------------------------------------------------------------------------\n- (instancetype)initWithDataController:(MVDataController *)dc rootNode:(MVNode *)node\n{\n    if (self = [super init]) {\n        dataController = dc;\n        rootNode = node;\n        imageOffset = node.dataRange.location;\n        imageSize = node.dataRange.length;\n        backgroundThread = [[NSThread alloc] initWithTarget:self selector:@selector(doBackgroundTasks) object:nil];\n    \n        const char *tmp = [[MVDocument temporaryDirectory] UTF8String];\n        char *swapFilePath = strdup(tmp);\n        if (mkstemp(swapFilePath) == -1) {\n            NSLog(@\"mkstemp failed!\");\n            free(swapFilePath);\n            return nil;\n        }\n      \n        NSString *swapPath = [NSString stringWithFormat:@\"%s.%@\", swapFilePath, [[dataController fileName] lastPathComponent]];\n        free(swapFilePath);\n        archiver = [MVArchiver archiverWithPath:swapPath];\n    }\n    return self;\n}\n\n//-----------------------------------------------------------------------------\n- (void const *)imageAt:(uint64_t)location\n{\n  auto p = (uint8_t const *)[dataController.realData bytes];\n  return p ? p + location : NULL;\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)description\n{\n  return [[super description] stringByAppendingFormat:@\" [%@]\",rootNode.caption];\n}\n\n//-----------------------------------------------------------------------------\n-(void)printException:(NSException *)exception caption:(NSString *)caption\n{\n  @synchronized([NSApp class])\n  {\n    NSLog(@\"%@: Exception (%@): %@\", self, caption, [exception name]);\n    NSLog(@\"  Reason: %@\", [exception reason]);\n    NSLog(@\"  User Info: %@\", [exception userInfo]);\n    NSLog(@\"  Backtrace:\\n%@\", [exception callStackSymbols]);\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (BOOL)is64bit\n{\n  return NO;\n}\n\n//-----------------------------------------------------------------------------\n- (void)doMainTasks\n{\n}\n\n//-----------------------------------------------------------------------------\n- (void)doBackgroundTasks\n{\n  [archiver halt];\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)convertToRVA: (NSString *)offsetStr\n{\n  return @\"\";\n}\n\n//-----------------------------------------------------------------------------\n// Depth-first Traversal of nodes\n//-----------------------------------------------------------------------------\n- (MVNode *)findNodeByUserInfo:(NSDictionary *)userInfo\n{\n  [dataController.treeLock lock];\n  MVNode * node = [rootNode findNodeByUserInfo:userInfo];\n  [dataController.treeLock unlock];\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n// Create data node without details table (only hex content)\n//-----------------------------------------------------------------------------\n- (MVNode *)createDataNode:(MVNode *)parent\n                   caption:(NSString *)caption\n                  location:(uint64_t)location\n                    length:(uint64_t)length\n{\n  MVNode * node = [parent insertChild:caption location:location length:length];\n  return node;\n}\n\n@end\n"
        },
        {
          "name": "LinkEdit.h",
          "type": "blob",
          "size": 3.3271484375,
          "content": "/*\n *  LinkEdit.h\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#import \"MachOLayout.h\"\n@interface MachOLayout (LinkEdit)\n\n- (MVNode *) createRelocNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n                 baseAddress:(uint32_t)baseAddress;\n\n- (MVNode *) createReloc64Node:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length\n                   baseAddress:(uint64_t)baseAddress;\n\n- (MVNode *) createSymbolsNode:parent \n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length;\n\n- (MVNode *) createSymbols64Node:parent \n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length;\n\n- (MVNode *) createReferencesNode:parent \n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length;\n\n- (MVNode *) createISymbolsNode:parent\n                        caption:(NSString *)caption\n                       location:(uint64_t)location\n                         length:(uint64_t)length;\n\n- (MVNode *) createISymbols64Node:parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length;\n\n- (MVNode *) createTOCNode:parent\n                   caption:(NSString *)caption\n                  location:(uint64_t)location\n                    length:(uint64_t)length;\n\n- (MVNode *) createTOC64Node:parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length;\n\n- (MVNode *) createModulesNode:parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length;\n\n- (MVNode *) createModules64Node:parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length;\n\n- (MVNode *) createTwoLevelHintsNode:parent \n                             caption:(NSString *)caption\n                            location:(uint64_t)location\n                              length:(uint64_t)length\n                               index:(uint32_t)index;\n\n- (MVNode *) createSplitSegmentNode:parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length\n                        baseAddress:(uint64_t)baseAddress;\n\n- (MVNode *) createFunctionStartsNode:parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                               length:(uint64_t)length\n                          baseAddress:(uint64_t)baseAddress;\n\n- (MVNode *) createDataInCodeEntriesNode:parent\n                                 caption:(NSString *)caption\n                                location:(uint64_t)location\n                                  length:(uint64_t)length;\n\n\n@end\n\n"
        },
        {
          "name": "LinkEdit.mm",
          "type": "blob",
          "size": 86.5263671875,
          "content": "/*\n *  LinkEdit.mm\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#import \"Common.h\"\n#import \"LinkEdit.h\"\n#import \"ReadWrite.h\"\n#import \"DataController.h\"\n#import <mach-o/loader.h>\n#import <mach-o/reloc.h>\n#import <mach-o/arm/reloc.h>\n#import <mach-o/arm64/reloc.h>\n#import <mach-o/x86_64/reloc.h>\n#import <mach-o/nlist.h>\n\nusing namespace std;\n\n//============================================================================\n@implementation MachOLayout (LinkEdit)\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createRelocNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n                 baseAddress:(uint32_t)baseAddress // start of the section containing the relocation (image: start of the first segment)\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  MATCH_STRUCT(mach_header,imageOffset);\n  \n  struct scattered_relocation_info const * prev_scattered_relocation_info = NULL; // for sectdiff & pair\n  \n  for (uint32_t nreloc = 0; nreloc < length / sizeof(struct relocation_info); ++nreloc)\n  {\n    if ([backgroundThread isCancelled]) break;\n    \n    // normal:    relocation_info != NULL, scattered_relocation_info == NULL\n    // scattered: relocation_info == NULL, scattered_relocation_info != NULL\n    \n    MATCH_STRUCT(relocation_info,location + nreloc * sizeof(struct relocation_info))\n    \n    struct scattered_relocation_info const * scattered_relocation_info = NULL;\n    \n    if (relocation_info->r_address & R_SCATTERED)\n    {\n      scattered_relocation_info = (struct scattered_relocation_info const *)relocation_info;\n      relocation_info = NULL;\n    }\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    NSColor * color = nil;\n    \n    // read the first half of the entry\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Address\"\n                           :[NSString stringWithFormat:@\"0x%X\", relocation_info \n                             ? relocation_info->r_address + baseAddress \n                             : scattered_relocation_info->r_address + baseAddress]];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Scattered\":scattered_relocation_info ? @\"True\" : @\"False\"];\n    \n    // read the second half of the entry\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    \n    if (relocation_info)\n    {\n      uint64_t relocLocation = [self RVAToFileOffset:baseAddress + relocation_info->r_address];\n      NSRange rangeReloc = NSMakeRange(relocLocation,0);\n      uint32_t relocValue = [dataController read_uint32:rangeReloc];\n      uint32_t relocLength = (1 << relocation_info->r_length);\n      NSParameterAssert(relocLength == sizeof(uint32_t));\n      \n      // adjust for PC relative relocs\n      if (relocation_info->r_pcrel)\n      {\n        relocValue += relocation_info->r_address + baseAddress + relocLength;\n      }\n\n      if (relocation_info->r_extern)\n      {\n        // target is a symbol\n        if (relocation_info->r_symbolnum >= symbols.size())\n        {\n          [NSException raise:@\"Symbol\"\n                      format:@\"index is out of range %u\", relocation_info->r_symbolnum];\n        }\n        \n        struct nlist const * nlist = [self getSymbolByIndex:relocation_info->r_symbolnum];\n        symbolName = NSSTRING(strtab + nlist->n_un.n_strx);\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Symbol\"\n                               :(nlist->n_type & N_TYPE) == N_SECT \n                                  ? [NSString stringWithFormat:@\"0x%X (%@)\", nlist->n_value, symbolName]\n                                  : symbolName];\n        \n        [symbolNames setObject:[NSString stringWithFormat:@\"%@->%@\",\n                                [self findSymbolAtRVA:[self fileOffsetToRVA:relocLocation]],symbolName]\n                        forKey:[NSNumber numberWithUnsignedLong:[self fileOffsetToRVA:relocLocation]]];\n\n        if ((nlist->n_type & N_TYPE) == N_SECT)\n        {\n          // reference to local symbol\n          relocValue += nlist->n_value;\n        }\n        else \n        {\n          // reference to undefined external symbol\n\n          uint32_t relocAddend = relocValue;\n          \n          // use the negative index of the symbol (hope that will not overlap)\n          relocValue += *symbols.begin() - nlist - 1;\n          \n          if (relocAddend != 0) \n          {\n            [node.details appendRow:@\"\":@\"\":@\"Addend\":(int32_t)relocAddend < 0 \n                                                        ? [NSString stringWithFormat:@\"-0x%X\",-relocAddend] \n                                                        : [NSString stringWithFormat:@\"0x%X\",relocAddend]];\n          }\n        }\n      }\n      else // r_symbolnum means section index\n      {\n        if (relocation_info->r_symbolnum == R_ABS)\n        {\n          // absolute address\n          [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                 :lastReadHex\n                                 :@\"Section\"\n                                 :@\"R_ABS\"];\n        }\n        else\n        {\n          // section relative (symbolNum means sectionNum)\n          if (relocation_info->r_symbolnum >= sections.size())\n          {\n            [NSException raise:@\"Section\"\n                        format:@\"index is out of range %u\", relocation_info->r_symbolnum];\n          }\n          \n          struct section const * section = [self getSectionByIndex:relocation_info->r_symbolnum];\n          \n          NSString * sectionName = [NSString stringWithFormat:@\"(%s,%s)\", \n                                    string(section->segname,16).c_str(),\n                                    string(section->sectname,16).c_str()];\n          \n          [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                 :lastReadHex\n                                 :@\"Section\"\n                                 :[NSString stringWithFormat:@\"%u %@\", relocation_info->r_symbolnum, sectionName]];\n          \n          [node.details appendRow:@\"\":@\"\":@\"Target\":(symbolName = [self findSymbolAtRVA:relocValue])];\n          \n          [symbolNames setObject:[NSString stringWithFormat:@\"%@->%@\",\n                                  [self findSymbolAtRVA:[self fileOffsetToRVA:relocLocation]],symbolName]\n                          forKey:[NSNumber numberWithUnsignedLong:[self fileOffsetToRVA:relocLocation]]];\n        }\n      }\n\n      // update real data\n      [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n      //NSLog(@\"%@ %.8X --> %@\",[self findSectionContainsRVA:[self fileOffsetToRVA:relocLocation]],[self fileOffsetToRVA:relocLocation],[self findSymbolAtRVA:relocValue]);\n    } \n    else \n      \n    //=============================== scattered relocation ===============================\n      \n    if (scattered_relocation_info)\n    {\n      NSParameterAssert(scattered_relocation_info->r_pcrel == false); // have not faced with this yet\n      \n      uint32_t r_type = scattered_relocation_info->r_type;\n      if (\n          (mach_header->cputype == CPU_TYPE_I386 && (r_type == GENERIC_RELOC_SECTDIFF || r_type == GENERIC_RELOC_LOCAL_SECTDIFF))\n          ||\n          (mach_header->cputype == CPU_TYPE_ARM && (r_type == ARM_RELOC_SECTDIFF || r_type == ARM_RELOC_LOCAL_SECTDIFF))\n          )\n      {\n        prev_scattered_relocation_info = scattered_relocation_info;\n      }\n      else if (\n               ((mach_header->cputype == CPU_TYPE_I386 && r_type == GENERIC_RELOC_PAIR)\n               ||\n               (mach_header->cputype == CPU_TYPE_ARM && r_type == ARM_RELOC_PAIR))\n               && prev_scattered_relocation_info\n               )\n      {\n        //read original content at relocation\n        uint64_t relocLocation = [self RVAToFileOffset:baseAddress + prev_scattered_relocation_info->r_address];\n        uint32_t relocLength = (1 << prev_scattered_relocation_info->r_length);\n        NSAssert1(relocLength == sizeof(uint32_t), @\"unsupported reloc length (%u)\", relocLength);\n        NSRange rangeReloc = NSMakeRange(relocLocation,0);\n        uint32_t relocValue = [dataController read_uint32:rangeReloc];\n        uint32_t relocAddend = relocValue - (prev_scattered_relocation_info->r_value - scattered_relocation_info->r_value);\n\n        // the relocation value only differs if it has an addend\n        if (relocAddend != 0)\n        {\n          [node.details appendRow:@\"\":@\"\":@\"Addend\"\n                                 :(int32_t)relocAddend < 0 \n                                  ? [NSString stringWithFormat:@\"-0x%X\", -relocAddend] \n                                  : [NSString stringWithFormat:@\"0x%X\", relocAddend]];\n          \n          // update real data\n          relocValue += relocAddend;\n          [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n          //NSLog(@\"%@ %.8X --> %@\",[self findSectionContainsRVA:[self fileOffsetToRVA:relocLocation]],[self fileOffsetToRVA:relocLocation],[self findSymbolAtRVA:relocValue]);\n        }\n\n        prev_scattered_relocation_info = NULL; // reset\n      }\n    }\n    \n    //=============================== normal relocations ===============================\n    \n    if (mach_header->cputype == CPU_TYPE_I386)\n    {\n      uint32_t r_type = (relocation_info ? relocation_info->r_type : scattered_relocation_info->r_type);\n      \n      [node.details appendRow:@\"\":@\"\":@\"Type\"\n                             :r_type == GENERIC_RELOC_VANILLA ? @\"GENERIC_RELOC_VANILLA\" :\n                              r_type == GENERIC_RELOC_PAIR ? @\"GENERIC_RELOC_PAIR\" :\n                              r_type == GENERIC_RELOC_SECTDIFF ? @\"GENERIC_RELOC_SECTDIFF\" :\n                              r_type == GENERIC_RELOC_PB_LA_PTR ? @\"GENERIC_RELOC_PB_LA_PTR\" :\n                              r_type == GENERIC_RELOC_LOCAL_SECTDIFF ? @\"GENERIC_RELOC_LOCAL_SECTDIFF\" : \n                              r_type == GENERIC_RELOC_TLV ? @\"GENERIC_RELOC_TLV\" : @\"?????\"];\n    }\n    else if (mach_header->cputype == CPU_TYPE_ARM)\n    {\n      uint32_t r_type = (relocation_info ? relocation_info->r_type : scattered_relocation_info->r_type);\n      \n      [node.details appendRow:@\"\":@\"\":@\"Type\"\n                             :r_type == ARM_RELOC_VANILLA ? @\"ARM_RELOC_VANILLA\" :\n                              r_type == ARM_RELOC_PAIR ? @\"ARM_RELOC_PAIR\" :\n                              r_type == ARM_RELOC_SECTDIFF ? @\"ARM_RELOC_SECTDIFF\" :\n                              r_type == ARM_RELOC_LOCAL_SECTDIFF ? @\"ARM_RELOC_LOCAL_SECTDIFF\" :\n                              r_type == ARM_RELOC_PB_LA_PTR ? @\"ARM_RELOC_PB_LA_PTR\" :\n                              r_type == ARM_RELOC_BR24 ? @\"ARM_RELOC_BR24\" :\n                              r_type == ARM_THUMB_RELOC_BR22 ? @\"ARM_THUMB_RELOC_BR22\" :\n                              r_type == ARM_THUMB_32BIT_BRANCH ? @\"ARM_THUMB_32BIT_BRANCH\" :\n                              r_type == ARM_RELOC_HALF ? @\"ARM_RELOC_HALF\" :\n                              r_type == ARM_RELOC_HALF_SECTDIFF ? @\"ARM_RELOC_HALF_SECTDIFF\" : @\"?????\"];\n    }\n    \n    if (relocation_info)\n    {\n      [node.details appendRow:@\"\":@\"\":@\"External\"\n                             :relocation_info->r_extern ? @\"True\" : @\"False\"];\n    }\n    \n    [node.details appendRow:@\"\":@\"\":@\"PCRelative\"\n                           :(relocation_info && relocation_info->r_pcrel) || (scattered_relocation_info && scattered_relocation_info->r_pcrel) \n                            ? @\"True\" : @\"False\"];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Length\"\n                           :[NSString stringWithFormat:@\"%u\",\n                             relocation_info ? (1 << relocation_info->r_length) : (1 << scattered_relocation_info->r_length)]];\n    \n    if (scattered_relocation_info)\n    {\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Value\"\n                             :(symbolName = [self findSymbolAtRVA:scattered_relocation_info->r_value])];\n      \n      color = [NSColor magentaColor];\n    }\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,\n                                                      MVCellColorAttributeName,color,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  } // loop\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createReloc64Node:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length\n                   baseAddress:(uint64_t)baseAddress // start of the section containing the relocation (image: start of the first segment)\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  MATCH_STRUCT(mach_header_64,imageOffset);\n  \n  struct relocation_info const * prev_relocation_info = NULL;\n  \n  for (uint32_t nreloc = 0; nreloc < length / sizeof(struct relocation_info); ++nreloc)\n  {\n    if ([backgroundThread isCancelled]) break;\n    \n    // In the Mac OS X x86-64 environment scattered relocations are not used. Compiler-generated code\n    // uses mostly external relocations, in which the r_extern bit is set to 1 and the r_symbolnum field contains\n    // the symbol-table index of the target label.\n    \n    MATCH_STRUCT(relocation_info,location + nreloc * sizeof(struct relocation_info))\n    \n    uint32_t relocLength = (1 << relocation_info->r_length);\n    NSAssert1(relocLength == sizeof(uint32_t) || relocLength == sizeof(uint64_t), @\"unsupported reloc length (%u)\", relocLength);\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    NSColor * color = nil;\n\n    // read the first half of the entry\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Address\"\n                           :[NSString stringWithFormat:@\"0x%qX\", relocation_info->r_address + baseAddress]];\n\n    // read the second half of the entry\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    \n    //========================================================================\n    if (relocation_info->r_extern)\n    {\n      uint64_t relocLocation = [self RVAToFileOffset:baseAddress + relocation_info->r_address];\n      NSRange rangeReloc = NSMakeRange(relocLocation,0);\n\n      // target symbol\n      if (relocation_info->r_symbolnum >= symbols_64.size())\n      {\n        [NSException raise:@\"Symbol\"\n                    format:@\"symbol is out of range %u\", relocation_info->r_symbolnum];\n      }\n      \n      struct nlist_64 const * nlist_64 = [self getSymbol64ByIndex:relocation_info->r_symbolnum];\n      symbolName = NSSTRING(strtab + nlist_64->n_un.n_strx);\n      \n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Symbol\"\n                             :(nlist_64->n_type & N_TYPE) == N_SECT \n                                ? [NSString stringWithFormat:@\"0x%qX (%@)\", nlist_64->n_value, symbolName]\n                                : symbolName];\n      \n      [symbolNames setObject:[NSString stringWithFormat:@\"%@->%@\",\n                              [self findSymbolAtRVA:[self fileOffsetToRVA:relocLocation]],symbolName]\n                      forKey:[NSNumber numberWithUnsignedLongLong:[self fileOffsetToRVA:relocLocation]]];\n\n      // For the x86_64 architecure on Mac OS X it is possible to\n      // encode a signed 32-bit expression of the form:\n      // \"add_symbol - subtract_symbol + number\" \n      // using two relocation entries pointing at the same 32-bits.\n      // The first one has to be a X86_64_RELOC_SUBTRACTOR then must\n      // be followed by a X86_64_RELOC_UNSIGNED.\n      \n      if ((mach_header_64->cputype == CPU_TYPE_X86_64 && relocation_info->r_type == X86_64_RELOC_SUBTRACTOR)\n          ||\n          (mach_header_64->cputype == CPU_TYPE_ARM64 && relocation_info->r_type == ARM64_RELOC_SUBTRACTOR))\n      {\n        color = [NSColor magentaColor];\n        prev_relocation_info = relocation_info;\n      } \n      else if (prev_relocation_info)\n      {\n        // reference computed from difference of two symbols\n        //============================================\n\n        NSAssert(!(mach_header_64->cputype == CPU_TYPE_X86_64) || relocation_info->r_type == X86_64_RELOC_UNSIGNED, @\"X86_64_RELOC_SUBTRACTOR must be followed by X86_64_RELOC_UNSIGNED\");\n        NSAssert(!(mach_header_64->cputype == CPU_TYPE_ARM64) || relocation_info->r_type == ARM64_RELOC_UNSIGNED, @\"ARM64_RELOC_SUBTRACTOR must be followed by ARM64_RELOC_UNSIGNED\");\n        NSParameterAssert (relocation_info->r_address == prev_relocation_info->r_address);\n        \n        color = [NSColor magentaColor];\n        \n        if (relocation_info->r_symbolnum >= symbols_64.size())\n        {\n          [NSException raise:@\"Symbol\"\n                      format:@\"index is out of range %u\", relocation_info->r_symbolnum];\n        }\n        \n        struct nlist_64 const * prev_nlist_64 = [self getSymbol64ByIndex:prev_relocation_info->r_symbolnum];\n        \n        if (relocLength == sizeof(uint32_t))\n        {\n          uint32_t relocAddend = [dataController read_uint32:rangeReloc];\n          if (relocAddend != 0) \n          {\n            [node.details appendRow:@\"\":@\"\":@\"Addend\"\n                                   :(int32_t)relocAddend < 0 \n                                    ? [NSString stringWithFormat:@\"-0x%X\",-relocAddend] \n                                    : [NSString stringWithFormat:@\"0x%X\",relocAddend]];\n          }\n          uint64_t relocValue = nlist_64->n_value - prev_nlist_64->n_value + relocAddend;\n          \n          // update real data\n          [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n          //NSLog(@\"diff32:  %@ %.16qX --> (%u) %@\",[self findSectionContainsRVA64:[self fileOffsetToRVA64:relocLocation]],[self fileOffsetToRVA64:relocLocation],relocLength,[self findSymbolAtRVA64:relocValue]);\n        }\n        else if (relocLength == sizeof(uint64_t))\n        {\n          uint64_t relocAddend = [dataController read_uint64:rangeReloc];\n          if (relocAddend != 0) \n          {\n            [node.details appendRow:@\"\":@\"\":@\"Addend\"\n                                   :(int64_t)relocAddend < 0\n                                    ? [NSString stringWithFormat:@\"-0x%qX\",-relocAddend] \n                                    : [NSString stringWithFormat:@\"0x%qX\",relocAddend]];\n          }\n          uint64_t relocValue = nlist_64->n_value - prev_nlist_64->n_value + relocAddend;\n          \n          // update real data\n          [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n          //NSLog(@\"diff64:  %@ %.16qX --> (%u) %@\",[self findSectionContainsRVA64:[self fileOffsetToRVA64:relocLocation]],[self fileOffsetToRVA64:relocLocation],relocLength,[self findSymbolAtRVA64:relocValue]);\n        }\n        prev_relocation_info = NULL; // reset\n      } \n      else if ((nlist_64->n_type & N_TYPE) == N_SECT)\n      {\n        // reference to local symbol\n        //============================================\n        \n        if (relocLength == sizeof(uint32_t))\n        {\n          // 32bit signed PC Rel\n          NSParameterAssert(relocation_info->r_pcrel == true);\n          // XXX: is this cast correct?\n          uint32_t relocValue = (uint32_t)(nlist_64->n_value - relocation_info->r_address - baseAddress - relocLength);\n          uint32_t relocAddend = [dataController read_uint32:rangeReloc];\n\n          if (mach_header_64->cputype == CPU_TYPE_X86_64)\n          {\n            relocAddend -= (relocation_info->r_type == X86_64_RELOC_SIGNED_1 ? 1 :\n                                   relocation_info->r_type == X86_64_RELOC_SIGNED_2 ? 2 :\n                                   relocation_info->r_type == X86_64_RELOC_SIGNED_4 ? 4 : 0);\n          }\n          \n          if (relocAddend != 0)\n          {\n            [node.details appendRow:@\"\":@\"\":@\"Addend\"\n                                   :(int32_t)relocAddend < 0 \n                                    ? [NSString stringWithFormat:@\"-0x%X\",-relocAddend] \n                                    : [NSString stringWithFormat:@\"0x%X\",relocAddend]];\n          }\n          \n          // update real data\n          relocValue += relocAddend;\n          [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n          //NSLog(@\"local32: %@ %.16qX --> (%u) %@\",[self findSectionContainsRVA64:[self fileOffsetToRVA64:relocLocation]],[self fileOffsetToRVA64:relocLocation],relocLength,[self findSymbolAtRVA64:relocValue]);\n        }\n        else if (relocLength == sizeof(uint64_t))\n        {\n          // 64bit unsigned direct\n          NSParameterAssert(relocation_info->r_pcrel == false);\n          uint64_t relocValue = nlist_64->n_value;\n          uint64_t relocAddend = [dataController read_uint64:rangeReloc];\n          if (relocAddend != 0) \n          {\n            [node.details appendRow:@\"\":@\"\":@\"Addend\"\n                                   :(int64_t)relocAddend < 0\n                                    ? [NSString stringWithFormat:@\"-0x%qX\",-relocAddend] \n                                    : [NSString stringWithFormat:@\"0x%qX\",relocAddend]];\n          }\n          \n          // update real data\n          relocValue += relocAddend;\n          [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n          //NSLog(@\"local64: %@ %.16qX --> (%u) %@\",[self findSectionContainsRVA64:[self fileOffsetToRVA64:relocLocation]],[self fileOffsetToRVA64:relocLocation],relocLength,[self findSymbolAtRVA64:relocValue]);\n        }\n      }\n      else\n      {\n        // reference to undefined external symbol\n        //============================================\n        \n        NSParameterAssert((nlist_64->n_type & N_TYPE) == N_UNDF);  // N_PBUD is only in image\n        \n        if (relocLength == sizeof(uint32_t))\n        {\n          NSParameterAssert(relocation_info->r_pcrel == true);\n          NSRange rangeReloc = NSMakeRange(relocLocation,0);\n          uint32_t relocAddend = [dataController read_uint32:rangeReloc];\n          \n          if (mach_header_64->cputype == CPU_TYPE_X86_64)\n          {\n            relocAddend -= (relocation_info->r_type == X86_64_RELOC_SIGNED_1 ? 1 :\n                                   relocation_info->r_type == X86_64_RELOC_SIGNED_2 ? 2 :\n                                   relocation_info->r_type == X86_64_RELOC_SIGNED_4 ? 4 : 0);\n          }\n          \n          if (relocAddend != 0) \n          {\n            [node.details appendRow:@\"\":@\"\":@\"Addend\"\n                                   :(int32_t)relocAddend < 0\n                                    ? [NSString stringWithFormat:@\"-0x%X\",-relocAddend] \n                                    : [NSString stringWithFormat:@\"0x%X\",relocAddend]];\n          }\n          // XXX: is this cast correct?\n          uint32_t relocValue = (uint32_t)(*symbols_64.begin() - nlist_64 - 1);\n          relocValue -= relocation_info->r_address + baseAddress + relocLength; // it is PC relative\n          \n          // update real data\n          relocValue += relocAddend;\n          [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n          //NSLog(@\"undef32: %@ %.16qX --> (%u) %@\",[self findSectionContainsRVA64:[self fileOffsetToRVA64:relocLocation]],[self fileOffsetToRVA64:relocLocation],relocLength,[self findSymbolAtRVA64:relocValue]);\n        }\n        else \n        {\n          NSParameterAssert(relocation_info->r_pcrel == false);\n          NSRange rangeReloc = NSMakeRange(relocLocation,0);\n          uint64_t relocAddend = [dataController read_uint64:rangeReloc];\n          if (relocAddend != 0) \n          {\n            [node.details appendRow:@\"\":@\"\":@\"Addend\"\n                                   :(int64_t)relocAddend < 0 \n                                    ? [NSString stringWithFormat:@\"-0x%qX\",-relocAddend]\n                                    : [NSString stringWithFormat:@\"0x%qX\",relocAddend]];\n          }\n          uint64_t relocValue = *symbols_64.begin() - nlist_64 - 1;\n          \n          // update real data\n          relocValue += relocAddend;\n          [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n          //NSLog(@\"undef64: %@ %.16qX --> (%u) %@\",[self findSectionContainsRVA64:[self fileOffsetToRVA64:relocLocation]],[self fileOffsetToRVA64:relocLocation],relocLength,[self findSymbolAtRVA64:relocValue]);\n        }\n      }\n    }\n    else // r_symbolnum means section index\n    {\n      // section relative (symbolNum means sectionNum)\n      if (relocation_info->r_symbolnum >= sections_64.size())\n      {\n        [NSException raise:@\"Section\"\n                    format:@\"index is out of range %u\", relocation_info->r_symbolnum];\n      }\n      \n      struct section_64 const * section_64 = [self getSection64ByIndex:relocation_info->r_symbolnum];\n      \n      NSString * sectionName = [NSString stringWithFormat:@\"(%s,%s)\", \n                                string(section_64->segname,16).c_str(),\n                                string(section_64->sectname,16).c_str()];\n      \n      if (relocation_info->r_symbolnum == R_ABS)\n      {\n        // absolute address\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Section\"\n                               :@\"R_ABS\"];\n      }\n      else\n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Section\"\n                               :[NSString stringWithFormat:@\"%u %@\", relocation_info->r_symbolnum, sectionName]];\n        \n        uint64_t relocLocation = [self RVAToFileOffset:baseAddress + relocation_info->r_address];\n        NSRange rangeReloc = NSMakeRange(relocLocation,0);\n        uint64_t relocValue = 0;\n        \n        if ((mach_header_64->cputype == CPU_TYPE_X86_64 && relocation_info->r_type == X86_64_RELOC_SUBTRACTOR)\n            ||\n            (mach_header_64->cputype == CPU_TYPE_ARM64 && relocation_info->r_type == ARM64_RELOC_SUBTRACTOR))\n        {\n          prev_relocation_info = relocation_info;\n        }\n        else if (prev_relocation_info)\n        {\n          // TODO: calculate if we will ever be interested of the target \n          // (usually used only in debug_line section)\n          prev_relocation_info = NULL;\n        }\n        else if (relocLength == sizeof(uint32_t))\n        {\n          relocValue = [dataController read_uint32:rangeReloc];\n\n          if ((mach_header_64->cputype == CPU_TYPE_X86_64 && relocation_info->r_type == X86_64_RELOC_UNSIGNED)\n              ||\n              (mach_header_64->cputype == CPU_TYPE_ARM64 && relocation_info->r_type == ARM64_RELOC_UNSIGNED))\n          {\n            // 32bit direct relocation\n            NSParameterAssert (relocation_info->r_pcrel == false);\n          }\n          else\n          {\n            // 32bit PC relative signed relocation\n            NSParameterAssert (relocation_info->r_pcrel == true);\n            relocValue += relocation_info->r_address + baseAddress + relocLength;\n            \n            if (mach_header_64->cputype == CPU_TYPE_X86_64)\n            {\n              relocValue -= (relocation_info->r_type == X86_64_RELOC_SIGNED_1 ? 1 :\n                           relocation_info->r_type == X86_64_RELOC_SIGNED_2 ? 2 :\n                           relocation_info->r_type == X86_64_RELOC_SIGNED_4 ? 4 : 0);\n          }\n            \n          }\n        }\n        else if (relocLength == sizeof(uint64_t))\n        {\n          // 64bit direct relocation\n          NSParameterAssert (!(mach_header_64->cputype == CPU_TYPE_X86_64) || relocation_info->r_type == X86_64_RELOC_UNSIGNED);\n          NSParameterAssert (!(mach_header_64->cputype == CPU_TYPE_ARM64) || relocation_info->r_type == ARM64_RELOC_UNSIGNED);\n          NSParameterAssert (relocation_info->r_pcrel == false);\n          relocValue = [dataController read_uint64:rangeReloc];\n        }\n        else\n        {\n          NSAssert(NO, @\"Unsupported 64bit reloc\");\n        }\n        \n        [node.details appendRow:@\"\":@\"\":@\"Target\":(symbolName = [self findSymbolAtRVA:relocValue])];\n        \n        // update real data\n        [self addRelocAtFileOffset:relocLocation withLength:relocLength andValue:relocValue];\n        \n        [symbolNames setObject:[NSString stringWithFormat:@\"%@->%@\",\n                                [self findSymbolAtRVA:[self fileOffsetToRVA:relocLocation]],symbolName]\n                        forKey:[NSNumber numberWithUnsignedLongLong:[self fileOffsetToRVA:relocLocation]]];\n\n        //NSLog(@\"%@ %.16qX --> (%u) %@\",[self findSectionContainsRVA64:[self fileOffsetToRVA64:relocLocation]],[self fileOffsetToRVA64:relocLocation],relocLength,[self findSymbolAtRVA64:relocValue]);\n      }\n    }\n    //========== end of differentation \n    \n    if (mach_header_64->cputype == CPU_TYPE_X86_64)\n    {\n    [node.details appendRow:@\"\":@\"\":@\"Type\"\n                           :relocation_info->r_type == X86_64_RELOC_UNSIGNED ? @\"X86_64_RELOC_UNSIGNED\" :\n                            relocation_info->r_type == X86_64_RELOC_SIGNED ? @\"X86_64_RELOC_SIGNED\" :\n                            relocation_info->r_type == X86_64_RELOC_BRANCH ? @\"X86_64_RELOC_BRANCH\" :\n                            relocation_info->r_type == X86_64_RELOC_GOT_LOAD ? @\"X86_64_RELOC_GOT_LOAD\" :\n                            relocation_info->r_type == X86_64_RELOC_GOT ? @\"X86_64_RELOC_GOT\" :\n                            relocation_info->r_type == X86_64_RELOC_SUBTRACTOR ? @\"X86_64_RELOC_SUBTRACTOR\" :\n                            relocation_info->r_type == X86_64_RELOC_SIGNED_1 ? @\"X86_64_RELOC_SIGNED_1\" :\n                            relocation_info->r_type == X86_64_RELOC_SIGNED_2 ? @\"X86_64_RELOC_SIGNED_2\" :\n                            relocation_info->r_type == X86_64_RELOC_SIGNED_4 ? @\"X86_64_RELOC_SIGNED_4\" : @\"?????\"];\n    }\n    else if (mach_header_64->cputype == CPU_TYPE_ARM64)\n    {\n      [node.details appendRow:@\"\":@\"\":@\"Type\"\n                             :relocation_info->r_type == ARM64_RELOC_UNSIGNED ? @\"ARM64_RELOC_UNSIGNED\" :\n                              relocation_info->r_type == ARM64_RELOC_SUBTRACTOR ? @\"ARM64_RELOC_SUBTRACTOR\" :\n                              relocation_info->r_type == ARM64_RELOC_BRANCH26 ? @\"ARM64_RELOC_BRANCH26\" :\n                              relocation_info->r_type == ARM64_RELOC_PAGE21 ? @\"ARM64_RELOC_PAGE21\" :\n                              relocation_info->r_type == ARM64_RELOC_PAGEOFF12 ? @\"ARM64_RELOC_PAGEOFF12\" :\n                              relocation_info->r_type == ARM64_RELOC_GOT_LOAD_PAGE21 ? @\"ARM64_RELOC_GOT_LOAD_PAGE21\" :\n                              relocation_info->r_type == ARM64_RELOC_GOT_LOAD_PAGEOFF12 ? @\"ARM64_RELOC_GOT_LOAD_PAGEOFF12\" :\n                              relocation_info->r_type == ARM64_RELOC_POINTER_TO_GOT ? @\"ARM64_RELOC_POINTER_TO_GOT\" :\n                              relocation_info->r_type == ARM64_RELOC_TLVP_LOAD_PAGE21 ? @\"ARM64_RELOC_TLVP_LOAD_PAGE21\" :\n                              relocation_info->r_type == ARM64_RELOC_TLVP_LOAD_PAGEOFF12 ? @\"ARM64_RELOC_TLVP_LOAD_PAGEOFF12\" :\n                              relocation_info->r_type == ARM64_RELOC_ADDEND ? @\"ARM64_RELOC_ADDEND\" : @\"?????\"];\n    }\n    \n    if (relocation_info)\n    {\n      [node.details appendRow:@\"\":@\"\":@\"External\"\n                             :relocation_info->r_extern ? @\"True\" : @\"False\"];\n    }\n    \n    [node.details appendRow:@\"\":@\"\":@\"PCRelative\"\n                           :relocation_info->r_pcrel ? @\"True\" : @\"False\"];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Length\"\n                           :[NSString stringWithFormat:@\"%u\", relocLength]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,\n                                                      MVCellColorAttributeName,color,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  } // loop relocs\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createSymbolsNode:parent \n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  for (uint32_t nsym = 0; nsym < length / sizeof(struct nlist); ++nsym)\n  {\n    if ([backgroundThread isCancelled]) break;\n    \n    MATCH_STRUCT(nlist, location + nsym * sizeof(struct nlist))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = NSSTRING(strtab + nlist->n_un.n_strx);\n    NSColor * color = nil;\n    \n    /* print the symbol nr */\n    [node.details appendRow:[NSString stringWithFormat:@\"#%d\", nsym]\n                           :@\"\"\n                           :@\"\"\n                           :@\"\"];\n      \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"String Table Index\"\n                           :symbolName];\n    \n    [dataController read_uint8:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Type\"\n                           :@\"\"];\n    \n    if (nlist->n_type & N_STAB)\n    {\n      [node.details appendRow:@\"\":@\"\":@\"E0\":@\"N_STAB\"];\n      color = [NSColor magentaColor];\n    }\n    else\n    {\n      switch (nlist->n_type & N_TYPE)\n      {\n        case N_UNDF:  [node.details appendRow:@\"\":@\"\":@\"00\":@\"N_UNDF\"]; break;\n        case N_ABS:   [node.details appendRow:@\"\":@\"\":@\"02\":@\"N_ABS\"]; break;\n        case N_SECT:  [node.details appendRow:@\"\":@\"\":@\"0E\":@\"N_SECT\"]; break;\n        case N_PBUD:  [node.details appendRow:@\"\":@\"\":@\"0C\":@\"N_PBUD\"]; break;\n        case N_INDR:  [node.details appendRow:@\"\":@\"\":@\"0A\":@\"N_INDR\"]; break;\n      }\n      \n      if (nlist->n_type & N_PEXT) [node.details appendRow:@\"\":@\"\":@\"10\":@\"N_PEXT\"];\n      if (nlist->n_type & N_EXT)  [node.details appendRow:@\"\":@\"\":@\"01\":@\"N_EXT\"];\n      \n      if (nlist->n_type & N_EXT) color = ((nlist->n_type & N_TYPE) == N_UNDF || (nlist->n_type & N_TYPE) == N_PBUD \n                                          ? [NSColor greenColor] : [NSColor orangeColor]);\n    }\n    \n    struct section const * section = [self getSectionByIndex:nlist->n_sect];\n    \n    [dataController read_uint8:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Section Index\"\n                           :nlist->n_sect == NO_SECT ? @\"NO_SECT\" \n                              : [NSString stringWithFormat:@\"%u (%s,%s)\", \n                                 nlist->n_sect,\n                                 string(section->segname,16).c_str(),\n                                 string(section->sectname,16).c_str()]];\n    \n    [dataController read_uint16:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Description\"\n                           :@\"\"];\n    \n    if ((nlist->n_type & N_STAB) == 0 && \n        ((nlist->n_type & N_TYPE) == N_UNDF || (nlist->n_type & N_TYPE) == N_PBUD) &&\n        (nlist->n_type & N_EXT))\n    {\n      switch (nlist->n_desc & REFERENCE_TYPE)\n      {\n        case REFERENCE_FLAG_UNDEFINED_NON_LAZY:         [node.details appendRow:@\"\":@\"\":@\"0\":@\"REFERENCE_FLAG_UNDEFINED_NON_LAZY\"]; break;\n        case REFERENCE_FLAG_UNDEFINED_LAZY:             [node.details appendRow:@\"\":@\"\":@\"1\":@\"REFERENCE_FLAG_UNDEFINED_LAZY\"]; break;\n        case REFERENCE_FLAG_DEFINED:                    [node.details appendRow:@\"\":@\"\":@\"2\":@\"REFERENCE_FLAG_DEFINED\"]; break;\n        case REFERENCE_FLAG_PRIVATE_DEFINED:            [node.details appendRow:@\"\":@\"\":@\"3\":@\"REFERENCE_FLAG_PRIVATE_DEFINED\"]; break;\n        case REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY: [node.details appendRow:@\"\":@\"\":@\"4\":@\"REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY\"]; break;\n        case REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY:     [node.details appendRow:@\"\":@\"\":@\"5\":@\"REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY\"]; break;\n        default: \n          [node.details appendRow:@\"\":@\"\":[NSString stringWithFormat:@\"%u\",nlist->n_desc & REFERENCE_TYPE]:@\"???\"]; break;\n      }\n      \n      uint32_t libOrdinal = GET_LIBRARY_ORDINAL(nlist->n_desc);\n      struct dylib const * dylib = [self getDylibByIndex:libOrdinal];\n      \n      [node.details appendRow:@\"\":@\"\":@\"Library Ordinal\"\n                             :[NSString stringWithFormat:@\"%u (%@)\",libOrdinal,\n                               libOrdinal == SELF_LIBRARY_ORDINAL ? @\"SELF_LIBRARY_ORDINAL\" :\n                               libOrdinal == DYNAMIC_LOOKUP_ORDINAL ? @\"DYNAMIC_LOOKUP_ORDINAL\" :\n                               libOrdinal == EXECUTABLE_ORDINAL ? @\"EXECUTABLE_ORDINAL\" :\n                               [NSSTRING((uint8_t *)dylib + dylib->name.offset - sizeof(struct load_command)) lastPathComponent]]];\n    }\n    \n    if ((nlist->n_desc & N_ARM_THUMB_DEF) == N_ARM_THUMB_DEF)               [node.details appendRow:@\"\":@\"\":@\"0008\":@\"N_ARM_THUMB_DEF\"];\n    if ((nlist->n_desc & REFERENCED_DYNAMICALLY) == REFERENCED_DYNAMICALLY) [node.details appendRow:@\"\":@\"\":@\"0010\":@\"REFERENCED_DYNAMICALLY\"];\n    if ((nlist->n_desc & N_NO_DEAD_STRIP) == N_NO_DEAD_STRIP)               [node.details appendRow:@\"\":@\"\":@\"0020\":@\"N_NO_DEAD_STRIP\"];\n    if ((nlist->n_desc & N_WEAK_REF) == N_WEAK_REF)                         [node.details appendRow:@\"\":@\"\":@\"0040\":@\"N_WEAK_REF\"];\n\n    if ((nlist->n_type & N_TYPE) == N_UNDF)\n    {\n      if ((nlist->n_desc & N_REF_TO_WEAK) == N_REF_TO_WEAK)                 [node.details appendRow:@\"\":@\"\":@\"0080\":@\"N_REF_TO_WEAK\"];\n    }\n    else\n    {\n      if ((nlist->n_desc & N_WEAK_DEF) == N_WEAK_DEF)                       [node.details appendRow:@\"\":@\"\":@\"0080\":@\"N_WEAK_DEF\"];\n      if ((nlist->n_desc & N_SYMBOL_RESOLVER) == N_SYMBOL_RESOLVER)         [node.details appendRow:@\"\":@\"\":@\"0100\":@\"N_SYMBOL_RESOLVER\"];\n    }\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    if ((nlist->n_type & N_TYPE) == N_SECT)\n    {\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Value\"\n                             :(nlist->n_type & N_STAB) || section == NULL\n                                ? [NSString stringWithFormat:@\"%u\", nlist->n_value] : nlist->n_value == 0 ? @\"0\"\n                                : [NSString stringWithFormat:@\"%u ($+%u)\", nlist->n_value, nlist->n_value - section->addr]];\n      \n      // fill in lookup table with defined sybols\n      if ((nlist->n_type & N_STAB) == 0)\n      {\n        // it is possible to associate more than one symbol to the same address.\n        // every new symbol will be appended to the list\n        \n        NSString * nameToStore = [symbolNames objectForKey:[NSNumber numberWithUnsignedLong:nlist->n_value]];\n        nameToStore = (nameToStore != nil \n                       ? [nameToStore stringByAppendingFormat:@\"(%@)\", symbolName] \n                       : [NSString stringWithFormat:@\"0x%X (%@)\", nlist->n_value, symbolName]);\n        \n        [symbolNames setObject:nameToStore\n                        forKey:[NSNumber numberWithUnsignedLong:nlist->n_value]];\n      }\n    } \n    else\n    {\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Value\"\n                             :[NSString stringWithFormat:@\"%u\", nlist->n_value]];\n      \n      // fill in lookup table with undefined sybols (key equals (-1) * index)\n      uint32_t key = (uint32_t)(*symbols.begin() - nlist - 1);\n      [symbolNames setObject:symbolName\n                      forKey:[NSNumber numberWithUnsignedLong:key]];\n    }\n\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,\n                                                      MVCellColorAttributeName,color,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  } // loop\n\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createSymbols64Node:parent \n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  for (uint32_t nsym = 0; nsym < length / sizeof(struct nlist_64); ++nsym)\n  {\n    if ([backgroundThread isCancelled]) break;\n    \n    MATCH_STRUCT(nlist_64, location + nsym * sizeof(struct nlist_64))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = NSSTRING(strtab + nlist_64->n_un.n_strx);\n    NSColor * color = nil;\n    \n    /* print the symbol nr */\n    [node.details appendRow:[NSString stringWithFormat:@\"#%d\", nsym]\n                           :@\"\"\n                           :@\"\"\n                           :@\"\"];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"String Table Index\"\n                           :symbolName];\n    \n    [dataController read_uint8:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Type\"\n                           :@\"\"];\n    \n    if (nlist_64->n_type & N_STAB)\n    {\n      [node.details appendRow:@\"\":@\"\":@\"E0\":@\"N_STAB\"];\n      color = [NSColor magentaColor];\n    }\n    else\n    {\n      switch (nlist_64->n_type & N_TYPE)\n      {\n        case N_UNDF:  [node.details appendRow:@\"\":@\"\":@\"00\":@\"N_UNDF\"]; break;\n        case N_ABS:   [node.details appendRow:@\"\":@\"\":@\"02\":@\"N_ABS\"]; break;\n        case N_SECT:  [node.details appendRow:@\"\":@\"\":@\"0E\":@\"N_SECT\"]; break;\n        case N_PBUD:  [node.details appendRow:@\"\":@\"\":@\"0C\":@\"N_PBUD\"]; break;\n        case N_INDR:  [node.details appendRow:@\"\":@\"\":@\"0A\":@\"N_INDR\"]; break;\n      }\n      \n      if (nlist_64->n_type & N_PEXT) [node.details appendRow:@\"\":@\"\":@\"10\":@\"N_PEXT\"];\n      if (nlist_64->n_type & N_EXT)  [node.details appendRow:@\"\":@\"\":@\"01\":@\"N_EXT\"];\n      \n      if (nlist_64->n_type & N_EXT) color = ((nlist_64->n_type & N_TYPE) == N_UNDF || (nlist_64->n_type & N_TYPE) == N_PBUD \n                                             ? [NSColor greenColor] : [NSColor orangeColor]);\n    }\n    \n    struct section_64 const * section_64 = [self getSection64ByIndex:nlist_64->n_sect];\n    \n    [dataController read_uint8:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Section Index\"\n                           :nlist_64->n_sect == NO_SECT ? @\"NO_SECT\" \n                              : [NSString stringWithFormat:@\"%u (%s,%s)\", \n                                 nlist_64->n_sect,\n                                 string(section_64->segname,16).c_str(),\n                                 string(section_64->sectname,16).c_str()]];\n    \n    [dataController read_uint16:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Description\"\n                           :@\"\"];\n    \n    if ((nlist_64->n_type & N_STAB) == 0 && \n        ((nlist_64->n_type & N_TYPE) == N_UNDF || (nlist_64->n_type & N_TYPE) == N_PBUD) &&\n        (nlist_64->n_type & N_EXT))\n    {\n      switch (nlist_64->n_desc & REFERENCE_TYPE)\n      {\n        case REFERENCE_FLAG_UNDEFINED_NON_LAZY:         [node.details appendRow:@\"\":@\"\":@\"0\":@\"REFERENCE_FLAG_UNDEFINED_NON_LAZY\"]; break;\n        case REFERENCE_FLAG_UNDEFINED_LAZY:             [node.details appendRow:@\"\":@\"\":@\"1\":@\"REFERENCE_FLAG_UNDEFINED_LAZY\"]; break;\n        case REFERENCE_FLAG_DEFINED:                    [node.details appendRow:@\"\":@\"\":@\"2\":@\"REFERENCE_FLAG_DEFINED\"]; break;\n        case REFERENCE_FLAG_PRIVATE_DEFINED:            [node.details appendRow:@\"\":@\"\":@\"3\":@\"REFERENCE_FLAG_PRIVATE_DEFINED\"]; break;\n        case REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY: [node.details appendRow:@\"\":@\"\":@\"4\":@\"REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY\"]; break;\n        case REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY:     [node.details appendRow:@\"\":@\"\":@\"5\":@\"REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY\"]; break;\n        default:\n          [node.details appendRow:@\"\":@\"\":[NSString stringWithFormat:@\"%u\",nlist_64->n_desc & REFERENCE_TYPE]:@\"???\"]; break;\n      }\n      \n      uint32_t libOrdinal = GET_LIBRARY_ORDINAL(nlist_64->n_desc);\n      struct dylib const * dylib = [self getDylibByIndex:libOrdinal];\n      \n      [node.details appendRow:@\"\":@\"\":@\"Library Ordinal\"\n                             :[NSString stringWithFormat:@\"%u (%@)\",libOrdinal,\n                               libOrdinal == SELF_LIBRARY_ORDINAL ? @\"SELF_LIBRARY_ORDINAL\" :\n                               libOrdinal == DYNAMIC_LOOKUP_ORDINAL ? @\"DYNAMIC_LOOKUP_ORDINAL\" :\n                               libOrdinal == EXECUTABLE_ORDINAL ? @\"EXECUTABLE_ORDINAL\" :\n                               [NSSTRING((uint8_t *)dylib + dylib->name.offset - sizeof(struct load_command)) lastPathComponent]]];\n    }\n    \n    if ((nlist_64->n_desc & REFERENCED_DYNAMICALLY) == REFERENCED_DYNAMICALLY)  [node.details appendRow:@\"\":@\"\":@\"0010\":@\"REFERENCED_DYNAMICALLY\"];\n    if ((nlist_64->n_desc & N_NO_DEAD_STRIP) == N_NO_DEAD_STRIP)                [node.details appendRow:@\"\":@\"\":@\"0020\":@\"N_NO_DEAD_STRIP\"];\n    if ((nlist_64->n_desc & N_WEAK_REF) == N_WEAK_REF)                          [node.details appendRow:@\"\":@\"\":@\"0040\":@\"N_WEAK_REF\"];\n    if ((nlist_64->n_desc & N_WEAK_DEF) == N_WEAK_DEF)                          [node.details appendRow:@\"\":@\"\":@\"0080\":\n                                                                                 (nlist_64->n_type & N_TYPE) == N_UNDF || (nlist_64->n_type & N_TYPE) == N_PBUD \n                                                                                  ? @\"N_REF_TO_WEAK\" \n                                                                                  : @\"N_WEAK_DEF\"];\n    if ((nlist_64->n_desc & N_SYMBOL_RESOLVER) == N_SYMBOL_RESOLVER)            [node.details appendRow:@\"\":@\"\":@\"0100\":@\"N_SYMBOL_RESOLVER\"];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    if ((nlist_64->n_type & N_TYPE) == N_SECT)\n    {\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Value\"\n                             :(nlist_64->n_type & N_STAB) || section_64 == NULL\n                                ? [NSString stringWithFormat:@\"%qu\", nlist_64->n_value] : nlist_64->n_value == 0 ? @\"0\"\n                                : [NSString stringWithFormat:@\"%qu ($+%qu)\", nlist_64->n_value, nlist_64->n_value - section_64->addr]];\n      \n      // fill in lookup table with defined sybols\n      if ((nlist_64->n_type & N_STAB) == 0)\n      {\n        // it is possible to associate more than one symbol to the same address.\n        // every new symbol will be appended to the list\n\n        NSString * nameToStore = [symbolNames objectForKey:[NSNumber numberWithUnsignedLongLong:nlist_64->n_value]];\n        nameToStore = (nameToStore != nil \n                       ? [nameToStore stringByAppendingFormat:@\"(%@)\", symbolName] \n                       : [NSString stringWithFormat:@\"0x%qX (%@)\", nlist_64->n_value, symbolName]);\n        \n        [symbolNames setObject:nameToStore\n                        forKey:[NSNumber numberWithUnsignedLongLong:nlist_64->n_value]];\n      }\n    } \n    else\n    {\n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"Value\"\n                             :[NSString stringWithFormat:@\"%qu\", nlist_64->n_value]];\n      \n      // fill in lookup table with undefined sybols (key equals (-1) * index)\n      uint64_t key = *symbols_64.begin() - nlist_64 - 1;\n      [symbolNames setObject:symbolName\n                      forKey:[NSNumber numberWithUnsignedLongLong:key]];\n    }\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,\n                                                      MVCellColorAttributeName,color,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  } // loop\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createReferencesNode:parent \n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(dylib_reference, NSMaxRange(range))\n    \n    if (dylib_reference->isym >= symbols.size())\n    {\n      [NSException raise:@\"Symbol\"\n                  format:@\"index is out of range %u\", dylib_reference->isym];\n    }\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = NSSTRING(strtab + [self getSymbolByIndex:dylib_reference->isym]->n_un.n_strx);\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Symbol\"\n                           :symbolName];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Flags\":@\"\"];\n    \n    switch (dylib_reference->flags)\n    {\n      case REFERENCE_FLAG_UNDEFINED_NON_LAZY:         [node.details appendRow:@\"\":@\"\":@\"0\":@\"REFERENCE_FLAG_UNDEFINED_NON_LAZY\"]; break;\n      case REFERENCE_FLAG_UNDEFINED_LAZY:             [node.details appendRow:@\"\":@\"\":@\"1\":@\"REFERENCE_FLAG_UNDEFINED_LAZY\"]; break;\n      case REFERENCE_FLAG_DEFINED:                    [node.details appendRow:@\"\":@\"\":@\"2\":@\"REFERENCE_FLAG_DEFINED\"]; break;\n      case REFERENCE_FLAG_PRIVATE_DEFINED:            [node.details appendRow:@\"\":@\"\":@\"3\":@\"REFERENCE_FLAG_PRIVATE_DEFINED\"]; break;\n      case REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY: [node.details appendRow:@\"\":@\"\":@\"4\":@\"REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY\"]; break;\n      case REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY:     [node.details appendRow:@\"\":@\"\":@\"5\":@\"REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY\"]; break;\n      default:\n        [node.details appendRow:@\"\":@\"\":[NSString stringWithFormat:@\"%u\",dylib_reference->flags]:@\"???\"]; break;\n    }\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createISymbolsNode:parent\n                        caption:(NSString *)caption\n                       location:(uint64_t)location\n                         length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  for (uint32_t nindsym = 0; nindsym < length / sizeof(uint32_t); ++nindsym)\n  {\n    uint32_t nsect = (uint32_t)sections.size();\n    while (--nsect > 0)\n    {\n      struct section const * section = [self getSectionByIndex:nsect];\n      \n      if (((section->flags & SECTION_TYPE) != S_SYMBOL_STUBS &&\n           (section->flags & SECTION_TYPE) != S_LAZY_SYMBOL_POINTERS &&\n           (section->flags & SECTION_TYPE) != S_LAZY_DYLIB_SYMBOL_POINTERS &&\n           (section->flags & SECTION_TYPE) != S_NON_LAZY_SYMBOL_POINTERS) ||\n          section->reserved1 > nindsym)\n      {\n        // section type or indirect symbol index mismatch\n        continue;\n      }\n      \n      // preserve location of indirect symbol index for further processing\n      isymbols.push_back((uint32_t *)[self imageAt:location + sizeof(uint32_t)*nindsym]);\n\n      // calculate stub or pointer length\n      uint32_t length = (section->reserved2 > 0 ? section->reserved2 : sizeof(uint32_t));\n        \n      // calculate indirect value location\n      uint32_t indirectAddress = section->addr + (nindsym - section->reserved1) * length;\n        \n      // accumulate search info\n      NSUInteger bookmark = node.details.rowCount;\n      NSString * symbolName = nil;\n      NSColor * color = nil;\n        \n      // read indirect symbol index\n      uint32_t indirectIndex = [dataController read_uint32:range lastReadHex:&lastReadHex];\n        \n      if ((indirectIndex & (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) == 0)\n      {\n        if (indirectIndex >= symbols.size())\n        {\n          [NSException raise:@\"Symbol\"\n                      format:@\"index is out of range %u\", indirectIndex];\n        }\n          \n        symbolName = NSSTRING(strtab + [self getSymbolByIndex:indirectIndex]->n_un.n_strx);\n          \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Symbol\"\n                               :symbolName];\n          \n        // fill in lookup table with indirect sybols\n        [symbolNames setObject:[NSString stringWithFormat:@\"[%@->%@]\",\n                                [self findSymbolAtRVA:indirectAddress],symbolName]\n                        forKey:[NSNumber numberWithUnsignedLong:indirectAddress]];\n      }\n      else\n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Symbol\"\n                               :@\"\"];\n          \n        switch (indirectIndex)\n        {\n          case INDIRECT_SYMBOL_LOCAL:\n          {\n            [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"INDIRECT_SYMBOL_LOCAL\"];\n            color = [NSColor magentaColor];\n            \n            // follow indirection for pointers only\n            NSRange range = NSMakeRange(indirectAddress - section->addr + section->offset + imageOffset, 0);\n            uint32_t targetAddress = [dataController read_uint32:range lastReadHex:&lastReadHex];\n            [node.details appendRow:@\"\":@\"\":@\"Target\":(symbolName = [self findSymbolAtRVA:targetAddress])];\n            symbolName = [NSString stringWithFormat:@\"[%@->%@]\",\n                          [self findSymbolAtRVA:indirectAddress],symbolName];\n          } break;\n\n          case INDIRECT_SYMBOL_ABS:\n          {\n            [node.details appendRow:@\"\":@\"\":@\"40000000\":@\"INDIRECT_SYMBOL_ABS\"];\n            color = [NSColor greenColor];\n            symbolName = [NSString stringWithFormat:@\"[0x%X->ABSOLUTE]\",indirectAddress];\n          } break;\n\n          default:\n          {\n            [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"INDIRECT_SYMBOL_LOCAL\"];\n            [node.details appendRow:@\"\":@\"\":@\"40000000\":@\"INDIRECT_SYMBOL_ABS\"];\n            color = [NSColor orangeColor];\n            symbolName = [NSString stringWithFormat:@\"[0x%X->LOCAL ABSOLUTE]\",indirectAddress];\n          }\n        }\n\n        // fill in lookup table with special indirect sybols\n        [symbolNames setObject:symbolName\n                        forKey:[NSNumber numberWithUnsignedLong:indirectAddress]];\n      }\n        \n      [node.details appendRow:@\"\":@\"\":@\"Section\"\n                             :[NSString stringWithFormat:@\"(%s,%s)\", \n                               string(section->segname,16).c_str(),\n                               string(section->sectname,16).c_str()]];\n        \n      [node.details appendRow:@\"\":@\"\":@\"Indirect Address\"\n                             :[NSString stringWithFormat:@\"0x%X ($+%u)\", indirectAddress, indirectAddress - section->addr]];\n      \n      [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,\n                                                        MVCellColorAttributeName,color,nil];\n      [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n      break; // we have found the section we was looking for\n\n    } // loop sections\n  } // loop indirect symbols\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createISymbols64Node:parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  for (uint32_t nindsym = 0; nindsym < length / sizeof(uint32_t); ++nindsym)\n  {\n    uint32_t nsect = (uint32_t)sections_64.size();\n    while (--nsect > 0)\n    {\n      struct section_64 const * section_64 = [self getSection64ByIndex:nsect];\n      \n      if (((section_64->flags & SECTION_TYPE) != S_SYMBOL_STUBS &&\n           (section_64->flags & SECTION_TYPE) != S_LAZY_SYMBOL_POINTERS &&\n           (section_64->flags & SECTION_TYPE) != S_LAZY_DYLIB_SYMBOL_POINTERS &&\n           (section_64->flags & SECTION_TYPE) != S_NON_LAZY_SYMBOL_POINTERS) ||\n          section_64->reserved1 > nindsym)\n      {\n        // section type or indirect symbol index mismatch\n        continue;\n      }\n      \n      // preserve location of indirect symbol index for further processing\n      isymbols.push_back((uint32_t *)[self imageAt:location + sizeof(uint32_t)*nindsym]);\n\n      // calculate stub or pointer length\n      uint32_t length = (section_64->reserved2 > 0 ? section_64->reserved2 : sizeof(uint64_t));\n\n      // calculate indirect value location\n      uint64_t indirectAddress = section_64->addr + (nindsym - section_64->reserved1) * length;\n        \n      // accumulate search info\n      NSUInteger bookmark = node.details.rowCount;\n      NSString * symbolName = nil;\n      NSColor * color = nil;\n      \n      // read indirect symbol index\n      uint32_t indirectIndex = [dataController read_uint32:range lastReadHex:&lastReadHex];\n      \n      if ((indirectIndex & (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) == 0)\n      {\n        if (indirectIndex >= symbols_64.size())\n        {\n          [NSException raise:@\"Symbol\"\n                      format:@\"index is out of range %u\", indirectIndex];\n        }\n        \n        symbolName = NSSTRING(strtab + [self getSymbol64ByIndex:indirectIndex]->n_un.n_strx);\n        \n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Symbol\"\n                               :symbolName];\n        \n        // fill in lookup table with indirect sybols\n        [symbolNames setObject:[NSString stringWithFormat:@\"[%@->%@]\",\n                                [self findSymbolAtRVA:indirectAddress],symbolName]\n                        forKey:[NSNumber numberWithUnsignedLongLong:indirectAddress]];\n      }\n      else\n      {\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Symbol\"\n                               :@\"\"];\n        \n        switch (indirectIndex)\n        {\n          case INDIRECT_SYMBOL_LOCAL:\n          {\n            [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"INDIRECT_SYMBOL_LOCAL\"];\n            color = [NSColor magentaColor];\n            \n            // follow indirection for pointers only\n            NSRange range = NSMakeRange(indirectAddress - section_64->addr + section_64->offset + imageOffset, 0);\n            uint64_t targetAddress = [dataController read_uint64:range lastReadHex:&lastReadHex];\n            [node.details appendRow:@\"\":@\"\":@\"Target\":(symbolName = [self findSymbolAtRVA:targetAddress])];\n            symbolName = [NSString stringWithFormat:@\"[%@->%@]\",\n                          [self findSymbolAtRVA:indirectAddress],symbolName];\n          } break;\n            \n          case INDIRECT_SYMBOL_ABS:\n          {\n            [node.details appendRow:@\"\":@\"\":@\"40000000\":@\"INDIRECT_SYMBOL_ABS\"];\n            color = [NSColor greenColor];\n            symbolName = [NSString stringWithFormat:@\"[0x%qX->ABSOLUTE]\",indirectAddress];\n          } break;\n            \n          default:\n          {\n            [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"INDIRECT_SYMBOL_LOCAL\"];\n            [node.details appendRow:@\"\":@\"\":@\"40000000\":@\"INDIRECT_SYMBOL_ABS\"];\n            color = [NSColor orangeColor];\n            symbolName = [NSString stringWithFormat:@\"[0x%qX->LOCAL ABSOLUTE]\",indirectAddress];\n          }\n        }\n        \n        // fill in lookup table with special indirect sybols\n        [symbolNames setObject:symbolName\n                        forKey:[NSNumber numberWithUnsignedLongLong:indirectAddress]];\n      }\n      \n      [node.details appendRow:@\"\":@\"\":@\"Section\"\n                             :[NSString stringWithFormat:@\"(%s,%s)\", \n                               string(section_64->segname,16).c_str(),\n                               string(section_64->sectname,16).c_str()]];\n      \n      [node.details appendRow:@\"\":@\"\":@\"Indirect Address\"\n                             :[NSString stringWithFormat:@\"0x%qX ($+%qu)\", indirectAddress, indirectAddress - section_64->addr]];\n      \n      [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,\n                                                        MVCellColorAttributeName,color,nil];\n      [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n      break;  // we have found the section we was looking for\n      \n    } // loop sections\n  } // loop indirect symbols\n\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createTOCNode:parent\n                   caption:(NSString *)caption\n                  location:(uint64_t)location\n                    length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(dylib_table_of_contents, NSMaxRange(range))\n    \n    if (dylib_table_of_contents->symbol_index >= symbols.size())\n    {\n      [NSException raise:@\"Symbol\"\n                  format:@\"index is out of range %u\", dylib_table_of_contents->symbol_index];\n    }\n\n    if (dylib_table_of_contents->module_index >= modules.size())\n    {\n      [NSException raise:@\"Module\"\n                  format:@\"index is out of range %u\", dylib_table_of_contents->module_index];\n    }\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = NSSTRING(strtab + [self getSymbolByIndex:dylib_table_of_contents->symbol_index]->n_un.n_strx); \n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Symbol\"\n                           :symbolName];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module\"\n                           :NSSTRING(strtab + modules.at(dylib_table_of_contents->module_index)->module_name)];    \n\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createTOC64Node:parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n                      length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(dylib_table_of_contents, NSMaxRange(range))\n    \n    if (dylib_table_of_contents->symbol_index >= symbols_64.size())\n    {\n      [NSException raise:@\"Symbol\"\n                  format:@\"index is out of range %u\", dylib_table_of_contents->symbol_index];\n    }\n    \n    if (dylib_table_of_contents->module_index >= modules_64.size())\n    {\n      [NSException raise:@\"Module\"\n                  format:@\"index is out of range %u\", dylib_table_of_contents->module_index];\n    }\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = NSSTRING(strtab + [self getSymbol64ByIndex:dylib_table_of_contents->symbol_index]->n_un.n_strx); \n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Symbol\"\n                           :symbolName];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module\"\n                           :NSSTRING(strtab + modules_64.at(dylib_table_of_contents->module_index)->module_name)];    \n\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createModulesNode:parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(dylib_module, NSMaxRange(range))\n    modules.push_back(dylib_module);\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * moduleName = NSSTRING(strtab + dylib_module->module_name); \n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module\"\n                           :moduleName];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Defined Symbols Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->iextdefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Defined Symbols Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->nextdefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext References Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->irefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext References Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->nrefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Local Symbols Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->ilocalsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Local Symbols Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->nlocalsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Relocs Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->iextrel]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Relocs Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->nextrel]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Init Pointers Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->iinit_iterm & 0xfff]];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Term Pointers Index\"\n                           :[NSString stringWithFormat:@\"%u\", (dylib_module->iinit_iterm >> 16) & 0xffff]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Init Pointers Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->ninit_nterm & 0xffff]];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Term Pointers Number\"\n                           :[NSString stringWithFormat:@\"%u\", (dylib_module->ninit_nterm >> 16) & 0xffff]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module Info Address\"\n                           :[NSString stringWithFormat:@\"0x%X\", dylib_module->objc_module_info_addr]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module Info Size\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module->objc_module_info_size]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,moduleName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createModules64Node:parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(dylib_module_64, NSMaxRange(range))\n    modules_64.push_back(dylib_module_64);\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * moduleName = NSSTRING(strtab + dylib_module_64->module_name); \n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module\"\n                           :moduleName];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Defined Symbols Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->iextdefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Defined Symbols Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->nextdefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext References Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->irefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext References Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->nrefsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Local Symbols Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->ilocalsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Local Symbols Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->nlocalsym]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Relocs Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->iextrel]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Ext Relocs Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->nextrel]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Init Pointers Index\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->iinit_iterm & 0xfff]];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Term Pointers Index\"\n                           :[NSString stringWithFormat:@\"%u\", (dylib_module_64->iinit_iterm >> 16) & 0xffff]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Init Pointers Number\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->ninit_nterm & 0xffff]];\n    \n    [node.details appendRow:@\"\":@\"\":@\"Term Pointers Number\"\n                           :[NSString stringWithFormat:@\"%u\", (dylib_module_64->ninit_nterm >> 16) & 0xffff]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module Info Address\"\n                           :[NSString stringWithFormat:@\"0x%llX\", dylib_module_64->objc_module_info_addr]];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Module Info Size\"\n                           :[NSString stringWithFormat:@\"%u\", dylib_module_64->objc_module_info_size]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,moduleName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createTwoLevelHintsNode:parent \n                             caption:(NSString *)caption\n                            location:(uint64_t)location\n                              length:(uint64_t)length\n                               index:(uint32_t)index\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(twolevel_hint, NSMaxRange(range))\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Subimage\"\n                           :[NSString stringWithFormat:@\"%u\", twolevel_hint->isub_image]];\n\n    uint32_t libOrdinal = GET_LIBRARY_ORDINAL([self is64bit] == NO \n                                               ? [self getSymbolByIndex:index]->n_desc\n                                               : [self getSymbol64ByIndex:index]->n_desc);\n    struct dylib const * dylib = [self getDylibByIndex:libOrdinal];\n\n    NSString * symbolName = [NSString stringWithFormat:@\"%s (from %@)\",\n                             strtab +([self is64bit] == NO \n                                        ? [self getSymbolByIndex:index]->n_un.n_strx\n                                        : [self getSymbol64ByIndex:index]->n_un.n_strx),\n                             (libOrdinal == SELF_LIBRARY_ORDINAL ? @\"SELF_LIBRARY_ORDINAL\" :\n                              libOrdinal == DYNAMIC_LOOKUP_ORDINAL ? @\"DYNAMIC_LOOKUP_ORDINAL\" :\n                              libOrdinal == EXECUTABLE_ORDINAL ? @\"EXECUTABLE_ORDINAL\" :\n                              [NSSTRING((uint8_t *)dylib + dylib->name.offset - sizeof(struct load_command)) lastPathComponent])];\n    ++index;\n    \n    [node.details appendRow:@\"\":@\"\":@\"TOC Index\"\n                           :[NSString stringWithFormat:@\"%u %@\", twolevel_hint->itoc, symbolName]];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,\n                                MVUnderlineAttributeName,@\"YES\",nil];\n  }\n    \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createSplitSegmentNode:parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length\n                        baseAddress:(uint64_t)baseAddress\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  NSString * symbolName = nil;\n\n  while (NSMaxRange(range) < location + length)\n  {    \n    uint8_t kind = [dataController read_uint8:range lastReadHex:&lastReadHex];\n    \n    if (kind == 0) // terminator\n    {\n      break;\n    }\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"kind\"\n                           :kind == 1 ? @\"32-bit pointer\" :\n                            kind == 2 ? @\"64-bit pointer\" :\n                            kind == 3 ? @\"ppc hi16\" :\n                            kind == 4 ? @\"32-bit offset to IMPORT\" :\n                            kind == 5 ? @\"thumb2 movw\" :\n                            kind == 6 ? @\"ARM movw\" :\n                            kind == 0x10 ? @\"thumb2 movt low high 4 bits=0\" :\n                            kind == 0x11 ? @\"thumb2 movt low high 4 bits=1\" :\n                            kind == 0x12 ? @\"thumb2 movt low high 4 bits=2\" :\n                            kind == 0x13 ? @\"thumb2 movt low high 4 bits=3\" :\n                            kind == 0x14 ? @\"thumb2 movt low high 4 bits=4\" :\n                            kind == 0x15 ? @\"thumb2 movt low high 4 bits=5\" :\n                            kind == 0x16 ? @\"thumb2 movt low high 4 bits=6\" :\n                            kind == 0x17 ? @\"thumb2 movt low high 4 bits=7\" :\n                            kind == 0x18 ? @\"thumb2 movt low high 4 bits=8\" :\n                            kind == 0x19 ? @\"thumb2 movt low high 4 bits=9\" :\n                            kind == 0x1A ? @\"thumb2 movt low high 4 bits=0xA\" :\n                            kind == 0x1B ? @\"thumb2 movt low high 4 bits=0xB\" :\n                            kind == 0x1C ? @\"thumb2 movt low high 4 bits=0xC\" :\n                            kind == 0x1D ? @\"thumb2 movt low high 4 bits=0xD\" :\n                            kind == 0x1E ? @\"thumb2 movt low high 4 bits=0xE\" :\n                            kind == 0x1f ? @\"thumb2 movt low high 4 bits=0xF\" : @\"???\"];\n    \n    [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n    \n    uint64_t address = baseAddress;\n    uint64_t offset = 0;\n    do\n    {\n      offset = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n      address += offset;\n      \n      [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                             :lastReadHex\n                             :@\"uleb128\"\n                             :[NSString stringWithFormat:@\"%@ %@\",\n                               [self findSectionContainsRVA:address],\n                               [self findSymbolAtRVA:address]]];\n      \n      [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil]; \n      \n    } while (offset != 0);\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createFunctionStartsNode:parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                               length:(uint64_t)length\n                          baseAddress:(uint64_t)baseAddress\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  uint64_t address = baseAddress;\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  NSString * symbolName = nil;\n  \n  while (NSMaxRange(range) < location + length)\n  {    \n    uint64_t offset = [dataController read_uleb128:range lastReadHex:&lastReadHex];\n    address += offset;\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"uleb128\"\n                           :[self findSymbolAtRVA:address]];\n\n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil]; \n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *) createDataInCodeEntriesNode:parent\n                                 caption:(NSString *)caption\n                                location:(uint64_t)location\n                                  length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(data_in_code_entry, NSMaxRange(range))\n    dices.push_back(data_in_code_entry);\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Offset\"\n                           :[self findSymbolAtRVA:[self fileOffsetToRVA:data_in_code_entry->offset + imageOffset]]];\n\n    [dataController read_uint16:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Length\"\n                           :[NSString stringWithFormat:@\"%u\", (uint32_t)data_in_code_entry->length]];\n\n    [dataController read_uint16:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Kind\"\n                           :data_in_code_entry->kind == DICE_KIND_DATA ? @\"DICE_KIND_DATA\" :\n                            data_in_code_entry->kind == DICE_KIND_JUMP_TABLE8 ? @\"DICE_KIND_JUMP_TABLE8\" :\n                            data_in_code_entry->kind == DICE_KIND_JUMP_TABLE16 ? @\"DICE_KIND_JUMP_TABLE16\" :\n                            data_in_code_entry->kind == DICE_KIND_JUMP_TABLE32 ? @\"DICE_KIND_JUMP_TABLE32\" :\n                            data_in_code_entry->kind == DICE_KIND_ABS_JUMP_TABLE32 ? @\"DICE_KIND_ABS_JUMP_TABLE32\" : @\"???\"];\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n@end\n"
        },
        {
          "name": "LoadCommands.h",
          "type": "blob",
          "size": 0.4521484375,
          "content": "/*\n *  LoadCommands.h\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#import \"MachOLayout.h\"\n\n\n@interface MachOLayout (LoadCommands)\n\n- (NSString *)getNameForCommand:(uint32_t)cmd;\n\n-(MVNode *)createLoadCommandNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n                         command:(uint32_t)command;\n\n@end\n"
        },
        {
          "name": "LoadCommands.mm",
          "type": "blob",
          "size": 126.2158203125,
          "content": "/*\n *  LoadCommands.mm\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#import \"Common.h\"\n#import \"LoadCommands.h\"\n#import \"ReadWrite.h\"\n#import \"DataController.h\"\n#import <mach-o/loader.h>\n#import <mach-o/nlist.h>\n#include \"thread_status.h\"\n#include \"thread_status_arm.h\"\n\nusing namespace std;\n\n//============================================================================\n@implementation MachOLayout (LoadCommands)\n\n//-----------------------------------------------------------------------------\n- (NSString *)getNameForCommand:(uint32_t)cmd\n{\n    switch(cmd)\n    {\n        default:                      return @\"???\";\n        case LC_SEGMENT:              return @\"LC_SEGMENT\";\n        case LC_SYMTAB:               return @\"LC_SYMTAB\";\n        case LC_SYMSEG:               return @\"LC_SYMSEG\";\n        case LC_THREAD:               return @\"LC_THREAD\";\n        case LC_UNIXTHREAD:           return @\"LC_UNIXTHREAD\";\n        case LC_LOADFVMLIB:           return @\"LC_LOADFVMLIB\";\n        case LC_IDFVMLIB:             return @\"LC_IDFVMLIB\";\n        case LC_IDENT:                return @\"LC_IDENT\";\n        case LC_FVMFILE:              return @\"LC_FVMFILE\";\n        case LC_PREPAGE:              return @\"LC_PREPAGE\";\n        case LC_DYSYMTAB:             return @\"LC_DYSYMTAB\";\n        case LC_LOAD_DYLIB:           return @\"LC_LOAD_DYLIB\";\n        case LC_ID_DYLIB:             return @\"LC_ID_DYLIB\";\n        case LC_LOAD_DYLINKER:        return @\"LC_LOAD_DYLINKER\";\n        case LC_ID_DYLINKER:          return @\"LC_ID_DYLINKER\";\n        case LC_PREBOUND_DYLIB:       return @\"LC_PREBOUND_DYLIB\";\n        case LC_ROUTINES:             return @\"LC_ROUTINES\";\n        case LC_SUB_FRAMEWORK:        return @\"LC_SUB_FRAMEWORK\";\n        case LC_SUB_UMBRELLA:         return @\"LC_SUB_UMBRELLA\";\n        case LC_SUB_CLIENT:           return @\"LC_SUB_CLIENT\";\n        case LC_SUB_LIBRARY:          return @\"LC_SUB_LIBRARY\";\n        case LC_TWOLEVEL_HINTS:       return @\"LC_TWOLEVEL_HINTS\";\n        case LC_PREBIND_CKSUM:        return @\"LC_PREBIND_CKSUM\";\n        case LC_LOAD_WEAK_DYLIB:      return @\"LC_LOAD_WEAK_DYLIB\";\n        case LC_SEGMENT_64:           return @\"LC_SEGMENT_64\";\n        case LC_ROUTINES_64:          return @\"LC_ROUTINES_64\";\n        case LC_UUID:                 return @\"LC_UUID\";\n        case LC_RPATH:                return @\"LC_RPATH\";\n        case LC_CODE_SIGNATURE:       return @\"LC_CODE_SIGNATURE\";\n        case LC_SEGMENT_SPLIT_INFO:   return @\"LC_SEGMENT_SPLIT_INFO\";\n        case LC_REEXPORT_DYLIB:       return @\"LC_REEXPORT_DYLIB\";\n        case LC_LAZY_LOAD_DYLIB:      return @\"LC_LAZY_LOAD_DYLIB\";\n        case LC_ENCRYPTION_INFO:      return @\"LC_ENCRYPTION_INFO\";\n        case LC_DYLD_INFO:            return @\"LC_DYLD_INFO\";\n        case LC_DYLD_INFO_ONLY:       return @\"LC_DYLD_INFO_ONLY\";\n        case LC_LOAD_UPWARD_DYLIB:    return @\"LC_LOAD_UPWARD_DYLIB\";\n        case LC_VERSION_MIN_MACOSX:   return @\"LC_VERSION_MIN_MACOSX\";\n        case LC_VERSION_MIN_IPHONEOS: return @\"LC_VERSION_MIN_IPHONEOS\";\n        case LC_FUNCTION_STARTS:      return @\"LC_FUNCTION_STARTS\";\n        case LC_DYLD_ENVIRONMENT:     return @\"LC_DYLD_ENVIRONMENT\";\n        case LC_MAIN:                 return @\"LC_MAIN\";\n        case LC_DATA_IN_CODE:         return @\"LC_DATA_IN_CODE\";\n        case LC_SOURCE_VERSION:       return @\"LC_SOURCE_VERSION\";\n        case LC_DYLIB_CODE_SIGN_DRS:  return @\"LC_DYLIB_CODE_SIGN_DRS\";\n        case LC_ENCRYPTION_INFO_64:   return @\"LC_ENCRYPTION_INFO_64\";\n        case LC_LINKER_OPTION:        return @\"LC_LINKER_OPTION\";\n        case LC_LINKER_OPTIMIZATION_HINT: return @\"LC_LINKER_OPTIMIZATION_HINT\";\n        case LC_VERSION_MIN_TVOS:     return @\"LC_VERSION_MIN_TVOS\";\n        case LC_VERSION_MIN_WATCHOS:  return @\"LC_VERSION_MIN_WATCHOS\";\n        case LC_NOTE:                 return @\"LC_NOTE\";\n        case LC_BUILD_VERSION:        return @\"LC_BUILD_VERSION\";\n        case LC_DYLD_EXPORTS_TRIE:    return @\"LC_DYLD_EXPORTS_TRIE\";\n        case LC_DYLD_CHAINED_FIXUPS:  return @\"LC_DYLD_CHAINED_FIXUPS\";\n        case LC_FILESET_ENTRY:        return @\"LC_FILESET_ENTRY\";\n    }\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSegmentNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n              segment_command:(struct segment_command const *)segment_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:segment_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:segment_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", segment_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_string:range fixlen:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Segment Name\"\n                         :[NSString stringWithFormat:@\"%s\", string(segment_command->segname,16).c_str()]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"VM Address\"\n                         :[NSString stringWithFormat:@\"0x%X\", segment_command->vmaddr]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"VM Size\"\n                         :[NSString stringWithFormat:@\"%u\", segment_command->vmsize]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"File Offset\"\n                         :[NSString stringWithFormat:@\"%u\", segment_command->fileoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"File Size\"\n                         :[NSString stringWithFormat:@\"%u\", segment_command->filesize]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Maximum VM Protection\"\n                         :@\"\"];\n  \n  if (segment_command->maxprot == VM_PROT_NONE)    [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"VM_PROT_NONE\"];\n  if (segment_command->maxprot & VM_PROT_READ)     [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"VM_PROT_READ\"];\n  if (segment_command->maxprot & VM_PROT_WRITE)    [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"VM_PROT_WRITE\"];\n  if (segment_command->maxprot & VM_PROT_EXECUTE)  [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"VM_PROT_EXECUTE\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Initial VM Protection\"\n                         :@\"\"];\n  \n  if (segment_command->initprot == VM_PROT_NONE)   [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"VM_PROT_NONE\"];\n  if (segment_command->initprot & VM_PROT_READ)    [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"VM_PROT_READ\"];\n  if (segment_command->initprot & VM_PROT_WRITE)   [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"VM_PROT_WRITE\"];\n  if (segment_command->initprot & VM_PROT_EXECUTE) [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"VM_PROT_EXECUTE\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Sections\"\n                         :[NSString stringWithFormat:@\"%u\", segment_command->nsects]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n    if (segment_command->flags & SG_HIGHVM) {\n        [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"SG_HIGHVM\"];\n    }\n    if (segment_command->flags & SG_FVMLIB) {\n        [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"SG_FVMLIB\"];\n    }\n    if (segment_command->flags & SG_NORELOC) {\n        [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"SG_NORELOC\"];\n    }\n    if (segment_command->flags & SG_PROTECTED_VERSION_1) {\n        [node.details appendRow:@\"\":@\"\":@\"00000008\":@\"SG_PROTECTED_VERSION_1\"];\n    }\n    if (segment_command->flags & SG_READ_ONLY) {\n        [node.details appendRow:@\"\" :@\"\" :@\"00000010\" :@\"SG_READ_ONLY\"];\n    }\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createSectionNode:(MVNode *)parent\n                    caption:(NSString *)caption\n                   location:(uint64_t)location\n                    section:(struct section const *)section\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sizeof(struct section) saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_string:range fixlen:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Section Name\"\n                         :[NSString stringWithFormat:@\"%s\", string(section->sectname,16).c_str()]];\n  \n  [dataController read_string:range fixlen:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Segment Name\"\n                         :[NSString stringWithFormat:@\"%s\", string(section->segname,16).c_str()]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Address\"\n                         :[NSString stringWithFormat:@\"0x%X\", section->addr]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Size\"\n                         :[NSString stringWithFormat:@\"%u\", section->size]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Offset\"\n                         :[NSString stringWithFormat:@\"%u\", section->offset]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Alignment\"\n                         :[NSString stringWithFormat:@\"%u\", (1 << section->align)]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Relocations Offset\"\n                         :[NSString stringWithFormat:@\"%u\", section->reloff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Relocations\"\n                         :[NSString stringWithFormat:@\"%u\", section->nreloc]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n    switch (section->flags & SECTION_TYPE)\n    {\n        case S_REGULAR:                             [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"S_REGULAR\"]; break;\n        case S_ZEROFILL:                            [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"S_ZEROFILL\"]; break;\n        case S_CSTRING_LITERALS:                    [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"S_CSTRING_LITERALS\"]; break;\n        case S_4BYTE_LITERALS:                      [node.details appendRow:@\"\":@\"\":@\"00000003\":@\"S_4BYTE_LITERALS\"]; break;\n        case S_8BYTE_LITERALS:                      [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"S_8BYTE_LITERALS\"]; break;\n        case S_LITERAL_POINTERS:                    [node.details appendRow:@\"\":@\"\":@\"00000005\":@\"S_LITERAL_POINTERS\"]; break;\n        case S_NON_LAZY_SYMBOL_POINTERS:            [node.details appendRow:@\"\":@\"\":@\"00000006\":@\"S_NON_LAZY_SYMBOL_POINTERS\"]; break;\n        case S_LAZY_SYMBOL_POINTERS:                [node.details appendRow:@\"\":@\"\":@\"00000007\":@\"S_LAZY_SYMBOL_POINTERS\"]; break;\n        case S_SYMBOL_STUBS:                        [node.details appendRow:@\"\":@\"\":@\"00000008\":@\"S_SYMBOL_STUBS\"]; break;\n        case S_MOD_INIT_FUNC_POINTERS:              [node.details appendRow:@\"\":@\"\":@\"00000009\":@\"S_MOD_INIT_FUNC_POINTERS\"]; break;\n        case S_MOD_TERM_FUNC_POINTERS:              [node.details appendRow:@\"\":@\"\":@\"0000000A\":@\"S_MOD_TERM_FUNC_POINTERS\"]; break;\n        case S_COALESCED:                           [node.details appendRow:@\"\":@\"\":@\"0000000B\":@\"S_COALESCED\"]; break;\n        case S_GB_ZEROFILL:                         [node.details appendRow:@\"\":@\"\":@\"0000000C\":@\"S_GB_ZEROFILL\"]; break;\n        case S_INTERPOSING:                         [node.details appendRow:@\"\":@\"\":@\"0000000D\":@\"S_INTERPOSING\"]; break;\n        case S_16BYTE_LITERALS:                     [node.details appendRow:@\"\":@\"\":@\"0000000E\":@\"S_16BYTE_LITERALS\"]; break;\n        case S_DTRACE_DOF:                          [node.details appendRow:@\"\":@\"\":@\"0000000F\":@\"S_DTRACE_DOF\"]; break;\n        case S_LAZY_DYLIB_SYMBOL_POINTERS:          [node.details appendRow:@\"\":@\"\":@\"00000010\":@\"S_LAZY_DYLIB_SYMBOL_POINTERS\"]; break;\n        case S_THREAD_LOCAL_REGULAR:                [node.details appendRow:@\"\":@\"\":@\"00000011\":@\"S_THREAD_LOCAL_REGULAR\"]; break;\n        case S_THREAD_LOCAL_ZEROFILL:               [node.details appendRow:@\"\":@\"\":@\"00000012\":@\"S_THREAD_LOCAL_ZEROFILL\"]; break;\n        case S_THREAD_LOCAL_VARIABLES:              [node.details appendRow:@\"\":@\"\":@\"00000013\":@\"S_THREAD_LOCAL_VARIABLES\"]; break;\n        case S_THREAD_LOCAL_VARIABLE_POINTERS:      [node.details appendRow:@\"\":@\"\":@\"00000014\":@\"S_THREAD_LOCAL_VARIABLE_POINTERS\"]; break;\n        case S_THREAD_LOCAL_INIT_FUNCTION_POINTERS: [node.details appendRow:@\"\":@\"\":@\"00000015\":@\"S_THREAD_LOCAL_INIT_FUNCTION_POINTERS\"]; break;\n        case S_INIT_FUNC_OFFSETS:                   [node.details appendRow:@\"\":@\"\":@\"00000016\":@\"S_INIT_FUNC_OFFSETS\"]; break;\n    }\n  \n  if (section->flags & S_ATTR_PURE_INSTRUCTIONS)   [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"S_ATTR_PURE_INSTRUCTIONS\"];\n  if (section->flags & S_ATTR_NO_TOC)              [node.details appendRow:@\"\":@\"\":@\"40000000\":@\"S_ATTR_NO_TOC\"];\n  if (section->flags & S_ATTR_STRIP_STATIC_SYMS)   [node.details appendRow:@\"\":@\"\":@\"20000000\":@\"S_ATTR_STRIP_STATIC_SYMS\"];\n  if (section->flags & S_ATTR_NO_DEAD_STRIP)       [node.details appendRow:@\"\":@\"\":@\"10000000\":@\"S_ATTR_NO_DEAD_STRIP\"];\n  if (section->flags & S_ATTR_LIVE_SUPPORT)        [node.details appendRow:@\"\":@\"\":@\"08000000\":@\"S_ATTR_LIVE_SUPPORT\"];\n  if (section->flags & S_ATTR_SELF_MODIFYING_CODE) [node.details appendRow:@\"\":@\"\":@\"04000000\":@\"S_ATTR_SELF_MODIFYING_CODE\"];\n  if (section->flags & S_ATTR_DEBUG)               [node.details appendRow:@\"\":@\"\":@\"02000000\":@\"S_ATTR_DEBUG\"];\n  if (section->flags & S_ATTR_SOME_INSTRUCTIONS)   [node.details appendRow:@\"\":@\"\":@\"00000400\":@\"S_ATTR_SOME_INSTRUCTIONS\"];\n  if (section->flags & S_ATTR_EXT_RELOC)           [node.details appendRow:@\"\":@\"\":@\"00000200\":@\"S_ATTR_EXT_RELOC\"];\n  if (section->flags & S_ATTR_LOC_RELOC)           [node.details appendRow:@\"\":@\"\":@\"00000100\":@\"S_ATTR_LOC_RELOC\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :(section->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||\n                          (section->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||\n                          (section->flags & SECTION_TYPE) == S_LAZY_DYLIB_SYMBOL_POINTERS ||\n                          (section->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ? @\"Indirect Sym Index\" : @\"Reserved1\"\n                         :[NSString stringWithFormat:@\"%u\", section->reserved1]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :(section->flags & SECTION_TYPE) == S_SYMBOL_STUBS ? @\"Size of Stubs\" : @\"Reserved2\"\n                         :[NSString stringWithFormat:@\"%u\", section->reserved2]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSegment64Node:(MVNode *)parent\n                        caption:(NSString *)caption\n                       location:(uint64_t)location\n             segment_command_64:(struct segment_command_64 const *)segment_command_64\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:segment_command_64->cmdsize saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:segment_command_64->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", segment_command_64->cmdsize]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_string:range fixlen:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Segment Name\"\n                         :[NSString stringWithFormat:@\"%s\", string(segment_command_64->segname,16).c_str()]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"VM Address\"\n                         :[NSString stringWithFormat:@\"%qu\", segment_command_64->vmaddr]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"VM Size\"\n                         :[NSString stringWithFormat:@\"%qu\", segment_command_64->vmsize]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"File Offset\"\n                         :[NSString stringWithFormat:@\"%qu\", segment_command_64->fileoff]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"File Size\"\n                         :[NSString stringWithFormat:@\"%qu\", segment_command_64->filesize]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Maximum VM Protection\"\n                         :@\"\"];\n  \n  if (segment_command_64->maxprot == VM_PROT_NONE)   [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"VM_PROT_NONE\"];\n  if (segment_command_64->maxprot & VM_PROT_READ)    [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"VM_PROT_READ\"];\n  if (segment_command_64->maxprot & VM_PROT_WRITE)   [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"VM_PROT_WRITE\"];\n  if (segment_command_64->maxprot & VM_PROT_EXECUTE) [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"VM_PROT_EXECUTE\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Initial VM Protection\"\n                         :@\"\"];\n  \n  if (segment_command_64->initprot == VM_PROT_NONE)  [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"VM_PROT_NONE\"];\n  if (segment_command_64->initprot & VM_PROT_READ)   [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"VM_PROT_READ\"];\n  if (segment_command_64->initprot & VM_PROT_WRITE)  [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"VM_PROT_WRITE\"];\n  if (segment_command_64->initprot & VM_PROT_EXECUTE)[node.details appendRow:@\"\":@\"\":@\"00000004\":@\"VM_PROT_EXECUTE\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Sections\"\n                         :[NSString stringWithFormat:@\"%u\", segment_command_64->nsects]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n    if (segment_command_64->flags & SG_HIGHVM) {\n        [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"SG_HIGHVM\"];\n    }\n    if (segment_command_64->flags & SG_FVMLIB) {\n        [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"SG_FVMLIB\"];\n    }\n    if (segment_command_64->flags & SG_NORELOC) {\n        [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"SG_NORELOC\"];\n    }\n    if (segment_command_64->flags & SG_PROTECTED_VERSION_1) {\n        [node.details appendRow:@\"\":@\"\":@\"00000008\":@\"SG_PROTECTED_VERSION_1\"];\n    }\n    if (segment_command_64->flags & SG_READ_ONLY) {\n        [node.details appendRow:@\"\" :@\"\" :@\"00000010\" :@\"SG_READ_ONLY\"];\n    }\n\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createSection64Node:(MVNode *)parent\n                    caption:(NSString *)caption\n                   location:(uint64_t)location\n                 section_64:(struct section_64 const *)section_64\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sizeof(struct section_64) saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_string:range fixlen:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Section Name\"\n                         :[NSString stringWithFormat:@\"%s\", string(section_64->sectname,16).c_str()]];\n  \n  [dataController read_string:range fixlen:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Segment Name\"\n                         :[NSString stringWithFormat:@\"%s\", string(section_64->segname,16).c_str()]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Address\"\n                         :[NSString stringWithFormat:@\"%qu\", section_64->addr]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Size\"\n                         :[NSString stringWithFormat:@\"%qu\", section_64->size]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Offset\"\n                         :[NSString stringWithFormat:@\"%u\", section_64->offset]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Alignment\"\n                         :[NSString stringWithFormat:@\"%u\", (1 << section_64->align)]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Relocations Offset\"\n                         :[NSString stringWithFormat:@\"%u\", section_64->reloff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Relocations\"\n                         :[NSString stringWithFormat:@\"%u\", section_64->nreloc]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n    switch (section_64->flags & SECTION_TYPE)\n    {\n        case S_REGULAR:                             [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"S_REGULAR\"]; break;\n        case S_ZEROFILL:                            [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"S_ZEROFILL\"]; break;\n        case S_CSTRING_LITERALS:                    [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"S_CSTRING_LITERALS\"]; break;\n        case S_4BYTE_LITERALS:                      [node.details appendRow:@\"\":@\"\":@\"00000003\":@\"S_4BYTE_LITERALS\"]; break;\n        case S_8BYTE_LITERALS:                      [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"S_8BYTE_LITERALS\"]; break;\n        case S_LITERAL_POINTERS:                    [node.details appendRow:@\"\":@\"\":@\"00000005\":@\"S_LITERAL_POINTERS\"]; break;\n        case S_NON_LAZY_SYMBOL_POINTERS:            [node.details appendRow:@\"\":@\"\":@\"00000006\":@\"S_NON_LAZY_SYMBOL_POINTERS\"]; break;\n        case S_LAZY_SYMBOL_POINTERS:                [node.details appendRow:@\"\":@\"\":@\"00000007\":@\"S_LAZY_SYMBOL_POINTERS\"]; break;\n        case S_SYMBOL_STUBS:                        [node.details appendRow:@\"\":@\"\":@\"00000008\":@\"S_SYMBOL_STUBS\"]; break;\n        case S_MOD_INIT_FUNC_POINTERS:              [node.details appendRow:@\"\":@\"\":@\"00000009\":@\"S_MOD_INIT_FUNC_POINTERS\"]; break;\n        case S_MOD_TERM_FUNC_POINTERS:              [node.details appendRow:@\"\":@\"\":@\"0000000A\":@\"S_MOD_TERM_FUNC_POINTERS\"]; break;\n        case S_COALESCED:                           [node.details appendRow:@\"\":@\"\":@\"0000000B\":@\"S_COALESCED\"]; break;\n        case S_GB_ZEROFILL:                         [node.details appendRow:@\"\":@\"\":@\"0000000C\":@\"S_GB_ZEROFILL\"]; break;\n        case S_INTERPOSING:                         [node.details appendRow:@\"\":@\"\":@\"0000000D\":@\"S_INTERPOSING\"]; break;\n        case S_16BYTE_LITERALS:                     [node.details appendRow:@\"\":@\"\":@\"0000000E\":@\"S_16BYTE_LITERALS\"]; break;\n        case S_DTRACE_DOF:                          [node.details appendRow:@\"\":@\"\":@\"0000000F\":@\"S_DTRACE_DOF\"]; break;\n        case S_LAZY_DYLIB_SYMBOL_POINTERS:          [node.details appendRow:@\"\":@\"\":@\"00000010\":@\"S_LAZY_DYLIB_SYMBOL_POINTERS\"]; break;\n        case S_THREAD_LOCAL_REGULAR:                [node.details appendRow:@\"\":@\"\":@\"00000011\":@\"S_THREAD_LOCAL_REGULAR\"]; break;\n        case S_THREAD_LOCAL_ZEROFILL:               [node.details appendRow:@\"\":@\"\":@\"00000012\":@\"S_THREAD_LOCAL_ZEROFILL\"]; break;\n        case S_THREAD_LOCAL_VARIABLES:              [node.details appendRow:@\"\":@\"\":@\"00000013\":@\"S_THREAD_LOCAL_VARIABLES\"]; break;\n        case S_THREAD_LOCAL_VARIABLE_POINTERS:      [node.details appendRow:@\"\":@\"\":@\"00000014\":@\"S_THREAD_LOCAL_VARIABLE_POINTERS\"]; break;\n        case S_THREAD_LOCAL_INIT_FUNCTION_POINTERS: [node.details appendRow:@\"\":@\"\":@\"00000015\":@\"S_THREAD_LOCAL_INIT_FUNCTION_POINTERS\"]; break;\n        case S_INIT_FUNC_OFFSETS:                   [node.details appendRow:@\"\":@\"\":@\"00000016\":@\"S_INIT_FUNC_OFFSETS\"]; break;\n    }\n  \n  if (section_64->flags & S_ATTR_PURE_INSTRUCTIONS)   [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"S_ATTR_PURE_INSTRUCTIONS\"];\n  if (section_64->flags & S_ATTR_NO_TOC)              [node.details appendRow:@\"\":@\"\":@\"40000000\":@\"S_ATTR_NO_TOC\"];\n  if (section_64->flags & S_ATTR_STRIP_STATIC_SYMS)   [node.details appendRow:@\"\":@\"\":@\"20000000\":@\"S_ATTR_STRIP_STATIC_SYMS\"];\n  if (section_64->flags & S_ATTR_NO_DEAD_STRIP)       [node.details appendRow:@\"\":@\"\":@\"10000000\":@\"S_ATTR_NO_DEAD_STRIP\"];\n  if (section_64->flags & S_ATTR_LIVE_SUPPORT)        [node.details appendRow:@\"\":@\"\":@\"08000000\":@\"S_ATTR_LIVE_SUPPORT\"];\n  if (section_64->flags & S_ATTR_SELF_MODIFYING_CODE) [node.details appendRow:@\"\":@\"\":@\"04000000\":@\"S_ATTR_SELF_MODIFYING_CODE\"];\n  if (section_64->flags & S_ATTR_DEBUG)               [node.details appendRow:@\"\":@\"\":@\"02000000\":@\"S_ATTR_DEBUG\"];\n  if (section_64->flags & S_ATTR_SOME_INSTRUCTIONS)   [node.details appendRow:@\"\":@\"\":@\"00000400\":@\"S_ATTR_SOME_INSTRUCTIONS\"];\n  if (section_64->flags & S_ATTR_EXT_RELOC)           [node.details appendRow:@\"\":@\"\":@\"00000200\":@\"S_ATTR_EXT_RELOC\"];\n  if (section_64->flags & S_ATTR_LOC_RELOC)           [node.details appendRow:@\"\":@\"\":@\"00000100\":@\"S_ATTR_LOC_RELOC\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :(section_64->flags & SECTION_TYPE) == S_SYMBOL_STUBS ||\n                          (section_64->flags & SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS ||\n                          (section_64->flags & SECTION_TYPE) == S_LAZY_DYLIB_SYMBOL_POINTERS ||\n                          (section_64->flags & SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS ? @\"Indirect Sym Index\" : @\"Reserved1\"\n                         :[NSString stringWithFormat:@\"%u\", section_64->reserved1]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :(section_64->flags & SECTION_TYPE) == S_SYMBOL_STUBS ? @\"Size of Stubs\" : @\"Reserved2\"\n                         :[NSString stringWithFormat:@\"%u\", section_64->reserved2]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved3\"\n                         :[NSString stringWithFormat:@\"%u\", section_64->reserved3]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSymtabNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n              symtab_command:(struct symtab_command const *)symtab_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:symtab_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:symtab_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", symtab_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Symbol Table Offset\"\n                         :[NSString stringWithFormat:@\"%u\", symtab_command->symoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Symbols\"\n                         :[NSString stringWithFormat:@\"%u\", symtab_command->nsyms]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"String Table Offset\"\n                         :[NSString stringWithFormat:@\"%u\", symtab_command->stroff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"String Table Size\"\n                         :[NSString stringWithFormat:@\"%u\", symtab_command->strsize]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCDysymtabNode:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n              dysymtab_command:(struct dysymtab_command const *)dysymtab_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:dysymtab_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:dysymtab_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"LocSymbol Index\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->ilocalsym]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"LocSymbol Number\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nlocalsym]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Defined ExtSymbol Index\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->iextdefsym]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Defined ExtSymbol Number\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nextdefsym]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Undef ExtSymbol Index\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->iundefsym]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Undef ExtSymbol Number\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nundefsym]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"TOC Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->tocoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"TOC Entries\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->ntoc]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Module Table Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->modtaboff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Module Table Entries\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nmodtab]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ExtRef Table Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->extrefsymoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ExtRef Table Entries\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nextrefsyms]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"IndSym Table Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->indirectsymoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"IndSym Table Entries\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nindirectsyms]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ExtReloc Table Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->extreloff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ExtReloc Table Entries\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nextrel]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"LocReloc Table Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->locreloff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"LocReloc Table Entries\"\n                         :[NSString stringWithFormat:@\"%u\", dysymtab_command->nlocrel]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCTwolevelHintsNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n             twolevel_hints_command:(struct twolevel_hints_command const *)twolevel_hints_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:twolevel_hints_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:twolevel_hints_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", twolevel_hints_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Offset\"\n                         :[NSString stringWithFormat:@\"%u\", twolevel_hints_command->offset]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Hints\"\n                         :[NSString stringWithFormat:@\"%u\", twolevel_hints_command->nhints]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCDylinkerNode:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n              dylinker_command:(struct dylinker_command const *)dylinker_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:dylinker_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:dylinker_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", dylinker_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Str Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dylinker_command->name.offset]];\n  \n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  \n  range = NSMakeRange(location + dylinker_command->name.offset,0);\n  NSString * name = [dataController read_string:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :name];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCPrebindChksumNode:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                prebind_cksum_command:(struct prebind_cksum_command const *)prebind_cksum_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:prebind_cksum_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:prebind_cksum_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", prebind_cksum_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Checksum\"\n                         :[NSString stringWithFormat:@\"0x%.8X\",prebind_cksum_command->cksum]];\n  return node;\n}\n\n  \n//-----------------------------------------------------------------------------\n- (MVNode *)createLCUUIDNode:(MVNode *)parent\n                   caption:(NSString *)caption\n                  location:(uint64_t)location\n              uuid_command:(struct uuid_command const *)uuid_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:uuid_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:uuid_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", uuid_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_bytes:range length:16 lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"UUID\"\n                         :[NSString stringWithFormat:@\"%@-%@-%@-%@-%@\",\n                          [lastReadHex substringWithRange:NSMakeRange(0,8)],\n                          [lastReadHex substringWithRange:NSMakeRange(8,4)],\n                          [lastReadHex substringWithRange:NSMakeRange(12,4)],\n                          [lastReadHex substringWithRange:NSMakeRange(16,4)],\n                          [lastReadHex substringWithRange:NSMakeRange(20,12)] ]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCThreadNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n              thread_command:(struct thread_command const *)thread_command\n{\n    MVNodeSaver nodeSaver;\n    MVNode * node = [parent insertChildWithDetails:caption location:location length:thread_command->cmdsize saver:nodeSaver];\n\n    NSRange range = NSMakeRange(location,0);\n    NSString * lastReadHex;\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Command\"\n                           :[self getNameForCommand:thread_command->cmd]];\n  \n    [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Command Size\"\n                           :[NSString stringWithFormat:@\"%u\", thread_command->cmdsize]];\n  \n    [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                                MVUnderlineAttributeName,@\"YES\",nil];\n  \n    MATCH_STRUCT(mach_header,imageOffset);\n    if (mach_header->cputype == CPU_TYPE_I386 || mach_header->cputype == CPU_TYPE_X86_64)\n    {\n        MATCH_STRUCT(_x86_thread_state,NSMaxRange(range))\n    \n        NSString *flavor;\n        switch (_x86_thread_state->tsh.flavor) {\n            case _x86_THREAD_STATE32:\n                flavor = @\"x86_THREAD_STATE32\"; break;\n            case _x86_FLOAT_STATE32:\n                flavor = @\"x86_FLOAT_STATE32\"; break;\n            case _x86_EXCEPTION_STATE32:\n                flavor = @\"x86_EXCEPTION_STATE32\"; break;\n            case _x86_THREAD_STATE64:\n                flavor = @\"x86_THREAD_STATE64\"; break;\n            case _x86_FLOAT_STATE64:\n                flavor = @\"x86_FLOAT_STATE64\"; break;\n            case _x86_EXCEPTION_STATE64:\n                flavor = @\"x86_EXCEPTION_STATE64\"; break;\n            case _x86_THREAD_STATE:\n                flavor = @\"x86_THREAD_STATE\"; break;\n            case _x86_FLOAT_STATE:\n                flavor = @\"x86_FLOAT_STATE\"; break;\n            case _x86_EXCEPTION_STATE:\n                flavor = @\"x86_EXCEPTION_STATE\"; break;\n            case _x86_DEBUG_STATE32:\n                flavor = @\"x86_DEBUG_STATE32\"; break;\n            case _x86_DEBUG_STATE64:\n                flavor = @\"x86_DEBUG_STATE64\"; break;\n            case _x86_DEBUG_STATE:\n                flavor = @\"x86_DEBUG_STATE\"; break;\n            case _x86_THREAD_STATE_NONE:\n                flavor = @\"THREAD_STATE_NONE\"; break;\n            default:\n                flavor = @\"???\"; break;\n        }\n        [dataController read_uint32:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Flavor\"\n                               :flavor];\n    \n        [dataController read_uint32:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Count\"\n                               :[NSString stringWithFormat:@\"%u\", _x86_thread_state->tsh.count]];\n    \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n        if (_x86_thread_state->tsh.flavor == _x86_THREAD_STATE32) {\n            entryPoint = _x86_thread_state->uts.ts32.eip;\n\n            NSDictionary * stateDict = [NSDictionary dictionaryWithObjectsAndKeys:\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.eax],   @\"eax\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.ebx],   @\"ebx\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.ecx],   @\"ecx\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.edx],   @\"edx\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.edi],   @\"edi\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.esi],   @\"esi\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.ebp],   @\"ebp\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.esp],   @\"esp\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.ss],    @\"ss\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.eflags],@\"eflags\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.eip],   @\"eip\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.cs],    @\"cs\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.ds],    @\"ds\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.es],    @\"es\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.fs],    @\"fs\",\n                                        [NSString stringWithFormat:@\"%u\",_x86_thread_state->uts.ts32.gs],    @\"gs\",\n                                        nil];\n      \n            for (id key in [NSArray arrayWithObjects:\n                            @\"eax\",@\"ebx\",@\"ecx\",@\"edx\",\n                            @\"edi\",@\"esi\",@\"ebp\",@\"esp\",\n                            @\"ss\",@\"eflags\",@\"eip\",@\"cs\",\n                            @\"ds\",@\"es\",@\"fs\",@\"gs\",nil])\n            {\n                [dataController read_uint32:range lastReadHex:&lastReadHex];\n                [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                       :lastReadHex\n                                       :key\n                                       :[stateDict objectForKey:key]];\n            }\n        }\n        else if (_x86_thread_state->tsh.flavor == _x86_THREAD_STATE64) {\n            entryPoint = _x86_thread_state->uts.ts64.rip;\n            NSDictionary * stateDict = [NSDictionary dictionaryWithObjectsAndKeys:\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rax], @\"rax\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rbx], @\"rbx\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rcx], @\"rcx\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rdx], @\"rdx\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rdi], @\"rdi\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rsi], @\"rsi\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rbp], @\"rbp\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rsp], @\"rsp\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r8], @\"r8\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r9], @\"r9\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r10], @\"r10\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r11], @\"r11\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r12], @\"r12\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r13], @\"r13\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r14], @\"r14\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.r15], @\"r15\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rip], @\"rip\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.rflags], @\"rflags\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.cs], @\"cs\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.fs], @\"fs\",\n                                        [NSString stringWithFormat:@\"%qu\",_x86_thread_state->uts.ts64.gs], @\"gs\", nil];\n      \n            for (id key in [NSArray arrayWithObjects:\n                            @\"rax\",@\"rbx\",@\"rcx\",@\"rdx\",@\"rdi\",@\"rsi\",@\"rbp\",@\"rsp\",\n                            @\"r8\",@\"r9\", @\"r10\", @\"r11\", @\"r12\", @\"r13\", @\"r14\", @\"r15\",\n                            @\"rip\",@\"rflags\",@\"cs\",@\"fs\", @\"gs\", nil])\n            {\n                [dataController read_uint64:range lastReadHex:&lastReadHex];\n                [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                       :lastReadHex\n                                       :key\n                                       :[stateDict objectForKey:key]];\n            }\n        }\n    } // i386/x64\n    // these can be built targeting armv7\n    else if (mach_header->cputype == CPU_TYPE_ARM) {\n        MATCH_STRUCT(_arm_unified_thread_state,NSMaxRange(range))\n        \n        [dataController read_uint32:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Flavor\"\n                               :_arm_unified_thread_state->ash.flavor == _ARM_THREAD_STATE ? @\"ARM_THREAD_STATE\" :\n         _arm_unified_thread_state->ash.flavor == _ARM_VFP_STATE ? @\"ARM_VFP_STATE\" :\n         _arm_unified_thread_state->ash.flavor == _ARM_EXCEPTION_STATE ? @\"ARM_EXCEPTION_STATE\" :\n         _arm_unified_thread_state->ash.flavor == _ARM_DEBUG_STATE ? @\"ARM_DEBUG_STATE\" :\n         _arm_unified_thread_state->ash.flavor == _ARM_THREAD_STATE_NONE ? @\"THREAD_STATE_NONE\" : @\"???\"];\n        \n        [dataController read_uint32:range lastReadHex:&lastReadHex];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                               :lastReadHex\n                               :@\"Count\"\n                               :[NSString stringWithFormat:@\"%u\", _arm_unified_thread_state->ash.count]];\n        \n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n        \n        if (_arm_unified_thread_state->ash.flavor == _ARM_THREAD_STATE) {\n            entryPoint = _arm_unified_thread_state->uts.ts32.pc;\n            NSDictionary * stateDict = [NSDictionary dictionaryWithObjectsAndKeys:\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[0]],   @\"r0\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[1]],   @\"r1\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[2]],   @\"r2\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[3]],   @\"r3\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[4]],   @\"r4\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[5]],   @\"r5\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[6]],   @\"r6\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[7]],   @\"r7\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[8]],   @\"r8\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[9]],   @\"r9\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[10]],  @\"r10\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[11]],  @\"r11\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.r[12]],  @\"r12\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.sp],     @\"sp\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.lr],     @\"lr\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.pc],     @\"pc\",\n                                        [NSString stringWithFormat:@\"%u\",_arm_unified_thread_state->uts.ts32.cpsr],   @\"cpsr\",\n                                        nil];\n            \n            for (id key in [NSArray arrayWithObjects:\n                            @\"r0\", @\"r1\", @\"r2\", @\"r3\", @\"r4\", @\"r5\", @\"r6\",\n                            @\"r7\", @\"r8\", @\"r9\", @\"r10\",@\"r11\", @\"r12\",\n                            @\"sp\", @\"lr\", @\"pc\", @\"cpsr\", nil])\n            {\n                [dataController read_uint32:range lastReadHex:&lastReadHex];\n                [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                                       :lastReadHex\n                                       :key\n                                       :[stateDict objectForKey:key]];\n            }\n        }\n    }\n    // these seem impossible to build - arm64 builds to iOS 7 min and LC_MAIN was introduced with iOS 6\n    else if (mach_header->cputype == CPU_TYPE_ARM64) {\n#pragma message \"TODO: ARM64\"\n    }\n    \n    return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCDylibNode:(MVNode *)parent\n                    caption:(NSString *)caption\n                   location:(uint64_t)location\n              dylib_command:(struct dylib_command const *)dylib_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:dylib_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:dylib_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", dylib_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Str Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dylib_command->dylib.name.offset]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  time_t time = (time_t)dylib_command->dylib.timestamp;\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Time Stamp\"\n                         :[NSString stringWithFormat:@\"%s\", ctime(&time)]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Current Version\"\n                         :[NSString stringWithFormat:@\"%u.%u.%u\",  \n                           (dylib_command->dylib.current_version >> 16),\n                           ((dylib_command->dylib.current_version >> 8) & 0xff),\n                           (dylib_command->dylib.current_version & 0xff)]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Compatibility Version\"\n                         :[NSString stringWithFormat:@\"%u.%u.%u\",  \n                           (dylib_command->dylib.compatibility_version >> 16),\n                           ((dylib_command->dylib.compatibility_version >> 8) & 0xff),\n                           (dylib_command->dylib.compatibility_version & 0xff)]];\n\n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  \n  range = NSMakeRange(location + dylib_command->dylib.name.offset,0);\n  NSString * name = [dataController read_string:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :name];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCLinkeditDataNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n             linkedit_data_command:(struct linkedit_data_command const *)linkedit_data_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:linkedit_data_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:linkedit_data_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", linkedit_data_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Data Offset\"\n                         :[NSString stringWithFormat:@\"%u\", linkedit_data_command->dataoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Data Size\"\n                         :[NSString stringWithFormat:@\"%u\", linkedit_data_command->datasize]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCRoutinesNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                routines_command:(struct routines_command const *)routines_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:routines_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:routines_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Init Address\"\n                         :[NSString stringWithFormat:@\"0x%X\", routines_command->init_address]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Init Module\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->init_module]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved1\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->reserved1]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved2\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->reserved2]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved3\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->reserved3]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved4\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->reserved4]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved5\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->reserved5]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved6\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command->reserved6]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCRoutines64Node:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n               routines_command_64:(struct routines_command_64 const *)routines_command_64\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:routines_command_64->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:routines_command_64->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", routines_command_64->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Init Address\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->init_address]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Init Module\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->init_module]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved1\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->reserved1]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved2\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->reserved2]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved3\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->reserved3]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved4\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->reserved4]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved5\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->reserved5]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved6\"\n                         :[NSString stringWithFormat:@\"%qu\", routines_command_64->reserved6]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSubFrameworkNode:(MVNode *)parent\n                             caption:(NSString *)caption\n                            location:(uint64_t)location\n               sub_framework_command:(struct sub_framework_command const *)sub_framework_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sub_framework_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:sub_framework_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", sub_framework_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Str Offset\"\n                         :[NSString stringWithFormat:@\"%u\", sub_framework_command->umbrella.offset]];\n  \n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n\n  range = NSMakeRange(location + sub_framework_command->umbrella.offset,0);\n  NSString * name = [dataController read_string:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Umbrella\"\n                         :name];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSubUmbrellaNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n               sub_umbrella_command:(struct sub_umbrella_command const *)sub_umbrella_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sub_umbrella_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:sub_umbrella_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", sub_umbrella_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Str Offset\"\n                         :[NSString stringWithFormat:@\"%u\", sub_umbrella_command->sub_umbrella.offset]];\n  \n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n\n  range = NSMakeRange(location + sub_umbrella_command->sub_umbrella.offset,0);\n  NSString * name = [dataController read_string:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Sub Umbrella\"\n                         :name];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSubClientNode:(MVNode *)parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n               sub_client_command:(struct sub_client_command const *)sub_client_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sub_client_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:sub_client_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", sub_client_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Str Offset\"\n                         :[NSString stringWithFormat:@\"%u\", sub_client_command->client.offset]];\n  \n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n\n  range = NSMakeRange(location + sub_client_command->client.offset,0);\n  NSString * name = [dataController read_string:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Client\"\n                         :name];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSubLibraryNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n               sub_library_command:(struct sub_library_command const *)sub_library_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sub_library_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:sub_library_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", sub_library_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Str Offset\"\n                         :[NSString stringWithFormat:@\"%u\", sub_library_command->sub_library.offset]];\n  \n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n\n  range = NSMakeRange(location + sub_library_command->sub_library.offset,0);\n  NSString * name = [dataController read_string:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Sub Library\"\n                         :name];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCDyldInfoNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n               dyld_info_command:(struct dyld_info_command const *)dyld_info_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:dyld_info_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:dyld_info_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Rebase Info Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->rebase_off]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Rebase Info Size\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->rebase_size]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Binding Info Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->bind_off]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Binding Info Size\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->bind_size]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Weak Binding Info Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->weak_bind_off]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Weak Binding Info Size\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->weak_bind_size]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Lazy Binding Info Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->lazy_bind_off]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Lazy Binding Info Size\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->lazy_bind_size]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Export Info Offset\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->export_off]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Export Info Size\"\n                         :[NSString stringWithFormat:@\"%u\", dyld_info_command->export_size]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCEncryptionInfoNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n               encryption_info_command:(struct encryption_info_command const *)encryption_info_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:encryption_info_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:encryption_info_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Crypt Offset\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command->cryptoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Crypt Size\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command->cryptsize]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Crypt ID\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command->cryptid]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCEncryptionInfo64Node:(MVNode *)parent\n                                 caption:(NSString *)caption\n                                location:(uint64_t)location\n              encryption_info_command_64:(struct encryption_info_command_64 const *)encryption_info_command_64\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:encryption_info_command_64->cmdsize saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:encryption_info_command_64->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command_64->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n   MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Crypt Offset\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command_64->cryptoff]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Crypt Size\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command_64->cryptsize]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Crypt ID\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command_64->cryptid]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Padding\"\n                         :[NSString stringWithFormat:@\"%u\", encryption_info_command_64->pad]];\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCRPathNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n                rpath_command:(struct rpath_command const *)rpath_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:rpath_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:rpath_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", rpath_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Str Offset\"\n                         :[NSString stringWithFormat:@\"%u\", rpath_command->path.offset]];\n  \n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  \n  range = NSMakeRange(location + rpath_command->path.offset,0);\n  NSString * name = [dataController read_string:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Path\"\n                         :name];\n  return node;\n}               \n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCVersionMinNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n               version_min_command:(struct version_min_command const *)version_min_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:version_min_command->cmdsize saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:version_min_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", version_min_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Version\"\n                         :[NSString stringWithFormat:@\"%u.%u.%u\",  \n                           (version_min_command->version >> 16),\n                           ((version_min_command->version >> 8) & 0xff),\n                           (version_min_command->version & 0xff)]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved\"\n                         :[NSString stringWithFormat:@\"%u\", version_min_command->sdk]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCMainNode:(MVNode *)parent\n                     caption:(NSString *)caption\n                    location:(uint64_t)location\n          entrypoint_command:(struct entry_point_command const *)entry_point_command\n{\n    MVNodeSaver nodeSaver;\n    MVNode * node = [parent insertChildWithDetails:caption location:location length:entry_point_command->cmdsize saver:nodeSaver];\n    \n    NSRange range = NSMakeRange(location,0);\n    NSString * lastReadHex;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Command\"\n                           :[self getNameForCommand:entry_point_command->cmd]];\n    \n    [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Command Size\"\n                           :[NSString stringWithFormat:@\"%u\", entry_point_command->cmdsize]];\n    \n    [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n     MVUnderlineAttributeName,@\"YES\",nil];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Entry Offset\"\n                           :[NSString stringWithFormat:@\"%qu\", entry_point_command->entryoff]];\n\n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Stacksize\"\n                           :[NSString stringWithFormat:@\"%qu\", entry_point_command->stacksize]];\n    // add an entry with entry point address\n    // this is the non-aslr value since we don't know its value here\n    uint64_t text_vmaddr = 0;\n    if ([self is64bit] == YES) {\n        for (Segment64Vector::const_iterator cmdIter = segments_64.begin(); cmdIter != segments_64.end(); ++cmdIter) {\n            struct segment_command_64 const *sg = (struct segment_command_64 const *)(*cmdIter);\n            if (strncmp(sg->segname, \"__TEXT\", 16) == 0) {\n                text_vmaddr = sg->vmaddr;\n                break;\n            }\n        }\n    }\n    else {\n        for (SegmentVector::const_iterator cmdIter = segments.begin(); cmdIter != segments.end(); ++cmdIter) {\n            struct segment_command const *sg = (struct segment_command const *)(*cmdIter);\n            if (strncmp(sg->segname, \"__TEXT\", 16) == 0) {\n                text_vmaddr = sg->vmaddr;\n                break;\n            }\n        }\n    }\n        \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8x\", 0]\n                           :[NSString stringWithFormat:@\"%.16qX\", text_vmaddr + entry_point_command->entryoff]\n                           :@\"Entry Point\"\n                           :[NSString stringWithFormat:@\"0x%qX\", text_vmaddr + entry_point_command->entryoff]];\n\n    return node;\n}\n\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCSourceVersionNode:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n               source_version_command:(struct source_version_command const *)source_version_command\n{\n    MVNodeSaver nodeSaver;\n    MVNode * node = [parent insertChildWithDetails:caption location:location length:source_version_command->cmdsize saver:nodeSaver];\n    \n    NSRange range = NSMakeRange(location,0);\n    NSString * lastReadHex;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Command\"\n                           :[self getNameForCommand:source_version_command->cmd]];\n    \n    [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Command Size\"\n                           :[NSString stringWithFormat:@\"%u\", source_version_command->cmdsize]];\n    \n    [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n     MVUnderlineAttributeName,@\"YES\",nil];\n    \n    // ripped from otool source code\n    uint64_t a, b, c, d, e;\n    NSString *version;\n\ta = (source_version_command->version >> 40) & 0xffffff;\n\tb = (source_version_command->version >> 30) & 0x3ff;\n\tc = (source_version_command->version >> 20) & 0x3ff;\n\td = (source_version_command->version >> 10) & 0x3ff;\n\te = source_version_command->version & 0x3ff;\n\tif(e != 0)\n        version = [NSString stringWithFormat:@\"%llu.%llu.%llu.%llu.%llu\\n\", a, b, c, d, e];\n\telse if(d != 0)\n        version = [NSString stringWithFormat:@\"%llu.%llu.%llu.%llu\\n\", a, b, c, d];\n\telse if(c != 0)\n        version = [NSString stringWithFormat:@\"%llu.%llu.%llu\\n\", a, b, c];\n\telse\n        version = [NSString stringWithFormat:@\"%llu.%llu\\n\", a, b];\n\n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Version\"\n                           :version];\n\n    return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createLCLinkerOptionNode:(MVNode *)parent\n                             caption:(NSString *)caption\n                            location:(uint64_t)location\n               linker_option_command:(struct linker_option_command const *)linker_option_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:linker_option_command->cmdsize saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:linker_option_command->cmd]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", linker_option_command->cmdsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n   MVUnderlineAttributeName,@\"YES\",nil];\n  \n#pragma message \"TODO\"\n//  void\n//  print_linker_option_command(\n//                              struct linker_option_command *lo,\n//                              struct load_command *lc)\n//  {\n//    int left, len, i;\n//    char *string;\n//    \n//    printf(\"     cmd LC_LINKER_OPTION\\n\");\n//    printf(\" cmdsize %u\", lo->cmdsize);\n//    if(lo->cmdsize < sizeof(struct linker_option_command))\n//\t    printf(\" Incorrect size\\n\");\n//    else\n//\t    printf(\"\\n\");\n//    printf(\"   count %u\\n\", lo->count);\n//    string = (char *)lc + sizeof(struct linker_option_command);\n//    left = lo->cmdsize - sizeof(struct linker_option_command);\n//    i = 0;\n//    while(left > 0){\n//\t    while(*string == '\\0' && left > 0){\n//        string++;\n//        left--;\n//\t    }\n//\t    if(left > 0){\n//        i++;\n//        printf(\"  string #%d %.*s\\n\", i, left, string);\n//        len = strnlen(string, left) + 1;\n//        string += len;\n//        left -= len;\n//\t    }\n//    }\n//    if(lo->count != i)\n//      printf(\"   count %u does not match number of strings %u\\n\",\n//             lo->count, i);\n//  }\n  \n  return node;\n}\n\n- (NSString *)platformDescription:(uint32_t)platform {\n    switch (platform) {\n        case PLATFORM_MACOS: return @\"macOS\";\n        case PLATFORM_IOS: return @\"iOS\";\n        case PLATFORM_TVOS: return @\"tvOS\";\n        case PLATFORM_WATCHOS: return @\"watchOS\";\n        case PLATFORM_BRIDGEOS: return @\"brigeOS\";\n        case PLATFORM_MACCATALYST: return @\"Mac Catalyst\";\n        case PLATFORM_IOSSIMULATOR: return @\"iOS Simulator\";\n        case PLATFORM_TVOSSIMULATOR: return @\"tvOS Simulator\";\n        case PLATFORM_WATCHOSSIMULATOR: return @\"watchOS Simulator\";\n        case PLATFORM_DRIVERKIT: return @\"DriverKit\";\n        // available in Xcode 13.3 or higher with SDK 12.3+\n#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 120300\n        case PLATFORM_FIRMWARE: return @\"Firmware\";\n        case PLATFORM_SEPOS: return @\"SEPOS\";\n#endif\n        // available in Xcode 14.1 or higher with SDK 13.0+\n#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 130000\n        case PLATFORM_ANY: return @\"Any\";\n#endif\n        default: return @\"Unknown\";\n    }\n}\n\n- (NSString *)toolDescription:(uint32_t)tool {\n    switch (tool) {\n        case TOOL_CLANG: return @\"clang\";\n        case TOOL_SWIFT: return @\"swiftc\";\n        case TOOL_LD: return @\"ld\";\n        // available in Xcode 13.3 or higher with SDK 12.3+\n#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 120300\n        case TOOL_LLD: return @\"ldd\";\n#endif\n        // available in Xcode 14.1 or higher with SDK 13.0+\n#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 130000\n        case TOOL_METAL: return @\"Metal\";\n        case TOOL_AIRLLD: return @\"Air lld\";\n        case TOOL_AIRNT: return @\"Air nt\";\n        case TOOL_AIRNT_PLUGIN: return @\"Air nt plugin\";\n        case TOOL_AIRPACK: return @\"Air pack\";\n        case TOOL_GPUARCHIVER: return @\"GPU Archiver\";\n        case TOOL_METAL_FRAMEWORK: return @\"Metal Framework\";\n#endif\n        default: return @\"unknown\";\n    }\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createBuildVersionNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n               version_min_command:(struct build_version_command const *)build_version_command\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:build_version_command->cmdsize saver:nodeSaver];\n\n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command\"\n                         :[self getNameForCommand:build_version_command->cmd]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Command Size\"\n                         :[NSString stringWithFormat:@\"%u\", build_version_command->cmdsize]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  NSString *platform = [self platformDescription:build_version_command->platform];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Platform\"\n                         :[NSString stringWithFormat:@\"%@ (%u)\", platform, build_version_command->platform]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Minimum OS Version\"\n                         :[NSString stringWithFormat:@\"%u.%u.%u\",\n                           (build_version_command->minos >> 16),\n                           ((build_version_command->minos >> 8) & 0xff),\n                           (build_version_command->minos & 0xff)]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Build SDK Version\"\n                         :[NSString stringWithFormat:@\"%u.%u.%u\",\n                           (build_version_command->sdk >> 16),\n                           ((build_version_command->sdk >> 8) & 0xff),\n                           (build_version_command->sdk & 0xff)]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of tools entries\"\n                         :[NSString stringWithFormat:@\"%u\", build_version_command->ntools]];\n  [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n\n  for (uint32_t i = 0; i < build_version_command->ntools; i++) {\n    NSData *bytes = [dataController read_bytes:range length:sizeof(build_tool_version) lastReadHex:&lastReadHex];\n    struct build_tool_version tool_version;\n    [bytes getBytes:&tool_version length:sizeof(build_tool_version)];\n\n    NSString *tool = [self toolDescription:tool_version.tool];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Tool\"\n                           :[NSString stringWithFormat:@\"%@ (%u)\", tool, tool_version.tool]];\n\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Tool Version\"\n                           :[NSString stringWithFormat:@\"%u.%u.%u\",\n                             (tool_version.version >> 16),\n                             ((tool_version.version >> 8) & 0xff),\n                             (tool_version.version & 0xff)]];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n-(MVNode *)createLoadCommandNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n                         command:(uint32_t)command\n{\n  MVNode * node = nil;\n  \n  switch (command)\n  {\n    case LC_SEGMENT:\n    {\n      MATCH_STRUCT(segment_command,location)\n      node = [self createLCSegmentNode:parent \n                               caption:[NSString stringWithFormat:@\"%@ (%s)\", \n                                        caption, string(segment_command->segname,16).c_str()]\n                              location:location\n                       segment_command:segment_command];\n      \n      // preserv segment RVA/size for offset lookup\n      segmentInfo[segment_command->fileoff + imageOffset] = make_pair(segment_command->vmaddr, segment_command->vmsize);\n      \n      // preserv load segment command info for latter use\n      segments.push_back(segment_command);\n      \n      // Section Headers\n      for (uint32_t nsect = 0; nsect < segment_command->nsects; ++nsect)\n      {\n        uint64_t sectionloc = location + sizeof(struct segment_command) + nsect * sizeof(struct section);\n        MATCH_STRUCT(section,sectionloc)\n        [self createSectionNode:node \n                        caption:[NSString stringWithFormat:@\"Section Header (%s)\",\n                                 string(section->sectname,16).c_str()]\n                       location:sectionloc\n                        section:section];\n        \n        // preserv section fileOffset/sectName for RVA lookup\n        NSDictionary * userInfo = [self userInfoForSection:section];\n        sectionInfo[section->addr] = make_pair(section->offset + imageOffset, userInfo);\n        \n        // preserv header info for latter use\n        sections.push_back(section);\n      }\n    } break;\n      \n    case LC_SEGMENT_64:\n    {\n      MATCH_STRUCT(segment_command_64,location)\n      \n      node = [self createLCSegment64Node:parent \n                                 caption:[NSString stringWithFormat:@\"%@ (%s)\", \n                                          caption, string(segment_command_64->segname,16).c_str()]\n                                location:location\n                      segment_command_64:segment_command_64];\n      \n      // preserv segment RVA/size for offset lookup\n      segmentInfo[segment_command_64->fileoff + imageOffset] = make_pair(segment_command_64->vmaddr, segment_command_64->vmsize);\n      \n      // preserv load segment command info for latter use\n      segments_64.push_back(segment_command_64);\n\n      // Section Headers\n      for (uint32_t nsect = 0; nsect < segment_command_64->nsects; ++nsect)\n      {\n        uint64_t sectionloc = location + sizeof(struct segment_command_64) + nsect * sizeof(struct section_64);\n        MATCH_STRUCT(section_64,sectionloc)\n        [self createSection64Node:node \n                          caption:[NSString stringWithFormat:@\"Section64 Header (%s)\",\n                                   string(section_64->sectname,16).c_str()]\n                         location:sectionloc\n                       section_64:section_64];\n        \n        // preserv section fileOffset/sectName for RVA lookup\n        NSDictionary * userInfo = [self userInfoForSection64:section_64];\n        sectionInfo[section_64->addr] = make_pair(section_64->offset + imageOffset, userInfo);\n\n        // preserv header info for latter use\n        sections_64.push_back(section_64);\n      }\n    } break;\n      \n    case LC_SYMTAB:\n    {\n      MATCH_STRUCT(symtab_command,location)\n      \n      node = [self createLCSymtabNode:parent \n                              caption:caption\n                             location:location\n                       symtab_command:symtab_command];\n      \n      strtab = (char *)((uint8_t *)[dataController.fileData bytes] + imageOffset + symtab_command->stroff);\n      \n      for (uint32_t nsym = 0; nsym < symtab_command->nsyms; ++nsym)\n      {\n        if ([self is64bit] == NO)\n        {\n          MATCH_STRUCT(nlist,imageOffset + symtab_command->symoff + nsym * sizeof(struct nlist))\n          symbols.push_back (nlist);\n        }\n        else // 64bit\n        {\n          MATCH_STRUCT(nlist_64,imageOffset + symtab_command->symoff + nsym * sizeof(struct nlist_64))\n          symbols_64.push_back (nlist_64);\n        }\n        \n      }\n    } break;\n      \n    case LC_DYSYMTAB:\n    {\n      MATCH_STRUCT(dysymtab_command,location)\n      node = [self createLCDysymtabNode:parent \n                                caption:caption\n                               location:location\n                       dysymtab_command:dysymtab_command];\n    } break;\n      \n    case LC_TWOLEVEL_HINTS:\n    {\n      MATCH_STRUCT(twolevel_hints_command,location)\n      node = [self createLCTwolevelHintsNode:parent \n                                     caption:caption\n                                    location:location\n                      twolevel_hints_command:twolevel_hints_command];\n    } break;\n      \n    case LC_ID_DYLINKER:\n    case LC_LOAD_DYLINKER:\n    case LC_DYLD_ENVIRONMENT:\n    {\n      MATCH_STRUCT(dylinker_command,location)\n      node = [self createLCDylinkerNode:parent \n                                caption:caption\n                               location:location\n                       dylinker_command:dylinker_command];\n    } break;\n    \n    case LC_PREBIND_CKSUM:\n    {\n      MATCH_STRUCT(prebind_cksum_command,location)\n      node = [self createLCPrebindChksumNode:parent \n                                     caption:caption\n                                    location:location\n                       prebind_cksum_command:prebind_cksum_command];\n    } break;\n    \n    case LC_UUID:\n    {\n      MATCH_STRUCT(uuid_command,location)\n      node = [self createLCUUIDNode:parent \n                            caption:caption\n                           location:location\n                       uuid_command:uuid_command];\n    } break;\n      \n    case LC_THREAD:\n    case LC_UNIXTHREAD:\n    {\n      MATCH_STRUCT(thread_command,location)\n      node = [self createLCThreadNode:parent \n                              caption:caption\n                             location:location\n                       thread_command:thread_command];\n    } break; \n      \n    case LC_ID_DYLIB:\n    case LC_LOAD_DYLIB:\n    case LC_LOAD_WEAK_DYLIB:\n    case LC_REEXPORT_DYLIB:\n    case LC_LAZY_LOAD_DYLIB:\n    case LC_LOAD_UPWARD_DYLIB:\n    {\n      MATCH_STRUCT(dylib_command,location)\n      if (command != LC_ID_DYLIB)\n      {\n        dylibs.push_back (&dylib_command->dylib);\n      }\n      NSRange range = NSMakeRange(location + dylib_command->dylib.name.offset,0);\n      NSString * name = [dataController read_string:range];\n      \n      node = [self createLCDylibNode:parent \n                             caption:[NSString stringWithFormat:@\"%@ (%@)\", \n                                      caption, [name lastPathComponent]]\n                            location:location\n                       dylib_command:dylib_command];\n    } break; \n      \n    case LC_CODE_SIGNATURE:\n    case LC_SEGMENT_SPLIT_INFO:\n    case LC_FUNCTION_STARTS:\n    case LC_DATA_IN_CODE:\n    case LC_DYLIB_CODE_SIGN_DRS:\n    case LC_LINKER_OPTIMIZATION_HINT:\n    {\n      MATCH_STRUCT(linkedit_data_command,location)\n      node = [self createLCLinkeditDataNode:parent \n                                    caption:caption\n                                   location:location\n                      linkedit_data_command:linkedit_data_command];\n    } break;   \n\n    case LC_ENCRYPTION_INFO:\n    {\n      MATCH_STRUCT(encryption_info_command, location)\n      node = [self createLCEncryptionInfoNode:parent\n                                      caption:caption\n                                     location:location\n                      encryption_info_command:encryption_info_command];\n    } break;\n      \n    case LC_ENCRYPTION_INFO_64:\n    {\n      MATCH_STRUCT(encryption_info_command_64, location)\n      node = [self createLCEncryptionInfo64Node:parent\n                                        caption:caption\n                                       location:location\n                     encryption_info_command_64:encryption_info_command_64];\n    } break;\n\n    case LC_RPATH:\n    {\n      MATCH_STRUCT(rpath_command, location)\n      node = [self createLCRPathNode:parent\n                             caption:caption\n                            location:location\n                       rpath_command:rpath_command];\n    } break;\n    \n    case LC_ROUTINES:\n    {\n      MATCH_STRUCT(routines_command,location)\n      node = [self createLCRoutinesNode:parent \n                                caption:caption\n                               location:location\n                       routines_command:routines_command];\n    } break; \n      \n    case LC_ROUTINES_64:\n    {\n      MATCH_STRUCT(routines_command_64,location)\n      node = [self createLCRoutines64Node:parent \n                                  caption:caption\n                                 location:location\n                      routines_command_64:routines_command_64];\n    } break;   \n      \n    case LC_SUB_FRAMEWORK:\n    {\n      MATCH_STRUCT(sub_framework_command,location)\n      node = [self createLCSubFrameworkNode:parent \n                                    caption:caption\n                                   location:location\n                      sub_framework_command:sub_framework_command];\n    } break; \n      \n    case LC_SUB_UMBRELLA:\n    {\n      MATCH_STRUCT(sub_umbrella_command,location)\n      node = [self createLCSubUmbrellaNode:parent \n                                   caption:caption\n                                  location:location\n                      sub_umbrella_command:sub_umbrella_command];\n    } break; \n      \n    case LC_SUB_CLIENT:\n    {\n      MATCH_STRUCT(sub_client_command,location)\n      node = [self createLCSubClientNode:parent \n                                 caption:caption\n                                location:location\n                      sub_client_command:sub_client_command];\n    } break; \n      \n    case LC_SUB_LIBRARY:\n    {\n      MATCH_STRUCT(sub_library_command,location)\n      node = [self createLCSubLibraryNode:parent \n                                  caption:caption\n                                 location:location\n                      sub_library_command:sub_library_command];\n    } break; \n      \n    case LC_DYLD_INFO:\n    case LC_DYLD_INFO_ONLY:\n    {\n      MATCH_STRUCT(dyld_info_command,location)\n      node = [self createLCDyldInfoNode:parent \n                                caption:caption\n                               location:location\n                      dyld_info_command:dyld_info_command];\n    } break;   \n    \n      case LC_VERSION_MIN_MACOSX:\n      case LC_VERSION_MIN_IPHONEOS:\n      case LC_VERSION_MIN_TVOS:\n      case LC_VERSION_MIN_WATCHOS:\n      {\n          MATCH_STRUCT(version_min_command,location)\n          node = [self createLCVersionMinNode:parent\n                                      caption:caption\n                                     location:location\n                          version_min_command:version_min_command];\n          break;\n      }\n    case LC_MAIN:\n    {\n        MATCH_STRUCT(entry_point_command, location)\n        node = [self createLCMainNode:parent\n                              caption:caption\n                             location:location\n                   entrypoint_command:entry_point_command];\n    } break;\n    case LC_SOURCE_VERSION:\n    {\n        MATCH_STRUCT(source_version_command, location);\n        node = [self createLCSourceVersionNode:parent\n                                       caption:caption\n                                      location:location\n                        source_version_command:source_version_command];\n    } break;\n    case LC_LINKER_OPTION:\n    {\n      MATCH_STRUCT(linker_option_command, location);\n      node = [self createLCLinkerOptionNode:parent\n                                    caption:caption\n                                   location:location\n                      linker_option_command:linker_option_command];\n    } break;\n    case LC_BUILD_VERSION:\n    {\n      MATCH_STRUCT(build_version_command, location);\n      node = [self createBuildVersionNode:parent\n                                  caption:caption\n                                 location:location\n                      version_min_command:build_version_command];\n      break;\n    }\n          // just create space for missing commands for now\n#if 0\n      case LC_NOTE:\n      {\n          break;\n      }\n      case LC_DYLD_EXPORTS_TRIE:\n      {\n          break;\n      }\n      case LC_DYLD_CHAINED_FIXUPS:\n      {\n          break;\n      }\n      case LC_FILESET_ENTRY:\n      {\n          break;\n      }\n#endif\n      default:\n      [self createDataNode:parent \n                   caption:[NSString stringWithFormat:@\"%@ (unsupported)\", caption]\n                  location:location\n                    length:length];\n  } // switch\n  \n  return node;\n}\n\n@end\n"
        },
        {
          "name": "MachOLayout.h",
          "type": "blob",
          "size": 4.0576171875,
          "content": "/*\n *  MachOLayout.h\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cxxabi.h>\n\n#import \"Layout.h\"\n\ntypedef std::vector<struct load_command const *>          CommandVector;\ntypedef std::vector<struct segment_command const *>       SegmentVector;\ntypedef std::vector<struct segment_command_64 const *>    Segment64Vector;\ntypedef std::vector<struct section const *>               SectionVector;\ntypedef std::vector<struct section_64 const *>            Section64Vector;\ntypedef std::vector<struct nlist const *>                 NListVector;\ntypedef std::vector<struct nlist_64 const *>              NList64Vector;\ntypedef std::vector<struct dylib const *>                 DylibVector;\ntypedef std::vector<struct dylib_module const *>          ModuleVector;\ntypedef std::vector<struct dylib_module_64 const *>       Module64Vector;\ntypedef std::vector<struct data_in_code_entry const *>    DataInCodeEntryVector;\ntypedef std::vector<uint32_t const *>                     IndirectSymbolVector;\n\ntypedef std::map<uint32_t,std::pair<uint64_t,uint64_t> >        RelocMap;           // fileOffset --> <length,value>\ntypedef std::map<uint64_t,std::pair<uint64_t,uint64_t> >        SegmentInfoMap;     // fileOffset --> <address,size>\ntypedef std::map<uint64_t,std::pair<uint64_t,NSDictionary *> >  SectionInfoMap;     // address --> <fileOffset,sectionUserInfo>\ntypedef std::map<uint64_t,uint64_t>                             ExceptionFrameMap;  // LSDA_addr  --> PCBegin_addr\n\n@interface MachOLayout : MVLayout \n{\n  uint64_t                entryPoint;       // instruction pointer in thread command\n  \n  CommandVector           commands;         // load commands\n  SegmentVector           segments;         // segment entries for 32-bit architectures\n  Segment64Vector         segments_64;      // segment entries for 64-bit architectures\n  SectionVector           sections;         // section entries for 32-bit architectures\n  Section64Vector         sections_64;      // section entries for 64-bit architectures\n  NListVector             symbols;          // symbol entries in the symbol table for 32-bit architectures\n  NList64Vector           symbols_64;       // symbol entries in the symbol table for 64-bit architectures\n  IndirectSymbolVector    isymbols;         // indirect symbols\n  \n  DylibVector             dylibs;           // imported dynamic libraries\n  ModuleVector            modules;          // module table entries in a dynamic shared library for 32-bit architectures\n  Module64Vector          modules_64;       // module table entries in a dynamic shared library for 64-bit architectures\n  DataInCodeEntryVector   dices;            // data in code entries\n  char const *            strtab;           // pointer to the string table\n  \n  //RelocMap                relocMap;         // section relocations\n  SegmentInfoMap          segmentInfo;      // segment info lookup table by offset\n  SectionInfoMap          sectionInfo;      // section info lookup table by address\n  ExceptionFrameMap       lsdaInfo;         // LSDA info lookup table by address\n  \n  NSMutableDictionary *   symbolNames;      // symbol names by address\n}\n\n+ (MachOLayout *)layoutWithDataController:(MVDataController *)dc rootNode:(MVNode *)node;\n\n- (struct section const *)getSectionByIndex:(uint32_t)index;\n- (struct section_64 const *)getSection64ByIndex:(uint32_t)index;\n\n- (struct nlist const *)getSymbolByIndex:(uint32_t)index;\n- (struct nlist_64 const *)getSymbol64ByIndex:(uint32_t)index;\n\n- (struct dylib const *)getDylibByIndex:(uint32_t)index;\n\n- (NSDictionary *)userInfoForSection:(struct section const *)section;\n- (NSDictionary *)userInfoForSection64:(struct section_64 const *)section_64;\n\n- (MVNode *)sectionNodeContainsRVA:(uint64_t)rva;\n\n- (NSString *)findSectionContainsRVA:(uint64_t)rva;\n\n- (NSString *)findSymbolAtRVA:(uint64_t)rva;\n\n- (uint64_t)fileOffsetToRVA:(uint64_t)offset;\n\n- (uint64_t)RVAToFileOffset:(uint64_t)rva;\n\n- (void)addRelocAtFileOffset:(uint64_t)offset withLength:(uint64_t)length andValue:(uint64_t)value;\n\n- (BOOL)isDylibStub;\n\n@end\n"
        },
        {
          "name": "MachOLayout.mm",
          "type": "blob",
          "size": 107.7958984375,
          "content": "/*\n *  MachOLayout.mm\n *  MachOView\n *\n *  Created by psaghelyi on 15/06/2010.\n *\n */\n\n#import \"Common.h\"\n#import \"MachOLayout.h\"\n#import \"DataController.h\"\n#import \"ReadWrite.h\"\n#import \"LoadCommands.h\"\n#import \"LinkEdit.h\"\n#import \"DyldInfo.h\"\n#import \"Exceptions.h\"\n#import \"SectionContents.h\"\n#import \"ObjC.h\"\n#import \"CRTFootPrints.h\"\n#import <mach-o/loader.h>\n#import <mach-o/nlist.h>\n#import <mach-o/reloc.h>\n\nusing namespace std;\n\n//============================================================================\n@implementation MachOLayout\n\n//-----------------------------------------------------------------------------\n- (instancetype)initWithDataController:(MVDataController *)dc rootNode:(MVNode *)node\n{\n  if (self = [super initWithDataController:dc rootNode:node])\n  {\n    symbolNames = [[NSMutableDictionary alloc] init];\n  }\n  return self;\n}\n\n//-----------------------------------------------------------------------------\n+ (MachOLayout *)layoutWithDataController:(MVDataController *)dc rootNode:(MVNode *)node\n{\n  return [[MachOLayout alloc] initWithDataController:dc rootNode:node];\n}\n\n//-----------------------------------------------------------------------------\n- (BOOL)is64bit\n{\n  MATCH_STRUCT(mach_header,imageOffset);\n  return ((mach_header->cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64);\n}\n\n//-----------------------------------------------------------------------------\n- (BOOL)isDylibStub\n{\n  MATCH_STRUCT(mach_header,imageOffset);\n  return (mach_header->filetype == MH_DYLIB_STUB);\n}\n\n//-----------------------------------------------------------------------------\n- (struct section const *)getSectionByIndex:(uint32_t)index\n{\n  static const struct section notfound = { \"???\", \"?????\", 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n  return (index < sections.size() ? sections.at(index) : &notfound);\n}\n\n//-----------------------------------------------------------------------------\n- (struct section_64 const *)getSection64ByIndex:(uint32_t)index\n{\n  static const struct section_64 notfound = { \"???\", \"?????\", 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n  return (index < sections_64.size() ? sections_64.at(index) : &notfound);\n}\n\n//-----------------------------------------------------------------------------\n- (struct nlist const *)getSymbolByIndex:(uint32_t)index\n{\n  static const struct nlist notfound = { 0, 0, 0, 0, 0 }; \n  return (index < symbols.size() ? symbols.at(index) : &notfound);\n}\n\n//-----------------------------------------------------------------------------\n- (struct nlist_64 const *)getSymbol64ByIndex:(uint32_t)index\n{\n  static const struct nlist_64 notfound = { 0, 0, 0, 0, 0 }; \n  return (index < symbols_64.size() ? symbols_64.at(index) : &notfound);\n}\n\n//-----------------------------------------------------------------------------\n- (struct dylib const *)getDylibByIndex:(uint32_t)index\n{\n  static const struct dylib notfound = { 0, 0, 0, 0 }; \n  return (index < dylibs.size() ? dylibs.at(index) : &notfound);\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)findSymbolAtRVA:(uint64_t)rva\n{\n  NSString * symbolName = [symbolNames objectForKey:[NSNumber numberWithUnsignedLongLong:rva]];\n  return (symbolName != nil ? symbolName : [NSString stringWithFormat:@\"0x%qX\",rva]);\n}\n\n//-----------------------------------------------------------------------------\n-(struct section const *)findSectionByName:(char const *)sectname \n                                andSegment:(char const *)segname\n{\n    \n  for (SectionVector::const_iterator sectIter = ++sections.begin(); \n       sectIter != sections.end(); ++sectIter)\n  {\n    struct section const * section = *sectIter;\n    if ((segname == NULL || strncmp(section->segname,segname,16) == 0) && \n        strncmp(section->sectname,sectname,16) == 0)\n    {\n      return section;\n    }\n  }\n  return NULL;\n}\n\n//-----------------------------------------------------------------------------\n-(struct section_64 const *)findSection64ByName:(char const *)sectname \n                                     andSegment:(char const *)segname\n{\n  \n  for (Section64Vector::const_iterator sectIter = ++sections_64.begin(); \n       sectIter != sections_64.end(); ++sectIter)\n  {\n    struct section_64 const * section_64 = *sectIter;\n    if ((segname == NULL || strncmp(section_64->segname,segname,16) == 0) &&\n        strncmp(section_64->sectname,sectname,16) == 0)\n    {\n      return section_64;\n    }\n  }\n  return NULL;\n}\n\n//-----------------------------------------------------------------------------\n// convert a file offset to the virtual address\n- (uint64_t)fileOffsetToRVA: (uint64_t)offset\n{\n    SegmentInfoMap::const_iterator segIter = segmentInfo.upper_bound(offset);\n    if (segIter == segmentInfo.begin()) {\n        [NSException raise:@\"fileOffsetToRVA\"\n                    format:@\"no segment found at offset 0x%llX\", offset];\n    }\n    --segIter;\n    uint64_t segOffset = segIter->first;\n    uint64_t segAddr = segIter->second.first;\n    // XXX: missing overflow checks\n    return offset - segOffset + segAddr;\n}\n\n// ----------------------------------------------------------------------------\n- (uint64_t)RVAToFileOffset: (uint64_t)rva\n{\n    SectionInfoMap::const_iterator sectIter = sectionInfo.upper_bound(rva);\n    if (sectIter == sectionInfo.begin()) {\n        [NSException raise:@\"RVAToFileOffset\"\n                    format:@\"no section found at address 0x%llX\", rva];\n    }\n    --sectIter;\n    uint64_t sectOffset = sectIter->second.first;\n    uint64_t fileOffset = sectOffset + (rva - [self fileOffsetToRVA:sectOffset]);\n    NSAssert1(fileOffset < [dataController.fileData length], @\"rva is out of range (0x%llX)\", rva);\n    return fileOffset;\n}\n\n// ----------------------------------------------------------------------------\n- (void)addRelocAtFileOffset:(uint64_t)offset withLength:(uint64_t)length andValue:(uint64_t)value\n{\n  [dataController.realData replaceBytesInRange:NSMakeRange(offset,length) withBytes:&value];\n}\n\n// ----------------------------------------------------------------------------\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Winitializer-overrides\"\nstatic const long hextable[] =\n{\n  [0 ... 255] = -1, // bit aligned access into this table is considerably\n  ['0'] = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, // faster for most modern processors,\n  ['A'] = 10, 11, 12, 13, 14, 15,       // for the space conscious, reduce to\n  ['a'] = 10, 11, 12, 13, 14, 15        // signed char.\n};\n#pragma clang diagnostic pop\n\n/**\n * @brief convert a hexidecimal string to a signed long\n * will not produce or process negative numbers except\n * to signal error.\n *\n * @param hex without decoration, case insensitive.\n *\n * @return -1 on error, or result (max (sizeof(long)*8)-1 bits)\n */\nstatic inline\nlong hexdec(const char *hex) {\n    long ret = 0;\n    while (*hex && ret >= 0) {\n        ret = (ret << 4) | hextable[*hex++];\n    }\n    return ret;\n}\n\n// ----------------------------------------------------------------------------\n// RAW string to RVA string converter for data source\n- (NSString *)convertToRVA: (NSString *)offsetStr\n{\n    uint64_t fileOffset = hexdec(CSTRING(offsetStr));\n    NSParameterAssert((long)fileOffset != -1);\n  \n    if (segmentInfo.empty() ||\n        fileOffset < segmentInfo.begin()->first ||\n        fileOffset + 1 >= (--segmentInfo.end())->first + (--segmentInfo.end())->second.second)\n    {\n        return @\"\";\n    }\n  \n    return [NSString stringWithFormat:@\"%.8qX\",[self fileOffsetToRVA:fileOffset]];\n}\n\n// ----------------------------------------------------------------------------\n- (NSDictionary *)userInfoForSection:(struct section const *)section\n{\n  if (section == NULL) return nil;\n  typeof(self) __weak weakSelf = self;\n  return [NSDictionary dictionaryWithObjectsAndKeys:\n          weakSelf,MVLayoutUserInfoKey,\n          NSSTRING(string(section->segname,16).c_str()), @\"segname\",\n          NSSTRING(string(section->sectname,16).c_str()), @\"sectname\",\n          [NSNumber numberWithUnsignedLong:section->addr], @\"address\",\n          nil];\n}\n\n//-----------------------------------------------------------------------------\n- (NSDictionary *)userInfoForSection64:(struct section_64 const *)section_64\n{\n  if (section_64 == NULL) return nil;\n  typeof(self) __weak weakSelf = self;\n  return [NSDictionary dictionaryWithObjectsAndKeys:\n          weakSelf,MVLayoutUserInfoKey,\n          NSSTRING(string(section_64->segname,16).c_str()), @\"segname\",\n          NSSTRING(string(section_64->sectname,16).c_str()), @\"sectname\",\n          [NSNumber numberWithUnsignedLongLong:section_64->addr], @\"address\",\n          nil];\n}\n\n//-----------------------------------------------------------------------------\n- (NSDictionary *)userInfoForRelocs\n{\n  typeof(self) __weak weakSelf = self;\n  return [NSDictionary dictionaryWithObjectsAndKeys:\n          weakSelf,MVLayoutUserInfoKey,\n          @\"Relocations\", MVNodeUserInfoKey,\n          nil];\n}\n\n//-----------------------------------------------------------------------------\n- (NSDictionary *)sectionInfoForRVA:(uint64_t)rva\n{\n    SectionInfoMap::iterator iter = sectionInfo.upper_bound(rva);\n    if (iter == sectionInfo.begin()) {\n        NSLog(@\"warning: no section info found for address 0x%.8qX\",rva);\n        return nil;\n    }\n    return (--iter)->second.second;\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)findSectionContainsRVA:(uint64_t)rva\n{\n    NSDictionary * userInfo = [self sectionInfoForRVA:rva];\n    return (userInfo ? [NSString stringWithFormat:@\"%8s %-16s\",\n                        CSTRING([userInfo objectForKey:@\"segname\"]),\n                        CSTRING([userInfo objectForKey:@\"sectname\"])] : @\"NO SECTION               \");\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)sectionNodeContainsRVA:(uint64_t)rva\n{\n    NSDictionary * userInfo = [self sectionInfoForRVA:rva];\n    return (userInfo ? [self findNodeByUserInfo:userInfo] : nil);\n}\n\n//-----------------------------------------------------------------------------\n-(void) processLinkEdit\n{\n  // find related load commands\n  struct symtab_command const * symtab_command = NULL;\n  struct dysymtab_command const * dysymtab_command = NULL;\n  struct twolevel_hints_command const * twolevel_hints_command = NULL;\n  struct linkedit_data_command const * segment_split_info = NULL;\n  struct linkedit_data_command const * code_signature = NULL;\n  struct linkedit_data_command const * function_starts = NULL;\n  struct linkedit_data_command const * data_in_code_entries = NULL;\n  \n  MATCH_STRUCT(mach_header,imageOffset);\n  \n  uint32_t base_addr;\n  uint32_t seg1addr = (uint32_t)-1;\n  uint32_t segs_read_write_addr = (uint32_t)-1;\n\n  for (CommandVector::const_iterator cmdIter = commands.begin(); cmdIter != commands.end(); ++cmdIter)\n  {\n    struct load_command const * load_command = *cmdIter;\n    switch (load_command->cmd)\n    {\n      case LC_SEGMENT:        \n      {\n        struct segment_command const * segment_command = (struct segment_command const *)load_command;\n        \n        if (segment_command->fileoff == 0 && segment_command->filesize != 0)\n        {\n\t\t\t\t\tbase_addr = segment_command->vmaddr;\n        }\n\n        if(segment_command->vmaddr < seg1addr)\n        {\n          seg1addr = segment_command->vmaddr;\n        }\n        \n        // Pickup the address of the first read-write segment for MH_SPLIT_SEGS images.\n        if((segment_command->initprot & VM_PROT_WRITE) == VM_PROT_WRITE &&\n           segment_command->vmaddr < segs_read_write_addr)\n        {\n          segs_read_write_addr = segment_command->vmaddr;\n        }\n      } break;        \n      case LC_SYMTAB: symtab_command = (struct symtab_command const *)load_command; break;\n      case LC_DYSYMTAB: dysymtab_command = (struct dysymtab_command const *)load_command; break;\n      case LC_TWOLEVEL_HINTS: twolevel_hints_command = (struct twolevel_hints_command const *)load_command; break;\n      case LC_SEGMENT_SPLIT_INFO: segment_split_info = (struct linkedit_data_command const *)load_command; break;\n      case LC_CODE_SIGNATURE: code_signature = (struct linkedit_data_command const *)load_command; break;\n      case LC_FUNCTION_STARTS: function_starts = (struct linkedit_data_command const *)load_command; break;\n      case LC_DATA_IN_CODE: data_in_code_entries = (struct linkedit_data_command const *)load_command; break;\n      default: ; // not interested\n    }\n  }\n  \n  MVNode * symtabNode = nil;\n  MVNode * dysymtabNode = nil;\n  MVNode * twoLevelHintsNode = nil;\n  MVNode * segmentSplitInfoNode = nil;\n  MVNode * functionStartsNode = nil;\n  MVNode * dataInCodeEntriesNode = nil;\n  \n  NSString * lastNodeCaption;\n  \n  if (symtab_command)\n  {\n    symtabNode = [self createDataNode:rootNode\n                              caption:@\"Symbol Table\"\n                             location:symtab_command->symoff + imageOffset\n                               length:symtab_command->nsyms * sizeof(struct nlist)];\n    \n    [self createDataNode:rootNode \n                 caption:@\"String Table\"\n                location:symtab_command->stroff + imageOffset\n                  length:symtab_command->strsize];\n  }\n  \n  if (dysymtab_command)\n  {\n    NSRange dysymtabRange = NSMakeRange(0,0);\n    if (dysymtab_command->tocoff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->tocoff + imageOffset, dysymtab_command->ntoc * sizeof(struct dylib_table_of_contents));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->modtaboff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->modtaboff + imageOffset, dysymtab_command->nmodtab * sizeof(struct dylib_module));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->extrefsymoff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->extrefsymoff + imageOffset, dysymtab_command->nextrefsyms * sizeof(struct dylib_reference));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->indirectsymoff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->indirectsymoff + imageOffset, dysymtab_command->nindirectsyms * sizeof(uint32_t));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->extreloff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->extreloff + imageOffset, dysymtab_command->nextrel * sizeof(struct relocation_info));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->locreloff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->locreloff + imageOffset, dysymtab_command->nlocrel * sizeof(struct relocation_info));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtabRange.length > 0)\n    {\n      dysymtabNode = [self createDataNode:rootNode\n                                  caption:@\"Dynamic Symbol Table\"\n                                 location:dysymtabRange.location\n                                   length:dysymtabRange.length];\n    }\n  }\n  \n  if (twolevel_hints_command)\n  {\n    twoLevelHintsNode = [self createDataNode:rootNode \n                                     caption:@\"Two Level Hints Table\"\n                                    location:twolevel_hints_command->offset + imageOffset\n                                      length:twolevel_hints_command->nhints * sizeof(struct twolevel_hint)];\n  }\n\n  if (segment_split_info)\n  {\n    segmentSplitInfoNode = [self createDataNode:rootNode \n                                        caption:@\"Segment Split Info\"\n                                       location:segment_split_info->dataoff + imageOffset\n                                         length:segment_split_info->datasize];\n  }\n  \n  if (code_signature)\n  {\n    [self createDataNode:rootNode \n                 caption:@\"Code Signature\"\n                location:code_signature->dataoff + imageOffset\n                  length:code_signature->datasize];\n  }\n  \n  if (function_starts)\n  {\n    functionStartsNode = [self createDataNode:rootNode \n                                      caption:@\"Function Starts\"\n                                     location:function_starts->dataoff + imageOffset\n                                       length:function_starts->datasize];\n  }\n  \n  if (data_in_code_entries)\n  {\n    dataInCodeEntriesNode = [self createDataNode:rootNode\n                                         caption:@\"Data in Code Entries\"\n                                        location:data_in_code_entries->dataoff + imageOffset\n                                          length:data_in_code_entries->datasize];\n  }\n  \n  //============ Symbol Table ====================\n  //==============================================\n  if (symtabNode)\n  {\n    @try\n    {\n      [self createSymbolsNode:symtabNode\n                      caption:(lastNodeCaption = @\"Symbols\")\n                     location:symtabNode.dataRange.location\n                       length:symtabNode.dataRange.length];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  \n  //=========== Dynamic Symbol Table =============\n  //==============================================\n  if (dysymtabNode)\n  {\n    @try\n    {\n      //=============== Module Table =================\n      //==============================================\n      if (dysymtab_command->modtaboff * dysymtab_command->nmodtab > 0)\n      {\n        [self createModulesNode:dysymtabNode \n                        caption:(lastNodeCaption = @\"Modules\")\n                       location:dysymtab_command->modtaboff + imageOffset\n                         length:dysymtab_command->nmodtab * sizeof(struct dylib_module)];\n      }\n\n      //========== Table of Contents =================\n      //==============================================\n      if (dysymtab_command->tocoff * dysymtab_command->ntoc > 0)\n      {\n        [self createTOCNode:dysymtabNode \n                    caption:(lastNodeCaption = @\"Table of Contents\")\n                   location:dysymtab_command->tocoff + imageOffset \n                     length:dysymtab_command->ntoc * sizeof(struct dylib_table_of_contents)];\n      }\n\n      //======= External Reference Table =============\n      //==============================================\n      if (dysymtab_command->extrefsymoff * dysymtab_command->nextrefsyms > 0)\n      {\n        [self createReferencesNode:dysymtabNode \n                           caption:(lastNodeCaption = @\"External References\")\n                          location:dysymtab_command->extrefsymoff + imageOffset\n                            length:dysymtab_command->nextrefsyms * sizeof(struct dylib_reference)];\n      }\n\n      //========== Indirect Symbol Table =============\n      //==============================================\n      if (dysymtab_command->indirectsymoff * dysymtab_command->nindirectsyms > 0)\n      {\n        [self createISymbolsNode:dysymtabNode\n                         caption:(lastNodeCaption = @\"Indirect Symbols\")\n                        location:dysymtab_command->indirectsymoff + imageOffset\n                          length:dysymtab_command->nindirectsyms * sizeof(uint32_t)];\n      }\n\n      //========== External Reloc Table ==============\n      //==============================================\n      if (dysymtab_command->extreloff * dysymtab_command->nextrel > 0)\n      {\n        [self createRelocNode:dysymtabNode \n                      caption:(lastNodeCaption = @\"External Relocations\")\n                     location:dysymtab_command->extreloff + imageOffset\n                       length:dysymtab_command->nextrel * sizeof(struct relocation_info)\n                  baseAddress:(mach_header->flags & MH_SPLIT_SEGS) == MH_SPLIT_SEGS ? segs_read_write_addr : seg1addr];\n      }\n\n      //=========== Local Reloc Table ================\n      //==============================================\n      if (dysymtab_command->locreloff * dysymtab_command->nlocrel > 0)\n      {\n        [self createRelocNode:dysymtabNode \n                      caption:(lastNodeCaption = @\"Local Relocations\")\n                     location:dysymtab_command->locreloff + imageOffset\n                       length:dysymtab_command->nlocrel * sizeof(struct relocation_info)\n                  baseAddress:(mach_header->flags & MH_SPLIT_SEGS) == MH_SPLIT_SEGS ? segs_read_write_addr : seg1addr];\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  if (twoLevelHintsNode && twoLevelHintsNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createTwoLevelHintsNode:twoLevelHintsNode \n                            caption:(lastNodeCaption = @\"Hints\") \n                           location:twoLevelHintsNode.dataRange.location\n                             length:twoLevelHintsNode.dataRange.length\n                              index:dysymtab_command->iundefsym];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n\n  if (segmentSplitInfoNode && segmentSplitInfoNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createSplitSegmentNode:segmentSplitInfoNode \n                           caption:(lastNodeCaption = @\"Shared Region Info\")\n                          location:segmentSplitInfoNode.dataRange.location\n                            length:segmentSplitInfoNode.dataRange.length\n                       baseAddress:base_addr];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  if (functionStartsNode && functionStartsNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createFunctionStartsNode:functionStartsNode \n                             caption:(lastNodeCaption = @\"Functions\")  \n                            location:functionStartsNode.dataRange.location \n                              length:functionStartsNode.dataRange.length\n                         baseAddress:base_addr];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  if (dataInCodeEntriesNode && dataInCodeEntriesNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createDataInCodeEntriesNode:dataInCodeEntriesNode\n                                caption:(lastNodeCaption = @\"Dices\")\n                               location:dataInCodeEntriesNode.dataRange.location\n                                 length:dataInCodeEntriesNode.dataRange.length];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n-(void) processLinkEdit64\n{\n  // find related load commands\n  struct symtab_command const * symtab_command = NULL;\n  struct dysymtab_command const * dysymtab_command = NULL;\n  struct twolevel_hints_command const * twolevel_hints_command = NULL;\n  struct linkedit_data_command const * segment_split_info = NULL;\n  struct linkedit_data_command const * code_signature = NULL;\n  struct linkedit_data_command const * function_starts = NULL;\n  struct linkedit_data_command const * data_in_code_entries = NULL;\n  \n  MATCH_STRUCT(mach_header_64,imageOffset);\n  \n  uint64_t base_addr;\n  uint64_t seg1addr = (uint64_t)-1LL;\n  uint64_t segs_read_write_addr = (uint64_t)-1LL;\n  \n  for (CommandVector::const_iterator cmdIter = commands.begin(); cmdIter != commands.end(); ++cmdIter)\n  {\n    struct load_command const * load_command = *cmdIter;\n    switch (load_command->cmd)\n    {\n      case LC_SEGMENT_64:     \n      {\n        struct segment_command_64 const * segment_command_64 = (struct segment_command_64 const *)load_command;\n        \n        if (segment_command_64->fileoff == 0 && segment_command_64->filesize != 0)\n        {\n\t\t\t\t\tbase_addr = segment_command_64->vmaddr;\n        }\n        \n        if(segment_command_64->vmaddr < seg1addr)\n        {\n          seg1addr = segment_command_64->vmaddr;\n        }\n        \n        // Pickup the address of the first read-write segment for MH_SPLIT_SEGS images.\n        if((segment_command_64->initprot & VM_PROT_WRITE) == VM_PROT_WRITE &&\n           segment_command_64->vmaddr < segs_read_write_addr)\n        {\n          segs_read_write_addr = segment_command_64->vmaddr;\n        }\n      } break;\n      case LC_SYMTAB: symtab_command = (struct symtab_command const *)load_command; break;\n      case LC_DYSYMTAB: dysymtab_command = (struct dysymtab_command const *)load_command; break;\n      case LC_TWOLEVEL_HINTS: twolevel_hints_command = (struct twolevel_hints_command const *)load_command; break;\n      case LC_SEGMENT_SPLIT_INFO: segment_split_info = (struct linkedit_data_command const *)load_command; break;\n      case LC_CODE_SIGNATURE: code_signature = (struct linkedit_data_command const *)load_command; break;\n      case LC_FUNCTION_STARTS: function_starts = (struct linkedit_data_command const *)load_command; break;\n      case LC_DATA_IN_CODE: data_in_code_entries = (struct linkedit_data_command const *)load_command; break;\n      default: ; // not interested\n    }\n  }\n\n  MVNode * symtabNode = nil;\n  MVNode * dysymtabNode = nil;\n  MVNode * twoLevelHintsNode = nil;\n  MVNode * segmentSplitInfoNode = nil;\n  MVNode * functionStartsNode = nil;\n  MVNode * dataInCodeEntriesNode = nil;\n\n  NSString * lastNodeCaption;\n  \n  if (symtab_command)\n  {\n    symtabNode = [self createDataNode:rootNode\n                              caption:@\"Symbol Table\"\n                             location:symtab_command->symoff + imageOffset\n                               length:symtab_command->nsyms * sizeof(struct nlist_64)];\n    \n    [self createDataNode:rootNode \n                 caption:@\"String Table\"\n                location:symtab_command->stroff + imageOffset\n                  length:symtab_command->strsize];\n  }\n  \n  if (dysymtab_command)\n  {\n    NSRange dysymtabRange = NSMakeRange(0,0);\n    if (dysymtab_command->tocoff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->tocoff + imageOffset, dysymtab_command->ntoc * sizeof(struct dylib_table_of_contents));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->modtaboff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->modtaboff + imageOffset, dysymtab_command->nmodtab * sizeof(struct dylib_module_64));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->extrefsymoff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->extrefsymoff + imageOffset, dysymtab_command->nextrefsyms * sizeof(struct dylib_reference));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->indirectsymoff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->indirectsymoff + imageOffset, dysymtab_command->nindirectsyms * sizeof(uint32_t));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->extreloff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->extreloff + imageOffset, dysymtab_command->nextrel * sizeof(struct relocation_info));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtab_command->locreloff > 0)\n    {\n      NSRange range = NSMakeRange(dysymtab_command->locreloff + imageOffset, dysymtab_command->nlocrel * sizeof(struct relocation_info));\n      dysymtabRange = NSMaxRange(dysymtabRange) > 0 ? NSUnionRange(dysymtabRange, range) : range;\n    }\n    if (dysymtabRange.length > 0)\n    {\n      dysymtabNode = [self createDataNode:rootNode\n                                  caption:@\"Dynamic Symbol Table\"\n                                 location:dysymtabRange.location\n                                   length:dysymtabRange.length];\n    }\n  }\n  \n  if (twolevel_hints_command)\n  {\n    twoLevelHintsNode = [self createDataNode:rootNode \n                                     caption:@\"Two Level Hints Table\"\n                                    location:twolevel_hints_command->offset + imageOffset\n                                      length:twolevel_hints_command->nhints * sizeof(struct twolevel_hint)];\n  }\n  \n  if (segment_split_info)\n  {\n    segmentSplitInfoNode = [self createDataNode:rootNode \n                                        caption:@\"Segment Split Info\"\n                                       location:segment_split_info->dataoff + imageOffset\n                                         length:segment_split_info->datasize];\n  }\n\n  if (code_signature)\n  {\n    [self createDataNode:rootNode \n                 caption:@\"Code Signature\"\n                location:code_signature->dataoff + imageOffset\n                  length:code_signature->datasize];\n  }\n\n  if (function_starts)\n  {\n    functionStartsNode = [self createDataNode:rootNode \n                                      caption:@\"Function Starts\"\n                                     location:function_starts->dataoff + imageOffset\n                                       length:function_starts->datasize];\n  }\n\n  if (data_in_code_entries)\n  {\n    dataInCodeEntriesNode = [self createDataNode:rootNode\n                                         caption:@\"Data in Code Entries\"\n                                        location:data_in_code_entries->dataoff + imageOffset\n                                          length:data_in_code_entries->datasize];\n  }\n  \n  //============ Symbol Table ====================\n  //==============================================\n  if (symtabNode)\n  {\n    @try\n    {\n      [self createSymbols64Node:symtabNode\n                        caption:(lastNodeCaption = @\"Symbols\")\n                       location:symtabNode.dataRange.location\n                         length:symtabNode.dataRange.length];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n\n  //=========== Dynamic Symbol Table =============\n  //==============================================\n  if (dysymtabNode)\n  {\n    @try\n    {\n      //=============== Module Table =================\n      //==============================================\n      if (dysymtab_command->modtaboff * dysymtab_command->nmodtab > 0)\n      {\n        [self createModules64Node:dysymtabNode \n                          caption:(lastNodeCaption = @\"Modules64\")\n                         location:dysymtab_command->modtaboff + imageOffset\n                           length:dysymtab_command->nmodtab * sizeof(struct dylib_module_64)];\n      }  \n\n      //========== Table of Contents =================\n      //==============================================\n      if (dysymtab_command->tocoff * dysymtab_command->ntoc > 0)\n      {\n        [self createTOC64Node:dysymtabNode \n                      caption:(lastNodeCaption = @\"Table of Contents\")\n                     location:dysymtab_command->tocoff + imageOffset \n                       length:dysymtab_command->ntoc * sizeof(struct dylib_table_of_contents)];\n      }\n\n      //======= External Reference Table =============\n      //==============================================\n      if (dysymtab_command->extrefsymoff * dysymtab_command->nextrefsyms > 0)\n      {\n        [self createReferencesNode:dysymtabNode \n                           caption:(lastNodeCaption = @\"External References\")\n                          location:dysymtab_command->extrefsymoff + imageOffset\n                            length:dysymtab_command->nextrefsyms * sizeof(struct dylib_reference)];\n      }\n\n      //========== Indirect Symbol Table =============\n      //==============================================\n      if (dysymtab_command->indirectsymoff * dysymtab_command->nindirectsyms > 0)\n      {\n        [self createISymbols64Node:dysymtabNode\n                           caption:(lastNodeCaption = @\"Indirect Symbols\")\n                          location:dysymtab_command->indirectsymoff + imageOffset\n                            length:dysymtab_command->nindirectsyms * sizeof(uint32_t)];\n      }\n\n      //========== External Reloc Table ==============\n      //==============================================\n      if (dysymtab_command->extreloff * dysymtab_command->nextrel > 0)\n      {\n        [self createReloc64Node:dysymtabNode \n                        caption:(lastNodeCaption = @\"External Relocations\")\n                       location:dysymtab_command->extreloff + imageOffset\n                         length:dysymtab_command->nextrel * sizeof(struct relocation_info)\n                    baseAddress:(mach_header_64->flags & MH_SPLIT_SEGS) == MH_SPLIT_SEGS ? segs_read_write_addr : seg1addr];\n      }\n\n      //=========== Local Reloc Table ================\n      //==============================================\n      if (dysymtab_command->locreloff * dysymtab_command->nlocrel > 0)\n      {\n        [self createReloc64Node:dysymtabNode \n                        caption:(lastNodeCaption = @\"Local Reloc Table\")\n                       location:dysymtab_command->locreloff + imageOffset\n                         length:dysymtab_command->nlocrel * sizeof(struct relocation_info)\n                    baseAddress:(mach_header_64->flags & MH_SPLIT_SEGS) == MH_SPLIT_SEGS ? segs_read_write_addr : seg1addr];\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  if (twoLevelHintsNode && twoLevelHintsNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createTwoLevelHintsNode:twoLevelHintsNode \n                            caption:(lastNodeCaption = @\"Hints\") \n                           location:twoLevelHintsNode.dataRange.location\n                             length:twoLevelHintsNode.dataRange.length\n                              index:dysymtab_command->iundefsym];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  if (segmentSplitInfoNode && segmentSplitInfoNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createSplitSegmentNode:segmentSplitInfoNode \n                           caption:(lastNodeCaption = @\"Shared Region Info\") \n                          location:segmentSplitInfoNode.dataRange.location\n                            length:segmentSplitInfoNode.dataRange.length\n                       baseAddress:base_addr];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }  \n  \n  if (functionStartsNode && functionStartsNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createFunctionStartsNode:functionStartsNode \n                             caption:(lastNodeCaption = @\"Functions\")  \n                            location:functionStartsNode.dataRange.location \n                              length:functionStartsNode.dataRange.length\n                         baseAddress:base_addr];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  if (dataInCodeEntriesNode && dataInCodeEntriesNode.dataRange.length > 0)\n  {\n    @try\n    {\n      [self createDataInCodeEntriesNode:dataInCodeEntriesNode\n                                caption:(lastNodeCaption = @\"Dices\")\n                               location:dataInCodeEntriesNode.dataRange.location\n                                 length:dataInCodeEntriesNode.dataRange.length];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n-(void)processDyldInfo\n{\n  uint64_t base_addr = 0;\n  \n  // find related load commands\n  struct dyld_info_command const * dyld_info_command = NULL;\n  \n  for (CommandVector::const_iterator cmdIter = commands.begin(); cmdIter != commands.end(); ++cmdIter)\n  {\n    struct load_command const * load_command = *cmdIter;\n    switch (load_command->cmd)\n    {\n      case LC_SEGMENT:     \n      {\n        struct segment_command const * segment_command = (struct segment_command const *)load_command;\n        if (segment_command->fileoff == 0 && segment_command->filesize != 0)\n        {\n\t\t\t\t\tbase_addr = segment_command->vmaddr;\n        }\n      } break;\n\n      case LC_SEGMENT_64:     \n      {\n        struct segment_command_64 const * segment_command_64 = (struct segment_command_64 const *)load_command;\n        if (segment_command_64->fileoff == 0 && segment_command_64->filesize != 0)\n        {\n\t\t\t\t\tbase_addr = segment_command_64->vmaddr;\n        }\n      } break;\n      case LC_DYLD_INFO:\n      case LC_DYLD_INFO_ONLY: dyld_info_command = (struct dyld_info_command const *)load_command; break;\n      default: ; // not interested\n    }\n  }\n  \n  if (dyld_info_command == NULL)\n  {\n    return;\n  }\n  \n  NSRange dyldInfoRange = NSMakeRange(0,0);\n  if (dyld_info_command->rebase_off > 0)\n  {\n    NSRange range = NSMakeRange(dyld_info_command->rebase_off + imageOffset, dyld_info_command->rebase_size);\n    dyldInfoRange = NSMaxRange(dyldInfoRange) > 0 ? NSUnionRange(dyldInfoRange, range) : range;\n  }\n  if (dyld_info_command->bind_off > 0)\n  {\n    NSRange range = NSMakeRange(dyld_info_command->bind_off + imageOffset, dyld_info_command->bind_size);\n    dyldInfoRange = NSMaxRange(dyldInfoRange) > 0 ? NSUnionRange(dyldInfoRange, range) : range;\n  }\n  if (dyld_info_command->weak_bind_off > 0)\n  {\n    NSRange range = NSMakeRange(dyld_info_command->weak_bind_off + imageOffset, dyld_info_command->weak_bind_size);\n    dyldInfoRange = NSMaxRange(dyldInfoRange) > 0 ? NSUnionRange(dyldInfoRange, range) : range;\n  }\n  if (dyld_info_command->lazy_bind_off > 0)\n  {\n    NSRange range = NSMakeRange(dyld_info_command->lazy_bind_off + imageOffset, dyld_info_command->lazy_bind_size);\n    dyldInfoRange = NSMaxRange(dyldInfoRange) > 0 ? NSUnionRange(dyldInfoRange, range) : range;\n  }\n  if (dyld_info_command->export_off > 0)\n  {\n    NSRange range = NSMakeRange(dyld_info_command->export_off + imageOffset, dyld_info_command->export_size);\n    dyldInfoRange = NSMaxRange(dyldInfoRange) > 0 ? NSUnionRange(dyldInfoRange, range) : range;\n  }\n  MVNode * dyldInfoNode = [self createDataNode:rootNode\n                                       caption:@\"Dynamic Loader Info\"\n                                      location:dyldInfoRange.location\n                                        length:dyldInfoRange.length];\n  \n  DyldHelper * dyldHelper = [DyldHelper dyldHelperWithSymbols:symbolNames is64Bit:[self is64bit]];\n  \n  NSString * lastNodeCaption;\n  @try \n  {\n    if (dyld_info_command->rebase_off * dyld_info_command->rebase_size > 0)\n    {\n      [self createRebaseNode:dyldInfoNode\n                     caption:(lastNodeCaption = @\"Rebase Info\")\n                    location:dyld_info_command->rebase_off + imageOffset\n                      length:dyld_info_command->rebase_size\n                 baseAddress:base_addr];\n    }\n\n    if (dyld_info_command->bind_off * dyld_info_command->bind_size > 0)\n    {\n      [self createBindingNode:dyldInfoNode\n                      caption:(lastNodeCaption = @\"Binding Info\")\n                     location:dyld_info_command->bind_off + imageOffset\n                       length:dyld_info_command->bind_size\n                  baseAddress:base_addr\n                     nodeType:NodeTypeBind\n                   dyldHelper:dyldHelper];\n    }\n\n    if (dyld_info_command->weak_bind_off * dyld_info_command->weak_bind_size > 0)\n    {\n      [self createBindingNode:dyldInfoNode\n                      caption:(lastNodeCaption = @\"Weak Binding Info\")\n                     location:dyld_info_command->weak_bind_off + imageOffset\n                       length:dyld_info_command->weak_bind_size\n                  baseAddress:base_addr\n                     nodeType:NodeTypeWeakBind\n                   dyldHelper:dyldHelper];\n    }\n\n    if (dyld_info_command->lazy_bind_off * dyld_info_command->lazy_bind_size > 0)\n    {\n      [self createBindingNode:dyldInfoNode\n                      caption:(lastNodeCaption = @\"Lazy Binding Info\")\n                     location:dyld_info_command->lazy_bind_off + imageOffset\n                       length:dyld_info_command->lazy_bind_size\n                  baseAddress:base_addr\n                     nodeType:NodeTypeLazyBind\n                   dyldHelper:dyldHelper];\n    }\n    \n    if (dyld_info_command->export_off * dyld_info_command->export_size > 0)\n    {\n      [self createExportNode:dyldInfoNode\n                     caption:(lastNodeCaption = @\"Export Info\")\n                    location:dyld_info_command->export_off + imageOffset\n                      length:dyld_info_command->export_size\n                 baseAddress:base_addr];\n    }\n  }\n  @catch(NSException * exception)\n  {\n    [self printException:exception caption:lastNodeCaption];\n  }\n  \n}\n\n//-----------------------------------------------------------------------------\ntemplate <typename SectionT>\nstruct CompareSectionByName\n{\n  CompareSectionByName(char const * segname, char const * sectname) \n    : segname(segname)\n    , sectname(sectname) \n  {\n  }\n\n  CompareSectionByName(char const * sectname) \n    : segname(NULL)\n    , sectname(sectname) \n  {\n  }\n  \n  bool operator() (SectionT const * section)\n  {\n    return ((segname == NULL || strncmp(segname,section->segname,16) == 0) && \n                                strncmp(sectname,section->sectname,16) == 0);\n  }\n  \n  char const * segname;\n  char const * sectname;\n};\n\n//-----------------------------------------------------------------------------\n-(void)processSections\n{\n  NSString * lastNodeCaption;\n  \n  //================ sections with literal content ============================\n  for (SectionVector::const_iterator sectIter = ++sections.begin(); sectIter != sections.end(); ++sectIter)\n  {\n    struct section const * section = *sectIter;\n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]];\n    if (sectionNode == nil)\n    {\n      continue;\n    }\n    \n    @try\n    {\n      switch (section->flags & SECTION_TYPE)\n      {\n        case S_CSTRING_LITERALS: \n          [self createCStringsNode:sectionNode \n                           caption:(lastNodeCaption = @\"C String Literals\")\n                          location:section->offset + imageOffset\n                            length:section->size]; break;\n      \n        case S_4BYTE_LITERALS:\n          [self createLiteralsNode:sectionNode \n                           caption:(lastNodeCaption = @\"Floating Point Literals\")\n                          location:section->offset + imageOffset\n                            length:section->size\n                            stride:4]; break;\n          \n        case S_8BYTE_LITERALS:\n          [self createLiteralsNode:sectionNode \n                           caption:(lastNodeCaption = @\"Floating Point Literals\")\n                          location:section->offset + imageOffset\n                            length:section->size\n                            stride:8]; break;\n\n        case S_16BYTE_LITERALS:\n          [self createLiteralsNode:sectionNode \n                           caption:(lastNodeCaption = @\"Floating Point Literals\")\n                          location:section->offset + imageOffset\n                            length:section->size\n                            stride:16]; break;\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n\n  //================ sections with pointer content ============================\n  for (SectionVector::const_iterator sectIter = ++sections.begin(); sectIter != sections.end(); ++sectIter)\n  {\n    struct section const * section = *sectIter;\n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]];\n    if (sectionNode == nil)\n    {\n      continue;\n    }\n    \n    @try \n    {\n      switch (section->flags & SECTION_TYPE)\n      {\n        case S_LITERAL_POINTERS:\n          [self createPointersNode:sectionNode \n                           caption:(lastNodeCaption = @\"Literal Pointers\")\n                          location:section->offset + imageOffset\n                            length:section->size]; break;\n\n        case S_MOD_INIT_FUNC_POINTERS:\n          [self createPointersNode:sectionNode \n                           caption:(lastNodeCaption = @\"Module Init Func Pointers\") \n                          location:section->offset + imageOffset\n                            length:section->size]; break;\n\n        case S_MOD_TERM_FUNC_POINTERS:\n          [self createPointersNode:sectionNode \n                           caption:(lastNodeCaption = @\"Module Term Func Pointers\") \n                          location:section->offset + imageOffset\n                            length:section->size]; break;\n\n        case S_LAZY_SYMBOL_POINTERS:\n          [self createIndPointersNode:sectionNode \n                              caption:(lastNodeCaption = @\"Lazy Symbol Pointers\")\n                             location:section->offset + imageOffset\n                               length:section->size]; break;\n\n        case S_NON_LAZY_SYMBOL_POINTERS:\n          [self createIndPointersNode:sectionNode \n                              caption:(lastNodeCaption = @\"Non-Lazy Symbol Pointers\")\n                             location:section->offset + imageOffset\n                               length:section->size]; break;\n\n        case S_LAZY_DYLIB_SYMBOL_POINTERS:\n          [self createIndPointersNode:sectionNode \n                              caption:(lastNodeCaption = @\"Lazy Dylib Symbol Pointers\")\n                             location:section->offset + imageOffset\n                               length:section->size]; break;\n\n        case S_SYMBOL_STUBS:\n          [self createIndStubsNode:sectionNode \n                           caption:(lastNodeCaption = @\"Symbol Stubs\")\n                          location:section->offset + imageOffset\n                            length:section->size\n                            stride:section->reserved2]; break;\n       \n        default:;\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n}\n\n//-----------------------------------------------------------------------------\n-(void)processSections64\n{\n  NSString * lastNodeCaption;\n\n  //================ sections with literal content ============================\n  for (Section64Vector::const_iterator sectIter = ++sections_64.begin(); sectIter != sections_64.end(); ++sectIter)\n  {\n    struct section_64 const * section_64 = *sectIter;\n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]];\n    if (sectionNode == nil)\n    {\n      continue;\n    }\n    \n    @try\n    {\n      switch (section_64->flags & SECTION_TYPE)\n      {\n        case S_CSTRING_LITERALS: \n          [self createCStringsNode:sectionNode \n                           caption:(lastNodeCaption = @\"C String Literals\")\n                          location:section_64->offset + imageOffset\n                            length:section_64->size]; break;\n          \n        case S_4BYTE_LITERALS:\n          [self createLiteralsNode:sectionNode \n                           caption:(lastNodeCaption = @\"Floating Point Literals\")\n                          location:section_64->offset + imageOffset\n                            length:section_64->size\n                            stride:4]; break;\n          \n        case S_8BYTE_LITERALS:\n          [self createLiteralsNode:sectionNode \n                           caption:(lastNodeCaption = @\"Floating Point Literals\")\n                          location:section_64->offset + imageOffset\n                            length:section_64->size\n                            stride:8]; break;\n          \n        case S_16BYTE_LITERALS:\n          [self createLiteralsNode:sectionNode \n                           caption:(lastNodeCaption = @\"Floating Point Literals\")\n                          location:section_64->offset + imageOffset\n                            length:section_64->size\n                            stride:16]; break;\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n    \n  //================ sections with pointer content ============================\n  for (Section64Vector::const_iterator sectIter = ++sections_64.begin(); sectIter != sections_64.end(); ++sectIter)\n  {\n    struct section_64 const * section_64 = *sectIter;\n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]];\n    if (sectionNode == nil)\n    {\n      continue;\n    }\n    \n    @try \n    {\n      switch (section_64->flags & SECTION_TYPE)\n      {\n        case S_LITERAL_POINTERS:\n          [self createPointers64Node:sectionNode \n                             caption:(lastNodeCaption = @\"Literal Pointers\")\n                            location:section_64->offset + imageOffset\n                              length:section_64->size]; break;\n          \n        case S_MOD_INIT_FUNC_POINTERS:\n          [self createPointers64Node:sectionNode \n                             caption:(lastNodeCaption = @\"Module Init Func Pointers\") \n                            location:section_64->offset + imageOffset\n                              length:section_64->size]; break;\n          \n        case S_MOD_TERM_FUNC_POINTERS:\n          [self createPointers64Node:sectionNode \n                             caption:(lastNodeCaption = @\"Module Term Func Pointers\") \n                            location:section_64->offset + imageOffset\n                              length:section_64->size]; break;\n          \n        case S_LAZY_SYMBOL_POINTERS:\n          [self createIndPointers64Node:sectionNode \n                                caption:(lastNodeCaption = @\"Lazy Symbol Pointers\")\n                               location:section_64->offset + imageOffset\n                                 length:section_64->size]; break;\n          \n        case S_NON_LAZY_SYMBOL_POINTERS:\n          [self createIndPointers64Node:sectionNode \n                                caption:(lastNodeCaption = @\"Non-Lazy Symbol Pointers\")\n                               location:section_64->offset + imageOffset\n                                 length:section_64->size]; break;\n          \n        case S_LAZY_DYLIB_SYMBOL_POINTERS:\n          [self createIndPointers64Node:sectionNode \n                                caption:(lastNodeCaption = @\"Lazy Dylib Symbol Pointers\")\n                               location:section_64->offset + imageOffset\n                                 length:section_64->size]; break;\n          \n        case S_SYMBOL_STUBS:\n          [self createIndStubs64Node:sectionNode \n                             caption:(lastNodeCaption = @\"Symbol Stubs\")\n                            location:section_64->offset + imageOffset\n                              length:section_64->size\n                              stride:section_64->reserved2]; break;\n          \n        default:;\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n}\n\n//-----------------------------------------------------------------------------\n-(void)processEHFrames\n{\n  // dylib stubs have no section\n  if ([self isDylibStub] == YES)\n  {\n    return;\n  }\n  \n  NSString * lastNodeCaption;\n  \n  for (SectionVector::iterator sectIter = find_if(++sections.begin(), sections.end(), CompareSectionByName<struct section>(\"__eh_frame\"));\n       sectIter != sections.end();\n       sectIter = find_if(++sectIter, sections.end(), CompareSectionByName<struct section>(\"__eh_frame\")))\n  {\n    struct section const * section = *sectIter;\n    \n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]];\n    // there is no valid exception data\n    if (sectionNode == nil) \n    {\n      return;\n    }\n    \n    /* The .eh_frame section shall contain 1 or more Call Frame Information (CFI) records. \n     * The number of records present shall be determined by size of the section as contained in the section header.\n     * Each CFI record contains a Common Information Entry (CIE) record followed by 1 or more Frame Description Entry (FDE) records. \n     * Both CIEs and FDEs shall be aligned to an addressing unit sized boundary.\n     */\n    \n    @try\n    {\n      uint64_t location = section->offset + imageOffset;\n      do\n      {\n        NSRange range = NSMakeRange(location,0);\n        uint32_t length = [dataController read_uint32:range];\n        uint32_t cieID = [dataController read_uint32:range];\n        \n        if (cieID == 0)\n        {\n          uint64_t CIE_addr = [self fileOffsetToRVA:location];\n          [self createCFINode:sectionNode\n                      caption:(lastNodeCaption = [NSString stringWithFormat:@\"Call Frame %@\", [self findSymbolAtRVA:CIE_addr]])\n                     location:location\n                       length:section->offset + imageOffset + section->size - location];  // upper bound\n        }\n        location += length + /*length itself */ sizeof(uint32_t);\n      } while (location - section->offset - imageOffset < section->size);\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n-(void)processEHFrames64\n{\n  // dylib stubs have no section\n  if ([self isDylibStub] == YES)\n  {\n    return;\n  }\n  \n  NSString * lastNodeCaption;\n  \n  for (Section64Vector::iterator sectIter = find_if(++sections_64.begin(), sections_64.end(), CompareSectionByName<struct section_64>(\"__eh_frame\"));\n       sectIter != sections_64.end();\n       sectIter = find_if(++sectIter, sections_64.end(), CompareSectionByName<struct section_64>(\"__eh_frame\")))\n  {\n    struct section_64 const * section_64 = *sectIter;\n    \n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]];\n    // there is no valid exception data\n    if (sectionNode == nil) \n    {\n      return;\n    }\n    \n    /* The .eh_frame section shall contain 1 or more Call Frame Information (CFI) records. \n     * The number of records present shall be determined by size of the section as contained in the section header.\n     * Each CFI record contains a Common Information Entry (CIE) record followed by 1 or more Frame Description Entry (FDE) records. \n     * Both CIEs and FDEs shall be aligned to an addressing unit sized boundary.\n     */\n    \n    @try\n    {\n      uint64_t location = section_64->offset + imageOffset;\n      do\n      {\n        NSRange range = NSMakeRange(location,0);\n        uint32_t length = [dataController read_uint32:range];\n        uint32_t cieID = [dataController read_uint32:range];\n        \n        if (cieID == 0)\n        {\n          uint64_t CIE_addr = [self fileOffsetToRVA:location];\n          [self createCFINode:sectionNode\n                      caption:(lastNodeCaption = [NSString stringWithFormat:@\"Call Frame %@\", [self findSymbolAtRVA:CIE_addr]])\n                     location:location\n                       length:section_64->offset + imageOffset + section_64->size - location]; // upper bound\n        }\n        location += length + /*length itself */ sizeof(uint32_t);\n      } while (location - section_64->offset - imageOffset < section_64->size);\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n-(void)processLSDA\n{\n  // dylib stubs have no section\n  if ([self isDylibStub] == YES)\n  {\n    return;\n  }\n  \n  NSString * lastNodeCaption;\n  \n  for (SectionVector::iterator sectIter = find_if(++sections.begin(), sections.end(), CompareSectionByName<struct section>(\"__gcc_except_tab\"));\n       sectIter != sections.end();\n       sectIter = find_if(++sectIter, sections.end(), CompareSectionByName<struct section>(\"__gcc_except_tab\")))\n  {\n    struct section const * section = *sectIter;\n    \n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]];\n    NSParameterAssert(sectionNode != nil);\n    if (sectionNode == nil)\n    { \n      return;\n    }\n    \n    @try \n    {\n      for (ExceptionFrameMap::iterator ehFrameIter = lsdaInfo.begin(); ehFrameIter != lsdaInfo.end();)\n      {\n        uint64_t lsdaAddr = ehFrameIter->first;\n        uint64_t frameAddr = ehFrameIter->second;\n        \n        uint64_t location = [self RVAToFileOffset:lsdaAddr];\n        \n        uint64_t length = (++ehFrameIter != lsdaInfo.end()\n                           ? [self RVAToFileOffset:ehFrameIter->first]\n                           : imageOffset + section->offset + section->size) - location;\n        \n        [self createLSDANode:sectionNode \n                     caption:(lastNodeCaption = [NSString stringWithFormat:@\"LSDA %@\",[self findSymbolAtRVA:lsdaAddr]])\n                    location:location\n                      length:length\n              eh_frame_begin:frameAddr];\n      }\n    }      \n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n-(void)processLSDA64\n{\n  // dylib stubs have no section\n  if ([self isDylibStub] == YES)\n  {\n    return;\n  }\n  \n  NSString * lastNodeCaption;\n  \n  for (Section64Vector::iterator sectIter = find_if(++sections_64.begin(), sections_64.end(), CompareSectionByName<struct section_64>(\"__gcc_except_tab\"));\n       sectIter != sections_64.end();\n       sectIter = find_if(++sectIter, sections_64.end(), CompareSectionByName<struct section_64>(\"__gcc_except_tab\")))\n  {\n    struct section_64 const * section_64 = *sectIter;\n    \n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]];\n    NSParameterAssert(sectionNode != nil);\n    if (sectionNode == nil)\n    {\n      return;\n    }\n    \n    @try \n    {\n      for (ExceptionFrameMap::iterator ehFrameIter = lsdaInfo.begin(); ehFrameIter != lsdaInfo.end();)\n      {\n        uint64_t lsdaAddr = ehFrameIter->first;\n        uint64_t frameAddr = ehFrameIter->second;\n        \n        uint64_t location = [self RVAToFileOffset:lsdaAddr];\n        \n        uint64_t length = (++ehFrameIter != lsdaInfo.end()\n                           ? [self RVAToFileOffset:ehFrameIter->first]\n                           : section_64->offset + section_64->size) - location;\n        \n        [self createLSDANode:sectionNode \n                     caption:(lastNodeCaption = [NSString stringWithFormat:@\"LSDA %@\",[self findSymbolAtRVA:lsdaAddr]])\n                    location:location\n                      length:length\n              eh_frame_begin:frameAddr];\n      }\n    }      \n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n-(void)processObjcSections\n{\n    PointerVector objcClassPointers;\n    PointerVector objcClassReferences;\n    PointerVector objcSuperReferences;\n    PointerVector objcCategoryPointers;\n    PointerVector objcProtocolPointers;\n    \n    NSString * lastNodeCaption;\n    MVNode * sectionNode;\n    struct section const * section;\n    bool hasObjCModules = false; // objC version detector\n    \n    @try\n    {\n        // first Objective-C ABI\n        section = [self findSectionByName:\"__module_info\" andSegment:\"__OBJC\"];\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n            hasObjCModules = true;\n            [self createObjCModulesNode:sectionNode\n                                caption:(lastNodeCaption = @\"ObjC Modules\")\n                               location:section->offset + imageOffset\n                                 length:section->size];\n        }\n        \n        section = [self findSectionByName:\"__class_ext\" andSegment:\"__OBJC\"];\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n            [self createObjCClassExtNode:sectionNode\n                                 caption:(lastNodeCaption = @\"ObjC Class Extensions\")\n                                location:section->offset + imageOffset\n                                  length:section->size];\n        }\n        \n        section = [self findSectionByName:\"__protocol_ext\" andSegment:\"__OBJC\"];\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n            [self createObjCProtocolExtNode:sectionNode\n                                    caption:(lastNodeCaption = @\"ObjC Protocol Extensions\")\n                                   location:section->offset + imageOffset\n                                     length:section->size];\n        }\n        \n        // second Objective-C ABI\n        if (hasObjCModules == false) {\n            section = [self findSectionByName:\"__category_list\" andSegment:\"__OBJC2\"];\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_catlist\" andSegment:\"__DATA_CONST\"];\n            }\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_catlist\" andSegment:\"__DATA\"];\n            }\n            if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n                [self createObjC2PointerListNode:sectionNode\n                                         caption:(lastNodeCaption = @\"ObjC2 Category List\")\n                                        location:section->offset + imageOffset\n                                          length:section->size\n                                        pointers:objcCategoryPointers];\n            }\n            \n            section = [self findSectionByName:\"__class_list\" andSegment:\"__OBJC2\"];\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_classlist\" andSegment:\"__DATA_CONST\"];\n            }\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_classlist\" andSegment:\"__DATA\"];\n            }\n            if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n                [self createObjC2PointerListNode:sectionNode\n                                         caption:(lastNodeCaption = @\"ObjC2 Class List\")\n                                        location:section->offset + imageOffset\n                                          length:section->size\n                                        pointers:objcClassPointers];\n            }\n            \n            section = [self findSectionByName:\"__class_refs\" andSegment:\"__OBJC2\"];\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_classrefs\" andSegment:\"__DATA\"];\n            }\n            if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n                [self createObjC2PointerListNode:sectionNode\n                                         caption:(lastNodeCaption = @\"ObjC2 References\")\n                                        location:section->offset + imageOffset\n                                          length:section->size\n                                        pointers:objcClassReferences];\n            }\n            \n            section = [self findSectionByName:\"__super_refs\" andSegment:\"__OBJC2\"];\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_superrefs\" andSegment:\"__DATA\"];\n            }\n            if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n                [self createObjC2PointerListNode:sectionNode\n                                         caption:(lastNodeCaption = @\"ObjC2 References\")\n                                        location:section->offset + imageOffset\n                                          length:section->size\n                                        pointers:objcSuperReferences];\n            }\n            \n            section = [self findSectionByName:\"__protocol_list\" andSegment:\"__OBJC2\"];\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_protolist\" andSegment:\"__DATA__CONST\"];\n            }\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_protolist\" andSegment:\"__DATA\"];\n            }\n            if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n                [self createObjC2PointerListNode:sectionNode\n                                         caption:(lastNodeCaption = @\"ObjC2 Pointer List\")\n                                        location:section->offset + imageOffset\n                                          length:section->size\n                                        pointers:objcProtocolPointers];\n            }\n            \n            section = [self findSectionByName:\"__message_refs\" andSegment:\"__OBJC2\"];\n            if (section == NULL) {\n                section = [self findSectionByName:\"__objc_msgrefs\" andSegment:\"__DATA\"];\n            }\n            if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n                [self createObjC2MsgRefsNode:sectionNode\n                                     caption:(lastNodeCaption = @\"ObjC2 Message References\")\n                                    location:section->offset + imageOffset\n                                      length:section->size];\n            }\n        } // if (hasObjcModules == false)\n        \n        section = [self findSectionByName:\"__image_info\" andSegment:\"__OBJC\"];\n        if (section == NULL) {\n            section = [self findSectionByName:\"__objc_imageinfo\" andSegment:\"__DATA__CONST\"];\n        }\n        if (section == NULL) {\n            section = [self findSectionByName:\"__objc_imageinfo\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n            [self createObjCImageInfoNode:sectionNode\n                                  caption:(lastNodeCaption = @\"ObjC2 Image Info\")\n                                 location:section->offset + imageOffset\n                                   length:section->size];\n        }\n        \n        section = [self findSectionByName:\"__cfstring\" andSegment:NULL];\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]])) {\n            [self createObjCCFStringsNode:sectionNode\n                                  caption:(lastNodeCaption = @\"ObjC CFStrings\")\n                                 location:section->offset + imageOffset\n                                   length:section->size];\n        }\n    }\n    @catch(NSException * exception)\n    {\n        [self printException:exception caption:lastNodeCaption];\n    }\n    \n    @try\n    {\n        [self parseObjC2ClassPointers:&objcClassPointers\n                     CategoryPointers:&objcCategoryPointers\n                     ProtocolPointers:&objcProtocolPointers];\n    }\n    @catch(NSException * exception)\n    {\n        [self printException:exception caption:lastNodeCaption];\n    }\n}\n\n//-----------------------------------------------------------------------------\n-(void)processObjcSections64\n{\n    Pointer64Vector objcClassPointers;\n    Pointer64Vector objcClassReferences;\n    Pointer64Vector objcSuperReferences;\n    Pointer64Vector objcCategoryPointers;\n    Pointer64Vector objcProtocolPointers;\n    \n    NSString * lastNodeCaption;\n    MVNode * sectionNode;\n    struct section_64 const * section_64;\n    \n    @try\n    {\n        section_64 = [self findSection64ByName:\"__class_list\" andSegment:\"__OBJC2\"];\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_classlist\" andSegment:\"__DATA_CONST\"];\n        }\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_classlist\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjC2Pointer64ListNode:sectionNode\n                                       caption:(lastNodeCaption = @\"ObjC2 Class List\")\n                                      location:section_64->offset + imageOffset\n                                        length:section_64->size\n                                      pointers:objcClassPointers];\n        }\n        \n        section_64 = [self findSection64ByName:\"__class_refs\" andSegment:\"__OBJC2\"];\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_classrefs\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjC2Pointer64ListNode:sectionNode\n                                       caption:(lastNodeCaption = @\"ObjC2 References\")\n                                      location:section_64->offset + imageOffset\n                                        length:section_64->size\n                                      pointers:objcClassReferences];\n        }\n        \n        section_64 = [self findSection64ByName:\"__super_refs\" andSegment:\"__OBJC2\"];\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_superrefs\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjC2Pointer64ListNode:sectionNode\n                                       caption:(lastNodeCaption = @\"ObjC2 References\")\n                                      location:section_64->offset + imageOffset\n                                        length:section_64->size\n                                      pointers:objcSuperReferences];\n        }\n        \n        section_64 = [self findSection64ByName:\"__category_list\" andSegment:\"__OBJC2\"];\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_catlist\" andSegment:\"__DATA_CONST\"];\n        }\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_catlist\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjC2Pointer64ListNode:sectionNode\n                                       caption:(lastNodeCaption = @\"ObjC2 Category List\")\n                                      location:section_64->offset + imageOffset\n                                        length:section_64->size\n                                      pointers:objcCategoryPointers];\n        }\n        \n        section_64 = [self findSection64ByName:\"__protocol_list\" andSegment:\"__OBJC2\"];\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_protolist\" andSegment:\"__DATA_CONST\"];\n        }\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_protolist\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjC2Pointer64ListNode:sectionNode\n                                       caption:(lastNodeCaption = @\"ObjC2 Pointer List\")\n                                      location:section_64->offset + imageOffset\n                                        length:section_64->size\n                                      pointers:objcProtocolPointers];\n        }\n        \n        section_64 = [self findSection64ByName:\"__message_refs\" andSegment:\"__OBJC2\"];\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_msgrefs\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjC2MsgRefs64Node:sectionNode\n                                   caption:(lastNodeCaption = @\"ObjC2 Message References\")\n                                  location:section_64->offset + imageOffset\n                                    length:section_64->size];\n        }\n        \n        section_64 = [self findSection64ByName:\"__image_info\" andSegment:\"__OBJC\"];\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_imageinfo\" andSegment:\"__DATA_CONST\"];\n        }\n        if (section_64 == NULL) {\n            section_64 = [self findSection64ByName:\"__objc_imageinfo\" andSegment:\"__DATA\"];\n        }\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjCImageInfoNode:sectionNode\n                                  caption:(lastNodeCaption = @\"ObjC2 Image Info\")\n                                 location:section_64->offset + imageOffset\n                                   length:section_64->size];\n        }\n        \n        section_64 = [self findSection64ByName:\"__cfstring\" andSegment:NULL];\n        if ((sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]]))\n        {\n            [self createObjCCFStrings64Node:sectionNode\n                                    caption:(lastNodeCaption = @\"ObjC CFStrings\")\n                                   location:section_64->offset + imageOffset\n                                     length:section_64->size];\n        }\n    }\n    @catch(NSException * exception)\n    {\n        [self printException:exception caption:lastNodeCaption];\n    }\n    \n    @try\n    {\n        [self parseObjC2Class64Pointers:&objcClassPointers\n                     Category64Pointers:&objcCategoryPointers\n                     Protocol64Pointers:&objcProtocolPointers];\n    }\n    @catch(NSException * exception)\n    {\n        [self printException:exception caption:lastNodeCaption];\n    }\n}\n\n//-----------------------------------------------------------------------------\n- (void)processCodeSections\n{\n  // find related load commands\n  struct dysymtab_command const * dysymtab_command = NULL;\n  for (CommandVector::const_iterator cmdIter = commands.begin(); cmdIter != commands.end(); ++cmdIter)\n  {\n    struct load_command const * load_command = *cmdIter;\n    switch (load_command->cmd)\n    {\n      case LC_DYSYMTAB: dysymtab_command = (struct dysymtab_command const *)load_command; break;\n      default: ; // not interested\n    }\n  }\n  \n\n  NSString * lastNodeCaption;\n  \n  for (SectionVector::const_iterator sectIter = ++sections.begin(); sectIter != sections.end(); ++sectIter)\n  {\n    struct section const * section = *sectIter;\n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection:section]];\n    if (sectionNode == nil)\n    {\n      continue;\n    }\n    \n    @try \n    {\n      if ((section->flags & S_ATTR_PURE_INSTRUCTIONS) && (section->flags & SECTION_TYPE) != S_SYMBOL_STUBS)\n      {\n        [self createTextNode:sectionNode \n                     caption:(lastNodeCaption = @\"Assembly\") \n                    location:section->offset + imageOffset \n                      length:section->size\n                      reloff:section->reloff + imageOffset\n                      nreloc:section->nreloc\n                   extreloff:dysymtab_command ? dysymtab_command->extreloff : 0\n                     nextrel:dysymtab_command ? dysymtab_command->nextrel : 0\n                   locreloff:dysymtab_command ? dysymtab_command->locreloff : 0\n                     nlocrel:dysymtab_command ? dysymtab_command->nlocrel : 0];\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (void)processCodeSections64\n{\n  // find related load commands\n  struct dysymtab_command const * dysymtab_command = NULL;\n  for (CommandVector::const_iterator cmdIter = commands.begin(); cmdIter != commands.end(); ++cmdIter)\n  {\n    struct load_command const * load_command = *cmdIter;\n    switch (load_command->cmd)\n    {\n      case LC_DYSYMTAB: dysymtab_command = (struct dysymtab_command const *)load_command; break;\n      default: ; // not interested\n    }\n  }\n  \n  \n  NSString * lastNodeCaption;\n  \n  for (Section64Vector::const_iterator sectIter = ++sections_64.begin(); sectIter != sections_64.end(); ++sectIter)\n  {\n    struct section_64 const * section_64 = *sectIter;\n    MVNode * sectionNode = [self findNodeByUserInfo:[self userInfoForSection64:section_64]];\n    if (sectionNode == nil)\n    {\n      continue;\n    }\n    \n    @try \n    {\n      if ((section_64->flags & S_ATTR_PURE_INSTRUCTIONS) && (section_64->flags & SECTION_TYPE) != S_SYMBOL_STUBS)\n      {\n        [self createTextNode:sectionNode \n                     caption:(lastNodeCaption = @\"Assembly\") \n                    location:section_64->offset + imageOffset \n                      length:section_64->size\n                      reloff:section_64->reloff + imageOffset\n                      nreloc:section_64->nreloc\n                   extreloff:dysymtab_command ? dysymtab_command->extreloff : 0\n                     nextrel:dysymtab_command ? dysymtab_command->nextrel : 0\n                   locreloff:dysymtab_command ? dysymtab_command->locreloff : 0\n                     nlocrel:dysymtab_command ? dysymtab_command->nlocrel : 0];\n      }\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (void)processSectionRelocs\n{\n  // find Relocations node\n  MVNode * relocsNode = [self findNodeByUserInfo:[self userInfoForRelocs]];\n  if (relocsNode == nil)\n  {\n    return;\n  }\n  \n  NSString * lastNodeCaption;\n  @try\n  {\n    for (SectionVector::const_iterator sectIter = ++sections.begin(); sectIter != sections.end(); ++sectIter)\n    {\n      struct section const * section = *sectIter;\n      if (section->nreloc > 0)\n      {\n        [self createRelocNode:relocsNode \n                      caption:(lastNodeCaption = [NSString stringWithFormat:@\"(%s,%s)\",\n                                                  string(section->segname,16).c_str(),\n                                                  string(section->sectname,16).c_str()])\n                     location:section->reloff + imageOffset\n                       length:section->nreloc * sizeof(struct relocation_info)\n                  baseAddress:section->addr];\n      }\n    }\n  }\n  @catch(NSException * exception)\n  {\n    [self printException:exception caption:lastNodeCaption];\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (void)processSectionRelocs64\n{\n  // find Relocations node\n  MVNode * relocsNode = [self findNodeByUserInfo:[self userInfoForRelocs]];\n  if (relocsNode == nil)\n  {\n    return;\n  }\n  \n  NSString * lastNodeCaption;\n  @try\n  {  \n    for (Section64Vector::const_iterator sectIter = ++sections_64.begin(); sectIter != sections_64.end(); ++sectIter)\n    {\n      struct section_64 const * section_64 = *sectIter;\n      if (section_64->nreloc > 0)\n      {\n        [self createReloc64Node:relocsNode \n                        caption:(lastNodeCaption = [NSString stringWithFormat:@\"(%s,%s)\",\n                                                    string(section_64->segname,16).c_str(),\n                                                    string(section_64->sectname,16).c_str()])\n                       location:section_64->reloff + imageOffset\n                         length:section_64->nreloc * sizeof(struct relocation_info)\n                    baseAddress:section_64->addr];\n      }\n    }\n  }\n  @catch(NSException * exception)\n  {\n    [self printException:exception caption:lastNodeCaption];\n  }\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createMachONode:(MVNode *)parent\n                    caption:(NSString *)caption\n                   location:(uint64_t)location\n                mach_header:(struct mach_header const *)mach_header\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sizeof(struct mach_header) saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Magic Number\"\n                         :mach_header->magic == MH_MAGIC ? @\"MH_MAGIC\" :\n                          mach_header->magic == MH_CIGAM ? @\"MH_CIGAM\" : @\"???\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CPU Type\"\n                         :mach_header->cputype == CPU_TYPE_ANY ? @\"CPU_TYPE_ANY\" :\n                          mach_header->cputype == CPU_TYPE_I386 ? @\"CPU_TYPE_I386\" :\n                          mach_header->cputype == CPU_TYPE_ARM ? @\"CPU_TYPE_ARM\" :\n                          mach_header->cputype == CPU_TYPE_POWERPC ? @\"CPU_TYPE_POWERPC\" : @\"???\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CPU SubType\"\n                         :@\"\"];\n   \n  if ((mach_header->cpusubtype & CPU_SUBTYPE_LIB64) == CPU_SUBTYPE_LIB64) [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"CPU_SUBTYPE_LIB64\"];\n  \n  if (mach_header->cputype == CPU_TYPE_ARM)\n  {\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_ALL)   [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"CPU_SUBTYPE_ARM_ALL\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V4T)   [node.details appendRow:@\"\":@\"\":@\"00000005\":@\"CPU_SUBTYPE_ARM_V4T\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V6)    [node.details appendRow:@\"\":@\"\":@\"00000006\":@\"CPU_SUBTYPE_ARM_V6\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V5TEJ) [node.details appendRow:@\"\":@\"\":@\"00000007\":@\"CPU_SUBTYPE_ARM_V5TEJ\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_XSCALE)[node.details appendRow:@\"\":@\"\":@\"00000008\":@\"CPU_SUBTYPE_ARM_XSCALE\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7)    [node.details appendRow:@\"\":@\"\":@\"00000009\":@\"CPU_SUBTYPE_ARM_V7\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7F)   [node.details appendRow:@\"\":@\"\":@\"0000000A\":@\"CPU_SUBTYPE_ARM_V7F (Cortex A9)\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7S)   [node.details appendRow:@\"\":@\"\":@\"0000000B\":@\"CPU_SUBTYPE_ARM_V7S (Swift)\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7K)   [node.details appendRow:@\"\":@\"\":@\"0000000C\":@\"CPU_SUBTYPE_ARM_V7K (Kirkwood4)\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V8)    [node.details appendRow:@\"\":@\"\":@\"0000000D\":@\"CPU_SUBTYPE_ARM_V8\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V6M)   [node.details appendRow:@\"\":@\"\":@\"0000000E\":@\"CPU_SUBTYPE_ARM_V6M\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7M)   [node.details appendRow:@\"\":@\"\":@\"0000000F\":@\"CPU_SUBTYPE_ARM_V7M\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V7EM)  [node.details appendRow:@\"\":@\"\":@\"00000010\":@\"CPU_SUBTYPE_ARM_V7EM\"];\n      if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM_V8M)   [node.details appendRow:@\"\":@\"\":@\"00000011\":@\"CPU_SUBTYPE_ARM_V8M\"];\n  }\n  else if (mach_header->cputype == CPU_TYPE_I386)\n  {\n    if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_I386_ALL) [node.details appendRow:@\"\":@\"\":@\"00000003\":@\"CPU_SUBTYPE_I386_ALL\"];\n  }\n  else if (mach_header->cputype == CPU_TYPE_ANY)\n  {\n    if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_MULTIPLE) [node.details appendRow:@\"\":@\"\":@\"FFFFFFFF\":@\"CPU_SUBTYPE_MULTIPLE\"];\n    if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_LITTLE_ENDIAN) [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"CPU_SUBTYPE_LITTLE_ENDIAN\"];\n    if ((mach_header->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_BIG_ENDIAN) [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"CPU_SUBTYPE_BIG_ENDIAN\"];\n  }\n   \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"File Type\"\n                         :mach_header->filetype == MH_OBJECT ? @\"MH_OBJECT\" :\n                          mach_header->filetype == MH_EXECUTE ? @\"MH_EXECUTE\" :\n                          mach_header->filetype == MH_FVMLIB ? @\"MH_FVMLIB\" :\n                          mach_header->filetype == MH_CORE ? @\"MH_CORE\" :\n                          mach_header->filetype == MH_PRELOAD ? @\"MH_PRELOAD\" :\n                          mach_header->filetype == MH_DYLIB ? @\"MH_DYLIB\" :\n                          mach_header->filetype == MH_DYLINKER ? @\"MH_DYLINKER\" :\n                          mach_header->filetype == MH_BUNDLE ? @\"MH_BUNDLE\" :\n                          mach_header->filetype == MH_DYLIB_STUB ? @\"MH_DYLIB_STUB\" :\n                          mach_header->filetype == MH_DSYM ? @\"MH_DSYM\" : \n                          mach_header->filetype == MH_KEXT_BUNDLE ? @\"MH_KEXT_BUNDLE\" :\n                          mach_header->filetype == MH_FILESET ? @\"MH_FILESET\" :\n#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 130000\n                          mach_header->filetype == MH_GPU_EXECUTE ? @\"MH_GPU_EXECUTE\" :\n                          mach_header->filetype == MH_GPU_DYLIB ? @\"MH_GPU_DYLIB\" :\n#endif\n                          @\"???\"];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Load Commands\"\n                         :[NSString stringWithFormat:@\"%u\", mach_header->ncmds]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Size of Load Commands\"\n                         :[NSString stringWithFormat:@\"%u\", mach_header->sizeofcmds]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n    if (mach_header->flags & MH_NOUNDEFS)                [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"MH_NOUNDEFS\"];\n    if (mach_header->flags & MH_INCRLINK)                [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"MH_INCRLINK\"];\n    if (mach_header->flags & MH_DYLDLINK)                [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"MH_DYLDLINK\"];\n    if (mach_header->flags & MH_BINDATLOAD)              [node.details appendRow:@\"\":@\"\":@\"00000008\":@\"MH_BINDATLOAD\"];\n    if (mach_header->flags & MH_PREBOUND)                [node.details appendRow:@\"\":@\"\":@\"00000010\":@\"MH_PREBOUND\"];\n    if (mach_header->flags & MH_SPLIT_SEGS)              [node.details appendRow:@\"\":@\"\":@\"00000020\":@\"MH_SPLIT_SEGS\"];\n    if (mach_header->flags & MH_LAZY_INIT)               [node.details appendRow:@\"\":@\"\":@\"00000040\":@\"MH_LAZY_INIT\"];\n    if (mach_header->flags & MH_TWOLEVEL)                [node.details appendRow:@\"\":@\"\":@\"00000080\":@\"MH_TWOLEVEL\"];\n    if (mach_header->flags & MH_FORCE_FLAT)              [node.details appendRow:@\"\":@\"\":@\"00000100\":@\"MH_FORCE_FLAT\"];\n    if (mach_header->flags & MH_NOMULTIDEFS)             [node.details appendRow:@\"\":@\"\":@\"00000200\":@\"MH_NOMULTIDEFS\"];\n    if (mach_header->flags & MH_NOFIXPREBINDING)         [node.details appendRow:@\"\":@\"\":@\"00000400\":@\"MH_NOFIXPREBINDING\"];\n    if (mach_header->flags & MH_PREBINDABLE)             [node.details appendRow:@\"\":@\"\":@\"00000800\":@\"MH_PREBINDABLE\"];\n    if (mach_header->flags & MH_ALLMODSBOUND)            [node.details appendRow:@\"\":@\"\":@\"00001000\":@\"MH_ALLMODSBOUND\"];\n    if (mach_header->flags & MH_SUBSECTIONS_VIA_SYMBOLS) [node.details appendRow:@\"\":@\"\":@\"00002000\":@\"MH_SUBSECTIONS_VIA_SYMBOLS\"];\n    if (mach_header->flags & MH_CANONICAL)               [node.details appendRow:@\"\":@\"\":@\"00004000\":@\"MH_CANONICAL\"];\n    if (mach_header->flags & MH_WEAK_DEFINES)            [node.details appendRow:@\"\":@\"\":@\"00008000\":@\"MH_WEAK_DEFINES\"];\n    if (mach_header->flags & MH_BINDS_TO_WEAK)           [node.details appendRow:@\"\":@\"\":@\"00010000\":@\"MH_BINDS_TO_WEAK\"];\n    if (mach_header->flags & MH_ALLOW_STACK_EXECUTION)   [node.details appendRow:@\"\":@\"\":@\"00020000\":@\"MH_ALLOW_STACK_EXECUTION\"];\n    if (mach_header->flags & MH_ROOT_SAFE)               [node.details appendRow:@\"\":@\"\":@\"00040000\":@\"MH_ROOT_SAFE\"];\n    if (mach_header->flags & MH_SETUID_SAFE)             [node.details appendRow:@\"\":@\"\":@\"00080000\":@\"MH_SETUID_SAFE\"];\n    if (mach_header->flags & MH_NO_REEXPORTED_DYLIBS)    [node.details appendRow:@\"\":@\"\":@\"00100000\":@\"MH_NO_REEXPORTED_DYLIBS\"];\n    if (mach_header->flags & MH_PIE)                     [node.details appendRow:@\"\":@\"\":@\"00200000\":@\"MH_PIE\"];\n    if (mach_header->flags & MH_DEAD_STRIPPABLE_DYLIB)   [node.details appendRow:@\"\":@\"\":@\"00400000\":@\"MH_DEAD_STRIPPABLE_DYLIB\"];\n    if (mach_header->flags & MH_HAS_TLV_DESCRIPTORS)     [node.details appendRow:@\"\":@\"\":@\"00800000\":@\"MH_HAS_TLV_DESCRIPTORS\"];\n    if (mach_header->flags & MH_NO_HEAP_EXECUTION)       [node.details appendRow:@\"\":@\"\":@\"01000000\":@\"MH_NO_HEAP_EXECUTION\"];\n    if (mach_header->flags & MH_APP_EXTENSION_SAFE)      [node.details appendRow:@\"\":@\"\":@\"02000000\":@\"MH_APP_EXTENSION_SAFE\"];\n    if (mach_header->flags & MH_NLIST_OUTOFSYNC_WITH_DYLDINFO)      [node.details appendRow:@\"\":@\"\":@\"04000000\":@\"MH_NLIST_OUTOFSYNC_WITH_DYLDINFO\"];\n    if (mach_header->flags & MH_SIM_SUPPORT)             [node.details appendRow:@\"\":@\"\":@\"08000000\":@\"MH_SIM_SUPPORT\"];\n    if (mach_header->flags & MH_DYLIB_IN_CACHE)          [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"MH_DYLIB_IN_CACHE\"];\n\n  return node;\n}\n//-----------------------------------------------------------------------------\n\n- (MVNode *)createMachO64Node:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n               mach_header_64:(struct mach_header_64 const *)mach_header_64\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:sizeof(struct mach_header_64) saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Magic Number\"\n                         :mach_header_64->magic == MH_MAGIC_64 ? @\"MH_MAGIC_64\" :\n                          mach_header_64->magic == MH_CIGAM_64 ? @\"MH_CIGAM_64\" : @\"???\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CPU Type\"\n                         :mach_header_64->cputype == CPU_TYPE_ANY ? @\"CPU_TYPE_ANY\" :\n                          mach_header_64->cputype == CPU_TYPE_POWERPC64 ? @\"CPU_TYPE_POWERPC64\" :\n                          mach_header_64->cputype == CPU_TYPE_X86_64 ? @\"CPU_TYPE_X86_64\" :\n                          mach_header_64->cputype == CPU_TYPE_ARM64 ? @\"CPU_TYPE_ARM64\" :\n                          mach_header_64->cputype == CPU_TYPE_ARM64_32 ? @\"CPU_TYPE_ARM64_32\" : @\"???\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CPU SubType\"\n                         :@\"\"];\n\n  if ((mach_header_64->cpusubtype & CPU_SUBTYPE_LIB64) == CPU_SUBTYPE_LIB64) [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"CPU_SUBTYPE_LIB64\"];\n\n  if (mach_header_64->cputype == CPU_TYPE_X86_64)\n  {\n    if ((mach_header_64->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_X86_64_ALL) [node.details appendRow:@\"\":@\"\":@\"00000003\":@\"CPU_SUBTYPE_X86_64_ALL\"]; \n  }\n  else if (mach_header_64->cputype == CPU_TYPE_ARM64)\n  {\n      if ((mach_header_64->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64_ALL) {\n          [node.details appendRow:@\"\":@\"\":@\"00000000\":@\"CPU_SUBTYPE_ARM64_ALL\"];\n      }\n      else if ((mach_header_64->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64_V8) {\n          [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"CPU_SUBTYPE_ARM64_V8\"];\n      }\n      else if ((mach_header_64->cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {\n          [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"CPU_SUBTYPE_ARM64E\"];\n      }\n  }\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"File Type\"\n                         :mach_header_64->filetype == MH_OBJECT ? @\"MH_OBJECT\" :\n                          mach_header_64->filetype == MH_EXECUTE ? @\"MH_EXECUTE\" :\n                          mach_header_64->filetype == MH_FVMLIB ? @\"MH_FVMLIB\" :\n                          mach_header_64->filetype == MH_CORE ? @\"MH_CORE\" :\n                          mach_header_64->filetype == MH_PRELOAD ? @\"MH_PRELOAD\" :\n                          mach_header_64->filetype == MH_DYLIB ? @\"MH_DYLIB\" :\n                          mach_header_64->filetype == MH_DYLINKER ? @\"MH_DYLINKER\" :\n                          mach_header_64->filetype == MH_BUNDLE ? @\"MH_BUNDLE\" :\n                          mach_header_64->filetype == MH_DYLIB_STUB ? @\"MH_DYLIB_STUB\" :\n                          mach_header_64->filetype == MH_DSYM ? @\"MH_DSYM\" : \n                          mach_header_64->filetype == MH_KEXT_BUNDLE ? @\"MH_KEXT_BUNDLE\" :\n                          mach_header_64->filetype == MH_FILESET ? @\"MH_FILESET\" :\n#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 130000\n                          mach_header_64->filetype == MH_GPU_EXECUTE ? @\"MH_GPU_EXECUTE\" :\n                          mach_header_64->filetype == MH_GPU_DYLIB ? @\"MH_GPU_DYLIB\" :\n#endif\n                          @\"???\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Number of Load Commands\"\n                         :[NSString stringWithFormat:@\"%u\", mach_header_64->ncmds]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Size of Load Commands\"\n                         :[NSString stringWithFormat:@\"%u\", mach_header_64->sizeofcmds]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n    if (mach_header_64->flags & MH_NOUNDEFS)               [node.details appendRow:@\"\":@\"\":@\"00000001\":@\"MH_NOUNDEFS\"];\n    if (mach_header_64->flags & MH_INCRLINK)               [node.details appendRow:@\"\":@\"\":@\"00000002\":@\"MH_INCRLINK\"];\n    if (mach_header_64->flags & MH_DYLDLINK)               [node.details appendRow:@\"\":@\"\":@\"00000004\":@\"MH_DYLDLINK\"];\n    if (mach_header_64->flags & MH_BINDATLOAD)             [node.details appendRow:@\"\":@\"\":@\"00000008\":@\"MH_BINDATLOAD\"];\n    if (mach_header_64->flags & MH_PREBOUND)               [node.details appendRow:@\"\":@\"\":@\"00000010\":@\"MH_PREBOUND\"];\n    if (mach_header_64->flags & MH_SPLIT_SEGS)             [node.details appendRow:@\"\":@\"\":@\"00000020\":@\"MH_SPLIT_SEGS\"];\n    if (mach_header_64->flags & MH_LAZY_INIT)              [node.details appendRow:@\"\":@\"\":@\"00000040\":@\"MH_LAZY_INIT\"];\n    if (mach_header_64->flags & MH_TWOLEVEL)               [node.details appendRow:@\"\":@\"\":@\"00000080\":@\"MH_TWOLEVEL\"];\n    if (mach_header_64->flags & MH_FORCE_FLAT)             [node.details appendRow:@\"\":@\"\":@\"00000100\":@\"MH_FORCE_FLAT\"];\n    if (mach_header_64->flags & MH_NOMULTIDEFS)            [node.details appendRow:@\"\":@\"\":@\"00000200\":@\"MH_NOMULTIDEFS\"];\n    if (mach_header_64->flags & MH_NOFIXPREBINDING)        [node.details appendRow:@\"\":@\"\":@\"00000400\":@\"MH_NOFIXPREBINDING\"];\n    if (mach_header_64->flags & MH_PREBINDABLE)            [node.details appendRow:@\"\":@\"\":@\"00000800\":@\"MH_PREBINDABLE\"];\n    if (mach_header_64->flags & MH_ALLMODSBOUND)           [node.details appendRow:@\"\":@\"\":@\"00001000\":@\"MH_ALLMODSBOUND\"];\n    if (mach_header_64->flags & MH_SUBSECTIONS_VIA_SYMBOLS)[node.details appendRow:@\"\":@\"\":@\"00002000\":@\"MH_SUBSECTIONS_VIA_SYMBOLS\"];\n    if (mach_header_64->flags & MH_CANONICAL)              [node.details appendRow:@\"\":@\"\":@\"00004000\":@\"MH_CANONICAL\"];\n    if (mach_header_64->flags & MH_WEAK_DEFINES)           [node.details appendRow:@\"\":@\"\":@\"00008000\":@\"MH_WEAK_DEFINES\"];\n    if (mach_header_64->flags & MH_BINDS_TO_WEAK)          [node.details appendRow:@\"\":@\"\":@\"00010000\":@\"MH_BINDS_TO_WEAK\"];\n    if (mach_header_64->flags & MH_ALLOW_STACK_EXECUTION)  [node.details appendRow:@\"\":@\"\":@\"00020000\":@\"MH_ALLOW_STACK_EXECUTION\"];\n    if (mach_header_64->flags & MH_ROOT_SAFE)              [node.details appendRow:@\"\":@\"\":@\"00040000\":@\"MH_ROOT_SAFE\"];\n    if (mach_header_64->flags & MH_SETUID_SAFE)            [node.details appendRow:@\"\":@\"\":@\"00080000\":@\"MH_SETUID_SAFE\"];\n    if (mach_header_64->flags & MH_NO_REEXPORTED_DYLIBS)   [node.details appendRow:@\"\":@\"\":@\"00100000\":@\"MH_NO_REEXPORTED_DYLIBS\"];\n    if (mach_header_64->flags & MH_PIE)                    [node.details appendRow:@\"\":@\"\":@\"00200000\":@\"MH_PIE\"];\n    if (mach_header_64->flags & MH_DEAD_STRIPPABLE_DYLIB)  [node.details appendRow:@\"\":@\"\":@\"00400000\":@\"MH_DEAD_STRIPPABLE_DYLIB\"];\n    if (mach_header_64->flags & MH_HAS_TLV_DESCRIPTORS)    [node.details appendRow:@\"\":@\"\":@\"00800000\":@\"MH_HAS_TLV_DESCRIPTORS\"];\n    if (mach_header_64->flags & MH_NO_HEAP_EXECUTION)      [node.details appendRow:@\"\":@\"\":@\"01000000\":@\"MH_NO_HEAP_EXECUTION\"];\n    if (mach_header_64->flags & MH_APP_EXTENSION_SAFE)     [node.details appendRow:@\"\":@\"\":@\"02000000\":@\"MH_APP_EXTENSION_SAFE\"];\n    if (mach_header_64->flags & MH_NLIST_OUTOFSYNC_WITH_DYLDINFO)      [node.details appendRow:@\"\":@\"\":@\"04000000\":@\"MH_NLIST_OUTOFSYNC_WITH_DYLDINFO\"];\n    if (mach_header_64->flags & MH_SIM_SUPPORT)            [node.details appendRow:@\"\":@\"\":@\"08000000\":@\"MH_SIM_SUPPORT\"];\n    if (mach_header_64->flags & MH_DYLIB_IN_CACHE)         [node.details appendRow:@\"\":@\"\":@\"80000000\":@\"MH_DYLIB_IN_CACHE\"];\n    \n  uint32_t reserved = [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved\"\n                         :[NSString stringWithFormat:@\"%u\", reserved]];\n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (void)doMainTasks\n{\n  uint32_t      ncmds;        // number of load commands\n  uint32_t      sizeofcmds;   // the size of all the load commands\n  \n  // zero section (used to indicate absolute section relocations)\n  sections.push_back(NULL); \n  sections_64.push_back(NULL); \n  \n  // zero dylib (self)\n  dylibs.push_back((struct dylib *)NULL);\n  \n  NSString * lastNodeCaption; // for error message\n  \n  // ============== Mach Header ===========\n  if ([self is64bit] == NO)\n  {\n    MATCH_STRUCT(mach_header,imageOffset)\n    ncmds = mach_header->ncmds;\n    sizeofcmds = mach_header->sizeofcmds;\n\n    @try\n    {\n      [self createMachONode:rootNode\n                    caption:(lastNodeCaption = @\"Mach Header\")\n                   location:imageOffset\n                mach_header:mach_header];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  else //64bit\n  {\n    MATCH_STRUCT(mach_header_64,imageOffset)\n    ncmds = mach_header_64->ncmds;\n    sizeofcmds = mach_header_64->sizeofcmds;\n\n    @try\n    {\n      [self createMachO64Node:rootNode\n                      caption:(lastNodeCaption = @\"Mach64 Header\")\n                     location:imageOffset\n               mach_header_64:mach_header_64];\n    }\n    @catch(NSException * exception)\n    {\n      [self printException:exception caption:lastNodeCaption];\n    }\n  }\n  \n  \n  //=========== Load Commands =============\n  {\n    uint64_t fileOffset = imageOffset + ([self is64bit] == NO\n                                         ? sizeof(struct mach_header) \n                                         : sizeof(struct mach_header_64));\n    \n    MVNode * commandsNode = [self createDataNode:rootNode \n                                         caption:@\"Load Commands\"\n                                        location:fileOffset\n                                          length:sizeofcmds];\n    \n    for (uint32_t ncmd = 0; ncmd < ncmds; ++ncmd)\n    {\n      MATCH_STRUCT(load_command,fileOffset)\n      \n      // store the command for post-processing\n      commands.push_back(load_command);\n      \n      @try\n      {\n        [self createLoadCommandNode:commandsNode\n                            caption:(lastNodeCaption = [self getNameForCommand:load_command->cmd])\n                           location:fileOffset\n                             length:load_command->cmdsize\n                            command:load_command->cmd];\n      }\n      @catch(NSException * exception)\n      {\n        [self printException:exception caption:lastNodeCaption];\n      }\n      \n      fileOffset += load_command->cmdsize;\n    }\n  }\n  \n  \n  //=========================== Sections =========================\n  NSRange relocsRange = NSMakeRange(0,0);\n  \n  if ([self is64bit] == NO)\n  {\n    for (SectionVector::const_iterator sectIter = ++sections.begin(); sectIter != sections.end(); ++sectIter)\n    {\n      struct section const * section = *sectIter;\n      if (section->offset == 0)\n      {\n        continue;\n      }\n      \n      MVNode * sectionNode = [self createDataNode:rootNode \n                                          caption:[NSString stringWithFormat:@\"Section (%s,%s)\", \n                                                   string(section->segname,16).c_str(),\n                                                   string(section->sectname,16).c_str()]\n                                         location:section->offset + imageOffset\n                                           length:(section->flags & SECTION_TYPE) == S_ZEROFILL ||\n                                                  (section->flags & SECTION_TYPE) == S_GB_ZEROFILL ? 0 : section->size];\n      \n      [sectionNode.userInfo addEntriesFromDictionary:[self userInfoForSection:section]];\n      \n      NSRange range = NSMakeRange(section->reloff + imageOffset, section->nreloc * sizeof(struct relocation_info));\n      if (range.length > 0)\n      {\n        relocsRange = NSMaxRange(relocsRange) > 0 ? NSUnionRange(relocsRange,range) : range;\n      }\n    }\n  }\n  else //64bit\n  {\n    for (Section64Vector::const_iterator sectIter = ++sections_64.begin(); sectIter != sections_64.end(); ++sectIter)\n    {\n      struct section_64 const * section_64 = *sectIter;\n      if (section_64->offset == 0)\n      {\n        continue;\n      }\n      \n      MVNode * sectionNode = [self createDataNode:rootNode \n                                          caption:[NSString stringWithFormat:@\"Section64 (%s,%s)\", \n                                                   string(section_64->segname,16).c_str(),\n                                                   string(section_64->sectname,16).c_str()]\n                                         location:section_64->offset + imageOffset\n                                           length:(section_64->flags & SECTION_TYPE) == S_ZEROFILL ||\n                                                  (section_64->flags & SECTION_TYPE) == S_GB_ZEROFILL ? 0 : section_64->size];\n      \n      [sectionNode.userInfo addEntriesFromDictionary:[self userInfoForSection64:section_64]];\n      \n      NSRange range = NSMakeRange(section_64->reloff + imageOffset, section_64->nreloc * sizeof(struct relocation_info));\n      if (range.length > 0)\n      {\n        relocsRange = NSMaxRange(relocsRange) > 0 ? NSUnionRange(relocsRange,range) : range;\n      }\n    }\n  }\n  \n  \n  //======================== Relocations ============================\n  if (NSMaxRange(relocsRange) > 0)\n  {\n    MVNode * relocsNode = [self createDataNode:rootNode\n                                       caption:@\"Relocations\"\n                                      location:relocsRange.location\n                                        length:relocsRange.length];\n    \n    [relocsNode.userInfo addEntriesFromDictionary:[self userInfoForRelocs]];\n  }\n \n  //======================== determine SDK ============================\n  @try \n  {\n    [self determineRuntimeVersion];\n  }\n  @catch(NSException * exception)\n  {\n    [self printException:exception caption:rootNode.caption];\n  }\n  \n  [super doMainTasks];\n}\n\n//-----------------------------------------------------------------------------\n- (void)doBackgroundTasks\n{\n  NSBlockOperation * linkEditOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      if ([self is64bit] == NO) [self processLinkEdit]; else [self processLinkEdit64];\n    }\n    NSLog(@\"%@: LinkEdit finished parsing. (%lu symbols found)\", self, \n    [self is64bit] == NO ? self->symbols.size() : self->symbols_64.size());\n  }];\n  \n  NSBlockOperation * sectionRelocsOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      if ([self is64bit] == NO) [self processSectionRelocs]; else [self processSectionRelocs64];\n    }\n    NSLog(@\"%@: Section relocations finished parsing.\", self);\n  }];\n  \n  NSBlockOperation * dyldInfoOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      [self processDyldInfo];\n    }\n    NSLog(@\"%@: Dyld info finished parsing.\", self);\n  }];\n  \n  NSBlockOperation * sectionOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      if ([self is64bit] == NO) [self processSections]; else [self processSections64];\n    }\n    NSLog(@\"%@: Section contents finished parsing.\", self);\n  }];\n  \n  NSBlockOperation * EHFramesOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      if ([self is64bit] == NO) [self processEHFrames]; else [self processEHFrames64];\n    }\n    NSLog(@\"%@: Exception Frames finished parsing.\", self);\n  }];\n  \n  NSBlockOperation * LSDAsOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      if ([self is64bit] == NO) [self processLSDA]; else [self processLSDA64];\n    }\n    NSLog(@\"%@: Lang Spec Data Areas finished parsing. (%lu LSDAs found)\", self, self->lsdaInfo.size());\n  }];\n  \n  NSBlockOperation * objcSectionOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      if ([self is64bit] == NO) [self processObjcSections]; else [self processObjcSections64];\n    }\n    NSLog(@\"%@: ObjC Section contents finished parsing.\", self);\n  }];\n  \n  NSBlockOperation * codeSectionsOperation = [NSBlockOperation blockOperationWithBlock:^\n  {\n    if ([self->backgroundThread isCancelled]) return;\n    @autoreleasepool {\n      if ([self is64bit] == NO) [self processCodeSections]; else [self processCodeSections64];\n    }\n    NSLog(@\"%@: Code sections finished parsing.\", self);\n  }];\n  \n  // setup dependencies\n  [sectionOperation       addDependency:linkEditOperation];\n  [sectionRelocsOperation addDependency:sectionOperation];\n  [dyldInfoOperation      addDependency:sectionRelocsOperation];\n  [objcSectionOperation   addDependency:dyldInfoOperation];\n  [codeSectionsOperation  addDependency:objcSectionOperation];\n  [EHFramesOperation      addDependency:dyldInfoOperation];\n  [LSDAsOperation         addDependency:EHFramesOperation];\n    \n  // setup priorities\n  [codeSectionsOperation  setQueuePriority:NSOperationQueuePriorityLow];\n  \n  // start operations\n  NSOperationQueue * oq = [[NSOperationQueue alloc] init];\n\n  [dataController updateStatus:MVStatusTaskStarted];\n  \n  [oq   addOperations:[NSArray arrayWithObjects:linkEditOperation,\n                                                sectionOperation,\n                                                sectionRelocsOperation,\n                                                dyldInfoOperation,\n                                                EHFramesOperation,\n                                                LSDAsOperation,\n                                                objcSectionOperation,\n                                                codeSectionsOperation,nil] \n    waitUntilFinished:YES];\n  \n  [super doBackgroundTasks];\n  \n  [dataController updateStatus:MVStatusTaskTerminated];\n}\n\n@end\n"
        },
        {
          "name": "ObjC.h",
          "type": "blob",
          "size": 2.9267578125,
          "content": "/*\n *  ObjC.h\n *  MachOView\n *\n *  Created by Peter Saghelyi on 17/10/2011.\n *\n */\n\n#import \"MachOLayout.h\"\n\ntypedef std::vector<uint32_t> PointerVector;\ntypedef std::vector<uint64_t> Pointer64Vector;\n\n@interface MachOLayout (ObjC)\n\n\n- (MVNode *)createObjCCFStringsNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length;\n\n- (MVNode *)createObjCCFStrings64Node:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                               length:(uint64_t)length;\n\n- (MVNode *)createObjCImageInfoNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length;\n\n- (MVNode *)createObjCModulesNode:(MVNode *)parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length;\n\n- (MVNode *)createObjCClassExtNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                            length:(uint64_t)length;\n\n- (MVNode *)createObjCProtocolExtNode:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                               length:(uint64_t)length;\n\n- (MVNode *)createObjC2PointerListNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                                length:(uint64_t)length\n                              pointers:(PointerVector &)pointers;\n\n- (MVNode *)createObjC2Pointer64ListNode:(MVNode *)parent\n                                 caption:(NSString *)caption\n                                location:(uint64_t)location\n                                  length:(uint64_t)length\n                                pointers:(Pointer64Vector &)pointers;\n\n- (MVNode *)createObjC2MsgRefsNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                            length:(uint64_t)length;\n\n- (MVNode *)createObjC2MsgRefs64Node:(MVNode *)parent\n                             caption:(NSString *)caption\n                            location:(uint64_t)location\n                              length:(uint64_t)length;\n\n-(void)parseObjC2ClassPointers:(PointerVector const *)classes\n              CategoryPointers:(PointerVector const *)categories\n              ProtocolPointers:(PointerVector const *)protocols;\n\n-(void)parseObjC2Class64Pointers:(Pointer64Vector const *)classes\n              Category64Pointers:(Pointer64Vector const *)categories\n              Protocol64Pointers:(Pointer64Vector const *)protocols;\n\n@end\n"
        },
        {
          "name": "ObjC.mm",
          "type": "blob",
          "size": 130.6943359375,
          "content": "/*\n *  ObjC.mm\n *  MachOView\n *\n *  Created by Peter Saghelyi on 17/10/2011.\n *\n */\n\n#import \"ObjC.h\"\n#import \"ReadWrite.h\"\n#import \"DataController.h\"\n\n/* masks for objc_image_info.flags */\n#define OBJC_IMAGE_IS_REPLACEMENT   (1<<0)\n#define OBJC_IMAGE_SUPPORTS_GC      (1<<1)\n#define OBJC_IMAGE_GC_ONLY          (1<<2)\n\n/* Values for class_ro_t->flags */\n#define RO_META                     (1<<0)\n#define RO_ROOT                     (1<<1)\n#define RO_HAS_CXX_STRUCTORS        (1<<2)\n\nusing namespace std;\n\n//--------------------- ObjC ----------------------------------------\n\nstruct objc_image_info \n{\n  uint32_t version;\n  uint32_t flags;\n};\n\nstruct objc_module_t \n{\n  uint32_t version;\n  uint32_t size;\n  uint32_t name;              // char * (32-bit pointer)\n  uint32_t symtab;            // struct objc_symtab * (32-bit pointer)\n};\n\nstruct objc_symtab_t \n{\n  uint32_t sel_ref_cnt; \n  uint32_t refs;              // SEL * (32-bit pointer)\n  uint16_t cls_def_cnt;\n  uint16_t cat_def_cnt;\n  uint32_t defs[0];           // void * (32-bit pointer) variable size\n};\n\nstruct objc_class_t \n{\n  uint32_t isa;               // struct objc_class * (32-bit pointer)\n  uint32_t super_class;       // struct objc_class * (32-bit pointer)\n  uint32_t name;              // const char * (32-bit pointer)\n  int32_t version;\n  int32_t info;\n  int32_t instance_size;\n  uint32_t ivars;             // struct objc_ivar_list * (32-bit pointer)\n  uint32_t methodLists;       // struct objc_method_list ** (32-bit pointer)\n  uint32_t cache;             // struct objc_cache * (32-bit pointer)\n  uint32_t protocols;         // struct objc_protocol_list * (32-bit pointer)\n};\n\nstruct objc_category_t \n{\n  uint32_t category_name;     // char * (32-bit pointer)\n  uint32_t class_name;        // char * (32-bit pointer)\n  uint32_t instance_methods;\t// struct objc_method_list * (32-bit pointer)\n  uint32_t class_methods;     // struct objc_method_list * (32-bit pointer)\n  uint32_t protocols;         // struct objc_protocol_list * (32-bit ptr)\n};\n\nstruct objc_ivar_t \n{\n  uint32_t ivar_name;         // char * (32-bit pointer)\n  uint32_t ivar_type;         // char * (32-bit pointer)\n  int32_t ivar_offset;\n};\n\nstruct objc_ivar_list_t \n{\n  int32_t ivar_count;\n  struct objc_ivar_t ivar_list[0];  // variable length structure\n};\n\nstruct objc_method_t \n{\n  uint32_t method_name;       // SEL, aka struct objc_selector * (32-bit pointer)\n  uint32_t method_types;      // char * (32-bit pointer)\n  uint32_t method_imp;        // IMP, aka function pointer, (*IMP)(id, SEL, ...) (32-bit pointer)\n};\n\nstruct objc_method_list_t \n{\n  uint32_t obsolete;          // struct objc_method_list * (32-bit pointer)\n  int32_t method_count;\n  struct objc_method_t method_list[0];  // variable length structure\n};\n\nstruct objc_protocol_t \n{\n  uint32_t isa;               // struct objc_class * (32-bit pointer) \n  uint32_t protocol_name;     // char * (32-bit pointer)\n  uint32_t protocol_list;     // struct objc_protocol_list * (32-bit pointer)\n  uint32_t instance_methods;\t// struct objc_method_description_list * (32-bit pointer)\n  uint32_t class_methods;     // struct objc_method_description_list * (32-bit pointer)\n};\n\nstruct objc_protocol_list_t \n{\n  uint32_t next;              // struct objc_protocol_list * (32-bit pointer)\n  int32_t count;\n  uint32_t list[0];           // Protocol *, aka struct objc_protocol_t * (32-bit pointer)\n};\n\nstruct objc_method_description_t \n{\n  uint32_t name;              // SEL, aka struct objc_selector * (32-bit pointer)\n  uint32_t types;             // char * (32-bit pointer)\n};\n\nstruct objc_method_description_list_t \n{\n  int32_t count;\n  struct objc_method_description_t list[0];\n};\n\n//--------------------- ObjC2 32bit ----------------------------------------\n\nstruct class_t \n{\n  uint32_t isa;               // class_t * (32-bit pointer)\n  uint32_t superclass;        // class_t * (32-bit pointer)\n  uint32_t cache;             // Cache (32-bit pointer)\n  uint32_t vtable;            // IMP * (32-bit pointer)\n  uint32_t data;              // class_ro_t * (32-bit pointer)\n};\n\nstruct class_ro_t \n{\n  uint32_t flags;\n  uint32_t instanceStart;\n  uint32_t instanceSize;\n  uint32_t ivarLayout;        // const uint8_t * (32-bit pointer)\n  uint32_t name;              // const char * (32-bit pointer)\n  uint32_t baseMethods;       // const method_list_t * (32-bit pointer)\n  uint32_t baseProtocols;     // const protocol_list_t * (32-bit pointer)\n  uint32_t ivars;             // const ivar_list_t * (32-bit pointer)\n  uint32_t weakIvarLayout;    // const uint8_t * (32-bit pointer)\n  uint32_t baseProperties;    // const struct objc_property_list * (32-bit pointer)\n};\n\nstruct method_t \n{\n  uint32_t name;              // SEL (32-bit pointer)\n  uint32_t types;             // const char * (32-bit pointer)\n  uint32_t imp;               // IMP (32-bit pointer)\n};\n\nstruct method_list_t \n{\n  uint32_t entsize;\n  uint32_t count;\n  //struct method_t first;  These structures follow inline\n};\n\nstruct ivar_list_t \n{\n  uint32_t entsize;\n  uint32_t count;\n  // struct ivar_t first;  These structures follow inline\n};\n\nstruct ivar_t \n{\n  uint32_t offset;            // uintptr_t * (32-bit pointer)\n  uint32_t name;              // const char * (32-bit pointer)\n  uint32_t type;              // const char * (32-bit pointer)\n  uint32_t alignment;\n  uint32_t size;\n};\n\nstruct protocol_list_t \n{\n  uint32_t count;             // uintptr_t (a 32-bit value)\n  // struct protocol_t * list[0];  These pointers follow inline\n};\n\nstruct protocol_t \n{\n  uint32_t isa;               // id * (32-bit pointer)\n  uint32_t name;              // const char * (32-bit pointer)\n  uint32_t protocols;         // struct protocol_list_t * (32-bit pointer)\n  uint32_t instanceMethods;\t\t// method_list_t * (32-bit pointer)\n  uint32_t classMethods;      // method_list_t * (32-bit pointer)\n  uint32_t optionalInstanceMethods;\t// method_list_t * (32-bit pointer)\n  uint32_t optionalClassMethods;\t// method_list_t * (32-bit pointer)\n  uint32_t instanceProperties;\t// struct objc_property_list * (32-bit pointer)\n};\n\nstruct objc_property_list \n{\n  uint32_t entsize;\n  uint32_t count;\n  // struct objc_property first;  These structures follow inline\n};\n\nstruct objc_property \n{\n  uint32_t name;              // const char * (32-bit pointer)\n  uint32_t attributes;        // const char * (32-bit pointer)\n};\n\nstruct category_t \n{\n  uint32_t name;              // const char * (32-bit pointer)\n  uint32_t cls;               // struct class_t * (32-bit pointer)\n  uint32_t instanceMethods;   // struct method_list_t * (32-bit pointer)\n  uint32_t classMethods;      // struct method_list_t * (32-bit pointer)\n  uint32_t protocols;         // struct protocol_list_t * (32-bit pointer)\n  uint32_t instanceProperties; // struct objc_property_list * (32-bit pointer)\n};\n\nstruct message_ref \n{\n  uint32_t imp;               // IMP (32-bit pointer)\n  uint32_t sel;               // SEL (32-bit pointer)\n};\n\n//--------------------- ObjC2 64bit ----------------------------------------\n\nstruct class64_t \n{\n  uint64_t isa;               // class_t * (64-bit pointer)\n  uint64_t superclass;        // class_t * (64-bit pointer)\n  uint64_t cache;             // Cache (64-bit pointer)\n  uint64_t vtable;            // IMP * (64-bit pointer)\n  uint64_t data;              // class_ro_t * (64-bit pointer)\n};\n\nstruct class64_ro_t \n{\n  uint32_t flags;\n  uint32_t instanceStart;\n  uint32_t instanceSize;\n  uint32_t reserved;\n  uint64_t ivarLayout;        // const uint8_t * (64-bit pointer)\n  uint64_t name;              // const char * (64-bit pointer)\n  uint64_t baseMethods;       // const method_list_t * (64-bit pointer)\n  uint64_t baseProtocols;     // const protocol_list_t * (64-bit pointer)\n  uint64_t ivars;             // const ivar_list_t * (64-bit pointer)\n  uint64_t weakIvarLayout;    // const uint8_t * (64-bit pointer)\n  uint64_t baseProperties;    // const struct objc_property_list * (64-bit pointer)\n};\n\nstruct method64_list_t \n{\n  uint32_t entsize;\n  uint32_t count;\n  // struct method_t first;  These structures follow inline\n};\n\nstruct method64_t \n{\n  uint64_t name;              // SEL (64-bit pointer)\n  uint64_t types;             // const char * (64-bit pointer)\n  uint64_t imp;               // IMP (64-bit pointer)\n};\n\nstruct ivar64_list_t \n{\n  uint32_t entsize;\n  uint32_t count;\n  // struct ivar_t first;  These structures follow inline\n};\n\nstruct ivar64_t \n{\n  uint64_t offset;            // uintptr_t * (64-bit pointer)\n  uint64_t name;              // const char * (64-bit pointer)\n  uint64_t type;              // const char * (64-bit pointer)\n  uint32_t alignment;\n  uint32_t size;\n};\n\nstruct protocol64_list_t \n{\n  uint64_t count;             // uintptr_t (a 64-bit value)\n  // struct protocol_t * list[0];  These pointers follow inline\n};\n\nstruct protocol64_t\n{\n  uint64_t isa;               // id * (64-bit pointer)\n  uint64_t name;              // const char * (64-bit pointer)\n  uint64_t protocols;         // struct protocol_list_t * (64-bit pointer)\n  uint64_t instanceMethods;\t\t// method_list_t * (64-bit pointer)\n  uint64_t classMethods;      // method_list_t * (64-bit pointer)\n  uint64_t optionalInstanceMethods;\t// method_list_t * (64-bit pointer)\n  uint64_t optionalClassMethods;\t// method_list_t * (64-bit pointer)\n  uint64_t instanceProperties;\t// struct objc_property_list * (64-bit pointer)\n};\n\nstruct objc_property64_list \n{\n  uint32_t entsize;\n  uint32_t count;\n  // struct objc_property first;  These structures follow inline\n};\n\nstruct objc_property64 \n{\n  uint64_t name;              // const char * (64-bit pointer)\n  uint64_t attributes;        // const char * (64-bit pointer)\n};\n\nstruct category64_t\n{\n  uint64_t name;              // const char * (64-bit pointer)\n  uint64_t cls;               // struct class_t * (64-bit pointer)\n  uint64_t instanceMethods;   // struct method_list_t * (64-bit pointer)\n  uint64_t classMethods;      // struct method_list_t * (64-bit pointer)\n  uint64_t protocols;         // struct protocol_list_t * (64-bit pointer)\n  uint64_t instanceProperties; // struct objc_property_list * (64-bit pointer)\n};\n\nstruct message_ref64 \n{\n  uint64_t imp;               // IMP (64-bit pointer)\n  uint64_t sel;               // SEL (64-bit pointer)\n};\n\n\n//--------------------- Predeclarations ----------------------------------------\n\n@interface MachOLayout (Predeclarations)\n\n- (MVNode *)createObjCProtocolListNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                             protocols:(struct objc_protocol_list_t const *)objc_protocol_list_t;\n\n- (MVNode *)createObjC2ProtocolListNode:(MVNode *)parent\n                                caption:(NSString *)caption\n                               location:(uint64_t)location\n                              protocols:(struct protocol_list_t const *)protocol_list_t;\n\n- (MVNode *)createObjC2Protocol64ListNode:(MVNode *)parent\n                                  caption:(NSString *)caption\n                                 location:(uint64_t)location\n                                protocols:(struct protocol64_list_t const *)protocol64_list_t;\n\n@end\n\n\n//============================================================================\n@implementation MachOLayout (ObjC)\n\n\n//------------------------------------------------------------------------------\n- (MVNode *)objcSectionNodeContainsRVA:(uint32_t)rva\n{\n  MVNode * node = [self sectionNodeContainsRVA:rva];\n  // segment name must be __OBJC\n  return (node && [[node.userInfo objectForKey:@\"segname\"] isEqualToString:@\"__OBJC\"] ? node: nil);\n}\n\n//------------------------------------------------------------------------------\n// returns YES if has already been processed\n//------------------------------------------------------------------------------\n- (MVNode *)entryInSectionNode:(MVNode *)node atLocation:(uint64_t)location\n{\n  NSUInteger childCount = [node numberOfChildren];\n  \n  for (NSUInteger nchild = 0; nchild < childCount; ++nchild)\n  {\n    MVNode * child = [node childAtIndex:nchild];\n    if (NSLocationInRange(location,child.dataRange))\n    {\n      NSParameterAssert(location == child.dataRange.location); // check for perfect match\n      return child;\n    }\n  }\n  return nil;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCCFStringsNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length\n{\n  struct cfstring_t\n  {\n    uint32_t ptr;\n    uint32_t data;\n    uint32_t cstr;\n    uint32_t size;\n  };\n  \n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(cfstring_t,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"CFString Ptr\"\n                           :[self findSymbolAtRVA:cfstring_t->ptr]];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"\"\n                           :[self findSymbolAtRVA:cfstring_t->data]];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"String\"\n                           :(symbolName = [self findSymbolAtRVA:cfstring_t->cstr])];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%u\",cfstring_t->size]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCCFStrings64Node:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                               length:(uint64_t)length\n{\n  struct cfstring64_t\n  {\n    uint64_t ptr;\n    uint64_t data;\n    uint64_t cstr;\n    uint64_t size;\n  };\n  \n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(cfstring64_t,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"CFString Ptr\"\n                           :[self findSymbolAtRVA:cfstring64_t->ptr]];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"\"\n                           :[self findSymbolAtRVA:cfstring64_t->data]];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"String\"\n                           :(symbolName = [self findSymbolAtRVA:cfstring64_t->cstr])];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%qu\",cfstring64_t->size]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCImageInfoNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  MATCH_STRUCT(objc_image_info,location)\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Version\"\n                         :[NSString stringWithFormat:@\"%u\",objc_image_info->version]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n  if (objc_image_info->flags & OBJC_IMAGE_IS_REPLACEMENT) [node.details appendRow:@\"\":@\"\":@\"0x1\":@\"OBJC_IMAGE_IS_REPLACEMENT\"];\n  if (objc_image_info->flags & OBJC_IMAGE_SUPPORTS_GC)    [node.details appendRow:@\"\":@\"\":@\"0x2\":@\"OBJC_IMAGE_SUPPORTS_GC\"];\n  if (objc_image_info->flags & OBJC_IMAGE_GC_ONLY)        [node.details appendRow:@\"\":@\"\":@\"0x4\":@\"OBJC_IMAGE_GC_ONLY\"];\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCVariablesNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                              ivars:(struct objc_ivar_list_t const *)objc_ivar_list_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Variable List: \" stringByAppendingString:caption] \n                               location:location \n                                 length:sizeof(struct objc_ivar_list_t) + objc_ivar_list_t->ivar_count*sizeof(struct objc_ivar_t)\n                                  saver:nodeSaver];\n  \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  [dataController read_int32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%i\",objc_ivar_list_t->ivar_count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (int32_t nivar = 0; nivar < objc_ivar_list_t->ivar_count; ++nivar)\n  {\n    struct objc_ivar_t const * objc_ivar_t = &objc_ivar_list_t->ivar_list[nivar];\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:objc_ivar_t->ivar_name])];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Type\"\n                           :[self findSymbolAtRVA:objc_ivar_t->ivar_type]];\n    \n    [dataController read_int32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Offset\"\n                           :[NSString stringWithFormat:@\"%u\",objc_ivar_t->ivar_offset]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCMethodsNode:(MVNode *)parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                          methods:(struct objc_method_list_t const *)objc_method_list_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Method List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct objc_method_list_t) + objc_method_list_t->method_count*sizeof(struct objc_method_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Obsolete\"\n                         :[NSString stringWithFormat:@\"0x%X\",objc_method_list_t->obsolete]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_int32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%i\",objc_method_list_t->method_count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (int32_t nmeth = 0; nmeth < objc_method_list_t->method_count; ++nmeth)\n  {\n    struct objc_method_t const * objc_method_t = &objc_method_list_t->method_list[nmeth];\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:objc_method_t->method_name])];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Types\"\n                           :[self findSymbolAtRVA:objc_method_t->method_types]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"IMP (Function Pointer)\"\n                           :[self findSymbolAtRVA:objc_method_t->method_imp]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCMethodDescrsNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                             methodDescrs:(struct objc_method_description_list_t const *)objc_method_description_list_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Method Descr List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct objc_method_description_list_t) + objc_method_description_list_t->count*sizeof(struct objc_method_description_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_int32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%i\",objc_method_description_list_t->count]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (int32_t ndescr = 0; ndescr < objc_method_description_list_t->count; ++ndescr)\n  {\n    struct objc_method_description_t const * objc_method_description_t = &objc_method_description_list_t->list[ndescr];\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:objc_method_description_t->name])];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Types\"\n                           :[self findSymbolAtRVA:objc_method_description_t->types]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCProtocolNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                          protocol:(struct objc_protocol_t const *)objc_protocol_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Protocol: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct objc_protocol_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ISA\"\n                         :[self findSymbolAtRVA:objc_protocol_t->isa]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:objc_protocol_t->protocol_name]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Protocol List\"\n                         :[self findSymbolAtRVA:objc_protocol_t->protocol_list]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Method Descrs\"\n                         :[self findSymbolAtRVA:objc_protocol_t->instance_methods]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Method Descrs\"\n                         :[self findSymbolAtRVA:objc_protocol_t->class_methods]];\n  \n  MVNode * childNode = nil;\n  \n  // embedded protocol lists\n  if (objc_protocol_t->protocol_list && (childNode = [self objcSectionNodeContainsRVA:objc_protocol_t->protocol_list]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_protocol_t->protocol_list];\n    NSString * caption = [self findSymbolAtRVA:objc_protocol_t->protocol_list];\n    MATCH_STRUCT(objc_protocol_list_t,location)\n    [self createObjCProtocolListNode:childNode\n                             caption:caption\n                            location:location\n                           protocols:objc_protocol_list_t];\n  }\n  \n  // instance method descriptors\n  if (objc_protocol_t->instance_methods && (childNode = [self objcSectionNodeContainsRVA:objc_protocol_t->instance_methods]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_protocol_t->instance_methods];\n    NSString * caption = [self findSymbolAtRVA:objc_protocol_t->instance_methods];\n    MATCH_STRUCT(objc_method_description_list_t,location)\n    [self createObjCMethodDescrsNode:childNode\n                             caption:caption\n                            location:location\n                        methodDescrs:objc_method_description_list_t];\n  }\n  \n  // class method descriptors\n  if (objc_protocol_t->class_methods && (childNode = [self objcSectionNodeContainsRVA:objc_protocol_t->class_methods]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_protocol_t->class_methods];\n    NSString * caption = [self findSymbolAtRVA:objc_protocol_t->class_methods];\n    MATCH_STRUCT(objc_method_description_list_t,location)\n    [self createObjCMethodDescrsNode:childNode\n                             caption:caption\n                            location:location\n                        methodDescrs:objc_method_description_list_t];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCProtocolListNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                             protocols:(struct objc_protocol_list_t const *)objc_protocol_list_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Protocol List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct objc_protocol_list_t) + objc_protocol_list_t->count*sizeof(uint32_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Next\"\n                         :[self findSymbolAtRVA:objc_protocol_list_t->next]];\n\n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_int32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%i\",objc_protocol_list_t->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n\n  MVNode * childNode = nil;\n\n  for (int32_t nprot = 0; nprot < objc_protocol_list_t->count; ++nprot)\n  {\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :[NSString stringWithFormat:@\"Protocol[%i]\",nprot]\n                           :[self findSymbolAtRVA:objc_protocol_list_t->list[nprot]]];\n    \n    if (objc_protocol_list_t->list[nprot] && (childNode = [self objcSectionNodeContainsRVA:objc_protocol_list_t->list[nprot]]))\n    {\n      uint64_t location = [self RVAToFileOffset:objc_protocol_list_t->list[nprot]];\n      NSString * caption = [self findSymbolAtRVA:objc_protocol_list_t->list[nprot]];\n      MATCH_STRUCT(objc_protocol_t,location)\n      [self createObjCProtocolNode:childNode\n                           caption:caption\n                          location:location\n                          protocol:objc_protocol_t];\n    }\n  }\n  \n  // next protocol list\n  if (objc_protocol_list_t->next && (childNode = [self objcSectionNodeContainsRVA:objc_protocol_list_t->next]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_protocol_list_t->next];\n    NSString * caption = [self findSymbolAtRVA:objc_protocol_list_t->next];\n    MATCH_STRUCT(objc_protocol_list_t,location)\n    [self createObjCProtocolListNode:childNode\n                             caption:caption\n                            location:location\n                           protocols:objc_protocol_list_t];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCClassNode:(MVNode *)parent\n                        caption:(NSString *)caption\n                       location:(uint64_t)location\n                      objcClass:(struct objc_class_t const *)objc_class_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Class: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct objc_class_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ISA\"\n                         :[self findSymbolAtRVA:objc_class_t->isa]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Super Class\"\n                         :[self findSymbolAtRVA:objc_class_t->super_class]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:objc_class_t->name]];\n  \n  [dataController read_int32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Version\"\n                         :[NSString stringWithFormat:@\"%i\", objc_class_t->version]];\n  \n  [dataController read_int32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Info\"\n                         :@\"\"];\n   \n  if (objc_class_t->info &     0x1) [node.details appendRow:@\"\":@\"\":@\"    1\":@\"CLS_CLASS\"];\n  if (objc_class_t->info &     0x2) [node.details appendRow:@\"\":@\"\":@\"    2\":@\"CLS_META\"];\n  if (objc_class_t->info &     0x4) [node.details appendRow:@\"\":@\"\":@\"    4\":@\"CLS_INITIALIZED\"];\n  if (objc_class_t->info &     0x8) [node.details appendRow:@\"\":@\"\":@\"    8\":@\"CLS_POSING\"];\n  if (objc_class_t->info &    0x10) [node.details appendRow:@\"\":@\"\":@\"   10\":@\"CLS_MAPPED\"];\n  if (objc_class_t->info &    0x20) [node.details appendRow:@\"\":@\"\":@\"   20\":@\"CLS_FLUSH_CACHE\"];\n  if (objc_class_t->info &    0x40) [node.details appendRow:@\"\":@\"\":@\"   40\":@\"CLS_GROW_CACHE\"];\n  if (objc_class_t->info &    0x80) [node.details appendRow:@\"\":@\"\":@\"   80\":@\"CLS_NEED_BIND\"];\n  if (objc_class_t->info &   0x100) [node.details appendRow:@\"\":@\"\":@\"  100\":@\"CLS_METHOD_ARRAY\"];\n  if (objc_class_t->info &   0x200) [node.details appendRow:@\"\":@\"\":@\"  200\":@\"CLS_JAVA_HYBRID\"];\n  if (objc_class_t->info &   0x400) [node.details appendRow:@\"\":@\"\":@\"  400\":@\"CLS_JAVA_CLASS\"];\n  if (objc_class_t->info &   0x800) [node.details appendRow:@\"\":@\"\":@\"  800\":@\"CLS_INITIALIZING\"];\n  if (objc_class_t->info &  0x1000) [node.details appendRow:@\"\":@\"\":@\" 1000\":@\"CLS_FROM_BUNDLE\"];\n  if (objc_class_t->info &  0x2000) [node.details appendRow:@\"\":@\"\":@\" 2000\":@\"CLS_HAS_CXX_STRUCTORS\"];\n  if (objc_class_t->info &  0x4000) [node.details appendRow:@\"\":@\"\":@\" 4000\":@\"CLS_NO_METHOD_ARRAY\"];\n  if (objc_class_t->info &  0x8000) [node.details appendRow:@\"\":@\"\":@\" 8000\":@\"CLS_HAS_LOAD_METHOD\"];\n  if (objc_class_t->info & 0x10000) [node.details appendRow:@\"\":@\"\":@\"10000\":@\"CLS_CONSTRUCTING\"];\n  if (objc_class_t->info & 0x20000) [node.details appendRow:@\"\":@\"\":@\"20000\":@\"CLS_EXT\"];\n\n\n  [dataController read_int32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Size\"\n                         :[NSString stringWithFormat:@\"%i\", objc_class_t->instance_size]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Vars\"\n                         :[self findSymbolAtRVA:objc_class_t->ivars]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Method Lists\"\n                         :[self findSymbolAtRVA:objc_class_t->methodLists]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Cache\"\n                         :[self findSymbolAtRVA:objc_class_t->cache]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Protocols\"\n                         :[self findSymbolAtRVA:objc_class_t->protocols]];\n\n  MVNode * childNode = nil;\n  \n  // Meta Classes\n  if (objc_class_t->isa && (childNode = [self objcSectionNodeContainsRVA:objc_class_t->isa])\n      && (objc_class_t->info & 0x1) == 0x1)\n  {\n    uint64_t location = [self RVAToFileOffset:objc_class_t->isa];\n    NSString * caption = [self findSymbolAtRVA:objc_class_t->isa];\n    MATCH_STRUCT(objc_class_t,location)\n    [self createObjCClassNode:childNode\n                      caption:caption\n                     location:location\n                    objcClass:objc_class_t];\n  }\n  \n  // Instance Variables\n  if (objc_class_t->ivars && (childNode = [self objcSectionNodeContainsRVA:objc_class_t->ivars]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_class_t->ivars];\n    NSString * caption = [self findSymbolAtRVA:objc_class_t->ivars];\n    MATCH_STRUCT (objc_ivar_list_t,location)\n    [self createObjCVariablesNode:childNode\n                          caption:caption\n                         location:location\n                            ivars:objc_ivar_list_t];\n  }\n  \n  // Methods\n  if (objc_class_t->methodLists && (childNode = [self objcSectionNodeContainsRVA:objc_class_t->methodLists]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_class_t->methodLists];\n    NSString * caption = [self findSymbolAtRVA:objc_class_t->methodLists];\n    MATCH_STRUCT (objc_method_list_t,location)\n    [self createObjCMethodsNode:childNode\n                        caption:caption\n                       location:location\n                        methods:objc_method_list_t];\n  }\n  \n  // Protocols\n  if (objc_class_t->protocols && (childNode = [self objcSectionNodeContainsRVA:objc_class_t->protocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_class_t->protocols];\n    NSString * caption = [self findSymbolAtRVA:objc_class_t->protocols];\n    MATCH_STRUCT (objc_protocol_list_t,location)\n    [self createObjCProtocolListNode:childNode\n                             caption:caption\n                            location:location\n                           protocols:objc_protocol_list_t];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCCategoryNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                      objcCategory:(struct objc_category_t const *)objc_category_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Category: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct objc_category_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  NSString * className;\n  NSString * categoryName;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :categoryName = [self findSymbolAtRVA:objc_category_t->category_name]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Name\"\n                         :className = [self findSymbolAtRVA:objc_category_t->class_name]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Methods\"\n                         :[NSString stringWithFormat:@\"0x%X\",objc_category_t->instance_methods]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Methods\"\n                         :[NSString stringWithFormat:@\"0x%X\",objc_category_t->class_methods]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Protocols\"\n                         :[NSString stringWithFormat:@\"0x%X\",objc_category_t->protocols]];\n  \n\n  node.caption = [NSString stringWithFormat:@\"%@ [%@ %@]\", node.caption, className, categoryName];\n  \n  \n  MVNode * childNode = nil;\n  \n  // Instance Methods\n  if (objc_category_t->instance_methods && (childNode = [self objcSectionNodeContainsRVA:objc_category_t->instance_methods]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_category_t->instance_methods];\n    NSString * caption = [self findSymbolAtRVA:objc_category_t->instance_methods];\n    MATCH_STRUCT(objc_method_list_t,location)\n    [self createObjCMethodsNode:childNode\n                        caption:caption\n                       location:location\n                        methods:objc_method_list_t];\n  }\n  \n  // Class Methods\n  if (objc_category_t->class_methods && (childNode = [self objcSectionNodeContainsRVA:objc_category_t->class_methods]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_category_t->class_methods];\n    NSString * caption = [self findSymbolAtRVA:objc_category_t->class_methods];\n    MATCH_STRUCT(objc_method_list_t,location)\n    [self createObjCMethodsNode:childNode\n                        caption:caption\n                       location:location\n                        methods:objc_method_list_t];\n  }\n\n  // Protocols\n  if (objc_category_t->protocols && (childNode = [self objcSectionNodeContainsRVA:objc_category_t->protocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:objc_category_t->protocols];\n    NSString * caption = [self findSymbolAtRVA:objc_category_t->protocols];\n    MATCH_STRUCT (objc_protocol_list_t,location)\n    [self createObjCProtocolListNode:childNode\n                             caption:caption\n                            location:location\n                           protocols:objc_protocol_list_t];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCSymtabNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                      objcSymtab:(struct objc_symtab_t const *)objc_symtab_t\n{\n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"Objc Symtab: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct objc_symtab_t) + (objc_symtab_t->cls_def_cnt + objc_symtab_t->cat_def_cnt)*sizeof(uint32_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Selector Reference Count\"\n                         :[NSString stringWithFormat:@\"%u\", objc_symtab_t->sel_ref_cnt]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"References\"\n                         :[self findSymbolAtRVA:objc_symtab_t->refs]];\n  \n  [dataController read_uint16:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Definition Count\"\n                         :[NSString stringWithFormat:@\"%u\", objc_symtab_t->cls_def_cnt]];\n  \n  [dataController read_uint16:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Category Definition Count\"\n                         :[NSString stringWithFormat:@\"%u\", objc_symtab_t->cat_def_cnt]];\n  \n  // processing definitions\n  for (uint32_t ndef = 0; ndef < objc_symtab_t->cls_def_cnt + objc_symtab_t->cat_def_cnt; ++ndef)\n  {\n    uint64_t location = [self RVAToFileOffset:objc_symtab_t->defs[ndef]];\n    NSString * caption = [self findSymbolAtRVA:objc_symtab_t->defs[ndef]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :[NSString stringWithFormat:@\"Definition[%u]\",ndef]\n                           :caption];\n    \n    MVNode * childNode = [self objcSectionNodeContainsRVA:objc_symtab_t->defs[ndef]];\n    if (childNode)\n    {\n      // Class Definitions\n      if (ndef < objc_symtab_t->cls_def_cnt)\n      {\n        MATCH_STRUCT(objc_class_t,location)\n        [self createObjCClassNode:childNode\n                          caption:caption\n                         location:location\n                        objcClass:objc_class_t];\n      }\n      // Category Definitions\n      else\n      {\n        MATCH_STRUCT(objc_category_t,location)\n        [self createObjCCategoryNode:childNode\n                             caption:caption\n                            location:location\n                        objcCategory:objc_category_t];\n      }\n    }\n  }\n  \n  return node;\n  \n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCModulesNode:(MVNode *)parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(objc_module_t,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Version\"\n                           :[NSString stringWithFormat:@\"%u\", objc_module_t->version]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%u\", objc_module_t->size]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:objc_module_t->name])];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Symtab\"\n                           :[self findSymbolAtRVA:objc_module_t->symtab]];\n\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n    MVNode * childNode = nil;\n    \n    // symbol table\n    if (objc_module_t->symtab && (childNode = [self objcSectionNodeContainsRVA:objc_module_t->symtab]))\n    {\n      uint64_t location = [self RVAToFileOffset:objc_module_t->symtab];\n      NSString * caption = [self findSymbolAtRVA:objc_module_t->symtab];\n      MATCH_STRUCT(objc_symtab_t,location)\n      [self createObjCSymtabNode:childNode\n                         caption:caption\n                        location:location\n                      objcSymtab:objc_symtab_t];\n    }\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCClassExtNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                            length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    uint32_t value1 = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%u\", value1]];\n    \n    uint32_t value2 = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"\"\n                           :[NSString stringWithFormat:@\"%u\", value2]];\n    \n    uint32_t propertyList = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Property List\"\n                           :[NSString stringWithFormat:@\"0x%X\", propertyList]];\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n    MVNode * childNode = nil;\n    \n    // Instance Properties\n    if (propertyList && (childNode = [self sectionNodeContainsRVA:propertyList]))\n    {\n      uint64_t location = [self RVAToFileOffset:propertyList];\n      NSString * caption = [self findSymbolAtRVA:propertyList];\n      MATCH_STRUCT(objc_property_list,location)\n      [self createObjC2PropertyListNode:childNode\n                                caption:caption\n                               location:location\n                             properties:objc_property_list];\n    }\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjCProtocolExtNode:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                               length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    uint32_t value1 = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%u\", value1]];\n    \n    uint32_t value2 = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Method Descrs\"\n                           :[NSString stringWithFormat:@\"0x%X\", value2]];\n    \n    uint32_t value3 = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"\"\n                           :[NSString stringWithFormat:@\"%u\", value3]];\n\n    uint32_t value4 = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"\"\n                           :[NSString stringWithFormat:@\"%u\", value4]];\n\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n    MVNode * childNode = nil;\n    \n    // instance method descriptors\n    if (value2 && (childNode = [self objcSectionNodeContainsRVA:value2]))\n    {\n      uint64_t location = [self RVAToFileOffset:value2];\n      NSString * caption = [self findSymbolAtRVA:value2];\n      MATCH_STRUCT(objc_method_description_list_t,location)\n      [self createObjCMethodDescrsNode:childNode\n                               caption:caption\n                              location:location\n                          methodDescrs:objc_method_description_list_t];\n    }\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2PointerListNode:(MVNode *)parent\n                               caption:(NSString *)caption\n                              location:(uint64_t)location\n                                length:(uint64_t)length\n                              pointers:(PointerVector &)pointers\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    // accumulate search info\n    NSString * symbolName = nil;\n    \n    uint32_t rva = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Pointer\"\n                           :(symbolName = [self findSymbolAtRVA:rva])];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n    \n    pointers.push_back(rva);\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Pointer64ListNode:(MVNode *)parent\n                                 caption:(NSString *)caption\n                                location:(uint64_t)location\n                                  length:(uint64_t)length\n                                pointers:(Pointer64Vector &)pointers\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    // accumulate search info\n    NSString * symbolName = nil;\n\n    uint64_t rva64 = [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Pointer\"\n                           :(symbolName = [self findSymbolAtRVA:rva64])];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n    \n    pointers.push_back(rva64);\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2MsgRefsNode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                            length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(message_ref,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"IMP\"\n                           :[self findSymbolAtRVA:message_ref->imp]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"SEL\"\n                           :(symbolName = [self findSymbolAtRVA:message_ref->sel])];\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2MsgRefs64Node:(MVNode *)parent\n                             caption:(NSString *)caption\n                            location:(uint64_t)location\n                              length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  while (NSMaxRange(range) < location + length)\n  {\n    MATCH_STRUCT(message_ref64,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n\n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"IMP\"\n                           :[self findSymbolAtRVA:message_ref64->imp]];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"SEL\"\n                           :(symbolName = [self findSymbolAtRVA:message_ref64->sel])];\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2MethodListNode:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                              methods:(struct method_list_t const *)method_list_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Method List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct method_list_t) + method_list_t->count*sizeof(struct method_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Entry Size\"\n                         :[NSString stringWithFormat:@\"%u\",method_list_t->entsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%u\",method_list_t->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nmeth = 0; nmeth < method_list_t->count; ++nmeth)\n  {\n    MATCH_STRUCT(method_t,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:method_t->name])];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Types\"\n                           :[self findSymbolAtRVA:method_t->types]];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Implementation\"\n                           :[self findSymbolAtRVA:method_t->imp]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Method64ListNode:(MVNode *)parent\n                                caption:(NSString *)caption\n                               location:(uint64_t)location\n                                methods:(struct method64_list_t const *)method64_list_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Method64 List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct method64_list_t) + method64_list_t->count*sizeof(struct method64_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Entry Size\"\n                         :[NSString stringWithFormat:@\"%u\",method64_list_t->entsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%u\",method64_list_t->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nmeth = 0; nmeth < method64_list_t->count; ++nmeth)\n  {\n    MATCH_STRUCT(method64_t,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:method64_t->name])];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Types\"\n                           :[self findSymbolAtRVA:method64_t->types]];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Implementation\"\n                           :[self findSymbolAtRVA:method64_t->imp]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2PropertyListNode:(MVNode *)parent\n                                caption:(NSString *)caption\n                               location:(uint64_t)location\n                             properties:(struct objc_property_list const *)objc_property_list\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Property List: \" stringByAppendingString:caption]\n                               location:location\n                                 length:sizeof(struct objc_property_list) + objc_property_list->count*sizeof(struct objc_property)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Entry Size\"\n                         :[NSString stringWithFormat:@\"%u\",objc_property_list->entsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%u\",objc_property_list->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nprop = 0; nprop < objc_property_list->count; ++nprop)\n  {\n    MATCH_STRUCT(objc_property,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:objc_property->name])];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Attributes\"\n                           :[self findSymbolAtRVA:objc_property->attributes]];\n\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Property64ListNode:(MVNode *)parent\n                                  caption:(NSString *)caption\n                                 location:(uint64_t)location\n                               properties:(struct objc_property64_list const *)objc_property64_list\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Property64 List: \" stringByAppendingString:caption]\n                               location:location\n                                 length:sizeof(struct objc_property64_list) + objc_property64_list->count*sizeof(struct objc_property64)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Entry Size\"\n                         :[NSString stringWithFormat:@\"%u\",objc_property64_list->entsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%u\",objc_property64_list->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nprop = 0; nprop < objc_property64_list->count; ++nprop)\n  {\n    MATCH_STRUCT(objc_property64,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:objc_property64->name])];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Attributes\"\n                           :[self findSymbolAtRVA:objc_property64->attributes]];\n\n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return  node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2ProtocolNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                           protocol:(struct protocol_t const *)protocol_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Protocol: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct protocol_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ISA\"\n                         :[self findSymbolAtRVA:protocol_t->isa]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:protocol_t->name]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Protocols\"\n                         :[self findSymbolAtRVA:protocol_t->protocols]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Methods\"\n                         :[self findSymbolAtRVA:protocol_t->instanceMethods]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Methods\"\n                         :[self findSymbolAtRVA:protocol_t->classMethods]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Optional Inst Methods\"\n                         :[self findSymbolAtRVA:protocol_t->optionalInstanceMethods]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Optional Class Methods\"\n                         :[self findSymbolAtRVA:protocol_t->optionalClassMethods]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Properties\"\n                         :[self findSymbolAtRVA:protocol_t->instanceProperties]];\n\n  MVNode * childNode = nil;\n  \n  // Protocols\n  if (protocol_t->protocols && (childNode = [self sectionNodeContainsRVA:protocol_t->protocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:protocol_t->protocols];\n    NSString * caption = [self findSymbolAtRVA:protocol_t->protocols];\n    MATCH_STRUCT(protocol_list_t,location)\n    [self createObjC2ProtocolListNode:childNode\n                              caption:caption\n                             location:location\n                            protocols:protocol_list_t];\n  }\n  \n  // Instance Methods\n  if (protocol_t->instanceMethods && (childNode = [self sectionNodeContainsRVA:protocol_t->instanceMethods]))\n  {\n      uint64_t location = [self RVAToFileOffset:protocol_t->instanceMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol_t->instanceMethods];\n    MATCH_STRUCT(method_list_t,location)\n    [self createObjC2MethodListNode:childNode\n                            caption:caption\n                           location:location\n                            methods:method_list_t];\n  }\n  \n  // Class Methods\n  if (protocol_t->classMethods && (childNode = [self sectionNodeContainsRVA:protocol_t->classMethods]))\n  {\n      uint64_t location = [self RVAToFileOffset:protocol_t->classMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol_t->classMethods];\n    MATCH_STRUCT(method_list_t,location)\n    [self createObjC2MethodListNode:childNode\n                            caption:caption\n                           location:location\n                            methods:method_list_t];\n  }\n\n  // Optional Instance Methods\n  if (protocol_t->optionalInstanceMethods && (childNode = [self sectionNodeContainsRVA:protocol_t->optionalInstanceMethods]))\n  {\n      uint64_t location = [self RVAToFileOffset:protocol_t->optionalInstanceMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol_t->optionalInstanceMethods];\n    MATCH_STRUCT(method_list_t,location)\n    [self createObjC2MethodListNode:childNode\n                            caption:caption\n                           location:location\n                            methods:method_list_t];\n  }\n\n  // Optional Class Methods\n  if (protocol_t->optionalClassMethods && (childNode = [self sectionNodeContainsRVA:protocol_t->optionalClassMethods]))\n  {\n      uint64_t location = [self RVAToFileOffset:protocol_t->optionalClassMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol_t->optionalClassMethods];\n    MATCH_STRUCT(method_list_t,location)\n    [self createObjC2MethodListNode:childNode\n                            caption:caption\n                           location:location\n                            methods:method_list_t];\n  }\n  \n  // Instance Properties\n  if (protocol_t->instanceProperties && (childNode = [self sectionNodeContainsRVA:protocol_t->instanceProperties]))\n  {\n      uint64_t location = [self RVAToFileOffset:protocol_t->instanceProperties];\n    NSString * caption = [self findSymbolAtRVA:protocol_t->instanceProperties];\n    MATCH_STRUCT(objc_property_list,location)\n    [self createObjC2PropertyListNode:childNode\n                              caption:caption\n                             location:location\n                           properties:objc_property_list];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Protocol64Node:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                             protocol:(struct protocol64_t const *)protocol64_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Protocol64: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct protocol64_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ISA\"\n                         :[self findSymbolAtRVA:protocol64_t->isa]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:protocol64_t->name]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Protocols\"\n                         :[self findSymbolAtRVA:protocol64_t->protocols]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Methods\"\n                         :[self findSymbolAtRVA:protocol64_t->instanceMethods]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Methods\"\n                         :[self findSymbolAtRVA:protocol64_t->classMethods]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Optional Inst Methods\"\n                         :[self findSymbolAtRVA:protocol64_t->optionalInstanceMethods]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Optional Class Methods\"\n                         :[self findSymbolAtRVA:protocol64_t->optionalClassMethods]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Properties\"\n                         :[self findSymbolAtRVA:protocol64_t->instanceProperties]];\n  \n  MVNode * childNode = nil;\n  \n  // Protocols\n  if (protocol64_t->protocols && (childNode = [self sectionNodeContainsRVA:protocol64_t->protocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:protocol64_t->protocols];\n    NSString * caption = [self findSymbolAtRVA:protocol64_t->protocols];\n    MATCH_STRUCT(protocol64_list_t,location)\n    [self createObjC2Protocol64ListNode:childNode\n                                caption:caption\n                               location:location\n                              protocols:protocol64_list_t];\n  }\n  \n  // Instance Methods\n  if (protocol64_t->instanceMethods && (childNode = [self sectionNodeContainsRVA:protocol64_t->instanceMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:protocol64_t->instanceMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol64_t->instanceMethods];\n    MATCH_STRUCT(method64_list_t,location)\n    [self createObjC2Method64ListNode:childNode\n                              caption:caption\n                             location:location\n                              methods:method64_list_t];\n  }\n  \n  // Class Methods\n  if (protocol64_t->classMethods && (childNode = [self sectionNodeContainsRVA:protocol64_t->classMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:protocol64_t->classMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol64_t->classMethods];\n    MATCH_STRUCT(method64_list_t,location)\n    [self createObjC2Method64ListNode:childNode\n                              caption:caption\n                             location:location\n                              methods:method64_list_t];\n  }\n  \n  // Optional Instance Methods\n  if (protocol64_t->optionalInstanceMethods && (childNode = [self sectionNodeContainsRVA:protocol64_t->optionalInstanceMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:protocol64_t->optionalInstanceMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol64_t->optionalInstanceMethods];\n    MATCH_STRUCT(method64_list_t,location)\n    [self createObjC2Method64ListNode:childNode\n                              caption:caption\n                             location:location\n                              methods:method64_list_t];\n  }\n  \n  // Optional Class Methods\n  if (protocol64_t->optionalClassMethods && (childNode = [self sectionNodeContainsRVA:protocol64_t->optionalClassMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:protocol64_t->optionalClassMethods];\n    NSString * caption = [self findSymbolAtRVA:protocol64_t->optionalClassMethods];\n    MATCH_STRUCT(method64_list_t,location)\n    [self createObjC2Method64ListNode:childNode\n                              caption:caption\n                             location:location\n                              methods:method64_list_t];\n  }\n  \n  // Instance Properties\n  if (protocol64_t->instanceProperties && (childNode = [self sectionNodeContainsRVA:protocol64_t->instanceProperties]))\n  {\n    uint64_t location = [self RVAToFileOffset:protocol64_t->instanceProperties];\n    NSString * caption = [self findSymbolAtRVA:protocol64_t->instanceProperties];\n    MATCH_STRUCT(objc_property64_list,location)\n    [self createObjC2Property64ListNode:childNode\n                                caption:caption\n                               location:location\n                             properties:objc_property64_list];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2ProtocolListNode:(MVNode *)parent\n                                caption:(NSString *)caption\n                               location:(uint64_t)location\n                              protocols:(struct protocol_list_t const *)protocol_list_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Protocol List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct protocol_list_t) + protocol_list_t->count*sizeof(uint32_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%u\",protocol_list_t->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nprot = 0; nprot < protocol_list_t->count; ++nprot)\n  {\n    uint32_t protocolAddr = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :[NSString stringWithFormat:@\"list[%u]\",nprot]\n                           :[self findSymbolAtRVA:protocolAddr]];\n    \n    MVNode * childNode = [self sectionNodeContainsRVA:protocolAddr];\n    if (childNode)\n    {\n      uint64_t location = [self RVAToFileOffset:protocolAddr];\n      NSString * caption = [self findSymbolAtRVA:protocolAddr];\n      MATCH_STRUCT(protocol_t,location)\n      [self createObjC2ProtocolNode:childNode\n                            caption:caption\n                           location:location\n                           protocol:protocol_t];\n    }\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Protocol64ListNode:(MVNode *)parent\n                                  caption:(NSString *)caption\n                                 location:(uint64_t)location\n                                protocols:(struct protocol64_list_t const *)protocol64_list_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Protocol64 List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct protocol64_list_t) + protocol64_list_t->count*sizeof(uint64_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%qu\",protocol64_list_t->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint64_t nprot = 0; nprot < protocol64_list_t->count; ++nprot)\n  {\n    uint64_t protocolAddr = [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :[NSString stringWithFormat:@\"list[%qu]\",nprot]\n                           :[self findSymbolAtRVA:protocolAddr]];\n    \n    MVNode * childNode = [self sectionNodeContainsRVA:protocolAddr];\n    if (childNode)\n    {\n      uint64_t location = [self RVAToFileOffset:protocolAddr];\n      NSString * caption = [self findSymbolAtRVA:protocolAddr];\n      MATCH_STRUCT(protocol64_t,location)\n      [self createObjC2Protocol64Node:childNode\n                              caption:caption\n                             location:location\n                             protocol:protocol64_t];\n    }\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2VariableListNode:(MVNode *)parent\n                                caption:(NSString *)caption\n                               location:(uint64_t)location\n                              variables:(struct ivar_list_t const *)ivar_list_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Variable List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct ivar_list_t) + ivar_list_t->count*sizeof(struct ivar_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Entry Size\"\n                         :[NSString stringWithFormat:@\"%u\",ivar_list_t->entsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%u\",ivar_list_t->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nvar = 0; nvar < ivar_list_t->count; ++nvar)\n  {\n    MATCH_STRUCT(ivar_t,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Offset\"\n                           :[self findSymbolAtRVA:ivar_t->offset]];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:ivar_t->name])];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Type\"\n                           :[self findSymbolAtRVA:ivar_t->type]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Alignment\"\n                           :[NSString stringWithFormat:@\"%u\",ivar_t->alignment]];\n\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%u\",ivar_t->size]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n\n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Variable64ListNode:(MVNode *)parent\n                                  caption:(NSString *)caption\n                                 location:(uint64_t)location\n                                variables:(struct ivar64_list_t const *)ivar64_list_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Variable64 List: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct ivar64_list_t) + ivar64_list_t->count*sizeof(struct ivar64_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Entry Size\"\n                         :[NSString stringWithFormat:@\"%u\",ivar64_list_t->entsize]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],nil];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Count\"\n                         :[NSString stringWithFormat:@\"%u\",ivar64_list_t->count]];\n  \n  [node.details setAttributes:MVCellColorAttributeName,[NSColor greenColor],\n                              MVUnderlineAttributeName,@\"YES\",nil];\n  \n  for (uint32_t nvar = 0; nvar < ivar64_list_t->count; ++nvar)\n  {\n    MATCH_STRUCT(ivar64_t,NSMaxRange(range))\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Offset\"\n                           :[self findSymbolAtRVA:ivar64_t->offset]];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Name\"\n                           :(symbolName = [self findSymbolAtRVA:ivar64_t->name])];\n    \n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Type\"\n                           :[self findSymbolAtRVA:ivar64_t->type]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Alignment\"\n                           :[NSString stringWithFormat:@\"%u\",ivar64_t->alignment]];\n    \n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Size\"\n                           :[NSString stringWithFormat:@\"%u\",ivar64_t->size]];\n    \n    [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2ClassRONode:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                           classRO:(struct class_ro_t const *)class_ro_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n\n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Class Info: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct class_ro_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n  if (class_ro_t->flags & RO_META) [node.details appendRow:@\"\":@\"\":@\"0x1\":@\"RO_META\"];\n  if (class_ro_t->flags & RO_ROOT) [node.details appendRow:@\"\":@\"\":@\"0x2\":@\"RO_ROOT\"];\n  if (class_ro_t->flags & RO_HAS_CXX_STRUCTORS) [node.details appendRow:@\"\":@\"\":@\"0x4\":@\"RO_HAS_CXX_STRUCTORS\"];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Start\"\n                         :[NSString stringWithFormat:@\"%u\", class_ro_t->instanceStart]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Size\"\n                         :[NSString stringWithFormat:@\"%u\", class_ro_t->instanceSize]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Var Layout\"\n                         :[self findSymbolAtRVA:class_ro_t->ivarLayout]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:class_ro_t->name]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Base Methods\"\n                         :[self findSymbolAtRVA:class_ro_t->baseMethods]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Base Protocols\"\n                         :[self findSymbolAtRVA:class_ro_t->baseProtocols]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Variables\"\n                         :[self findSymbolAtRVA:class_ro_t->ivars]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Weak Instance Var Layout\"\n                         :[self findSymbolAtRVA:class_ro_t->weakIvarLayout]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Base Properties\"\n                         :[self findSymbolAtRVA:class_ro_t->baseProperties]];\n   \n  MVNode * childNode = nil;\n  \n  // Base Methods\n  if (class_ro_t->baseMethods && (childNode = [self sectionNodeContainsRVA:class_ro_t->baseMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:class_ro_t->baseMethods];\n    NSString * caption = [self findSymbolAtRVA:class_ro_t->baseMethods];\n    MATCH_STRUCT(method_list_t,location)\n    [self createObjC2MethodListNode:childNode\n                            caption:caption\n                           location:location\n                            methods:method_list_t];\n  }\n\n  // Base Protocols\n  if (class_ro_t->baseProtocols && (childNode = [self sectionNodeContainsRVA:class_ro_t->baseProtocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:class_ro_t->baseProtocols];\n    NSString * caption = [self findSymbolAtRVA:class_ro_t->baseProtocols];\n    MATCH_STRUCT(protocol_list_t,location)\n    [self createObjC2ProtocolListNode:childNode\n                              caption:caption\n                             location:location\n                            protocols:protocol_list_t];\n  }\n\n  // Instance Variables\n  if (class_ro_t->ivars && (childNode = [self sectionNodeContainsRVA:class_ro_t->ivars]))\n  {\n    uint64_t location = [self RVAToFileOffset:class_ro_t->ivars];\n    NSString * caption = [self findSymbolAtRVA:class_ro_t->ivars];\n    MATCH_STRUCT(ivar_list_t,location)\n    [self createObjC2VariableListNode:childNode\n                              caption:caption\n                             location:location\n                            variables:ivar_list_t];\n  }\n\n  // Base Properties\n  if (class_ro_t->baseProperties && (childNode = [self sectionNodeContainsRVA:class_ro_t->baseProperties]))\n  {\n    uint64_t location = [self RVAToFileOffset:class_ro_t->baseProperties];\n    NSString * caption = [self findSymbolAtRVA:class_ro_t->baseProperties];\n    MATCH_STRUCT(objc_property_list,location)\n    [self createObjC2PropertyListNode:childNode\n                              caption:caption\n                             location:location\n                           properties:objc_property_list];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Class64RONode:(MVNode *)parent\n                             caption:(NSString *)caption\n                            location:(uint64_t)location\n                             classRO:(struct class64_ro_t const *)class64_ro_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Class64 Info: \" stringByAppendingString:caption]\n                               location:location \n                                 length:sizeof(struct class64_ro_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Flags\"\n                         :@\"\"];\n  \n  if (class64_ro_t->flags & RO_META) [node.details appendRow:@\"\":@\"\":@\"0x1\":@\"RO_META\"];\n  if (class64_ro_t->flags & RO_ROOT) [node.details appendRow:@\"\":@\"\":@\"0x2\":@\"RO_ROOT\"];\n  if (class64_ro_t->flags & RO_HAS_CXX_STRUCTORS) [node.details appendRow:@\"\":@\"\":@\"0x4\":@\"RO_HAS_CXX_STRUCTORS\"];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Start\"\n                         :[NSString stringWithFormat:@\"%u\", class64_ro_t->instanceStart]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Size\"\n                         :[NSString stringWithFormat:@\"%u\", class64_ro_t->instanceSize]];\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Reserved\"\n                         :[NSString stringWithFormat:@\"%u\", class64_ro_t->reserved]];\n\n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Var Layout\"\n                         :[self findSymbolAtRVA:class64_ro_t->ivarLayout]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:class64_ro_t->name]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Base Methods\"\n                         :[self findSymbolAtRVA:class64_ro_t->baseMethods]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Base Protocols\"\n                         :[self findSymbolAtRVA:class64_ro_t->baseProtocols]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Variables\"\n                         :[self findSymbolAtRVA:class64_ro_t->ivars]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Weak Instance Var Layout\"\n                         :[self findSymbolAtRVA:class64_ro_t->weakIvarLayout]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Base Properties\"\n                         :[self findSymbolAtRVA:class64_ro_t->baseProperties]];\n  \n  MVNode * childNode = nil;\n  \n  // Base Methods\n  if (class64_ro_t->baseMethods && (childNode = [self sectionNodeContainsRVA:class64_ro_t->baseMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:class64_ro_t->baseMethods];\n    NSString * caption = [self findSymbolAtRVA:class64_ro_t->baseMethods];\n    MATCH_STRUCT(method64_list_t,location)\n    [self createObjC2Method64ListNode:childNode\n                              caption:caption\n                             location:location\n                              methods:method64_list_t];\n  }\n  \n  // Base Protocols\n  if (class64_ro_t->baseProtocols && (childNode = [self sectionNodeContainsRVA:class64_ro_t->baseProtocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:class64_ro_t->baseProtocols];\n    NSString * caption = [self findSymbolAtRVA:class64_ro_t->baseProtocols];\n    MATCH_STRUCT(protocol64_list_t,location)\n    [self createObjC2Protocol64ListNode:childNode\n                                caption:caption\n                               location:location\n                              protocols:protocol64_list_t];\n  }\n  \n  // Instance Variables\n  if (class64_ro_t->ivars && (childNode = [self sectionNodeContainsRVA:class64_ro_t->ivars]))\n  {\n    uint64_t location = [self RVAToFileOffset:class64_ro_t->ivars];\n    NSString * caption = [self findSymbolAtRVA:class64_ro_t->ivars];\n    MATCH_STRUCT(ivar64_list_t,location)\n    [self createObjC2Variable64ListNode:childNode\n                                caption:caption\n                               location:location\n                              variables:ivar64_list_t];\n  }\n  \n  // Base Properties\n  if (class64_ro_t->baseProperties && (childNode = [self sectionNodeContainsRVA:class64_ro_t->baseProperties]))\n  {\n    uint64_t location = [self RVAToFileOffset:class64_ro_t->baseProperties];\n    NSString * caption = [self findSymbolAtRVA:class64_ro_t->baseProperties];\n    MATCH_STRUCT(objc_property64_list,location)\n    [self createObjC2Property64ListNode:childNode\n                                caption:caption\n                               location:location\n                             properties:objc_property64_list];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2ClassNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                           class:(struct class_t const *)class_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Class: \" stringByAppendingString:caption]\n                               location:location\n                                 length:sizeof(struct class_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ISA\"\n                         :[self findSymbolAtRVA:class_t->isa]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Super Class\"\n                         :[self findSymbolAtRVA:class_t->superclass]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Cache\"\n                         :[self findSymbolAtRVA:class_t->cache]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"VTable\"\n                         :[self findSymbolAtRVA:class_t->vtable]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Data\"\n                         :[self findSymbolAtRVA:class_t->data]];\n  \n  MVNode * childNode = nil;\n  \n  // readonly data\n  if (class_t->data && (childNode = [self sectionNodeContainsRVA:class_t->data]))\n  {\n    uint64_t location = [self RVAToFileOffset:class_t->data];\n    NSString * caption = [self findSymbolAtRVA:class_t->data];\n    MATCH_STRUCT(class_ro_t,location)\n    [self createObjC2ClassRONode:childNode\n                         caption:caption\n                        location:location\n                         classRO:class_ro_t];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Class64Node:(MVNode *)parent\n                           caption:(NSString *)caption\n                          location:(uint64_t)location\n                             class:(struct class64_t const *)class64_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Class64: \" stringByAppendingString:caption]\n                               location:location\n                                 length:sizeof(struct class64_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"ISA\"\n                         :[self findSymbolAtRVA:class64_t->isa]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Super Class\"\n                         :[self findSymbolAtRVA:class64_t->superclass]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Cache\"\n                         :[self findSymbolAtRVA:class64_t->cache]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"VTable\"\n                         :[self findSymbolAtRVA:class64_t->vtable]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Data\"\n                         :[self findSymbolAtRVA:class64_t->data]];\n  \n  MVNode * childNode = nil;\n  \n  // readonly data\n  if (class64_t->data && (childNode = [self sectionNodeContainsRVA:class64_t->data]))\n  {\n    uint64_t location = [self RVAToFileOffset:class64_t->data];\n    NSString * caption = [self findSymbolAtRVA:class64_t->data];\n    MATCH_STRUCT(class64_ro_t,location)\n    [self createObjC2Class64RONode:childNode\n                           caption:caption\n                          location:location\n                           classRO:class64_ro_t];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2CategoryNode:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                           category:(struct category_t const *)category_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Category: \" stringByAppendingString:caption]\n                               location:location\n                                 length:sizeof(struct category_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:category_t->name]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class\"\n                         :[self findSymbolAtRVA:category_t->cls]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Methods\"\n                         :[self findSymbolAtRVA:category_t->instanceMethods]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Methods\"\n                         :[self findSymbolAtRVA:category_t->classMethods]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Protocols\"\n                         :[self findSymbolAtRVA:category_t->protocols]];\n\n  [dataController read_uint32:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Properties\"\n                         :[self findSymbolAtRVA:category_t->instanceProperties]];\n\n  MVNode * childNode = nil;\n  \n  // CLS\n  if (category_t->cls && (childNode = [self sectionNodeContainsRVA:category_t->cls]))\n  {\n    uint64_t location = [self RVAToFileOffset:category_t->cls];\n    NSString * caption = [self findSymbolAtRVA:category_t->cls];\n    MATCH_STRUCT(class_t,location)\n    [self createObjC2ClassNode:childNode\n                       caption:caption\n                      location:location\n                         class:class_t];\n  }\n  \n  // Instance Methods\n  if (category_t->instanceMethods && (childNode = [self sectionNodeContainsRVA:category_t->instanceMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:category_t->instanceMethods];\n    NSString * caption = [self findSymbolAtRVA:category_t->instanceMethods];\n    MATCH_STRUCT(method_list_t,location)\n    [self createObjC2MethodListNode:childNode\n                            caption:caption\n                           location:location\n                            methods:method_list_t];\n  }\n\n  // Class Methods\n  if (category_t->classMethods && (childNode = [self sectionNodeContainsRVA:category_t->classMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:category_t->classMethods];\n    NSString * caption = [self findSymbolAtRVA:category_t->classMethods];\n    MATCH_STRUCT(method_list_t,location)\n    [self createObjC2MethodListNode:childNode\n                            caption:caption\n                           location:location\n                            methods:method_list_t];\n  }\n  \n  // Protocols\n  if (category_t->protocols && (childNode = [self sectionNodeContainsRVA:category_t->protocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:category_t->protocols];\n    NSString * caption = [self findSymbolAtRVA:category_t->protocols];\n    MATCH_STRUCT(protocol_list_t,location)\n    [self createObjC2ProtocolListNode:childNode\n                              caption:caption\n                             location:location\n                            protocols:protocol_list_t];\n  }\n  \n  // Instance Properties\n  if (category_t->instanceProperties && (childNode = [self sectionNodeContainsRVA:category_t->instanceProperties]))\n  {\n    uint64_t location = [self RVAToFileOffset:category_t->instanceProperties];\n    NSString * caption = [self findSymbolAtRVA:category_t->instanceProperties];\n    MATCH_STRUCT(objc_property_list,location)\n    [self createObjC2PropertyListNode:childNode\n                              caption:caption\n                             location:location\n                           properties:objc_property_list];\n  }\n  \n  return node;\n}\n  \n//------------------------------------------------------------------------------\n- (MVNode *)createObjC2Category64Node:(MVNode *)parent\n                              caption:(NSString *)caption\n                             location:(uint64_t)location\n                             category:(struct category64_t const *)category64_t\n{  \n  // check for parent\n  if (parent == nil)\n  {\n    return nil;\n  }\n  \n  // check for duplicates\n  MVNode * node = [self entryInSectionNode:parent atLocation:location];\n  if (node != nil)\n  {\n    return node;\n  }\n  \n  MVNodeSaver nodeSaver;\n  node = [parent insertChildWithDetails:[@\"ObjC2 Category64: \" stringByAppendingString:caption]\n                               location:location\n                                 length:sizeof(struct category64_t)\n                                  saver:nodeSaver];\n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Name\"\n                         :[self findSymbolAtRVA:category64_t->name]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"CLS\"\n                         :[self findSymbolAtRVA:category64_t->cls]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Methods\"\n                         :[self findSymbolAtRVA:category64_t->instanceMethods]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Class Methods\"\n                         :[self findSymbolAtRVA:category64_t->classMethods]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Protocols\"\n                         :[self findSymbolAtRVA:category64_t->protocols]];\n  \n  [dataController read_uint64:range lastReadHex:&lastReadHex];\n  [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                         :lastReadHex\n                         :@\"Instance Properties\"\n                         :[self findSymbolAtRVA:category64_t->instanceProperties]];\n  \n  MVNode * childNode = nil;\n  \n  // CLS\n  if (category64_t->cls && (childNode = [self sectionNodeContainsRVA:category64_t->cls]))\n  {\n    uint64_t location = [self RVAToFileOffset:category64_t->cls];\n    NSString * caption = [self findSymbolAtRVA:category64_t->cls];\n    MATCH_STRUCT(class64_t,location)\n    [self createObjC2Class64Node:childNode\n                         caption:caption\n                        location:location\n                           class:class64_t];\n  }\n  \n  // Instance Methods\n  if (category64_t->instanceMethods && (childNode = [self sectionNodeContainsRVA:category64_t->instanceMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:category64_t->instanceMethods];\n    NSString * caption = [self findSymbolAtRVA:category64_t->instanceMethods];\n    MATCH_STRUCT(method64_list_t,location)\n    [self createObjC2Method64ListNode:childNode\n                              caption:caption\n                             location:location\n                              methods:method64_list_t];\n  }\n  \n  // Class Methods\n  if (category64_t->classMethods && (childNode = [self sectionNodeContainsRVA:category64_t->classMethods]))\n  {\n    uint64_t location = [self RVAToFileOffset:category64_t->classMethods];\n    NSString * caption = [self findSymbolAtRVA:category64_t->classMethods];\n    MATCH_STRUCT(method64_list_t,location)\n    [self createObjC2Method64ListNode:childNode\n                              caption:caption\n                             location:location\n                              methods:method64_list_t];\n  }\n  \n  // Protocols\n  if (category64_t->protocols && (childNode = [self sectionNodeContainsRVA:category64_t->protocols]))\n  {\n    uint64_t location = [self RVAToFileOffset:category64_t->protocols];\n    NSString * caption = [self findSymbolAtRVA:category64_t->protocols];\n    MATCH_STRUCT(protocol64_list_t,location)\n    [self createObjC2Protocol64ListNode:childNode\n                                caption:caption\n                               location:location\n                              protocols:protocol64_list_t];\n  }\n  \n  // Instance Properties\n  if (category64_t->instanceProperties && (childNode = [self sectionNodeContainsRVA:category64_t->instanceProperties]))\n  {\n    uint64_t location = [self RVAToFileOffset:category64_t->instanceProperties];\n    NSString * caption = [self findSymbolAtRVA:category64_t->instanceProperties];\n    MATCH_STRUCT(objc_property64_list,location)\n    [self createObjC2Property64ListNode:childNode\n                                caption:caption\n                               location:location\n                             properties:objc_property64_list];\n  }\n  \n  return node;\n}\n\n//------------------------------------------------------------------------------\n-(void)parseObjC2ClassPointers:(PointerVector const *)classes\n              CategoryPointers:(PointerVector const *)categories\n              ProtocolPointers:(PointerVector const *)protocols\n{\n  MVNode * node = nil;\n  \n  for (PointerVector::const_iterator iter = classes->begin(); iter != classes->end(); ++iter)\n  {\n    uint32_t const & rva = *iter;\n    if (rva && (node = [self sectionNodeContainsRVA:rva]))\n    {\n      uint64_t location = [self RVAToFileOffset:rva];\n      NSString * caption = [self findSymbolAtRVA:rva];\n      MATCH_STRUCT(class_t,location)\n      [self createObjC2ClassNode:node\n                         caption:caption\n                        location:location\n                           class:class_t];\n    }\n  }\n\n  for (PointerVector::const_iterator iter = categories->begin(); iter != categories->end(); ++iter)\n  {\n    uint32_t const & rva = *iter;\n    if (rva && (node = [self sectionNodeContainsRVA:rva]))\n    {\n      uint64_t location = [self RVAToFileOffset:rva];\n      NSString * caption = [self findSymbolAtRVA:rva];\n      MATCH_STRUCT(category_t,location)\n      [self createObjC2CategoryNode:node\n                            caption:caption\n                           location:location\n                           category:category_t];\n    }\n  }\n\n  for (PointerVector::const_iterator iter = protocols->begin(); iter != protocols->end(); ++iter)\n  {\n    uint32_t const & rva = *iter;\n    if (rva && (node = [self sectionNodeContainsRVA:rva]))\n    {\n      uint64_t location = [self RVAToFileOffset:rva];\n      NSString * caption = [self findSymbolAtRVA:rva];\n      MATCH_STRUCT(protocol_t,location)\n      [self createObjC2ProtocolNode:node\n                            caption:caption\n                           location:location\n                           protocol:protocol_t];\n    }\n  }\n  \n}\n\n//------------------------------------------------------------------------------\n-(void)parseObjC2Class64Pointers:(Pointer64Vector const *)classes\n              Category64Pointers:(Pointer64Vector const *)categories\n              Protocol64Pointers:(Pointer64Vector const *)protocols\n{\n  MVNode * node = nil;\n  \n  for (Pointer64Vector::const_iterator iter = classes->begin(); iter != classes->end(); ++iter)\n  {\n    uint64_t const & rva64 = *iter;\n    if (rva64 && (node = [self sectionNodeContainsRVA:rva64]))\n    {\n      uint64_t location = [self RVAToFileOffset:rva64];\n      NSString * caption = [self findSymbolAtRVA:rva64];\n      MATCH_STRUCT(class64_t,location)\n      [self createObjC2Class64Node:node\n                           caption:caption\n                          location:location\n                             class:class64_t];\n    }\n  }\n  \n  for (Pointer64Vector::const_iterator iter = categories->begin(); iter != categories->end(); ++iter)\n  {\n    uint64_t const & rva64 = *iter;\n    if (rva64 && (node = [self sectionNodeContainsRVA:rva64]))\n    {\n      uint64_t location = [self RVAToFileOffset:rva64];\n      NSString * caption = [self findSymbolAtRVA:rva64];\n      MATCH_STRUCT(category64_t,location)\n      [self createObjC2Category64Node:node\n                              caption:caption\n                             location:location\n                             category:category64_t];\n    }\n  }\n  \n  for (Pointer64Vector::const_iterator iter = protocols->begin(); iter != protocols->end(); ++iter)\n  {\n    uint64_t const & rva64 = *iter;\n    if (rva64 && (node = [self sectionNodeContainsRVA:rva64]))\n    {\n      uint64_t location = [self RVAToFileOffset:rva64];\n      NSString * caption = [self findSymbolAtRVA:rva64];\n      MATCH_STRUCT(protocol64_t,location)\n      [self createObjC2Protocol64Node:node\n                              caption:caption\n                             location:location\n                             protocol:protocol64_t];\n    }\n  }\n  \n}\n\n@end\n"
        },
        {
          "name": "PreferenceController.h",
          "type": "blob",
          "size": 0.234375,
          "content": "/*\n *  MVPreferenceController.h\n *  MachOView\n *\n *  Created by psaghelyi on 12/24/12.\n *\n */\n\n@interface MVPreferenceController: NSWindowController\n{\n  IBOutlet NSButton *   openAtLaunch;\n}\n\n- (IBAction)toggleOpenAtLaunch:(id)sender;\n\n@end"
        },
        {
          "name": "PreferenceController.mm",
          "type": "blob",
          "size": 0.3408203125,
          "content": "/*\n *  PreferencesWindowController.mm\n *  MachOView\n *\n *  Created by psaghelyi on 12/24/12.\n *\n */\n\n#import \"PreferenceController.h\"\n\n@implementation MVPreferenceController\n\n- (instancetype)init\n{\n  self = [super initWithWindowNibName:@\"Preferences\"];\n  return self;\n}\n\n- (IBAction)toggleOpenAtLaunch:(id)sender\n{\n  // nothing to do here?\n}\n\n@end\n\n"
        },
        {
          "name": "Prefix.pch",
          "type": "blob",
          "size": 0.17578125,
          "content": "//\n// Prefix header for all source files of the 'MachOView' target in the 'MachOView' project\n//\n\n#ifdef __OBJC__\n    #import <Cocoa/Cocoa.h>\n#endif\n\n#include <libkern/OSAtomic.h>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.7021484375,
          "content": "```\n   _____                .__     ____________   ____.__               \n  /     \\ _____    ____ |  |__  \\_____  \\   \\ /   /|__| ______  _  __\n /  \\ /  \\\\__  \\ _/ ___\\|  |  \\  /   |   \\   Y   / |  |/ __ \\ \\/ \\/ /\n/    Y    \\/ __ \\\\  \\___|   Y  \\/    |    \\     /  |  \\  ___/\\     / \n\\____|__  (____  /\\___  >___|  /\\_______  /\\___/   |__|\\___  >\\/\\_/  \n        \\/     \\/     \\/     \\/         \\/                 \\/        \n```\n\n## Update - 16/05/2023\n\nThis code has return from the dead and updated to version 3.0. \n\nVersion 3.0 is now a x86_64/arm64 universal binary, with 10.13+ as the minimum version.\n\nBuilding has been tested with Xcode 13 or higher. The best option is to build with latest available Xcode (14.3) and SDK since I stopped including local copies of latest headers and using the system ones as much as possible. It's annoying to have to use latest version to have all features, but also annoying to keep those headers in sync. This time opting for latest version way.\n\nBesides the universal binary, some bug fixes and small updates were merged, warnings were fixed (and then I found psaghelyi had also done this modernization effort 4 years ago), and Capstone has been updated to next branch to benefit from aarch64 updates. I haven't merged the modern Objective-C syntax since I find it a bit meh. Something I'm thinking of changing is the indent since I'm not a fan of 2 spaces.\n\n### What's the future for this fork and project?\n\nOver the last years I have been puzzled how people kept forking and staring this project on my GitHub despite being dead. I'm using Apple Silicon more often and missed this tool so decided to give it some love again.\n\nThere is still a lot of work ahead to make it better, mostly adding parsing for new and old commands that doesn't exist, and more important for me, making the mach-o parsing way more robust than it is.\n\nI'm still divided on the latter. Blacktop has a nice Go based mach-o parser called [go-macho](https://github.com/blacktop/go-macho) and some months ago I was working on my own fork of it, where I changed the API a bit according to personal taste and more important made the parser a lot more robust (most of the time I'm dealing with potentially hostile binaries so parser security is very important to me). I'm thinking about the possibility of using a sandboxed Go backend and remove all the parsing code from the current codebase. This would be a more secure design and avoid the tedious and error-prone work of fixing the current code. Plus it has the benefit of using a modern codebase that can parse a lot more than the engine being used here right now. \n\nI also have to think about providing binary builds or not since I don't own right now a developer certificate and not counting on getting one and pay Apple's developer tax. \n\nHave fun,  \nfG!\n\n---\n\nA fork from MachOView to update and fix some bugs, mostly Mountain Lion & iOS 6 related.  \nAlso some small changes to the original behaviour.\n\nOriginal MachOView by psaghelyi at [machoview](https://sourceforge.net/projects/machoview/).  \nThanks to psaghelyi for his great work :-)\n\nLatest versions are Lion+ only.  \nThe LLVM disassembler was replaced with Capstone. This eliminates Clang/LLVM packages requirements.  \nThe downside is that Capstone stops disassembling on bad instructions which means that for now data in code and jump tables data will create problems and `__text` section disassembly might be incomplete in binaries that contain such data.  \nCapstone improved disassembly on error but data in code locations are available in header so this can and should be improved.\n\nA static Capstone library extracted from the official DMG is included in the repo.  \nIf you want to be safe you should download Capstone and compile it yourself.\n\nNow features the attach option to analyse headers of a running process.  \nTo use this feature you will need to codesign the binary.  \nFollow this [LLDB guide](https://lldb.llvm.org/resources/build.html?highlight=codesign#code-signing-on-macos) to create the certificate and then codesign MachOView binary.  \n\nThe necessary entitlements are already added to Info.plist.\n\nBe warned that this allows MachOView to have task_for_pid() privs under current under and control every process from user running it.  \nThe whole Mach-O parsing code needs to be reviewed and made more robust.\n\nEnjoy,  \nfG!\n\nNote:\nThis repo is frozen in time and there are kinda active forks out there.  \nThe main problem of this codebase is that the Mach-O parser has quite some problems\nand needs a significant overhaul to make it more robust and secure.  \nI do have much better code but it's under NDAs etc and I don't have energy to reinvent\nthe wheel once again. Secure executable binary parsing is a ton of work in C/C++.  \nIt's possible but it's exhausting.\n"
        },
        {
          "name": "README.orig",
          "type": "blob",
          "size": 3.0869140625,
          "content": "\nHungry Apple icons by Nicholas Boyd (http://loafninja.deviantart.com)\n\ntodo:\n- code sections parsing on demand\n- string table\n\nver 2.4.9200\n- Lots of leaks fixed\n- Updated disassembler from cctools-855\n- Updated llvm disassembler from libLTO OSX10.9\n- ARM64 relocations in detail (need to review)\n- Added new load commands\n\nver 2.4.9000\n- ARM64\n- LC_ENCRYPTION_INFO_64,LC_LINKER_OPTION\n- data in code and entries (DICES)\n- updated disassembler (cctools-845 and LLVM with enhanced symbol table)\n- SDK 10.8 / deploy 10.8\n- fix for multithreaded usage of CoreAnimation\n\nver 2.3.8505\n- updated disassembler (LLVM included for testing)\n- some GUI improvements (PreferencePanel)\n- transitions to __weak references instead of __unsafe_retain\n- SDK 10.8 / deploy 10.6\n- crash fix for disassembling encrypted ARM text sections\n\nver 2.3.8370\n- merge changes from fG!\n  -- do not reopen unclosed binaries\n  -- some new Load Commands\n  -- bugfixes\n\nver 2.3.8345\n- Transition to ARC (but targeting OS X 10.6 for compatibility)\n- FAT binary layout in details\n- LC_ENCRYPTION_INFO,LC_PREBIND_CKSUM,LC_RPATH,LC_FUNCTION_STARTS\n- twolevel swapping for smaller memory usage and better GUI response \n- Better ObjectiveC 2 section parsing\n\nver 2.2.6500\n- objC sections\n- crash fix for concurrent treeView update\n- crash fix for disassembler (could read beyond file data)\n- relocs/bindings stored in a shadow NSData for faster access\n- improved exception records parser\n\nver 2.1.5290\n- mainly bugfixes (relocInfoInfo, static libraries)\n- stop button for cancelling background tasks\n- exception safe symbol/section namelookup\n- disassembler updated to cctools-806\n\nver 2.0.5000 \n- ARM support\n- symbolic disassembling of text sections (based on otool)\n- split segment info in details\n- fast symbol stubs in details\n- improved RAW/RVA switch\n- typelist is fixed in LSDAs\n\nver 1.3.4090\n- some new file types, section types\n- minor fixes\n- indirect symbols showed between squared brackets\n\nver 1.3.4045\n- static libraries (binary archives)\n- dyld info parsing in details\n- base SDK and deploy target detection\n- fix indirect symbol issues in compressed Mach-O files\n- fix treeLock stability (now belongs to dataController not to the layout)\n- display multiply symbols for the same address\n\nver 1.3.3047\n- swapfile based processing to avoid memory overhead for extremely big binaries\n  (note: Ctrl+click toggles swap file usage on the selected node for faster access) \n- two-level namespaces in details\n- export dylibs (e.g.: libSystem.B.dylib)\n- safer symbol/section table access\n\nver 1.2.2632 \n- some command binary representation (dyld info, routines, two-level namespace)\n- better grouping and ordering of parsed content\n- 64bit exception data and relocation fixes\n- more stable name unmangling in tooltips\n\nver 1.2.2200\n- tooltip with unmangled name for all the mangled symbol\n- better section parsing\n- common symbol table for better search (types distinguished by coloured background)\n\nver 1.2.1842:\n- coloured background for special items:\n\tlocal/absolute indirect symbol\n\tscattered relocation\n- edit and save function\n- RVA/RWA offset uses segments' properties for calculation\n"
        },
        {
          "name": "ReadWrite.h",
          "type": "blob",
          "size": 2.951171875,
          "content": "/*\n *  ReadWrite.h\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#import \"DataController.h\"\n@interface MVDataController (ReadWrite)\n\n\n- (uint8_t)     read_uint8:(NSRange &)range;\n- (uint16_t)    read_uint16:(NSRange &)range;  \n- (uint32_t)    read_uint32:(NSRange &)range; \n- (uint64_t)    read_uint64:(NSRange &)range; \n- (int8_t)      read_int8:(NSRange &)range; \n- (int16_t)     read_int16:(NSRange &)range;   \n- (int32_t)     read_int32:(NSRange &)range;  \n- (int64_t)     read_int64:(NSRange &)range;\n\n- (uint8_t)     read_uint8:(NSRange &)range   lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (uint16_t)    read_uint16:(NSRange &)range  lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (uint32_t)    read_uint32:(NSRange &)range  lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (uint64_t)    read_uint64:(NSRange &)range  lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (int8_t)      read_int8:(NSRange &)range    lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (int16_t)     read_int16:(NSRange &)range   lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (int32_t)     read_int32:(NSRange &)range   lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (int64_t)     read_int64:(NSRange &)range   lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n\n- (NSString *)  read_string:(NSRange &)range;\n- (NSString *)  read_string:(NSRange &)range  fixlen:(NSUInteger)len;\n- (NSData *)    read_bytes:(NSRange &)range   length:(NSUInteger)length;\n- (int64_t)     read_sleb128:(NSRange &)range;\n- (uint64_t)    read_uleb128:(NSRange &)range;\n\n- (NSString *)  read_string:(NSRange &)range  lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (NSString *)  read_string:(NSRange &)range  fixlen:(NSUInteger)len lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (NSData *)    read_bytes:(NSRange &)range   length:(NSUInteger)length lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (int64_t)     read_sleb128:(NSRange &)range lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n- (uint64_t)    read_uleb128:(NSRange &)range lastReadHex:(NSString * __autoreleasing *)lastReadHex;\n\n- (void)        write_uint8:(NSUInteger)location data:(uint8_t)data;\n- (void)        write_uint16:(NSUInteger)location data:(uint16_t)data;\n- (void)        write_uint32:(NSUInteger)location data:(uint32_t)data;\n- (void)        write_uint64:(NSUInteger)location data:(uint64_t)data;\n- (void)        write_int8:(NSUInteger)location data:(int8_t)data;\n- (void)        write_int16:(NSUInteger)location data:(int16_t)data;\n- (void)        write_int32:(NSUInteger)location data:(int32_t)data;\n- (void)        write_int64:(NSUInteger)location data:(int64_t)data;\n- (void)        write_string:(NSUInteger)location data:(NSString *)data;\n- (void)        write_bytes:(NSUInteger)location data:(NSData *)data;\n- (void)        write_sleb128:(NSUInteger)location data:(int64_t)data;\n- (void)        write_uleb128:(NSUInteger)location data:(uint64_t)data;\n\n@end\n"
        },
        {
          "name": "ReadWrite.mm",
          "type": "blob",
          "size": 12.6591796875,
          "content": "/*\n *  ReadWrite.mm\n *  MachOView\n *\n *  Created by psaghelyi on 20/07/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#import \"Common.h\"\n#import \"ReadWrite.h\"\n#import \"DataController.h\"\n\n//============================================================================\n@implementation MVDataController (ReadWrite)\n\n//-----------------------------------------------------------------------------\n- (uint8_t)read_uint8:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  uint8_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(uint8_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.2X\",(0xFF & buffer)];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (uint16_t)read_uint16:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  uint16_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(uint16_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.4X\",(0xFFFF & buffer)];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (uint32_t)read_uint32:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  uint32_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(uint32_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.8X\",buffer];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (uint64_t)read_uint64:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  uint64_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(uint64_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.16qX\",buffer];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (int8_t)read_int8:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  int8_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(int8_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.2X\",(0xFF & buffer)];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (int16_t)read_int16:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  int16_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(int16_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.4X\",(0xFFFF & buffer)];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (int32_t)read_int32:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  int32_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(int32_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.8X\",buffer];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (int64_t)read_int64:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  int64_t buffer;\n  range = NSMakeRange(NSMaxRange(range),sizeof(int64_t));\n  [fileData getBytes:&buffer range:range];\n  if (lastReadHex) *lastReadHex = [NSString stringWithFormat:@\"%.16qX\",buffer];\n  [realData getBytes:&buffer range:range];\n  return buffer;\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)getHexStr:(NSRange &)range\n{\n  NSMutableString * lastReadHex = [NSMutableString stringWithCapacity:2*range.length];\n  for (NSUInteger i = 0; i < range.length; ++i)\n  {\n    int value = *((uint8_t *)[fileData bytes] + range.location + i);\n    [lastReadHex appendFormat:@\"%.2X\",value];\n  }\n  return lastReadHex;\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *) replaceEscapeCharsInString: (NSString *)orig\n{\n  NSUInteger len = [orig length];\n  NSMutableString * str = [[NSMutableString alloc] init];\n  SEL sel = @selector(characterAtIndex:);\n  unichar (*charAtIdx)(id, SEL, NSUInteger) = (typeof(charAtIdx)) [orig methodForSelector:sel];\n  for (NSUInteger i = 0; i < len; i++)\n  {\n    unichar c = charAtIdx(orig, sel, i);\n    switch (c)\n    {\n      default:    [str appendFormat:@\"%C\",c]; break;\n      case L'\\f': [str appendString:@\"\\\\f\"]; break; // form feed - new page (byte 0x0c)\n      case L'\\n': [str appendString:@\"\\\\n\"]; break; // line feed - new line (byte 0x0a)\n      case L'\\r': [str appendString:@\"\\\\r\"]; break; // carriage return (byte 0x0d)\n      case L'\\t': [str appendString:@\"\\\\t\"]; break; // horizontal tab (byte 0x09)\n      case L'\\v': [str appendString:@\"\\\\v\"]; break; // vertical tab (byte 0x0b)\n    }\n  }\n  return str;\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)read_string:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  range.location = NSMaxRange(range);\n  NSString * str = NSSTRING((uint8_t *)[fileData bytes] + range.location);\n  range.length = [str length] + 1;\n  if (lastReadHex) *lastReadHex = [self getHexStr:range];\n  return [self replaceEscapeCharsInString:str];\n}\n\n//-----------------------------------------------------------------------------\n- (NSString *)read_string:(NSRange &)range fixlen:(NSUInteger)len lastReadHex:(NSString **)lastReadHex\n{\n  range = NSMakeRange(NSMaxRange(range),len);\n  uint8_t * buffer = (uint8_t *)malloc(len + 1); buffer[len] = '\\0';\n  [fileData getBytes:buffer range:range];\n  if (lastReadHex) *lastReadHex = [self getHexStr:range];\n  NSString * str = NSSTRING(buffer);\n  free (buffer);\n  return [self replaceEscapeCharsInString:str];\n}\n\n//-----------------------------------------------------------------------------\n- (NSData *)read_bytes:(NSRange &)range length:(NSUInteger)length lastReadHex:(NSString **)lastReadHex\n{\n  range = NSMakeRange(NSMaxRange(range),length);\n  uint8_t * buffer = (uint8_t *)malloc(length);\n  [fileData getBytes:buffer range:range];\n  if (lastReadHex) *lastReadHex = [self getHexStr:range];\n  NSData * ret = [NSData dataWithBytes:buffer length:length];\n  free (buffer);\n  return ret;\n}\n\n//-----------------------------------------------------------------------------\n- (int64_t)read_sleb128:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  range.location = NSMaxRange(range);\n  uint8_t * p = (uint8_t *)[fileData bytes] + range.location, *start = p;\n  \n  int64_t result = 0;\n  int bit = 0;\n  uint8_t byte;\n  \n  do {\n    byte = *p++;\n    result |= ((byte & 0x7f) << bit);\n    bit += 7;\n  } while (byte & 0x80);\n  \n  // sign extend negative numbers\n  if ( (byte & 0x40) != 0 )\n  {\n    result |= (-1LL) << bit;\n  }\n  \n  range.length = (p - start);\n  if (lastReadHex) *lastReadHex = [self getHexStr:range];\n  return result;\n}\n\n// ----------------------------------------------------------------------------\n- (uint64_t)read_uleb128:(NSRange &)range lastReadHex:(NSString **)lastReadHex\n{\n  range.location = NSMaxRange(range);\n  uint8_t * p = (uint8_t *)[fileData bytes] + range.location, *start = p;\n  \n  uint64_t result = 0;\n  int bit = 0;\n  \n  do {\n    uint64_t slice = *p & 0x7f;\n    \n    if (bit >= 64 || slice << bit >> bit != slice)\n      [NSException raise:@\"uleb128 error\" format:@\"uleb128 too big\"];\n    else {\n      result |= (slice << bit);\n      bit += 7;\n    }\n  } \n  while (*p++ & 0x80);\n  \n  range.length = (p - start);\n  if (lastReadHex) *lastReadHex = [self getHexStr:range];\n  return result;\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_uint8:(NSUInteger)location data:(uint8_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(uint8_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_uint16:(NSUInteger)location data:(uint16_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(uint16_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_uint32:(NSUInteger)location data:(uint32_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(uint32_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_uint64:(NSUInteger)location data:(uint64_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(uint64_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_int8:(NSUInteger)location data:(int8_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(int8_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_int16:(NSUInteger)location data:(int16_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(int16_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_int32:(NSUInteger)location data:(int32_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(int32_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_int64:(NSUInteger)location data:(int64_t)data\n{\n  [fileData replaceBytesInRange:NSMakeRange(location,sizeof(int64_t)) \n                                     withBytes:&data];\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_string:(NSUInteger)location data:(NSString *)data\n{\n  assert(false);\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_bytes:(NSUInteger)location data:(NSData *)data\n{\n  assert(false);\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_sleb128:(NSUInteger)location data:(int64_t)data\n{\n  assert(false);\n  /*\n   uint8_t * \n   writeSLEB128(uint8_t *p, int64_t value)\n   {\n    bool isNeg = ( value < 0 );\n    uint8_t byte;\n    bool more;\n    do {\n      byte = value & 0x7F;\n      value = value >> 7;\n      if ( isNeg ) \n        more = ( (value != -1) || ((byte & 0x40) == 0) );\n      else\n        more = ( (value != 0) || ((byte & 0x40) != 0) );\n      if ( more )\n        byte |= 0x80;\n      *(p++) = byte;\n    } \n    while( more );\n    return p;\n   }\n   */\n}\n\n// ----------------------------------------------------------------------------\n- (void) write_uleb128:(NSUInteger)location data:(uint64_t)data\n{\n  assert(false);\n  /*\n   uint8_t *\n   writeULEB128 (uint8_t *p, uint64_t value)\n   {\n    uint8_t byte;\n    do {\n      byte = value & 0x7F;\n      value &= ~0x7F;\n      if ( value != 0 )\n        byte |= 0x80;\n      *(p++) = byte;\n      value = value >> 7;\n    } while( byte >= 0x80 );\n   return p;\n   }\n   */\n}\n\n\n\n// ----------------------------------------------------------------------------\n- (uint8_t)read_uint8:(NSRange &)range    { return [self read_uint8:range  lastReadHex:NULL]; }\n- (uint16_t)read_uint16:(NSRange &)range  { return [self read_uint16:range lastReadHex:NULL]; }\n- (uint32_t)read_uint32:(NSRange &)range  { return [self read_uint32:range lastReadHex:NULL]; }\n- (uint64_t)read_uint64:(NSRange &)range  { return [self read_uint64:range lastReadHex:NULL]; }\n- (int8_t)read_int8:(NSRange &)range      { return [self read_int8:range   lastReadHex:NULL]; }\n- (int16_t)read_int16:(NSRange &)range    { return [self read_int16:range  lastReadHex:NULL]; }\n- (int32_t)read_int32:(NSRange &)range    { return [self read_int32:range  lastReadHex:NULL]; }\n- (int64_t)read_int64:(NSRange &)range    { return [self read_int64:range  lastReadHex:NULL]; }\n\n// ----------------------------------------------------------------------------\n- (NSString *)  read_string:(NSRange &)range  { return [self read_string:range lastReadHex:NULL]; }\n- (NSString *)  read_string:(NSRange &)range  fixlen:(NSUInteger)len   { return [self read_string:range fixlen:len lastReadHex:NULL]; }\n- (NSData *)    read_bytes:(NSRange &)range   length:(NSUInteger)length  { return [self read_bytes:range length:length lastReadHex:NULL]; }\n- (int64_t)     read_sleb128:(NSRange &)range  { return [self read_sleb128:range lastReadHex:NULL]; } \n- (uint64_t)    read_uleb128:(NSRange &)range  { return [self read_uleb128:range lastReadHex:NULL]; }\n\n@end\n"
        },
        {
          "name": "SectionContents.h",
          "type": "blob",
          "size": 2.541015625,
          "content": "/*\n *  SectionContents.h\n *  MachOView\n *\n *  Created by psaghelyi on 15/09/2010.\n *\n */\n\n#import \"MachOLayout.h\"\n\n@interface MachOLayout (SectionContents)\n\n- (MVNode *)createPointersNode:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length;\n\n\n- (MVNode *)createPointers64Node:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length;\n\n-(MVNode *)createCStringsNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n                       length:(uint64_t)length;\n\n-(MVNode *)createLiteralsNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n                       length:(uint64_t)length\n                       stride:(uint32_t)stride;\n\n- (MVNode *)createIndPointersNode:(MVNode *)parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length;\n\n- (MVNode *)createIndPointers64Node:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length;\n\n- (MVNode *)createIndStubsNode:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length\n                        stride:(uint32_t)stride;\n\n- (MVNode *)createIndStubs64Node:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n                          stride:(uint32_t)stride;\n\n- (MVNode *)createStubHelperNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length;\n\n- (MVNode *)createTextNode:(MVNode *)parent\n                   caption:(NSString *)caption\n                  location:(uint64_t)location\n                    length:(uint64_t)length\n                    reloff:(uint64_t)reloff\n                    nreloc:(uint32_t)nreloc\n                 extreloff:(uint64_t)extreloff\n                   nextrel:(uint32_t)nextrel\n                 locreloff:(uint64_t)locreloff\n                   nlocrel:(uint32_t)nlocrel;\n\n@end\n"
        },
        {
          "name": "SectionContents.mm",
          "type": "blob",
          "size": 24.5048828125,
          "content": "/*\n *  SectionContents.mm\n *  MachOView\n *\n *  Created by psaghelyi on 15/09/2010.\n *\n */\n\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#import \"Common.h\"\n#import \"SectionContents.h\"\n#import \"CRTFootPrints.h\"\n#import \"ReadWrite.h\"\n#import \"DataController.h\"\n#import \"capstone/include/capstone/capstone.h\"\n#import <mach-o/loader.h>\n\n#define TAB_WIDTH 10\n\nusing namespace std;\n\n//============================================================================\n@implementation MachOLayout (SectionContents)\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createPointersNode:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    uint32_t ptr = [dataController read_uint32:range lastReadHex:&lastReadHex];\n    NSString * symbolName = [NSString stringWithFormat:@\"%@->%@\",\n                             [self findSymbolAtRVA:[self fileOffsetToRVA:range.location]],\n                             [self findSymbolAtRVA:ptr]];\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Pointer\"\n                           :symbolName];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n    \n    [symbolNames setObject:symbolName \n                    forKey:[NSNumber numberWithUnsignedLong:[self fileOffsetToRVA:range.location]]];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createPointers64Node:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    uint64_t ptr = [dataController read_uint64:range lastReadHex:&lastReadHex];\n    NSString * symbolName = [NSString stringWithFormat:@\"%@->%@\",\n                             [self findSymbolAtRVA:[self fileOffsetToRVA:range.location]],\n                             [self findSymbolAtRVA:ptr]];\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Pointer\"\n                           :symbolName];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n    \n    [symbolNames setObject:symbolName \n                    forKey:[NSNumber numberWithUnsignedLongLong:[self fileOffsetToRVA:range.location]]];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n-(MVNode *)createCStringsNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n                       length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    NSString * symbolName = [dataController read_string:range lastReadHex:&lastReadHex];\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :[NSString stringWithFormat:@\"CString (length:%lu)\", [symbolName length]]\n                           :symbolName];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n    \n      // fill in lookup table with C Strings\n      uint64_t rva = [self fileOffsetToRVA:range.location];\n      [symbolNames setObject:[NSString stringWithFormat:@\"0x%qX:\\\"%@\\\"\", rva, symbolName]\n                      forKey:[NSNumber numberWithUnsignedLongLong:rva]];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n-(MVNode *)createLiteralsNode:(MVNode *)parent\n                      caption:(NSString *)caption\n                     location:(uint64_t)location\n                       length:(uint64_t)length\n                       stride:(uint32_t)stride\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    NSData * data = [dataController read_bytes:range length:stride lastReadHex:&lastReadHex];\n\n    NSString * literalStr;\n    switch (stride)\n    {\n      case sizeof(float): \n      {\n        double num = *(float *)[data bytes];\n        literalStr = [NSString stringWithFormat:@\"%.16g\", num];\n      } break;\n      \n      case sizeof(double): \n      {\n        double num = *(double *)[data bytes]; \n        literalStr = [NSString stringWithFormat:@\"%.16g\", num];\n      } break;\n        \n      default:\n#if !defined (__arm64__)\n        // it's 8 for both cases in arm64\n        case sizeof(long double):\n#endif\n        {\n          long double num = *(long double *)[data bytes];\n          literalStr = [NSString stringWithFormat:@\"%.16Lg\", num];\n          break;\n        }\n    }\n    \n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Floating Point Number\"\n                           :literalStr];\n    \n      // fill in lookup table with string literals\n      uint64_t rva = [self fileOffsetToRVA:range.location];\n      [symbolNames setObject:[NSString stringWithFormat:@\"0x%qX:%@f\", rva, literalStr]\n                      forKey:[NSNumber numberWithUnsignedLongLong:rva]];\n  }\n  return node;\n  \n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createIndPointersNode:(MVNode *)parent\n                          caption:(NSString *)caption\n                         location:(uint64_t)location\n                           length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    [dataController read_uint32:range lastReadHex:&lastReadHex];\n    NSString * symbolName = [self findSymbolAtRVA:[self fileOffsetToRVA:range.location]];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Indirect Pointer\"\n                           :symbolName];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createIndPointers64Node:(MVNode *)parent\n                            caption:(NSString *)caption\n                           location:(uint64_t)location\n                             length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    [dataController read_uint64:range lastReadHex:&lastReadHex];\n    NSString * symbolName = [self findSymbolAtRVA:[self fileOffsetToRVA:range.location]];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Indirect Pointer\"\n                           :symbolName];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createIndStubsNode:(MVNode *)parent\n                       caption:(NSString *)caption\n                      location:(uint64_t)location\n                        length:(uint64_t)length\n                        stride:(uint32_t)stride\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    [dataController read_bytes:range length:stride lastReadHex:&lastReadHex];\n    NSString * symbolName = [self findSymbolAtRVA:[self fileOffsetToRVA:range.location]];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Indirect Stub\"\n                           :symbolName];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n  }\n  \n  return node;\n}\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createIndStubs64Node:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n                          stride:(uint32_t)stride\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n\n  while (NSMaxRange(range) < location + length)\n  {\n    [dataController read_bytes:range length:stride lastReadHex:&lastReadHex];\n    NSString * symbolName = [self findSymbolAtRVA:[self fileOffsetToRVA:range.location]];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"Indirect Stub\"\n                           :symbolName];\n    \n    [node.details setAttributes:MVMetaDataAttributeName,symbolName,nil];\n  }\n  \n  return node;\n}\n\n\n//============================= X86 =========================\n//===========================================================\nstatic AsmFootPrint const classicStubHelperX86 =\n{\n\t{1, 0x68}, GAP(4),                        // pushl   $foo$lazy_ptr\n\t{1, 0xE9}, GAP(4),                        // jmp     helperhelper\n};\n\nstatic AsmFootPrint const hybridStubHelperX86 =\n{\n  {1, 0x68}, GAP(4),                        // pushl   $lazy-info-offset\n\t{1, 0x68}, GAP(4),                        // pushl   $foo$lazy_ptr\n\t{1, 0xE9}, GAP(4),                        // jmp     dyld_hybrid_stub_binding_helper\n\t{1, 0x90},                                // nop\n};\n\nstatic AsmFootPrint const hybridStubHelperHelperX86 =\n{\n  {2, 0x83, 0x3D}, GAP(4), {1, 0x00},       // cmpl    $0x00,_fast_lazy_bind\n\t{2, 0x75,\t0x0D},                          // jne     $0x0D\n\t{4, 0x89,\t0x44, 0x24, 0x04},              // movl    %eax,4(%esp)\n\t{1, 0x58},                                // popl    %eax\n\t{3, 0x87, 0x04, 0x24},                    // xchgl   (%esp),%eax\n\t{1, 0xE9}, GAP(4),                        // jmpl    dyld_stub_binding_helper\n\t{3, 0x83, 0xC4, 0x04},                    // addl    $0x04,%esp\n\t{1, 0x68}, GAP(4),                        // pushl   imageloadercache\n\t{2, 0xFF, 0x25}, GAP(4),                  // jmp     *_fast_lazy_bind(%rip)\n};\n\nstatic AsmFootPrint const fastStubHelperX86 =\n{\n  {1, 0x68}, GAP(4),                        // pushl   $lazy-info-offset\n  {1, 0xE9}, GAP(4),                        // jmp     helperhelper\n};\n\nstatic AsmFootPrint const fastStubHelperHelperX86 =\n{\n\t{1, 0x68}, GAP(4),                        // pushl   imageloadercache\n\t{2, 0xFF, 0x25}, GAP(4),                  // jmp     *_fast_lazy_bind\n\t{1, 0x90},                                // nop\n};\n\n//=========================== X86_64 ========================\n//===========================================================\n\nstatic AsmFootPrint const classicStubHelperX86_64 =\n{\n  {3, 0x4C,\t0x8D, 0x1D}, GAP(4),            // lea    foo$lazy_ptr(%rip),%r11\n\t{1, 0xE9}, GAP(4),                        // jmp    dyld_stub_binding_helper\n};\n\n\nstatic AsmFootPrint const hybridStubHelperX86_64 =\n{\n  {1, 0x68}, GAP(4),                        // pushq  $lazy-info-offset\n\t{3, 0x4C, 0x8D, 0x1D}, GAP(4),            // lea    foo$lazy_ptr(%rip),%r11\n\t{1, 0xE9}, GAP(4),                        // jmp    helper-helper\n\t{1, 0x90},                                // nop\n};\n\nstatic AsmFootPrint const hybridStubHelperHelperX86_64 =\n{\n  {3, 0x48, 0x83, 0x3D}, GAP(4), {1, 0x00}, // cmpq   $0x00,_fast_lazy_bind\n\t{2, 0x74,\t0x0F},                          // je     $0x0F\n\t{3, 0x4C, 0x8D,\t0x1D}, GAP(4),            // leaq   imageCache(%rip),%r11\n\t{2, 0x41,\t0x53},                          // pushq  %r11\n\t{2, 0xFF,\t0x25}, GAP(4),                  // jmp    *_fast_lazy_bind(%rip)\n\t{4, 0x48, 0x83, 0xC4, 0x08},              // addq   $8,%rsp\n\t{1, 0xE9}, GAP(4),                        // jmp    dyld_stub_binding_helper\n};\n\n\nstatic AsmFootPrint const fastStubHelperX86_64 =\n{\n  {1, 0x68}, GAP(4),                        // pushq  $lazy-info-offset\n\t{1, 0xE9}, GAP(4),                        // jmp    helperhelper\n};\n\nstatic AsmFootPrint const fastStubHelperHelperX86_64 =\n{\n  {3, 0x4C, 0x8D, 0x1D}, GAP(4),            // leaq   dyld_mageLoaderCache(%rip),%r11\n  {2, 0x41, 0x53},                          // pushq  %r11\n  {2, 0xFF, 0x25}, GAP(4),                  // jmp    *_fast_lazy_bind(%rip)\n  {1, 0x90},                                // nop\n};\n\n//=========================== ARM ===========================\n//===========================================================\nstatic AsmFootPrint const fastStubHelperARM =\n{\n  {4, 0xe5, 0x9f, 0xc0, 0x00},              // ldr  ip, [pc, #0]\n\t{4, 0xea, 0x00, 0x00, 0x00},              // b\t_helperhelper\n  GAP(4),                                   // lazy binding info\n};\n\nstatic AsmFootPrint const fastStubHelperHelperARM =\n{\n  // push lazy-info-offset\n  {4, 0xe5, 0x2d, 0xc0, 0x04},              // str ip, [sp, #-4]!\n  // push address of dyld_mageLoaderCache\n  {4, 0xe5, 0x9f, 0xc0, 0x10},              // ldr\tip, L1\n  {4, 0xe0, 0x8f, 0xc0, 0x0c},              // add\tip, pc, ip\n  {4, 0xe5, 0x2d, 0xc0, 0x04},              // str ip, [sp, #-4]!\n  // jump through _fast_lazy_bind\n  {4, 0xe5, 0x9f, 0xc0, 0x08},              // ldr\tip, L2\n  {4, 0xe0, 0x8f, 0xc0, 0x0c},              // add\tip, pc, ip\n  {4, 0xe5, 0x9c, 0xf0, 0x00},              // ldr\tpc, [ip]\n  GAP(4),                                   // L1: .long fFastStubGOTAtom - (helperhelper+16)\n  GAP(4),                                   // L2: .long _fast_lazy_bind - (helperhelper+28)\n};\n\n\n//-----------------------------------------------------------------------------\n// __stub_helper:\n//\n//  StubHelperHelper\n//  StubHelper\n//  StubHelper\n//  ...\n\n// __symbol_stub1:\n//  FF 25 <relative to indirect>\n//  ...\n//-----------------------------------------------------------------------------\n- (MVNode *)createStubHelperNode:(MVNode *)parent\n                         caption:(NSString *)caption\n                        location:(uint64_t)location\n                          length:(uint64_t)length\n{\n  MVNodeSaver nodeSaver;\n  MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver]; \n  \n  NSRange range = NSMakeRange(location,0);\n  NSString * lastReadHex;\n  \n  NSData * data;\n  uint64_t address;\n\n  if ([self matchAsmAtOffset:range.location \n                asmFootPrint:hybridStubHelperHelperX86 \n                   lineCount:sizeof(hybridStubHelperHelperX86)/FOOTPRINT_STRIDE])\n  {\n    data = [dataController read_bytes:range length:7 lastReadHex:&lastReadHex];\n    address = *(uint32_t *)((uint8_t *)data.bytes + 2);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"cmpl  $0x00,_fast_lazy_bind\"\n                           :[self findSymbolAtRVA:address]];\n\n    [dataController read_bytes:range length:2 lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"jne  $0x0D\"\n                           :@\"\"];\n\n    [dataController read_bytes:range length:4 lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"movl  %eax,4(%esp)\"\n                           :@\"\"];\n\n    [dataController read_bytes:range length:1 lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"popl  %eax\"\n                           :@\"\"];\n\n    [dataController read_bytes:range length:3 lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"xchgl  (%esp),%eax\"\n                           :@\"\"];\n\n    data = [dataController read_bytes:range length:5 lastReadHex:&lastReadHex];\n    address = [self fileOffsetToRVA:NSMaxRange(range) + *(uint32_t *)((uint8_t *)data.bytes + 1)];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"jmpl  dyld_stub_binding_helper\"\n                           :[self findSymbolAtRVA:address]];\n\n    [dataController read_bytes:range length:3 lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"addl  $0x04,%esp\"\n                           :@\"\"];\n\n    data = [dataController read_bytes:range length:5 lastReadHex:&lastReadHex];\n    address = *(uint32_t *)((uint8_t *)data.bytes + 1);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"pushl  imageloadercache\"\n                           :[self findSymbolAtRVA:address]];\n\n    data = [dataController read_bytes:range length:6 lastReadHex:&lastReadHex];\n    address = *(uint32_t *)((uint8_t *)data.bytes + 2);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"jmp  *_fast_lazy_bind(%rip)\"\n                           :[self findSymbolAtRVA:address]];\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n  }\n  else if ([self matchAsmAtOffset:range.location \n                     asmFootPrint:fastStubHelperHelperX86 \n                        lineCount:sizeof(fastStubHelperHelperX86)/FOOTPRINT_STRIDE])\n  {\n    data = [dataController read_bytes:range length:5 lastReadHex:&lastReadHex];\n    address = *(uint32_t *)((uint8_t *)data.bytes + 1);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"pushl  imageloadercache\"\n                           :[self findSymbolAtRVA:address]];\n    \n    data = [dataController read_bytes:range length:6 lastReadHex:&lastReadHex];\n    address = *(uint32_t *)((uint8_t *)data.bytes + 2);\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"jmp  *_fast_lazy_bind\"\n                           :[self findSymbolAtRVA:address]];\n\n    [dataController read_bytes:range length:1 lastReadHex:&lastReadHex];\n    [node.details appendRow:[NSString stringWithFormat:@\"%.8lX\", range.location]\n                           :lastReadHex\n                           :@\"nop\"\n                           :@\"\"];\n    \n    [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    \n  }\n  \n  return node;\n}\n\n\n//-----------------------------------------------------------------------------\n- (MVNode *)createTextNode:(MVNode *)parent\n                   caption:(NSString *)caption\n                  location:(uint64_t)location\n                    length:(uint64_t)length\n                    reloff:(uint64_t)reloff\n                    nreloc:(uint32_t)nreloc\n                 extreloff:(uint64_t)extreloff\n                   nextrel:(uint32_t)nextrel\n                 locreloff:(uint64_t)locreloff\n                   nlocrel:(uint32_t)nlocrel\n{\n    MVNodeSaver nodeSaver;\n    MVNode * node = [parent insertChildWithDetails:caption location:location length:length saver:nodeSaver];\n    \n    // accumulate search info\n    NSUInteger bookmark = node.details.rowCount;\n    NSString * symbolName = nil;\n    \n    if (length == 0) // prevent from attempting to parse zero length sections\n    {\n        return node;\n    }\n    \n    // prepare disassembler params\n    //===========================================================================\n    MATCH_STRUCT(mach_header,imageOffset);\n    \n    char *                    ot_sect = (char*)[dataController.fileData bytes] + location;\n    uint64_t                  ot_left = length;\n    uint64_t                  ot_addr = [self fileOffsetToRVA:location];\n    \n    csh cs_handle = 0;\n    cs_insn *cs_insn = NULL;\n    size_t disasm_count = 0;\n    cs_err cserr;\n    /* open capstone */\n    cs_arch target_arch = CS_ARCH_ALL;\n    cs_mode target_mode = CS_MODE_LITTLE_ENDIAN;\n    switch (mach_header->cputype)\n    {\n        case CPU_TYPE_I386:\n            target_arch = CS_ARCH_X86;\n            target_mode = CS_MODE_32;\n            break;\n        case CPU_TYPE_X86_64:\n            target_arch = CS_ARCH_X86;\n            target_mode = CS_MODE_64;\n            break;\n        case CPU_TYPE_ARM:\n            target_arch = CS_ARCH_ARM;\n            target_mode = CS_MODE_ARM;\n            break;\n        case CPU_TYPE_ARM64:\n            target_arch = CS_ARCH_ARM64;\n            target_mode = CS_MODE_LITTLE_ENDIAN;\n            break;\n        default:\n            NSLog(@\"No CPU found to disassemble!\");\n            return node;\n    }\n    \n    if ( (cserr = cs_open(target_arch, target_mode, &cs_handle)) != CS_ERR_OK )\n    {\n        NSLog(@\"Failed to initialize Capstone: %d, %s.\", cserr, cs_strerror(cs_errno(cs_handle)));\n        return node;\n    }\n    \n    /* set or not thumb mode for 32 bits ARM targets */\n    if (mach_header->cputype == CPU_TYPE_ARM)\n    {\n        switch (mach_header->cpusubtype)\n        {\n            case CPU_SUBTYPE_ARM_V7:\n            case CPU_SUBTYPE_ARM_V7F:\n            case CPU_SUBTYPE_ARM_V7S:\n            case CPU_SUBTYPE_ARM_V7K:\n            case CPU_SUBTYPE_ARM_V8:\n                cs_option(cs_handle, CS_OPT_MODE, CS_MODE_THUMB);\n                break;\n            default:\n                cs_option(cs_handle, CS_OPT_MODE, CS_MODE_ARM);\n                break;\n        }\n    }\n    \n    /* enable detail - we need fields available in detail field */\n    cs_option(cs_handle, CS_OPT_DETAIL, CS_OPT_ON);\n    cs_option(cs_handle, CS_OPT_SKIPDATA, CS_OPT_ON);\n    \n    /* disassemble the whole section */\n    /* this will fail if we have data in code or jump tables because Capstone stops when it can't disassemble */\n    /* a bit of a problem with most binaries :( */\n    /* XXX: parse data in code section to partially solve this */\n    disasm_count = cs_disasm(cs_handle, (const uint8_t *)ot_sect, ot_left, ot_addr, 0, &cs_insn);\n    NSLog(@\"Disassembled %lu instructions.\", disasm_count);\n    uint64_t fileOffset = [self RVAToFileOffset:ot_addr];\n    for (size_t i = 0; i < disasm_count; i++)\n    {\n        /* XXX: replace this bytes retrieval with Capstone internal data since it already contains this info */\n        NSRange range = NSMakeRange(fileOffset,0);\n        NSString * lastReadHex;\n        [dataController read_bytes:range length:cs_insn[i].size lastReadHex:&lastReadHex];\n        /* format the disassembly output using Capstone strings */\n        NSString *asm_string = [NSString stringWithFormat:@\"%-10s\\t%s\", cs_insn[i].mnemonic, cs_insn[i].op_str];\n        [node.details appendRow:[NSString stringWithFormat:@\"%.8qX\", fileOffset]\n                               :lastReadHex\n                               :asm_string\n                               :@\"\"];\n        /* advance to next instruction */\n        fileOffset += cs_insn[i].size;\n    }\n    cs_free(cs_insn, disasm_count);\n    cs_close(&cs_handle);\n    // close last block\n    if (symbolName)\n    {\n        [node.details setAttributesFromRowIndex:bookmark:MVMetaDataAttributeName,symbolName,nil];\n        [node.details setAttributes:MVUnderlineAttributeName,@\"YES\",nil];\n    }\n    \n    return node;\n}\n\n@end\n"
        },
        {
          "name": "capstone",
          "type": "tree",
          "content": null
        },
        {
          "name": "createdmg",
          "type": "blob",
          "size": 0.642578125,
          "content": "#!/bin/bash\n\n#TARGET=Debug\nTARGET=Release\n\n# Build disassembler\ncd otool_disasm\n/usr/bin/xcodebuild -configuration $TARGET\ncp -f build/$TARGET/libdisasm.a ..\ncd ..\n\n# Build MachOView\n/usr/bin/xcodebuild -configuration $TARGET\n\n# Create DMG Installer\nbuildPlist=\"build/\"$TARGET\"/MachOView.app/Contents/Info.plist\"\nCFBuildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBuildNumber\" $buildPlist)\nCFBundleShortVersionString=$(/usr/libexec/PlistBuddy -c \"Print CFBundleShortVersionString\" $buildPlist)\ncp -f README \"build/\"$TARGET\n\nhdiutil create -fs HFS+ -volname \"MachOView\" -srcfolder \"build/\"$TARGET \"MachOView-\"$CFBundleShortVersionString.$CFBuildNumber\".dmg\"\n"
        },
        {
          "name": "en.lproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "greenApple.icns",
          "type": "blob",
          "size": 328.9794921875,
          "content": null
        },
        {
          "name": "mach-o",
          "type": "tree",
          "content": null
        },
        {
          "name": "machoview.xcodeproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.mm",
          "type": "blob",
          "size": 0.3349609375,
          "content": "//\n//  main.m\n//  MachOView\n//\n//  Created by psaghelyi on 10/06/2010.\n//\n\n\n// every std IO operation needs to be paused until pipes are in use\nNSCondition * pipeCondition;\nint32_t numIOThread;\n\nint \nmain(int argc, const char *argv[])\n{\n  pipeCondition = [[NSCondition alloc]init];\n  numIOThread = 0;\n  return NSApplicationMain(argc, argv);\n}\n"
        },
        {
          "name": "redApple.icns",
          "type": "blob",
          "size": 365.59765625,
          "content": null
        },
        {
          "name": "stop.png",
          "type": "blob",
          "size": 1.34375,
          "content": null
        }
      ]
    }
  ]
}