{
  "metadata": {
    "timestamp": 1736710189827,
    "page": 883,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vinniefalco/LuaBridge",
      "stars": 1657,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 1.9609375,
          "content": "---\nAccessModifierOffset: -4\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: DontAlign\nAlignOperands: true\nAlignTrailingComments: false\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: InlineOnly\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: true\nBinPackArguments: false\nBinPackParameters: false\nBraceWrapping:\n  AfterClass: true\n  AfterControlStatement: true\n  AfterEnum: true\n  AfterFunction: true\n  AfterNamespace: false\n  AfterStruct: true\n  AfterUnion: true\n  BeforeCatch: true\n  BeforeElse: true\n  IndentBraces: false\n  SplitEmptyFunction: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Custom\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializers: BeforeComma\nBreakStringLiterals: true\nColumnLimit: 100\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: true\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat: false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: true\nIndentCaseLabels: false\nIndentWidth: 4\nIndentWrappedFunctionNames: false\nKeepEmptyLinesAtTheStartOfBlocks: false\nLanguage: Cpp\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nPointerAlignment: Left\nReflowComments: true\nSortIncludes: true\nSortUsingDeclarations: true\nSpaceAfterCStyleCast: true\nSpaceAfterTemplateKeyword: false\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles: false\nSpacesInCStyleCastParentheses: false\nSpacesInContainerLiterals: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard: Cpp11\nTabWidth: 4\nUseTab: Never\n\n...\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.01171875,
          "content": "* text=auto\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1298828125,
          "content": "Documentation\n*.swp\nMakefile\nCMakeCache.txt\nCMakeFiles/\n*.dir/\n*.cmake\n*.sln\n*.vcxproj\n*.vcxproj.filters\n*.vcxproj.user\n.vs/\n.vscode\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.103515625,
          "content": "[submodule \"third_party/gtest\"]\n\tpath = third_party/gtest\n\turl = https://github.com/google/googletest.git\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 3.365234375,
          "content": "## Version 2.9\n\n* Added stack traits for `std::pair` (`Pair.h`).\n* Added `isInstance()` function specialization for `std::array`.\n* Added Meson bulid support.\n* Added CMake rules for packaging.\n\n## Version 2.8\n\n* Added convenience `get()` function template.\n* Fixed inconsistent `Stack<int>::isInstance()` behavior.\n* Fixed bug in the `Stack<Nil>::isInstance()`.\n\n## Version 2.7\n\n* Added  `std::string_view` stack traits (`LUABRIDGE_CXX17` must be defined).\n* Added  `std::optional` support (`Optional.h`).\n* Fixed `RefCountedPtr` issues.\n\n## Version 2.6\n\n* Added namespace `addFunction()` accepting `std::function` (C++11 only).\n* Added class `addStaticFunction()` accepting `std::function` (C++11 only).\n* Updated the Doxygen documentation.\n* Added brief API reference into the manual.\n* Hidden non-public `luabridge` members into the `detail` namespace.\n* Fixed stack cleanup by `LuaRef::isInstance()` method.\n\n## Version 2.5\n\n* Introduce stack `isInstance()` method.\n* Introduce LuaRef `isInstance()` method.\n* Added a convenience `isInstance()` function template.\n\n## Version 2.4.1\n\n* Do not call the object destructor then its constructor throws.\n\n## Version 2.4\n\n* String stack get specialization doesn't change the stack value anymore.\n* Added namespace `addProperty()` accepting C-functions.\n* Introduced enableExceptions function.\n\n## Version 2.3.2\n\n* Fixed registration continuation for an already registered class.\n\n## Version 2.3.1\n\n* Fixed registration continuation issues.\n\n## Version 2.3\n\n* Added class `addFunction()` accepting proxy functions (C++11 only).\n* Added class `addFunction()` accepting `std::function` (C++11 only).\n* Added class `addProperty()` accepting functions with lua_State* parameter.\n* Added class `addProperty()` accepting `std::function` (C++11 only).\n* Added stack traits for `std::unordered_map` (`UnorderedMap.h`).\n* Now using lightuserdata for function pointers.\n\n## Version 2.2.2\n\n* Performance optimization.\n\n## Version 2.2.1\n\n* Refactored namespace and class handling.\n\n## Version 2.2\n\n* Refactored stack operations.\n* Handle exceptions in stack operations.\n\n## Version 2.1.2\n\n* Added `operator==` and `operator!=` for `RefCountedPtr` template.\n\n## Version 2.1.1\n\n* Support for `__stdcall` function pointers.\n\n## Version 2.1\n\n* Added stack traits for `std::vector` (`Vector.h`).\n* Added stack traits for `std::list` (`List.h`).\n* Added stack traits for `std::map` (`Map.h`).\n* Added ability to use `LuaRef` objects as an `std::map` keys.\n* Fixed some manual errata.\n\n## Version 2.0\n\n* Numerous bug fixes.\n* Feature Requests from Github issues.\n* Added `LuaRef` object.\n* Rewritten documentation.\n\n## Version 1.1.0\n\n* Split code up into several files.\n* Added Lua table and type representations (based on Nigel's code).\n* Reformatted documentation as external HTML file.\n\n## Version 1.0.3\n\n* Pass `nil` to Lua when a null pointer is passed for objects with shared lifetime.\n\n## Version 1.0.2\n\n* Option to hide metatables selectable at runtime, default to true.\n* `addStaticMethod()` renamed to `addStaticFunction()` for consistency.\n* `addMethod()` renamed to `addFunction()` for consistency.\n* `addCFunction()` registrations.\n* Convert null pointers to and from `nil`.\n* Small performance increase in class pointer extraction.\n\n## Version 1.0.1\n\n* Backward compatibility with Lua 5.1.x.\n\n## Version 1.0\n\n* Explicit lifetime management models.\n* Generalized containers.\n* Single header distribution.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.96484375,
          "content": "cmake_minimum_required(VERSION 3.5)\n\nproject(LuaBridge)\n\ninclude(CMakeDependentOption)\n\noption(LUABRIDGE_CXX17 \"Use C++17 standard if supported by compiler\" OFF)\n\nif(LUABRIDGE_CXX17)\n    set(CMAKE_CXX_STANDARD 17)\nelse()\n    set(CMAKE_CXX_STANDARD 11)\nendif()\n\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\ncmake_dependent_option(LUABRIDGE_TESTING \"Build tests\" ON\n    \"CMAKE_SOURCE_DIR STREQUAL PROJECT_SOURCE_DIR\" OFF\n)\n\nif(WIN32)\n    add_compile_options(/MP)\nendif()\n\nadd_subdirectory(Source)\n\nif(LUABRIDGE_TESTING)\n    find_package(GTest)\n    if(NOT GTest_FOUND)\n        set(gtest_force_shared_crt ON CACHE BOOL \"Use /MD and /MDd\" FORCE)\n        add_subdirectory(third_party/gtest EXCLUDE_FROM_ALL)\n        add_library(GTest::gtest ALIAS gtest)\n    endif()\n\n    enable_testing()\n    add_subdirectory(Tests)\nendif()\n\nadd_custom_target(Documentation SOURCES\n    .github/workflows/cmake.yml\n    CHANGES.md\n    README.md\n    Doxyfile\n    index.html\n    Manual.html\n)\n"
        },
        {
          "name": "Doxyfile",
          "type": "blob",
          "size": 11.029296875,
          "content": "# Doxyfile 1.8.13\n\n#---------------------------------------------------------------------------\n# Project related configuration options\n#---------------------------------------------------------------------------\nDOXYFILE_ENCODING      = UTF-8\nPROJECT_NAME           = LuaBridge\nPROJECT_NUMBER         =\nPROJECT_BRIEF          =\nPROJECT_LOGO           =\nOUTPUT_DIRECTORY       =\nCREATE_SUBDIRS         = NO\nALLOW_UNICODE_NAMES    = NO\nOUTPUT_LANGUAGE        = English\nBRIEF_MEMBER_DESC      = YES\nREPEAT_BRIEF           = NO\nABBREVIATE_BRIEF       =\nALWAYS_DETAILED_SEC    = NO\nINLINE_INHERITED_MEMB  = YES\nFULL_PATH_NAMES        = NO\nSTRIP_FROM_PATH        =\nSTRIP_FROM_INC_PATH    =\nSHORT_NAMES            = NO\nJAVADOC_AUTOBRIEF      = NO\nQT_AUTOBRIEF           = NO\nMULTILINE_CPP_IS_BRIEF = NO\nINHERIT_DOCS           = YES\nSEPARATE_MEMBER_PAGES  = NO\nTAB_SIZE               = 4\nALIASES                =\nTCL_SUBST              =\nOPTIMIZE_OUTPUT_FOR_C  = NO\nOPTIMIZE_OUTPUT_JAVA   = NO\nOPTIMIZE_FOR_FORTRAN   = NO\nOPTIMIZE_OUTPUT_VHDL   = NO\nEXTENSION_MAPPING      =\nMARKDOWN_SUPPORT       = YES\nTOC_INCLUDE_HEADINGS   = 0\nAUTOLINK_SUPPORT       = YES\nBUILTIN_STL_SUPPORT    = YES\nCPP_CLI_SUPPORT        = NO\nSIP_SUPPORT            = NO\nIDL_PROPERTY_SUPPORT   = YES\nDISTRIBUTE_GROUP_DOC   = NO\nGROUP_NESTED_COMPOUNDS = NO\nSUBGROUPING            = YES\nINLINE_GROUPED_CLASSES = NO\nINLINE_SIMPLE_STRUCTS  = NO\nTYPEDEF_HIDES_STRUCT   = NO\nLOOKUP_CACHE_SIZE      = 0\n#---------------------------------------------------------------------------\n# Build related configuration options\n#---------------------------------------------------------------------------\nEXTRACT_ALL            = NO\nEXTRACT_PRIVATE        = YES\nEXTRACT_PACKAGE        = NO\nEXTRACT_STATIC         = NO\nEXTRACT_LOCAL_CLASSES  = NO\nEXTRACT_LOCAL_METHODS  = NO\nEXTRACT_ANON_NSPACES   = NO\nHIDE_UNDOC_MEMBERS     = NO\nHIDE_UNDOC_CLASSES     = NO\nHIDE_FRIEND_COMPOUNDS  = NO\nHIDE_IN_BODY_DOCS      = NO\nINTERNAL_DOCS          = NO\nCASE_SENSE_NAMES       = NO\nHIDE_SCOPE_NAMES       = NO\nHIDE_COMPOUND_REFERENCE= NO\nSHOW_INCLUDE_FILES     = NO\nSHOW_GROUPED_MEMB_INC  = NO\nFORCE_LOCAL_INCLUDES   = NO\nINLINE_INFO            = NO\nSORT_MEMBER_DOCS       = NO\nSORT_BRIEF_DOCS        = NO\nSORT_MEMBERS_CTORS_1ST = YES\nSORT_GROUP_NAMES       = YES\nSORT_BY_SCOPE_NAME     = YES\nSTRICT_PROTO_MATCHING  = NO\nGENERATE_TODOLIST      = NO\nGENERATE_TESTLIST      = NO\nGENERATE_BUGLIST       = NO\nGENERATE_DEPRECATEDLIST= NO\nENABLED_SECTIONS       =\nMAX_INITIALIZER_LINES  = 30\nSHOW_USED_FILES        = NO\nSHOW_FILES             = NO\nSHOW_NAMESPACES        = NO\nFILE_VERSION_FILTER    =\nLAYOUT_FILE            =\nCITE_BIB_FILES         =\n#---------------------------------------------------------------------------\n# Configuration options related to warning and progress messages\n#---------------------------------------------------------------------------\nQUIET                  = YES\nWARNINGS               = YES\nWARN_IF_UNDOCUMENTED   = YES\nWARN_IF_DOC_ERROR      = YES\nWARN_NO_PARAMDOC       = YES\nWARN_AS_ERROR          = NO\nWARN_FORMAT            = \"$file:$line: $text\"\nWARN_LOGFILE           =\n#---------------------------------------------------------------------------\n# Configuration options related to the input files\n#---------------------------------------------------------------------------\nINPUT                  = Source\nINPUT_ENCODING         = UTF-8\nFILE_PATTERNS          = *.c \\\n                         *.cpp \\\n                         *.h \\\n                         *.hpp\nRECURSIVE              = YES\nEXCLUDE                =\nEXCLUDE_SYMLINKS       = NO\nEXCLUDE_PATTERNS       =\nEXCLUDE_SYMBOLS        = luabridge::detail::*\nEXAMPLE_PATH           =\nEXAMPLE_PATTERNS       = *\nEXAMPLE_RECURSIVE      = NO\nIMAGE_PATH             =\nINPUT_FILTER           =\nFILTER_PATTERNS        =\nFILTER_SOURCE_FILES    = NO\nFILTER_SOURCE_PATTERNS =\nUSE_MDFILE_AS_MAINPAGE =\n#---------------------------------------------------------------------------\n# Configuration options related to source browsing\n#---------------------------------------------------------------------------\nSOURCE_BROWSER         = NO\nINLINE_SOURCES         = NO\nSTRIP_CODE_COMMENTS    = YES\nREFERENCED_BY_RELATION = NO\nREFERENCES_RELATION    = NO\nREFERENCES_LINK_SOURCE = YES\nSOURCE_TOOLTIPS        = YES\nUSE_HTAGS              = NO\nVERBATIM_HEADERS       = NO\nCLANG_ASSISTED_PARSING = NO\nCLANG_OPTIONS          =\n#---------------------------------------------------------------------------\n# Configuration options related to the alphabetical class index\n#---------------------------------------------------------------------------\nALPHABETICAL_INDEX     = NO\nCOLS_IN_ALPHA_INDEX    = 5\nIGNORE_PREFIX          =\n#---------------------------------------------------------------------------\n# Configuration options related to the HTML output\n#---------------------------------------------------------------------------\nGENERATE_HTML          = YES\nHTML_OUTPUT            = Documentation\nHTML_FILE_EXTENSION    = .html\nHTML_HEADER            =\nHTML_FOOTER            =\nHTML_STYLESHEET        =\nHTML_EXTRA_STYLESHEET  =\nHTML_EXTRA_FILES       =\nHTML_COLORSTYLE_HUE    = 240\nHTML_COLORSTYLE_SAT    = 64\nHTML_COLORSTYLE_GAMMA  = 80\nHTML_TIMESTAMP         = NO\nHTML_DYNAMIC_SECTIONS  = NO\nHTML_INDEX_NUM_ENTRIES = 100\nGENERATE_DOCSET        = NO\nDOCSET_FEEDNAME        = \"Doxygen generated docs\"\nDOCSET_BUNDLE_ID       = org.doxygen.Project\nDOCSET_PUBLISHER_ID    = org.doxygen.Publisher\nDOCSET_PUBLISHER_NAME  = Publisher\nGENERATE_HTMLHELP      = NO\nCHM_FILE               =\nHHC_LOCATION           =\nGENERATE_CHI           = NO\nCHM_INDEX_ENCODING     =\nBINARY_TOC             = NO\nTOC_EXPAND             = NO\nGENERATE_QHP           = NO\nQCH_FILE               =\nQHP_NAMESPACE          = org.doxygen.Project\nQHP_VIRTUAL_FOLDER     = doc\nQHP_CUST_FILTER_NAME   =\nQHP_CUST_FILTER_ATTRS  =\nQHP_SECT_FILTER_ATTRS  =\nQHG_LOCATION           =\nGENERATE_ECLIPSEHELP   = NO\nECLIPSE_DOC_ID         = org.doxygen.Project\nDISABLE_INDEX          = NO\nGENERATE_TREEVIEW      = YES\nENUM_VALUES_PER_LINE   = 4\nTREEVIEW_WIDTH         = 250\nEXT_LINKS_IN_WINDOW    = NO\nFORMULA_FONTSIZE       = 10\nFORMULA_TRANSPARENT    = YES\nUSE_MATHJAX            = NO\nMATHJAX_FORMAT         = HTML-CSS\nMATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest\nMATHJAX_EXTENSIONS     =\nMATHJAX_CODEFILE       =\nSEARCHENGINE           = YES\nSERVER_BASED_SEARCH    = NO\nEXTERNAL_SEARCH        = NO\nSEARCHENGINE_URL       =\nSEARCHDATA_FILE        = searchdata.xml\nEXTERNAL_SEARCH_ID     =\nEXTRA_SEARCH_MAPPINGS  =\n#---------------------------------------------------------------------------\n# Configuration options related to the LaTeX output\n#---------------------------------------------------------------------------\nGENERATE_LATEX         = NO\nLATEX_OUTPUT           = latex\nLATEX_CMD_NAME         = latex\nMAKEINDEX_CMD_NAME     = makeindex\nCOMPACT_LATEX          = NO\nPAPER_TYPE             = a4\nEXTRA_PACKAGES         =\nLATEX_HEADER           =\nLATEX_FOOTER           =\nLATEX_EXTRA_STYLESHEET =\nLATEX_EXTRA_FILES      =\nPDF_HYPERLINKS         = YES\nUSE_PDFLATEX           = YES\nLATEX_BATCHMODE        = NO\nLATEX_HIDE_INDICES     = NO\nLATEX_SOURCE_CODE      = NO\nLATEX_BIB_STYLE        = plain\nLATEX_TIMESTAMP        = NO\n#---------------------------------------------------------------------------\n# Configuration options related to the RTF output\n#---------------------------------------------------------------------------\nGENERATE_RTF           = NO\nRTF_OUTPUT             = rtf\nCOMPACT_RTF            = NO\nRTF_HYPERLINKS         = NO\nRTF_STYLESHEET_FILE    =\nRTF_EXTENSIONS_FILE    =\nRTF_SOURCE_CODE        = NO\n#---------------------------------------------------------------------------\n# Configuration options related to the man page output\n#---------------------------------------------------------------------------\nGENERATE_MAN           = NO\nMAN_OUTPUT             = man\nMAN_EXTENSION          = .3\nMAN_SUBDIR             =\nMAN_LINKS              = NO\n#---------------------------------------------------------------------------\n# Configuration options related to the XML output\n#---------------------------------------------------------------------------\nGENERATE_XML           = NO\nXML_OUTPUT             = xml\nXML_PROGRAMLISTING     = YES\n#---------------------------------------------------------------------------\n# Configuration options related to the DOCBOOK output\n#---------------------------------------------------------------------------\nGENERATE_DOCBOOK       = NO\nDOCBOOK_OUTPUT         = docbook\nDOCBOOK_PROGRAMLISTING = NO\n#---------------------------------------------------------------------------\n# Configuration options for the AutoGen Definitions output\n#---------------------------------------------------------------------------\nGENERATE_AUTOGEN_DEF   = NO\n#---------------------------------------------------------------------------\n# Configuration options related to the Perl module output\n#---------------------------------------------------------------------------\nGENERATE_PERLMOD       = NO\nPERLMOD_LATEX          = NO\nPERLMOD_PRETTY         = YES\nPERLMOD_MAKEVAR_PREFIX =\n#---------------------------------------------------------------------------\n# Configuration options related to the preprocessor\n#---------------------------------------------------------------------------\nENABLE_PREPROCESSING   = YES\nMACRO_EXPANSION        = NO\nEXPAND_ONLY_PREDEF     = NO\nSEARCH_INCLUDES        = NO\nINCLUDE_PATH           =\nINCLUDE_FILE_PATTERNS  =\nPREDEFINED             = WIN32 \\\n                         = \\\n                         1\nEXPAND_AS_DEFINED      =\nSKIP_FUNCTION_MACROS   = YES\n#---------------------------------------------------------------------------\n# Configuration options related to external references\n#---------------------------------------------------------------------------\nTAGFILES               =\nGENERATE_TAGFILE       =\nALLEXTERNALS           = NO\nEXTERNAL_GROUPS        = YES\nEXTERNAL_PAGES         = YES\nPERL_PATH              = /bin/perl\n#---------------------------------------------------------------------------\n# Configuration options related to the dot tool\n#---------------------------------------------------------------------------\nCLASS_DIAGRAMS         = NO\nMSCGEN_PATH            =\nDIA_PATH               =\nHIDE_UNDOC_RELATIONS   = YES\nHAVE_DOT               = NO\nDOT_NUM_THREADS        = 0\nDOT_FONTNAME           = Helvetica\nDOT_FONTSIZE           = 10\nDOT_FONTPATH           =\nCLASS_GRAPH            = YES\nCOLLABORATION_GRAPH    = YES\nGROUP_GRAPHS           = YES\nUML_LOOK               = NO\nUML_LIMIT_NUM_FIELDS   = 10\nTEMPLATE_RELATIONS     = NO\nINCLUDE_GRAPH          = YES\nINCLUDED_BY_GRAPH      = YES\nCALL_GRAPH             = NO\nCALLER_GRAPH           = NO\nGRAPHICAL_HIERARCHY    = YES\nDIRECTORY_GRAPH        = YES\nDOT_IMAGE_FORMAT       = png\nINTERACTIVE_SVG        = NO\nDOT_PATH               =\nDOTFILE_DIRS           =\nMSCFILE_DIRS           =\nDIAFILE_DIRS           =\nPLANTUML_JAR_PATH      =\nPLANTUML_CFG_FILE      =\nPLANTUML_INCLUDE_PATH  =\nDOT_GRAPH_MAX_NODES    = 50\nMAX_DOT_GRAPH_DEPTH    = 0\nDOT_TRANSPARENT        = NO\nDOT_MULTI_TARGETS      = NO\nGENERATE_LEGEND        = YES\nDOT_CLEANUP            = YES\n"
        },
        {
          "name": "Manual.html",
          "type": "blob",
          "size": 63.6259765625,
          "content": "<!doctype html>\n<html>\n<head>\n<title>LuaBridge 2.8 Reference Manual</title>\n<META HTTP-EQUIV=\"content-type\" CONTENT=\"text/html; charset=iso-8859-1\">\n\n<!--=========================================================================-->\n<style TYPE=\"text/css\">\n\nbody {\n  color: #000000 ;\n  background-color: #FFFFFF ;\n  font-family: Helvetica, Arial, sans-serif ;\n  text-align: justify ;\n  margin-right: 30px ;\n  margin-left: 30px ;\n}\n\nh1, h2, h3, h4 {\n  font-family: Verdana, Geneva, sans-serif ;\n  font-weight: normal ;\n  font-style: normal ;\n}\n\nh1 {\n  padding-top: 0.4em ;\n  padding-bottom: 0.4em ;\n  padding-left: 24px ;\n  margin-left: -24px ;\n  background-color: #ffe668 ;\n  border-radius: 8px ;\n}\n\nh2 {\n  padding-top: 0.4em ;\n  padding-bottom: 0.4em ;\n  padding-left: 1em ;\n  padding-right: 1em ;\n  background-color: #ffe668 ;\n  border-radius: 8px ;\n}\n\nh3 {\n  padding-left: 0.5em ;\n  border-left: solid #ffe668 1em ;\n}\n\na:link {\n  color: #8d5c00 ;\n  background-color: inherit ;\n  text-decoration: none ;\n}\n\na:visited {\n  color: #b17b26;\n  background-color: inherit ;\n  text-decoration: none ;\n}\n\na:link:hover, a:visited:hover {\n  color: #8d5c00 ;\n  background-color: #ffe668 ;\n}\n\na:link:active, a:visited:active {\n  color: inherit;\n}\n\nhr {\n  border: 0 ;\n  height: 1px ;\n  color: #a0a0a0 ;\n  background-color: #a0a0a0 ;\n}\n\n:target {\n  background-color: #F8F8F8 ;\n  padding-top: 2px ;\n  padding-bottom: 2px ;\n  padding-left: 8px;\n  padding-right: 8px;\n  border: solid #a0a0a0 2px ;\n}\n\n.footer {\n  color: gray ;\n  font-size: small ;\n}\n\nul {\n  list-style-type: none ;\n  list-style-position: outside ;\n}\n\nul.bullets {\n  list-style-type: disc ;\n}\n\nimg {\n  border: 0;\n}\n\ntable {\n  margin-left: 2em;\n}\n\npre, code {\n  font-size: 12pt ;\n}\n\npre {\n  margin-left: 2em;\n}\n\npre.split {\n  padding-left: 2em;\n  display: table-cell ;\n  white-space: pre-wrap ;\n  vertical-align: text-top ;\n  padding-right: 2em;\n}\n\npre.split + pre.split {\n  border-left: 1px solid #ccc;\n}\n\n</style>\n\n</head>\n\n<!--=========================================================================-->\n\n<body>\n\n<header>\n<hr>\n<h1>LuaBridge 2.8 Reference Manual</h1>\n<hr>\n</header>\n\n<small>\nOfficial repository is located at\n<a href=\"https://github.com/vinniefalco/LuaBridge\">https://github.com/vinniefalco/LuaBridge</a>.\n<br>\nCopyright &copy; 2012 Vinnie Falco. Freely available under the terms of the\n<a href=\"http://www.opensource.org/licenses/mit-license.html\">MIT License</a>.\n</small>\n\n<nav>\n<h2>Contents</h2>\n<UL id=\"toc\" style=\"padding: 0\">\n<li><A href=\"#s1\">1 - Introduction</A>\n<ul>\n  <li><A href=\"#s1.1\">1.1 - Design</A>\n  <li><A href=\"#s1.2\">1.2 - Repository</A>\n  <li><A href=\"#s1.3\">1.3 - License and Credits</A>\n</ul>\n<p>\n<li><A href=\"#s2\">2 - Accessing C++ from Lua</A>\n<ul>\n  <li><A href=\"#s2.1\">2.1 - Namespaces</A>\n  <li><A href=\"#s2.2\">2.2 - Data, Properties, Functions, and CFunctions</A>\n  <li><A href=\"#s2.3\">2.3 - Class Objects</A>\n  <li><A href=\"#s2.4\">2.4 - Property Member Proxies</A>\n  <li><A href=\"#s2.5\">2.5 - Function Member Proxies</A>\n  <li><A href=\"#s2.6\">2.6 - Constructors</A>\n  <li><A href=\"#s2.7\">2.7 - Lua Stack</A>\n  <li><A href=\"#s2.8\">2.8 - lua_State</A>\n</ul>\n<p>\n<li><A href=\"#s3\">3 - Passing Objects</A>\n<ul>\n  <li><A href=\"#s3.1\">3.1 - C++ Lifetime</A>\n  <li><A href=\"#s3.2\">3.2 - Lua Lifetime</A>\n  <li><A href=\"#s3.3\">3.3 - Pointers, References, and Pass by Value</A>\n  <li><A href=\"#s3.4\">3.4 - Shared Lifetime</A>\n  <ul>\n    <li><A href=\"#s3.4.1\">3.4.1 - Class RefCountedObjectPtr</A>\n    <li><A href=\"#s3.4.2\">3.4.2 - Class RefCountedPtr</A>\n    <li><A href=\"#s3.4.3\">3.4.3 - User-defined Containers</A>\n    <li><A href=\"#s3.4.4\">3.4.4 - Container Constructors</A>\n  </ul>\n  <li><A href=\"#s3.5\">3.5 - Mixing Lifetimes</A>\n  <li><A href=\"#s3.6\">3.6 - Convenience Functions</A>\n</ul>\n<p>\n<li><A href=\"#s4\">4 - Accessing Lua from C++</A>\n<ul>\n  <li><A href=\"#s4.1\">4.1 - Class LuaRef</A>\n  <ul>\n    <li><A href=\"#s4.1.1\">4.1.1 - Type Conversions</A>\n    <li><A href=\"#s4.1.2\">4.1.2 - Visual Studio 2010, 2012</A>\n  </ul>\n  <li><A href=\"#s4.2\">4.2 - Table Proxies</A>\n  <li><A href=\"#s4.3\">4.3 - Calling Lua</A>\n  <ul>\n    <li><A href=\"#s4.3.1\">4.3.1 - Class LuaException</A>\n  </ul>\n</ul>\n<p>\n<li><A href=\"#s5\">5 - Security</A>\n<p>\n<li><a href=\"#appendix\">Appendix - API Reference</a>\n</ul>\n</nav>\n\n<!--========================================================================-->\n\n<section>\n\n<h1>1 - <span id=\"s1\">Introduction</span></h1>\n\n<p>\n<a href=\"https://github.com/vinniefalco/LuaBridge\">LuaBridge</a> is a\nlightweight and dependency-free library for mapping data, functions, and\nclasses back and forth between C++ and <a href=\"http://wwww.lua.org\">Lua</a>,\na powerful, fast, lightweight, embeddable scripting language. LuaBridge has\nbeen tested and works with Lua revisions starting from 5.1.5, although it\nshould work in any version of Lua from 5.1.0 and later. It also works\ntransparently with <a href=\"http://luajit.org/\">LuaJIT</a>.\n</p>\n\n<p>\nLuaBridge offers the following features:\n</p>\n\n<ul class=\"bullets\" title=\"Features\">\n<li><a href=\"http://www.opensource.org/licenses/mit-license.html\">MIT Licensed</a>, no usage restrictions!</li>\n<li>Headers-only: No Makefile, no .cpp files, just one <code>#include</code>!</li>\n<li>Simple, light, and nothing else needed (like Boost).</li>\n<li>No macros, settings, or configuration scripts needed.</li>\n<li>Supports different object lifetime management models.</li>\n<li>Convenient, type-safe access to the Lua stack.</li>\n<li>Automatic function parameter type binding.</li>\n<li>Easy access to Lua objects like tables and functions.</li>\n<li>Written in a clear and easy to debug style.</li>\n<li>C++11 compliant.</li>\n</ul>\n\n<p>\nLuaBridge is distributed as a a collection of header files. You simply add\none line, <code>#include \"LuaBridge/LuaBridge.h\"</code> where you want to\npass functions, classes, and variables back and forth between C++ and Lua.\nThere are no additional source files, no compilation settings, and no\nMakefiles or IDE-specific project files. LuaBridge is easy to integrate.\n</p>\n\n<p>\nC++ concepts like variables and classes are made available to Lua through a\nprocess called <em>registration</em>. Because Lua is weakly typed, the resulting\nstructure is not rigid. The API is based on C++ template metaprogramming. It\ncontains template code to automatically generate at compile-time the various\nLua C API calls necessary to export your program's classes and functions to\nthe Lua environment.\n</p>\n\n<p>\nTo expose Lua objects to C++, a class called <code>LuaRef</code> is provided.\nThe implementation allows C++ code to access Lua objects such as numbers\nor strings, but more importantly to access things like tables and their\nvalues. Using this class makes idioms like calling Lua functions simple\nand clean.\n</p>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>1.1 - <span id=\"s1.1\">Design</span></h2>\n\n<p>\nLuaBridge tries to be efficient as possible when creating the \"glue\" that\nexposes C++ data and functions to Lua. At the same time, the code was\nwritten with the intention that it is all as simple and clear as possible,\nwithout resorting to obscure C++ idioms, ugly preprocessor macros, or\nconfiguration settings. Furthermore, it is designed to be \"header-only\",\nmaking it very easy to integrate into your projects.\n</p>\n\n<p>\nBecause LuaBridge was written with simplicity in mind there are some features\nthat are not available. Although it comes close to the highest possible\nperformance, LuaBridge is not quite the fastest,\n<a href=\"http://code.google.com/p/oolua/\">OOLua</a> slightly outperforms\nLuaBridge in some tests. LuaBridge also does not try to implement every\npossible feature,\n<a href=\"http://www.rasterbar.com/products/luabind.html\">LuaBind</a>\nexplores every corner of the C++ language (but it requires Boost).\n</p>\n\n<p>\nLuaBridge does not support:\n</p>\n\n<ul class=\"bullets\">\n<li>Enumerated constants\n<li>More than 8 parameters on a function or method (although this can be\n    increased by adding more <code>TypeListValues</code> specializations).\n<li>Overloaded functions, methods, or constructors.\n<li>Global variables (variables must be wrapped in a named scope).\n<li>Automatic conversion between STL container types and Lua tables\n    (conversion can be enabled for <code>std::list</code>, <code>std::vector</code>,\n    <code>std::array</code>, <code>std::map</code>, <code>std::unordered_map</code>,\n    <code>std::pair</code> or <code>std::optional</code> by including <code>List.h</code>,\n    <code>Vector.h</code>, <code>Array.h</code>, <code>Map.h</code>,\n    <code>UnorderedMap.h</code>, <code>Pair.h</code> or <code>Optional.h</code> respectively)\n<li>Inheriting Lua classes from C++ classes.\n<li>Passing nil to a C++ function that expects a pointer or reference.\n<li>Standard containers like <code>std::shared_ptr</code>.\n</ul>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>1.2 - <span id=\"s1.2\">Repository</span></h2>\n\n<p>\nThe official repository is located at\n<a href=\"https://github.com/vinniefalco/LuaBridge\">https://github.com/vinniefalco/LuaBridge</a>.\n</p>\n\n<p>\nThe <b>master</b> branch contains published library versions. Release versions are marked with tags.\n</p>\n\n<p>\nThese repositories are also available:\n</p>\n\n<table>\n<tr>\n  <td><b><a href=\"https://github.com/vinniefalco/LuaBridgeUnitTests\">LuaBridgeUnitTests</a></b></td>\n  <td>A stand alone command line application to exercise LuaBridge functionality.</td>\n</tr>\n<tr>\n  <td><b><a href=\"https://github.com/vinniefalco/LuaBridgeDemo\">LuaBridgeUnitDemo</a></b></td>\n  <td>A stand alone GUI application that provides an interactive console.</td>\n</tr>\n</table>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>1.3 - <span id=\"s1.3\">License and Credits</span></h2>\n\n<p>\nLuaBridge is published under the terms of the\n<a href=\"http://www.opensource.org/licenses/mit-license.html\">MIT License</a>:\n</p>\n\n<pre>\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</pre>\n\n<p>\nThe original version of LuaBridge was written by Nathan Reed. The project\nhas been taken over by Vinnie Falco, who added new functionality and wrote\nthe new documentation. Vinnie also incorporated <code>LuaRef</code> and\nother Lua to C++ binding contributions from Nigel Atkinson.\n</p>\n\n<p>\nFor questions, comments, or bug reports feel free to open a Github issue\nor contact Vinnie Falco directly at the email address indicated below.\n</p>\n\n<ul>\n<li>Copyright 2019, Dmitry Tarakanov</li>\n<li>Copyright 2012, Vinnie Falco <a href=\"mailto:vinnie.falco@gmail.com\">&lt;vinnie.falco@gmail.com&gt;</a>\n<li>Copyright 2008, Nigel Atkinson <a href=\"mailto:suprapilot+LuaCode@gmail.com\">&lt;suprapilot+LuaCode@gmail.com&gt;</a>\n<li>Copyright 2007, Nathan Reed\n<li>Portions from The Loki Library: Copyright 2001 by Andrei Alexandrescu\n</ul>\n\n<p>\nOlder versions of LuaBridge up to and including 0.2 (available separately) are\ndistributed under the BSD 3-Clause License. See the corresponding license file\nin those versions (distributed separately) for more details.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n</section>\n\n<section>\n\n<h1>2 - <span id=\"s2\">Accessing C++ from Lua</span></h1>\n\n<p>\nIn order to expose C++ data and functions to Lua, each piece of exported\ninformation must be <em>registered</em>. There are five types of objects that\nLuaBridge can register:\n</p>\n\n<table>\n<tr>\n  <td><b>Namespaces</b>&nbsp;&nbsp;</td>\n  <td>A Lua table that contains other registrations.</td>\n</tr>\n<tr>\n  <td><b>Data</b>&nbsp;&nbsp;</td>\n  <td>Global or static variables, data members, and static data members.</td>\n</tr>\n<tr>\n  <td><b>Functions&nbsp;&nbsp;</b></td>\n  <td>Regular functions, member functions, and static member functions.</td>\n</tr>\n<tr>\n  <td><b>CFunctions&nbsp;&nbsp;</b></td>\n  <td>A regular function, member function, or static member function that\n      uses the <code>lua_CFunction</code> calling convention.</td>\n</tr>\n<tr>\n  <td><b>Properties&nbsp;&nbsp;</b></td>\n  <td>Global properties, property members, and static property members.\n      These appear like data to Lua, but are implemented in C++ using\n      functions to get and set the values.</td>\n  </tr>\n</table>\n\n<p>\nBoth data and properties can be marked as <em>read-only</em> at the time of\nregistration. This is different from <code>const</code>; the values of these\nobjects can be modified on the C++ side, but Lua scripts cannot change them.\nCode samples that follow are in C++ or Lua, depending on context. For brevity\nof exposition code samples in C++ assume the traditional variable\n<code>lua_State* L</code> is defined, and that a <code>using namespace luabridge</code>\nusing-directive is in effect.\n</p>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.1 - <span id=\"s2.1\">Namespaces</span></h2>\n\n<p>\nAll LuaBridge registrations take place in a <em>namespace</em>. When we refer\nto a <em>namespace</em> we are always talking about a namespace in the Lua\nsense, which is implemented using tables. The namespace need not correspond\nto a C++ namespace; in fact no C++ namespaces need to exist at all unless you\nwant them to. LuaBridge namespaces are visible only to Lua scripts; they are\nused as a logical grouping tool. To obtain access to the global namespace\nwe write:\n</p>\n\n<pre>\ngetGlobalNamespace (L);\n</pre>\n\n<p>\nThis returns an object on which further registrations can be performed. The\nsubsequent registrations will go into the global namespace, a practice which\nis not recommended. Instead, we can add our own namespace by writing:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\");\n</pre>\n\n<p>\nThis creates a table in <code>_G</code> called \"test\". Since we have not\nperformed any registrations, this table will be empty except for some\nbookkeeping key/value pairs. LuaBridge reserves all identifiers that start\nwith a double underscore. So <code>__test</code> would be an invalid name\n(although LuaBridge will silently accept it). Functions like\n<code>beginNamespace</code> return the corresponding object on which we can\nmake more registrations. Given:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .beginNamespace (\"detail\")\n    .endNamespace ()\n    .beginNamespace (\"utility\")\n    .endNamespace ()\n  .endNamespace ();\n</pre>\n\n<p>\nThe results are accessible to Lua as <code>test</code>, <code>test.detail</code>,\nand <code>test.utility</code>. Here we introduce the <code>endNamespace</code>\nfunction; it returns an object representing the original enclosing namespace.\nAll LuaBridge functions which  create registrations return an object upon which\nsubsequent registrations can be made, allowing for an unlimited number of\nregistrations to be chained together using the dot operator. Adding two objects\nwith the same name, in the same namespace, results in undefined behavior\n(although LuaBridge will silently accept it).\n</p>\n\n<p>\nA namespace can be re-opened later to add more functions. This lets you split\nup the registration between different source files. These are equivalent:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .addFunction (\"foo\", foo)\n  .endNamespace ();\n\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .addFunction (\"bar\", bar)\n  .endNamespace ();\n</pre>\n\n<p>\nand\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .addFunction (\"foo\", foo)\n    .addFunction (\"bar\", bar)\n  .endNamespace ();\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.2 - <span id=\"s2.2\">Properties and Functions</span></h2>\n\n<p>\nThese are registered into a namespace using <code>addProperty</code>\nand <code>addFunction</code>.\nWhen registered functions are called by scripts, LuaBridge automatically takes\ncare of the conversion of arguments into the appropriate data type when doing\nso is possible. This automated system works for the function's return value,\nand up to 8 parameters although more can be added by extending the templates.\nPointers, references, and objects of class type as parameters are treated\nspecially, and explained later.\n</p>\n<p>\nIf we have:\n</p>\n\n<pre>\nint globalVar;\nstatic float staticVar;\n\nstd::string stringProperty;\nstd::string getString () { return stringProperty; }\nvoid setString (std::string s) { stringProperty = s; }\n\nint foo () { return 42; }\nvoid bar (char const*) { }\nint cFunc (lua_State* L) { return 0; }\n</pre>\n\n<p>\nThese are registered with:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .addProperty (\"var1\", &amp;globalVar)\n    .addProperty (\"var2\", &amp;staticVar, false) // read-only\n    .addProperty (\"prop1\", getString, setString)\n    .addProperty (\"prop2\", getString)            // read only\n    .addFunction (\"foo\", foo)\n    .addFunction (\"bar\", bar)\n    .addFunction (\"cfunc\", cFunc)\n  .endNamespace ();\n</pre>\n\n<p>\nVariables can be marked <em>read-only</em> by passing <code>false</code> in\nthe second optional parameter. If the parameter is omitted, <em>true</em> is\nused making the variable read/write. Properties are marked read-only by\nomitting the set function. After the registrations above, the following Lua\nidentifiers are valid:\n</p>\n\n<pre>\ntest        -- a namespace\ntest.var1   -- a lua_Number property\ntest.var2   -- a read-only lua_Number property\ntest.prop1  -- a lua_String property\ntest.prop2  -- a read-only lua_String property\ntest.foo    -- a function returning a lua_Number\ntest.bar    -- a function taking a lua_String as a parameter\ntest.cfunc  -- a function with a variable argument list and multi-return\n</pre>\n\n<p>\nNote that <code>test.prop1</code> and <code>test.prop2</code> both refer to the\nsame value. However, since <code>test.prop2</code> is read-only, assignment\nattempts will generate a run-time error. These Lua statements have the stated effects:\n</p>\n\n<pre>\ntest.var1 = 5         -- okay\ntest.var2 = 6         -- error: var2 is not writable\ntest.prop1 = \"Hello\"  -- okay\ntest.prop1 = 68       -- okay, Lua converts the number to a string\ntest.prop2 = \"bar\"    -- error: prop2 is not writable\n\ntest.foo ()           -- calls foo and discards the return value\ntest.var1 = foo ()    -- calls foo and stores the result in var1\ntest.bar (\"Employee\") -- calls bar with a string\ntest.bar (test)       -- error: bar expects a string not a table\n</pre>\n\n<p>\nLuaBridge does not support overloaded functions nor is it likely to in the\nfuture. Since Lua is dynamically typed, any system that tries to resolve a set\nof parameters passed from a script will face considerable ambiguity when\ntrying to choose an appropriately matching C++ function signature.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.3 - <span id=\"s2.3\">Class Objects</span></h2>\n\n<p>\nA class registration is opened using either <code>beginClass</code> or\n<code>deriveClass</code> and ended using <code>endClass</code>. Once\nregistered, a class can later be re-opened for more registrations using\n<code>beginClass</code>. However, <code>deriveClass</code> should only be\nused once. To add more registrations to an already registered derived class,\nuse <code>beginClass</code> on it.\n</p>\n<p>\nThese declarations:\n</p>\n\n<pre>\nstruct A {\n  static int staticData;\n  static float staticProperty;\n\n  static float getStaticProperty () { return staticProperty; }\n  static void setStaticProperty (float f) { staticProperty = f; }\n  static void staticFunc () { }\n\n  static int staticCFunc (lua_State *L) { return 0; }\n\n  std::string dataMember;\n\n  char dataProperty;\n  char getProperty () const { return dataProperty; }\n  void setProperty (char v) { dataProperty = v; }\n  std::string toString () const { return dataMember; }\n\n  void func1 () { }\n  virtual void virtualFunc () { }\n\n  int cfunc (lua_State* L) { return 0; }\n};\n\nstruct B : public A {\n  double dataMember2;\n\n  void func1 () { }\n  void func2 () { }\n  void virtualFunc () { }\n};\n\nint A::staticData;\nfloat A::staticProperty;\n</pre>\n\n<p>\nare registered using:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .beginClass &lt;A&gt; (\"A\")\n      .addStaticProperty (\"staticData\", &amp;A::staticData)\n      .addStaticProperty (\"staticProperty\", &amp;A::getStaticProperty, &amp;A::setStaticProperty)\n      .addStaticFunction (\"staticFunc\", &amp;A::staticFunc)\n      .addStaticFunction (\"staticCFunc\", &amp;A::staticCFunc)\n      .addProperty (\"data\", &amp;A::dataMember)\n      .addProperty (\"prop\", &amp;A::getProperty, &amp;A::setProperty)\n      .addFunction (\"func1\", &amp;A::func1)\n      .addFunction (\"virtualFunc\", &amp;A::virtualFunc)\n      .addFunction (\"__tostring\", &amp;A::toString)     // Metamethod\n      .addFunction (\"cfunc\", &amp;A::cfunc)\n    .endClass ()\n    .deriveClass &lt;B, A&gt; (\"B\")\n      .addProperty (\"data\", &amp;B::dataMember2)\n      .addFunction (\"func1\", &amp;B::func1)\n      .addFunction (\"func2\", &amp;B::func2)\n    .endClass ()\n  .endNameSpace ();\n</pre>\n\n<p>\nMethod registration works just like function registration.  Virtual methods\nwork normally; no special syntax is needed. const methods are detected and\nconst-correctness is enforced, so if a function returns a const object (or\na container holding to a const object) to Lua, that reference to the object\nwill be considered const and only const methods can be called on it.\nIt is possible to register Lua metamethods (except <code>__gc</code>).\nDestructors are registered automatically for each class.\n</p>\n\n<p>\nAs with regular variables and properties, class properties can be\nmarked read-only by passing false in the second parameter, or omitting the set\nset function. The <code>deriveClass</code> takes two template arguments: the\nclass to be registered, and its base class.  Inherited methods do not have to\nbe re-declared and will function normally in Lua. If a class has a base class\nthat is **not** registered with Lua, there is no need to declare it as a\nsubclass.\n</p>\n\n<p>\nRemember that in Lua, the colon operator '<code>:</code>' is used for\nmethod call syntax:\n</p>\n\n<pre>\nlocal a = A ()\n\na.func1 ()  -- error: func1 expects an object of a registered class\na.func1 (a) -- okay, verbose, this how OOP works in Lua\na:func1 ()  -- okay, less verbose, equivalent to the previous\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.4 - <span id=\"s2.4\">Property Member Proxies</span></h2>\n\n<p>\nSometimes when registering a class which comes from a third party library, the\ndata is not exposed in a way that can be expressed as a pointer to member,\nthere are no get or set functions, or the get and set functions do not have the\nright function signature. Since the class declaration is closed for changes,\nLuaBridge allows for a <em>property member proxy</em>. This is a pair of get\nand set flat functions which take as their first parameter a pointer to\nthe object. This is easily understood with the following example:\n</p>\n\n<pre>\n// Third party declaration, can't be changed\nstruct Vec\n{\n  float coord [3];\n};\n</pre>\n\n<p>\nTaking the address of an array element, e.g. <code>&amp;Vec::coord [0]</code>\nresults in an error instead of a pointer-to-member. The class is closed for\nmodifications, but we want to export Vec objects to Lua using the familiar\nobject notation. To do this, first we add a \"helper\" class:\n</p>\n\n<pre>\nstruct VecHelper\n{\n  template &lt;unsigned index&gt;\n  static float get (Vec const* vec)\n  {\n    return vec->coord [index];\n  }\n\n  template &lt;unsigned index&gt;\n  static void set (Vec* vec, float value)\n  {\n    vec->coord [index] = value;\n  }\n};\n</pre>\n\n<p>\nThis helper class is only used to provide property member proxies.\n<code>Vec</code> continues to be used in the C++ code as it was before.\nNow we can register the <code>Vec</code> class with property member proxies for\n<code>x</code>, <code>y</code>, and <code>z</code>:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .beginClass &lt;Vec&gt; (\"Vec\")\n      .addProperty (\"x\", &amp;VecHelper::get &lt;0&gt;, &amp;VecHelper::set &lt;0&gt;)\n      .addProperty (\"y\", &amp;VecHelper::get &lt;1&gt;, &amp;VecHelper::set &lt;1&gt;)\n      .addProperty (\"z\", &amp;VecHelper::get &lt;2&gt;, &amp;VecHelper::set &lt;2&gt;)\n    .endClass ()\n  .endNamespace ();\n</pre>\n\n<p>\nIt is also possible to use <code>std::function &lt;&gt;</code> instances as proxies:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .beginClass &lt;Vec&gt; (\"Vec\")\n      .addProperty (\"x\",\n        std::function &lt;float (const Vec*)&gt; (\n          [] (const Vec* vec) {return vec->coord [0];}),\n        std::function &lt;void (Vec*, float)&gt; (\n          [] (Vec* vec, float v) {vec->coord [0] = v;}))\n      // ... same for \"y\" and \"z\"\n    .endClass ()\n  .endNamespace ();\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.5 - <span id=\"s2.5\">Function Member Proxies</span></h2>\n\n<p>\nWhere it is not possible or inconvenient to add a member to be registered,\nLuaBridge also allows for a <em>function member proxy</em>. This is a flat\nfunction which take as its first parameter a pointer to the object:\n</p>\n\n<pre>\n// Third party declaration, can't be changed\nstruct Vec\n{\n  float coord [3];\n};\n</pre>\n\n<p>\nThe class is closed for modifications, but we want to extend Vec objects\nwith our member function. To do this, first we add a \"helper\" function:\n</p>\n\n<pre>\nvoid scale (float value)\n{\n  value->coord [0] *= value;\n  value->coord [1] *= value;\n  value->coord [2] *= value;\n};\n</pre>\n\n<p>\nNow we can register the <code>Vec</code> class with a member function\n<code>scale</code>:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .beginClass &lt;Vec&gt; (\"Vec\")\n      .addFunction (\"scale\", &amp;scale)\n    .endClass ()\n  .endNamespace ();\n</pre>\n\n<p>\nIt is also possible to use <code>std::function &lt;&gt;</code> instances as proxies:\n</p>\n\n<pre>\ngetGlobalNamespace (L)\n  .beginClass &lt;Vec&gt; (\"Vec\")\n    .addFunction (\"scaleX\",\n      std::function &lt;void (Vec*, float)&gt; (\n        [] (Vec* vec, float v) {vec->coord [0] *= v;}))\n  .endClass ()\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.6 - <span id=\"s2.6\">Constructors</span></h2>\n\n<p>\nA single constructor may be added for a class using <code>addConstructor</code>.\nLuaBridge cannot automatically determine the number and types of constructor\nparameters like it can for functions and methods, so you must provide them.\nThis is done by specifying the signature of the desired constructor function\nas the first template parameter to <code>addConstructor</code>. The parameter\ntypes will be extracted from this (the return type is ignored).  For example,\nthese statements register constructors for the given classes:\n</p>\n\n<pre>\nstruct A\n{\n  A ();\n};\n\nstruct B\n{\n  explicit B (char const* s, int nChars);\n};\n\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .beginClass &lt;A&gt; (\"A\")\n      .addConstructor &lt;void (*) (void)&gt; ()\n    .endClass ()\n    .beginClass &lt;B&gt; (\"B\")\n      .addConstructor &lt;void (*) (char const*, int)&gt; ()\n    .endClass ()\n  .endNamespace ();\n</pre>\n\n<p>\nConstructors added in this fashion are called from Lua using the fully\nqualified name of the class. This Lua code will create instances of\n<code>A</code> and <code>B</code>.\n</p>\n\n<pre>\na = test.A ()           -- Create a new A.\nb = test.B (\"hello\", 5) -- Create a new B.\nb = test.B ()           -- Error: expected string in argument 1\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.7 - <span id=\"s2.7\">Lua Stack</span></h2>\n\n<p>\nIn the Lua C API, all operations on the <code>lua_State</code> are performed\nthrough the Lua stack. In order to pass values back and forth between C++\nand Lua, LuaBridge uses specializations of this template class concept:\n</p>\n\n<pre>\ntemplate &lt;class T&gt;\nstruct Stack\n{\n  static void push (lua_State* L, T t);\n  static T get (lua_State* L, int index);\n  static bool isInstance (lua_State* L, int index);\n};\n</pre>\n\n<p>\nWhen a specialization of <code>Stack</code> exists for a given type\n<code>T</code> we say that the <code>T</code> is <em>convertible</em>.\nThroughout this document and the LuaBridge API, these types can be used\nanywhere a convertible type is expected.\n</p>\n\n<p>\nThe Stack template class specializations are used automatically for variables,\nproperties, data members, property members, function arguments and return\nvalues. These basic types are supported:\n</p>\n\n<ul class=\"bullets\">\n<li><code>bool</code>\n<li><code>char</code>, converted to a string of length one.\n<li><code>char const*</code> and <code>std::string</code> strings.\n<li>Integers, <code>float</code>, and <code>double</code>,\n    converted to <code>Lua_number</code>.\n</ul>\n\n<p>\nUser-defined types which are convertible to one of the basic types are\npossible, simply provide a <code>Stack &lt;&gt;</code> specialization in the\n<code>luabridge</code> namespace for your user-defined type, modeled after\nthe existing types. For example, here is a specialization for a\n<code>juce::String</code>:\n</p>\n\n<pre>\ntemplate &lt;&gt;\nstruct Stack &lt;juce::String&gt;\n{\n  static void push (lua_State* L, juce::String s)\n  {\n    lua_pushstring (L, s.toUTF8 ());\n  }\n\n  static juce::String get (lua_State* L, int index)\n  {\n    return juce::String (luaL_checkstring (L, index));\n  }\n\n  static bool isInstance (lua_State* L, int index)\n  {\n    return lua_type (L, index) == LUA_TSTRING;\n  }\n};\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>2.8 - <span id=\"s2.8\">lua_State</span></h2>\n\n<p>\nSometimes it is convenient from within a bound function or member function\nto gain access to the <code>lua_State*</code> normally available to a </code>lua_CFunction</code>.\nWith LuaBridge, all you need to do is add a <code>lua_State*</code> as the last\nparameter of your bound function:\n</p>\n\n<pre>\nvoid useState (lua_State* L);\n\ngetGlobalNamespace (L).addFunction (\"useState\", &amp;useState);\n</pre>\n\n<p>\nYou can still include regular arguments while receiving the state:\n</p>\n\n<pre>\nvoid useStateAndArgs (int i, std::string s, lua_State* L);\n\ngetGlobalNamespace (L).addFunction (\"useStateAndArgs\", &amp;useStateAndArgs);\n</pre>\n\n<p>\nWhen the script calls <code>useStateAndArgs</code>, it passes only the integer\nand string parameters. LuaBridge takes care of inserting the <code>lua_State*</code>\ninto the argument list for the corresponding C++ function. This will work\ncorrectly even for the state created by coroutines. Undefined behavior results\nif the <code>lua_State*</code> is not the last parameter.\n</p>\n\n<p>\nThe same is applicable for properties.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n</section>\n\n<section>\n\n<h1>3 - <span id=\"s3\">Passing Objects</span></h1>\n\n<p>\nAn object of a registered class <code>T</code> may be passed to Lua as:\n</p>\n\n<table>\n<tr>\n  <td><b><code>T</code></b></td>\n  <td>Passed by value (a copy), with <em>Lua lifetime</em>.</td>\n</tr>\n<tr>\n  <td><b><code>T const</code></b></td>\n  <td>Passed by value (a copy), with <em>Lua lifetime</em>.</td>\n</tr>\n<tr>\n  <td><b><code>T*</code></b></td>\n  <td>Passed by reference, with <em>C++ lifetime</em>.</td>\n</tr>\n<tr>\n  <td><b><code>T&amp;</code></b></td>\n  <td>Passed by reference, with <em>C++ lifetime</em>.</td>\n</tr>\n<tr>\n  <td><b><code>T const*</code></b></td>\n  <td>Passed by const reference, with <em>C++ lifetime</em>.</td>\n</tr>\n<tr>\n  <td><b><code>T const&amp;</code></b></td>\n  <td>Passed by const reference, with <em>C++ lifetime</em>.</td>\n</tr>\n</table>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>3.1 - <span id=\"s3.1\">C++ Lifetime</span></h2>\n\n<p>\nThe creation and deletion of objects with <em>C++ lifetime</em> is controlled by\nthe C++ code. Lua does nothing when it garbage collects a reference to such an\nobject. Specifically, the object's destructor is not called (since C++ owns\nit). Care must be taken to ensure that objects with C++ lifetime are not\ndeleted while still being referenced by a <code>lua_State*</code>, or else\nundefined behavior results. In the previous examples, an instance of <code>A</code>\ncan be passed to Lua with C++ lifetime, like this:\n</p>\n\n<pre>\nA a;\n\npush (L, &amp;a);             // pointer to 'a', C++ lifetime\nlua_setglobal (L, \"a\");\n\npush (L, (A const*) &amp;a);   // pointer to 'a const', C++ lifetime\nlua_setglobal (L, \"ac\");\n\npush &lt;A const*&gt; (L, &amp;a);  // equivalent to push (L, (A const*) &amp;a)\nlua_setglobal (L, \"ac2\");\n\npush (L, new A);          // compiles, but will leak memory\nlua_setglobal (L, \"ap\");\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>3.2 - <span id=\"s3.2\">Lua Lifetime</span></h2>\n\n<p>\nWhen an object of a registered class is passed by value to Lua, it will have\n<em>Lua lifetime</em>. A copy of the passed object is constructed inside the\nuserdata. When Lua has no more references to the object, it becomes eligible\nfor garbage collection. When the userdata is collected, the destructor for\nthe class will be called on the object. Care must be taken to ensure that\nobjects with Lua lifetime are not accessed by C++ after they are garbage\ncollected, or else undefined behavior results. An instance of <code>B</code>\ncan be passed to Lua with Lua lifetime this way:\n</p>\n\n<pre>\nB b;\n\npush (L, b);                    // Copy of b passed, Lua lifetime.\nlua_setglobal (L, \"b\");\n</pre>\n\n<p>\nGiven the previous code segments, these Lua statements are applicable:\n</p>\n\n<pre>\nprint (test.A.staticData)       -- Prints the static data member.\nprint (test.A.staticProperty)   -- Prints the static property member.\ntest.A.staticFunc ()            -- Calls the static method.\n\nprint (a.data)                  -- Prints the data member.\nprint (a.prop)                  -- Prints the property member.\na:func1 ()                      -- Calls A::func1 ().\ntest.A.func1 (a)                -- Equivalent to a:func1 ().\ntest.A.func1 (\"hello\")          -- Error: \"hello\" is not a class A.\na:virtualFunc ()                -- Calls A::virtualFunc ().\n\nprint (b.data)                  -- Prints B::dataMember.\nprint (b.prop)                  -- Prints inherited property member.\nb:func1 ()                      -- Calls B::func1 ().\nb:func2 ()                      -- Calls B::func2 ().\ntest.B.func2 (a)                -- Error: a is not a class B.\ntest.A.func1 (b)                -- Calls A::func1 ().\nb:virtualFunc ()                -- Calls B::virtualFunc ().\ntest.B.virtualFunc (b)          -- Calls B::virtualFunc ().\ntest.A.virtualFunc (b)          -- Calls B::virtualFunc ().\ntest.B.virtualFunc (a)          -- Error: a is not a class B.\n\na = nil; collectgarbage ()      -- 'a' still exists in C++.\nb = nil; collectgarbage ()      -- Lua calls ~B() on the copy of b.\n</pre>\n\n<p>\nWhen Lua script creates an object of class type using a registered\nconstructor, the resulting value will have Lua lifetime. After Lua no longer\nreferences the object, it becomes eligible for garbage collection. You can\nstill pass these to C++, either by reference or by value. If passed by\nreference, the usual warnings apply about accessing the reference later,\nafter it has been garbage collected.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>3.3 - <span id=\"s3.3\">Pointers, References, and Pass by Value</span></h2>\n\n<p>\nWhen C++ objects are passed from Lua back to C++ as arguments to functions,\nor set as data members, LuaBridge does its best to automate the conversion.\nUsing the previous definitions, the following functions may be registered\nto Lua:\n</p>\n\n<pre>\nvoid func0 (A a);\nvoid func1 (A* a);\nvoid func2 (A const* a);\nvoid func3 (A&amp; a);\nvoid func4 (A const&amp; a);\n</pre>\n\n<p>\nExecuting this Lua code will have the prescribed effect:\n</p>\n\n<pre>\nfunc0 (a)   -- Passes a copy of a, using A's copy constructor.\nfunc1 (a)   -- Passes a pointer to a.\nfunc2 (a)   -- Passes a pointer to a const a.\nfunc3 (a)   -- Passes a reference to a.\nfunc4 (a)   -- Passes a reference to a const a.\n</pre>\n\n<p>\nIn the example above, all functions can read the data members and property\nmembers of <code>a</code>, or call const member functions of <code>a</code>.\nOnly <code>func0</code>, <code>func1</code>, and <code>func3</code> can\nmodify the data members and data properties, or call non-const member\nfunctions of <code>a</code>.\n</p>\n\n<p>\nThe usual C++ inheritance and pointer assignment rules apply. Given:\n</p>\n\n<pre>\nvoid func5 (B b);\nvoid func6 (B* b);\n</pre>\n\n<p>\nThese Lua statements hold:\n</p>\n\n<pre>\nfunc5 (b)   - Passes a copy of b, using B's copy constructor.\nfunc6 (b)   - Passes a pointer to b.\nfunc6 (a)   - Error: Pointer to B expected.\nfunc1 (b)   - Okay, b is a subclass of a.\n</pre>\n\n<p>\nWhen a pointer or pointer to const is passed to Lua and the pointer is null\n(zero), LuaBridge will pass Lua a <code>nil</code> instead. When Lua passes a\n<code>nil</code> to C++ where a pointer is expected, a null (zero) is passed\ninstead. Attempting to pass a null pointer to a C++ function expecting a\nreference results in <code>lua_error</code> being called.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>3.4 - <span id=\"s3.4\">Shared Lifetime</span></h2>\n\n<p>\nLuaBridge supports a <em>shared lifetime</em> model: dynamically allocated\nand reference counted objects whose ownership is shared by both Lua and C++.\nThe object remains in existence until there are no remaining C++ or Lua\nreferences, and Lua performs its usual garbage collection cycle. A container\nis recognized by a specialization of the <code>ContainerTraits</code>\ntemplate class. LuaBridge will automatically recognize when a data type is\na container when the corresponding specialization is present. Two styles of\ncontainers come with LuaBridge, including the necessary specializations.\n</p>\n\n<!--========================================================================-->\n\n<section>\n\n<h3>3.4.1 - <span id=\"s3.4.1\">Class RefCountedObjectPtr</span></h3>\n\n<p>\nThis is an intrusive style container. Your existing class declaration must be\nchanged to be also derived from <code>RefCountedObject</code>. Given\n<code>class T</code>, derived from <code>RefCountedObject</code>, the container\n<code>RefCountedObjectPtr &lt;T&gt;</code> may be used. In order for\nreference counts to be maintained properly, all C++ code must store a\ncontainer instead of the pointer. This is similar in style to\n<code>std::shared_ptr</code> although there are slight differences. For\nexample:\n</p>\n\n<pre>\n// A is reference counted.\nstruct A : public RefCountedObject\n{\n  void foo () { }\n};\n\nstruct B\n{\n  RefCountedObjectPtr &lt;A&gt; a; // holds a reference to A\n};\n\nvoid bar (RefCountedObjectPtr &lt;A&gt; a)\n{\n  a->foo ();\n}\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h3>3.4.2 - <span id=\"s3.4.2\">Class RefCountedPtr</span></h3>\n\n<p>\nThis is a non intrusive reference counted pointer. The reference counts are\nkept in a global hash table, which does incur a small performance penalty.\nHowever, it does not require changing any already existing class declarations.\nThis is especially useful when the classes to be registered come from a third\nparty library and cannot be modified. To use it, simply wrap all pointers\nto class objects with the container instead:\n</p>\n\n<pre>\nstruct A\n{\n  void foo () { }\n};\n\nstruct B\n{\n  RefCountedPtr &lt;A&gt; a;\n};\n\nRefCountedPtr &lt;A&gt; createA ()\n{\n  return new A;\n}\n\nvoid bar (RefCountedPtr &lt;A&gt; a)\n{\n  a->foo ();\n}\n\nvoid callFoo ()\n{\n  bar (createA ());\n\n  // The created A will be destroyed\n  // when we leave this scope\n}\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h3>3.4.3 - <span id=\"s3.4.3\">User-defined Containers</span></h3>\n\n<p>\nIf you have your own container, you must provide a specialization of\n<code>ContainerTraits</code> in the <code>luabridge</code> namespace for your\ntype before it will be recognized by LuaBridge (or else the code will not\ncompile):\n</p>\n\n<pre>\ntemplate &lt;class T&gt;\nstruct ContainerTraits &lt;CustomContainer &lt;T&gt; &gt;\n{\n  typedef typename T Type;\n\n  static T* get (CustomContainer &lt;T&gt; const&amp; c)\n  {\n    return c.getPointerToObject ();\n  }\n};\n</pre>\n\n<p>\nStandard containers like <code>std::shared_ptr</code> or\n<code>boost::shared_ptr</code> <b>will not work</b>. This is because of type\nerasure; when the object goes from C++ to Lua and back to C++, there is no\nway to associate the object with the original container. The new container is\nconstructed from a pointer to the object instead of an existing container.\nThe result is undefined behavior since there are now two sets of reference\ncounts.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h3>3.4.4 - <span id=\"s3.4.4\">Container Constructors</span></h3>\n\n<p>\nWhen a constructor is registered for a class, there is an additional\noptional second template parameter describing the type of container to use.\nIf this parameter is specified, calls to the constructor will create the\nobject dynamically, via operator new, and place it a container of that\ntype. The container must have been previously specialized in\n<code>ContainerTraits</code>, or else a compile error will result. This code\nwill register two objects, each using a constructor that creates an object\nwith Lua lifetime using the specified container:\n</p>\n\n<pre>\nclass C : public RefCountedObject\n{\n  C () { }\n};\n\nclass D\n{\n  D () { }\n};\n\ngetGlobalNamespace (L)\n  .beginNamespace (\"test\")\n    .beginClass &lt;C&gt; (\"C\")\n      .addConstructor &lt;void (*) (void), RefCountedObjectPtr &lt;C&gt; &gt; ()\n    .endClass ()\n    .beginClass &lt;D&gt; (\"D\")\n      .addConstructor &lt;void (*) (void), RefCountedPtr &lt;D&gt; &gt; ()\n    .endClass ();\n  .endNamespace ()\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n</section>\n\n<section>\n\n<h2>3.5 - <span id=\"s3.5\">Mixing Lifetimes</span></h2>\n\n<p>\nMixing object lifetime models is entirely possible, subject to the usual\ncaveats of holding references to objects which could get deleted. For\nexample, C++ can be called from Lua with a pointer to an object of class\ntype; the function can modify the object or call non-const data members.\nThese modifications are visible to Lua (since they both refer to the same\nobject). An object store in a container can be passed to a function expecting\na pointer. These conversion work seamlessly.\n<p>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>3.6 - <span id=\"s3.6\">Convenience Functions</span></h2>\n\n<p>\nThe <code>setGlobal</code> function can be used to assign any convertible\nvalue into a global variable.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n</section>\n\n<section>\n\n<h1>4 - <span id=\"s4\">Accessing Lua from C++</span></h1>\n\n<p>\nBecause Lua is a <em>dynamically typed language</em>, special consideration\nis required to map values in Lua to C++. The following sections describe the\nclasses and functions used for representing Lua types. Only the essential\noperations are explained; To gain understanding of all available functions,\nplease refer to the documentation comments in the corresponding source files.\n</p>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>4.1 - <span id=\"s4.1\">Class LuaRef</span></h2>\n\n<p>\nThe <code>LuaRef</code> class is a container which references any Lua type.\nIt can hold anything which a Lua variable can hold: <strong>nil</strong>,\nnumber, boolean, string, table, function, thread, userdata, and\nlightuserdata. Because <code>LuaRef</code> uses the <code>Stack</code>\ntemplate specializations to do its work, classes, functions, and data\nexported to Lua through namespace registrations can also be stored (these\nare instances of userdata). In general, a <code>LuaRef</code> can represent\nany <em>convertible</em> C++ type as well as all Lua types.\n</p>\n\n<p>\nA <code>LuaRef</code> variable constructed with no parameters produces a\nreference to <strong>nil</strong>:\n</p>\n\n<pre>\nLuaRef v (L); // References nil\n</pre>\n\n<p>\nTo construct a <code>LuaRef</code> to a specific value, the two parameter\nconstructor is used:\n</p>\n\n<pre>\nLuaRef v1 (L, 1);                   // A LUA_TNUMBER\nLuaRef v2 (L, 1.1);                 // Also a LUA_TNUMBER\nLuaRef v3 (L, true);                // A LUA_TBOOLEAN\nLuaRef v4 (L, \"string\");            // A LUA_TSTRING\n</pre>\n\n<p>\nThe functions <code>newTable</code> and <code>getGlobal</code> create\nreferences to new empty table and an existing value in the global table\nrespectively:\n</p>\n\n<pre>\nLuaRef v1 = newTable (L);           // Create a new table\nLuaRef v2 = getGlobal (L, \"print\")  // Reference to _G [\"print\"]\n</pre>\n\n<p>\nA <code>LuaRef</code> can hold classes <em>registered</em> using LuaBridge:\n</p>\n\n<pre>\nclass A;\n//...\nLuaRef v (L, new A); // A LuaBridge userdata holding a pointer to A\n</pre>\n\n<p>\nAny convertible type may be assigned to an already-existing <code>LuaRef</code>:\n</p>\n\n<pre>\nLuaRef v (L);         // Nil\nv = newTable (L);     // An empty table\nv = \"string\"          // A string. The previous value becomes\n                      // eligible for garbage collection.\n</pre>\n\n<p>\nA <code>LuaRef</code> is itself a convertible type, and the convertible\ntype <code>Nil</code> can be used to represent a Lua <strong>nil</strong>.\n</p>\n\n<pre>\nLuaRef v1 (L, \"x\");   // assign \"x\"\nLuaRef v2 (L, \"y\");   // assign \"y\"\nv2 = v1;              // v2 becomes \"x\"\nv1 = \"z\";             // v1 becomes \"z\", v2 is unchanged\nv1 = newTable (L);    // An empty table\nv2 = v1;              // v2 references the same table as v1\nv1 = Nil ();          // v1 becomes nil, table is still\n                      // referenced by v2.\n</pre>\n\n<p>\nValues stored in a <code>LuaRef</code> object obey the same rules as\nvariables in Lua: tables, functions, threads, and full userdata values are\n<em>objects</em>. The <code>LuaRef</code> does not actually <em>contain</em>\nthese values, only <em>references</em> to them. Assignment, parameter\npassing, and function returns always manipulate references to such values;\nthese operations do not imply any kind of copy.\n</p>\n\n<!--========================================================================-->\n\n<section>\n\n<h3>4.1.1 - <span id=\"s4.1.1\">Type Conversions</span></h3>\n\n<p>\nA universal C++ conversion operator is provided for implicit conversions\nwhich allow a <code>LuaRef</code> to be used where any convertible type is\nexpected. These operations will all compile:\n</p>\n\n<pre>\nvoid passInt (int);\nvoid passBool (bool);\nvoid passString (std::string);\nvoid passObject (A*);\n\nLuaRef v (L);\n//...\npassInt (v);        // implicit conversion to int\npassBool (v);       // implicit conversion to bool\npassString (v);     // implicit conversion to string\npassObject (v);     // must hold a registered LuaBridge class or a\n                    // lua_error() will be called.\n</pre>\n\n<p>\nSince Lua types are dynamic, the conversion is performed at run time using\ntraditional functions like <code>lua_toboolean</code> or\n<code>lua_tostring</code>. In some cases, the type information may be\nincorrect especially when passing objects of registered class types.\nWhen performing these conversions, LuaBridge may raise a Lua error by\ndirectly or indirectly calling <code>lua_error</code> To be bullet-proof,\nsuch code must either be wrapped in a <code>lua_pcall</code>, or you must\ninstall a Lua <em>panic function</em> that throws an exception which you\ncan catch.\n</p>\n\n<p>\nWhen an explicit conversion is required (such as when writing templates),\nuse the <code>cast</code> template function or an explicit C++ style cast.\n</p>\n\n<pre>\nvoid passString (std::string);\n\nLuaRef v (L);\n\n// The following are all equivalent:\n\npassString (std::string (v));\npassString ((std::string)v);\npassString (static_cast &lt;std::string&gt; (v));\npassString (v.cast &lt;std::string&gt; ());\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n</section>\n\n<section>\n\n<h2>4.2 - <span id=\"s4.2\">Table Proxies</span></h2>\n\n<p>\nAs tables are the sole data structuring mechanism in Lua, the\n<code>LuaRef</code> class provides robust facilities for accessing and\nmanipulating table elements using a simple, precise syntax. Any convertible\ntype may be used as a key or value. Applying the array indexing operator\n<code>[]</code> to a <code>LuaRef</code> returns a special temporary object\ncalled a <em>table proxy</em> which supports all the operations which can\nbe performed on a <code>LuaRef</code>. In addition, assignments made to\ntable proxies change the underlying table. Because table proxies are\ncompiler-created temporary objects, you don't work with them directly. A\nLuaBridge table proxy should not be confused with the Lua proxy table\ntechnique described in the book \"Programming in Lua\"; the LuaBridge table\nproxy is simply an intermediate C++ class object that works behind the\nscenes to make table manipulation syntax conform to C++ idioms. These\noperations all invoke table proxies:\n</p>\n\n<pre>\nLuaRef v (L);\nv = newTable (L);\n\nv [\"name\"] = \"John Doe\";      // string key, string value\nv [1] = 200;                  // integer key, integer value\nv [2] = newTable (L);         // integer key, LuaRef value\nv [3] = v [1];                // assign 200 to integer index 3\nv [1] = 100;                  // v[1] is 100, v[3] is still 200\nv [3] = v [2];                // v[2] and v[3] reference the same table\nv [2] = Nil ();               // Removes the value with key = 2. The table\n                              //   is still referenced by v[3].\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h2>4.3 - <span id=\"s4.3\">Calling Lua</span></h2>\n\n<p>\nTable proxies and <code>LuaRef</code> objects provide a convenient syntax\nfor invoking <code>lua_pcall</code> on suitable referenced object. This\nincludes C functions, Lua functions, or Lua objects with an appropriate\n<code>__call</code> metamethod set. The provided implementation supports\nup to eight parameters (although more can be supported by adding new\nfunctions). Any convertible C++ type can be passed as a parameter in its\nnative format. The return value of the function call is provided as a\n<code>LuaRef</code>, which may be <strong>nil</strong>.\n</p>\n\n<pre class=\"split\">\nLuaRef same = getGlobal (L, \"same\");\n\n// These all evaluate to true\nsame (1,1);\n!same (1,2);\nsame (\"text\", \"text\");\n!same (1, \"text\");\nsame (1, 1, 2); // third param ignored\n</pre>\n\n<pre class=\"split\">\nfunction same (arg1, arg)\n  return arg1 == arg2\nend\n</pre>\n\n<p>\nTable proxies support all of the Lua call notation that <code>LuaRef</code>\nsupports, making these statements possible:\n</p>\n\n<pre class=\"split\">\nLuaRef v = getGlobal (L, \"t\");\n\nt[1]();\nt[2](\"a\", \"b\");\nt[2](t[1]); // Call t[3] with the value in t[2]\nt[4]=t[3]();   // Call t[3] and store the result in t[4].\n\nt [t[5]()] = \"wow\"; // Store \"wow\" at the key returned by\n                    //   the call to t[5]\n</pre>\n\n<pre class=\"split\">\nt = {}\nt[1] = function () print (\"hello\") end\nt[2] = function (u, v) print (u, v) end\nt[3] = \"foo\"\n</pre>\n\n<!--========================================================================-->\n\n<h3>4.3.1 - <span id=\"s4.3.1\">Class LuaException</span></h3>\n\n<section >\n\n<p>\nWhen <code>LuaRef</code> is used to call into Lua using the <code>()</code>\noperator it issues a protected call using <code>lua_pcall</code>. LuaBridge\nuses the C++ exception handling mechanism, throwing a <code>LuaException</code>\nobject:\n</p>\n\n<pre class=\"split\">\nLuaRef f (L) = getGlobal (L, \"fail\");\n\ntry {\n  f ();\n}\ncatch (LuaException const&amp; e) {\n  std::cerr &amp;&amp; e.what ();\n}\n</pre>\n\n<pre class=\"split\">\nfunction fail ()\n  error (\"A problem occurred\")\nend\n</pre>\n\n</section>\n\n<!--========================================================================-->\n\n</section>\n\n<!--========================================================================-->\n\n</section>\n\n<section>\n\n<h1>5 - <span id=\"s5\">Security</span></h1>\n\n<p>\nThe metatables and userdata that LuaBridge creates in the <code>lua_State*</code> are\nprotected using a security system, to eliminate the possibility of undefined\nbehavior resulting from scripted manipulation of the environment. The\nsecurity system has these components:\n</p>\n\n<ul class=\"bullets\">\n<li>\nClass and const class tables use the <em>table proxy</em> technique. The\ncorresponding metatables have <code>__index</code> and <code>__newindex</code>\nmetamethods, so these class tables are immutable from Lua.\n<li>\nMetatables have <code>__metatable</code> set to a boolean value. Scripts\ncannot obtain the metatable from a LuaBridge object.\n<li>\nClasses are mapped to metatables through the registry, which Lua scripts\ncannot access. The global environment does not expose metatables\n<li>\nMetatables created by LuaBridge are tagged with a lightuserdata key which\nis unique in the process. Other libraries cannot forge a LuaBridge\nmetatable.\n</ul>\n\n<p>\nThis security system can be easily bypassed if scripts are given access to\nthe debug library (or functionality similar to it, i.e. a raw <code>getmetatable</code>).\nThe security system can also be defeated by C code in the host, either by\nrevealing the unique lightuserdata key to another module or by putting a\nLuaBridge metatable in a place that can be accessed by scripts.\n</p>\n\n<p>\nWhen a class member function is called, or class property member accessed,\nthe <code>this</code> pointer is type-checked. This is because member functions exposed\nto Lua are just plain functions that usually get called with the Lua colon\nnotation, which passes the object in question as the first parameter. Lua's\ndynamic typing makes this type-checking mandatory to prevent undefined\nbehavior resulting from improper use.\n</p>\n\n<p>\nIf a type check error occurs, LuaBridge uses the <code>lua_error</code>\nmechanism to trigger a failure. A host program can always recover from\nan error through the use of <code>lua_pcall</code>; proper usage of\nLuaBridge will never result in undefined behavior.\n</p>\n\n</section>\n\n<!--========================================================================-->\n\n<section>\n\n<h1>Appendix - <span id=\"appendix\">API Reference</span></h1>\n\n<h2>Free Functions</h2>\n\n<pre>\n/// Gets a global Lua variable reference.\n///\nLuaRef getGlobal(lua_State* L, const char* name);\n</pre>\n\n<pre>\n/// Sets a global Lua variable.\n///\ntemplate&lt;class V&gt;\nvoid setGlobal(lua_State* L, V* varPtr, const char* name);\n</pre>\n\n<pre>\n/// Gets the global namespace registration object.\n///\nNamespace getGlobalNamespace(lua_State* L);\n</pre>\n\n<h2>Namespace Registration - Namespace</h2>\n\n<pre>\n/// Begins or continues class registration, returns this class object.\n///\ntemplate&lt;class T&gt;\nClass&lt;T&gt; beginClass(const char* name);\n</pre>\n\n<pre>\n/// Begins derived class registration, returns this class object.\n///\ntemplate&lt;class T, class Base&gt;\nClass&lt;T&gt; deriveClass(const char* name);\n</pre>\n\n<pre>\n/// Begin or continues namespace registration, returns this namespace object.\n///\ntemplate&lt;class T&gt;\nNamespace beginNamespace(const char* name);\n</pre>\n\n<pre>\n/// Ends namespace registration, returns the parent namespace object.\n///\ntemplate&lt;class T&gt;\nNamespace endNamespace();\n</pre>\n\n<pre>\n/// Registers a function.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addFunction(const char* name,\n                      R (*fn)(Params...));\n</pre>\n\n<pre>\n/// Registers a function.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addFunction(const char* name,\n                      std::function&lt;R (Params...)&gt; fn);\n</pre>\n\n<pre>\n/// Registers a function with an extra Lua state parameter.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addFunction(const char* name,\n                      R (*fn)(Params..., lua_State*))\n</pre>\n\n<pre>\n/// Registers a C-function.\n///\nNamespace addFunction(const char* name,\n                      int (*fn)(lua_State*));\n</pre>\n\n<pre>\n/// Registers a property with a getter and setter.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      V (*getFn)(),\n                      void (*setFn)(V));\n</pre>\n\n<pre>\n/// Registers a property with a getter and setter.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      std::function&lt;V ()&gt; getFn,\n                      std::function&lt;void (V)&gt; setFn);\n</pre>\n\n<pre>\n/// Registers a property with a C-function getter and setter.\n///\nNamespace addProperty(const char* name,\n                      int (*getFn)(lua_State*),\n                      int (*setFn)(lua_State*));\n</pre>\n\n<pre>\n/// Registers a read-only property with a getter function.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      V (*getFn)());\n</pre>\n\n<pre>\n/// Registers a read-only property with a getter function.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      std::function&lt;V ()&gt; getFn);\n</pre>\n\n<pre>\n/// Registers a read-only property with a C-function getter.\n///\nNamespace addProperty(const char* name,\n                      int (*getFn)(lua_State*));\n</pre>\n\n<pre>\n/// Registers a variable, writable or read-only.\n///\ntemplate&lt;class V&gt;\nNamespace addVariable(const char* name,\n                      V* varPtr,\n                      bool isWritable = true);\n</pre>\n\n<h2>Class Registration - Class&lt;T&gt;</h2>\n\n<pre>\n/// Ends class registration, returns the parent namespace object.\n///\ntemplate&lt;class T&gt;\nNamespace endClass();\n</pre>\n\n<h3>Member Function Registration</h3>\n\n<pre>\n/// Registers a member function.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addFunction(const char* name,\n                      R (T::* fn)(Params...));\n</pre>\n\n<pre>\n/// Registers a function.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addFunction(const char* name,\n                      std::function&lt;R (Params...)&gt; fn);\n</pre>\n\n<pre>\n/// Registers a function with an extra Lua state parameter.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addFunction(const char* name,\n                      R (T::* fn)(Params..., lua_State*))\n</pre>\n\n<pre>\n/// Registers a C-function.\n///\nNamespace addFunction(const char* name,\n                      int (*fn)(lua_State*));\n</pre>\n\n<h3>Member Property Registration</h3>\n\n<pre>\n/// Registers a property with a getter and setter.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      V (T::* getFn)(),\n                      void (T::* setFn)(V));\n</pre>\n\n<pre>\n/// Registers a property with a getter and setter.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      std::function&lt;V ()&gt; getFn,\n                      std::function&lt;void (V)&gt; setFn);\n</pre>\n\n<pre>\n/// Registers a property with a C-function getter and setter.\n///\nNamespace addProperty(const char* name,\n                      int (*getFn)(lua_State*),\n                      int (*setFn)(lua_State*));\n</pre>\n\n<pre>\n/// Registers a read-only property with a getter member function.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      V (T::* getFn)());\n</pre>\n\n<pre>\n/// Registers a read-only property with a getter function.\n///\ntemplate&lt;class V&gt;\nNamespace addProperty(const char* name,\n                      std::function&lt;V ()&gt; getFn);\n</pre>\n\n<pre>\n/// Registers a read-only property with a C-function getter.\n///\nNamespace addProperty(const char* name,\n                      int (*getFn)(lua_State*));\n</pre>\n\n<pre>\n/// Registers a member variable, writable or read-only.\n///\ntemplate&lt;class V&gt;\nNamespace addData(const char* name,\n                  V T::* varPtr,\n                  bool isWritable = true);\n</pre>\n\n<h3>Static Function Registration</h3>\n\n<pre>\n/// Registers a function.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addStaticFunction(const char* name,\n                            R (*fn)(Params...));\n</pre>\n\n<pre>\n/// Registers a function.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addStaticFunction(const char* name,\n                            std::function&lt;R (Params...)&gt; fn);\n</pre>\n\n<pre>\n/// Registers a function with an extra Lua state parameter.\n///\ntemplate&lt;class R, class... Params>&gt;\nNamespace addStaticFunction(const char* name,\n                            R (*fn)(Params..., lua_State*))\n</pre>\n\n<pre>\n/// Registers a C-function.\n///\nNamespace addStaticFunction(const char* name,\n                            int (*fn)(lua_State*));\n</pre>\n\n<h3>Static Property Registration</h3>\n\n<pre>\n/// Registers a property with a getter and setter.\n///\ntemplate&lt;class V&gt;\nNamespace addStaticProperty(const char* name,\n                            V (*getFn)(),\n                            void (*setFn)(V));\n</pre>\n\n<pre>\n/// Registers a property with a getter and setter.\n///\ntemplate&lt;class V&gt;\nNamespace addStaticProperty(const char* name,\n                            std::function&lt;V ()&gt; getFn,\n                            std::function&lt;void (V)&gt; setFn);\n</pre>\n\n<pre>\n/// Registers a property with a C-function getter and setter.\n///\nNamespace addStaticProperty(const char* name,\n                            int (*getFn)(lua_State*),\n                            int (*setFn)(lua_State*));\n</pre>\n\n<pre>\n/// Registers a read-only property with a getter function.\n///\ntemplate&lt;class V&gt;\nNamespace addStaticProperty(const char* name,\n                            V (*getFn)());\n</pre>\n\n<pre>\n/// Registers a read-only property with a getter function.\n///\ntemplate&lt;class V&gt;\nNamespace addStaticProperty(const char* name,\n                            std::function&lt;V ()&gt; getFn);\n</pre>\n\n<pre>\n/// Registers a read-only property with a C-function getter.\n///\nNamespace addStaticProperty(const char* name,\n                            int (*getFn)(lua_State*));\n</pre>\n\n<pre>\n/// Registers a variable, writable or read-only.\n///\nNamespace addStaticData(const char* name,\n                        T* varPtr,\n                        bool isWritable = true);\n</pre>\n\n<h2>Lua Variable Reference - LuaRef</h2>\n\n<pre>\n/// Creates a nil reference.\n///\nLuaRef(lua_State* L);\n</pre>\n\n<pre>\n/// Returns native Lua string representation.\n///\nstd::string tostring() const;\n</pre>\n\n<pre>\n/// Dumps reference to a stream.\n///\nvoid print(std::ostream& stream) const;\n</pre>\n\n<pre>\n/// Returns the Lua state.\n///\nlua_State* state() const;\n</pre>\n\n<pre>\n/// Place the object onto the Lua stack.\n///\nvoid push(lua_State* L);\n</pre>\n\n<pre>\n/// Return the lua_type.\n///\nint type() const;\n</pre>\n\n<pre>\n/// Perform the explicit type conversion.\n///\ntemplate&lt;class T&gt;\nT cast() const;\n</pre>\n\n<pre>\n/// Check if the Lua value is convertible to the type T.\n///\ntemplate&lt;class T&gt;\nbool isInstance() const;\n</pre>\n\n<h2>Stack Traits - Stack&lt;T&gt;</h2>\n\n<pre>\n/// Converts the C++ value into the Lua value at the top of the Lua stack.\n///\nvoid put (lua_State* L, T value);\n</pre>\n\n<pre>\n/// Converts the Lua value at the index into the C++ value of the type T.\n///\nT get (lua_State* L, int index);\n</pre>\n\n<pre>\n/// Checks if the Lua value at the index is convertible into the C++ value of the type T.\n///\nbool isInstance (lua_State* L, int index);\n</pre>\n\n</section>\n\n</body>\n</html>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6064453125,
          "content": "<a href=\"http://lua.org\">\n<img src=\"http://vinniefalco.github.io/LuaBridgeDemo/powered-by-lua.png\">\n</a><br>\n\n# LuaBridge 2.8\n\n[LuaBridge][1] is a lightweight and dependency-free library for mapping data,\nfunctions, and classes back and forth between C++ and [Lua][2] (a powerful,\nfast, lightweight, embeddable scripting language). LuaBridge has been tested\nand works with Lua revisions starting from 5.1.5, although it should work in\nany version of Lua from 5.1.0 as well as [LuaJit][3].\n\nLuaBridge offers the following features:\n\n- [MIT Licensed][4]\n- A printable [Reference Manual][5].\n- Headers-only: No Makefile, no .cpp files, just one #include!\n- Simple, light, and nothing else needed (like Boost).\n- No macros, settings, or configuration scripts needed.\n- Supports different object lifetime management models.\n- Convenient, type-safe access to the Lua stack.\n- Automatic function parameter type binding.\n- Easy access to Lua objects like tables and functions.\n- Written in a clear and easy to debug style.\n\nPlease read the [LuaBridge Reference Manual][5] for more details on the API.\n\n## Unit Tests\n\nUnit test build requires a CMake and C++11 compliant compiler.\n\nTo enable C++17 features (`std::optional` and `std::string_view`) specify an extra option: `-DLUABRIDGE_CXX17=1`.\n\nThere are the following unit test flavors:\n* `Tests51` - uses Lua 5.1.5\n* `Tests51Cxx17` - uses Lua 5.1.5 and C++17 features\n* `Tests52` - uses Lua 5.2.4,\n* `Tests52Cxx17` - uses Lua 5.2.4 and C++17 features\n* `Tests53` - uses Lua 5.3.6\n* `Tests53Cxx17` - uses Lua 5.3.6 and C++17 features\n* `Tests54` - uses Lua 5.4.4\n* `Tests54Cxx17` - uses Lua 5.4.4 and C++17 features\n\nBuild using Make on Linux/MacOS:\n```bash\nclone --recurse-submodules git@github.com:vinniefalco/LuaBridge.git\ncd LuaBridge\ncmake -DCMAKE_BUILD_TYPE=Debug -B build\n# or cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -B build\n# or cmake -DCMAKE_BUILD_TYPE=Release -B build\ncd build\nmake -j\n```\n\nGenerate XCode project on MacOS:\n```bash\nclone --recurse-submodules git@github.com:vinniefalco/LuaBridge.git\ncd LuaBridge\ncmake -G Xcode -B build\n# Generates XCode project build/LuaBridge.xcodeproj\n```\n\nGenerate MSVS solution on Windows:\n```cmd\nclone --recurse-submodules git@github.com:vinniefalco/LuaBridge.git\ncd LuaBridge\nmkdir build\ncd build\ncmake -G \"Visual Studio 17 2022 Win64\" -B build\n# or cmake -G \"Visual Studio 15 2017 Win64\" -B build\n# or cmake -G \"Visual Studio 14 2015\" -B build\n# or cmake -G \"Visual Studio 15 2017 Win64\" -B build\n# or cmake -G \"Visual Studio 15 2017\" -B build\n# or cmake -G \"Visual Studio 15 2019\" -A Win64 -B build\n# or cmake -G \"Visual Studio 15 2019\" -B build\n# Generates MSVS solution build/LuaBridge.sln\n```\n\n## Installing LuaBridge (vcpkg)\n\nYou can download and install LuaBridge using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n```Powershell or bash\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh # The name of the script should be \"./bootstrap-vcpkg.bat\" for Powershell\n./vcpkg integrate install\n./vcpkg install luabridge\n```\n\nThe LuaBridge port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n\n## Official Repository\n\nLuaBridge is published under the terms of the [MIT License][4].\n\nThe original version of LuaBridge was written by Nathan Reed. The project has\nbeen taken over by [Vinnie Falco][7], who added new functionality, wrote the new\ndocumentation, and incorporated contributions from Nigel Atkinson.\n\nFor questions, comments, or bug reports feel free to open a Github issue\nor contact Vinnie Falco directly at the email address indicated below.\n\nCopyright 2019, Dmitry Tarakanov<br>\nCopyright 2012, [Vinnie Falco][7] (<[vinnie.falco@gmail.com][8]>)<br>\nCopyright 2008, Nigel Atkinson<br>\nCopyright 2007, Nathan Reed<br>\n\nPortions from The Loki Library:<br>\nCopyright (C) 2001 by Andrei Alexandrescu\n\nOlder versions of LuaBridge up to and including 0.2 are distributed under the\nBSD 3-Clause License. See the corresponding license file in those versions\n(distributed separately) for more details.\n\n[1]:  https://github.com/vinniefalco/LuaBridge \"LuaBridge\"\n[2]:  http://lua.org \"The Lua Programming Language\"\n[3]:  http://luajit.org/ \"The LuaJIT Probject\"\n[4]:  http://www.opensource.org/licenses/mit-license.html \"The MIT License\"\n[5]:  http://vinniefalco.github.io/LuaBridge \"LuaBridge Reference Manual\"\n[6]:  https://github.com/vinniefalco/LuaBridgeDemo \"LuaBridge Demo\"\n[7]:  https://github.com/vinniefalco \"Vinnie Falco's Github\"\n[8]:  mailto:vinnie.falco@gmail.com \"Vinnie Falco (Email)\"\n"
        },
        {
          "name": "Source",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 0.3212890625,
          "content": "<!-- Simple redirect to bring up the reference manual. -->\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html>\n<head>\n<title>LuaBridge Reference Manual</title>\n<meta http-equiv=\"REFRESH\" content=\"0;url=Manual.html\"></HEAD>\n<BODY>\nRedirecting to the <a HREF=\"Manual.html\">LuaBridge reference manual</a>.\n</BODY>\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 1.158203125,
          "content": "project('LuaBridge', 'cpp',\n  license: 'MIT',\n  default_options: ['cpp_std=c++17'],\n)\n\ninstall_headers([\n  'Source/LuaBridge/List.h',\n  'Source/LuaBridge/LuaBridge.h',\n  'Source/LuaBridge/Map.h',\n  'Source/LuaBridge/RefCountedObject.h',\n  'Source/LuaBridge/RefCountedPtr.h',\n  'Source/LuaBridge/UnorderedMap.h',\n  'Source/LuaBridge/Vector.h',\n  'Source/LuaBridge/Array.h',\n  ], subdir: 'LuaBridge')\ninstall_headers([\n  'Source/LuaBridge/detail/CFunctions.h',\n  'Source/LuaBridge/detail/ClassInfo.h',\n  'Source/LuaBridge/detail/Config.h',\n  'Source/LuaBridge/detail/Constructor.h',\n  'Source/LuaBridge/detail/dump.h',\n  'Source/LuaBridge/detail/FuncTraits.h',\n  'Source/LuaBridge/detail/Iterator.h',\n  'Source/LuaBridge/detail/LuaException.h',\n  'Source/LuaBridge/detail/LuaHelpers.h',\n  'Source/LuaBridge/detail/LuaRef.h',\n  'Source/LuaBridge/detail/Namespace.h',\n  'Source/LuaBridge/detail/Stack.h',\n  'Source/LuaBridge/detail/TypeList.h',\n  'Source/LuaBridge/detail/TypeTraits.h',\n  'Source/LuaBridge/detail/Userdata.h',\n  ], subdir: 'LuaBridge/detail')\n\nluabridge_dep = declare_dependency(\n  include_directories: include_directories('Source'),\n  compile_args: '-DLUABRIDGE_CXX17',\n)\n"
        },
        {
          "name": "third_party",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}